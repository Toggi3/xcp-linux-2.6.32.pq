# HG changeset patch
# Parent f4bf81a7ff2057532c3aaa76428a6643b9786466

diff -r f4bf81a7ff20 drivers/net/Kconfig
--- a/drivers/net/Kconfig
+++ b/drivers/net/Kconfig
@@ -2292,29 +2292,6 @@ config TIGON3
 	  To compile this driver as a module, choose M here: the module
 	  will be called tg3.  This is recommended.
 
-config BNX2
-	tristate "Broadcom NetXtremeII support"
-	depends on PCI
-	select CRC32
-	select FW_LOADER
-	help
-	  This driver supports Broadcom NetXtremeII gigabit Ethernet cards.
-
-	  To compile this driver as a module, choose M here: the module
-	  will be called bnx2.  This is recommended.
-
-config CNIC
-	tristate "Broadcom CNIC support"
-	depends on PCI
-	select BNX2
-	select UIO
-	help
-	  This driver supports offload features of Broadcom NetXtremeII
-	  gigabit Ethernet cards.
-
-	  To compile this driver as a module, choose M here: the module
-	  will be called cnic.  This is recommended.
-
 config SPIDER_NET
 	tristate "Spider Gigabit Ethernet driver"
 	depends on PCI && (PPC_IBM_CELL_BLADE || PPC_CELLEB)
@@ -2760,18 +2737,6 @@ config TEHUTI
 	help
 	  Tehuti Networks 10G Ethernet NIC
 
-config BNX2X
-	tristate "Broadcom NetXtremeII 10Gb support"
-	depends on PCI
-	select FW_LOADER
-	select ZLIB_INFLATE
-	select LIBCRC32C
-	select MDIO
-	help
-	  This driver supports Broadcom NetXtremeII 10 gigabit Ethernet cards.
-	  To compile this driver as a module, choose M here: the module
-	  will be called bnx2x.  This is recommended.
-
 config QLGE
 	tristate "QLogic QLGE 10Gb Ethernet Driver Support"
 	depends on PCI
diff -r f4bf81a7ff20 drivers/net/Makefile
--- a/drivers/net/Makefile
+++ b/drivers/net/Makefile
@@ -81,10 +81,6 @@ obj-$(CONFIG_NS83820) += ns83820.o
 obj-$(CONFIG_STNIC) += stnic.o 8390.o
 obj-$(CONFIG_FEALNX) += fealnx.o
 obj-$(CONFIG_TIGON3) += tg3/
-obj-$(CONFIG_BNX2) += bnx2.o
-obj-$(CONFIG_CNIC) += cnic.o
-obj-$(CONFIG_BNX2X) += bnx2x.o
-bnx2x-objs := bnx2x_main.o bnx2x_link.o
 spidernet-y += spider_net.o spider_net_ethtool.o
 obj-$(CONFIG_SPIDER_NET) += spidernet.o sungem_phy.o
 obj-$(CONFIG_GELIC_NET) += ps3_gelic.o
diff -r f4bf81a7ff20 drivers/net/bnx2.c
--- a/drivers/net/bnx2.c
+++ /dev/null
@@ -1,8531 +0,0 @@
-/* bnx2.c: Broadcom NX2 network driver.
- *
- * Copyright (c) 2004-2009 Broadcom Corporation
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation.
- *
- * Written by: Michael Chan  (mchan@broadcom.com)
- */
-
-
-#include <linux/module.h>
-#include <linux/moduleparam.h>
-
-#include <linux/kernel.h>
-#include <linux/timer.h>
-#include <linux/errno.h>
-#include <linux/ioport.h>
-#include <linux/slab.h>
-#include <linux/vmalloc.h>
-#include <linux/interrupt.h>
-#include <linux/pci.h>
-#include <linux/init.h>
-#include <linux/netdevice.h>
-#include <linux/etherdevice.h>
-#include <linux/skbuff.h>
-#include <linux/dma-mapping.h>
-#include <linux/bitops.h>
-#include <asm/io.h>
-#include <asm/irq.h>
-#include <linux/delay.h>
-#include <asm/byteorder.h>
-#include <asm/page.h>
-#include <linux/time.h>
-#include <linux/ethtool.h>
-#include <linux/mii.h>
-#include <linux/if_vlan.h>
-#if defined(CONFIG_VLAN_8021Q) || defined(CONFIG_VLAN_8021Q_MODULE)
-#define BCM_VLAN 1
-#endif
-#include <net/ip.h>
-#include <net/tcp.h>
-#include <net/checksum.h>
-#include <linux/workqueue.h>
-#include <linux/crc32.h>
-#include <linux/prefetch.h>
-#include <linux/cache.h>
-#include <linux/firmware.h>
-#include <linux/log2.h>
-#include <linux/list.h>
-
-#if defined(CONFIG_CNIC) || defined(CONFIG_CNIC_MODULE)
-#define BCM_CNIC 1
-#include "cnic_if.h"
-#endif
-#include "bnx2.h"
-#include "bnx2_fw.h"
-
-#define DRV_MODULE_NAME		"bnx2"
-#define PFX DRV_MODULE_NAME	": "
-#define DRV_MODULE_VERSION	"2.0.4"
-#define DRV_MODULE_RELDATE	"Mar 03, 2010"
-#define FW_MIPS_FILE_06		"bnx2/bnx2-mips-06-5.0.0.j6.fw"
-#define FW_RV2P_FILE_06		"bnx2/bnx2-rv2p-06-5.0.0.j3.fw"
-#define FW_MIPS_FILE_09		"bnx2/bnx2-mips-09-5.0.0.j9.fw"
-#define FW_RV2P_FILE_09_Ax	"bnx2/bnx2-rv2p-09ax-5.0.0.j10.fw"
-#define FW_RV2P_FILE_09		"bnx2/bnx2-rv2p-09-5.0.0.j10.fw"
-
-#define RUN_AT(x) (jiffies + (x))
-
-/* Time in jiffies before concluding the transmitter is hung. */
-#define TX_TIMEOUT  (5*HZ)
-
-static char version[] __devinitdata =
-	"Broadcom NetXtreme II Gigabit Ethernet Driver " DRV_MODULE_NAME " v" DRV_MODULE_VERSION " (" DRV_MODULE_RELDATE ")\n";
-
-MODULE_AUTHOR("Michael Chan <mchan@broadcom.com>");
-MODULE_DESCRIPTION("Broadcom NetXtreme II BCM5706/5708/5709/5716 Driver");
-MODULE_LICENSE("GPL");
-MODULE_VERSION(DRV_MODULE_VERSION);
-MODULE_FIRMWARE(FW_MIPS_FILE_06);
-MODULE_FIRMWARE(FW_RV2P_FILE_06);
-MODULE_FIRMWARE(FW_MIPS_FILE_09);
-MODULE_FIRMWARE(FW_RV2P_FILE_09);
-MODULE_FIRMWARE(FW_RV2P_FILE_09_Ax);
-
-static int entropy = 0;
-module_param(entropy, int, 0);
-MODULE_PARM_DESC(entropy, "Allow bnx2 to populate the /dev/random entropy pool");
-
-static int disable_msi = 0;
-
-module_param(disable_msi, int, 0);
-MODULE_PARM_DESC(disable_msi, "Disable Message Signaled Interrupt (MSI)");
-
-typedef enum {
-	BCM5706 = 0,
-	NC370T,
-	NC370I,
-	BCM5706S,
-	NC370F,
-	BCM5708,
-	BCM5708S,
-	BCM5709,
-	BCM5709S,
-	BCM5716,
-	BCM5716S,
-} board_t;
-
-/* indexed by board_t, above */
-static struct {
-	char *name;
-} board_info[] __devinitdata = {
-	{ "Broadcom NetXtreme II BCM5706 1000Base-T" },
-	{ "HP NC370T Multifunction Gigabit Server Adapter" },
-	{ "HP NC370i Multifunction Gigabit Server Adapter" },
-	{ "Broadcom NetXtreme II BCM5706 1000Base-SX" },
-	{ "HP NC370F Multifunction Gigabit Server Adapter" },
-	{ "Broadcom NetXtreme II BCM5708 1000Base-T" },
-	{ "Broadcom NetXtreme II BCM5708 1000Base-SX" },
-	{ "Broadcom NetXtreme II BCM5709 1000Base-T" },
-	{ "Broadcom NetXtreme II BCM5709 1000Base-SX" },
-	{ "Broadcom NetXtreme II BCM5716 1000Base-T" },
-	{ "Broadcom NetXtreme II BCM5716 1000Base-SX" },
-	};
-
-static DEFINE_PCI_DEVICE_TABLE(bnx2_pci_tbl) = {
-	{ PCI_VENDOR_ID_BROADCOM, PCI_DEVICE_ID_NX2_5706,
-	  PCI_VENDOR_ID_HP, 0x3101, 0, 0, NC370T },
-	{ PCI_VENDOR_ID_BROADCOM, PCI_DEVICE_ID_NX2_5706,
-	  PCI_VENDOR_ID_HP, 0x3106, 0, 0, NC370I },
-	{ PCI_VENDOR_ID_BROADCOM, PCI_DEVICE_ID_NX2_5706,
-	  PCI_ANY_ID, PCI_ANY_ID, 0, 0, BCM5706 },
-	{ PCI_VENDOR_ID_BROADCOM, PCI_DEVICE_ID_NX2_5708,
-	  PCI_ANY_ID, PCI_ANY_ID, 0, 0, BCM5708 },
-	{ PCI_VENDOR_ID_BROADCOM, PCI_DEVICE_ID_NX2_5706S,
-	  PCI_VENDOR_ID_HP, 0x3102, 0, 0, NC370F },
-	{ PCI_VENDOR_ID_BROADCOM, PCI_DEVICE_ID_NX2_5706S,
-	  PCI_ANY_ID, PCI_ANY_ID, 0, 0, BCM5706S },
-	{ PCI_VENDOR_ID_BROADCOM, PCI_DEVICE_ID_NX2_5708S,
-	  PCI_ANY_ID, PCI_ANY_ID, 0, 0, BCM5708S },
-	{ PCI_VENDOR_ID_BROADCOM, PCI_DEVICE_ID_NX2_5709,
-	  PCI_ANY_ID, PCI_ANY_ID, 0, 0, BCM5709 },
-	{ PCI_VENDOR_ID_BROADCOM, PCI_DEVICE_ID_NX2_5709S,
-	  PCI_ANY_ID, PCI_ANY_ID, 0, 0, BCM5709S },
-	{ PCI_VENDOR_ID_BROADCOM, 0x163b,
-	  PCI_ANY_ID, PCI_ANY_ID, 0, 0, BCM5716 },
-	{ PCI_VENDOR_ID_BROADCOM, 0x163c,
-	  PCI_ANY_ID, PCI_ANY_ID, 0, 0, BCM5716S },
-	{ 0, }
-};
-
-static const struct flash_spec flash_table[] =
-{
-#define BUFFERED_FLAGS		(BNX2_NV_BUFFERED | BNX2_NV_TRANSLATE)
-#define NONBUFFERED_FLAGS	(BNX2_NV_WREN)
-	/* Slow EEPROM */
-	{0x00000000, 0x40830380, 0x009f0081, 0xa184a053, 0xaf000400,
-	 BUFFERED_FLAGS, SEEPROM_PAGE_BITS, SEEPROM_PAGE_SIZE,
-	 SEEPROM_BYTE_ADDR_MASK, SEEPROM_TOTAL_SIZE,
-	 "EEPROM - slow"},
-	/* Expansion entry 0001 */
-	{0x08000002, 0x4b808201, 0x00050081, 0x03840253, 0xaf020406,
-	 NONBUFFERED_FLAGS, SAIFUN_FLASH_PAGE_BITS, SAIFUN_FLASH_PAGE_SIZE,
-	 SAIFUN_FLASH_BYTE_ADDR_MASK, 0,
-	 "Entry 0001"},
-	/* Saifun SA25F010 (non-buffered flash) */
-	/* strap, cfg1, & write1 need updates */
-	{0x04000001, 0x47808201, 0x00050081, 0x03840253, 0xaf020406,
-	 NONBUFFERED_FLAGS, SAIFUN_FLASH_PAGE_BITS, SAIFUN_FLASH_PAGE_SIZE,
-	 SAIFUN_FLASH_BYTE_ADDR_MASK, SAIFUN_FLASH_BASE_TOTAL_SIZE*2,
-	 "Non-buffered flash (128kB)"},
-	/* Saifun SA25F020 (non-buffered flash) */
-	/* strap, cfg1, & write1 need updates */
-	{0x0c000003, 0x4f808201, 0x00050081, 0x03840253, 0xaf020406,
-	 NONBUFFERED_FLAGS, SAIFUN_FLASH_PAGE_BITS, SAIFUN_FLASH_PAGE_SIZE,
-	 SAIFUN_FLASH_BYTE_ADDR_MASK, SAIFUN_FLASH_BASE_TOTAL_SIZE*4,
-	 "Non-buffered flash (256kB)"},
-	/* Expansion entry 0100 */
-	{0x11000000, 0x53808201, 0x00050081, 0x03840253, 0xaf020406,
-	 NONBUFFERED_FLAGS, SAIFUN_FLASH_PAGE_BITS, SAIFUN_FLASH_PAGE_SIZE,
-	 SAIFUN_FLASH_BYTE_ADDR_MASK, 0,
-	 "Entry 0100"},
-	/* Entry 0101: ST M45PE10 (non-buffered flash, TetonII B0) */
-	{0x19000002, 0x5b808201, 0x000500db, 0x03840253, 0xaf020406,
-	 NONBUFFERED_FLAGS, ST_MICRO_FLASH_PAGE_BITS, ST_MICRO_FLASH_PAGE_SIZE,
-	 ST_MICRO_FLASH_BYTE_ADDR_MASK, ST_MICRO_FLASH_BASE_TOTAL_SIZE*2,
-	 "Entry 0101: ST M45PE10 (128kB non-bufferred)"},
-	/* Entry 0110: ST M45PE20 (non-buffered flash)*/
-	{0x15000001, 0x57808201, 0x000500db, 0x03840253, 0xaf020406,
-	 NONBUFFERED_FLAGS, ST_MICRO_FLASH_PAGE_BITS, ST_MICRO_FLASH_PAGE_SIZE,
-	 ST_MICRO_FLASH_BYTE_ADDR_MASK, ST_MICRO_FLASH_BASE_TOTAL_SIZE*4,
-	 "Entry 0110: ST M45PE20 (256kB non-bufferred)"},
-	/* Saifun SA25F005 (non-buffered flash) */
-	/* strap, cfg1, & write1 need updates */
-	{0x1d000003, 0x5f808201, 0x00050081, 0x03840253, 0xaf020406,
-	 NONBUFFERED_FLAGS, SAIFUN_FLASH_PAGE_BITS, SAIFUN_FLASH_PAGE_SIZE,
-	 SAIFUN_FLASH_BYTE_ADDR_MASK, SAIFUN_FLASH_BASE_TOTAL_SIZE,
-	 "Non-buffered flash (64kB)"},
-	/* Fast EEPROM */
-	{0x22000000, 0x62808380, 0x009f0081, 0xa184a053, 0xaf000400,
-	 BUFFERED_FLAGS, SEEPROM_PAGE_BITS, SEEPROM_PAGE_SIZE,
-	 SEEPROM_BYTE_ADDR_MASK, SEEPROM_TOTAL_SIZE,
-	 "EEPROM - fast"},
-	/* Expansion entry 1001 */
-	{0x2a000002, 0x6b808201, 0x00050081, 0x03840253, 0xaf020406,
-	 NONBUFFERED_FLAGS, SAIFUN_FLASH_PAGE_BITS, SAIFUN_FLASH_PAGE_SIZE,
-	 SAIFUN_FLASH_BYTE_ADDR_MASK, 0,
-	 "Entry 1001"},
-	/* Expansion entry 1010 */
-	{0x26000001, 0x67808201, 0x00050081, 0x03840253, 0xaf020406,
-	 NONBUFFERED_FLAGS, SAIFUN_FLASH_PAGE_BITS, SAIFUN_FLASH_PAGE_SIZE,
-	 SAIFUN_FLASH_BYTE_ADDR_MASK, 0,
-	 "Entry 1010"},
-	/* ATMEL AT45DB011B (buffered flash) */
-	{0x2e000003, 0x6e808273, 0x00570081, 0x68848353, 0xaf000400,
-	 BUFFERED_FLAGS, BUFFERED_FLASH_PAGE_BITS, BUFFERED_FLASH_PAGE_SIZE,
-	 BUFFERED_FLASH_BYTE_ADDR_MASK, BUFFERED_FLASH_TOTAL_SIZE,
-	 "Buffered flash (128kB)"},
-	/* Expansion entry 1100 */
-	{0x33000000, 0x73808201, 0x00050081, 0x03840253, 0xaf020406,
-	 NONBUFFERED_FLAGS, SAIFUN_FLASH_PAGE_BITS, SAIFUN_FLASH_PAGE_SIZE,
-	 SAIFUN_FLASH_BYTE_ADDR_MASK, 0,
-	 "Entry 1100"},
-	/* Expansion entry 1101 */
-	{0x3b000002, 0x7b808201, 0x00050081, 0x03840253, 0xaf020406,
-	 NONBUFFERED_FLAGS, SAIFUN_FLASH_PAGE_BITS, SAIFUN_FLASH_PAGE_SIZE,
-	 SAIFUN_FLASH_BYTE_ADDR_MASK, 0,
-	 "Entry 1101"},
-	/* Ateml Expansion entry 1110 */
-	{0x37000001, 0x76808273, 0x00570081, 0x68848353, 0xaf000400,
-	 BUFFERED_FLAGS, BUFFERED_FLASH_PAGE_BITS, BUFFERED_FLASH_PAGE_SIZE,
-	 BUFFERED_FLASH_BYTE_ADDR_MASK, 0,
-	 "Entry 1110 (Atmel)"},
-	/* ATMEL AT45DB021B (buffered flash) */
-	{0x3f000003, 0x7e808273, 0x00570081, 0x68848353, 0xaf000400,
-	 BUFFERED_FLAGS, BUFFERED_FLASH_PAGE_BITS, BUFFERED_FLASH_PAGE_SIZE,
-	 BUFFERED_FLASH_BYTE_ADDR_MASK, BUFFERED_FLASH_TOTAL_SIZE*2,
-	 "Buffered flash (256kB)"},
-};
-
-static const struct flash_spec flash_5709 = {
-	.flags		= BNX2_NV_BUFFERED,
-	.page_bits	= BCM5709_FLASH_PAGE_BITS,
-	.page_size	= BCM5709_FLASH_PAGE_SIZE,
-	.addr_mask	= BCM5709_FLASH_BYTE_ADDR_MASK,
-	.total_size	= BUFFERED_FLASH_TOTAL_SIZE*2,
-	.name		= "5709 Buffered flash (256kB)",
-};
-
-MODULE_DEVICE_TABLE(pci, bnx2_pci_tbl);
-
-static inline u32 bnx2_tx_avail(struct bnx2 *bp, struct bnx2_tx_ring_info *txr)
-{
-	u32 diff;
-
-	smp_mb();
-
-	/* The ring uses 256 indices for 255 entries, one of them
-	 * needs to be skipped.
-	 */
-	diff = txr->tx_prod - txr->tx_cons;
-	if (unlikely(diff >= TX_DESC_CNT)) {
-		diff &= 0xffff;
-		if (diff == TX_DESC_CNT)
-			diff = MAX_TX_DESC_CNT;
-	}
-	return (bp->tx_ring_size - diff);
-}
-
-static u32
-bnx2_reg_rd_ind(struct bnx2 *bp, u32 offset)
-{
-	u32 val;
-
-	spin_lock_bh(&bp->indirect_lock);
-	REG_WR(bp, BNX2_PCICFG_REG_WINDOW_ADDRESS, offset);
-	val = REG_RD(bp, BNX2_PCICFG_REG_WINDOW);
-	spin_unlock_bh(&bp->indirect_lock);
-	return val;
-}
-
-static void
-bnx2_reg_wr_ind(struct bnx2 *bp, u32 offset, u32 val)
-{
-	spin_lock_bh(&bp->indirect_lock);
-	REG_WR(bp, BNX2_PCICFG_REG_WINDOW_ADDRESS, offset);
-	REG_WR(bp, BNX2_PCICFG_REG_WINDOW, val);
-	spin_unlock_bh(&bp->indirect_lock);
-}
-
-static void
-bnx2_shmem_wr(struct bnx2 *bp, u32 offset, u32 val)
-{
-	bnx2_reg_wr_ind(bp, bp->shmem_base + offset, val);
-}
-
-static u32
-bnx2_shmem_rd(struct bnx2 *bp, u32 offset)
-{
-	return (bnx2_reg_rd_ind(bp, bp->shmem_base + offset));
-}
-
-static void
-bnx2_ctx_wr(struct bnx2 *bp, u32 cid_addr, u32 offset, u32 val)
-{
-	offset += cid_addr;
-	spin_lock_bh(&bp->indirect_lock);
-	if (CHIP_NUM(bp) == CHIP_NUM_5709) {
-		int i;
-
-		REG_WR(bp, BNX2_CTX_CTX_DATA, val);
-		REG_WR(bp, BNX2_CTX_CTX_CTRL,
-		       offset | BNX2_CTX_CTX_CTRL_WRITE_REQ);
-		for (i = 0; i < 5; i++) {
-			val = REG_RD(bp, BNX2_CTX_CTX_CTRL);
-			if ((val & BNX2_CTX_CTX_CTRL_WRITE_REQ) == 0)
-				break;
-			udelay(5);
-		}
-	} else {
-		REG_WR(bp, BNX2_CTX_DATA_ADR, offset);
-		REG_WR(bp, BNX2_CTX_DATA, val);
-	}
-	spin_unlock_bh(&bp->indirect_lock);
-}
-
-#ifdef BCM_CNIC
-static int
-bnx2_drv_ctl(struct net_device *dev, struct drv_ctl_info *info)
-{
-	struct bnx2 *bp = netdev_priv(dev);
-	struct drv_ctl_io *io = &info->data.io;
-
-	switch (info->cmd) {
-	case DRV_CTL_IO_WR_CMD:
-		bnx2_reg_wr_ind(bp, io->offset, io->data);
-		break;
-	case DRV_CTL_IO_RD_CMD:
-		io->data = bnx2_reg_rd_ind(bp, io->offset);
-		break;
-	case DRV_CTL_CTX_WR_CMD:
-		bnx2_ctx_wr(bp, io->cid_addr, io->offset, io->data);
-		break;
-	default:
-		return -EINVAL;
-	}
-	return 0;
-}
-
-static void bnx2_setup_cnic_irq_info(struct bnx2 *bp)
-{
-	struct cnic_eth_dev *cp = &bp->cnic_eth_dev;
-	struct bnx2_napi *bnapi = &bp->bnx2_napi[0];
-	int sb_id;
-
-	if (bp->flags & BNX2_FLAG_USING_MSIX) {
-		cp->drv_state |= CNIC_DRV_STATE_USING_MSIX;
-		bnapi->cnic_present = 0;
-		sb_id = bp->irq_nvecs;
-		cp->irq_arr[0].irq_flags |= CNIC_IRQ_FL_MSIX;
-	} else {
-		cp->drv_state &= ~CNIC_DRV_STATE_USING_MSIX;
-		bnapi->cnic_tag = bnapi->last_status_idx;
-		bnapi->cnic_present = 1;
-		sb_id = 0;
-		cp->irq_arr[0].irq_flags &= ~CNIC_IRQ_FL_MSIX;
-	}
-
-	cp->irq_arr[0].vector = bp->irq_tbl[sb_id].vector;
-	cp->irq_arr[0].status_blk = (void *)
-		((unsigned long) bnapi->status_blk.msi +
-		(BNX2_SBLK_MSIX_ALIGN_SIZE * sb_id));
-	cp->irq_arr[0].status_blk_num = sb_id;
-	cp->num_irq = 1;
-}
-
-static int bnx2_register_cnic(struct net_device *dev, struct cnic_ops *ops,
-			      void *data)
-{
-	struct bnx2 *bp = netdev_priv(dev);
-	struct cnic_eth_dev *cp = &bp->cnic_eth_dev;
-
-	if (ops == NULL)
-		return -EINVAL;
-
-	if (cp->drv_state & CNIC_DRV_STATE_REGD)
-		return -EBUSY;
-
-	bp->cnic_data = data;
-	rcu_assign_pointer(bp->cnic_ops, ops);
-
-	cp->num_irq = 0;
-	cp->drv_state = CNIC_DRV_STATE_REGD;
-
-	bnx2_setup_cnic_irq_info(bp);
-
-	return 0;
-}
-
-static int bnx2_unregister_cnic(struct net_device *dev)
-{
-	struct bnx2 *bp = netdev_priv(dev);
-	struct bnx2_napi *bnapi = &bp->bnx2_napi[0];
-	struct cnic_eth_dev *cp = &bp->cnic_eth_dev;
-
-	mutex_lock(&bp->cnic_lock);
-	cp->drv_state = 0;
-	bnapi->cnic_present = 0;
-	rcu_assign_pointer(bp->cnic_ops, NULL);
-	mutex_unlock(&bp->cnic_lock);
-	synchronize_rcu();
-	return 0;
-}
-
-struct cnic_eth_dev *bnx2_cnic_probe(struct net_device *dev)
-{
-	struct bnx2 *bp = netdev_priv(dev);
-	struct cnic_eth_dev *cp = &bp->cnic_eth_dev;
-
-	cp->drv_owner = THIS_MODULE;
-	cp->chip_id = bp->chip_id;
-	cp->pdev = bp->pdev;
-	cp->io_base = bp->regview;
-	cp->drv_ctl = bnx2_drv_ctl;
-	cp->drv_register_cnic = bnx2_register_cnic;
-	cp->drv_unregister_cnic = bnx2_unregister_cnic;
-
-	return cp;
-}
-EXPORT_SYMBOL(bnx2_cnic_probe);
-
-static void
-bnx2_cnic_stop(struct bnx2 *bp)
-{
-	struct cnic_ops *c_ops;
-	struct cnic_ctl_info info;
-
-	mutex_lock(&bp->cnic_lock);
-	c_ops = bp->cnic_ops;
-	if (c_ops) {
-		info.cmd = CNIC_CTL_STOP_CMD;
-		c_ops->cnic_ctl(bp->cnic_data, &info);
-	}
-	mutex_unlock(&bp->cnic_lock);
-}
-
-static void
-bnx2_cnic_start(struct bnx2 *bp)
-{
-	struct cnic_ops *c_ops;
-	struct cnic_ctl_info info;
-
-	mutex_lock(&bp->cnic_lock);
-	c_ops = bp->cnic_ops;
-	if (c_ops) {
-		if (!(bp->flags & BNX2_FLAG_USING_MSIX)) {
-			struct bnx2_napi *bnapi = &bp->bnx2_napi[0];
-
-			bnapi->cnic_tag = bnapi->last_status_idx;
-		}
-		info.cmd = CNIC_CTL_START_CMD;
-		c_ops->cnic_ctl(bp->cnic_data, &info);
-	}
-	mutex_unlock(&bp->cnic_lock);
-}
-
-#else
-
-static void
-bnx2_cnic_stop(struct bnx2 *bp)
-{
-}
-
-static void
-bnx2_cnic_start(struct bnx2 *bp)
-{
-}
-
-#endif
-
-static int
-bnx2_read_phy(struct bnx2 *bp, u32 reg, u32 *val)
-{
-	u32 val1;
-	int i, ret;
-
-	if (bp->phy_flags & BNX2_PHY_FLAG_INT_MODE_AUTO_POLLING) {
-		val1 = REG_RD(bp, BNX2_EMAC_MDIO_MODE);
-		val1 &= ~BNX2_EMAC_MDIO_MODE_AUTO_POLL;
-
-		REG_WR(bp, BNX2_EMAC_MDIO_MODE, val1);
-		REG_RD(bp, BNX2_EMAC_MDIO_MODE);
-
-		udelay(40);
-	}
-
-	val1 = (bp->phy_addr << 21) | (reg << 16) |
-		BNX2_EMAC_MDIO_COMM_COMMAND_READ | BNX2_EMAC_MDIO_COMM_DISEXT |
-		BNX2_EMAC_MDIO_COMM_START_BUSY;
-	REG_WR(bp, BNX2_EMAC_MDIO_COMM, val1);
-
-	for (i = 0; i < 50; i++) {
-		udelay(10);
-
-		val1 = REG_RD(bp, BNX2_EMAC_MDIO_COMM);
-		if (!(val1 & BNX2_EMAC_MDIO_COMM_START_BUSY)) {
-			udelay(5);
-
-			val1 = REG_RD(bp, BNX2_EMAC_MDIO_COMM);
-			val1 &= BNX2_EMAC_MDIO_COMM_DATA;
-
-			break;
-		}
-	}
-
-	if (val1 & BNX2_EMAC_MDIO_COMM_START_BUSY) {
-		*val = 0x0;
-		ret = -EBUSY;
-	}
-	else {
-		*val = val1;
-		ret = 0;
-	}
-
-	if (bp->phy_flags & BNX2_PHY_FLAG_INT_MODE_AUTO_POLLING) {
-		val1 = REG_RD(bp, BNX2_EMAC_MDIO_MODE);
-		val1 |= BNX2_EMAC_MDIO_MODE_AUTO_POLL;
-
-		REG_WR(bp, BNX2_EMAC_MDIO_MODE, val1);
-		REG_RD(bp, BNX2_EMAC_MDIO_MODE);
-
-		udelay(40);
-	}
-
-	return ret;
-}
-
-static int
-bnx2_write_phy(struct bnx2 *bp, u32 reg, u32 val)
-{
-	u32 val1;
-	int i, ret;
-
-	if (bp->phy_flags & BNX2_PHY_FLAG_INT_MODE_AUTO_POLLING) {
-		val1 = REG_RD(bp, BNX2_EMAC_MDIO_MODE);
-		val1 &= ~BNX2_EMAC_MDIO_MODE_AUTO_POLL;
-
-		REG_WR(bp, BNX2_EMAC_MDIO_MODE, val1);
-		REG_RD(bp, BNX2_EMAC_MDIO_MODE);
-
-		udelay(40);
-	}
-
-	val1 = (bp->phy_addr << 21) | (reg << 16) | val |
-		BNX2_EMAC_MDIO_COMM_COMMAND_WRITE |
-		BNX2_EMAC_MDIO_COMM_START_BUSY | BNX2_EMAC_MDIO_COMM_DISEXT;
-	REG_WR(bp, BNX2_EMAC_MDIO_COMM, val1);
-
-	for (i = 0; i < 50; i++) {
-		udelay(10);
-
-		val1 = REG_RD(bp, BNX2_EMAC_MDIO_COMM);
-		if (!(val1 & BNX2_EMAC_MDIO_COMM_START_BUSY)) {
-			udelay(5);
-			break;
-		}
-	}
-
-	if (val1 & BNX2_EMAC_MDIO_COMM_START_BUSY)
-        	ret = -EBUSY;
-	else
-		ret = 0;
-
-	if (bp->phy_flags & BNX2_PHY_FLAG_INT_MODE_AUTO_POLLING) {
-		val1 = REG_RD(bp, BNX2_EMAC_MDIO_MODE);
-		val1 |= BNX2_EMAC_MDIO_MODE_AUTO_POLL;
-
-		REG_WR(bp, BNX2_EMAC_MDIO_MODE, val1);
-		REG_RD(bp, BNX2_EMAC_MDIO_MODE);
-
-		udelay(40);
-	}
-
-	return ret;
-}
-
-static void
-bnx2_disable_int(struct bnx2 *bp)
-{
-	int i;
-	struct bnx2_napi *bnapi;
-
-	for (i = 0; i < bp->irq_nvecs; i++) {
-		bnapi = &bp->bnx2_napi[i];
-		REG_WR(bp, BNX2_PCICFG_INT_ACK_CMD, bnapi->int_num |
-		       BNX2_PCICFG_INT_ACK_CMD_MASK_INT);
-	}
-	REG_RD(bp, BNX2_PCICFG_INT_ACK_CMD);
-}
-
-static void
-bnx2_enable_int(struct bnx2 *bp)
-{
-	int i;
-	struct bnx2_napi *bnapi;
-
-	for (i = 0; i < bp->irq_nvecs; i++) {
-		bnapi = &bp->bnx2_napi[i];
-
-		REG_WR(bp, BNX2_PCICFG_INT_ACK_CMD, bnapi->int_num |
-		       BNX2_PCICFG_INT_ACK_CMD_INDEX_VALID |
-		       BNX2_PCICFG_INT_ACK_CMD_MASK_INT |
-		       bnapi->last_status_idx);
-
-		REG_WR(bp, BNX2_PCICFG_INT_ACK_CMD, bnapi->int_num |
-		       BNX2_PCICFG_INT_ACK_CMD_INDEX_VALID |
-		       bnapi->last_status_idx);
-	}
-	REG_WR(bp, BNX2_HC_COMMAND, bp->hc_cmd | BNX2_HC_COMMAND_COAL_NOW);
-}
-
-static void
-bnx2_disable_int_sync(struct bnx2 *bp)
-{
-	int i;
-
-	atomic_inc(&bp->intr_sem);
-	if (!netif_running(bp->dev))
-		return;
-
-	bnx2_disable_int(bp);
-	for (i = 0; i < bp->irq_nvecs; i++)
-		synchronize_irq(bp->irq_tbl[i].vector);
-}
-
-static void
-bnx2_napi_disable(struct bnx2 *bp)
-{
-	int i;
-
-	for (i = 0; i < bp->irq_nvecs; i++)
-		napi_disable(&bp->bnx2_napi[i].napi);
-}
-
-static void
-bnx2_napi_enable(struct bnx2 *bp)
-{
-	int i;
-
-	for (i = 0; i < bp->irq_nvecs; i++)
-		napi_enable(&bp->bnx2_napi[i].napi);
-}
-
-static void
-bnx2_netif_stop(struct bnx2 *bp)
-{
-	bnx2_cnic_stop(bp);
-	if (netif_running(bp->dev)) {
-		int i;
-
-		bnx2_napi_disable(bp);
-		netif_tx_disable(bp->dev);
-		/* prevent tx timeout */
-		for (i = 0; i <  bp->dev->num_tx_queues; i++) {
-			struct netdev_queue *txq;
-
-			txq = netdev_get_tx_queue(bp->dev, i);
-			txq->trans_start = jiffies;
-		}
-	}
-	bnx2_disable_int_sync(bp);
-}
-
-static void
-bnx2_netif_start(struct bnx2 *bp)
-{
-	if (atomic_dec_and_test(&bp->intr_sem)) {
-		if (netif_running(bp->dev)) {
-			netif_tx_wake_all_queues(bp->dev);
-			bnx2_napi_enable(bp);
-			bnx2_enable_int(bp);
-			bnx2_cnic_start(bp);
-		}
-	}
-}
-
-static void
-bnx2_free_tx_mem(struct bnx2 *bp)
-{
-	int i;
-
-	for (i = 0; i < bp->num_tx_rings; i++) {
-		struct bnx2_napi *bnapi = &bp->bnx2_napi[i];
-		struct bnx2_tx_ring_info *txr = &bnapi->tx_ring;
-
-		if (txr->tx_desc_ring) {
-			pci_free_consistent(bp->pdev, TXBD_RING_SIZE,
-					    txr->tx_desc_ring,
-					    txr->tx_desc_mapping);
-			txr->tx_desc_ring = NULL;
-		}
-		kfree(txr->tx_buf_ring);
-		txr->tx_buf_ring = NULL;
-	}
-}
-
-static void
-bnx2_free_rx_mem(struct bnx2 *bp)
-{
-	int i;
-
-	for (i = 0; i < bp->num_rx_rings; i++) {
-		struct bnx2_napi *bnapi = &bp->bnx2_napi[i];
-		struct bnx2_rx_ring_info *rxr = &bnapi->rx_ring;
-		int j;
-
-		for (j = 0; j < bp->rx_max_ring; j++) {
-			if (rxr->rx_desc_ring[j])
-				pci_free_consistent(bp->pdev, RXBD_RING_SIZE,
-						    rxr->rx_desc_ring[j],
-						    rxr->rx_desc_mapping[j]);
-			rxr->rx_desc_ring[j] = NULL;
-		}
-		vfree(rxr->rx_buf_ring);
-		rxr->rx_buf_ring = NULL;
-
-		for (j = 0; j < bp->rx_max_pg_ring; j++) {
-			if (rxr->rx_pg_desc_ring[j])
-				pci_free_consistent(bp->pdev, RXBD_RING_SIZE,
-						    rxr->rx_pg_desc_ring[j],
-						    rxr->rx_pg_desc_mapping[j]);
-			rxr->rx_pg_desc_ring[j] = NULL;
-		}
-		vfree(rxr->rx_pg_ring);
-		rxr->rx_pg_ring = NULL;
-	}
-}
-
-static int
-bnx2_alloc_tx_mem(struct bnx2 *bp)
-{
-	int i;
-
-	for (i = 0; i < bp->num_tx_rings; i++) {
-		struct bnx2_napi *bnapi = &bp->bnx2_napi[i];
-		struct bnx2_tx_ring_info *txr = &bnapi->tx_ring;
-
-		txr->tx_buf_ring = kzalloc(SW_TXBD_RING_SIZE, GFP_KERNEL);
-		if (txr->tx_buf_ring == NULL)
-			return -ENOMEM;
-
-		txr->tx_desc_ring =
-			pci_alloc_consistent(bp->pdev, TXBD_RING_SIZE,
-					     &txr->tx_desc_mapping);
-		if (txr->tx_desc_ring == NULL)
-			return -ENOMEM;
-	}
-	return 0;
-}
-
-static int
-bnx2_alloc_rx_mem(struct bnx2 *bp)
-{
-	int i;
-
-	for (i = 0; i < bp->num_rx_rings; i++) {
-		struct bnx2_napi *bnapi = &bp->bnx2_napi[i];
-		struct bnx2_rx_ring_info *rxr = &bnapi->rx_ring;
-		int j;
-
-		rxr->rx_buf_ring =
-			vmalloc(SW_RXBD_RING_SIZE * bp->rx_max_ring);
-		if (rxr->rx_buf_ring == NULL)
-			return -ENOMEM;
-
-		memset(rxr->rx_buf_ring, 0,
-		       SW_RXBD_RING_SIZE * bp->rx_max_ring);
-
-		for (j = 0; j < bp->rx_max_ring; j++) {
-			rxr->rx_desc_ring[j] =
-				pci_alloc_consistent(bp->pdev, RXBD_RING_SIZE,
-						     &rxr->rx_desc_mapping[j]);
-			if (rxr->rx_desc_ring[j] == NULL)
-				return -ENOMEM;
-
-		}
-
-		if (bp->rx_pg_ring_size) {
-			rxr->rx_pg_ring = vmalloc(SW_RXPG_RING_SIZE *
-						  bp->rx_max_pg_ring);
-			if (rxr->rx_pg_ring == NULL)
-				return -ENOMEM;
-
-			memset(rxr->rx_pg_ring, 0, SW_RXPG_RING_SIZE *
-			       bp->rx_max_pg_ring);
-		}
-
-		for (j = 0; j < bp->rx_max_pg_ring; j++) {
-			rxr->rx_pg_desc_ring[j] =
-				pci_alloc_consistent(bp->pdev, RXBD_RING_SIZE,
-						&rxr->rx_pg_desc_mapping[j]);
-			if (rxr->rx_pg_desc_ring[j] == NULL)
-				return -ENOMEM;
-
-		}
-	}
-	return 0;
-}
-
-static void
-bnx2_free_mem(struct bnx2 *bp)
-{
-	int i;
-	struct bnx2_napi *bnapi = &bp->bnx2_napi[0];
-
-	bnx2_free_tx_mem(bp);
-	bnx2_free_rx_mem(bp);
-
-	for (i = 0; i < bp->ctx_pages; i++) {
-		if (bp->ctx_blk[i]) {
-			pci_free_consistent(bp->pdev, BCM_PAGE_SIZE,
-					    bp->ctx_blk[i],
-					    bp->ctx_blk_mapping[i]);
-			bp->ctx_blk[i] = NULL;
-		}
-	}
-	if (bnapi->status_blk.msi) {
-		pci_free_consistent(bp->pdev, bp->status_stats_size,
-				    bnapi->status_blk.msi,
-				    bp->status_blk_mapping);
-		bnapi->status_blk.msi = NULL;
-		bp->stats_blk = NULL;
-	}
-}
-
-static int
-bnx2_alloc_mem(struct bnx2 *bp)
-{
-	int i, status_blk_size, err;
-	struct bnx2_napi *bnapi;
-	void *status_blk;
-
-	/* Combine status and statistics blocks into one allocation. */
-	status_blk_size = L1_CACHE_ALIGN(sizeof(struct status_block));
-	if (bp->flags & BNX2_FLAG_MSIX_CAP)
-		status_blk_size = L1_CACHE_ALIGN(BNX2_MAX_MSIX_HW_VEC *
-						 BNX2_SBLK_MSIX_ALIGN_SIZE);
-	bp->status_stats_size = status_blk_size +
-				sizeof(struct statistics_block);
-
-	status_blk = pci_alloc_consistent(bp->pdev, bp->status_stats_size,
-					  &bp->status_blk_mapping);
-	if (status_blk == NULL)
-		goto alloc_mem_err;
-
-	memset(status_blk, 0, bp->status_stats_size);
-
-	bnapi = &bp->bnx2_napi[0];
-	bnapi->status_blk.msi = status_blk;
-	bnapi->hw_tx_cons_ptr =
-		&bnapi->status_blk.msi->status_tx_quick_consumer_index0;
-	bnapi->hw_rx_cons_ptr =
-		&bnapi->status_blk.msi->status_rx_quick_consumer_index0;
-	if (bp->flags & BNX2_FLAG_MSIX_CAP) {
-		for (i = 1; i < BNX2_MAX_MSIX_VEC; i++) {
-			struct status_block_msix *sblk;
-
-			bnapi = &bp->bnx2_napi[i];
-
-			sblk = (void *) (status_blk +
-					 BNX2_SBLK_MSIX_ALIGN_SIZE * i);
-			bnapi->status_blk.msix = sblk;
-			bnapi->hw_tx_cons_ptr =
-				&sblk->status_tx_quick_consumer_index;
-			bnapi->hw_rx_cons_ptr =
-				&sblk->status_rx_quick_consumer_index;
-			bnapi->int_num = i << 24;
-		}
-	}
-
-	bp->stats_blk = status_blk + status_blk_size;
-
-	bp->stats_blk_mapping = bp->status_blk_mapping + status_blk_size;
-
-	if (CHIP_NUM(bp) == CHIP_NUM_5709) {
-		bp->ctx_pages = 0x2000 / BCM_PAGE_SIZE;
-		if (bp->ctx_pages == 0)
-			bp->ctx_pages = 1;
-		for (i = 0; i < bp->ctx_pages; i++) {
-			bp->ctx_blk[i] = pci_alloc_consistent(bp->pdev,
-						BCM_PAGE_SIZE,
-						&bp->ctx_blk_mapping[i]);
-			if (bp->ctx_blk[i] == NULL)
-				goto alloc_mem_err;
-		}
-	}
-
-	err = bnx2_alloc_rx_mem(bp);
-	if (err)
-		goto alloc_mem_err;
-
-	err = bnx2_alloc_tx_mem(bp);
-	if (err)
-		goto alloc_mem_err;
-
-	return 0;
-
-alloc_mem_err:
-	bnx2_free_mem(bp);
-	return -ENOMEM;
-}
-
-static void
-bnx2_report_fw_link(struct bnx2 *bp)
-{
-	u32 fw_link_status = 0;
-
-	if (bp->phy_flags & BNX2_PHY_FLAG_REMOTE_PHY_CAP)
-		return;
-
-	if (bp->link_up) {
-		u32 bmsr;
-
-		switch (bp->line_speed) {
-		case SPEED_10:
-			if (bp->duplex == DUPLEX_HALF)
-				fw_link_status = BNX2_LINK_STATUS_10HALF;
-			else
-				fw_link_status = BNX2_LINK_STATUS_10FULL;
-			break;
-		case SPEED_100:
-			if (bp->duplex == DUPLEX_HALF)
-				fw_link_status = BNX2_LINK_STATUS_100HALF;
-			else
-				fw_link_status = BNX2_LINK_STATUS_100FULL;
-			break;
-		case SPEED_1000:
-			if (bp->duplex == DUPLEX_HALF)
-				fw_link_status = BNX2_LINK_STATUS_1000HALF;
-			else
-				fw_link_status = BNX2_LINK_STATUS_1000FULL;
-			break;
-		case SPEED_2500:
-			if (bp->duplex == DUPLEX_HALF)
-				fw_link_status = BNX2_LINK_STATUS_2500HALF;
-			else
-				fw_link_status = BNX2_LINK_STATUS_2500FULL;
-			break;
-		}
-
-		fw_link_status |= BNX2_LINK_STATUS_LINK_UP;
-
-		if (bp->autoneg) {
-			fw_link_status |= BNX2_LINK_STATUS_AN_ENABLED;
-
-			bnx2_read_phy(bp, bp->mii_bmsr, &bmsr);
-			bnx2_read_phy(bp, bp->mii_bmsr, &bmsr);
-
-			if (!(bmsr & BMSR_ANEGCOMPLETE) ||
-			    bp->phy_flags & BNX2_PHY_FLAG_PARALLEL_DETECT)
-				fw_link_status |= BNX2_LINK_STATUS_PARALLEL_DET;
-			else
-				fw_link_status |= BNX2_LINK_STATUS_AN_COMPLETE;
-		}
-	}
-	else
-		fw_link_status = BNX2_LINK_STATUS_LINK_DOWN;
-
-	bnx2_shmem_wr(bp, BNX2_LINK_STATUS, fw_link_status);
-}
-
-static char *
-bnx2_xceiver_str(struct bnx2 *bp)
-{
-	return ((bp->phy_port == PORT_FIBRE) ? "SerDes" :
-		((bp->phy_flags & BNX2_PHY_FLAG_SERDES) ? "Remote Copper" :
-		 "Copper"));
-}
-
-static void
-bnx2_report_link(struct bnx2 *bp)
-{
-	if (bp->link_up) {
-		netif_carrier_on(bp->dev);
-		printk(KERN_INFO PFX "%s NIC %s Link is Up, ", bp->dev->name,
-		       bnx2_xceiver_str(bp));
-
-		printk("%d Mbps ", bp->line_speed);
-
-		if (bp->duplex == DUPLEX_FULL)
-			printk("full duplex");
-		else
-			printk("half duplex");
-
-		if (bp->flow_ctrl) {
-			if (bp->flow_ctrl & FLOW_CTRL_RX) {
-				printk(", receive ");
-				if (bp->flow_ctrl & FLOW_CTRL_TX)
-					printk("& transmit ");
-			}
-			else {
-				printk(", transmit ");
-			}
-			printk("flow control ON");
-		}
-		printk("\n");
-	}
-	else {
-		netif_carrier_off(bp->dev);
-		printk(KERN_ERR PFX "%s NIC %s Link is Down\n", bp->dev->name,
-		       bnx2_xceiver_str(bp));
-	}
-
-	bnx2_report_fw_link(bp);
-}
-
-static void
-bnx2_resolve_flow_ctrl(struct bnx2 *bp)
-{
-	u32 local_adv, remote_adv;
-
-	bp->flow_ctrl = 0;
-	if ((bp->autoneg & (AUTONEG_SPEED | AUTONEG_FLOW_CTRL)) !=
-		(AUTONEG_SPEED | AUTONEG_FLOW_CTRL)) {
-
-		if (bp->duplex == DUPLEX_FULL) {
-			bp->flow_ctrl = bp->req_flow_ctrl;
-		}
-		return;
-	}
-
-	if (bp->duplex != DUPLEX_FULL) {
-		return;
-	}
-
-	if ((bp->phy_flags & BNX2_PHY_FLAG_SERDES) &&
-	    (CHIP_NUM(bp) == CHIP_NUM_5708)) {
-		u32 val;
-
-		bnx2_read_phy(bp, BCM5708S_1000X_STAT1, &val);
-		if (val & BCM5708S_1000X_STAT1_TX_PAUSE)
-			bp->flow_ctrl |= FLOW_CTRL_TX;
-		if (val & BCM5708S_1000X_STAT1_RX_PAUSE)
-			bp->flow_ctrl |= FLOW_CTRL_RX;
-		return;
-	}
-
-	bnx2_read_phy(bp, bp->mii_adv, &local_adv);
-	bnx2_read_phy(bp, bp->mii_lpa, &remote_adv);
-
-	if (bp->phy_flags & BNX2_PHY_FLAG_SERDES) {
-		u32 new_local_adv = 0;
-		u32 new_remote_adv = 0;
-
-		if (local_adv & ADVERTISE_1000XPAUSE)
-			new_local_adv |= ADVERTISE_PAUSE_CAP;
-		if (local_adv & ADVERTISE_1000XPSE_ASYM)
-			new_local_adv |= ADVERTISE_PAUSE_ASYM;
-		if (remote_adv & ADVERTISE_1000XPAUSE)
-			new_remote_adv |= ADVERTISE_PAUSE_CAP;
-		if (remote_adv & ADVERTISE_1000XPSE_ASYM)
-			new_remote_adv |= ADVERTISE_PAUSE_ASYM;
-
-		local_adv = new_local_adv;
-		remote_adv = new_remote_adv;
-	}
-
-	/* See Table 28B-3 of 802.3ab-1999 spec. */
-	if (local_adv & ADVERTISE_PAUSE_CAP) {
-		if(local_adv & ADVERTISE_PAUSE_ASYM) {
-	                if (remote_adv & ADVERTISE_PAUSE_CAP) {
-				bp->flow_ctrl = FLOW_CTRL_TX | FLOW_CTRL_RX;
-			}
-			else if (remote_adv & ADVERTISE_PAUSE_ASYM) {
-				bp->flow_ctrl = FLOW_CTRL_RX;
-			}
-		}
-		else {
-			if (remote_adv & ADVERTISE_PAUSE_CAP) {
-				bp->flow_ctrl = FLOW_CTRL_TX | FLOW_CTRL_RX;
-			}
-		}
-	}
-	else if (local_adv & ADVERTISE_PAUSE_ASYM) {
-		if ((remote_adv & ADVERTISE_PAUSE_CAP) &&
-			(remote_adv & ADVERTISE_PAUSE_ASYM)) {
-
-			bp->flow_ctrl = FLOW_CTRL_TX;
-		}
-	}
-}
-
-static int
-bnx2_5709s_linkup(struct bnx2 *bp)
-{
-	u32 val, speed;
-
-	bp->link_up = 1;
-
-	bnx2_write_phy(bp, MII_BNX2_BLK_ADDR, MII_BNX2_BLK_ADDR_GP_STATUS);
-	bnx2_read_phy(bp, MII_BNX2_GP_TOP_AN_STATUS1, &val);
-	bnx2_write_phy(bp, MII_BNX2_BLK_ADDR, MII_BNX2_BLK_ADDR_COMBO_IEEEB0);
-
-	if ((bp->autoneg & AUTONEG_SPEED) == 0) {
-		bp->line_speed = bp->req_line_speed;
-		bp->duplex = bp->req_duplex;
-		return 0;
-	}
-	speed = val & MII_BNX2_GP_TOP_AN_SPEED_MSK;
-	switch (speed) {
-		case MII_BNX2_GP_TOP_AN_SPEED_10:
-			bp->line_speed = SPEED_10;
-			break;
-		case MII_BNX2_GP_TOP_AN_SPEED_100:
-			bp->line_speed = SPEED_100;
-			break;
-		case MII_BNX2_GP_TOP_AN_SPEED_1G:
-		case MII_BNX2_GP_TOP_AN_SPEED_1GKV:
-			bp->line_speed = SPEED_1000;
-			break;
-		case MII_BNX2_GP_TOP_AN_SPEED_2_5G:
-			bp->line_speed = SPEED_2500;
-			break;
-	}
-	if (val & MII_BNX2_GP_TOP_AN_FD)
-		bp->duplex = DUPLEX_FULL;
-	else
-		bp->duplex = DUPLEX_HALF;
-	return 0;
-}
-
-static int
-bnx2_5708s_linkup(struct bnx2 *bp)
-{
-	u32 val;
-
-	bp->link_up = 1;
-	bnx2_read_phy(bp, BCM5708S_1000X_STAT1, &val);
-	switch (val & BCM5708S_1000X_STAT1_SPEED_MASK) {
-		case BCM5708S_1000X_STAT1_SPEED_10:
-			bp->line_speed = SPEED_10;
-			break;
-		case BCM5708S_1000X_STAT1_SPEED_100:
-			bp->line_speed = SPEED_100;
-			break;
-		case BCM5708S_1000X_STAT1_SPEED_1G:
-			bp->line_speed = SPEED_1000;
-			break;
-		case BCM5708S_1000X_STAT1_SPEED_2G5:
-			bp->line_speed = SPEED_2500;
-			break;
-	}
-	if (val & BCM5708S_1000X_STAT1_FD)
-		bp->duplex = DUPLEX_FULL;
-	else
-		bp->duplex = DUPLEX_HALF;
-
-	return 0;
-}
-
-static int
-bnx2_5706s_linkup(struct bnx2 *bp)
-{
-	u32 bmcr, local_adv, remote_adv, common;
-
-	bp->link_up = 1;
-	bp->line_speed = SPEED_1000;
-
-	bnx2_read_phy(bp, bp->mii_bmcr, &bmcr);
-	if (bmcr & BMCR_FULLDPLX) {
-		bp->duplex = DUPLEX_FULL;
-	}
-	else {
-		bp->duplex = DUPLEX_HALF;
-	}
-
-	if (!(bmcr & BMCR_ANENABLE)) {
-		return 0;
-	}
-
-	bnx2_read_phy(bp, bp->mii_adv, &local_adv);
-	bnx2_read_phy(bp, bp->mii_lpa, &remote_adv);
-
-	common = local_adv & remote_adv;
-	if (common & (ADVERTISE_1000XHALF | ADVERTISE_1000XFULL)) {
-
-		if (common & ADVERTISE_1000XFULL) {
-			bp->duplex = DUPLEX_FULL;
-		}
-		else {
-			bp->duplex = DUPLEX_HALF;
-		}
-	}
-
-	return 0;
-}
-
-static int
-bnx2_copper_linkup(struct bnx2 *bp)
-{
-	u32 bmcr;
-
-	bnx2_read_phy(bp, bp->mii_bmcr, &bmcr);
-	if (bmcr & BMCR_ANENABLE) {
-		u32 local_adv, remote_adv, common;
-
-		bnx2_read_phy(bp, MII_CTRL1000, &local_adv);
-		bnx2_read_phy(bp, MII_STAT1000, &remote_adv);
-
-		common = local_adv & (remote_adv >> 2);
-		if (common & ADVERTISE_1000FULL) {
-			bp->line_speed = SPEED_1000;
-			bp->duplex = DUPLEX_FULL;
-		}
-		else if (common & ADVERTISE_1000HALF) {
-			bp->line_speed = SPEED_1000;
-			bp->duplex = DUPLEX_HALF;
-		}
-		else {
-			bnx2_read_phy(bp, bp->mii_adv, &local_adv);
-			bnx2_read_phy(bp, bp->mii_lpa, &remote_adv);
-
-			common = local_adv & remote_adv;
-			if (common & ADVERTISE_100FULL) {
-				bp->line_speed = SPEED_100;
-				bp->duplex = DUPLEX_FULL;
-			}
-			else if (common & ADVERTISE_100HALF) {
-				bp->line_speed = SPEED_100;
-				bp->duplex = DUPLEX_HALF;
-			}
-			else if (common & ADVERTISE_10FULL) {
-				bp->line_speed = SPEED_10;
-				bp->duplex = DUPLEX_FULL;
-			}
-			else if (common & ADVERTISE_10HALF) {
-				bp->line_speed = SPEED_10;
-				bp->duplex = DUPLEX_HALF;
-			}
-			else {
-				bp->line_speed = 0;
-				bp->link_up = 0;
-			}
-		}
-	}
-	else {
-		if (bmcr & BMCR_SPEED100) {
-			bp->line_speed = SPEED_100;
-		}
-		else {
-			bp->line_speed = SPEED_10;
-		}
-		if (bmcr & BMCR_FULLDPLX) {
-			bp->duplex = DUPLEX_FULL;
-		}
-		else {
-			bp->duplex = DUPLEX_HALF;
-		}
-	}
-
-	return 0;
-}
-
-static void
-bnx2_init_rx_context(struct bnx2 *bp, u32 cid)
-{
-	u32 val, rx_cid_addr = GET_CID_ADDR(cid);
-
-	val = BNX2_L2CTX_CTX_TYPE_CTX_BD_CHN_TYPE_VALUE;
-	val |= BNX2_L2CTX_CTX_TYPE_SIZE_L2;
-	val |= 0x02 << 8;
-
-	if (CHIP_NUM(bp) == CHIP_NUM_5709) {
-		u32 lo_water, hi_water;
-
-		if (bp->flow_ctrl & FLOW_CTRL_TX)
-			lo_water = BNX2_L2CTX_LO_WATER_MARK_DEFAULT;
-		else
-			lo_water = BNX2_L2CTX_LO_WATER_MARK_DIS;
-		if (lo_water >= bp->rx_ring_size)
-			lo_water = 0;
-
-		hi_water = min_t(int, bp->rx_ring_size / 4, lo_water + 16);
-
-		if (hi_water <= lo_water)
-			lo_water = 0;
-
-		hi_water /= BNX2_L2CTX_HI_WATER_MARK_SCALE;
-		lo_water /= BNX2_L2CTX_LO_WATER_MARK_SCALE;
-
-		if (hi_water > 0xf)
-			hi_water = 0xf;
-		else if (hi_water == 0)
-			lo_water = 0;
-		val |= lo_water | (hi_water << BNX2_L2CTX_HI_WATER_MARK_SHIFT);
-	}
-	bnx2_ctx_wr(bp, rx_cid_addr, BNX2_L2CTX_CTX_TYPE, val);
-}
-
-static void
-bnx2_init_all_rx_contexts(struct bnx2 *bp)
-{
-	int i;
-	u32 cid;
-
-	for (i = 0, cid = RX_CID; i < bp->num_rx_rings; i++, cid++) {
-		if (i == 1)
-			cid = RX_RSS_CID;
-		bnx2_init_rx_context(bp, cid);
-	}
-}
-
-static void
-bnx2_set_mac_link(struct bnx2 *bp)
-{
-	u32 val;
-
-	REG_WR(bp, BNX2_EMAC_TX_LENGTHS, 0x2620);
-	if (bp->link_up && (bp->line_speed == SPEED_1000) &&
-		(bp->duplex == DUPLEX_HALF)) {
-		REG_WR(bp, BNX2_EMAC_TX_LENGTHS, 0x26ff);
-	}
-
-	/* Configure the EMAC mode register. */
-	val = REG_RD(bp, BNX2_EMAC_MODE);
-
-	val &= ~(BNX2_EMAC_MODE_PORT | BNX2_EMAC_MODE_HALF_DUPLEX |
-		BNX2_EMAC_MODE_MAC_LOOP | BNX2_EMAC_MODE_FORCE_LINK |
-		BNX2_EMAC_MODE_25G_MODE);
-
-	if (bp->link_up) {
-		switch (bp->line_speed) {
-			case SPEED_10:
-				if (CHIP_NUM(bp) != CHIP_NUM_5706) {
-					val |= BNX2_EMAC_MODE_PORT_MII_10M;
-					break;
-				}
-				/* fall through */
-			case SPEED_100:
-				val |= BNX2_EMAC_MODE_PORT_MII;
-				break;
-			case SPEED_2500:
-				val |= BNX2_EMAC_MODE_25G_MODE;
-				/* fall through */
-			case SPEED_1000:
-				val |= BNX2_EMAC_MODE_PORT_GMII;
-				break;
-		}
-	}
-	else {
-		val |= BNX2_EMAC_MODE_PORT_GMII;
-	}
-
-	/* Set the MAC to operate in the appropriate duplex mode. */
-	if (bp->duplex == DUPLEX_HALF)
-		val |= BNX2_EMAC_MODE_HALF_DUPLEX;
-	REG_WR(bp, BNX2_EMAC_MODE, val);
-
-	/* Enable/disable rx PAUSE. */
-	bp->rx_mode &= ~BNX2_EMAC_RX_MODE_FLOW_EN;
-
-	if (bp->flow_ctrl & FLOW_CTRL_RX)
-		bp->rx_mode |= BNX2_EMAC_RX_MODE_FLOW_EN;
-	REG_WR(bp, BNX2_EMAC_RX_MODE, bp->rx_mode);
-
-	/* Enable/disable tx PAUSE. */
-	val = REG_RD(bp, BNX2_EMAC_TX_MODE);
-	val &= ~BNX2_EMAC_TX_MODE_FLOW_EN;
-
-	if (bp->flow_ctrl & FLOW_CTRL_TX)
-		val |= BNX2_EMAC_TX_MODE_FLOW_EN;
-	REG_WR(bp, BNX2_EMAC_TX_MODE, val);
-
-	/* Acknowledge the interrupt. */
-	REG_WR(bp, BNX2_EMAC_STATUS, BNX2_EMAC_STATUS_LINK_CHANGE);
-
-	if (CHIP_NUM(bp) == CHIP_NUM_5709)
-		bnx2_init_all_rx_contexts(bp);
-}
-
-static void
-bnx2_enable_bmsr1(struct bnx2 *bp)
-{
-	if ((bp->phy_flags & BNX2_PHY_FLAG_SERDES) &&
-	    (CHIP_NUM(bp) == CHIP_NUM_5709))
-		bnx2_write_phy(bp, MII_BNX2_BLK_ADDR,
-			       MII_BNX2_BLK_ADDR_GP_STATUS);
-}
-
-static void
-bnx2_disable_bmsr1(struct bnx2 *bp)
-{
-	if ((bp->phy_flags & BNX2_PHY_FLAG_SERDES) &&
-	    (CHIP_NUM(bp) == CHIP_NUM_5709))
-		bnx2_write_phy(bp, MII_BNX2_BLK_ADDR,
-			       MII_BNX2_BLK_ADDR_COMBO_IEEEB0);
-}
-
-static int
-bnx2_test_and_enable_2g5(struct bnx2 *bp)
-{
-	u32 up1;
-	int ret = 1;
-
-	if (!(bp->phy_flags & BNX2_PHY_FLAG_2_5G_CAPABLE))
-		return 0;
-
-	if (bp->autoneg & AUTONEG_SPEED)
-		bp->advertising |= ADVERTISED_2500baseX_Full;
-
-	if (CHIP_NUM(bp) == CHIP_NUM_5709)
-		bnx2_write_phy(bp, MII_BNX2_BLK_ADDR, MII_BNX2_BLK_ADDR_OVER1G);
-
-	bnx2_read_phy(bp, bp->mii_up1, &up1);
-	if (!(up1 & BCM5708S_UP1_2G5)) {
-		up1 |= BCM5708S_UP1_2G5;
-		bnx2_write_phy(bp, bp->mii_up1, up1);
-		ret = 0;
-	}
-
-	if (CHIP_NUM(bp) == CHIP_NUM_5709)
-		bnx2_write_phy(bp, MII_BNX2_BLK_ADDR,
-			       MII_BNX2_BLK_ADDR_COMBO_IEEEB0);
-
-	return ret;
-}
-
-static int
-bnx2_test_and_disable_2g5(struct bnx2 *bp)
-{
-	u32 up1;
-	int ret = 0;
-
-	if (!(bp->phy_flags & BNX2_PHY_FLAG_2_5G_CAPABLE))
-		return 0;
-
-	if (CHIP_NUM(bp) == CHIP_NUM_5709)
-		bnx2_write_phy(bp, MII_BNX2_BLK_ADDR, MII_BNX2_BLK_ADDR_OVER1G);
-
-	bnx2_read_phy(bp, bp->mii_up1, &up1);
-	if (up1 & BCM5708S_UP1_2G5) {
-		up1 &= ~BCM5708S_UP1_2G5;
-		bnx2_write_phy(bp, bp->mii_up1, up1);
-		ret = 1;
-	}
-
-	if (CHIP_NUM(bp) == CHIP_NUM_5709)
-		bnx2_write_phy(bp, MII_BNX2_BLK_ADDR,
-			       MII_BNX2_BLK_ADDR_COMBO_IEEEB0);
-
-	return ret;
-}
-
-static void
-bnx2_enable_forced_2g5(struct bnx2 *bp)
-{
-	u32 bmcr;
-
-	if (!(bp->phy_flags & BNX2_PHY_FLAG_2_5G_CAPABLE))
-		return;
-
-	if (CHIP_NUM(bp) == CHIP_NUM_5709) {
-		u32 val;
-
-		bnx2_write_phy(bp, MII_BNX2_BLK_ADDR,
-			       MII_BNX2_BLK_ADDR_SERDES_DIG);
-		bnx2_read_phy(bp, MII_BNX2_SERDES_DIG_MISC1, &val);
-		val &= ~MII_BNX2_SD_MISC1_FORCE_MSK;
-		val |= MII_BNX2_SD_MISC1_FORCE | MII_BNX2_SD_MISC1_FORCE_2_5G;
-		bnx2_write_phy(bp, MII_BNX2_SERDES_DIG_MISC1, val);
-
-		bnx2_write_phy(bp, MII_BNX2_BLK_ADDR,
-			       MII_BNX2_BLK_ADDR_COMBO_IEEEB0);
-		bnx2_read_phy(bp, bp->mii_bmcr, &bmcr);
-
-	} else if (CHIP_NUM(bp) == CHIP_NUM_5708) {
-		bnx2_read_phy(bp, bp->mii_bmcr, &bmcr);
-		bmcr |= BCM5708S_BMCR_FORCE_2500;
-	} else {
-		return;
-	}
-
-	if (bp->autoneg & AUTONEG_SPEED) {
-		bmcr &= ~BMCR_ANENABLE;
-		if (bp->req_duplex == DUPLEX_FULL)
-			bmcr |= BMCR_FULLDPLX;
-	}
-	bnx2_write_phy(bp, bp->mii_bmcr, bmcr);
-}
-
-static void
-bnx2_disable_forced_2g5(struct bnx2 *bp)
-{
-	u32 bmcr;
-
-	if (!(bp->phy_flags & BNX2_PHY_FLAG_2_5G_CAPABLE))
-		return;
-
-	if (CHIP_NUM(bp) == CHIP_NUM_5709) {
-		u32 val;
-
-		bnx2_write_phy(bp, MII_BNX2_BLK_ADDR,
-			       MII_BNX2_BLK_ADDR_SERDES_DIG);
-		bnx2_read_phy(bp, MII_BNX2_SERDES_DIG_MISC1, &val);
-		val &= ~MII_BNX2_SD_MISC1_FORCE;
-		bnx2_write_phy(bp, MII_BNX2_SERDES_DIG_MISC1, val);
-
-		bnx2_write_phy(bp, MII_BNX2_BLK_ADDR,
-			       MII_BNX2_BLK_ADDR_COMBO_IEEEB0);
-		bnx2_read_phy(bp, bp->mii_bmcr, &bmcr);
-
-	} else if (CHIP_NUM(bp) == CHIP_NUM_5708) {
-		bnx2_read_phy(bp, bp->mii_bmcr, &bmcr);
-		bmcr &= ~BCM5708S_BMCR_FORCE_2500;
-	} else {
-		return;
-	}
-
-	if (bp->autoneg & AUTONEG_SPEED)
-		bmcr |= BMCR_SPEED1000 | BMCR_ANENABLE | BMCR_ANRESTART;
-	bnx2_write_phy(bp, bp->mii_bmcr, bmcr);
-}
-
-static void
-bnx2_5706s_force_link_dn(struct bnx2 *bp, int start)
-{
-	u32 val;
-
-	bnx2_write_phy(bp, MII_BNX2_DSP_ADDRESS, MII_EXPAND_SERDES_CTL);
-	bnx2_read_phy(bp, MII_BNX2_DSP_RW_PORT, &val);
-	if (start)
-		bnx2_write_phy(bp, MII_BNX2_DSP_RW_PORT, val & 0xff0f);
-	else
-		bnx2_write_phy(bp, MII_BNX2_DSP_RW_PORT, val | 0xc0);
-}
-
-static int
-bnx2_set_link(struct bnx2 *bp)
-{
-	u32 bmsr;
-	u8 link_up;
-
-	if (bp->loopback == MAC_LOOPBACK || bp->loopback == PHY_LOOPBACK) {
-		bp->link_up = 1;
-		return 0;
-	}
-
-	if (bp->phy_flags & BNX2_PHY_FLAG_REMOTE_PHY_CAP)
-		return 0;
-
-	link_up = bp->link_up;
-
-	bnx2_enable_bmsr1(bp);
-	bnx2_read_phy(bp, bp->mii_bmsr1, &bmsr);
-	bnx2_read_phy(bp, bp->mii_bmsr1, &bmsr);
-	bnx2_disable_bmsr1(bp);
-
-	if ((bp->phy_flags & BNX2_PHY_FLAG_SERDES) &&
-	    (CHIP_NUM(bp) == CHIP_NUM_5706)) {
-		u32 val, an_dbg;
-
-		if (bp->phy_flags & BNX2_PHY_FLAG_FORCED_DOWN) {
-			bnx2_5706s_force_link_dn(bp, 0);
-			bp->phy_flags &= ~BNX2_PHY_FLAG_FORCED_DOWN;
-		}
-		val = REG_RD(bp, BNX2_EMAC_STATUS);
-
-		bnx2_write_phy(bp, MII_BNX2_MISC_SHADOW, MISC_SHDW_AN_DBG);
-		bnx2_read_phy(bp, MII_BNX2_MISC_SHADOW, &an_dbg);
-		bnx2_read_phy(bp, MII_BNX2_MISC_SHADOW, &an_dbg);
-
-		if ((val & BNX2_EMAC_STATUS_LINK) &&
-		    !(an_dbg & MISC_SHDW_AN_DBG_NOSYNC))
-			bmsr |= BMSR_LSTATUS;
-		else
-			bmsr &= ~BMSR_LSTATUS;
-	}
-
-	if (bmsr & BMSR_LSTATUS) {
-		bp->link_up = 1;
-
-		if (bp->phy_flags & BNX2_PHY_FLAG_SERDES) {
-			if (CHIP_NUM(bp) == CHIP_NUM_5706)
-				bnx2_5706s_linkup(bp);
-			else if (CHIP_NUM(bp) == CHIP_NUM_5708)
-				bnx2_5708s_linkup(bp);
-			else if (CHIP_NUM(bp) == CHIP_NUM_5709)
-				bnx2_5709s_linkup(bp);
-		}
-		else {
-			bnx2_copper_linkup(bp);
-		}
-		bnx2_resolve_flow_ctrl(bp);
-	}
-	else {
-		if ((bp->phy_flags & BNX2_PHY_FLAG_SERDES) &&
-		    (bp->autoneg & AUTONEG_SPEED))
-			bnx2_disable_forced_2g5(bp);
-
-		if (bp->phy_flags & BNX2_PHY_FLAG_PARALLEL_DETECT) {
-			u32 bmcr;
-
-			bnx2_read_phy(bp, bp->mii_bmcr, &bmcr);
-			bmcr |= BMCR_ANENABLE;
-			bnx2_write_phy(bp, bp->mii_bmcr, bmcr);
-
-			bp->phy_flags &= ~BNX2_PHY_FLAG_PARALLEL_DETECT;
-		}
-		bp->link_up = 0;
-	}
-
-	if (bp->link_up != link_up) {
-		bnx2_report_link(bp);
-	}
-
-	bnx2_set_mac_link(bp);
-
-	return 0;
-}
-
-static int
-bnx2_reset_phy(struct bnx2 *bp)
-{
-	int i;
-	u32 reg;
-
-        bnx2_write_phy(bp, bp->mii_bmcr, BMCR_RESET);
-
-#define PHY_RESET_MAX_WAIT 100
-	for (i = 0; i < PHY_RESET_MAX_WAIT; i++) {
-		udelay(10);
-
-		bnx2_read_phy(bp, bp->mii_bmcr, &reg);
-		if (!(reg & BMCR_RESET)) {
-			udelay(20);
-			break;
-		}
-	}
-	if (i == PHY_RESET_MAX_WAIT) {
-		return -EBUSY;
-	}
-	return 0;
-}
-
-static u32
-bnx2_phy_get_pause_adv(struct bnx2 *bp)
-{
-	u32 adv = 0;
-
-	if ((bp->req_flow_ctrl & (FLOW_CTRL_RX | FLOW_CTRL_TX)) ==
-		(FLOW_CTRL_RX | FLOW_CTRL_TX)) {
-
-		if (bp->phy_flags & BNX2_PHY_FLAG_SERDES) {
-			adv = ADVERTISE_1000XPAUSE;
-		}
-		else {
-			adv = ADVERTISE_PAUSE_CAP;
-		}
-	}
-	else if (bp->req_flow_ctrl & FLOW_CTRL_TX) {
-		if (bp->phy_flags & BNX2_PHY_FLAG_SERDES) {
-			adv = ADVERTISE_1000XPSE_ASYM;
-		}
-		else {
-			adv = ADVERTISE_PAUSE_ASYM;
-		}
-	}
-	else if (bp->req_flow_ctrl & FLOW_CTRL_RX) {
-		if (bp->phy_flags & BNX2_PHY_FLAG_SERDES) {
-			adv = ADVERTISE_1000XPAUSE | ADVERTISE_1000XPSE_ASYM;
-		}
-		else {
-			adv = ADVERTISE_PAUSE_CAP | ADVERTISE_PAUSE_ASYM;
-		}
-	}
-	return adv;
-}
-
-static int bnx2_fw_sync(struct bnx2 *, u32, int, int);
-
-static int
-bnx2_setup_remote_phy(struct bnx2 *bp, u8 port)
-__releases(&bp->phy_lock)
-__acquires(&bp->phy_lock)
-{
-	u32 speed_arg = 0, pause_adv;
-
-	pause_adv = bnx2_phy_get_pause_adv(bp);
-
-	if (bp->autoneg & AUTONEG_SPEED) {
-		speed_arg |= BNX2_NETLINK_SET_LINK_ENABLE_AUTONEG;
-		if (bp->advertising & ADVERTISED_10baseT_Half)
-			speed_arg |= BNX2_NETLINK_SET_LINK_SPEED_10HALF;
-		if (bp->advertising & ADVERTISED_10baseT_Full)
-			speed_arg |= BNX2_NETLINK_SET_LINK_SPEED_10FULL;
-		if (bp->advertising & ADVERTISED_100baseT_Half)
-			speed_arg |= BNX2_NETLINK_SET_LINK_SPEED_100HALF;
-		if (bp->advertising & ADVERTISED_100baseT_Full)
-			speed_arg |= BNX2_NETLINK_SET_LINK_SPEED_100FULL;
-		if (bp->advertising & ADVERTISED_1000baseT_Full)
-			speed_arg |= BNX2_NETLINK_SET_LINK_SPEED_1GFULL;
-		if (bp->advertising & ADVERTISED_2500baseX_Full)
-			speed_arg |= BNX2_NETLINK_SET_LINK_SPEED_2G5FULL;
-	} else {
-		if (bp->req_line_speed == SPEED_2500)
-			speed_arg = BNX2_NETLINK_SET_LINK_SPEED_2G5FULL;
-		else if (bp->req_line_speed == SPEED_1000)
-			speed_arg = BNX2_NETLINK_SET_LINK_SPEED_1GFULL;
-		else if (bp->req_line_speed == SPEED_100) {
-			if (bp->req_duplex == DUPLEX_FULL)
-				speed_arg = BNX2_NETLINK_SET_LINK_SPEED_100FULL;
-			else
-				speed_arg = BNX2_NETLINK_SET_LINK_SPEED_100HALF;
-		} else if (bp->req_line_speed == SPEED_10) {
-			if (bp->req_duplex == DUPLEX_FULL)
-				speed_arg = BNX2_NETLINK_SET_LINK_SPEED_10FULL;
-			else
-				speed_arg = BNX2_NETLINK_SET_LINK_SPEED_10HALF;
-		}
-	}
-
-	if (pause_adv & (ADVERTISE_1000XPAUSE | ADVERTISE_PAUSE_CAP))
-		speed_arg |= BNX2_NETLINK_SET_LINK_FC_SYM_PAUSE;
-	if (pause_adv & (ADVERTISE_1000XPSE_ASYM | ADVERTISE_PAUSE_ASYM))
-		speed_arg |= BNX2_NETLINK_SET_LINK_FC_ASYM_PAUSE;
-
-	if (port == PORT_TP)
-		speed_arg |= BNX2_NETLINK_SET_LINK_PHY_APP_REMOTE |
-			     BNX2_NETLINK_SET_LINK_ETH_AT_WIRESPEED;
-
-	bnx2_shmem_wr(bp, BNX2_DRV_MB_ARG0, speed_arg);
-
-	spin_unlock_bh(&bp->phy_lock);
-	bnx2_fw_sync(bp, BNX2_DRV_MSG_CODE_CMD_SET_LINK, 1, 0);
-	spin_lock_bh(&bp->phy_lock);
-
-	return 0;
-}
-
-static int
-bnx2_setup_serdes_phy(struct bnx2 *bp, u8 port)
-__releases(&bp->phy_lock)
-__acquires(&bp->phy_lock)
-{
-	u32 adv, bmcr;
-	u32 new_adv = 0;
-
-	if (bp->phy_flags & BNX2_PHY_FLAG_REMOTE_PHY_CAP)
-		return (bnx2_setup_remote_phy(bp, port));
-
-	if (!(bp->autoneg & AUTONEG_SPEED)) {
-		u32 new_bmcr;
-		int force_link_down = 0;
-
-		if (bp->req_line_speed == SPEED_2500) {
-			if (!bnx2_test_and_enable_2g5(bp))
-				force_link_down = 1;
-		} else if (bp->req_line_speed == SPEED_1000) {
-			if (bnx2_test_and_disable_2g5(bp))
-				force_link_down = 1;
-		}
-		bnx2_read_phy(bp, bp->mii_adv, &adv);
-		adv &= ~(ADVERTISE_1000XFULL | ADVERTISE_1000XHALF);
-
-		bnx2_read_phy(bp, bp->mii_bmcr, &bmcr);
-		new_bmcr = bmcr & ~BMCR_ANENABLE;
-		new_bmcr |= BMCR_SPEED1000;
-
-		if (CHIP_NUM(bp) == CHIP_NUM_5709) {
-			if (bp->req_line_speed == SPEED_2500)
-				bnx2_enable_forced_2g5(bp);
-			else if (bp->req_line_speed == SPEED_1000) {
-				bnx2_disable_forced_2g5(bp);
-				new_bmcr &= ~0x2000;
-			}
-
-		} else if (CHIP_NUM(bp) == CHIP_NUM_5708) {
-			if (bp->req_line_speed == SPEED_2500)
-				new_bmcr |= BCM5708S_BMCR_FORCE_2500;
-			else
-				new_bmcr = bmcr & ~BCM5708S_BMCR_FORCE_2500;
-		}
-
-		if (bp->req_duplex == DUPLEX_FULL) {
-			adv |= ADVERTISE_1000XFULL;
-			new_bmcr |= BMCR_FULLDPLX;
-		}
-		else {
-			adv |= ADVERTISE_1000XHALF;
-			new_bmcr &= ~BMCR_FULLDPLX;
-		}
-		if ((new_bmcr != bmcr) || (force_link_down)) {
-			/* Force a link down visible on the other side */
-			if (bp->link_up) {
-				bnx2_write_phy(bp, bp->mii_adv, adv &
-					       ~(ADVERTISE_1000XFULL |
-						 ADVERTISE_1000XHALF));
-				bnx2_write_phy(bp, bp->mii_bmcr, bmcr |
-					BMCR_ANRESTART | BMCR_ANENABLE);
-
-				bp->link_up = 0;
-				netif_carrier_off(bp->dev);
-				bnx2_write_phy(bp, bp->mii_bmcr, new_bmcr);
-				bnx2_report_link(bp);
-			}
-			bnx2_write_phy(bp, bp->mii_adv, adv);
-			bnx2_write_phy(bp, bp->mii_bmcr, new_bmcr);
-		} else {
-			bnx2_resolve_flow_ctrl(bp);
-			bnx2_set_mac_link(bp);
-		}
-		return 0;
-	}
-
-	bnx2_test_and_enable_2g5(bp);
-
-	if (bp->advertising & ADVERTISED_1000baseT_Full)
-		new_adv |= ADVERTISE_1000XFULL;
-
-	new_adv |= bnx2_phy_get_pause_adv(bp);
-
-	bnx2_read_phy(bp, bp->mii_adv, &adv);
-	bnx2_read_phy(bp, bp->mii_bmcr, &bmcr);
-
-	bp->serdes_an_pending = 0;
-	if ((adv != new_adv) || ((bmcr & BMCR_ANENABLE) == 0)) {
-		/* Force a link down visible on the other side */
-		if (bp->link_up) {
-			bnx2_write_phy(bp, bp->mii_bmcr, BMCR_LOOPBACK);
-			spin_unlock_bh(&bp->phy_lock);
-			msleep(20);
-			spin_lock_bh(&bp->phy_lock);
-		}
-
-		bnx2_write_phy(bp, bp->mii_adv, new_adv);
-		bnx2_write_phy(bp, bp->mii_bmcr, bmcr | BMCR_ANRESTART |
-			BMCR_ANENABLE);
-		/* Speed up link-up time when the link partner
-		 * does not autonegotiate which is very common
-		 * in blade servers. Some blade servers use
-		 * IPMI for kerboard input and it's important
-		 * to minimize link disruptions. Autoneg. involves
-		 * exchanging base pages plus 3 next pages and
-		 * normally completes in about 120 msec.
-		 */
-		bp->current_interval = BNX2_SERDES_AN_TIMEOUT;
-		bp->serdes_an_pending = 1;
-		mod_timer(&bp->timer, jiffies + bp->current_interval);
-	} else {
-		bnx2_resolve_flow_ctrl(bp);
-		bnx2_set_mac_link(bp);
-	}
-
-	return 0;
-}
-
-#define ETHTOOL_ALL_FIBRE_SPEED						\
-	(bp->phy_flags & BNX2_PHY_FLAG_2_5G_CAPABLE) ?			\
-		(ADVERTISED_2500baseX_Full | ADVERTISED_1000baseT_Full) :\
-		(ADVERTISED_1000baseT_Full)
-
-#define ETHTOOL_ALL_COPPER_SPEED					\
-	(ADVERTISED_10baseT_Half | ADVERTISED_10baseT_Full |		\
-	ADVERTISED_100baseT_Half | ADVERTISED_100baseT_Full |		\
-	ADVERTISED_1000baseT_Full)
-
-#define PHY_ALL_10_100_SPEED (ADVERTISE_10HALF | ADVERTISE_10FULL | \
-	ADVERTISE_100HALF | ADVERTISE_100FULL | ADVERTISE_CSMA)
-
-#define PHY_ALL_1000_SPEED (ADVERTISE_1000HALF | ADVERTISE_1000FULL)
-
-static void
-bnx2_set_default_remote_link(struct bnx2 *bp)
-{
-	u32 link;
-
-	if (bp->phy_port == PORT_TP)
-		link = bnx2_shmem_rd(bp, BNX2_RPHY_COPPER_LINK);
-	else
-		link = bnx2_shmem_rd(bp, BNX2_RPHY_SERDES_LINK);
-
-	if (link & BNX2_NETLINK_SET_LINK_ENABLE_AUTONEG) {
-		bp->req_line_speed = 0;
-		bp->autoneg |= AUTONEG_SPEED;
-		bp->advertising = ADVERTISED_Autoneg;
-		if (link & BNX2_NETLINK_SET_LINK_SPEED_10HALF)
-			bp->advertising |= ADVERTISED_10baseT_Half;
-		if (link & BNX2_NETLINK_SET_LINK_SPEED_10FULL)
-			bp->advertising |= ADVERTISED_10baseT_Full;
-		if (link & BNX2_NETLINK_SET_LINK_SPEED_100HALF)
-			bp->advertising |= ADVERTISED_100baseT_Half;
-		if (link & BNX2_NETLINK_SET_LINK_SPEED_100FULL)
-			bp->advertising |= ADVERTISED_100baseT_Full;
-		if (link & BNX2_NETLINK_SET_LINK_SPEED_1GFULL)
-			bp->advertising |= ADVERTISED_1000baseT_Full;
-		if (link & BNX2_NETLINK_SET_LINK_SPEED_2G5FULL)
-			bp->advertising |= ADVERTISED_2500baseX_Full;
-	} else {
-		bp->autoneg = 0;
-		bp->advertising = 0;
-		bp->req_duplex = DUPLEX_FULL;
-		if (link & BNX2_NETLINK_SET_LINK_SPEED_10) {
-			bp->req_line_speed = SPEED_10;
-			if (link & BNX2_NETLINK_SET_LINK_SPEED_10HALF)
-				bp->req_duplex = DUPLEX_HALF;
-		}
-		if (link & BNX2_NETLINK_SET_LINK_SPEED_100) {
-			bp->req_line_speed = SPEED_100;
-			if (link & BNX2_NETLINK_SET_LINK_SPEED_100HALF)
-				bp->req_duplex = DUPLEX_HALF;
-		}
-		if (link & BNX2_NETLINK_SET_LINK_SPEED_1GFULL)
-			bp->req_line_speed = SPEED_1000;
-		if (link & BNX2_NETLINK_SET_LINK_SPEED_2G5FULL)
-			bp->req_line_speed = SPEED_2500;
-	}
-}
-
-static void
-bnx2_set_default_link(struct bnx2 *bp)
-{
-	if (bp->phy_flags & BNX2_PHY_FLAG_REMOTE_PHY_CAP) {
-		bnx2_set_default_remote_link(bp);
-		return;
-	}
-
-	bp->autoneg = AUTONEG_SPEED | AUTONEG_FLOW_CTRL;
-	bp->req_line_speed = 0;
-	if (bp->phy_flags & BNX2_PHY_FLAG_SERDES) {
-		u32 reg;
-
-		bp->advertising = ETHTOOL_ALL_FIBRE_SPEED | ADVERTISED_Autoneg;
-
-		reg = bnx2_shmem_rd(bp, BNX2_PORT_HW_CFG_CONFIG);
-		reg &= BNX2_PORT_HW_CFG_CFG_DFLT_LINK_MASK;
-		if (reg == BNX2_PORT_HW_CFG_CFG_DFLT_LINK_1G) {
-			bp->autoneg = 0;
-			bp->req_line_speed = bp->line_speed = SPEED_1000;
-			bp->req_duplex = DUPLEX_FULL;
-		}
-	} else
-		bp->advertising = ETHTOOL_ALL_COPPER_SPEED | ADVERTISED_Autoneg;
-}
-
-static void
-bnx2_send_heart_beat(struct bnx2 *bp)
-{
-	u32 msg;
-	u32 addr;
-
-	spin_lock(&bp->indirect_lock);
-	msg = (u32) (++bp->fw_drv_pulse_wr_seq & BNX2_DRV_PULSE_SEQ_MASK);
-	addr = bp->shmem_base + BNX2_DRV_PULSE_MB;
-	REG_WR(bp, BNX2_PCICFG_REG_WINDOW_ADDRESS, addr);
-	REG_WR(bp, BNX2_PCICFG_REG_WINDOW, msg);
-	spin_unlock(&bp->indirect_lock);
-}
-
-static void
-bnx2_remote_phy_event(struct bnx2 *bp)
-{
-	u32 msg;
-	u8 link_up = bp->link_up;
-	u8 old_port;
-
-	msg = bnx2_shmem_rd(bp, BNX2_LINK_STATUS);
-
-	if (msg & BNX2_LINK_STATUS_HEART_BEAT_EXPIRED)
-		bnx2_send_heart_beat(bp);
-
-	msg &= ~BNX2_LINK_STATUS_HEART_BEAT_EXPIRED;
-
-	if ((msg & BNX2_LINK_STATUS_LINK_UP) == BNX2_LINK_STATUS_LINK_DOWN)
-		bp->link_up = 0;
-	else {
-		u32 speed;
-
-		bp->link_up = 1;
-		speed = msg & BNX2_LINK_STATUS_SPEED_MASK;
-		bp->duplex = DUPLEX_FULL;
-		switch (speed) {
-			case BNX2_LINK_STATUS_10HALF:
-				bp->duplex = DUPLEX_HALF;
-			case BNX2_LINK_STATUS_10FULL:
-				bp->line_speed = SPEED_10;
-				break;
-			case BNX2_LINK_STATUS_100HALF:
-				bp->duplex = DUPLEX_HALF;
-			case BNX2_LINK_STATUS_100BASE_T4:
-			case BNX2_LINK_STATUS_100FULL:
-				bp->line_speed = SPEED_100;
-				break;
-			case BNX2_LINK_STATUS_1000HALF:
-				bp->duplex = DUPLEX_HALF;
-			case BNX2_LINK_STATUS_1000FULL:
-				bp->line_speed = SPEED_1000;
-				break;
-			case BNX2_LINK_STATUS_2500HALF:
-				bp->duplex = DUPLEX_HALF;
-			case BNX2_LINK_STATUS_2500FULL:
-				bp->line_speed = SPEED_2500;
-				break;
-			default:
-				bp->line_speed = 0;
-				break;
-		}
-
-		bp->flow_ctrl = 0;
-		if ((bp->autoneg & (AUTONEG_SPEED | AUTONEG_FLOW_CTRL)) !=
-		    (AUTONEG_SPEED | AUTONEG_FLOW_CTRL)) {
-			if (bp->duplex == DUPLEX_FULL)
-				bp->flow_ctrl = bp->req_flow_ctrl;
-		} else {
-			if (msg & BNX2_LINK_STATUS_TX_FC_ENABLED)
-				bp->flow_ctrl |= FLOW_CTRL_TX;
-			if (msg & BNX2_LINK_STATUS_RX_FC_ENABLED)
-				bp->flow_ctrl |= FLOW_CTRL_RX;
-		}
-
-		old_port = bp->phy_port;
-		if (msg & BNX2_LINK_STATUS_SERDES_LINK)
-			bp->phy_port = PORT_FIBRE;
-		else
-			bp->phy_port = PORT_TP;
-
-		if (old_port != bp->phy_port)
-			bnx2_set_default_link(bp);
-
-	}
-	if (bp->link_up != link_up)
-		bnx2_report_link(bp);
-
-	bnx2_set_mac_link(bp);
-}
-
-static int
-bnx2_set_remote_link(struct bnx2 *bp)
-{
-	u32 evt_code;
-
-	evt_code = bnx2_shmem_rd(bp, BNX2_FW_EVT_CODE_MB);
-	switch (evt_code) {
-		case BNX2_FW_EVT_CODE_LINK_EVENT:
-			bnx2_remote_phy_event(bp);
-			break;
-		case BNX2_FW_EVT_CODE_SW_TIMER_EXPIRATION_EVENT:
-		default:
-			bnx2_send_heart_beat(bp);
-			break;
-	}
-	return 0;
-}
-
-static int
-bnx2_setup_copper_phy(struct bnx2 *bp)
-__releases(&bp->phy_lock)
-__acquires(&bp->phy_lock)
-{
-	u32 bmcr;
-	u32 new_bmcr;
-
-	bnx2_read_phy(bp, bp->mii_bmcr, &bmcr);
-
-	if (bp->autoneg & AUTONEG_SPEED) {
-		u32 adv_reg, adv1000_reg;
-		u32 new_adv_reg = 0;
-		u32 new_adv1000_reg = 0;
-
-		bnx2_read_phy(bp, bp->mii_adv, &adv_reg);
-		adv_reg &= (PHY_ALL_10_100_SPEED | ADVERTISE_PAUSE_CAP |
-			ADVERTISE_PAUSE_ASYM);
-
-		bnx2_read_phy(bp, MII_CTRL1000, &adv1000_reg);
-		adv1000_reg &= PHY_ALL_1000_SPEED;
-
-		if (bp->advertising & ADVERTISED_10baseT_Half)
-			new_adv_reg |= ADVERTISE_10HALF;
-		if (bp->advertising & ADVERTISED_10baseT_Full)
-			new_adv_reg |= ADVERTISE_10FULL;
-		if (bp->advertising & ADVERTISED_100baseT_Half)
-			new_adv_reg |= ADVERTISE_100HALF;
-		if (bp->advertising & ADVERTISED_100baseT_Full)
-			new_adv_reg |= ADVERTISE_100FULL;
-		if (bp->advertising & ADVERTISED_1000baseT_Full)
-			new_adv1000_reg |= ADVERTISE_1000FULL;
-
-		new_adv_reg |= ADVERTISE_CSMA;
-
-		new_adv_reg |= bnx2_phy_get_pause_adv(bp);
-
-		if ((adv1000_reg != new_adv1000_reg) ||
-			(adv_reg != new_adv_reg) ||
-			((bmcr & BMCR_ANENABLE) == 0)) {
-
-			bnx2_write_phy(bp, bp->mii_adv, new_adv_reg);
-			bnx2_write_phy(bp, MII_CTRL1000, new_adv1000_reg);
-			bnx2_write_phy(bp, bp->mii_bmcr, BMCR_ANRESTART |
-				BMCR_ANENABLE);
-		}
-		else if (bp->link_up) {
-			/* Flow ctrl may have changed from auto to forced */
-			/* or vice-versa. */
-
-			bnx2_resolve_flow_ctrl(bp);
-			bnx2_set_mac_link(bp);
-		}
-		return 0;
-	}
-
-	new_bmcr = 0;
-	if (bp->req_line_speed == SPEED_100) {
-		new_bmcr |= BMCR_SPEED100;
-	}
-	if (bp->req_duplex == DUPLEX_FULL) {
-		new_bmcr |= BMCR_FULLDPLX;
-	}
-	if (new_bmcr != bmcr) {
-		u32 bmsr;
-
-		bnx2_read_phy(bp, bp->mii_bmsr, &bmsr);
-		bnx2_read_phy(bp, bp->mii_bmsr, &bmsr);
-
-		if (bmsr & BMSR_LSTATUS) {
-			/* Force link down */
-			bnx2_write_phy(bp, bp->mii_bmcr, BMCR_LOOPBACK);
-			spin_unlock_bh(&bp->phy_lock);
-			msleep(50);
-			spin_lock_bh(&bp->phy_lock);
-
-			bnx2_read_phy(bp, bp->mii_bmsr, &bmsr);
-			bnx2_read_phy(bp, bp->mii_bmsr, &bmsr);
-		}
-
-		bnx2_write_phy(bp, bp->mii_bmcr, new_bmcr);
-
-		/* Normally, the new speed is setup after the link has
-		 * gone down and up again. In some cases, link will not go
-		 * down so we need to set up the new speed here.
-		 */
-		if (bmsr & BMSR_LSTATUS) {
-			bp->line_speed = bp->req_line_speed;
-			bp->duplex = bp->req_duplex;
-			bnx2_resolve_flow_ctrl(bp);
-			bnx2_set_mac_link(bp);
-		}
-	} else {
-		bnx2_resolve_flow_ctrl(bp);
-		bnx2_set_mac_link(bp);
-	}
-	return 0;
-}
-
-static int
-bnx2_setup_phy(struct bnx2 *bp, u8 port)
-__releases(&bp->phy_lock)
-__acquires(&bp->phy_lock)
-{
-	if (bp->loopback == MAC_LOOPBACK)
-		return 0;
-
-	if (bp->phy_flags & BNX2_PHY_FLAG_SERDES) {
-		return (bnx2_setup_serdes_phy(bp, port));
-	}
-	else {
-		return (bnx2_setup_copper_phy(bp));
-	}
-}
-
-static int
-bnx2_init_5709s_phy(struct bnx2 *bp, int reset_phy)
-{
-	u32 val;
-
-	bp->mii_bmcr = MII_BMCR + 0x10;
-	bp->mii_bmsr = MII_BMSR + 0x10;
-	bp->mii_bmsr1 = MII_BNX2_GP_TOP_AN_STATUS1;
-	bp->mii_adv = MII_ADVERTISE + 0x10;
-	bp->mii_lpa = MII_LPA + 0x10;
-	bp->mii_up1 = MII_BNX2_OVER1G_UP1;
-
-	bnx2_write_phy(bp, MII_BNX2_BLK_ADDR, MII_BNX2_BLK_ADDR_AER);
-	bnx2_write_phy(bp, MII_BNX2_AER_AER, MII_BNX2_AER_AER_AN_MMD);
-
-	bnx2_write_phy(bp, MII_BNX2_BLK_ADDR, MII_BNX2_BLK_ADDR_COMBO_IEEEB0);
-	if (reset_phy)
-		bnx2_reset_phy(bp);
-
-	bnx2_write_phy(bp, MII_BNX2_BLK_ADDR, MII_BNX2_BLK_ADDR_SERDES_DIG);
-
-	bnx2_read_phy(bp, MII_BNX2_SERDES_DIG_1000XCTL1, &val);
-	val &= ~MII_BNX2_SD_1000XCTL1_AUTODET;
-	val |= MII_BNX2_SD_1000XCTL1_FIBER;
-	bnx2_write_phy(bp, MII_BNX2_SERDES_DIG_1000XCTL1, val);
-
-	bnx2_write_phy(bp, MII_BNX2_BLK_ADDR, MII_BNX2_BLK_ADDR_OVER1G);
-	bnx2_read_phy(bp, MII_BNX2_OVER1G_UP1, &val);
-	if (bp->phy_flags & BNX2_PHY_FLAG_2_5G_CAPABLE)
-		val |= BCM5708S_UP1_2G5;
-	else
-		val &= ~BCM5708S_UP1_2G5;
-	bnx2_write_phy(bp, MII_BNX2_OVER1G_UP1, val);
-
-	bnx2_write_phy(bp, MII_BNX2_BLK_ADDR, MII_BNX2_BLK_ADDR_BAM_NXTPG);
-	bnx2_read_phy(bp, MII_BNX2_BAM_NXTPG_CTL, &val);
-	val |= MII_BNX2_NXTPG_CTL_T2 | MII_BNX2_NXTPG_CTL_BAM;
-	bnx2_write_phy(bp, MII_BNX2_BAM_NXTPG_CTL, val);
-
-	bnx2_write_phy(bp, MII_BNX2_BLK_ADDR, MII_BNX2_BLK_ADDR_CL73_USERB0);
-
-	val = MII_BNX2_CL73_BAM_EN | MII_BNX2_CL73_BAM_STA_MGR_EN |
-	      MII_BNX2_CL73_BAM_NP_AFT_BP_EN;
-	bnx2_write_phy(bp, MII_BNX2_CL73_BAM_CTL1, val);
-
-	bnx2_write_phy(bp, MII_BNX2_BLK_ADDR, MII_BNX2_BLK_ADDR_COMBO_IEEEB0);
-
-	return 0;
-}
-
-static int
-bnx2_init_5708s_phy(struct bnx2 *bp, int reset_phy)
-{
-	u32 val;
-
-	if (reset_phy)
-		bnx2_reset_phy(bp);
-
-	bp->mii_up1 = BCM5708S_UP1;
-
-	bnx2_write_phy(bp, BCM5708S_BLK_ADDR, BCM5708S_BLK_ADDR_DIG3);
-	bnx2_write_phy(bp, BCM5708S_DIG_3_0, BCM5708S_DIG_3_0_USE_IEEE);
-	bnx2_write_phy(bp, BCM5708S_BLK_ADDR, BCM5708S_BLK_ADDR_DIG);
-
-	bnx2_read_phy(bp, BCM5708S_1000X_CTL1, &val);
-	val |= BCM5708S_1000X_CTL1_FIBER_MODE | BCM5708S_1000X_CTL1_AUTODET_EN;
-	bnx2_write_phy(bp, BCM5708S_1000X_CTL1, val);
-
-	bnx2_read_phy(bp, BCM5708S_1000X_CTL2, &val);
-	val |= BCM5708S_1000X_CTL2_PLLEL_DET_EN;
-	bnx2_write_phy(bp, BCM5708S_1000X_CTL2, val);
-
-	if (bp->phy_flags & BNX2_PHY_FLAG_2_5G_CAPABLE) {
-		bnx2_read_phy(bp, BCM5708S_UP1, &val);
-		val |= BCM5708S_UP1_2G5;
-		bnx2_write_phy(bp, BCM5708S_UP1, val);
-	}
-
-	if ((CHIP_ID(bp) == CHIP_ID_5708_A0) ||
-	    (CHIP_ID(bp) == CHIP_ID_5708_B0) ||
-	    (CHIP_ID(bp) == CHIP_ID_5708_B1)) {
-		/* increase tx signal amplitude */
-		bnx2_write_phy(bp, BCM5708S_BLK_ADDR,
-			       BCM5708S_BLK_ADDR_TX_MISC);
-		bnx2_read_phy(bp, BCM5708S_TX_ACTL1, &val);
-		val &= ~BCM5708S_TX_ACTL1_DRIVER_VCM;
-		bnx2_write_phy(bp, BCM5708S_TX_ACTL1, val);
-		bnx2_write_phy(bp, BCM5708S_BLK_ADDR, BCM5708S_BLK_ADDR_DIG);
-	}
-
-	val = bnx2_shmem_rd(bp, BNX2_PORT_HW_CFG_CONFIG) &
-	      BNX2_PORT_HW_CFG_CFG_TXCTL3_MASK;
-
-	if (val) {
-		u32 is_backplane;
-
-		is_backplane = bnx2_shmem_rd(bp, BNX2_SHARED_HW_CFG_CONFIG);
-		if (is_backplane & BNX2_SHARED_HW_CFG_PHY_BACKPLANE) {
-			bnx2_write_phy(bp, BCM5708S_BLK_ADDR,
-				       BCM5708S_BLK_ADDR_TX_MISC);
-			bnx2_write_phy(bp, BCM5708S_TX_ACTL3, val);
-			bnx2_write_phy(bp, BCM5708S_BLK_ADDR,
-				       BCM5708S_BLK_ADDR_DIG);
-		}
-	}
-	return 0;
-}
-
-static int
-bnx2_init_5706s_phy(struct bnx2 *bp, int reset_phy)
-{
-	if (reset_phy)
-		bnx2_reset_phy(bp);
-
-	bp->phy_flags &= ~BNX2_PHY_FLAG_PARALLEL_DETECT;
-
-	if (CHIP_NUM(bp) == CHIP_NUM_5706)
-        	REG_WR(bp, BNX2_MISC_GP_HW_CTL0, 0x300);
-
-	if (bp->dev->mtu > 1500) {
-		u32 val;
-
-		/* Set extended packet length bit */
-		bnx2_write_phy(bp, 0x18, 0x7);
-		bnx2_read_phy(bp, 0x18, &val);
-		bnx2_write_phy(bp, 0x18, (val & 0xfff8) | 0x4000);
-
-		bnx2_write_phy(bp, 0x1c, 0x6c00);
-		bnx2_read_phy(bp, 0x1c, &val);
-		bnx2_write_phy(bp, 0x1c, (val & 0x3ff) | 0xec02);
-	}
-	else {
-		u32 val;
-
-		bnx2_write_phy(bp, 0x18, 0x7);
-		bnx2_read_phy(bp, 0x18, &val);
-		bnx2_write_phy(bp, 0x18, val & ~0x4007);
-
-		bnx2_write_phy(bp, 0x1c, 0x6c00);
-		bnx2_read_phy(bp, 0x1c, &val);
-		bnx2_write_phy(bp, 0x1c, (val & 0x3fd) | 0xec00);
-	}
-
-	return 0;
-}
-
-static int
-bnx2_init_copper_phy(struct bnx2 *bp, int reset_phy)
-{
-	u32 val;
-
-	if (reset_phy)
-		bnx2_reset_phy(bp);
-
-	if (bp->phy_flags & BNX2_PHY_FLAG_CRC_FIX) {
-		bnx2_write_phy(bp, 0x18, 0x0c00);
-		bnx2_write_phy(bp, 0x17, 0x000a);
-		bnx2_write_phy(bp, 0x15, 0x310b);
-		bnx2_write_phy(bp, 0x17, 0x201f);
-		bnx2_write_phy(bp, 0x15, 0x9506);
-		bnx2_write_phy(bp, 0x17, 0x401f);
-		bnx2_write_phy(bp, 0x15, 0x14e2);
-		bnx2_write_phy(bp, 0x18, 0x0400);
-	}
-
-	if (bp->phy_flags & BNX2_PHY_FLAG_DIS_EARLY_DAC) {
-		bnx2_write_phy(bp, MII_BNX2_DSP_ADDRESS,
-			       MII_BNX2_DSP_EXPAND_REG | 0x8);
-		bnx2_read_phy(bp, MII_BNX2_DSP_RW_PORT, &val);
-		val &= ~(1 << 8);
-		bnx2_write_phy(bp, MII_BNX2_DSP_RW_PORT, val);
-	}
-
-	if (bp->dev->mtu > 1500) {
-		/* Set extended packet length bit */
-		bnx2_write_phy(bp, 0x18, 0x7);
-		bnx2_read_phy(bp, 0x18, &val);
-		bnx2_write_phy(bp, 0x18, val | 0x4000);
-
-		bnx2_read_phy(bp, 0x10, &val);
-		bnx2_write_phy(bp, 0x10, val | 0x1);
-	}
-	else {
-		bnx2_write_phy(bp, 0x18, 0x7);
-		bnx2_read_phy(bp, 0x18, &val);
-		bnx2_write_phy(bp, 0x18, val & ~0x4007);
-
-		bnx2_read_phy(bp, 0x10, &val);
-		bnx2_write_phy(bp, 0x10, val & ~0x1);
-	}
-
-	/* ethernet@wirespeed */
-	bnx2_write_phy(bp, 0x18, 0x7007);
-	bnx2_read_phy(bp, 0x18, &val);
-	bnx2_write_phy(bp, 0x18, val | (1 << 15) | (1 << 4));
-	return 0;
-}
-
-
-static int
-bnx2_init_phy(struct bnx2 *bp, int reset_phy)
-__releases(&bp->phy_lock)
-__acquires(&bp->phy_lock)
-{
-	u32 val;
-	int rc = 0;
-
-	bp->phy_flags &= ~BNX2_PHY_FLAG_INT_MODE_MASK;
-	bp->phy_flags |= BNX2_PHY_FLAG_INT_MODE_LINK_READY;
-
-	bp->mii_bmcr = MII_BMCR;
-	bp->mii_bmsr = MII_BMSR;
-	bp->mii_bmsr1 = MII_BMSR;
-	bp->mii_adv = MII_ADVERTISE;
-	bp->mii_lpa = MII_LPA;
-
-        REG_WR(bp, BNX2_EMAC_ATTENTION_ENA, BNX2_EMAC_ATTENTION_ENA_LINK);
-
-	if (bp->phy_flags & BNX2_PHY_FLAG_REMOTE_PHY_CAP)
-		goto setup_phy;
-
-	bnx2_read_phy(bp, MII_PHYSID1, &val);
-	bp->phy_id = val << 16;
-	bnx2_read_phy(bp, MII_PHYSID2, &val);
-	bp->phy_id |= val & 0xffff;
-
-	if (bp->phy_flags & BNX2_PHY_FLAG_SERDES) {
-		if (CHIP_NUM(bp) == CHIP_NUM_5706)
-			rc = bnx2_init_5706s_phy(bp, reset_phy);
-		else if (CHIP_NUM(bp) == CHIP_NUM_5708)
-			rc = bnx2_init_5708s_phy(bp, reset_phy);
-		else if (CHIP_NUM(bp) == CHIP_NUM_5709)
-			rc = bnx2_init_5709s_phy(bp, reset_phy);
-	}
-	else {
-		rc = bnx2_init_copper_phy(bp, reset_phy);
-	}
-
-setup_phy:
-	if (!rc)
-		rc = bnx2_setup_phy(bp, bp->phy_port);
-
-	return rc;
-}
-
-static int
-bnx2_set_mac_loopback(struct bnx2 *bp)
-{
-	u32 mac_mode;
-
-	mac_mode = REG_RD(bp, BNX2_EMAC_MODE);
-	mac_mode &= ~BNX2_EMAC_MODE_PORT;
-	mac_mode |= BNX2_EMAC_MODE_MAC_LOOP | BNX2_EMAC_MODE_FORCE_LINK;
-	REG_WR(bp, BNX2_EMAC_MODE, mac_mode);
-	bp->link_up = 1;
-	return 0;
-}
-
-static int bnx2_test_link(struct bnx2 *);
-
-static int
-bnx2_set_phy_loopback(struct bnx2 *bp)
-{
-	u32 mac_mode;
-	int rc, i;
-
-	spin_lock_bh(&bp->phy_lock);
-	rc = bnx2_write_phy(bp, bp->mii_bmcr, BMCR_LOOPBACK | BMCR_FULLDPLX |
-			    BMCR_SPEED1000);
-	spin_unlock_bh(&bp->phy_lock);
-	if (rc)
-		return rc;
-
-	for (i = 0; i < 10; i++) {
-		if (bnx2_test_link(bp) == 0)
-			break;
-		msleep(100);
-	}
-
-	mac_mode = REG_RD(bp, BNX2_EMAC_MODE);
-	mac_mode &= ~(BNX2_EMAC_MODE_PORT | BNX2_EMAC_MODE_HALF_DUPLEX |
-		      BNX2_EMAC_MODE_MAC_LOOP | BNX2_EMAC_MODE_FORCE_LINK |
-		      BNX2_EMAC_MODE_25G_MODE);
-
-	mac_mode |= BNX2_EMAC_MODE_PORT_GMII;
-	REG_WR(bp, BNX2_EMAC_MODE, mac_mode);
-	bp->link_up = 1;
-	return 0;
-}
-
-static int
-bnx2_fw_sync(struct bnx2 *bp, u32 msg_data, int ack, int silent)
-{
-	int i;
-	u32 val;
-
-	bp->fw_wr_seq++;
-	msg_data |= bp->fw_wr_seq;
-
-	bnx2_shmem_wr(bp, BNX2_DRV_MB, msg_data);
-
-	if (!ack)
-		return 0;
-
-	/* wait for an acknowledgement. */
-	for (i = 0; i < (BNX2_FW_ACK_TIME_OUT_MS / 10); i++) {
-		msleep(10);
-
-		val = bnx2_shmem_rd(bp, BNX2_FW_MB);
-
-		if ((val & BNX2_FW_MSG_ACK) == (msg_data & BNX2_DRV_MSG_SEQ))
-			break;
-	}
-	if ((msg_data & BNX2_DRV_MSG_DATA) == BNX2_DRV_MSG_DATA_WAIT0)
-		return 0;
-
-	/* If we timed out, inform the firmware that this is the case. */
-	if ((val & BNX2_FW_MSG_ACK) != (msg_data & BNX2_DRV_MSG_SEQ)) {
-		if (!silent)
-			printk(KERN_ERR PFX "fw sync timeout, reset code = "
-					    "%x\n", msg_data);
-
-		msg_data &= ~BNX2_DRV_MSG_CODE;
-		msg_data |= BNX2_DRV_MSG_CODE_FW_TIMEOUT;
-
-		bnx2_shmem_wr(bp, BNX2_DRV_MB, msg_data);
-
-		return -EBUSY;
-	}
-
-	if ((val & BNX2_FW_MSG_STATUS_MASK) != BNX2_FW_MSG_STATUS_OK)
-		return -EIO;
-
-	return 0;
-}
-
-static int
-bnx2_init_5709_context(struct bnx2 *bp)
-{
-	int i, ret = 0;
-	u32 val;
-
-	val = BNX2_CTX_COMMAND_ENABLED | BNX2_CTX_COMMAND_MEM_INIT | (1 << 12);
-	val |= (BCM_PAGE_BITS - 8) << 16;
-	REG_WR(bp, BNX2_CTX_COMMAND, val);
-	for (i = 0; i < 10; i++) {
-		val = REG_RD(bp, BNX2_CTX_COMMAND);
-		if (!(val & BNX2_CTX_COMMAND_MEM_INIT))
-			break;
-		udelay(2);
-	}
-	if (val & BNX2_CTX_COMMAND_MEM_INIT)
-		return -EBUSY;
-
-	for (i = 0; i < bp->ctx_pages; i++) {
-		int j;
-
-		if (bp->ctx_blk[i])
-			memset(bp->ctx_blk[i], 0, BCM_PAGE_SIZE);
-		else
-			return -ENOMEM;
-
-		REG_WR(bp, BNX2_CTX_HOST_PAGE_TBL_DATA0,
-		       (bp->ctx_blk_mapping[i] & 0xffffffff) |
-		       BNX2_CTX_HOST_PAGE_TBL_DATA0_VALID);
-		REG_WR(bp, BNX2_CTX_HOST_PAGE_TBL_DATA1,
-		       (u64) bp->ctx_blk_mapping[i] >> 32);
-		REG_WR(bp, BNX2_CTX_HOST_PAGE_TBL_CTRL, i |
-		       BNX2_CTX_HOST_PAGE_TBL_CTRL_WRITE_REQ);
-		for (j = 0; j < 10; j++) {
-
-			val = REG_RD(bp, BNX2_CTX_HOST_PAGE_TBL_CTRL);
-			if (!(val & BNX2_CTX_HOST_PAGE_TBL_CTRL_WRITE_REQ))
-				break;
-			udelay(5);
-		}
-		if (val & BNX2_CTX_HOST_PAGE_TBL_CTRL_WRITE_REQ) {
-			ret = -EBUSY;
-			break;
-		}
-	}
-	return ret;
-}
-
-static void
-bnx2_init_context(struct bnx2 *bp)
-{
-	u32 vcid;
-
-	vcid = 96;
-	while (vcid) {
-		u32 vcid_addr, pcid_addr, offset;
-		int i;
-
-		vcid--;
-
-		if (CHIP_ID(bp) == CHIP_ID_5706_A0) {
-			u32 new_vcid;
-
-			vcid_addr = GET_PCID_ADDR(vcid);
-			if (vcid & 0x8) {
-				new_vcid = 0x60 + (vcid & 0xf0) + (vcid & 0x7);
-			}
-			else {
-				new_vcid = vcid;
-			}
-			pcid_addr = GET_PCID_ADDR(new_vcid);
-		}
-		else {
-	    		vcid_addr = GET_CID_ADDR(vcid);
-			pcid_addr = vcid_addr;
-		}
-
-		for (i = 0; i < (CTX_SIZE / PHY_CTX_SIZE); i++) {
-			vcid_addr += (i << PHY_CTX_SHIFT);
-			pcid_addr += (i << PHY_CTX_SHIFT);
-
-			REG_WR(bp, BNX2_CTX_VIRT_ADDR, vcid_addr);
-			REG_WR(bp, BNX2_CTX_PAGE_TBL, pcid_addr);
-
-			/* Zero out the context. */
-			for (offset = 0; offset < PHY_CTX_SIZE; offset += 4)
-				bnx2_ctx_wr(bp, vcid_addr, offset, 0);
-		}
-	}
-}
-
-static int
-bnx2_alloc_bad_rbuf(struct bnx2 *bp)
-{
-	u16 *good_mbuf;
-	u32 good_mbuf_cnt;
-	u32 val;
-
-	good_mbuf = kmalloc(512 * sizeof(u16), GFP_KERNEL);
-	if (good_mbuf == NULL) {
-		printk(KERN_ERR PFX "Failed to allocate memory in "
-				    "bnx2_alloc_bad_rbuf\n");
-		return -ENOMEM;
-	}
-
-	REG_WR(bp, BNX2_MISC_ENABLE_SET_BITS,
-		BNX2_MISC_ENABLE_SET_BITS_RX_MBUF_ENABLE);
-
-	good_mbuf_cnt = 0;
-
-	/* Allocate a bunch of mbufs and save the good ones in an array. */
-	val = bnx2_reg_rd_ind(bp, BNX2_RBUF_STATUS1);
-	while (val & BNX2_RBUF_STATUS1_FREE_COUNT) {
-		bnx2_reg_wr_ind(bp, BNX2_RBUF_COMMAND,
-				BNX2_RBUF_COMMAND_ALLOC_REQ);
-
-		val = bnx2_reg_rd_ind(bp, BNX2_RBUF_FW_BUF_ALLOC);
-
-		val &= BNX2_RBUF_FW_BUF_ALLOC_VALUE;
-
-		/* The addresses with Bit 9 set are bad memory blocks. */
-		if (!(val & (1 << 9))) {
-			good_mbuf[good_mbuf_cnt] = (u16) val;
-			good_mbuf_cnt++;
-		}
-
-		val = bnx2_reg_rd_ind(bp, BNX2_RBUF_STATUS1);
-	}
-
-	/* Free the good ones back to the mbuf pool thus discarding
-	 * all the bad ones. */
-	while (good_mbuf_cnt) {
-		good_mbuf_cnt--;
-
-		val = good_mbuf[good_mbuf_cnt];
-		val = (val << 9) | val | 1;
-
-		bnx2_reg_wr_ind(bp, BNX2_RBUF_FW_BUF_FREE, val);
-	}
-	kfree(good_mbuf);
-	return 0;
-}
-
-static void
-bnx2_set_mac_addr(struct bnx2 *bp, u8 *mac_addr, u32 pos)
-{
-	u32 val;
-
-	val = (mac_addr[0] << 8) | mac_addr[1];
-
-	REG_WR(bp, BNX2_EMAC_MAC_MATCH0 + (pos * 8), val);
-
-	val = (mac_addr[2] << 24) | (mac_addr[3] << 16) |
-		(mac_addr[4] << 8) | mac_addr[5];
-
-	REG_WR(bp, BNX2_EMAC_MAC_MATCH1 + (pos * 8), val);
-}
-
-static inline int
-bnx2_alloc_rx_page(struct bnx2 *bp, struct bnx2_rx_ring_info *rxr, u16 index)
-{
-	dma_addr_t mapping;
-	struct sw_pg *rx_pg = &rxr->rx_pg_ring[index];
-	struct rx_bd *rxbd =
-		&rxr->rx_pg_desc_ring[RX_RING(index)][RX_IDX(index)];
-	struct page *page = netdev_alloc_page(bp->dev);
-
-	if (!page)
-		return -ENOMEM;
-	mapping = pci_map_page(bp->pdev, page, 0, PAGE_SIZE,
-			       PCI_DMA_FROMDEVICE);
-	if (pci_dma_mapping_error(bp->pdev, mapping)) {
-		__free_page(page);
-		return -EIO;
-	}
-
-	rx_pg->page = page;
-	pci_unmap_addr_set(rx_pg, mapping, mapping);
-	rxbd->rx_bd_haddr_hi = (u64) mapping >> 32;
-	rxbd->rx_bd_haddr_lo = (u64) mapping & 0xffffffff;
-	return 0;
-}
-
-static void
-bnx2_free_rx_page(struct bnx2 *bp, struct bnx2_rx_ring_info *rxr, u16 index)
-{
-	struct sw_pg *rx_pg = &rxr->rx_pg_ring[index];
-	struct page *page = rx_pg->page;
-
-	if (!page)
-		return;
-
-	pci_unmap_page(bp->pdev, pci_unmap_addr(rx_pg, mapping), PAGE_SIZE,
-		       PCI_DMA_FROMDEVICE);
-
-	netdev_free_page(bp->dev, page);
-	rx_pg->page = NULL;
-}
-
-static inline int
-bnx2_alloc_rx_skb(struct bnx2 *bp, struct bnx2_rx_ring_info *rxr, u16 index)
-{
-	struct sk_buff *skb;
-	struct sw_bd *rx_buf = &rxr->rx_buf_ring[index];
-	dma_addr_t mapping;
-	struct rx_bd *rxbd = &rxr->rx_desc_ring[RX_RING(index)][RX_IDX(index)];
-	unsigned long align;
-
-	skb = netdev_alloc_skb(bp->dev, bp->rx_buf_size);
-	if (skb == NULL) {
-		return -ENOMEM;
-	}
-
-	if (unlikely((align = (unsigned long) skb->data & (BNX2_RX_ALIGN - 1))))
-		skb_reserve(skb, BNX2_RX_ALIGN - align);
-
-	mapping = pci_map_single(bp->pdev, skb->data, bp->rx_buf_use_size,
-		PCI_DMA_FROMDEVICE);
-	if (pci_dma_mapping_error(bp->pdev, mapping)) {
-		dev_kfree_skb(skb);
-		return -EIO;
-	}
-
-	rx_buf->skb = skb;
-	pci_unmap_addr_set(rx_buf, mapping, mapping);
-
-	rxbd->rx_bd_haddr_hi = (u64) mapping >> 32;
-	rxbd->rx_bd_haddr_lo = (u64) mapping & 0xffffffff;
-
-	rxr->rx_prod_bseq += bp->rx_buf_use_size;
-
-	return 0;
-}
-
-static int
-bnx2_phy_event_is_set(struct bnx2 *bp, struct bnx2_napi *bnapi, u32 event)
-{
-	struct status_block *sblk = bnapi->status_blk.msi;
-	u32 new_link_state, old_link_state;
-	int is_set = 1;
-
-	new_link_state = sblk->status_attn_bits & event;
-	old_link_state = sblk->status_attn_bits_ack & event;
-	if (new_link_state != old_link_state) {
-		if (new_link_state)
-			REG_WR(bp, BNX2_PCICFG_STATUS_BIT_SET_CMD, event);
-		else
-			REG_WR(bp, BNX2_PCICFG_STATUS_BIT_CLEAR_CMD, event);
-	} else
-		is_set = 0;
-
-	return is_set;
-}
-
-static void
-bnx2_phy_int(struct bnx2 *bp, struct bnx2_napi *bnapi)
-{
-	spin_lock(&bp->phy_lock);
-
-	if (bnx2_phy_event_is_set(bp, bnapi, STATUS_ATTN_BITS_LINK_STATE))
-		bnx2_set_link(bp);
-	if (bnx2_phy_event_is_set(bp, bnapi, STATUS_ATTN_BITS_TIMER_ABORT))
-		bnx2_set_remote_link(bp);
-
-	spin_unlock(&bp->phy_lock);
-
-}
-
-static inline u16
-bnx2_get_hw_tx_cons(struct bnx2_napi *bnapi)
-{
-	u16 cons;
-
-	/* Tell compiler that status block fields can change. */
-	barrier();
-	cons = *bnapi->hw_tx_cons_ptr;
-	barrier();
-	if (unlikely((cons & MAX_TX_DESC_CNT) == MAX_TX_DESC_CNT))
-		cons++;
-	return cons;
-}
-
-static int
-bnx2_tx_int(struct bnx2 *bp, struct bnx2_napi *bnapi, int budget)
-{
-	struct bnx2_tx_ring_info *txr = &bnapi->tx_ring;
-	u16 hw_cons, sw_cons, sw_ring_cons;
-	int tx_pkt = 0, index;
-	struct netdev_queue *txq;
-
-	index = (bnapi - bp->bnx2_napi);
-	txq = netdev_get_tx_queue(bp->dev, index);
-
-	hw_cons = bnx2_get_hw_tx_cons(bnapi);
-	sw_cons = txr->tx_cons;
-
-	while (sw_cons != hw_cons) {
-		struct sw_tx_bd *tx_buf;
-		struct sk_buff *skb;
-		int i, last;
-
-		sw_ring_cons = TX_RING_IDX(sw_cons);
-
-		tx_buf = &txr->tx_buf_ring[sw_ring_cons];
-		skb = tx_buf->skb;
-
-		/* prefetch skb_end_pointer() to speedup skb_shinfo(skb) */
-		prefetch(&skb->end);
-
-		/* partial BD completions possible with TSO packets */
-		if (tx_buf->is_gso) {
-			u16 last_idx, last_ring_idx;
-
-			last_idx = sw_cons + tx_buf->nr_frags + 1;
-			last_ring_idx = sw_ring_cons + tx_buf->nr_frags + 1;
-			if (unlikely(last_ring_idx >= MAX_TX_DESC_CNT)) {
-				last_idx++;
-			}
-			if (((s16) ((s16) last_idx - (s16) hw_cons)) > 0) {
-				break;
-			}
-		}
-
-		pci_unmap_single(bp->pdev, pci_unmap_addr(tx_buf, mapping),
-			skb_headlen(skb), PCI_DMA_TODEVICE);
-
-		tx_buf->skb = NULL;
-		last = tx_buf->nr_frags;
-
-		for (i = 0; i < last; i++) {
-			sw_cons = NEXT_TX_BD(sw_cons);
-
-			pci_unmap_page(bp->pdev,
-				pci_unmap_addr(
-					&txr->tx_buf_ring[TX_RING_IDX(sw_cons)],
-					mapping),
-				skb_shinfo(skb)->frags[i].size,
-				PCI_DMA_TODEVICE);
-		}
-
-		sw_cons = NEXT_TX_BD(sw_cons);
-
-		dev_kfree_skb(skb);
-		tx_pkt++;
-		if (tx_pkt == budget)
-			break;
-
-		if (hw_cons == sw_cons)
-			hw_cons = bnx2_get_hw_tx_cons(bnapi);
-	}
-
-	txr->hw_tx_cons = hw_cons;
-	txr->tx_cons = sw_cons;
-
-	/* Need to make the tx_cons update visible to bnx2_start_xmit()
-	 * before checking for netif_tx_queue_stopped().  Without the
-	 * memory barrier, there is a small possibility that bnx2_start_xmit()
-	 * will miss it and cause the queue to be stopped forever.
-	 */
-	smp_mb();
-
-	if (unlikely(netif_tx_queue_stopped(txq)) &&
-		     (bnx2_tx_avail(bp, txr) > bp->tx_wake_thresh)) {
-		__netif_tx_lock(txq, smp_processor_id());
-		if ((netif_tx_queue_stopped(txq)) &&
-		    (bnx2_tx_avail(bp, txr) > bp->tx_wake_thresh))
-			netif_tx_wake_queue(txq);
-		__netif_tx_unlock(txq);
-	}
-
-	return tx_pkt;
-}
-
-static void
-bnx2_reuse_rx_skb_pages(struct bnx2 *bp, struct bnx2_rx_ring_info *rxr,
-			struct sk_buff *skb, int count)
-{
-	struct sw_pg *cons_rx_pg, *prod_rx_pg;
-	struct rx_bd *cons_bd, *prod_bd;
-	int i;
-	u16 hw_prod, prod;
-	u16 cons = rxr->rx_pg_cons;
-
-	cons_rx_pg = &rxr->rx_pg_ring[cons];
-
-	/* The caller was unable to allocate a new page to replace the
-	 * last one in the frags array, so we need to recycle that page
-	 * and then free the skb.
-	 */
-	if (skb) {
-		struct page *page;
-		struct skb_shared_info *shinfo;
-
-		shinfo = skb_shinfo(skb);
-		shinfo->nr_frags--;
-		page = shinfo->frags[shinfo->nr_frags].page;
-		shinfo->frags[shinfo->nr_frags].page = NULL;
-
-		cons_rx_pg->page = page;
-		dev_kfree_skb(skb);
-	}
-
-	hw_prod = rxr->rx_pg_prod;
-
-	for (i = 0; i < count; i++) {
-		prod = RX_PG_RING_IDX(hw_prod);
-
-		prod_rx_pg = &rxr->rx_pg_ring[prod];
-		cons_rx_pg = &rxr->rx_pg_ring[cons];
-		cons_bd = &rxr->rx_pg_desc_ring[RX_RING(cons)][RX_IDX(cons)];
-		prod_bd = &rxr->rx_pg_desc_ring[RX_RING(prod)][RX_IDX(prod)];
-
-		if (prod != cons) {
-			prod_rx_pg->page = cons_rx_pg->page;
-			cons_rx_pg->page = NULL;
-			pci_unmap_addr_set(prod_rx_pg, mapping,
-				pci_unmap_addr(cons_rx_pg, mapping));
-
-			prod_bd->rx_bd_haddr_hi = cons_bd->rx_bd_haddr_hi;
-			prod_bd->rx_bd_haddr_lo = cons_bd->rx_bd_haddr_lo;
-
-		}
-		cons = RX_PG_RING_IDX(NEXT_RX_BD(cons));
-		hw_prod = NEXT_RX_BD(hw_prod);
-	}
-	rxr->rx_pg_prod = hw_prod;
-	rxr->rx_pg_cons = cons;
-}
-
-static inline void
-bnx2_reuse_rx_skb(struct bnx2 *bp, struct bnx2_rx_ring_info *rxr,
-		  struct sk_buff *skb, u16 cons, u16 prod)
-{
-	struct sw_bd *cons_rx_buf, *prod_rx_buf;
-	struct rx_bd *cons_bd, *prod_bd;
-
-	cons_rx_buf = &rxr->rx_buf_ring[cons];
-	prod_rx_buf = &rxr->rx_buf_ring[prod];
-
-	pci_dma_sync_single_for_device(bp->pdev,
-		pci_unmap_addr(cons_rx_buf, mapping),
-		BNX2_RX_OFFSET + BNX2_RX_COPY_THRESH, PCI_DMA_FROMDEVICE);
-
-	rxr->rx_prod_bseq += bp->rx_buf_use_size;
-
-	prod_rx_buf->skb = skb;
-
-	if (cons == prod)
-		return;
-
-	pci_unmap_addr_set(prod_rx_buf, mapping,
-			pci_unmap_addr(cons_rx_buf, mapping));
-
-	cons_bd = &rxr->rx_desc_ring[RX_RING(cons)][RX_IDX(cons)];
-	prod_bd = &rxr->rx_desc_ring[RX_RING(prod)][RX_IDX(prod)];
-	prod_bd->rx_bd_haddr_hi = cons_bd->rx_bd_haddr_hi;
-	prod_bd->rx_bd_haddr_lo = cons_bd->rx_bd_haddr_lo;
-}
-
-static int
-bnx2_rx_skb(struct bnx2 *bp, struct bnx2_rx_ring_info *rxr, struct sk_buff *skb,
-	    unsigned int len, unsigned int hdr_len, dma_addr_t dma_addr,
-	    u32 ring_idx)
-{
-	int err;
-	u16 prod = ring_idx & 0xffff;
-
-	err = bnx2_alloc_rx_skb(bp, rxr, prod);
-	if (unlikely(err)) {
-		bnx2_reuse_rx_skb(bp, rxr, skb, (u16) (ring_idx >> 16), prod);
-		if (hdr_len) {
-			unsigned int raw_len = len + 4;
-			int pages = PAGE_ALIGN(raw_len - hdr_len) >> PAGE_SHIFT;
-
-			bnx2_reuse_rx_skb_pages(bp, rxr, NULL, pages);
-		}
-		return err;
-	}
-
-	skb_reserve(skb, BNX2_RX_OFFSET);
-	pci_unmap_single(bp->pdev, dma_addr, bp->rx_buf_use_size,
-			 PCI_DMA_FROMDEVICE);
-
-	if (hdr_len == 0) {
-		skb_put(skb, len);
-		return 0;
-	} else {
-		unsigned int i, frag_len, frag_size, pages;
-		struct sw_pg *rx_pg;
-		u16 pg_cons = rxr->rx_pg_cons;
-		u16 pg_prod = rxr->rx_pg_prod;
-
-		frag_size = len + 4 - hdr_len;
-		pages = PAGE_ALIGN(frag_size) >> PAGE_SHIFT;
-		skb_put(skb, hdr_len);
-
-		for (i = 0; i < pages; i++) {
-			dma_addr_t mapping_old;
-
-			frag_len = min(frag_size, (unsigned int) PAGE_SIZE);
-			if (unlikely(frag_len <= 4)) {
-				unsigned int tail = 4 - frag_len;
-
-				rxr->rx_pg_cons = pg_cons;
-				rxr->rx_pg_prod = pg_prod;
-				bnx2_reuse_rx_skb_pages(bp, rxr, NULL,
-							pages - i);
-				skb->len -= tail;
-				if (i == 0) {
-					skb->tail -= tail;
-				} else {
-					skb_frag_t *frag =
-						&skb_shinfo(skb)->frags[i - 1];
-					frag->size -= tail;
-					skb->data_len -= tail;
-					skb->truesize -= tail;
-				}
-				return 0;
-			}
-			rx_pg = &rxr->rx_pg_ring[pg_cons];
-
-			/* Don't unmap yet.  If we're unable to allocate a new
-			 * page, we need to recycle the page and the DMA addr.
-			 */
-			mapping_old = pci_unmap_addr(rx_pg, mapping);
-			if (i == pages - 1)
-				frag_len -= 4;
-
-			skb_add_rx_frag(skb, i, rx_pg->page, 0, frag_len);
-			rx_pg->page = NULL;
-
-			err = bnx2_alloc_rx_page(bp, rxr,
-						 RX_PG_RING_IDX(pg_prod));
-			if (unlikely(err)) {
-				rxr->rx_pg_cons = pg_cons;
-				rxr->rx_pg_prod = pg_prod;
-				bnx2_reuse_rx_skb_pages(bp, rxr, skb,
-							pages - i);
-				return err;
-			}
-
-			pci_unmap_page(bp->pdev, mapping_old,
-				       PAGE_SIZE, PCI_DMA_FROMDEVICE);
-
-			frag_size -= frag_len;
-
-			pg_prod = NEXT_RX_BD(pg_prod);
-			pg_cons = RX_PG_RING_IDX(NEXT_RX_BD(pg_cons));
-		}
-		rxr->rx_pg_prod = pg_prod;
-		rxr->rx_pg_cons = pg_cons;
-	}
-	return 0;
-}
-
-static inline u16
-bnx2_get_hw_rx_cons(struct bnx2_napi *bnapi)
-{
-	u16 cons;
-
-	/* Tell compiler that status block fields can change. */
-	barrier();
-	cons = *bnapi->hw_rx_cons_ptr;
-	barrier();
-	if (unlikely((cons & MAX_RX_DESC_CNT) == MAX_RX_DESC_CNT))
-		cons++;
-	return cons;
-}
-
-static int
-bnx2_rx_int(struct bnx2 *bp, struct bnx2_napi *bnapi, int budget)
-{
-	struct bnx2_rx_ring_info *rxr = &bnapi->rx_ring;
-	u16 hw_cons, sw_cons, sw_ring_cons, sw_prod, sw_ring_prod;
-	struct l2_fhdr *rx_hdr;
-	int rx_pkt = 0, pg_ring_used = 0;
-
-	hw_cons = bnx2_get_hw_rx_cons(bnapi);
-	sw_cons = rxr->rx_cons;
-	sw_prod = rxr->rx_prod;
-
-	/* Memory barrier necessary as speculative reads of the rx
-	 * buffer can be ahead of the index in the status block
-	 */
-	rmb();
-	while (sw_cons != hw_cons) {
-		unsigned int len, hdr_len;
-		u32 status;
-		struct sw_bd *rx_buf;
-		struct sk_buff *skb;
-		dma_addr_t dma_addr;
-		u16 vtag = 0;
-		int hw_vlan __maybe_unused = 0;
-
-		sw_ring_cons = RX_RING_IDX(sw_cons);
-		sw_ring_prod = RX_RING_IDX(sw_prod);
-
-		rx_buf = &rxr->rx_buf_ring[sw_ring_cons];
-		skb = rx_buf->skb;
-
-		rx_buf->skb = NULL;
-
-		dma_addr = pci_unmap_addr(rx_buf, mapping);
-
-		pci_dma_sync_single_for_cpu(bp->pdev, dma_addr,
-			BNX2_RX_OFFSET + BNX2_RX_COPY_THRESH,
-			PCI_DMA_FROMDEVICE);
-
-		rx_hdr = (struct l2_fhdr *) skb->data;
-		len = rx_hdr->l2_fhdr_pkt_len;
-		status = rx_hdr->l2_fhdr_status;
-
-		hdr_len = 0;
-		if (status & L2_FHDR_STATUS_SPLIT) {
-			hdr_len = rx_hdr->l2_fhdr_ip_xsum;
-			pg_ring_used = 1;
-		} else if (len > bp->rx_jumbo_thresh) {
-			hdr_len = bp->rx_jumbo_thresh;
-			pg_ring_used = 1;
-		}
-
-		if (unlikely(status & (L2_FHDR_ERRORS_BAD_CRC |
-				       L2_FHDR_ERRORS_PHY_DECODE |
-				       L2_FHDR_ERRORS_ALIGNMENT |
-				       L2_FHDR_ERRORS_TOO_SHORT |
-				       L2_FHDR_ERRORS_GIANT_FRAME))) {
-
-			bnx2_reuse_rx_skb(bp, rxr, skb, sw_ring_cons,
-					  sw_ring_prod);
-			if (pg_ring_used) {
-				int pages;
-
-				pages = PAGE_ALIGN(len - hdr_len) >> PAGE_SHIFT;
-
-				bnx2_reuse_rx_skb_pages(bp, rxr, NULL, pages);
-			}
-			goto next_rx;
-		}
-
-		len -= 4;
-
-		if (len <= bp->rx_copy_thresh) {
-			struct sk_buff *new_skb;
-
-			new_skb = netdev_alloc_skb(bp->dev, len + 6);
-			if (new_skb == NULL) {
-				bnx2_reuse_rx_skb(bp, rxr, skb, sw_ring_cons,
-						  sw_ring_prod);
-				goto next_rx;
-			}
-
-			/* aligned copy */
-			skb_copy_from_linear_data_offset(skb,
-							 BNX2_RX_OFFSET - 6,
-				      new_skb->data, len + 6);
-			skb_reserve(new_skb, 6);
-			skb_put(new_skb, len);
-
-			bnx2_reuse_rx_skb(bp, rxr, skb,
-				sw_ring_cons, sw_ring_prod);
-
-			skb = new_skb;
-		} else if (unlikely(bnx2_rx_skb(bp, rxr, skb, len, hdr_len,
-			   dma_addr, (sw_ring_cons << 16) | sw_ring_prod)))
-			goto next_rx;
-
-		if ((status & L2_FHDR_STATUS_L2_VLAN_TAG) &&
-		    !(bp->rx_mode & BNX2_EMAC_RX_MODE_KEEP_VLAN_TAG)) {
-			vtag = rx_hdr->l2_fhdr_vlan_tag;
-#ifdef BCM_VLAN
-			if (bp->vlgrp)
-				hw_vlan = 1;
-			else
-#endif
-			{
-				struct vlan_ethhdr *ve = (struct vlan_ethhdr *)
-					__skb_push(skb, 4);
-
-				memmove(ve, skb->data + 4, ETH_ALEN * 2);
-				ve->h_vlan_proto = htons(ETH_P_8021Q);
-				ve->h_vlan_TCI = htons(vtag);
-				len += 4;
-			}
-		}
-
-		skb->protocol = eth_type_trans(skb, bp->dev);
-
-		if ((len > (bp->dev->mtu + ETH_HLEN)) &&
-			(ntohs(skb->protocol) != 0x8100)) {
-
-			dev_kfree_skb(skb);
-			goto next_rx;
-
-		}
-
-		skb->ip_summed = CHECKSUM_NONE;
-		if (bp->rx_csum &&
-			(status & (L2_FHDR_STATUS_TCP_SEGMENT |
-			L2_FHDR_STATUS_UDP_DATAGRAM))) {
-
-			if (likely((status & (L2_FHDR_ERRORS_TCP_XSUM |
-					      L2_FHDR_ERRORS_UDP_XSUM)) == 0))
-				skb->ip_summed = CHECKSUM_UNNECESSARY;
-		}
-
-		skb_record_rx_queue(skb, bnapi - &bp->bnx2_napi[0]);
-
-#ifdef BCM_VLAN
-		if (hw_vlan)
-			vlan_hwaccel_receive_skb(skb, bp->vlgrp, vtag);
-		else
-#endif
-			netif_receive_skb(skb);
-
-		rx_pkt++;
-
-next_rx:
-		sw_cons = NEXT_RX_BD(sw_cons);
-		sw_prod = NEXT_RX_BD(sw_prod);
-
-		if ((rx_pkt == budget))
-			break;
-
-		/* Refresh hw_cons to see if there is new work */
-		if (sw_cons == hw_cons) {
-			hw_cons = bnx2_get_hw_rx_cons(bnapi);
-			rmb();
-		}
-	}
-	rxr->rx_cons = sw_cons;
-	rxr->rx_prod = sw_prod;
-
-	if (pg_ring_used)
-		REG_WR16(bp, rxr->rx_pg_bidx_addr, rxr->rx_pg_prod);
-
-	REG_WR16(bp, rxr->rx_bidx_addr, sw_prod);
-
-	REG_WR(bp, rxr->rx_bseq_addr, rxr->rx_prod_bseq);
-
-	mmiowb();
-
-	return rx_pkt;
-
-}
-
-/* MSI ISR - The only difference between this and the INTx ISR
- * is that the MSI interrupt is always serviced.
- */
-static irqreturn_t
-bnx2_msi(int irq, void *dev_instance)
-{
-	struct bnx2_napi *bnapi = dev_instance;
-	struct bnx2 *bp = bnapi->bp;
-
-	prefetch(bnapi->status_blk.msi);
-	REG_WR(bp, BNX2_PCICFG_INT_ACK_CMD,
-		BNX2_PCICFG_INT_ACK_CMD_USE_INT_HC_PARAM |
-		BNX2_PCICFG_INT_ACK_CMD_MASK_INT);
-
-	/* Return here if interrupt is disabled. */
-	if (unlikely(atomic_read(&bp->intr_sem) != 0))
-		return IRQ_HANDLED;
-
-	napi_schedule(&bnapi->napi);
-
-	return IRQ_HANDLED;
-}
-
-static irqreturn_t
-bnx2_msi_1shot(int irq, void *dev_instance)
-{
-	struct bnx2_napi *bnapi = dev_instance;
-	struct bnx2 *bp = bnapi->bp;
-
-	prefetch(bnapi->status_blk.msi);
-
-	/* Return here if interrupt is disabled. */
-	if (unlikely(atomic_read(&bp->intr_sem) != 0))
-		return IRQ_HANDLED;
-
-	napi_schedule(&bnapi->napi);
-
-	return IRQ_HANDLED;
-}
-
-static irqreturn_t
-bnx2_interrupt(int irq, void *dev_instance)
-{
-	struct bnx2_napi *bnapi = dev_instance;
-	struct bnx2 *bp = bnapi->bp;
-	struct status_block *sblk = bnapi->status_blk.msi;
-
-	/* When using INTx, it is possible for the interrupt to arrive
-	 * at the CPU before the status block posted prior to the
-	 * interrupt. Reading a register will flush the status block.
-	 * When using MSI, the MSI message will always complete after
-	 * the status block write.
-	 */
-	if ((sblk->status_idx == bnapi->last_status_idx) &&
-	    (REG_RD(bp, BNX2_PCICFG_MISC_STATUS) &
-	     BNX2_PCICFG_MISC_STATUS_INTA_VALUE))
-		return IRQ_NONE;
-
-	REG_WR(bp, BNX2_PCICFG_INT_ACK_CMD,
-		BNX2_PCICFG_INT_ACK_CMD_USE_INT_HC_PARAM |
-		BNX2_PCICFG_INT_ACK_CMD_MASK_INT);
-
-	/* Read back to deassert IRQ immediately to avoid too many
-	 * spurious interrupts.
-	 */
-	REG_RD(bp, BNX2_PCICFG_INT_ACK_CMD);
-
-	/* Return here if interrupt is shared and is disabled. */
-	if (unlikely(atomic_read(&bp->intr_sem) != 0))
-		return IRQ_HANDLED;
-
-	if (napi_schedule_prep(&bnapi->napi)) {
-		bnapi->last_status_idx = sblk->status_idx;
-		__napi_schedule(&bnapi->napi);
-	}
-
-	return IRQ_HANDLED;
-}
-
-static inline int
-bnx2_has_fast_work(struct bnx2_napi *bnapi)
-{
-	struct bnx2_tx_ring_info *txr = &bnapi->tx_ring;
-	struct bnx2_rx_ring_info *rxr = &bnapi->rx_ring;
-
-	if ((bnx2_get_hw_rx_cons(bnapi) != rxr->rx_cons) ||
-	    (bnx2_get_hw_tx_cons(bnapi) != txr->hw_tx_cons))
-		return 1;
-	return 0;
-}
-
-#define STATUS_ATTN_EVENTS	(STATUS_ATTN_BITS_LINK_STATE | \
-				 STATUS_ATTN_BITS_TIMER_ABORT)
-
-static inline int
-bnx2_has_work(struct bnx2_napi *bnapi)
-{
-	struct status_block *sblk = bnapi->status_blk.msi;
-
-	if (bnx2_has_fast_work(bnapi))
-		return 1;
-
-#ifdef BCM_CNIC
-	if (bnapi->cnic_present && (bnapi->cnic_tag != sblk->status_idx))
-		return 1;
-#endif
-
-	if ((sblk->status_attn_bits & STATUS_ATTN_EVENTS) !=
-	    (sblk->status_attn_bits_ack & STATUS_ATTN_EVENTS))
-		return 1;
-
-	return 0;
-}
-
-static void
-bnx2_chk_missed_msi(struct bnx2 *bp)
-{
-	struct bnx2_napi *bnapi = &bp->bnx2_napi[0];
-	u32 msi_ctrl;
-
-	if (bnx2_has_work(bnapi)) {
-		msi_ctrl = REG_RD(bp, BNX2_PCICFG_MSI_CONTROL);
-		if (!(msi_ctrl & BNX2_PCICFG_MSI_CONTROL_ENABLE))
-			return;
-
-		if (bnapi->last_status_idx == bp->idle_chk_status_idx) {
-			REG_WR(bp, BNX2_PCICFG_MSI_CONTROL, msi_ctrl &
-			       ~BNX2_PCICFG_MSI_CONTROL_ENABLE);
-			REG_WR(bp, BNX2_PCICFG_MSI_CONTROL, msi_ctrl);
-			bnx2_msi(bp->irq_tbl[0].vector, bnapi);
-		}
-	}
-
-	bp->idle_chk_status_idx = bnapi->last_status_idx;
-}
-
-#ifdef BCM_CNIC
-static void bnx2_poll_cnic(struct bnx2 *bp, struct bnx2_napi *bnapi)
-{
-	struct cnic_ops *c_ops;
-
-	if (!bnapi->cnic_present)
-		return;
-
-	rcu_read_lock();
-	c_ops = rcu_dereference(bp->cnic_ops);
-	if (c_ops)
-		bnapi->cnic_tag = c_ops->cnic_handler(bp->cnic_data,
-						      bnapi->status_blk.msi);
-	rcu_read_unlock();
-}
-#endif
-
-static void bnx2_poll_link(struct bnx2 *bp, struct bnx2_napi *bnapi)
-{
-	struct status_block *sblk = bnapi->status_blk.msi;
-	u32 status_attn_bits = sblk->status_attn_bits;
-	u32 status_attn_bits_ack = sblk->status_attn_bits_ack;
-
-	if ((status_attn_bits & STATUS_ATTN_EVENTS) !=
-	    (status_attn_bits_ack & STATUS_ATTN_EVENTS)) {
-
-		bnx2_phy_int(bp, bnapi);
-
-		/* This is needed to take care of transient status
-		 * during link changes.
-		 */
-		REG_WR(bp, BNX2_HC_COMMAND,
-		       bp->hc_cmd | BNX2_HC_COMMAND_COAL_NOW_WO_INT);
-		REG_RD(bp, BNX2_HC_COMMAND);
-	}
-}
-
-static int bnx2_poll_work(struct bnx2 *bp, struct bnx2_napi *bnapi,
-			  int work_done, int budget)
-{
-	struct bnx2_tx_ring_info *txr = &bnapi->tx_ring;
-	struct bnx2_rx_ring_info *rxr = &bnapi->rx_ring;
-
-	if (bnx2_get_hw_tx_cons(bnapi) != txr->hw_tx_cons)
-		bnx2_tx_int(bp, bnapi, 0);
-
-	if (bnx2_get_hw_rx_cons(bnapi) != rxr->rx_cons)
-		work_done += bnx2_rx_int(bp, bnapi, budget - work_done);
-
-	return work_done;
-}
-
-static int bnx2_poll_msix(struct napi_struct *napi, int budget)
-{
-	struct bnx2_napi *bnapi = container_of(napi, struct bnx2_napi, napi);
-	struct bnx2 *bp = bnapi->bp;
-	int work_done = 0;
-	struct status_block_msix *sblk = bnapi->status_blk.msix;
-
-	while (1) {
-		work_done = bnx2_poll_work(bp, bnapi, work_done, budget);
-		if (unlikely(work_done >= budget))
-			break;
-
-		bnapi->last_status_idx = sblk->status_idx;
-		/* status idx must be read before checking for more work. */
-		rmb();
-		if (likely(!bnx2_has_fast_work(bnapi))) {
-
-			napi_complete(napi);
-			REG_WR(bp, BNX2_PCICFG_INT_ACK_CMD, bnapi->int_num |
-			       BNX2_PCICFG_INT_ACK_CMD_INDEX_VALID |
-			       bnapi->last_status_idx);
-			break;
-		}
-	}
-	return work_done;
-}
-
-static int bnx2_poll(struct napi_struct *napi, int budget)
-{
-	struct bnx2_napi *bnapi = container_of(napi, struct bnx2_napi, napi);
-	struct bnx2 *bp = bnapi->bp;
-	int work_done = 0;
-	struct status_block *sblk = bnapi->status_blk.msi;
-
-	while (1) {
-		bnx2_poll_link(bp, bnapi);
-
-		work_done = bnx2_poll_work(bp, bnapi, work_done, budget);
-
-#ifdef BCM_CNIC
-		bnx2_poll_cnic(bp, bnapi);
-#endif
-
-		/* bnapi->last_status_idx is used below to tell the hw how
-		 * much work has been processed, so we must read it before
-		 * checking for more work.
-		 */
-		bnapi->last_status_idx = sblk->status_idx;
-
-		if (unlikely(work_done >= budget))
-			break;
-
-		rmb();
-		if (likely(!bnx2_has_work(bnapi))) {
-			napi_complete(napi);
-			if (likely(bp->flags & BNX2_FLAG_USING_MSI_OR_MSIX)) {
-				REG_WR(bp, BNX2_PCICFG_INT_ACK_CMD,
-				       BNX2_PCICFG_INT_ACK_CMD_INDEX_VALID |
-				       bnapi->last_status_idx);
-				break;
-			}
-			REG_WR(bp, BNX2_PCICFG_INT_ACK_CMD,
-			       BNX2_PCICFG_INT_ACK_CMD_INDEX_VALID |
-			       BNX2_PCICFG_INT_ACK_CMD_MASK_INT |
-			       bnapi->last_status_idx);
-
-			REG_WR(bp, BNX2_PCICFG_INT_ACK_CMD,
-			       BNX2_PCICFG_INT_ACK_CMD_INDEX_VALID |
-			       bnapi->last_status_idx);
-			break;
-		}
-	}
-
-	return work_done;
-}
-
-/* Called with rtnl_lock from vlan functions and also netif_tx_lock
- * from set_multicast.
- */
-static void
-bnx2_set_rx_mode(struct net_device *dev)
-{
-	struct bnx2 *bp = netdev_priv(dev);
-	u32 rx_mode, sort_mode;
-	struct netdev_hw_addr *ha;
-	int i;
-
-	if (!netif_running(dev))
-		return;
-
-	spin_lock_bh(&bp->phy_lock);
-
-	rx_mode = bp->rx_mode & ~(BNX2_EMAC_RX_MODE_PROMISCUOUS |
-				  BNX2_EMAC_RX_MODE_KEEP_VLAN_TAG);
-	sort_mode = 1 | BNX2_RPM_SORT_USER0_BC_EN;
-#ifdef BCM_VLAN
-	if (!bp->vlgrp && (bp->flags & BNX2_FLAG_CAN_KEEP_VLAN))
-		rx_mode |= BNX2_EMAC_RX_MODE_KEEP_VLAN_TAG;
-#else
-	if (bp->flags & BNX2_FLAG_CAN_KEEP_VLAN)
-		rx_mode |= BNX2_EMAC_RX_MODE_KEEP_VLAN_TAG;
-#endif
-	if (dev->flags & IFF_PROMISC) {
-		/* Promiscuous mode. */
-		rx_mode |= BNX2_EMAC_RX_MODE_PROMISCUOUS;
-		sort_mode |= BNX2_RPM_SORT_USER0_PROM_EN |
-			     BNX2_RPM_SORT_USER0_PROM_VLAN;
-	}
-	else if (dev->flags & IFF_ALLMULTI) {
-		for (i = 0; i < NUM_MC_HASH_REGISTERS; i++) {
-			REG_WR(bp, BNX2_EMAC_MULTICAST_HASH0 + (i * 4),
-			       0xffffffff);
-        	}
-		sort_mode |= BNX2_RPM_SORT_USER0_MC_EN;
-	}
-	else {
-		/* Accept one or more multicast(s). */
-		struct dev_mc_list *mclist;
-		u32 mc_filter[NUM_MC_HASH_REGISTERS];
-		u32 regidx;
-		u32 bit;
-		u32 crc;
-
-		memset(mc_filter, 0, 4 * NUM_MC_HASH_REGISTERS);
-
-		for (i = 0, mclist = dev->mc_list; mclist && i < dev->mc_count;
-		     i++, mclist = mclist->next) {
-
-			crc = ether_crc_le(ETH_ALEN, mclist->dmi_addr);
-			bit = crc & 0xff;
-			regidx = (bit & 0xe0) >> 5;
-			bit &= 0x1f;
-			mc_filter[regidx] |= (1 << bit);
-		}
-
-		for (i = 0; i < NUM_MC_HASH_REGISTERS; i++) {
-			REG_WR(bp, BNX2_EMAC_MULTICAST_HASH0 + (i * 4),
-			       mc_filter[i]);
-		}
-
-		sort_mode |= BNX2_RPM_SORT_USER0_MC_HSH_EN;
-	}
-
-	if (dev->uc.count > BNX2_MAX_UNICAST_ADDRESSES) {
-		rx_mode |= BNX2_EMAC_RX_MODE_PROMISCUOUS;
-		sort_mode |= BNX2_RPM_SORT_USER0_PROM_EN |
-			     BNX2_RPM_SORT_USER0_PROM_VLAN;
-	} else if (!(dev->flags & IFF_PROMISC)) {
-		/* Add all entries into to the match filter list */
-		i = 0;
-		list_for_each_entry(ha, &dev->uc.list, list) {
-			bnx2_set_mac_addr(bp, ha->addr,
-					  i + BNX2_START_UNICAST_ADDRESS_INDEX);
-			sort_mode |= (1 <<
-				      (i + BNX2_START_UNICAST_ADDRESS_INDEX));
-			i++;
-		}
-
-	}
-
-	if (rx_mode != bp->rx_mode) {
-		bp->rx_mode = rx_mode;
-		REG_WR(bp, BNX2_EMAC_RX_MODE, rx_mode);
-	}
-
-	REG_WR(bp, BNX2_RPM_SORT_USER0, 0x0);
-	REG_WR(bp, BNX2_RPM_SORT_USER0, sort_mode);
-	REG_WR(bp, BNX2_RPM_SORT_USER0, sort_mode | BNX2_RPM_SORT_USER0_ENA);
-
-	spin_unlock_bh(&bp->phy_lock);
-}
-
-static int __devinit
-check_fw_section(const struct firmware *fw,
-		 const struct bnx2_fw_file_section *section,
-		 u32 alignment, bool non_empty)
-{
-	u32 offset = be32_to_cpu(section->offset);
-	u32 len = be32_to_cpu(section->len);
-
-	if ((offset == 0 && len != 0) || offset >= fw->size || offset & 3)
-		return -EINVAL;
-	if ((non_empty && len == 0) || len > fw->size - offset ||
-	    len & (alignment - 1))
-		return -EINVAL;
-	return 0;
-}
-
-static int __devinit
-check_mips_fw_entry(const struct firmware *fw,
-		    const struct bnx2_mips_fw_file_entry *entry)
-{
-	if (check_fw_section(fw, &entry->text, 4, true) ||
-	    check_fw_section(fw, &entry->data, 4, false) ||
-	    check_fw_section(fw, &entry->rodata, 4, false))
-		return -EINVAL;
-	return 0;
-}
-
-static int __devinit
-bnx2_request_firmware(struct bnx2 *bp)
-{
-	const char *mips_fw_file, *rv2p_fw_file;
-	const struct bnx2_mips_fw_file *mips_fw;
-	const struct bnx2_rv2p_fw_file *rv2p_fw;
-	int rc;
-
-	if (CHIP_NUM(bp) == CHIP_NUM_5709) {
-		mips_fw_file = FW_MIPS_FILE_09;
-		if ((CHIP_ID(bp) == CHIP_ID_5709_A0) ||
-		    (CHIP_ID(bp) == CHIP_ID_5709_A1))
-			rv2p_fw_file = FW_RV2P_FILE_09_Ax;
-		else
-			rv2p_fw_file = FW_RV2P_FILE_09;
-	} else {
-		mips_fw_file = FW_MIPS_FILE_06;
-		rv2p_fw_file = FW_RV2P_FILE_06;
-	}
-
-	rc = request_firmware(&bp->mips_firmware, mips_fw_file, &bp->pdev->dev);
-	if (rc) {
-		printk(KERN_ERR PFX "Can't load firmware file \"%s\"\n",
-		       mips_fw_file);
-		return rc;
-	}
-
-	rc = request_firmware(&bp->rv2p_firmware, rv2p_fw_file, &bp->pdev->dev);
-	if (rc) {
-		printk(KERN_ERR PFX "Can't load firmware file \"%s\"\n",
-		       rv2p_fw_file);
-		return rc;
-	}
-	mips_fw = (const struct bnx2_mips_fw_file *) bp->mips_firmware->data;
-	rv2p_fw = (const struct bnx2_rv2p_fw_file *) bp->rv2p_firmware->data;
-	if (bp->mips_firmware->size < sizeof(*mips_fw) ||
-	    check_mips_fw_entry(bp->mips_firmware, &mips_fw->com) ||
-	    check_mips_fw_entry(bp->mips_firmware, &mips_fw->cp) ||
-	    check_mips_fw_entry(bp->mips_firmware, &mips_fw->rxp) ||
-	    check_mips_fw_entry(bp->mips_firmware, &mips_fw->tpat) ||
-	    check_mips_fw_entry(bp->mips_firmware, &mips_fw->txp)) {
-		printk(KERN_ERR PFX "Firmware file \"%s\" is invalid\n",
-		       mips_fw_file);
-		return -EINVAL;
-	}
-	if (bp->rv2p_firmware->size < sizeof(*rv2p_fw) ||
-	    check_fw_section(bp->rv2p_firmware, &rv2p_fw->proc1.rv2p, 8, true) ||
-	    check_fw_section(bp->rv2p_firmware, &rv2p_fw->proc2.rv2p, 8, true)) {
-		printk(KERN_ERR PFX "Firmware file \"%s\" is invalid\n",
-		       rv2p_fw_file);
-		return -EINVAL;
-	}
-
-	return 0;
-}
-
-static u32
-rv2p_fw_fixup(u32 rv2p_proc, int idx, u32 loc, u32 rv2p_code)
-{
-	switch (idx) {
-	case RV2P_P1_FIXUP_PAGE_SIZE_IDX:
-		rv2p_code &= ~RV2P_BD_PAGE_SIZE_MSK;
-		rv2p_code |= RV2P_BD_PAGE_SIZE;
-		break;
-	}
-	return rv2p_code;
-}
-
-static int
-load_rv2p_fw(struct bnx2 *bp, u32 rv2p_proc,
-	     const struct bnx2_rv2p_fw_file_entry *fw_entry)
-{
-	u32 rv2p_code_len, file_offset;
-	__be32 *rv2p_code;
-	int i;
-	u32 val, cmd, addr;
-
-	rv2p_code_len = be32_to_cpu(fw_entry->rv2p.len);
-	file_offset = be32_to_cpu(fw_entry->rv2p.offset);
-
-	rv2p_code = (__be32 *)(bp->rv2p_firmware->data + file_offset);
-
-	if (rv2p_proc == RV2P_PROC1) {
-		cmd = BNX2_RV2P_PROC1_ADDR_CMD_RDWR;
-		addr = BNX2_RV2P_PROC1_ADDR_CMD;
-	} else {
-		cmd = BNX2_RV2P_PROC2_ADDR_CMD_RDWR;
-		addr = BNX2_RV2P_PROC2_ADDR_CMD;
-	}
-
-	for (i = 0; i < rv2p_code_len; i += 8) {
-		REG_WR(bp, BNX2_RV2P_INSTR_HIGH, be32_to_cpu(*rv2p_code));
-		rv2p_code++;
-		REG_WR(bp, BNX2_RV2P_INSTR_LOW, be32_to_cpu(*rv2p_code));
-		rv2p_code++;
-
-		val = (i / 8) | cmd;
-		REG_WR(bp, addr, val);
-	}
-
-	rv2p_code = (__be32 *)(bp->rv2p_firmware->data + file_offset);
-	for (i = 0; i < 8; i++) {
-		u32 loc, code;
-
-		loc = be32_to_cpu(fw_entry->fixup[i]);
-		if (loc && ((loc * 4) < rv2p_code_len)) {
-			code = be32_to_cpu(*(rv2p_code + loc - 1));
-			REG_WR(bp, BNX2_RV2P_INSTR_HIGH, code);
-			code = be32_to_cpu(*(rv2p_code + loc));
-			code = rv2p_fw_fixup(rv2p_proc, i, loc, code);
-			REG_WR(bp, BNX2_RV2P_INSTR_LOW, code);
-
-			val = (loc / 2) | cmd;
-			REG_WR(bp, addr, val);
-		}
-	}
-
-	/* Reset the processor, un-stall is done later. */
-	if (rv2p_proc == RV2P_PROC1) {
-		REG_WR(bp, BNX2_RV2P_COMMAND, BNX2_RV2P_COMMAND_PROC1_RESET);
-	}
-	else {
-		REG_WR(bp, BNX2_RV2P_COMMAND, BNX2_RV2P_COMMAND_PROC2_RESET);
-	}
-
-	return 0;
-}
-
-static int
-load_cpu_fw(struct bnx2 *bp, const struct cpu_reg *cpu_reg,
-	    const struct bnx2_mips_fw_file_entry *fw_entry)
-{
-	u32 addr, len, file_offset;
-	__be32 *data;
-	u32 offset;
-	u32 val;
-
-	/* Halt the CPU. */
-	val = bnx2_reg_rd_ind(bp, cpu_reg->mode);
-	val |= cpu_reg->mode_value_halt;
-	bnx2_reg_wr_ind(bp, cpu_reg->mode, val);
-	bnx2_reg_wr_ind(bp, cpu_reg->state, cpu_reg->state_value_clear);
-
-	/* Load the Text area. */
-	addr = be32_to_cpu(fw_entry->text.addr);
-	len = be32_to_cpu(fw_entry->text.len);
-	file_offset = be32_to_cpu(fw_entry->text.offset);
-	data = (__be32 *)(bp->mips_firmware->data + file_offset);
-
-	offset = cpu_reg->spad_base + (addr - cpu_reg->mips_view_base);
-	if (len) {
-		int j;
-
-		for (j = 0; j < (len / 4); j++, offset += 4)
-			bnx2_reg_wr_ind(bp, offset, be32_to_cpu(data[j]));
-	}
-
-	/* Load the Data area. */
-	addr = be32_to_cpu(fw_entry->data.addr);
-	len = be32_to_cpu(fw_entry->data.len);
-	file_offset = be32_to_cpu(fw_entry->data.offset);
-	data = (__be32 *)(bp->mips_firmware->data + file_offset);
-
-	offset = cpu_reg->spad_base + (addr - cpu_reg->mips_view_base);
-	if (len) {
-		int j;
-
-		for (j = 0; j < (len / 4); j++, offset += 4)
-			bnx2_reg_wr_ind(bp, offset, be32_to_cpu(data[j]));
-	}
-
-	/* Load the Read-Only area. */
-	addr = be32_to_cpu(fw_entry->rodata.addr);
-	len = be32_to_cpu(fw_entry->rodata.len);
-	file_offset = be32_to_cpu(fw_entry->rodata.offset);
-	data = (__be32 *)(bp->mips_firmware->data + file_offset);
-
-	offset = cpu_reg->spad_base + (addr - cpu_reg->mips_view_base);
-	if (len) {
-		int j;
-
-		for (j = 0; j < (len / 4); j++, offset += 4)
-			bnx2_reg_wr_ind(bp, offset, be32_to_cpu(data[j]));
-	}
-
-	/* Clear the pre-fetch instruction. */
-	bnx2_reg_wr_ind(bp, cpu_reg->inst, 0);
-
-	val = be32_to_cpu(fw_entry->start_addr);
-	bnx2_reg_wr_ind(bp, cpu_reg->pc, val);
-
-	/* Start the CPU. */
-	val = bnx2_reg_rd_ind(bp, cpu_reg->mode);
-	val &= ~cpu_reg->mode_value_halt;
-	bnx2_reg_wr_ind(bp, cpu_reg->state, cpu_reg->state_value_clear);
-	bnx2_reg_wr_ind(bp, cpu_reg->mode, val);
-
-	return 0;
-}
-
-static int
-bnx2_init_cpus(struct bnx2 *bp)
-{
-	const struct bnx2_mips_fw_file *mips_fw =
-		(const struct bnx2_mips_fw_file *) bp->mips_firmware->data;
-	const struct bnx2_rv2p_fw_file *rv2p_fw =
-		(const struct bnx2_rv2p_fw_file *) bp->rv2p_firmware->data;
-	int rc;
-
-	/* Initialize the RV2P processor. */
-	load_rv2p_fw(bp, RV2P_PROC1, &rv2p_fw->proc1);
-	load_rv2p_fw(bp, RV2P_PROC2, &rv2p_fw->proc2);
-
-	/* Initialize the RX Processor. */
-	rc = load_cpu_fw(bp, &cpu_reg_rxp, &mips_fw->rxp);
-	if (rc)
-		goto init_cpu_err;
-
-	/* Initialize the TX Processor. */
-	rc = load_cpu_fw(bp, &cpu_reg_txp, &mips_fw->txp);
-	if (rc)
-		goto init_cpu_err;
-
-	/* Initialize the TX Patch-up Processor. */
-	rc = load_cpu_fw(bp, &cpu_reg_tpat, &mips_fw->tpat);
-	if (rc)
-		goto init_cpu_err;
-
-	/* Initialize the Completion Processor. */
-	rc = load_cpu_fw(bp, &cpu_reg_com, &mips_fw->com);
-	if (rc)
-		goto init_cpu_err;
-
-	/* Initialize the Command Processor. */
-	rc = load_cpu_fw(bp, &cpu_reg_cp, &mips_fw->cp);
-
-init_cpu_err:
-	return rc;
-}
-
-static int
-bnx2_set_power_state(struct bnx2 *bp, pci_power_t state)
-{
-	u16 pmcsr;
-
-	pci_read_config_word(bp->pdev, bp->pm_cap + PCI_PM_CTRL, &pmcsr);
-
-	switch (state) {
-	case PCI_D0: {
-		u32 val;
-
-		pci_write_config_word(bp->pdev, bp->pm_cap + PCI_PM_CTRL,
-			(pmcsr & ~PCI_PM_CTRL_STATE_MASK) |
-			PCI_PM_CTRL_PME_STATUS);
-
-		if (pmcsr & PCI_PM_CTRL_STATE_MASK)
-			/* delay required during transition out of D3hot */
-			msleep(20);
-
-		val = REG_RD(bp, BNX2_EMAC_MODE);
-		val |= BNX2_EMAC_MODE_MPKT_RCVD | BNX2_EMAC_MODE_ACPI_RCVD;
-		val &= ~BNX2_EMAC_MODE_MPKT;
-		REG_WR(bp, BNX2_EMAC_MODE, val);
-
-		val = REG_RD(bp, BNX2_RPM_CONFIG);
-		val &= ~BNX2_RPM_CONFIG_ACPI_ENA;
-		REG_WR(bp, BNX2_RPM_CONFIG, val);
-		break;
-	}
-	case PCI_D3hot: {
-		int i;
-		u32 val, wol_msg;
-
-		if (bp->wol) {
-			u32 advertising;
-			u8 autoneg;
-
-			autoneg = bp->autoneg;
-			advertising = bp->advertising;
-
-			if (bp->phy_port == PORT_TP) {
-				bp->autoneg = AUTONEG_SPEED;
-				bp->advertising = ADVERTISED_10baseT_Half |
-					ADVERTISED_10baseT_Full |
-					ADVERTISED_100baseT_Half |
-					ADVERTISED_100baseT_Full |
-					ADVERTISED_Autoneg;
-			}
-
-			spin_lock_bh(&bp->phy_lock);
-			bnx2_setup_phy(bp, bp->phy_port);
-			spin_unlock_bh(&bp->phy_lock);
-
-			bp->autoneg = autoneg;
-			bp->advertising = advertising;
-
-			bnx2_set_mac_addr(bp, bp->dev->dev_addr, 0);
-
-			val = REG_RD(bp, BNX2_EMAC_MODE);
-
-			/* Enable port mode. */
-			val &= ~BNX2_EMAC_MODE_PORT;
-			val |= BNX2_EMAC_MODE_MPKT_RCVD |
-			       BNX2_EMAC_MODE_ACPI_RCVD |
-			       BNX2_EMAC_MODE_MPKT;
-			if (bp->phy_port == PORT_TP)
-				val |= BNX2_EMAC_MODE_PORT_MII;
-			else {
-				val |= BNX2_EMAC_MODE_PORT_GMII;
-				if (bp->line_speed == SPEED_2500)
-					val |= BNX2_EMAC_MODE_25G_MODE;
-			}
-
-			REG_WR(bp, BNX2_EMAC_MODE, val);
-
-			/* receive all multicast */
-			for (i = 0; i < NUM_MC_HASH_REGISTERS; i++) {
-				REG_WR(bp, BNX2_EMAC_MULTICAST_HASH0 + (i * 4),
-				       0xffffffff);
-			}
-			REG_WR(bp, BNX2_EMAC_RX_MODE,
-			       BNX2_EMAC_RX_MODE_SORT_MODE);
-
-			val = 1 | BNX2_RPM_SORT_USER0_BC_EN |
-			      BNX2_RPM_SORT_USER0_MC_EN;
-			REG_WR(bp, BNX2_RPM_SORT_USER0, 0x0);
-			REG_WR(bp, BNX2_RPM_SORT_USER0, val);
-			REG_WR(bp, BNX2_RPM_SORT_USER0, val |
-			       BNX2_RPM_SORT_USER0_ENA);
-
-			/* Need to enable EMAC and RPM for WOL. */
-			REG_WR(bp, BNX2_MISC_ENABLE_SET_BITS,
-			       BNX2_MISC_ENABLE_SET_BITS_RX_PARSER_MAC_ENABLE |
-			       BNX2_MISC_ENABLE_SET_BITS_TX_HEADER_Q_ENABLE |
-			       BNX2_MISC_ENABLE_SET_BITS_EMAC_ENABLE);
-
-			val = REG_RD(bp, BNX2_RPM_CONFIG);
-			val &= ~BNX2_RPM_CONFIG_ACPI_ENA;
-			REG_WR(bp, BNX2_RPM_CONFIG, val);
-
-			wol_msg = BNX2_DRV_MSG_CODE_SUSPEND_WOL;
-		}
-		else {
-			wol_msg = BNX2_DRV_MSG_CODE_SUSPEND_NO_WOL;
-		}
-
-		if (!(bp->flags & BNX2_FLAG_NO_WOL))
-			bnx2_fw_sync(bp, BNX2_DRV_MSG_DATA_WAIT3 | wol_msg,
-				     1, 0);
-
-		pmcsr &= ~PCI_PM_CTRL_STATE_MASK;
-		if ((CHIP_ID(bp) == CHIP_ID_5706_A0) ||
-		    (CHIP_ID(bp) == CHIP_ID_5706_A1)) {
-
-			if (bp->wol)
-				pmcsr |= 3;
-		}
-		else {
-			pmcsr |= 3;
-		}
-		if (bp->wol) {
-			pmcsr |= PCI_PM_CTRL_PME_ENABLE;
-		}
-		pci_write_config_word(bp->pdev, bp->pm_cap + PCI_PM_CTRL,
-				      pmcsr);
-
-		/* No more memory access after this point until
-		 * device is brought back to D0.
-		 */
-		udelay(50);
-		break;
-	}
-	default:
-		return -EINVAL;
-	}
-	return 0;
-}
-
-static int
-bnx2_acquire_nvram_lock(struct bnx2 *bp)
-{
-	u32 val;
-	int j;
-
-	/* Request access to the flash interface. */
-	REG_WR(bp, BNX2_NVM_SW_ARB, BNX2_NVM_SW_ARB_ARB_REQ_SET2);
-	for (j = 0; j < NVRAM_TIMEOUT_COUNT; j++) {
-		val = REG_RD(bp, BNX2_NVM_SW_ARB);
-		if (val & BNX2_NVM_SW_ARB_ARB_ARB2)
-			break;
-
-		udelay(5);
-	}
-
-	if (j >= NVRAM_TIMEOUT_COUNT)
-		return -EBUSY;
-
-	return 0;
-}
-
-static int
-bnx2_release_nvram_lock(struct bnx2 *bp)
-{
-	int j;
-	u32 val;
-
-	/* Relinquish nvram interface. */
-	REG_WR(bp, BNX2_NVM_SW_ARB, BNX2_NVM_SW_ARB_ARB_REQ_CLR2);
-
-	for (j = 0; j < NVRAM_TIMEOUT_COUNT; j++) {
-		val = REG_RD(bp, BNX2_NVM_SW_ARB);
-		if (!(val & BNX2_NVM_SW_ARB_ARB_ARB2))
-			break;
-
-		udelay(5);
-	}
-
-	if (j >= NVRAM_TIMEOUT_COUNT)
-		return -EBUSY;
-
-	return 0;
-}
-
-
-static int
-bnx2_enable_nvram_write(struct bnx2 *bp)
-{
-	u32 val;
-
-	val = REG_RD(bp, BNX2_MISC_CFG);
-	REG_WR(bp, BNX2_MISC_CFG, val | BNX2_MISC_CFG_NVM_WR_EN_PCI);
-
-	if (bp->flash_info->flags & BNX2_NV_WREN) {
-		int j;
-
-		REG_WR(bp, BNX2_NVM_COMMAND, BNX2_NVM_COMMAND_DONE);
-		REG_WR(bp, BNX2_NVM_COMMAND,
-		       BNX2_NVM_COMMAND_WREN | BNX2_NVM_COMMAND_DOIT);
-
-		for (j = 0; j < NVRAM_TIMEOUT_COUNT; j++) {
-			udelay(5);
-
-			val = REG_RD(bp, BNX2_NVM_COMMAND);
-			if (val & BNX2_NVM_COMMAND_DONE)
-				break;
-		}
-
-		if (j >= NVRAM_TIMEOUT_COUNT)
-			return -EBUSY;
-	}
-	return 0;
-}
-
-static void
-bnx2_disable_nvram_write(struct bnx2 *bp)
-{
-	u32 val;
-
-	val = REG_RD(bp, BNX2_MISC_CFG);
-	REG_WR(bp, BNX2_MISC_CFG, val & ~BNX2_MISC_CFG_NVM_WR_EN);
-}
-
-
-static void
-bnx2_enable_nvram_access(struct bnx2 *bp)
-{
-	u32 val;
-
-	val = REG_RD(bp, BNX2_NVM_ACCESS_ENABLE);
-	/* Enable both bits, even on read. */
-	REG_WR(bp, BNX2_NVM_ACCESS_ENABLE,
-	       val | BNX2_NVM_ACCESS_ENABLE_EN | BNX2_NVM_ACCESS_ENABLE_WR_EN);
-}
-
-static void
-bnx2_disable_nvram_access(struct bnx2 *bp)
-{
-	u32 val;
-
-	val = REG_RD(bp, BNX2_NVM_ACCESS_ENABLE);
-	/* Disable both bits, even after read. */
-	REG_WR(bp, BNX2_NVM_ACCESS_ENABLE,
-		val & ~(BNX2_NVM_ACCESS_ENABLE_EN |
-			BNX2_NVM_ACCESS_ENABLE_WR_EN));
-}
-
-static int
-bnx2_nvram_erase_page(struct bnx2 *bp, u32 offset)
-{
-	u32 cmd;
-	int j;
-
-	if (bp->flash_info->flags & BNX2_NV_BUFFERED)
-		/* Buffered flash, no erase needed */
-		return 0;
-
-	/* Build an erase command */
-	cmd = BNX2_NVM_COMMAND_ERASE | BNX2_NVM_COMMAND_WR |
-	      BNX2_NVM_COMMAND_DOIT;
-
-	/* Need to clear DONE bit separately. */
-	REG_WR(bp, BNX2_NVM_COMMAND, BNX2_NVM_COMMAND_DONE);
-
-	/* Address of the NVRAM to read from. */
-	REG_WR(bp, BNX2_NVM_ADDR, offset & BNX2_NVM_ADDR_NVM_ADDR_VALUE);
-
-	/* Issue an erase command. */
-	REG_WR(bp, BNX2_NVM_COMMAND, cmd);
-
-	/* Wait for completion. */
-	for (j = 0; j < NVRAM_TIMEOUT_COUNT; j++) {
-		u32 val;
-
-		udelay(5);
-
-		val = REG_RD(bp, BNX2_NVM_COMMAND);
-		if (val & BNX2_NVM_COMMAND_DONE)
-			break;
-	}
-
-	if (j >= NVRAM_TIMEOUT_COUNT)
-		return -EBUSY;
-
-	return 0;
-}
-
-static int
-bnx2_nvram_read_dword(struct bnx2 *bp, u32 offset, u8 *ret_val, u32 cmd_flags)
-{
-	u32 cmd;
-	int j;
-
-	/* Build the command word. */
-	cmd = BNX2_NVM_COMMAND_DOIT | cmd_flags;
-
-	/* Calculate an offset of a buffered flash, not needed for 5709. */
-	if (bp->flash_info->flags & BNX2_NV_TRANSLATE) {
-		offset = ((offset / bp->flash_info->page_size) <<
-			   bp->flash_info->page_bits) +
-			  (offset % bp->flash_info->page_size);
-	}
-
-	/* Need to clear DONE bit separately. */
-	REG_WR(bp, BNX2_NVM_COMMAND, BNX2_NVM_COMMAND_DONE);
-
-	/* Address of the NVRAM to read from. */
-	REG_WR(bp, BNX2_NVM_ADDR, offset & BNX2_NVM_ADDR_NVM_ADDR_VALUE);
-
-	/* Issue a read command. */
-	REG_WR(bp, BNX2_NVM_COMMAND, cmd);
-
-	/* Wait for completion. */
-	for (j = 0; j < NVRAM_TIMEOUT_COUNT; j++) {
-		u32 val;
-
-		udelay(5);
-
-		val = REG_RD(bp, BNX2_NVM_COMMAND);
-		if (val & BNX2_NVM_COMMAND_DONE) {
-			__be32 v = cpu_to_be32(REG_RD(bp, BNX2_NVM_READ));
-			memcpy(ret_val, &v, 4);
-			break;
-		}
-	}
-	if (j >= NVRAM_TIMEOUT_COUNT)
-		return -EBUSY;
-
-	return 0;
-}
-
-
-static int
-bnx2_nvram_write_dword(struct bnx2 *bp, u32 offset, u8 *val, u32 cmd_flags)
-{
-	u32 cmd;
-	__be32 val32;
-	int j;
-
-	/* Build the command word. */
-	cmd = BNX2_NVM_COMMAND_DOIT | BNX2_NVM_COMMAND_WR | cmd_flags;
-
-	/* Calculate an offset of a buffered flash, not needed for 5709. */
-	if (bp->flash_info->flags & BNX2_NV_TRANSLATE) {
-		offset = ((offset / bp->flash_info->page_size) <<
-			  bp->flash_info->page_bits) +
-			 (offset % bp->flash_info->page_size);
-	}
-
-	/* Need to clear DONE bit separately. */
-	REG_WR(bp, BNX2_NVM_COMMAND, BNX2_NVM_COMMAND_DONE);
-
-	memcpy(&val32, val, 4);
-
-	/* Write the data. */
-	REG_WR(bp, BNX2_NVM_WRITE, be32_to_cpu(val32));
-
-	/* Address of the NVRAM to write to. */
-	REG_WR(bp, BNX2_NVM_ADDR, offset & BNX2_NVM_ADDR_NVM_ADDR_VALUE);
-
-	/* Issue the write command. */
-	REG_WR(bp, BNX2_NVM_COMMAND, cmd);
-
-	/* Wait for completion. */
-	for (j = 0; j < NVRAM_TIMEOUT_COUNT; j++) {
-		udelay(5);
-
-		if (REG_RD(bp, BNX2_NVM_COMMAND) & BNX2_NVM_COMMAND_DONE)
-			break;
-	}
-	if (j >= NVRAM_TIMEOUT_COUNT)
-		return -EBUSY;
-
-	return 0;
-}
-
-static int
-bnx2_init_nvram(struct bnx2 *bp)
-{
-	u32 val;
-	int j, entry_count, rc = 0;
-	const struct flash_spec *flash;
-
-	if (CHIP_NUM(bp) == CHIP_NUM_5709) {
-		bp->flash_info = &flash_5709;
-		goto get_flash_size;
-	}
-
-	/* Determine the selected interface. */
-	val = REG_RD(bp, BNX2_NVM_CFG1);
-
-	entry_count = ARRAY_SIZE(flash_table);
-
-	if (val & 0x40000000) {
-
-		/* Flash interface has been reconfigured */
-		for (j = 0, flash = &flash_table[0]; j < entry_count;
-		     j++, flash++) {
-			if ((val & FLASH_BACKUP_STRAP_MASK) ==
-			    (flash->config1 & FLASH_BACKUP_STRAP_MASK)) {
-				bp->flash_info = flash;
-				break;
-			}
-		}
-	}
-	else {
-		u32 mask;
-		/* Not yet been reconfigured */
-
-		if (val & (1 << 23))
-			mask = FLASH_BACKUP_STRAP_MASK;
-		else
-			mask = FLASH_STRAP_MASK;
-
-		for (j = 0, flash = &flash_table[0]; j < entry_count;
-			j++, flash++) {
-
-			if ((val & mask) == (flash->strapping & mask)) {
-				bp->flash_info = flash;
-
-				/* Request access to the flash interface. */
-				if ((rc = bnx2_acquire_nvram_lock(bp)) != 0)
-					return rc;
-
-				/* Enable access to flash interface */
-				bnx2_enable_nvram_access(bp);
-
-				/* Reconfigure the flash interface */
-				REG_WR(bp, BNX2_NVM_CFG1, flash->config1);
-				REG_WR(bp, BNX2_NVM_CFG2, flash->config2);
-				REG_WR(bp, BNX2_NVM_CFG3, flash->config3);
-				REG_WR(bp, BNX2_NVM_WRITE1, flash->write1);
-
-				/* Disable access to flash interface */
-				bnx2_disable_nvram_access(bp);
-				bnx2_release_nvram_lock(bp);
-
-				break;
-			}
-		}
-	} /* if (val & 0x40000000) */
-
-	if (j == entry_count) {
-		bp->flash_info = NULL;
-		printk(KERN_ALERT PFX "Unknown flash/EEPROM type.\n");
-		return -ENODEV;
-	}
-
-get_flash_size:
-	val = bnx2_shmem_rd(bp, BNX2_SHARED_HW_CFG_CONFIG2);
-	val &= BNX2_SHARED_HW_CFG2_NVM_SIZE_MASK;
-	if (val)
-		bp->flash_size = val;
-	else
-		bp->flash_size = bp->flash_info->total_size;
-
-	return rc;
-}
-
-static int
-bnx2_nvram_read(struct bnx2 *bp, u32 offset, u8 *ret_buf,
-		int buf_size)
-{
-	int rc = 0;
-	u32 cmd_flags, offset32, len32, extra;
-
-	if (buf_size == 0)
-		return 0;
-
-	/* Request access to the flash interface. */
-	if ((rc = bnx2_acquire_nvram_lock(bp)) != 0)
-		return rc;
-
-	/* Enable access to flash interface */
-	bnx2_enable_nvram_access(bp);
-
-	len32 = buf_size;
-	offset32 = offset;
-	extra = 0;
-
-	cmd_flags = 0;
-
-	if (offset32 & 3) {
-		u8 buf[4];
-		u32 pre_len;
-
-		offset32 &= ~3;
-		pre_len = 4 - (offset & 3);
-
-		if (pre_len >= len32) {
-			pre_len = len32;
-			cmd_flags = BNX2_NVM_COMMAND_FIRST |
-				    BNX2_NVM_COMMAND_LAST;
-		}
-		else {
-			cmd_flags = BNX2_NVM_COMMAND_FIRST;
-		}
-
-		rc = bnx2_nvram_read_dword(bp, offset32, buf, cmd_flags);
-
-		if (rc)
-			return rc;
-
-		memcpy(ret_buf, buf + (offset & 3), pre_len);
-
-		offset32 += 4;
-		ret_buf += pre_len;
-		len32 -= pre_len;
-	}
-	if (len32 & 3) {
-		extra = 4 - (len32 & 3);
-		len32 = (len32 + 4) & ~3;
-	}
-
-	if (len32 == 4) {
-		u8 buf[4];
-
-		if (cmd_flags)
-			cmd_flags = BNX2_NVM_COMMAND_LAST;
-		else
-			cmd_flags = BNX2_NVM_COMMAND_FIRST |
-				    BNX2_NVM_COMMAND_LAST;
-
-		rc = bnx2_nvram_read_dword(bp, offset32, buf, cmd_flags);
-
-		memcpy(ret_buf, buf, 4 - extra);
-	}
-	else if (len32 > 0) {
-		u8 buf[4];
-
-		/* Read the first word. */
-		if (cmd_flags)
-			cmd_flags = 0;
-		else
-			cmd_flags = BNX2_NVM_COMMAND_FIRST;
-
-		rc = bnx2_nvram_read_dword(bp, offset32, ret_buf, cmd_flags);
-
-		/* Advance to the next dword. */
-		offset32 += 4;
-		ret_buf += 4;
-		len32 -= 4;
-
-		while (len32 > 4 && rc == 0) {
-			rc = bnx2_nvram_read_dword(bp, offset32, ret_buf, 0);
-
-			/* Advance to the next dword. */
-			offset32 += 4;
-			ret_buf += 4;
-			len32 -= 4;
-		}
-
-		if (rc)
-			return rc;
-
-		cmd_flags = BNX2_NVM_COMMAND_LAST;
-		rc = bnx2_nvram_read_dword(bp, offset32, buf, cmd_flags);
-
-		memcpy(ret_buf, buf, 4 - extra);
-	}
-
-	/* Disable access to flash interface */
-	bnx2_disable_nvram_access(bp);
-
-	bnx2_release_nvram_lock(bp);
-
-	return rc;
-}
-
-static int
-bnx2_nvram_write(struct bnx2 *bp, u32 offset, u8 *data_buf,
-		int buf_size)
-{
-	u32 written, offset32, len32;
-	u8 *buf, start[4], end[4], *align_buf = NULL, *flash_buffer = NULL;
-	int rc = 0;
-	int align_start, align_end;
-
-	buf = data_buf;
-	offset32 = offset;
-	len32 = buf_size;
-	align_start = align_end = 0;
-
-	if ((align_start = (offset32 & 3))) {
-		offset32 &= ~3;
-		len32 += align_start;
-		if (len32 < 4)
-			len32 = 4;
-		if ((rc = bnx2_nvram_read(bp, offset32, start, 4)))
-			return rc;
-	}
-
-	if (len32 & 3) {
-		align_end = 4 - (len32 & 3);
-		len32 += align_end;
-		if ((rc = bnx2_nvram_read(bp, offset32 + len32 - 4, end, 4)))
-			return rc;
-	}
-
-	if (align_start || align_end) {
-		align_buf = kmalloc(len32, GFP_KERNEL);
-		if (align_buf == NULL)
-			return -ENOMEM;
-		if (align_start) {
-			memcpy(align_buf, start, 4);
-		}
-		if (align_end) {
-			memcpy(align_buf + len32 - 4, end, 4);
-		}
-		memcpy(align_buf + align_start, data_buf, buf_size);
-		buf = align_buf;
-	}
-
-	if (!(bp->flash_info->flags & BNX2_NV_BUFFERED)) {
-		flash_buffer = kmalloc(264, GFP_KERNEL);
-		if (flash_buffer == NULL) {
-			rc = -ENOMEM;
-			goto nvram_write_end;
-		}
-	}
-
-	written = 0;
-	while ((written < len32) && (rc == 0)) {
-		u32 page_start, page_end, data_start, data_end;
-		u32 addr, cmd_flags;
-		int i;
-
-	        /* Find the page_start addr */
-		page_start = offset32 + written;
-		page_start -= (page_start % bp->flash_info->page_size);
-		/* Find the page_end addr */
-		page_end = page_start + bp->flash_info->page_size;
-		/* Find the data_start addr */
-		data_start = (written == 0) ? offset32 : page_start;
-		/* Find the data_end addr */
-		data_end = (page_end > offset32 + len32) ?
-			(offset32 + len32) : page_end;
-
-		/* Request access to the flash interface. */
-		if ((rc = bnx2_acquire_nvram_lock(bp)) != 0)
-			goto nvram_write_end;
-
-		/* Enable access to flash interface */
-		bnx2_enable_nvram_access(bp);
-
-		cmd_flags = BNX2_NVM_COMMAND_FIRST;
-		if (!(bp->flash_info->flags & BNX2_NV_BUFFERED)) {
-			int j;
-
-			/* Read the whole page into the buffer
-			 * (non-buffer flash only) */
-			for (j = 0; j < bp->flash_info->page_size; j += 4) {
-				if (j == (bp->flash_info->page_size - 4)) {
-					cmd_flags |= BNX2_NVM_COMMAND_LAST;
-				}
-				rc = bnx2_nvram_read_dword(bp,
-					page_start + j,
-					&flash_buffer[j],
-					cmd_flags);
-
-				if (rc)
-					goto nvram_write_end;
-
-				cmd_flags = 0;
-			}
-		}
-
-		/* Enable writes to flash interface (unlock write-protect) */
-		if ((rc = bnx2_enable_nvram_write(bp)) != 0)
-			goto nvram_write_end;
-
-		/* Loop to write back the buffer data from page_start to
-		 * data_start */
-		i = 0;
-		if (!(bp->flash_info->flags & BNX2_NV_BUFFERED)) {
-			/* Erase the page */
-			if ((rc = bnx2_nvram_erase_page(bp, page_start)) != 0)
-				goto nvram_write_end;
-
-			/* Re-enable the write again for the actual write */
-			bnx2_enable_nvram_write(bp);
-
-			for (addr = page_start; addr < data_start;
-				addr += 4, i += 4) {
-
-				rc = bnx2_nvram_write_dword(bp, addr,
-					&flash_buffer[i], cmd_flags);
-
-				if (rc != 0)
-					goto nvram_write_end;
-
-				cmd_flags = 0;
-			}
-		}
-
-		/* Loop to write the new data from data_start to data_end */
-		for (addr = data_start; addr < data_end; addr += 4, i += 4) {
-			if ((addr == page_end - 4) ||
-				((bp->flash_info->flags & BNX2_NV_BUFFERED) &&
-				 (addr == data_end - 4))) {
-
-				cmd_flags |= BNX2_NVM_COMMAND_LAST;
-			}
-			rc = bnx2_nvram_write_dword(bp, addr, buf,
-				cmd_flags);
-
-			if (rc != 0)
-				goto nvram_write_end;
-
-			cmd_flags = 0;
-			buf += 4;
-		}
-
-		/* Loop to write back the buffer data from data_end
-		 * to page_end */
-		if (!(bp->flash_info->flags & BNX2_NV_BUFFERED)) {
-			for (addr = data_end; addr < page_end;
-				addr += 4, i += 4) {
-
-				if (addr == page_end-4) {
-					cmd_flags = BNX2_NVM_COMMAND_LAST;
-                		}
-				rc = bnx2_nvram_write_dword(bp, addr,
-					&flash_buffer[i], cmd_flags);
-
-				if (rc != 0)
-					goto nvram_write_end;
-
-				cmd_flags = 0;
-			}
-		}
-
-		/* Disable writes to flash interface (lock write-protect) */
-		bnx2_disable_nvram_write(bp);
-
-		/* Disable access to flash interface */
-		bnx2_disable_nvram_access(bp);
-		bnx2_release_nvram_lock(bp);
-
-		/* Increment written */
-		written += data_end - data_start;
-	}
-
-nvram_write_end:
-	kfree(flash_buffer);
-	kfree(align_buf);
-	return rc;
-}
-
-static void
-bnx2_init_fw_cap(struct bnx2 *bp)
-{
-	u32 val, sig = 0;
-
-	bp->phy_flags &= ~BNX2_PHY_FLAG_REMOTE_PHY_CAP;
-	bp->flags &= ~BNX2_FLAG_CAN_KEEP_VLAN;
-
-	if (!(bp->flags & BNX2_FLAG_ASF_ENABLE))
-		bp->flags |= BNX2_FLAG_CAN_KEEP_VLAN;
-
-	val = bnx2_shmem_rd(bp, BNX2_FW_CAP_MB);
-	if ((val & BNX2_FW_CAP_SIGNATURE_MASK) != BNX2_FW_CAP_SIGNATURE)
-		return;
-
-	if ((val & BNX2_FW_CAP_CAN_KEEP_VLAN) == BNX2_FW_CAP_CAN_KEEP_VLAN) {
-		bp->flags |= BNX2_FLAG_CAN_KEEP_VLAN;
-		sig |= BNX2_DRV_ACK_CAP_SIGNATURE | BNX2_FW_CAP_CAN_KEEP_VLAN;
-	}
-
-	if ((bp->phy_flags & BNX2_PHY_FLAG_SERDES) &&
-	    (val & BNX2_FW_CAP_REMOTE_PHY_CAPABLE)) {
-		u32 link;
-
-		bp->phy_flags |= BNX2_PHY_FLAG_REMOTE_PHY_CAP;
-
-		link = bnx2_shmem_rd(bp, BNX2_LINK_STATUS);
-		if (link & BNX2_LINK_STATUS_SERDES_LINK)
-			bp->phy_port = PORT_FIBRE;
-		else
-			bp->phy_port = PORT_TP;
-
-		sig |= BNX2_DRV_ACK_CAP_SIGNATURE |
-		       BNX2_FW_CAP_REMOTE_PHY_CAPABLE;
-	}
-
-	if (netif_running(bp->dev) && sig)
-		bnx2_shmem_wr(bp, BNX2_DRV_ACK_CAP_MB, sig);
-}
-
-static void
-bnx2_setup_msix_tbl(struct bnx2 *bp)
-{
-	REG_WR(bp, BNX2_PCI_GRC_WINDOW_ADDR, BNX2_PCI_GRC_WINDOW_ADDR_SEP_WIN);
-
-	REG_WR(bp, BNX2_PCI_GRC_WINDOW2_ADDR, BNX2_MSIX_TABLE_ADDR);
-	REG_WR(bp, BNX2_PCI_GRC_WINDOW3_ADDR, BNX2_MSIX_PBA_ADDR);
-}
-
-static int
-bnx2_reset_chip(struct bnx2 *bp, u32 reset_code)
-{
-	u32 val;
-	int i, rc = 0;
-	u8 old_port;
-
-	/* Wait for the current PCI transaction to complete before
-	 * issuing a reset. */
-	REG_WR(bp, BNX2_MISC_ENABLE_CLR_BITS,
-	       BNX2_MISC_ENABLE_CLR_BITS_TX_DMA_ENABLE |
-	       BNX2_MISC_ENABLE_CLR_BITS_DMA_ENGINE_ENABLE |
-	       BNX2_MISC_ENABLE_CLR_BITS_RX_DMA_ENABLE |
-	       BNX2_MISC_ENABLE_CLR_BITS_HOST_COALESCE_ENABLE);
-	val = REG_RD(bp, BNX2_MISC_ENABLE_CLR_BITS);
-	udelay(5);
-
-	/* Wait for the firmware to tell us it is ok to issue a reset. */
-	bnx2_fw_sync(bp, BNX2_DRV_MSG_DATA_WAIT0 | reset_code, 1, 1);
-
-	/* Deposit a driver reset signature so the firmware knows that
-	 * this is a soft reset. */
-	bnx2_shmem_wr(bp, BNX2_DRV_RESET_SIGNATURE,
-		      BNX2_DRV_RESET_SIGNATURE_MAGIC);
-
-	/* Do a dummy read to force the chip to complete all current transaction
-	 * before we issue a reset. */
-	val = REG_RD(bp, BNX2_MISC_ID);
-
-	if (CHIP_NUM(bp) == CHIP_NUM_5709) {
-		REG_WR(bp, BNX2_MISC_COMMAND, BNX2_MISC_COMMAND_SW_RESET);
-		REG_RD(bp, BNX2_MISC_COMMAND);
-		udelay(5);
-
-		val = BNX2_PCICFG_MISC_CONFIG_REG_WINDOW_ENA |
-		      BNX2_PCICFG_MISC_CONFIG_TARGET_MB_WORD_SWAP;
-
-		pci_write_config_dword(bp->pdev, BNX2_PCICFG_MISC_CONFIG, val);
-
-	} else {
-		val = BNX2_PCICFG_MISC_CONFIG_CORE_RST_REQ |
-		      BNX2_PCICFG_MISC_CONFIG_REG_WINDOW_ENA |
-		      BNX2_PCICFG_MISC_CONFIG_TARGET_MB_WORD_SWAP;
-
-		/* Chip reset. */
-		REG_WR(bp, BNX2_PCICFG_MISC_CONFIG, val);
-
-		/* Reading back any register after chip reset will hang the
-		 * bus on 5706 A0 and A1.  The msleep below provides plenty
-		 * of margin for write posting.
-		 */
-		if ((CHIP_ID(bp) == CHIP_ID_5706_A0) ||
-		    (CHIP_ID(bp) == CHIP_ID_5706_A1))
-			msleep(20);
-
-		/* Reset takes approximate 30 usec */
-		for (i = 0; i < 10; i++) {
-			val = REG_RD(bp, BNX2_PCICFG_MISC_CONFIG);
-			if ((val & (BNX2_PCICFG_MISC_CONFIG_CORE_RST_REQ |
-				    BNX2_PCICFG_MISC_CONFIG_CORE_RST_BSY)) == 0)
-				break;
-			udelay(10);
-		}
-
-		if (val & (BNX2_PCICFG_MISC_CONFIG_CORE_RST_REQ |
-			   BNX2_PCICFG_MISC_CONFIG_CORE_RST_BSY)) {
-			printk(KERN_ERR PFX "Chip reset did not complete\n");
-			return -EBUSY;
-		}
-	}
-
-	/* Make sure byte swapping is properly configured. */
-	val = REG_RD(bp, BNX2_PCI_SWAP_DIAG0);
-	if (val != 0x01020304) {
-		printk(KERN_ERR PFX "Chip not in correct endian mode\n");
-		return -ENODEV;
-	}
-
-	/* Wait for the firmware to finish its initialization. */
-	rc = bnx2_fw_sync(bp, BNX2_DRV_MSG_DATA_WAIT1 | reset_code, 1, 0);
-	if (rc)
-		return rc;
-
-	spin_lock_bh(&bp->phy_lock);
-	old_port = bp->phy_port;
-	bnx2_init_fw_cap(bp);
-	if ((bp->phy_flags & BNX2_PHY_FLAG_REMOTE_PHY_CAP) &&
-	    old_port != bp->phy_port)
-		bnx2_set_default_remote_link(bp);
-	spin_unlock_bh(&bp->phy_lock);
-
-	if (CHIP_ID(bp) == CHIP_ID_5706_A0) {
-		/* Adjust the voltage regular to two steps lower.  The default
-		 * of this register is 0x0000000e. */
-		REG_WR(bp, BNX2_MISC_VREG_CONTROL, 0x000000fa);
-
-		/* Remove bad rbuf memory from the free pool. */
-		rc = bnx2_alloc_bad_rbuf(bp);
-	}
-
-	if (bp->flags & BNX2_FLAG_USING_MSIX) {
-		bnx2_setup_msix_tbl(bp);
-		/* Prevent MSIX table reads and write from timing out */
-		REG_WR(bp, BNX2_MISC_ECO_HW_CTL,
-			BNX2_MISC_ECO_HW_CTL_LARGE_GRC_TMOUT_EN);
-	}
-
-	return rc;
-}
-
-static int
-bnx2_init_chip(struct bnx2 *bp)
-{
-	u32 val, mtu;
-	int rc, i;
-
-	/* Make sure the interrupt is not active. */
-	REG_WR(bp, BNX2_PCICFG_INT_ACK_CMD, BNX2_PCICFG_INT_ACK_CMD_MASK_INT);
-
-	val = BNX2_DMA_CONFIG_DATA_BYTE_SWAP |
-	      BNX2_DMA_CONFIG_DATA_WORD_SWAP |
-#ifdef __BIG_ENDIAN
-	      BNX2_DMA_CONFIG_CNTL_BYTE_SWAP |
-#endif
-	      BNX2_DMA_CONFIG_CNTL_WORD_SWAP |
-	      DMA_READ_CHANS << 12 |
-	      DMA_WRITE_CHANS << 16;
-
-	val |= (0x2 << 20) | (1 << 11);
-
-	if ((bp->flags & BNX2_FLAG_PCIX) && (bp->bus_speed_mhz == 133))
-		val |= (1 << 23);
-
-	if ((CHIP_NUM(bp) == CHIP_NUM_5706) &&
-	    (CHIP_ID(bp) != CHIP_ID_5706_A0) && !(bp->flags & BNX2_FLAG_PCIX))
-		val |= BNX2_DMA_CONFIG_CNTL_PING_PONG_DMA;
-
-	REG_WR(bp, BNX2_DMA_CONFIG, val);
-
-	if (CHIP_ID(bp) == CHIP_ID_5706_A0) {
-		val = REG_RD(bp, BNX2_TDMA_CONFIG);
-		val |= BNX2_TDMA_CONFIG_ONE_DMA;
-		REG_WR(bp, BNX2_TDMA_CONFIG, val);
-	}
-
-	if (bp->flags & BNX2_FLAG_PCIX) {
-		u16 val16;
-
-		pci_read_config_word(bp->pdev, bp->pcix_cap + PCI_X_CMD,
-				     &val16);
-		pci_write_config_word(bp->pdev, bp->pcix_cap + PCI_X_CMD,
-				      val16 & ~PCI_X_CMD_ERO);
-	}
-
-	REG_WR(bp, BNX2_MISC_ENABLE_SET_BITS,
-	       BNX2_MISC_ENABLE_SET_BITS_HOST_COALESCE_ENABLE |
-	       BNX2_MISC_ENABLE_STATUS_BITS_RX_V2P_ENABLE |
-	       BNX2_MISC_ENABLE_STATUS_BITS_CONTEXT_ENABLE);
-
-	/* Initialize context mapping and zero out the quick contexts.  The
-	 * context block must have already been enabled. */
-	if (CHIP_NUM(bp) == CHIP_NUM_5709) {
-		rc = bnx2_init_5709_context(bp);
-		if (rc)
-			return rc;
-	} else
-		bnx2_init_context(bp);
-
-	if ((rc = bnx2_init_cpus(bp)) != 0)
-		return rc;
-
-	bnx2_init_nvram(bp);
-
-	bnx2_set_mac_addr(bp, bp->dev->dev_addr, 0);
-
-	val = REG_RD(bp, BNX2_MQ_CONFIG);
-	val &= ~BNX2_MQ_CONFIG_KNL_BYP_BLK_SIZE;
-	val |= BNX2_MQ_CONFIG_KNL_BYP_BLK_SIZE_256;
-	if (CHIP_NUM(bp) == CHIP_NUM_5709) {
-		val |= BNX2_MQ_CONFIG_BIN_MQ_MODE;
-		if (CHIP_REV(bp) == CHIP_REV_Ax)
-			val |= BNX2_MQ_CONFIG_HALT_DIS;
-	}
-
-	REG_WR(bp, BNX2_MQ_CONFIG, val);
-
-	val = 0x10000 + (MAX_CID_CNT * MB_KERNEL_CTX_SIZE);
-	REG_WR(bp, BNX2_MQ_KNL_BYP_WIND_START, val);
-	REG_WR(bp, BNX2_MQ_KNL_WIND_END, val);
-
-	val = (BCM_PAGE_BITS - 8) << 24;
-	REG_WR(bp, BNX2_RV2P_CONFIG, val);
-
-	/* Configure page size. */
-	val = REG_RD(bp, BNX2_TBDR_CONFIG);
-	val &= ~BNX2_TBDR_CONFIG_PAGE_SIZE;
-	val |= (BCM_PAGE_BITS - 8) << 24 | 0x40;
-	REG_WR(bp, BNX2_TBDR_CONFIG, val);
-
-	val = bp->mac_addr[0] +
-	      (bp->mac_addr[1] << 8) +
-	      (bp->mac_addr[2] << 16) +
-	      bp->mac_addr[3] +
-	      (bp->mac_addr[4] << 8) +
-	      (bp->mac_addr[5] << 16);
-	REG_WR(bp, BNX2_EMAC_BACKOFF_SEED, val);
-
-	/* Program the MTU.  Also include 4 bytes for CRC32. */
-	mtu = bp->dev->mtu;
-	val = mtu + ETH_HLEN + ETH_FCS_LEN;
-	if (val > (MAX_ETHERNET_PACKET_SIZE + 4))
-		val |= BNX2_EMAC_RX_MTU_SIZE_JUMBO_ENA;
-	REG_WR(bp, BNX2_EMAC_RX_MTU_SIZE, val);
-
-	if (mtu < 1500)
-		mtu = 1500;
-
-	bnx2_reg_wr_ind(bp, BNX2_RBUF_CONFIG, BNX2_RBUF_CONFIG_VAL(mtu));
-	bnx2_reg_wr_ind(bp, BNX2_RBUF_CONFIG2, BNX2_RBUF_CONFIG2_VAL(mtu));
-	bnx2_reg_wr_ind(bp, BNX2_RBUF_CONFIG3, BNX2_RBUF_CONFIG3_VAL(mtu));
-
-	memset(bp->bnx2_napi[0].status_blk.msi, 0, bp->status_stats_size);
-	for (i = 0; i < BNX2_MAX_MSIX_VEC; i++)
-		bp->bnx2_napi[i].last_status_idx = 0;
-
-	bp->idle_chk_status_idx = 0xffff;
-
-	bp->rx_mode = BNX2_EMAC_RX_MODE_SORT_MODE;
-
-	/* Set up how to generate a link change interrupt. */
-	REG_WR(bp, BNX2_EMAC_ATTENTION_ENA, BNX2_EMAC_ATTENTION_ENA_LINK);
-
-	REG_WR(bp, BNX2_HC_STATUS_ADDR_L,
-	       (u64) bp->status_blk_mapping & 0xffffffff);
-	REG_WR(bp, BNX2_HC_STATUS_ADDR_H, (u64) bp->status_blk_mapping >> 32);
-
-	REG_WR(bp, BNX2_HC_STATISTICS_ADDR_L,
-	       (u64) bp->stats_blk_mapping & 0xffffffff);
-	REG_WR(bp, BNX2_HC_STATISTICS_ADDR_H,
-	       (u64) bp->stats_blk_mapping >> 32);
-
-	REG_WR(bp, BNX2_HC_TX_QUICK_CONS_TRIP,
-	       (bp->tx_quick_cons_trip_int << 16) | bp->tx_quick_cons_trip);
-
-	REG_WR(bp, BNX2_HC_RX_QUICK_CONS_TRIP,
-	       (bp->rx_quick_cons_trip_int << 16) | bp->rx_quick_cons_trip);
-
-	REG_WR(bp, BNX2_HC_COMP_PROD_TRIP,
-	       (bp->comp_prod_trip_int << 16) | bp->comp_prod_trip);
-
-	REG_WR(bp, BNX2_HC_TX_TICKS, (bp->tx_ticks_int << 16) | bp->tx_ticks);
-
-	REG_WR(bp, BNX2_HC_RX_TICKS, (bp->rx_ticks_int << 16) | bp->rx_ticks);
-
-	REG_WR(bp, BNX2_HC_COM_TICKS,
-	       (bp->com_ticks_int << 16) | bp->com_ticks);
-
-	REG_WR(bp, BNX2_HC_CMD_TICKS,
-	       (bp->cmd_ticks_int << 16) | bp->cmd_ticks);
-
-	if (bp->flags & BNX2_FLAG_BROKEN_STATS)
-		REG_WR(bp, BNX2_HC_STATS_TICKS, 0);
-	else
-		REG_WR(bp, BNX2_HC_STATS_TICKS, bp->stats_ticks);
-	REG_WR(bp, BNX2_HC_STAT_COLLECT_TICKS, 0xbb8);  /* 3ms */
-
-	if (CHIP_ID(bp) == CHIP_ID_5706_A1)
-		val = BNX2_HC_CONFIG_COLLECT_STATS;
-	else {
-		val = BNX2_HC_CONFIG_RX_TMR_MODE | BNX2_HC_CONFIG_TX_TMR_MODE |
-		      BNX2_HC_CONFIG_COLLECT_STATS;
-	}
-
-	if (bp->irq_nvecs > 1) {
-		REG_WR(bp, BNX2_HC_MSIX_BIT_VECTOR,
-		       BNX2_HC_MSIX_BIT_VECTOR_VAL);
-
-		val |= BNX2_HC_CONFIG_SB_ADDR_INC_128B;
-	}
-
-	if (bp->flags & BNX2_FLAG_ONE_SHOT_MSI)
-		val |= BNX2_HC_CONFIG_ONE_SHOT | BNX2_HC_CONFIG_USE_INT_PARAM;
-
-	REG_WR(bp, BNX2_HC_CONFIG, val);
-
-	for (i = 1; i < bp->irq_nvecs; i++) {
-		u32 base = ((i - 1) * BNX2_HC_SB_CONFIG_SIZE) +
-			   BNX2_HC_SB_CONFIG_1;
-
-		REG_WR(bp, base,
-			BNX2_HC_SB_CONFIG_1_TX_TMR_MODE |
-			BNX2_HC_SB_CONFIG_1_RX_TMR_MODE |
-			BNX2_HC_SB_CONFIG_1_ONE_SHOT);
-
-		REG_WR(bp, base + BNX2_HC_TX_QUICK_CONS_TRIP_OFF,
-			(bp->tx_quick_cons_trip_int << 16) |
-			 bp->tx_quick_cons_trip);
-
-		REG_WR(bp, base + BNX2_HC_TX_TICKS_OFF,
-			(bp->tx_ticks_int << 16) | bp->tx_ticks);
-
-		REG_WR(bp, base + BNX2_HC_RX_QUICK_CONS_TRIP_OFF,
-		       (bp->rx_quick_cons_trip_int << 16) |
-			bp->rx_quick_cons_trip);
-
-		REG_WR(bp, base + BNX2_HC_RX_TICKS_OFF,
-			(bp->rx_ticks_int << 16) | bp->rx_ticks);
-	}
-
-	/* Clear internal stats counters. */
-	REG_WR(bp, BNX2_HC_COMMAND, BNX2_HC_COMMAND_CLR_STAT_NOW);
-
-	REG_WR(bp, BNX2_HC_ATTN_BITS_ENABLE, STATUS_ATTN_EVENTS);
-
-	/* Initialize the receive filter. */
-	bnx2_set_rx_mode(bp->dev);
-
-	if (CHIP_NUM(bp) == CHIP_NUM_5709) {
-		val = REG_RD(bp, BNX2_MISC_NEW_CORE_CTL);
-		val |= BNX2_MISC_NEW_CORE_CTL_DMA_ENABLE;
-		REG_WR(bp, BNX2_MISC_NEW_CORE_CTL, val);
-	}
-	rc = bnx2_fw_sync(bp, BNX2_DRV_MSG_DATA_WAIT2 | BNX2_DRV_MSG_CODE_RESET,
-			  1, 0);
-
-	REG_WR(bp, BNX2_MISC_ENABLE_SET_BITS, BNX2_MISC_ENABLE_DEFAULT);
-	REG_RD(bp, BNX2_MISC_ENABLE_SET_BITS);
-
-	udelay(20);
-
-	bp->hc_cmd = REG_RD(bp, BNX2_HC_COMMAND);
-
-	return rc;
-}
-
-static void
-bnx2_clear_ring_states(struct bnx2 *bp)
-{
-	struct bnx2_napi *bnapi;
-	struct bnx2_tx_ring_info *txr;
-	struct bnx2_rx_ring_info *rxr;
-	int i;
-
-	for (i = 0; i < BNX2_MAX_MSIX_VEC; i++) {
-		bnapi = &bp->bnx2_napi[i];
-		txr = &bnapi->tx_ring;
-		rxr = &bnapi->rx_ring;
-
-		txr->tx_cons = 0;
-		txr->hw_tx_cons = 0;
-		rxr->rx_prod_bseq = 0;
-		rxr->rx_prod = 0;
-		rxr->rx_cons = 0;
-		rxr->rx_pg_prod = 0;
-		rxr->rx_pg_cons = 0;
-	}
-}
-
-static void
-bnx2_init_tx_context(struct bnx2 *bp, u32 cid, struct bnx2_tx_ring_info *txr)
-{
-	u32 val, offset0, offset1, offset2, offset3;
-	u32 cid_addr = GET_CID_ADDR(cid);
-
-	if (CHIP_NUM(bp) == CHIP_NUM_5709) {
-		offset0 = BNX2_L2CTX_TYPE_XI;
-		offset1 = BNX2_L2CTX_CMD_TYPE_XI;
-		offset2 = BNX2_L2CTX_TBDR_BHADDR_HI_XI;
-		offset3 = BNX2_L2CTX_TBDR_BHADDR_LO_XI;
-	} else {
-		offset0 = BNX2_L2CTX_TYPE;
-		offset1 = BNX2_L2CTX_CMD_TYPE;
-		offset2 = BNX2_L2CTX_TBDR_BHADDR_HI;
-		offset3 = BNX2_L2CTX_TBDR_BHADDR_LO;
-	}
-	val = BNX2_L2CTX_TYPE_TYPE_L2 | BNX2_L2CTX_TYPE_SIZE_L2;
-	bnx2_ctx_wr(bp, cid_addr, offset0, val);
-
-	val = BNX2_L2CTX_CMD_TYPE_TYPE_L2 | (8 << 16);
-	bnx2_ctx_wr(bp, cid_addr, offset1, val);
-
-	val = (u64) txr->tx_desc_mapping >> 32;
-	bnx2_ctx_wr(bp, cid_addr, offset2, val);
-
-	val = (u64) txr->tx_desc_mapping & 0xffffffff;
-	bnx2_ctx_wr(bp, cid_addr, offset3, val);
-}
-
-static void
-bnx2_init_tx_ring(struct bnx2 *bp, int ring_num)
-{
-	struct tx_bd *txbd;
-	u32 cid = TX_CID;
-	struct bnx2_napi *bnapi;
-	struct bnx2_tx_ring_info *txr;
-
-	bnapi = &bp->bnx2_napi[ring_num];
-	txr = &bnapi->tx_ring;
-
-	if (ring_num == 0)
-		cid = TX_CID;
-	else
-		cid = TX_TSS_CID + ring_num - 1;
-
-	bp->tx_wake_thresh = bp->tx_ring_size / 2;
-
-	txbd = &txr->tx_desc_ring[MAX_TX_DESC_CNT];
-
-	txbd->tx_bd_haddr_hi = (u64) txr->tx_desc_mapping >> 32;
-	txbd->tx_bd_haddr_lo = (u64) txr->tx_desc_mapping & 0xffffffff;
-
-	txr->tx_prod = 0;
-	txr->tx_prod_bseq = 0;
-
-	txr->tx_bidx_addr = MB_GET_CID_ADDR(cid) + BNX2_L2CTX_TX_HOST_BIDX;
-	txr->tx_bseq_addr = MB_GET_CID_ADDR(cid) + BNX2_L2CTX_TX_HOST_BSEQ;
-
-	bnx2_init_tx_context(bp, cid, txr);
-}
-
-static void
-bnx2_init_rxbd_rings(struct rx_bd *rx_ring[], dma_addr_t dma[], u32 buf_size,
-		     int num_rings)
-{
-	int i;
-	struct rx_bd *rxbd;
-
-	for (i = 0; i < num_rings; i++) {
-		int j;
-
-		rxbd = &rx_ring[i][0];
-		for (j = 0; j < MAX_RX_DESC_CNT; j++, rxbd++) {
-			rxbd->rx_bd_len = buf_size;
-			rxbd->rx_bd_flags = RX_BD_FLAGS_START | RX_BD_FLAGS_END;
-		}
-		if (i == (num_rings - 1))
-			j = 0;
-		else
-			j = i + 1;
-		rxbd->rx_bd_haddr_hi = (u64) dma[j] >> 32;
-		rxbd->rx_bd_haddr_lo = (u64) dma[j] & 0xffffffff;
-	}
-}
-
-static void
-bnx2_init_rx_ring(struct bnx2 *bp, int ring_num)
-{
-	int i;
-	u16 prod, ring_prod;
-	u32 cid, rx_cid_addr, val;
-	struct bnx2_napi *bnapi = &bp->bnx2_napi[ring_num];
-	struct bnx2_rx_ring_info *rxr = &bnapi->rx_ring;
-
-	if (ring_num == 0)
-		cid = RX_CID;
-	else
-		cid = RX_RSS_CID + ring_num - 1;
-
-	rx_cid_addr = GET_CID_ADDR(cid);
-
-	bnx2_init_rxbd_rings(rxr->rx_desc_ring, rxr->rx_desc_mapping,
-			     bp->rx_buf_use_size, bp->rx_max_ring);
-
-	bnx2_init_rx_context(bp, cid);
-
-	if (CHIP_NUM(bp) == CHIP_NUM_5709) {
-		val = REG_RD(bp, BNX2_MQ_MAP_L2_5);
-		REG_WR(bp, BNX2_MQ_MAP_L2_5, val | BNX2_MQ_MAP_L2_5_ARM);
-	}
-
-	bnx2_ctx_wr(bp, rx_cid_addr, BNX2_L2CTX_PG_BUF_SIZE, 0);
-	if (bp->rx_pg_ring_size) {
-		bnx2_init_rxbd_rings(rxr->rx_pg_desc_ring,
-				     rxr->rx_pg_desc_mapping,
-				     PAGE_SIZE, bp->rx_max_pg_ring);
-		val = (bp->rx_buf_use_size << 16) | PAGE_SIZE;
-		bnx2_ctx_wr(bp, rx_cid_addr, BNX2_L2CTX_PG_BUF_SIZE, val);
-		bnx2_ctx_wr(bp, rx_cid_addr, BNX2_L2CTX_RBDC_KEY,
-		       BNX2_L2CTX_RBDC_JUMBO_KEY - ring_num);
-
-		val = (u64) rxr->rx_pg_desc_mapping[0] >> 32;
-		bnx2_ctx_wr(bp, rx_cid_addr, BNX2_L2CTX_NX_PG_BDHADDR_HI, val);
-
-		val = (u64) rxr->rx_pg_desc_mapping[0] & 0xffffffff;
-		bnx2_ctx_wr(bp, rx_cid_addr, BNX2_L2CTX_NX_PG_BDHADDR_LO, val);
-
-		if (CHIP_NUM(bp) == CHIP_NUM_5709)
-			REG_WR(bp, BNX2_MQ_MAP_L2_3, BNX2_MQ_MAP_L2_3_DEFAULT);
-	}
-
-	val = (u64) rxr->rx_desc_mapping[0] >> 32;
-	bnx2_ctx_wr(bp, rx_cid_addr, BNX2_L2CTX_NX_BDHADDR_HI, val);
-
-	val = (u64) rxr->rx_desc_mapping[0] & 0xffffffff;
-	bnx2_ctx_wr(bp, rx_cid_addr, BNX2_L2CTX_NX_BDHADDR_LO, val);
-
-	ring_prod = prod = rxr->rx_pg_prod;
-	for (i = 0; i < bp->rx_pg_ring_size; i++) {
-		if (bnx2_alloc_rx_page(bp, rxr, ring_prod) < 0) {
-			printk(KERN_WARNING PFX "%s: init'ed rx page ring %d "
-						"with %d/%d pages only\n",
-			       bp->dev->name, ring_num, i, bp->rx_pg_ring_size);
-			break;
-		}
-		prod = NEXT_RX_BD(prod);
-		ring_prod = RX_PG_RING_IDX(prod);
-	}
-	rxr->rx_pg_prod = prod;
-
-	ring_prod = prod = rxr->rx_prod;
-	for (i = 0; i < bp->rx_ring_size; i++) {
-		if (bnx2_alloc_rx_skb(bp, rxr, ring_prod) < 0) {
-			printk(KERN_WARNING PFX "%s: init'ed rx ring %d with "
-						"%d/%d skbs only\n",
-			       bp->dev->name, ring_num, i, bp->rx_ring_size);
-			break;
-		}
-		prod = NEXT_RX_BD(prod);
-		ring_prod = RX_RING_IDX(prod);
-	}
-	rxr->rx_prod = prod;
-
-	rxr->rx_bidx_addr = MB_GET_CID_ADDR(cid) + BNX2_L2CTX_HOST_BDIDX;
-	rxr->rx_bseq_addr = MB_GET_CID_ADDR(cid) + BNX2_L2CTX_HOST_BSEQ;
-	rxr->rx_pg_bidx_addr = MB_GET_CID_ADDR(cid) + BNX2_L2CTX_HOST_PG_BDIDX;
-
-	REG_WR16(bp, rxr->rx_pg_bidx_addr, rxr->rx_pg_prod);
-	REG_WR16(bp, rxr->rx_bidx_addr, prod);
-
-	REG_WR(bp, rxr->rx_bseq_addr, rxr->rx_prod_bseq);
-}
-
-static void
-bnx2_init_all_rings(struct bnx2 *bp)
-{
-	int i;
-	u32 val;
-
-	bnx2_clear_ring_states(bp);
-
-	REG_WR(bp, BNX2_TSCH_TSS_CFG, 0);
-	for (i = 0; i < bp->num_tx_rings; i++)
-		bnx2_init_tx_ring(bp, i);
-
-	if (bp->num_tx_rings > 1)
-		REG_WR(bp, BNX2_TSCH_TSS_CFG, ((bp->num_tx_rings - 1) << 24) |
-		       (TX_TSS_CID << 7));
-
-	REG_WR(bp, BNX2_RLUP_RSS_CONFIG, 0);
-	bnx2_reg_wr_ind(bp, BNX2_RXP_SCRATCH_RSS_TBL_SZ, 0);
-
-	for (i = 0; i < bp->num_rx_rings; i++)
-		bnx2_init_rx_ring(bp, i);
-
-	if (bp->num_rx_rings > 1) {
-		u32 tbl_32;
-		u8 *tbl = (u8 *) &tbl_32;
-
-		bnx2_reg_wr_ind(bp, BNX2_RXP_SCRATCH_RSS_TBL_SZ,
-				BNX2_RXP_SCRATCH_RSS_TBL_MAX_ENTRIES);
-
-		for (i = 0; i < BNX2_RXP_SCRATCH_RSS_TBL_MAX_ENTRIES; i++) {
-			tbl[i % 4] = i % (bp->num_rx_rings - 1);
-			if ((i % 4) == 3)
-				bnx2_reg_wr_ind(bp,
-						BNX2_RXP_SCRATCH_RSS_TBL + i,
-						cpu_to_be32(tbl_32));
-		}
-
-		val = BNX2_RLUP_RSS_CONFIG_IPV4_RSS_TYPE_ALL_XI |
-		      BNX2_RLUP_RSS_CONFIG_IPV6_RSS_TYPE_ALL_XI;
-
-		REG_WR(bp, BNX2_RLUP_RSS_CONFIG, val);
-
-	}
-}
-
-static u32 bnx2_find_max_ring(u32 ring_size, u32 max_size)
-{
-	u32 max, num_rings = 1;
-
-	while (ring_size > MAX_RX_DESC_CNT) {
-		ring_size -= MAX_RX_DESC_CNT;
-		num_rings++;
-	}
-	/* round to next power of 2 */
-	max = max_size;
-	while ((max & num_rings) == 0)
-		max >>= 1;
-
-	if (num_rings != max)
-		max <<= 1;
-
-	return max;
-}
-
-static void
-bnx2_set_rx_ring_size(struct bnx2 *bp, u32 size)
-{
-	u32 rx_size, rx_space, jumbo_size;
-
-	/* 8 for CRC and VLAN */
-	rx_size = bp->dev->mtu + ETH_HLEN + BNX2_RX_OFFSET + 8;
-
-	rx_space = SKB_DATA_ALIGN(rx_size + BNX2_RX_ALIGN) + NET_SKB_PAD +
-		sizeof(struct skb_shared_info);
-
-	bp->rx_copy_thresh = BNX2_RX_COPY_THRESH;
-	bp->rx_pg_ring_size = 0;
-	bp->rx_max_pg_ring = 0;
-	bp->rx_max_pg_ring_idx = 0;
-	if ((rx_space > PAGE_SIZE) && !(bp->flags & BNX2_FLAG_JUMBO_BROKEN)) {
-		int pages = PAGE_ALIGN(bp->dev->mtu - 40) >> PAGE_SHIFT;
-
-		jumbo_size = size * pages;
-		if (jumbo_size > MAX_TOTAL_RX_PG_DESC_CNT)
-			jumbo_size = MAX_TOTAL_RX_PG_DESC_CNT;
-
-		bp->rx_pg_ring_size = jumbo_size;
-		bp->rx_max_pg_ring = bnx2_find_max_ring(jumbo_size,
-							MAX_RX_PG_RINGS);
-		bp->rx_max_pg_ring_idx = (bp->rx_max_pg_ring * RX_DESC_CNT) - 1;
-		rx_size = BNX2_RX_COPY_THRESH + BNX2_RX_OFFSET;
-		bp->rx_copy_thresh = 0;
-	}
-
-	bp->rx_buf_use_size = rx_size;
-	/* hw alignment */
-	bp->rx_buf_size = bp->rx_buf_use_size + BNX2_RX_ALIGN;
-	bp->rx_jumbo_thresh = rx_size - BNX2_RX_OFFSET;
-	bp->rx_ring_size = size;
-	bp->rx_max_ring = bnx2_find_max_ring(size, MAX_RX_RINGS);
-	bp->rx_max_ring_idx = (bp->rx_max_ring * RX_DESC_CNT) - 1;
-}
-
-static void
-bnx2_free_tx_skbs(struct bnx2 *bp)
-{
-	int i;
-
-	for (i = 0; i < bp->num_tx_rings; i++) {
-		struct bnx2_napi *bnapi = &bp->bnx2_napi[i];
-		struct bnx2_tx_ring_info *txr = &bnapi->tx_ring;
-		int j;
-
-		if (txr->tx_buf_ring == NULL)
-			continue;
-
-		for (j = 0; j < TX_DESC_CNT; ) {
-			struct sw_tx_bd *tx_buf = &txr->tx_buf_ring[j];
-			struct sk_buff *skb = tx_buf->skb;
-			int k, last;
-
-			if (skb == NULL) {
-				j++;
-				continue;
-			}
-
-			pci_unmap_single(bp->pdev,
-					 pci_unmap_addr(tx_buf, mapping),
-					 skb_headlen(skb),
-					 PCI_DMA_TODEVICE);
-
-			tx_buf->skb = NULL;
-
-			last = tx_buf->nr_frags;
-			j++;
-			for (k = 0; k < last; k++, j++) {
-				tx_buf = &txr->tx_buf_ring[TX_RING_IDX(j)];
-				pci_unmap_page(bp->pdev,
-					pci_unmap_addr(tx_buf, mapping),
-					skb_shinfo(skb)->frags[k].size,
-					PCI_DMA_TODEVICE);
-			}
-			dev_kfree_skb(skb);
-		}
-	}
-}
-
-static void
-bnx2_free_rx_skbs(struct bnx2 *bp)
-{
-	int i;
-
-	for (i = 0; i < bp->num_rx_rings; i++) {
-		struct bnx2_napi *bnapi = &bp->bnx2_napi[i];
-		struct bnx2_rx_ring_info *rxr = &bnapi->rx_ring;
-		int j;
-
-		if (rxr->rx_buf_ring == NULL)
-			return;
-
-		for (j = 0; j < bp->rx_max_ring_idx; j++) {
-			struct sw_bd *rx_buf = &rxr->rx_buf_ring[j];
-			struct sk_buff *skb = rx_buf->skb;
-
-			if (skb == NULL)
-				continue;
-
-			pci_unmap_single(bp->pdev,
-					 pci_unmap_addr(rx_buf, mapping),
-					 bp->rx_buf_use_size,
-					 PCI_DMA_FROMDEVICE);
-
-			rx_buf->skb = NULL;
-
-			dev_kfree_skb(skb);
-		}
-		for (j = 0; j < bp->rx_max_pg_ring_idx; j++)
-			bnx2_free_rx_page(bp, rxr, j);
-	}
-}
-
-static void
-bnx2_free_skbs(struct bnx2 *bp)
-{
-	bnx2_free_tx_skbs(bp);
-	bnx2_free_rx_skbs(bp);
-}
-
-static int
-bnx2_reset_nic(struct bnx2 *bp, u32 reset_code)
-{
-	int rc;
-
-	rc = bnx2_reset_chip(bp, reset_code);
-	bnx2_free_skbs(bp);
-	if (rc)
-		return rc;
-
-	if ((rc = bnx2_init_chip(bp)) != 0)
-		return rc;
-
-	bnx2_init_all_rings(bp);
-	return 0;
-}
-
-static int
-bnx2_init_nic(struct bnx2 *bp, int reset_phy)
-{
-	int rc;
-
-	if ((rc = bnx2_reset_nic(bp, BNX2_DRV_MSG_CODE_RESET)) != 0)
-		return rc;
-
-	spin_lock_bh(&bp->phy_lock);
-	bnx2_init_phy(bp, reset_phy);
-	bnx2_set_link(bp);
-	if (bp->phy_flags & BNX2_PHY_FLAG_REMOTE_PHY_CAP)
-		bnx2_remote_phy_event(bp);
-	spin_unlock_bh(&bp->phy_lock);
-	return 0;
-}
-
-static int
-bnx2_shutdown_chip(struct bnx2 *bp)
-{
-	u32 reset_code;
-
-	if (bp->flags & BNX2_FLAG_NO_WOL)
-		reset_code = BNX2_DRV_MSG_CODE_UNLOAD_LNK_DN;
-	else if (bp->wol)
-		reset_code = BNX2_DRV_MSG_CODE_SUSPEND_WOL;
-	else
-		reset_code = BNX2_DRV_MSG_CODE_SUSPEND_NO_WOL;
-
-	return bnx2_reset_chip(bp, reset_code);
-}
-
-static int
-bnx2_test_registers(struct bnx2 *bp)
-{
-	int ret;
-	int i, is_5709;
-	static const struct {
-		u16   offset;
-		u16   flags;
-#define BNX2_FL_NOT_5709	1
-		u32   rw_mask;
-		u32   ro_mask;
-	} reg_tbl[] = {
-		{ 0x006c, 0, 0x00000000, 0x0000003f },
-		{ 0x0090, 0, 0xffffffff, 0x00000000 },
-		{ 0x0094, 0, 0x00000000, 0x00000000 },
-
-		{ 0x0404, BNX2_FL_NOT_5709, 0x00003f00, 0x00000000 },
-		{ 0x0418, BNX2_FL_NOT_5709, 0x00000000, 0xffffffff },
-		{ 0x041c, BNX2_FL_NOT_5709, 0x00000000, 0xffffffff },
-		{ 0x0420, BNX2_FL_NOT_5709, 0x00000000, 0x80ffffff },
-		{ 0x0424, BNX2_FL_NOT_5709, 0x00000000, 0x00000000 },
-		{ 0x0428, BNX2_FL_NOT_5709, 0x00000000, 0x00000001 },
-		{ 0x0450, BNX2_FL_NOT_5709, 0x00000000, 0x0000ffff },
-		{ 0x0454, BNX2_FL_NOT_5709, 0x00000000, 0xffffffff },
-		{ 0x0458, BNX2_FL_NOT_5709, 0x00000000, 0xffffffff },
-
-		{ 0x0808, BNX2_FL_NOT_5709, 0x00000000, 0xffffffff },
-		{ 0x0854, BNX2_FL_NOT_5709, 0x00000000, 0xffffffff },
-		{ 0x0868, BNX2_FL_NOT_5709, 0x00000000, 0x77777777 },
-		{ 0x086c, BNX2_FL_NOT_5709, 0x00000000, 0x77777777 },
-		{ 0x0870, BNX2_FL_NOT_5709, 0x00000000, 0x77777777 },
-		{ 0x0874, BNX2_FL_NOT_5709, 0x00000000, 0x77777777 },
-
-		{ 0x0c00, BNX2_FL_NOT_5709, 0x00000000, 0x00000001 },
-		{ 0x0c04, BNX2_FL_NOT_5709, 0x00000000, 0x03ff0001 },
-		{ 0x0c08, BNX2_FL_NOT_5709,  0x0f0ff073, 0x00000000 },
-
-		{ 0x1000, 0, 0x00000000, 0x00000001 },
-		{ 0x1004, BNX2_FL_NOT_5709, 0x00000000, 0x000f0001 },
-
-		{ 0x1408, 0, 0x01c00800, 0x00000000 },
-		{ 0x149c, 0, 0x8000ffff, 0x00000000 },
-		{ 0x14a8, 0, 0x00000000, 0x000001ff },
-		{ 0x14ac, 0, 0x0fffffff, 0x10000000 },
-		{ 0x14b0, 0, 0x00000002, 0x00000001 },
-		{ 0x14b8, 0, 0x00000000, 0x00000000 },
-		{ 0x14c0, 0, 0x00000000, 0x00000009 },
-		{ 0x14c4, 0, 0x00003fff, 0x00000000 },
-		{ 0x14cc, 0, 0x00000000, 0x00000001 },
-		{ 0x14d0, 0, 0xffffffff, 0x00000000 },
-
-		{ 0x1800, 0, 0x00000000, 0x00000001 },
-		{ 0x1804, 0, 0x00000000, 0x00000003 },
-
-		{ 0x2800, 0, 0x00000000, 0x00000001 },
-		{ 0x2804, 0, 0x00000000, 0x00003f01 },
-		{ 0x2808, 0, 0x0f3f3f03, 0x00000000 },
-		{ 0x2810, 0, 0xffff0000, 0x00000000 },
-		{ 0x2814, 0, 0xffff0000, 0x00000000 },
-		{ 0x2818, 0, 0xffff0000, 0x00000000 },
-		{ 0x281c, 0, 0xffff0000, 0x00000000 },
-		{ 0x2834, 0, 0xffffffff, 0x00000000 },
-		{ 0x2840, 0, 0x00000000, 0xffffffff },
-		{ 0x2844, 0, 0x00000000, 0xffffffff },
-		{ 0x2848, 0, 0xffffffff, 0x00000000 },
-		{ 0x284c, 0, 0xf800f800, 0x07ff07ff },
-
-		{ 0x2c00, 0, 0x00000000, 0x00000011 },
-		{ 0x2c04, 0, 0x00000000, 0x00030007 },
-
-		{ 0x3c00, 0, 0x00000000, 0x00000001 },
-		{ 0x3c04, 0, 0x00000000, 0x00070000 },
-		{ 0x3c08, 0, 0x00007f71, 0x07f00000 },
-		{ 0x3c0c, 0, 0x1f3ffffc, 0x00000000 },
-		{ 0x3c10, 0, 0xffffffff, 0x00000000 },
-		{ 0x3c14, 0, 0x00000000, 0xffffffff },
-		{ 0x3c18, 0, 0x00000000, 0xffffffff },
-		{ 0x3c1c, 0, 0xfffff000, 0x00000000 },
-		{ 0x3c20, 0, 0xffffff00, 0x00000000 },
-
-		{ 0x5004, 0, 0x00000000, 0x0000007f },
-		{ 0x5008, 0, 0x0f0007ff, 0x00000000 },
-
-		{ 0x5c00, 0, 0x00000000, 0x00000001 },
-		{ 0x5c04, 0, 0x00000000, 0x0003000f },
-		{ 0x5c08, 0, 0x00000003, 0x00000000 },
-		{ 0x5c0c, 0, 0x0000fff8, 0x00000000 },
-		{ 0x5c10, 0, 0x00000000, 0xffffffff },
-		{ 0x5c80, 0, 0x00000000, 0x0f7113f1 },
-		{ 0x5c84, 0, 0x00000000, 0x0000f333 },
-		{ 0x5c88, 0, 0x00000000, 0x00077373 },
-		{ 0x5c8c, 0, 0x00000000, 0x0007f737 },
-
-		{ 0x6808, 0, 0x0000ff7f, 0x00000000 },
-		{ 0x680c, 0, 0xffffffff, 0x00000000 },
-		{ 0x6810, 0, 0xffffffff, 0x00000000 },
-		{ 0x6814, 0, 0xffffffff, 0x00000000 },
-		{ 0x6818, 0, 0xffffffff, 0x00000000 },
-		{ 0x681c, 0, 0xffffffff, 0x00000000 },
-		{ 0x6820, 0, 0x00ff00ff, 0x00000000 },
-		{ 0x6824, 0, 0x00ff00ff, 0x00000000 },
-		{ 0x6828, 0, 0x00ff00ff, 0x00000000 },
-		{ 0x682c, 0, 0x03ff03ff, 0x00000000 },
-		{ 0x6830, 0, 0x03ff03ff, 0x00000000 },
-		{ 0x6834, 0, 0x03ff03ff, 0x00000000 },
-		{ 0x6838, 0, 0x03ff03ff, 0x00000000 },
-		{ 0x683c, 0, 0x0000ffff, 0x00000000 },
-		{ 0x6840, 0, 0x00000ff0, 0x00000000 },
-		{ 0x6844, 0, 0x00ffff00, 0x00000000 },
-		{ 0x684c, 0, 0xffffffff, 0x00000000 },
-		{ 0x6850, 0, 0x7f7f7f7f, 0x00000000 },
-		{ 0x6854, 0, 0x7f7f7f7f, 0x00000000 },
-		{ 0x6858, 0, 0x7f7f7f7f, 0x00000000 },
-		{ 0x685c, 0, 0x7f7f7f7f, 0x00000000 },
-		{ 0x6908, 0, 0x00000000, 0x0001ff0f },
-		{ 0x690c, 0, 0x00000000, 0x0ffe00f0 },
-
-		{ 0xffff, 0, 0x00000000, 0x00000000 },
-	};
-
-	ret = 0;
-	is_5709 = 0;
-	if (CHIP_NUM(bp) == CHIP_NUM_5709)
-		is_5709 = 1;
-
-	for (i = 0; reg_tbl[i].offset != 0xffff; i++) {
-		u32 offset, rw_mask, ro_mask, save_val, val;
-		u16 flags = reg_tbl[i].flags;
-
-		if (is_5709 && (flags & BNX2_FL_NOT_5709))
-			continue;
-
-		offset = (u32) reg_tbl[i].offset;
-		rw_mask = reg_tbl[i].rw_mask;
-		ro_mask = reg_tbl[i].ro_mask;
-
-		save_val = readl(bp->regview + offset);
-
-		writel(0, bp->regview + offset);
-
-		val = readl(bp->regview + offset);
-		if ((val & rw_mask) != 0) {
-			goto reg_test_err;
-		}
-
-		if ((val & ro_mask) != (save_val & ro_mask)) {
-			goto reg_test_err;
-		}
-
-		writel(0xffffffff, bp->regview + offset);
-
-		val = readl(bp->regview + offset);
-		if ((val & rw_mask) != rw_mask) {
-			goto reg_test_err;
-		}
-
-		if ((val & ro_mask) != (save_val & ro_mask)) {
-			goto reg_test_err;
-		}
-
-		writel(save_val, bp->regview + offset);
-		continue;
-
-reg_test_err:
-		writel(save_val, bp->regview + offset);
-		ret = -ENODEV;
-		break;
-	}
-	return ret;
-}
-
-static int
-bnx2_do_mem_test(struct bnx2 *bp, u32 start, u32 size)
-{
-	static const u32 test_pattern[] = { 0x00000000, 0xffffffff, 0x55555555,
-		0xaaaaaaaa , 0xaa55aa55, 0x55aa55aa };
-	int i;
-
-	for (i = 0; i < sizeof(test_pattern) / 4; i++) {
-		u32 offset;
-
-		for (offset = 0; offset < size; offset += 4) {
-
-			bnx2_reg_wr_ind(bp, start + offset, test_pattern[i]);
-
-			if (bnx2_reg_rd_ind(bp, start + offset) !=
-				test_pattern[i]) {
-				return -ENODEV;
-			}
-		}
-	}
-	return 0;
-}
-
-static int
-bnx2_test_memory(struct bnx2 *bp)
-{
-	int ret = 0;
-	int i;
-	static struct mem_entry {
-		u32   offset;
-		u32   len;
-	} mem_tbl_5706[] = {
-		{ 0x60000,  0x4000 },
-		{ 0xa0000,  0x3000 },
-		{ 0xe0000,  0x4000 },
-		{ 0x120000, 0x4000 },
-		{ 0x1a0000, 0x4000 },
-		{ 0x160000, 0x4000 },
-		{ 0xffffffff, 0    },
-	},
-	mem_tbl_5709[] = {
-		{ 0x60000,  0x4000 },
-		{ 0xa0000,  0x3000 },
-		{ 0xe0000,  0x4000 },
-		{ 0x120000, 0x4000 },
-		{ 0x1a0000, 0x4000 },
-		{ 0xffffffff, 0    },
-	};
-	struct mem_entry *mem_tbl;
-
-	if (CHIP_NUM(bp) == CHIP_NUM_5709)
-		mem_tbl = mem_tbl_5709;
-	else
-		mem_tbl = mem_tbl_5706;
-
-	for (i = 0; mem_tbl[i].offset != 0xffffffff; i++) {
-		if ((ret = bnx2_do_mem_test(bp, mem_tbl[i].offset,
-			mem_tbl[i].len)) != 0) {
-			return ret;
-		}
-	}
-
-	return ret;
-}
-
-#define BNX2_MAC_LOOPBACK	0
-#define BNX2_PHY_LOOPBACK	1
-
-static int
-bnx2_run_loopback(struct bnx2 *bp, int loopback_mode)
-{
-	unsigned int pkt_size, num_pkts, i;
-	struct sk_buff *skb, *rx_skb;
-	unsigned char *packet;
-	u16 rx_start_idx, rx_idx;
-	dma_addr_t map;
-	struct tx_bd *txbd;
-	struct sw_bd *rx_buf;
-	struct l2_fhdr *rx_hdr;
-	int ret = -ENODEV;
-	struct bnx2_napi *bnapi = &bp->bnx2_napi[0], *tx_napi;
-	struct bnx2_tx_ring_info *txr = &bnapi->tx_ring;
-	struct bnx2_rx_ring_info *rxr = &bnapi->rx_ring;
-
-	tx_napi = bnapi;
-
-	txr = &tx_napi->tx_ring;
-	rxr = &bnapi->rx_ring;
-	if (loopback_mode == BNX2_MAC_LOOPBACK) {
-		bp->loopback = MAC_LOOPBACK;
-		bnx2_set_mac_loopback(bp);
-	}
-	else if (loopback_mode == BNX2_PHY_LOOPBACK) {
-		if (bp->phy_flags & BNX2_PHY_FLAG_REMOTE_PHY_CAP)
-			return 0;
-
-		bp->loopback = PHY_LOOPBACK;
-		bnx2_set_phy_loopback(bp);
-	}
-	else
-		return -EINVAL;
-
-	pkt_size = min(bp->dev->mtu + ETH_HLEN, bp->rx_jumbo_thresh - 4);
-	skb = netdev_alloc_skb(bp->dev, pkt_size);
-	if (!skb)
-		return -ENOMEM;
-	packet = skb_put(skb, pkt_size);
-	memcpy(packet, bp->dev->dev_addr, 6);
-	memset(packet + 6, 0x0, 8);
-	for (i = 14; i < pkt_size; i++)
-		packet[i] = (unsigned char) (i & 0xff);
-
-	map = pci_map_single(bp->pdev, skb->data, pkt_size,
-		PCI_DMA_TODEVICE);
-	if (pci_dma_mapping_error(bp->pdev, map)) {
-		dev_kfree_skb(skb);
-		return -EIO;
-	}
-
-	REG_WR(bp, BNX2_HC_COMMAND,
-	       bp->hc_cmd | BNX2_HC_COMMAND_COAL_NOW_WO_INT);
-
-	REG_RD(bp, BNX2_HC_COMMAND);
-
-	udelay(5);
-	rx_start_idx = bnx2_get_hw_rx_cons(bnapi);
-
-	num_pkts = 0;
-
-	txbd = &txr->tx_desc_ring[TX_RING_IDX(txr->tx_prod)];
-
-	txbd->tx_bd_haddr_hi = (u64) map >> 32;
-	txbd->tx_bd_haddr_lo = (u64) map & 0xffffffff;
-	txbd->tx_bd_mss_nbytes = pkt_size;
-	txbd->tx_bd_vlan_tag_flags = TX_BD_FLAGS_START | TX_BD_FLAGS_END;
-
-	num_pkts++;
-	txr->tx_prod = NEXT_TX_BD(txr->tx_prod);
-	txr->tx_prod_bseq += pkt_size;
-
-	REG_WR16(bp, txr->tx_bidx_addr, txr->tx_prod);
-	REG_WR(bp, txr->tx_bseq_addr, txr->tx_prod_bseq);
-
-	udelay(100);
-
-	REG_WR(bp, BNX2_HC_COMMAND,
-	       bp->hc_cmd | BNX2_HC_COMMAND_COAL_NOW_WO_INT);
-
-	REG_RD(bp, BNX2_HC_COMMAND);
-
-	udelay(5);
-
-	pci_unmap_single(bp->pdev, map, pkt_size, PCI_DMA_TODEVICE);
-	dev_kfree_skb(skb);
-
-	if (bnx2_get_hw_tx_cons(tx_napi) != txr->tx_prod)
-		goto loopback_test_done;
-
-	rx_idx = bnx2_get_hw_rx_cons(bnapi);
-	if (rx_idx != rx_start_idx + num_pkts) {
-		goto loopback_test_done;
-	}
-
-	rx_buf = &rxr->rx_buf_ring[rx_start_idx];
-	rx_skb = rx_buf->skb;
-
-	rx_hdr = (struct l2_fhdr *) rx_skb->data;
-	skb_reserve(rx_skb, BNX2_RX_OFFSET);
-
-	pci_dma_sync_single_for_cpu(bp->pdev,
-		pci_unmap_addr(rx_buf, mapping),
-		bp->rx_buf_size, PCI_DMA_FROMDEVICE);
-
-	if (rx_hdr->l2_fhdr_status &
-		(L2_FHDR_ERRORS_BAD_CRC |
-		L2_FHDR_ERRORS_PHY_DECODE |
-		L2_FHDR_ERRORS_ALIGNMENT |
-		L2_FHDR_ERRORS_TOO_SHORT |
-		L2_FHDR_ERRORS_GIANT_FRAME)) {
-
-		goto loopback_test_done;
-	}
-
-	if ((rx_hdr->l2_fhdr_pkt_len - 4) != pkt_size) {
-		goto loopback_test_done;
-	}
-
-	for (i = 14; i < pkt_size; i++) {
-		if (*(rx_skb->data + i) != (unsigned char) (i & 0xff)) {
-			goto loopback_test_done;
-		}
-	}
-
-	ret = 0;
-
-loopback_test_done:
-	bp->loopback = 0;
-	return ret;
-}
-
-#define BNX2_MAC_LOOPBACK_FAILED	1
-#define BNX2_PHY_LOOPBACK_FAILED	2
-#define BNX2_LOOPBACK_FAILED		(BNX2_MAC_LOOPBACK_FAILED |	\
-					 BNX2_PHY_LOOPBACK_FAILED)
-
-static int
-bnx2_test_loopback(struct bnx2 *bp)
-{
-	int rc = 0;
-
-	if (!netif_running(bp->dev))
-		return BNX2_LOOPBACK_FAILED;
-
-	bnx2_reset_nic(bp, BNX2_DRV_MSG_CODE_RESET);
-	spin_lock_bh(&bp->phy_lock);
-	bnx2_init_phy(bp, 1);
-	spin_unlock_bh(&bp->phy_lock);
-	if (bnx2_run_loopback(bp, BNX2_MAC_LOOPBACK))
-		rc |= BNX2_MAC_LOOPBACK_FAILED;
-	if (bnx2_run_loopback(bp, BNX2_PHY_LOOPBACK))
-		rc |= BNX2_PHY_LOOPBACK_FAILED;
-	return rc;
-}
-
-#define NVRAM_SIZE 0x200
-#define CRC32_RESIDUAL 0xdebb20e3
-
-static int
-bnx2_test_nvram(struct bnx2 *bp)
-{
-	__be32 buf[NVRAM_SIZE / 4];
-	u8 *data = (u8 *) buf;
-	int rc = 0;
-	u32 magic, csum;
-
-	if ((rc = bnx2_nvram_read(bp, 0, data, 4)) != 0)
-		goto test_nvram_done;
-
-        magic = be32_to_cpu(buf[0]);
-	if (magic != 0x669955aa) {
-		rc = -ENODEV;
-		goto test_nvram_done;
-	}
-
-	if ((rc = bnx2_nvram_read(bp, 0x100, data, NVRAM_SIZE)) != 0)
-		goto test_nvram_done;
-
-	csum = ether_crc_le(0x100, data);
-	if (csum != CRC32_RESIDUAL) {
-		rc = -ENODEV;
-		goto test_nvram_done;
-	}
-
-	csum = ether_crc_le(0x100, data + 0x100);
-	if (csum != CRC32_RESIDUAL) {
-		rc = -ENODEV;
-	}
-
-test_nvram_done:
-	return rc;
-}
-
-static int
-bnx2_test_link(struct bnx2 *bp)
-{
-	u32 bmsr;
-
-	if (!netif_running(bp->dev))
-		return -ENODEV;
-
-	if (bp->phy_flags & BNX2_PHY_FLAG_REMOTE_PHY_CAP) {
-		if (bp->link_up)
-			return 0;
-		return -ENODEV;
-	}
-	spin_lock_bh(&bp->phy_lock);
-	bnx2_enable_bmsr1(bp);
-	bnx2_read_phy(bp, bp->mii_bmsr1, &bmsr);
-	bnx2_read_phy(bp, bp->mii_bmsr1, &bmsr);
-	bnx2_disable_bmsr1(bp);
-	spin_unlock_bh(&bp->phy_lock);
-
-	if (bmsr & BMSR_LSTATUS) {
-		return 0;
-	}
-	return -ENODEV;
-}
-
-static int
-bnx2_test_intr(struct bnx2 *bp)
-{
-	int i;
-	u16 status_idx;
-
-	if (!netif_running(bp->dev))
-		return -ENODEV;
-
-	status_idx = REG_RD(bp, BNX2_PCICFG_INT_ACK_CMD) & 0xffff;
-
-	/* This register is not touched during run-time. */
-	REG_WR(bp, BNX2_HC_COMMAND, bp->hc_cmd | BNX2_HC_COMMAND_COAL_NOW);
-	REG_RD(bp, BNX2_HC_COMMAND);
-
-	for (i = 0; i < 10; i++) {
-		if ((REG_RD(bp, BNX2_PCICFG_INT_ACK_CMD) & 0xffff) !=
-			status_idx) {
-
-			break;
-		}
-
-		msleep_interruptible(10);
-	}
-	if (i < 10)
-		return 0;
-
-	return -ENODEV;
-}
-
-/* Determining link for parallel detection. */
-static int
-bnx2_5706_serdes_has_link(struct bnx2 *bp)
-{
-	u32 mode_ctl, an_dbg, exp;
-
-	if (bp->phy_flags & BNX2_PHY_FLAG_NO_PARALLEL)
-		return 0;
-
-	bnx2_write_phy(bp, MII_BNX2_MISC_SHADOW, MISC_SHDW_MODE_CTL);
-	bnx2_read_phy(bp, MII_BNX2_MISC_SHADOW, &mode_ctl);
-
-	if (!(mode_ctl & MISC_SHDW_MODE_CTL_SIG_DET))
-		return 0;
-
-	bnx2_write_phy(bp, MII_BNX2_MISC_SHADOW, MISC_SHDW_AN_DBG);
-	bnx2_read_phy(bp, MII_BNX2_MISC_SHADOW, &an_dbg);
-	bnx2_read_phy(bp, MII_BNX2_MISC_SHADOW, &an_dbg);
-
-	if (an_dbg & (MISC_SHDW_AN_DBG_NOSYNC | MISC_SHDW_AN_DBG_RUDI_INVALID))
-		return 0;
-
-	bnx2_write_phy(bp, MII_BNX2_DSP_ADDRESS, MII_EXPAND_REG1);
-	bnx2_read_phy(bp, MII_BNX2_DSP_RW_PORT, &exp);
-	bnx2_read_phy(bp, MII_BNX2_DSP_RW_PORT, &exp);
-
-	if (exp & MII_EXPAND_REG1_RUDI_C)	/* receiving CONFIG */
-		return 0;
-
-	return 1;
-}
-
-static void
-bnx2_5706_serdes_timer(struct bnx2 *bp)
-{
-	int check_link = 1;
-
-	spin_lock(&bp->phy_lock);
-	if (bp->serdes_an_pending) {
-		bp->serdes_an_pending--;
-		check_link = 0;
-	} else if ((bp->link_up == 0) && (bp->autoneg & AUTONEG_SPEED)) {
-		u32 bmcr;
-
-		bp->current_interval = BNX2_TIMER_INTERVAL;
-
-		bnx2_read_phy(bp, bp->mii_bmcr, &bmcr);
-
-		if (bmcr & BMCR_ANENABLE) {
-			if (bnx2_5706_serdes_has_link(bp)) {
-				bmcr &= ~BMCR_ANENABLE;
-				bmcr |= BMCR_SPEED1000 | BMCR_FULLDPLX;
-				bnx2_write_phy(bp, bp->mii_bmcr, bmcr);
-				bp->phy_flags |= BNX2_PHY_FLAG_PARALLEL_DETECT;
-			}
-		}
-	}
-	else if ((bp->link_up) && (bp->autoneg & AUTONEG_SPEED) &&
-		 (bp->phy_flags & BNX2_PHY_FLAG_PARALLEL_DETECT)) {
-		u32 phy2;
-
-		bnx2_write_phy(bp, 0x17, 0x0f01);
-		bnx2_read_phy(bp, 0x15, &phy2);
-		if (phy2 & 0x20) {
-			u32 bmcr;
-
-			bnx2_read_phy(bp, bp->mii_bmcr, &bmcr);
-			bmcr |= BMCR_ANENABLE;
-			bnx2_write_phy(bp, bp->mii_bmcr, bmcr);
-
-			bp->phy_flags &= ~BNX2_PHY_FLAG_PARALLEL_DETECT;
-		}
-	} else
-		bp->current_interval = BNX2_TIMER_INTERVAL;
-
-	if (check_link) {
-		u32 val;
-
-		bnx2_write_phy(bp, MII_BNX2_MISC_SHADOW, MISC_SHDW_AN_DBG);
-		bnx2_read_phy(bp, MII_BNX2_MISC_SHADOW, &val);
-		bnx2_read_phy(bp, MII_BNX2_MISC_SHADOW, &val);
-
-		if (bp->link_up && (val & MISC_SHDW_AN_DBG_NOSYNC)) {
-			if (!(bp->phy_flags & BNX2_PHY_FLAG_FORCED_DOWN)) {
-				bnx2_5706s_force_link_dn(bp, 1);
-				bp->phy_flags |= BNX2_PHY_FLAG_FORCED_DOWN;
-			} else
-				bnx2_set_link(bp);
-		} else if (!bp->link_up && !(val & MISC_SHDW_AN_DBG_NOSYNC))
-			bnx2_set_link(bp);
-	}
-	spin_unlock(&bp->phy_lock);
-}
-
-static void
-bnx2_5708_serdes_timer(struct bnx2 *bp)
-{
-	if (bp->phy_flags & BNX2_PHY_FLAG_REMOTE_PHY_CAP)
-		return;
-
-	if ((bp->phy_flags & BNX2_PHY_FLAG_2_5G_CAPABLE) == 0) {
-		bp->serdes_an_pending = 0;
-		return;
-	}
-
-	spin_lock(&bp->phy_lock);
-	if (bp->serdes_an_pending)
-		bp->serdes_an_pending--;
-	else if ((bp->link_up == 0) && (bp->autoneg & AUTONEG_SPEED)) {
-		u32 bmcr;
-
-		bnx2_read_phy(bp, bp->mii_bmcr, &bmcr);
-		if (bmcr & BMCR_ANENABLE) {
-			bnx2_enable_forced_2g5(bp);
-			bp->current_interval = BNX2_SERDES_FORCED_TIMEOUT;
-		} else {
-			bnx2_disable_forced_2g5(bp);
-			bp->serdes_an_pending = 2;
-			bp->current_interval = BNX2_TIMER_INTERVAL;
-		}
-
-	} else
-		bp->current_interval = BNX2_TIMER_INTERVAL;
-
-	spin_unlock(&bp->phy_lock);
-}
-
-static void
-bnx2_timer(unsigned long data)
-{
-	struct bnx2 *bp = (struct bnx2 *) data;
-
-	if (!netif_running(bp->dev))
-		return;
-
-	if (atomic_read(&bp->intr_sem) != 0)
-		goto bnx2_restart_timer;
-
-	if ((bp->flags & (BNX2_FLAG_USING_MSI | BNX2_FLAG_ONE_SHOT_MSI)) ==
-	     BNX2_FLAG_USING_MSI)
-		bnx2_chk_missed_msi(bp);
-
-	bnx2_send_heart_beat(bp);
-
-	bp->stats_blk->stat_FwRxDrop =
-		bnx2_reg_rd_ind(bp, BNX2_FW_RX_DROP_COUNT);
-
-	/* workaround occasional corrupted counters */
-	if ((bp->flags & BNX2_FLAG_BROKEN_STATS) && bp->stats_ticks)
-		REG_WR(bp, BNX2_HC_COMMAND, bp->hc_cmd |
-					    BNX2_HC_COMMAND_STATS_NOW);
-
-	if (bp->phy_flags & BNX2_PHY_FLAG_SERDES) {
-		if (CHIP_NUM(bp) == CHIP_NUM_5706)
-			bnx2_5706_serdes_timer(bp);
-		else
-			bnx2_5708_serdes_timer(bp);
-	}
-
-bnx2_restart_timer:
-	mod_timer(&bp->timer, jiffies + bp->current_interval);
-}
-
-static int
-bnx2_request_irq(struct bnx2 *bp)
-{
-	unsigned long flags;
-	struct bnx2_irq *irq;
-	int rc = 0, i;
-
-	if (bp->flags & BNX2_FLAG_USING_MSI_OR_MSIX)
-		flags = 0;
-	else
-		flags = IRQF_SHARED;
-
-	if (entropy)
-		flags |= IRQF_SAMPLE_RANDOM;
-
-	for (i = 0; i < bp->irq_nvecs; i++) {
-		irq = &bp->irq_tbl[i];
-		rc = request_irq(irq->vector, irq->handler, flags, irq->name,
-				 &bp->bnx2_napi[i]);
-		if (rc)
-			break;
-		irq->requested = 1;
-	}
-	return rc;
-}
-
-static void
-bnx2_free_irq(struct bnx2 *bp)
-{
-	struct bnx2_irq *irq;
-	int i;
-
-	for (i = 0; i < bp->irq_nvecs; i++) {
-		irq = &bp->irq_tbl[i];
-		if (irq->requested)
-			free_irq(irq->vector, &bp->bnx2_napi[i]);
-		irq->requested = 0;
-	}
-	if (bp->flags & BNX2_FLAG_USING_MSI)
-		pci_disable_msi(bp->pdev);
-	else if (bp->flags & BNX2_FLAG_USING_MSIX)
-		pci_disable_msix(bp->pdev);
-
-	bp->flags &= ~(BNX2_FLAG_USING_MSI_OR_MSIX | BNX2_FLAG_ONE_SHOT_MSI);
-}
-
-static void
-bnx2_enable_msix(struct bnx2 *bp, int msix_vecs)
-{
-	int i, rc;
-	struct msix_entry msix_ent[BNX2_MAX_MSIX_VEC];
-	struct net_device *dev = bp->dev;
-	const int len = sizeof(bp->irq_tbl[0].name);
-
-	bnx2_setup_msix_tbl(bp);
-	REG_WR(bp, BNX2_PCI_MSIX_CONTROL, BNX2_MAX_MSIX_HW_VEC - 1);
-	REG_WR(bp, BNX2_PCI_MSIX_TBL_OFF_BIR, BNX2_PCI_GRC_WINDOW2_BASE);
-	REG_WR(bp, BNX2_PCI_MSIX_PBA_OFF_BIT, BNX2_PCI_GRC_WINDOW3_BASE);
-
-	/*  Need to flush the previous three writes to ensure MSI-X
-	 *  is setup properly */
-	REG_RD(bp, BNX2_PCI_MSIX_CONTROL);
-
-	for (i = 0; i < BNX2_MAX_MSIX_VEC; i++) {
-		msix_ent[i].entry = i;
-		msix_ent[i].vector = 0;
-	}
-
-	rc = pci_enable_msix(bp->pdev, msix_ent, BNX2_MAX_MSIX_VEC);
-	if (rc != 0)
-		return;
-
-	bp->irq_nvecs = msix_vecs;
-	bp->flags |= BNX2_FLAG_USING_MSIX | BNX2_FLAG_ONE_SHOT_MSI;
-	for (i = 0; i < BNX2_MAX_MSIX_VEC; i++) {
-		bp->irq_tbl[i].vector = msix_ent[i].vector;
-		snprintf(bp->irq_tbl[i].name, len, "%s-%d", dev->name, i);
-		bp->irq_tbl[i].handler = bnx2_msi_1shot;
-	}
-}
-
-static void
-bnx2_setup_int_mode(struct bnx2 *bp, int dis_msi)
-{
-	int cpus = num_online_cpus();
-	int msix_vecs = min(cpus + 1, RX_MAX_RINGS);
-
-	bp->irq_tbl[0].handler = bnx2_interrupt;
-	strcpy(bp->irq_tbl[0].name, bp->dev->name);
-	bp->irq_nvecs = 1;
-	bp->irq_tbl[0].vector = bp->pdev->irq;
-
-	if ((bp->flags & BNX2_FLAG_MSIX_CAP) && !dis_msi && cpus > 1)
-		bnx2_enable_msix(bp, msix_vecs);
-
-	if ((bp->flags & BNX2_FLAG_MSI_CAP) && !dis_msi &&
-	    !(bp->flags & BNX2_FLAG_USING_MSIX)) {
-		if (pci_enable_msi(bp->pdev) == 0) {
-			bp->flags |= BNX2_FLAG_USING_MSI;
-			if (CHIP_NUM(bp) == CHIP_NUM_5709) {
-				bp->flags |= BNX2_FLAG_ONE_SHOT_MSI;
-				bp->irq_tbl[0].handler = bnx2_msi_1shot;
-			} else
-				bp->irq_tbl[0].handler = bnx2_msi;
-
-			bp->irq_tbl[0].vector = bp->pdev->irq;
-		}
-	}
-
-	bp->num_tx_rings = rounddown_pow_of_two(bp->irq_nvecs);
-	bp->dev->real_num_tx_queues = bp->num_tx_rings;
-
-	bp->num_rx_rings = bp->irq_nvecs;
-}
-
-/* Called with rtnl_lock */
-static int
-bnx2_open(struct net_device *dev)
-{
-	struct bnx2 *bp = netdev_priv(dev);
-	int rc;
-
-	netif_carrier_off(dev);
-
-	bnx2_set_power_state(bp, PCI_D0);
-	bnx2_disable_int(bp);
-
-	bnx2_setup_int_mode(bp, disable_msi);
-	bnx2_napi_enable(bp);
-	rc = bnx2_alloc_mem(bp);
-	if (rc)
-		goto open_err;
-
-	rc = bnx2_request_irq(bp);
-	if (rc)
-		goto open_err;
-
-	rc = bnx2_init_nic(bp, 1);
-	if (rc)
-		goto open_err;
-
-	mod_timer(&bp->timer, jiffies + bp->current_interval);
-
-	atomic_set(&bp->intr_sem, 0);
-
-	bnx2_enable_int(bp);
-
-	if (bp->flags & BNX2_FLAG_USING_MSI) {
-		/* Test MSI to make sure it is working
-		 * If MSI test fails, go back to INTx mode
-		 */
-		if (bnx2_test_intr(bp) != 0) {
-			printk(KERN_WARNING PFX "%s: No interrupt was generated"
-			       " using MSI, switching to INTx mode. Please"
-			       " report this failure to the PCI maintainer"
-			       " and include system chipset information.\n",
-			       bp->dev->name);
-
-			bnx2_disable_int(bp);
-			bnx2_free_irq(bp);
-
-			bnx2_setup_int_mode(bp, 1);
-
-			rc = bnx2_init_nic(bp, 0);
-
-			if (!rc)
-				rc = bnx2_request_irq(bp);
-
-			if (rc) {
-				del_timer_sync(&bp->timer);
-				goto open_err;
-			}
-			bnx2_enable_int(bp);
-		}
-	}
-	if (bp->flags & BNX2_FLAG_USING_MSI)
-		printk(KERN_INFO PFX "%s: using MSI\n", dev->name);
-	else if (bp->flags & BNX2_FLAG_USING_MSIX)
-		printk(KERN_INFO PFX "%s: using MSIX\n", dev->name);
-
-	netif_tx_start_all_queues(dev);
-
-	return 0;
-
-open_err:
-	bnx2_napi_disable(bp);
-	bnx2_free_skbs(bp);
-	bnx2_free_irq(bp);
-	bnx2_free_mem(bp);
-	return rc;
-}
-
-static void
-bnx2_reset_task(struct work_struct *work)
-{
-	struct bnx2 *bp = container_of(work, struct bnx2, reset_task);
-
-	rtnl_lock();
-	if (!netif_running(bp->dev)) {
-		rtnl_unlock();
-		return;
-	}
-
-	bnx2_netif_stop(bp);
-
-	bnx2_init_nic(bp, 1);
-
-	atomic_set(&bp->intr_sem, 1);
-	bnx2_netif_start(bp);
-	rtnl_unlock();
-}
-
-static void
-bnx2_dump_state(struct bnx2 *bp)
-{
-	struct net_device *dev = bp->dev;
-
-	printk(KERN_ERR PFX "%s DEBUG: intr_sem[%x]\n", dev->name,
-		atomic_read(&bp->intr_sem));
-	printk(KERN_ERR PFX "%s DEBUG: EMAC_TX_STATUS[%08x] "
-			    "RPM_MGMT_PKT_CTRL[%08x]\n", dev->name,
-		REG_RD(bp, BNX2_EMAC_TX_STATUS),
-		REG_RD(bp, BNX2_RPM_MGMT_PKT_CTRL));
-	printk(KERN_ERR PFX "%s DEBUG: MCP_STATE_P0[%08x] MCP_STATE_P1[%08x]\n",
-		dev->name, bnx2_reg_rd_ind(bp, BNX2_MCP_STATE_P0),
-		bnx2_reg_rd_ind(bp, BNX2_MCP_STATE_P1));
-	printk(KERN_ERR PFX "%s DEBUG: HC_STATS_INTERRUPT_STATUS[%08x]\n",
-		dev->name, REG_RD(bp, BNX2_HC_STATS_INTERRUPT_STATUS));
-	if (bp->flags & BNX2_FLAG_USING_MSIX)
-		printk(KERN_ERR PFX "%s DEBUG: PBA[%08x]\n", dev->name,
-			REG_RD(bp, BNX2_PCI_GRC_WINDOW3_BASE));
-}
-
-static void
-bnx2_tx_timeout(struct net_device *dev)
-{
-	struct bnx2 *bp = netdev_priv(dev);
-
-	bnx2_dump_state(bp);
-
-	/* This allows the netif to be shutdown gracefully before resetting */
-	schedule_work(&bp->reset_task);
-}
-
-#ifdef BCM_VLAN
-/* Called with rtnl_lock */
-static void
-bnx2_vlan_rx_register(struct net_device *dev, struct vlan_group *vlgrp)
-{
-	struct bnx2 *bp = netdev_priv(dev);
-
-	if (netif_running(dev))
-		bnx2_netif_stop(bp);
-
-	bp->vlgrp = vlgrp;
-
-	if (!netif_running(dev))
-		return;
-
-	bnx2_set_rx_mode(dev);
-	if (bp->flags & BNX2_FLAG_CAN_KEEP_VLAN)
-		bnx2_fw_sync(bp, BNX2_DRV_MSG_CODE_KEEP_VLAN_UPDATE, 0, 1);
-
-	bnx2_netif_start(bp);
-}
-#endif
-
-/* Called with netif_tx_lock.
- * bnx2_tx_int() runs without netif_tx_lock unless it needs to call
- * netif_wake_queue().
- */
-static netdev_tx_t
-bnx2_start_xmit(struct sk_buff *skb, struct net_device *dev)
-{
-	struct bnx2 *bp = netdev_priv(dev);
-	dma_addr_t mapping;
-	struct tx_bd *txbd;
-	struct sw_tx_bd *tx_buf;
-	u32 len, vlan_tag_flags, last_frag, mss;
-	u16 prod, ring_prod;
-	int i;
-	struct bnx2_napi *bnapi;
-	struct bnx2_tx_ring_info *txr;
-	struct netdev_queue *txq;
-
-	/*  Determine which tx ring we will be placed on */
-	i = skb_get_queue_mapping(skb);
-	bnapi = &bp->bnx2_napi[i];
-	txr = &bnapi->tx_ring;
-	txq = netdev_get_tx_queue(dev, i);
-
-	if (unlikely(bnx2_tx_avail(bp, txr) <
-	    (skb_shinfo(skb)->nr_frags + 1))) {
-		netif_tx_stop_queue(txq);
-		printk(KERN_ERR PFX "%s: BUG! Tx ring full when queue awake!\n",
-			dev->name);
-
-		return NETDEV_TX_BUSY;
-	}
-	len = skb_headlen(skb);
-	prod = txr->tx_prod;
-	ring_prod = TX_RING_IDX(prod);
-
-	vlan_tag_flags = 0;
-	if (skb->ip_summed == CHECKSUM_PARTIAL) {
-		vlan_tag_flags |= TX_BD_FLAGS_TCP_UDP_CKSUM;
-	}
-
-#ifdef BCM_VLAN
-	if (bp->vlgrp && vlan_tx_tag_present(skb)) {
-		vlan_tag_flags |=
-			(TX_BD_FLAGS_VLAN_TAG | (vlan_tx_tag_get(skb) << 16));
-	}
-#endif
-	if ((mss = skb_shinfo(skb)->gso_size)) {
-		u32 tcp_opt_len;
-		struct iphdr *iph;
-
-		vlan_tag_flags |= TX_BD_FLAGS_SW_LSO;
-
-		tcp_opt_len = tcp_optlen(skb);
-
-		if (skb_shinfo(skb)->gso_type & SKB_GSO_TCPV6) {
-			u32 tcp_off = skb_transport_offset(skb) -
-				      sizeof(struct ipv6hdr) - ETH_HLEN;
-
-			vlan_tag_flags |= ((tcp_opt_len >> 2) << 8) |
-					  TX_BD_FLAGS_SW_FLAGS;
-			if (likely(tcp_off == 0))
-				vlan_tag_flags &= ~TX_BD_FLAGS_TCP6_OFF0_MSK;
-			else {
-				tcp_off >>= 3;
-				vlan_tag_flags |= ((tcp_off & 0x3) <<
-						   TX_BD_FLAGS_TCP6_OFF0_SHL) |
-						  ((tcp_off & 0x10) <<
-						   TX_BD_FLAGS_TCP6_OFF4_SHL);
-				mss |= (tcp_off & 0xc) << TX_BD_TCP6_OFF2_SHL;
-			}
-		} else {
-			iph = ip_hdr(skb);
-			if (tcp_opt_len || (iph->ihl > 5)) {
-				vlan_tag_flags |= ((iph->ihl - 5) +
-						   (tcp_opt_len >> 2)) << 8;
-			}
-		}
-	} else
-		mss = 0;
-
-	mapping = pci_map_single(bp->pdev, skb->data, len, PCI_DMA_TODEVICE);
-	if (pci_dma_mapping_error(bp->pdev, mapping)) {
-		dev_kfree_skb(skb);
-		return NETDEV_TX_OK;
-	}
-
-	tx_buf = &txr->tx_buf_ring[ring_prod];
-	tx_buf->skb = skb;
-	pci_unmap_addr_set(tx_buf, mapping, mapping);
-
-	txbd = &txr->tx_desc_ring[ring_prod];
-
-	txbd->tx_bd_haddr_hi = (u64) mapping >> 32;
-	txbd->tx_bd_haddr_lo = (u64) mapping & 0xffffffff;
-	txbd->tx_bd_mss_nbytes = len | (mss << 16);
-	txbd->tx_bd_vlan_tag_flags = vlan_tag_flags | TX_BD_FLAGS_START;
-
-	last_frag = skb_shinfo(skb)->nr_frags;
-	tx_buf->nr_frags = last_frag;
-	tx_buf->is_gso = skb_is_gso(skb);
-
-	for (i = 0; i < last_frag; i++) {
-		skb_frag_t *frag = &skb_shinfo(skb)->frags[i];
-
-		prod = NEXT_TX_BD(prod);
-		ring_prod = TX_RING_IDX(prod);
-		txbd = &txr->tx_desc_ring[ring_prod];
-
-		len = frag->size;
-		mapping = pci_map_page(bp->pdev, frag->page, frag->page_offset,
-			len, PCI_DMA_TODEVICE);
-		if (pci_dma_mapping_error(bp->pdev, mapping))
-			goto dma_error;
-		pci_unmap_addr_set(&txr->tx_buf_ring[ring_prod], mapping,
-				   mapping);
-
-		txbd->tx_bd_haddr_hi = (u64) mapping >> 32;
-		txbd->tx_bd_haddr_lo = (u64) mapping & 0xffffffff;
-		txbd->tx_bd_mss_nbytes = len | (mss << 16);
-		txbd->tx_bd_vlan_tag_flags = vlan_tag_flags;
-
-	}
-	txbd->tx_bd_vlan_tag_flags |= TX_BD_FLAGS_END;
-
-	prod = NEXT_TX_BD(prod);
-	txr->tx_prod_bseq += skb->len;
-
-	REG_WR16(bp, txr->tx_bidx_addr, prod);
-	REG_WR(bp, txr->tx_bseq_addr, txr->tx_prod_bseq);
-
-	mmiowb();
-
-	txr->tx_prod = prod;
-
-	if (unlikely(bnx2_tx_avail(bp, txr) <= MAX_SKB_FRAGS)) {
-		netif_tx_stop_queue(txq);
-		if (bnx2_tx_avail(bp, txr) > bp->tx_wake_thresh)
-			netif_tx_wake_queue(txq);
-	}
-
-	return NETDEV_TX_OK;
-dma_error:
-	/* save value of frag that failed */
-	last_frag = i;
-
-	/* start back at beginning and unmap skb */
-	prod = txr->tx_prod;
-	ring_prod = TX_RING_IDX(prod);
-	tx_buf = &txr->tx_buf_ring[ring_prod];
-	tx_buf->skb = NULL;
-	pci_unmap_single(bp->pdev, pci_unmap_addr(tx_buf, mapping),
-			 skb_headlen(skb), PCI_DMA_TODEVICE);
-
-	/* unmap remaining mapped pages */
-	for (i = 0; i < last_frag; i++) {
-		prod = NEXT_TX_BD(prod);
-		ring_prod = TX_RING_IDX(prod);
-		tx_buf = &txr->tx_buf_ring[ring_prod];
-		pci_unmap_page(bp->pdev, pci_unmap_addr(tx_buf, mapping),
-			       skb_shinfo(skb)->frags[i].size,
-			       PCI_DMA_TODEVICE);
-	}
-
-	dev_kfree_skb(skb);
-	return NETDEV_TX_OK;
-}
-
-/* Called with rtnl_lock */
-static int
-bnx2_close(struct net_device *dev)
-{
-	struct bnx2 *bp = netdev_priv(dev);
-
-	cancel_work_sync(&bp->reset_task);
-
-	bnx2_disable_int_sync(bp);
-	bnx2_napi_disable(bp);
-	del_timer_sync(&bp->timer);
-	bnx2_shutdown_chip(bp);
-	bnx2_free_irq(bp);
-	bnx2_free_skbs(bp);
-	bnx2_free_mem(bp);
-	bp->link_up = 0;
-	netif_carrier_off(bp->dev);
-	bnx2_set_power_state(bp, PCI_D3hot);
-	return 0;
-}
-
-#define GET_NET_STATS64(ctr)					\
-	(unsigned long) ((unsigned long) (ctr##_hi) << 32) +	\
-	(unsigned long) (ctr##_lo)
-
-#define GET_NET_STATS32(ctr)		\
-	(ctr##_lo)
-
-#if (BITS_PER_LONG == 64)
-#define GET_NET_STATS	GET_NET_STATS64
-#else
-#define GET_NET_STATS	GET_NET_STATS32
-#endif
-
-static struct net_device_stats *
-bnx2_get_stats(struct net_device *dev)
-{
-	struct bnx2 *bp = netdev_priv(dev);
-	struct statistics_block *stats_blk = bp->stats_blk;
-	struct net_device_stats *net_stats = &dev->stats;
-
-	if (bp->stats_blk == NULL) {
-		return net_stats;
-	}
-	net_stats->rx_packets =
-		GET_NET_STATS(stats_blk->stat_IfHCInUcastPkts) +
-		GET_NET_STATS(stats_blk->stat_IfHCInMulticastPkts) +
-		GET_NET_STATS(stats_blk->stat_IfHCInBroadcastPkts);
-
-	net_stats->tx_packets =
-		GET_NET_STATS(stats_blk->stat_IfHCOutUcastPkts) +
-		GET_NET_STATS(stats_blk->stat_IfHCOutMulticastPkts) +
-		GET_NET_STATS(stats_blk->stat_IfHCOutBroadcastPkts);
-
-	net_stats->rx_bytes =
-		GET_NET_STATS(stats_blk->stat_IfHCInOctets);
-
-	net_stats->tx_bytes =
-		GET_NET_STATS(stats_blk->stat_IfHCOutOctets);
-
-	net_stats->multicast =
-		GET_NET_STATS(stats_blk->stat_IfHCOutMulticastPkts);
-
-	net_stats->collisions =
-		(unsigned long) stats_blk->stat_EtherStatsCollisions;
-
-	net_stats->rx_length_errors =
-		(unsigned long) (stats_blk->stat_EtherStatsUndersizePkts +
-		stats_blk->stat_EtherStatsOverrsizePkts);
-
-	net_stats->rx_over_errors =
-		(unsigned long) (stats_blk->stat_IfInFTQDiscards +
-		stats_blk->stat_IfInMBUFDiscards);
-
-	net_stats->rx_frame_errors =
-		(unsigned long) stats_blk->stat_Dot3StatsAlignmentErrors;
-
-	net_stats->rx_crc_errors =
-		(unsigned long) stats_blk->stat_Dot3StatsFCSErrors;
-
-	net_stats->rx_errors = net_stats->rx_length_errors +
-		net_stats->rx_over_errors + net_stats->rx_frame_errors +
-		net_stats->rx_crc_errors;
-
-	net_stats->tx_aborted_errors =
-    		(unsigned long) (stats_blk->stat_Dot3StatsExcessiveCollisions +
-		stats_blk->stat_Dot3StatsLateCollisions);
-
-	if ((CHIP_NUM(bp) == CHIP_NUM_5706) ||
-	    (CHIP_ID(bp) == CHIP_ID_5708_A0))
-		net_stats->tx_carrier_errors = 0;
-	else {
-		net_stats->tx_carrier_errors =
-			(unsigned long)
-			stats_blk->stat_Dot3StatsCarrierSenseErrors;
-	}
-
-	net_stats->tx_errors =
-    		(unsigned long)
-		stats_blk->stat_emac_tx_stat_dot3statsinternalmactransmiterrors
-		+
-		net_stats->tx_aborted_errors +
-		net_stats->tx_carrier_errors;
-
-	net_stats->rx_missed_errors =
-		(unsigned long) (stats_blk->stat_IfInFTQDiscards +
-		stats_blk->stat_IfInMBUFDiscards + stats_blk->stat_FwRxDrop);
-
-	return net_stats;
-}
-
-/* All ethtool functions called with rtnl_lock */
-
-static int
-bnx2_get_settings(struct net_device *dev, struct ethtool_cmd *cmd)
-{
-	struct bnx2 *bp = netdev_priv(dev);
-	int support_serdes = 0, support_copper = 0;
-
-	cmd->supported = SUPPORTED_Autoneg;
-	if (bp->phy_flags & BNX2_PHY_FLAG_REMOTE_PHY_CAP) {
-		support_serdes = 1;
-		support_copper = 1;
-	} else if (bp->phy_port == PORT_FIBRE)
-		support_serdes = 1;
-	else
-		support_copper = 1;
-
-	if (support_serdes) {
-		cmd->supported |= SUPPORTED_1000baseT_Full |
-			SUPPORTED_FIBRE;
-		if (bp->phy_flags & BNX2_PHY_FLAG_2_5G_CAPABLE)
-			cmd->supported |= SUPPORTED_2500baseX_Full;
-
-	}
-	if (support_copper) {
-		cmd->supported |= SUPPORTED_10baseT_Half |
-			SUPPORTED_10baseT_Full |
-			SUPPORTED_100baseT_Half |
-			SUPPORTED_100baseT_Full |
-			SUPPORTED_1000baseT_Full |
-			SUPPORTED_TP;
-
-	}
-
-	spin_lock_bh(&bp->phy_lock);
-	cmd->port = bp->phy_port;
-	cmd->advertising = bp->advertising;
-
-	if (bp->autoneg & AUTONEG_SPEED) {
-		cmd->autoneg = AUTONEG_ENABLE;
-	}
-	else {
-		cmd->autoneg = AUTONEG_DISABLE;
-	}
-
-	if (netif_carrier_ok(dev)) {
-		cmd->speed = bp->line_speed;
-		cmd->duplex = bp->duplex;
-	}
-	else {
-		cmd->speed = -1;
-		cmd->duplex = -1;
-	}
-	spin_unlock_bh(&bp->phy_lock);
-
-	cmd->transceiver = XCVR_INTERNAL;
-	cmd->phy_address = bp->phy_addr;
-
-	return 0;
-}
-
-static int
-bnx2_set_settings(struct net_device *dev, struct ethtool_cmd *cmd)
-{
-	struct bnx2 *bp = netdev_priv(dev);
-	u8 autoneg = bp->autoneg;
-	u8 req_duplex = bp->req_duplex;
-	u16 req_line_speed = bp->req_line_speed;
-	u32 advertising = bp->advertising;
-	int err = -EINVAL;
-
-	spin_lock_bh(&bp->phy_lock);
-
-	if (cmd->port != PORT_TP && cmd->port != PORT_FIBRE)
-		goto err_out_unlock;
-
-	if (cmd->port != bp->phy_port &&
-	    !(bp->phy_flags & BNX2_PHY_FLAG_REMOTE_PHY_CAP))
-		goto err_out_unlock;
-
-	/* If device is down, we can store the settings only if the user
-	 * is setting the currently active port.
-	 */
-	if (!netif_running(dev) && cmd->port != bp->phy_port)
-		goto err_out_unlock;
-
-	if (cmd->autoneg == AUTONEG_ENABLE) {
-		autoneg |= AUTONEG_SPEED;
-
-		cmd->advertising &= ETHTOOL_ALL_COPPER_SPEED;
-
-		/* allow advertising 1 speed */
-		if ((cmd->advertising == ADVERTISED_10baseT_Half) ||
-			(cmd->advertising == ADVERTISED_10baseT_Full) ||
-			(cmd->advertising == ADVERTISED_100baseT_Half) ||
-			(cmd->advertising == ADVERTISED_100baseT_Full)) {
-
-			if (cmd->port == PORT_FIBRE)
-				goto err_out_unlock;
-
-			advertising = cmd->advertising;
-
-		} else if (cmd->advertising == ADVERTISED_2500baseX_Full) {
-			if (!(bp->phy_flags & BNX2_PHY_FLAG_2_5G_CAPABLE) ||
-			    (cmd->port == PORT_TP))
-				goto err_out_unlock;
-		} else if (cmd->advertising == ADVERTISED_1000baseT_Full)
-			advertising = cmd->advertising;
-		else if (cmd->advertising == ADVERTISED_1000baseT_Half)
-			goto err_out_unlock;
-		else {
-			if (cmd->port == PORT_FIBRE)
-				advertising = ETHTOOL_ALL_FIBRE_SPEED;
-			else
-				advertising = ETHTOOL_ALL_COPPER_SPEED;
-		}
-		advertising |= ADVERTISED_Autoneg;
-	}
-	else {
-		if (cmd->port == PORT_FIBRE) {
-			if ((cmd->speed != SPEED_1000 &&
-			     cmd->speed != SPEED_2500) ||
-			    (cmd->duplex != DUPLEX_FULL))
-				goto err_out_unlock;
-
-			if (cmd->speed == SPEED_2500 &&
-			    !(bp->phy_flags & BNX2_PHY_FLAG_2_5G_CAPABLE))
-				goto err_out_unlock;
-		}
-		else if (cmd->speed == SPEED_1000 || cmd->speed == SPEED_2500)
-			goto err_out_unlock;
-
-		autoneg &= ~AUTONEG_SPEED;
-		req_line_speed = cmd->speed;
-		req_duplex = cmd->duplex;
-		advertising = 0;
-	}
-
-	bp->autoneg = autoneg;
-	bp->advertising = advertising;
-	bp->req_line_speed = req_line_speed;
-	bp->req_duplex = req_duplex;
-
-	err = 0;
-	/* If device is down, the new settings will be picked up when it is
-	 * brought up.
-	 */
-	if (netif_running(dev))
-		err = bnx2_setup_phy(bp, cmd->port);
-
-err_out_unlock:
-	spin_unlock_bh(&bp->phy_lock);
-
-	return err;
-}
-
-static void
-bnx2_get_drvinfo(struct net_device *dev, struct ethtool_drvinfo *info)
-{
-	struct bnx2 *bp = netdev_priv(dev);
-
-	strcpy(info->driver, DRV_MODULE_NAME);
-	strcpy(info->version, DRV_MODULE_VERSION);
-	strcpy(info->bus_info, pci_name(bp->pdev));
-	strcpy(info->fw_version, bp->fw_version);
-}
-
-#define BNX2_REGDUMP_LEN		(32 * 1024)
-
-static int
-bnx2_get_regs_len(struct net_device *dev)
-{
-	return BNX2_REGDUMP_LEN;
-}
-
-static void
-bnx2_get_regs(struct net_device *dev, struct ethtool_regs *regs, void *_p)
-{
-	u32 *p = _p, i, offset;
-	u8 *orig_p = _p;
-	struct bnx2 *bp = netdev_priv(dev);
-	u32 reg_boundaries[] = { 0x0000, 0x0098, 0x0400, 0x045c,
-				 0x0800, 0x0880, 0x0c00, 0x0c10,
-				 0x0c30, 0x0d08, 0x1000, 0x101c,
-				 0x1040, 0x1048, 0x1080, 0x10a4,
-				 0x1400, 0x1490, 0x1498, 0x14f0,
-				 0x1500, 0x155c, 0x1580, 0x15dc,
-				 0x1600, 0x1658, 0x1680, 0x16d8,
-				 0x1800, 0x1820, 0x1840, 0x1854,
-				 0x1880, 0x1894, 0x1900, 0x1984,
-				 0x1c00, 0x1c0c, 0x1c40, 0x1c54,
-				 0x1c80, 0x1c94, 0x1d00, 0x1d84,
-				 0x2000, 0x2030, 0x23c0, 0x2400,
-				 0x2800, 0x2820, 0x2830, 0x2850,
-				 0x2b40, 0x2c10, 0x2fc0, 0x3058,
-				 0x3c00, 0x3c94, 0x4000, 0x4010,
-				 0x4080, 0x4090, 0x43c0, 0x4458,
-				 0x4c00, 0x4c18, 0x4c40, 0x4c54,
-				 0x4fc0, 0x5010, 0x53c0, 0x5444,
-				 0x5c00, 0x5c18, 0x5c80, 0x5c90,
-				 0x5fc0, 0x6000, 0x6400, 0x6428,
-				 0x6800, 0x6848, 0x684c, 0x6860,
-				 0x6888, 0x6910, 0x8000 };
-
-	regs->version = 0;
-
-	memset(p, 0, BNX2_REGDUMP_LEN);
-
-	if (!netif_running(bp->dev))
-		return;
-
-	i = 0;
-	offset = reg_boundaries[0];
-	p += offset;
-	while (offset < BNX2_REGDUMP_LEN) {
-		*p++ = REG_RD(bp, offset);
-		offset += 4;
-		if (offset == reg_boundaries[i + 1]) {
-			offset = reg_boundaries[i + 2];
-			p = (u32 *) (orig_p + offset);
-			i += 2;
-		}
-	}
-}
-
-static void
-bnx2_get_wol(struct net_device *dev, struct ethtool_wolinfo *wol)
-{
-	struct bnx2 *bp = netdev_priv(dev);
-
-	if (bp->flags & BNX2_FLAG_NO_WOL) {
-		wol->supported = 0;
-		wol->wolopts = 0;
-	}
-	else {
-		wol->supported = WAKE_MAGIC;
-		if (bp->wol)
-			wol->wolopts = WAKE_MAGIC;
-		else
-			wol->wolopts = 0;
-	}
-	memset(&wol->sopass, 0, sizeof(wol->sopass));
-}
-
-static int
-bnx2_set_wol(struct net_device *dev, struct ethtool_wolinfo *wol)
-{
-	struct bnx2 *bp = netdev_priv(dev);
-
-	if (wol->wolopts & ~WAKE_MAGIC)
-		return -EINVAL;
-
-	if (wol->wolopts & WAKE_MAGIC) {
-		if (bp->flags & BNX2_FLAG_NO_WOL)
-			return -EINVAL;
-
-		bp->wol = 1;
-	}
-	else {
-		bp->wol = 0;
-	}
-	return 0;
-}
-
-static int
-bnx2_nway_reset(struct net_device *dev)
-{
-	struct bnx2 *bp = netdev_priv(dev);
-	u32 bmcr;
-
-	if (!netif_running(dev))
-		return -EAGAIN;
-
-	if (!(bp->autoneg & AUTONEG_SPEED)) {
-		return -EINVAL;
-	}
-
-	spin_lock_bh(&bp->phy_lock);
-
-	if (bp->phy_flags & BNX2_PHY_FLAG_REMOTE_PHY_CAP) {
-		int rc;
-
-		rc = bnx2_setup_remote_phy(bp, bp->phy_port);
-		spin_unlock_bh(&bp->phy_lock);
-		return rc;
-	}
-
-	/* Force a link down visible on the other side */
-	if (bp->phy_flags & BNX2_PHY_FLAG_SERDES) {
-		bnx2_write_phy(bp, bp->mii_bmcr, BMCR_LOOPBACK);
-		spin_unlock_bh(&bp->phy_lock);
-
-		msleep(20);
-
-		spin_lock_bh(&bp->phy_lock);
-
-		bp->current_interval = BNX2_SERDES_AN_TIMEOUT;
-		bp->serdes_an_pending = 1;
-		mod_timer(&bp->timer, jiffies + bp->current_interval);
-	}
-
-	bnx2_read_phy(bp, bp->mii_bmcr, &bmcr);
-	bmcr &= ~BMCR_LOOPBACK;
-	bnx2_write_phy(bp, bp->mii_bmcr, bmcr | BMCR_ANRESTART | BMCR_ANENABLE);
-
-	spin_unlock_bh(&bp->phy_lock);
-
-	return 0;
-}
-
-static u32
-bnx2_get_link(struct net_device *dev)
-{
-	struct bnx2 *bp = netdev_priv(dev);
-
-	return bp->link_up;
-}
-
-static int
-bnx2_get_eeprom_len(struct net_device *dev)
-{
-	struct bnx2 *bp = netdev_priv(dev);
-
-	if (bp->flash_info == NULL)
-		return 0;
-
-	return (int) bp->flash_size;
-}
-
-static int
-bnx2_get_eeprom(struct net_device *dev, struct ethtool_eeprom *eeprom,
-		u8 *eebuf)
-{
-	struct bnx2 *bp = netdev_priv(dev);
-	int rc;
-
-	if (!netif_running(dev))
-		return -EAGAIN;
-
-	/* parameters already validated in ethtool_get_eeprom */
-
-	rc = bnx2_nvram_read(bp, eeprom->offset, eebuf, eeprom->len);
-
-	return rc;
-}
-
-static int
-bnx2_set_eeprom(struct net_device *dev, struct ethtool_eeprom *eeprom,
-		u8 *eebuf)
-{
-	struct bnx2 *bp = netdev_priv(dev);
-	int rc;
-
-	if (!netif_running(dev))
-		return -EAGAIN;
-
-	/* parameters already validated in ethtool_set_eeprom */
-
-	rc = bnx2_nvram_write(bp, eeprom->offset, eebuf, eeprom->len);
-
-	return rc;
-}
-
-static int
-bnx2_get_coalesce(struct net_device *dev, struct ethtool_coalesce *coal)
-{
-	struct bnx2 *bp = netdev_priv(dev);
-
-	memset(coal, 0, sizeof(struct ethtool_coalesce));
-
-	coal->rx_coalesce_usecs = bp->rx_ticks;
-	coal->rx_max_coalesced_frames = bp->rx_quick_cons_trip;
-	coal->rx_coalesce_usecs_irq = bp->rx_ticks_int;
-	coal->rx_max_coalesced_frames_irq = bp->rx_quick_cons_trip_int;
-
-	coal->tx_coalesce_usecs = bp->tx_ticks;
-	coal->tx_max_coalesced_frames = bp->tx_quick_cons_trip;
-	coal->tx_coalesce_usecs_irq = bp->tx_ticks_int;
-	coal->tx_max_coalesced_frames_irq = bp->tx_quick_cons_trip_int;
-
-	coal->stats_block_coalesce_usecs = bp->stats_ticks;
-
-	return 0;
-}
-
-static int
-bnx2_set_coalesce(struct net_device *dev, struct ethtool_coalesce *coal)
-{
-	struct bnx2 *bp = netdev_priv(dev);
-
-	bp->rx_ticks = (u16) coal->rx_coalesce_usecs;
-	if (bp->rx_ticks > 0x3ff) bp->rx_ticks = 0x3ff;
-
-	bp->rx_quick_cons_trip = (u16) coal->rx_max_coalesced_frames;
-	if (bp->rx_quick_cons_trip > 0xff) bp->rx_quick_cons_trip = 0xff;
-
-	bp->rx_ticks_int = (u16) coal->rx_coalesce_usecs_irq;
-	if (bp->rx_ticks_int > 0x3ff) bp->rx_ticks_int = 0x3ff;
-
-	bp->rx_quick_cons_trip_int = (u16) coal->rx_max_coalesced_frames_irq;
-	if (bp->rx_quick_cons_trip_int > 0xff)
-		bp->rx_quick_cons_trip_int = 0xff;
-
-	bp->tx_ticks = (u16) coal->tx_coalesce_usecs;
-	if (bp->tx_ticks > 0x3ff) bp->tx_ticks = 0x3ff;
-
-	bp->tx_quick_cons_trip = (u16) coal->tx_max_coalesced_frames;
-	if (bp->tx_quick_cons_trip > 0xff) bp->tx_quick_cons_trip = 0xff;
-
-	bp->tx_ticks_int = (u16) coal->tx_coalesce_usecs_irq;
-	if (bp->tx_ticks_int > 0x3ff) bp->tx_ticks_int = 0x3ff;
-
-	bp->tx_quick_cons_trip_int = (u16) coal->tx_max_coalesced_frames_irq;
-	if (bp->tx_quick_cons_trip_int > 0xff) bp->tx_quick_cons_trip_int =
-		0xff;
-
-	bp->stats_ticks = coal->stats_block_coalesce_usecs;
-	if (bp->flags & BNX2_FLAG_BROKEN_STATS) {
-		if (bp->stats_ticks != 0 && bp->stats_ticks != USEC_PER_SEC)
-			bp->stats_ticks = USEC_PER_SEC;
-	}
-	if (bp->stats_ticks > BNX2_HC_STATS_TICKS_HC_STAT_TICKS)
-		bp->stats_ticks = BNX2_HC_STATS_TICKS_HC_STAT_TICKS;
-	bp->stats_ticks &= BNX2_HC_STATS_TICKS_HC_STAT_TICKS;
-
-	if (netif_running(bp->dev)) {
-		bnx2_netif_stop(bp);
-		bnx2_init_nic(bp, 0);
-		bnx2_netif_start(bp);
-	}
-
-	return 0;
-}
-
-static void
-bnx2_get_ringparam(struct net_device *dev, struct ethtool_ringparam *ering)
-{
-	struct bnx2 *bp = netdev_priv(dev);
-
-	ering->rx_max_pending = MAX_TOTAL_RX_DESC_CNT;
-	ering->rx_mini_max_pending = 0;
-	ering->rx_jumbo_max_pending = MAX_TOTAL_RX_PG_DESC_CNT;
-
-	ering->rx_pending = bp->rx_ring_size;
-	ering->rx_mini_pending = 0;
-	ering->rx_jumbo_pending = bp->rx_pg_ring_size;
-
-	ering->tx_max_pending = MAX_TX_DESC_CNT;
-	ering->tx_pending = bp->tx_ring_size;
-}
-
-static int
-bnx2_change_ring_size(struct bnx2 *bp, u32 rx, u32 tx)
-{
-	if (netif_running(bp->dev)) {
-		bnx2_netif_stop(bp);
-		bnx2_reset_chip(bp, BNX2_DRV_MSG_CODE_RESET);
-		bnx2_free_skbs(bp);
-		bnx2_free_mem(bp);
-	}
-
-	bnx2_set_rx_ring_size(bp, rx);
-	bp->tx_ring_size = tx;
-
-	if (netif_running(bp->dev)) {
-		int rc;
-
-		rc = bnx2_alloc_mem(bp);
-		if (!rc)
-			rc = bnx2_init_nic(bp, 0);
-
-		if (rc) {
-			bnx2_napi_enable(bp);
-			dev_close(bp->dev);
-			return rc;
-		}
-#ifdef BCM_CNIC
-		mutex_lock(&bp->cnic_lock);
-		/* Let cnic know about the new status block. */
-		if (bp->cnic_eth_dev.drv_state & CNIC_DRV_STATE_REGD)
-			bnx2_setup_cnic_irq_info(bp);
-		mutex_unlock(&bp->cnic_lock);
-#endif
-		bnx2_netif_start(bp);
-	}
-	return 0;
-}
-
-static int
-bnx2_set_ringparam(struct net_device *dev, struct ethtool_ringparam *ering)
-{
-	struct bnx2 *bp = netdev_priv(dev);
-	int rc;
-
-	if ((ering->rx_pending > MAX_TOTAL_RX_DESC_CNT) ||
-		(ering->tx_pending > MAX_TX_DESC_CNT) ||
-		(ering->tx_pending <= MAX_SKB_FRAGS)) {
-
-		return -EINVAL;
-	}
-	rc = bnx2_change_ring_size(bp, ering->rx_pending, ering->tx_pending);
-	return rc;
-}
-
-static void
-bnx2_get_pauseparam(struct net_device *dev, struct ethtool_pauseparam *epause)
-{
-	struct bnx2 *bp = netdev_priv(dev);
-
-	epause->autoneg = ((bp->autoneg & AUTONEG_FLOW_CTRL) != 0);
-	epause->rx_pause = ((bp->flow_ctrl & FLOW_CTRL_RX) != 0);
-	epause->tx_pause = ((bp->flow_ctrl & FLOW_CTRL_TX) != 0);
-}
-
-static int
-bnx2_set_pauseparam(struct net_device *dev, struct ethtool_pauseparam *epause)
-{
-	struct bnx2 *bp = netdev_priv(dev);
-
-	bp->req_flow_ctrl = 0;
-	if (epause->rx_pause)
-		bp->req_flow_ctrl |= FLOW_CTRL_RX;
-	if (epause->tx_pause)
-		bp->req_flow_ctrl |= FLOW_CTRL_TX;
-
-	if (epause->autoneg) {
-		bp->autoneg |= AUTONEG_FLOW_CTRL;
-	}
-	else {
-		bp->autoneg &= ~AUTONEG_FLOW_CTRL;
-	}
-
-	if (netif_running(dev)) {
-		spin_lock_bh(&bp->phy_lock);
-		bnx2_setup_phy(bp, bp->phy_port);
-		spin_unlock_bh(&bp->phy_lock);
-	}
-
-	return 0;
-}
-
-static u32
-bnx2_get_rx_csum(struct net_device *dev)
-{
-	struct bnx2 *bp = netdev_priv(dev);
-
-	return bp->rx_csum;
-}
-
-static int
-bnx2_set_rx_csum(struct net_device *dev, u32 data)
-{
-	struct bnx2 *bp = netdev_priv(dev);
-
-	bp->rx_csum = data;
-	return 0;
-}
-
-static int
-bnx2_set_tso(struct net_device *dev, u32 data)
-{
-	struct bnx2 *bp = netdev_priv(dev);
-
-	if (data) {
-		dev->features |= NETIF_F_TSO | NETIF_F_TSO_ECN;
-		if (CHIP_NUM(bp) == CHIP_NUM_5709)
-			dev->features |= NETIF_F_TSO6;
-	} else
-		dev->features &= ~(NETIF_F_TSO | NETIF_F_TSO6 |
-				   NETIF_F_TSO_ECN);
-	return 0;
-}
-
-static struct {
-	char string[ETH_GSTRING_LEN];
-} bnx2_stats_str_arr[] = {
-	{ "rx_bytes" },
-	{ "rx_error_bytes" },
-	{ "tx_bytes" },
-	{ "tx_error_bytes" },
-	{ "rx_ucast_packets" },
-	{ "rx_mcast_packets" },
-	{ "rx_bcast_packets" },
-	{ "tx_ucast_packets" },
-	{ "tx_mcast_packets" },
-	{ "tx_bcast_packets" },
-	{ "tx_mac_errors" },
-	{ "tx_carrier_errors" },
-	{ "rx_crc_errors" },
-	{ "rx_align_errors" },
-	{ "tx_single_collisions" },
-	{ "tx_multi_collisions" },
-	{ "tx_deferred" },
-	{ "tx_excess_collisions" },
-	{ "tx_late_collisions" },
-	{ "tx_total_collisions" },
-	{ "rx_fragments" },
-	{ "rx_jabbers" },
-	{ "rx_undersize_packets" },
-	{ "rx_oversize_packets" },
-	{ "rx_64_byte_packets" },
-	{ "rx_65_to_127_byte_packets" },
-	{ "rx_128_to_255_byte_packets" },
-	{ "rx_256_to_511_byte_packets" },
-	{ "rx_512_to_1023_byte_packets" },
-	{ "rx_1024_to_1522_byte_packets" },
-	{ "rx_1523_to_9022_byte_packets" },
-	{ "tx_64_byte_packets" },
-	{ "tx_65_to_127_byte_packets" },
-	{ "tx_128_to_255_byte_packets" },
-	{ "tx_256_to_511_byte_packets" },
-	{ "tx_512_to_1023_byte_packets" },
-	{ "tx_1024_to_1522_byte_packets" },
-	{ "tx_1523_to_9022_byte_packets" },
-	{ "rx_xon_frames" },
-	{ "rx_xoff_frames" },
-	{ "tx_xon_frames" },
-	{ "tx_xoff_frames" },
-	{ "rx_mac_ctrl_frames" },
-	{ "rx_filtered_packets" },
-	{ "rx_ftq_discards" },
-	{ "rx_discards" },
-	{ "rx_fw_discards" },
-};
-
-#define BNX2_NUM_STATS (sizeof(bnx2_stats_str_arr)/\
-			sizeof(bnx2_stats_str_arr[0]))
-
-#define STATS_OFFSET32(offset_name) (offsetof(struct statistics_block, offset_name) / 4)
-
-static const unsigned long bnx2_stats_offset_arr[BNX2_NUM_STATS] = {
-    STATS_OFFSET32(stat_IfHCInOctets_hi),
-    STATS_OFFSET32(stat_IfHCInBadOctets_hi),
-    STATS_OFFSET32(stat_IfHCOutOctets_hi),
-    STATS_OFFSET32(stat_IfHCOutBadOctets_hi),
-    STATS_OFFSET32(stat_IfHCInUcastPkts_hi),
-    STATS_OFFSET32(stat_IfHCInMulticastPkts_hi),
-    STATS_OFFSET32(stat_IfHCInBroadcastPkts_hi),
-    STATS_OFFSET32(stat_IfHCOutUcastPkts_hi),
-    STATS_OFFSET32(stat_IfHCOutMulticastPkts_hi),
-    STATS_OFFSET32(stat_IfHCOutBroadcastPkts_hi),
-    STATS_OFFSET32(stat_emac_tx_stat_dot3statsinternalmactransmiterrors),
-    STATS_OFFSET32(stat_Dot3StatsCarrierSenseErrors),
-    STATS_OFFSET32(stat_Dot3StatsFCSErrors),
-    STATS_OFFSET32(stat_Dot3StatsAlignmentErrors),
-    STATS_OFFSET32(stat_Dot3StatsSingleCollisionFrames),
-    STATS_OFFSET32(stat_Dot3StatsMultipleCollisionFrames),
-    STATS_OFFSET32(stat_Dot3StatsDeferredTransmissions),
-    STATS_OFFSET32(stat_Dot3StatsExcessiveCollisions),
-    STATS_OFFSET32(stat_Dot3StatsLateCollisions),
-    STATS_OFFSET32(stat_EtherStatsCollisions),
-    STATS_OFFSET32(stat_EtherStatsFragments),
-    STATS_OFFSET32(stat_EtherStatsJabbers),
-    STATS_OFFSET32(stat_EtherStatsUndersizePkts),
-    STATS_OFFSET32(stat_EtherStatsOverrsizePkts),
-    STATS_OFFSET32(stat_EtherStatsPktsRx64Octets),
-    STATS_OFFSET32(stat_EtherStatsPktsRx65Octetsto127Octets),
-    STATS_OFFSET32(stat_EtherStatsPktsRx128Octetsto255Octets),
-    STATS_OFFSET32(stat_EtherStatsPktsRx256Octetsto511Octets),
-    STATS_OFFSET32(stat_EtherStatsPktsRx512Octetsto1023Octets),
-    STATS_OFFSET32(stat_EtherStatsPktsRx1024Octetsto1522Octets),
-    STATS_OFFSET32(stat_EtherStatsPktsRx1523Octetsto9022Octets),
-    STATS_OFFSET32(stat_EtherStatsPktsTx64Octets),
-    STATS_OFFSET32(stat_EtherStatsPktsTx65Octetsto127Octets),
-    STATS_OFFSET32(stat_EtherStatsPktsTx128Octetsto255Octets),
-    STATS_OFFSET32(stat_EtherStatsPktsTx256Octetsto511Octets),
-    STATS_OFFSET32(stat_EtherStatsPktsTx512Octetsto1023Octets),
-    STATS_OFFSET32(stat_EtherStatsPktsTx1024Octetsto1522Octets),
-    STATS_OFFSET32(stat_EtherStatsPktsTx1523Octetsto9022Octets),
-    STATS_OFFSET32(stat_XonPauseFramesReceived),
-    STATS_OFFSET32(stat_XoffPauseFramesReceived),
-    STATS_OFFSET32(stat_OutXonSent),
-    STATS_OFFSET32(stat_OutXoffSent),
-    STATS_OFFSET32(stat_MacControlFramesReceived),
-    STATS_OFFSET32(stat_IfInFramesL2FilterDiscards),
-    STATS_OFFSET32(stat_IfInFTQDiscards),
-    STATS_OFFSET32(stat_IfInMBUFDiscards),
-    STATS_OFFSET32(stat_FwRxDrop),
-};
-
-/* stat_IfHCInBadOctets and stat_Dot3StatsCarrierSenseErrors are
- * skipped because of errata.
- */
-static u8 bnx2_5706_stats_len_arr[BNX2_NUM_STATS] = {
-	8,0,8,8,8,8,8,8,8,8,
-	4,0,4,4,4,4,4,4,4,4,
-	4,4,4,4,4,4,4,4,4,4,
-	4,4,4,4,4,4,4,4,4,4,
-	4,4,4,4,4,4,4,
-};
-
-static u8 bnx2_5708_stats_len_arr[BNX2_NUM_STATS] = {
-	8,0,8,8,8,8,8,8,8,8,
-	4,4,4,4,4,4,4,4,4,4,
-	4,4,4,4,4,4,4,4,4,4,
-	4,4,4,4,4,4,4,4,4,4,
-	4,4,4,4,4,4,4,
-};
-
-#define BNX2_NUM_TESTS 6
-
-static struct {
-	char string[ETH_GSTRING_LEN];
-} bnx2_tests_str_arr[BNX2_NUM_TESTS] = {
-	{ "register_test (offline)" },
-	{ "memory_test (offline)" },
-	{ "loopback_test (offline)" },
-	{ "nvram_test (online)" },
-	{ "interrupt_test (online)" },
-	{ "link_test (online)" },
-};
-
-static int
-bnx2_get_sset_count(struct net_device *dev, int sset)
-{
-	switch (sset) {
-	case ETH_SS_TEST:
-		return BNX2_NUM_TESTS;
-	case ETH_SS_STATS:
-		return BNX2_NUM_STATS;
-	default:
-		return -EOPNOTSUPP;
-	}
-}
-
-static void
-bnx2_self_test(struct net_device *dev, struct ethtool_test *etest, u64 *buf)
-{
-	struct bnx2 *bp = netdev_priv(dev);
-
-	bnx2_set_power_state(bp, PCI_D0);
-
-	memset(buf, 0, sizeof(u64) * BNX2_NUM_TESTS);
-	if (etest->flags & ETH_TEST_FL_OFFLINE) {
-		int i;
-
-		bnx2_netif_stop(bp);
-		bnx2_reset_chip(bp, BNX2_DRV_MSG_CODE_DIAG);
-		bnx2_free_skbs(bp);
-
-		if (bnx2_test_registers(bp) != 0) {
-			buf[0] = 1;
-			etest->flags |= ETH_TEST_FL_FAILED;
-		}
-		if (bnx2_test_memory(bp) != 0) {
-			buf[1] = 1;
-			etest->flags |= ETH_TEST_FL_FAILED;
-		}
-		if ((buf[2] = bnx2_test_loopback(bp)) != 0)
-			etest->flags |= ETH_TEST_FL_FAILED;
-
-		if (!netif_running(bp->dev))
-			bnx2_shutdown_chip(bp);
-		else {
-			bnx2_init_nic(bp, 1);
-			bnx2_netif_start(bp);
-		}
-
-		/* wait for link up */
-		for (i = 0; i < 7; i++) {
-			if (bp->link_up)
-				break;
-			msleep_interruptible(1000);
-		}
-	}
-
-	if (bnx2_test_nvram(bp) != 0) {
-		buf[3] = 1;
-		etest->flags |= ETH_TEST_FL_FAILED;
-	}
-	if (bnx2_test_intr(bp) != 0) {
-		buf[4] = 1;
-		etest->flags |= ETH_TEST_FL_FAILED;
-	}
-
-	if (bnx2_test_link(bp) != 0) {
-		buf[5] = 1;
-		etest->flags |= ETH_TEST_FL_FAILED;
-
-	}
-	if (!netif_running(bp->dev))
-		bnx2_set_power_state(bp, PCI_D3hot);
-}
-
-static void
-bnx2_get_strings(struct net_device *dev, u32 stringset, u8 *buf)
-{
-	switch (stringset) {
-	case ETH_SS_STATS:
-		memcpy(buf, bnx2_stats_str_arr,
-			sizeof(bnx2_stats_str_arr));
-		break;
-	case ETH_SS_TEST:
-		memcpy(buf, bnx2_tests_str_arr,
-			sizeof(bnx2_tests_str_arr));
-		break;
-	}
-}
-
-static void
-bnx2_get_ethtool_stats(struct net_device *dev,
-		struct ethtool_stats *stats, u64 *buf)
-{
-	struct bnx2 *bp = netdev_priv(dev);
-	int i;
-	u32 *hw_stats = (u32 *) bp->stats_blk;
-	u8 *stats_len_arr = NULL;
-
-	if (hw_stats == NULL) {
-		memset(buf, 0, sizeof(u64) * BNX2_NUM_STATS);
-		return;
-	}
-
-	if ((CHIP_ID(bp) == CHIP_ID_5706_A0) ||
-	    (CHIP_ID(bp) == CHIP_ID_5706_A1) ||
-	    (CHIP_ID(bp) == CHIP_ID_5706_A2) ||
-	    (CHIP_ID(bp) == CHIP_ID_5708_A0))
-		stats_len_arr = bnx2_5706_stats_len_arr;
-	else
-		stats_len_arr = bnx2_5708_stats_len_arr;
-
-	for (i = 0; i < BNX2_NUM_STATS; i++) {
-		if (stats_len_arr[i] == 0) {
-			/* skip this counter */
-			buf[i] = 0;
-			continue;
-		}
-		if (stats_len_arr[i] == 4) {
-			/* 4-byte counter */
-			buf[i] = (u64)
-				*(hw_stats + bnx2_stats_offset_arr[i]);
-			continue;
-		}
-		/* 8-byte counter */
-		buf[i] = (((u64) *(hw_stats +
-					bnx2_stats_offset_arr[i])) << 32) +
-				*(hw_stats + bnx2_stats_offset_arr[i] + 1);
-	}
-}
-
-static int
-bnx2_phys_id(struct net_device *dev, u32 data)
-{
-	struct bnx2 *bp = netdev_priv(dev);
-	int i;
-	u32 save;
-
-	bnx2_set_power_state(bp, PCI_D0);
-
-	if (data == 0)
-		data = 2;
-
-	save = REG_RD(bp, BNX2_MISC_CFG);
-	REG_WR(bp, BNX2_MISC_CFG, BNX2_MISC_CFG_LEDMODE_MAC);
-
-	for (i = 0; i < (data * 2); i++) {
-		if ((i % 2) == 0) {
-			REG_WR(bp, BNX2_EMAC_LED, BNX2_EMAC_LED_OVERRIDE);
-		}
-		else {
-			REG_WR(bp, BNX2_EMAC_LED, BNX2_EMAC_LED_OVERRIDE |
-				BNX2_EMAC_LED_1000MB_OVERRIDE |
-				BNX2_EMAC_LED_100MB_OVERRIDE |
-				BNX2_EMAC_LED_10MB_OVERRIDE |
-				BNX2_EMAC_LED_TRAFFIC_OVERRIDE |
-				BNX2_EMAC_LED_TRAFFIC);
-		}
-		msleep_interruptible(500);
-		if (signal_pending(current))
-			break;
-	}
-	REG_WR(bp, BNX2_EMAC_LED, 0);
-	REG_WR(bp, BNX2_MISC_CFG, save);
-
-	if (!netif_running(dev))
-		bnx2_set_power_state(bp, PCI_D3hot);
-
-	return 0;
-}
-
-static int
-bnx2_set_tx_csum(struct net_device *dev, u32 data)
-{
-	struct bnx2 *bp = netdev_priv(dev);
-
-	if (CHIP_NUM(bp) == CHIP_NUM_5709)
-		return (ethtool_op_set_tx_ipv6_csum(dev, data));
-	else
-		return (ethtool_op_set_tx_csum(dev, data));
-}
-
-static const struct ethtool_ops bnx2_ethtool_ops = {
-	.get_settings		= bnx2_get_settings,
-	.set_settings		= bnx2_set_settings,
-	.get_drvinfo		= bnx2_get_drvinfo,
-	.get_regs_len		= bnx2_get_regs_len,
-	.get_regs		= bnx2_get_regs,
-	.get_wol		= bnx2_get_wol,
-	.set_wol		= bnx2_set_wol,
-	.nway_reset		= bnx2_nway_reset,
-	.get_link		= bnx2_get_link,
-	.get_eeprom_len		= bnx2_get_eeprom_len,
-	.get_eeprom		= bnx2_get_eeprom,
-	.set_eeprom		= bnx2_set_eeprom,
-	.get_coalesce		= bnx2_get_coalesce,
-	.set_coalesce		= bnx2_set_coalesce,
-	.get_ringparam		= bnx2_get_ringparam,
-	.set_ringparam		= bnx2_set_ringparam,
-	.get_pauseparam		= bnx2_get_pauseparam,
-	.set_pauseparam		= bnx2_set_pauseparam,
-	.get_rx_csum		= bnx2_get_rx_csum,
-	.set_rx_csum		= bnx2_set_rx_csum,
-	.set_tx_csum		= bnx2_set_tx_csum,
-	.set_sg			= ethtool_op_set_sg,
-	.set_tso		= bnx2_set_tso,
-	.self_test		= bnx2_self_test,
-	.get_strings		= bnx2_get_strings,
-	.phys_id		= bnx2_phys_id,
-	.get_ethtool_stats	= bnx2_get_ethtool_stats,
-	.get_sset_count		= bnx2_get_sset_count,
-};
-
-/* Called with rtnl_lock */
-static int
-bnx2_ioctl(struct net_device *dev, struct ifreq *ifr, int cmd)
-{
-	struct mii_ioctl_data *data = if_mii(ifr);
-	struct bnx2 *bp = netdev_priv(dev);
-	int err;
-
-	switch(cmd) {
-	case SIOCGMIIPHY:
-		data->phy_id = bp->phy_addr;
-
-		/* fallthru */
-	case SIOCGMIIREG: {
-		u32 mii_regval;
-
-		if (bp->phy_flags & BNX2_PHY_FLAG_REMOTE_PHY_CAP)
-			return -EOPNOTSUPP;
-
-		if (!netif_running(dev))
-			return -EAGAIN;
-
-		spin_lock_bh(&bp->phy_lock);
-		err = bnx2_read_phy(bp, data->reg_num & 0x1f, &mii_regval);
-		spin_unlock_bh(&bp->phy_lock);
-
-		data->val_out = mii_regval;
-
-		return err;
-	}
-
-	case SIOCSMIIREG:
-		if (bp->phy_flags & BNX2_PHY_FLAG_REMOTE_PHY_CAP)
-			return -EOPNOTSUPP;
-
-		if (!netif_running(dev))
-			return -EAGAIN;
-
-		spin_lock_bh(&bp->phy_lock);
-		err = bnx2_write_phy(bp, data->reg_num & 0x1f, data->val_in);
-		spin_unlock_bh(&bp->phy_lock);
-
-		return err;
-
-	default:
-		/* do nothing */
-		break;
-	}
-	return -EOPNOTSUPP;
-}
-
-/* Called with rtnl_lock */
-static int
-bnx2_change_mac_addr(struct net_device *dev, void *p)
-{
-	struct sockaddr *addr = p;
-	struct bnx2 *bp = netdev_priv(dev);
-
-	if (!is_valid_ether_addr(addr->sa_data))
-		return -EINVAL;
-
-	memcpy(dev->dev_addr, addr->sa_data, dev->addr_len);
-	if (netif_running(dev))
-		bnx2_set_mac_addr(bp, bp->dev->dev_addr, 0);
-
-	return 0;
-}
-
-/* Called with rtnl_lock */
-static int
-bnx2_change_mtu(struct net_device *dev, int new_mtu)
-{
-	struct bnx2 *bp = netdev_priv(dev);
-
-	if (((new_mtu + ETH_HLEN) > MAX_ETHERNET_JUMBO_PACKET_SIZE) ||
-		((new_mtu + ETH_HLEN) < MIN_ETHERNET_PACKET_SIZE))
-		return -EINVAL;
-
-	dev->mtu = new_mtu;
-	return (bnx2_change_ring_size(bp, bp->rx_ring_size, bp->tx_ring_size));
-}
-
-#if defined(HAVE_POLL_CONTROLLER) || defined(CONFIG_NET_POLL_CONTROLLER)
-static void
-poll_bnx2(struct net_device *dev)
-{
-	struct bnx2 *bp = netdev_priv(dev);
-	int i;
-
-	for (i = 0; i < bp->irq_nvecs; i++) {
-		disable_irq(bp->irq_tbl[i].vector);
-		bnx2_interrupt(bp->irq_tbl[i].vector, &bp->bnx2_napi[i]);
-		enable_irq(bp->irq_tbl[i].vector);
-	}
-}
-#endif
-
-static void __devinit
-bnx2_get_5709_media(struct bnx2 *bp)
-{
-	u32 val = REG_RD(bp, BNX2_MISC_DUAL_MEDIA_CTRL);
-	u32 bond_id = val & BNX2_MISC_DUAL_MEDIA_CTRL_BOND_ID;
-	u32 strap;
-
-	if (bond_id == BNX2_MISC_DUAL_MEDIA_CTRL_BOND_ID_C)
-		return;
-	else if (bond_id == BNX2_MISC_DUAL_MEDIA_CTRL_BOND_ID_S) {
-		bp->phy_flags |= BNX2_PHY_FLAG_SERDES;
-		return;
-	}
-
-	if (val & BNX2_MISC_DUAL_MEDIA_CTRL_STRAP_OVERRIDE)
-		strap = (val & BNX2_MISC_DUAL_MEDIA_CTRL_PHY_CTRL) >> 21;
-	else
-		strap = (val & BNX2_MISC_DUAL_MEDIA_CTRL_PHY_CTRL_STRAP) >> 8;
-
-	if (PCI_FUNC(bp->pdev->devfn) == 0) {
-		switch (strap) {
-		case 0x4:
-		case 0x5:
-		case 0x6:
-			bp->phy_flags |= BNX2_PHY_FLAG_SERDES;
-			return;
-		}
-	} else {
-		switch (strap) {
-		case 0x1:
-		case 0x2:
-		case 0x4:
-			bp->phy_flags |= BNX2_PHY_FLAG_SERDES;
-			return;
-		}
-	}
-}
-
-static void __devinit
-bnx2_get_pci_speed(struct bnx2 *bp)
-{
-	u32 reg;
-
-	reg = REG_RD(bp, BNX2_PCICFG_MISC_STATUS);
-	if (reg & BNX2_PCICFG_MISC_STATUS_PCIX_DET) {
-		u32 clkreg;
-
-		bp->flags |= BNX2_FLAG_PCIX;
-
-		clkreg = REG_RD(bp, BNX2_PCICFG_PCI_CLOCK_CONTROL_BITS);
-
-		clkreg &= BNX2_PCICFG_PCI_CLOCK_CONTROL_BITS_PCI_CLK_SPD_DET;
-		switch (clkreg) {
-		case BNX2_PCICFG_PCI_CLOCK_CONTROL_BITS_PCI_CLK_SPD_DET_133MHZ:
-			bp->bus_speed_mhz = 133;
-			break;
-
-		case BNX2_PCICFG_PCI_CLOCK_CONTROL_BITS_PCI_CLK_SPD_DET_95MHZ:
-			bp->bus_speed_mhz = 100;
-			break;
-
-		case BNX2_PCICFG_PCI_CLOCK_CONTROL_BITS_PCI_CLK_SPD_DET_66MHZ:
-		case BNX2_PCICFG_PCI_CLOCK_CONTROL_BITS_PCI_CLK_SPD_DET_80MHZ:
-			bp->bus_speed_mhz = 66;
-			break;
-
-		case BNX2_PCICFG_PCI_CLOCK_CONTROL_BITS_PCI_CLK_SPD_DET_48MHZ:
-		case BNX2_PCICFG_PCI_CLOCK_CONTROL_BITS_PCI_CLK_SPD_DET_55MHZ:
-			bp->bus_speed_mhz = 50;
-			break;
-
-		case BNX2_PCICFG_PCI_CLOCK_CONTROL_BITS_PCI_CLK_SPD_DET_LOW:
-		case BNX2_PCICFG_PCI_CLOCK_CONTROL_BITS_PCI_CLK_SPD_DET_32MHZ:
-		case BNX2_PCICFG_PCI_CLOCK_CONTROL_BITS_PCI_CLK_SPD_DET_38MHZ:
-			bp->bus_speed_mhz = 33;
-			break;
-		}
-	}
-	else {
-		if (reg & BNX2_PCICFG_MISC_STATUS_M66EN)
-			bp->bus_speed_mhz = 66;
-		else
-			bp->bus_speed_mhz = 33;
-	}
-
-	if (reg & BNX2_PCICFG_MISC_STATUS_32BIT_DET)
-		bp->flags |= BNX2_FLAG_PCI_32BIT;
-
-}
-
-static void __devinit
-bnx2_read_vpd_fw_ver(struct bnx2 *bp)
-{
-	int rc, i, v0_len = 0;
-	u8 *data;
-	u8 *v0_str = NULL;
-	bool mn_match = false;
-
-#define BNX2_VPD_NVRAM_OFFSET	0x300
-#define BNX2_VPD_LEN		128
-#define BNX2_MAX_VER_SLEN	30
-
-	data = kmalloc(256, GFP_KERNEL);
-	if (!data)
-		return;
-
-	rc = bnx2_nvram_read(bp, BNX2_VPD_NVRAM_OFFSET, data + BNX2_VPD_LEN,
-			     BNX2_VPD_LEN);
-	if (rc)
-		goto vpd_done;
-
-	for (i = 0; i < BNX2_VPD_LEN; i += 4) {
-		data[i] = data[i + BNX2_VPD_LEN + 3];
-		data[i + 1] = data[i + BNX2_VPD_LEN + 2];
-		data[i + 2] = data[i + BNX2_VPD_LEN + 1];
-		data[i + 3] = data[i + BNX2_VPD_LEN];
-	}
-
-	for (i = 0; i <= BNX2_VPD_LEN - 3; ) {
-		unsigned char val = data[i];
-		unsigned int block_end;
-
-		if (val == 0x82 || val == 0x91) {
-			i = (i + 3 + (data[i + 1] + (data[i + 2] << 8)));
-			continue;
-		}
-
-		if (val != 0x90)
-			goto vpd_done;
-
-		block_end = (i + 3 + (data[i + 1] + (data[i + 2] << 8)));
-		i += 3;
-
-		if (block_end > BNX2_VPD_LEN)
-			goto vpd_done;
-
-		while (i < (block_end - 2)) {
-			int len = data[i + 2];
-
-			if (i + 3 + len > block_end)
-				goto vpd_done;
-
-			if (data[i] == 'M' && data[i + 1] == 'N') {
-				if (len != 4 ||
-				    memcmp(&data[i + 3], "1028", 4))
-					goto vpd_done;
-				mn_match = true;
-
-			} else if (data[i] == 'V' && data[i + 1] == '0') {
-				if (len > BNX2_MAX_VER_SLEN)
-					goto vpd_done;
-
-				v0_len = len;
-				v0_str = &data[i + 3];
-			}
-			i += 3 + len;
-
-			if (mn_match && v0_str) {
-				memcpy(bp->fw_version, v0_str, v0_len);
-				bp->fw_version[v0_len] = ' ';
-				goto vpd_done;
-			}
-		}
-		goto vpd_done;
-	}
-
-vpd_done:
-	kfree(data);
-}
-
-static int __devinit
-bnx2_init_board(struct pci_dev *pdev, struct net_device *dev)
-{
-	struct bnx2 *bp;
-	unsigned long mem_len;
-	int rc, i, j;
-	u32 reg;
-	u64 dma_mask, persist_dma_mask;
-
-	SET_NETDEV_DEV(dev, &pdev->dev);
-	bp = netdev_priv(dev);
-
-	bp->flags = 0;
-	bp->phy_flags = 0;
-
-	/* enable device (incl. PCI PM wakeup), and bus-mastering */
-	rc = pci_enable_device(pdev);
-	if (rc) {
-		dev_err(&pdev->dev, "Cannot enable PCI device, aborting.\n");
-		goto err_out;
-	}
-
-	if (!(pci_resource_flags(pdev, 0) & IORESOURCE_MEM)) {
-		dev_err(&pdev->dev,
-			"Cannot find PCI device base address, aborting.\n");
-		rc = -ENODEV;
-		goto err_out_disable;
-	}
-
-	rc = pci_request_regions(pdev, DRV_MODULE_NAME);
-	if (rc) {
-		dev_err(&pdev->dev, "Cannot obtain PCI resources, aborting.\n");
-		goto err_out_disable;
-	}
-
-	pci_set_master(pdev);
-	pci_save_state(pdev);
-
-	bp->pm_cap = pci_find_capability(pdev, PCI_CAP_ID_PM);
-	if (bp->pm_cap == 0) {
-		dev_err(&pdev->dev,
-			"Cannot find power management capability, aborting.\n");
-		rc = -EIO;
-		goto err_out_release;
-	}
-
-	bp->dev = dev;
-	bp->pdev = pdev;
-
-	spin_lock_init(&bp->phy_lock);
-	spin_lock_init(&bp->indirect_lock);
-#ifdef BCM_CNIC
-	mutex_init(&bp->cnic_lock);
-#endif
-	INIT_WORK(&bp->reset_task, bnx2_reset_task);
-
-	dev->base_addr = dev->mem_start = pci_resource_start(pdev, 0);
-	mem_len = MB_GET_CID_ADDR(TX_TSS_CID + TX_MAX_TSS_RINGS + 1);
-	dev->mem_end = dev->mem_start + mem_len;
-	dev->irq = pdev->irq;
-
-	bp->regview = ioremap_nocache(dev->base_addr, mem_len);
-
-	if (!bp->regview) {
-		dev_err(&pdev->dev, "Cannot map register space, aborting.\n");
-		rc = -ENOMEM;
-		goto err_out_release;
-	}
-
-	/* Configure byte swap and enable write to the reg_window registers.
-	 * Rely on CPU to do target byte swapping on big endian systems
-	 * The chip's target access swapping will not swap all accesses
-	 */
-	pci_write_config_dword(bp->pdev, BNX2_PCICFG_MISC_CONFIG,
-			       BNX2_PCICFG_MISC_CONFIG_REG_WINDOW_ENA |
-			       BNX2_PCICFG_MISC_CONFIG_TARGET_MB_WORD_SWAP);
-
-	bnx2_set_power_state(bp, PCI_D0);
-
-	bp->chip_id = REG_RD(bp, BNX2_MISC_ID);
-
-	if (CHIP_NUM(bp) == CHIP_NUM_5709) {
-		if (pci_find_capability(pdev, PCI_CAP_ID_EXP) == 0) {
-			dev_err(&pdev->dev,
-				"Cannot find PCIE capability, aborting.\n");
-			rc = -EIO;
-			goto err_out_unmap;
-		}
-		bp->flags |= BNX2_FLAG_PCIE;
-		if (CHIP_REV(bp) == CHIP_REV_Ax)
-			bp->flags |= BNX2_FLAG_JUMBO_BROKEN;
-	} else {
-		bp->pcix_cap = pci_find_capability(pdev, PCI_CAP_ID_PCIX);
-		if (bp->pcix_cap == 0) {
-			dev_err(&pdev->dev,
-				"Cannot find PCIX capability, aborting.\n");
-			rc = -EIO;
-			goto err_out_unmap;
-		}
-		bp->flags |= BNX2_FLAG_BROKEN_STATS;
-	}
-
-	if (CHIP_NUM(bp) == CHIP_NUM_5709 && CHIP_REV(bp) != CHIP_REV_Ax) {
-		if (pci_find_capability(pdev, PCI_CAP_ID_MSIX))
-			bp->flags |= BNX2_FLAG_MSIX_CAP;
-	}
-
-	if (CHIP_ID(bp) != CHIP_ID_5706_A0 && CHIP_ID(bp) != CHIP_ID_5706_A1) {
-		if (pci_find_capability(pdev, PCI_CAP_ID_MSI))
-			bp->flags |= BNX2_FLAG_MSI_CAP;
-	}
-
-	/* 5708 cannot support DMA addresses > 40-bit.  */
-	if (CHIP_NUM(bp) == CHIP_NUM_5708)
-		persist_dma_mask = dma_mask = DMA_BIT_MASK(40);
-	else
-		persist_dma_mask = dma_mask = DMA_BIT_MASK(64);
-
-	/* Configure DMA attributes. */
-	if (pci_set_dma_mask(pdev, dma_mask) == 0) {
-		dev->features |= NETIF_F_HIGHDMA;
-		rc = pci_set_consistent_dma_mask(pdev, persist_dma_mask);
-		if (rc) {
-			dev_err(&pdev->dev,
-				"pci_set_consistent_dma_mask failed, aborting.\n");
-			goto err_out_unmap;
-		}
-	} else if ((rc = pci_set_dma_mask(pdev, DMA_BIT_MASK(32))) != 0) {
-		dev_err(&pdev->dev, "System does not support DMA, aborting.\n");
-		goto err_out_unmap;
-	}
-
-	if (!(bp->flags & BNX2_FLAG_PCIE))
-		bnx2_get_pci_speed(bp);
-
-	/* 5706A0 may falsely detect SERR and PERR. */
-	if (CHIP_ID(bp) == CHIP_ID_5706_A0) {
-		reg = REG_RD(bp, PCI_COMMAND);
-		reg &= ~(PCI_COMMAND_SERR | PCI_COMMAND_PARITY);
-		REG_WR(bp, PCI_COMMAND, reg);
-	}
-	else if ((CHIP_ID(bp) == CHIP_ID_5706_A1) &&
-		!(bp->flags & BNX2_FLAG_PCIX)) {
-
-		dev_err(&pdev->dev,
-			"5706 A1 can only be used in a PCIX bus, aborting.\n");
-		goto err_out_unmap;
-	}
-
-	bnx2_init_nvram(bp);
-
-	reg = bnx2_reg_rd_ind(bp, BNX2_SHM_HDR_SIGNATURE);
-
-	if ((reg & BNX2_SHM_HDR_SIGNATURE_SIG_MASK) ==
-	    BNX2_SHM_HDR_SIGNATURE_SIG) {
-		u32 off = PCI_FUNC(pdev->devfn) << 2;
-
-		bp->shmem_base = bnx2_reg_rd_ind(bp, BNX2_SHM_HDR_ADDR_0 + off);
-	} else
-		bp->shmem_base = HOST_VIEW_SHMEM_BASE;
-
-	/* Get the permanent MAC address.  First we need to make sure the
-	 * firmware is actually running.
-	 */
-	reg = bnx2_shmem_rd(bp, BNX2_DEV_INFO_SIGNATURE);
-
-	if ((reg & BNX2_DEV_INFO_SIGNATURE_MAGIC_MASK) !=
-	    BNX2_DEV_INFO_SIGNATURE_MAGIC) {
-		dev_err(&pdev->dev, "Firmware not running, aborting.\n");
-		rc = -ENODEV;
-		goto err_out_unmap;
-	}
-
-	bnx2_read_vpd_fw_ver(bp);
-
-	j = strlen(bp->fw_version);
-	reg = bnx2_shmem_rd(bp, BNX2_DEV_INFO_BC_REV);
-	for (i = 0; i < 3 && j < 24; i++) {
-		u8 num, k, skip0;
-
-		if (i == 0) {
-			bp->fw_version[j++] = 'b';
-			bp->fw_version[j++] = 'c';
-			bp->fw_version[j++] = ' ';
-		}
-		num = (u8) (reg >> (24 - (i * 8)));
-		for (k = 100, skip0 = 1; k >= 1; num %= k, k /= 10) {
-			if (num >= k || !skip0 || k == 1) {
-				bp->fw_version[j++] = (num / k) + '0';
-				skip0 = 0;
-			}
-		}
-		if (i != 2)
-			bp->fw_version[j++] = '.';
-	}
-	reg = bnx2_shmem_rd(bp, BNX2_PORT_FEATURE);
-	if (reg & BNX2_PORT_FEATURE_WOL_ENABLED)
-		bp->wol = 1;
-
-	if (reg & BNX2_PORT_FEATURE_ASF_ENABLED) {
-		bp->flags |= BNX2_FLAG_ASF_ENABLE;
-
-		for (i = 0; i < 30; i++) {
-			reg = bnx2_shmem_rd(bp, BNX2_BC_STATE_CONDITION);
-			if (reg & BNX2_CONDITION_MFW_RUN_MASK)
-				break;
-			msleep(10);
-		}
-	}
-	reg = bnx2_shmem_rd(bp, BNX2_BC_STATE_CONDITION);
-	reg &= BNX2_CONDITION_MFW_RUN_MASK;
-	if (reg != BNX2_CONDITION_MFW_RUN_UNKNOWN &&
-	    reg != BNX2_CONDITION_MFW_RUN_NONE) {
-		u32 addr = bnx2_shmem_rd(bp, BNX2_MFW_VER_PTR);
-
-		if (j < 32)
-			bp->fw_version[j++] = ' ';
-		for (i = 0; i < 3 && j < 28; i++) {
-			reg = bnx2_reg_rd_ind(bp, addr + i * 4);
-			reg = swab32(reg);
-			memcpy(&bp->fw_version[j], &reg, 4);
-			j += 4;
-		}
-	}
-
-	reg = bnx2_shmem_rd(bp, BNX2_PORT_HW_CFG_MAC_UPPER);
-	bp->mac_addr[0] = (u8) (reg >> 8);
-	bp->mac_addr[1] = (u8) reg;
-
-	reg = bnx2_shmem_rd(bp, BNX2_PORT_HW_CFG_MAC_LOWER);
-	bp->mac_addr[2] = (u8) (reg >> 24);
-	bp->mac_addr[3] = (u8) (reg >> 16);
-	bp->mac_addr[4] = (u8) (reg >> 8);
-	bp->mac_addr[5] = (u8) reg;
-
-	bp->tx_ring_size = MAX_TX_DESC_CNT;
-	bnx2_set_rx_ring_size(bp, 255);
-
-	bp->rx_csum = 1;
-
-	bp->tx_quick_cons_trip_int = 2;
-	bp->tx_quick_cons_trip = 20;
-	bp->tx_ticks_int = 18;
-	bp->tx_ticks = 80;
-
-	bp->rx_quick_cons_trip_int = 2;
-	bp->rx_quick_cons_trip = 12;
-	bp->rx_ticks_int = 18;
-	bp->rx_ticks = 18;
-
-	bp->stats_ticks = USEC_PER_SEC & BNX2_HC_STATS_TICKS_HC_STAT_TICKS;
-
-	bp->current_interval = BNX2_TIMER_INTERVAL;
-
-	bp->phy_addr = 1;
-
-	/* Disable WOL support if we are running on a SERDES chip. */
-	if (CHIP_NUM(bp) == CHIP_NUM_5709)
-		bnx2_get_5709_media(bp);
-	else if (CHIP_BOND_ID(bp) & CHIP_BOND_ID_SERDES_BIT)
-		bp->phy_flags |= BNX2_PHY_FLAG_SERDES;
-
-	bp->phy_port = PORT_TP;
-	if (bp->phy_flags & BNX2_PHY_FLAG_SERDES) {
-		bp->phy_port = PORT_FIBRE;
-		reg = bnx2_shmem_rd(bp, BNX2_SHARED_HW_CFG_CONFIG);
-		if (!(reg & BNX2_SHARED_HW_CFG_GIG_LINK_ON_VAUX)) {
-			bp->flags |= BNX2_FLAG_NO_WOL;
-			bp->wol = 0;
-		}
-		if (CHIP_NUM(bp) == CHIP_NUM_5706) {
-			/* Don't do parallel detect on this board because of
-			 * some board problems.  The link will not go down
-			 * if we do parallel detect.
-			 */
-			if (pdev->subsystem_vendor == PCI_VENDOR_ID_HP &&
-			    pdev->subsystem_device == 0x310c)
-				bp->phy_flags |= BNX2_PHY_FLAG_NO_PARALLEL;
-		} else {
-			bp->phy_addr = 2;
-			if (reg & BNX2_SHARED_HW_CFG_PHY_2_5G)
-				bp->phy_flags |= BNX2_PHY_FLAG_2_5G_CAPABLE;
-		}
-	} else if (CHIP_NUM(bp) == CHIP_NUM_5706 ||
-		   CHIP_NUM(bp) == CHIP_NUM_5708)
-		bp->phy_flags |= BNX2_PHY_FLAG_CRC_FIX;
-	else if (CHIP_NUM(bp) == CHIP_NUM_5709 &&
-		 (CHIP_REV(bp) == CHIP_REV_Ax ||
-		  CHIP_REV(bp) == CHIP_REV_Bx))
-		bp->phy_flags |= BNX2_PHY_FLAG_DIS_EARLY_DAC;
-
-	bnx2_init_fw_cap(bp);
-
-	if ((CHIP_ID(bp) == CHIP_ID_5708_A0) ||
-	    (CHIP_ID(bp) == CHIP_ID_5708_B0) ||
-	    (CHIP_ID(bp) == CHIP_ID_5708_B1) ||
-	    !(REG_RD(bp, BNX2_PCI_CONFIG_3) & BNX2_PCI_CONFIG_3_VAUX_PRESET)) {
-		bp->flags |= BNX2_FLAG_NO_WOL;
-		bp->wol = 0;
-	}
-
-	if (CHIP_ID(bp) == CHIP_ID_5706_A0) {
-		bp->tx_quick_cons_trip_int =
-			bp->tx_quick_cons_trip;
-		bp->tx_ticks_int = bp->tx_ticks;
-		bp->rx_quick_cons_trip_int =
-			bp->rx_quick_cons_trip;
-		bp->rx_ticks_int = bp->rx_ticks;
-		bp->comp_prod_trip_int = bp->comp_prod_trip;
-		bp->com_ticks_int = bp->com_ticks;
-		bp->cmd_ticks_int = bp->cmd_ticks;
-	}
-
-	/* Disable MSI on 5706 if AMD 8132 bridge is found.
-	 *
-	 * MSI is defined to be 32-bit write.  The 5706 does 64-bit MSI writes
-	 * with byte enables disabled on the unused 32-bit word.  This is legal
-	 * but causes problems on the AMD 8132 which will eventually stop
-	 * responding after a while.
-	 *
-	 * AMD believes this incompatibility is unique to the 5706, and
-	 * prefers to locally disable MSI rather than globally disabling it.
-	 */
-	if (CHIP_NUM(bp) == CHIP_NUM_5706 && disable_msi == 0) {
-		struct pci_dev *amd_8132 = NULL;
-
-		while ((amd_8132 = pci_get_device(PCI_VENDOR_ID_AMD,
-						  PCI_DEVICE_ID_AMD_8132_BRIDGE,
-						  amd_8132))) {
-
-			if (amd_8132->revision >= 0x10 &&
-			    amd_8132->revision <= 0x13) {
-				disable_msi = 1;
-				pci_dev_put(amd_8132);
-				break;
-			}
-		}
-	}
-
-	bnx2_set_default_link(bp);
-	bp->req_flow_ctrl = FLOW_CTRL_RX | FLOW_CTRL_TX;
-
-	init_timer(&bp->timer);
-	bp->timer.expires = RUN_AT(BNX2_TIMER_INTERVAL);
-	bp->timer.data = (unsigned long) bp;
-	bp->timer.function = bnx2_timer;
-
-	return 0;
-
-err_out_unmap:
-	if (bp->regview) {
-		iounmap(bp->regview);
-		bp->regview = NULL;
-	}
-
-err_out_release:
-	pci_release_regions(pdev);
-
-err_out_disable:
-	pci_disable_device(pdev);
-	pci_set_drvdata(pdev, NULL);
-
-err_out:
-	return rc;
-}
-
-static char * __devinit
-bnx2_bus_string(struct bnx2 *bp, char *str)
-{
-	char *s = str;
-
-	if (bp->flags & BNX2_FLAG_PCIE) {
-		s += sprintf(s, "PCI Express");
-	} else {
-		s += sprintf(s, "PCI");
-		if (bp->flags & BNX2_FLAG_PCIX)
-			s += sprintf(s, "-X");
-		if (bp->flags & BNX2_FLAG_PCI_32BIT)
-			s += sprintf(s, " 32-bit");
-		else
-			s += sprintf(s, " 64-bit");
-		s += sprintf(s, " %dMHz", bp->bus_speed_mhz);
-	}
-	return str;
-}
-
-static void __devinit
-bnx2_init_napi(struct bnx2 *bp)
-{
-	int i;
-
-	for (i = 0; i < BNX2_MAX_MSIX_VEC; i++) {
-		struct bnx2_napi *bnapi = &bp->bnx2_napi[i];
-		int (*poll)(struct napi_struct *, int);
-
-		if (i == 0)
-			poll = bnx2_poll;
-		else
-			poll = bnx2_poll_msix;
-
-		netif_napi_add(bp->dev, &bp->bnx2_napi[i].napi, poll, 64);
-		bnapi->bp = bp;
-	}
-}
-
-static const struct net_device_ops bnx2_netdev_ops = {
-	.ndo_open		= bnx2_open,
-	.ndo_start_xmit		= bnx2_start_xmit,
-	.ndo_stop		= bnx2_close,
-	.ndo_get_stats		= bnx2_get_stats,
-	.ndo_set_rx_mode	= bnx2_set_rx_mode,
-	.ndo_do_ioctl		= bnx2_ioctl,
-	.ndo_validate_addr	= eth_validate_addr,
-	.ndo_set_mac_address	= bnx2_change_mac_addr,
-	.ndo_change_mtu		= bnx2_change_mtu,
-	.ndo_tx_timeout		= bnx2_tx_timeout,
-#ifdef BCM_VLAN
-	.ndo_vlan_rx_register	= bnx2_vlan_rx_register,
-#endif
-#if defined(HAVE_POLL_CONTROLLER) || defined(CONFIG_NET_POLL_CONTROLLER)
-	.ndo_poll_controller	= poll_bnx2,
-#endif
-};
-
-static void inline vlan_features_add(struct net_device *dev, unsigned long flags)
-{
-#ifdef BCM_VLAN
-	dev->vlan_features |= flags;
-#endif
-}
-
-static int __devinit
-bnx2_init_one(struct pci_dev *pdev, const struct pci_device_id *ent)
-{
-	static int version_printed = 0;
-	struct net_device *dev = NULL;
-	struct bnx2 *bp;
-	int rc;
-	char str[40];
-
-	if (version_printed++ == 0)
-		printk(KERN_INFO "%s", version);
-
-	/* dev zeroed in init_etherdev */
-	dev = alloc_etherdev_mq(sizeof(*bp), TX_MAX_RINGS);
-
-	if (!dev)
-		return -ENOMEM;
-
-	rc = bnx2_init_board(pdev, dev);
-	if (rc < 0) {
-		free_netdev(dev);
-		return rc;
-	}
-
-	dev->netdev_ops = &bnx2_netdev_ops;
-	dev->watchdog_timeo = TX_TIMEOUT;
-	dev->ethtool_ops = &bnx2_ethtool_ops;
-
-	bp = netdev_priv(dev);
-	bnx2_init_napi(bp);
-
-	pci_set_drvdata(pdev, dev);
-
-	rc = bnx2_request_firmware(bp);
-	if (rc)
-		goto error;
-
-	memcpy(dev->dev_addr, bp->mac_addr, 6);
-	memcpy(dev->perm_addr, bp->mac_addr, 6);
-
-	dev->features |= NETIF_F_IP_CSUM | NETIF_F_SG;
-	vlan_features_add(dev, NETIF_F_IP_CSUM | NETIF_F_SG);
-	if (CHIP_NUM(bp) == CHIP_NUM_5709) {
-		dev->features |= NETIF_F_IPV6_CSUM;
-		vlan_features_add(dev, NETIF_F_IPV6_CSUM);
-	}
-#ifdef BCM_VLAN
-	dev->features |= NETIF_F_HW_VLAN_TX | NETIF_F_HW_VLAN_RX;
-#endif
-	dev->features |= NETIF_F_TSO | NETIF_F_TSO_ECN;
-	vlan_features_add(dev, NETIF_F_TSO | NETIF_F_TSO_ECN);
-	if (CHIP_NUM(bp) == CHIP_NUM_5709) {
-		dev->features |= NETIF_F_TSO6;
-		vlan_features_add(dev, NETIF_F_TSO6);
-	}
-	if ((rc = register_netdev(dev))) {
-		dev_err(&pdev->dev, "Cannot register net device\n");
-		goto error;
-	}
-
-	printk(KERN_INFO "%s: %s (%c%d) %s found at mem %lx, "
-		"IRQ %d, node addr %pM\n",
-		dev->name,
-		board_info[ent->driver_data].name,
-		((CHIP_ID(bp) & 0xf000) >> 12) + 'A',
-		((CHIP_ID(bp) & 0x0ff0) >> 4),
-		bnx2_bus_string(bp, str),
-		dev->base_addr,
-		bp->pdev->irq, dev->dev_addr);
-
-	return 0;
-
-error:
-	if (bp->mips_firmware)
-		release_firmware(bp->mips_firmware);
-	if (bp->rv2p_firmware)
-		release_firmware(bp->rv2p_firmware);
-
-	if (bp->regview)
-		iounmap(bp->regview);
-	pci_release_regions(pdev);
-	pci_disable_device(pdev);
-	pci_set_drvdata(pdev, NULL);
-	free_netdev(dev);
-	return rc;
-}
-
-static void __devexit
-bnx2_remove_one(struct pci_dev *pdev)
-{
-	struct net_device *dev = pci_get_drvdata(pdev);
-	struct bnx2 *bp = netdev_priv(dev);
-
-	flush_scheduled_work();
-
-	unregister_netdev(dev);
-
-	if (bp->mips_firmware)
-		release_firmware(bp->mips_firmware);
-	if (bp->rv2p_firmware)
-		release_firmware(bp->rv2p_firmware);
-
-	if (bp->regview)
-		iounmap(bp->regview);
-
-	free_netdev(dev);
-	pci_release_regions(pdev);
-	pci_disable_device(pdev);
-	pci_set_drvdata(pdev, NULL);
-}
-
-static int
-bnx2_suspend(struct pci_dev *pdev, pm_message_t state)
-{
-	struct net_device *dev = pci_get_drvdata(pdev);
-	struct bnx2 *bp = netdev_priv(dev);
-
-	/* PCI register 4 needs to be saved whether netif_running() or not.
-	 * MSI address and data need to be saved if using MSI and
-	 * netif_running().
-	 */
-	pci_save_state(pdev);
-	if (!netif_running(dev))
-		return 0;
-
-	flush_scheduled_work();
-	bnx2_netif_stop(bp);
-	netif_device_detach(dev);
-	del_timer_sync(&bp->timer);
-	bnx2_shutdown_chip(bp);
-	bnx2_free_skbs(bp);
-	bnx2_set_power_state(bp, pci_choose_state(pdev, state));
-	return 0;
-}
-
-static int
-bnx2_resume(struct pci_dev *pdev)
-{
-	struct net_device *dev = pci_get_drvdata(pdev);
-	struct bnx2 *bp = netdev_priv(dev);
-
-	pci_restore_state(pdev);
-	if (!netif_running(dev))
-		return 0;
-
-	bnx2_set_power_state(bp, PCI_D0);
-	netif_device_attach(dev);
-	bnx2_init_nic(bp, 1);
-	bnx2_netif_start(bp);
-	return 0;
-}
-
-/**
- * bnx2_io_error_detected - called when PCI error is detected
- * @pdev: Pointer to PCI device
- * @state: The current pci connection state
- *
- * This function is called after a PCI bus error affecting
- * this device has been detected.
- */
-static pci_ers_result_t bnx2_io_error_detected(struct pci_dev *pdev,
-					       pci_channel_state_t state)
-{
-	struct net_device *dev = pci_get_drvdata(pdev);
-	struct bnx2 *bp = netdev_priv(dev);
-
-	rtnl_lock();
-	netif_device_detach(dev);
-
-	if (state == pci_channel_io_perm_failure) {
-		rtnl_unlock();
-		return PCI_ERS_RESULT_DISCONNECT;
-	}
-
-	if (netif_running(dev)) {
-		bnx2_netif_stop(bp);
-		del_timer_sync(&bp->timer);
-		bnx2_reset_nic(bp, BNX2_DRV_MSG_CODE_RESET);
-	}
-
-	pci_disable_device(pdev);
-	rtnl_unlock();
-
-	/* Request a slot slot reset. */
-	return PCI_ERS_RESULT_NEED_RESET;
-}
-
-/**
- * bnx2_io_slot_reset - called after the pci bus has been reset.
- * @pdev: Pointer to PCI device
- *
- * Restart the card from scratch, as if from a cold-boot.
- */
-static pci_ers_result_t bnx2_io_slot_reset(struct pci_dev *pdev)
-{
-	struct net_device *dev = pci_get_drvdata(pdev);
-	struct bnx2 *bp = netdev_priv(dev);
-
-	rtnl_lock();
-	if (pci_enable_device(pdev)) {
-		dev_err(&pdev->dev,
-			"Cannot re-enable PCI device after reset.\n");
-		rtnl_unlock();
-		return PCI_ERS_RESULT_DISCONNECT;
-	}
-	pci_set_master(pdev);
-	pci_restore_state(pdev);
-	pci_save_state(pdev);
-
-	if (netif_running(dev)) {
-		bnx2_set_power_state(bp, PCI_D0);
-		bnx2_init_nic(bp, 1);
-	}
-
-	rtnl_unlock();
-	return PCI_ERS_RESULT_RECOVERED;
-}
-
-/**
- * bnx2_io_resume - called when traffic can start flowing again.
- * @pdev: Pointer to PCI device
- *
- * This callback is called when the error recovery driver tells us that
- * its OK to resume normal operation.
- */
-static void bnx2_io_resume(struct pci_dev *pdev)
-{
-	struct net_device *dev = pci_get_drvdata(pdev);
-	struct bnx2 *bp = netdev_priv(dev);
-
-	rtnl_lock();
-	if (netif_running(dev))
-		bnx2_netif_start(bp);
-
-	netif_device_attach(dev);
-	rtnl_unlock();
-}
-
-static struct pci_error_handlers bnx2_err_handler = {
-	.error_detected	= bnx2_io_error_detected,
-	.slot_reset	= bnx2_io_slot_reset,
-	.resume		= bnx2_io_resume,
-};
-
-static struct pci_driver bnx2_pci_driver = {
-	.name		= DRV_MODULE_NAME,
-	.id_table	= bnx2_pci_tbl,
-	.probe		= bnx2_init_one,
-	.remove		= __devexit_p(bnx2_remove_one),
-	.suspend	= bnx2_suspend,
-	.resume		= bnx2_resume,
-	.err_handler	= &bnx2_err_handler,
-};
-
-static int __init bnx2_init(void)
-{
-	return pci_register_driver(&bnx2_pci_driver);
-}
-
-static void __exit bnx2_cleanup(void)
-{
-	pci_unregister_driver(&bnx2_pci_driver);
-}
-
-module_init(bnx2_init);
-module_exit(bnx2_cleanup);
-
-
-
diff -r f4bf81a7ff20 drivers/net/bnx2.h
--- a/drivers/net/bnx2.h
+++ /dev/null
@@ -1,7358 +0,0 @@
-/* bnx2.h: Broadcom NX2 network driver.
- *
- * Copyright (c) 2004-2009 Broadcom Corporation
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation.
- *
- * Written by: Michael Chan  (mchan@broadcom.com)
- */
-
-
-#ifndef BNX2_H
-#define BNX2_H
-
-/* Hardware data structures and register definitions automatically
- * generated from RTL code. Do not modify.
- */
-
-/*
- *  tx_bd definition
- */
-struct tx_bd {
-	u32 tx_bd_haddr_hi;
-	u32 tx_bd_haddr_lo;
-	u32 tx_bd_mss_nbytes;
-		#define TX_BD_TCP6_OFF2_SHL		(14)
-	u32 tx_bd_vlan_tag_flags;
-		#define TX_BD_FLAGS_CONN_FAULT		(1<<0)
-		#define TX_BD_FLAGS_TCP6_OFF0_MSK	(3<<1)
-		#define TX_BD_FLAGS_TCP6_OFF0_SHL	(1)
-		#define TX_BD_FLAGS_TCP_UDP_CKSUM	(1<<1)
-		#define TX_BD_FLAGS_IP_CKSUM		(1<<2)
-		#define TX_BD_FLAGS_VLAN_TAG		(1<<3)
-		#define TX_BD_FLAGS_COAL_NOW		(1<<4)
-		#define TX_BD_FLAGS_DONT_GEN_CRC	(1<<5)
-		#define TX_BD_FLAGS_END			(1<<6)
-		#define TX_BD_FLAGS_START		(1<<7)
-		#define TX_BD_FLAGS_SW_OPTION_WORD	(0x1f<<8)
-		#define TX_BD_FLAGS_TCP6_OFF4_SHL	(12)
-		#define TX_BD_FLAGS_SW_FLAGS		(1<<13)
-		#define TX_BD_FLAGS_SW_SNAP		(1<<14)
-		#define TX_BD_FLAGS_SW_LSO		(1<<15)
-
-};
-
-
-/*
- *  rx_bd definition
- */
-struct rx_bd {
-	u32 rx_bd_haddr_hi;
-	u32 rx_bd_haddr_lo;
-	u32 rx_bd_len;
-	u32 rx_bd_flags;
-		#define RX_BD_FLAGS_NOPUSH		(1<<0)
-		#define RX_BD_FLAGS_DUMMY		(1<<1)
-		#define RX_BD_FLAGS_END			(1<<2)
-		#define RX_BD_FLAGS_START		(1<<3)
-
-};
-
-#define BNX2_RX_ALIGN			16
-
-/*
- *  status_block definition
- */
-struct status_block {
-	u32 status_attn_bits;
-		#define STATUS_ATTN_BITS_LINK_STATE		(1L<<0)
-		#define STATUS_ATTN_BITS_TX_SCHEDULER_ABORT	(1L<<1)
-		#define STATUS_ATTN_BITS_TX_BD_READ_ABORT	(1L<<2)
-		#define STATUS_ATTN_BITS_TX_BD_CACHE_ABORT	(1L<<3)
-		#define STATUS_ATTN_BITS_TX_PROCESSOR_ABORT	(1L<<4)
-		#define STATUS_ATTN_BITS_TX_DMA_ABORT		(1L<<5)
-		#define STATUS_ATTN_BITS_TX_PATCHUP_ABORT	(1L<<6)
-		#define STATUS_ATTN_BITS_TX_ASSEMBLER_ABORT	(1L<<7)
-		#define STATUS_ATTN_BITS_RX_PARSER_MAC_ABORT	(1L<<8)
-		#define STATUS_ATTN_BITS_RX_PARSER_CATCHUP_ABORT	(1L<<9)
-		#define STATUS_ATTN_BITS_RX_MBUF_ABORT		(1L<<10)
-		#define STATUS_ATTN_BITS_RX_LOOKUP_ABORT	(1L<<11)
-		#define STATUS_ATTN_BITS_RX_PROCESSOR_ABORT	(1L<<12)
-		#define STATUS_ATTN_BITS_RX_V2P_ABORT		(1L<<13)
-		#define STATUS_ATTN_BITS_RX_BD_CACHE_ABORT	(1L<<14)
-		#define STATUS_ATTN_BITS_RX_DMA_ABORT		(1L<<15)
-		#define STATUS_ATTN_BITS_COMPLETION_ABORT	(1L<<16)
-		#define STATUS_ATTN_BITS_HOST_COALESCE_ABORT	(1L<<17)
-		#define STATUS_ATTN_BITS_MAILBOX_QUEUE_ABORT	(1L<<18)
-		#define STATUS_ATTN_BITS_CONTEXT_ABORT		(1L<<19)
-		#define STATUS_ATTN_BITS_CMD_SCHEDULER_ABORT	(1L<<20)
-		#define STATUS_ATTN_BITS_CMD_PROCESSOR_ABORT	(1L<<21)
-		#define STATUS_ATTN_BITS_MGMT_PROCESSOR_ABORT	(1L<<22)
-		#define STATUS_ATTN_BITS_MAC_ABORT		(1L<<23)
-		#define STATUS_ATTN_BITS_TIMER_ABORT		(1L<<24)
-		#define STATUS_ATTN_BITS_DMAE_ABORT		(1L<<25)
-		#define STATUS_ATTN_BITS_FLSH_ABORT		(1L<<26)
-		#define STATUS_ATTN_BITS_GRC_ABORT		(1L<<27)
-		#define STATUS_ATTN_BITS_EPB_ERROR		(1L<<30)
-		#define STATUS_ATTN_BITS_PARITY_ERROR		(1L<<31)
-
-	u32 status_attn_bits_ack;
-#if defined(__BIG_ENDIAN)
-	u16 status_tx_quick_consumer_index0;
-	u16 status_tx_quick_consumer_index1;
-	u16 status_tx_quick_consumer_index2;
-	u16 status_tx_quick_consumer_index3;
-	u16 status_rx_quick_consumer_index0;
-	u16 status_rx_quick_consumer_index1;
-	u16 status_rx_quick_consumer_index2;
-	u16 status_rx_quick_consumer_index3;
-	u16 status_rx_quick_consumer_index4;
-	u16 status_rx_quick_consumer_index5;
-	u16 status_rx_quick_consumer_index6;
-	u16 status_rx_quick_consumer_index7;
-	u16 status_rx_quick_consumer_index8;
-	u16 status_rx_quick_consumer_index9;
-	u16 status_rx_quick_consumer_index10;
-	u16 status_rx_quick_consumer_index11;
-	u16 status_rx_quick_consumer_index12;
-	u16 status_rx_quick_consumer_index13;
-	u16 status_rx_quick_consumer_index14;
-	u16 status_rx_quick_consumer_index15;
-	u16 status_completion_producer_index;
-	u16 status_cmd_consumer_index;
-	u16 status_idx;
-	u8 status_unused;
-	u8 status_blk_num;
-#elif defined(__LITTLE_ENDIAN)
-	u16 status_tx_quick_consumer_index1;
-	u16 status_tx_quick_consumer_index0;
-	u16 status_tx_quick_consumer_index3;
-	u16 status_tx_quick_consumer_index2;
-	u16 status_rx_quick_consumer_index1;
-	u16 status_rx_quick_consumer_index0;
-	u16 status_rx_quick_consumer_index3;
-	u16 status_rx_quick_consumer_index2;
-	u16 status_rx_quick_consumer_index5;
-	u16 status_rx_quick_consumer_index4;
-	u16 status_rx_quick_consumer_index7;
-	u16 status_rx_quick_consumer_index6;
-	u16 status_rx_quick_consumer_index9;
-	u16 status_rx_quick_consumer_index8;
-	u16 status_rx_quick_consumer_index11;
-	u16 status_rx_quick_consumer_index10;
-	u16 status_rx_quick_consumer_index13;
-	u16 status_rx_quick_consumer_index12;
-	u16 status_rx_quick_consumer_index15;
-	u16 status_rx_quick_consumer_index14;
-	u16 status_cmd_consumer_index;
-	u16 status_completion_producer_index;
-	u8 status_blk_num;
-	u8 status_unused;
-	u16 status_idx;
-#endif
-};
-
-/*
- *  status_block definition
- */
-struct status_block_msix {
-#if defined(__BIG_ENDIAN)
-	u16 status_tx_quick_consumer_index;
-	u16 status_rx_quick_consumer_index;
-	u16 status_completion_producer_index;
-	u16 status_cmd_consumer_index;
-	u32 status_unused;
-	u16 status_idx;
-	u8 status_unused2;
-	u8 status_blk_num;
-#elif defined(__LITTLE_ENDIAN)
-	u16 status_rx_quick_consumer_index;
-	u16 status_tx_quick_consumer_index;
-	u16 status_cmd_consumer_index;
-	u16 status_completion_producer_index;
-	u32 status_unused;
-	u8 status_blk_num;
-	u8 status_unused2;
-	u16 status_idx;
-#endif
-};
-
-#define BNX2_SBLK_MSIX_ALIGN_SIZE	128
-
-
-/*
- *  statistics_block definition
- */
-struct statistics_block {
-	u32 stat_IfHCInOctets_hi;
-	u32 stat_IfHCInOctets_lo;
-	u32 stat_IfHCInBadOctets_hi;
-	u32 stat_IfHCInBadOctets_lo;
-	u32 stat_IfHCOutOctets_hi;
-	u32 stat_IfHCOutOctets_lo;
-	u32 stat_IfHCOutBadOctets_hi;
-	u32 stat_IfHCOutBadOctets_lo;
-	u32 stat_IfHCInUcastPkts_hi;
-	u32 stat_IfHCInUcastPkts_lo;
-	u32 stat_IfHCInMulticastPkts_hi;
-	u32 stat_IfHCInMulticastPkts_lo;
-	u32 stat_IfHCInBroadcastPkts_hi;
-	u32 stat_IfHCInBroadcastPkts_lo;
-	u32 stat_IfHCOutUcastPkts_hi;
-	u32 stat_IfHCOutUcastPkts_lo;
-	u32 stat_IfHCOutMulticastPkts_hi;
-	u32 stat_IfHCOutMulticastPkts_lo;
-	u32 stat_IfHCOutBroadcastPkts_hi;
-	u32 stat_IfHCOutBroadcastPkts_lo;
-	u32 stat_emac_tx_stat_dot3statsinternalmactransmiterrors;
-	u32 stat_Dot3StatsCarrierSenseErrors;
-	u32 stat_Dot3StatsFCSErrors;
-	u32 stat_Dot3StatsAlignmentErrors;
-	u32 stat_Dot3StatsSingleCollisionFrames;
-	u32 stat_Dot3StatsMultipleCollisionFrames;
-	u32 stat_Dot3StatsDeferredTransmissions;
-	u32 stat_Dot3StatsExcessiveCollisions;
-	u32 stat_Dot3StatsLateCollisions;
-	u32 stat_EtherStatsCollisions;
-	u32 stat_EtherStatsFragments;
-	u32 stat_EtherStatsJabbers;
-	u32 stat_EtherStatsUndersizePkts;
-	u32 stat_EtherStatsOverrsizePkts;
-	u32 stat_EtherStatsPktsRx64Octets;
-	u32 stat_EtherStatsPktsRx65Octetsto127Octets;
-	u32 stat_EtherStatsPktsRx128Octetsto255Octets;
-	u32 stat_EtherStatsPktsRx256Octetsto511Octets;
-	u32 stat_EtherStatsPktsRx512Octetsto1023Octets;
-	u32 stat_EtherStatsPktsRx1024Octetsto1522Octets;
-	u32 stat_EtherStatsPktsRx1523Octetsto9022Octets;
-	u32 stat_EtherStatsPktsTx64Octets;
-	u32 stat_EtherStatsPktsTx65Octetsto127Octets;
-	u32 stat_EtherStatsPktsTx128Octetsto255Octets;
-	u32 stat_EtherStatsPktsTx256Octetsto511Octets;
-	u32 stat_EtherStatsPktsTx512Octetsto1023Octets;
-	u32 stat_EtherStatsPktsTx1024Octetsto1522Octets;
-	u32 stat_EtherStatsPktsTx1523Octetsto9022Octets;
-	u32 stat_XonPauseFramesReceived;
-	u32 stat_XoffPauseFramesReceived;
-	u32 stat_OutXonSent;
-	u32 stat_OutXoffSent;
-	u32 stat_FlowControlDone;
-	u32 stat_MacControlFramesReceived;
-	u32 stat_XoffStateEntered;
-	u32 stat_IfInFramesL2FilterDiscards;
-	u32 stat_IfInRuleCheckerDiscards;
-	u32 stat_IfInFTQDiscards;
-	u32 stat_IfInMBUFDiscards;
-	u32 stat_IfInRuleCheckerP4Hit;
-	u32 stat_CatchupInRuleCheckerDiscards;
-	u32 stat_CatchupInFTQDiscards;
-	u32 stat_CatchupInMBUFDiscards;
-	u32 stat_CatchupInRuleCheckerP4Hit;
-	u32 stat_GenStat00;
-	u32 stat_GenStat01;
-	u32 stat_GenStat02;
-	u32 stat_GenStat03;
-	u32 stat_GenStat04;
-	u32 stat_GenStat05;
-	u32 stat_GenStat06;
-	u32 stat_GenStat07;
-	u32 stat_GenStat08;
-	u32 stat_GenStat09;
-	u32 stat_GenStat10;
-	u32 stat_GenStat11;
-	u32 stat_GenStat12;
-	u32 stat_GenStat13;
-	u32 stat_GenStat14;
-	u32 stat_GenStat15;
-	u32 stat_FwRxDrop;
-};
-
-
-/*
- *  l2_fhdr definition
- */
-struct l2_fhdr {
-	u32 l2_fhdr_status;
-		#define L2_FHDR_STATUS_RULE_CLASS	(0x7<<0)
-		#define L2_FHDR_STATUS_RULE_P2		(1<<3)
-		#define L2_FHDR_STATUS_RULE_P3		(1<<4)
-		#define L2_FHDR_STATUS_RULE_P4		(1<<5)
-		#define L2_FHDR_STATUS_L2_VLAN_TAG	(1<<6)
-		#define L2_FHDR_STATUS_L2_LLC_SNAP	(1<<7)
-		#define L2_FHDR_STATUS_RSS_HASH		(1<<8)
-		#define L2_FHDR_STATUS_IP_DATAGRAM	(1<<13)
-		#define L2_FHDR_STATUS_TCP_SEGMENT	(1<<14)
-		#define L2_FHDR_STATUS_UDP_DATAGRAM	(1<<15)
-
-		#define L2_FHDR_STATUS_SPLIT		(1<<16)
-		#define L2_FHDR_ERRORS_BAD_CRC		(1<<17)
-		#define L2_FHDR_ERRORS_PHY_DECODE	(1<<18)
-		#define L2_FHDR_ERRORS_ALIGNMENT	(1<<19)
-		#define L2_FHDR_ERRORS_TOO_SHORT	(1<<20)
-		#define L2_FHDR_ERRORS_GIANT_FRAME	(1<<21)
-		#define L2_FHDR_ERRORS_TCP_XSUM		(1<<28)
-		#define L2_FHDR_ERRORS_UDP_XSUM		(1<<31)
-
-	u32 l2_fhdr_hash;
-#if defined(__BIG_ENDIAN)
-	u16 l2_fhdr_pkt_len;
-	u16 l2_fhdr_vlan_tag;
-	u16 l2_fhdr_ip_xsum;
-	u16 l2_fhdr_tcp_udp_xsum;
-#elif defined(__LITTLE_ENDIAN)
-	u16 l2_fhdr_vlan_tag;
-	u16 l2_fhdr_pkt_len;
-	u16 l2_fhdr_tcp_udp_xsum;
-	u16 l2_fhdr_ip_xsum;
-#endif
-};
-
-#define BNX2_RX_OFFSET		(sizeof(struct l2_fhdr) + 2)
-
-/*
- *  l2_context definition
- */
-#define BNX2_L2CTX_TYPE					0x00000000
-#define BNX2_L2CTX_TYPE_SIZE_L2				 ((0xc0/0x20)<<16)
-#define BNX2_L2CTX_TYPE_TYPE				 (0xf<<28)
-#define BNX2_L2CTX_TYPE_TYPE_EMPTY			 (0<<28)
-#define BNX2_L2CTX_TYPE_TYPE_L2				 (1<<28)
-
-#define BNX2_L2CTX_TX_HOST_BIDX				0x00000088
-#define BNX2_L2CTX_EST_NBD				0x00000088
-#define BNX2_L2CTX_CMD_TYPE				0x00000088
-#define BNX2_L2CTX_CMD_TYPE_TYPE			 (0xf<<24)
-#define BNX2_L2CTX_CMD_TYPE_TYPE_L2			 (0<<24)
-#define BNX2_L2CTX_CMD_TYPE_TYPE_TCP			 (1<<24)
-
-#define BNX2_L2CTX_TX_HOST_BSEQ				0x00000090
-#define BNX2_L2CTX_TSCH_BSEQ				0x00000094
-#define BNX2_L2CTX_TBDR_BSEQ				0x00000098
-#define BNX2_L2CTX_TBDR_BOFF				0x0000009c
-#define BNX2_L2CTX_TBDR_BIDX				0x0000009c
-#define BNX2_L2CTX_TBDR_BHADDR_HI			0x000000a0
-#define BNX2_L2CTX_TBDR_BHADDR_LO			0x000000a4
-#define BNX2_L2CTX_TXP_BOFF				0x000000a8
-#define BNX2_L2CTX_TXP_BIDX				0x000000a8
-#define BNX2_L2CTX_TXP_BSEQ				0x000000ac
-
-#define BNX2_L2CTX_TYPE_XI				0x00000080
-#define BNX2_L2CTX_CMD_TYPE_XI				0x00000240
-#define BNX2_L2CTX_TBDR_BHADDR_HI_XI			0x00000258
-#define BNX2_L2CTX_TBDR_BHADDR_LO_XI			0x0000025c
-
-/*
- *  l2_bd_chain_context definition
- */
-#define BNX2_L2CTX_BD_PRE_READ				0x00000000
-#define BNX2_L2CTX_CTX_SIZE				0x00000000
-#define BNX2_L2CTX_CTX_TYPE				0x00000000
-#define BNX2_L2CTX_LO_WATER_MARK_DEFAULT		 4
-#define BNX2_L2CTX_LO_WATER_MARK_SCALE			 4
-#define BNX2_L2CTX_LO_WATER_MARK_DIS			 0
-#define BNX2_L2CTX_HI_WATER_MARK_SHIFT			 4
-#define BNX2_L2CTX_HI_WATER_MARK_SCALE			 16
-#define BNX2_L2CTX_WATER_MARKS_MSK			 0x000000ff
-#define BNX2_L2CTX_CTX_TYPE_SIZE_L2			 ((0x20/20)<<16)
-#define BNX2_L2CTX_CTX_TYPE_CTX_BD_CHN_TYPE		 (0xf<<28)
-#define BNX2_L2CTX_CTX_TYPE_CTX_BD_CHN_TYPE_UNDEFINED	 (0<<28)
-#define BNX2_L2CTX_CTX_TYPE_CTX_BD_CHN_TYPE_VALUE	 (1<<28)
-
-#define BNX2_L2CTX_HOST_BDIDX				0x00000004
-#define BNX2_L2CTX_L5_STATUSB_NUM_SHIFT			 16
-#define BNX2_L2CTX_L2_STATUSB_NUM_SHIFT			 24
-#define BNX2_L2CTX_L5_STATUSB_NUM(sb_id)		\
-	(((sb_id) > 0) ? (((sb_id) + 7) << BNX2_L2CTX_L5_STATUSB_NUM_SHIFT) : 0)
-#define BNX2_L2CTX_L2_STATUSB_NUM(sb_id)		\
-	(((sb_id) > 0) ? (((sb_id) + 7) << BNX2_L2CTX_L2_STATUSB_NUM_SHIFT) : 0)
-#define BNX2_L2CTX_HOST_BSEQ				0x00000008
-#define BNX2_L2CTX_NX_BSEQ				0x0000000c
-#define BNX2_L2CTX_NX_BDHADDR_HI			0x00000010
-#define BNX2_L2CTX_NX_BDHADDR_LO			0x00000014
-#define BNX2_L2CTX_NX_BDIDX				0x00000018
-
-#define BNX2_L2CTX_HOST_PG_BDIDX			0x00000044
-#define BNX2_L2CTX_PG_BUF_SIZE				0x00000048
-#define BNX2_L2CTX_RBDC_KEY				0x0000004c
-#define BNX2_L2CTX_RBDC_JUMBO_KEY			 0x3ffe
-#define BNX2_L2CTX_NX_PG_BDHADDR_HI			0x00000050
-#define BNX2_L2CTX_NX_PG_BDHADDR_LO			0x00000054
-
-/*
- *  pci_config_l definition
- *  offset: 0000
- */
-#define BNX2_PCICFG_MSI_CONTROL				0x00000058
-#define BNX2_PCICFG_MSI_CONTROL_ENABLE			 (1L<<16)
-
-#define BNX2_PCICFG_MISC_CONFIG				0x00000068
-#define BNX2_PCICFG_MISC_CONFIG_TARGET_BYTE_SWAP	 (1L<<2)
-#define BNX2_PCICFG_MISC_CONFIG_TARGET_MB_WORD_SWAP	 (1L<<3)
-#define BNX2_PCICFG_MISC_CONFIG_RESERVED1		 (1L<<4)
-#define BNX2_PCICFG_MISC_CONFIG_CLOCK_CTL_ENA		 (1L<<5)
-#define BNX2_PCICFG_MISC_CONFIG_TARGET_GRC_WORD_SWAP	 (1L<<6)
-#define BNX2_PCICFG_MISC_CONFIG_REG_WINDOW_ENA		 (1L<<7)
-#define BNX2_PCICFG_MISC_CONFIG_CORE_RST_REQ		 (1L<<8)
-#define BNX2_PCICFG_MISC_CONFIG_CORE_RST_BSY		 (1L<<9)
-#define BNX2_PCICFG_MISC_CONFIG_GRC_WIN1_SWAP_EN	 (1L<<10)
-#define BNX2_PCICFG_MISC_CONFIG_GRC_WIN2_SWAP_EN	 (1L<<11)
-#define BNX2_PCICFG_MISC_CONFIG_GRC_WIN3_SWAP_EN	 (1L<<12)
-#define BNX2_PCICFG_MISC_CONFIG_ASIC_METAL_REV		 (0xffL<<16)
-#define BNX2_PCICFG_MISC_CONFIG_ASIC_BASE_REV		 (0xfL<<24)
-#define BNX2_PCICFG_MISC_CONFIG_ASIC_ID			 (0xfL<<28)
-
-#define BNX2_PCICFG_MISC_STATUS				0x0000006c
-#define BNX2_PCICFG_MISC_STATUS_INTA_VALUE		 (1L<<0)
-#define BNX2_PCICFG_MISC_STATUS_32BIT_DET		 (1L<<1)
-#define BNX2_PCICFG_MISC_STATUS_M66EN			 (1L<<2)
-#define BNX2_PCICFG_MISC_STATUS_PCIX_DET		 (1L<<3)
-#define BNX2_PCICFG_MISC_STATUS_PCIX_SPEED		 (0x3L<<4)
-#define BNX2_PCICFG_MISC_STATUS_PCIX_SPEED_66		 (0L<<4)
-#define BNX2_PCICFG_MISC_STATUS_PCIX_SPEED_100		 (1L<<4)
-#define BNX2_PCICFG_MISC_STATUS_PCIX_SPEED_133		 (2L<<4)
-#define BNX2_PCICFG_MISC_STATUS_PCIX_SPEED_PCI_MODE	 (3L<<4)
-#define BNX2_PCICFG_MISC_STATUS_BAD_MEM_WRITE_BE	 (1L<<8)
-
-#define BNX2_PCICFG_PCI_CLOCK_CONTROL_BITS		0x00000070
-#define BNX2_PCICFG_PCI_CLOCK_CONTROL_BITS_PCI_CLK_SPD_DET	 (0xfL<<0)
-#define BNX2_PCICFG_PCI_CLOCK_CONTROL_BITS_PCI_CLK_SPD_DET_32MHZ	 (0L<<0)
-#define BNX2_PCICFG_PCI_CLOCK_CONTROL_BITS_PCI_CLK_SPD_DET_38MHZ	 (1L<<0)
-#define BNX2_PCICFG_PCI_CLOCK_CONTROL_BITS_PCI_CLK_SPD_DET_48MHZ	 (2L<<0)
-#define BNX2_PCICFG_PCI_CLOCK_CONTROL_BITS_PCI_CLK_SPD_DET_55MHZ	 (3L<<0)
-#define BNX2_PCICFG_PCI_CLOCK_CONTROL_BITS_PCI_CLK_SPD_DET_66MHZ	 (4L<<0)
-#define BNX2_PCICFG_PCI_CLOCK_CONTROL_BITS_PCI_CLK_SPD_DET_80MHZ	 (5L<<0)
-#define BNX2_PCICFG_PCI_CLOCK_CONTROL_BITS_PCI_CLK_SPD_DET_95MHZ	 (6L<<0)
-#define BNX2_PCICFG_PCI_CLOCK_CONTROL_BITS_PCI_CLK_SPD_DET_133MHZ	 (7L<<0)
-#define BNX2_PCICFG_PCI_CLOCK_CONTROL_BITS_PCI_CLK_SPD_DET_LOW	 (0xfL<<0)
-#define BNX2_PCICFG_PCI_CLOCK_CONTROL_BITS_CORE_CLK_DISABLE	 (1L<<6)
-#define BNX2_PCICFG_PCI_CLOCK_CONTROL_BITS_CORE_CLK_ALT	 (1L<<7)
-#define BNX2_PCICFG_PCI_CLOCK_CONTROL_BITS_CORE_CLK_ALT_SRC	 (0x7L<<8)
-#define BNX2_PCICFG_PCI_CLOCK_CONTROL_BITS_CORE_CLK_ALT_SRC_UNDEF	 (0L<<8)
-#define BNX2_PCICFG_PCI_CLOCK_CONTROL_BITS_CORE_CLK_ALT_SRC_12	 (1L<<8)
-#define BNX2_PCICFG_PCI_CLOCK_CONTROL_BITS_CORE_CLK_ALT_SRC_6	 (2L<<8)
-#define BNX2_PCICFG_PCI_CLOCK_CONTROL_BITS_CORE_CLK_ALT_SRC_62	 (4L<<8)
-#define BNX2_PCICFG_PCI_CLOCK_CONTROL_BITS_MIN_POWER	 (1L<<11)
-#define BNX2_PCICFG_PCI_CLOCK_CONTROL_BITS_CORE_CLK_PLL_SPEED	 (0xfL<<12)
-#define BNX2_PCICFG_PCI_CLOCK_CONTROL_BITS_CORE_CLK_PLL_SPEED_100	 (0L<<12)
-#define BNX2_PCICFG_PCI_CLOCK_CONTROL_BITS_CORE_CLK_PLL_SPEED_80	 (1L<<12)
-#define BNX2_PCICFG_PCI_CLOCK_CONTROL_BITS_CORE_CLK_PLL_SPEED_50	 (2L<<12)
-#define BNX2_PCICFG_PCI_CLOCK_CONTROL_BITS_CORE_CLK_PLL_SPEED_40	 (4L<<12)
-#define BNX2_PCICFG_PCI_CLOCK_CONTROL_BITS_CORE_CLK_PLL_SPEED_25	 (8L<<12)
-#define BNX2_PCICFG_PCI_CLOCK_CONTROL_BITS_CORE_CLK_PLL_STOP	 (1L<<16)
-#define BNX2_PCICFG_PCI_CLOCK_CONTROL_BITS_RESERVED_17	 (1L<<17)
-#define BNX2_PCICFG_PCI_CLOCK_CONTROL_BITS_RESERVED_18	 (1L<<18)
-#define BNX2_PCICFG_PCI_CLOCK_CONTROL_BITS_RESERVED_19	 (1L<<19)
-#define BNX2_PCICFG_PCI_CLOCK_CONTROL_BITS_RESERVED	 (0xfffL<<20)
-
-#define BNX2_PCICFG_REG_WINDOW_ADDRESS			0x00000078
-#define BNX2_PCICFG_REG_WINDOW_ADDRESS_VAL		 (0xfffffL<<2)
-
-#define BNX2_PCICFG_REG_WINDOW				0x00000080
-#define BNX2_PCICFG_INT_ACK_CMD				0x00000084
-#define BNX2_PCICFG_INT_ACK_CMD_INDEX			 (0xffffL<<0)
-#define BNX2_PCICFG_INT_ACK_CMD_INDEX_VALID		 (1L<<16)
-#define BNX2_PCICFG_INT_ACK_CMD_USE_INT_HC_PARAM	 (1L<<17)
-#define BNX2_PCICFG_INT_ACK_CMD_MASK_INT		 (1L<<18)
-#define BNX2_PCICFG_INT_ACK_CMD_INTERRUPT_NUM		 (0xfL<<24)
-#define BNX2_PCICFG_INT_ACK_CMD_INT_NUM_SHIFT		 24
-
-#define BNX2_PCICFG_STATUS_BIT_SET_CMD			0x00000088
-#define BNX2_PCICFG_STATUS_BIT_CLEAR_CMD		0x0000008c
-#define BNX2_PCICFG_MAILBOX_QUEUE_ADDR			0x00000090
-#define BNX2_PCICFG_MAILBOX_QUEUE_DATA			0x00000094
-
-
-/*
- *  pci_reg definition
- *  offset: 0x400
- */
-#define BNX2_PCI_GRC_WINDOW_ADDR			0x00000400
-#define BNX2_PCI_GRC_WINDOW_ADDR_VALUE			 (0x1ffL<<13)
-#define BNX2_PCI_GRC_WINDOW_ADDR_SEP_WIN		 (1L<<31)
-
-#define BNX2_PCI_GRC_WINDOW2_BASE		 	 0xc000
-#define BNX2_PCI_GRC_WINDOW3_BASE		 	 0xe000
-
-#define BNX2_PCI_CONFIG_1				0x00000404
-#define BNX2_PCI_CONFIG_1_RESERVED0			 (0xffL<<0)
-#define BNX2_PCI_CONFIG_1_READ_BOUNDARY			 (0x7L<<8)
-#define BNX2_PCI_CONFIG_1_READ_BOUNDARY_OFF		 (0L<<8)
-#define BNX2_PCI_CONFIG_1_READ_BOUNDARY_16		 (1L<<8)
-#define BNX2_PCI_CONFIG_1_READ_BOUNDARY_32		 (2L<<8)
-#define BNX2_PCI_CONFIG_1_READ_BOUNDARY_64		 (3L<<8)
-#define BNX2_PCI_CONFIG_1_READ_BOUNDARY_128		 (4L<<8)
-#define BNX2_PCI_CONFIG_1_READ_BOUNDARY_256		 (5L<<8)
-#define BNX2_PCI_CONFIG_1_READ_BOUNDARY_512		 (6L<<8)
-#define BNX2_PCI_CONFIG_1_READ_BOUNDARY_1024		 (7L<<8)
-#define BNX2_PCI_CONFIG_1_WRITE_BOUNDARY		 (0x7L<<11)
-#define BNX2_PCI_CONFIG_1_WRITE_BOUNDARY_OFF		 (0L<<11)
-#define BNX2_PCI_CONFIG_1_WRITE_BOUNDARY_16		 (1L<<11)
-#define BNX2_PCI_CONFIG_1_WRITE_BOUNDARY_32		 (2L<<11)
-#define BNX2_PCI_CONFIG_1_WRITE_BOUNDARY_64		 (3L<<11)
-#define BNX2_PCI_CONFIG_1_WRITE_BOUNDARY_128		 (4L<<11)
-#define BNX2_PCI_CONFIG_1_WRITE_BOUNDARY_256		 (5L<<11)
-#define BNX2_PCI_CONFIG_1_WRITE_BOUNDARY_512		 (6L<<11)
-#define BNX2_PCI_CONFIG_1_WRITE_BOUNDARY_1024		 (7L<<11)
-#define BNX2_PCI_CONFIG_1_RESERVED1			 (0x3ffffL<<14)
-
-#define BNX2_PCI_CONFIG_2				0x00000408
-#define BNX2_PCI_CONFIG_2_BAR1_SIZE			 (0xfL<<0)
-#define BNX2_PCI_CONFIG_2_BAR1_SIZE_DISABLED		 (0L<<0)
-#define BNX2_PCI_CONFIG_2_BAR1_SIZE_64K			 (1L<<0)
-#define BNX2_PCI_CONFIG_2_BAR1_SIZE_128K		 (2L<<0)
-#define BNX2_PCI_CONFIG_2_BAR1_SIZE_256K		 (3L<<0)
-#define BNX2_PCI_CONFIG_2_BAR1_SIZE_512K		 (4L<<0)
-#define BNX2_PCI_CONFIG_2_BAR1_SIZE_1M			 (5L<<0)
-#define BNX2_PCI_CONFIG_2_BAR1_SIZE_2M			 (6L<<0)
-#define BNX2_PCI_CONFIG_2_BAR1_SIZE_4M			 (7L<<0)
-#define BNX2_PCI_CONFIG_2_BAR1_SIZE_8M			 (8L<<0)
-#define BNX2_PCI_CONFIG_2_BAR1_SIZE_16M			 (9L<<0)
-#define BNX2_PCI_CONFIG_2_BAR1_SIZE_32M			 (10L<<0)
-#define BNX2_PCI_CONFIG_2_BAR1_SIZE_64M			 (11L<<0)
-#define BNX2_PCI_CONFIG_2_BAR1_SIZE_128M		 (12L<<0)
-#define BNX2_PCI_CONFIG_2_BAR1_SIZE_256M		 (13L<<0)
-#define BNX2_PCI_CONFIG_2_BAR1_SIZE_512M		 (14L<<0)
-#define BNX2_PCI_CONFIG_2_BAR1_SIZE_1G			 (15L<<0)
-#define BNX2_PCI_CONFIG_2_BAR1_64ENA			 (1L<<4)
-#define BNX2_PCI_CONFIG_2_EXP_ROM_RETRY			 (1L<<5)
-#define BNX2_PCI_CONFIG_2_CFG_CYCLE_RETRY		 (1L<<6)
-#define BNX2_PCI_CONFIG_2_FIRST_CFG_DONE		 (1L<<7)
-#define BNX2_PCI_CONFIG_2_EXP_ROM_SIZE			 (0xffL<<8)
-#define BNX2_PCI_CONFIG_2_EXP_ROM_SIZE_DISABLED		 (0L<<8)
-#define BNX2_PCI_CONFIG_2_EXP_ROM_SIZE_1K		 (1L<<8)
-#define BNX2_PCI_CONFIG_2_EXP_ROM_SIZE_2K		 (2L<<8)
-#define BNX2_PCI_CONFIG_2_EXP_ROM_SIZE_4K		 (3L<<8)
-#define BNX2_PCI_CONFIG_2_EXP_ROM_SIZE_8K		 (4L<<8)
-#define BNX2_PCI_CONFIG_2_EXP_ROM_SIZE_16K		 (5L<<8)
-#define BNX2_PCI_CONFIG_2_EXP_ROM_SIZE_32K		 (6L<<8)
-#define BNX2_PCI_CONFIG_2_EXP_ROM_SIZE_64K		 (7L<<8)
-#define BNX2_PCI_CONFIG_2_EXP_ROM_SIZE_128K		 (8L<<8)
-#define BNX2_PCI_CONFIG_2_EXP_ROM_SIZE_256K		 (9L<<8)
-#define BNX2_PCI_CONFIG_2_EXP_ROM_SIZE_512K		 (10L<<8)
-#define BNX2_PCI_CONFIG_2_EXP_ROM_SIZE_1M		 (11L<<8)
-#define BNX2_PCI_CONFIG_2_EXP_ROM_SIZE_2M		 (12L<<8)
-#define BNX2_PCI_CONFIG_2_EXP_ROM_SIZE_4M		 (13L<<8)
-#define BNX2_PCI_CONFIG_2_EXP_ROM_SIZE_8M		 (14L<<8)
-#define BNX2_PCI_CONFIG_2_EXP_ROM_SIZE_16M		 (15L<<8)
-#define BNX2_PCI_CONFIG_2_MAX_SPLIT_LIMIT		 (0x1fL<<16)
-#define BNX2_PCI_CONFIG_2_MAX_READ_LIMIT		 (0x3L<<21)
-#define BNX2_PCI_CONFIG_2_MAX_READ_LIMIT_512		 (0L<<21)
-#define BNX2_PCI_CONFIG_2_MAX_READ_LIMIT_1K		 (1L<<21)
-#define BNX2_PCI_CONFIG_2_MAX_READ_LIMIT_2K		 (2L<<21)
-#define BNX2_PCI_CONFIG_2_MAX_READ_LIMIT_4K		 (3L<<21)
-#define BNX2_PCI_CONFIG_2_FORCE_32_BIT_MSTR		 (1L<<23)
-#define BNX2_PCI_CONFIG_2_FORCE_32_BIT_TGT		 (1L<<24)
-#define BNX2_PCI_CONFIG_2_KEEP_REQ_ASSERT		 (1L<<25)
-#define BNX2_PCI_CONFIG_2_RESERVED0			 (0x3fL<<26)
-#define BNX2_PCI_CONFIG_2_BAR_PREFETCH_XI		 (1L<<16)
-#define BNX2_PCI_CONFIG_2_RESERVED0_XI			 (0x7fffL<<17)
-
-#define BNX2_PCI_CONFIG_3				0x0000040c
-#define BNX2_PCI_CONFIG_3_STICKY_BYTE			 (0xffL<<0)
-#define BNX2_PCI_CONFIG_3_REG_STICKY_BYTE		 (0xffL<<8)
-#define BNX2_PCI_CONFIG_3_FORCE_PME			 (1L<<24)
-#define BNX2_PCI_CONFIG_3_PME_STATUS			 (1L<<25)
-#define BNX2_PCI_CONFIG_3_PME_ENABLE			 (1L<<26)
-#define BNX2_PCI_CONFIG_3_PM_STATE			 (0x3L<<27)
-#define BNX2_PCI_CONFIG_3_VAUX_PRESET			 (1L<<30)
-#define BNX2_PCI_CONFIG_3_PCI_POWER			 (1L<<31)
-
-#define BNX2_PCI_PM_DATA_A				0x00000410
-#define BNX2_PCI_PM_DATA_A_PM_DATA_0_PRG		 (0xffL<<0)
-#define BNX2_PCI_PM_DATA_A_PM_DATA_1_PRG		 (0xffL<<8)
-#define BNX2_PCI_PM_DATA_A_PM_DATA_2_PRG		 (0xffL<<16)
-#define BNX2_PCI_PM_DATA_A_PM_DATA_3_PRG		 (0xffL<<24)
-
-#define BNX2_PCI_PM_DATA_B				0x00000414
-#define BNX2_PCI_PM_DATA_B_PM_DATA_4_PRG		 (0xffL<<0)
-#define BNX2_PCI_PM_DATA_B_PM_DATA_5_PRG		 (0xffL<<8)
-#define BNX2_PCI_PM_DATA_B_PM_DATA_6_PRG		 (0xffL<<16)
-#define BNX2_PCI_PM_DATA_B_PM_DATA_7_PRG		 (0xffL<<24)
-
-#define BNX2_PCI_SWAP_DIAG0				0x00000418
-#define BNX2_PCI_SWAP_DIAG1				0x0000041c
-#define BNX2_PCI_EXP_ROM_ADDR				0x00000420
-#define BNX2_PCI_EXP_ROM_ADDR_ADDRESS			 (0x3fffffL<<2)
-#define BNX2_PCI_EXP_ROM_ADDR_REQ			 (1L<<31)
-
-#define BNX2_PCI_EXP_ROM_DATA				0x00000424
-#define BNX2_PCI_VPD_INTF				0x00000428
-#define BNX2_PCI_VPD_INTF_INTF_REQ			 (1L<<0)
-
-#define BNX2_PCI_VPD_ADDR_FLAG				0x0000042c
-#define BNX2_PCI_VPD_ADDR_FLAG_MSK			0x0000ffff
-#define BNX2_PCI_VPD_ADDR_FLAG_SL			0L
-#define BNX2_PCI_VPD_ADDR_FLAG_ADDRESS			 (0x1fffL<<2)
-#define BNX2_PCI_VPD_ADDR_FLAG_WR			 (1L<<15)
-
-#define BNX2_PCI_VPD_DATA				0x00000430
-#define BNX2_PCI_ID_VAL1				0x00000434
-#define BNX2_PCI_ID_VAL1_DEVICE_ID			 (0xffffL<<0)
-#define BNX2_PCI_ID_VAL1_VENDOR_ID			 (0xffffL<<16)
-
-#define BNX2_PCI_ID_VAL2				0x00000438
-#define BNX2_PCI_ID_VAL2_SUBSYSTEM_VENDOR_ID		 (0xffffL<<0)
-#define BNX2_PCI_ID_VAL2_SUBSYSTEM_ID			 (0xffffL<<16)
-
-#define BNX2_PCI_ID_VAL3				0x0000043c
-#define BNX2_PCI_ID_VAL3_CLASS_CODE			 (0xffffffL<<0)
-#define BNX2_PCI_ID_VAL3_REVISION_ID			 (0xffL<<24)
-
-#define BNX2_PCI_ID_VAL4				0x00000440
-#define BNX2_PCI_ID_VAL4_CAP_ENA			 (0xfL<<0)
-#define BNX2_PCI_ID_VAL4_CAP_ENA_0			 (0L<<0)
-#define BNX2_PCI_ID_VAL4_CAP_ENA_1			 (1L<<0)
-#define BNX2_PCI_ID_VAL4_CAP_ENA_2			 (2L<<0)
-#define BNX2_PCI_ID_VAL4_CAP_ENA_3			 (3L<<0)
-#define BNX2_PCI_ID_VAL4_CAP_ENA_4			 (4L<<0)
-#define BNX2_PCI_ID_VAL4_CAP_ENA_5			 (5L<<0)
-#define BNX2_PCI_ID_VAL4_CAP_ENA_6			 (6L<<0)
-#define BNX2_PCI_ID_VAL4_CAP_ENA_7			 (7L<<0)
-#define BNX2_PCI_ID_VAL4_CAP_ENA_8			 (8L<<0)
-#define BNX2_PCI_ID_VAL4_CAP_ENA_9			 (9L<<0)
-#define BNX2_PCI_ID_VAL4_CAP_ENA_10			 (10L<<0)
-#define BNX2_PCI_ID_VAL4_CAP_ENA_11			 (11L<<0)
-#define BNX2_PCI_ID_VAL4_CAP_ENA_12			 (12L<<0)
-#define BNX2_PCI_ID_VAL4_CAP_ENA_13			 (13L<<0)
-#define BNX2_PCI_ID_VAL4_CAP_ENA_14			 (14L<<0)
-#define BNX2_PCI_ID_VAL4_CAP_ENA_15			 (15L<<0)
-#define BNX2_PCI_ID_VAL4_RESERVED0			 (0x3L<<4)
-#define BNX2_PCI_ID_VAL4_PM_SCALE_PRG			 (0x3L<<6)
-#define BNX2_PCI_ID_VAL4_PM_SCALE_PRG_0			 (0L<<6)
-#define BNX2_PCI_ID_VAL4_PM_SCALE_PRG_1			 (1L<<6)
-#define BNX2_PCI_ID_VAL4_PM_SCALE_PRG_2			 (2L<<6)
-#define BNX2_PCI_ID_VAL4_PM_SCALE_PRG_3			 (3L<<6)
-#define BNX2_PCI_ID_VAL4_MSI_PV_MASK_CAP		 (1L<<8)
-#define BNX2_PCI_ID_VAL4_MSI_LIMIT			 (0x7L<<9)
-#define BNX2_PCI_ID_VAL4_MULTI_MSG_CAP			 (0x7L<<12)
-#define BNX2_PCI_ID_VAL4_MSI_ENABLE			 (1L<<15)
-#define BNX2_PCI_ID_VAL4_MAX_64_ADVERTIZE		 (1L<<16)
-#define BNX2_PCI_ID_VAL4_MAX_133_ADVERTIZE		 (1L<<17)
-#define BNX2_PCI_ID_VAL4_RESERVED2			 (0x7L<<18)
-#define BNX2_PCI_ID_VAL4_MAX_CUMULATIVE_SIZE_B21	 (0x3L<<21)
-#define BNX2_PCI_ID_VAL4_MAX_SPLIT_SIZE_B21		 (0x3L<<23)
-#define BNX2_PCI_ID_VAL4_MAX_CUMULATIVE_SIZE_B0		 (1L<<25)
-#define BNX2_PCI_ID_VAL4_MAX_MEM_READ_SIZE_B10		 (0x3L<<26)
-#define BNX2_PCI_ID_VAL4_MAX_SPLIT_SIZE_B0		 (1L<<28)
-#define BNX2_PCI_ID_VAL4_RESERVED3			 (0x7L<<29)
-#define BNX2_PCI_ID_VAL4_RESERVED3_XI			 (0xffffL<<16)
-
-#define BNX2_PCI_ID_VAL5				0x00000444
-#define BNX2_PCI_ID_VAL5_D1_SUPPORT			 (1L<<0)
-#define BNX2_PCI_ID_VAL5_D2_SUPPORT			 (1L<<1)
-#define BNX2_PCI_ID_VAL5_PME_IN_D0			 (1L<<2)
-#define BNX2_PCI_ID_VAL5_PME_IN_D1			 (1L<<3)
-#define BNX2_PCI_ID_VAL5_PME_IN_D2			 (1L<<4)
-#define BNX2_PCI_ID_VAL5_PME_IN_D3_HOT			 (1L<<5)
-#define BNX2_PCI_ID_VAL5_RESERVED0_TE			 (0x3ffffffL<<6)
-#define BNX2_PCI_ID_VAL5_PM_VERSION_XI			 (0x7L<<6)
-#define BNX2_PCI_ID_VAL5_NO_SOFT_RESET_XI		 (1L<<9)
-#define BNX2_PCI_ID_VAL5_RESERVED0_XI			 (0x3fffffL<<10)
-
-#define BNX2_PCI_PCIX_EXTENDED_STATUS			0x00000448
-#define BNX2_PCI_PCIX_EXTENDED_STATUS_NO_SNOOP		 (1L<<8)
-#define BNX2_PCI_PCIX_EXTENDED_STATUS_LONG_BURST	 (1L<<9)
-#define BNX2_PCI_PCIX_EXTENDED_STATUS_SPLIT_COMP_MSG_CLASS	 (0xfL<<16)
-#define BNX2_PCI_PCIX_EXTENDED_STATUS_SPLIT_COMP_MSG_IDX	 (0xffL<<24)
-
-#define BNX2_PCI_ID_VAL6				0x0000044c
-#define BNX2_PCI_ID_VAL6_MAX_LAT			 (0xffL<<0)
-#define BNX2_PCI_ID_VAL6_MIN_GNT			 (0xffL<<8)
-#define BNX2_PCI_ID_VAL6_BIST				 (0xffL<<16)
-#define BNX2_PCI_ID_VAL6_RESERVED0			 (0xffL<<24)
-
-#define BNX2_PCI_MSI_DATA				0x00000450
-#define BNX2_PCI_MSI_DATA_MSI_DATA			 (0xffffL<<0)
-
-#define BNX2_PCI_MSI_ADDR_H				0x00000454
-#define BNX2_PCI_MSI_ADDR_L				0x00000458
-#define BNX2_PCI_MSI_ADDR_L_VAL				 (0x3fffffffL<<2)
-
-#define BNX2_PCI_CFG_ACCESS_CMD				0x0000045c
-#define BNX2_PCI_CFG_ACCESS_CMD_ADR			 (0x3fL<<2)
-#define BNX2_PCI_CFG_ACCESS_CMD_RD_REQ			 (1L<<27)
-#define BNX2_PCI_CFG_ACCESS_CMD_WR_REQ			 (0xfL<<28)
-
-#define BNX2_PCI_CFG_ACCESS_DATA			0x00000460
-#define BNX2_PCI_MSI_MASK				0x00000464
-#define BNX2_PCI_MSI_MASK_MSI_MASK			 (0xffffffffL<<0)
-
-#define BNX2_PCI_MSI_PEND				0x00000468
-#define BNX2_PCI_MSI_PEND_MSI_PEND			 (0xffffffffL<<0)
-
-#define BNX2_PCI_PM_DATA_C				0x0000046c
-#define BNX2_PCI_PM_DATA_C_PM_DATA_8_PRG		 (0xffL<<0)
-#define BNX2_PCI_PM_DATA_C_RESERVED0			 (0xffffffL<<8)
-
-#define BNX2_PCI_MSIX_CONTROL				0x000004c0
-#define BNX2_PCI_MSIX_CONTROL_MSIX_TBL_SIZ		 (0x7ffL<<0)
-#define BNX2_PCI_MSIX_CONTROL_RESERVED0			 (0x1fffffL<<11)
-
-#define BNX2_PCI_MSIX_TBL_OFF_BIR			0x000004c4
-#define BNX2_PCI_MSIX_TBL_OFF_BIR_MSIX_TBL_BIR		 (0x7L<<0)
-#define BNX2_PCI_MSIX_TBL_OFF_BIR_MSIX_TBL_OFF		 (0x1fffffffL<<3)
-
-#define BNX2_PCI_MSIX_PBA_OFF_BIT			0x000004c8
-#define BNX2_PCI_MSIX_PBA_OFF_BIT_MSIX_PBA_BIR		 (0x7L<<0)
-#define BNX2_PCI_MSIX_PBA_OFF_BIT_MSIX_PBA_OFF		 (0x1fffffffL<<3)
-
-#define BNX2_PCI_PCIE_CAPABILITY			0x000004d0
-#define BNX2_PCI_PCIE_CAPABILITY_INTERRUPT_MSG_NUM	 (0x1fL<<0)
-#define BNX2_PCI_PCIE_CAPABILITY_COMPLY_PCIE_1_1	 (1L<<5)
-
-#define BNX2_PCI_DEVICE_CAPABILITY			0x000004d4
-#define BNX2_PCI_DEVICE_CAPABILITY_MAX_PL_SIZ_SUPPORTED	 (0x7L<<0)
-#define BNX2_PCI_DEVICE_CAPABILITY_EXTENDED_TAG_SUPPORT	 (1L<<5)
-#define BNX2_PCI_DEVICE_CAPABILITY_L0S_ACCEPTABLE_LATENCY	 (0x7L<<6)
-#define BNX2_PCI_DEVICE_CAPABILITY_L1_ACCEPTABLE_LATENCY	 (0x7L<<9)
-#define BNX2_PCI_DEVICE_CAPABILITY_ROLE_BASED_ERR_RPT	 (1L<<15)
-
-#define BNX2_PCI_LINK_CAPABILITY			0x000004dc
-#define BNX2_PCI_LINK_CAPABILITY_MAX_LINK_SPEED		 (0xfL<<0)
-#define BNX2_PCI_LINK_CAPABILITY_MAX_LINK_SPEED_0001	 (1L<<0)
-#define BNX2_PCI_LINK_CAPABILITY_MAX_LINK_SPEED_0010	 (1L<<0)
-#define BNX2_PCI_LINK_CAPABILITY_MAX_LINK_WIDTH		 (0x1fL<<4)
-#define BNX2_PCI_LINK_CAPABILITY_CLK_POWER_MGMT		 (1L<<9)
-#define BNX2_PCI_LINK_CAPABILITY_ASPM_SUPPORT		 (0x3L<<10)
-#define BNX2_PCI_LINK_CAPABILITY_L0S_EXIT_LAT		 (0x7L<<12)
-#define BNX2_PCI_LINK_CAPABILITY_L0S_EXIT_LAT_101	 (5L<<12)
-#define BNX2_PCI_LINK_CAPABILITY_L0S_EXIT_LAT_110	 (6L<<12)
-#define BNX2_PCI_LINK_CAPABILITY_L1_EXIT_LAT		 (0x7L<<15)
-#define BNX2_PCI_LINK_CAPABILITY_L1_EXIT_LAT_001	 (1L<<15)
-#define BNX2_PCI_LINK_CAPABILITY_L1_EXIT_LAT_010	 (2L<<15)
-#define BNX2_PCI_LINK_CAPABILITY_L0S_EXIT_COMM_LAT	 (0x7L<<18)
-#define BNX2_PCI_LINK_CAPABILITY_L0S_EXIT_COMM_LAT_101	 (5L<<18)
-#define BNX2_PCI_LINK_CAPABILITY_L0S_EXIT_COMM_LAT_110	 (6L<<18)
-#define BNX2_PCI_LINK_CAPABILITY_L1_EXIT_COMM_LAT	 (0x7L<<21)
-#define BNX2_PCI_LINK_CAPABILITY_L1_EXIT_COMM_LAT_001	 (1L<<21)
-#define BNX2_PCI_LINK_CAPABILITY_L1_EXIT_COMM_LAT_010	 (2L<<21)
-#define BNX2_PCI_LINK_CAPABILITY_PORT_NUM		 (0xffL<<24)
-
-#define BNX2_PCI_PCIE_DEVICE_CAPABILITY_2		0x000004e4
-#define BNX2_PCI_PCIE_DEVICE_CAPABILITY_2_CMPL_TO_RANGE_SUPP	 (0xfL<<0)
-#define BNX2_PCI_PCIE_DEVICE_CAPABILITY_2_CMPL_TO_DISABL_SUPP	 (1L<<4)
-#define BNX2_PCI_PCIE_DEVICE_CAPABILITY_2_RESERVED	 (0x7ffffffL<<5)
-
-#define BNX2_PCI_PCIE_LINK_CAPABILITY_2			0x000004e8
-#define BNX2_PCI_PCIE_LINK_CAPABILITY_2_RESERVED	 (0xffffffffL<<0)
-
-#define BNX2_PCI_GRC_WINDOW1_ADDR			0x00000610
-#define BNX2_PCI_GRC_WINDOW1_ADDR_VALUE			 (0x1ffL<<13)
-
-#define BNX2_PCI_GRC_WINDOW2_ADDR			0x00000614
-#define BNX2_PCI_GRC_WINDOW2_ADDR_VALUE			 (0x1ffL<<13)
-
-#define BNX2_PCI_GRC_WINDOW3_ADDR			0x00000618
-#define BNX2_PCI_GRC_WINDOW3_ADDR_VALUE			 (0x1ffL<<13)
-
-#define BNX2_MSIX_TABLE_ADDR				 0x318000
-#define BNX2_MSIX_PBA_ADDR				 0x31c000
-
-/*
- *  misc_reg definition
- *  offset: 0x800
- */
-#define BNX2_MISC_COMMAND				0x00000800
-#define BNX2_MISC_COMMAND_ENABLE_ALL			 (1L<<0)
-#define BNX2_MISC_COMMAND_DISABLE_ALL			 (1L<<1)
-#define BNX2_MISC_COMMAND_SW_RESET			 (1L<<4)
-#define BNX2_MISC_COMMAND_POR_RESET			 (1L<<5)
-#define BNX2_MISC_COMMAND_HD_RESET			 (1L<<6)
-#define BNX2_MISC_COMMAND_CMN_SW_RESET			 (1L<<7)
-#define BNX2_MISC_COMMAND_PAR_ERROR			 (1L<<8)
-#define BNX2_MISC_COMMAND_CS16_ERR			 (1L<<9)
-#define BNX2_MISC_COMMAND_CS16_ERR_LOC			 (0xfL<<12)
-#define BNX2_MISC_COMMAND_PAR_ERR_RAM			 (0x7fL<<16)
-#define BNX2_MISC_COMMAND_POWERDOWN_EVENT		 (1L<<23)
-#define BNX2_MISC_COMMAND_SW_SHUTDOWN			 (1L<<24)
-#define BNX2_MISC_COMMAND_SHUTDOWN_EN			 (1L<<25)
-#define BNX2_MISC_COMMAND_DINTEG_ATTN_EN		 (1L<<26)
-#define BNX2_MISC_COMMAND_PCIE_LINK_IN_L23		 (1L<<27)
-#define BNX2_MISC_COMMAND_PCIE_DIS			 (1L<<28)
-
-#define BNX2_MISC_CFG					0x00000804
-#define BNX2_MISC_CFG_GRC_TMOUT				 (1L<<0)
-#define BNX2_MISC_CFG_NVM_WR_EN				 (0x3L<<1)
-#define BNX2_MISC_CFG_NVM_WR_EN_PROTECT			 (0L<<1)
-#define BNX2_MISC_CFG_NVM_WR_EN_PCI			 (1L<<1)
-#define BNX2_MISC_CFG_NVM_WR_EN_ALLOW			 (2L<<1)
-#define BNX2_MISC_CFG_NVM_WR_EN_ALLOW2			 (3L<<1)
-#define BNX2_MISC_CFG_BIST_EN				 (1L<<3)
-#define BNX2_MISC_CFG_CK25_OUT_ALT_SRC			 (1L<<4)
-#define BNX2_MISC_CFG_RESERVED5_TE			 (1L<<5)
-#define BNX2_MISC_CFG_RESERVED6_TE			 (1L<<6)
-#define BNX2_MISC_CFG_CLK_CTL_OVERRIDE			 (1L<<7)
-#define BNX2_MISC_CFG_LEDMODE				 (0x7L<<8)
-#define BNX2_MISC_CFG_LEDMODE_MAC			 (0L<<8)
-#define BNX2_MISC_CFG_LEDMODE_PHY1_TE			 (1L<<8)
-#define BNX2_MISC_CFG_LEDMODE_PHY2_TE			 (2L<<8)
-#define BNX2_MISC_CFG_LEDMODE_PHY3_TE			 (3L<<8)
-#define BNX2_MISC_CFG_LEDMODE_PHY4_TE			 (4L<<8)
-#define BNX2_MISC_CFG_LEDMODE_PHY5_TE			 (5L<<8)
-#define BNX2_MISC_CFG_LEDMODE_PHY6_TE			 (6L<<8)
-#define BNX2_MISC_CFG_LEDMODE_PHY7_TE			 (7L<<8)
-#define BNX2_MISC_CFG_MCP_GRC_TMOUT_TE			 (1L<<11)
-#define BNX2_MISC_CFG_DBU_GRC_TMOUT_TE			 (1L<<12)
-#define BNX2_MISC_CFG_LEDMODE_XI			 (0xfL<<8)
-#define BNX2_MISC_CFG_LEDMODE_MAC_XI			 (0L<<8)
-#define BNX2_MISC_CFG_LEDMODE_PHY1_XI			 (1L<<8)
-#define BNX2_MISC_CFG_LEDMODE_PHY2_XI			 (2L<<8)
-#define BNX2_MISC_CFG_LEDMODE_PHY3_XI			 (3L<<8)
-#define BNX2_MISC_CFG_LEDMODE_MAC2_XI			 (4L<<8)
-#define BNX2_MISC_CFG_LEDMODE_PHY4_XI			 (5L<<8)
-#define BNX2_MISC_CFG_LEDMODE_PHY5_XI			 (6L<<8)
-#define BNX2_MISC_CFG_LEDMODE_PHY6_XI			 (7L<<8)
-#define BNX2_MISC_CFG_LEDMODE_MAC3_XI			 (8L<<8)
-#define BNX2_MISC_CFG_LEDMODE_PHY7_XI			 (9L<<8)
-#define BNX2_MISC_CFG_LEDMODE_PHY8_XI			 (10L<<8)
-#define BNX2_MISC_CFG_LEDMODE_PHY9_XI			 (11L<<8)
-#define BNX2_MISC_CFG_LEDMODE_MAC4_XI			 (12L<<8)
-#define BNX2_MISC_CFG_LEDMODE_PHY10_XI			 (13L<<8)
-#define BNX2_MISC_CFG_LEDMODE_PHY11_XI			 (14L<<8)
-#define BNX2_MISC_CFG_LEDMODE_UNUSED_XI			 (15L<<8)
-#define BNX2_MISC_CFG_PORT_SELECT_XI			 (1L<<13)
-#define BNX2_MISC_CFG_PARITY_MODE_XI			 (1L<<14)
-
-#define BNX2_MISC_ID					0x00000808
-#define BNX2_MISC_ID_BOND_ID				 (0xfL<<0)
-#define BNX2_MISC_ID_BOND_ID_X				 (0L<<0)
-#define BNX2_MISC_ID_BOND_ID_C				 (3L<<0)
-#define BNX2_MISC_ID_BOND_ID_S				 (12L<<0)
-#define BNX2_MISC_ID_CHIP_METAL				 (0xffL<<4)
-#define BNX2_MISC_ID_CHIP_REV				 (0xfL<<12)
-#define BNX2_MISC_ID_CHIP_NUM				 (0xffffL<<16)
-
-#define BNX2_MISC_ENABLE_STATUS_BITS			0x0000080c
-#define BNX2_MISC_ENABLE_STATUS_BITS_TX_SCHEDULER_ENABLE	 (1L<<0)
-#define BNX2_MISC_ENABLE_STATUS_BITS_TX_BD_READ_ENABLE	 (1L<<1)
-#define BNX2_MISC_ENABLE_STATUS_BITS_TX_BD_CACHE_ENABLE	 (1L<<2)
-#define BNX2_MISC_ENABLE_STATUS_BITS_TX_PROCESSOR_ENABLE	 (1L<<3)
-#define BNX2_MISC_ENABLE_STATUS_BITS_TX_DMA_ENABLE	 (1L<<4)
-#define BNX2_MISC_ENABLE_STATUS_BITS_TX_PATCHUP_ENABLE	 (1L<<5)
-#define BNX2_MISC_ENABLE_STATUS_BITS_TX_PAYLOAD_Q_ENABLE	 (1L<<6)
-#define BNX2_MISC_ENABLE_STATUS_BITS_TX_HEADER_Q_ENABLE	 (1L<<7)
-#define BNX2_MISC_ENABLE_STATUS_BITS_TX_ASSEMBLER_ENABLE	 (1L<<8)
-#define BNX2_MISC_ENABLE_STATUS_BITS_EMAC_ENABLE	 (1L<<9)
-#define BNX2_MISC_ENABLE_STATUS_BITS_RX_PARSER_MAC_ENABLE	 (1L<<10)
-#define BNX2_MISC_ENABLE_STATUS_BITS_RX_PARSER_CATCHUP_ENABLE	 (1L<<11)
-#define BNX2_MISC_ENABLE_STATUS_BITS_RX_MBUF_ENABLE	 (1L<<12)
-#define BNX2_MISC_ENABLE_STATUS_BITS_RX_LOOKUP_ENABLE	 (1L<<13)
-#define BNX2_MISC_ENABLE_STATUS_BITS_RX_PROCESSOR_ENABLE	 (1L<<14)
-#define BNX2_MISC_ENABLE_STATUS_BITS_RX_V2P_ENABLE	 (1L<<15)
-#define BNX2_MISC_ENABLE_STATUS_BITS_RX_BD_CACHE_ENABLE	 (1L<<16)
-#define BNX2_MISC_ENABLE_STATUS_BITS_RX_DMA_ENABLE	 (1L<<17)
-#define BNX2_MISC_ENABLE_STATUS_BITS_COMPLETION_ENABLE	 (1L<<18)
-#define BNX2_MISC_ENABLE_STATUS_BITS_HOST_COALESCE_ENABLE	 (1L<<19)
-#define BNX2_MISC_ENABLE_STATUS_BITS_MAILBOX_QUEUE_ENABLE	 (1L<<20)
-#define BNX2_MISC_ENABLE_STATUS_BITS_CONTEXT_ENABLE	 (1L<<21)
-#define BNX2_MISC_ENABLE_STATUS_BITS_CMD_SCHEDULER_ENABLE	 (1L<<22)
-#define BNX2_MISC_ENABLE_STATUS_BITS_CMD_PROCESSOR_ENABLE	 (1L<<23)
-#define BNX2_MISC_ENABLE_STATUS_BITS_MGMT_PROCESSOR_ENABLE	 (1L<<24)
-#define BNX2_MISC_ENABLE_STATUS_BITS_TIMER_ENABLE	 (1L<<25)
-#define BNX2_MISC_ENABLE_STATUS_BITS_DMA_ENGINE_ENABLE	 (1L<<26)
-#define BNX2_MISC_ENABLE_STATUS_BITS_UMP_ENABLE		 (1L<<27)
-#define BNX2_MISC_ENABLE_STATUS_BITS_RV2P_CMD_SCHEDULER_ENABLE	 (1L<<28)
-#define BNX2_MISC_ENABLE_STATUS_BITS_RSVD_FUTURE_ENABLE	 (0x7L<<29)
-
-#define BNX2_MISC_ENABLE_SET_BITS			0x00000810
-#define BNX2_MISC_ENABLE_SET_BITS_TX_SCHEDULER_ENABLE	 (1L<<0)
-#define BNX2_MISC_ENABLE_SET_BITS_TX_BD_READ_ENABLE	 (1L<<1)
-#define BNX2_MISC_ENABLE_SET_BITS_TX_BD_CACHE_ENABLE	 (1L<<2)
-#define BNX2_MISC_ENABLE_SET_BITS_TX_PROCESSOR_ENABLE	 (1L<<3)
-#define BNX2_MISC_ENABLE_SET_BITS_TX_DMA_ENABLE		 (1L<<4)
-#define BNX2_MISC_ENABLE_SET_BITS_TX_PATCHUP_ENABLE	 (1L<<5)
-#define BNX2_MISC_ENABLE_SET_BITS_TX_PAYLOAD_Q_ENABLE	 (1L<<6)
-#define BNX2_MISC_ENABLE_SET_BITS_TX_HEADER_Q_ENABLE	 (1L<<7)
-#define BNX2_MISC_ENABLE_SET_BITS_TX_ASSEMBLER_ENABLE	 (1L<<8)
-#define BNX2_MISC_ENABLE_SET_BITS_EMAC_ENABLE		 (1L<<9)
-#define BNX2_MISC_ENABLE_SET_BITS_RX_PARSER_MAC_ENABLE	 (1L<<10)
-#define BNX2_MISC_ENABLE_SET_BITS_RX_PARSER_CATCHUP_ENABLE	 (1L<<11)
-#define BNX2_MISC_ENABLE_SET_BITS_RX_MBUF_ENABLE	 (1L<<12)
-#define BNX2_MISC_ENABLE_SET_BITS_RX_LOOKUP_ENABLE	 (1L<<13)
-#define BNX2_MISC_ENABLE_SET_BITS_RX_PROCESSOR_ENABLE	 (1L<<14)
-#define BNX2_MISC_ENABLE_SET_BITS_RX_V2P_ENABLE		 (1L<<15)
-#define BNX2_MISC_ENABLE_SET_BITS_RX_BD_CACHE_ENABLE	 (1L<<16)
-#define BNX2_MISC_ENABLE_SET_BITS_RX_DMA_ENABLE		 (1L<<17)
-#define BNX2_MISC_ENABLE_SET_BITS_COMPLETION_ENABLE	 (1L<<18)
-#define BNX2_MISC_ENABLE_SET_BITS_HOST_COALESCE_ENABLE	 (1L<<19)
-#define BNX2_MISC_ENABLE_SET_BITS_MAILBOX_QUEUE_ENABLE	 (1L<<20)
-#define BNX2_MISC_ENABLE_SET_BITS_CONTEXT_ENABLE	 (1L<<21)
-#define BNX2_MISC_ENABLE_SET_BITS_CMD_SCHEDULER_ENABLE	 (1L<<22)
-#define BNX2_MISC_ENABLE_SET_BITS_CMD_PROCESSOR_ENABLE	 (1L<<23)
-#define BNX2_MISC_ENABLE_SET_BITS_MGMT_PROCESSOR_ENABLE	 (1L<<24)
-#define BNX2_MISC_ENABLE_SET_BITS_TIMER_ENABLE		 (1L<<25)
-#define BNX2_MISC_ENABLE_SET_BITS_DMA_ENGINE_ENABLE	 (1L<<26)
-#define BNX2_MISC_ENABLE_SET_BITS_UMP_ENABLE		 (1L<<27)
-#define BNX2_MISC_ENABLE_SET_BITS_RV2P_CMD_SCHEDULER_ENABLE	 (1L<<28)
-#define BNX2_MISC_ENABLE_SET_BITS_RSVD_FUTURE_ENABLE	 (0x7L<<29)
-
-#define BNX2_MISC_ENABLE_CLR_BITS			0x00000814
-#define BNX2_MISC_ENABLE_CLR_BITS_TX_SCHEDULER_ENABLE	 (1L<<0)
-#define BNX2_MISC_ENABLE_CLR_BITS_TX_BD_READ_ENABLE	 (1L<<1)
-#define BNX2_MISC_ENABLE_CLR_BITS_TX_BD_CACHE_ENABLE	 (1L<<2)
-#define BNX2_MISC_ENABLE_CLR_BITS_TX_PROCESSOR_ENABLE	 (1L<<3)
-#define BNX2_MISC_ENABLE_CLR_BITS_TX_DMA_ENABLE		 (1L<<4)
-#define BNX2_MISC_ENABLE_CLR_BITS_TX_PATCHUP_ENABLE	 (1L<<5)
-#define BNX2_MISC_ENABLE_CLR_BITS_TX_PAYLOAD_Q_ENABLE	 (1L<<6)
-#define BNX2_MISC_ENABLE_CLR_BITS_TX_HEADER_Q_ENABLE	 (1L<<7)
-#define BNX2_MISC_ENABLE_CLR_BITS_TX_ASSEMBLER_ENABLE	 (1L<<8)
-#define BNX2_MISC_ENABLE_CLR_BITS_EMAC_ENABLE		 (1L<<9)
-#define BNX2_MISC_ENABLE_CLR_BITS_RX_PARSER_MAC_ENABLE	 (1L<<10)
-#define BNX2_MISC_ENABLE_CLR_BITS_RX_PARSER_CATCHUP_ENABLE	 (1L<<11)
-#define BNX2_MISC_ENABLE_CLR_BITS_RX_MBUF_ENABLE	 (1L<<12)
-#define BNX2_MISC_ENABLE_CLR_BITS_RX_LOOKUP_ENABLE	 (1L<<13)
-#define BNX2_MISC_ENABLE_CLR_BITS_RX_PROCESSOR_ENABLE	 (1L<<14)
-#define BNX2_MISC_ENABLE_CLR_BITS_RX_V2P_ENABLE		 (1L<<15)
-#define BNX2_MISC_ENABLE_CLR_BITS_RX_BD_CACHE_ENABLE	 (1L<<16)
-#define BNX2_MISC_ENABLE_CLR_BITS_RX_DMA_ENABLE		 (1L<<17)
-#define BNX2_MISC_ENABLE_CLR_BITS_COMPLETION_ENABLE	 (1L<<18)
-#define BNX2_MISC_ENABLE_CLR_BITS_HOST_COALESCE_ENABLE	 (1L<<19)
-#define BNX2_MISC_ENABLE_CLR_BITS_MAILBOX_QUEUE_ENABLE	 (1L<<20)
-#define BNX2_MISC_ENABLE_CLR_BITS_CONTEXT_ENABLE	 (1L<<21)
-#define BNX2_MISC_ENABLE_CLR_BITS_CMD_SCHEDULER_ENABLE	 (1L<<22)
-#define BNX2_MISC_ENABLE_CLR_BITS_CMD_PROCESSOR_ENABLE	 (1L<<23)
-#define BNX2_MISC_ENABLE_CLR_BITS_MGMT_PROCESSOR_ENABLE	 (1L<<24)
-#define BNX2_MISC_ENABLE_CLR_BITS_TIMER_ENABLE		 (1L<<25)
-#define BNX2_MISC_ENABLE_CLR_BITS_DMA_ENGINE_ENABLE	 (1L<<26)
-#define BNX2_MISC_ENABLE_CLR_BITS_UMP_ENABLE		 (1L<<27)
-#define BNX2_MISC_ENABLE_CLR_BITS_RV2P_CMD_SCHEDULER_ENABLE	 (1L<<28)
-#define BNX2_MISC_ENABLE_CLR_BITS_RSVD_FUTURE_ENABLE	 (0x7L<<29)
-
-#define BNX2_MISC_CLOCK_CONTROL_BITS			0x00000818
-#define BNX2_MISC_CLOCK_CONTROL_BITS_PCI_CLK_SPD_DET	 (0xfL<<0)
-#define BNX2_MISC_CLOCK_CONTROL_BITS_PCI_CLK_SPD_DET_32MHZ	 (0L<<0)
-#define BNX2_MISC_CLOCK_CONTROL_BITS_PCI_CLK_SPD_DET_38MHZ	 (1L<<0)
-#define BNX2_MISC_CLOCK_CONTROL_BITS_PCI_CLK_SPD_DET_48MHZ	 (2L<<0)
-#define BNX2_MISC_CLOCK_CONTROL_BITS_PCI_CLK_SPD_DET_55MHZ	 (3L<<0)
-#define BNX2_MISC_CLOCK_CONTROL_BITS_PCI_CLK_SPD_DET_66MHZ	 (4L<<0)
-#define BNX2_MISC_CLOCK_CONTROL_BITS_PCI_CLK_SPD_DET_80MHZ	 (5L<<0)
-#define BNX2_MISC_CLOCK_CONTROL_BITS_PCI_CLK_SPD_DET_95MHZ	 (6L<<0)
-#define BNX2_MISC_CLOCK_CONTROL_BITS_PCI_CLK_SPD_DET_133MHZ	 (7L<<0)
-#define BNX2_MISC_CLOCK_CONTROL_BITS_PCI_CLK_SPD_DET_LOW	 (0xfL<<0)
-#define BNX2_MISC_CLOCK_CONTROL_BITS_CORE_CLK_DISABLE	 (1L<<6)
-#define BNX2_MISC_CLOCK_CONTROL_BITS_CORE_CLK_ALT	 (1L<<7)
-#define BNX2_MISC_CLOCK_CONTROL_BITS_CORE_CLK_ALT_SRC	 (0x7L<<8)
-#define BNX2_MISC_CLOCK_CONTROL_BITS_CORE_CLK_ALT_SRC_UNDEF	 (0L<<8)
-#define BNX2_MISC_CLOCK_CONTROL_BITS_CORE_CLK_ALT_SRC_12	 (1L<<8)
-#define BNX2_MISC_CLOCK_CONTROL_BITS_CORE_CLK_ALT_SRC_6	 (2L<<8)
-#define BNX2_MISC_CLOCK_CONTROL_BITS_CORE_CLK_ALT_SRC_62	 (4L<<8)
-#define BNX2_MISC_CLOCK_CONTROL_BITS_RESERVED0_XI	 (0x7L<<8)
-#define BNX2_MISC_CLOCK_CONTROL_BITS_MIN_POWER		 (1L<<11)
-#define BNX2_MISC_CLOCK_CONTROL_BITS_CORE_CLK_PLL_SPEED	 (0xfL<<12)
-#define BNX2_MISC_CLOCK_CONTROL_BITS_CORE_CLK_PLL_SPEED_100	 (0L<<12)
-#define BNX2_MISC_CLOCK_CONTROL_BITS_CORE_CLK_PLL_SPEED_80	 (1L<<12)
-#define BNX2_MISC_CLOCK_CONTROL_BITS_CORE_CLK_PLL_SPEED_50	 (2L<<12)
-#define BNX2_MISC_CLOCK_CONTROL_BITS_CORE_CLK_PLL_SPEED_40	 (4L<<12)
-#define BNX2_MISC_CLOCK_CONTROL_BITS_CORE_CLK_PLL_SPEED_25	 (8L<<12)
-#define BNX2_MISC_CLOCK_CONTROL_BITS_RESERVED1_XI	 (0xfL<<12)
-#define BNX2_MISC_CLOCK_CONTROL_BITS_CORE_CLK_PLL_STOP	 (1L<<16)
-#define BNX2_MISC_CLOCK_CONTROL_BITS_RESERVED_17_TE	 (1L<<17)
-#define BNX2_MISC_CLOCK_CONTROL_BITS_RESERVED_18_TE	 (1L<<18)
-#define BNX2_MISC_CLOCK_CONTROL_BITS_RESERVED_19_TE	 (1L<<19)
-#define BNX2_MISC_CLOCK_CONTROL_BITS_RESERVED_TE	 (0xfffL<<20)
-#define BNX2_MISC_CLOCK_CONTROL_BITS_CORE_CLK_ALT_MGMT_XI	 (1L<<17)
-#define BNX2_MISC_CLOCK_CONTROL_BITS_RESERVED2_XI	 (0x3fL<<18)
-#define BNX2_MISC_CLOCK_CONTROL_BITS_CORE_CLK_PLL_VCO_XI	 (0x7L<<24)
-#define BNX2_MISC_CLOCK_CONTROL_BITS_RESERVED3_XI	 (1L<<27)
-#define BNX2_MISC_CLOCK_CONTROL_BITS_CORE_CLK_PLL_SPEED_XI	 (0xfL<<28)
-
-#define BNX2_MISC_SPIO					0x0000081c
-#define BNX2_MISC_SPIO_VALUE				 (0xffL<<0)
-#define BNX2_MISC_SPIO_SET				 (0xffL<<8)
-#define BNX2_MISC_SPIO_CLR				 (0xffL<<16)
-#define BNX2_MISC_SPIO_FLOAT				 (0xffL<<24)
-
-#define BNX2_MISC_SPIO_INT				0x00000820
-#define BNX2_MISC_SPIO_INT_INT_STATE_TE			 (0xfL<<0)
-#define BNX2_MISC_SPIO_INT_OLD_VALUE_TE			 (0xfL<<8)
-#define BNX2_MISC_SPIO_INT_OLD_SET_TE			 (0xfL<<16)
-#define BNX2_MISC_SPIO_INT_OLD_CLR_TE			 (0xfL<<24)
-#define BNX2_MISC_SPIO_INT_INT_STATE_XI			 (0xffL<<0)
-#define BNX2_MISC_SPIO_INT_OLD_VALUE_XI			 (0xffL<<8)
-#define BNX2_MISC_SPIO_INT_OLD_SET_XI			 (0xffL<<16)
-#define BNX2_MISC_SPIO_INT_OLD_CLR_XI			 (0xffL<<24)
-
-#define BNX2_MISC_CONFIG_LFSR				0x00000824
-#define BNX2_MISC_CONFIG_LFSR_DIV			 (0xffffL<<0)
-
-#define BNX2_MISC_LFSR_MASK_BITS			0x00000828
-#define BNX2_MISC_LFSR_MASK_BITS_TX_SCHEDULER_ENABLE	 (1L<<0)
-#define BNX2_MISC_LFSR_MASK_BITS_TX_BD_READ_ENABLE	 (1L<<1)
-#define BNX2_MISC_LFSR_MASK_BITS_TX_BD_CACHE_ENABLE	 (1L<<2)
-#define BNX2_MISC_LFSR_MASK_BITS_TX_PROCESSOR_ENABLE	 (1L<<3)
-#define BNX2_MISC_LFSR_MASK_BITS_TX_DMA_ENABLE		 (1L<<4)
-#define BNX2_MISC_LFSR_MASK_BITS_TX_PATCHUP_ENABLE	 (1L<<5)
-#define BNX2_MISC_LFSR_MASK_BITS_TX_PAYLOAD_Q_ENABLE	 (1L<<6)
-#define BNX2_MISC_LFSR_MASK_BITS_TX_HEADER_Q_ENABLE	 (1L<<7)
-#define BNX2_MISC_LFSR_MASK_BITS_TX_ASSEMBLER_ENABLE	 (1L<<8)
-#define BNX2_MISC_LFSR_MASK_BITS_EMAC_ENABLE		 (1L<<9)
-#define BNX2_MISC_LFSR_MASK_BITS_RX_PARSER_MAC_ENABLE	 (1L<<10)
-#define BNX2_MISC_LFSR_MASK_BITS_RX_PARSER_CATCHUP_ENABLE	 (1L<<11)
-#define BNX2_MISC_LFSR_MASK_BITS_RX_MBUF_ENABLE		 (1L<<12)
-#define BNX2_MISC_LFSR_MASK_BITS_RX_LOOKUP_ENABLE	 (1L<<13)
-#define BNX2_MISC_LFSR_MASK_BITS_RX_PROCESSOR_ENABLE	 (1L<<14)
-#define BNX2_MISC_LFSR_MASK_BITS_RX_V2P_ENABLE		 (1L<<15)
-#define BNX2_MISC_LFSR_MASK_BITS_RX_BD_CACHE_ENABLE	 (1L<<16)
-#define BNX2_MISC_LFSR_MASK_BITS_RX_DMA_ENABLE		 (1L<<17)
-#define BNX2_MISC_LFSR_MASK_BITS_COMPLETION_ENABLE	 (1L<<18)
-#define BNX2_MISC_LFSR_MASK_BITS_HOST_COALESCE_ENABLE	 (1L<<19)
-#define BNX2_MISC_LFSR_MASK_BITS_MAILBOX_QUEUE_ENABLE	 (1L<<20)
-#define BNX2_MISC_LFSR_MASK_BITS_CONTEXT_ENABLE		 (1L<<21)
-#define BNX2_MISC_LFSR_MASK_BITS_CMD_SCHEDULER_ENABLE	 (1L<<22)
-#define BNX2_MISC_LFSR_MASK_BITS_CMD_PROCESSOR_ENABLE	 (1L<<23)
-#define BNX2_MISC_LFSR_MASK_BITS_MGMT_PROCESSOR_ENABLE	 (1L<<24)
-#define BNX2_MISC_LFSR_MASK_BITS_TIMER_ENABLE		 (1L<<25)
-#define BNX2_MISC_LFSR_MASK_BITS_DMA_ENGINE_ENABLE	 (1L<<26)
-#define BNX2_MISC_LFSR_MASK_BITS_UMP_ENABLE		 (1L<<27)
-#define BNX2_MISC_LFSR_MASK_BITS_RV2P_CMD_SCHEDULER_ENABLE	 (1L<<28)
-#define BNX2_MISC_LFSR_MASK_BITS_RSVD_FUTURE_ENABLE	 (0x7L<<29)
-
-#define BNX2_MISC_ARB_REQ0				0x0000082c
-#define BNX2_MISC_ARB_REQ1				0x00000830
-#define BNX2_MISC_ARB_REQ2				0x00000834
-#define BNX2_MISC_ARB_REQ3				0x00000838
-#define BNX2_MISC_ARB_REQ4				0x0000083c
-#define BNX2_MISC_ARB_FREE0				0x00000840
-#define BNX2_MISC_ARB_FREE1				0x00000844
-#define BNX2_MISC_ARB_FREE2				0x00000848
-#define BNX2_MISC_ARB_FREE3				0x0000084c
-#define BNX2_MISC_ARB_FREE4				0x00000850
-#define BNX2_MISC_ARB_REQ_STATUS0			0x00000854
-#define BNX2_MISC_ARB_REQ_STATUS1			0x00000858
-#define BNX2_MISC_ARB_REQ_STATUS2			0x0000085c
-#define BNX2_MISC_ARB_REQ_STATUS3			0x00000860
-#define BNX2_MISC_ARB_REQ_STATUS4			0x00000864
-#define BNX2_MISC_ARB_GNT0				0x00000868
-#define BNX2_MISC_ARB_GNT0_0				 (0x7L<<0)
-#define BNX2_MISC_ARB_GNT0_1				 (0x7L<<4)
-#define BNX2_MISC_ARB_GNT0_2				 (0x7L<<8)
-#define BNX2_MISC_ARB_GNT0_3				 (0x7L<<12)
-#define BNX2_MISC_ARB_GNT0_4				 (0x7L<<16)
-#define BNX2_MISC_ARB_GNT0_5				 (0x7L<<20)
-#define BNX2_MISC_ARB_GNT0_6				 (0x7L<<24)
-#define BNX2_MISC_ARB_GNT0_7				 (0x7L<<28)
-
-#define BNX2_MISC_ARB_GNT1				0x0000086c
-#define BNX2_MISC_ARB_GNT1_8				 (0x7L<<0)
-#define BNX2_MISC_ARB_GNT1_9				 (0x7L<<4)
-#define BNX2_MISC_ARB_GNT1_10				 (0x7L<<8)
-#define BNX2_MISC_ARB_GNT1_11				 (0x7L<<12)
-#define BNX2_MISC_ARB_GNT1_12				 (0x7L<<16)
-#define BNX2_MISC_ARB_GNT1_13				 (0x7L<<20)
-#define BNX2_MISC_ARB_GNT1_14				 (0x7L<<24)
-#define BNX2_MISC_ARB_GNT1_15				 (0x7L<<28)
-
-#define BNX2_MISC_ARB_GNT2				0x00000870
-#define BNX2_MISC_ARB_GNT2_16				 (0x7L<<0)
-#define BNX2_MISC_ARB_GNT2_17				 (0x7L<<4)
-#define BNX2_MISC_ARB_GNT2_18				 (0x7L<<8)
-#define BNX2_MISC_ARB_GNT2_19				 (0x7L<<12)
-#define BNX2_MISC_ARB_GNT2_20				 (0x7L<<16)
-#define BNX2_MISC_ARB_GNT2_21				 (0x7L<<20)
-#define BNX2_MISC_ARB_GNT2_22				 (0x7L<<24)
-#define BNX2_MISC_ARB_GNT2_23				 (0x7L<<28)
-
-#define BNX2_MISC_ARB_GNT3				0x00000874
-#define BNX2_MISC_ARB_GNT3_24				 (0x7L<<0)
-#define BNX2_MISC_ARB_GNT3_25				 (0x7L<<4)
-#define BNX2_MISC_ARB_GNT3_26				 (0x7L<<8)
-#define BNX2_MISC_ARB_GNT3_27				 (0x7L<<12)
-#define BNX2_MISC_ARB_GNT3_28				 (0x7L<<16)
-#define BNX2_MISC_ARB_GNT3_29				 (0x7L<<20)
-#define BNX2_MISC_ARB_GNT3_30				 (0x7L<<24)
-#define BNX2_MISC_ARB_GNT3_31				 (0x7L<<28)
-
-#define BNX2_MISC_RESERVED1				0x00000878
-#define BNX2_MISC_RESERVED1_MISC_RESERVED1_VALUE	 (0x3fL<<0)
-
-#define BNX2_MISC_RESERVED2				0x0000087c
-#define BNX2_MISC_RESERVED2_PCIE_DIS			 (1L<<0)
-#define BNX2_MISC_RESERVED2_LINK_IN_L23			 (1L<<1)
-
-#define BNX2_MISC_SM_ASF_CONTROL			0x00000880
-#define BNX2_MISC_SM_ASF_CONTROL_ASF_RST		 (1L<<0)
-#define BNX2_MISC_SM_ASF_CONTROL_TSC_EN			 (1L<<1)
-#define BNX2_MISC_SM_ASF_CONTROL_WG_TO			 (1L<<2)
-#define BNX2_MISC_SM_ASF_CONTROL_HB_TO			 (1L<<3)
-#define BNX2_MISC_SM_ASF_CONTROL_PA_TO			 (1L<<4)
-#define BNX2_MISC_SM_ASF_CONTROL_PL_TO			 (1L<<5)
-#define BNX2_MISC_SM_ASF_CONTROL_RT_TO			 (1L<<6)
-#define BNX2_MISC_SM_ASF_CONTROL_SMB_EVENT		 (1L<<7)
-#define BNX2_MISC_SM_ASF_CONTROL_STRETCH_EN		 (1L<<8)
-#define BNX2_MISC_SM_ASF_CONTROL_STRETCH_PULSE		 (1L<<9)
-#define BNX2_MISC_SM_ASF_CONTROL_RES			 (0x3L<<10)
-#define BNX2_MISC_SM_ASF_CONTROL_SMB_EN			 (1L<<12)
-#define BNX2_MISC_SM_ASF_CONTROL_SMB_BB_EN		 (1L<<13)
-#define BNX2_MISC_SM_ASF_CONTROL_SMB_NO_ADDR_FILT	 (1L<<14)
-#define BNX2_MISC_SM_ASF_CONTROL_SMB_AUTOREAD		 (1L<<15)
-#define BNX2_MISC_SM_ASF_CONTROL_NIC_SMB_ADDR1		 (0x7fL<<16)
-#define BNX2_MISC_SM_ASF_CONTROL_NIC_SMB_ADDR2		 (0x7fL<<23)
-#define BNX2_MISC_SM_ASF_CONTROL_EN_NIC_SMB_ADDR_0	 (1L<<30)
-#define BNX2_MISC_SM_ASF_CONTROL_SMB_EARLY_ATTN		 (1L<<31)
-
-#define BNX2_MISC_SMB_IN				0x00000884
-#define BNX2_MISC_SMB_IN_DAT_IN				 (0xffL<<0)
-#define BNX2_MISC_SMB_IN_RDY				 (1L<<8)
-#define BNX2_MISC_SMB_IN_DONE				 (1L<<9)
-#define BNX2_MISC_SMB_IN_FIRSTBYTE			 (1L<<10)
-#define BNX2_MISC_SMB_IN_STATUS				 (0x7L<<11)
-#define BNX2_MISC_SMB_IN_STATUS_OK			 (0x0L<<11)
-#define BNX2_MISC_SMB_IN_STATUS_PEC			 (0x1L<<11)
-#define BNX2_MISC_SMB_IN_STATUS_OFLOW			 (0x2L<<11)
-#define BNX2_MISC_SMB_IN_STATUS_STOP			 (0x3L<<11)
-#define BNX2_MISC_SMB_IN_STATUS_TIMEOUT			 (0x4L<<11)
-
-#define BNX2_MISC_SMB_OUT				0x00000888
-#define BNX2_MISC_SMB_OUT_DAT_OUT			 (0xffL<<0)
-#define BNX2_MISC_SMB_OUT_RDY				 (1L<<8)
-#define BNX2_MISC_SMB_OUT_START				 (1L<<9)
-#define BNX2_MISC_SMB_OUT_LAST				 (1L<<10)
-#define BNX2_MISC_SMB_OUT_ACC_TYPE			 (1L<<11)
-#define BNX2_MISC_SMB_OUT_ENB_PEC			 (1L<<12)
-#define BNX2_MISC_SMB_OUT_GET_RX_LEN			 (1L<<13)
-#define BNX2_MISC_SMB_OUT_SMB_READ_LEN			 (0x3fL<<14)
-#define BNX2_MISC_SMB_OUT_SMB_OUT_STATUS		 (0xfL<<20)
-#define BNX2_MISC_SMB_OUT_SMB_OUT_STATUS_OK		 (0L<<20)
-#define BNX2_MISC_SMB_OUT_SMB_OUT_STATUS_FIRST_NACK	 (1L<<20)
-#define BNX2_MISC_SMB_OUT_SMB_OUT_STATUS_UFLOW		 (2L<<20)
-#define BNX2_MISC_SMB_OUT_SMB_OUT_STATUS_STOP		 (3L<<20)
-#define BNX2_MISC_SMB_OUT_SMB_OUT_STATUS_TIMEOUT	 (4L<<20)
-#define BNX2_MISC_SMB_OUT_SMB_OUT_STATUS_FIRST_LOST	 (5L<<20)
-#define BNX2_MISC_SMB_OUT_SMB_OUT_STATUS_BADACK		 (6L<<20)
-#define BNX2_MISC_SMB_OUT_SMB_OUT_STATUS_SUB_NACK	 (9L<<20)
-#define BNX2_MISC_SMB_OUT_SMB_OUT_STATUS_SUB_LOST	 (0xdL<<20)
-#define BNX2_MISC_SMB_OUT_SMB_OUT_SLAVEMODE		 (1L<<24)
-#define BNX2_MISC_SMB_OUT_SMB_OUT_DAT_EN		 (1L<<25)
-#define BNX2_MISC_SMB_OUT_SMB_OUT_DAT_IN		 (1L<<26)
-#define BNX2_MISC_SMB_OUT_SMB_OUT_CLK_EN		 (1L<<27)
-#define BNX2_MISC_SMB_OUT_SMB_OUT_CLK_IN		 (1L<<28)
-
-#define BNX2_MISC_SMB_WATCHDOG				0x0000088c
-#define BNX2_MISC_SMB_WATCHDOG_WATCHDOG			 (0xffffL<<0)
-
-#define BNX2_MISC_SMB_HEARTBEAT				0x00000890
-#define BNX2_MISC_SMB_HEARTBEAT_HEARTBEAT		 (0xffffL<<0)
-
-#define BNX2_MISC_SMB_POLL_ASF				0x00000894
-#define BNX2_MISC_SMB_POLL_ASF_POLL_ASF			 (0xffffL<<0)
-
-#define BNX2_MISC_SMB_POLL_LEGACY			0x00000898
-#define BNX2_MISC_SMB_POLL_LEGACY_POLL_LEGACY		 (0xffffL<<0)
-
-#define BNX2_MISC_SMB_RETRAN				0x0000089c
-#define BNX2_MISC_SMB_RETRAN_RETRAN			 (0xffL<<0)
-
-#define BNX2_MISC_SMB_TIMESTAMP				0x000008a0
-#define BNX2_MISC_SMB_TIMESTAMP_TIMESTAMP		 (0xffffffffL<<0)
-
-#define BNX2_MISC_PERR_ENA0				0x000008a4
-#define BNX2_MISC_PERR_ENA0_COM_MISC_CTXC		 (1L<<0)
-#define BNX2_MISC_PERR_ENA0_COM_MISC_REGF		 (1L<<1)
-#define BNX2_MISC_PERR_ENA0_COM_MISC_SCPAD		 (1L<<2)
-#define BNX2_MISC_PERR_ENA0_CP_MISC_CTXC		 (1L<<3)
-#define BNX2_MISC_PERR_ENA0_CP_MISC_REGF		 (1L<<4)
-#define BNX2_MISC_PERR_ENA0_CP_MISC_SCPAD		 (1L<<5)
-#define BNX2_MISC_PERR_ENA0_CS_MISC_TMEM		 (1L<<6)
-#define BNX2_MISC_PERR_ENA0_CTX_MISC_ACCM0		 (1L<<7)
-#define BNX2_MISC_PERR_ENA0_CTX_MISC_ACCM1		 (1L<<8)
-#define BNX2_MISC_PERR_ENA0_CTX_MISC_ACCM2		 (1L<<9)
-#define BNX2_MISC_PERR_ENA0_CTX_MISC_ACCM3		 (1L<<10)
-#define BNX2_MISC_PERR_ENA0_CTX_MISC_ACCM4		 (1L<<11)
-#define BNX2_MISC_PERR_ENA0_CTX_MISC_ACCM5		 (1L<<12)
-#define BNX2_MISC_PERR_ENA0_CTX_MISC_PGTBL		 (1L<<13)
-#define BNX2_MISC_PERR_ENA0_DMAE_MISC_DR0		 (1L<<14)
-#define BNX2_MISC_PERR_ENA0_DMAE_MISC_DR1		 (1L<<15)
-#define BNX2_MISC_PERR_ENA0_DMAE_MISC_DR2		 (1L<<16)
-#define BNX2_MISC_PERR_ENA0_DMAE_MISC_DR3		 (1L<<17)
-#define BNX2_MISC_PERR_ENA0_DMAE_MISC_DR4		 (1L<<18)
-#define BNX2_MISC_PERR_ENA0_DMAE_MISC_DW0		 (1L<<19)
-#define BNX2_MISC_PERR_ENA0_DMAE_MISC_DW1		 (1L<<20)
-#define BNX2_MISC_PERR_ENA0_DMAE_MISC_DW2		 (1L<<21)
-#define BNX2_MISC_PERR_ENA0_HC_MISC_DMA			 (1L<<22)
-#define BNX2_MISC_PERR_ENA0_MCP_MISC_REGF		 (1L<<23)
-#define BNX2_MISC_PERR_ENA0_MCP_MISC_SCPAD		 (1L<<24)
-#define BNX2_MISC_PERR_ENA0_MQ_MISC_CTX			 (1L<<25)
-#define BNX2_MISC_PERR_ENA0_RBDC_MISC			 (1L<<26)
-#define BNX2_MISC_PERR_ENA0_RBUF_MISC_MB		 (1L<<27)
-#define BNX2_MISC_PERR_ENA0_RBUF_MISC_PTR		 (1L<<28)
-#define BNX2_MISC_PERR_ENA0_RDE_MISC_RPC		 (1L<<29)
-#define BNX2_MISC_PERR_ENA0_RDE_MISC_RPM		 (1L<<30)
-#define BNX2_MISC_PERR_ENA0_RV2P_MISC_CB0REGS		 (1L<<31)
-#define BNX2_MISC_PERR_ENA0_COM_DMAE_PERR_EN_XI		 (1L<<0)
-#define BNX2_MISC_PERR_ENA0_CP_DMAE_PERR_EN_XI		 (1L<<1)
-#define BNX2_MISC_PERR_ENA0_RPM_ACPIBEMEM_PERR_EN_XI	 (1L<<2)
-#define BNX2_MISC_PERR_ENA0_CTX_USAGE_CNT_PERR_EN_XI	 (1L<<3)
-#define BNX2_MISC_PERR_ENA0_CTX_PGTBL_PERR_EN_XI	 (1L<<4)
-#define BNX2_MISC_PERR_ENA0_CTX_CACHE_PERR_EN_XI	 (1L<<5)
-#define BNX2_MISC_PERR_ENA0_CTX_MIRROR_PERR_EN_XI	 (1L<<6)
-#define BNX2_MISC_PERR_ENA0_COM_CTXC_PERR_EN_XI		 (1L<<7)
-#define BNX2_MISC_PERR_ENA0_COM_SCPAD_PERR_EN_XI	 (1L<<8)
-#define BNX2_MISC_PERR_ENA0_CP_CTXC_PERR_EN_XI		 (1L<<9)
-#define BNX2_MISC_PERR_ENA0_CP_SCPAD_PERR_EN_XI		 (1L<<10)
-#define BNX2_MISC_PERR_ENA0_RXP_RBUFC_PERR_EN_XI	 (1L<<11)
-#define BNX2_MISC_PERR_ENA0_RXP_CTXC_PERR_EN_XI		 (1L<<12)
-#define BNX2_MISC_PERR_ENA0_RXP_SCPAD_PERR_EN_XI	 (1L<<13)
-#define BNX2_MISC_PERR_ENA0_TPAT_SCPAD_PERR_EN_XI	 (1L<<14)
-#define BNX2_MISC_PERR_ENA0_TXP_CTXC_PERR_EN_XI		 (1L<<15)
-#define BNX2_MISC_PERR_ENA0_TXP_SCPAD_PERR_EN_XI	 (1L<<16)
-#define BNX2_MISC_PERR_ENA0_CS_TMEM_PERR_EN_XI		 (1L<<17)
-#define BNX2_MISC_PERR_ENA0_MQ_CTX_PERR_EN_XI		 (1L<<18)
-#define BNX2_MISC_PERR_ENA0_RPM_DFIFOMEM_PERR_EN_XI	 (1L<<19)
-#define BNX2_MISC_PERR_ENA0_RPC_DFIFOMEM_PERR_EN_XI	 (1L<<20)
-#define BNX2_MISC_PERR_ENA0_RBUF_PTRMEM_PERR_EN_XI	 (1L<<21)
-#define BNX2_MISC_PERR_ENA0_RBUF_DATAMEM_PERR_EN_XI	 (1L<<22)
-#define BNX2_MISC_PERR_ENA0_RV2P_P2IRAM_PERR_EN_XI	 (1L<<23)
-#define BNX2_MISC_PERR_ENA0_RV2P_P1IRAM_PERR_EN_XI	 (1L<<24)
-#define BNX2_MISC_PERR_ENA0_RV2P_CB1REGS_PERR_EN_XI	 (1L<<25)
-#define BNX2_MISC_PERR_ENA0_RV2P_CB0REGS_PERR_EN_XI	 (1L<<26)
-#define BNX2_MISC_PERR_ENA0_TPBUF_PERR_EN_XI		 (1L<<27)
-#define BNX2_MISC_PERR_ENA0_THBUF_PERR_EN_XI		 (1L<<28)
-#define BNX2_MISC_PERR_ENA0_TDMA_PERR_EN_XI		 (1L<<29)
-#define BNX2_MISC_PERR_ENA0_TBDC_PERR_EN_XI		 (1L<<30)
-#define BNX2_MISC_PERR_ENA0_TSCH_LR_PERR_EN_XI		 (1L<<31)
-
-#define BNX2_MISC_PERR_ENA1				0x000008a8
-#define BNX2_MISC_PERR_ENA1_RV2P_MISC_CB1REGS		 (1L<<0)
-#define BNX2_MISC_PERR_ENA1_RV2P_MISC_P1IRAM		 (1L<<1)
-#define BNX2_MISC_PERR_ENA1_RV2P_MISC_P2IRAM		 (1L<<2)
-#define BNX2_MISC_PERR_ENA1_RXP_MISC_CTXC		 (1L<<3)
-#define BNX2_MISC_PERR_ENA1_RXP_MISC_REGF		 (1L<<4)
-#define BNX2_MISC_PERR_ENA1_RXP_MISC_SCPAD		 (1L<<5)
-#define BNX2_MISC_PERR_ENA1_RXP_MISC_RBUFC		 (1L<<6)
-#define BNX2_MISC_PERR_ENA1_TBDC_MISC			 (1L<<7)
-#define BNX2_MISC_PERR_ENA1_TDMA_MISC			 (1L<<8)
-#define BNX2_MISC_PERR_ENA1_THBUF_MISC_MB0		 (1L<<9)
-#define BNX2_MISC_PERR_ENA1_THBUF_MISC_MB1		 (1L<<10)
-#define BNX2_MISC_PERR_ENA1_TPAT_MISC_REGF		 (1L<<11)
-#define BNX2_MISC_PERR_ENA1_TPAT_MISC_SCPAD		 (1L<<12)
-#define BNX2_MISC_PERR_ENA1_TPBUF_MISC_MB		 (1L<<13)
-#define BNX2_MISC_PERR_ENA1_TSCH_MISC_LR		 (1L<<14)
-#define BNX2_MISC_PERR_ENA1_TXP_MISC_CTXC		 (1L<<15)
-#define BNX2_MISC_PERR_ENA1_TXP_MISC_REGF		 (1L<<16)
-#define BNX2_MISC_PERR_ENA1_TXP_MISC_SCPAD		 (1L<<17)
-#define BNX2_MISC_PERR_ENA1_UMP_MISC_FIORX		 (1L<<18)
-#define BNX2_MISC_PERR_ENA1_UMP_MISC_FIOTX		 (1L<<19)
-#define BNX2_MISC_PERR_ENA1_UMP_MISC_RX			 (1L<<20)
-#define BNX2_MISC_PERR_ENA1_UMP_MISC_TX			 (1L<<21)
-#define BNX2_MISC_PERR_ENA1_RDMAQ_MISC			 (1L<<22)
-#define BNX2_MISC_PERR_ENA1_CSQ_MISC			 (1L<<23)
-#define BNX2_MISC_PERR_ENA1_CPQ_MISC			 (1L<<24)
-#define BNX2_MISC_PERR_ENA1_MCPQ_MISC			 (1L<<25)
-#define BNX2_MISC_PERR_ENA1_RV2PMQ_MISC			 (1L<<26)
-#define BNX2_MISC_PERR_ENA1_RV2PPQ_MISC			 (1L<<27)
-#define BNX2_MISC_PERR_ENA1_RV2PTQ_MISC			 (1L<<28)
-#define BNX2_MISC_PERR_ENA1_RXPQ_MISC			 (1L<<29)
-#define BNX2_MISC_PERR_ENA1_RXPCQ_MISC			 (1L<<30)
-#define BNX2_MISC_PERR_ENA1_RLUPQ_MISC			 (1L<<31)
-#define BNX2_MISC_PERR_ENA1_RBDC_PERR_EN_XI		 (1L<<0)
-#define BNX2_MISC_PERR_ENA1_RDMA_DFIFO_PERR_EN_XI	 (1L<<2)
-#define BNX2_MISC_PERR_ENA1_HC_STATS_PERR_EN_XI		 (1L<<3)
-#define BNX2_MISC_PERR_ENA1_HC_MSIX_PERR_EN_XI		 (1L<<4)
-#define BNX2_MISC_PERR_ENA1_HC_PRODUCSTB_PERR_EN_XI	 (1L<<5)
-#define BNX2_MISC_PERR_ENA1_HC_CONSUMSTB_PERR_EN_XI	 (1L<<6)
-#define BNX2_MISC_PERR_ENA1_TPATQ_PERR_EN_XI		 (1L<<7)
-#define BNX2_MISC_PERR_ENA1_MCPQ_PERR_EN_XI		 (1L<<8)
-#define BNX2_MISC_PERR_ENA1_TDMAQ_PERR_EN_XI		 (1L<<9)
-#define BNX2_MISC_PERR_ENA1_TXPQ_PERR_EN_XI		 (1L<<10)
-#define BNX2_MISC_PERR_ENA1_COMTQ_PERR_EN_XI		 (1L<<11)
-#define BNX2_MISC_PERR_ENA1_COMQ_PERR_EN_XI		 (1L<<12)
-#define BNX2_MISC_PERR_ENA1_RLUPQ_PERR_EN_XI		 (1L<<13)
-#define BNX2_MISC_PERR_ENA1_RXPQ_PERR_EN_XI		 (1L<<14)
-#define BNX2_MISC_PERR_ENA1_RV2PPQ_PERR_EN_XI		 (1L<<15)
-#define BNX2_MISC_PERR_ENA1_RDMAQ_PERR_EN_XI		 (1L<<16)
-#define BNX2_MISC_PERR_ENA1_TASQ_PERR_EN_XI		 (1L<<17)
-#define BNX2_MISC_PERR_ENA1_TBDRQ_PERR_EN_XI		 (1L<<18)
-#define BNX2_MISC_PERR_ENA1_TSCHQ_PERR_EN_XI		 (1L<<19)
-#define BNX2_MISC_PERR_ENA1_COMXQ_PERR_EN_XI		 (1L<<20)
-#define BNX2_MISC_PERR_ENA1_RXPCQ_PERR_EN_XI		 (1L<<21)
-#define BNX2_MISC_PERR_ENA1_RV2PTQ_PERR_EN_XI		 (1L<<22)
-#define BNX2_MISC_PERR_ENA1_RV2PMQ_PERR_EN_XI		 (1L<<23)
-#define BNX2_MISC_PERR_ENA1_CPQ_PERR_EN_XI		 (1L<<24)
-#define BNX2_MISC_PERR_ENA1_CSQ_PERR_EN_XI		 (1L<<25)
-#define BNX2_MISC_PERR_ENA1_RLUP_CID_PERR_EN_XI		 (1L<<26)
-#define BNX2_MISC_PERR_ENA1_RV2PCS_TMEM_PERR_EN_XI	 (1L<<27)
-#define BNX2_MISC_PERR_ENA1_RV2PCSQ_PERR_EN_XI		 (1L<<28)
-#define BNX2_MISC_PERR_ENA1_MQ_IDX_PERR_EN_XI		 (1L<<29)
-
-#define BNX2_MISC_PERR_ENA2				0x000008ac
-#define BNX2_MISC_PERR_ENA2_COMQ_MISC			 (1L<<0)
-#define BNX2_MISC_PERR_ENA2_COMXQ_MISC			 (1L<<1)
-#define BNX2_MISC_PERR_ENA2_COMTQ_MISC			 (1L<<2)
-#define BNX2_MISC_PERR_ENA2_TSCHQ_MISC			 (1L<<3)
-#define BNX2_MISC_PERR_ENA2_TBDRQ_MISC			 (1L<<4)
-#define BNX2_MISC_PERR_ENA2_TXPQ_MISC			 (1L<<5)
-#define BNX2_MISC_PERR_ENA2_TDMAQ_MISC			 (1L<<6)
-#define BNX2_MISC_PERR_ENA2_TPATQ_MISC			 (1L<<7)
-#define BNX2_MISC_PERR_ENA2_TASQ_MISC			 (1L<<8)
-#define BNX2_MISC_PERR_ENA2_TGT_FIFO_PERR_EN_XI		 (1L<<0)
-#define BNX2_MISC_PERR_ENA2_UMP_TX_PERR_EN_XI		 (1L<<1)
-#define BNX2_MISC_PERR_ENA2_UMP_RX_PERR_EN_XI		 (1L<<2)
-#define BNX2_MISC_PERR_ENA2_MCP_ROM_PERR_EN_XI		 (1L<<3)
-#define BNX2_MISC_PERR_ENA2_MCP_SCPAD_PERR_EN_XI	 (1L<<4)
-#define BNX2_MISC_PERR_ENA2_HB_MEM_PERR_EN_XI		 (1L<<5)
-#define BNX2_MISC_PERR_ENA2_PCIE_REPLAY_PERR_EN_XI	 (1L<<6)
-
-#define BNX2_MISC_DEBUG_VECTOR_SEL			0x000008b0
-#define BNX2_MISC_DEBUG_VECTOR_SEL_0			 (0xfffL<<0)
-#define BNX2_MISC_DEBUG_VECTOR_SEL_1			 (0xfffL<<12)
-#define BNX2_MISC_DEBUG_VECTOR_SEL_1_XI			 (0xfffL<<15)
-
-#define BNX2_MISC_VREG_CONTROL				0x000008b4
-#define BNX2_MISC_VREG_CONTROL_1_2			 (0xfL<<0)
-#define BNX2_MISC_VREG_CONTROL_1_0_MAIN_XI		 (0xfL<<0)
-#define BNX2_MISC_VREG_CONTROL_1_0_MAIN_PLUS14_XI	 (0L<<0)
-#define BNX2_MISC_VREG_CONTROL_1_0_MAIN_PLUS12_XI	 (1L<<0)
-#define BNX2_MISC_VREG_CONTROL_1_0_MAIN_PLUS10_XI	 (2L<<0)
-#define BNX2_MISC_VREG_CONTROL_1_0_MAIN_PLUS8_XI	 (3L<<0)
-#define BNX2_MISC_VREG_CONTROL_1_0_MAIN_PLUS6_XI	 (4L<<0)
-#define BNX2_MISC_VREG_CONTROL_1_0_MAIN_PLUS4_XI	 (5L<<0)
-#define BNX2_MISC_VREG_CONTROL_1_0_MAIN_PLUS2_XI	 (6L<<0)
-#define BNX2_MISC_VREG_CONTROL_1_0_MAIN_NOM_XI		 (7L<<0)
-#define BNX2_MISC_VREG_CONTROL_1_0_MAIN_MINUS2_XI	 (8L<<0)
-#define BNX2_MISC_VREG_CONTROL_1_0_MAIN_MINUS4_XI	 (9L<<0)
-#define BNX2_MISC_VREG_CONTROL_1_0_MAIN_MINUS6_XI	 (10L<<0)
-#define BNX2_MISC_VREG_CONTROL_1_0_MAIN_MINUS8_XI	 (11L<<0)
-#define BNX2_MISC_VREG_CONTROL_1_0_MAIN_MINUS10_XI	 (12L<<0)
-#define BNX2_MISC_VREG_CONTROL_1_0_MAIN_MINUS12_XI	 (13L<<0)
-#define BNX2_MISC_VREG_CONTROL_1_0_MAIN_MINUS14_XI	 (14L<<0)
-#define BNX2_MISC_VREG_CONTROL_1_0_MAIN_MINUS16_XI	 (15L<<0)
-#define BNX2_MISC_VREG_CONTROL_2_5			 (0xfL<<4)
-#define BNX2_MISC_VREG_CONTROL_2_5_PLUS14		 (0L<<4)
-#define BNX2_MISC_VREG_CONTROL_2_5_PLUS12		 (1L<<4)
-#define BNX2_MISC_VREG_CONTROL_2_5_PLUS10		 (2L<<4)
-#define BNX2_MISC_VREG_CONTROL_2_5_PLUS8		 (3L<<4)
-#define BNX2_MISC_VREG_CONTROL_2_5_PLUS6		 (4L<<4)
-#define BNX2_MISC_VREG_CONTROL_2_5_PLUS4		 (5L<<4)
-#define BNX2_MISC_VREG_CONTROL_2_5_PLUS2		 (6L<<4)
-#define BNX2_MISC_VREG_CONTROL_2_5_NOM			 (7L<<4)
-#define BNX2_MISC_VREG_CONTROL_2_5_MINUS2		 (8L<<4)
-#define BNX2_MISC_VREG_CONTROL_2_5_MINUS4		 (9L<<4)
-#define BNX2_MISC_VREG_CONTROL_2_5_MINUS6		 (10L<<4)
-#define BNX2_MISC_VREG_CONTROL_2_5_MINUS8		 (11L<<4)
-#define BNX2_MISC_VREG_CONTROL_2_5_MINUS10		 (12L<<4)
-#define BNX2_MISC_VREG_CONTROL_2_5_MINUS12		 (13L<<4)
-#define BNX2_MISC_VREG_CONTROL_2_5_MINUS14		 (14L<<4)
-#define BNX2_MISC_VREG_CONTROL_2_5_MINUS16		 (15L<<4)
-#define BNX2_MISC_VREG_CONTROL_1_0_MGMT			 (0xfL<<8)
-#define BNX2_MISC_VREG_CONTROL_1_0_MGMT_PLUS14		 (0L<<8)
-#define BNX2_MISC_VREG_CONTROL_1_0_MGMT_PLUS12		 (1L<<8)
-#define BNX2_MISC_VREG_CONTROL_1_0_MGMT_PLUS10		 (2L<<8)
-#define BNX2_MISC_VREG_CONTROL_1_0_MGMT_PLUS8		 (3L<<8)
-#define BNX2_MISC_VREG_CONTROL_1_0_MGMT_PLUS6		 (4L<<8)
-#define BNX2_MISC_VREG_CONTROL_1_0_MGMT_PLUS4		 (5L<<8)
-#define BNX2_MISC_VREG_CONTROL_1_0_MGMT_PLUS2		 (6L<<8)
-#define BNX2_MISC_VREG_CONTROL_1_0_MGMT_NOM		 (7L<<8)
-#define BNX2_MISC_VREG_CONTROL_1_0_MGMT_MINUS2		 (8L<<8)
-#define BNX2_MISC_VREG_CONTROL_1_0_MGMT_MINUS4		 (9L<<8)
-#define BNX2_MISC_VREG_CONTROL_1_0_MGMT_MINUS6		 (10L<<8)
-#define BNX2_MISC_VREG_CONTROL_1_0_MGMT_MINUS8		 (11L<<8)
-#define BNX2_MISC_VREG_CONTROL_1_0_MGMT_MINUS10		 (12L<<8)
-#define BNX2_MISC_VREG_CONTROL_1_0_MGMT_MINUS12		 (13L<<8)
-#define BNX2_MISC_VREG_CONTROL_1_0_MGMT_MINUS14		 (14L<<8)
-#define BNX2_MISC_VREG_CONTROL_1_0_MGMT_MINUS16		 (15L<<8)
-
-#define BNX2_MISC_FINAL_CLK_CTL_VAL			0x000008b8
-#define BNX2_MISC_FINAL_CLK_CTL_VAL_MISC_FINAL_CLK_CTL_VAL	 (0x3ffffffL<<6)
-
-#define BNX2_MISC_GP_HW_CTL0				0x000008bc
-#define BNX2_MISC_GP_HW_CTL0_TX_DRIVE			 (1L<<0)
-#define BNX2_MISC_GP_HW_CTL0_RMII_MODE			 (1L<<1)
-#define BNX2_MISC_GP_HW_CTL0_RMII_CRSDV_SEL		 (1L<<2)
-#define BNX2_MISC_GP_HW_CTL0_RVMII_MODE			 (1L<<3)
-#define BNX2_MISC_GP_HW_CTL0_FLASH_SAMP_SCLK_NEGEDGE_TE	 (1L<<4)
-#define BNX2_MISC_GP_HW_CTL0_HIDDEN_REVISION_ID_TE	 (1L<<5)
-#define BNX2_MISC_GP_HW_CTL0_HC_CNTL_TMOUT_CTR_RST_TE	 (1L<<6)
-#define BNX2_MISC_GP_HW_CTL0_RESERVED1_XI		 (0x7L<<4)
-#define BNX2_MISC_GP_HW_CTL0_ENA_CORE_RST_ON_MAIN_PWR_GOING_AWAY	 (1L<<7)
-#define BNX2_MISC_GP_HW_CTL0_ENA_SEL_VAUX_B_IN_L2_TE	 (1L<<8)
-#define BNX2_MISC_GP_HW_CTL0_GRC_BNK_FREE_FIX_TE	 (1L<<9)
-#define BNX2_MISC_GP_HW_CTL0_LED_ACT_SEL_TE		 (1L<<10)
-#define BNX2_MISC_GP_HW_CTL0_RESERVED2_XI		 (0x7L<<8)
-#define BNX2_MISC_GP_HW_CTL0_UP1_DEF0			 (1L<<11)
-#define BNX2_MISC_GP_HW_CTL0_FIBER_MODE_DIS_DEF		 (1L<<12)
-#define BNX2_MISC_GP_HW_CTL0_FORCE2500_DEF		 (1L<<13)
-#define BNX2_MISC_GP_HW_CTL0_AUTODETECT_DIS_DEF		 (1L<<14)
-#define BNX2_MISC_GP_HW_CTL0_PARALLEL_DETECT_DEF	 (1L<<15)
-#define BNX2_MISC_GP_HW_CTL0_OSCCTRL_DAI		 (0xfL<<16)
-#define BNX2_MISC_GP_HW_CTL0_OSCCTRL_DAI_3MA		 (0L<<16)
-#define BNX2_MISC_GP_HW_CTL0_OSCCTRL_DAI_2P5MA		 (1L<<16)
-#define BNX2_MISC_GP_HW_CTL0_OSCCTRL_DAI_2P0MA		 (3L<<16)
-#define BNX2_MISC_GP_HW_CTL0_OSCCTRL_DAI_1P5MA		 (5L<<16)
-#define BNX2_MISC_GP_HW_CTL0_OSCCTRL_DAI_1P0MA		 (7L<<16)
-#define BNX2_MISC_GP_HW_CTL0_OSCCTRL_DAI_PWRDN		 (15L<<16)
-#define BNX2_MISC_GP_HW_CTL0_OSCCTRL_PRE2DIS		 (1L<<20)
-#define BNX2_MISC_GP_HW_CTL0_OSCCTRL_PRE1DIS		 (1L<<21)
-#define BNX2_MISC_GP_HW_CTL0_OSCCTRL_CTAT		 (0x3L<<22)
-#define BNX2_MISC_GP_HW_CTL0_OSCCTRL_CTAT_M6P		 (0L<<22)
-#define BNX2_MISC_GP_HW_CTL0_OSCCTRL_CTAT_M0P		 (1L<<22)
-#define BNX2_MISC_GP_HW_CTL0_OSCCTRL_CTAT_P0P		 (2L<<22)
-#define BNX2_MISC_GP_HW_CTL0_OSCCTRL_CTAT_P6P		 (3L<<22)
-#define BNX2_MISC_GP_HW_CTL0_OSCCTRL_PTAT		 (0x3L<<24)
-#define BNX2_MISC_GP_HW_CTL0_OSCCTRL_PTAT_M6P		 (0L<<24)
-#define BNX2_MISC_GP_HW_CTL0_OSCCTRL_PTAT_M0P		 (1L<<24)
-#define BNX2_MISC_GP_HW_CTL0_OSCCTRL_PTAT_P0P		 (2L<<24)
-#define BNX2_MISC_GP_HW_CTL0_OSCCTRL_PTAT_P6P		 (3L<<24)
-#define BNX2_MISC_GP_HW_CTL0_OSCCTRL_IAMP_ADJ		 (0x3L<<26)
-#define BNX2_MISC_GP_HW_CTL0_OSCCTRL_IAMP_ADJ_240UA	 (0L<<26)
-#define BNX2_MISC_GP_HW_CTL0_OSCCTRL_IAMP_ADJ_160UA	 (1L<<26)
-#define BNX2_MISC_GP_HW_CTL0_OSCCTRL_IAMP_ADJ_400UA	 (2L<<26)
-#define BNX2_MISC_GP_HW_CTL0_OSCCTRL_IAMP_ADJ_320UA	 (3L<<26)
-#define BNX2_MISC_GP_HW_CTL0_OSCCTRL_ICBUF_ADJ		 (0x3L<<28)
-#define BNX2_MISC_GP_HW_CTL0_OSCCTRL_ICBUF_ADJ_240UA	 (0L<<28)
-#define BNX2_MISC_GP_HW_CTL0_OSCCTRL_ICBUF_ADJ_160UA	 (1L<<28)
-#define BNX2_MISC_GP_HW_CTL0_OSCCTRL_ICBUF_ADJ_400UA	 (2L<<28)
-#define BNX2_MISC_GP_HW_CTL0_OSCCTRL_ICBUF_ADJ_320UA	 (3L<<28)
-#define BNX2_MISC_GP_HW_CTL0_OSCCTRL_XTAL_ADJ		 (0x3L<<30)
-#define BNX2_MISC_GP_HW_CTL0_OSCCTRL_XTAL_ADJ_1P57	 (0L<<30)
-#define BNX2_MISC_GP_HW_CTL0_OSCCTRL_XTAL_ADJ_1P45	 (1L<<30)
-#define BNX2_MISC_GP_HW_CTL0_OSCCTRL_XTAL_ADJ_1P62	 (2L<<30)
-#define BNX2_MISC_GP_HW_CTL0_OSCCTRL_XTAL_ADJ_1P66	 (3L<<30)
-
-#define BNX2_MISC_GP_HW_CTL1				0x000008c0
-#define BNX2_MISC_GP_HW_CTL1_1_ATTN_BTN_PRSNT_TE	 (1L<<0)
-#define BNX2_MISC_GP_HW_CTL1_1_ATTN_IND_PRSNT_TE	 (1L<<1)
-#define BNX2_MISC_GP_HW_CTL1_1_PWR_IND_PRSNT_TE		 (1L<<2)
-#define BNX2_MISC_GP_HW_CTL1_0_PCIE_LOOPBACK_TE		 (1L<<3)
-#define BNX2_MISC_GP_HW_CTL1_RESERVED_SOFT_XI		 (0xffffL<<0)
-#define BNX2_MISC_GP_HW_CTL1_RESERVED_HARD_XI		 (0xffffL<<16)
-
-#define BNX2_MISC_NEW_HW_CTL				0x000008c4
-#define BNX2_MISC_NEW_HW_CTL_MAIN_POR_BYPASS		 (1L<<0)
-#define BNX2_MISC_NEW_HW_CTL_RINGOSC_ENABLE		 (1L<<1)
-#define BNX2_MISC_NEW_HW_CTL_RINGOSC_SEL0		 (1L<<2)
-#define BNX2_MISC_NEW_HW_CTL_RINGOSC_SEL1		 (1L<<3)
-#define BNX2_MISC_NEW_HW_CTL_RESERVED_SHARED		 (0xfffL<<4)
-#define BNX2_MISC_NEW_HW_CTL_RESERVED_SPLIT		 (0xffffL<<16)
-
-#define BNX2_MISC_NEW_CORE_CTL				0x000008c8
-#define BNX2_MISC_NEW_CORE_CTL_LINK_HOLDOFF_SUCCESS	 (1L<<0)
-#define BNX2_MISC_NEW_CORE_CTL_LINK_HOLDOFF_REQ		 (1L<<1)
-#define BNX2_MISC_NEW_CORE_CTL_DMA_ENABLE		 (1L<<16)
-#define BNX2_MISC_NEW_CORE_CTL_RESERVED_CMN		 (0x3fffL<<2)
-#define BNX2_MISC_NEW_CORE_CTL_RESERVED_TC		 (0xffffL<<16)
-
-#define BNX2_MISC_ECO_HW_CTL				0x000008cc
-#define BNX2_MISC_ECO_HW_CTL_LARGE_GRC_TMOUT_EN		 (1L<<0)
-#define BNX2_MISC_ECO_HW_CTL_RESERVED_SOFT		 (0x7fffL<<1)
-#define BNX2_MISC_ECO_HW_CTL_RESERVED_HARD		 (0xffffL<<16)
-
-#define BNX2_MISC_ECO_CORE_CTL				0x000008d0
-#define BNX2_MISC_ECO_CORE_CTL_RESERVED_SOFT		 (0xffffL<<0)
-#define BNX2_MISC_ECO_CORE_CTL_RESERVED_HARD		 (0xffffL<<16)
-
-#define BNX2_MISC_PPIO					0x000008d4
-#define BNX2_MISC_PPIO_VALUE				 (0xfL<<0)
-#define BNX2_MISC_PPIO_SET				 (0xfL<<8)
-#define BNX2_MISC_PPIO_CLR				 (0xfL<<16)
-#define BNX2_MISC_PPIO_FLOAT				 (0xfL<<24)
-
-#define BNX2_MISC_PPIO_INT				0x000008d8
-#define BNX2_MISC_PPIO_INT_INT_STATE			 (0xfL<<0)
-#define BNX2_MISC_PPIO_INT_OLD_VALUE			 (0xfL<<8)
-#define BNX2_MISC_PPIO_INT_OLD_SET			 (0xfL<<16)
-#define BNX2_MISC_PPIO_INT_OLD_CLR			 (0xfL<<24)
-
-#define BNX2_MISC_RESET_NUMS				0x000008dc
-#define BNX2_MISC_RESET_NUMS_NUM_HARD_RESETS		 (0x7L<<0)
-#define BNX2_MISC_RESET_NUMS_NUM_PCIE_RESETS		 (0x7L<<4)
-#define BNX2_MISC_RESET_NUMS_NUM_PERSTB_RESETS		 (0x7L<<8)
-#define BNX2_MISC_RESET_NUMS_NUM_CMN_RESETS		 (0x7L<<12)
-#define BNX2_MISC_RESET_NUMS_NUM_PORT_RESETS		 (0x7L<<16)
-
-#define BNX2_MISC_CS16_ERR				0x000008e0
-#define BNX2_MISC_CS16_ERR_ENA_PCI			 (1L<<0)
-#define BNX2_MISC_CS16_ERR_ENA_RDMA			 (1L<<1)
-#define BNX2_MISC_CS16_ERR_ENA_TDMA			 (1L<<2)
-#define BNX2_MISC_CS16_ERR_ENA_EMAC			 (1L<<3)
-#define BNX2_MISC_CS16_ERR_ENA_CTX			 (1L<<4)
-#define BNX2_MISC_CS16_ERR_ENA_TBDR			 (1L<<5)
-#define BNX2_MISC_CS16_ERR_ENA_RBDC			 (1L<<6)
-#define BNX2_MISC_CS16_ERR_ENA_COM			 (1L<<7)
-#define BNX2_MISC_CS16_ERR_ENA_CP			 (1L<<8)
-#define BNX2_MISC_CS16_ERR_STA_PCI			 (1L<<16)
-#define BNX2_MISC_CS16_ERR_STA_RDMA			 (1L<<17)
-#define BNX2_MISC_CS16_ERR_STA_TDMA			 (1L<<18)
-#define BNX2_MISC_CS16_ERR_STA_EMAC			 (1L<<19)
-#define BNX2_MISC_CS16_ERR_STA_CTX			 (1L<<20)
-#define BNX2_MISC_CS16_ERR_STA_TBDR			 (1L<<21)
-#define BNX2_MISC_CS16_ERR_STA_RBDC			 (1L<<22)
-#define BNX2_MISC_CS16_ERR_STA_COM			 (1L<<23)
-#define BNX2_MISC_CS16_ERR_STA_CP			 (1L<<24)
-
-#define BNX2_MISC_SPIO_EVENT				0x000008e4
-#define BNX2_MISC_SPIO_EVENT_ENABLE			 (0xffL<<0)
-
-#define BNX2_MISC_PPIO_EVENT				0x000008e8
-#define BNX2_MISC_PPIO_EVENT_ENABLE			 (0xfL<<0)
-
-#define BNX2_MISC_DUAL_MEDIA_CTRL			0x000008ec
-#define BNX2_MISC_DUAL_MEDIA_CTRL_BOND_ID		 (0xffL<<0)
-#define BNX2_MISC_DUAL_MEDIA_CTRL_BOND_ID_X		 (0L<<0)
-#define BNX2_MISC_DUAL_MEDIA_CTRL_BOND_ID_C		 (3L<<0)
-#define BNX2_MISC_DUAL_MEDIA_CTRL_BOND_ID_S		 (12L<<0)
-#define BNX2_MISC_DUAL_MEDIA_CTRL_PHY_CTRL_STRAP	 (0x7L<<8)
-#define BNX2_MISC_DUAL_MEDIA_CTRL_PORT_SWAP_PIN		 (1L<<11)
-#define BNX2_MISC_DUAL_MEDIA_CTRL_SERDES1_SIGDET	 (1L<<12)
-#define BNX2_MISC_DUAL_MEDIA_CTRL_SERDES0_SIGDET	 (1L<<13)
-#define BNX2_MISC_DUAL_MEDIA_CTRL_PHY1_SIGDET		 (1L<<14)
-#define BNX2_MISC_DUAL_MEDIA_CTRL_PHY0_SIGDET		 (1L<<15)
-#define BNX2_MISC_DUAL_MEDIA_CTRL_LCPLL_RST		 (1L<<16)
-#define BNX2_MISC_DUAL_MEDIA_CTRL_SERDES1_RST		 (1L<<17)
-#define BNX2_MISC_DUAL_MEDIA_CTRL_SERDES0_RST		 (1L<<18)
-#define BNX2_MISC_DUAL_MEDIA_CTRL_PHY1_RST		 (1L<<19)
-#define BNX2_MISC_DUAL_MEDIA_CTRL_PHY0_RST		 (1L<<20)
-#define BNX2_MISC_DUAL_MEDIA_CTRL_PHY_CTRL		 (0x7L<<21)
-#define BNX2_MISC_DUAL_MEDIA_CTRL_PORT_SWAP		 (1L<<24)
-#define BNX2_MISC_DUAL_MEDIA_CTRL_STRAP_OVERRIDE	 (1L<<25)
-#define BNX2_MISC_DUAL_MEDIA_CTRL_PHY_SERDES_IDDQ	 (0xfL<<26)
-#define BNX2_MISC_DUAL_MEDIA_CTRL_PHY_SERDES_IDDQ_SER1_IDDQ	 (1L<<26)
-#define BNX2_MISC_DUAL_MEDIA_CTRL_PHY_SERDES_IDDQ_SER0_IDDQ	 (2L<<26)
-#define BNX2_MISC_DUAL_MEDIA_CTRL_PHY_SERDES_IDDQ_PHY1_IDDQ	 (4L<<26)
-#define BNX2_MISC_DUAL_MEDIA_CTRL_PHY_SERDES_IDDQ_PHY0_IDDQ	 (8L<<26)
-
-#define BNX2_MISC_OTP_CMD1				0x000008f0
-#define BNX2_MISC_OTP_CMD1_FMODE			 (0x7L<<0)
-#define BNX2_MISC_OTP_CMD1_FMODE_IDLE			 (0L<<0)
-#define BNX2_MISC_OTP_CMD1_FMODE_WRITE			 (1L<<0)
-#define BNX2_MISC_OTP_CMD1_FMODE_INIT			 (2L<<0)
-#define BNX2_MISC_OTP_CMD1_FMODE_SET			 (3L<<0)
-#define BNX2_MISC_OTP_CMD1_FMODE_RST			 (4L<<0)
-#define BNX2_MISC_OTP_CMD1_FMODE_VERIFY			 (5L<<0)
-#define BNX2_MISC_OTP_CMD1_FMODE_RESERVED0		 (6L<<0)
-#define BNX2_MISC_OTP_CMD1_FMODE_RESERVED1		 (7L<<0)
-#define BNX2_MISC_OTP_CMD1_USEPINS			 (1L<<8)
-#define BNX2_MISC_OTP_CMD1_PROGSEL			 (1L<<9)
-#define BNX2_MISC_OTP_CMD1_PROGSTART			 (1L<<10)
-#define BNX2_MISC_OTP_CMD1_PCOUNT			 (0x7L<<16)
-#define BNX2_MISC_OTP_CMD1_PBYP				 (1L<<19)
-#define BNX2_MISC_OTP_CMD1_VSEL				 (0xfL<<20)
-#define BNX2_MISC_OTP_CMD1_TM				 (0x7L<<27)
-#define BNX2_MISC_OTP_CMD1_SADBYP			 (1L<<30)
-#define BNX2_MISC_OTP_CMD1_DEBUG			 (1L<<31)
-
-#define BNX2_MISC_OTP_CMD2				0x000008f4
-#define BNX2_MISC_OTP_CMD2_OTP_ROM_ADDR			 (0x3ffL<<0)
-#define BNX2_MISC_OTP_CMD2_DOSEL			 (0x7fL<<16)
-#define BNX2_MISC_OTP_CMD2_DOSEL_0			 (0L<<16)
-#define BNX2_MISC_OTP_CMD2_DOSEL_1			 (1L<<16)
-#define BNX2_MISC_OTP_CMD2_DOSEL_127			 (127L<<16)
-
-#define BNX2_MISC_OTP_STATUS				0x000008f8
-#define BNX2_MISC_OTP_STATUS_DATA			 (0xffL<<0)
-#define BNX2_MISC_OTP_STATUS_VALID			 (1L<<8)
-#define BNX2_MISC_OTP_STATUS_BUSY			 (1L<<9)
-#define BNX2_MISC_OTP_STATUS_BUSYSM			 (1L<<10)
-#define BNX2_MISC_OTP_STATUS_DONE			 (1L<<11)
-
-#define BNX2_MISC_OTP_SHIFT1_CMD			0x000008fc
-#define BNX2_MISC_OTP_SHIFT1_CMD_RESET_MODE_N		 (1L<<0)
-#define BNX2_MISC_OTP_SHIFT1_CMD_SHIFT_DONE		 (1L<<1)
-#define BNX2_MISC_OTP_SHIFT1_CMD_SHIFT_START		 (1L<<2)
-#define BNX2_MISC_OTP_SHIFT1_CMD_LOAD_DATA		 (1L<<3)
-#define BNX2_MISC_OTP_SHIFT1_CMD_SHIFT_SELECT		 (0x1fL<<8)
-
-#define BNX2_MISC_OTP_SHIFT1_DATA			0x00000900
-#define BNX2_MISC_OTP_SHIFT2_CMD			0x00000904
-#define BNX2_MISC_OTP_SHIFT2_CMD_RESET_MODE_N		 (1L<<0)
-#define BNX2_MISC_OTP_SHIFT2_CMD_SHIFT_DONE		 (1L<<1)
-#define BNX2_MISC_OTP_SHIFT2_CMD_SHIFT_START		 (1L<<2)
-#define BNX2_MISC_OTP_SHIFT2_CMD_LOAD_DATA		 (1L<<3)
-#define BNX2_MISC_OTP_SHIFT2_CMD_SHIFT_SELECT		 (0x1fL<<8)
-
-#define BNX2_MISC_OTP_SHIFT2_DATA			0x00000908
-#define BNX2_MISC_BIST_CS0				0x0000090c
-#define BNX2_MISC_BIST_CS0_MBIST_EN			 (1L<<0)
-#define BNX2_MISC_BIST_CS0_BIST_SETUP			 (0x3L<<1)
-#define BNX2_MISC_BIST_CS0_MBIST_ASYNC_RESET		 (1L<<3)
-#define BNX2_MISC_BIST_CS0_MBIST_DONE			 (1L<<8)
-#define BNX2_MISC_BIST_CS0_MBIST_GO			 (1L<<9)
-#define BNX2_MISC_BIST_CS0_BIST_OVERRIDE		 (1L<<31)
-
-#define BNX2_MISC_BIST_MEMSTATUS0			0x00000910
-#define BNX2_MISC_BIST_CS1				0x00000914
-#define BNX2_MISC_BIST_CS1_MBIST_EN			 (1L<<0)
-#define BNX2_MISC_BIST_CS1_BIST_SETUP			 (0x3L<<1)
-#define BNX2_MISC_BIST_CS1_MBIST_ASYNC_RESET		 (1L<<3)
-#define BNX2_MISC_BIST_CS1_MBIST_DONE			 (1L<<8)
-#define BNX2_MISC_BIST_CS1_MBIST_GO			 (1L<<9)
-
-#define BNX2_MISC_BIST_MEMSTATUS1			0x00000918
-#define BNX2_MISC_BIST_CS2				0x0000091c
-#define BNX2_MISC_BIST_CS2_MBIST_EN			 (1L<<0)
-#define BNX2_MISC_BIST_CS2_BIST_SETUP			 (0x3L<<1)
-#define BNX2_MISC_BIST_CS2_MBIST_ASYNC_RESET		 (1L<<3)
-#define BNX2_MISC_BIST_CS2_MBIST_DONE			 (1L<<8)
-#define BNX2_MISC_BIST_CS2_MBIST_GO			 (1L<<9)
-
-#define BNX2_MISC_BIST_MEMSTATUS2			0x00000920
-#define BNX2_MISC_BIST_CS3				0x00000924
-#define BNX2_MISC_BIST_CS3_MBIST_EN			 (1L<<0)
-#define BNX2_MISC_BIST_CS3_BIST_SETUP			 (0x3L<<1)
-#define BNX2_MISC_BIST_CS3_MBIST_ASYNC_RESET		 (1L<<3)
-#define BNX2_MISC_BIST_CS3_MBIST_DONE			 (1L<<8)
-#define BNX2_MISC_BIST_CS3_MBIST_GO			 (1L<<9)
-
-#define BNX2_MISC_BIST_MEMSTATUS3			0x00000928
-#define BNX2_MISC_BIST_CS4				0x0000092c
-#define BNX2_MISC_BIST_CS4_MBIST_EN			 (1L<<0)
-#define BNX2_MISC_BIST_CS4_BIST_SETUP			 (0x3L<<1)
-#define BNX2_MISC_BIST_CS4_MBIST_ASYNC_RESET		 (1L<<3)
-#define BNX2_MISC_BIST_CS4_MBIST_DONE			 (1L<<8)
-#define BNX2_MISC_BIST_CS4_MBIST_GO			 (1L<<9)
-
-#define BNX2_MISC_BIST_MEMSTATUS4			0x00000930
-#define BNX2_MISC_BIST_CS5				0x00000934
-#define BNX2_MISC_BIST_CS5_MBIST_EN			 (1L<<0)
-#define BNX2_MISC_BIST_CS5_BIST_SETUP			 (0x3L<<1)
-#define BNX2_MISC_BIST_CS5_MBIST_ASYNC_RESET		 (1L<<3)
-#define BNX2_MISC_BIST_CS5_MBIST_DONE			 (1L<<8)
-#define BNX2_MISC_BIST_CS5_MBIST_GO			 (1L<<9)
-
-#define BNX2_MISC_BIST_MEMSTATUS5			0x00000938
-#define BNX2_MISC_MEM_TM0				0x0000093c
-#define BNX2_MISC_MEM_TM0_PCIE_REPLAY_TM		 (0xfL<<0)
-#define BNX2_MISC_MEM_TM0_MCP_SCPAD			 (0xfL<<8)
-#define BNX2_MISC_MEM_TM0_UMP_TM			 (0xffL<<16)
-#define BNX2_MISC_MEM_TM0_HB_MEM_TM			 (0xfL<<24)
-
-#define BNX2_MISC_USPLL_CTRL				0x00000940
-#define BNX2_MISC_USPLL_CTRL_PH_DET_DIS			 (1L<<0)
-#define BNX2_MISC_USPLL_CTRL_FREQ_DET_DIS		 (1L<<1)
-#define BNX2_MISC_USPLL_CTRL_LCPX			 (0x3fL<<2)
-#define BNX2_MISC_USPLL_CTRL_RX				 (0x3L<<8)
-#define BNX2_MISC_USPLL_CTRL_VC_EN			 (1L<<10)
-#define BNX2_MISC_USPLL_CTRL_VCO_MG			 (0x3L<<11)
-#define BNX2_MISC_USPLL_CTRL_KVCO_XF			 (0x7L<<13)
-#define BNX2_MISC_USPLL_CTRL_KVCO_XS			 (0x7L<<16)
-#define BNX2_MISC_USPLL_CTRL_TESTD_EN			 (1L<<19)
-#define BNX2_MISC_USPLL_CTRL_TESTD_SEL			 (0x7L<<20)
-#define BNX2_MISC_USPLL_CTRL_TESTA_EN			 (1L<<23)
-#define BNX2_MISC_USPLL_CTRL_TESTA_SEL			 (0x3L<<24)
-#define BNX2_MISC_USPLL_CTRL_ATTEN_FREF			 (1L<<26)
-#define BNX2_MISC_USPLL_CTRL_DIGITAL_RST		 (1L<<27)
-#define BNX2_MISC_USPLL_CTRL_ANALOG_RST			 (1L<<28)
-#define BNX2_MISC_USPLL_CTRL_LOCK			 (1L<<29)
-
-#define BNX2_MISC_PERR_STATUS0				0x00000944
-#define BNX2_MISC_PERR_STATUS0_COM_DMAE_PERR		 (1L<<0)
-#define BNX2_MISC_PERR_STATUS0_CP_DMAE_PERR		 (1L<<1)
-#define BNX2_MISC_PERR_STATUS0_RPM_ACPIBEMEM_PERR	 (1L<<2)
-#define BNX2_MISC_PERR_STATUS0_CTX_USAGE_CNT_PERR	 (1L<<3)
-#define BNX2_MISC_PERR_STATUS0_CTX_PGTBL_PERR		 (1L<<4)
-#define BNX2_MISC_PERR_STATUS0_CTX_CACHE_PERR		 (1L<<5)
-#define BNX2_MISC_PERR_STATUS0_CTX_MIRROR_PERR		 (1L<<6)
-#define BNX2_MISC_PERR_STATUS0_COM_CTXC_PERR		 (1L<<7)
-#define BNX2_MISC_PERR_STATUS0_COM_SCPAD_PERR		 (1L<<8)
-#define BNX2_MISC_PERR_STATUS0_CP_CTXC_PERR		 (1L<<9)
-#define BNX2_MISC_PERR_STATUS0_CP_SCPAD_PERR		 (1L<<10)
-#define BNX2_MISC_PERR_STATUS0_RXP_RBUFC_PERR		 (1L<<11)
-#define BNX2_MISC_PERR_STATUS0_RXP_CTXC_PERR		 (1L<<12)
-#define BNX2_MISC_PERR_STATUS0_RXP_SCPAD_PERR		 (1L<<13)
-#define BNX2_MISC_PERR_STATUS0_TPAT_SCPAD_PERR		 (1L<<14)
-#define BNX2_MISC_PERR_STATUS0_TXP_CTXC_PERR		 (1L<<15)
-#define BNX2_MISC_PERR_STATUS0_TXP_SCPAD_PERR		 (1L<<16)
-#define BNX2_MISC_PERR_STATUS0_CS_TMEM_PERR		 (1L<<17)
-#define BNX2_MISC_PERR_STATUS0_MQ_CTX_PERR		 (1L<<18)
-#define BNX2_MISC_PERR_STATUS0_RPM_DFIFOMEM_PERR	 (1L<<19)
-#define BNX2_MISC_PERR_STATUS0_RPC_DFIFOMEM_PERR	 (1L<<20)
-#define BNX2_MISC_PERR_STATUS0_RBUF_PTRMEM_PERR		 (1L<<21)
-#define BNX2_MISC_PERR_STATUS0_RBUF_DATAMEM_PERR	 (1L<<22)
-#define BNX2_MISC_PERR_STATUS0_RV2P_P2IRAM_PERR		 (1L<<23)
-#define BNX2_MISC_PERR_STATUS0_RV2P_P1IRAM_PERR		 (1L<<24)
-#define BNX2_MISC_PERR_STATUS0_RV2P_CB1REGS_PERR	 (1L<<25)
-#define BNX2_MISC_PERR_STATUS0_RV2P_CB0REGS_PERR	 (1L<<26)
-#define BNX2_MISC_PERR_STATUS0_TPBUF_PERR		 (1L<<27)
-#define BNX2_MISC_PERR_STATUS0_THBUF_PERR		 (1L<<28)
-#define BNX2_MISC_PERR_STATUS0_TDMA_PERR		 (1L<<29)
-#define BNX2_MISC_PERR_STATUS0_TBDC_PERR		 (1L<<30)
-#define BNX2_MISC_PERR_STATUS0_TSCH_LR_PERR		 (1L<<31)
-
-#define BNX2_MISC_PERR_STATUS1				0x00000948
-#define BNX2_MISC_PERR_STATUS1_RBDC_PERR		 (1L<<0)
-#define BNX2_MISC_PERR_STATUS1_RDMA_DFIFO_PERR		 (1L<<2)
-#define BNX2_MISC_PERR_STATUS1_HC_STATS_PERR		 (1L<<3)
-#define BNX2_MISC_PERR_STATUS1_HC_MSIX_PERR		 (1L<<4)
-#define BNX2_MISC_PERR_STATUS1_HC_PRODUCSTB_PERR	 (1L<<5)
-#define BNX2_MISC_PERR_STATUS1_HC_CONSUMSTB_PERR	 (1L<<6)
-#define BNX2_MISC_PERR_STATUS1_TPATQ_PERR		 (1L<<7)
-#define BNX2_MISC_PERR_STATUS1_MCPQ_PERR		 (1L<<8)
-#define BNX2_MISC_PERR_STATUS1_TDMAQ_PERR		 (1L<<9)
-#define BNX2_MISC_PERR_STATUS1_TXPQ_PERR		 (1L<<10)
-#define BNX2_MISC_PERR_STATUS1_COMTQ_PERR		 (1L<<11)
-#define BNX2_MISC_PERR_STATUS1_COMQ_PERR		 (1L<<12)
-#define BNX2_MISC_PERR_STATUS1_RLUPQ_PERR		 (1L<<13)
-#define BNX2_MISC_PERR_STATUS1_RXPQ_PERR		 (1L<<14)
-#define BNX2_MISC_PERR_STATUS1_RV2PPQ_PERR		 (1L<<15)
-#define BNX2_MISC_PERR_STATUS1_RDMAQ_PERR		 (1L<<16)
-#define BNX2_MISC_PERR_STATUS1_TASQ_PERR		 (1L<<17)
-#define BNX2_MISC_PERR_STATUS1_TBDRQ_PERR		 (1L<<18)
-#define BNX2_MISC_PERR_STATUS1_TSCHQ_PERR		 (1L<<19)
-#define BNX2_MISC_PERR_STATUS1_COMXQ_PERR		 (1L<<20)
-#define BNX2_MISC_PERR_STATUS1_RXPCQ_PERR		 (1L<<21)
-#define BNX2_MISC_PERR_STATUS1_RV2PTQ_PERR		 (1L<<22)
-#define BNX2_MISC_PERR_STATUS1_RV2PMQ_PERR		 (1L<<23)
-#define BNX2_MISC_PERR_STATUS1_CPQ_PERR			 (1L<<24)
-#define BNX2_MISC_PERR_STATUS1_CSQ_PERR			 (1L<<25)
-#define BNX2_MISC_PERR_STATUS1_RLUP_CID_PERR		 (1L<<26)
-#define BNX2_MISC_PERR_STATUS1_RV2PCS_TMEM_PERR		 (1L<<27)
-#define BNX2_MISC_PERR_STATUS1_RV2PCSQ_PERR		 (1L<<28)
-#define BNX2_MISC_PERR_STATUS1_MQ_IDX_PERR		 (1L<<29)
-
-#define BNX2_MISC_PERR_STATUS2				0x0000094c
-#define BNX2_MISC_PERR_STATUS2_TGT_FIFO_PERR		 (1L<<0)
-#define BNX2_MISC_PERR_STATUS2_UMP_TX_PERR		 (1L<<1)
-#define BNX2_MISC_PERR_STATUS2_UMP_RX_PERR		 (1L<<2)
-#define BNX2_MISC_PERR_STATUS2_MCP_ROM_PERR		 (1L<<3)
-#define BNX2_MISC_PERR_STATUS2_MCP_SCPAD_PERR		 (1L<<4)
-#define BNX2_MISC_PERR_STATUS2_HB_MEM_PERR		 (1L<<5)
-#define BNX2_MISC_PERR_STATUS2_PCIE_REPLAY_PERR		 (1L<<6)
-
-#define BNX2_MISC_LCPLL_CTRL0				0x00000950
-#define BNX2_MISC_LCPLL_CTRL0_OAC			 (0x7L<<0)
-#define BNX2_MISC_LCPLL_CTRL0_OAC_NEGTWENTY		 (0L<<0)
-#define BNX2_MISC_LCPLL_CTRL0_OAC_ZERO			 (1L<<0)
-#define BNX2_MISC_LCPLL_CTRL0_OAC_TWENTY		 (3L<<0)
-#define BNX2_MISC_LCPLL_CTRL0_OAC_FORTY			 (7L<<0)
-#define BNX2_MISC_LCPLL_CTRL0_ICP_CTRL			 (0x7L<<3)
-#define BNX2_MISC_LCPLL_CTRL0_ICP_CTRL_360		 (0L<<3)
-#define BNX2_MISC_LCPLL_CTRL0_ICP_CTRL_480		 (1L<<3)
-#define BNX2_MISC_LCPLL_CTRL0_ICP_CTRL_600		 (3L<<3)
-#define BNX2_MISC_LCPLL_CTRL0_ICP_CTRL_720		 (7L<<3)
-#define BNX2_MISC_LCPLL_CTRL0_BIAS_CTRL			 (0x3L<<6)
-#define BNX2_MISC_LCPLL_CTRL0_PLL_OBSERVE		 (0x7L<<8)
-#define BNX2_MISC_LCPLL_CTRL0_VTH_CTRL			 (0x3L<<11)
-#define BNX2_MISC_LCPLL_CTRL0_VTH_CTRL_0		 (0L<<11)
-#define BNX2_MISC_LCPLL_CTRL0_VTH_CTRL_1		 (1L<<11)
-#define BNX2_MISC_LCPLL_CTRL0_VTH_CTRL_2		 (2L<<11)
-#define BNX2_MISC_LCPLL_CTRL0_PLLSEQSTART		 (1L<<13)
-#define BNX2_MISC_LCPLL_CTRL0_RESERVED			 (1L<<14)
-#define BNX2_MISC_LCPLL_CTRL0_CAPRETRY_EN		 (1L<<15)
-#define BNX2_MISC_LCPLL_CTRL0_FREQMONITOR_EN		 (1L<<16)
-#define BNX2_MISC_LCPLL_CTRL0_FREQDETRESTART_EN		 (1L<<17)
-#define BNX2_MISC_LCPLL_CTRL0_FREQDETRETRY_EN		 (1L<<18)
-#define BNX2_MISC_LCPLL_CTRL0_PLLFORCEFDONE_EN		 (1L<<19)
-#define BNX2_MISC_LCPLL_CTRL0_PLLFORCEFDONE		 (1L<<20)
-#define BNX2_MISC_LCPLL_CTRL0_PLLFORCEFPASS		 (1L<<21)
-#define BNX2_MISC_LCPLL_CTRL0_PLLFORCECAPDONE_EN	 (1L<<22)
-#define BNX2_MISC_LCPLL_CTRL0_PLLFORCECAPDONE		 (1L<<23)
-#define BNX2_MISC_LCPLL_CTRL0_PLLFORCECAPPASS_EN	 (1L<<24)
-#define BNX2_MISC_LCPLL_CTRL0_PLLFORCECAPPASS		 (1L<<25)
-#define BNX2_MISC_LCPLL_CTRL0_CAPRESTART		 (1L<<26)
-#define BNX2_MISC_LCPLL_CTRL0_CAPSELECTM_EN		 (1L<<27)
-
-#define BNX2_MISC_LCPLL_CTRL1				0x00000954
-#define BNX2_MISC_LCPLL_CTRL1_CAPSELECTM		 (0x1fL<<0)
-#define BNX2_MISC_LCPLL_CTRL1_CAPFORCESLOWDOWN_EN	 (1L<<5)
-#define BNX2_MISC_LCPLL_CTRL1_CAPFORCESLOWDOWN		 (1L<<6)
-#define BNX2_MISC_LCPLL_CTRL1_SLOWDN_XOR		 (1L<<7)
-
-#define BNX2_MISC_LCPLL_STATUS				0x00000958
-#define BNX2_MISC_LCPLL_STATUS_FREQDONE_SM		 (1L<<0)
-#define BNX2_MISC_LCPLL_STATUS_FREQPASS_SM		 (1L<<1)
-#define BNX2_MISC_LCPLL_STATUS_PLLSEQDONE		 (1L<<2)
-#define BNX2_MISC_LCPLL_STATUS_PLLSEQPASS		 (1L<<3)
-#define BNX2_MISC_LCPLL_STATUS_PLLSTATE			 (0x7L<<4)
-#define BNX2_MISC_LCPLL_STATUS_CAPSTATE			 (0x7L<<7)
-#define BNX2_MISC_LCPLL_STATUS_CAPSELECT		 (0x1fL<<10)
-#define BNX2_MISC_LCPLL_STATUS_SLOWDN_INDICATOR		 (1L<<15)
-#define BNX2_MISC_LCPLL_STATUS_SLOWDN_INDICATOR_0	 (0L<<15)
-#define BNX2_MISC_LCPLL_STATUS_SLOWDN_INDICATOR_1	 (1L<<15)
-
-#define BNX2_MISC_OSCFUNDS_CTRL				0x0000095c
-#define BNX2_MISC_OSCFUNDS_CTRL_FREQ_MON		 (1L<<5)
-#define BNX2_MISC_OSCFUNDS_CTRL_FREQ_MON_OFF		 (0L<<5)
-#define BNX2_MISC_OSCFUNDS_CTRL_FREQ_MON_ON		 (1L<<5)
-#define BNX2_MISC_OSCFUNDS_CTRL_XTAL_ADJCM		 (0x3L<<6)
-#define BNX2_MISC_OSCFUNDS_CTRL_XTAL_ADJCM_0		 (0L<<6)
-#define BNX2_MISC_OSCFUNDS_CTRL_XTAL_ADJCM_1		 (1L<<6)
-#define BNX2_MISC_OSCFUNDS_CTRL_XTAL_ADJCM_2		 (2L<<6)
-#define BNX2_MISC_OSCFUNDS_CTRL_XTAL_ADJCM_3		 (3L<<6)
-#define BNX2_MISC_OSCFUNDS_CTRL_ICBUF_ADJ		 (0x3L<<8)
-#define BNX2_MISC_OSCFUNDS_CTRL_ICBUF_ADJ_0		 (0L<<8)
-#define BNX2_MISC_OSCFUNDS_CTRL_ICBUF_ADJ_1		 (1L<<8)
-#define BNX2_MISC_OSCFUNDS_CTRL_ICBUF_ADJ_2		 (2L<<8)
-#define BNX2_MISC_OSCFUNDS_CTRL_ICBUF_ADJ_3		 (3L<<8)
-#define BNX2_MISC_OSCFUNDS_CTRL_IAMP_ADJ		 (0x3L<<10)
-#define BNX2_MISC_OSCFUNDS_CTRL_IAMP_ADJ_0		 (0L<<10)
-#define BNX2_MISC_OSCFUNDS_CTRL_IAMP_ADJ_1		 (1L<<10)
-#define BNX2_MISC_OSCFUNDS_CTRL_IAMP_ADJ_2		 (2L<<10)
-#define BNX2_MISC_OSCFUNDS_CTRL_IAMP_ADJ_3		 (3L<<10)
-
-
-/*
- *  nvm_reg definition
- *  offset: 0x6400
- */
-#define BNX2_NVM_COMMAND				0x00006400
-#define BNX2_NVM_COMMAND_RST				 (1L<<0)
-#define BNX2_NVM_COMMAND_DONE				 (1L<<3)
-#define BNX2_NVM_COMMAND_DOIT				 (1L<<4)
-#define BNX2_NVM_COMMAND_WR				 (1L<<5)
-#define BNX2_NVM_COMMAND_ERASE				 (1L<<6)
-#define BNX2_NVM_COMMAND_FIRST				 (1L<<7)
-#define BNX2_NVM_COMMAND_LAST				 (1L<<8)
-#define BNX2_NVM_COMMAND_WREN				 (1L<<16)
-#define BNX2_NVM_COMMAND_WRDI				 (1L<<17)
-#define BNX2_NVM_COMMAND_EWSR				 (1L<<18)
-#define BNX2_NVM_COMMAND_WRSR				 (1L<<19)
-#define BNX2_NVM_COMMAND_RD_ID				 (1L<<20)
-#define BNX2_NVM_COMMAND_RD_STATUS			 (1L<<21)
-#define BNX2_NVM_COMMAND_MODE_256			 (1L<<22)
-
-#define BNX2_NVM_STATUS					0x00006404
-#define BNX2_NVM_STATUS_PI_FSM_STATE			 (0xfL<<0)
-#define BNX2_NVM_STATUS_EE_FSM_STATE			 (0xfL<<4)
-#define BNX2_NVM_STATUS_EQ_FSM_STATE			 (0xfL<<8)
-#define BNX2_NVM_STATUS_SPI_FSM_STATE_XI		 (0x1fL<<0)
-#define BNX2_NVM_STATUS_SPI_FSM_STATE_SPI_IDLE_XI	 (0L<<0)
-#define BNX2_NVM_STATUS_SPI_FSM_STATE_SPI_CMD0_XI	 (1L<<0)
-#define BNX2_NVM_STATUS_SPI_FSM_STATE_SPI_CMD1_XI	 (2L<<0)
-#define BNX2_NVM_STATUS_SPI_FSM_STATE_SPI_CMD_FINISH0_XI	 (3L<<0)
-#define BNX2_NVM_STATUS_SPI_FSM_STATE_SPI_CMD_FINISH1_XI	 (4L<<0)
-#define BNX2_NVM_STATUS_SPI_FSM_STATE_SPI_ADDR0_XI	 (5L<<0)
-#define BNX2_NVM_STATUS_SPI_FSM_STATE_SPI_WRITE_DATA0_XI	 (6L<<0)
-#define BNX2_NVM_STATUS_SPI_FSM_STATE_SPI_WRITE_DATA1_XI	 (7L<<0)
-#define BNX2_NVM_STATUS_SPI_FSM_STATE_SPI_WRITE_DATA2_XI	 (8L<<0)
-#define BNX2_NVM_STATUS_SPI_FSM_STATE_SPI_READ_DATA0_XI	 (9L<<0)
-#define BNX2_NVM_STATUS_SPI_FSM_STATE_SPI_READ_DATA1_XI	 (10L<<0)
-#define BNX2_NVM_STATUS_SPI_FSM_STATE_SPI_READ_DATA2_XI	 (11L<<0)
-#define BNX2_NVM_STATUS_SPI_FSM_STATE_SPI_READ_STATUS_RDID0_XI	 (12L<<0)
-#define BNX2_NVM_STATUS_SPI_FSM_STATE_SPI_READ_STATUS_RDID1_XI	 (13L<<0)
-#define BNX2_NVM_STATUS_SPI_FSM_STATE_SPI_READ_STATUS_RDID2_XI	 (14L<<0)
-#define BNX2_NVM_STATUS_SPI_FSM_STATE_SPI_READ_STATUS_RDID3_XI	 (15L<<0)
-#define BNX2_NVM_STATUS_SPI_FSM_STATE_SPI_READ_STATUS_RDID4_XI	 (16L<<0)
-#define BNX2_NVM_STATUS_SPI_FSM_STATE_SPI_CHECK_BUSY0_XI	 (17L<<0)
-#define BNX2_NVM_STATUS_SPI_FSM_STATE_SPI_ST_WREN_XI	 (18L<<0)
-#define BNX2_NVM_STATUS_SPI_FSM_STATE_SPI_WAIT_XI	 (19L<<0)
-
-#define BNX2_NVM_WRITE					0x00006408
-#define BNX2_NVM_WRITE_NVM_WRITE_VALUE			 (0xffffffffL<<0)
-#define BNX2_NVM_WRITE_NVM_WRITE_VALUE_BIT_BANG		 (0L<<0)
-#define BNX2_NVM_WRITE_NVM_WRITE_VALUE_EECLK		 (1L<<0)
-#define BNX2_NVM_WRITE_NVM_WRITE_VALUE_EEDATA		 (2L<<0)
-#define BNX2_NVM_WRITE_NVM_WRITE_VALUE_SCLK		 (4L<<0)
-#define BNX2_NVM_WRITE_NVM_WRITE_VALUE_CS_B		 (8L<<0)
-#define BNX2_NVM_WRITE_NVM_WRITE_VALUE_SO		 (16L<<0)
-#define BNX2_NVM_WRITE_NVM_WRITE_VALUE_SI		 (32L<<0)
-#define BNX2_NVM_WRITE_NVM_WRITE_VALUE_SI_XI		 (1L<<0)
-#define BNX2_NVM_WRITE_NVM_WRITE_VALUE_SO_XI		 (2L<<0)
-#define BNX2_NVM_WRITE_NVM_WRITE_VALUE_CS_B_XI		 (4L<<0)
-#define BNX2_NVM_WRITE_NVM_WRITE_VALUE_SCLK_XI		 (8L<<0)
-
-#define BNX2_NVM_ADDR					0x0000640c
-#define BNX2_NVM_ADDR_NVM_ADDR_VALUE			 (0xffffffL<<0)
-#define BNX2_NVM_ADDR_NVM_ADDR_VALUE_BIT_BANG		 (0L<<0)
-#define BNX2_NVM_ADDR_NVM_ADDR_VALUE_EECLK		 (1L<<0)
-#define BNX2_NVM_ADDR_NVM_ADDR_VALUE_EEDATA		 (2L<<0)
-#define BNX2_NVM_ADDR_NVM_ADDR_VALUE_SCLK		 (4L<<0)
-#define BNX2_NVM_ADDR_NVM_ADDR_VALUE_CS_B		 (8L<<0)
-#define BNX2_NVM_ADDR_NVM_ADDR_VALUE_SO			 (16L<<0)
-#define BNX2_NVM_ADDR_NVM_ADDR_VALUE_SI			 (32L<<0)
-#define BNX2_NVM_ADDR_NVM_ADDR_VALUE_SI_XI		 (1L<<0)
-#define BNX2_NVM_ADDR_NVM_ADDR_VALUE_SO_XI		 (2L<<0)
-#define BNX2_NVM_ADDR_NVM_ADDR_VALUE_CS_B_XI		 (4L<<0)
-#define BNX2_NVM_ADDR_NVM_ADDR_VALUE_SCLK_XI		 (8L<<0)
-
-#define BNX2_NVM_READ					0x00006410
-#define BNX2_NVM_READ_NVM_READ_VALUE			 (0xffffffffL<<0)
-#define BNX2_NVM_READ_NVM_READ_VALUE_BIT_BANG		 (0L<<0)
-#define BNX2_NVM_READ_NVM_READ_VALUE_EECLK		 (1L<<0)
-#define BNX2_NVM_READ_NVM_READ_VALUE_EEDATA		 (2L<<0)
-#define BNX2_NVM_READ_NVM_READ_VALUE_SCLK		 (4L<<0)
-#define BNX2_NVM_READ_NVM_READ_VALUE_CS_B		 (8L<<0)
-#define BNX2_NVM_READ_NVM_READ_VALUE_SO			 (16L<<0)
-#define BNX2_NVM_READ_NVM_READ_VALUE_SI			 (32L<<0)
-#define BNX2_NVM_READ_NVM_READ_VALUE_SI_XI		 (1L<<0)
-#define BNX2_NVM_READ_NVM_READ_VALUE_SO_XI		 (2L<<0)
-#define BNX2_NVM_READ_NVM_READ_VALUE_CS_B_XI		 (4L<<0)
-#define BNX2_NVM_READ_NVM_READ_VALUE_SCLK_XI		 (8L<<0)
-
-#define BNX2_NVM_CFG1					0x00006414
-#define BNX2_NVM_CFG1_FLASH_MODE			 (1L<<0)
-#define BNX2_NVM_CFG1_BUFFER_MODE			 (1L<<1)
-#define BNX2_NVM_CFG1_PASS_MODE				 (1L<<2)
-#define BNX2_NVM_CFG1_BITBANG_MODE			 (1L<<3)
-#define BNX2_NVM_CFG1_STATUS_BIT			 (0x7L<<4)
-#define BNX2_NVM_CFG1_STATUS_BIT_FLASH_RDY		 (0L<<4)
-#define BNX2_NVM_CFG1_STATUS_BIT_BUFFER_RDY		 (7L<<4)
-#define BNX2_NVM_CFG1_SPI_CLK_DIV			 (0xfL<<7)
-#define BNX2_NVM_CFG1_SEE_CLK_DIV			 (0x7ffL<<11)
-#define BNX2_NVM_CFG1_STRAP_CONTROL_0			 (1L<<23)
-#define BNX2_NVM_CFG1_PROTECT_MODE			 (1L<<24)
-#define BNX2_NVM_CFG1_FLASH_SIZE			 (1L<<25)
-#define BNX2_NVM_CFG1_FW_USTRAP_1			 (1L<<26)
-#define BNX2_NVM_CFG1_FW_USTRAP_0			 (1L<<27)
-#define BNX2_NVM_CFG1_FW_USTRAP_2			 (1L<<28)
-#define BNX2_NVM_CFG1_FW_USTRAP_3			 (1L<<29)
-#define BNX2_NVM_CFG1_FW_FLASH_TYPE_EN			 (1L<<30)
-#define BNX2_NVM_CFG1_COMPAT_BYPASSS			 (1L<<31)
-
-#define BNX2_NVM_CFG2					0x00006418
-#define BNX2_NVM_CFG2_ERASE_CMD				 (0xffL<<0)
-#define BNX2_NVM_CFG2_DUMMY				 (0xffL<<8)
-#define BNX2_NVM_CFG2_STATUS_CMD			 (0xffL<<16)
-#define BNX2_NVM_CFG2_READ_ID				 (0xffL<<24)
-
-#define BNX2_NVM_CFG3					0x0000641c
-#define BNX2_NVM_CFG3_BUFFER_RD_CMD			 (0xffL<<0)
-#define BNX2_NVM_CFG3_WRITE_CMD				 (0xffL<<8)
-#define BNX2_NVM_CFG3_BUFFER_WRITE_CMD			 (0xffL<<16)
-#define BNX2_NVM_CFG3_READ_CMD				 (0xffL<<24)
-
-#define BNX2_NVM_SW_ARB					0x00006420
-#define BNX2_NVM_SW_ARB_ARB_REQ_SET0			 (1L<<0)
-#define BNX2_NVM_SW_ARB_ARB_REQ_SET1			 (1L<<1)
-#define BNX2_NVM_SW_ARB_ARB_REQ_SET2			 (1L<<2)
-#define BNX2_NVM_SW_ARB_ARB_REQ_SET3			 (1L<<3)
-#define BNX2_NVM_SW_ARB_ARB_REQ_CLR0			 (1L<<4)
-#define BNX2_NVM_SW_ARB_ARB_REQ_CLR1			 (1L<<5)
-#define BNX2_NVM_SW_ARB_ARB_REQ_CLR2			 (1L<<6)
-#define BNX2_NVM_SW_ARB_ARB_REQ_CLR3			 (1L<<7)
-#define BNX2_NVM_SW_ARB_ARB_ARB0			 (1L<<8)
-#define BNX2_NVM_SW_ARB_ARB_ARB1			 (1L<<9)
-#define BNX2_NVM_SW_ARB_ARB_ARB2			 (1L<<10)
-#define BNX2_NVM_SW_ARB_ARB_ARB3			 (1L<<11)
-#define BNX2_NVM_SW_ARB_REQ0				 (1L<<12)
-#define BNX2_NVM_SW_ARB_REQ1				 (1L<<13)
-#define BNX2_NVM_SW_ARB_REQ2				 (1L<<14)
-#define BNX2_NVM_SW_ARB_REQ3				 (1L<<15)
-
-#define BNX2_NVM_ACCESS_ENABLE				0x00006424
-#define BNX2_NVM_ACCESS_ENABLE_EN			 (1L<<0)
-#define BNX2_NVM_ACCESS_ENABLE_WR_EN			 (1L<<1)
-
-#define BNX2_NVM_WRITE1					0x00006428
-#define BNX2_NVM_WRITE1_WREN_CMD			 (0xffL<<0)
-#define BNX2_NVM_WRITE1_WRDI_CMD			 (0xffL<<8)
-#define BNX2_NVM_WRITE1_SR_DATA				 (0xffL<<16)
-
-#define BNX2_NVM_CFG4					0x0000642c
-#define BNX2_NVM_CFG4_FLASH_SIZE			 (0x7L<<0)
-#define BNX2_NVM_CFG4_FLASH_SIZE_1MBIT			 (0L<<0)
-#define BNX2_NVM_CFG4_FLASH_SIZE_2MBIT			 (1L<<0)
-#define BNX2_NVM_CFG4_FLASH_SIZE_4MBIT			 (2L<<0)
-#define BNX2_NVM_CFG4_FLASH_SIZE_8MBIT			 (3L<<0)
-#define BNX2_NVM_CFG4_FLASH_SIZE_16MBIT			 (4L<<0)
-#define BNX2_NVM_CFG4_FLASH_SIZE_32MBIT			 (5L<<0)
-#define BNX2_NVM_CFG4_FLASH_SIZE_64MBIT			 (6L<<0)
-#define BNX2_NVM_CFG4_FLASH_SIZE_128MBIT		 (7L<<0)
-#define BNX2_NVM_CFG4_FLASH_VENDOR			 (1L<<3)
-#define BNX2_NVM_CFG4_FLASH_VENDOR_ST			 (0L<<3)
-#define BNX2_NVM_CFG4_FLASH_VENDOR_ATMEL		 (1L<<3)
-#define BNX2_NVM_CFG4_MODE_256_EMPTY_BIT_LOC		 (0x3L<<4)
-#define BNX2_NVM_CFG4_MODE_256_EMPTY_BIT_LOC_BIT8	 (0L<<4)
-#define BNX2_NVM_CFG4_MODE_256_EMPTY_BIT_LOC_BIT9	 (1L<<4)
-#define BNX2_NVM_CFG4_MODE_256_EMPTY_BIT_LOC_BIT10	 (2L<<4)
-#define BNX2_NVM_CFG4_MODE_256_EMPTY_BIT_LOC_BIT11	 (3L<<4)
-#define BNX2_NVM_CFG4_STATUS_BIT_POLARITY		 (1L<<6)
-#define BNX2_NVM_CFG4_RESERVED				 (0x1ffffffL<<7)
-
-#define BNX2_NVM_RECONFIG				0x00006430
-#define BNX2_NVM_RECONFIG_ORIG_STRAP_VALUE		 (0xfL<<0)
-#define BNX2_NVM_RECONFIG_ORIG_STRAP_VALUE_ST		 (0L<<0)
-#define BNX2_NVM_RECONFIG_ORIG_STRAP_VALUE_ATMEL	 (1L<<0)
-#define BNX2_NVM_RECONFIG_RECONFIG_STRAP_VALUE		 (0xfL<<4)
-#define BNX2_NVM_RECONFIG_RESERVED			 (0x7fffffL<<8)
-#define BNX2_NVM_RECONFIG_RECONFIG_DONE			 (1L<<31)
-
-
-
-/*
- *  dma_reg definition
- *  offset: 0xc00
- */
-#define BNX2_DMA_COMMAND				0x00000c00
-#define BNX2_DMA_COMMAND_ENABLE				 (1L<<0)
-
-#define BNX2_DMA_STATUS					0x00000c04
-#define BNX2_DMA_STATUS_PAR_ERROR_STATE			 (1L<<0)
-#define BNX2_DMA_STATUS_READ_TRANSFERS_STAT		 (1L<<16)
-#define BNX2_DMA_STATUS_READ_DELAY_PCI_CLKS_STAT	 (1L<<17)
-#define BNX2_DMA_STATUS_BIG_READ_TRANSFERS_STAT		 (1L<<18)
-#define BNX2_DMA_STATUS_BIG_READ_DELAY_PCI_CLKS_STAT	 (1L<<19)
-#define BNX2_DMA_STATUS_BIG_READ_RETRY_AFTER_DATA_STAT	 (1L<<20)
-#define BNX2_DMA_STATUS_WRITE_TRANSFERS_STAT		 (1L<<21)
-#define BNX2_DMA_STATUS_WRITE_DELAY_PCI_CLKS_STAT	 (1L<<22)
-#define BNX2_DMA_STATUS_BIG_WRITE_TRANSFERS_STAT	 (1L<<23)
-#define BNX2_DMA_STATUS_BIG_WRITE_DELAY_PCI_CLKS_STAT	 (1L<<24)
-#define BNX2_DMA_STATUS_BIG_WRITE_RETRY_AFTER_DATA_STAT	 (1L<<25)
-#define BNX2_DMA_STATUS_GLOBAL_ERR_XI			 (1L<<0)
-#define BNX2_DMA_STATUS_BME_XI				 (1L<<4)
-
-#define BNX2_DMA_CONFIG					0x00000c08
-#define BNX2_DMA_CONFIG_DATA_BYTE_SWAP			 (1L<<0)
-#define BNX2_DMA_CONFIG_DATA_WORD_SWAP			 (1L<<1)
-#define BNX2_DMA_CONFIG_CNTL_BYTE_SWAP			 (1L<<4)
-#define BNX2_DMA_CONFIG_CNTL_WORD_SWAP			 (1L<<5)
-#define BNX2_DMA_CONFIG_ONE_DMA				 (1L<<6)
-#define BNX2_DMA_CONFIG_CNTL_TWO_DMA			 (1L<<7)
-#define BNX2_DMA_CONFIG_CNTL_FPGA_MODE			 (1L<<8)
-#define BNX2_DMA_CONFIG_CNTL_PING_PONG_DMA		 (1L<<10)
-#define BNX2_DMA_CONFIG_CNTL_PCI_COMP_DLY		 (1L<<11)
-#define BNX2_DMA_CONFIG_NO_RCHANS_IN_USE		 (0xfL<<12)
-#define BNX2_DMA_CONFIG_NO_WCHANS_IN_USE		 (0xfL<<16)
-#define BNX2_DMA_CONFIG_PCI_CLK_CMP_BITS		 (0x7L<<20)
-#define BNX2_DMA_CONFIG_PCI_FAST_CLK_CMP		 (1L<<23)
-#define BNX2_DMA_CONFIG_BIG_SIZE			 (0xfL<<24)
-#define BNX2_DMA_CONFIG_BIG_SIZE_NONE			 (0x0L<<24)
-#define BNX2_DMA_CONFIG_BIG_SIZE_64			 (0x1L<<24)
-#define BNX2_DMA_CONFIG_BIG_SIZE_128			 (0x2L<<24)
-#define BNX2_DMA_CONFIG_BIG_SIZE_256			 (0x4L<<24)
-#define BNX2_DMA_CONFIG_BIG_SIZE_512			 (0x8L<<24)
-#define BNX2_DMA_CONFIG_DAT_WBSWAP_MODE_XI		 (0x3L<<0)
-#define BNX2_DMA_CONFIG_CTL_WBSWAP_MODE_XI		 (0x3L<<4)
-#define BNX2_DMA_CONFIG_MAX_PL_XI			 (0x7L<<12)
-#define BNX2_DMA_CONFIG_MAX_PL_128B_XI			 (0L<<12)
-#define BNX2_DMA_CONFIG_MAX_PL_256B_XI			 (1L<<12)
-#define BNX2_DMA_CONFIG_MAX_PL_512B_XI			 (2L<<12)
-#define BNX2_DMA_CONFIG_MAX_PL_EN_XI			 (1L<<15)
-#define BNX2_DMA_CONFIG_MAX_RRS_XI			 (0x7L<<16)
-#define BNX2_DMA_CONFIG_MAX_RRS_128B_XI			 (0L<<16)
-#define BNX2_DMA_CONFIG_MAX_RRS_256B_XI			 (1L<<16)
-#define BNX2_DMA_CONFIG_MAX_RRS_512B_XI			 (2L<<16)
-#define BNX2_DMA_CONFIG_MAX_RRS_1024B_XI		 (3L<<16)
-#define BNX2_DMA_CONFIG_MAX_RRS_2048B_XI		 (4L<<16)
-#define BNX2_DMA_CONFIG_MAX_RRS_4096B_XI		 (5L<<16)
-#define BNX2_DMA_CONFIG_MAX_RRS_EN_XI			 (1L<<19)
-#define BNX2_DMA_CONFIG_NO_64SWAP_EN_XI			 (1L<<31)
-
-#define BNX2_DMA_BLACKOUT				0x00000c0c
-#define BNX2_DMA_BLACKOUT_RD_RETRY_BLACKOUT		 (0xffL<<0)
-#define BNX2_DMA_BLACKOUT_2ND_RD_RETRY_BLACKOUT		 (0xffL<<8)
-#define BNX2_DMA_BLACKOUT_WR_RETRY_BLACKOUT		 (0xffL<<16)
-
-#define BNX2_DMA_READ_MASTER_SETTING_0			0x00000c10
-#define BNX2_DMA_READ_MASTER_SETTING_0_TBDC_NO_SNOOP	 (1L<<0)
-#define BNX2_DMA_READ_MASTER_SETTING_0_TBDC_RELAX_ORDER	 (1L<<1)
-#define BNX2_DMA_READ_MASTER_SETTING_0_TBDC_PRIORITY	 (1L<<2)
-#define BNX2_DMA_READ_MASTER_SETTING_0_TBDC_TRAFFIC_CLASS	 (0x7L<<4)
-#define BNX2_DMA_READ_MASTER_SETTING_0_TBDC_PARAM_EN	 (1L<<7)
-#define BNX2_DMA_READ_MASTER_SETTING_0_RBDC_NO_SNOOP	 (1L<<8)
-#define BNX2_DMA_READ_MASTER_SETTING_0_RBDC_RELAX_ORDER	 (1L<<9)
-#define BNX2_DMA_READ_MASTER_SETTING_0_RBDC_PRIORITY	 (1L<<10)
-#define BNX2_DMA_READ_MASTER_SETTING_0_RBDC_TRAFFIC_CLASS	 (0x7L<<12)
-#define BNX2_DMA_READ_MASTER_SETTING_0_RBDC_PARAM_EN	 (1L<<15)
-#define BNX2_DMA_READ_MASTER_SETTING_0_TDMA_NO_SNOOP	 (1L<<16)
-#define BNX2_DMA_READ_MASTER_SETTING_0_TDMA_RELAX_ORDER	 (1L<<17)
-#define BNX2_DMA_READ_MASTER_SETTING_0_TDMA_PRIORITY	 (1L<<18)
-#define BNX2_DMA_READ_MASTER_SETTING_0_TDMA_TRAFFIC_CLASS	 (0x7L<<20)
-#define BNX2_DMA_READ_MASTER_SETTING_0_TDMA_PARAM_EN	 (1L<<23)
-#define BNX2_DMA_READ_MASTER_SETTING_0_CTX_NO_SNOOP	 (1L<<24)
-#define BNX2_DMA_READ_MASTER_SETTING_0_CTX_RELAX_ORDER	 (1L<<25)
-#define BNX2_DMA_READ_MASTER_SETTING_0_CTX_PRIORITY	 (1L<<26)
-#define BNX2_DMA_READ_MASTER_SETTING_0_CTX_TRAFFIC_CLASS	 (0x7L<<28)
-#define BNX2_DMA_READ_MASTER_SETTING_0_CTX_PARAM_EN	 (1L<<31)
-
-#define BNX2_DMA_READ_MASTER_SETTING_1			0x00000c14
-#define BNX2_DMA_READ_MASTER_SETTING_1_COM_NO_SNOOP	 (1L<<0)
-#define BNX2_DMA_READ_MASTER_SETTING_1_COM_RELAX_ORDER	 (1L<<1)
-#define BNX2_DMA_READ_MASTER_SETTING_1_COM_PRIORITY	 (1L<<2)
-#define BNX2_DMA_READ_MASTER_SETTING_1_COM_TRAFFIC_CLASS	 (0x7L<<4)
-#define BNX2_DMA_READ_MASTER_SETTING_1_COM_PARAM_EN	 (1L<<7)
-#define BNX2_DMA_READ_MASTER_SETTING_1_CP_NO_SNOOP	 (1L<<8)
-#define BNX2_DMA_READ_MASTER_SETTING_1_CP_RELAX_ORDER	 (1L<<9)
-#define BNX2_DMA_READ_MASTER_SETTING_1_CP_PRIORITY	 (1L<<10)
-#define BNX2_DMA_READ_MASTER_SETTING_1_CP_TRAFFIC_CLASS	 (0x7L<<12)
-#define BNX2_DMA_READ_MASTER_SETTING_1_CP_PARAM_EN	 (1L<<15)
-
-#define BNX2_DMA_WRITE_MASTER_SETTING_0			0x00000c18
-#define BNX2_DMA_WRITE_MASTER_SETTING_0_HC_NO_SNOOP	 (1L<<0)
-#define BNX2_DMA_WRITE_MASTER_SETTING_0_HC_RELAX_ORDER	 (1L<<1)
-#define BNX2_DMA_WRITE_MASTER_SETTING_0_HC_PRIORITY	 (1L<<2)
-#define BNX2_DMA_WRITE_MASTER_SETTING_0_HC_CS_VLD	 (1L<<3)
-#define BNX2_DMA_WRITE_MASTER_SETTING_0_HC_TRAFFIC_CLASS	 (0x7L<<4)
-#define BNX2_DMA_WRITE_MASTER_SETTING_0_HC_PARAM_EN	 (1L<<7)
-#define BNX2_DMA_WRITE_MASTER_SETTING_0_RDMA_NO_SNOOP	 (1L<<8)
-#define BNX2_DMA_WRITE_MASTER_SETTING_0_RDMA_RELAX_ORDER	 (1L<<9)
-#define BNX2_DMA_WRITE_MASTER_SETTING_0_RDMA_PRIORITY	 (1L<<10)
-#define BNX2_DMA_WRITE_MASTER_SETTING_0_RDMA_CS_VLD	 (1L<<11)
-#define BNX2_DMA_WRITE_MASTER_SETTING_0_RDMA_TRAFFIC_CLASS	 (0x7L<<12)
-#define BNX2_DMA_WRITE_MASTER_SETTING_0_RDMA_PARAM_EN	 (1L<<15)
-#define BNX2_DMA_WRITE_MASTER_SETTING_0_CTX_NO_SNOOP	 (1L<<24)
-#define BNX2_DMA_WRITE_MASTER_SETTING_0_CTX_RELAX_ORDER	 (1L<<25)
-#define BNX2_DMA_WRITE_MASTER_SETTING_0_CTX_PRIORITY	 (1L<<26)
-#define BNX2_DMA_WRITE_MASTER_SETTING_0_CTX_CS_VLD	 (1L<<27)
-#define BNX2_DMA_WRITE_MASTER_SETTING_0_CTX_TRAFFIC_CLASS	 (0x7L<<28)
-#define BNX2_DMA_WRITE_MASTER_SETTING_0_CTX_PARAM_EN	 (1L<<31)
-
-#define BNX2_DMA_WRITE_MASTER_SETTING_1			0x00000c1c
-#define BNX2_DMA_WRITE_MASTER_SETTING_1_COM_NO_SNOOP	 (1L<<0)
-#define BNX2_DMA_WRITE_MASTER_SETTING_1_COM_RELAX_ORDER	 (1L<<1)
-#define BNX2_DMA_WRITE_MASTER_SETTING_1_COM_PRIORITY	 (1L<<2)
-#define BNX2_DMA_WRITE_MASTER_SETTING_1_COM_CS_VLD	 (1L<<3)
-#define BNX2_DMA_WRITE_MASTER_SETTING_1_COM_TRAFFIC_CLASS	 (0x7L<<4)
-#define BNX2_DMA_WRITE_MASTER_SETTING_1_COM_PARAM_EN	 (1L<<7)
-#define BNX2_DMA_WRITE_MASTER_SETTING_1_CP_NO_SNOOP	 (1L<<8)
-#define BNX2_DMA_WRITE_MASTER_SETTING_1_CP_RELAX_ORDER	 (1L<<9)
-#define BNX2_DMA_WRITE_MASTER_SETTING_1_CP_PRIORITY	 (1L<<10)
-#define BNX2_DMA_WRITE_MASTER_SETTING_1_CP_CS_VLD	 (1L<<11)
-#define BNX2_DMA_WRITE_MASTER_SETTING_1_CP_TRAFFIC_CLASS	 (0x7L<<12)
-#define BNX2_DMA_WRITE_MASTER_SETTING_1_CP_PARAM_EN	 (1L<<15)
-
-#define BNX2_DMA_ARBITER				0x00000c20
-#define BNX2_DMA_ARBITER_NUM_READS			 (0x7L<<0)
-#define BNX2_DMA_ARBITER_WR_ARB_MODE			 (1L<<4)
-#define BNX2_DMA_ARBITER_WR_ARB_MODE_STRICT		 (0L<<4)
-#define BNX2_DMA_ARBITER_WR_ARB_MODE_RND_RBN		 (1L<<4)
-#define BNX2_DMA_ARBITER_RD_ARB_MODE			 (0x3L<<5)
-#define BNX2_DMA_ARBITER_RD_ARB_MODE_STRICT		 (0L<<5)
-#define BNX2_DMA_ARBITER_RD_ARB_MODE_RND_RBN		 (1L<<5)
-#define BNX2_DMA_ARBITER_RD_ARB_MODE_WGT_RND_RBN	 (2L<<5)
-#define BNX2_DMA_ARBITER_ALT_MODE_EN			 (1L<<8)
-#define BNX2_DMA_ARBITER_RR_MODE			 (1L<<9)
-#define BNX2_DMA_ARBITER_TIMER_MODE			 (1L<<10)
-#define BNX2_DMA_ARBITER_OUSTD_READ_REQ			 (0xfL<<12)
-
-#define BNX2_DMA_ARB_TIMERS				0x00000c24
-#define BNX2_DMA_ARB_TIMERS_RD_DRR_WAIT_TIME		 (0xffL<<0)
-#define BNX2_DMA_ARB_TIMERS_TM_MIN_TIMEOUT		 (0xffL<<12)
-#define BNX2_DMA_ARB_TIMERS_TM_MAX_TIMEOUT		 (0xfffL<<20)
-
-#define BNX2_DMA_DEBUG_VECT_PEEK			0x00000c2c
-#define BNX2_DMA_DEBUG_VECT_PEEK_1_VALUE		 (0x7ffL<<0)
-#define BNX2_DMA_DEBUG_VECT_PEEK_1_PEEK_EN		 (1L<<11)
-#define BNX2_DMA_DEBUG_VECT_PEEK_1_SEL			 (0xfL<<12)
-#define BNX2_DMA_DEBUG_VECT_PEEK_2_VALUE		 (0x7ffL<<16)
-#define BNX2_DMA_DEBUG_VECT_PEEK_2_PEEK_EN		 (1L<<27)
-#define BNX2_DMA_DEBUG_VECT_PEEK_2_SEL			 (0xfL<<28)
-
-#define BNX2_DMA_TAG_RAM_00				0x00000c30
-#define BNX2_DMA_TAG_RAM_00_CHANNEL			 (0xfL<<0)
-#define BNX2_DMA_TAG_RAM_00_MASTER			 (0x7L<<4)
-#define BNX2_DMA_TAG_RAM_00_MASTER_CTX			 (0L<<4)
-#define BNX2_DMA_TAG_RAM_00_MASTER_RBDC			 (1L<<4)
-#define BNX2_DMA_TAG_RAM_00_MASTER_TBDC			 (2L<<4)
-#define BNX2_DMA_TAG_RAM_00_MASTER_COM			 (3L<<4)
-#define BNX2_DMA_TAG_RAM_00_MASTER_CP			 (4L<<4)
-#define BNX2_DMA_TAG_RAM_00_MASTER_TDMA			 (5L<<4)
-#define BNX2_DMA_TAG_RAM_00_SWAP			 (0x3L<<7)
-#define BNX2_DMA_TAG_RAM_00_SWAP_CONFIG			 (0L<<7)
-#define BNX2_DMA_TAG_RAM_00_SWAP_DATA			 (1L<<7)
-#define BNX2_DMA_TAG_RAM_00_SWAP_CONTROL		 (2L<<7)
-#define BNX2_DMA_TAG_RAM_00_FUNCTION			 (1L<<9)
-#define BNX2_DMA_TAG_RAM_00_VALID			 (1L<<10)
-
-#define BNX2_DMA_TAG_RAM_01				0x00000c34
-#define BNX2_DMA_TAG_RAM_01_CHANNEL			 (0xfL<<0)
-#define BNX2_DMA_TAG_RAM_01_MASTER			 (0x7L<<4)
-#define BNX2_DMA_TAG_RAM_01_MASTER_CTX			 (0L<<4)
-#define BNX2_DMA_TAG_RAM_01_MASTER_RBDC			 (1L<<4)
-#define BNX2_DMA_TAG_RAM_01_MASTER_TBDC			 (2L<<4)
-#define BNX2_DMA_TAG_RAM_01_MASTER_COM			 (3L<<4)
-#define BNX2_DMA_TAG_RAM_01_MASTER_CP			 (4L<<4)
-#define BNX2_DMA_TAG_RAM_01_MASTER_TDMA			 (5L<<4)
-#define BNX2_DMA_TAG_RAM_01_SWAP			 (0x3L<<7)
-#define BNX2_DMA_TAG_RAM_01_SWAP_CONFIG			 (0L<<7)
-#define BNX2_DMA_TAG_RAM_01_SWAP_DATA			 (1L<<7)
-#define BNX2_DMA_TAG_RAM_01_SWAP_CONTROL		 (2L<<7)
-#define BNX2_DMA_TAG_RAM_01_FUNCTION			 (1L<<9)
-#define BNX2_DMA_TAG_RAM_01_VALID			 (1L<<10)
-
-#define BNX2_DMA_TAG_RAM_02				0x00000c38
-#define BNX2_DMA_TAG_RAM_02_CHANNEL			 (0xfL<<0)
-#define BNX2_DMA_TAG_RAM_02_MASTER			 (0x7L<<4)
-#define BNX2_DMA_TAG_RAM_02_MASTER_CTX			 (0L<<4)
-#define BNX2_DMA_TAG_RAM_02_MASTER_RBDC			 (1L<<4)
-#define BNX2_DMA_TAG_RAM_02_MASTER_TBDC			 (2L<<4)
-#define BNX2_DMA_TAG_RAM_02_MASTER_COM			 (3L<<4)
-#define BNX2_DMA_TAG_RAM_02_MASTER_CP			 (4L<<4)
-#define BNX2_DMA_TAG_RAM_02_MASTER_TDMA			 (5L<<4)
-#define BNX2_DMA_TAG_RAM_02_SWAP			 (0x3L<<7)
-#define BNX2_DMA_TAG_RAM_02_SWAP_CONFIG			 (0L<<7)
-#define BNX2_DMA_TAG_RAM_02_SWAP_DATA			 (1L<<7)
-#define BNX2_DMA_TAG_RAM_02_SWAP_CONTROL		 (2L<<7)
-#define BNX2_DMA_TAG_RAM_02_FUNCTION			 (1L<<9)
-#define BNX2_DMA_TAG_RAM_02_VALID			 (1L<<10)
-
-#define BNX2_DMA_TAG_RAM_03				0x00000c3c
-#define BNX2_DMA_TAG_RAM_03_CHANNEL			 (0xfL<<0)
-#define BNX2_DMA_TAG_RAM_03_MASTER			 (0x7L<<4)
-#define BNX2_DMA_TAG_RAM_03_MASTER_CTX			 (0L<<4)
-#define BNX2_DMA_TAG_RAM_03_MASTER_RBDC			 (1L<<4)
-#define BNX2_DMA_TAG_RAM_03_MASTER_TBDC			 (2L<<4)
-#define BNX2_DMA_TAG_RAM_03_MASTER_COM			 (3L<<4)
-#define BNX2_DMA_TAG_RAM_03_MASTER_CP			 (4L<<4)
-#define BNX2_DMA_TAG_RAM_03_MASTER_TDMA			 (5L<<4)
-#define BNX2_DMA_TAG_RAM_03_SWAP			 (0x3L<<7)
-#define BNX2_DMA_TAG_RAM_03_SWAP_CONFIG			 (0L<<7)
-#define BNX2_DMA_TAG_RAM_03_SWAP_DATA			 (1L<<7)
-#define BNX2_DMA_TAG_RAM_03_SWAP_CONTROL		 (2L<<7)
-#define BNX2_DMA_TAG_RAM_03_FUNCTION			 (1L<<9)
-#define BNX2_DMA_TAG_RAM_03_VALID			 (1L<<10)
-
-#define BNX2_DMA_TAG_RAM_04				0x00000c40
-#define BNX2_DMA_TAG_RAM_04_CHANNEL			 (0xfL<<0)
-#define BNX2_DMA_TAG_RAM_04_MASTER			 (0x7L<<4)
-#define BNX2_DMA_TAG_RAM_04_MASTER_CTX			 (0L<<4)
-#define BNX2_DMA_TAG_RAM_04_MASTER_RBDC			 (1L<<4)
-#define BNX2_DMA_TAG_RAM_04_MASTER_TBDC			 (2L<<4)
-#define BNX2_DMA_TAG_RAM_04_MASTER_COM			 (3L<<4)
-#define BNX2_DMA_TAG_RAM_04_MASTER_CP			 (4L<<4)
-#define BNX2_DMA_TAG_RAM_04_MASTER_TDMA			 (5L<<4)
-#define BNX2_DMA_TAG_RAM_04_SWAP			 (0x3L<<7)
-#define BNX2_DMA_TAG_RAM_04_SWAP_CONFIG			 (0L<<7)
-#define BNX2_DMA_TAG_RAM_04_SWAP_DATA			 (1L<<7)
-#define BNX2_DMA_TAG_RAM_04_SWAP_CONTROL		 (2L<<7)
-#define BNX2_DMA_TAG_RAM_04_FUNCTION			 (1L<<9)
-#define BNX2_DMA_TAG_RAM_04_VALID			 (1L<<10)
-
-#define BNX2_DMA_TAG_RAM_05				0x00000c44
-#define BNX2_DMA_TAG_RAM_05_CHANNEL			 (0xfL<<0)
-#define BNX2_DMA_TAG_RAM_05_MASTER			 (0x7L<<4)
-#define BNX2_DMA_TAG_RAM_05_MASTER_CTX			 (0L<<4)
-#define BNX2_DMA_TAG_RAM_05_MASTER_RBDC			 (1L<<4)
-#define BNX2_DMA_TAG_RAM_05_MASTER_TBDC			 (2L<<4)
-#define BNX2_DMA_TAG_RAM_05_MASTER_COM			 (3L<<4)
-#define BNX2_DMA_TAG_RAM_05_MASTER_CP			 (4L<<4)
-#define BNX2_DMA_TAG_RAM_05_MASTER_TDMA			 (5L<<4)
-#define BNX2_DMA_TAG_RAM_05_SWAP			 (0x3L<<7)
-#define BNX2_DMA_TAG_RAM_05_SWAP_CONFIG			 (0L<<7)
-#define BNX2_DMA_TAG_RAM_05_SWAP_DATA			 (1L<<7)
-#define BNX2_DMA_TAG_RAM_05_SWAP_CONTROL		 (2L<<7)
-#define BNX2_DMA_TAG_RAM_05_FUNCTION			 (1L<<9)
-#define BNX2_DMA_TAG_RAM_05_VALID			 (1L<<10)
-
-#define BNX2_DMA_TAG_RAM_06				0x00000c48
-#define BNX2_DMA_TAG_RAM_06_CHANNEL			 (0xfL<<0)
-#define BNX2_DMA_TAG_RAM_06_MASTER			 (0x7L<<4)
-#define BNX2_DMA_TAG_RAM_06_MASTER_CTX			 (0L<<4)
-#define BNX2_DMA_TAG_RAM_06_MASTER_RBDC			 (1L<<4)
-#define BNX2_DMA_TAG_RAM_06_MASTER_TBDC			 (2L<<4)
-#define BNX2_DMA_TAG_RAM_06_MASTER_COM			 (3L<<4)
-#define BNX2_DMA_TAG_RAM_06_MASTER_CP			 (4L<<4)
-#define BNX2_DMA_TAG_RAM_06_MASTER_TDMA			 (5L<<4)
-#define BNX2_DMA_TAG_RAM_06_SWAP			 (0x3L<<7)
-#define BNX2_DMA_TAG_RAM_06_SWAP_CONFIG			 (0L<<7)
-#define BNX2_DMA_TAG_RAM_06_SWAP_DATA			 (1L<<7)
-#define BNX2_DMA_TAG_RAM_06_SWAP_CONTROL		 (2L<<7)
-#define BNX2_DMA_TAG_RAM_06_FUNCTION			 (1L<<9)
-#define BNX2_DMA_TAG_RAM_06_VALID			 (1L<<10)
-
-#define BNX2_DMA_TAG_RAM_07				0x00000c4c
-#define BNX2_DMA_TAG_RAM_07_CHANNEL			 (0xfL<<0)
-#define BNX2_DMA_TAG_RAM_07_MASTER			 (0x7L<<4)
-#define BNX2_DMA_TAG_RAM_07_MASTER_CTX			 (0L<<4)
-#define BNX2_DMA_TAG_RAM_07_MASTER_RBDC			 (1L<<4)
-#define BNX2_DMA_TAG_RAM_07_MASTER_TBDC			 (2L<<4)
-#define BNX2_DMA_TAG_RAM_07_MASTER_COM			 (3L<<4)
-#define BNX2_DMA_TAG_RAM_07_MASTER_CP			 (4L<<4)
-#define BNX2_DMA_TAG_RAM_07_MASTER_TDMA			 (5L<<4)
-#define BNX2_DMA_TAG_RAM_07_SWAP			 (0x3L<<7)
-#define BNX2_DMA_TAG_RAM_07_SWAP_CONFIG			 (0L<<7)
-#define BNX2_DMA_TAG_RAM_07_SWAP_DATA			 (1L<<7)
-#define BNX2_DMA_TAG_RAM_07_SWAP_CONTROL		 (2L<<7)
-#define BNX2_DMA_TAG_RAM_07_FUNCTION			 (1L<<9)
-#define BNX2_DMA_TAG_RAM_07_VALID			 (1L<<10)
-
-#define BNX2_DMA_TAG_RAM_08				0x00000c50
-#define BNX2_DMA_TAG_RAM_08_CHANNEL			 (0xfL<<0)
-#define BNX2_DMA_TAG_RAM_08_MASTER			 (0x7L<<4)
-#define BNX2_DMA_TAG_RAM_08_MASTER_CTX			 (0L<<4)
-#define BNX2_DMA_TAG_RAM_08_MASTER_RBDC			 (1L<<4)
-#define BNX2_DMA_TAG_RAM_08_MASTER_TBDC			 (2L<<4)
-#define BNX2_DMA_TAG_RAM_08_MASTER_COM			 (3L<<4)
-#define BNX2_DMA_TAG_RAM_08_MASTER_CP			 (4L<<4)
-#define BNX2_DMA_TAG_RAM_08_MASTER_TDMA			 (5L<<4)
-#define BNX2_DMA_TAG_RAM_08_SWAP			 (0x3L<<7)
-#define BNX2_DMA_TAG_RAM_08_SWAP_CONFIG			 (0L<<7)
-#define BNX2_DMA_TAG_RAM_08_SWAP_DATA			 (1L<<7)
-#define BNX2_DMA_TAG_RAM_08_SWAP_CONTROL		 (2L<<7)
-#define BNX2_DMA_TAG_RAM_08_FUNCTION			 (1L<<9)
-#define BNX2_DMA_TAG_RAM_08_VALID			 (1L<<10)
-
-#define BNX2_DMA_TAG_RAM_09				0x00000c54
-#define BNX2_DMA_TAG_RAM_09_CHANNEL			 (0xfL<<0)
-#define BNX2_DMA_TAG_RAM_09_MASTER			 (0x7L<<4)
-#define BNX2_DMA_TAG_RAM_09_MASTER_CTX			 (0L<<4)
-#define BNX2_DMA_TAG_RAM_09_MASTER_RBDC			 (1L<<4)
-#define BNX2_DMA_TAG_RAM_09_MASTER_TBDC			 (2L<<4)
-#define BNX2_DMA_TAG_RAM_09_MASTER_COM			 (3L<<4)
-#define BNX2_DMA_TAG_RAM_09_MASTER_CP			 (4L<<4)
-#define BNX2_DMA_TAG_RAM_09_MASTER_TDMA			 (5L<<4)
-#define BNX2_DMA_TAG_RAM_09_SWAP			 (0x3L<<7)
-#define BNX2_DMA_TAG_RAM_09_SWAP_CONFIG			 (0L<<7)
-#define BNX2_DMA_TAG_RAM_09_SWAP_DATA			 (1L<<7)
-#define BNX2_DMA_TAG_RAM_09_SWAP_CONTROL		 (2L<<7)
-#define BNX2_DMA_TAG_RAM_09_FUNCTION			 (1L<<9)
-#define BNX2_DMA_TAG_RAM_09_VALID			 (1L<<10)
-
-#define BNX2_DMA_TAG_RAM_10				0x00000c58
-#define BNX2_DMA_TAG_RAM_10_CHANNEL			 (0xfL<<0)
-#define BNX2_DMA_TAG_RAM_10_MASTER			 (0x7L<<4)
-#define BNX2_DMA_TAG_RAM_10_MASTER_CTX			 (0L<<4)
-#define BNX2_DMA_TAG_RAM_10_MASTER_RBDC			 (1L<<4)
-#define BNX2_DMA_TAG_RAM_10_MASTER_TBDC			 (2L<<4)
-#define BNX2_DMA_TAG_RAM_10_MASTER_COM			 (3L<<4)
-#define BNX2_DMA_TAG_RAM_10_MASTER_CP			 (4L<<4)
-#define BNX2_DMA_TAG_RAM_10_MASTER_TDMA			 (5L<<4)
-#define BNX2_DMA_TAG_RAM_10_SWAP			 (0x3L<<7)
-#define BNX2_DMA_TAG_RAM_10_SWAP_CONFIG			 (0L<<7)
-#define BNX2_DMA_TAG_RAM_10_SWAP_DATA			 (1L<<7)
-#define BNX2_DMA_TAG_RAM_10_SWAP_CONTROL		 (2L<<7)
-#define BNX2_DMA_TAG_RAM_10_FUNCTION			 (1L<<9)
-#define BNX2_DMA_TAG_RAM_10_VALID			 (1L<<10)
-
-#define BNX2_DMA_TAG_RAM_11				0x00000c5c
-#define BNX2_DMA_TAG_RAM_11_CHANNEL			 (0xfL<<0)
-#define BNX2_DMA_TAG_RAM_11_MASTER			 (0x7L<<4)
-#define BNX2_DMA_TAG_RAM_11_MASTER_CTX			 (0L<<4)
-#define BNX2_DMA_TAG_RAM_11_MASTER_RBDC			 (1L<<4)
-#define BNX2_DMA_TAG_RAM_11_MASTER_TBDC			 (2L<<4)
-#define BNX2_DMA_TAG_RAM_11_MASTER_COM			 (3L<<4)
-#define BNX2_DMA_TAG_RAM_11_MASTER_CP			 (4L<<4)
-#define BNX2_DMA_TAG_RAM_11_MASTER_TDMA			 (5L<<4)
-#define BNX2_DMA_TAG_RAM_11_SWAP			 (0x3L<<7)
-#define BNX2_DMA_TAG_RAM_11_SWAP_CONFIG			 (0L<<7)
-#define BNX2_DMA_TAG_RAM_11_SWAP_DATA			 (1L<<7)
-#define BNX2_DMA_TAG_RAM_11_SWAP_CONTROL		 (2L<<7)
-#define BNX2_DMA_TAG_RAM_11_FUNCTION			 (1L<<9)
-#define BNX2_DMA_TAG_RAM_11_VALID			 (1L<<10)
-
-#define BNX2_DMA_RCHAN_STAT_22				0x00000c60
-#define BNX2_DMA_RCHAN_STAT_30				0x00000c64
-#define BNX2_DMA_RCHAN_STAT_31				0x00000c68
-#define BNX2_DMA_RCHAN_STAT_32				0x00000c6c
-#define BNX2_DMA_RCHAN_STAT_40				0x00000c70
-#define BNX2_DMA_RCHAN_STAT_41				0x00000c74
-#define BNX2_DMA_RCHAN_STAT_42				0x00000c78
-#define BNX2_DMA_RCHAN_STAT_50				0x00000c7c
-#define BNX2_DMA_RCHAN_STAT_51				0x00000c80
-#define BNX2_DMA_RCHAN_STAT_52				0x00000c84
-#define BNX2_DMA_RCHAN_STAT_60				0x00000c88
-#define BNX2_DMA_RCHAN_STAT_61				0x00000c8c
-#define BNX2_DMA_RCHAN_STAT_62				0x00000c90
-#define BNX2_DMA_RCHAN_STAT_70				0x00000c94
-#define BNX2_DMA_RCHAN_STAT_71				0x00000c98
-#define BNX2_DMA_RCHAN_STAT_72				0x00000c9c
-#define BNX2_DMA_WCHAN_STAT_00				0x00000ca0
-#define BNX2_DMA_WCHAN_STAT_00_WCHAN_STA_HOST_ADDR_LOW	 (0xffffffffL<<0)
-
-#define BNX2_DMA_WCHAN_STAT_01				0x00000ca4
-#define BNX2_DMA_WCHAN_STAT_01_WCHAN_STA_HOST_ADDR_HIGH	 (0xffffffffL<<0)
-
-#define BNX2_DMA_WCHAN_STAT_02				0x00000ca8
-#define BNX2_DMA_WCHAN_STAT_02_LENGTH			 (0xffffL<<0)
-#define BNX2_DMA_WCHAN_STAT_02_WORD_SWAP		 (1L<<16)
-#define BNX2_DMA_WCHAN_STAT_02_BYTE_SWAP		 (1L<<17)
-#define BNX2_DMA_WCHAN_STAT_02_PRIORITY_LVL		 (1L<<18)
-
-#define BNX2_DMA_WCHAN_STAT_10				0x00000cac
-#define BNX2_DMA_WCHAN_STAT_11				0x00000cb0
-#define BNX2_DMA_WCHAN_STAT_12				0x00000cb4
-#define BNX2_DMA_WCHAN_STAT_20				0x00000cb8
-#define BNX2_DMA_WCHAN_STAT_21				0x00000cbc
-#define BNX2_DMA_WCHAN_STAT_22				0x00000cc0
-#define BNX2_DMA_WCHAN_STAT_30				0x00000cc4
-#define BNX2_DMA_WCHAN_STAT_31				0x00000cc8
-#define BNX2_DMA_WCHAN_STAT_32				0x00000ccc
-#define BNX2_DMA_WCHAN_STAT_40				0x00000cd0
-#define BNX2_DMA_WCHAN_STAT_41				0x00000cd4
-#define BNX2_DMA_WCHAN_STAT_42				0x00000cd8
-#define BNX2_DMA_WCHAN_STAT_50				0x00000cdc
-#define BNX2_DMA_WCHAN_STAT_51				0x00000ce0
-#define BNX2_DMA_WCHAN_STAT_52				0x00000ce4
-#define BNX2_DMA_WCHAN_STAT_60				0x00000ce8
-#define BNX2_DMA_WCHAN_STAT_61				0x00000cec
-#define BNX2_DMA_WCHAN_STAT_62				0x00000cf0
-#define BNX2_DMA_WCHAN_STAT_70				0x00000cf4
-#define BNX2_DMA_WCHAN_STAT_71				0x00000cf8
-#define BNX2_DMA_WCHAN_STAT_72				0x00000cfc
-#define BNX2_DMA_ARB_STAT_00				0x00000d00
-#define BNX2_DMA_ARB_STAT_00_MASTER			 (0xffffL<<0)
-#define BNX2_DMA_ARB_STAT_00_MASTER_ENC			 (0xffL<<16)
-#define BNX2_DMA_ARB_STAT_00_CUR_BINMSTR		 (0xffL<<24)
-
-#define BNX2_DMA_ARB_STAT_01				0x00000d04
-#define BNX2_DMA_ARB_STAT_01_LPR_RPTR			 (0xfL<<0)
-#define BNX2_DMA_ARB_STAT_01_LPR_WPTR			 (0xfL<<4)
-#define BNX2_DMA_ARB_STAT_01_LPB_RPTR			 (0xfL<<8)
-#define BNX2_DMA_ARB_STAT_01_LPB_WPTR			 (0xfL<<12)
-#define BNX2_DMA_ARB_STAT_01_HPR_RPTR			 (0xfL<<16)
-#define BNX2_DMA_ARB_STAT_01_HPR_WPTR			 (0xfL<<20)
-#define BNX2_DMA_ARB_STAT_01_HPB_RPTR			 (0xfL<<24)
-#define BNX2_DMA_ARB_STAT_01_HPB_WPTR			 (0xfL<<28)
-
-#define BNX2_DMA_FUSE_CTRL0_CMD				0x00000f00
-#define BNX2_DMA_FUSE_CTRL0_CMD_PWRUP_DONE		 (1L<<0)
-#define BNX2_DMA_FUSE_CTRL0_CMD_SHIFT_DONE		 (1L<<1)
-#define BNX2_DMA_FUSE_CTRL0_CMD_SHIFT			 (1L<<2)
-#define BNX2_DMA_FUSE_CTRL0_CMD_LOAD			 (1L<<3)
-#define BNX2_DMA_FUSE_CTRL0_CMD_SEL			 (0xfL<<8)
-
-#define BNX2_DMA_FUSE_CTRL0_DATA			0x00000f04
-#define BNX2_DMA_FUSE_CTRL1_CMD				0x00000f08
-#define BNX2_DMA_FUSE_CTRL1_CMD_PWRUP_DONE		 (1L<<0)
-#define BNX2_DMA_FUSE_CTRL1_CMD_SHIFT_DONE		 (1L<<1)
-#define BNX2_DMA_FUSE_CTRL1_CMD_SHIFT			 (1L<<2)
-#define BNX2_DMA_FUSE_CTRL1_CMD_LOAD			 (1L<<3)
-#define BNX2_DMA_FUSE_CTRL1_CMD_SEL			 (0xfL<<8)
-
-#define BNX2_DMA_FUSE_CTRL1_DATA			0x00000f0c
-#define BNX2_DMA_FUSE_CTRL2_CMD				0x00000f10
-#define BNX2_DMA_FUSE_CTRL2_CMD_PWRUP_DONE		 (1L<<0)
-#define BNX2_DMA_FUSE_CTRL2_CMD_SHIFT_DONE		 (1L<<1)
-#define BNX2_DMA_FUSE_CTRL2_CMD_SHIFT			 (1L<<2)
-#define BNX2_DMA_FUSE_CTRL2_CMD_LOAD			 (1L<<3)
-#define BNX2_DMA_FUSE_CTRL2_CMD_SEL			 (0xfL<<8)
-
-#define BNX2_DMA_FUSE_CTRL2_DATA			0x00000f14
-
-
-/*
- *  context_reg definition
- *  offset: 0x1000
- */
-#define BNX2_CTX_COMMAND				0x00001000
-#define BNX2_CTX_COMMAND_ENABLED			 (1L<<0)
-#define BNX2_CTX_COMMAND_DISABLE_USAGE_CNT		 (1L<<1)
-#define BNX2_CTX_COMMAND_DISABLE_PLRU			 (1L<<2)
-#define BNX2_CTX_COMMAND_DISABLE_COMBINE_READ		 (1L<<3)
-#define BNX2_CTX_COMMAND_FLUSH_AHEAD			 (0x1fL<<8)
-#define BNX2_CTX_COMMAND_MEM_INIT			 (1L<<13)
-#define BNX2_CTX_COMMAND_PAGE_SIZE			 (0xfL<<16)
-#define BNX2_CTX_COMMAND_PAGE_SIZE_256			 (0L<<16)
-#define BNX2_CTX_COMMAND_PAGE_SIZE_512			 (1L<<16)
-#define BNX2_CTX_COMMAND_PAGE_SIZE_1K			 (2L<<16)
-#define BNX2_CTX_COMMAND_PAGE_SIZE_2K			 (3L<<16)
-#define BNX2_CTX_COMMAND_PAGE_SIZE_4K			 (4L<<16)
-#define BNX2_CTX_COMMAND_PAGE_SIZE_8K			 (5L<<16)
-#define BNX2_CTX_COMMAND_PAGE_SIZE_16K			 (6L<<16)
-#define BNX2_CTX_COMMAND_PAGE_SIZE_32K			 (7L<<16)
-#define BNX2_CTX_COMMAND_PAGE_SIZE_64K			 (8L<<16)
-#define BNX2_CTX_COMMAND_PAGE_SIZE_128K			 (9L<<16)
-#define BNX2_CTX_COMMAND_PAGE_SIZE_256K			 (10L<<16)
-#define BNX2_CTX_COMMAND_PAGE_SIZE_512K			 (11L<<16)
-#define BNX2_CTX_COMMAND_PAGE_SIZE_1M			 (12L<<16)
-
-#define BNX2_CTX_STATUS					0x00001004
-#define BNX2_CTX_STATUS_LOCK_WAIT			 (1L<<0)
-#define BNX2_CTX_STATUS_READ_STAT			 (1L<<16)
-#define BNX2_CTX_STATUS_WRITE_STAT			 (1L<<17)
-#define BNX2_CTX_STATUS_ACC_STALL_STAT			 (1L<<18)
-#define BNX2_CTX_STATUS_LOCK_STALL_STAT			 (1L<<19)
-#define BNX2_CTX_STATUS_EXT_READ_STAT			 (1L<<20)
-#define BNX2_CTX_STATUS_EXT_WRITE_STAT			 (1L<<21)
-#define BNX2_CTX_STATUS_MISS_STAT			 (1L<<22)
-#define BNX2_CTX_STATUS_HIT_STAT			 (1L<<23)
-#define BNX2_CTX_STATUS_DEAD_LOCK			 (1L<<24)
-#define BNX2_CTX_STATUS_USAGE_CNT_ERR			 (1L<<25)
-#define BNX2_CTX_STATUS_INVALID_PAGE			 (1L<<26)
-
-#define BNX2_CTX_VIRT_ADDR				0x00001008
-#define BNX2_CTX_VIRT_ADDR_VIRT_ADDR			 (0x7fffL<<6)
-
-#define BNX2_CTX_PAGE_TBL				0x0000100c
-#define BNX2_CTX_PAGE_TBL_PAGE_TBL			 (0x3fffL<<6)
-
-#define BNX2_CTX_DATA_ADR				0x00001010
-#define BNX2_CTX_DATA_ADR_DATA_ADR			 (0x7ffffL<<2)
-
-#define BNX2_CTX_DATA					0x00001014
-#define BNX2_CTX_LOCK					0x00001018
-#define BNX2_CTX_LOCK_TYPE				 (0x7L<<0)
-#define BNX2_CTX_LOCK_TYPE_LOCK_TYPE_VOID		 (0x0L<<0)
-#define BNX2_CTX_LOCK_TYPE_LOCK_TYPE_PROTOCOL		 (0x1L<<0)
-#define BNX2_CTX_LOCK_TYPE_LOCK_TYPE_TX			 (0x2L<<0)
-#define BNX2_CTX_LOCK_TYPE_LOCK_TYPE_TIMER		 (0x4L<<0)
-#define BNX2_CTX_LOCK_TYPE_LOCK_TYPE_COMPLETE		 (0x7L<<0)
-#define BNX2_CTX_LOCK_TYPE_VOID_XI			 (0L<<0)
-#define BNX2_CTX_LOCK_TYPE_PROTOCOL_XI			 (1L<<0)
-#define BNX2_CTX_LOCK_TYPE_TX_XI			 (2L<<0)
-#define BNX2_CTX_LOCK_TYPE_TIMER_XI			 (4L<<0)
-#define BNX2_CTX_LOCK_TYPE_COMPLETE_XI			 (7L<<0)
-#define BNX2_CTX_LOCK_CID_VALUE				 (0x3fffL<<7)
-#define BNX2_CTX_LOCK_GRANTED				 (1L<<26)
-#define BNX2_CTX_LOCK_MODE				 (0x7L<<27)
-#define BNX2_CTX_LOCK_MODE_UNLOCK			 (0x0L<<27)
-#define BNX2_CTX_LOCK_MODE_IMMEDIATE			 (0x1L<<27)
-#define BNX2_CTX_LOCK_MODE_SURE				 (0x2L<<27)
-#define BNX2_CTX_LOCK_STATUS				 (1L<<30)
-#define BNX2_CTX_LOCK_REQ				 (1L<<31)
-
-#define BNX2_CTX_CTX_CTRL				0x0000101c
-#define BNX2_CTX_CTX_CTRL_CTX_ADDR			 (0x7ffffL<<2)
-#define BNX2_CTX_CTX_CTRL_MOD_USAGE_CNT			 (0x3L<<21)
-#define BNX2_CTX_CTX_CTRL_NO_RAM_ACC			 (1L<<23)
-#define BNX2_CTX_CTX_CTRL_PREFETCH_SIZE			 (0x3L<<24)
-#define BNX2_CTX_CTX_CTRL_ATTR				 (1L<<26)
-#define BNX2_CTX_CTX_CTRL_WRITE_REQ			 (1L<<30)
-#define BNX2_CTX_CTX_CTRL_READ_REQ			 (1L<<31)
-
-#define BNX2_CTX_CTX_DATA				0x00001020
-#define BNX2_CTX_ACCESS_STATUS				0x00001040
-#define BNX2_CTX_ACCESS_STATUS_MASTERENCODED		 (0xfL<<0)
-#define BNX2_CTX_ACCESS_STATUS_ACCESSMEMORYSM		 (0x3L<<10)
-#define BNX2_CTX_ACCESS_STATUS_PAGETABLEINITSM		 (0x3L<<12)
-#define BNX2_CTX_ACCESS_STATUS_ACCESSMEMORYINITSM	 (0x3L<<14)
-#define BNX2_CTX_ACCESS_STATUS_QUALIFIED_REQUEST	 (0x7ffL<<17)
-#define BNX2_CTX_ACCESS_STATUS_CAMMASTERENCODED_XI	 (0x1fL<<0)
-#define BNX2_CTX_ACCESS_STATUS_CACHEMASTERENCODED_XI	 (0x1fL<<5)
-#define BNX2_CTX_ACCESS_STATUS_REQUEST_XI		 (0x3fffffL<<10)
-
-#define BNX2_CTX_DBG_LOCK_STATUS			0x00001044
-#define BNX2_CTX_DBG_LOCK_STATUS_SM			 (0x3ffL<<0)
-#define BNX2_CTX_DBG_LOCK_STATUS_MATCH			 (0x3ffL<<22)
-
-#define BNX2_CTX_CACHE_CTRL_STATUS			0x00001048
-#define BNX2_CTX_CACHE_CTRL_STATUS_RFIFO_OVERFLOW	 (1L<<0)
-#define BNX2_CTX_CACHE_CTRL_STATUS_INVALID_READ_COMP	 (1L<<1)
-#define BNX2_CTX_CACHE_CTRL_STATUS_FLUSH_START		 (1L<<6)
-#define BNX2_CTX_CACHE_CTRL_STATUS_FREE_ENTRY_CNT	 (0x3fL<<7)
-#define BNX2_CTX_CACHE_CTRL_STATUS_CACHE_ENTRY_NEEDED	 (0x3fL<<13)
-#define BNX2_CTX_CACHE_CTRL_STATUS_RD_CHAN0_ACTIVE	 (1L<<19)
-#define BNX2_CTX_CACHE_CTRL_STATUS_RD_CHAN1_ACTIVE	 (1L<<20)
-#define BNX2_CTX_CACHE_CTRL_STATUS_RD_CHAN2_ACTIVE	 (1L<<21)
-#define BNX2_CTX_CACHE_CTRL_STATUS_RD_CHAN3_ACTIVE	 (1L<<22)
-#define BNX2_CTX_CACHE_CTRL_STATUS_RD_CHAN4_ACTIVE	 (1L<<23)
-#define BNX2_CTX_CACHE_CTRL_STATUS_RD_CHAN5_ACTIVE	 (1L<<24)
-#define BNX2_CTX_CACHE_CTRL_STATUS_RD_CHAN6_ACTIVE	 (1L<<25)
-#define BNX2_CTX_CACHE_CTRL_STATUS_RD_CHAN7_ACTIVE	 (1L<<26)
-#define BNX2_CTX_CACHE_CTRL_STATUS_RD_CHAN8_ACTIVE	 (1L<<27)
-#define BNX2_CTX_CACHE_CTRL_STATUS_RD_CHAN9_ACTIVE	 (1L<<28)
-#define BNX2_CTX_CACHE_CTRL_STATUS_RD_CHAN10_ACTIVE	 (1L<<29)
-
-#define BNX2_CTX_CACHE_CTRL_SM_STATUS			0x0000104c
-#define BNX2_CTX_CACHE_CTRL_SM_STATUS_CS_DWC		 (0x7L<<0)
-#define BNX2_CTX_CACHE_CTRL_SM_STATUS_CS_WFIFOC		 (0x7L<<3)
-#define BNX2_CTX_CACHE_CTRL_SM_STATUS_CS_RTAGC		 (0x7L<<6)
-#define BNX2_CTX_CACHE_CTRL_SM_STATUS_CS_RFIFOC		 (0x7L<<9)
-#define BNX2_CTX_CACHE_CTRL_SM_STATUS_INVALID_BLK_ADDR	 (0x7fffL<<16)
-
-#define BNX2_CTX_CACHE_STATUS				0x00001050
-#define BNX2_CTX_CACHE_STATUS_HELD_ENTRIES		 (0x3ffL<<0)
-#define BNX2_CTX_CACHE_STATUS_MAX_HELD_ENTRIES		 (0x3ffL<<16)
-
-#define BNX2_CTX_DMA_STATUS				0x00001054
-#define BNX2_CTX_DMA_STATUS_RD_CHAN0_STATUS		 (0x3L<<0)
-#define BNX2_CTX_DMA_STATUS_RD_CHAN1_STATUS		 (0x3L<<2)
-#define BNX2_CTX_DMA_STATUS_RD_CHAN2_STATUS		 (0x3L<<4)
-#define BNX2_CTX_DMA_STATUS_RD_CHAN3_STATUS		 (0x3L<<6)
-#define BNX2_CTX_DMA_STATUS_RD_CHAN4_STATUS		 (0x3L<<8)
-#define BNX2_CTX_DMA_STATUS_RD_CHAN5_STATUS		 (0x3L<<10)
-#define BNX2_CTX_DMA_STATUS_RD_CHAN6_STATUS		 (0x3L<<12)
-#define BNX2_CTX_DMA_STATUS_RD_CHAN7_STATUS		 (0x3L<<14)
-#define BNX2_CTX_DMA_STATUS_RD_CHAN8_STATUS		 (0x3L<<16)
-#define BNX2_CTX_DMA_STATUS_RD_CHAN9_STATUS		 (0x3L<<18)
-#define BNX2_CTX_DMA_STATUS_RD_CHAN10_STATUS		 (0x3L<<20)
-
-#define BNX2_CTX_REP_STATUS				0x00001058
-#define BNX2_CTX_REP_STATUS_ERROR_ENTRY			 (0x3ffL<<0)
-#define BNX2_CTX_REP_STATUS_ERROR_CLIENT_ID		 (0x1fL<<10)
-#define BNX2_CTX_REP_STATUS_USAGE_CNT_MAX_ERR		 (1L<<16)
-#define BNX2_CTX_REP_STATUS_USAGE_CNT_MIN_ERR		 (1L<<17)
-#define BNX2_CTX_REP_STATUS_USAGE_CNT_MISS_ERR		 (1L<<18)
-
-#define BNX2_CTX_CKSUM_ERROR_STATUS			0x0000105c
-#define BNX2_CTX_CKSUM_ERROR_STATUS_CALCULATED		 (0xffffL<<0)
-#define BNX2_CTX_CKSUM_ERROR_STATUS_EXPECTED		 (0xffffL<<16)
-
-#define BNX2_CTX_CHNL_LOCK_STATUS_0			0x00001080
-#define BNX2_CTX_CHNL_LOCK_STATUS_0_CID			 (0x3fffL<<0)
-#define BNX2_CTX_CHNL_LOCK_STATUS_0_TYPE		 (0x3L<<14)
-#define BNX2_CTX_CHNL_LOCK_STATUS_0_MODE		 (1L<<16)
-#define BNX2_CTX_CHNL_LOCK_STATUS_0_MODE_XI		 (1L<<14)
-#define BNX2_CTX_CHNL_LOCK_STATUS_0_TYPE_XI		 (0x7L<<15)
-
-#define BNX2_CTX_CHNL_LOCK_STATUS_1			0x00001084
-#define BNX2_CTX_CHNL_LOCK_STATUS_2			0x00001088
-#define BNX2_CTX_CHNL_LOCK_STATUS_3			0x0000108c
-#define BNX2_CTX_CHNL_LOCK_STATUS_4			0x00001090
-#define BNX2_CTX_CHNL_LOCK_STATUS_5			0x00001094
-#define BNX2_CTX_CHNL_LOCK_STATUS_6			0x00001098
-#define BNX2_CTX_CHNL_LOCK_STATUS_7			0x0000109c
-#define BNX2_CTX_CHNL_LOCK_STATUS_8			0x000010a0
-#define BNX2_CTX_CHNL_LOCK_STATUS_9			0x000010a4
-
-#define BNX2_CTX_CACHE_DATA				0x000010c4
-#define BNX2_CTX_HOST_PAGE_TBL_CTRL			0x000010c8
-#define BNX2_CTX_HOST_PAGE_TBL_CTRL_PAGE_TBL_ADDR	 (0x1ffL<<0)
-#define BNX2_CTX_HOST_PAGE_TBL_CTRL_WRITE_REQ		 (1L<<30)
-#define BNX2_CTX_HOST_PAGE_TBL_CTRL_READ_REQ		 (1L<<31)
-
-#define BNX2_CTX_HOST_PAGE_TBL_DATA0			0x000010cc
-#define BNX2_CTX_HOST_PAGE_TBL_DATA0_VALID		 (1L<<0)
-#define BNX2_CTX_HOST_PAGE_TBL_DATA0_VALUE		 (0xffffffL<<8)
-
-#define BNX2_CTX_HOST_PAGE_TBL_DATA1			0x000010d0
-#define BNX2_CTX_CAM_CTRL				0x000010d4
-#define BNX2_CTX_CAM_CTRL_CAM_ADDR			 (0x3ffL<<0)
-#define BNX2_CTX_CAM_CTRL_RESET				 (1L<<27)
-#define BNX2_CTX_CAM_CTRL_INVALIDATE			 (1L<<28)
-#define BNX2_CTX_CAM_CTRL_SEARCH			 (1L<<29)
-#define BNX2_CTX_CAM_CTRL_WRITE_REQ			 (1L<<30)
-#define BNX2_CTX_CAM_CTRL_READ_REQ			 (1L<<31)
-
-
-/*
- *  emac_reg definition
- *  offset: 0x1400
- */
-#define BNX2_EMAC_MODE					0x00001400
-#define BNX2_EMAC_MODE_RESET				 (1L<<0)
-#define BNX2_EMAC_MODE_HALF_DUPLEX			 (1L<<1)
-#define BNX2_EMAC_MODE_PORT				 (0x3L<<2)
-#define BNX2_EMAC_MODE_PORT_NONE			 (0L<<2)
-#define BNX2_EMAC_MODE_PORT_MII				 (1L<<2)
-#define BNX2_EMAC_MODE_PORT_GMII			 (2L<<2)
-#define BNX2_EMAC_MODE_PORT_MII_10M			 (3L<<2)
-#define BNX2_EMAC_MODE_MAC_LOOP				 (1L<<4)
-#define BNX2_EMAC_MODE_25G_MODE				 (1L<<5)
-#define BNX2_EMAC_MODE_TAGGED_MAC_CTL			 (1L<<7)
-#define BNX2_EMAC_MODE_TX_BURST				 (1L<<8)
-#define BNX2_EMAC_MODE_MAX_DEFER_DROP_ENA		 (1L<<9)
-#define BNX2_EMAC_MODE_EXT_LINK_POL			 (1L<<10)
-#define BNX2_EMAC_MODE_FORCE_LINK			 (1L<<11)
-#define BNX2_EMAC_MODE_SERDES_MODE			 (1L<<12)
-#define BNX2_EMAC_MODE_BOND_OVRD			 (1L<<13)
-#define BNX2_EMAC_MODE_MPKT				 (1L<<18)
-#define BNX2_EMAC_MODE_MPKT_RCVD			 (1L<<19)
-#define BNX2_EMAC_MODE_ACPI_RCVD			 (1L<<20)
-
-#define BNX2_EMAC_STATUS				0x00001404
-#define BNX2_EMAC_STATUS_LINK				 (1L<<11)
-#define BNX2_EMAC_STATUS_LINK_CHANGE			 (1L<<12)
-#define BNX2_EMAC_STATUS_SERDES_AUTONEG_COMPLETE	 (1L<<13)
-#define BNX2_EMAC_STATUS_SERDES_AUTONEG_CHANGE		 (1L<<14)
-#define BNX2_EMAC_STATUS_SERDES_NXT_PG_CHANGE		 (1L<<16)
-#define BNX2_EMAC_STATUS_SERDES_RX_CONFIG_IS_0		 (1L<<17)
-#define BNX2_EMAC_STATUS_SERDES_RX_CONFIG_IS_0_CHANGE	 (1L<<18)
-#define BNX2_EMAC_STATUS_MI_COMPLETE			 (1L<<22)
-#define BNX2_EMAC_STATUS_MI_INT				 (1L<<23)
-#define BNX2_EMAC_STATUS_AP_ERROR			 (1L<<24)
-#define BNX2_EMAC_STATUS_PARITY_ERROR_STATE		 (1L<<31)
-
-#define BNX2_EMAC_ATTENTION_ENA				0x00001408
-#define BNX2_EMAC_ATTENTION_ENA_LINK			 (1L<<11)
-#define BNX2_EMAC_ATTENTION_ENA_AUTONEG_CHANGE		 (1L<<14)
-#define BNX2_EMAC_ATTENTION_ENA_NXT_PG_CHANGE		 (1L<<16)
-#define BNX2_EMAC_ATTENTION_ENA_SERDES_RX_CONFIG_IS_0_CHANGE	 (1L<<18)
-#define BNX2_EMAC_ATTENTION_ENA_MI_COMPLETE		 (1L<<22)
-#define BNX2_EMAC_ATTENTION_ENA_MI_INT			 (1L<<23)
-#define BNX2_EMAC_ATTENTION_ENA_AP_ERROR		 (1L<<24)
-
-#define BNX2_EMAC_LED					0x0000140c
-#define BNX2_EMAC_LED_OVERRIDE				 (1L<<0)
-#define BNX2_EMAC_LED_1000MB_OVERRIDE			 (1L<<1)
-#define BNX2_EMAC_LED_100MB_OVERRIDE			 (1L<<2)
-#define BNX2_EMAC_LED_10MB_OVERRIDE			 (1L<<3)
-#define BNX2_EMAC_LED_TRAFFIC_OVERRIDE			 (1L<<4)
-#define BNX2_EMAC_LED_BLNK_TRAFFIC			 (1L<<5)
-#define BNX2_EMAC_LED_TRAFFIC				 (1L<<6)
-#define BNX2_EMAC_LED_1000MB				 (1L<<7)
-#define BNX2_EMAC_LED_100MB				 (1L<<8)
-#define BNX2_EMAC_LED_10MB				 (1L<<9)
-#define BNX2_EMAC_LED_TRAFFIC_STAT			 (1L<<10)
-#define BNX2_EMAC_LED_2500MB				 (1L<<11)
-#define BNX2_EMAC_LED_2500MB_OVERRIDE			 (1L<<12)
-#define BNX2_EMAC_LED_ACTIVITY_SEL			 (0x3L<<17)
-#define BNX2_EMAC_LED_ACTIVITY_SEL_0			 (0L<<17)
-#define BNX2_EMAC_LED_ACTIVITY_SEL_1			 (1L<<17)
-#define BNX2_EMAC_LED_ACTIVITY_SEL_2			 (2L<<17)
-#define BNX2_EMAC_LED_ACTIVITY_SEL_3			 (3L<<17)
-#define BNX2_EMAC_LED_BLNK_RATE				 (0xfffL<<19)
-#define BNX2_EMAC_LED_BLNK_RATE_ENA			 (1L<<31)
-
-#define BNX2_EMAC_MAC_MATCH0				0x00001410
-#define BNX2_EMAC_MAC_MATCH1				0x00001414
-#define BNX2_EMAC_MAC_MATCH2				0x00001418
-#define BNX2_EMAC_MAC_MATCH3				0x0000141c
-#define BNX2_EMAC_MAC_MATCH4				0x00001420
-#define BNX2_EMAC_MAC_MATCH5				0x00001424
-#define BNX2_EMAC_MAC_MATCH6				0x00001428
-#define BNX2_EMAC_MAC_MATCH7				0x0000142c
-#define BNX2_EMAC_MAC_MATCH8				0x00001430
-#define BNX2_EMAC_MAC_MATCH9				0x00001434
-#define BNX2_EMAC_MAC_MATCH10				0x00001438
-#define BNX2_EMAC_MAC_MATCH11				0x0000143c
-#define BNX2_EMAC_MAC_MATCH12				0x00001440
-#define BNX2_EMAC_MAC_MATCH13				0x00001444
-#define BNX2_EMAC_MAC_MATCH14				0x00001448
-#define BNX2_EMAC_MAC_MATCH15				0x0000144c
-#define BNX2_EMAC_MAC_MATCH16				0x00001450
-#define BNX2_EMAC_MAC_MATCH17				0x00001454
-#define BNX2_EMAC_MAC_MATCH18				0x00001458
-#define BNX2_EMAC_MAC_MATCH19				0x0000145c
-#define BNX2_EMAC_MAC_MATCH20				0x00001460
-#define BNX2_EMAC_MAC_MATCH21				0x00001464
-#define BNX2_EMAC_MAC_MATCH22				0x00001468
-#define BNX2_EMAC_MAC_MATCH23				0x0000146c
-#define BNX2_EMAC_MAC_MATCH24				0x00001470
-#define BNX2_EMAC_MAC_MATCH25				0x00001474
-#define BNX2_EMAC_MAC_MATCH26				0x00001478
-#define BNX2_EMAC_MAC_MATCH27				0x0000147c
-#define BNX2_EMAC_MAC_MATCH28				0x00001480
-#define BNX2_EMAC_MAC_MATCH29				0x00001484
-#define BNX2_EMAC_MAC_MATCH30				0x00001488
-#define BNX2_EMAC_MAC_MATCH31				0x0000148c
-#define BNX2_EMAC_BACKOFF_SEED				0x00001498
-#define BNX2_EMAC_BACKOFF_SEED_EMAC_BACKOFF_SEED	 (0x3ffL<<0)
-
-#define BNX2_EMAC_RX_MTU_SIZE				0x0000149c
-#define BNX2_EMAC_RX_MTU_SIZE_MTU_SIZE			 (0xffffL<<0)
-#define BNX2_EMAC_RX_MTU_SIZE_JUMBO_ENA			 (1L<<31)
-
-#define BNX2_EMAC_SERDES_CNTL				0x000014a4
-#define BNX2_EMAC_SERDES_CNTL_RXR			 (0x7L<<0)
-#define BNX2_EMAC_SERDES_CNTL_RXG			 (0x3L<<3)
-#define BNX2_EMAC_SERDES_CNTL_RXCKSEL			 (1L<<6)
-#define BNX2_EMAC_SERDES_CNTL_TXBIAS			 (0x7L<<7)
-#define BNX2_EMAC_SERDES_CNTL_BGMAX			 (1L<<10)
-#define BNX2_EMAC_SERDES_CNTL_BGMIN			 (1L<<11)
-#define BNX2_EMAC_SERDES_CNTL_TXMODE			 (1L<<12)
-#define BNX2_EMAC_SERDES_CNTL_TXEDGE			 (1L<<13)
-#define BNX2_EMAC_SERDES_CNTL_SERDES_MODE		 (1L<<14)
-#define BNX2_EMAC_SERDES_CNTL_PLLTEST			 (1L<<15)
-#define BNX2_EMAC_SERDES_CNTL_CDET_EN			 (1L<<16)
-#define BNX2_EMAC_SERDES_CNTL_TBI_LBK			 (1L<<17)
-#define BNX2_EMAC_SERDES_CNTL_REMOTE_LBK		 (1L<<18)
-#define BNX2_EMAC_SERDES_CNTL_REV_PHASE			 (1L<<19)
-#define BNX2_EMAC_SERDES_CNTL_REGCTL12			 (0x3L<<20)
-#define BNX2_EMAC_SERDES_CNTL_REGCTL25			 (0x3L<<22)
-
-#define BNX2_EMAC_SERDES_STATUS				0x000014a8
-#define BNX2_EMAC_SERDES_STATUS_RX_STAT			 (0xffL<<0)
-#define BNX2_EMAC_SERDES_STATUS_COMMA_DET		 (1L<<8)
-
-#define BNX2_EMAC_MDIO_COMM				0x000014ac
-#define BNX2_EMAC_MDIO_COMM_DATA			 (0xffffL<<0)
-#define BNX2_EMAC_MDIO_COMM_REG_ADDR			 (0x1fL<<16)
-#define BNX2_EMAC_MDIO_COMM_PHY_ADDR			 (0x1fL<<21)
-#define BNX2_EMAC_MDIO_COMM_COMMAND			 (0x3L<<26)
-#define BNX2_EMAC_MDIO_COMM_COMMAND_UNDEFINED_0		 (0L<<26)
-#define BNX2_EMAC_MDIO_COMM_COMMAND_ADDRESS		 (0L<<26)
-#define BNX2_EMAC_MDIO_COMM_COMMAND_WRITE		 (1L<<26)
-#define BNX2_EMAC_MDIO_COMM_COMMAND_READ		 (2L<<26)
-#define BNX2_EMAC_MDIO_COMM_COMMAND_WRITE_22_XI		 (1L<<26)
-#define BNX2_EMAC_MDIO_COMM_COMMAND_WRITE_45_XI		 (1L<<26)
-#define BNX2_EMAC_MDIO_COMM_COMMAND_READ_22_XI		 (2L<<26)
-#define BNX2_EMAC_MDIO_COMM_COMMAND_READ_INC_45_XI	 (2L<<26)
-#define BNX2_EMAC_MDIO_COMM_COMMAND_UNDEFINED_3		 (3L<<26)
-#define BNX2_EMAC_MDIO_COMM_COMMAND_READ_45		 (3L<<26)
-#define BNX2_EMAC_MDIO_COMM_FAIL			 (1L<<28)
-#define BNX2_EMAC_MDIO_COMM_START_BUSY			 (1L<<29)
-#define BNX2_EMAC_MDIO_COMM_DISEXT			 (1L<<30)
-
-#define BNX2_EMAC_MDIO_STATUS				0x000014b0
-#define BNX2_EMAC_MDIO_STATUS_LINK			 (1L<<0)
-#define BNX2_EMAC_MDIO_STATUS_10MB			 (1L<<1)
-
-#define BNX2_EMAC_MDIO_MODE				0x000014b4
-#define BNX2_EMAC_MDIO_MODE_SHORT_PREAMBLE		 (1L<<1)
-#define BNX2_EMAC_MDIO_MODE_AUTO_POLL			 (1L<<4)
-#define BNX2_EMAC_MDIO_MODE_BIT_BANG			 (1L<<8)
-#define BNX2_EMAC_MDIO_MODE_MDIO			 (1L<<9)
-#define BNX2_EMAC_MDIO_MODE_MDIO_OE			 (1L<<10)
-#define BNX2_EMAC_MDIO_MODE_MDC				 (1L<<11)
-#define BNX2_EMAC_MDIO_MODE_MDINT			 (1L<<12)
-#define BNX2_EMAC_MDIO_MODE_EXT_MDINT			 (1L<<13)
-#define BNX2_EMAC_MDIO_MODE_CLOCK_CNT			 (0x1fL<<16)
-#define BNX2_EMAC_MDIO_MODE_CLOCK_CNT_XI		 (0x3fL<<16)
-#define BNX2_EMAC_MDIO_MODE_CLAUSE_45_XI		 (1L<<31)
-
-#define BNX2_EMAC_MDIO_AUTO_STATUS			0x000014b8
-#define BNX2_EMAC_MDIO_AUTO_STATUS_AUTO_ERR		 (1L<<0)
-
-#define BNX2_EMAC_TX_MODE				0x000014bc
-#define BNX2_EMAC_TX_MODE_RESET				 (1L<<0)
-#define BNX2_EMAC_TX_MODE_CS16_TEST			 (1L<<2)
-#define BNX2_EMAC_TX_MODE_EXT_PAUSE_EN			 (1L<<3)
-#define BNX2_EMAC_TX_MODE_FLOW_EN			 (1L<<4)
-#define BNX2_EMAC_TX_MODE_BIG_BACKOFF			 (1L<<5)
-#define BNX2_EMAC_TX_MODE_LONG_PAUSE			 (1L<<6)
-#define BNX2_EMAC_TX_MODE_LINK_AWARE			 (1L<<7)
-
-#define BNX2_EMAC_TX_STATUS				0x000014c0
-#define BNX2_EMAC_TX_STATUS_XOFFED			 (1L<<0)
-#define BNX2_EMAC_TX_STATUS_XOFF_SENT			 (1L<<1)
-#define BNX2_EMAC_TX_STATUS_XON_SENT			 (1L<<2)
-#define BNX2_EMAC_TX_STATUS_LINK_UP			 (1L<<3)
-#define BNX2_EMAC_TX_STATUS_UNDERRUN			 (1L<<4)
-#define BNX2_EMAC_TX_STATUS_CS16_ERROR			 (1L<<5)
-
-#define BNX2_EMAC_TX_LENGTHS				0x000014c4
-#define BNX2_EMAC_TX_LENGTHS_SLOT			 (0xffL<<0)
-#define BNX2_EMAC_TX_LENGTHS_IPG			 (0xfL<<8)
-#define BNX2_EMAC_TX_LENGTHS_IPG_CRS			 (0x3L<<12)
-
-#define BNX2_EMAC_RX_MODE				0x000014c8
-#define BNX2_EMAC_RX_MODE_RESET				 (1L<<0)
-#define BNX2_EMAC_RX_MODE_FLOW_EN			 (1L<<2)
-#define BNX2_EMAC_RX_MODE_KEEP_MAC_CONTROL		 (1L<<3)
-#define BNX2_EMAC_RX_MODE_KEEP_PAUSE			 (1L<<4)
-#define BNX2_EMAC_RX_MODE_ACCEPT_OVERSIZE		 (1L<<5)
-#define BNX2_EMAC_RX_MODE_ACCEPT_RUNTS			 (1L<<6)
-#define BNX2_EMAC_RX_MODE_LLC_CHK			 (1L<<7)
-#define BNX2_EMAC_RX_MODE_PROMISCUOUS			 (1L<<8)
-#define BNX2_EMAC_RX_MODE_NO_CRC_CHK			 (1L<<9)
-#define BNX2_EMAC_RX_MODE_KEEP_VLAN_TAG			 (1L<<10)
-#define BNX2_EMAC_RX_MODE_FILT_BROADCAST		 (1L<<11)
-#define BNX2_EMAC_RX_MODE_SORT_MODE			 (1L<<12)
-
-#define BNX2_EMAC_RX_STATUS				0x000014cc
-#define BNX2_EMAC_RX_STATUS_FFED			 (1L<<0)
-#define BNX2_EMAC_RX_STATUS_FF_RECEIVED			 (1L<<1)
-#define BNX2_EMAC_RX_STATUS_N_RECEIVED			 (1L<<2)
-
-#define BNX2_EMAC_MULTICAST_HASH0			0x000014d0
-#define BNX2_EMAC_MULTICAST_HASH1			0x000014d4
-#define BNX2_EMAC_MULTICAST_HASH2			0x000014d8
-#define BNX2_EMAC_MULTICAST_HASH3			0x000014dc
-#define BNX2_EMAC_MULTICAST_HASH4			0x000014e0
-#define BNX2_EMAC_MULTICAST_HASH5			0x000014e4
-#define BNX2_EMAC_MULTICAST_HASH6			0x000014e8
-#define BNX2_EMAC_MULTICAST_HASH7			0x000014ec
-#define BNX2_EMAC_CKSUM_ERROR_STATUS			0x000014f0
-#define BNX2_EMAC_CKSUM_ERROR_STATUS_CALCULATED		 (0xffffL<<0)
-#define BNX2_EMAC_CKSUM_ERROR_STATUS_EXPECTED		 (0xffffL<<16)
-
-#define BNX2_EMAC_RX_STAT_IFHCINOCTETS			0x00001500
-#define BNX2_EMAC_RX_STAT_IFHCINBADOCTETS		0x00001504
-#define BNX2_EMAC_RX_STAT_ETHERSTATSFRAGMENTS		0x00001508
-#define BNX2_EMAC_RX_STAT_IFHCINUCASTPKTS		0x0000150c
-#define BNX2_EMAC_RX_STAT_IFHCINMULTICASTPKTS		0x00001510
-#define BNX2_EMAC_RX_STAT_IFHCINBROADCASTPKTS		0x00001514
-#define BNX2_EMAC_RX_STAT_DOT3STATSFCSERRORS		0x00001518
-#define BNX2_EMAC_RX_STAT_DOT3STATSALIGNMENTERRORS	0x0000151c
-#define BNX2_EMAC_RX_STAT_DOT3STATSCARRIERSENSEERRORS	0x00001520
-#define BNX2_EMAC_RX_STAT_XONPAUSEFRAMESRECEIVED	0x00001524
-#define BNX2_EMAC_RX_STAT_XOFFPAUSEFRAMESRECEIVED	0x00001528
-#define BNX2_EMAC_RX_STAT_MACCONTROLFRAMESRECEIVED	0x0000152c
-#define BNX2_EMAC_RX_STAT_XOFFSTATEENTERED		0x00001530
-#define BNX2_EMAC_RX_STAT_DOT3STATSFRAMESTOOLONG	0x00001534
-#define BNX2_EMAC_RX_STAT_ETHERSTATSJABBERS		0x00001538
-#define BNX2_EMAC_RX_STAT_ETHERSTATSUNDERSIZEPKTS	0x0000153c
-#define BNX2_EMAC_RX_STAT_ETHERSTATSPKTS64OCTETS	0x00001540
-#define BNX2_EMAC_RX_STAT_ETHERSTATSPKTS65OCTETSTO127OCTETS	0x00001544
-#define BNX2_EMAC_RX_STAT_ETHERSTATSPKTS128OCTETSTO255OCTETS	0x00001548
-#define BNX2_EMAC_RX_STAT_ETHERSTATSPKTS256OCTETSTO511OCTETS	0x0000154c
-#define BNX2_EMAC_RX_STAT_ETHERSTATSPKTS512OCTETSTO1023OCTETS	0x00001550
-#define BNX2_EMAC_RX_STAT_ETHERSTATSPKTS1024OCTETSTO1522OCTETS	0x00001554
-#define BNX2_EMAC_RX_STAT_ETHERSTATSPKTSOVER1522OCTETS	0x00001558
-#define BNX2_EMAC_RXMAC_DEBUG0				0x0000155c
-#define BNX2_EMAC_RXMAC_DEBUG1				0x00001560
-#define BNX2_EMAC_RXMAC_DEBUG1_LENGTH_NE_BYTE_COUNT	 (1L<<0)
-#define BNX2_EMAC_RXMAC_DEBUG1_LENGTH_OUT_RANGE		 (1L<<1)
-#define BNX2_EMAC_RXMAC_DEBUG1_BAD_CRC			 (1L<<2)
-#define BNX2_EMAC_RXMAC_DEBUG1_RX_ERROR			 (1L<<3)
-#define BNX2_EMAC_RXMAC_DEBUG1_ALIGN_ERROR		 (1L<<4)
-#define BNX2_EMAC_RXMAC_DEBUG1_LAST_DATA		 (1L<<5)
-#define BNX2_EMAC_RXMAC_DEBUG1_ODD_BYTE_START		 (1L<<6)
-#define BNX2_EMAC_RXMAC_DEBUG1_BYTE_COUNT		 (0xffffL<<7)
-#define BNX2_EMAC_RXMAC_DEBUG1_SLOT_TIME		 (0xffL<<23)
-
-#define BNX2_EMAC_RXMAC_DEBUG2				0x00001564
-#define BNX2_EMAC_RXMAC_DEBUG2_SM_STATE			 (0x7L<<0)
-#define BNX2_EMAC_RXMAC_DEBUG2_SM_STATE_IDLE		 (0x0L<<0)
-#define BNX2_EMAC_RXMAC_DEBUG2_SM_STATE_SFD		 (0x1L<<0)
-#define BNX2_EMAC_RXMAC_DEBUG2_SM_STATE_DATA		 (0x2L<<0)
-#define BNX2_EMAC_RXMAC_DEBUG2_SM_STATE_SKEEP		 (0x3L<<0)
-#define BNX2_EMAC_RXMAC_DEBUG2_SM_STATE_EXT		 (0x4L<<0)
-#define BNX2_EMAC_RXMAC_DEBUG2_SM_STATE_DROP		 (0x5L<<0)
-#define BNX2_EMAC_RXMAC_DEBUG2_SM_STATE_SDROP		 (0x6L<<0)
-#define BNX2_EMAC_RXMAC_DEBUG2_SM_STATE_FC		 (0x7L<<0)
-#define BNX2_EMAC_RXMAC_DEBUG2_IDI_STATE		 (0xfL<<3)
-#define BNX2_EMAC_RXMAC_DEBUG2_IDI_STATE_IDLE		 (0x0L<<3)
-#define BNX2_EMAC_RXMAC_DEBUG2_IDI_STATE_DATA0		 (0x1L<<3)
-#define BNX2_EMAC_RXMAC_DEBUG2_IDI_STATE_DATA1		 (0x2L<<3)
-#define BNX2_EMAC_RXMAC_DEBUG2_IDI_STATE_DATA2		 (0x3L<<3)
-#define BNX2_EMAC_RXMAC_DEBUG2_IDI_STATE_DATA3		 (0x4L<<3)
-#define BNX2_EMAC_RXMAC_DEBUG2_IDI_STATE_ABORT		 (0x5L<<3)
-#define BNX2_EMAC_RXMAC_DEBUG2_IDI_STATE_WAIT		 (0x6L<<3)
-#define BNX2_EMAC_RXMAC_DEBUG2_IDI_STATE_STATUS		 (0x7L<<3)
-#define BNX2_EMAC_RXMAC_DEBUG2_IDI_STATE_LAST		 (0x8L<<3)
-#define BNX2_EMAC_RXMAC_DEBUG2_BYTE_IN			 (0xffL<<7)
-#define BNX2_EMAC_RXMAC_DEBUG2_FALSEC			 (1L<<15)
-#define BNX2_EMAC_RXMAC_DEBUG2_TAGGED			 (1L<<16)
-#define BNX2_EMAC_RXMAC_DEBUG2_PAUSE_STATE		 (1L<<18)
-#define BNX2_EMAC_RXMAC_DEBUG2_PAUSE_STATE_IDLE		 (0L<<18)
-#define BNX2_EMAC_RXMAC_DEBUG2_PAUSE_STATE_PAUSED	 (1L<<18)
-#define BNX2_EMAC_RXMAC_DEBUG2_SE_COUNTER		 (0xfL<<19)
-#define BNX2_EMAC_RXMAC_DEBUG2_QUANTA			 (0x1fL<<23)
-
-#define BNX2_EMAC_RXMAC_DEBUG3				0x00001568
-#define BNX2_EMAC_RXMAC_DEBUG3_PAUSE_CTR		 (0xffffL<<0)
-#define BNX2_EMAC_RXMAC_DEBUG3_TMP_PAUSE_CTR		 (0xffffL<<16)
-
-#define BNX2_EMAC_RXMAC_DEBUG4				0x0000156c
-#define BNX2_EMAC_RXMAC_DEBUG4_TYPE_FIELD		 (0xffffL<<0)
-#define BNX2_EMAC_RXMAC_DEBUG4_FILT_STATE		 (0x3fL<<16)
-#define BNX2_EMAC_RXMAC_DEBUG4_FILT_STATE_IDLE		 (0x0L<<16)
-#define BNX2_EMAC_RXMAC_DEBUG4_FILT_STATE_UMAC2		 (0x1L<<16)
-#define BNX2_EMAC_RXMAC_DEBUG4_FILT_STATE_UMAC3		 (0x2L<<16)
-#define BNX2_EMAC_RXMAC_DEBUG4_FILT_STATE_UNI		 (0x3L<<16)
-#define BNX2_EMAC_RXMAC_DEBUG4_FILT_STATE_MMAC3		 (0x5L<<16)
-#define BNX2_EMAC_RXMAC_DEBUG4_FILT_STATE_PSA1		 (0x6L<<16)
-#define BNX2_EMAC_RXMAC_DEBUG4_FILT_STATE_MMAC2		 (0x7L<<16)
-#define BNX2_EMAC_RXMAC_DEBUG4_FILT_STATE_PSA2		 (0x7L<<16)
-#define BNX2_EMAC_RXMAC_DEBUG4_FILT_STATE_PSA3		 (0x8L<<16)
-#define BNX2_EMAC_RXMAC_DEBUG4_FILT_STATE_MC2		 (0x9L<<16)
-#define BNX2_EMAC_RXMAC_DEBUG4_FILT_STATE_MC3		 (0xaL<<16)
-#define BNX2_EMAC_RXMAC_DEBUG4_FILT_STATE_MWAIT1	 (0xeL<<16)
-#define BNX2_EMAC_RXMAC_DEBUG4_FILT_STATE_MWAIT2	 (0xfL<<16)
-#define BNX2_EMAC_RXMAC_DEBUG4_FILT_STATE_MCHECK	 (0x10L<<16)
-#define BNX2_EMAC_RXMAC_DEBUG4_FILT_STATE_MC		 (0x11L<<16)
-#define BNX2_EMAC_RXMAC_DEBUG4_FILT_STATE_BC2		 (0x12L<<16)
-#define BNX2_EMAC_RXMAC_DEBUG4_FILT_STATE_BC3		 (0x13L<<16)
-#define BNX2_EMAC_RXMAC_DEBUG4_FILT_STATE_BSA1		 (0x14L<<16)
-#define BNX2_EMAC_RXMAC_DEBUG4_FILT_STATE_BSA2		 (0x15L<<16)
-#define BNX2_EMAC_RXMAC_DEBUG4_FILT_STATE_BSA3		 (0x16L<<16)
-#define BNX2_EMAC_RXMAC_DEBUG4_FILT_STATE_BTYPE		 (0x17L<<16)
-#define BNX2_EMAC_RXMAC_DEBUG4_FILT_STATE_BC		 (0x18L<<16)
-#define BNX2_EMAC_RXMAC_DEBUG4_FILT_STATE_PTYPE		 (0x19L<<16)
-#define BNX2_EMAC_RXMAC_DEBUG4_FILT_STATE_CMD		 (0x1aL<<16)
-#define BNX2_EMAC_RXMAC_DEBUG4_FILT_STATE_MAC		 (0x1bL<<16)
-#define BNX2_EMAC_RXMAC_DEBUG4_FILT_STATE_LATCH		 (0x1cL<<16)
-#define BNX2_EMAC_RXMAC_DEBUG4_FILT_STATE_XOFF		 (0x1dL<<16)
-#define BNX2_EMAC_RXMAC_DEBUG4_FILT_STATE_XON		 (0x1eL<<16)
-#define BNX2_EMAC_RXMAC_DEBUG4_FILT_STATE_PAUSED	 (0x1fL<<16)
-#define BNX2_EMAC_RXMAC_DEBUG4_FILT_STATE_NPAUSED	 (0x20L<<16)
-#define BNX2_EMAC_RXMAC_DEBUG4_FILT_STATE_TTYPE		 (0x21L<<16)
-#define BNX2_EMAC_RXMAC_DEBUG4_FILT_STATE_TVAL		 (0x22L<<16)
-#define BNX2_EMAC_RXMAC_DEBUG4_FILT_STATE_USA1		 (0x23L<<16)
-#define BNX2_EMAC_RXMAC_DEBUG4_FILT_STATE_USA2		 (0x24L<<16)
-#define BNX2_EMAC_RXMAC_DEBUG4_FILT_STATE_USA3		 (0x25L<<16)
-#define BNX2_EMAC_RXMAC_DEBUG4_FILT_STATE_UTYPE		 (0x26L<<16)
-#define BNX2_EMAC_RXMAC_DEBUG4_FILT_STATE_UTTYPE	 (0x27L<<16)
-#define BNX2_EMAC_RXMAC_DEBUG4_FILT_STATE_UTVAL		 (0x28L<<16)
-#define BNX2_EMAC_RXMAC_DEBUG4_FILT_STATE_MTYPE		 (0x29L<<16)
-#define BNX2_EMAC_RXMAC_DEBUG4_FILT_STATE_DROP		 (0x2aL<<16)
-#define BNX2_EMAC_RXMAC_DEBUG4_DROP_PKT			 (1L<<22)
-#define BNX2_EMAC_RXMAC_DEBUG4_SLOT_FILLED		 (1L<<23)
-#define BNX2_EMAC_RXMAC_DEBUG4_FALSE_CARRIER		 (1L<<24)
-#define BNX2_EMAC_RXMAC_DEBUG4_LAST_DATA		 (1L<<25)
-#define BNX2_EMAC_RXMAC_DEBUG4_SFD_FOUND		 (1L<<26)
-#define BNX2_EMAC_RXMAC_DEBUG4_ADVANCE			 (1L<<27)
-#define BNX2_EMAC_RXMAC_DEBUG4_START			 (1L<<28)
-
-#define BNX2_EMAC_RXMAC_DEBUG5				0x00001570
-#define BNX2_EMAC_RXMAC_DEBUG5_PS_IDISM			 (0x7L<<0)
-#define BNX2_EMAC_RXMAC_DEBUG5_PS_IDISM_IDLE		 (0L<<0)
-#define BNX2_EMAC_RXMAC_DEBUG5_PS_IDISM_WAIT_EOF	 (1L<<0)
-#define BNX2_EMAC_RXMAC_DEBUG5_PS_IDISM_WAIT_STAT	 (2L<<0)
-#define BNX2_EMAC_RXMAC_DEBUG5_PS_IDISM_SET_EOF4FCRC	 (3L<<0)
-#define BNX2_EMAC_RXMAC_DEBUG5_PS_IDISM_SET_EOF4RDE	 (4L<<0)
-#define BNX2_EMAC_RXMAC_DEBUG5_PS_IDISM_SET_EOF4ALL	 (5L<<0)
-#define BNX2_EMAC_RXMAC_DEBUG5_PS_IDISM_1WD_WAIT_STAT	 (6L<<0)
-#define BNX2_EMAC_RXMAC_DEBUG5_CCODE_BUF1		 (0x7L<<4)
-#define BNX2_EMAC_RXMAC_DEBUG5_CCODE_BUF1_VDW		 (0x0L<<4)
-#define BNX2_EMAC_RXMAC_DEBUG5_CCODE_BUF1_STAT		 (0x1L<<4)
-#define BNX2_EMAC_RXMAC_DEBUG5_CCODE_BUF1_AEOF		 (0x2L<<4)
-#define BNX2_EMAC_RXMAC_DEBUG5_CCODE_BUF1_NEOF		 (0x3L<<4)
-#define BNX2_EMAC_RXMAC_DEBUG5_CCODE_BUF1_SOF		 (0x4L<<4)
-#define BNX2_EMAC_RXMAC_DEBUG5_CCODE_BUF1_SAEOF		 (0x6L<<4)
-#define BNX2_EMAC_RXMAC_DEBUG5_CCODE_BUF1_SNEOF		 (0x7L<<4)
-#define BNX2_EMAC_RXMAC_DEBUG5_EOF_DETECTED		 (1L<<7)
-#define BNX2_EMAC_RXMAC_DEBUG5_CCODE_BUF0		 (0x7L<<8)
-#define BNX2_EMAC_RXMAC_DEBUG5_RPM_IDI_FIFO_FULL	 (1L<<11)
-#define BNX2_EMAC_RXMAC_DEBUG5_LOAD_CCODE		 (1L<<12)
-#define BNX2_EMAC_RXMAC_DEBUG5_LOAD_DATA		 (1L<<13)
-#define BNX2_EMAC_RXMAC_DEBUG5_LOAD_STAT		 (1L<<14)
-#define BNX2_EMAC_RXMAC_DEBUG5_CLR_STAT			 (1L<<15)
-#define BNX2_EMAC_RXMAC_DEBUG5_IDI_RPM_CCODE		 (0x3L<<16)
-#define BNX2_EMAC_RXMAC_DEBUG5_IDI_RPM_ACCEPT		 (1L<<19)
-#define BNX2_EMAC_RXMAC_DEBUG5_FMLEN			 (0xfffL<<20)
-
-#define BNX2_EMAC_RX_STAT_FALSECARRIERERRORS		0x00001574
-#define BNX2_EMAC_RX_STAT_AC0				0x00001580
-#define BNX2_EMAC_RX_STAT_AC1				0x00001584
-#define BNX2_EMAC_RX_STAT_AC2				0x00001588
-#define BNX2_EMAC_RX_STAT_AC3				0x0000158c
-#define BNX2_EMAC_RX_STAT_AC4				0x00001590
-#define BNX2_EMAC_RX_STAT_AC5				0x00001594
-#define BNX2_EMAC_RX_STAT_AC6				0x00001598
-#define BNX2_EMAC_RX_STAT_AC7				0x0000159c
-#define BNX2_EMAC_RX_STAT_AC8				0x000015a0
-#define BNX2_EMAC_RX_STAT_AC9				0x000015a4
-#define BNX2_EMAC_RX_STAT_AC10				0x000015a8
-#define BNX2_EMAC_RX_STAT_AC11				0x000015ac
-#define BNX2_EMAC_RX_STAT_AC12				0x000015b0
-#define BNX2_EMAC_RX_STAT_AC13				0x000015b4
-#define BNX2_EMAC_RX_STAT_AC14				0x000015b8
-#define BNX2_EMAC_RX_STAT_AC15				0x000015bc
-#define BNX2_EMAC_RX_STAT_AC16				0x000015c0
-#define BNX2_EMAC_RX_STAT_AC17				0x000015c4
-#define BNX2_EMAC_RX_STAT_AC18				0x000015c8
-#define BNX2_EMAC_RX_STAT_AC19				0x000015cc
-#define BNX2_EMAC_RX_STAT_AC20				0x000015d0
-#define BNX2_EMAC_RX_STAT_AC21				0x000015d4
-#define BNX2_EMAC_RX_STAT_AC22				0x000015d8
-#define BNX2_EMAC_RXMAC_SUC_DBG_OVERRUNVEC		0x000015dc
-#define BNX2_EMAC_RX_STAT_AC_28				0x000015f4
-#define BNX2_EMAC_TX_STAT_IFHCOUTOCTETS			0x00001600
-#define BNX2_EMAC_TX_STAT_IFHCOUTBADOCTETS		0x00001604
-#define BNX2_EMAC_TX_STAT_ETHERSTATSCOLLISIONS		0x00001608
-#define BNX2_EMAC_TX_STAT_OUTXONSENT			0x0000160c
-#define BNX2_EMAC_TX_STAT_OUTXOFFSENT			0x00001610
-#define BNX2_EMAC_TX_STAT_FLOWCONTROLDONE		0x00001614
-#define BNX2_EMAC_TX_STAT_DOT3STATSSINGLECOLLISIONFRAMES	0x00001618
-#define BNX2_EMAC_TX_STAT_DOT3STATSMULTIPLECOLLISIONFRAMES	0x0000161c
-#define BNX2_EMAC_TX_STAT_DOT3STATSDEFERREDTRANSMISSIONS	0x00001620
-#define BNX2_EMAC_TX_STAT_DOT3STATSEXCESSIVECOLLISIONS	0x00001624
-#define BNX2_EMAC_TX_STAT_DOT3STATSLATECOLLISIONS	0x00001628
-#define BNX2_EMAC_TX_STAT_IFHCOUTUCASTPKTS		0x0000162c
-#define BNX2_EMAC_TX_STAT_IFHCOUTMULTICASTPKTS		0x00001630
-#define BNX2_EMAC_TX_STAT_IFHCOUTBROADCASTPKTS		0x00001634
-#define BNX2_EMAC_TX_STAT_ETHERSTATSPKTS64OCTETS	0x00001638
-#define BNX2_EMAC_TX_STAT_ETHERSTATSPKTS65OCTETSTO127OCTETS	0x0000163c
-#define BNX2_EMAC_TX_STAT_ETHERSTATSPKTS128OCTETSTO255OCTETS	0x00001640
-#define BNX2_EMAC_TX_STAT_ETHERSTATSPKTS256OCTETSTO511OCTETS	0x00001644
-#define BNX2_EMAC_TX_STAT_ETHERSTATSPKTS512OCTETSTO1023OCTETS	0x00001648
-#define BNX2_EMAC_TX_STAT_ETHERSTATSPKTS1024OCTETSTO1522OCTETS	0x0000164c
-#define BNX2_EMAC_TX_STAT_ETHERSTATSPKTSOVER1522OCTETS	0x00001650
-#define BNX2_EMAC_TX_STAT_DOT3STATSINTERNALMACTRANSMITERRORS	0x00001654
-#define BNX2_EMAC_TXMAC_DEBUG0				0x00001658
-#define BNX2_EMAC_TXMAC_DEBUG1				0x0000165c
-#define BNX2_EMAC_TXMAC_DEBUG1_ODI_STATE		 (0xfL<<0)
-#define BNX2_EMAC_TXMAC_DEBUG1_ODI_STATE_IDLE		 (0x0L<<0)
-#define BNX2_EMAC_TXMAC_DEBUG1_ODI_STATE_START0		 (0x1L<<0)
-#define BNX2_EMAC_TXMAC_DEBUG1_ODI_STATE_DATA0		 (0x4L<<0)
-#define BNX2_EMAC_TXMAC_DEBUG1_ODI_STATE_DATA1		 (0x5L<<0)
-#define BNX2_EMAC_TXMAC_DEBUG1_ODI_STATE_DATA2		 (0x6L<<0)
-#define BNX2_EMAC_TXMAC_DEBUG1_ODI_STATE_DATA3		 (0x7L<<0)
-#define BNX2_EMAC_TXMAC_DEBUG1_ODI_STATE_WAIT0		 (0x8L<<0)
-#define BNX2_EMAC_TXMAC_DEBUG1_ODI_STATE_WAIT1		 (0x9L<<0)
-#define BNX2_EMAC_TXMAC_DEBUG1_CRS_ENABLE		 (1L<<4)
-#define BNX2_EMAC_TXMAC_DEBUG1_BAD_CRC			 (1L<<5)
-#define BNX2_EMAC_TXMAC_DEBUG1_SE_COUNTER		 (0xfL<<6)
-#define BNX2_EMAC_TXMAC_DEBUG1_SEND_PAUSE		 (1L<<10)
-#define BNX2_EMAC_TXMAC_DEBUG1_LATE_COLLISION		 (1L<<11)
-#define BNX2_EMAC_TXMAC_DEBUG1_MAX_DEFER		 (1L<<12)
-#define BNX2_EMAC_TXMAC_DEBUG1_DEFERRED			 (1L<<13)
-#define BNX2_EMAC_TXMAC_DEBUG1_ONE_BYTE			 (1L<<14)
-#define BNX2_EMAC_TXMAC_DEBUG1_IPG_TIME			 (0xfL<<15)
-#define BNX2_EMAC_TXMAC_DEBUG1_SLOT_TIME		 (0xffL<<19)
-
-#define BNX2_EMAC_TXMAC_DEBUG2				0x00001660
-#define BNX2_EMAC_TXMAC_DEBUG2_BACK_OFF			 (0x3ffL<<0)
-#define BNX2_EMAC_TXMAC_DEBUG2_BYTE_COUNT		 (0xffffL<<10)
-#define BNX2_EMAC_TXMAC_DEBUG2_COL_COUNT		 (0x1fL<<26)
-#define BNX2_EMAC_TXMAC_DEBUG2_COL_BIT			 (1L<<31)
-
-#define BNX2_EMAC_TXMAC_DEBUG3				0x00001664
-#define BNX2_EMAC_TXMAC_DEBUG3_SM_STATE			 (0xfL<<0)
-#define BNX2_EMAC_TXMAC_DEBUG3_SM_STATE_IDLE		 (0x0L<<0)
-#define BNX2_EMAC_TXMAC_DEBUG3_SM_STATE_PRE1		 (0x1L<<0)
-#define BNX2_EMAC_TXMAC_DEBUG3_SM_STATE_PRE2		 (0x2L<<0)
-#define BNX2_EMAC_TXMAC_DEBUG3_SM_STATE_SFD		 (0x3L<<0)
-#define BNX2_EMAC_TXMAC_DEBUG3_SM_STATE_DATA		 (0x4L<<0)
-#define BNX2_EMAC_TXMAC_DEBUG3_SM_STATE_CRC1		 (0x5L<<0)
-#define BNX2_EMAC_TXMAC_DEBUG3_SM_STATE_CRC2		 (0x6L<<0)
-#define BNX2_EMAC_TXMAC_DEBUG3_SM_STATE_EXT		 (0x7L<<0)
-#define BNX2_EMAC_TXMAC_DEBUG3_SM_STATE_STATB		 (0x8L<<0)
-#define BNX2_EMAC_TXMAC_DEBUG3_SM_STATE_STATG		 (0x9L<<0)
-#define BNX2_EMAC_TXMAC_DEBUG3_SM_STATE_JAM		 (0xaL<<0)
-#define BNX2_EMAC_TXMAC_DEBUG3_SM_STATE_EJAM		 (0xbL<<0)
-#define BNX2_EMAC_TXMAC_DEBUG3_SM_STATE_BJAM		 (0xcL<<0)
-#define BNX2_EMAC_TXMAC_DEBUG3_SM_STATE_SWAIT		 (0xdL<<0)
-#define BNX2_EMAC_TXMAC_DEBUG3_SM_STATE_BACKOFF		 (0xeL<<0)
-#define BNX2_EMAC_TXMAC_DEBUG3_FILT_STATE		 (0x7L<<4)
-#define BNX2_EMAC_TXMAC_DEBUG3_FILT_STATE_IDLE		 (0x0L<<4)
-#define BNX2_EMAC_TXMAC_DEBUG3_FILT_STATE_WAIT		 (0x1L<<4)
-#define BNX2_EMAC_TXMAC_DEBUG3_FILT_STATE_UNI		 (0x2L<<4)
-#define BNX2_EMAC_TXMAC_DEBUG3_FILT_STATE_MC		 (0x3L<<4)
-#define BNX2_EMAC_TXMAC_DEBUG3_FILT_STATE_BC2		 (0x4L<<4)
-#define BNX2_EMAC_TXMAC_DEBUG3_FILT_STATE_BC3		 (0x5L<<4)
-#define BNX2_EMAC_TXMAC_DEBUG3_FILT_STATE_BC		 (0x6L<<4)
-#define BNX2_EMAC_TXMAC_DEBUG3_CRS_DONE			 (1L<<7)
-#define BNX2_EMAC_TXMAC_DEBUG3_XOFF			 (1L<<8)
-#define BNX2_EMAC_TXMAC_DEBUG3_SE_COUNTER		 (0xfL<<9)
-#define BNX2_EMAC_TXMAC_DEBUG3_QUANTA_COUNTER		 (0x1fL<<13)
-
-#define BNX2_EMAC_TXMAC_DEBUG4				0x00001668
-#define BNX2_EMAC_TXMAC_DEBUG4_PAUSE_COUNTER		 (0xffffL<<0)
-#define BNX2_EMAC_TXMAC_DEBUG4_PAUSE_STATE		 (0xfL<<16)
-#define BNX2_EMAC_TXMAC_DEBUG4_PAUSE_STATE_IDLE		 (0x0L<<16)
-#define BNX2_EMAC_TXMAC_DEBUG4_PAUSE_STATE_MCA1		 (0x2L<<16)
-#define BNX2_EMAC_TXMAC_DEBUG4_PAUSE_STATE_MCA2		 (0x3L<<16)
-#define BNX2_EMAC_TXMAC_DEBUG4_PAUSE_STATE_SRC3		 (0x4L<<16)
-#define BNX2_EMAC_TXMAC_DEBUG4_PAUSE_STATE_SRC2		 (0x5L<<16)
-#define BNX2_EMAC_TXMAC_DEBUG4_PAUSE_STATE_MCA3		 (0x6L<<16)
-#define BNX2_EMAC_TXMAC_DEBUG4_PAUSE_STATE_SRC1		 (0x7L<<16)
-#define BNX2_EMAC_TXMAC_DEBUG4_PAUSE_STATE_CRC1		 (0x8L<<16)
-#define BNX2_EMAC_TXMAC_DEBUG4_PAUSE_STATE_CRC2		 (0x9L<<16)
-#define BNX2_EMAC_TXMAC_DEBUG4_PAUSE_STATE_TIME		 (0xaL<<16)
-#define BNX2_EMAC_TXMAC_DEBUG4_PAUSE_STATE_TYPE		 (0xcL<<16)
-#define BNX2_EMAC_TXMAC_DEBUG4_PAUSE_STATE_WAIT		 (0xdL<<16)
-#define BNX2_EMAC_TXMAC_DEBUG4_PAUSE_STATE_CMD		 (0xeL<<16)
-#define BNX2_EMAC_TXMAC_DEBUG4_STATS0_VALID		 (1L<<20)
-#define BNX2_EMAC_TXMAC_DEBUG4_APPEND_CRC		 (1L<<21)
-#define BNX2_EMAC_TXMAC_DEBUG4_SLOT_FILLED		 (1L<<22)
-#define BNX2_EMAC_TXMAC_DEBUG4_MAX_DEFER		 (1L<<23)
-#define BNX2_EMAC_TXMAC_DEBUG4_SEND_EXTEND		 (1L<<24)
-#define BNX2_EMAC_TXMAC_DEBUG4_SEND_PADDING		 (1L<<25)
-#define BNX2_EMAC_TXMAC_DEBUG4_EOF_LOC			 (1L<<26)
-#define BNX2_EMAC_TXMAC_DEBUG4_COLLIDING		 (1L<<27)
-#define BNX2_EMAC_TXMAC_DEBUG4_COL_IN			 (1L<<28)
-#define BNX2_EMAC_TXMAC_DEBUG4_BURSTING			 (1L<<29)
-#define BNX2_EMAC_TXMAC_DEBUG4_ADVANCE			 (1L<<30)
-#define BNX2_EMAC_TXMAC_DEBUG4_GO			 (1L<<31)
-
-#define BNX2_EMAC_TX_STAT_AC0				0x00001680
-#define BNX2_EMAC_TX_STAT_AC1				0x00001684
-#define BNX2_EMAC_TX_STAT_AC2				0x00001688
-#define BNX2_EMAC_TX_STAT_AC3				0x0000168c
-#define BNX2_EMAC_TX_STAT_AC4				0x00001690
-#define BNX2_EMAC_TX_STAT_AC5				0x00001694
-#define BNX2_EMAC_TX_STAT_AC6				0x00001698
-#define BNX2_EMAC_TX_STAT_AC7				0x0000169c
-#define BNX2_EMAC_TX_STAT_AC8				0x000016a0
-#define BNX2_EMAC_TX_STAT_AC9				0x000016a4
-#define BNX2_EMAC_TX_STAT_AC10				0x000016a8
-#define BNX2_EMAC_TX_STAT_AC11				0x000016ac
-#define BNX2_EMAC_TX_STAT_AC12				0x000016b0
-#define BNX2_EMAC_TX_STAT_AC13				0x000016b4
-#define BNX2_EMAC_TX_STAT_AC14				0x000016b8
-#define BNX2_EMAC_TX_STAT_AC15				0x000016bc
-#define BNX2_EMAC_TX_STAT_AC16				0x000016c0
-#define BNX2_EMAC_TX_STAT_AC17				0x000016c4
-#define BNX2_EMAC_TX_STAT_AC18				0x000016c8
-#define BNX2_EMAC_TX_STAT_AC19				0x000016cc
-#define BNX2_EMAC_TX_STAT_AC20				0x000016d0
-#define BNX2_EMAC_TXMAC_SUC_DBG_OVERRUNVEC		0x000016d8
-#define BNX2_EMAC_TX_RATE_LIMIT_CTRL			0x000016fc
-#define BNX2_EMAC_TX_RATE_LIMIT_CTRL_TX_THROTTLE_INC	 (0x7fL<<0)
-#define BNX2_EMAC_TX_RATE_LIMIT_CTRL_TX_THROTTLE_NUM	 (0x7fL<<16)
-#define BNX2_EMAC_TX_RATE_LIMIT_CTRL_RATE_LIMITER_EN	 (1L<<31)
-
-
-/*
- *  rpm_reg definition
- *  offset: 0x1800
- */
-#define BNX2_RPM_COMMAND				0x00001800
-#define BNX2_RPM_COMMAND_ENABLED			 (1L<<0)
-#define BNX2_RPM_COMMAND_OVERRUN_ABORT			 (1L<<4)
-
-#define BNX2_RPM_STATUS					0x00001804
-#define BNX2_RPM_STATUS_MBUF_WAIT			 (1L<<0)
-#define BNX2_RPM_STATUS_FREE_WAIT			 (1L<<1)
-
-#define BNX2_RPM_CONFIG					0x00001808
-#define BNX2_RPM_CONFIG_NO_PSD_HDR_CKSUM		 (1L<<0)
-#define BNX2_RPM_CONFIG_ACPI_ENA			 (1L<<1)
-#define BNX2_RPM_CONFIG_ACPI_KEEP			 (1L<<2)
-#define BNX2_RPM_CONFIG_MP_KEEP				 (1L<<3)
-#define BNX2_RPM_CONFIG_SORT_VECT_VAL			 (0xfL<<4)
-#define BNX2_RPM_CONFIG_DISABLE_WOL_ASSERT		 (1L<<30)
-#define BNX2_RPM_CONFIG_IGNORE_VLAN			 (1L<<31)
-
-#define BNX2_RPM_MGMT_PKT_CTRL				0x0000180c
-#define BNX2_RPM_MGMT_PKT_CTRL_MGMT_SORT		 (0xfL<<0)
-#define BNX2_RPM_MGMT_PKT_CTRL_MGMT_RULE		 (0xfL<<4)
-#define BNX2_RPM_MGMT_PKT_CTRL_MGMT_DISCARD_EN		 (1L<<30)
-#define BNX2_RPM_MGMT_PKT_CTRL_MGMT_EN			 (1L<<31)
-
-#define BNX2_RPM_VLAN_MATCH0				0x00001810
-#define BNX2_RPM_VLAN_MATCH0_RPM_VLAN_MTCH0_VALUE	 (0xfffL<<0)
-
-#define BNX2_RPM_VLAN_MATCH1				0x00001814
-#define BNX2_RPM_VLAN_MATCH1_RPM_VLAN_MTCH1_VALUE	 (0xfffL<<0)
-
-#define BNX2_RPM_VLAN_MATCH2				0x00001818
-#define BNX2_RPM_VLAN_MATCH2_RPM_VLAN_MTCH2_VALUE	 (0xfffL<<0)
-
-#define BNX2_RPM_VLAN_MATCH3				0x0000181c
-#define BNX2_RPM_VLAN_MATCH3_RPM_VLAN_MTCH3_VALUE	 (0xfffL<<0)
-
-#define BNX2_RPM_SORT_USER0				0x00001820
-#define BNX2_RPM_SORT_USER0_PM_EN			 (0xffffL<<0)
-#define BNX2_RPM_SORT_USER0_BC_EN			 (1L<<16)
-#define BNX2_RPM_SORT_USER0_MC_EN			 (1L<<17)
-#define BNX2_RPM_SORT_USER0_MC_HSH_EN			 (1L<<18)
-#define BNX2_RPM_SORT_USER0_PROM_EN			 (1L<<19)
-#define BNX2_RPM_SORT_USER0_VLAN_EN			 (0xfL<<20)
-#define BNX2_RPM_SORT_USER0_PROM_VLAN			 (1L<<24)
-#define BNX2_RPM_SORT_USER0_VLAN_NOTMATCH		 (1L<<25)
-#define BNX2_RPM_SORT_USER0_ENA				 (1L<<31)
-
-#define BNX2_RPM_SORT_USER1				0x00001824
-#define BNX2_RPM_SORT_USER1_PM_EN			 (0xffffL<<0)
-#define BNX2_RPM_SORT_USER1_BC_EN			 (1L<<16)
-#define BNX2_RPM_SORT_USER1_MC_EN			 (1L<<17)
-#define BNX2_RPM_SORT_USER1_MC_HSH_EN			 (1L<<18)
-#define BNX2_RPM_SORT_USER1_PROM_EN			 (1L<<19)
-#define BNX2_RPM_SORT_USER1_VLAN_EN			 (0xfL<<20)
-#define BNX2_RPM_SORT_USER1_PROM_VLAN			 (1L<<24)
-#define BNX2_RPM_SORT_USER1_ENA				 (1L<<31)
-
-#define BNX2_RPM_SORT_USER2				0x00001828
-#define BNX2_RPM_SORT_USER2_PM_EN			 (0xffffL<<0)
-#define BNX2_RPM_SORT_USER2_BC_EN			 (1L<<16)
-#define BNX2_RPM_SORT_USER2_MC_EN			 (1L<<17)
-#define BNX2_RPM_SORT_USER2_MC_HSH_EN			 (1L<<18)
-#define BNX2_RPM_SORT_USER2_PROM_EN			 (1L<<19)
-#define BNX2_RPM_SORT_USER2_VLAN_EN			 (0xfL<<20)
-#define BNX2_RPM_SORT_USER2_PROM_VLAN			 (1L<<24)
-#define BNX2_RPM_SORT_USER2_ENA				 (1L<<31)
-
-#define BNX2_RPM_SORT_USER3				0x0000182c
-#define BNX2_RPM_SORT_USER3_PM_EN			 (0xffffL<<0)
-#define BNX2_RPM_SORT_USER3_BC_EN			 (1L<<16)
-#define BNX2_RPM_SORT_USER3_MC_EN			 (1L<<17)
-#define BNX2_RPM_SORT_USER3_MC_HSH_EN			 (1L<<18)
-#define BNX2_RPM_SORT_USER3_PROM_EN			 (1L<<19)
-#define BNX2_RPM_SORT_USER3_VLAN_EN			 (0xfL<<20)
-#define BNX2_RPM_SORT_USER3_PROM_VLAN			 (1L<<24)
-#define BNX2_RPM_SORT_USER3_ENA				 (1L<<31)
-
-#define BNX2_RPM_STAT_L2_FILTER_DISCARDS		0x00001840
-#define BNX2_RPM_STAT_RULE_CHECKER_DISCARDS		0x00001844
-#define BNX2_RPM_STAT_IFINFTQDISCARDS			0x00001848
-#define BNX2_RPM_STAT_IFINMBUFDISCARD			0x0000184c
-#define BNX2_RPM_STAT_RULE_CHECKER_P4_HIT		0x00001850
-#define BNX2_RPM_IPV6_PROGRAMMABLE_EXTENSION0		0x00001854
-#define BNX2_RPM_IPV6_PROGRAMMABLE_EXTENSION0_NEXT_HEADER_LEN	 (0xffL<<0)
-#define BNX2_RPM_IPV6_PROGRAMMABLE_EXTENSION0_NEXT_HEADER	 (0xffL<<16)
-#define BNX2_RPM_IPV6_PROGRAMMABLE_EXTENSION0_NEXT_HEADER_LEN_TYPE	 (1L<<30)
-#define BNX2_RPM_IPV6_PROGRAMMABLE_EXTENSION0_NEXT_HEADER_EN	 (1L<<31)
-
-#define BNX2_RPM_IPV6_PROGRAMMABLE_EXTENSION1		0x00001858
-#define BNX2_RPM_IPV6_PROGRAMMABLE_EXTENSION1_NEXT_HEADER_LEN	 (0xffL<<0)
-#define BNX2_RPM_IPV6_PROGRAMMABLE_EXTENSION1_NEXT_HEADER	 (0xffL<<16)
-#define BNX2_RPM_IPV6_PROGRAMMABLE_EXTENSION1_NEXT_HEADER_LEN_TYPE	 (1L<<30)
-#define BNX2_RPM_IPV6_PROGRAMMABLE_EXTENSION1_NEXT_HEADER_EN	 (1L<<31)
-
-#define BNX2_RPM_IPV6_PROGRAMMABLE_EXTENSION2		0x0000185c
-#define BNX2_RPM_IPV6_PROGRAMMABLE_EXTENSION2_NEXT_HEADER_LEN	 (0xffL<<0)
-#define BNX2_RPM_IPV6_PROGRAMMABLE_EXTENSION2_NEXT_HEADER	 (0xffL<<16)
-#define BNX2_RPM_IPV6_PROGRAMMABLE_EXTENSION2_NEXT_HEADER_LEN_TYPE	 (1L<<30)
-#define BNX2_RPM_IPV6_PROGRAMMABLE_EXTENSION2_NEXT_HEADER_EN	 (1L<<31)
-
-#define BNX2_RPM_IPV6_PROGRAMMABLE_EXTENSION3		0x00001860
-#define BNX2_RPM_IPV6_PROGRAMMABLE_EXTENSION3_NEXT_HEADER_LEN	 (0xffL<<0)
-#define BNX2_RPM_IPV6_PROGRAMMABLE_EXTENSION3_NEXT_HEADER	 (0xffL<<16)
-#define BNX2_RPM_IPV6_PROGRAMMABLE_EXTENSION3_NEXT_HEADER_LEN_TYPE	 (1L<<30)
-#define BNX2_RPM_IPV6_PROGRAMMABLE_EXTENSION3_NEXT_HEADER_EN	 (1L<<31)
-
-#define BNX2_RPM_IPV6_PROGRAMMABLE_EXTENSION4		0x00001864
-#define BNX2_RPM_IPV6_PROGRAMMABLE_EXTENSION4_NEXT_HEADER_LEN	 (0xffL<<0)
-#define BNX2_RPM_IPV6_PROGRAMMABLE_EXTENSION4_NEXT_HEADER	 (0xffL<<16)
-#define BNX2_RPM_IPV6_PROGRAMMABLE_EXTENSION4_NEXT_HEADER_LEN_TYPE	 (1L<<30)
-#define BNX2_RPM_IPV6_PROGRAMMABLE_EXTENSION4_NEXT_HEADER_EN	 (1L<<31)
-
-#define BNX2_RPM_IPV6_PROGRAMMABLE_EXTENSION5		0x00001868
-#define BNX2_RPM_IPV6_PROGRAMMABLE_EXTENSION5_NEXT_HEADER_LEN	 (0xffL<<0)
-#define BNX2_RPM_IPV6_PROGRAMMABLE_EXTENSION5_NEXT_HEADER	 (0xffL<<16)
-#define BNX2_RPM_IPV6_PROGRAMMABLE_EXTENSION5_NEXT_HEADER_LEN_TYPE	 (1L<<30)
-#define BNX2_RPM_IPV6_PROGRAMMABLE_EXTENSION5_NEXT_HEADER_EN	 (1L<<31)
-
-#define BNX2_RPM_IPV6_PROGRAMMABLE_EXTENSION6		0x0000186c
-#define BNX2_RPM_IPV6_PROGRAMMABLE_EXTENSION6_NEXT_HEADER_LEN	 (0xffL<<0)
-#define BNX2_RPM_IPV6_PROGRAMMABLE_EXTENSION6_NEXT_HEADER	 (0xffL<<16)
-#define BNX2_RPM_IPV6_PROGRAMMABLE_EXTENSION6_NEXT_HEADER_LEN_TYPE	 (1L<<30)
-#define BNX2_RPM_IPV6_PROGRAMMABLE_EXTENSION6_NEXT_HEADER_EN	 (1L<<31)
-
-#define BNX2_RPM_IPV6_PROGRAMMABLE_EXTENSION7		0x00001870
-#define BNX2_RPM_IPV6_PROGRAMMABLE_EXTENSION7_NEXT_HEADER_LEN	 (0xffL<<0)
-#define BNX2_RPM_IPV6_PROGRAMMABLE_EXTENSION7_NEXT_HEADER	 (0xffL<<16)
-#define BNX2_RPM_IPV6_PROGRAMMABLE_EXTENSION7_NEXT_HEADER_LEN_TYPE	 (1L<<30)
-#define BNX2_RPM_IPV6_PROGRAMMABLE_EXTENSION7_NEXT_HEADER_EN	 (1L<<31)
-
-#define BNX2_RPM_STAT_AC0				0x00001880
-#define BNX2_RPM_STAT_AC1				0x00001884
-#define BNX2_RPM_STAT_AC2				0x00001888
-#define BNX2_RPM_STAT_AC3				0x0000188c
-#define BNX2_RPM_STAT_AC4				0x00001890
-#define BNX2_RPM_RC_CNTL_16				0x000018e0
-#define BNX2_RPM_RC_CNTL_16_OFFSET			 (0xffL<<0)
-#define BNX2_RPM_RC_CNTL_16_CLASS			 (0x7L<<8)
-#define BNX2_RPM_RC_CNTL_16_PRIORITY			 (1L<<11)
-#define BNX2_RPM_RC_CNTL_16_P4				 (1L<<12)
-#define BNX2_RPM_RC_CNTL_16_HDR_TYPE			 (0x7L<<13)
-#define BNX2_RPM_RC_CNTL_16_HDR_TYPE_START		 (0L<<13)
-#define BNX2_RPM_RC_CNTL_16_HDR_TYPE_IP			 (1L<<13)
-#define BNX2_RPM_RC_CNTL_16_HDR_TYPE_TCP		 (2L<<13)
-#define BNX2_RPM_RC_CNTL_16_HDR_TYPE_UDP		 (3L<<13)
-#define BNX2_RPM_RC_CNTL_16_HDR_TYPE_DATA		 (4L<<13)
-#define BNX2_RPM_RC_CNTL_16_HDR_TYPE_TCP_UDP		 (5L<<13)
-#define BNX2_RPM_RC_CNTL_16_HDR_TYPE_ICMPV6		 (6L<<13)
-#define BNX2_RPM_RC_CNTL_16_COMP			 (0x3L<<16)
-#define BNX2_RPM_RC_CNTL_16_COMP_EQUAL			 (0L<<16)
-#define BNX2_RPM_RC_CNTL_16_COMP_NEQUAL			 (1L<<16)
-#define BNX2_RPM_RC_CNTL_16_COMP_GREATER		 (2L<<16)
-#define BNX2_RPM_RC_CNTL_16_COMP_LESS			 (3L<<16)
-#define BNX2_RPM_RC_CNTL_16_MAP				 (1L<<18)
-#define BNX2_RPM_RC_CNTL_16_SBIT			 (1L<<19)
-#define BNX2_RPM_RC_CNTL_16_CMDSEL			 (0x1fL<<20)
-#define BNX2_RPM_RC_CNTL_16_DISCARD			 (1L<<25)
-#define BNX2_RPM_RC_CNTL_16_MASK			 (1L<<26)
-#define BNX2_RPM_RC_CNTL_16_P1				 (1L<<27)
-#define BNX2_RPM_RC_CNTL_16_P2				 (1L<<28)
-#define BNX2_RPM_RC_CNTL_16_P3				 (1L<<29)
-#define BNX2_RPM_RC_CNTL_16_NBIT			 (1L<<30)
-
-#define BNX2_RPM_RC_VALUE_MASK_16			0x000018e4
-#define BNX2_RPM_RC_VALUE_MASK_16_VALUE			 (0xffffL<<0)
-#define BNX2_RPM_RC_VALUE_MASK_16_MASK			 (0xffffL<<16)
-
-#define BNX2_RPM_RC_CNTL_17				0x000018e8
-#define BNX2_RPM_RC_CNTL_17_OFFSET			 (0xffL<<0)
-#define BNX2_RPM_RC_CNTL_17_CLASS			 (0x7L<<8)
-#define BNX2_RPM_RC_CNTL_17_PRIORITY			 (1L<<11)
-#define BNX2_RPM_RC_CNTL_17_P4				 (1L<<12)
-#define BNX2_RPM_RC_CNTL_17_HDR_TYPE			 (0x7L<<13)
-#define BNX2_RPM_RC_CNTL_17_HDR_TYPE_START		 (0L<<13)
-#define BNX2_RPM_RC_CNTL_17_HDR_TYPE_IP			 (1L<<13)
-#define BNX2_RPM_RC_CNTL_17_HDR_TYPE_TCP		 (2L<<13)
-#define BNX2_RPM_RC_CNTL_17_HDR_TYPE_UDP		 (3L<<13)
-#define BNX2_RPM_RC_CNTL_17_HDR_TYPE_DATA		 (4L<<13)
-#define BNX2_RPM_RC_CNTL_17_HDR_TYPE_TCP_UDP		 (5L<<13)
-#define BNX2_RPM_RC_CNTL_17_HDR_TYPE_ICMPV6		 (6L<<13)
-#define BNX2_RPM_RC_CNTL_17_COMP			 (0x3L<<16)
-#define BNX2_RPM_RC_CNTL_17_COMP_EQUAL			 (0L<<16)
-#define BNX2_RPM_RC_CNTL_17_COMP_NEQUAL			 (1L<<16)
-#define BNX2_RPM_RC_CNTL_17_COMP_GREATER		 (2L<<16)
-#define BNX2_RPM_RC_CNTL_17_COMP_LESS			 (3L<<16)
-#define BNX2_RPM_RC_CNTL_17_MAP				 (1L<<18)
-#define BNX2_RPM_RC_CNTL_17_SBIT			 (1L<<19)
-#define BNX2_RPM_RC_CNTL_17_CMDSEL			 (0x1fL<<20)
-#define BNX2_RPM_RC_CNTL_17_DISCARD			 (1L<<25)
-#define BNX2_RPM_RC_CNTL_17_MASK			 (1L<<26)
-#define BNX2_RPM_RC_CNTL_17_P1				 (1L<<27)
-#define BNX2_RPM_RC_CNTL_17_P2				 (1L<<28)
-#define BNX2_RPM_RC_CNTL_17_P3				 (1L<<29)
-#define BNX2_RPM_RC_CNTL_17_NBIT			 (1L<<30)
-
-#define BNX2_RPM_RC_VALUE_MASK_17			0x000018ec
-#define BNX2_RPM_RC_VALUE_MASK_17_VALUE			 (0xffffL<<0)
-#define BNX2_RPM_RC_VALUE_MASK_17_MASK			 (0xffffL<<16)
-
-#define BNX2_RPM_RC_CNTL_18				0x000018f0
-#define BNX2_RPM_RC_CNTL_18_OFFSET			 (0xffL<<0)
-#define BNX2_RPM_RC_CNTL_18_CLASS			 (0x7L<<8)
-#define BNX2_RPM_RC_CNTL_18_PRIORITY			 (1L<<11)
-#define BNX2_RPM_RC_CNTL_18_P4				 (1L<<12)
-#define BNX2_RPM_RC_CNTL_18_HDR_TYPE			 (0x7L<<13)
-#define BNX2_RPM_RC_CNTL_18_HDR_TYPE_START		 (0L<<13)
-#define BNX2_RPM_RC_CNTL_18_HDR_TYPE_IP			 (1L<<13)
-#define BNX2_RPM_RC_CNTL_18_HDR_TYPE_TCP		 (2L<<13)
-#define BNX2_RPM_RC_CNTL_18_HDR_TYPE_UDP		 (3L<<13)
-#define BNX2_RPM_RC_CNTL_18_HDR_TYPE_DATA		 (4L<<13)
-#define BNX2_RPM_RC_CNTL_18_HDR_TYPE_TCP_UDP		 (5L<<13)
-#define BNX2_RPM_RC_CNTL_18_HDR_TYPE_ICMPV6		 (6L<<13)
-#define BNX2_RPM_RC_CNTL_18_COMP			 (0x3L<<16)
-#define BNX2_RPM_RC_CNTL_18_COMP_EQUAL			 (0L<<16)
-#define BNX2_RPM_RC_CNTL_18_COMP_NEQUAL			 (1L<<16)
-#define BNX2_RPM_RC_CNTL_18_COMP_GREATER		 (2L<<16)
-#define BNX2_RPM_RC_CNTL_18_COMP_LESS			 (3L<<16)
-#define BNX2_RPM_RC_CNTL_18_MAP				 (1L<<18)
-#define BNX2_RPM_RC_CNTL_18_SBIT			 (1L<<19)
-#define BNX2_RPM_RC_CNTL_18_CMDSEL			 (0x1fL<<20)
-#define BNX2_RPM_RC_CNTL_18_DISCARD			 (1L<<25)
-#define BNX2_RPM_RC_CNTL_18_MASK			 (1L<<26)
-#define BNX2_RPM_RC_CNTL_18_P1				 (1L<<27)
-#define BNX2_RPM_RC_CNTL_18_P2				 (1L<<28)
-#define BNX2_RPM_RC_CNTL_18_P3				 (1L<<29)
-#define BNX2_RPM_RC_CNTL_18_NBIT			 (1L<<30)
-
-#define BNX2_RPM_RC_VALUE_MASK_18			0x000018f4
-#define BNX2_RPM_RC_VALUE_MASK_18_VALUE			 (0xffffL<<0)
-#define BNX2_RPM_RC_VALUE_MASK_18_MASK			 (0xffffL<<16)
-
-#define BNX2_RPM_RC_CNTL_19				0x000018f8
-#define BNX2_RPM_RC_CNTL_19_OFFSET			 (0xffL<<0)
-#define BNX2_RPM_RC_CNTL_19_CLASS			 (0x7L<<8)
-#define BNX2_RPM_RC_CNTL_19_PRIORITY			 (1L<<11)
-#define BNX2_RPM_RC_CNTL_19_P4				 (1L<<12)
-#define BNX2_RPM_RC_CNTL_19_HDR_TYPE			 (0x7L<<13)
-#define BNX2_RPM_RC_CNTL_19_HDR_TYPE_START		 (0L<<13)
-#define BNX2_RPM_RC_CNTL_19_HDR_TYPE_IP			 (1L<<13)
-#define BNX2_RPM_RC_CNTL_19_HDR_TYPE_TCP		 (2L<<13)
-#define BNX2_RPM_RC_CNTL_19_HDR_TYPE_UDP		 (3L<<13)
-#define BNX2_RPM_RC_CNTL_19_HDR_TYPE_DATA		 (4L<<13)
-#define BNX2_RPM_RC_CNTL_19_HDR_TYPE_TCP_UDP		 (5L<<13)
-#define BNX2_RPM_RC_CNTL_19_HDR_TYPE_ICMPV6		 (6L<<13)
-#define BNX2_RPM_RC_CNTL_19_COMP			 (0x3L<<16)
-#define BNX2_RPM_RC_CNTL_19_COMP_EQUAL			 (0L<<16)
-#define BNX2_RPM_RC_CNTL_19_COMP_NEQUAL			 (1L<<16)
-#define BNX2_RPM_RC_CNTL_19_COMP_GREATER		 (2L<<16)
-#define BNX2_RPM_RC_CNTL_19_COMP_LESS			 (3L<<16)
-#define BNX2_RPM_RC_CNTL_19_MAP				 (1L<<18)
-#define BNX2_RPM_RC_CNTL_19_SBIT			 (1L<<19)
-#define BNX2_RPM_RC_CNTL_19_CMDSEL			 (0x1fL<<20)
-#define BNX2_RPM_RC_CNTL_19_DISCARD			 (1L<<25)
-#define BNX2_RPM_RC_CNTL_19_MASK			 (1L<<26)
-#define BNX2_RPM_RC_CNTL_19_P1				 (1L<<27)
-#define BNX2_RPM_RC_CNTL_19_P2				 (1L<<28)
-#define BNX2_RPM_RC_CNTL_19_P3				 (1L<<29)
-#define BNX2_RPM_RC_CNTL_19_NBIT			 (1L<<30)
-
-#define BNX2_RPM_RC_VALUE_MASK_19			0x000018fc
-#define BNX2_RPM_RC_VALUE_MASK_19_VALUE			 (0xffffL<<0)
-#define BNX2_RPM_RC_VALUE_MASK_19_MASK			 (0xffffL<<16)
-
-#define BNX2_RPM_RC_CNTL_0				0x00001900
-#define BNX2_RPM_RC_CNTL_0_OFFSET			 (0xffL<<0)
-#define BNX2_RPM_RC_CNTL_0_CLASS			 (0x7L<<8)
-#define BNX2_RPM_RC_CNTL_0_PRIORITY			 (1L<<11)
-#define BNX2_RPM_RC_CNTL_0_P4				 (1L<<12)
-#define BNX2_RPM_RC_CNTL_0_HDR_TYPE			 (0x7L<<13)
-#define BNX2_RPM_RC_CNTL_0_HDR_TYPE_START		 (0L<<13)
-#define BNX2_RPM_RC_CNTL_0_HDR_TYPE_IP			 (1L<<13)
-#define BNX2_RPM_RC_CNTL_0_HDR_TYPE_TCP			 (2L<<13)
-#define BNX2_RPM_RC_CNTL_0_HDR_TYPE_UDP			 (3L<<13)
-#define BNX2_RPM_RC_CNTL_0_HDR_TYPE_DATA		 (4L<<13)
-#define BNX2_RPM_RC_CNTL_0_HDR_TYPE_TCP_UDP		 (5L<<13)
-#define BNX2_RPM_RC_CNTL_0_HDR_TYPE_ICMPV6		 (6L<<13)
-#define BNX2_RPM_RC_CNTL_0_COMP				 (0x3L<<16)
-#define BNX2_RPM_RC_CNTL_0_COMP_EQUAL			 (0L<<16)
-#define BNX2_RPM_RC_CNTL_0_COMP_NEQUAL			 (1L<<16)
-#define BNX2_RPM_RC_CNTL_0_COMP_GREATER			 (2L<<16)
-#define BNX2_RPM_RC_CNTL_0_COMP_LESS			 (3L<<16)
-#define BNX2_RPM_RC_CNTL_0_MAP_XI			 (1L<<18)
-#define BNX2_RPM_RC_CNTL_0_SBIT				 (1L<<19)
-#define BNX2_RPM_RC_CNTL_0_CMDSEL			 (0xfL<<20)
-#define BNX2_RPM_RC_CNTL_0_MAP				 (1L<<24)
-#define BNX2_RPM_RC_CNTL_0_CMDSEL_XI			 (0x1fL<<20)
-#define BNX2_RPM_RC_CNTL_0_DISCARD			 (1L<<25)
-#define BNX2_RPM_RC_CNTL_0_MASK				 (1L<<26)
-#define BNX2_RPM_RC_CNTL_0_P1				 (1L<<27)
-#define BNX2_RPM_RC_CNTL_0_P2				 (1L<<28)
-#define BNX2_RPM_RC_CNTL_0_P3				 (1L<<29)
-#define BNX2_RPM_RC_CNTL_0_NBIT				 (1L<<30)
-
-#define BNX2_RPM_RC_VALUE_MASK_0			0x00001904
-#define BNX2_RPM_RC_VALUE_MASK_0_VALUE			 (0xffffL<<0)
-#define BNX2_RPM_RC_VALUE_MASK_0_MASK			 (0xffffL<<16)
-
-#define BNX2_RPM_RC_CNTL_1				0x00001908
-#define BNX2_RPM_RC_CNTL_1_A				 (0x3ffffL<<0)
-#define BNX2_RPM_RC_CNTL_1_B				 (0xfffL<<19)
-#define BNX2_RPM_RC_CNTL_1_OFFSET_XI			 (0xffL<<0)
-#define BNX2_RPM_RC_CNTL_1_CLASS_XI			 (0x7L<<8)
-#define BNX2_RPM_RC_CNTL_1_PRIORITY_XI			 (1L<<11)
-#define BNX2_RPM_RC_CNTL_1_P4_XI			 (1L<<12)
-#define BNX2_RPM_RC_CNTL_1_HDR_TYPE_XI			 (0x7L<<13)
-#define BNX2_RPM_RC_CNTL_1_HDR_TYPE_START_XI		 (0L<<13)
-#define BNX2_RPM_RC_CNTL_1_HDR_TYPE_IP_XI		 (1L<<13)
-#define BNX2_RPM_RC_CNTL_1_HDR_TYPE_TCP_XI		 (2L<<13)
-#define BNX2_RPM_RC_CNTL_1_HDR_TYPE_UDP_XI		 (3L<<13)
-#define BNX2_RPM_RC_CNTL_1_HDR_TYPE_DATA_XI		 (4L<<13)
-#define BNX2_RPM_RC_CNTL_1_HDR_TYPE_TCP_UDP_XI		 (5L<<13)
-#define BNX2_RPM_RC_CNTL_1_HDR_TYPE_ICMPV6_XI		 (6L<<13)
-#define BNX2_RPM_RC_CNTL_1_COMP_XI			 (0x3L<<16)
-#define BNX2_RPM_RC_CNTL_1_COMP_EQUAL_XI		 (0L<<16)
-#define BNX2_RPM_RC_CNTL_1_COMP_NEQUAL_XI		 (1L<<16)
-#define BNX2_RPM_RC_CNTL_1_COMP_GREATER_XI		 (2L<<16)
-#define BNX2_RPM_RC_CNTL_1_COMP_LESS_XI			 (3L<<16)
-#define BNX2_RPM_RC_CNTL_1_MAP_XI			 (1L<<18)
-#define BNX2_RPM_RC_CNTL_1_SBIT_XI			 (1L<<19)
-#define BNX2_RPM_RC_CNTL_1_CMDSEL_XI			 (0x1fL<<20)
-#define BNX2_RPM_RC_CNTL_1_DISCARD_XI			 (1L<<25)
-#define BNX2_RPM_RC_CNTL_1_MASK_XI			 (1L<<26)
-#define BNX2_RPM_RC_CNTL_1_P1_XI			 (1L<<27)
-#define BNX2_RPM_RC_CNTL_1_P2_XI			 (1L<<28)
-#define BNX2_RPM_RC_CNTL_1_P3_XI			 (1L<<29)
-#define BNX2_RPM_RC_CNTL_1_NBIT_XI			 (1L<<30)
-
-#define BNX2_RPM_RC_VALUE_MASK_1			0x0000190c
-#define BNX2_RPM_RC_VALUE_MASK_1_VALUE			 (0xffffL<<0)
-#define BNX2_RPM_RC_VALUE_MASK_1_MASK			 (0xffffL<<16)
-
-#define BNX2_RPM_RC_CNTL_2				0x00001910
-#define BNX2_RPM_RC_CNTL_2_A				 (0x3ffffL<<0)
-#define BNX2_RPM_RC_CNTL_2_B				 (0xfffL<<19)
-#define BNX2_RPM_RC_CNTL_2_OFFSET_XI			 (0xffL<<0)
-#define BNX2_RPM_RC_CNTL_2_CLASS_XI			 (0x7L<<8)
-#define BNX2_RPM_RC_CNTL_2_PRIORITY_XI			 (1L<<11)
-#define BNX2_RPM_RC_CNTL_2_P4_XI			 (1L<<12)
-#define BNX2_RPM_RC_CNTL_2_HDR_TYPE_XI			 (0x7L<<13)
-#define BNX2_RPM_RC_CNTL_2_HDR_TYPE_START_XI		 (0L<<13)
-#define BNX2_RPM_RC_CNTL_2_HDR_TYPE_IP_XI		 (1L<<13)
-#define BNX2_RPM_RC_CNTL_2_HDR_TYPE_TCP_XI		 (2L<<13)
-#define BNX2_RPM_RC_CNTL_2_HDR_TYPE_UDP_XI		 (3L<<13)
-#define BNX2_RPM_RC_CNTL_2_HDR_TYPE_DATA_XI		 (4L<<13)
-#define BNX2_RPM_RC_CNTL_2_HDR_TYPE_TCP_UDP_XI		 (5L<<13)
-#define BNX2_RPM_RC_CNTL_2_HDR_TYPE_ICMPV6_XI		 (6L<<13)
-#define BNX2_RPM_RC_CNTL_2_COMP_XI			 (0x3L<<16)
-#define BNX2_RPM_RC_CNTL_2_COMP_EQUAL_XI		 (0L<<16)
-#define BNX2_RPM_RC_CNTL_2_COMP_NEQUAL_XI		 (1L<<16)
-#define BNX2_RPM_RC_CNTL_2_COMP_GREATER_XI		 (2L<<16)
-#define BNX2_RPM_RC_CNTL_2_COMP_LESS_XI			 (3L<<16)
-#define BNX2_RPM_RC_CNTL_2_MAP_XI			 (1L<<18)
-#define BNX2_RPM_RC_CNTL_2_SBIT_XI			 (1L<<19)
-#define BNX2_RPM_RC_CNTL_2_CMDSEL_XI			 (0x1fL<<20)
-#define BNX2_RPM_RC_CNTL_2_DISCARD_XI			 (1L<<25)
-#define BNX2_RPM_RC_CNTL_2_MASK_XI			 (1L<<26)
-#define BNX2_RPM_RC_CNTL_2_P1_XI			 (1L<<27)
-#define BNX2_RPM_RC_CNTL_2_P2_XI			 (1L<<28)
-#define BNX2_RPM_RC_CNTL_2_P3_XI			 (1L<<29)
-#define BNX2_RPM_RC_CNTL_2_NBIT_XI			 (1L<<30)
-
-#define BNX2_RPM_RC_VALUE_MASK_2			0x00001914
-#define BNX2_RPM_RC_VALUE_MASK_2_VALUE			 (0xffffL<<0)
-#define BNX2_RPM_RC_VALUE_MASK_2_MASK			 (0xffffL<<16)
-
-#define BNX2_RPM_RC_CNTL_3				0x00001918
-#define BNX2_RPM_RC_CNTL_3_A				 (0x3ffffL<<0)
-#define BNX2_RPM_RC_CNTL_3_B				 (0xfffL<<19)
-#define BNX2_RPM_RC_CNTL_3_OFFSET_XI			 (0xffL<<0)
-#define BNX2_RPM_RC_CNTL_3_CLASS_XI			 (0x7L<<8)
-#define BNX2_RPM_RC_CNTL_3_PRIORITY_XI			 (1L<<11)
-#define BNX2_RPM_RC_CNTL_3_P4_XI			 (1L<<12)
-#define BNX2_RPM_RC_CNTL_3_HDR_TYPE_XI			 (0x7L<<13)
-#define BNX2_RPM_RC_CNTL_3_HDR_TYPE_START_XI		 (0L<<13)
-#define BNX2_RPM_RC_CNTL_3_HDR_TYPE_IP_XI		 (1L<<13)
-#define BNX2_RPM_RC_CNTL_3_HDR_TYPE_TCP_XI		 (2L<<13)
-#define BNX2_RPM_RC_CNTL_3_HDR_TYPE_UDP_XI		 (3L<<13)
-#define BNX2_RPM_RC_CNTL_3_HDR_TYPE_DATA_XI		 (4L<<13)
-#define BNX2_RPM_RC_CNTL_3_HDR_TYPE_TCP_UDP_XI		 (5L<<13)
-#define BNX2_RPM_RC_CNTL_3_HDR_TYPE_ICMPV6_XI		 (6L<<13)
-#define BNX2_RPM_RC_CNTL_3_COMP_XI			 (0x3L<<16)
-#define BNX2_RPM_RC_CNTL_3_COMP_EQUAL_XI		 (0L<<16)
-#define BNX2_RPM_RC_CNTL_3_COMP_NEQUAL_XI		 (1L<<16)
-#define BNX2_RPM_RC_CNTL_3_COMP_GREATER_XI		 (2L<<16)
-#define BNX2_RPM_RC_CNTL_3_COMP_LESS_XI			 (3L<<16)
-#define BNX2_RPM_RC_CNTL_3_MAP_XI			 (1L<<18)
-#define BNX2_RPM_RC_CNTL_3_SBIT_XI			 (1L<<19)
-#define BNX2_RPM_RC_CNTL_3_CMDSEL_XI			 (0x1fL<<20)
-#define BNX2_RPM_RC_CNTL_3_DISCARD_XI			 (1L<<25)
-#define BNX2_RPM_RC_CNTL_3_MASK_XI			 (1L<<26)
-#define BNX2_RPM_RC_CNTL_3_P1_XI			 (1L<<27)
-#define BNX2_RPM_RC_CNTL_3_P2_XI			 (1L<<28)
-#define BNX2_RPM_RC_CNTL_3_P3_XI			 (1L<<29)
-#define BNX2_RPM_RC_CNTL_3_NBIT_XI			 (1L<<30)
-
-#define BNX2_RPM_RC_VALUE_MASK_3			0x0000191c
-#define BNX2_RPM_RC_VALUE_MASK_3_VALUE			 (0xffffL<<0)
-#define BNX2_RPM_RC_VALUE_MASK_3_MASK			 (0xffffL<<16)
-
-#define BNX2_RPM_RC_CNTL_4				0x00001920
-#define BNX2_RPM_RC_CNTL_4_A				 (0x3ffffL<<0)
-#define BNX2_RPM_RC_CNTL_4_B				 (0xfffL<<19)
-#define BNX2_RPM_RC_CNTL_4_OFFSET_XI			 (0xffL<<0)
-#define BNX2_RPM_RC_CNTL_4_CLASS_XI			 (0x7L<<8)
-#define BNX2_RPM_RC_CNTL_4_PRIORITY_XI			 (1L<<11)
-#define BNX2_RPM_RC_CNTL_4_P4_XI			 (1L<<12)
-#define BNX2_RPM_RC_CNTL_4_HDR_TYPE_XI			 (0x7L<<13)
-#define BNX2_RPM_RC_CNTL_4_HDR_TYPE_START_XI		 (0L<<13)
-#define BNX2_RPM_RC_CNTL_4_HDR_TYPE_IP_XI		 (1L<<13)
-#define BNX2_RPM_RC_CNTL_4_HDR_TYPE_TCP_XI		 (2L<<13)
-#define BNX2_RPM_RC_CNTL_4_HDR_TYPE_UDP_XI		 (3L<<13)
-#define BNX2_RPM_RC_CNTL_4_HDR_TYPE_DATA_XI		 (4L<<13)
-#define BNX2_RPM_RC_CNTL_4_HDR_TYPE_TCP_UDP_XI		 (5L<<13)
-#define BNX2_RPM_RC_CNTL_4_HDR_TYPE_ICMPV6_XI		 (6L<<13)
-#define BNX2_RPM_RC_CNTL_4_COMP_XI			 (0x3L<<16)
-#define BNX2_RPM_RC_CNTL_4_COMP_EQUAL_XI		 (0L<<16)
-#define BNX2_RPM_RC_CNTL_4_COMP_NEQUAL_XI		 (1L<<16)
-#define BNX2_RPM_RC_CNTL_4_COMP_GREATER_XI		 (2L<<16)
-#define BNX2_RPM_RC_CNTL_4_COMP_LESS_XI			 (3L<<16)
-#define BNX2_RPM_RC_CNTL_4_MAP_XI			 (1L<<18)
-#define BNX2_RPM_RC_CNTL_4_SBIT_XI			 (1L<<19)
-#define BNX2_RPM_RC_CNTL_4_CMDSEL_XI			 (0x1fL<<20)
-#define BNX2_RPM_RC_CNTL_4_DISCARD_XI			 (1L<<25)
-#define BNX2_RPM_RC_CNTL_4_MASK_XI			 (1L<<26)
-#define BNX2_RPM_RC_CNTL_4_P1_XI			 (1L<<27)
-#define BNX2_RPM_RC_CNTL_4_P2_XI			 (1L<<28)
-#define BNX2_RPM_RC_CNTL_4_P3_XI			 (1L<<29)
-#define BNX2_RPM_RC_CNTL_4_NBIT_XI			 (1L<<30)
-
-#define BNX2_RPM_RC_VALUE_MASK_4			0x00001924
-#define BNX2_RPM_RC_VALUE_MASK_4_VALUE			 (0xffffL<<0)
-#define BNX2_RPM_RC_VALUE_MASK_4_MASK			 (0xffffL<<16)
-
-#define BNX2_RPM_RC_CNTL_5				0x00001928
-#define BNX2_RPM_RC_CNTL_5_A				 (0x3ffffL<<0)
-#define BNX2_RPM_RC_CNTL_5_B				 (0xfffL<<19)
-#define BNX2_RPM_RC_CNTL_5_OFFSET_XI			 (0xffL<<0)
-#define BNX2_RPM_RC_CNTL_5_CLASS_XI			 (0x7L<<8)
-#define BNX2_RPM_RC_CNTL_5_PRIORITY_XI			 (1L<<11)
-#define BNX2_RPM_RC_CNTL_5_P4_XI			 (1L<<12)
-#define BNX2_RPM_RC_CNTL_5_HDR_TYPE_XI			 (0x7L<<13)
-#define BNX2_RPM_RC_CNTL_5_HDR_TYPE_START_XI		 (0L<<13)
-#define BNX2_RPM_RC_CNTL_5_HDR_TYPE_IP_XI		 (1L<<13)
-#define BNX2_RPM_RC_CNTL_5_HDR_TYPE_TCP_XI		 (2L<<13)
-#define BNX2_RPM_RC_CNTL_5_HDR_TYPE_UDP_XI		 (3L<<13)
-#define BNX2_RPM_RC_CNTL_5_HDR_TYPE_DATA_XI		 (4L<<13)
-#define BNX2_RPM_RC_CNTL_5_HDR_TYPE_TCP_UDP_XI		 (5L<<13)
-#define BNX2_RPM_RC_CNTL_5_HDR_TYPE_ICMPV6_XI		 (6L<<13)
-#define BNX2_RPM_RC_CNTL_5_COMP_XI			 (0x3L<<16)
-#define BNX2_RPM_RC_CNTL_5_COMP_EQUAL_XI		 (0L<<16)
-#define BNX2_RPM_RC_CNTL_5_COMP_NEQUAL_XI		 (1L<<16)
-#define BNX2_RPM_RC_CNTL_5_COMP_GREATER_XI		 (2L<<16)
-#define BNX2_RPM_RC_CNTL_5_COMP_LESS_XI			 (3L<<16)
-#define BNX2_RPM_RC_CNTL_5_MAP_XI			 (1L<<18)
-#define BNX2_RPM_RC_CNTL_5_SBIT_XI			 (1L<<19)
-#define BNX2_RPM_RC_CNTL_5_CMDSEL_XI			 (0x1fL<<20)
-#define BNX2_RPM_RC_CNTL_5_DISCARD_XI			 (1L<<25)
-#define BNX2_RPM_RC_CNTL_5_MASK_XI			 (1L<<26)
-#define BNX2_RPM_RC_CNTL_5_P1_XI			 (1L<<27)
-#define BNX2_RPM_RC_CNTL_5_P2_XI			 (1L<<28)
-#define BNX2_RPM_RC_CNTL_5_P3_XI			 (1L<<29)
-#define BNX2_RPM_RC_CNTL_5_NBIT_XI			 (1L<<30)
-
-#define BNX2_RPM_RC_VALUE_MASK_5			0x0000192c
-#define BNX2_RPM_RC_VALUE_MASK_5_VALUE			 (0xffffL<<0)
-#define BNX2_RPM_RC_VALUE_MASK_5_MASK			 (0xffffL<<16)
-
-#define BNX2_RPM_RC_CNTL_6				0x00001930
-#define BNX2_RPM_RC_CNTL_6_A				 (0x3ffffL<<0)
-#define BNX2_RPM_RC_CNTL_6_B				 (0xfffL<<19)
-#define BNX2_RPM_RC_CNTL_6_OFFSET_XI			 (0xffL<<0)
-#define BNX2_RPM_RC_CNTL_6_CLASS_XI			 (0x7L<<8)
-#define BNX2_RPM_RC_CNTL_6_PRIORITY_XI			 (1L<<11)
-#define BNX2_RPM_RC_CNTL_6_P4_XI			 (1L<<12)
-#define BNX2_RPM_RC_CNTL_6_HDR_TYPE_XI			 (0x7L<<13)
-#define BNX2_RPM_RC_CNTL_6_HDR_TYPE_START_XI		 (0L<<13)
-#define BNX2_RPM_RC_CNTL_6_HDR_TYPE_IP_XI		 (1L<<13)
-#define BNX2_RPM_RC_CNTL_6_HDR_TYPE_TCP_XI		 (2L<<13)
-#define BNX2_RPM_RC_CNTL_6_HDR_TYPE_UDP_XI		 (3L<<13)
-#define BNX2_RPM_RC_CNTL_6_HDR_TYPE_DATA_XI		 (4L<<13)
-#define BNX2_RPM_RC_CNTL_6_HDR_TYPE_TCP_UDP_XI		 (5L<<13)
-#define BNX2_RPM_RC_CNTL_6_HDR_TYPE_ICMPV6_XI		 (6L<<13)
-#define BNX2_RPM_RC_CNTL_6_COMP_XI			 (0x3L<<16)
-#define BNX2_RPM_RC_CNTL_6_COMP_EQUAL_XI		 (0L<<16)
-#define BNX2_RPM_RC_CNTL_6_COMP_NEQUAL_XI		 (1L<<16)
-#define BNX2_RPM_RC_CNTL_6_COMP_GREATER_XI		 (2L<<16)
-#define BNX2_RPM_RC_CNTL_6_COMP_LESS_XI			 (3L<<16)
-#define BNX2_RPM_RC_CNTL_6_MAP_XI			 (1L<<18)
-#define BNX2_RPM_RC_CNTL_6_SBIT_XI			 (1L<<19)
-#define BNX2_RPM_RC_CNTL_6_CMDSEL_XI			 (0x1fL<<20)
-#define BNX2_RPM_RC_CNTL_6_DISCARD_XI			 (1L<<25)
-#define BNX2_RPM_RC_CNTL_6_MASK_XI			 (1L<<26)
-#define BNX2_RPM_RC_CNTL_6_P1_XI			 (1L<<27)
-#define BNX2_RPM_RC_CNTL_6_P2_XI			 (1L<<28)
-#define BNX2_RPM_RC_CNTL_6_P3_XI			 (1L<<29)
-#define BNX2_RPM_RC_CNTL_6_NBIT_XI			 (1L<<30)
-
-#define BNX2_RPM_RC_VALUE_MASK_6			0x00001934
-#define BNX2_RPM_RC_VALUE_MASK_6_VALUE			 (0xffffL<<0)
-#define BNX2_RPM_RC_VALUE_MASK_6_MASK			 (0xffffL<<16)
-
-#define BNX2_RPM_RC_CNTL_7				0x00001938
-#define BNX2_RPM_RC_CNTL_7_A				 (0x3ffffL<<0)
-#define BNX2_RPM_RC_CNTL_7_B				 (0xfffL<<19)
-#define BNX2_RPM_RC_CNTL_7_OFFSET_XI			 (0xffL<<0)
-#define BNX2_RPM_RC_CNTL_7_CLASS_XI			 (0x7L<<8)
-#define BNX2_RPM_RC_CNTL_7_PRIORITY_XI			 (1L<<11)
-#define BNX2_RPM_RC_CNTL_7_P4_XI			 (1L<<12)
-#define BNX2_RPM_RC_CNTL_7_HDR_TYPE_XI			 (0x7L<<13)
-#define BNX2_RPM_RC_CNTL_7_HDR_TYPE_START_XI		 (0L<<13)
-#define BNX2_RPM_RC_CNTL_7_HDR_TYPE_IP_XI		 (1L<<13)
-#define BNX2_RPM_RC_CNTL_7_HDR_TYPE_TCP_XI		 (2L<<13)
-#define BNX2_RPM_RC_CNTL_7_HDR_TYPE_UDP_XI		 (3L<<13)
-#define BNX2_RPM_RC_CNTL_7_HDR_TYPE_DATA_XI		 (4L<<13)
-#define BNX2_RPM_RC_CNTL_7_HDR_TYPE_TCP_UDP_XI		 (5L<<13)
-#define BNX2_RPM_RC_CNTL_7_HDR_TYPE_ICMPV6_XI		 (6L<<13)
-#define BNX2_RPM_RC_CNTL_7_COMP_XI			 (0x3L<<16)
-#define BNX2_RPM_RC_CNTL_7_COMP_EQUAL_XI		 (0L<<16)
-#define BNX2_RPM_RC_CNTL_7_COMP_NEQUAL_XI		 (1L<<16)
-#define BNX2_RPM_RC_CNTL_7_COMP_GREATER_XI		 (2L<<16)
-#define BNX2_RPM_RC_CNTL_7_COMP_LESS_XI			 (3L<<16)
-#define BNX2_RPM_RC_CNTL_7_MAP_XI			 (1L<<18)
-#define BNX2_RPM_RC_CNTL_7_SBIT_XI			 (1L<<19)
-#define BNX2_RPM_RC_CNTL_7_CMDSEL_XI			 (0x1fL<<20)
-#define BNX2_RPM_RC_CNTL_7_DISCARD_XI			 (1L<<25)
-#define BNX2_RPM_RC_CNTL_7_MASK_XI			 (1L<<26)
-#define BNX2_RPM_RC_CNTL_7_P1_XI			 (1L<<27)
-#define BNX2_RPM_RC_CNTL_7_P2_XI			 (1L<<28)
-#define BNX2_RPM_RC_CNTL_7_P3_XI			 (1L<<29)
-#define BNX2_RPM_RC_CNTL_7_NBIT_XI			 (1L<<30)
-
-#define BNX2_RPM_RC_VALUE_MASK_7			0x0000193c
-#define BNX2_RPM_RC_VALUE_MASK_7_VALUE			 (0xffffL<<0)
-#define BNX2_RPM_RC_VALUE_MASK_7_MASK			 (0xffffL<<16)
-
-#define BNX2_RPM_RC_CNTL_8				0x00001940
-#define BNX2_RPM_RC_CNTL_8_A				 (0x3ffffL<<0)
-#define BNX2_RPM_RC_CNTL_8_B				 (0xfffL<<19)
-#define BNX2_RPM_RC_CNTL_8_OFFSET_XI			 (0xffL<<0)
-#define BNX2_RPM_RC_CNTL_8_CLASS_XI			 (0x7L<<8)
-#define BNX2_RPM_RC_CNTL_8_PRIORITY_XI			 (1L<<11)
-#define BNX2_RPM_RC_CNTL_8_P4_XI			 (1L<<12)
-#define BNX2_RPM_RC_CNTL_8_HDR_TYPE_XI			 (0x7L<<13)
-#define BNX2_RPM_RC_CNTL_8_HDR_TYPE_START_XI		 (0L<<13)
-#define BNX2_RPM_RC_CNTL_8_HDR_TYPE_IP_XI		 (1L<<13)
-#define BNX2_RPM_RC_CNTL_8_HDR_TYPE_TCP_XI		 (2L<<13)
-#define BNX2_RPM_RC_CNTL_8_HDR_TYPE_UDP_XI		 (3L<<13)
-#define BNX2_RPM_RC_CNTL_8_HDR_TYPE_DATA_XI		 (4L<<13)
-#define BNX2_RPM_RC_CNTL_8_HDR_TYPE_TCP_UDP_XI		 (5L<<13)
-#define BNX2_RPM_RC_CNTL_8_HDR_TYPE_ICMPV6_XI		 (6L<<13)
-#define BNX2_RPM_RC_CNTL_8_COMP_XI			 (0x3L<<16)
-#define BNX2_RPM_RC_CNTL_8_COMP_EQUAL_XI		 (0L<<16)
-#define BNX2_RPM_RC_CNTL_8_COMP_NEQUAL_XI		 (1L<<16)
-#define BNX2_RPM_RC_CNTL_8_COMP_GREATER_XI		 (2L<<16)
-#define BNX2_RPM_RC_CNTL_8_COMP_LESS_XI			 (3L<<16)
-#define BNX2_RPM_RC_CNTL_8_MAP_XI			 (1L<<18)
-#define BNX2_RPM_RC_CNTL_8_SBIT_XI			 (1L<<19)
-#define BNX2_RPM_RC_CNTL_8_CMDSEL_XI			 (0x1fL<<20)
-#define BNX2_RPM_RC_CNTL_8_DISCARD_XI			 (1L<<25)
-#define BNX2_RPM_RC_CNTL_8_MASK_XI			 (1L<<26)
-#define BNX2_RPM_RC_CNTL_8_P1_XI			 (1L<<27)
-#define BNX2_RPM_RC_CNTL_8_P2_XI			 (1L<<28)
-#define BNX2_RPM_RC_CNTL_8_P3_XI			 (1L<<29)
-#define BNX2_RPM_RC_CNTL_8_NBIT_XI			 (1L<<30)
-
-#define BNX2_RPM_RC_VALUE_MASK_8			0x00001944
-#define BNX2_RPM_RC_VALUE_MASK_8_VALUE			 (0xffffL<<0)
-#define BNX2_RPM_RC_VALUE_MASK_8_MASK			 (0xffffL<<16)
-
-#define BNX2_RPM_RC_CNTL_9				0x00001948
-#define BNX2_RPM_RC_CNTL_9_A				 (0x3ffffL<<0)
-#define BNX2_RPM_RC_CNTL_9_B				 (0xfffL<<19)
-#define BNX2_RPM_RC_CNTL_9_OFFSET_XI			 (0xffL<<0)
-#define BNX2_RPM_RC_CNTL_9_CLASS_XI			 (0x7L<<8)
-#define BNX2_RPM_RC_CNTL_9_PRIORITY_XI			 (1L<<11)
-#define BNX2_RPM_RC_CNTL_9_P4_XI			 (1L<<12)
-#define BNX2_RPM_RC_CNTL_9_HDR_TYPE_XI			 (0x7L<<13)
-#define BNX2_RPM_RC_CNTL_9_HDR_TYPE_START_XI		 (0L<<13)
-#define BNX2_RPM_RC_CNTL_9_HDR_TYPE_IP_XI		 (1L<<13)
-#define BNX2_RPM_RC_CNTL_9_HDR_TYPE_TCP_XI		 (2L<<13)
-#define BNX2_RPM_RC_CNTL_9_HDR_TYPE_UDP_XI		 (3L<<13)
-#define BNX2_RPM_RC_CNTL_9_HDR_TYPE_DATA_XI		 (4L<<13)
-#define BNX2_RPM_RC_CNTL_9_HDR_TYPE_TCP_UDP_XI		 (5L<<13)
-#define BNX2_RPM_RC_CNTL_9_HDR_TYPE_ICMPV6_XI		 (6L<<13)
-#define BNX2_RPM_RC_CNTL_9_COMP_XI			 (0x3L<<16)
-#define BNX2_RPM_RC_CNTL_9_COMP_EQUAL_XI		 (0L<<16)
-#define BNX2_RPM_RC_CNTL_9_COMP_NEQUAL_XI		 (1L<<16)
-#define BNX2_RPM_RC_CNTL_9_COMP_GREATER_XI		 (2L<<16)
-#define BNX2_RPM_RC_CNTL_9_COMP_LESS_XI			 (3L<<16)
-#define BNX2_RPM_RC_CNTL_9_MAP_XI			 (1L<<18)
-#define BNX2_RPM_RC_CNTL_9_SBIT_XI			 (1L<<19)
-#define BNX2_RPM_RC_CNTL_9_CMDSEL_XI			 (0x1fL<<20)
-#define BNX2_RPM_RC_CNTL_9_DISCARD_XI			 (1L<<25)
-#define BNX2_RPM_RC_CNTL_9_MASK_XI			 (1L<<26)
-#define BNX2_RPM_RC_CNTL_9_P1_XI			 (1L<<27)
-#define BNX2_RPM_RC_CNTL_9_P2_XI			 (1L<<28)
-#define BNX2_RPM_RC_CNTL_9_P3_XI			 (1L<<29)
-#define BNX2_RPM_RC_CNTL_9_NBIT_XI			 (1L<<30)
-
-#define BNX2_RPM_RC_VALUE_MASK_9			0x0000194c
-#define BNX2_RPM_RC_VALUE_MASK_9_VALUE			 (0xffffL<<0)
-#define BNX2_RPM_RC_VALUE_MASK_9_MASK			 (0xffffL<<16)
-
-#define BNX2_RPM_RC_CNTL_10				0x00001950
-#define BNX2_RPM_RC_CNTL_10_A				 (0x3ffffL<<0)
-#define BNX2_RPM_RC_CNTL_10_B				 (0xfffL<<19)
-#define BNX2_RPM_RC_CNTL_10_OFFSET_XI			 (0xffL<<0)
-#define BNX2_RPM_RC_CNTL_10_CLASS_XI			 (0x7L<<8)
-#define BNX2_RPM_RC_CNTL_10_PRIORITY_XI			 (1L<<11)
-#define BNX2_RPM_RC_CNTL_10_P4_XI			 (1L<<12)
-#define BNX2_RPM_RC_CNTL_10_HDR_TYPE_XI			 (0x7L<<13)
-#define BNX2_RPM_RC_CNTL_10_HDR_TYPE_START_XI		 (0L<<13)
-#define BNX2_RPM_RC_CNTL_10_HDR_TYPE_IP_XI		 (1L<<13)
-#define BNX2_RPM_RC_CNTL_10_HDR_TYPE_TCP_XI		 (2L<<13)
-#define BNX2_RPM_RC_CNTL_10_HDR_TYPE_UDP_XI		 (3L<<13)
-#define BNX2_RPM_RC_CNTL_10_HDR_TYPE_DATA_XI		 (4L<<13)
-#define BNX2_RPM_RC_CNTL_10_HDR_TYPE_TCP_UDP_XI		 (5L<<13)
-#define BNX2_RPM_RC_CNTL_10_HDR_TYPE_ICMPV6_XI		 (6L<<13)
-#define BNX2_RPM_RC_CNTL_10_COMP_XI			 (0x3L<<16)
-#define BNX2_RPM_RC_CNTL_10_COMP_EQUAL_XI		 (0L<<16)
-#define BNX2_RPM_RC_CNTL_10_COMP_NEQUAL_XI		 (1L<<16)
-#define BNX2_RPM_RC_CNTL_10_COMP_GREATER_XI		 (2L<<16)
-#define BNX2_RPM_RC_CNTL_10_COMP_LESS_XI		 (3L<<16)
-#define BNX2_RPM_RC_CNTL_10_MAP_XI			 (1L<<18)
-#define BNX2_RPM_RC_CNTL_10_SBIT_XI			 (1L<<19)
-#define BNX2_RPM_RC_CNTL_10_CMDSEL_XI			 (0x1fL<<20)
-#define BNX2_RPM_RC_CNTL_10_DISCARD_XI			 (1L<<25)
-#define BNX2_RPM_RC_CNTL_10_MASK_XI			 (1L<<26)
-#define BNX2_RPM_RC_CNTL_10_P1_XI			 (1L<<27)
-#define BNX2_RPM_RC_CNTL_10_P2_XI			 (1L<<28)
-#define BNX2_RPM_RC_CNTL_10_P3_XI			 (1L<<29)
-#define BNX2_RPM_RC_CNTL_10_NBIT_XI			 (1L<<30)
-
-#define BNX2_RPM_RC_VALUE_MASK_10			0x00001954
-#define BNX2_RPM_RC_VALUE_MASK_10_VALUE			 (0xffffL<<0)
-#define BNX2_RPM_RC_VALUE_MASK_10_MASK			 (0xffffL<<16)
-
-#define BNX2_RPM_RC_CNTL_11				0x00001958
-#define BNX2_RPM_RC_CNTL_11_A				 (0x3ffffL<<0)
-#define BNX2_RPM_RC_CNTL_11_B				 (0xfffL<<19)
-#define BNX2_RPM_RC_CNTL_11_OFFSET_XI			 (0xffL<<0)
-#define BNX2_RPM_RC_CNTL_11_CLASS_XI			 (0x7L<<8)
-#define BNX2_RPM_RC_CNTL_11_PRIORITY_XI			 (1L<<11)
-#define BNX2_RPM_RC_CNTL_11_P4_XI			 (1L<<12)
-#define BNX2_RPM_RC_CNTL_11_HDR_TYPE_XI			 (0x7L<<13)
-#define BNX2_RPM_RC_CNTL_11_HDR_TYPE_START_XI		 (0L<<13)
-#define BNX2_RPM_RC_CNTL_11_HDR_TYPE_IP_XI		 (1L<<13)
-#define BNX2_RPM_RC_CNTL_11_HDR_TYPE_TCP_XI		 (2L<<13)
-#define BNX2_RPM_RC_CNTL_11_HDR_TYPE_UDP_XI		 (3L<<13)
-#define BNX2_RPM_RC_CNTL_11_HDR_TYPE_DATA_XI		 (4L<<13)
-#define BNX2_RPM_RC_CNTL_11_HDR_TYPE_TCP_UDP_XI		 (5L<<13)
-#define BNX2_RPM_RC_CNTL_11_HDR_TYPE_ICMPV6_XI		 (6L<<13)
-#define BNX2_RPM_RC_CNTL_11_COMP_XI			 (0x3L<<16)
-#define BNX2_RPM_RC_CNTL_11_COMP_EQUAL_XI		 (0L<<16)
-#define BNX2_RPM_RC_CNTL_11_COMP_NEQUAL_XI		 (1L<<16)
-#define BNX2_RPM_RC_CNTL_11_COMP_GREATER_XI		 (2L<<16)
-#define BNX2_RPM_RC_CNTL_11_COMP_LESS_XI		 (3L<<16)
-#define BNX2_RPM_RC_CNTL_11_MAP_XI			 (1L<<18)
-#define BNX2_RPM_RC_CNTL_11_SBIT_XI			 (1L<<19)
-#define BNX2_RPM_RC_CNTL_11_CMDSEL_XI			 (0x1fL<<20)
-#define BNX2_RPM_RC_CNTL_11_DISCARD_XI			 (1L<<25)
-#define BNX2_RPM_RC_CNTL_11_MASK_XI			 (1L<<26)
-#define BNX2_RPM_RC_CNTL_11_P1_XI			 (1L<<27)
-#define BNX2_RPM_RC_CNTL_11_P2_XI			 (1L<<28)
-#define BNX2_RPM_RC_CNTL_11_P3_XI			 (1L<<29)
-#define BNX2_RPM_RC_CNTL_11_NBIT_XI			 (1L<<30)
-
-#define BNX2_RPM_RC_VALUE_MASK_11			0x0000195c
-#define BNX2_RPM_RC_VALUE_MASK_11_VALUE			 (0xffffL<<0)
-#define BNX2_RPM_RC_VALUE_MASK_11_MASK			 (0xffffL<<16)
-
-#define BNX2_RPM_RC_CNTL_12				0x00001960
-#define BNX2_RPM_RC_CNTL_12_A				 (0x3ffffL<<0)
-#define BNX2_RPM_RC_CNTL_12_B				 (0xfffL<<19)
-#define BNX2_RPM_RC_CNTL_12_OFFSET_XI			 (0xffL<<0)
-#define BNX2_RPM_RC_CNTL_12_CLASS_XI			 (0x7L<<8)
-#define BNX2_RPM_RC_CNTL_12_PRIORITY_XI			 (1L<<11)
-#define BNX2_RPM_RC_CNTL_12_P4_XI			 (1L<<12)
-#define BNX2_RPM_RC_CNTL_12_HDR_TYPE_XI			 (0x7L<<13)
-#define BNX2_RPM_RC_CNTL_12_HDR_TYPE_START_XI		 (0L<<13)
-#define BNX2_RPM_RC_CNTL_12_HDR_TYPE_IP_XI		 (1L<<13)
-#define BNX2_RPM_RC_CNTL_12_HDR_TYPE_TCP_XI		 (2L<<13)
-#define BNX2_RPM_RC_CNTL_12_HDR_TYPE_UDP_XI		 (3L<<13)
-#define BNX2_RPM_RC_CNTL_12_HDR_TYPE_DATA_XI		 (4L<<13)
-#define BNX2_RPM_RC_CNTL_12_HDR_TYPE_TCP_UDP_XI		 (5L<<13)
-#define BNX2_RPM_RC_CNTL_12_HDR_TYPE_ICMPV6_XI		 (6L<<13)
-#define BNX2_RPM_RC_CNTL_12_COMP_XI			 (0x3L<<16)
-#define BNX2_RPM_RC_CNTL_12_COMP_EQUAL_XI		 (0L<<16)
-#define BNX2_RPM_RC_CNTL_12_COMP_NEQUAL_XI		 (1L<<16)
-#define BNX2_RPM_RC_CNTL_12_COMP_GREATER_XI		 (2L<<16)
-#define BNX2_RPM_RC_CNTL_12_COMP_LESS_XI		 (3L<<16)
-#define BNX2_RPM_RC_CNTL_12_MAP_XI			 (1L<<18)
-#define BNX2_RPM_RC_CNTL_12_SBIT_XI			 (1L<<19)
-#define BNX2_RPM_RC_CNTL_12_CMDSEL_XI			 (0x1fL<<20)
-#define BNX2_RPM_RC_CNTL_12_DISCARD_XI			 (1L<<25)
-#define BNX2_RPM_RC_CNTL_12_MASK_XI			 (1L<<26)
-#define BNX2_RPM_RC_CNTL_12_P1_XI			 (1L<<27)
-#define BNX2_RPM_RC_CNTL_12_P2_XI			 (1L<<28)
-#define BNX2_RPM_RC_CNTL_12_P3_XI			 (1L<<29)
-#define BNX2_RPM_RC_CNTL_12_NBIT_XI			 (1L<<30)
-
-#define BNX2_RPM_RC_VALUE_MASK_12			0x00001964
-#define BNX2_RPM_RC_VALUE_MASK_12_VALUE			 (0xffffL<<0)
-#define BNX2_RPM_RC_VALUE_MASK_12_MASK			 (0xffffL<<16)
-
-#define BNX2_RPM_RC_CNTL_13				0x00001968
-#define BNX2_RPM_RC_CNTL_13_A				 (0x3ffffL<<0)
-#define BNX2_RPM_RC_CNTL_13_B				 (0xfffL<<19)
-#define BNX2_RPM_RC_CNTL_13_OFFSET_XI			 (0xffL<<0)
-#define BNX2_RPM_RC_CNTL_13_CLASS_XI			 (0x7L<<8)
-#define BNX2_RPM_RC_CNTL_13_PRIORITY_XI			 (1L<<11)
-#define BNX2_RPM_RC_CNTL_13_P4_XI			 (1L<<12)
-#define BNX2_RPM_RC_CNTL_13_HDR_TYPE_XI			 (0x7L<<13)
-#define BNX2_RPM_RC_CNTL_13_HDR_TYPE_START_XI		 (0L<<13)
-#define BNX2_RPM_RC_CNTL_13_HDR_TYPE_IP_XI		 (1L<<13)
-#define BNX2_RPM_RC_CNTL_13_HDR_TYPE_TCP_XI		 (2L<<13)
-#define BNX2_RPM_RC_CNTL_13_HDR_TYPE_UDP_XI		 (3L<<13)
-#define BNX2_RPM_RC_CNTL_13_HDR_TYPE_DATA_XI		 (4L<<13)
-#define BNX2_RPM_RC_CNTL_13_HDR_TYPE_TCP_UDP_XI		 (5L<<13)
-#define BNX2_RPM_RC_CNTL_13_HDR_TYPE_ICMPV6_XI		 (6L<<13)
-#define BNX2_RPM_RC_CNTL_13_COMP_XI			 (0x3L<<16)
-#define BNX2_RPM_RC_CNTL_13_COMP_EQUAL_XI		 (0L<<16)
-#define BNX2_RPM_RC_CNTL_13_COMP_NEQUAL_XI		 (1L<<16)
-#define BNX2_RPM_RC_CNTL_13_COMP_GREATER_XI		 (2L<<16)
-#define BNX2_RPM_RC_CNTL_13_COMP_LESS_XI		 (3L<<16)
-#define BNX2_RPM_RC_CNTL_13_MAP_XI			 (1L<<18)
-#define BNX2_RPM_RC_CNTL_13_SBIT_XI			 (1L<<19)
-#define BNX2_RPM_RC_CNTL_13_CMDSEL_XI			 (0x1fL<<20)
-#define BNX2_RPM_RC_CNTL_13_DISCARD_XI			 (1L<<25)
-#define BNX2_RPM_RC_CNTL_13_MASK_XI			 (1L<<26)
-#define BNX2_RPM_RC_CNTL_13_P1_XI			 (1L<<27)
-#define BNX2_RPM_RC_CNTL_13_P2_XI			 (1L<<28)
-#define BNX2_RPM_RC_CNTL_13_P3_XI			 (1L<<29)
-#define BNX2_RPM_RC_CNTL_13_NBIT_XI			 (1L<<30)
-
-#define BNX2_RPM_RC_VALUE_MASK_13			0x0000196c
-#define BNX2_RPM_RC_VALUE_MASK_13_VALUE			 (0xffffL<<0)
-#define BNX2_RPM_RC_VALUE_MASK_13_MASK			 (0xffffL<<16)
-
-#define BNX2_RPM_RC_CNTL_14				0x00001970
-#define BNX2_RPM_RC_CNTL_14_A				 (0x3ffffL<<0)
-#define BNX2_RPM_RC_CNTL_14_B				 (0xfffL<<19)
-#define BNX2_RPM_RC_CNTL_14_OFFSET_XI			 (0xffL<<0)
-#define BNX2_RPM_RC_CNTL_14_CLASS_XI			 (0x7L<<8)
-#define BNX2_RPM_RC_CNTL_14_PRIORITY_XI			 (1L<<11)
-#define BNX2_RPM_RC_CNTL_14_P4_XI			 (1L<<12)
-#define BNX2_RPM_RC_CNTL_14_HDR_TYPE_XI			 (0x7L<<13)
-#define BNX2_RPM_RC_CNTL_14_HDR_TYPE_START_XI		 (0L<<13)
-#define BNX2_RPM_RC_CNTL_14_HDR_TYPE_IP_XI		 (1L<<13)
-#define BNX2_RPM_RC_CNTL_14_HDR_TYPE_TCP_XI		 (2L<<13)
-#define BNX2_RPM_RC_CNTL_14_HDR_TYPE_UDP_XI		 (3L<<13)
-#define BNX2_RPM_RC_CNTL_14_HDR_TYPE_DATA_XI		 (4L<<13)
-#define BNX2_RPM_RC_CNTL_14_HDR_TYPE_TCP_UDP_XI		 (5L<<13)
-#define BNX2_RPM_RC_CNTL_14_HDR_TYPE_ICMPV6_XI		 (6L<<13)
-#define BNX2_RPM_RC_CNTL_14_COMP_XI			 (0x3L<<16)
-#define BNX2_RPM_RC_CNTL_14_COMP_EQUAL_XI		 (0L<<16)
-#define BNX2_RPM_RC_CNTL_14_COMP_NEQUAL_XI		 (1L<<16)
-#define BNX2_RPM_RC_CNTL_14_COMP_GREATER_XI		 (2L<<16)
-#define BNX2_RPM_RC_CNTL_14_COMP_LESS_XI		 (3L<<16)
-#define BNX2_RPM_RC_CNTL_14_MAP_XI			 (1L<<18)
-#define BNX2_RPM_RC_CNTL_14_SBIT_XI			 (1L<<19)
-#define BNX2_RPM_RC_CNTL_14_CMDSEL_XI			 (0x1fL<<20)
-#define BNX2_RPM_RC_CNTL_14_DISCARD_XI			 (1L<<25)
-#define BNX2_RPM_RC_CNTL_14_MASK_XI			 (1L<<26)
-#define BNX2_RPM_RC_CNTL_14_P1_XI			 (1L<<27)
-#define BNX2_RPM_RC_CNTL_14_P2_XI			 (1L<<28)
-#define BNX2_RPM_RC_CNTL_14_P3_XI			 (1L<<29)
-#define BNX2_RPM_RC_CNTL_14_NBIT_XI			 (1L<<30)
-
-#define BNX2_RPM_RC_VALUE_MASK_14			0x00001974
-#define BNX2_RPM_RC_VALUE_MASK_14_VALUE			 (0xffffL<<0)
-#define BNX2_RPM_RC_VALUE_MASK_14_MASK			 (0xffffL<<16)
-
-#define BNX2_RPM_RC_CNTL_15				0x00001978
-#define BNX2_RPM_RC_CNTL_15_A				 (0x3ffffL<<0)
-#define BNX2_RPM_RC_CNTL_15_B				 (0xfffL<<19)
-#define BNX2_RPM_RC_CNTL_15_OFFSET_XI			 (0xffL<<0)
-#define BNX2_RPM_RC_CNTL_15_CLASS_XI			 (0x7L<<8)
-#define BNX2_RPM_RC_CNTL_15_PRIORITY_XI			 (1L<<11)
-#define BNX2_RPM_RC_CNTL_15_P4_XI			 (1L<<12)
-#define BNX2_RPM_RC_CNTL_15_HDR_TYPE_XI			 (0x7L<<13)
-#define BNX2_RPM_RC_CNTL_15_HDR_TYPE_START_XI		 (0L<<13)
-#define BNX2_RPM_RC_CNTL_15_HDR_TYPE_IP_XI		 (1L<<13)
-#define BNX2_RPM_RC_CNTL_15_HDR_TYPE_TCP_XI		 (2L<<13)
-#define BNX2_RPM_RC_CNTL_15_HDR_TYPE_UDP_XI		 (3L<<13)
-#define BNX2_RPM_RC_CNTL_15_HDR_TYPE_DATA_XI		 (4L<<13)
-#define BNX2_RPM_RC_CNTL_15_HDR_TYPE_TCP_UDP_XI		 (5L<<13)
-#define BNX2_RPM_RC_CNTL_15_HDR_TYPE_ICMPV6_XI		 (6L<<13)
-#define BNX2_RPM_RC_CNTL_15_COMP_XI			 (0x3L<<16)
-#define BNX2_RPM_RC_CNTL_15_COMP_EQUAL_XI		 (0L<<16)
-#define BNX2_RPM_RC_CNTL_15_COMP_NEQUAL_XI		 (1L<<16)
-#define BNX2_RPM_RC_CNTL_15_COMP_GREATER_XI		 (2L<<16)
-#define BNX2_RPM_RC_CNTL_15_COMP_LESS_XI		 (3L<<16)
-#define BNX2_RPM_RC_CNTL_15_MAP_XI			 (1L<<18)
-#define BNX2_RPM_RC_CNTL_15_SBIT_XI			 (1L<<19)
-#define BNX2_RPM_RC_CNTL_15_CMDSEL_XI			 (0x1fL<<20)
-#define BNX2_RPM_RC_CNTL_15_DISCARD_XI			 (1L<<25)
-#define BNX2_RPM_RC_CNTL_15_MASK_XI			 (1L<<26)
-#define BNX2_RPM_RC_CNTL_15_P1_XI			 (1L<<27)
-#define BNX2_RPM_RC_CNTL_15_P2_XI			 (1L<<28)
-#define BNX2_RPM_RC_CNTL_15_P3_XI			 (1L<<29)
-#define BNX2_RPM_RC_CNTL_15_NBIT_XI			 (1L<<30)
-
-#define BNX2_RPM_RC_VALUE_MASK_15			0x0000197c
-#define BNX2_RPM_RC_VALUE_MASK_15_VALUE			 (0xffffL<<0)
-#define BNX2_RPM_RC_VALUE_MASK_15_MASK			 (0xffffL<<16)
-
-#define BNX2_RPM_RC_CONFIG				0x00001980
-#define BNX2_RPM_RC_CONFIG_RULE_ENABLE			 (0xffffL<<0)
-#define BNX2_RPM_RC_CONFIG_RULE_ENABLE_XI		 (0xfffffL<<0)
-#define BNX2_RPM_RC_CONFIG_DEF_CLASS			 (0x7L<<24)
-#define BNX2_RPM_RC_CONFIG_KNUM_OVERWRITE		 (1L<<31)
-
-#define BNX2_RPM_DEBUG0					0x00001984
-#define BNX2_RPM_DEBUG0_FM_BCNT				 (0xffffL<<0)
-#define BNX2_RPM_DEBUG0_T_DATA_OFST_VLD			 (1L<<16)
-#define BNX2_RPM_DEBUG0_T_UDP_OFST_VLD			 (1L<<17)
-#define BNX2_RPM_DEBUG0_T_TCP_OFST_VLD			 (1L<<18)
-#define BNX2_RPM_DEBUG0_T_IP_OFST_VLD			 (1L<<19)
-#define BNX2_RPM_DEBUG0_IP_MORE_FRGMT			 (1L<<20)
-#define BNX2_RPM_DEBUG0_T_IP_NO_TCP_UDP_HDR		 (1L<<21)
-#define BNX2_RPM_DEBUG0_LLC_SNAP			 (1L<<22)
-#define BNX2_RPM_DEBUG0_FM_STARTED			 (1L<<23)
-#define BNX2_RPM_DEBUG0_DONE				 (1L<<24)
-#define BNX2_RPM_DEBUG0_WAIT_4_DONE			 (1L<<25)
-#define BNX2_RPM_DEBUG0_USE_TPBUF_CKSUM			 (1L<<26)
-#define BNX2_RPM_DEBUG0_RX_NO_PSD_HDR_CKSUM		 (1L<<27)
-#define BNX2_RPM_DEBUG0_IGNORE_VLAN			 (1L<<28)
-#define BNX2_RPM_DEBUG0_RP_ENA_ACTIVE			 (1L<<31)
-
-#define BNX2_RPM_DEBUG1					0x00001988
-#define BNX2_RPM_DEBUG1_FSM_CUR_ST			 (0xffffL<<0)
-#define BNX2_RPM_DEBUG1_FSM_CUR_ST_IDLE			 (0L<<0)
-#define BNX2_RPM_DEBUG1_FSM_CUR_ST_ETYPE_B6_ALL		 (1L<<0)
-#define BNX2_RPM_DEBUG1_FSM_CUR_ST_ETYPE_B2_IPLLC	 (2L<<0)
-#define BNX2_RPM_DEBUG1_FSM_CUR_ST_ETYPE_B6_IP		 (4L<<0)
-#define BNX2_RPM_DEBUG1_FSM_CUR_ST_ETYPE_B2_IP		 (8L<<0)
-#define BNX2_RPM_DEBUG1_FSM_CUR_ST_IP_START		 (16L<<0)
-#define BNX2_RPM_DEBUG1_FSM_CUR_ST_IP			 (32L<<0)
-#define BNX2_RPM_DEBUG1_FSM_CUR_ST_TCP			 (64L<<0)
-#define BNX2_RPM_DEBUG1_FSM_CUR_ST_UDP			 (128L<<0)
-#define BNX2_RPM_DEBUG1_FSM_CUR_ST_AH			 (256L<<0)
-#define BNX2_RPM_DEBUG1_FSM_CUR_ST_ESP			 (512L<<0)
-#define BNX2_RPM_DEBUG1_FSM_CUR_ST_ESP_PAYLOAD		 (1024L<<0)
-#define BNX2_RPM_DEBUG1_FSM_CUR_ST_DATA			 (2048L<<0)
-#define BNX2_RPM_DEBUG1_FSM_CUR_ST_ADD_CARRY		 (0x2000L<<0)
-#define BNX2_RPM_DEBUG1_FSM_CUR_ST_ADD_CARRYOUT		 (0x4000L<<0)
-#define BNX2_RPM_DEBUG1_FSM_CUR_ST_LATCH_RESULT		 (0x8000L<<0)
-#define BNX2_RPM_DEBUG1_HDR_BCNT			 (0x7ffL<<16)
-#define BNX2_RPM_DEBUG1_UNKNOWN_ETYPE_D			 (1L<<28)
-#define BNX2_RPM_DEBUG1_VLAN_REMOVED_D2			 (1L<<29)
-#define BNX2_RPM_DEBUG1_VLAN_REMOVED_D1			 (1L<<30)
-#define BNX2_RPM_DEBUG1_EOF_0XTRA_WD			 (1L<<31)
-
-#define BNX2_RPM_DEBUG2					0x0000198c
-#define BNX2_RPM_DEBUG2_CMD_HIT_VEC			 (0xffffL<<0)
-#define BNX2_RPM_DEBUG2_IP_BCNT				 (0xffL<<16)
-#define BNX2_RPM_DEBUG2_THIS_CMD_M4			 (1L<<24)
-#define BNX2_RPM_DEBUG2_THIS_CMD_M3			 (1L<<25)
-#define BNX2_RPM_DEBUG2_THIS_CMD_M2			 (1L<<26)
-#define BNX2_RPM_DEBUG2_THIS_CMD_M1			 (1L<<27)
-#define BNX2_RPM_DEBUG2_IPIPE_EMPTY			 (1L<<28)
-#define BNX2_RPM_DEBUG2_FM_DISCARD			 (1L<<29)
-#define BNX2_RPM_DEBUG2_LAST_RULE_IN_FM_D2		 (1L<<30)
-#define BNX2_RPM_DEBUG2_LAST_RULE_IN_FM_D1		 (1L<<31)
-
-#define BNX2_RPM_DEBUG3					0x00001990
-#define BNX2_RPM_DEBUG3_AVAIL_MBUF_PTR			 (0x1ffL<<0)
-#define BNX2_RPM_DEBUG3_RDE_RLUPQ_WR_REQ_INT		 (1L<<9)
-#define BNX2_RPM_DEBUG3_RDE_RBUF_WR_LAST_INT		 (1L<<10)
-#define BNX2_RPM_DEBUG3_RDE_RBUF_WR_REQ_INT		 (1L<<11)
-#define BNX2_RPM_DEBUG3_RDE_RBUF_FREE_REQ		 (1L<<12)
-#define BNX2_RPM_DEBUG3_RDE_RBUF_ALLOC_REQ		 (1L<<13)
-#define BNX2_RPM_DEBUG3_DFSM_MBUF_NOTAVAIL		 (1L<<14)
-#define BNX2_RPM_DEBUG3_RBUF_RDE_SOF_DROP		 (1L<<15)
-#define BNX2_RPM_DEBUG3_DFIFO_VLD_ENTRY_CT		 (0xfL<<16)
-#define BNX2_RPM_DEBUG3_RDE_SRC_FIFO_ALMFULL		 (1L<<21)
-#define BNX2_RPM_DEBUG3_DROP_NXT_VLD			 (1L<<22)
-#define BNX2_RPM_DEBUG3_DROP_NXT			 (1L<<23)
-#define BNX2_RPM_DEBUG3_FTQ_FSM				 (0x3L<<24)
-#define BNX2_RPM_DEBUG3_FTQ_FSM_IDLE			 (0x0L<<24)
-#define BNX2_RPM_DEBUG3_FTQ_FSM_WAIT_ACK		 (0x1L<<24)
-#define BNX2_RPM_DEBUG3_FTQ_FSM_WAIT_FREE		 (0x2L<<24)
-#define BNX2_RPM_DEBUG3_MBWRITE_FSM			 (0x3L<<26)
-#define BNX2_RPM_DEBUG3_MBWRITE_FSM_WAIT_SOF		 (0x0L<<26)
-#define BNX2_RPM_DEBUG3_MBWRITE_FSM_GET_MBUF		 (0x1L<<26)
-#define BNX2_RPM_DEBUG3_MBWRITE_FSM_DMA_DATA		 (0x2L<<26)
-#define BNX2_RPM_DEBUG3_MBWRITE_FSM_WAIT_DATA		 (0x3L<<26)
-#define BNX2_RPM_DEBUG3_MBWRITE_FSM_WAIT_EOF		 (0x4L<<26)
-#define BNX2_RPM_DEBUG3_MBWRITE_FSM_WAIT_MF_ACK		 (0x5L<<26)
-#define BNX2_RPM_DEBUG3_MBWRITE_FSM_WAIT_DROP_NXT_VLD	 (0x6L<<26)
-#define BNX2_RPM_DEBUG3_MBWRITE_FSM_DONE		 (0x7L<<26)
-#define BNX2_RPM_DEBUG3_MBFREE_FSM			 (1L<<29)
-#define BNX2_RPM_DEBUG3_MBFREE_FSM_IDLE			 (0L<<29)
-#define BNX2_RPM_DEBUG3_MBFREE_FSM_WAIT_ACK		 (1L<<29)
-#define BNX2_RPM_DEBUG3_MBALLOC_FSM			 (1L<<30)
-#define BNX2_RPM_DEBUG3_MBALLOC_FSM_ET_MBUF		 (0x0L<<30)
-#define BNX2_RPM_DEBUG3_MBALLOC_FSM_IVE_MBUF		 (0x1L<<30)
-#define BNX2_RPM_DEBUG3_CCODE_EOF_ERROR			 (1L<<31)
-
-#define BNX2_RPM_DEBUG4					0x00001994
-#define BNX2_RPM_DEBUG4_DFSM_MBUF_CLUSTER		 (0x1ffffffL<<0)
-#define BNX2_RPM_DEBUG4_DFIFO_CUR_CCODE			 (0x7L<<25)
-#define BNX2_RPM_DEBUG4_MBWRITE_FSM			 (0x7L<<28)
-#define BNX2_RPM_DEBUG4_DFIFO_EMPTY			 (1L<<31)
-
-#define BNX2_RPM_DEBUG5					0x00001998
-#define BNX2_RPM_DEBUG5_RDROP_WPTR			 (0x1fL<<0)
-#define BNX2_RPM_DEBUG5_RDROP_ACPI_RPTR			 (0x1fL<<5)
-#define BNX2_RPM_DEBUG5_RDROP_MC_RPTR			 (0x1fL<<10)
-#define BNX2_RPM_DEBUG5_RDROP_RC_RPTR			 (0x1fL<<15)
-#define BNX2_RPM_DEBUG5_RDROP_ACPI_EMPTY		 (1L<<20)
-#define BNX2_RPM_DEBUG5_RDROP_MC_EMPTY			 (1L<<21)
-#define BNX2_RPM_DEBUG5_RDROP_AEOF_VEC_AT_RDROP_MC_RPTR	 (1L<<22)
-#define BNX2_RPM_DEBUG5_HOLDREG_WOL_DROP_INT		 (1L<<23)
-#define BNX2_RPM_DEBUG5_HOLDREG_DISCARD			 (1L<<24)
-#define BNX2_RPM_DEBUG5_HOLDREG_MBUF_NOTAVAIL		 (1L<<25)
-#define BNX2_RPM_DEBUG5_HOLDREG_MC_EMPTY		 (1L<<26)
-#define BNX2_RPM_DEBUG5_HOLDREG_RC_EMPTY		 (1L<<27)
-#define BNX2_RPM_DEBUG5_HOLDREG_FC_EMPTY		 (1L<<28)
-#define BNX2_RPM_DEBUG5_HOLDREG_ACPI_EMPTY		 (1L<<29)
-#define BNX2_RPM_DEBUG5_HOLDREG_FULL_T			 (1L<<30)
-#define BNX2_RPM_DEBUG5_HOLDREG_RD			 (1L<<31)
-
-#define BNX2_RPM_DEBUG6					0x0000199c
-#define BNX2_RPM_DEBUG6_ACPI_VEC			 (0xffffL<<0)
-#define BNX2_RPM_DEBUG6_VEC				 (0xffffL<<16)
-
-#define BNX2_RPM_DEBUG7					0x000019a0
-#define BNX2_RPM_DEBUG7_RPM_DBG7_LAST_CRC		 (0xffffffffL<<0)
-
-#define BNX2_RPM_DEBUG8					0x000019a4
-#define BNX2_RPM_DEBUG8_PS_ACPI_FSM			 (0xfL<<0)
-#define BNX2_RPM_DEBUG8_PS_ACPI_FSM_IDLE		 (0L<<0)
-#define BNX2_RPM_DEBUG8_PS_ACPI_FSM_SOF_W1_ADDR		 (1L<<0)
-#define BNX2_RPM_DEBUG8_PS_ACPI_FSM_SOF_W2_ADDR		 (2L<<0)
-#define BNX2_RPM_DEBUG8_PS_ACPI_FSM_SOF_W3_ADDR		 (3L<<0)
-#define BNX2_RPM_DEBUG8_PS_ACPI_FSM_SOF_WAIT_THBUF	 (4L<<0)
-#define BNX2_RPM_DEBUG8_PS_ACPI_FSM_W3_DATA		 (5L<<0)
-#define BNX2_RPM_DEBUG8_PS_ACPI_FSM_W0_ADDR		 (6L<<0)
-#define BNX2_RPM_DEBUG8_PS_ACPI_FSM_W1_ADDR		 (7L<<0)
-#define BNX2_RPM_DEBUG8_PS_ACPI_FSM_W2_ADDR		 (8L<<0)
-#define BNX2_RPM_DEBUG8_PS_ACPI_FSM_W3_ADDR		 (9L<<0)
-#define BNX2_RPM_DEBUG8_PS_ACPI_FSM_WAIT_THBUF		 (10L<<0)
-#define BNX2_RPM_DEBUG8_COMPARE_AT_W0			 (1L<<4)
-#define BNX2_RPM_DEBUG8_COMPARE_AT_W3_DATA		 (1L<<5)
-#define BNX2_RPM_DEBUG8_COMPARE_AT_SOF_WAIT		 (1L<<6)
-#define BNX2_RPM_DEBUG8_COMPARE_AT_SOF_W3		 (1L<<7)
-#define BNX2_RPM_DEBUG8_COMPARE_AT_SOF_W2		 (1L<<8)
-#define BNX2_RPM_DEBUG8_EOF_W_LTEQ6_VLDBYTES		 (1L<<9)
-#define BNX2_RPM_DEBUG8_EOF_W_LTEQ4_VLDBYTES		 (1L<<10)
-#define BNX2_RPM_DEBUG8_NXT_EOF_W_12_VLDBYTES		 (1L<<11)
-#define BNX2_RPM_DEBUG8_EOF_DET				 (1L<<12)
-#define BNX2_RPM_DEBUG8_SOF_DET				 (1L<<13)
-#define BNX2_RPM_DEBUG8_WAIT_4_SOF			 (1L<<14)
-#define BNX2_RPM_DEBUG8_ALL_DONE			 (1L<<15)
-#define BNX2_RPM_DEBUG8_THBUF_ADDR			 (0x7fL<<16)
-#define BNX2_RPM_DEBUG8_BYTE_CTR			 (0xffL<<24)
-
-#define BNX2_RPM_DEBUG9					0x000019a8
-#define BNX2_RPM_DEBUG9_OUTFIFO_COUNT			 (0x7L<<0)
-#define BNX2_RPM_DEBUG9_RDE_ACPI_RDY			 (1L<<3)
-#define BNX2_RPM_DEBUG9_VLD_RD_ENTRY_CT			 (0x7L<<4)
-#define BNX2_RPM_DEBUG9_OUTFIFO_OVERRUN_OCCURRED	 (1L<<28)
-#define BNX2_RPM_DEBUG9_INFIFO_OVERRUN_OCCURRED		 (1L<<29)
-#define BNX2_RPM_DEBUG9_ACPI_MATCH_INT			 (1L<<30)
-#define BNX2_RPM_DEBUG9_ACPI_ENABLE_SYN			 (1L<<31)
-#define BNX2_RPM_DEBUG9_BEMEM_R_XI			 (0x1fL<<0)
-#define BNX2_RPM_DEBUG9_EO_XI				 (1L<<5)
-#define BNX2_RPM_DEBUG9_AEOF_DE_XI			 (1L<<6)
-#define BNX2_RPM_DEBUG9_SO_XI				 (1L<<7)
-#define BNX2_RPM_DEBUG9_WD64_CT_XI			 (0x1fL<<8)
-#define BNX2_RPM_DEBUG9_EOF_VLDBYTE_XI			 (0x7L<<13)
-#define BNX2_RPM_DEBUG9_ACPI_RDE_PAT_ID_XI		 (0xfL<<16)
-#define BNX2_RPM_DEBUG9_CALCRC_RESULT_XI		 (0x3ffL<<20)
-#define BNX2_RPM_DEBUG9_DATA_IN_VL_XI			 (1L<<30)
-#define BNX2_RPM_DEBUG9_CALCRC_BUFFER_VLD_XI		 (1L<<31)
-
-#define BNX2_RPM_ACPI_DBG_BUF_W00			0x000019c0
-#define BNX2_RPM_ACPI_DBG_BUF_W01			0x000019c4
-#define BNX2_RPM_ACPI_DBG_BUF_W02			0x000019c8
-#define BNX2_RPM_ACPI_DBG_BUF_W03			0x000019cc
-#define BNX2_RPM_ACPI_DBG_BUF_W10			0x000019d0
-#define BNX2_RPM_ACPI_DBG_BUF_W11			0x000019d4
-#define BNX2_RPM_ACPI_DBG_BUF_W12			0x000019d8
-#define BNX2_RPM_ACPI_DBG_BUF_W13			0x000019dc
-#define BNX2_RPM_ACPI_DBG_BUF_W20			0x000019e0
-#define BNX2_RPM_ACPI_DBG_BUF_W21			0x000019e4
-#define BNX2_RPM_ACPI_DBG_BUF_W22			0x000019e8
-#define BNX2_RPM_ACPI_DBG_BUF_W23			0x000019ec
-#define BNX2_RPM_ACPI_DBG_BUF_W30			0x000019f0
-#define BNX2_RPM_ACPI_DBG_BUF_W31			0x000019f4
-#define BNX2_RPM_ACPI_DBG_BUF_W32			0x000019f8
-#define BNX2_RPM_ACPI_DBG_BUF_W33			0x000019fc
-#define BNX2_RPM_ACPI_BYTE_ENABLE_CTRL			0x00001a00
-#define BNX2_RPM_ACPI_BYTE_ENABLE_CTRL_BYTE_ADDRESS	 (0xffffL<<0)
-#define BNX2_RPM_ACPI_BYTE_ENABLE_CTRL_DEBUGRD		 (1L<<28)
-#define BNX2_RPM_ACPI_BYTE_ENABLE_CTRL_MODE		 (1L<<29)
-#define BNX2_RPM_ACPI_BYTE_ENABLE_CTRL_INIT		 (1L<<30)
-#define BNX2_RPM_ACPI_BYTE_ENABLE_CTRL_WR		 (1L<<31)
-
-#define BNX2_RPM_ACPI_PATTERN_CTRL			0x00001a04
-#define BNX2_RPM_ACPI_PATTERN_CTRL_PATTERN_ID		 (0xfL<<0)
-#define BNX2_RPM_ACPI_PATTERN_CTRL_CRC_SM_CLR		 (1L<<30)
-#define BNX2_RPM_ACPI_PATTERN_CTRL_WR			 (1L<<31)
-
-#define BNX2_RPM_ACPI_DATA				0x00001a08
-#define BNX2_RPM_ACPI_DATA_PATTERN_BE			 (0xffffffffL<<0)
-
-#define BNX2_RPM_ACPI_PATTERN_LEN0			0x00001a0c
-#define BNX2_RPM_ACPI_PATTERN_LEN0_PATTERN_LEN3		 (0xffL<<0)
-#define BNX2_RPM_ACPI_PATTERN_LEN0_PATTERN_LEN2		 (0xffL<<8)
-#define BNX2_RPM_ACPI_PATTERN_LEN0_PATTERN_LEN1		 (0xffL<<16)
-#define BNX2_RPM_ACPI_PATTERN_LEN0_PATTERN_LEN0		 (0xffL<<24)
-
-#define BNX2_RPM_ACPI_PATTERN_LEN1			0x00001a10
-#define BNX2_RPM_ACPI_PATTERN_LEN1_PATTERN_LEN7		 (0xffL<<0)
-#define BNX2_RPM_ACPI_PATTERN_LEN1_PATTERN_LEN6		 (0xffL<<8)
-#define BNX2_RPM_ACPI_PATTERN_LEN1_PATTERN_LEN5		 (0xffL<<16)
-#define BNX2_RPM_ACPI_PATTERN_LEN1_PATTERN_LEN4		 (0xffL<<24)
-
-#define BNX2_RPM_ACPI_PATTERN_CRC0			0x00001a18
-#define BNX2_RPM_ACPI_PATTERN_CRC0_PATTERN_CRC0		 (0xffffffffL<<0)
-
-#define BNX2_RPM_ACPI_PATTERN_CRC1			0x00001a1c
-#define BNX2_RPM_ACPI_PATTERN_CRC1_PATTERN_CRC1		 (0xffffffffL<<0)
-
-#define BNX2_RPM_ACPI_PATTERN_CRC2			0x00001a20
-#define BNX2_RPM_ACPI_PATTERN_CRC2_PATTERN_CRC2		 (0xffffffffL<<0)
-
-#define BNX2_RPM_ACPI_PATTERN_CRC3			0x00001a24
-#define BNX2_RPM_ACPI_PATTERN_CRC3_PATTERN_CRC3		 (0xffffffffL<<0)
-
-#define BNX2_RPM_ACPI_PATTERN_CRC4			0x00001a28
-#define BNX2_RPM_ACPI_PATTERN_CRC4_PATTERN_CRC4		 (0xffffffffL<<0)
-
-#define BNX2_RPM_ACPI_PATTERN_CRC5			0x00001a2c
-#define BNX2_RPM_ACPI_PATTERN_CRC5_PATTERN_CRC5		 (0xffffffffL<<0)
-
-#define BNX2_RPM_ACPI_PATTERN_CRC6			0x00001a30
-#define BNX2_RPM_ACPI_PATTERN_CRC6_PATTERN_CRC6		 (0xffffffffL<<0)
-
-#define BNX2_RPM_ACPI_PATTERN_CRC7			0x00001a34
-#define BNX2_RPM_ACPI_PATTERN_CRC7_PATTERN_CRC7		 (0xffffffffL<<0)
-
-
-/*
- *  rlup_reg definition
- *  offset: 0x2000
- */
-#define BNX2_RLUP_RSS_CONFIG				0x0000201c
-#define BNX2_RLUP_RSS_CONFIG_IPV4_RSS_TYPE_XI		 (0x3L<<0)
-#define BNX2_RLUP_RSS_CONFIG_IPV4_RSS_TYPE_OFF_XI	 (0L<<0)
-#define BNX2_RLUP_RSS_CONFIG_IPV4_RSS_TYPE_ALL_XI	 (1L<<0)
-#define BNX2_RLUP_RSS_CONFIG_IPV4_RSS_TYPE_IP_ONLY_XI	 (2L<<0)
-#define BNX2_RLUP_RSS_CONFIG_IPV4_RSS_TYPE_RES_XI	 (3L<<0)
-#define BNX2_RLUP_RSS_CONFIG_IPV6_RSS_TYPE_XI		 (0x3L<<2)
-#define BNX2_RLUP_RSS_CONFIG_IPV6_RSS_TYPE_OFF_XI	 (0L<<2)
-#define BNX2_RLUP_RSS_CONFIG_IPV6_RSS_TYPE_ALL_XI	 (1L<<2)
-#define BNX2_RLUP_RSS_CONFIG_IPV6_RSS_TYPE_IP_ONLY_XI	 (2L<<2)
-#define BNX2_RLUP_RSS_CONFIG_IPV6_RSS_TYPE_RES_XI	 (3L<<2)
-
-
-/*
- *  rbuf_reg definition
- *  offset: 0x200000
- */
-#define BNX2_RBUF_COMMAND				0x00200000
-#define BNX2_RBUF_COMMAND_ENABLED			 (1L<<0)
-#define BNX2_RBUF_COMMAND_FREE_INIT			 (1L<<1)
-#define BNX2_RBUF_COMMAND_RAM_INIT			 (1L<<2)
-#define BNX2_RBUF_COMMAND_PKT_OFFSET_OVFL		 (1L<<3)
-#define BNX2_RBUF_COMMAND_OVER_FREE			 (1L<<4)
-#define BNX2_RBUF_COMMAND_ALLOC_REQ			 (1L<<5)
-#define BNX2_RBUF_COMMAND_EN_PRI_CHNGE_TE		 (1L<<6)
-#define BNX2_RBUF_COMMAND_CU_ISOLATE_XI			 (1L<<5)
-#define BNX2_RBUF_COMMAND_EN_PRI_CHANGE_XI		 (1L<<6)
-#define BNX2_RBUF_COMMAND_GRC_ENDIAN_CONV_DIS_XI	 (1L<<7)
-
-#define BNX2_RBUF_STATUS1				0x00200004
-#define BNX2_RBUF_STATUS1_FREE_COUNT			 (0x3ffL<<0)
-
-#define BNX2_RBUF_STATUS2				0x00200008
-#define BNX2_RBUF_STATUS2_FREE_TAIL			 (0x1ffL<<0)
-#define BNX2_RBUF_STATUS2_FREE_HEAD			 (0x1ffL<<16)
-
-#define BNX2_RBUF_CONFIG				0x0020000c
-#define BNX2_RBUF_CONFIG_XOFF_TRIP			 (0x3ffL<<0)
-#define BNX2_RBUF_CONFIG_XOFF_TRIP_VAL(mtu)		 \
-	((((mtu) - 1500) * 31 / 1000) + 54)
-#define BNX2_RBUF_CONFIG_XON_TRIP			 (0x3ffL<<16)
-#define BNX2_RBUF_CONFIG_XON_TRIP_VAL(mtu)		 \
-	((((mtu) - 1500) * 39 / 1000) + 66)
-#define BNX2_RBUF_CONFIG_VAL(mtu)			 \
-	(BNX2_RBUF_CONFIG_XOFF_TRIP_VAL(mtu) |		 \
-	(BNX2_RBUF_CONFIG_XON_TRIP_VAL(mtu) << 16))
-
-#define BNX2_RBUF_FW_BUF_ALLOC				0x00200010
-#define BNX2_RBUF_FW_BUF_ALLOC_VALUE			 (0x1ffL<<7)
-#define BNX2_RBUF_FW_BUF_ALLOC_TYPE			 (1L<<16)
-#define BNX2_RBUF_FW_BUF_ALLOC_ALLOC_REQ		 (1L<<31)
-
-#define BNX2_RBUF_FW_BUF_FREE				0x00200014
-#define BNX2_RBUF_FW_BUF_FREE_COUNT			 (0x7fL<<0)
-#define BNX2_RBUF_FW_BUF_FREE_TAIL			 (0x1ffL<<7)
-#define BNX2_RBUF_FW_BUF_FREE_HEAD			 (0x1ffL<<16)
-#define BNX2_RBUF_FW_BUF_FREE_TYPE			 (1L<<25)
-#define BNX2_RBUF_FW_BUF_FREE_FREE_REQ			 (1L<<31)
-
-#define BNX2_RBUF_FW_BUF_SEL				0x00200018
-#define BNX2_RBUF_FW_BUF_SEL_COUNT			 (0x7fL<<0)
-#define BNX2_RBUF_FW_BUF_SEL_TAIL			 (0x1ffL<<7)
-#define BNX2_RBUF_FW_BUF_SEL_HEAD			 (0x1ffL<<16)
-#define BNX2_RBUF_FW_BUF_SEL_SEL_REQ			 (1L<<31)
-
-#define BNX2_RBUF_CONFIG2				0x0020001c
-#define BNX2_RBUF_CONFIG2_MAC_DROP_TRIP			 (0x3ffL<<0)
-#define BNX2_RBUF_CONFIG2_MAC_DROP_TRIP_VAL(mtu)	 \
-	((((mtu) - 1500) * 4 / 1000) + 5)
-#define BNX2_RBUF_CONFIG2_MAC_KEEP_TRIP			 (0x3ffL<<16)
-#define BNX2_RBUF_CONFIG2_MAC_KEEP_TRIP_VAL(mtu)	 \
-	((((mtu) - 1500) * 2 / 100) + 30)
-#define BNX2_RBUF_CONFIG2_VAL(mtu)			 \
-	(BNX2_RBUF_CONFIG2_MAC_DROP_TRIP_VAL(mtu) |	 \
-	(BNX2_RBUF_CONFIG2_MAC_KEEP_TRIP_VAL(mtu) << 16))
-
-#define BNX2_RBUF_CONFIG3				0x00200020
-#define BNX2_RBUF_CONFIG3_CU_DROP_TRIP			 (0x3ffL<<0)
-#define BNX2_RBUF_CONFIG3_CU_DROP_TRIP_VAL(mtu)		 \
-	((((mtu) - 1500) * 12 / 1000) + 18)
-#define BNX2_RBUF_CONFIG3_CU_KEEP_TRIP			 (0x3ffL<<16)
-#define BNX2_RBUF_CONFIG3_CU_KEEP_TRIP_VAL(mtu)		 \
-	((((mtu) - 1500) * 2 / 100) + 30)
-#define BNX2_RBUF_CONFIG3_VAL(mtu)			 \
-	(BNX2_RBUF_CONFIG3_CU_DROP_TRIP_VAL(mtu) |	 \
-	(BNX2_RBUF_CONFIG3_CU_KEEP_TRIP_VAL(mtu) << 16))
-
-#define BNX2_RBUF_PKT_DATA				0x00208000
-#define BNX2_RBUF_CLIST_DATA				0x00210000
-#define BNX2_RBUF_BUF_DATA				0x00220000
-
-
-/*
- *  rv2p_reg definition
- *  offset: 0x2800
- */
-#define BNX2_RV2P_COMMAND				0x00002800
-#define BNX2_RV2P_COMMAND_ENABLED			 (1L<<0)
-#define BNX2_RV2P_COMMAND_PROC1_INTRPT			 (1L<<1)
-#define BNX2_RV2P_COMMAND_PROC2_INTRPT			 (1L<<2)
-#define BNX2_RV2P_COMMAND_ABORT0			 (1L<<4)
-#define BNX2_RV2P_COMMAND_ABORT1			 (1L<<5)
-#define BNX2_RV2P_COMMAND_ABORT2			 (1L<<6)
-#define BNX2_RV2P_COMMAND_ABORT3			 (1L<<7)
-#define BNX2_RV2P_COMMAND_ABORT4			 (1L<<8)
-#define BNX2_RV2P_COMMAND_ABORT5			 (1L<<9)
-#define BNX2_RV2P_COMMAND_PROC1_RESET			 (1L<<16)
-#define BNX2_RV2P_COMMAND_PROC2_RESET			 (1L<<17)
-#define BNX2_RV2P_COMMAND_CTXIF_RESET			 (1L<<18)
-
-#define BNX2_RV2P_STATUS				0x00002804
-#define BNX2_RV2P_STATUS_ALWAYS_0			 (1L<<0)
-#define BNX2_RV2P_STATUS_RV2P_GEN_STAT0_CNT		 (1L<<8)
-#define BNX2_RV2P_STATUS_RV2P_GEN_STAT1_CNT		 (1L<<9)
-#define BNX2_RV2P_STATUS_RV2P_GEN_STAT2_CNT		 (1L<<10)
-#define BNX2_RV2P_STATUS_RV2P_GEN_STAT3_CNT		 (1L<<11)
-#define BNX2_RV2P_STATUS_RV2P_GEN_STAT4_CNT		 (1L<<12)
-#define BNX2_RV2P_STATUS_RV2P_GEN_STAT5_CNT		 (1L<<13)
-
-#define BNX2_RV2P_CONFIG				0x00002808
-#define BNX2_RV2P_CONFIG_STALL_PROC1			 (1L<<0)
-#define BNX2_RV2P_CONFIG_STALL_PROC2			 (1L<<1)
-#define BNX2_RV2P_CONFIG_PROC1_STALL_ON_ABORT0		 (1L<<8)
-#define BNX2_RV2P_CONFIG_PROC1_STALL_ON_ABORT1		 (1L<<9)
-#define BNX2_RV2P_CONFIG_PROC1_STALL_ON_ABORT2		 (1L<<10)
-#define BNX2_RV2P_CONFIG_PROC1_STALL_ON_ABORT3		 (1L<<11)
-#define BNX2_RV2P_CONFIG_PROC1_STALL_ON_ABORT4		 (1L<<12)
-#define BNX2_RV2P_CONFIG_PROC1_STALL_ON_ABORT5		 (1L<<13)
-#define BNX2_RV2P_CONFIG_PROC2_STALL_ON_ABORT0		 (1L<<16)
-#define BNX2_RV2P_CONFIG_PROC2_STALL_ON_ABORT1		 (1L<<17)
-#define BNX2_RV2P_CONFIG_PROC2_STALL_ON_ABORT2		 (1L<<18)
-#define BNX2_RV2P_CONFIG_PROC2_STALL_ON_ABORT3		 (1L<<19)
-#define BNX2_RV2P_CONFIG_PROC2_STALL_ON_ABORT4		 (1L<<20)
-#define BNX2_RV2P_CONFIG_PROC2_STALL_ON_ABORT5		 (1L<<21)
-#define BNX2_RV2P_CONFIG_PAGE_SIZE			 (0xfL<<24)
-#define BNX2_RV2P_CONFIG_PAGE_SIZE_256			 (0L<<24)
-#define BNX2_RV2P_CONFIG_PAGE_SIZE_512			 (1L<<24)
-#define BNX2_RV2P_CONFIG_PAGE_SIZE_1K			 (2L<<24)
-#define BNX2_RV2P_CONFIG_PAGE_SIZE_2K			 (3L<<24)
-#define BNX2_RV2P_CONFIG_PAGE_SIZE_4K			 (4L<<24)
-#define BNX2_RV2P_CONFIG_PAGE_SIZE_8K			 (5L<<24)
-#define BNX2_RV2P_CONFIG_PAGE_SIZE_16K			 (6L<<24)
-#define BNX2_RV2P_CONFIG_PAGE_SIZE_32K			 (7L<<24)
-#define BNX2_RV2P_CONFIG_PAGE_SIZE_64K			 (8L<<24)
-#define BNX2_RV2P_CONFIG_PAGE_SIZE_128K			 (9L<<24)
-#define BNX2_RV2P_CONFIG_PAGE_SIZE_256K			 (10L<<24)
-#define BNX2_RV2P_CONFIG_PAGE_SIZE_512K			 (11L<<24)
-#define BNX2_RV2P_CONFIG_PAGE_SIZE_1M			 (12L<<24)
-
-#define BNX2_RV2P_GEN_BFR_ADDR_0			0x00002810
-#define BNX2_RV2P_GEN_BFR_ADDR_0_VALUE			 (0xffffL<<16)
-
-#define BNX2_RV2P_GEN_BFR_ADDR_1			0x00002814
-#define BNX2_RV2P_GEN_BFR_ADDR_1_VALUE			 (0xffffL<<16)
-
-#define BNX2_RV2P_GEN_BFR_ADDR_2			0x00002818
-#define BNX2_RV2P_GEN_BFR_ADDR_2_VALUE			 (0xffffL<<16)
-
-#define BNX2_RV2P_GEN_BFR_ADDR_3			0x0000281c
-#define BNX2_RV2P_GEN_BFR_ADDR_3_VALUE			 (0xffffL<<16)
-
-#define BNX2_RV2P_INSTR_HIGH				0x00002830
-#define BNX2_RV2P_INSTR_HIGH_HIGH			 (0x1fL<<0)
-
-#define BNX2_RV2P_INSTR_LOW				0x00002834
-#define BNX2_RV2P_INSTR_LOW_LOW				 (0xffffffffL<<0)
-
-#define BNX2_RV2P_PROC1_ADDR_CMD			0x00002838
-#define BNX2_RV2P_PROC1_ADDR_CMD_ADD			 (0x3ffL<<0)
-#define BNX2_RV2P_PROC1_ADDR_CMD_RDWR			 (1L<<31)
-
-#define BNX2_RV2P_PROC2_ADDR_CMD			0x0000283c
-#define BNX2_RV2P_PROC2_ADDR_CMD_ADD			 (0x3ffL<<0)
-#define BNX2_RV2P_PROC2_ADDR_CMD_RDWR			 (1L<<31)
-
-#define BNX2_RV2P_PROC1_GRC_DEBUG			0x00002840
-#define BNX2_RV2P_PROC2_GRC_DEBUG			0x00002844
-#define BNX2_RV2P_GRC_PROC_DEBUG			0x00002848
-#define BNX2_RV2P_DEBUG_VECT_PEEK			0x0000284c
-#define BNX2_RV2P_DEBUG_VECT_PEEK_1_VALUE		 (0x7ffL<<0)
-#define BNX2_RV2P_DEBUG_VECT_PEEK_1_PEEK_EN		 (1L<<11)
-#define BNX2_RV2P_DEBUG_VECT_PEEK_1_SEL			 (0xfL<<12)
-#define BNX2_RV2P_DEBUG_VECT_PEEK_2_VALUE		 (0x7ffL<<16)
-#define BNX2_RV2P_DEBUG_VECT_PEEK_2_PEEK_EN		 (1L<<27)
-#define BNX2_RV2P_DEBUG_VECT_PEEK_2_SEL			 (0xfL<<28)
-
-#define BNX2_RV2P_MPFE_PFE_CTL				0x00002afc
-#define BNX2_RV2P_MPFE_PFE_CTL_INC_USAGE_CNT		 (1L<<0)
-#define BNX2_RV2P_MPFE_PFE_CTL_PFE_SIZE			 (0xfL<<4)
-#define BNX2_RV2P_MPFE_PFE_CTL_PFE_SIZE_0		 (0L<<4)
-#define BNX2_RV2P_MPFE_PFE_CTL_PFE_SIZE_1		 (1L<<4)
-#define BNX2_RV2P_MPFE_PFE_CTL_PFE_SIZE_2		 (2L<<4)
-#define BNX2_RV2P_MPFE_PFE_CTL_PFE_SIZE_3		 (3L<<4)
-#define BNX2_RV2P_MPFE_PFE_CTL_PFE_SIZE_4		 (4L<<4)
-#define BNX2_RV2P_MPFE_PFE_CTL_PFE_SIZE_5		 (5L<<4)
-#define BNX2_RV2P_MPFE_PFE_CTL_PFE_SIZE_6		 (6L<<4)
-#define BNX2_RV2P_MPFE_PFE_CTL_PFE_SIZE_7		 (7L<<4)
-#define BNX2_RV2P_MPFE_PFE_CTL_PFE_SIZE_8		 (8L<<4)
-#define BNX2_RV2P_MPFE_PFE_CTL_PFE_SIZE_9		 (9L<<4)
-#define BNX2_RV2P_MPFE_PFE_CTL_PFE_SIZE_10		 (10L<<4)
-#define BNX2_RV2P_MPFE_PFE_CTL_PFE_SIZE_11		 (11L<<4)
-#define BNX2_RV2P_MPFE_PFE_CTL_PFE_SIZE_12		 (12L<<4)
-#define BNX2_RV2P_MPFE_PFE_CTL_PFE_SIZE_13		 (13L<<4)
-#define BNX2_RV2P_MPFE_PFE_CTL_PFE_SIZE_14		 (14L<<4)
-#define BNX2_RV2P_MPFE_PFE_CTL_PFE_SIZE_15		 (15L<<4)
-#define BNX2_RV2P_MPFE_PFE_CTL_PFE_COUNT		 (0xfL<<12)
-#define BNX2_RV2P_MPFE_PFE_CTL_OFFSET			 (0x1ffL<<16)
-
-#define BNX2_RV2P_RV2PPQ				0x00002b40
-#define BNX2_RV2P_PFTQ_CMD				0x00002b78
-#define BNX2_RV2P_PFTQ_CMD_OFFSET			 (0x3ffL<<0)
-#define BNX2_RV2P_PFTQ_CMD_WR_TOP			 (1L<<10)
-#define BNX2_RV2P_PFTQ_CMD_WR_TOP_0			 (0L<<10)
-#define BNX2_RV2P_PFTQ_CMD_WR_TOP_1			 (1L<<10)
-#define BNX2_RV2P_PFTQ_CMD_SFT_RESET			 (1L<<25)
-#define BNX2_RV2P_PFTQ_CMD_RD_DATA			 (1L<<26)
-#define BNX2_RV2P_PFTQ_CMD_ADD_INTERVEN			 (1L<<27)
-#define BNX2_RV2P_PFTQ_CMD_ADD_DATA			 (1L<<28)
-#define BNX2_RV2P_PFTQ_CMD_INTERVENE_CLR		 (1L<<29)
-#define BNX2_RV2P_PFTQ_CMD_POP				 (1L<<30)
-#define BNX2_RV2P_PFTQ_CMD_BUSY				 (1L<<31)
-
-#define BNX2_RV2P_PFTQ_CTL				0x00002b7c
-#define BNX2_RV2P_PFTQ_CTL_INTERVENE			 (1L<<0)
-#define BNX2_RV2P_PFTQ_CTL_OVERFLOW			 (1L<<1)
-#define BNX2_RV2P_PFTQ_CTL_FORCE_INTERVENE		 (1L<<2)
-#define BNX2_RV2P_PFTQ_CTL_MAX_DEPTH			 (0x3ffL<<12)
-#define BNX2_RV2P_PFTQ_CTL_CUR_DEPTH			 (0x3ffL<<22)
-
-#define BNX2_RV2P_RV2PTQ				0x00002b80
-#define BNX2_RV2P_TFTQ_CMD				0x00002bb8
-#define BNX2_RV2P_TFTQ_CMD_OFFSET			 (0x3ffL<<0)
-#define BNX2_RV2P_TFTQ_CMD_WR_TOP			 (1L<<10)
-#define BNX2_RV2P_TFTQ_CMD_WR_TOP_0			 (0L<<10)
-#define BNX2_RV2P_TFTQ_CMD_WR_TOP_1			 (1L<<10)
-#define BNX2_RV2P_TFTQ_CMD_SFT_RESET			 (1L<<25)
-#define BNX2_RV2P_TFTQ_CMD_RD_DATA			 (1L<<26)
-#define BNX2_RV2P_TFTQ_CMD_ADD_INTERVEN			 (1L<<27)
-#define BNX2_RV2P_TFTQ_CMD_ADD_DATA			 (1L<<28)
-#define BNX2_RV2P_TFTQ_CMD_INTERVENE_CLR		 (1L<<29)
-#define BNX2_RV2P_TFTQ_CMD_POP				 (1L<<30)
-#define BNX2_RV2P_TFTQ_CMD_BUSY				 (1L<<31)
-
-#define BNX2_RV2P_TFTQ_CTL				0x00002bbc
-#define BNX2_RV2P_TFTQ_CTL_INTERVENE			 (1L<<0)
-#define BNX2_RV2P_TFTQ_CTL_OVERFLOW			 (1L<<1)
-#define BNX2_RV2P_TFTQ_CTL_FORCE_INTERVENE		 (1L<<2)
-#define BNX2_RV2P_TFTQ_CTL_MAX_DEPTH			 (0x3ffL<<12)
-#define BNX2_RV2P_TFTQ_CTL_CUR_DEPTH			 (0x3ffL<<22)
-
-#define BNX2_RV2P_RV2PMQ				0x00002bc0
-#define BNX2_RV2P_MFTQ_CMD				0x00002bf8
-#define BNX2_RV2P_MFTQ_CMD_OFFSET			 (0x3ffL<<0)
-#define BNX2_RV2P_MFTQ_CMD_WR_TOP			 (1L<<10)
-#define BNX2_RV2P_MFTQ_CMD_WR_TOP_0			 (0L<<10)
-#define BNX2_RV2P_MFTQ_CMD_WR_TOP_1			 (1L<<10)
-#define BNX2_RV2P_MFTQ_CMD_SFT_RESET			 (1L<<25)
-#define BNX2_RV2P_MFTQ_CMD_RD_DATA			 (1L<<26)
-#define BNX2_RV2P_MFTQ_CMD_ADD_INTERVEN			 (1L<<27)
-#define BNX2_RV2P_MFTQ_CMD_ADD_DATA			 (1L<<28)
-#define BNX2_RV2P_MFTQ_CMD_INTERVENE_CLR		 (1L<<29)
-#define BNX2_RV2P_MFTQ_CMD_POP				 (1L<<30)
-#define BNX2_RV2P_MFTQ_CMD_BUSY				 (1L<<31)
-
-#define BNX2_RV2P_MFTQ_CTL				0x00002bfc
-#define BNX2_RV2P_MFTQ_CTL_INTERVENE			 (1L<<0)
-#define BNX2_RV2P_MFTQ_CTL_OVERFLOW			 (1L<<1)
-#define BNX2_RV2P_MFTQ_CTL_FORCE_INTERVENE		 (1L<<2)
-#define BNX2_RV2P_MFTQ_CTL_MAX_DEPTH			 (0x3ffL<<12)
-#define BNX2_RV2P_MFTQ_CTL_CUR_DEPTH			 (0x3ffL<<22)
-
-
-
-/*
- *  mq_reg definition
- *  offset: 0x3c00
- */
-#define BNX2_MQ_COMMAND					0x00003c00
-#define BNX2_MQ_COMMAND_ENABLED				 (1L<<0)
-#define BNX2_MQ_COMMAND_INIT				 (1L<<1)
-#define BNX2_MQ_COMMAND_OVERFLOW			 (1L<<4)
-#define BNX2_MQ_COMMAND_WR_ERROR			 (1L<<5)
-#define BNX2_MQ_COMMAND_RD_ERROR			 (1L<<6)
-#define BNX2_MQ_COMMAND_IDB_CFG_ERROR			 (1L<<7)
-#define BNX2_MQ_COMMAND_IDB_OVERFLOW			 (1L<<10)
-#define BNX2_MQ_COMMAND_NO_BIN_ERROR			 (1L<<11)
-#define BNX2_MQ_COMMAND_NO_MAP_ERROR			 (1L<<12)
-
-#define BNX2_MQ_STATUS					0x00003c04
-#define BNX2_MQ_STATUS_CTX_ACCESS_STAT			 (1L<<16)
-#define BNX2_MQ_STATUS_CTX_ACCESS64_STAT		 (1L<<17)
-#define BNX2_MQ_STATUS_PCI_STALL_STAT			 (1L<<18)
-#define BNX2_MQ_STATUS_IDB_OFLOW_STAT			 (1L<<19)
-
-#define BNX2_MQ_CONFIG					0x00003c08
-#define BNX2_MQ_CONFIG_TX_HIGH_PRI			 (1L<<0)
-#define BNX2_MQ_CONFIG_HALT_DIS				 (1L<<1)
-#define BNX2_MQ_CONFIG_BIN_MQ_MODE			 (1L<<2)
-#define BNX2_MQ_CONFIG_DIS_IDB_DROP			 (1L<<3)
-#define BNX2_MQ_CONFIG_KNL_BYP_BLK_SIZE			 (0x7L<<4)
-#define BNX2_MQ_CONFIG_KNL_BYP_BLK_SIZE_256		 (0L<<4)
-#define BNX2_MQ_CONFIG_KNL_BYP_BLK_SIZE_512		 (1L<<4)
-#define BNX2_MQ_CONFIG_KNL_BYP_BLK_SIZE_1K		 (2L<<4)
-#define BNX2_MQ_CONFIG_KNL_BYP_BLK_SIZE_2K		 (3L<<4)
-#define BNX2_MQ_CONFIG_KNL_BYP_BLK_SIZE_4K		 (4L<<4)
-#define BNX2_MQ_CONFIG_MAX_DEPTH			 (0x7fL<<8)
-#define BNX2_MQ_CONFIG_CUR_DEPTH			 (0x7fL<<20)
-
-#define BNX2_MQ_ENQUEUE1				0x00003c0c
-#define BNX2_MQ_ENQUEUE1_OFFSET				 (0x3fL<<2)
-#define BNX2_MQ_ENQUEUE1_CID				 (0x3fffL<<8)
-#define BNX2_MQ_ENQUEUE1_BYTE_MASK			 (0xfL<<24)
-#define BNX2_MQ_ENQUEUE1_KNL_MODE			 (1L<<28)
-
-#define BNX2_MQ_ENQUEUE2				0x00003c10
-#define BNX2_MQ_BAD_WR_ADDR				0x00003c14
-#define BNX2_MQ_BAD_RD_ADDR				0x00003c18
-#define BNX2_MQ_KNL_BYP_WIND_START			0x00003c1c
-#define BNX2_MQ_KNL_BYP_WIND_START_VALUE		 (0xfffffL<<12)
-
-#define BNX2_MQ_KNL_WIND_END				0x00003c20
-#define BNX2_MQ_KNL_WIND_END_VALUE			 (0xffffffL<<8)
-
-#define BNX2_MQ_KNL_WRITE_MASK1				0x00003c24
-#define BNX2_MQ_KNL_TX_MASK1				0x00003c28
-#define BNX2_MQ_KNL_CMD_MASK1				0x00003c2c
-#define BNX2_MQ_KNL_COND_ENQUEUE_MASK1			0x00003c30
-#define BNX2_MQ_KNL_RX_V2P_MASK1			0x00003c34
-#define BNX2_MQ_KNL_WRITE_MASK2				0x00003c38
-#define BNX2_MQ_KNL_TX_MASK2				0x00003c3c
-#define BNX2_MQ_KNL_CMD_MASK2				0x00003c40
-#define BNX2_MQ_KNL_COND_ENQUEUE_MASK2			0x00003c44
-#define BNX2_MQ_KNL_RX_V2P_MASK2			0x00003c48
-#define BNX2_MQ_KNL_BYP_WRITE_MASK1			0x00003c4c
-#define BNX2_MQ_KNL_BYP_TX_MASK1			0x00003c50
-#define BNX2_MQ_KNL_BYP_CMD_MASK1			0x00003c54
-#define BNX2_MQ_KNL_BYP_COND_ENQUEUE_MASK1		0x00003c58
-#define BNX2_MQ_KNL_BYP_RX_V2P_MASK1			0x00003c5c
-#define BNX2_MQ_KNL_BYP_WRITE_MASK2			0x00003c60
-#define BNX2_MQ_KNL_BYP_TX_MASK2			0x00003c64
-#define BNX2_MQ_KNL_BYP_CMD_MASK2			0x00003c68
-#define BNX2_MQ_KNL_BYP_COND_ENQUEUE_MASK2		0x00003c6c
-#define BNX2_MQ_KNL_BYP_RX_V2P_MASK2			0x00003c70
-#define BNX2_MQ_MEM_WR_ADDR				0x00003c74
-#define BNX2_MQ_MEM_WR_ADDR_VALUE			 (0x3fL<<0)
-
-#define BNX2_MQ_MEM_WR_DATA0				0x00003c78
-#define BNX2_MQ_MEM_WR_DATA0_VALUE			 (0xffffffffL<<0)
-
-#define BNX2_MQ_MEM_WR_DATA1				0x00003c7c
-#define BNX2_MQ_MEM_WR_DATA1_VALUE			 (0xffffffffL<<0)
-
-#define BNX2_MQ_MEM_WR_DATA2				0x00003c80
-#define BNX2_MQ_MEM_WR_DATA2_VALUE			 (0x3fffffffL<<0)
-#define BNX2_MQ_MEM_WR_DATA2_VALUE_XI			 (0x7fffffffL<<0)
-
-#define BNX2_MQ_MEM_RD_ADDR				0x00003c84
-#define BNX2_MQ_MEM_RD_ADDR_VALUE			 (0x3fL<<0)
-
-#define BNX2_MQ_MEM_RD_DATA0				0x00003c88
-#define BNX2_MQ_MEM_RD_DATA0_VALUE			 (0xffffffffL<<0)
-
-#define BNX2_MQ_MEM_RD_DATA1				0x00003c8c
-#define BNX2_MQ_MEM_RD_DATA1_VALUE			 (0xffffffffL<<0)
-
-#define BNX2_MQ_MEM_RD_DATA2				0x00003c90
-#define BNX2_MQ_MEM_RD_DATA2_VALUE			 (0x3fffffffL<<0)
-#define BNX2_MQ_MEM_RD_DATA2_VALUE_XI			 (0x7fffffffL<<0)
-
-#define BNX2_MQ_MAP_L2_3				0x00003d2c
-#define BNX2_MQ_MAP_L2_3_MQ_OFFSET			 (0xffL<<0)
-#define BNX2_MQ_MAP_L2_3_SZ				 (0x3L<<8)
-#define BNX2_MQ_MAP_L2_3_CTX_OFFSET			 (0x2ffL<<10)
-#define BNX2_MQ_MAP_L2_3_BIN_OFFSET			 (0x7L<<23)
-#define BNX2_MQ_MAP_L2_3_ARM				 (0x3L<<26)
-#define BNX2_MQ_MAP_L2_3_ENA				 (0x1L<<31)
-#define BNX2_MQ_MAP_L2_3_DEFAULT			 0x82004646
-
-#define BNX2_MQ_MAP_L2_5				0x00003d34
-#define BNX2_MQ_MAP_L2_5_ARM				 (0x3L<<26)
-
-/*
- *  tsch_reg definition
- *  offset: 0x4c00
- */
-#define BNX2_TSCH_TSS_CFG				0x00004c1c
-#define BNX2_TSCH_TSS_CFG_TSS_START_CID			 (0x7ffL<<8)
-#define BNX2_TSCH_TSS_CFG_NUM_OF_TSS_CON		 (0xfL<<24)
-
-
-
-/*
- *  tbdr_reg definition
- *  offset: 0x5000
- */
-#define BNX2_TBDR_COMMAND				0x00005000
-#define BNX2_TBDR_COMMAND_ENABLE			 (1L<<0)
-#define BNX2_TBDR_COMMAND_SOFT_RST			 (1L<<1)
-#define BNX2_TBDR_COMMAND_MSTR_ABORT			 (1L<<4)
-
-#define BNX2_TBDR_STATUS				0x00005004
-#define BNX2_TBDR_STATUS_DMA_WAIT			 (1L<<0)
-#define BNX2_TBDR_STATUS_FTQ_WAIT			 (1L<<1)
-#define BNX2_TBDR_STATUS_FIFO_OVERFLOW			 (1L<<2)
-#define BNX2_TBDR_STATUS_FIFO_UNDERFLOW			 (1L<<3)
-#define BNX2_TBDR_STATUS_SEARCHMISS_ERROR		 (1L<<4)
-#define BNX2_TBDR_STATUS_FTQ_ENTRY_CNT			 (1L<<5)
-#define BNX2_TBDR_STATUS_BURST_CNT			 (1L<<6)
-
-#define BNX2_TBDR_CONFIG				0x00005008
-#define BNX2_TBDR_CONFIG_MAX_BDS			 (0xffL<<0)
-#define BNX2_TBDR_CONFIG_SWAP_MODE			 (1L<<8)
-#define BNX2_TBDR_CONFIG_PRIORITY			 (1L<<9)
-#define BNX2_TBDR_CONFIG_CACHE_NEXT_PAGE_PTRS		 (1L<<10)
-#define BNX2_TBDR_CONFIG_PAGE_SIZE			 (0xfL<<24)
-#define BNX2_TBDR_CONFIG_PAGE_SIZE_256			 (0L<<24)
-#define BNX2_TBDR_CONFIG_PAGE_SIZE_512			 (1L<<24)
-#define BNX2_TBDR_CONFIG_PAGE_SIZE_1K			 (2L<<24)
-#define BNX2_TBDR_CONFIG_PAGE_SIZE_2K			 (3L<<24)
-#define BNX2_TBDR_CONFIG_PAGE_SIZE_4K			 (4L<<24)
-#define BNX2_TBDR_CONFIG_PAGE_SIZE_8K			 (5L<<24)
-#define BNX2_TBDR_CONFIG_PAGE_SIZE_16K			 (6L<<24)
-#define BNX2_TBDR_CONFIG_PAGE_SIZE_32K			 (7L<<24)
-#define BNX2_TBDR_CONFIG_PAGE_SIZE_64K			 (8L<<24)
-#define BNX2_TBDR_CONFIG_PAGE_SIZE_128K			 (9L<<24)
-#define BNX2_TBDR_CONFIG_PAGE_SIZE_256K			 (10L<<24)
-#define BNX2_TBDR_CONFIG_PAGE_SIZE_512K			 (11L<<24)
-#define BNX2_TBDR_CONFIG_PAGE_SIZE_1M			 (12L<<24)
-
-#define BNX2_TBDR_DEBUG_VECT_PEEK			0x0000500c
-#define BNX2_TBDR_DEBUG_VECT_PEEK_1_VALUE		 (0x7ffL<<0)
-#define BNX2_TBDR_DEBUG_VECT_PEEK_1_PEEK_EN		 (1L<<11)
-#define BNX2_TBDR_DEBUG_VECT_PEEK_1_SEL			 (0xfL<<12)
-#define BNX2_TBDR_DEBUG_VECT_PEEK_2_VALUE		 (0x7ffL<<16)
-#define BNX2_TBDR_DEBUG_VECT_PEEK_2_PEEK_EN		 (1L<<27)
-#define BNX2_TBDR_DEBUG_VECT_PEEK_2_SEL			 (0xfL<<28)
-
-#define BNX2_TBDR_CKSUM_ERROR_STATUS			0x00005010
-#define BNX2_TBDR_CKSUM_ERROR_STATUS_CALCULATED		 (0xffffL<<0)
-#define BNX2_TBDR_CKSUM_ERROR_STATUS_EXPECTED		 (0xffffL<<16)
-
-#define BNX2_TBDR_TBDRQ					0x000053c0
-#define BNX2_TBDR_FTQ_CMD				0x000053f8
-#define BNX2_TBDR_FTQ_CMD_OFFSET			 (0x3ffL<<0)
-#define BNX2_TBDR_FTQ_CMD_WR_TOP			 (1L<<10)
-#define BNX2_TBDR_FTQ_CMD_WR_TOP_0			 (0L<<10)
-#define BNX2_TBDR_FTQ_CMD_WR_TOP_1			 (1L<<10)
-#define BNX2_TBDR_FTQ_CMD_SFT_RESET			 (1L<<25)
-#define BNX2_TBDR_FTQ_CMD_RD_DATA			 (1L<<26)
-#define BNX2_TBDR_FTQ_CMD_ADD_INTERVEN			 (1L<<27)
-#define BNX2_TBDR_FTQ_CMD_ADD_DATA			 (1L<<28)
-#define BNX2_TBDR_FTQ_CMD_INTERVENE_CLR			 (1L<<29)
-#define BNX2_TBDR_FTQ_CMD_POP				 (1L<<30)
-#define BNX2_TBDR_FTQ_CMD_BUSY				 (1L<<31)
-
-#define BNX2_TBDR_FTQ_CTL				0x000053fc
-#define BNX2_TBDR_FTQ_CTL_INTERVENE			 (1L<<0)
-#define BNX2_TBDR_FTQ_CTL_OVERFLOW			 (1L<<1)
-#define BNX2_TBDR_FTQ_CTL_FORCE_INTERVENE		 (1L<<2)
-#define BNX2_TBDR_FTQ_CTL_MAX_DEPTH			 (0x3ffL<<12)
-#define BNX2_TBDR_FTQ_CTL_CUR_DEPTH			 (0x3ffL<<22)
-
-
-
-/*
- *  tdma_reg definition
- *  offset: 0x5c00
- */
-#define BNX2_TDMA_COMMAND				0x00005c00
-#define BNX2_TDMA_COMMAND_ENABLED			 (1L<<0)
-#define BNX2_TDMA_COMMAND_MASTER_ABORT			 (1L<<4)
-#define BNX2_TDMA_COMMAND_CS16_ERR			 (1L<<5)
-#define BNX2_TDMA_COMMAND_BAD_L2_LENGTH_ABORT		 (1L<<7)
-#define BNX2_TDMA_COMMAND_MASK_CS1			 (1L<<20)
-#define BNX2_TDMA_COMMAND_MASK_CS2			 (1L<<21)
-#define BNX2_TDMA_COMMAND_MASK_CS3			 (1L<<22)
-#define BNX2_TDMA_COMMAND_MASK_CS4			 (1L<<23)
-#define BNX2_TDMA_COMMAND_FORCE_ILOCK_CKERR		 (1L<<24)
-#define BNX2_TDMA_COMMAND_OFIFO_CLR			 (1L<<30)
-#define BNX2_TDMA_COMMAND_IFIFO_CLR			 (1L<<31)
-
-#define BNX2_TDMA_STATUS				0x00005c04
-#define BNX2_TDMA_STATUS_DMA_WAIT			 (1L<<0)
-#define BNX2_TDMA_STATUS_PAYLOAD_WAIT			 (1L<<1)
-#define BNX2_TDMA_STATUS_PATCH_FTQ_WAIT			 (1L<<2)
-#define BNX2_TDMA_STATUS_LOCK_WAIT			 (1L<<3)
-#define BNX2_TDMA_STATUS_FTQ_ENTRY_CNT			 (1L<<16)
-#define BNX2_TDMA_STATUS_BURST_CNT			 (1L<<17)
-#define BNX2_TDMA_STATUS_MAX_IFIFO_DEPTH		 (0x3fL<<20)
-#define BNX2_TDMA_STATUS_OFIFO_OVERFLOW			 (1L<<30)
-#define BNX2_TDMA_STATUS_IFIFO_OVERFLOW			 (1L<<31)
-
-#define BNX2_TDMA_CONFIG				0x00005c08
-#define BNX2_TDMA_CONFIG_ONE_DMA			 (1L<<0)
-#define BNX2_TDMA_CONFIG_ONE_RECORD			 (1L<<1)
-#define BNX2_TDMA_CONFIG_NUM_DMA_CHAN			 (0x3L<<2)
-#define BNX2_TDMA_CONFIG_NUM_DMA_CHAN_0			 (0L<<2)
-#define BNX2_TDMA_CONFIG_NUM_DMA_CHAN_1			 (1L<<2)
-#define BNX2_TDMA_CONFIG_NUM_DMA_CHAN_2			 (2L<<2)
-#define BNX2_TDMA_CONFIG_NUM_DMA_CHAN_3			 (3L<<2)
-#define BNX2_TDMA_CONFIG_LIMIT_SZ			 (0xfL<<4)
-#define BNX2_TDMA_CONFIG_LIMIT_SZ_64			 (0L<<4)
-#define BNX2_TDMA_CONFIG_LIMIT_SZ_128			 (0x4L<<4)
-#define BNX2_TDMA_CONFIG_LIMIT_SZ_256			 (0x6L<<4)
-#define BNX2_TDMA_CONFIG_LIMIT_SZ_512			 (0x8L<<4)
-#define BNX2_TDMA_CONFIG_LINE_SZ			 (0xfL<<8)
-#define BNX2_TDMA_CONFIG_LINE_SZ_64			 (0L<<8)
-#define BNX2_TDMA_CONFIG_LINE_SZ_128			 (4L<<8)
-#define BNX2_TDMA_CONFIG_LINE_SZ_256			 (6L<<8)
-#define BNX2_TDMA_CONFIG_LINE_SZ_512			 (8L<<8)
-#define BNX2_TDMA_CONFIG_ALIGN_ENA			 (1L<<15)
-#define BNX2_TDMA_CONFIG_CHK_L2_BD			 (1L<<16)
-#define BNX2_TDMA_CONFIG_CMPL_ENTRY			 (1L<<17)
-#define BNX2_TDMA_CONFIG_OFIFO_CMP			 (1L<<19)
-#define BNX2_TDMA_CONFIG_OFIFO_CMP_3			 (0L<<19)
-#define BNX2_TDMA_CONFIG_OFIFO_CMP_2			 (1L<<19)
-#define BNX2_TDMA_CONFIG_FIFO_CMP			 (0xfL<<20)
-#define BNX2_TDMA_CONFIG_IFIFO_DEPTH_XI			 (0x7L<<20)
-#define BNX2_TDMA_CONFIG_IFIFO_DEPTH_0_XI		 (0L<<20)
-#define BNX2_TDMA_CONFIG_IFIFO_DEPTH_4_XI		 (1L<<20)
-#define BNX2_TDMA_CONFIG_IFIFO_DEPTH_8_XI		 (2L<<20)
-#define BNX2_TDMA_CONFIG_IFIFO_DEPTH_16_XI		 (3L<<20)
-#define BNX2_TDMA_CONFIG_IFIFO_DEPTH_32_XI		 (4L<<20)
-#define BNX2_TDMA_CONFIG_IFIFO_DEPTH_64_XI		 (5L<<20)
-#define BNX2_TDMA_CONFIG_FIFO_CMP_EN_XI			 (1L<<23)
-#define BNX2_TDMA_CONFIG_BYTES_OST_XI			 (0x7L<<24)
-#define BNX2_TDMA_CONFIG_BYTES_OST_512_XI		 (0L<<24)
-#define BNX2_TDMA_CONFIG_BYTES_OST_1024_XI		 (1L<<24)
-#define BNX2_TDMA_CONFIG_BYTES_OST_2048_XI		 (2L<<24)
-#define BNX2_TDMA_CONFIG_BYTES_OST_4096_XI		 (3L<<24)
-#define BNX2_TDMA_CONFIG_BYTES_OST_8192_XI		 (4L<<24)
-#define BNX2_TDMA_CONFIG_BYTES_OST_16384_XI		 (5L<<24)
-#define BNX2_TDMA_CONFIG_HC_BYPASS_XI			 (1L<<27)
-#define BNX2_TDMA_CONFIG_LCL_MRRS_XI			 (0x7L<<28)
-#define BNX2_TDMA_CONFIG_LCL_MRRS_128_XI		 (0L<<28)
-#define BNX2_TDMA_CONFIG_LCL_MRRS_256_XI		 (1L<<28)
-#define BNX2_TDMA_CONFIG_LCL_MRRS_512_XI		 (2L<<28)
-#define BNX2_TDMA_CONFIG_LCL_MRRS_1024_XI		 (3L<<28)
-#define BNX2_TDMA_CONFIG_LCL_MRRS_2048_XI		 (4L<<28)
-#define BNX2_TDMA_CONFIG_LCL_MRRS_4096_XI		 (5L<<28)
-#define BNX2_TDMA_CONFIG_LCL_MRRS_EN_XI			 (1L<<31)
-
-#define BNX2_TDMA_PAYLOAD_PROD				0x00005c0c
-#define BNX2_TDMA_PAYLOAD_PROD_VALUE			 (0x1fffL<<3)
-
-#define BNX2_TDMA_DBG_WATCHDOG				0x00005c10
-#define BNX2_TDMA_DBG_TRIGGER				0x00005c14
-#define BNX2_TDMA_DMAD_FSM				0x00005c80
-#define BNX2_TDMA_DMAD_FSM_BD_INVLD			 (1L<<0)
-#define BNX2_TDMA_DMAD_FSM_PUSH				 (0xfL<<4)
-#define BNX2_TDMA_DMAD_FSM_ARB_TBDC			 (0x3L<<8)
-#define BNX2_TDMA_DMAD_FSM_ARB_CTX			 (1L<<12)
-#define BNX2_TDMA_DMAD_FSM_DR_INTF			 (1L<<16)
-#define BNX2_TDMA_DMAD_FSM_DMAD				 (0x7L<<20)
-#define BNX2_TDMA_DMAD_FSM_BD				 (0xfL<<24)
-
-#define BNX2_TDMA_DMAD_STATUS				0x00005c84
-#define BNX2_TDMA_DMAD_STATUS_RHOLD_PUSH_ENTRY		 (0x3L<<0)
-#define BNX2_TDMA_DMAD_STATUS_RHOLD_DMAD_ENTRY		 (0x3L<<4)
-#define BNX2_TDMA_DMAD_STATUS_RHOLD_BD_ENTRY		 (0x3L<<8)
-#define BNX2_TDMA_DMAD_STATUS_IFTQ_ENUM			 (0xfL<<12)
-
-#define BNX2_TDMA_DR_INTF_FSM				0x00005c88
-#define BNX2_TDMA_DR_INTF_FSM_L2_COMP			 (0x3L<<0)
-#define BNX2_TDMA_DR_INTF_FSM_TPATQ			 (0x7L<<4)
-#define BNX2_TDMA_DR_INTF_FSM_TPBUF			 (0x3L<<8)
-#define BNX2_TDMA_DR_INTF_FSM_DR_BUF			 (0x7L<<12)
-#define BNX2_TDMA_DR_INTF_FSM_DMAD			 (0x7L<<16)
-
-#define BNX2_TDMA_DR_INTF_STATUS			0x00005c8c
-#define BNX2_TDMA_DR_INTF_STATUS_HOLE_PHASE		 (0x7L<<0)
-#define BNX2_TDMA_DR_INTF_STATUS_DATA_AVAIL		 (0x3L<<4)
-#define BNX2_TDMA_DR_INTF_STATUS_SHIFT_ADDR		 (0x7L<<8)
-#define BNX2_TDMA_DR_INTF_STATUS_NXT_PNTR		 (0xfL<<12)
-#define BNX2_TDMA_DR_INTF_STATUS_BYTE_COUNT		 (0x7L<<16)
-
-#define BNX2_TDMA_PUSH_FSM				0x00005c90
-#define BNX2_TDMA_BD_IF_DEBUG				0x00005c94
-#define BNX2_TDMA_DMAD_IF_DEBUG				0x00005c98
-#define BNX2_TDMA_CTX_IF_DEBUG				0x00005c9c
-#define BNX2_TDMA_TPBUF_IF_DEBUG			0x00005ca0
-#define BNX2_TDMA_DR_IF_DEBUG				0x00005ca4
-#define BNX2_TDMA_TPATQ_IF_DEBUG			0x00005ca8
-#define BNX2_TDMA_TDMA_ILOCK_CKSUM			0x00005cac
-#define BNX2_TDMA_TDMA_ILOCK_CKSUM_CALCULATED		 (0xffffL<<0)
-#define BNX2_TDMA_TDMA_ILOCK_CKSUM_EXPECTED		 (0xffffL<<16)
-
-#define BNX2_TDMA_TDMA_PCIE_CKSUM			0x00005cb0
-#define BNX2_TDMA_TDMA_PCIE_CKSUM_CALCULATED		 (0xffffL<<0)
-#define BNX2_TDMA_TDMA_PCIE_CKSUM_EXPECTED		 (0xffffL<<16)
-
-#define BNX2_TDMA_TDMAQ					0x00005fc0
-#define BNX2_TDMA_FTQ_CMD				0x00005ff8
-#define BNX2_TDMA_FTQ_CMD_OFFSET			 (0x3ffL<<0)
-#define BNX2_TDMA_FTQ_CMD_WR_TOP			 (1L<<10)
-#define BNX2_TDMA_FTQ_CMD_WR_TOP_0			 (0L<<10)
-#define BNX2_TDMA_FTQ_CMD_WR_TOP_1			 (1L<<10)
-#define BNX2_TDMA_FTQ_CMD_SFT_RESET			 (1L<<25)
-#define BNX2_TDMA_FTQ_CMD_RD_DATA			 (1L<<26)
-#define BNX2_TDMA_FTQ_CMD_ADD_INTERVEN			 (1L<<27)
-#define BNX2_TDMA_FTQ_CMD_ADD_DATA			 (1L<<28)
-#define BNX2_TDMA_FTQ_CMD_INTERVENE_CLR			 (1L<<29)
-#define BNX2_TDMA_FTQ_CMD_POP				 (1L<<30)
-#define BNX2_TDMA_FTQ_CMD_BUSY				 (1L<<31)
-
-#define BNX2_TDMA_FTQ_CTL				0x00005ffc
-#define BNX2_TDMA_FTQ_CTL_INTERVENE			 (1L<<0)
-#define BNX2_TDMA_FTQ_CTL_OVERFLOW			 (1L<<1)
-#define BNX2_TDMA_FTQ_CTL_FORCE_INTERVENE		 (1L<<2)
-#define BNX2_TDMA_FTQ_CTL_MAX_DEPTH			 (0x3ffL<<12)
-#define BNX2_TDMA_FTQ_CTL_CUR_DEPTH			 (0x3ffL<<22)
-
-
-
-/*
- *  hc_reg definition
- *  offset: 0x6800
- */
-#define BNX2_HC_COMMAND					0x00006800
-#define BNX2_HC_COMMAND_ENABLE				 (1L<<0)
-#define BNX2_HC_COMMAND_SKIP_ABORT			 (1L<<4)
-#define BNX2_HC_COMMAND_COAL_NOW			 (1L<<16)
-#define BNX2_HC_COMMAND_COAL_NOW_WO_INT			 (1L<<17)
-#define BNX2_HC_COMMAND_STATS_NOW			 (1L<<18)
-#define BNX2_HC_COMMAND_FORCE_INT			 (0x3L<<19)
-#define BNX2_HC_COMMAND_FORCE_INT_NULL			 (0L<<19)
-#define BNX2_HC_COMMAND_FORCE_INT_HIGH			 (1L<<19)
-#define BNX2_HC_COMMAND_FORCE_INT_LOW			 (2L<<19)
-#define BNX2_HC_COMMAND_FORCE_INT_FREE			 (3L<<19)
-#define BNX2_HC_COMMAND_CLR_STAT_NOW			 (1L<<21)
-#define BNX2_HC_COMMAND_MAIN_PWR_INT			 (1L<<22)
-#define BNX2_HC_COMMAND_COAL_ON_NEXT_EVENT		 (1L<<27)
-
-#define BNX2_HC_STATUS					0x00006804
-#define BNX2_HC_STATUS_MASTER_ABORT			 (1L<<0)
-#define BNX2_HC_STATUS_PARITY_ERROR_STATE		 (1L<<1)
-#define BNX2_HC_STATUS_PCI_CLK_CNT_STAT			 (1L<<16)
-#define BNX2_HC_STATUS_CORE_CLK_CNT_STAT		 (1L<<17)
-#define BNX2_HC_STATUS_NUM_STATUS_BLOCKS_STAT		 (1L<<18)
-#define BNX2_HC_STATUS_NUM_INT_GEN_STAT			 (1L<<19)
-#define BNX2_HC_STATUS_NUM_INT_MBOX_WR_STAT		 (1L<<20)
-#define BNX2_HC_STATUS_CORE_CLKS_TO_HW_INTACK_STAT	 (1L<<23)
-#define BNX2_HC_STATUS_CORE_CLKS_TO_SW_INTACK_STAT	 (1L<<24)
-#define BNX2_HC_STATUS_CORE_CLKS_DURING_SW_INTACK_STAT	 (1L<<25)
-
-#define BNX2_HC_CONFIG					0x00006808
-#define BNX2_HC_CONFIG_COLLECT_STATS			 (1L<<0)
-#define BNX2_HC_CONFIG_RX_TMR_MODE			 (1L<<1)
-#define BNX2_HC_CONFIG_TX_TMR_MODE			 (1L<<2)
-#define BNX2_HC_CONFIG_COM_TMR_MODE			 (1L<<3)
-#define BNX2_HC_CONFIG_CMD_TMR_MODE			 (1L<<4)
-#define BNX2_HC_CONFIG_STATISTIC_PRIORITY		 (1L<<5)
-#define BNX2_HC_CONFIG_STATUS_PRIORITY			 (1L<<6)
-#define BNX2_HC_CONFIG_STAT_MEM_ADDR			 (0xffL<<8)
-#define BNX2_HC_CONFIG_PER_MODE				 (1L<<16)
-#define BNX2_HC_CONFIG_ONE_SHOT				 (1L<<17)
-#define BNX2_HC_CONFIG_USE_INT_PARAM			 (1L<<18)
-#define BNX2_HC_CONFIG_SET_MASK_AT_RD			 (1L<<19)
-#define BNX2_HC_CONFIG_PER_COLLECT_LIMIT		 (0xfL<<20)
-#define BNX2_HC_CONFIG_SB_ADDR_INC			 (0x7L<<24)
-#define BNX2_HC_CONFIG_SB_ADDR_INC_64B			 (0L<<24)
-#define BNX2_HC_CONFIG_SB_ADDR_INC_128B			 (1L<<24)
-#define BNX2_HC_CONFIG_SB_ADDR_INC_256B			 (2L<<24)
-#define BNX2_HC_CONFIG_SB_ADDR_INC_512B			 (3L<<24)
-#define BNX2_HC_CONFIG_SB_ADDR_INC_1024B		 (4L<<24)
-#define BNX2_HC_CONFIG_SB_ADDR_INC_2048B		 (5L<<24)
-#define BNX2_HC_CONFIG_SB_ADDR_INC_4096B		 (6L<<24)
-#define BNX2_HC_CONFIG_SB_ADDR_INC_8192B		 (7L<<24)
-#define BNX2_HC_CONFIG_GEN_STAT_AVG_INTR		 (1L<<29)
-#define BNX2_HC_CONFIG_UNMASK_ALL			 (1L<<30)
-#define BNX2_HC_CONFIG_TX_SEL				 (1L<<31)
-
-#define BNX2_HC_ATTN_BITS_ENABLE			0x0000680c
-#define BNX2_HC_STATUS_ADDR_L				0x00006810
-#define BNX2_HC_STATUS_ADDR_H				0x00006814
-#define BNX2_HC_STATISTICS_ADDR_L			0x00006818
-#define BNX2_HC_STATISTICS_ADDR_H			0x0000681c
-#define BNX2_HC_TX_QUICK_CONS_TRIP			0x00006820
-#define BNX2_HC_TX_QUICK_CONS_TRIP_VALUE		 (0xffL<<0)
-#define BNX2_HC_TX_QUICK_CONS_TRIP_INT			 (0xffL<<16)
-
-#define BNX2_HC_COMP_PROD_TRIP				0x00006824
-#define BNX2_HC_COMP_PROD_TRIP_VALUE			 (0xffL<<0)
-#define BNX2_HC_COMP_PROD_TRIP_INT			 (0xffL<<16)
-
-#define BNX2_HC_RX_QUICK_CONS_TRIP			0x00006828
-#define BNX2_HC_RX_QUICK_CONS_TRIP_VALUE		 (0xffL<<0)
-#define BNX2_HC_RX_QUICK_CONS_TRIP_INT			 (0xffL<<16)
-
-#define BNX2_HC_RX_TICKS				0x0000682c
-#define BNX2_HC_RX_TICKS_VALUE				 (0x3ffL<<0)
-#define BNX2_HC_RX_TICKS_INT				 (0x3ffL<<16)
-
-#define BNX2_HC_TX_TICKS				0x00006830
-#define BNX2_HC_TX_TICKS_VALUE				 (0x3ffL<<0)
-#define BNX2_HC_TX_TICKS_INT				 (0x3ffL<<16)
-
-#define BNX2_HC_COM_TICKS				0x00006834
-#define BNX2_HC_COM_TICKS_VALUE				 (0x3ffL<<0)
-#define BNX2_HC_COM_TICKS_INT				 (0x3ffL<<16)
-
-#define BNX2_HC_CMD_TICKS				0x00006838
-#define BNX2_HC_CMD_TICKS_VALUE				 (0x3ffL<<0)
-#define BNX2_HC_CMD_TICKS_INT				 (0x3ffL<<16)
-
-#define BNX2_HC_PERIODIC_TICKS				0x0000683c
-#define BNX2_HC_PERIODIC_TICKS_HC_PERIODIC_TICKS	 (0xffffL<<0)
-#define BNX2_HC_PERIODIC_TICKS_HC_INT_PERIODIC_TICKS	 (0xffffL<<16)
-
-#define BNX2_HC_STAT_COLLECT_TICKS			0x00006840
-#define BNX2_HC_STAT_COLLECT_TICKS_HC_STAT_COLL_TICKS	 (0xffL<<4)
-
-#define BNX2_HC_STATS_TICKS				0x00006844
-#define BNX2_HC_STATS_TICKS_HC_STAT_TICKS		 (0xffffL<<8)
-
-#define BNX2_HC_STATS_INTERRUPT_STATUS			0x00006848
-#define BNX2_HC_STATS_INTERRUPT_STATUS_SB_STATUS	 (0x1ffL<<0)
-#define BNX2_HC_STATS_INTERRUPT_STATUS_INT_STATUS	 (0x1ffL<<16)
-
-#define BNX2_HC_STAT_MEM_DATA				0x0000684c
-#define BNX2_HC_STAT_GEN_SEL_0				0x00006850
-#define BNX2_HC_STAT_GEN_SEL_0_GEN_SEL_0		 (0x7fL<<0)
-#define BNX2_HC_STAT_GEN_SEL_0_GEN_SEL_0_RXP_STAT0	 (0L<<0)
-#define BNX2_HC_STAT_GEN_SEL_0_GEN_SEL_0_RXP_STAT1	 (1L<<0)
-#define BNX2_HC_STAT_GEN_SEL_0_GEN_SEL_0_RXP_STAT2	 (2L<<0)
-#define BNX2_HC_STAT_GEN_SEL_0_GEN_SEL_0_RXP_STAT3	 (3L<<0)
-#define BNX2_HC_STAT_GEN_SEL_0_GEN_SEL_0_RXP_STAT4	 (4L<<0)
-#define BNX2_HC_STAT_GEN_SEL_0_GEN_SEL_0_RXP_STAT5	 (5L<<0)
-#define BNX2_HC_STAT_GEN_SEL_0_GEN_SEL_0_RXP_STAT6	 (6L<<0)
-#define BNX2_HC_STAT_GEN_SEL_0_GEN_SEL_0_RXP_STAT7	 (7L<<0)
-#define BNX2_HC_STAT_GEN_SEL_0_GEN_SEL_0_RXP_STAT8	 (8L<<0)
-#define BNX2_HC_STAT_GEN_SEL_0_GEN_SEL_0_RXP_STAT9	 (9L<<0)
-#define BNX2_HC_STAT_GEN_SEL_0_GEN_SEL_0_RXP_STAT10	 (10L<<0)
-#define BNX2_HC_STAT_GEN_SEL_0_GEN_SEL_0_RXP_STAT11	 (11L<<0)
-#define BNX2_HC_STAT_GEN_SEL_0_GEN_SEL_0_TXP_STAT0	 (12L<<0)
-#define BNX2_HC_STAT_GEN_SEL_0_GEN_SEL_0_TXP_STAT1	 (13L<<0)
-#define BNX2_HC_STAT_GEN_SEL_0_GEN_SEL_0_TXP_STAT2	 (14L<<0)
-#define BNX2_HC_STAT_GEN_SEL_0_GEN_SEL_0_TXP_STAT3	 (15L<<0)
-#define BNX2_HC_STAT_GEN_SEL_0_GEN_SEL_0_TXP_STAT4	 (16L<<0)
-#define BNX2_HC_STAT_GEN_SEL_0_GEN_SEL_0_TXP_STAT5	 (17L<<0)
-#define BNX2_HC_STAT_GEN_SEL_0_GEN_SEL_0_TXP_STAT6	 (18L<<0)
-#define BNX2_HC_STAT_GEN_SEL_0_GEN_SEL_0_TXP_STAT7	 (19L<<0)
-#define BNX2_HC_STAT_GEN_SEL_0_GEN_SEL_0_COM_STAT0	 (20L<<0)
-#define BNX2_HC_STAT_GEN_SEL_0_GEN_SEL_0_COM_STAT1	 (21L<<0)
-#define BNX2_HC_STAT_GEN_SEL_0_GEN_SEL_0_COM_STAT2	 (22L<<0)
-#define BNX2_HC_STAT_GEN_SEL_0_GEN_SEL_0_COM_STAT3	 (23L<<0)
-#define BNX2_HC_STAT_GEN_SEL_0_GEN_SEL_0_COM_STAT4	 (24L<<0)
-#define BNX2_HC_STAT_GEN_SEL_0_GEN_SEL_0_COM_STAT5	 (25L<<0)
-#define BNX2_HC_STAT_GEN_SEL_0_GEN_SEL_0_COM_STAT6	 (26L<<0)
-#define BNX2_HC_STAT_GEN_SEL_0_GEN_SEL_0_COM_STAT7	 (27L<<0)
-#define BNX2_HC_STAT_GEN_SEL_0_GEN_SEL_0_COM_STAT8	 (28L<<0)
-#define BNX2_HC_STAT_GEN_SEL_0_GEN_SEL_0_COM_STAT9	 (29L<<0)
-#define BNX2_HC_STAT_GEN_SEL_0_GEN_SEL_0_COM_STAT10	 (30L<<0)
-#define BNX2_HC_STAT_GEN_SEL_0_GEN_SEL_0_COM_STAT11	 (31L<<0)
-#define BNX2_HC_STAT_GEN_SEL_0_GEN_SEL_0_TPAT_STAT0	 (32L<<0)
-#define BNX2_HC_STAT_GEN_SEL_0_GEN_SEL_0_TPAT_STAT1	 (33L<<0)
-#define BNX2_HC_STAT_GEN_SEL_0_GEN_SEL_0_TPAT_STAT2	 (34L<<0)
-#define BNX2_HC_STAT_GEN_SEL_0_GEN_SEL_0_TPAT_STAT3	 (35L<<0)
-#define BNX2_HC_STAT_GEN_SEL_0_GEN_SEL_0_CP_STAT0	 (36L<<0)
-#define BNX2_HC_STAT_GEN_SEL_0_GEN_SEL_0_CP_STAT1	 (37L<<0)
-#define BNX2_HC_STAT_GEN_SEL_0_GEN_SEL_0_CP_STAT2	 (38L<<0)
-#define BNX2_HC_STAT_GEN_SEL_0_GEN_SEL_0_CP_STAT3	 (39L<<0)
-#define BNX2_HC_STAT_GEN_SEL_0_GEN_SEL_0_CP_STAT4	 (40L<<0)
-#define BNX2_HC_STAT_GEN_SEL_0_GEN_SEL_0_CP_STAT5	 (41L<<0)
-#define BNX2_HC_STAT_GEN_SEL_0_GEN_SEL_0_CP_STAT6	 (42L<<0)
-#define BNX2_HC_STAT_GEN_SEL_0_GEN_SEL_0_CP_STAT7	 (43L<<0)
-#define BNX2_HC_STAT_GEN_SEL_0_GEN_SEL_0_MCP_STAT0	 (44L<<0)
-#define BNX2_HC_STAT_GEN_SEL_0_GEN_SEL_0_MCP_STAT1	 (45L<<0)
-#define BNX2_HC_STAT_GEN_SEL_0_GEN_SEL_0_MCP_STAT2	 (46L<<0)
-#define BNX2_HC_STAT_GEN_SEL_0_GEN_SEL_0_MCP_STAT3	 (47L<<0)
-#define BNX2_HC_STAT_GEN_SEL_0_GEN_SEL_0_MCP_STAT4	 (48L<<0)
-#define BNX2_HC_STAT_GEN_SEL_0_GEN_SEL_0_MCP_STAT5	 (49L<<0)
-#define BNX2_HC_STAT_GEN_SEL_0_GEN_SEL_0_MCP_STAT6	 (50L<<0)
-#define BNX2_HC_STAT_GEN_SEL_0_GEN_SEL_0_MCP_STAT7	 (51L<<0)
-#define BNX2_HC_STAT_GEN_SEL_0_GEN_SEL_0_PCI_CLK_CNT	 (52L<<0)
-#define BNX2_HC_STAT_GEN_SEL_0_GEN_SEL_0_CORE_CLK_CNT	 (53L<<0)
-#define BNX2_HC_STAT_GEN_SEL_0_GEN_SEL_0_HC_NUM_STATUS_BLOCKS	 (54L<<0)
-#define BNX2_HC_STAT_GEN_SEL_0_GEN_SEL_0_HC_NUM_INT_GEN	 (55L<<0)
-#define BNX2_HC_STAT_GEN_SEL_0_GEN_SEL_0_HC_NUM_INT_MBOX_WR	 (56L<<0)
-#define BNX2_HC_STAT_GEN_SEL_0_GEN_SEL_0_HC_CORE_CLKS_TO_HW_INTACK	 (59L<<0)
-#define BNX2_HC_STAT_GEN_SEL_0_GEN_SEL_0_HC_CORE_CLKS_TO_SW_INTACK	 (60L<<0)
-#define BNX2_HC_STAT_GEN_SEL_0_GEN_SEL_0_HC_CORE_CLKS_DURING_SW_INTACK	 (61L<<0)
-#define BNX2_HC_STAT_GEN_SEL_0_GEN_SEL_0_TSCH_CMD_CNT	 (62L<<0)
-#define BNX2_HC_STAT_GEN_SEL_0_GEN_SEL_0_TSCH_SLOT_CNT	 (63L<<0)
-#define BNX2_HC_STAT_GEN_SEL_0_GEN_SEL_0_CSCH_CMD_CNT	 (64L<<0)
-#define BNX2_HC_STAT_GEN_SEL_0_GEN_SEL_0_CSCH_SLOT_CNT	 (65L<<0)
-#define BNX2_HC_STAT_GEN_SEL_0_GEN_SEL_0_RLUPQ_VALID_CNT	 (66L<<0)
-#define BNX2_HC_STAT_GEN_SEL_0_GEN_SEL_0_RXPQ_VALID_CNT	 (67L<<0)
-#define BNX2_HC_STAT_GEN_SEL_0_GEN_SEL_0_RXPCQ_VALID_CNT	 (68L<<0)
-#define BNX2_HC_STAT_GEN_SEL_0_GEN_SEL_0_RV2PPQ_VALID_CNT	 (69L<<0)
-#define BNX2_HC_STAT_GEN_SEL_0_GEN_SEL_0_RV2PMQ_VALID_CNT	 (70L<<0)
-#define BNX2_HC_STAT_GEN_SEL_0_GEN_SEL_0_RV2PTQ_VALID_CNT	 (71L<<0)
-#define BNX2_HC_STAT_GEN_SEL_0_GEN_SEL_0_RDMAQ_VALID_CNT	 (72L<<0)
-#define BNX2_HC_STAT_GEN_SEL_0_GEN_SEL_0_TSCHQ_VALID_CNT	 (73L<<0)
-#define BNX2_HC_STAT_GEN_SEL_0_GEN_SEL_0_TBDRQ_VALID_CNT	 (74L<<0)
-#define BNX2_HC_STAT_GEN_SEL_0_GEN_SEL_0_TXPQ_VALID_CNT	 (75L<<0)
-#define BNX2_HC_STAT_GEN_SEL_0_GEN_SEL_0_TDMAQ_VALID_CNT	 (76L<<0)
-#define BNX2_HC_STAT_GEN_SEL_0_GEN_SEL_0_TPATQ_VALID_CNT	 (77L<<0)
-#define BNX2_HC_STAT_GEN_SEL_0_GEN_SEL_0_TASQ_VALID_CNT	 (78L<<0)
-#define BNX2_HC_STAT_GEN_SEL_0_GEN_SEL_0_CSQ_VALID_CNT	 (79L<<0)
-#define BNX2_HC_STAT_GEN_SEL_0_GEN_SEL_0_CPQ_VALID_CNT	 (80L<<0)
-#define BNX2_HC_STAT_GEN_SEL_0_GEN_SEL_0_COMXQ_VALID_CNT	 (81L<<0)
-#define BNX2_HC_STAT_GEN_SEL_0_GEN_SEL_0_COMTQ_VALID_CNT	 (82L<<0)
-#define BNX2_HC_STAT_GEN_SEL_0_GEN_SEL_0_COMQ_VALID_CNT	 (83L<<0)
-#define BNX2_HC_STAT_GEN_SEL_0_GEN_SEL_0_MGMQ_VALID_CNT	 (84L<<0)
-#define BNX2_HC_STAT_GEN_SEL_0_GEN_SEL_0_DMAE_READ_TRANSFERS_CNT	 (85L<<0)
-#define BNX2_HC_STAT_GEN_SEL_0_GEN_SEL_0_DMAE_READ_DELAY_PCI_CLKS_CNT	 (86L<<0)
-#define BNX2_HC_STAT_GEN_SEL_0_GEN_SEL_0_DMAE_BIG_READ_TRANSFERS_CNT	 (87L<<0)
-#define BNX2_HC_STAT_GEN_SEL_0_GEN_SEL_0_DMAE_BIG_READ_DELAY_PCI_CLKS_CNT	 (88L<<0)
-#define BNX2_HC_STAT_GEN_SEL_0_GEN_SEL_0_DMAE_BIG_READ_RETRY_AFTER_DATA_CNT	 (89L<<0)
-#define BNX2_HC_STAT_GEN_SEL_0_GEN_SEL_0_DMAE_WRITE_TRANSFERS_CNT	 (90L<<0)
-#define BNX2_HC_STAT_GEN_SEL_0_GEN_SEL_0_DMAE_WRITE_DELAY_PCI_CLKS_CNT	 (91L<<0)
-#define BNX2_HC_STAT_GEN_SEL_0_GEN_SEL_0_DMAE_BIG_WRITE_TRANSFERS_CNT	 (92L<<0)
-#define BNX2_HC_STAT_GEN_SEL_0_GEN_SEL_0_DMAE_BIG_WRITE_DELAY_PCI_CLKS_CNT	 (93L<<0)
-#define BNX2_HC_STAT_GEN_SEL_0_GEN_SEL_0_DMAE_BIG_WRITE_RETRY_AFTER_DATA_CNT	 (94L<<0)
-#define BNX2_HC_STAT_GEN_SEL_0_GEN_SEL_0_CTX_WR_CNT64	 (95L<<0)
-#define BNX2_HC_STAT_GEN_SEL_0_GEN_SEL_0_CTX_RD_CNT64	 (96L<<0)
-#define BNX2_HC_STAT_GEN_SEL_0_GEN_SEL_0_CTX_ACC_STALL_CLKS	 (97L<<0)
-#define BNX2_HC_STAT_GEN_SEL_0_GEN_SEL_0_CTX_LOCK_STALL_CLKS	 (98L<<0)
-#define BNX2_HC_STAT_GEN_SEL_0_GEN_SEL_0_MBQ_CTX_ACCESS_STAT	 (99L<<0)
-#define BNX2_HC_STAT_GEN_SEL_0_GEN_SEL_0_MBQ_CTX_ACCESS64_STAT	 (100L<<0)
-#define BNX2_HC_STAT_GEN_SEL_0_GEN_SEL_0_MBQ_PCI_STALL_STAT	 (101L<<0)
-#define BNX2_HC_STAT_GEN_SEL_0_GEN_SEL_0_TBDR_FTQ_ENTRY_CNT	 (102L<<0)
-#define BNX2_HC_STAT_GEN_SEL_0_GEN_SEL_0_TBDR_BURST_CNT	 (103L<<0)
-#define BNX2_HC_STAT_GEN_SEL_0_GEN_SEL_0_TDMA_FTQ_ENTRY_CNT	 (104L<<0)
-#define BNX2_HC_STAT_GEN_SEL_0_GEN_SEL_0_TDMA_BURST_CNT	 (105L<<0)
-#define BNX2_HC_STAT_GEN_SEL_0_GEN_SEL_0_RDMA_FTQ_ENTRY_CNT	 (106L<<0)
-#define BNX2_HC_STAT_GEN_SEL_0_GEN_SEL_0_RDMA_BURST_CNT	 (107L<<0)
-#define BNX2_HC_STAT_GEN_SEL_0_GEN_SEL_0_RLUP_MATCH_CNT	 (108L<<0)
-#define BNX2_HC_STAT_GEN_SEL_0_GEN_SEL_0_TMR_POLL_PASS_CNT	 (109L<<0)
-#define BNX2_HC_STAT_GEN_SEL_0_GEN_SEL_0_TMR_TMR1_CNT	 (110L<<0)
-#define BNX2_HC_STAT_GEN_SEL_0_GEN_SEL_0_TMR_TMR2_CNT	 (111L<<0)
-#define BNX2_HC_STAT_GEN_SEL_0_GEN_SEL_0_TMR_TMR3_CNT	 (112L<<0)
-#define BNX2_HC_STAT_GEN_SEL_0_GEN_SEL_0_TMR_TMR4_CNT	 (113L<<0)
-#define BNX2_HC_STAT_GEN_SEL_0_GEN_SEL_0_TMR_TMR5_CNT	 (114L<<0)
-#define BNX2_HC_STAT_GEN_SEL_0_GEN_SEL_0_RV2P_STAT0	 (115L<<0)
-#define BNX2_HC_STAT_GEN_SEL_0_GEN_SEL_0_RV2P_STAT1	 (116L<<0)
-#define BNX2_HC_STAT_GEN_SEL_0_GEN_SEL_0_RV2P_STAT2	 (117L<<0)
-#define BNX2_HC_STAT_GEN_SEL_0_GEN_SEL_0_RV2P_STAT3	 (118L<<0)
-#define BNX2_HC_STAT_GEN_SEL_0_GEN_SEL_0_RV2P_STAT4	 (119L<<0)
-#define BNX2_HC_STAT_GEN_SEL_0_GEN_SEL_0_RV2P_STAT5	 (120L<<0)
-#define BNX2_HC_STAT_GEN_SEL_0_GEN_SEL_0_RBDC_PROC1_MISS	 (121L<<0)
-#define BNX2_HC_STAT_GEN_SEL_0_GEN_SEL_0_RBDC_PROC2_MISS	 (122L<<0)
-#define BNX2_HC_STAT_GEN_SEL_0_GEN_SEL_0_RBDC_BURST_CNT	 (127L<<0)
-#define BNX2_HC_STAT_GEN_SEL_0_GEN_SEL_1		 (0x7fL<<8)
-#define BNX2_HC_STAT_GEN_SEL_0_GEN_SEL_2		 (0x7fL<<16)
-#define BNX2_HC_STAT_GEN_SEL_0_GEN_SEL_3		 (0x7fL<<24)
-#define BNX2_HC_STAT_GEN_SEL_0_GEN_SEL_0_XI		 (0xffL<<0)
-#define BNX2_HC_STAT_GEN_SEL_0_GEN_SEL_0_UMP_RX_FRAME_DROP_XI	 (52L<<0)
-#define BNX2_HC_STAT_GEN_SEL_0_GEN_SEL_0_UNUSED_S0_XI	 (57L<<0)
-#define BNX2_HC_STAT_GEN_SEL_0_GEN_SEL_0_UNUSED_S1_XI	 (58L<<0)
-#define BNX2_HC_STAT_GEN_SEL_0_GEN_SEL_0_UNUSED_S2_XI	 (85L<<0)
-#define BNX2_HC_STAT_GEN_SEL_0_GEN_SEL_0_UNUSED_S3_XI	 (86L<<0)
-#define BNX2_HC_STAT_GEN_SEL_0_GEN_SEL_0_UNUSED_S4_XI	 (87L<<0)
-#define BNX2_HC_STAT_GEN_SEL_0_GEN_SEL_0_UNUSED_S5_XI	 (88L<<0)
-#define BNX2_HC_STAT_GEN_SEL_0_GEN_SEL_0_UNUSED_S6_XI	 (89L<<0)
-#define BNX2_HC_STAT_GEN_SEL_0_GEN_SEL_0_UNUSED_S7_XI	 (90L<<0)
-#define BNX2_HC_STAT_GEN_SEL_0_GEN_SEL_0_UNUSED_S8_XI	 (91L<<0)
-#define BNX2_HC_STAT_GEN_SEL_0_GEN_SEL_0_UNUSED_S9_XI	 (92L<<0)
-#define BNX2_HC_STAT_GEN_SEL_0_GEN_SEL_0_UNUSED_S10_XI	 (93L<<0)
-#define BNX2_HC_STAT_GEN_SEL_0_GEN_SEL_0_MQ_IDB_OFLOW_XI	 (94L<<0)
-#define BNX2_HC_STAT_GEN_SEL_0_GEN_SEL_0_CTX_BLK_RD_CNT_XI	 (123L<<0)
-#define BNX2_HC_STAT_GEN_SEL_0_GEN_SEL_0_CTX_BLK_WR_CNT_XI	 (124L<<0)
-#define BNX2_HC_STAT_GEN_SEL_0_GEN_SEL_0_CTX_HITS_XI	 (125L<<0)
-#define BNX2_HC_STAT_GEN_SEL_0_GEN_SEL_0_CTX_MISSES_XI	 (126L<<0)
-#define BNX2_HC_STAT_GEN_SEL_0_GEN_SEL_0_HC_NUM_STATUS_BLOCKS_VEC1_XI	 (128L<<0)
-#define BNX2_HC_STAT_GEN_SEL_0_GEN_SEL_0_HC_NUM_INT_GEN_VEC1_XI	 (129L<<0)
-#define BNX2_HC_STAT_GEN_SEL_0_GEN_SEL_0_HC_NUM_INT_MBOX_WR_VEC1_XI	 (130L<<0)
-#define BNX2_HC_STAT_GEN_SEL_0_GEN_SEL_0_HC_CORE_CLKS_TO_HW_INTACK_VEC1_XI	 (131L<<0)
-#define BNX2_HC_STAT_GEN_SEL_0_GEN_SEL_0_HC_CORE_CLKS_TO_SW_INTACK_VEC1_XI	 (132L<<0)
-#define BNX2_HC_STAT_GEN_SEL_0_GEN_SEL_0_HC_CORE_CLKS_DURING_SW_INTACK_VEC1_XI	 (133L<<0)
-#define BNX2_HC_STAT_GEN_SEL_0_GEN_SEL_0_HC_NUM_STATUS_BLOCKS_VEC2_XI	 (134L<<0)
-#define BNX2_HC_STAT_GEN_SEL_0_GEN_SEL_0_HC_NUM_INT_GEN_VEC2_XI	 (135L<<0)
-#define BNX2_HC_STAT_GEN_SEL_0_GEN_SEL_0_HC_NUM_INT_MBOX_WR_VEC2_XI	 (136L<<0)
-#define BNX2_HC_STAT_GEN_SEL_0_GEN_SEL_0_HC_CORE_CLKS_TO_HW_INTACK_VEC2_XI	 (137L<<0)
-#define BNX2_HC_STAT_GEN_SEL_0_GEN_SEL_0_HC_CORE_CLKS_TO_SW_INTACK_VEC2_XI	 (138L<<0)
-#define BNX2_HC_STAT_GEN_SEL_0_GEN_SEL_0_HC_CORE_CLKS_DURING_SW_INTACK_VEC2_XI	 (139L<<0)
-#define BNX2_HC_STAT_GEN_SEL_0_GEN_SEL_0_HC_NUM_STATUS_BLOCKS_VEC3_XI	 (140L<<0)
-#define BNX2_HC_STAT_GEN_SEL_0_GEN_SEL_0_HC_NUM_INT_GEN_VEC3_XI	 (141L<<0)
-#define BNX2_HC_STAT_GEN_SEL_0_GEN_SEL_0_HC_NUM_INT_MBOX_WR_VEC3_XI	 (142L<<0)
-#define BNX2_HC_STAT_GEN_SEL_0_GEN_SEL_0_HC_CORE_CLKS_TO_HW_INTACK_VEC3_XI	 (143L<<0)
-#define BNX2_HC_STAT_GEN_SEL_0_GEN_SEL_0_HC_CORE_CLKS_TO_SW_INTACK_VEC3_XI	 (144L<<0)
-#define BNX2_HC_STAT_GEN_SEL_0_GEN_SEL_0_HC_CORE_CLKS_DURING_SW_INTACK_VEC3_XI	 (145L<<0)
-#define BNX2_HC_STAT_GEN_SEL_0_GEN_SEL_0_HC_NUM_STATUS_BLOCKS_VEC4_XI	 (146L<<0)
-#define BNX2_HC_STAT_GEN_SEL_0_GEN_SEL_0_HC_NUM_INT_GEN_VEC4_XI	 (147L<<0)
-#define BNX2_HC_STAT_GEN_SEL_0_GEN_SEL_0_HC_NUM_INT_MBOX_WR_VEC4_XI	 (148L<<0)
-#define BNX2_HC_STAT_GEN_SEL_0_GEN_SEL_0_HC_CORE_CLKS_TO_HW_INTACK_VEC4_XI	 (149L<<0)
-#define BNX2_HC_STAT_GEN_SEL_0_GEN_SEL_0_HC_CORE_CLKS_TO_SW_INTACK_VEC4_XI	 (150L<<0)
-#define BNX2_HC_STAT_GEN_SEL_0_GEN_SEL_0_HC_CORE_CLKS_DURING_SW_INTACK_VEC4_XI	 (151L<<0)
-#define BNX2_HC_STAT_GEN_SEL_0_GEN_SEL_0_HC_NUM_STATUS_BLOCKS_VEC5_XI	 (152L<<0)
-#define BNX2_HC_STAT_GEN_SEL_0_GEN_SEL_0_HC_NUM_INT_GEN_VEC5_XI	 (153L<<0)
-#define BNX2_HC_STAT_GEN_SEL_0_GEN_SEL_0_HC_NUM_INT_MBOX_WR_VEC5_XI	 (154L<<0)
-#define BNX2_HC_STAT_GEN_SEL_0_GEN_SEL_0_HC_CORE_CLKS_TO_HW_INTACK_VEC5_XI	 (155L<<0)
-#define BNX2_HC_STAT_GEN_SEL_0_GEN_SEL_0_HC_CORE_CLKS_TO_SW_INTACK_VEC5_XI	 (156L<<0)
-#define BNX2_HC_STAT_GEN_SEL_0_GEN_SEL_0_HC_CORE_CLKS_DURING_SW_INTACK_VEC5_XI	 (157L<<0)
-#define BNX2_HC_STAT_GEN_SEL_0_GEN_SEL_0_HC_NUM_STATUS_BLOCKS_VEC6_XI	 (158L<<0)
-#define BNX2_HC_STAT_GEN_SEL_0_GEN_SEL_0_HC_NUM_INT_GEN_VEC6_XI	 (159L<<0)
-#define BNX2_HC_STAT_GEN_SEL_0_GEN_SEL_0_HC_NUM_INT_MBOX_WR_VEC6_XI	 (160L<<0)
-#define BNX2_HC_STAT_GEN_SEL_0_GEN_SEL_0_HC_CORE_CLKS_TO_HW_INTACK_VEC6_XI	 (161L<<0)
-#define BNX2_HC_STAT_GEN_SEL_0_GEN_SEL_0_HC_CORE_CLKS_TO_SW_INTACK_VEC6_XI	 (162L<<0)
-#define BNX2_HC_STAT_GEN_SEL_0_GEN_SEL_0_HC_CORE_CLKS_DURING_SW_INTACK_VEC6_XI	 (163L<<0)
-#define BNX2_HC_STAT_GEN_SEL_0_GEN_SEL_0_HC_NUM_STATUS_BLOCKS_VEC7_XI	 (164L<<0)
-#define BNX2_HC_STAT_GEN_SEL_0_GEN_SEL_0_HC_NUM_INT_GEN_VEC7_XI	 (165L<<0)
-#define BNX2_HC_STAT_GEN_SEL_0_GEN_SEL_0_HC_NUM_INT_MBOX_WR_VEC7_XI	 (166L<<0)
-#define BNX2_HC_STAT_GEN_SEL_0_GEN_SEL_0_HC_CORE_CLKS_TO_HW_INTACK_VEC7_XI	 (167L<<0)
-#define BNX2_HC_STAT_GEN_SEL_0_GEN_SEL_0_HC_CORE_CLKS_TO_SW_INTACK_VEC7_XI	 (168L<<0)
-#define BNX2_HC_STAT_GEN_SEL_0_GEN_SEL_0_HC_CORE_CLKS_DURING_SW_INTACK_VEC7_XI	 (169L<<0)
-#define BNX2_HC_STAT_GEN_SEL_0_GEN_SEL_0_HC_NUM_STATUS_BLOCKS_VEC8_XI	 (170L<<0)
-#define BNX2_HC_STAT_GEN_SEL_0_GEN_SEL_0_HC_NUM_INT_GEN_VEC8_XI	 (171L<<0)
-#define BNX2_HC_STAT_GEN_SEL_0_GEN_SEL_0_HC_NUM_INT_MBOX_WR_VEC8_XI	 (172L<<0)
-#define BNX2_HC_STAT_GEN_SEL_0_GEN_SEL_0_HC_CORE_CLKS_TO_HW_INTACK_VEC8_XI	 (173L<<0)
-#define BNX2_HC_STAT_GEN_SEL_0_GEN_SEL_0_HC_CORE_CLKS_TO_SW_INTACK_VEC8_XI	 (174L<<0)
-#define BNX2_HC_STAT_GEN_SEL_0_GEN_SEL_0_HC_CORE_CLKS_DURING_SW_INTACK_VEC8_XI	 (175L<<0)
-#define BNX2_HC_STAT_GEN_SEL_0_GEN_SEL_0_RV2PCS_CMD_CNT_XI	 (176L<<0)
-#define BNX2_HC_STAT_GEN_SEL_0_GEN_SEL_0_RV2PCS_SLOT_CNT_XI	 (177L<<0)
-#define BNX2_HC_STAT_GEN_SEL_0_GEN_SEL_0_RV2PCSQ_VALID_CNT_XI	 (178L<<0)
-#define BNX2_HC_STAT_GEN_SEL_0_GEN_SEL_1_XI		 (0xffL<<8)
-#define BNX2_HC_STAT_GEN_SEL_0_GEN_SEL_2_XI		 (0xffL<<16)
-#define BNX2_HC_STAT_GEN_SEL_0_GEN_SEL_3_XI		 (0xffL<<24)
-
-#define BNX2_HC_STAT_GEN_SEL_1				0x00006854
-#define BNX2_HC_STAT_GEN_SEL_1_GEN_SEL_4		 (0x7fL<<0)
-#define BNX2_HC_STAT_GEN_SEL_1_GEN_SEL_5		 (0x7fL<<8)
-#define BNX2_HC_STAT_GEN_SEL_1_GEN_SEL_6		 (0x7fL<<16)
-#define BNX2_HC_STAT_GEN_SEL_1_GEN_SEL_7		 (0x7fL<<24)
-#define BNX2_HC_STAT_GEN_SEL_1_GEN_SEL_4_XI		 (0xffL<<0)
-#define BNX2_HC_STAT_GEN_SEL_1_GEN_SEL_5_XI		 (0xffL<<8)
-#define BNX2_HC_STAT_GEN_SEL_1_GEN_SEL_6_XI		 (0xffL<<16)
-#define BNX2_HC_STAT_GEN_SEL_1_GEN_SEL_7_XI		 (0xffL<<24)
-
-#define BNX2_HC_STAT_GEN_SEL_2				0x00006858
-#define BNX2_HC_STAT_GEN_SEL_2_GEN_SEL_8		 (0x7fL<<0)
-#define BNX2_HC_STAT_GEN_SEL_2_GEN_SEL_9		 (0x7fL<<8)
-#define BNX2_HC_STAT_GEN_SEL_2_GEN_SEL_10		 (0x7fL<<16)
-#define BNX2_HC_STAT_GEN_SEL_2_GEN_SEL_11		 (0x7fL<<24)
-#define BNX2_HC_STAT_GEN_SEL_2_GEN_SEL_8_XI		 (0xffL<<0)
-#define BNX2_HC_STAT_GEN_SEL_2_GEN_SEL_9_XI		 (0xffL<<8)
-#define BNX2_HC_STAT_GEN_SEL_2_GEN_SEL_10_XI		 (0xffL<<16)
-#define BNX2_HC_STAT_GEN_SEL_2_GEN_SEL_11_XI		 (0xffL<<24)
-
-#define BNX2_HC_STAT_GEN_SEL_3				0x0000685c
-#define BNX2_HC_STAT_GEN_SEL_3_GEN_SEL_12		 (0x7fL<<0)
-#define BNX2_HC_STAT_GEN_SEL_3_GEN_SEL_13		 (0x7fL<<8)
-#define BNX2_HC_STAT_GEN_SEL_3_GEN_SEL_14		 (0x7fL<<16)
-#define BNX2_HC_STAT_GEN_SEL_3_GEN_SEL_15		 (0x7fL<<24)
-#define BNX2_HC_STAT_GEN_SEL_3_GEN_SEL_12_XI		 (0xffL<<0)
-#define BNX2_HC_STAT_GEN_SEL_3_GEN_SEL_13_XI		 (0xffL<<8)
-#define BNX2_HC_STAT_GEN_SEL_3_GEN_SEL_14_XI		 (0xffL<<16)
-#define BNX2_HC_STAT_GEN_SEL_3_GEN_SEL_15_XI		 (0xffL<<24)
-
-#define BNX2_HC_STAT_GEN_STAT0				0x00006888
-#define BNX2_HC_STAT_GEN_STAT1				0x0000688c
-#define BNX2_HC_STAT_GEN_STAT2				0x00006890
-#define BNX2_HC_STAT_GEN_STAT3				0x00006894
-#define BNX2_HC_STAT_GEN_STAT4				0x00006898
-#define BNX2_HC_STAT_GEN_STAT5				0x0000689c
-#define BNX2_HC_STAT_GEN_STAT6				0x000068a0
-#define BNX2_HC_STAT_GEN_STAT7				0x000068a4
-#define BNX2_HC_STAT_GEN_STAT8				0x000068a8
-#define BNX2_HC_STAT_GEN_STAT9				0x000068ac
-#define BNX2_HC_STAT_GEN_STAT10				0x000068b0
-#define BNX2_HC_STAT_GEN_STAT11				0x000068b4
-#define BNX2_HC_STAT_GEN_STAT12				0x000068b8
-#define BNX2_HC_STAT_GEN_STAT13				0x000068bc
-#define BNX2_HC_STAT_GEN_STAT14				0x000068c0
-#define BNX2_HC_STAT_GEN_STAT15				0x000068c4
-#define BNX2_HC_STAT_GEN_STAT_AC0			0x000068c8
-#define BNX2_HC_STAT_GEN_STAT_AC1			0x000068cc
-#define BNX2_HC_STAT_GEN_STAT_AC2			0x000068d0
-#define BNX2_HC_STAT_GEN_STAT_AC3			0x000068d4
-#define BNX2_HC_STAT_GEN_STAT_AC4			0x000068d8
-#define BNX2_HC_STAT_GEN_STAT_AC5			0x000068dc
-#define BNX2_HC_STAT_GEN_STAT_AC6			0x000068e0
-#define BNX2_HC_STAT_GEN_STAT_AC7			0x000068e4
-#define BNX2_HC_STAT_GEN_STAT_AC8			0x000068e8
-#define BNX2_HC_STAT_GEN_STAT_AC9			0x000068ec
-#define BNX2_HC_STAT_GEN_STAT_AC10			0x000068f0
-#define BNX2_HC_STAT_GEN_STAT_AC11			0x000068f4
-#define BNX2_HC_STAT_GEN_STAT_AC12			0x000068f8
-#define BNX2_HC_STAT_GEN_STAT_AC13			0x000068fc
-#define BNX2_HC_STAT_GEN_STAT_AC14			0x00006900
-#define BNX2_HC_STAT_GEN_STAT_AC15			0x00006904
-#define BNX2_HC_STAT_GEN_STAT_AC			0x000068c8
-#define BNX2_HC_VIS					0x00006908
-#define BNX2_HC_VIS_STAT_BUILD_STATE			 (0xfL<<0)
-#define BNX2_HC_VIS_STAT_BUILD_STATE_IDLE		 (0L<<0)
-#define BNX2_HC_VIS_STAT_BUILD_STATE_START		 (1L<<0)
-#define BNX2_HC_VIS_STAT_BUILD_STATE_REQUEST		 (2L<<0)
-#define BNX2_HC_VIS_STAT_BUILD_STATE_UPDATE64		 (3L<<0)
-#define BNX2_HC_VIS_STAT_BUILD_STATE_UPDATE32		 (4L<<0)
-#define BNX2_HC_VIS_STAT_BUILD_STATE_UPDATE_DONE	 (5L<<0)
-#define BNX2_HC_VIS_STAT_BUILD_STATE_DMA		 (6L<<0)
-#define BNX2_HC_VIS_STAT_BUILD_STATE_MSI_CONTROL	 (7L<<0)
-#define BNX2_HC_VIS_STAT_BUILD_STATE_MSI_LOW		 (8L<<0)
-#define BNX2_HC_VIS_STAT_BUILD_STATE_MSI_HIGH		 (9L<<0)
-#define BNX2_HC_VIS_STAT_BUILD_STATE_MSI_DATA		 (10L<<0)
-#define BNX2_HC_VIS_DMA_STAT_STATE			 (0xfL<<8)
-#define BNX2_HC_VIS_DMA_STAT_STATE_IDLE			 (0L<<8)
-#define BNX2_HC_VIS_DMA_STAT_STATE_STATUS_PARAM		 (1L<<8)
-#define BNX2_HC_VIS_DMA_STAT_STATE_STATUS_DMA		 (2L<<8)
-#define BNX2_HC_VIS_DMA_STAT_STATE_WRITE_COMP		 (3L<<8)
-#define BNX2_HC_VIS_DMA_STAT_STATE_COMP			 (4L<<8)
-#define BNX2_HC_VIS_DMA_STAT_STATE_STATISTIC_PARAM	 (5L<<8)
-#define BNX2_HC_VIS_DMA_STAT_STATE_STATISTIC_DMA	 (6L<<8)
-#define BNX2_HC_VIS_DMA_STAT_STATE_WRITE_COMP_1		 (7L<<8)
-#define BNX2_HC_VIS_DMA_STAT_STATE_WRITE_COMP_2		 (8L<<8)
-#define BNX2_HC_VIS_DMA_STAT_STATE_WAIT			 (9L<<8)
-#define BNX2_HC_VIS_DMA_STAT_STATE_ABORT		 (15L<<8)
-#define BNX2_HC_VIS_DMA_MSI_STATE			 (0x7L<<12)
-#define BNX2_HC_VIS_STATISTIC_DMA_EN_STATE		 (0x3L<<15)
-#define BNX2_HC_VIS_STATISTIC_DMA_EN_STATE_IDLE		 (0L<<15)
-#define BNX2_HC_VIS_STATISTIC_DMA_EN_STATE_COUNT	 (1L<<15)
-#define BNX2_HC_VIS_STATISTIC_DMA_EN_STATE_START	 (2L<<15)
-
-#define BNX2_HC_VIS_1					0x0000690c
-#define BNX2_HC_VIS_1_HW_INTACK_STATE			 (1L<<4)
-#define BNX2_HC_VIS_1_HW_INTACK_STATE_IDLE		 (0L<<4)
-#define BNX2_HC_VIS_1_HW_INTACK_STATE_COUNT		 (1L<<4)
-#define BNX2_HC_VIS_1_SW_INTACK_STATE			 (1L<<5)
-#define BNX2_HC_VIS_1_SW_INTACK_STATE_IDLE		 (0L<<5)
-#define BNX2_HC_VIS_1_SW_INTACK_STATE_COUNT		 (1L<<5)
-#define BNX2_HC_VIS_1_DURING_SW_INTACK_STATE		 (1L<<6)
-#define BNX2_HC_VIS_1_DURING_SW_INTACK_STATE_IDLE	 (0L<<6)
-#define BNX2_HC_VIS_1_DURING_SW_INTACK_STATE_COUNT	 (1L<<6)
-#define BNX2_HC_VIS_1_MAILBOX_COUNT_STATE		 (1L<<7)
-#define BNX2_HC_VIS_1_MAILBOX_COUNT_STATE_IDLE		 (0L<<7)
-#define BNX2_HC_VIS_1_MAILBOX_COUNT_STATE_COUNT		 (1L<<7)
-#define BNX2_HC_VIS_1_RAM_RD_ARB_STATE			 (0xfL<<17)
-#define BNX2_HC_VIS_1_RAM_RD_ARB_STATE_IDLE		 (0L<<17)
-#define BNX2_HC_VIS_1_RAM_RD_ARB_STATE_DMA		 (1L<<17)
-#define BNX2_HC_VIS_1_RAM_RD_ARB_STATE_UPDATE		 (2L<<17)
-#define BNX2_HC_VIS_1_RAM_RD_ARB_STATE_ASSIGN		 (3L<<17)
-#define BNX2_HC_VIS_1_RAM_RD_ARB_STATE_WAIT		 (4L<<17)
-#define BNX2_HC_VIS_1_RAM_RD_ARB_STATE_REG_UPDATE	 (5L<<17)
-#define BNX2_HC_VIS_1_RAM_RD_ARB_STATE_REG_ASSIGN	 (6L<<17)
-#define BNX2_HC_VIS_1_RAM_RD_ARB_STATE_REG_WAIT		 (7L<<17)
-#define BNX2_HC_VIS_1_RAM_WR_ARB_STATE			 (0x3L<<21)
-#define BNX2_HC_VIS_1_RAM_WR_ARB_STATE_NORMAL		 (0L<<21)
-#define BNX2_HC_VIS_1_RAM_WR_ARB_STATE_CLEAR		 (1L<<21)
-#define BNX2_HC_VIS_1_INT_GEN_STATE			 (1L<<23)
-#define BNX2_HC_VIS_1_INT_GEN_STATE_DLE			 (0L<<23)
-#define BNX2_HC_VIS_1_INT_GEN_STATE_NTERRUPT		 (1L<<23)
-#define BNX2_HC_VIS_1_STAT_CHAN_ID			 (0x7L<<24)
-#define BNX2_HC_VIS_1_INT_B				 (1L<<27)
-
-#define BNX2_HC_DEBUG_VECT_PEEK				0x00006910
-#define BNX2_HC_DEBUG_VECT_PEEK_1_VALUE			 (0x7ffL<<0)
-#define BNX2_HC_DEBUG_VECT_PEEK_1_PEEK_EN		 (1L<<11)
-#define BNX2_HC_DEBUG_VECT_PEEK_1_SEL			 (0xfL<<12)
-#define BNX2_HC_DEBUG_VECT_PEEK_2_VALUE			 (0x7ffL<<16)
-#define BNX2_HC_DEBUG_VECT_PEEK_2_PEEK_EN		 (1L<<27)
-#define BNX2_HC_DEBUG_VECT_PEEK_2_SEL			 (0xfL<<28)
-
-#define BNX2_HC_COALESCE_NOW				0x00006914
-#define BNX2_HC_COALESCE_NOW_COAL_NOW			 (0x1ffL<<1)
-#define BNX2_HC_COALESCE_NOW_COAL_NOW_WO_INT		 (0x1ffL<<11)
-#define BNX2_HC_COALESCE_NOW_COAL_ON_NXT_EVENT		 (0x1ffL<<21)
-
-#define BNX2_HC_MSIX_BIT_VECTOR				0x00006918
-#define BNX2_HC_MSIX_BIT_VECTOR_VAL			 (0x1ffL<<0)
-
-#define BNX2_HC_SB_CONFIG_1				0x00006a00
-#define BNX2_HC_SB_CONFIG_1_RX_TMR_MODE			 (1L<<1)
-#define BNX2_HC_SB_CONFIG_1_TX_TMR_MODE			 (1L<<2)
-#define BNX2_HC_SB_CONFIG_1_COM_TMR_MODE		 (1L<<3)
-#define BNX2_HC_SB_CONFIG_1_CMD_TMR_MODE		 (1L<<4)
-#define BNX2_HC_SB_CONFIG_1_PER_MODE			 (1L<<16)
-#define BNX2_HC_SB_CONFIG_1_ONE_SHOT			 (1L<<17)
-#define BNX2_HC_SB_CONFIG_1_USE_INT_PARAM		 (1L<<18)
-#define BNX2_HC_SB_CONFIG_1_PER_COLLECT_LIMIT		 (0xfL<<20)
-
-#define BNX2_HC_TX_QUICK_CONS_TRIP_1			0x00006a04
-#define BNX2_HC_TX_QUICK_CONS_TRIP_1_VALUE		 (0xffL<<0)
-#define BNX2_HC_TX_QUICK_CONS_TRIP_1_INT		 (0xffL<<16)
-
-#define BNX2_HC_COMP_PROD_TRIP_1			0x00006a08
-#define BNX2_HC_COMP_PROD_TRIP_1_VALUE			 (0xffL<<0)
-#define BNX2_HC_COMP_PROD_TRIP_1_INT			 (0xffL<<16)
-
-#define BNX2_HC_RX_QUICK_CONS_TRIP_1			0x00006a0c
-#define BNX2_HC_RX_QUICK_CONS_TRIP_1_VALUE		 (0xffL<<0)
-#define BNX2_HC_RX_QUICK_CONS_TRIP_1_INT		 (0xffL<<16)
-
-#define BNX2_HC_RX_TICKS_1				0x00006a10
-#define BNX2_HC_RX_TICKS_1_VALUE			 (0x3ffL<<0)
-#define BNX2_HC_RX_TICKS_1_INT				 (0x3ffL<<16)
-
-#define BNX2_HC_TX_TICKS_1				0x00006a14
-#define BNX2_HC_TX_TICKS_1_VALUE			 (0x3ffL<<0)
-#define BNX2_HC_TX_TICKS_1_INT				 (0x3ffL<<16)
-
-#define BNX2_HC_COM_TICKS_1				0x00006a18
-#define BNX2_HC_COM_TICKS_1_VALUE			 (0x3ffL<<0)
-#define BNX2_HC_COM_TICKS_1_INT				 (0x3ffL<<16)
-
-#define BNX2_HC_CMD_TICKS_1				0x00006a1c
-#define BNX2_HC_CMD_TICKS_1_VALUE			 (0x3ffL<<0)
-#define BNX2_HC_CMD_TICKS_1_INT				 (0x3ffL<<16)
-
-#define BNX2_HC_PERIODIC_TICKS_1			0x00006a20
-#define BNX2_HC_PERIODIC_TICKS_1_HC_PERIODIC_TICKS	 (0xffffL<<0)
-#define BNX2_HC_PERIODIC_TICKS_1_HC_INT_PERIODIC_TICKS	 (0xffffL<<16)
-
-#define BNX2_HC_SB_CONFIG_2				0x00006a24
-#define BNX2_HC_SB_CONFIG_2_RX_TMR_MODE			 (1L<<1)
-#define BNX2_HC_SB_CONFIG_2_TX_TMR_MODE			 (1L<<2)
-#define BNX2_HC_SB_CONFIG_2_COM_TMR_MODE		 (1L<<3)
-#define BNX2_HC_SB_CONFIG_2_CMD_TMR_MODE		 (1L<<4)
-#define BNX2_HC_SB_CONFIG_2_PER_MODE			 (1L<<16)
-#define BNX2_HC_SB_CONFIG_2_ONE_SHOT			 (1L<<17)
-#define BNX2_HC_SB_CONFIG_2_USE_INT_PARAM		 (1L<<18)
-#define BNX2_HC_SB_CONFIG_2_PER_COLLECT_LIMIT		 (0xfL<<20)
-
-#define BNX2_HC_TX_QUICK_CONS_TRIP_2			0x00006a28
-#define BNX2_HC_TX_QUICK_CONS_TRIP_2_VALUE		 (0xffL<<0)
-#define BNX2_HC_TX_QUICK_CONS_TRIP_2_INT		 (0xffL<<16)
-
-#define BNX2_HC_COMP_PROD_TRIP_2			0x00006a2c
-#define BNX2_HC_COMP_PROD_TRIP_2_VALUE			 (0xffL<<0)
-#define BNX2_HC_COMP_PROD_TRIP_2_INT			 (0xffL<<16)
-
-#define BNX2_HC_RX_QUICK_CONS_TRIP_2			0x00006a30
-#define BNX2_HC_RX_QUICK_CONS_TRIP_2_VALUE		 (0xffL<<0)
-#define BNX2_HC_RX_QUICK_CONS_TRIP_2_INT		 (0xffL<<16)
-
-#define BNX2_HC_RX_TICKS_2				0x00006a34
-#define BNX2_HC_RX_TICKS_2_VALUE			 (0x3ffL<<0)
-#define BNX2_HC_RX_TICKS_2_INT				 (0x3ffL<<16)
-
-#define BNX2_HC_TX_TICKS_2				0x00006a38
-#define BNX2_HC_TX_TICKS_2_VALUE			 (0x3ffL<<0)
-#define BNX2_HC_TX_TICKS_2_INT				 (0x3ffL<<16)
-
-#define BNX2_HC_COM_TICKS_2				0x00006a3c
-#define BNX2_HC_COM_TICKS_2_VALUE			 (0x3ffL<<0)
-#define BNX2_HC_COM_TICKS_2_INT				 (0x3ffL<<16)
-
-#define BNX2_HC_CMD_TICKS_2				0x00006a40
-#define BNX2_HC_CMD_TICKS_2_VALUE			 (0x3ffL<<0)
-#define BNX2_HC_CMD_TICKS_2_INT				 (0x3ffL<<16)
-
-#define BNX2_HC_PERIODIC_TICKS_2			0x00006a44
-#define BNX2_HC_PERIODIC_TICKS_2_HC_PERIODIC_TICKS	 (0xffffL<<0)
-#define BNX2_HC_PERIODIC_TICKS_2_HC_INT_PERIODIC_TICKS	 (0xffffL<<16)
-
-#define BNX2_HC_SB_CONFIG_3				0x00006a48
-#define BNX2_HC_SB_CONFIG_3_RX_TMR_MODE			 (1L<<1)
-#define BNX2_HC_SB_CONFIG_3_TX_TMR_MODE			 (1L<<2)
-#define BNX2_HC_SB_CONFIG_3_COM_TMR_MODE		 (1L<<3)
-#define BNX2_HC_SB_CONFIG_3_CMD_TMR_MODE		 (1L<<4)
-#define BNX2_HC_SB_CONFIG_3_PER_MODE			 (1L<<16)
-#define BNX2_HC_SB_CONFIG_3_ONE_SHOT			 (1L<<17)
-#define BNX2_HC_SB_CONFIG_3_USE_INT_PARAM		 (1L<<18)
-#define BNX2_HC_SB_CONFIG_3_PER_COLLECT_LIMIT		 (0xfL<<20)
-
-#define BNX2_HC_TX_QUICK_CONS_TRIP_3			0x00006a4c
-#define BNX2_HC_TX_QUICK_CONS_TRIP_3_VALUE		 (0xffL<<0)
-#define BNX2_HC_TX_QUICK_CONS_TRIP_3_INT		 (0xffL<<16)
-
-#define BNX2_HC_COMP_PROD_TRIP_3			0x00006a50
-#define BNX2_HC_COMP_PROD_TRIP_3_VALUE			 (0xffL<<0)
-#define BNX2_HC_COMP_PROD_TRIP_3_INT			 (0xffL<<16)
-
-#define BNX2_HC_RX_QUICK_CONS_TRIP_3			0x00006a54
-#define BNX2_HC_RX_QUICK_CONS_TRIP_3_VALUE		 (0xffL<<0)
-#define BNX2_HC_RX_QUICK_CONS_TRIP_3_INT		 (0xffL<<16)
-
-#define BNX2_HC_RX_TICKS_3				0x00006a58
-#define BNX2_HC_RX_TICKS_3_VALUE			 (0x3ffL<<0)
-#define BNX2_HC_RX_TICKS_3_INT				 (0x3ffL<<16)
-
-#define BNX2_HC_TX_TICKS_3				0x00006a5c
-#define BNX2_HC_TX_TICKS_3_VALUE			 (0x3ffL<<0)
-#define BNX2_HC_TX_TICKS_3_INT				 (0x3ffL<<16)
-
-#define BNX2_HC_COM_TICKS_3				0x00006a60
-#define BNX2_HC_COM_TICKS_3_VALUE			 (0x3ffL<<0)
-#define BNX2_HC_COM_TICKS_3_INT				 (0x3ffL<<16)
-
-#define BNX2_HC_CMD_TICKS_3				0x00006a64
-#define BNX2_HC_CMD_TICKS_3_VALUE			 (0x3ffL<<0)
-#define BNX2_HC_CMD_TICKS_3_INT				 (0x3ffL<<16)
-
-#define BNX2_HC_PERIODIC_TICKS_3			0x00006a68
-#define BNX2_HC_PERIODIC_TICKS_3_HC_PERIODIC_TICKS	 (0xffffL<<0)
-#define BNX2_HC_PERIODIC_TICKS_3_HC_INT_PERIODIC_TICKS	 (0xffffL<<16)
-
-#define BNX2_HC_SB_CONFIG_4				0x00006a6c
-#define BNX2_HC_SB_CONFIG_4_RX_TMR_MODE			 (1L<<1)
-#define BNX2_HC_SB_CONFIG_4_TX_TMR_MODE			 (1L<<2)
-#define BNX2_HC_SB_CONFIG_4_COM_TMR_MODE		 (1L<<3)
-#define BNX2_HC_SB_CONFIG_4_CMD_TMR_MODE		 (1L<<4)
-#define BNX2_HC_SB_CONFIG_4_PER_MODE			 (1L<<16)
-#define BNX2_HC_SB_CONFIG_4_ONE_SHOT			 (1L<<17)
-#define BNX2_HC_SB_CONFIG_4_USE_INT_PARAM		 (1L<<18)
-#define BNX2_HC_SB_CONFIG_4_PER_COLLECT_LIMIT		 (0xfL<<20)
-
-#define BNX2_HC_TX_QUICK_CONS_TRIP_4			0x00006a70
-#define BNX2_HC_TX_QUICK_CONS_TRIP_4_VALUE		 (0xffL<<0)
-#define BNX2_HC_TX_QUICK_CONS_TRIP_4_INT		 (0xffL<<16)
-
-#define BNX2_HC_COMP_PROD_TRIP_4			0x00006a74
-#define BNX2_HC_COMP_PROD_TRIP_4_VALUE			 (0xffL<<0)
-#define BNX2_HC_COMP_PROD_TRIP_4_INT			 (0xffL<<16)
-
-#define BNX2_HC_RX_QUICK_CONS_TRIP_4			0x00006a78
-#define BNX2_HC_RX_QUICK_CONS_TRIP_4_VALUE		 (0xffL<<0)
-#define BNX2_HC_RX_QUICK_CONS_TRIP_4_INT		 (0xffL<<16)
-
-#define BNX2_HC_RX_TICKS_4				0x00006a7c
-#define BNX2_HC_RX_TICKS_4_VALUE			 (0x3ffL<<0)
-#define BNX2_HC_RX_TICKS_4_INT				 (0x3ffL<<16)
-
-#define BNX2_HC_TX_TICKS_4				0x00006a80
-#define BNX2_HC_TX_TICKS_4_VALUE			 (0x3ffL<<0)
-#define BNX2_HC_TX_TICKS_4_INT				 (0x3ffL<<16)
-
-#define BNX2_HC_COM_TICKS_4				0x00006a84
-#define BNX2_HC_COM_TICKS_4_VALUE			 (0x3ffL<<0)
-#define BNX2_HC_COM_TICKS_4_INT				 (0x3ffL<<16)
-
-#define BNX2_HC_CMD_TICKS_4				0x00006a88
-#define BNX2_HC_CMD_TICKS_4_VALUE			 (0x3ffL<<0)
-#define BNX2_HC_CMD_TICKS_4_INT				 (0x3ffL<<16)
-
-#define BNX2_HC_PERIODIC_TICKS_4			0x00006a8c
-#define BNX2_HC_PERIODIC_TICKS_4_HC_PERIODIC_TICKS	 (0xffffL<<0)
-#define BNX2_HC_PERIODIC_TICKS_4_HC_INT_PERIODIC_TICKS	 (0xffffL<<16)
-
-#define BNX2_HC_SB_CONFIG_5				0x00006a90
-#define BNX2_HC_SB_CONFIG_5_RX_TMR_MODE			 (1L<<1)
-#define BNX2_HC_SB_CONFIG_5_TX_TMR_MODE			 (1L<<2)
-#define BNX2_HC_SB_CONFIG_5_COM_TMR_MODE		 (1L<<3)
-#define BNX2_HC_SB_CONFIG_5_CMD_TMR_MODE		 (1L<<4)
-#define BNX2_HC_SB_CONFIG_5_PER_MODE			 (1L<<16)
-#define BNX2_HC_SB_CONFIG_5_ONE_SHOT			 (1L<<17)
-#define BNX2_HC_SB_CONFIG_5_USE_INT_PARAM		 (1L<<18)
-#define BNX2_HC_SB_CONFIG_5_PER_COLLECT_LIMIT		 (0xfL<<20)
-
-#define BNX2_HC_TX_QUICK_CONS_TRIP_5			0x00006a94
-#define BNX2_HC_TX_QUICK_CONS_TRIP_5_VALUE		 (0xffL<<0)
-#define BNX2_HC_TX_QUICK_CONS_TRIP_5_INT		 (0xffL<<16)
-
-#define BNX2_HC_COMP_PROD_TRIP_5			0x00006a98
-#define BNX2_HC_COMP_PROD_TRIP_5_VALUE			 (0xffL<<0)
-#define BNX2_HC_COMP_PROD_TRIP_5_INT			 (0xffL<<16)
-
-#define BNX2_HC_RX_QUICK_CONS_TRIP_5			0x00006a9c
-#define BNX2_HC_RX_QUICK_CONS_TRIP_5_VALUE		 (0xffL<<0)
-#define BNX2_HC_RX_QUICK_CONS_TRIP_5_INT		 (0xffL<<16)
-
-#define BNX2_HC_RX_TICKS_5				0x00006aa0
-#define BNX2_HC_RX_TICKS_5_VALUE			 (0x3ffL<<0)
-#define BNX2_HC_RX_TICKS_5_INT				 (0x3ffL<<16)
-
-#define BNX2_HC_TX_TICKS_5				0x00006aa4
-#define BNX2_HC_TX_TICKS_5_VALUE			 (0x3ffL<<0)
-#define BNX2_HC_TX_TICKS_5_INT				 (0x3ffL<<16)
-
-#define BNX2_HC_COM_TICKS_5				0x00006aa8
-#define BNX2_HC_COM_TICKS_5_VALUE			 (0x3ffL<<0)
-#define BNX2_HC_COM_TICKS_5_INT				 (0x3ffL<<16)
-
-#define BNX2_HC_CMD_TICKS_5				0x00006aac
-#define BNX2_HC_CMD_TICKS_5_VALUE			 (0x3ffL<<0)
-#define BNX2_HC_CMD_TICKS_5_INT				 (0x3ffL<<16)
-
-#define BNX2_HC_PERIODIC_TICKS_5			0x00006ab0
-#define BNX2_HC_PERIODIC_TICKS_5_HC_PERIODIC_TICKS	 (0xffffL<<0)
-#define BNX2_HC_PERIODIC_TICKS_5_HC_INT_PERIODIC_TICKS	 (0xffffL<<16)
-
-#define BNX2_HC_SB_CONFIG_6				0x00006ab4
-#define BNX2_HC_SB_CONFIG_6_RX_TMR_MODE			 (1L<<1)
-#define BNX2_HC_SB_CONFIG_6_TX_TMR_MODE			 (1L<<2)
-#define BNX2_HC_SB_CONFIG_6_COM_TMR_MODE		 (1L<<3)
-#define BNX2_HC_SB_CONFIG_6_CMD_TMR_MODE		 (1L<<4)
-#define BNX2_HC_SB_CONFIG_6_PER_MODE			 (1L<<16)
-#define BNX2_HC_SB_CONFIG_6_ONE_SHOT			 (1L<<17)
-#define BNX2_HC_SB_CONFIG_6_USE_INT_PARAM		 (1L<<18)
-#define BNX2_HC_SB_CONFIG_6_PER_COLLECT_LIMIT		 (0xfL<<20)
-
-#define BNX2_HC_TX_QUICK_CONS_TRIP_6			0x00006ab8
-#define BNX2_HC_TX_QUICK_CONS_TRIP_6_VALUE		 (0xffL<<0)
-#define BNX2_HC_TX_QUICK_CONS_TRIP_6_INT		 (0xffL<<16)
-
-#define BNX2_HC_COMP_PROD_TRIP_6			0x00006abc
-#define BNX2_HC_COMP_PROD_TRIP_6_VALUE			 (0xffL<<0)
-#define BNX2_HC_COMP_PROD_TRIP_6_INT			 (0xffL<<16)
-
-#define BNX2_HC_RX_QUICK_CONS_TRIP_6			0x00006ac0
-#define BNX2_HC_RX_QUICK_CONS_TRIP_6_VALUE		 (0xffL<<0)
-#define BNX2_HC_RX_QUICK_CONS_TRIP_6_INT		 (0xffL<<16)
-
-#define BNX2_HC_RX_TICKS_6				0x00006ac4
-#define BNX2_HC_RX_TICKS_6_VALUE			 (0x3ffL<<0)
-#define BNX2_HC_RX_TICKS_6_INT				 (0x3ffL<<16)
-
-#define BNX2_HC_TX_TICKS_6				0x00006ac8
-#define BNX2_HC_TX_TICKS_6_VALUE			 (0x3ffL<<0)
-#define BNX2_HC_TX_TICKS_6_INT				 (0x3ffL<<16)
-
-#define BNX2_HC_COM_TICKS_6				0x00006acc
-#define BNX2_HC_COM_TICKS_6_VALUE			 (0x3ffL<<0)
-#define BNX2_HC_COM_TICKS_6_INT				 (0x3ffL<<16)
-
-#define BNX2_HC_CMD_TICKS_6				0x00006ad0
-#define BNX2_HC_CMD_TICKS_6_VALUE			 (0x3ffL<<0)
-#define BNX2_HC_CMD_TICKS_6_INT				 (0x3ffL<<16)
-
-#define BNX2_HC_PERIODIC_TICKS_6			0x00006ad4
-#define BNX2_HC_PERIODIC_TICKS_6_HC_PERIODIC_TICKS	 (0xffffL<<0)
-#define BNX2_HC_PERIODIC_TICKS_6_HC_INT_PERIODIC_TICKS	 (0xffffL<<16)
-
-#define BNX2_HC_SB_CONFIG_7				0x00006ad8
-#define BNX2_HC_SB_CONFIG_7_RX_TMR_MODE			 (1L<<1)
-#define BNX2_HC_SB_CONFIG_7_TX_TMR_MODE			 (1L<<2)
-#define BNX2_HC_SB_CONFIG_7_COM_TMR_MODE		 (1L<<3)
-#define BNX2_HC_SB_CONFIG_7_CMD_TMR_MODE		 (1L<<4)
-#define BNX2_HC_SB_CONFIG_7_PER_MODE			 (1L<<16)
-#define BNX2_HC_SB_CONFIG_7_ONE_SHOT			 (1L<<17)
-#define BNX2_HC_SB_CONFIG_7_USE_INT_PARAM		 (1L<<18)
-#define BNX2_HC_SB_CONFIG_7_PER_COLLECT_LIMIT		 (0xfL<<20)
-
-#define BNX2_HC_TX_QUICK_CONS_TRIP_7			0x00006adc
-#define BNX2_HC_TX_QUICK_CONS_TRIP_7_VALUE		 (0xffL<<0)
-#define BNX2_HC_TX_QUICK_CONS_TRIP_7_INT		 (0xffL<<16)
-
-#define BNX2_HC_COMP_PROD_TRIP_7			0x00006ae0
-#define BNX2_HC_COMP_PROD_TRIP_7_VALUE			 (0xffL<<0)
-#define BNX2_HC_COMP_PROD_TRIP_7_INT			 (0xffL<<16)
-
-#define BNX2_HC_RX_QUICK_CONS_TRIP_7			0x00006ae4
-#define BNX2_HC_RX_QUICK_CONS_TRIP_7_VALUE		 (0xffL<<0)
-#define BNX2_HC_RX_QUICK_CONS_TRIP_7_INT		 (0xffL<<16)
-
-#define BNX2_HC_RX_TICKS_7				0x00006ae8
-#define BNX2_HC_RX_TICKS_7_VALUE			 (0x3ffL<<0)
-#define BNX2_HC_RX_TICKS_7_INT				 (0x3ffL<<16)
-
-#define BNX2_HC_TX_TICKS_7				0x00006aec
-#define BNX2_HC_TX_TICKS_7_VALUE			 (0x3ffL<<0)
-#define BNX2_HC_TX_TICKS_7_INT				 (0x3ffL<<16)
-
-#define BNX2_HC_COM_TICKS_7				0x00006af0
-#define BNX2_HC_COM_TICKS_7_VALUE			 (0x3ffL<<0)
-#define BNX2_HC_COM_TICKS_7_INT				 (0x3ffL<<16)
-
-#define BNX2_HC_CMD_TICKS_7				0x00006af4
-#define BNX2_HC_CMD_TICKS_7_VALUE			 (0x3ffL<<0)
-#define BNX2_HC_CMD_TICKS_7_INT				 (0x3ffL<<16)
-
-#define BNX2_HC_PERIODIC_TICKS_7			0x00006af8
-#define BNX2_HC_PERIODIC_TICKS_7_HC_PERIODIC_TICKS	 (0xffffL<<0)
-#define BNX2_HC_PERIODIC_TICKS_7_HC_INT_PERIODIC_TICKS	 (0xffffL<<16)
-
-#define BNX2_HC_SB_CONFIG_8				0x00006afc
-#define BNX2_HC_SB_CONFIG_8_RX_TMR_MODE			 (1L<<1)
-#define BNX2_HC_SB_CONFIG_8_TX_TMR_MODE			 (1L<<2)
-#define BNX2_HC_SB_CONFIG_8_COM_TMR_MODE		 (1L<<3)
-#define BNX2_HC_SB_CONFIG_8_CMD_TMR_MODE		 (1L<<4)
-#define BNX2_HC_SB_CONFIG_8_PER_MODE			 (1L<<16)
-#define BNX2_HC_SB_CONFIG_8_ONE_SHOT			 (1L<<17)
-#define BNX2_HC_SB_CONFIG_8_USE_INT_PARAM		 (1L<<18)
-#define BNX2_HC_SB_CONFIG_8_PER_COLLECT_LIMIT		 (0xfL<<20)
-
-#define BNX2_HC_TX_QUICK_CONS_TRIP_8			0x00006b00
-#define BNX2_HC_TX_QUICK_CONS_TRIP_8_VALUE		 (0xffL<<0)
-#define BNX2_HC_TX_QUICK_CONS_TRIP_8_INT		 (0xffL<<16)
-
-#define BNX2_HC_COMP_PROD_TRIP_8			0x00006b04
-#define BNX2_HC_COMP_PROD_TRIP_8_VALUE			 (0xffL<<0)
-#define BNX2_HC_COMP_PROD_TRIP_8_INT			 (0xffL<<16)
-
-#define BNX2_HC_RX_QUICK_CONS_TRIP_8			0x00006b08
-#define BNX2_HC_RX_QUICK_CONS_TRIP_8_VALUE		 (0xffL<<0)
-#define BNX2_HC_RX_QUICK_CONS_TRIP_8_INT		 (0xffL<<16)
-
-#define BNX2_HC_RX_TICKS_8				0x00006b0c
-#define BNX2_HC_RX_TICKS_8_VALUE			 (0x3ffL<<0)
-#define BNX2_HC_RX_TICKS_8_INT				 (0x3ffL<<16)
-
-#define BNX2_HC_TX_TICKS_8				0x00006b10
-#define BNX2_HC_TX_TICKS_8_VALUE			 (0x3ffL<<0)
-#define BNX2_HC_TX_TICKS_8_INT				 (0x3ffL<<16)
-
-#define BNX2_HC_COM_TICKS_8				0x00006b14
-#define BNX2_HC_COM_TICKS_8_VALUE			 (0x3ffL<<0)
-#define BNX2_HC_COM_TICKS_8_INT				 (0x3ffL<<16)
-
-#define BNX2_HC_CMD_TICKS_8				0x00006b18
-#define BNX2_HC_CMD_TICKS_8_VALUE			 (0x3ffL<<0)
-#define BNX2_HC_CMD_TICKS_8_INT				 (0x3ffL<<16)
-
-#define BNX2_HC_PERIODIC_TICKS_8			0x00006b1c
-#define BNX2_HC_PERIODIC_TICKS_8_HC_PERIODIC_TICKS	 (0xffffL<<0)
-#define BNX2_HC_PERIODIC_TICKS_8_HC_INT_PERIODIC_TICKS	 (0xffffL<<16)
-
-#define BNX2_HC_SB_CONFIG_SIZE	(BNX2_HC_SB_CONFIG_2 - BNX2_HC_SB_CONFIG_1)
-#define BNX2_HC_COMP_PROD_TRIP_OFF	(BNX2_HC_COMP_PROD_TRIP_1 -	\
-					 BNX2_HC_SB_CONFIG_1)
-#define BNX2_HC_COM_TICKS_OFF	(BNX2_HC_COM_TICKS_1 - BNX2_HC_SB_CONFIG_1)
-#define BNX2_HC_CMD_TICKS_OFF	(BNX2_HC_CMD_TICKS_1 - BNX2_HC_SB_CONFIG_1)
-#define BNX2_HC_TX_QUICK_CONS_TRIP_OFF	(BNX2_HC_TX_QUICK_CONS_TRIP_1 -	\
-					 BNX2_HC_SB_CONFIG_1)
-#define BNX2_HC_TX_TICKS_OFF	(BNX2_HC_TX_TICKS_1 - BNX2_HC_SB_CONFIG_1)
-#define BNX2_HC_RX_QUICK_CONS_TRIP_OFF	(BNX2_HC_RX_QUICK_CONS_TRIP_1 - \
-					 BNX2_HC_SB_CONFIG_1)
-#define BNX2_HC_RX_TICKS_OFF	(BNX2_HC_RX_TICKS_1 - BNX2_HC_SB_CONFIG_1)
-
-
-/*
- *  txp_reg definition
- *  offset: 0x40000
- */
-#define BNX2_TXP_CPU_MODE				0x00045000
-#define BNX2_TXP_CPU_MODE_LOCAL_RST			 (1L<<0)
-#define BNX2_TXP_CPU_MODE_STEP_ENA			 (1L<<1)
-#define BNX2_TXP_CPU_MODE_PAGE_0_DATA_ENA		 (1L<<2)
-#define BNX2_TXP_CPU_MODE_PAGE_0_INST_ENA		 (1L<<3)
-#define BNX2_TXP_CPU_MODE_MSG_BIT1			 (1L<<6)
-#define BNX2_TXP_CPU_MODE_INTERRUPT_ENA			 (1L<<7)
-#define BNX2_TXP_CPU_MODE_SOFT_HALT			 (1L<<10)
-#define BNX2_TXP_CPU_MODE_BAD_DATA_HALT_ENA		 (1L<<11)
-#define BNX2_TXP_CPU_MODE_BAD_INST_HALT_ENA		 (1L<<12)
-#define BNX2_TXP_CPU_MODE_FIO_ABORT_HALT_ENA		 (1L<<13)
-#define BNX2_TXP_CPU_MODE_SPAD_UNDERFLOW_HALT_ENA	 (1L<<15)
-
-#define BNX2_TXP_CPU_STATE				0x00045004
-#define BNX2_TXP_CPU_STATE_BREAKPOINT			 (1L<<0)
-#define BNX2_TXP_CPU_STATE_BAD_INST_HALTED		 (1L<<2)
-#define BNX2_TXP_CPU_STATE_PAGE_0_DATA_HALTED		 (1L<<3)
-#define BNX2_TXP_CPU_STATE_PAGE_0_INST_HALTED		 (1L<<4)
-#define BNX2_TXP_CPU_STATE_BAD_DATA_ADDR_HALTED		 (1L<<5)
-#define BNX2_TXP_CPU_STATE_BAD_PC_HALTED		 (1L<<6)
-#define BNX2_TXP_CPU_STATE_ALIGN_HALTED			 (1L<<7)
-#define BNX2_TXP_CPU_STATE_FIO_ABORT_HALTED		 (1L<<8)
-#define BNX2_TXP_CPU_STATE_SOFT_HALTED			 (1L<<10)
-#define BNX2_TXP_CPU_STATE_SPAD_UNDERFLOW		 (1L<<11)
-#define BNX2_TXP_CPU_STATE_INTERRRUPT			 (1L<<12)
-#define BNX2_TXP_CPU_STATE_DATA_ACCESS_STALL		 (1L<<14)
-#define BNX2_TXP_CPU_STATE_INST_FETCH_STALL		 (1L<<15)
-#define BNX2_TXP_CPU_STATE_BLOCKED_READ			 (1L<<31)
-
-#define BNX2_TXP_CPU_EVENT_MASK				0x00045008
-#define BNX2_TXP_CPU_EVENT_MASK_BREAKPOINT_MASK		 (1L<<0)
-#define BNX2_TXP_CPU_EVENT_MASK_BAD_INST_HALTED_MASK	 (1L<<2)
-#define BNX2_TXP_CPU_EVENT_MASK_PAGE_0_DATA_HALTED_MASK	 (1L<<3)
-#define BNX2_TXP_CPU_EVENT_MASK_PAGE_0_INST_HALTED_MASK	 (1L<<4)
-#define BNX2_TXP_CPU_EVENT_MASK_BAD_DATA_ADDR_HALTED_MASK	 (1L<<5)
-#define BNX2_TXP_CPU_EVENT_MASK_BAD_PC_HALTED_MASK	 (1L<<6)
-#define BNX2_TXP_CPU_EVENT_MASK_ALIGN_HALTED_MASK	 (1L<<7)
-#define BNX2_TXP_CPU_EVENT_MASK_FIO_ABORT_MASK		 (1L<<8)
-#define BNX2_TXP_CPU_EVENT_MASK_SOFT_HALTED_MASK	 (1L<<10)
-#define BNX2_TXP_CPU_EVENT_MASK_SPAD_UNDERFLOW_MASK	 (1L<<11)
-#define BNX2_TXP_CPU_EVENT_MASK_INTERRUPT_MASK		 (1L<<12)
-
-#define BNX2_TXP_CPU_PROGRAM_COUNTER			0x0004501c
-#define BNX2_TXP_CPU_INSTRUCTION			0x00045020
-#define BNX2_TXP_CPU_DATA_ACCESS			0x00045024
-#define BNX2_TXP_CPU_INTERRUPT_ENABLE			0x00045028
-#define BNX2_TXP_CPU_INTERRUPT_VECTOR			0x0004502c
-#define BNX2_TXP_CPU_INTERRUPT_SAVED_PC			0x00045030
-#define BNX2_TXP_CPU_HW_BREAKPOINT			0x00045034
-#define BNX2_TXP_CPU_HW_BREAKPOINT_DISABLE		 (1L<<0)
-#define BNX2_TXP_CPU_HW_BREAKPOINT_ADDRESS		 (0x3fffffffL<<2)
-
-#define BNX2_TXP_CPU_DEBUG_VECT_PEEK			0x00045038
-#define BNX2_TXP_CPU_DEBUG_VECT_PEEK_1_VALUE		 (0x7ffL<<0)
-#define BNX2_TXP_CPU_DEBUG_VECT_PEEK_1_PEEK_EN		 (1L<<11)
-#define BNX2_TXP_CPU_DEBUG_VECT_PEEK_1_SEL		 (0xfL<<12)
-#define BNX2_TXP_CPU_DEBUG_VECT_PEEK_2_VALUE		 (0x7ffL<<16)
-#define BNX2_TXP_CPU_DEBUG_VECT_PEEK_2_PEEK_EN		 (1L<<27)
-#define BNX2_TXP_CPU_DEBUG_VECT_PEEK_2_SEL		 (0xfL<<28)
-
-#define BNX2_TXP_CPU_LAST_BRANCH_ADDR			0x00045048
-#define BNX2_TXP_CPU_LAST_BRANCH_ADDR_TYPE		 (1L<<1)
-#define BNX2_TXP_CPU_LAST_BRANCH_ADDR_TYPE_JUMP		 (0L<<1)
-#define BNX2_TXP_CPU_LAST_BRANCH_ADDR_TYPE_BRANCH	 (1L<<1)
-#define BNX2_TXP_CPU_LAST_BRANCH_ADDR_LBA		 (0x3fffffffL<<2)
-
-#define BNX2_TXP_CPU_REG_FILE				0x00045200
-#define BNX2_TXP_TXPQ					0x000453c0
-#define BNX2_TXP_FTQ_CMD				0x000453f8
-#define BNX2_TXP_FTQ_CMD_OFFSET				 (0x3ffL<<0)
-#define BNX2_TXP_FTQ_CMD_WR_TOP				 (1L<<10)
-#define BNX2_TXP_FTQ_CMD_WR_TOP_0			 (0L<<10)
-#define BNX2_TXP_FTQ_CMD_WR_TOP_1			 (1L<<10)
-#define BNX2_TXP_FTQ_CMD_SFT_RESET			 (1L<<25)
-#define BNX2_TXP_FTQ_CMD_RD_DATA			 (1L<<26)
-#define BNX2_TXP_FTQ_CMD_ADD_INTERVEN			 (1L<<27)
-#define BNX2_TXP_FTQ_CMD_ADD_DATA			 (1L<<28)
-#define BNX2_TXP_FTQ_CMD_INTERVENE_CLR			 (1L<<29)
-#define BNX2_TXP_FTQ_CMD_POP				 (1L<<30)
-#define BNX2_TXP_FTQ_CMD_BUSY				 (1L<<31)
-
-#define BNX2_TXP_FTQ_CTL				0x000453fc
-#define BNX2_TXP_FTQ_CTL_INTERVENE			 (1L<<0)
-#define BNX2_TXP_FTQ_CTL_OVERFLOW			 (1L<<1)
-#define BNX2_TXP_FTQ_CTL_FORCE_INTERVENE		 (1L<<2)
-#define BNX2_TXP_FTQ_CTL_MAX_DEPTH			 (0x3ffL<<12)
-#define BNX2_TXP_FTQ_CTL_CUR_DEPTH			 (0x3ffL<<22)
-
-#define BNX2_TXP_SCRATCH				0x00060000
-
-
-/*
- *  tpat_reg definition
- *  offset: 0x80000
- */
-#define BNX2_TPAT_CPU_MODE				0x00085000
-#define BNX2_TPAT_CPU_MODE_LOCAL_RST			 (1L<<0)
-#define BNX2_TPAT_CPU_MODE_STEP_ENA			 (1L<<1)
-#define BNX2_TPAT_CPU_MODE_PAGE_0_DATA_ENA		 (1L<<2)
-#define BNX2_TPAT_CPU_MODE_PAGE_0_INST_ENA		 (1L<<3)
-#define BNX2_TPAT_CPU_MODE_MSG_BIT1			 (1L<<6)
-#define BNX2_TPAT_CPU_MODE_INTERRUPT_ENA		 (1L<<7)
-#define BNX2_TPAT_CPU_MODE_SOFT_HALT			 (1L<<10)
-#define BNX2_TPAT_CPU_MODE_BAD_DATA_HALT_ENA		 (1L<<11)
-#define BNX2_TPAT_CPU_MODE_BAD_INST_HALT_ENA		 (1L<<12)
-#define BNX2_TPAT_CPU_MODE_FIO_ABORT_HALT_ENA		 (1L<<13)
-#define BNX2_TPAT_CPU_MODE_SPAD_UNDERFLOW_HALT_ENA	 (1L<<15)
-
-#define BNX2_TPAT_CPU_STATE				0x00085004
-#define BNX2_TPAT_CPU_STATE_BREAKPOINT			 (1L<<0)
-#define BNX2_TPAT_CPU_STATE_BAD_INST_HALTED		 (1L<<2)
-#define BNX2_TPAT_CPU_STATE_PAGE_0_DATA_HALTED		 (1L<<3)
-#define BNX2_TPAT_CPU_STATE_PAGE_0_INST_HALTED		 (1L<<4)
-#define BNX2_TPAT_CPU_STATE_BAD_DATA_ADDR_HALTED	 (1L<<5)
-#define BNX2_TPAT_CPU_STATE_BAD_PC_HALTED		 (1L<<6)
-#define BNX2_TPAT_CPU_STATE_ALIGN_HALTED		 (1L<<7)
-#define BNX2_TPAT_CPU_STATE_FIO_ABORT_HALTED		 (1L<<8)
-#define BNX2_TPAT_CPU_STATE_SOFT_HALTED			 (1L<<10)
-#define BNX2_TPAT_CPU_STATE_SPAD_UNDERFLOW		 (1L<<11)
-#define BNX2_TPAT_CPU_STATE_INTERRRUPT			 (1L<<12)
-#define BNX2_TPAT_CPU_STATE_DATA_ACCESS_STALL		 (1L<<14)
-#define BNX2_TPAT_CPU_STATE_INST_FETCH_STALL		 (1L<<15)
-#define BNX2_TPAT_CPU_STATE_BLOCKED_READ		 (1L<<31)
-
-#define BNX2_TPAT_CPU_EVENT_MASK			0x00085008
-#define BNX2_TPAT_CPU_EVENT_MASK_BREAKPOINT_MASK	 (1L<<0)
-#define BNX2_TPAT_CPU_EVENT_MASK_BAD_INST_HALTED_MASK	 (1L<<2)
-#define BNX2_TPAT_CPU_EVENT_MASK_PAGE_0_DATA_HALTED_MASK	 (1L<<3)
-#define BNX2_TPAT_CPU_EVENT_MASK_PAGE_0_INST_HALTED_MASK	 (1L<<4)
-#define BNX2_TPAT_CPU_EVENT_MASK_BAD_DATA_ADDR_HALTED_MASK	 (1L<<5)
-#define BNX2_TPAT_CPU_EVENT_MASK_BAD_PC_HALTED_MASK	 (1L<<6)
-#define BNX2_TPAT_CPU_EVENT_MASK_ALIGN_HALTED_MASK	 (1L<<7)
-#define BNX2_TPAT_CPU_EVENT_MASK_FIO_ABORT_MASK		 (1L<<8)
-#define BNX2_TPAT_CPU_EVENT_MASK_SOFT_HALTED_MASK	 (1L<<10)
-#define BNX2_TPAT_CPU_EVENT_MASK_SPAD_UNDERFLOW_MASK	 (1L<<11)
-#define BNX2_TPAT_CPU_EVENT_MASK_INTERRUPT_MASK		 (1L<<12)
-
-#define BNX2_TPAT_CPU_PROGRAM_COUNTER			0x0008501c
-#define BNX2_TPAT_CPU_INSTRUCTION			0x00085020
-#define BNX2_TPAT_CPU_DATA_ACCESS			0x00085024
-#define BNX2_TPAT_CPU_INTERRUPT_ENABLE			0x00085028
-#define BNX2_TPAT_CPU_INTERRUPT_VECTOR			0x0008502c
-#define BNX2_TPAT_CPU_INTERRUPT_SAVED_PC		0x00085030
-#define BNX2_TPAT_CPU_HW_BREAKPOINT			0x00085034
-#define BNX2_TPAT_CPU_HW_BREAKPOINT_DISABLE		 (1L<<0)
-#define BNX2_TPAT_CPU_HW_BREAKPOINT_ADDRESS		 (0x3fffffffL<<2)
-
-#define BNX2_TPAT_CPU_DEBUG_VECT_PEEK			0x00085038
-#define BNX2_TPAT_CPU_DEBUG_VECT_PEEK_1_VALUE		 (0x7ffL<<0)
-#define BNX2_TPAT_CPU_DEBUG_VECT_PEEK_1_PEEK_EN		 (1L<<11)
-#define BNX2_TPAT_CPU_DEBUG_VECT_PEEK_1_SEL		 (0xfL<<12)
-#define BNX2_TPAT_CPU_DEBUG_VECT_PEEK_2_VALUE		 (0x7ffL<<16)
-#define BNX2_TPAT_CPU_DEBUG_VECT_PEEK_2_PEEK_EN		 (1L<<27)
-#define BNX2_TPAT_CPU_DEBUG_VECT_PEEK_2_SEL		 (0xfL<<28)
-
-#define BNX2_TPAT_CPU_LAST_BRANCH_ADDR			0x00085048
-#define BNX2_TPAT_CPU_LAST_BRANCH_ADDR_TYPE		 (1L<<1)
-#define BNX2_TPAT_CPU_LAST_BRANCH_ADDR_TYPE_JUMP	 (0L<<1)
-#define BNX2_TPAT_CPU_LAST_BRANCH_ADDR_TYPE_BRANCH	 (1L<<1)
-#define BNX2_TPAT_CPU_LAST_BRANCH_ADDR_LBA		 (0x3fffffffL<<2)
-
-#define BNX2_TPAT_CPU_REG_FILE				0x00085200
-#define BNX2_TPAT_TPATQ					0x000853c0
-#define BNX2_TPAT_FTQ_CMD				0x000853f8
-#define BNX2_TPAT_FTQ_CMD_OFFSET			 (0x3ffL<<0)
-#define BNX2_TPAT_FTQ_CMD_WR_TOP			 (1L<<10)
-#define BNX2_TPAT_FTQ_CMD_WR_TOP_0			 (0L<<10)
-#define BNX2_TPAT_FTQ_CMD_WR_TOP_1			 (1L<<10)
-#define BNX2_TPAT_FTQ_CMD_SFT_RESET			 (1L<<25)
-#define BNX2_TPAT_FTQ_CMD_RD_DATA			 (1L<<26)
-#define BNX2_TPAT_FTQ_CMD_ADD_INTERVEN			 (1L<<27)
-#define BNX2_TPAT_FTQ_CMD_ADD_DATA			 (1L<<28)
-#define BNX2_TPAT_FTQ_CMD_INTERVENE_CLR			 (1L<<29)
-#define BNX2_TPAT_FTQ_CMD_POP				 (1L<<30)
-#define BNX2_TPAT_FTQ_CMD_BUSY				 (1L<<31)
-
-#define BNX2_TPAT_FTQ_CTL				0x000853fc
-#define BNX2_TPAT_FTQ_CTL_INTERVENE			 (1L<<0)
-#define BNX2_TPAT_FTQ_CTL_OVERFLOW			 (1L<<1)
-#define BNX2_TPAT_FTQ_CTL_FORCE_INTERVENE		 (1L<<2)
-#define BNX2_TPAT_FTQ_CTL_MAX_DEPTH			 (0x3ffL<<12)
-#define BNX2_TPAT_FTQ_CTL_CUR_DEPTH			 (0x3ffL<<22)
-
-#define BNX2_TPAT_SCRATCH				0x000a0000
-
-
-/*
- *  rxp_reg definition
- *  offset: 0xc0000
- */
-#define BNX2_RXP_CPU_MODE				0x000c5000
-#define BNX2_RXP_CPU_MODE_LOCAL_RST			 (1L<<0)
-#define BNX2_RXP_CPU_MODE_STEP_ENA			 (1L<<1)
-#define BNX2_RXP_CPU_MODE_PAGE_0_DATA_ENA		 (1L<<2)
-#define BNX2_RXP_CPU_MODE_PAGE_0_INST_ENA		 (1L<<3)
-#define BNX2_RXP_CPU_MODE_MSG_BIT1			 (1L<<6)
-#define BNX2_RXP_CPU_MODE_INTERRUPT_ENA			 (1L<<7)
-#define BNX2_RXP_CPU_MODE_SOFT_HALT			 (1L<<10)
-#define BNX2_RXP_CPU_MODE_BAD_DATA_HALT_ENA		 (1L<<11)
-#define BNX2_RXP_CPU_MODE_BAD_INST_HALT_ENA		 (1L<<12)
-#define BNX2_RXP_CPU_MODE_FIO_ABORT_HALT_ENA		 (1L<<13)
-#define BNX2_RXP_CPU_MODE_SPAD_UNDERFLOW_HALT_ENA	 (1L<<15)
-
-#define BNX2_RXP_CPU_STATE				0x000c5004
-#define BNX2_RXP_CPU_STATE_BREAKPOINT			 (1L<<0)
-#define BNX2_RXP_CPU_STATE_BAD_INST_HALTED		 (1L<<2)
-#define BNX2_RXP_CPU_STATE_PAGE_0_DATA_HALTED		 (1L<<3)
-#define BNX2_RXP_CPU_STATE_PAGE_0_INST_HALTED		 (1L<<4)
-#define BNX2_RXP_CPU_STATE_BAD_DATA_ADDR_HALTED		 (1L<<5)
-#define BNX2_RXP_CPU_STATE_BAD_PC_HALTED		 (1L<<6)
-#define BNX2_RXP_CPU_STATE_ALIGN_HALTED			 (1L<<7)
-#define BNX2_RXP_CPU_STATE_FIO_ABORT_HALTED		 (1L<<8)
-#define BNX2_RXP_CPU_STATE_SOFT_HALTED			 (1L<<10)
-#define BNX2_RXP_CPU_STATE_SPAD_UNDERFLOW		 (1L<<11)
-#define BNX2_RXP_CPU_STATE_INTERRRUPT			 (1L<<12)
-#define BNX2_RXP_CPU_STATE_DATA_ACCESS_STALL		 (1L<<14)
-#define BNX2_RXP_CPU_STATE_INST_FETCH_STALL		 (1L<<15)
-#define BNX2_RXP_CPU_STATE_BLOCKED_READ			 (1L<<31)
-
-#define BNX2_RXP_CPU_EVENT_MASK				0x000c5008
-#define BNX2_RXP_CPU_EVENT_MASK_BREAKPOINT_MASK		 (1L<<0)
-#define BNX2_RXP_CPU_EVENT_MASK_BAD_INST_HALTED_MASK	 (1L<<2)
-#define BNX2_RXP_CPU_EVENT_MASK_PAGE_0_DATA_HALTED_MASK	 (1L<<3)
-#define BNX2_RXP_CPU_EVENT_MASK_PAGE_0_INST_HALTED_MASK	 (1L<<4)
-#define BNX2_RXP_CPU_EVENT_MASK_BAD_DATA_ADDR_HALTED_MASK	 (1L<<5)
-#define BNX2_RXP_CPU_EVENT_MASK_BAD_PC_HALTED_MASK	 (1L<<6)
-#define BNX2_RXP_CPU_EVENT_MASK_ALIGN_HALTED_MASK	 (1L<<7)
-#define BNX2_RXP_CPU_EVENT_MASK_FIO_ABORT_MASK		 (1L<<8)
-#define BNX2_RXP_CPU_EVENT_MASK_SOFT_HALTED_MASK	 (1L<<10)
-#define BNX2_RXP_CPU_EVENT_MASK_SPAD_UNDERFLOW_MASK	 (1L<<11)
-#define BNX2_RXP_CPU_EVENT_MASK_INTERRUPT_MASK		 (1L<<12)
-
-#define BNX2_RXP_CPU_PROGRAM_COUNTER			0x000c501c
-#define BNX2_RXP_CPU_INSTRUCTION			0x000c5020
-#define BNX2_RXP_CPU_DATA_ACCESS			0x000c5024
-#define BNX2_RXP_CPU_INTERRUPT_ENABLE			0x000c5028
-#define BNX2_RXP_CPU_INTERRUPT_VECTOR			0x000c502c
-#define BNX2_RXP_CPU_INTERRUPT_SAVED_PC			0x000c5030
-#define BNX2_RXP_CPU_HW_BREAKPOINT			0x000c5034
-#define BNX2_RXP_CPU_HW_BREAKPOINT_DISABLE		 (1L<<0)
-#define BNX2_RXP_CPU_HW_BREAKPOINT_ADDRESS		 (0x3fffffffL<<2)
-
-#define BNX2_RXP_CPU_DEBUG_VECT_PEEK			0x000c5038
-#define BNX2_RXP_CPU_DEBUG_VECT_PEEK_1_VALUE		 (0x7ffL<<0)
-#define BNX2_RXP_CPU_DEBUG_VECT_PEEK_1_PEEK_EN		 (1L<<11)
-#define BNX2_RXP_CPU_DEBUG_VECT_PEEK_1_SEL		 (0xfL<<12)
-#define BNX2_RXP_CPU_DEBUG_VECT_PEEK_2_VALUE		 (0x7ffL<<16)
-#define BNX2_RXP_CPU_DEBUG_VECT_PEEK_2_PEEK_EN		 (1L<<27)
-#define BNX2_RXP_CPU_DEBUG_VECT_PEEK_2_SEL		 (0xfL<<28)
-
-#define BNX2_RXP_CPU_LAST_BRANCH_ADDR			0x000c5048
-#define BNX2_RXP_CPU_LAST_BRANCH_ADDR_TYPE		 (1L<<1)
-#define BNX2_RXP_CPU_LAST_BRANCH_ADDR_TYPE_JUMP		 (0L<<1)
-#define BNX2_RXP_CPU_LAST_BRANCH_ADDR_TYPE_BRANCH	 (1L<<1)
-#define BNX2_RXP_CPU_LAST_BRANCH_ADDR_LBA		 (0x3fffffffL<<2)
-
-#define BNX2_RXP_CPU_REG_FILE				0x000c5200
-#define BNX2_RXP_PFE_PFE_CTL				0x000c537c
-#define BNX2_RXP_PFE_PFE_CTL_INC_USAGE_CNT		 (1L<<0)
-#define BNX2_RXP_PFE_PFE_CTL_PFE_SIZE			 (0xfL<<4)
-#define BNX2_RXP_PFE_PFE_CTL_PFE_SIZE_0			 (0L<<4)
-#define BNX2_RXP_PFE_PFE_CTL_PFE_SIZE_1			 (1L<<4)
-#define BNX2_RXP_PFE_PFE_CTL_PFE_SIZE_2			 (2L<<4)
-#define BNX2_RXP_PFE_PFE_CTL_PFE_SIZE_3			 (3L<<4)
-#define BNX2_RXP_PFE_PFE_CTL_PFE_SIZE_4			 (4L<<4)
-#define BNX2_RXP_PFE_PFE_CTL_PFE_SIZE_5			 (5L<<4)
-#define BNX2_RXP_PFE_PFE_CTL_PFE_SIZE_6			 (6L<<4)
-#define BNX2_RXP_PFE_PFE_CTL_PFE_SIZE_7			 (7L<<4)
-#define BNX2_RXP_PFE_PFE_CTL_PFE_SIZE_8			 (8L<<4)
-#define BNX2_RXP_PFE_PFE_CTL_PFE_SIZE_9			 (9L<<4)
-#define BNX2_RXP_PFE_PFE_CTL_PFE_SIZE_10		 (10L<<4)
-#define BNX2_RXP_PFE_PFE_CTL_PFE_SIZE_11		 (11L<<4)
-#define BNX2_RXP_PFE_PFE_CTL_PFE_SIZE_12		 (12L<<4)
-#define BNX2_RXP_PFE_PFE_CTL_PFE_SIZE_13		 (13L<<4)
-#define BNX2_RXP_PFE_PFE_CTL_PFE_SIZE_14		 (14L<<4)
-#define BNX2_RXP_PFE_PFE_CTL_PFE_SIZE_15		 (15L<<4)
-#define BNX2_RXP_PFE_PFE_CTL_PFE_COUNT			 (0xfL<<12)
-#define BNX2_RXP_PFE_PFE_CTL_OFFSET			 (0x1ffL<<16)
-
-#define BNX2_RXP_RXPCQ					0x000c5380
-#define BNX2_RXP_CFTQ_CMD				0x000c53b8
-#define BNX2_RXP_CFTQ_CMD_OFFSET			 (0x3ffL<<0)
-#define BNX2_RXP_CFTQ_CMD_WR_TOP			 (1L<<10)
-#define BNX2_RXP_CFTQ_CMD_WR_TOP_0			 (0L<<10)
-#define BNX2_RXP_CFTQ_CMD_WR_TOP_1			 (1L<<10)
-#define BNX2_RXP_CFTQ_CMD_SFT_RESET			 (1L<<25)
-#define BNX2_RXP_CFTQ_CMD_RD_DATA			 (1L<<26)
-#define BNX2_RXP_CFTQ_CMD_ADD_INTERVEN			 (1L<<27)
-#define BNX2_RXP_CFTQ_CMD_ADD_DATA			 (1L<<28)
-#define BNX2_RXP_CFTQ_CMD_INTERVENE_CLR			 (1L<<29)
-#define BNX2_RXP_CFTQ_CMD_POP				 (1L<<30)
-#define BNX2_RXP_CFTQ_CMD_BUSY				 (1L<<31)
-
-#define BNX2_RXP_CFTQ_CTL				0x000c53bc
-#define BNX2_RXP_CFTQ_CTL_INTERVENE			 (1L<<0)
-#define BNX2_RXP_CFTQ_CTL_OVERFLOW			 (1L<<1)
-#define BNX2_RXP_CFTQ_CTL_FORCE_INTERVENE		 (1L<<2)
-#define BNX2_RXP_CFTQ_CTL_MAX_DEPTH			 (0x3ffL<<12)
-#define BNX2_RXP_CFTQ_CTL_CUR_DEPTH			 (0x3ffL<<22)
-
-#define BNX2_RXP_RXPQ					0x000c53c0
-#define BNX2_RXP_FTQ_CMD				0x000c53f8
-#define BNX2_RXP_FTQ_CMD_OFFSET				 (0x3ffL<<0)
-#define BNX2_RXP_FTQ_CMD_WR_TOP				 (1L<<10)
-#define BNX2_RXP_FTQ_CMD_WR_TOP_0			 (0L<<10)
-#define BNX2_RXP_FTQ_CMD_WR_TOP_1			 (1L<<10)
-#define BNX2_RXP_FTQ_CMD_SFT_RESET			 (1L<<25)
-#define BNX2_RXP_FTQ_CMD_RD_DATA			 (1L<<26)
-#define BNX2_RXP_FTQ_CMD_ADD_INTERVEN			 (1L<<27)
-#define BNX2_RXP_FTQ_CMD_ADD_DATA			 (1L<<28)
-#define BNX2_RXP_FTQ_CMD_INTERVENE_CLR			 (1L<<29)
-#define BNX2_RXP_FTQ_CMD_POP				 (1L<<30)
-#define BNX2_RXP_FTQ_CMD_BUSY				 (1L<<31)
-
-#define BNX2_RXP_FTQ_CTL				0x000c53fc
-#define BNX2_RXP_FTQ_CTL_INTERVENE			 (1L<<0)
-#define BNX2_RXP_FTQ_CTL_OVERFLOW			 (1L<<1)
-#define BNX2_RXP_FTQ_CTL_FORCE_INTERVENE		 (1L<<2)
-#define BNX2_RXP_FTQ_CTL_MAX_DEPTH			 (0x3ffL<<12)
-#define BNX2_RXP_FTQ_CTL_CUR_DEPTH			 (0x3ffL<<22)
-
-#define BNX2_RXP_SCRATCH				0x000e0000
-#define BNX2_RXP_SCRATCH_RXP_FLOOD			 0x000e0024
-#define BNX2_RXP_SCRATCH_RSS_TBL_SZ			 0x000e0038
-#define BNX2_RXP_SCRATCH_RSS_TBL			 0x000e003c
-#define BNX2_RXP_SCRATCH_RSS_TBL_MAX_ENTRIES		 128
-
-
-/*
- *  com_reg definition
- *  offset: 0x100000
- */
-#define BNX2_COM_CKSUM_ERROR_STATUS			0x00100000
-#define BNX2_COM_CKSUM_ERROR_STATUS_CALCULATED		 (0xffffL<<0)
-#define BNX2_COM_CKSUM_ERROR_STATUS_EXPECTED		 (0xffffL<<16)
-
-#define BNX2_COM_CPU_MODE				0x00105000
-#define BNX2_COM_CPU_MODE_LOCAL_RST			 (1L<<0)
-#define BNX2_COM_CPU_MODE_STEP_ENA			 (1L<<1)
-#define BNX2_COM_CPU_MODE_PAGE_0_DATA_ENA		 (1L<<2)
-#define BNX2_COM_CPU_MODE_PAGE_0_INST_ENA		 (1L<<3)
-#define BNX2_COM_CPU_MODE_MSG_BIT1			 (1L<<6)
-#define BNX2_COM_CPU_MODE_INTERRUPT_ENA			 (1L<<7)
-#define BNX2_COM_CPU_MODE_SOFT_HALT			 (1L<<10)
-#define BNX2_COM_CPU_MODE_BAD_DATA_HALT_ENA		 (1L<<11)
-#define BNX2_COM_CPU_MODE_BAD_INST_HALT_ENA		 (1L<<12)
-#define BNX2_COM_CPU_MODE_FIO_ABORT_HALT_ENA		 (1L<<13)
-#define BNX2_COM_CPU_MODE_SPAD_UNDERFLOW_HALT_ENA	 (1L<<15)
-
-#define BNX2_COM_CPU_STATE				0x00105004
-#define BNX2_COM_CPU_STATE_BREAKPOINT			 (1L<<0)
-#define BNX2_COM_CPU_STATE_BAD_INST_HALTED		 (1L<<2)
-#define BNX2_COM_CPU_STATE_PAGE_0_DATA_HALTED		 (1L<<3)
-#define BNX2_COM_CPU_STATE_PAGE_0_INST_HALTED		 (1L<<4)
-#define BNX2_COM_CPU_STATE_BAD_DATA_ADDR_HALTED		 (1L<<5)
-#define BNX2_COM_CPU_STATE_BAD_PC_HALTED		 (1L<<6)
-#define BNX2_COM_CPU_STATE_ALIGN_HALTED			 (1L<<7)
-#define BNX2_COM_CPU_STATE_FIO_ABORT_HALTED		 (1L<<8)
-#define BNX2_COM_CPU_STATE_SOFT_HALTED			 (1L<<10)
-#define BNX2_COM_CPU_STATE_SPAD_UNDERFLOW		 (1L<<11)
-#define BNX2_COM_CPU_STATE_INTERRRUPT			 (1L<<12)
-#define BNX2_COM_CPU_STATE_DATA_ACCESS_STALL		 (1L<<14)
-#define BNX2_COM_CPU_STATE_INST_FETCH_STALL		 (1L<<15)
-#define BNX2_COM_CPU_STATE_BLOCKED_READ			 (1L<<31)
-
-#define BNX2_COM_CPU_EVENT_MASK				0x00105008
-#define BNX2_COM_CPU_EVENT_MASK_BREAKPOINT_MASK		 (1L<<0)
-#define BNX2_COM_CPU_EVENT_MASK_BAD_INST_HALTED_MASK	 (1L<<2)
-#define BNX2_COM_CPU_EVENT_MASK_PAGE_0_DATA_HALTED_MASK	 (1L<<3)
-#define BNX2_COM_CPU_EVENT_MASK_PAGE_0_INST_HALTED_MASK	 (1L<<4)
-#define BNX2_COM_CPU_EVENT_MASK_BAD_DATA_ADDR_HALTED_MASK	 (1L<<5)
-#define BNX2_COM_CPU_EVENT_MASK_BAD_PC_HALTED_MASK	 (1L<<6)
-#define BNX2_COM_CPU_EVENT_MASK_ALIGN_HALTED_MASK	 (1L<<7)
-#define BNX2_COM_CPU_EVENT_MASK_FIO_ABORT_MASK		 (1L<<8)
-#define BNX2_COM_CPU_EVENT_MASK_SOFT_HALTED_MASK	 (1L<<10)
-#define BNX2_COM_CPU_EVENT_MASK_SPAD_UNDERFLOW_MASK	 (1L<<11)
-#define BNX2_COM_CPU_EVENT_MASK_INTERRUPT_MASK		 (1L<<12)
-
-#define BNX2_COM_CPU_PROGRAM_COUNTER			0x0010501c
-#define BNX2_COM_CPU_INSTRUCTION			0x00105020
-#define BNX2_COM_CPU_DATA_ACCESS			0x00105024
-#define BNX2_COM_CPU_INTERRUPT_ENABLE			0x00105028
-#define BNX2_COM_CPU_INTERRUPT_VECTOR			0x0010502c
-#define BNX2_COM_CPU_INTERRUPT_SAVED_PC			0x00105030
-#define BNX2_COM_CPU_HW_BREAKPOINT			0x00105034
-#define BNX2_COM_CPU_HW_BREAKPOINT_DISABLE		 (1L<<0)
-#define BNX2_COM_CPU_HW_BREAKPOINT_ADDRESS		 (0x3fffffffL<<2)
-
-#define BNX2_COM_CPU_DEBUG_VECT_PEEK			0x00105038
-#define BNX2_COM_CPU_DEBUG_VECT_PEEK_1_VALUE		 (0x7ffL<<0)
-#define BNX2_COM_CPU_DEBUG_VECT_PEEK_1_PEEK_EN		 (1L<<11)
-#define BNX2_COM_CPU_DEBUG_VECT_PEEK_1_SEL		 (0xfL<<12)
-#define BNX2_COM_CPU_DEBUG_VECT_PEEK_2_VALUE		 (0x7ffL<<16)
-#define BNX2_COM_CPU_DEBUG_VECT_PEEK_2_PEEK_EN		 (1L<<27)
-#define BNX2_COM_CPU_DEBUG_VECT_PEEK_2_SEL		 (0xfL<<28)
-
-#define BNX2_COM_CPU_LAST_BRANCH_ADDR			0x00105048
-#define BNX2_COM_CPU_LAST_BRANCH_ADDR_TYPE		 (1L<<1)
-#define BNX2_COM_CPU_LAST_BRANCH_ADDR_TYPE_JUMP		 (0L<<1)
-#define BNX2_COM_CPU_LAST_BRANCH_ADDR_TYPE_BRANCH	 (1L<<1)
-#define BNX2_COM_CPU_LAST_BRANCH_ADDR_LBA		 (0x3fffffffL<<2)
-
-#define BNX2_COM_CPU_REG_FILE				0x00105200
-#define BNX2_COM_COMTQ_PFE_PFE_CTL			0x001052bc
-#define BNX2_COM_COMTQ_PFE_PFE_CTL_INC_USAGE_CNT	 (1L<<0)
-#define BNX2_COM_COMTQ_PFE_PFE_CTL_PFE_SIZE		 (0xfL<<4)
-#define BNX2_COM_COMTQ_PFE_PFE_CTL_PFE_SIZE_0		 (0L<<4)
-#define BNX2_COM_COMTQ_PFE_PFE_CTL_PFE_SIZE_1		 (1L<<4)
-#define BNX2_COM_COMTQ_PFE_PFE_CTL_PFE_SIZE_2		 (2L<<4)
-#define BNX2_COM_COMTQ_PFE_PFE_CTL_PFE_SIZE_3		 (3L<<4)
-#define BNX2_COM_COMTQ_PFE_PFE_CTL_PFE_SIZE_4		 (4L<<4)
-#define BNX2_COM_COMTQ_PFE_PFE_CTL_PFE_SIZE_5		 (5L<<4)
-#define BNX2_COM_COMTQ_PFE_PFE_CTL_PFE_SIZE_6		 (6L<<4)
-#define BNX2_COM_COMTQ_PFE_PFE_CTL_PFE_SIZE_7		 (7L<<4)
-#define BNX2_COM_COMTQ_PFE_PFE_CTL_PFE_SIZE_8		 (8L<<4)
-#define BNX2_COM_COMTQ_PFE_PFE_CTL_PFE_SIZE_9		 (9L<<4)
-#define BNX2_COM_COMTQ_PFE_PFE_CTL_PFE_SIZE_10		 (10L<<4)
-#define BNX2_COM_COMTQ_PFE_PFE_CTL_PFE_SIZE_11		 (11L<<4)
-#define BNX2_COM_COMTQ_PFE_PFE_CTL_PFE_SIZE_12		 (12L<<4)
-#define BNX2_COM_COMTQ_PFE_PFE_CTL_PFE_SIZE_13		 (13L<<4)
-#define BNX2_COM_COMTQ_PFE_PFE_CTL_PFE_SIZE_14		 (14L<<4)
-#define BNX2_COM_COMTQ_PFE_PFE_CTL_PFE_SIZE_15		 (15L<<4)
-#define BNX2_COM_COMTQ_PFE_PFE_CTL_PFE_COUNT		 (0xfL<<12)
-#define BNX2_COM_COMTQ_PFE_PFE_CTL_OFFSET		 (0x1ffL<<16)
-
-#define BNX2_COM_COMXQ					0x00105340
-#define BNX2_COM_COMXQ_FTQ_CMD				0x00105378
-#define BNX2_COM_COMXQ_FTQ_CMD_OFFSET			 (0x3ffL<<0)
-#define BNX2_COM_COMXQ_FTQ_CMD_WR_TOP			 (1L<<10)
-#define BNX2_COM_COMXQ_FTQ_CMD_WR_TOP_0			 (0L<<10)
-#define BNX2_COM_COMXQ_FTQ_CMD_WR_TOP_1			 (1L<<10)
-#define BNX2_COM_COMXQ_FTQ_CMD_SFT_RESET		 (1L<<25)
-#define BNX2_COM_COMXQ_FTQ_CMD_RD_DATA			 (1L<<26)
-#define BNX2_COM_COMXQ_FTQ_CMD_ADD_INTERVEN		 (1L<<27)
-#define BNX2_COM_COMXQ_FTQ_CMD_ADD_DATA			 (1L<<28)
-#define BNX2_COM_COMXQ_FTQ_CMD_INTERVENE_CLR		 (1L<<29)
-#define BNX2_COM_COMXQ_FTQ_CMD_POP			 (1L<<30)
-#define BNX2_COM_COMXQ_FTQ_CMD_BUSY			 (1L<<31)
-
-#define BNX2_COM_COMXQ_FTQ_CTL				0x0010537c
-#define BNX2_COM_COMXQ_FTQ_CTL_INTERVENE		 (1L<<0)
-#define BNX2_COM_COMXQ_FTQ_CTL_OVERFLOW			 (1L<<1)
-#define BNX2_COM_COMXQ_FTQ_CTL_FORCE_INTERVENE		 (1L<<2)
-#define BNX2_COM_COMXQ_FTQ_CTL_MAX_DEPTH		 (0x3ffL<<12)
-#define BNX2_COM_COMXQ_FTQ_CTL_CUR_DEPTH		 (0x3ffL<<22)
-
-#define BNX2_COM_COMTQ					0x00105380
-#define BNX2_COM_COMTQ_FTQ_CMD				0x001053b8
-#define BNX2_COM_COMTQ_FTQ_CMD_OFFSET			 (0x3ffL<<0)
-#define BNX2_COM_COMTQ_FTQ_CMD_WR_TOP			 (1L<<10)
-#define BNX2_COM_COMTQ_FTQ_CMD_WR_TOP_0			 (0L<<10)
-#define BNX2_COM_COMTQ_FTQ_CMD_WR_TOP_1			 (1L<<10)
-#define BNX2_COM_COMTQ_FTQ_CMD_SFT_RESET		 (1L<<25)
-#define BNX2_COM_COMTQ_FTQ_CMD_RD_DATA			 (1L<<26)
-#define BNX2_COM_COMTQ_FTQ_CMD_ADD_INTERVEN		 (1L<<27)
-#define BNX2_COM_COMTQ_FTQ_CMD_ADD_DATA			 (1L<<28)
-#define BNX2_COM_COMTQ_FTQ_CMD_INTERVENE_CLR		 (1L<<29)
-#define BNX2_COM_COMTQ_FTQ_CMD_POP			 (1L<<30)
-#define BNX2_COM_COMTQ_FTQ_CMD_BUSY			 (1L<<31)
-
-#define BNX2_COM_COMTQ_FTQ_CTL				0x001053bc
-#define BNX2_COM_COMTQ_FTQ_CTL_INTERVENE		 (1L<<0)
-#define BNX2_COM_COMTQ_FTQ_CTL_OVERFLOW			 (1L<<1)
-#define BNX2_COM_COMTQ_FTQ_CTL_FORCE_INTERVENE		 (1L<<2)
-#define BNX2_COM_COMTQ_FTQ_CTL_MAX_DEPTH		 (0x3ffL<<12)
-#define BNX2_COM_COMTQ_FTQ_CTL_CUR_DEPTH		 (0x3ffL<<22)
-
-#define BNX2_COM_COMQ					0x001053c0
-#define BNX2_COM_COMQ_FTQ_CMD				0x001053f8
-#define BNX2_COM_COMQ_FTQ_CMD_OFFSET			 (0x3ffL<<0)
-#define BNX2_COM_COMQ_FTQ_CMD_WR_TOP			 (1L<<10)
-#define BNX2_COM_COMQ_FTQ_CMD_WR_TOP_0			 (0L<<10)
-#define BNX2_COM_COMQ_FTQ_CMD_WR_TOP_1			 (1L<<10)
-#define BNX2_COM_COMQ_FTQ_CMD_SFT_RESET			 (1L<<25)
-#define BNX2_COM_COMQ_FTQ_CMD_RD_DATA			 (1L<<26)
-#define BNX2_COM_COMQ_FTQ_CMD_ADD_INTERVEN		 (1L<<27)
-#define BNX2_COM_COMQ_FTQ_CMD_ADD_DATA			 (1L<<28)
-#define BNX2_COM_COMQ_FTQ_CMD_INTERVENE_CLR		 (1L<<29)
-#define BNX2_COM_COMQ_FTQ_CMD_POP			 (1L<<30)
-#define BNX2_COM_COMQ_FTQ_CMD_BUSY			 (1L<<31)
-
-#define BNX2_COM_COMQ_FTQ_CTL				0x001053fc
-#define BNX2_COM_COMQ_FTQ_CTL_INTERVENE			 (1L<<0)
-#define BNX2_COM_COMQ_FTQ_CTL_OVERFLOW			 (1L<<1)
-#define BNX2_COM_COMQ_FTQ_CTL_FORCE_INTERVENE		 (1L<<2)
-#define BNX2_COM_COMQ_FTQ_CTL_MAX_DEPTH			 (0x3ffL<<12)
-#define BNX2_COM_COMQ_FTQ_CTL_CUR_DEPTH			 (0x3ffL<<22)
-
-#define BNX2_COM_SCRATCH				0x00120000
-
-#define BNX2_FW_RX_DROP_COUNT				 0x00120084
-
-
-/*
- *  cp_reg definition
- *  offset: 0x180000
- */
-#define BNX2_CP_CKSUM_ERROR_STATUS			0x00180000
-#define BNX2_CP_CKSUM_ERROR_STATUS_CALCULATED		 (0xffffL<<0)
-#define BNX2_CP_CKSUM_ERROR_STATUS_EXPECTED		 (0xffffL<<16)
-
-#define BNX2_CP_CPU_MODE				0x00185000
-#define BNX2_CP_CPU_MODE_LOCAL_RST			 (1L<<0)
-#define BNX2_CP_CPU_MODE_STEP_ENA			 (1L<<1)
-#define BNX2_CP_CPU_MODE_PAGE_0_DATA_ENA		 (1L<<2)
-#define BNX2_CP_CPU_MODE_PAGE_0_INST_ENA		 (1L<<3)
-#define BNX2_CP_CPU_MODE_MSG_BIT1			 (1L<<6)
-#define BNX2_CP_CPU_MODE_INTERRUPT_ENA			 (1L<<7)
-#define BNX2_CP_CPU_MODE_SOFT_HALT			 (1L<<10)
-#define BNX2_CP_CPU_MODE_BAD_DATA_HALT_ENA		 (1L<<11)
-#define BNX2_CP_CPU_MODE_BAD_INST_HALT_ENA		 (1L<<12)
-#define BNX2_CP_CPU_MODE_FIO_ABORT_HALT_ENA		 (1L<<13)
-#define BNX2_CP_CPU_MODE_SPAD_UNDERFLOW_HALT_ENA	 (1L<<15)
-
-#define BNX2_CP_CPU_STATE				0x00185004
-#define BNX2_CP_CPU_STATE_BREAKPOINT			 (1L<<0)
-#define BNX2_CP_CPU_STATE_BAD_INST_HALTED		 (1L<<2)
-#define BNX2_CP_CPU_STATE_PAGE_0_DATA_HALTED		 (1L<<3)
-#define BNX2_CP_CPU_STATE_PAGE_0_INST_HALTED		 (1L<<4)
-#define BNX2_CP_CPU_STATE_BAD_DATA_ADDR_HALTED		 (1L<<5)
-#define BNX2_CP_CPU_STATE_BAD_PC_HALTED			 (1L<<6)
-#define BNX2_CP_CPU_STATE_ALIGN_HALTED			 (1L<<7)
-#define BNX2_CP_CPU_STATE_FIO_ABORT_HALTED		 (1L<<8)
-#define BNX2_CP_CPU_STATE_SOFT_HALTED			 (1L<<10)
-#define BNX2_CP_CPU_STATE_SPAD_UNDERFLOW		 (1L<<11)
-#define BNX2_CP_CPU_STATE_INTERRRUPT			 (1L<<12)
-#define BNX2_CP_CPU_STATE_DATA_ACCESS_STALL		 (1L<<14)
-#define BNX2_CP_CPU_STATE_INST_FETCH_STALL		 (1L<<15)
-#define BNX2_CP_CPU_STATE_BLOCKED_READ			 (1L<<31)
-
-#define BNX2_CP_CPU_EVENT_MASK				0x00185008
-#define BNX2_CP_CPU_EVENT_MASK_BREAKPOINT_MASK		 (1L<<0)
-#define BNX2_CP_CPU_EVENT_MASK_BAD_INST_HALTED_MASK	 (1L<<2)
-#define BNX2_CP_CPU_EVENT_MASK_PAGE_0_DATA_HALTED_MASK	 (1L<<3)
-#define BNX2_CP_CPU_EVENT_MASK_PAGE_0_INST_HALTED_MASK	 (1L<<4)
-#define BNX2_CP_CPU_EVENT_MASK_BAD_DATA_ADDR_HALTED_MASK	 (1L<<5)
-#define BNX2_CP_CPU_EVENT_MASK_BAD_PC_HALTED_MASK	 (1L<<6)
-#define BNX2_CP_CPU_EVENT_MASK_ALIGN_HALTED_MASK	 (1L<<7)
-#define BNX2_CP_CPU_EVENT_MASK_FIO_ABORT_MASK		 (1L<<8)
-#define BNX2_CP_CPU_EVENT_MASK_SOFT_HALTED_MASK		 (1L<<10)
-#define BNX2_CP_CPU_EVENT_MASK_SPAD_UNDERFLOW_MASK	 (1L<<11)
-#define BNX2_CP_CPU_EVENT_MASK_INTERRUPT_MASK		 (1L<<12)
-
-#define BNX2_CP_CPU_PROGRAM_COUNTER			0x0018501c
-#define BNX2_CP_CPU_INSTRUCTION				0x00185020
-#define BNX2_CP_CPU_DATA_ACCESS				0x00185024
-#define BNX2_CP_CPU_INTERRUPT_ENABLE			0x00185028
-#define BNX2_CP_CPU_INTERRUPT_VECTOR			0x0018502c
-#define BNX2_CP_CPU_INTERRUPT_SAVED_PC			0x00185030
-#define BNX2_CP_CPU_HW_BREAKPOINT			0x00185034
-#define BNX2_CP_CPU_HW_BREAKPOINT_DISABLE		 (1L<<0)
-#define BNX2_CP_CPU_HW_BREAKPOINT_ADDRESS		 (0x3fffffffL<<2)
-
-#define BNX2_CP_CPU_DEBUG_VECT_PEEK			0x00185038
-#define BNX2_CP_CPU_DEBUG_VECT_PEEK_1_VALUE		 (0x7ffL<<0)
-#define BNX2_CP_CPU_DEBUG_VECT_PEEK_1_PEEK_EN		 (1L<<11)
-#define BNX2_CP_CPU_DEBUG_VECT_PEEK_1_SEL		 (0xfL<<12)
-#define BNX2_CP_CPU_DEBUG_VECT_PEEK_2_VALUE		 (0x7ffL<<16)
-#define BNX2_CP_CPU_DEBUG_VECT_PEEK_2_PEEK_EN		 (1L<<27)
-#define BNX2_CP_CPU_DEBUG_VECT_PEEK_2_SEL		 (0xfL<<28)
-
-#define BNX2_CP_CPU_LAST_BRANCH_ADDR			0x00185048
-#define BNX2_CP_CPU_LAST_BRANCH_ADDR_TYPE		 (1L<<1)
-#define BNX2_CP_CPU_LAST_BRANCH_ADDR_TYPE_JUMP		 (0L<<1)
-#define BNX2_CP_CPU_LAST_BRANCH_ADDR_TYPE_BRANCH	 (1L<<1)
-#define BNX2_CP_CPU_LAST_BRANCH_ADDR_LBA		 (0x3fffffffL<<2)
-
-#define BNX2_CP_CPU_REG_FILE				0x00185200
-#define BNX2_CP_CPQ_PFE_PFE_CTL				0x001853bc
-#define BNX2_CP_CPQ_PFE_PFE_CTL_INC_USAGE_CNT		 (1L<<0)
-#define BNX2_CP_CPQ_PFE_PFE_CTL_PFE_SIZE		 (0xfL<<4)
-#define BNX2_CP_CPQ_PFE_PFE_CTL_PFE_SIZE_0		 (0L<<4)
-#define BNX2_CP_CPQ_PFE_PFE_CTL_PFE_SIZE_1		 (1L<<4)
-#define BNX2_CP_CPQ_PFE_PFE_CTL_PFE_SIZE_2		 (2L<<4)
-#define BNX2_CP_CPQ_PFE_PFE_CTL_PFE_SIZE_3		 (3L<<4)
-#define BNX2_CP_CPQ_PFE_PFE_CTL_PFE_SIZE_4		 (4L<<4)
-#define BNX2_CP_CPQ_PFE_PFE_CTL_PFE_SIZE_5		 (5L<<4)
-#define BNX2_CP_CPQ_PFE_PFE_CTL_PFE_SIZE_6		 (6L<<4)
-#define BNX2_CP_CPQ_PFE_PFE_CTL_PFE_SIZE_7		 (7L<<4)
-#define BNX2_CP_CPQ_PFE_PFE_CTL_PFE_SIZE_8		 (8L<<4)
-#define BNX2_CP_CPQ_PFE_PFE_CTL_PFE_SIZE_9		 (9L<<4)
-#define BNX2_CP_CPQ_PFE_PFE_CTL_PFE_SIZE_10		 (10L<<4)
-#define BNX2_CP_CPQ_PFE_PFE_CTL_PFE_SIZE_11		 (11L<<4)
-#define BNX2_CP_CPQ_PFE_PFE_CTL_PFE_SIZE_12		 (12L<<4)
-#define BNX2_CP_CPQ_PFE_PFE_CTL_PFE_SIZE_13		 (13L<<4)
-#define BNX2_CP_CPQ_PFE_PFE_CTL_PFE_SIZE_14		 (14L<<4)
-#define BNX2_CP_CPQ_PFE_PFE_CTL_PFE_SIZE_15		 (15L<<4)
-#define BNX2_CP_CPQ_PFE_PFE_CTL_PFE_COUNT		 (0xfL<<12)
-#define BNX2_CP_CPQ_PFE_PFE_CTL_OFFSET			 (0x1ffL<<16)
-
-#define BNX2_CP_CPQ					0x001853c0
-#define BNX2_CP_CPQ_FTQ_CMD				0x001853f8
-#define BNX2_CP_CPQ_FTQ_CMD_OFFSET			 (0x3ffL<<0)
-#define BNX2_CP_CPQ_FTQ_CMD_WR_TOP			 (1L<<10)
-#define BNX2_CP_CPQ_FTQ_CMD_WR_TOP_0			 (0L<<10)
-#define BNX2_CP_CPQ_FTQ_CMD_WR_TOP_1			 (1L<<10)
-#define BNX2_CP_CPQ_FTQ_CMD_SFT_RESET			 (1L<<25)
-#define BNX2_CP_CPQ_FTQ_CMD_RD_DATA			 (1L<<26)
-#define BNX2_CP_CPQ_FTQ_CMD_ADD_INTERVEN		 (1L<<27)
-#define BNX2_CP_CPQ_FTQ_CMD_ADD_DATA			 (1L<<28)
-#define BNX2_CP_CPQ_FTQ_CMD_INTERVENE_CLR		 (1L<<29)
-#define BNX2_CP_CPQ_FTQ_CMD_POP				 (1L<<30)
-#define BNX2_CP_CPQ_FTQ_CMD_BUSY			 (1L<<31)
-
-#define BNX2_CP_CPQ_FTQ_CTL				0x001853fc
-#define BNX2_CP_CPQ_FTQ_CTL_INTERVENE			 (1L<<0)
-#define BNX2_CP_CPQ_FTQ_CTL_OVERFLOW			 (1L<<1)
-#define BNX2_CP_CPQ_FTQ_CTL_FORCE_INTERVENE		 (1L<<2)
-#define BNX2_CP_CPQ_FTQ_CTL_MAX_DEPTH			 (0x3ffL<<12)
-#define BNX2_CP_CPQ_FTQ_CTL_CUR_DEPTH			 (0x3ffL<<22)
-
-#define BNX2_CP_SCRATCH					0x001a0000
-
-
-/*
- *  mcp_reg definition
- *  offset: 0x140000
- */
-#define BNX2_MCP_MCP_CONTROL				0x00140080
-#define BNX2_MCP_MCP_CONTROL_SMBUS_SEL			 (1L<<30)
-#define BNX2_MCP_MCP_CONTROL_MCP_ISOLATE		 (1L<<31)
-
-#define BNX2_MCP_MCP_ATTENTION_STATUS			0x00140084
-#define BNX2_MCP_MCP_ATTENTION_STATUS_DRV_DOORBELL	 (1L<<29)
-#define BNX2_MCP_MCP_ATTENTION_STATUS_WATCHDOG_TIMEOUT	 (1L<<30)
-#define BNX2_MCP_MCP_ATTENTION_STATUS_CPU_EVENT		 (1L<<31)
-
-#define BNX2_MCP_MCP_HEARTBEAT_CONTROL			0x00140088
-#define BNX2_MCP_MCP_HEARTBEAT_CONTROL_MCP_HEARTBEAT_ENABLE	 (1L<<31)
-
-#define BNX2_MCP_MCP_HEARTBEAT_STATUS			0x0014008c
-#define BNX2_MCP_MCP_HEARTBEAT_STATUS_MCP_HEARTBEAT_PERIOD	 (0x7ffL<<0)
-#define BNX2_MCP_MCP_HEARTBEAT_STATUS_VALID		 (1L<<31)
-
-#define BNX2_MCP_MCP_HEARTBEAT				0x00140090
-#define BNX2_MCP_MCP_HEARTBEAT_MCP_HEARTBEAT_COUNT	 (0x3fffffffL<<0)
-#define BNX2_MCP_MCP_HEARTBEAT_MCP_HEARTBEAT_INC	 (1L<<30)
-#define BNX2_MCP_MCP_HEARTBEAT_MCP_HEARTBEAT_RESET	 (1L<<31)
-
-#define BNX2_MCP_WATCHDOG_RESET				0x00140094
-#define BNX2_MCP_WATCHDOG_RESET_WATCHDOG_RESET		 (1L<<31)
-
-#define BNX2_MCP_WATCHDOG_CONTROL			0x00140098
-#define BNX2_MCP_WATCHDOG_CONTROL_WATCHDOG_TIMEOUT	 (0xfffffffL<<0)
-#define BNX2_MCP_WATCHDOG_CONTROL_WATCHDOG_ATTN		 (1L<<29)
-#define BNX2_MCP_WATCHDOG_CONTROL_MCP_RST_ENABLE	 (1L<<30)
-#define BNX2_MCP_WATCHDOG_CONTROL_WATCHDOG_ENABLE	 (1L<<31)
-
-#define BNX2_MCP_ACCESS_LOCK				0x0014009c
-#define BNX2_MCP_ACCESS_LOCK_LOCK			 (1L<<31)
-
-#define BNX2_MCP_TOE_ID					0x001400a0
-#define BNX2_MCP_TOE_ID_FUNCTION_ID			 (1L<<31)
-
-#define BNX2_MCP_MAILBOX_CFG				0x001400a4
-#define BNX2_MCP_MAILBOX_CFG_MAILBOX_OFFSET		 (0x3fffL<<0)
-#define BNX2_MCP_MAILBOX_CFG_MAILBOX_SIZE		 (0xfffL<<20)
-
-#define BNX2_MCP_MAILBOX_CFG_OTHER_FUNC			0x001400a8
-#define BNX2_MCP_MAILBOX_CFG_OTHER_FUNC_MAILBOX_OFFSET	 (0x3fffL<<0)
-#define BNX2_MCP_MAILBOX_CFG_OTHER_FUNC_MAILBOX_SIZE	 (0xfffL<<20)
-
-#define BNX2_MCP_MCP_DOORBELL				0x001400ac
-#define BNX2_MCP_MCP_DOORBELL_MCP_DOORBELL		 (1L<<31)
-
-#define BNX2_MCP_DRIVER_DOORBELL			0x001400b0
-#define BNX2_MCP_DRIVER_DOORBELL_DRIVER_DOORBELL	 (1L<<31)
-
-#define BNX2_MCP_DRIVER_DOORBELL_OTHER_FUNC		0x001400b4
-#define BNX2_MCP_DRIVER_DOORBELL_OTHER_FUNC_DRIVER_DOORBELL	 (1L<<31)
-
-#define BNX2_MCP_CPU_MODE				0x00145000
-#define BNX2_MCP_CPU_MODE_LOCAL_RST			 (1L<<0)
-#define BNX2_MCP_CPU_MODE_STEP_ENA			 (1L<<1)
-#define BNX2_MCP_CPU_MODE_PAGE_0_DATA_ENA		 (1L<<2)
-#define BNX2_MCP_CPU_MODE_PAGE_0_INST_ENA		 (1L<<3)
-#define BNX2_MCP_CPU_MODE_MSG_BIT1			 (1L<<6)
-#define BNX2_MCP_CPU_MODE_INTERRUPT_ENA			 (1L<<7)
-#define BNX2_MCP_CPU_MODE_SOFT_HALT			 (1L<<10)
-#define BNX2_MCP_CPU_MODE_BAD_DATA_HALT_ENA		 (1L<<11)
-#define BNX2_MCP_CPU_MODE_BAD_INST_HALT_ENA		 (1L<<12)
-#define BNX2_MCP_CPU_MODE_FIO_ABORT_HALT_ENA		 (1L<<13)
-#define BNX2_MCP_CPU_MODE_SPAD_UNDERFLOW_HALT_ENA	 (1L<<15)
-
-#define BNX2_MCP_CPU_STATE				0x00145004
-#define BNX2_MCP_CPU_STATE_BREAKPOINT			 (1L<<0)
-#define BNX2_MCP_CPU_STATE_BAD_INST_HALTED		 (1L<<2)
-#define BNX2_MCP_CPU_STATE_PAGE_0_DATA_HALTED		 (1L<<3)
-#define BNX2_MCP_CPU_STATE_PAGE_0_INST_HALTED		 (1L<<4)
-#define BNX2_MCP_CPU_STATE_BAD_DATA_ADDR_HALTED		 (1L<<5)
-#define BNX2_MCP_CPU_STATE_BAD_PC_HALTED		 (1L<<6)
-#define BNX2_MCP_CPU_STATE_ALIGN_HALTED			 (1L<<7)
-#define BNX2_MCP_CPU_STATE_FIO_ABORT_HALTED		 (1L<<8)
-#define BNX2_MCP_CPU_STATE_SOFT_HALTED			 (1L<<10)
-#define BNX2_MCP_CPU_STATE_SPAD_UNDERFLOW		 (1L<<11)
-#define BNX2_MCP_CPU_STATE_INTERRRUPT			 (1L<<12)
-#define BNX2_MCP_CPU_STATE_DATA_ACCESS_STALL		 (1L<<14)
-#define BNX2_MCP_CPU_STATE_INST_FETCH_STALL		 (1L<<15)
-#define BNX2_MCP_CPU_STATE_BLOCKED_READ			 (1L<<31)
-
-#define BNX2_MCP_CPU_EVENT_MASK				0x00145008
-#define BNX2_MCP_CPU_EVENT_MASK_BREAKPOINT_MASK		 (1L<<0)
-#define BNX2_MCP_CPU_EVENT_MASK_BAD_INST_HALTED_MASK	 (1L<<2)
-#define BNX2_MCP_CPU_EVENT_MASK_PAGE_0_DATA_HALTED_MASK	 (1L<<3)
-#define BNX2_MCP_CPU_EVENT_MASK_PAGE_0_INST_HALTED_MASK	 (1L<<4)
-#define BNX2_MCP_CPU_EVENT_MASK_BAD_DATA_ADDR_HALTED_MASK	 (1L<<5)
-#define BNX2_MCP_CPU_EVENT_MASK_BAD_PC_HALTED_MASK	 (1L<<6)
-#define BNX2_MCP_CPU_EVENT_MASK_ALIGN_HALTED_MASK	 (1L<<7)
-#define BNX2_MCP_CPU_EVENT_MASK_FIO_ABORT_MASK		 (1L<<8)
-#define BNX2_MCP_CPU_EVENT_MASK_SOFT_HALTED_MASK	 (1L<<10)
-#define BNX2_MCP_CPU_EVENT_MASK_SPAD_UNDERFLOW_MASK	 (1L<<11)
-#define BNX2_MCP_CPU_EVENT_MASK_INTERRUPT_MASK		 (1L<<12)
-
-#define BNX2_MCP_CPU_PROGRAM_COUNTER			0x0014501c
-#define BNX2_MCP_CPU_INSTRUCTION			0x00145020
-#define BNX2_MCP_CPU_DATA_ACCESS			0x00145024
-#define BNX2_MCP_CPU_INTERRUPT_ENABLE			0x00145028
-#define BNX2_MCP_CPU_INTERRUPT_VECTOR			0x0014502c
-#define BNX2_MCP_CPU_INTERRUPT_SAVED_PC			0x00145030
-#define BNX2_MCP_CPU_HW_BREAKPOINT			0x00145034
-#define BNX2_MCP_CPU_HW_BREAKPOINT_DISABLE		 (1L<<0)
-#define BNX2_MCP_CPU_HW_BREAKPOINT_ADDRESS		 (0x3fffffffL<<2)
-
-#define BNX2_MCP_CPU_DEBUG_VECT_PEEK			0x00145038
-#define BNX2_MCP_CPU_DEBUG_VECT_PEEK_1_VALUE		 (0x7ffL<<0)
-#define BNX2_MCP_CPU_DEBUG_VECT_PEEK_1_PEEK_EN		 (1L<<11)
-#define BNX2_MCP_CPU_DEBUG_VECT_PEEK_1_SEL		 (0xfL<<12)
-#define BNX2_MCP_CPU_DEBUG_VECT_PEEK_2_VALUE		 (0x7ffL<<16)
-#define BNX2_MCP_CPU_DEBUG_VECT_PEEK_2_PEEK_EN		 (1L<<27)
-#define BNX2_MCP_CPU_DEBUG_VECT_PEEK_2_SEL		 (0xfL<<28)
-
-#define BNX2_MCP_CPU_LAST_BRANCH_ADDR			0x00145048
-#define BNX2_MCP_CPU_LAST_BRANCH_ADDR_TYPE		 (1L<<1)
-#define BNX2_MCP_CPU_LAST_BRANCH_ADDR_TYPE_JUMP		 (0L<<1)
-#define BNX2_MCP_CPU_LAST_BRANCH_ADDR_TYPE_BRANCH	 (1L<<1)
-#define BNX2_MCP_CPU_LAST_BRANCH_ADDR_LBA		 (0x3fffffffL<<2)
-
-#define BNX2_MCP_CPU_REG_FILE				0x00145200
-#define BNX2_MCP_MCPQ					0x001453c0
-#define BNX2_MCP_MCPQ_FTQ_CMD				0x001453f8
-#define BNX2_MCP_MCPQ_FTQ_CMD_OFFSET			 (0x3ffL<<0)
-#define BNX2_MCP_MCPQ_FTQ_CMD_WR_TOP			 (1L<<10)
-#define BNX2_MCP_MCPQ_FTQ_CMD_WR_TOP_0			 (0L<<10)
-#define BNX2_MCP_MCPQ_FTQ_CMD_WR_TOP_1			 (1L<<10)
-#define BNX2_MCP_MCPQ_FTQ_CMD_SFT_RESET			 (1L<<25)
-#define BNX2_MCP_MCPQ_FTQ_CMD_RD_DATA			 (1L<<26)
-#define BNX2_MCP_MCPQ_FTQ_CMD_ADD_INTERVEN		 (1L<<27)
-#define BNX2_MCP_MCPQ_FTQ_CMD_ADD_DATA			 (1L<<28)
-#define BNX2_MCP_MCPQ_FTQ_CMD_INTERVENE_CLR		 (1L<<29)
-#define BNX2_MCP_MCPQ_FTQ_CMD_POP			 (1L<<30)
-#define BNX2_MCP_MCPQ_FTQ_CMD_BUSY			 (1L<<31)
-
-#define BNX2_MCP_MCPQ_FTQ_CTL				0x001453fc
-#define BNX2_MCP_MCPQ_FTQ_CTL_INTERVENE			 (1L<<0)
-#define BNX2_MCP_MCPQ_FTQ_CTL_OVERFLOW			 (1L<<1)
-#define BNX2_MCP_MCPQ_FTQ_CTL_FORCE_INTERVENE		 (1L<<2)
-#define BNX2_MCP_MCPQ_FTQ_CTL_MAX_DEPTH			 (0x3ffL<<12)
-#define BNX2_MCP_MCPQ_FTQ_CTL_CUR_DEPTH			 (0x3ffL<<22)
-
-#define BNX2_MCP_ROM					0x00150000
-#define BNX2_MCP_SCRATCH				0x00160000
-#define BNX2_MCP_STATE_P1				 0x0016f9c8
-#define BNX2_MCP_STATE_P0				 0x0016fdc8
-
-#define BNX2_SHM_HDR_SIGNATURE				BNX2_MCP_SCRATCH
-#define BNX2_SHM_HDR_SIGNATURE_SIG_MASK			 0xffff0000
-#define BNX2_SHM_HDR_SIGNATURE_SIG			 0x53530000
-#define BNX2_SHM_HDR_SIGNATURE_VER_MASK			 0x000000ff
-#define BNX2_SHM_HDR_SIGNATURE_VER_ONE			 0x00000001
-
-#define BNX2_SHM_HDR_ADDR_0				BNX2_MCP_SCRATCH + 4
-#define BNX2_SHM_HDR_ADDR_1				BNX2_MCP_SCRATCH + 8
-
-
-#define NUM_MC_HASH_REGISTERS   8
-
-
-/* PHY_ID1: bits 31-16; PHY_ID2: bits 15-0.  */
-#define PHY_BCM5706_PHY_ID                          0x00206160
-
-#define PHY_ID(id)                                  ((id) & 0xfffffff0)
-#define PHY_REV_ID(id)                              ((id) & 0xf)
-
-/* 5708 Serdes PHY registers */
-
-#define BCM5708S_BMCR_FORCE_2500		0x20
-
-#define BCM5708S_UP1				0xb
-
-#define BCM5708S_UP1_2G5			0x1
-
-#define BCM5708S_BLK_ADDR			0x1f
-
-#define BCM5708S_BLK_ADDR_DIG			0x0000
-#define BCM5708S_BLK_ADDR_DIG3			0x0002
-#define BCM5708S_BLK_ADDR_TX_MISC		0x0005
-
-/* Digital Block */
-#define BCM5708S_1000X_CTL1			0x10
-
-#define BCM5708S_1000X_CTL1_FIBER_MODE		0x0001
-#define BCM5708S_1000X_CTL1_AUTODET_EN		0x0010
-
-#define BCM5708S_1000X_CTL2			0x11
-
-#define BCM5708S_1000X_CTL2_PLLEL_DET_EN	0x0001
-
-#define BCM5708S_1000X_STAT1			0x14
-
-#define BCM5708S_1000X_STAT1_SGMII		0x0001
-#define BCM5708S_1000X_STAT1_LINK		0x0002
-#define BCM5708S_1000X_STAT1_FD			0x0004
-#define BCM5708S_1000X_STAT1_SPEED_MASK		0x0018
-#define BCM5708S_1000X_STAT1_SPEED_10		0x0000
-#define BCM5708S_1000X_STAT1_SPEED_100		0x0008
-#define BCM5708S_1000X_STAT1_SPEED_1G		0x0010
-#define BCM5708S_1000X_STAT1_SPEED_2G5		0x0018
-#define BCM5708S_1000X_STAT1_TX_PAUSE		0x0020
-#define BCM5708S_1000X_STAT1_RX_PAUSE		0x0040
-
-/* Digital3 Block */
-#define BCM5708S_DIG_3_0			0x10
-
-#define BCM5708S_DIG_3_0_USE_IEEE		0x0001
-
-/* Tx/Misc Block */
-#define BCM5708S_TX_ACTL1			0x15
-
-#define BCM5708S_TX_ACTL1_DRIVER_VCM		0x30
-
-#define BCM5708S_TX_ACTL3			0x17
-
-#define MII_BNX2_DSP_RW_PORT			0x15
-#define MII_BNX2_DSP_ADDRESS			0x17
-#define MII_BNX2_DSP_EXPAND_REG			 0x0f00
-#define MII_EXPAND_REG1				  (MII_BNX2_DSP_EXPAND_REG | 1)
-#define MII_EXPAND_REG1_RUDI_C			   0x20
-#define MII_EXPAND_SERDES_CTL			  (MII_BNX2_DSP_EXPAND_REG | 3)
-
-#define MII_BNX2_MISC_SHADOW			0x1c
-#define MISC_SHDW_AN_DBG			 0x6800
-#define MISC_SHDW_AN_DBG_NOSYNC			  0x0002
-#define MISC_SHDW_AN_DBG_RUDI_INVALID		  0x0100
-#define MISC_SHDW_MODE_CTL			 0x7c00
-#define MISC_SHDW_MODE_CTL_SIG_DET		  0x0010
-
-#define MII_BNX2_BLK_ADDR			0x1f
-#define MII_BNX2_BLK_ADDR_IEEE0			 0x0000
-#define MII_BNX2_BLK_ADDR_GP_STATUS		 0x8120
-#define MII_BNX2_GP_TOP_AN_STATUS1		  0x1b
-#define MII_BNX2_GP_TOP_AN_SPEED_MSK		   0x3f00
-#define MII_BNX2_GP_TOP_AN_SPEED_10		   0x0000
-#define MII_BNX2_GP_TOP_AN_SPEED_100		   0x0100
-#define MII_BNX2_GP_TOP_AN_SPEED_1G		   0x0200
-#define MII_BNX2_GP_TOP_AN_SPEED_2_5G		   0x0300
-#define MII_BNX2_GP_TOP_AN_SPEED_1GKV		   0x0d00
-#define MII_BNX2_GP_TOP_AN_FD			   0x8
-#define MII_BNX2_BLK_ADDR_SERDES_DIG		 0x8300
-#define MII_BNX2_SERDES_DIG_1000XCTL1		  0x10
-#define MII_BNX2_SD_1000XCTL1_FIBER		   0x01
-#define MII_BNX2_SD_1000XCTL1_AUTODET		   0x10
-#define MII_BNX2_SERDES_DIG_MISC1		  0x18
-#define MII_BNX2_SD_MISC1_FORCE_MSK		   0xf
-#define MII_BNX2_SD_MISC1_FORCE_2_5G		   0x0
-#define MII_BNX2_SD_MISC1_FORCE			   0x10
-#define MII_BNX2_BLK_ADDR_OVER1G		 0x8320
-#define MII_BNX2_OVER1G_UP1			  0x19
-#define MII_BNX2_BLK_ADDR_BAM_NXTPG		 0x8350
-#define MII_BNX2_BAM_NXTPG_CTL			  0x10
-#define MII_BNX2_NXTPG_CTL_BAM			   0x1
-#define MII_BNX2_NXTPG_CTL_T2			   0x2
-#define MII_BNX2_BLK_ADDR_CL73_USERB0		 0x8370
-#define MII_BNX2_CL73_BAM_CTL1			  0x12
-#define MII_BNX2_CL73_BAM_EN			   0x8000
-#define MII_BNX2_CL73_BAM_STA_MGR_EN		   0x4000
-#define MII_BNX2_CL73_BAM_NP_AFT_BP_EN		   0x2000
-#define MII_BNX2_BLK_ADDR_AER			 0xffd0
-#define MII_BNX2_AER_AER			  0x1e
-#define MII_BNX2_AER_AER_AN_MMD			   0x3800
-#define MII_BNX2_BLK_ADDR_COMBO_IEEEB0		 0xffe0
-
-#define MIN_ETHERNET_PACKET_SIZE	60
-#define MAX_ETHERNET_PACKET_SIZE	1514
-#define MAX_ETHERNET_JUMBO_PACKET_SIZE	9014
-
-#define BNX2_RX_COPY_THRESH		128
-
-#define BNX2_MISC_ENABLE_DEFAULT	0x17ffffff
-
-#define BNX2_START_UNICAST_ADDRESS_INDEX	4
-#define BNX2_END_UNICAST_ADDRESS_INDEX		7
-#define BNX2_MAX_UNICAST_ADDRESSES     	(BNX2_END_UNICAST_ADDRESS_INDEX - \
-					 BNX2_START_UNICAST_ADDRESS_INDEX + 1)
-
-#define DMA_READ_CHANS	5
-#define DMA_WRITE_CHANS	3
-
-/* Use CPU native page size up to 16K for the ring sizes.  */
-#if (PAGE_SHIFT > 14)
-#define BCM_PAGE_BITS	14
-#else
-#define BCM_PAGE_BITS	PAGE_SHIFT
-#endif
-#define BCM_PAGE_SIZE	(1 << BCM_PAGE_BITS)
-
-#define TX_DESC_CNT  (BCM_PAGE_SIZE / sizeof(struct tx_bd))
-#define MAX_TX_DESC_CNT (TX_DESC_CNT - 1)
-
-#define MAX_RX_RINGS	4
-#define MAX_RX_PG_RINGS	16
-#define RX_DESC_CNT  (BCM_PAGE_SIZE / sizeof(struct rx_bd))
-#define MAX_RX_DESC_CNT (RX_DESC_CNT - 1)
-#define MAX_TOTAL_RX_DESC_CNT (MAX_RX_DESC_CNT * MAX_RX_RINGS)
-#define MAX_TOTAL_RX_PG_DESC_CNT (MAX_RX_DESC_CNT * MAX_RX_PG_RINGS)
-
-#define NEXT_TX_BD(x) (((x) & (MAX_TX_DESC_CNT - 1)) ==			\
-		(MAX_TX_DESC_CNT - 1)) ?				\
-	(x) + 2 : (x) + 1
-
-#define TX_RING_IDX(x) ((x) & MAX_TX_DESC_CNT)
-
-#define NEXT_RX_BD(x) (((x) & (MAX_RX_DESC_CNT - 1)) ==			\
-		(MAX_RX_DESC_CNT - 1)) ?				\
-	(x) + 2 : (x) + 1
-
-#define RX_RING_IDX(x) ((x) & bp->rx_max_ring_idx)
-#define RX_PG_RING_IDX(x) ((x) & bp->rx_max_pg_ring_idx)
-
-#define RX_RING(x) (((x) & ~MAX_RX_DESC_CNT) >> (BCM_PAGE_BITS - 4))
-#define RX_IDX(x) ((x) & MAX_RX_DESC_CNT)
-
-/* Context size. */
-#define CTX_SHIFT                   7
-#define CTX_SIZE                    (1 << CTX_SHIFT)
-#define CTX_MASK                    (CTX_SIZE - 1)
-#define GET_CID_ADDR(_cid)          ((_cid) << CTX_SHIFT)
-#define GET_CID(_cid_addr)          ((_cid_addr) >> CTX_SHIFT)
-
-#define PHY_CTX_SHIFT               6
-#define PHY_CTX_SIZE                (1 << PHY_CTX_SHIFT)
-#define PHY_CTX_MASK                (PHY_CTX_SIZE - 1)
-#define GET_PCID_ADDR(_pcid)        ((_pcid) << PHY_CTX_SHIFT)
-#define GET_PCID(_pcid_addr)        ((_pcid_addr) >> PHY_CTX_SHIFT)
-
-#define MB_KERNEL_CTX_SHIFT         8
-#define MB_KERNEL_CTX_SIZE          (1 << MB_KERNEL_CTX_SHIFT)
-#define MB_KERNEL_CTX_MASK          (MB_KERNEL_CTX_SIZE - 1)
-#define MB_GET_CID_ADDR(_cid)       (0x10000 + ((_cid) << MB_KERNEL_CTX_SHIFT))
-
-#define MAX_CID_CNT                 0x4000
-#define MAX_CID_ADDR                (GET_CID_ADDR(MAX_CID_CNT))
-#define INVALID_CID_ADDR            0xffffffff
-
-#define TX_CID		16
-#define TX_TSS_CID	32
-#define RX_CID		0
-#define RX_RSS_CID	4
-#define RX_MAX_RSS_RINGS	7
-#define RX_MAX_RINGS		(RX_MAX_RSS_RINGS + 1)
-#define TX_MAX_TSS_RINGS	7
-#define TX_MAX_RINGS		(TX_MAX_TSS_RINGS + 1)
-
-#define MB_TX_CID_ADDR	MB_GET_CID_ADDR(TX_CID)
-#define MB_RX_CID_ADDR	MB_GET_CID_ADDR(RX_CID)
-
-struct sw_bd {
-	struct sk_buff		*skb;
-	DECLARE_PCI_UNMAP_ADDR(mapping)
-};
-
-struct sw_pg {
-	struct page		*page;
-	DECLARE_PCI_UNMAP_ADDR(mapping)
-};
-
-struct sw_tx_bd {
-	struct sk_buff		*skb;
-	DECLARE_PCI_UNMAP_ADDR(mapping)
-	unsigned short		is_gso;
-	unsigned short		nr_frags;
-};
-
-#define SW_RXBD_RING_SIZE (sizeof(struct sw_bd) * RX_DESC_CNT)
-#define SW_RXPG_RING_SIZE (sizeof(struct sw_pg) * RX_DESC_CNT)
-#define RXBD_RING_SIZE (sizeof(struct rx_bd) * RX_DESC_CNT)
-#define SW_TXBD_RING_SIZE (sizeof(struct sw_tx_bd) * TX_DESC_CNT)
-#define TXBD_RING_SIZE (sizeof(struct tx_bd) * TX_DESC_CNT)
-
-/* Buffered flash (Atmel: AT45DB011B) specific information */
-#define SEEPROM_PAGE_BITS			2
-#define SEEPROM_PHY_PAGE_SIZE			(1 << SEEPROM_PAGE_BITS)
-#define SEEPROM_BYTE_ADDR_MASK			(SEEPROM_PHY_PAGE_SIZE-1)
-#define SEEPROM_PAGE_SIZE			4
-#define SEEPROM_TOTAL_SIZE			65536
-
-#define BUFFERED_FLASH_PAGE_BITS		9
-#define BUFFERED_FLASH_PHY_PAGE_SIZE		(1 << BUFFERED_FLASH_PAGE_BITS)
-#define BUFFERED_FLASH_BYTE_ADDR_MASK		(BUFFERED_FLASH_PHY_PAGE_SIZE-1)
-#define BUFFERED_FLASH_PAGE_SIZE		264
-#define BUFFERED_FLASH_TOTAL_SIZE		0x21000
-
-#define SAIFUN_FLASH_PAGE_BITS			8
-#define SAIFUN_FLASH_PHY_PAGE_SIZE		(1 << SAIFUN_FLASH_PAGE_BITS)
-#define SAIFUN_FLASH_BYTE_ADDR_MASK		(SAIFUN_FLASH_PHY_PAGE_SIZE-1)
-#define SAIFUN_FLASH_PAGE_SIZE			256
-#define SAIFUN_FLASH_BASE_TOTAL_SIZE		65536
-
-#define ST_MICRO_FLASH_PAGE_BITS		8
-#define ST_MICRO_FLASH_PHY_PAGE_SIZE		(1 << ST_MICRO_FLASH_PAGE_BITS)
-#define ST_MICRO_FLASH_BYTE_ADDR_MASK		(ST_MICRO_FLASH_PHY_PAGE_SIZE-1)
-#define ST_MICRO_FLASH_PAGE_SIZE		256
-#define ST_MICRO_FLASH_BASE_TOTAL_SIZE		65536
-
-#define BCM5709_FLASH_PAGE_BITS			8
-#define BCM5709_FLASH_PHY_PAGE_SIZE		(1 << BCM5709_FLASH_PAGE_BITS)
-#define BCM5709_FLASH_BYTE_ADDR_MASK		(BCM5709_FLASH_PHY_PAGE_SIZE-1)
-#define BCM5709_FLASH_PAGE_SIZE			256
-
-#define NVRAM_TIMEOUT_COUNT			30000
-
-
-#define FLASH_STRAP_MASK			(BNX2_NVM_CFG1_FLASH_MODE   | \
-						 BNX2_NVM_CFG1_BUFFER_MODE  | \
-						 BNX2_NVM_CFG1_PROTECT_MODE | \
-						 BNX2_NVM_CFG1_FLASH_SIZE)
-
-#define FLASH_BACKUP_STRAP_MASK			(0xf << 26)
-
-struct flash_spec {
-	u32 strapping;
-	u32 config1;
-	u32 config2;
-	u32 config3;
-	u32 write1;
-	u32 flags;
-#define BNX2_NV_BUFFERED	0x00000001
-#define BNX2_NV_TRANSLATE	0x00000002
-#define BNX2_NV_WREN		0x00000004
-	u32 page_bits;
-	u32 page_size;
-	u32 addr_mask;
-	u32 total_size;
-	u8  *name;
-};
-
-#define BNX2_MAX_MSIX_HW_VEC	9
-#define BNX2_MAX_MSIX_VEC	9
-#define BNX2_BASE_VEC		0
-#define BNX2_TX_VEC		1
-#define BNX2_TX_INT_NUM	(BNX2_TX_VEC << BNX2_PCICFG_INT_ACK_CMD_INT_NUM_SHIFT)
-
-struct bnx2_irq {
-	irq_handler_t	handler;
-	unsigned int	vector;
-	u8		requested;
-	char		name[IFNAMSIZ + 2];
-};
-
-struct bnx2_tx_ring_info {
-	u32			tx_prod_bseq;
-	u16			tx_prod;
-	u32			tx_bidx_addr;
-	u32			tx_bseq_addr;
-
-	struct tx_bd		*tx_desc_ring;
-	struct sw_tx_bd		*tx_buf_ring;
-
-	u16			tx_cons;
-	u16			hw_tx_cons;
-
-	dma_addr_t		tx_desc_mapping;
-};
-
-struct bnx2_rx_ring_info {
-	u32			rx_prod_bseq;
-	u16			rx_prod;
-	u16			rx_cons;
-
-	u32			rx_bidx_addr;
-	u32			rx_bseq_addr;
-	u32			rx_pg_bidx_addr;
-
-	u16			rx_pg_prod;
-	u16			rx_pg_cons;
-
-	struct sw_bd		*rx_buf_ring;
-	struct rx_bd		*rx_desc_ring[MAX_RX_RINGS];
-	struct sw_pg		*rx_pg_ring;
-	struct rx_bd		*rx_pg_desc_ring[MAX_RX_PG_RINGS];
-
-	dma_addr_t		rx_desc_mapping[MAX_RX_RINGS];
-	dma_addr_t		rx_pg_desc_mapping[MAX_RX_PG_RINGS];
-};
-
-struct bnx2_napi {
-	struct napi_struct	napi		____cacheline_aligned;
-	struct bnx2		*bp;
-	union {
-		struct status_block		*msi;
-		struct status_block_msix	*msix;
-	} status_blk;
-	u16			*hw_tx_cons_ptr;
-	u16			*hw_rx_cons_ptr;
-	u32 			last_status_idx;
-	u32			int_num;
-
-#ifdef BCM_CNIC
-	u32			cnic_tag;
-	int			cnic_present;
-#endif
-
-	struct bnx2_rx_ring_info	rx_ring;
-	struct bnx2_tx_ring_info	tx_ring;
-};
-
-struct bnx2 {
-	/* Fields used in the tx and intr/napi performance paths are grouped */
-	/* together in the beginning of the structure. */
-	void __iomem		*regview;
-
-	struct net_device	*dev;
-	struct pci_dev		*pdev;
-
-	atomic_t		intr_sem;
-
-	u32			flags;
-#define BNX2_FLAG_PCIX			0x00000001
-#define BNX2_FLAG_PCI_32BIT		0x00000002
-#define BNX2_FLAG_MSIX_CAP		0x00000004
-#define BNX2_FLAG_NO_WOL		0x00000008
-#define BNX2_FLAG_USING_MSI		0x00000020
-#define BNX2_FLAG_ASF_ENABLE		0x00000040
-#define BNX2_FLAG_MSI_CAP		0x00000080
-#define BNX2_FLAG_ONE_SHOT_MSI		0x00000100
-#define BNX2_FLAG_PCIE			0x00000200
-#define BNX2_FLAG_USING_MSIX		0x00000400
-#define BNX2_FLAG_USING_MSI_OR_MSIX	(BNX2_FLAG_USING_MSI | \
-					 BNX2_FLAG_USING_MSIX)
-#define BNX2_FLAG_JUMBO_BROKEN		0x00000800
-#define BNX2_FLAG_CAN_KEEP_VLAN		0x00001000
-#define BNX2_FLAG_BROKEN_STATS		0x00002000
-
-	struct bnx2_napi	bnx2_napi[BNX2_MAX_MSIX_VEC];
-
-#ifdef BCM_VLAN
-	struct			vlan_group *vlgrp;
-#endif
-
-	u32			rx_buf_use_size;	/* useable size */
-	u32			rx_buf_size;		/* with alignment */
-	u32			rx_copy_thresh;
-	u32			rx_jumbo_thresh;
-	u32			rx_max_ring_idx;
-	u32			rx_max_pg_ring_idx;
-
-	u32			rx_csum;
-
-	/* TX constants */
-	int		tx_ring_size;
-	u32		tx_wake_thresh;
-
-#ifdef BCM_CNIC
-	struct cnic_ops		*cnic_ops;
-	void			*cnic_data;
-#endif
-
-	/* End of fields used in the performance code paths. */
-
-	unsigned int		current_interval;
-#define BNX2_TIMER_INTERVAL		HZ
-#define BNX2_SERDES_AN_TIMEOUT		(HZ / 3)
-#define BNX2_SERDES_FORCED_TIMEOUT	(HZ / 10)
-
-	struct			timer_list timer;
-	struct work_struct	reset_task;
-
-	/* Used to synchronize phy accesses. */
-	spinlock_t		phy_lock;
-	spinlock_t		indirect_lock;
-
-	u32			phy_flags;
-#define BNX2_PHY_FLAG_SERDES			0x00000001
-#define BNX2_PHY_FLAG_CRC_FIX			0x00000002
-#define BNX2_PHY_FLAG_PARALLEL_DETECT		0x00000004
-#define BNX2_PHY_FLAG_2_5G_CAPABLE		0x00000008
-#define BNX2_PHY_FLAG_INT_MODE_MASK		0x00000300
-#define BNX2_PHY_FLAG_INT_MODE_AUTO_POLLING	0x00000100
-#define BNX2_PHY_FLAG_INT_MODE_LINK_READY	0x00000200
-#define BNX2_PHY_FLAG_DIS_EARLY_DAC		0x00000400
-#define BNX2_PHY_FLAG_REMOTE_PHY_CAP		0x00000800
-#define BNX2_PHY_FLAG_FORCED_DOWN		0x00001000
-#define BNX2_PHY_FLAG_NO_PARALLEL		0x00002000
-
-	u32			mii_bmcr;
-	u32			mii_bmsr;
-	u32			mii_bmsr1;
-	u32			mii_adv;
-	u32			mii_lpa;
-	u32			mii_up1;
-
-	u32			chip_id;
-	/* chip num:16-31, rev:12-15, metal:4-11, bond_id:0-3 */
-#define CHIP_NUM(bp)			(((bp)->chip_id) & 0xffff0000)
-#define CHIP_NUM_5706			0x57060000
-#define CHIP_NUM_5708			0x57080000
-#define CHIP_NUM_5709			0x57090000
-
-#define CHIP_REV(bp)			(((bp)->chip_id) & 0x0000f000)
-#define CHIP_REV_Ax			0x00000000
-#define CHIP_REV_Bx			0x00001000
-#define CHIP_REV_Cx			0x00002000
-
-#define CHIP_METAL(bp)			(((bp)->chip_id) & 0x00000ff0)
-#define CHIP_BONDING(bp)		(((bp)->chip_id) & 0x0000000f)
-
-#define CHIP_ID(bp)			(((bp)->chip_id) & 0xfffffff0)
-#define CHIP_ID_5706_A0			0x57060000
-#define CHIP_ID_5706_A1			0x57060010
-#define CHIP_ID_5706_A2			0x57060020
-#define CHIP_ID_5708_A0			0x57080000
-#define CHIP_ID_5708_B0			0x57081000
-#define CHIP_ID_5708_B1			0x57081010
-#define CHIP_ID_5709_A0			0x57090000
-#define CHIP_ID_5709_A1			0x57090010
-
-#define CHIP_BOND_ID(bp)		(((bp)->chip_id) & 0xf)
-
-/* A serdes chip will have the first bit of the bond id set. */
-#define CHIP_BOND_ID_SERDES_BIT		0x01
-
-	u32			phy_addr;
-	u32			phy_id;
-
-	u16			bus_speed_mhz;
-	u8			wol;
-
-	u8			pad;
-
-	u16			fw_wr_seq;
-	u16			fw_drv_pulse_wr_seq;
-
-	int			rx_max_ring;
-	int			rx_ring_size;
-
-	int			rx_max_pg_ring;
-	int			rx_pg_ring_size;
-
-	u16			tx_quick_cons_trip;
-	u16			tx_quick_cons_trip_int;
-	u16			rx_quick_cons_trip;
-	u16			rx_quick_cons_trip_int;
-	u16			comp_prod_trip;
-	u16			comp_prod_trip_int;
-	u16			tx_ticks;
-	u16			tx_ticks_int;
-	u16			com_ticks;
-	u16			com_ticks_int;
-	u16			cmd_ticks;
-	u16			cmd_ticks_int;
-	u16			rx_ticks;
-	u16			rx_ticks_int;
-
-	u32			stats_ticks;
-
-	dma_addr_t		status_blk_mapping;
-
-	struct statistics_block	*stats_blk;
-	dma_addr_t		stats_blk_mapping;
-
-	int			ctx_pages;
-	void			*ctx_blk[4];
-	dma_addr_t		ctx_blk_mapping[4];
-
-	u32			hc_cmd;
-	u32			rx_mode;
-
-	u16			req_line_speed;
-	u8			req_duplex;
-
-	u8			phy_port;
-	u8			link_up;
-
-	u16			line_speed;
-	u8			duplex;
-	u8			flow_ctrl;	/* actual flow ctrl settings */
-						/* may be different from     */
-						/* req_flow_ctrl if autoneg  */
-	u32			advertising;
-
-	u8			req_flow_ctrl;	/* flow ctrl advertisement */
-						/* settings or forced      */
-						/* settings                */
-	u8			autoneg;
-#define AUTONEG_SPEED		1
-#define AUTONEG_FLOW_CTRL	2
-
-	u8			loopback;
-#define MAC_LOOPBACK		1
-#define PHY_LOOPBACK		2
-
-	u8			serdes_an_pending;
-
-	u8			mac_addr[8];
-
-	u32			shmem_base;
-
-	char			fw_version[32];
-
-	int			pm_cap;
-	int			pcix_cap;
-
-	const struct flash_spec	*flash_info;
-	u32			flash_size;
-
-	int			status_stats_size;
-
-	struct bnx2_irq		irq_tbl[BNX2_MAX_MSIX_VEC];
-	int			irq_nvecs;
-
-	u8			num_tx_rings;
-	u8			num_rx_rings;
-
-	u32			idle_chk_status_idx;
-
-#ifdef BCM_CNIC
-	struct mutex		cnic_lock;
-	struct cnic_eth_dev	cnic_eth_dev;
-#endif
-
-	const struct firmware	*mips_firmware;
-	const struct firmware	*rv2p_firmware;
-};
-
-#define REG_RD(bp, offset)					\
-	readl(bp->regview + offset)
-
-#define REG_WR(bp, offset, val)					\
-	writel(val, bp->regview + offset)
-
-#define REG_WR16(bp, offset, val)				\
-	writew(val, bp->regview + offset)
-
-struct cpu_reg {
-	u32 mode;
-	u32 mode_value_halt;
-	u32 mode_value_sstep;
-
-	u32 state;
-	u32 state_value_clear;
-
-	u32 gpr0;
-	u32 evmask;
-	u32 pc;
-	u32 inst;
-	u32 bp;
-
-	u32 spad_base;
-
-	u32 mips_view_base;
-};
-
-struct bnx2_fw_file_section {
-	__be32 addr;
-	__be32 len;
-	__be32 offset;
-};
-
-struct bnx2_mips_fw_file_entry {
-	__be32 start_addr;
-	struct bnx2_fw_file_section text;
-	struct bnx2_fw_file_section data;
-	struct bnx2_fw_file_section rodata;
-};
-
-struct bnx2_rv2p_fw_file_entry {
-	struct bnx2_fw_file_section rv2p;
-	__be32 fixup[8];
-};
-
-struct bnx2_mips_fw_file {
-	struct bnx2_mips_fw_file_entry com;
-	struct bnx2_mips_fw_file_entry cp;
-	struct bnx2_mips_fw_file_entry rxp;
-	struct bnx2_mips_fw_file_entry tpat;
-	struct bnx2_mips_fw_file_entry txp;
-};
-
-struct bnx2_rv2p_fw_file {
-	struct bnx2_rv2p_fw_file_entry proc1;
-	struct bnx2_rv2p_fw_file_entry proc2;
-};
-
-#define RV2P_P1_FIXUP_PAGE_SIZE_IDX		0
-#define RV2P_BD_PAGE_SIZE_MSK			0xffff
-#define RV2P_BD_PAGE_SIZE			((BCM_PAGE_SIZE / 16) - 1)
-
-#define RV2P_PROC1                              0
-#define RV2P_PROC2                              1
-
-
-/* This value (in milliseconds) determines the frequency of the driver
- * issuing the PULSE message code.  The firmware monitors this periodic
- * pulse to determine when to switch to an OS-absent mode. */
-#define BNX2_DRV_PULSE_PERIOD_MS                 250
-
-/* This value (in milliseconds) determines how long the driver should
- * wait for an acknowledgement from the firmware before timing out.  Once
- * the firmware has timed out, the driver will assume there is no firmware
- * running and there won't be any firmware-driver synchronization during a
- * driver reset. */
-#define BNX2_FW_ACK_TIME_OUT_MS                  1000
-
-
-#define BNX2_DRV_RESET_SIGNATURE		0x00000000
-#define BNX2_DRV_RESET_SIGNATURE_MAGIC		 0x4841564b /* HAVK */
-//#define DRV_RESET_SIGNATURE_MAGIC		 0x47495352 /* RSIG */
-
-#define BNX2_DRV_MB				0x00000004
-#define BNX2_DRV_MSG_CODE			 0xff000000
-#define BNX2_DRV_MSG_CODE_RESET			 0x01000000
-#define BNX2_DRV_MSG_CODE_UNLOAD		 0x02000000
-#define BNX2_DRV_MSG_CODE_SHUTDOWN		 0x03000000
-#define BNX2_DRV_MSG_CODE_SUSPEND_WOL		 0x04000000
-#define BNX2_DRV_MSG_CODE_FW_TIMEOUT		 0x05000000
-#define BNX2_DRV_MSG_CODE_PULSE			 0x06000000
-#define BNX2_DRV_MSG_CODE_DIAG			 0x07000000
-#define BNX2_DRV_MSG_CODE_SUSPEND_NO_WOL	 0x09000000
-#define BNX2_DRV_MSG_CODE_UNLOAD_LNK_DN		 0x0b000000
-#define BNX2_DRV_MSG_CODE_KEEP_VLAN_UPDATE	 0x0d000000
-#define BNX2_DRV_MSG_CODE_CMD_SET_LINK		 0x10000000
-
-#define BNX2_DRV_MSG_DATA			 0x00ff0000
-#define BNX2_DRV_MSG_DATA_WAIT0			 0x00010000
-#define BNX2_DRV_MSG_DATA_WAIT1			 0x00020000
-#define BNX2_DRV_MSG_DATA_WAIT2			 0x00030000
-#define BNX2_DRV_MSG_DATA_WAIT3			 0x00040000
-
-#define BNX2_DRV_MSG_SEQ			 0x0000ffff
-
-#define BNX2_FW_MB				0x00000008
-#define BNX2_FW_MSG_ACK				 0x0000ffff
-#define BNX2_FW_MSG_STATUS_MASK			 0x00ff0000
-#define BNX2_FW_MSG_STATUS_OK			 0x00000000
-#define BNX2_FW_MSG_STATUS_FAILURE		 0x00ff0000
-
-#define BNX2_LINK_STATUS			0x0000000c
-#define BNX2_LINK_STATUS_INIT_VALUE		 0xffffffff
-#define BNX2_LINK_STATUS_LINK_UP		 0x1
-#define BNX2_LINK_STATUS_LINK_DOWN		 0x0
-#define BNX2_LINK_STATUS_SPEED_MASK		 0x1e
-#define BNX2_LINK_STATUS_AN_INCOMPLETE		 (0<<1)
-#define BNX2_LINK_STATUS_10HALF			 (1<<1)
-#define BNX2_LINK_STATUS_10FULL			 (2<<1)
-#define BNX2_LINK_STATUS_100HALF		 (3<<1)
-#define BNX2_LINK_STATUS_100BASE_T4		 (4<<1)
-#define BNX2_LINK_STATUS_100FULL		 (5<<1)
-#define BNX2_LINK_STATUS_1000HALF		 (6<<1)
-#define BNX2_LINK_STATUS_1000FULL		 (7<<1)
-#define BNX2_LINK_STATUS_2500HALF		 (8<<1)
-#define BNX2_LINK_STATUS_2500FULL		 (9<<1)
-#define BNX2_LINK_STATUS_AN_ENABLED		 (1<<5)
-#define BNX2_LINK_STATUS_AN_COMPLETE		 (1<<6)
-#define BNX2_LINK_STATUS_PARALLEL_DET		 (1<<7)
-#define BNX2_LINK_STATUS_RESERVED		 (1<<8)
-#define BNX2_LINK_STATUS_PARTNER_AD_1000FULL	 (1<<9)
-#define BNX2_LINK_STATUS_PARTNER_AD_1000HALF	 (1<<10)
-#define BNX2_LINK_STATUS_PARTNER_AD_100BT4	 (1<<11)
-#define BNX2_LINK_STATUS_PARTNER_AD_100FULL	 (1<<12)
-#define BNX2_LINK_STATUS_PARTNER_AD_100HALF	 (1<<13)
-#define BNX2_LINK_STATUS_PARTNER_AD_10FULL	 (1<<14)
-#define BNX2_LINK_STATUS_PARTNER_AD_10HALF	 (1<<15)
-#define BNX2_LINK_STATUS_TX_FC_ENABLED		 (1<<16)
-#define BNX2_LINK_STATUS_RX_FC_ENABLED		 (1<<17)
-#define BNX2_LINK_STATUS_PARTNER_SYM_PAUSE_CAP	 (1<<18)
-#define BNX2_LINK_STATUS_PARTNER_ASYM_PAUSE_CAP	 (1<<19)
-#define BNX2_LINK_STATUS_SERDES_LINK		 (1<<20)
-#define BNX2_LINK_STATUS_PARTNER_AD_2500FULL	 (1<<21)
-#define BNX2_LINK_STATUS_PARTNER_AD_2500HALF	 (1<<22)
-#define BNX2_LINK_STATUS_HEART_BEAT_EXPIRED	 (1<<31)
-
-#define BNX2_DRV_PULSE_MB			0x00000010
-#define BNX2_DRV_PULSE_SEQ_MASK			 0x00007fff
-
-/* Indicate to the firmware not to go into the
- * OS absent when it is not getting driver pulse.
- * This is used for debugging. */
-#define BNX2_DRV_MSG_DATA_PULSE_CODE_ALWAYS_ALIVE	 0x00080000
-
-#define BNX2_DRV_MB_ARG0			0x00000014
-#define BNX2_NETLINK_SET_LINK_SPEED_10HALF	 (1<<0)
-#define BNX2_NETLINK_SET_LINK_SPEED_10FULL	 (1<<1)
-#define BNX2_NETLINK_SET_LINK_SPEED_10		 \
-	(BNX2_NETLINK_SET_LINK_SPEED_10HALF |	 \
-	 BNX2_NETLINK_SET_LINK_SPEED_10FULL)
-#define BNX2_NETLINK_SET_LINK_SPEED_100HALF	 (1<<2)
-#define BNX2_NETLINK_SET_LINK_SPEED_100FULL	 (1<<3)
-#define BNX2_NETLINK_SET_LINK_SPEED_100		 \
-	(BNX2_NETLINK_SET_LINK_SPEED_100HALF |	 \
-	 BNX2_NETLINK_SET_LINK_SPEED_100FULL)
-#define BNX2_NETLINK_SET_LINK_SPEED_1GHALF	 (1<<4)
-#define BNX2_NETLINK_SET_LINK_SPEED_1GFULL	 (1<<5)
-#define BNX2_NETLINK_SET_LINK_SPEED_2G5HALF	 (1<<6)
-#define BNX2_NETLINK_SET_LINK_SPEED_2G5FULL	 (1<<7)
-#define BNX2_NETLINK_SET_LINK_SPEED_10GHALF	 (1<<8)
-#define BNX2_NETLINK_SET_LINK_SPEED_10GFULL	 (1<<9)
-#define BNX2_NETLINK_SET_LINK_ENABLE_AUTONEG	 (1<<10)
-#define BNX2_NETLINK_SET_LINK_PHY_APP_REMOTE	 (1<<11)
-#define BNX2_NETLINK_SET_LINK_FC_SYM_PAUSE	 (1<<12)
-#define BNX2_NETLINK_SET_LINK_FC_ASYM_PAUSE	 (1<<13)
-#define BNX2_NETLINK_SET_LINK_ETH_AT_WIRESPEED	 (1<<14)
-#define BNX2_NETLINK_SET_LINK_PHY_RESET		 (1<<15)
-
-#define BNX2_DEV_INFO_SIGNATURE			0x00000020
-#define BNX2_DEV_INFO_SIGNATURE_MAGIC		 0x44564900
-#define BNX2_DEV_INFO_SIGNATURE_MAGIC_MASK	 0xffffff00
-#define BNX2_DEV_INFO_FEATURE_CFG_VALID		 0x01
-#define BNX2_DEV_INFO_SECONDARY_PORT		 0x80
-#define BNX2_DEV_INFO_DRV_ALWAYS_ALIVE		 0x40
-
-#define BNX2_SHARED_HW_CFG_PART_NUM		0x00000024
-
-#define BNX2_SHARED_HW_CFG_POWER_DISSIPATED	0x00000034
-#define BNX2_SHARED_HW_CFG_POWER_STATE_D3_MASK	 0xff000000
-#define BNX2_SHARED_HW_CFG_POWER_STATE_D2_MASK	 0xff0000
-#define BNX2_SHARED_HW_CFG_POWER_STATE_D1_MASK	 0xff00
-#define BNX2_SHARED_HW_CFG_POWER_STATE_D0_MASK	 0xff
-
-#define BNX2_SHARED_HW_CFG POWER_CONSUMED	0x00000038
-#define BNX2_SHARED_HW_CFG_CONFIG		0x0000003c
-#define BNX2_SHARED_HW_CFG_DESIGN_NIC		 0
-#define BNX2_SHARED_HW_CFG_DESIGN_LOM		 0x1
-#define BNX2_SHARED_HW_CFG_PHY_COPPER		 0
-#define BNX2_SHARED_HW_CFG_PHY_FIBER		 0x2
-#define BNX2_SHARED_HW_CFG_PHY_2_5G		 0x20
-#define BNX2_SHARED_HW_CFG_PHY_BACKPLANE	 0x40
-#define BNX2_SHARED_HW_CFG_LED_MODE_SHIFT_BITS	 8
-#define BNX2_SHARED_HW_CFG_LED_MODE_MASK	 0x300
-#define BNX2_SHARED_HW_CFG_LED_MODE_MAC		 0
-#define BNX2_SHARED_HW_CFG_LED_MODE_GPHY1	 0x100
-#define BNX2_SHARED_HW_CFG_LED_MODE_GPHY2	 0x200
-#define BNX2_SHARED_HW_CFG_GIG_LINK_ON_VAUX	 0x8000
-
-#define BNX2_SHARED_HW_CFG_CONFIG2		0x00000040
-#define BNX2_SHARED_HW_CFG2_NVM_SIZE_MASK	 0x00fff000
-
-#define BNX2_DEV_INFO_BC_REV			0x0000004c
-
-#define BNX2_PORT_HW_CFG_MAC_UPPER		0x00000050
-#define BNX2_PORT_HW_CFG_UPPERMAC_MASK		 0xffff
-
-#define BNX2_PORT_HW_CFG_MAC_LOWER		0x00000054
-#define BNX2_PORT_HW_CFG_CONFIG			0x00000058
-#define BNX2_PORT_HW_CFG_CFG_TXCTL3_MASK	 0x0000ffff
-#define BNX2_PORT_HW_CFG_CFG_DFLT_LINK_MASK	 0x001f0000
-#define BNX2_PORT_HW_CFG_CFG_DFLT_LINK_AN	 0x00000000
-#define BNX2_PORT_HW_CFG_CFG_DFLT_LINK_1G	 0x00030000
-#define BNX2_PORT_HW_CFG_CFG_DFLT_LINK_2_5G	 0x00040000
-
-#define BNX2_PORT_HW_CFG_IMD_MAC_A_UPPER	0x00000068
-#define BNX2_PORT_HW_CFG_IMD_MAC_A_LOWER	0x0000006c
-#define BNX2_PORT_HW_CFG_IMD_MAC_B_UPPER	0x00000070
-#define BNX2_PORT_HW_CFG_IMD_MAC_B_LOWER	0x00000074
-#define BNX2_PORT_HW_CFG_ISCSI_MAC_UPPER	0x00000078
-#define BNX2_PORT_HW_CFG_ISCSI_MAC_LOWER	0x0000007c
-
-#define BNX2_DEV_INFO_PER_PORT_HW_CONFIG2	0x000000b4
-
-#define BNX2_DEV_INFO_FORMAT_REV		0x000000c4
-#define BNX2_DEV_INFO_FORMAT_REV_MASK		 0xff000000
-#define BNX2_DEV_INFO_FORMAT_REV_ID		 ('A' << 24)
-
-#define BNX2_SHARED_FEATURE			0x000000c8
-#define BNX2_SHARED_FEATURE_MASK		 0xffffffff
-
-#define BNX2_PORT_FEATURE			0x000000d8
-#define BNX2_PORT2_FEATURE			0x00000014c
-#define BNX2_PORT_FEATURE_WOL_ENABLED		 0x01000000
-#define BNX2_PORT_FEATURE_MBA_ENABLED		 0x02000000
-#define BNX2_PORT_FEATURE_ASF_ENABLED		 0x04000000
-#define BNX2_PORT_FEATURE_IMD_ENABLED		 0x08000000
-#define BNX2_PORT_FEATURE_BAR1_SIZE_MASK	 0xf
-#define BNX2_PORT_FEATURE_BAR1_SIZE_DISABLED	 0x0
-#define BNX2_PORT_FEATURE_BAR1_SIZE_64K		 0x1
-#define BNX2_PORT_FEATURE_BAR1_SIZE_128K	 0x2
-#define BNX2_PORT_FEATURE_BAR1_SIZE_256K	 0x3
-#define BNX2_PORT_FEATURE_BAR1_SIZE_512K	 0x4
-#define BNX2_PORT_FEATURE_BAR1_SIZE_1M		 0x5
-#define BNX2_PORT_FEATURE_BAR1_SIZE_2M		 0x6
-#define BNX2_PORT_FEATURE_BAR1_SIZE_4M		 0x7
-#define BNX2_PORT_FEATURE_BAR1_SIZE_8M		 0x8
-#define BNX2_PORT_FEATURE_BAR1_SIZE_16M		 0x9
-#define BNX2_PORT_FEATURE_BAR1_SIZE_32M		 0xa
-#define BNX2_PORT_FEATURE_BAR1_SIZE_64M		 0xb
-#define BNX2_PORT_FEATURE_BAR1_SIZE_128M	 0xc
-#define BNX2_PORT_FEATURE_BAR1_SIZE_256M	 0xd
-#define BNX2_PORT_FEATURE_BAR1_SIZE_512M	 0xe
-#define BNX2_PORT_FEATURE_BAR1_SIZE_1G		 0xf
-
-#define BNX2_PORT_FEATURE_WOL			0xdc
-#define BNX2_PORT2_FEATURE_WOL			0x150
-#define BNX2_PORT_FEATURE_WOL_DEFAULT_SHIFT_BITS	 4
-#define BNX2_PORT_FEATURE_WOL_DEFAULT_MASK	 0x30
-#define BNX2_PORT_FEATURE_WOL_DEFAULT_DISABLE	 0
-#define BNX2_PORT_FEATURE_WOL_DEFAULT_MAGIC	 0x10
-#define BNX2_PORT_FEATURE_WOL_DEFAULT_ACPI	 0x20
-#define BNX2_PORT_FEATURE_WOL_DEFAULT_MAGIC_AND_ACPI	 0x30
-#define BNX2_PORT_FEATURE_WOL_LINK_SPEED_MASK	 0xf
-#define BNX2_PORT_FEATURE_WOL_LINK_SPEED_AUTONEG	 0
-#define BNX2_PORT_FEATURE_WOL_LINK_SPEED_10HALF	 1
-#define BNX2_PORT_FEATURE_WOL_LINK_SPEED_10FULL	 2
-#define BNX2_PORT_FEATURE_WOL_LINK_SPEED_100HALF 3
-#define BNX2_PORT_FEATURE_WOL_LINK_SPEED_100FULL 4
-#define BNX2_PORT_FEATURE_WOL_LINK_SPEED_1000HALF	 5
-#define BNX2_PORT_FEATURE_WOL_LINK_SPEED_1000FULL	 6
-#define BNX2_PORT_FEATURE_WOL_AUTONEG_ADVERTISE_1000	 0x40
-#define BNX2_PORT_FEATURE_WOL_RESERVED_PAUSE_CAP 0x400
-#define BNX2_PORT_FEATURE_WOL_RESERVED_ASYM_PAUSE_CAP	 0x800
-
-#define BNX2_PORT_FEATURE_MBA			0xe0
-#define BNX2_PORT2_FEATURE_MBA			0x154
-#define BNX2_PORT_FEATURE_MBA_BOOT_AGENT_TYPE_SHIFT_BITS	 0
-#define BNX2_PORT_FEATURE_MBA_BOOT_AGENT_TYPE_MASK	 0x3
-#define BNX2_PORT_FEATURE_MBA_BOOT_AGENT_TYPE_PXE	 0
-#define BNX2_PORT_FEATURE_MBA_BOOT_AGENT_TYPE_RPL	 1
-#define BNX2_PORT_FEATURE_MBA_BOOT_AGENT_TYPE_BOOTP	 2
-#define BNX2_PORT_FEATURE_MBA_LINK_SPEED_SHIFT_BITS	 2
-#define BNX2_PORT_FEATURE_MBA_LINK_SPEED_MASK	 0x3c
-#define BNX2_PORT_FEATURE_MBA_LINK_SPEED_AUTONEG	 0
-#define BNX2_PORT_FEATURE_MBA_LINK_SPEED_10HALF	 0x4
-#define BNX2_PORT_FEATURE_MBA_LINK_SPEED_10FULL	 0x8
-#define BNX2_PORT_FEATURE_MBA_LINK_SPEED_100HALF	 0xc
-#define BNX2_PORT_FEATURE_MBA_LINK_SPEED_100FULL	 0x10
-#define BNX2_PORT_FEATURE_MBA_LINK_SPEED_1000HALF	 0x14
-#define BNX2_PORT_FEATURE_MBA_LINK_SPEED_1000FULL	 0x18
-#define BNX2_PORT_FEATURE_MBA_SETUP_PROMPT_ENABLE	 0x40
-#define BNX2_PORT_FEATURE_MBA_HOTKEY_CTRL_S	 0
-#define BNX2_PORT_FEATURE_MBA_HOTKEY_CTRL_B	 0x80
-#define BNX2_PORT_FEATURE_MBA_EXP_ROM_SIZE_SHIFT_BITS	 8
-#define BNX2_PORT_FEATURE_MBA_EXP_ROM_SIZE_MASK	 0xff00
-#define BNX2_PORT_FEATURE_MBA_EXP_ROM_SIZE_DISABLED	 0
-#define BNX2_PORT_FEATURE_MBA_EXP_ROM_SIZE_1K	 0x100
-#define BNX2_PORT_FEATURE_MBA_EXP_ROM_SIZE_2K	 0x200
-#define BNX2_PORT_FEATURE_MBA_EXP_ROM_SIZE_4K	 0x300
-#define BNX2_PORT_FEATURE_MBA_EXP_ROM_SIZE_8K	 0x400
-#define BNX2_PORT_FEATURE_MBA_EXP_ROM_SIZE_16K	 0x500
-#define BNX2_PORT_FEATURE_MBA_EXP_ROM_SIZE_32K	 0x600
-#define BNX2_PORT_FEATURE_MBA_EXP_ROM_SIZE_64K	 0x700
-#define BNX2_PORT_FEATURE_MBA_EXP_ROM_SIZE_128K	 0x800
-#define BNX2_PORT_FEATURE_MBA_EXP_ROM_SIZE_256K	 0x900
-#define BNX2_PORT_FEATURE_MBA_EXP_ROM_SIZE_512K	 0xa00
-#define BNX2_PORT_FEATURE_MBA_EXP_ROM_SIZE_1M	 0xb00
-#define BNX2_PORT_FEATURE_MBA_EXP_ROM_SIZE_2M	 0xc00
-#define BNX2_PORT_FEATURE_MBA_EXP_ROM_SIZE_4M	 0xd00
-#define BNX2_PORT_FEATURE_MBA_EXP_ROM_SIZE_8M	 0xe00
-#define BNX2_PORT_FEATURE_MBA_EXP_ROM_SIZE_16M	 0xf00
-#define BNX2_PORT_FEATURE_MBA_MSG_TIMEOUT_SHIFT_BITS	 16
-#define BNX2_PORT_FEATURE_MBA_MSG_TIMEOUT_MASK	 0xf0000
-#define BNX2_PORT_FEATURE_MBA_BIOS_BOOTSTRAP_SHIFT_BITS	 20
-#define BNX2_PORT_FEATURE_MBA_BIOS_BOOTSTRAP_MASK	 0x300000
-#define BNX2_PORT_FEATURE_MBA_BIOS_BOOTSTRAP_AUTO	 0
-#define BNX2_PORT_FEATURE_MBA_BIOS_BOOTSTRAP_BBS	 0x100000
-#define BNX2_PORT_FEATURE_MBA_BIOS_BOOTSTRAP_INT18H	 0x200000
-#define BNX2_PORT_FEATURE_MBA_BIOS_BOOTSTRAP_INT19H	 0x300000
-
-#define BNX2_PORT_FEATURE_IMD			0xe4
-#define BNX2_PORT2_FEATURE_IMD			0x158
-#define BNX2_PORT_FEATURE_IMD_LINK_OVERRIDE_DEFAULT	 0
-#define BNX2_PORT_FEATURE_IMD_LINK_OVERRIDE_ENABLE	 1
-
-#define BNX2_PORT_FEATURE_VLAN			0xe8
-#define BNX2_PORT2_FEATURE_VLAN			0x15c
-#define BNX2_PORT_FEATURE_MBA_VLAN_TAG_MASK	 0xffff
-#define BNX2_PORT_FEATURE_MBA_VLAN_ENABLE	 0x10000
-
-#define BNX2_MFW_VER_PTR			0x00000014c
-
-#define BNX2_BC_STATE_RESET_TYPE		0x000001c0
-#define BNX2_BC_STATE_RESET_TYPE_SIG		 0x00005254
-#define BNX2_BC_STATE_RESET_TYPE_SIG_MASK	 0x0000ffff
-#define BNX2_BC_STATE_RESET_TYPE_NONE	 (BNX2_BC_STATE_RESET_TYPE_SIG | \
-					  0x00010000)
-#define BNX2_BC_STATE_RESET_TYPE_PCI	 (BNX2_BC_STATE_RESET_TYPE_SIG | \
-					  0x00020000)
-#define BNX2_BC_STATE_RESET_TYPE_VAUX	 (BNX2_BC_STATE_RESET_TYPE_SIG | \
-					  0x00030000)
-#define BNX2_BC_STATE_RESET_TYPE_DRV_MASK	 DRV_MSG_CODE
-#define BNX2_BC_STATE_RESET_TYPE_DRV_RESET (BNX2_BC_STATE_RESET_TYPE_SIG | \
-					    DRV_MSG_CODE_RESET)
-#define BNX2_BC_STATE_RESET_TYPE_DRV_UNLOAD (BNX2_BC_STATE_RESET_TYPE_SIG | \
-					     DRV_MSG_CODE_UNLOAD)
-#define BNX2_BC_STATE_RESET_TYPE_DRV_SHUTDOWN (BNX2_BC_STATE_RESET_TYPE_SIG | \
-					       DRV_MSG_CODE_SHUTDOWN)
-#define BNX2_BC_STATE_RESET_TYPE_DRV_WOL (BNX2_BC_STATE_RESET_TYPE_SIG | \
-					  DRV_MSG_CODE_WOL)
-#define BNX2_BC_STATE_RESET_TYPE_DRV_DIAG (BNX2_BC_STATE_RESET_TYPE_SIG | \
-					   DRV_MSG_CODE_DIAG)
-#define BNX2_BC_STATE_RESET_TYPE_VALUE(msg) (BNX2_BC_STATE_RESET_TYPE_SIG | \
-					     (msg))
-
-#define BNX2_BC_STATE				0x000001c4
-#define BNX2_BC_STATE_ERR_MASK			 0x0000ff00
-#define BNX2_BC_STATE_SIGN			 0x42530000
-#define BNX2_BC_STATE_SIGN_MASK			 0xffff0000
-#define BNX2_BC_STATE_BC1_START			 (BNX2_BC_STATE_SIGN | 0x1)
-#define BNX2_BC_STATE_GET_NVM_CFG1		 (BNX2_BC_STATE_SIGN | 0x2)
-#define BNX2_BC_STATE_PROG_BAR			 (BNX2_BC_STATE_SIGN | 0x3)
-#define BNX2_BC_STATE_INIT_VID			 (BNX2_BC_STATE_SIGN | 0x4)
-#define BNX2_BC_STATE_GET_NVM_CFG2		 (BNX2_BC_STATE_SIGN | 0x5)
-#define BNX2_BC_STATE_APPLY_WKARND		 (BNX2_BC_STATE_SIGN | 0x6)
-#define BNX2_BC_STATE_LOAD_BC2			 (BNX2_BC_STATE_SIGN | 0x7)
-#define BNX2_BC_STATE_GOING_BC2			 (BNX2_BC_STATE_SIGN | 0x8)
-#define BNX2_BC_STATE_GOING_DIAG		 (BNX2_BC_STATE_SIGN | 0x9)
-#define BNX2_BC_STATE_RT_FINAL_INIT		 (BNX2_BC_STATE_SIGN | 0x81)
-#define BNX2_BC_STATE_RT_WKARND			 (BNX2_BC_STATE_SIGN | 0x82)
-#define BNX2_BC_STATE_RT_DRV_PULSE		 (BNX2_BC_STATE_SIGN | 0x83)
-#define BNX2_BC_STATE_RT_FIOEVTS		 (BNX2_BC_STATE_SIGN | 0x84)
-#define BNX2_BC_STATE_RT_DRV_CMD		 (BNX2_BC_STATE_SIGN | 0x85)
-#define BNX2_BC_STATE_RT_LOW_POWER		 (BNX2_BC_STATE_SIGN | 0x86)
-#define BNX2_BC_STATE_RT_SET_WOL		 (BNX2_BC_STATE_SIGN | 0x87)
-#define BNX2_BC_STATE_RT_OTHER_FW		 (BNX2_BC_STATE_SIGN | 0x88)
-#define BNX2_BC_STATE_RT_GOING_D3		 (BNX2_BC_STATE_SIGN | 0x89)
-#define BNX2_BC_STATE_ERR_BAD_VERSION		 (BNX2_BC_STATE_SIGN | 0x0100)
-#define BNX2_BC_STATE_ERR_BAD_BC2_CRC		 (BNX2_BC_STATE_SIGN | 0x0200)
-#define BNX2_BC_STATE_ERR_BC1_LOOP		 (BNX2_BC_STATE_SIGN | 0x0300)
-#define BNX2_BC_STATE_ERR_UNKNOWN_CMD		 (BNX2_BC_STATE_SIGN | 0x0400)
-#define BNX2_BC_STATE_ERR_DRV_DEAD		 (BNX2_BC_STATE_SIGN | 0x0500)
-#define BNX2_BC_STATE_ERR_NO_RXP		 (BNX2_BC_STATE_SIGN | 0x0600)
-#define BNX2_BC_STATE_ERR_TOO_MANY_RBUF		 (BNX2_BC_STATE_SIGN | 0x0700)
-
-#define BNX2_BC_STATE_CONDITION			0x000001c8
-#define BNX2_CONDITION_MFW_RUN_UNKNOWN		 0x00000000
-#define BNX2_CONDITION_MFW_RUN_IPMI		 0x00002000
-#define BNX2_CONDITION_MFW_RUN_UMP		 0x00004000
-#define BNX2_CONDITION_MFW_RUN_NCSI		 0x00006000
-#define BNX2_CONDITION_MFW_RUN_NONE		 0x0000e000
-#define BNX2_CONDITION_MFW_RUN_MASK		 0x0000e000
-
-#define BNX2_BC_STATE_DEBUG_CMD			0x1dc
-#define BNX2_BC_STATE_BC_DBG_CMD_SIGNATURE	 0x42440000
-#define BNX2_BC_STATE_BC_DBG_CMD_SIGNATURE_MASK	 0xffff0000
-#define BNX2_BC_STATE_BC_DBG_CMD_LOOP_CNT_MASK	 0xffff
-#define BNX2_BC_STATE_BC_DBG_CMD_LOOP_INFINITE	 0xffff
-
-#define BNX2_FW_EVT_CODE_MB			0x354
-#define BNX2_FW_EVT_CODE_SW_TIMER_EXPIRATION_EVENT 0x00000000
-#define BNX2_FW_EVT_CODE_LINK_EVENT		 0x00000001
-
-#define BNX2_DRV_ACK_CAP_MB			0x364
-#define BNX2_DRV_ACK_CAP_SIGNATURE		 0x35450000
-#define BNX2_CAPABILITY_SIGNATURE_MASK		 0xFFFF0000
-
-#define BNX2_FW_CAP_MB				0x368
-#define BNX2_FW_CAP_SIGNATURE			 0xaa550000
-#define BNX2_FW_ACK_DRV_SIGNATURE		 0x52500000
-#define BNX2_FW_CAP_SIGNATURE_MASK		 0xffff0000
-#define BNX2_FW_CAP_REMOTE_PHY_CAPABLE		 0x00000001
-#define BNX2_FW_CAP_REMOTE_PHY_PRESENT		 0x00000002
-#define BNX2_FW_CAP_MFW_CAN_KEEP_VLAN		 0x00000008
-#define BNX2_FW_CAP_BC_CAN_KEEP_VLAN		 0x00000010
-#define BNX2_FW_CAP_CAN_KEEP_VLAN	(BNX2_FW_CAP_BC_CAN_KEEP_VLAN | \
-					 BNX2_FW_CAP_MFW_CAN_KEEP_VLAN)
-
-#define BNX2_RPHY_SIGNATURE			0x36c
-#define BNX2_RPHY_LOAD_SIGNATURE		 0x5a5a5a5a
-
-#define BNX2_RPHY_FLAGS				0x370
-#define BNX2_RPHY_SERDES_LINK			0x374
-#define BNX2_RPHY_COPPER_LINK			0x378
-
-#define HOST_VIEW_SHMEM_BASE			0x167c00
-
-#endif
diff -r f4bf81a7ff20 drivers/net/bnx2_fw.h
--- a/drivers/net/bnx2_fw.h
+++ /dev/null
@@ -1,88 +0,0 @@
-/* bnx2_fw.h: Broadcom NX2 network driver.
- *
- * Copyright (c) 2004, 2005, 2006, 2007 Broadcom Corporation
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation.
- */
-
-/* Initialized Values for the Completion Processor. */
-static const struct cpu_reg cpu_reg_com = {
-	.mode = BNX2_COM_CPU_MODE,
-	.mode_value_halt = BNX2_COM_CPU_MODE_SOFT_HALT,
-	.mode_value_sstep = BNX2_COM_CPU_MODE_STEP_ENA,
-	.state = BNX2_COM_CPU_STATE,
-	.state_value_clear = 0xffffff,
-	.gpr0 = BNX2_COM_CPU_REG_FILE,
-	.evmask = BNX2_COM_CPU_EVENT_MASK,
-	.pc = BNX2_COM_CPU_PROGRAM_COUNTER,
-	.inst = BNX2_COM_CPU_INSTRUCTION,
-	.bp = BNX2_COM_CPU_HW_BREAKPOINT,
-	.spad_base = BNX2_COM_SCRATCH,
-	.mips_view_base = 0x8000000,
-};
-
-/* Initialized Values the Command Processor. */
-static const struct cpu_reg cpu_reg_cp = {
-	.mode = BNX2_CP_CPU_MODE,
-	.mode_value_halt = BNX2_CP_CPU_MODE_SOFT_HALT,
-	.mode_value_sstep = BNX2_CP_CPU_MODE_STEP_ENA,
-	.state = BNX2_CP_CPU_STATE,
-	.state_value_clear = 0xffffff,
-	.gpr0 = BNX2_CP_CPU_REG_FILE,
-	.evmask = BNX2_CP_CPU_EVENT_MASK,
-	.pc = BNX2_CP_CPU_PROGRAM_COUNTER,
-	.inst = BNX2_CP_CPU_INSTRUCTION,
-	.bp = BNX2_CP_CPU_HW_BREAKPOINT,
-	.spad_base = BNX2_CP_SCRATCH,
-	.mips_view_base = 0x8000000,
-};
-
-/* Initialized Values for the RX Processor. */
-static const struct cpu_reg cpu_reg_rxp = {
-	.mode = BNX2_RXP_CPU_MODE,
-	.mode_value_halt = BNX2_RXP_CPU_MODE_SOFT_HALT,
-	.mode_value_sstep = BNX2_RXP_CPU_MODE_STEP_ENA,
-	.state = BNX2_RXP_CPU_STATE,
-	.state_value_clear = 0xffffff,
-	.gpr0 = BNX2_RXP_CPU_REG_FILE,
-	.evmask = BNX2_RXP_CPU_EVENT_MASK,
-	.pc = BNX2_RXP_CPU_PROGRAM_COUNTER,
-	.inst = BNX2_RXP_CPU_INSTRUCTION,
-	.bp = BNX2_RXP_CPU_HW_BREAKPOINT,
-	.spad_base = BNX2_RXP_SCRATCH,
-	.mips_view_base = 0x8000000,
-};
-
-/* Initialized Values for the TX Patch-up Processor. */
-static const struct cpu_reg cpu_reg_tpat = {
-	.mode = BNX2_TPAT_CPU_MODE,
-	.mode_value_halt = BNX2_TPAT_CPU_MODE_SOFT_HALT,
-	.mode_value_sstep = BNX2_TPAT_CPU_MODE_STEP_ENA,
-	.state = BNX2_TPAT_CPU_STATE,
-	.state_value_clear = 0xffffff,
-	.gpr0 = BNX2_TPAT_CPU_REG_FILE,
-	.evmask = BNX2_TPAT_CPU_EVENT_MASK,
-	.pc = BNX2_TPAT_CPU_PROGRAM_COUNTER,
-	.inst = BNX2_TPAT_CPU_INSTRUCTION,
-	.bp = BNX2_TPAT_CPU_HW_BREAKPOINT,
-	.spad_base = BNX2_TPAT_SCRATCH,
-	.mips_view_base = 0x8000000,
-};
-
-/* Initialized Values for the TX Processor. */
-static const struct cpu_reg cpu_reg_txp = {
-	.mode = BNX2_TXP_CPU_MODE,
-	.mode_value_halt = BNX2_TXP_CPU_MODE_SOFT_HALT,
-	.mode_value_sstep = BNX2_TXP_CPU_MODE_STEP_ENA,
-	.state = BNX2_TXP_CPU_STATE,
-	.state_value_clear = 0xffffff,
-	.gpr0 = BNX2_TXP_CPU_REG_FILE,
-	.evmask = BNX2_TXP_CPU_EVENT_MASK,
-	.pc = BNX2_TXP_CPU_PROGRAM_COUNTER,
-	.inst = BNX2_TXP_CPU_INSTRUCTION,
-	.bp = BNX2_TXP_CPU_HW_BREAKPOINT,
-	.spad_base = BNX2_TXP_SCRATCH,
-	.mips_view_base = 0x8000000,
-};
diff -r f4bf81a7ff20 drivers/net/bnx2x.h
--- a/drivers/net/bnx2x.h
+++ /dev/null
@@ -1,1339 +0,0 @@
-/* bnx2x.h: Broadcom Everest network driver.
- *
- * Copyright (c) 2007-2010 Broadcom Corporation
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation.
- *
- * Maintained by: Eilon Greenstein <eilong@broadcom.com>
- * Written by: Eliezer Tamir
- * Based on code from Michael Chan's bnx2 driver
- */
-
-#ifndef BNX2X_H
-#define BNX2X_H
-
-/* compilation time flags */
-
-/* define this to make the driver freeze on error to allow getting debug info
- * (you will need to reboot afterwards) */
-/* #define BNX2X_STOP_ON_ERROR */
-
-#if defined(CONFIG_VLAN_8021Q) || defined(CONFIG_VLAN_8021Q_MODULE)
-#define BCM_VLAN			1
-#endif
-
-
-#define BNX2X_MULTI_QUEUE
-
-#define BNX2X_NEW_NAPI
-
-
-#if defined(CONFIG_CNIC) || defined(CONFIG_CNIC_MODULE)
-#define BCM_CNIC 1
-#include "cnic_if.h"
-#endif
-
-#include <linux/mdio.h>
-#include "bnx2x_compat.h"
-#include "bnx2x_reg.h"
-#include "bnx2x_fw_defs.h"
-#include "bnx2x_hsi.h"
-#include "bnx2x_link.h"
-
-/* error/debug prints */
-
-#define DRV_MODULE_NAME		"bnx2x"
-
-/* for messages that are currently off */
-#define BNX2X_MSG_OFF			0
-#define BNX2X_MSG_MCP			0x010000 /* was: NETIF_MSG_HW */
-#define BNX2X_MSG_STATS			0x020000 /* was: NETIF_MSG_TIMER */
-#define BNX2X_MSG_NVM			0x040000 /* was: NETIF_MSG_HW */
-#define BNX2X_MSG_DMAE			0x080000 /* was: NETIF_MSG_HW */
-#define BNX2X_MSG_SP			0x100000 /* was: NETIF_MSG_INTR */
-#define BNX2X_MSG_FP			0x200000 /* was: NETIF_MSG_INTR */
-
-#define DP_LEVEL			KERN_NOTICE	/* was: KERN_DEBUG */
-
-/* regular debug print */
-#define DP(__mask, __fmt, __args...)				\
-do {								\
-	if (bp->msg_enable & (__mask))				\
-		printk(DP_LEVEL "[%s:%d(%s)]" __fmt,		\
-		       __func__, __LINE__,			\
-		       bp->dev ? (bp->dev->name) : "?",		\
-		       ##__args);				\
-} while (0)
-
-/* errors debug print */
-#define BNX2X_DBG_ERR(__fmt, __args...)				\
-do {								\
-	if (netif_msg_probe(bp))				\
-		pr_err("[%s:%d(%s)]" __fmt,			\
-		       __func__, __LINE__,			\
-		       bp->dev ? (bp->dev->name) : "?",		\
-		       ##__args);				\
-} while (0)
-
-/* for errors (never masked) */
-#define BNX2X_ERR(__fmt, __args...)				\
-do {								\
-	pr_err("[%s:%d(%s)]" __fmt,				\
-	       __func__, __LINE__,				\
-	       bp->dev ? (bp->dev->name) : "?",			\
-	       ##__args);					\
-} while (0)
-
-/* before we have a dev->name use dev_info() */
-#define BNX2X_DEV_INFO(__fmt, __args...)			 \
-do {								 \
-	if (netif_msg_probe(bp))				 \
-		dev_info(&bp->pdev->dev, __fmt, ##__args);	 \
-} while (0)
-
-
-#ifdef BNX2X_STOP_ON_ERROR
-#define bnx2x_panic() do { \
-		bp->panic = 1; \
-		BNX2X_ERR("driver assert\n"); \
-		bnx2x_int_disable(bp); \
-		bnx2x_panic_dump(bp); \
-	} while (0)
-#else
-#define bnx2x_panic() do { \
-		bp->panic = 1; \
-		BNX2X_ERR("driver assert\n"); \
-		bnx2x_panic_dump(bp); \
-	} while (0)
-#endif
-
-
-#define U64_LO(x)			(u32)(((u64)(x)) & 0xffffffff)
-#define U64_HI(x)			(u32)(((u64)(x)) >> 32)
-#define HILO_U64(hi, lo)		((((u64)(hi)) << 32) + (lo))
-
-
-#define REG_ADDR(bp, offset)		(bp->regview + offset)
-
-#define REG_RD(bp, offset)		readl(REG_ADDR(bp, offset))
-#define REG_RD8(bp, offset)		readb(REG_ADDR(bp, offset))
-
-#define REG_WR(bp, offset, val)		writel((u32)val, REG_ADDR(bp, offset))
-#define REG_WR8(bp, offset, val)	writeb((u8)val, REG_ADDR(bp, offset))
-#define REG_WR16(bp, offset, val)	writew((u16)val, REG_ADDR(bp, offset))
-
-#define REG_RD_IND(bp, offset)		bnx2x_reg_rd_ind(bp, offset)
-#define REG_WR_IND(bp, offset, val)	bnx2x_reg_wr_ind(bp, offset, val)
-
-#define REG_RD_DMAE(bp, offset, valp, len32) \
-	do { \
-		bnx2x_read_dmae(bp, offset, len32);\
-		memcpy(valp, bnx2x_sp(bp, wb_data[0]), (len32) * 4); \
-	} while (0)
-
-#define REG_WR_DMAE(bp, offset, valp, len32) \
-	do { \
-		memcpy(bnx2x_sp(bp, wb_data[0]), valp, (len32) * 4); \
-		bnx2x_write_dmae(bp, bnx2x_sp_mapping(bp, wb_data), \
-				 offset, len32); \
-	} while (0)
-
-#define VIRT_WR_DMAE_LEN(bp, data, addr, len32, le32_swap) \
-	do { \
-		memcpy(GUNZIP_BUF(bp), data, (len32) * 4); \
-		bnx2x_write_big_buf_wb(bp, addr, len32); \
-	} while (0)
-
-#define SHMEM_ADDR(bp, field)		(bp->common.shmem_base + \
-					 offsetof(struct shmem_region, field))
-#define SHMEM_RD(bp, field)		REG_RD(bp, SHMEM_ADDR(bp, field))
-#define SHMEM_WR(bp, field, val)	REG_WR(bp, SHMEM_ADDR(bp, field), val)
-
-#define SHMEM2_ADDR(bp, field)		(bp->common.shmem2_base + \
-					 offsetof(struct shmem2_region, field))
-#define SHMEM2_RD(bp, field)		REG_RD(bp, SHMEM2_ADDR(bp, field))
-#define SHMEM2_WR(bp, field, val)	REG_WR(bp, SHMEM2_ADDR(bp, field), val)
-
-#define EMAC_RD(bp, reg)		REG_RD(bp, emac_base + reg)
-#define EMAC_WR(bp, reg, val)		REG_WR(bp, emac_base + reg, val)
-
-
-/* fast path */
-
-struct sw_rx_bd {
-	struct sk_buff	*skb;
-	DECLARE_PCI_UNMAP_ADDR(mapping)
-};
-
-struct sw_tx_bd {
-	struct sk_buff	*skb;
-	u16		first_bd;
-	u8		flags;
-/* Set on the first BD descriptor when there is a split BD */
-#define BNX2X_TSO_SPLIT_BD		(1<<0)
-};
-
-struct sw_rx_page {
-	struct page	*page;
-	DECLARE_PCI_UNMAP_ADDR(mapping)
-};
-
-union db_prod {
-	struct doorbell_set_prod data;
-	u32		raw;
-};
-
-
-/* MC hsi */
-#define BCM_PAGE_SHIFT			12
-#define BCM_PAGE_SIZE			(1 << BCM_PAGE_SHIFT)
-#define BCM_PAGE_MASK			(~(BCM_PAGE_SIZE - 1))
-#define BCM_PAGE_ALIGN(addr)	(((addr) + BCM_PAGE_SIZE - 1) & BCM_PAGE_MASK)
-
-#define PAGES_PER_SGE_SHIFT		0
-#define PAGES_PER_SGE			(1 << PAGES_PER_SGE_SHIFT)
-#define SGE_PAGE_SIZE			PAGE_SIZE
-#define SGE_PAGE_SHIFT			PAGE_SHIFT
-#define SGE_PAGE_ALIGN(addr)		PAGE_ALIGN((typeof(PAGE_SIZE))(addr))
-
-/* SGE ring related macros */
-#define NUM_RX_SGE_PAGES		2
-#define RX_SGE_CNT		(BCM_PAGE_SIZE / sizeof(struct eth_rx_sge))
-#define MAX_RX_SGE_CNT			(RX_SGE_CNT - 2)
-/* RX_SGE_CNT is promised to be a power of 2 */
-#define RX_SGE_MASK			(RX_SGE_CNT - 1)
-#define NUM_RX_SGE			(RX_SGE_CNT * NUM_RX_SGE_PAGES)
-#define MAX_RX_SGE			(NUM_RX_SGE - 1)
-#define NEXT_SGE_IDX(x)		((((x) & RX_SGE_MASK) == \
-				  (MAX_RX_SGE_CNT - 1)) ? (x) + 3 : (x) + 1)
-#define RX_SGE(x)			((x) & MAX_RX_SGE)
-
-/* SGE producer mask related macros */
-/* Number of bits in one sge_mask array element */
-#define RX_SGE_MASK_ELEM_SZ		64
-#define RX_SGE_MASK_ELEM_SHIFT		6
-#define RX_SGE_MASK_ELEM_MASK		((u64)RX_SGE_MASK_ELEM_SZ - 1)
-
-/* Creates a bitmask of all ones in less significant bits.
-   idx - index of the most significant bit in the created mask */
-#define RX_SGE_ONES_MASK(idx) \
-		(((u64)0x1 << (((idx) & RX_SGE_MASK_ELEM_MASK) + 1)) - 1)
-#define RX_SGE_MASK_ELEM_ONE_MASK	((u64)(~0))
-
-/* Number of u64 elements in SGE mask array */
-#define RX_SGE_MASK_LEN			((NUM_RX_SGE_PAGES * RX_SGE_CNT) / \
-					 RX_SGE_MASK_ELEM_SZ)
-#define RX_SGE_MASK_LEN_MASK		(RX_SGE_MASK_LEN - 1)
-#define NEXT_SGE_MASK_ELEM(el)		(((el) + 1) & RX_SGE_MASK_LEN_MASK)
-
-
-struct bnx2x_eth_q_stats {
-	u32 total_bytes_received_hi;
-	u32 total_bytes_received_lo;
-	u32 total_bytes_transmitted_hi;
-	u32 total_bytes_transmitted_lo;
-	u32 total_unicast_packets_received_hi;
-	u32 total_unicast_packets_received_lo;
-	u32 total_multicast_packets_received_hi;
-	u32 total_multicast_packets_received_lo;
-	u32 total_broadcast_packets_received_hi;
-	u32 total_broadcast_packets_received_lo;
-	u32 total_unicast_packets_transmitted_hi;
-	u32 total_unicast_packets_transmitted_lo;
-	u32 total_multicast_packets_transmitted_hi;
-	u32 total_multicast_packets_transmitted_lo;
-	u32 total_broadcast_packets_transmitted_hi;
-	u32 total_broadcast_packets_transmitted_lo;
-	u32 valid_bytes_received_hi;
-	u32 valid_bytes_received_lo;
-
-	u32 error_bytes_received_hi;
-	u32 error_bytes_received_lo;
-	u32 etherstatsoverrsizepkts_hi;
-	u32 etherstatsoverrsizepkts_lo;
-	u32 no_buff_discard_hi;
-	u32 no_buff_discard_lo;
-
-	u32 driver_xoff;
-	u32 rx_err_discard_pkt;
-	u32 rx_skb_alloc_failed;
-	u32 hw_csum_err;
-};
-
-#define BNX2X_NUM_Q_STATS		11
-#define Q_STATS_OFFSET32(stat_name) \
-			(offsetof(struct bnx2x_eth_q_stats, stat_name) / 4)
-
-struct bnx2x_fastpath {
-
-	struct napi_struct	napi;
-	struct host_status_block *status_blk;
-	dma_addr_t		status_blk_mapping;
-
-	struct sw_tx_bd		*tx_buf_ring;
-
-	union eth_tx_bd_types	*tx_desc_ring;
-	dma_addr_t		tx_desc_mapping;
-
-	struct sw_rx_bd		*rx_buf_ring;	/* BDs mappings ring */
-	struct sw_rx_page	*rx_page_ring;	/* SGE pages mappings ring */
-
-	struct eth_rx_bd	*rx_desc_ring;
-	dma_addr_t		rx_desc_mapping;
-
-	union eth_rx_cqe	*rx_comp_ring;
-	dma_addr_t		rx_comp_mapping;
-
-	/* SGE ring */
-	struct eth_rx_sge	*rx_sge_ring;
-	dma_addr_t		rx_sge_mapping;
-
-	u64			sge_mask[RX_SGE_MASK_LEN];
-
-	int			state;
-#define BNX2X_FP_STATE_CLOSED		0
-#define BNX2X_FP_STATE_IRQ		0x80000
-#define BNX2X_FP_STATE_OPENING		0x90000
-#define BNX2X_FP_STATE_OPEN		0xa0000
-#define BNX2X_FP_STATE_HALTING		0xb0000
-#define BNX2X_FP_STATE_HALTED		0xc0000
-
-	u8			index;	/* number in fp array */
-	u8			cl_id;	/* eth client id */
-	u8			sb_id;	/* status block number in HW */
-
-	union db_prod		tx_db;
-
-	u16			tx_pkt_prod;
-	u16			tx_pkt_cons;
-	u16			tx_bd_prod;
-	u16			tx_bd_cons;
-	__le16			*tx_cons_sb;
-
-	__le16			fp_c_idx;
-	__le16			fp_u_idx;
-
-	u16			rx_bd_prod;
-	u16			rx_bd_cons;
-	u16			rx_comp_prod;
-	u16			rx_comp_cons;
-	u16			rx_sge_prod;
-	/* The last maximal completed SGE */
-	u16			last_max_sge;
-	__le16			*rx_cons_sb;
-	__le16			*rx_bd_cons_sb;
-
-
-	unsigned long		tx_pkt,
-				rx_pkt,
-				rx_calls;
-
-	/* TPA related */
-	struct sw_rx_bd		tpa_pool[ETH_MAX_AGGREGATION_QUEUES_E1H];
-	u8			tpa_state[ETH_MAX_AGGREGATION_QUEUES_E1H];
-#define BNX2X_TPA_START			1
-#define BNX2X_TPA_STOP			2
-	u8			disable_tpa;
-#ifdef BNX2X_STOP_ON_ERROR
-	u64			tpa_queue_used;
-#endif
-
-	struct tstorm_per_client_stats old_tclient;
-	struct ustorm_per_client_stats old_uclient;
-	struct xstorm_per_client_stats old_xclient;
-	struct bnx2x_eth_q_stats eth_q_stats;
-
-	/* The size is calculated using the following:
-	     sizeof name field from netdev structure +
-	     4 ('-Xx-' string) +
-	     4 (for the digits and to make it DWORD aligned) */
-#define FP_NAME_SIZE		(sizeof(((struct net_device *)0)->name) + 8)
-	char			name[FP_NAME_SIZE];
-	struct bnx2x		*bp; /* parent */
-};
-
-#define bnx2x_fp(bp, nr, var)		(bp->fp[nr].var)
-
-
-/* MC hsi */
-#define MAX_FETCH_BD			13	/* HW max BDs per packet */
-#define RX_COPY_THRESH			92
-
-#define NUM_TX_RINGS			16
-#define TX_DESC_CNT		(BCM_PAGE_SIZE / sizeof(union eth_tx_bd_types))
-#define MAX_TX_DESC_CNT			(TX_DESC_CNT - 1)
-#define NUM_TX_BD			(TX_DESC_CNT * NUM_TX_RINGS)
-#define MAX_TX_BD			(NUM_TX_BD - 1)
-#define MAX_TX_AVAIL			(MAX_TX_DESC_CNT * NUM_TX_RINGS - 2)
-#define NEXT_TX_IDX(x)		((((x) & MAX_TX_DESC_CNT) == \
-				  (MAX_TX_DESC_CNT - 1)) ? (x) + 2 : (x) + 1)
-#define TX_BD(x)			((x) & MAX_TX_BD)
-#define TX_BD_POFF(x)			((x) & MAX_TX_DESC_CNT)
-
-/* The RX BD ring is special, each bd is 8 bytes but the last one is 16 */
-#define NUM_RX_RINGS			8
-#define RX_DESC_CNT		(BCM_PAGE_SIZE / sizeof(struct eth_rx_bd))
-#define MAX_RX_DESC_CNT			(RX_DESC_CNT - 2)
-#define RX_DESC_MASK			(RX_DESC_CNT - 1)
-#define NUM_RX_BD			(RX_DESC_CNT * NUM_RX_RINGS)
-#define MAX_RX_BD			(NUM_RX_BD - 1)
-#define MAX_RX_AVAIL			(MAX_RX_DESC_CNT * NUM_RX_RINGS - 2)
-#define NEXT_RX_IDX(x)		((((x) & RX_DESC_MASK) == \
-				  (MAX_RX_DESC_CNT - 1)) ? (x) + 3 : (x) + 1)
-#define RX_BD(x)			((x) & MAX_RX_BD)
-
-/* As long as CQE is 4 times bigger than BD entry we have to allocate
-   4 times more pages for CQ ring in order to keep it balanced with
-   BD ring */
-#define NUM_RCQ_RINGS			(NUM_RX_RINGS * 4)
-#define RCQ_DESC_CNT		(BCM_PAGE_SIZE / sizeof(union eth_rx_cqe))
-#define MAX_RCQ_DESC_CNT		(RCQ_DESC_CNT - 1)
-#define NUM_RCQ_BD			(RCQ_DESC_CNT * NUM_RCQ_RINGS)
-#define MAX_RCQ_BD			(NUM_RCQ_BD - 1)
-#define MAX_RCQ_AVAIL			(MAX_RCQ_DESC_CNT * NUM_RCQ_RINGS - 2)
-#define NEXT_RCQ_IDX(x)		((((x) & MAX_RCQ_DESC_CNT) == \
-				  (MAX_RCQ_DESC_CNT - 1)) ? (x) + 2 : (x) + 1)
-#define RCQ_BD(x)			((x) & MAX_RCQ_BD)
-
-
-/* This is needed for determining of last_max */
-#define SUB_S16(a, b)			(s16)((s16)(a) - (s16)(b))
-
-#define __SGE_MASK_SET_BIT(el, bit) \
-	do { \
-		el = ((el) | ((u64)0x1 << (bit))); \
-	} while (0)
-
-#define __SGE_MASK_CLEAR_BIT(el, bit) \
-	do { \
-		el = ((el) & (~((u64)0x1 << (bit)))); \
-	} while (0)
-
-#define SGE_MASK_SET_BIT(fp, idx) \
-	__SGE_MASK_SET_BIT(fp->sge_mask[(idx) >> RX_SGE_MASK_ELEM_SHIFT], \
-			   ((idx) & RX_SGE_MASK_ELEM_MASK))
-
-#define SGE_MASK_CLEAR_BIT(fp, idx) \
-	__SGE_MASK_CLEAR_BIT(fp->sge_mask[(idx) >> RX_SGE_MASK_ELEM_SHIFT], \
-			     ((idx) & RX_SGE_MASK_ELEM_MASK))
-
-
-/* used on a CID received from the HW */
-#define SW_CID(x)			(le32_to_cpu(x) & \
-					 (COMMON_RAMROD_ETH_RX_CQE_CID >> 7))
-#define CQE_CMD(x)			(le32_to_cpu(x) >> \
-					COMMON_RAMROD_ETH_RX_CQE_CMD_ID_SHIFT)
-
-#define BD_UNMAP_ADDR(bd)		HILO_U64(le32_to_cpu((bd)->addr_hi), \
-						 le32_to_cpu((bd)->addr_lo))
-#define BD_UNMAP_LEN(bd)		(le16_to_cpu((bd)->nbytes))
-
-
-#define DPM_TRIGER_TYPE			0x40
-#define DOORBELL(bp, cid, val) \
-	do { \
-		writel((u32)(val), bp->doorbells + (BCM_PAGE_SIZE * (cid)) + \
-		       DPM_TRIGER_TYPE); \
-	} while (0)
-
-
-/* TX CSUM helpers */
-#define SKB_CS_OFF(skb)		(offsetof(struct tcphdr, check) - \
-				 skb->csum_offset)
-#define SKB_CS(skb)		(*(u16 *)(skb_transport_header(skb) + \
-					  skb->csum_offset))
-
-#define pbd_tcp_flags(skb)	(ntohl(tcp_flag_word(tcp_hdr(skb)))>>16 & 0xff)
-
-#define XMIT_PLAIN			0
-#define XMIT_CSUM_V4			0x1
-#define XMIT_CSUM_V6			0x2
-#define XMIT_CSUM_TCP			0x4
-#define XMIT_GSO_V4			0x8
-#define XMIT_GSO_V6			0x10
-
-#define XMIT_CSUM			(XMIT_CSUM_V4 | XMIT_CSUM_V6)
-#define XMIT_GSO			(XMIT_GSO_V4 | XMIT_GSO_V6)
-
-
-/* stuff added to make the code fit 80Col */
-
-#define CQE_TYPE(cqe_fp_flags)	((cqe_fp_flags) & ETH_FAST_PATH_RX_CQE_TYPE)
-
-#define TPA_TYPE_START			ETH_FAST_PATH_RX_CQE_START_FLG
-#define TPA_TYPE_END			ETH_FAST_PATH_RX_CQE_END_FLG
-#define TPA_TYPE(cqe_fp_flags)		((cqe_fp_flags) & \
-					 (TPA_TYPE_START | TPA_TYPE_END))
-
-#define ETH_RX_ERROR_FALGS		ETH_FAST_PATH_RX_CQE_PHY_DECODE_ERR_FLG
-
-#define BNX2X_IP_CSUM_ERR(cqe) \
-			(!((cqe)->fast_path_cqe.status_flags & \
-			   ETH_FAST_PATH_RX_CQE_IP_XSUM_NO_VALIDATION_FLG) && \
-			 ((cqe)->fast_path_cqe.type_error_flags & \
-			  ETH_FAST_PATH_RX_CQE_IP_BAD_XSUM_FLG))
-
-#define BNX2X_L4_CSUM_ERR(cqe) \
-			(!((cqe)->fast_path_cqe.status_flags & \
-			   ETH_FAST_PATH_RX_CQE_L4_XSUM_NO_VALIDATION_FLG) && \
-			 ((cqe)->fast_path_cqe.type_error_flags & \
-			  ETH_FAST_PATH_RX_CQE_L4_BAD_XSUM_FLG))
-
-#define BNX2X_RX_CSUM_OK(cqe) \
-			(!(BNX2X_L4_CSUM_ERR(cqe) || BNX2X_IP_CSUM_ERR(cqe)))
-
-#define BNX2X_PRS_FLAG_OVERETH_IPV4(flags) \
-				(((le16_to_cpu(flags) & \
-				   PARSING_FLAGS_OVER_ETHERNET_PROTOCOL) >> \
-				  PARSING_FLAGS_OVER_ETHERNET_PROTOCOL_SHIFT) \
-				 == PRS_FLAG_OVERETH_IPV4)
-#define BNX2X_RX_SUM_FIX(cqe) \
-	BNX2X_PRS_FLAG_OVERETH_IPV4(cqe->fast_path_cqe.pars_flags.flags)
-
-
-#define FP_USB_FUNC_OFF			(2 + 2*HC_USTORM_SB_NUM_INDICES)
-#define FP_CSB_FUNC_OFF			(2 + 2*HC_CSTORM_SB_NUM_INDICES)
-
-#define U_SB_ETH_RX_CQ_INDEX		HC_INDEX_U_ETH_RX_CQ_CONS
-#define U_SB_ETH_RX_BD_INDEX		HC_INDEX_U_ETH_RX_BD_CONS
-#define C_SB_ETH_TX_CQ_INDEX		HC_INDEX_C_ETH_TX_CQ_CONS
-
-#define BNX2X_RX_SB_INDEX \
-	(&fp->status_blk->u_status_block.index_values[U_SB_ETH_RX_CQ_INDEX])
-
-#define BNX2X_RX_SB_BD_INDEX \
-	(&fp->status_blk->u_status_block.index_values[U_SB_ETH_RX_BD_INDEX])
-
-#define BNX2X_RX_SB_INDEX_NUM \
-		(((U_SB_ETH_RX_CQ_INDEX << \
-		   USTORM_ETH_ST_CONTEXT_CONFIG_CQE_SB_INDEX_NUMBER_SHIFT) & \
-		  USTORM_ETH_ST_CONTEXT_CONFIG_CQE_SB_INDEX_NUMBER) | \
-		 ((U_SB_ETH_RX_BD_INDEX << \
-		   USTORM_ETH_ST_CONTEXT_CONFIG_BD_SB_INDEX_NUMBER_SHIFT) & \
-		  USTORM_ETH_ST_CONTEXT_CONFIG_BD_SB_INDEX_NUMBER))
-
-#define BNX2X_TX_SB_INDEX \
-	(&fp->status_blk->c_status_block.index_values[C_SB_ETH_TX_CQ_INDEX])
-
-
-/* end of fast path */
-
-/* common */
-
-struct bnx2x_common {
-
-	u32			chip_id;
-/* chip num:16-31, rev:12-15, metal:4-11, bond_id:0-3 */
-#define CHIP_ID(bp)			(bp->common.chip_id & 0xfffffff0)
-
-#define CHIP_NUM(bp)			(bp->common.chip_id >> 16)
-#define CHIP_NUM_57710			0x164e
-#define CHIP_NUM_57711			0x164f
-#define CHIP_NUM_57711E			0x1650
-#define CHIP_IS_E1(bp)			(CHIP_NUM(bp) == CHIP_NUM_57710)
-#define CHIP_IS_57711(bp)		(CHIP_NUM(bp) == CHIP_NUM_57711)
-#define CHIP_IS_57711E(bp)		(CHIP_NUM(bp) == CHIP_NUM_57711E)
-#define CHIP_IS_E1H(bp)			(CHIP_IS_57711(bp) || \
-					 CHIP_IS_57711E(bp))
-#define IS_E1H_OFFSET			CHIP_IS_E1H(bp)
-
-#define CHIP_REV(bp)			(bp->common.chip_id & 0x0000f000)
-#define CHIP_REV_Ax			0x00000000
-/* assume maximum 5 revisions */
-#define CHIP_REV_IS_SLOW(bp)		(CHIP_REV(bp) > 0x00005000)
-/* Emul versions are A=>0xe, B=>0xc, C=>0xa, D=>8, E=>6 */
-#define CHIP_REV_IS_EMUL(bp)		((CHIP_REV_IS_SLOW(bp)) && \
-					 !(CHIP_REV(bp) & 0x00001000))
-/* FPGA versions are A=>0xf, B=>0xd, C=>0xb, D=>9, E=>7 */
-#define CHIP_REV_IS_FPGA(bp)		((CHIP_REV_IS_SLOW(bp)) && \
-					 (CHIP_REV(bp) & 0x00001000))
-
-#define CHIP_TIME(bp)			((CHIP_REV_IS_EMUL(bp)) ? 2000 : \
-					((CHIP_REV_IS_FPGA(bp)) ? 200 : 1))
-
-#define CHIP_METAL(bp)			(bp->common.chip_id & 0x00000ff0)
-#define CHIP_BOND_ID(bp)		(bp->common.chip_id & 0x0000000f)
-
-	int			flash_size;
-#define NVRAM_1MB_SIZE			0x20000	/* 1M bit in bytes */
-#define NVRAM_TIMEOUT_COUNT		30000
-#define NVRAM_PAGE_SIZE			256
-
-	u32			shmem_base;
-	u32			shmem2_base;
-
-	u32			hw_config;
-
-	u32			bc_ver;
-};
-
-
-/* end of common */
-
-/* port */
-
-struct nig_stats {
-	u32 brb_discard;
-	u32 brb_packet;
-	u32 brb_truncate;
-	u32 flow_ctrl_discard;
-	u32 flow_ctrl_octets;
-	u32 flow_ctrl_packet;
-	u32 mng_discard;
-	u32 mng_octet_inp;
-	u32 mng_octet_out;
-	u32 mng_packet_inp;
-	u32 mng_packet_out;
-	u32 pbf_octets;
-	u32 pbf_packet;
-	u32 safc_inp;
-	u32 egress_mac_pkt0_lo;
-	u32 egress_mac_pkt0_hi;
-	u32 egress_mac_pkt1_lo;
-	u32 egress_mac_pkt1_hi;
-};
-
-struct bnx2x_port {
-	u32			pmf;
-
-	u32			link_config;
-
-	u32			supported;
-/* link settings - missing defines */
-#define SUPPORTED_2500baseX_Full	(1 << 15)
-
-	u32			advertising;
-/* link settings - missing defines */
-#define ADVERTISED_2500baseX_Full	(1 << 15)
-
-	u32			phy_addr;
-
-	/* used to synchronize phy accesses */
-	struct mutex		phy_mutex;
-	int			need_hw_lock;
-
-	u32			port_stx;
-
-	struct nig_stats	old_nig_stats;
-};
-
-/* end of port */
-
-
-enum bnx2x_stats_event {
-	STATS_EVENT_PMF = 0,
-	STATS_EVENT_LINK_UP,
-	STATS_EVENT_UPDATE,
-	STATS_EVENT_STOP,
-	STATS_EVENT_MAX
-};
-
-enum bnx2x_stats_state {
-	STATS_STATE_DISABLED = 0,
-	STATS_STATE_ENABLED,
-	STATS_STATE_MAX
-};
-
-struct bnx2x_eth_stats {
-	u32 total_bytes_received_hi;
-	u32 total_bytes_received_lo;
-	u32 total_bytes_transmitted_hi;
-	u32 total_bytes_transmitted_lo;
-	u32 total_unicast_packets_received_hi;
-	u32 total_unicast_packets_received_lo;
-	u32 total_multicast_packets_received_hi;
-	u32 total_multicast_packets_received_lo;
-	u32 total_broadcast_packets_received_hi;
-	u32 total_broadcast_packets_received_lo;
-	u32 total_unicast_packets_transmitted_hi;
-	u32 total_unicast_packets_transmitted_lo;
-	u32 total_multicast_packets_transmitted_hi;
-	u32 total_multicast_packets_transmitted_lo;
-	u32 total_broadcast_packets_transmitted_hi;
-	u32 total_broadcast_packets_transmitted_lo;
-	u32 valid_bytes_received_hi;
-	u32 valid_bytes_received_lo;
-
-	u32 error_bytes_received_hi;
-	u32 error_bytes_received_lo;
-	u32 etherstatsoverrsizepkts_hi;
-	u32 etherstatsoverrsizepkts_lo;
-	u32 no_buff_discard_hi;
-	u32 no_buff_discard_lo;
-
-	u32 rx_stat_ifhcinbadoctets_hi;
-	u32 rx_stat_ifhcinbadoctets_lo;
-	u32 tx_stat_ifhcoutbadoctets_hi;
-	u32 tx_stat_ifhcoutbadoctets_lo;
-	u32 rx_stat_dot3statsfcserrors_hi;
-	u32 rx_stat_dot3statsfcserrors_lo;
-	u32 rx_stat_dot3statsalignmenterrors_hi;
-	u32 rx_stat_dot3statsalignmenterrors_lo;
-	u32 rx_stat_dot3statscarriersenseerrors_hi;
-	u32 rx_stat_dot3statscarriersenseerrors_lo;
-	u32 rx_stat_falsecarriererrors_hi;
-	u32 rx_stat_falsecarriererrors_lo;
-	u32 rx_stat_etherstatsundersizepkts_hi;
-	u32 rx_stat_etherstatsundersizepkts_lo;
-	u32 rx_stat_dot3statsframestoolong_hi;
-	u32 rx_stat_dot3statsframestoolong_lo;
-	u32 rx_stat_etherstatsfragments_hi;
-	u32 rx_stat_etherstatsfragments_lo;
-	u32 rx_stat_etherstatsjabbers_hi;
-	u32 rx_stat_etherstatsjabbers_lo;
-	u32 rx_stat_maccontrolframesreceived_hi;
-	u32 rx_stat_maccontrolframesreceived_lo;
-	u32 rx_stat_bmac_xpf_hi;
-	u32 rx_stat_bmac_xpf_lo;
-	u32 rx_stat_bmac_xcf_hi;
-	u32 rx_stat_bmac_xcf_lo;
-	u32 rx_stat_xoffstateentered_hi;
-	u32 rx_stat_xoffstateentered_lo;
-	u32 rx_stat_xonpauseframesreceived_hi;
-	u32 rx_stat_xonpauseframesreceived_lo;
-	u32 rx_stat_xoffpauseframesreceived_hi;
-	u32 rx_stat_xoffpauseframesreceived_lo;
-	u32 tx_stat_outxonsent_hi;
-	u32 tx_stat_outxonsent_lo;
-	u32 tx_stat_outxoffsent_hi;
-	u32 tx_stat_outxoffsent_lo;
-	u32 tx_stat_flowcontroldone_hi;
-	u32 tx_stat_flowcontroldone_lo;
-	u32 tx_stat_etherstatscollisions_hi;
-	u32 tx_stat_etherstatscollisions_lo;
-	u32 tx_stat_dot3statssinglecollisionframes_hi;
-	u32 tx_stat_dot3statssinglecollisionframes_lo;
-	u32 tx_stat_dot3statsmultiplecollisionframes_hi;
-	u32 tx_stat_dot3statsmultiplecollisionframes_lo;
-	u32 tx_stat_dot3statsdeferredtransmissions_hi;
-	u32 tx_stat_dot3statsdeferredtransmissions_lo;
-	u32 tx_stat_dot3statsexcessivecollisions_hi;
-	u32 tx_stat_dot3statsexcessivecollisions_lo;
-	u32 tx_stat_dot3statslatecollisions_hi;
-	u32 tx_stat_dot3statslatecollisions_lo;
-	u32 tx_stat_etherstatspkts64octets_hi;
-	u32 tx_stat_etherstatspkts64octets_lo;
-	u32 tx_stat_etherstatspkts65octetsto127octets_hi;
-	u32 tx_stat_etherstatspkts65octetsto127octets_lo;
-	u32 tx_stat_etherstatspkts128octetsto255octets_hi;
-	u32 tx_stat_etherstatspkts128octetsto255octets_lo;
-	u32 tx_stat_etherstatspkts256octetsto511octets_hi;
-	u32 tx_stat_etherstatspkts256octetsto511octets_lo;
-	u32 tx_stat_etherstatspkts512octetsto1023octets_hi;
-	u32 tx_stat_etherstatspkts512octetsto1023octets_lo;
-	u32 tx_stat_etherstatspkts1024octetsto1522octets_hi;
-	u32 tx_stat_etherstatspkts1024octetsto1522octets_lo;
-	u32 tx_stat_etherstatspktsover1522octets_hi;
-	u32 tx_stat_etherstatspktsover1522octets_lo;
-	u32 tx_stat_bmac_2047_hi;
-	u32 tx_stat_bmac_2047_lo;
-	u32 tx_stat_bmac_4095_hi;
-	u32 tx_stat_bmac_4095_lo;
-	u32 tx_stat_bmac_9216_hi;
-	u32 tx_stat_bmac_9216_lo;
-	u32 tx_stat_bmac_16383_hi;
-	u32 tx_stat_bmac_16383_lo;
-	u32 tx_stat_dot3statsinternalmactransmiterrors_hi;
-	u32 tx_stat_dot3statsinternalmactransmiterrors_lo;
-	u32 tx_stat_bmac_ufl_hi;
-	u32 tx_stat_bmac_ufl_lo;
-
-	u32 pause_frames_received_hi;
-	u32 pause_frames_received_lo;
-	u32 pause_frames_sent_hi;
-	u32 pause_frames_sent_lo;
-
-	u32 etherstatspkts1024octetsto1522octets_hi;
-	u32 etherstatspkts1024octetsto1522octets_lo;
-	u32 etherstatspktsover1522octets_hi;
-	u32 etherstatspktsover1522octets_lo;
-
-	u32 brb_drop_hi;
-	u32 brb_drop_lo;
-	u32 brb_truncate_hi;
-	u32 brb_truncate_lo;
-
-	u32 mac_filter_discard;
-	u32 xxoverflow_discard;
-	u32 brb_truncate_discard;
-	u32 mac_discard;
-
-	u32 driver_xoff;
-	u32 rx_err_discard_pkt;
-	u32 rx_skb_alloc_failed;
-	u32 hw_csum_err;
-
-	u32 nig_timer_max;
-};
-
-#define BNX2X_NUM_STATS			41
-#define STATS_OFFSET32(stat_name) \
-			(offsetof(struct bnx2x_eth_stats, stat_name) / 4)
-
-
-#ifdef BCM_CNIC
-#define MAX_CONTEXT			15
-#else
-#define MAX_CONTEXT			16
-#endif
-
-union cdu_context {
-	struct eth_context eth;
-	char pad[1024];
-};
-
-#define MAX_DMAE_C			8
-
-/* DMA memory not used in fastpath */
-struct bnx2x_slowpath {
-	union cdu_context		context[MAX_CONTEXT];
-	struct eth_stats_query		fw_stats;
-	struct mac_configuration_cmd	mac_config;
-	struct mac_configuration_cmd	mcast_config;
-
-	/* used by dmae command executer */
-	struct dmae_command		dmae[MAX_DMAE_C];
-
-	u32				stats_comp;
-	union mac_stats			mac_stats;
-	struct nig_stats		nig_stats;
-	struct host_port_stats		port_stats;
-	struct host_func_stats		func_stats;
-	struct host_func_stats		func_stats_base;
-
-	u32				wb_comp;
-	u32				wb_data[4];
-};
-
-#define bnx2x_sp(bp, var)		(&bp->slowpath->var)
-#define bnx2x_sp_mapping(bp, var) \
-		(bp->slowpath_mapping + offsetof(struct bnx2x_slowpath, var))
-
-
-/* attn group wiring */
-#define MAX_DYNAMIC_ATTN_GRPS		8
-
-struct attn_route {
-	u32	sig[4];
-};
-
-struct bnx2x {
-	/* Fields used in the tx and intr/napi performance paths
-	 * are grouped together in the beginning of the structure
-	 */
-	struct bnx2x_fastpath	fp[MAX_CONTEXT];
-	void __iomem		*regview;
-	void __iomem		*doorbells;
-#ifdef BCM_CNIC
-#define BNX2X_DB_SIZE		(18*BCM_PAGE_SIZE)
-#else
-#define BNX2X_DB_SIZE		(16*BCM_PAGE_SIZE)
-#endif
-
-	struct net_device	*dev;
-	struct pci_dev		*pdev;
-
-	atomic_t		intr_sem;
-#ifdef BCM_CNIC
-	struct msix_entry	msix_table[MAX_CONTEXT+2];
-#else
-	struct msix_entry	msix_table[MAX_CONTEXT+1];
-#endif
-#define INT_MODE_INTx			1
-#define INT_MODE_MSI			2
-#define INT_MODE_MSIX			3
-
-	int			tx_ring_size;
-
-#ifdef BCM_VLAN
-	struct vlan_group	*vlgrp;
-#endif
-
-	u32			rx_csum;
-	u32			rx_buf_size;
-#define ETH_OVREHEAD			(ETH_HLEN + 8)	/* 8 for CRC + VLAN */
-#define ETH_MIN_PACKET_SIZE		60
-#define ETH_MAX_PACKET_SIZE		1500
-#define ETH_MAX_JUMBO_PACKET_SIZE	9600
-
-	/* Max supported alignment is 256 (8 shift) */
-#define BNX2X_RX_ALIGN_SHIFT		((L1_CACHE_SHIFT < 8) ? \
-					 L1_CACHE_SHIFT : 8)
-#define BNX2X_RX_ALIGN			(1 << BNX2X_RX_ALIGN_SHIFT)
-
-	struct host_def_status_block *def_status_blk;
-#define DEF_SB_ID			16
-	__le16			def_c_idx;
-	__le16			def_u_idx;
-	__le16			def_x_idx;
-	__le16			def_t_idx;
-	__le16			def_att_idx;
-	u32			attn_state;
-	struct attn_route	attn_group[MAX_DYNAMIC_ATTN_GRPS];
-
-	/* slow path ring */
-	struct eth_spe		*spq;
-	dma_addr_t		spq_mapping;
-	u16			spq_prod_idx;
-	struct eth_spe		*spq_prod_bd;
-	struct eth_spe		*spq_last_bd;
-	__le16			*dsb_sp_prod;
-	u16			spq_left; /* serialize spq */
-	/* used to synchronize spq accesses */
-	spinlock_t		spq_lock;
-
-	/* Flags for marking that there is a STAT_QUERY or
-	   SET_MAC ramrod pending */
-	int			stats_pending;
-	int			set_mac_pending;
-
-	/* End of fields used in the performance code paths */
-
-	int			panic;
-	int			msg_enable;
-
-	u32			flags;
-#define PCIX_FLAG			1
-#define PCI_32BIT_FLAG			2
-#define ONE_PORT_FLAG			4
-#define NO_WOL_FLAG			8
-#define USING_DAC_FLAG			0x10
-#define USING_MSIX_FLAG			0x20
-#define USING_MSI_FLAG			0x40
-#define TPA_ENABLE_FLAG			0x80
-#define NO_MCP_FLAG			0x100
-#define BP_NOMCP(bp)			(bp->flags & NO_MCP_FLAG)
-#define HW_VLAN_TX_FLAG			0x400
-#define HW_VLAN_RX_FLAG			0x800
-#define MF_FUNC_DIS			0x1000
-
-	int			func;
-#define BP_PORT(bp)			(bp->func % PORT_MAX)
-#define BP_FUNC(bp)			(bp->func)
-#define BP_E1HVN(bp)			(bp->func >> 1)
-#define BP_L_ID(bp)			(BP_E1HVN(bp) << 2)
-
-#ifdef BCM_CNIC
-#define BCM_CNIC_CID_START		16
-#define BCM_ISCSI_ETH_CL_ID		17
-#endif
-
-	int			pm_cap;
-	int			pcie_cap;
-	int			mrrs;
-
-	struct delayed_work	sp_task;
-	struct work_struct	reset_task;
-
-	struct timer_list	timer;
-	int			current_interval;
-
-	u16			fw_seq;
-	u16			fw_drv_pulse_wr_seq;
-	u32			func_stx;
-
-	struct link_params	link_params;
-	struct link_vars	link_vars;
-	struct mdio_if_info	mdio;
-
-	struct bnx2x_common	common;
-	struct bnx2x_port	port;
-
-	struct cmng_struct_per_port cmng;
-	u32			vn_weight_sum;
-
-	u32			mf_config;
-	u16			e1hov;
-	u8			e1hmf;
-#define IS_E1HMF(bp)			(bp->e1hmf != 0)
-
-	u8			wol;
-
-	int			rx_ring_size;
-
-	u16			tx_quick_cons_trip_int;
-	u16			tx_quick_cons_trip;
-	u16			tx_ticks_int;
-	u16			tx_ticks;
-
-	u16			rx_quick_cons_trip_int;
-	u16			rx_quick_cons_trip;
-	u16			rx_ticks_int;
-	u16			rx_ticks;
-
-	u32			lin_cnt;
-
-	int			state;
-#define BNX2X_STATE_CLOSED		0
-#define BNX2X_STATE_OPENING_WAIT4_LOAD	0x1000
-#define BNX2X_STATE_OPENING_WAIT4_PORT	0x2000
-#define BNX2X_STATE_OPEN		0x3000
-#define BNX2X_STATE_CLOSING_WAIT4_HALT	0x4000
-#define BNX2X_STATE_CLOSING_WAIT4_DELETE 0x5000
-#define BNX2X_STATE_CLOSING_WAIT4_UNLOAD 0x6000
-#define BNX2X_STATE_DIAG		0xe000
-#define BNX2X_STATE_ERROR		0xf000
-
-	int			multi_mode;
-	int			num_queues;
-
-	u32			rx_mode;
-#define BNX2X_RX_MODE_NONE		0
-#define BNX2X_RX_MODE_NORMAL		1
-#define BNX2X_RX_MODE_ALLMULTI		2
-#define BNX2X_RX_MODE_PROMISC		3
-#define BNX2X_MAX_MULTICAST		64
-#define BNX2X_MAX_EMUL_MULTI		16
-
-	u32 			rx_mode_cl_mask;
-
-	dma_addr_t		def_status_blk_mapping;
-
-	struct bnx2x_slowpath	*slowpath;
-	dma_addr_t		slowpath_mapping;
-
-	int			dropless_fc;
-
-#ifdef BCM_CNIC
-	u32			cnic_flags;
-#define BNX2X_CNIC_FLAG_MAC_SET		1
-
-	void			*t1;
-	dma_addr_t		t1_mapping;
-	void			*t2;
-	dma_addr_t		t2_mapping;
-	void			*timers;
-	dma_addr_t		timers_mapping;
-	void			*qm;
-	dma_addr_t		qm_mapping;
-	struct cnic_ops		*cnic_ops;
-	void			*cnic_data;
-	u32			cnic_tag;
-	struct cnic_eth_dev	cnic_eth_dev;
-	struct host_status_block *cnic_sb;
-	dma_addr_t		cnic_sb_mapping;
-#define CNIC_SB_ID(bp)			BP_L_ID(bp)
-	struct eth_spe		*cnic_kwq;
-	struct eth_spe		*cnic_kwq_prod;
-	struct eth_spe		*cnic_kwq_cons;
-	struct eth_spe		*cnic_kwq_last;
-	u16			cnic_kwq_pending;
-	u16			cnic_spq_pending;
-	struct mutex		cnic_mutex;
-	u8			iscsi_mac[6];
-#endif
-
-	int			dmae_ready;
-	/* used to synchronize dmae accesses */
-	struct mutex		dmae_mutex;
-
-	/* used to protect the FW mail box */
-	struct mutex		fw_mb_mutex;
-
-	/* used to synchronize stats collecting */
-	int			stats_state;
-	/* used by dmae command loader */
-	struct dmae_command	stats_dmae;
-	int			executer_idx;
-
-	u16			stats_counter;
-	struct bnx2x_eth_stats	eth_stats;
-
-	struct z_stream_s	*strm;
-	void			*gunzip_buf;
-	dma_addr_t		gunzip_mapping;
-	int			gunzip_outlen;
-#define FW_BUF_SIZE			0x8000
-#define GUNZIP_BUF(bp)			(bp->gunzip_buf)
-#define GUNZIP_PHYS(bp)			(bp->gunzip_mapping)
-#define GUNZIP_OUTLEN(bp)		(bp->gunzip_outlen)
-
-	struct raw_op		*init_ops;
-	/* Init blocks offsets inside init_ops */
-	u16			*init_ops_offsets;
-	/* Data blob - has 32 bit granularity */
-	u32			*init_data;
-	/* Zipped PRAM blobs - raw data */
-	const u8		*tsem_int_table_data;
-	const u8		*tsem_pram_data;
-	const u8		*usem_int_table_data;
-	const u8		*usem_pram_data;
-	const u8		*xsem_int_table_data;
-	const u8		*xsem_pram_data;
-	const u8		*csem_int_table_data;
-	const u8		*csem_pram_data;
-#define INIT_OPS(bp)			(bp->init_ops)
-#define INIT_OPS_OFFSETS(bp)		(bp->init_ops_offsets)
-#define INIT_DATA(bp)			(bp->init_data)
-#define INIT_TSEM_INT_TABLE_DATA(bp)	(bp->tsem_int_table_data)
-#define INIT_TSEM_PRAM_DATA(bp)		(bp->tsem_pram_data)
-#define INIT_USEM_INT_TABLE_DATA(bp)	(bp->usem_int_table_data)
-#define INIT_USEM_PRAM_DATA(bp)		(bp->usem_pram_data)
-#define INIT_XSEM_INT_TABLE_DATA(bp)	(bp->xsem_int_table_data)
-#define INIT_XSEM_PRAM_DATA(bp)		(bp->xsem_pram_data)
-#define INIT_CSEM_INT_TABLE_DATA(bp)	(bp->csem_int_table_data)
-#define INIT_CSEM_PRAM_DATA(bp)		(bp->csem_pram_data)
-
-	const struct firmware	*firmware;
-};
-
-
-#define BNX2X_MAX_QUEUES(bp)	(IS_E1HMF(bp) ? (MAX_CONTEXT/E1HVN_MAX) \
-					      : MAX_CONTEXT)
-#define BNX2X_NUM_QUEUES(bp)	(bp->num_queues)
-#define is_multi(bp)		(BNX2X_NUM_QUEUES(bp) > 1)
-
-#define for_each_queue(bp, var) \
-			for (var = 0; var < BNX2X_NUM_QUEUES(bp); var++)
-#define for_each_nondefault_queue(bp, var) \
-			for (var = 1; var < BNX2X_NUM_QUEUES(bp); var++)
-
-
-void bnx2x_read_dmae(struct bnx2x *bp, u32 src_addr, u32 len32);
-void bnx2x_write_dmae(struct bnx2x *bp, dma_addr_t dma_addr, u32 dst_addr,
-		      u32 len32);
-int bnx2x_get_gpio(struct bnx2x *bp, int gpio_num, u8 port);
-int bnx2x_set_gpio(struct bnx2x *bp, int gpio_num, u32 mode, u8 port);
-int bnx2x_set_gpio_int(struct bnx2x *bp, int gpio_num, u32 mode, u8 port);
-u32 bnx2x_fw_command(struct bnx2x *bp, u32 command);
-void bnx2x_reg_wr_ind(struct bnx2x *bp, u32 addr, u32 val);
-void bnx2x_write_dmae_phys_len(struct bnx2x *bp, dma_addr_t phys_addr,
-			       u32 addr, u32 len);
-
-static inline u32 reg_poll(struct bnx2x *bp, u32 reg, u32 expected, int ms,
-			   int wait)
-{
-	u32 val;
-
-	do {
-		val = REG_RD(bp, reg);
-		if (val == expected)
-			break;
-		ms -= wait;
-		msleep(wait);
-
-	} while (ms > 0);
-
-	return val;
-}
-
-
-/* load/unload mode */
-#define LOAD_NORMAL			0
-#define LOAD_OPEN			1
-#define LOAD_DIAG			2
-#define UNLOAD_NORMAL			0
-#define UNLOAD_CLOSE			1
-
-
-/* DMAE command defines */
-#define DMAE_CMD_SRC_PCI		0
-#define DMAE_CMD_SRC_GRC		DMAE_COMMAND_SRC
-
-#define DMAE_CMD_DST_PCI		(1 << DMAE_COMMAND_DST_SHIFT)
-#define DMAE_CMD_DST_GRC		(2 << DMAE_COMMAND_DST_SHIFT)
-
-#define DMAE_CMD_C_DST_PCI		0
-#define DMAE_CMD_C_DST_GRC		(1 << DMAE_COMMAND_C_DST_SHIFT)
-
-#define DMAE_CMD_C_ENABLE		DMAE_COMMAND_C_TYPE_ENABLE
-
-#define DMAE_CMD_ENDIANITY_NO_SWAP	(0 << DMAE_COMMAND_ENDIANITY_SHIFT)
-#define DMAE_CMD_ENDIANITY_B_SWAP	(1 << DMAE_COMMAND_ENDIANITY_SHIFT)
-#define DMAE_CMD_ENDIANITY_DW_SWAP	(2 << DMAE_COMMAND_ENDIANITY_SHIFT)
-#define DMAE_CMD_ENDIANITY_B_DW_SWAP	(3 << DMAE_COMMAND_ENDIANITY_SHIFT)
-
-#define DMAE_CMD_PORT_0			0
-#define DMAE_CMD_PORT_1			DMAE_COMMAND_PORT
-
-#define DMAE_CMD_SRC_RESET		DMAE_COMMAND_SRC_RESET
-#define DMAE_CMD_DST_RESET		DMAE_COMMAND_DST_RESET
-#define DMAE_CMD_E1HVN_SHIFT		DMAE_COMMAND_E1HVN_SHIFT
-
-#define DMAE_LEN32_RD_MAX		0x80
-#define DMAE_LEN32_WR_MAX		0x400
-
-#define DMAE_COMP_VAL			0xe0d0d0ae
-
-#define MAX_DMAE_C_PER_PORT		8
-#define INIT_DMAE_C(bp)			(BP_PORT(bp) * MAX_DMAE_C_PER_PORT + \
-					 BP_E1HVN(bp))
-#define PMF_DMAE_C(bp)			(BP_PORT(bp) * MAX_DMAE_C_PER_PORT + \
-					 E1HVN_MAX)
-
-
-/* PCIE link and speed */
-#define PCICFG_LINK_WIDTH		0x1f00000
-#define PCICFG_LINK_WIDTH_SHIFT		20
-#define PCICFG_LINK_SPEED		0xf0000
-#define PCICFG_LINK_SPEED_SHIFT		16
-
-
-#define BNX2X_NUM_TESTS			7
-
-#define BNX2X_PHY_LOOPBACK		0
-#define BNX2X_MAC_LOOPBACK		1
-#define BNX2X_PHY_LOOPBACK_FAILED	1
-#define BNX2X_MAC_LOOPBACK_FAILED	2
-#define BNX2X_LOOPBACK_FAILED		(BNX2X_MAC_LOOPBACK_FAILED | \
-					 BNX2X_PHY_LOOPBACK_FAILED)
-
-
-#define STROM_ASSERT_ARRAY_SIZE		50
-
-
-/* must be used on a CID before placing it on a HW ring */
-#define HW_CID(bp, x)			((BP_PORT(bp) << 23) | \
-					 (BP_E1HVN(bp) << 17) | (x))
-
-#define SP_DESC_CNT		(BCM_PAGE_SIZE / sizeof(struct eth_spe))
-#define MAX_SP_DESC_CNT			(SP_DESC_CNT - 1)
-
-
-#define BNX2X_BTR			1
-#define MAX_SPQ_PENDING			8
-
-
-/* CMNG constants
-   derived from lab experiments, and not from system spec calculations !!! */
-#define DEF_MIN_RATE			100
-/* resolution of the rate shaping timer - 100 usec */
-#define RS_PERIODIC_TIMEOUT_USEC	100
-/* resolution of fairness algorithm in usecs -
-   coefficient for calculating the actual t fair */
-#define T_FAIR_COEF			10000000
-/* number of bytes in single QM arbitration cycle -
-   coefficient for calculating the fairness timer */
-#define QM_ARB_BYTES			40000
-#define FAIR_MEM			2
-
-
-#define ATTN_NIG_FOR_FUNC		(1L << 8)
-#define ATTN_SW_TIMER_4_FUNC		(1L << 9)
-#define GPIO_2_FUNC			(1L << 10)
-#define GPIO_3_FUNC			(1L << 11)
-#define GPIO_4_FUNC			(1L << 12)
-#define ATTN_GENERAL_ATTN_1		(1L << 13)
-#define ATTN_GENERAL_ATTN_2		(1L << 14)
-#define ATTN_GENERAL_ATTN_3		(1L << 15)
-#define ATTN_GENERAL_ATTN_4		(1L << 13)
-#define ATTN_GENERAL_ATTN_5		(1L << 14)
-#define ATTN_GENERAL_ATTN_6		(1L << 15)
-
-#define ATTN_HARD_WIRED_MASK		0xff00
-#define ATTENTION_ID			4
-
-
-/* stuff added to make the code fit 80Col */
-
-#define BNX2X_PMF_LINK_ASSERT \
-	GENERAL_ATTEN_OFFSET(LINK_SYNC_ATTENTION_BIT_FUNC_0 + BP_FUNC(bp))
-
-#define BNX2X_MC_ASSERT_BITS \
-	(GENERAL_ATTEN_OFFSET(TSTORM_FATAL_ASSERT_ATTENTION_BIT) | \
-	 GENERAL_ATTEN_OFFSET(USTORM_FATAL_ASSERT_ATTENTION_BIT) | \
-	 GENERAL_ATTEN_OFFSET(CSTORM_FATAL_ASSERT_ATTENTION_BIT) | \
-	 GENERAL_ATTEN_OFFSET(XSTORM_FATAL_ASSERT_ATTENTION_BIT))
-
-#define BNX2X_MCP_ASSERT \
-	GENERAL_ATTEN_OFFSET(MCP_FATAL_ASSERT_ATTENTION_BIT)
-
-#define BNX2X_GRC_TIMEOUT	GENERAL_ATTEN_OFFSET(LATCHED_ATTN_TIMEOUT_GRC)
-#define BNX2X_GRC_RSV		(GENERAL_ATTEN_OFFSET(LATCHED_ATTN_RBCR) | \
-				 GENERAL_ATTEN_OFFSET(LATCHED_ATTN_RBCT) | \
-				 GENERAL_ATTEN_OFFSET(LATCHED_ATTN_RBCN) | \
-				 GENERAL_ATTEN_OFFSET(LATCHED_ATTN_RBCU) | \
-				 GENERAL_ATTEN_OFFSET(LATCHED_ATTN_RBCP) | \
-				 GENERAL_ATTEN_OFFSET(LATCHED_ATTN_RSVD_GRC))
-
-#define HW_INTERRUT_ASSERT_SET_0 \
-				(AEU_INPUTS_ATTN_BITS_TSDM_HW_INTERRUPT | \
-				 AEU_INPUTS_ATTN_BITS_TCM_HW_INTERRUPT | \
-				 AEU_INPUTS_ATTN_BITS_TSEMI_HW_INTERRUPT | \
-				 AEU_INPUTS_ATTN_BITS_PBF_HW_INTERRUPT)
-#define HW_PRTY_ASSERT_SET_0	(AEU_INPUTS_ATTN_BITS_BRB_PARITY_ERROR | \
-				 AEU_INPUTS_ATTN_BITS_PARSER_PARITY_ERROR | \
-				 AEU_INPUTS_ATTN_BITS_TSDM_PARITY_ERROR | \
-				 AEU_INPUTS_ATTN_BITS_SEARCHER_PARITY_ERROR |\
-				 AEU_INPUTS_ATTN_BITS_TSEMI_PARITY_ERROR)
-#define HW_INTERRUT_ASSERT_SET_1 \
-				(AEU_INPUTS_ATTN_BITS_QM_HW_INTERRUPT | \
-				 AEU_INPUTS_ATTN_BITS_TIMERS_HW_INTERRUPT | \
-				 AEU_INPUTS_ATTN_BITS_XSDM_HW_INTERRUPT | \
-				 AEU_INPUTS_ATTN_BITS_XCM_HW_INTERRUPT | \
-				 AEU_INPUTS_ATTN_BITS_XSEMI_HW_INTERRUPT | \
-				 AEU_INPUTS_ATTN_BITS_USDM_HW_INTERRUPT | \
-				 AEU_INPUTS_ATTN_BITS_UCM_HW_INTERRUPT | \
-				 AEU_INPUTS_ATTN_BITS_USEMI_HW_INTERRUPT | \
-				 AEU_INPUTS_ATTN_BITS_UPB_HW_INTERRUPT | \
-				 AEU_INPUTS_ATTN_BITS_CSDM_HW_INTERRUPT | \
-				 AEU_INPUTS_ATTN_BITS_CCM_HW_INTERRUPT)
-#define HW_PRTY_ASSERT_SET_1	(AEU_INPUTS_ATTN_BITS_PBCLIENT_PARITY_ERROR |\
-				 AEU_INPUTS_ATTN_BITS_QM_PARITY_ERROR | \
-				 AEU_INPUTS_ATTN_BITS_XSDM_PARITY_ERROR | \
-				 AEU_INPUTS_ATTN_BITS_XSEMI_PARITY_ERROR | \
-				 AEU_INPUTS_ATTN_BITS_DOORBELLQ_PARITY_ERROR |\
-			     AEU_INPUTS_ATTN_BITS_VAUX_PCI_CORE_PARITY_ERROR |\
-				 AEU_INPUTS_ATTN_BITS_DEBUG_PARITY_ERROR | \
-				 AEU_INPUTS_ATTN_BITS_USDM_PARITY_ERROR | \
-				 AEU_INPUTS_ATTN_BITS_USEMI_PARITY_ERROR | \
-				 AEU_INPUTS_ATTN_BITS_UPB_PARITY_ERROR | \
-				 AEU_INPUTS_ATTN_BITS_CSDM_PARITY_ERROR)
-#define HW_INTERRUT_ASSERT_SET_2 \
-				(AEU_INPUTS_ATTN_BITS_CSEMI_HW_INTERRUPT | \
-				 AEU_INPUTS_ATTN_BITS_CDU_HW_INTERRUPT | \
-				 AEU_INPUTS_ATTN_BITS_DMAE_HW_INTERRUPT | \
-			AEU_INPUTS_ATTN_BITS_PXPPCICLOCKCLIENT_HW_INTERRUPT |\
-				 AEU_INPUTS_ATTN_BITS_MISC_HW_INTERRUPT)
-#define HW_PRTY_ASSERT_SET_2	(AEU_INPUTS_ATTN_BITS_CSEMI_PARITY_ERROR | \
-				 AEU_INPUTS_ATTN_BITS_PXP_PARITY_ERROR | \
-			AEU_INPUTS_ATTN_BITS_PXPPCICLOCKCLIENT_PARITY_ERROR |\
-				 AEU_INPUTS_ATTN_BITS_CFC_PARITY_ERROR | \
-				 AEU_INPUTS_ATTN_BITS_CDU_PARITY_ERROR | \
-				 AEU_INPUTS_ATTN_BITS_IGU_PARITY_ERROR | \
-				 AEU_INPUTS_ATTN_BITS_MISC_PARITY_ERROR)
-
-
-#define MULTI_FLAGS(bp) \
-		(TSTORM_ETH_FUNCTION_COMMON_CONFIG_RSS_IPV4_CAPABILITY | \
-		 TSTORM_ETH_FUNCTION_COMMON_CONFIG_RSS_IPV4_TCP_CAPABILITY | \
-		 TSTORM_ETH_FUNCTION_COMMON_CONFIG_RSS_IPV6_CAPABILITY | \
-		 TSTORM_ETH_FUNCTION_COMMON_CONFIG_RSS_IPV6_TCP_CAPABILITY | \
-		 (bp->multi_mode << \
-		  TSTORM_ETH_FUNCTION_COMMON_CONFIG_RSS_MODE_SHIFT))
-#define MULTI_MASK			0x7f
-
-
-#define DEF_USB_FUNC_OFF		(2 + 2*HC_USTORM_DEF_SB_NUM_INDICES)
-#define DEF_CSB_FUNC_OFF		(2 + 2*HC_CSTORM_DEF_SB_NUM_INDICES)
-#define DEF_XSB_FUNC_OFF		(2 + 2*HC_XSTORM_DEF_SB_NUM_INDICES)
-#define DEF_TSB_FUNC_OFF		(2 + 2*HC_TSTORM_DEF_SB_NUM_INDICES)
-
-#define C_DEF_SB_SP_INDEX		HC_INDEX_DEF_C_ETH_SLOW_PATH
-
-#define BNX2X_SP_DSB_INDEX \
-(&bp->def_status_blk->c_def_status_block.index_values[C_DEF_SB_SP_INDEX])
-
-
-#define CAM_IS_INVALID(x) \
-(x.target_table_entry.flags == TSTORM_CAM_TARGET_TABLE_ENTRY_ACTION_TYPE)
-
-#define CAM_INVALIDATE(x) \
-	(x.target_table_entry.flags = TSTORM_CAM_TARGET_TABLE_ENTRY_ACTION_TYPE)
-
-
-/* Number of u32 elements in MC hash array */
-#define MC_HASH_SIZE			8
-#define MC_HASH_OFFSET(bp, i)		(BAR_TSTRORM_INTMEM + \
-	TSTORM_APPROXIMATE_MATCH_MULTICAST_FILTERING_OFFSET(BP_FUNC(bp)) + i*4)
-
-
-#ifndef PXP2_REG_PXP2_INT_STS
-#define PXP2_REG_PXP2_INT_STS		PXP2_REG_PXP2_INT_STS_0
-#endif
-
-/* MISC_REG_RESET_REG - this is here for the hsi to work don't touch */
-
-#endif /* bnx2x.h */
diff -r f4bf81a7ff20 drivers/net/bnx2x_compat.h
--- a/drivers/net/bnx2x_compat.h
+++ /dev/null
@@ -1,746 +0,0 @@
-#ifndef __BNX2X_COMPAT_H__
-#define __BNX2X_COMPAT_H__
-
-#ifndef __VMKLNX__
-#define VMWARE_ESX_DDK_VERSION		0
-#endif
-
-#include <linux/in.h>
-#include <linux/in6.h>
-#include <linux/version.h>
-
-#if (LINUX_VERSION_CODE < 0x02061e)
-#define skb_record_rx_queue(skb, index)
-#define skb_tx_hash(dev, skb)	0
-#endif
-
-#if (LINUX_VERSION_CODE < 0x020618) && (VMWARE_ESX_DDK_VERSION < 40000) && !defined(NETIF_F_GRO)
-#define napi_complete(napi)		netif_rx_complete(dev)
-#endif
-#if (LINUX_VERSION_CODE < 0x020618) && (VMWARE_ESX_DDK_VERSION < 40000)
-#define napi_schedule(dev)		netif_rx_schedule(dev)
-#endif
-
-#if !defined(BNX2X_NEW_NAPI) && defined(USE_NAPI_GRO)
-extern int  __bnx2x_poll(struct net_device *dev, int *budget);
-
-#define netif_napi_add(_dev, _napi, _poll, _weight) 	\
-do {							\
-	(_dev)->poll = (__bnx2x_poll);			\
-	(_dev)->weight = _weight;			\
-	(_napi)->poll = _poll;				\
-	(_napi)->weight = _weight;			\
-	(_napi)->dev = _dev;				\
-	dev_hold(_dev);        				\
-	set_bit(__LINK_STATE_RX_SCHED, &_dev->state);	\
-	set_bit(__LINK_STATE_START, &(_dev->state));	\
-} while (0)
-
-#define netif_napi_del(_napi)		\
-do {					\
-	dev_hold((_napi)->dev);		\
-} while (0)
-
-#endif
-
-#ifndef false
-#define false 0
-#define true 1
-#endif
-
-#ifndef NETIF_F_GRO
-#define napi_gro_receive(napi, skb) netif_receive_skb(skb)
-#define vlan_gro_receive(napi, vlgrp, vlan, skb) \
-				vlan_hwaccel_receive_skb(skb, vlgrp, vlan)
-#endif
-
-#ifndef BNX2X_MULTI_QUEUE
-#define netif_tx_wake_all_queues	netif_wake_queue
-#define netif_tx_start_all_queues	netif_start_queue
-#endif
-
-#if (LINUX_VERSION_CODE < 0x020616)
-#define skb_copy_from_linear_data_offset(skb, pad, new_skb_data, len) \
-				memcpy(new_skb_data, skb->data + pad, len)
-
-/* skb_buff accessors */
-#define ip_hdr(skb)			(skb)->nh.iph
-#define ipv6_hdr(skb)			(skb)->nh.ipv6h
-#define ip_hdrlen(skb)			(ip_hdr(skb)->ihl * 4)
-#define tcp_hdr(skb)			(skb)->h.th
-#define tcp_hdrlen(skb)			(tcp_hdr(skb)->doff * 4)
-#define udp_hdr(skb)			(skb)->h.uh
-#define skb_mac_header(skb)		((skb)->mac.raw)
-#define skb_network_header(skb)		((skb)->nh.raw)
-#define skb_transport_header(skb)	((skb)->h.raw)
-#endif
-
-
-#ifndef CHECKSUM_PARTIAL
-#define CHECKSUM_PARTIAL		CHECKSUM_HW
-#endif
-
-
-#if (LINUX_VERSION_CODE < 0x020600)
-#define might_sleep()
-
-#define num_online_cpus()		1
-
-#define dev_info(dev, format, args...) \
-				printk(KERN_INFO "bnx2x: " format, ##args)
-
-#define dev_err(dev, format, args...) \
-				printk(KERN_ERR "bnx2x: " format, ##args)
-
-static inline int dma_mapping_error(dma_addr_t mapping)
-{
-	return 0;
-}
-
-#define synchronize_irq(X)		synchronize_irq()
-#define flush_scheduled_work()
-#endif
-
-
-#ifndef SET_MODULE_OWNER
-#define SET_MODULE_OWNER(dev)
-#endif
-
-
-#if (LINUX_VERSION_CODE < 0x020604)
-#define MODULE_VERSION(version)
-#endif
-
-
-#if (LINUX_VERSION_CODE < 0x020605)
-static inline void pci_dma_sync_single_for_device(struct pci_dev *dev,
-						  dma_addr_t map, size_t size,
-						  int dir)
-{
-}
-#endif
-
-
-#if (LINUX_VERSION_CODE < 0x020547)
-#define pci_set_consistent_dma_mask(X, Y)	(0)
-#endif
-
-
-#if (LINUX_VERSION_CODE < 0x020607)
-#define msleep(x) \
-	do { \
-		current->state = TASK_UNINTERRUPTIBLE; \
-		schedule_timeout((HZ * (x)) / 1000); \
-	} while (0)
-
-#ifndef ADVERTISE_1000XPAUSE
-static inline struct mii_ioctl_data *if_mii(struct ifreq *rq)
-{
-	return (struct mii_ioctl_data *)&rq->ifr_ifru;
-}
-#endif
-#endif
-
-#if (LINUX_VERSION_CODE < 0x020608)
-struct msix_entry {
-	u32     vector; /* kernel uses to write allocated vector */
-	u16     entry;  /* driver uses to specify entry, OS writes */
-};
-#define pci_enable_msix(X, Y, Z)	(-1)
-#define pci_enable_msi(X)		(-1)
-#define pci_disable_msix(X)
-#define pci_disable_msi(X)
-#endif
-
-#if (LINUX_VERSION_CODE < 0x020609)
-#define msleep_interruptible(x) \
-	do{ \
-		current->state = TASK_INTERRUPTIBLE; \
-		schedule_timeout((HZ * (x)) / 1000); \
-	} while (0)
-
-#endif
-
-
-#if (LINUX_VERSION_CODE < 0x02060b)
-#define pm_message_t			u32
-#define pci_power_t			u32
-#define PCI_D0				0
-#define PCI_D3hot			3
-#define pci_choose_state(pdev, state)	state
-#endif
-
-
-#if (LINUX_VERSION_CODE < 0x02060e)
-#define touch_softlockup_watchdog()
-#endif
-
-
-#if (LINUX_VERSION_CODE < 0x020612)
-static inline struct sk_buff *netdev_alloc_skb(struct net_device *dev,
-					       unsigned int length)
-{
-	struct sk_buff *skb = dev_alloc_skb(length);
-
-	if (skb)
-		skb->dev = dev;
-	return skb;
-}
-#endif
-
-
-#if (LINUX_VERSION_CODE < 0x020614)
-#define PCI_VDEVICE(vendor, device)             \
-        PCI_VENDOR_ID_##vendor, (device),       \
-        PCI_ANY_ID, PCI_ANY_ID, 0, 0
-#endif
-
-#if (LINUX_VERSION_CODE < 0x020615)
-#define vlan_group_set_device(vg, vlan_id, dev)	vg->vlan_devices[vlan_id] = dev
-#endif
-
-
-#ifndef IRQ_RETVAL
-typedef void				irqreturn_t;
-#define IRQ_HANDLED
-#define IRQ_NONE
-#endif
-
-
-#ifndef IRQF_SHARED
-#define IRQF_SHARED			SA_SHIRQ
-#endif
-
-
-#ifndef NETIF_F_GSO
-static inline void netif_tx_lock(struct net_device *dev)
-{
-	spin_lock(&dev->xmit_lock);
-	dev->xmit_lock_owner = smp_processor_id();
-}
-
-static inline void netif_tx_unlock(struct net_device *dev)
-{
-	dev->xmit_lock_owner = -1;
-	spin_unlock(&dev->xmit_lock);
-}
-#endif
-
-
-#ifndef skb_shinfo
-#define skb_shinfo(SKB)	((struct skb_shared_info *)(skb_end_pointer(SKB)))
-#endif
-
-
-#ifdef NETIF_F_TSO
-#ifndef NETIF_F_GSO
-
-static inline int skb_is_gso(const struct sk_buff *skb)
-{
-	return skb_shinfo(skb)->tso_size;
-}
-
-#define gso_size			tso_size
-
-#endif /* NETIF_F_GSO */
-
-#ifndef NETIF_F_GSO_SOFTWARE
-#define NETIF_F_GSO_SOFTWARE		(NETIF_F_TSO)
-#endif
-
-#endif /* NETIF_F_TSO */
-
-#ifndef NETIF_F_TSO_ECN
-#define NETIF_F_TSO_ECN			0
-#endif
-
-
-#if !defined(mmiowb)
-#define mmiowb()
-#endif
-
-#if !defined(__iomem)
-#define __iomem
-#endif
-
-#ifndef noinline
-#define noinline
-#endif
-
-#if !defined(INIT_WORK)
-#define INIT_WORK INIT_TQUEUE
-#define schedule_work			schedule_task
-#define work_struct			tq_struct
-#endif
-
-#if !defined(HAVE_NETDEV_PRIV) && (LINUX_VERSION_CODE != 0x020603) && (LINUX_VERSION_CODE != 0x020604) && (LINUX_VERSION_CODE != 0x020605)
-#define netdev_priv(dev)		(dev)->priv
-#endif
-
-/* Missing defines */
-#ifndef SPEED_2500
-#define SPEED_2500			2500
-#endif
-
-#ifndef SUPPORTED_Pause
-#define SUPPORTED_Pause			(1 << 13)
-#endif
-#ifndef SUPPORTED_Asym_Pause
-#define SUPPORTED_Asym_Pause		(1 << 14)
-#endif
-
-#ifndef ADVERTISED_Pause
-#define ADVERTISED_Pause		(1 << 13)
-#endif
-
-#ifndef ADVERTISED_Asym_Pause
-#define ADVERTISED_Asym_Pause		(1 << 14)
-#endif
-
-#ifndef DMA_BIT_MASK
-#define DMA_BIT_MASK(n) (((n) == 64) ? ~0ULL : ((1ULL<<(n))-1))
-#endif
-
-#ifndef PCI_CAP_ID_EXP
-#define PCI_CAP_ID_EXP			0x10
-#endif
-
-#ifndef PCI_EXP_DEVCTL
-#define PCI_EXP_DEVCTL			8	/* Device Control */
-#endif
-
-#ifndef PCI_EXP_DEVCTL_PAYLOAD
-#define PCI_EXP_DEVCTL_PAYLOAD		0x00e0	/* Max_Payload_Size */
-#endif
-
-#ifndef PCI_EXP_DEVCTL_READRQ
-#define PCI_EXP_DEVCTL_READRQ		0x7000	/* Max_Read_Request_Size */
-#endif
-
-
-#if (LINUX_VERSION_CODE < 0x020618)
-
-#ifndef NETIF_F_HW_CSUM
-#define NETIF_F_HW_CSUM			8
-#endif
-
-static inline int bnx2x_set_tx_hw_csum(struct net_device *dev, u32 data)
-{
-	if (data)
-		dev->features |= NETIF_F_HW_CSUM;
-	else
-		dev->features &= ~NETIF_F_HW_CSUM;
-	return 0;
-}
-#endif
-
-
-/* If mutex is not available, use semaphore */
-#ifndef __LINUX_MUTEX_H
-#define mutex				semaphore
-#define mutex_lock(x)			down(x)
-#define mutex_unlock(x)			up(x)
-#define mutex_init(x)			sema_init(x,1)
-#endif
-
-
-#ifndef KERN_CONT
-#define KERN_CONT			""
-#endif
-
-
-#if (LINUX_VERSION_CODE < 0x020619)
-#define le16_add_cpu(var, val) *var = cpu_to_le16(le16_to_cpup(var) + val)
-#define le32_add_cpu(var, val) *var = cpu_to_le32(le32_to_cpup(var) + val)
-#endif
-
-#if (LINUX_VERSION_CODE < 0x020620)
-/* Driver transmit return codes */
-#undef NETDEV_TX_OK
-#undef NETDEV_TX_BUSY
-#undef NETDEV_TX_LOCKED
-enum netdev_tx {
-	NETDEV_TX_OK = 0,	/* driver took care of packet */
-	NETDEV_TX_BUSY,		/* driver tx path was busy*/
-	NETDEV_TX_LOCKED = -1,	/* driver tx lock was already taken */
-};
-typedef enum netdev_tx netdev_tx_t;
-#endif
-
-#if (LINUX_VERSION_CODE < 0x02061b) || defined(BNX2X_DRIVER_DISK) || defined(__VMKLNX__)
-
-/*
- * This is the CRC-32C table
- * Generated with:
- * width = 32 bits
- * poly = 0x1EDC6F41
- * reflect input bytes = true
- * reflect output bytes = true
- */
-
-static u32 crc32c_table[256] = {
-	0x00000000L, 0xF26B8303L, 0xE13B70F7L, 0x1350F3F4L,
-	0xC79A971FL, 0x35F1141CL, 0x26A1E7E8L, 0xD4CA64EBL,
-	0x8AD958CFL, 0x78B2DBCCL, 0x6BE22838L, 0x9989AB3BL,
-	0x4D43CFD0L, 0xBF284CD3L, 0xAC78BF27L, 0x5E133C24L,
-	0x105EC76FL, 0xE235446CL, 0xF165B798L, 0x030E349BL,
-	0xD7C45070L, 0x25AFD373L, 0x36FF2087L, 0xC494A384L,
-	0x9A879FA0L, 0x68EC1CA3L, 0x7BBCEF57L, 0x89D76C54L,
-	0x5D1D08BFL, 0xAF768BBCL, 0xBC267848L, 0x4E4DFB4BL,
-	0x20BD8EDEL, 0xD2D60DDDL, 0xC186FE29L, 0x33ED7D2AL,
-	0xE72719C1L, 0x154C9AC2L, 0x061C6936L, 0xF477EA35L,
-	0xAA64D611L, 0x580F5512L, 0x4B5FA6E6L, 0xB93425E5L,
-	0x6DFE410EL, 0x9F95C20DL, 0x8CC531F9L, 0x7EAEB2FAL,
-	0x30E349B1L, 0xC288CAB2L, 0xD1D83946L, 0x23B3BA45L,
-	0xF779DEAEL, 0x05125DADL, 0x1642AE59L, 0xE4292D5AL,
-	0xBA3A117EL, 0x4851927DL, 0x5B016189L, 0xA96AE28AL,
-	0x7DA08661L, 0x8FCB0562L, 0x9C9BF696L, 0x6EF07595L,
-	0x417B1DBCL, 0xB3109EBFL, 0xA0406D4BL, 0x522BEE48L,
-	0x86E18AA3L, 0x748A09A0L, 0x67DAFA54L, 0x95B17957L,
-	0xCBA24573L, 0x39C9C670L, 0x2A993584L, 0xD8F2B687L,
-	0x0C38D26CL, 0xFE53516FL, 0xED03A29BL, 0x1F682198L,
-	0x5125DAD3L, 0xA34E59D0L, 0xB01EAA24L, 0x42752927L,
-	0x96BF4DCCL, 0x64D4CECFL, 0x77843D3BL, 0x85EFBE38L,
-	0xDBFC821CL, 0x2997011FL, 0x3AC7F2EBL, 0xC8AC71E8L,
-	0x1C661503L, 0xEE0D9600L, 0xFD5D65F4L, 0x0F36E6F7L,
-	0x61C69362L, 0x93AD1061L, 0x80FDE395L, 0x72966096L,
-	0xA65C047DL, 0x5437877EL, 0x4767748AL, 0xB50CF789L,
-	0xEB1FCBADL, 0x197448AEL, 0x0A24BB5AL, 0xF84F3859L,
-	0x2C855CB2L, 0xDEEEDFB1L, 0xCDBE2C45L, 0x3FD5AF46L,
-	0x7198540DL, 0x83F3D70EL, 0x90A324FAL, 0x62C8A7F9L,
-	0xB602C312L, 0x44694011L, 0x5739B3E5L, 0xA55230E6L,
-	0xFB410CC2L, 0x092A8FC1L, 0x1A7A7C35L, 0xE811FF36L,
-	0x3CDB9BDDL, 0xCEB018DEL, 0xDDE0EB2AL, 0x2F8B6829L,
-	0x82F63B78L, 0x709DB87BL, 0x63CD4B8FL, 0x91A6C88CL,
-	0x456CAC67L, 0xB7072F64L, 0xA457DC90L, 0x563C5F93L,
-	0x082F63B7L, 0xFA44E0B4L, 0xE9141340L, 0x1B7F9043L,
-	0xCFB5F4A8L, 0x3DDE77ABL, 0x2E8E845FL, 0xDCE5075CL,
-	0x92A8FC17L, 0x60C37F14L, 0x73938CE0L, 0x81F80FE3L,
-	0x55326B08L, 0xA759E80BL, 0xB4091BFFL, 0x466298FCL,
-	0x1871A4D8L, 0xEA1A27DBL, 0xF94AD42FL, 0x0B21572CL,
-	0xDFEB33C7L, 0x2D80B0C4L, 0x3ED04330L, 0xCCBBC033L,
-	0xA24BB5A6L, 0x502036A5L, 0x4370C551L, 0xB11B4652L,
-	0x65D122B9L, 0x97BAA1BAL, 0x84EA524EL, 0x7681D14DL,
-	0x2892ED69L, 0xDAF96E6AL, 0xC9A99D9EL, 0x3BC21E9DL,
-	0xEF087A76L, 0x1D63F975L, 0x0E330A81L, 0xFC588982L,
-	0xB21572C9L, 0x407EF1CAL, 0x532E023EL, 0xA145813DL,
-	0x758FE5D6L, 0x87E466D5L, 0x94B49521L, 0x66DF1622L,
-	0x38CC2A06L, 0xCAA7A905L, 0xD9F75AF1L, 0x2B9CD9F2L,
-	0xFF56BD19L, 0x0D3D3E1AL, 0x1E6DCDEEL, 0xEC064EEDL,
-	0xC38D26C4L, 0x31E6A5C7L, 0x22B65633L, 0xD0DDD530L,
-	0x0417B1DBL, 0xF67C32D8L, 0xE52CC12CL, 0x1747422FL,
-	0x49547E0BL, 0xBB3FFD08L, 0xA86F0EFCL, 0x5A048DFFL,
-	0x8ECEE914L, 0x7CA56A17L, 0x6FF599E3L, 0x9D9E1AE0L,
-	0xD3D3E1ABL, 0x21B862A8L, 0x32E8915CL, 0xC083125FL,
-	0x144976B4L, 0xE622F5B7L, 0xF5720643L, 0x07198540L,
-	0x590AB964L, 0xAB613A67L, 0xB831C993L, 0x4A5A4A90L,
-	0x9E902E7BL, 0x6CFBAD78L, 0x7FAB5E8CL, 0x8DC0DD8FL,
-	0xE330A81AL, 0x115B2B19L, 0x020BD8EDL, 0xF0605BEEL,
-	0x24AA3F05L, 0xD6C1BC06L, 0xC5914FF2L, 0x37FACCF1L,
-	0x69E9F0D5L, 0x9B8273D6L, 0x88D28022L, 0x7AB90321L,
-	0xAE7367CAL, 0x5C18E4C9L, 0x4F48173DL, 0xBD23943EL,
-	0xF36E6F75L, 0x0105EC76L, 0x12551F82L, 0xE03E9C81L,
-	0x34F4F86AL, 0xC69F7B69L, 0xD5CF889DL, 0x27A40B9EL,
-	0x79B737BAL, 0x8BDCB4B9L, 0x988C474DL, 0x6AE7C44EL,
-	0xBE2DA0A5L, 0x4C4623A6L, 0x5F16D052L, 0xAD7D5351L
-};
-
-/*
- * Steps through buffer one byte at at time, calculates reflected
- * crc using table.
- */
-
-static inline u32 /*__attribute_pure__*/
-crc32c_le(u32 seed, unsigned char const *data, size_t length)
-{
-	__le32 crc = __cpu_to_le32(seed);
-
-	while (length--)
-		crc = crc32c_table[(crc ^ *data++) & 0xFFL] ^ (crc >> 8);
-
-	return __le32_to_cpu(crc);
-}
-#endif
-
-/* Taken from drivers/net/mdio.c */
-#if (LINUX_VERSION_CODE < 0x02061f)
-#include <linux/mii.h>
-
-/* MDIO Manageable Devices (MMDs). */
-#define MDIO_MMD_AN		7	/* Auto-Negotiation */
-
-/* Generic MDIO registers. */
-#define MDIO_AN_ADVERTISE	16	/* AN advertising (base page) */
-#define MDIO_AN_LPA		19	/* AN LP abilities (base page) */
-
-/* Device present registers. */
-#define MDIO_DEVS_PRESENT(devad)	(1 << (devad))
-#define MDIO_DEVS_AN			MDIO_DEVS_PRESENT(MDIO_MMD_AN)
-
-/**
- * struct mdio_if_info - Ethernet controller MDIO interface
- * @prtad: PRTAD of the PHY (%MDIO_PRTAD_NONE if not present/unknown)
- * @mmds: Mask of MMDs expected to be present in the PHY.  This must be
- *	non-zero unless @prtad = %MDIO_PRTAD_NONE.
- * @mode_support: MDIO modes supported.  If %MDIO_SUPPORTS_C22 is set then
- *	MII register access will be passed through with @devad =
- *	%MDIO_DEVAD_NONE.  If %MDIO_EMULATE_C22 is set then access to
- *	commonly used clause 22 registers will be translated into
- *	clause 45 registers.
- * @dev: Net device structure
- * @mdio_read: Register read function; returns value or negative error code
- * @mdio_write: Register write function; returns 0 or negative error code
- */
-struct mdio_if_info {
-	int prtad;
-	u32 __bitwise mmds;
-	unsigned mode_support;
-
-	struct net_device *dev;
-	int (*mdio_read)(struct net_device *dev, int prtad, int devad,
-			 u16 addr);
-	int (*mdio_write)(struct net_device *dev, int prtad, int devad,
-			  u16 addr, u16 val);
-};
-
-#define MDIO_PRTAD_NONE			(-1)
-#define MDIO_DEVAD_NONE			(-1)
-#define MDIO_EMULATE_C22		4
-
-/* Mapping between MDIO PRTAD/DEVAD and mii_ioctl_data::phy_id */
-
-#define MDIO_PHY_ID_C45			0x8000
-#define MDIO_PHY_ID_PRTAD		0x03e0
-#define MDIO_PHY_ID_DEVAD		0x001f
-#define MDIO_PHY_ID_C45_MASK						\
-	(MDIO_PHY_ID_C45 | MDIO_PHY_ID_PRTAD | MDIO_PHY_ID_DEVAD)
-
-static inline int mdio_phy_id_is_c45(int phy_id)
-{
-	return (phy_id & MDIO_PHY_ID_C45) && !(phy_id & ~MDIO_PHY_ID_C45_MASK);
-}
-
-static inline __u16 mdio_phy_id_prtad(int phy_id)
-{
-	return (phy_id & MDIO_PHY_ID_PRTAD) >> 5;
-}
-
-static inline __u16 mdio_phy_id_devad(int phy_id)
-{
-	return phy_id & MDIO_PHY_ID_DEVAD;
-}
-
-#define MDIO_SUPPORTS_C22		1
-#define MDIO_SUPPORTS_C45		2
-
-/**
- * mdio_mii_ioctl - MII ioctl interface for MDIO (clause 22 or 45) PHYs
- * @mdio: MDIO interface
- * @mii_data: MII ioctl data structure
- * @cmd: MII ioctl command
- *
- * Returns 0 on success, negative on error.
- */
-static inline int mdio_mii_ioctl(const struct mdio_if_info *mdio,
-				 struct mii_ioctl_data *mii_data, int cmd)
-{
-	int prtad, devad;
-	u16 addr = mii_data->reg_num;
-
-	/* Validate/convert cmd to one of SIOC{G,S}MIIREG */
-	switch (cmd) {
-	case SIOCGMIIPHY:
-		if (mdio->prtad == MDIO_PRTAD_NONE)
-			return -EOPNOTSUPP;
-		mii_data->phy_id = mdio->prtad;
-		cmd = SIOCGMIIREG;
-		break;
-	case SIOCGMIIREG:
-		break;
-	case SIOCSMIIREG:
-		if (!capable(CAP_NET_ADMIN))
-			return -EPERM;
-		break;
-	default:
-		return -EOPNOTSUPP;
-	}
-
-	/* Validate/convert phy_id */
-	if ((mdio->mode_support & MDIO_SUPPORTS_C45) &&
-	    mdio_phy_id_is_c45(mii_data->phy_id)) {
-		prtad = mdio_phy_id_prtad(mii_data->phy_id);
-		devad = mdio_phy_id_devad(mii_data->phy_id);
-	} else if ((mdio->mode_support & MDIO_SUPPORTS_C22) &&
-		   mii_data->phy_id < 0x20) {
-		prtad = mii_data->phy_id;
-		devad = MDIO_DEVAD_NONE;
-		addr &= 0x1f;
-	} else if ((mdio->mode_support & MDIO_EMULATE_C22) &&
-		   mdio->prtad != MDIO_PRTAD_NONE &&
-		   mii_data->phy_id == mdio->prtad) {
-		/* Remap commonly-used MII registers. */
-		prtad = mdio->prtad;
-		switch (addr) {
-		case MII_BMCR:
-		case MII_BMSR:
-		case MII_PHYSID1:
-		case MII_PHYSID2:
-			devad = __ffs(mdio->mmds);
-			break;
-		case MII_ADVERTISE:
-		case MII_LPA:
-			if (!(mdio->mmds & MDIO_DEVS_AN))
-				return -EINVAL;
-			devad = MDIO_MMD_AN;
-			if (addr == MII_ADVERTISE)
-				addr = MDIO_AN_ADVERTISE;
-			else
-				addr = MDIO_AN_LPA;
-			break;
-		default:
-			return -EINVAL;
-		}
-	} else {
-		return -EINVAL;
-	}
-
-	if (cmd == SIOCGMIIREG) {
-		int rc = mdio->mdio_read(mdio->dev, prtad, devad, addr);
-		if (rc < 0)
-			return rc;
-		mii_data->val_out = rc;
-		return 0;
-	} else {
-		return mdio->mdio_write(mdio->dev, prtad, devad, addr,
-					mii_data->val_in);
-	}
-}
-#endif
-
-#if (LINUX_VERSION_CODE < 0x02061D)
-static inline ssize_t
-pci_read_vpd(struct pci_dev *dev, loff_t pos, size_t count, u8 *buf)
-{
-	int i, vpd_cap;
-
-	vpd_cap = pci_find_capability(dev, PCI_CAP_ID_VPD);
-	if (!vpd_cap)
-		return -ENODEV;
-
-	for (i = 0; i < count; i += 4) {
-		u32 tmp, j = 0;
-		__le32 v;
-		u16 tmp16;
-
-		pci_write_config_word(dev, vpd_cap + PCI_VPD_ADDR, i);
-		while (j++ < 100) {
-			pci_read_config_word(dev, vpd_cap +
-					     PCI_VPD_ADDR, &tmp16);
-			if (tmp16 & 0x8000)
-				break;
-			msleep(1);
-		}
-		if (!(tmp16 & 0x8000))
-			break;
-
-		pci_read_config_dword(dev, vpd_cap + PCI_VPD_DATA, &tmp);
-		v = cpu_to_le32(tmp);
-		memcpy(&buf[i], &v, sizeof(v));
-	}
-
-	return i;
-}
-#endif
-#if (LINUX_VERSION_CODE < 0x02060c)
-#define is_multicast_ether_addr(addr) \
-		((((u8*)addr)[0] != 0xff) && (0x01 & ((u8*)addr)[0]))
-#endif
-
-#ifndef bool
-#define bool int
-#endif
-
-#if (LINUX_VERSION_CODE < 0x02060e)
-#define is_broadcast_ether_addr(addr) \
-	((((u8*)addr)[0] == 0xff) && (((u8*)addr)[1] == 0xff) &&\
-	 (((u8*)addr)[2] == 0xff) && (((u8*)addr)[3] == 0xff) &&\
-	 (((u8*)addr)[4] == 0xff) && (((u8*)addr)[5] == 0xff))
-#endif
-
-#ifndef DEFINE_PCI_DEVICE_TABLE
-#define DEFINE_PCI_DEVICE_TABLE(tbl) const struct pci_device_id bnx2x_pci_tbl[]
-#endif
-
-#if (LINUX_VERSION_CODE < 0x020606)
-#undef netdev_printk
-#undef netdev_err
-#undef netdev_info
-#endif
-
-#ifndef netdev_printk
-
-#if (LINUX_VERSION_CODE < 0x020615)
-#define NET_PARENT_DEV(netdev)  ((netdev)->class_dev.dev)
-#else
-#define NET_PARENT_DEV(netdev)  ((netdev)->dev.parent)
-#endif
-
-#define netdev_printk(level, netdev, format, args...)		\
-	dev_printk(level, NET_PARENT_DEV(netdev),	\
-		   "%s: " format,				\
-		   netdev_name(netdev), ##args)
-
-static inline const char *netdev_name(const struct net_device *dev)
-{
-	if (dev->reg_state != NETREG_REGISTERED)
-		return "(unregistered net_device)";
-	return dev->name;
-}
-
-
-#endif
-
-#ifndef netdev_err
-#define netdev_err(dev, format, args...)			\
-	netdev_printk(KERN_ERR, dev, format, ##args)
-#endif
-
-#ifndef pr_cont
-#define pr_cont(fmt, ...) \
-	printk(KERN_CONT fmt, ##__VA_ARGS__)
-#endif
-
-#ifndef netdev_info
-#define netdev_info(dev, format, args...)			\
-	netdev_printk(KERN_INFO, dev, format, ##args)
-#endif
-
-#ifndef pr_fmt
-#define pr_fmt(fmt) fmt
-#endif
-
-#ifndef pr_alert
-#define pr_alert(fmt, ...) \
-        printk(KERN_ALERT pr_fmt(fmt), ##__VA_ARGS__)
-#endif
-
-#ifndef pr_err
-#define pr_err(fmt, ...) \
-        printk(KERN_ERR pr_fmt(fmt), ##__VA_ARGS__)
-#endif
-
-#ifndef netdev_mc_count
-#define netdev_mc_count(dev) ((dev)->mc_count)
-#endif
-
-#ifndef dev_alert
-#define dev_alert(dev, format, arg...)		\
-	dev_printk(KERN_ALERT , dev , format , ## arg)
-#endif
-
-#ifndef netdev_for_each_mc_addr
-#define netdev_for_each_mc_addr(mclist, dev) \
-	for (mclist = (dev)->mc_list; mclist; mclist = mclist->next)
-#endif
-
-#endif /* __BNX2X_COMPAT_H__ */
diff -r f4bf81a7ff20 drivers/net/bnx2x_dump.h
--- a/drivers/net/bnx2x_dump.h
+++ /dev/null
@@ -1,534 +0,0 @@
-/* bnx2x_dump.h: Broadcom Everest network driver.
- *
- * Copyright (c) 2009 Broadcom Corporation
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation.
- */
-
-
-/* This struct holds a signature to ensure the dump returned from the driver
- * match the meta data file inserted to grc_dump.tcl
- * The signature is time stamp, diag version and grc_dump version
- */
-
-#ifndef BNX2X_DUMP_H
-#define BNX2X_DUMP_H
-
-
-struct dump_sign {
-	u32 time_stamp;
-	u32 diag_ver;
-	u32 grc_dump_ver;
-};
-
-#define TSTORM_WAITP_ADDR		0x1b8a80
-#define CSTORM_WAITP_ADDR		0x238a80
-#define XSTORM_WAITP_ADDR		0x2b8a80
-#define USTORM_WAITP_ADDR		0x338a80
-#define TSTORM_CAM_MODE			0x1b1440
-
-#define RI_E1				0x1
-#define RI_E1H				0x2
-#define RI_ONLINE			0x100
-
-#define RI_E1_OFFLINE			(RI_E1)
-#define RI_E1_ONLINE			(RI_E1 | RI_ONLINE)
-#define RI_E1H_OFFLINE			(RI_E1H)
-#define RI_E1H_ONLINE			(RI_E1H | RI_ONLINE)
-#define RI_ALL_OFFLINE			(RI_E1 | RI_E1H)
-#define RI_ALL_ONLINE			(RI_E1 | RI_E1H | RI_ONLINE)
-
-#define MAX_TIMER_PENDING		200
-#define TIMER_SCAN_DONT_CARE		0xFF
-
-
-struct dump_hdr {
-	u32		 hdr_size;	/* in dwords, excluding this field */
-	struct dump_sign dump_sign;
-	u32		 xstorm_waitp;
-	u32		 tstorm_waitp;
-	u32		 ustorm_waitp;
-	u32		 cstorm_waitp;
-	u16		 info;
-	u8		 idle_chk;
-	u8		 reserved;
-};
-
-struct reg_addr {
-	u32 addr;
-	u32 size;
-	u16 info;
-};
-
-struct wreg_addr {
-	u32 addr;
-	u32 size;
-	u32 read_regs_count;
-	const u32 *read_regs;
-	u16 info;
-};
-
-
-#define REGS_COUNT			558
-static const struct reg_addr reg_addrs[REGS_COUNT] = {
-	{ 0x2000, 341, RI_ALL_ONLINE }, { 0x2800, 103, RI_ALL_ONLINE },
-	{ 0x3000, 287, RI_ALL_ONLINE }, { 0x3800, 331, RI_ALL_ONLINE },
-	{ 0x8800, 6, RI_E1_ONLINE }, { 0xa000, 223, RI_ALL_ONLINE },
-	{ 0xa388, 1, RI_ALL_ONLINE }, { 0xa398, 1, RI_ALL_ONLINE },
-	{ 0xa39c, 7, RI_E1H_ONLINE }, { 0xa3c0, 3, RI_E1H_ONLINE },
-	{ 0xa3d0, 1, RI_E1H_ONLINE }, { 0xa3d8, 1, RI_E1H_ONLINE },
-	{ 0xa3e0, 1, RI_E1H_ONLINE }, { 0xa3e8, 1, RI_E1H_ONLINE },
-	{ 0xa3f0, 1, RI_E1H_ONLINE }, { 0xa3f8, 1, RI_E1H_ONLINE },
-	{ 0xa400, 69, RI_ALL_ONLINE }, { 0xa518, 1, RI_ALL_ONLINE },
-	{ 0xa520, 1, RI_ALL_ONLINE }, { 0xa528, 1, RI_ALL_ONLINE },
-	{ 0xa530, 1, RI_ALL_ONLINE }, { 0xa538, 1, RI_ALL_ONLINE },
-	{ 0xa540, 1, RI_ALL_ONLINE }, { 0xa548, 1, RI_ALL_ONLINE },
-	{ 0xa550, 1, RI_ALL_ONLINE }, { 0xa558, 1, RI_ALL_ONLINE },
-	{ 0xa560, 1, RI_ALL_ONLINE }, { 0xa568, 1, RI_ALL_ONLINE },
-	{ 0xa570, 1, RI_ALL_ONLINE }, { 0xa580, 1, RI_ALL_ONLINE },
-	{ 0xa590, 1, RI_ALL_ONLINE }, { 0xa5a0, 1, RI_ALL_ONLINE },
-	{ 0xa5c0, 1, RI_ALL_ONLINE }, { 0xa5e0, 1, RI_E1H_ONLINE },
-	{ 0xa5e8, 1, RI_E1H_ONLINE }, { 0xa5f0, 1, RI_E1H_ONLINE },
-	{ 0xa5f8, 10, RI_E1H_ONLINE }, { 0x10000, 236, RI_ALL_ONLINE },
-	{ 0x103bc, 1, RI_ALL_ONLINE }, { 0x103cc, 1, RI_ALL_ONLINE },
-	{ 0x103dc, 1, RI_ALL_ONLINE }, { 0x10400, 57, RI_ALL_ONLINE },
-	{ 0x104e8, 2, RI_ALL_ONLINE }, { 0x104f4, 2, RI_ALL_ONLINE },
-	{ 0x10500, 146, RI_ALL_ONLINE }, { 0x10750, 2, RI_ALL_ONLINE },
-	{ 0x10760, 2, RI_ALL_ONLINE }, { 0x10770, 2, RI_ALL_ONLINE },
-	{ 0x10780, 2, RI_ALL_ONLINE }, { 0x10790, 2, RI_ALL_ONLINE },
-	{ 0x107a0, 2, RI_ALL_ONLINE }, { 0x107b0, 2, RI_ALL_ONLINE },
-	{ 0x107c0, 2, RI_ALL_ONLINE }, { 0x107d0, 2, RI_ALL_ONLINE },
-	{ 0x107e0, 2, RI_ALL_ONLINE }, { 0x10880, 2, RI_ALL_ONLINE },
-	{ 0x10900, 2, RI_ALL_ONLINE }, { 0x12000, 1, RI_ALL_ONLINE },
-	{ 0x14000, 1, RI_ALL_ONLINE }, { 0x16000, 26, RI_E1H_ONLINE },
-	{ 0x16070, 18, RI_E1H_ONLINE }, { 0x160c0, 27, RI_E1H_ONLINE },
-	{ 0x16140, 1, RI_E1H_ONLINE }, { 0x16160, 1, RI_E1H_ONLINE },
-	{ 0x16180, 2, RI_E1H_ONLINE }, { 0x161c0, 2, RI_E1H_ONLINE },
-	{ 0x16204, 5, RI_E1H_ONLINE }, { 0x18000, 1, RI_E1H_ONLINE },
-	{ 0x18008, 1, RI_E1H_ONLINE }, { 0x20000, 24, RI_ALL_ONLINE },
-	{ 0x20060, 8, RI_ALL_ONLINE }, { 0x20080, 138, RI_ALL_ONLINE },
-	{ 0x202b4, 1, RI_ALL_ONLINE }, { 0x202c4, 1, RI_ALL_ONLINE },
-	{ 0x20400, 2, RI_ALL_ONLINE }, { 0x2040c, 8, RI_ALL_ONLINE },
-	{ 0x2042c, 18, RI_E1H_ONLINE }, { 0x20480, 1, RI_ALL_ONLINE },
-	{ 0x20500, 1, RI_ALL_ONLINE }, { 0x20600, 1, RI_ALL_ONLINE },
-	{ 0x28000, 1, RI_ALL_ONLINE }, { 0x28004, 8191, RI_ALL_OFFLINE },
-	{ 0x30000, 1, RI_ALL_ONLINE }, { 0x30004, 16383, RI_ALL_OFFLINE },
-	{ 0x40000, 98, RI_ALL_ONLINE }, { 0x40194, 1, RI_ALL_ONLINE },
-	{ 0x401a4, 1, RI_ALL_ONLINE }, { 0x401a8, 11, RI_E1H_ONLINE },
-	{ 0x40200, 4, RI_ALL_ONLINE }, { 0x40400, 43, RI_ALL_ONLINE },
-	{ 0x404b8, 1, RI_ALL_ONLINE }, { 0x404c8, 1, RI_ALL_ONLINE },
-	{ 0x404cc, 3, RI_E1H_ONLINE }, { 0x40500, 2, RI_ALL_ONLINE },
-	{ 0x40510, 2, RI_ALL_ONLINE }, { 0x40520, 2, RI_ALL_ONLINE },
-	{ 0x40530, 2, RI_ALL_ONLINE }, { 0x40540, 2, RI_ALL_ONLINE },
-	{ 0x42000, 164, RI_ALL_ONLINE }, { 0x4229c, 1, RI_ALL_ONLINE },
-	{ 0x422ac, 1, RI_ALL_ONLINE }, { 0x422bc, 1, RI_ALL_ONLINE },
-	{ 0x422d4, 5, RI_E1H_ONLINE }, { 0x42400, 49, RI_ALL_ONLINE },
-	{ 0x424c8, 38, RI_ALL_ONLINE }, { 0x42568, 2, RI_ALL_ONLINE },
-	{ 0x42800, 1, RI_ALL_ONLINE }, { 0x50000, 20, RI_ALL_ONLINE },
-	{ 0x50050, 8, RI_ALL_ONLINE }, { 0x50070, 88, RI_ALL_ONLINE },
-	{ 0x501dc, 1, RI_ALL_ONLINE }, { 0x501ec, 1, RI_ALL_ONLINE },
-	{ 0x501f0, 4, RI_E1H_ONLINE }, { 0x50200, 2, RI_ALL_ONLINE },
-	{ 0x5020c, 7, RI_ALL_ONLINE }, { 0x50228, 6, RI_E1H_ONLINE },
-	{ 0x50240, 1, RI_ALL_ONLINE }, { 0x50280, 1, RI_ALL_ONLINE },
-	{ 0x52000, 1, RI_ALL_ONLINE }, { 0x54000, 1, RI_ALL_ONLINE },
-	{ 0x54004, 3327, RI_ALL_OFFLINE }, { 0x58000, 1, RI_ALL_ONLINE },
-	{ 0x58004, 8191, RI_ALL_OFFLINE }, { 0x60000, 71, RI_ALL_ONLINE },
-	{ 0x60128, 1, RI_ALL_ONLINE }, { 0x60138, 1, RI_ALL_ONLINE },
-	{ 0x6013c, 24, RI_E1H_ONLINE }, { 0x60200, 1, RI_ALL_ONLINE },
-	{ 0x61000, 1, RI_ALL_ONLINE }, { 0x61004, 511, RI_ALL_OFFLINE },
-	{ 0x70000, 8, RI_ALL_ONLINE }, { 0x70020, 21496, RI_ALL_OFFLINE },
-	{ 0x85000, 3, RI_ALL_ONLINE }, { 0x8500c, 4, RI_ALL_OFFLINE },
-	{ 0x8501c, 7, RI_ALL_ONLINE }, { 0x85038, 4, RI_ALL_OFFLINE },
-	{ 0x85048, 1, RI_ALL_ONLINE }, { 0x8504c, 109, RI_ALL_OFFLINE },
-	{ 0x85200, 32, RI_ALL_ONLINE }, { 0x85280, 11104, RI_ALL_OFFLINE },
-	{ 0xa0000, 16384, RI_ALL_ONLINE }, { 0xb0000, 16384, RI_E1H_ONLINE },
-	{ 0xc1000, 7, RI_ALL_ONLINE }, { 0xc1028, 1, RI_ALL_ONLINE },
-	{ 0xc1038, 1, RI_ALL_ONLINE }, { 0xc1800, 2, RI_ALL_ONLINE },
-	{ 0xc2000, 164, RI_ALL_ONLINE }, { 0xc229c, 1, RI_ALL_ONLINE },
-	{ 0xc22ac, 1, RI_ALL_ONLINE }, { 0xc22bc, 1, RI_ALL_ONLINE },
-	{ 0xc2400, 49, RI_ALL_ONLINE }, { 0xc24c8, 38, RI_ALL_ONLINE },
-	{ 0xc2568, 2, RI_ALL_ONLINE }, { 0xc2600, 1, RI_ALL_ONLINE },
-	{ 0xc4000, 165, RI_ALL_ONLINE }, { 0xc42a0, 1, RI_ALL_ONLINE },
-	{ 0xc42b0, 1, RI_ALL_ONLINE }, { 0xc42c0, 1, RI_ALL_ONLINE },
-	{ 0xc42e0, 7, RI_E1H_ONLINE }, { 0xc4400, 51, RI_ALL_ONLINE },
-	{ 0xc44d0, 38, RI_ALL_ONLINE }, { 0xc4570, 2, RI_ALL_ONLINE },
-	{ 0xc4600, 1, RI_ALL_ONLINE }, { 0xd0000, 19, RI_ALL_ONLINE },
-	{ 0xd004c, 8, RI_ALL_ONLINE }, { 0xd006c, 91, RI_ALL_ONLINE },
-	{ 0xd01e4, 1, RI_ALL_ONLINE }, { 0xd01f4, 1, RI_ALL_ONLINE },
-	{ 0xd0200, 2, RI_ALL_ONLINE }, { 0xd020c, 7, RI_ALL_ONLINE },
-	{ 0xd0228, 18, RI_E1H_ONLINE }, { 0xd0280, 1, RI_ALL_ONLINE },
-	{ 0xd0300, 1, RI_ALL_ONLINE }, { 0xd0400, 1, RI_ALL_ONLINE },
-	{ 0xd4000, 1, RI_ALL_ONLINE }, { 0xd4004, 2559, RI_ALL_OFFLINE },
-	{ 0xd8000, 1, RI_ALL_ONLINE }, { 0xd8004, 8191, RI_ALL_OFFLINE },
-	{ 0xe0000, 21, RI_ALL_ONLINE }, { 0xe0054, 8, RI_ALL_ONLINE },
-	{ 0xe0074, 85, RI_ALL_ONLINE }, { 0xe01d4, 1, RI_ALL_ONLINE },
-	{ 0xe01e4, 1, RI_ALL_ONLINE }, { 0xe0200, 2, RI_ALL_ONLINE },
-	{ 0xe020c, 8, RI_ALL_ONLINE }, { 0xe022c, 18, RI_E1H_ONLINE },
-	{ 0xe0280, 1, RI_ALL_ONLINE }, { 0xe0300, 1, RI_ALL_ONLINE },
-	{ 0xe1000, 1, RI_ALL_ONLINE }, { 0xe2000, 1, RI_ALL_ONLINE },
-	{ 0xe2004, 2047, RI_ALL_OFFLINE }, { 0xf0000, 1, RI_ALL_ONLINE },
-	{ 0xf0004, 16383, RI_ALL_OFFLINE }, { 0x101000, 12, RI_ALL_ONLINE },
-	{ 0x10103c, 1, RI_ALL_ONLINE }, { 0x10104c, 1, RI_ALL_ONLINE },
-	{ 0x101050, 1, RI_E1H_ONLINE }, { 0x101100, 1, RI_ALL_ONLINE },
-	{ 0x101800, 8, RI_ALL_ONLINE }, { 0x102000, 18, RI_ALL_ONLINE },
-	{ 0x102054, 1, RI_ALL_ONLINE }, { 0x102064, 1, RI_ALL_ONLINE },
-	{ 0x102080, 17, RI_ALL_ONLINE }, { 0x1020c8, 8, RI_E1H_ONLINE },
-	{ 0x102400, 1, RI_ALL_ONLINE }, { 0x103000, 26, RI_ALL_ONLINE },
-	{ 0x103074, 1, RI_ALL_ONLINE }, { 0x103084, 1, RI_ALL_ONLINE },
-	{ 0x103094, 1, RI_ALL_ONLINE }, { 0x103098, 5, RI_E1H_ONLINE },
-	{ 0x103800, 8, RI_ALL_ONLINE }, { 0x104000, 63, RI_ALL_ONLINE },
-	{ 0x104108, 1, RI_ALL_ONLINE }, { 0x104118, 1, RI_ALL_ONLINE },
-	{ 0x104200, 17, RI_ALL_ONLINE }, { 0x104400, 64, RI_ALL_ONLINE },
-	{ 0x104500, 192, RI_ALL_OFFLINE }, { 0x104800, 64, RI_ALL_ONLINE },
-	{ 0x104900, 192, RI_ALL_OFFLINE }, { 0x105000, 7, RI_ALL_ONLINE },
-	{ 0x10501c, 1, RI_ALL_OFFLINE }, { 0x105020, 3, RI_ALL_ONLINE },
-	{ 0x10502c, 1, RI_ALL_OFFLINE }, { 0x105030, 3, RI_ALL_ONLINE },
-	{ 0x10503c, 1, RI_ALL_OFFLINE }, { 0x105040, 3, RI_ALL_ONLINE },
-	{ 0x10504c, 1, RI_ALL_OFFLINE }, { 0x105050, 3, RI_ALL_ONLINE },
-	{ 0x10505c, 1, RI_ALL_OFFLINE }, { 0x105060, 3, RI_ALL_ONLINE },
-	{ 0x10506c, 1, RI_ALL_OFFLINE }, { 0x105070, 3, RI_ALL_ONLINE },
-	{ 0x10507c, 1, RI_ALL_OFFLINE }, { 0x105080, 3, RI_ALL_ONLINE },
-	{ 0x10508c, 1, RI_ALL_OFFLINE }, { 0x105090, 3, RI_ALL_ONLINE },
-	{ 0x10509c, 1, RI_ALL_OFFLINE }, { 0x1050a0, 3, RI_ALL_ONLINE },
-	{ 0x1050ac, 1, RI_ALL_OFFLINE }, { 0x1050b0, 3, RI_ALL_ONLINE },
-	{ 0x1050bc, 1, RI_ALL_OFFLINE }, { 0x1050c0, 3, RI_ALL_ONLINE },
-	{ 0x1050cc, 1, RI_ALL_OFFLINE }, { 0x1050d0, 3, RI_ALL_ONLINE },
-	{ 0x1050dc, 1, RI_ALL_OFFLINE }, { 0x1050e0, 3, RI_ALL_ONLINE },
-	{ 0x1050ec, 1, RI_ALL_OFFLINE }, { 0x1050f0, 3, RI_ALL_ONLINE },
-	{ 0x1050fc, 1, RI_ALL_OFFLINE }, { 0x105100, 3, RI_ALL_ONLINE },
-	{ 0x10510c, 1, RI_ALL_OFFLINE }, { 0x105110, 3, RI_ALL_ONLINE },
-	{ 0x10511c, 1, RI_ALL_OFFLINE }, { 0x105120, 3, RI_ALL_ONLINE },
-	{ 0x10512c, 1, RI_ALL_OFFLINE }, { 0x105130, 3, RI_ALL_ONLINE },
-	{ 0x10513c, 1, RI_ALL_OFFLINE }, { 0x105140, 3, RI_ALL_ONLINE },
-	{ 0x10514c, 1, RI_ALL_OFFLINE }, { 0x105150, 3, RI_ALL_ONLINE },
-	{ 0x10515c, 1, RI_ALL_OFFLINE }, { 0x105160, 3, RI_ALL_ONLINE },
-	{ 0x10516c, 1, RI_ALL_OFFLINE }, { 0x105170, 3, RI_ALL_ONLINE },
-	{ 0x10517c, 1, RI_ALL_OFFLINE }, { 0x105180, 3, RI_ALL_ONLINE },
-	{ 0x10518c, 1, RI_ALL_OFFLINE }, { 0x105190, 3, RI_ALL_ONLINE },
-	{ 0x10519c, 1, RI_ALL_OFFLINE }, { 0x1051a0, 3, RI_ALL_ONLINE },
-	{ 0x1051ac, 1, RI_ALL_OFFLINE }, { 0x1051b0, 3, RI_ALL_ONLINE },
-	{ 0x1051bc, 1, RI_ALL_OFFLINE }, { 0x1051c0, 3, RI_ALL_ONLINE },
-	{ 0x1051cc, 1, RI_ALL_OFFLINE }, { 0x1051d0, 3, RI_ALL_ONLINE },
-	{ 0x1051dc, 1, RI_ALL_OFFLINE }, { 0x1051e0, 3, RI_ALL_ONLINE },
-	{ 0x1051ec, 1, RI_ALL_OFFLINE }, { 0x1051f0, 3, RI_ALL_ONLINE },
-	{ 0x1051fc, 1, RI_ALL_OFFLINE }, { 0x105200, 3, RI_ALL_ONLINE },
-	{ 0x10520c, 1, RI_ALL_OFFLINE }, { 0x105210, 3, RI_ALL_ONLINE },
-	{ 0x10521c, 1, RI_ALL_OFFLINE }, { 0x105220, 3, RI_ALL_ONLINE },
-	{ 0x10522c, 1, RI_ALL_OFFLINE }, { 0x105230, 3, RI_ALL_ONLINE },
-	{ 0x10523c, 1, RI_ALL_OFFLINE }, { 0x105240, 3, RI_ALL_ONLINE },
-	{ 0x10524c, 1, RI_ALL_OFFLINE }, { 0x105250, 3, RI_ALL_ONLINE },
-	{ 0x10525c, 1, RI_ALL_OFFLINE }, { 0x105260, 3, RI_ALL_ONLINE },
-	{ 0x10526c, 1, RI_ALL_OFFLINE }, { 0x105270, 3, RI_ALL_ONLINE },
-	{ 0x10527c, 1, RI_ALL_OFFLINE }, { 0x105280, 3, RI_ALL_ONLINE },
-	{ 0x10528c, 1, RI_ALL_OFFLINE }, { 0x105290, 3, RI_ALL_ONLINE },
-	{ 0x10529c, 1, RI_ALL_OFFLINE }, { 0x1052a0, 3, RI_ALL_ONLINE },
-	{ 0x1052ac, 1, RI_ALL_OFFLINE }, { 0x1052b0, 3, RI_ALL_ONLINE },
-	{ 0x1052bc, 1, RI_ALL_OFFLINE }, { 0x1052c0, 3, RI_ALL_ONLINE },
-	{ 0x1052cc, 1, RI_ALL_OFFLINE }, { 0x1052d0, 3, RI_ALL_ONLINE },
-	{ 0x1052dc, 1, RI_ALL_OFFLINE }, { 0x1052e0, 3, RI_ALL_ONLINE },
-	{ 0x1052ec, 1, RI_ALL_OFFLINE }, { 0x1052f0, 3, RI_ALL_ONLINE },
-	{ 0x1052fc, 1, RI_ALL_OFFLINE }, { 0x105300, 3, RI_ALL_ONLINE },
-	{ 0x10530c, 1, RI_ALL_OFFLINE }, { 0x105310, 3, RI_ALL_ONLINE },
-	{ 0x10531c, 1, RI_ALL_OFFLINE }, { 0x105320, 3, RI_ALL_ONLINE },
-	{ 0x10532c, 1, RI_ALL_OFFLINE }, { 0x105330, 3, RI_ALL_ONLINE },
-	{ 0x10533c, 1, RI_ALL_OFFLINE }, { 0x105340, 3, RI_ALL_ONLINE },
-	{ 0x10534c, 1, RI_ALL_OFFLINE }, { 0x105350, 3, RI_ALL_ONLINE },
-	{ 0x10535c, 1, RI_ALL_OFFLINE }, { 0x105360, 3, RI_ALL_ONLINE },
-	{ 0x10536c, 1, RI_ALL_OFFLINE }, { 0x105370, 3, RI_ALL_ONLINE },
-	{ 0x10537c, 1, RI_ALL_OFFLINE }, { 0x105380, 3, RI_ALL_ONLINE },
-	{ 0x10538c, 1, RI_ALL_OFFLINE }, { 0x105390, 3, RI_ALL_ONLINE },
-	{ 0x10539c, 1, RI_ALL_OFFLINE }, { 0x1053a0, 3, RI_ALL_ONLINE },
-	{ 0x1053ac, 1, RI_ALL_OFFLINE }, { 0x1053b0, 3, RI_ALL_ONLINE },
-	{ 0x1053bc, 1, RI_ALL_OFFLINE }, { 0x1053c0, 3, RI_ALL_ONLINE },
-	{ 0x1053cc, 1, RI_ALL_OFFLINE }, { 0x1053d0, 3, RI_ALL_ONLINE },
-	{ 0x1053dc, 1, RI_ALL_OFFLINE }, { 0x1053e0, 3, RI_ALL_ONLINE },
-	{ 0x1053ec, 1, RI_ALL_OFFLINE }, { 0x1053f0, 3, RI_ALL_ONLINE },
-	{ 0x1053fc, 769, RI_ALL_OFFLINE }, { 0x108000, 33, RI_ALL_ONLINE },
-	{ 0x108090, 1, RI_ALL_ONLINE }, { 0x1080a0, 1, RI_ALL_ONLINE },
-	{ 0x1080ac, 5, RI_E1H_ONLINE }, { 0x108100, 5, RI_ALL_ONLINE },
-	{ 0x108120, 5, RI_ALL_ONLINE }, { 0x108200, 74, RI_ALL_ONLINE },
-	{ 0x108400, 74, RI_ALL_ONLINE }, { 0x108800, 152, RI_ALL_ONLINE },
-	{ 0x109000, 1, RI_ALL_ONLINE }, { 0x120000, 347, RI_ALL_ONLINE },
-	{ 0x120578, 1, RI_ALL_ONLINE }, { 0x120588, 1, RI_ALL_ONLINE },
-	{ 0x120598, 1, RI_ALL_ONLINE }, { 0x12059c, 23, RI_E1H_ONLINE },
-	{ 0x120614, 1, RI_E1H_ONLINE }, { 0x12061c, 30, RI_E1H_ONLINE },
-	{ 0x12080c, 65, RI_ALL_ONLINE }, { 0x120a00, 2, RI_ALL_ONLINE },
-	{ 0x122000, 2, RI_ALL_ONLINE }, { 0x128000, 2, RI_E1H_ONLINE },
-	{ 0x140000, 114, RI_ALL_ONLINE }, { 0x1401d4, 1, RI_ALL_ONLINE },
-	{ 0x1401e4, 1, RI_ALL_ONLINE }, { 0x140200, 6, RI_ALL_ONLINE },
-	{ 0x144000, 4, RI_ALL_ONLINE }, { 0x148000, 4, RI_ALL_ONLINE },
-	{ 0x14c000, 4, RI_ALL_ONLINE }, { 0x150000, 4, RI_ALL_ONLINE },
-	{ 0x154000, 4, RI_ALL_ONLINE }, { 0x158000, 4, RI_ALL_ONLINE },
-	{ 0x15c000, 7, RI_E1H_ONLINE }, { 0x161000, 7, RI_ALL_ONLINE },
-	{ 0x161028, 1, RI_ALL_ONLINE }, { 0x161038, 1, RI_ALL_ONLINE },
-	{ 0x161800, 2, RI_ALL_ONLINE }, { 0x164000, 60, RI_ALL_ONLINE },
-	{ 0x1640fc, 1, RI_ALL_ONLINE }, { 0x16410c, 1, RI_ALL_ONLINE },
-	{ 0x164110, 2, RI_E1H_ONLINE }, { 0x164200, 1, RI_ALL_ONLINE },
-	{ 0x164208, 1, RI_ALL_ONLINE }, { 0x164210, 1, RI_ALL_ONLINE },
-	{ 0x164218, 1, RI_ALL_ONLINE }, { 0x164220, 1, RI_ALL_ONLINE },
-	{ 0x164228, 1, RI_ALL_ONLINE }, { 0x164230, 1, RI_ALL_ONLINE },
-	{ 0x164238, 1, RI_ALL_ONLINE }, { 0x164240, 1, RI_ALL_ONLINE },
-	{ 0x164248, 1, RI_ALL_ONLINE }, { 0x164250, 1, RI_ALL_ONLINE },
-	{ 0x164258, 1, RI_ALL_ONLINE }, { 0x164260, 1, RI_ALL_ONLINE },
-	{ 0x164270, 2, RI_ALL_ONLINE }, { 0x164280, 2, RI_ALL_ONLINE },
-	{ 0x164800, 2, RI_ALL_ONLINE }, { 0x165000, 2, RI_ALL_ONLINE },
-	{ 0x166000, 164, RI_ALL_ONLINE }, { 0x16629c, 1, RI_ALL_ONLINE },
-	{ 0x1662ac, 1, RI_ALL_ONLINE }, { 0x1662bc, 1, RI_ALL_ONLINE },
-	{ 0x166400, 49, RI_ALL_ONLINE }, { 0x1664c8, 38, RI_ALL_ONLINE },
-	{ 0x166568, 2, RI_ALL_ONLINE }, { 0x166800, 1, RI_ALL_ONLINE },
-	{ 0x168000, 270, RI_ALL_ONLINE }, { 0x168444, 1, RI_ALL_ONLINE },
-	{ 0x168454, 1, RI_ALL_ONLINE }, { 0x168800, 19, RI_ALL_ONLINE },
-	{ 0x168900, 1, RI_ALL_ONLINE }, { 0x168a00, 128, RI_ALL_ONLINE },
-	{ 0x16a000, 1, RI_ALL_ONLINE }, { 0x16a004, 1535, RI_ALL_OFFLINE },
-	{ 0x16c000, 1, RI_ALL_ONLINE }, { 0x16c004, 1535, RI_ALL_OFFLINE },
-	{ 0x16e000, 16, RI_E1H_ONLINE }, { 0x16e100, 1, RI_E1H_ONLINE },
-	{ 0x16e200, 2, RI_E1H_ONLINE }, { 0x16e400, 183, RI_E1H_ONLINE },
-	{ 0x170000, 93, RI_ALL_ONLINE }, { 0x170180, 1, RI_ALL_ONLINE },
-	{ 0x170190, 1, RI_ALL_ONLINE }, { 0x170200, 4, RI_ALL_ONLINE },
-	{ 0x170214, 1, RI_ALL_ONLINE }, { 0x178000, 1, RI_ALL_ONLINE },
-	{ 0x180000, 61, RI_ALL_ONLINE }, { 0x180100, 1, RI_ALL_ONLINE },
-	{ 0x180110, 1, RI_ALL_ONLINE }, { 0x180120, 1, RI_ALL_ONLINE },
-	{ 0x180130, 1, RI_ALL_ONLINE }, { 0x18013c, 2, RI_E1H_ONLINE },
-	{ 0x180200, 58, RI_ALL_ONLINE }, { 0x180340, 4, RI_ALL_ONLINE },
-	{ 0x180400, 1, RI_ALL_ONLINE }, { 0x180404, 255, RI_ALL_OFFLINE },
-	{ 0x181000, 4, RI_ALL_ONLINE }, { 0x181010, 1020, RI_ALL_OFFLINE },
-	{ 0x1a0000, 1, RI_ALL_ONLINE }, { 0x1a0004, 1023, RI_ALL_OFFLINE },
-	{ 0x1a1000, 1, RI_ALL_ONLINE }, { 0x1a1004, 4607, RI_ALL_OFFLINE },
-	{ 0x1a5800, 2560, RI_E1H_OFFLINE }, { 0x1a8000, 64, RI_ALL_OFFLINE },
-	{ 0x1a8100, 1984, RI_E1H_OFFLINE }, { 0x1aa000, 1, RI_E1H_ONLINE },
-	{ 0x1aa004, 6655, RI_E1H_OFFLINE }, { 0x1b1800, 128, RI_ALL_OFFLINE },
-	{ 0x1b1c00, 128, RI_ALL_OFFLINE }, { 0x1b2000, 1, RI_ALL_OFFLINE },
-	{ 0x1b2400, 64, RI_E1H_OFFLINE }, { 0x1b8200, 1, RI_ALL_ONLINE },
-	{ 0x1b8240, 1, RI_ALL_ONLINE }, { 0x1b8280, 1, RI_ALL_ONLINE },
-	{ 0x1b82c0, 1, RI_ALL_ONLINE }, { 0x1b8a00, 1, RI_ALL_ONLINE },
-	{ 0x1b8a80, 1, RI_ALL_ONLINE }, { 0x1c0000, 2, RI_ALL_ONLINE },
-	{ 0x200000, 65, RI_ALL_ONLINE }, { 0x200110, 1, RI_ALL_ONLINE },
-	{ 0x200120, 1, RI_ALL_ONLINE }, { 0x200130, 1, RI_ALL_ONLINE },
-	{ 0x200140, 1, RI_ALL_ONLINE }, { 0x20014c, 2, RI_E1H_ONLINE },
-	{ 0x200200, 58, RI_ALL_ONLINE }, { 0x200340, 4, RI_ALL_ONLINE },
-	{ 0x200400, 1, RI_ALL_ONLINE }, { 0x200404, 255, RI_ALL_OFFLINE },
-	{ 0x202000, 4, RI_ALL_ONLINE }, { 0x202010, 2044, RI_ALL_OFFLINE },
-	{ 0x220000, 1, RI_ALL_ONLINE }, { 0x220004, 1023, RI_ALL_OFFLINE },
-	{ 0x221000, 1, RI_ALL_ONLINE }, { 0x221004, 4607, RI_ALL_OFFLINE },
-	{ 0x225800, 1536, RI_E1H_OFFLINE }, { 0x227000, 1, RI_E1H_ONLINE },
-	{ 0x227004, 1023, RI_E1H_OFFLINE }, { 0x228000, 64, RI_ALL_OFFLINE },
-	{ 0x228100, 8640, RI_E1H_OFFLINE }, { 0x231800, 128, RI_ALL_OFFLINE },
-	{ 0x231c00, 128, RI_ALL_OFFLINE }, { 0x232000, 1, RI_ALL_OFFLINE },
-	{ 0x232400, 64, RI_E1H_OFFLINE }, { 0x238200, 1, RI_ALL_ONLINE },
-	{ 0x238240, 1, RI_ALL_ONLINE }, { 0x238280, 1, RI_ALL_ONLINE },
-	{ 0x2382c0, 1, RI_ALL_ONLINE }, { 0x238a00, 1, RI_ALL_ONLINE },
-	{ 0x238a80, 1, RI_ALL_ONLINE }, { 0x240000, 2, RI_ALL_ONLINE },
-	{ 0x280000, 65, RI_ALL_ONLINE }, { 0x280110, 1, RI_ALL_ONLINE },
-	{ 0x280120, 1, RI_ALL_ONLINE }, { 0x280130, 1, RI_ALL_ONLINE },
-	{ 0x280140, 1, RI_ALL_ONLINE }, { 0x28014c, 2, RI_E1H_ONLINE },
-	{ 0x280200, 58, RI_ALL_ONLINE }, { 0x280340, 4, RI_ALL_ONLINE },
-	{ 0x280400, 1, RI_ALL_ONLINE }, { 0x280404, 255, RI_ALL_OFFLINE },
-	{ 0x282000, 4, RI_ALL_ONLINE }, { 0x282010, 2044, RI_ALL_OFFLINE },
-	{ 0x2a0000, 1, RI_ALL_ONLINE }, { 0x2a0004, 1023, RI_ALL_OFFLINE },
-	{ 0x2a1000, 1, RI_ALL_ONLINE }, { 0x2a1004, 4607, RI_ALL_OFFLINE },
-	{ 0x2a5800, 2560, RI_E1H_OFFLINE }, { 0x2a8000, 64, RI_ALL_OFFLINE },
-	{ 0x2a8100, 960, RI_E1H_OFFLINE }, { 0x2a9000, 1, RI_E1H_ONLINE },
-	{ 0x2a9004, 7679, RI_E1H_OFFLINE }, { 0x2b1800, 128, RI_ALL_OFFLINE },
-	{ 0x2b1c00, 128, RI_ALL_OFFLINE }, { 0x2b2000, 1, RI_ALL_OFFLINE },
-	{ 0x2b2400, 64, RI_E1H_OFFLINE }, { 0x2b8200, 1, RI_ALL_ONLINE },
-	{ 0x2b8240, 1, RI_ALL_ONLINE }, { 0x2b8280, 1, RI_ALL_ONLINE },
-	{ 0x2b82c0, 1, RI_ALL_ONLINE }, { 0x2b8a00, 1, RI_ALL_ONLINE },
-	{ 0x2b8a80, 1, RI_ALL_ONLINE }, { 0x2c0000, 2, RI_ALL_ONLINE },
-	{ 0x300000, 65, RI_ALL_ONLINE }, { 0x300110, 1, RI_ALL_ONLINE },
-	{ 0x300120, 1, RI_ALL_ONLINE }, { 0x300130, 1, RI_ALL_ONLINE },
-	{ 0x300140, 1, RI_ALL_ONLINE }, { 0x30014c, 2, RI_E1H_ONLINE },
-	{ 0x300200, 58, RI_ALL_ONLINE }, { 0x300340, 4, RI_ALL_ONLINE },
-	{ 0x300400, 1, RI_ALL_ONLINE }, { 0x300404, 255, RI_ALL_OFFLINE },
-	{ 0x302000, 4, RI_ALL_ONLINE }, { 0x302010, 2044, RI_ALL_OFFLINE },
-	{ 0x320000, 1, RI_ALL_ONLINE }, { 0x320004, 1023, RI_ALL_OFFLINE },
-	{ 0x321000, 1, RI_ALL_ONLINE }, { 0x321004, 4607, RI_ALL_OFFLINE },
-	{ 0x325800, 2560, RI_E1H_OFFLINE }, { 0x328000, 64, RI_ALL_OFFLINE },
-	{ 0x328100, 536, RI_E1H_OFFLINE }, { 0x328960, 1, RI_E1H_ONLINE },
-	{ 0x328964, 8103, RI_E1H_OFFLINE }, { 0x331800, 128, RI_ALL_OFFLINE },
-	{ 0x331c00, 128, RI_ALL_OFFLINE }, { 0x332000, 1, RI_ALL_OFFLINE },
-	{ 0x332400, 64, RI_E1H_OFFLINE }, { 0x338200, 1, RI_ALL_ONLINE },
-	{ 0x338240, 1, RI_ALL_ONLINE }, { 0x338280, 1, RI_ALL_ONLINE },
-	{ 0x3382c0, 1, RI_ALL_ONLINE }, { 0x338a00, 1, RI_ALL_ONLINE },
-	{ 0x338a80, 1, RI_ALL_ONLINE }, { 0x340000, 2, RI_ALL_ONLINE }
-};
-
-
-#define IDLE_REGS_COUNT			277
-static const struct reg_addr idle_addrs[IDLE_REGS_COUNT] = {
-	{ 0x2114, 1, RI_ALL_ONLINE }, { 0x2120, 1, RI_ALL_ONLINE },
-	{ 0x212c, 4, RI_ALL_ONLINE }, { 0x2814, 1, RI_ALL_ONLINE },
-	{ 0x281c, 2, RI_ALL_ONLINE }, { 0xa38c, 1, RI_ALL_ONLINE },
-	{ 0xa408, 1, RI_ALL_ONLINE }, { 0xa42c, 12, RI_ALL_ONLINE },
-	{ 0xa600, 5, RI_E1H_ONLINE }, { 0xa618, 1, RI_E1H_ONLINE },
-	{ 0xc09c, 1, RI_ALL_ONLINE }, { 0x103b0, 1, RI_ALL_ONLINE },
-	{ 0x103c0, 1, RI_ALL_ONLINE }, { 0x103d0, 1, RI_E1H_ONLINE },
-	{ 0x2021c, 11, RI_ALL_ONLINE }, { 0x202a8, 1, RI_ALL_ONLINE },
-	{ 0x202b8, 1, RI_ALL_ONLINE }, { 0x20404, 1, RI_ALL_ONLINE },
-	{ 0x2040c, 2, RI_ALL_ONLINE }, { 0x2041c, 2, RI_ALL_ONLINE },
-	{ 0x40154, 14, RI_ALL_ONLINE }, { 0x40198, 1, RI_ALL_ONLINE },
-	{ 0x404ac, 1, RI_ALL_ONLINE }, { 0x404bc, 1, RI_ALL_ONLINE },
-	{ 0x42290, 1, RI_ALL_ONLINE }, { 0x422a0, 1, RI_ALL_ONLINE },
-	{ 0x422b0, 1, RI_ALL_ONLINE }, { 0x42548, 1, RI_ALL_ONLINE },
-	{ 0x42550, 1, RI_ALL_ONLINE }, { 0x42558, 1, RI_ALL_ONLINE },
-	{ 0x50160, 8, RI_ALL_ONLINE }, { 0x501d0, 1, RI_ALL_ONLINE },
-	{ 0x501e0, 1, RI_ALL_ONLINE }, { 0x50204, 1, RI_ALL_ONLINE },
-	{ 0x5020c, 2, RI_ALL_ONLINE }, { 0x5021c, 1, RI_ALL_ONLINE },
-	{ 0x60090, 1, RI_ALL_ONLINE }, { 0x6011c, 1, RI_ALL_ONLINE },
-	{ 0x6012c, 1, RI_ALL_ONLINE }, { 0xc101c, 1, RI_ALL_ONLINE },
-	{ 0xc102c, 1, RI_ALL_ONLINE }, { 0xc2290, 1, RI_ALL_ONLINE },
-	{ 0xc22a0, 1, RI_ALL_ONLINE }, { 0xc22b0, 1, RI_ALL_ONLINE },
-	{ 0xc2548, 1, RI_ALL_ONLINE }, { 0xc2550, 1, RI_ALL_ONLINE },
-	{ 0xc2558, 1, RI_ALL_ONLINE }, { 0xc4294, 1, RI_ALL_ONLINE },
-	{ 0xc42a4, 1, RI_ALL_ONLINE }, { 0xc42b4, 1, RI_ALL_ONLINE },
-	{ 0xc4550, 1, RI_ALL_ONLINE }, { 0xc4558, 1, RI_ALL_ONLINE },
-	{ 0xc4560, 1, RI_ALL_ONLINE }, { 0xd016c, 8, RI_ALL_ONLINE },
-	{ 0xd01d8, 1, RI_ALL_ONLINE }, { 0xd01e8, 1, RI_ALL_ONLINE },
-	{ 0xd0204, 1, RI_ALL_ONLINE }, { 0xd020c, 3, RI_ALL_ONLINE },
-	{ 0xe0154, 8, RI_ALL_ONLINE }, { 0xe01c8, 1, RI_ALL_ONLINE },
-	{ 0xe01d8, 1, RI_ALL_ONLINE }, { 0xe0204, 1, RI_ALL_ONLINE },
-	{ 0xe020c, 2, RI_ALL_ONLINE }, { 0xe021c, 2, RI_ALL_ONLINE },
-	{ 0x101014, 1, RI_ALL_ONLINE }, { 0x101030, 1, RI_ALL_ONLINE },
-	{ 0x101040, 1, RI_ALL_ONLINE }, { 0x102058, 1, RI_ALL_ONLINE },
-	{ 0x102080, 16, RI_ALL_ONLINE }, { 0x103004, 2, RI_ALL_ONLINE },
-	{ 0x103068, 1, RI_ALL_ONLINE }, { 0x103078, 1, RI_ALL_ONLINE },
-	{ 0x103088, 1, RI_ALL_ONLINE }, { 0x10309c, 2, RI_E1H_ONLINE },
-	{ 0x104004, 1, RI_ALL_ONLINE }, { 0x104018, 1, RI_ALL_ONLINE },
-	{ 0x104020, 1, RI_ALL_ONLINE }, { 0x10403c, 1, RI_ALL_ONLINE },
-	{ 0x1040fc, 1, RI_ALL_ONLINE }, { 0x10410c, 1, RI_ALL_ONLINE },
-	{ 0x104400, 64, RI_ALL_ONLINE }, { 0x104800, 64, RI_ALL_ONLINE },
-	{ 0x105000, 3, RI_ALL_ONLINE }, { 0x105010, 3, RI_ALL_ONLINE },
-	{ 0x105020, 3, RI_ALL_ONLINE }, { 0x105030, 3, RI_ALL_ONLINE },
-	{ 0x105040, 3, RI_ALL_ONLINE }, { 0x105050, 3, RI_ALL_ONLINE },
-	{ 0x105060, 3, RI_ALL_ONLINE }, { 0x105070, 3, RI_ALL_ONLINE },
-	{ 0x105080, 3, RI_ALL_ONLINE }, { 0x105090, 3, RI_ALL_ONLINE },
-	{ 0x1050a0, 3, RI_ALL_ONLINE }, { 0x1050b0, 3, RI_ALL_ONLINE },
-	{ 0x1050c0, 3, RI_ALL_ONLINE }, { 0x1050d0, 3, RI_ALL_ONLINE },
-	{ 0x1050e0, 3, RI_ALL_ONLINE }, { 0x1050f0, 3, RI_ALL_ONLINE },
-	{ 0x105100, 3, RI_ALL_ONLINE }, { 0x105110, 3, RI_ALL_ONLINE },
-	{ 0x105120, 3, RI_ALL_ONLINE }, { 0x105130, 3, RI_ALL_ONLINE },
-	{ 0x105140, 3, RI_ALL_ONLINE }, { 0x105150, 3, RI_ALL_ONLINE },
-	{ 0x105160, 3, RI_ALL_ONLINE }, { 0x105170, 3, RI_ALL_ONLINE },
-	{ 0x105180, 3, RI_ALL_ONLINE }, { 0x105190, 3, RI_ALL_ONLINE },
-	{ 0x1051a0, 3, RI_ALL_ONLINE }, { 0x1051b0, 3, RI_ALL_ONLINE },
-	{ 0x1051c0, 3, RI_ALL_ONLINE }, { 0x1051d0, 3, RI_ALL_ONLINE },
-	{ 0x1051e0, 3, RI_ALL_ONLINE }, { 0x1051f0, 3, RI_ALL_ONLINE },
-	{ 0x105200, 3, RI_ALL_ONLINE }, { 0x105210, 3, RI_ALL_ONLINE },
-	{ 0x105220, 3, RI_ALL_ONLINE }, { 0x105230, 3, RI_ALL_ONLINE },
-	{ 0x105240, 3, RI_ALL_ONLINE }, { 0x105250, 3, RI_ALL_ONLINE },
-	{ 0x105260, 3, RI_ALL_ONLINE }, { 0x105270, 3, RI_ALL_ONLINE },
-	{ 0x105280, 3, RI_ALL_ONLINE }, { 0x105290, 3, RI_ALL_ONLINE },
-	{ 0x1052a0, 3, RI_ALL_ONLINE }, { 0x1052b0, 3, RI_ALL_ONLINE },
-	{ 0x1052c0, 3, RI_ALL_ONLINE }, { 0x1052d0, 3, RI_ALL_ONLINE },
-	{ 0x1052e0, 3, RI_ALL_ONLINE }, { 0x1052f0, 3, RI_ALL_ONLINE },
-	{ 0x105300, 3, RI_ALL_ONLINE }, { 0x105310, 3, RI_ALL_ONLINE },
-	{ 0x105320, 3, RI_ALL_ONLINE }, { 0x105330, 3, RI_ALL_ONLINE },
-	{ 0x105340, 3, RI_ALL_ONLINE }, { 0x105350, 3, RI_ALL_ONLINE },
-	{ 0x105360, 3, RI_ALL_ONLINE }, { 0x105370, 3, RI_ALL_ONLINE },
-	{ 0x105380, 3, RI_ALL_ONLINE }, { 0x105390, 3, RI_ALL_ONLINE },
-	{ 0x1053a0, 3, RI_ALL_ONLINE }, { 0x1053b0, 3, RI_ALL_ONLINE },
-	{ 0x1053c0, 3, RI_ALL_ONLINE }, { 0x1053d0, 3, RI_ALL_ONLINE },
-	{ 0x1053e0, 3, RI_ALL_ONLINE }, { 0x1053f0, 3, RI_ALL_ONLINE },
-	{ 0x108094, 1, RI_ALL_ONLINE }, { 0x1201b0, 2, RI_ALL_ONLINE },
-	{ 0x12032c, 1, RI_ALL_ONLINE }, { 0x12036c, 3, RI_ALL_ONLINE },
-	{ 0x120408, 2, RI_ALL_ONLINE }, { 0x120414, 15, RI_ALL_ONLINE },
-	{ 0x120478, 2, RI_ALL_ONLINE }, { 0x12052c, 1, RI_ALL_ONLINE },
-	{ 0x120564, 3, RI_ALL_ONLINE }, { 0x12057c, 1, RI_ALL_ONLINE },
-	{ 0x12058c, 1, RI_ALL_ONLINE }, { 0x120608, 1, RI_E1H_ONLINE },
-	{ 0x120808, 1, RI_E1_ONLINE }, { 0x12080c, 2, RI_ALL_ONLINE },
-	{ 0x120818, 1, RI_ALL_ONLINE }, { 0x120820, 1, RI_ALL_ONLINE },
-	{ 0x120828, 1, RI_ALL_ONLINE }, { 0x120830, 1, RI_ALL_ONLINE },
-	{ 0x120838, 1, RI_ALL_ONLINE }, { 0x120840, 1, RI_ALL_ONLINE },
-	{ 0x120848, 1, RI_ALL_ONLINE }, { 0x120850, 1, RI_ALL_ONLINE },
-	{ 0x120858, 1, RI_ALL_ONLINE }, { 0x120860, 1, RI_ALL_ONLINE },
-	{ 0x120868, 1, RI_ALL_ONLINE }, { 0x120870, 1, RI_ALL_ONLINE },
-	{ 0x120878, 1, RI_ALL_ONLINE }, { 0x120880, 1, RI_ALL_ONLINE },
-	{ 0x120888, 1, RI_ALL_ONLINE }, { 0x120890, 1, RI_ALL_ONLINE },
-	{ 0x120898, 1, RI_ALL_ONLINE }, { 0x1208a0, 1, RI_ALL_ONLINE },
-	{ 0x1208a8, 1, RI_ALL_ONLINE }, { 0x1208b0, 1, RI_ALL_ONLINE },
-	{ 0x1208b8, 1, RI_ALL_ONLINE }, { 0x1208c0, 1, RI_ALL_ONLINE },
-	{ 0x1208c8, 1, RI_ALL_ONLINE }, { 0x1208d0, 1, RI_ALL_ONLINE },
-	{ 0x1208d8, 1, RI_ALL_ONLINE }, { 0x1208e0, 1, RI_ALL_ONLINE },
-	{ 0x1208e8, 1, RI_ALL_ONLINE }, { 0x1208f0, 1, RI_ALL_ONLINE },
-	{ 0x1208f8, 1, RI_ALL_ONLINE }, { 0x120900, 1, RI_ALL_ONLINE },
-	{ 0x120908, 1, RI_ALL_ONLINE }, { 0x14005c, 2, RI_ALL_ONLINE },
-	{ 0x1400d0, 2, RI_ALL_ONLINE }, { 0x1400e0, 1, RI_ALL_ONLINE },
-	{ 0x1401c8, 1, RI_ALL_ONLINE }, { 0x140200, 6, RI_ALL_ONLINE },
-	{ 0x16101c, 1, RI_ALL_ONLINE }, { 0x16102c, 1, RI_ALL_ONLINE },
-	{ 0x164014, 2, RI_ALL_ONLINE }, { 0x1640f0, 1, RI_ALL_ONLINE },
-	{ 0x166290, 1, RI_ALL_ONLINE }, { 0x1662a0, 1, RI_ALL_ONLINE },
-	{ 0x1662b0, 1, RI_ALL_ONLINE }, { 0x166548, 1, RI_ALL_ONLINE },
-	{ 0x166550, 1, RI_ALL_ONLINE }, { 0x166558, 1, RI_ALL_ONLINE },
-	{ 0x168000, 1, RI_ALL_ONLINE }, { 0x168008, 1, RI_ALL_ONLINE },
-	{ 0x168010, 1, RI_ALL_ONLINE }, { 0x168018, 1, RI_ALL_ONLINE },
-	{ 0x168028, 2, RI_ALL_ONLINE }, { 0x168058, 4, RI_ALL_ONLINE },
-	{ 0x168070, 1, RI_ALL_ONLINE }, { 0x168238, 1, RI_ALL_ONLINE },
-	{ 0x1682d0, 2, RI_ALL_ONLINE }, { 0x1682e0, 1, RI_ALL_ONLINE },
-	{ 0x168300, 67, RI_ALL_ONLINE }, { 0x168410, 2, RI_ALL_ONLINE },
-	{ 0x168438, 1, RI_ALL_ONLINE }, { 0x168448, 1, RI_ALL_ONLINE },
-	{ 0x168a00, 128, RI_ALL_ONLINE }, { 0x16e200, 128, RI_E1H_ONLINE },
-	{ 0x16e404, 2, RI_E1H_ONLINE }, { 0x16e584, 70, RI_E1H_ONLINE },
-	{ 0x1700a4, 1, RI_ALL_ONLINE }, { 0x1700ac, 2, RI_ALL_ONLINE },
-	{ 0x1700c0, 1, RI_ALL_ONLINE }, { 0x170174, 1, RI_ALL_ONLINE },
-	{ 0x170184, 1, RI_ALL_ONLINE }, { 0x1800f4, 1, RI_ALL_ONLINE },
-	{ 0x180104, 1, RI_ALL_ONLINE }, { 0x180114, 1, RI_ALL_ONLINE },
-	{ 0x180124, 1, RI_ALL_ONLINE }, { 0x18026c, 1, RI_ALL_ONLINE },
-	{ 0x1802a0, 1, RI_ALL_ONLINE }, { 0x1a1000, 1, RI_ALL_ONLINE },
-	{ 0x1aa000, 1, RI_E1H_ONLINE }, { 0x1b8000, 1, RI_ALL_ONLINE },
-	{ 0x1b8040, 1, RI_ALL_ONLINE }, { 0x1b8080, 1, RI_ALL_ONLINE },
-	{ 0x1b80c0, 1, RI_ALL_ONLINE }, { 0x200104, 1, RI_ALL_ONLINE },
-	{ 0x200114, 1, RI_ALL_ONLINE }, { 0x200124, 1, RI_ALL_ONLINE },
-	{ 0x200134, 1, RI_ALL_ONLINE }, { 0x20026c, 1, RI_ALL_ONLINE },
-	{ 0x2002a0, 1, RI_ALL_ONLINE }, { 0x221000, 1, RI_ALL_ONLINE },
-	{ 0x227000, 1, RI_E1H_ONLINE }, { 0x238000, 1, RI_ALL_ONLINE },
-	{ 0x238040, 1, RI_ALL_ONLINE }, { 0x238080, 1, RI_ALL_ONLINE },
-	{ 0x2380c0, 1, RI_ALL_ONLINE }, { 0x280104, 1, RI_ALL_ONLINE },
-	{ 0x280114, 1, RI_ALL_ONLINE }, { 0x280124, 1, RI_ALL_ONLINE },
-	{ 0x280134, 1, RI_ALL_ONLINE }, { 0x28026c, 1, RI_ALL_ONLINE },
-	{ 0x2802a0, 1, RI_ALL_ONLINE }, { 0x2a1000, 1, RI_ALL_ONLINE },
-	{ 0x2a9000, 1, RI_E1H_ONLINE }, { 0x2b8000, 1, RI_ALL_ONLINE },
-	{ 0x2b8040, 1, RI_ALL_ONLINE }, { 0x2b8080, 1, RI_ALL_ONLINE },
-	{ 0x2b80c0, 1, RI_ALL_ONLINE }, { 0x300104, 1, RI_ALL_ONLINE },
-	{ 0x300114, 1, RI_ALL_ONLINE }, { 0x300124, 1, RI_ALL_ONLINE },
-	{ 0x300134, 1, RI_ALL_ONLINE }, { 0x30026c, 1, RI_ALL_ONLINE },
-	{ 0x3002a0, 1, RI_ALL_ONLINE }, { 0x321000, 1, RI_ALL_ONLINE },
-	{ 0x328960, 1, RI_E1H_ONLINE }, { 0x338000, 1, RI_ALL_ONLINE },
-	{ 0x338040, 1, RI_ALL_ONLINE }, { 0x338080, 1, RI_ALL_ONLINE },
-	{ 0x3380c0, 1, RI_ALL_ONLINE }
-};
-
-#define WREGS_COUNT_E1			1
-static const u32 read_reg_e1_0[] = { 0x1b1000 };
-
-static const struct wreg_addr wreg_addrs_e1[WREGS_COUNT_E1] = {
-	{ 0x1b0c00, 192, 1, read_reg_e1_0, RI_E1_OFFLINE }
-};
-
-
-#define WREGS_COUNT_E1H			1
-static const u32 read_reg_e1h_0[] = { 0x1b1040, 0x1b1000 };
-
-static const struct wreg_addr wreg_addrs_e1h[WREGS_COUNT_E1H] = {
-	{ 0x1b0c00, 256, 2, read_reg_e1h_0, RI_E1H_OFFLINE }
-};
-
-
-static const struct dump_sign dump_sign_all = { 0x49aa93ee, 0x40835, 0x22 };
-
-
-#define TIMER_REGS_COUNT_E1		2
-static const u32 timer_status_regs_e1[TIMER_REGS_COUNT_E1] =
-	{ 0x164014, 0x164018 };
-static const u32 timer_scan_regs_e1[TIMER_REGS_COUNT_E1] =
-	{ 0x1640d0, 0x1640d4 };
-
-
-#define TIMER_REGS_COUNT_E1H		2
-static const u32 timer_status_regs_e1h[TIMER_REGS_COUNT_E1H] =
-	{ 0x164014, 0x164018 };
-static const u32 timer_scan_regs_e1h[TIMER_REGS_COUNT_E1H] =
-	{ 0x1640d0, 0x1640d4 };
-
-
-#endif /* BNX2X_DUMP_H */
diff -r f4bf81a7ff20 drivers/net/bnx2x_fw_defs.h
--- a/drivers/net/bnx2x_fw_defs.h
+++ /dev/null
@@ -1,594 +0,0 @@
-/* bnx2x_fw_defs.h: Broadcom Everest network driver.
- *
- * Copyright (c) 2007-2010 Broadcom Corporation
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation.
- */
-
-
-#define CSTORM_ASSERT_LIST_INDEX_OFFSET \
-	(IS_E1H_OFFSET ? 0x7000 : 0x1000)
-#define CSTORM_ASSERT_LIST_OFFSET(idx) \
-	(IS_E1H_OFFSET ? (0x7020 + (idx * 0x10)) : (0x1020 + (idx * 0x10)))
-#define CSTORM_DEF_SB_HC_DISABLE_C_OFFSET(function, index) \
-	(IS_E1H_OFFSET ? (0x8622 + ((function>>1) * 0x40) + \
-	((function&1) * 0x100) + (index * 0x4)) : (0x3562 + (function * \
-	0x40) + (index * 0x4)))
-#define CSTORM_DEF_SB_HC_DISABLE_U_OFFSET(function, index) \
-	(IS_E1H_OFFSET ? (0x8822 + ((function>>1) * 0x80) + \
-	((function&1) * 0x200) + (index * 0x4)) : (0x35e2 + (function * \
-	0x80) + (index * 0x4)))
-#define CSTORM_DEF_SB_HOST_SB_ADDR_C_OFFSET(function) \
-	(IS_E1H_OFFSET ? (0x8600 + ((function>>1) * 0x40) + \
-	((function&1) * 0x100)) : (0x3540 + (function * 0x40)))
-#define CSTORM_DEF_SB_HOST_SB_ADDR_U_OFFSET(function) \
-	(IS_E1H_OFFSET ? (0x8800 + ((function>>1) * 0x80) + \
-	((function&1) * 0x200)) : (0x35c0 + (function * 0x80)))
-#define CSTORM_DEF_SB_HOST_STATUS_BLOCK_C_OFFSET(function) \
-	(IS_E1H_OFFSET ? (0x8608 + ((function>>1) * 0x40) + \
-	((function&1) * 0x100)) : (0x3548 + (function * 0x40)))
-#define CSTORM_DEF_SB_HOST_STATUS_BLOCK_U_OFFSET(function) \
-	(IS_E1H_OFFSET ? (0x8808 + ((function>>1) * 0x80) + \
-	((function&1) * 0x200)) : (0x35c8 + (function * 0x80)))
-#define CSTORM_FUNCTION_MODE_OFFSET \
-	(IS_E1H_OFFSET ? 0x11e8 : 0xffffffff)
-#define CSTORM_HC_BTR_C_OFFSET(port) \
-	(IS_E1H_OFFSET ? (0x8c04 + (port * 0xf0)) : (0x36c4 + (port * 0xc0)))
-#define CSTORM_HC_BTR_U_OFFSET(port) \
-	(IS_E1H_OFFSET ? (0x8de4 + (port * 0xf0)) : (0x3844 + (port * 0xc0)))
-#define CSTORM_ISCSI_CQ_SIZE_OFFSET(function) \
-	(IS_E1H_OFFSET ? (0x6680 + (function * 0x8)) : (0x25a0 + \
-	(function * 0x8)))
-#define CSTORM_ISCSI_CQ_SQN_SIZE_OFFSET(function) \
-	(IS_E1H_OFFSET ? (0x66c0 + (function * 0x8)) : (0x25b0 + \
-	(function * 0x8)))
-#define CSTORM_ISCSI_EQ_CONS_OFFSET(function, eqIdx) \
-	(IS_E1H_OFFSET ? (0x6040 + (function * 0xc0) + (eqIdx * 0x18)) : \
-	(0x2410 + (function * 0xc0) + (eqIdx * 0x18)))
-#define CSTORM_ISCSI_EQ_NEXT_EQE_ADDR_OFFSET(function, eqIdx) \
-	(IS_E1H_OFFSET ? (0x6044 + (function * 0xc0) + (eqIdx * 0x18)) : \
-	(0x2414 + (function * 0xc0) + (eqIdx * 0x18)))
-#define CSTORM_ISCSI_EQ_NEXT_PAGE_ADDR_OFFSET(function, eqIdx) \
-	(IS_E1H_OFFSET ? (0x604c + (function * 0xc0) + (eqIdx * 0x18)) : \
-	(0x241c + (function * 0xc0) + (eqIdx * 0x18)))
-#define CSTORM_ISCSI_EQ_NEXT_PAGE_ADDR_VALID_OFFSET(function, eqIdx) \
-	(IS_E1H_OFFSET ? (0x6057 + (function * 0xc0) + (eqIdx * 0x18)) : \
-	(0x2427 + (function * 0xc0) + (eqIdx * 0x18)))
-#define CSTORM_ISCSI_EQ_PROD_OFFSET(function, eqIdx) \
-	(IS_E1H_OFFSET ? (0x6042 + (function * 0xc0) + (eqIdx * 0x18)) : \
-	(0x2412 + (function * 0xc0) + (eqIdx * 0x18)))
-#define CSTORM_ISCSI_EQ_SB_INDEX_OFFSET(function, eqIdx) \
-	(IS_E1H_OFFSET ? (0x6056 + (function * 0xc0) + (eqIdx * 0x18)) : \
-	(0x2426 + (function * 0xc0) + (eqIdx * 0x18)))
-#define CSTORM_ISCSI_EQ_SB_NUM_OFFSET(function, eqIdx) \
-	(IS_E1H_OFFSET ? (0x6054 + (function * 0xc0) + (eqIdx * 0x18)) : \
-	(0x2424 + (function * 0xc0) + (eqIdx * 0x18)))
-#define CSTORM_ISCSI_HQ_SIZE_OFFSET(function) \
-	(IS_E1H_OFFSET ? (0x6640 + (function * 0x8)) : (0x2590 + \
-	(function * 0x8)))
-#define CSTORM_ISCSI_NUM_OF_TASKS_OFFSET(function) \
-	(IS_E1H_OFFSET ? (0x6004 + (function * 0x8)) : (0x2404 + \
-	(function * 0x8)))
-#define CSTORM_ISCSI_PAGE_SIZE_LOG_OFFSET(function) \
-	(IS_E1H_OFFSET ? (0x6002 + (function * 0x8)) : (0x2402 + \
-	(function * 0x8)))
-#define CSTORM_ISCSI_PAGE_SIZE_OFFSET(function) \
-	(IS_E1H_OFFSET ? (0x6000 + (function * 0x8)) : (0x2400 + \
-	(function * 0x8)))
-#define CSTORM_SB_HC_DISABLE_C_OFFSET(port, cpu_id, index) \
-	(IS_E1H_OFFSET ? (0x811a + (port * 0x280) + (cpu_id * 0x28) + \
-	(index * 0x4)) : (0x305a + (port * 0x280) + (cpu_id * 0x28) + \
-	(index * 0x4)))
-#define CSTORM_SB_HC_DISABLE_U_OFFSET(port, cpu_id, index) \
-	(IS_E1H_OFFSET ? (0xb01a + (port * 0x800) + (cpu_id * 0x80) + \
-	(index * 0x4)) : (0x401a + (port * 0x800) + (cpu_id * 0x80) + \
-	(index * 0x4)))
-#define CSTORM_SB_HC_TIMEOUT_C_OFFSET(port, cpu_id, index) \
-	(IS_E1H_OFFSET ? (0x8118 + (port * 0x280) + (cpu_id * 0x28) + \
-	(index * 0x4)) : (0x3058 + (port * 0x280) + (cpu_id * 0x28) + \
-	(index * 0x4)))
-#define CSTORM_SB_HC_TIMEOUT_U_OFFSET(port, cpu_id, index) \
-	(IS_E1H_OFFSET ? (0xb018 + (port * 0x800) + (cpu_id * 0x80) + \
-	(index * 0x4)) : (0x4018 + (port * 0x800) + (cpu_id * 0x80) + \
-	(index * 0x4)))
-#define CSTORM_SB_HOST_SB_ADDR_C_OFFSET(port, cpu_id) \
-	(IS_E1H_OFFSET ? (0x8100 + (port * 0x280) + (cpu_id * 0x28)) : \
-	(0x3040 + (port * 0x280) + (cpu_id * 0x28)))
-#define CSTORM_SB_HOST_SB_ADDR_U_OFFSET(port, cpu_id) \
-	(IS_E1H_OFFSET ? (0xb000 + (port * 0x800) + (cpu_id * 0x80)) : \
-	(0x4000 + (port * 0x800) + (cpu_id * 0x80)))
-#define CSTORM_SB_HOST_STATUS_BLOCK_C_OFFSET(port, cpu_id) \
-	(IS_E1H_OFFSET ? (0x8108 + (port * 0x280) + (cpu_id * 0x28)) : \
-	(0x3048 + (port * 0x280) + (cpu_id * 0x28)))
-#define CSTORM_SB_HOST_STATUS_BLOCK_U_OFFSET(port, cpu_id) \
-	(IS_E1H_OFFSET ? (0xb008 + (port * 0x800) + (cpu_id * 0x80)) : \
-	(0x4008 + (port * 0x800) + (cpu_id * 0x80)))
-#define CSTORM_SB_STATUS_BLOCK_C_SIZE 0x10
-#define CSTORM_SB_STATUS_BLOCK_U_SIZE 0x60
-#define CSTORM_STATS_FLAGS_OFFSET(function) \
-	(IS_E1H_OFFSET ? (0x1108 + (function * 0x8)) : (0x5108 + \
-	(function * 0x8)))
-#define TSTORM_APPROXIMATE_MATCH_MULTICAST_FILTERING_OFFSET(function) \
-	(IS_E1H_OFFSET ? (0x3200 + (function * 0x20)) : 0xffffffff)
-#define TSTORM_ASSERT_LIST_INDEX_OFFSET \
-	(IS_E1H_OFFSET ? 0xa000 : 0x1000)
-#define TSTORM_ASSERT_LIST_OFFSET(idx) \
-	(IS_E1H_OFFSET ? (0xa020 + (idx * 0x10)) : (0x1020 + (idx * 0x10)))
-#define TSTORM_CLIENT_CONFIG_OFFSET(port, client_id) \
-	(IS_E1H_OFFSET ? (0x33a0 + (port * 0x1a0) + (client_id * 0x10)) \
-	: (0x9c0 + (port * 0x120) + (client_id * 0x10)))
-#define TSTORM_COMMON_SAFC_WORKAROUND_ENABLE_OFFSET \
-	(IS_E1H_OFFSET ? 0x1ed8 : 0xffffffff)
-#define TSTORM_COMMON_SAFC_WORKAROUND_TIMEOUT_10USEC_OFFSET \
-	(IS_E1H_OFFSET ? 0x1eda : 0xffffffff)
-#define TSTORM_DEF_SB_HC_DISABLE_OFFSET(function, index) \
-	(IS_E1H_OFFSET ? (0xb01a + ((function>>1) * 0x28) + \
-	((function&1) * 0xa0) + (index * 0x4)) : (0x141a + (function * \
-	0x28) + (index * 0x4)))
-#define TSTORM_DEF_SB_HOST_SB_ADDR_OFFSET(function) \
-	(IS_E1H_OFFSET ? (0xb000 + ((function>>1) * 0x28) + \
-	((function&1) * 0xa0)) : (0x1400 + (function * 0x28)))
-#define TSTORM_DEF_SB_HOST_STATUS_BLOCK_OFFSET(function) \
-	(IS_E1H_OFFSET ? (0xb008 + ((function>>1) * 0x28) + \
-	((function&1) * 0xa0)) : (0x1408 + (function * 0x28)))
-#define TSTORM_ETH_STATS_QUERY_ADDR_OFFSET(function) \
-	(IS_E1H_OFFSET ? (0x2940 + (function * 0x8)) : (0x4928 + \
-	(function * 0x8)))
-#define TSTORM_FUNCTION_COMMON_CONFIG_OFFSET(function) \
-	(IS_E1H_OFFSET ? (0x3000 + (function * 0x40)) : (0x1500 + \
-	(function * 0x40)))
-#define TSTORM_FUNCTION_MODE_OFFSET \
-	(IS_E1H_OFFSET ? 0x1ed0 : 0xffffffff)
-#define TSTORM_HC_BTR_OFFSET(port) \
-	(IS_E1H_OFFSET ? (0xb144 + (port * 0x30)) : (0x1454 + (port * 0x18)))
-#define TSTORM_INDIRECTION_TABLE_OFFSET(function) \
-	(IS_E1H_OFFSET ? (0x12c8 + (function * 0x80)) : (0x22c8 + \
-	(function * 0x80)))
-#define TSTORM_INDIRECTION_TABLE_SIZE 0x80
-#define TSTORM_ISCSI_CONN_BUF_PBL_OFFSET(function, pblEntry) \
-	(IS_E1H_OFFSET ? (0x60c0 + (function * 0x40) + (pblEntry * 0x8)) \
-	: (0x4c30 + (function * 0x40) + (pblEntry * 0x8)))
-#define TSTORM_ISCSI_ERROR_BITMAP_OFFSET(function) \
-	(IS_E1H_OFFSET ? (0x6340 + (function * 0x8)) : (0x4cd0 + \
-	(function * 0x8)))
-#define TSTORM_ISCSI_NUM_OF_TASKS_OFFSET(function) \
-	(IS_E1H_OFFSET ? (0x6004 + (function * 0x8)) : (0x4c04 + \
-	(function * 0x8)))
-#define TSTORM_ISCSI_PAGE_SIZE_LOG_OFFSET(function) \
-	(IS_E1H_OFFSET ? (0x6002 + (function * 0x8)) : (0x4c02 + \
-	(function * 0x8)))
-#define TSTORM_ISCSI_PAGE_SIZE_OFFSET(function) \
-	(IS_E1H_OFFSET ? (0x6000 + (function * 0x8)) : (0x4c00 + \
-	(function * 0x8)))
-#define TSTORM_ISCSI_RQ_SIZE_OFFSET(function) \
-	(IS_E1H_OFFSET ? (0x6080 + (function * 0x8)) : (0x4c20 + \
-	(function * 0x8)))
-#define TSTORM_ISCSI_TCP_VARS_FLAGS_OFFSET(function) \
-	(IS_E1H_OFFSET ? (0x6040 + (function * 0x8)) : (0x4c10 + \
-	(function * 0x8)))
-#define TSTORM_ISCSI_TCP_VARS_LSB_LOCAL_MAC_ADDR_OFFSET(function) \
-	(IS_E1H_OFFSET ? (0x6042 + (function * 0x8)) : (0x4c12 + \
-	(function * 0x8)))
-#define TSTORM_ISCSI_TCP_VARS_MSB_LOCAL_MAC_ADDR_OFFSET(function) \
-	(IS_E1H_OFFSET ? (0x6044 + (function * 0x8)) : (0x4c14 + \
-	(function * 0x8)))
-#define TSTORM_MAC_FILTER_CONFIG_OFFSET(function) \
-	(IS_E1H_OFFSET ? (0x3008 + (function * 0x40)) : (0x1508 + \
-	(function * 0x40)))
-#define TSTORM_PER_COUNTER_ID_STATS_OFFSET(port, stats_counter_id) \
-	(IS_E1H_OFFSET ? (0x2010 + (port * 0x490) + (stats_counter_id * \
-	0x40)) : (0x4010 + (port * 0x490) + (stats_counter_id * 0x40)))
-#define TSTORM_STATS_FLAGS_OFFSET(function) \
-	(IS_E1H_OFFSET ? (0x29c0 + (function * 0x8)) : (0x4948 + \
-	(function * 0x8)))
-#define TSTORM_TCP_MAX_CWND_OFFSET(function) \
-	(IS_E1H_OFFSET ? (0x4004 + (function * 0x8)) : (0x1fb4 + \
-	(function * 0x8)))
-#define USTORM_AGG_DATA_OFFSET (IS_E1H_OFFSET ? 0xa000 : 0x3000)
-#define USTORM_AGG_DATA_SIZE (IS_E1H_OFFSET ? 0x2000 : 0x1000)
-#define USTORM_ASSERT_LIST_INDEX_OFFSET \
-	(IS_E1H_OFFSET ? 0x8000 : 0x1000)
-#define USTORM_ASSERT_LIST_OFFSET(idx) \
-	(IS_E1H_OFFSET ? (0x8020 + (idx * 0x10)) : (0x1020 + (idx * 0x10)))
-#define USTORM_CQE_PAGE_BASE_OFFSET(port, clientId) \
-	(IS_E1H_OFFSET ? (0x1010 + (port * 0x680) + (clientId * 0x40)) : \
-	(0x4010 + (port * 0x360) + (clientId * 0x30)))
-#define USTORM_CQE_PAGE_NEXT_OFFSET(port, clientId) \
-	(IS_E1H_OFFSET ? (0x1028 + (port * 0x680) + (clientId * 0x40)) : \
-	(0x4028 + (port * 0x360) + (clientId * 0x30)))
-#define USTORM_ETH_PAUSE_ENABLED_OFFSET(port) \
-	(IS_E1H_OFFSET ? (0x2ad4 + (port * 0x8)) : 0xffffffff)
-#define USTORM_ETH_RING_PAUSE_DATA_OFFSET(port, clientId) \
-	(IS_E1H_OFFSET ? (0x1030 + (port * 0x680) + (clientId * 0x40)) : \
-	0xffffffff)
-#define USTORM_ETH_STATS_QUERY_ADDR_OFFSET(function) \
-	(IS_E1H_OFFSET ? (0x2a50 + (function * 0x8)) : (0x1dd0 + \
-	(function * 0x8)))
-#define USTORM_FUNCTION_MODE_OFFSET \
-	(IS_E1H_OFFSET ? 0x2448 : 0xffffffff)
-#define USTORM_ISCSI_CQ_SIZE_OFFSET(function) \
-	(IS_E1H_OFFSET ? (0x7044 + (function * 0x8)) : (0x2414 + \
-	(function * 0x8)))
-#define USTORM_ISCSI_CQ_SQN_SIZE_OFFSET(function) \
-	(IS_E1H_OFFSET ? (0x7046 + (function * 0x8)) : (0x2416 + \
-	(function * 0x8)))
-#define USTORM_ISCSI_ERROR_BITMAP_OFFSET(function) \
-	(IS_E1H_OFFSET ? (0x7688 + (function * 0x8)) : (0x29c8 + \
-	(function * 0x8)))
-#define USTORM_ISCSI_GLOBAL_BUF_PHYS_ADDR_OFFSET(function) \
-	(IS_E1H_OFFSET ? (0x7648 + (function * 0x8)) : (0x29b8 + \
-	(function * 0x8)))
-#define USTORM_ISCSI_NUM_OF_TASKS_OFFSET(function) \
-	(IS_E1H_OFFSET ? (0x7004 + (function * 0x8)) : (0x2404 + \
-	(function * 0x8)))
-#define USTORM_ISCSI_PAGE_SIZE_LOG_OFFSET(function) \
-	(IS_E1H_OFFSET ? (0x7002 + (function * 0x8)) : (0x2402 + \
-	(function * 0x8)))
-#define USTORM_ISCSI_PAGE_SIZE_OFFSET(function) \
-	(IS_E1H_OFFSET ? (0x7000 + (function * 0x8)) : (0x2400 + \
-	(function * 0x8)))
-#define USTORM_ISCSI_R2TQ_SIZE_OFFSET(function) \
-	(IS_E1H_OFFSET ? (0x7040 + (function * 0x8)) : (0x2410 + \
-	(function * 0x8)))
-#define USTORM_ISCSI_RQ_BUFFER_SIZE_OFFSET(function) \
-	(IS_E1H_OFFSET ? (0x7080 + (function * 0x8)) : (0x2420 + \
-	(function * 0x8)))
-#define USTORM_ISCSI_RQ_SIZE_OFFSET(function) \
-	(IS_E1H_OFFSET ? (0x7084 + (function * 0x8)) : (0x2424 + \
-	(function * 0x8)))
-#define USTORM_MAX_AGG_SIZE_OFFSET(port, clientId) \
-	(IS_E1H_OFFSET ? (0x1018 + (port * 0x680) + (clientId * 0x40)) : \
-	(0x4018 + (port * 0x360) + (clientId * 0x30)))
-#define USTORM_MEM_WORKAROUND_ADDRESS_OFFSET(function) \
-	(IS_E1H_OFFSET ? (0x2408 + (function * 0x8)) : (0x1da8 + \
-	(function * 0x8)))
-#define USTORM_PER_COUNTER_ID_STATS_OFFSET(port, stats_counter_id) \
-	(IS_E1H_OFFSET ? (0x2450 + (port * 0x2d0) + (stats_counter_id * \
-	0x28)) : (0x1500 + (port * 0x2d0) + (stats_counter_id * 0x28)))
-#define USTORM_RX_PRODS_OFFSET(port, client_id) \
-	(IS_E1H_OFFSET ? (0x1000 + (port * 0x680) + (client_id * 0x40)) \
-	: (0x4000 + (port * 0x360) + (client_id * 0x30)))
-#define USTORM_STATS_FLAGS_OFFSET(function) \
-	(IS_E1H_OFFSET ? (0x29f0 + (function * 0x8)) : (0x1db8 + \
-	(function * 0x8)))
-#define USTORM_TPA_BTR_OFFSET (IS_E1H_OFFSET ? 0x3da5 : 0x5095)
-#define USTORM_TPA_BTR_SIZE 0x1
-#define XSTORM_ASSERT_LIST_INDEX_OFFSET \
-	(IS_E1H_OFFSET ? 0x9000 : 0x1000)
-#define XSTORM_ASSERT_LIST_OFFSET(idx) \
-	(IS_E1H_OFFSET ? (0x9020 + (idx * 0x10)) : (0x1020 + (idx * 0x10)))
-#define XSTORM_CMNG_PER_PORT_VARS_OFFSET(port) \
-	(IS_E1H_OFFSET ? (0x24a8 + (port * 0x50)) : (0x3a80 + (port * 0x50)))
-#define XSTORM_DEF_SB_HC_DISABLE_OFFSET(function, index) \
-	(IS_E1H_OFFSET ? (0xa01a + ((function>>1) * 0x28) + \
-	((function&1) * 0xa0) + (index * 0x4)) : (0x141a + (function * \
-	0x28) + (index * 0x4)))
-#define XSTORM_DEF_SB_HOST_SB_ADDR_OFFSET(function) \
-	(IS_E1H_OFFSET ? (0xa000 + ((function>>1) * 0x28) + \
-	((function&1) * 0xa0)) : (0x1400 + (function * 0x28)))
-#define XSTORM_DEF_SB_HOST_STATUS_BLOCK_OFFSET(function) \
-	(IS_E1H_OFFSET ? (0xa008 + ((function>>1) * 0x28) + \
-	((function&1) * 0xa0)) : (0x1408 + (function * 0x28)))
-#define XSTORM_E1HOV_OFFSET(function) \
-	(IS_E1H_OFFSET ? (0x2c10 + (function * 0x8)) : 0xffffffff)
-#define XSTORM_ETH_STATS_QUERY_ADDR_OFFSET(function) \
-	(IS_E1H_OFFSET ? (0x2418 + (function * 0x8)) : (0x3a50 + \
-	(function * 0x8)))
-#define XSTORM_FAIRNESS_PER_VN_VARS_OFFSET(function) \
-	(IS_E1H_OFFSET ? (0x2588 + (function * 0x90)) : (0x3b60 + \
-	(function * 0x90)))
-#define XSTORM_FUNCTION_MODE_OFFSET \
-	(IS_E1H_OFFSET ? 0x2c50 : 0xffffffff)
-#define XSTORM_HC_BTR_OFFSET(port) \
-	(IS_E1H_OFFSET ? (0xa144 + (port * 0x30)) : (0x1454 + (port * 0x18)))
-#define XSTORM_ISCSI_HQ_SIZE_OFFSET(function) \
-	(IS_E1H_OFFSET ? (0x80c0 + (function * 0x8)) : (0x1c30 + \
-	(function * 0x8)))
-#define XSTORM_ISCSI_LOCAL_MAC_ADDR0_OFFSET(function) \
-	(IS_E1H_OFFSET ? (0x8080 + (function * 0x8)) : (0x1c20 + \
-	(function * 0x8)))
-#define XSTORM_ISCSI_LOCAL_MAC_ADDR1_OFFSET(function) \
-	(IS_E1H_OFFSET ? (0x8081 + (function * 0x8)) : (0x1c21 + \
-	(function * 0x8)))
-#define XSTORM_ISCSI_LOCAL_MAC_ADDR2_OFFSET(function) \
-	(IS_E1H_OFFSET ? (0x8082 + (function * 0x8)) : (0x1c22 + \
-	(function * 0x8)))
-#define XSTORM_ISCSI_LOCAL_MAC_ADDR3_OFFSET(function) \
-	(IS_E1H_OFFSET ? (0x8083 + (function * 0x8)) : (0x1c23 + \
-	(function * 0x8)))
-#define XSTORM_ISCSI_LOCAL_MAC_ADDR4_OFFSET(function) \
-	(IS_E1H_OFFSET ? (0x8084 + (function * 0x8)) : (0x1c24 + \
-	(function * 0x8)))
-#define XSTORM_ISCSI_LOCAL_MAC_ADDR5_OFFSET(function) \
-	(IS_E1H_OFFSET ? (0x8085 + (function * 0x8)) : (0x1c25 + \
-	(function * 0x8)))
-#define XSTORM_ISCSI_LOCAL_VLAN_OFFSET(function) \
-	(IS_E1H_OFFSET ? (0x8086 + (function * 0x8)) : (0x1c26 + \
-	(function * 0x8)))
-#define XSTORM_ISCSI_NUM_OF_TASKS_OFFSET(function) \
-	(IS_E1H_OFFSET ? (0x8004 + (function * 0x8)) : (0x1c04 + \
-	(function * 0x8)))
-#define XSTORM_ISCSI_PAGE_SIZE_LOG_OFFSET(function) \
-	(IS_E1H_OFFSET ? (0x8002 + (function * 0x8)) : (0x1c02 + \
-	(function * 0x8)))
-#define XSTORM_ISCSI_PAGE_SIZE_OFFSET(function) \
-	(IS_E1H_OFFSET ? (0x8000 + (function * 0x8)) : (0x1c00 + \
-	(function * 0x8)))
-#define XSTORM_ISCSI_R2TQ_SIZE_OFFSET(function) \
-	(IS_E1H_OFFSET ? (0x80c4 + (function * 0x8)) : (0x1c34 + \
-	(function * 0x8)))
-#define XSTORM_ISCSI_SQ_SIZE_OFFSET(function) \
-	(IS_E1H_OFFSET ? (0x80c2 + (function * 0x8)) : (0x1c32 + \
-	(function * 0x8)))
-#define XSTORM_ISCSI_TCP_VARS_ADV_WND_SCL_OFFSET(function) \
-	(IS_E1H_OFFSET ? (0x8043 + (function * 0x8)) : (0x1c13 + \
-	(function * 0x8)))
-#define XSTORM_ISCSI_TCP_VARS_FLAGS_OFFSET(function) \
-	(IS_E1H_OFFSET ? (0x8042 + (function * 0x8)) : (0x1c12 + \
-	(function * 0x8)))
-#define XSTORM_ISCSI_TCP_VARS_TOS_OFFSET(function) \
-	(IS_E1H_OFFSET ? (0x8041 + (function * 0x8)) : (0x1c11 + \
-	(function * 0x8)))
-#define XSTORM_ISCSI_TCP_VARS_TTL_OFFSET(function) \
-	(IS_E1H_OFFSET ? (0x8040 + (function * 0x8)) : (0x1c10 + \
-	(function * 0x8)))
-#define XSTORM_PER_COUNTER_ID_STATS_OFFSET(port, stats_counter_id) \
-	(IS_E1H_OFFSET ? (0xc000 + (port * 0x360) + (stats_counter_id * \
-	0x30)) : (0x3378 + (port * 0x360) + (stats_counter_id * 0x30)))
-#define XSTORM_RATE_SHAPING_PER_VN_VARS_OFFSET(function) \
-	(IS_E1H_OFFSET ? (0x2548 + (function * 0x90)) : (0x3b20 + \
-	(function * 0x90)))
-#define XSTORM_SPQ_PAGE_BASE_OFFSET(function) \
-	(IS_E1H_OFFSET ? (0x2000 + (function * 0x10)) : (0x3328 + \
-	(function * 0x10)))
-#define XSTORM_SPQ_PROD_OFFSET(function) \
-	(IS_E1H_OFFSET ? (0x2008 + (function * 0x10)) : (0x3330 + \
-	(function * 0x10)))
-#define XSTORM_STATS_FLAGS_OFFSET(function) \
-	(IS_E1H_OFFSET ? (0x23d8 + (function * 0x8)) : (0x3a40 + \
-	(function * 0x8)))
-#define XSTORM_TCP_GLOBAL_DEL_ACK_COUNTER_ENABLED_OFFSET(port) \
-	(IS_E1H_OFFSET ? (0x4000 + (port * 0x8)) : (0x1960 + (port * 0x8)))
-#define XSTORM_TCP_GLOBAL_DEL_ACK_COUNTER_MAX_COUNT_OFFSET(port) \
-	(IS_E1H_OFFSET ? (0x4001 + (port * 0x8)) : (0x1961 + (port * 0x8)))
-#define XSTORM_TCP_TX_SWS_TIMER_VAL_OFFSET(function) \
-	(IS_E1H_OFFSET ? (0x4060 + ((function>>1) * 0x8) + ((function&1) \
-	* 0x4)) : (0x1978 + (function * 0x4)))
-#define COMMON_ASM_INVALID_ASSERT_OPCODE 0x0
-
-/**
-* This file defines HSI constants for the ETH flow
-*/
-#ifdef _EVEREST_MICROCODE
-#include "microcode_constants.h"
-#include "eth_rx_bd.h"
-#include "eth_tx_bd.h"
-#include "eth_rx_cqe.h"
-#include "eth_rx_sge.h"
-#include "eth_rx_cqe_next_page.h"
-#endif
-
-/* RSS hash types */
-#define DEFAULT_HASH_TYPE 0
-#define IPV4_HASH_TYPE 1
-#define TCP_IPV4_HASH_TYPE 2
-#define IPV6_HASH_TYPE 3
-#define TCP_IPV6_HASH_TYPE 4
-#define VLAN_PRI_HASH_TYPE 5
-#define E1HOV_PRI_HASH_TYPE 6
-#define DSCP_HASH_TYPE 7
-
-
-/* Ethernet Ring parameters */
-#define X_ETH_LOCAL_RING_SIZE 13
-#define FIRST_BD_IN_PKT 0
-#define PARSE_BD_INDEX 1
-#define NUM_OF_ETH_BDS_IN_PAGE ((PAGE_SIZE)/(STRUCT_SIZE(eth_tx_bd)/8))
-#define U_ETH_NUM_OF_SGES_TO_FETCH 8
-#define U_ETH_MAX_SGES_FOR_PACKET 3
-
-/* Rx ring params */
-#define U_ETH_LOCAL_BD_RING_SIZE 8
-#define U_ETH_LOCAL_SGE_RING_SIZE 10
-#define U_ETH_SGL_SIZE 8
-
-
-#define U_ETH_SGES_PER_PAGE_INVERSE_MASK \
-	(0xFFFF - ((PAGE_SIZE/((STRUCT_SIZE(eth_rx_sge))/8))-1))
-
-#define TU_ETH_CQES_PER_PAGE (PAGE_SIZE/(STRUCT_SIZE(eth_rx_cqe)/8))
-#define U_ETH_BDS_PER_PAGE (PAGE_SIZE/(STRUCT_SIZE(eth_rx_bd)/8))
-#define U_ETH_SGES_PER_PAGE (PAGE_SIZE/(STRUCT_SIZE(eth_rx_sge)/8))
-
-#define U_ETH_BDS_PER_PAGE_MASK (U_ETH_BDS_PER_PAGE-1)
-#define U_ETH_CQE_PER_PAGE_MASK (TU_ETH_CQES_PER_PAGE-1)
-#define U_ETH_SGES_PER_PAGE_MASK (U_ETH_SGES_PER_PAGE-1)
-
-#define U_ETH_UNDEFINED_Q 0xFF
-
-/* values of command IDs in the ramrod message */
-#define RAMROD_CMD_ID_ETH_PORT_SETUP 80
-#define RAMROD_CMD_ID_ETH_CLIENT_SETUP 85
-#define RAMROD_CMD_ID_ETH_STAT_QUERY 90
-#define RAMROD_CMD_ID_ETH_UPDATE 100
-#define RAMROD_CMD_ID_ETH_HALT 105
-#define RAMROD_CMD_ID_ETH_SET_MAC 110
-#define RAMROD_CMD_ID_ETH_CFC_DEL 115
-#define RAMROD_CMD_ID_ETH_PORT_DEL 120
-#define RAMROD_CMD_ID_ETH_FORWARD_SETUP 125
-
-
-/* command values for set mac command */
-#define T_ETH_MAC_COMMAND_SET 0
-#define T_ETH_MAC_COMMAND_INVALIDATE 1
-
-#define T_ETH_INDIRECTION_TABLE_SIZE 128
-
-/*The CRC32 seed, that is used for the hash(reduction) multicast address */
-#define T_ETH_CRC32_HASH_SEED 0x00000000
-
-/* Maximal L2 clients supported */
-#define ETH_MAX_RX_CLIENTS_E1 18
-#define ETH_MAX_RX_CLIENTS_E1H 26
-
-/* Maximal aggregation queues supported */
-#define ETH_MAX_AGGREGATION_QUEUES_E1 32
-#define ETH_MAX_AGGREGATION_QUEUES_E1H 64
-
-/* ETH RSS modes */
-#define ETH_RSS_MODE_DISABLED 0
-#define ETH_RSS_MODE_REGULAR 1
-#define ETH_RSS_MODE_VLAN_PRI 2
-#define ETH_RSS_MODE_E1HOV_PRI 3
-#define ETH_RSS_MODE_IP_DSCP 4
-
-
-/**
-* This file defines HSI constants common to all microcode flows
-*/
-
-/* Connection types */
-#define ETH_CONNECTION_TYPE 0
-#define TOE_CONNECTION_TYPE 1
-#define RDMA_CONNECTION_TYPE 2
-#define ISCSI_CONNECTION_TYPE 3
-#define FCOE_CONNECTION_TYPE 4
-#define RESERVED_CONNECTION_TYPE_0 5
-#define RESERVED_CONNECTION_TYPE_1 6
-#define RESERVED_CONNECTION_TYPE_2 7
-
-
-#define PROTOCOL_STATE_BIT_OFFSET 6
-
-#define ETH_STATE (ETH_CONNECTION_TYPE << PROTOCOL_STATE_BIT_OFFSET)
-#define TOE_STATE (TOE_CONNECTION_TYPE << PROTOCOL_STATE_BIT_OFFSET)
-#define RDMA_STATE (RDMA_CONNECTION_TYPE << PROTOCOL_STATE_BIT_OFFSET)
-
-/* microcode fixed page page size 4K (chains and ring segments) */
-#define MC_PAGE_SIZE 4096
-
-
-/* Host coalescing constants */
-#define HC_IGU_BC_MODE 0
-#define HC_IGU_NBC_MODE 1
-
-#define HC_REGULAR_SEGMENT 0
-#define HC_DEFAULT_SEGMENT 1
-
-/* index numbers */
-#define HC_USTORM_DEF_SB_NUM_INDICES 8
-#define HC_CSTORM_DEF_SB_NUM_INDICES 8
-#define HC_XSTORM_DEF_SB_NUM_INDICES 4
-#define HC_TSTORM_DEF_SB_NUM_INDICES 4
-#define HC_USTORM_SB_NUM_INDICES 4
-#define HC_CSTORM_SB_NUM_INDICES 4
-
-/* index values - which counter to update */
-
-#define HC_INDEX_U_TOE_RX_CQ_CONS 0
-#define HC_INDEX_U_ETH_RX_CQ_CONS 1
-#define HC_INDEX_U_ETH_RX_BD_CONS 2
-#define HC_INDEX_U_FCOE_EQ_CONS 3
-
-#define HC_INDEX_C_TOE_TX_CQ_CONS 0
-#define HC_INDEX_C_ETH_TX_CQ_CONS 1
-#define HC_INDEX_C_ISCSI_EQ_CONS 2
-
-#define HC_INDEX_DEF_X_SPQ_CONS 0
-
-#define HC_INDEX_DEF_C_RDMA_EQ_CONS 0
-#define HC_INDEX_DEF_C_RDMA_NAL_PROD 1
-#define HC_INDEX_DEF_C_ETH_FW_TX_CQ_CONS 2
-#define HC_INDEX_DEF_C_ETH_SLOW_PATH 3
-#define HC_INDEX_DEF_C_ETH_RDMA_CQ_CONS 4
-#define HC_INDEX_DEF_C_ETH_ISCSI_CQ_CONS 5
-#define HC_INDEX_DEF_C_ETH_FCOE_CQ_CONS 6
-
-#define HC_INDEX_DEF_U_ETH_RDMA_RX_CQ_CONS 0
-#define HC_INDEX_DEF_U_ETH_ISCSI_RX_CQ_CONS 1
-#define HC_INDEX_DEF_U_ETH_RDMA_RX_BD_CONS 2
-#define HC_INDEX_DEF_U_ETH_ISCSI_RX_BD_CONS 3
-#define HC_INDEX_DEF_U_ETH_FCOE_RX_CQ_CONS 4
-#define HC_INDEX_DEF_U_ETH_FCOE_RX_BD_CONS 5
-
-/* used by the driver to get the SB offset */
-#define USTORM_ID 0
-#define CSTORM_ID 1
-#define XSTORM_ID 2
-#define TSTORM_ID 3
-#define ATTENTION_ID 4
-
-/* max number of slow path commands per port */
-#define MAX_RAMRODS_PER_PORT 8
-
-/* values for RX ETH CQE type field */
-#define RX_ETH_CQE_TYPE_ETH_FASTPATH 0
-#define RX_ETH_CQE_TYPE_ETH_RAMROD 1
-
-
-/**** DEFINES FOR TIMERS/CLOCKS RESOLUTIONS ****/
-#define EMULATION_FREQUENCY_FACTOR 1600
-#define FPGA_FREQUENCY_FACTOR 100
-
-#define TIMERS_TICK_SIZE_CHIP (1e-3)
-#define TIMERS_TICK_SIZE_EMUL \
- ((TIMERS_TICK_SIZE_CHIP)/((EMULATION_FREQUENCY_FACTOR)))
-#define TIMERS_TICK_SIZE_FPGA \
- ((TIMERS_TICK_SIZE_CHIP)/((FPGA_FREQUENCY_FACTOR)))
-
-#define TSEMI_CLK1_RESUL_CHIP (1e-3)
-#define TSEMI_CLK1_RESUL_EMUL \
- ((TSEMI_CLK1_RESUL_CHIP)/(EMULATION_FREQUENCY_FACTOR))
-#define TSEMI_CLK1_RESUL_FPGA \
- ((TSEMI_CLK1_RESUL_CHIP)/(FPGA_FREQUENCY_FACTOR))
-
-#define USEMI_CLK1_RESUL_CHIP (TIMERS_TICK_SIZE_CHIP)
-#define USEMI_CLK1_RESUL_EMUL (TIMERS_TICK_SIZE_EMUL)
-#define USEMI_CLK1_RESUL_FPGA (TIMERS_TICK_SIZE_FPGA)
-
-#define XSEMI_CLK1_RESUL_CHIP (1e-3)
-#define XSEMI_CLK1_RESUL_EMUL \
- ((XSEMI_CLK1_RESUL_CHIP)/(EMULATION_FREQUENCY_FACTOR))
-#define XSEMI_CLK1_RESUL_FPGA \
- ((XSEMI_CLK1_RESUL_CHIP)/(FPGA_FREQUENCY_FACTOR))
-
-#define XSEMI_CLK2_RESUL_CHIP (1e-6)
-#define XSEMI_CLK2_RESUL_EMUL \
- ((XSEMI_CLK2_RESUL_CHIP)/(EMULATION_FREQUENCY_FACTOR))
-#define XSEMI_CLK2_RESUL_FPGA \
- ((XSEMI_CLK2_RESUL_CHIP)/(FPGA_FREQUENCY_FACTOR))
-
-#define SDM_TIMER_TICK_RESUL_CHIP (4*(1e-6))
-#define SDM_TIMER_TICK_RESUL_EMUL \
- ((SDM_TIMER_TICK_RESUL_CHIP)/(EMULATION_FREQUENCY_FACTOR))
-#define SDM_TIMER_TICK_RESUL_FPGA \
- ((SDM_TIMER_TICK_RESUL_CHIP)/(FPGA_FREQUENCY_FACTOR))
-
-
-/**** END DEFINES FOR TIMERS/CLOCKS RESOLUTIONS ****/
-#define XSTORM_IP_ID_ROLL_HALF 0x8000
-#define XSTORM_IP_ID_ROLL_ALL 0
-
-#define FW_LOG_LIST_SIZE 50
-
-#define NUM_OF_PROTOCOLS 4
-#define NUM_OF_SAFC_BITS 16
-#define MAX_COS_NUMBER 4
-#define MAX_T_STAT_COUNTER_ID 18
-#define MAX_X_STAT_COUNTER_ID 18
-#define MAX_U_STAT_COUNTER_ID 18
-
-
-#define UNKNOWN_ADDRESS 0
-#define UNICAST_ADDRESS 1
-#define MULTICAST_ADDRESS 2
-#define BROADCAST_ADDRESS 3
-
-#define SINGLE_FUNCTION 0
-#define MULTI_FUNCTION 1
-
-#define IP_V4 0
-#define IP_V6 1
-
diff -r f4bf81a7ff20 drivers/net/bnx2x_fw_file_hdr.h
--- a/drivers/net/bnx2x_fw_file_hdr.h
+++ /dev/null
@@ -1,37 +0,0 @@
-/* bnx2x_fw_file_hdr.h: FW binary file header structure.
- *
- * Copyright (c) 2007-2009 Broadcom Corporation
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation.
- *
- * Maintained by: Eilon Greenstein <eilong@broadcom.com>
- * Written by: Vladislav Zolotarov <vladz@broadcom.com>
- * Based on the original idea of John Wright <john.wright@hp.com>.
- */
-
-#ifndef BNX2X_INIT_FILE_HDR_H
-#define BNX2X_INIT_FILE_HDR_H
-
-struct bnx2x_fw_file_section {
-	__be32 len;
-	__be32 offset;
-};
-
-struct bnx2x_fw_file_hdr {
-	struct bnx2x_fw_file_section init_ops;
-	struct bnx2x_fw_file_section init_ops_offsets;
-	struct bnx2x_fw_file_section init_data;
-	struct bnx2x_fw_file_section tsem_int_table_data;
-	struct bnx2x_fw_file_section tsem_pram_data;
-	struct bnx2x_fw_file_section usem_int_table_data;
-	struct bnx2x_fw_file_section usem_pram_data;
-	struct bnx2x_fw_file_section csem_int_table_data;
-	struct bnx2x_fw_file_section csem_pram_data;
-	struct bnx2x_fw_file_section xsem_int_table_data;
-	struct bnx2x_fw_file_section xsem_pram_data;
-	struct bnx2x_fw_file_section fw_version;
-};
-
-#endif /* BNX2X_INIT_FILE_HDR_H */
diff -r f4bf81a7ff20 drivers/net/bnx2x_hsi.h
--- a/drivers/net/bnx2x_hsi.h
+++ /dev/null
@@ -1,3138 +0,0 @@
-/* bnx2x_hsi.h: Broadcom Everest network driver.
- *
- * Copyright (c) 2007-2010 Broadcom Corporation
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation.
- */
-
-struct license_key {
-	u32 reserved[6];
-
-#if defined(__BIG_ENDIAN)
-	u16 max_iscsi_init_conn;
-	u16 max_iscsi_trgt_conn;
-#elif defined(__LITTLE_ENDIAN)
-	u16 max_iscsi_trgt_conn;
-	u16 max_iscsi_init_conn;
-#endif
-
-	u32 reserved_a[6];
-};
-
-
-#define PORT_0				0
-#define PORT_1				1
-#define PORT_MAX			2
-
-/****************************************************************************
- * Shared HW configuration						    *
- ****************************************************************************/
-struct shared_hw_cfg {					 /* NVRAM Offset */
-	/* Up to 16 bytes of NULL-terminated string */
-	u8  part_num[16];					/* 0x104 */
-
-	u32 config;						/* 0x114 */
-#define SHARED_HW_CFG_MDIO_VOLTAGE_MASK 	    0x00000001
-#define SHARED_HW_CFG_MDIO_VOLTAGE_SHIFT	    0
-#define SHARED_HW_CFG_MDIO_VOLTAGE_1_2V 	    0x00000000
-#define SHARED_HW_CFG_MDIO_VOLTAGE_2_5V 	    0x00000001
-#define SHARED_HW_CFG_MCP_RST_ON_CORE_RST_EN	    0x00000002
-
-#define SHARED_HW_CFG_PORT_SWAP 		    0x00000004
-
-#define SHARED_HW_CFG_BEACON_WOL_EN		    0x00000008
-
-#define SHARED_HW_CFG_MFW_SELECT_MASK		    0x00000700
-#define SHARED_HW_CFG_MFW_SELECT_SHIFT		    8
-	/* Whatever MFW found in NVM
-	   (if multiple found, priority order is: NC-SI, UMP, IPMI) */
-#define SHARED_HW_CFG_MFW_SELECT_DEFAULT	    0x00000000
-#define SHARED_HW_CFG_MFW_SELECT_NC_SI		    0x00000100
-#define SHARED_HW_CFG_MFW_SELECT_UMP		    0x00000200
-#define SHARED_HW_CFG_MFW_SELECT_IPMI		    0x00000300
-	/* Use SPIO4 as an arbiter between: 0-NC_SI, 1-IPMI
-	  (can only be used when an add-in board, not BMC, pulls-down SPIO4) */
-#define SHARED_HW_CFG_MFW_SELECT_SPIO4_NC_SI_IPMI   0x00000400
-	/* Use SPIO4 as an arbiter between: 0-UMP, 1-IPMI
-	  (can only be used when an add-in board, not BMC, pulls-down SPIO4) */
-#define SHARED_HW_CFG_MFW_SELECT_SPIO4_UMP_IPMI     0x00000500
-	/* Use SPIO4 as an arbiter between: 0-NC-SI, 1-UMP
-	  (can only be used when an add-in board, not BMC, pulls-down SPIO4) */
-#define SHARED_HW_CFG_MFW_SELECT_SPIO4_NC_SI_UMP    0x00000600
-
-#define SHARED_HW_CFG_LED_MODE_MASK		    0x000f0000
-#define SHARED_HW_CFG_LED_MODE_SHIFT		    16
-#define SHARED_HW_CFG_LED_MAC1			    0x00000000
-#define SHARED_HW_CFG_LED_PHY1			    0x00010000
-#define SHARED_HW_CFG_LED_PHY2			    0x00020000
-#define SHARED_HW_CFG_LED_PHY3			    0x00030000
-#define SHARED_HW_CFG_LED_MAC2			    0x00040000
-#define SHARED_HW_CFG_LED_PHY4			    0x00050000
-#define SHARED_HW_CFG_LED_PHY5			    0x00060000
-#define SHARED_HW_CFG_LED_PHY6			    0x00070000
-#define SHARED_HW_CFG_LED_MAC3			    0x00080000
-#define SHARED_HW_CFG_LED_PHY7			    0x00090000
-#define SHARED_HW_CFG_LED_PHY9			    0x000a0000
-#define SHARED_HW_CFG_LED_PHY11 		    0x000b0000
-#define SHARED_HW_CFG_LED_MAC4			    0x000c0000
-#define SHARED_HW_CFG_LED_PHY8			    0x000d0000
-
-#define SHARED_HW_CFG_AN_ENABLE_MASK		    0x3f000000
-#define SHARED_HW_CFG_AN_ENABLE_SHIFT		    24
-#define SHARED_HW_CFG_AN_ENABLE_CL37		    0x01000000
-#define SHARED_HW_CFG_AN_ENABLE_CL73		    0x02000000
-#define SHARED_HW_CFG_AN_ENABLE_BAM		    0x04000000
-#define SHARED_HW_CFG_AN_ENABLE_PARALLEL_DETECTION  0x08000000
-#define SHARED_HW_CFG_AN_EN_SGMII_FIBER_AUTO_DETECT 0x10000000
-#define SHARED_HW_CFG_AN_ENABLE_REMOTE_PHY	    0x20000000
-
-	u32 config2;						/* 0x118 */
-	/* one time auto detect grace period (in sec) */
-#define SHARED_HW_CFG_GRACE_PERIOD_MASK 	    0x000000ff
-#define SHARED_HW_CFG_GRACE_PERIOD_SHIFT	    0
-
-#define SHARED_HW_CFG_PCIE_GEN2_ENABLED 	    0x00000100
-
-	/* The default value for the core clock is 250MHz and it is
-	   achieved by setting the clock change to 4 */
-#define SHARED_HW_CFG_CLOCK_CHANGE_MASK 	    0x00000e00
-#define SHARED_HW_CFG_CLOCK_CHANGE_SHIFT	    9
-
-#define SHARED_HW_CFG_SMBUS_TIMING_100KHZ	    0x00000000
-#define SHARED_HW_CFG_SMBUS_TIMING_400KHZ	    0x00001000
-
-#define SHARED_HW_CFG_HIDE_PORT1		    0x00002000
-
-	/*  The fan failure mechanism is usually related to the PHY type
-	  since the power consumption of the board is determined by the PHY.
-	  Currently, fan is required for most designs with SFX7101, BCM8727
-	  and BCM8481. If a fan is not required for a board which uses one
-	  of those PHYs, this field should be set to "Disabled". If a fan is
-	  required for a different PHY type, this option should be set to
-	  "Enabled".
-	  The fan failure indication is expected on
-	  SPIO5 */
-#define SHARED_HW_CFG_FAN_FAILURE_MASK			      0x00180000
-#define SHARED_HW_CFG_FAN_FAILURE_SHIFT 		      19
-#define SHARED_HW_CFG_FAN_FAILURE_PHY_TYPE		      0x00000000
-#define SHARED_HW_CFG_FAN_FAILURE_DISABLED		      0x00080000
-#define SHARED_HW_CFG_FAN_FAILURE_ENABLED		      0x00100000
-
-	u32 power_dissipated;					/* 0x11c */
-#define SHARED_HW_CFG_POWER_DIS_CMN_MASK	    0xff000000
-#define SHARED_HW_CFG_POWER_DIS_CMN_SHIFT	    24
-
-#define SHARED_HW_CFG_POWER_MGNT_SCALE_MASK	    0x00ff0000
-#define SHARED_HW_CFG_POWER_MGNT_SCALE_SHIFT	    16
-#define SHARED_HW_CFG_POWER_MGNT_UNKNOWN_SCALE	    0x00000000
-#define SHARED_HW_CFG_POWER_MGNT_DOT_1_WATT	    0x00010000
-#define SHARED_HW_CFG_POWER_MGNT_DOT_01_WATT	    0x00020000
-#define SHARED_HW_CFG_POWER_MGNT_DOT_001_WATT	    0x00030000
-
-	u32 ump_nc_si_config;					/* 0x120 */
-#define SHARED_HW_CFG_UMP_NC_SI_MII_MODE_MASK	    0x00000003
-#define SHARED_HW_CFG_UMP_NC_SI_MII_MODE_SHIFT	    0
-#define SHARED_HW_CFG_UMP_NC_SI_MII_MODE_MAC	    0x00000000
-#define SHARED_HW_CFG_UMP_NC_SI_MII_MODE_PHY	    0x00000001
-#define SHARED_HW_CFG_UMP_NC_SI_MII_MODE_MII	    0x00000000
-#define SHARED_HW_CFG_UMP_NC_SI_MII_MODE_RMII	    0x00000002
-
-#define SHARED_HW_CFG_UMP_NC_SI_NUM_DEVS_MASK	    0x00000f00
-#define SHARED_HW_CFG_UMP_NC_SI_NUM_DEVS_SHIFT	    8
-
-#define SHARED_HW_CFG_UMP_NC_SI_EXT_PHY_TYPE_MASK   0x00ff0000
-#define SHARED_HW_CFG_UMP_NC_SI_EXT_PHY_TYPE_SHIFT  16
-#define SHARED_HW_CFG_UMP_NC_SI_EXT_PHY_TYPE_NONE   0x00000000
-#define SHARED_HW_CFG_UMP_NC_SI_EXT_PHY_TYPE_BCM5221 0x00010000
-
-	u32 board;						/* 0x124 */
-#define SHARED_HW_CFG_BOARD_REV_MASK		    0x00FF0000
-#define SHARED_HW_CFG_BOARD_REV_SHIFT		    16
-
-#define SHARED_HW_CFG_BOARD_MAJOR_VER_MASK	    0x0F000000
-#define SHARED_HW_CFG_BOARD_MAJOR_VER_SHIFT	    24
-
-#define SHARED_HW_CFG_BOARD_MINOR_VER_MASK	    0xF0000000
-#define SHARED_HW_CFG_BOARD_MINOR_VER_SHIFT	    28
-
-	u32 reserved;						/* 0x128 */
-
-};
-
-
-/****************************************************************************
- * Port HW configuration						    *
- ****************************************************************************/
-struct port_hw_cfg {			    /* port 0: 0x12c  port 1: 0x2bc */
-
-	u32 pci_id;
-#define PORT_HW_CFG_PCI_VENDOR_ID_MASK		    0xffff0000
-#define PORT_HW_CFG_PCI_DEVICE_ID_MASK		    0x0000ffff
-
-	u32 pci_sub_id;
-#define PORT_HW_CFG_PCI_SUBSYS_DEVICE_ID_MASK	    0xffff0000
-#define PORT_HW_CFG_PCI_SUBSYS_VENDOR_ID_MASK	    0x0000ffff
-
-	u32 power_dissipated;
-#define PORT_HW_CFG_POWER_DIS_D3_MASK		    0xff000000
-#define PORT_HW_CFG_POWER_DIS_D3_SHIFT		    24
-#define PORT_HW_CFG_POWER_DIS_D2_MASK		    0x00ff0000
-#define PORT_HW_CFG_POWER_DIS_D2_SHIFT		    16
-#define PORT_HW_CFG_POWER_DIS_D1_MASK		    0x0000ff00
-#define PORT_HW_CFG_POWER_DIS_D1_SHIFT		    8
-#define PORT_HW_CFG_POWER_DIS_D0_MASK		    0x000000ff
-#define PORT_HW_CFG_POWER_DIS_D0_SHIFT		    0
-
-	u32 power_consumed;
-#define PORT_HW_CFG_POWER_CONS_D3_MASK		    0xff000000
-#define PORT_HW_CFG_POWER_CONS_D3_SHIFT 	    24
-#define PORT_HW_CFG_POWER_CONS_D2_MASK		    0x00ff0000
-#define PORT_HW_CFG_POWER_CONS_D2_SHIFT 	    16
-#define PORT_HW_CFG_POWER_CONS_D1_MASK		    0x0000ff00
-#define PORT_HW_CFG_POWER_CONS_D1_SHIFT 	    8
-#define PORT_HW_CFG_POWER_CONS_D0_MASK		    0x000000ff
-#define PORT_HW_CFG_POWER_CONS_D0_SHIFT 	    0
-
-	u32 mac_upper;
-#define PORT_HW_CFG_UPPERMAC_MASK		    0x0000ffff
-#define PORT_HW_CFG_UPPERMAC_SHIFT		    0
-	u32 mac_lower;
-
-	u32 iscsi_mac_upper;  /* Upper 16 bits are always zeroes */
-	u32 iscsi_mac_lower;
-
-	u32 rdma_mac_upper;   /* Upper 16 bits are always zeroes */
-	u32 rdma_mac_lower;
-
-	u32 serdes_config;
-#define PORT_HW_CFG_SERDES_TX_DRV_PRE_EMPHASIS_MASK	      0x0000FFFF
-#define PORT_HW_CFG_SERDES_TX_DRV_PRE_EMPHASIS_SHIFT	      0
-
-#define PORT_HW_CFG_SERDES_RX_DRV_EQUALIZER_MASK	      0xFFFF0000
-#define PORT_HW_CFG_SERDES_RX_DRV_EQUALIZER_SHIFT	      16
-
-
-	u32 Reserved0[16];				    /* 0x158 */
-
-	/*  for external PHY, or forced mode or during AN */
-	u16 xgxs_config_rx[4];				    /* 0x198 */
-
-	u16 xgxs_config_tx[4];				    /* 0x1A0 */
-
-	u32 Reserved1[64];				    /* 0x1A8 */
-
-	u32 lane_config;
-#define PORT_HW_CFG_LANE_SWAP_CFG_MASK		    0x0000ffff
-#define PORT_HW_CFG_LANE_SWAP_CFG_SHIFT 	    0
-#define PORT_HW_CFG_LANE_SWAP_CFG_TX_MASK	    0x000000ff
-#define PORT_HW_CFG_LANE_SWAP_CFG_TX_SHIFT	    0
-#define PORT_HW_CFG_LANE_SWAP_CFG_RX_MASK	    0x0000ff00
-#define PORT_HW_CFG_LANE_SWAP_CFG_RX_SHIFT	    8
-#define PORT_HW_CFG_LANE_SWAP_CFG_MASTER_MASK	    0x0000c000
-#define PORT_HW_CFG_LANE_SWAP_CFG_MASTER_SHIFT	    14
-	/* AN and forced */
-#define PORT_HW_CFG_LANE_SWAP_CFG_01230123	    0x00001b1b
-	/* forced only */
-#define PORT_HW_CFG_LANE_SWAP_CFG_01233210	    0x00001be4
-	/* forced only */
-#define PORT_HW_CFG_LANE_SWAP_CFG_31203120	    0x0000d8d8
-	/* forced only */
-#define PORT_HW_CFG_LANE_SWAP_CFG_32103210	    0x0000e4e4
-
-	u32 external_phy_config;
-#define PORT_HW_CFG_SERDES_EXT_PHY_TYPE_MASK	    0xff000000
-#define PORT_HW_CFG_SERDES_EXT_PHY_TYPE_SHIFT	    24
-#define PORT_HW_CFG_SERDES_EXT_PHY_TYPE_DIRECT	    0x00000000
-#define PORT_HW_CFG_SERDES_EXT_PHY_TYPE_BCM5482     0x01000000
-#define PORT_HW_CFG_SERDES_EXT_PHY_TYPE_NOT_CONN    0xff000000
-
-#define PORT_HW_CFG_SERDES_EXT_PHY_ADDR_MASK	    0x00ff0000
-#define PORT_HW_CFG_SERDES_EXT_PHY_ADDR_SHIFT	    16
-
-#define PORT_HW_CFG_XGXS_EXT_PHY_TYPE_MASK	    0x0000ff00
-#define PORT_HW_CFG_XGXS_EXT_PHY_TYPE_SHIFT	    8
-#define PORT_HW_CFG_XGXS_EXT_PHY_TYPE_DIRECT	    0x00000000
-#define PORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM8071	    0x00000100
-#define PORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM8072	    0x00000200
-#define PORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM8073	    0x00000300
-#define PORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM8705	    0x00000400
-#define PORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM8706	    0x00000500
-#define PORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM8726	    0x00000600
-#define PORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM8481	    0x00000700
-#define PORT_HW_CFG_XGXS_EXT_PHY_TYPE_SFX7101	    0x00000800
-#define PORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM8727	    0x00000900
-#define PORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM8727_NOC   0x00000a00
-#define PORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM84823	    0x00000b00
-#define PORT_HW_CFG_XGXS_EXT_PHY_TYPE_FAILURE	    0x0000fd00
-#define PORT_HW_CFG_XGXS_EXT_PHY_TYPE_NOT_CONN	    0x0000ff00
-
-#define PORT_HW_CFG_XGXS_EXT_PHY_ADDR_MASK	    0x000000ff
-#define PORT_HW_CFG_XGXS_EXT_PHY_ADDR_SHIFT	    0
-
-	u32 speed_capability_mask;
-#define PORT_HW_CFG_SPEED_CAPABILITY_D0_MASK	    0xffff0000
-#define PORT_HW_CFG_SPEED_CAPABILITY_D0_SHIFT	    16
-#define PORT_HW_CFG_SPEED_CAPABILITY_D0_10M_FULL    0x00010000
-#define PORT_HW_CFG_SPEED_CAPABILITY_D0_10M_HALF    0x00020000
-#define PORT_HW_CFG_SPEED_CAPABILITY_D0_100M_HALF   0x00040000
-#define PORT_HW_CFG_SPEED_CAPABILITY_D0_100M_FULL   0x00080000
-#define PORT_HW_CFG_SPEED_CAPABILITY_D0_1G	    0x00100000
-#define PORT_HW_CFG_SPEED_CAPABILITY_D0_2_5G	    0x00200000
-#define PORT_HW_CFG_SPEED_CAPABILITY_D0_10G	    0x00400000
-#define PORT_HW_CFG_SPEED_CAPABILITY_D0_12G	    0x00800000
-#define PORT_HW_CFG_SPEED_CAPABILITY_D0_12_5G	    0x01000000
-#define PORT_HW_CFG_SPEED_CAPABILITY_D0_13G	    0x02000000
-#define PORT_HW_CFG_SPEED_CAPABILITY_D0_15G	    0x04000000
-#define PORT_HW_CFG_SPEED_CAPABILITY_D0_16G	    0x08000000
-#define PORT_HW_CFG_SPEED_CAPABILITY_D0_RESERVED    0xf0000000
-
-#define PORT_HW_CFG_SPEED_CAPABILITY_D3_MASK	    0x0000ffff
-#define PORT_HW_CFG_SPEED_CAPABILITY_D3_SHIFT	    0
-#define PORT_HW_CFG_SPEED_CAPABILITY_D3_10M_FULL    0x00000001
-#define PORT_HW_CFG_SPEED_CAPABILITY_D3_10M_HALF    0x00000002
-#define PORT_HW_CFG_SPEED_CAPABILITY_D3_100M_HALF   0x00000004
-#define PORT_HW_CFG_SPEED_CAPABILITY_D3_100M_FULL   0x00000008
-#define PORT_HW_CFG_SPEED_CAPABILITY_D3_1G	    0x00000010
-#define PORT_HW_CFG_SPEED_CAPABILITY_D3_2_5G	    0x00000020
-#define PORT_HW_CFG_SPEED_CAPABILITY_D3_10G	    0x00000040
-#define PORT_HW_CFG_SPEED_CAPABILITY_D3_12G	    0x00000080
-#define PORT_HW_CFG_SPEED_CAPABILITY_D3_12_5G	    0x00000100
-#define PORT_HW_CFG_SPEED_CAPABILITY_D3_13G	    0x00000200
-#define PORT_HW_CFG_SPEED_CAPABILITY_D3_15G	    0x00000400
-#define PORT_HW_CFG_SPEED_CAPABILITY_D3_16G	    0x00000800
-#define PORT_HW_CFG_SPEED_CAPABILITY_D3_RESERVED    0x0000f000
-
-	u32 reserved[2];
-
-};
-
-
-/****************************************************************************
- * Shared Feature configuration 					    *
- ****************************************************************************/
-struct shared_feat_cfg {				 /* NVRAM Offset */
-
-	u32 config;						/* 0x450 */
-#define SHARED_FEATURE_BMC_ECHO_MODE_EN 	    0x00000001
-
-	/*  Use the values from options 47 and 48 instead of the HW default
-	  values */
-#define SHARED_FEAT_CFG_OVERRIDE_PREEMPHASIS_CFG_DISABLED     0x00000000
-#define SHARED_FEAT_CFG_OVERRIDE_PREEMPHASIS_CFG_ENABLED      0x00000002
-
-#define SHARED_FEATURE_MF_MODE_DISABLED 	    0x00000100
-
-};
-
-
-/****************************************************************************
- * Port Feature configuration						    *
- ****************************************************************************/
-struct port_feat_cfg {			    /* port 0: 0x454  port 1: 0x4c8 */
-
-	u32 config;
-#define PORT_FEATURE_BAR1_SIZE_MASK		    0x0000000f
-#define PORT_FEATURE_BAR1_SIZE_SHIFT		    0
-#define PORT_FEATURE_BAR1_SIZE_DISABLED 	    0x00000000
-#define PORT_FEATURE_BAR1_SIZE_64K		    0x00000001
-#define PORT_FEATURE_BAR1_SIZE_128K		    0x00000002
-#define PORT_FEATURE_BAR1_SIZE_256K		    0x00000003
-#define PORT_FEATURE_BAR1_SIZE_512K		    0x00000004
-#define PORT_FEATURE_BAR1_SIZE_1M		    0x00000005
-#define PORT_FEATURE_BAR1_SIZE_2M		    0x00000006
-#define PORT_FEATURE_BAR1_SIZE_4M		    0x00000007
-#define PORT_FEATURE_BAR1_SIZE_8M		    0x00000008
-#define PORT_FEATURE_BAR1_SIZE_16M		    0x00000009
-#define PORT_FEATURE_BAR1_SIZE_32M		    0x0000000a
-#define PORT_FEATURE_BAR1_SIZE_64M		    0x0000000b
-#define PORT_FEATURE_BAR1_SIZE_128M		    0x0000000c
-#define PORT_FEATURE_BAR1_SIZE_256M		    0x0000000d
-#define PORT_FEATURE_BAR1_SIZE_512M		    0x0000000e
-#define PORT_FEATURE_BAR1_SIZE_1G		    0x0000000f
-#define PORT_FEATURE_BAR2_SIZE_MASK		    0x000000f0
-#define PORT_FEATURE_BAR2_SIZE_SHIFT		    4
-#define PORT_FEATURE_BAR2_SIZE_DISABLED 	    0x00000000
-#define PORT_FEATURE_BAR2_SIZE_64K		    0x00000010
-#define PORT_FEATURE_BAR2_SIZE_128K		    0x00000020
-#define PORT_FEATURE_BAR2_SIZE_256K		    0x00000030
-#define PORT_FEATURE_BAR2_SIZE_512K		    0x00000040
-#define PORT_FEATURE_BAR2_SIZE_1M		    0x00000050
-#define PORT_FEATURE_BAR2_SIZE_2M		    0x00000060
-#define PORT_FEATURE_BAR2_SIZE_4M		    0x00000070
-#define PORT_FEATURE_BAR2_SIZE_8M		    0x00000080
-#define PORT_FEATURE_BAR2_SIZE_16M		    0x00000090
-#define PORT_FEATURE_BAR2_SIZE_32M		    0x000000a0
-#define PORT_FEATURE_BAR2_SIZE_64M		    0x000000b0
-#define PORT_FEATURE_BAR2_SIZE_128M		    0x000000c0
-#define PORT_FEATURE_BAR2_SIZE_256M		    0x000000d0
-#define PORT_FEATURE_BAR2_SIZE_512M		    0x000000e0
-#define PORT_FEATURE_BAR2_SIZE_1G		    0x000000f0
-#define PORT_FEATURE_EN_SIZE_MASK		    0x07000000
-#define PORT_FEATURE_EN_SIZE_SHIFT		    24
-#define PORT_FEATURE_WOL_ENABLED		    0x01000000
-#define PORT_FEATURE_MBA_ENABLED		    0x02000000
-#define PORT_FEATURE_MFW_ENABLED		    0x04000000
-
-	/* Reserved bits: 28-29 */
-	/*  Check the optic vendor via i2c against a list of approved modules
-	  in a separate nvram image */
-#define PORT_FEAT_CFG_OPT_MDL_ENFRCMNT_MASK		      0xE0000000
-#define PORT_FEAT_CFG_OPT_MDL_ENFRCMNT_SHIFT		      29
-#define PORT_FEAT_CFG_OPT_MDL_ENFRCMNT_NO_ENFORCEMENT	      0x00000000
-#define PORT_FEAT_CFG_OPT_MDL_ENFRCMNT_DISABLE_TX_LASER       0x20000000
-#define PORT_FEAT_CFG_OPT_MDL_ENFRCMNT_WARNING_MSG	      0x40000000
-#define PORT_FEAT_CFG_OPT_MDL_ENFRCMNT_POWER_DOWN	      0x60000000
-
-
-	u32 wol_config;
-	/* Default is used when driver sets to "auto" mode */
-#define PORT_FEATURE_WOL_DEFAULT_MASK		    0x00000003
-#define PORT_FEATURE_WOL_DEFAULT_SHIFT		    0
-#define PORT_FEATURE_WOL_DEFAULT_DISABLE	    0x00000000
-#define PORT_FEATURE_WOL_DEFAULT_MAGIC		    0x00000001
-#define PORT_FEATURE_WOL_DEFAULT_ACPI		    0x00000002
-#define PORT_FEATURE_WOL_DEFAULT_MAGIC_AND_ACPI     0x00000003
-#define PORT_FEATURE_WOL_RES_PAUSE_CAP		    0x00000004
-#define PORT_FEATURE_WOL_RES_ASYM_PAUSE_CAP	    0x00000008
-#define PORT_FEATURE_WOL_ACPI_UPON_MGMT 	    0x00000010
-
-	u32 mba_config;
-#define PORT_FEATURE_MBA_BOOT_AGENT_TYPE_MASK	    0x00000003
-#define PORT_FEATURE_MBA_BOOT_AGENT_TYPE_SHIFT	    0
-#define PORT_FEATURE_MBA_BOOT_AGENT_TYPE_PXE	    0x00000000
-#define PORT_FEATURE_MBA_BOOT_AGENT_TYPE_RPL	    0x00000001
-#define PORT_FEATURE_MBA_BOOT_AGENT_TYPE_BOOTP	    0x00000002
-#define PORT_FEATURE_MBA_BOOT_AGENT_TYPE_ISCSIB     0x00000003
-#define PORT_FEATURE_MBA_RES_PAUSE_CAP		    0x00000100
-#define PORT_FEATURE_MBA_RES_ASYM_PAUSE_CAP	    0x00000200
-#define PORT_FEATURE_MBA_SETUP_PROMPT_ENABLE	    0x00000400
-#define PORT_FEATURE_MBA_HOTKEY_CTRL_S		    0x00000000
-#define PORT_FEATURE_MBA_HOTKEY_CTRL_B		    0x00000800
-#define PORT_FEATURE_MBA_EXP_ROM_SIZE_MASK	    0x000ff000
-#define PORT_FEATURE_MBA_EXP_ROM_SIZE_SHIFT	    12
-#define PORT_FEATURE_MBA_EXP_ROM_SIZE_DISABLED	    0x00000000
-#define PORT_FEATURE_MBA_EXP_ROM_SIZE_2K	    0x00001000
-#define PORT_FEATURE_MBA_EXP_ROM_SIZE_4K	    0x00002000
-#define PORT_FEATURE_MBA_EXP_ROM_SIZE_8K	    0x00003000
-#define PORT_FEATURE_MBA_EXP_ROM_SIZE_16K	    0x00004000
-#define PORT_FEATURE_MBA_EXP_ROM_SIZE_32K	    0x00005000
-#define PORT_FEATURE_MBA_EXP_ROM_SIZE_64K	    0x00006000
-#define PORT_FEATURE_MBA_EXP_ROM_SIZE_128K	    0x00007000
-#define PORT_FEATURE_MBA_EXP_ROM_SIZE_256K	    0x00008000
-#define PORT_FEATURE_MBA_EXP_ROM_SIZE_512K	    0x00009000
-#define PORT_FEATURE_MBA_EXP_ROM_SIZE_1M	    0x0000a000
-#define PORT_FEATURE_MBA_EXP_ROM_SIZE_2M	    0x0000b000
-#define PORT_FEATURE_MBA_EXP_ROM_SIZE_4M	    0x0000c000
-#define PORT_FEATURE_MBA_EXP_ROM_SIZE_8M	    0x0000d000
-#define PORT_FEATURE_MBA_EXP_ROM_SIZE_16M	    0x0000e000
-#define PORT_FEATURE_MBA_EXP_ROM_SIZE_32M	    0x0000f000
-#define PORT_FEATURE_MBA_MSG_TIMEOUT_MASK	    0x00f00000
-#define PORT_FEATURE_MBA_MSG_TIMEOUT_SHIFT	    20
-#define PORT_FEATURE_MBA_BIOS_BOOTSTRAP_MASK	    0x03000000
-#define PORT_FEATURE_MBA_BIOS_BOOTSTRAP_SHIFT	    24
-#define PORT_FEATURE_MBA_BIOS_BOOTSTRAP_AUTO	    0x00000000
-#define PORT_FEATURE_MBA_BIOS_BOOTSTRAP_BBS	    0x01000000
-#define PORT_FEATURE_MBA_BIOS_BOOTSTRAP_INT18H	    0x02000000
-#define PORT_FEATURE_MBA_BIOS_BOOTSTRAP_INT19H	    0x03000000
-#define PORT_FEATURE_MBA_LINK_SPEED_MASK	    0x3c000000
-#define PORT_FEATURE_MBA_LINK_SPEED_SHIFT	    26
-#define PORT_FEATURE_MBA_LINK_SPEED_AUTO	    0x00000000
-#define PORT_FEATURE_MBA_LINK_SPEED_10HD	    0x04000000
-#define PORT_FEATURE_MBA_LINK_SPEED_10FD	    0x08000000
-#define PORT_FEATURE_MBA_LINK_SPEED_100HD	    0x0c000000
-#define PORT_FEATURE_MBA_LINK_SPEED_100FD	    0x10000000
-#define PORT_FEATURE_MBA_LINK_SPEED_1GBPS	    0x14000000
-#define PORT_FEATURE_MBA_LINK_SPEED_2_5GBPS	    0x18000000
-#define PORT_FEATURE_MBA_LINK_SPEED_10GBPS_CX4	    0x1c000000
-#define PORT_FEATURE_MBA_LINK_SPEED_10GBPS_KX4	    0x20000000
-#define PORT_FEATURE_MBA_LINK_SPEED_10GBPS_KR	    0x24000000
-#define PORT_FEATURE_MBA_LINK_SPEED_12GBPS	    0x28000000
-#define PORT_FEATURE_MBA_LINK_SPEED_12_5GBPS	    0x2c000000
-#define PORT_FEATURE_MBA_LINK_SPEED_13GBPS	    0x30000000
-#define PORT_FEATURE_MBA_LINK_SPEED_15GBPS	    0x34000000
-#define PORT_FEATURE_MBA_LINK_SPEED_16GBPS	    0x38000000
-
-	u32 bmc_config;
-#define PORT_FEATURE_BMC_LINK_OVERRIDE_DEFAULT	    0x00000000
-#define PORT_FEATURE_BMC_LINK_OVERRIDE_EN	    0x00000001
-
-	u32 mba_vlan_cfg;
-#define PORT_FEATURE_MBA_VLAN_TAG_MASK		    0x0000ffff
-#define PORT_FEATURE_MBA_VLAN_TAG_SHIFT 	    0
-#define PORT_FEATURE_MBA_VLAN_EN		    0x00010000
-
-	u32 resource_cfg;
-#define PORT_FEATURE_RESOURCE_CFG_VALID 	    0x00000001
-#define PORT_FEATURE_RESOURCE_CFG_DIAG		    0x00000002
-#define PORT_FEATURE_RESOURCE_CFG_L2		    0x00000004
-#define PORT_FEATURE_RESOURCE_CFG_ISCSI 	    0x00000008
-#define PORT_FEATURE_RESOURCE_CFG_RDMA		    0x00000010
-
-	u32 smbus_config;
-	/* Obsolete */
-#define PORT_FEATURE_SMBUS_EN			    0x00000001
-#define PORT_FEATURE_SMBUS_ADDR_MASK		    0x000000fe
-#define PORT_FEATURE_SMBUS_ADDR_SHIFT		    1
-
-	u32 reserved1;
-
-	u32 link_config;    /* Used as HW defaults for the driver */
-#define PORT_FEATURE_CONNECTED_SWITCH_MASK	    0x03000000
-#define PORT_FEATURE_CONNECTED_SWITCH_SHIFT	    24
-	/* (forced) low speed switch (< 10G) */
-#define PORT_FEATURE_CON_SWITCH_1G_SWITCH	    0x00000000
-	/* (forced) high speed switch (>= 10G) */
-#define PORT_FEATURE_CON_SWITCH_10G_SWITCH	    0x01000000
-#define PORT_FEATURE_CON_SWITCH_AUTO_DETECT	    0x02000000
-#define PORT_FEATURE_CON_SWITCH_ONE_TIME_DETECT     0x03000000
-
-#define PORT_FEATURE_LINK_SPEED_MASK		    0x000f0000
-#define PORT_FEATURE_LINK_SPEED_SHIFT		    16
-#define PORT_FEATURE_LINK_SPEED_AUTO		    0x00000000
-#define PORT_FEATURE_LINK_SPEED_10M_FULL	    0x00010000
-#define PORT_FEATURE_LINK_SPEED_10M_HALF	    0x00020000
-#define PORT_FEATURE_LINK_SPEED_100M_HALF	    0x00030000
-#define PORT_FEATURE_LINK_SPEED_100M_FULL	    0x00040000
-#define PORT_FEATURE_LINK_SPEED_1G		    0x00050000
-#define PORT_FEATURE_LINK_SPEED_2_5G		    0x00060000
-#define PORT_FEATURE_LINK_SPEED_10G_CX4 	    0x00070000
-#define PORT_FEATURE_LINK_SPEED_10G_KX4 	    0x00080000
-#define PORT_FEATURE_LINK_SPEED_10G_KR		    0x00090000
-#define PORT_FEATURE_LINK_SPEED_12G		    0x000a0000
-#define PORT_FEATURE_LINK_SPEED_12_5G		    0x000b0000
-#define PORT_FEATURE_LINK_SPEED_13G		    0x000c0000
-#define PORT_FEATURE_LINK_SPEED_15G		    0x000d0000
-#define PORT_FEATURE_LINK_SPEED_16G		    0x000e0000
-
-#define PORT_FEATURE_FLOW_CONTROL_MASK		    0x00000700
-#define PORT_FEATURE_FLOW_CONTROL_SHIFT 	    8
-#define PORT_FEATURE_FLOW_CONTROL_AUTO		    0x00000000
-#define PORT_FEATURE_FLOW_CONTROL_TX		    0x00000100
-#define PORT_FEATURE_FLOW_CONTROL_RX		    0x00000200
-#define PORT_FEATURE_FLOW_CONTROL_BOTH		    0x00000300
-#define PORT_FEATURE_FLOW_CONTROL_NONE		    0x00000400
-
-	/* The default for MCP link configuration,
-	   uses the same defines as link_config */
-	u32 mfw_wol_link_cfg;
-
-	u32 reserved[19];
-
-};
-
-
-/****************************************************************************
- * Device Information							    *
- ****************************************************************************/
-struct shm_dev_info {						    /* size */
-
-	u32    bc_rev; /* 8 bits each: major, minor, build */	       /* 4 */
-
-	struct shared_hw_cfg	 shared_hw_config;		      /* 40 */
-
-	struct port_hw_cfg	 port_hw_config[PORT_MAX];     /* 400*2=800 */
-
-	struct shared_feat_cfg	 shared_feature_config; 	       /* 4 */
-
-	struct port_feat_cfg	 port_feature_config[PORT_MAX];/* 116*2=232 */
-
-};
-
-
-#define FUNC_0				0
-#define FUNC_1				1
-#define FUNC_2				2
-#define FUNC_3				3
-#define FUNC_4				4
-#define FUNC_5				5
-#define FUNC_6				6
-#define FUNC_7				7
-#define E1_FUNC_MAX			2
-#define E1H_FUNC_MAX			8
-
-#define VN_0				0
-#define VN_1				1
-#define VN_2				2
-#define VN_3				3
-#define E1VN_MAX			1
-#define E1HVN_MAX			4
-
-
-/* This value (in milliseconds) determines the frequency of the driver
- * issuing the PULSE message code.  The firmware monitors this periodic
- * pulse to determine when to switch to an OS-absent mode. */
-#define DRV_PULSE_PERIOD_MS		250
-
-/* This value (in milliseconds) determines how long the driver should
- * wait for an acknowledgement from the firmware before timing out.  Once
- * the firmware has timed out, the driver will assume there is no firmware
- * running and there won't be any firmware-driver synchronization during a
- * driver reset. */
-#define FW_ACK_TIME_OUT_MS		5000
-
-#define FW_ACK_POLL_TIME_MS		1
-
-#define FW_ACK_NUM_OF_POLL	(FW_ACK_TIME_OUT_MS/FW_ACK_POLL_TIME_MS)
-
-/* LED Blink rate that will achieve ~15.9Hz */
-#define LED_BLINK_RATE_VAL		480
-
-/****************************************************************************
- * Driver <-> FW Mailbox						    *
- ****************************************************************************/
-struct drv_port_mb {
-
-	u32 link_status;
-	/* Driver should update this field on any link change event */
-
-#define LINK_STATUS_LINK_FLAG_MASK			0x00000001
-#define LINK_STATUS_LINK_UP				0x00000001
-#define LINK_STATUS_SPEED_AND_DUPLEX_MASK		0x0000001E
-#define LINK_STATUS_SPEED_AND_DUPLEX_AN_NOT_COMPLETE	(0<<1)
-#define LINK_STATUS_SPEED_AND_DUPLEX_10THD		(1<<1)
-#define LINK_STATUS_SPEED_AND_DUPLEX_10TFD		(2<<1)
-#define LINK_STATUS_SPEED_AND_DUPLEX_100TXHD		(3<<1)
-#define LINK_STATUS_SPEED_AND_DUPLEX_100T4		(4<<1)
-#define LINK_STATUS_SPEED_AND_DUPLEX_100TXFD		(5<<1)
-#define LINK_STATUS_SPEED_AND_DUPLEX_1000THD		(6<<1)
-#define LINK_STATUS_SPEED_AND_DUPLEX_1000TFD		(7<<1)
-#define LINK_STATUS_SPEED_AND_DUPLEX_1000XFD		(7<<1)
-#define LINK_STATUS_SPEED_AND_DUPLEX_2500THD		(8<<1)
-#define LINK_STATUS_SPEED_AND_DUPLEX_2500TFD		(9<<1)
-#define LINK_STATUS_SPEED_AND_DUPLEX_2500XFD		(9<<1)
-#define LINK_STATUS_SPEED_AND_DUPLEX_10GTFD		(10<<1)
-#define LINK_STATUS_SPEED_AND_DUPLEX_10GXFD		(10<<1)
-#define LINK_STATUS_SPEED_AND_DUPLEX_12GTFD		(11<<1)
-#define LINK_STATUS_SPEED_AND_DUPLEX_12GXFD		(11<<1)
-#define LINK_STATUS_SPEED_AND_DUPLEX_12_5GTFD		(12<<1)
-#define LINK_STATUS_SPEED_AND_DUPLEX_12_5GXFD		(12<<1)
-#define LINK_STATUS_SPEED_AND_DUPLEX_13GTFD		(13<<1)
-#define LINK_STATUS_SPEED_AND_DUPLEX_13GXFD		(13<<1)
-#define LINK_STATUS_SPEED_AND_DUPLEX_15GTFD		(14<<1)
-#define LINK_STATUS_SPEED_AND_DUPLEX_15GXFD		(14<<1)
-#define LINK_STATUS_SPEED_AND_DUPLEX_16GTFD		(15<<1)
-#define LINK_STATUS_SPEED_AND_DUPLEX_16GXFD		(15<<1)
-
-#define LINK_STATUS_AUTO_NEGOTIATE_FLAG_MASK		0x00000020
-#define LINK_STATUS_AUTO_NEGOTIATE_ENABLED		0x00000020
-
-#define LINK_STATUS_AUTO_NEGOTIATE_COMPLETE		0x00000040
-#define LINK_STATUS_PARALLEL_DETECTION_FLAG_MASK	0x00000080
-#define LINK_STATUS_PARALLEL_DETECTION_USED		0x00000080
-
-#define LINK_STATUS_LINK_PARTNER_1000TFD_CAPABLE	0x00000200
-#define LINK_STATUS_LINK_PARTNER_1000THD_CAPABLE	0x00000400
-#define LINK_STATUS_LINK_PARTNER_100T4_CAPABLE		0x00000800
-#define LINK_STATUS_LINK_PARTNER_100TXFD_CAPABLE	0x00001000
-#define LINK_STATUS_LINK_PARTNER_100TXHD_CAPABLE	0x00002000
-#define LINK_STATUS_LINK_PARTNER_10TFD_CAPABLE		0x00004000
-#define LINK_STATUS_LINK_PARTNER_10THD_CAPABLE		0x00008000
-
-#define LINK_STATUS_TX_FLOW_CONTROL_FLAG_MASK		0x00010000
-#define LINK_STATUS_TX_FLOW_CONTROL_ENABLED		0x00010000
-
-#define LINK_STATUS_RX_FLOW_CONTROL_FLAG_MASK		0x00020000
-#define LINK_STATUS_RX_FLOW_CONTROL_ENABLED		0x00020000
-
-#define LINK_STATUS_LINK_PARTNER_FLOW_CONTROL_MASK	0x000C0000
-#define LINK_STATUS_LINK_PARTNER_NOT_PAUSE_CAPABLE	(0<<18)
-#define LINK_STATUS_LINK_PARTNER_SYMMETRIC_PAUSE	(1<<18)
-#define LINK_STATUS_LINK_PARTNER_ASYMMETRIC_PAUSE	(2<<18)
-#define LINK_STATUS_LINK_PARTNER_BOTH_PAUSE		(3<<18)
-
-#define LINK_STATUS_SERDES_LINK 			0x00100000
-
-#define LINK_STATUS_LINK_PARTNER_2500XFD_CAPABLE	0x00200000
-#define LINK_STATUS_LINK_PARTNER_2500XHD_CAPABLE	0x00400000
-#define LINK_STATUS_LINK_PARTNER_10GXFD_CAPABLE 	0x00800000
-#define LINK_STATUS_LINK_PARTNER_12GXFD_CAPABLE 	0x01000000
-#define LINK_STATUS_LINK_PARTNER_12_5GXFD_CAPABLE	0x02000000
-#define LINK_STATUS_LINK_PARTNER_13GXFD_CAPABLE 	0x04000000
-#define LINK_STATUS_LINK_PARTNER_15GXFD_CAPABLE 	0x08000000
-#define LINK_STATUS_LINK_PARTNER_16GXFD_CAPABLE 	0x10000000
-
-	u32 port_stx;
-
-	u32 stat_nig_timer;
-
-	/* MCP firmware does not use this field */
-	u32 ext_phy_fw_version;
-
-};
-
-
-struct drv_func_mb {
-
-	u32 drv_mb_header;
-#define DRV_MSG_CODE_MASK				0xffff0000
-#define DRV_MSG_CODE_LOAD_REQ				0x10000000
-#define DRV_MSG_CODE_LOAD_DONE				0x11000000
-#define DRV_MSG_CODE_UNLOAD_REQ_WOL_EN			0x20000000
-#define DRV_MSG_CODE_UNLOAD_REQ_WOL_DIS 		0x20010000
-#define DRV_MSG_CODE_UNLOAD_REQ_WOL_MCP 		0x20020000
-#define DRV_MSG_CODE_UNLOAD_DONE			0x21000000
-#define DRV_MSG_CODE_DCC_OK				0x30000000
-#define DRV_MSG_CODE_DCC_FAILURE			0x31000000
-#define DRV_MSG_CODE_DIAG_ENTER_REQ			0x50000000
-#define DRV_MSG_CODE_DIAG_EXIT_REQ			0x60000000
-#define DRV_MSG_CODE_VALIDATE_KEY			0x70000000
-#define DRV_MSG_CODE_GET_CURR_KEY			0x80000000
-#define DRV_MSG_CODE_GET_UPGRADE_KEY			0x81000000
-#define DRV_MSG_CODE_GET_MANUF_KEY			0x82000000
-#define DRV_MSG_CODE_LOAD_L2B_PRAM			0x90000000
-	/*
-	 * The optic module verification commands requris bootcode
-	 * v5.0.6 or later
-	 */
-#define DRV_MSG_CODE_VRFY_OPT_MDL			0xa0000000
-#define REQ_BC_VER_4_VRFY_OPT_MDL			0x00050006
-
-#define BIOS_MSG_CODE_LIC_CHALLENGE			0xff010000
-#define BIOS_MSG_CODE_LIC_RESPONSE			0xff020000
-#define BIOS_MSG_CODE_VIRT_MAC_PRIM			0xff030000
-#define BIOS_MSG_CODE_VIRT_MAC_ISCSI			0xff040000
-
-#define DRV_MSG_SEQ_NUMBER_MASK 			0x0000ffff
-
-	u32 drv_mb_param;
-
-	u32 fw_mb_header;
-#define FW_MSG_CODE_MASK				0xffff0000
-#define FW_MSG_CODE_DRV_LOAD_COMMON			0x10100000
-#define FW_MSG_CODE_DRV_LOAD_PORT			0x10110000
-#define FW_MSG_CODE_DRV_LOAD_FUNCTION			0x10120000
-#define FW_MSG_CODE_DRV_LOAD_REFUSED			0x10200000
-#define FW_MSG_CODE_DRV_LOAD_DONE			0x11100000
-#define FW_MSG_CODE_DRV_UNLOAD_COMMON			0x20100000
-#define FW_MSG_CODE_DRV_UNLOAD_PORT			0x20110000
-#define FW_MSG_CODE_DRV_UNLOAD_FUNCTION 		0x20120000
-#define FW_MSG_CODE_DRV_UNLOAD_DONE			0x21100000
-#define FW_MSG_CODE_DCC_DONE				0x30100000
-#define FW_MSG_CODE_DIAG_ENTER_DONE			0x50100000
-#define FW_MSG_CODE_DIAG_REFUSE 			0x50200000
-#define FW_MSG_CODE_DIAG_EXIT_DONE			0x60100000
-#define FW_MSG_CODE_VALIDATE_KEY_SUCCESS		0x70100000
-#define FW_MSG_CODE_VALIDATE_KEY_FAILURE		0x70200000
-#define FW_MSG_CODE_GET_KEY_DONE			0x80100000
-#define FW_MSG_CODE_NO_KEY				0x80f00000
-#define FW_MSG_CODE_LIC_INFO_NOT_READY			0x80f80000
-#define FW_MSG_CODE_L2B_PRAM_LOADED			0x90100000
-#define FW_MSG_CODE_L2B_PRAM_T_LOAD_FAILURE		0x90210000
-#define FW_MSG_CODE_L2B_PRAM_C_LOAD_FAILURE		0x90220000
-#define FW_MSG_CODE_L2B_PRAM_X_LOAD_FAILURE		0x90230000
-#define FW_MSG_CODE_L2B_PRAM_U_LOAD_FAILURE		0x90240000
-#define FW_MSG_CODE_VRFY_OPT_MDL_SUCCESS		0xa0100000
-#define FW_MSG_CODE_VRFY_OPT_MDL_INVLD_IMG		0xa0200000
-#define FW_MSG_CODE_VRFY_OPT_MDL_UNAPPROVED		0xa0300000
-
-#define FW_MSG_CODE_LIC_CHALLENGE			0xff010000
-#define FW_MSG_CODE_LIC_RESPONSE			0xff020000
-#define FW_MSG_CODE_VIRT_MAC_PRIM			0xff030000
-#define FW_MSG_CODE_VIRT_MAC_ISCSI			0xff040000
-
-#define FW_MSG_SEQ_NUMBER_MASK				0x0000ffff
-
-	u32 fw_mb_param;
-
-	u32 drv_pulse_mb;
-#define DRV_PULSE_SEQ_MASK				0x00007fff
-#define DRV_PULSE_SYSTEM_TIME_MASK			0xffff0000
-	/* The system time is in the format of
-	 * (year-2001)*12*32 + month*32 + day. */
-#define DRV_PULSE_ALWAYS_ALIVE				0x00008000
-	/* Indicate to the firmware not to go into the
-	 * OS-absent when it is not getting driver pulse.
-	 * This is used for debugging as well for PXE(MBA). */
-
-	u32 mcp_pulse_mb;
-#define MCP_PULSE_SEQ_MASK				0x00007fff
-#define MCP_PULSE_ALWAYS_ALIVE				0x00008000
-	/* Indicates to the driver not to assert due to lack
-	 * of MCP response */
-#define MCP_EVENT_MASK					0xffff0000
-#define MCP_EVENT_OTHER_DRIVER_RESET_REQ		0x00010000
-
-	u32 iscsi_boot_signature;
-	u32 iscsi_boot_block_offset;
-
-	u32 drv_status;
-#define DRV_STATUS_PMF					0x00000001
-
-#define DRV_STATUS_DCC_EVENT_MASK			0x0000ff00
-#define DRV_STATUS_DCC_DISABLE_ENABLE_PF		0x00000100
-#define DRV_STATUS_DCC_BANDWIDTH_ALLOCATION		0x00000200
-#define DRV_STATUS_DCC_CHANGE_MAC_ADDRESS		0x00000400
-#define DRV_STATUS_DCC_RESERVED1			0x00000800
-#define DRV_STATUS_DCC_SET_PROTOCOL			0x00001000
-#define DRV_STATUS_DCC_SET_PRIORITY			0x00002000
-
-	u32 virt_mac_upper;
-#define VIRT_MAC_SIGN_MASK				0xffff0000
-#define VIRT_MAC_SIGNATURE				0x564d0000
-	u32 virt_mac_lower;
-
-};
-
-
-/****************************************************************************
- * Management firmware state						    *
- ****************************************************************************/
-/* Allocate 440 bytes for management firmware */
-#define MGMTFW_STATE_WORD_SIZE				    110
-
-struct mgmtfw_state {
-	u32 opaque[MGMTFW_STATE_WORD_SIZE];
-};
-
-
-/****************************************************************************
- * Multi-Function configuration 					    *
- ****************************************************************************/
-struct shared_mf_cfg {
-
-	u32 clp_mb;
-#define SHARED_MF_CLP_SET_DEFAULT		    0x00000000
-	/* set by CLP */
-#define SHARED_MF_CLP_EXIT			    0x00000001
-	/* set by MCP */
-#define SHARED_MF_CLP_EXIT_DONE 		    0x00010000
-
-};
-
-struct port_mf_cfg {
-
-	u32 dynamic_cfg;	/* device control channel */
-#define PORT_MF_CFG_E1HOV_TAG_MASK		    0x0000ffff
-#define PORT_MF_CFG_E1HOV_TAG_SHIFT		    0
-#define PORT_MF_CFG_E1HOV_TAG_DEFAULT		    PORT_MF_CFG_E1HOV_TAG_MASK
-
-	u32 reserved[3];
-
-};
-
-struct func_mf_cfg {
-
-	u32 config;
-	/* E/R/I/D */
-	/* function 0 of each port cannot be hidden */
-#define FUNC_MF_CFG_FUNC_HIDE			    0x00000001
-
-#define FUNC_MF_CFG_PROTOCOL_MASK		    0x00000007
-#define FUNC_MF_CFG_PROTOCOL_ETHERNET		    0x00000002
-#define FUNC_MF_CFG_PROTOCOL_ETHERNET_WITH_RDMA     0x00000004
-#define FUNC_MF_CFG_PROTOCOL_ISCSI		    0x00000006
-#define FUNC_MF_CFG_PROTOCOL_DEFAULT\
-	FUNC_MF_CFG_PROTOCOL_ETHERNET_WITH_RDMA
-
-#define FUNC_MF_CFG_FUNC_DISABLED		    0x00000008
-
-	/* PRI */
-	/* 0 - low priority, 3 - high priority */
-#define FUNC_MF_CFG_TRANSMIT_PRIORITY_MASK	    0x00000300
-#define FUNC_MF_CFG_TRANSMIT_PRIORITY_SHIFT	    8
-#define FUNC_MF_CFG_TRANSMIT_PRIORITY_DEFAULT	    0x00000000
-
-	/* MINBW, MAXBW */
-	/* value range - 0..100, increments in 100Mbps */
-#define FUNC_MF_CFG_MIN_BW_MASK 		    0x00ff0000
-#define FUNC_MF_CFG_MIN_BW_SHIFT		    16
-#define FUNC_MF_CFG_MIN_BW_DEFAULT		    0x00000000
-#define FUNC_MF_CFG_MAX_BW_MASK 		    0xff000000
-#define FUNC_MF_CFG_MAX_BW_SHIFT		    24
-#define FUNC_MF_CFG_MAX_BW_DEFAULT		    0x64000000
-
-	u32 mac_upper;		/* MAC */
-#define FUNC_MF_CFG_UPPERMAC_MASK		    0x0000ffff
-#define FUNC_MF_CFG_UPPERMAC_SHIFT		    0
-#define FUNC_MF_CFG_UPPERMAC_DEFAULT		    FUNC_MF_CFG_UPPERMAC_MASK
-	u32 mac_lower;
-#define FUNC_MF_CFG_LOWERMAC_DEFAULT		    0xffffffff
-
-	u32 e1hov_tag;	/* VNI */
-#define FUNC_MF_CFG_E1HOV_TAG_MASK		    0x0000ffff
-#define FUNC_MF_CFG_E1HOV_TAG_SHIFT		    0
-#define FUNC_MF_CFG_E1HOV_TAG_DEFAULT		    FUNC_MF_CFG_E1HOV_TAG_MASK
-
-	u32 reserved[2];
-
-};
-
-struct mf_cfg {
-
-	struct shared_mf_cfg	shared_mf_config;
-	struct port_mf_cfg	port_mf_config[PORT_MAX];
-	struct func_mf_cfg	func_mf_config[E1H_FUNC_MAX];
-
-};
-
-
-/****************************************************************************
- * Shared Memory Region 						    *
- ****************************************************************************/
-struct shmem_region {			       /*   SharedMem Offset (size) */
-
-	u32			validity_map[PORT_MAX];  /* 0x0 (4*2 = 0x8) */
-#define SHR_MEM_FORMAT_REV_ID			    ('A'<<24)
-#define SHR_MEM_FORMAT_REV_MASK 		    0xff000000
-	/* validity bits */
-#define SHR_MEM_VALIDITY_PCI_CFG		    0x00100000
-#define SHR_MEM_VALIDITY_MB			    0x00200000
-#define SHR_MEM_VALIDITY_DEV_INFO		    0x00400000
-#define SHR_MEM_VALIDITY_RESERVED		    0x00000007
-	/* One licensing bit should be set */
-#define SHR_MEM_VALIDITY_LIC_KEY_IN_EFFECT_MASK     0x00000038
-#define SHR_MEM_VALIDITY_LIC_MANUF_KEY_IN_EFFECT    0x00000008
-#define SHR_MEM_VALIDITY_LIC_UPGRADE_KEY_IN_EFFECT  0x00000010
-#define SHR_MEM_VALIDITY_LIC_NO_KEY_IN_EFFECT	    0x00000020
-	/* Active MFW */
-#define SHR_MEM_VALIDITY_ACTIVE_MFW_UNKNOWN	    0x00000000
-#define SHR_MEM_VALIDITY_ACTIVE_MFW_IPMI	    0x00000040
-#define SHR_MEM_VALIDITY_ACTIVE_MFW_UMP 	    0x00000080
-#define SHR_MEM_VALIDITY_ACTIVE_MFW_NCSI	    0x000000c0
-#define SHR_MEM_VALIDITY_ACTIVE_MFW_NONE	    0x000001c0
-#define SHR_MEM_VALIDITY_ACTIVE_MFW_MASK	    0x000001c0
-
-	struct shm_dev_info	dev_info;		 /* 0x8     (0x438) */
-
-	struct license_key	drv_lic_key[PORT_MAX];	/* 0x440 (52*2=0x68) */
-
-	/* FW information (for internal FW use) */
-	u32			fw_info_fio_offset;    /* 0x4a8       (0x4) */
-	struct mgmtfw_state	mgmtfw_state;	       /* 0x4ac     (0x1b8) */
-
-	struct drv_port_mb	port_mb[PORT_MAX];     /* 0x664 (16*2=0x20) */
-	struct drv_func_mb	func_mb[E1H_FUNC_MAX];
-
-	struct mf_cfg		mf_cfg;
-
-};						       /* 0x6dc */
-
-
-struct shmem2_region {
-
-	u32			size;
-
-	u32			dcc_support;
-#define SHMEM_DCC_SUPPORT_NONE			    0x00000000
-#define SHMEM_DCC_SUPPORT_DISABLE_ENABLE_PF_TLV     0x00000001
-#define SHMEM_DCC_SUPPORT_BANDWIDTH_ALLOCATION_TLV  0x00000004
-#define SHMEM_DCC_SUPPORT_CHANGE_MAC_ADDRESS_TLV    0x00000008
-#define SHMEM_DCC_SUPPORT_SET_PROTOCOL_TLV	    0x00000040
-#define SHMEM_DCC_SUPPORT_SET_PRIORITY_TLV	    0x00000080
-#define SHMEM_DCC_SUPPORT_DEFAULT		    SHMEM_DCC_SUPPORT_NONE
-
-};
-
-
-struct emac_stats {
-    u32     rx_stat_ifhcinoctets;
-    u32     rx_stat_ifhcinbadoctets;
-    u32     rx_stat_etherstatsfragments;
-    u32     rx_stat_ifhcinucastpkts;
-    u32     rx_stat_ifhcinmulticastpkts;
-    u32     rx_stat_ifhcinbroadcastpkts;
-    u32     rx_stat_dot3statsfcserrors;
-    u32     rx_stat_dot3statsalignmenterrors;
-    u32     rx_stat_dot3statscarriersenseerrors;
-    u32     rx_stat_xonpauseframesreceived;
-    u32     rx_stat_xoffpauseframesreceived;
-    u32     rx_stat_maccontrolframesreceived;
-    u32     rx_stat_xoffstateentered;
-    u32     rx_stat_dot3statsframestoolong;
-    u32     rx_stat_etherstatsjabbers;
-    u32     rx_stat_etherstatsundersizepkts;
-    u32     rx_stat_etherstatspkts64octets;
-    u32     rx_stat_etherstatspkts65octetsto127octets;
-    u32     rx_stat_etherstatspkts128octetsto255octets;
-    u32     rx_stat_etherstatspkts256octetsto511octets;
-    u32     rx_stat_etherstatspkts512octetsto1023octets;
-    u32     rx_stat_etherstatspkts1024octetsto1522octets;
-    u32     rx_stat_etherstatspktsover1522octets;
-
-    u32     rx_stat_falsecarriererrors;
-
-    u32     tx_stat_ifhcoutoctets;
-    u32     tx_stat_ifhcoutbadoctets;
-    u32     tx_stat_etherstatscollisions;
-    u32     tx_stat_outxonsent;
-    u32     tx_stat_outxoffsent;
-    u32     tx_stat_flowcontroldone;
-    u32     tx_stat_dot3statssinglecollisionframes;
-    u32     tx_stat_dot3statsmultiplecollisionframes;
-    u32     tx_stat_dot3statsdeferredtransmissions;
-    u32     tx_stat_dot3statsexcessivecollisions;
-    u32     tx_stat_dot3statslatecollisions;
-    u32     tx_stat_ifhcoutucastpkts;
-    u32     tx_stat_ifhcoutmulticastpkts;
-    u32     tx_stat_ifhcoutbroadcastpkts;
-    u32     tx_stat_etherstatspkts64octets;
-    u32     tx_stat_etherstatspkts65octetsto127octets;
-    u32     tx_stat_etherstatspkts128octetsto255octets;
-    u32     tx_stat_etherstatspkts256octetsto511octets;
-    u32     tx_stat_etherstatspkts512octetsto1023octets;
-    u32     tx_stat_etherstatspkts1024octetsto1522octets;
-    u32     tx_stat_etherstatspktsover1522octets;
-    u32     tx_stat_dot3statsinternalmactransmiterrors;
-};
-
-
-struct bmac_stats {
-    u32     tx_stat_gtpkt_lo;
-    u32     tx_stat_gtpkt_hi;
-    u32     tx_stat_gtxpf_lo;
-    u32     tx_stat_gtxpf_hi;
-    u32     tx_stat_gtfcs_lo;
-    u32     tx_stat_gtfcs_hi;
-    u32     tx_stat_gtmca_lo;
-    u32     tx_stat_gtmca_hi;
-    u32     tx_stat_gtbca_lo;
-    u32     tx_stat_gtbca_hi;
-    u32     tx_stat_gtfrg_lo;
-    u32     tx_stat_gtfrg_hi;
-    u32     tx_stat_gtovr_lo;
-    u32     tx_stat_gtovr_hi;
-    u32     tx_stat_gt64_lo;
-    u32     tx_stat_gt64_hi;
-    u32     tx_stat_gt127_lo;
-    u32     tx_stat_gt127_hi;
-    u32     tx_stat_gt255_lo;
-    u32     tx_stat_gt255_hi;
-    u32     tx_stat_gt511_lo;
-    u32     tx_stat_gt511_hi;
-    u32     tx_stat_gt1023_lo;
-    u32     tx_stat_gt1023_hi;
-    u32     tx_stat_gt1518_lo;
-    u32     tx_stat_gt1518_hi;
-    u32     tx_stat_gt2047_lo;
-    u32     tx_stat_gt2047_hi;
-    u32     tx_stat_gt4095_lo;
-    u32     tx_stat_gt4095_hi;
-    u32     tx_stat_gt9216_lo;
-    u32     tx_stat_gt9216_hi;
-    u32     tx_stat_gt16383_lo;
-    u32     tx_stat_gt16383_hi;
-    u32     tx_stat_gtmax_lo;
-    u32     tx_stat_gtmax_hi;
-    u32     tx_stat_gtufl_lo;
-    u32     tx_stat_gtufl_hi;
-    u32     tx_stat_gterr_lo;
-    u32     tx_stat_gterr_hi;
-    u32     tx_stat_gtbyt_lo;
-    u32     tx_stat_gtbyt_hi;
-
-    u32     rx_stat_gr64_lo;
-    u32     rx_stat_gr64_hi;
-    u32     rx_stat_gr127_lo;
-    u32     rx_stat_gr127_hi;
-    u32     rx_stat_gr255_lo;
-    u32     rx_stat_gr255_hi;
-    u32     rx_stat_gr511_lo;
-    u32     rx_stat_gr511_hi;
-    u32     rx_stat_gr1023_lo;
-    u32     rx_stat_gr1023_hi;
-    u32     rx_stat_gr1518_lo;
-    u32     rx_stat_gr1518_hi;
-    u32     rx_stat_gr2047_lo;
-    u32     rx_stat_gr2047_hi;
-    u32     rx_stat_gr4095_lo;
-    u32     rx_stat_gr4095_hi;
-    u32     rx_stat_gr9216_lo;
-    u32     rx_stat_gr9216_hi;
-    u32     rx_stat_gr16383_lo;
-    u32     rx_stat_gr16383_hi;
-    u32     rx_stat_grmax_lo;
-    u32     rx_stat_grmax_hi;
-    u32     rx_stat_grpkt_lo;
-    u32     rx_stat_grpkt_hi;
-    u32     rx_stat_grfcs_lo;
-    u32     rx_stat_grfcs_hi;
-    u32     rx_stat_grmca_lo;
-    u32     rx_stat_grmca_hi;
-    u32     rx_stat_grbca_lo;
-    u32     rx_stat_grbca_hi;
-    u32     rx_stat_grxcf_lo;
-    u32     rx_stat_grxcf_hi;
-    u32     rx_stat_grxpf_lo;
-    u32     rx_stat_grxpf_hi;
-    u32     rx_stat_grxuo_lo;
-    u32     rx_stat_grxuo_hi;
-    u32     rx_stat_grjbr_lo;
-    u32     rx_stat_grjbr_hi;
-    u32     rx_stat_grovr_lo;
-    u32     rx_stat_grovr_hi;
-    u32     rx_stat_grflr_lo;
-    u32     rx_stat_grflr_hi;
-    u32     rx_stat_grmeg_lo;
-    u32     rx_stat_grmeg_hi;
-    u32     rx_stat_grmeb_lo;
-    u32     rx_stat_grmeb_hi;
-    u32     rx_stat_grbyt_lo;
-    u32     rx_stat_grbyt_hi;
-    u32     rx_stat_grund_lo;
-    u32     rx_stat_grund_hi;
-    u32     rx_stat_grfrg_lo;
-    u32     rx_stat_grfrg_hi;
-    u32     rx_stat_grerb_lo;
-    u32     rx_stat_grerb_hi;
-    u32     rx_stat_grfre_lo;
-    u32     rx_stat_grfre_hi;
-    u32     rx_stat_gripj_lo;
-    u32     rx_stat_gripj_hi;
-};
-
-
-union mac_stats {
-    struct emac_stats	emac_stats;
-    struct bmac_stats	bmac_stats;
-};
-
-
-struct mac_stx {
-    /* in_bad_octets */
-    u32     rx_stat_ifhcinbadoctets_hi;
-    u32     rx_stat_ifhcinbadoctets_lo;
-
-    /* out_bad_octets */
-    u32     tx_stat_ifhcoutbadoctets_hi;
-    u32     tx_stat_ifhcoutbadoctets_lo;
-
-    /* crc_receive_errors */
-    u32     rx_stat_dot3statsfcserrors_hi;
-    u32     rx_stat_dot3statsfcserrors_lo;
-    /* alignment_errors */
-    u32     rx_stat_dot3statsalignmenterrors_hi;
-    u32     rx_stat_dot3statsalignmenterrors_lo;
-    /* carrier_sense_errors */
-    u32     rx_stat_dot3statscarriersenseerrors_hi;
-    u32     rx_stat_dot3statscarriersenseerrors_lo;
-    /* false_carrier_detections */
-    u32     rx_stat_falsecarriererrors_hi;
-    u32     rx_stat_falsecarriererrors_lo;
-
-    /* runt_packets_received */
-    u32     rx_stat_etherstatsundersizepkts_hi;
-    u32     rx_stat_etherstatsundersizepkts_lo;
-    /* jabber_packets_received */
-    u32     rx_stat_dot3statsframestoolong_hi;
-    u32     rx_stat_dot3statsframestoolong_lo;
-
-    /* error_runt_packets_received */
-    u32     rx_stat_etherstatsfragments_hi;
-    u32     rx_stat_etherstatsfragments_lo;
-    /* error_jabber_packets_received */
-    u32     rx_stat_etherstatsjabbers_hi;
-    u32     rx_stat_etherstatsjabbers_lo;
-
-    /* control_frames_received */
-    u32     rx_stat_maccontrolframesreceived_hi;
-    u32     rx_stat_maccontrolframesreceived_lo;
-    u32     rx_stat_bmac_xpf_hi;
-    u32     rx_stat_bmac_xpf_lo;
-    u32     rx_stat_bmac_xcf_hi;
-    u32     rx_stat_bmac_xcf_lo;
-
-    /* xoff_state_entered */
-    u32     rx_stat_xoffstateentered_hi;
-    u32     rx_stat_xoffstateentered_lo;
-    /* pause_xon_frames_received */
-    u32     rx_stat_xonpauseframesreceived_hi;
-    u32     rx_stat_xonpauseframesreceived_lo;
-    /* pause_xoff_frames_received */
-    u32     rx_stat_xoffpauseframesreceived_hi;
-    u32     rx_stat_xoffpauseframesreceived_lo;
-    /* pause_xon_frames_transmitted */
-    u32     tx_stat_outxonsent_hi;
-    u32     tx_stat_outxonsent_lo;
-    /* pause_xoff_frames_transmitted */
-    u32     tx_stat_outxoffsent_hi;
-    u32     tx_stat_outxoffsent_lo;
-    /* flow_control_done */
-    u32     tx_stat_flowcontroldone_hi;
-    u32     tx_stat_flowcontroldone_lo;
-
-    /* ether_stats_collisions */
-    u32     tx_stat_etherstatscollisions_hi;
-    u32     tx_stat_etherstatscollisions_lo;
-    /* single_collision_transmit_frames */
-    u32     tx_stat_dot3statssinglecollisionframes_hi;
-    u32     tx_stat_dot3statssinglecollisionframes_lo;
-    /* multiple_collision_transmit_frames */
-    u32     tx_stat_dot3statsmultiplecollisionframes_hi;
-    u32     tx_stat_dot3statsmultiplecollisionframes_lo;
-    /* deferred_transmissions */
-    u32     tx_stat_dot3statsdeferredtransmissions_hi;
-    u32     tx_stat_dot3statsdeferredtransmissions_lo;
-    /* excessive_collision_frames */
-    u32     tx_stat_dot3statsexcessivecollisions_hi;
-    u32     tx_stat_dot3statsexcessivecollisions_lo;
-    /* late_collision_frames */
-    u32     tx_stat_dot3statslatecollisions_hi;
-    u32     tx_stat_dot3statslatecollisions_lo;
-
-    /* frames_transmitted_64_bytes */
-    u32     tx_stat_etherstatspkts64octets_hi;
-    u32     tx_stat_etherstatspkts64octets_lo;
-    /* frames_transmitted_65_127_bytes */
-    u32     tx_stat_etherstatspkts65octetsto127octets_hi;
-    u32     tx_stat_etherstatspkts65octetsto127octets_lo;
-    /* frames_transmitted_128_255_bytes */
-    u32     tx_stat_etherstatspkts128octetsto255octets_hi;
-    u32     tx_stat_etherstatspkts128octetsto255octets_lo;
-    /* frames_transmitted_256_511_bytes */
-    u32     tx_stat_etherstatspkts256octetsto511octets_hi;
-    u32     tx_stat_etherstatspkts256octetsto511octets_lo;
-    /* frames_transmitted_512_1023_bytes */
-    u32     tx_stat_etherstatspkts512octetsto1023octets_hi;
-    u32     tx_stat_etherstatspkts512octetsto1023octets_lo;
-    /* frames_transmitted_1024_1522_bytes */
-    u32     tx_stat_etherstatspkts1024octetsto1522octets_hi;
-    u32     tx_stat_etherstatspkts1024octetsto1522octets_lo;
-    /* frames_transmitted_1523_9022_bytes */
-    u32     tx_stat_etherstatspktsover1522octets_hi;
-    u32     tx_stat_etherstatspktsover1522octets_lo;
-    u32     tx_stat_bmac_2047_hi;
-    u32     tx_stat_bmac_2047_lo;
-    u32     tx_stat_bmac_4095_hi;
-    u32     tx_stat_bmac_4095_lo;
-    u32     tx_stat_bmac_9216_hi;
-    u32     tx_stat_bmac_9216_lo;
-    u32     tx_stat_bmac_16383_hi;
-    u32     tx_stat_bmac_16383_lo;
-
-    /* internal_mac_transmit_errors */
-    u32     tx_stat_dot3statsinternalmactransmiterrors_hi;
-    u32     tx_stat_dot3statsinternalmactransmiterrors_lo;
-
-    /* if_out_discards */
-    u32     tx_stat_bmac_ufl_hi;
-    u32     tx_stat_bmac_ufl_lo;
-};
-
-
-#define MAC_STX_IDX_MAX 		    2
-
-struct host_port_stats {
-    u32 	   host_port_stats_start;
-
-    struct mac_stx mac_stx[MAC_STX_IDX_MAX];
-
-    u32 	   brb_drop_hi;
-    u32 	   brb_drop_lo;
-
-    u32 	   host_port_stats_end;
-};
-
-
-struct host_func_stats {
-    u32     host_func_stats_start;
-
-    u32     total_bytes_received_hi;
-    u32     total_bytes_received_lo;
-
-    u32     total_bytes_transmitted_hi;
-    u32     total_bytes_transmitted_lo;
-
-    u32     total_unicast_packets_received_hi;
-    u32     total_unicast_packets_received_lo;
-
-    u32     total_multicast_packets_received_hi;
-    u32     total_multicast_packets_received_lo;
-
-    u32     total_broadcast_packets_received_hi;
-    u32     total_broadcast_packets_received_lo;
-
-    u32     total_unicast_packets_transmitted_hi;
-    u32     total_unicast_packets_transmitted_lo;
-
-    u32     total_multicast_packets_transmitted_hi;
-    u32     total_multicast_packets_transmitted_lo;
-
-    u32     total_broadcast_packets_transmitted_hi;
-    u32     total_broadcast_packets_transmitted_lo;
-
-    u32     valid_bytes_received_hi;
-    u32     valid_bytes_received_lo;
-
-    u32     host_func_stats_end;
-};
-
-
-#define BCM_5710_FW_MAJOR_VERSION			5
-#define BCM_5710_FW_MINOR_VERSION			2
-#define BCM_5710_FW_REVISION_VERSION			13
-#define BCM_5710_FW_ENGINEERING_VERSION 		0
-#define BCM_5710_FW_COMPILE_FLAGS			1
-
-
-/*
- * attention bits
- */
-struct atten_def_status_block {
-	__le32 attn_bits;
-	__le32 attn_bits_ack;
-	u8 status_block_id;
-	u8 reserved0;
-	__le16 attn_bits_index;
-	__le32 reserved1;
-};
-
-
-/*
- * common data for all protocols
- */
-struct doorbell_hdr {
-	u8 header;
-#define DOORBELL_HDR_RX (0x1<<0)
-#define DOORBELL_HDR_RX_SHIFT 0
-#define DOORBELL_HDR_DB_TYPE (0x1<<1)
-#define DOORBELL_HDR_DB_TYPE_SHIFT 1
-#define DOORBELL_HDR_DPM_SIZE (0x3<<2)
-#define DOORBELL_HDR_DPM_SIZE_SHIFT 2
-#define DOORBELL_HDR_CONN_TYPE (0xF<<4)
-#define DOORBELL_HDR_CONN_TYPE_SHIFT 4
-};
-
-/*
- * doorbell message sent to the chip
- */
-struct doorbell {
-#if defined(__BIG_ENDIAN)
-	u16 zero_fill2;
-	u8 zero_fill1;
-	struct doorbell_hdr header;
-#elif defined(__LITTLE_ENDIAN)
-	struct doorbell_hdr header;
-	u8 zero_fill1;
-	u16 zero_fill2;
-#endif
-};
-
-
-/*
- * doorbell message sent to the chip
- */
-struct doorbell_set_prod {
-#if defined(__BIG_ENDIAN)
-	u16 prod;
-	u8 zero_fill1;
-	struct doorbell_hdr header;
-#elif defined(__LITTLE_ENDIAN)
-	struct doorbell_hdr header;
-	u8 zero_fill1;
-	u16 prod;
-#endif
-};
-
-
-/*
- * IGU driver acknowledgement register
- */
-struct igu_ack_register {
-#if defined(__BIG_ENDIAN)
-	u16 sb_id_and_flags;
-#define IGU_ACK_REGISTER_STATUS_BLOCK_ID (0x1F<<0)
-#define IGU_ACK_REGISTER_STATUS_BLOCK_ID_SHIFT 0
-#define IGU_ACK_REGISTER_STORM_ID (0x7<<5)
-#define IGU_ACK_REGISTER_STORM_ID_SHIFT 5
-#define IGU_ACK_REGISTER_UPDATE_INDEX (0x1<<8)
-#define IGU_ACK_REGISTER_UPDATE_INDEX_SHIFT 8
-#define IGU_ACK_REGISTER_INTERRUPT_MODE (0x3<<9)
-#define IGU_ACK_REGISTER_INTERRUPT_MODE_SHIFT 9
-#define IGU_ACK_REGISTER_RESERVED (0x1F<<11)
-#define IGU_ACK_REGISTER_RESERVED_SHIFT 11
-	u16 status_block_index;
-#elif defined(__LITTLE_ENDIAN)
-	u16 status_block_index;
-	u16 sb_id_and_flags;
-#define IGU_ACK_REGISTER_STATUS_BLOCK_ID (0x1F<<0)
-#define IGU_ACK_REGISTER_STATUS_BLOCK_ID_SHIFT 0
-#define IGU_ACK_REGISTER_STORM_ID (0x7<<5)
-#define IGU_ACK_REGISTER_STORM_ID_SHIFT 5
-#define IGU_ACK_REGISTER_UPDATE_INDEX (0x1<<8)
-#define IGU_ACK_REGISTER_UPDATE_INDEX_SHIFT 8
-#define IGU_ACK_REGISTER_INTERRUPT_MODE (0x3<<9)
-#define IGU_ACK_REGISTER_INTERRUPT_MODE_SHIFT 9
-#define IGU_ACK_REGISTER_RESERVED (0x1F<<11)
-#define IGU_ACK_REGISTER_RESERVED_SHIFT 11
-#endif
-};
-
-
-/*
- * IGU driver acknowledgement register
- */
-struct igu_backward_compatible {
-	u32 sb_id_and_flags;
-#define IGU_BACKWARD_COMPATIBLE_SB_INDEX (0xFFFF<<0)
-#define IGU_BACKWARD_COMPATIBLE_SB_INDEX_SHIFT 0
-#define IGU_BACKWARD_COMPATIBLE_SB_SELECT (0x1F<<16)
-#define IGU_BACKWARD_COMPATIBLE_SB_SELECT_SHIFT 16
-#define IGU_BACKWARD_COMPATIBLE_SEGMENT_ACCESS (0x7<<21)
-#define IGU_BACKWARD_COMPATIBLE_SEGMENT_ACCESS_SHIFT 21
-#define IGU_BACKWARD_COMPATIBLE_BUPDATE (0x1<<24)
-#define IGU_BACKWARD_COMPATIBLE_BUPDATE_SHIFT 24
-#define IGU_BACKWARD_COMPATIBLE_ENABLE_INT (0x3<<25)
-#define IGU_BACKWARD_COMPATIBLE_ENABLE_INT_SHIFT 25
-#define IGU_BACKWARD_COMPATIBLE_RESERVED_0 (0x1F<<27)
-#define IGU_BACKWARD_COMPATIBLE_RESERVED_0_SHIFT 27
-	u32 reserved_2;
-};
-
-
-/*
- * IGU driver acknowledgement register
- */
-struct igu_regular {
-	u32 sb_id_and_flags;
-#define IGU_REGULAR_SB_INDEX (0xFFFFF<<0)
-#define IGU_REGULAR_SB_INDEX_SHIFT 0
-#define IGU_REGULAR_RESERVED0 (0x1<<20)
-#define IGU_REGULAR_RESERVED0_SHIFT 20
-#define IGU_REGULAR_SEGMENT_ACCESS (0x7<<21)
-#define IGU_REGULAR_SEGMENT_ACCESS_SHIFT 21
-#define IGU_REGULAR_BUPDATE (0x1<<24)
-#define IGU_REGULAR_BUPDATE_SHIFT 24
-#define IGU_REGULAR_ENABLE_INT (0x3<<25)
-#define IGU_REGULAR_ENABLE_INT_SHIFT 25
-#define IGU_REGULAR_RESERVED_1 (0x1<<27)
-#define IGU_REGULAR_RESERVED_1_SHIFT 27
-#define IGU_REGULAR_CLEANUP_TYPE (0x3<<28)
-#define IGU_REGULAR_CLEANUP_TYPE_SHIFT 28
-#define IGU_REGULAR_CLEANUP_SET (0x1<<30)
-#define IGU_REGULAR_CLEANUP_SET_SHIFT 30
-#define IGU_REGULAR_BCLEANUP (0x1<<31)
-#define IGU_REGULAR_BCLEANUP_SHIFT 31
-	u32 reserved_2;
-};
-
-/*
- * IGU driver acknowledgement register
- */
-union igu_consprod_reg {
-	struct igu_regular regular;
-	struct igu_backward_compatible backward_compatible;
-};
-
-
-/*
- * Parser parsing flags field
- */
-struct parsing_flags {
-	__le16 flags;
-#define PARSING_FLAGS_ETHERNET_ADDRESS_TYPE (0x1<<0)
-#define PARSING_FLAGS_ETHERNET_ADDRESS_TYPE_SHIFT 0
-#define PARSING_FLAGS_VLAN (0x1<<1)
-#define PARSING_FLAGS_VLAN_SHIFT 1
-#define PARSING_FLAGS_EXTRA_VLAN (0x1<<2)
-#define PARSING_FLAGS_EXTRA_VLAN_SHIFT 2
-#define PARSING_FLAGS_OVER_ETHERNET_PROTOCOL (0x3<<3)
-#define PARSING_FLAGS_OVER_ETHERNET_PROTOCOL_SHIFT 3
-#define PARSING_FLAGS_IP_OPTIONS (0x1<<5)
-#define PARSING_FLAGS_IP_OPTIONS_SHIFT 5
-#define PARSING_FLAGS_FRAGMENTATION_STATUS (0x1<<6)
-#define PARSING_FLAGS_FRAGMENTATION_STATUS_SHIFT 6
-#define PARSING_FLAGS_OVER_IP_PROTOCOL (0x3<<7)
-#define PARSING_FLAGS_OVER_IP_PROTOCOL_SHIFT 7
-#define PARSING_FLAGS_PURE_ACK_INDICATION (0x1<<9)
-#define PARSING_FLAGS_PURE_ACK_INDICATION_SHIFT 9
-#define PARSING_FLAGS_TCP_OPTIONS_EXIST (0x1<<10)
-#define PARSING_FLAGS_TCP_OPTIONS_EXIST_SHIFT 10
-#define PARSING_FLAGS_TIME_STAMP_EXIST_FLAG (0x1<<11)
-#define PARSING_FLAGS_TIME_STAMP_EXIST_FLAG_SHIFT 11
-#define PARSING_FLAGS_CONNECTION_MATCH (0x1<<12)
-#define PARSING_FLAGS_CONNECTION_MATCH_SHIFT 12
-#define PARSING_FLAGS_LLC_SNAP (0x1<<13)
-#define PARSING_FLAGS_LLC_SNAP_SHIFT 13
-#define PARSING_FLAGS_RESERVED0 (0x3<<14)
-#define PARSING_FLAGS_RESERVED0_SHIFT 14
-};
-
-
-struct regpair {
-	__le32 lo;
-	__le32 hi;
-};
-
-
-/*
- * dmae command structure
- */
-struct dmae_command {
-	u32 opcode;
-#define DMAE_COMMAND_SRC (0x1<<0)
-#define DMAE_COMMAND_SRC_SHIFT 0
-#define DMAE_COMMAND_DST (0x3<<1)
-#define DMAE_COMMAND_DST_SHIFT 1
-#define DMAE_COMMAND_C_DST (0x1<<3)
-#define DMAE_COMMAND_C_DST_SHIFT 3
-#define DMAE_COMMAND_C_TYPE_ENABLE (0x1<<4)
-#define DMAE_COMMAND_C_TYPE_ENABLE_SHIFT 4
-#define DMAE_COMMAND_C_TYPE_CRC_ENABLE (0x1<<5)
-#define DMAE_COMMAND_C_TYPE_CRC_ENABLE_SHIFT 5
-#define DMAE_COMMAND_C_TYPE_CRC_OFFSET (0x7<<6)
-#define DMAE_COMMAND_C_TYPE_CRC_OFFSET_SHIFT 6
-#define DMAE_COMMAND_ENDIANITY (0x3<<9)
-#define DMAE_COMMAND_ENDIANITY_SHIFT 9
-#define DMAE_COMMAND_PORT (0x1<<11)
-#define DMAE_COMMAND_PORT_SHIFT 11
-#define DMAE_COMMAND_CRC_RESET (0x1<<12)
-#define DMAE_COMMAND_CRC_RESET_SHIFT 12
-#define DMAE_COMMAND_SRC_RESET (0x1<<13)
-#define DMAE_COMMAND_SRC_RESET_SHIFT 13
-#define DMAE_COMMAND_DST_RESET (0x1<<14)
-#define DMAE_COMMAND_DST_RESET_SHIFT 14
-#define DMAE_COMMAND_E1HVN (0x3<<15)
-#define DMAE_COMMAND_E1HVN_SHIFT 15
-#define DMAE_COMMAND_RESERVED0 (0x7FFF<<17)
-#define DMAE_COMMAND_RESERVED0_SHIFT 17
-	u32 src_addr_lo;
-	u32 src_addr_hi;
-	u32 dst_addr_lo;
-	u32 dst_addr_hi;
-#if defined(__BIG_ENDIAN)
-	u16 reserved1;
-	u16 len;
-#elif defined(__LITTLE_ENDIAN)
-	u16 len;
-	u16 reserved1;
-#endif
-	u32 comp_addr_lo;
-	u32 comp_addr_hi;
-	u32 comp_val;
-	u32 crc32;
-	u32 crc32_c;
-#if defined(__BIG_ENDIAN)
-	u16 crc16_c;
-	u16 crc16;
-#elif defined(__LITTLE_ENDIAN)
-	u16 crc16;
-	u16 crc16_c;
-#endif
-#if defined(__BIG_ENDIAN)
-	u16 reserved2;
-	u16 crc_t10;
-#elif defined(__LITTLE_ENDIAN)
-	u16 crc_t10;
-	u16 reserved2;
-#endif
-#if defined(__BIG_ENDIAN)
-	u16 xsum8;
-	u16 xsum16;
-#elif defined(__LITTLE_ENDIAN)
-	u16 xsum16;
-	u16 xsum8;
-#endif
-};
-
-
-struct double_regpair {
-	u32 regpair0_lo;
-	u32 regpair0_hi;
-	u32 regpair1_lo;
-	u32 regpair1_hi;
-};
-
-
-/*
- * The eth storm context of Ustorm (configuration part)
- */
-struct ustorm_eth_st_context_config {
-#if defined(__BIG_ENDIAN)
-	u8 flags;
-#define USTORM_ETH_ST_CONTEXT_CONFIG_ENABLE_MC_ALIGNMENT (0x1<<0)
-#define USTORM_ETH_ST_CONTEXT_CONFIG_ENABLE_MC_ALIGNMENT_SHIFT 0
-#define USTORM_ETH_ST_CONTEXT_CONFIG_ENABLE_DYNAMIC_HC (0x1<<1)
-#define USTORM_ETH_ST_CONTEXT_CONFIG_ENABLE_DYNAMIC_HC_SHIFT 1
-#define USTORM_ETH_ST_CONTEXT_CONFIG_ENABLE_TPA (0x1<<2)
-#define USTORM_ETH_ST_CONTEXT_CONFIG_ENABLE_TPA_SHIFT 2
-#define USTORM_ETH_ST_CONTEXT_CONFIG_ENABLE_STATISTICS (0x1<<3)
-#define USTORM_ETH_ST_CONTEXT_CONFIG_ENABLE_STATISTICS_SHIFT 3
-#define __USTORM_ETH_ST_CONTEXT_CONFIG_RESERVED0 (0xF<<4)
-#define __USTORM_ETH_ST_CONTEXT_CONFIG_RESERVED0_SHIFT 4
-	u8 status_block_id;
-	u8 clientId;
-	u8 sb_index_numbers;
-#define USTORM_ETH_ST_CONTEXT_CONFIG_CQE_SB_INDEX_NUMBER (0xF<<0)
-#define USTORM_ETH_ST_CONTEXT_CONFIG_CQE_SB_INDEX_NUMBER_SHIFT 0
-#define USTORM_ETH_ST_CONTEXT_CONFIG_BD_SB_INDEX_NUMBER (0xF<<4)
-#define USTORM_ETH_ST_CONTEXT_CONFIG_BD_SB_INDEX_NUMBER_SHIFT 4
-#elif defined(__LITTLE_ENDIAN)
-	u8 sb_index_numbers;
-#define USTORM_ETH_ST_CONTEXT_CONFIG_CQE_SB_INDEX_NUMBER (0xF<<0)
-#define USTORM_ETH_ST_CONTEXT_CONFIG_CQE_SB_INDEX_NUMBER_SHIFT 0
-#define USTORM_ETH_ST_CONTEXT_CONFIG_BD_SB_INDEX_NUMBER (0xF<<4)
-#define USTORM_ETH_ST_CONTEXT_CONFIG_BD_SB_INDEX_NUMBER_SHIFT 4
-	u8 clientId;
-	u8 status_block_id;
-	u8 flags;
-#define USTORM_ETH_ST_CONTEXT_CONFIG_ENABLE_MC_ALIGNMENT (0x1<<0)
-#define USTORM_ETH_ST_CONTEXT_CONFIG_ENABLE_MC_ALIGNMENT_SHIFT 0
-#define USTORM_ETH_ST_CONTEXT_CONFIG_ENABLE_DYNAMIC_HC (0x1<<1)
-#define USTORM_ETH_ST_CONTEXT_CONFIG_ENABLE_DYNAMIC_HC_SHIFT 1
-#define USTORM_ETH_ST_CONTEXT_CONFIG_ENABLE_TPA (0x1<<2)
-#define USTORM_ETH_ST_CONTEXT_CONFIG_ENABLE_TPA_SHIFT 2
-#define USTORM_ETH_ST_CONTEXT_CONFIG_ENABLE_STATISTICS (0x1<<3)
-#define USTORM_ETH_ST_CONTEXT_CONFIG_ENABLE_STATISTICS_SHIFT 3
-#define __USTORM_ETH_ST_CONTEXT_CONFIG_RESERVED0 (0xF<<4)
-#define __USTORM_ETH_ST_CONTEXT_CONFIG_RESERVED0_SHIFT 4
-#endif
-#if defined(__BIG_ENDIAN)
-	u16 bd_buff_size;
-	u8 statistics_counter_id;
-	u8 mc_alignment_log_size;
-#elif defined(__LITTLE_ENDIAN)
-	u8 mc_alignment_log_size;
-	u8 statistics_counter_id;
-	u16 bd_buff_size;
-#endif
-#if defined(__BIG_ENDIAN)
-	u8 __local_sge_prod;
-	u8 __local_bd_prod;
-	u16 sge_buff_size;
-#elif defined(__LITTLE_ENDIAN)
-	u16 sge_buff_size;
-	u8 __local_bd_prod;
-	u8 __local_sge_prod;
-#endif
-#if defined(__BIG_ENDIAN)
-	u16 __sdm_bd_expected_counter;
-	u8 cstorm_agg_int;
-	u8 __expected_bds_on_ram;
-#elif defined(__LITTLE_ENDIAN)
-	u8 __expected_bds_on_ram;
-	u8 cstorm_agg_int;
-	u16 __sdm_bd_expected_counter;
-#endif
-#if defined(__BIG_ENDIAN)
-	u16 __ring_data_ram_addr;
-	u16 __hc_cstorm_ram_addr;
-#elif defined(__LITTLE_ENDIAN)
-	u16 __hc_cstorm_ram_addr;
-	u16 __ring_data_ram_addr;
-#endif
-#if defined(__BIG_ENDIAN)
-	u8 reserved1;
-	u8 max_sges_for_packet;
-	u16 __bd_ring_ram_addr;
-#elif defined(__LITTLE_ENDIAN)
-	u16 __bd_ring_ram_addr;
-	u8 max_sges_for_packet;
-	u8 reserved1;
-#endif
-	u32 bd_page_base_lo;
-	u32 bd_page_base_hi;
-	u32 sge_page_base_lo;
-	u32 sge_page_base_hi;
-	struct regpair reserved2;
-};
-
-/*
- * The eth Rx Buffer Descriptor
- */
-struct eth_rx_bd {
-	__le32 addr_lo;
-	__le32 addr_hi;
-};
-
-/*
- * The eth Rx SGE Descriptor
- */
-struct eth_rx_sge {
-	__le32 addr_lo;
-	__le32 addr_hi;
-};
-
-/*
- * Local BDs and SGEs rings (in ETH)
- */
-struct eth_local_rx_rings {
-	struct eth_rx_bd __local_bd_ring[8];
-	struct eth_rx_sge __local_sge_ring[10];
-};
-
-/*
- * The eth storm context of Ustorm
- */
-struct ustorm_eth_st_context {
-	struct ustorm_eth_st_context_config common;
-	struct eth_local_rx_rings __rings;
-};
-
-/*
- * The eth storm context of Tstorm
- */
-struct tstorm_eth_st_context {
-	u32 __reserved0[28];
-};
-
-/*
- * The eth aggregative context section of Xstorm
- */
-struct xstorm_eth_extra_ag_context_section {
-#if defined(__BIG_ENDIAN)
-	u8 __tcp_agg_vars1;
-	u8 __reserved50;
-	u16 __mss;
-#elif defined(__LITTLE_ENDIAN)
-	u16 __mss;
-	u8 __reserved50;
-	u8 __tcp_agg_vars1;
-#endif
-	u32 __snd_nxt;
-	u32 __tx_wnd;
-	u32 __snd_una;
-	u32 __reserved53;
-#if defined(__BIG_ENDIAN)
-	u8 __agg_val8_th;
-	u8 __agg_val8;
-	u16 __tcp_agg_vars2;
-#elif defined(__LITTLE_ENDIAN)
-	u16 __tcp_agg_vars2;
-	u8 __agg_val8;
-	u8 __agg_val8_th;
-#endif
-	u32 __reserved58;
-	u32 __reserved59;
-	u32 __reserved60;
-	u32 __reserved61;
-#if defined(__BIG_ENDIAN)
-	u16 __agg_val7_th;
-	u16 __agg_val7;
-#elif defined(__LITTLE_ENDIAN)
-	u16 __agg_val7;
-	u16 __agg_val7_th;
-#endif
-#if defined(__BIG_ENDIAN)
-	u8 __tcp_agg_vars5;
-	u8 __tcp_agg_vars4;
-	u8 __tcp_agg_vars3;
-	u8 __reserved62;
-#elif defined(__LITTLE_ENDIAN)
-	u8 __reserved62;
-	u8 __tcp_agg_vars3;
-	u8 __tcp_agg_vars4;
-	u8 __tcp_agg_vars5;
-#endif
-	u32 __tcp_agg_vars6;
-#if defined(__BIG_ENDIAN)
-	u16 __agg_misc6;
-	u16 __tcp_agg_vars7;
-#elif defined(__LITTLE_ENDIAN)
-	u16 __tcp_agg_vars7;
-	u16 __agg_misc6;
-#endif
-	u32 __agg_val10;
-	u32 __agg_val10_th;
-#if defined(__BIG_ENDIAN)
-	u16 __reserved3;
-	u8 __reserved2;
-	u8 __da_only_cnt;
-#elif defined(__LITTLE_ENDIAN)
-	u8 __da_only_cnt;
-	u8 __reserved2;
-	u16 __reserved3;
-#endif
-};
-
-/*
- * The eth aggregative context of Xstorm
- */
-struct xstorm_eth_ag_context {
-#if defined(__BIG_ENDIAN)
-	u16 agg_val1;
-	u8 __agg_vars1;
-	u8 __state;
-#elif defined(__LITTLE_ENDIAN)
-	u8 __state;
-	u8 __agg_vars1;
-	u16 agg_val1;
-#endif
-#if defined(__BIG_ENDIAN)
-	u8 cdu_reserved;
-	u8 __agg_vars4;
-	u8 __agg_vars3;
-	u8 __agg_vars2;
-#elif defined(__LITTLE_ENDIAN)
-	u8 __agg_vars2;
-	u8 __agg_vars3;
-	u8 __agg_vars4;
-	u8 cdu_reserved;
-#endif
-	u32 __bd_prod;
-#if defined(__BIG_ENDIAN)
-	u16 __agg_vars5;
-	u16 __agg_val4_th;
-#elif defined(__LITTLE_ENDIAN)
-	u16 __agg_val4_th;
-	u16 __agg_vars5;
-#endif
-	struct xstorm_eth_extra_ag_context_section __extra_section;
-#if defined(__BIG_ENDIAN)
-	u16 __agg_vars7;
-	u8 __agg_val3_th;
-	u8 __agg_vars6;
-#elif defined(__LITTLE_ENDIAN)
-	u8 __agg_vars6;
-	u8 __agg_val3_th;
-	u16 __agg_vars7;
-#endif
-#if defined(__BIG_ENDIAN)
-	u16 __agg_val11_th;
-	u16 __agg_val11;
-#elif defined(__LITTLE_ENDIAN)
-	u16 __agg_val11;
-	u16 __agg_val11_th;
-#endif
-#if defined(__BIG_ENDIAN)
-	u8 __reserved1;
-	u8 __agg_val6_th;
-	u16 __agg_val9;
-#elif defined(__LITTLE_ENDIAN)
-	u16 __agg_val9;
-	u8 __agg_val6_th;
-	u8 __reserved1;
-#endif
-#if defined(__BIG_ENDIAN)
-	u16 __agg_val2_th;
-	u16 __agg_val2;
-#elif defined(__LITTLE_ENDIAN)
-	u16 __agg_val2;
-	u16 __agg_val2_th;
-#endif
-	u32 __agg_vars8;
-#if defined(__BIG_ENDIAN)
-	u16 __agg_misc0;
-	u16 __agg_val4;
-#elif defined(__LITTLE_ENDIAN)
-	u16 __agg_val4;
-	u16 __agg_misc0;
-#endif
-#if defined(__BIG_ENDIAN)
-	u8 __agg_val3;
-	u8 __agg_val6;
-	u8 __agg_val5_th;
-	u8 __agg_val5;
-#elif defined(__LITTLE_ENDIAN)
-	u8 __agg_val5;
-	u8 __agg_val5_th;
-	u8 __agg_val6;
-	u8 __agg_val3;
-#endif
-#if defined(__BIG_ENDIAN)
-	u16 __agg_misc1;
-	u16 __bd_ind_max_val;
-#elif defined(__LITTLE_ENDIAN)
-	u16 __bd_ind_max_val;
-	u16 __agg_misc1;
-#endif
-	u32 __reserved57;
-	u32 __agg_misc4;
-	u32 __agg_misc5;
-};
-
-/*
- * The eth extra aggregative context section of Tstorm
- */
-struct tstorm_eth_extra_ag_context_section {
-	u32 __agg_val1;
-#if defined(__BIG_ENDIAN)
-	u8 __tcp_agg_vars2;
-	u8 __agg_val3;
-	u16 __agg_val2;
-#elif defined(__LITTLE_ENDIAN)
-	u16 __agg_val2;
-	u8 __agg_val3;
-	u8 __tcp_agg_vars2;
-#endif
-#if defined(__BIG_ENDIAN)
-	u16 __agg_val5;
-	u8 __agg_val6;
-	u8 __tcp_agg_vars3;
-#elif defined(__LITTLE_ENDIAN)
-	u8 __tcp_agg_vars3;
-	u8 __agg_val6;
-	u16 __agg_val5;
-#endif
-	u32 __reserved63;
-	u32 __reserved64;
-	u32 __reserved65;
-	u32 __reserved66;
-	u32 __reserved67;
-	u32 __tcp_agg_vars1;
-	u32 __reserved61;
-	u32 __reserved62;
-	u32 __reserved2;
-};
-
-/*
- * The eth aggregative context of Tstorm
- */
-struct tstorm_eth_ag_context {
-#if defined(__BIG_ENDIAN)
-	u16 __reserved54;
-	u8 __agg_vars1;
-	u8 __state;
-#elif defined(__LITTLE_ENDIAN)
-	u8 __state;
-	u8 __agg_vars1;
-	u16 __reserved54;
-#endif
-#if defined(__BIG_ENDIAN)
-	u16 __agg_val4;
-	u16 __agg_vars2;
-#elif defined(__LITTLE_ENDIAN)
-	u16 __agg_vars2;
-	u16 __agg_val4;
-#endif
-	struct tstorm_eth_extra_ag_context_section __extra_section;
-};
-
-/*
- * The eth aggregative context of Cstorm
- */
-struct cstorm_eth_ag_context {
-	u32 __agg_vars1;
-#if defined(__BIG_ENDIAN)
-	u8 __aux1_th;
-	u8 __aux1_val;
-	u16 __agg_vars2;
-#elif defined(__LITTLE_ENDIAN)
-	u16 __agg_vars2;
-	u8 __aux1_val;
-	u8 __aux1_th;
-#endif
-	u32 __num_of_treated_packet;
-	u32 __last_packet_treated;
-#if defined(__BIG_ENDIAN)
-	u16 __reserved58;
-	u16 __reserved57;
-#elif defined(__LITTLE_ENDIAN)
-	u16 __reserved57;
-	u16 __reserved58;
-#endif
-#if defined(__BIG_ENDIAN)
-	u8 __reserved62;
-	u8 __reserved61;
-	u8 __reserved60;
-	u8 __reserved59;
-#elif defined(__LITTLE_ENDIAN)
-	u8 __reserved59;
-	u8 __reserved60;
-	u8 __reserved61;
-	u8 __reserved62;
-#endif
-#if defined(__BIG_ENDIAN)
-	u16 __reserved64;
-	u16 __reserved63;
-#elif defined(__LITTLE_ENDIAN)
-	u16 __reserved63;
-	u16 __reserved64;
-#endif
-	u32 __reserved65;
-#if defined(__BIG_ENDIAN)
-	u16 __agg_vars3;
-	u16 __rq_inv_cnt;
-#elif defined(__LITTLE_ENDIAN)
-	u16 __rq_inv_cnt;
-	u16 __agg_vars3;
-#endif
-#if defined(__BIG_ENDIAN)
-	u16 __packet_index_th;
-	u16 __packet_index;
-#elif defined(__LITTLE_ENDIAN)
-	u16 __packet_index;
-	u16 __packet_index_th;
-#endif
-};
-
-/*
- * The eth aggregative context of Ustorm
- */
-struct ustorm_eth_ag_context {
-#if defined(__BIG_ENDIAN)
-	u8 __aux_counter_flags;
-	u8 __agg_vars2;
-	u8 __agg_vars1;
-	u8 __state;
-#elif defined(__LITTLE_ENDIAN)
-	u8 __state;
-	u8 __agg_vars1;
-	u8 __agg_vars2;
-	u8 __aux_counter_flags;
-#endif
-#if defined(__BIG_ENDIAN)
-	u8 cdu_usage;
-	u8 __agg_misc2;
-	u16 __agg_misc1;
-#elif defined(__LITTLE_ENDIAN)
-	u16 __agg_misc1;
-	u8 __agg_misc2;
-	u8 cdu_usage;
-#endif
-	u32 __agg_misc4;
-#if defined(__BIG_ENDIAN)
-	u8 __agg_val3_th;
-	u8 __agg_val3;
-	u16 __agg_misc3;
-#elif defined(__LITTLE_ENDIAN)
-	u16 __agg_misc3;
-	u8 __agg_val3;
-	u8 __agg_val3_th;
-#endif
-	u32 __agg_val1;
-	u32 __agg_misc4_th;
-#if defined(__BIG_ENDIAN)
-	u16 __agg_val2_th;
-	u16 __agg_val2;
-#elif defined(__LITTLE_ENDIAN)
-	u16 __agg_val2;
-	u16 __agg_val2_th;
-#endif
-#if defined(__BIG_ENDIAN)
-	u16 __reserved2;
-	u8 __decision_rules;
-	u8 __decision_rule_enable_bits;
-#elif defined(__LITTLE_ENDIAN)
-	u8 __decision_rule_enable_bits;
-	u8 __decision_rules;
-	u16 __reserved2;
-#endif
-};
-
-/*
- * Timers connection context
- */
-struct timers_block_context {
-	u32 __reserved_0;
-	u32 __reserved_1;
-	u32 __reserved_2;
-	u32 flags;
-#define __TIMERS_BLOCK_CONTEXT_NUM_OF_ACTIVE_TIMERS (0x3<<0)
-#define __TIMERS_BLOCK_CONTEXT_NUM_OF_ACTIVE_TIMERS_SHIFT 0
-#define TIMERS_BLOCK_CONTEXT_CONN_VALID_FLG (0x1<<2)
-#define TIMERS_BLOCK_CONTEXT_CONN_VALID_FLG_SHIFT 2
-#define __TIMERS_BLOCK_CONTEXT_RESERVED0 (0x1FFFFFFF<<3)
-#define __TIMERS_BLOCK_CONTEXT_RESERVED0_SHIFT 3
-};
-
-/*
- * structure for easy accessibility to assembler
- */
-struct eth_tx_bd_flags {
-	u8 as_bitfield;
-#define ETH_TX_BD_FLAGS_VLAN_TAG (0x1<<0)
-#define ETH_TX_BD_FLAGS_VLAN_TAG_SHIFT 0
-#define ETH_TX_BD_FLAGS_IP_CSUM (0x1<<1)
-#define ETH_TX_BD_FLAGS_IP_CSUM_SHIFT 1
-#define ETH_TX_BD_FLAGS_L4_CSUM (0x1<<2)
-#define ETH_TX_BD_FLAGS_L4_CSUM_SHIFT 2
-#define ETH_TX_BD_FLAGS_END_BD (0x1<<3)
-#define ETH_TX_BD_FLAGS_END_BD_SHIFT 3
-#define ETH_TX_BD_FLAGS_START_BD (0x1<<4)
-#define ETH_TX_BD_FLAGS_START_BD_SHIFT 4
-#define ETH_TX_BD_FLAGS_HDR_POOL (0x1<<5)
-#define ETH_TX_BD_FLAGS_HDR_POOL_SHIFT 5
-#define ETH_TX_BD_FLAGS_SW_LSO (0x1<<6)
-#define ETH_TX_BD_FLAGS_SW_LSO_SHIFT 6
-#define ETH_TX_BD_FLAGS_IPV6 (0x1<<7)
-#define ETH_TX_BD_FLAGS_IPV6_SHIFT 7
-};
-
-/*
- * The eth Tx Buffer Descriptor
- */
-struct eth_tx_start_bd {
-	__le32 addr_lo;
-	__le32 addr_hi;
-	__le16 nbd;
-	__le16 nbytes;
-	__le16 vlan;
-	struct eth_tx_bd_flags bd_flags;
-	u8 general_data;
-#define ETH_TX_START_BD_HDR_NBDS (0x3F<<0)
-#define ETH_TX_START_BD_HDR_NBDS_SHIFT 0
-#define ETH_TX_START_BD_ETH_ADDR_TYPE (0x3<<6)
-#define ETH_TX_START_BD_ETH_ADDR_TYPE_SHIFT 6
-};
-
-/*
- * Tx regular BD structure
- */
-struct eth_tx_bd {
-	u32 addr_lo;
-	u32 addr_hi;
-	u16 total_pkt_bytes;
-	u16 nbytes;
-	u8 reserved[4];
-};
-
-/*
- * Tx parsing BD structure for ETH,Relevant in START
- */
-struct eth_tx_parse_bd {
-	u8 global_data;
-#define ETH_TX_PARSE_BD_IP_HDR_START_OFFSET (0xF<<0)
-#define ETH_TX_PARSE_BD_IP_HDR_START_OFFSET_SHIFT 0
-#define ETH_TX_PARSE_BD_UDP_CS_FLG (0x1<<4)
-#define ETH_TX_PARSE_BD_UDP_CS_FLG_SHIFT 4
-#define ETH_TX_PARSE_BD_PSEUDO_CS_WITHOUT_LEN (0x1<<5)
-#define ETH_TX_PARSE_BD_PSEUDO_CS_WITHOUT_LEN_SHIFT 5
-#define ETH_TX_PARSE_BD_LLC_SNAP_EN (0x1<<6)
-#define ETH_TX_PARSE_BD_LLC_SNAP_EN_SHIFT 6
-#define ETH_TX_PARSE_BD_NS_FLG (0x1<<7)
-#define ETH_TX_PARSE_BD_NS_FLG_SHIFT 7
-	u8 tcp_flags;
-#define ETH_TX_PARSE_BD_FIN_FLG (0x1<<0)
-#define ETH_TX_PARSE_BD_FIN_FLG_SHIFT 0
-#define ETH_TX_PARSE_BD_SYN_FLG (0x1<<1)
-#define ETH_TX_PARSE_BD_SYN_FLG_SHIFT 1
-#define ETH_TX_PARSE_BD_RST_FLG (0x1<<2)
-#define ETH_TX_PARSE_BD_RST_FLG_SHIFT 2
-#define ETH_TX_PARSE_BD_PSH_FLG (0x1<<3)
-#define ETH_TX_PARSE_BD_PSH_FLG_SHIFT 3
-#define ETH_TX_PARSE_BD_ACK_FLG (0x1<<4)
-#define ETH_TX_PARSE_BD_ACK_FLG_SHIFT 4
-#define ETH_TX_PARSE_BD_URG_FLG (0x1<<5)
-#define ETH_TX_PARSE_BD_URG_FLG_SHIFT 5
-#define ETH_TX_PARSE_BD_ECE_FLG (0x1<<6)
-#define ETH_TX_PARSE_BD_ECE_FLG_SHIFT 6
-#define ETH_TX_PARSE_BD_CWR_FLG (0x1<<7)
-#define ETH_TX_PARSE_BD_CWR_FLG_SHIFT 7
-	u8 ip_hlen;
-	s8 reserved;
-	__le16 total_hlen;
-	__le16 tcp_pseudo_csum;
-	__le16 lso_mss;
-	__le16 ip_id;
-	__le32 tcp_send_seq;
-};
-
-/*
- * The last BD in the BD memory will hold a pointer to the next BD memory
- */
-struct eth_tx_next_bd {
-	__le32 addr_lo;
-	__le32 addr_hi;
-	u8 reserved[8];
-};
-
-/*
- * union for 4 Bd types
- */
-union eth_tx_bd_types {
-	struct eth_tx_start_bd start_bd;
-	struct eth_tx_bd reg_bd;
-	struct eth_tx_parse_bd parse_bd;
-	struct eth_tx_next_bd next_bd;
-};
-
-/*
- * The eth storm context of Xstorm
- */
-struct xstorm_eth_st_context {
-	u32 tx_bd_page_base_lo;
-	u32 tx_bd_page_base_hi;
-#if defined(__BIG_ENDIAN)
-	u16 tx_bd_cons;
-	u8 statistics_data;
-#define XSTORM_ETH_ST_CONTEXT_STATISTICS_COUNTER_ID (0x7F<<0)
-#define XSTORM_ETH_ST_CONTEXT_STATISTICS_COUNTER_ID_SHIFT 0
-#define XSTORM_ETH_ST_CONTEXT_STATISTICS_ENABLE (0x1<<7)
-#define XSTORM_ETH_ST_CONTEXT_STATISTICS_ENABLE_SHIFT 7
-	u8 __local_tx_bd_prod;
-#elif defined(__LITTLE_ENDIAN)
-	u8 __local_tx_bd_prod;
-	u8 statistics_data;
-#define XSTORM_ETH_ST_CONTEXT_STATISTICS_COUNTER_ID (0x7F<<0)
-#define XSTORM_ETH_ST_CONTEXT_STATISTICS_COUNTER_ID_SHIFT 0
-#define XSTORM_ETH_ST_CONTEXT_STATISTICS_ENABLE (0x1<<7)
-#define XSTORM_ETH_ST_CONTEXT_STATISTICS_ENABLE_SHIFT 7
-	u16 tx_bd_cons;
-#endif
-	u32 __reserved1;
-	u32 __reserved2;
-#if defined(__BIG_ENDIAN)
-	u8 __ram_cache_index;
-	u8 __double_buffer_client;
-	u16 __pkt_cons;
-#elif defined(__LITTLE_ENDIAN)
-	u16 __pkt_cons;
-	u8 __double_buffer_client;
-	u8 __ram_cache_index;
-#endif
-#if defined(__BIG_ENDIAN)
-	u16 __statistics_address;
-	u16 __gso_next;
-#elif defined(__LITTLE_ENDIAN)
-	u16 __gso_next;
-	u16 __statistics_address;
-#endif
-#if defined(__BIG_ENDIAN)
-	u8 __local_tx_bd_cons;
-	u8 safc_group_num;
-	u8 safc_group_en;
-	u8 __is_eth_conn;
-#elif defined(__LITTLE_ENDIAN)
-	u8 __is_eth_conn;
-	u8 safc_group_en;
-	u8 safc_group_num;
-	u8 __local_tx_bd_cons;
-#endif
-	union eth_tx_bd_types __bds[13];
-};
-
-/*
- * The eth storm context of Cstorm
- */
-struct cstorm_eth_st_context {
-#if defined(__BIG_ENDIAN)
-	u16 __reserved0;
-	u8 sb_index_number;
-	u8 status_block_id;
-#elif defined(__LITTLE_ENDIAN)
-	u8 status_block_id;
-	u8 sb_index_number;
-	u16 __reserved0;
-#endif
-	u32 __reserved1[3];
-};
-
-/*
- * Ethernet connection context
- */
-struct eth_context {
-	struct ustorm_eth_st_context ustorm_st_context;
-	struct tstorm_eth_st_context tstorm_st_context;
-	struct xstorm_eth_ag_context xstorm_ag_context;
-	struct tstorm_eth_ag_context tstorm_ag_context;
-	struct cstorm_eth_ag_context cstorm_ag_context;
-	struct ustorm_eth_ag_context ustorm_ag_context;
-	struct timers_block_context timers_context;
-	struct xstorm_eth_st_context xstorm_st_context;
-	struct cstorm_eth_st_context cstorm_st_context;
-};
-
-
-/*
- * Ethernet doorbell
- */
-struct eth_tx_doorbell {
-#if defined(__BIG_ENDIAN)
-	u16 npackets;
-	u8 params;
-#define ETH_TX_DOORBELL_NUM_BDS (0x3F<<0)
-#define ETH_TX_DOORBELL_NUM_BDS_SHIFT 0
-#define ETH_TX_DOORBELL_RESERVED_TX_FIN_FLAG (0x1<<6)
-#define ETH_TX_DOORBELL_RESERVED_TX_FIN_FLAG_SHIFT 6
-#define ETH_TX_DOORBELL_SPARE (0x1<<7)
-#define ETH_TX_DOORBELL_SPARE_SHIFT 7
-	struct doorbell_hdr hdr;
-#elif defined(__LITTLE_ENDIAN)
-	struct doorbell_hdr hdr;
-	u8 params;
-#define ETH_TX_DOORBELL_NUM_BDS (0x3F<<0)
-#define ETH_TX_DOORBELL_NUM_BDS_SHIFT 0
-#define ETH_TX_DOORBELL_RESERVED_TX_FIN_FLAG (0x1<<6)
-#define ETH_TX_DOORBELL_RESERVED_TX_FIN_FLAG_SHIFT 6
-#define ETH_TX_DOORBELL_SPARE (0x1<<7)
-#define ETH_TX_DOORBELL_SPARE_SHIFT 7
-	u16 npackets;
-#endif
-};
-
-
-/*
- * cstorm default status block, generated by ustorm
- */
-struct cstorm_def_status_block_u {
-	__le16 index_values[HC_USTORM_DEF_SB_NUM_INDICES];
-	__le16 status_block_index;
-	u8 func;
-	u8 status_block_id;
-	__le32 __flags;
-};
-
-/*
- * cstorm default status block, generated by cstorm
- */
-struct cstorm_def_status_block_c {
-	__le16 index_values[HC_CSTORM_DEF_SB_NUM_INDICES];
-	__le16 status_block_index;
-	u8 func;
-	u8 status_block_id;
-	__le32 __flags;
-};
-
-/*
- * xstorm status block
- */
-struct xstorm_def_status_block {
-	__le16 index_values[HC_XSTORM_DEF_SB_NUM_INDICES];
-	__le16 status_block_index;
-	u8 func;
-	u8 status_block_id;
-	__le32 __flags;
-};
-
-/*
- * tstorm status block
- */
-struct tstorm_def_status_block {
-	__le16 index_values[HC_TSTORM_DEF_SB_NUM_INDICES];
-	__le16 status_block_index;
-	u8 func;
-	u8 status_block_id;
-	__le32 __flags;
-};
-
-/*
- * host status block
- */
-struct host_def_status_block {
-	struct atten_def_status_block atten_status_block;
-	struct cstorm_def_status_block_u u_def_status_block;
-	struct cstorm_def_status_block_c c_def_status_block;
-	struct xstorm_def_status_block x_def_status_block;
-	struct tstorm_def_status_block t_def_status_block;
-};
-
-
-/*
- * cstorm status block, generated by ustorm
- */
-struct cstorm_status_block_u {
-	__le16 index_values[HC_USTORM_SB_NUM_INDICES];
-	__le16 status_block_index;
-	u8 func;
-	u8 status_block_id;
-	__le32 __flags;
-};
-
-/*
- * cstorm status block, generated by cstorm
- */
-struct cstorm_status_block_c {
-	__le16 index_values[HC_CSTORM_SB_NUM_INDICES];
-	__le16 status_block_index;
-	u8 func;
-	u8 status_block_id;
-	__le32 __flags;
-};
-
-/*
- * host status block
- */
-struct host_status_block {
-	struct cstorm_status_block_u u_status_block;
-	struct cstorm_status_block_c c_status_block;
-};
-
-
-/*
- * The data for RSS setup ramrod
- */
-struct eth_client_setup_ramrod_data {
-	u32 client_id;
-	u8 is_rdma;
-	u8 is_fcoe;
-	u16 reserved1;
-};
-
-
-/*
- * regular eth FP CQE parameters struct
- */
-struct eth_fast_path_rx_cqe {
-	u8 type_error_flags;
-#define ETH_FAST_PATH_RX_CQE_TYPE (0x1<<0)
-#define ETH_FAST_PATH_RX_CQE_TYPE_SHIFT 0
-#define ETH_FAST_PATH_RX_CQE_PHY_DECODE_ERR_FLG (0x1<<1)
-#define ETH_FAST_PATH_RX_CQE_PHY_DECODE_ERR_FLG_SHIFT 1
-#define ETH_FAST_PATH_RX_CQE_IP_BAD_XSUM_FLG (0x1<<2)
-#define ETH_FAST_PATH_RX_CQE_IP_BAD_XSUM_FLG_SHIFT 2
-#define ETH_FAST_PATH_RX_CQE_L4_BAD_XSUM_FLG (0x1<<3)
-#define ETH_FAST_PATH_RX_CQE_L4_BAD_XSUM_FLG_SHIFT 3
-#define ETH_FAST_PATH_RX_CQE_START_FLG (0x1<<4)
-#define ETH_FAST_PATH_RX_CQE_START_FLG_SHIFT 4
-#define ETH_FAST_PATH_RX_CQE_END_FLG (0x1<<5)
-#define ETH_FAST_PATH_RX_CQE_END_FLG_SHIFT 5
-#define ETH_FAST_PATH_RX_CQE_RESERVED0 (0x3<<6)
-#define ETH_FAST_PATH_RX_CQE_RESERVED0_SHIFT 6
-	u8 status_flags;
-#define ETH_FAST_PATH_RX_CQE_RSS_HASH_TYPE (0x7<<0)
-#define ETH_FAST_PATH_RX_CQE_RSS_HASH_TYPE_SHIFT 0
-#define ETH_FAST_PATH_RX_CQE_RSS_HASH_FLG (0x1<<3)
-#define ETH_FAST_PATH_RX_CQE_RSS_HASH_FLG_SHIFT 3
-#define ETH_FAST_PATH_RX_CQE_BROADCAST_FLG (0x1<<4)
-#define ETH_FAST_PATH_RX_CQE_BROADCAST_FLG_SHIFT 4
-#define ETH_FAST_PATH_RX_CQE_MAC_MATCH_FLG (0x1<<5)
-#define ETH_FAST_PATH_RX_CQE_MAC_MATCH_FLG_SHIFT 5
-#define ETH_FAST_PATH_RX_CQE_IP_XSUM_NO_VALIDATION_FLG (0x1<<6)
-#define ETH_FAST_PATH_RX_CQE_IP_XSUM_NO_VALIDATION_FLG_SHIFT 6
-#define ETH_FAST_PATH_RX_CQE_L4_XSUM_NO_VALIDATION_FLG (0x1<<7)
-#define ETH_FAST_PATH_RX_CQE_L4_XSUM_NO_VALIDATION_FLG_SHIFT 7
-	u8 placement_offset;
-	u8 queue_index;
-	__le32 rss_hash_result;
-	__le16 vlan_tag;
-	__le16 pkt_len;
-	__le16 len_on_bd;
-	struct parsing_flags pars_flags;
-	__le16 sgl[8];
-};
-
-
-/*
- * The data for RSS setup ramrod
- */
-struct eth_halt_ramrod_data {
-	u32 client_id;
-	u32 reserved0;
-};
-
-
-/*
- * The data for statistics query ramrod
- */
-struct eth_query_ramrod_data {
-#if defined(__BIG_ENDIAN)
-	u8 reserved0;
-	u8 collect_port;
-	u16 drv_counter;
-#elif defined(__LITTLE_ENDIAN)
-	u16 drv_counter;
-	u8 collect_port;
-	u8 reserved0;
-#endif
-	u32 ctr_id_vector;
-};
-
-
-/*
- * Place holder for ramrods protocol specific data
- */
-struct ramrod_data {
-	__le32 data_lo;
-	__le32 data_hi;
-};
-
-/*
- * union for ramrod data for Ethernet protocol (CQE) (force size of 16 bits)
- */
-union eth_ramrod_data {
-	struct ramrod_data general;
-};
-
-
-/*
- * Eth Rx Cqe structure- general structure for ramrods
- */
-struct common_ramrod_eth_rx_cqe {
-	u8 ramrod_type;
-#define COMMON_RAMROD_ETH_RX_CQE_TYPE (0x1<<0)
-#define COMMON_RAMROD_ETH_RX_CQE_TYPE_SHIFT 0
-#define COMMON_RAMROD_ETH_RX_CQE_ERROR (0x1<<1)
-#define COMMON_RAMROD_ETH_RX_CQE_ERROR_SHIFT 1
-#define COMMON_RAMROD_ETH_RX_CQE_RESERVED0 (0x3F<<2)
-#define COMMON_RAMROD_ETH_RX_CQE_RESERVED0_SHIFT 2
-	u8 conn_type;
-	__le16 reserved1;
-	__le32 conn_and_cmd_data;
-#define COMMON_RAMROD_ETH_RX_CQE_CID (0xFFFFFF<<0)
-#define COMMON_RAMROD_ETH_RX_CQE_CID_SHIFT 0
-#define COMMON_RAMROD_ETH_RX_CQE_CMD_ID (0xFF<<24)
-#define COMMON_RAMROD_ETH_RX_CQE_CMD_ID_SHIFT 24
-	struct ramrod_data protocol_data;
-	__le32 reserved2[4];
-};
-
-/*
- * Rx Last CQE in page (in ETH)
- */
-struct eth_rx_cqe_next_page {
-	__le32 addr_lo;
-	__le32 addr_hi;
-	__le32 reserved[6];
-};
-
-/*
- * union for all eth rx cqe types (fix their sizes)
- */
-union eth_rx_cqe {
-	struct eth_fast_path_rx_cqe fast_path_cqe;
-	struct common_ramrod_eth_rx_cqe ramrod_cqe;
-	struct eth_rx_cqe_next_page next_page_cqe;
-};
-
-
-/*
- * common data for all protocols
- */
-struct spe_hdr {
-	__le32 conn_and_cmd_data;
-#define SPE_HDR_CID (0xFFFFFF<<0)
-#define SPE_HDR_CID_SHIFT 0
-#define SPE_HDR_CMD_ID (0xFF<<24)
-#define SPE_HDR_CMD_ID_SHIFT 24
-	__le16 type;
-#define SPE_HDR_CONN_TYPE (0xFF<<0)
-#define SPE_HDR_CONN_TYPE_SHIFT 0
-#define SPE_HDR_COMMON_RAMROD (0xFF<<8)
-#define SPE_HDR_COMMON_RAMROD_SHIFT 8
-	__le16 reserved;
-};
-
-/*
- * Ethernet slow path element
- */
-union eth_specific_data {
-	u8 protocol_data[8];
-	struct regpair mac_config_addr;
-	struct eth_client_setup_ramrod_data client_setup_ramrod_data;
-	struct eth_halt_ramrod_data halt_ramrod_data;
-	struct regpair leading_cqe_addr;
-	struct regpair update_data_addr;
-	struct eth_query_ramrod_data query_ramrod_data;
-};
-
-/*
- * Ethernet slow path element
- */
-struct eth_spe {
-	struct spe_hdr hdr;
-	union eth_specific_data data;
-};
-
-
-/*
- * array of 13 bds as appears in the eth xstorm context
- */
-struct eth_tx_bds_array {
-	union eth_tx_bd_types bds[13];
-};
-
-
-/*
- * Common configuration parameters per function in Tstorm
- */
-struct tstorm_eth_function_common_config {
-#if defined(__BIG_ENDIAN)
-	u8 leading_client_id;
-	u8 rss_result_mask;
-	u16 config_flags;
-#define TSTORM_ETH_FUNCTION_COMMON_CONFIG_RSS_IPV4_CAPABILITY (0x1<<0)
-#define TSTORM_ETH_FUNCTION_COMMON_CONFIG_RSS_IPV4_CAPABILITY_SHIFT 0
-#define TSTORM_ETH_FUNCTION_COMMON_CONFIG_RSS_IPV4_TCP_CAPABILITY (0x1<<1)
-#define TSTORM_ETH_FUNCTION_COMMON_CONFIG_RSS_IPV4_TCP_CAPABILITY_SHIFT 1
-#define TSTORM_ETH_FUNCTION_COMMON_CONFIG_RSS_IPV6_CAPABILITY (0x1<<2)
-#define TSTORM_ETH_FUNCTION_COMMON_CONFIG_RSS_IPV6_CAPABILITY_SHIFT 2
-#define TSTORM_ETH_FUNCTION_COMMON_CONFIG_RSS_IPV6_TCP_CAPABILITY (0x1<<3)
-#define TSTORM_ETH_FUNCTION_COMMON_CONFIG_RSS_IPV6_TCP_CAPABILITY_SHIFT 3
-#define TSTORM_ETH_FUNCTION_COMMON_CONFIG_RSS_MODE (0x7<<4)
-#define TSTORM_ETH_FUNCTION_COMMON_CONFIG_RSS_MODE_SHIFT 4
-#define TSTORM_ETH_FUNCTION_COMMON_CONFIG_DEFAULT_ENABLE (0x1<<7)
-#define TSTORM_ETH_FUNCTION_COMMON_CONFIG_DEFAULT_ENABLE_SHIFT 7
-#define TSTORM_ETH_FUNCTION_COMMON_CONFIG_VLAN_IN_CAM (0x1<<8)
-#define TSTORM_ETH_FUNCTION_COMMON_CONFIG_VLAN_IN_CAM_SHIFT 8
-#define TSTORM_ETH_FUNCTION_COMMON_CONFIG_E1HOV_IN_CAM (0x1<<9)
-#define TSTORM_ETH_FUNCTION_COMMON_CONFIG_E1HOV_IN_CAM_SHIFT 9
-#define TSTORM_ETH_FUNCTION_COMMON_CONFIG_ENABLE_TPA (0x1<<10)
-#define TSTORM_ETH_FUNCTION_COMMON_CONFIG_ENABLE_TPA_SHIFT 10
-#define __TSTORM_ETH_FUNCTION_COMMON_CONFIG_RESERVED0 (0x1F<<11)
-#define __TSTORM_ETH_FUNCTION_COMMON_CONFIG_RESERVED0_SHIFT 11
-#elif defined(__LITTLE_ENDIAN)
-	u16 config_flags;
-#define TSTORM_ETH_FUNCTION_COMMON_CONFIG_RSS_IPV4_CAPABILITY (0x1<<0)
-#define TSTORM_ETH_FUNCTION_COMMON_CONFIG_RSS_IPV4_CAPABILITY_SHIFT 0
-#define TSTORM_ETH_FUNCTION_COMMON_CONFIG_RSS_IPV4_TCP_CAPABILITY (0x1<<1)
-#define TSTORM_ETH_FUNCTION_COMMON_CONFIG_RSS_IPV4_TCP_CAPABILITY_SHIFT 1
-#define TSTORM_ETH_FUNCTION_COMMON_CONFIG_RSS_IPV6_CAPABILITY (0x1<<2)
-#define TSTORM_ETH_FUNCTION_COMMON_CONFIG_RSS_IPV6_CAPABILITY_SHIFT 2
-#define TSTORM_ETH_FUNCTION_COMMON_CONFIG_RSS_IPV6_TCP_CAPABILITY (0x1<<3)
-#define TSTORM_ETH_FUNCTION_COMMON_CONFIG_RSS_IPV6_TCP_CAPABILITY_SHIFT 3
-#define TSTORM_ETH_FUNCTION_COMMON_CONFIG_RSS_MODE (0x7<<4)
-#define TSTORM_ETH_FUNCTION_COMMON_CONFIG_RSS_MODE_SHIFT 4
-#define TSTORM_ETH_FUNCTION_COMMON_CONFIG_DEFAULT_ENABLE (0x1<<7)
-#define TSTORM_ETH_FUNCTION_COMMON_CONFIG_DEFAULT_ENABLE_SHIFT 7
-#define TSTORM_ETH_FUNCTION_COMMON_CONFIG_VLAN_IN_CAM (0x1<<8)
-#define TSTORM_ETH_FUNCTION_COMMON_CONFIG_VLAN_IN_CAM_SHIFT 8
-#define TSTORM_ETH_FUNCTION_COMMON_CONFIG_E1HOV_IN_CAM (0x1<<9)
-#define TSTORM_ETH_FUNCTION_COMMON_CONFIG_E1HOV_IN_CAM_SHIFT 9
-#define TSTORM_ETH_FUNCTION_COMMON_CONFIG_ENABLE_TPA (0x1<<10)
-#define TSTORM_ETH_FUNCTION_COMMON_CONFIG_ENABLE_TPA_SHIFT 10
-#define __TSTORM_ETH_FUNCTION_COMMON_CONFIG_RESERVED0 (0x1F<<11)
-#define __TSTORM_ETH_FUNCTION_COMMON_CONFIG_RESERVED0_SHIFT 11
-	u8 rss_result_mask;
-	u8 leading_client_id;
-#endif
-	u16 vlan_id[2];
-};
-
-/*
- * RSS idirection table update configuration
- */
-struct rss_update_config {
-#if defined(__BIG_ENDIAN)
-	u16 toe_rss_bitmap;
-	u16 flags;
-#define RSS_UPDATE_CONFIG_ETH_UPDATE_ENABLE (0x1<<0)
-#define RSS_UPDATE_CONFIG_ETH_UPDATE_ENABLE_SHIFT 0
-#define RSS_UPDATE_CONFIG_TOE_UPDATE_ENABLE (0x1<<1)
-#define RSS_UPDATE_CONFIG_TOE_UPDATE_ENABLE_SHIFT 1
-#define __RSS_UPDATE_CONFIG_RESERVED0 (0x3FFF<<2)
-#define __RSS_UPDATE_CONFIG_RESERVED0_SHIFT 2
-#elif defined(__LITTLE_ENDIAN)
-	u16 flags;
-#define RSS_UPDATE_CONFIG_ETH_UPDATE_ENABLE (0x1<<0)
-#define RSS_UPDATE_CONFIG_ETH_UPDATE_ENABLE_SHIFT 0
-#define RSS_UPDATE_CONFIG_TOE_UPDATE_ENABLE (0x1<<1)
-#define RSS_UPDATE_CONFIG_TOE_UPDATE_ENABLE_SHIFT 1
-#define __RSS_UPDATE_CONFIG_RESERVED0 (0x3FFF<<2)
-#define __RSS_UPDATE_CONFIG_RESERVED0_SHIFT 2
-	u16 toe_rss_bitmap;
-#endif
-	u32 reserved1;
-};
-
-/*
- * parameters for eth update ramrod
- */
-struct eth_update_ramrod_data {
-	struct tstorm_eth_function_common_config func_config;
-	u8 indirectionTable[128];
-	struct rss_update_config rss_config;
-};
-
-
-/*
- * MAC filtering configuration command header
- */
-struct mac_configuration_hdr {
-	u8 length;
-	u8 offset;
-	u16 client_id;
-	u32 reserved1;
-};
-
-/*
- * MAC address in list for ramrod
- */
-struct tstorm_cam_entry {
-	__le16 lsb_mac_addr;
-	__le16 middle_mac_addr;
-	__le16 msb_mac_addr;
-	__le16 flags;
-#define TSTORM_CAM_ENTRY_PORT_ID (0x1<<0)
-#define TSTORM_CAM_ENTRY_PORT_ID_SHIFT 0
-#define TSTORM_CAM_ENTRY_RSRVVAL0 (0x7<<1)
-#define TSTORM_CAM_ENTRY_RSRVVAL0_SHIFT 1
-#define TSTORM_CAM_ENTRY_RESERVED0 (0xFFF<<4)
-#define TSTORM_CAM_ENTRY_RESERVED0_SHIFT 4
-};
-
-/*
- * MAC filtering: CAM target table entry
- */
-struct tstorm_cam_target_table_entry {
-	u8 flags;
-#define TSTORM_CAM_TARGET_TABLE_ENTRY_BROADCAST (0x1<<0)
-#define TSTORM_CAM_TARGET_TABLE_ENTRY_BROADCAST_SHIFT 0
-#define TSTORM_CAM_TARGET_TABLE_ENTRY_OVERRIDE_VLAN_REMOVAL (0x1<<1)
-#define TSTORM_CAM_TARGET_TABLE_ENTRY_OVERRIDE_VLAN_REMOVAL_SHIFT 1
-#define TSTORM_CAM_TARGET_TABLE_ENTRY_ACTION_TYPE (0x1<<2)
-#define TSTORM_CAM_TARGET_TABLE_ENTRY_ACTION_TYPE_SHIFT 2
-#define TSTORM_CAM_TARGET_TABLE_ENTRY_RDMA_MAC (0x1<<3)
-#define TSTORM_CAM_TARGET_TABLE_ENTRY_RDMA_MAC_SHIFT 3
-#define TSTORM_CAM_TARGET_TABLE_ENTRY_RESERVED0 (0xF<<4)
-#define TSTORM_CAM_TARGET_TABLE_ENTRY_RESERVED0_SHIFT 4
-	u8 reserved1;
-	u16 vlan_id;
-	u32 clients_bit_vector;
-};
-
-/*
- * MAC address in list for ramrod
- */
-struct mac_configuration_entry {
-	struct tstorm_cam_entry cam_entry;
-	struct tstorm_cam_target_table_entry target_table_entry;
-};
-
-/*
- * MAC filtering configuration command
- */
-struct mac_configuration_cmd {
-	struct mac_configuration_hdr hdr;
-	struct mac_configuration_entry config_table[64];
-};
-
-
-/*
- * MAC address in list for ramrod
- */
-struct mac_configuration_entry_e1h {
-	__le16 lsb_mac_addr;
-	__le16 middle_mac_addr;
-	__le16 msb_mac_addr;
-	__le16 vlan_id;
-	__le16 e1hov_id;
-	u8 reserved0;
-	u8 flags;
-#define MAC_CONFIGURATION_ENTRY_E1H_PORT (0x1<<0)
-#define MAC_CONFIGURATION_ENTRY_E1H_PORT_SHIFT 0
-#define MAC_CONFIGURATION_ENTRY_E1H_ACTION_TYPE (0x1<<1)
-#define MAC_CONFIGURATION_ENTRY_E1H_ACTION_TYPE_SHIFT 1
-#define MAC_CONFIGURATION_ENTRY_E1H_RDMA_MAC (0x1<<2)
-#define MAC_CONFIGURATION_ENTRY_E1H_RDMA_MAC_SHIFT 2
-#define MAC_CONFIGURATION_ENTRY_E1H_RESERVED1 (0x1F<<3)
-#define MAC_CONFIGURATION_ENTRY_E1H_RESERVED1_SHIFT 3
-	u32 clients_bit_vector;
-};
-
-/*
- * MAC filtering configuration command
- */
-struct mac_configuration_cmd_e1h {
-	struct mac_configuration_hdr hdr;
-	struct mac_configuration_entry_e1h config_table[32];
-};
-
-
-/*
- * approximate-match multicast filtering for E1H per function in Tstorm
- */
-struct tstorm_eth_approximate_match_multicast_filtering {
-	u32 mcast_add_hash_bit_array[8];
-};
-
-
-/*
- * Configuration parameters per client in Tstorm
- */
-struct tstorm_eth_client_config {
-#if defined(__BIG_ENDIAN)
-	u8 reserved0;
-	u8 statistics_counter_id;
-	u16 mtu;
-#elif defined(__LITTLE_ENDIAN)
-	u16 mtu;
-	u8 statistics_counter_id;
-	u8 reserved0;
-#endif
-#if defined(__BIG_ENDIAN)
-	u16 drop_flags;
-#define TSTORM_ETH_CLIENT_CONFIG_DROP_IP_CS_ERR (0x1<<0)
-#define TSTORM_ETH_CLIENT_CONFIG_DROP_IP_CS_ERR_SHIFT 0
-#define TSTORM_ETH_CLIENT_CONFIG_DROP_TCP_CS_ERR (0x1<<1)
-#define TSTORM_ETH_CLIENT_CONFIG_DROP_TCP_CS_ERR_SHIFT 1
-#define TSTORM_ETH_CLIENT_CONFIG_DROP_TTL0 (0x1<<2)
-#define TSTORM_ETH_CLIENT_CONFIG_DROP_TTL0_SHIFT 2
-#define TSTORM_ETH_CLIENT_CONFIG_DROP_UDP_CS_ERR (0x1<<3)
-#define TSTORM_ETH_CLIENT_CONFIG_DROP_UDP_CS_ERR_SHIFT 3
-#define __TSTORM_ETH_CLIENT_CONFIG_RESERVED2 (0xFFF<<4)
-#define __TSTORM_ETH_CLIENT_CONFIG_RESERVED2_SHIFT 4
-	u16 config_flags;
-#define TSTORM_ETH_CLIENT_CONFIG_VLAN_REM_ENABLE (0x1<<0)
-#define TSTORM_ETH_CLIENT_CONFIG_VLAN_REM_ENABLE_SHIFT 0
-#define TSTORM_ETH_CLIENT_CONFIG_E1HOV_REM_ENABLE (0x1<<1)
-#define TSTORM_ETH_CLIENT_CONFIG_E1HOV_REM_ENABLE_SHIFT 1
-#define TSTORM_ETH_CLIENT_CONFIG_STATSITICS_ENABLE (0x1<<2)
-#define TSTORM_ETH_CLIENT_CONFIG_STATSITICS_ENABLE_SHIFT 2
-#define __TSTORM_ETH_CLIENT_CONFIG_RESERVED1 (0x1FFF<<3)
-#define __TSTORM_ETH_CLIENT_CONFIG_RESERVED1_SHIFT 3
-#elif defined(__LITTLE_ENDIAN)
-	u16 config_flags;
-#define TSTORM_ETH_CLIENT_CONFIG_VLAN_REM_ENABLE (0x1<<0)
-#define TSTORM_ETH_CLIENT_CONFIG_VLAN_REM_ENABLE_SHIFT 0
-#define TSTORM_ETH_CLIENT_CONFIG_E1HOV_REM_ENABLE (0x1<<1)
-#define TSTORM_ETH_CLIENT_CONFIG_E1HOV_REM_ENABLE_SHIFT 1
-#define TSTORM_ETH_CLIENT_CONFIG_STATSITICS_ENABLE (0x1<<2)
-#define TSTORM_ETH_CLIENT_CONFIG_STATSITICS_ENABLE_SHIFT 2
-#define __TSTORM_ETH_CLIENT_CONFIG_RESERVED1 (0x1FFF<<3)
-#define __TSTORM_ETH_CLIENT_CONFIG_RESERVED1_SHIFT 3
-	u16 drop_flags;
-#define TSTORM_ETH_CLIENT_CONFIG_DROP_IP_CS_ERR (0x1<<0)
-#define TSTORM_ETH_CLIENT_CONFIG_DROP_IP_CS_ERR_SHIFT 0
-#define TSTORM_ETH_CLIENT_CONFIG_DROP_TCP_CS_ERR (0x1<<1)
-#define TSTORM_ETH_CLIENT_CONFIG_DROP_TCP_CS_ERR_SHIFT 1
-#define TSTORM_ETH_CLIENT_CONFIG_DROP_TTL0 (0x1<<2)
-#define TSTORM_ETH_CLIENT_CONFIG_DROP_TTL0_SHIFT 2
-#define TSTORM_ETH_CLIENT_CONFIG_DROP_UDP_CS_ERR (0x1<<3)
-#define TSTORM_ETH_CLIENT_CONFIG_DROP_UDP_CS_ERR_SHIFT 3
-#define __TSTORM_ETH_CLIENT_CONFIG_RESERVED2 (0xFFF<<4)
-#define __TSTORM_ETH_CLIENT_CONFIG_RESERVED2_SHIFT 4
-#endif
-};
-
-
-/*
- * MAC filtering configuration parameters per port in Tstorm
- */
-struct tstorm_eth_mac_filter_config {
-	u32 ucast_drop_all;
-	u32 ucast_accept_all;
-	u32 mcast_drop_all;
-	u32 mcast_accept_all;
-	u32 bcast_drop_all;
-	u32 bcast_accept_all;
-	u32 strict_vlan;
-	u32 vlan_filter[2];
-	u32 reserved;
-};
-
-
-/*
- * common flag to indicate existance of TPA.
- */
-struct tstorm_eth_tpa_exist {
-#if defined(__BIG_ENDIAN)
-	u16 reserved1;
-	u8 reserved0;
-	u8 tpa_exist;
-#elif defined(__LITTLE_ENDIAN)
-	u8 tpa_exist;
-	u8 reserved0;
-	u16 reserved1;
-#endif
-	u32 reserved2;
-};
-
-
-/*
- * rx rings pause data for E1h only
- */
-struct ustorm_eth_rx_pause_data_e1h {
-#if defined(__BIG_ENDIAN)
-	u16 bd_thr_low;
-	u16 cqe_thr_low;
-#elif defined(__LITTLE_ENDIAN)
-	u16 cqe_thr_low;
-	u16 bd_thr_low;
-#endif
-#if defined(__BIG_ENDIAN)
-	u16 cos;
-	u16 sge_thr_low;
-#elif defined(__LITTLE_ENDIAN)
-	u16 sge_thr_low;
-	u16 cos;
-#endif
-#if defined(__BIG_ENDIAN)
-	u16 bd_thr_high;
-	u16 cqe_thr_high;
-#elif defined(__LITTLE_ENDIAN)
-	u16 cqe_thr_high;
-	u16 bd_thr_high;
-#endif
-#if defined(__BIG_ENDIAN)
-	u16 reserved0;
-	u16 sge_thr_high;
-#elif defined(__LITTLE_ENDIAN)
-	u16 sge_thr_high;
-	u16 reserved0;
-#endif
-};
-
-
-/*
- * Three RX producers for ETH
- */
-struct ustorm_eth_rx_producers {
-#if defined(__BIG_ENDIAN)
-	u16 bd_prod;
-	u16 cqe_prod;
-#elif defined(__LITTLE_ENDIAN)
-	u16 cqe_prod;
-	u16 bd_prod;
-#endif
-#if defined(__BIG_ENDIAN)
-	u16 reserved;
-	u16 sge_prod;
-#elif defined(__LITTLE_ENDIAN)
-	u16 sge_prod;
-	u16 reserved;
-#endif
-};
-
-
-/*
- * per-port SAFC demo variables
- */
-struct cmng_flags_per_port {
-	u8 con_number[NUM_OF_PROTOCOLS];
-	u32 cmng_enables;
-#define CMNG_FLAGS_PER_PORT_FAIRNESS_VN (0x1<<0)
-#define CMNG_FLAGS_PER_PORT_FAIRNESS_VN_SHIFT 0
-#define CMNG_FLAGS_PER_PORT_RATE_SHAPING_VN (0x1<<1)
-#define CMNG_FLAGS_PER_PORT_RATE_SHAPING_VN_SHIFT 1
-#define CMNG_FLAGS_PER_PORT_FAIRNESS_PROTOCOL (0x1<<2)
-#define CMNG_FLAGS_PER_PORT_FAIRNESS_PROTOCOL_SHIFT 2
-#define CMNG_FLAGS_PER_PORT_RATE_SHAPING_PROTOCOL (0x1<<3)
-#define CMNG_FLAGS_PER_PORT_RATE_SHAPING_PROTOCOL_SHIFT 3
-#define CMNG_FLAGS_PER_PORT_FAIRNESS_COS (0x1<<4)
-#define CMNG_FLAGS_PER_PORT_FAIRNESS_COS_SHIFT 4
-#define __CMNG_FLAGS_PER_PORT_RESERVED0 (0x7FFFFFF<<5)
-#define __CMNG_FLAGS_PER_PORT_RESERVED0_SHIFT 5
-};
-
-
-/*
- * per-port rate shaping variables
- */
-struct rate_shaping_vars_per_port {
-	u32 rs_periodic_timeout;
-	u32 rs_threshold;
-};
-
-/*
- * per-port fairness variables
- */
-struct fairness_vars_per_port {
-	u32 upper_bound;
-	u32 fair_threshold;
-	u32 fairness_timeout;
-};
-
-/*
- * per-port SAFC variables
- */
-struct safc_struct_per_port {
-#if defined(__BIG_ENDIAN)
-	u16 __reserved1;
-	u8 __reserved0;
-	u8 safc_timeout_usec;
-#elif defined(__LITTLE_ENDIAN)
-	u8 safc_timeout_usec;
-	u8 __reserved0;
-	u16 __reserved1;
-#endif
-	u16 cos_to_pause_mask[NUM_OF_SAFC_BITS];
-};
-
-/*
- * Per-port congestion management variables
- */
-struct cmng_struct_per_port {
-	struct rate_shaping_vars_per_port rs_vars;
-	struct fairness_vars_per_port fair_vars;
-	struct safc_struct_per_port safc_vars;
-	struct cmng_flags_per_port flags;
-};
-
-
-/*
- * Dynamic host coalescing init parameters
- */
-struct dynamic_hc_config {
-	u32 threshold[3];
-	u8 shift_per_protocol[HC_USTORM_SB_NUM_INDICES];
-	u8 hc_timeout0[HC_USTORM_SB_NUM_INDICES];
-	u8 hc_timeout1[HC_USTORM_SB_NUM_INDICES];
-	u8 hc_timeout2[HC_USTORM_SB_NUM_INDICES];
-	u8 hc_timeout3[HC_USTORM_SB_NUM_INDICES];
-};
-
-
-/*
- * Protocol-common statistics collected by the Xstorm (per client)
- */
-struct xstorm_per_client_stats {
-	__le32 reserved0;
-	__le32 unicast_pkts_sent;
-	struct regpair unicast_bytes_sent;
-	struct regpair multicast_bytes_sent;
-	__le32 multicast_pkts_sent;
-	__le32 broadcast_pkts_sent;
-	struct regpair broadcast_bytes_sent;
-	__le16 stats_counter;
-	__le16 reserved1;
-	__le32 reserved2;
-};
-
-/*
- * Common statistics collected by the Xstorm (per port)
- */
-struct xstorm_common_stats {
- struct xstorm_per_client_stats client_statistics[MAX_X_STAT_COUNTER_ID];
-};
-
-/*
- * Protocol-common statistics collected by the Tstorm (per port)
- */
-struct tstorm_per_port_stats {
-	__le32 mac_filter_discard;
-	__le32 xxoverflow_discard;
-	__le32 brb_truncate_discard;
-	__le32 mac_discard;
-};
-
-/*
- * Protocol-common statistics collected by the Tstorm (per client)
- */
-struct tstorm_per_client_stats {
-	struct regpair rcv_unicast_bytes;
-	struct regpair rcv_broadcast_bytes;
-	struct regpair rcv_multicast_bytes;
-	struct regpair rcv_error_bytes;
-	__le32 checksum_discard;
-	__le32 packets_too_big_discard;
-	__le32 rcv_unicast_pkts;
-	__le32 rcv_broadcast_pkts;
-	__le32 rcv_multicast_pkts;
-	__le32 no_buff_discard;
-	__le32 ttl0_discard;
-	__le16 stats_counter;
-	__le16 reserved0;
-};
-
-/*
- * Protocol-common statistics collected by the Tstorm
- */
-struct tstorm_common_stats {
-	struct tstorm_per_port_stats port_statistics;
- struct tstorm_per_client_stats client_statistics[MAX_T_STAT_COUNTER_ID];
-};
-
-/*
- * Protocol-common statistics collected by the Ustorm (per client)
- */
-struct ustorm_per_client_stats {
-	struct regpair ucast_no_buff_bytes;
-	struct regpair mcast_no_buff_bytes;
-	struct regpair bcast_no_buff_bytes;
-	__le32 ucast_no_buff_pkts;
-	__le32 mcast_no_buff_pkts;
-	__le32 bcast_no_buff_pkts;
-	__le16 stats_counter;
-	__le16 reserved0;
-};
-
-/*
- * Protocol-common statistics collected by the Ustorm
- */
-struct ustorm_common_stats {
- struct ustorm_per_client_stats client_statistics[MAX_U_STAT_COUNTER_ID];
-};
-
-/*
- * Eth statistics query structure for the eth_stats_query ramrod
- */
-struct eth_stats_query {
-	struct xstorm_common_stats xstorm_common;
-	struct tstorm_common_stats tstorm_common;
-	struct ustorm_common_stats ustorm_common;
-};
-
-
-/*
- * per-vnic fairness variables
- */
-struct fairness_vars_per_vn {
-	u32 cos_credit_delta[MAX_COS_NUMBER];
-	u32 protocol_credit_delta[NUM_OF_PROTOCOLS];
-	u32 vn_credit_delta;
-	u32 __reserved0;
-};
-
-
-/*
- * FW version stored in the Xstorm RAM
- */
-struct fw_version {
-#if defined(__BIG_ENDIAN)
-	u8 engineering;
-	u8 revision;
-	u8 minor;
-	u8 major;
-#elif defined(__LITTLE_ENDIAN)
-	u8 major;
-	u8 minor;
-	u8 revision;
-	u8 engineering;
-#endif
-	u32 flags;
-#define FW_VERSION_OPTIMIZED (0x1<<0)
-#define FW_VERSION_OPTIMIZED_SHIFT 0
-#define FW_VERSION_BIG_ENDIEN (0x1<<1)
-#define FW_VERSION_BIG_ENDIEN_SHIFT 1
-#define FW_VERSION_CHIP_VERSION (0x3<<2)
-#define FW_VERSION_CHIP_VERSION_SHIFT 2
-#define __FW_VERSION_RESERVED (0xFFFFFFF<<4)
-#define __FW_VERSION_RESERVED_SHIFT 4
-};
-
-
-/*
- * FW version stored in first line of pram
- */
-struct pram_fw_version {
-	u8 major;
-	u8 minor;
-	u8 revision;
-	u8 engineering;
-	u8 flags;
-#define PRAM_FW_VERSION_OPTIMIZED (0x1<<0)
-#define PRAM_FW_VERSION_OPTIMIZED_SHIFT 0
-#define PRAM_FW_VERSION_STORM_ID (0x3<<1)
-#define PRAM_FW_VERSION_STORM_ID_SHIFT 1
-#define PRAM_FW_VERSION_BIG_ENDIEN (0x1<<3)
-#define PRAM_FW_VERSION_BIG_ENDIEN_SHIFT 3
-#define PRAM_FW_VERSION_CHIP_VERSION (0x3<<4)
-#define PRAM_FW_VERSION_CHIP_VERSION_SHIFT 4
-#define __PRAM_FW_VERSION_RESERVED0 (0x3<<6)
-#define __PRAM_FW_VERSION_RESERVED0_SHIFT 6
-};
-
-
-/*
- * The send queue element
- */
-struct protocol_common_spe {
-	struct spe_hdr hdr;
-	struct regpair phy_address;
-};
-
-
-/*
- * a single rate shaping counter. can be used as protocol or vnic counter
- */
-struct rate_shaping_counter {
-	u32 quota;
-#if defined(__BIG_ENDIAN)
-	u16 __reserved0;
-	u16 rate;
-#elif defined(__LITTLE_ENDIAN)
-	u16 rate;
-	u16 __reserved0;
-#endif
-};
-
-
-/*
- * per-vnic rate shaping variables
- */
-struct rate_shaping_vars_per_vn {
-	struct rate_shaping_counter protocol_counters[NUM_OF_PROTOCOLS];
-	struct rate_shaping_counter vn_counter;
-};
-
-
-/*
- * The send queue element
- */
-struct slow_path_element {
-	struct spe_hdr hdr;
-	u8 protocol_data[8];
-};
-
-
-/*
- * eth/toe flags that indicate if to query
- */
-struct stats_indication_flags {
-	u32 collect_eth;
-	u32 collect_toe;
-};
-
-
diff -r f4bf81a7ff20 drivers/net/bnx2x_init.h
--- a/drivers/net/bnx2x_init.h
+++ /dev/null
@@ -1,152 +0,0 @@
-/* bnx2x_init.h: Broadcom Everest network driver.
- *               Structures and macroes needed during the initialization.
- *
- * Copyright (c) 2007-2009 Broadcom Corporation
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation.
- *
- * Maintained by: Eilon Greenstein <eilong@broadcom.com>
- * Written by: Eliezer Tamir
- * Modified by: Vladislav Zolotarov <vladz@broadcom.com>
- */
-
-#ifndef BNX2X_INIT_H
-#define BNX2X_INIT_H
-
-/* RAM0 size in bytes */
-#define STORM_INTMEM_SIZE_E1		0x5800
-#define STORM_INTMEM_SIZE_E1H		0x10000
-#define STORM_INTMEM_SIZE(bp) ((CHIP_IS_E1(bp) ? STORM_INTMEM_SIZE_E1 : \
-						    STORM_INTMEM_SIZE_E1H) / 4)
-
-
-/* Init operation types and structures */
-/* Common for both E1 and E1H */
-#define OP_RD			0x1 /* read single register */
-#define OP_WR			0x2 /* write single register */
-#define OP_IW			0x3 /* write single register using mailbox */
-#define OP_SW			0x4 /* copy a string to the device */
-#define OP_SI			0x5 /* copy a string using mailbox */
-#define OP_ZR			0x6 /* clear memory */
-#define OP_ZP			0x7 /* unzip then copy with DMAE */
-#define OP_WR_64		0x8 /* write 64 bit pattern */
-#define OP_WB			0x9 /* copy a string using DMAE */
-
-/* FPGA and EMUL specific operations */
-#define OP_WR_EMUL		0xa /* write single register on Emulation */
-#define OP_WR_FPGA		0xb /* write single register on FPGA */
-#define OP_WR_ASIC		0xc /* write single register on ASIC */
-
-/* Init stages */
-/* Never reorder stages !!! */
-#define COMMON_STAGE		0
-#define PORT0_STAGE		1
-#define PORT1_STAGE		2
-#define FUNC0_STAGE		3
-#define FUNC1_STAGE		4
-#define FUNC2_STAGE		5
-#define FUNC3_STAGE		6
-#define FUNC4_STAGE		7
-#define FUNC5_STAGE		8
-#define FUNC6_STAGE		9
-#define FUNC7_STAGE		10
-#define STAGE_IDX_MAX		11
-
-#define STAGE_START		0
-#define STAGE_END		1
-
-
-/* Indices of blocks */
-#define PRS_BLOCK		0
-#define SRCH_BLOCK		1
-#define TSDM_BLOCK		2
-#define TCM_BLOCK		3
-#define BRB1_BLOCK		4
-#define TSEM_BLOCK		5
-#define PXPCS_BLOCK		6
-#define EMAC0_BLOCK		7
-#define EMAC1_BLOCK		8
-#define DBU_BLOCK		9
-#define MISC_BLOCK		10
-#define DBG_BLOCK		11
-#define NIG_BLOCK		12
-#define MCP_BLOCK		13
-#define UPB_BLOCK		14
-#define CSDM_BLOCK		15
-#define USDM_BLOCK		16
-#define CCM_BLOCK		17
-#define UCM_BLOCK		18
-#define USEM_BLOCK		19
-#define CSEM_BLOCK		20
-#define XPB_BLOCK		21
-#define DQ_BLOCK		22
-#define TIMERS_BLOCK		23
-#define XSDM_BLOCK		24
-#define QM_BLOCK		25
-#define PBF_BLOCK		26
-#define XCM_BLOCK		27
-#define XSEM_BLOCK		28
-#define CDU_BLOCK		29
-#define DMAE_BLOCK		30
-#define PXP_BLOCK		31
-#define CFC_BLOCK		32
-#define HC_BLOCK		33
-#define PXP2_BLOCK		34
-#define MISC_AEU_BLOCK		35
-#define PGLUE_B_BLOCK		36
-#define IGU_BLOCK		37
-
-
-/* Returns the index of start or end of a specific block stage in ops array*/
-#define BLOCK_OPS_IDX(block, stage, end) \
-			(2*(((block)*STAGE_IDX_MAX) + (stage)) + (end))
-
-
-struct raw_op {
-	u32 op:8;
-	u32 offset:24;
-	u32 raw_data;
-};
-
-struct op_read {
-	u32 op:8;
-	u32 offset:24;
-	u32 pad;
-};
-
-struct op_write {
-	u32 op:8;
-	u32 offset:24;
-	u32 val;
-};
-
-struct op_string_write {
-	u32 op:8;
-	u32 offset:24;
-#ifdef __LITTLE_ENDIAN
-	u16 data_off;
-	u16 data_len;
-#else /* __BIG_ENDIAN */
-	u16 data_len;
-	u16 data_off;
-#endif
-};
-
-struct op_zero {
-	u32 op:8;
-	u32 offset:24;
-	u32 len;
-};
-
-union init_op {
-	struct op_read		read;
-	struct op_write		write;
-	struct op_string_write	str_wr;
-	struct op_zero		zero;
-	struct raw_op		raw;
-};
-
-#endif /* BNX2X_INIT_H */
-
diff -r f4bf81a7ff20 drivers/net/bnx2x_init_ops.h
--- a/drivers/net/bnx2x_init_ops.h
+++ /dev/null
@@ -1,506 +0,0 @@
-/* bnx2x_init_ops.h: Broadcom Everest network driver.
- *               Static functions needed during the initialization.
- *               This file is "included" in bnx2x_main.c.
- *
- * Copyright (c) 2007-2010 Broadcom Corporation
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation.
- *
- * Maintained by: Eilon Greenstein <eilong@broadcom.com>
- * Written by: Vladislav Zolotarov <vladz@broadcom.com>
- */
-
-#ifndef BNX2X_INIT_OPS_H
-#define BNX2X_INIT_OPS_H
-
-static int bnx2x_gunzip(struct bnx2x *bp, const u8 *zbuf, int len);
-
-
-static void bnx2x_init_str_wr(struct bnx2x *bp, u32 addr, const u32 *data,
-			      u32 len)
-{
-	u32 i;
-
-	for (i = 0; i < len; i++)
-		REG_WR(bp, addr + i*4, data[i]);
-}
-
-static void bnx2x_init_ind_wr(struct bnx2x *bp, u32 addr, const u32 *data,
-			      u32 len)
-{
-	u32 i;
-
-	for (i = 0; i < len; i++)
-		REG_WR_IND(bp, addr + i*4, data[i]);
-}
-
-static void bnx2x_write_big_buf(struct bnx2x *bp, u32 addr, u32 len)
-{
-	if (bp->dmae_ready)
-		bnx2x_write_dmae_phys_len(bp, GUNZIP_PHYS(bp), addr, len);
-	else
-		bnx2x_init_str_wr(bp, addr, GUNZIP_BUF(bp), len);
-}
-
-static void bnx2x_init_fill(struct bnx2x *bp, u32 addr, int fill, u32 len)
-{
-	u32 buf_len = (((len*4) > FW_BUF_SIZE) ? FW_BUF_SIZE : (len*4));
-	u32 buf_len32 = buf_len/4;
-	u32 i;
-
-	memset(GUNZIP_BUF(bp), (u8)fill, buf_len);
-
-	for (i = 0; i < len; i += buf_len32) {
-		u32 cur_len = min(buf_len32, len - i);
-
-		bnx2x_write_big_buf(bp, addr + i*4, cur_len);
-	}
-}
-
-static void bnx2x_init_wr_64(struct bnx2x *bp, u32 addr, const u32 *data,
-			     u32 len64)
-{
-	u32 buf_len32 = FW_BUF_SIZE/4;
-	u32 len = len64*2;
-	u64 data64 = 0;
-	u32 i;
-
-	/* 64 bit value is in a blob: first low DWORD, then high DWORD */
-	data64 = HILO_U64((*(data + 1)), (*data));
-
-	len64 = min((u32)(FW_BUF_SIZE/8), len64);
-	for (i = 0; i < len64; i++) {
-		u64 *pdata = ((u64 *)(GUNZIP_BUF(bp))) + i;
-
-		*pdata = data64;
-	}
-
-	for (i = 0; i < len; i += buf_len32) {
-		u32 cur_len = min(buf_len32, len - i);
-
-		bnx2x_write_big_buf(bp, addr + i*4, cur_len);
-	}
-}
-
-/*********************************************************
-   There are different blobs for each PRAM section.
-   In addition, each blob write operation is divided into a few operations
-   in order to decrease the amount of phys. contiguous buffer needed.
-   Thus, when we select a blob the address may be with some offset
-   from the beginning of PRAM section.
-   The same holds for the INT_TABLE sections.
-**********************************************************/
-#define IF_IS_INT_TABLE_ADDR(base, addr) \
-			if (((base) <= (addr)) && ((base) + 0x400 >= (addr)))
-
-#define IF_IS_PRAM_ADDR(base, addr) \
-			if (((base) <= (addr)) && ((base) + 0x40000 >= (addr)))
-
-static const u8 *bnx2x_sel_blob(struct bnx2x *bp, u32 addr, const u8 *data)
-{
-	IF_IS_INT_TABLE_ADDR(TSEM_REG_INT_TABLE, addr)
-		data = INIT_TSEM_INT_TABLE_DATA(bp);
-	else
-		IF_IS_INT_TABLE_ADDR(CSEM_REG_INT_TABLE, addr)
-			data = INIT_CSEM_INT_TABLE_DATA(bp);
-	else
-		IF_IS_INT_TABLE_ADDR(USEM_REG_INT_TABLE, addr)
-			data = INIT_USEM_INT_TABLE_DATA(bp);
-	else
-		IF_IS_INT_TABLE_ADDR(XSEM_REG_INT_TABLE, addr)
-			data = INIT_XSEM_INT_TABLE_DATA(bp);
-	else
-		IF_IS_PRAM_ADDR(TSEM_REG_PRAM, addr)
-			data = INIT_TSEM_PRAM_DATA(bp);
-	else
-		IF_IS_PRAM_ADDR(CSEM_REG_PRAM, addr)
-			data = INIT_CSEM_PRAM_DATA(bp);
-	else
-		IF_IS_PRAM_ADDR(USEM_REG_PRAM, addr)
-			data = INIT_USEM_PRAM_DATA(bp);
-	else
-		IF_IS_PRAM_ADDR(XSEM_REG_PRAM, addr)
-			data = INIT_XSEM_PRAM_DATA(bp);
-
-	return data;
-}
-
-static void bnx2x_write_big_buf_wb(struct bnx2x *bp, u32 addr, u32 len)
-{
-	if (bp->dmae_ready)
-		bnx2x_write_dmae_phys_len(bp, GUNZIP_PHYS(bp), addr, len);
-	else
-		bnx2x_init_ind_wr(bp, addr, GUNZIP_BUF(bp), len);
-}
-
-static void bnx2x_init_wr_wb(struct bnx2x *bp, u32 addr, const u32 *data,
-			     u32 len)
-{
-	const u32 *old_data = data;
-
-	data = (const u32 *)bnx2x_sel_blob(bp, addr, (const u8 *)data);
-
-	if (bp->dmae_ready) {
-		if (old_data != data)
-			VIRT_WR_DMAE_LEN(bp, data, addr, len, 1);
-		else
-			VIRT_WR_DMAE_LEN(bp, data, addr, len, 0);
-	} else
-		bnx2x_init_ind_wr(bp, addr, data, len);
-}
-
-static void bnx2x_init_wr_zp(struct bnx2x *bp, u32 addr, u32 len, u32 blob_off)
-{
-	const u8 *data = NULL;
-	int rc;
-	u32 i;
-
-	data = bnx2x_sel_blob(bp, addr, data) + blob_off*4;
-
-	rc = bnx2x_gunzip(bp, data, len);
-	if (rc)
-		return;
-
-	/* gunzip_outlen is in dwords */
-	len = GUNZIP_OUTLEN(bp);
-	for (i = 0; i < len; i++)
-		((u32 *)GUNZIP_BUF(bp))[i] =
-				cpu_to_le32(((u32 *)GUNZIP_BUF(bp))[i]);
-
-	bnx2x_write_big_buf_wb(bp, addr, len);
-}
-
-static void bnx2x_init_block(struct bnx2x *bp, u32 block, u32 stage)
-{
-	u16 op_start =
-		INIT_OPS_OFFSETS(bp)[BLOCK_OPS_IDX(block, stage, STAGE_START)];
-	u16 op_end =
-		INIT_OPS_OFFSETS(bp)[BLOCK_OPS_IDX(block, stage, STAGE_END)];
-	union init_op *op;
-	int hw_wr;
-	u32 i, op_type, addr, len;
-	const u32 *data, *data_base;
-
-	/* If empty block */
-	if (op_start == op_end)
-		return;
-
-	if (CHIP_REV_IS_FPGA(bp))
-		hw_wr = OP_WR_FPGA;
-	else if (CHIP_REV_IS_EMUL(bp))
-		hw_wr = OP_WR_EMUL;
-	else
-		hw_wr = OP_WR_ASIC;
-
-	data_base = INIT_DATA(bp);
-
-	for (i = op_start; i < op_end; i++) {
-
-		op = (union init_op *)&(INIT_OPS(bp)[i]);
-
-		op_type = op->str_wr.op;
-		addr = op->str_wr.offset;
-		len = op->str_wr.data_len;
-		data = data_base + op->str_wr.data_off;
-
-		/* HW/EMUL specific */
-		if ((op_type > OP_WB) && (op_type == hw_wr))
-			op_type = OP_WR;
-
-		switch (op_type) {
-		case OP_RD:
-			REG_RD(bp, addr);
-			break;
-		case OP_WR:
-			REG_WR(bp, addr, op->write.val);
-			break;
-		case OP_SW:
-			bnx2x_init_str_wr(bp, addr, data, len);
-			break;
-		case OP_WB:
-			bnx2x_init_wr_wb(bp, addr, data, len);
-			break;
-		case OP_SI:
-			bnx2x_init_ind_wr(bp, addr, data, len);
-			break;
-		case OP_ZR:
-			bnx2x_init_fill(bp, addr, 0, op->zero.len);
-			break;
-		case OP_ZP:
-			bnx2x_init_wr_zp(bp, addr, len,
-					 op->str_wr.data_off);
-			break;
-		case OP_WR_64:
-			bnx2x_init_wr_64(bp, addr, data, len);
-			break;
-		default:
-			/* happens whenever an op is of a diff HW */
-			break;
-		}
-	}
-}
-
-
-/****************************************************************************
-* PXP Arbiter
-****************************************************************************/
-/*
- * This code configures the PCI read/write arbiter
- * which implements a weighted round robin
- * between the virtual queues in the chip.
- *
- * The values were derived for each PCI max payload and max request size.
- * since max payload and max request size are only known at run time,
- * this is done as a separate init stage.
- */
-
-#define NUM_WR_Q			13
-#define NUM_RD_Q			29
-#define MAX_RD_ORD			3
-#define MAX_WR_ORD			2
-
-/* configuration for one arbiter queue */
-struct arb_line {
-	int l;
-	int add;
-	int ubound;
-};
-
-/* derived configuration for each read queue for each max request size */
-static const struct arb_line read_arb_data[NUM_RD_Q][MAX_RD_ORD + 1] = {
-/* 1 */	{ {8, 64, 25}, {16, 64, 25}, {32, 64, 25}, {64, 64, 41} },
-	{ {4, 8,  4},  {4,  8,  4},  {4,  8,  4},  {4,  8,  4}  },
-	{ {4, 3,  3},  {4,  3,  3},  {4,  3,  3},  {4,  3,  3}  },
-	{ {8, 3,  6},  {16, 3,  11}, {16, 3,  11}, {16, 3,  11} },
-	{ {8, 64, 25}, {16, 64, 25}, {32, 64, 25}, {64, 64, 41} },
-	{ {8, 3,  6},  {16, 3,  11}, {32, 3,  21}, {64, 3,  41} },
-	{ {8, 3,  6},  {16, 3,  11}, {32, 3,  21}, {64, 3,  41} },
-	{ {8, 3,  6},  {16, 3,  11}, {32, 3,  21}, {64, 3,  41} },
-	{ {8, 3,  6},  {16, 3,  11}, {32, 3,  21}, {64, 3,  41} },
-/* 10 */{ {8, 3,  6},  {16, 3,  11}, {32, 3,  21}, {32, 3,  21} },
-	{ {8, 3,  6},  {16, 3,  11}, {32, 3,  21}, {32, 3,  21} },
-	{ {8, 3,  6},  {16, 3,  11}, {32, 3,  21}, {32, 3,  21} },
-	{ {8, 3,  6},  {16, 3,  11}, {32, 3,  21}, {32, 3,  21} },
-	{ {8, 3,  6},  {16, 3,  11}, {32, 3,  21}, {32, 3,  21} },
-	{ {8, 3,  6},  {16, 3,  11}, {32, 3,  21}, {32, 3,  21} },
-	{ {8, 3,  6},  {16, 3,  11}, {32, 3,  21}, {32, 3,  21} },
-	{ {8, 64, 6},  {16, 64, 11}, {32, 64, 21}, {32, 64, 21} },
-	{ {8, 3,  6},  {16, 3,  11}, {32, 3,  21}, {32, 3,  21} },
-	{ {8, 3,  6},  {16, 3,  11}, {32, 3,  21}, {32, 3,  21} },
-/* 20 */{ {8, 3,  6},  {16, 3,  11}, {32, 3,  21}, {32, 3,  21} },
-	{ {8, 3,  6},  {16, 3,  11}, {32, 3,  21}, {32, 3,  21} },
-	{ {8, 3,  6},  {16, 3,  11}, {32, 3,  21}, {32, 3,  21} },
-	{ {8, 3,  6},  {16, 3,  11}, {32, 3,  21}, {32, 3,  21} },
-	{ {8, 3,  6},  {16, 3,  11}, {32, 3,  21}, {32, 3,  21} },
-	{ {8, 3,  6},  {16, 3,  11}, {32, 3,  21}, {32, 3,  21} },
-	{ {8, 3,  6},  {16, 3,  11}, {32, 3,  21}, {32, 3,  21} },
-	{ {8, 3,  6},  {16, 3,  11}, {32, 3,  21}, {32, 3,  21} },
-	{ {8, 3,  6},  {16, 3,  11}, {32, 3,  21}, {32, 3,  21} },
-	{ {8, 64, 25}, {16, 64, 41}, {32, 64, 81}, {64, 64, 120} }
-};
-
-/* derived configuration for each write queue for each max request size */
-static const struct arb_line write_arb_data[NUM_WR_Q][MAX_WR_ORD + 1] = {
-/* 1 */	{ {4, 6,  3},  {4,  6,  3},  {4,  6,  3} },
-	{ {4, 2,  3},  {4,  2,  3},  {4,  2,  3} },
-	{ {8, 2,  6},  {16, 2,  11}, {16, 2,  11} },
-	{ {8, 2,  6},  {16, 2,  11}, {32, 2,  21} },
-	{ {8, 2,  6},  {16, 2,  11}, {32, 2,  21} },
-	{ {8, 2,  6},  {16, 2,  11}, {32, 2,  21} },
-	{ {8, 64, 25}, {16, 64, 25}, {32, 64, 25} },
-	{ {8, 2,  6},  {16, 2,  11}, {16, 2,  11} },
-	{ {8, 2,  6},  {16, 2,  11}, {16, 2,  11} },
-/* 10 */{ {8, 9,  6},  {16, 9,  11}, {32, 9,  21} },
-	{ {8, 47, 19}, {16, 47, 19}, {32, 47, 21} },
-	{ {8, 9,  6},  {16, 9,  11}, {16, 9,  11} },
-	{ {8, 64, 25}, {16, 64, 41}, {32, 64, 81} }
-};
-
-/* register addresses for read queues */
-static const struct arb_line read_arb_addr[NUM_RD_Q-1] = {
-/* 1 */	{PXP2_REG_RQ_BW_RD_L0, PXP2_REG_RQ_BW_RD_ADD0,
-		PXP2_REG_RQ_BW_RD_UBOUND0},
-	{PXP2_REG_PSWRQ_BW_L1, PXP2_REG_PSWRQ_BW_ADD1,
-		PXP2_REG_PSWRQ_BW_UB1},
-	{PXP2_REG_PSWRQ_BW_L2, PXP2_REG_PSWRQ_BW_ADD2,
-		PXP2_REG_PSWRQ_BW_UB2},
-	{PXP2_REG_PSWRQ_BW_L3, PXP2_REG_PSWRQ_BW_ADD3,
-		PXP2_REG_PSWRQ_BW_UB3},
-	{PXP2_REG_RQ_BW_RD_L4, PXP2_REG_RQ_BW_RD_ADD4,
-		PXP2_REG_RQ_BW_RD_UBOUND4},
-	{PXP2_REG_RQ_BW_RD_L5, PXP2_REG_RQ_BW_RD_ADD5,
-		PXP2_REG_RQ_BW_RD_UBOUND5},
-	{PXP2_REG_PSWRQ_BW_L6, PXP2_REG_PSWRQ_BW_ADD6,
-		PXP2_REG_PSWRQ_BW_UB6},
-	{PXP2_REG_PSWRQ_BW_L7, PXP2_REG_PSWRQ_BW_ADD7,
-		PXP2_REG_PSWRQ_BW_UB7},
-	{PXP2_REG_PSWRQ_BW_L8, PXP2_REG_PSWRQ_BW_ADD8,
-		PXP2_REG_PSWRQ_BW_UB8},
-/* 10 */{PXP2_REG_PSWRQ_BW_L9, PXP2_REG_PSWRQ_BW_ADD9,
-		PXP2_REG_PSWRQ_BW_UB9},
-	{PXP2_REG_PSWRQ_BW_L10, PXP2_REG_PSWRQ_BW_ADD10,
-		PXP2_REG_PSWRQ_BW_UB10},
-	{PXP2_REG_PSWRQ_BW_L11, PXP2_REG_PSWRQ_BW_ADD11,
-		PXP2_REG_PSWRQ_BW_UB11},
-	{PXP2_REG_RQ_BW_RD_L12, PXP2_REG_RQ_BW_RD_ADD12,
-		PXP2_REG_RQ_BW_RD_UBOUND12},
-	{PXP2_REG_RQ_BW_RD_L13, PXP2_REG_RQ_BW_RD_ADD13,
-		PXP2_REG_RQ_BW_RD_UBOUND13},
-	{PXP2_REG_RQ_BW_RD_L14, PXP2_REG_RQ_BW_RD_ADD14,
-		PXP2_REG_RQ_BW_RD_UBOUND14},
-	{PXP2_REG_RQ_BW_RD_L15, PXP2_REG_RQ_BW_RD_ADD15,
-		PXP2_REG_RQ_BW_RD_UBOUND15},
-	{PXP2_REG_RQ_BW_RD_L16, PXP2_REG_RQ_BW_RD_ADD16,
-		PXP2_REG_RQ_BW_RD_UBOUND16},
-	{PXP2_REG_RQ_BW_RD_L17, PXP2_REG_RQ_BW_RD_ADD17,
-		PXP2_REG_RQ_BW_RD_UBOUND17},
-	{PXP2_REG_RQ_BW_RD_L18, PXP2_REG_RQ_BW_RD_ADD18,
-		PXP2_REG_RQ_BW_RD_UBOUND18},
-/* 20 */{PXP2_REG_RQ_BW_RD_L19, PXP2_REG_RQ_BW_RD_ADD19,
-		PXP2_REG_RQ_BW_RD_UBOUND19},
-	{PXP2_REG_RQ_BW_RD_L20, PXP2_REG_RQ_BW_RD_ADD20,
-		PXP2_REG_RQ_BW_RD_UBOUND20},
-	{PXP2_REG_RQ_BW_RD_L22, PXP2_REG_RQ_BW_RD_ADD22,
-		PXP2_REG_RQ_BW_RD_UBOUND22},
-	{PXP2_REG_RQ_BW_RD_L23, PXP2_REG_RQ_BW_RD_ADD23,
-		PXP2_REG_RQ_BW_RD_UBOUND23},
-	{PXP2_REG_RQ_BW_RD_L24, PXP2_REG_RQ_BW_RD_ADD24,
-		PXP2_REG_RQ_BW_RD_UBOUND24},
-	{PXP2_REG_RQ_BW_RD_L25, PXP2_REG_RQ_BW_RD_ADD25,
-		PXP2_REG_RQ_BW_RD_UBOUND25},
-	{PXP2_REG_RQ_BW_RD_L26, PXP2_REG_RQ_BW_RD_ADD26,
-		PXP2_REG_RQ_BW_RD_UBOUND26},
-	{PXP2_REG_RQ_BW_RD_L27, PXP2_REG_RQ_BW_RD_ADD27,
-		PXP2_REG_RQ_BW_RD_UBOUND27},
-	{PXP2_REG_PSWRQ_BW_L28, PXP2_REG_PSWRQ_BW_ADD28,
-		PXP2_REG_PSWRQ_BW_UB28}
-};
-
-/* register addresses for write queues */
-static const struct arb_line write_arb_addr[NUM_WR_Q-1] = {
-/* 1 */	{PXP2_REG_PSWRQ_BW_L1, PXP2_REG_PSWRQ_BW_ADD1,
-		PXP2_REG_PSWRQ_BW_UB1},
-	{PXP2_REG_PSWRQ_BW_L2, PXP2_REG_PSWRQ_BW_ADD2,
-		PXP2_REG_PSWRQ_BW_UB2},
-	{PXP2_REG_PSWRQ_BW_L3, PXP2_REG_PSWRQ_BW_ADD3,
-		PXP2_REG_PSWRQ_BW_UB3},
-	{PXP2_REG_PSWRQ_BW_L6, PXP2_REG_PSWRQ_BW_ADD6,
-		PXP2_REG_PSWRQ_BW_UB6},
-	{PXP2_REG_PSWRQ_BW_L7, PXP2_REG_PSWRQ_BW_ADD7,
-		PXP2_REG_PSWRQ_BW_UB7},
-	{PXP2_REG_PSWRQ_BW_L8, PXP2_REG_PSWRQ_BW_ADD8,
-		PXP2_REG_PSWRQ_BW_UB8},
-	{PXP2_REG_PSWRQ_BW_L9, PXP2_REG_PSWRQ_BW_ADD9,
-		PXP2_REG_PSWRQ_BW_UB9},
-	{PXP2_REG_PSWRQ_BW_L10, PXP2_REG_PSWRQ_BW_ADD10,
-		PXP2_REG_PSWRQ_BW_UB10},
-	{PXP2_REG_PSWRQ_BW_L11, PXP2_REG_PSWRQ_BW_ADD11,
-		PXP2_REG_PSWRQ_BW_UB11},
-/* 10 */{PXP2_REG_PSWRQ_BW_L28, PXP2_REG_PSWRQ_BW_ADD28,
-		PXP2_REG_PSWRQ_BW_UB28},
-	{PXP2_REG_RQ_BW_WR_L29, PXP2_REG_RQ_BW_WR_ADD29,
-		PXP2_REG_RQ_BW_WR_UBOUND29},
-	{PXP2_REG_RQ_BW_WR_L30, PXP2_REG_RQ_BW_WR_ADD30,
-		PXP2_REG_RQ_BW_WR_UBOUND30}
-};
-
-static void bnx2x_init_pxp_arb(struct bnx2x *bp, int r_order, int w_order)
-{
-	u32 val, i;
-
-	if (r_order > MAX_RD_ORD) {
-		DP(NETIF_MSG_HW, "read order of %d  order adjusted to %d\n",
-		   r_order, MAX_RD_ORD);
-		r_order = MAX_RD_ORD;
-	}
-	if (w_order > MAX_WR_ORD) {
-		DP(NETIF_MSG_HW, "write order of %d  order adjusted to %d\n",
-		   w_order, MAX_WR_ORD);
-		w_order = MAX_WR_ORD;
-	}
-	if (CHIP_REV_IS_FPGA(bp)) {
-		DP(NETIF_MSG_HW, "write order adjusted to 1 for FPGA\n");
-		w_order = 0;
-	}
-	DP(NETIF_MSG_HW, "read order %d  write order %d\n", r_order, w_order);
-
-	for (i = 0; i < NUM_RD_Q-1; i++) {
-		REG_WR(bp, read_arb_addr[i].l, read_arb_data[i][r_order].l);
-		REG_WR(bp, read_arb_addr[i].add,
-		       read_arb_data[i][r_order].add);
-		REG_WR(bp, read_arb_addr[i].ubound,
-		       read_arb_data[i][r_order].ubound);
-	}
-
-	for (i = 0; i < NUM_WR_Q-1; i++) {
-		if ((write_arb_addr[i].l == PXP2_REG_RQ_BW_WR_L29) ||
-		    (write_arb_addr[i].l == PXP2_REG_RQ_BW_WR_L30)) {
-
-			REG_WR(bp, write_arb_addr[i].l,
-			       write_arb_data[i][w_order].l);
-
-			REG_WR(bp, write_arb_addr[i].add,
-			       write_arb_data[i][w_order].add);
-
-			REG_WR(bp, write_arb_addr[i].ubound,
-			       write_arb_data[i][w_order].ubound);
-		} else {
-
-			val = REG_RD(bp, write_arb_addr[i].l);
-			REG_WR(bp, write_arb_addr[i].l,
-			       val | (write_arb_data[i][w_order].l << 10));
-
-			val = REG_RD(bp, write_arb_addr[i].add);
-			REG_WR(bp, write_arb_addr[i].add,
-			       val | (write_arb_data[i][w_order].add << 10));
-
-			val = REG_RD(bp, write_arb_addr[i].ubound);
-			REG_WR(bp, write_arb_addr[i].ubound,
-			       val | (write_arb_data[i][w_order].ubound << 7));
-		}
-	}
-
-	val =  write_arb_data[NUM_WR_Q-1][w_order].add;
-	val += write_arb_data[NUM_WR_Q-1][w_order].ubound << 10;
-	val += write_arb_data[NUM_WR_Q-1][w_order].l << 17;
-	REG_WR(bp, PXP2_REG_PSWRQ_BW_RD, val);
-
-	val =  read_arb_data[NUM_RD_Q-1][r_order].add;
-	val += read_arb_data[NUM_RD_Q-1][r_order].ubound << 10;
-	val += read_arb_data[NUM_RD_Q-1][r_order].l << 17;
-	REG_WR(bp, PXP2_REG_PSWRQ_BW_WR, val);
-
-	REG_WR(bp, PXP2_REG_RQ_WR_MBS0, w_order);
-	REG_WR(bp, PXP2_REG_RQ_WR_MBS1, w_order);
-	REG_WR(bp, PXP2_REG_RQ_RD_MBS0, r_order);
-	REG_WR(bp, PXP2_REG_RQ_RD_MBS1, r_order);
-
-	if (r_order == MAX_RD_ORD)
-		REG_WR(bp, PXP2_REG_RQ_PDR_LIMIT, 0xe00);
-
-	REG_WR(bp, PXP2_REG_WR_USDMDP_TH, (0x18 << w_order));
-
-	if (CHIP_IS_E1H(bp)) {
-		/*    MPS      w_order     optimal TH      presently TH
-		 *    128         0             0               2
-		 *    256         1             1               3
-		 *    >=512       2             2               3
-		 */
-		val = ((w_order == 0) ? 2 : 3);
-		REG_WR(bp, PXP2_REG_WR_HC_MPS, val);
-		REG_WR(bp, PXP2_REG_WR_USDM_MPS, val);
-		REG_WR(bp, PXP2_REG_WR_CSDM_MPS, val);
-		REG_WR(bp, PXP2_REG_WR_TSDM_MPS, val);
-		REG_WR(bp, PXP2_REG_WR_XSDM_MPS, val);
-		REG_WR(bp, PXP2_REG_WR_QM_MPS, val);
-		REG_WR(bp, PXP2_REG_WR_TM_MPS, val);
-		REG_WR(bp, PXP2_REG_WR_SRC_MPS, val);
-		REG_WR(bp, PXP2_REG_WR_DBG_MPS, val);
-		REG_WR(bp, PXP2_REG_WR_DMAE_MPS, 2); /* DMAE is special */
-		REG_WR(bp, PXP2_REG_WR_CDU_MPS, val);
-	}
-}
-
-#endif /* BNX2X_INIT_OPS_H */
diff -r f4bf81a7ff20 drivers/net/bnx2x_link.c
--- a/drivers/net/bnx2x_link.c
+++ /dev/null
@@ -1,6733 +0,0 @@
-/* Copyright 2008-2009 Broadcom Corporation
- *
- * Unless you and Broadcom execute a separate written software license
- * agreement governing use of this software, this software is licensed to you
- * under the terms of the GNU General Public License version 2, available
- * at http://www.gnu.org/licenses/old-licenses/gpl-2.0.html (the "GPL").
- *
- * Notwithstanding the above, under no circumstances may you combine this
- * software in any way with any other Broadcom software provided under a
- * license other than the GPL, without Broadcom's express prior written
- * consent.
- *
- * Written by Yaniv Rosner
- *
- */
-
-#define pr_fmt(fmt) KBUILD_MODNAME ": " fmt
-
-#include <linux/kernel.h>
-#include <linux/errno.h>
-#include <linux/pci.h>
-#include <linux/netdevice.h>
-#include <linux/delay.h>
-#include <linux/ethtool.h>
-#include <linux/mutex.h>
-
-#include "bnx2x.h"
-
-/********************************************************/
-#define ETH_HLEN			14
-#define ETH_OVREHEAD		(ETH_HLEN + 8)/* 8 for CRC + VLAN*/
-#define ETH_MIN_PACKET_SIZE		60
-#define ETH_MAX_PACKET_SIZE		1500
-#define ETH_MAX_JUMBO_PACKET_SIZE	9600
-#define MDIO_ACCESS_TIMEOUT		1000
-#define BMAC_CONTROL_RX_ENABLE	2
-
-/***********************************************************/
-/*			Shortcut definitions		   */
-/***********************************************************/
-
-#define NIG_LATCH_BC_ENABLE_MI_INT 0
-
-#define NIG_STATUS_EMAC0_MI_INT \
-		NIG_STATUS_INTERRUPT_PORT0_REG_STATUS_EMAC0_MISC_MI_INT
-#define NIG_STATUS_XGXS0_LINK10G \
-		NIG_STATUS_INTERRUPT_PORT0_REG_STATUS_XGXS0_LINK10G
-#define NIG_STATUS_XGXS0_LINK_STATUS \
-		NIG_STATUS_INTERRUPT_PORT0_REG_STATUS_XGXS0_LINK_STATUS
-#define NIG_STATUS_XGXS0_LINK_STATUS_SIZE \
-		NIG_STATUS_INTERRUPT_PORT0_REG_STATUS_XGXS0_LINK_STATUS_SIZE
-#define NIG_STATUS_SERDES0_LINK_STATUS \
-		NIG_STATUS_INTERRUPT_PORT0_REG_STATUS_SERDES0_LINK_STATUS
-#define NIG_MASK_MI_INT \
-		NIG_MASK_INTERRUPT_PORT0_REG_MASK_EMAC0_MISC_MI_INT
-#define NIG_MASK_XGXS0_LINK10G \
-		NIG_MASK_INTERRUPT_PORT0_REG_MASK_XGXS0_LINK10G
-#define NIG_MASK_XGXS0_LINK_STATUS \
-		NIG_MASK_INTERRUPT_PORT0_REG_MASK_XGXS0_LINK_STATUS
-#define NIG_MASK_SERDES0_LINK_STATUS \
-		NIG_MASK_INTERRUPT_PORT0_REG_MASK_SERDES0_LINK_STATUS
-
-#define MDIO_AN_CL73_OR_37_COMPLETE \
-		(MDIO_GP_STATUS_TOP_AN_STATUS1_CL73_AUTONEG_COMPLETE | \
-		 MDIO_GP_STATUS_TOP_AN_STATUS1_CL37_AUTONEG_COMPLETE)
-
-#define XGXS_RESET_BITS \
-	(MISC_REGISTERS_RESET_REG_3_MISC_NIG_MUX_XGXS0_RSTB_HW |   \
-	 MISC_REGISTERS_RESET_REG_3_MISC_NIG_MUX_XGXS0_IDDQ |      \
-	 MISC_REGISTERS_RESET_REG_3_MISC_NIG_MUX_XGXS0_PWRDWN |    \
-	 MISC_REGISTERS_RESET_REG_3_MISC_NIG_MUX_XGXS0_PWRDWN_SD | \
-	 MISC_REGISTERS_RESET_REG_3_MISC_NIG_MUX_XGXS0_TXD_FIFO_RSTB)
-
-#define SERDES_RESET_BITS \
-	(MISC_REGISTERS_RESET_REG_3_MISC_NIG_MUX_SERDES0_RSTB_HW | \
-	 MISC_REGISTERS_RESET_REG_3_MISC_NIG_MUX_SERDES0_IDDQ |    \
-	 MISC_REGISTERS_RESET_REG_3_MISC_NIG_MUX_SERDES0_PWRDWN |  \
-	 MISC_REGISTERS_RESET_REG_3_MISC_NIG_MUX_SERDES0_PWRDWN_SD)
-
-#define AUTONEG_CL37		SHARED_HW_CFG_AN_ENABLE_CL37
-#define AUTONEG_CL73		SHARED_HW_CFG_AN_ENABLE_CL73
-#define AUTONEG_BAM 		SHARED_HW_CFG_AN_ENABLE_BAM
-#define AUTONEG_PARALLEL \
-				SHARED_HW_CFG_AN_ENABLE_PARALLEL_DETECTION
-#define AUTONEG_SGMII_FIBER_AUTODET \
-				SHARED_HW_CFG_AN_EN_SGMII_FIBER_AUTO_DETECT
-#define AUTONEG_REMOTE_PHY	SHARED_HW_CFG_AN_ENABLE_REMOTE_PHY
-
-#define GP_STATUS_PAUSE_RSOLUTION_TXSIDE \
-			MDIO_GP_STATUS_TOP_AN_STATUS1_PAUSE_RSOLUTION_TXSIDE
-#define GP_STATUS_PAUSE_RSOLUTION_RXSIDE \
-			MDIO_GP_STATUS_TOP_AN_STATUS1_PAUSE_RSOLUTION_RXSIDE
-#define GP_STATUS_SPEED_MASK \
-			MDIO_GP_STATUS_TOP_AN_STATUS1_ACTUAL_SPEED_MASK
-#define GP_STATUS_10M	MDIO_GP_STATUS_TOP_AN_STATUS1_ACTUAL_SPEED_10M
-#define GP_STATUS_100M	MDIO_GP_STATUS_TOP_AN_STATUS1_ACTUAL_SPEED_100M
-#define GP_STATUS_1G	MDIO_GP_STATUS_TOP_AN_STATUS1_ACTUAL_SPEED_1G
-#define GP_STATUS_2_5G	MDIO_GP_STATUS_TOP_AN_STATUS1_ACTUAL_SPEED_2_5G
-#define GP_STATUS_5G	MDIO_GP_STATUS_TOP_AN_STATUS1_ACTUAL_SPEED_5G
-#define GP_STATUS_6G	MDIO_GP_STATUS_TOP_AN_STATUS1_ACTUAL_SPEED_6G
-#define GP_STATUS_10G_HIG \
-			MDIO_GP_STATUS_TOP_AN_STATUS1_ACTUAL_SPEED_10G_HIG
-#define GP_STATUS_10G_CX4 \
-			MDIO_GP_STATUS_TOP_AN_STATUS1_ACTUAL_SPEED_10G_CX4
-#define GP_STATUS_12G_HIG \
-			MDIO_GP_STATUS_TOP_AN_STATUS1_ACTUAL_SPEED_12G_HIG
-#define GP_STATUS_12_5G MDIO_GP_STATUS_TOP_AN_STATUS1_ACTUAL_SPEED_12_5G
-#define GP_STATUS_13G	MDIO_GP_STATUS_TOP_AN_STATUS1_ACTUAL_SPEED_13G
-#define GP_STATUS_15G	MDIO_GP_STATUS_TOP_AN_STATUS1_ACTUAL_SPEED_15G
-#define GP_STATUS_16G	MDIO_GP_STATUS_TOP_AN_STATUS1_ACTUAL_SPEED_16G
-#define GP_STATUS_1G_KX MDIO_GP_STATUS_TOP_AN_STATUS1_ACTUAL_SPEED_1G_KX
-#define GP_STATUS_10G_KX4 \
-			MDIO_GP_STATUS_TOP_AN_STATUS1_ACTUAL_SPEED_10G_KX4
-
-#define LINK_10THD			LINK_STATUS_SPEED_AND_DUPLEX_10THD
-#define LINK_10TFD			LINK_STATUS_SPEED_AND_DUPLEX_10TFD
-#define LINK_100TXHD		LINK_STATUS_SPEED_AND_DUPLEX_100TXHD
-#define LINK_100T4			LINK_STATUS_SPEED_AND_DUPLEX_100T4
-#define LINK_100TXFD		LINK_STATUS_SPEED_AND_DUPLEX_100TXFD
-#define LINK_1000THD		LINK_STATUS_SPEED_AND_DUPLEX_1000THD
-#define LINK_1000TFD		LINK_STATUS_SPEED_AND_DUPLEX_1000TFD
-#define LINK_1000XFD		LINK_STATUS_SPEED_AND_DUPLEX_1000XFD
-#define LINK_2500THD		LINK_STATUS_SPEED_AND_DUPLEX_2500THD
-#define LINK_2500TFD		LINK_STATUS_SPEED_AND_DUPLEX_2500TFD
-#define LINK_2500XFD		LINK_STATUS_SPEED_AND_DUPLEX_2500XFD
-#define LINK_10GTFD			LINK_STATUS_SPEED_AND_DUPLEX_10GTFD
-#define LINK_10GXFD			LINK_STATUS_SPEED_AND_DUPLEX_10GXFD
-#define LINK_12GTFD			LINK_STATUS_SPEED_AND_DUPLEX_12GTFD
-#define LINK_12GXFD			LINK_STATUS_SPEED_AND_DUPLEX_12GXFD
-#define LINK_12_5GTFD		LINK_STATUS_SPEED_AND_DUPLEX_12_5GTFD
-#define LINK_12_5GXFD		LINK_STATUS_SPEED_AND_DUPLEX_12_5GXFD
-#define LINK_13GTFD			LINK_STATUS_SPEED_AND_DUPLEX_13GTFD
-#define LINK_13GXFD			LINK_STATUS_SPEED_AND_DUPLEX_13GXFD
-#define LINK_15GTFD			LINK_STATUS_SPEED_AND_DUPLEX_15GTFD
-#define LINK_15GXFD			LINK_STATUS_SPEED_AND_DUPLEX_15GXFD
-#define LINK_16GTFD			LINK_STATUS_SPEED_AND_DUPLEX_16GTFD
-#define LINK_16GXFD			LINK_STATUS_SPEED_AND_DUPLEX_16GXFD
-
-#define PHY_XGXS_FLAG			0x1
-#define PHY_SGMII_FLAG			0x2
-#define PHY_SERDES_FLAG			0x4
-
-/* */
-#define SFP_EEPROM_CON_TYPE_ADDR		0x2
-	#define SFP_EEPROM_CON_TYPE_VAL_LC 		0x7
-	#define SFP_EEPROM_CON_TYPE_VAL_COPPER	0x21
-
-
-#define SFP_EEPROM_COMP_CODE_ADDR		0x3
-	#define SFP_EEPROM_COMP_CODE_SR_MASK	(1<<4)
-	#define SFP_EEPROM_COMP_CODE_LR_MASK	(1<<5)
-	#define SFP_EEPROM_COMP_CODE_LRM_MASK	(1<<6)
-
-#define SFP_EEPROM_FC_TX_TECH_ADDR		0x8
-	#define SFP_EEPROM_FC_TX_TECH_BITMASK_COPPER_PASSIVE 0x4
-	#define SFP_EEPROM_FC_TX_TECH_BITMASK_COPPER_ACTIVE	 0x8
-
-#define SFP_EEPROM_OPTIONS_ADDR 		0x40
-	#define SFP_EEPROM_OPTIONS_LINEAR_RX_OUT_MASK 0x1
-#define SFP_EEPROM_OPTIONS_SIZE 		2
-
-#define EDC_MODE_LINEAR	 			0x0022
-#define EDC_MODE_LIMITING	 			0x0044
-#define EDC_MODE_PASSIVE_DAC 			0x0055
-
-
-
-/**********************************************************/
-/*                     INTERFACE                          */
-/**********************************************************/
-#define CL45_WR_OVER_CL22(_bp, _port, _phy_addr, _bank, _addr, _val) \
-	bnx2x_cl45_write(_bp, _port, 0, _phy_addr, \
-		DEFAULT_PHY_DEV_ADDR, \
-		(_bank + (_addr & 0xf)), \
-		_val)
-
-#define CL45_RD_OVER_CL22(_bp, _port, _phy_addr, _bank, _addr, _val) \
-	bnx2x_cl45_read(_bp, _port, 0, _phy_addr, \
-		DEFAULT_PHY_DEV_ADDR, \
-		(_bank + (_addr & 0xf)), \
-		_val)
-
-static void bnx2x_set_serdes_access(struct link_params *params)
-{
-	struct bnx2x *bp = params->bp;
-	u32 emac_base = (params->port) ? GRCBASE_EMAC1 : GRCBASE_EMAC0;
-
-	/* Set Clause 22 */
-	REG_WR(bp, NIG_REG_SERDES0_CTRL_MD_ST + params->port*0x10, 1);
-	REG_WR(bp, emac_base + EMAC_REG_EMAC_MDIO_COMM, 0x245f8000);
-	udelay(500);
-	REG_WR(bp, emac_base + EMAC_REG_EMAC_MDIO_COMM, 0x245d000f);
-	udelay(500);
-	 /* Set Clause 45 */
-	REG_WR(bp, NIG_REG_SERDES0_CTRL_MD_ST + params->port*0x10, 0);
-}
-static void bnx2x_set_phy_mdio(struct link_params *params, u8 phy_flags)
-{
-	struct bnx2x *bp = params->bp;
-
-	if (phy_flags & PHY_XGXS_FLAG) {
-		REG_WR(bp, NIG_REG_XGXS0_CTRL_MD_ST +
-			   params->port*0x18, 0);
-		REG_WR(bp, NIG_REG_XGXS0_CTRL_MD_DEVAD + params->port*0x18,
-			   DEFAULT_PHY_DEV_ADDR);
-	} else {
-		bnx2x_set_serdes_access(params);
-
-		REG_WR(bp, NIG_REG_SERDES0_CTRL_MD_DEVAD +
-			   params->port*0x10,
-			   DEFAULT_PHY_DEV_ADDR);
-	}
-}
-
-static u32 bnx2x_bits_en(struct bnx2x *bp, u32 reg, u32 bits)
-{
-	u32 val = REG_RD(bp, reg);
-
-	val |= bits;
-	REG_WR(bp, reg, val);
-	return val;
-}
-
-static u32 bnx2x_bits_dis(struct bnx2x *bp, u32 reg, u32 bits)
-{
-	u32 val = REG_RD(bp, reg);
-
-	val &= ~bits;
-	REG_WR(bp, reg, val);
-	return val;
-}
-
-static void bnx2x_emac_init(struct link_params *params,
-			   struct link_vars *vars)
-{
-	/* reset and unreset the emac core */
-	struct bnx2x *bp = params->bp;
-	u8 port = params->port;
-	u32 emac_base = port ? GRCBASE_EMAC1 : GRCBASE_EMAC0;
-	u32 val;
-	u16 timeout;
-
-	REG_WR(bp, GRCBASE_MISC + MISC_REGISTERS_RESET_REG_2_CLEAR,
-		   (MISC_REGISTERS_RESET_REG_2_RST_EMAC0_HARD_CORE << port));
-	udelay(5);
-	REG_WR(bp, GRCBASE_MISC + MISC_REGISTERS_RESET_REG_2_SET,
-		   (MISC_REGISTERS_RESET_REG_2_RST_EMAC0_HARD_CORE << port));
-
-	/* init emac - use read-modify-write */
-	/* self clear reset */
-	val = REG_RD(bp, emac_base + EMAC_REG_EMAC_MODE);
-	EMAC_WR(bp, EMAC_REG_EMAC_MODE, (val | EMAC_MODE_RESET));
-
-	timeout = 200;
-	do {
-		val = REG_RD(bp, emac_base + EMAC_REG_EMAC_MODE);
-		DP(NETIF_MSG_LINK, "EMAC reset reg is %u\n", val);
-		if (!timeout) {
-			DP(NETIF_MSG_LINK, "EMAC timeout!\n");
-			return;
-		}
-		timeout--;
-	} while (val & EMAC_MODE_RESET);
-
-	/* Set mac address */
-	val = ((params->mac_addr[0] << 8) |
-		params->mac_addr[1]);
-	EMAC_WR(bp, EMAC_REG_EMAC_MAC_MATCH, val);
-
-	val = ((params->mac_addr[2] << 24) |
-	       (params->mac_addr[3] << 16) |
-	       (params->mac_addr[4] << 8) |
-		params->mac_addr[5]);
-	EMAC_WR(bp, EMAC_REG_EMAC_MAC_MATCH + 4, val);
-}
-
-static u8 bnx2x_emac_enable(struct link_params *params,
-			  struct link_vars *vars, u8 lb)
-{
-	struct bnx2x *bp = params->bp;
-	u8 port = params->port;
-	u32 emac_base = port ? GRCBASE_EMAC1 : GRCBASE_EMAC0;
-	u32 val;
-
-	DP(NETIF_MSG_LINK, "enabling EMAC\n");
-
-	/* enable emac and not bmac */
-	REG_WR(bp, NIG_REG_EGRESS_EMAC0_PORT + port*4, 1);
-
-	/* for paladium */
-	if (CHIP_REV_IS_EMUL(bp)) {
-		/* Use lane 1 (of lanes 0-3) */
-		REG_WR(bp, NIG_REG_XGXS_LANE_SEL_P0 + port*4, 1);
-		REG_WR(bp, NIG_REG_XGXS_SERDES0_MODE_SEL +
-			    port*4, 1);
-	}
-	/* for fpga */
-	else
-
-	if (CHIP_REV_IS_FPGA(bp)) {
-		/* Use lane 1 (of lanes 0-3) */
-		DP(NETIF_MSG_LINK, "bnx2x_emac_enable: Setting FPGA\n");
-
-		REG_WR(bp, NIG_REG_XGXS_LANE_SEL_P0 + port*4, 1);
-		REG_WR(bp, NIG_REG_XGXS_SERDES0_MODE_SEL + port*4,
-			    0);
-	} else
-	/* ASIC */
-	if (vars->phy_flags & PHY_XGXS_FLAG) {
-		u32 ser_lane = ((params->lane_config &
-			    PORT_HW_CFG_LANE_SWAP_CFG_MASTER_MASK) >>
-			    PORT_HW_CFG_LANE_SWAP_CFG_MASTER_SHIFT);
-
-		DP(NETIF_MSG_LINK, "XGXS\n");
-		/* select the master lanes (out of 0-3) */
-		REG_WR(bp, NIG_REG_XGXS_LANE_SEL_P0 +
-			   port*4, ser_lane);
-		/* select XGXS */
-		REG_WR(bp, NIG_REG_XGXS_SERDES0_MODE_SEL +
-			   port*4, 1);
-
-	} else { /* SerDes */
-		DP(NETIF_MSG_LINK, "SerDes\n");
-		/* select SerDes */
-		REG_WR(bp, NIG_REG_XGXS_SERDES0_MODE_SEL +
-			   port*4, 0);
-	}
-
-	bnx2x_bits_en(bp, emac_base + EMAC_REG_EMAC_RX_MODE,
-		    EMAC_RX_MODE_RESET);
-	bnx2x_bits_en(bp, emac_base + EMAC_REG_EMAC_TX_MODE,
-		    EMAC_TX_MODE_RESET);
-
-	if (CHIP_REV_IS_SLOW(bp)) {
-		/* config GMII mode */
-		val = REG_RD(bp, emac_base + EMAC_REG_EMAC_MODE);
-		EMAC_WR(bp, EMAC_REG_EMAC_MODE,
-			    (val | EMAC_MODE_PORT_GMII));
-	} else { /* ASIC */
-		/* pause enable/disable */
-		bnx2x_bits_dis(bp, emac_base + EMAC_REG_EMAC_RX_MODE,
-			       EMAC_RX_MODE_FLOW_EN);
-		if (vars->flow_ctrl & BNX2X_FLOW_CTRL_RX)
-			bnx2x_bits_en(bp, emac_base +
-				    EMAC_REG_EMAC_RX_MODE,
-				    EMAC_RX_MODE_FLOW_EN);
-
-		bnx2x_bits_dis(bp,  emac_base + EMAC_REG_EMAC_TX_MODE,
-			     (EMAC_TX_MODE_EXT_PAUSE_EN |
-			      EMAC_TX_MODE_FLOW_EN));
-		if (vars->flow_ctrl & BNX2X_FLOW_CTRL_TX)
-			bnx2x_bits_en(bp, emac_base +
-				    EMAC_REG_EMAC_TX_MODE,
-				   (EMAC_TX_MODE_EXT_PAUSE_EN |
-				    EMAC_TX_MODE_FLOW_EN));
-	}
-
-	/* KEEP_VLAN_TAG, promiscuous */
-	val = REG_RD(bp, emac_base + EMAC_REG_EMAC_RX_MODE);
-	val |= EMAC_RX_MODE_KEEP_VLAN_TAG | EMAC_RX_MODE_PROMISCUOUS;
-	EMAC_WR(bp, EMAC_REG_EMAC_RX_MODE, val);
-
-	/* Set Loopback */
-	val = REG_RD(bp, emac_base + EMAC_REG_EMAC_MODE);
-	if (lb)
-		val |= 0x810;
-	else
-		val &= ~0x810;
-	EMAC_WR(bp, EMAC_REG_EMAC_MODE, val);
-
-	/* enable emac */
-	REG_WR(bp, NIG_REG_NIG_EMAC0_EN + port*4, 1);
-
-	/* enable emac for jumbo packets */
-	EMAC_WR(bp, EMAC_REG_EMAC_RX_MTU_SIZE,
-		(EMAC_RX_MTU_SIZE_JUMBO_ENA |
-		 (ETH_MAX_JUMBO_PACKET_SIZE + ETH_OVREHEAD)));
-
-	/* strip CRC */
-	REG_WR(bp, NIG_REG_NIG_INGRESS_EMAC0_NO_CRC + port*4, 0x1);
-
-	/* disable the NIG in/out to the bmac */
-	REG_WR(bp, NIG_REG_BMAC0_IN_EN + port*4, 0x0);
-	REG_WR(bp, NIG_REG_BMAC0_PAUSE_OUT_EN + port*4, 0x0);
-	REG_WR(bp, NIG_REG_BMAC0_OUT_EN + port*4, 0x0);
-
-	/* enable the NIG in/out to the emac */
-	REG_WR(bp, NIG_REG_EMAC0_IN_EN + port*4, 0x1);
-	val = 0;
-	if (vars->flow_ctrl & BNX2X_FLOW_CTRL_TX)
-		val = 1;
-
-	REG_WR(bp, NIG_REG_EMAC0_PAUSE_OUT_EN + port*4, val);
-	REG_WR(bp, NIG_REG_EGRESS_EMAC0_OUT_EN + port*4, 0x1);
-
-	if (CHIP_REV_IS_EMUL(bp)) {
-		/* take the BigMac out of reset */
-		REG_WR(bp,
-			   GRCBASE_MISC + MISC_REGISTERS_RESET_REG_2_SET,
-			   (MISC_REGISTERS_RESET_REG_2_RST_BMAC0 << port));
-
-		/* enable access for bmac registers */
-		REG_WR(bp, NIG_REG_BMAC0_REGS_OUT_EN + port*4, 0x1);
-	} else
-		REG_WR(bp, NIG_REG_BMAC0_REGS_OUT_EN + port*4, 0x0);
-
-	vars->mac_type = MAC_TYPE_EMAC;
-	return 0;
-}
-
-
-
-static u8 bnx2x_bmac_enable(struct link_params *params, struct link_vars *vars,
-			  u8 is_lb)
-{
-	struct bnx2x *bp = params->bp;
-	u8 port = params->port;
-	u32 bmac_addr = port ? NIG_REG_INGRESS_BMAC1_MEM :
-			       NIG_REG_INGRESS_BMAC0_MEM;
-	u32 wb_data[2];
-	u32 val;
-
-	DP(NETIF_MSG_LINK, "Enabling BigMAC\n");
-	/* reset and unreset the BigMac */
-	REG_WR(bp, GRCBASE_MISC + MISC_REGISTERS_RESET_REG_2_CLEAR,
-	       (MISC_REGISTERS_RESET_REG_2_RST_BMAC0 << port));
-	msleep(1);
-
-	REG_WR(bp, GRCBASE_MISC + MISC_REGISTERS_RESET_REG_2_SET,
-	       (MISC_REGISTERS_RESET_REG_2_RST_BMAC0 << port));
-
-	/* enable access for bmac registers */
-	REG_WR(bp, NIG_REG_BMAC0_REGS_OUT_EN + port*4, 0x1);
-
-	/* XGXS control */
-	wb_data[0] = 0x3c;
-	wb_data[1] = 0;
-	REG_WR_DMAE(bp, bmac_addr +
-		      BIGMAC_REGISTER_BMAC_XGXS_CONTROL,
-		      wb_data, 2);
-
-	/* tx MAC SA */
-	wb_data[0] = ((params->mac_addr[2] << 24) |
-		       (params->mac_addr[3] << 16) |
-		       (params->mac_addr[4] << 8) |
-			params->mac_addr[5]);
-	wb_data[1] = ((params->mac_addr[0] << 8) |
-			params->mac_addr[1]);
-	REG_WR_DMAE(bp, bmac_addr + BIGMAC_REGISTER_TX_SOURCE_ADDR,
-		    wb_data, 2);
-
-	/* tx control */
-	val = 0xc0;
-	if (vars->flow_ctrl & BNX2X_FLOW_CTRL_TX)
-		val |= 0x800000;
-	wb_data[0] = val;
-	wb_data[1] = 0;
-	REG_WR_DMAE(bp, bmac_addr + BIGMAC_REGISTER_TX_CONTROL,
-			wb_data, 2);
-
-	/* mac control */
-	val = 0x3;
-	if (is_lb) {
-		val |= 0x4;
-		DP(NETIF_MSG_LINK, "enable bmac loopback\n");
-	}
-	wb_data[0] = val;
-	wb_data[1] = 0;
-	REG_WR_DMAE(bp, bmac_addr + BIGMAC_REGISTER_BMAC_CONTROL,
-		    wb_data, 2);
-
-	/* set rx mtu */
-	wb_data[0] = ETH_MAX_JUMBO_PACKET_SIZE + ETH_OVREHEAD;
-	wb_data[1] = 0;
-	REG_WR_DMAE(bp, bmac_addr + BIGMAC_REGISTER_RX_MAX_SIZE,
-			wb_data, 2);
-
-	/* rx control set to don't strip crc */
-	val = 0x14;
-	if (vars->flow_ctrl & BNX2X_FLOW_CTRL_RX)
-		val |= 0x20;
-	wb_data[0] = val;
-	wb_data[1] = 0;
-	REG_WR_DMAE(bp, bmac_addr + BIGMAC_REGISTER_RX_CONTROL,
-			wb_data, 2);
-
-	/* set tx mtu */
-	wb_data[0] = ETH_MAX_JUMBO_PACKET_SIZE + ETH_OVREHEAD;
-	wb_data[1] = 0;
-	REG_WR_DMAE(bp, bmac_addr + BIGMAC_REGISTER_TX_MAX_SIZE,
-			wb_data, 2);
-
-	/* set cnt max size */
-	wb_data[0] = ETH_MAX_JUMBO_PACKET_SIZE + ETH_OVREHEAD;
-	wb_data[1] = 0;
-	REG_WR_DMAE(bp, bmac_addr + BIGMAC_REGISTER_CNT_MAX_SIZE,
-		    wb_data, 2);
-
-	/* configure safc */
-	wb_data[0] = 0x1000200;
-	wb_data[1] = 0;
-	REG_WR_DMAE(bp, bmac_addr + BIGMAC_REGISTER_RX_LLFC_MSG_FLDS,
-		    wb_data, 2);
-	/* fix for emulation */
-	if (CHIP_REV_IS_EMUL(bp)) {
-		wb_data[0] = 0xf000;
-		wb_data[1] = 0;
-		REG_WR_DMAE(bp,
-			    bmac_addr + BIGMAC_REGISTER_TX_PAUSE_THRESHOLD,
-			    wb_data, 2);
-	}
-
-	REG_WR(bp, NIG_REG_XGXS_SERDES0_MODE_SEL + port*4, 0x1);
-	REG_WR(bp, NIG_REG_XGXS_LANE_SEL_P0 + port*4, 0x0);
-	REG_WR(bp, NIG_REG_EGRESS_EMAC0_PORT + port*4, 0x0);
-	val = 0;
-	if (vars->flow_ctrl & BNX2X_FLOW_CTRL_TX)
-		val = 1;
-	REG_WR(bp, NIG_REG_BMAC0_PAUSE_OUT_EN + port*4, val);
-	REG_WR(bp, NIG_REG_EGRESS_EMAC0_OUT_EN + port*4, 0x0);
-	REG_WR(bp, NIG_REG_EMAC0_IN_EN + port*4, 0x0);
-	REG_WR(bp, NIG_REG_EMAC0_PAUSE_OUT_EN + port*4, 0x0);
-	REG_WR(bp, NIG_REG_BMAC0_IN_EN + port*4, 0x1);
-	REG_WR(bp, NIG_REG_BMAC0_OUT_EN + port*4, 0x1);
-
-	vars->mac_type = MAC_TYPE_BMAC;
-	return 0;
-}
-
-static void bnx2x_phy_deassert(struct link_params *params, u8 phy_flags)
-{
-	struct bnx2x *bp = params->bp;
-	u32 val;
-
-	if (phy_flags & PHY_XGXS_FLAG) {
-		DP(NETIF_MSG_LINK, "bnx2x_phy_deassert:XGXS\n");
-		val = XGXS_RESET_BITS;
-
-	} else { /* SerDes */
-		DP(NETIF_MSG_LINK, "bnx2x_phy_deassert:SerDes\n");
-		val = SERDES_RESET_BITS;
-	}
-
-	val = val << (params->port*16);
-
-	/* reset and unreset the SerDes/XGXS */
-	REG_WR(bp, GRCBASE_MISC + MISC_REGISTERS_RESET_REG_3_CLEAR,
-		    val);
-	udelay(500);
-	REG_WR(bp, GRCBASE_MISC + MISC_REGISTERS_RESET_REG_3_SET,
-		    val);
-	bnx2x_set_phy_mdio(params, phy_flags);
-}
-
-void bnx2x_link_status_update(struct link_params *params,
-			    struct link_vars   *vars)
-{
-	struct bnx2x *bp = params->bp;
-	u8 link_10g;
-	u8 port = params->port;
-
-	if (params->switch_cfg ==  SWITCH_CFG_1G)
-		vars->phy_flags = PHY_SERDES_FLAG;
-	else
-		vars->phy_flags = PHY_XGXS_FLAG;
-	vars->link_status = REG_RD(bp, params->shmem_base +
-					  offsetof(struct shmem_region,
-					   port_mb[port].link_status));
-
-	vars->link_up = (vars->link_status & LINK_STATUS_LINK_UP);
-
-	if (vars->link_up) {
-		DP(NETIF_MSG_LINK, "phy link up\n");
-
-		vars->phy_link_up = 1;
-		vars->duplex = DUPLEX_FULL;
-		switch (vars->link_status &
-					LINK_STATUS_SPEED_AND_DUPLEX_MASK) {
-			case LINK_10THD:
-				vars->duplex = DUPLEX_HALF;
-				/* fall thru */
-			case LINK_10TFD:
-				vars->line_speed = SPEED_10;
-				break;
-
-			case LINK_100TXHD:
-				vars->duplex = DUPLEX_HALF;
-				/* fall thru */
-			case LINK_100T4:
-			case LINK_100TXFD:
-				vars->line_speed = SPEED_100;
-				break;
-
-			case LINK_1000THD:
-				vars->duplex = DUPLEX_HALF;
-				/* fall thru */
-			case LINK_1000TFD:
-				vars->line_speed = SPEED_1000;
-				break;
-
-			case LINK_2500THD:
-				vars->duplex = DUPLEX_HALF;
-				/* fall thru */
-			case LINK_2500TFD:
-				vars->line_speed = SPEED_2500;
-				break;
-
-			case LINK_10GTFD:
-				vars->line_speed = SPEED_10000;
-				break;
-
-			case LINK_12GTFD:
-				vars->line_speed = SPEED_12000;
-				break;
-
-			case LINK_12_5GTFD:
-				vars->line_speed = SPEED_12500;
-				break;
-
-			case LINK_13GTFD:
-				vars->line_speed = SPEED_13000;
-				break;
-
-			case LINK_15GTFD:
-				vars->line_speed = SPEED_15000;
-				break;
-
-			case LINK_16GTFD:
-				vars->line_speed = SPEED_16000;
-				break;
-
-			default:
-				break;
-		}
-
-		if (vars->link_status & LINK_STATUS_TX_FLOW_CONTROL_ENABLED)
-			vars->flow_ctrl |= BNX2X_FLOW_CTRL_TX;
-		else
-			vars->flow_ctrl &= ~BNX2X_FLOW_CTRL_TX;
-
-		if (vars->link_status & LINK_STATUS_RX_FLOW_CONTROL_ENABLED)
-			vars->flow_ctrl |= BNX2X_FLOW_CTRL_RX;
-		else
-			vars->flow_ctrl &= ~BNX2X_FLOW_CTRL_RX;
-
-		if (vars->phy_flags & PHY_XGXS_FLAG) {
-			if (vars->line_speed &&
-			    ((vars->line_speed == SPEED_10) ||
-			     (vars->line_speed == SPEED_100))) {
-				vars->phy_flags |= PHY_SGMII_FLAG;
-			} else {
-				vars->phy_flags &= ~PHY_SGMII_FLAG;
-			}
-		}
-
-		/* anything 10 and over uses the bmac */
-		link_10g = ((vars->line_speed == SPEED_10000) ||
-			    (vars->line_speed == SPEED_12000) ||
-			    (vars->line_speed == SPEED_12500) ||
-			    (vars->line_speed == SPEED_13000) ||
-			    (vars->line_speed == SPEED_15000) ||
-			    (vars->line_speed == SPEED_16000));
-		if (link_10g)
-			vars->mac_type = MAC_TYPE_BMAC;
-		else
-			vars->mac_type = MAC_TYPE_EMAC;
-
-	} else { /* link down */
-		DP(NETIF_MSG_LINK, "phy link down\n");
-
-		vars->phy_link_up = 0;
-
-		vars->line_speed = 0;
-		vars->duplex = DUPLEX_FULL;
-		vars->flow_ctrl = BNX2X_FLOW_CTRL_NONE;
-
-		/* indicate no mac active */
-		vars->mac_type = MAC_TYPE_NONE;
-	}
-
-	DP(NETIF_MSG_LINK, "link_status 0x%x  phy_link_up %x\n",
-		 vars->link_status, vars->phy_link_up);
-	DP(NETIF_MSG_LINK, "line_speed %x  duplex %x  flow_ctrl 0x%x\n",
-		 vars->line_speed, vars->duplex, vars->flow_ctrl);
-}
-
-static void bnx2x_update_mng(struct link_params *params, u32 link_status)
-{
-	struct bnx2x *bp = params->bp;
-
-	REG_WR(bp, params->shmem_base +
-		   offsetof(struct shmem_region,
-			    port_mb[params->port].link_status),
-			link_status);
-}
-
-static void bnx2x_bmac_rx_disable(struct bnx2x *bp, u8 port)
-{
-	u32 bmac_addr = port ? NIG_REG_INGRESS_BMAC1_MEM :
-		NIG_REG_INGRESS_BMAC0_MEM;
-	u32 wb_data[2];
-	u32 nig_bmac_enable = REG_RD(bp, NIG_REG_BMAC0_REGS_OUT_EN + port*4);
-
-	/* Only if the bmac is out of reset */
-	if (REG_RD(bp, MISC_REG_RESET_REG_2) &
-			(MISC_REGISTERS_RESET_REG_2_RST_BMAC0 << port) &&
-	    nig_bmac_enable) {
-
-		/* Clear Rx Enable bit in BMAC_CONTROL register */
-		REG_RD_DMAE(bp, bmac_addr + BIGMAC_REGISTER_BMAC_CONTROL,
-			    wb_data, 2);
-		wb_data[0] &= ~BMAC_CONTROL_RX_ENABLE;
-		REG_WR_DMAE(bp, bmac_addr + BIGMAC_REGISTER_BMAC_CONTROL,
-			    wb_data, 2);
-
-		msleep(1);
-	}
-}
-
-static u8 bnx2x_pbf_update(struct link_params *params, u32 flow_ctrl,
-			 u32 line_speed)
-{
-	struct bnx2x *bp = params->bp;
-	u8 port = params->port;
-	u32 init_crd, crd;
-	u32 count = 1000;
-
-	/* disable port */
-	REG_WR(bp, PBF_REG_DISABLE_NEW_TASK_PROC_P0 + port*4, 0x1);
-
-	/* wait for init credit */
-	init_crd = REG_RD(bp, PBF_REG_P0_INIT_CRD + port*4);
-	crd = REG_RD(bp, PBF_REG_P0_CREDIT + port*8);
-	DP(NETIF_MSG_LINK, "init_crd 0x%x  crd 0x%x\n", init_crd, crd);
-
-	while ((init_crd != crd) && count) {
-		msleep(5);
-
-		crd = REG_RD(bp, PBF_REG_P0_CREDIT + port*8);
-		count--;
-	}
-	crd = REG_RD(bp, PBF_REG_P0_CREDIT + port*8);
-	if (init_crd != crd) {
-		DP(NETIF_MSG_LINK, "BUG! init_crd 0x%x != crd 0x%x\n",
-			  init_crd, crd);
-		return -EINVAL;
-	}
-
-	if (flow_ctrl & BNX2X_FLOW_CTRL_RX ||
-	    line_speed == SPEED_10 ||
-	    line_speed == SPEED_100 ||
-	    line_speed == SPEED_1000 ||
-	    line_speed == SPEED_2500) {
-		REG_WR(bp, PBF_REG_P0_PAUSE_ENABLE + port*4, 1);
-		/* update threshold */
-		REG_WR(bp, PBF_REG_P0_ARB_THRSH + port*4, 0);
-		/* update init credit */
-		init_crd = 778; 	/* (800-18-4) */
-
-	} else {
-		u32 thresh = (ETH_MAX_JUMBO_PACKET_SIZE +
-			      ETH_OVREHEAD)/16;
-		REG_WR(bp, PBF_REG_P0_PAUSE_ENABLE + port*4, 0);
-		/* update threshold */
-		REG_WR(bp, PBF_REG_P0_ARB_THRSH + port*4, thresh);
-		/* update init credit */
-		switch (line_speed) {
-		case SPEED_10000:
-			init_crd = thresh + 553 - 22;
-			break;
-
-		case SPEED_12000:
-			init_crd = thresh + 664 - 22;
-			break;
-
-		case SPEED_13000:
-			init_crd = thresh + 742 - 22;
-			break;
-
-		case SPEED_16000:
-			init_crd = thresh + 778 - 22;
-			break;
-		default:
-			DP(NETIF_MSG_LINK, "Invalid line_speed 0x%x\n",
-				  line_speed);
-			return -EINVAL;
-		}
-	}
-	REG_WR(bp, PBF_REG_P0_INIT_CRD + port*4, init_crd);
-	DP(NETIF_MSG_LINK, "PBF updated to speed %d credit %d\n",
-		 line_speed, init_crd);
-
-	/* probe the credit changes */
-	REG_WR(bp, PBF_REG_INIT_P0 + port*4, 0x1);
-	msleep(5);
-	REG_WR(bp, PBF_REG_INIT_P0 + port*4, 0x0);
-
-	/* enable port */
-	REG_WR(bp, PBF_REG_DISABLE_NEW_TASK_PROC_P0 + port*4, 0x0);
-	return 0;
-}
-
-static u32 bnx2x_get_emac_base(struct bnx2x *bp, u32 ext_phy_type, u8 port)
-{
-	u32 emac_base;
-
-	switch (ext_phy_type) {
-	case PORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM8072:
-	case PORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM8726:
-	case PORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM8727:
-		/* All MDC/MDIO is directed through single EMAC */
-		if (REG_RD(bp, NIG_REG_PORT_SWAP))
-			emac_base = GRCBASE_EMAC0;
-		else
-			emac_base = GRCBASE_EMAC1;
-		break;
-	case PORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM8073:
-		emac_base = (port) ? GRCBASE_EMAC0 : GRCBASE_EMAC1;
-		break;
-	default:
-		emac_base = (port) ? GRCBASE_EMAC1 : GRCBASE_EMAC0;
-		break;
-	}
-	return emac_base;
-
-}
-
-u8 bnx2x_cl45_write(struct bnx2x *bp, u8 port, u32 ext_phy_type,
-		  u8 phy_addr, u8 devad, u16 reg, u16 val)
-{
-	u32 tmp, saved_mode;
-	u8 i, rc = 0;
-	u32 mdio_ctrl = bnx2x_get_emac_base(bp, ext_phy_type, port);
-
-	/* set clause 45 mode, slow down the MDIO clock to 2.5MHz
-	 * (a value of 49==0x31) and make sure that the AUTO poll is off
-	 */
-
-	saved_mode = REG_RD(bp, mdio_ctrl + EMAC_REG_EMAC_MDIO_MODE);
-	tmp = saved_mode & ~(EMAC_MDIO_MODE_AUTO_POLL |
-			     EMAC_MDIO_MODE_CLOCK_CNT);
-	tmp |= (EMAC_MDIO_MODE_CLAUSE_45 |
-		(49 << EMAC_MDIO_MODE_CLOCK_CNT_BITSHIFT));
-	REG_WR(bp, mdio_ctrl + EMAC_REG_EMAC_MDIO_MODE, tmp);
-	REG_RD(bp, mdio_ctrl + EMAC_REG_EMAC_MDIO_MODE);
-	udelay(40);
-
-	/* address */
-
-	tmp = ((phy_addr << 21) | (devad << 16) | reg |
-	       EMAC_MDIO_COMM_COMMAND_ADDRESS |
-	       EMAC_MDIO_COMM_START_BUSY);
-	REG_WR(bp, mdio_ctrl + EMAC_REG_EMAC_MDIO_COMM, tmp);
-
-	for (i = 0; i < 50; i++) {
-		udelay(10);
-
-		tmp = REG_RD(bp, mdio_ctrl + EMAC_REG_EMAC_MDIO_COMM);
-		if (!(tmp & EMAC_MDIO_COMM_START_BUSY)) {
-			udelay(5);
-			break;
-		}
-	}
-	if (tmp & EMAC_MDIO_COMM_START_BUSY) {
-		DP(NETIF_MSG_LINK, "write phy register failed\n");
-		rc = -EFAULT;
-	} else {
-		/* data */
-		tmp = ((phy_addr << 21) | (devad << 16) | val |
-		       EMAC_MDIO_COMM_COMMAND_WRITE_45 |
-		       EMAC_MDIO_COMM_START_BUSY);
-		REG_WR(bp, mdio_ctrl + EMAC_REG_EMAC_MDIO_COMM, tmp);
-
-		for (i = 0; i < 50; i++) {
-			udelay(10);
-
-			tmp = REG_RD(bp, mdio_ctrl +
-					 EMAC_REG_EMAC_MDIO_COMM);
-			if (!(tmp & EMAC_MDIO_COMM_START_BUSY)) {
-				udelay(5);
-				break;
-			}
-		}
-		if (tmp & EMAC_MDIO_COMM_START_BUSY) {
-			DP(NETIF_MSG_LINK, "write phy register failed\n");
-			rc = -EFAULT;
-		}
-	}
-
-	/* Restore the saved mode */
-	REG_WR(bp, mdio_ctrl + EMAC_REG_EMAC_MDIO_MODE, saved_mode);
-
-	return rc;
-}
-
-u8 bnx2x_cl45_read(struct bnx2x *bp, u8 port, u32 ext_phy_type,
-		 u8 phy_addr, u8 devad, u16 reg, u16 *ret_val)
-{
-	u32 val, saved_mode;
-	u16 i;
-	u8 rc = 0;
-
-	u32 mdio_ctrl = bnx2x_get_emac_base(bp, ext_phy_type, port);
-	/* set clause 45 mode, slow down the MDIO clock to 2.5MHz
-	 * (a value of 49==0x31) and make sure that the AUTO poll is off
-	 */
-
-	saved_mode = REG_RD(bp, mdio_ctrl + EMAC_REG_EMAC_MDIO_MODE);
-	val = saved_mode & ((EMAC_MDIO_MODE_AUTO_POLL |
-			     EMAC_MDIO_MODE_CLOCK_CNT));
-	val |= (EMAC_MDIO_MODE_CLAUSE_45 |
-		(49L << EMAC_MDIO_MODE_CLOCK_CNT_BITSHIFT));
-	REG_WR(bp, mdio_ctrl + EMAC_REG_EMAC_MDIO_MODE, val);
-	REG_RD(bp, mdio_ctrl + EMAC_REG_EMAC_MDIO_MODE);
-	udelay(40);
-
-	/* address */
-	val = ((phy_addr << 21) | (devad << 16) | reg |
-	       EMAC_MDIO_COMM_COMMAND_ADDRESS |
-	       EMAC_MDIO_COMM_START_BUSY);
-	REG_WR(bp, mdio_ctrl + EMAC_REG_EMAC_MDIO_COMM, val);
-
-	for (i = 0; i < 50; i++) {
-		udelay(10);
-
-		val = REG_RD(bp, mdio_ctrl + EMAC_REG_EMAC_MDIO_COMM);
-		if (!(val & EMAC_MDIO_COMM_START_BUSY)) {
-			udelay(5);
-			break;
-		}
-	}
-	if (val & EMAC_MDIO_COMM_START_BUSY) {
-		DP(NETIF_MSG_LINK, "read phy register failed\n");
-
-		*ret_val = 0;
-		rc = -EFAULT;
-
-	} else {
-		/* data */
-		val = ((phy_addr << 21) | (devad << 16) |
-		       EMAC_MDIO_COMM_COMMAND_READ_45 |
-		       EMAC_MDIO_COMM_START_BUSY);
-		REG_WR(bp, mdio_ctrl + EMAC_REG_EMAC_MDIO_COMM, val);
-
-		for (i = 0; i < 50; i++) {
-			udelay(10);
-
-			val = REG_RD(bp, mdio_ctrl +
-					  EMAC_REG_EMAC_MDIO_COMM);
-			if (!(val & EMAC_MDIO_COMM_START_BUSY)) {
-				*ret_val = (u16)(val & EMAC_MDIO_COMM_DATA);
-				break;
-			}
-		}
-		if (val & EMAC_MDIO_COMM_START_BUSY) {
-			DP(NETIF_MSG_LINK, "read phy register failed\n");
-
-			*ret_val = 0;
-			rc = -EFAULT;
-		}
-	}
-
-	/* Restore the saved mode */
-	REG_WR(bp, mdio_ctrl + EMAC_REG_EMAC_MDIO_MODE, saved_mode);
-
-	return rc;
-}
-
-static void bnx2x_set_aer_mmd(struct link_params *params,
-			    struct link_vars   *vars)
-{
-	struct bnx2x *bp = params->bp;
-	u32 ser_lane;
-	u16 offset;
-
-	ser_lane = ((params->lane_config &
-		     PORT_HW_CFG_LANE_SWAP_CFG_MASTER_MASK) >>
-		     PORT_HW_CFG_LANE_SWAP_CFG_MASTER_SHIFT);
-
-	offset = (vars->phy_flags & PHY_XGXS_FLAG) ?
-		(params->phy_addr + ser_lane) : 0;
-
-	CL45_WR_OVER_CL22(bp, params->port,
-			      params->phy_addr,
-			      MDIO_REG_BANK_AER_BLOCK,
-			      MDIO_AER_BLOCK_AER_REG, 0x3800 + offset);
-}
-
-static void bnx2x_set_master_ln(struct link_params *params)
-{
-	struct bnx2x *bp = params->bp;
-	u16 new_master_ln, ser_lane;
-	ser_lane =  ((params->lane_config &
-		     PORT_HW_CFG_LANE_SWAP_CFG_MASTER_MASK) >>
-		     PORT_HW_CFG_LANE_SWAP_CFG_MASTER_SHIFT);
-
-	/* set the master_ln for AN */
-	CL45_RD_OVER_CL22(bp, params->port,
-			      params->phy_addr,
-			      MDIO_REG_BANK_XGXS_BLOCK2,
-			      MDIO_XGXS_BLOCK2_TEST_MODE_LANE,
-			      &new_master_ln);
-
-	CL45_WR_OVER_CL22(bp, params->port,
-			      params->phy_addr,
-			      MDIO_REG_BANK_XGXS_BLOCK2 ,
-			      MDIO_XGXS_BLOCK2_TEST_MODE_LANE,
-			      (new_master_ln | ser_lane));
-}
-
-static u8 bnx2x_reset_unicore(struct link_params *params)
-{
-	struct bnx2x *bp = params->bp;
-	u16 mii_control;
-	u16 i;
-
-	CL45_RD_OVER_CL22(bp, params->port,
-			      params->phy_addr,
-			      MDIO_REG_BANK_COMBO_IEEE0,
-			      MDIO_COMBO_IEEE0_MII_CONTROL, &mii_control);
-
-	/* reset the unicore */
-	CL45_WR_OVER_CL22(bp, params->port,
-			      params->phy_addr,
-			      MDIO_REG_BANK_COMBO_IEEE0,
-			      MDIO_COMBO_IEEE0_MII_CONTROL,
-			      (mii_control |
-			       MDIO_COMBO_IEEO_MII_CONTROL_RESET));
-	if (params->switch_cfg == SWITCH_CFG_1G)
-		bnx2x_set_serdes_access(params);
-
-	/* wait for the reset to self clear */
-	for (i = 0; i < MDIO_ACCESS_TIMEOUT; i++) {
-		udelay(5);
-
-		/* the reset erased the previous bank value */
-		CL45_RD_OVER_CL22(bp, params->port,
-				      params->phy_addr,
-			      MDIO_REG_BANK_COMBO_IEEE0,
-			      MDIO_COMBO_IEEE0_MII_CONTROL,
-			      &mii_control);
-
-		if (!(mii_control & MDIO_COMBO_IEEO_MII_CONTROL_RESET)) {
-			udelay(5);
-			return 0;
-		}
-	}
-
-	DP(NETIF_MSG_LINK, "BUG! XGXS is still in reset!\n");
-	return -EINVAL;
-
-}
-
-static void bnx2x_set_swap_lanes(struct link_params *params)
-{
-	struct bnx2x *bp = params->bp;
-	/* Each two bits represents a lane number:
-	   No swap is 0123 => 0x1b no need to enable the swap */
-	u16 ser_lane, rx_lane_swap, tx_lane_swap;
-
-	ser_lane = ((params->lane_config &
-			 PORT_HW_CFG_LANE_SWAP_CFG_MASTER_MASK) >>
-			PORT_HW_CFG_LANE_SWAP_CFG_MASTER_SHIFT);
-	rx_lane_swap = ((params->lane_config &
-			     PORT_HW_CFG_LANE_SWAP_CFG_RX_MASK) >>
-			    PORT_HW_CFG_LANE_SWAP_CFG_RX_SHIFT);
-	tx_lane_swap = ((params->lane_config &
-			     PORT_HW_CFG_LANE_SWAP_CFG_TX_MASK) >>
-			    PORT_HW_CFG_LANE_SWAP_CFG_TX_SHIFT);
-
-	if (rx_lane_swap != 0x1b) {
-		CL45_WR_OVER_CL22(bp, params->port,
-				      params->phy_addr,
-				    MDIO_REG_BANK_XGXS_BLOCK2,
-				    MDIO_XGXS_BLOCK2_RX_LN_SWAP,
-				    (rx_lane_swap |
-				    MDIO_XGXS_BLOCK2_RX_LN_SWAP_ENABLE |
-				    MDIO_XGXS_BLOCK2_RX_LN_SWAP_FORCE_ENABLE));
-	} else {
-		CL45_WR_OVER_CL22(bp, params->port,
-				      params->phy_addr,
-				      MDIO_REG_BANK_XGXS_BLOCK2,
-				      MDIO_XGXS_BLOCK2_RX_LN_SWAP, 0);
-	}
-
-	if (tx_lane_swap != 0x1b) {
-		CL45_WR_OVER_CL22(bp, params->port,
-				      params->phy_addr,
-				      MDIO_REG_BANK_XGXS_BLOCK2,
-				      MDIO_XGXS_BLOCK2_TX_LN_SWAP,
-				      (tx_lane_swap |
-				       MDIO_XGXS_BLOCK2_TX_LN_SWAP_ENABLE));
-	} else {
-		CL45_WR_OVER_CL22(bp, params->port,
-				      params->phy_addr,
-				      MDIO_REG_BANK_XGXS_BLOCK2,
-				      MDIO_XGXS_BLOCK2_TX_LN_SWAP, 0);
-	}
-}
-
-static void bnx2x_set_parallel_detection(struct link_params *params,
-				       u8       	 phy_flags)
-{
-	struct bnx2x *bp = params->bp;
-	u16 control2;
-
-	CL45_RD_OVER_CL22(bp, params->port,
-			      params->phy_addr,
-			      MDIO_REG_BANK_SERDES_DIGITAL,
-			      MDIO_SERDES_DIGITAL_A_1000X_CONTROL2,
-			      &control2);
-	if (params->speed_cap_mask & PORT_HW_CFG_SPEED_CAPABILITY_D0_1G)
-		control2 |= MDIO_SERDES_DIGITAL_A_1000X_CONTROL2_PRL_DT_EN;
-	else
-		control2 &= ~MDIO_SERDES_DIGITAL_A_1000X_CONTROL2_PRL_DT_EN;
-	DP(NETIF_MSG_LINK, "params->speed_cap_mask = 0x%x, control2 = 0x%x\n",
-		params->speed_cap_mask, control2);
-	CL45_WR_OVER_CL22(bp, params->port,
-			      params->phy_addr,
-			      MDIO_REG_BANK_SERDES_DIGITAL,
-			      MDIO_SERDES_DIGITAL_A_1000X_CONTROL2,
-			      control2);
-
-	if ((phy_flags & PHY_XGXS_FLAG) &&
-	     (params->speed_cap_mask &
-		    PORT_HW_CFG_SPEED_CAPABILITY_D0_10G)) {
-		DP(NETIF_MSG_LINK, "XGXS\n");
-
-		CL45_WR_OVER_CL22(bp, params->port,
-				      params->phy_addr,
-				MDIO_REG_BANK_10G_PARALLEL_DETECT,
-				MDIO_10G_PARALLEL_DETECT_PAR_DET_10G_LINK,
-				MDIO_10G_PARALLEL_DETECT_PAR_DET_10G_LINK_CNT);
-
-		CL45_RD_OVER_CL22(bp, params->port,
-				      params->phy_addr,
-				MDIO_REG_BANK_10G_PARALLEL_DETECT,
-				MDIO_10G_PARALLEL_DETECT_PAR_DET_10G_CONTROL,
-				&control2);
-
-
-		control2 |=
-		    MDIO_10G_PARALLEL_DETECT_PAR_DET_10G_CONTROL_PARDET10G_EN;
-
-		CL45_WR_OVER_CL22(bp, params->port,
-				      params->phy_addr,
-				MDIO_REG_BANK_10G_PARALLEL_DETECT,
-				MDIO_10G_PARALLEL_DETECT_PAR_DET_10G_CONTROL,
-				control2);
-
-		/* Disable parallel detection of HiG */
-		CL45_WR_OVER_CL22(bp, params->port,
-				      params->phy_addr,
-				MDIO_REG_BANK_XGXS_BLOCK2,
-				MDIO_XGXS_BLOCK2_UNICORE_MODE_10G,
-				MDIO_XGXS_BLOCK2_UNICORE_MODE_10G_CX4_XGXS |
-				MDIO_XGXS_BLOCK2_UNICORE_MODE_10G_HIGIG_XGXS);
-	}
-}
-
-static void bnx2x_set_autoneg(struct link_params *params,
-			    struct link_vars *vars,
-			    u8 enable_cl73)
-{
-	struct bnx2x *bp = params->bp;
-	u16 reg_val;
-
-	/* CL37 Autoneg */
-
-	CL45_RD_OVER_CL22(bp, params->port,
-			      params->phy_addr,
-			      MDIO_REG_BANK_COMBO_IEEE0,
-			      MDIO_COMBO_IEEE0_MII_CONTROL, &reg_val);
-
-	/* CL37 Autoneg Enabled */
-	if (vars->line_speed == SPEED_AUTO_NEG)
-		reg_val |= MDIO_COMBO_IEEO_MII_CONTROL_AN_EN;
-	else /* CL37 Autoneg Disabled */
-		reg_val &= ~(MDIO_COMBO_IEEO_MII_CONTROL_AN_EN |
-			     MDIO_COMBO_IEEO_MII_CONTROL_RESTART_AN);
-
-	CL45_WR_OVER_CL22(bp, params->port,
-			      params->phy_addr,
-			      MDIO_REG_BANK_COMBO_IEEE0,
-			      MDIO_COMBO_IEEE0_MII_CONTROL, reg_val);
-
-	/* Enable/Disable Autodetection */
-
-	CL45_RD_OVER_CL22(bp, params->port,
-			      params->phy_addr,
-			      MDIO_REG_BANK_SERDES_DIGITAL,
-			      MDIO_SERDES_DIGITAL_A_1000X_CONTROL1, &reg_val);
-	reg_val &= ~(MDIO_SERDES_DIGITAL_A_1000X_CONTROL1_SIGNAL_DETECT_EN |
-		    MDIO_SERDES_DIGITAL_A_1000X_CONTROL1_INVERT_SIGNAL_DETECT);
-	reg_val |= MDIO_SERDES_DIGITAL_A_1000X_CONTROL1_FIBER_MODE;
-	if (vars->line_speed == SPEED_AUTO_NEG)
-		reg_val |= MDIO_SERDES_DIGITAL_A_1000X_CONTROL1_AUTODET;
-	else
-		reg_val &= ~MDIO_SERDES_DIGITAL_A_1000X_CONTROL1_AUTODET;
-
-	CL45_WR_OVER_CL22(bp, params->port,
-			      params->phy_addr,
-			      MDIO_REG_BANK_SERDES_DIGITAL,
-			      MDIO_SERDES_DIGITAL_A_1000X_CONTROL1, reg_val);
-
-	/* Enable TetonII and BAM autoneg */
-	CL45_RD_OVER_CL22(bp, params->port,
-			      params->phy_addr,
-			      MDIO_REG_BANK_BAM_NEXT_PAGE,
-			      MDIO_BAM_NEXT_PAGE_MP5_NEXT_PAGE_CTRL,
-			  &reg_val);
-	if (vars->line_speed == SPEED_AUTO_NEG) {
-		/* Enable BAM aneg Mode and TetonII aneg Mode */
-		reg_val |= (MDIO_BAM_NEXT_PAGE_MP5_NEXT_PAGE_CTRL_BAM_MODE |
-			    MDIO_BAM_NEXT_PAGE_MP5_NEXT_PAGE_CTRL_TETON_AN);
-	} else {
-		/* TetonII and BAM Autoneg Disabled */
-		reg_val &= ~(MDIO_BAM_NEXT_PAGE_MP5_NEXT_PAGE_CTRL_BAM_MODE |
-			     MDIO_BAM_NEXT_PAGE_MP5_NEXT_PAGE_CTRL_TETON_AN);
-	}
-	CL45_WR_OVER_CL22(bp, params->port,
-			      params->phy_addr,
-			      MDIO_REG_BANK_BAM_NEXT_PAGE,
-			      MDIO_BAM_NEXT_PAGE_MP5_NEXT_PAGE_CTRL,
-			      reg_val);
-
-	if (enable_cl73) {
-		/* Enable Cl73 FSM status bits */
-		CL45_WR_OVER_CL22(bp, params->port,
-				      params->phy_addr,
-				      MDIO_REG_BANK_CL73_USERB0,
-				    MDIO_CL73_USERB0_CL73_UCTRL,
-				      0xe);
-
-		/* Enable BAM Station Manager*/
-		CL45_WR_OVER_CL22(bp, params->port,
-			params->phy_addr,
-			MDIO_REG_BANK_CL73_USERB0,
-			MDIO_CL73_USERB0_CL73_BAM_CTRL1,
-			MDIO_CL73_USERB0_CL73_BAM_CTRL1_BAM_EN |
-			MDIO_CL73_USERB0_CL73_BAM_CTRL1_BAM_STATION_MNGR_EN |
-			MDIO_CL73_USERB0_CL73_BAM_CTRL1_BAM_NP_AFTER_BP_EN);
-
-		/* Advertise CL73 link speeds */
-			CL45_RD_OVER_CL22(bp, params->port,
-					      params->phy_addr,
-					      MDIO_REG_BANK_CL73_IEEEB1,
-					      MDIO_CL73_IEEEB1_AN_ADV2,
-					      &reg_val);
-		if (params->speed_cap_mask &
-		    PORT_HW_CFG_SPEED_CAPABILITY_D0_10G)
-			reg_val |= MDIO_CL73_IEEEB1_AN_ADV2_ADVR_10G_KX4;
-		if (params->speed_cap_mask &
-		    PORT_HW_CFG_SPEED_CAPABILITY_D0_1G)
-			reg_val |= MDIO_CL73_IEEEB1_AN_ADV2_ADVR_1000M_KX;
-
-			CL45_WR_OVER_CL22(bp, params->port,
-					      params->phy_addr,
-					      MDIO_REG_BANK_CL73_IEEEB1,
-					      MDIO_CL73_IEEEB1_AN_ADV2,
-				      reg_val);
-
-		/* CL73 Autoneg Enabled */
-		reg_val = MDIO_CL73_IEEEB0_CL73_AN_CONTROL_AN_EN;
-
-	} else /* CL73 Autoneg Disabled */
-		reg_val = 0;
-
-	CL45_WR_OVER_CL22(bp, params->port,
-			      params->phy_addr,
-			      MDIO_REG_BANK_CL73_IEEEB0,
-			      MDIO_CL73_IEEEB0_CL73_AN_CONTROL, reg_val);
-}
-
-/* program SerDes, forced speed */
-static void bnx2x_program_serdes(struct link_params *params,
-			       struct link_vars *vars)
-{
-	struct bnx2x *bp = params->bp;
-	u16 reg_val;
-
-	/* program duplex, disable autoneg and sgmii*/
-	CL45_RD_OVER_CL22(bp, params->port,
-			      params->phy_addr,
-			      MDIO_REG_BANK_COMBO_IEEE0,
-			      MDIO_COMBO_IEEE0_MII_CONTROL, &reg_val);
-	reg_val &= ~(MDIO_COMBO_IEEO_MII_CONTROL_FULL_DUPLEX |
-		     MDIO_COMBO_IEEO_MII_CONTROL_AN_EN |
-		     MDIO_COMBO_IEEO_MII_CONTROL_MAN_SGMII_SP_MASK);
-	if (params->req_duplex == DUPLEX_FULL)
-		reg_val |= MDIO_COMBO_IEEO_MII_CONTROL_FULL_DUPLEX;
-	CL45_WR_OVER_CL22(bp, params->port,
-			      params->phy_addr,
-			      MDIO_REG_BANK_COMBO_IEEE0,
-			      MDIO_COMBO_IEEE0_MII_CONTROL, reg_val);
-
-	/* program speed
-	   - needed only if the speed is greater than 1G (2.5G or 10G) */
-	CL45_RD_OVER_CL22(bp, params->port,
-				      params->phy_addr,
-				      MDIO_REG_BANK_SERDES_DIGITAL,
-				      MDIO_SERDES_DIGITAL_MISC1, &reg_val);
-	/* clearing the speed value before setting the right speed */
-	DP(NETIF_MSG_LINK, "MDIO_REG_BANK_SERDES_DIGITAL = 0x%x\n", reg_val);
-
-	reg_val &= ~(MDIO_SERDES_DIGITAL_MISC1_FORCE_SPEED_MASK |
-		     MDIO_SERDES_DIGITAL_MISC1_FORCE_SPEED_SEL);
-
-	if (!((vars->line_speed == SPEED_1000) ||
-	      (vars->line_speed == SPEED_100) ||
-	      (vars->line_speed == SPEED_10))) {
-
-		reg_val |= (MDIO_SERDES_DIGITAL_MISC1_REFCLK_SEL_156_25M |
-			    MDIO_SERDES_DIGITAL_MISC1_FORCE_SPEED_SEL);
-		if (vars->line_speed == SPEED_10000)
-			reg_val |=
-				MDIO_SERDES_DIGITAL_MISC1_FORCE_SPEED_10G_CX4;
-		if (vars->line_speed == SPEED_13000)
-			reg_val |=
-				MDIO_SERDES_DIGITAL_MISC1_FORCE_SPEED_13G;
-	}
-
-	CL45_WR_OVER_CL22(bp, params->port,
-				      params->phy_addr,
-				      MDIO_REG_BANK_SERDES_DIGITAL,
-				      MDIO_SERDES_DIGITAL_MISC1, reg_val);
-
-}
-
-static void bnx2x_set_brcm_cl37_advertisment(struct link_params *params)
-{
-	struct bnx2x *bp = params->bp;
-	u16 val = 0;
-
-	/* configure the 48 bits for BAM AN */
-
-	/* set extended capabilities */
-	if (params->speed_cap_mask & PORT_HW_CFG_SPEED_CAPABILITY_D0_2_5G)
-		val |= MDIO_OVER_1G_UP1_2_5G;
-	if (params->speed_cap_mask & PORT_HW_CFG_SPEED_CAPABILITY_D0_10G)
-		val |= MDIO_OVER_1G_UP1_10G;
-	CL45_WR_OVER_CL22(bp, params->port,
-			      params->phy_addr,
-			      MDIO_REG_BANK_OVER_1G,
-			      MDIO_OVER_1G_UP1, val);
-
-	CL45_WR_OVER_CL22(bp, params->port,
-			      params->phy_addr,
-			      MDIO_REG_BANK_OVER_1G,
-			      MDIO_OVER_1G_UP3, 0x400);
-}
-
-static void bnx2x_calc_ieee_aneg_adv(struct link_params *params, u16 *ieee_fc)
-{
-	struct bnx2x *bp = params->bp;
-	*ieee_fc = MDIO_COMBO_IEEE0_AUTO_NEG_ADV_FULL_DUPLEX;
-	/* resolve pause mode and advertisement
-	 * Please refer to Table 28B-3 of the 802.3ab-1999 spec */
-
-	switch (params->req_flow_ctrl) {
-	case BNX2X_FLOW_CTRL_AUTO:
-		if (params->req_fc_auto_adv == BNX2X_FLOW_CTRL_BOTH) {
-			*ieee_fc |=
-			     MDIO_COMBO_IEEE0_AUTO_NEG_ADV_PAUSE_BOTH;
-		} else {
-			*ieee_fc |=
-		       MDIO_COMBO_IEEE0_AUTO_NEG_ADV_PAUSE_ASYMMETRIC;
-		}
-		break;
-	case BNX2X_FLOW_CTRL_TX:
-		*ieee_fc |=
-		       MDIO_COMBO_IEEE0_AUTO_NEG_ADV_PAUSE_ASYMMETRIC;
-		break;
-
-	case BNX2X_FLOW_CTRL_RX:
-	case BNX2X_FLOW_CTRL_BOTH:
-		*ieee_fc |= MDIO_COMBO_IEEE0_AUTO_NEG_ADV_PAUSE_BOTH;
-		break;
-
-	case BNX2X_FLOW_CTRL_NONE:
-	default:
-		*ieee_fc |= MDIO_COMBO_IEEE0_AUTO_NEG_ADV_PAUSE_NONE;
-		break;
-	}
-	DP(NETIF_MSG_LINK, "ieee_fc = 0x%x\n", *ieee_fc);
-}
-
-static void bnx2x_set_ieee_aneg_advertisment(struct link_params *params,
-					   u16 ieee_fc)
-{
-	struct bnx2x *bp = params->bp;
-	u16 val;
-	/* for AN, we are always publishing full duplex */
-
-	CL45_WR_OVER_CL22(bp, params->port,
-			      params->phy_addr,
-			      MDIO_REG_BANK_COMBO_IEEE0,
-			      MDIO_COMBO_IEEE0_AUTO_NEG_ADV, ieee_fc);
-	CL45_RD_OVER_CL22(bp, params->port,
-			      params->phy_addr,
-			      MDIO_REG_BANK_CL73_IEEEB1,
-			      MDIO_CL73_IEEEB1_AN_ADV1, &val);
-	val &= ~MDIO_CL73_IEEEB1_AN_ADV1_PAUSE_BOTH;
-	val |= ((ieee_fc<<3) & MDIO_CL73_IEEEB1_AN_ADV1_PAUSE_MASK);
-	CL45_WR_OVER_CL22(bp, params->port,
-			      params->phy_addr,
-			      MDIO_REG_BANK_CL73_IEEEB1,
-			      MDIO_CL73_IEEEB1_AN_ADV1, val);
-}
-
-static void bnx2x_restart_autoneg(struct link_params *params, u8 enable_cl73)
-{
-	struct bnx2x *bp = params->bp;
-	u16 mii_control;
-
-	DP(NETIF_MSG_LINK, "bnx2x_restart_autoneg\n");
-	/* Enable and restart BAM/CL37 aneg */
-
-	if (enable_cl73) {
-		CL45_RD_OVER_CL22(bp, params->port,
-				      params->phy_addr,
-				      MDIO_REG_BANK_CL73_IEEEB0,
-				      MDIO_CL73_IEEEB0_CL73_AN_CONTROL,
-				      &mii_control);
-
-		CL45_WR_OVER_CL22(bp, params->port,
-				params->phy_addr,
-				MDIO_REG_BANK_CL73_IEEEB0,
-				MDIO_CL73_IEEEB0_CL73_AN_CONTROL,
-				(mii_control |
-				MDIO_CL73_IEEEB0_CL73_AN_CONTROL_AN_EN |
-				MDIO_CL73_IEEEB0_CL73_AN_CONTROL_RESTART_AN));
-	} else {
-
-		CL45_RD_OVER_CL22(bp, params->port,
-				      params->phy_addr,
-				      MDIO_REG_BANK_COMBO_IEEE0,
-				      MDIO_COMBO_IEEE0_MII_CONTROL,
-				      &mii_control);
-		DP(NETIF_MSG_LINK,
-			 "bnx2x_restart_autoneg mii_control before = 0x%x\n",
-			 mii_control);
-		CL45_WR_OVER_CL22(bp, params->port,
-				      params->phy_addr,
-				      MDIO_REG_BANK_COMBO_IEEE0,
-				      MDIO_COMBO_IEEE0_MII_CONTROL,
-				      (mii_control |
-				       MDIO_COMBO_IEEO_MII_CONTROL_AN_EN |
-				       MDIO_COMBO_IEEO_MII_CONTROL_RESTART_AN));
-	}
-}
-
-static void bnx2x_initialize_sgmii_process(struct link_params *params,
-					 struct link_vars *vars)
-{
-	struct bnx2x *bp = params->bp;
-	u16 control1;
-
-	/* in SGMII mode, the unicore is always slave */
-
-	CL45_RD_OVER_CL22(bp, params->port,
-			      params->phy_addr,
-			      MDIO_REG_BANK_SERDES_DIGITAL,
-			      MDIO_SERDES_DIGITAL_A_1000X_CONTROL1,
-		      &control1);
-	control1 |= MDIO_SERDES_DIGITAL_A_1000X_CONTROL1_INVERT_SIGNAL_DETECT;
-	/* set sgmii mode (and not fiber) */
-	control1 &= ~(MDIO_SERDES_DIGITAL_A_1000X_CONTROL1_FIBER_MODE |
-		      MDIO_SERDES_DIGITAL_A_1000X_CONTROL1_AUTODET |
-		      MDIO_SERDES_DIGITAL_A_1000X_CONTROL1_MSTR_MODE);
-	CL45_WR_OVER_CL22(bp, params->port,
-			      params->phy_addr,
-			      MDIO_REG_BANK_SERDES_DIGITAL,
-			      MDIO_SERDES_DIGITAL_A_1000X_CONTROL1,
-			      control1);
-
-	/* if forced speed */
-	if (!(vars->line_speed == SPEED_AUTO_NEG)) {
-		/* set speed, disable autoneg */
-		u16 mii_control;
-
-		CL45_RD_OVER_CL22(bp, params->port,
-				      params->phy_addr,
-				      MDIO_REG_BANK_COMBO_IEEE0,
-				      MDIO_COMBO_IEEE0_MII_CONTROL,
-				      &mii_control);
-		mii_control &= ~(MDIO_COMBO_IEEO_MII_CONTROL_AN_EN |
-				 MDIO_COMBO_IEEO_MII_CONTROL_MAN_SGMII_SP_MASK|
-				 MDIO_COMBO_IEEO_MII_CONTROL_FULL_DUPLEX);
-
-		switch (vars->line_speed) {
-		case SPEED_100:
-			mii_control |=
-				MDIO_COMBO_IEEO_MII_CONTROL_MAN_SGMII_SP_100;
-			break;
-		case SPEED_1000:
-			mii_control |=
-				MDIO_COMBO_IEEO_MII_CONTROL_MAN_SGMII_SP_1000;
-			break;
-		case SPEED_10:
-			/* there is nothing to set for 10M */
-			break;
-		default:
-			/* invalid speed for SGMII */
-			DP(NETIF_MSG_LINK, "Invalid line_speed 0x%x\n",
-				  vars->line_speed);
-			break;
-		}
-
-		/* setting the full duplex */
-		if (params->req_duplex == DUPLEX_FULL)
-			mii_control |=
-				MDIO_COMBO_IEEO_MII_CONTROL_FULL_DUPLEX;
-		CL45_WR_OVER_CL22(bp, params->port,
-				      params->phy_addr,
-				      MDIO_REG_BANK_COMBO_IEEE0,
-				      MDIO_COMBO_IEEE0_MII_CONTROL,
-				      mii_control);
-
-	} else { /* AN mode */
-		/* enable and restart AN */
-		bnx2x_restart_autoneg(params, 0);
-	}
-}
-
-
-/*
- * link management
- */
-
-static void bnx2x_pause_resolve(struct link_vars *vars, u32 pause_result)
-{						/*  LD	    LP	 */
-	switch (pause_result) { 		/* ASYM P ASYM P */
-	case 0xb:       			/*   1  0   1  1 */
-		vars->flow_ctrl = BNX2X_FLOW_CTRL_TX;
-		break;
-
-	case 0xe:       			/*   1  1   1  0 */
-		vars->flow_ctrl = BNX2X_FLOW_CTRL_RX;
-		break;
-
-	case 0x5:       			/*   0  1   0  1 */
-	case 0x7:       			/*   0  1   1  1 */
-	case 0xd:       			/*   1  1   0  1 */
-	case 0xf:       			/*   1  1   1  1 */
-		vars->flow_ctrl = BNX2X_FLOW_CTRL_BOTH;
-		break;
-
-	default:
-		break;
-	}
-}
-
-static u8 bnx2x_ext_phy_resolve_fc(struct link_params *params,
-				  struct link_vars *vars)
-{
-	struct bnx2x *bp = params->bp;
-	u8 ext_phy_addr;
-	u16 ld_pause;		/* local */
-	u16 lp_pause;		/* link partner */
-	u16 an_complete;	/* AN complete */
-	u16 pause_result;
-	u8 ret = 0;
-	u32 ext_phy_type;
-	u8 port = params->port;
-	ext_phy_addr = XGXS_EXT_PHY_ADDR(params->ext_phy_config);
-	ext_phy_type = XGXS_EXT_PHY_TYPE(params->ext_phy_config);
-	/* read twice */
-
-	bnx2x_cl45_read(bp, port,
-		      ext_phy_type,
-		      ext_phy_addr,
-		      MDIO_AN_DEVAD,
-		      MDIO_AN_REG_STATUS, &an_complete);
-	bnx2x_cl45_read(bp, port,
-		      ext_phy_type,
-		      ext_phy_addr,
-		      MDIO_AN_DEVAD,
-		      MDIO_AN_REG_STATUS, &an_complete);
-
-	if (an_complete & MDIO_AN_REG_STATUS_AN_COMPLETE) {
-		ret = 1;
-		bnx2x_cl45_read(bp, port,
-			      ext_phy_type,
-			      ext_phy_addr,
-			      MDIO_AN_DEVAD,
-			      MDIO_AN_REG_ADV_PAUSE, &ld_pause);
-		bnx2x_cl45_read(bp, port,
-			      ext_phy_type,
-			      ext_phy_addr,
-			      MDIO_AN_DEVAD,
-			      MDIO_AN_REG_LP_AUTO_NEG, &lp_pause);
-		pause_result = (ld_pause &
-				MDIO_AN_REG_ADV_PAUSE_MASK) >> 8;
-		pause_result |= (lp_pause &
-				 MDIO_AN_REG_ADV_PAUSE_MASK) >> 10;
-		DP(NETIF_MSG_LINK, "Ext PHY pause result 0x%x \n",
-		   pause_result);
-		bnx2x_pause_resolve(vars, pause_result);
-		if (vars->flow_ctrl == BNX2X_FLOW_CTRL_NONE &&
-		     ext_phy_type == PORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM8073) {
-			bnx2x_cl45_read(bp, port,
-				      ext_phy_type,
-				      ext_phy_addr,
-				      MDIO_AN_DEVAD,
-				      MDIO_AN_REG_CL37_FC_LD, &ld_pause);
-
-			bnx2x_cl45_read(bp, port,
-				      ext_phy_type,
-				      ext_phy_addr,
-				      MDIO_AN_DEVAD,
-				      MDIO_AN_REG_CL37_FC_LP, &lp_pause);
-			pause_result = (ld_pause &
-				MDIO_COMBO_IEEE0_AUTO_NEG_ADV_PAUSE_BOTH) >> 5;
-			pause_result |= (lp_pause &
-				MDIO_COMBO_IEEE0_AUTO_NEG_ADV_PAUSE_BOTH) >> 7;
-
-			bnx2x_pause_resolve(vars, pause_result);
-			DP(NETIF_MSG_LINK, "Ext PHY CL37 pause result 0x%x \n",
-				 pause_result);
-		}
-	}
-	return ret;
-}
-
-static u8 bnx2x_direct_parallel_detect_used(struct link_params *params)
-{
-	struct bnx2x *bp = params->bp;
-	u16 pd_10g, status2_1000x;
-	CL45_RD_OVER_CL22(bp, params->port,
-			      params->phy_addr,
-			      MDIO_REG_BANK_SERDES_DIGITAL,
-			      MDIO_SERDES_DIGITAL_A_1000X_STATUS2,
-			      &status2_1000x);
-	CL45_RD_OVER_CL22(bp, params->port,
-			      params->phy_addr,
-			      MDIO_REG_BANK_SERDES_DIGITAL,
-			      MDIO_SERDES_DIGITAL_A_1000X_STATUS2,
-			      &status2_1000x);
-	if (status2_1000x & MDIO_SERDES_DIGITAL_A_1000X_STATUS2_AN_DISABLED) {
-		DP(NETIF_MSG_LINK, "1G parallel detect link on port %d\n",
-			 params->port);
-		return 1;
-	}
-
-	CL45_RD_OVER_CL22(bp, params->port,
-			      params->phy_addr,
-			      MDIO_REG_BANK_10G_PARALLEL_DETECT,
-			      MDIO_10G_PARALLEL_DETECT_PAR_DET_10G_STATUS,
-			      &pd_10g);
-
-	if (pd_10g & MDIO_10G_PARALLEL_DETECT_PAR_DET_10G_STATUS_PD_LINK) {
-		DP(NETIF_MSG_LINK, "10G parallel detect link on port %d\n",
-			 params->port);
-		return 1;
-	}
-	return 0;
-}
-
-static void bnx2x_flow_ctrl_resolve(struct link_params *params,
-				  struct link_vars *vars,
-				  u32 gp_status)
-{
-	struct bnx2x *bp = params->bp;
-	u16 ld_pause;   /* local driver */
-	u16 lp_pause;   /* link partner */
-	u16 pause_result;
-
-	vars->flow_ctrl = BNX2X_FLOW_CTRL_NONE;
-
-	/* resolve from gp_status in case of AN complete and not sgmii */
-	if ((params->req_flow_ctrl == BNX2X_FLOW_CTRL_AUTO) &&
-	    (gp_status & MDIO_AN_CL73_OR_37_COMPLETE) &&
-	    (!(vars->phy_flags & PHY_SGMII_FLAG)) &&
-	    (XGXS_EXT_PHY_TYPE(params->ext_phy_config) ==
-	     PORT_HW_CFG_XGXS_EXT_PHY_TYPE_DIRECT)) {
-		if (bnx2x_direct_parallel_detect_used(params)) {
-			vars->flow_ctrl = params->req_fc_auto_adv;
-			return;
-		}
-		if ((gp_status &
-		    (MDIO_GP_STATUS_TOP_AN_STATUS1_CL73_AUTONEG_COMPLETE |
-		     MDIO_GP_STATUS_TOP_AN_STATUS1_CL73_MR_LP_NP_AN_ABLE)) ==
-		    (MDIO_GP_STATUS_TOP_AN_STATUS1_CL73_AUTONEG_COMPLETE |
-		     MDIO_GP_STATUS_TOP_AN_STATUS1_CL73_MR_LP_NP_AN_ABLE)) {
-
-			CL45_RD_OVER_CL22(bp, params->port,
-					      params->phy_addr,
-					      MDIO_REG_BANK_CL73_IEEEB1,
-					      MDIO_CL73_IEEEB1_AN_ADV1,
-					      &ld_pause);
-			CL45_RD_OVER_CL22(bp, params->port,
-					     params->phy_addr,
-					     MDIO_REG_BANK_CL73_IEEEB1,
-					     MDIO_CL73_IEEEB1_AN_LP_ADV1,
-					     &lp_pause);
-			pause_result = (ld_pause &
-					MDIO_CL73_IEEEB1_AN_ADV1_PAUSE_MASK)
-					>> 8;
-			pause_result |= (lp_pause &
-					MDIO_CL73_IEEEB1_AN_LP_ADV1_PAUSE_MASK)
-					>> 10;
-			DP(NETIF_MSG_LINK, "pause_result CL73 0x%x\n",
-				 pause_result);
-		} else {
-
-			CL45_RD_OVER_CL22(bp, params->port,
-					      params->phy_addr,
-					      MDIO_REG_BANK_COMBO_IEEE0,
-					      MDIO_COMBO_IEEE0_AUTO_NEG_ADV,
-					      &ld_pause);
-			CL45_RD_OVER_CL22(bp, params->port,
-			       params->phy_addr,
-			       MDIO_REG_BANK_COMBO_IEEE0,
-			       MDIO_COMBO_IEEE0_AUTO_NEG_LINK_PARTNER_ABILITY1,
-			       &lp_pause);
-			pause_result = (ld_pause &
-				MDIO_COMBO_IEEE0_AUTO_NEG_ADV_PAUSE_MASK)>>5;
-			pause_result |= (lp_pause &
-				 MDIO_COMBO_IEEE0_AUTO_NEG_ADV_PAUSE_MASK)>>7;
-			DP(NETIF_MSG_LINK, "pause_result CL37 0x%x\n",
-				 pause_result);
-		}
-		bnx2x_pause_resolve(vars, pause_result);
-	} else if ((params->req_flow_ctrl == BNX2X_FLOW_CTRL_AUTO) &&
-		   (bnx2x_ext_phy_resolve_fc(params, vars))) {
-		return;
-	} else {
-		if (params->req_flow_ctrl == BNX2X_FLOW_CTRL_AUTO)
-			vars->flow_ctrl = params->req_fc_auto_adv;
-		else
-			vars->flow_ctrl = params->req_flow_ctrl;
-	}
-	DP(NETIF_MSG_LINK, "flow_ctrl 0x%x\n", vars->flow_ctrl);
-}
-
-static void bnx2x_check_fallback_to_cl37(struct link_params *params)
-{
-	struct bnx2x *bp = params->bp;
-	u16 rx_status, ustat_val, cl37_fsm_recieved;
-	DP(NETIF_MSG_LINK, "bnx2x_check_fallback_to_cl37\n");
-	/* Step 1: Make sure signal is detected */
-	CL45_RD_OVER_CL22(bp, params->port,
-			      params->phy_addr,
-			      MDIO_REG_BANK_RX0,
-			      MDIO_RX0_RX_STATUS,
-			      &rx_status);
-	if ((rx_status & MDIO_RX0_RX_STATUS_SIGDET) !=
-	    (MDIO_RX0_RX_STATUS_SIGDET)) {
-		DP(NETIF_MSG_LINK, "Signal is not detected. Restoring CL73."
-			     "rx_status(0x80b0) = 0x%x\n", rx_status);
-		CL45_WR_OVER_CL22(bp, params->port,
-				      params->phy_addr,
-				      MDIO_REG_BANK_CL73_IEEEB0,
-				      MDIO_CL73_IEEEB0_CL73_AN_CONTROL,
-				      MDIO_CL73_IEEEB0_CL73_AN_CONTROL_AN_EN);
-		return;
-	}
-	/* Step 2: Check CL73 state machine */
-	CL45_RD_OVER_CL22(bp, params->port,
-			      params->phy_addr,
-			      MDIO_REG_BANK_CL73_USERB0,
-			      MDIO_CL73_USERB0_CL73_USTAT1,
-			      &ustat_val);
-	if ((ustat_val &
-	     (MDIO_CL73_USERB0_CL73_USTAT1_LINK_STATUS_CHECK |
-	      MDIO_CL73_USERB0_CL73_USTAT1_AN_GOOD_CHECK_BAM37)) !=
-	    (MDIO_CL73_USERB0_CL73_USTAT1_LINK_STATUS_CHECK |
-	      MDIO_CL73_USERB0_CL73_USTAT1_AN_GOOD_CHECK_BAM37)) {
-		DP(NETIF_MSG_LINK, "CL73 state-machine is not stable. "
-			     "ustat_val(0x8371) = 0x%x\n", ustat_val);
-		return;
-	}
-	/* Step 3: Check CL37 Message Pages received to indicate LP
-	supports only CL37 */
-	CL45_RD_OVER_CL22(bp, params->port,
-			      params->phy_addr,
-			      MDIO_REG_BANK_REMOTE_PHY,
-			      MDIO_REMOTE_PHY_MISC_RX_STATUS,
-			      &cl37_fsm_recieved);
-	if ((cl37_fsm_recieved &
-	     (MDIO_REMOTE_PHY_MISC_RX_STATUS_CL37_FSM_RECEIVED_OVER1G_MSG |
-	     MDIO_REMOTE_PHY_MISC_RX_STATUS_CL37_FSM_RECEIVED_BRCM_OUI_MSG)) !=
-	    (MDIO_REMOTE_PHY_MISC_RX_STATUS_CL37_FSM_RECEIVED_OVER1G_MSG |
-	      MDIO_REMOTE_PHY_MISC_RX_STATUS_CL37_FSM_RECEIVED_BRCM_OUI_MSG)) {
-		DP(NETIF_MSG_LINK, "No CL37 FSM were received. "
-			     "misc_rx_status(0x8330) = 0x%x\n",
-			 cl37_fsm_recieved);
-		return;
-	}
-	/* The combined cl37/cl73 fsm state information indicating that we are
-	connected to a device which does not support cl73, but does support
-	cl37 BAM. In this case we disable cl73 and restart cl37 auto-neg */
-	/* Disable CL73 */
-	CL45_WR_OVER_CL22(bp, params->port,
-			      params->phy_addr,
-			      MDIO_REG_BANK_CL73_IEEEB0,
-			      MDIO_CL73_IEEEB0_CL73_AN_CONTROL,
-			      0);
-	/* Restart CL37 autoneg */
-	bnx2x_restart_autoneg(params, 0);
-	DP(NETIF_MSG_LINK, "Disabling CL73, and restarting CL37 autoneg\n");
-}
-static u8 bnx2x_link_settings_status(struct link_params *params,
-				   struct link_vars *vars,
-				   u32 gp_status,
-				   u8 ext_phy_link_up)
-{
-	struct bnx2x *bp = params->bp;
-	u16 new_line_speed;
-	u8 rc = 0;
-	vars->link_status = 0;
-
-	if (gp_status & MDIO_GP_STATUS_TOP_AN_STATUS1_LINK_STATUS) {
-		DP(NETIF_MSG_LINK, "phy link up gp_status=0x%x\n",
-			 gp_status);
-
-		vars->phy_link_up = 1;
-		vars->link_status |= LINK_STATUS_LINK_UP;
-
-		if (gp_status & MDIO_GP_STATUS_TOP_AN_STATUS1_DUPLEX_STATUS)
-			vars->duplex = DUPLEX_FULL;
-		else
-			vars->duplex = DUPLEX_HALF;
-
-		bnx2x_flow_ctrl_resolve(params, vars, gp_status);
-
-		switch (gp_status & GP_STATUS_SPEED_MASK) {
-		case GP_STATUS_10M:
-			new_line_speed = SPEED_10;
-			if (vars->duplex == DUPLEX_FULL)
-				vars->link_status |= LINK_10TFD;
-			else
-				vars->link_status |= LINK_10THD;
-			break;
-
-		case GP_STATUS_100M:
-			new_line_speed = SPEED_100;
-			if (vars->duplex == DUPLEX_FULL)
-				vars->link_status |= LINK_100TXFD;
-			else
-				vars->link_status |= LINK_100TXHD;
-			break;
-
-		case GP_STATUS_1G:
-		case GP_STATUS_1G_KX:
-			new_line_speed = SPEED_1000;
-			if (vars->duplex == DUPLEX_FULL)
-				vars->link_status |= LINK_1000TFD;
-			else
-				vars->link_status |= LINK_1000THD;
-			break;
-
-		case GP_STATUS_2_5G:
-			new_line_speed = SPEED_2500;
-			if (vars->duplex == DUPLEX_FULL)
-				vars->link_status |= LINK_2500TFD;
-			else
-				vars->link_status |= LINK_2500THD;
-			break;
-
-		case GP_STATUS_5G:
-		case GP_STATUS_6G:
-			DP(NETIF_MSG_LINK,
-				 "link speed unsupported  gp_status 0x%x\n",
-				  gp_status);
-			return -EINVAL;
-
-		case GP_STATUS_10G_KX4:
-		case GP_STATUS_10G_HIG:
-		case GP_STATUS_10G_CX4:
-			new_line_speed = SPEED_10000;
-			vars->link_status |= LINK_10GTFD;
-			break;
-
-		case GP_STATUS_12G_HIG:
-			new_line_speed = SPEED_12000;
-			vars->link_status |= LINK_12GTFD;
-			break;
-
-		case GP_STATUS_12_5G:
-			new_line_speed = SPEED_12500;
-			vars->link_status |= LINK_12_5GTFD;
-			break;
-
-		case GP_STATUS_13G:
-			new_line_speed = SPEED_13000;
-			vars->link_status |= LINK_13GTFD;
-			break;
-
-		case GP_STATUS_15G:
-			new_line_speed = SPEED_15000;
-			vars->link_status |= LINK_15GTFD;
-			break;
-
-		case GP_STATUS_16G:
-			new_line_speed = SPEED_16000;
-			vars->link_status |= LINK_16GTFD;
-			break;
-
-		default:
-			DP(NETIF_MSG_LINK,
-				  "link speed unsupported gp_status 0x%x\n",
-				  gp_status);
-			return -EINVAL;
-		}
-
-		/* Upon link speed change set the NIG into drain mode.
-		Comes to deals with possible FIFO glitch due to clk change
-		when speed is decreased without link down indicator */
-		if (new_line_speed != vars->line_speed) {
-			if (XGXS_EXT_PHY_TYPE(params->ext_phy_config) !=
-			     PORT_HW_CFG_XGXS_EXT_PHY_TYPE_DIRECT &&
-			    ext_phy_link_up) {
-				DP(NETIF_MSG_LINK, "Internal link speed %d is"
-					    " different than the external"
-					    " link speed %d\n", new_line_speed,
-					  vars->line_speed);
-				vars->phy_link_up = 0;
-				return 0;
-			}
-			REG_WR(bp, NIG_REG_EGRESS_DRAIN0_MODE
-				    + params->port*4, 0);
-			msleep(1);
-		}
-		vars->line_speed = new_line_speed;
-		vars->link_status |= LINK_STATUS_SERDES_LINK;
-
-		if ((params->req_line_speed == SPEED_AUTO_NEG) &&
-		    ((XGXS_EXT_PHY_TYPE(params->ext_phy_config) ==
-		     PORT_HW_CFG_XGXS_EXT_PHY_TYPE_DIRECT) ||
-		    (XGXS_EXT_PHY_TYPE(params->ext_phy_config) ==
-		     PORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM8705) ||
-		    (XGXS_EXT_PHY_TYPE(params->ext_phy_config) ==
-		     PORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM8706) ||
-		    (XGXS_EXT_PHY_TYPE(params->ext_phy_config) ==
-		     PORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM8726))) {
-			vars->autoneg = AUTO_NEG_ENABLED;
-
-			if (gp_status & MDIO_AN_CL73_OR_37_COMPLETE) {
-				vars->autoneg |= AUTO_NEG_COMPLETE;
-				vars->link_status |=
-					LINK_STATUS_AUTO_NEGOTIATE_COMPLETE;
-			}
-
-			vars->autoneg |= AUTO_NEG_PARALLEL_DETECTION_USED;
-			vars->link_status |=
-				LINK_STATUS_PARALLEL_DETECTION_USED;
-
-		}
-		if (vars->flow_ctrl & BNX2X_FLOW_CTRL_TX)
-			vars->link_status |=
-				LINK_STATUS_TX_FLOW_CONTROL_ENABLED;
-
-		if (vars->flow_ctrl & BNX2X_FLOW_CTRL_RX)
-			vars->link_status |=
-				LINK_STATUS_RX_FLOW_CONTROL_ENABLED;
-
-	} else { /* link_down */
-		DP(NETIF_MSG_LINK, "phy link down\n");
-
-		vars->phy_link_up = 0;
-
-		vars->duplex = DUPLEX_FULL;
-		vars->flow_ctrl = BNX2X_FLOW_CTRL_NONE;
-		vars->autoneg = AUTO_NEG_DISABLED;
-		vars->mac_type = MAC_TYPE_NONE;
-
-		if ((params->req_line_speed == SPEED_AUTO_NEG) &&
-		    ((XGXS_EXT_PHY_TYPE(params->ext_phy_config) ==
-		     PORT_HW_CFG_XGXS_EXT_PHY_TYPE_DIRECT))) {
-			/* Check signal is detected */
-			bnx2x_check_fallback_to_cl37(params);
-		}
-	}
-
-	DP(NETIF_MSG_LINK, "gp_status 0x%x  phy_link_up %x line_speed %x \n",
-		 gp_status, vars->phy_link_up, vars->line_speed);
-	DP(NETIF_MSG_LINK, "duplex %x  flow_ctrl 0x%x"
-		 " autoneg 0x%x\n",
-		 vars->duplex,
-		 vars->flow_ctrl, vars->autoneg);
-	DP(NETIF_MSG_LINK, "link_status 0x%x\n", vars->link_status);
-
-	return rc;
-}
-
-static void bnx2x_set_gmii_tx_driver(struct link_params *params)
-{
-	struct bnx2x *bp = params->bp;
-	u16 lp_up2;
-	u16 tx_driver;
-	u16 bank;
-
-	/* read precomp */
-	CL45_RD_OVER_CL22(bp, params->port,
-			      params->phy_addr,
-			      MDIO_REG_BANK_OVER_1G,
-			      MDIO_OVER_1G_LP_UP2, &lp_up2);
-
-	/* bits [10:7] at lp_up2, positioned at [15:12] */
-	lp_up2 = (((lp_up2 & MDIO_OVER_1G_LP_UP2_PREEMPHASIS_MASK) >>
-		   MDIO_OVER_1G_LP_UP2_PREEMPHASIS_SHIFT) <<
-		  MDIO_TX0_TX_DRIVER_PREEMPHASIS_SHIFT);
-
-	if (lp_up2 == 0)
-		return;
-
-	for (bank = MDIO_REG_BANK_TX0; bank <= MDIO_REG_BANK_TX3;
-	      bank += (MDIO_REG_BANK_TX1 - MDIO_REG_BANK_TX0)) {
-		CL45_RD_OVER_CL22(bp, params->port,
-				      params->phy_addr,
-				      bank,
-				      MDIO_TX0_TX_DRIVER, &tx_driver);
-
-		/* replace tx_driver bits [15:12] */
-		if (lp_up2 !=
-		    (tx_driver & MDIO_TX0_TX_DRIVER_PREEMPHASIS_MASK)) {
-			tx_driver &= ~MDIO_TX0_TX_DRIVER_PREEMPHASIS_MASK;
-			tx_driver |= lp_up2;
-			CL45_WR_OVER_CL22(bp, params->port,
-					      params->phy_addr,
-					      bank,
-					      MDIO_TX0_TX_DRIVER, tx_driver);
-		}
-	}
-}
-
-static u8 bnx2x_emac_program(struct link_params *params,
-			   u32 line_speed, u32 duplex)
-{
-	struct bnx2x *bp = params->bp;
-	u8 port = params->port;
-	u16 mode = 0;
-
-	DP(NETIF_MSG_LINK, "setting link speed & duplex\n");
-	bnx2x_bits_dis(bp, GRCBASE_EMAC0 + port*0x400 +
-		     EMAC_REG_EMAC_MODE,
-		     (EMAC_MODE_25G_MODE |
-		     EMAC_MODE_PORT_MII_10M |
-		     EMAC_MODE_HALF_DUPLEX));
-	switch (line_speed) {
-	case SPEED_10:
-		mode |= EMAC_MODE_PORT_MII_10M;
-		break;
-
-	case SPEED_100:
-		mode |= EMAC_MODE_PORT_MII;
-		break;
-
-	case SPEED_1000:
-		mode |= EMAC_MODE_PORT_GMII;
-		break;
-
-	case SPEED_2500:
-		mode |= (EMAC_MODE_25G_MODE | EMAC_MODE_PORT_GMII);
-		break;
-
-	default:
-		/* 10G not valid for EMAC */
-		DP(NETIF_MSG_LINK, "Invalid line_speed 0x%x\n", line_speed);
-		return -EINVAL;
-	}
-
-	if (duplex == DUPLEX_HALF)
-		mode |= EMAC_MODE_HALF_DUPLEX;
-	bnx2x_bits_en(bp,
-		    GRCBASE_EMAC0 + port*0x400 + EMAC_REG_EMAC_MODE,
-		    mode);
-
-	bnx2x_set_led(params, LED_MODE_OPER, line_speed);
-	return 0;
-}
-
-/*****************************************************************************/
-/*      		     External Phy section       		     */
-/*****************************************************************************/
-void bnx2x_ext_phy_hw_reset(struct bnx2x *bp, u8 port)
-{
-	bnx2x_set_gpio(bp, MISC_REGISTERS_GPIO_1,
-		       MISC_REGISTERS_GPIO_OUTPUT_LOW, port);
-	msleep(1);
-	bnx2x_set_gpio(bp, MISC_REGISTERS_GPIO_1,
-		      MISC_REGISTERS_GPIO_OUTPUT_HIGH, port);
-}
-
-static void bnx2x_ext_phy_reset(struct link_params *params,
-			      struct link_vars   *vars)
-{
-	struct bnx2x *bp = params->bp;
-	u32 ext_phy_type;
-	u8 ext_phy_addr = XGXS_EXT_PHY_ADDR(params->ext_phy_config);
-
-	DP(NETIF_MSG_LINK, "Port %x: bnx2x_ext_phy_reset\n", params->port);
-	ext_phy_type = XGXS_EXT_PHY_TYPE(params->ext_phy_config);
-	/* The PHY reset is controled by GPIO 1
-	 * Give it 1ms of reset pulse
-	 */
-	if (vars->phy_flags & PHY_XGXS_FLAG) {
-
-		switch (ext_phy_type) {
-		case PORT_HW_CFG_XGXS_EXT_PHY_TYPE_DIRECT:
-			DP(NETIF_MSG_LINK, "XGXS Direct\n");
-			break;
-
-		case PORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM8705:
-		case PORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM8706:
-			DP(NETIF_MSG_LINK, "XGXS 8705/8706\n");
-
-			/* Restore normal power mode*/
-			bnx2x_set_gpio(bp, MISC_REGISTERS_GPIO_2,
-				      MISC_REGISTERS_GPIO_OUTPUT_HIGH,
-					  params->port);
-
-			/* HW reset */
-			bnx2x_ext_phy_hw_reset(bp, params->port);
-
-			bnx2x_cl45_write(bp, params->port,
-				       ext_phy_type,
-				       ext_phy_addr,
-				       MDIO_PMA_DEVAD,
-				       MDIO_PMA_REG_CTRL, 0xa040);
-			break;
-
-		case PORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM8727:
-			break;
-
-		case PORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM8726:
-
-			/* Restore normal power mode*/
-			bnx2x_set_gpio(bp, MISC_REGISTERS_GPIO_2,
-					  MISC_REGISTERS_GPIO_OUTPUT_HIGH,
-					  params->port);
-
-			bnx2x_set_gpio(bp, MISC_REGISTERS_GPIO_1,
-					  MISC_REGISTERS_GPIO_OUTPUT_HIGH,
-					  params->port);
-
-			bnx2x_cl45_write(bp, params->port,
-				       ext_phy_type,
-				       ext_phy_addr,
-				       MDIO_PMA_DEVAD,
-				       MDIO_PMA_REG_CTRL,
-				       1<<15);
-			break;
-
-		case PORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM8072:
-			DP(NETIF_MSG_LINK, "XGXS 8072\n");
-
-			/* Unset Low Power Mode and SW reset */
-			/* Restore normal power mode*/
-			bnx2x_set_gpio(bp, MISC_REGISTERS_GPIO_2,
-				      MISC_REGISTERS_GPIO_OUTPUT_HIGH,
-					  params->port);
-
-			bnx2x_cl45_write(bp, params->port,
-				       ext_phy_type,
-				       ext_phy_addr,
-				       MDIO_PMA_DEVAD,
-				       MDIO_PMA_REG_CTRL,
-				       1<<15);
-			break;
-
-		case PORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM8073:
-			DP(NETIF_MSG_LINK, "XGXS 8073\n");
-
-			/* Restore normal power mode*/
-			bnx2x_set_gpio(bp, MISC_REGISTERS_GPIO_2,
-				      MISC_REGISTERS_GPIO_OUTPUT_HIGH,
-					  params->port);
-
-			bnx2x_set_gpio(bp, MISC_REGISTERS_GPIO_1,
-				      MISC_REGISTERS_GPIO_OUTPUT_HIGH,
-					  params->port);
-			break;
-
-		case PORT_HW_CFG_XGXS_EXT_PHY_TYPE_SFX7101:
-			DP(NETIF_MSG_LINK, "XGXS SFX7101\n");
-
-			/* Restore normal power mode*/
-			bnx2x_set_gpio(bp, MISC_REGISTERS_GPIO_2,
-				      MISC_REGISTERS_GPIO_OUTPUT_HIGH,
-					  params->port);
-
-			/* HW reset */
-			bnx2x_ext_phy_hw_reset(bp, params->port);
-			break;
-
-		case PORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM8481:
-			/* Restore normal power mode*/
-			bnx2x_set_gpio(bp, MISC_REGISTERS_GPIO_2,
-				      MISC_REGISTERS_GPIO_OUTPUT_HIGH,
-					  params->port);
-
-			/* HW reset */
-			bnx2x_ext_phy_hw_reset(bp, params->port);
-
-			bnx2x_cl45_write(bp, params->port,
-				       ext_phy_type,
-				       ext_phy_addr,
-				       MDIO_PMA_DEVAD,
-				       MDIO_PMA_REG_CTRL,
-				       1<<15);
-			break;
-		case PORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM84823:
-			break;
-		case PORT_HW_CFG_XGXS_EXT_PHY_TYPE_FAILURE:
-			DP(NETIF_MSG_LINK, "XGXS PHY Failure detected\n");
-			break;
-
-		default:
-			DP(NETIF_MSG_LINK, "BAD XGXS ext_phy_config 0x%x\n",
-			   params->ext_phy_config);
-			break;
-		}
-
-	} else { /* SerDes */
-		ext_phy_type = SERDES_EXT_PHY_TYPE(params->ext_phy_config);
-		switch (ext_phy_type) {
-		case PORT_HW_CFG_SERDES_EXT_PHY_TYPE_DIRECT:
-			DP(NETIF_MSG_LINK, "SerDes Direct\n");
-			break;
-
-		case PORT_HW_CFG_SERDES_EXT_PHY_TYPE_BCM5482:
-			DP(NETIF_MSG_LINK, "SerDes 5482\n");
-			bnx2x_ext_phy_hw_reset(bp, params->port);
-			break;
-
-		default:
-			DP(NETIF_MSG_LINK, "BAD SerDes ext_phy_config 0x%x\n",
-				 params->ext_phy_config);
-			break;
-		}
-	}
-}
-
-static void bnx2x_save_spirom_version(struct bnx2x *bp, u8 port,
-				    u32 shmem_base, u32 spirom_ver)
-{
-	DP(NETIF_MSG_LINK, "FW version 0x%x:0x%x for port %d\n",
-		 (u16)(spirom_ver>>16), (u16)spirom_ver, port);
-	REG_WR(bp, shmem_base +
-		   offsetof(struct shmem_region,
-			    port_mb[port].ext_phy_fw_version),
-			spirom_ver);
-}
-
-static void bnx2x_save_bcm_spirom_ver(struct bnx2x *bp, u8 port,
-				    u32 ext_phy_type, u8 ext_phy_addr,
-				    u32 shmem_base)
-{
-	u16 fw_ver1, fw_ver2;
-
-	bnx2x_cl45_read(bp, port, ext_phy_type, ext_phy_addr, MDIO_PMA_DEVAD,
-		      MDIO_PMA_REG_ROM_VER1, &fw_ver1);
-	bnx2x_cl45_read(bp, port, ext_phy_type, ext_phy_addr, MDIO_PMA_DEVAD,
-		      MDIO_PMA_REG_ROM_VER2, &fw_ver2);
-	bnx2x_save_spirom_version(bp, port, shmem_base,
-				(u32)(fw_ver1<<16 | fw_ver2));
-}
-
-
-static void bnx2x_save_8481_spirom_version(struct bnx2x *bp, u8 port,
-					 u8 ext_phy_addr, u32 shmem_base)
-{
-	u16 val, fw_ver1, fw_ver2, cnt;
-	/* For the 32 bits registers in 8481, access via MDIO2ARM interface.*/
-	/* (1) set register 0xc200_0014(SPI_BRIDGE_CTRL_2) to 0x03000000 */
-	bnx2x_cl45_write(bp, port,
-		       PORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM8481,
-		       ext_phy_addr, MDIO_PMA_DEVAD,
-		       0xA819, 0x0014);
-	bnx2x_cl45_write(bp, port,
-		       PORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM8481,
-		       ext_phy_addr,
-		       MDIO_PMA_DEVAD,
-		       0xA81A,
-		       0xc200);
-	bnx2x_cl45_write(bp, port,
-		       PORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM8481,
-		       ext_phy_addr,
-		       MDIO_PMA_DEVAD,
-		       0xA81B,
-		       0x0000);
-	bnx2x_cl45_write(bp, port,
-		       PORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM8481,
-		       ext_phy_addr,
-		       MDIO_PMA_DEVAD,
-		       0xA81C,
-		       0x0300);
-	bnx2x_cl45_write(bp, port,
-		       PORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM8481,
-		       ext_phy_addr,
-		       MDIO_PMA_DEVAD,
-		       0xA817,
-		       0x0009);
-
-	for (cnt = 0; cnt < 100; cnt++) {
-		bnx2x_cl45_read(bp, port,
-			      PORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM8481,
-			      ext_phy_addr,
-			      MDIO_PMA_DEVAD,
-			      0xA818,
-			      &val);
-		if (val & 1)
-			break;
-		udelay(5);
-	}
-	if (cnt == 100) {
-		DP(NETIF_MSG_LINK, "Unable to read 8481 phy fw version(1)\n");
-		bnx2x_save_spirom_version(bp, port,
-					shmem_base, 0);
-		return;
-	}
-
-
-	/* 2) read register 0xc200_0000 (SPI_FW_STATUS) */
-	bnx2x_cl45_write(bp, port,
-		       PORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM8481,
-		       ext_phy_addr, MDIO_PMA_DEVAD,
-		       0xA819, 0x0000);
-	bnx2x_cl45_write(bp, port,
-		       PORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM8481,
-		       ext_phy_addr, MDIO_PMA_DEVAD,
-		       0xA81A, 0xc200);
-	bnx2x_cl45_write(bp, port,
-		       PORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM8481,
-		       ext_phy_addr, MDIO_PMA_DEVAD,
-		       0xA817, 0x000A);
-	for (cnt = 0; cnt < 100; cnt++) {
-		bnx2x_cl45_read(bp, port,
-			      PORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM8481,
-			      ext_phy_addr,
-			      MDIO_PMA_DEVAD,
-			      0xA818,
-			      &val);
-		if (val & 1)
-			break;
-		udelay(5);
-	}
-	if (cnt == 100) {
-		DP(NETIF_MSG_LINK, "Unable to read 8481 phy fw version(2)\n");
-		bnx2x_save_spirom_version(bp, port,
-					shmem_base, 0);
-		return;
-	}
-
-	/* lower 16 bits of the register SPI_FW_STATUS */
-	bnx2x_cl45_read(bp, port,
-		      PORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM8481,
-		      ext_phy_addr,
-		      MDIO_PMA_DEVAD,
-		      0xA81B,
-		      &fw_ver1);
-	/* upper 16 bits of register SPI_FW_STATUS */
-	bnx2x_cl45_read(bp, port,
-		      PORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM8481,
-		      ext_phy_addr,
-		      MDIO_PMA_DEVAD,
-		      0xA81C,
-		      &fw_ver2);
-
-	bnx2x_save_spirom_version(bp, port,
-				shmem_base, (fw_ver2<<16) | fw_ver1);
-}
-
-static void bnx2x_bcm8072_external_rom_boot(struct link_params *params)
-{
-	struct bnx2x *bp = params->bp;
-	u8 port = params->port;
-	u8 ext_phy_addr = XGXS_EXT_PHY_ADDR(params->ext_phy_config);
-	u32 ext_phy_type = XGXS_EXT_PHY_TYPE(params->ext_phy_config);
-
-	/* Need to wait 200ms after reset */
-	msleep(200);
-	/* Boot port from external ROM
-	 * Set ser_boot_ctl bit in the MISC_CTRL1 register
-	 */
-	bnx2x_cl45_write(bp, port, ext_phy_type, ext_phy_addr,
-			    MDIO_PMA_DEVAD,
-			    MDIO_PMA_REG_MISC_CTRL1, 0x0001);
-
-	/* Reset internal microprocessor */
-	bnx2x_cl45_write(bp, port, ext_phy_type, ext_phy_addr,
-			  MDIO_PMA_DEVAD,
-			  MDIO_PMA_REG_GEN_CTRL,
-			  MDIO_PMA_REG_GEN_CTRL_ROM_RESET_INTERNAL_MP);
-	/* set micro reset = 0 */
-	bnx2x_cl45_write(bp, port, ext_phy_type, ext_phy_addr,
-			    MDIO_PMA_DEVAD,
-			    MDIO_PMA_REG_GEN_CTRL,
-			    MDIO_PMA_REG_GEN_CTRL_ROM_MICRO_RESET);
-	/* Reset internal microprocessor */
-	bnx2x_cl45_write(bp, port, ext_phy_type, ext_phy_addr,
-			  MDIO_PMA_DEVAD,
-			  MDIO_PMA_REG_GEN_CTRL,
-			  MDIO_PMA_REG_GEN_CTRL_ROM_RESET_INTERNAL_MP);
-	/* wait for 100ms for code download via SPI port */
-	msleep(100);
-
-	/* Clear ser_boot_ctl bit */
-	bnx2x_cl45_write(bp, port, ext_phy_type, ext_phy_addr,
-			    MDIO_PMA_DEVAD,
-			    MDIO_PMA_REG_MISC_CTRL1, 0x0000);
-	/* Wait 100ms */
-	msleep(100);
-
-	bnx2x_save_bcm_spirom_ver(bp, port,
-				ext_phy_type,
-				ext_phy_addr,
-				params->shmem_base);
-}
-
-static u8 bnx2x_8073_is_snr_needed(struct link_params *params)
-{
-	/* This is only required for 8073A1, version 102 only */
-
-	struct bnx2x *bp = params->bp;
-	u8 ext_phy_addr = XGXS_EXT_PHY_ADDR(params->ext_phy_config);
-	u16 val;
-
-	/* Read 8073 HW revision*/
-	bnx2x_cl45_read(bp, params->port,
-		      PORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM8073,
-		      ext_phy_addr,
-		      MDIO_PMA_DEVAD,
-		      MDIO_PMA_REG_8073_CHIP_REV, &val);
-
-	if (val != 1) {
-		/* No need to workaround in 8073 A1 */
-		return 0;
-	}
-
-	bnx2x_cl45_read(bp, params->port,
-		      PORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM8073,
-		      ext_phy_addr,
-		      MDIO_PMA_DEVAD,
-		      MDIO_PMA_REG_ROM_VER2, &val);
-
-	/* SNR should be applied only for version 0x102 */
-	if (val != 0x102)
-		return 0;
-
-	return 1;
-}
-
-static u8 bnx2x_bcm8073_xaui_wa(struct link_params *params)
-{
-	struct bnx2x *bp = params->bp;
-	u8 ext_phy_addr = XGXS_EXT_PHY_ADDR(params->ext_phy_config);
-	u16 val, cnt, cnt1 ;
-
-	bnx2x_cl45_read(bp, params->port,
-		      PORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM8073,
-		      ext_phy_addr,
-		      MDIO_PMA_DEVAD,
-		      MDIO_PMA_REG_8073_CHIP_REV, &val);
-
-	if (val > 0) {
-		/* No need to workaround in 8073 A1 */
-		return 0;
-	}
-	/* XAUI workaround in 8073 A0: */
-
-	/* After loading the boot ROM and restarting Autoneg,
-	poll Dev1, Reg $C820: */
-
-	for (cnt = 0; cnt < 1000; cnt++) {
-		bnx2x_cl45_read(bp, params->port,
-			      PORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM8073,
-			      ext_phy_addr,
-			      MDIO_PMA_DEVAD,
-			      MDIO_PMA_REG_8073_SPEED_LINK_STATUS,
-			      &val);
-		  /* If bit [14] = 0 or bit [13] = 0, continue on with
-		   system initialization (XAUI work-around not required,
-		    as these bits indicate 2.5G or 1G link up). */
-		if (!(val & (1<<14)) || !(val & (1<<13))) {
-			DP(NETIF_MSG_LINK, "XAUI work-around not required\n");
-			return 0;
-		} else if (!(val & (1<<15))) {
-			DP(NETIF_MSG_LINK, "clc bit 15 went off\n");
-			 /* If bit 15 is 0, then poll Dev1, Reg $C841 until
-			  it's MSB (bit 15) goes to 1 (indicating that the
-			  XAUI workaround has completed),
-			  then continue on with system initialization.*/
-			for (cnt1 = 0; cnt1 < 1000; cnt1++) {
-				bnx2x_cl45_read(bp, params->port,
-					PORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM8073,
-					ext_phy_addr,
-					MDIO_PMA_DEVAD,
-					MDIO_PMA_REG_8073_XAUI_WA, &val);
-				if (val & (1<<15)) {
-					DP(NETIF_MSG_LINK,
-					  "XAUI workaround has completed\n");
-					return 0;
-				 }
-				 msleep(3);
-			}
-			break;
-		}
-		msleep(3);
-	}
-	DP(NETIF_MSG_LINK, "Warning: XAUI work-around timeout !!!\n");
-	return -EINVAL;
-}
-
-static void bnx2x_bcm8073_bcm8727_external_rom_boot(struct bnx2x *bp, u8 port,
-						  u8 ext_phy_addr,
-						  u32 ext_phy_type,
-						  u32 shmem_base)
-{
-	/* Boot port from external ROM  */
-	/* EDC grst */
-	bnx2x_cl45_write(bp, port,
-		       ext_phy_type,
-		       ext_phy_addr,
-		       MDIO_PMA_DEVAD,
-		       MDIO_PMA_REG_GEN_CTRL,
-		       0x0001);
-
-	/* ucode reboot and rst */
-	bnx2x_cl45_write(bp, port,
-		       ext_phy_type,
-		       ext_phy_addr,
-		       MDIO_PMA_DEVAD,
-		       MDIO_PMA_REG_GEN_CTRL,
-		       0x008c);
-
-	bnx2x_cl45_write(bp, port,
-		       ext_phy_type,
-		       ext_phy_addr,
-		       MDIO_PMA_DEVAD,
-		       MDIO_PMA_REG_MISC_CTRL1, 0x0001);
-
-	/* Reset internal microprocessor */
-	bnx2x_cl45_write(bp, port,
-		       ext_phy_type,
-		       ext_phy_addr,
-		       MDIO_PMA_DEVAD,
-		       MDIO_PMA_REG_GEN_CTRL,
-		       MDIO_PMA_REG_GEN_CTRL_ROM_MICRO_RESET);
-
-	/* Release srst bit */
-	bnx2x_cl45_write(bp, port,
-		       ext_phy_type,
-		       ext_phy_addr,
-		       MDIO_PMA_DEVAD,
-		       MDIO_PMA_REG_GEN_CTRL,
-		       MDIO_PMA_REG_GEN_CTRL_ROM_RESET_INTERNAL_MP);
-
-	/* wait for 100ms for code download via SPI port */
-	msleep(100);
-
-	/* Clear ser_boot_ctl bit */
-	bnx2x_cl45_write(bp, port,
-		       ext_phy_type,
-		       ext_phy_addr,
-		       MDIO_PMA_DEVAD,
-		       MDIO_PMA_REG_MISC_CTRL1, 0x0000);
-
-	bnx2x_save_bcm_spirom_ver(bp, port,
-				ext_phy_type,
-				ext_phy_addr,
-				shmem_base);
-}
-
-static void bnx2x_bcm8073_external_rom_boot(struct bnx2x *bp, u8 port,
-					  u8 ext_phy_addr,
-					  u32 shmem_base)
-{
-	bnx2x_bcm8073_bcm8727_external_rom_boot(bp, port, ext_phy_addr,
-					 PORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM8073,
-					 shmem_base);
-}
-
-static void bnx2x_bcm8727_external_rom_boot(struct bnx2x *bp, u8 port,
-					  u8 ext_phy_addr,
-					  u32 shmem_base)
-{
-	bnx2x_bcm8073_bcm8727_external_rom_boot(bp, port, ext_phy_addr,
-					 PORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM8727,
-					 shmem_base);
-
-}
-
-static void bnx2x_bcm8726_external_rom_boot(struct link_params *params)
-{
-	struct bnx2x *bp = params->bp;
-	u8 port = params->port;
-	u8 ext_phy_addr = XGXS_EXT_PHY_ADDR(params->ext_phy_config);
-	u32 ext_phy_type = XGXS_EXT_PHY_TYPE(params->ext_phy_config);
-
-	/* Need to wait 100ms after reset */
-	msleep(100);
-
-	/* Micro controller re-boot */
-	bnx2x_cl45_write(bp, port, ext_phy_type, ext_phy_addr,
-		       MDIO_PMA_DEVAD,
-		       MDIO_PMA_REG_GEN_CTRL,
-		       0x018B);
-
-	/* Set soft reset */
-	bnx2x_cl45_write(bp, port, ext_phy_type, ext_phy_addr,
-		       MDIO_PMA_DEVAD,
-		       MDIO_PMA_REG_GEN_CTRL,
-		       MDIO_PMA_REG_GEN_CTRL_ROM_MICRO_RESET);
-
-	bnx2x_cl45_write(bp, port, ext_phy_type, ext_phy_addr,
-		       MDIO_PMA_DEVAD,
-		       MDIO_PMA_REG_MISC_CTRL1, 0x0001);
-
-	bnx2x_cl45_write(bp, port, ext_phy_type, ext_phy_addr,
-		       MDIO_PMA_DEVAD,
-		       MDIO_PMA_REG_GEN_CTRL,
-		       MDIO_PMA_REG_GEN_CTRL_ROM_RESET_INTERNAL_MP);
-
-	/* wait for 150ms for microcode load */
-	msleep(150);
-
-	/* Disable serial boot control, tristates pins SS_N, SCK, MOSI, MISO */
-	bnx2x_cl45_write(bp, port, ext_phy_type, ext_phy_addr,
-		       MDIO_PMA_DEVAD,
-		       MDIO_PMA_REG_MISC_CTRL1, 0x0000);
-
-	msleep(200);
-	bnx2x_save_bcm_spirom_ver(bp, port,
-				ext_phy_type,
-				ext_phy_addr,
-				params->shmem_base);
-}
-
-static void bnx2x_sfp_set_transmitter(struct bnx2x *bp, u8 port,
-				    u32 ext_phy_type, u8 ext_phy_addr,
-				    u8 tx_en)
-{
-	u16 val;
-
-	DP(NETIF_MSG_LINK, "Setting transmitter tx_en=%x for port %x\n",
-		 tx_en, port);
-	/* Disable/Enable transmitter ( TX laser of the SFP+ module.)*/
-	bnx2x_cl45_read(bp, port,
-		      ext_phy_type,
-		      ext_phy_addr,
-		      MDIO_PMA_DEVAD,
-		      MDIO_PMA_REG_PHY_IDENTIFIER,
-		      &val);
-
-	if (tx_en)
-		val &= ~(1<<15);
-	else
-		val |= (1<<15);
-
-	bnx2x_cl45_write(bp, port,
-		       ext_phy_type,
-		       ext_phy_addr,
-		       MDIO_PMA_DEVAD,
-		       MDIO_PMA_REG_PHY_IDENTIFIER,
-		       val);
-}
-
-static u8 bnx2x_8726_read_sfp_module_eeprom(struct link_params *params,
-					  u16 addr, u8 byte_cnt, u8 *o_buf)
-{
-	struct bnx2x *bp = params->bp;
-	u16 val = 0;
-	u16 i;
-	u8 port = params->port;
-	u8 ext_phy_addr = XGXS_EXT_PHY_ADDR(params->ext_phy_config);
-	u32 ext_phy_type = XGXS_EXT_PHY_TYPE(params->ext_phy_config);
-
-	if (byte_cnt > 16) {
-		DP(NETIF_MSG_LINK, "Reading from eeprom is"
-			    " is limited to 0xf\n");
-		return -EINVAL;
-	}
-	/* Set the read command byte count */
-	bnx2x_cl45_write(bp, port,
-		       ext_phy_type,
-		       ext_phy_addr,
-		       MDIO_PMA_DEVAD,
-		       MDIO_PMA_REG_SFP_TWO_WIRE_BYTE_CNT,
-		       (byte_cnt | 0xa000));
-
-	/* Set the read command address */
-	bnx2x_cl45_write(bp, port,
-		       ext_phy_type,
-		       ext_phy_addr,
-		       MDIO_PMA_DEVAD,
-		       MDIO_PMA_REG_SFP_TWO_WIRE_MEM_ADDR,
-		       addr);
-
-	/* Activate read command */
-	bnx2x_cl45_write(bp, port,
-		       ext_phy_type,
-		       ext_phy_addr,
-		       MDIO_PMA_DEVAD,
-		       MDIO_PMA_REG_SFP_TWO_WIRE_CTRL,
-		       0x2c0f);
-
-	/* Wait up to 500us for command complete status */
-	for (i = 0; i < 100; i++) {
-		bnx2x_cl45_read(bp, port,
-			      ext_phy_type,
-			      ext_phy_addr,
-			      MDIO_PMA_DEVAD,
-			      MDIO_PMA_REG_SFP_TWO_WIRE_CTRL, &val);
-		if ((val & MDIO_PMA_REG_SFP_TWO_WIRE_CTRL_STATUS_MASK) ==
-		    MDIO_PMA_REG_SFP_TWO_WIRE_STATUS_COMPLETE)
-			break;
-		udelay(5);
-	}
-
-	if ((val & MDIO_PMA_REG_SFP_TWO_WIRE_CTRL_STATUS_MASK) !=
-		    MDIO_PMA_REG_SFP_TWO_WIRE_STATUS_COMPLETE) {
-		DP(NETIF_MSG_LINK,
-			 "Got bad status 0x%x when reading from SFP+ EEPROM\n",
-			 (val & MDIO_PMA_REG_SFP_TWO_WIRE_CTRL_STATUS_MASK));
-		return -EINVAL;
-	}
-
-	/* Read the buffer */
-	for (i = 0; i < byte_cnt; i++) {
-		bnx2x_cl45_read(bp, port,
-			      ext_phy_type,
-			      ext_phy_addr,
-			      MDIO_PMA_DEVAD,
-			      MDIO_PMA_REG_8726_TWO_WIRE_DATA_BUF + i, &val);
-		o_buf[i] = (u8)(val & MDIO_PMA_REG_8726_TWO_WIRE_DATA_MASK);
-	}
-
-	for (i = 0; i < 100; i++) {
-		bnx2x_cl45_read(bp, port,
-			      ext_phy_type,
-			      ext_phy_addr,
-			      MDIO_PMA_DEVAD,
-			      MDIO_PMA_REG_SFP_TWO_WIRE_CTRL, &val);
-		if ((val & MDIO_PMA_REG_SFP_TWO_WIRE_CTRL_STATUS_MASK) ==
-		    MDIO_PMA_REG_SFP_TWO_WIRE_STATUS_IDLE)
-			return 0;;
-		msleep(1);
-	}
-	return -EINVAL;
-}
-
-static u8 bnx2x_8727_read_sfp_module_eeprom(struct link_params *params,
-					  u16 addr, u8 byte_cnt, u8 *o_buf)
-{
-	struct bnx2x *bp = params->bp;
-	u16 val, i;
-	u8 port = params->port;
-	u8 ext_phy_addr = XGXS_EXT_PHY_ADDR(params->ext_phy_config);
-	u32 ext_phy_type = XGXS_EXT_PHY_TYPE(params->ext_phy_config);
-
-	if (byte_cnt > 16) {
-		DP(NETIF_MSG_LINK, "Reading from eeprom is"
-			    " is limited to 0xf\n");
-		return -EINVAL;
-	}
-
-	/* Need to read from 1.8000 to clear it */
-	bnx2x_cl45_read(bp, port,
-		      PORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM8727,
-		      ext_phy_addr,
-		      MDIO_PMA_DEVAD,
-		      MDIO_PMA_REG_SFP_TWO_WIRE_CTRL,
-		      &val);
-
-	/* Set the read command byte count */
-	bnx2x_cl45_write(bp, port,
-		       ext_phy_type,
-		       ext_phy_addr,
-		       MDIO_PMA_DEVAD,
-		       MDIO_PMA_REG_SFP_TWO_WIRE_BYTE_CNT,
-		       ((byte_cnt < 2) ? 2 : byte_cnt));
-
-	/* Set the read command address */
-	bnx2x_cl45_write(bp, port,
-		       ext_phy_type,
-		       ext_phy_addr,
-		       MDIO_PMA_DEVAD,
-		       MDIO_PMA_REG_SFP_TWO_WIRE_MEM_ADDR,
-		       addr);
-	/* Set the destination address */
-	bnx2x_cl45_write(bp, port,
-		       ext_phy_type,
-		       ext_phy_addr,
-		       MDIO_PMA_DEVAD,
-		       0x8004,
-		       MDIO_PMA_REG_8727_TWO_WIRE_DATA_BUF);
-
-	/* Activate read command */
-	bnx2x_cl45_write(bp, port,
-		       ext_phy_type,
-		       ext_phy_addr,
-		       MDIO_PMA_DEVAD,
-		       MDIO_PMA_REG_SFP_TWO_WIRE_CTRL,
-		       0x8002);
-	/* Wait appropriate time for two-wire command to finish before
-	polling the status register */
-	msleep(1);
-
-	/* Wait up to 500us for command complete status */
-	for (i = 0; i < 100; i++) {
-		bnx2x_cl45_read(bp, port,
-			      ext_phy_type,
-			      ext_phy_addr,
-			      MDIO_PMA_DEVAD,
-			      MDIO_PMA_REG_SFP_TWO_WIRE_CTRL, &val);
-		if ((val & MDIO_PMA_REG_SFP_TWO_WIRE_CTRL_STATUS_MASK) ==
-		    MDIO_PMA_REG_SFP_TWO_WIRE_STATUS_COMPLETE)
-			break;
-		udelay(5);
-	}
-
-	if ((val & MDIO_PMA_REG_SFP_TWO_WIRE_CTRL_STATUS_MASK) !=
-		    MDIO_PMA_REG_SFP_TWO_WIRE_STATUS_COMPLETE) {
-		DP(NETIF_MSG_LINK,
-			 "Got bad status 0x%x when reading from SFP+ EEPROM\n",
-			 (val & MDIO_PMA_REG_SFP_TWO_WIRE_CTRL_STATUS_MASK));
-		return -EINVAL;
-	}
-
-	/* Read the buffer */
-	for (i = 0; i < byte_cnt; i++) {
-		bnx2x_cl45_read(bp, port,
-			      ext_phy_type,
-			      ext_phy_addr,
-			      MDIO_PMA_DEVAD,
-			      MDIO_PMA_REG_8727_TWO_WIRE_DATA_BUF + i, &val);
-		o_buf[i] = (u8)(val & MDIO_PMA_REG_8727_TWO_WIRE_DATA_MASK);
-	}
-
-	for (i = 0; i < 100; i++) {
-		bnx2x_cl45_read(bp, port,
-			      ext_phy_type,
-			      ext_phy_addr,
-			      MDIO_PMA_DEVAD,
-			      MDIO_PMA_REG_SFP_TWO_WIRE_CTRL, &val);
-		if ((val & MDIO_PMA_REG_SFP_TWO_WIRE_CTRL_STATUS_MASK) ==
-		    MDIO_PMA_REG_SFP_TWO_WIRE_STATUS_IDLE)
-			return 0;;
-		msleep(1);
-	}
-
-	return -EINVAL;
-}
-
-u8 bnx2x_read_sfp_module_eeprom(struct link_params *params, u16 addr,
-				     u8 byte_cnt, u8 *o_buf)
-{
-	u32 ext_phy_type = XGXS_EXT_PHY_TYPE(params->ext_phy_config);
-
-	if (ext_phy_type == PORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM8726)
-		return bnx2x_8726_read_sfp_module_eeprom(params, addr,
-						       byte_cnt, o_buf);
-	else if (ext_phy_type == PORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM8727)
-		return bnx2x_8727_read_sfp_module_eeprom(params, addr,
-						       byte_cnt, o_buf);
-	return -EINVAL;
-}
-
-static u8 bnx2x_get_edc_mode(struct link_params *params,
-				  u16 *edc_mode)
-{
-	struct bnx2x *bp = params->bp;
-	u8 val, check_limiting_mode = 0;
-	*edc_mode = EDC_MODE_LIMITING;
-
-	/* First check for copper cable */
-	if (bnx2x_read_sfp_module_eeprom(params,
-				       SFP_EEPROM_CON_TYPE_ADDR,
-				       1,
-				       &val) != 0) {
-		DP(NETIF_MSG_LINK, "Failed to read from SFP+ module EEPROM\n");
-		return -EINVAL;
-	}
-
-	switch (val) {
-	case SFP_EEPROM_CON_TYPE_VAL_COPPER:
-	{
-		u8 copper_module_type;
-
-		/* Check if its active cable( includes SFP+ module)
-		of passive cable*/
-		if (bnx2x_read_sfp_module_eeprom(params,
-					       SFP_EEPROM_FC_TX_TECH_ADDR,
-					       1,
-					       &copper_module_type) !=
-		    0) {
-			DP(NETIF_MSG_LINK,
-				"Failed to read copper-cable-type"
-				" from SFP+ EEPROM\n");
-			return -EINVAL;
-		}
-
-		if (copper_module_type &
-		    SFP_EEPROM_FC_TX_TECH_BITMASK_COPPER_ACTIVE) {
-			DP(NETIF_MSG_LINK, "Active Copper cable detected\n");
-			check_limiting_mode = 1;
-		} else if (copper_module_type &
-			SFP_EEPROM_FC_TX_TECH_BITMASK_COPPER_PASSIVE) {
-				DP(NETIF_MSG_LINK, "Passive Copper"
-					    " cable detected\n");
-				*edc_mode =
-				      EDC_MODE_PASSIVE_DAC;
-		} else {
-			DP(NETIF_MSG_LINK, "Unknown copper-cable-"
-				     "type 0x%x !!!\n", copper_module_type);
-			return -EINVAL;
-		}
-		break;
-	}
-	case SFP_EEPROM_CON_TYPE_VAL_LC:
-		DP(NETIF_MSG_LINK, "Optic module detected\n");
-		check_limiting_mode = 1;
-		break;
-	default:
-		DP(NETIF_MSG_LINK, "Unable to determine module type 0x%x !!!\n",
-			 val);
-		return -EINVAL;
-	}
-
-	if (check_limiting_mode) {
-		u8 options[SFP_EEPROM_OPTIONS_SIZE];
-		if (bnx2x_read_sfp_module_eeprom(params,
-					       SFP_EEPROM_OPTIONS_ADDR,
-					       SFP_EEPROM_OPTIONS_SIZE,
-					       options) != 0) {
-			DP(NETIF_MSG_LINK, "Failed to read Option"
-				" field from module EEPROM\n");
-			return -EINVAL;
-		}
-		if ((options[0] & SFP_EEPROM_OPTIONS_LINEAR_RX_OUT_MASK))
-			*edc_mode = EDC_MODE_LINEAR;
-		else
-			*edc_mode = EDC_MODE_LIMITING;
-	}
-	DP(NETIF_MSG_LINK, "EDC mode is set to 0x%x\n", *edc_mode);
-	return 0;
-}
-
-/* This function read the relevant field from the module ( SFP+ ),
-	and verify it is compliant with this board */
-static u8 bnx2x_verify_sfp_module(struct link_params *params)
-{
-	struct bnx2x *bp = params->bp;
-	u32 val;
-	u32 fw_resp;
-	char vendor_name[SFP_EEPROM_VENDOR_NAME_SIZE+1];
-	char vendor_pn[SFP_EEPROM_PART_NO_SIZE+1];
-
-	val = REG_RD(bp, params->shmem_base +
-			 offsetof(struct shmem_region, dev_info.
-				  port_feature_config[params->port].config));
-	if ((val & PORT_FEAT_CFG_OPT_MDL_ENFRCMNT_MASK) ==
-	    PORT_FEAT_CFG_OPT_MDL_ENFRCMNT_NO_ENFORCEMENT) {
-		DP(NETIF_MSG_LINK, "NOT enforcing module verification\n");
-		return 0;
-	}
-
-	/* Ask the FW to validate the module */
-	if (!(params->feature_config_flags &
-	      FEATURE_CONFIG_BC_SUPPORTS_OPT_MDL_VRFY)) {
-		DP(NETIF_MSG_LINK, "FW does not support OPT MDL "
-			    "verification\n");
-		return -EINVAL;
-	}
-
-	fw_resp = bnx2x_fw_command(bp, DRV_MSG_CODE_VRFY_OPT_MDL);
-	if (fw_resp == FW_MSG_CODE_VRFY_OPT_MDL_SUCCESS) {
-		DP(NETIF_MSG_LINK, "Approved module\n");
-		return 0;
-	}
-
-	/* format the warning message */
-	if (bnx2x_read_sfp_module_eeprom(params,
-				       SFP_EEPROM_VENDOR_NAME_ADDR,
-				       SFP_EEPROM_VENDOR_NAME_SIZE,
-				       (u8 *)vendor_name))
-		vendor_name[0] = '\0';
-	else
-		vendor_name[SFP_EEPROM_VENDOR_NAME_SIZE] = '\0';
-	if (bnx2x_read_sfp_module_eeprom(params,
-				       SFP_EEPROM_PART_NO_ADDR,
-				       SFP_EEPROM_PART_NO_SIZE,
-				       (u8 *)vendor_pn))
-		vendor_pn[0] = '\0';
-	else
-		vendor_pn[SFP_EEPROM_PART_NO_SIZE] = '\0';
-
-	netdev_info(bp->dev, "Warning: Unqualified SFP+ module detected, Port %d from %s part number %s\n",
-		    params->port, vendor_name, vendor_pn);
-	return -EINVAL;
-}
-
-static u8 bnx2x_bcm8726_set_limiting_mode(struct link_params *params,
-					u16 edc_mode)
-{
-	struct bnx2x *bp = params->bp;
-	u8 port = params->port;
-	u8 ext_phy_addr = XGXS_EXT_PHY_ADDR(params->ext_phy_config);
-	u16 cur_limiting_mode;
-
-	bnx2x_cl45_read(bp, port,
-		      PORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM8726,
-		      ext_phy_addr,
-		      MDIO_PMA_DEVAD,
-		      MDIO_PMA_REG_ROM_VER2,
-		      &cur_limiting_mode);
-	DP(NETIF_MSG_LINK, "Current Limiting mode is 0x%x\n",
-		 cur_limiting_mode);
-
-	if (edc_mode == EDC_MODE_LIMITING) {
-		DP(NETIF_MSG_LINK,
-			 "Setting LIMITING MODE\n");
-		bnx2x_cl45_write(bp, port,
-			       PORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM8726,
-			       ext_phy_addr,
-			       MDIO_PMA_DEVAD,
-			       MDIO_PMA_REG_ROM_VER2,
-			       EDC_MODE_LIMITING);
-	} else { /* LRM mode ( default )*/
-
-		DP(NETIF_MSG_LINK, "Setting LRM MODE\n");
-
-		/* Changing to LRM mode takes quite few seconds.
-		So do it only if current mode is limiting
-		( default is LRM )*/
-		if (cur_limiting_mode != EDC_MODE_LIMITING)
-			return 0;
-
-		bnx2x_cl45_write(bp, port,
-			       PORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM8726,
-			       ext_phy_addr,
-			       MDIO_PMA_DEVAD,
-			       MDIO_PMA_REG_LRM_MODE,
-			       0);
-		bnx2x_cl45_write(bp, port,
-			       PORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM8726,
-			       ext_phy_addr,
-			       MDIO_PMA_DEVAD,
-			       MDIO_PMA_REG_ROM_VER2,
-			       0x128);
-		bnx2x_cl45_write(bp, port,
-			       PORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM8726,
-			       ext_phy_addr,
-			       MDIO_PMA_DEVAD,
-			       MDIO_PMA_REG_MISC_CTRL0,
-			       0x4008);
-		bnx2x_cl45_write(bp, port,
-			       PORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM8726,
-			       ext_phy_addr,
-			       MDIO_PMA_DEVAD,
-			       MDIO_PMA_REG_LRM_MODE,
-			       0xaaaa);
-	}
-	return 0;
-}
-
-static u8 bnx2x_bcm8727_set_limiting_mode(struct link_params *params,
-					u16 edc_mode)
-{
-	struct bnx2x *bp = params->bp;
-	u8 port = params->port;
-	u16 phy_identifier;
-	u16 rom_ver2_val;
-	u8 ext_phy_addr = XGXS_EXT_PHY_ADDR(params->ext_phy_config);
-
-	bnx2x_cl45_read(bp, port,
-		       PORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM8727,
-		       ext_phy_addr,
-		       MDIO_PMA_DEVAD,
-		       MDIO_PMA_REG_PHY_IDENTIFIER,
-		       &phy_identifier);
-
-	bnx2x_cl45_write(bp, port,
-		       PORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM8727,
-		       ext_phy_addr,
-		       MDIO_PMA_DEVAD,
-		       MDIO_PMA_REG_PHY_IDENTIFIER,
-		       (phy_identifier & ~(1<<9)));
-
-	bnx2x_cl45_read(bp, port,
-		      PORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM8727,
-		      ext_phy_addr,
-		      MDIO_PMA_DEVAD,
-		      MDIO_PMA_REG_ROM_VER2,
-		      &rom_ver2_val);
-	/* Keep the MSB 8-bits, and set the LSB 8-bits with the edc_mode */
-	bnx2x_cl45_write(bp, port,
-		       PORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM8727,
-		       ext_phy_addr,
-		       MDIO_PMA_DEVAD,
-		       MDIO_PMA_REG_ROM_VER2,
-		       (rom_ver2_val & 0xff00) | (edc_mode & 0x00ff));
-
-	bnx2x_cl45_write(bp, port,
-		       PORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM8727,
-		       ext_phy_addr,
-		       MDIO_PMA_DEVAD,
-		       MDIO_PMA_REG_PHY_IDENTIFIER,
-		       (phy_identifier | (1<<9)));
-
-	return 0;
-}
-
-
-static u8 bnx2x_wait_for_sfp_module_initialized(struct link_params *params)
-{
-	u8 val;
-	struct bnx2x *bp = params->bp;
-	u16 timeout;
-	/* Initialization time after hot-plug may take up to 300ms for some
-	phys type ( e.g. JDSU ) */
-	for (timeout = 0; timeout < 60; timeout++) {
-		if (bnx2x_read_sfp_module_eeprom(params, 1, 1, &val)
-		    == 0) {
-			DP(NETIF_MSG_LINK, "SFP+ module initialization "
-				     "took %d ms\n", timeout * 5);
-			return 0;
-		}
-		msleep(5);
-	}
-	return -EINVAL;
-}
-
-static void bnx2x_8727_power_module(struct bnx2x *bp,
-				  struct link_params *params,
-				  u8 ext_phy_addr, u8 is_power_up) {
-	/* Make sure GPIOs are not using for LED mode */
-	u16 val;
-	u8 port = params->port;
-	/*
-	 * In the GPIO register, bit 4 is use to detemine if the GPIOs are
-	 * operating as INPUT or as OUTPUT. Bit 1 is for input, and 0 for
-	 * output
-	 * Bits 0-1 determine the gpios value for OUTPUT in case bit 4 val is 0
-	 * Bits 8-9 determine the gpios value for INPUT in case bit 4 val is 1
-	 * where the 1st bit is the over-current(only input), and 2nd bit is
-	 * for power( only output )
-	*/
-
-	/*
-	 * In case of NOC feature is disabled and power is up, set GPIO control
-	 *  as input to enable listening of over-current indication
-	 */
-
-	if (!(params->feature_config_flags &
-	      FEATURE_CONFIG_BCM8727_NOC) && is_power_up)
-		val = (1<<4);
-	else
-		/*
-		 * Set GPIO control to OUTPUT, and set the power bit
-		 * to according to the is_power_up
-		 */
-		val = ((!(is_power_up)) << 1);
-
-	bnx2x_cl45_write(bp, port,
-		       PORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM8727,
-		       ext_phy_addr,
-		       MDIO_PMA_DEVAD,
-		       MDIO_PMA_REG_8727_GPIO_CTRL,
-		       val);
-}
-
-static u8 bnx2x_sfp_module_detection(struct link_params *params)
-{
-	struct bnx2x *bp = params->bp;
-	u16 edc_mode;
-	u8 rc = 0;
-	u8 ext_phy_addr = XGXS_EXT_PHY_ADDR(params->ext_phy_config);
-	u32 ext_phy_type = XGXS_EXT_PHY_TYPE(params->ext_phy_config);
-	u32 val = REG_RD(bp, params->shmem_base +
-			     offsetof(struct shmem_region, dev_info.
-				     port_feature_config[params->port].config));
-
-	DP(NETIF_MSG_LINK, "SFP+ module plugged in/out detected on port %d\n",
-		 params->port);
-
-	if (bnx2x_get_edc_mode(params, &edc_mode) != 0) {
-		DP(NETIF_MSG_LINK, "Failed to get valid module type\n");
-		return -EINVAL;
-	} else if (bnx2x_verify_sfp_module(params) !=
-		   0) {
-		/* check SFP+ module compatibility */
-		DP(NETIF_MSG_LINK, "Module verification failed!!\n");
-		rc = -EINVAL;
-		/* Turn on fault module-detected led */
-		bnx2x_set_gpio(bp, MISC_REGISTERS_GPIO_0,
-				  MISC_REGISTERS_GPIO_HIGH,
-				  params->port);
-		if ((ext_phy_type == PORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM8727) &&
-		    ((val & PORT_FEAT_CFG_OPT_MDL_ENFRCMNT_MASK) ==
-		     PORT_FEAT_CFG_OPT_MDL_ENFRCMNT_POWER_DOWN)) {
-			/* Shutdown SFP+ module */
-			DP(NETIF_MSG_LINK, "Shutdown SFP+ module!!\n");
-			bnx2x_8727_power_module(bp, params,
-					      ext_phy_addr, 0);
-			return rc;
-		}
-	} else {
-		/* Turn off fault module-detected led */
-		DP(NETIF_MSG_LINK, "Turn off fault module-detected led\n");
-		bnx2x_set_gpio(bp, MISC_REGISTERS_GPIO_0,
-					  MISC_REGISTERS_GPIO_LOW,
-					  params->port);
-	}
-
-	/* power up the SFP module */
-	if (ext_phy_type == PORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM8727)
-		bnx2x_8727_power_module(bp, params, ext_phy_addr, 1);
-
-	/* Check and set limiting mode / LRM mode on 8726.
-	On 8727 it is done automatically */
-	if (ext_phy_type == PORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM8726)
-		bnx2x_bcm8726_set_limiting_mode(params, edc_mode);
-	else
-		bnx2x_bcm8727_set_limiting_mode(params, edc_mode);
-	/*
-	 * Enable transmit for this module if the module is approved, or
-	 * if unapproved modules should also enable the Tx laser
-	 */
-	if (rc == 0 ||
-	    (val & PORT_FEAT_CFG_OPT_MDL_ENFRCMNT_MASK) !=
-	    PORT_FEAT_CFG_OPT_MDL_ENFRCMNT_DISABLE_TX_LASER)
-		bnx2x_sfp_set_transmitter(bp, params->port,
-					ext_phy_type, ext_phy_addr, 1);
-	else
-		bnx2x_sfp_set_transmitter(bp, params->port,
-					ext_phy_type, ext_phy_addr, 0);
-
-	return rc;
-}
-
-void bnx2x_handle_module_detect_int(struct link_params *params)
-{
-	struct bnx2x *bp = params->bp;
-	u32 gpio_val;
-	u8 port = params->port;
-
-	/* Set valid module led off */
-	bnx2x_set_gpio(bp, MISC_REGISTERS_GPIO_0,
-			  MISC_REGISTERS_GPIO_HIGH,
-			  params->port);
-
-	/* Get current gpio val refelecting module plugged in / out*/
-	gpio_val = bnx2x_get_gpio(bp,  MISC_REGISTERS_GPIO_3, port);
-
-	/* Call the handling function in case module is detected */
-	if (gpio_val == 0) {
-
-		bnx2x_set_gpio_int(bp, MISC_REGISTERS_GPIO_3,
-				      MISC_REGISTERS_GPIO_INT_OUTPUT_CLR,
-				      port);
-
-		if (bnx2x_wait_for_sfp_module_initialized(params) ==
-		    0)
-			bnx2x_sfp_module_detection(params);
-		else
-			DP(NETIF_MSG_LINK, "SFP+ module is not initialized\n");
-	} else {
-		u8 ext_phy_addr = XGXS_EXT_PHY_ADDR(params->ext_phy_config);
-
-		u32 ext_phy_type =
-			XGXS_EXT_PHY_TYPE(params->ext_phy_config);
-		u32 val = REG_RD(bp, params->shmem_base +
-				     offsetof(struct shmem_region, dev_info.
-					      port_feature_config[params->port].
-					      config));
-
-		bnx2x_set_gpio_int(bp, MISC_REGISTERS_GPIO_3,
-				      MISC_REGISTERS_GPIO_INT_OUTPUT_SET,
-				      port);
-		/* Module was plugged out. */
-		/* Disable transmit for this module */
-		if ((val & PORT_FEAT_CFG_OPT_MDL_ENFRCMNT_MASK) ==
-		    PORT_FEAT_CFG_OPT_MDL_ENFRCMNT_DISABLE_TX_LASER)
-			bnx2x_sfp_set_transmitter(bp, params->port,
-						ext_phy_type, ext_phy_addr, 0);
-	}
-}
-
-static void bnx2x_bcm807x_force_10G(struct link_params *params)
-{
-	struct bnx2x *bp = params->bp;
-	u8 port = params->port;
-	u8 ext_phy_addr = XGXS_EXT_PHY_ADDR(params->ext_phy_config);
-	u32 ext_phy_type = XGXS_EXT_PHY_TYPE(params->ext_phy_config);
-
-	/* Force KR or KX */
-	bnx2x_cl45_write(bp, port, ext_phy_type, ext_phy_addr,
-		       MDIO_PMA_DEVAD,
-		       MDIO_PMA_REG_CTRL,
-		       0x2040);
-	bnx2x_cl45_write(bp, port, ext_phy_type, ext_phy_addr,
-		       MDIO_PMA_DEVAD,
-		       MDIO_PMA_REG_10G_CTRL2,
-		       0x000b);
-	bnx2x_cl45_write(bp, port, ext_phy_type, ext_phy_addr,
-		       MDIO_PMA_DEVAD,
-		       MDIO_PMA_REG_BCM_CTRL,
-		       0x0000);
-	bnx2x_cl45_write(bp, port, ext_phy_type, ext_phy_addr,
-		       MDIO_AN_DEVAD,
-		       MDIO_AN_REG_CTRL,
-		       0x0000);
-}
-
-static void bnx2x_bcm8073_set_xaui_low_power_mode(struct link_params *params)
-{
-	struct bnx2x *bp = params->bp;
-	u8 port = params->port;
-	u16 val;
-	u8 ext_phy_addr = XGXS_EXT_PHY_ADDR(params->ext_phy_config);
-	u32 ext_phy_type = XGXS_EXT_PHY_TYPE(params->ext_phy_config);
-
-	bnx2x_cl45_read(bp, params->port,
-		      PORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM8073,
-		      ext_phy_addr,
-		      MDIO_PMA_DEVAD,
-		      MDIO_PMA_REG_8073_CHIP_REV, &val);
-
-	if (val == 0) {
-		/* Mustn't set low power mode in 8073 A0 */
-		return;
-	}
-
-	/* Disable PLL sequencer (use read-modify-write to clear bit 13) */
-	bnx2x_cl45_read(bp, port, ext_phy_type, ext_phy_addr,
-		       MDIO_XS_DEVAD,
-		       MDIO_XS_PLL_SEQUENCER, &val);
-	val &= ~(1<<13);
-	bnx2x_cl45_write(bp, port, ext_phy_type, ext_phy_addr,
-		       MDIO_XS_DEVAD, MDIO_XS_PLL_SEQUENCER, val);
-
-	/* PLL controls */
-	bnx2x_cl45_write(bp, port, ext_phy_type, ext_phy_addr,
-		       MDIO_XS_DEVAD, 0x805E, 0x1077);
-	bnx2x_cl45_write(bp, port, ext_phy_type, ext_phy_addr,
-		       MDIO_XS_DEVAD, 0x805D, 0x0000);
-	bnx2x_cl45_write(bp, port, ext_phy_type, ext_phy_addr,
-		       MDIO_XS_DEVAD, 0x805C, 0x030B);
-	bnx2x_cl45_write(bp, port, ext_phy_type, ext_phy_addr,
-		       MDIO_XS_DEVAD, 0x805B, 0x1240);
-	bnx2x_cl45_write(bp, port, ext_phy_type, ext_phy_addr,
-		       MDIO_XS_DEVAD, 0x805A, 0x2490);
-
-	/* Tx Controls */
-	bnx2x_cl45_write(bp, port, ext_phy_type, ext_phy_addr,
-		       MDIO_XS_DEVAD, 0x80A7, 0x0C74);
-	bnx2x_cl45_write(bp, port, ext_phy_type, ext_phy_addr,
-		       MDIO_XS_DEVAD, 0x80A6, 0x9041);
-	bnx2x_cl45_write(bp, port, ext_phy_type, ext_phy_addr,
-		       MDIO_XS_DEVAD, 0x80A5, 0x4640);
-
-	/* Rx Controls */
-	bnx2x_cl45_write(bp, port, ext_phy_type, ext_phy_addr,
-		       MDIO_XS_DEVAD, 0x80FE, 0x01C4);
-	bnx2x_cl45_write(bp, port, ext_phy_type, ext_phy_addr,
-		       MDIO_XS_DEVAD, 0x80FD, 0x9249);
-	bnx2x_cl45_write(bp, port, ext_phy_type, ext_phy_addr,
-		       MDIO_XS_DEVAD, 0x80FC, 0x2015);
-
-	/* Enable PLL sequencer  (use read-modify-write to set bit 13) */
-	bnx2x_cl45_read(bp, port, ext_phy_type, ext_phy_addr,
-		       MDIO_XS_DEVAD,
-		       MDIO_XS_PLL_SEQUENCER, &val);
-	val |= (1<<13);
-	bnx2x_cl45_write(bp, port, ext_phy_type, ext_phy_addr,
-		       MDIO_XS_DEVAD, MDIO_XS_PLL_SEQUENCER, val);
-}
-
-static void bnx2x_8073_set_pause_cl37(struct link_params *params,
-				  struct link_vars *vars)
-{
-	struct bnx2x *bp = params->bp;
-	u16 cl37_val;
-	u8 ext_phy_addr = XGXS_EXT_PHY_ADDR(params->ext_phy_config);
-	u32 ext_phy_type = XGXS_EXT_PHY_TYPE(params->ext_phy_config);
-
-	bnx2x_cl45_read(bp, params->port,
-		      ext_phy_type,
-		      ext_phy_addr,
-		      MDIO_AN_DEVAD,
-		      MDIO_AN_REG_CL37_FC_LD, &cl37_val);
-
-	cl37_val &= ~MDIO_COMBO_IEEE0_AUTO_NEG_ADV_PAUSE_BOTH;
-	/* Please refer to Table 28B-3 of 802.3ab-1999 spec. */
-
-	if ((vars->ieee_fc &
-	    MDIO_COMBO_IEEE0_AUTO_NEG_ADV_PAUSE_SYMMETRIC) ==
-	    MDIO_COMBO_IEEE0_AUTO_NEG_ADV_PAUSE_SYMMETRIC) {
-		cl37_val |=  MDIO_COMBO_IEEE0_AUTO_NEG_ADV_PAUSE_SYMMETRIC;
-	}
-	if ((vars->ieee_fc &
-	    MDIO_COMBO_IEEE0_AUTO_NEG_ADV_PAUSE_ASYMMETRIC) ==
-	    MDIO_COMBO_IEEE0_AUTO_NEG_ADV_PAUSE_ASYMMETRIC) {
-		cl37_val |=  MDIO_COMBO_IEEE0_AUTO_NEG_ADV_PAUSE_ASYMMETRIC;
-	}
-	if ((vars->ieee_fc &
-	    MDIO_COMBO_IEEE0_AUTO_NEG_ADV_PAUSE_BOTH) ==
-	    MDIO_COMBO_IEEE0_AUTO_NEG_ADV_PAUSE_BOTH) {
-		cl37_val |= MDIO_COMBO_IEEE0_AUTO_NEG_ADV_PAUSE_BOTH;
-	}
-	DP(NETIF_MSG_LINK,
-		 "Ext phy AN advertize cl37 0x%x\n", cl37_val);
-
-	bnx2x_cl45_write(bp, params->port,
-		       ext_phy_type,
-		       ext_phy_addr,
-		       MDIO_AN_DEVAD,
-		       MDIO_AN_REG_CL37_FC_LD, cl37_val);
-	msleep(500);
-}
-
-static void bnx2x_ext_phy_set_pause(struct link_params *params,
-				  struct link_vars *vars)
-{
-	struct bnx2x *bp = params->bp;
-	u16 val;
-	u8 ext_phy_addr = XGXS_EXT_PHY_ADDR(params->ext_phy_config);
-	u32 ext_phy_type = XGXS_EXT_PHY_TYPE(params->ext_phy_config);
-
-	/* read modify write pause advertizing */
-	bnx2x_cl45_read(bp, params->port,
-		      ext_phy_type,
-		      ext_phy_addr,
-		      MDIO_AN_DEVAD,
-		      MDIO_AN_REG_ADV_PAUSE, &val);
-
-	val &= ~MDIO_AN_REG_ADV_PAUSE_BOTH;
-
-	/* Please refer to Table 28B-3 of 802.3ab-1999 spec. */
-
-	if ((vars->ieee_fc &
-	    MDIO_COMBO_IEEE0_AUTO_NEG_ADV_PAUSE_ASYMMETRIC) ==
-	    MDIO_COMBO_IEEE0_AUTO_NEG_ADV_PAUSE_ASYMMETRIC) {
-		val |=  MDIO_AN_REG_ADV_PAUSE_ASYMMETRIC;
-	}
-	if ((vars->ieee_fc &
-	    MDIO_COMBO_IEEE0_AUTO_NEG_ADV_PAUSE_BOTH) ==
-	    MDIO_COMBO_IEEE0_AUTO_NEG_ADV_PAUSE_BOTH) {
-		val |=
-		 MDIO_AN_REG_ADV_PAUSE_PAUSE;
-	}
-	DP(NETIF_MSG_LINK,
-		 "Ext phy AN advertize 0x%x\n", val);
-	bnx2x_cl45_write(bp, params->port,
-		       ext_phy_type,
-		       ext_phy_addr,
-		       MDIO_AN_DEVAD,
-		       MDIO_AN_REG_ADV_PAUSE, val);
-}
-static void bnx2x_set_preemphasis(struct link_params *params)
-{
-	u16 bank, i = 0;
-	struct bnx2x *bp = params->bp;
-
-	for (bank = MDIO_REG_BANK_RX0, i = 0; bank <= MDIO_REG_BANK_RX3;
-	      bank += (MDIO_REG_BANK_RX1-MDIO_REG_BANK_RX0), i++) {
-			CL45_WR_OVER_CL22(bp, params->port,
-					      params->phy_addr,
-					      bank,
-					      MDIO_RX0_RX_EQ_BOOST,
-					      params->xgxs_config_rx[i]);
-	}
-
-	for (bank = MDIO_REG_BANK_TX0, i = 0; bank <= MDIO_REG_BANK_TX3;
-		      bank += (MDIO_REG_BANK_TX1 - MDIO_REG_BANK_TX0), i++) {
-			CL45_WR_OVER_CL22(bp, params->port,
-					      params->phy_addr,
-					      bank,
-					      MDIO_TX0_TX_DRIVER,
-					      params->xgxs_config_tx[i]);
-	}
-}
-
-
-static void bnx2x_8481_set_led4(struct link_params *params,
-			      u32 ext_phy_type, u8 ext_phy_addr)
-{
-	struct bnx2x *bp = params->bp;
-
-	/* PHYC_CTL_LED_CTL */
-	bnx2x_cl45_write(bp, params->port,
-		       ext_phy_type,
-		       ext_phy_addr,
-		       MDIO_PMA_DEVAD,
-		       MDIO_PMA_REG_8481_LINK_SIGNAL, 0xa482);
-
-	/* Unmask LED4 for 10G link */
-	bnx2x_cl45_write(bp, params->port,
-		       ext_phy_type,
-		       ext_phy_addr,
-		       MDIO_PMA_DEVAD,
-		       MDIO_PMA_REG_8481_SIGNAL_MASK, (1<<6));
-	/* 'Interrupt Mask' */
-	bnx2x_cl45_write(bp, params->port,
-		       ext_phy_type,
-		       ext_phy_addr,
-		       MDIO_AN_DEVAD,
-		       0xFFFB, 0xFFFD);
-}
-static void bnx2x_8481_set_legacy_led_mode(struct link_params *params,
-					 u32 ext_phy_type, u8 ext_phy_addr)
-{
-	struct bnx2x *bp = params->bp;
-
-	/* LED1 (10G Link): Disable LED1 when 10/100/1000 link */
-	/* LED2 (1G/100/10 Link): Enable LED2 when 10/100/1000 link) */
-	bnx2x_cl45_write(bp, params->port,
-		       ext_phy_type,
-		       ext_phy_addr,
-		       MDIO_AN_DEVAD,
-		       MDIO_AN_REG_8481_LEGACY_SHADOW,
-		       (1<<15) | (0xd << 10) | (0xc<<4) | 0xe);
-}
-
-static void bnx2x_8481_set_10G_led_mode(struct link_params *params,
-				      u32 ext_phy_type, u8 ext_phy_addr)
-{
-	struct bnx2x *bp = params->bp;
-	u16 val1;
-
-	/* LED1 (10G Link) */
-	/* Enable continuse based on source 7(10G-link) */
-	bnx2x_cl45_read(bp, params->port,
-		       ext_phy_type,
-		       ext_phy_addr,
-		       MDIO_PMA_DEVAD,
-		       MDIO_PMA_REG_8481_LINK_SIGNAL,
-		       &val1);
-	/* Set bit 2 to 0, and bits [1:0] to 10 */
-	val1 &= ~((1<<0) | (1<<2) | (1<<7)); /* Clear bits 0,2,7*/
-	val1 |= ((1<<1) | (1<<6)); /* Set bit 1, 6 */
-
-	bnx2x_cl45_write(bp, params->port,
-		       ext_phy_type,
-		       ext_phy_addr,
-		       MDIO_PMA_DEVAD,
-		       MDIO_PMA_REG_8481_LINK_SIGNAL,
-		       val1);
-
-	/* Unmask LED1 for 10G link */
-	bnx2x_cl45_read(bp, params->port,
-		      ext_phy_type,
-		      ext_phy_addr,
-		      MDIO_PMA_DEVAD,
-		      MDIO_PMA_REG_8481_LED1_MASK,
-		      &val1);
-	/* Set bit 2 to 0, and bits [1:0] to 10 */
-	val1 |= (1<<7);
-	bnx2x_cl45_write(bp, params->port,
-		       ext_phy_type,
-		       ext_phy_addr,
-		       MDIO_PMA_DEVAD,
-		       MDIO_PMA_REG_8481_LED1_MASK,
-		       val1);
-
-	/* LED2 (1G/100/10G Link) */
-	/* Mask LED2 for 10G link */
-	bnx2x_cl45_write(bp, params->port,
-		       ext_phy_type,
-		       ext_phy_addr,
-		       MDIO_PMA_DEVAD,
-		       MDIO_PMA_REG_8481_LED2_MASK,
-		       0);
-
-	/* Unmask LED3 for 10G link */
-	bnx2x_cl45_write(bp, params->port,
-		       ext_phy_type,
-		       ext_phy_addr,
-		       MDIO_PMA_DEVAD,
-		      MDIO_PMA_REG_8481_LED3_MASK,
-		       0x6);
-	bnx2x_cl45_write(bp, params->port,
-		       ext_phy_type,
-		       ext_phy_addr,
-		       MDIO_PMA_DEVAD,
-		       MDIO_PMA_REG_8481_LED3_BLINK,
-		       0);
-}
-
-
-static void bnx2x_init_internal_phy(struct link_params *params,
-				  struct link_vars *vars,
-				  u8 enable_cl73)
-{
-	struct bnx2x *bp = params->bp;
-
-	if (!(vars->phy_flags & PHY_SGMII_FLAG)) {
-		if ((XGXS_EXT_PHY_TYPE(params->ext_phy_config) ==
-		     PORT_HW_CFG_XGXS_EXT_PHY_TYPE_DIRECT) &&
-		    (params->feature_config_flags &
-		     FEATURE_CONFIG_OVERRIDE_PREEMPHASIS_ENABLED))
-			bnx2x_set_preemphasis(params);
-
-		/* forced speed requested? */
-		if (vars->line_speed != SPEED_AUTO_NEG ||
-		    ((XGXS_EXT_PHY_TYPE(params->ext_phy_config) ==
-		     PORT_HW_CFG_XGXS_EXT_PHY_TYPE_DIRECT) &&
-			  params->loopback_mode == LOOPBACK_EXT)) {
-			DP(NETIF_MSG_LINK, "not SGMII, no AN\n");
-
-			/* disable autoneg */
-			bnx2x_set_autoneg(params, vars, 0);
-
-			/* program speed and duplex */
-			bnx2x_program_serdes(params, vars);
-
-		} else { /* AN_mode */
-			DP(NETIF_MSG_LINK, "not SGMII, AN\n");
-
-			/* AN enabled */
-			bnx2x_set_brcm_cl37_advertisment(params);
-
-			/* program duplex & pause advertisement (for aneg) */
-			bnx2x_set_ieee_aneg_advertisment(params,
-						       vars->ieee_fc);
-
-			/* enable autoneg */
-			bnx2x_set_autoneg(params, vars, enable_cl73);
-
-			/* enable and restart AN */
-			bnx2x_restart_autoneg(params, enable_cl73);
-		}
-
-	} else { /* SGMII mode */
-		DP(NETIF_MSG_LINK, "SGMII\n");
-
-		bnx2x_initialize_sgmii_process(params, vars);
-	}
-}
-
-static u8 bnx2x_ext_phy_init(struct link_params *params, struct link_vars *vars)
-{
-	struct bnx2x *bp = params->bp;
-	u32 ext_phy_type;
-	u8 ext_phy_addr;
-	u16 cnt;
-	u16 ctrl = 0;
-	u16 val = 0;
-	u8 rc = 0;
-
-	if (vars->phy_flags & PHY_XGXS_FLAG) {
-		ext_phy_addr = XGXS_EXT_PHY_ADDR(params->ext_phy_config);
-
-		ext_phy_type = XGXS_EXT_PHY_TYPE(params->ext_phy_config);
-		/* Make sure that the soft reset is off (expect for the 8072:
-		 * due to the lock, it will be done inside the specific
-		 * handling)
-		 */
-		if ((ext_phy_type != PORT_HW_CFG_XGXS_EXT_PHY_TYPE_DIRECT) &&
-		    (ext_phy_type != PORT_HW_CFG_XGXS_EXT_PHY_TYPE_FAILURE) &&
-		   (ext_phy_type != PORT_HW_CFG_XGXS_EXT_PHY_TYPE_NOT_CONN) &&
-		    (ext_phy_type != PORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM8072) &&
-		    (ext_phy_type != PORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM8073)) {
-			/* Wait for soft reset to get cleared upto 1 sec */
-			for (cnt = 0; cnt < 1000; cnt++) {
-				bnx2x_cl45_read(bp, params->port,
-					      ext_phy_type,
-					      ext_phy_addr,
-					      MDIO_PMA_DEVAD,
-					      MDIO_PMA_REG_CTRL, &ctrl);
-				if (!(ctrl & (1<<15)))
-					break;
-				msleep(1);
-			}
-			DP(NETIF_MSG_LINK, "control reg 0x%x (after %d ms)\n",
-				 ctrl, cnt);
-		}
-
-		switch (ext_phy_type) {
-		case PORT_HW_CFG_XGXS_EXT_PHY_TYPE_DIRECT:
-			break;
-
-		case PORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM8705:
-			DP(NETIF_MSG_LINK, "XGXS 8705\n");
-
-			bnx2x_cl45_write(bp, params->port,
-				       ext_phy_type,
-				       ext_phy_addr,
-				       MDIO_PMA_DEVAD,
-				       MDIO_PMA_REG_MISC_CTRL,
-				       0x8288);
-			bnx2x_cl45_write(bp, params->port,
-				       ext_phy_type,
-				       ext_phy_addr,
-				       MDIO_PMA_DEVAD,
-				       MDIO_PMA_REG_PHY_IDENTIFIER,
-				       0x7fbf);
-			bnx2x_cl45_write(bp, params->port,
-				       ext_phy_type,
-				       ext_phy_addr,
-				       MDIO_PMA_DEVAD,
-				       MDIO_PMA_REG_CMU_PLL_BYPASS,
-				       0x0100);
-			bnx2x_cl45_write(bp, params->port,
-				       ext_phy_type,
-				       ext_phy_addr,
-				       MDIO_WIS_DEVAD,
-				       MDIO_WIS_REG_LASI_CNTL, 0x1);
-
-			/* BCM8705 doesn't have microcode, hence the 0 */
-			bnx2x_save_spirom_version(bp, params->port,
-						params->shmem_base, 0);
-			break;
-
-		case PORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM8706:
-			/* Wait until fw is loaded */
-			for (cnt = 0; cnt < 100; cnt++) {
-				bnx2x_cl45_read(bp, params->port, ext_phy_type,
-					      ext_phy_addr, MDIO_PMA_DEVAD,
-					      MDIO_PMA_REG_ROM_VER1, &val);
-				if (val)
-					break;
-				msleep(10);
-			}
-			DP(NETIF_MSG_LINK, "XGXS 8706 is initialized "
-				"after %d ms\n", cnt);
-			if ((params->feature_config_flags &
-			     FEATURE_CONFIG_OVERRIDE_PREEMPHASIS_ENABLED)) {
-				u8 i;
-				u16 reg;
-				for (i = 0; i < 4; i++) {
-					reg = MDIO_XS_8706_REG_BANK_RX0 +
-						i*(MDIO_XS_8706_REG_BANK_RX1 -
-						   MDIO_XS_8706_REG_BANK_RX0);
-					bnx2x_cl45_read(bp, params->port,
-						      ext_phy_type,
-						      ext_phy_addr,
-						      MDIO_XS_DEVAD,
-						      reg, &val);
-					/* Clear first 3 bits of the control */
-					val &= ~0x7;
-					/* Set control bits according to
-					configuation */
-					val |= (params->xgxs_config_rx[i] &
-						0x7);
-					DP(NETIF_MSG_LINK, "Setting RX"
-						 "Equalizer to BCM8706 reg 0x%x"
-						 " <-- val 0x%x\n", reg, val);
-					bnx2x_cl45_write(bp, params->port,
-						       ext_phy_type,
-						       ext_phy_addr,
-						       MDIO_XS_DEVAD,
-						       reg, val);
-				}
-			}
-			/* Force speed */
-			if (params->req_line_speed == SPEED_10000) {
-				DP(NETIF_MSG_LINK, "XGXS 8706 force 10Gbps\n");
-
-				bnx2x_cl45_write(bp, params->port,
-					       ext_phy_type,
-					       ext_phy_addr,
-					       MDIO_PMA_DEVAD,
-					       MDIO_PMA_REG_DIGITAL_CTRL,
-					       0x400);
-				bnx2x_cl45_write(bp, params->port, ext_phy_type,
-					       ext_phy_addr, MDIO_PMA_DEVAD,
-					       MDIO_PMA_REG_LASI_CTRL, 1);
-			} else {
-				/* Force 1Gbps using autoneg with 1G
-				advertisment */
-
-				/* Allow CL37 through CL73 */
-				DP(NETIF_MSG_LINK, "XGXS 8706 AutoNeg\n");
-				bnx2x_cl45_write(bp, params->port,
-					       ext_phy_type,
-					       ext_phy_addr,
-					       MDIO_AN_DEVAD,
-					       MDIO_AN_REG_CL37_CL73,
-					       0x040c);
-
-				/* Enable Full-Duplex advertisment on CL37 */
-				bnx2x_cl45_write(bp, params->port,
-					       ext_phy_type,
-					       ext_phy_addr,
-					       MDIO_AN_DEVAD,
-					       MDIO_AN_REG_CL37_FC_LP,
-					       0x0020);
-				/* Enable CL37 AN */
-				bnx2x_cl45_write(bp, params->port,
-					       ext_phy_type,
-					       ext_phy_addr,
-					       MDIO_AN_DEVAD,
-					       MDIO_AN_REG_CL37_AN,
-					       0x1000);
-				/* 1G support */
-				bnx2x_cl45_write(bp, params->port,
-					       ext_phy_type,
-					       ext_phy_addr,
-					       MDIO_AN_DEVAD,
-					       MDIO_AN_REG_ADV, (1<<5));
-
-				/* Enable clause 73 AN */
-				bnx2x_cl45_write(bp, params->port,
-					       ext_phy_type,
-					       ext_phy_addr,
-					       MDIO_AN_DEVAD,
-					       MDIO_AN_REG_CTRL,
-					       0x1200);
-				bnx2x_cl45_write(bp, params->port,
-					       ext_phy_type,
-					       ext_phy_addr,
-					       MDIO_PMA_DEVAD,
-					       MDIO_PMA_REG_RX_ALARM_CTRL,
-					       0x0400);
-				bnx2x_cl45_write(bp, params->port,
-					       ext_phy_type,
-					       ext_phy_addr,
-					       MDIO_PMA_DEVAD,
-					       MDIO_PMA_REG_LASI_CTRL, 0x0004);
-
-			}
-			bnx2x_save_bcm_spirom_ver(bp, params->port,
-						ext_phy_type,
-						ext_phy_addr,
-						params->shmem_base);
-			break;
-		case PORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM8726:
-			DP(NETIF_MSG_LINK, "Initializing BCM8726\n");
-			bnx2x_bcm8726_external_rom_boot(params);
-
-			/* Need to call module detected on initialization since
-			the module detection triggered by actual module
-			insertion might occur before driver is loaded, and when
-			driver is loaded, it reset all registers, including the
-			transmitter */
-			bnx2x_sfp_module_detection(params);
-
-			/* Set Flow control */
-			bnx2x_ext_phy_set_pause(params, vars);
-			if (params->req_line_speed == SPEED_1000) {
-				DP(NETIF_MSG_LINK, "Setting 1G force\n");
-				bnx2x_cl45_write(bp, params->port, ext_phy_type,
-					       ext_phy_addr, MDIO_PMA_DEVAD,
-					       MDIO_PMA_REG_CTRL, 0x40);
-				bnx2x_cl45_write(bp, params->port, ext_phy_type,
-					       ext_phy_addr, MDIO_PMA_DEVAD,
-					       MDIO_PMA_REG_10G_CTRL2, 0xD);
-				bnx2x_cl45_write(bp, params->port, ext_phy_type,
-					       ext_phy_addr, MDIO_PMA_DEVAD,
-					       MDIO_PMA_REG_LASI_CTRL, 0x5);
-				bnx2x_cl45_write(bp, params->port, ext_phy_type,
-					       ext_phy_addr, MDIO_PMA_DEVAD,
-					       MDIO_PMA_REG_RX_ALARM_CTRL,
-					       0x400);
-			} else if ((params->req_line_speed ==
-				    SPEED_AUTO_NEG) &&
-				   ((params->speed_cap_mask &
-				     PORT_HW_CFG_SPEED_CAPABILITY_D0_1G))) {
-				DP(NETIF_MSG_LINK, "Setting 1G clause37 \n");
-				bnx2x_cl45_write(bp, params->port, ext_phy_type,
-					       ext_phy_addr, MDIO_AN_DEVAD,
-					       MDIO_AN_REG_ADV, 0x20);
-				bnx2x_cl45_write(bp, params->port, ext_phy_type,
-					       ext_phy_addr, MDIO_AN_DEVAD,
-					       MDIO_AN_REG_CL37_CL73, 0x040c);
-				bnx2x_cl45_write(bp, params->port, ext_phy_type,
-					       ext_phy_addr, MDIO_AN_DEVAD,
-					       MDIO_AN_REG_CL37_FC_LD, 0x0020);
-				bnx2x_cl45_write(bp, params->port, ext_phy_type,
-					       ext_phy_addr, MDIO_AN_DEVAD,
-					       MDIO_AN_REG_CL37_AN, 0x1000);
-				bnx2x_cl45_write(bp, params->port, ext_phy_type,
-					       ext_phy_addr, MDIO_AN_DEVAD,
-					       MDIO_AN_REG_CTRL, 0x1200);
-
-				/* Enable RX-ALARM control to receive
-				interrupt for 1G speed change */
-				bnx2x_cl45_write(bp, params->port, ext_phy_type,
-					       ext_phy_addr, MDIO_PMA_DEVAD,
-					       MDIO_PMA_REG_LASI_CTRL, 0x4);
-				bnx2x_cl45_write(bp, params->port, ext_phy_type,
-					       ext_phy_addr, MDIO_PMA_DEVAD,
-					       MDIO_PMA_REG_RX_ALARM_CTRL,
-					       0x400);
-
-			} else { /* Default 10G. Set only LASI control */
-				bnx2x_cl45_write(bp, params->port, ext_phy_type,
-					       ext_phy_addr, MDIO_PMA_DEVAD,
-					       MDIO_PMA_REG_LASI_CTRL, 1);
-			}
-
-			/* Set TX PreEmphasis if needed */
-			if ((params->feature_config_flags &
-			     FEATURE_CONFIG_OVERRIDE_PREEMPHASIS_ENABLED)) {
-				DP(NETIF_MSG_LINK, "Setting TX_CTRL1 0x%x,"
-					 "TX_CTRL2 0x%x\n",
-					 params->xgxs_config_tx[0],
-					 params->xgxs_config_tx[1]);
-				bnx2x_cl45_write(bp, params->port,
-					       ext_phy_type,
-					       ext_phy_addr,
-					       MDIO_PMA_DEVAD,
-					       MDIO_PMA_REG_8726_TX_CTRL1,
-					       params->xgxs_config_tx[0]);
-
-				bnx2x_cl45_write(bp, params->port,
-					       ext_phy_type,
-					       ext_phy_addr,
-					       MDIO_PMA_DEVAD,
-					       MDIO_PMA_REG_8726_TX_CTRL2,
-					       params->xgxs_config_tx[1]);
-			}
-			break;
-		case PORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM8072:
-		case PORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM8073:
-		{
-			u16 tmp1;
-			u16 rx_alarm_ctrl_val;
-			u16 lasi_ctrl_val;
-			if (ext_phy_type ==
-			    PORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM8072) {
-				rx_alarm_ctrl_val = 0x400;
-				lasi_ctrl_val = 0x0004;
-			} else {
-				rx_alarm_ctrl_val = (1<<2);
-				lasi_ctrl_val = 0x0004;
-			}
-
-			/* enable LASI */
-			bnx2x_cl45_write(bp, params->port,
-				   ext_phy_type,
-				   ext_phy_addr,
-				   MDIO_PMA_DEVAD,
-				   MDIO_PMA_REG_RX_ALARM_CTRL,
-				   rx_alarm_ctrl_val);
-
-			bnx2x_cl45_write(bp, params->port,
-				       ext_phy_type,
-				       ext_phy_addr,
-				       MDIO_PMA_DEVAD,
-				       MDIO_PMA_REG_LASI_CTRL,
-				       lasi_ctrl_val);
-
-			bnx2x_8073_set_pause_cl37(params, vars);
-
-			if (ext_phy_type ==
-			    PORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM8072)
-				bnx2x_bcm8072_external_rom_boot(params);
-			else
-				/* In case of 8073 with long xaui lines,
-				don't set the 8073 xaui low power*/
-				bnx2x_bcm8073_set_xaui_low_power_mode(params);
-
-			bnx2x_cl45_read(bp, params->port,
-				      ext_phy_type,
-				      ext_phy_addr,
-				      MDIO_PMA_DEVAD,
-				      MDIO_PMA_REG_M8051_MSGOUT_REG,
-				      &tmp1);
-
-			bnx2x_cl45_read(bp, params->port,
-				      ext_phy_type,
-				      ext_phy_addr,
-				      MDIO_PMA_DEVAD,
-				      MDIO_PMA_REG_RX_ALARM, &tmp1);
-
-			DP(NETIF_MSG_LINK, "Before rom RX_ALARM(port1):"
-					     "0x%x\n", tmp1);
-
-			/* If this is forced speed, set to KR or KX
-			 * (all other are not supported)
-			 */
-			if (params->loopback_mode == LOOPBACK_EXT) {
-				bnx2x_bcm807x_force_10G(params);
-				DP(NETIF_MSG_LINK,
-					"Forced speed 10G on 807X\n");
-				break;
-			} else {
-				bnx2x_cl45_write(bp, params->port,
-					       ext_phy_type, ext_phy_addr,
-					       MDIO_PMA_DEVAD,
-					       MDIO_PMA_REG_BCM_CTRL,
-					       0x0002);
-			}
-			if (params->req_line_speed != SPEED_AUTO_NEG) {
-				if (params->req_line_speed == SPEED_10000) {
-					val = (1<<7);
-				} else if (params->req_line_speed ==
-					   SPEED_2500) {
-					val = (1<<5);
-					/* Note that 2.5G works only
-					when used with 1G advertisment */
-				} else
-					val = (1<<5);
-			} else {
-
-				val = 0;
-				if (params->speed_cap_mask &
-					PORT_HW_CFG_SPEED_CAPABILITY_D0_10G)
-					val |= (1<<7);
-
-				/* Note that 2.5G works only when
-				used with 1G advertisment */
-				if (params->speed_cap_mask &
-					(PORT_HW_CFG_SPEED_CAPABILITY_D0_1G |
-					 PORT_HW_CFG_SPEED_CAPABILITY_D0_2_5G))
-					val |= (1<<5);
-				DP(NETIF_MSG_LINK,
-					 "807x autoneg val = 0x%x\n", val);
-			}
-
-			bnx2x_cl45_write(bp, params->port,
-				       ext_phy_type,
-				       ext_phy_addr,
-				       MDIO_AN_DEVAD,
-				       MDIO_AN_REG_ADV, val);
-			if (ext_phy_type ==
-			    PORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM8073) {
-				bnx2x_cl45_read(bp, params->port,
-					      ext_phy_type,
-					      ext_phy_addr,
-					      MDIO_AN_DEVAD,
-					      MDIO_AN_REG_8073_2_5G, &tmp1);
-
-				if (((params->speed_cap_mask &
-				      PORT_HW_CFG_SPEED_CAPABILITY_D0_2_5G) &&
-				     (params->req_line_speed ==
-				      SPEED_AUTO_NEG)) ||
-				    (params->req_line_speed ==
-				     SPEED_2500)) {
-					u16 phy_ver;
-					/* Allow 2.5G for A1 and above */
-					bnx2x_cl45_read(bp, params->port,
-					 PORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM8073,
-					 ext_phy_addr,
-					 MDIO_PMA_DEVAD,
-					 MDIO_PMA_REG_8073_CHIP_REV, &phy_ver);
-					DP(NETIF_MSG_LINK, "Add 2.5G\n");
-					if (phy_ver > 0)
-						tmp1 |= 1;
-					else
-						tmp1 &= 0xfffe;
-				} else {
-					DP(NETIF_MSG_LINK, "Disable 2.5G\n");
-					tmp1 &= 0xfffe;
-				}
-
-				bnx2x_cl45_write(bp, params->port,
-					       ext_phy_type,
-					       ext_phy_addr,
-					       MDIO_AN_DEVAD,
-					       MDIO_AN_REG_8073_2_5G, tmp1);
-			}
-
-			/* Add support for CL37 (passive mode) II */
-
-			bnx2x_cl45_read(bp, params->port,
-				       ext_phy_type,
-				       ext_phy_addr,
-				       MDIO_AN_DEVAD,
-				       MDIO_AN_REG_CL37_FC_LD,
-				       &tmp1);
-
-			bnx2x_cl45_write(bp, params->port,
-				       ext_phy_type,
-				       ext_phy_addr,
-				       MDIO_AN_DEVAD,
-				       MDIO_AN_REG_CL37_FC_LD, (tmp1 |
-				       ((params->req_duplex == DUPLEX_FULL) ?
-				       0x20 : 0x40)));
-
-			/* Add support for CL37 (passive mode) III */
-			bnx2x_cl45_write(bp, params->port,
-				       ext_phy_type,
-				       ext_phy_addr,
-				       MDIO_AN_DEVAD,
-				       MDIO_AN_REG_CL37_AN, 0x1000);
-
-			if (ext_phy_type ==
-			    PORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM8073) {
-				/* The SNR will improve about 2db by changing
-				BW and FEE main tap. Rest commands are executed
-				after link is up*/
-				/*Change FFE main cursor to 5 in EDC register*/
-				if (bnx2x_8073_is_snr_needed(params))
-					bnx2x_cl45_write(bp, params->port,
-						    ext_phy_type,
-						    ext_phy_addr,
-						    MDIO_PMA_DEVAD,
-						    MDIO_PMA_REG_EDC_FFE_MAIN,
-						    0xFB0C);
-
-				/* Enable FEC (Forware Error Correction)
-				Request in the AN */
-				bnx2x_cl45_read(bp, params->port,
-					      ext_phy_type,
-					      ext_phy_addr,
-					      MDIO_AN_DEVAD,
-					      MDIO_AN_REG_ADV2, &tmp1);
-
-				tmp1 |= (1<<15);
-
-				bnx2x_cl45_write(bp, params->port,
-					       ext_phy_type,
-					       ext_phy_addr,
-					       MDIO_AN_DEVAD,
-					       MDIO_AN_REG_ADV2, tmp1);
-
-			}
-
-			bnx2x_ext_phy_set_pause(params, vars);
-
-			/* Restart autoneg */
-			msleep(500);
-			bnx2x_cl45_write(bp, params->port,
-				       ext_phy_type,
-				       ext_phy_addr,
-				       MDIO_AN_DEVAD,
-				       MDIO_AN_REG_CTRL, 0x1200);
-			DP(NETIF_MSG_LINK, "807x Autoneg Restart: "
-			   "Advertise 1G=%x, 10G=%x\n",
-			   ((val & (1<<5)) > 0),
-			   ((val & (1<<7)) > 0));
-			break;
-		}
-
-		case PORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM8727:
-		{
-			u16 tmp1;
-			u16 rx_alarm_ctrl_val;
-			u16 lasi_ctrl_val;
-
-			/* Enable PMD link, MOD_ABS_FLT, and 1G link alarm */
-
-			u16 mod_abs;
-			rx_alarm_ctrl_val = (1<<2) | (1<<5) ;
-			lasi_ctrl_val = 0x0004;
-
-			DP(NETIF_MSG_LINK, "Initializing BCM8727\n");
-			/* enable LASI */
-			bnx2x_cl45_write(bp, params->port,
-				       ext_phy_type,
-				       ext_phy_addr,
-				       MDIO_PMA_DEVAD,
-				       MDIO_PMA_REG_RX_ALARM_CTRL,
-				       rx_alarm_ctrl_val);
-
-			bnx2x_cl45_write(bp, params->port,
-				       ext_phy_type,
-				       ext_phy_addr,
-				       MDIO_PMA_DEVAD,
-				       MDIO_PMA_REG_LASI_CTRL,
-				       lasi_ctrl_val);
-
-			/* Initially configure  MOD_ABS to interrupt when
-			module is presence( bit 8) */
-			bnx2x_cl45_read(bp, params->port,
-				      ext_phy_type,
-				      ext_phy_addr,
-				      MDIO_PMA_DEVAD,
-				      MDIO_PMA_REG_PHY_IDENTIFIER, &mod_abs);
-			/* Set EDC off by setting OPTXLOS signal input to low
-			(bit 9).
-			When the EDC is off it locks onto a reference clock and
-			avoids becoming 'lost'.*/
-			mod_abs &= ~((1<<8) | (1<<9));
-			bnx2x_cl45_write(bp, params->port,
-				       ext_phy_type,
-				       ext_phy_addr,
-				       MDIO_PMA_DEVAD,
-				       MDIO_PMA_REG_PHY_IDENTIFIER, mod_abs);
-
-			/* Make MOD_ABS give interrupt on change */
-			bnx2x_cl45_read(bp, params->port,
-				      ext_phy_type,
-				      ext_phy_addr,
-				      MDIO_PMA_DEVAD,
-				      MDIO_PMA_REG_8727_PCS_OPT_CTRL,
-				      &val);
-			val |= (1<<12);
-			bnx2x_cl45_write(bp, params->port,
-				       ext_phy_type,
-				       ext_phy_addr,
-				       MDIO_PMA_DEVAD,
-				       MDIO_PMA_REG_8727_PCS_OPT_CTRL,
-				       val);
-
-			/* Set 8727 GPIOs to input to allow reading from the
-			8727 GPIO0 status which reflect SFP+ module
-			over-current */
-
-			bnx2x_cl45_read(bp, params->port,
-				       PORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM8727,
-				       ext_phy_addr,
-				       MDIO_PMA_DEVAD,
-				       MDIO_PMA_REG_8727_PCS_OPT_CTRL,
-				       &val);
-			val &= 0xff8f; /* Reset bits 4-6 */
-			bnx2x_cl45_write(bp, params->port,
-				       PORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM8727,
-				       ext_phy_addr,
-				       MDIO_PMA_DEVAD,
-				       MDIO_PMA_REG_8727_PCS_OPT_CTRL,
-				       val);
-
-			bnx2x_8727_power_module(bp, params, ext_phy_addr, 1);
-			bnx2x_bcm8073_set_xaui_low_power_mode(params);
-
-			bnx2x_cl45_read(bp, params->port,
-				      ext_phy_type,
-				      ext_phy_addr,
-				      MDIO_PMA_DEVAD,
-				      MDIO_PMA_REG_M8051_MSGOUT_REG,
-				      &tmp1);
-
-			bnx2x_cl45_read(bp, params->port,
-				      ext_phy_type,
-				      ext_phy_addr,
-				      MDIO_PMA_DEVAD,
-				      MDIO_PMA_REG_RX_ALARM, &tmp1);
-
-			/* Set option 1G speed */
-			if (params->req_line_speed == SPEED_1000) {
-
-				DP(NETIF_MSG_LINK, "Setting 1G force\n");
-				bnx2x_cl45_write(bp, params->port,
-					       ext_phy_type,
-					       ext_phy_addr,
-					       MDIO_PMA_DEVAD,
-					       MDIO_PMA_REG_CTRL, 0x40);
-				bnx2x_cl45_write(bp, params->port,
-					       ext_phy_type,
-					       ext_phy_addr,
-					       MDIO_PMA_DEVAD,
-					       MDIO_PMA_REG_10G_CTRL2, 0xD);
-				bnx2x_cl45_read(bp, params->port,
-				      ext_phy_type,
-				      ext_phy_addr,
-				      MDIO_PMA_DEVAD,
-				      MDIO_PMA_REG_10G_CTRL2, &tmp1);
-				DP(NETIF_MSG_LINK, "1.7 = 0x%x \n", tmp1);
-
-			} else if ((params->req_line_speed ==
-				    SPEED_AUTO_NEG) &&
-				   ((params->speed_cap_mask &
-				     PORT_HW_CFG_SPEED_CAPABILITY_D0_1G))) {
-
-				DP(NETIF_MSG_LINK, "Setting 1G clause37 \n");
-				bnx2x_cl45_write(bp, params->port, ext_phy_type,
-					       ext_phy_addr, MDIO_AN_DEVAD,
-					       MDIO_PMA_REG_8727_MISC_CTRL, 0);
-				bnx2x_cl45_write(bp, params->port, ext_phy_type,
-					       ext_phy_addr, MDIO_AN_DEVAD,
-					       MDIO_AN_REG_CL37_AN, 0x1300);
-			} else {
-				/* Since the 8727 has only single reset pin,
-				need to set the 10G registers although it is
-				default */
-				bnx2x_cl45_write(bp, params->port, ext_phy_type,
-					       ext_phy_addr, MDIO_AN_DEVAD,
-					       MDIO_AN_REG_CTRL, 0x0020);
-				bnx2x_cl45_write(bp, params->port, ext_phy_type,
-					       ext_phy_addr, MDIO_AN_DEVAD,
-					       0x7, 0x0100);
-				bnx2x_cl45_write(bp, params->port, ext_phy_type,
-					       ext_phy_addr, MDIO_PMA_DEVAD,
-					       MDIO_PMA_REG_CTRL, 0x2040);
-				bnx2x_cl45_write(bp, params->port, ext_phy_type,
-					       ext_phy_addr, MDIO_PMA_DEVAD,
-					       MDIO_PMA_REG_10G_CTRL2, 0x0008);
-			}
-
-			/* Set 2-wire transfer rate to 400Khz since 100Khz
-			is not operational */
-			bnx2x_cl45_write(bp, params->port,
-				       ext_phy_type,
-				       ext_phy_addr,
-				       MDIO_PMA_DEVAD,
-				       MDIO_PMA_REG_8727_TWO_WIRE_SLAVE_ADDR,
-				       0xa101);
-
-			/* Set TX PreEmphasis if needed */
-			if ((params->feature_config_flags &
-			     FEATURE_CONFIG_OVERRIDE_PREEMPHASIS_ENABLED)) {
-				DP(NETIF_MSG_LINK, "Setting TX_CTRL1 0x%x,"
-					 "TX_CTRL2 0x%x\n",
-					 params->xgxs_config_tx[0],
-					 params->xgxs_config_tx[1]);
-				bnx2x_cl45_write(bp, params->port,
-					       ext_phy_type,
-					       ext_phy_addr,
-					       MDIO_PMA_DEVAD,
-					       MDIO_PMA_REG_8727_TX_CTRL1,
-					       params->xgxs_config_tx[0]);
-
-				bnx2x_cl45_write(bp, params->port,
-					       ext_phy_type,
-					       ext_phy_addr,
-					       MDIO_PMA_DEVAD,
-					       MDIO_PMA_REG_8727_TX_CTRL2,
-					       params->xgxs_config_tx[1]);
-			}
-
-			break;
-		}
-
-		case PORT_HW_CFG_XGXS_EXT_PHY_TYPE_SFX7101:
-		{
-			u16 fw_ver1, fw_ver2;
-			DP(NETIF_MSG_LINK,
-				"Setting the SFX7101 LASI indication\n");
-
-			bnx2x_cl45_write(bp, params->port,
-				       ext_phy_type,
-				       ext_phy_addr,
-				       MDIO_PMA_DEVAD,
-				       MDIO_PMA_REG_LASI_CTRL, 0x1);
-			DP(NETIF_MSG_LINK,
-			  "Setting the SFX7101 LED to blink on traffic\n");
-			bnx2x_cl45_write(bp, params->port,
-				       ext_phy_type,
-				       ext_phy_addr,
-				       MDIO_PMA_DEVAD,
-				       MDIO_PMA_REG_7107_LED_CNTL, (1<<3));
-
-			bnx2x_ext_phy_set_pause(params, vars);
-			/* Restart autoneg */
-			bnx2x_cl45_read(bp, params->port,
-				      ext_phy_type,
-				      ext_phy_addr,
-				      MDIO_AN_DEVAD,
-				      MDIO_AN_REG_CTRL, &val);
-			val |= 0x200;
-			bnx2x_cl45_write(bp, params->port,
-				       ext_phy_type,
-				       ext_phy_addr,
-				       MDIO_AN_DEVAD,
-				       MDIO_AN_REG_CTRL, val);
-
-			/* Save spirom version */
-			bnx2x_cl45_read(bp, params->port, ext_phy_type,
-				      ext_phy_addr, MDIO_PMA_DEVAD,
-				      MDIO_PMA_REG_7101_VER1, &fw_ver1);
-
-			bnx2x_cl45_read(bp, params->port, ext_phy_type,
-				      ext_phy_addr, MDIO_PMA_DEVAD,
-				      MDIO_PMA_REG_7101_VER2, &fw_ver2);
-
-			bnx2x_save_spirom_version(params->bp, params->port,
-						params->shmem_base,
-						(u32)(fw_ver1<<16 | fw_ver2));
-			break;
-		}
-		case PORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM8481:
-		case PORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM84823:
-			/* This phy uses the NIG latch mechanism since link
-				indication arrives through its LED4 and not via
-				its LASI signal, so we get steady signal
-				instead of clear on read */
-			bnx2x_bits_en(bp, NIG_REG_LATCH_BC_0 + params->port*4,
-				    1 << NIG_LATCH_BC_ENABLE_MI_INT);
-
-			bnx2x_cl45_write(bp, params->port,
-				       PORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM8481,
-				       ext_phy_addr,
-				       MDIO_PMA_DEVAD,
-				       MDIO_PMA_REG_CTRL, 0x0000);
-
-			bnx2x_8481_set_led4(params, ext_phy_type, ext_phy_addr);
-			if (params->req_line_speed == SPEED_AUTO_NEG) {
-
-				u16 autoneg_val, an_1000_val, an_10_100_val;
-				/* set 1000 speed advertisement */
-				bnx2x_cl45_read(bp, params->port,
-					      ext_phy_type,
-					      ext_phy_addr,
-					      MDIO_AN_DEVAD,
-					      MDIO_AN_REG_8481_1000T_CTRL,
-					      &an_1000_val);
-
-				if (params->speed_cap_mask &
-				    PORT_HW_CFG_SPEED_CAPABILITY_D0_1G) {
-					an_1000_val |= (1<<8);
-					if (params->req_duplex == DUPLEX_FULL)
-						an_1000_val |= (1<<9);
-					DP(NETIF_MSG_LINK, "Advertising 1G\n");
-				} else
-					an_1000_val &= ~((1<<8) | (1<<9));
-
-				bnx2x_cl45_write(bp, params->port,
-					       ext_phy_type,
-					       ext_phy_addr,
-					       MDIO_AN_DEVAD,
-					       MDIO_AN_REG_8481_1000T_CTRL,
-					       an_1000_val);
-
-				/* set 100 speed advertisement */
-				bnx2x_cl45_read(bp, params->port,
-					      ext_phy_type,
-					      ext_phy_addr,
-					      MDIO_AN_DEVAD,
-					      MDIO_AN_REG_8481_LEGACY_AN_ADV,
-					      &an_10_100_val);
-
-				if (params->speed_cap_mask &
-				 (PORT_HW_CFG_SPEED_CAPABILITY_D0_100M_FULL |
-				  PORT_HW_CFG_SPEED_CAPABILITY_D0_100M_HALF)) {
-					an_10_100_val |= (1<<7);
-					if (params->req_duplex == DUPLEX_FULL)
-						an_10_100_val |= (1<<8);
-					DP(NETIF_MSG_LINK,
-						"Advertising 100M\n");
-				} else
-					an_10_100_val &= ~((1<<7) | (1<<8));
-
-				/* set 10 speed advertisement */
-				if (params->speed_cap_mask &
-				  (PORT_HW_CFG_SPEED_CAPABILITY_D0_10M_FULL |
-				   PORT_HW_CFG_SPEED_CAPABILITY_D0_10M_HALF)) {
-					an_10_100_val |= (1<<5);
-					if (params->req_duplex == DUPLEX_FULL)
-						an_10_100_val |= (1<<6);
-					DP(NETIF_MSG_LINK, "Advertising 10M\n");
-				     }
-				else
-					an_10_100_val &= ~((1<<5) | (1<<6));
-
-				bnx2x_cl45_write(bp, params->port,
-					       ext_phy_type,
-					       ext_phy_addr,
-					       MDIO_AN_DEVAD,
-					       MDIO_AN_REG_8481_LEGACY_AN_ADV,
-					       an_10_100_val);
-
-				bnx2x_cl45_read(bp, params->port,
-					      ext_phy_type,
-					      ext_phy_addr,
-					      MDIO_AN_DEVAD,
-					      MDIO_AN_REG_8481_LEGACY_MII_CTRL,
-					      &autoneg_val);
-
-				/* Disable forced speed */
-				autoneg_val &= ~(1<<6|1<<13);
-
-				/* Enable autoneg and restart autoneg
-				for legacy speeds */
-				autoneg_val |= (1<<9|1<<12);
-
-				if (params->req_duplex == DUPLEX_FULL)
-					autoneg_val |= (1<<8);
-				else
-					autoneg_val &= ~(1<<8);
-
-				bnx2x_cl45_write(bp, params->port,
-					       ext_phy_type,
-					       ext_phy_addr,
-					       MDIO_AN_DEVAD,
-					       MDIO_AN_REG_8481_LEGACY_MII_CTRL,
-					       autoneg_val);
-
-				if (params->speed_cap_mask &
-				    PORT_HW_CFG_SPEED_CAPABILITY_D0_10G) {
-					DP(NETIF_MSG_LINK, "Advertising 10G\n");
-					/* Restart autoneg for 10G*/
-
-			bnx2x_cl45_write(bp, params->port,
-				       ext_phy_type,
-				       ext_phy_addr,
-				       MDIO_AN_DEVAD,
-				       MDIO_AN_REG_CTRL, 0x3200);
-				}
-			} else {
-				/* Force speed */
-				u16 autoneg_ctrl, pma_ctrl;
-				bnx2x_cl45_read(bp, params->port,
-					      ext_phy_type,
-					      ext_phy_addr,
-					      MDIO_AN_DEVAD,
-					      MDIO_AN_REG_8481_LEGACY_MII_CTRL,
-					      &autoneg_ctrl);
-
-				/* Disable autoneg */
-				autoneg_ctrl &= ~(1<<12);
-
-				/* Set 1000 force */
-				switch (params->req_line_speed) {
-				case SPEED_10000:
-					DP(NETIF_MSG_LINK,
-						"Unable to set 10G force !\n");
-					break;
-				case SPEED_1000:
-					bnx2x_cl45_read(bp, params->port,
-						      ext_phy_type,
-						      ext_phy_addr,
-						      MDIO_PMA_DEVAD,
-						      MDIO_PMA_REG_CTRL,
-						      &pma_ctrl);
-					autoneg_ctrl &= ~(1<<13);
-					autoneg_ctrl |= (1<<6);
-					pma_ctrl &= ~(1<<13);
-					pma_ctrl |= (1<<6);
-					DP(NETIF_MSG_LINK,
-						"Setting 1000M force\n");
-					bnx2x_cl45_write(bp, params->port,
-						       ext_phy_type,
-						       ext_phy_addr,
-						       MDIO_PMA_DEVAD,
-						       MDIO_PMA_REG_CTRL,
-						       pma_ctrl);
-					break;
-				case SPEED_100:
-					autoneg_ctrl |= (1<<13);
-					autoneg_ctrl &= ~(1<<6);
-					DP(NETIF_MSG_LINK,
-						"Setting 100M force\n");
-					break;
-				case SPEED_10:
-					autoneg_ctrl &= ~(1<<13);
-					autoneg_ctrl &= ~(1<<6);
-					DP(NETIF_MSG_LINK,
-						"Setting 10M force\n");
-					break;
-				}
-
-				/* Duplex mode */
-				if (params->req_duplex == DUPLEX_FULL) {
-					autoneg_ctrl |= (1<<8);
-					DP(NETIF_MSG_LINK,
-						"Setting full duplex\n");
-				} else
-					autoneg_ctrl &= ~(1<<8);
-
-				/* Update autoneg ctrl and pma ctrl */
-				bnx2x_cl45_write(bp, params->port,
-					       ext_phy_type,
-					       ext_phy_addr,
-					       MDIO_AN_DEVAD,
-					       MDIO_AN_REG_8481_LEGACY_MII_CTRL,
-					       autoneg_ctrl);
-			}
-
-			/* Save spirom version */
-			bnx2x_save_8481_spirom_version(bp, params->port,
-						     ext_phy_addr,
-						     params->shmem_base);
-			break;
-		case PORT_HW_CFG_XGXS_EXT_PHY_TYPE_FAILURE:
-			DP(NETIF_MSG_LINK,
-				 "XGXS PHY Failure detected 0x%x\n",
-				 params->ext_phy_config);
-			rc = -EINVAL;
-			break;
-		default:
-			DP(NETIF_MSG_LINK, "BAD XGXS ext_phy_config 0x%x\n",
-				  params->ext_phy_config);
-			rc = -EINVAL;
-			break;
-		}
-
-	} else { /* SerDes */
-
-		ext_phy_type = SERDES_EXT_PHY_TYPE(params->ext_phy_config);
-		switch (ext_phy_type) {
-		case PORT_HW_CFG_SERDES_EXT_PHY_TYPE_DIRECT:
-			DP(NETIF_MSG_LINK, "SerDes Direct\n");
-			break;
-
-		case PORT_HW_CFG_SERDES_EXT_PHY_TYPE_BCM5482:
-			DP(NETIF_MSG_LINK, "SerDes 5482\n");
-			break;
-
-		default:
-			DP(NETIF_MSG_LINK, "BAD SerDes ext_phy_config 0x%x\n",
-			   params->ext_phy_config);
-			break;
-		}
-	}
-	return rc;
-}
-
-static void bnx2x_8727_handle_mod_abs(struct link_params *params)
-{
-	struct bnx2x *bp = params->bp;
-	u16 mod_abs, rx_alarm_status;
-	u8 ext_phy_addr = XGXS_EXT_PHY_ADDR(params->ext_phy_config);
-	u32 val = REG_RD(bp, params->shmem_base +
-			     offsetof(struct shmem_region, dev_info.
-				      port_feature_config[params->port].
-				      config));
-	bnx2x_cl45_read(bp, params->port,
-		      PORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM8727,
-		      ext_phy_addr,
-		      MDIO_PMA_DEVAD,
-		      MDIO_PMA_REG_PHY_IDENTIFIER, &mod_abs);
-	if (mod_abs & (1<<8)) {
-
-		/* Module is absent */
-		DP(NETIF_MSG_LINK, "MOD_ABS indication "
-			    "show module is absent\n");
-
-		/* 1. Set mod_abs to detect next module
-		presence event
-		   2. Set EDC off by setting OPTXLOS signal input to low
-			(bit 9).
-			When the EDC is off it locks onto a reference clock and
-			avoids becoming 'lost'.*/
-		mod_abs &= ~((1<<8)|(1<<9));
-		bnx2x_cl45_write(bp, params->port,
-			       PORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM8727,
-			       ext_phy_addr,
-			       MDIO_PMA_DEVAD,
-			       MDIO_PMA_REG_PHY_IDENTIFIER, mod_abs);
-
-		/* Clear RX alarm since it stays up as long as
-		the mod_abs wasn't changed */
-		bnx2x_cl45_read(bp, params->port,
-			      PORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM8727,
-			      ext_phy_addr,
-			      MDIO_PMA_DEVAD,
-			      MDIO_PMA_REG_RX_ALARM, &rx_alarm_status);
-
-	} else {
-		/* Module is present */
-		DP(NETIF_MSG_LINK, "MOD_ABS indication "
-			    "show module is present\n");
-		/* First thing, disable transmitter,
-		and if the module is ok, the
-		module_detection will enable it*/
-
-		/* 1. Set mod_abs to detect next module
-		absent event ( bit 8)
-		   2. Restore the default polarity of the OPRXLOS signal and
-		this signal will then correctly indicate the presence or
-		absence of the Rx signal. (bit 9) */
-		mod_abs |= ((1<<8)|(1<<9));
-		bnx2x_cl45_write(bp, params->port,
-		       PORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM8727,
-		       ext_phy_addr,
-		       MDIO_PMA_DEVAD,
-		       MDIO_PMA_REG_PHY_IDENTIFIER, mod_abs);
-
-		/* Clear RX alarm since it stays up as long as
-		the mod_abs wasn't changed. This is need to be done
-		before calling the module detection, otherwise it will clear
-		the link update alarm */
-		bnx2x_cl45_read(bp, params->port,
-			      PORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM8727,
-			      ext_phy_addr,
-			      MDIO_PMA_DEVAD,
-			      MDIO_PMA_REG_RX_ALARM, &rx_alarm_status);
-
-
-		if ((val & PORT_FEAT_CFG_OPT_MDL_ENFRCMNT_MASK) ==
-		    PORT_FEAT_CFG_OPT_MDL_ENFRCMNT_DISABLE_TX_LASER)
-			bnx2x_sfp_set_transmitter(bp, params->port,
-					PORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM8727,
-					ext_phy_addr, 0);
-
-		if (bnx2x_wait_for_sfp_module_initialized(params)
-		    == 0)
-			bnx2x_sfp_module_detection(params);
-		else
-			DP(NETIF_MSG_LINK, "SFP+ module is not initialized\n");
-	}
-
-	DP(NETIF_MSG_LINK, "8727 RX_ALARM_STATUS 0x%x\n",
-		 rx_alarm_status);
-	/* No need to check link status in case of
-	module plugged in/out */
-}
-
-
-static u8 bnx2x_ext_phy_is_link_up(struct link_params *params,
-				 struct link_vars *vars,
-				 u8 is_mi_int)
-{
-	struct bnx2x *bp = params->bp;
-	u32 ext_phy_type;
-	u8 ext_phy_addr;
-	u16 val1 = 0, val2;
-	u16 rx_sd, pcs_status;
-	u8 ext_phy_link_up = 0;
-	u8 port = params->port;
-
-	if (vars->phy_flags & PHY_XGXS_FLAG) {
-		ext_phy_addr = XGXS_EXT_PHY_ADDR(params->ext_phy_config);
-		ext_phy_type = XGXS_EXT_PHY_TYPE(params->ext_phy_config);
-		switch (ext_phy_type) {
-		case PORT_HW_CFG_XGXS_EXT_PHY_TYPE_DIRECT:
-			DP(NETIF_MSG_LINK, "XGXS Direct\n");
-			ext_phy_link_up = 1;
-			break;
-
-		case PORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM8705:
-			DP(NETIF_MSG_LINK, "XGXS 8705\n");
-			bnx2x_cl45_read(bp, params->port, ext_phy_type,
-				      ext_phy_addr,
-				      MDIO_WIS_DEVAD,
-				      MDIO_WIS_REG_LASI_STATUS, &val1);
-			DP(NETIF_MSG_LINK, "8705 LASI status 0x%x\n", val1);
-
-			bnx2x_cl45_read(bp, params->port, ext_phy_type,
-				      ext_phy_addr,
-				      MDIO_WIS_DEVAD,
-				      MDIO_WIS_REG_LASI_STATUS, &val1);
-			DP(NETIF_MSG_LINK, "8705 LASI status 0x%x\n", val1);
-
-			bnx2x_cl45_read(bp, params->port, ext_phy_type,
-				      ext_phy_addr,
-				      MDIO_PMA_DEVAD,
-				      MDIO_PMA_REG_RX_SD, &rx_sd);
-
-			bnx2x_cl45_read(bp, params->port, ext_phy_type,
-				      ext_phy_addr,
-				      1,
-				      0xc809, &val1);
-			bnx2x_cl45_read(bp, params->port, ext_phy_type,
-				      ext_phy_addr,
-				      1,
-				      0xc809, &val1);
-
-			DP(NETIF_MSG_LINK, "8705 1.c809 val=0x%x\n", val1);
-			ext_phy_link_up = ((rx_sd & 0x1) && (val1 & (1<<9)) &&
-					   ((val1 & (1<<8)) == 0));
-			if (ext_phy_link_up)
-				vars->line_speed = SPEED_10000;
-			break;
-
-		case PORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM8706:
-		case PORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM8726:
-			DP(NETIF_MSG_LINK, "XGXS 8706/8726\n");
-			/* Clear RX Alarm*/
-			bnx2x_cl45_read(bp, params->port, ext_phy_type,
-				      ext_phy_addr,
-				      MDIO_PMA_DEVAD, MDIO_PMA_REG_RX_ALARM,
-				      &val2);
-			/* clear LASI indication*/
-			bnx2x_cl45_read(bp, params->port, ext_phy_type,
-				      ext_phy_addr,
-				      MDIO_PMA_DEVAD, MDIO_PMA_REG_LASI_STATUS,
-				      &val1);
-			bnx2x_cl45_read(bp, params->port, ext_phy_type,
-				      ext_phy_addr,
-				      MDIO_PMA_DEVAD, MDIO_PMA_REG_LASI_STATUS,
-				      &val2);
-			DP(NETIF_MSG_LINK, "8706/8726 LASI status 0x%x-->"
-				     "0x%x\n", val1, val2);
-
-			bnx2x_cl45_read(bp, params->port, ext_phy_type,
-				      ext_phy_addr,
-				      MDIO_PMA_DEVAD, MDIO_PMA_REG_RX_SD,
-				      &rx_sd);
-			bnx2x_cl45_read(bp, params->port, ext_phy_type,
-				      ext_phy_addr,
-				      MDIO_PCS_DEVAD, MDIO_PCS_REG_STATUS,
-				      &pcs_status);
-			bnx2x_cl45_read(bp, params->port, ext_phy_type,
-				      ext_phy_addr,
-				      MDIO_AN_DEVAD, MDIO_AN_REG_LINK_STATUS,
-				      &val2);
-			bnx2x_cl45_read(bp, params->port, ext_phy_type,
-				      ext_phy_addr,
-				      MDIO_AN_DEVAD, MDIO_AN_REG_LINK_STATUS,
-				      &val2);
-
-			DP(NETIF_MSG_LINK, "8706/8726 rx_sd 0x%x"
-			   "  pcs_status 0x%x 1Gbps link_status 0x%x\n",
-			   rx_sd, pcs_status, val2);
-			/* link is up if both bit 0 of pmd_rx_sd and
-			 * bit 0 of pcs_status are set, or if the autoneg bit
-			   1 is set
-			 */
-			ext_phy_link_up = ((rx_sd & pcs_status & 0x1) ||
-					   (val2 & (1<<1)));
-			if (ext_phy_link_up) {
-				if (ext_phy_type ==
-				     PORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM8726) {
-					/* If transmitter is disabled,
-					ignore false link up indication */
-					bnx2x_cl45_read(bp, params->port,
-						   ext_phy_type,
-						   ext_phy_addr,
-						   MDIO_PMA_DEVAD,
-						   MDIO_PMA_REG_PHY_IDENTIFIER,
-						   &val1);
-					if (val1 & (1<<15)) {
-						DP(NETIF_MSG_LINK, "Tx is "
-							    "disabled\n");
-						ext_phy_link_up = 0;
-						break;
-					}
-				}
-				if (val2 & (1<<1))
-					vars->line_speed = SPEED_1000;
-				else
-					vars->line_speed = SPEED_10000;
-			}
-			break;
-
-		case PORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM8727:
-		{
-			u16 link_status = 0;
-			u16 rx_alarm_status;
-			/* Check the LASI */
-			bnx2x_cl45_read(bp, params->port,
-				      ext_phy_type,
-				      ext_phy_addr,
-				      MDIO_PMA_DEVAD,
-				      MDIO_PMA_REG_RX_ALARM, &rx_alarm_status);
-
-			DP(NETIF_MSG_LINK, "8727 RX_ALARM_STATUS 0x%x\n",
-				 rx_alarm_status);
-
-			bnx2x_cl45_read(bp, params->port,
-				      ext_phy_type,
-				      ext_phy_addr,
-				      MDIO_PMA_DEVAD,
-				      MDIO_PMA_REG_LASI_STATUS, &val1);
-
-			DP(NETIF_MSG_LINK,
-				 "8727 LASI status 0x%x\n",
-				 val1);
-
-			/* Clear MSG-OUT */
-			bnx2x_cl45_read(bp, params->port,
-				      ext_phy_type,
-				      ext_phy_addr,
-				      MDIO_PMA_DEVAD,
-				      MDIO_PMA_REG_M8051_MSGOUT_REG,
-				      &val1);
-
-			/*
-			 * If a module is present and there is need to check
-			 * for over current
-			 */
-			if (!(params->feature_config_flags &
-			      FEATURE_CONFIG_BCM8727_NOC) &&
-			    !(rx_alarm_status & (1<<5))) {
-				/* Check over-current using 8727 GPIO0 input*/
-				bnx2x_cl45_read(bp, params->port,
-					      ext_phy_type,
-					      ext_phy_addr,
-					      MDIO_PMA_DEVAD,
-					      MDIO_PMA_REG_8727_GPIO_CTRL,
-					      &val1);
-
-				if ((val1 & (1<<8)) == 0) {
-					DP(NETIF_MSG_LINK, "8727 Power fault"
-						     " has been detected on "
-						     "port %d\n",
-						 params->port);
-					netdev_err(bp->dev, "Error:  Power fault on Port %d has been detected and the power to that SFP+ module has been removed to prevent failure of the card. Please remove the SFP+ module and restart the system to clear this error.\n",
-						   params->port);
-					/*
-					 * Disable all RX_ALARMs except for
-					 * mod_abs
-					 */
-					bnx2x_cl45_write(bp, params->port,
-						     ext_phy_type,
-						     ext_phy_addr,
-						     MDIO_PMA_DEVAD,
-						     MDIO_PMA_REG_RX_ALARM_CTRL,
-						     (1<<5));
-
-					bnx2x_cl45_read(bp, params->port,
-						    ext_phy_type,
-						    ext_phy_addr,
-						    MDIO_PMA_DEVAD,
-						    MDIO_PMA_REG_PHY_IDENTIFIER,
-						    &val1);
-					/* Wait for module_absent_event */
-					val1 |= (1<<8);
-					bnx2x_cl45_write(bp, params->port,
-						    ext_phy_type,
-						    ext_phy_addr,
-						    MDIO_PMA_DEVAD,
-						    MDIO_PMA_REG_PHY_IDENTIFIER,
-						    val1);
-					/* Clear RX alarm */
-					bnx2x_cl45_read(bp, params->port,
-						      ext_phy_type,
-						      ext_phy_addr,
-						      MDIO_PMA_DEVAD,
-						      MDIO_PMA_REG_RX_ALARM,
-						      &rx_alarm_status);
-					break;
-				}
-			} /* Over current check */
-
-			/* When module absent bit is set, check module */
-			if (rx_alarm_status & (1<<5)) {
-				bnx2x_8727_handle_mod_abs(params);
-				/* Enable all mod_abs and link detection bits */
-				bnx2x_cl45_write(bp, params->port,
-					       ext_phy_type,
-					       ext_phy_addr,
-					       MDIO_PMA_DEVAD,
-					       MDIO_PMA_REG_RX_ALARM_CTRL,
-					       ((1<<5) | (1<<2)));
-			}
-
-			/* If transmitter is disabled,
-			ignore false link up indication */
-			bnx2x_cl45_read(bp, params->port,
-				      ext_phy_type,
-				      ext_phy_addr,
-				      MDIO_PMA_DEVAD,
-				      MDIO_PMA_REG_PHY_IDENTIFIER,
-				      &val1);
-			if (val1 & (1<<15)) {
-				DP(NETIF_MSG_LINK, "Tx is disabled\n");
-				ext_phy_link_up = 0;
-				break;
-			}
-
-			bnx2x_cl45_read(bp, params->port,
-				      ext_phy_type,
-				      ext_phy_addr,
-				      MDIO_PMA_DEVAD,
-				      MDIO_PMA_REG_8073_SPEED_LINK_STATUS,
-				      &link_status);
-
-			/* Bits 0..2 --> speed detected,
-			   bits 13..15--> link is down */
-			if ((link_status & (1<<2)) &&
-			    (!(link_status & (1<<15)))) {
-				ext_phy_link_up = 1;
-				vars->line_speed = SPEED_10000;
-			} else if ((link_status & (1<<0)) &&
-				   (!(link_status & (1<<13)))) {
-				ext_phy_link_up = 1;
-				vars->line_speed = SPEED_1000;
-				DP(NETIF_MSG_LINK,
-					 "port %x: External link"
-					 " up in 1G\n", params->port);
-			} else {
-				ext_phy_link_up = 0;
-				DP(NETIF_MSG_LINK,
-					 "port %x: External link"
-					 " is down\n", params->port);
-			}
-			break;
-		}
-
-		case PORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM8072:
-		case PORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM8073:
-		{
-			u16 link_status = 0;
-			u16 an1000_status = 0;
-
-			if (ext_phy_type ==
-			     PORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM8072) {
-				bnx2x_cl45_read(bp, params->port,
-				      ext_phy_type,
-				      ext_phy_addr,
-				      MDIO_PCS_DEVAD,
-				      MDIO_PCS_REG_LASI_STATUS, &val1);
-			bnx2x_cl45_read(bp, params->port,
-				      ext_phy_type,
-				      ext_phy_addr,
-				      MDIO_PCS_DEVAD,
-				      MDIO_PCS_REG_LASI_STATUS, &val2);
-			DP(NETIF_MSG_LINK,
-				 "870x LASI status 0x%x->0x%x\n",
-				  val1, val2);
-			} else {
-				/* In 8073, port1 is directed through emac0 and
-				 * port0 is directed through emac1
-				 */
-				bnx2x_cl45_read(bp, params->port,
-					      ext_phy_type,
-					      ext_phy_addr,
-					      MDIO_PMA_DEVAD,
-					      MDIO_PMA_REG_LASI_STATUS, &val1);
-
-				DP(NETIF_MSG_LINK,
-					 "8703 LASI status 0x%x\n",
-					  val1);
-			}
-
-			/* clear the interrupt LASI status register */
-			bnx2x_cl45_read(bp, params->port,
-				      ext_phy_type,
-				      ext_phy_addr,
-				      MDIO_PCS_DEVAD,
-				      MDIO_PCS_REG_STATUS, &val2);
-			bnx2x_cl45_read(bp, params->port,
-				      ext_phy_type,
-				      ext_phy_addr,
-				      MDIO_PCS_DEVAD,
-				      MDIO_PCS_REG_STATUS, &val1);
-			DP(NETIF_MSG_LINK, "807x PCS status 0x%x->0x%x\n",
-			   val2, val1);
-			/* Clear MSG-OUT */
-			bnx2x_cl45_read(bp, params->port,
-				      ext_phy_type,
-				      ext_phy_addr,
-				      MDIO_PMA_DEVAD,
-				      MDIO_PMA_REG_M8051_MSGOUT_REG,
-				      &val1);
-
-			/* Check the LASI */
-			bnx2x_cl45_read(bp, params->port,
-				      ext_phy_type,
-				      ext_phy_addr,
-				      MDIO_PMA_DEVAD,
-				      MDIO_PMA_REG_RX_ALARM, &val2);
-
-			DP(NETIF_MSG_LINK, "KR 0x9003 0x%x\n", val2);
-
-			/* Check the link status */
-			bnx2x_cl45_read(bp, params->port,
-				      ext_phy_type,
-				      ext_phy_addr,
-				      MDIO_PCS_DEVAD,
-				      MDIO_PCS_REG_STATUS, &val2);
-			DP(NETIF_MSG_LINK, "KR PCS status 0x%x\n", val2);
-
-			bnx2x_cl45_read(bp, params->port,
-				      ext_phy_type,
-				      ext_phy_addr,
-				      MDIO_PMA_DEVAD,
-				      MDIO_PMA_REG_STATUS, &val2);
-			bnx2x_cl45_read(bp, params->port,
-				      ext_phy_type,
-				      ext_phy_addr,
-				      MDIO_PMA_DEVAD,
-				      MDIO_PMA_REG_STATUS, &val1);
-			ext_phy_link_up = ((val1 & 4) == 4);
-			DP(NETIF_MSG_LINK, "PMA_REG_STATUS=0x%x\n", val1);
-			if (ext_phy_type ==
-			    PORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM8073) {
-
-				if (ext_phy_link_up &&
-				    ((params->req_line_speed !=
-					SPEED_10000))) {
-					if (bnx2x_bcm8073_xaui_wa(params)
-					     != 0) {
-						ext_phy_link_up = 0;
-						break;
-					}
-				}
-				bnx2x_cl45_read(bp, params->port,
-					      ext_phy_type,
-					      ext_phy_addr,
-					      MDIO_AN_DEVAD,
-					      MDIO_AN_REG_LINK_STATUS,
-					      &an1000_status);
-				bnx2x_cl45_read(bp, params->port,
-					      ext_phy_type,
-					      ext_phy_addr,
-					      MDIO_AN_DEVAD,
-					      MDIO_AN_REG_LINK_STATUS,
-					      &an1000_status);
-
-				/* Check the link status on 1.1.2 */
-				bnx2x_cl45_read(bp, params->port,
-					      ext_phy_type,
-					      ext_phy_addr,
-					      MDIO_PMA_DEVAD,
-					      MDIO_PMA_REG_STATUS, &val2);
-				bnx2x_cl45_read(bp, params->port,
-					      ext_phy_type,
-					      ext_phy_addr,
-					      MDIO_PMA_DEVAD,
-					      MDIO_PMA_REG_STATUS, &val1);
-				DP(NETIF_MSG_LINK, "KR PMA status 0x%x->0x%x,"
-					     "an_link_status=0x%x\n",
-					  val2, val1, an1000_status);
-
-				ext_phy_link_up = (((val1 & 4) == 4) ||
-						(an1000_status & (1<<1)));
-				if (ext_phy_link_up &&
-				    bnx2x_8073_is_snr_needed(params)) {
-					/* The SNR will improve about 2dbby
-					changing the BW and FEE main tap.*/
-
-					/* The 1st write to change FFE main
-					tap is set before restart AN */
-					/* Change PLL Bandwidth in EDC
-					register */
-					bnx2x_cl45_write(bp, port, ext_phy_type,
-						    ext_phy_addr,
-						    MDIO_PMA_DEVAD,
-						    MDIO_PMA_REG_PLL_BANDWIDTH,
-						    0x26BC);
-
-					/* Change CDR Bandwidth in EDC
-					register */
-					bnx2x_cl45_write(bp, port, ext_phy_type,
-						    ext_phy_addr,
-						    MDIO_PMA_DEVAD,
-						    MDIO_PMA_REG_CDR_BANDWIDTH,
-						    0x0333);
-				}
-				bnx2x_cl45_read(bp, params->port,
-					   ext_phy_type,
-					   ext_phy_addr,
-					   MDIO_PMA_DEVAD,
-					   MDIO_PMA_REG_8073_SPEED_LINK_STATUS,
-					   &link_status);
-
-				/* Bits 0..2 --> speed detected,
-				   bits 13..15--> link is down */
-				if ((link_status & (1<<2)) &&
-				    (!(link_status & (1<<15)))) {
-					ext_phy_link_up = 1;
-					vars->line_speed = SPEED_10000;
-					DP(NETIF_MSG_LINK,
-						 "port %x: External link"
-						 " up in 10G\n", params->port);
-				} else if ((link_status & (1<<1)) &&
-					   (!(link_status & (1<<14)))) {
-					ext_phy_link_up = 1;
-					vars->line_speed = SPEED_2500;
-					DP(NETIF_MSG_LINK,
-						 "port %x: External link"
-						 " up in 2.5G\n", params->port);
-				} else if ((link_status & (1<<0)) &&
-					   (!(link_status & (1<<13)))) {
-					ext_phy_link_up = 1;
-					vars->line_speed = SPEED_1000;
-					DP(NETIF_MSG_LINK,
-						 "port %x: External link"
-						 " up in 1G\n", params->port);
-				} else {
-					ext_phy_link_up = 0;
-					DP(NETIF_MSG_LINK,
-						 "port %x: External link"
-						 " is down\n", params->port);
-				}
-			} else {
-				/* See if 1G link is up for the 8072 */
-				bnx2x_cl45_read(bp, params->port,
-					      ext_phy_type,
-					      ext_phy_addr,
-					      MDIO_AN_DEVAD,
-					      MDIO_AN_REG_LINK_STATUS,
-					      &an1000_status);
-				bnx2x_cl45_read(bp, params->port,
-					      ext_phy_type,
-					      ext_phy_addr,
-					      MDIO_AN_DEVAD,
-					      MDIO_AN_REG_LINK_STATUS,
-					      &an1000_status);
-				if (an1000_status & (1<<1)) {
-					ext_phy_link_up = 1;
-					vars->line_speed = SPEED_1000;
-					DP(NETIF_MSG_LINK,
-						 "port %x: External link"
-						 " up in 1G\n", params->port);
-				} else if (ext_phy_link_up) {
-					ext_phy_link_up = 1;
-					vars->line_speed = SPEED_10000;
-					DP(NETIF_MSG_LINK,
-						 "port %x: External link"
-						 " up in 10G\n", params->port);
-				}
-			}
-
-
-			break;
-		}
-		case PORT_HW_CFG_XGXS_EXT_PHY_TYPE_SFX7101:
-			bnx2x_cl45_read(bp, params->port, ext_phy_type,
-				      ext_phy_addr,
-				      MDIO_PMA_DEVAD,
-				      MDIO_PMA_REG_LASI_STATUS, &val2);
-			bnx2x_cl45_read(bp, params->port, ext_phy_type,
-				      ext_phy_addr,
-				      MDIO_PMA_DEVAD,
-				      MDIO_PMA_REG_LASI_STATUS, &val1);
-			DP(NETIF_MSG_LINK,
-				 "10G-base-T LASI status 0x%x->0x%x\n",
-				  val2, val1);
-			bnx2x_cl45_read(bp, params->port, ext_phy_type,
-				      ext_phy_addr,
-				      MDIO_PMA_DEVAD,
-				      MDIO_PMA_REG_STATUS, &val2);
-			bnx2x_cl45_read(bp, params->port, ext_phy_type,
-				      ext_phy_addr,
-				      MDIO_PMA_DEVAD,
-				      MDIO_PMA_REG_STATUS, &val1);
-			DP(NETIF_MSG_LINK,
-				 "10G-base-T PMA status 0x%x->0x%x\n",
-				 val2, val1);
-			ext_phy_link_up = ((val1 & 4) == 4);
-			/* if link is up
-			 * print the AN outcome of the SFX7101 PHY
-			 */
-			if (ext_phy_link_up) {
-				bnx2x_cl45_read(bp, params->port,
-					      ext_phy_type,
-					      ext_phy_addr,
-					      MDIO_AN_DEVAD,
-					      MDIO_AN_REG_MASTER_STATUS,
-					      &val2);
-				vars->line_speed = SPEED_10000;
-				DP(NETIF_MSG_LINK,
-					 "SFX7101 AN status 0x%x->Master=%x\n",
-					  val2,
-					 (val2 & (1<<14)));
-			}
-			break;
-		case PORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM8481:
-		case PORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM84823:
-			/* Check 10G-BaseT link status */
-			/* Check PMD signal ok */
-			bnx2x_cl45_read(bp, params->port, ext_phy_type,
-						      ext_phy_addr,
-						      MDIO_AN_DEVAD,
-						      0xFFFA,
-						      &val1);
-			bnx2x_cl45_read(bp, params->port, ext_phy_type,
-				      ext_phy_addr,
-				      MDIO_PMA_DEVAD,
-				      MDIO_PMA_REG_8481_PMD_SIGNAL,
-				      &val2);
-			DP(NETIF_MSG_LINK, "PMD_SIGNAL 1.a811 = 0x%x\n", val2);
-
-			/* Check link 10G */
-			if (val2 & (1<<11)) {
-				vars->line_speed = SPEED_10000;
-				ext_phy_link_up = 1;
-				bnx2x_8481_set_10G_led_mode(params,
-							  ext_phy_type,
-							  ext_phy_addr);
-			} else { /* Check Legacy speed link */
-				u16 legacy_status, legacy_speed;
-
-				/* Enable expansion register 0x42
-				(Operation mode status) */
-				bnx2x_cl45_write(bp, params->port,
-					 ext_phy_type,
-					 ext_phy_addr,
-					 MDIO_AN_DEVAD,
-					 MDIO_AN_REG_8481_EXPANSION_REG_ACCESS,
-					 0xf42);
-
-				/* Get legacy speed operation status */
-				bnx2x_cl45_read(bp, params->port,
-					  ext_phy_type,
-					  ext_phy_addr,
-					  MDIO_AN_DEVAD,
-					  MDIO_AN_REG_8481_EXPANSION_REG_RD_RW,
-					  &legacy_status);
-
-				DP(NETIF_MSG_LINK, "Legacy speed status"
-					     " = 0x%x\n", legacy_status);
-				ext_phy_link_up = ((legacy_status & (1<<11))
-						   == (1<<11));
-				if (ext_phy_link_up) {
-					legacy_speed = (legacy_status & (3<<9));
-					if (legacy_speed == (0<<9))
-						vars->line_speed = SPEED_10;
-					else if (legacy_speed == (1<<9))
-						vars->line_speed =
-							SPEED_100;
-					else if (legacy_speed == (2<<9))
-						vars->line_speed =
-							SPEED_1000;
-					else /* Should not happen */
-						vars->line_speed = 0;
-
-					if (legacy_status & (1<<8))
-						vars->duplex = DUPLEX_FULL;
-					else
-						vars->duplex = DUPLEX_HALF;
-
-					DP(NETIF_MSG_LINK, "Link is up "
-						     "in %dMbps, is_duplex_full"
-						     "= %d\n",
-						vars->line_speed,
-						(vars->duplex == DUPLEX_FULL));
-					bnx2x_8481_set_legacy_led_mode(params,
-								 ext_phy_type,
-								 ext_phy_addr);
-				}
-			}
-			break;
-		default:
-			DP(NETIF_MSG_LINK, "BAD XGXS ext_phy_config 0x%x\n",
-			   params->ext_phy_config);
-			ext_phy_link_up = 0;
-			break;
-		}
-		/* Set SGMII mode for external phy */
-		if (ext_phy_type != PORT_HW_CFG_XGXS_EXT_PHY_TYPE_DIRECT) {
-			if (vars->line_speed < SPEED_1000)
-				vars->phy_flags |= PHY_SGMII_FLAG;
-			else
-				vars->phy_flags &= ~PHY_SGMII_FLAG;
-		}
-
-	} else { /* SerDes */
-		ext_phy_type = SERDES_EXT_PHY_TYPE(params->ext_phy_config);
-		switch (ext_phy_type) {
-		case PORT_HW_CFG_SERDES_EXT_PHY_TYPE_DIRECT:
-			DP(NETIF_MSG_LINK, "SerDes Direct\n");
-			ext_phy_link_up = 1;
-			break;
-
-		case PORT_HW_CFG_SERDES_EXT_PHY_TYPE_BCM5482:
-			DP(NETIF_MSG_LINK, "SerDes 5482\n");
-			ext_phy_link_up = 1;
-			break;
-
-		default:
-			DP(NETIF_MSG_LINK,
-				 "BAD SerDes ext_phy_config 0x%x\n",
-				 params->ext_phy_config);
-			ext_phy_link_up = 0;
-			break;
-		}
-	}
-
-	return ext_phy_link_up;
-}
-
-static void bnx2x_link_int_enable(struct link_params *params)
-{
-	u8 port = params->port;
-	u32 ext_phy_type;
-	u32 mask;
-	struct bnx2x *bp = params->bp;
-
-	/* setting the status to report on link up
-	   for either XGXS or SerDes */
-
-	if (params->switch_cfg == SWITCH_CFG_10G) {
-		mask = (NIG_MASK_XGXS0_LINK10G |
-			NIG_MASK_XGXS0_LINK_STATUS);
-		DP(NETIF_MSG_LINK, "enabled XGXS interrupt\n");
-		ext_phy_type = XGXS_EXT_PHY_TYPE(params->ext_phy_config);
-		if ((ext_phy_type != PORT_HW_CFG_XGXS_EXT_PHY_TYPE_DIRECT) &&
-		    (ext_phy_type != PORT_HW_CFG_XGXS_EXT_PHY_TYPE_FAILURE) &&
-		    (ext_phy_type !=
-				PORT_HW_CFG_XGXS_EXT_PHY_TYPE_NOT_CONN)) {
-			mask |= NIG_MASK_MI_INT;
-			DP(NETIF_MSG_LINK, "enabled external phy int\n");
-		}
-
-	} else { /* SerDes */
-		mask = NIG_MASK_SERDES0_LINK_STATUS;
-		DP(NETIF_MSG_LINK, "enabled SerDes interrupt\n");
-		ext_phy_type = SERDES_EXT_PHY_TYPE(params->ext_phy_config);
-		if ((ext_phy_type !=
-				PORT_HW_CFG_SERDES_EXT_PHY_TYPE_DIRECT) &&
-		    (ext_phy_type !=
-				PORT_HW_CFG_SERDES_EXT_PHY_TYPE_NOT_CONN)) {
-			mask |= NIG_MASK_MI_INT;
-			DP(NETIF_MSG_LINK, "enabled external phy int\n");
-		}
-	}
-	bnx2x_bits_en(bp,
-		      NIG_REG_MASK_INTERRUPT_PORT0 + port*4,
-		      mask);
-
-	DP(NETIF_MSG_LINK, "port %x, is_xgxs %x, int_status 0x%x\n", port,
-		 (params->switch_cfg == SWITCH_CFG_10G),
-		 REG_RD(bp, NIG_REG_STATUS_INTERRUPT_PORT0 + port*4));
-	DP(NETIF_MSG_LINK, " int_mask 0x%x, MI_INT %x, SERDES_LINK %x\n",
-		 REG_RD(bp, NIG_REG_MASK_INTERRUPT_PORT0 + port*4),
-		 REG_RD(bp, NIG_REG_EMAC0_STATUS_MISC_MI_INT + port*0x18),
-		 REG_RD(bp, NIG_REG_SERDES0_STATUS_LINK_STATUS+port*0x3c));
-	DP(NETIF_MSG_LINK, " 10G %x, XGXS_LINK %x\n",
-	   REG_RD(bp, NIG_REG_XGXS0_STATUS_LINK10G + port*0x68),
-	   REG_RD(bp, NIG_REG_XGXS0_STATUS_LINK_STATUS + port*0x68));
-}
-
-static void bnx2x_8481_rearm_latch_signal(struct bnx2x *bp, u8 port,
-					u8 is_mi_int)
-{
-	u32 latch_status = 0, is_mi_int_status;
-	/* Disable the MI INT ( external phy int )
-	 * by writing 1 to the status register. Link down indication
-	 * is high-active-signal, so in this case we need to write the
-	 * status to clear the XOR
-	 */
-	/* Read Latched signals */
-	latch_status = REG_RD(bp,
-				  NIG_REG_LATCH_STATUS_0 + port*8);
-	is_mi_int_status = REG_RD(bp,
-				  NIG_REG_STATUS_INTERRUPT_PORT0 + port*4);
-	DP(NETIF_MSG_LINK, "original_signal = 0x%x, nig_status = 0x%x,"
-		     "latch_status = 0x%x\n",
-		 is_mi_int, is_mi_int_status, latch_status);
-	/* Handle only those with latched-signal=up.*/
-	if (latch_status & 1) {
-		/* For all latched-signal=up,Write original_signal to status */
-		if (is_mi_int)
-			bnx2x_bits_en(bp,
-				    NIG_REG_STATUS_INTERRUPT_PORT0
-				    + port*4,
-				    NIG_STATUS_EMAC0_MI_INT);
-		else
-			bnx2x_bits_dis(bp,
-				     NIG_REG_STATUS_INTERRUPT_PORT0
-				     + port*4,
-				     NIG_STATUS_EMAC0_MI_INT);
-		/* For all latched-signal=up : Re-Arm Latch signals */
-		REG_WR(bp, NIG_REG_LATCH_STATUS_0 + port*8,
-			   (latch_status & 0xfffe) | (latch_status & 1));
-	}
-}
-/*
- * link management
- */
-static void bnx2x_link_int_ack(struct link_params *params,
-			     struct link_vars *vars, u8 is_10g,
-			     u8 is_mi_int)
-{
-	struct bnx2x *bp = params->bp;
-	u8 port = params->port;
-
-	/* first reset all status
-	 * we assume only one line will be change at a time */
-	bnx2x_bits_dis(bp, NIG_REG_STATUS_INTERRUPT_PORT0 + port*4,
-		     (NIG_STATUS_XGXS0_LINK10G |
-		      NIG_STATUS_XGXS0_LINK_STATUS |
-		      NIG_STATUS_SERDES0_LINK_STATUS));
-	if ((XGXS_EXT_PHY_TYPE(params->ext_phy_config)
-		== PORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM8481) ||
-	(XGXS_EXT_PHY_TYPE(params->ext_phy_config)
-		== PORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM84823)) {
-		bnx2x_8481_rearm_latch_signal(bp, port, is_mi_int);
-	}
-	if (vars->phy_link_up) {
-		if (is_10g) {
-			/* Disable the 10G link interrupt
-			 * by writing 1 to the status register
-			 */
-			DP(NETIF_MSG_LINK, "10G XGXS phy link up\n");
-			bnx2x_bits_en(bp,
-				      NIG_REG_STATUS_INTERRUPT_PORT0 + port*4,
-				      NIG_STATUS_XGXS0_LINK10G);
-
-		} else if (params->switch_cfg == SWITCH_CFG_10G) {
-			/* Disable the link interrupt
-			 * by writing 1 to the relevant lane
-			 * in the status register
-			 */
-			u32 ser_lane = ((params->lane_config &
-				    PORT_HW_CFG_LANE_SWAP_CFG_MASTER_MASK) >>
-				    PORT_HW_CFG_LANE_SWAP_CFG_MASTER_SHIFT);
-
-			DP(NETIF_MSG_LINK, "%d speed XGXS phy link up\n",
-				 vars->line_speed);
-			bnx2x_bits_en(bp,
-				      NIG_REG_STATUS_INTERRUPT_PORT0 + port*4,
-				      ((1 << ser_lane) <<
-				       NIG_STATUS_XGXS0_LINK_STATUS_SIZE));
-
-		} else { /* SerDes */
-			DP(NETIF_MSG_LINK, "SerDes phy link up\n");
-			/* Disable the link interrupt
-			 * by writing 1 to the status register
-			 */
-			bnx2x_bits_en(bp,
-				      NIG_REG_STATUS_INTERRUPT_PORT0 + port*4,
-				      NIG_STATUS_SERDES0_LINK_STATUS);
-		}
-
-	} else { /* link_down */
-	}
-}
-
-static u8 bnx2x_format_ver(u32 num, u8 *str, u16 len)
-{
-	u8 *str_ptr = str;
-	u32 mask = 0xf0000000;
-	u8 shift = 8*4;
-	u8 digit;
-	if (len < 10) {
-		/* Need more than 10chars for this format */
-		*str_ptr = '\0';
-		return -EINVAL;
-	}
-	while (shift > 0) {
-
-		shift -= 4;
-		digit = ((num & mask) >> shift);
-		if (digit < 0xa)
-			*str_ptr = digit + '0';
-		else
-			*str_ptr = digit - 0xa + 'a';
-		str_ptr++;
-		mask = mask >> 4;
-		if (shift == 4*4) {
-			*str_ptr = ':';
-			str_ptr++;
-		}
-	}
-	*str_ptr = '\0';
-	return 0;
-}
-
-u8 bnx2x_get_ext_phy_fw_version(struct link_params *params, u8 driver_loaded,
-			      u8 *version, u16 len)
-{
-	struct bnx2x *bp;
-	u32 ext_phy_type = 0;
-	u32 spirom_ver = 0;
-	u8 status;
-
-	if (version == NULL || params == NULL)
-		return -EINVAL;
-	bp = params->bp;
-
-	spirom_ver = REG_RD(bp, params->shmem_base +
-		   offsetof(struct shmem_region,
-			    port_mb[params->port].ext_phy_fw_version));
-
-	status = 0;
-	/* reset the returned value to zero */
-	ext_phy_type = XGXS_EXT_PHY_TYPE(params->ext_phy_config);
-	switch (ext_phy_type) {
-	case PORT_HW_CFG_XGXS_EXT_PHY_TYPE_SFX7101:
-
-		if (len < 5)
-			return -EINVAL;
-
-		version[0] = (spirom_ver & 0xFF);
-		version[1] = (spirom_ver & 0xFF00) >> 8;
-		version[2] = (spirom_ver & 0xFF0000) >> 16;
-		version[3] = (spirom_ver & 0xFF000000) >> 24;
-		version[4] = '\0';
-
-		break;
-	case PORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM8072:
-	case PORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM8073:
-	case PORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM8727:
-	case PORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM8706:
-	case PORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM8726:
-		status = bnx2x_format_ver(spirom_ver, version, len);
-		break;
-	case PORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM8481:
-	case PORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM84823:
-		spirom_ver = ((spirom_ver & 0xF80) >> 7) << 16 |
-			(spirom_ver & 0x7F);
-		status = bnx2x_format_ver(spirom_ver, version, len);
-		break;
-	case PORT_HW_CFG_XGXS_EXT_PHY_TYPE_DIRECT:
-	case PORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM8705:
-		version[0] = '\0';
-		break;
-
-	case PORT_HW_CFG_XGXS_EXT_PHY_TYPE_FAILURE:
-		DP(NETIF_MSG_LINK, "bnx2x_get_ext_phy_fw_version:"
-				    " type is FAILURE!\n");
-		status = -EINVAL;
-		break;
-
-	default:
-		break;
-	}
-	return status;
-}
-
-static void bnx2x_set_xgxs_loopback(struct link_params *params,
-				  struct link_vars *vars,
-				  u8 is_10g)
-{
-	u8 port = params->port;
-	struct bnx2x *bp = params->bp;
-
-	if (is_10g) {
-		u32 md_devad;
-
-		DP(NETIF_MSG_LINK, "XGXS 10G loopback enable\n");
-
-		/* change the uni_phy_addr in the nig */
-		md_devad = REG_RD(bp, (NIG_REG_XGXS0_CTRL_MD_DEVAD +
-					  port*0x18));
-
-		REG_WR(bp, NIG_REG_XGXS0_CTRL_MD_DEVAD + port*0x18, 0x5);
-
-		bnx2x_cl45_write(bp, port, 0,
-			       params->phy_addr,
-			       5,
-			       (MDIO_REG_BANK_AER_BLOCK +
-				(MDIO_AER_BLOCK_AER_REG & 0xf)),
-			       0x2800);
-
-		bnx2x_cl45_write(bp, port, 0,
-			       params->phy_addr,
-			       5,
-			       (MDIO_REG_BANK_CL73_IEEEB0 +
-				(MDIO_CL73_IEEEB0_CL73_AN_CONTROL & 0xf)),
-			       0x6041);
-		msleep(200);
-		/* set aer mmd back */
-		bnx2x_set_aer_mmd(params, vars);
-
-		/* and md_devad */
-		REG_WR(bp, NIG_REG_XGXS0_CTRL_MD_DEVAD + port*0x18,
-			    md_devad);
-
-	} else {
-		u16 mii_control;
-
-		DP(NETIF_MSG_LINK, "XGXS 1G loopback enable\n");
-
-		CL45_RD_OVER_CL22(bp, port,
-				      params->phy_addr,
-				      MDIO_REG_BANK_COMBO_IEEE0,
-				      MDIO_COMBO_IEEE0_MII_CONTROL,
-				      &mii_control);
-
-		CL45_WR_OVER_CL22(bp, port,
-				      params->phy_addr,
-				      MDIO_REG_BANK_COMBO_IEEE0,
-				      MDIO_COMBO_IEEE0_MII_CONTROL,
-				      (mii_control |
-				       MDIO_COMBO_IEEO_MII_CONTROL_LOOPBACK));
-	}
-}
-
-
-static void bnx2x_ext_phy_loopback(struct link_params *params)
-{
-	struct bnx2x *bp = params->bp;
-	u8 ext_phy_addr;
-	u32 ext_phy_type;
-
-	if (params->switch_cfg == SWITCH_CFG_10G) {
-		ext_phy_type = XGXS_EXT_PHY_TYPE(params->ext_phy_config);
-		ext_phy_addr = XGXS_EXT_PHY_ADDR(params->ext_phy_config);
-		/* CL37 Autoneg Enabled */
-		switch (ext_phy_type) {
-		case PORT_HW_CFG_XGXS_EXT_PHY_TYPE_DIRECT:
-		case PORT_HW_CFG_XGXS_EXT_PHY_TYPE_NOT_CONN:
-			DP(NETIF_MSG_LINK,
-				"ext_phy_loopback: We should not get here\n");
-			break;
-		case PORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM8705:
-			DP(NETIF_MSG_LINK, "ext_phy_loopback: 8705\n");
-			break;
-		case PORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM8706:
-			DP(NETIF_MSG_LINK, "ext_phy_loopback: 8706\n");
-			break;
-		case PORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM8726:
-			DP(NETIF_MSG_LINK, "PMA/PMD ext_phy_loopback: 8726\n");
-			bnx2x_cl45_write(bp, params->port, ext_phy_type,
-				       ext_phy_addr,
-				       MDIO_PMA_DEVAD,
-				       MDIO_PMA_REG_CTRL,
-				       0x0001);
-			break;
-		case PORT_HW_CFG_XGXS_EXT_PHY_TYPE_SFX7101:
-			/* SFX7101_XGXS_TEST1 */
-			bnx2x_cl45_write(bp, params->port, ext_phy_type,
-				       ext_phy_addr,
-				       MDIO_XS_DEVAD,
-				       MDIO_XS_SFX7101_XGXS_TEST1,
-				       0x100);
-			DP(NETIF_MSG_LINK,
-				"ext_phy_loopback: set ext phy loopback\n");
-			break;
-		case PORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM8072:
-
-			break;
-		} /* switch external PHY type */
-	} else {
-		/* serdes */
-		ext_phy_type = SERDES_EXT_PHY_TYPE(params->ext_phy_config);
-		ext_phy_addr = (params->ext_phy_config  &
-		PORT_HW_CFG_SERDES_EXT_PHY_ADDR_MASK)
-		>> PORT_HW_CFG_SERDES_EXT_PHY_ADDR_SHIFT;
-	}
-}
-
-
-/*
- *------------------------------------------------------------------------
- * bnx2x_override_led_value -
- *
- * Override the led value of the requsted led
- *
- *------------------------------------------------------------------------
- */
-u8 bnx2x_override_led_value(struct bnx2x *bp, u8 port,
-			  u32 led_idx, u32 value)
-{
-	u32 reg_val;
-
-	/* If port 0 then use EMAC0, else use EMAC1*/
-	u32 emac_base = (port) ? GRCBASE_EMAC1 : GRCBASE_EMAC0;
-
-	DP(NETIF_MSG_LINK,
-		 "bnx2x_override_led_value() port %x led_idx %d value %d\n",
-		 port, led_idx, value);
-
-	switch (led_idx) {
-	case 0: /* 10MB led */
-		/* Read the current value of the LED register in
-		the EMAC block */
-		reg_val = REG_RD(bp, emac_base + EMAC_REG_EMAC_LED);
-		/* Set the OVERRIDE bit to 1 */
-		reg_val |= EMAC_LED_OVERRIDE;
-		/* If value is 1, set the 10M_OVERRIDE bit,
-		otherwise reset it.*/
-		reg_val = (value == 1) ? (reg_val | EMAC_LED_10MB_OVERRIDE) :
-			(reg_val & ~EMAC_LED_10MB_OVERRIDE);
-		REG_WR(bp, emac_base + EMAC_REG_EMAC_LED, reg_val);
-		break;
-	case 1: /*100MB led    */
-		/*Read the current value of the LED register in
-		the EMAC block */
-		reg_val = REG_RD(bp, emac_base + EMAC_REG_EMAC_LED);
-		/*  Set the OVERRIDE bit to 1 */
-		reg_val |= EMAC_LED_OVERRIDE;
-		/*  If value is 1, set the 100M_OVERRIDE bit,
-		otherwise reset it.*/
-		reg_val = (value == 1) ? (reg_val | EMAC_LED_100MB_OVERRIDE) :
-			(reg_val & ~EMAC_LED_100MB_OVERRIDE);
-		REG_WR(bp, emac_base + EMAC_REG_EMAC_LED, reg_val);
-		break;
-	case 2: /* 1000MB led */
-		/* Read the current value of the LED register in the
-		EMAC block */
-		reg_val = REG_RD(bp, emac_base + EMAC_REG_EMAC_LED);
-		/* Set the OVERRIDE bit to 1 */
-		reg_val |= EMAC_LED_OVERRIDE;
-		/* If value is 1, set the 1000M_OVERRIDE bit, otherwise
-		reset it. */
-		reg_val = (value == 1) ? (reg_val | EMAC_LED_1000MB_OVERRIDE) :
-			(reg_val & ~EMAC_LED_1000MB_OVERRIDE);
-		REG_WR(bp, emac_base + EMAC_REG_EMAC_LED, reg_val);
-		break;
-	case 3: /* 2500MB led */
-		/*  Read the current value of the LED register in the
-		EMAC block*/
-		reg_val = REG_RD(bp, emac_base + EMAC_REG_EMAC_LED);
-		/* Set the OVERRIDE bit to 1 */
-		reg_val |= EMAC_LED_OVERRIDE;
-		/*  If value is 1, set the 2500M_OVERRIDE bit, otherwise
-		reset it.*/
-		reg_val = (value == 1) ? (reg_val | EMAC_LED_2500MB_OVERRIDE) :
-			(reg_val & ~EMAC_LED_2500MB_OVERRIDE);
-		REG_WR(bp, emac_base + EMAC_REG_EMAC_LED, reg_val);
-		break;
-	case 4: /*10G led */
-		if (port == 0) {
-			REG_WR(bp, NIG_REG_LED_10G_P0,
-				    value);
-		} else {
-			REG_WR(bp, NIG_REG_LED_10G_P1,
-				    value);
-		}
-		break;
-	case 5: /* TRAFFIC led */
-		/* Find if the traffic control is via BMAC or EMAC */
-		if (port == 0)
-			reg_val = REG_RD(bp, NIG_REG_NIG_EMAC0_EN);
-		else
-			reg_val = REG_RD(bp, NIG_REG_NIG_EMAC1_EN);
-
-		/*  Override the traffic led in the EMAC:*/
-		if (reg_val == 1) {
-			/* Read the current value of the LED register in
-			the EMAC block */
-			reg_val = REG_RD(bp, emac_base +
-					     EMAC_REG_EMAC_LED);
-			/* Set the TRAFFIC_OVERRIDE bit to 1 */
-			reg_val |= EMAC_LED_OVERRIDE;
-			/* If value is 1, set the TRAFFIC bit, otherwise
-			reset it.*/
-			reg_val = (value == 1) ? (reg_val | EMAC_LED_TRAFFIC) :
-				(reg_val & ~EMAC_LED_TRAFFIC);
-			REG_WR(bp, emac_base + EMAC_REG_EMAC_LED, reg_val);
-		} else { /* Override the traffic led in the BMAC: */
-			REG_WR(bp, NIG_REG_LED_CONTROL_OVERRIDE_TRAFFIC_P0
-				   + port*4, 1);
-			REG_WR(bp, NIG_REG_LED_CONTROL_TRAFFIC_P0 + port*4,
-				    value);
-		}
-		break;
-	default:
-		DP(NETIF_MSG_LINK,
-			 "bnx2x_override_led_value() unknown led index %d "
-			 "(should be 0-5)\n", led_idx);
-		return -EINVAL;
-	}
-
-	return 0;
-}
-
-
-u8 bnx2x_set_led(struct link_params *params, u8 mode, u32 speed)
-{
-	u8 port = params->port;
-	u16 hw_led_mode = params->hw_led_mode;
-	u8 rc = 0;
-	u32 tmp;
-	u32 emac_base = port ? GRCBASE_EMAC1 : GRCBASE_EMAC0;
-	u32 ext_phy_type = XGXS_EXT_PHY_TYPE(params->ext_phy_config);
-	struct bnx2x *bp = params->bp;
-	DP(NETIF_MSG_LINK, "bnx2x_set_led: port %x, mode %d\n", port, mode);
-	DP(NETIF_MSG_LINK, "speed 0x%x, hw_led_mode 0x%x\n",
-		 speed, hw_led_mode);
-	switch (mode) {
-	case LED_MODE_OFF:
-		REG_WR(bp, NIG_REG_LED_10G_P0 + port*4, 0);
-		REG_WR(bp, NIG_REG_LED_MODE_P0 + port*4,
-			   SHARED_HW_CFG_LED_MAC1);
-
-		tmp = EMAC_RD(bp, EMAC_REG_EMAC_LED);
-		EMAC_WR(bp, EMAC_REG_EMAC_LED, (tmp | EMAC_LED_OVERRIDE));
-		break;
-
-	case LED_MODE_OPER:
-		if (ext_phy_type == PORT_HW_CFG_XGXS_EXT_PHY_TYPE_DIRECT) {
-			REG_WR(bp, NIG_REG_LED_MODE_P0 + port*4, 0);
-			REG_WR(bp, NIG_REG_LED_10G_P0 + port*4, 1);
-		} else {
-			REG_WR(bp, NIG_REG_LED_MODE_P0 + port*4,
-				   hw_led_mode);
-		}
-
-		REG_WR(bp, NIG_REG_LED_CONTROL_OVERRIDE_TRAFFIC_P0 +
-			   port*4, 0);
-		/* Set blinking rate to ~15.9Hz */
-		REG_WR(bp, NIG_REG_LED_CONTROL_BLINK_RATE_P0 + port*4,
-			   LED_BLINK_RATE_VAL);
-		REG_WR(bp, NIG_REG_LED_CONTROL_BLINK_RATE_ENA_P0 +
-			   port*4, 1);
-		tmp = EMAC_RD(bp, EMAC_REG_EMAC_LED);
-		EMAC_WR(bp, EMAC_REG_EMAC_LED,
-			    (tmp & (~EMAC_LED_OVERRIDE)));
-
-		if (CHIP_IS_E1(bp) &&
-		    ((speed == SPEED_2500) ||
-		     (speed == SPEED_1000) ||
-		     (speed == SPEED_100) ||
-		     (speed == SPEED_10))) {
-			/* On Everest 1 Ax chip versions for speeds less than
-			10G LED scheme is different */
-			REG_WR(bp, NIG_REG_LED_CONTROL_OVERRIDE_TRAFFIC_P0
-				   + port*4, 1);
-			REG_WR(bp, NIG_REG_LED_CONTROL_TRAFFIC_P0 +
-				   port*4, 0);
-			REG_WR(bp, NIG_REG_LED_CONTROL_BLINK_TRAFFIC_P0 +
-				   port*4, 1);
-		}
-		break;
-
-	default:
-		rc = -EINVAL;
-		DP(NETIF_MSG_LINK, "bnx2x_set_led: Invalid led mode %d\n",
-			 mode);
-		break;
-	}
-	return rc;
-
-}
-
-u8 bnx2x_test_link(struct link_params *params, struct link_vars *vars)
-{
-	struct bnx2x *bp = params->bp;
-	u16 gp_status = 0;
-
-	CL45_RD_OVER_CL22(bp, params->port,
-			      params->phy_addr,
-			      MDIO_REG_BANK_GP_STATUS,
-			      MDIO_GP_STATUS_TOP_AN_STATUS1,
-			      &gp_status);
-	/* link is up only if both local phy and external phy are up */
-	if ((gp_status & MDIO_GP_STATUS_TOP_AN_STATUS1_LINK_STATUS) &&
-	    bnx2x_ext_phy_is_link_up(params, vars, 1))
-		return 0;
-
-	return -ESRCH;
-}
-
-static u8 bnx2x_link_initialize(struct link_params *params,
-			      struct link_vars *vars)
-{
-	struct bnx2x *bp = params->bp;
-	u8 port = params->port;
-	u8 rc = 0;
-	u8 non_ext_phy;
-	u32 ext_phy_type = XGXS_EXT_PHY_TYPE(params->ext_phy_config);
-
-	/* Activate the external PHY */
-	bnx2x_ext_phy_reset(params, vars);
-
-	bnx2x_set_aer_mmd(params, vars);
-
-	if (vars->phy_flags & PHY_XGXS_FLAG)
-		bnx2x_set_master_ln(params);
-
-	rc = bnx2x_reset_unicore(params);
-	/* reset the SerDes and wait for reset bit return low */
-	if (rc != 0)
-		return rc;
-
-	bnx2x_set_aer_mmd(params, vars);
-
-	/* setting the masterLn_def again after the reset */
-	if (vars->phy_flags & PHY_XGXS_FLAG) {
-		bnx2x_set_master_ln(params);
-		bnx2x_set_swap_lanes(params);
-	}
-
-	if (vars->phy_flags & PHY_XGXS_FLAG) {
-		if ((params->req_line_speed &&
-		    ((params->req_line_speed == SPEED_100) ||
-		     (params->req_line_speed == SPEED_10))) ||
-		    (!params->req_line_speed &&
-		     (params->speed_cap_mask >=
-		       PORT_HW_CFG_SPEED_CAPABILITY_D0_10M_FULL) &&
-		     (params->speed_cap_mask <
-		       PORT_HW_CFG_SPEED_CAPABILITY_D0_1G)
-		     ))  {
-			vars->phy_flags |= PHY_SGMII_FLAG;
-		} else {
-			vars->phy_flags &= ~PHY_SGMII_FLAG;
-		}
-	}
-	/* In case of external phy existance, the line speed would be the
-	 line speed linked up by the external phy. In case it is direct only,
-	  then the line_speed during initialization will be equal to the
-	   req_line_speed*/
-	vars->line_speed = params->req_line_speed;
-
-	bnx2x_calc_ieee_aneg_adv(params, &vars->ieee_fc);
-
-	/* init ext phy and enable link state int */
-	non_ext_phy = ((ext_phy_type == PORT_HW_CFG_XGXS_EXT_PHY_TYPE_DIRECT) ||
-		       (params->loopback_mode == LOOPBACK_XGXS_10));
-
-	if (non_ext_phy ||
-	    (ext_phy_type == PORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM8705) ||
-	    (ext_phy_type == PORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM8706) ||
-	    (ext_phy_type == PORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM8726) ||
-	    (params->loopback_mode == LOOPBACK_EXT_PHY)) {
-		if (params->req_line_speed == SPEED_AUTO_NEG)
-			bnx2x_set_parallel_detection(params, vars->phy_flags);
-		bnx2x_init_internal_phy(params, vars, non_ext_phy);
-	}
-
-	if (!non_ext_phy)
-		rc |= bnx2x_ext_phy_init(params, vars);
-
-	bnx2x_bits_dis(bp, NIG_REG_STATUS_INTERRUPT_PORT0 + port*4,
-		     (NIG_STATUS_XGXS0_LINK10G |
-		      NIG_STATUS_XGXS0_LINK_STATUS |
-		      NIG_STATUS_SERDES0_LINK_STATUS));
-
-	return rc;
-
-}
-
-
-u8 bnx2x_phy_init(struct link_params *params, struct link_vars *vars)
-{
-	struct bnx2x *bp = params->bp;
-	u32 val;
-
-	DP(NETIF_MSG_LINK, "Phy Initialization started\n");
-	DP(NETIF_MSG_LINK, "req_speed %d, req_flowctrl %d\n",
-		 params->req_line_speed, params->req_flow_ctrl);
-	vars->link_status = 0;
-	vars->phy_link_up = 0;
-	vars->link_up = 0;
-	vars->line_speed = 0;
-	vars->duplex = DUPLEX_FULL;
-	vars->flow_ctrl = BNX2X_FLOW_CTRL_NONE;
-	vars->mac_type = MAC_TYPE_NONE;
-
-	if (params->switch_cfg ==  SWITCH_CFG_1G)
-		vars->phy_flags = PHY_SERDES_FLAG;
-	else
-		vars->phy_flags = PHY_XGXS_FLAG;
-
-	/* disable attentions */
-	bnx2x_bits_dis(bp, NIG_REG_MASK_INTERRUPT_PORT0 + params->port*4,
-		       (NIG_MASK_XGXS0_LINK_STATUS |
-			NIG_MASK_XGXS0_LINK10G |
-			NIG_MASK_SERDES0_LINK_STATUS |
-			NIG_MASK_MI_INT));
-
-	bnx2x_emac_init(params, vars);
-
-	if (CHIP_REV_IS_FPGA(bp)) {
-
-		vars->link_up = 1;
-		vars->line_speed = SPEED_10000;
-		vars->duplex = DUPLEX_FULL;
-		vars->flow_ctrl = BNX2X_FLOW_CTRL_NONE;
-		vars->link_status = (LINK_STATUS_LINK_UP | LINK_10GTFD);
-		/* enable on E1.5 FPGA */
-		if (CHIP_IS_E1H(bp)) {
-			vars->flow_ctrl |=
-					(BNX2X_FLOW_CTRL_TX |
-					 BNX2X_FLOW_CTRL_RX);
-			vars->link_status |=
-					(LINK_STATUS_TX_FLOW_CONTROL_ENABLED |
-					 LINK_STATUS_RX_FLOW_CONTROL_ENABLED);
-		}
-
-		bnx2x_emac_enable(params, vars, 0);
-		bnx2x_pbf_update(params, vars->flow_ctrl, vars->line_speed);
-		/* disable drain */
-		REG_WR(bp, NIG_REG_EGRESS_DRAIN0_MODE + params->port*4, 0);
-
-		/* update shared memory */
-		bnx2x_update_mng(params, vars->link_status);
-
-		return 0;
-
-	} else
-	if (CHIP_REV_IS_EMUL(bp)) {
-
-		vars->link_up = 1;
-		vars->line_speed = SPEED_10000;
-		vars->duplex = DUPLEX_FULL;
-		vars->flow_ctrl = BNX2X_FLOW_CTRL_NONE;
-		vars->link_status = (LINK_STATUS_LINK_UP | LINK_10GTFD);
-
-		bnx2x_bmac_enable(params, vars, 0);
-
-		bnx2x_pbf_update(params, vars->flow_ctrl, vars->line_speed);
-		/* Disable drain */
-		REG_WR(bp, NIG_REG_EGRESS_DRAIN0_MODE
-				    + params->port*4, 0);
-
-		/* update shared memory */
-		bnx2x_update_mng(params, vars->link_status);
-
-		return 0;
-
-	} else
-	if (params->loopback_mode == LOOPBACK_BMAC) {
-
-		vars->link_up = 1;
-		vars->line_speed = SPEED_10000;
-		vars->duplex = DUPLEX_FULL;
-		vars->flow_ctrl = BNX2X_FLOW_CTRL_NONE;
-		vars->mac_type = MAC_TYPE_BMAC;
-
-		vars->phy_flags = PHY_XGXS_FLAG;
-
-		bnx2x_phy_deassert(params, vars->phy_flags);
-		/* set bmac loopback */
-		bnx2x_bmac_enable(params, vars, 1);
-
-		REG_WR(bp, NIG_REG_EGRESS_DRAIN0_MODE +
-		    params->port*4, 0);
-
-	} else if (params->loopback_mode == LOOPBACK_EMAC) {
-
-		vars->link_up = 1;
-		vars->line_speed = SPEED_1000;
-		vars->duplex = DUPLEX_FULL;
-		vars->flow_ctrl = BNX2X_FLOW_CTRL_NONE;
-		vars->mac_type = MAC_TYPE_EMAC;
-
-		vars->phy_flags = PHY_XGXS_FLAG;
-
-		bnx2x_phy_deassert(params, vars->phy_flags);
-		/* set bmac loopback */
-		bnx2x_emac_enable(params, vars, 1);
-		bnx2x_emac_program(params, vars->line_speed,
-					      vars->duplex);
-		REG_WR(bp, NIG_REG_EGRESS_DRAIN0_MODE +
-		    params->port*4, 0);
-
-	} else if ((params->loopback_mode == LOOPBACK_XGXS_10) ||
-		   (params->loopback_mode == LOOPBACK_EXT_PHY)) {
-
-		vars->link_up = 1;
-		vars->line_speed = SPEED_10000;
-		vars->duplex = DUPLEX_FULL;
-		vars->flow_ctrl = BNX2X_FLOW_CTRL_NONE;
-
-		vars->phy_flags = PHY_XGXS_FLAG;
-
-		val = REG_RD(bp,
-				 NIG_REG_XGXS0_CTRL_PHY_ADDR+
-				 params->port*0x18);
-		params->phy_addr = (u8)val;
-
-		bnx2x_phy_deassert(params, vars->phy_flags);
-		bnx2x_link_initialize(params, vars);
-
-		vars->mac_type = MAC_TYPE_BMAC;
-
-		bnx2x_bmac_enable(params, vars, 0);
-
-		if (params->loopback_mode == LOOPBACK_XGXS_10) {
-			/* set 10G XGXS loopback */
-			bnx2x_set_xgxs_loopback(params, vars, 1);
-		} else {
-			/* set external phy loopback */
-			bnx2x_ext_phy_loopback(params);
-		}
-		REG_WR(bp, NIG_REG_EGRESS_DRAIN0_MODE +
-			    params->port*4, 0);
-
-		bnx2x_set_led(params, LED_MODE_OPER, vars->line_speed);
-	} else
-	/* No loopback */
-	{
-		bnx2x_phy_deassert(params, vars->phy_flags);
-		switch (params->switch_cfg) {
-		case SWITCH_CFG_1G:
-			vars->phy_flags |= PHY_SERDES_FLAG;
-			if ((params->ext_phy_config &
-			     PORT_HW_CFG_SERDES_EXT_PHY_TYPE_MASK) ==
-			     PORT_HW_CFG_SERDES_EXT_PHY_TYPE_BCM5482) {
-				vars->phy_flags |= PHY_SGMII_FLAG;
-			}
-
-			val = REG_RD(bp,
-					 NIG_REG_SERDES0_CTRL_PHY_ADDR+
-					 params->port*0x10);
-
-			params->phy_addr = (u8)val;
-
-			break;
-		case SWITCH_CFG_10G:
-			vars->phy_flags |= PHY_XGXS_FLAG;
-			val = REG_RD(bp,
-				 NIG_REG_XGXS0_CTRL_PHY_ADDR+
-				 params->port*0x18);
-			params->phy_addr = (u8)val;
-
-			break;
-		default:
-			DP(NETIF_MSG_LINK, "Invalid switch_cfg\n");
-			return -EINVAL;
-		}
-		DP(NETIF_MSG_LINK, "Phy address = 0x%x\n", params->phy_addr);
-
-		bnx2x_link_initialize(params, vars);
-		msleep(30);
-		bnx2x_link_int_enable(params);
-	}
-	return 0;
-}
-
-static void bnx2x_8726_reset_phy(struct bnx2x *bp, u8 port, u8 ext_phy_addr)
-{
-	DP(NETIF_MSG_LINK, "bnx2x_8726_reset_phy port %d\n", port);
-
-	/* Set serial boot control for external load */
-	bnx2x_cl45_write(bp, port,
-		       PORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM8726, ext_phy_addr,
-		       MDIO_PMA_DEVAD,
-		       MDIO_PMA_REG_GEN_CTRL, 0x0001);
-}
-
-u8 bnx2x_link_reset(struct link_params *params, struct link_vars *vars,
-		  u8 reset_ext_phy)
-{
-	struct bnx2x *bp = params->bp;
-	u32 ext_phy_config = params->ext_phy_config;
-	u8 port = params->port;
-	u32 ext_phy_type = XGXS_EXT_PHY_TYPE(ext_phy_config);
-	u32 val = REG_RD(bp, params->shmem_base +
-			     offsetof(struct shmem_region, dev_info.
-				      port_feature_config[params->port].
-				      config));
-	DP(NETIF_MSG_LINK, "Resetting the link of port %d\n", port);
-	/* disable attentions */
-	vars->link_status = 0;
-	bnx2x_update_mng(params, vars->link_status);
-	bnx2x_bits_dis(bp, NIG_REG_MASK_INTERRUPT_PORT0 + port*4,
-		     (NIG_MASK_XGXS0_LINK_STATUS |
-		      NIG_MASK_XGXS0_LINK10G |
-		      NIG_MASK_SERDES0_LINK_STATUS |
-		      NIG_MASK_MI_INT));
-
-	/* activate nig drain */
-	REG_WR(bp, NIG_REG_EGRESS_DRAIN0_MODE + port*4, 1);
-
-	/* disable nig egress interface */
-	REG_WR(bp, NIG_REG_BMAC0_OUT_EN + port*4, 0);
-	REG_WR(bp, NIG_REG_EGRESS_EMAC0_OUT_EN + port*4, 0);
-
-	/* Stop BigMac rx */
-	bnx2x_bmac_rx_disable(bp, port);
-
-	/* disable emac */
-	REG_WR(bp, NIG_REG_NIG_EMAC0_EN + port*4, 0);
-
-	msleep(10);
-	/* The PHY reset is controled by GPIO 1
-	 * Hold it as vars low
-	 */
-	 /* clear link led */
-	bnx2x_set_led(params, LED_MODE_OFF, 0);
-	if (reset_ext_phy) {
-		switch (ext_phy_type) {
-		case PORT_HW_CFG_XGXS_EXT_PHY_TYPE_DIRECT:
-		case PORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM8072:
-			break;
-
-		case PORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM8727:
-		{
-
-			/* Disable Transmitter */
-			u8 ext_phy_addr =
-				XGXS_EXT_PHY_ADDR(params->ext_phy_config);
-			if ((val & PORT_FEAT_CFG_OPT_MDL_ENFRCMNT_MASK) ==
-			    PORT_FEAT_CFG_OPT_MDL_ENFRCMNT_DISABLE_TX_LASER)
-				bnx2x_sfp_set_transmitter(bp, port,
-					PORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM8727,
-					ext_phy_addr, 0);
-			break;
-		}
-		case PORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM8073:
-			DP(NETIF_MSG_LINK, "Setting 8073 port %d into "
-				 "low power mode\n",
-				 port);
-			bnx2x_set_gpio(bp, MISC_REGISTERS_GPIO_2,
-					  MISC_REGISTERS_GPIO_OUTPUT_LOW,
-					  port);
-			break;
-		case PORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM8726:
-		{
-			u8 ext_phy_addr =
-				XGXS_EXT_PHY_ADDR(params->ext_phy_config);
-			/* Set soft reset */
-			bnx2x_8726_reset_phy(bp, params->port, ext_phy_addr);
-			break;
-		}
-		case PORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM84823:
-		{
-			u8 ext_phy_addr =
-				XGXS_EXT_PHY_ADDR(params->ext_phy_config);
-			bnx2x_cl45_write(bp, port,
-				       PORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM8481,
-				       ext_phy_addr,
-				       MDIO_AN_DEVAD,
-				       MDIO_AN_REG_CTRL, 0x0000);
-			bnx2x_cl45_write(bp, port,
-				       PORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM8481,
-				       ext_phy_addr,
-				       MDIO_PMA_DEVAD,
-				       MDIO_PMA_REG_CTRL, 1);
-			break;
-		}
-		default:
-			/* HW reset */
-			bnx2x_set_gpio(bp, MISC_REGISTERS_GPIO_1,
-					  MISC_REGISTERS_GPIO_OUTPUT_LOW,
-					  port);
-			bnx2x_set_gpio(bp, MISC_REGISTERS_GPIO_2,
-					  MISC_REGISTERS_GPIO_OUTPUT_LOW,
-					  port);
-			DP(NETIF_MSG_LINK, "reset external PHY\n");
-		}
-	}
-	/* reset the SerDes/XGXS */
-	REG_WR(bp, GRCBASE_MISC + MISC_REGISTERS_RESET_REG_3_CLEAR,
-	       (0x1ff << (port*16)));
-
-	/* reset BigMac */
-	REG_WR(bp, GRCBASE_MISC + MISC_REGISTERS_RESET_REG_2_CLEAR,
-	       (MISC_REGISTERS_RESET_REG_2_RST_BMAC0 << port));
-
-	/* disable nig ingress interface */
-	REG_WR(bp, NIG_REG_BMAC0_IN_EN + port*4, 0);
-	REG_WR(bp, NIG_REG_EMAC0_IN_EN + port*4, 0);
-	REG_WR(bp, NIG_REG_BMAC0_OUT_EN + port*4, 0);
-	REG_WR(bp, NIG_REG_EGRESS_EMAC0_OUT_EN + port*4, 0);
-	vars->link_up = 0;
-	return 0;
-}
-
-static u8 bnx2x_update_link_down(struct link_params *params,
-			       struct link_vars *vars)
-{
-	struct bnx2x *bp = params->bp;
-	u8 port = params->port;
-
-	DP(NETIF_MSG_LINK, "Port %x: Link is down\n", port);
-	bnx2x_set_led(params, LED_MODE_OFF, 0);
-
-	/* indicate no mac active */
-	vars->mac_type = MAC_TYPE_NONE;
-
-	/* update shared memory */
-	vars->link_status = 0;
-	vars->line_speed = 0;
-	bnx2x_update_mng(params, vars->link_status);
-
-	/* activate nig drain */
-	REG_WR(bp, NIG_REG_EGRESS_DRAIN0_MODE + port*4, 1);
-
-	/* disable emac */
-	REG_WR(bp, NIG_REG_NIG_EMAC0_EN + port*4, 0);
-
-	msleep(10);
-
-	/* reset BigMac */
-	bnx2x_bmac_rx_disable(bp, params->port);
-	REG_WR(bp, GRCBASE_MISC +
-		   MISC_REGISTERS_RESET_REG_2_CLEAR,
-		   (MISC_REGISTERS_RESET_REG_2_RST_BMAC0 << port));
-	return 0;
-}
-
-static u8 bnx2x_update_link_up(struct link_params *params,
-			     struct link_vars *vars,
-			     u8 link_10g, u32 gp_status)
-{
-	struct bnx2x *bp = params->bp;
-	u8 port = params->port;
-	u8 rc = 0;
-
-	vars->link_status |= LINK_STATUS_LINK_UP;
-	if (link_10g) {
-		bnx2x_bmac_enable(params, vars, 0);
-		bnx2x_set_led(params, LED_MODE_OPER, SPEED_10000);
-	} else {
-		rc = bnx2x_emac_program(params, vars->line_speed,
-				      vars->duplex);
-
-		bnx2x_emac_enable(params, vars, 0);
-
-		/* AN complete? */
-		if (gp_status & MDIO_AN_CL73_OR_37_COMPLETE) {
-			if (!(vars->phy_flags &
-			      PHY_SGMII_FLAG))
-				bnx2x_set_gmii_tx_driver(params);
-		}
-	}
-
-	/* PBF - link up */
-	rc |= bnx2x_pbf_update(params, vars->flow_ctrl,
-			      vars->line_speed);
-
-	/* disable drain */
-	REG_WR(bp, NIG_REG_EGRESS_DRAIN0_MODE + port*4, 0);
-
-	/* update shared memory */
-	bnx2x_update_mng(params, vars->link_status);
-	msleep(20);
-	return rc;
-}
-/* This function should called upon link interrupt */
-/* In case vars->link_up, driver needs to
-	1. Update the pbf
-	2. Disable drain
-	3. Update the shared memory
-	4. Indicate link up
-	5. Set LEDs
-   Otherwise,
-	1. Update shared memory
-	2. Reset BigMac
-	3. Report link down
-	4. Unset LEDs
-*/
-u8 bnx2x_link_update(struct link_params *params, struct link_vars *vars)
-{
-	struct bnx2x *bp = params->bp;
-	u8 port = params->port;
-	u16 gp_status;
-	u8 link_10g;
-	u8 ext_phy_link_up, rc = 0;
-	u32 ext_phy_type;
-	u8 is_mi_int = 0;
-
-	DP(NETIF_MSG_LINK, "port %x, XGXS?%x, int_status 0x%x\n",
-		 port, (vars->phy_flags & PHY_XGXS_FLAG),
-		 REG_RD(bp, NIG_REG_STATUS_INTERRUPT_PORT0 + port*4));
-
-	is_mi_int = (u8)(REG_RD(bp, NIG_REG_EMAC0_STATUS_MISC_MI_INT +
-				    port*0x18) > 0);
-	DP(NETIF_MSG_LINK, "int_mask 0x%x MI_INT %x, SERDES_LINK %x\n",
-		 REG_RD(bp, NIG_REG_MASK_INTERRUPT_PORT0 + port*4),
-		 is_mi_int,
-		 REG_RD(bp,
-			    NIG_REG_SERDES0_STATUS_LINK_STATUS + port*0x3c));
-
-	DP(NETIF_MSG_LINK, " 10G %x, XGXS_LINK %x\n",
-	  REG_RD(bp, NIG_REG_XGXS0_STATUS_LINK10G + port*0x68),
-	  REG_RD(bp, NIG_REG_XGXS0_STATUS_LINK_STATUS + port*0x68));
-
-	/* disable emac */
-	REG_WR(bp, NIG_REG_NIG_EMAC0_EN + port*4, 0);
-
-	ext_phy_type = XGXS_EXT_PHY_TYPE(params->ext_phy_config);
-
-	/* Check external link change only for non-direct */
-	ext_phy_link_up = bnx2x_ext_phy_is_link_up(params, vars, is_mi_int);
-
-	/* Read gp_status */
-	CL45_RD_OVER_CL22(bp, port, params->phy_addr,
-			      MDIO_REG_BANK_GP_STATUS,
-			      MDIO_GP_STATUS_TOP_AN_STATUS1,
-			      &gp_status);
-
-	rc = bnx2x_link_settings_status(params, vars, gp_status,
-				      ext_phy_link_up);
-	if (rc != 0)
-		return rc;
-
-	/* anything 10 and over uses the bmac */
-	link_10g = ((vars->line_speed == SPEED_10000) ||
-		    (vars->line_speed == SPEED_12000) ||
-		    (vars->line_speed == SPEED_12500) ||
-		    (vars->line_speed == SPEED_13000) ||
-		    (vars->line_speed == SPEED_15000) ||
-		    (vars->line_speed == SPEED_16000));
-
-	bnx2x_link_int_ack(params, vars, link_10g, is_mi_int);
-
-	/* In case external phy link is up, and internal link is down
-	( not initialized yet probably after link initialization, it needs
-	to be initialized.
-	Note that after link down-up as result of cable plug,
-	the xgxs link would probably become up again without the need to
-	initialize it*/
-
-	if ((ext_phy_type != PORT_HW_CFG_SERDES_EXT_PHY_TYPE_DIRECT) &&
-	    (ext_phy_type != PORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM8705) &&
-	    (ext_phy_type != PORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM8706) &&
-	    (ext_phy_type != PORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM8726) &&
-	    (ext_phy_link_up && !vars->phy_link_up))
-		bnx2x_init_internal_phy(params, vars, 0);
-
-	/* link is up only if both local phy and external phy are up */
-	vars->link_up = (ext_phy_link_up && vars->phy_link_up);
-
-	if (vars->link_up)
-		rc = bnx2x_update_link_up(params, vars, link_10g, gp_status);
-	else
-		rc = bnx2x_update_link_down(params, vars);
-
-	return rc;
-}
-
-static u8 bnx2x_8073_common_init_phy(struct bnx2x *bp, u32 shmem_base)
-{
-	u8 ext_phy_addr[PORT_MAX];
-	u16 val;
-	s8 port;
-
-	/* PART1 - Reset both phys */
-	for (port = PORT_MAX - 1; port >= PORT_0; port--) {
-		/* Extract the ext phy address for the port */
-		u32 ext_phy_config = REG_RD(bp, shmem_base +
-					offsetof(struct shmem_region,
-		   dev_info.port_hw_config[port].external_phy_config));
-
-		/* disable attentions */
-		bnx2x_bits_dis(bp, NIG_REG_MASK_INTERRUPT_PORT0 + port*4,
-			     (NIG_MASK_XGXS0_LINK_STATUS |
-			      NIG_MASK_XGXS0_LINK10G |
-			      NIG_MASK_SERDES0_LINK_STATUS |
-			      NIG_MASK_MI_INT));
-
-		ext_phy_addr[port] = XGXS_EXT_PHY_ADDR(ext_phy_config);
-
-		/* Need to take the phy out of low power mode in order
-			to write to access its registers */
-		bnx2x_set_gpio(bp, MISC_REGISTERS_GPIO_2,
-				  MISC_REGISTERS_GPIO_OUTPUT_HIGH, port);
-
-		/* Reset the phy */
-		bnx2x_cl45_write(bp, port,
-			       PORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM8073,
-			       ext_phy_addr[port],
-			       MDIO_PMA_DEVAD,
-			       MDIO_PMA_REG_CTRL,
-			       1<<15);
-	}
-
-	/* Add delay of 150ms after reset */
-	msleep(150);
-
-	/* PART2 - Download firmware to both phys */
-	for (port = PORT_MAX - 1; port >= PORT_0; port--) {
-		u16 fw_ver1;
-
-		bnx2x_bcm8073_external_rom_boot(bp, port,
-					      ext_phy_addr[port], shmem_base);
-
-		bnx2x_cl45_read(bp, port, PORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM8073,
-			      ext_phy_addr[port],
-			      MDIO_PMA_DEVAD,
-			      MDIO_PMA_REG_ROM_VER1, &fw_ver1);
-		if (fw_ver1 == 0 || fw_ver1 == 0x4321) {
-			DP(NETIF_MSG_LINK,
-				 "bnx2x_8073_common_init_phy port %x:"
-				 "Download failed. fw version = 0x%x\n",
-				 port, fw_ver1);
-			return -EINVAL;
-		}
-
-		/* Only set bit 10 = 1 (Tx power down) */
-		bnx2x_cl45_read(bp, port,
-			      PORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM8073,
-			      ext_phy_addr[port],
-			      MDIO_PMA_DEVAD,
-			      MDIO_PMA_REG_TX_POWER_DOWN, &val);
-
-		/* Phase1 of TX_POWER_DOWN reset */
-		bnx2x_cl45_write(bp, port,
-			       PORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM8073,
-			       ext_phy_addr[port],
-			       MDIO_PMA_DEVAD,
-			       MDIO_PMA_REG_TX_POWER_DOWN,
-			       (val | 1<<10));
-	}
-
-	/* Toggle Transmitter: Power down and then up with 600ms
-	   delay between */
-	msleep(600);
-
-	/* PART3 - complete TX_POWER_DOWN process, and set GPIO2 back to low */
-	for (port = PORT_MAX - 1; port >= PORT_0; port--) {
-		/* Phase2 of POWER_DOWN_RESET */
-		/* Release bit 10 (Release Tx power down) */
-		bnx2x_cl45_read(bp, port,
-			      PORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM8073,
-			      ext_phy_addr[port],
-			      MDIO_PMA_DEVAD,
-			      MDIO_PMA_REG_TX_POWER_DOWN, &val);
-
-		bnx2x_cl45_write(bp, port,
-			       PORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM8073,
-			       ext_phy_addr[port],
-			       MDIO_PMA_DEVAD,
-			       MDIO_PMA_REG_TX_POWER_DOWN, (val & (~(1<<10))));
-		msleep(15);
-
-		/* Read modify write the SPI-ROM version select register */
-		bnx2x_cl45_read(bp, port,
-			      PORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM8073,
-			      ext_phy_addr[port],
-			      MDIO_PMA_DEVAD,
-			      MDIO_PMA_REG_EDC_FFE_MAIN, &val);
-		bnx2x_cl45_write(bp, port,
-			      PORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM8073,
-			      ext_phy_addr[port],
-			      MDIO_PMA_DEVAD,
-			      MDIO_PMA_REG_EDC_FFE_MAIN, (val | (1<<12)));
-
-		/* set GPIO2 back to LOW */
-		bnx2x_set_gpio(bp, MISC_REGISTERS_GPIO_2,
-				  MISC_REGISTERS_GPIO_OUTPUT_LOW, port);
-	}
-	return 0;
-
-}
-
-static u8 bnx2x_8727_common_init_phy(struct bnx2x *bp, u32 shmem_base)
-{
-	u8 ext_phy_addr[PORT_MAX];
-	s8 port, first_port, i;
-	u32 swap_val, swap_override;
-	DP(NETIF_MSG_LINK, "Executing BCM8727 common init\n");
-	swap_val = REG_RD(bp,  NIG_REG_PORT_SWAP);
-	swap_override = REG_RD(bp,  NIG_REG_STRAP_OVERRIDE);
-
-	bnx2x_ext_phy_hw_reset(bp, 1 ^ (swap_val && swap_override));
-	msleep(5);
-
-	if (swap_val && swap_override)
-		first_port = PORT_0;
-	else
-		first_port = PORT_1;
-
-	/* PART1 - Reset both phys */
-	for (i = 0, port = first_port; i < PORT_MAX; i++, port = !port) {
-		/* Extract the ext phy address for the port */
-		u32 ext_phy_config = REG_RD(bp, shmem_base +
-					offsetof(struct shmem_region,
-		   dev_info.port_hw_config[port].external_phy_config));
-
-		/* disable attentions */
-		bnx2x_bits_dis(bp, NIG_REG_MASK_INTERRUPT_PORT0 + port*4,
-			     (NIG_MASK_XGXS0_LINK_STATUS |
-			      NIG_MASK_XGXS0_LINK10G |
-			      NIG_MASK_SERDES0_LINK_STATUS |
-			      NIG_MASK_MI_INT));
-
-		ext_phy_addr[port] = XGXS_EXT_PHY_ADDR(ext_phy_config);
-
-		/* Reset the phy */
-		bnx2x_cl45_write(bp, port,
-			       PORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM8727,
-			       ext_phy_addr[port],
-			       MDIO_PMA_DEVAD,
-			       MDIO_PMA_REG_CTRL,
-			       1<<15);
-	}
-
-	/* Add delay of 150ms after reset */
-	msleep(150);
-
-	/* PART2 - Download firmware to both phys */
-	for (i = 0, port = first_port; i < PORT_MAX; i++, port = !port) {
-		u16 fw_ver1;
-
-		bnx2x_bcm8727_external_rom_boot(bp, port,
-					      ext_phy_addr[port], shmem_base);
-
-		bnx2x_cl45_read(bp, port, PORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM8727,
-			      ext_phy_addr[port],
-			      MDIO_PMA_DEVAD,
-			      MDIO_PMA_REG_ROM_VER1, &fw_ver1);
-		if (fw_ver1 == 0 || fw_ver1 == 0x4321) {
-			DP(NETIF_MSG_LINK,
-				 "bnx2x_8727_common_init_phy port %x:"
-				 "Download failed. fw version = 0x%x\n",
-				 port, fw_ver1);
-			return -EINVAL;
-		}
-	}
-
-	return 0;
-}
-
-
-static u8 bnx2x_8726_common_init_phy(struct bnx2x *bp, u32 shmem_base)
-{
-	u8 ext_phy_addr;
-	u32 val;
-	s8 port;
-
-	/* Use port1 because of the static port-swap */
-	/* Enable the module detection interrupt */
-	val = REG_RD(bp, MISC_REG_GPIO_EVENT_EN);
-	val |= ((1<<MISC_REGISTERS_GPIO_3)|
-		(1<<(MISC_REGISTERS_GPIO_3 + MISC_REGISTERS_GPIO_PORT_SHIFT)));
-	REG_WR(bp, MISC_REG_GPIO_EVENT_EN, val);
-
-	bnx2x_ext_phy_hw_reset(bp, 1);
-	msleep(5);
-	for (port = 0; port < PORT_MAX; port++) {
-		/* Extract the ext phy address for the port */
-		u32 ext_phy_config = REG_RD(bp, shmem_base +
-					offsetof(struct shmem_region,
-			dev_info.port_hw_config[port].external_phy_config));
-
-		ext_phy_addr = XGXS_EXT_PHY_ADDR(ext_phy_config);
-		DP(NETIF_MSG_LINK, "8726_common_init : ext_phy_addr = 0x%x\n",
-			 ext_phy_addr);
-
-		bnx2x_8726_reset_phy(bp, port, ext_phy_addr);
-
-		/* Set fault module detected LED on */
-		bnx2x_set_gpio(bp, MISC_REGISTERS_GPIO_0,
-				  MISC_REGISTERS_GPIO_HIGH,
-				  port);
-	}
-
-	return 0;
-}
-
-
-static u8 bnx2x_84823_common_init_phy(struct bnx2x *bp, u32 shmem_base)
-{
-	/* HW reset */
-	bnx2x_ext_phy_hw_reset(bp, 1);
-	return 0;
-}
-u8 bnx2x_common_init_phy(struct bnx2x *bp, u32 shmem_base)
-{
-	u8 rc = 0;
-	u32 ext_phy_type;
-
-	DP(NETIF_MSG_LINK, "Begin common phy init\n");
-
-	/* Read the ext_phy_type for arbitrary port(0) */
-	ext_phy_type = XGXS_EXT_PHY_TYPE(
-			REG_RD(bp, shmem_base +
-			   offsetof(struct shmem_region,
-			     dev_info.port_hw_config[0].external_phy_config)));
-
-	switch (ext_phy_type) {
-	case PORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM8073:
-	{
-		rc = bnx2x_8073_common_init_phy(bp, shmem_base);
-		break;
-	}
-
-	case PORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM8727:
-	case PORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM8727_NOC:
-		rc = bnx2x_8727_common_init_phy(bp, shmem_base);
-		break;
-
-	case PORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM8726:
-		/* GPIO1 affects both ports, so there's need to pull
-		it for single port alone */
-		rc = bnx2x_8726_common_init_phy(bp, shmem_base);
-		break;
-	case PORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM84823:
-		rc = bnx2x_84823_common_init_phy(bp, shmem_base);
-		break;
-	default:
-		DP(NETIF_MSG_LINK,
-			 "bnx2x_common_init_phy: ext_phy 0x%x not required\n",
-			 ext_phy_type);
-		break;
-	}
-
-	return rc;
-}
-
-void bnx2x_sfx7101_sp_sw_reset(struct bnx2x *bp, u8 port, u8 phy_addr)
-{
-	u16 val, cnt;
-
-	bnx2x_cl45_read(bp, port,
-		      PORT_HW_CFG_XGXS_EXT_PHY_TYPE_SFX7101,
-		      phy_addr,
-		      MDIO_PMA_DEVAD,
-		      MDIO_PMA_REG_7101_RESET, &val);
-
-	for (cnt = 0; cnt < 10; cnt++) {
-		msleep(50);
-		/* Writes a self-clearing reset */
-		bnx2x_cl45_write(bp, port,
-			       PORT_HW_CFG_XGXS_EXT_PHY_TYPE_SFX7101,
-			       phy_addr,
-			       MDIO_PMA_DEVAD,
-			       MDIO_PMA_REG_7101_RESET,
-			       (val | (1<<15)));
-		/* Wait for clear */
-		bnx2x_cl45_read(bp, port,
-			      PORT_HW_CFG_XGXS_EXT_PHY_TYPE_SFX7101,
-			      phy_addr,
-			      MDIO_PMA_DEVAD,
-			      MDIO_PMA_REG_7101_RESET, &val);
-
-		if ((val & (1<<15)) == 0)
-			break;
-	}
-}
diff -r f4bf81a7ff20 drivers/net/bnx2x_link.h
--- a/drivers/net/bnx2x_link.h
+++ /dev/null
@@ -1,206 +0,0 @@
-/* Copyright 2008-2009 Broadcom Corporation
- *
- * Unless you and Broadcom execute a separate written software license
- * agreement governing use of this software, this software is licensed to you
- * under the terms of the GNU General Public License version 2, available
- * at http://www.gnu.org/licenses/old-licenses/gpl-2.0.html (the "GPL").
- *
- * Notwithstanding the above, under no circumstances may you combine this
- * software in any way with any other Broadcom software provided under a
- * license other than the GPL, without Broadcom's express prior written
- * consent.
- *
- * Written by Yaniv Rosner
- *
- */
-
-#ifndef BNX2X_LINK_H
-#define BNX2X_LINK_H
-
-
-
-/***********************************************************/
-/*                         Defines                         */
-/***********************************************************/
-#define DEFAULT_PHY_DEV_ADDR 3
-
-
-
-#define BNX2X_FLOW_CTRL_AUTO		PORT_FEATURE_FLOW_CONTROL_AUTO
-#define BNX2X_FLOW_CTRL_TX		PORT_FEATURE_FLOW_CONTROL_TX
-#define BNX2X_FLOW_CTRL_RX		PORT_FEATURE_FLOW_CONTROL_RX
-#define BNX2X_FLOW_CTRL_BOTH		PORT_FEATURE_FLOW_CONTROL_BOTH
-#define BNX2X_FLOW_CTRL_NONE		PORT_FEATURE_FLOW_CONTROL_NONE
-
-#define SPEED_AUTO_NEG	    0
-#define SPEED_12000		12000
-#define SPEED_12500		12500
-#define SPEED_13000		13000
-#define SPEED_15000		15000
-#define SPEED_16000		16000
-
-#define SFP_EEPROM_VENDOR_NAME_ADDR		0x14
-#define SFP_EEPROM_VENDOR_NAME_SIZE		16
-#define SFP_EEPROM_VENDOR_OUI_ADDR		0x25
-#define SFP_EEPROM_VENDOR_OUI_SIZE		3
-#define SFP_EEPROM_PART_NO_ADDR 		0x28
-#define SFP_EEPROM_PART_NO_SIZE		16
-#define PWR_FLT_ERR_MSG_LEN			250
-/***********************************************************/
-/*                         Structs                         */
-/***********************************************************/
-/* Inputs parameters to the CLC */
-struct link_params {
-
-	u8 port;
-
-	/* Default / User Configuration */
-	u8 loopback_mode;
-#define LOOPBACK_NONE	0
-#define LOOPBACK_EMAC	1
-#define LOOPBACK_BMAC	2
-#define LOOPBACK_XGXS_10	3
-#define LOOPBACK_EXT_PHY	4
-#define LOOPBACK_EXT 	5
-
-	u16 req_duplex;
-	u16 req_flow_ctrl;
-	u16 req_fc_auto_adv; /* Should be set to TX / BOTH when
-	req_flow_ctrl is set to AUTO */
-	u16 req_line_speed; /* Also determine AutoNeg */
-
-	/* Device parameters */
-	u8 mac_addr[6];
-
-	/* shmem parameters */
-	u32 shmem_base;
-	u32 speed_cap_mask;
-	u32 switch_cfg;
-#define SWITCH_CFG_1G		PORT_FEATURE_CON_SWITCH_1G_SWITCH
-#define SWITCH_CFG_10G		PORT_FEATURE_CON_SWITCH_10G_SWITCH
-#define SWITCH_CFG_AUTO_DETECT	PORT_FEATURE_CON_SWITCH_AUTO_DETECT
-
-	u16 hw_led_mode; /* part of the hw_config read from the shmem */
-
-	/* phy_addr populated by the phy_init function */
-	u8 phy_addr;
-	/*u8 reserved1;*/
-
-	u32 lane_config;
-	u32 ext_phy_config;
-#define XGXS_EXT_PHY_TYPE(ext_phy_config) \
-		((ext_phy_config) & PORT_HW_CFG_XGXS_EXT_PHY_TYPE_MASK)
-#define XGXS_EXT_PHY_ADDR(ext_phy_config) \
-		(((ext_phy_config) & PORT_HW_CFG_XGXS_EXT_PHY_ADDR_MASK) >> \
-		 PORT_HW_CFG_XGXS_EXT_PHY_ADDR_SHIFT)
-#define SERDES_EXT_PHY_TYPE(ext_phy_config) \
-		((ext_phy_config) & PORT_HW_CFG_SERDES_EXT_PHY_TYPE_MASK)
-
-	/* Phy register parameter */
-	u32 chip_id;
-
-	u16 xgxs_config_rx[4]; /* preemphasis values for the rx side */
-	u16 xgxs_config_tx[4]; /* preemphasis values for the tx side */
-
-	u32 feature_config_flags;
-#define FEATURE_CONFIG_OVERRIDE_PREEMPHASIS_ENABLED (1<<0)
-#define FEATURE_CONFIG_BC_SUPPORTS_OPT_MDL_VRFY	(1<<2)
-#define FEATURE_CONFIG_BCM8727_NOC			(1<<3)
-
-	/* Device pointer passed to all callback functions */
-	struct bnx2x *bp;
-};
-
-/* Output parameters */
-struct link_vars {
-	u8 phy_flags;
-
-	u8 mac_type;
-#define MAC_TYPE_NONE		0
-#define MAC_TYPE_EMAC		1
-#define MAC_TYPE_BMAC		2
-
-	u8 phy_link_up; /* internal phy link indication */
-	u8 link_up;
-
-	u16 line_speed;
-	u16 duplex;
-
-	u16 flow_ctrl;
-	u16 ieee_fc;
-
-	u32 autoneg;
-#define AUTO_NEG_DISABLED			0x0
-#define AUTO_NEG_ENABLED			0x1
-#define AUTO_NEG_COMPLETE			0x2
-#define AUTO_NEG_PARALLEL_DETECTION_USED	0x3
-
-	/* The same definitions as the shmem parameter */
-	u32 link_status;
-};
-
-/***********************************************************/
-/*                         Functions                       */
-/***********************************************************/
-
-/* Initialize the phy */
-u8 bnx2x_phy_init(struct link_params *input, struct link_vars *output);
-
-/* Reset the link. Should be called when driver or interface goes down
-   Before calling phy firmware upgrade, the reset_ext_phy should be set
-   to 0 */
-u8 bnx2x_link_reset(struct link_params *params, struct link_vars *vars,
-		  u8 reset_ext_phy);
-
-/* bnx2x_link_update should be called upon link interrupt */
-u8 bnx2x_link_update(struct link_params *input, struct link_vars *output);
-
-/* use the following cl45 functions to read/write from external_phy
-  In order to use it to read/write internal phy registers, use
-  DEFAULT_PHY_DEV_ADDR as devad, and (_bank + (_addr & 0xf)) as
-  Use ext_phy_type of 0 in case of cl22 over cl45
-  the register */
-u8 bnx2x_cl45_read(struct bnx2x *bp, u8 port, u32 ext_phy_type,
-		 u8 phy_addr, u8 devad, u16 reg, u16 *ret_val);
-
-u8 bnx2x_cl45_write(struct bnx2x *bp, u8 port, u32 ext_phy_type,
-		  u8 phy_addr, u8 devad, u16 reg, u16 val);
-
-/* Reads the link_status from the shmem,
-   and update the link vars accordingly */
-void bnx2x_link_status_update(struct link_params *input,
-			    struct link_vars *output);
-/* returns string representing the fw_version of the external phy */
-u8 bnx2x_get_ext_phy_fw_version(struct link_params *params, u8 driver_loaded,
-			      u8 *version, u16 len);
-
-/* Set/Unset the led
-   Basically, the CLC takes care of the led for the link, but in case one needs
-   to set/unset the led unnaturally, set the "mode" to LED_MODE_OPER to
-   blink the led, and LED_MODE_OFF to set the led off.*/
-u8 bnx2x_set_led(struct link_params *params, u8 mode, u32 speed);
-#define LED_MODE_OFF	0
-#define LED_MODE_OPER 	2
-
-u8 bnx2x_override_led_value(struct bnx2x *bp, u8 port, u32 led_idx, u32 value);
-
-/* bnx2x_handle_module_detect_int should be called upon module detection
-   interrupt */
-void bnx2x_handle_module_detect_int(struct link_params *params);
-
-/* Get the actual link status. In case it returns 0, link is up,
-	otherwise link is down*/
-u8 bnx2x_test_link(struct link_params *input, struct link_vars *vars);
-
-/* One-time initialization for external phy after power up */
-u8 bnx2x_common_init_phy(struct bnx2x *bp, u32 shmem_base);
-
-/* Reset the external PHY using GPIO */
-void bnx2x_ext_phy_hw_reset(struct bnx2x *bp, u8 port);
-
-void bnx2x_sfx7101_sp_sw_reset(struct bnx2x *bp, u8 port, u8 phy_addr);
-
-u8 bnx2x_read_sfp_module_eeprom(struct link_params *params, u16 addr,
-			      u8 byte_cnt, u8 *o_buf);
-
-#endif /* BNX2X_LINK_H */
diff -r f4bf81a7ff20 drivers/net/bnx2x_main.c
--- a/drivers/net/bnx2x_main.c
+++ /dev/null
@@ -1,12771 +0,0 @@
-/* bnx2x_main.c: Broadcom Everest network driver.
- *
- * Copyright (c) 2007-2010 Broadcom Corporation
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation.
- *
- * Maintained by: Eilon Greenstein <eilong@broadcom.com>
- * Written by: Eliezer Tamir
- * Based on code from Michael Chan's bnx2 driver
- * UDP CSUM errata workaround by Arik Gendelman
- * Slowpath and fastpath rework by Vladislav Zolotarov
- * Statistics and Link management by Yitchak Gertner
- *
- */
-
-#include <linux/module.h>
-#include <linux/moduleparam.h>
-#include <linux/kernel.h>
-#include <linux/device.h>  /* for dev_info() */
-#include <linux/timer.h>
-#include <linux/errno.h>
-#include <linux/ioport.h>
-#include <linux/slab.h>
-#include <linux/vmalloc.h>
-#include <linux/interrupt.h>
-#include <linux/pci.h>
-#include <linux/init.h>
-#include <linux/netdevice.h>
-#include <linux/etherdevice.h>
-#include <linux/skbuff.h>
-#include <linux/dma-mapping.h>
-#include <linux/bitops.h>
-#include <linux/irq.h>
-#include <linux/delay.h>
-#include <asm/byteorder.h>
-#include <linux/time.h>
-#include <linux/ethtool.h>
-#include <linux/mii.h>
-#include <linux/if_vlan.h>
-#include <net/ip.h>
-#include <net/tcp.h>
-#include <net/checksum.h>
-#include <net/ip6_checksum.h>
-#include <linux/workqueue.h>
-#include <linux/crc32.h>
-#include <linux/crc32c.h>
-#include <linux/prefetch.h>
-#include <linux/zlib.h>
-#include <linux/io.h>
-#include <linux/stringify.h>
-
-#include "bnx2x.h"
-#include "bnx2x_init.h"
-#include "bnx2x_init_ops.h"
-#include "bnx2x_dump.h"
-
-#define DRV_MODULE_VERSION	"1.52.1-7"
-#define DRV_MODULE_RELDATE	"2010/02/28"
-#define BNX2X_BC_VER		0x040200
-
-#include <linux/firmware.h>
-#include "bnx2x_fw_file_hdr.h"
-/* FW files */
-#define FW_FILE_VERSION					\
-	__stringify(BCM_5710_FW_MAJOR_VERSION) "."	\
-	__stringify(BCM_5710_FW_MINOR_VERSION) "."	\
-	__stringify(BCM_5710_FW_REVISION_VERSION) "."	\
-	__stringify(BCM_5710_FW_ENGINEERING_VERSION)
-#define FW_FILE_NAME_E1		"bnx2x-e1-" FW_FILE_VERSION ".fw"
-#define FW_FILE_NAME_E1H	"bnx2x-e1h-" FW_FILE_VERSION ".fw"
-
-/* Time in jiffies before concluding the transmitter is hung */
-#define TX_TIMEOUT		(5*HZ)
-
-static char version[] __devinitdata =
-	"Broadcom NetXtreme II 5771x 10Gigabit Ethernet Driver "
-	DRV_MODULE_NAME " " DRV_MODULE_VERSION " (" DRV_MODULE_RELDATE ")\n";
-
-MODULE_AUTHOR("Eliezer Tamir");
-MODULE_DESCRIPTION("Broadcom NetXtreme II BCM57710/57711/57711E Driver");
-MODULE_LICENSE("GPL");
-MODULE_VERSION(DRV_MODULE_VERSION);
-MODULE_FIRMWARE(FW_FILE_NAME_E1);
-MODULE_FIRMWARE(FW_FILE_NAME_E1H);
-
-static int multi_mode = 1;
-module_param(multi_mode, int, 0);
-MODULE_PARM_DESC(multi_mode, " Multi queue mode "
-			     "(0 Disable; 1 Enable (default))");
-
-static int num_queues;
-module_param(num_queues, int, 0);
-MODULE_PARM_DESC(num_queues, " Number of queues for multi_mode=1"
-				" (default is as a number of CPUs)");
-
-static int disable_tpa;
-module_param(disable_tpa, int, 0);
-MODULE_PARM_DESC(disable_tpa, " Disable the TPA (LRO) feature");
-
-static int int_mode;
-module_param(int_mode, int, 0);
-MODULE_PARM_DESC(int_mode, " Force interrupt mode (1 INT#x; 2 MSI)");
-
-static int dropless_fc;
-module_param(dropless_fc, int, 0);
-MODULE_PARM_DESC(dropless_fc, " Pause on exhausted host ring");
-
-static int poll;
-module_param(poll, int, 0);
-MODULE_PARM_DESC(poll, " Use polling (for debug)");
-
-static int mrrs = -1;
-module_param(mrrs, int, 0);
-MODULE_PARM_DESC(mrrs, " Force Max Read Req Size (0..3) (for debug)");
-
-static int debug;
-module_param(debug, int, 0);
-MODULE_PARM_DESC(debug, " Default debug msglevel");
-
-static int load_count[3]; /* 0-common, 1-port0, 2-port1 */
-
-static struct workqueue_struct *bnx2x_wq;
-
-enum bnx2x_board_type {
-	BCM57710 = 0,
-	BCM57711 = 1,
-	BCM57711E = 2,
-};
-
-/* indexed by board_type, above */
-static struct {
-	char *name;
-} board_info[] __devinitdata = {
-	{ "Broadcom NetXtreme II BCM57710 XGb" },
-	{ "Broadcom NetXtreme II BCM57711 XGb" },
-	{ "Broadcom NetXtreme II BCM57711E XGb" }
-};
-
-
-static DEFINE_PCI_DEVICE_TABLE(bnx2x_pci_tbl) = {
-	{ PCI_VDEVICE(BROADCOM, PCI_DEVICE_ID_NX2_57710), BCM57710 },
-	{ PCI_VDEVICE(BROADCOM, PCI_DEVICE_ID_NX2_57711), BCM57711 },
-	{ PCI_VDEVICE(BROADCOM, PCI_DEVICE_ID_NX2_57711E), BCM57711E },
-	{ 0 }
-};
-
-MODULE_DEVICE_TABLE(pci, bnx2x_pci_tbl);
-
-/****************************************************************************
-* General service functions
-****************************************************************************/
-
-/* used only at init
- * locking is done by mcp
- */
-void bnx2x_reg_wr_ind(struct bnx2x *bp, u32 addr, u32 val)
-{
-	pci_write_config_dword(bp->pdev, PCICFG_GRC_ADDRESS, addr);
-	pci_write_config_dword(bp->pdev, PCICFG_GRC_DATA, val);
-	pci_write_config_dword(bp->pdev, PCICFG_GRC_ADDRESS,
-			       PCICFG_VENDOR_ID_OFFSET);
-}
-
-static u32 bnx2x_reg_rd_ind(struct bnx2x *bp, u32 addr)
-{
-	u32 val;
-
-	pci_write_config_dword(bp->pdev, PCICFG_GRC_ADDRESS, addr);
-	pci_read_config_dword(bp->pdev, PCICFG_GRC_DATA, &val);
-	pci_write_config_dword(bp->pdev, PCICFG_GRC_ADDRESS,
-			       PCICFG_VENDOR_ID_OFFSET);
-
-	return val;
-}
-
-static const u32 dmae_reg_go_c[] = {
-	DMAE_REG_GO_C0, DMAE_REG_GO_C1, DMAE_REG_GO_C2, DMAE_REG_GO_C3,
-	DMAE_REG_GO_C4, DMAE_REG_GO_C5, DMAE_REG_GO_C6, DMAE_REG_GO_C7,
-	DMAE_REG_GO_C8, DMAE_REG_GO_C9, DMAE_REG_GO_C10, DMAE_REG_GO_C11,
-	DMAE_REG_GO_C12, DMAE_REG_GO_C13, DMAE_REG_GO_C14, DMAE_REG_GO_C15
-};
-
-/* copy command into DMAE command memory and set DMAE command go */
-static void bnx2x_post_dmae(struct bnx2x *bp, struct dmae_command *dmae,
-			    int idx)
-{
-	u32 cmd_offset;
-	int i;
-
-	cmd_offset = (DMAE_REG_CMD_MEM + sizeof(struct dmae_command) * idx);
-	for (i = 0; i < (sizeof(struct dmae_command)/4); i++) {
-		REG_WR(bp, cmd_offset + i*4, *(((u32 *)dmae) + i));
-
-		DP(BNX2X_MSG_OFF, "DMAE cmd[%d].%d (0x%08x) : 0x%08x\n",
-		   idx, i, cmd_offset + i*4, *(((u32 *)dmae) + i));
-	}
-	REG_WR(bp, dmae_reg_go_c[idx], 1);
-}
-
-void bnx2x_write_dmae(struct bnx2x *bp, dma_addr_t dma_addr, u32 dst_addr,
-		      u32 len32)
-{
-	struct dmae_command dmae;
-	u32 *wb_comp = bnx2x_sp(bp, wb_comp);
-	int cnt = 200;
-
-	if (!bp->dmae_ready) {
-		u32 *data = bnx2x_sp(bp, wb_data[0]);
-
-		DP(BNX2X_MSG_OFF, "DMAE is not ready (dst_addr %08x  len32 %d)"
-		   "  using indirect\n", dst_addr, len32);
-		bnx2x_init_ind_wr(bp, dst_addr, data, len32);
-		return;
-	}
-
-	memset(&dmae, 0, sizeof(struct dmae_command));
-
-	dmae.opcode = (DMAE_CMD_SRC_PCI | DMAE_CMD_DST_GRC |
-		       DMAE_CMD_C_DST_PCI | DMAE_CMD_C_ENABLE |
-		       DMAE_CMD_SRC_RESET | DMAE_CMD_DST_RESET |
-#ifdef __BIG_ENDIAN
-		       DMAE_CMD_ENDIANITY_B_DW_SWAP |
-#else
-		       DMAE_CMD_ENDIANITY_DW_SWAP |
-#endif
-		       (BP_PORT(bp) ? DMAE_CMD_PORT_1 : DMAE_CMD_PORT_0) |
-		       (BP_E1HVN(bp) << DMAE_CMD_E1HVN_SHIFT));
-	dmae.src_addr_lo = U64_LO(dma_addr);
-	dmae.src_addr_hi = U64_HI(dma_addr);
-	dmae.dst_addr_lo = dst_addr >> 2;
-	dmae.dst_addr_hi = 0;
-	dmae.len = len32;
-	dmae.comp_addr_lo = U64_LO(bnx2x_sp_mapping(bp, wb_comp));
-	dmae.comp_addr_hi = U64_HI(bnx2x_sp_mapping(bp, wb_comp));
-	dmae.comp_val = DMAE_COMP_VAL;
-
-	DP(BNX2X_MSG_OFF, "DMAE: opcode 0x%08x\n"
-	   DP_LEVEL "src_addr  [%x:%08x]  len [%d *4]  "
-		    "dst_addr [%x:%08x (%08x)]\n"
-	   DP_LEVEL "comp_addr [%x:%08x]  comp_val 0x%08x\n",
-	   dmae.opcode, dmae.src_addr_hi, dmae.src_addr_lo,
-	   dmae.len, dmae.dst_addr_hi, dmae.dst_addr_lo, dst_addr,
-	   dmae.comp_addr_hi, dmae.comp_addr_lo, dmae.comp_val);
-	DP(BNX2X_MSG_OFF, "data [0x%08x 0x%08x 0x%08x 0x%08x]\n",
-	   bp->slowpath->wb_data[0], bp->slowpath->wb_data[1],
-	   bp->slowpath->wb_data[2], bp->slowpath->wb_data[3]);
-
-	mutex_lock(&bp->dmae_mutex);
-
-	*wb_comp = 0;
-
-	bnx2x_post_dmae(bp, &dmae, INIT_DMAE_C(bp));
-
-	udelay(5);
-
-	while (*wb_comp != DMAE_COMP_VAL) {
-		DP(BNX2X_MSG_OFF, "wb_comp 0x%08x\n", *wb_comp);
-
-		if (!cnt) {
-			BNX2X_ERR("DMAE timeout!\n");
-			break;
-		}
-		cnt--;
-		/* adjust delay for emulation/FPGA */
-		if (CHIP_REV_IS_SLOW(bp))
-			msleep(100);
-		else
-			udelay(5);
-	}
-
-	mutex_unlock(&bp->dmae_mutex);
-}
-
-void bnx2x_read_dmae(struct bnx2x *bp, u32 src_addr, u32 len32)
-{
-	struct dmae_command dmae;
-	u32 *wb_comp = bnx2x_sp(bp, wb_comp);
-	int cnt = 200;
-
-	if (!bp->dmae_ready) {
-		u32 *data = bnx2x_sp(bp, wb_data[0]);
-		int i;
-
-		DP(BNX2X_MSG_OFF, "DMAE is not ready (src_addr %08x  len32 %d)"
-		   "  using indirect\n", src_addr, len32);
-		for (i = 0; i < len32; i++)
-			data[i] = bnx2x_reg_rd_ind(bp, src_addr + i*4);
-		return;
-	}
-
-	memset(&dmae, 0, sizeof(struct dmae_command));
-
-	dmae.opcode = (DMAE_CMD_SRC_GRC | DMAE_CMD_DST_PCI |
-		       DMAE_CMD_C_DST_PCI | DMAE_CMD_C_ENABLE |
-		       DMAE_CMD_SRC_RESET | DMAE_CMD_DST_RESET |
-#ifdef __BIG_ENDIAN
-		       DMAE_CMD_ENDIANITY_B_DW_SWAP |
-#else
-		       DMAE_CMD_ENDIANITY_DW_SWAP |
-#endif
-		       (BP_PORT(bp) ? DMAE_CMD_PORT_1 : DMAE_CMD_PORT_0) |
-		       (BP_E1HVN(bp) << DMAE_CMD_E1HVN_SHIFT));
-	dmae.src_addr_lo = src_addr >> 2;
-	dmae.src_addr_hi = 0;
-	dmae.dst_addr_lo = U64_LO(bnx2x_sp_mapping(bp, wb_data));
-	dmae.dst_addr_hi = U64_HI(bnx2x_sp_mapping(bp, wb_data));
-	dmae.len = len32;
-	dmae.comp_addr_lo = U64_LO(bnx2x_sp_mapping(bp, wb_comp));
-	dmae.comp_addr_hi = U64_HI(bnx2x_sp_mapping(bp, wb_comp));
-	dmae.comp_val = DMAE_COMP_VAL;
-
-	DP(BNX2X_MSG_OFF, "DMAE: opcode 0x%08x\n"
-	   DP_LEVEL "src_addr  [%x:%08x]  len [%d *4]  "
-		    "dst_addr [%x:%08x (%08x)]\n"
-	   DP_LEVEL "comp_addr [%x:%08x]  comp_val 0x%08x\n",
-	   dmae.opcode, dmae.src_addr_hi, dmae.src_addr_lo,
-	   dmae.len, dmae.dst_addr_hi, dmae.dst_addr_lo, src_addr,
-	   dmae.comp_addr_hi, dmae.comp_addr_lo, dmae.comp_val);
-
-	mutex_lock(&bp->dmae_mutex);
-
-	memset(bnx2x_sp(bp, wb_data[0]), 0, sizeof(u32) * 4);
-	*wb_comp = 0;
-
-	bnx2x_post_dmae(bp, &dmae, INIT_DMAE_C(bp));
-
-	udelay(5);
-
-	while (*wb_comp != DMAE_COMP_VAL) {
-
-		if (!cnt) {
-			BNX2X_ERR("DMAE timeout!\n");
-			break;
-		}
-		cnt--;
-		/* adjust delay for emulation/FPGA */
-		if (CHIP_REV_IS_SLOW(bp))
-			msleep(100);
-		else
-			udelay(5);
-	}
-	DP(BNX2X_MSG_OFF, "data [0x%08x 0x%08x 0x%08x 0x%08x]\n",
-	   bp->slowpath->wb_data[0], bp->slowpath->wb_data[1],
-	   bp->slowpath->wb_data[2], bp->slowpath->wb_data[3]);
-
-	mutex_unlock(&bp->dmae_mutex);
-}
-
-void bnx2x_write_dmae_phys_len(struct bnx2x *bp, dma_addr_t phys_addr,
-			       u32 addr, u32 len)
-{
-	int offset = 0;
-
-	while (len > DMAE_LEN32_WR_MAX) {
-		bnx2x_write_dmae(bp, phys_addr + offset,
-				 addr + offset, DMAE_LEN32_WR_MAX);
-		offset += DMAE_LEN32_WR_MAX * 4;
-		len -= DMAE_LEN32_WR_MAX;
-	}
-
-	bnx2x_write_dmae(bp, phys_addr + offset, addr + offset, len);
-}
-
-/* used only for slowpath so not inlined */
-static void bnx2x_wb_wr(struct bnx2x *bp, int reg, u32 val_hi, u32 val_lo)
-{
-	u32 wb_write[2];
-
-	wb_write[0] = val_hi;
-	wb_write[1] = val_lo;
-	REG_WR_DMAE(bp, reg, wb_write, 2);
-}
-
-#ifdef USE_WB_RD
-static u64 bnx2x_wb_rd(struct bnx2x *bp, int reg)
-{
-	u32 wb_data[2];
-
-	REG_RD_DMAE(bp, reg, wb_data, 2);
-
-	return HILO_U64(wb_data[0], wb_data[1]);
-}
-#endif
-
-static int bnx2x_mc_assert(struct bnx2x *bp)
-{
-	char last_idx;
-	int i, rc = 0;
-	u32 row0, row1, row2, row3;
-
-	/* XSTORM */
-	last_idx = REG_RD8(bp, BAR_XSTRORM_INTMEM +
-			   XSTORM_ASSERT_LIST_INDEX_OFFSET);
-	if (last_idx)
-		BNX2X_ERR("XSTORM_ASSERT_LIST_INDEX 0x%x\n", last_idx);
-
-	/* print the asserts */
-	for (i = 0; i < STROM_ASSERT_ARRAY_SIZE; i++) {
-
-		row0 = REG_RD(bp, BAR_XSTRORM_INTMEM +
-			      XSTORM_ASSERT_LIST_OFFSET(i));
-		row1 = REG_RD(bp, BAR_XSTRORM_INTMEM +
-			      XSTORM_ASSERT_LIST_OFFSET(i) + 4);
-		row2 = REG_RD(bp, BAR_XSTRORM_INTMEM +
-			      XSTORM_ASSERT_LIST_OFFSET(i) + 8);
-		row3 = REG_RD(bp, BAR_XSTRORM_INTMEM +
-			      XSTORM_ASSERT_LIST_OFFSET(i) + 12);
-
-		if (row0 != COMMON_ASM_INVALID_ASSERT_OPCODE) {
-			BNX2X_ERR("XSTORM_ASSERT_INDEX 0x%x = 0x%08x"
-				  " 0x%08x 0x%08x 0x%08x\n",
-				  i, row3, row2, row1, row0);
-			rc++;
-		} else {
-			break;
-		}
-	}
-
-	/* TSTORM */
-	last_idx = REG_RD8(bp, BAR_TSTRORM_INTMEM +
-			   TSTORM_ASSERT_LIST_INDEX_OFFSET);
-	if (last_idx)
-		BNX2X_ERR("TSTORM_ASSERT_LIST_INDEX 0x%x\n", last_idx);
-
-	/* print the asserts */
-	for (i = 0; i < STROM_ASSERT_ARRAY_SIZE; i++) {
-
-		row0 = REG_RD(bp, BAR_TSTRORM_INTMEM +
-			      TSTORM_ASSERT_LIST_OFFSET(i));
-		row1 = REG_RD(bp, BAR_TSTRORM_INTMEM +
-			      TSTORM_ASSERT_LIST_OFFSET(i) + 4);
-		row2 = REG_RD(bp, BAR_TSTRORM_INTMEM +
-			      TSTORM_ASSERT_LIST_OFFSET(i) + 8);
-		row3 = REG_RD(bp, BAR_TSTRORM_INTMEM +
-			      TSTORM_ASSERT_LIST_OFFSET(i) + 12);
-
-		if (row0 != COMMON_ASM_INVALID_ASSERT_OPCODE) {
-			BNX2X_ERR("TSTORM_ASSERT_INDEX 0x%x = 0x%08x"
-				  " 0x%08x 0x%08x 0x%08x\n",
-				  i, row3, row2, row1, row0);
-			rc++;
-		} else {
-			break;
-		}
-	}
-
-	/* CSTORM */
-	last_idx = REG_RD8(bp, BAR_CSTRORM_INTMEM +
-			   CSTORM_ASSERT_LIST_INDEX_OFFSET);
-	if (last_idx)
-		BNX2X_ERR("CSTORM_ASSERT_LIST_INDEX 0x%x\n", last_idx);
-
-	/* print the asserts */
-	for (i = 0; i < STROM_ASSERT_ARRAY_SIZE; i++) {
-
-		row0 = REG_RD(bp, BAR_CSTRORM_INTMEM +
-			      CSTORM_ASSERT_LIST_OFFSET(i));
-		row1 = REG_RD(bp, BAR_CSTRORM_INTMEM +
-			      CSTORM_ASSERT_LIST_OFFSET(i) + 4);
-		row2 = REG_RD(bp, BAR_CSTRORM_INTMEM +
-			      CSTORM_ASSERT_LIST_OFFSET(i) + 8);
-		row3 = REG_RD(bp, BAR_CSTRORM_INTMEM +
-			      CSTORM_ASSERT_LIST_OFFSET(i) + 12);
-
-		if (row0 != COMMON_ASM_INVALID_ASSERT_OPCODE) {
-			BNX2X_ERR("CSTORM_ASSERT_INDEX 0x%x = 0x%08x"
-				  " 0x%08x 0x%08x 0x%08x\n",
-				  i, row3, row2, row1, row0);
-			rc++;
-		} else {
-			break;
-		}
-	}
-
-	/* USTORM */
-	last_idx = REG_RD8(bp, BAR_USTRORM_INTMEM +
-			   USTORM_ASSERT_LIST_INDEX_OFFSET);
-	if (last_idx)
-		BNX2X_ERR("USTORM_ASSERT_LIST_INDEX 0x%x\n", last_idx);
-
-	/* print the asserts */
-	for (i = 0; i < STROM_ASSERT_ARRAY_SIZE; i++) {
-
-		row0 = REG_RD(bp, BAR_USTRORM_INTMEM +
-			      USTORM_ASSERT_LIST_OFFSET(i));
-		row1 = REG_RD(bp, BAR_USTRORM_INTMEM +
-			      USTORM_ASSERT_LIST_OFFSET(i) + 4);
-		row2 = REG_RD(bp, BAR_USTRORM_INTMEM +
-			      USTORM_ASSERT_LIST_OFFSET(i) + 8);
-		row3 = REG_RD(bp, BAR_USTRORM_INTMEM +
-			      USTORM_ASSERT_LIST_OFFSET(i) + 12);
-
-		if (row0 != COMMON_ASM_INVALID_ASSERT_OPCODE) {
-			BNX2X_ERR("USTORM_ASSERT_INDEX 0x%x = 0x%08x"
-				  " 0x%08x 0x%08x 0x%08x\n",
-				  i, row3, row2, row1, row0);
-			rc++;
-		} else {
-			break;
-		}
-	}
-
-	return rc;
-}
-
-static void bnx2x_fw_dump(struct bnx2x *bp)
-{
-	u32 mark, offset;
-	__be32 data[9];
-	int word;
-
-	mark = REG_RD(bp, MCP_REG_MCPR_SCRATCH + 0xf104);
-	mark = ((mark + 0x3) & ~0x3);
-	pr_err("begin fw dump (mark 0x%x)\n", mark);
-
-	pr_err("");
-	for (offset = mark - 0x08000000; offset <= 0xF900; offset += 0x8*4) {
-		for (word = 0; word < 8; word++)
-			data[word] = htonl(REG_RD(bp, MCP_REG_MCPR_SCRATCH +
-						  offset + 4*word));
-		data[8] = 0x0;
-		pr_cont("%s", (char *)data);
-	}
-	for (offset = 0xF108; offset <= mark - 0x08000000; offset += 0x8*4) {
-		for (word = 0; word < 8; word++)
-			data[word] = htonl(REG_RD(bp, MCP_REG_MCPR_SCRATCH +
-						  offset + 4*word));
-		data[8] = 0x0;
-		pr_cont("%s", (char *)data);
-	}
-	pr_err("end of fw dump\n");
-}
-
-static void bnx2x_panic_dump(struct bnx2x *bp)
-{
-	int i;
-	u16 j, start, end;
-
-	bp->stats_state = STATS_STATE_DISABLED;
-	DP(BNX2X_MSG_STATS, "stats_state - DISABLED\n");
-
-	BNX2X_ERR("begin crash dump -----------------\n");
-
-	/* Indices */
-	/* Common */
-	BNX2X_ERR("def_c_idx(%u)  def_u_idx(%u)  def_x_idx(%u)"
-		  "  def_t_idx(%u)  def_att_idx(%u)  attn_state(%u)"
-		  "  spq_prod_idx(%u)\n",
-		  bp->def_c_idx, bp->def_u_idx, bp->def_x_idx, bp->def_t_idx,
-		  bp->def_att_idx, bp->attn_state, bp->spq_prod_idx);
-
-	/* Rx */
-	for_each_queue(bp, i) {
-		struct bnx2x_fastpath *fp = &bp->fp[i];
-
-		BNX2X_ERR("fp%d: rx_bd_prod(%x)  rx_bd_cons(%x)"
-			  "  *rx_bd_cons_sb(%x)  rx_comp_prod(%x)"
-			  "  rx_comp_cons(%x)  *rx_cons_sb(%x)\n",
-			  i, fp->rx_bd_prod, fp->rx_bd_cons,
-			  le16_to_cpu(*fp->rx_bd_cons_sb), fp->rx_comp_prod,
-			  fp->rx_comp_cons, le16_to_cpu(*fp->rx_cons_sb));
-		BNX2X_ERR("      rx_sge_prod(%x)  last_max_sge(%x)"
-			  "  fp_u_idx(%x) *sb_u_idx(%x)\n",
-			  fp->rx_sge_prod, fp->last_max_sge,
-			  le16_to_cpu(fp->fp_u_idx),
-			  fp->status_blk->u_status_block.status_block_index);
-	}
-
-	/* Tx */
-	for_each_queue(bp, i) {
-		struct bnx2x_fastpath *fp = &bp->fp[i];
-
-		BNX2X_ERR("fp%d: tx_pkt_prod(%x)  tx_pkt_cons(%x)"
-			  "  tx_bd_prod(%x)  tx_bd_cons(%x)  *tx_cons_sb(%x)\n",
-			  i, fp->tx_pkt_prod, fp->tx_pkt_cons, fp->tx_bd_prod,
-			  fp->tx_bd_cons, le16_to_cpu(*fp->tx_cons_sb));
-		BNX2X_ERR("      fp_c_idx(%x)  *sb_c_idx(%x)"
-			  "  tx_db_prod(%x)\n", le16_to_cpu(fp->fp_c_idx),
-			  fp->status_blk->c_status_block.status_block_index,
-			  fp->tx_db.data.prod);
-	}
-
-	/* Rings */
-	/* Rx */
-	for_each_queue(bp, i) {
-		struct bnx2x_fastpath *fp = &bp->fp[i];
-
-		start = RX_BD(le16_to_cpu(*fp->rx_cons_sb) - 10);
-		end = RX_BD(le16_to_cpu(*fp->rx_cons_sb) + 503);
-		for (j = start; j != end; j = RX_BD(j + 1)) {
-			u32 *rx_bd = (u32 *)&fp->rx_desc_ring[j];
-			struct sw_rx_bd *sw_bd = &fp->rx_buf_ring[j];
-
-			BNX2X_ERR("fp%d: rx_bd[%x]=[%x:%x]  sw_bd=[%p]\n",
-				  i, j, rx_bd[1], rx_bd[0], sw_bd->skb);
-		}
-
-		start = RX_SGE(fp->rx_sge_prod);
-		end = RX_SGE(fp->last_max_sge);
-		for (j = start; j != end; j = RX_SGE(j + 1)) {
-			u32 *rx_sge = (u32 *)&fp->rx_sge_ring[j];
-			struct sw_rx_page *sw_page = &fp->rx_page_ring[j];
-
-			BNX2X_ERR("fp%d: rx_sge[%x]=[%x:%x]  sw_page=[%p]\n",
-				  i, j, rx_sge[1], rx_sge[0], sw_page->page);
-		}
-
-		start = RCQ_BD(fp->rx_comp_cons - 10);
-		end = RCQ_BD(fp->rx_comp_cons + 503);
-		for (j = start; j != end; j = RCQ_BD(j + 1)) {
-			u32 *cqe = (u32 *)&fp->rx_comp_ring[j];
-
-			BNX2X_ERR("fp%d: cqe[%x]=[%x:%x:%x:%x]\n",
-				  i, j, cqe[0], cqe[1], cqe[2], cqe[3]);
-		}
-	}
-
-	/* Tx */
-	for_each_queue(bp, i) {
-		struct bnx2x_fastpath *fp = &bp->fp[i];
-
-		start = TX_BD(le16_to_cpu(*fp->tx_cons_sb) - 10);
-		end = TX_BD(le16_to_cpu(*fp->tx_cons_sb) + 245);
-		for (j = start; j != end; j = TX_BD(j + 1)) {
-			struct sw_tx_bd *sw_bd = &fp->tx_buf_ring[j];
-
-			BNX2X_ERR("fp%d: packet[%x]=[%p,%x]\n",
-				  i, j, sw_bd->skb, sw_bd->first_bd);
-		}
-
-		start = TX_BD(fp->tx_bd_cons - 10);
-		end = TX_BD(fp->tx_bd_cons + 254);
-		for (j = start; j != end; j = TX_BD(j + 1)) {
-			u32 *tx_bd = (u32 *)&fp->tx_desc_ring[j];
-
-			BNX2X_ERR("fp%d: tx_bd[%x]=[%x:%x:%x:%x]\n",
-				  i, j, tx_bd[0], tx_bd[1], tx_bd[2], tx_bd[3]);
-		}
-	}
-
-	bnx2x_fw_dump(bp);
-	bnx2x_mc_assert(bp);
-	BNX2X_ERR("end crash dump -----------------\n");
-}
-
-static void bnx2x_int_enable(struct bnx2x *bp)
-{
-	int port = BP_PORT(bp);
-	u32 addr = port ? HC_REG_CONFIG_1 : HC_REG_CONFIG_0;
-	u32 val = REG_RD(bp, addr);
-	int msix = (bp->flags & USING_MSIX_FLAG) ? 1 : 0;
-	int msi = (bp->flags & USING_MSI_FLAG) ? 1 : 0;
-
-	if (msix) {
-		val &= ~(HC_CONFIG_0_REG_SINGLE_ISR_EN_0 |
-			 HC_CONFIG_0_REG_INT_LINE_EN_0);
-		val |= (HC_CONFIG_0_REG_MSI_MSIX_INT_EN_0 |
-			HC_CONFIG_0_REG_ATTN_BIT_EN_0);
-	} else if (msi) {
-		val &= ~HC_CONFIG_0_REG_INT_LINE_EN_0;
-		val |= (HC_CONFIG_0_REG_SINGLE_ISR_EN_0 |
-			HC_CONFIG_0_REG_MSI_MSIX_INT_EN_0 |
-			HC_CONFIG_0_REG_ATTN_BIT_EN_0);
-	} else {
-		val |= (HC_CONFIG_0_REG_SINGLE_ISR_EN_0 |
-			HC_CONFIG_0_REG_MSI_MSIX_INT_EN_0 |
-			HC_CONFIG_0_REG_INT_LINE_EN_0 |
-			HC_CONFIG_0_REG_ATTN_BIT_EN_0);
-
-		DP(NETIF_MSG_INTR, "write %x to HC %d (addr 0x%x)\n",
-		   val, port, addr);
-
-		REG_WR(bp, addr, val);
-
-		val &= ~HC_CONFIG_0_REG_MSI_MSIX_INT_EN_0;
-	}
-
-	DP(NETIF_MSG_INTR, "write %x to HC %d (addr 0x%x)  mode %s\n",
-	   val, port, addr, (msix ? "MSI-X" : (msi ? "MSI" : "INTx")));
-
-	REG_WR(bp, addr, val);
-	/*
-	 * Ensure that HC_CONFIG is written before leading/trailing edge config
-	 */
-	mmiowb();
-	barrier();
-
-	if (CHIP_IS_E1H(bp)) {
-		/* init leading/trailing edge */
-		if (IS_E1HMF(bp)) {
-			val = (0xee0f | (1 << (BP_E1HVN(bp) + 4)));
-			if (bp->port.pmf)
-				/* enable nig and gpio3 attention */
-				val |= 0x1100;
-		} else
-			val = 0xffff;
-
-		REG_WR(bp, HC_REG_TRAILING_EDGE_0 + port*8, val);
-		REG_WR(bp, HC_REG_LEADING_EDGE_0 + port*8, val);
-	}
-
-	/* Make sure that interrupts are indeed enabled from here on */
-	mmiowb();
-}
-
-static void bnx2x_int_disable(struct bnx2x *bp)
-{
-	int port = BP_PORT(bp);
-	u32 addr = port ? HC_REG_CONFIG_1 : HC_REG_CONFIG_0;
-	u32 val = REG_RD(bp, addr);
-
-	val &= ~(HC_CONFIG_0_REG_SINGLE_ISR_EN_0 |
-		 HC_CONFIG_0_REG_MSI_MSIX_INT_EN_0 |
-		 HC_CONFIG_0_REG_INT_LINE_EN_0 |
-		 HC_CONFIG_0_REG_ATTN_BIT_EN_0);
-
-	DP(NETIF_MSG_INTR, "write %x to HC %d (addr 0x%x)\n",
-	   val, port, addr);
-
-	/* flush all outstanding writes */
-	mmiowb();
-
-	REG_WR(bp, addr, val);
-	if (REG_RD(bp, addr) != val)
-		BNX2X_ERR("BUG! proper val not read from IGU!\n");
-}
-
-static void bnx2x_int_disable_sync(struct bnx2x *bp, int disable_hw)
-{
-	int msix = (bp->flags & USING_MSIX_FLAG) ? 1 : 0;
-	int i, offset;
-
-	/* disable interrupt handling */
-	atomic_inc(&bp->intr_sem);
-	smp_wmb(); /* Ensure that bp->intr_sem update is SMP-safe */
-
-	if (disable_hw)
-		/* prevent the HW from sending interrupts */
-		bnx2x_int_disable(bp);
-
-	/* make sure all ISRs are done */
-	if (msix) {
-		synchronize_irq(bp->msix_table[0].vector);
-		offset = 1;
-#ifdef BCM_CNIC
-		offset++;
-#endif
-		for_each_queue(bp, i)
-			synchronize_irq(bp->msix_table[i + offset].vector);
-	} else
-		synchronize_irq(bp->pdev->irq);
-
-	/* make sure sp_task is not running */
-	cancel_delayed_work(&bp->sp_task);
-	flush_workqueue(bnx2x_wq);
-}
-
-/* fast path */
-
-/*
- * General service functions
- */
-
-static inline void bnx2x_ack_sb(struct bnx2x *bp, u8 sb_id,
-				u8 storm, u16 index, u8 op, u8 update)
-{
-	u32 hc_addr = (HC_REG_COMMAND_REG + BP_PORT(bp)*32 +
-		       COMMAND_REG_INT_ACK);
-	struct igu_ack_register igu_ack;
-
-	igu_ack.status_block_index = index;
-	igu_ack.sb_id_and_flags =
-			((sb_id << IGU_ACK_REGISTER_STATUS_BLOCK_ID_SHIFT) |
-			 (storm << IGU_ACK_REGISTER_STORM_ID_SHIFT) |
-			 (update << IGU_ACK_REGISTER_UPDATE_INDEX_SHIFT) |
-			 (op << IGU_ACK_REGISTER_INTERRUPT_MODE_SHIFT));
-
-	DP(BNX2X_MSG_OFF, "write 0x%08x to HC addr 0x%x\n",
-	   (*(u32 *)&igu_ack), hc_addr);
-	REG_WR(bp, hc_addr, (*(u32 *)&igu_ack));
-
-	/* Make sure that ACK is written */
-	mmiowb();
-	barrier();
-}
-
-static inline void bnx2x_update_fpsb_idx(struct bnx2x_fastpath *fp)
-{
-	struct host_status_block *fpsb = fp->status_blk;
-
-	barrier(); /* status block is written to by the chip */
-	fp->fp_c_idx = fpsb->c_status_block.status_block_index;
-	fp->fp_u_idx = fpsb->u_status_block.status_block_index;
-}
-
-static u16 bnx2x_ack_int(struct bnx2x *bp)
-{
-	u32 hc_addr = (HC_REG_COMMAND_REG + BP_PORT(bp)*32 +
-		       COMMAND_REG_SIMD_MASK);
-	u32 result = REG_RD(bp, hc_addr);
-
-	DP(BNX2X_MSG_OFF, "read 0x%08x from HC addr 0x%x\n",
-	   result, hc_addr);
-
-	return result;
-}
-
-
-/*
- * fast path service functions
- */
-
-static inline int bnx2x_has_tx_work_unload(struct bnx2x_fastpath *fp)
-{
-	/* Tell compiler that consumer and producer can change */
-	barrier();
-	return (fp->tx_pkt_prod != fp->tx_pkt_cons);
-}
-
-/* free skb in the packet ring at pos idx
- * return idx of last bd freed
- */
-static u16 bnx2x_free_tx_pkt(struct bnx2x *bp, struct bnx2x_fastpath *fp,
-			     u16 idx)
-{
-	struct sw_tx_bd *tx_buf = &fp->tx_buf_ring[idx];
-	struct eth_tx_start_bd *tx_start_bd;
-	struct eth_tx_bd *tx_data_bd;
-	struct sk_buff *skb = tx_buf->skb;
-	u16 bd_idx = TX_BD(tx_buf->first_bd), new_cons;
-	int nbd;
-
-	/* prefetch skb end pointer to speedup dev_kfree_skb() */
-	prefetch(&skb->end);
-
-	DP(BNX2X_MSG_OFF, "pkt_idx %d  buff @(%p)->skb %p\n",
-	   idx, tx_buf, skb);
-
-	/* unmap first bd */
-	DP(BNX2X_MSG_OFF, "free bd_idx %d\n", bd_idx);
-	tx_start_bd = &fp->tx_desc_ring[bd_idx].start_bd;
-	pci_unmap_single(bp->pdev, BD_UNMAP_ADDR(tx_start_bd),
-			 BD_UNMAP_LEN(tx_start_bd), PCI_DMA_TODEVICE);
-
-	nbd = le16_to_cpu(tx_start_bd->nbd) - 1;
-#ifdef BNX2X_STOP_ON_ERROR
-	if ((nbd - 1) > (MAX_SKB_FRAGS + 2)) {
-		BNX2X_ERR("BAD nbd!\n");
-		bnx2x_panic();
-	}
-#endif
-	new_cons = nbd + tx_buf->first_bd;
-
-	/* Get the next bd */
-	bd_idx = TX_BD(NEXT_TX_IDX(bd_idx));
-
-	/* Skip a parse bd... */
-	--nbd;
-	bd_idx = TX_BD(NEXT_TX_IDX(bd_idx));
-
-	/* ...and the TSO split header bd since they have no mapping */
-	if (tx_buf->flags & BNX2X_TSO_SPLIT_BD) {
-		--nbd;
-		bd_idx = TX_BD(NEXT_TX_IDX(bd_idx));
-	}
-
-	/* now free frags */
-	while (nbd > 0) {
-
-		DP(BNX2X_MSG_OFF, "free frag bd_idx %d\n", bd_idx);
-		tx_data_bd = &fp->tx_desc_ring[bd_idx].reg_bd;
-		pci_unmap_page(bp->pdev, BD_UNMAP_ADDR(tx_data_bd),
-			       BD_UNMAP_LEN(tx_data_bd), PCI_DMA_TODEVICE);
-		if (--nbd)
-			bd_idx = TX_BD(NEXT_TX_IDX(bd_idx));
-	}
-
-	/* release skb */
-	WARN_ON(!skb);
-	dev_kfree_skb(skb);
-	tx_buf->first_bd = 0;
-	tx_buf->skb = NULL;
-
-	return new_cons;
-}
-
-static inline u16 bnx2x_tx_avail(struct bnx2x_fastpath *fp)
-{
-	s16 used;
-	u16 prod;
-	u16 cons;
-
-	barrier(); /* Tell compiler that prod and cons can change */
-	prod = fp->tx_bd_prod;
-	cons = fp->tx_bd_cons;
-
-	/* NUM_TX_RINGS = number of "next-page" entries
-	   It will be used as a threshold */
-	used = SUB_S16(prod, cons) + (s16)NUM_TX_RINGS;
-
-#ifdef BNX2X_STOP_ON_ERROR
-	WARN_ON(used < 0);
-	WARN_ON(used > fp->bp->tx_ring_size);
-	WARN_ON((fp->bp->tx_ring_size - used) > MAX_TX_AVAIL);
-#endif
-
-	return (s16)(fp->bp->tx_ring_size) - used;
-}
-
-static inline int bnx2x_has_tx_work(struct bnx2x_fastpath *fp)
-{
-	u16 hw_cons;
-
-	/* Tell compiler that status block fields can change */
-	barrier();
-	hw_cons = le16_to_cpu(*fp->tx_cons_sb);
-	return hw_cons != fp->tx_pkt_cons;
-}
-
-static int bnx2x_tx_int(struct bnx2x_fastpath *fp)
-{
-	struct bnx2x *bp = fp->bp;
-	struct netdev_queue *txq;
-	u16 hw_cons, sw_cons, bd_cons = fp->tx_bd_cons;
-
-#ifdef BNX2X_STOP_ON_ERROR
-	if (unlikely(bp->panic))
-		return -1;
-#endif
-
-	txq = netdev_get_tx_queue(bp->dev, fp->index);
-	hw_cons = le16_to_cpu(*fp->tx_cons_sb);
-	sw_cons = fp->tx_pkt_cons;
-
-	while (sw_cons != hw_cons) {
-		u16 pkt_cons;
-
-		pkt_cons = TX_BD(sw_cons);
-
-		/* prefetch(bp->tx_buf_ring[pkt_cons].skb); */
-
-		DP(NETIF_MSG_TX_DONE, "hw_cons %u  sw_cons %u  pkt_cons %u\n",
-		   hw_cons, sw_cons, pkt_cons);
-
-/*		if (NEXT_TX_IDX(sw_cons) != hw_cons) {
-			rmb();
-			prefetch(fp->tx_buf_ring[NEXT_TX_IDX(sw_cons)].skb);
-		}
-*/
-		bd_cons = bnx2x_free_tx_pkt(bp, fp, pkt_cons);
-		sw_cons++;
-	}
-
-	fp->tx_pkt_cons = sw_cons;
-	fp->tx_bd_cons = bd_cons;
-
-	/* Need to make the tx_bd_cons update visible to start_xmit()
-	 * before checking for netif_tx_queue_stopped().  Without the
-	 * memory barrier, there is a small possibility that
-	 * start_xmit() will miss it and cause the queue to be stopped
-	 * forever.
-	 */
-	smp_wmb();
-
-	/* TBD need a thresh? */
-	if (unlikely(netif_tx_queue_stopped(txq))) {
-		/* Taking tx_lock() is needed to prevent reenabling the queue
-		 * while it's empty. This could have happen if rx_action() gets
-		 * suspended in bnx2x_tx_int() after the condition before
-		 * netif_tx_wake_queue(), while tx_action (bnx2x_start_xmit()):
-		 *
-		 * stops the queue->sees fresh tx_bd_cons->releases the queue->
-		 * sends some packets consuming the whole queue again->
-		 * stops the queue
-		 */
-
-		__netif_tx_lock(txq, smp_processor_id());
-
-		if ((netif_tx_queue_stopped(txq)) &&
-		    (bp->state == BNX2X_STATE_OPEN) &&
-		    (bnx2x_tx_avail(fp) >= MAX_SKB_FRAGS + 3))
-			netif_tx_wake_queue(txq);
-
-		__netif_tx_unlock(txq);
-	}
-	return 0;
-}
-
-#ifdef BCM_CNIC
-static void bnx2x_cnic_cfc_comp(struct bnx2x *bp, int cid);
-#endif
-
-static void bnx2x_sp_event(struct bnx2x_fastpath *fp,
-			   union eth_rx_cqe *rr_cqe)
-{
-	struct bnx2x *bp = fp->bp;
-	int cid = SW_CID(rr_cqe->ramrod_cqe.conn_and_cmd_data);
-	int command = CQE_CMD(rr_cqe->ramrod_cqe.conn_and_cmd_data);
-
-	DP(BNX2X_MSG_SP,
-	   "fp %d  cid %d  got ramrod #%d  state is %x  type is %d\n",
-	   fp->index, cid, command, bp->state,
-	   rr_cqe->ramrod_cqe.ramrod_type);
-
-	bp->spq_left++;
-
-	if (fp->index) {
-		switch (command | fp->state) {
-		case (RAMROD_CMD_ID_ETH_CLIENT_SETUP |
-						BNX2X_FP_STATE_OPENING):
-			DP(NETIF_MSG_IFUP, "got MULTI[%d] setup ramrod\n",
-			   cid);
-			fp->state = BNX2X_FP_STATE_OPEN;
-			break;
-
-		case (RAMROD_CMD_ID_ETH_HALT | BNX2X_FP_STATE_HALTING):
-			DP(NETIF_MSG_IFDOWN, "got MULTI[%d] halt ramrod\n",
-			   cid);
-			fp->state = BNX2X_FP_STATE_HALTED;
-			break;
-
-		default:
-			BNX2X_ERR("unexpected MC reply (%d)  "
-				  "fp->state is %x\n", command, fp->state);
-			break;
-		}
-		mb(); /* force bnx2x_wait_ramrod() to see the change */
-		return;
-	}
-
-	switch (command | bp->state) {
-	case (RAMROD_CMD_ID_ETH_PORT_SETUP | BNX2X_STATE_OPENING_WAIT4_PORT):
-		DP(NETIF_MSG_IFUP, "got setup ramrod\n");
-		bp->state = BNX2X_STATE_OPEN;
-		break;
-
-	case (RAMROD_CMD_ID_ETH_HALT | BNX2X_STATE_CLOSING_WAIT4_HALT):
-		DP(NETIF_MSG_IFDOWN, "got halt ramrod\n");
-		bp->state = BNX2X_STATE_CLOSING_WAIT4_DELETE;
-		fp->state = BNX2X_FP_STATE_HALTED;
-		break;
-
-	case (RAMROD_CMD_ID_ETH_CFC_DEL | BNX2X_STATE_CLOSING_WAIT4_HALT):
-		DP(NETIF_MSG_IFDOWN, "got delete ramrod for MULTI[%d]\n", cid);
-		bnx2x_fp(bp, cid, state) = BNX2X_FP_STATE_CLOSED;
-		break;
-
-#ifdef BCM_CNIC
-	case (RAMROD_CMD_ID_ETH_CFC_DEL | BNX2X_STATE_OPEN):
-		DP(NETIF_MSG_IFDOWN, "got delete ramrod for CID %d\n", cid);
-		bnx2x_cnic_cfc_comp(bp, cid);
-		break;
-#endif
-
-	case (RAMROD_CMD_ID_ETH_SET_MAC | BNX2X_STATE_OPEN):
-	case (RAMROD_CMD_ID_ETH_SET_MAC | BNX2X_STATE_DIAG):
-		DP(NETIF_MSG_IFUP, "got set mac ramrod\n");
-		bp->set_mac_pending--;
-		smp_wmb();
-		break;
-
-	case (RAMROD_CMD_ID_ETH_SET_MAC | BNX2X_STATE_CLOSING_WAIT4_HALT):
-		DP(NETIF_MSG_IFDOWN, "got (un)set mac ramrod\n");
-		bp->set_mac_pending--;
-		smp_wmb();
-		break;
-
-	default:
-		BNX2X_ERR("unexpected MC reply (%d)  bp->state is %x\n",
-			  command, bp->state);
-		break;
-	}
-	mb(); /* force bnx2x_wait_ramrod() to see the change */
-}
-
-static inline void bnx2x_free_rx_sge(struct bnx2x *bp,
-				     struct bnx2x_fastpath *fp, u16 index)
-{
-	struct sw_rx_page *sw_buf = &fp->rx_page_ring[index];
-	struct page *page = sw_buf->page;
-	struct eth_rx_sge *sge = &fp->rx_sge_ring[index];
-
-	/* Skip "next page" elements */
-	if (!page)
-		return;
-
-	pci_unmap_page(bp->pdev, pci_unmap_addr(sw_buf, mapping),
-		       SGE_PAGE_SIZE*PAGES_PER_SGE, PCI_DMA_FROMDEVICE);
-	__free_pages(page, PAGES_PER_SGE_SHIFT);
-
-	sw_buf->page = NULL;
-	sge->addr_hi = 0;
-	sge->addr_lo = 0;
-}
-
-static inline void bnx2x_free_rx_sge_range(struct bnx2x *bp,
-					   struct bnx2x_fastpath *fp, int last)
-{
-	int i;
-
-	for (i = 0; i < last; i++)
-		bnx2x_free_rx_sge(bp, fp, i);
-}
-
-static inline int bnx2x_alloc_rx_sge(struct bnx2x *bp,
-				     struct bnx2x_fastpath *fp, u16 index)
-{
-	struct page *page = alloc_pages(GFP_ATOMIC, PAGES_PER_SGE_SHIFT);
-	struct sw_rx_page *sw_buf = &fp->rx_page_ring[index];
-	struct eth_rx_sge *sge = &fp->rx_sge_ring[index];
-	dma_addr_t mapping;
-
-	if (unlikely(page == NULL))
-		return -ENOMEM;
-
-	mapping = pci_map_page(bp->pdev, page, 0, SGE_PAGE_SIZE*PAGES_PER_SGE,
-			       PCI_DMA_FROMDEVICE);
-	if (unlikely(dma_mapping_error(&bp->pdev->dev, mapping))) {
-		__free_pages(page, PAGES_PER_SGE_SHIFT);
-		return -ENOMEM;
-	}
-
-	sw_buf->page = page;
-	pci_unmap_addr_set(sw_buf, mapping, mapping);
-
-	sge->addr_hi = cpu_to_le32(U64_HI(mapping));
-	sge->addr_lo = cpu_to_le32(U64_LO(mapping));
-
-	return 0;
-}
-
-static inline int bnx2x_alloc_rx_skb(struct bnx2x *bp,
-				     struct bnx2x_fastpath *fp, u16 index)
-{
-	struct sk_buff *skb;
-	struct sw_rx_bd *rx_buf = &fp->rx_buf_ring[index];
-	struct eth_rx_bd *rx_bd = &fp->rx_desc_ring[index];
-	dma_addr_t mapping;
-
-	skb = netdev_alloc_skb(bp->dev, bp->rx_buf_size);
-	if (unlikely(skb == NULL))
-		return -ENOMEM;
-
-	mapping = pci_map_single(bp->pdev, skb->data, bp->rx_buf_size,
-				 PCI_DMA_FROMDEVICE);
-	if (unlikely(dma_mapping_error(&bp->pdev->dev, mapping))) {
-		dev_kfree_skb(skb);
-		return -ENOMEM;
-	}
-
-	rx_buf->skb = skb;
-	pci_unmap_addr_set(rx_buf, mapping, mapping);
-
-	rx_bd->addr_hi = cpu_to_le32(U64_HI(mapping));
-	rx_bd->addr_lo = cpu_to_le32(U64_LO(mapping));
-
-	return 0;
-}
-
-/* note that we are not allocating a new skb,
- * we are just moving one from cons to prod
- * we are not creating a new mapping,
- * so there is no need to check for dma_mapping_error().
- */
-static void bnx2x_reuse_rx_skb(struct bnx2x_fastpath *fp,
-			       struct sk_buff *skb, u16 cons, u16 prod)
-{
-	struct bnx2x *bp = fp->bp;
-	struct sw_rx_bd *cons_rx_buf = &fp->rx_buf_ring[cons];
-	struct sw_rx_bd *prod_rx_buf = &fp->rx_buf_ring[prod];
-	struct eth_rx_bd *cons_bd = &fp->rx_desc_ring[cons];
-	struct eth_rx_bd *prod_bd = &fp->rx_desc_ring[prod];
-
-	pci_dma_sync_single_for_device(bp->pdev,
-				       pci_unmap_addr(cons_rx_buf, mapping),
-				       RX_COPY_THRESH, PCI_DMA_FROMDEVICE);
-
-	prod_rx_buf->skb = cons_rx_buf->skb;
-	pci_unmap_addr_set(prod_rx_buf, mapping,
-			   pci_unmap_addr(cons_rx_buf, mapping));
-	*prod_bd = *cons_bd;
-}
-
-static inline void bnx2x_update_last_max_sge(struct bnx2x_fastpath *fp,
-					     u16 idx)
-{
-	u16 last_max = fp->last_max_sge;
-
-	if (SUB_S16(idx, last_max) > 0)
-		fp->last_max_sge = idx;
-}
-
-static void bnx2x_clear_sge_mask_next_elems(struct bnx2x_fastpath *fp)
-{
-	int i, j;
-
-	for (i = 1; i <= NUM_RX_SGE_PAGES; i++) {
-		int idx = RX_SGE_CNT * i - 1;
-
-		for (j = 0; j < 2; j++) {
-			SGE_MASK_CLEAR_BIT(fp, idx);
-			idx--;
-		}
-	}
-}
-
-static void bnx2x_update_sge_prod(struct bnx2x_fastpath *fp,
-				  struct eth_fast_path_rx_cqe *fp_cqe)
-{
-	struct bnx2x *bp = fp->bp;
-	u16 sge_len = SGE_PAGE_ALIGN(le16_to_cpu(fp_cqe->pkt_len) -
-				     le16_to_cpu(fp_cqe->len_on_bd)) >>
-		      SGE_PAGE_SHIFT;
-	u16 last_max, last_elem, first_elem;
-	u16 delta = 0;
-	u16 i;
-
-	if (!sge_len)
-		return;
-
-	/* First mark all used pages */
-	for (i = 0; i < sge_len; i++)
-		SGE_MASK_CLEAR_BIT(fp, RX_SGE(le16_to_cpu(fp_cqe->sgl[i])));
-
-	DP(NETIF_MSG_RX_STATUS, "fp_cqe->sgl[%d] = %d\n",
-	   sge_len - 1, le16_to_cpu(fp_cqe->sgl[sge_len - 1]));
-
-	/* Here we assume that the last SGE index is the biggest */
-	prefetch((void *)(fp->sge_mask));
-	bnx2x_update_last_max_sge(fp, le16_to_cpu(fp_cqe->sgl[sge_len - 1]));
-
-	last_max = RX_SGE(fp->last_max_sge);
-	last_elem = last_max >> RX_SGE_MASK_ELEM_SHIFT;
-	first_elem = RX_SGE(fp->rx_sge_prod) >> RX_SGE_MASK_ELEM_SHIFT;
-
-	/* If ring is not full */
-	if (last_elem + 1 != first_elem)
-		last_elem++;
-
-	/* Now update the prod */
-	for (i = first_elem; i != last_elem; i = NEXT_SGE_MASK_ELEM(i)) {
-		if (likely(fp->sge_mask[i]))
-			break;
-
-		fp->sge_mask[i] = RX_SGE_MASK_ELEM_ONE_MASK;
-		delta += RX_SGE_MASK_ELEM_SZ;
-	}
-
-	if (delta > 0) {
-		fp->rx_sge_prod += delta;
-		/* clear page-end entries */
-		bnx2x_clear_sge_mask_next_elems(fp);
-	}
-
-	DP(NETIF_MSG_RX_STATUS,
-	   "fp->last_max_sge = %d  fp->rx_sge_prod = %d\n",
-	   fp->last_max_sge, fp->rx_sge_prod);
-}
-
-static inline void bnx2x_init_sge_ring_bit_mask(struct bnx2x_fastpath *fp)
-{
-	/* Set the mask to all 1-s: it's faster to compare to 0 than to 0xf-s */
-	memset(fp->sge_mask, 0xff,
-	       (NUM_RX_SGE >> RX_SGE_MASK_ELEM_SHIFT)*sizeof(u64));
-
-	/* Clear the two last indices in the page to 1:
-	   these are the indices that correspond to the "next" element,
-	   hence will never be indicated and should be removed from
-	   the calculations. */
-	bnx2x_clear_sge_mask_next_elems(fp);
-}
-
-static void bnx2x_tpa_start(struct bnx2x_fastpath *fp, u16 queue,
-			    struct sk_buff *skb, u16 cons, u16 prod)
-{
-	struct bnx2x *bp = fp->bp;
-	struct sw_rx_bd *cons_rx_buf = &fp->rx_buf_ring[cons];
-	struct sw_rx_bd *prod_rx_buf = &fp->rx_buf_ring[prod];
-	struct eth_rx_bd *prod_bd = &fp->rx_desc_ring[prod];
-	dma_addr_t mapping;
-
-	/* move empty skb from pool to prod and map it */
-	prod_rx_buf->skb = fp->tpa_pool[queue].skb;
-	mapping = pci_map_single(bp->pdev, fp->tpa_pool[queue].skb->data,
-				 bp->rx_buf_size, PCI_DMA_FROMDEVICE);
-	pci_unmap_addr_set(prod_rx_buf, mapping, mapping);
-
-	/* move partial skb from cons to pool (don't unmap yet) */
-	fp->tpa_pool[queue] = *cons_rx_buf;
-
-	/* mark bin state as start - print error if current state != stop */
-	if (fp->tpa_state[queue] != BNX2X_TPA_STOP)
-		BNX2X_ERR("start of bin not in stop [%d]\n", queue);
-
-	fp->tpa_state[queue] = BNX2X_TPA_START;
-
-	/* point prod_bd to new skb */
-	prod_bd->addr_hi = cpu_to_le32(U64_HI(mapping));
-	prod_bd->addr_lo = cpu_to_le32(U64_LO(mapping));
-
-#ifdef BNX2X_STOP_ON_ERROR
-	fp->tpa_queue_used |= (1 << queue);
-#ifdef __powerpc64__
-	DP(NETIF_MSG_RX_STATUS, "fp->tpa_queue_used = 0x%lx\n",
-#else
-	DP(NETIF_MSG_RX_STATUS, "fp->tpa_queue_used = 0x%llx\n",
-#endif
-	   fp->tpa_queue_used);
-#endif
-}
-
-static int bnx2x_fill_frag_skb(struct bnx2x *bp, struct bnx2x_fastpath *fp,
-			       struct sk_buff *skb,
-			       struct eth_fast_path_rx_cqe *fp_cqe,
-			       u16 cqe_idx)
-{
-	struct sw_rx_page *rx_pg, old_rx_pg;
-	u16 len_on_bd = le16_to_cpu(fp_cqe->len_on_bd);
-	u32 i, frag_len, frag_size, pages;
-	int err;
-	int j;
-
-	frag_size = le16_to_cpu(fp_cqe->pkt_len) - len_on_bd;
-	pages = SGE_PAGE_ALIGN(frag_size) >> SGE_PAGE_SHIFT;
-
-	/* This is needed in order to enable forwarding support */
-	if (frag_size)
-		skb_shinfo(skb)->gso_size = min((u32)SGE_PAGE_SIZE,
-					       max(frag_size, (u32)len_on_bd));
-
-#ifdef BNX2X_STOP_ON_ERROR
-	if (pages >
-	    min((u32)8, (u32)MAX_SKB_FRAGS) * SGE_PAGE_SIZE * PAGES_PER_SGE) {
-		BNX2X_ERR("SGL length is too long: %d. CQE index is %d\n",
-			  pages, cqe_idx);
-		BNX2X_ERR("fp_cqe->pkt_len = %d  fp_cqe->len_on_bd = %d\n",
-			  fp_cqe->pkt_len, len_on_bd);
-		bnx2x_panic();
-		return -EINVAL;
-	}
-#endif
-
-	/* Run through the SGL and compose the fragmented skb */
-	for (i = 0, j = 0; i < pages; i += PAGES_PER_SGE, j++) {
-		u16 sge_idx = RX_SGE(le16_to_cpu(fp_cqe->sgl[j]));
-
-		/* FW gives the indices of the SGE as if the ring is an array
-		   (meaning that "next" element will consume 2 indices) */
-		frag_len = min(frag_size, (u32)(SGE_PAGE_SIZE*PAGES_PER_SGE));
-		rx_pg = &fp->rx_page_ring[sge_idx];
-		old_rx_pg = *rx_pg;
-
-		/* If we fail to allocate a substitute page, we simply stop
-		   where we are and drop the whole packet */
-		err = bnx2x_alloc_rx_sge(bp, fp, sge_idx);
-		if (unlikely(err)) {
-			fp->eth_q_stats.rx_skb_alloc_failed++;
-			return err;
-		}
-
-		/* Unmap the page as we r going to pass it to the stack */
-		pci_unmap_page(bp->pdev, pci_unmap_addr(&old_rx_pg, mapping),
-			      SGE_PAGE_SIZE*PAGES_PER_SGE, PCI_DMA_FROMDEVICE);
-
-		/* Add one frag and update the appropriate fields in the skb */
-		skb_fill_page_desc(skb, j, old_rx_pg.page, 0, frag_len);
-
-		skb->data_len += frag_len;
-		skb->truesize += frag_len;
-		skb->len += frag_len;
-
-		frag_size -= frag_len;
-	}
-
-	return 0;
-}
-
-static void bnx2x_tpa_stop(struct bnx2x *bp, struct bnx2x_fastpath *fp,
-			   u16 queue, int pad, int len, union eth_rx_cqe *cqe,
-			   u16 cqe_idx)
-{
-	struct sw_rx_bd *rx_buf = &fp->tpa_pool[queue];
-	struct sk_buff *skb = rx_buf->skb;
-	/* alloc new skb */
-	struct sk_buff *new_skb = netdev_alloc_skb(bp->dev, bp->rx_buf_size);
-
-	/* Unmap skb in the pool anyway, as we are going to change
-	   pool entry status to BNX2X_TPA_STOP even if new skb allocation
-	   fails. */
-	pci_unmap_single(bp->pdev, pci_unmap_addr(rx_buf, mapping),
-			 bp->rx_buf_size, PCI_DMA_FROMDEVICE);
-
-	if (likely(new_skb)) {
-		/* fix ip xsum and give it to the stack */
-		/* (no need to map the new skb) */
-#ifdef BCM_VLAN
-		int is_vlan_cqe =
-			(le16_to_cpu(cqe->fast_path_cqe.pars_flags.flags) &
-			 PARSING_FLAGS_VLAN);
-		int is_not_hwaccel_vlan_cqe =
-			(is_vlan_cqe && (!(bp->flags & HW_VLAN_RX_FLAG)));
-#endif
-
-		prefetch(skb);
-		prefetch(((char *)(skb)) + 128);
-
-#ifdef BNX2X_STOP_ON_ERROR
-		if (pad + len > bp->rx_buf_size) {
-			BNX2X_ERR("skb_put is about to fail...  "
-				  "pad %d  len %d  rx_buf_size %d\n",
-				  pad, len, bp->rx_buf_size);
-			bnx2x_panic();
-			return;
-		}
-#endif
-
-		skb_reserve(skb, pad);
-		skb_put(skb, len);
-
-		skb->protocol = eth_type_trans(skb, bp->dev);
-		skb->ip_summed = CHECKSUM_UNNECESSARY;
-
-		{
-			struct iphdr *iph;
-
-			iph = (struct iphdr *)skb->data;
-#ifdef BCM_VLAN
-			/* If there is no Rx VLAN offloading -
-			   take VLAN tag into an account */
-			if (unlikely(is_not_hwaccel_vlan_cqe))
-				iph = (struct iphdr *)((u8 *)iph + VLAN_HLEN);
-#endif
-			iph->check = 0;
-			iph->check = ip_fast_csum((u8 *)iph, iph->ihl);
-		}
-
-		if (!bnx2x_fill_frag_skb(bp, fp, skb,
-					 &cqe->fast_path_cqe, cqe_idx)) {
-#ifdef BCM_VLAN
-			if ((bp->vlgrp != NULL) && is_vlan_cqe &&
-			    (!is_not_hwaccel_vlan_cqe))
-				vlan_hwaccel_receive_skb(skb, bp->vlgrp,
-						le16_to_cpu(cqe->fast_path_cqe.
-							    vlan_tag));
-			else
-#endif
-				netif_receive_skb(skb);
-		} else {
-			DP(NETIF_MSG_RX_STATUS, "Failed to allocate new pages"
-			   " - dropping packet!\n");
-			dev_kfree_skb(skb);
-		}
-
-
-		/* put new skb in bin */
-		fp->tpa_pool[queue].skb = new_skb;
-
-	} else {
-		/* else drop the packet and keep the buffer in the bin */
-		DP(NETIF_MSG_RX_STATUS,
-		   "Failed to allocate new skb - dropping packet!\n");
-		fp->eth_q_stats.rx_skb_alloc_failed++;
-	}
-
-	fp->tpa_state[queue] = BNX2X_TPA_STOP;
-}
-
-static inline void bnx2x_update_rx_prod(struct bnx2x *bp,
-					struct bnx2x_fastpath *fp,
-					u16 bd_prod, u16 rx_comp_prod,
-					u16 rx_sge_prod)
-{
-	struct ustorm_eth_rx_producers rx_prods = {0};
-	int i;
-
-	/* Update producers */
-	rx_prods.bd_prod = bd_prod;
-	rx_prods.cqe_prod = rx_comp_prod;
-	rx_prods.sge_prod = rx_sge_prod;
-
-	/*
-	 * Make sure that the BD and SGE data is updated before updating the
-	 * producers since FW might read the BD/SGE right after the producer
-	 * is updated.
-	 * This is only applicable for weak-ordered memory model archs such
-	 * as IA-64. The following barrier is also mandatory since FW will
-	 * assumes BDs must have buffers.
-	 */
-	wmb();
-
-	for (i = 0; i < sizeof(struct ustorm_eth_rx_producers)/4; i++)
-		REG_WR(bp, BAR_USTRORM_INTMEM +
-		       USTORM_RX_PRODS_OFFSET(BP_PORT(bp), fp->cl_id) + i*4,
-		       ((u32 *)&rx_prods)[i]);
-
-	mmiowb(); /* keep prod updates ordered */
-
-	DP(NETIF_MSG_RX_STATUS,
-	   "queue[%d]:  wrote  bd_prod %u  cqe_prod %u  sge_prod %u\n",
-	   fp->index, bd_prod, rx_comp_prod, rx_sge_prod);
-}
-
-static int bnx2x_rx_int(struct bnx2x_fastpath *fp, int budget)
-{
-	struct bnx2x *bp = fp->bp;
-	u16 bd_cons, bd_prod, bd_prod_fw, comp_ring_cons;
-	u16 hw_comp_cons, sw_comp_cons, sw_comp_prod;
-	int rx_pkt = 0;
-
-#ifdef BNX2X_STOP_ON_ERROR
-	if (unlikely(bp->panic))
-		return 0;
-#endif
-
-	/* CQ "next element" is of the size of the regular element,
-	   that's why it's ok here */
-	hw_comp_cons = le16_to_cpu(*fp->rx_cons_sb);
-	if ((hw_comp_cons & MAX_RCQ_DESC_CNT) == MAX_RCQ_DESC_CNT)
-		hw_comp_cons++;
-
-	bd_cons = fp->rx_bd_cons;
-	bd_prod = fp->rx_bd_prod;
-	bd_prod_fw = bd_prod;
-	sw_comp_cons = fp->rx_comp_cons;
-	sw_comp_prod = fp->rx_comp_prod;
-
-	/* Memory barrier necessary as speculative reads of the rx
-	 * buffer can be ahead of the index in the status block
-	 */
-	rmb();
-
-	DP(NETIF_MSG_RX_STATUS,
-	   "queue[%d]:  hw_comp_cons %u  sw_comp_cons %u\n",
-	   fp->index, hw_comp_cons, sw_comp_cons);
-
-	while (sw_comp_cons != hw_comp_cons) {
-		struct sw_rx_bd *rx_buf = NULL;
-		struct sk_buff *skb;
-		union eth_rx_cqe *cqe;
-		u8 cqe_fp_flags;
-		u16 len, pad;
-
-		comp_ring_cons = RCQ_BD(sw_comp_cons);
-		bd_prod = RX_BD(bd_prod);
-		bd_cons = RX_BD(bd_cons);
-
-		/* Prefetch the page containing the BD descriptor
-		   at producer's index. It will be needed when new skb is
-		   allocated */
-		prefetch((void *)(PAGE_ALIGN((unsigned long)
-					     (&fp->rx_desc_ring[bd_prod])) -
-				  PAGE_SIZE + 1));
-
-		cqe = &fp->rx_comp_ring[comp_ring_cons];
-		cqe_fp_flags = cqe->fast_path_cqe.type_error_flags;
-
-		DP(NETIF_MSG_RX_STATUS, "CQE type %x  err %x  status %x"
-		   "  queue %x  vlan %x  len %u\n", CQE_TYPE(cqe_fp_flags),
-		   cqe_fp_flags, cqe->fast_path_cqe.status_flags,
-		   le32_to_cpu(cqe->fast_path_cqe.rss_hash_result),
-		   le16_to_cpu(cqe->fast_path_cqe.vlan_tag),
-		   le16_to_cpu(cqe->fast_path_cqe.pkt_len));
-
-		/* is this a slowpath msg? */
-		if (unlikely(CQE_TYPE(cqe_fp_flags))) {
-			bnx2x_sp_event(fp, cqe);
-			goto next_cqe;
-
-		/* this is an rx packet */
-		} else {
-			rx_buf = &fp->rx_buf_ring[bd_cons];
-			skb = rx_buf->skb;
-			prefetch(skb);
-			prefetch((u8 *)skb + 256);
-			len = le16_to_cpu(cqe->fast_path_cqe.pkt_len);
-			pad = cqe->fast_path_cqe.placement_offset;
-
-			/* If CQE is marked both TPA_START and TPA_END
-			   it is a non-TPA CQE */
-			if ((!fp->disable_tpa) &&
-			    (TPA_TYPE(cqe_fp_flags) !=
-					(TPA_TYPE_START | TPA_TYPE_END))) {
-				u16 queue = cqe->fast_path_cqe.queue_index;
-
-				if (TPA_TYPE(cqe_fp_flags) == TPA_TYPE_START) {
-					DP(NETIF_MSG_RX_STATUS,
-					   "calling tpa_start on queue %d\n",
-					   queue);
-
-					bnx2x_tpa_start(fp, queue, skb,
-							bd_cons, bd_prod);
-					goto next_rx;
-				}
-
-				if (TPA_TYPE(cqe_fp_flags) == TPA_TYPE_END) {
-					DP(NETIF_MSG_RX_STATUS,
-					   "calling tpa_stop on queue %d\n",
-					   queue);
-
-					if (!BNX2X_RX_SUM_FIX(cqe))
-						BNX2X_ERR("STOP on none TCP "
-							  "data\n");
-
-					/* This is a size of the linear data
-					   on this skb */
-					len = le16_to_cpu(cqe->fast_path_cqe.
-								len_on_bd);
-					bnx2x_tpa_stop(bp, fp, queue, pad,
-						    len, cqe, comp_ring_cons);
-#ifdef BNX2X_STOP_ON_ERROR
-					if (bp->panic)
-						return 0;
-#endif
-
-					bnx2x_update_sge_prod(fp,
-							&cqe->fast_path_cqe);
-					goto next_cqe;
-				}
-			}
-
-			pci_dma_sync_single_for_device(bp->pdev,
-					pci_unmap_addr(rx_buf, mapping),
-						       pad + RX_COPY_THRESH,
-						       PCI_DMA_FROMDEVICE);
-			prefetch(skb);
-			prefetch(((char *)(skb)) + 128);
-
-			/* is this an error packet? */
-			if (unlikely(cqe_fp_flags & ETH_RX_ERROR_FALGS)) {
-				DP(NETIF_MSG_RX_ERR,
-				   "ERROR  flags %x  rx packet %u\n",
-				   cqe_fp_flags, sw_comp_cons);
-				fp->eth_q_stats.rx_err_discard_pkt++;
-				goto reuse_rx;
-			}
-
-			/* Since we don't have a jumbo ring
-			 * copy small packets if mtu > 1500
-			 */
-			if ((bp->dev->mtu > ETH_MAX_PACKET_SIZE) &&
-			    (len <= RX_COPY_THRESH)) {
-				struct sk_buff *new_skb;
-
-				new_skb = netdev_alloc_skb(bp->dev,
-							   len + pad);
-				if (new_skb == NULL) {
-					DP(NETIF_MSG_RX_ERR,
-					   "ERROR  packet dropped "
-					   "because of alloc failure\n");
-					fp->eth_q_stats.rx_skb_alloc_failed++;
-					goto reuse_rx;
-				}
-
-				/* aligned copy */
-				skb_copy_from_linear_data_offset(skb, pad,
-						    new_skb->data + pad, len);
-				skb_reserve(new_skb, pad);
-				skb_put(new_skb, len);
-
-				bnx2x_reuse_rx_skb(fp, skb, bd_cons, bd_prod);
-
-				skb = new_skb;
-
-			} else
-			if (likely(bnx2x_alloc_rx_skb(bp, fp, bd_prod) == 0)) {
-				pci_unmap_single(bp->pdev,
-					pci_unmap_addr(rx_buf, mapping),
-						 bp->rx_buf_size,
-						 PCI_DMA_FROMDEVICE);
-				skb_reserve(skb, pad);
-				skb_put(skb, len);
-
-			} else {
-				DP(NETIF_MSG_RX_ERR,
-				   "ERROR  packet dropped because "
-				   "of alloc failure\n");
-				fp->eth_q_stats.rx_skb_alloc_failed++;
-reuse_rx:
-				bnx2x_reuse_rx_skb(fp, skb, bd_cons, bd_prod);
-				goto next_rx;
-			}
-
-			skb->protocol = eth_type_trans(skb, bp->dev);
-
-			skb->ip_summed = CHECKSUM_NONE;
-			if (bp->rx_csum) {
-				if (likely(BNX2X_RX_CSUM_OK(cqe)))
-					skb->ip_summed = CHECKSUM_UNNECESSARY;
-				else
-					fp->eth_q_stats.hw_csum_err++;
-			}
-		}
-
-		skb_record_rx_queue(skb, fp->index);
-
-#ifdef BCM_VLAN
-		if ((bp->vlgrp != NULL) && (bp->flags & HW_VLAN_RX_FLAG) &&
-		    (le16_to_cpu(cqe->fast_path_cqe.pars_flags.flags) &
-		     PARSING_FLAGS_VLAN))
-			vlan_hwaccel_receive_skb(skb, bp->vlgrp,
-				le16_to_cpu(cqe->fast_path_cqe.vlan_tag));
-		else
-#endif
-			netif_receive_skb(skb);
-
-
-next_rx:
-		rx_buf->skb = NULL;
-
-		bd_cons = NEXT_RX_IDX(bd_cons);
-		bd_prod = NEXT_RX_IDX(bd_prod);
-		bd_prod_fw = NEXT_RX_IDX(bd_prod_fw);
-		rx_pkt++;
-next_cqe:
-		sw_comp_prod = NEXT_RCQ_IDX(sw_comp_prod);
-		sw_comp_cons = NEXT_RCQ_IDX(sw_comp_cons);
-
-		if (rx_pkt == budget)
-			break;
-	} /* while */
-
-	fp->rx_bd_cons = bd_cons;
-	fp->rx_bd_prod = bd_prod_fw;
-	fp->rx_comp_cons = sw_comp_cons;
-	fp->rx_comp_prod = sw_comp_prod;
-
-	/* Update producers */
-	bnx2x_update_rx_prod(bp, fp, bd_prod_fw, sw_comp_prod,
-			     fp->rx_sge_prod);
-
-	fp->rx_pkt += rx_pkt;
-	fp->rx_calls++;
-
-	return rx_pkt;
-}
-
-static irqreturn_t bnx2x_msix_fp_int(int irq, void *fp_cookie)
-{
-	struct bnx2x_fastpath *fp = fp_cookie;
-	struct bnx2x *bp = fp->bp;
-
-	/* Return here if interrupt is disabled */
-	if (unlikely(atomic_read(&bp->intr_sem) != 0)) {
-		DP(NETIF_MSG_INTR, "called but intr_sem not 0, returning\n");
-		return IRQ_HANDLED;
-	}
-
-	DP(BNX2X_MSG_FP, "got an MSI-X interrupt on IDX:SB [%d:%d]\n",
-	   fp->index, fp->sb_id);
-	bnx2x_ack_sb(bp, fp->sb_id, USTORM_ID, 0, IGU_INT_DISABLE, 0);
-
-#ifdef BNX2X_STOP_ON_ERROR
-	if (unlikely(bp->panic))
-		return IRQ_HANDLED;
-#endif
-
-	/* Handle Rx and Tx according to MSI-X vector */
-	prefetch(fp->rx_cons_sb);
-	prefetch(fp->tx_cons_sb);
-	prefetch(&fp->status_blk->u_status_block.status_block_index);
-	prefetch(&fp->status_blk->c_status_block.status_block_index);
-	napi_schedule(&bnx2x_fp(bp, fp->index, napi));
-
-	return IRQ_HANDLED;
-}
-
-static irqreturn_t bnx2x_interrupt(int irq, void *dev_instance)
-{
-	struct bnx2x *bp = netdev_priv(dev_instance);
-	u16 status = bnx2x_ack_int(bp);
-	u16 mask;
-	int i;
-
-	/* Return here if interrupt is shared and it's not for us */
-	if (unlikely(status == 0)) {
-		DP(NETIF_MSG_INTR, "not our interrupt!\n");
-		return IRQ_NONE;
-	}
-	DP(NETIF_MSG_INTR, "got an interrupt  status 0x%x\n", status);
-
-	/* Return here if interrupt is disabled */
-	if (unlikely(atomic_read(&bp->intr_sem) != 0)) {
-		DP(NETIF_MSG_INTR, "called but intr_sem not 0, returning\n");
-		return IRQ_HANDLED;
-	}
-
-#ifdef BNX2X_STOP_ON_ERROR
-	if (unlikely(bp->panic))
-		return IRQ_HANDLED;
-#endif
-
-	for (i = 0; i < BNX2X_NUM_QUEUES(bp); i++) {
-		struct bnx2x_fastpath *fp = &bp->fp[i];
-
-		mask = 0x2 << fp->sb_id;
-		if (status & mask) {
-			/* Handle Rx and Tx according to SB id */
-			prefetch(fp->rx_cons_sb);
-			prefetch(&fp->status_blk->u_status_block.
-						status_block_index);
-			prefetch(fp->tx_cons_sb);
-			prefetch(&fp->status_blk->c_status_block.
-						status_block_index);
-			napi_schedule(&bnx2x_fp(bp, fp->index, napi));
-			status &= ~mask;
-		}
-	}
-
-#ifdef BCM_CNIC
-	mask = 0x2 << CNIC_SB_ID(bp);
-	if (status & (mask | 0x1)) {
-		struct cnic_ops *c_ops = NULL;
-
-		rcu_read_lock();
-		c_ops = rcu_dereference(bp->cnic_ops);
-		if (c_ops)
-			c_ops->cnic_handler(bp->cnic_data, NULL);
-		rcu_read_unlock();
-
-		status &= ~mask;
-	}
-#endif
-
-	if (unlikely(status & 0x1)) {
-		queue_delayed_work(bnx2x_wq, &bp->sp_task, 0);
-
-		status &= ~0x1;
-		if (!status)
-			return IRQ_HANDLED;
-	}
-
-	if (status)
-		DP(NETIF_MSG_INTR, "got an unknown interrupt! (status %u)\n",
-		   status);
-
-	return IRQ_HANDLED;
-}
-
-/* end of fast path */
-
-static void bnx2x_stats_handle(struct bnx2x *bp, enum bnx2x_stats_event event);
-
-/* Link */
-
-/*
- * General service functions
- */
-
-static int bnx2x_acquire_hw_lock(struct bnx2x *bp, u32 resource)
-{
-	u32 lock_status;
-	u32 resource_bit = (1 << resource);
-	int func = BP_FUNC(bp);
-	u32 hw_lock_control_reg;
-	int cnt;
-
-	/* Validating that the resource is within range */
-	if (resource > HW_LOCK_MAX_RESOURCE_VALUE) {
-		DP(NETIF_MSG_HW,
-		   "resource(0x%x) > HW_LOCK_MAX_RESOURCE_VALUE(0x%x)\n",
-		   resource, HW_LOCK_MAX_RESOURCE_VALUE);
-		return -EINVAL;
-	}
-
-	if (func <= 5) {
-		hw_lock_control_reg = (MISC_REG_DRIVER_CONTROL_1 + func*8);
-	} else {
-		hw_lock_control_reg =
-				(MISC_REG_DRIVER_CONTROL_7 + (func - 6)*8);
-	}
-
-	/* Validating that the resource is not already taken */
-	lock_status = REG_RD(bp, hw_lock_control_reg);
-	if (lock_status & resource_bit) {
-		DP(NETIF_MSG_HW, "lock_status 0x%x  resource_bit 0x%x\n",
-		   lock_status, resource_bit);
-		return -EEXIST;
-	}
-
-	/* Try for 5 second every 5ms */
-	for (cnt = 0; cnt < 1000; cnt++) {
-		/* Try to acquire the lock */
-		REG_WR(bp, hw_lock_control_reg + 4, resource_bit);
-		lock_status = REG_RD(bp, hw_lock_control_reg);
-		if (lock_status & resource_bit)
-			return 0;
-
-		msleep(5);
-	}
-	DP(NETIF_MSG_HW, "Timeout\n");
-	return -EAGAIN;
-}
-
-static int bnx2x_release_hw_lock(struct bnx2x *bp, u32 resource)
-{
-	u32 lock_status;
-	u32 resource_bit = (1 << resource);
-	int func = BP_FUNC(bp);
-	u32 hw_lock_control_reg;
-
-	/* Validating that the resource is within range */
-	if (resource > HW_LOCK_MAX_RESOURCE_VALUE) {
-		DP(NETIF_MSG_HW,
-		   "resource(0x%x) > HW_LOCK_MAX_RESOURCE_VALUE(0x%x)\n",
-		   resource, HW_LOCK_MAX_RESOURCE_VALUE);
-		return -EINVAL;
-	}
-
-	if (func <= 5) {
-		hw_lock_control_reg = (MISC_REG_DRIVER_CONTROL_1 + func*8);
-	} else {
-		hw_lock_control_reg =
-				(MISC_REG_DRIVER_CONTROL_7 + (func - 6)*8);
-	}
-
-	/* Validating that the resource is currently taken */
-	lock_status = REG_RD(bp, hw_lock_control_reg);
-	if (!(lock_status & resource_bit)) {
-		DP(NETIF_MSG_HW, "lock_status 0x%x  resource_bit 0x%x\n",
-		   lock_status, resource_bit);
-		return -EFAULT;
-	}
-
-	REG_WR(bp, hw_lock_control_reg, resource_bit);
-	return 0;
-}
-
-/* HW Lock for shared dual port PHYs */
-static void bnx2x_acquire_phy_lock(struct bnx2x *bp)
-{
-	mutex_lock(&bp->port.phy_mutex);
-
-	if (bp->port.need_hw_lock)
-		bnx2x_acquire_hw_lock(bp, HW_LOCK_RESOURCE_MDIO);
-}
-
-static void bnx2x_release_phy_lock(struct bnx2x *bp)
-{
-	if (bp->port.need_hw_lock)
-		bnx2x_release_hw_lock(bp, HW_LOCK_RESOURCE_MDIO);
-
-	mutex_unlock(&bp->port.phy_mutex);
-}
-
-int bnx2x_get_gpio(struct bnx2x *bp, int gpio_num, u8 port)
-{
-	/* The GPIO should be swapped if swap register is set and active */
-	int gpio_port = (REG_RD(bp, NIG_REG_PORT_SWAP) &&
-			 REG_RD(bp, NIG_REG_STRAP_OVERRIDE)) ^ port;
-	int gpio_shift = gpio_num +
-			(gpio_port ? MISC_REGISTERS_GPIO_PORT_SHIFT : 0);
-	u32 gpio_mask = (1 << gpio_shift);
-	u32 gpio_reg;
-	int value;
-
-	if (gpio_num > MISC_REGISTERS_GPIO_3) {
-		BNX2X_ERR("Invalid GPIO %d\n", gpio_num);
-		return -EINVAL;
-	}
-
-	/* read GPIO value */
-	gpio_reg = REG_RD(bp, MISC_REG_GPIO);
-
-	/* get the requested pin value */
-	if ((gpio_reg & gpio_mask) == gpio_mask)
-		value = 1;
-	else
-		value = 0;
-
-	DP(NETIF_MSG_LINK, "pin %d  value 0x%x\n", gpio_num, value);
-
-	return value;
-}
-
-int bnx2x_set_gpio(struct bnx2x *bp, int gpio_num, u32 mode, u8 port)
-{
-	/* The GPIO should be swapped if swap register is set and active */
-	int gpio_port = (REG_RD(bp, NIG_REG_PORT_SWAP) &&
-			 REG_RD(bp, NIG_REG_STRAP_OVERRIDE)) ^ port;
-	int gpio_shift = gpio_num +
-			(gpio_port ? MISC_REGISTERS_GPIO_PORT_SHIFT : 0);
-	u32 gpio_mask = (1 << gpio_shift);
-	u32 gpio_reg;
-
-	if (gpio_num > MISC_REGISTERS_GPIO_3) {
-		BNX2X_ERR("Invalid GPIO %d\n", gpio_num);
-		return -EINVAL;
-	}
-
-	bnx2x_acquire_hw_lock(bp, HW_LOCK_RESOURCE_GPIO);
-	/* read GPIO and mask except the float bits */
-	gpio_reg = (REG_RD(bp, MISC_REG_GPIO) & MISC_REGISTERS_GPIO_FLOAT);
-
-	switch (mode) {
-	case MISC_REGISTERS_GPIO_OUTPUT_LOW:
-		DP(NETIF_MSG_LINK, "Set GPIO %d (shift %d) -> output low\n",
-		   gpio_num, gpio_shift);
-		/* clear FLOAT and set CLR */
-		gpio_reg &= ~(gpio_mask << MISC_REGISTERS_GPIO_FLOAT_POS);
-		gpio_reg |=  (gpio_mask << MISC_REGISTERS_GPIO_CLR_POS);
-		break;
-
-	case MISC_REGISTERS_GPIO_OUTPUT_HIGH:
-		DP(NETIF_MSG_LINK, "Set GPIO %d (shift %d) -> output high\n",
-		   gpio_num, gpio_shift);
-		/* clear FLOAT and set SET */
-		gpio_reg &= ~(gpio_mask << MISC_REGISTERS_GPIO_FLOAT_POS);
-		gpio_reg |=  (gpio_mask << MISC_REGISTERS_GPIO_SET_POS);
-		break;
-
-	case MISC_REGISTERS_GPIO_INPUT_HI_Z:
-		DP(NETIF_MSG_LINK, "Set GPIO %d (shift %d) -> input\n",
-		   gpio_num, gpio_shift);
-		/* set FLOAT */
-		gpio_reg |= (gpio_mask << MISC_REGISTERS_GPIO_FLOAT_POS);
-		break;
-
-	default:
-		break;
-	}
-
-	REG_WR(bp, MISC_REG_GPIO, gpio_reg);
-	bnx2x_release_hw_lock(bp, HW_LOCK_RESOURCE_GPIO);
-
-	return 0;
-}
-
-int bnx2x_set_gpio_int(struct bnx2x *bp, int gpio_num, u32 mode, u8 port)
-{
-	/* The GPIO should be swapped if swap register is set and active */
-	int gpio_port = (REG_RD(bp, NIG_REG_PORT_SWAP) &&
-			 REG_RD(bp, NIG_REG_STRAP_OVERRIDE)) ^ port;
-	int gpio_shift = gpio_num +
-			(gpio_port ? MISC_REGISTERS_GPIO_PORT_SHIFT : 0);
-	u32 gpio_mask = (1 << gpio_shift);
-	u32 gpio_reg;
-
-	if (gpio_num > MISC_REGISTERS_GPIO_3) {
-		BNX2X_ERR("Invalid GPIO %d\n", gpio_num);
-		return -EINVAL;
-	}
-
-	bnx2x_acquire_hw_lock(bp, HW_LOCK_RESOURCE_GPIO);
-	/* read GPIO int */
-	gpio_reg = REG_RD(bp, MISC_REG_GPIO_INT);
-
-	switch (mode) {
-	case MISC_REGISTERS_GPIO_INT_OUTPUT_CLR:
-		DP(NETIF_MSG_LINK, "Clear GPIO INT %d (shift %d) -> "
-				   "output low\n", gpio_num, gpio_shift);
-		/* clear SET and set CLR */
-		gpio_reg &= ~(gpio_mask << MISC_REGISTERS_GPIO_INT_SET_POS);
-		gpio_reg |=  (gpio_mask << MISC_REGISTERS_GPIO_INT_CLR_POS);
-		break;
-
-	case MISC_REGISTERS_GPIO_INT_OUTPUT_SET:
-		DP(NETIF_MSG_LINK, "Set GPIO INT %d (shift %d) -> "
-				   "output high\n", gpio_num, gpio_shift);
-		/* clear CLR and set SET */
-		gpio_reg &= ~(gpio_mask << MISC_REGISTERS_GPIO_INT_CLR_POS);
-		gpio_reg |=  (gpio_mask << MISC_REGISTERS_GPIO_INT_SET_POS);
-		break;
-
-	default:
-		break;
-	}
-
-	REG_WR(bp, MISC_REG_GPIO_INT, gpio_reg);
-	bnx2x_release_hw_lock(bp, HW_LOCK_RESOURCE_GPIO);
-
-	return 0;
-}
-
-static int bnx2x_set_spio(struct bnx2x *bp, int spio_num, u32 mode)
-{
-	u32 spio_mask = (1 << spio_num);
-	u32 spio_reg;
-
-	if ((spio_num < MISC_REGISTERS_SPIO_4) ||
-	    (spio_num > MISC_REGISTERS_SPIO_7)) {
-		BNX2X_ERR("Invalid SPIO %d\n", spio_num);
-		return -EINVAL;
-	}
-
-	bnx2x_acquire_hw_lock(bp, HW_LOCK_RESOURCE_SPIO);
-	/* read SPIO and mask except the float bits */
-	spio_reg = (REG_RD(bp, MISC_REG_SPIO) & MISC_REGISTERS_SPIO_FLOAT);
-
-	switch (mode) {
-	case MISC_REGISTERS_SPIO_OUTPUT_LOW:
-		DP(NETIF_MSG_LINK, "Set SPIO %d -> output low\n", spio_num);
-		/* clear FLOAT and set CLR */
-		spio_reg &= ~(spio_mask << MISC_REGISTERS_SPIO_FLOAT_POS);
-		spio_reg |=  (spio_mask << MISC_REGISTERS_SPIO_CLR_POS);
-		break;
-
-	case MISC_REGISTERS_SPIO_OUTPUT_HIGH:
-		DP(NETIF_MSG_LINK, "Set SPIO %d -> output high\n", spio_num);
-		/* clear FLOAT and set SET */
-		spio_reg &= ~(spio_mask << MISC_REGISTERS_SPIO_FLOAT_POS);
-		spio_reg |=  (spio_mask << MISC_REGISTERS_SPIO_SET_POS);
-		break;
-
-	case MISC_REGISTERS_SPIO_INPUT_HI_Z:
-		DP(NETIF_MSG_LINK, "Set SPIO %d -> input\n", spio_num);
-		/* set FLOAT */
-		spio_reg |= (spio_mask << MISC_REGISTERS_SPIO_FLOAT_POS);
-		break;
-
-	default:
-		break;
-	}
-
-	REG_WR(bp, MISC_REG_SPIO, spio_reg);
-	bnx2x_release_hw_lock(bp, HW_LOCK_RESOURCE_SPIO);
-
-	return 0;
-}
-
-static void bnx2x_calc_fc_adv(struct bnx2x *bp)
-{
-	switch (bp->link_vars.ieee_fc &
-		MDIO_COMBO_IEEE0_AUTO_NEG_ADV_PAUSE_MASK) {
-	case MDIO_COMBO_IEEE0_AUTO_NEG_ADV_PAUSE_NONE:
-		bp->port.advertising &= ~(ADVERTISED_Asym_Pause |
-					  ADVERTISED_Pause);
-		break;
-
-	case MDIO_COMBO_IEEE0_AUTO_NEG_ADV_PAUSE_BOTH:
-		bp->port.advertising |= (ADVERTISED_Asym_Pause |
-					 ADVERTISED_Pause);
-		break;
-
-	case MDIO_COMBO_IEEE0_AUTO_NEG_ADV_PAUSE_ASYMMETRIC:
-		bp->port.advertising |= ADVERTISED_Asym_Pause;
-		break;
-
-	default:
-		bp->port.advertising &= ~(ADVERTISED_Asym_Pause |
-					  ADVERTISED_Pause);
-		break;
-	}
-}
-
-static void bnx2x_link_report(struct bnx2x *bp)
-{
-	if (bp->flags & MF_FUNC_DIS) {
-		netif_carrier_off(bp->dev);
-		netdev_err(bp->dev, "NIC Link is Down\n");
-		return;
-	}
-
-	if (bp->link_vars.link_up) {
-		u16 line_speed;
-
-		if (bp->state == BNX2X_STATE_OPEN)
-			netif_carrier_on(bp->dev);
-		netdev_info(bp->dev, "NIC Link is Up, ");
-
-		line_speed = bp->link_vars.line_speed;
-		if (IS_E1HMF(bp)) {
-			u16 vn_max_rate;
-
-			vn_max_rate =
-				((bp->mf_config & FUNC_MF_CFG_MAX_BW_MASK) >>
-				 FUNC_MF_CFG_MAX_BW_SHIFT) * 100;
-			if (vn_max_rate < line_speed)
-				line_speed = vn_max_rate;
-		}
-		pr_cont("%d Mbps ", line_speed);
-
-		if (bp->link_vars.duplex == DUPLEX_FULL)
-			pr_cont("full duplex");
-		else
-			pr_cont("half duplex");
-
-		if (bp->link_vars.flow_ctrl != BNX2X_FLOW_CTRL_NONE) {
-			if (bp->link_vars.flow_ctrl & BNX2X_FLOW_CTRL_RX) {
-				pr_cont(", receive ");
-				if (bp->link_vars.flow_ctrl &
-				    BNX2X_FLOW_CTRL_TX)
-					pr_cont("& transmit ");
-			} else {
-				pr_cont(", transmit ");
-			}
-			pr_cont("flow control ON");
-		}
-		pr_cont("\n");
-
-	} else { /* link_down */
-		netif_carrier_off(bp->dev);
-		netdev_err(bp->dev, "NIC Link is Down\n");
-	}
-}
-
-static u8 bnx2x_initial_phy_init(struct bnx2x *bp, int load_mode)
-{
-	if (!BP_NOMCP(bp)) {
-		u8 rc;
-
-		/* Initialize link parameters structure variables */
-		/* It is recommended to turn off RX FC for jumbo frames
-		   for better performance */
-		if (bp->dev->mtu > 5000)
-			bp->link_params.req_fc_auto_adv = BNX2X_FLOW_CTRL_TX;
-		else
-			bp->link_params.req_fc_auto_adv = BNX2X_FLOW_CTRL_BOTH;
-
-		bnx2x_acquire_phy_lock(bp);
-
-		if (load_mode == LOAD_DIAG)
-			bp->link_params.loopback_mode = LOOPBACK_XGXS_10;
-
-		rc = bnx2x_phy_init(&bp->link_params, &bp->link_vars);
-
-		bnx2x_release_phy_lock(bp);
-
-		bnx2x_calc_fc_adv(bp);
-
-		if (CHIP_REV_IS_SLOW(bp) && bp->link_vars.link_up) {
-			bnx2x_stats_handle(bp, STATS_EVENT_LINK_UP);
-			bnx2x_link_report(bp);
-		}
-
-		return rc;
-	}
-	BNX2X_ERR("Bootcode is missing - can not initialize link\n");
-	return -EINVAL;
-}
-
-static void bnx2x_link_set(struct bnx2x *bp)
-{
-	if (!BP_NOMCP(bp)) {
-		bnx2x_acquire_phy_lock(bp);
-		bnx2x_phy_init(&bp->link_params, &bp->link_vars);
-		bnx2x_release_phy_lock(bp);
-
-		bnx2x_calc_fc_adv(bp);
-	} else
-		BNX2X_ERR("Bootcode is missing - can not set link\n");
-}
-
-static void bnx2x__link_reset(struct bnx2x *bp)
-{
-	if (!BP_NOMCP(bp)) {
-		bnx2x_acquire_phy_lock(bp);
-		bnx2x_link_reset(&bp->link_params, &bp->link_vars, 1);
-		bnx2x_release_phy_lock(bp);
-	} else
-		BNX2X_ERR("Bootcode is missing - can not reset link\n");
-}
-
-static u8 bnx2x_link_test(struct bnx2x *bp)
-{
-	u8 rc;
-
-	bnx2x_acquire_phy_lock(bp);
-	rc = bnx2x_test_link(&bp->link_params, &bp->link_vars);
-	bnx2x_release_phy_lock(bp);
-
-	return rc;
-}
-
-static void bnx2x_init_port_minmax(struct bnx2x *bp)
-{
-	u32 r_param = bp->link_vars.line_speed / 8;
-	u32 fair_periodic_timeout_usec;
-	u32 t_fair;
-
-	memset(&(bp->cmng.rs_vars), 0,
-	       sizeof(struct rate_shaping_vars_per_port));
-	memset(&(bp->cmng.fair_vars), 0, sizeof(struct fairness_vars_per_port));
-
-	/* 100 usec in SDM ticks = 25 since each tick is 4 usec */
-	bp->cmng.rs_vars.rs_periodic_timeout = RS_PERIODIC_TIMEOUT_USEC / 4;
-
-	/* this is the threshold below which no timer arming will occur
-	   1.25 coefficient is for the threshold to be a little bigger
-	   than the real time, to compensate for timer in-accuracy */
-	bp->cmng.rs_vars.rs_threshold =
-				(RS_PERIODIC_TIMEOUT_USEC * r_param * 5) / 4;
-
-	/* resolution of fairness timer */
-	fair_periodic_timeout_usec = QM_ARB_BYTES / r_param;
-	/* for 10G it is 1000usec. for 1G it is 10000usec. */
-	t_fair = T_FAIR_COEF / bp->link_vars.line_speed;
-
-	/* this is the threshold below which we won't arm the timer anymore */
-	bp->cmng.fair_vars.fair_threshold = QM_ARB_BYTES;
-
-	/* we multiply by 1e3/8 to get bytes/msec.
-	   We don't want the credits to pass a credit
-	   of the t_fair*FAIR_MEM (algorithm resolution) */
-	bp->cmng.fair_vars.upper_bound = r_param * t_fair * FAIR_MEM;
-	/* since each tick is 4 usec */
-	bp->cmng.fair_vars.fairness_timeout = fair_periodic_timeout_usec / 4;
-}
-
-/* Calculates the sum of vn_min_rates.
-   It's needed for further normalizing of the min_rates.
-   Returns:
-     sum of vn_min_rates.
-       or
-     0 - if all the min_rates are 0.
-     In the later case fainess algorithm should be deactivated.
-     If not all min_rates are zero then those that are zeroes will be set to 1.
- */
-static void bnx2x_calc_vn_weight_sum(struct bnx2x *bp)
-{
-	int all_zero = 1;
-	int port = BP_PORT(bp);
-	int vn;
-
-	bp->vn_weight_sum = 0;
-	for (vn = VN_0; vn < E1HVN_MAX; vn++) {
-		int func = 2*vn + port;
-		u32 vn_cfg = SHMEM_RD(bp, mf_cfg.func_mf_config[func].config);
-		u32 vn_min_rate = ((vn_cfg & FUNC_MF_CFG_MIN_BW_MASK) >>
-				   FUNC_MF_CFG_MIN_BW_SHIFT) * 100;
-
-		/* Skip hidden vns */
-		if (vn_cfg & FUNC_MF_CFG_FUNC_HIDE)
-			continue;
-
-		/* If min rate is zero - set it to 1 */
-		if (!vn_min_rate)
-			vn_min_rate = DEF_MIN_RATE;
-		else
-			all_zero = 0;
-
-		bp->vn_weight_sum += vn_min_rate;
-	}
-
-	/* ... only if all min rates are zeros - disable fairness */
-	if (all_zero) {
-		bp->cmng.flags.cmng_enables &=
-					~CMNG_FLAGS_PER_PORT_FAIRNESS_VN;
-		DP(NETIF_MSG_IFUP, "All MIN values are zeroes"
-		   "  fairness will be disabled\n");
-	} else
-		bp->cmng.flags.cmng_enables |=
-					CMNG_FLAGS_PER_PORT_FAIRNESS_VN;
-}
-
-static void bnx2x_init_vn_minmax(struct bnx2x *bp, int func)
-{
-	struct rate_shaping_vars_per_vn m_rs_vn;
-	struct fairness_vars_per_vn m_fair_vn;
-	u32 vn_cfg = SHMEM_RD(bp, mf_cfg.func_mf_config[func].config);
-	u16 vn_min_rate, vn_max_rate;
-	int i;
-
-	/* If function is hidden - set min and max to zeroes */
-	if (vn_cfg & FUNC_MF_CFG_FUNC_HIDE) {
-		vn_min_rate = 0;
-		vn_max_rate = 0;
-
-	} else {
-		vn_min_rate = ((vn_cfg & FUNC_MF_CFG_MIN_BW_MASK) >>
-				FUNC_MF_CFG_MIN_BW_SHIFT) * 100;
-		/* If min rate is zero - set it to 1 */
-		if (!vn_min_rate)
-			vn_min_rate = DEF_MIN_RATE;
-		vn_max_rate = ((vn_cfg & FUNC_MF_CFG_MAX_BW_MASK) >>
-				FUNC_MF_CFG_MAX_BW_SHIFT) * 100;
-	}
-	DP(NETIF_MSG_IFUP,
-	   "func %d: vn_min_rate %d  vn_max_rate %d  vn_weight_sum %d\n",
-	   func, vn_min_rate, vn_max_rate, bp->vn_weight_sum);
-
-	memset(&m_rs_vn, 0, sizeof(struct rate_shaping_vars_per_vn));
-	memset(&m_fair_vn, 0, sizeof(struct fairness_vars_per_vn));
-
-	/* global vn counter - maximal Mbps for this vn */
-	m_rs_vn.vn_counter.rate = vn_max_rate;
-
-	/* quota - number of bytes transmitted in this period */
-	m_rs_vn.vn_counter.quota =
-				(vn_max_rate * RS_PERIODIC_TIMEOUT_USEC) / 8;
-
-	if (bp->vn_weight_sum) {
-		/* credit for each period of the fairness algorithm:
-		   number of bytes in T_FAIR (the vn share the port rate).
-		   vn_weight_sum should not be larger than 10000, thus
-		   T_FAIR_COEF / (8 * vn_weight_sum) will always be greater
-		   than zero */
-		m_fair_vn.vn_credit_delta =
-			max((u32)(vn_min_rate * (T_FAIR_COEF /
-						 (8 * bp->vn_weight_sum))),
-			    (u32)(bp->cmng.fair_vars.fair_threshold * 2));
-		DP(NETIF_MSG_IFUP, "m_fair_vn.vn_credit_delta=%d\n",
-		   m_fair_vn.vn_credit_delta);
-	}
-
-	/* Store it to internal memory */
-	for (i = 0; i < sizeof(struct rate_shaping_vars_per_vn)/4; i++)
-		REG_WR(bp, BAR_XSTRORM_INTMEM +
-		       XSTORM_RATE_SHAPING_PER_VN_VARS_OFFSET(func) + i * 4,
-		       ((u32 *)(&m_rs_vn))[i]);
-
-	for (i = 0; i < sizeof(struct fairness_vars_per_vn)/4; i++)
-		REG_WR(bp, BAR_XSTRORM_INTMEM +
-		       XSTORM_FAIRNESS_PER_VN_VARS_OFFSET(func) + i * 4,
-		       ((u32 *)(&m_fair_vn))[i]);
-}
-
-
-/* This function is called upon link interrupt */
-static void bnx2x_link_attn(struct bnx2x *bp)
-{
-	/* Make sure that we are synced with the current statistics */
-	bnx2x_stats_handle(bp, STATS_EVENT_STOP);
-
-	bnx2x_link_update(&bp->link_params, &bp->link_vars);
-
-	if (bp->link_vars.link_up) {
-
-		/* dropless flow control */
-		if (CHIP_IS_E1H(bp) && bp->dropless_fc) {
-			int port = BP_PORT(bp);
-			u32 pause_enabled = 0;
-
-			if (bp->link_vars.flow_ctrl & BNX2X_FLOW_CTRL_TX)
-				pause_enabled = 1;
-
-			REG_WR(bp, BAR_USTRORM_INTMEM +
-			       USTORM_ETH_PAUSE_ENABLED_OFFSET(port),
-			       pause_enabled);
-		}
-
-		if (bp->link_vars.mac_type == MAC_TYPE_BMAC) {
-			struct host_port_stats *pstats;
-
-			pstats = bnx2x_sp(bp, port_stats);
-			/* reset old bmac stats */
-			memset(&(pstats->mac_stx[0]), 0,
-			       sizeof(struct mac_stx));
-		}
-		if (bp->state == BNX2X_STATE_OPEN)
-			bnx2x_stats_handle(bp, STATS_EVENT_LINK_UP);
-	}
-
-	/* indicate link status */
-	bnx2x_link_report(bp);
-
-	if (IS_E1HMF(bp)) {
-		int port = BP_PORT(bp);
-		int func;
-		int vn;
-
-		/* Set the attention towards other drivers on the same port */
-		for (vn = VN_0; vn < E1HVN_MAX; vn++) {
-			if (vn == BP_E1HVN(bp))
-				continue;
-
-			func = ((vn << 1) | port);
-			REG_WR(bp, MISC_REG_AEU_GENERAL_ATTN_0 +
-			       (LINK_SYNC_ATTENTION_BIT_FUNC_0 + func)*4, 1);
-		}
-
-		if (bp->link_vars.link_up) {
-			int i;
-
-			/* Init rate shaping and fairness contexts */
-			bnx2x_init_port_minmax(bp);
-
-			for (vn = VN_0; vn < E1HVN_MAX; vn++)
-				bnx2x_init_vn_minmax(bp, 2*vn + port);
-
-			/* Store it to internal memory */
-			for (i = 0;
-			     i < sizeof(struct cmng_struct_per_port) / 4; i++)
-				REG_WR(bp, BAR_XSTRORM_INTMEM +
-				  XSTORM_CMNG_PER_PORT_VARS_OFFSET(port) + i*4,
-				       ((u32 *)(&bp->cmng))[i]);
-		}
-	}
-}
-
-static void bnx2x__link_status_update(struct bnx2x *bp)
-{
-	if ((bp->state != BNX2X_STATE_OPEN) || (bp->flags & MF_FUNC_DIS))
-		return;
-
-	bnx2x_link_status_update(&bp->link_params, &bp->link_vars);
-
-	if (bp->link_vars.link_up)
-		bnx2x_stats_handle(bp, STATS_EVENT_LINK_UP);
-	else
-		bnx2x_stats_handle(bp, STATS_EVENT_STOP);
-
-	bnx2x_calc_vn_weight_sum(bp);
-
-	/* indicate link status */
-	bnx2x_link_report(bp);
-}
-
-static void bnx2x_pmf_update(struct bnx2x *bp)
-{
-	int port = BP_PORT(bp);
-	u32 val;
-
-	bp->port.pmf = 1;
-	DP(NETIF_MSG_LINK, "pmf %d\n", bp->port.pmf);
-
-	/* enable nig attention */
-	val = (0xff0f | (1 << (BP_E1HVN(bp) + 4)));
-	REG_WR(bp, HC_REG_TRAILING_EDGE_0 + port*8, val);
-	REG_WR(bp, HC_REG_LEADING_EDGE_0 + port*8, val);
-
-	bnx2x_stats_handle(bp, STATS_EVENT_PMF);
-}
-
-/* end of Link */
-
-/* slow path */
-
-/*
- * General service functions
- */
-
-/* send the MCP a request, block until there is a reply */
-u32 bnx2x_fw_command(struct bnx2x *bp, u32 command)
-{
-	int func = BP_FUNC(bp);
-	u32 seq = ++bp->fw_seq;
-	u32 rc = 0;
-	u32 cnt = 1;
-	u8 delay = CHIP_REV_IS_SLOW(bp) ? 100 : 10;
-
-	mutex_lock(&bp->fw_mb_mutex);
-	SHMEM_WR(bp, func_mb[func].drv_mb_header, (command | seq));
-	DP(BNX2X_MSG_MCP, "wrote command (%x) to FW MB\n", (command | seq));
-
-	do {
-		/* let the FW do it's magic ... */
-		msleep(delay);
-
-		rc = SHMEM_RD(bp, func_mb[func].fw_mb_header);
-
-		/* Give the FW up to 5 second (500*10ms) */
-	} while ((seq != (rc & FW_MSG_SEQ_NUMBER_MASK)) && (cnt++ < 500));
-
-	DP(BNX2X_MSG_MCP, "[after %d ms] read (%x) seq is (%x) from FW MB\n",
-	   cnt*delay, rc, seq);
-
-	/* is this a reply to our command? */
-	if (seq == (rc & FW_MSG_SEQ_NUMBER_MASK))
-		rc &= FW_MSG_CODE_MASK;
-	else {
-		/* FW BUG! */
-		BNX2X_ERR("FW failed to respond!\n");
-		bnx2x_fw_dump(bp);
-		rc = 0;
-	}
-	mutex_unlock(&bp->fw_mb_mutex);
-
-	return rc;
-}
-
-static void bnx2x_set_storm_rx_mode(struct bnx2x *bp);
-static void bnx2x_set_eth_mac_addr_e1h(struct bnx2x *bp, int set);
-static void bnx2x_set_rx_mode(struct net_device *dev);
-
-static void bnx2x_e1h_disable(struct bnx2x *bp)
-{
-	int port = BP_PORT(bp);
-
-	netif_tx_disable(bp->dev);
-
-	REG_WR(bp, NIG_REG_LLH0_FUNC_EN + port*8, 0);
-
-	netif_carrier_off(bp->dev);
-}
-
-static void bnx2x_e1h_enable(struct bnx2x *bp)
-{
-	int port = BP_PORT(bp);
-
-	REG_WR(bp, NIG_REG_LLH0_FUNC_EN + port*8, 1);
-
-	/* Tx queue should be only reenabled */
-	netif_tx_wake_all_queues(bp->dev);
-
-	/*
-	 * Should not call netif_carrier_on since it will be called if the link
-	 * is up when checking for link state
-	 */
-}
-
-static void bnx2x_update_min_max(struct bnx2x *bp)
-{
-	int port = BP_PORT(bp);
-	int vn, i;
-
-	/* Init rate shaping and fairness contexts */
-	bnx2x_init_port_minmax(bp);
-
-	bnx2x_calc_vn_weight_sum(bp);
-
-	for (vn = VN_0; vn < E1HVN_MAX; vn++)
-		bnx2x_init_vn_minmax(bp, 2*vn + port);
-
-	if (bp->port.pmf) {
-		int func;
-
-		/* Set the attention towards other drivers on the same port */
-		for (vn = VN_0; vn < E1HVN_MAX; vn++) {
-			if (vn == BP_E1HVN(bp))
-				continue;
-
-			func = ((vn << 1) | port);
-			REG_WR(bp, MISC_REG_AEU_GENERAL_ATTN_0 +
-			       (LINK_SYNC_ATTENTION_BIT_FUNC_0 + func)*4, 1);
-		}
-
-		/* Store it to internal memory */
-		for (i = 0; i < sizeof(struct cmng_struct_per_port) / 4; i++)
-			REG_WR(bp, BAR_XSTRORM_INTMEM +
-			       XSTORM_CMNG_PER_PORT_VARS_OFFSET(port) + i*4,
-			       ((u32 *)(&bp->cmng))[i]);
-	}
-}
-
-static void bnx2x_dcc_event(struct bnx2x *bp, u32 dcc_event)
-{
-	DP(BNX2X_MSG_MCP, "dcc_event 0x%x\n", dcc_event);
-
-	if (dcc_event & DRV_STATUS_DCC_DISABLE_ENABLE_PF) {
-
-		/*
-		 * This is the only place besides the function initialization
-		 * where the bp->flags can change so it is done without any
-		 * locks
-		 */
-		if (bp->mf_config & FUNC_MF_CFG_FUNC_DISABLED) {
-			DP(NETIF_MSG_IFDOWN, "mf_cfg function disabled\n");
-			bp->flags |= MF_FUNC_DIS;
-
-			bnx2x_e1h_disable(bp);
-		} else {
-			DP(NETIF_MSG_IFUP, "mf_cfg function enabled\n");
-			bp->flags &= ~MF_FUNC_DIS;
-
-			bnx2x_e1h_enable(bp);
-		}
-		dcc_event &= ~DRV_STATUS_DCC_DISABLE_ENABLE_PF;
-	}
-	if (dcc_event & DRV_STATUS_DCC_BANDWIDTH_ALLOCATION) {
-
-		bnx2x_update_min_max(bp);
-		dcc_event &= ~DRV_STATUS_DCC_BANDWIDTH_ALLOCATION;
-	}
-
-	/* Report results to MCP */
-	if (dcc_event)
-		bnx2x_fw_command(bp, DRV_MSG_CODE_DCC_FAILURE);
-	else
-		bnx2x_fw_command(bp, DRV_MSG_CODE_DCC_OK);
-}
-
-/* must be called under the spq lock */
-static inline struct eth_spe *bnx2x_sp_get_next(struct bnx2x *bp)
-{
-	struct eth_spe *next_spe = bp->spq_prod_bd;
-
-	if (bp->spq_prod_bd == bp->spq_last_bd) {
-		bp->spq_prod_bd = bp->spq;
-		bp->spq_prod_idx = 0;
-		DP(NETIF_MSG_TIMER, "end of spq\n");
-	} else {
-		bp->spq_prod_bd++;
-		bp->spq_prod_idx++;
-	}
-	return next_spe;
-}
-
-/* must be called under the spq lock */
-static inline void bnx2x_sp_prod_update(struct bnx2x *bp)
-{
-	int func = BP_FUNC(bp);
-
-	/* Make sure that BD data is updated before writing the producer */
-	wmb();
-
-	REG_WR(bp, BAR_XSTRORM_INTMEM + XSTORM_SPQ_PROD_OFFSET(func),
-	       bp->spq_prod_idx);
-	mmiowb();
-}
-
-/* the slow path queue is odd since completions arrive on the fastpath ring */
-static int bnx2x_sp_post(struct bnx2x *bp, int command, int cid,
-			 u32 data_hi, u32 data_lo, int common)
-{
-	struct eth_spe *spe;
-
-	DP(BNX2X_MSG_SP/*NETIF_MSG_TIMER*/,
-	   "SPQE (%x:%x)  command %d  hw_cid %x  data (%x:%x)  left %x\n",
-	   (u32)U64_HI(bp->spq_mapping), (u32)(U64_LO(bp->spq_mapping) +
-	   (void *)bp->spq_prod_bd - (void *)bp->spq), command,
-	   HW_CID(bp, cid), data_hi, data_lo, bp->spq_left);
-
-#ifdef BNX2X_STOP_ON_ERROR
-	if (unlikely(bp->panic))
-		return -EIO;
-#endif
-
-	spin_lock_bh(&bp->spq_lock);
-
-	if (!bp->spq_left) {
-		BNX2X_ERR("BUG! SPQ ring full!\n");
-		spin_unlock_bh(&bp->spq_lock);
-		bnx2x_panic();
-		return -EBUSY;
-	}
-
-	spe = bnx2x_sp_get_next(bp);
-
-	/* CID needs port number to be encoded int it */
-	spe->hdr.conn_and_cmd_data =
-			cpu_to_le32(((command << SPE_HDR_CMD_ID_SHIFT) |
-				     HW_CID(bp, cid)));
-	spe->hdr.type = cpu_to_le16(ETH_CONNECTION_TYPE);
-	if (common)
-		spe->hdr.type |=
-			cpu_to_le16((1 << SPE_HDR_COMMON_RAMROD_SHIFT));
-
-	spe->data.mac_config_addr.hi = cpu_to_le32(data_hi);
-	spe->data.mac_config_addr.lo = cpu_to_le32(data_lo);
-
-	bp->spq_left--;
-
-	bnx2x_sp_prod_update(bp);
-	spin_unlock_bh(&bp->spq_lock);
-	return 0;
-}
-
-/* acquire split MCP access lock register */
-static int bnx2x_acquire_alr(struct bnx2x *bp)
-{
-	u32 i, j, val;
-	int rc = 0;
-
-	might_sleep();
-	i = 100;
-	for (j = 0; j < i*10; j++) {
-		val = (1UL << 31);
-		REG_WR(bp, GRCBASE_MCP + 0x9c, val);
-		val = REG_RD(bp, GRCBASE_MCP + 0x9c);
-		if (val & (1L << 31))
-			break;
-
-		msleep(5);
-	}
-	if (!(val & (1L << 31))) {
-		BNX2X_ERR("Cannot acquire MCP access lock register\n");
-		rc = -EBUSY;
-	}
-
-	return rc;
-}
-
-/* release split MCP access lock register */
-static void bnx2x_release_alr(struct bnx2x *bp)
-{
-	u32 val = 0;
-
-	REG_WR(bp, GRCBASE_MCP + 0x9c, val);
-}
-
-static inline u16 bnx2x_update_dsb_idx(struct bnx2x *bp)
-{
-	struct host_def_status_block *def_sb = bp->def_status_blk;
-	u16 rc = 0;
-
-	barrier(); /* status block is written to by the chip */
-	if (bp->def_att_idx != def_sb->atten_status_block.attn_bits_index) {
-		bp->def_att_idx = def_sb->atten_status_block.attn_bits_index;
-		rc |= 1;
-	}
-	if (bp->def_c_idx != def_sb->c_def_status_block.status_block_index) {
-		bp->def_c_idx = def_sb->c_def_status_block.status_block_index;
-		rc |= 2;
-	}
-	if (bp->def_u_idx != def_sb->u_def_status_block.status_block_index) {
-		bp->def_u_idx = def_sb->u_def_status_block.status_block_index;
-		rc |= 4;
-	}
-	if (bp->def_x_idx != def_sb->x_def_status_block.status_block_index) {
-		bp->def_x_idx = def_sb->x_def_status_block.status_block_index;
-		rc |= 8;
-	}
-	if (bp->def_t_idx != def_sb->t_def_status_block.status_block_index) {
-		bp->def_t_idx = def_sb->t_def_status_block.status_block_index;
-		rc |= 16;
-	}
-	return rc;
-}
-
-/*
- * slow path service functions
- */
-
-static void bnx2x_attn_int_asserted(struct bnx2x *bp, u32 asserted)
-{
-	int port = BP_PORT(bp);
-	u32 hc_addr = (HC_REG_COMMAND_REG + port*32 +
-		       COMMAND_REG_ATTN_BITS_SET);
-	u32 aeu_addr = port ? MISC_REG_AEU_MASK_ATTN_FUNC_1 :
-			      MISC_REG_AEU_MASK_ATTN_FUNC_0;
-	u32 nig_int_mask_addr = port ? NIG_REG_MASK_INTERRUPT_PORT1 :
-				       NIG_REG_MASK_INTERRUPT_PORT0;
-	u32 aeu_mask;
-	u32 nig_mask = 0;
-
-	if (bp->attn_state & asserted)
-		BNX2X_ERR("IGU ERROR\n");
-
-	bnx2x_acquire_hw_lock(bp, HW_LOCK_RESOURCE_PORT0_ATT_MASK + port);
-	aeu_mask = REG_RD(bp, aeu_addr);
-
-	DP(NETIF_MSG_HW, "aeu_mask %x  newly asserted %x\n",
-	   aeu_mask, asserted);
-	aeu_mask &= ~(asserted & 0xff);
-	DP(NETIF_MSG_HW, "new mask %x\n", aeu_mask);
-
-	REG_WR(bp, aeu_addr, aeu_mask);
-	bnx2x_release_hw_lock(bp, HW_LOCK_RESOURCE_PORT0_ATT_MASK + port);
-
-	DP(NETIF_MSG_HW, "attn_state %x\n", bp->attn_state);
-	bp->attn_state |= asserted;
-	DP(NETIF_MSG_HW, "new state %x\n", bp->attn_state);
-
-	if (asserted & ATTN_HARD_WIRED_MASK) {
-		if (asserted & ATTN_NIG_FOR_FUNC) {
-
-			bnx2x_acquire_phy_lock(bp);
-
-			/* save nig interrupt mask */
-			nig_mask = REG_RD(bp, nig_int_mask_addr);
-			REG_WR(bp, nig_int_mask_addr, 0);
-
-			bnx2x_link_attn(bp);
-
-			/* handle unicore attn? */
-		}
-		if (asserted & ATTN_SW_TIMER_4_FUNC)
-			DP(NETIF_MSG_HW, "ATTN_SW_TIMER_4_FUNC!\n");
-
-		if (asserted & GPIO_2_FUNC)
-			DP(NETIF_MSG_HW, "GPIO_2_FUNC!\n");
-
-		if (asserted & GPIO_3_FUNC)
-			DP(NETIF_MSG_HW, "GPIO_3_FUNC!\n");
-
-		if (asserted & GPIO_4_FUNC)
-			DP(NETIF_MSG_HW, "GPIO_4_FUNC!\n");
-
-		if (port == 0) {
-			if (asserted & ATTN_GENERAL_ATTN_1) {
-				DP(NETIF_MSG_HW, "ATTN_GENERAL_ATTN_1!\n");
-				REG_WR(bp, MISC_REG_AEU_GENERAL_ATTN_1, 0x0);
-			}
-			if (asserted & ATTN_GENERAL_ATTN_2) {
-				DP(NETIF_MSG_HW, "ATTN_GENERAL_ATTN_2!\n");
-				REG_WR(bp, MISC_REG_AEU_GENERAL_ATTN_2, 0x0);
-			}
-			if (asserted & ATTN_GENERAL_ATTN_3) {
-				DP(NETIF_MSG_HW, "ATTN_GENERAL_ATTN_3!\n");
-				REG_WR(bp, MISC_REG_AEU_GENERAL_ATTN_3, 0x0);
-			}
-		} else {
-			if (asserted & ATTN_GENERAL_ATTN_4) {
-				DP(NETIF_MSG_HW, "ATTN_GENERAL_ATTN_4!\n");
-				REG_WR(bp, MISC_REG_AEU_GENERAL_ATTN_4, 0x0);
-			}
-			if (asserted & ATTN_GENERAL_ATTN_5) {
-				DP(NETIF_MSG_HW, "ATTN_GENERAL_ATTN_5!\n");
-				REG_WR(bp, MISC_REG_AEU_GENERAL_ATTN_5, 0x0);
-			}
-			if (asserted & ATTN_GENERAL_ATTN_6) {
-				DP(NETIF_MSG_HW, "ATTN_GENERAL_ATTN_6!\n");
-				REG_WR(bp, MISC_REG_AEU_GENERAL_ATTN_6, 0x0);
-			}
-		}
-
-	} /* if hardwired */
-
-	DP(NETIF_MSG_HW, "about to mask 0x%08x at HC addr 0x%x\n",
-	   asserted, hc_addr);
-	REG_WR(bp, hc_addr, asserted);
-
-	/* now set back the mask */
-	if (asserted & ATTN_NIG_FOR_FUNC) {
-		REG_WR(bp, nig_int_mask_addr, nig_mask);
-		bnx2x_release_phy_lock(bp);
-	}
-}
-
-static inline void bnx2x_fan_failure(struct bnx2x *bp)
-{
-	int port = BP_PORT(bp);
-
-	/* mark the failure */
-	bp->link_params.ext_phy_config &= ~PORT_HW_CFG_XGXS_EXT_PHY_TYPE_MASK;
-	bp->link_params.ext_phy_config |= PORT_HW_CFG_XGXS_EXT_PHY_TYPE_FAILURE;
-	SHMEM_WR(bp, dev_info.port_hw_config[port].external_phy_config,
-		 bp->link_params.ext_phy_config);
-
-	/* log the failure */
-	netdev_err(bp->dev, "Fan Failure on Network Controller has caused the driver to shutdown the card to prevent permanent damage.\n"
-		   "Please contact Dell Support for assistance.\n");
-}
-
-static inline void bnx2x_attn_int_deasserted0(struct bnx2x *bp, u32 attn)
-{
-	int port = BP_PORT(bp);
-	int reg_offset;
-	u32 val, swap_val, swap_override;
-
-	reg_offset = (port ? MISC_REG_AEU_ENABLE1_FUNC_1_OUT_0 :
-			     MISC_REG_AEU_ENABLE1_FUNC_0_OUT_0);
-
-	if (attn & AEU_INPUTS_ATTN_BITS_SPIO5) {
-
-		val = REG_RD(bp, reg_offset);
-		val &= ~AEU_INPUTS_ATTN_BITS_SPIO5;
-		REG_WR(bp, reg_offset, val);
-
-		BNX2X_ERR("SPIO5 hw attention\n");
-
-		/* Fan failure attention */
-		switch (XGXS_EXT_PHY_TYPE(bp->link_params.ext_phy_config)) {
-		case PORT_HW_CFG_XGXS_EXT_PHY_TYPE_SFX7101:
-			/* Low power mode is controlled by GPIO 2 */
-			bnx2x_set_gpio(bp, MISC_REGISTERS_GPIO_2,
-				       MISC_REGISTERS_GPIO_OUTPUT_LOW, port);
-			/* The PHY reset is controlled by GPIO 1 */
-			bnx2x_set_gpio(bp, MISC_REGISTERS_GPIO_1,
-				       MISC_REGISTERS_GPIO_OUTPUT_LOW, port);
-			break;
-
-		case PORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM8727:
-			/* The PHY reset is controlled by GPIO 1 */
-			/* fake the port number to cancel the swap done in
-			   set_gpio() */
-			swap_val = REG_RD(bp, NIG_REG_PORT_SWAP);
-			swap_override = REG_RD(bp, NIG_REG_STRAP_OVERRIDE);
-			port = (swap_val && swap_override) ^ 1;
-			bnx2x_set_gpio(bp, MISC_REGISTERS_GPIO_1,
-				       MISC_REGISTERS_GPIO_OUTPUT_LOW, port);
-			break;
-
-		default:
-			break;
-		}
-		bnx2x_fan_failure(bp);
-	}
-
-	if (attn & (AEU_INPUTS_ATTN_BITS_GPIO3_FUNCTION_0 |
-		    AEU_INPUTS_ATTN_BITS_GPIO3_FUNCTION_1)) {
-		bnx2x_acquire_phy_lock(bp);
-		bnx2x_handle_module_detect_int(&bp->link_params);
-		bnx2x_release_phy_lock(bp);
-	}
-
-	if (attn & HW_INTERRUT_ASSERT_SET_0) {
-
-		val = REG_RD(bp, reg_offset);
-		val &= ~(attn & HW_INTERRUT_ASSERT_SET_0);
-		REG_WR(bp, reg_offset, val);
-
-		BNX2X_ERR("FATAL HW block attention set0 0x%x\n",
-			  (u32)(attn & HW_INTERRUT_ASSERT_SET_0));
-		bnx2x_panic();
-	}
-}
-
-static inline void bnx2x_attn_int_deasserted1(struct bnx2x *bp, u32 attn)
-{
-	u32 val;
-
-	if (attn & AEU_INPUTS_ATTN_BITS_DOORBELLQ_HW_INTERRUPT) {
-
-		val = REG_RD(bp, DORQ_REG_DORQ_INT_STS_CLR);
-		BNX2X_ERR("DB hw attention 0x%x\n", val);
-		/* DORQ discard attention */
-		if (val & 0x2)
-			BNX2X_ERR("FATAL error from DORQ\n");
-	}
-
-	if (attn & HW_INTERRUT_ASSERT_SET_1) {
-
-		int port = BP_PORT(bp);
-		int reg_offset;
-
-		reg_offset = (port ? MISC_REG_AEU_ENABLE1_FUNC_1_OUT_1 :
-				     MISC_REG_AEU_ENABLE1_FUNC_0_OUT_1);
-
-		val = REG_RD(bp, reg_offset);
-		val &= ~(attn & HW_INTERRUT_ASSERT_SET_1);
-		REG_WR(bp, reg_offset, val);
-
-		BNX2X_ERR("FATAL HW block attention set1 0x%x\n",
-			  (u32)(attn & HW_INTERRUT_ASSERT_SET_1));
-		bnx2x_panic();
-	}
-}
-
-static inline void bnx2x_attn_int_deasserted2(struct bnx2x *bp, u32 attn)
-{
-	u32 val;
-
-	if (attn & AEU_INPUTS_ATTN_BITS_CFC_HW_INTERRUPT) {
-
-		val = REG_RD(bp, CFC_REG_CFC_INT_STS_CLR);
-		BNX2X_ERR("CFC hw attention 0x%x\n", val);
-		/* CFC error attention */
-		if (val & 0x2)
-			BNX2X_ERR("FATAL error from CFC\n");
-	}
-
-	if (attn & AEU_INPUTS_ATTN_BITS_PXP_HW_INTERRUPT) {
-
-		val = REG_RD(bp, PXP_REG_PXP_INT_STS_CLR_0);
-		BNX2X_ERR("PXP hw attention 0x%x\n", val);
-		/* RQ_USDMDP_FIFO_OVERFLOW */
-		if (val & 0x18000)
-			BNX2X_ERR("FATAL error from PXP\n");
-	}
-
-	if (attn & HW_INTERRUT_ASSERT_SET_2) {
-
-		int port = BP_PORT(bp);
-		int reg_offset;
-
-		reg_offset = (port ? MISC_REG_AEU_ENABLE1_FUNC_1_OUT_2 :
-				     MISC_REG_AEU_ENABLE1_FUNC_0_OUT_2);
-
-		val = REG_RD(bp, reg_offset);
-		val &= ~(attn & HW_INTERRUT_ASSERT_SET_2);
-		REG_WR(bp, reg_offset, val);
-
-		BNX2X_ERR("FATAL HW block attention set2 0x%x\n",
-			  (u32)(attn & HW_INTERRUT_ASSERT_SET_2));
-		bnx2x_panic();
-	}
-}
-
-static inline void bnx2x_attn_int_deasserted3(struct bnx2x *bp, u32 attn)
-{
-	u32 val;
-
-	if (attn & EVEREST_GEN_ATTN_IN_USE_MASK) {
-
-		if (attn & BNX2X_PMF_LINK_ASSERT) {
-			int func = BP_FUNC(bp);
-
-			REG_WR(bp, MISC_REG_AEU_GENERAL_ATTN_12 + func*4, 0);
-			bp->mf_config = SHMEM_RD(bp,
-					   mf_cfg.func_mf_config[func].config);
-			val = SHMEM_RD(bp, func_mb[func].drv_status);
-			if (val & DRV_STATUS_DCC_EVENT_MASK)
-				bnx2x_dcc_event(bp,
-					    (val & DRV_STATUS_DCC_EVENT_MASK));
-			bnx2x__link_status_update(bp);
-			if ((bp->port.pmf == 0) && (val & DRV_STATUS_PMF))
-				bnx2x_pmf_update(bp);
-
-		} else if (attn & BNX2X_MC_ASSERT_BITS) {
-
-			BNX2X_ERR("MC assert!\n");
-			REG_WR(bp, MISC_REG_AEU_GENERAL_ATTN_10, 0);
-			REG_WR(bp, MISC_REG_AEU_GENERAL_ATTN_9, 0);
-			REG_WR(bp, MISC_REG_AEU_GENERAL_ATTN_8, 0);
-			REG_WR(bp, MISC_REG_AEU_GENERAL_ATTN_7, 0);
-			bnx2x_panic();
-
-		} else if (attn & BNX2X_MCP_ASSERT) {
-
-			BNX2X_ERR("MCP assert!\n");
-			REG_WR(bp, MISC_REG_AEU_GENERAL_ATTN_11, 0);
-			bnx2x_fw_dump(bp);
-
-		} else
-			BNX2X_ERR("Unknown HW assert! (attn 0x%x)\n", attn);
-	}
-
-	if (attn & EVEREST_LATCHED_ATTN_IN_USE_MASK) {
-		BNX2X_ERR("LATCHED attention 0x%08x (masked)\n", attn);
-		if (attn & BNX2X_GRC_TIMEOUT) {
-			val = CHIP_IS_E1H(bp) ?
-				REG_RD(bp, MISC_REG_GRC_TIMEOUT_ATTN) : 0;
-			BNX2X_ERR("GRC time-out 0x%08x\n", val);
-		}
-		if (attn & BNX2X_GRC_RSV) {
-			val = CHIP_IS_E1H(bp) ?
-				REG_RD(bp, MISC_REG_GRC_RSV_ATTN) : 0;
-			BNX2X_ERR("GRC reserved 0x%08x\n", val);
-		}
-		REG_WR(bp, MISC_REG_AEU_CLR_LATCH_SIGNAL, 0x7ff);
-	}
-}
-
-static void bnx2x_attn_int_deasserted(struct bnx2x *bp, u32 deasserted)
-{
-	struct attn_route attn;
-	struct attn_route group_mask;
-	int port = BP_PORT(bp);
-	int index;
-	u32 reg_addr;
-	u32 val;
-	u32 aeu_mask;
-
-	/* need to take HW lock because MCP or other port might also
-	   try to handle this event */
-	bnx2x_acquire_alr(bp);
-
-	attn.sig[0] = REG_RD(bp, MISC_REG_AEU_AFTER_INVERT_1_FUNC_0 + port*4);
-	attn.sig[1] = REG_RD(bp, MISC_REG_AEU_AFTER_INVERT_2_FUNC_0 + port*4);
-	attn.sig[2] = REG_RD(bp, MISC_REG_AEU_AFTER_INVERT_3_FUNC_0 + port*4);
-	attn.sig[3] = REG_RD(bp, MISC_REG_AEU_AFTER_INVERT_4_FUNC_0 + port*4);
-	DP(NETIF_MSG_HW, "attn: %08x %08x %08x %08x\n",
-	   attn.sig[0], attn.sig[1], attn.sig[2], attn.sig[3]);
-
-	for (index = 0; index < MAX_DYNAMIC_ATTN_GRPS; index++) {
-		if (deasserted & (1 << index)) {
-			group_mask = bp->attn_group[index];
-
-			DP(NETIF_MSG_HW, "group[%d]: %08x %08x %08x %08x\n",
-			   index, group_mask.sig[0], group_mask.sig[1],
-			   group_mask.sig[2], group_mask.sig[3]);
-
-			bnx2x_attn_int_deasserted3(bp,
-					attn.sig[3] & group_mask.sig[3]);
-			bnx2x_attn_int_deasserted1(bp,
-					attn.sig[1] & group_mask.sig[1]);
-			bnx2x_attn_int_deasserted2(bp,
-					attn.sig[2] & group_mask.sig[2]);
-			bnx2x_attn_int_deasserted0(bp,
-					attn.sig[0] & group_mask.sig[0]);
-
-			if ((attn.sig[0] & group_mask.sig[0] &
-						HW_PRTY_ASSERT_SET_0) ||
-			    (attn.sig[1] & group_mask.sig[1] &
-						HW_PRTY_ASSERT_SET_1) ||
-			    (attn.sig[2] & group_mask.sig[2] &
-						HW_PRTY_ASSERT_SET_2))
-				BNX2X_ERR("FATAL HW block parity attention\n");
-		}
-	}
-
-	bnx2x_release_alr(bp);
-
-	reg_addr = (HC_REG_COMMAND_REG + port*32 + COMMAND_REG_ATTN_BITS_CLR);
-
-	val = ~deasserted;
-	DP(NETIF_MSG_HW, "about to mask 0x%08x at HC addr 0x%x\n",
-	   val, reg_addr);
-	REG_WR(bp, reg_addr, val);
-
-	if (~bp->attn_state & deasserted)
-		BNX2X_ERR("IGU ERROR\n");
-
-	reg_addr = port ? MISC_REG_AEU_MASK_ATTN_FUNC_1 :
-			  MISC_REG_AEU_MASK_ATTN_FUNC_0;
-
-	bnx2x_acquire_hw_lock(bp, HW_LOCK_RESOURCE_PORT0_ATT_MASK + port);
-	aeu_mask = REG_RD(bp, reg_addr);
-
-	DP(NETIF_MSG_HW, "aeu_mask %x  newly deasserted %x\n",
-	   aeu_mask, deasserted);
-	aeu_mask |= (deasserted & 0xff);
-	DP(NETIF_MSG_HW, "new mask %x\n", aeu_mask);
-
-	REG_WR(bp, reg_addr, aeu_mask);
-	bnx2x_release_hw_lock(bp, HW_LOCK_RESOURCE_PORT0_ATT_MASK + port);
-
-	DP(NETIF_MSG_HW, "attn_state %x\n", bp->attn_state);
-	bp->attn_state &= ~deasserted;
-	DP(NETIF_MSG_HW, "new state %x\n", bp->attn_state);
-}
-
-static void bnx2x_attn_int(struct bnx2x *bp)
-{
-	/* read local copy of bits */
-	u32 attn_bits = le32_to_cpu(bp->def_status_blk->atten_status_block.
-								attn_bits);
-	u32 attn_ack = le32_to_cpu(bp->def_status_blk->atten_status_block.
-								attn_bits_ack);
-	u32 attn_state = bp->attn_state;
-
-	/* look for changed bits */
-	u32 asserted   =  attn_bits & ~attn_ack & ~attn_state;
-	u32 deasserted = ~attn_bits &  attn_ack &  attn_state;
-
-	DP(NETIF_MSG_HW,
-	   "attn_bits %x  attn_ack %x  asserted %x  deasserted %x\n",
-	   attn_bits, attn_ack, asserted, deasserted);
-
-	if (~(attn_bits ^ attn_ack) & (attn_bits ^ attn_state))
-		BNX2X_ERR("BAD attention state\n");
-
-	/* handle bits that were raised */
-	if (asserted)
-		bnx2x_attn_int_asserted(bp, asserted);
-
-	if (deasserted)
-		bnx2x_attn_int_deasserted(bp, deasserted);
-}
-
-static void bnx2x_sp_task(struct work_struct *work)
-{
-	struct bnx2x *bp = container_of(work, struct bnx2x, sp_task.work);
-	u16 status;
-
-
-	/* Return here if interrupt is disabled */
-	if (unlikely(atomic_read(&bp->intr_sem) != 0)) {
-		DP(NETIF_MSG_INTR, "called but intr_sem not 0, returning\n");
-		return;
-	}
-
-	status = bnx2x_update_dsb_idx(bp);
-/*	if (status == 0)				     */
-/*		BNX2X_ERR("spurious slowpath interrupt!\n"); */
-
-	DP(NETIF_MSG_INTR, "got a slowpath interrupt (updated %x)\n", status);
-
-	/* HW attentions */
-	if (status & 0x1)
-		bnx2x_attn_int(bp);
-
-	bnx2x_ack_sb(bp, DEF_SB_ID, ATTENTION_ID, le16_to_cpu(bp->def_att_idx),
-		     IGU_INT_NOP, 1);
-	bnx2x_ack_sb(bp, DEF_SB_ID, USTORM_ID, le16_to_cpu(bp->def_u_idx),
-		     IGU_INT_NOP, 1);
-	bnx2x_ack_sb(bp, DEF_SB_ID, CSTORM_ID, le16_to_cpu(bp->def_c_idx),
-		     IGU_INT_NOP, 1);
-	bnx2x_ack_sb(bp, DEF_SB_ID, XSTORM_ID, le16_to_cpu(bp->def_x_idx),
-		     IGU_INT_NOP, 1);
-	bnx2x_ack_sb(bp, DEF_SB_ID, TSTORM_ID, le16_to_cpu(bp->def_t_idx),
-		     IGU_INT_ENABLE, 1);
-
-}
-
-static irqreturn_t bnx2x_msix_sp_int(int irq, void *dev_instance)
-{
-	struct net_device *dev = dev_instance;
-	struct bnx2x *bp = netdev_priv(dev);
-
-	/* Return here if interrupt is disabled */
-	if (unlikely(atomic_read(&bp->intr_sem) != 0)) {
-		DP(NETIF_MSG_INTR, "called but intr_sem not 0, returning\n");
-		return IRQ_HANDLED;
-	}
-
-	bnx2x_ack_sb(bp, DEF_SB_ID, TSTORM_ID, 0, IGU_INT_DISABLE, 0);
-
-#ifdef BNX2X_STOP_ON_ERROR
-	if (unlikely(bp->panic))
-		return IRQ_HANDLED;
-#endif
-
-#ifdef BCM_CNIC
-	{
-		struct cnic_ops *c_ops;
-
-		rcu_read_lock();
-		c_ops = rcu_dereference(bp->cnic_ops);
-		if (c_ops)
-			c_ops->cnic_handler(bp->cnic_data, NULL);
-		rcu_read_unlock();
-	}
-#endif
-	queue_delayed_work(bnx2x_wq, &bp->sp_task, 0);
-
-	return IRQ_HANDLED;
-}
-
-/* end of slow path */
-
-/* Statistics */
-
-/****************************************************************************
-* Macros
-****************************************************************************/
-
-/* sum[hi:lo] += add[hi:lo] */
-#define ADD_64(s_hi, a_hi, s_lo, a_lo) \
-	do { \
-		s_lo += a_lo; \
-		s_hi += a_hi + ((s_lo < a_lo) ? 1 : 0); \
-	} while (0)
-
-/* difference = minuend - subtrahend */
-#define DIFF_64(d_hi, m_hi, s_hi, d_lo, m_lo, s_lo) \
-	do { \
-		if (m_lo < s_lo) { \
-			/* underflow */ \
-			d_hi = m_hi - s_hi; \
-			if (d_hi > 0) { \
-				/* we can 'loan' 1 */ \
-				d_hi--; \
-				d_lo = m_lo + (UINT_MAX - s_lo) + 1; \
-			} else { \
-				/* m_hi <= s_hi */ \
-				d_hi = 0; \
-				d_lo = 0; \
-			} \
-		} else { \
-			/* m_lo >= s_lo */ \
-			if (m_hi < s_hi) { \
-				d_hi = 0; \
-				d_lo = 0; \
-			} else { \
-				/* m_hi >= s_hi */ \
-				d_hi = m_hi - s_hi; \
-				d_lo = m_lo - s_lo; \
-			} \
-		} \
-	} while (0)
-
-#define UPDATE_STAT64(s, t) \
-	do { \
-		DIFF_64(diff.hi, new->s##_hi, pstats->mac_stx[0].t##_hi, \
-			diff.lo, new->s##_lo, pstats->mac_stx[0].t##_lo); \
-		pstats->mac_stx[0].t##_hi = new->s##_hi; \
-		pstats->mac_stx[0].t##_lo = new->s##_lo; \
-		ADD_64(pstats->mac_stx[1].t##_hi, diff.hi, \
-		       pstats->mac_stx[1].t##_lo, diff.lo); \
-	} while (0)
-
-#define UPDATE_STAT64_NIG(s, t) \
-	do { \
-		DIFF_64(diff.hi, new->s##_hi, old->s##_hi, \
-			diff.lo, new->s##_lo, old->s##_lo); \
-		ADD_64(estats->t##_hi, diff.hi, \
-		       estats->t##_lo, diff.lo); \
-	} while (0)
-
-/* sum[hi:lo] += add */
-#define ADD_EXTEND_64(s_hi, s_lo, a) \
-	do { \
-		s_lo += a; \
-		s_hi += (s_lo < a) ? 1 : 0; \
-	} while (0)
-
-#define UPDATE_EXTEND_STAT(s) \
-	do { \
-		ADD_EXTEND_64(pstats->mac_stx[1].s##_hi, \
-			      pstats->mac_stx[1].s##_lo, \
-			      new->s); \
-	} while (0)
-
-#define UPDATE_EXTEND_TSTAT(s, t) \
-	do { \
-		diff = le32_to_cpu(tclient->s) - le32_to_cpu(old_tclient->s); \
-		old_tclient->s = tclient->s; \
-		ADD_EXTEND_64(qstats->t##_hi, qstats->t##_lo, diff); \
-	} while (0)
-
-#define UPDATE_EXTEND_USTAT(s, t) \
-	do { \
-		diff = le32_to_cpu(uclient->s) - le32_to_cpu(old_uclient->s); \
-		old_uclient->s = uclient->s; \
-		ADD_EXTEND_64(qstats->t##_hi, qstats->t##_lo, diff); \
-	} while (0)
-
-#define UPDATE_EXTEND_XSTAT(s, t) \
-	do { \
-		diff = le32_to_cpu(xclient->s) - le32_to_cpu(old_xclient->s); \
-		old_xclient->s = xclient->s; \
-		ADD_EXTEND_64(qstats->t##_hi, qstats->t##_lo, diff); \
-	} while (0)
-
-/* minuend -= subtrahend */
-#define SUB_64(m_hi, s_hi, m_lo, s_lo) \
-	do { \
-		DIFF_64(m_hi, m_hi, s_hi, m_lo, m_lo, s_lo); \
-	} while (0)
-
-/* minuend[hi:lo] -= subtrahend */
-#define SUB_EXTEND_64(m_hi, m_lo, s) \
-	do { \
-		SUB_64(m_hi, 0, m_lo, s); \
-	} while (0)
-
-#define SUB_EXTEND_USTAT(s, t) \
-	do { \
-		diff = le32_to_cpu(uclient->s) - le32_to_cpu(old_uclient->s); \
-		SUB_EXTEND_64(qstats->t##_hi, qstats->t##_lo, diff); \
-	} while (0)
-
-/*
- * General service functions
- */
-
-static inline long bnx2x_hilo(u32 *hiref)
-{
-	u32 lo = *(hiref + 1);
-#if (BITS_PER_LONG == 64)
-	u32 hi = *hiref;
-
-	return HILO_U64(hi, lo);
-#else
-	return lo;
-#endif
-}
-
-/*
- * Init service functions
- */
-
-static void bnx2x_storm_stats_post(struct bnx2x *bp)
-{
-	if (!bp->stats_pending) {
-		struct eth_query_ramrod_data ramrod_data = {0};
-		int i, rc;
-
-		ramrod_data.drv_counter = bp->stats_counter++;
-		ramrod_data.collect_port = bp->port.pmf ? 1 : 0;
-		for_each_queue(bp, i)
-			ramrod_data.ctr_id_vector |= (1 << bp->fp[i].cl_id);
-
-		rc = bnx2x_sp_post(bp, RAMROD_CMD_ID_ETH_STAT_QUERY, 0,
-				   ((u32 *)&ramrod_data)[1],
-				   ((u32 *)&ramrod_data)[0], 0);
-		if (rc == 0) {
-			/* stats ramrod has it's own slot on the spq */
-			bp->spq_left++;
-			bp->stats_pending = 1;
-		}
-	}
-}
-
-static void bnx2x_hw_stats_post(struct bnx2x *bp)
-{
-	struct dmae_command *dmae = &bp->stats_dmae;
-	u32 *stats_comp = bnx2x_sp(bp, stats_comp);
-
-	*stats_comp = DMAE_COMP_VAL;
-	if (CHIP_REV_IS_SLOW(bp))
-		return;
-
-	/* loader */
-	if (bp->executer_idx) {
-		int loader_idx = PMF_DMAE_C(bp);
-
-		memset(dmae, 0, sizeof(struct dmae_command));
-
-		dmae->opcode = (DMAE_CMD_SRC_PCI | DMAE_CMD_DST_GRC |
-				DMAE_CMD_C_DST_GRC | DMAE_CMD_C_ENABLE |
-				DMAE_CMD_DST_RESET |
-#ifdef __BIG_ENDIAN
-				DMAE_CMD_ENDIANITY_B_DW_SWAP |
-#else
-				DMAE_CMD_ENDIANITY_DW_SWAP |
-#endif
-				(BP_PORT(bp) ? DMAE_CMD_PORT_1 :
-					       DMAE_CMD_PORT_0) |
-				(BP_E1HVN(bp) << DMAE_CMD_E1HVN_SHIFT));
-		dmae->src_addr_lo = U64_LO(bnx2x_sp_mapping(bp, dmae[0]));
-		dmae->src_addr_hi = U64_HI(bnx2x_sp_mapping(bp, dmae[0]));
-		dmae->dst_addr_lo = (DMAE_REG_CMD_MEM +
-				     sizeof(struct dmae_command) *
-				     (loader_idx + 1)) >> 2;
-		dmae->dst_addr_hi = 0;
-		dmae->len = sizeof(struct dmae_command) >> 2;
-		if (CHIP_IS_E1(bp))
-			dmae->len--;
-		dmae->comp_addr_lo = dmae_reg_go_c[loader_idx + 1] >> 2;
-		dmae->comp_addr_hi = 0;
-		dmae->comp_val = 1;
-
-		*stats_comp = 0;
-		bnx2x_post_dmae(bp, dmae, loader_idx);
-
-	} else if (bp->func_stx) {
-		*stats_comp = 0;
-		bnx2x_post_dmae(bp, dmae, INIT_DMAE_C(bp));
-	}
-}
-
-static int bnx2x_stats_comp(struct bnx2x *bp)
-{
-	u32 *stats_comp = bnx2x_sp(bp, stats_comp);
-	int cnt = 10;
-
-	might_sleep();
-	while (*stats_comp != DMAE_COMP_VAL) {
-		if (!cnt) {
-			BNX2X_ERR("timeout waiting for stats finished\n");
-			break;
-		}
-		cnt--;
-		msleep(1);
-	}
-	return 1;
-}
-
-/*
- * Statistics service functions
- */
-
-static void bnx2x_stats_pmf_update(struct bnx2x *bp)
-{
-	struct dmae_command *dmae;
-	u32 opcode;
-	int loader_idx = PMF_DMAE_C(bp);
-	u32 *stats_comp = bnx2x_sp(bp, stats_comp);
-
-	/* sanity */
-	if (!IS_E1HMF(bp) || !bp->port.pmf || !bp->port.port_stx) {
-		BNX2X_ERR("BUG!\n");
-		return;
-	}
-
-	bp->executer_idx = 0;
-
-	opcode = (DMAE_CMD_SRC_GRC | DMAE_CMD_DST_PCI |
-		  DMAE_CMD_C_ENABLE |
-		  DMAE_CMD_SRC_RESET | DMAE_CMD_DST_RESET |
-#ifdef __BIG_ENDIAN
-		  DMAE_CMD_ENDIANITY_B_DW_SWAP |
-#else
-		  DMAE_CMD_ENDIANITY_DW_SWAP |
-#endif
-		  (BP_PORT(bp) ? DMAE_CMD_PORT_1 : DMAE_CMD_PORT_0) |
-		  (BP_E1HVN(bp) << DMAE_CMD_E1HVN_SHIFT));
-
-	dmae = bnx2x_sp(bp, dmae[bp->executer_idx++]);
-	dmae->opcode = (opcode | DMAE_CMD_C_DST_GRC);
-	dmae->src_addr_lo = bp->port.port_stx >> 2;
-	dmae->src_addr_hi = 0;
-	dmae->dst_addr_lo = U64_LO(bnx2x_sp_mapping(bp, port_stats));
-	dmae->dst_addr_hi = U64_HI(bnx2x_sp_mapping(bp, port_stats));
-	dmae->len = DMAE_LEN32_RD_MAX;
-	dmae->comp_addr_lo = dmae_reg_go_c[loader_idx] >> 2;
-	dmae->comp_addr_hi = 0;
-	dmae->comp_val = 1;
-
-	dmae = bnx2x_sp(bp, dmae[bp->executer_idx++]);
-	dmae->opcode = (opcode | DMAE_CMD_C_DST_PCI);
-	dmae->src_addr_lo = (bp->port.port_stx >> 2) + DMAE_LEN32_RD_MAX;
-	dmae->src_addr_hi = 0;
-	dmae->dst_addr_lo = U64_LO(bnx2x_sp_mapping(bp, port_stats) +
-				   DMAE_LEN32_RD_MAX * 4);
-	dmae->dst_addr_hi = U64_HI(bnx2x_sp_mapping(bp, port_stats) +
-				   DMAE_LEN32_RD_MAX * 4);
-	dmae->len = (sizeof(struct host_port_stats) >> 2) - DMAE_LEN32_RD_MAX;
-	dmae->comp_addr_lo = U64_LO(bnx2x_sp_mapping(bp, stats_comp));
-	dmae->comp_addr_hi = U64_HI(bnx2x_sp_mapping(bp, stats_comp));
-	dmae->comp_val = DMAE_COMP_VAL;
-
-	*stats_comp = 0;
-	bnx2x_hw_stats_post(bp);
-	bnx2x_stats_comp(bp);
-}
-
-static void bnx2x_port_stats_init(struct bnx2x *bp)
-{
-	struct dmae_command *dmae;
-	int port = BP_PORT(bp);
-	int vn = BP_E1HVN(bp);
-	u32 opcode;
-	int loader_idx = PMF_DMAE_C(bp);
-	u32 mac_addr;
-	u32 *stats_comp = bnx2x_sp(bp, stats_comp);
-
-	/* sanity */
-	if (!bp->link_vars.link_up || !bp->port.pmf) {
-		BNX2X_ERR("BUG!\n");
-		return;
-	}
-
-	bp->executer_idx = 0;
-
-	/* MCP */
-	opcode = (DMAE_CMD_SRC_PCI | DMAE_CMD_DST_GRC |
-		  DMAE_CMD_C_DST_GRC | DMAE_CMD_C_ENABLE |
-		  DMAE_CMD_SRC_RESET | DMAE_CMD_DST_RESET |
-#ifdef __BIG_ENDIAN
-		  DMAE_CMD_ENDIANITY_B_DW_SWAP |
-#else
-		  DMAE_CMD_ENDIANITY_DW_SWAP |
-#endif
-		  (port ? DMAE_CMD_PORT_1 : DMAE_CMD_PORT_0) |
-		  (vn << DMAE_CMD_E1HVN_SHIFT));
-
-	if (bp->port.port_stx) {
-
-		dmae = bnx2x_sp(bp, dmae[bp->executer_idx++]);
-		dmae->opcode = opcode;
-		dmae->src_addr_lo = U64_LO(bnx2x_sp_mapping(bp, port_stats));
-		dmae->src_addr_hi = U64_HI(bnx2x_sp_mapping(bp, port_stats));
-		dmae->dst_addr_lo = bp->port.port_stx >> 2;
-		dmae->dst_addr_hi = 0;
-		dmae->len = sizeof(struct host_port_stats) >> 2;
-		dmae->comp_addr_lo = dmae_reg_go_c[loader_idx] >> 2;
-		dmae->comp_addr_hi = 0;
-		dmae->comp_val = 1;
-	}
-
-	if (bp->func_stx) {
-
-		dmae = bnx2x_sp(bp, dmae[bp->executer_idx++]);
-		dmae->opcode = opcode;
-		dmae->src_addr_lo = U64_LO(bnx2x_sp_mapping(bp, func_stats));
-		dmae->src_addr_hi = U64_HI(bnx2x_sp_mapping(bp, func_stats));
-		dmae->dst_addr_lo = bp->func_stx >> 2;
-		dmae->dst_addr_hi = 0;
-		dmae->len = sizeof(struct host_func_stats) >> 2;
-		dmae->comp_addr_lo = dmae_reg_go_c[loader_idx] >> 2;
-		dmae->comp_addr_hi = 0;
-		dmae->comp_val = 1;
-	}
-
-	/* MAC */
-	opcode = (DMAE_CMD_SRC_GRC | DMAE_CMD_DST_PCI |
-		  DMAE_CMD_C_DST_GRC | DMAE_CMD_C_ENABLE |
-		  DMAE_CMD_SRC_RESET | DMAE_CMD_DST_RESET |
-#ifdef __BIG_ENDIAN
-		  DMAE_CMD_ENDIANITY_B_DW_SWAP |
-#else
-		  DMAE_CMD_ENDIANITY_DW_SWAP |
-#endif
-		  (port ? DMAE_CMD_PORT_1 : DMAE_CMD_PORT_0) |
-		  (vn << DMAE_CMD_E1HVN_SHIFT));
-
-	if (bp->link_vars.mac_type == MAC_TYPE_BMAC) {
-
-		mac_addr = (port ? NIG_REG_INGRESS_BMAC1_MEM :
-				   NIG_REG_INGRESS_BMAC0_MEM);
-
-		/* BIGMAC_REGISTER_TX_STAT_GTPKT ..
-		   BIGMAC_REGISTER_TX_STAT_GTBYT */
-		dmae = bnx2x_sp(bp, dmae[bp->executer_idx++]);
-		dmae->opcode = opcode;
-		dmae->src_addr_lo = (mac_addr +
-				     BIGMAC_REGISTER_TX_STAT_GTPKT) >> 2;
-		dmae->src_addr_hi = 0;
-		dmae->dst_addr_lo = U64_LO(bnx2x_sp_mapping(bp, mac_stats));
-		dmae->dst_addr_hi = U64_HI(bnx2x_sp_mapping(bp, mac_stats));
-		dmae->len = (8 + BIGMAC_REGISTER_TX_STAT_GTBYT -
-			     BIGMAC_REGISTER_TX_STAT_GTPKT) >> 2;
-		dmae->comp_addr_lo = dmae_reg_go_c[loader_idx] >> 2;
-		dmae->comp_addr_hi = 0;
-		dmae->comp_val = 1;
-
-		/* BIGMAC_REGISTER_RX_STAT_GR64 ..
-		   BIGMAC_REGISTER_RX_STAT_GRIPJ */
-		dmae = bnx2x_sp(bp, dmae[bp->executer_idx++]);
-		dmae->opcode = opcode;
-		dmae->src_addr_lo = (mac_addr +
-				     BIGMAC_REGISTER_RX_STAT_GR64) >> 2;
-		dmae->src_addr_hi = 0;
-		dmae->dst_addr_lo = U64_LO(bnx2x_sp_mapping(bp, mac_stats) +
-				offsetof(struct bmac_stats, rx_stat_gr64_lo));
-		dmae->dst_addr_hi = U64_HI(bnx2x_sp_mapping(bp, mac_stats) +
-				offsetof(struct bmac_stats, rx_stat_gr64_lo));
-		dmae->len = (8 + BIGMAC_REGISTER_RX_STAT_GRIPJ -
-			     BIGMAC_REGISTER_RX_STAT_GR64) >> 2;
-		dmae->comp_addr_lo = dmae_reg_go_c[loader_idx] >> 2;
-		dmae->comp_addr_hi = 0;
-		dmae->comp_val = 1;
-
-	} else if (bp->link_vars.mac_type == MAC_TYPE_EMAC) {
-
-		mac_addr = (port ? GRCBASE_EMAC1 : GRCBASE_EMAC0);
-
-		/* EMAC_REG_EMAC_RX_STAT_AC (EMAC_REG_EMAC_RX_STAT_AC_COUNT)*/
-		dmae = bnx2x_sp(bp, dmae[bp->executer_idx++]);
-		dmae->opcode = opcode;
-		dmae->src_addr_lo = (mac_addr +
-				     EMAC_REG_EMAC_RX_STAT_AC) >> 2;
-		dmae->src_addr_hi = 0;
-		dmae->dst_addr_lo = U64_LO(bnx2x_sp_mapping(bp, mac_stats));
-		dmae->dst_addr_hi = U64_HI(bnx2x_sp_mapping(bp, mac_stats));
-		dmae->len = EMAC_REG_EMAC_RX_STAT_AC_COUNT;
-		dmae->comp_addr_lo = dmae_reg_go_c[loader_idx] >> 2;
-		dmae->comp_addr_hi = 0;
-		dmae->comp_val = 1;
-
-		/* EMAC_REG_EMAC_RX_STAT_AC_28 */
-		dmae = bnx2x_sp(bp, dmae[bp->executer_idx++]);
-		dmae->opcode = opcode;
-		dmae->src_addr_lo = (mac_addr +
-				     EMAC_REG_EMAC_RX_STAT_AC_28) >> 2;
-		dmae->src_addr_hi = 0;
-		dmae->dst_addr_lo = U64_LO(bnx2x_sp_mapping(bp, mac_stats) +
-		     offsetof(struct emac_stats, rx_stat_falsecarriererrors));
-		dmae->dst_addr_hi = U64_HI(bnx2x_sp_mapping(bp, mac_stats) +
-		     offsetof(struct emac_stats, rx_stat_falsecarriererrors));
-		dmae->len = 1;
-		dmae->comp_addr_lo = dmae_reg_go_c[loader_idx] >> 2;
-		dmae->comp_addr_hi = 0;
-		dmae->comp_val = 1;
-
-		/* EMAC_REG_EMAC_TX_STAT_AC (EMAC_REG_EMAC_TX_STAT_AC_COUNT)*/
-		dmae = bnx2x_sp(bp, dmae[bp->executer_idx++]);
-		dmae->opcode = opcode;
-		dmae->src_addr_lo = (mac_addr +
-				     EMAC_REG_EMAC_TX_STAT_AC) >> 2;
-		dmae->src_addr_hi = 0;
-		dmae->dst_addr_lo = U64_LO(bnx2x_sp_mapping(bp, mac_stats) +
-			offsetof(struct emac_stats, tx_stat_ifhcoutoctets));
-		dmae->dst_addr_hi = U64_HI(bnx2x_sp_mapping(bp, mac_stats) +
-			offsetof(struct emac_stats, tx_stat_ifhcoutoctets));
-		dmae->len = EMAC_REG_EMAC_TX_STAT_AC_COUNT;
-		dmae->comp_addr_lo = dmae_reg_go_c[loader_idx] >> 2;
-		dmae->comp_addr_hi = 0;
-		dmae->comp_val = 1;
-	}
-
-	/* NIG */
-	dmae = bnx2x_sp(bp, dmae[bp->executer_idx++]);
-	dmae->opcode = opcode;
-	dmae->src_addr_lo = (port ? NIG_REG_STAT1_BRB_DISCARD :
-				    NIG_REG_STAT0_BRB_DISCARD) >> 2;
-	dmae->src_addr_hi = 0;
-	dmae->dst_addr_lo = U64_LO(bnx2x_sp_mapping(bp, nig_stats));
-	dmae->dst_addr_hi = U64_HI(bnx2x_sp_mapping(bp, nig_stats));
-	dmae->len = (sizeof(struct nig_stats) - 4*sizeof(u32)) >> 2;
-	dmae->comp_addr_lo = dmae_reg_go_c[loader_idx] >> 2;
-	dmae->comp_addr_hi = 0;
-	dmae->comp_val = 1;
-
-	dmae = bnx2x_sp(bp, dmae[bp->executer_idx++]);
-	dmae->opcode = opcode;
-	dmae->src_addr_lo = (port ? NIG_REG_STAT1_EGRESS_MAC_PKT0 :
-				    NIG_REG_STAT0_EGRESS_MAC_PKT0) >> 2;
-	dmae->src_addr_hi = 0;
-	dmae->dst_addr_lo = U64_LO(bnx2x_sp_mapping(bp, nig_stats) +
-			offsetof(struct nig_stats, egress_mac_pkt0_lo));
-	dmae->dst_addr_hi = U64_HI(bnx2x_sp_mapping(bp, nig_stats) +
-			offsetof(struct nig_stats, egress_mac_pkt0_lo));
-	dmae->len = (2*sizeof(u32)) >> 2;
-	dmae->comp_addr_lo = dmae_reg_go_c[loader_idx] >> 2;
-	dmae->comp_addr_hi = 0;
-	dmae->comp_val = 1;
-
-	dmae = bnx2x_sp(bp, dmae[bp->executer_idx++]);
-	dmae->opcode = (DMAE_CMD_SRC_GRC | DMAE_CMD_DST_PCI |
-			DMAE_CMD_C_DST_PCI | DMAE_CMD_C_ENABLE |
-			DMAE_CMD_SRC_RESET | DMAE_CMD_DST_RESET |
-#ifdef __BIG_ENDIAN
-			DMAE_CMD_ENDIANITY_B_DW_SWAP |
-#else
-			DMAE_CMD_ENDIANITY_DW_SWAP |
-#endif
-			(port ? DMAE_CMD_PORT_1 : DMAE_CMD_PORT_0) |
-			(vn << DMAE_CMD_E1HVN_SHIFT));
-	dmae->src_addr_lo = (port ? NIG_REG_STAT1_EGRESS_MAC_PKT1 :
-				    NIG_REG_STAT0_EGRESS_MAC_PKT1) >> 2;
-	dmae->src_addr_hi = 0;
-	dmae->dst_addr_lo = U64_LO(bnx2x_sp_mapping(bp, nig_stats) +
-			offsetof(struct nig_stats, egress_mac_pkt1_lo));
-	dmae->dst_addr_hi = U64_HI(bnx2x_sp_mapping(bp, nig_stats) +
-			offsetof(struct nig_stats, egress_mac_pkt1_lo));
-	dmae->len = (2*sizeof(u32)) >> 2;
-	dmae->comp_addr_lo = U64_LO(bnx2x_sp_mapping(bp, stats_comp));
-	dmae->comp_addr_hi = U64_HI(bnx2x_sp_mapping(bp, stats_comp));
-	dmae->comp_val = DMAE_COMP_VAL;
-
-	*stats_comp = 0;
-}
-
-static void bnx2x_func_stats_init(struct bnx2x *bp)
-{
-	struct dmae_command *dmae = &bp->stats_dmae;
-	u32 *stats_comp = bnx2x_sp(bp, stats_comp);
-
-	/* sanity */
-	if (!bp->func_stx) {
-		BNX2X_ERR("BUG!\n");
-		return;
-	}
-
-	bp->executer_idx = 0;
-	memset(dmae, 0, sizeof(struct dmae_command));
-
-	dmae->opcode = (DMAE_CMD_SRC_PCI | DMAE_CMD_DST_GRC |
-			DMAE_CMD_C_DST_PCI | DMAE_CMD_C_ENABLE |
-			DMAE_CMD_SRC_RESET | DMAE_CMD_DST_RESET |
-#ifdef __BIG_ENDIAN
-			DMAE_CMD_ENDIANITY_B_DW_SWAP |
-#else
-			DMAE_CMD_ENDIANITY_DW_SWAP |
-#endif
-			(BP_PORT(bp) ? DMAE_CMD_PORT_1 : DMAE_CMD_PORT_0) |
-			(BP_E1HVN(bp) << DMAE_CMD_E1HVN_SHIFT));
-	dmae->src_addr_lo = U64_LO(bnx2x_sp_mapping(bp, func_stats));
-	dmae->src_addr_hi = U64_HI(bnx2x_sp_mapping(bp, func_stats));
-	dmae->dst_addr_lo = bp->func_stx >> 2;
-	dmae->dst_addr_hi = 0;
-	dmae->len = sizeof(struct host_func_stats) >> 2;
-	dmae->comp_addr_lo = U64_LO(bnx2x_sp_mapping(bp, stats_comp));
-	dmae->comp_addr_hi = U64_HI(bnx2x_sp_mapping(bp, stats_comp));
-	dmae->comp_val = DMAE_COMP_VAL;
-
-	*stats_comp = 0;
-}
-
-static void bnx2x_stats_start(struct bnx2x *bp)
-{
-	if (bp->port.pmf)
-		bnx2x_port_stats_init(bp);
-
-	else if (bp->func_stx)
-		bnx2x_func_stats_init(bp);
-
-	bnx2x_hw_stats_post(bp);
-	bnx2x_storm_stats_post(bp);
-}
-
-static void bnx2x_stats_pmf_start(struct bnx2x *bp)
-{
-	bnx2x_stats_comp(bp);
-	bnx2x_stats_pmf_update(bp);
-	bnx2x_stats_start(bp);
-}
-
-static void bnx2x_stats_restart(struct bnx2x *bp)
-{
-	bnx2x_stats_comp(bp);
-	bnx2x_stats_start(bp);
-}
-
-static void bnx2x_bmac_stats_update(struct bnx2x *bp)
-{
-	struct bmac_stats *new = bnx2x_sp(bp, mac_stats.bmac_stats);
-	struct host_port_stats *pstats = bnx2x_sp(bp, port_stats);
-	struct bnx2x_eth_stats *estats = &bp->eth_stats;
-	struct {
-		u32 lo;
-		u32 hi;
-	} diff;
-
-	UPDATE_STAT64(rx_stat_grerb, rx_stat_ifhcinbadoctets);
-	UPDATE_STAT64(rx_stat_grfcs, rx_stat_dot3statsfcserrors);
-	UPDATE_STAT64(rx_stat_grund, rx_stat_etherstatsundersizepkts);
-	UPDATE_STAT64(rx_stat_grovr, rx_stat_dot3statsframestoolong);
-	UPDATE_STAT64(rx_stat_grfrg, rx_stat_etherstatsfragments);
-	UPDATE_STAT64(rx_stat_grjbr, rx_stat_etherstatsjabbers);
-	UPDATE_STAT64(rx_stat_grxcf, rx_stat_maccontrolframesreceived);
-	UPDATE_STAT64(rx_stat_grxpf, rx_stat_xoffstateentered);
-	UPDATE_STAT64(rx_stat_grxpf, rx_stat_bmac_xpf);
-	UPDATE_STAT64(tx_stat_gtxpf, tx_stat_outxoffsent);
-	UPDATE_STAT64(tx_stat_gtxpf, tx_stat_flowcontroldone);
-	UPDATE_STAT64(tx_stat_gt64, tx_stat_etherstatspkts64octets);
-	UPDATE_STAT64(tx_stat_gt127,
-				tx_stat_etherstatspkts65octetsto127octets);
-	UPDATE_STAT64(tx_stat_gt255,
-				tx_stat_etherstatspkts128octetsto255octets);
-	UPDATE_STAT64(tx_stat_gt511,
-				tx_stat_etherstatspkts256octetsto511octets);
-	UPDATE_STAT64(tx_stat_gt1023,
-				tx_stat_etherstatspkts512octetsto1023octets);
-	UPDATE_STAT64(tx_stat_gt1518,
-				tx_stat_etherstatspkts1024octetsto1522octets);
-	UPDATE_STAT64(tx_stat_gt2047, tx_stat_bmac_2047);
-	UPDATE_STAT64(tx_stat_gt4095, tx_stat_bmac_4095);
-	UPDATE_STAT64(tx_stat_gt9216, tx_stat_bmac_9216);
-	UPDATE_STAT64(tx_stat_gt16383, tx_stat_bmac_16383);
-	UPDATE_STAT64(tx_stat_gterr,
-				tx_stat_dot3statsinternalmactransmiterrors);
-	UPDATE_STAT64(tx_stat_gtufl, tx_stat_bmac_ufl);
-
-	estats->pause_frames_received_hi =
-				pstats->mac_stx[1].rx_stat_bmac_xpf_hi;
-	estats->pause_frames_received_lo =
-				pstats->mac_stx[1].rx_stat_bmac_xpf_lo;
-
-	estats->pause_frames_sent_hi =
-				pstats->mac_stx[1].tx_stat_outxoffsent_hi;
-	estats->pause_frames_sent_lo =
-				pstats->mac_stx[1].tx_stat_outxoffsent_lo;
-}
-
-static void bnx2x_emac_stats_update(struct bnx2x *bp)
-{
-	struct emac_stats *new = bnx2x_sp(bp, mac_stats.emac_stats);
-	struct host_port_stats *pstats = bnx2x_sp(bp, port_stats);
-	struct bnx2x_eth_stats *estats = &bp->eth_stats;
-
-	UPDATE_EXTEND_STAT(rx_stat_ifhcinbadoctets);
-	UPDATE_EXTEND_STAT(tx_stat_ifhcoutbadoctets);
-	UPDATE_EXTEND_STAT(rx_stat_dot3statsfcserrors);
-	UPDATE_EXTEND_STAT(rx_stat_dot3statsalignmenterrors);
-	UPDATE_EXTEND_STAT(rx_stat_dot3statscarriersenseerrors);
-	UPDATE_EXTEND_STAT(rx_stat_falsecarriererrors);
-	UPDATE_EXTEND_STAT(rx_stat_etherstatsundersizepkts);
-	UPDATE_EXTEND_STAT(rx_stat_dot3statsframestoolong);
-	UPDATE_EXTEND_STAT(rx_stat_etherstatsfragments);
-	UPDATE_EXTEND_STAT(rx_stat_etherstatsjabbers);
-	UPDATE_EXTEND_STAT(rx_stat_maccontrolframesreceived);
-	UPDATE_EXTEND_STAT(rx_stat_xoffstateentered);
-	UPDATE_EXTEND_STAT(rx_stat_xonpauseframesreceived);
-	UPDATE_EXTEND_STAT(rx_stat_xoffpauseframesreceived);
-	UPDATE_EXTEND_STAT(tx_stat_outxonsent);
-	UPDATE_EXTEND_STAT(tx_stat_outxoffsent);
-	UPDATE_EXTEND_STAT(tx_stat_flowcontroldone);
-	UPDATE_EXTEND_STAT(tx_stat_etherstatscollisions);
-	UPDATE_EXTEND_STAT(tx_stat_dot3statssinglecollisionframes);
-	UPDATE_EXTEND_STAT(tx_stat_dot3statsmultiplecollisionframes);
-	UPDATE_EXTEND_STAT(tx_stat_dot3statsdeferredtransmissions);
-	UPDATE_EXTEND_STAT(tx_stat_dot3statsexcessivecollisions);
-	UPDATE_EXTEND_STAT(tx_stat_dot3statslatecollisions);
-	UPDATE_EXTEND_STAT(tx_stat_etherstatspkts64octets);
-	UPDATE_EXTEND_STAT(tx_stat_etherstatspkts65octetsto127octets);
-	UPDATE_EXTEND_STAT(tx_stat_etherstatspkts128octetsto255octets);
-	UPDATE_EXTEND_STAT(tx_stat_etherstatspkts256octetsto511octets);
-	UPDATE_EXTEND_STAT(tx_stat_etherstatspkts512octetsto1023octets);
-	UPDATE_EXTEND_STAT(tx_stat_etherstatspkts1024octetsto1522octets);
-	UPDATE_EXTEND_STAT(tx_stat_etherstatspktsover1522octets);
-	UPDATE_EXTEND_STAT(tx_stat_dot3statsinternalmactransmiterrors);
-
-	estats->pause_frames_received_hi =
-			pstats->mac_stx[1].rx_stat_xonpauseframesreceived_hi;
-	estats->pause_frames_received_lo =
-			pstats->mac_stx[1].rx_stat_xonpauseframesreceived_lo;
-	ADD_64(estats->pause_frames_received_hi,
-	       pstats->mac_stx[1].rx_stat_xoffpauseframesreceived_hi,
-	       estats->pause_frames_received_lo,
-	       pstats->mac_stx[1].rx_stat_xoffpauseframesreceived_lo);
-
-	estats->pause_frames_sent_hi =
-			pstats->mac_stx[1].tx_stat_outxonsent_hi;
-	estats->pause_frames_sent_lo =
-			pstats->mac_stx[1].tx_stat_outxonsent_lo;
-	ADD_64(estats->pause_frames_sent_hi,
-	       pstats->mac_stx[1].tx_stat_outxoffsent_hi,
-	       estats->pause_frames_sent_lo,
-	       pstats->mac_stx[1].tx_stat_outxoffsent_lo);
-}
-
-static int bnx2x_hw_stats_update(struct bnx2x *bp)
-{
-	struct nig_stats *new = bnx2x_sp(bp, nig_stats);
-	struct nig_stats *old = &(bp->port.old_nig_stats);
-	struct host_port_stats *pstats = bnx2x_sp(bp, port_stats);
-	struct bnx2x_eth_stats *estats = &bp->eth_stats;
-	struct {
-		u32 lo;
-		u32 hi;
-	} diff;
-	u32 nig_timer_max;
-
-	if (bp->link_vars.mac_type == MAC_TYPE_BMAC)
-		bnx2x_bmac_stats_update(bp);
-
-	else if (bp->link_vars.mac_type == MAC_TYPE_EMAC)
-		bnx2x_emac_stats_update(bp);
-
-	else { /* unreached */
-		BNX2X_ERR("stats updated by DMAE but no MAC active\n");
-		return -1;
-	}
-
-	ADD_EXTEND_64(pstats->brb_drop_hi, pstats->brb_drop_lo,
-		      new->brb_discard - old->brb_discard);
-	ADD_EXTEND_64(estats->brb_truncate_hi, estats->brb_truncate_lo,
-		      new->brb_truncate - old->brb_truncate);
-
-	UPDATE_STAT64_NIG(egress_mac_pkt0,
-					etherstatspkts1024octetsto1522octets);
-	UPDATE_STAT64_NIG(egress_mac_pkt1, etherstatspktsover1522octets);
-
-	memcpy(old, new, sizeof(struct nig_stats));
-
-	memcpy(&(estats->rx_stat_ifhcinbadoctets_hi), &(pstats->mac_stx[1]),
-	       sizeof(struct mac_stx));
-	estats->brb_drop_hi = pstats->brb_drop_hi;
-	estats->brb_drop_lo = pstats->brb_drop_lo;
-
-	pstats->host_port_stats_start = ++pstats->host_port_stats_end;
-
-	nig_timer_max = SHMEM_RD(bp, port_mb[BP_PORT(bp)].stat_nig_timer);
-	if (nig_timer_max != estats->nig_timer_max) {
-		estats->nig_timer_max = nig_timer_max;
-		BNX2X_ERR("NIG timer max (%u)\n", estats->nig_timer_max);
-	}
-
-	return 0;
-}
-
-static int bnx2x_storm_stats_update(struct bnx2x *bp)
-{
-	struct eth_stats_query *stats = bnx2x_sp(bp, fw_stats);
-	struct tstorm_per_port_stats *tport =
-					&stats->tstorm_common.port_statistics;
-	struct host_func_stats *fstats = bnx2x_sp(bp, func_stats);
-	struct bnx2x_eth_stats *estats = &bp->eth_stats;
-	int i;
-
-	memcpy(&(fstats->total_bytes_received_hi),
-	       &(bnx2x_sp(bp, func_stats_base)->total_bytes_received_hi),
-	       sizeof(struct host_func_stats) - 2*sizeof(u32));
-	estats->error_bytes_received_hi = 0;
-	estats->error_bytes_received_lo = 0;
-	estats->etherstatsoverrsizepkts_hi = 0;
-	estats->etherstatsoverrsizepkts_lo = 0;
-	estats->no_buff_discard_hi = 0;
-	estats->no_buff_discard_lo = 0;
-
-	for_each_queue(bp, i) {
-		struct bnx2x_fastpath *fp = &bp->fp[i];
-		int cl_id = fp->cl_id;
-		struct tstorm_per_client_stats *tclient =
-				&stats->tstorm_common.client_statistics[cl_id];
-		struct tstorm_per_client_stats *old_tclient = &fp->old_tclient;
-		struct ustorm_per_client_stats *uclient =
-				&stats->ustorm_common.client_statistics[cl_id];
-		struct ustorm_per_client_stats *old_uclient = &fp->old_uclient;
-		struct xstorm_per_client_stats *xclient =
-				&stats->xstorm_common.client_statistics[cl_id];
-		struct xstorm_per_client_stats *old_xclient = &fp->old_xclient;
-		struct bnx2x_eth_q_stats *qstats = &fp->eth_q_stats;
-		u32 diff;
-
-		/* are storm stats valid? */
-		if ((u16)(le16_to_cpu(xclient->stats_counter) + 1) !=
-							bp->stats_counter) {
-			DP(BNX2X_MSG_STATS, "[%d] stats not updated by xstorm"
-			   "  xstorm counter (%d) != stats_counter (%d)\n",
-			   i, xclient->stats_counter, bp->stats_counter);
-			return -1;
-		}
-		if ((u16)(le16_to_cpu(tclient->stats_counter) + 1) !=
-							bp->stats_counter) {
-			DP(BNX2X_MSG_STATS, "[%d] stats not updated by tstorm"
-			   "  tstorm counter (%d) != stats_counter (%d)\n",
-			   i, tclient->stats_counter, bp->stats_counter);
-			return -2;
-		}
-		if ((u16)(le16_to_cpu(uclient->stats_counter) + 1) !=
-							bp->stats_counter) {
-			DP(BNX2X_MSG_STATS, "[%d] stats not updated by ustorm"
-			   "  ustorm counter (%d) != stats_counter (%d)\n",
-			   i, uclient->stats_counter, bp->stats_counter);
-			return -4;
-		}
-
-		qstats->total_bytes_received_hi =
-			le32_to_cpu(tclient->rcv_broadcast_bytes.hi);
-		qstats->total_bytes_received_lo =
-			le32_to_cpu(tclient->rcv_broadcast_bytes.lo);
-
-		ADD_64(qstats->total_bytes_received_hi,
-		       le32_to_cpu(tclient->rcv_multicast_bytes.hi),
-		       qstats->total_bytes_received_lo,
-		       le32_to_cpu(tclient->rcv_multicast_bytes.lo));
-
-		ADD_64(qstats->total_bytes_received_hi,
-		       le32_to_cpu(tclient->rcv_unicast_bytes.hi),
-		       qstats->total_bytes_received_lo,
-		       le32_to_cpu(tclient->rcv_unicast_bytes.lo));
-
-		qstats->valid_bytes_received_hi =
-					qstats->total_bytes_received_hi;
-		qstats->valid_bytes_received_lo =
-					qstats->total_bytes_received_lo;
-
-		qstats->error_bytes_received_hi =
-				le32_to_cpu(tclient->rcv_error_bytes.hi);
-		qstats->error_bytes_received_lo =
-				le32_to_cpu(tclient->rcv_error_bytes.lo);
-
-		ADD_64(qstats->total_bytes_received_hi,
-		       qstats->error_bytes_received_hi,
-		       qstats->total_bytes_received_lo,
-		       qstats->error_bytes_received_lo);
-
-		UPDATE_EXTEND_TSTAT(rcv_unicast_pkts,
-					total_unicast_packets_received);
-		UPDATE_EXTEND_TSTAT(rcv_multicast_pkts,
-					total_multicast_packets_received);
-		UPDATE_EXTEND_TSTAT(rcv_broadcast_pkts,
-					total_broadcast_packets_received);
-		UPDATE_EXTEND_TSTAT(packets_too_big_discard,
-					etherstatsoverrsizepkts);
-		UPDATE_EXTEND_TSTAT(no_buff_discard, no_buff_discard);
-
-		SUB_EXTEND_USTAT(ucast_no_buff_pkts,
-					total_unicast_packets_received);
-		SUB_EXTEND_USTAT(mcast_no_buff_pkts,
-					total_multicast_packets_received);
-		SUB_EXTEND_USTAT(bcast_no_buff_pkts,
-					total_broadcast_packets_received);
-		UPDATE_EXTEND_USTAT(ucast_no_buff_pkts, no_buff_discard);
-		UPDATE_EXTEND_USTAT(mcast_no_buff_pkts, no_buff_discard);
-		UPDATE_EXTEND_USTAT(bcast_no_buff_pkts, no_buff_discard);
-
-		qstats->total_bytes_transmitted_hi =
-				le32_to_cpu(xclient->unicast_bytes_sent.hi);
-		qstats->total_bytes_transmitted_lo =
-				le32_to_cpu(xclient->unicast_bytes_sent.lo);
-
-		ADD_64(qstats->total_bytes_transmitted_hi,
-		       le32_to_cpu(xclient->multicast_bytes_sent.hi),
-		       qstats->total_bytes_transmitted_lo,
-		       le32_to_cpu(xclient->multicast_bytes_sent.lo));
-
-		ADD_64(qstats->total_bytes_transmitted_hi,
-		       le32_to_cpu(xclient->broadcast_bytes_sent.hi),
-		       qstats->total_bytes_transmitted_lo,
-		       le32_to_cpu(xclient->broadcast_bytes_sent.lo));
-
-		UPDATE_EXTEND_XSTAT(unicast_pkts_sent,
-					total_unicast_packets_transmitted);
-		UPDATE_EXTEND_XSTAT(multicast_pkts_sent,
-					total_multicast_packets_transmitted);
-		UPDATE_EXTEND_XSTAT(broadcast_pkts_sent,
-					total_broadcast_packets_transmitted);
-
-		old_tclient->checksum_discard = tclient->checksum_discard;
-		old_tclient->ttl0_discard = tclient->ttl0_discard;
-
-		ADD_64(fstats->total_bytes_received_hi,
-		       qstats->total_bytes_received_hi,
-		       fstats->total_bytes_received_lo,
-		       qstats->total_bytes_received_lo);
-		ADD_64(fstats->total_bytes_transmitted_hi,
-		       qstats->total_bytes_transmitted_hi,
-		       fstats->total_bytes_transmitted_lo,
-		       qstats->total_bytes_transmitted_lo);
-		ADD_64(fstats->total_unicast_packets_received_hi,
-		       qstats->total_unicast_packets_received_hi,
-		       fstats->total_unicast_packets_received_lo,
-		       qstats->total_unicast_packets_received_lo);
-		ADD_64(fstats->total_multicast_packets_received_hi,
-		       qstats->total_multicast_packets_received_hi,
-		       fstats->total_multicast_packets_received_lo,
-		       qstats->total_multicast_packets_received_lo);
-		ADD_64(fstats->total_broadcast_packets_received_hi,
-		       qstats->total_broadcast_packets_received_hi,
-		       fstats->total_broadcast_packets_received_lo,
-		       qstats->total_broadcast_packets_received_lo);
-		ADD_64(fstats->total_unicast_packets_transmitted_hi,
-		       qstats->total_unicast_packets_transmitted_hi,
-		       fstats->total_unicast_packets_transmitted_lo,
-		       qstats->total_unicast_packets_transmitted_lo);
-		ADD_64(fstats->total_multicast_packets_transmitted_hi,
-		       qstats->total_multicast_packets_transmitted_hi,
-		       fstats->total_multicast_packets_transmitted_lo,
-		       qstats->total_multicast_packets_transmitted_lo);
-		ADD_64(fstats->total_broadcast_packets_transmitted_hi,
-		       qstats->total_broadcast_packets_transmitted_hi,
-		       fstats->total_broadcast_packets_transmitted_lo,
-		       qstats->total_broadcast_packets_transmitted_lo);
-		ADD_64(fstats->valid_bytes_received_hi,
-		       qstats->valid_bytes_received_hi,
-		       fstats->valid_bytes_received_lo,
-		       qstats->valid_bytes_received_lo);
-
-		ADD_64(estats->error_bytes_received_hi,
-		       qstats->error_bytes_received_hi,
-		       estats->error_bytes_received_lo,
-		       qstats->error_bytes_received_lo);
-		ADD_64(estats->etherstatsoverrsizepkts_hi,
-		       qstats->etherstatsoverrsizepkts_hi,
-		       estats->etherstatsoverrsizepkts_lo,
-		       qstats->etherstatsoverrsizepkts_lo);
-		ADD_64(estats->no_buff_discard_hi, qstats->no_buff_discard_hi,
-		       estats->no_buff_discard_lo, qstats->no_buff_discard_lo);
-	}
-
-	ADD_64(fstats->total_bytes_received_hi,
-	       estats->rx_stat_ifhcinbadoctets_hi,
-	       fstats->total_bytes_received_lo,
-	       estats->rx_stat_ifhcinbadoctets_lo);
-
-	memcpy(estats, &(fstats->total_bytes_received_hi),
-	       sizeof(struct host_func_stats) - 2*sizeof(u32));
-
-	ADD_64(estats->etherstatsoverrsizepkts_hi,
-	       estats->rx_stat_dot3statsframestoolong_hi,
-	       estats->etherstatsoverrsizepkts_lo,
-	       estats->rx_stat_dot3statsframestoolong_lo);
-	ADD_64(estats->error_bytes_received_hi,
-	       estats->rx_stat_ifhcinbadoctets_hi,
-	       estats->error_bytes_received_lo,
-	       estats->rx_stat_ifhcinbadoctets_lo);
-
-	if (bp->port.pmf) {
-		estats->mac_filter_discard =
-				le32_to_cpu(tport->mac_filter_discard);
-		estats->xxoverflow_discard =
-				le32_to_cpu(tport->xxoverflow_discard);
-		estats->brb_truncate_discard =
-				le32_to_cpu(tport->brb_truncate_discard);
-		estats->mac_discard = le32_to_cpu(tport->mac_discard);
-	}
-
-	fstats->host_func_stats_start = ++fstats->host_func_stats_end;
-
-	bp->stats_pending = 0;
-
-	return 0;
-}
-
-static void bnx2x_net_stats_update(struct bnx2x *bp)
-{
-	struct bnx2x_eth_stats *estats = &bp->eth_stats;
-	struct net_device_stats *nstats = &bp->dev->stats;
-	int i;
-
-	nstats->rx_packets =
-		bnx2x_hilo(&estats->total_unicast_packets_received_hi) +
-		bnx2x_hilo(&estats->total_multicast_packets_received_hi) +
-		bnx2x_hilo(&estats->total_broadcast_packets_received_hi);
-
-	nstats->tx_packets =
-		bnx2x_hilo(&estats->total_unicast_packets_transmitted_hi) +
-		bnx2x_hilo(&estats->total_multicast_packets_transmitted_hi) +
-		bnx2x_hilo(&estats->total_broadcast_packets_transmitted_hi);
-
-	nstats->rx_bytes = bnx2x_hilo(&estats->total_bytes_received_hi);
-
-	nstats->tx_bytes = bnx2x_hilo(&estats->total_bytes_transmitted_hi);
-
-	nstats->rx_dropped = estats->mac_discard;
-	for_each_queue(bp, i)
-		nstats->rx_dropped +=
-			le32_to_cpu(bp->fp[i].old_tclient.checksum_discard);
-
-	nstats->tx_dropped = 0;
-
-	nstats->multicast =
-		bnx2x_hilo(&estats->total_multicast_packets_received_hi);
-
-	nstats->collisions =
-		bnx2x_hilo(&estats->tx_stat_etherstatscollisions_hi);
-
-	nstats->rx_length_errors =
-		bnx2x_hilo(&estats->rx_stat_etherstatsundersizepkts_hi) +
-		bnx2x_hilo(&estats->etherstatsoverrsizepkts_hi);
-	nstats->rx_over_errors = bnx2x_hilo(&estats->brb_drop_hi) +
-				 bnx2x_hilo(&estats->brb_truncate_hi);
-	nstats->rx_crc_errors =
-		bnx2x_hilo(&estats->rx_stat_dot3statsfcserrors_hi);
-	nstats->rx_frame_errors =
-		bnx2x_hilo(&estats->rx_stat_dot3statsalignmenterrors_hi);
-	nstats->rx_fifo_errors = bnx2x_hilo(&estats->no_buff_discard_hi);
-	nstats->rx_missed_errors = estats->xxoverflow_discard;
-
-	nstats->rx_errors = nstats->rx_length_errors +
-			    nstats->rx_over_errors +
-			    nstats->rx_crc_errors +
-			    nstats->rx_frame_errors +
-			    nstats->rx_fifo_errors +
-			    nstats->rx_missed_errors;
-
-	nstats->tx_aborted_errors =
-		bnx2x_hilo(&estats->tx_stat_dot3statslatecollisions_hi) +
-		bnx2x_hilo(&estats->tx_stat_dot3statsexcessivecollisions_hi);
-	nstats->tx_carrier_errors =
-		bnx2x_hilo(&estats->rx_stat_dot3statscarriersenseerrors_hi);
-	nstats->tx_fifo_errors = 0;
-	nstats->tx_heartbeat_errors = 0;
-	nstats->tx_window_errors = 0;
-
-	nstats->tx_errors = nstats->tx_aborted_errors +
-			    nstats->tx_carrier_errors +
-	    bnx2x_hilo(&estats->tx_stat_dot3statsinternalmactransmiterrors_hi);
-}
-
-static void bnx2x_drv_stats_update(struct bnx2x *bp)
-{
-	struct bnx2x_eth_stats *estats = &bp->eth_stats;
-	int i;
-
-	estats->driver_xoff = 0;
-	estats->rx_err_discard_pkt = 0;
-	estats->rx_skb_alloc_failed = 0;
-	estats->hw_csum_err = 0;
-	for_each_queue(bp, i) {
-		struct bnx2x_eth_q_stats *qstats = &bp->fp[i].eth_q_stats;
-
-		estats->driver_xoff += qstats->driver_xoff;
-		estats->rx_err_discard_pkt += qstats->rx_err_discard_pkt;
-		estats->rx_skb_alloc_failed += qstats->rx_skb_alloc_failed;
-		estats->hw_csum_err += qstats->hw_csum_err;
-	}
-}
-
-static void bnx2x_stats_update(struct bnx2x *bp)
-{
-	u32 *stats_comp = bnx2x_sp(bp, stats_comp);
-
-	if (*stats_comp != DMAE_COMP_VAL)
-		return;
-
-	if (bp->port.pmf)
-		bnx2x_hw_stats_update(bp);
-
-	if (bnx2x_storm_stats_update(bp) && (bp->stats_pending++ == 3)) {
-		BNX2X_ERR("storm stats were not updated for 3 times\n");
-		bnx2x_panic();
-		return;
-	}
-
-	bnx2x_net_stats_update(bp);
-	bnx2x_drv_stats_update(bp);
-
-	if (netif_msg_timer(bp)) {
-		struct bnx2x_fastpath *fp0_rx = bp->fp;
-		struct bnx2x_fastpath *fp0_tx = bp->fp;
-		struct tstorm_per_client_stats *old_tclient =
-							&bp->fp->old_tclient;
-		struct bnx2x_eth_q_stats *qstats = &bp->fp->eth_q_stats;
-		struct bnx2x_eth_stats *estats = &bp->eth_stats;
-		struct net_device_stats *nstats = &bp->dev->stats;
-		int i;
-
-		netdev_printk(KERN_DEBUG, bp->dev, "\n");
-		printk(KERN_DEBUG "  tx avail (%4x)  tx hc idx (%x)"
-				  "  tx pkt (%lx)\n",
-		       bnx2x_tx_avail(fp0_tx),
-		       le16_to_cpu(*fp0_tx->tx_cons_sb), nstats->tx_packets);
-		printk(KERN_DEBUG "  rx usage (%4x)  rx hc idx (%x)"
-				  "  rx pkt (%lx)\n",
-		       (u16)(le16_to_cpu(*fp0_rx->rx_cons_sb) -
-			     fp0_rx->rx_comp_cons),
-		       le16_to_cpu(*fp0_rx->rx_cons_sb), nstats->rx_packets);
-		printk(KERN_DEBUG "  %s (Xoff events %u)  brb drops %u  "
-				  "brb truncate %u\n",
-		       (netif_queue_stopped(bp->dev) ? "Xoff" : "Xon"),
-		       qstats->driver_xoff,
-		       estats->brb_drop_lo, estats->brb_truncate_lo);
-		printk(KERN_DEBUG "tstats: checksum_discard %u  "
-			"packets_too_big_discard %lu  no_buff_discard %lu  "
-			"mac_discard %u  mac_filter_discard %u  "
-			"xxovrflow_discard %u  brb_truncate_discard %u  "
-			"ttl0_discard %u\n",
-		       le32_to_cpu(old_tclient->checksum_discard),
-		       bnx2x_hilo(&qstats->etherstatsoverrsizepkts_hi),
-		       bnx2x_hilo(&qstats->no_buff_discard_hi),
-		       estats->mac_discard, estats->mac_filter_discard,
-		       estats->xxoverflow_discard, estats->brb_truncate_discard,
-		       le32_to_cpu(old_tclient->ttl0_discard));
-
-		for_each_queue(bp, i) {
-			printk(KERN_DEBUG "[%d]: %lu\t%lu\t%lu\n", i,
-			       bnx2x_fp(bp, i, tx_pkt),
-			       bnx2x_fp(bp, i, rx_pkt),
-			       bnx2x_fp(bp, i, rx_calls));
-		}
-	}
-
-	bnx2x_hw_stats_post(bp);
-	bnx2x_storm_stats_post(bp);
-}
-
-static void bnx2x_port_stats_stop(struct bnx2x *bp)
-{
-	struct dmae_command *dmae;
-	u32 opcode;
-	int loader_idx = PMF_DMAE_C(bp);
-	u32 *stats_comp = bnx2x_sp(bp, stats_comp);
-
-	bp->executer_idx = 0;
-
-	opcode = (DMAE_CMD_SRC_PCI | DMAE_CMD_DST_GRC |
-		  DMAE_CMD_C_ENABLE |
-		  DMAE_CMD_SRC_RESET | DMAE_CMD_DST_RESET |
-#ifdef __BIG_ENDIAN
-		  DMAE_CMD_ENDIANITY_B_DW_SWAP |
-#else
-		  DMAE_CMD_ENDIANITY_DW_SWAP |
-#endif
-		  (BP_PORT(bp) ? DMAE_CMD_PORT_1 : DMAE_CMD_PORT_0) |
-		  (BP_E1HVN(bp) << DMAE_CMD_E1HVN_SHIFT));
-
-	if (bp->port.port_stx) {
-
-		dmae = bnx2x_sp(bp, dmae[bp->executer_idx++]);
-		if (bp->func_stx)
-			dmae->opcode = (opcode | DMAE_CMD_C_DST_GRC);
-		else
-			dmae->opcode = (opcode | DMAE_CMD_C_DST_PCI);
-		dmae->src_addr_lo = U64_LO(bnx2x_sp_mapping(bp, port_stats));
-		dmae->src_addr_hi = U64_HI(bnx2x_sp_mapping(bp, port_stats));
-		dmae->dst_addr_lo = bp->port.port_stx >> 2;
-		dmae->dst_addr_hi = 0;
-		dmae->len = sizeof(struct host_port_stats) >> 2;
-		if (bp->func_stx) {
-			dmae->comp_addr_lo = dmae_reg_go_c[loader_idx] >> 2;
-			dmae->comp_addr_hi = 0;
-			dmae->comp_val = 1;
-		} else {
-			dmae->comp_addr_lo =
-				U64_LO(bnx2x_sp_mapping(bp, stats_comp));
-			dmae->comp_addr_hi =
-				U64_HI(bnx2x_sp_mapping(bp, stats_comp));
-			dmae->comp_val = DMAE_COMP_VAL;
-
-			*stats_comp = 0;
-		}
-	}
-
-	if (bp->func_stx) {
-
-		dmae = bnx2x_sp(bp, dmae[bp->executer_idx++]);
-		dmae->opcode = (opcode | DMAE_CMD_C_DST_PCI);
-		dmae->src_addr_lo = U64_LO(bnx2x_sp_mapping(bp, func_stats));
-		dmae->src_addr_hi = U64_HI(bnx2x_sp_mapping(bp, func_stats));
-		dmae->dst_addr_lo = bp->func_stx >> 2;
-		dmae->dst_addr_hi = 0;
-		dmae->len = sizeof(struct host_func_stats) >> 2;
-		dmae->comp_addr_lo = U64_LO(bnx2x_sp_mapping(bp, stats_comp));
-		dmae->comp_addr_hi = U64_HI(bnx2x_sp_mapping(bp, stats_comp));
-		dmae->comp_val = DMAE_COMP_VAL;
-
-		*stats_comp = 0;
-	}
-}
-
-static void bnx2x_stats_stop(struct bnx2x *bp)
-{
-	int update = 0;
-
-	bnx2x_stats_comp(bp);
-
-	if (bp->port.pmf)
-		update = (bnx2x_hw_stats_update(bp) == 0);
-
-	update |= (bnx2x_storm_stats_update(bp) == 0);
-
-	if (update) {
-		bnx2x_net_stats_update(bp);
-
-		if (bp->port.pmf)
-			bnx2x_port_stats_stop(bp);
-
-		bnx2x_hw_stats_post(bp);
-		bnx2x_stats_comp(bp);
-	}
-}
-
-static void bnx2x_stats_do_nothing(struct bnx2x *bp)
-{
-}
-
-static const struct {
-	void (*action)(struct bnx2x *bp);
-	enum bnx2x_stats_state next_state;
-} bnx2x_stats_stm[STATS_STATE_MAX][STATS_EVENT_MAX] = {
-/* state	event	*/
-{
-/* DISABLED	PMF	*/ {bnx2x_stats_pmf_update, STATS_STATE_DISABLED},
-/*		LINK_UP	*/ {bnx2x_stats_start,      STATS_STATE_ENABLED},
-/*		UPDATE	*/ {bnx2x_stats_do_nothing, STATS_STATE_DISABLED},
-/*		STOP	*/ {bnx2x_stats_do_nothing, STATS_STATE_DISABLED}
-},
-{
-/* ENABLED	PMF	*/ {bnx2x_stats_pmf_start,  STATS_STATE_ENABLED},
-/*		LINK_UP	*/ {bnx2x_stats_restart,    STATS_STATE_ENABLED},
-/*		UPDATE	*/ {bnx2x_stats_update,     STATS_STATE_ENABLED},
-/*		STOP	*/ {bnx2x_stats_stop,       STATS_STATE_DISABLED}
-}
-};
-
-static void bnx2x_stats_handle(struct bnx2x *bp, enum bnx2x_stats_event event)
-{
-	enum bnx2x_stats_state state = bp->stats_state;
-
-	bnx2x_stats_stm[state][event].action(bp);
-	bp->stats_state = bnx2x_stats_stm[state][event].next_state;
-
-	/* Make sure the state has been "changed" */
-	smp_wmb();
-
-	if ((event != STATS_EVENT_UPDATE) || netif_msg_timer(bp))
-		DP(BNX2X_MSG_STATS, "state %d -> event %d -> state %d\n",
-		   state, event, bp->stats_state);
-}
-
-static void bnx2x_port_stats_base_init(struct bnx2x *bp)
-{
-	struct dmae_command *dmae;
-	u32 *stats_comp = bnx2x_sp(bp, stats_comp);
-
-	/* sanity */
-	if (!bp->port.pmf || !bp->port.port_stx) {
-		BNX2X_ERR("BUG!\n");
-		return;
-	}
-
-	bp->executer_idx = 0;
-
-	dmae = bnx2x_sp(bp, dmae[bp->executer_idx++]);
-	dmae->opcode = (DMAE_CMD_SRC_PCI | DMAE_CMD_DST_GRC |
-			DMAE_CMD_C_DST_PCI | DMAE_CMD_C_ENABLE |
-			DMAE_CMD_SRC_RESET | DMAE_CMD_DST_RESET |
-#ifdef __BIG_ENDIAN
-			DMAE_CMD_ENDIANITY_B_DW_SWAP |
-#else
-			DMAE_CMD_ENDIANITY_DW_SWAP |
-#endif
-			(BP_PORT(bp) ? DMAE_CMD_PORT_1 : DMAE_CMD_PORT_0) |
-			(BP_E1HVN(bp) << DMAE_CMD_E1HVN_SHIFT));
-	dmae->src_addr_lo = U64_LO(bnx2x_sp_mapping(bp, port_stats));
-	dmae->src_addr_hi = U64_HI(bnx2x_sp_mapping(bp, port_stats));
-	dmae->dst_addr_lo = bp->port.port_stx >> 2;
-	dmae->dst_addr_hi = 0;
-	dmae->len = sizeof(struct host_port_stats) >> 2;
-	dmae->comp_addr_lo = U64_LO(bnx2x_sp_mapping(bp, stats_comp));
-	dmae->comp_addr_hi = U64_HI(bnx2x_sp_mapping(bp, stats_comp));
-	dmae->comp_val = DMAE_COMP_VAL;
-
-	*stats_comp = 0;
-	bnx2x_hw_stats_post(bp);
-	bnx2x_stats_comp(bp);
-}
-
-static void bnx2x_func_stats_base_init(struct bnx2x *bp)
-{
-	int vn, vn_max = IS_E1HMF(bp) ? E1HVN_MAX : E1VN_MAX;
-	int port = BP_PORT(bp);
-	int func;
-	u32 func_stx;
-
-	/* sanity */
-	if (!bp->port.pmf || !bp->func_stx) {
-		BNX2X_ERR("BUG!\n");
-		return;
-	}
-
-	/* save our func_stx */
-	func_stx = bp->func_stx;
-
-	for (vn = VN_0; vn < vn_max; vn++) {
-		func = 2*vn + port;
-
-		bp->func_stx = SHMEM_RD(bp, func_mb[func].fw_mb_param);
-		bnx2x_func_stats_init(bp);
-		bnx2x_hw_stats_post(bp);
-		bnx2x_stats_comp(bp);
-	}
-
-	/* restore our func_stx */
-	bp->func_stx = func_stx;
-}
-
-static void bnx2x_func_stats_base_update(struct bnx2x *bp)
-{
-	struct dmae_command *dmae = &bp->stats_dmae;
-	u32 *stats_comp = bnx2x_sp(bp, stats_comp);
-
-	/* sanity */
-	if (!bp->func_stx) {
-		BNX2X_ERR("BUG!\n");
-		return;
-	}
-
-	bp->executer_idx = 0;
-	memset(dmae, 0, sizeof(struct dmae_command));
-
-	dmae->opcode = (DMAE_CMD_SRC_GRC | DMAE_CMD_DST_PCI |
-			DMAE_CMD_C_DST_PCI | DMAE_CMD_C_ENABLE |
-			DMAE_CMD_SRC_RESET | DMAE_CMD_DST_RESET |
-#ifdef __BIG_ENDIAN
-			DMAE_CMD_ENDIANITY_B_DW_SWAP |
-#else
-			DMAE_CMD_ENDIANITY_DW_SWAP |
-#endif
-			(BP_PORT(bp) ? DMAE_CMD_PORT_1 : DMAE_CMD_PORT_0) |
-			(BP_E1HVN(bp) << DMAE_CMD_E1HVN_SHIFT));
-	dmae->src_addr_lo = bp->func_stx >> 2;
-	dmae->src_addr_hi = 0;
-	dmae->dst_addr_lo = U64_LO(bnx2x_sp_mapping(bp, func_stats_base));
-	dmae->dst_addr_hi = U64_HI(bnx2x_sp_mapping(bp, func_stats_base));
-	dmae->len = sizeof(struct host_func_stats) >> 2;
-	dmae->comp_addr_lo = U64_LO(bnx2x_sp_mapping(bp, stats_comp));
-	dmae->comp_addr_hi = U64_HI(bnx2x_sp_mapping(bp, stats_comp));
-	dmae->comp_val = DMAE_COMP_VAL;
-
-	*stats_comp = 0;
-	bnx2x_hw_stats_post(bp);
-	bnx2x_stats_comp(bp);
-}
-
-static void bnx2x_stats_init(struct bnx2x *bp)
-{
-	int port = BP_PORT(bp);
-	int func = BP_FUNC(bp);
-	int i;
-
-	bp->stats_pending = 0;
-	bp->executer_idx = 0;
-	bp->stats_counter = 0;
-
-	/* port and func stats for management */
-	if (!BP_NOMCP(bp)) {
-		bp->port.port_stx = SHMEM_RD(bp, port_mb[port].port_stx);
-		bp->func_stx = SHMEM_RD(bp, func_mb[func].fw_mb_param);
-
-	} else {
-		bp->port.port_stx = 0;
-		bp->func_stx = 0;
-	}
-	DP(BNX2X_MSG_STATS, "port_stx 0x%x  func_stx 0x%x\n",
-	   bp->port.port_stx, bp->func_stx);
-
-	/* port stats */
-	memset(&(bp->port.old_nig_stats), 0, sizeof(struct nig_stats));
-	bp->port.old_nig_stats.brb_discard =
-			REG_RD(bp, NIG_REG_STAT0_BRB_DISCARD + port*0x38);
-	bp->port.old_nig_stats.brb_truncate =
-			REG_RD(bp, NIG_REG_STAT0_BRB_TRUNCATE + port*0x38);
-	REG_RD_DMAE(bp, NIG_REG_STAT0_EGRESS_MAC_PKT0 + port*0x50,
-		    &(bp->port.old_nig_stats.egress_mac_pkt0_lo), 2);
-	REG_RD_DMAE(bp, NIG_REG_STAT0_EGRESS_MAC_PKT1 + port*0x50,
-		    &(bp->port.old_nig_stats.egress_mac_pkt1_lo), 2);
-
-	/* function stats */
-	for_each_queue(bp, i) {
-		struct bnx2x_fastpath *fp = &bp->fp[i];
-
-		memset(&fp->old_tclient, 0,
-		       sizeof(struct tstorm_per_client_stats));
-		memset(&fp->old_uclient, 0,
-		       sizeof(struct ustorm_per_client_stats));
-		memset(&fp->old_xclient, 0,
-		       sizeof(struct xstorm_per_client_stats));
-		memset(&fp->eth_q_stats, 0, sizeof(struct bnx2x_eth_q_stats));
-	}
-
-	memset(&bp->dev->stats, 0, sizeof(struct net_device_stats));
-	memset(&bp->eth_stats, 0, sizeof(struct bnx2x_eth_stats));
-
-	bp->stats_state = STATS_STATE_DISABLED;
-
-	if (bp->port.pmf) {
-		if (bp->port.port_stx)
-			bnx2x_port_stats_base_init(bp);
-
-		if (bp->func_stx)
-			bnx2x_func_stats_base_init(bp);
-
-	} else if (bp->func_stx)
-		bnx2x_func_stats_base_update(bp);
-}
-
-static void bnx2x_timer(unsigned long data)
-{
-	struct bnx2x *bp = (struct bnx2x *) data;
-
-	if (!netif_running(bp->dev))
-		return;
-
-	if (atomic_read(&bp->intr_sem) != 0)
-		goto timer_restart;
-
-	if (poll) {
-		struct bnx2x_fastpath *fp = &bp->fp[0];
-		int rc;
-
-		bnx2x_tx_int(fp);
-		rc = bnx2x_rx_int(fp, 1000);
-	}
-
-	if (!BP_NOMCP(bp)) {
-		int func = BP_FUNC(bp);
-		u32 drv_pulse;
-		u32 mcp_pulse;
-
-		++bp->fw_drv_pulse_wr_seq;
-		bp->fw_drv_pulse_wr_seq &= DRV_PULSE_SEQ_MASK;
-		/* TBD - add SYSTEM_TIME */
-		drv_pulse = bp->fw_drv_pulse_wr_seq;
-		SHMEM_WR(bp, func_mb[func].drv_pulse_mb, drv_pulse);
-
-		mcp_pulse = (SHMEM_RD(bp, func_mb[func].mcp_pulse_mb) &
-			     MCP_PULSE_SEQ_MASK);
-		/* The delta between driver pulse and mcp response
-		 * should be 1 (before mcp response) or 0 (after mcp response)
-		 */
-		if ((drv_pulse != mcp_pulse) &&
-		    (drv_pulse != ((mcp_pulse + 1) & MCP_PULSE_SEQ_MASK))) {
-			/* someone lost a heartbeat... */
-			BNX2X_ERR("drv_pulse (0x%x) != mcp_pulse (0x%x)\n",
-				  drv_pulse, mcp_pulse);
-		}
-	}
-
-	if (bp->state == BNX2X_STATE_OPEN)
-		bnx2x_stats_handle(bp, STATS_EVENT_UPDATE);
-
-timer_restart:
-	mod_timer(&bp->timer, jiffies + bp->current_interval);
-}
-
-/* end of Statistics */
-
-/* nic init */
-
-/*
- * nic init service functions
- */
-
-static void bnx2x_zero_sb(struct bnx2x *bp, int sb_id)
-{
-	int port = BP_PORT(bp);
-
-	/* "CSTORM" */
-	bnx2x_init_fill(bp, CSEM_REG_FAST_MEMORY +
-			CSTORM_SB_HOST_STATUS_BLOCK_U_OFFSET(port, sb_id), 0,
-			CSTORM_SB_STATUS_BLOCK_U_SIZE / 4);
-	bnx2x_init_fill(bp, CSEM_REG_FAST_MEMORY +
-			CSTORM_SB_HOST_STATUS_BLOCK_C_OFFSET(port, sb_id), 0,
-			CSTORM_SB_STATUS_BLOCK_C_SIZE / 4);
-}
-
-static void bnx2x_init_sb(struct bnx2x *bp, struct host_status_block *sb,
-			  dma_addr_t mapping, int sb_id)
-{
-	int port = BP_PORT(bp);
-	int func = BP_FUNC(bp);
-	int index;
-	u64 section;
-
-	/* USTORM */
-	section = ((u64)mapping) + offsetof(struct host_status_block,
-					    u_status_block);
-	sb->u_status_block.status_block_id = sb_id;
-
-	REG_WR(bp, BAR_CSTRORM_INTMEM +
-	       CSTORM_SB_HOST_SB_ADDR_U_OFFSET(port, sb_id), U64_LO(section));
-	REG_WR(bp, BAR_CSTRORM_INTMEM +
-	       ((CSTORM_SB_HOST_SB_ADDR_U_OFFSET(port, sb_id)) + 4),
-	       U64_HI(section));
-	REG_WR8(bp, BAR_CSTRORM_INTMEM + FP_USB_FUNC_OFF +
-		CSTORM_SB_HOST_STATUS_BLOCK_U_OFFSET(port, sb_id), func);
-
-	for (index = 0; index < HC_USTORM_SB_NUM_INDICES; index++)
-		REG_WR16(bp, BAR_CSTRORM_INTMEM +
-			 CSTORM_SB_HC_DISABLE_U_OFFSET(port, sb_id, index), 1);
-
-	/* CSTORM */
-	section = ((u64)mapping) + offsetof(struct host_status_block,
-					    c_status_block);
-	sb->c_status_block.status_block_id = sb_id;
-
-	REG_WR(bp, BAR_CSTRORM_INTMEM +
-	       CSTORM_SB_HOST_SB_ADDR_C_OFFSET(port, sb_id), U64_LO(section));
-	REG_WR(bp, BAR_CSTRORM_INTMEM +
-	       ((CSTORM_SB_HOST_SB_ADDR_C_OFFSET(port, sb_id)) + 4),
-	       U64_HI(section));
-	REG_WR8(bp, BAR_CSTRORM_INTMEM + FP_CSB_FUNC_OFF +
-		CSTORM_SB_HOST_STATUS_BLOCK_C_OFFSET(port, sb_id), func);
-
-	for (index = 0; index < HC_CSTORM_SB_NUM_INDICES; index++)
-		REG_WR16(bp, BAR_CSTRORM_INTMEM +
-			 CSTORM_SB_HC_DISABLE_C_OFFSET(port, sb_id, index), 1);
-
-	bnx2x_ack_sb(bp, sb_id, CSTORM_ID, 0, IGU_INT_ENABLE, 0);
-}
-
-static void bnx2x_zero_def_sb(struct bnx2x *bp)
-{
-	int func = BP_FUNC(bp);
-
-	bnx2x_init_fill(bp, TSEM_REG_FAST_MEMORY +
-			TSTORM_DEF_SB_HOST_STATUS_BLOCK_OFFSET(func), 0,
-			sizeof(struct tstorm_def_status_block)/4);
-	bnx2x_init_fill(bp, CSEM_REG_FAST_MEMORY +
-			CSTORM_DEF_SB_HOST_STATUS_BLOCK_U_OFFSET(func), 0,
-			sizeof(struct cstorm_def_status_block_u)/4);
-	bnx2x_init_fill(bp, CSEM_REG_FAST_MEMORY +
-			CSTORM_DEF_SB_HOST_STATUS_BLOCK_C_OFFSET(func), 0,
-			sizeof(struct cstorm_def_status_block_c)/4);
-	bnx2x_init_fill(bp, XSEM_REG_FAST_MEMORY +
-			XSTORM_DEF_SB_HOST_STATUS_BLOCK_OFFSET(func), 0,
-			sizeof(struct xstorm_def_status_block)/4);
-}
-
-static void bnx2x_init_def_sb(struct bnx2x *bp,
-			      struct host_def_status_block *def_sb,
-			      dma_addr_t mapping, int sb_id)
-{
-	int port = BP_PORT(bp);
-	int func = BP_FUNC(bp);
-	int index, val, reg_offset;
-	u64 section;
-
-	/* ATTN */
-	section = ((u64)mapping) + offsetof(struct host_def_status_block,
-					    atten_status_block);
-	def_sb->atten_status_block.status_block_id = sb_id;
-
-	bp->attn_state = 0;
-
-	reg_offset = (port ? MISC_REG_AEU_ENABLE1_FUNC_1_OUT_0 :
-			     MISC_REG_AEU_ENABLE1_FUNC_0_OUT_0);
-
-	for (index = 0; index < MAX_DYNAMIC_ATTN_GRPS; index++) {
-		bp->attn_group[index].sig[0] = REG_RD(bp,
-						     reg_offset + 0x10*index);
-		bp->attn_group[index].sig[1] = REG_RD(bp,
-					       reg_offset + 0x4 + 0x10*index);
-		bp->attn_group[index].sig[2] = REG_RD(bp,
-					       reg_offset + 0x8 + 0x10*index);
-		bp->attn_group[index].sig[3] = REG_RD(bp,
-					       reg_offset + 0xc + 0x10*index);
-	}
-
-	reg_offset = (port ? HC_REG_ATTN_MSG1_ADDR_L :
-			     HC_REG_ATTN_MSG0_ADDR_L);
-
-	REG_WR(bp, reg_offset, U64_LO(section));
-	REG_WR(bp, reg_offset + 4, U64_HI(section));
-
-	reg_offset = (port ? HC_REG_ATTN_NUM_P1 : HC_REG_ATTN_NUM_P0);
-
-	val = REG_RD(bp, reg_offset);
-	val |= sb_id;
-	REG_WR(bp, reg_offset, val);
-
-	/* USTORM */
-	section = ((u64)mapping) + offsetof(struct host_def_status_block,
-					    u_def_status_block);
-	def_sb->u_def_status_block.status_block_id = sb_id;
-
-	REG_WR(bp, BAR_CSTRORM_INTMEM +
-	       CSTORM_DEF_SB_HOST_SB_ADDR_U_OFFSET(func), U64_LO(section));
-	REG_WR(bp, BAR_CSTRORM_INTMEM +
-	       ((CSTORM_DEF_SB_HOST_SB_ADDR_U_OFFSET(func)) + 4),
-	       U64_HI(section));
-	REG_WR8(bp, BAR_CSTRORM_INTMEM + DEF_USB_FUNC_OFF +
-		CSTORM_DEF_SB_HOST_STATUS_BLOCK_U_OFFSET(func), func);
-
-	for (index = 0; index < HC_USTORM_DEF_SB_NUM_INDICES; index++)
-		REG_WR16(bp, BAR_CSTRORM_INTMEM +
-			 CSTORM_DEF_SB_HC_DISABLE_U_OFFSET(func, index), 1);
-
-	/* CSTORM */
-	section = ((u64)mapping) + offsetof(struct host_def_status_block,
-					    c_def_status_block);
-	def_sb->c_def_status_block.status_block_id = sb_id;
-
-	REG_WR(bp, BAR_CSTRORM_INTMEM +
-	       CSTORM_DEF_SB_HOST_SB_ADDR_C_OFFSET(func), U64_LO(section));
-	REG_WR(bp, BAR_CSTRORM_INTMEM +
-	       ((CSTORM_DEF_SB_HOST_SB_ADDR_C_OFFSET(func)) + 4),
-	       U64_HI(section));
-	REG_WR8(bp, BAR_CSTRORM_INTMEM + DEF_CSB_FUNC_OFF +
-		CSTORM_DEF_SB_HOST_STATUS_BLOCK_C_OFFSET(func), func);
-
-	for (index = 0; index < HC_CSTORM_DEF_SB_NUM_INDICES; index++)
-		REG_WR16(bp, BAR_CSTRORM_INTMEM +
-			 CSTORM_DEF_SB_HC_DISABLE_C_OFFSET(func, index), 1);
-
-	/* TSTORM */
-	section = ((u64)mapping) + offsetof(struct host_def_status_block,
-					    t_def_status_block);
-	def_sb->t_def_status_block.status_block_id = sb_id;
-
-	REG_WR(bp, BAR_TSTRORM_INTMEM +
-	       TSTORM_DEF_SB_HOST_SB_ADDR_OFFSET(func), U64_LO(section));
-	REG_WR(bp, BAR_TSTRORM_INTMEM +
-	       ((TSTORM_DEF_SB_HOST_SB_ADDR_OFFSET(func)) + 4),
-	       U64_HI(section));
-	REG_WR8(bp, BAR_TSTRORM_INTMEM + DEF_TSB_FUNC_OFF +
-		TSTORM_DEF_SB_HOST_STATUS_BLOCK_OFFSET(func), func);
-
-	for (index = 0; index < HC_TSTORM_DEF_SB_NUM_INDICES; index++)
-		REG_WR16(bp, BAR_TSTRORM_INTMEM +
-			 TSTORM_DEF_SB_HC_DISABLE_OFFSET(func, index), 1);
-
-	/* XSTORM */
-	section = ((u64)mapping) + offsetof(struct host_def_status_block,
-					    x_def_status_block);
-	def_sb->x_def_status_block.status_block_id = sb_id;
-
-	REG_WR(bp, BAR_XSTRORM_INTMEM +
-	       XSTORM_DEF_SB_HOST_SB_ADDR_OFFSET(func), U64_LO(section));
-	REG_WR(bp, BAR_XSTRORM_INTMEM +
-	       ((XSTORM_DEF_SB_HOST_SB_ADDR_OFFSET(func)) + 4),
-	       U64_HI(section));
-	REG_WR8(bp, BAR_XSTRORM_INTMEM + DEF_XSB_FUNC_OFF +
-		XSTORM_DEF_SB_HOST_STATUS_BLOCK_OFFSET(func), func);
-
-	for (index = 0; index < HC_XSTORM_DEF_SB_NUM_INDICES; index++)
-		REG_WR16(bp, BAR_XSTRORM_INTMEM +
-			 XSTORM_DEF_SB_HC_DISABLE_OFFSET(func, index), 1);
-
-	bp->stats_pending = 0;
-	bp->set_mac_pending = 0;
-
-	bnx2x_ack_sb(bp, sb_id, CSTORM_ID, 0, IGU_INT_ENABLE, 0);
-}
-
-static void bnx2x_update_coalesce(struct bnx2x *bp)
-{
-	int port = BP_PORT(bp);
-	int i;
-
-	for_each_queue(bp, i) {
-		int sb_id = bp->fp[i].sb_id;
-
-		/* HC_INDEX_U_ETH_RX_CQ_CONS */
-		REG_WR8(bp, BAR_CSTRORM_INTMEM +
-			CSTORM_SB_HC_TIMEOUT_U_OFFSET(port, sb_id,
-						      U_SB_ETH_RX_CQ_INDEX),
-			bp->rx_ticks/(4 * BNX2X_BTR));
-		REG_WR16(bp, BAR_CSTRORM_INTMEM +
-			 CSTORM_SB_HC_DISABLE_U_OFFSET(port, sb_id,
-						       U_SB_ETH_RX_CQ_INDEX),
-			 (bp->rx_ticks/(4 * BNX2X_BTR)) ? 0 : 1);
-
-		/* HC_INDEX_C_ETH_TX_CQ_CONS */
-		REG_WR8(bp, BAR_CSTRORM_INTMEM +
-			CSTORM_SB_HC_TIMEOUT_C_OFFSET(port, sb_id,
-						      C_SB_ETH_TX_CQ_INDEX),
-			bp->tx_ticks/(4 * BNX2X_BTR));
-		REG_WR16(bp, BAR_CSTRORM_INTMEM +
-			 CSTORM_SB_HC_DISABLE_C_OFFSET(port, sb_id,
-						       C_SB_ETH_TX_CQ_INDEX),
-			 (bp->tx_ticks/(4 * BNX2X_BTR)) ? 0 : 1);
-	}
-}
-
-static inline void bnx2x_free_tpa_pool(struct bnx2x *bp,
-				       struct bnx2x_fastpath *fp, int last)
-{
-	int i;
-
-	for (i = 0; i < last; i++) {
-		struct sw_rx_bd *rx_buf = &(fp->tpa_pool[i]);
-		struct sk_buff *skb = rx_buf->skb;
-
-		if (skb == NULL) {
-			DP(NETIF_MSG_IFDOWN, "tpa bin %d empty on free\n", i);
-			continue;
-		}
-
-		if (fp->tpa_state[i] == BNX2X_TPA_START)
-			pci_unmap_single(bp->pdev,
-					 pci_unmap_addr(rx_buf, mapping),
-					 bp->rx_buf_size, PCI_DMA_FROMDEVICE);
-
-		dev_kfree_skb(skb);
-		rx_buf->skb = NULL;
-	}
-}
-
-static void bnx2x_init_rx_rings(struct bnx2x *bp)
-{
-	int func = BP_FUNC(bp);
-	int max_agg_queues = CHIP_IS_E1(bp) ? ETH_MAX_AGGREGATION_QUEUES_E1 :
-					      ETH_MAX_AGGREGATION_QUEUES_E1H;
-	u16 ring_prod, cqe_ring_prod;
-	int i, j;
-
-	bp->rx_buf_size = bp->dev->mtu + ETH_OVREHEAD + BNX2X_RX_ALIGN;
-	DP(NETIF_MSG_IFUP,
-	   "mtu %d  rx_buf_size %d\n", bp->dev->mtu, bp->rx_buf_size);
-
-	if (bp->flags & TPA_ENABLE_FLAG) {
-
-		for_each_queue(bp, j) {
-			struct bnx2x_fastpath *fp = &bp->fp[j];
-
-			for (i = 0; i < max_agg_queues; i++) {
-				fp->tpa_pool[i].skb =
-				   netdev_alloc_skb(bp->dev, bp->rx_buf_size);
-				if (!fp->tpa_pool[i].skb) {
-					BNX2X_ERR("Failed to allocate TPA "
-						  "skb pool for queue[%d] - "
-						  "disabling TPA on this "
-						  "queue!\n", j);
-					bnx2x_free_tpa_pool(bp, fp, i);
-					fp->disable_tpa = 1;
-					break;
-				}
-				pci_unmap_addr_set((struct sw_rx_bd *)
-							&bp->fp->tpa_pool[i],
-						   mapping, 0);
-				fp->tpa_state[i] = BNX2X_TPA_STOP;
-			}
-		}
-	}
-
-	for_each_queue(bp, j) {
-		struct bnx2x_fastpath *fp = &bp->fp[j];
-
-		fp->rx_bd_cons = 0;
-		fp->rx_cons_sb = BNX2X_RX_SB_INDEX;
-		fp->rx_bd_cons_sb = BNX2X_RX_SB_BD_INDEX;
-
-		/* "next page" elements initialization */
-		/* SGE ring */
-		for (i = 1; i <= NUM_RX_SGE_PAGES; i++) {
-			struct eth_rx_sge *sge;
-
-			sge = &fp->rx_sge_ring[RX_SGE_CNT * i - 2];
-			sge->addr_hi =
-				cpu_to_le32(U64_HI(fp->rx_sge_mapping +
-					BCM_PAGE_SIZE*(i % NUM_RX_SGE_PAGES)));
-			sge->addr_lo =
-				cpu_to_le32(U64_LO(fp->rx_sge_mapping +
-					BCM_PAGE_SIZE*(i % NUM_RX_SGE_PAGES)));
-		}
-
-		bnx2x_init_sge_ring_bit_mask(fp);
-
-		/* RX BD ring */
-		for (i = 1; i <= NUM_RX_RINGS; i++) {
-			struct eth_rx_bd *rx_bd;
-
-			rx_bd = &fp->rx_desc_ring[RX_DESC_CNT * i - 2];
-			rx_bd->addr_hi =
-				cpu_to_le32(U64_HI(fp->rx_desc_mapping +
-					    BCM_PAGE_SIZE*(i % NUM_RX_RINGS)));
-			rx_bd->addr_lo =
-				cpu_to_le32(U64_LO(fp->rx_desc_mapping +
-					    BCM_PAGE_SIZE*(i % NUM_RX_RINGS)));
-		}
-
-		/* CQ ring */
-		for (i = 1; i <= NUM_RCQ_RINGS; i++) {
-			struct eth_rx_cqe_next_page *nextpg;
-
-			nextpg = (struct eth_rx_cqe_next_page *)
-				&fp->rx_comp_ring[RCQ_DESC_CNT * i - 1];
-			nextpg->addr_hi =
-				cpu_to_le32(U64_HI(fp->rx_comp_mapping +
-					   BCM_PAGE_SIZE*(i % NUM_RCQ_RINGS)));
-			nextpg->addr_lo =
-				cpu_to_le32(U64_LO(fp->rx_comp_mapping +
-					   BCM_PAGE_SIZE*(i % NUM_RCQ_RINGS)));
-		}
-
-		/* Allocate SGEs and initialize the ring elements */
-		for (i = 0, ring_prod = 0;
-		     i < MAX_RX_SGE_CNT*NUM_RX_SGE_PAGES; i++) {
-
-			if (bnx2x_alloc_rx_sge(bp, fp, ring_prod) < 0) {
-				BNX2X_ERR("was only able to allocate "
-					  "%d rx sges\n", i);
-				BNX2X_ERR("disabling TPA for queue[%d]\n", j);
-				/* Cleanup already allocated elements */
-				bnx2x_free_rx_sge_range(bp, fp, ring_prod);
-				bnx2x_free_tpa_pool(bp, fp, max_agg_queues);
-				fp->disable_tpa = 1;
-				ring_prod = 0;
-				break;
-			}
-			ring_prod = NEXT_SGE_IDX(ring_prod);
-		}
-		fp->rx_sge_prod = ring_prod;
-
-		/* Allocate BDs and initialize BD ring */
-		fp->rx_comp_cons = 0;
-		cqe_ring_prod = ring_prod = 0;
-		for (i = 0; i < bp->rx_ring_size; i++) {
-			if (bnx2x_alloc_rx_skb(bp, fp, ring_prod) < 0) {
-				BNX2X_ERR("was only able to allocate "
-					  "%d rx skbs on queue[%d]\n", i, j);
-				fp->eth_q_stats.rx_skb_alloc_failed++;
-				break;
-			}
-			ring_prod = NEXT_RX_IDX(ring_prod);
-			cqe_ring_prod = NEXT_RCQ_IDX(cqe_ring_prod);
-			WARN_ON(ring_prod <= i);
-		}
-
-		fp->rx_bd_prod = ring_prod;
-		/* must not have more available CQEs than BDs */
-		fp->rx_comp_prod = min((u16)(NUM_RCQ_RINGS*RCQ_DESC_CNT),
-				       cqe_ring_prod);
-		fp->rx_pkt = fp->rx_calls = 0;
-
-		/* Warning!
-		 * this will generate an interrupt (to the TSTORM)
-		 * must only be done after chip is initialized
-		 */
-		bnx2x_update_rx_prod(bp, fp, ring_prod, fp->rx_comp_prod,
-				     fp->rx_sge_prod);
-		if (j != 0)
-			continue;
-
-		REG_WR(bp, BAR_USTRORM_INTMEM +
-		       USTORM_MEM_WORKAROUND_ADDRESS_OFFSET(func),
-		       U64_LO(fp->rx_comp_mapping));
-		REG_WR(bp, BAR_USTRORM_INTMEM +
-		       USTORM_MEM_WORKAROUND_ADDRESS_OFFSET(func) + 4,
-		       U64_HI(fp->rx_comp_mapping));
-	}
-}
-
-static void bnx2x_init_tx_ring(struct bnx2x *bp)
-{
-	int i, j;
-
-	for_each_queue(bp, j) {
-		struct bnx2x_fastpath *fp = &bp->fp[j];
-
-		for (i = 1; i <= NUM_TX_RINGS; i++) {
-			struct eth_tx_next_bd *tx_next_bd =
-				&fp->tx_desc_ring[TX_DESC_CNT * i - 1].next_bd;
-
-			tx_next_bd->addr_hi =
-				cpu_to_le32(U64_HI(fp->tx_desc_mapping +
-					    BCM_PAGE_SIZE*(i % NUM_TX_RINGS)));
-			tx_next_bd->addr_lo =
-				cpu_to_le32(U64_LO(fp->tx_desc_mapping +
-					    BCM_PAGE_SIZE*(i % NUM_TX_RINGS)));
-		}
-
-		fp->tx_db.data.header.header = DOORBELL_HDR_DB_TYPE;
-		fp->tx_db.data.zero_fill1 = 0;
-		fp->tx_db.data.prod = 0;
-
-		fp->tx_pkt_prod = 0;
-		fp->tx_pkt_cons = 0;
-		fp->tx_bd_prod = 0;
-		fp->tx_bd_cons = 0;
-		fp->tx_cons_sb = BNX2X_TX_SB_INDEX;
-		fp->tx_pkt = 0;
-	}
-}
-
-static void bnx2x_init_sp_ring(struct bnx2x *bp)
-{
-	int func = BP_FUNC(bp);
-
-	spin_lock_init(&bp->spq_lock);
-
-	bp->spq_left = MAX_SPQ_PENDING;
-	bp->spq_prod_idx = 0;
-	bp->dsb_sp_prod = BNX2X_SP_DSB_INDEX;
-	bp->spq_prod_bd = bp->spq;
-	bp->spq_last_bd = bp->spq_prod_bd + MAX_SP_DESC_CNT;
-
-	REG_WR(bp, XSEM_REG_FAST_MEMORY + XSTORM_SPQ_PAGE_BASE_OFFSET(func),
-	       U64_LO(bp->spq_mapping));
-	REG_WR(bp,
-	       XSEM_REG_FAST_MEMORY + XSTORM_SPQ_PAGE_BASE_OFFSET(func) + 4,
-	       U64_HI(bp->spq_mapping));
-
-	REG_WR(bp, XSEM_REG_FAST_MEMORY + XSTORM_SPQ_PROD_OFFSET(func),
-	       bp->spq_prod_idx);
-}
-
-static void bnx2x_init_context(struct bnx2x *bp)
-{
-	int i;
-
-	/* Rx */
-	for_each_queue(bp, i) {
-		struct eth_context *context = bnx2x_sp(bp, context[i].eth);
-		struct bnx2x_fastpath *fp = &bp->fp[i];
-		u8 cl_id = fp->cl_id;
-
-		context->ustorm_st_context.common.sb_index_numbers =
-						BNX2X_RX_SB_INDEX_NUM;
-		context->ustorm_st_context.common.clientId = cl_id;
-		context->ustorm_st_context.common.status_block_id = fp->sb_id;
-		context->ustorm_st_context.common.flags =
-			(USTORM_ETH_ST_CONTEXT_CONFIG_ENABLE_MC_ALIGNMENT |
-			 USTORM_ETH_ST_CONTEXT_CONFIG_ENABLE_STATISTICS);
-		context->ustorm_st_context.common.statistics_counter_id =
-						cl_id;
-		context->ustorm_st_context.common.mc_alignment_log_size =
-						BNX2X_RX_ALIGN_SHIFT;
-		context->ustorm_st_context.common.bd_buff_size =
-						bp->rx_buf_size;
-		context->ustorm_st_context.common.bd_page_base_hi =
-						U64_HI(fp->rx_desc_mapping);
-		context->ustorm_st_context.common.bd_page_base_lo =
-						U64_LO(fp->rx_desc_mapping);
-		if (!fp->disable_tpa) {
-			context->ustorm_st_context.common.flags |=
-				USTORM_ETH_ST_CONTEXT_CONFIG_ENABLE_TPA;
-			context->ustorm_st_context.common.sge_buff_size =
-				(u16)min((u32)SGE_PAGE_SIZE*PAGES_PER_SGE,
-					 (u32)0xffff);
-			context->ustorm_st_context.common.sge_page_base_hi =
-						U64_HI(fp->rx_sge_mapping);
-			context->ustorm_st_context.common.sge_page_base_lo =
-						U64_LO(fp->rx_sge_mapping);
-
-			context->ustorm_st_context.common.max_sges_for_packet =
-				SGE_PAGE_ALIGN(bp->dev->mtu) >> SGE_PAGE_SHIFT;
-			context->ustorm_st_context.common.max_sges_for_packet =
-				((context->ustorm_st_context.common.
-				  max_sges_for_packet + PAGES_PER_SGE - 1) &
-				 (~(PAGES_PER_SGE - 1))) >> PAGES_PER_SGE_SHIFT;
-		}
-
-		context->ustorm_ag_context.cdu_usage =
-			CDU_RSRVD_VALUE_TYPE_A(HW_CID(bp, i),
-					       CDU_REGION_NUMBER_UCM_AG,
-					       ETH_CONNECTION_TYPE);
-
-		context->xstorm_ag_context.cdu_reserved =
-			CDU_RSRVD_VALUE_TYPE_A(HW_CID(bp, i),
-					       CDU_REGION_NUMBER_XCM_AG,
-					       ETH_CONNECTION_TYPE);
-	}
-
-	/* Tx */
-	for_each_queue(bp, i) {
-		struct bnx2x_fastpath *fp = &bp->fp[i];
-		struct eth_context *context =
-			bnx2x_sp(bp, context[i].eth);
-
-		context->cstorm_st_context.sb_index_number =
-						C_SB_ETH_TX_CQ_INDEX;
-		context->cstorm_st_context.status_block_id = fp->sb_id;
-
-		context->xstorm_st_context.tx_bd_page_base_hi =
-						U64_HI(fp->tx_desc_mapping);
-		context->xstorm_st_context.tx_bd_page_base_lo =
-						U64_LO(fp->tx_desc_mapping);
-		context->xstorm_st_context.statistics_data = (fp->cl_id |
-				XSTORM_ETH_ST_CONTEXT_STATISTICS_ENABLE);
-	}
-}
-
-static void bnx2x_init_ind_table(struct bnx2x *bp)
-{
-	int func = BP_FUNC(bp);
-	int i;
-
-	if (bp->multi_mode == ETH_RSS_MODE_DISABLED)
-		return;
-
-	DP(NETIF_MSG_IFUP,
-	   "Initializing indirection table  multi_mode %d\n", bp->multi_mode);
-	for (i = 0; i < TSTORM_INDIRECTION_TABLE_SIZE; i++)
-		REG_WR8(bp, BAR_TSTRORM_INTMEM +
-			TSTORM_INDIRECTION_TABLE_OFFSET(func) + i,
-			bp->fp->cl_id + (i % bp->num_queues));
-}
-
-static void bnx2x_set_client_config(struct bnx2x *bp)
-{
-	struct tstorm_eth_client_config tstorm_client = {0};
-	int port = BP_PORT(bp);
-	int i;
-
-	tstorm_client.mtu = bp->dev->mtu;
-	tstorm_client.config_flags =
-				(TSTORM_ETH_CLIENT_CONFIG_STATSITICS_ENABLE |
-				 TSTORM_ETH_CLIENT_CONFIG_E1HOV_REM_ENABLE);
-#ifdef BCM_VLAN
-	if (bp->rx_mode && bp->vlgrp && (bp->flags & HW_VLAN_RX_FLAG)) {
-		tstorm_client.config_flags |=
-				TSTORM_ETH_CLIENT_CONFIG_VLAN_REM_ENABLE;
-		DP(NETIF_MSG_IFUP, "vlan removal enabled\n");
-	}
-#endif
-
-	for_each_queue(bp, i) {
-		tstorm_client.statistics_counter_id = bp->fp[i].cl_id;
-
-		REG_WR(bp, BAR_TSTRORM_INTMEM +
-		       TSTORM_CLIENT_CONFIG_OFFSET(port, bp->fp[i].cl_id),
-		       ((u32 *)&tstorm_client)[0]);
-		REG_WR(bp, BAR_TSTRORM_INTMEM +
-		       TSTORM_CLIENT_CONFIG_OFFSET(port, bp->fp[i].cl_id) + 4,
-		       ((u32 *)&tstorm_client)[1]);
-	}
-
-	DP(BNX2X_MSG_OFF, "tstorm_client: 0x%08x 0x%08x\n",
-	   ((u32 *)&tstorm_client)[0], ((u32 *)&tstorm_client)[1]);
-}
-
-static void bnx2x_set_storm_rx_mode(struct bnx2x *bp)
-{
-	struct tstorm_eth_mac_filter_config tstorm_mac_filter = {0};
-	int mode = bp->rx_mode;
-	int mask = bp->rx_mode_cl_mask;
-	int func = BP_FUNC(bp);
-	int port = BP_PORT(bp);
-	int i;
-	/* All but management unicast packets should pass to the host as well */
-	u32 llh_mask =
-		NIG_LLH0_BRB1_DRV_MASK_REG_LLH0_BRB1_DRV_MASK_BRCST |
-		NIG_LLH0_BRB1_DRV_MASK_REG_LLH0_BRB1_DRV_MASK_MLCST |
-		NIG_LLH0_BRB1_DRV_MASK_REG_LLH0_BRB1_DRV_MASK_VLAN |
-		NIG_LLH0_BRB1_DRV_MASK_REG_LLH0_BRB1_DRV_MASK_NO_VLAN;
-
-	DP(NETIF_MSG_IFUP, "rx mode %d  mask 0x%x\n", mode, mask);
-
-	switch (mode) {
-	case BNX2X_RX_MODE_NONE: /* no Rx */
-		tstorm_mac_filter.ucast_drop_all = mask;
-		tstorm_mac_filter.mcast_drop_all = mask;
-		tstorm_mac_filter.bcast_drop_all = mask;
-		break;
-
-	case BNX2X_RX_MODE_NORMAL:
-		tstorm_mac_filter.bcast_accept_all = mask;
-		break;
-
-	case BNX2X_RX_MODE_ALLMULTI:
-		tstorm_mac_filter.mcast_accept_all = mask;
-		tstorm_mac_filter.bcast_accept_all = mask;
-		break;
-
-	case BNX2X_RX_MODE_PROMISC:
-		tstorm_mac_filter.ucast_accept_all = mask;
-		tstorm_mac_filter.mcast_accept_all = mask;
-		tstorm_mac_filter.bcast_accept_all = mask;
-		/* pass management unicast packets as well */
-		llh_mask |= NIG_LLH0_BRB1_DRV_MASK_REG_LLH0_BRB1_DRV_MASK_UNCST;
-		break;
-
-	default:
-		BNX2X_ERR("BAD rx mode (%d)\n", mode);
-		break;
-	}
-
-	REG_WR(bp,
-	       (port ? NIG_REG_LLH1_BRB1_DRV_MASK : NIG_REG_LLH0_BRB1_DRV_MASK),
-	       llh_mask);
-
-	for (i = 0; i < sizeof(struct tstorm_eth_mac_filter_config)/4; i++) {
-		REG_WR(bp, BAR_TSTRORM_INTMEM +
-		       TSTORM_MAC_FILTER_CONFIG_OFFSET(func) + i * 4,
-		       ((u32 *)&tstorm_mac_filter)[i]);
-
-/*		DP(NETIF_MSG_IFUP, "tstorm_mac_filter[%d]: 0x%08x\n", i,
-		   ((u32 *)&tstorm_mac_filter)[i]); */
-	}
-
-	if (mode != BNX2X_RX_MODE_NONE)
-		bnx2x_set_client_config(bp);
-}
-
-static void bnx2x_init_internal_common(struct bnx2x *bp)
-{
-	int i;
-
-	/* Zero this manually as its initialization is
-	   currently missing in the initTool */
-	for (i = 0; i < (USTORM_AGG_DATA_SIZE >> 2); i++)
-		REG_WR(bp, BAR_USTRORM_INTMEM +
-		       USTORM_AGG_DATA_OFFSET + i * 4, 0);
-}
-
-static void bnx2x_init_internal_port(struct bnx2x *bp)
-{
-	int port = BP_PORT(bp);
-
-	REG_WR(bp,
-	       BAR_CSTRORM_INTMEM + CSTORM_HC_BTR_U_OFFSET(port), BNX2X_BTR);
-	REG_WR(bp,
-	       BAR_CSTRORM_INTMEM + CSTORM_HC_BTR_C_OFFSET(port), BNX2X_BTR);
-	REG_WR(bp, BAR_TSTRORM_INTMEM + TSTORM_HC_BTR_OFFSET(port), BNX2X_BTR);
-	REG_WR(bp, BAR_XSTRORM_INTMEM + XSTORM_HC_BTR_OFFSET(port), BNX2X_BTR);
-}
-
-static void bnx2x_init_internal_func(struct bnx2x *bp)
-{
-	struct tstorm_eth_function_common_config tstorm_config = {0};
-	struct stats_indication_flags stats_flags = {0};
-	int port = BP_PORT(bp);
-	int func = BP_FUNC(bp);
-	int i, j;
-	u32 offset;
-	u16 max_agg_size;
-
-	if (is_multi(bp)) {
-		tstorm_config.config_flags = MULTI_FLAGS(bp);
-		tstorm_config.rss_result_mask = MULTI_MASK;
-	}
-
-	/* Enable TPA if needed */
-	if (bp->flags & TPA_ENABLE_FLAG)
-		tstorm_config.config_flags |=
-			TSTORM_ETH_FUNCTION_COMMON_CONFIG_ENABLE_TPA;
-
-	if (IS_E1HMF(bp))
-		tstorm_config.config_flags |=
-				TSTORM_ETH_FUNCTION_COMMON_CONFIG_E1HOV_IN_CAM;
-
-	tstorm_config.leading_client_id = BP_L_ID(bp);
-
-	REG_WR(bp, BAR_TSTRORM_INTMEM +
-	       TSTORM_FUNCTION_COMMON_CONFIG_OFFSET(func),
-	       (*(u32 *)&tstorm_config));
-
-	bp->rx_mode = BNX2X_RX_MODE_NONE; /* no rx until link is up */
-	bp->rx_mode_cl_mask = (1 << BP_L_ID(bp));
-	bnx2x_set_storm_rx_mode(bp);
-
-	for_each_queue(bp, i) {
-		u8 cl_id = bp->fp[i].cl_id;
-
-		/* reset xstorm per client statistics */
-		offset = BAR_XSTRORM_INTMEM +
-			 XSTORM_PER_COUNTER_ID_STATS_OFFSET(port, cl_id);
-		for (j = 0;
-		     j < sizeof(struct xstorm_per_client_stats) / 4; j++)
-			REG_WR(bp, offset + j*4, 0);
-
-		/* reset tstorm per client statistics */
-		offset = BAR_TSTRORM_INTMEM +
-			 TSTORM_PER_COUNTER_ID_STATS_OFFSET(port, cl_id);
-		for (j = 0;
-		     j < sizeof(struct tstorm_per_client_stats) / 4; j++)
-			REG_WR(bp, offset + j*4, 0);
-
-		/* reset ustorm per client statistics */
-		offset = BAR_USTRORM_INTMEM +
-			 USTORM_PER_COUNTER_ID_STATS_OFFSET(port, cl_id);
-		for (j = 0;
-		     j < sizeof(struct ustorm_per_client_stats) / 4; j++)
-			REG_WR(bp, offset + j*4, 0);
-	}
-
-	/* Init statistics related context */
-	stats_flags.collect_eth = 1;
-
-	REG_WR(bp, BAR_XSTRORM_INTMEM + XSTORM_STATS_FLAGS_OFFSET(func),
-	       ((u32 *)&stats_flags)[0]);
-	REG_WR(bp, BAR_XSTRORM_INTMEM + XSTORM_STATS_FLAGS_OFFSET(func) + 4,
-	       ((u32 *)&stats_flags)[1]);
-
-	REG_WR(bp, BAR_TSTRORM_INTMEM + TSTORM_STATS_FLAGS_OFFSET(func),
-	       ((u32 *)&stats_flags)[0]);
-	REG_WR(bp, BAR_TSTRORM_INTMEM + TSTORM_STATS_FLAGS_OFFSET(func) + 4,
-	       ((u32 *)&stats_flags)[1]);
-
-	REG_WR(bp, BAR_USTRORM_INTMEM + USTORM_STATS_FLAGS_OFFSET(func),
-	       ((u32 *)&stats_flags)[0]);
-	REG_WR(bp, BAR_USTRORM_INTMEM + USTORM_STATS_FLAGS_OFFSET(func) + 4,
-	       ((u32 *)&stats_flags)[1]);
-
-	REG_WR(bp, BAR_CSTRORM_INTMEM + CSTORM_STATS_FLAGS_OFFSET(func),
-	       ((u32 *)&stats_flags)[0]);
-	REG_WR(bp, BAR_CSTRORM_INTMEM + CSTORM_STATS_FLAGS_OFFSET(func) + 4,
-	       ((u32 *)&stats_flags)[1]);
-
-	REG_WR(bp, BAR_XSTRORM_INTMEM +
-	       XSTORM_ETH_STATS_QUERY_ADDR_OFFSET(func),
-	       U64_LO(bnx2x_sp_mapping(bp, fw_stats)));
-	REG_WR(bp, BAR_XSTRORM_INTMEM +
-	       XSTORM_ETH_STATS_QUERY_ADDR_OFFSET(func) + 4,
-	       U64_HI(bnx2x_sp_mapping(bp, fw_stats)));
-
-	REG_WR(bp, BAR_TSTRORM_INTMEM +
-	       TSTORM_ETH_STATS_QUERY_ADDR_OFFSET(func),
-	       U64_LO(bnx2x_sp_mapping(bp, fw_stats)));
-	REG_WR(bp, BAR_TSTRORM_INTMEM +
-	       TSTORM_ETH_STATS_QUERY_ADDR_OFFSET(func) + 4,
-	       U64_HI(bnx2x_sp_mapping(bp, fw_stats)));
-
-	REG_WR(bp, BAR_USTRORM_INTMEM +
-	       USTORM_ETH_STATS_QUERY_ADDR_OFFSET(func),
-	       U64_LO(bnx2x_sp_mapping(bp, fw_stats)));
-	REG_WR(bp, BAR_USTRORM_INTMEM +
-	       USTORM_ETH_STATS_QUERY_ADDR_OFFSET(func) + 4,
-	       U64_HI(bnx2x_sp_mapping(bp, fw_stats)));
-
-	if (CHIP_IS_E1H(bp)) {
-		REG_WR8(bp, BAR_XSTRORM_INTMEM + XSTORM_FUNCTION_MODE_OFFSET,
-			IS_E1HMF(bp));
-		REG_WR8(bp, BAR_TSTRORM_INTMEM + TSTORM_FUNCTION_MODE_OFFSET,
-			IS_E1HMF(bp));
-		REG_WR8(bp, BAR_CSTRORM_INTMEM + CSTORM_FUNCTION_MODE_OFFSET,
-			IS_E1HMF(bp));
-		REG_WR8(bp, BAR_USTRORM_INTMEM + USTORM_FUNCTION_MODE_OFFSET,
-			IS_E1HMF(bp));
-
-		REG_WR16(bp, BAR_XSTRORM_INTMEM + XSTORM_E1HOV_OFFSET(func),
-			 bp->e1hov);
-	}
-
-	/* Init CQ ring mapping and aggregation size, the FW limit is 8 frags */
-	max_agg_size =
-		min((u32)(min((u32)8, (u32)MAX_SKB_FRAGS) *
-			  SGE_PAGE_SIZE * PAGES_PER_SGE),
-		    (u32)0xffff);
-	for_each_queue(bp, i) {
-		struct bnx2x_fastpath *fp = &bp->fp[i];
-
-		REG_WR(bp, BAR_USTRORM_INTMEM +
-		       USTORM_CQE_PAGE_BASE_OFFSET(port, fp->cl_id),
-		       U64_LO(fp->rx_comp_mapping));
-		REG_WR(bp, BAR_USTRORM_INTMEM +
-		       USTORM_CQE_PAGE_BASE_OFFSET(port, fp->cl_id) + 4,
-		       U64_HI(fp->rx_comp_mapping));
-
-		/* Next page */
-		REG_WR(bp, BAR_USTRORM_INTMEM +
-		       USTORM_CQE_PAGE_NEXT_OFFSET(port, fp->cl_id),
-		       U64_LO(fp->rx_comp_mapping + BCM_PAGE_SIZE));
-		REG_WR(bp, BAR_USTRORM_INTMEM +
-		       USTORM_CQE_PAGE_NEXT_OFFSET(port, fp->cl_id) + 4,
-		       U64_HI(fp->rx_comp_mapping + BCM_PAGE_SIZE));
-
-		REG_WR16(bp, BAR_USTRORM_INTMEM +
-			 USTORM_MAX_AGG_SIZE_OFFSET(port, fp->cl_id),
-			 max_agg_size);
-	}
-
-	/* dropless flow control */
-	if (CHIP_IS_E1H(bp)) {
-		struct ustorm_eth_rx_pause_data_e1h rx_pause = {0};
-
-		rx_pause.bd_thr_low = 250;
-		rx_pause.cqe_thr_low = 250;
-		rx_pause.cos = 1;
-		rx_pause.sge_thr_low = 0;
-		rx_pause.bd_thr_high = 350;
-		rx_pause.cqe_thr_high = 350;
-		rx_pause.sge_thr_high = 0;
-
-		for_each_queue(bp, i) {
-			struct bnx2x_fastpath *fp = &bp->fp[i];
-
-			if (!fp->disable_tpa) {
-				rx_pause.sge_thr_low = 150;
-				rx_pause.sge_thr_high = 250;
-			}
-
-
-			offset = BAR_USTRORM_INTMEM +
-				 USTORM_ETH_RING_PAUSE_DATA_OFFSET(port,
-								   fp->cl_id);
-			for (j = 0;
-			     j < sizeof(struct ustorm_eth_rx_pause_data_e1h)/4;
-			     j++)
-				REG_WR(bp, offset + j*4,
-				       ((u32 *)&rx_pause)[j]);
-		}
-	}
-
-	memset(&(bp->cmng), 0, sizeof(struct cmng_struct_per_port));
-
-	/* Init rate shaping and fairness contexts */
-	if (IS_E1HMF(bp)) {
-		int vn;
-
-		/* During init there is no active link
-		   Until link is up, set link rate to 10Gbps */
-		bp->link_vars.line_speed = SPEED_10000;
-		bnx2x_init_port_minmax(bp);
-
-		if (!BP_NOMCP(bp))
-			bp->mf_config =
-			      SHMEM_RD(bp, mf_cfg.func_mf_config[func].config);
-		bnx2x_calc_vn_weight_sum(bp);
-
-		for (vn = VN_0; vn < E1HVN_MAX; vn++)
-			bnx2x_init_vn_minmax(bp, 2*vn + port);
-
-		/* Enable rate shaping and fairness */
-		bp->cmng.flags.cmng_enables |=
-					CMNG_FLAGS_PER_PORT_RATE_SHAPING_VN;
-
-	} else {
-		/* rate shaping and fairness are disabled */
-		DP(NETIF_MSG_IFUP,
-		   "single function mode  minmax will be disabled\n");
-	}
-
-
-	/* Store it to internal memory */
-	if (bp->port.pmf)
-		for (i = 0; i < sizeof(struct cmng_struct_per_port) / 4; i++)
-			REG_WR(bp, BAR_XSTRORM_INTMEM +
-			       XSTORM_CMNG_PER_PORT_VARS_OFFSET(port) + i * 4,
-			       ((u32 *)(&bp->cmng))[i]);
-}
-
-static void bnx2x_init_internal(struct bnx2x *bp, u32 load_code)
-{
-	switch (load_code) {
-	case FW_MSG_CODE_DRV_LOAD_COMMON:
-		bnx2x_init_internal_common(bp);
-		/* no break */
-
-	case FW_MSG_CODE_DRV_LOAD_PORT:
-		bnx2x_init_internal_port(bp);
-		/* no break */
-
-	case FW_MSG_CODE_DRV_LOAD_FUNCTION:
-		bnx2x_init_internal_func(bp);
-		break;
-
-	default:
-		BNX2X_ERR("Unknown load_code (0x%x) from MCP\n", load_code);
-		break;
-	}
-}
-
-static void bnx2x_nic_init(struct bnx2x *bp, u32 load_code)
-{
-	int i;
-
-	for_each_queue(bp, i) {
-		struct bnx2x_fastpath *fp = &bp->fp[i];
-
-		fp->bp = bp;
-		fp->state = BNX2X_FP_STATE_CLOSED;
-		fp->index = i;
-		fp->cl_id = BP_L_ID(bp) + i;
-#ifdef BCM_CNIC
-		fp->sb_id = fp->cl_id + 1;
-#else
-		fp->sb_id = fp->cl_id;
-#endif
-		DP(NETIF_MSG_IFUP,
-		   "queue[%d]:  bnx2x_init_sb(%p,%p)  cl_id %d  sb %d\n",
-		   i, bp, fp->status_blk, fp->cl_id, fp->sb_id);
-		bnx2x_init_sb(bp, fp->status_blk, fp->status_blk_mapping,
-			      fp->sb_id);
-		bnx2x_update_fpsb_idx(fp);
-	}
-
-	/* ensure status block indices were read */
-	rmb();
-
-
-	bnx2x_init_def_sb(bp, bp->def_status_blk, bp->def_status_blk_mapping,
-			  DEF_SB_ID);
-	bnx2x_update_dsb_idx(bp);
-	bnx2x_update_coalesce(bp);
-	bnx2x_init_rx_rings(bp);
-	bnx2x_init_tx_ring(bp);
-	bnx2x_init_sp_ring(bp);
-	bnx2x_init_context(bp);
-	bnx2x_init_internal(bp, load_code);
-	bnx2x_init_ind_table(bp);
-	bnx2x_stats_init(bp);
-
-	/* At this point, we are ready for interrupts */
-	atomic_set(&bp->intr_sem, 0);
-
-	/* flush all before enabling interrupts */
-	mb();
-	mmiowb();
-
-	bnx2x_int_enable(bp);
-
-	/* Check for SPIO5 */
-	bnx2x_attn_int_deasserted0(bp,
-		REG_RD(bp, MISC_REG_AEU_AFTER_INVERT_1_FUNC_0 + BP_PORT(bp)*4) &
-				   AEU_INPUTS_ATTN_BITS_SPIO5);
-}
-
-/* end of nic init */
-
-/*
- * gzip service functions
- */
-
-static int bnx2x_gunzip_init(struct bnx2x *bp)
-{
-	bp->gunzip_buf = pci_alloc_consistent(bp->pdev, FW_BUF_SIZE,
-					      &bp->gunzip_mapping);
-	if (bp->gunzip_buf  == NULL)
-		goto gunzip_nomem1;
-
-	bp->strm = kmalloc(sizeof(*bp->strm), GFP_KERNEL);
-	if (bp->strm  == NULL)
-		goto gunzip_nomem2;
-
-	bp->strm->workspace = kmalloc(zlib_inflate_workspacesize(),
-				      GFP_KERNEL);
-	if (bp->strm->workspace == NULL)
-		goto gunzip_nomem3;
-
-	return 0;
-
-gunzip_nomem3:
-	kfree(bp->strm);
-	bp->strm = NULL;
-
-gunzip_nomem2:
-	pci_free_consistent(bp->pdev, FW_BUF_SIZE, bp->gunzip_buf,
-			    bp->gunzip_mapping);
-	bp->gunzip_buf = NULL;
-
-gunzip_nomem1:
-	netdev_err(bp->dev, "Cannot allocate firmware buffer for un-compression\n");
-	return -ENOMEM;
-}
-
-static void bnx2x_gunzip_end(struct bnx2x *bp)
-{
-	kfree(bp->strm->workspace);
-
-	kfree(bp->strm);
-	bp->strm = NULL;
-
-	if (bp->gunzip_buf) {
-		pci_free_consistent(bp->pdev, FW_BUF_SIZE, bp->gunzip_buf,
-				    bp->gunzip_mapping);
-		bp->gunzip_buf = NULL;
-	}
-}
-
-static int bnx2x_gunzip(struct bnx2x *bp, const u8 *zbuf, int len)
-{
-	int n, rc;
-
-	/* check gzip header */
-	if ((zbuf[0] != 0x1f) || (zbuf[1] != 0x8b) || (zbuf[2] != Z_DEFLATED)) {
-		BNX2X_ERR("Bad gzip header\n");
-		return -EINVAL;
-	}
-
-	n = 10;
-
-#define FNAME				0x8
-
-	if (zbuf[3] & FNAME)
-		while ((zbuf[n++] != 0) && (n < len));
-
-	bp->strm->next_in = (typeof(bp->strm->next_in))zbuf + n;
-	bp->strm->avail_in = len - n;
-	bp->strm->next_out = bp->gunzip_buf;
-	bp->strm->avail_out = FW_BUF_SIZE;
-
-	rc = zlib_inflateInit2(bp->strm, -MAX_WBITS);
-	if (rc != Z_OK)
-		return rc;
-
-	rc = zlib_inflate(bp->strm, Z_FINISH);
-	if ((rc != Z_OK) && (rc != Z_STREAM_END))
-		netdev_err(bp->dev, "Firmware decompression error: %s\n",
-			   bp->strm->msg);
-
-	bp->gunzip_outlen = (FW_BUF_SIZE - bp->strm->avail_out);
-	if (bp->gunzip_outlen & 0x3)
-		netdev_err(bp->dev, "Firmware decompression error: gunzip_outlen (%d) not aligned\n",
-			   bp->gunzip_outlen);
-	bp->gunzip_outlen >>= 2;
-
-	zlib_inflateEnd(bp->strm);
-
-	if (rc == Z_STREAM_END)
-		return 0;
-
-	return rc;
-}
-
-/* nic load/unload */
-
-/*
- * General service functions
- */
-
-/* send a NIG loopback debug packet */
-static void bnx2x_lb_pckt(struct bnx2x *bp)
-{
-	u32 wb_write[3];
-
-	/* Ethernet source and destination addresses */
-	wb_write[0] = 0x55555555;
-	wb_write[1] = 0x55555555;
-	wb_write[2] = 0x20;		/* SOP */
-	REG_WR_DMAE(bp, NIG_REG_DEBUG_PACKET_LB, wb_write, 3);
-
-	/* NON-IP protocol */
-	wb_write[0] = 0x09000000;
-	wb_write[1] = 0x55555555;
-	wb_write[2] = 0x10;		/* EOP, eop_bvalid = 0 */
-	REG_WR_DMAE(bp, NIG_REG_DEBUG_PACKET_LB, wb_write, 3);
-}
-
-/* some of the internal memories
- * are not directly readable from the driver
- * to test them we send debug packets
- */
-static int bnx2x_int_mem_test(struct bnx2x *bp)
-{
-	int factor;
-	int count, i;
-	u32 val = 0;
-
-	if (CHIP_REV_IS_FPGA(bp))
-		factor = 120;
-	else if (CHIP_REV_IS_EMUL(bp))
-		factor = 200;
-	else
-		factor = 1;
-
-	DP(NETIF_MSG_HW, "start part1\n");
-
-	/* Disable inputs of parser neighbor blocks */
-	REG_WR(bp, TSDM_REG_ENABLE_IN1, 0x0);
-	REG_WR(bp, TCM_REG_PRS_IFEN, 0x0);
-	REG_WR(bp, CFC_REG_DEBUG0, 0x1);
-	REG_WR(bp, NIG_REG_PRS_REQ_IN_EN, 0x0);
-
-	/*  Write 0 to parser credits for CFC search request */
-	REG_WR(bp, PRS_REG_CFC_SEARCH_INITIAL_CREDIT, 0x0);
-
-	/* send Ethernet packet */
-	bnx2x_lb_pckt(bp);
-
-	/* TODO do i reset NIG statistic? */
-	/* Wait until NIG register shows 1 packet of size 0x10 */
-	count = 1000 * factor;
-	while (count) {
-
-		bnx2x_read_dmae(bp, NIG_REG_STAT2_BRB_OCTET, 2);
-		val = *bnx2x_sp(bp, wb_data[0]);
-		if (val == 0x10)
-			break;
-
-		msleep(10);
-		count--;
-	}
-	if (val != 0x10) {
-		BNX2X_ERR("NIG timeout  val = 0x%x\n", val);
-		return -1;
-	}
-
-	/* Wait until PRS register shows 1 packet */
-	count = 1000 * factor;
-	while (count) {
-		val = REG_RD(bp, PRS_REG_NUM_OF_PACKETS);
-		if (val == 1)
-			break;
-
-		msleep(10);
-		count--;
-	}
-	if (val != 0x1) {
-		BNX2X_ERR("PRS timeout val = 0x%x\n", val);
-		return -2;
-	}
-
-	/* Reset and init BRB, PRS */
-	REG_WR(bp, GRCBASE_MISC + MISC_REGISTERS_RESET_REG_1_CLEAR, 0x03);
-	msleep(50);
-	REG_WR(bp, GRCBASE_MISC + MISC_REGISTERS_RESET_REG_1_SET, 0x03);
-	msleep(50);
-	bnx2x_init_block(bp, BRB1_BLOCK, COMMON_STAGE);
-	bnx2x_init_block(bp, PRS_BLOCK, COMMON_STAGE);
-
-	DP(NETIF_MSG_HW, "part2\n");
-
-	/* Disable inputs of parser neighbor blocks */
-	REG_WR(bp, TSDM_REG_ENABLE_IN1, 0x0);
-	REG_WR(bp, TCM_REG_PRS_IFEN, 0x0);
-	REG_WR(bp, CFC_REG_DEBUG0, 0x1);
-	REG_WR(bp, NIG_REG_PRS_REQ_IN_EN, 0x0);
-
-	/* Write 0 to parser credits for CFC search request */
-	REG_WR(bp, PRS_REG_CFC_SEARCH_INITIAL_CREDIT, 0x0);
-
-	/* send 10 Ethernet packets */
-	for (i = 0; i < 10; i++)
-		bnx2x_lb_pckt(bp);
-
-	/* Wait until NIG register shows 10 + 1
-	   packets of size 11*0x10 = 0xb0 */
-	count = 1000 * factor;
-	while (count) {
-
-		bnx2x_read_dmae(bp, NIG_REG_STAT2_BRB_OCTET, 2);
-		val = *bnx2x_sp(bp, wb_data[0]);
-		if (val == 0xb0)
-			break;
-
-		msleep(10);
-		count--;
-	}
-	if (val != 0xb0) {
-		BNX2X_ERR("NIG timeout  val = 0x%x\n", val);
-		return -3;
-	}
-
-	/* Wait until PRS register shows 2 packets */
-	val = REG_RD(bp, PRS_REG_NUM_OF_PACKETS);
-	if (val != 2)
-		BNX2X_ERR("PRS timeout  val = 0x%x\n", val);
-
-	/* Write 1 to parser credits for CFC search request */
-	REG_WR(bp, PRS_REG_CFC_SEARCH_INITIAL_CREDIT, 0x1);
-
-	/* Wait until PRS register shows 3 packets */
-	msleep(10 * factor);
-	/* Wait until NIG register shows 1 packet of size 0x10 */
-	val = REG_RD(bp, PRS_REG_NUM_OF_PACKETS);
-	if (val != 3)
-		BNX2X_ERR("PRS timeout  val = 0x%x\n", val);
-
-	/* clear NIG EOP FIFO */
-	for (i = 0; i < 11; i++)
-		REG_RD(bp, NIG_REG_INGRESS_EOP_LB_FIFO);
-	val = REG_RD(bp, NIG_REG_INGRESS_EOP_LB_EMPTY);
-	if (val != 1) {
-		BNX2X_ERR("clear of NIG failed\n");
-		return -4;
-	}
-
-	/* Reset and init BRB, PRS, NIG */
-	REG_WR(bp, GRCBASE_MISC + MISC_REGISTERS_RESET_REG_1_CLEAR, 0x03);
-	msleep(50);
-	REG_WR(bp, GRCBASE_MISC + MISC_REGISTERS_RESET_REG_1_SET, 0x03);
-	msleep(50);
-	bnx2x_init_block(bp, BRB1_BLOCK, COMMON_STAGE);
-	bnx2x_init_block(bp, PRS_BLOCK, COMMON_STAGE);
-#ifndef BCM_CNIC
-	/* set NIC mode */
-	REG_WR(bp, PRS_REG_NIC_MODE, 1);
-#endif
-
-	/* Enable inputs of parser neighbor blocks */
-	REG_WR(bp, TSDM_REG_ENABLE_IN1, 0x7fffffff);
-	REG_WR(bp, TCM_REG_PRS_IFEN, 0x1);
-	REG_WR(bp, CFC_REG_DEBUG0, 0x0);
-	REG_WR(bp, NIG_REG_PRS_REQ_IN_EN, 0x1);
-
-	DP(NETIF_MSG_HW, "done\n");
-
-	return 0; /* OK */
-}
-
-static void enable_blocks_attention(struct bnx2x *bp)
-{
-	REG_WR(bp, PXP_REG_PXP_INT_MASK_0, 0);
-	REG_WR(bp, PXP_REG_PXP_INT_MASK_1, 0);
-	REG_WR(bp, DORQ_REG_DORQ_INT_MASK, 0);
-	REG_WR(bp, CFC_REG_CFC_INT_MASK, 0);
-	REG_WR(bp, QM_REG_QM_INT_MASK, 0);
-	REG_WR(bp, TM_REG_TM_INT_MASK, 0);
-	REG_WR(bp, XSDM_REG_XSDM_INT_MASK_0, 0);
-	REG_WR(bp, XSDM_REG_XSDM_INT_MASK_1, 0);
-	REG_WR(bp, XCM_REG_XCM_INT_MASK, 0);
-/*	REG_WR(bp, XSEM_REG_XSEM_INT_MASK_0, 0); */
-/*	REG_WR(bp, XSEM_REG_XSEM_INT_MASK_1, 0); */
-	REG_WR(bp, USDM_REG_USDM_INT_MASK_0, 0);
-	REG_WR(bp, USDM_REG_USDM_INT_MASK_1, 0);
-	REG_WR(bp, UCM_REG_UCM_INT_MASK, 0);
-/*	REG_WR(bp, USEM_REG_USEM_INT_MASK_0, 0); */
-/*	REG_WR(bp, USEM_REG_USEM_INT_MASK_1, 0); */
-	REG_WR(bp, GRCBASE_UPB + PB_REG_PB_INT_MASK, 0);
-	REG_WR(bp, CSDM_REG_CSDM_INT_MASK_0, 0);
-	REG_WR(bp, CSDM_REG_CSDM_INT_MASK_1, 0);
-	REG_WR(bp, CCM_REG_CCM_INT_MASK, 0);
-/*	REG_WR(bp, CSEM_REG_CSEM_INT_MASK_0, 0); */
-/*	REG_WR(bp, CSEM_REG_CSEM_INT_MASK_1, 0); */
-	if (CHIP_REV_IS_FPGA(bp))
-		REG_WR(bp, PXP2_REG_PXP2_INT_MASK_0, 0x580000);
-	else
-		REG_WR(bp, PXP2_REG_PXP2_INT_MASK_0, 0x480000);
-	REG_WR(bp, TSDM_REG_TSDM_INT_MASK_0, 0);
-	REG_WR(bp, TSDM_REG_TSDM_INT_MASK_1, 0);
-	REG_WR(bp, TCM_REG_TCM_INT_MASK, 0);
-/*	REG_WR(bp, TSEM_REG_TSEM_INT_MASK_0, 0); */
-/*	REG_WR(bp, TSEM_REG_TSEM_INT_MASK_1, 0); */
-	REG_WR(bp, CDU_REG_CDU_INT_MASK, 0);
-	REG_WR(bp, DMAE_REG_DMAE_INT_MASK, 0);
-/*	REG_WR(bp, MISC_REG_MISC_INT_MASK, 0); */
-	REG_WR(bp, PBF_REG_PBF_INT_MASK, 0X18);		/* bit 3,4 masked */
-}
-
-
-static void bnx2x_reset_common(struct bnx2x *bp)
-{
-	/* reset_common */
-	REG_WR(bp, GRCBASE_MISC + MISC_REGISTERS_RESET_REG_1_CLEAR,
-	       0xd3ffff7f);
-	REG_WR(bp, GRCBASE_MISC + MISC_REGISTERS_RESET_REG_2_CLEAR, 0x1403);
-}
-
-static void bnx2x_init_pxp(struct bnx2x *bp)
-{
-	u16 devctl;
-	int r_order, w_order;
-
-	pci_read_config_word(bp->pdev,
-			     bp->pcie_cap + PCI_EXP_DEVCTL, &devctl);
-	DP(NETIF_MSG_HW, "read 0x%x from devctl\n", devctl);
-	w_order = ((devctl & PCI_EXP_DEVCTL_PAYLOAD) >> 5);
-	if (bp->mrrs == -1)
-		r_order = ((devctl & PCI_EXP_DEVCTL_READRQ) >> 12);
-	else {
-		DP(NETIF_MSG_HW, "force read order to %d\n", bp->mrrs);
-		r_order = bp->mrrs;
-	}
-
-	bnx2x_init_pxp_arb(bp, r_order, w_order);
-}
-
-static void bnx2x_setup_fan_failure_detection(struct bnx2x *bp)
-{
-	u32 val;
-	u8 port;
-	u8 is_required = 0;
-
-	val = SHMEM_RD(bp, dev_info.shared_hw_config.config2) &
-	      SHARED_HW_CFG_FAN_FAILURE_MASK;
-
-	if (val == SHARED_HW_CFG_FAN_FAILURE_ENABLED)
-		is_required = 1;
-
-	/*
-	 * The fan failure mechanism is usually related to the PHY type since
-	 * the power consumption of the board is affected by the PHY. Currently,
-	 * fan is required for most designs with SFX7101, BCM8727 and BCM8481.
-	 */
-	else if (val == SHARED_HW_CFG_FAN_FAILURE_PHY_TYPE)
-		for (port = PORT_0; port < PORT_MAX; port++) {
-			u32 phy_type =
-				SHMEM_RD(bp, dev_info.port_hw_config[port].
-					 external_phy_config) &
-				PORT_HW_CFG_XGXS_EXT_PHY_TYPE_MASK;
-			is_required |=
-				((phy_type ==
-				  PORT_HW_CFG_XGXS_EXT_PHY_TYPE_SFX7101) ||
-				 (phy_type ==
-				  PORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM8727) ||
-				 (phy_type ==
-				  PORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM8481));
-		}
-
-	DP(NETIF_MSG_HW, "fan detection setting: %d\n", is_required);
-
-	if (is_required == 0)
-		return;
-
-	/* Fan failure is indicated by SPIO 5 */
-	bnx2x_set_spio(bp, MISC_REGISTERS_SPIO_5,
-		       MISC_REGISTERS_SPIO_INPUT_HI_Z);
-
-	/* set to active low mode */
-	val = REG_RD(bp, MISC_REG_SPIO_INT);
-	val |= ((1 << MISC_REGISTERS_SPIO_5) <<
-				MISC_REGISTERS_SPIO_INT_OLD_SET_POS);
-	REG_WR(bp, MISC_REG_SPIO_INT, val);
-
-	/* enable interrupt to signal the IGU */
-	val = REG_RD(bp, MISC_REG_SPIO_EVENT_EN);
-	val |= (1 << MISC_REGISTERS_SPIO_5);
-	REG_WR(bp, MISC_REG_SPIO_EVENT_EN, val);
-}
-
-static int bnx2x_init_common(struct bnx2x *bp)
-{
-	u32 val, i;
-#ifdef BCM_CNIC
-	u32 wb_write[2];
-#endif
-
-	DP(BNX2X_MSG_MCP, "starting common init  func %d\n", BP_FUNC(bp));
-
-	bnx2x_reset_common(bp);
-	REG_WR(bp, GRCBASE_MISC + MISC_REGISTERS_RESET_REG_1_SET, 0xffffffff);
-	REG_WR(bp, GRCBASE_MISC + MISC_REGISTERS_RESET_REG_2_SET, 0xfffc);
-
-	bnx2x_init_block(bp, MISC_BLOCK, COMMON_STAGE);
-	if (CHIP_IS_E1H(bp))
-		REG_WR(bp, MISC_REG_E1HMF_MODE, IS_E1HMF(bp));
-
-	REG_WR(bp, MISC_REG_LCPLL_CTRL_REG_2, 0x100);
-	msleep(30);
-	REG_WR(bp, MISC_REG_LCPLL_CTRL_REG_2, 0x0);
-
-	bnx2x_init_block(bp, PXP_BLOCK, COMMON_STAGE);
-	if (CHIP_IS_E1(bp)) {
-		/* enable HW interrupt from PXP on USDM overflow
-		   bit 16 on INT_MASK_0 */
-		REG_WR(bp, PXP_REG_PXP_INT_MASK_0, 0);
-	}
-
-	bnx2x_init_block(bp, PXP2_BLOCK, COMMON_STAGE);
-	bnx2x_init_pxp(bp);
-
-#ifdef __BIG_ENDIAN
-	REG_WR(bp, PXP2_REG_RQ_QM_ENDIAN_M, 1);
-	REG_WR(bp, PXP2_REG_RQ_TM_ENDIAN_M, 1);
-	REG_WR(bp, PXP2_REG_RQ_SRC_ENDIAN_M, 1);
-	REG_WR(bp, PXP2_REG_RQ_CDU_ENDIAN_M, 1);
-	REG_WR(bp, PXP2_REG_RQ_DBG_ENDIAN_M, 1);
-	/* make sure this value is 0 */
-	REG_WR(bp, PXP2_REG_RQ_HC_ENDIAN_M, 0);
-
-/*	REG_WR(bp, PXP2_REG_RD_PBF_SWAP_MODE, 1); */
-	REG_WR(bp, PXP2_REG_RD_QM_SWAP_MODE, 1);
-	REG_WR(bp, PXP2_REG_RD_TM_SWAP_MODE, 1);
-	REG_WR(bp, PXP2_REG_RD_SRC_SWAP_MODE, 1);
-	REG_WR(bp, PXP2_REG_RD_CDURD_SWAP_MODE, 1);
-#endif
-
-	REG_WR(bp, PXP2_REG_RQ_CDU_P_SIZE, 2);
-#ifdef BCM_CNIC
-	REG_WR(bp, PXP2_REG_RQ_TM_P_SIZE, 5);
-	REG_WR(bp, PXP2_REG_RQ_QM_P_SIZE, 5);
-	REG_WR(bp, PXP2_REG_RQ_SRC_P_SIZE, 5);
-#endif
-
-	if (CHIP_REV_IS_FPGA(bp) && CHIP_IS_E1H(bp))
-		REG_WR(bp, PXP2_REG_PGL_TAGS_LIMIT, 0x1);
-
-	/* let the HW do it's magic ... */
-	msleep(100);
-	/* finish PXP init */
-	val = REG_RD(bp, PXP2_REG_RQ_CFG_DONE);
-	if (val != 1) {
-		BNX2X_ERR("PXP2 CFG failed\n");
-		return -EBUSY;
-	}
-	val = REG_RD(bp, PXP2_REG_RD_INIT_DONE);
-	if (val != 1) {
-		BNX2X_ERR("PXP2 RD_INIT failed\n");
-		return -EBUSY;
-	}
-
-	REG_WR(bp, PXP2_REG_RQ_DISABLE_INPUTS, 0);
-	REG_WR(bp, PXP2_REG_RD_DISABLE_INPUTS, 0);
-
-	bnx2x_init_block(bp, DMAE_BLOCK, COMMON_STAGE);
-
-	/* clean the DMAE memory */
-	bp->dmae_ready = 1;
-	bnx2x_init_fill(bp, TSEM_REG_PRAM, 0, 8);
-
-	bnx2x_init_block(bp, TCM_BLOCK, COMMON_STAGE);
-	bnx2x_init_block(bp, UCM_BLOCK, COMMON_STAGE);
-	bnx2x_init_block(bp, CCM_BLOCK, COMMON_STAGE);
-	bnx2x_init_block(bp, XCM_BLOCK, COMMON_STAGE);
-
-	bnx2x_read_dmae(bp, XSEM_REG_PASSIVE_BUFFER, 3);
-	bnx2x_read_dmae(bp, CSEM_REG_PASSIVE_BUFFER, 3);
-	bnx2x_read_dmae(bp, TSEM_REG_PASSIVE_BUFFER, 3);
-	bnx2x_read_dmae(bp, USEM_REG_PASSIVE_BUFFER, 3);
-
-	bnx2x_init_block(bp, QM_BLOCK, COMMON_STAGE);
-
-#ifdef BCM_CNIC
-	wb_write[0] = 0;
-	wb_write[1] = 0;
-	for (i = 0; i < 64; i++) {
-		REG_WR(bp, QM_REG_BASEADDR + i*4, 1024 * 4 * (i%16));
-		bnx2x_init_ind_wr(bp, QM_REG_PTRTBL + i*8, wb_write, 2);
-
-		if (CHIP_IS_E1H(bp)) {
-			REG_WR(bp, QM_REG_BASEADDR_EXT_A + i*4, 1024*4*(i%16));
-			bnx2x_init_ind_wr(bp, QM_REG_PTRTBL_EXT_A + i*8,
-					  wb_write, 2);
-		}
-	}
-#endif
-	/* soft reset pulse */
-	REG_WR(bp, QM_REG_SOFT_RESET, 1);
-	REG_WR(bp, QM_REG_SOFT_RESET, 0);
-
-#ifdef BCM_CNIC
-	bnx2x_init_block(bp, TIMERS_BLOCK, COMMON_STAGE);
-#endif
-
-	bnx2x_init_block(bp, DQ_BLOCK, COMMON_STAGE);
-	REG_WR(bp, DORQ_REG_DPM_CID_OFST, BCM_PAGE_SHIFT);
-	if (!CHIP_REV_IS_SLOW(bp)) {
-		/* enable hw interrupt from doorbell Q */
-		REG_WR(bp, DORQ_REG_DORQ_INT_MASK, 0);
-	}
-
-	bnx2x_init_block(bp, BRB1_BLOCK, COMMON_STAGE);
-	bnx2x_init_block(bp, PRS_BLOCK, COMMON_STAGE);
-	REG_WR(bp, PRS_REG_A_PRSU_20, 0xf);
-#ifndef BCM_CNIC
-	/* set NIC mode */
-	REG_WR(bp, PRS_REG_NIC_MODE, 1);
-#endif
-	if (CHIP_IS_E1H(bp))
-		REG_WR(bp, PRS_REG_E1HOV_MODE, IS_E1HMF(bp));
-
-	bnx2x_init_block(bp, TSDM_BLOCK, COMMON_STAGE);
-	bnx2x_init_block(bp, CSDM_BLOCK, COMMON_STAGE);
-	bnx2x_init_block(bp, USDM_BLOCK, COMMON_STAGE);
-	bnx2x_init_block(bp, XSDM_BLOCK, COMMON_STAGE);
-
-	bnx2x_init_fill(bp, TSEM_REG_FAST_MEMORY, 0, STORM_INTMEM_SIZE(bp));
-	bnx2x_init_fill(bp, USEM_REG_FAST_MEMORY, 0, STORM_INTMEM_SIZE(bp));
-	bnx2x_init_fill(bp, CSEM_REG_FAST_MEMORY, 0, STORM_INTMEM_SIZE(bp));
-	bnx2x_init_fill(bp, XSEM_REG_FAST_MEMORY, 0, STORM_INTMEM_SIZE(bp));
-
-	bnx2x_init_block(bp, TSEM_BLOCK, COMMON_STAGE);
-	bnx2x_init_block(bp, USEM_BLOCK, COMMON_STAGE);
-	bnx2x_init_block(bp, CSEM_BLOCK, COMMON_STAGE);
-	bnx2x_init_block(bp, XSEM_BLOCK, COMMON_STAGE);
-
-	/* sync semi rtc */
-	REG_WR(bp, GRCBASE_MISC + MISC_REGISTERS_RESET_REG_1_CLEAR,
-	       0x80000000);
-	REG_WR(bp, GRCBASE_MISC + MISC_REGISTERS_RESET_REG_1_SET,
-	       0x80000000);
-
-	bnx2x_init_block(bp, UPB_BLOCK, COMMON_STAGE);
-	bnx2x_init_block(bp, XPB_BLOCK, COMMON_STAGE);
-	bnx2x_init_block(bp, PBF_BLOCK, COMMON_STAGE);
-
-	REG_WR(bp, SRC_REG_SOFT_RST, 1);
-	for (i = SRC_REG_KEYRSS0_0; i <= SRC_REG_KEYRSS1_9; i += 4) {
-		REG_WR(bp, i, 0xc0cac01a);
-		/* TODO: replace with something meaningful */
-	}
-	bnx2x_init_block(bp, SRCH_BLOCK, COMMON_STAGE);
-#ifdef BCM_CNIC
-	REG_WR(bp, SRC_REG_KEYSEARCH_0, 0x63285672);
-	REG_WR(bp, SRC_REG_KEYSEARCH_1, 0x24b8f2cc);
-	REG_WR(bp, SRC_REG_KEYSEARCH_2, 0x223aef9b);
-	REG_WR(bp, SRC_REG_KEYSEARCH_3, 0x26001e3a);
-	REG_WR(bp, SRC_REG_KEYSEARCH_4, 0x7ae91116);
-	REG_WR(bp, SRC_REG_KEYSEARCH_5, 0x5ce5230b);
-	REG_WR(bp, SRC_REG_KEYSEARCH_6, 0x298d8adf);
-	REG_WR(bp, SRC_REG_KEYSEARCH_7, 0x6eb0ff09);
-	REG_WR(bp, SRC_REG_KEYSEARCH_8, 0x1830f82f);
-	REG_WR(bp, SRC_REG_KEYSEARCH_9, 0x01e46be7);
-#endif
-	REG_WR(bp, SRC_REG_SOFT_RST, 0);
-
-	if (sizeof(union cdu_context) != 1024)
-		/* we currently assume that a context is 1024 bytes */
-		pr_alert("please adjust the size of cdu_context(%ld)\n",
-			 (long)sizeof(union cdu_context));
-
-	bnx2x_init_block(bp, CDU_BLOCK, COMMON_STAGE);
-	val = (4 << 24) + (0 << 12) + 1024;
-	REG_WR(bp, CDU_REG_CDU_GLOBAL_PARAMS, val);
-
-	bnx2x_init_block(bp, CFC_BLOCK, COMMON_STAGE);
-	REG_WR(bp, CFC_REG_INIT_REG, 0x7FF);
-	/* enable context validation interrupt from CFC */
-	REG_WR(bp, CFC_REG_CFC_INT_MASK, 0);
-
-	/* set the thresholds to prevent CFC/CDU race */
-	REG_WR(bp, CFC_REG_DEBUG0, 0x20020000);
-
-	bnx2x_init_block(bp, HC_BLOCK, COMMON_STAGE);
-	bnx2x_init_block(bp, MISC_AEU_BLOCK, COMMON_STAGE);
-
-	bnx2x_init_block(bp, PXPCS_BLOCK, COMMON_STAGE);
-	/* Reset PCIE errors for debug */
-	REG_WR(bp, 0x2814, 0xffffffff);
-	REG_WR(bp, 0x3820, 0xffffffff);
-
-	bnx2x_init_block(bp, EMAC0_BLOCK, COMMON_STAGE);
-	bnx2x_init_block(bp, EMAC1_BLOCK, COMMON_STAGE);
-	bnx2x_init_block(bp, DBU_BLOCK, COMMON_STAGE);
-	bnx2x_init_block(bp, DBG_BLOCK, COMMON_STAGE);
-
-	bnx2x_init_block(bp, NIG_BLOCK, COMMON_STAGE);
-	if (CHIP_IS_E1H(bp)) {
-		REG_WR(bp, NIG_REG_LLH_MF_MODE, IS_E1HMF(bp));
-		REG_WR(bp, NIG_REG_LLH_E1HOV_MODE, IS_E1HMF(bp));
-	}
-
-	if (CHIP_REV_IS_SLOW(bp))
-		msleep(200);
-
-	/* finish CFC init */
-	val = reg_poll(bp, CFC_REG_LL_INIT_DONE, 1, 100, 10);
-	if (val != 1) {
-		BNX2X_ERR("CFC LL_INIT failed\n");
-		return -EBUSY;
-	}
-	val = reg_poll(bp, CFC_REG_AC_INIT_DONE, 1, 100, 10);
-	if (val != 1) {
-		BNX2X_ERR("CFC AC_INIT failed\n");
-		return -EBUSY;
-	}
-	val = reg_poll(bp, CFC_REG_CAM_INIT_DONE, 1, 100, 10);
-	if (val != 1) {
-		BNX2X_ERR("CFC CAM_INIT failed\n");
-		return -EBUSY;
-	}
-	REG_WR(bp, CFC_REG_DEBUG0, 0);
-
-	/* read NIG statistic
-	   to see if this is our first up since powerup */
-	bnx2x_read_dmae(bp, NIG_REG_STAT2_BRB_OCTET, 2);
-	val = *bnx2x_sp(bp, wb_data[0]);
-
-	/* do internal memory self test */
-	if ((CHIP_IS_E1(bp)) && (val == 0) && bnx2x_int_mem_test(bp)) {
-		BNX2X_ERR("internal mem self test failed\n");
-		return -EBUSY;
-	}
-
-	switch (XGXS_EXT_PHY_TYPE(bp->link_params.ext_phy_config)) {
-	case PORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM8072:
-	case PORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM8073:
-	case PORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM8726:
-	case PORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM8727:
-		bp->port.need_hw_lock = 1;
-		break;
-
-	default:
-		break;
-	}
-
-	bnx2x_setup_fan_failure_detection(bp);
-
-	/* clear PXP2 attentions */
-	REG_RD(bp, PXP2_REG_PXP2_INT_STS_CLR_0);
-
-	enable_blocks_attention(bp);
-
-	if (!BP_NOMCP(bp)) {
-		bnx2x_acquire_phy_lock(bp);
-		bnx2x_common_init_phy(bp, bp->common.shmem_base);
-		bnx2x_release_phy_lock(bp);
-	} else
-		BNX2X_ERR("Bootcode is missing - can not initialize link\n");
-
-	return 0;
-}
-
-static int bnx2x_init_port(struct bnx2x *bp)
-{
-	int port = BP_PORT(bp);
-	int init_stage = port ? PORT1_STAGE : PORT0_STAGE;
-	u32 low, high;
-	u32 val;
-
-	DP(BNX2X_MSG_MCP, "starting port init  port %x\n", port);
-
-	REG_WR(bp, NIG_REG_MASK_INTERRUPT_PORT0 + port*4, 0);
-
-	bnx2x_init_block(bp, PXP_BLOCK, init_stage);
-	bnx2x_init_block(bp, PXP2_BLOCK, init_stage);
-
-	bnx2x_init_block(bp, TCM_BLOCK, init_stage);
-	bnx2x_init_block(bp, UCM_BLOCK, init_stage);
-	bnx2x_init_block(bp, CCM_BLOCK, init_stage);
-	bnx2x_init_block(bp, XCM_BLOCK, init_stage);
-
-#ifdef BCM_CNIC
-	REG_WR(bp, QM_REG_CONNNUM_0 + port*4, 1024/16 - 1);
-
-	bnx2x_init_block(bp, TIMERS_BLOCK, init_stage);
-	REG_WR(bp, TM_REG_LIN0_SCAN_TIME + port*4, 20);
-	REG_WR(bp, TM_REG_LIN0_MAX_ACTIVE_CID + port*4, 31);
-#endif
-	bnx2x_init_block(bp, DQ_BLOCK, init_stage);
-
-	bnx2x_init_block(bp, BRB1_BLOCK, init_stage);
-	if (CHIP_REV_IS_SLOW(bp) && !CHIP_IS_E1H(bp)) {
-		/* no pause for emulation and FPGA */
-		low = 0;
-		high = 513;
-	} else {
-		if (IS_E1HMF(bp))
-			low = ((bp->flags & ONE_PORT_FLAG) ? 160 : 246);
-		else if (bp->dev->mtu > 4096) {
-			if (bp->flags & ONE_PORT_FLAG)
-				low = 160;
-			else {
-				val = bp->dev->mtu;
-				/* (24*1024 + val*4)/256 */
-				low = 96 + (val/64) + ((val % 64) ? 1 : 0);
-			}
-		} else
-			low = ((bp->flags & ONE_PORT_FLAG) ? 80 : 160);
-		high = low + 56;	/* 14*1024/256 */
-	}
-	REG_WR(bp, BRB1_REG_PAUSE_LOW_THRESHOLD_0 + port*4, low);
-	REG_WR(bp, BRB1_REG_PAUSE_HIGH_THRESHOLD_0 + port*4, high);
-
-
-	bnx2x_init_block(bp, PRS_BLOCK, init_stage);
-
-	bnx2x_init_block(bp, TSDM_BLOCK, init_stage);
-	bnx2x_init_block(bp, CSDM_BLOCK, init_stage);
-	bnx2x_init_block(bp, USDM_BLOCK, init_stage);
-	bnx2x_init_block(bp, XSDM_BLOCK, init_stage);
-
-	bnx2x_init_block(bp, TSEM_BLOCK, init_stage);
-	bnx2x_init_block(bp, USEM_BLOCK, init_stage);
-	bnx2x_init_block(bp, CSEM_BLOCK, init_stage);
-	bnx2x_init_block(bp, XSEM_BLOCK, init_stage);
-
-	bnx2x_init_block(bp, UPB_BLOCK, init_stage);
-	bnx2x_init_block(bp, XPB_BLOCK, init_stage);
-
-	bnx2x_init_block(bp, PBF_BLOCK, init_stage);
-
-	/* configure PBF to work without PAUSE mtu 9000 */
-	REG_WR(bp, PBF_REG_P0_PAUSE_ENABLE + port*4, 0);
-
-	/* update threshold */
-	REG_WR(bp, PBF_REG_P0_ARB_THRSH + port*4, (9040/16));
-	/* update init credit */
-	REG_WR(bp, PBF_REG_P0_INIT_CRD + port*4, (9040/16) + 553 - 22);
-
-	/* probe changes */
-	REG_WR(bp, PBF_REG_INIT_P0 + port*4, 1);
-	msleep(5);
-	REG_WR(bp, PBF_REG_INIT_P0 + port*4, 0);
-
-#ifdef BCM_CNIC
-	bnx2x_init_block(bp, SRCH_BLOCK, init_stage);
-#endif
-	bnx2x_init_block(bp, CDU_BLOCK, init_stage);
-	bnx2x_init_block(bp, CFC_BLOCK, init_stage);
-
-	if (CHIP_IS_E1(bp)) {
-		REG_WR(bp, HC_REG_LEADING_EDGE_0 + port*8, 0);
-		REG_WR(bp, HC_REG_TRAILING_EDGE_0 + port*8, 0);
-	}
-	bnx2x_init_block(bp, HC_BLOCK, init_stage);
-
-	bnx2x_init_block(bp, MISC_AEU_BLOCK, init_stage);
-	/* init aeu_mask_attn_func_0/1:
-	 *  - SF mode: bits 3-7 are masked. only bits 0-2 are in use
-	 *  - MF mode: bit 3 is masked. bits 0-2 are in use as in SF
-	 *             bits 4-7 are used for "per vn group attention" */
-	REG_WR(bp, MISC_REG_AEU_MASK_ATTN_FUNC_0 + port*4,
-	       (IS_E1HMF(bp) ? 0xF7 : 0x7));
-
-	bnx2x_init_block(bp, PXPCS_BLOCK, init_stage);
-	bnx2x_init_block(bp, EMAC0_BLOCK, init_stage);
-	bnx2x_init_block(bp, EMAC1_BLOCK, init_stage);
-	bnx2x_init_block(bp, DBU_BLOCK, init_stage);
-	bnx2x_init_block(bp, DBG_BLOCK, init_stage);
-
-	bnx2x_init_block(bp, NIG_BLOCK, init_stage);
-
-	REG_WR(bp, NIG_REG_XGXS_SERDES0_MODE_SEL + port*4, 1);
-
-	if (CHIP_IS_E1H(bp)) {
-		/* 0x2 disable e1hov, 0x1 enable */
-		REG_WR(bp, NIG_REG_LLH0_BRB1_DRV_MASK_MF + port*4,
-		       (IS_E1HMF(bp) ? 0x1 : 0x2));
-
-		{
-			REG_WR(bp, NIG_REG_LLFC_ENABLE_0 + port*4, 0);
-			REG_WR(bp, NIG_REG_LLFC_OUT_EN_0 + port*4, 0);
-			REG_WR(bp, NIG_REG_PAUSE_ENABLE_0 + port*4, 1);
-		}
-	}
-
-	bnx2x_init_block(bp, MCP_BLOCK, init_stage);
-	bnx2x_init_block(bp, DMAE_BLOCK, init_stage);
-
-	switch (XGXS_EXT_PHY_TYPE(bp->link_params.ext_phy_config)) {
-	case PORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM8726:
-		{
-		u32 swap_val, swap_override, aeu_gpio_mask, offset;
-
-		bnx2x_set_gpio(bp, MISC_REGISTERS_GPIO_3,
-			       MISC_REGISTERS_GPIO_INPUT_HI_Z, port);
-
-		/* The GPIO should be swapped if the swap register is
-		   set and active */
-		swap_val = REG_RD(bp, NIG_REG_PORT_SWAP);
-		swap_override = REG_RD(bp, NIG_REG_STRAP_OVERRIDE);
-
-		/* Select function upon port-swap configuration */
-		if (port == 0) {
-			offset = MISC_REG_AEU_ENABLE1_FUNC_0_OUT_0;
-			aeu_gpio_mask = (swap_val && swap_override) ?
-				AEU_INPUTS_ATTN_BITS_GPIO3_FUNCTION_1 :
-				AEU_INPUTS_ATTN_BITS_GPIO3_FUNCTION_0;
-		} else {
-			offset = MISC_REG_AEU_ENABLE1_FUNC_1_OUT_0;
-			aeu_gpio_mask = (swap_val && swap_override) ?
-				AEU_INPUTS_ATTN_BITS_GPIO3_FUNCTION_0 :
-				AEU_INPUTS_ATTN_BITS_GPIO3_FUNCTION_1;
-		}
-		val = REG_RD(bp, offset);
-		/* add GPIO3 to group */
-		val |= aeu_gpio_mask;
-		REG_WR(bp, offset, val);
-		}
-		break;
-
-	case PORT_HW_CFG_XGXS_EXT_PHY_TYPE_SFX7101:
-	case PORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM8727:
-		/* add SPIO 5 to group 0 */
-		{
-		u32 reg_addr = (port ? MISC_REG_AEU_ENABLE1_FUNC_1_OUT_0 :
-				       MISC_REG_AEU_ENABLE1_FUNC_0_OUT_0);
-		val = REG_RD(bp, reg_addr);
-		val |= AEU_INPUTS_ATTN_BITS_SPIO5;
-		REG_WR(bp, reg_addr, val);
-		}
-		break;
-
-	default:
-		break;
-	}
-
-	bnx2x__link_reset(bp);
-
-	return 0;
-}
-
-#define ILT_PER_FUNC		(768/2)
-#define FUNC_ILT_BASE(func)	(func * ILT_PER_FUNC)
-/* the phys address is shifted right 12 bits and has an added
-   1=valid bit added to the 53rd bit
-   then since this is a wide register(TM)
-   we split it into two 32 bit writes
- */
-#define ONCHIP_ADDR1(x)		((u32)(((u64)x >> 12) & 0xFFFFFFFF))
-#define ONCHIP_ADDR2(x)		((u32)((1 << 20) | ((u64)x >> 44)))
-#define PXP_ONE_ILT(x)		(((x) << 10) | x)
-#define PXP_ILT_RANGE(f, l)	(((l) << 10) | f)
-
-#ifdef BCM_CNIC
-#define CNIC_ILT_LINES		127
-#define CNIC_CTX_PER_ILT	16
-#else
-#define CNIC_ILT_LINES		0
-#endif
-
-static void bnx2x_ilt_wr(struct bnx2x *bp, u32 index, dma_addr_t addr)
-{
-	int reg;
-
-	if (CHIP_IS_E1H(bp))
-		reg = PXP2_REG_RQ_ONCHIP_AT_B0 + index*8;
-	else /* E1 */
-		reg = PXP2_REG_RQ_ONCHIP_AT + index*8;
-
-	bnx2x_wb_wr(bp, reg, ONCHIP_ADDR1(addr), ONCHIP_ADDR2(addr));
-}
-
-static int bnx2x_init_func(struct bnx2x *bp)
-{
-	int port = BP_PORT(bp);
-	int func = BP_FUNC(bp);
-	u32 addr, val;
-	int i;
-
-	DP(BNX2X_MSG_MCP, "starting func init  func %x\n", func);
-
-	/* set MSI reconfigure capability */
-	addr = (port ? HC_REG_CONFIG_1 : HC_REG_CONFIG_0);
-	val = REG_RD(bp, addr);
-	val |= HC_CONFIG_0_REG_MSI_ATTN_EN_0;
-	REG_WR(bp, addr, val);
-
-	i = FUNC_ILT_BASE(func);
-
-	bnx2x_ilt_wr(bp, i, bnx2x_sp_mapping(bp, context));
-	if (CHIP_IS_E1H(bp)) {
-		REG_WR(bp, PXP2_REG_RQ_CDU_FIRST_ILT, i);
-		REG_WR(bp, PXP2_REG_RQ_CDU_LAST_ILT, i + CNIC_ILT_LINES);
-	} else /* E1 */
-		REG_WR(bp, PXP2_REG_PSWRQ_CDU0_L2P + func*4,
-		       PXP_ILT_RANGE(i, i + CNIC_ILT_LINES));
-
-#ifdef BCM_CNIC
-	i += 1 + CNIC_ILT_LINES;
-	bnx2x_ilt_wr(bp, i, bp->timers_mapping);
-	if (CHIP_IS_E1(bp))
-		REG_WR(bp, PXP2_REG_PSWRQ_TM0_L2P + func*4, PXP_ONE_ILT(i));
-	else {
-		REG_WR(bp, PXP2_REG_RQ_TM_FIRST_ILT, i);
-		REG_WR(bp, PXP2_REG_RQ_TM_LAST_ILT, i);
-	}
-
-	i++;
-	bnx2x_ilt_wr(bp, i, bp->qm_mapping);
-	if (CHIP_IS_E1(bp))
-		REG_WR(bp, PXP2_REG_PSWRQ_QM0_L2P + func*4, PXP_ONE_ILT(i));
-	else {
-		REG_WR(bp, PXP2_REG_RQ_QM_FIRST_ILT, i);
-		REG_WR(bp, PXP2_REG_RQ_QM_LAST_ILT, i);
-	}
-
-	i++;
-	bnx2x_ilt_wr(bp, i, bp->t1_mapping);
-	if (CHIP_IS_E1(bp))
-		REG_WR(bp, PXP2_REG_PSWRQ_SRC0_L2P + func*4, PXP_ONE_ILT(i));
-	else {
-		REG_WR(bp, PXP2_REG_RQ_SRC_FIRST_ILT, i);
-		REG_WR(bp, PXP2_REG_RQ_SRC_LAST_ILT, i);
-	}
-
-	/* tell the searcher where the T2 table is */
-	REG_WR(bp, SRC_REG_COUNTFREE0 + port*4, 16*1024/64);
-
-	bnx2x_wb_wr(bp, SRC_REG_FIRSTFREE0 + port*16,
-		    U64_LO(bp->t2_mapping), U64_HI(bp->t2_mapping));
-
-	bnx2x_wb_wr(bp, SRC_REG_LASTFREE0 + port*16,
-		    U64_LO((u64)bp->t2_mapping + 16*1024 - 64),
-		    U64_HI((u64)bp->t2_mapping + 16*1024 - 64));
-
-	REG_WR(bp, SRC_REG_NUMBER_HASH_BITS0 + port*4, 10);
-#endif
-
-	if (CHIP_IS_E1H(bp)) {
-		bnx2x_init_block(bp, MISC_BLOCK, FUNC0_STAGE + func);
-		bnx2x_init_block(bp, TCM_BLOCK, FUNC0_STAGE + func);
-		bnx2x_init_block(bp, UCM_BLOCK, FUNC0_STAGE + func);
-		bnx2x_init_block(bp, CCM_BLOCK, FUNC0_STAGE + func);
-		bnx2x_init_block(bp, XCM_BLOCK, FUNC0_STAGE + func);
-		bnx2x_init_block(bp, TSEM_BLOCK, FUNC0_STAGE + func);
-		bnx2x_init_block(bp, USEM_BLOCK, FUNC0_STAGE + func);
-		bnx2x_init_block(bp, CSEM_BLOCK, FUNC0_STAGE + func);
-		bnx2x_init_block(bp, XSEM_BLOCK, FUNC0_STAGE + func);
-
-		REG_WR(bp, NIG_REG_LLH0_FUNC_EN + port*8, 1);
-		REG_WR(bp, NIG_REG_LLH0_FUNC_VLAN_ID + port*8, bp->e1hov);
-	}
-
-	/* HC init per function */
-	if (CHIP_IS_E1H(bp)) {
-		REG_WR(bp, MISC_REG_AEU_GENERAL_ATTN_12 + func*4, 0);
-
-		REG_WR(bp, HC_REG_LEADING_EDGE_0 + port*8, 0);
-		REG_WR(bp, HC_REG_TRAILING_EDGE_0 + port*8, 0);
-	}
-	bnx2x_init_block(bp, HC_BLOCK, FUNC0_STAGE + func);
-
-	/* Reset PCIE errors for debug */
-	REG_WR(bp, 0x2114, 0xffffffff);
-	REG_WR(bp, 0x2120, 0xffffffff);
-
-	return 0;
-}
-
-static int bnx2x_init_hw(struct bnx2x *bp, u32 load_code)
-{
-	int i, rc = 0;
-
-	DP(BNX2X_MSG_MCP, "function %d  load_code %x\n",
-	   BP_FUNC(bp), load_code);
-
-	bp->dmae_ready = 0;
-	mutex_init(&bp->dmae_mutex);
-	rc = bnx2x_gunzip_init(bp);
-	if (rc)
-		return rc;
-
-	switch (load_code) {
-	case FW_MSG_CODE_DRV_LOAD_COMMON:
-		rc = bnx2x_init_common(bp);
-		if (rc)
-			goto init_hw_err;
-		/* no break */
-
-	case FW_MSG_CODE_DRV_LOAD_PORT:
-		bp->dmae_ready = 1;
-		rc = bnx2x_init_port(bp);
-		if (rc)
-			goto init_hw_err;
-		/* no break */
-
-	case FW_MSG_CODE_DRV_LOAD_FUNCTION:
-		bp->dmae_ready = 1;
-		rc = bnx2x_init_func(bp);
-		if (rc)
-			goto init_hw_err;
-		break;
-
-	default:
-		BNX2X_ERR("Unknown load_code (0x%x) from MCP\n", load_code);
-		break;
-	}
-
-	if (!BP_NOMCP(bp)) {
-		int func = BP_FUNC(bp);
-
-		bp->fw_drv_pulse_wr_seq =
-				(SHMEM_RD(bp, func_mb[func].drv_pulse_mb) &
-				 DRV_PULSE_SEQ_MASK);
-		DP(BNX2X_MSG_MCP, "drv_pulse 0x%x\n", bp->fw_drv_pulse_wr_seq);
-	}
-
-	/* this needs to be done before gunzip end */
-	bnx2x_zero_def_sb(bp);
-	for_each_queue(bp, i)
-		bnx2x_zero_sb(bp, BP_L_ID(bp) + i);
-#ifdef BCM_CNIC
-	bnx2x_zero_sb(bp, BP_L_ID(bp) + i);
-#endif
-
-init_hw_err:
-	bnx2x_gunzip_end(bp);
-
-	return rc;
-}
-
-static void bnx2x_free_mem(struct bnx2x *bp)
-{
-
-#define BNX2X_PCI_FREE(x, y, size) \
-	do { \
-		if (x) { \
-			pci_free_consistent(bp->pdev, size, x, y); \
-			x = NULL; \
-			y = 0; \
-		} \
-	} while (0)
-
-#define BNX2X_FREE(x) \
-	do { \
-		if (x) { \
-			vfree(x); \
-			x = NULL; \
-		} \
-	} while (0)
-
-	int i;
-
-	/* fastpath */
-	/* Common */
-	for_each_queue(bp, i) {
-
-		/* status blocks */
-		BNX2X_PCI_FREE(bnx2x_fp(bp, i, status_blk),
-			       bnx2x_fp(bp, i, status_blk_mapping),
-			       sizeof(struct host_status_block));
-	}
-	/* Rx */
-	for_each_queue(bp, i) {
-
-		/* fastpath rx rings: rx_buf rx_desc rx_comp */
-		BNX2X_FREE(bnx2x_fp(bp, i, rx_buf_ring));
-		BNX2X_PCI_FREE(bnx2x_fp(bp, i, rx_desc_ring),
-			       bnx2x_fp(bp, i, rx_desc_mapping),
-			       sizeof(struct eth_rx_bd) * NUM_RX_BD);
-
-		BNX2X_PCI_FREE(bnx2x_fp(bp, i, rx_comp_ring),
-			       bnx2x_fp(bp, i, rx_comp_mapping),
-			       sizeof(struct eth_fast_path_rx_cqe) *
-			       NUM_RCQ_BD);
-
-		/* SGE ring */
-		BNX2X_FREE(bnx2x_fp(bp, i, rx_page_ring));
-		BNX2X_PCI_FREE(bnx2x_fp(bp, i, rx_sge_ring),
-			       bnx2x_fp(bp, i, rx_sge_mapping),
-			       BCM_PAGE_SIZE * NUM_RX_SGE_PAGES);
-	}
-	/* Tx */
-	for_each_queue(bp, i) {
-
-		/* fastpath tx rings: tx_buf tx_desc */
-		BNX2X_FREE(bnx2x_fp(bp, i, tx_buf_ring));
-		BNX2X_PCI_FREE(bnx2x_fp(bp, i, tx_desc_ring),
-			       bnx2x_fp(bp, i, tx_desc_mapping),
-			       sizeof(union eth_tx_bd_types) * NUM_TX_BD);
-	}
-	/* end of fastpath */
-
-	BNX2X_PCI_FREE(bp->def_status_blk, bp->def_status_blk_mapping,
-		       sizeof(struct host_def_status_block));
-
-	BNX2X_PCI_FREE(bp->slowpath, bp->slowpath_mapping,
-		       sizeof(struct bnx2x_slowpath));
-
-#ifdef BCM_CNIC
-	BNX2X_PCI_FREE(bp->t1, bp->t1_mapping, 64*1024);
-	BNX2X_PCI_FREE(bp->t2, bp->t2_mapping, 16*1024);
-	BNX2X_PCI_FREE(bp->timers, bp->timers_mapping, 8*1024);
-	BNX2X_PCI_FREE(bp->qm, bp->qm_mapping, 128*1024);
-	BNX2X_PCI_FREE(bp->cnic_sb, bp->cnic_sb_mapping,
-		       sizeof(struct host_status_block));
-#endif
-	BNX2X_PCI_FREE(bp->spq, bp->spq_mapping, BCM_PAGE_SIZE);
-
-#undef BNX2X_PCI_FREE
-#undef BNX2X_KFREE
-}
-
-static int bnx2x_alloc_mem(struct bnx2x *bp)
-{
-
-#define BNX2X_PCI_ALLOC(x, y, size) \
-	do { \
-		x = pci_alloc_consistent(bp->pdev, size, y); \
-		if (x == NULL) \
-			goto alloc_mem_err; \
-		memset(x, 0, size); \
-	} while (0)
-
-#define BNX2X_ALLOC(x, size) \
-	do { \
-		x = vmalloc(size); \
-		if (x == NULL) \
-			goto alloc_mem_err; \
-		memset(x, 0, size); \
-	} while (0)
-
-	int i;
-
-	/* fastpath */
-	/* Common */
-	for_each_queue(bp, i) {
-		bnx2x_fp(bp, i, bp) = bp;
-
-		/* status blocks */
-		BNX2X_PCI_ALLOC(bnx2x_fp(bp, i, status_blk),
-				&bnx2x_fp(bp, i, status_blk_mapping),
-				sizeof(struct host_status_block));
-	}
-	/* Rx */
-	for_each_queue(bp, i) {
-
-		/* fastpath rx rings: rx_buf rx_desc rx_comp */
-		BNX2X_ALLOC(bnx2x_fp(bp, i, rx_buf_ring),
-				sizeof(struct sw_rx_bd) * NUM_RX_BD);
-		BNX2X_PCI_ALLOC(bnx2x_fp(bp, i, rx_desc_ring),
-				&bnx2x_fp(bp, i, rx_desc_mapping),
-				sizeof(struct eth_rx_bd) * NUM_RX_BD);
-
-		BNX2X_PCI_ALLOC(bnx2x_fp(bp, i, rx_comp_ring),
-				&bnx2x_fp(bp, i, rx_comp_mapping),
-				sizeof(struct eth_fast_path_rx_cqe) *
-				NUM_RCQ_BD);
-
-		/* SGE ring */
-		BNX2X_ALLOC(bnx2x_fp(bp, i, rx_page_ring),
-				sizeof(struct sw_rx_page) * NUM_RX_SGE);
-		BNX2X_PCI_ALLOC(bnx2x_fp(bp, i, rx_sge_ring),
-				&bnx2x_fp(bp, i, rx_sge_mapping),
-				BCM_PAGE_SIZE * NUM_RX_SGE_PAGES);
-	}
-	/* Tx */
-	for_each_queue(bp, i) {
-
-		/* fastpath tx rings: tx_buf tx_desc */
-		BNX2X_ALLOC(bnx2x_fp(bp, i, tx_buf_ring),
-				sizeof(struct sw_tx_bd) * NUM_TX_BD);
-		BNX2X_PCI_ALLOC(bnx2x_fp(bp, i, tx_desc_ring),
-				&bnx2x_fp(bp, i, tx_desc_mapping),
-				sizeof(union eth_tx_bd_types) * NUM_TX_BD);
-	}
-	/* end of fastpath */
-
-	BNX2X_PCI_ALLOC(bp->def_status_blk, &bp->def_status_blk_mapping,
-			sizeof(struct host_def_status_block));
-
-	BNX2X_PCI_ALLOC(bp->slowpath, &bp->slowpath_mapping,
-			sizeof(struct bnx2x_slowpath));
-
-#ifdef BCM_CNIC
-	BNX2X_PCI_ALLOC(bp->t1, &bp->t1_mapping, 64*1024);
-
-	/* allocate searcher T2 table
-	   we allocate 1/4 of alloc num for T2
-	  (which is not entered into the ILT) */
-	BNX2X_PCI_ALLOC(bp->t2, &bp->t2_mapping, 16*1024);
-
-	/* Initialize T2 (for 1024 connections) */
-	for (i = 0; i < 16*1024; i += 64)
-		*(u64 *)((char *)bp->t2 + i + 56) = bp->t2_mapping + i + 64;
-
-	/* Timer block array (8*MAX_CONN) phys uncached for now 1024 conns */
-	BNX2X_PCI_ALLOC(bp->timers, &bp->timers_mapping, 8*1024);
-
-	/* QM queues (128*MAX_CONN) */
-	BNX2X_PCI_ALLOC(bp->qm, &bp->qm_mapping, 128*1024);
-
-	BNX2X_PCI_ALLOC(bp->cnic_sb, &bp->cnic_sb_mapping,
-			sizeof(struct host_status_block));
-#endif
-
-	/* Slow path ring */
-	BNX2X_PCI_ALLOC(bp->spq, &bp->spq_mapping, BCM_PAGE_SIZE);
-
-	return 0;
-
-alloc_mem_err:
-	bnx2x_free_mem(bp);
-	return -ENOMEM;
-
-#undef BNX2X_PCI_ALLOC
-#undef BNX2X_ALLOC
-}
-
-static void bnx2x_free_tx_skbs(struct bnx2x *bp)
-{
-	int i;
-
-	for_each_queue(bp, i) {
-		struct bnx2x_fastpath *fp = &bp->fp[i];
-
-		u16 bd_cons = fp->tx_bd_cons;
-		u16 sw_prod = fp->tx_pkt_prod;
-		u16 sw_cons = fp->tx_pkt_cons;
-
-		while (sw_cons != sw_prod) {
-			bd_cons = bnx2x_free_tx_pkt(bp, fp, TX_BD(sw_cons));
-			sw_cons++;
-		}
-	}
-}
-
-static void bnx2x_free_rx_skbs(struct bnx2x *bp)
-{
-	int i, j;
-
-	for_each_queue(bp, j) {
-		struct bnx2x_fastpath *fp = &bp->fp[j];
-
-		for (i = 0; i < NUM_RX_BD; i++) {
-			struct sw_rx_bd *rx_buf = &fp->rx_buf_ring[i];
-			struct sk_buff *skb = rx_buf->skb;
-
-			if (skb == NULL)
-				continue;
-
-			pci_unmap_single(bp->pdev,
-					 pci_unmap_addr(rx_buf, mapping),
-					 bp->rx_buf_size, PCI_DMA_FROMDEVICE);
-
-			rx_buf->skb = NULL;
-			dev_kfree_skb(skb);
-		}
-		if (!fp->disable_tpa)
-			bnx2x_free_tpa_pool(bp, fp, CHIP_IS_E1(bp) ?
-					    ETH_MAX_AGGREGATION_QUEUES_E1 :
-					    ETH_MAX_AGGREGATION_QUEUES_E1H);
-	}
-}
-
-static void bnx2x_free_skbs(struct bnx2x *bp)
-{
-	bnx2x_free_tx_skbs(bp);
-	bnx2x_free_rx_skbs(bp);
-}
-
-static void bnx2x_free_msix_irqs(struct bnx2x *bp)
-{
-	int i, offset = 1;
-
-	free_irq(bp->msix_table[0].vector, bp->dev);
-	DP(NETIF_MSG_IFDOWN, "released sp irq (%d)\n",
-	   bp->msix_table[0].vector);
-
-#ifdef BCM_CNIC
-	offset++;
-#endif
-	for_each_queue(bp, i) {
-		DP(NETIF_MSG_IFDOWN, "about to release fp #%d->%d irq  "
-		   "state %x\n", i, bp->msix_table[i + offset].vector,
-		   bnx2x_fp(bp, i, state));
-
-		free_irq(bp->msix_table[i + offset].vector, &bp->fp[i]);
-	}
-}
-
-static void bnx2x_free_irq(struct bnx2x *bp, bool disable_only)
-{
-	if (bp->flags & USING_MSIX_FLAG) {
-		if (!disable_only)
-			bnx2x_free_msix_irqs(bp);
-		pci_disable_msix(bp->pdev);
-		bp->flags &= ~USING_MSIX_FLAG;
-
-	} else if (bp->flags & USING_MSI_FLAG) {
-		if (!disable_only)
-			free_irq(bp->pdev->irq, bp->dev);
-		pci_disable_msi(bp->pdev);
-		bp->flags &= ~USING_MSI_FLAG;
-
-	} else if (!disable_only)
-		free_irq(bp->pdev->irq, bp->dev);
-}
-
-static int bnx2x_enable_msix(struct bnx2x *bp)
-{
-	int i, rc, offset = 1;
-	int igu_vec = 0;
-
-	bp->msix_table[0].entry = igu_vec;
-	DP(NETIF_MSG_IFUP, "msix_table[0].entry = %d (slowpath)\n", igu_vec);
-
-#ifdef BCM_CNIC
-	igu_vec = BP_L_ID(bp) + offset;
-	bp->msix_table[1].entry = igu_vec;
-	DP(NETIF_MSG_IFUP, "msix_table[1].entry = %d (CNIC)\n", igu_vec);
-	offset++;
-#endif
-	for_each_queue(bp, i) {
-		igu_vec = BP_L_ID(bp) + offset + i;
-		bp->msix_table[i + offset].entry = igu_vec;
-		DP(NETIF_MSG_IFUP, "msix_table[%d].entry = %d "
-		   "(fastpath #%u)\n", i + offset, igu_vec, i);
-	}
-
-	rc = pci_enable_msix(bp->pdev, &bp->msix_table[0],
-			     BNX2X_NUM_QUEUES(bp) + offset);
-	if (rc) {
-		DP(NETIF_MSG_IFUP, "MSI-X is not attainable  rc %d\n", rc);
-		return rc;
-	}
-
-	bp->flags |= USING_MSIX_FLAG;
-
-	return 0;
-}
-
-static int bnx2x_req_msix_irqs(struct bnx2x *bp)
-{
-	int i, rc, offset = 1;
-
-	rc = request_irq(bp->msix_table[0].vector, bnx2x_msix_sp_int, 0,
-			 bp->dev->name, bp->dev);
-	if (rc) {
-		BNX2X_ERR("request sp irq failed\n");
-		return -EBUSY;
-	}
-
-#ifdef BCM_CNIC
-	offset++;
-#endif
-	for_each_queue(bp, i) {
-		struct bnx2x_fastpath *fp = &bp->fp[i];
-		snprintf(fp->name, sizeof(fp->name), "%s-fp-%d",
-			 bp->dev->name, i);
-
-		rc = request_irq(bp->msix_table[i + offset].vector,
-				 bnx2x_msix_fp_int, 0, fp->name, fp);
-		if (rc) {
-			BNX2X_ERR("request fp #%d irq failed  rc %d\n", i, rc);
-			bnx2x_free_msix_irqs(bp);
-			return -EBUSY;
-		}
-
-		fp->state = BNX2X_FP_STATE_IRQ;
-	}
-
-	i = BNX2X_NUM_QUEUES(bp);
-	netdev_info(bp->dev, "using MSI-X  IRQs: sp %d  fp[%d] %d ... fp[%d] %d\n",
-		    bp->msix_table[0].vector,
-		    0, bp->msix_table[offset].vector,
-		    i - 1, bp->msix_table[offset + i - 1].vector);
-
-	return 0;
-}
-
-static int bnx2x_enable_msi(struct bnx2x *bp)
-{
-	int rc;
-
-	rc = pci_enable_msi(bp->pdev);
-	if (rc) {
-		DP(NETIF_MSG_IFUP, "MSI is not attainable\n");
-		return -1;
-	}
-	bp->flags |= USING_MSI_FLAG;
-
-	return 0;
-}
-
-static int bnx2x_req_irq(struct bnx2x *bp)
-{
-	unsigned long flags;
-	int rc;
-
-	if (bp->flags & USING_MSI_FLAG)
-		flags = 0;
-	else
-		flags = IRQF_SHARED;
-
-	rc = request_irq(bp->pdev->irq, bnx2x_interrupt, flags,
-			 bp->dev->name, bp->dev);
-	if (!rc)
-		bnx2x_fp(bp, 0, state) = BNX2X_FP_STATE_IRQ;
-
-	return rc;
-}
-
-static void bnx2x_napi_enable(struct bnx2x *bp)
-{
-	int i;
-
-	for_each_queue(bp, i)
-		napi_enable(&bnx2x_fp(bp, i, napi));
-}
-
-static void bnx2x_napi_disable(struct bnx2x *bp)
-{
-	int i;
-
-	for_each_queue(bp, i)
-		napi_disable(&bnx2x_fp(bp, i, napi));
-}
-
-static void bnx2x_netif_start(struct bnx2x *bp)
-{
-	int intr_sem;
-
-	intr_sem = atomic_dec_and_test(&bp->intr_sem);
-	smp_wmb(); /* Ensure that bp->intr_sem update is SMP-safe */
-
-	if (intr_sem) {
-		if (netif_running(bp->dev)) {
-			bnx2x_napi_enable(bp);
-			bnx2x_int_enable(bp);
-			if (bp->state == BNX2X_STATE_OPEN)
-				netif_tx_wake_all_queues(bp->dev);
-		}
-	}
-}
-
-static void bnx2x_netif_stop(struct bnx2x *bp, int disable_hw)
-{
-	bnx2x_int_disable_sync(bp, disable_hw);
-	bnx2x_napi_disable(bp);
-	netif_tx_disable(bp->dev);
-}
-
-/*
- * Init service functions
- */
-
-/**
- * Sets a MAC in a CAM for a few L2 Clients for E1 chip
- *
- * @param bp driver descriptor
- * @param set set or clear an entry (1 or 0)
- * @param mac pointer to a buffer containing a MAC
- * @param cl_bit_vec bit vector of clients to register a MAC for
- * @param cam_offset offset in a CAM to use
- * @param with_bcast set broadcast MAC as well
- */
-static void bnx2x_set_mac_addr_e1_gen(struct bnx2x *bp, int set, u8 *mac,
-				      u32 cl_bit_vec, u8 cam_offset,
-				      u8 with_bcast)
-{
-	struct mac_configuration_cmd *config = bnx2x_sp(bp, mac_config);
-	int port = BP_PORT(bp);
-
-	/* CAM allocation
-	 * unicasts 0-31:port0 32-63:port1
-	 * multicast 64-127:port0 128-191:port1
-	 */
-	config->hdr.length = 1 + (with_bcast ? 1 : 0);
-	config->hdr.offset = cam_offset;
-	config->hdr.client_id = 0xff;
-	config->hdr.reserved1 = 0;
-
-	/* primary MAC */
-	config->config_table[0].cam_entry.msb_mac_addr =
-					swab16(*(u16 *)&mac[0]);
-	config->config_table[0].cam_entry.middle_mac_addr =
-					swab16(*(u16 *)&mac[2]);
-	config->config_table[0].cam_entry.lsb_mac_addr =
-					swab16(*(u16 *)&mac[4]);
-	config->config_table[0].cam_entry.flags = cpu_to_le16(port);
-	if (set)
-		config->config_table[0].target_table_entry.flags = 0;
-	else
-		CAM_INVALIDATE(config->config_table[0]);
-	config->config_table[0].target_table_entry.clients_bit_vector =
-						cpu_to_le32(cl_bit_vec);
-	config->config_table[0].target_table_entry.vlan_id = 0;
-
-	DP(NETIF_MSG_IFUP, "%s MAC (%04x:%04x:%04x)\n",
-	   (set ? "setting" : "clearing"),
-	   config->config_table[0].cam_entry.msb_mac_addr,
-	   config->config_table[0].cam_entry.middle_mac_addr,
-	   config->config_table[0].cam_entry.lsb_mac_addr);
-
-	/* broadcast */
-	if (with_bcast) {
-		config->config_table[1].cam_entry.msb_mac_addr =
-			cpu_to_le16(0xffff);
-		config->config_table[1].cam_entry.middle_mac_addr =
-			cpu_to_le16(0xffff);
-		config->config_table[1].cam_entry.lsb_mac_addr =
-			cpu_to_le16(0xffff);
-		config->config_table[1].cam_entry.flags = cpu_to_le16(port);
-		if (set)
-			config->config_table[1].target_table_entry.flags =
-					TSTORM_CAM_TARGET_TABLE_ENTRY_BROADCAST;
-		else
-			CAM_INVALIDATE(config->config_table[1]);
-		config->config_table[1].target_table_entry.clients_bit_vector =
-							cpu_to_le32(cl_bit_vec);
-		config->config_table[1].target_table_entry.vlan_id = 0;
-	}
-
-	bnx2x_sp_post(bp, RAMROD_CMD_ID_ETH_SET_MAC, 0,
-		      U64_HI(bnx2x_sp_mapping(bp, mac_config)),
-		      U64_LO(bnx2x_sp_mapping(bp, mac_config)), 0);
-}
-
-/**
- * Sets a MAC in a CAM for a few L2 Clients for E1H chip
- *
- * @param bp driver descriptor
- * @param set set or clear an entry (1 or 0)
- * @param mac pointer to a buffer containing a MAC
- * @param cl_bit_vec bit vector of clients to register a MAC for
- * @param cam_offset offset in a CAM to use
- */
-static void bnx2x_set_mac_addr_e1h_gen(struct bnx2x *bp, int set, u8 *mac,
-				       u32 cl_bit_vec, u8 cam_offset)
-{
-	struct mac_configuration_cmd_e1h *config =
-		(struct mac_configuration_cmd_e1h *)bnx2x_sp(bp, mac_config);
-
-	config->hdr.length = 1;
-	config->hdr.offset = cam_offset;
-	config->hdr.client_id = 0xff;
-	config->hdr.reserved1 = 0;
-
-	/* primary MAC */
-	config->config_table[0].msb_mac_addr =
-					swab16(*(u16 *)&mac[0]);
-	config->config_table[0].middle_mac_addr =
-					swab16(*(u16 *)&mac[2]);
-	config->config_table[0].lsb_mac_addr =
-					swab16(*(u16 *)&mac[4]);
-	config->config_table[0].clients_bit_vector =
-					cpu_to_le32(cl_bit_vec);
-	config->config_table[0].vlan_id = 0;
-	config->config_table[0].e1hov_id = cpu_to_le16(bp->e1hov);
-	if (set)
-		config->config_table[0].flags = BP_PORT(bp);
-	else
-		config->config_table[0].flags =
-				MAC_CONFIGURATION_ENTRY_E1H_ACTION_TYPE;
-
-	DP(NETIF_MSG_IFUP, "%s MAC (%04x:%04x:%04x)  E1HOV %d  CLID mask %d\n",
-	   (set ? "setting" : "clearing"),
-	   config->config_table[0].msb_mac_addr,
-	   config->config_table[0].middle_mac_addr,
-	   config->config_table[0].lsb_mac_addr, bp->e1hov, cl_bit_vec);
-
-	bnx2x_sp_post(bp, RAMROD_CMD_ID_ETH_SET_MAC, 0,
-		      U64_HI(bnx2x_sp_mapping(bp, mac_config)),
-		      U64_LO(bnx2x_sp_mapping(bp, mac_config)), 0);
-}
-
-static int bnx2x_wait_ramrod(struct bnx2x *bp, int state, int idx,
-			     int *state_p, int poll)
-{
-	/* can take a while if any port is running */
-	int cnt = 5000;
-
-	DP(NETIF_MSG_IFUP, "%s for state to become %x on IDX [%d]\n",
-	   poll ? "polling" : "waiting", state, idx);
-
-	might_sleep();
-	while (cnt--) {
-		if (poll) {
-			bnx2x_rx_int(bp->fp, 10);
-			/* if index is different from 0
-			 * the reply for some commands will
-			 * be on the non default queue
-			 */
-			if (idx)
-				bnx2x_rx_int(&bp->fp[idx], 10);
-		}
-
-		mb(); /* state is changed by bnx2x_sp_event() */
-		if (*state_p == state) {
-#ifdef BNX2X_STOP_ON_ERROR
-			DP(NETIF_MSG_IFUP, "exit  (cnt %d)\n", 5000 - cnt);
-#endif
-			return 0;
-		}
-
-		msleep(1);
-
-		if (bp->panic)
-			return -EIO;
-	}
-
-	/* timeout! */
-	BNX2X_ERR("timeout %s for state %x on IDX [%d]\n",
-		  poll ? "polling" : "waiting", state, idx);
-#ifdef BNX2X_STOP_ON_ERROR
-	bnx2x_panic();
-#endif
-
-	return -EBUSY;
-}
-
-static void bnx2x_set_eth_mac_addr_e1h(struct bnx2x *bp, int set)
-{
-	bp->set_mac_pending++;
-	smp_wmb();
-
-	bnx2x_set_mac_addr_e1h_gen(bp, set, bp->dev->dev_addr,
-				   (1 << bp->fp->cl_id), BP_FUNC(bp));
-
-	/* Wait for a completion */
-	bnx2x_wait_ramrod(bp, 0, 0, &bp->set_mac_pending, set ? 0 : 1);
-}
-
-static void bnx2x_set_eth_mac_addr_e1(struct bnx2x *bp, int set)
-{
-	bp->set_mac_pending++;
-	smp_wmb();
-
-	bnx2x_set_mac_addr_e1_gen(bp, set, bp->dev->dev_addr,
-				  (1 << bp->fp->cl_id), (BP_PORT(bp) ? 32 : 0),
-				  1);
-
-	/* Wait for a completion */
-	bnx2x_wait_ramrod(bp, 0, 0, &bp->set_mac_pending, set ? 0 : 1);
-}
-
-#ifdef BCM_CNIC
-/**
- * Set iSCSI MAC(s) at the next enties in the CAM after the ETH
- * MAC(s). This function will wait until the ramdord completion
- * returns.
- *
- * @param bp driver handle
- * @param set set or clear the CAM entry
- *
- * @return 0 if cussess, -ENODEV if ramrod doesn't return.
- */
-static int bnx2x_set_iscsi_eth_mac_addr(struct bnx2x *bp, int set)
-{
-	u32 cl_bit_vec = (1 << BCM_ISCSI_ETH_CL_ID);
-
-	bp->set_mac_pending++;
-	smp_wmb();
-
-	/* Send a SET_MAC ramrod */
-	if (CHIP_IS_E1(bp))
-		bnx2x_set_mac_addr_e1_gen(bp, set, bp->iscsi_mac,
-				  cl_bit_vec, (BP_PORT(bp) ? 32 : 0) + 2,
-				  1);
-	else
-		/* CAM allocation for E1H
-		* unicasts: by func number
-		* multicast: 20+FUNC*20, 20 each
-		*/
-		bnx2x_set_mac_addr_e1h_gen(bp, set, bp->iscsi_mac,
-				   cl_bit_vec, E1H_FUNC_MAX + BP_FUNC(bp));
-
-	/* Wait for a completion when setting */
-	bnx2x_wait_ramrod(bp, 0, 0, &bp->set_mac_pending, set ? 0 : 1);
-
-	return 0;
-}
-#endif
-
-static int bnx2x_setup_leading(struct bnx2x *bp)
-{
-	int rc;
-
-	/* reset IGU state */
-	bnx2x_ack_sb(bp, bp->fp[0].sb_id, CSTORM_ID, 0, IGU_INT_ENABLE, 0);
-
-	/* SETUP ramrod */
-	bnx2x_sp_post(bp, RAMROD_CMD_ID_ETH_PORT_SETUP, 0, 0, 0, 0);
-
-	/* Wait for completion */
-	rc = bnx2x_wait_ramrod(bp, BNX2X_STATE_OPEN, 0, &(bp->state), 0);
-
-	return rc;
-}
-
-static int bnx2x_setup_multi(struct bnx2x *bp, int index)
-{
-	struct bnx2x_fastpath *fp = &bp->fp[index];
-
-	/* reset IGU state */
-	bnx2x_ack_sb(bp, fp->sb_id, CSTORM_ID, 0, IGU_INT_ENABLE, 0);
-
-	/* SETUP ramrod */
-	fp->state = BNX2X_FP_STATE_OPENING;
-	bnx2x_sp_post(bp, RAMROD_CMD_ID_ETH_CLIENT_SETUP, index, 0,
-		      fp->cl_id, 0);
-
-	/* Wait for completion */
-	return bnx2x_wait_ramrod(bp, BNX2X_FP_STATE_OPEN, index,
-				 &(fp->state), 0);
-}
-
-static int bnx2x_poll(struct napi_struct *napi, int budget);
-
-static void bnx2x_set_num_queues_msix(struct bnx2x *bp)
-{
-
-	switch (bp->multi_mode) {
-	case ETH_RSS_MODE_DISABLED:
-		bp->num_queues = 1;
-		break;
-
-	case ETH_RSS_MODE_REGULAR:
-		if (num_queues)
-			bp->num_queues = min_t(u32, num_queues,
-						  BNX2X_MAX_QUEUES(bp));
-		else
-			bp->num_queues = min_t(u32, num_online_cpus(),
-						  BNX2X_MAX_QUEUES(bp));
-		break;
-
-
-	default:
-		bp->num_queues = 1;
-		break;
-	}
-}
-
-static int bnx2x_set_num_queues(struct bnx2x *bp)
-{
-	int rc = 0;
-
-	switch (int_mode) {
-	case INT_MODE_INTx:
-	case INT_MODE_MSI:
-		bp->num_queues = 1;
-		DP(NETIF_MSG_IFUP, "set number of queues to 1\n");
-		break;
-
-	case INT_MODE_MSIX:
-	default:
-		/* Set number of queues according to bp->multi_mode value */
-		bnx2x_set_num_queues_msix(bp);
-
-		DP(NETIF_MSG_IFUP, "set number of queues to %d\n",
-		   bp->num_queues);
-
-		/* if we can't use MSI-X we only need one fp,
-		 * so try to enable MSI-X with the requested number of fp's
-		 * and fallback to MSI or legacy INTx with one fp
-		 */
-		rc = bnx2x_enable_msix(bp);
-		if (rc)
-			/* failed to enable MSI-X */
-			bp->num_queues = 1;
-		break;
-	}
-	bp->dev->real_num_tx_queues = bp->num_queues;
-	return rc;
-}
-
-#ifdef BCM_CNIC
-static int bnx2x_cnic_notify(struct bnx2x *bp, int cmd);
-static void bnx2x_setup_cnic_irq_info(struct bnx2x *bp);
-#endif
-
-/* must be called with rtnl_lock */
-static int bnx2x_nic_load(struct bnx2x *bp, int load_mode)
-{
-	u32 load_code;
-	int i, rc;
-
-#ifdef BNX2X_STOP_ON_ERROR
-	if (unlikely(bp->panic))
-		return -EPERM;
-#endif
-
-	bp->state = BNX2X_STATE_OPENING_WAIT4_LOAD;
-
-	rc = bnx2x_set_num_queues(bp);
-
-	if (bnx2x_alloc_mem(bp)) {
-		bnx2x_free_irq(bp, true);
-		return -ENOMEM;
-	}
-
-	for_each_queue(bp, i)
-		bnx2x_fp(bp, i, disable_tpa) =
-					((bp->flags & TPA_ENABLE_FLAG) == 0);
-
-	for_each_queue(bp, i)
-		netif_napi_add(bp->dev, &bnx2x_fp(bp, i, napi),
-			       bnx2x_poll, 128);
-
-	bnx2x_napi_enable(bp);
-
-	if (bp->flags & USING_MSIX_FLAG) {
-		rc = bnx2x_req_msix_irqs(bp);
-		if (rc) {
-			bnx2x_free_irq(bp, true);
-			goto load_error1;
-		}
-	} else {
-		/* Fall to INTx if failed to enable MSI-X due to lack of
-		   memory (in bnx2x_set_num_queues()) */
-		if ((rc != -ENOMEM) && (int_mode != INT_MODE_INTx))
-			bnx2x_enable_msi(bp);
-		bnx2x_ack_int(bp);
-		rc = bnx2x_req_irq(bp);
-		if (rc) {
-			BNX2X_ERR("IRQ request failed  rc %d, aborting\n", rc);
-			bnx2x_free_irq(bp, true);
-			goto load_error1;
-		}
-		if (bp->flags & USING_MSI_FLAG) {
-			bp->dev->irq = bp->pdev->irq;
-			netdev_info(bp->dev, "using MSI  IRQ %d\n",
-				    bp->pdev->irq);
-		}
-	}
-
-	/* Send LOAD_REQUEST command to MCP
-	   Returns the type of LOAD command:
-	   if it is the first port to be initialized
-	   common blocks should be initialized, otherwise - not
-	*/
-	if (!BP_NOMCP(bp)) {
-		load_code = bnx2x_fw_command(bp, DRV_MSG_CODE_LOAD_REQ);
-		if (!load_code) {
-			BNX2X_ERR("MCP response failure, aborting\n");
-			rc = -EBUSY;
-			goto load_error2;
-		}
-		if (load_code == FW_MSG_CODE_DRV_LOAD_REFUSED) {
-			rc = -EBUSY; /* other port in diagnostic mode */
-			goto load_error2;
-		}
-
-	} else {
-		int port = BP_PORT(bp);
-
-		DP(NETIF_MSG_IFUP, "NO MCP - load counts      %d, %d, %d\n",
-		   load_count[0], load_count[1], load_count[2]);
-		load_count[0]++;
-		load_count[1 + port]++;
-		DP(NETIF_MSG_IFUP, "NO MCP - new load counts  %d, %d, %d\n",
-		   load_count[0], load_count[1], load_count[2]);
-		if (load_count[0] == 1)
-			load_code = FW_MSG_CODE_DRV_LOAD_COMMON;
-		else if (load_count[1 + port] == 1)
-			load_code = FW_MSG_CODE_DRV_LOAD_PORT;
-		else
-			load_code = FW_MSG_CODE_DRV_LOAD_FUNCTION;
-	}
-
-	if ((load_code == FW_MSG_CODE_DRV_LOAD_COMMON) ||
-	    (load_code == FW_MSG_CODE_DRV_LOAD_PORT))
-		bp->port.pmf = 1;
-	else
-		bp->port.pmf = 0;
-	DP(NETIF_MSG_LINK, "pmf %d\n", bp->port.pmf);
-
-	/* Initialize HW */
-	rc = bnx2x_init_hw(bp, load_code);
-	if (rc) {
-		BNX2X_ERR("HW init failed, aborting\n");
-		bnx2x_fw_command(bp, DRV_MSG_CODE_LOAD_DONE);
-		bnx2x_fw_command(bp, DRV_MSG_CODE_UNLOAD_REQ_WOL_MCP);
-		bnx2x_fw_command(bp, DRV_MSG_CODE_UNLOAD_DONE);
-		goto load_error2;
-	}
-
-	/* Setup NIC internals and enable interrupts */
-	bnx2x_nic_init(bp, load_code);
-
-	if ((load_code == FW_MSG_CODE_DRV_LOAD_COMMON) &&
-	    (bp->common.shmem2_base))
-		SHMEM2_WR(bp, dcc_support,
-			  (SHMEM_DCC_SUPPORT_DISABLE_ENABLE_PF_TLV |
-			   SHMEM_DCC_SUPPORT_BANDWIDTH_ALLOCATION_TLV));
-
-	/* Send LOAD_DONE command to MCP */
-	if (!BP_NOMCP(bp)) {
-		load_code = bnx2x_fw_command(bp, DRV_MSG_CODE_LOAD_DONE);
-		if (!load_code) {
-			BNX2X_ERR("MCP response failure, aborting\n");
-			rc = -EBUSY;
-			goto load_error3;
-		}
-	}
-
-	bp->state = BNX2X_STATE_OPENING_WAIT4_PORT;
-
-	rc = bnx2x_setup_leading(bp);
-	if (rc) {
-		BNX2X_ERR("Setup leading failed!\n");
-#ifndef BNX2X_STOP_ON_ERROR
-		goto load_error3;
-#else
-		bp->panic = 1;
-		return -EBUSY;
-#endif
-	}
-
-	if (CHIP_IS_E1H(bp))
-		if (bp->mf_config & FUNC_MF_CFG_FUNC_DISABLED) {
-			DP(NETIF_MSG_IFUP, "mf_cfg function disabled\n");
-			bp->flags |= MF_FUNC_DIS;
-		}
-
-	if (bp->state == BNX2X_STATE_OPEN) {
-#ifdef BCM_CNIC
-		/* Enable Timer scan */
-		REG_WR(bp, TM_REG_EN_LINEAR0_TIMER + BP_PORT(bp)*4, 1);
-#endif
-		for_each_nondefault_queue(bp, i) {
-			rc = bnx2x_setup_multi(bp, i);
-			if (rc)
-#ifdef BCM_CNIC
-				goto load_error4;
-#else
-				goto load_error3;
-#endif
-		}
-
-		if (CHIP_IS_E1(bp))
-			bnx2x_set_eth_mac_addr_e1(bp, 1);
-		else
-			bnx2x_set_eth_mac_addr_e1h(bp, 1);
-#ifdef BCM_CNIC
-		/* Set iSCSI L2 MAC */
-		mutex_lock(&bp->cnic_mutex);
-		if (bp->cnic_eth_dev.drv_state & CNIC_DRV_STATE_REGD) {
-			bnx2x_set_iscsi_eth_mac_addr(bp, 1);
-			bp->cnic_flags |= BNX2X_CNIC_FLAG_MAC_SET;
-			bnx2x_init_sb(bp, bp->cnic_sb, bp->cnic_sb_mapping,
-				      CNIC_SB_ID(bp));
-		}
-		mutex_unlock(&bp->cnic_mutex);
-#endif
-	}
-
-	if (bp->port.pmf)
-		bnx2x_initial_phy_init(bp, load_mode);
-
-	/* Start fast path */
-	switch (load_mode) {
-	case LOAD_NORMAL:
-		if (bp->state == BNX2X_STATE_OPEN) {
-			/* Tx queue should be only reenabled */
-			netif_tx_wake_all_queues(bp->dev);
-		}
-		/* Initialize the receive filter. */
-		bnx2x_set_rx_mode(bp->dev);
-		break;
-
-	case LOAD_OPEN:
-		netif_tx_start_all_queues(bp->dev);
-		if (bp->state != BNX2X_STATE_OPEN)
-			netif_tx_disable(bp->dev);
-		/* Initialize the receive filter. */
-		bnx2x_set_rx_mode(bp->dev);
-		break;
-
-	case LOAD_DIAG:
-		/* Initialize the receive filter. */
-		bnx2x_set_rx_mode(bp->dev);
-		bp->state = BNX2X_STATE_DIAG;
-		break;
-
-	default:
-		break;
-	}
-
-	if (!bp->port.pmf)
-		bnx2x__link_status_update(bp);
-
-	/* start the timer */
-	mod_timer(&bp->timer, jiffies + bp->current_interval);
-
-#ifdef BCM_CNIC
-	bnx2x_setup_cnic_irq_info(bp);
-	if (bp->state == BNX2X_STATE_OPEN)
-		bnx2x_cnic_notify(bp, CNIC_CTL_START_CMD);
-#endif
-
-	return 0;
-
-#ifdef BCM_CNIC
-load_error4:
-	/* Disable Timer scan */
-	REG_WR(bp, TM_REG_EN_LINEAR0_TIMER + BP_PORT(bp)*4, 0);
-#endif
-load_error3:
-	bnx2x_int_disable_sync(bp, 1);
-	if (!BP_NOMCP(bp)) {
-		bnx2x_fw_command(bp, DRV_MSG_CODE_UNLOAD_REQ_WOL_MCP);
-		bnx2x_fw_command(bp, DRV_MSG_CODE_UNLOAD_DONE);
-	}
-	bp->port.pmf = 0;
-	/* Free SKBs, SGEs, TPA pool and driver internals */
-	bnx2x_free_skbs(bp);
-	for_each_queue(bp, i)
-		bnx2x_free_rx_sge_range(bp, bp->fp + i, NUM_RX_SGE);
-load_error2:
-	/* Release IRQs */
-	bnx2x_free_irq(bp, false);
-load_error1:
-	bnx2x_napi_disable(bp);
-	for_each_queue(bp, i)
-		netif_napi_del(&bnx2x_fp(bp, i, napi));
-	bnx2x_free_mem(bp);
-
-	return rc;
-}
-
-static int bnx2x_stop_multi(struct bnx2x *bp, int index)
-{
-	struct bnx2x_fastpath *fp = &bp->fp[index];
-	int rc;
-
-	/* halt the connection */
-	fp->state = BNX2X_FP_STATE_HALTING;
-	bnx2x_sp_post(bp, RAMROD_CMD_ID_ETH_HALT, index, 0, fp->cl_id, 0);
-
-	/* Wait for completion */
-	rc = bnx2x_wait_ramrod(bp, BNX2X_FP_STATE_HALTED, index,
-			       &(fp->state), 1);
-	if (rc) /* timeout */
-		return rc;
-
-	/* delete cfc entry */
-	bnx2x_sp_post(bp, RAMROD_CMD_ID_ETH_CFC_DEL, index, 0, 0, 1);
-
-	/* Wait for completion */
-	rc = bnx2x_wait_ramrod(bp, BNX2X_FP_STATE_CLOSED, index,
-			       &(fp->state), 1);
-	return rc;
-}
-
-static int bnx2x_stop_leading(struct bnx2x *bp)
-{
-	__le16 dsb_sp_prod_idx;
-	/* if the other port is handling traffic,
-	   this can take a lot of time */
-	int cnt = 500;
-	int rc;
-
-	might_sleep();
-
-	/* Send HALT ramrod */
-	bp->fp[0].state = BNX2X_FP_STATE_HALTING;
-	bnx2x_sp_post(bp, RAMROD_CMD_ID_ETH_HALT, 0, 0, bp->fp->cl_id, 0);
-
-	/* Wait for completion */
-	rc = bnx2x_wait_ramrod(bp, BNX2X_FP_STATE_HALTED, 0,
-			       &(bp->fp[0].state), 1);
-	if (rc) /* timeout */
-		return rc;
-
-	dsb_sp_prod_idx = *bp->dsb_sp_prod;
-
-	/* Send PORT_DELETE ramrod */
-	bnx2x_sp_post(bp, RAMROD_CMD_ID_ETH_PORT_DEL, 0, 0, 0, 1);
-
-	/* Wait for completion to arrive on default status block
-	   we are going to reset the chip anyway
-	   so there is not much to do if this times out
-	 */
-	while (dsb_sp_prod_idx == *bp->dsb_sp_prod) {
-		if (!cnt) {
-			DP(NETIF_MSG_IFDOWN, "timeout waiting for port del "
-			   "dsb_sp_prod 0x%x != dsb_sp_prod_idx 0x%x\n",
-			   *bp->dsb_sp_prod, dsb_sp_prod_idx);
-#ifdef BNX2X_STOP_ON_ERROR
-			bnx2x_panic();
-#endif
-			rc = -EBUSY;
-			break;
-		}
-		cnt--;
-		msleep(1);
-		rmb(); /* Refresh the dsb_sp_prod */
-	}
-	bp->state = BNX2X_STATE_CLOSING_WAIT4_UNLOAD;
-	bp->fp[0].state = BNX2X_FP_STATE_CLOSED;
-
-	return rc;
-}
-
-static void bnx2x_reset_func(struct bnx2x *bp)
-{
-	int port = BP_PORT(bp);
-	int func = BP_FUNC(bp);
-	int base, i;
-
-	/* Configure IGU */
-	REG_WR(bp, HC_REG_LEADING_EDGE_0 + port*8, 0);
-	REG_WR(bp, HC_REG_TRAILING_EDGE_0 + port*8, 0);
-
-#ifdef BCM_CNIC
-	/* Disable Timer scan */
-	REG_WR(bp, TM_REG_EN_LINEAR0_TIMER + port*4, 0);
-	/*
-	 * Wait for at least 10ms and up to 2 second for the timers scan to
-	 * complete
-	 */
-	for (i = 0; i < 200; i++) {
-		msleep(10);
-		if (!REG_RD(bp, TM_REG_LIN0_SCAN_ON + port*4))
-			break;
-	}
-#endif
-	/* Clear ILT */
-	base = FUNC_ILT_BASE(func);
-	for (i = base; i < base + ILT_PER_FUNC; i++)
-		bnx2x_ilt_wr(bp, i, 0);
-}
-
-static void bnx2x_reset_port(struct bnx2x *bp)
-{
-	int port = BP_PORT(bp);
-	u32 val;
-
-	REG_WR(bp, NIG_REG_MASK_INTERRUPT_PORT0 + port*4, 0);
-
-	/* Do not rcv packets to BRB */
-	REG_WR(bp, NIG_REG_LLH0_BRB1_DRV_MASK + port*4, 0x0);
-	/* Do not direct rcv packets that are not for MCP to the BRB */
-	REG_WR(bp, (port ? NIG_REG_LLH1_BRB1_NOT_MCP :
-			   NIG_REG_LLH0_BRB1_NOT_MCP), 0x0);
-
-	/* Configure AEU */
-	REG_WR(bp, MISC_REG_AEU_MASK_ATTN_FUNC_0 + port*4, 0);
-
-	msleep(100);
-	/* Check for BRB port occupancy */
-	val = REG_RD(bp, BRB1_REG_PORT_NUM_OCC_BLOCKS_0 + port*4);
-	if (val)
-		DP(NETIF_MSG_IFDOWN,
-		   "BRB1 is not empty  %d blocks are occupied\n", val);
-
-	/* TODO: Close Doorbell port? */
-}
-
-static void bnx2x_reset_chip(struct bnx2x *bp, u32 reset_code)
-{
-	DP(BNX2X_MSG_MCP, "function %d  reset_code %x\n",
-	   BP_FUNC(bp), reset_code);
-
-	switch (reset_code) {
-	case FW_MSG_CODE_DRV_UNLOAD_COMMON:
-		bnx2x_reset_port(bp);
-		bnx2x_reset_func(bp);
-		bnx2x_reset_common(bp);
-		break;
-
-	case FW_MSG_CODE_DRV_UNLOAD_PORT:
-		bnx2x_reset_port(bp);
-		bnx2x_reset_func(bp);
-		break;
-
-	case FW_MSG_CODE_DRV_UNLOAD_FUNCTION:
-		bnx2x_reset_func(bp);
-		break;
-
-	default:
-		BNX2X_ERR("Unknown reset_code (0x%x) from MCP\n", reset_code);
-		break;
-	}
-}
-
-/* must be called with rtnl_lock */
-static int bnx2x_nic_unload(struct bnx2x *bp, int unload_mode)
-{
-	int port = BP_PORT(bp);
-	u32 reset_code = 0;
-	int i, cnt, rc;
-
-#ifdef BCM_CNIC
-	bnx2x_cnic_notify(bp, CNIC_CTL_STOP_CMD);
-#endif
-	bp->state = BNX2X_STATE_CLOSING_WAIT4_HALT;
-
-	/* Set "drop all" */
-	bp->rx_mode = BNX2X_RX_MODE_NONE;
-	bnx2x_set_storm_rx_mode(bp);
-
-	/* Disable HW interrupts, NAPI and Tx */
-	bnx2x_netif_stop(bp, 1);
-
-	del_timer_sync(&bp->timer);
-	SHMEM_WR(bp, func_mb[BP_FUNC(bp)].drv_pulse_mb,
-		 (DRV_PULSE_ALWAYS_ALIVE | bp->fw_drv_pulse_wr_seq));
-	bnx2x_stats_handle(bp, STATS_EVENT_STOP);
-
-	/* Release IRQs */
-	bnx2x_free_irq(bp, false);
-
-	/* Wait until tx fastpath tasks complete */
-	for_each_queue(bp, i) {
-		struct bnx2x_fastpath *fp = &bp->fp[i];
-
-		cnt = 1000;
-		while (bnx2x_has_tx_work_unload(fp)) {
-
-			bnx2x_tx_int(fp);
-			if (!cnt) {
-				BNX2X_ERR("timeout waiting for queue[%d]\n",
-					  i);
-#ifdef BNX2X_STOP_ON_ERROR
-				bnx2x_panic();
-				return -EBUSY;
-#else
-				break;
-#endif
-			}
-			cnt--;
-			msleep(1);
-		}
-	}
-	/* Give HW time to discard old tx messages */
-	msleep(1);
-
-	if (CHIP_IS_E1(bp)) {
-		struct mac_configuration_cmd *config =
-						bnx2x_sp(bp, mcast_config);
-
-		bnx2x_set_eth_mac_addr_e1(bp, 0);
-
-		for (i = 0; i < config->hdr.length; i++)
-			CAM_INVALIDATE(config->config_table[i]);
-
-		config->hdr.length = i;
-		if (CHIP_REV_IS_SLOW(bp))
-			config->hdr.offset = BNX2X_MAX_EMUL_MULTI*(1 + port);
-		else
-			config->hdr.offset = BNX2X_MAX_MULTICAST*(1 + port);
-		config->hdr.client_id = bp->fp->cl_id;
-		config->hdr.reserved1 = 0;
-
-		bp->set_mac_pending++;
-		smp_wmb();
-
-		bnx2x_sp_post(bp, RAMROD_CMD_ID_ETH_SET_MAC, 0,
-			      U64_HI(bnx2x_sp_mapping(bp, mcast_config)),
-			      U64_LO(bnx2x_sp_mapping(bp, mcast_config)), 0);
-
-	} else { /* E1H */
-		REG_WR(bp, NIG_REG_LLH0_FUNC_EN + port*8, 0);
-
-		bnx2x_set_eth_mac_addr_e1h(bp, 0);
-
-		for (i = 0; i < MC_HASH_SIZE; i++)
-			REG_WR(bp, MC_HASH_OFFSET(bp, i), 0);
-
-		REG_WR(bp, MISC_REG_E1HMF_MODE, 0);
-	}
-#ifdef BCM_CNIC
-	/* Clear iSCSI L2 MAC */
-	mutex_lock(&bp->cnic_mutex);
-	if (bp->cnic_flags & BNX2X_CNIC_FLAG_MAC_SET) {
-		bnx2x_set_iscsi_eth_mac_addr(bp, 0);
-		bp->cnic_flags &= ~BNX2X_CNIC_FLAG_MAC_SET;
-	}
-	mutex_unlock(&bp->cnic_mutex);
-#endif
-
-	if (unload_mode == UNLOAD_NORMAL)
-		reset_code = DRV_MSG_CODE_UNLOAD_REQ_WOL_DIS;
-
-	else if (bp->flags & NO_WOL_FLAG)
-		reset_code = DRV_MSG_CODE_UNLOAD_REQ_WOL_MCP;
-
-	else if (bp->wol) {
-		u32 emac_base = port ? GRCBASE_EMAC1 : GRCBASE_EMAC0;
-		u8 *mac_addr = bp->dev->dev_addr;
-		u32 val;
-		/* The mac address is written to entries 1-4 to
-		   preserve entry 0 which is used by the PMF */
-		u8 entry = (BP_E1HVN(bp) + 1)*8;
-
-		val = (mac_addr[0] << 8) | mac_addr[1];
-		EMAC_WR(bp, EMAC_REG_EMAC_MAC_MATCH + entry, val);
-
-		val = (mac_addr[2] << 24) | (mac_addr[3] << 16) |
-		      (mac_addr[4] << 8) | mac_addr[5];
-		EMAC_WR(bp, EMAC_REG_EMAC_MAC_MATCH + entry + 4, val);
-
-		reset_code = DRV_MSG_CODE_UNLOAD_REQ_WOL_EN;
-
-	} else
-		reset_code = DRV_MSG_CODE_UNLOAD_REQ_WOL_DIS;
-
-	/* Close multi and leading connections
-	   Completions for ramrods are collected in a synchronous way */
-	for_each_nondefault_queue(bp, i)
-		if (bnx2x_stop_multi(bp, i))
-			goto unload_error;
-
-	rc = bnx2x_stop_leading(bp);
-	if (rc) {
-		BNX2X_ERR("Stop leading failed!\n");
-#ifdef BNX2X_STOP_ON_ERROR
-		return -EBUSY;
-#else
-		goto unload_error;
-#endif
-	}
-
-unload_error:
-	if (!BP_NOMCP(bp))
-		reset_code = bnx2x_fw_command(bp, reset_code);
-	else {
-		DP(NETIF_MSG_IFDOWN, "NO MCP - load counts      %d, %d, %d\n",
-		   load_count[0], load_count[1], load_count[2]);
-		load_count[0]--;
-		load_count[1 + port]--;
-		DP(NETIF_MSG_IFDOWN, "NO MCP - new load counts  %d, %d, %d\n",
-		   load_count[0], load_count[1], load_count[2]);
-		if (load_count[0] == 0)
-			reset_code = FW_MSG_CODE_DRV_UNLOAD_COMMON;
-		else if (load_count[1 + port] == 0)
-			reset_code = FW_MSG_CODE_DRV_UNLOAD_PORT;
-		else
-			reset_code = FW_MSG_CODE_DRV_UNLOAD_FUNCTION;
-	}
-
-	if ((reset_code == FW_MSG_CODE_DRV_UNLOAD_COMMON) ||
-	    (reset_code == FW_MSG_CODE_DRV_UNLOAD_PORT))
-		bnx2x__link_reset(bp);
-
-	/* Reset the chip */
-	bnx2x_reset_chip(bp, reset_code);
-
-	/* Report UNLOAD_DONE to MCP */
-	if (!BP_NOMCP(bp))
-		bnx2x_fw_command(bp, DRV_MSG_CODE_UNLOAD_DONE);
-
-	bp->port.pmf = 0;
-
-	/* Free SKBs, SGEs, TPA pool and driver internals */
-	bnx2x_free_skbs(bp);
-	for_each_queue(bp, i)
-		bnx2x_free_rx_sge_range(bp, bp->fp + i, NUM_RX_SGE);
-	for_each_queue(bp, i)
-		netif_napi_del(&bnx2x_fp(bp, i, napi));
-	bnx2x_free_mem(bp);
-
-	bp->state = BNX2X_STATE_CLOSED;
-
-	netif_carrier_off(bp->dev);
-
-	return 0;
-}
-
-static void bnx2x_reset_task(struct work_struct *work)
-{
-	struct bnx2x *bp = container_of(work, struct bnx2x, reset_task);
-
-#ifdef BNX2X_STOP_ON_ERROR
-	BNX2X_ERR("reset task called but STOP_ON_ERROR defined"
-		  " so reset not done to allow debug dump,\n"
-		  " you will need to reboot when done\n");
-	return;
-#endif
-
-	rtnl_lock();
-
-	if (!netif_running(bp->dev))
-		goto reset_task_exit;
-
-	bnx2x_nic_unload(bp, UNLOAD_NORMAL);
-	bnx2x_nic_load(bp, LOAD_NORMAL);
-
-reset_task_exit:
-	rtnl_unlock();
-}
-
-/* end of nic load/unload */
-
-/* ethtool_ops */
-
-/*
- * Init service functions
- */
-
-static inline u32 bnx2x_get_pretend_reg(struct bnx2x *bp, int func)
-{
-	switch (func) {
-	case 0: return PXP2_REG_PGL_PRETEND_FUNC_F0;
-	case 1:	return PXP2_REG_PGL_PRETEND_FUNC_F1;
-	case 2:	return PXP2_REG_PGL_PRETEND_FUNC_F2;
-	case 3:	return PXP2_REG_PGL_PRETEND_FUNC_F3;
-	case 4:	return PXP2_REG_PGL_PRETEND_FUNC_F4;
-	case 5:	return PXP2_REG_PGL_PRETEND_FUNC_F5;
-	case 6:	return PXP2_REG_PGL_PRETEND_FUNC_F6;
-	case 7:	return PXP2_REG_PGL_PRETEND_FUNC_F7;
-	default:
-		BNX2X_ERR("Unsupported function index: %d\n", func);
-		return (u32)(-1);
-	}
-}
-
-static void bnx2x_undi_int_disable_e1h(struct bnx2x *bp, int orig_func)
-{
-	u32 reg = bnx2x_get_pretend_reg(bp, orig_func), new_val;
-
-	/* Flush all outstanding writes */
-	mmiowb();
-
-	/* Pretend to be function 0 */
-	REG_WR(bp, reg, 0);
-	/* Flush the GRC transaction (in the chip) */
-	new_val = REG_RD(bp, reg);
-	if (new_val != 0) {
-		BNX2X_ERR("Hmmm... Pretend register wasn't updated: (0,%d)!\n",
-			  new_val);
-		BUG();
-	}
-
-	/* From now we are in the "like-E1" mode */
-	bnx2x_int_disable(bp);
-
-	/* Flush all outstanding writes */
-	mmiowb();
-
-	/* Restore the original funtion settings */
-	REG_WR(bp, reg, orig_func);
-	new_val = REG_RD(bp, reg);
-	if (new_val != orig_func) {
-		BNX2X_ERR("Hmmm... Pretend register wasn't updated: (%d,%d)!\n",
-			  orig_func, new_val);
-		BUG();
-	}
-}
-
-static inline void bnx2x_undi_int_disable(struct bnx2x *bp, int func)
-{
-	if (CHIP_IS_E1H(bp))
-		bnx2x_undi_int_disable_e1h(bp, func);
-	else
-		bnx2x_int_disable(bp);
-}
-
-static void __devinit bnx2x_undi_unload(struct bnx2x *bp)
-{
-	u32 val;
-
-	/* Check if there is any driver already loaded */
-	val = REG_RD(bp, MISC_REG_UNPREPARED);
-	if (val == 0x1) {
-		/* Check if it is the UNDI driver
-		 * UNDI driver initializes CID offset for normal bell to 0x7
-		 */
-		bnx2x_acquire_hw_lock(bp, HW_LOCK_RESOURCE_UNDI);
-		val = REG_RD(bp, DORQ_REG_NORM_CID_OFST);
-		if (val == 0x7) {
-			u32 reset_code = DRV_MSG_CODE_UNLOAD_REQ_WOL_DIS;
-			/* save our func */
-			int func = BP_FUNC(bp);
-			u32 swap_en;
-			u32 swap_val;
-
-			/* clear the UNDI indication */
-			REG_WR(bp, DORQ_REG_NORM_CID_OFST, 0);
-
-			BNX2X_DEV_INFO("UNDI is active! reset device\n");
-
-			/* try unload UNDI on port 0 */
-			bp->func = 0;
-			bp->fw_seq =
-			       (SHMEM_RD(bp, func_mb[bp->func].drv_mb_header) &
-				DRV_MSG_SEQ_NUMBER_MASK);
-			reset_code = bnx2x_fw_command(bp, reset_code);
-
-			/* if UNDI is loaded on the other port */
-			if (reset_code != FW_MSG_CODE_DRV_UNLOAD_COMMON) {
-
-				/* send "DONE" for previous unload */
-				bnx2x_fw_command(bp, DRV_MSG_CODE_UNLOAD_DONE);
-
-				/* unload UNDI on port 1 */
-				bp->func = 1;
-				bp->fw_seq =
-			       (SHMEM_RD(bp, func_mb[bp->func].drv_mb_header) &
-					DRV_MSG_SEQ_NUMBER_MASK);
-				reset_code = DRV_MSG_CODE_UNLOAD_REQ_WOL_DIS;
-
-				bnx2x_fw_command(bp, reset_code);
-			}
-
-			/* now it's safe to release the lock */
-			bnx2x_release_hw_lock(bp, HW_LOCK_RESOURCE_UNDI);
-
-			bnx2x_undi_int_disable(bp, func);
-
-			/* close input traffic and wait for it */
-			/* Do not rcv packets to BRB */
-			REG_WR(bp,
-			      (BP_PORT(bp) ? NIG_REG_LLH1_BRB1_DRV_MASK :
-					     NIG_REG_LLH0_BRB1_DRV_MASK), 0x0);
-			/* Do not direct rcv packets that are not for MCP to
-			 * the BRB */
-			REG_WR(bp,
-			       (BP_PORT(bp) ? NIG_REG_LLH1_BRB1_NOT_MCP :
-					      NIG_REG_LLH0_BRB1_NOT_MCP), 0x0);
-			/* clear AEU */
-			REG_WR(bp,
-			     (BP_PORT(bp) ? MISC_REG_AEU_MASK_ATTN_FUNC_1 :
-					    MISC_REG_AEU_MASK_ATTN_FUNC_0), 0);
-			msleep(10);
-
-			/* save NIG port swap info */
-			swap_val = REG_RD(bp, NIG_REG_PORT_SWAP);
-			swap_en = REG_RD(bp, NIG_REG_STRAP_OVERRIDE);
-			/* reset device */
-			REG_WR(bp,
-			       GRCBASE_MISC + MISC_REGISTERS_RESET_REG_1_CLEAR,
-			       0xd3ffffff);
-			REG_WR(bp,
-			       GRCBASE_MISC + MISC_REGISTERS_RESET_REG_2_CLEAR,
-			       0x1403);
-			/* take the NIG out of reset and restore swap values */
-			REG_WR(bp,
-			       GRCBASE_MISC + MISC_REGISTERS_RESET_REG_1_SET,
-			       MISC_REGISTERS_RESET_REG_1_RST_NIG);
-			REG_WR(bp, NIG_REG_PORT_SWAP, swap_val);
-			REG_WR(bp, NIG_REG_STRAP_OVERRIDE, swap_en);
-
-			/* send unload done to the MCP */
-			bnx2x_fw_command(bp, DRV_MSG_CODE_UNLOAD_DONE);
-
-			/* restore our func and fw_seq */
-			bp->func = func;
-			bp->fw_seq =
-			       (SHMEM_RD(bp, func_mb[bp->func].drv_mb_header) &
-				DRV_MSG_SEQ_NUMBER_MASK);
-
-		} else
-			bnx2x_release_hw_lock(bp, HW_LOCK_RESOURCE_UNDI);
-	}
-}
-
-static void __devinit bnx2x_get_common_hwinfo(struct bnx2x *bp)
-{
-	u32 val, val2, val3, val4, id;
-	u16 pmc;
-
-	/* Get the chip revision id and number. */
-	/* chip num:16-31, rev:12-15, metal:4-11, bond_id:0-3 */
-	val = REG_RD(bp, MISC_REG_CHIP_NUM);
-	id = ((val & 0xffff) << 16);
-	val = REG_RD(bp, MISC_REG_CHIP_REV);
-	id |= ((val & 0xf) << 12);
-	val = REG_RD(bp, MISC_REG_CHIP_METAL);
-	id |= ((val & 0xff) << 4);
-	val = REG_RD(bp, MISC_REG_BOND_ID);
-	id |= (val & 0xf);
-	bp->common.chip_id = id;
-	bp->link_params.chip_id = bp->common.chip_id;
-	BNX2X_DEV_INFO("chip ID is 0x%x\n", id);
-
-	val = (REG_RD(bp, 0x2874) & 0x55);
-	if ((bp->common.chip_id & 0x1) ||
-	    (CHIP_IS_E1(bp) && val) || (CHIP_IS_E1H(bp) && (val == 0x55))) {
-		bp->flags |= ONE_PORT_FLAG;
-		BNX2X_DEV_INFO("single port device\n");
-	}
-
-	val = REG_RD(bp, MCP_REG_MCPR_NVM_CFG4);
-	bp->common.flash_size = (NVRAM_1MB_SIZE <<
-				 (val & MCPR_NVM_CFG4_FLASH_SIZE));
-	BNX2X_DEV_INFO("flash_size 0x%x (%d)\n",
-		       bp->common.flash_size, bp->common.flash_size);
-
-	bp->common.shmem_base = REG_RD(bp, MISC_REG_SHARED_MEM_ADDR);
-	bp->common.shmem2_base = REG_RD(bp, MISC_REG_GENERIC_CR_0);
-	bp->link_params.shmem_base = bp->common.shmem_base;
-	BNX2X_DEV_INFO("shmem offset 0x%x  shmem2 offset 0x%x\n",
-		       bp->common.shmem_base, bp->common.shmem2_base);
-
-	if (!bp->common.shmem_base ||
-	    (bp->common.shmem_base < 0xA0000) ||
-	    (bp->common.shmem_base >= 0xC0000)) {
-		BNX2X_DEV_INFO("MCP not active\n");
-		bp->flags |= NO_MCP_FLAG;
-		return;
-	}
-
-	val = SHMEM_RD(bp, validity_map[BP_PORT(bp)]);
-	if ((val & (SHR_MEM_VALIDITY_DEV_INFO | SHR_MEM_VALIDITY_MB))
-		!= (SHR_MEM_VALIDITY_DEV_INFO | SHR_MEM_VALIDITY_MB))
-		BNX2X_ERR("BAD MCP validity signature\n");
-
-	bp->common.hw_config = SHMEM_RD(bp, dev_info.shared_hw_config.config);
-	BNX2X_DEV_INFO("hw_config 0x%08x\n", bp->common.hw_config);
-
-	bp->link_params.hw_led_mode = ((bp->common.hw_config &
-					SHARED_HW_CFG_LED_MODE_MASK) >>
-				       SHARED_HW_CFG_LED_MODE_SHIFT);
-
-	bp->link_params.feature_config_flags = 0;
-	val = SHMEM_RD(bp, dev_info.shared_feature_config.config);
-	if (val & SHARED_FEAT_CFG_OVERRIDE_PREEMPHASIS_CFG_ENABLED)
-		bp->link_params.feature_config_flags |=
-				FEATURE_CONFIG_OVERRIDE_PREEMPHASIS_ENABLED;
-	else
-		bp->link_params.feature_config_flags &=
-				~FEATURE_CONFIG_OVERRIDE_PREEMPHASIS_ENABLED;
-
-	val = SHMEM_RD(bp, dev_info.bc_rev) >> 8;
-	bp->common.bc_ver = val;
-	BNX2X_DEV_INFO("bc_ver %X\n", val);
-	if (val < BNX2X_BC_VER) {
-		/* for now only warn
-		 * later we might need to enforce this */
-		BNX2X_ERR("This driver needs bc_ver %X but found %X,"
-			  " please upgrade BC\n", BNX2X_BC_VER, val);
-	}
-	bp->link_params.feature_config_flags |=
-		(val >= REQ_BC_VER_4_VRFY_OPT_MDL) ?
-		FEATURE_CONFIG_BC_SUPPORTS_OPT_MDL_VRFY : 0;
-
-	if (BP_E1HVN(bp) == 0) {
-		pci_read_config_word(bp->pdev, bp->pm_cap + PCI_PM_PMC, &pmc);
-		bp->flags |= (pmc & PCI_PM_CAP_PME_D3cold) ? 0 : NO_WOL_FLAG;
-	} else {
-		/* no WOL capability for E1HVN != 0 */
-		bp->flags |= NO_WOL_FLAG;
-	}
-	BNX2X_DEV_INFO("%sWoL capable\n",
-		       (bp->flags & NO_WOL_FLAG) ? "not " : "");
-
-	val = SHMEM_RD(bp, dev_info.shared_hw_config.part_num);
-	val2 = SHMEM_RD(bp, dev_info.shared_hw_config.part_num[4]);
-	val3 = SHMEM_RD(bp, dev_info.shared_hw_config.part_num[8]);
-	val4 = SHMEM_RD(bp, dev_info.shared_hw_config.part_num[12]);
-
-	pr_info("part number %X-%X-%X-%X\n", val, val2, val3, val4);
-}
-
-static void __devinit bnx2x_link_settings_supported(struct bnx2x *bp,
-						    u32 switch_cfg)
-{
-	int port = BP_PORT(bp);
-	u32 ext_phy_type;
-
-	switch (switch_cfg) {
-	case SWITCH_CFG_1G:
-		BNX2X_DEV_INFO("switch_cfg 0x%x (1G)\n", switch_cfg);
-
-		ext_phy_type =
-			SERDES_EXT_PHY_TYPE(bp->link_params.ext_phy_config);
-		switch (ext_phy_type) {
-		case PORT_HW_CFG_SERDES_EXT_PHY_TYPE_DIRECT:
-			BNX2X_DEV_INFO("ext_phy_type 0x%x (Direct)\n",
-				       ext_phy_type);
-
-			bp->port.supported |= (SUPPORTED_10baseT_Half |
-					       SUPPORTED_10baseT_Full |
-					       SUPPORTED_100baseT_Half |
-					       SUPPORTED_100baseT_Full |
-					       SUPPORTED_1000baseT_Full |
-					       SUPPORTED_2500baseX_Full |
-					       SUPPORTED_TP |
-					       SUPPORTED_FIBRE |
-					       SUPPORTED_Autoneg |
-					       SUPPORTED_Pause |
-					       SUPPORTED_Asym_Pause);
-			break;
-
-		case PORT_HW_CFG_SERDES_EXT_PHY_TYPE_BCM5482:
-			BNX2X_DEV_INFO("ext_phy_type 0x%x (5482)\n",
-				       ext_phy_type);
-
-			bp->port.supported |= (SUPPORTED_10baseT_Half |
-					       SUPPORTED_10baseT_Full |
-					       SUPPORTED_100baseT_Half |
-					       SUPPORTED_100baseT_Full |
-					       SUPPORTED_1000baseT_Full |
-					       SUPPORTED_TP |
-					       SUPPORTED_FIBRE |
-					       SUPPORTED_Autoneg |
-					       SUPPORTED_Pause |
-					       SUPPORTED_Asym_Pause);
-			break;
-
-		default:
-			BNX2X_ERR("NVRAM config error. "
-				  "BAD SerDes ext_phy_config 0x%x\n",
-				  bp->link_params.ext_phy_config);
-			return;
-		}
-
-		bp->port.phy_addr = REG_RD(bp, NIG_REG_SERDES0_CTRL_PHY_ADDR +
-					   port*0x10);
-		BNX2X_DEV_INFO("phy_addr 0x%x\n", bp->port.phy_addr);
-		break;
-
-	case SWITCH_CFG_10G:
-		BNX2X_DEV_INFO("switch_cfg 0x%x (10G)\n", switch_cfg);
-
-		ext_phy_type =
-			XGXS_EXT_PHY_TYPE(bp->link_params.ext_phy_config);
-		switch (ext_phy_type) {
-		case PORT_HW_CFG_XGXS_EXT_PHY_TYPE_DIRECT:
-			BNX2X_DEV_INFO("ext_phy_type 0x%x (Direct)\n",
-				       ext_phy_type);
-
-			bp->port.supported |= (SUPPORTED_10baseT_Half |
-					       SUPPORTED_10baseT_Full |
-					       SUPPORTED_100baseT_Half |
-					       SUPPORTED_100baseT_Full |
-					       SUPPORTED_1000baseT_Full |
-					       SUPPORTED_2500baseX_Full |
-					       SUPPORTED_10000baseT_Full |
-					       SUPPORTED_TP |
-					       SUPPORTED_FIBRE |
-					       SUPPORTED_Autoneg |
-					       SUPPORTED_Pause |
-					       SUPPORTED_Asym_Pause);
-			break;
-
-		case PORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM8072:
-			BNX2X_DEV_INFO("ext_phy_type 0x%x (8072)\n",
-				       ext_phy_type);
-
-			bp->port.supported |= (SUPPORTED_10000baseT_Full |
-					       SUPPORTED_1000baseT_Full |
-					       SUPPORTED_FIBRE |
-					       SUPPORTED_Autoneg |
-					       SUPPORTED_Pause |
-					       SUPPORTED_Asym_Pause);
-			break;
-
-		case PORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM8073:
-			BNX2X_DEV_INFO("ext_phy_type 0x%x (8073)\n",
-				       ext_phy_type);
-
-			bp->port.supported |= (SUPPORTED_10000baseT_Full |
-					       SUPPORTED_2500baseX_Full |
-					       SUPPORTED_1000baseT_Full |
-					       SUPPORTED_FIBRE |
-					       SUPPORTED_Autoneg |
-					       SUPPORTED_Pause |
-					       SUPPORTED_Asym_Pause);
-			break;
-
-		case PORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM8705:
-			BNX2X_DEV_INFO("ext_phy_type 0x%x (8705)\n",
-				       ext_phy_type);
-
-			bp->port.supported |= (SUPPORTED_10000baseT_Full |
-					       SUPPORTED_FIBRE |
-					       SUPPORTED_Pause |
-					       SUPPORTED_Asym_Pause);
-			break;
-
-		case PORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM8706:
-			BNX2X_DEV_INFO("ext_phy_type 0x%x (8706)\n",
-				       ext_phy_type);
-
-			bp->port.supported |= (SUPPORTED_10000baseT_Full |
-					       SUPPORTED_1000baseT_Full |
-					       SUPPORTED_FIBRE |
-					       SUPPORTED_Pause |
-					       SUPPORTED_Asym_Pause);
-			break;
-
-		case PORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM8726:
-			BNX2X_DEV_INFO("ext_phy_type 0x%x (8726)\n",
-				       ext_phy_type);
-
-			bp->port.supported |= (SUPPORTED_10000baseT_Full |
-					       SUPPORTED_1000baseT_Full |
-					       SUPPORTED_Autoneg |
-					       SUPPORTED_FIBRE |
-					       SUPPORTED_Pause |
-					       SUPPORTED_Asym_Pause);
-			break;
-
-		case PORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM8727:
-			BNX2X_DEV_INFO("ext_phy_type 0x%x (8727)\n",
-				       ext_phy_type);
-
-			bp->port.supported |= (SUPPORTED_10000baseT_Full |
-					       SUPPORTED_1000baseT_Full |
-					       SUPPORTED_Autoneg |
-					       SUPPORTED_FIBRE |
-					       SUPPORTED_Pause |
-					       SUPPORTED_Asym_Pause);
-			break;
-
-		case PORT_HW_CFG_XGXS_EXT_PHY_TYPE_SFX7101:
-			BNX2X_DEV_INFO("ext_phy_type 0x%x (SFX7101)\n",
-				       ext_phy_type);
-
-			bp->port.supported |= (SUPPORTED_10000baseT_Full |
-					       SUPPORTED_TP |
-					       SUPPORTED_Autoneg |
-					       SUPPORTED_Pause |
-					       SUPPORTED_Asym_Pause);
-			break;
-
-		case PORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM8481:
-			BNX2X_DEV_INFO("ext_phy_type 0x%x (BCM8481)\n",
-				       ext_phy_type);
-
-			bp->port.supported |= (SUPPORTED_10baseT_Half |
-					       SUPPORTED_10baseT_Full |
-					       SUPPORTED_100baseT_Half |
-					       SUPPORTED_100baseT_Full |
-					       SUPPORTED_1000baseT_Full |
-					       SUPPORTED_10000baseT_Full |
-					       SUPPORTED_TP |
-					       SUPPORTED_Autoneg |
-					       SUPPORTED_Pause |
-					       SUPPORTED_Asym_Pause);
-			break;
-
-		case PORT_HW_CFG_XGXS_EXT_PHY_TYPE_FAILURE:
-			BNX2X_ERR("XGXS PHY Failure detected 0x%x\n",
-				  bp->link_params.ext_phy_config);
-			break;
-
-		default:
-			BNX2X_ERR("NVRAM config error. "
-				  "BAD XGXS ext_phy_config 0x%x\n",
-				  bp->link_params.ext_phy_config);
-			return;
-		}
-
-		bp->port.phy_addr = REG_RD(bp, NIG_REG_XGXS0_CTRL_PHY_ADDR +
-					   port*0x18);
-		BNX2X_DEV_INFO("phy_addr 0x%x\n", bp->port.phy_addr);
-
-		break;
-
-	default:
-		BNX2X_ERR("BAD switch_cfg link_config 0x%x\n",
-			  bp->port.link_config);
-		return;
-	}
-	bp->link_params.phy_addr = bp->port.phy_addr;
-
-	/* mask what we support according to speed_cap_mask */
-	if (!(bp->link_params.speed_cap_mask &
-				PORT_HW_CFG_SPEED_CAPABILITY_D0_10M_HALF))
-		bp->port.supported &= ~SUPPORTED_10baseT_Half;
-
-	if (!(bp->link_params.speed_cap_mask &
-				PORT_HW_CFG_SPEED_CAPABILITY_D0_10M_FULL))
-		bp->port.supported &= ~SUPPORTED_10baseT_Full;
-
-	if (!(bp->link_params.speed_cap_mask &
-				PORT_HW_CFG_SPEED_CAPABILITY_D0_100M_HALF))
-		bp->port.supported &= ~SUPPORTED_100baseT_Half;
-
-	if (!(bp->link_params.speed_cap_mask &
-				PORT_HW_CFG_SPEED_CAPABILITY_D0_100M_FULL))
-		bp->port.supported &= ~SUPPORTED_100baseT_Full;
-
-	if (!(bp->link_params.speed_cap_mask &
-					PORT_HW_CFG_SPEED_CAPABILITY_D0_1G))
-		bp->port.supported &= ~(SUPPORTED_1000baseT_Half |
-					SUPPORTED_1000baseT_Full);
-
-	if (!(bp->link_params.speed_cap_mask &
-					PORT_HW_CFG_SPEED_CAPABILITY_D0_2_5G))
-		bp->port.supported &= ~SUPPORTED_2500baseX_Full;
-
-	if (!(bp->link_params.speed_cap_mask &
-					PORT_HW_CFG_SPEED_CAPABILITY_D0_10G))
-		bp->port.supported &= ~SUPPORTED_10000baseT_Full;
-
-	BNX2X_DEV_INFO("supported 0x%x\n", bp->port.supported);
-}
-
-static void __devinit bnx2x_link_settings_requested(struct bnx2x *bp)
-{
-	bp->link_params.req_duplex = DUPLEX_FULL;
-
-	switch (bp->port.link_config & PORT_FEATURE_LINK_SPEED_MASK) {
-	case PORT_FEATURE_LINK_SPEED_AUTO:
-		if (bp->port.supported & SUPPORTED_Autoneg) {
-			bp->link_params.req_line_speed = SPEED_AUTO_NEG;
-			bp->port.advertising = bp->port.supported;
-		} else {
-			u32 ext_phy_type =
-			    XGXS_EXT_PHY_TYPE(bp->link_params.ext_phy_config);
-
-			if ((ext_phy_type ==
-			     PORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM8705) ||
-			    (ext_phy_type ==
-			     PORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM8706)) {
-				/* force 10G, no AN */
-				bp->link_params.req_line_speed = SPEED_10000;
-				bp->port.advertising =
-						(ADVERTISED_10000baseT_Full |
-						 ADVERTISED_FIBRE);
-				break;
-			}
-			BNX2X_ERR("NVRAM config error. "
-				  "Invalid link_config 0x%x"
-				  "  Autoneg not supported\n",
-				  bp->port.link_config);
-			return;
-		}
-		break;
-
-	case PORT_FEATURE_LINK_SPEED_10M_FULL:
-		if (bp->port.supported & SUPPORTED_10baseT_Full) {
-			bp->link_params.req_line_speed = SPEED_10;
-			bp->port.advertising = (ADVERTISED_10baseT_Full |
-						ADVERTISED_TP);
-		} else {
-			BNX2X_ERR("NVRAM config error. "
-				  "Invalid link_config 0x%x"
-				  "  speed_cap_mask 0x%x\n",
-				  bp->port.link_config,
-				  bp->link_params.speed_cap_mask);
-			return;
-		}
-		break;
-
-	case PORT_FEATURE_LINK_SPEED_10M_HALF:
-		if (bp->port.supported & SUPPORTED_10baseT_Half) {
-			bp->link_params.req_line_speed = SPEED_10;
-			bp->link_params.req_duplex = DUPLEX_HALF;
-			bp->port.advertising = (ADVERTISED_10baseT_Half |
-						ADVERTISED_TP);
-		} else {
-			BNX2X_ERR("NVRAM config error. "
-				  "Invalid link_config 0x%x"
-				  "  speed_cap_mask 0x%x\n",
-				  bp->port.link_config,
-				  bp->link_params.speed_cap_mask);
-			return;
-		}
-		break;
-
-	case PORT_FEATURE_LINK_SPEED_100M_FULL:
-		if (bp->port.supported & SUPPORTED_100baseT_Full) {
-			bp->link_params.req_line_speed = SPEED_100;
-			bp->port.advertising = (ADVERTISED_100baseT_Full |
-						ADVERTISED_TP);
-		} else {
-			BNX2X_ERR("NVRAM config error. "
-				  "Invalid link_config 0x%x"
-				  "  speed_cap_mask 0x%x\n",
-				  bp->port.link_config,
-				  bp->link_params.speed_cap_mask);
-			return;
-		}
-		break;
-
-	case PORT_FEATURE_LINK_SPEED_100M_HALF:
-		if (bp->port.supported & SUPPORTED_100baseT_Half) {
-			bp->link_params.req_line_speed = SPEED_100;
-			bp->link_params.req_duplex = DUPLEX_HALF;
-			bp->port.advertising = (ADVERTISED_100baseT_Half |
-						ADVERTISED_TP);
-		} else {
-			BNX2X_ERR("NVRAM config error. "
-				  "Invalid link_config 0x%x"
-				  "  speed_cap_mask 0x%x\n",
-				  bp->port.link_config,
-				  bp->link_params.speed_cap_mask);
-			return;
-		}
-		break;
-
-	case PORT_FEATURE_LINK_SPEED_1G:
-		if (bp->port.supported & SUPPORTED_1000baseT_Full) {
-			bp->link_params.req_line_speed = SPEED_1000;
-			bp->port.advertising = (ADVERTISED_1000baseT_Full |
-						ADVERTISED_TP);
-		} else {
-			BNX2X_ERR("NVRAM config error. "
-				  "Invalid link_config 0x%x"
-				  "  speed_cap_mask 0x%x\n",
-				  bp->port.link_config,
-				  bp->link_params.speed_cap_mask);
-			return;
-		}
-		break;
-
-	case PORT_FEATURE_LINK_SPEED_2_5G:
-		if (bp->port.supported & SUPPORTED_2500baseX_Full) {
-			bp->link_params.req_line_speed = SPEED_2500;
-			bp->port.advertising = (ADVERTISED_2500baseX_Full |
-						ADVERTISED_TP);
-		} else {
-			BNX2X_ERR("NVRAM config error. "
-				  "Invalid link_config 0x%x"
-				  "  speed_cap_mask 0x%x\n",
-				  bp->port.link_config,
-				  bp->link_params.speed_cap_mask);
-			return;
-		}
-		break;
-
-	case PORT_FEATURE_LINK_SPEED_10G_CX4:
-	case PORT_FEATURE_LINK_SPEED_10G_KX4:
-	case PORT_FEATURE_LINK_SPEED_10G_KR:
-		if (bp->port.supported & SUPPORTED_10000baseT_Full) {
-			bp->link_params.req_line_speed = SPEED_10000;
-			bp->port.advertising = (ADVERTISED_10000baseT_Full |
-						ADVERTISED_FIBRE);
-		} else {
-			BNX2X_ERR("NVRAM config error. "
-				  "Invalid link_config 0x%x"
-				  "  speed_cap_mask 0x%x\n",
-				  bp->port.link_config,
-				  bp->link_params.speed_cap_mask);
-			return;
-		}
-		break;
-
-	default:
-		BNX2X_ERR("NVRAM config error. "
-			  "BAD link speed link_config 0x%x\n",
-			  bp->port.link_config);
-		bp->link_params.req_line_speed = SPEED_AUTO_NEG;
-		bp->port.advertising = bp->port.supported;
-		break;
-	}
-
-	bp->link_params.req_flow_ctrl = (bp->port.link_config &
-					 PORT_FEATURE_FLOW_CONTROL_MASK);
-	if ((bp->link_params.req_flow_ctrl == BNX2X_FLOW_CTRL_AUTO) &&
-	    !(bp->port.supported & SUPPORTED_Autoneg))
-		bp->link_params.req_flow_ctrl = BNX2X_FLOW_CTRL_NONE;
-
-	BNX2X_DEV_INFO("req_line_speed %d  req_duplex %d  req_flow_ctrl 0x%x"
-		       "  advertising 0x%x\n",
-		       bp->link_params.req_line_speed,
-		       bp->link_params.req_duplex,
-		       bp->link_params.req_flow_ctrl, bp->port.advertising);
-}
-
-static void __devinit bnx2x_set_mac_buf(u8 *mac_buf, u32 mac_lo, u16 mac_hi)
-{
-	mac_hi = cpu_to_be16(mac_hi);
-	mac_lo = cpu_to_be32(mac_lo);
-	memcpy(mac_buf, &mac_hi, sizeof(mac_hi));
-	memcpy(mac_buf + sizeof(mac_hi), &mac_lo, sizeof(mac_lo));
-}
-
-static void __devinit bnx2x_get_port_hwinfo(struct bnx2x *bp)
-{
-	int port = BP_PORT(bp);
-	u32 val, val2;
-	u32 config;
-	u16 i;
-	u32 ext_phy_type;
-
-	bp->link_params.bp = bp;
-	bp->link_params.port = port;
-
-	bp->link_params.lane_config =
-		SHMEM_RD(bp, dev_info.port_hw_config[port].lane_config);
-	bp->link_params.ext_phy_config =
-		SHMEM_RD(bp,
-			 dev_info.port_hw_config[port].external_phy_config);
-	/* BCM8727_NOC => BCM8727 no over current */
-	if (XGXS_EXT_PHY_TYPE(bp->link_params.ext_phy_config) ==
-	    PORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM8727_NOC) {
-		bp->link_params.ext_phy_config &=
-			~PORT_HW_CFG_XGXS_EXT_PHY_TYPE_MASK;
-		bp->link_params.ext_phy_config |=
-			PORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM8727;
-		bp->link_params.feature_config_flags |=
-			FEATURE_CONFIG_BCM8727_NOC;
-	}
-
-	bp->link_params.speed_cap_mask =
-		SHMEM_RD(bp,
-			 dev_info.port_hw_config[port].speed_capability_mask);
-
-	bp->port.link_config =
-		SHMEM_RD(bp, dev_info.port_feature_config[port].link_config);
-
-	/* Get the 4 lanes xgxs config rx and tx */
-	for (i = 0; i < 2; i++) {
-		val = SHMEM_RD(bp,
-			   dev_info.port_hw_config[port].xgxs_config_rx[i<<1]);
-		bp->link_params.xgxs_config_rx[i << 1] = ((val>>16) & 0xffff);
-		bp->link_params.xgxs_config_rx[(i << 1) + 1] = (val & 0xffff);
-
-		val = SHMEM_RD(bp,
-			   dev_info.port_hw_config[port].xgxs_config_tx[i<<1]);
-		bp->link_params.xgxs_config_tx[i << 1] = ((val>>16) & 0xffff);
-		bp->link_params.xgxs_config_tx[(i << 1) + 1] = (val & 0xffff);
-	}
-
-	/* If the device is capable of WoL, set the default state according
-	 * to the HW
-	 */
-	config = SHMEM_RD(bp, dev_info.port_feature_config[port].config);
-	bp->wol = (!(bp->flags & NO_WOL_FLAG) &&
-		   (config & PORT_FEATURE_WOL_ENABLED));
-
-	BNX2X_DEV_INFO("lane_config 0x%08x  ext_phy_config 0x%08x"
-		       "  speed_cap_mask 0x%08x  link_config 0x%08x\n",
-		       bp->link_params.lane_config,
-		       bp->link_params.ext_phy_config,
-		       bp->link_params.speed_cap_mask, bp->port.link_config);
-
-	bp->link_params.switch_cfg |= (bp->port.link_config &
-				       PORT_FEATURE_CONNECTED_SWITCH_MASK);
-	bnx2x_link_settings_supported(bp, bp->link_params.switch_cfg);
-
-	bnx2x_link_settings_requested(bp);
-
-	/*
-	 * If connected directly, work with the internal PHY, otherwise, work
-	 * with the external PHY
-	 */
-	ext_phy_type = XGXS_EXT_PHY_TYPE(bp->link_params.ext_phy_config);
-	if (ext_phy_type == PORT_HW_CFG_XGXS_EXT_PHY_TYPE_DIRECT)
-		bp->mdio.prtad = bp->link_params.phy_addr;
-
-	else if ((ext_phy_type != PORT_HW_CFG_XGXS_EXT_PHY_TYPE_FAILURE) &&
-		 (ext_phy_type != PORT_HW_CFG_XGXS_EXT_PHY_TYPE_NOT_CONN))
-		bp->mdio.prtad =
-			XGXS_EXT_PHY_ADDR(bp->link_params.ext_phy_config);
-
-	val2 = SHMEM_RD(bp, dev_info.port_hw_config[port].mac_upper);
-	val = SHMEM_RD(bp, dev_info.port_hw_config[port].mac_lower);
-	bnx2x_set_mac_buf(bp->dev->dev_addr, val, val2);
-	memcpy(bp->link_params.mac_addr, bp->dev->dev_addr, ETH_ALEN);
-	memcpy(bp->dev->perm_addr, bp->dev->dev_addr, ETH_ALEN);
-
-#ifdef BCM_CNIC
-	val2 = SHMEM_RD(bp, dev_info.port_hw_config[port].iscsi_mac_upper);
-	val = SHMEM_RD(bp, dev_info.port_hw_config[port].iscsi_mac_lower);
-	bnx2x_set_mac_buf(bp->iscsi_mac, val, val2);
-#endif
-}
-
-static int __devinit bnx2x_get_hwinfo(struct bnx2x *bp)
-{
-	int func = BP_FUNC(bp);
-	u32 val, val2;
-	int rc = 0;
-
-	bnx2x_get_common_hwinfo(bp);
-
-	bp->e1hov = 0;
-	bp->e1hmf = 0;
-	if (CHIP_IS_E1H(bp)) {
-		bp->mf_config =
-			SHMEM_RD(bp, mf_cfg.func_mf_config[func].config);
-
-		val = (SHMEM_RD(bp, mf_cfg.func_mf_config[FUNC_0].e1hov_tag) &
-		       FUNC_MF_CFG_E1HOV_TAG_MASK);
-		if (val != FUNC_MF_CFG_E1HOV_TAG_DEFAULT)
-			bp->e1hmf = 1;
-		BNX2X_DEV_INFO("%s function mode\n",
-			       IS_E1HMF(bp) ? "multi" : "single");
-
-		if (IS_E1HMF(bp)) {
-			val = (SHMEM_RD(bp, mf_cfg.func_mf_config[func].
-								e1hov_tag) &
-			       FUNC_MF_CFG_E1HOV_TAG_MASK);
-			if (val != FUNC_MF_CFG_E1HOV_TAG_DEFAULT) {
-				bp->e1hov = val;
-				BNX2X_DEV_INFO("E1HOV for func %d is %d "
-					       "(0x%04x)\n",
-					       func, bp->e1hov, bp->e1hov);
-			} else {
-				BNX2X_ERR("!!!  No valid E1HOV for func %d,"
-					  "  aborting\n", func);
-				rc = -EPERM;
-			}
-		} else {
-			if (BP_E1HVN(bp)) {
-				BNX2X_ERR("!!!  VN %d in single function mode,"
-					  "  aborting\n", BP_E1HVN(bp));
-				rc = -EPERM;
-			}
-		}
-	}
-
-	if (!BP_NOMCP(bp)) {
-		bnx2x_get_port_hwinfo(bp);
-
-		bp->fw_seq = (SHMEM_RD(bp, func_mb[func].drv_mb_header) &
-			      DRV_MSG_SEQ_NUMBER_MASK);
-		BNX2X_DEV_INFO("fw_seq 0x%08x\n", bp->fw_seq);
-	}
-
-	if (IS_E1HMF(bp)) {
-		val2 = SHMEM_RD(bp, mf_cfg.func_mf_config[func].mac_upper);
-		val = SHMEM_RD(bp,  mf_cfg.func_mf_config[func].mac_lower);
-		if ((val2 != FUNC_MF_CFG_UPPERMAC_DEFAULT) &&
-		    (val != FUNC_MF_CFG_LOWERMAC_DEFAULT)) {
-			bp->dev->dev_addr[0] = (u8)(val2 >> 8 & 0xff);
-			bp->dev->dev_addr[1] = (u8)(val2 & 0xff);
-			bp->dev->dev_addr[2] = (u8)(val >> 24 & 0xff);
-			bp->dev->dev_addr[3] = (u8)(val >> 16 & 0xff);
-			bp->dev->dev_addr[4] = (u8)(val >> 8  & 0xff);
-			bp->dev->dev_addr[5] = (u8)(val & 0xff);
-			memcpy(bp->link_params.mac_addr, bp->dev->dev_addr,
-			       ETH_ALEN);
-			memcpy(bp->dev->perm_addr, bp->dev->dev_addr,
-			       ETH_ALEN);
-		}
-
-		return rc;
-	}
-
-	if (BP_NOMCP(bp)) {
-		/* only supposed to happen on emulation/FPGA */
-		BNX2X_ERR("warning random MAC workaround active\n");
-		random_ether_addr(bp->dev->dev_addr);
-		memcpy(bp->dev->perm_addr, bp->dev->dev_addr, ETH_ALEN);
-	}
-
-	return rc;
-}
-
-static int __devinit bnx2x_init_bp(struct bnx2x *bp)
-{
-	int func = BP_FUNC(bp);
-	int timer_interval;
-	int rc;
-
-	/* Disable interrupt handling until HW is initialized */
-	atomic_set(&bp->intr_sem, 1);
-	smp_wmb(); /* Ensure that bp->intr_sem update is SMP-safe */
-
-	mutex_init(&bp->port.phy_mutex);
-	mutex_init(&bp->fw_mb_mutex);
-#ifdef BCM_CNIC
-	mutex_init(&bp->cnic_mutex);
-#endif
-
-	INIT_DELAYED_WORK(&bp->sp_task, bnx2x_sp_task);
-	INIT_WORK(&bp->reset_task, bnx2x_reset_task);
-
-	rc = bnx2x_get_hwinfo(bp);
-
-	/* need to reset chip if undi was active */
-	if (!BP_NOMCP(bp))
-		bnx2x_undi_unload(bp);
-
-	if (CHIP_REV_IS_FPGA(bp))
-		pr_err("FPGA detected\n");
-
-	if (BP_NOMCP(bp) && (func == 0))
-		pr_err("MCP disabled, must load devices in order!\n");
-
-	/* Set multi queue mode */
-	if ((multi_mode != ETH_RSS_MODE_DISABLED) &&
-	    ((int_mode == INT_MODE_INTx) || (int_mode == INT_MODE_MSI))) {
-		pr_err("Multi disabled since int_mode requested is not MSI-X\n");
-		multi_mode = ETH_RSS_MODE_DISABLED;
-	}
-	bp->multi_mode = multi_mode;
-
-
-	/* Set TPA flags */
-	if (disable_tpa) {
-		bp->flags &= ~TPA_ENABLE_FLAG;
-		bp->dev->features &= ~NETIF_F_LRO;
-	} else {
-		bp->flags |= TPA_ENABLE_FLAG;
-		bp->dev->features |= NETIF_F_LRO;
-	}
-
-	if (CHIP_IS_E1(bp))
-		bp->dropless_fc = 0;
-	else
-		bp->dropless_fc = dropless_fc;
-
-	bp->mrrs = mrrs;
-
-	bp->tx_ring_size = MAX_TX_AVAIL;
-	bp->rx_ring_size = MAX_RX_AVAIL;
-
-	bp->rx_csum = 1;
-
-	/* make sure that the numbers are in the right granularity */
-	bp->tx_ticks = (50 / (4 * BNX2X_BTR)) * (4 * BNX2X_BTR);
-	bp->rx_ticks = (25 / (4 * BNX2X_BTR)) * (4 * BNX2X_BTR);
-
-	timer_interval = (CHIP_REV_IS_SLOW(bp) ? 5*HZ : HZ);
-	bp->current_interval = (poll ? poll : timer_interval);
-
-	init_timer(&bp->timer);
-	bp->timer.expires = jiffies + bp->current_interval;
-	bp->timer.data = (unsigned long) bp;
-	bp->timer.function = bnx2x_timer;
-
-	return rc;
-}
-
-/*
- * ethtool service functions
- */
-
-/* All ethtool functions called with rtnl_lock */
-
-static int bnx2x_get_settings(struct net_device *dev, struct ethtool_cmd *cmd)
-{
-	struct bnx2x *bp = netdev_priv(dev);
-
-	cmd->supported = bp->port.supported;
-	cmd->advertising = bp->port.advertising;
-
-	if ((bp->state == BNX2X_STATE_OPEN) &&
-	    !(bp->flags & MF_FUNC_DIS) &&
-	    (bp->link_vars.link_up)) {
-		cmd->speed = bp->link_vars.line_speed;
-		cmd->duplex = bp->link_vars.duplex;
-		if (IS_E1HMF(bp)) {
-			u16 vn_max_rate;
-
-			vn_max_rate =
-				((bp->mf_config & FUNC_MF_CFG_MAX_BW_MASK) >>
-				FUNC_MF_CFG_MAX_BW_SHIFT) * 100;
-			if (vn_max_rate < cmd->speed)
-				cmd->speed = vn_max_rate;
-		}
-	} else {
-		cmd->speed = -1;
-		cmd->duplex = -1;
-	}
-
-	if (bp->link_params.switch_cfg == SWITCH_CFG_10G) {
-		u32 ext_phy_type =
-			XGXS_EXT_PHY_TYPE(bp->link_params.ext_phy_config);
-
-		switch (ext_phy_type) {
-		case PORT_HW_CFG_XGXS_EXT_PHY_TYPE_DIRECT:
-		case PORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM8072:
-		case PORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM8073:
-		case PORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM8705:
-		case PORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM8706:
-		case PORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM8726:
-		case PORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM8727:
-			cmd->port = PORT_FIBRE;
-			break;
-
-		case PORT_HW_CFG_XGXS_EXT_PHY_TYPE_SFX7101:
-		case PORT_HW_CFG_XGXS_EXT_PHY_TYPE_BCM8481:
-			cmd->port = PORT_TP;
-			break;
-
-		case PORT_HW_CFG_XGXS_EXT_PHY_TYPE_FAILURE:
-			BNX2X_ERR("XGXS PHY Failure detected 0x%x\n",
-				  bp->link_params.ext_phy_config);
-			break;
-
-		default:
-			DP(NETIF_MSG_LINK, "BAD XGXS ext_phy_config 0x%x\n",
-			   bp->link_params.ext_phy_config);
-			break;
-		}
-	} else
-		cmd->port = PORT_TP;
-
-	cmd->phy_address = bp->mdio.prtad;
-	cmd->transceiver = XCVR_INTERNAL;
-
-	if (bp->link_params.req_line_speed == SPEED_AUTO_NEG)
-		cmd->autoneg = AUTONEG_ENABLE;
-	else
-		cmd->autoneg = AUTONEG_DISABLE;
-
-	cmd->maxtxpkt = 0;
-	cmd->maxrxpkt = 0;
-
-	DP(NETIF_MSG_LINK, "ethtool_cmd: cmd %d\n"
-	   DP_LEVEL "  supported 0x%x  advertising 0x%x  speed %d\n"
-	   DP_LEVEL "  duplex %d  port %d  phy_address %d  transceiver %d\n"
-	   DP_LEVEL "  autoneg %d  maxtxpkt %d  maxrxpkt %d\n",
-	   cmd->cmd, cmd->supported, cmd->advertising, cmd->speed,
-	   cmd->duplex, cmd->port, cmd->phy_address, cmd->transceiver,
-	   cmd->autoneg, cmd->maxtxpkt, cmd->maxrxpkt);
-
-	return 0;
-}
-
-static int bnx2x_set_settings(struct net_device *dev, struct ethtool_cmd *cmd)
-{
-	struct bnx2x *bp = netdev_priv(dev);
-	u32 advertising;
-
-	if (IS_E1HMF(bp))
-		return 0;
-
-	DP(NETIF_MSG_LINK, "ethtool_cmd: cmd %d\n"
-	   DP_LEVEL "  supported 0x%x  advertising 0x%x  speed %d\n"
-	   DP_LEVEL "  duplex %d  port %d  phy_address %d  transceiver %d\n"
-	   DP_LEVEL "  autoneg %d  maxtxpkt %d  maxrxpkt %d\n",
-	   cmd->cmd, cmd->supported, cmd->advertising, cmd->speed,
-	   cmd->duplex, cmd->port, cmd->phy_address, cmd->transceiver,
-	   cmd->autoneg, cmd->maxtxpkt, cmd->maxrxpkt);
-
-	if (cmd->autoneg == AUTONEG_ENABLE) {
-		if (!(bp->port.supported & SUPPORTED_Autoneg)) {
-			DP(NETIF_MSG_LINK, "Autoneg not supported\n");
-			return -EINVAL;
-		}
-
-		/* advertise the requested speed and duplex if supported */
-		cmd->advertising &= bp->port.supported;
-
-		bp->link_params.req_line_speed = SPEED_AUTO_NEG;
-		bp->link_params.req_duplex = DUPLEX_FULL;
-		bp->port.advertising |= (ADVERTISED_Autoneg |
-					 cmd->advertising);
-
-	} else { /* forced speed */
-		/* advertise the requested speed and duplex if supported */
-		switch (cmd->speed) {
-		case SPEED_10:
-			if (cmd->duplex == DUPLEX_FULL) {
-				if (!(bp->port.supported &
-				      SUPPORTED_10baseT_Full)) {
-					DP(NETIF_MSG_LINK,
-					   "10M full not supported\n");
-					return -EINVAL;
-				}
-
-				advertising = (ADVERTISED_10baseT_Full |
-					       ADVERTISED_TP);
-			} else {
-				if (!(bp->port.supported &
-				      SUPPORTED_10baseT_Half)) {
-					DP(NETIF_MSG_LINK,
-					   "10M half not supported\n");
-					return -EINVAL;
-				}
-
-				advertising = (ADVERTISED_10baseT_Half |
-					       ADVERTISED_TP);
-			}
-			break;
-
-		case SPEED_100:
-			if (cmd->duplex == DUPLEX_FULL) {
-				if (!(bp->port.supported &
-						SUPPORTED_100baseT_Full)) {
-					DP(NETIF_MSG_LINK,
-					   "100M full not supported\n");
-					return -EINVAL;
-				}
-
-				advertising = (ADVERTISED_100baseT_Full |
-					       ADVERTISED_TP);
-			} else {
-				if (!(bp->port.supported &
-						SUPPORTED_100baseT_Half)) {
-					DP(NETIF_MSG_LINK,
-					   "100M half not supported\n");
-					return -EINVAL;
-				}
-
-				advertising = (ADVERTISED_100baseT_Half |
-					       ADVERTISED_TP);
-			}
-			break;
-
-		case SPEED_1000:
-			if (cmd->duplex != DUPLEX_FULL) {
-				DP(NETIF_MSG_LINK, "1G half not supported\n");
-				return -EINVAL;
-			}
-
-			if (!(bp->port.supported & SUPPORTED_1000baseT_Full)) {
-				DP(NETIF_MSG_LINK, "1G full not supported\n");
-				return -EINVAL;
-			}
-
-			advertising = (ADVERTISED_1000baseT_Full |
-				       ADVERTISED_TP);
-			break;
-
-		case SPEED_2500:
-			if (cmd->duplex != DUPLEX_FULL) {
-				DP(NETIF_MSG_LINK,
-				   "2.5G half not supported\n");
-				return -EINVAL;
-			}
-
-			if (!(bp->port.supported & SUPPORTED_2500baseX_Full)) {
-				DP(NETIF_MSG_LINK,
-				   "2.5G full not supported\n");
-				return -EINVAL;
-			}
-
-			advertising = (ADVERTISED_2500baseX_Full |
-				       ADVERTISED_TP);
-			break;
-
-		case SPEED_10000:
-			if (cmd->duplex != DUPLEX_FULL) {
-				DP(NETIF_MSG_LINK, "10G half not supported\n");
-				return -EINVAL;
-			}
-
-			if (!(bp->port.supported & SUPPORTED_10000baseT_Full)) {
-				DP(NETIF_MSG_LINK, "10G full not supported\n");
-				return -EINVAL;
-			}
-
-			advertising = (ADVERTISED_10000baseT_Full |
-				       ADVERTISED_FIBRE);
-			break;
-
-		default:
-			DP(NETIF_MSG_LINK, "Unsupported speed\n");
-			return -EINVAL;
-		}
-
-		bp->link_params.req_line_speed = cmd->speed;
-		bp->link_params.req_duplex = cmd->duplex;
-		bp->port.advertising = advertising;
-	}
-
-	DP(NETIF_MSG_LINK, "req_line_speed %d\n"
-	   DP_LEVEL "  req_duplex %d  advertising 0x%x\n",
-	   bp->link_params.req_line_speed, bp->link_params.req_duplex,
-	   bp->port.advertising);
-
-	if (netif_running(dev)) {
-		bnx2x_stats_handle(bp, STATS_EVENT_STOP);
-		bnx2x_link_set(bp);
-	}
-
-	return 0;
-}
-
-#define IS_E1_ONLINE(info)	(((info) & RI_E1_ONLINE) == RI_E1_ONLINE)
-#define IS_E1H_ONLINE(info)	(((info) & RI_E1H_ONLINE) == RI_E1H_ONLINE)
-
-static int bnx2x_get_regs_len(struct net_device *dev)
-{
-	struct bnx2x *bp = netdev_priv(dev);
-	int regdump_len = 0;
-	int i;
-
-	if (CHIP_IS_E1(bp)) {
-		for (i = 0; i < REGS_COUNT; i++)
-			if (IS_E1_ONLINE(reg_addrs[i].info))
-				regdump_len += reg_addrs[i].size;
-
-		for (i = 0; i < WREGS_COUNT_E1; i++)
-			if (IS_E1_ONLINE(wreg_addrs_e1[i].info))
-				regdump_len += wreg_addrs_e1[i].size *
-					(1 + wreg_addrs_e1[i].read_regs_count);
-
-	} else { /* E1H */
-		for (i = 0; i < REGS_COUNT; i++)
-			if (IS_E1H_ONLINE(reg_addrs[i].info))
-				regdump_len += reg_addrs[i].size;
-
-		for (i = 0; i < WREGS_COUNT_E1H; i++)
-			if (IS_E1H_ONLINE(wreg_addrs_e1h[i].info))
-				regdump_len += wreg_addrs_e1h[i].size *
-					(1 + wreg_addrs_e1h[i].read_regs_count);
-	}
-	regdump_len *= 4;
-	regdump_len += sizeof(struct dump_hdr);
-
-	return regdump_len;
-}
-
-static void bnx2x_get_regs(struct net_device *dev,
-			   struct ethtool_regs *regs, void *_p)
-{
-	u32 *p = _p, i, j;
-	struct bnx2x *bp = netdev_priv(dev);
-	struct dump_hdr dump_hdr = {0};
-
-	regs->version = 0;
-	memset(p, 0, regs->len);
-
-	if (!netif_running(bp->dev))
-		return;
-
-	dump_hdr.hdr_size = (sizeof(struct dump_hdr) / 4) - 1;
-	dump_hdr.dump_sign = dump_sign_all;
-	dump_hdr.xstorm_waitp = REG_RD(bp, XSTORM_WAITP_ADDR);
-	dump_hdr.tstorm_waitp = REG_RD(bp, TSTORM_WAITP_ADDR);
-	dump_hdr.ustorm_waitp = REG_RD(bp, USTORM_WAITP_ADDR);
-	dump_hdr.cstorm_waitp = REG_RD(bp, CSTORM_WAITP_ADDR);
-	dump_hdr.info = CHIP_IS_E1(bp) ? RI_E1_ONLINE : RI_E1H_ONLINE;
-
-	memcpy(p, &dump_hdr, sizeof(struct dump_hdr));
-	p += dump_hdr.hdr_size + 1;
-
-	if (CHIP_IS_E1(bp)) {
-		for (i = 0; i < REGS_COUNT; i++)
-			if (IS_E1_ONLINE(reg_addrs[i].info))
-				for (j = 0; j < reg_addrs[i].size; j++)
-					*p++ = REG_RD(bp,
-						      reg_addrs[i].addr + j*4);
-
-	} else { /* E1H */
-		for (i = 0; i < REGS_COUNT; i++)
-			if (IS_E1H_ONLINE(reg_addrs[i].info))
-				for (j = 0; j < reg_addrs[i].size; j++)
-					*p++ = REG_RD(bp,
-						      reg_addrs[i].addr + j*4);
-	}
-}
-
-#define PHY_FW_VER_LEN			10
-
-static void bnx2x_get_drvinfo(struct net_device *dev,
-			      struct ethtool_drvinfo *info)
-{
-	struct bnx2x *bp = netdev_priv(dev);
-	u8 phy_fw_ver[PHY_FW_VER_LEN];
-
-	strcpy(info->driver, DRV_MODULE_NAME);
-	strcpy(info->version, DRV_MODULE_VERSION);
-
-	phy_fw_ver[0] = '\0';
-	if (bp->port.pmf) {
-		bnx2x_acquire_phy_lock(bp);
-		bnx2x_get_ext_phy_fw_version(&bp->link_params,
-					     (bp->state != BNX2X_STATE_CLOSED),
-					     phy_fw_ver, PHY_FW_VER_LEN);
-		bnx2x_release_phy_lock(bp);
-	}
-
-	snprintf(info->fw_version, 32, "BC:%d.%d.%d%s%s",
-		 (bp->common.bc_ver & 0xff0000) >> 16,
-		 (bp->common.bc_ver & 0xff00) >> 8,
-		 (bp->common.bc_ver & 0xff),
-		 ((phy_fw_ver[0] != '\0') ? " PHY:" : ""), phy_fw_ver);
-	strcpy(info->bus_info, pci_name(bp->pdev));
-	info->n_stats = BNX2X_NUM_STATS;
-	info->testinfo_len = BNX2X_NUM_TESTS;
-	info->eedump_len = bp->common.flash_size;
-	info->regdump_len = bnx2x_get_regs_len(dev);
-}
-
-static void bnx2x_get_wol(struct net_device *dev, struct ethtool_wolinfo *wol)
-{
-	struct bnx2x *bp = netdev_priv(dev);
-
-	if (bp->flags & NO_WOL_FLAG) {
-		wol->supported = 0;
-		wol->wolopts = 0;
-	} else {
-		wol->supported = WAKE_MAGIC;
-		if (bp->wol)
-			wol->wolopts = WAKE_MAGIC;
-		else
-			wol->wolopts = 0;
-	}
-	memset(&wol->sopass, 0, sizeof(wol->sopass));
-}
-
-static int bnx2x_set_wol(struct net_device *dev, struct ethtool_wolinfo *wol)
-{
-	struct bnx2x *bp = netdev_priv(dev);
-
-	if (wol->wolopts & ~WAKE_MAGIC)
-		return -EINVAL;
-
-	if (wol->wolopts & WAKE_MAGIC) {
-		if (bp->flags & NO_WOL_FLAG)
-			return -EINVAL;
-
-		bp->wol = 1;
-	} else
-		bp->wol = 0;
-
-	return 0;
-}
-
-static u32 bnx2x_get_msglevel(struct net_device *dev)
-{
-	struct bnx2x *bp = netdev_priv(dev);
-
-	return bp->msg_enable;
-}
-
-static void bnx2x_set_msglevel(struct net_device *dev, u32 level)
-{
-	struct bnx2x *bp = netdev_priv(dev);
-
-	if (capable(CAP_NET_ADMIN))
-		bp->msg_enable = level;
-}
-
-static int bnx2x_nway_reset(struct net_device *dev)
-{
-	struct bnx2x *bp = netdev_priv(dev);
-
-	if (!bp->port.pmf)
-		return 0;
-
-	if (netif_running(dev)) {
-		bnx2x_stats_handle(bp, STATS_EVENT_STOP);
-		bnx2x_link_set(bp);
-	}
-
-	return 0;
-}
-
-static u32 bnx2x_get_link(struct net_device *dev)
-{
-	struct bnx2x *bp = netdev_priv(dev);
-
-	if (bp->flags & MF_FUNC_DIS)
-		return 0;
-
-	return bp->link_vars.link_up;
-}
-
-static int bnx2x_get_eeprom_len(struct net_device *dev)
-{
-	struct bnx2x *bp = netdev_priv(dev);
-
-	return bp->common.flash_size;
-}
-
-static int bnx2x_acquire_nvram_lock(struct bnx2x *bp)
-{
-	int port = BP_PORT(bp);
-	int count, i;
-	u32 val = 0;
-
-	/* adjust timeout for emulation/FPGA */
-	count = NVRAM_TIMEOUT_COUNT;
-	if (CHIP_REV_IS_SLOW(bp))
-		count *= 100;
-
-	/* request access to nvram interface */
-	REG_WR(bp, MCP_REG_MCPR_NVM_SW_ARB,
-	       (MCPR_NVM_SW_ARB_ARB_REQ_SET1 << port));
-
-	for (i = 0; i < count*10; i++) {
-		val = REG_RD(bp, MCP_REG_MCPR_NVM_SW_ARB);
-		if (val & (MCPR_NVM_SW_ARB_ARB_ARB1 << port))
-			break;
-
-		udelay(5);
-	}
-
-	if (!(val & (MCPR_NVM_SW_ARB_ARB_ARB1 << port))) {
-		DP(BNX2X_MSG_NVM, "cannot get access to nvram interface\n");
-		return -EBUSY;
-	}
-
-	return 0;
-}
-
-static int bnx2x_release_nvram_lock(struct bnx2x *bp)
-{
-	int port = BP_PORT(bp);
-	int count, i;
-	u32 val = 0;
-
-	/* adjust timeout for emulation/FPGA */
-	count = NVRAM_TIMEOUT_COUNT;
-	if (CHIP_REV_IS_SLOW(bp))
-		count *= 100;
-
-	/* relinquish nvram interface */
-	REG_WR(bp, MCP_REG_MCPR_NVM_SW_ARB,
-	       (MCPR_NVM_SW_ARB_ARB_REQ_CLR1 << port));
-
-	for (i = 0; i < count*10; i++) {
-		val = REG_RD(bp, MCP_REG_MCPR_NVM_SW_ARB);
-		if (!(val & (MCPR_NVM_SW_ARB_ARB_ARB1 << port)))
-			break;
-
-		udelay(5);
-	}
-
-	if (val & (MCPR_NVM_SW_ARB_ARB_ARB1 << port)) {
-		DP(BNX2X_MSG_NVM, "cannot free access to nvram interface\n");
-		return -EBUSY;
-	}
-
-	return 0;
-}
-
-static void bnx2x_enable_nvram_access(struct bnx2x *bp)
-{
-	u32 val;
-
-	val = REG_RD(bp, MCP_REG_MCPR_NVM_ACCESS_ENABLE);
-
-	/* enable both bits, even on read */
-	REG_WR(bp, MCP_REG_MCPR_NVM_ACCESS_ENABLE,
-	       (val | MCPR_NVM_ACCESS_ENABLE_EN |
-		      MCPR_NVM_ACCESS_ENABLE_WR_EN));
-}
-
-static void bnx2x_disable_nvram_access(struct bnx2x *bp)
-{
-	u32 val;
-
-	val = REG_RD(bp, MCP_REG_MCPR_NVM_ACCESS_ENABLE);
-
-	/* disable both bits, even after read */
-	REG_WR(bp, MCP_REG_MCPR_NVM_ACCESS_ENABLE,
-	       (val & ~(MCPR_NVM_ACCESS_ENABLE_EN |
-			MCPR_NVM_ACCESS_ENABLE_WR_EN)));
-}
-
-static int bnx2x_nvram_read_dword(struct bnx2x *bp, u32 offset, __be32 *ret_val,
-				  u32 cmd_flags)
-{
-	int count, i, rc;
-	u32 val;
-
-	/* build the command word */
-	cmd_flags |= MCPR_NVM_COMMAND_DOIT;
-
-	/* need to clear DONE bit separately */
-	REG_WR(bp, MCP_REG_MCPR_NVM_COMMAND, MCPR_NVM_COMMAND_DONE);
-
-	/* address of the NVRAM to read from */
-	REG_WR(bp, MCP_REG_MCPR_NVM_ADDR,
-	       (offset & MCPR_NVM_ADDR_NVM_ADDR_VALUE));
-
-	/* issue a read command */
-	REG_WR(bp, MCP_REG_MCPR_NVM_COMMAND, cmd_flags);
-
-	/* adjust timeout for emulation/FPGA */
-	count = NVRAM_TIMEOUT_COUNT;
-	if (CHIP_REV_IS_SLOW(bp))
-		count *= 100;
-
-	/* wait for completion */
-	*ret_val = 0;
-	rc = -EBUSY;
-	for (i = 0; i < count; i++) {
-		udelay(5);
-		val = REG_RD(bp, MCP_REG_MCPR_NVM_COMMAND);
-
-		if (val & MCPR_NVM_COMMAND_DONE) {
-			val = REG_RD(bp, MCP_REG_MCPR_NVM_READ);
-			/* we read nvram data in cpu order
-			 * but ethtool sees it as an array of bytes
-			 * converting to big-endian will do the work */
-			*ret_val = cpu_to_be32(val);
-			rc = 0;
-			break;
-		}
-	}
-
-	return rc;
-}
-
-static int bnx2x_nvram_read(struct bnx2x *bp, u32 offset, u8 *ret_buf,
-			    int buf_size)
-{
-	int rc;
-	u32 cmd_flags;
-	__be32 val;
-
-	if ((offset & 0x03) || (buf_size & 0x03) || (buf_size == 0)) {
-		DP(BNX2X_MSG_NVM,
-		   "Invalid parameter: offset 0x%x  buf_size 0x%x\n",
-		   offset, buf_size);
-		return -EINVAL;
-	}
-
-	if (offset + buf_size > bp->common.flash_size) {
-		DP(BNX2X_MSG_NVM, "Invalid parameter: offset (0x%x) +"
-				  " buf_size (0x%x) > flash_size (0x%x)\n",
-		   offset, buf_size, bp->common.flash_size);
-		return -EINVAL;
-	}
-
-	/* request access to nvram interface */
-	rc = bnx2x_acquire_nvram_lock(bp);
-	if (rc)
-		return rc;
-
-	/* enable access to nvram interface */
-	bnx2x_enable_nvram_access(bp);
-
-	/* read the first word(s) */
-	cmd_flags = MCPR_NVM_COMMAND_FIRST;
-	while ((buf_size > sizeof(u32)) && (rc == 0)) {
-		rc = bnx2x_nvram_read_dword(bp, offset, &val, cmd_flags);
-		memcpy(ret_buf, &val, 4);
-
-		/* advance to the next dword */
-		offset += sizeof(u32);
-		ret_buf += sizeof(u32);
-		buf_size -= sizeof(u32);
-		cmd_flags = 0;
-	}
-
-	if (rc == 0) {
-		cmd_flags |= MCPR_NVM_COMMAND_LAST;
-		rc = bnx2x_nvram_read_dword(bp, offset, &val, cmd_flags);
-		memcpy(ret_buf, &val, 4);
-	}
-
-	/* disable access to nvram interface */
-	bnx2x_disable_nvram_access(bp);
-	bnx2x_release_nvram_lock(bp);
-
-	return rc;
-}
-
-static int bnx2x_get_eeprom(struct net_device *dev,
-			    struct ethtool_eeprom *eeprom, u8 *eebuf)
-{
-	struct bnx2x *bp = netdev_priv(dev);
-	int rc;
-
-	if (!netif_running(dev))
-		return -EAGAIN;
-
-	DP(BNX2X_MSG_NVM, "ethtool_eeprom: cmd %d\n"
-	   DP_LEVEL "  magic 0x%x  offset 0x%x (%d)  len 0x%x (%d)\n",
-	   eeprom->cmd, eeprom->magic, eeprom->offset, eeprom->offset,
-	   eeprom->len, eeprom->len);
-
-	/* parameters already validated in ethtool_get_eeprom */
-
-	rc = bnx2x_nvram_read(bp, eeprom->offset, eebuf, eeprom->len);
-
-	return rc;
-}
-
-static int bnx2x_nvram_write_dword(struct bnx2x *bp, u32 offset, u32 val,
-				   u32 cmd_flags)
-{
-	int count, i, rc;
-
-	/* build the command word */
-	cmd_flags |= MCPR_NVM_COMMAND_DOIT | MCPR_NVM_COMMAND_WR;
-
-	/* need to clear DONE bit separately */
-	REG_WR(bp, MCP_REG_MCPR_NVM_COMMAND, MCPR_NVM_COMMAND_DONE);
-
-	/* write the data */
-	REG_WR(bp, MCP_REG_MCPR_NVM_WRITE, val);
-
-	/* address of the NVRAM to write to */
-	REG_WR(bp, MCP_REG_MCPR_NVM_ADDR,
-	       (offset & MCPR_NVM_ADDR_NVM_ADDR_VALUE));
-
-	/* issue the write command */
-	REG_WR(bp, MCP_REG_MCPR_NVM_COMMAND, cmd_flags);
-
-	/* adjust timeout for emulation/FPGA */
-	count = NVRAM_TIMEOUT_COUNT;
-	if (CHIP_REV_IS_SLOW(bp))
-		count *= 100;
-
-	/* wait for completion */
-	rc = -EBUSY;
-	for (i = 0; i < count; i++) {
-		udelay(5);
-		val = REG_RD(bp, MCP_REG_MCPR_NVM_COMMAND);
-		if (val & MCPR_NVM_COMMAND_DONE) {
-			rc = 0;
-			break;
-		}
-	}
-
-	return rc;
-}
-
-#define BYTE_OFFSET(offset)		(8 * (offset & 0x03))
-
-static int bnx2x_nvram_write1(struct bnx2x *bp, u32 offset, u8 *data_buf,
-			      int buf_size)
-{
-	int rc;
-	u32 cmd_flags;
-	u32 align_offset;
-	__be32 val;
-
-	if (offset + buf_size > bp->common.flash_size) {
-		DP(BNX2X_MSG_NVM, "Invalid parameter: offset (0x%x) +"
-				  " buf_size (0x%x) > flash_size (0x%x)\n",
-		   offset, buf_size, bp->common.flash_size);
-		return -EINVAL;
-	}
-
-	/* request access to nvram interface */
-	rc = bnx2x_acquire_nvram_lock(bp);
-	if (rc)
-		return rc;
-
-	/* enable access to nvram interface */
-	bnx2x_enable_nvram_access(bp);
-
-	cmd_flags = (MCPR_NVM_COMMAND_FIRST | MCPR_NVM_COMMAND_LAST);
-	align_offset = (offset & ~0x03);
-	rc = bnx2x_nvram_read_dword(bp, align_offset, &val, cmd_flags);
-
-	if (rc == 0) {
-		val &= ~(0xff << BYTE_OFFSET(offset));
-		val |= (*data_buf << BYTE_OFFSET(offset));
-
-		/* nvram data is returned as an array of bytes
-		 * convert it back to cpu order */
-		val = be32_to_cpu(val);
-
-		rc = bnx2x_nvram_write_dword(bp, align_offset, val,
-					     cmd_flags);
-	}
-
-	/* disable access to nvram interface */
-	bnx2x_disable_nvram_access(bp);
-	bnx2x_release_nvram_lock(bp);
-
-	return rc;
-}
-
-static int bnx2x_nvram_write(struct bnx2x *bp, u32 offset, u8 *data_buf,
-			     int buf_size)
-{
-	int rc;
-	u32 cmd_flags;
-	u32 val;
-	u32 written_so_far;
-
-	if (buf_size == 1)	/* ethtool */
-		return bnx2x_nvram_write1(bp, offset, data_buf, buf_size);
-
-	if ((offset & 0x03) || (buf_size & 0x03) || (buf_size == 0)) {
-		DP(BNX2X_MSG_NVM,
-		   "Invalid parameter: offset 0x%x  buf_size 0x%x\n",
-		   offset, buf_size);
-		return -EINVAL;
-	}
-
-	if (offset + buf_size > bp->common.flash_size) {
-		DP(BNX2X_MSG_NVM, "Invalid parameter: offset (0x%x) +"
-				  " buf_size (0x%x) > flash_size (0x%x)\n",
-		   offset, buf_size, bp->common.flash_size);
-		return -EINVAL;
-	}
-
-	/* request access to nvram interface */
-	rc = bnx2x_acquire_nvram_lock(bp);
-	if (rc)
-		return rc;
-
-	/* enable access to nvram interface */
-	bnx2x_enable_nvram_access(bp);
-
-	written_so_far = 0;
-	cmd_flags = MCPR_NVM_COMMAND_FIRST;
-	while ((written_so_far < buf_size) && (rc == 0)) {
-		if (written_so_far == (buf_size - sizeof(u32)))
-			cmd_flags |= MCPR_NVM_COMMAND_LAST;
-		else if (((offset + 4) % NVRAM_PAGE_SIZE) == 0)
-			cmd_flags |= MCPR_NVM_COMMAND_LAST;
-		else if ((offset % NVRAM_PAGE_SIZE) == 0)
-			cmd_flags |= MCPR_NVM_COMMAND_FIRST;
-
-		memcpy(&val, data_buf, 4);
-
-		rc = bnx2x_nvram_write_dword(bp, offset, val, cmd_flags);
-
-		/* advance to the next dword */
-		offset += sizeof(u32);
-		data_buf += sizeof(u32);
-		written_so_far += sizeof(u32);
-		cmd_flags = 0;
-	}
-
-	/* disable access to nvram interface */
-	bnx2x_disable_nvram_access(bp);
-	bnx2x_release_nvram_lock(bp);
-
-	return rc;
-}
-
-static int bnx2x_set_eeprom(struct net_device *dev,
-			    struct ethtool_eeprom *eeprom, u8 *eebuf)
-{
-	struct bnx2x *bp = netdev_priv(dev);
-	int port = BP_PORT(bp);
-	int rc = 0;
-
-	if (!netif_running(dev))
-		return -EAGAIN;
-
-	DP(BNX2X_MSG_NVM, "ethtool_eeprom: cmd %d\n"
-	   DP_LEVEL "  magic 0x%x  offset 0x%x (%d)  len 0x%x (%d)\n",
-	   eeprom->cmd, eeprom->magic, eeprom->offset, eeprom->offset,
-	   eeprom->len, eeprom->len);
-
-	/* parameters already validated in ethtool_set_eeprom */
-
-	/* PHY eeprom can be accessed only by the PMF */
-	if ((eeprom->magic >= 0x50485900) && (eeprom->magic <= 0x504859FF) &&
-	    !bp->port.pmf)
-		return -EINVAL;
-
-	if (eeprom->magic == 0x50485950) {
-		/* 'PHYP' (0x50485950): prepare phy for FW upgrade */
-		bnx2x_stats_handle(bp, STATS_EVENT_STOP);
-
-		bnx2x_acquire_phy_lock(bp);
-		rc |= bnx2x_link_reset(&bp->link_params,
-				       &bp->link_vars, 0);
-		if (XGXS_EXT_PHY_TYPE(bp->link_params.ext_phy_config) ==
-					PORT_HW_CFG_XGXS_EXT_PHY_TYPE_SFX7101)
-			bnx2x_set_gpio(bp, MISC_REGISTERS_GPIO_0,
-				       MISC_REGISTERS_GPIO_HIGH, port);
-		bnx2x_release_phy_lock(bp);
-		bnx2x_link_report(bp);
-
-	} else if (eeprom->magic == 0x50485952) {
-		/* 'PHYR' (0x50485952): re-init link after FW upgrade */
-		if (bp->state == BNX2X_STATE_OPEN) {
-			bnx2x_acquire_phy_lock(bp);
-			rc |= bnx2x_link_reset(&bp->link_params,
-					       &bp->link_vars, 1);
-
-			rc |= bnx2x_phy_init(&bp->link_params,
-					     &bp->link_vars);
-			bnx2x_release_phy_lock(bp);
-			bnx2x_calc_fc_adv(bp);
-		}
-	} else if (eeprom->magic == 0x53985943) {
-		/* 'PHYC' (0x53985943): PHY FW upgrade completed */
-		if (XGXS_EXT_PHY_TYPE(bp->link_params.ext_phy_config) ==
-				       PORT_HW_CFG_XGXS_EXT_PHY_TYPE_SFX7101) {
-			u8 ext_phy_addr =
-			     XGXS_EXT_PHY_ADDR(bp->link_params.ext_phy_config);
-
-			/* DSP Remove Download Mode */
-			bnx2x_set_gpio(bp, MISC_REGISTERS_GPIO_0,
-				       MISC_REGISTERS_GPIO_LOW, port);
-
-			bnx2x_acquire_phy_lock(bp);
-
-			bnx2x_sfx7101_sp_sw_reset(bp, port, ext_phy_addr);
-
-			/* wait 0.5 sec to allow it to run */
-			msleep(500);
-			bnx2x_ext_phy_hw_reset(bp, port);
-			msleep(500);
-			bnx2x_release_phy_lock(bp);
-		}
-	} else
-		rc = bnx2x_nvram_write(bp, eeprom->offset, eebuf, eeprom->len);
-
-	return rc;
-}
-
-static int bnx2x_get_coalesce(struct net_device *dev,
-			      struct ethtool_coalesce *coal)
-{
-	struct bnx2x *bp = netdev_priv(dev);
-
-	memset(coal, 0, sizeof(struct ethtool_coalesce));
-
-	coal->rx_coalesce_usecs = bp->rx_ticks;
-	coal->tx_coalesce_usecs = bp->tx_ticks;
-
-	return 0;
-}
-
-#define BNX2X_MAX_COALES_TOUT  (0xf0*12) /* Maximal coalescing timeout in us */
-static int bnx2x_set_coalesce(struct net_device *dev,
-			      struct ethtool_coalesce *coal)
-{
-	struct bnx2x *bp = netdev_priv(dev);
-
-	bp->rx_ticks = (u16) coal->rx_coalesce_usecs;
-	if (bp->rx_ticks > BNX2X_MAX_COALES_TOUT)
-		bp->rx_ticks = BNX2X_MAX_COALES_TOUT;
-
-	bp->tx_ticks = (u16) coal->tx_coalesce_usecs;
-	if (bp->tx_ticks > BNX2X_MAX_COALES_TOUT)
-		bp->tx_ticks = BNX2X_MAX_COALES_TOUT;
-
-	if (netif_running(dev))
-		bnx2x_update_coalesce(bp);
-
-	return 0;
-}
-
-static void bnx2x_get_ringparam(struct net_device *dev,
-				struct ethtool_ringparam *ering)
-{
-	struct bnx2x *bp = netdev_priv(dev);
-
-	ering->rx_max_pending = MAX_RX_AVAIL;
-	ering->rx_mini_max_pending = 0;
-	ering->rx_jumbo_max_pending = 0;
-
-	ering->rx_pending = bp->rx_ring_size;
-	ering->rx_mini_pending = 0;
-	ering->rx_jumbo_pending = 0;
-
-	ering->tx_max_pending = MAX_TX_AVAIL;
-	ering->tx_pending = bp->tx_ring_size;
-}
-
-static int bnx2x_set_ringparam(struct net_device *dev,
-			       struct ethtool_ringparam *ering)
-{
-	struct bnx2x *bp = netdev_priv(dev);
-	int rc = 0;
-
-	if ((ering->rx_pending > MAX_RX_AVAIL) ||
-	    (ering->tx_pending > MAX_TX_AVAIL) ||
-	    (ering->tx_pending <= MAX_SKB_FRAGS + 4))
-		return -EINVAL;
-
-	bp->rx_ring_size = ering->rx_pending;
-	bp->tx_ring_size = ering->tx_pending;
-
-	if (netif_running(dev)) {
-		bnx2x_nic_unload(bp, UNLOAD_NORMAL);
-		rc = bnx2x_nic_load(bp, LOAD_NORMAL);
-	}
-
-	return rc;
-}
-
-static void bnx2x_get_pauseparam(struct net_device *dev,
-				 struct ethtool_pauseparam *epause)
-{
-	struct bnx2x *bp = netdev_priv(dev);
-
-	epause->autoneg = (bp->link_params.req_flow_ctrl ==
-			   BNX2X_FLOW_CTRL_AUTO) &&
-			  (bp->link_params.req_line_speed == SPEED_AUTO_NEG);
-
-	epause->rx_pause = ((bp->link_vars.flow_ctrl & BNX2X_FLOW_CTRL_RX) ==
-			    BNX2X_FLOW_CTRL_RX);
-	epause->tx_pause = ((bp->link_vars.flow_ctrl & BNX2X_FLOW_CTRL_TX) ==
-			    BNX2X_FLOW_CTRL_TX);
-
-	DP(NETIF_MSG_LINK, "ethtool_pauseparam: cmd %d\n"
-	   DP_LEVEL "  autoneg %d  rx_pause %d  tx_pause %d\n",
-	   epause->cmd, epause->autoneg, epause->rx_pause, epause->tx_pause);
-}
-
-static int bnx2x_set_pauseparam(struct net_device *dev,
-				struct ethtool_pauseparam *epause)
-{
-	struct bnx2x *bp = netdev_priv(dev);
-
-	if (IS_E1HMF(bp))
-		return 0;
-
-	DP(NETIF_MSG_LINK, "ethtool_pauseparam: cmd %d\n"
-	   DP_LEVEL "  autoneg %d  rx_pause %d  tx_pause %d\n",
-	   epause->cmd, epause->autoneg, epause->rx_pause, epause->tx_pause);
-
-	bp->link_params.req_flow_ctrl = BNX2X_FLOW_CTRL_AUTO;
-
-	if (epause->rx_pause)
-		bp->link_params.req_flow_ctrl |= BNX2X_FLOW_CTRL_RX;
-
-	if (epause->tx_pause)
-		bp->link_params.req_flow_ctrl |= BNX2X_FLOW_CTRL_TX;
-
-	if (bp->link_params.req_flow_ctrl == BNX2X_FLOW_CTRL_AUTO)
-		bp->link_params.req_flow_ctrl = BNX2X_FLOW_CTRL_NONE;
-
-	if (epause->autoneg) {
-		if (!(bp->port.supported & SUPPORTED_Autoneg)) {
-			DP(NETIF_MSG_LINK, "autoneg not supported\n");
-			return -EINVAL;
-		}
-
-		if (bp->link_params.req_line_speed == SPEED_AUTO_NEG)
-			bp->link_params.req_flow_ctrl = BNX2X_FLOW_CTRL_AUTO;
-	}
-
-	DP(NETIF_MSG_LINK,
-	   "req_flow_ctrl 0x%x\n", bp->link_params.req_flow_ctrl);
-
-	if (netif_running(dev)) {
-		bnx2x_stats_handle(bp, STATS_EVENT_STOP);
-		bnx2x_link_set(bp);
-	}
-
-	return 0;
-}
-
-static int bnx2x_set_flags(struct net_device *dev, u32 data)
-{
-	struct bnx2x *bp = netdev_priv(dev);
-	int changed = 0;
-	int rc = 0;
-
-	/* TPA requires Rx CSUM offloading */
-	if ((data & ETH_FLAG_LRO) && bp->rx_csum) {
-		if (!disable_tpa) {
-			if (!(dev->features & NETIF_F_LRO)) {
-				dev->features |= NETIF_F_LRO;
-				bp->flags |= TPA_ENABLE_FLAG;
-				changed = 1;
-			}
-		} else
-			rc = -EINVAL;
-	} else if (dev->features & NETIF_F_LRO) {
-		dev->features &= ~NETIF_F_LRO;
-		bp->flags &= ~TPA_ENABLE_FLAG;
-		changed = 1;
-	}
-
-	if (changed && netif_running(dev)) {
-		bnx2x_nic_unload(bp, UNLOAD_NORMAL);
-		rc = bnx2x_nic_load(bp, LOAD_NORMAL);
-	}
-
-	return rc;
-}
-
-static u32 bnx2x_get_rx_csum(struct net_device *dev)
-{
-	struct bnx2x *bp = netdev_priv(dev);
-
-	return bp->rx_csum;
-}
-
-static int bnx2x_set_rx_csum(struct net_device *dev, u32 data)
-{
-	struct bnx2x *bp = netdev_priv(dev);
-	int rc = 0;
-
-	bp->rx_csum = data;
-
-	/* Disable TPA, when Rx CSUM is disabled. Otherwise all
-	   TPA'ed packets will be discarded due to wrong TCP CSUM */
-	if (!data) {
-		u32 flags = ethtool_op_get_flags(dev);
-
-		rc = bnx2x_set_flags(dev, (flags & ~ETH_FLAG_LRO));
-	}
-
-	return rc;
-}
-
-static int bnx2x_set_tso(struct net_device *dev, u32 data)
-{
-	if (data) {
-		dev->features |= (NETIF_F_TSO | NETIF_F_TSO_ECN);
-		dev->features |= NETIF_F_TSO6;
-	} else {
-		dev->features &= ~(NETIF_F_TSO | NETIF_F_TSO_ECN);
-		dev->features &= ~NETIF_F_TSO6;
-	}
-
-	return 0;
-}
-
-static const struct {
-	char string[ETH_GSTRING_LEN];
-} bnx2x_tests_str_arr[BNX2X_NUM_TESTS] = {
-	{ "register_test (offline)" },
-	{ "memory_test (offline)" },
-	{ "loopback_test (offline)" },
-	{ "nvram_test (online)" },
-	{ "interrupt_test (online)" },
-	{ "link_test (online)" },
-	{ "idle check (online)" }
-};
-
-static int bnx2x_test_registers(struct bnx2x *bp)
-{
-	int idx, i, rc = -ENODEV;
-	u32 wr_val = 0;
-	int port = BP_PORT(bp);
-	static const struct {
-		u32  offset0;
-		u32  offset1;
-		u32  mask;
-	} reg_tbl[] = {
-/* 0 */		{ BRB1_REG_PAUSE_LOW_THRESHOLD_0,      4, 0x000003ff },
-		{ DORQ_REG_DB_ADDR0,                   4, 0xffffffff },
-		{ HC_REG_AGG_INT_0,                    4, 0x000003ff },
-		{ PBF_REG_MAC_IF0_ENABLE,              4, 0x00000001 },
-		{ PBF_REG_P0_INIT_CRD,                 4, 0x000007ff },
-		{ PRS_REG_CID_PORT_0,                  4, 0x00ffffff },
-		{ PXP2_REG_PSWRQ_CDU0_L2P,             4, 0x000fffff },
-		{ PXP2_REG_RQ_CDU0_EFIRST_MEM_ADDR,    8, 0x0003ffff },
-		{ PXP2_REG_PSWRQ_TM0_L2P,              4, 0x000fffff },
-		{ PXP2_REG_RQ_USDM0_EFIRST_MEM_ADDR,   8, 0x0003ffff },
-/* 10 */	{ PXP2_REG_PSWRQ_TSDM0_L2P,            4, 0x000fffff },
-		{ QM_REG_CONNNUM_0,                    4, 0x000fffff },
-		{ TM_REG_LIN0_MAX_ACTIVE_CID,          4, 0x0003ffff },
-		{ SRC_REG_KEYRSS0_0,                  40, 0xffffffff },
-		{ SRC_REG_KEYRSS0_7,                  40, 0xffffffff },
-		{ XCM_REG_WU_DA_SET_TMR_CNT_FLG_CMD00, 4, 0x00000001 },
-		{ XCM_REG_WU_DA_CNT_CMD00,             4, 0x00000003 },
-		{ XCM_REG_GLB_DEL_ACK_MAX_CNT_0,       4, 0x000000ff },
-		{ NIG_REG_LLH0_T_BIT,                  4, 0x00000001 },
-		{ NIG_REG_EMAC0_IN_EN,                 4, 0x00000001 },
-/* 20 */	{ NIG_REG_BMAC0_IN_EN,                 4, 0x00000001 },
-		{ NIG_REG_XCM0_OUT_EN,                 4, 0x00000001 },
-		{ NIG_REG_BRB0_OUT_EN,                 4, 0x00000001 },
-		{ NIG_REG_LLH0_XCM_MASK,               4, 0x00000007 },
-		{ NIG_REG_LLH0_ACPI_PAT_6_LEN,        68, 0x000000ff },
-		{ NIG_REG_LLH0_ACPI_PAT_0_CRC,        68, 0xffffffff },
-		{ NIG_REG_LLH0_DEST_MAC_0_0,         160, 0xffffffff },
-		{ NIG_REG_LLH0_DEST_IP_0_1,          160, 0xffffffff },
-		{ NIG_REG_LLH0_IPV4_IPV6_0,          160, 0x00000001 },
-		{ NIG_REG_LLH0_DEST_UDP_0,           160, 0x0000ffff },
-/* 30 */	{ NIG_REG_LLH0_DEST_TCP_0,           160, 0x0000ffff },
-		{ NIG_REG_LLH0_VLAN_ID_0,            160, 0x00000fff },
-		{ NIG_REG_XGXS_SERDES0_MODE_SEL,       4, 0x00000001 },
-		{ NIG_REG_LED_CONTROL_OVERRIDE_TRAFFIC_P0, 4, 0x00000001 },
-		{ NIG_REG_STATUS_INTERRUPT_PORT0,      4, 0x07ffffff },
-		{ NIG_REG_XGXS0_CTRL_EXTREMOTEMDIOST, 24, 0x00000001 },
-		{ NIG_REG_SERDES0_CTRL_PHY_ADDR,      16, 0x0000001f },
-
-		{ 0xffffffff, 0, 0x00000000 }
-	};
-
-	if (!netif_running(bp->dev))
-		return rc;
-
-	/* Repeat the test twice:
-	   First by writing 0x00000000, second by writing 0xffffffff */
-	for (idx = 0; idx < 2; idx++) {
-
-		switch (idx) {
-		case 0:
-			wr_val = 0;
-			break;
-		case 1:
-			wr_val = 0xffffffff;
-			break;
-		}
-
-		for (i = 0; reg_tbl[i].offset0 != 0xffffffff; i++) {
-			u32 offset, mask, save_val, val;
-
-			offset = reg_tbl[i].offset0 + port*reg_tbl[i].offset1;
-			mask = reg_tbl[i].mask;
-
-			save_val = REG_RD(bp, offset);
-
-			REG_WR(bp, offset, wr_val);
-			val = REG_RD(bp, offset);
-
-			/* Restore the original register's value */
-			REG_WR(bp, offset, save_val);
-
-			/* verify that value is as expected value */
-			if ((val & mask) != (wr_val & mask))
-				goto test_reg_exit;
-		}
-	}
-
-	rc = 0;
-
-test_reg_exit:
-	return rc;
-}
-
-static int bnx2x_test_memory(struct bnx2x *bp)
-{
-	int i, j, rc = -ENODEV;
-	u32 val;
-	static const struct {
-		u32 offset;
-		int size;
-	} mem_tbl[] = {
-		{ CCM_REG_XX_DESCR_TABLE,   CCM_REG_XX_DESCR_TABLE_SIZE },
-		{ CFC_REG_ACTIVITY_COUNTER, CFC_REG_ACTIVITY_COUNTER_SIZE },
-		{ CFC_REG_LINK_LIST,        CFC_REG_LINK_LIST_SIZE },
-		{ DMAE_REG_CMD_MEM,         DMAE_REG_CMD_MEM_SIZE },
-		{ TCM_REG_XX_DESCR_TABLE,   TCM_REG_XX_DESCR_TABLE_SIZE },
-		{ UCM_REG_XX_DESCR_TABLE,   UCM_REG_XX_DESCR_TABLE_SIZE },
-		{ XCM_REG_XX_DESCR_TABLE,   XCM_REG_XX_DESCR_TABLE_SIZE },
-
-		{ 0xffffffff, 0 }
-	};
-	static const struct {
-		char *name;
-		u32 offset;
-		u32 e1_mask;
-		u32 e1h_mask;
-	} prty_tbl[] = {
-		{ "CCM_PRTY_STS",  CCM_REG_CCM_PRTY_STS,   0x3ffc0, 0 },
-		{ "CFC_PRTY_STS",  CFC_REG_CFC_PRTY_STS,   0x2,     0x2 },
-		{ "DMAE_PRTY_STS", DMAE_REG_DMAE_PRTY_STS, 0,       0 },
-		{ "TCM_PRTY_STS",  TCM_REG_TCM_PRTY_STS,   0x3ffc0, 0 },
-		{ "UCM_PRTY_STS",  UCM_REG_UCM_PRTY_STS,   0x3ffc0, 0 },
-		{ "XCM_PRTY_STS",  XCM_REG_XCM_PRTY_STS,   0x3ffc1, 0 },
-
-		{ NULL, 0xffffffff, 0, 0 }
-	};
-
-	if (!netif_running(bp->dev))
-		return rc;
-
-	/* Go through all the memories */
-	for (i = 0; mem_tbl[i].offset != 0xffffffff; i++)
-		for (j = 0; j < mem_tbl[i].size; j++)
-			REG_RD(bp, mem_tbl[i].offset + j*4);
-
-	/* Check the parity status */
-	for (i = 0; prty_tbl[i].offset != 0xffffffff; i++) {
-		val = REG_RD(bp, prty_tbl[i].offset);
-		if ((CHIP_IS_E1(bp) && (val & ~(prty_tbl[i].e1_mask))) ||
-		    (CHIP_IS_E1H(bp) && (val & ~(prty_tbl[i].e1h_mask)))) {
-			DP(NETIF_MSG_HW,
-			   "%s is 0x%x\n", prty_tbl[i].name, val);
-			goto test_mem_exit;
-		}
-	}
-
-	rc = 0;
-
-test_mem_exit:
-	return rc;
-}
-
-static void bnx2x_wait_for_link(struct bnx2x *bp, u8 link_up)
-{
-	int cnt = 1000;
-
-	if (link_up)
-		while (bnx2x_link_test(bp) && cnt--)
-			msleep(10);
-}
-
-static int bnx2x_run_loopback(struct bnx2x *bp, int loopback_mode, u8 link_up)
-{
-	unsigned int pkt_size, num_pkts, i;
-	struct sk_buff *skb;
-	unsigned char *packet;
-	struct bnx2x_fastpath *fp_rx = &bp->fp[0];
-	struct bnx2x_fastpath *fp_tx = &bp->fp[0];
-	u16 tx_start_idx, tx_idx;
-	u16 rx_start_idx, rx_idx;
-	u16 pkt_prod, bd_prod;
-	struct sw_tx_bd *tx_buf;
-	struct eth_tx_start_bd *tx_start_bd;
-	struct eth_tx_parse_bd *pbd = NULL;
-	dma_addr_t mapping;
-	union eth_rx_cqe *cqe;
-	u8 cqe_fp_flags;
-	struct sw_rx_bd *rx_buf;
-	u16 len;
-	int rc = -ENODEV;
-
-	/* check the loopback mode */
-	switch (loopback_mode) {
-	case BNX2X_PHY_LOOPBACK:
-		if (bp->link_params.loopback_mode != LOOPBACK_XGXS_10)
-			return -EINVAL;
-		break;
-	case BNX2X_MAC_LOOPBACK:
-		bp->link_params.loopback_mode = LOOPBACK_BMAC;
-		bnx2x_phy_init(&bp->link_params, &bp->link_vars);
-		break;
-	default:
-		return -EINVAL;
-	}
-
-	/* prepare the loopback packet */
-	pkt_size = (((bp->dev->mtu < ETH_MAX_PACKET_SIZE) ?
-		     bp->dev->mtu : ETH_MAX_PACKET_SIZE) + ETH_HLEN);
-	skb = netdev_alloc_skb(bp->dev, bp->rx_buf_size);
-	if (!skb) {
-		rc = -ENOMEM;
-		goto test_loopback_exit;
-	}
-	packet = skb_put(skb, pkt_size);
-	memcpy(packet, bp->dev->dev_addr, ETH_ALEN);
-	memset(packet + ETH_ALEN, 0, ETH_ALEN);
-	memset(packet + 2*ETH_ALEN, 0x77, (ETH_HLEN - 2*ETH_ALEN));
-	for (i = ETH_HLEN; i < pkt_size; i++)
-		packet[i] = (unsigned char) (i & 0xff);
-
-	/* send the loopback packet */
-	num_pkts = 0;
-	tx_start_idx = le16_to_cpu(*fp_tx->tx_cons_sb);
-	rx_start_idx = le16_to_cpu(*fp_rx->rx_cons_sb);
-
-	pkt_prod = fp_tx->tx_pkt_prod++;
-	tx_buf = &fp_tx->tx_buf_ring[TX_BD(pkt_prod)];
-	tx_buf->first_bd = fp_tx->tx_bd_prod;
-	tx_buf->skb = skb;
-	tx_buf->flags = 0;
-
-	bd_prod = TX_BD(fp_tx->tx_bd_prod);
-	tx_start_bd = &fp_tx->tx_desc_ring[bd_prod].start_bd;
-	mapping = pci_map_single(bp->pdev, skb->data,
-				 skb_headlen(skb), PCI_DMA_TODEVICE);
-	tx_start_bd->addr_hi = cpu_to_le32(U64_HI(mapping));
-	tx_start_bd->addr_lo = cpu_to_le32(U64_LO(mapping));
-	tx_start_bd->nbd = cpu_to_le16(2); /* start + pbd */
-	tx_start_bd->nbytes = cpu_to_le16(skb_headlen(skb));
-	tx_start_bd->vlan = cpu_to_le16(pkt_prod);
-	tx_start_bd->bd_flags.as_bitfield = ETH_TX_BD_FLAGS_START_BD;
-	tx_start_bd->general_data = ((UNICAST_ADDRESS <<
-				ETH_TX_START_BD_ETH_ADDR_TYPE_SHIFT) | 1);
-
-	/* turn on parsing and get a BD */
-	bd_prod = TX_BD(NEXT_TX_IDX(bd_prod));
-	pbd = &fp_tx->tx_desc_ring[bd_prod].parse_bd;
-
-	memset(pbd, 0, sizeof(struct eth_tx_parse_bd));
-
-	wmb();
-
-	fp_tx->tx_db.data.prod += 2;
-	barrier();
-	DOORBELL(bp, fp_tx->index, fp_tx->tx_db.raw);
-
-	mmiowb();
-
-	num_pkts++;
-	fp_tx->tx_bd_prod += 2; /* start + pbd */
-
-	udelay(100);
-
-	tx_idx = le16_to_cpu(*fp_tx->tx_cons_sb);
-	if (tx_idx != tx_start_idx + num_pkts)
-		goto test_loopback_exit;
-
-	rx_idx = le16_to_cpu(*fp_rx->rx_cons_sb);
-	if (rx_idx != rx_start_idx + num_pkts)
-		goto test_loopback_exit;
-
-	cqe = &fp_rx->rx_comp_ring[RCQ_BD(fp_rx->rx_comp_cons)];
-	cqe_fp_flags = cqe->fast_path_cqe.type_error_flags;
-	if (CQE_TYPE(cqe_fp_flags) || (cqe_fp_flags & ETH_RX_ERROR_FALGS))
-		goto test_loopback_rx_exit;
-
-	len = le16_to_cpu(cqe->fast_path_cqe.pkt_len);
-	if (len != pkt_size)
-		goto test_loopback_rx_exit;
-
-	rx_buf = &fp_rx->rx_buf_ring[RX_BD(fp_rx->rx_bd_cons)];
-	skb = rx_buf->skb;
-	skb_reserve(skb, cqe->fast_path_cqe.placement_offset);
-	for (i = ETH_HLEN; i < pkt_size; i++)
-		if (*(skb->data + i) != (unsigned char) (i & 0xff))
-			goto test_loopback_rx_exit;
-
-	rc = 0;
-
-test_loopback_rx_exit:
-
-	fp_rx->rx_bd_cons = NEXT_RX_IDX(fp_rx->rx_bd_cons);
-	fp_rx->rx_bd_prod = NEXT_RX_IDX(fp_rx->rx_bd_prod);
-	fp_rx->rx_comp_cons = NEXT_RCQ_IDX(fp_rx->rx_comp_cons);
-	fp_rx->rx_comp_prod = NEXT_RCQ_IDX(fp_rx->rx_comp_prod);
-
-	/* Update producers */
-	bnx2x_update_rx_prod(bp, fp_rx, fp_rx->rx_bd_prod, fp_rx->rx_comp_prod,
-			     fp_rx->rx_sge_prod);
-
-test_loopback_exit:
-	bp->link_params.loopback_mode = LOOPBACK_NONE;
-
-	return rc;
-}
-
-static int bnx2x_test_loopback(struct bnx2x *bp, u8 link_up)
-{
-	int rc = 0, res;
-
-	if (!netif_running(bp->dev))
-		return BNX2X_LOOPBACK_FAILED;
-
-	bnx2x_netif_stop(bp, 1);
-	bnx2x_acquire_phy_lock(bp);
-
-	res = bnx2x_run_loopback(bp, BNX2X_PHY_LOOPBACK, link_up);
-	if (res) {
-		DP(NETIF_MSG_PROBE, "  PHY loopback failed  (res %d)\n", res);
-		rc |= BNX2X_PHY_LOOPBACK_FAILED;
-	}
-
-	res = bnx2x_run_loopback(bp, BNX2X_MAC_LOOPBACK, link_up);
-	if (res) {
-		DP(NETIF_MSG_PROBE, "  MAC loopback failed  (res %d)\n", res);
-		rc |= BNX2X_MAC_LOOPBACK_FAILED;
-	}
-
-	bnx2x_release_phy_lock(bp);
-	bnx2x_netif_start(bp);
-
-	return rc;
-}
-
-#define CRC32_RESIDUAL			0xdebb20e3
-
-static int bnx2x_test_nvram(struct bnx2x *bp)
-{
-	static const struct {
-		int offset;
-		int size;
-	} nvram_tbl[] = {
-		{     0,  0x14 }, /* bootstrap */
-		{  0x14,  0xec }, /* dir */
-		{ 0x100, 0x350 }, /* manuf_info */
-		{ 0x450,  0xf0 }, /* feature_info */
-		{ 0x640,  0x64 }, /* upgrade_key_info */
-		{ 0x6a4,  0x64 },
-		{ 0x708,  0x70 }, /* manuf_key_info */
-		{ 0x778,  0x70 },
-		{     0,     0 }
-	};
-	__be32 buf[0x350 / 4];
-	u8 *data = (u8 *)buf;
-	int i, rc;
-	u32 magic, crc;
-
-	rc = bnx2x_nvram_read(bp, 0, data, 4);
-	if (rc) {
-		DP(NETIF_MSG_PROBE, "magic value read (rc %d)\n", rc);
-		goto test_nvram_exit;
-	}
-
-	magic = be32_to_cpu(buf[0]);
-	if (magic != 0x669955aa) {
-		DP(NETIF_MSG_PROBE, "magic value (0x%08x)\n", magic);
-		rc = -ENODEV;
-		goto test_nvram_exit;
-	}
-
-	for (i = 0; nvram_tbl[i].size; i++) {
-
-		rc = bnx2x_nvram_read(bp, nvram_tbl[i].offset, data,
-				      nvram_tbl[i].size);
-		if (rc) {
-			DP(NETIF_MSG_PROBE,
-			   "nvram_tbl[%d] read data (rc %d)\n", i, rc);
-			goto test_nvram_exit;
-		}
-
-		crc = ether_crc_le(nvram_tbl[i].size, data);
-		if (crc != CRC32_RESIDUAL) {
-			DP(NETIF_MSG_PROBE,
-			   "nvram_tbl[%d] crc value (0x%08x)\n", i, crc);
-			rc = -ENODEV;
-			goto test_nvram_exit;
-		}
-	}
-
-test_nvram_exit:
-	return rc;
-}
-
-static int bnx2x_test_intr(struct bnx2x *bp)
-{
-	struct mac_configuration_cmd *config = bnx2x_sp(bp, mac_config);
-	int i, rc;
-
-	if (!netif_running(bp->dev))
-		return -ENODEV;
-
-	config->hdr.length = 0;
-	if (CHIP_IS_E1(bp))
-		/* use last unicast entries */
-		config->hdr.offset = (BP_PORT(bp) ? 63 : 31);
-	else
-		config->hdr.offset = BP_FUNC(bp);
-	config->hdr.client_id = bp->fp->cl_id;
-	config->hdr.reserved1 = 0;
-
-	bp->set_mac_pending++;
-	smp_wmb();
-	rc = bnx2x_sp_post(bp, RAMROD_CMD_ID_ETH_SET_MAC, 0,
-			   U64_HI(bnx2x_sp_mapping(bp, mac_config)),
-			   U64_LO(bnx2x_sp_mapping(bp, mac_config)), 0);
-	if (rc == 0) {
-		for (i = 0; i < 10; i++) {
-			if (!bp->set_mac_pending)
-				break;
-			smp_rmb();
-			msleep_interruptible(10);
-		}
-		if (i == 10)
-			rc = -ENODEV;
-	}
-
-	return rc;
-}
-
-static void bnx2x_self_test(struct net_device *dev,
-			    struct ethtool_test *etest, u64 *buf)
-{
-	struct bnx2x *bp = netdev_priv(dev);
-
-	memset(buf, 0, sizeof(u64) * BNX2X_NUM_TESTS);
-
-	if (!netif_running(dev))
-		return;
-
-	/* offline tests are not supported in MF mode */
-	if (IS_E1HMF(bp))
-		etest->flags &= ~ETH_TEST_FL_OFFLINE;
-
-	if (etest->flags & ETH_TEST_FL_OFFLINE) {
-		int port = BP_PORT(bp);
-		u32 val;
-		u8 link_up;
-
-		/* save current value of input enable for TX port IF */
-		val = REG_RD(bp, NIG_REG_EGRESS_UMP0_IN_EN + port*4);
-		/* disable input for TX port IF */
-		REG_WR(bp, NIG_REG_EGRESS_UMP0_IN_EN + port*4, 0);
-
-		link_up = (bnx2x_link_test(bp) == 0);
-		bnx2x_nic_unload(bp, UNLOAD_NORMAL);
-		bnx2x_nic_load(bp, LOAD_DIAG);
-		/* wait until link state is restored */
-		bnx2x_wait_for_link(bp, link_up);
-
-		if (bnx2x_test_registers(bp) != 0) {
-			buf[0] = 1;
-			etest->flags |= ETH_TEST_FL_FAILED;
-		}
-		if (bnx2x_test_memory(bp) != 0) {
-			buf[1] = 1;
-			etest->flags |= ETH_TEST_FL_FAILED;
-		}
-		buf[2] = bnx2x_test_loopback(bp, link_up);
-		if (buf[2] != 0)
-			etest->flags |= ETH_TEST_FL_FAILED;
-
-		bnx2x_nic_unload(bp, UNLOAD_NORMAL);
-
-		/* restore input for TX port IF */
-		REG_WR(bp, NIG_REG_EGRESS_UMP0_IN_EN + port*4, val);
-
-		bnx2x_nic_load(bp, LOAD_NORMAL);
-		/* wait until link state is restored */
-		bnx2x_wait_for_link(bp, link_up);
-	}
-	if (bnx2x_test_nvram(bp) != 0) {
-		buf[3] = 1;
-		etest->flags |= ETH_TEST_FL_FAILED;
-	}
-	if (bnx2x_test_intr(bp) != 0) {
-		buf[4] = 1;
-		etest->flags |= ETH_TEST_FL_FAILED;
-	}
-	if (bp->port.pmf)
-		if (bnx2x_link_test(bp) != 0) {
-			buf[5] = 1;
-			etest->flags |= ETH_TEST_FL_FAILED;
-		}
-
-#ifdef BNX2X_EXTRA_DEBUG
-	bnx2x_panic_dump(bp);
-#endif
-}
-
-static const struct {
-	long offset;
-	int size;
-	u8 string[ETH_GSTRING_LEN];
-} bnx2x_q_stats_arr[BNX2X_NUM_Q_STATS] = {
-/* 1 */	{ Q_STATS_OFFSET32(total_bytes_received_hi), 8, "[%d]: rx_bytes" },
-	{ Q_STATS_OFFSET32(error_bytes_received_hi),
-						8, "[%d]: rx_error_bytes" },
-	{ Q_STATS_OFFSET32(total_unicast_packets_received_hi),
-						8, "[%d]: rx_ucast_packets" },
-	{ Q_STATS_OFFSET32(total_multicast_packets_received_hi),
-						8, "[%d]: rx_mcast_packets" },
-	{ Q_STATS_OFFSET32(total_broadcast_packets_received_hi),
-						8, "[%d]: rx_bcast_packets" },
-	{ Q_STATS_OFFSET32(no_buff_discard_hi),	8, "[%d]: rx_discards" },
-	{ Q_STATS_OFFSET32(rx_err_discard_pkt),
-					 4, "[%d]: rx_phy_ip_err_discards"},
-	{ Q_STATS_OFFSET32(rx_skb_alloc_failed),
-					 4, "[%d]: rx_skb_alloc_discard" },
-	{ Q_STATS_OFFSET32(hw_csum_err), 4, "[%d]: rx_csum_offload_errors" },
-
-/* 10 */{ Q_STATS_OFFSET32(total_bytes_transmitted_hi),	8, "[%d]: tx_bytes" },
-	{ Q_STATS_OFFSET32(total_unicast_packets_transmitted_hi),
-							8, "[%d]: tx_packets" }
-};
-
-static const struct {
-	long offset;
-	int size;
-	u32 flags;
-#define STATS_FLAGS_PORT		1
-#define STATS_FLAGS_FUNC		2
-#define STATS_FLAGS_BOTH		(STATS_FLAGS_FUNC | STATS_FLAGS_PORT)
-	u8 string[ETH_GSTRING_LEN];
-} bnx2x_stats_arr[BNX2X_NUM_STATS] = {
-/* 1 */	{ STATS_OFFSET32(total_bytes_received_hi),
-				8, STATS_FLAGS_BOTH, "rx_bytes" },
-	{ STATS_OFFSET32(error_bytes_received_hi),
-				8, STATS_FLAGS_BOTH, "rx_error_bytes" },
-	{ STATS_OFFSET32(total_unicast_packets_received_hi),
-				8, STATS_FLAGS_BOTH, "rx_ucast_packets" },
-	{ STATS_OFFSET32(total_multicast_packets_received_hi),
-				8, STATS_FLAGS_BOTH, "rx_mcast_packets" },
-	{ STATS_OFFSET32(total_broadcast_packets_received_hi),
-				8, STATS_FLAGS_BOTH, "rx_bcast_packets" },
-	{ STATS_OFFSET32(rx_stat_dot3statsfcserrors_hi),
-				8, STATS_FLAGS_PORT, "rx_crc_errors" },
-	{ STATS_OFFSET32(rx_stat_dot3statsalignmenterrors_hi),
-				8, STATS_FLAGS_PORT, "rx_align_errors" },
-	{ STATS_OFFSET32(rx_stat_etherstatsundersizepkts_hi),
-				8, STATS_FLAGS_PORT, "rx_undersize_packets" },
-	{ STATS_OFFSET32(etherstatsoverrsizepkts_hi),
-				8, STATS_FLAGS_PORT, "rx_oversize_packets" },
-/* 10 */{ STATS_OFFSET32(rx_stat_etherstatsfragments_hi),
-				8, STATS_FLAGS_PORT, "rx_fragments" },
-	{ STATS_OFFSET32(rx_stat_etherstatsjabbers_hi),
-				8, STATS_FLAGS_PORT, "rx_jabbers" },
-	{ STATS_OFFSET32(no_buff_discard_hi),
-				8, STATS_FLAGS_BOTH, "rx_discards" },
-	{ STATS_OFFSET32(mac_filter_discard),
-				4, STATS_FLAGS_PORT, "rx_filtered_packets" },
-	{ STATS_OFFSET32(xxoverflow_discard),
-				4, STATS_FLAGS_PORT, "rx_fw_discards" },
-	{ STATS_OFFSET32(brb_drop_hi),
-				8, STATS_FLAGS_PORT, "rx_brb_discard" },
-	{ STATS_OFFSET32(brb_truncate_hi),
-				8, STATS_FLAGS_PORT, "rx_brb_truncate" },
-	{ STATS_OFFSET32(pause_frames_received_hi),
-				8, STATS_FLAGS_PORT, "rx_pause_frames" },
-	{ STATS_OFFSET32(rx_stat_maccontrolframesreceived_hi),
-				8, STATS_FLAGS_PORT, "rx_mac_ctrl_frames" },
-	{ STATS_OFFSET32(nig_timer_max),
-			4, STATS_FLAGS_PORT, "rx_constant_pause_events" },
-/* 20 */{ STATS_OFFSET32(rx_err_discard_pkt),
-				4, STATS_FLAGS_BOTH, "rx_phy_ip_err_discards"},
-	{ STATS_OFFSET32(rx_skb_alloc_failed),
-				4, STATS_FLAGS_BOTH, "rx_skb_alloc_discard" },
-	{ STATS_OFFSET32(hw_csum_err),
-				4, STATS_FLAGS_BOTH, "rx_csum_offload_errors" },
-
-	{ STATS_OFFSET32(total_bytes_transmitted_hi),
-				8, STATS_FLAGS_BOTH, "tx_bytes" },
-	{ STATS_OFFSET32(tx_stat_ifhcoutbadoctets_hi),
-				8, STATS_FLAGS_PORT, "tx_error_bytes" },
-	{ STATS_OFFSET32(total_unicast_packets_transmitted_hi),
-				8, STATS_FLAGS_BOTH, "tx_packets" },
-	{ STATS_OFFSET32(tx_stat_dot3statsinternalmactransmiterrors_hi),
-				8, STATS_FLAGS_PORT, "tx_mac_errors" },
-	{ STATS_OFFSET32(rx_stat_dot3statscarriersenseerrors_hi),
-				8, STATS_FLAGS_PORT, "tx_carrier_errors" },
-	{ STATS_OFFSET32(tx_stat_dot3statssinglecollisionframes_hi),
-				8, STATS_FLAGS_PORT, "tx_single_collisions" },
-	{ STATS_OFFSET32(tx_stat_dot3statsmultiplecollisionframes_hi),
-				8, STATS_FLAGS_PORT, "tx_multi_collisions" },
-/* 30 */{ STATS_OFFSET32(tx_stat_dot3statsdeferredtransmissions_hi),
-				8, STATS_FLAGS_PORT, "tx_deferred" },
-	{ STATS_OFFSET32(tx_stat_dot3statsexcessivecollisions_hi),
-				8, STATS_FLAGS_PORT, "tx_excess_collisions" },
-	{ STATS_OFFSET32(tx_stat_dot3statslatecollisions_hi),
-				8, STATS_FLAGS_PORT, "tx_late_collisions" },
-	{ STATS_OFFSET32(tx_stat_etherstatscollisions_hi),
-				8, STATS_FLAGS_PORT, "tx_total_collisions" },
-	{ STATS_OFFSET32(tx_stat_etherstatspkts64octets_hi),
-				8, STATS_FLAGS_PORT, "tx_64_byte_packets" },
-	{ STATS_OFFSET32(tx_stat_etherstatspkts65octetsto127octets_hi),
-			8, STATS_FLAGS_PORT, "tx_65_to_127_byte_packets" },
-	{ STATS_OFFSET32(tx_stat_etherstatspkts128octetsto255octets_hi),
-			8, STATS_FLAGS_PORT, "tx_128_to_255_byte_packets" },
-	{ STATS_OFFSET32(tx_stat_etherstatspkts256octetsto511octets_hi),
-			8, STATS_FLAGS_PORT, "tx_256_to_511_byte_packets" },
-	{ STATS_OFFSET32(tx_stat_etherstatspkts512octetsto1023octets_hi),
-			8, STATS_FLAGS_PORT, "tx_512_to_1023_byte_packets" },
-	{ STATS_OFFSET32(etherstatspkts1024octetsto1522octets_hi),
-			8, STATS_FLAGS_PORT, "tx_1024_to_1522_byte_packets" },
-/* 40 */{ STATS_OFFSET32(etherstatspktsover1522octets_hi),
-			8, STATS_FLAGS_PORT, "tx_1523_to_9022_byte_packets" },
-	{ STATS_OFFSET32(pause_frames_sent_hi),
-				8, STATS_FLAGS_PORT, "tx_pause_frames" }
-};
-
-#define IS_PORT_STAT(i) \
-	((bnx2x_stats_arr[i].flags & STATS_FLAGS_BOTH) == STATS_FLAGS_PORT)
-#define IS_FUNC_STAT(i)		(bnx2x_stats_arr[i].flags & STATS_FLAGS_FUNC)
-#define IS_E1HMF_MODE_STAT(bp) \
-			(IS_E1HMF(bp) && !(bp->msg_enable & BNX2X_MSG_STATS))
-
-static int bnx2x_get_sset_count(struct net_device *dev, int stringset)
-{
-	struct bnx2x *bp = netdev_priv(dev);
-	int i, num_stats;
-
-	switch(stringset) {
-	case ETH_SS_STATS:
-		if (is_multi(bp)) {
-			num_stats = BNX2X_NUM_Q_STATS * bp->num_queues;
-			if (!IS_E1HMF_MODE_STAT(bp))
-				num_stats += BNX2X_NUM_STATS;
-		} else {
-			if (IS_E1HMF_MODE_STAT(bp)) {
-				num_stats = 0;
-				for (i = 0; i < BNX2X_NUM_STATS; i++)
-					if (IS_FUNC_STAT(i))
-						num_stats++;
-			} else
-				num_stats = BNX2X_NUM_STATS;
-		}
-		return num_stats;
-
-	case ETH_SS_TEST:
-		return BNX2X_NUM_TESTS;
-
-	default:
-		return -EINVAL;
-	}
-}
-
-static void bnx2x_get_strings(struct net_device *dev, u32 stringset, u8 *buf)
-{
-	struct bnx2x *bp = netdev_priv(dev);
-	int i, j, k;
-
-	switch (stringset) {
-	case ETH_SS_STATS:
-		if (is_multi(bp)) {
-			k = 0;
-			for_each_queue(bp, i) {
-				for (j = 0; j < BNX2X_NUM_Q_STATS; j++)
-					sprintf(buf + (k + j)*ETH_GSTRING_LEN,
-						bnx2x_q_stats_arr[j].string, i);
-				k += BNX2X_NUM_Q_STATS;
-			}
-			if (IS_E1HMF_MODE_STAT(bp))
-				break;
-			for (j = 0; j < BNX2X_NUM_STATS; j++)
-				strcpy(buf + (k + j)*ETH_GSTRING_LEN,
-				       bnx2x_stats_arr[j].string);
-		} else {
-			for (i = 0, j = 0; i < BNX2X_NUM_STATS; i++) {
-				if (IS_E1HMF_MODE_STAT(bp) && IS_PORT_STAT(i))
-					continue;
-				strcpy(buf + j*ETH_GSTRING_LEN,
-				       bnx2x_stats_arr[i].string);
-				j++;
-			}
-		}
-		break;
-
-	case ETH_SS_TEST:
-		memcpy(buf, bnx2x_tests_str_arr, sizeof(bnx2x_tests_str_arr));
-		break;
-	}
-}
-
-static void bnx2x_get_ethtool_stats(struct net_device *dev,
-				    struct ethtool_stats *stats, u64 *buf)
-{
-	struct bnx2x *bp = netdev_priv(dev);
-	u32 *hw_stats, *offset;
-	int i, j, k;
-
-	if (is_multi(bp)) {
-		k = 0;
-		for_each_queue(bp, i) {
-			hw_stats = (u32 *)&bp->fp[i].eth_q_stats;
-			for (j = 0; j < BNX2X_NUM_Q_STATS; j++) {
-				if (bnx2x_q_stats_arr[j].size == 0) {
-					/* skip this counter */
-					buf[k + j] = 0;
-					continue;
-				}
-				offset = (hw_stats +
-					  bnx2x_q_stats_arr[j].offset);
-				if (bnx2x_q_stats_arr[j].size == 4) {
-					/* 4-byte counter */
-					buf[k + j] = (u64) *offset;
-					continue;
-				}
-				/* 8-byte counter */
-				buf[k + j] = HILO_U64(*offset, *(offset + 1));
-			}
-			k += BNX2X_NUM_Q_STATS;
-		}
-		if (IS_E1HMF_MODE_STAT(bp))
-			return;
-		hw_stats = (u32 *)&bp->eth_stats;
-		for (j = 0; j < BNX2X_NUM_STATS; j++) {
-			if (bnx2x_stats_arr[j].size == 0) {
-				/* skip this counter */
-				buf[k + j] = 0;
-				continue;
-			}
-			offset = (hw_stats + bnx2x_stats_arr[j].offset);
-			if (bnx2x_stats_arr[j].size == 4) {
-				/* 4-byte counter */
-				buf[k + j] = (u64) *offset;
-				continue;
-			}
-			/* 8-byte counter */
-			buf[k + j] = HILO_U64(*offset, *(offset + 1));
-		}
-	} else {
-		hw_stats = (u32 *)&bp->eth_stats;
-		for (i = 0, j = 0; i < BNX2X_NUM_STATS; i++) {
-			if (IS_E1HMF_MODE_STAT(bp) && IS_PORT_STAT(i))
-				continue;
-			if (bnx2x_stats_arr[i].size == 0) {
-				/* skip this counter */
-				buf[j] = 0;
-				j++;
-				continue;
-			}
-			offset = (hw_stats + bnx2x_stats_arr[i].offset);
-			if (bnx2x_stats_arr[i].size == 4) {
-				/* 4-byte counter */
-				buf[j] = (u64) *offset;
-				j++;
-				continue;
-			}
-			/* 8-byte counter */
-			buf[j] = HILO_U64(*offset, *(offset + 1));
-			j++;
-		}
-	}
-}
-
-static int bnx2x_phys_id(struct net_device *dev, u32 data)
-{
-	struct bnx2x *bp = netdev_priv(dev);
-	int i;
-
-	if (!netif_running(dev))
-		return 0;
-
-	if (!bp->port.pmf)
-		return 0;
-
-	if (data == 0)
-		data = 2;
-
-	for (i = 0; i < (data * 2); i++) {
-		if ((i % 2) == 0)
-			bnx2x_set_led(&bp->link_params, LED_MODE_OPER,
-				      SPEED_1000);
-		else
-			bnx2x_set_led(&bp->link_params, LED_MODE_OFF, 0);
-
-		msleep_interruptible(500);
-		if (signal_pending(current))
-			break;
-	}
-
-	if (bp->link_vars.link_up)
-		bnx2x_set_led(&bp->link_params, LED_MODE_OPER,
-			      bp->link_vars.line_speed);
-
-	return 0;
-}
-
-static const struct ethtool_ops bnx2x_ethtool_ops = {
-	.get_settings		= bnx2x_get_settings,
-	.set_settings		= bnx2x_set_settings,
-	.get_drvinfo		= bnx2x_get_drvinfo,
-	.get_regs_len		= bnx2x_get_regs_len,
-	.get_regs		= bnx2x_get_regs,
-	.get_wol		= bnx2x_get_wol,
-	.set_wol		= bnx2x_set_wol,
-	.get_msglevel		= bnx2x_get_msglevel,
-	.set_msglevel		= bnx2x_set_msglevel,
-	.nway_reset		= bnx2x_nway_reset,
-	.get_link		= bnx2x_get_link,
-	.get_eeprom_len		= bnx2x_get_eeprom_len,
-	.get_eeprom		= bnx2x_get_eeprom,
-	.set_eeprom		= bnx2x_set_eeprom,
-	.get_coalesce		= bnx2x_get_coalesce,
-	.set_coalesce		= bnx2x_set_coalesce,
-	.get_ringparam		= bnx2x_get_ringparam,
-	.set_ringparam		= bnx2x_set_ringparam,
-	.get_pauseparam		= bnx2x_get_pauseparam,
-	.set_pauseparam		= bnx2x_set_pauseparam,
-	.get_rx_csum		= bnx2x_get_rx_csum,
-	.set_rx_csum		= bnx2x_set_rx_csum,
-	.get_tx_csum		= ethtool_op_get_tx_csum,
-	.set_tx_csum		= ethtool_op_set_tx_hw_csum,
-	.set_flags		= bnx2x_set_flags,
-	.get_flags		= ethtool_op_get_flags,
-	.get_sg			= ethtool_op_get_sg,
-	.set_sg			= ethtool_op_set_sg,
-	.get_tso		= ethtool_op_get_tso,
-	.set_tso		= bnx2x_set_tso,
-	.self_test		= bnx2x_self_test,
-	.get_sset_count		= bnx2x_get_sset_count,
-	.get_strings		= bnx2x_get_strings,
-	.phys_id		= bnx2x_phys_id,
-	.get_ethtool_stats	= bnx2x_get_ethtool_stats,
-};
-
-/* end of ethtool_ops */
-
-/****************************************************************************
-* General service functions
-****************************************************************************/
-
-static int bnx2x_set_power_state(struct bnx2x *bp, pci_power_t state)
-{
-	u16 pmcsr;
-
-	pci_read_config_word(bp->pdev, bp->pm_cap + PCI_PM_CTRL, &pmcsr);
-
-	switch (state) {
-	case PCI_D0:
-		pci_write_config_word(bp->pdev, bp->pm_cap + PCI_PM_CTRL,
-				      ((pmcsr & ~PCI_PM_CTRL_STATE_MASK) |
-				       PCI_PM_CTRL_PME_STATUS));
-
-		if (pmcsr & PCI_PM_CTRL_STATE_MASK)
-			/* delay required during transition out of D3hot */
-			msleep(20);
-		break;
-
-	case PCI_D3hot:
-		pmcsr &= ~PCI_PM_CTRL_STATE_MASK;
-		pmcsr |= 3;
-
-		if (bp->wol)
-			pmcsr |= PCI_PM_CTRL_PME_ENABLE;
-
-		pci_write_config_word(bp->pdev, bp->pm_cap + PCI_PM_CTRL,
-				      pmcsr);
-
-		/* No more memory access after this point until
-		* device is brought back to D0.
-		*/
-		break;
-
-	default:
-		return -EINVAL;
-	}
-	return 0;
-}
-
-static inline int bnx2x_has_rx_work(struct bnx2x_fastpath *fp)
-{
-	u16 rx_cons_sb;
-
-	/* Tell compiler that status block fields can change */
-	barrier();
-	rx_cons_sb = le16_to_cpu(*fp->rx_cons_sb);
-	if ((rx_cons_sb & MAX_RCQ_DESC_CNT) == MAX_RCQ_DESC_CNT)
-		rx_cons_sb++;
-	return (fp->rx_comp_cons != rx_cons_sb);
-}
-
-/*
- * net_device service functions
- */
-
-static int bnx2x_poll(struct napi_struct *napi, int budget)
-{
-	int work_done = 0;
-	struct bnx2x_fastpath *fp = container_of(napi, struct bnx2x_fastpath,
-						 napi);
-	struct bnx2x *bp = fp->bp;
-
-	while (1) {
-#ifdef BNX2X_STOP_ON_ERROR
-		if (unlikely(bp->panic)) {
-			napi_complete(napi);
-			return 0;
-		}
-#endif
-
-		if (bnx2x_has_tx_work(fp))
-			bnx2x_tx_int(fp);
-
-		if (bnx2x_has_rx_work(fp)) {
-			work_done += bnx2x_rx_int(fp, budget - work_done);
-
-			/* must not complete if we consumed full budget */
-			if (work_done >= budget)
-				break;
-		}
-
-		/* Fall out from the NAPI loop if needed */
-		if (!(bnx2x_has_rx_work(fp) || bnx2x_has_tx_work(fp))) {
-			bnx2x_update_fpsb_idx(fp);
-		/* bnx2x_has_rx_work() reads the status block, thus we need
-		 * to ensure that status block indices have been actually read
-		 * (bnx2x_update_fpsb_idx) prior to this check
-		 * (bnx2x_has_rx_work) so that we won't write the "newer"
-		 * value of the status block to IGU (if there was a DMA right
-		 * after bnx2x_has_rx_work and if there is no rmb, the memory
-		 * reading (bnx2x_update_fpsb_idx) may be postponed to right
-		 * before bnx2x_ack_sb). In this case there will never be
-		 * another interrupt until there is another update of the
-		 * status block, while there is still unhandled work.
-		 */
-			rmb();
-
-			if (!(bnx2x_has_rx_work(fp) || bnx2x_has_tx_work(fp))) {
-				napi_complete(napi);
-				/* Re-enable interrupts */
-				bnx2x_ack_sb(bp, fp->sb_id, CSTORM_ID,
-					     le16_to_cpu(fp->fp_c_idx),
-					     IGU_INT_NOP, 1);
-				bnx2x_ack_sb(bp, fp->sb_id, USTORM_ID,
-					     le16_to_cpu(fp->fp_u_idx),
-					     IGU_INT_ENABLE, 1);
-				break;
-			}
-		}
-	}
-
-	return work_done;
-}
-
-
-/* we split the first BD into headers and data BDs
- * to ease the pain of our fellow microcode engineers
- * we use one mapping for both BDs
- * So far this has only been observed to happen
- * in Other Operating Systems(TM)
- */
-static noinline u16 bnx2x_tx_split(struct bnx2x *bp,
-				   struct bnx2x_fastpath *fp,
-				   struct sw_tx_bd *tx_buf,
-				   struct eth_tx_start_bd **tx_bd, u16 hlen,
-				   u16 bd_prod, int nbd)
-{
-	struct eth_tx_start_bd *h_tx_bd = *tx_bd;
-	struct eth_tx_bd *d_tx_bd;
-	dma_addr_t mapping;
-	int old_len = le16_to_cpu(h_tx_bd->nbytes);
-
-	/* first fix first BD */
-	h_tx_bd->nbd = cpu_to_le16(nbd);
-	h_tx_bd->nbytes = cpu_to_le16(hlen);
-
-	DP(NETIF_MSG_TX_QUEUED,	"TSO split header size is %d "
-	   "(%x:%x) nbd %d\n", h_tx_bd->nbytes, h_tx_bd->addr_hi,
-	   h_tx_bd->addr_lo, h_tx_bd->nbd);
-
-	/* now get a new data BD
-	 * (after the pbd) and fill it */
-	bd_prod = TX_BD(NEXT_TX_IDX(bd_prod));
-	d_tx_bd = &fp->tx_desc_ring[bd_prod].reg_bd;
-
-	mapping = HILO_U64(le32_to_cpu(h_tx_bd->addr_hi),
-			   le32_to_cpu(h_tx_bd->addr_lo)) + hlen;
-
-	d_tx_bd->addr_hi = cpu_to_le32(U64_HI(mapping));
-	d_tx_bd->addr_lo = cpu_to_le32(U64_LO(mapping));
-	d_tx_bd->nbytes = cpu_to_le16(old_len - hlen);
-
-	/* this marks the BD as one that has no individual mapping */
-	tx_buf->flags |= BNX2X_TSO_SPLIT_BD;
-
-	DP(NETIF_MSG_TX_QUEUED,
-	   "TSO split data size is %d (%x:%x)\n",
-	   d_tx_bd->nbytes, d_tx_bd->addr_hi, d_tx_bd->addr_lo);
-
-	/* update tx_bd */
-	*tx_bd = (struct eth_tx_start_bd *)d_tx_bd;
-
-	return bd_prod;
-}
-
-static inline u16 bnx2x_csum_fix(unsigned char *t_header, u16 csum, s8 fix)
-{
-	if (fix > 0)
-		csum = (u16) ~csum_fold(csum_sub(csum,
-				csum_partial(t_header - fix, fix, 0)));
-
-	else if (fix < 0)
-		csum = (u16) ~csum_fold(csum_add(csum,
-				csum_partial(t_header, -fix, 0)));
-
-	return swab16(csum);
-}
-
-static inline u32 bnx2x_xmit_type(struct bnx2x *bp, struct sk_buff *skb)
-{
-	u32 rc;
-
-	if (skb->ip_summed != CHECKSUM_PARTIAL)
-		rc = XMIT_PLAIN;
-
-	else {
-		if (skb->protocol == htons(ETH_P_IPV6)) {
-			rc = XMIT_CSUM_V6;
-			if (ipv6_hdr(skb)->nexthdr == IPPROTO_TCP)
-				rc |= XMIT_CSUM_TCP;
-
-		} else {
-			rc = XMIT_CSUM_V4;
-			if (ip_hdr(skb)->protocol == IPPROTO_TCP)
-				rc |= XMIT_CSUM_TCP;
-		}
-	}
-
-	if (skb_shinfo(skb)->gso_type & SKB_GSO_TCPV4)
-		rc |= (XMIT_GSO_V4 | XMIT_CSUM_V4 | XMIT_CSUM_TCP);
-
-	else if (skb_shinfo(skb)->gso_type & SKB_GSO_TCPV6)
-		rc |= (XMIT_GSO_V6 | XMIT_CSUM_TCP | XMIT_CSUM_V6);
-
-	return rc;
-}
-
-#if (MAX_SKB_FRAGS >= MAX_FETCH_BD - 3)
-/* check if packet requires linearization (packet is too fragmented)
-   no need to check fragmentation if page size > 8K (there will be no
-   violation to FW restrictions) */
-static int bnx2x_pkt_req_lin(struct bnx2x *bp, struct sk_buff *skb,
-			     u32 xmit_type)
-{
-	int to_copy = 0;
-	int hlen = 0;
-	int first_bd_sz = 0;
-
-	/* 3 = 1 (for linear data BD) + 2 (for PBD and last BD) */
-	if (skb_shinfo(skb)->nr_frags >= (MAX_FETCH_BD - 3)) {
-
-		if (xmit_type & XMIT_GSO) {
-			unsigned short lso_mss = skb_shinfo(skb)->gso_size;
-			/* Check if LSO packet needs to be copied:
-			   3 = 1 (for headers BD) + 2 (for PBD and last BD) */
-			int wnd_size = MAX_FETCH_BD - 3;
-			/* Number of windows to check */
-			int num_wnds = skb_shinfo(skb)->nr_frags - wnd_size;
-			int wnd_idx = 0;
-			int frag_idx = 0;
-			u32 wnd_sum = 0;
-
-			/* Headers length */
-			hlen = (int)(skb_transport_header(skb) - skb->data) +
-				tcp_hdrlen(skb);
-
-			/* Amount of data (w/o headers) on linear part of SKB*/
-			first_bd_sz = skb_headlen(skb) - hlen;
-
-			wnd_sum  = first_bd_sz;
-
-			/* Calculate the first sum - it's special */
-			for (frag_idx = 0; frag_idx < wnd_size - 1; frag_idx++)
-				wnd_sum +=
-					skb_shinfo(skb)->frags[frag_idx].size;
-
-			/* If there was data on linear skb data - check it */
-			if (first_bd_sz > 0) {
-				if (unlikely(wnd_sum < lso_mss)) {
-					to_copy = 1;
-					goto exit_lbl;
-				}
-
-				wnd_sum -= first_bd_sz;
-			}
-
-			/* Others are easier: run through the frag list and
-			   check all windows */
-			for (wnd_idx = 0; wnd_idx <= num_wnds; wnd_idx++) {
-				wnd_sum +=
-			  skb_shinfo(skb)->frags[wnd_idx + wnd_size - 1].size;
-
-				if (unlikely(wnd_sum < lso_mss)) {
-					to_copy = 1;
-					break;
-				}
-				wnd_sum -=
-					skb_shinfo(skb)->frags[wnd_idx].size;
-			}
-		} else {
-			/* in non-LSO too fragmented packet should always
-			   be linearized */
-			to_copy = 1;
-		}
-	}
-
-exit_lbl:
-	if (unlikely(to_copy))
-		DP(NETIF_MSG_TX_QUEUED,
-		   "Linearization IS REQUIRED for %s packet. "
-		   "num_frags %d  hlen %d  first_bd_sz %d\n",
-		   (xmit_type & XMIT_GSO) ? "LSO" : "non-LSO",
-		   skb_shinfo(skb)->nr_frags, hlen, first_bd_sz);
-
-	return to_copy;
-}
-#endif
-
-/* called with netif_tx_lock
- * bnx2x_tx_int() runs without netif_tx_lock unless it needs to call
- * netif_wake_queue()
- */
-static netdev_tx_t bnx2x_start_xmit(struct sk_buff *skb, struct net_device *dev)
-{
-	struct bnx2x *bp = netdev_priv(dev);
-	struct bnx2x_fastpath *fp;
-	struct netdev_queue *txq;
-	struct sw_tx_bd *tx_buf;
-	struct eth_tx_start_bd *tx_start_bd;
-	struct eth_tx_bd *tx_data_bd, *total_pkt_bd = NULL;
-	struct eth_tx_parse_bd *pbd = NULL;
-	u16 pkt_prod, bd_prod;
-	int nbd, fp_index;
-	dma_addr_t mapping;
-	u32 xmit_type = bnx2x_xmit_type(bp, skb);
-	int i;
-	u8 hlen = 0;
-	__le16 pkt_size = 0;
-
-#ifdef BNX2X_STOP_ON_ERROR
-	if (unlikely(bp->panic))
-		return NETDEV_TX_BUSY;
-#endif
-
-	fp_index = skb_get_queue_mapping(skb);
-	txq = netdev_get_tx_queue(dev, fp_index);
-
-	fp = &bp->fp[fp_index];
-
-	if (unlikely(bnx2x_tx_avail(fp) < (skb_shinfo(skb)->nr_frags + 3))) {
-		fp->eth_q_stats.driver_xoff++;
-		netif_tx_stop_queue(txq);
-		BNX2X_ERR("BUG! Tx ring full when queue awake!\n");
-		return NETDEV_TX_BUSY;
-	}
-
-	DP(NETIF_MSG_TX_QUEUED, "SKB: summed %x  protocol %x  protocol(%x,%x)"
-	   "  gso type %x  xmit_type %x\n",
-	   skb->ip_summed, skb->protocol, ipv6_hdr(skb)->nexthdr,
-	   ip_hdr(skb)->protocol, skb_shinfo(skb)->gso_type, xmit_type);
-
-#if (MAX_SKB_FRAGS >= MAX_FETCH_BD - 3)
-	/* First, check if we need to linearize the skb (due to FW
-	   restrictions). No need to check fragmentation if page size > 8K
-	   (there will be no violation to FW restrictions) */
-	if (bnx2x_pkt_req_lin(bp, skb, xmit_type)) {
-		/* Statistics of linearization */
-		bp->lin_cnt++;
-		if (skb_linearize(skb) != 0) {
-			DP(NETIF_MSG_TX_QUEUED, "SKB linearization failed - "
-			   "silently dropping this SKB\n");
-			dev_kfree_skb_any(skb);
-			return NETDEV_TX_OK;
-		}
-	}
-#endif
-
-	/*
-	Please read carefully. First we use one BD which we mark as start,
-	then we have a parsing info BD (used for TSO or xsum),
-	and only then we have the rest of the TSO BDs.
-	(don't forget to mark the last one as last,
-	and to unmap only AFTER you write to the BD ...)
-	And above all, all pdb sizes are in words - NOT DWORDS!
-	*/
-
-	pkt_prod = fp->tx_pkt_prod++;
-	bd_prod = TX_BD(fp->tx_bd_prod);
-
-	/* get a tx_buf and first BD */
-	tx_buf = &fp->tx_buf_ring[TX_BD(pkt_prod)];
-	tx_start_bd = &fp->tx_desc_ring[bd_prod].start_bd;
-
-	tx_start_bd->bd_flags.as_bitfield = ETH_TX_BD_FLAGS_START_BD;
-	tx_start_bd->general_data = (UNICAST_ADDRESS <<
-				     ETH_TX_START_BD_ETH_ADDR_TYPE_SHIFT);
-	/* header nbd */
-	tx_start_bd->general_data |= (1 << ETH_TX_START_BD_HDR_NBDS_SHIFT);
-
-	/* remember the first BD of the packet */
-	tx_buf->first_bd = fp->tx_bd_prod;
-	tx_buf->skb = skb;
-	tx_buf->flags = 0;
-
-	DP(NETIF_MSG_TX_QUEUED,
-	   "sending pkt %u @%p  next_idx %u  bd %u @%p\n",
-	   pkt_prod, tx_buf, fp->tx_pkt_prod, bd_prod, tx_start_bd);
-
-#ifdef BCM_VLAN
-	if ((bp->vlgrp != NULL) && vlan_tx_tag_present(skb) &&
-	    (bp->flags & HW_VLAN_TX_FLAG)) {
-		tx_start_bd->vlan = cpu_to_le16(vlan_tx_tag_get(skb));
-		tx_start_bd->bd_flags.as_bitfield |= ETH_TX_BD_FLAGS_VLAN_TAG;
-	} else
-#endif
-		tx_start_bd->vlan = cpu_to_le16(pkt_prod);
-
-	/* turn on parsing and get a BD */
-	bd_prod = TX_BD(NEXT_TX_IDX(bd_prod));
-	pbd = &fp->tx_desc_ring[bd_prod].parse_bd;
-
-	memset(pbd, 0, sizeof(struct eth_tx_parse_bd));
-
-	if (xmit_type & XMIT_CSUM) {
-		hlen = (skb_network_header(skb) - skb->data) / 2;
-
-		/* for now NS flag is not used in Linux */
-		pbd->global_data =
-			(hlen | ((skb->protocol == cpu_to_be16(ETH_P_8021Q)) <<
-				 ETH_TX_PARSE_BD_LLC_SNAP_EN_SHIFT));
-
-		pbd->ip_hlen = (skb_transport_header(skb) -
-				skb_network_header(skb)) / 2;
-
-		hlen += pbd->ip_hlen + tcp_hdrlen(skb) / 2;
-
-		pbd->total_hlen = cpu_to_le16(hlen);
-		hlen = hlen*2;
-
-		tx_start_bd->bd_flags.as_bitfield |= ETH_TX_BD_FLAGS_L4_CSUM;
-
-		if (xmit_type & XMIT_CSUM_V4)
-			tx_start_bd->bd_flags.as_bitfield |=
-						ETH_TX_BD_FLAGS_IP_CSUM;
-		else
-			tx_start_bd->bd_flags.as_bitfield |=
-						ETH_TX_BD_FLAGS_IPV6;
-
-		if (xmit_type & XMIT_CSUM_TCP) {
-			pbd->tcp_pseudo_csum = swab16(tcp_hdr(skb)->check);
-
-		} else {
-			s8 fix = SKB_CS_OFF(skb); /* signed! */
-
-			pbd->global_data |= ETH_TX_PARSE_BD_UDP_CS_FLG;
-
-			DP(NETIF_MSG_TX_QUEUED,
-			   "hlen %d  fix %d  csum before fix %x\n",
-			   le16_to_cpu(pbd->total_hlen), fix, SKB_CS(skb));
-
-			/* HW bug: fixup the CSUM */
-			pbd->tcp_pseudo_csum =
-				bnx2x_csum_fix(skb_transport_header(skb),
-					       SKB_CS(skb), fix);
-
-			DP(NETIF_MSG_TX_QUEUED, "csum after fix %x\n",
-			   pbd->tcp_pseudo_csum);
-		}
-	}
-
-	mapping = pci_map_single(bp->pdev, skb->data,
-				 skb_headlen(skb), PCI_DMA_TODEVICE);
-
-	tx_start_bd->addr_hi = cpu_to_le32(U64_HI(mapping));
-	tx_start_bd->addr_lo = cpu_to_le32(U64_LO(mapping));
-	nbd = skb_shinfo(skb)->nr_frags + 2; /* start_bd + pbd + frags */
-	tx_start_bd->nbd = cpu_to_le16(nbd);
-	tx_start_bd->nbytes = cpu_to_le16(skb_headlen(skb));
-	pkt_size = tx_start_bd->nbytes;
-
-	DP(NETIF_MSG_TX_QUEUED, "first bd @%p  addr (%x:%x)  nbd %d"
-	   "  nbytes %d  flags %x  vlan %x\n",
-	   tx_start_bd, tx_start_bd->addr_hi, tx_start_bd->addr_lo,
-	   le16_to_cpu(tx_start_bd->nbd), le16_to_cpu(tx_start_bd->nbytes),
-	   tx_start_bd->bd_flags.as_bitfield, le16_to_cpu(tx_start_bd->vlan));
-
-	if (xmit_type & XMIT_GSO) {
-
-		DP(NETIF_MSG_TX_QUEUED,
-		   "TSO packet len %d  hlen %d  total len %d  tso size %d\n",
-		   skb->len, hlen, skb_headlen(skb),
-		   skb_shinfo(skb)->gso_size);
-
-		tx_start_bd->bd_flags.as_bitfield |= ETH_TX_BD_FLAGS_SW_LSO;
-
-		if (unlikely(skb_headlen(skb) > hlen))
-			bd_prod = bnx2x_tx_split(bp, fp, tx_buf, &tx_start_bd,
-						 hlen, bd_prod, ++nbd);
-
-		pbd->lso_mss = cpu_to_le16(skb_shinfo(skb)->gso_size);
-		pbd->tcp_send_seq = swab32(tcp_hdr(skb)->seq);
-		pbd->tcp_flags = pbd_tcp_flags(skb);
-
-		if (xmit_type & XMIT_GSO_V4) {
-			pbd->ip_id = swab16(ip_hdr(skb)->id);
-			pbd->tcp_pseudo_csum =
-				swab16(~csum_tcpudp_magic(ip_hdr(skb)->saddr,
-							  ip_hdr(skb)->daddr,
-							  0, IPPROTO_TCP, 0));
-
-		} else
-			pbd->tcp_pseudo_csum =
-				swab16(~csum_ipv6_magic(&ipv6_hdr(skb)->saddr,
-							&ipv6_hdr(skb)->daddr,
-							0, IPPROTO_TCP, 0));
-
-		pbd->global_data |= ETH_TX_PARSE_BD_PSEUDO_CS_WITHOUT_LEN;
-	}
-	tx_data_bd = (struct eth_tx_bd *)tx_start_bd;
-
-	for (i = 0; i < skb_shinfo(skb)->nr_frags; i++) {
-		skb_frag_t *frag = &skb_shinfo(skb)->frags[i];
-
-		bd_prod = TX_BD(NEXT_TX_IDX(bd_prod));
-		tx_data_bd = &fp->tx_desc_ring[bd_prod].reg_bd;
-		if (total_pkt_bd == NULL)
-			total_pkt_bd = &fp->tx_desc_ring[bd_prod].reg_bd;
-
-		mapping = pci_map_page(bp->pdev, frag->page, frag->page_offset,
-				       frag->size, PCI_DMA_TODEVICE);
-
-		tx_data_bd->addr_hi = cpu_to_le32(U64_HI(mapping));
-		tx_data_bd->addr_lo = cpu_to_le32(U64_LO(mapping));
-		tx_data_bd->nbytes = cpu_to_le16(frag->size);
-		le16_add_cpu(&pkt_size, frag->size);
-
-		DP(NETIF_MSG_TX_QUEUED,
-		   "frag %d  bd @%p  addr (%x:%x)  nbytes %d\n",
-		   i, tx_data_bd, tx_data_bd->addr_hi, tx_data_bd->addr_lo,
-		   le16_to_cpu(tx_data_bd->nbytes));
-	}
-
-	DP(NETIF_MSG_TX_QUEUED, "last bd @%p\n", tx_data_bd);
-
-	bd_prod = TX_BD(NEXT_TX_IDX(bd_prod));
-
-	/* now send a tx doorbell, counting the next BD
-	 * if the packet contains or ends with it
-	 */
-	if (TX_BD_POFF(bd_prod) < nbd)
-		nbd++;
-
-	if (total_pkt_bd != NULL)
-		total_pkt_bd->total_pkt_bytes = pkt_size;
-
-	if (pbd)
-		DP(NETIF_MSG_TX_QUEUED,
-		   "PBD @%p  ip_data %x  ip_hlen %u  ip_id %u  lso_mss %u"
-		   "  tcp_flags %x  xsum %x  seq %u  hlen %u\n",
-		   pbd, pbd->global_data, pbd->ip_hlen, pbd->ip_id,
-		   pbd->lso_mss, pbd->tcp_flags, pbd->tcp_pseudo_csum,
-		   pbd->tcp_send_seq, le16_to_cpu(pbd->total_hlen));
-
-	DP(NETIF_MSG_TX_QUEUED, "doorbell: nbd %d  bd %u\n", nbd, bd_prod);
-
-	/*
-	 * Make sure that the BD data is updated before updating the producer
-	 * since FW might read the BD right after the producer is updated.
-	 * This is only applicable for weak-ordered memory model archs such
-	 * as IA-64. The following barrier is also mandatory since FW will
-	 * assumes packets must have BDs.
-	 */
-	wmb();
-
-	fp->tx_db.data.prod += nbd;
-	barrier();
-	DOORBELL(bp, fp->index, fp->tx_db.raw);
-
-	mmiowb();
-
-	fp->tx_bd_prod += nbd;
-
-	if (unlikely(bnx2x_tx_avail(fp) < MAX_SKB_FRAGS + 3)) {
-		netif_tx_stop_queue(txq);
-		/* We want bnx2x_tx_int to "see" the updated tx_bd_prod
-		   if we put Tx into XOFF state. */
-		smp_mb();
-		fp->eth_q_stats.driver_xoff++;
-		if (bnx2x_tx_avail(fp) >= MAX_SKB_FRAGS + 3)
-			netif_tx_wake_queue(txq);
-	}
-	fp->tx_pkt++;
-
-	return NETDEV_TX_OK;
-}
-
-/* called with rtnl_lock */
-static int bnx2x_open(struct net_device *dev)
-{
-	struct bnx2x *bp = netdev_priv(dev);
-
-	netif_carrier_off(dev);
-
-	bnx2x_set_power_state(bp, PCI_D0);
-
-	return bnx2x_nic_load(bp, LOAD_OPEN);
-}
-
-/* called with rtnl_lock */
-static int bnx2x_close(struct net_device *dev)
-{
-	struct bnx2x *bp = netdev_priv(dev);
-
-	/* Unload the driver, release IRQs */
-	bnx2x_nic_unload(bp, UNLOAD_CLOSE);
-	if (atomic_read(&bp->pdev->enable_cnt) == 1)
-		if (!CHIP_REV_IS_SLOW(bp))
-			bnx2x_set_power_state(bp, PCI_D3hot);
-
-	return 0;
-}
-
-/* called with netif_tx_lock from dev_mcast.c */
-static void bnx2x_set_rx_mode(struct net_device *dev)
-{
-	struct bnx2x *bp = netdev_priv(dev);
-	u32 rx_mode = BNX2X_RX_MODE_NORMAL;
-	int port = BP_PORT(bp);
-
-	if (bp->state != BNX2X_STATE_OPEN) {
-		DP(NETIF_MSG_IFUP, "state is %x, returning\n", bp->state);
-		return;
-	}
-
-	DP(NETIF_MSG_IFUP, "dev->flags = %x\n", dev->flags);
-
-	if (dev->flags & IFF_PROMISC)
-		rx_mode = BNX2X_RX_MODE_PROMISC;
-
-	else if ((dev->flags & IFF_ALLMULTI) ||
-		 ((netdev_mc_count(dev) > BNX2X_MAX_MULTICAST) &&
-		  CHIP_IS_E1(bp)))
-		rx_mode = BNX2X_RX_MODE_ALLMULTI;
-
-	else { /* some multicasts */
-		if (CHIP_IS_E1(bp)) {
-			int i, old, offset;
-			struct dev_mc_list *mclist;
-			struct mac_configuration_cmd *config =
-						bnx2x_sp(bp, mcast_config);
-
-			i = 0;
-			netdev_for_each_mc_addr(mclist, dev) {
-				config->config_table[i].
-					cam_entry.msb_mac_addr =
-					swab16(*(u16 *)&mclist->dmi_addr[0]);
-				config->config_table[i].
-					cam_entry.middle_mac_addr =
-					swab16(*(u16 *)&mclist->dmi_addr[2]);
-				config->config_table[i].
-					cam_entry.lsb_mac_addr =
-					swab16(*(u16 *)&mclist->dmi_addr[4]);
-				config->config_table[i].cam_entry.flags =
-							cpu_to_le16(port);
-				config->config_table[i].
-					target_table_entry.flags = 0;
-				config->config_table[i].target_table_entry.
-					clients_bit_vector =
-						cpu_to_le32(1 << BP_L_ID(bp));
-				config->config_table[i].
-					target_table_entry.vlan_id = 0;
-
-				DP(NETIF_MSG_IFUP,
-				   "setting MCAST[%d] (%04x:%04x:%04x)\n", i,
-				   config->config_table[i].
-						cam_entry.msb_mac_addr,
-				   config->config_table[i].
-						cam_entry.middle_mac_addr,
-				   config->config_table[i].
-						cam_entry.lsb_mac_addr);
-				i++;
-			}
-			old = config->hdr.length;
-			if (old > i) {
-				for (; i < old; i++) {
-					if (CAM_IS_INVALID(config->
-							   config_table[i])) {
-						/* already invalidated */
-						break;
-					}
-					/* invalidate */
-					CAM_INVALIDATE(config->
-						       config_table[i]);
-				}
-			}
-
-			if (CHIP_REV_IS_SLOW(bp))
-				offset = BNX2X_MAX_EMUL_MULTI*(1 + port);
-			else
-				offset = BNX2X_MAX_MULTICAST*(1 + port);
-
-			config->hdr.length = i;
-			config->hdr.offset = offset;
-			config->hdr.client_id = bp->fp->cl_id;
-			config->hdr.reserved1 = 0;
-
-			bp->set_mac_pending++;
-			smp_wmb();
-
-			bnx2x_sp_post(bp, RAMROD_CMD_ID_ETH_SET_MAC, 0,
-				   U64_HI(bnx2x_sp_mapping(bp, mcast_config)),
-				   U64_LO(bnx2x_sp_mapping(bp, mcast_config)),
-				      0);
-		} else { /* E1H */
-			/* Accept one or more multicasts */
-			struct dev_mc_list *mclist;
-			u32 mc_filter[MC_HASH_SIZE];
-			u32 crc, bit, regidx;
-			int i;
-
-			memset(mc_filter, 0, 4 * MC_HASH_SIZE);
-
-			netdev_for_each_mc_addr(mclist, dev) {
-				DP(NETIF_MSG_IFUP, "Adding mcast MAC: %pM\n",
-				   mclist->dmi_addr);
-
-				crc = crc32c_le(0, mclist->dmi_addr, ETH_ALEN);
-				bit = (crc >> 24) & 0xff;
-				regidx = bit >> 5;
-				bit &= 0x1f;
-				mc_filter[regidx] |= (1 << bit);
-			}
-
-			for (i = 0; i < MC_HASH_SIZE; i++)
-				REG_WR(bp, MC_HASH_OFFSET(bp, i),
-				       mc_filter[i]);
-		}
-	}
-
-	bp->rx_mode = rx_mode;
-	bnx2x_set_storm_rx_mode(bp);
-}
-
-/* called with rtnl_lock */
-static int bnx2x_change_mac_addr(struct net_device *dev, void *p)
-{
-	struct sockaddr *addr = p;
-	struct bnx2x *bp = netdev_priv(dev);
-
-	if (!is_valid_ether_addr((u8 *)(addr->sa_data)))
-		return -EINVAL;
-
-	memcpy(dev->dev_addr, addr->sa_data, dev->addr_len);
-	if (netif_running(dev)) {
-		if (CHIP_IS_E1(bp))
-			bnx2x_set_eth_mac_addr_e1(bp, 1);
-		else
-			bnx2x_set_eth_mac_addr_e1h(bp, 1);
-	}
-
-	return 0;
-}
-
-/* called with rtnl_lock */
-static int bnx2x_mdio_read(struct net_device *netdev, int prtad,
-			   int devad, u16 addr)
-{
-	struct bnx2x *bp = netdev_priv(netdev);
-	u16 value;
-	int rc;
-	u32 phy_type = XGXS_EXT_PHY_TYPE(bp->link_params.ext_phy_config);
-
-	DP(NETIF_MSG_LINK, "mdio_read: prtad 0x%x, devad 0x%x, addr 0x%x\n",
-	   prtad, devad, addr);
-
-	if (prtad != bp->mdio.prtad) {
-		DP(NETIF_MSG_LINK, "prtad missmatch (cmd:0x%x != bp:0x%x)\n",
-		   prtad, bp->mdio.prtad);
-		return -EINVAL;
-	}
-
-	/* The HW expects different devad if CL22 is used */
-	devad = (devad == MDIO_DEVAD_NONE) ? DEFAULT_PHY_DEV_ADDR : devad;
-
-	bnx2x_acquire_phy_lock(bp);
-	rc = bnx2x_cl45_read(bp, BP_PORT(bp), phy_type, prtad,
-			     devad, addr, &value);
-	bnx2x_release_phy_lock(bp);
-	DP(NETIF_MSG_LINK, "mdio_read_val 0x%x rc = 0x%x\n", value, rc);
-
-	if (!rc)
-		rc = value;
-	return rc;
-}
-
-/* called with rtnl_lock */
-static int bnx2x_mdio_write(struct net_device *netdev, int prtad, int devad,
-			    u16 addr, u16 value)
-{
-	struct bnx2x *bp = netdev_priv(netdev);
-	u32 ext_phy_type = XGXS_EXT_PHY_TYPE(bp->link_params.ext_phy_config);
-	int rc;
-
-	DP(NETIF_MSG_LINK, "mdio_write: prtad 0x%x, devad 0x%x, addr 0x%x,"
-			   " value 0x%x\n", prtad, devad, addr, value);
-
-	if (prtad != bp->mdio.prtad) {
-		DP(NETIF_MSG_LINK, "prtad missmatch (cmd:0x%x != bp:0x%x)\n",
-		   prtad, bp->mdio.prtad);
-		return -EINVAL;
-	}
-
-	/* The HW expects different devad if CL22 is used */
-	devad = (devad == MDIO_DEVAD_NONE) ? DEFAULT_PHY_DEV_ADDR : devad;
-
-	bnx2x_acquire_phy_lock(bp);
-	rc = bnx2x_cl45_write(bp, BP_PORT(bp), ext_phy_type, prtad,
-			      devad, addr, value);
-	bnx2x_release_phy_lock(bp);
-	return rc;
-}
-
-/* called with rtnl_lock */
-static int bnx2x_ioctl(struct net_device *dev, struct ifreq *ifr, int cmd)
-{
-	struct bnx2x *bp = netdev_priv(dev);
-	struct mii_ioctl_data *mdio = if_mii(ifr);
-
-	DP(NETIF_MSG_LINK, "ioctl: phy id 0x%x, reg 0x%x, val_in 0x%x\n",
-	   mdio->phy_id, mdio->reg_num, mdio->val_in);
-
-	if (!netif_running(dev))
-		return -EAGAIN;
-
-	return mdio_mii_ioctl(&bp->mdio, mdio, cmd);
-}
-
-/* called with rtnl_lock */
-static int bnx2x_change_mtu(struct net_device *dev, int new_mtu)
-{
-	struct bnx2x *bp = netdev_priv(dev);
-	int rc = 0;
-
-	if ((new_mtu > ETH_MAX_JUMBO_PACKET_SIZE) ||
-	    ((new_mtu + ETH_HLEN) < ETH_MIN_PACKET_SIZE))
-		return -EINVAL;
-
-	/* This does not race with packet allocation
-	 * because the actual alloc size is
-	 * only updated as part of load
-	 */
-	dev->mtu = new_mtu;
-
-	if (netif_running(dev)) {
-		bnx2x_nic_unload(bp, UNLOAD_NORMAL);
-		rc = bnx2x_nic_load(bp, LOAD_NORMAL);
-	}
-
-	return rc;
-}
-
-static void bnx2x_tx_timeout(struct net_device *dev)
-{
-	struct bnx2x *bp = netdev_priv(dev);
-
-#ifdef BNX2X_STOP_ON_ERROR
-	if (!bp->panic)
-		bnx2x_panic();
-#endif
-	/* This allows the netif to be shutdown gracefully before resetting */
-	schedule_work(&bp->reset_task);
-}
-
-#ifdef BCM_VLAN
-/* called with rtnl_lock */
-static void bnx2x_vlan_rx_register(struct net_device *dev,
-				   struct vlan_group *vlgrp)
-{
-	struct bnx2x *bp = netdev_priv(dev);
-
-	bp->vlgrp = vlgrp;
-
-	/* Set flags according to the required capabilities */
-	bp->flags &= ~(HW_VLAN_RX_FLAG | HW_VLAN_TX_FLAG);
-
-	if (dev->features & NETIF_F_HW_VLAN_TX)
-		bp->flags |= HW_VLAN_TX_FLAG;
-
-	if (dev->features & NETIF_F_HW_VLAN_RX)
-		bp->flags |= HW_VLAN_RX_FLAG;
-
-	if (netif_running(dev))
-		bnx2x_set_client_config(bp);
-}
-
-#endif
-
-#ifdef CONFIG_NET_POLL_CONTROLLER
-static void poll_bnx2x(struct net_device *dev)
-{
-	struct bnx2x *bp = netdev_priv(dev);
-
-	disable_irq(bp->pdev->irq);
-	bnx2x_interrupt(bp->pdev->irq, dev);
-	enable_irq(bp->pdev->irq);
-}
-#endif
-
-static const struct net_device_ops bnx2x_netdev_ops = {
-	.ndo_open		= bnx2x_open,
-	.ndo_stop		= bnx2x_close,
-	.ndo_start_xmit		= bnx2x_start_xmit,
-	.ndo_set_multicast_list	= bnx2x_set_rx_mode,
-	.ndo_set_mac_address	= bnx2x_change_mac_addr,
-	.ndo_validate_addr	= eth_validate_addr,
-	.ndo_do_ioctl		= bnx2x_ioctl,
-	.ndo_change_mtu		= bnx2x_change_mtu,
-	.ndo_tx_timeout		= bnx2x_tx_timeout,
-#ifdef BCM_VLAN
-	.ndo_vlan_rx_register	= bnx2x_vlan_rx_register,
-#endif
-#ifdef CONFIG_NET_POLL_CONTROLLER
-	.ndo_poll_controller	= poll_bnx2x,
-#endif
-};
-
-static int __devinit bnx2x_init_dev(struct pci_dev *pdev,
-				    struct net_device *dev)
-{
-	struct bnx2x *bp;
-	int rc;
-
-	SET_NETDEV_DEV(dev, &pdev->dev);
-	bp = netdev_priv(dev);
-
-	bp->dev = dev;
-	bp->pdev = pdev;
-	bp->flags = 0;
-	bp->func = PCI_FUNC(pdev->devfn);
-
-	rc = pci_enable_device(pdev);
-	if (rc) {
-		pr_err("Cannot enable PCI device, aborting\n");
-		goto err_out;
-	}
-
-	if (!(pci_resource_flags(pdev, 0) & IORESOURCE_MEM)) {
-		pr_err("Cannot find PCI device base address, aborting\n");
-		rc = -ENODEV;
-		goto err_out_disable;
-	}
-
-	if (!(pci_resource_flags(pdev, 2) & IORESOURCE_MEM)) {
-		pr_err("Cannot find second PCI device base address, aborting\n");
-		rc = -ENODEV;
-		goto err_out_disable;
-	}
-
-	if (atomic_read(&pdev->enable_cnt) == 1) {
-		rc = pci_request_regions(pdev, DRV_MODULE_NAME);
-		if (rc) {
-			pr_err("Cannot obtain PCI resources, aborting\n");
-			goto err_out_disable;
-		}
-
-		pci_set_master(pdev);
-		pci_save_state(pdev);
-	}
-
-	bp->pm_cap = pci_find_capability(pdev, PCI_CAP_ID_PM);
-	if (bp->pm_cap == 0) {
-		pr_err("Cannot find power management capability, aborting\n");
-		rc = -EIO;
-		goto err_out_release;
-	}
-
-	bp->pcie_cap = pci_find_capability(pdev, PCI_CAP_ID_EXP);
-	if (bp->pcie_cap == 0) {
-		pr_err("Cannot find PCI Express capability, aborting\n");
-		rc = -EIO;
-		goto err_out_release;
-	}
-
-	if (pci_set_dma_mask(pdev, DMA_BIT_MASK(64)) == 0) {
-		bp->flags |= USING_DAC_FLAG;
-		if (pci_set_consistent_dma_mask(pdev, DMA_BIT_MASK(64)) != 0) {
-			pr_err("pci_set_consistent_dma_mask failed, aborting\n");
-			rc = -EIO;
-			goto err_out_release;
-		}
-
-	} else if (pci_set_dma_mask(pdev, DMA_BIT_MASK(32)) != 0) {
-		pr_err("System does not support DMA, aborting\n");
-		rc = -EIO;
-		goto err_out_release;
-	}
-
-	dev->mem_start = pci_resource_start(pdev, 0);
-	dev->base_addr = dev->mem_start;
-	dev->mem_end = pci_resource_end(pdev, 0);
-
-	dev->irq = pdev->irq;
-
-	bp->regview = pci_ioremap_bar(pdev, 0);
-	if (!bp->regview) {
-		pr_err("Cannot map register space, aborting\n");
-		rc = -ENOMEM;
-		goto err_out_release;
-	}
-
-	bp->doorbells = ioremap_nocache(pci_resource_start(pdev, 2),
-					min_t(u64, BNX2X_DB_SIZE,
-					      pci_resource_len(pdev, 2)));
-	if (!bp->doorbells) {
-		pr_err("Cannot map doorbell space, aborting\n");
-		rc = -ENOMEM;
-		goto err_out_unmap;
-	}
-
-	bnx2x_set_power_state(bp, PCI_D0);
-
-	/* clean indirect addresses */
-	pci_write_config_dword(bp->pdev, PCICFG_GRC_ADDRESS,
-			       PCICFG_VENDOR_ID_OFFSET);
-	REG_WR(bp, PXP2_REG_PGL_ADDR_88_F0 + BP_PORT(bp)*16, 0);
-	REG_WR(bp, PXP2_REG_PGL_ADDR_8C_F0 + BP_PORT(bp)*16, 0);
-	REG_WR(bp, PXP2_REG_PGL_ADDR_90_F0 + BP_PORT(bp)*16, 0);
-	REG_WR(bp, PXP2_REG_PGL_ADDR_94_F0 + BP_PORT(bp)*16, 0);
-
-	dev->watchdog_timeo = TX_TIMEOUT;
-
-	dev->netdev_ops = &bnx2x_netdev_ops;
-	dev->ethtool_ops = &bnx2x_ethtool_ops;
-	dev->features |= NETIF_F_SG;
-	dev->features |= NETIF_F_HW_CSUM;
-	if (bp->flags & USING_DAC_FLAG)
-		dev->features |= NETIF_F_HIGHDMA;
-	dev->features |= (NETIF_F_TSO | NETIF_F_TSO_ECN);
-	dev->features |= NETIF_F_TSO6;
-#ifdef BCM_VLAN
-	dev->features |= (NETIF_F_HW_VLAN_TX | NETIF_F_HW_VLAN_RX);
-	bp->flags |= (HW_VLAN_RX_FLAG | HW_VLAN_TX_FLAG);
-
-	dev->vlan_features |= NETIF_F_SG;
-	dev->vlan_features |= NETIF_F_HW_CSUM;
-	if (bp->flags & USING_DAC_FLAG)
-		dev->vlan_features |= NETIF_F_HIGHDMA;
-	dev->vlan_features |= (NETIF_F_TSO | NETIF_F_TSO_ECN);
-	dev->vlan_features |= NETIF_F_TSO6;
-#endif
-
-	/* get_port_hwinfo() will set prtad and mmds properly */
-	bp->mdio.prtad = MDIO_PRTAD_NONE;
-	bp->mdio.mmds = 0;
-	bp->mdio.mode_support = MDIO_SUPPORTS_C45 | MDIO_EMULATE_C22;
-	bp->mdio.dev = dev;
-	bp->mdio.mdio_read = bnx2x_mdio_read;
-	bp->mdio.mdio_write = bnx2x_mdio_write;
-
-	return 0;
-
-err_out_unmap:
-	if (bp->regview) {
-		iounmap(bp->regview);
-		bp->regview = NULL;
-	}
-	if (bp->doorbells) {
-		iounmap(bp->doorbells);
-		bp->doorbells = NULL;
-	}
-
-err_out_release:
-	if (atomic_read(&pdev->enable_cnt) == 1)
-		pci_release_regions(pdev);
-
-err_out_disable:
-	pci_disable_device(pdev);
-	pci_set_drvdata(pdev, NULL);
-
-err_out:
-	return rc;
-}
-
-static void __devinit bnx2x_get_pcie_width_speed(struct bnx2x *bp,
-						 int *width, int *speed)
-{
-	u32 val = REG_RD(bp, PCICFG_OFFSET + PCICFG_LINK_CONTROL);
-
-	*width = (val & PCICFG_LINK_WIDTH) >> PCICFG_LINK_WIDTH_SHIFT;
-
-	/* return value of 1=2.5GHz 2=5GHz */
-	*speed = (val & PCICFG_LINK_SPEED) >> PCICFG_LINK_SPEED_SHIFT;
-}
-
-static int __devinit bnx2x_check_firmware(struct bnx2x *bp)
-{
-	const struct firmware *firmware = bp->firmware;
-	struct bnx2x_fw_file_hdr *fw_hdr;
-	struct bnx2x_fw_file_section *sections;
-	u32 offset, len, num_ops;
-	u16 *ops_offsets;
-	int i;
-	const u8 *fw_ver;
-
-	if (firmware->size < sizeof(struct bnx2x_fw_file_hdr))
-		return -EINVAL;
-
-	fw_hdr = (struct bnx2x_fw_file_hdr *)firmware->data;
-	sections = (struct bnx2x_fw_file_section *)fw_hdr;
-
-	/* Make sure none of the offsets and sizes make us read beyond
-	 * the end of the firmware data */
-	for (i = 0; i < sizeof(*fw_hdr) / sizeof(*sections); i++) {
-		offset = be32_to_cpu(sections[i].offset);
-		len = be32_to_cpu(sections[i].len);
-		if (offset + len > firmware->size) {
-			pr_err("Section %d length is out of bounds\n", i);
-			return -EINVAL;
-		}
-	}
-
-	/* Likewise for the init_ops offsets */
-	offset = be32_to_cpu(fw_hdr->init_ops_offsets.offset);
-	ops_offsets = (u16 *)(firmware->data + offset);
-	num_ops = be32_to_cpu(fw_hdr->init_ops.len) / sizeof(struct raw_op);
-
-	for (i = 0; i < be32_to_cpu(fw_hdr->init_ops_offsets.len) / 2; i++) {
-		if (be16_to_cpu(ops_offsets[i]) > num_ops) {
-			pr_err("Section offset %d is out of bounds\n", i);
-			return -EINVAL;
-		}
-	}
-
-	/* Check FW version */
-	offset = be32_to_cpu(fw_hdr->fw_version.offset);
-	fw_ver = firmware->data + offset;
-	if ((fw_ver[0] != BCM_5710_FW_MAJOR_VERSION) ||
-	    (fw_ver[1] != BCM_5710_FW_MINOR_VERSION) ||
-	    (fw_ver[2] != BCM_5710_FW_REVISION_VERSION) ||
-	    (fw_ver[3] != BCM_5710_FW_ENGINEERING_VERSION)) {
-		pr_err("Bad FW version:%d.%d.%d.%d. Should be %d.%d.%d.%d\n",
-		       fw_ver[0], fw_ver[1], fw_ver[2],
-		       fw_ver[3], BCM_5710_FW_MAJOR_VERSION,
-		       BCM_5710_FW_MINOR_VERSION,
-		       BCM_5710_FW_REVISION_VERSION,
-		       BCM_5710_FW_ENGINEERING_VERSION);
-		return -EINVAL;
-	}
-
-	return 0;
-}
-
-static inline void be32_to_cpu_n(const u8 *_source, u8 *_target, u32 n)
-{
-	const __be32 *source = (const __be32 *)_source;
-	u32 *target = (u32 *)_target;
-	u32 i;
-
-	for (i = 0; i < n/4; i++)
-		target[i] = be32_to_cpu(source[i]);
-}
-
-/*
-   Ops array is stored in the following format:
-   {op(8bit), offset(24bit, big endian), data(32bit, big endian)}
- */
-static inline void bnx2x_prep_ops(const u8 *_source, u8 *_target, u32 n)
-{
-	const __be32 *source = (const __be32 *)_source;
-	struct raw_op *target = (struct raw_op *)_target;
-	u32 i, j, tmp;
-
-	for (i = 0, j = 0; i < n/8; i++, j += 2) {
-		tmp = be32_to_cpu(source[j]);
-		target[i].op = (tmp >> 24) & 0xff;
-		target[i].offset =  tmp & 0xffffff;
-		target[i].raw_data = be32_to_cpu(source[j+1]);
-	}
-}
-
-static inline void be16_to_cpu_n(const u8 *_source, u8 *_target, u32 n)
-{
-	const __be16 *source = (const __be16 *)_source;
-	u16 *target = (u16 *)_target;
-	u32 i;
-
-	for (i = 0; i < n/2; i++)
-		target[i] = be16_to_cpu(source[i]);
-}
-
-#define BNX2X_ALLOC_AND_SET(arr, lbl, func)				\
-do {									\
-	u32 len = be32_to_cpu(fw_hdr->arr.len);				\
-	bp->arr = kmalloc(len, GFP_KERNEL);				\
-	if (!bp->arr) {							\
-		pr_err("Failed to allocate %d bytes for "#arr"\n", len); \
-		goto lbl;						\
-	}								\
-	func(bp->firmware->data + be32_to_cpu(fw_hdr->arr.offset),	\
-	     (u8 *)bp->arr, len);					\
-} while (0)
-
-static int __devinit bnx2x_init_firmware(struct bnx2x *bp, struct device *dev)
-{
-	const char *fw_file_name;
-	struct bnx2x_fw_file_hdr *fw_hdr;
-	int rc;
-
-	if (CHIP_IS_E1(bp))
-		fw_file_name = FW_FILE_NAME_E1;
-	else
-		fw_file_name = FW_FILE_NAME_E1H;
-
-	pr_info("Loading %s\n", fw_file_name);
-
-	rc = request_firmware(&bp->firmware, fw_file_name, dev);
-	if (rc) {
-		pr_err("Can't load firmware file %s\n", fw_file_name);
-		goto request_firmware_exit;
-	}
-
-	rc = bnx2x_check_firmware(bp);
-	if (rc) {
-		pr_err("Corrupt firmware file %s\n", fw_file_name);
-		goto request_firmware_exit;
-	}
-
-	fw_hdr = (struct bnx2x_fw_file_hdr *)bp->firmware->data;
-
-	/* Initialize the pointers to the init arrays */
-	/* Blob */
-	BNX2X_ALLOC_AND_SET(init_data, request_firmware_exit, be32_to_cpu_n);
-
-	/* Opcodes */
-	BNX2X_ALLOC_AND_SET(init_ops, init_ops_alloc_err, bnx2x_prep_ops);
-
-	/* Offsets */
-	BNX2X_ALLOC_AND_SET(init_ops_offsets, init_offsets_alloc_err,
-			    be16_to_cpu_n);
-
-	/* STORMs firmware */
-	INIT_TSEM_INT_TABLE_DATA(bp) = bp->firmware->data +
-			be32_to_cpu(fw_hdr->tsem_int_table_data.offset);
-	INIT_TSEM_PRAM_DATA(bp)      = bp->firmware->data +
-			be32_to_cpu(fw_hdr->tsem_pram_data.offset);
-	INIT_USEM_INT_TABLE_DATA(bp) = bp->firmware->data +
-			be32_to_cpu(fw_hdr->usem_int_table_data.offset);
-	INIT_USEM_PRAM_DATA(bp)      = bp->firmware->data +
-			be32_to_cpu(fw_hdr->usem_pram_data.offset);
-	INIT_XSEM_INT_TABLE_DATA(bp) = bp->firmware->data +
-			be32_to_cpu(fw_hdr->xsem_int_table_data.offset);
-	INIT_XSEM_PRAM_DATA(bp)      = bp->firmware->data +
-			be32_to_cpu(fw_hdr->xsem_pram_data.offset);
-	INIT_CSEM_INT_TABLE_DATA(bp) = bp->firmware->data +
-			be32_to_cpu(fw_hdr->csem_int_table_data.offset);
-	INIT_CSEM_PRAM_DATA(bp)      = bp->firmware->data +
-			be32_to_cpu(fw_hdr->csem_pram_data.offset);
-
-	return 0;
-
-init_offsets_alloc_err:
-	kfree(bp->init_ops);
-init_ops_alloc_err:
-	kfree(bp->init_data);
-request_firmware_exit:
-	release_firmware(bp->firmware);
-
-	return rc;
-}
-
-
-static int __devinit bnx2x_init_one(struct pci_dev *pdev,
-				    const struct pci_device_id *ent)
-{
-	struct net_device *dev = NULL;
-	struct bnx2x *bp;
-	int pcie_width, pcie_speed;
-	int rc;
-
-	/* dev zeroed in init_etherdev */
-	dev = alloc_etherdev_mq(sizeof(*bp), MAX_CONTEXT);
-	if (!dev) {
-		pr_err("Cannot allocate net device\n");
-		return -ENOMEM;
-	}
-
-	bp = netdev_priv(dev);
-	bp->msg_enable = debug;
-
-	pci_set_drvdata(pdev, dev);
-
-	rc = bnx2x_init_dev(pdev, dev);
-	if (rc < 0) {
-		free_netdev(dev);
-		return rc;
-	}
-
-	rc = bnx2x_init_bp(bp);
-	if (rc)
-		goto init_one_exit;
-
-	/* Set init arrays */
-	rc = bnx2x_init_firmware(bp, &pdev->dev);
-	if (rc) {
-		pr_err("Error loading firmware\n");
-		goto init_one_exit;
-	}
-
-	rc = register_netdev(dev);
-	if (rc) {
-		dev_err(&pdev->dev, "Cannot register net device\n");
-		goto init_one_exit;
-	}
-
-	bnx2x_get_pcie_width_speed(bp, &pcie_width, &pcie_speed);
-	netdev_info(dev, "%s (%c%d) PCI-E x%d %s found at mem %lx, IRQ %d, node addr %pM\n",
-		    board_info[ent->driver_data].name,
-		    (CHIP_REV(bp) >> 12) + 'A', (CHIP_METAL(bp) >> 4),
-		    pcie_width, (pcie_speed == 2) ? "5GHz (Gen2)" : "2.5GHz",
-		    dev->base_addr, bp->pdev->irq, dev->dev_addr);
-
-	return 0;
-
-init_one_exit:
-	if (bp->regview)
-		iounmap(bp->regview);
-
-	if (bp->doorbells)
-		iounmap(bp->doorbells);
-
-	free_netdev(dev);
-
-	if (atomic_read(&pdev->enable_cnt) == 1)
-		pci_release_regions(pdev);
-
-	pci_disable_device(pdev);
-	pci_set_drvdata(pdev, NULL);
-
-	return rc;
-}
-
-static void __devexit bnx2x_remove_one(struct pci_dev *pdev)
-{
-	struct net_device *dev = pci_get_drvdata(pdev);
-	struct bnx2x *bp;
-
-	if (!dev) {
-		pr_err("BAD net device from bnx2x_init_one\n");
-		return;
-	}
-	bp = netdev_priv(dev);
-
-	unregister_netdev(dev);
-
-	kfree(bp->init_ops_offsets);
-	kfree(bp->init_ops);
-	kfree(bp->init_data);
-	release_firmware(bp->firmware);
-
-	if (bp->regview)
-		iounmap(bp->regview);
-
-	if (bp->doorbells)
-		iounmap(bp->doorbells);
-
-	free_netdev(dev);
-
-	if (atomic_read(&pdev->enable_cnt) == 1)
-		pci_release_regions(pdev);
-
-	pci_disable_device(pdev);
-	pci_set_drvdata(pdev, NULL);
-}
-
-static int bnx2x_suspend(struct pci_dev *pdev, pm_message_t state)
-{
-	struct net_device *dev = pci_get_drvdata(pdev);
-	struct bnx2x *bp;
-
-	if (!dev) {
-		pr_err("BAD net device from bnx2x_init_one\n");
-		return -ENODEV;
-	}
-	bp = netdev_priv(dev);
-
-	rtnl_lock();
-
-	pci_save_state(pdev);
-
-	if (!netif_running(dev)) {
-		rtnl_unlock();
-		return 0;
-	}
-
-	netif_device_detach(dev);
-
-	bnx2x_nic_unload(bp, UNLOAD_CLOSE);
-
-	bnx2x_set_power_state(bp, pci_choose_state(pdev, state));
-
-	rtnl_unlock();
-
-	return 0;
-}
-
-static int bnx2x_resume(struct pci_dev *pdev)
-{
-	struct net_device *dev = pci_get_drvdata(pdev);
-	struct bnx2x *bp;
-	int rc;
-
-	if (!dev) {
-		pr_err("BAD net device from bnx2x_init_one\n");
-		return -ENODEV;
-	}
-	bp = netdev_priv(dev);
-
-	rtnl_lock();
-
-	pci_restore_state(pdev);
-
-	if (!netif_running(dev)) {
-		rtnl_unlock();
-		return 0;
-	}
-
-	bnx2x_set_power_state(bp, PCI_D0);
-	netif_device_attach(dev);
-
-	rc = bnx2x_nic_load(bp, LOAD_OPEN);
-
-	rtnl_unlock();
-
-	return rc;
-}
-
-static int bnx2x_eeh_nic_unload(struct bnx2x *bp)
-{
-	int i;
-
-	bp->state = BNX2X_STATE_ERROR;
-
-	bp->rx_mode = BNX2X_RX_MODE_NONE;
-
-	bnx2x_netif_stop(bp, 0);
-
-	del_timer_sync(&bp->timer);
-	bp->stats_state = STATS_STATE_DISABLED;
-	DP(BNX2X_MSG_STATS, "stats_state - DISABLED\n");
-
-	/* Release IRQs */
-	bnx2x_free_irq(bp, false);
-
-	if (CHIP_IS_E1(bp)) {
-		struct mac_configuration_cmd *config =
-						bnx2x_sp(bp, mcast_config);
-
-		for (i = 0; i < config->hdr.length; i++)
-			CAM_INVALIDATE(config->config_table[i]);
-	}
-
-	/* Free SKBs, SGEs, TPA pool and driver internals */
-	bnx2x_free_skbs(bp);
-	for_each_queue(bp, i)
-		bnx2x_free_rx_sge_range(bp, bp->fp + i, NUM_RX_SGE);
-	for_each_queue(bp, i)
-		netif_napi_del(&bnx2x_fp(bp, i, napi));
-	bnx2x_free_mem(bp);
-
-	bp->state = BNX2X_STATE_CLOSED;
-
-	netif_carrier_off(bp->dev);
-
-	return 0;
-}
-
-static void bnx2x_eeh_recover(struct bnx2x *bp)
-{
-	u32 val;
-
-	mutex_init(&bp->port.phy_mutex);
-
-	bp->common.shmem_base = REG_RD(bp, MISC_REG_SHARED_MEM_ADDR);
-	bp->link_params.shmem_base = bp->common.shmem_base;
-	BNX2X_DEV_INFO("shmem offset is 0x%x\n", bp->common.shmem_base);
-
-	if (!bp->common.shmem_base ||
-	    (bp->common.shmem_base < 0xA0000) ||
-	    (bp->common.shmem_base >= 0xC0000)) {
-		BNX2X_DEV_INFO("MCP not active\n");
-		bp->flags |= NO_MCP_FLAG;
-		return;
-	}
-
-	val = SHMEM_RD(bp, validity_map[BP_PORT(bp)]);
-	if ((val & (SHR_MEM_VALIDITY_DEV_INFO | SHR_MEM_VALIDITY_MB))
-		!= (SHR_MEM_VALIDITY_DEV_INFO | SHR_MEM_VALIDITY_MB))
-		BNX2X_ERR("BAD MCP validity signature\n");
-
-	if (!BP_NOMCP(bp)) {
-		bp->fw_seq = (SHMEM_RD(bp, func_mb[BP_FUNC(bp)].drv_mb_header)
-			      & DRV_MSG_SEQ_NUMBER_MASK);
-		BNX2X_DEV_INFO("fw_seq 0x%08x\n", bp->fw_seq);
-	}
-}
-
-/**
- * bnx2x_io_error_detected - called when PCI error is detected
- * @pdev: Pointer to PCI device
- * @state: The current pci connection state
- *
- * This function is called after a PCI bus error affecting
- * this device has been detected.
- */
-static pci_ers_result_t bnx2x_io_error_detected(struct pci_dev *pdev,
-						pci_channel_state_t state)
-{
-	struct net_device *dev = pci_get_drvdata(pdev);
-	struct bnx2x *bp = netdev_priv(dev);
-
-	rtnl_lock();
-
-	netif_device_detach(dev);
-
-	if (state == pci_channel_io_perm_failure) {
-		rtnl_unlock();
-		return PCI_ERS_RESULT_DISCONNECT;
-	}
-
-	if (netif_running(dev))
-		bnx2x_eeh_nic_unload(bp);
-
-	pci_disable_device(pdev);
-
-	rtnl_unlock();
-
-	/* Request a slot reset */
-	return PCI_ERS_RESULT_NEED_RESET;
-}
-
-/**
- * bnx2x_io_slot_reset - called after the PCI bus has been reset
- * @pdev: Pointer to PCI device
- *
- * Restart the card from scratch, as if from a cold-boot.
- */
-static pci_ers_result_t bnx2x_io_slot_reset(struct pci_dev *pdev)
-{
-	struct net_device *dev = pci_get_drvdata(pdev);
-	struct bnx2x *bp = netdev_priv(dev);
-
-	rtnl_lock();
-
-	if (pci_enable_device(pdev)) {
-		dev_err(&pdev->dev,
-			"Cannot re-enable PCI device after reset\n");
-		rtnl_unlock();
-		return PCI_ERS_RESULT_DISCONNECT;
-	}
-
-	pci_set_master(pdev);
-	pci_restore_state(pdev);
-
-	if (netif_running(dev))
-		bnx2x_set_power_state(bp, PCI_D0);
-
-	rtnl_unlock();
-
-	return PCI_ERS_RESULT_RECOVERED;
-}
-
-/**
- * bnx2x_io_resume - called when traffic can start flowing again
- * @pdev: Pointer to PCI device
- *
- * This callback is called when the error recovery driver tells us that
- * its OK to resume normal operation.
- */
-static void bnx2x_io_resume(struct pci_dev *pdev)
-{
-	struct net_device *dev = pci_get_drvdata(pdev);
-	struct bnx2x *bp = netdev_priv(dev);
-
-	rtnl_lock();
-
-	bnx2x_eeh_recover(bp);
-
-	if (netif_running(dev))
-		bnx2x_nic_load(bp, LOAD_NORMAL);
-
-	netif_device_attach(dev);
-
-	rtnl_unlock();
-}
-
-static struct pci_error_handlers bnx2x_err_handler = {
-	.error_detected = bnx2x_io_error_detected,
-	.slot_reset     = bnx2x_io_slot_reset,
-	.resume         = bnx2x_io_resume,
-};
-
-static struct pci_driver bnx2x_pci_driver = {
-	.name        = DRV_MODULE_NAME,
-	.id_table    = bnx2x_pci_tbl,
-	.probe       = bnx2x_init_one,
-	.remove      = __devexit_p(bnx2x_remove_one),
-	.suspend     = bnx2x_suspend,
-	.resume      = bnx2x_resume,
-	.err_handler = &bnx2x_err_handler,
-};
-
-static int __init bnx2x_init(void)
-{
-	int ret;
-
-	pr_info("%s", version);
-
-	bnx2x_wq = create_singlethread_workqueue("bnx2x");
-	if (bnx2x_wq == NULL) {
-		pr_err("Cannot create workqueue\n");
-		return -ENOMEM;
-	}
-
-	ret = pci_register_driver(&bnx2x_pci_driver);
-	if (ret) {
-		pr_err("Cannot register driver\n");
-		destroy_workqueue(bnx2x_wq);
-	}
-	return ret;
-}
-
-static void __exit bnx2x_cleanup(void)
-{
-	pci_unregister_driver(&bnx2x_pci_driver);
-
-	destroy_workqueue(bnx2x_wq);
-}
-
-module_init(bnx2x_init);
-module_exit(bnx2x_cleanup);
-
-#ifdef BCM_CNIC
-
-/* count denotes the number of new completions we have seen */
-static void bnx2x_cnic_sp_post(struct bnx2x *bp, int count)
-{
-	struct eth_spe *spe;
-
-#ifdef BNX2X_STOP_ON_ERROR
-	if (unlikely(bp->panic))
-		return;
-#endif
-
-	spin_lock_bh(&bp->spq_lock);
-	bp->cnic_spq_pending -= count;
-
-	for (; bp->cnic_spq_pending < bp->cnic_eth_dev.max_kwqe_pending;
-	     bp->cnic_spq_pending++) {
-
-		if (!bp->cnic_kwq_pending)
-			break;
-
-		spe = bnx2x_sp_get_next(bp);
-		*spe = *bp->cnic_kwq_cons;
-
-		bp->cnic_kwq_pending--;
-
-		DP(NETIF_MSG_TIMER, "pending on SPQ %d, on KWQ %d count %d\n",
-		   bp->cnic_spq_pending, bp->cnic_kwq_pending, count);
-
-		if (bp->cnic_kwq_cons == bp->cnic_kwq_last)
-			bp->cnic_kwq_cons = bp->cnic_kwq;
-		else
-			bp->cnic_kwq_cons++;
-	}
-	bnx2x_sp_prod_update(bp);
-	spin_unlock_bh(&bp->spq_lock);
-}
-
-static int bnx2x_cnic_sp_queue(struct net_device *dev,
-			       struct kwqe_16 *kwqes[], u32 count)
-{
-	struct bnx2x *bp = netdev_priv(dev);
-	int i;
-
-#ifdef BNX2X_STOP_ON_ERROR
-	if (unlikely(bp->panic))
-		return -EIO;
-#endif
-
-	spin_lock_bh(&bp->spq_lock);
-
-	for (i = 0; i < count; i++) {
-		struct eth_spe *spe = (struct eth_spe *)kwqes[i];
-
-		if (bp->cnic_kwq_pending == MAX_SP_DESC_CNT)
-			break;
-
-		*bp->cnic_kwq_prod = *spe;
-
-		bp->cnic_kwq_pending++;
-
-		DP(NETIF_MSG_TIMER, "L5 SPQE %x %x %x:%x pos %d\n",
-		   spe->hdr.conn_and_cmd_data, spe->hdr.type,
-		   spe->data.mac_config_addr.hi,
-		   spe->data.mac_config_addr.lo,
-		   bp->cnic_kwq_pending);
-
-		if (bp->cnic_kwq_prod == bp->cnic_kwq_last)
-			bp->cnic_kwq_prod = bp->cnic_kwq;
-		else
-			bp->cnic_kwq_prod++;
-	}
-
-	spin_unlock_bh(&bp->spq_lock);
-
-	if (bp->cnic_spq_pending < bp->cnic_eth_dev.max_kwqe_pending)
-		bnx2x_cnic_sp_post(bp, 0);
-
-	return i;
-}
-
-static int bnx2x_cnic_ctl_send(struct bnx2x *bp, struct cnic_ctl_info *ctl)
-{
-	struct cnic_ops *c_ops;
-	int rc = 0;
-
-	mutex_lock(&bp->cnic_mutex);
-	c_ops = bp->cnic_ops;
-	if (c_ops)
-		rc = c_ops->cnic_ctl(bp->cnic_data, ctl);
-	mutex_unlock(&bp->cnic_mutex);
-
-	return rc;
-}
-
-static int bnx2x_cnic_ctl_send_bh(struct bnx2x *bp, struct cnic_ctl_info *ctl)
-{
-	struct cnic_ops *c_ops;
-	int rc = 0;
-
-	rcu_read_lock();
-	c_ops = rcu_dereference(bp->cnic_ops);
-	if (c_ops)
-		rc = c_ops->cnic_ctl(bp->cnic_data, ctl);
-	rcu_read_unlock();
-
-	return rc;
-}
-
-/*
- * for commands that have no data
- */
-static int bnx2x_cnic_notify(struct bnx2x *bp, int cmd)
-{
-	struct cnic_ctl_info ctl = {0};
-
-	ctl.cmd = cmd;
-
-	return bnx2x_cnic_ctl_send(bp, &ctl);
-}
-
-static void bnx2x_cnic_cfc_comp(struct bnx2x *bp, int cid)
-{
-	struct cnic_ctl_info ctl;
-
-	/* first we tell CNIC and only then we count this as a completion */
-	ctl.cmd = CNIC_CTL_COMPLETION_CMD;
-	ctl.data.comp.cid = cid;
-
-	bnx2x_cnic_ctl_send_bh(bp, &ctl);
-	bnx2x_cnic_sp_post(bp, 1);
-}
-
-static int bnx2x_drv_ctl(struct net_device *dev, struct drv_ctl_info *ctl)
-{
-	struct bnx2x *bp = netdev_priv(dev);
-	int rc = 0;
-
-	switch (ctl->cmd) {
-	case DRV_CTL_CTXTBL_WR_CMD: {
-		u32 index = ctl->data.io.offset;
-		dma_addr_t addr = ctl->data.io.dma_addr;
-
-		bnx2x_ilt_wr(bp, index, addr);
-		break;
-	}
-
-	case DRV_CTL_COMPLETION_CMD: {
-		int count = ctl->data.comp.comp_count;
-
-		bnx2x_cnic_sp_post(bp, count);
-		break;
-	}
-
-	/* rtnl_lock is held.  */
-	case DRV_CTL_START_L2_CMD: {
-		u32 cli = ctl->data.ring.client_id;
-
-		bp->rx_mode_cl_mask |= (1 << cli);
-		bnx2x_set_storm_rx_mode(bp);
-		break;
-	}
-
-	/* rtnl_lock is held.  */
-	case DRV_CTL_STOP_L2_CMD: {
-		u32 cli = ctl->data.ring.client_id;
-
-		bp->rx_mode_cl_mask &= ~(1 << cli);
-		bnx2x_set_storm_rx_mode(bp);
-		break;
-	}
-
-	default:
-		BNX2X_ERR("unknown command %x\n", ctl->cmd);
-		rc = -EINVAL;
-	}
-
-	return rc;
-}
-
-static void bnx2x_setup_cnic_irq_info(struct bnx2x *bp)
-{
-	struct cnic_eth_dev *cp = &bp->cnic_eth_dev;
-
-	if (bp->flags & USING_MSIX_FLAG) {
-		cp->drv_state |= CNIC_DRV_STATE_USING_MSIX;
-		cp->irq_arr[0].irq_flags |= CNIC_IRQ_FL_MSIX;
-		cp->irq_arr[0].vector = bp->msix_table[1].vector;
-	} else {
-		cp->drv_state &= ~CNIC_DRV_STATE_USING_MSIX;
-		cp->irq_arr[0].irq_flags &= ~CNIC_IRQ_FL_MSIX;
-	}
-	cp->irq_arr[0].status_blk = bp->cnic_sb;
-	cp->irq_arr[0].status_blk_num = CNIC_SB_ID(bp);
-	cp->irq_arr[1].status_blk = bp->def_status_blk;
-	cp->irq_arr[1].status_blk_num = DEF_SB_ID;
-
-	cp->num_irq = 2;
-}
-
-static int bnx2x_register_cnic(struct net_device *dev, struct cnic_ops *ops,
-			       void *data)
-{
-	struct bnx2x *bp = netdev_priv(dev);
-	struct cnic_eth_dev *cp = &bp->cnic_eth_dev;
-
-	if (ops == NULL)
-		return -EINVAL;
-
-	if (atomic_read(&bp->intr_sem) != 0)
-		return -EBUSY;
-
-	bp->cnic_kwq = kzalloc(PAGE_SIZE, GFP_KERNEL);
-	if (!bp->cnic_kwq)
-		return -ENOMEM;
-
-	bp->cnic_kwq_cons = bp->cnic_kwq;
-	bp->cnic_kwq_prod = bp->cnic_kwq;
-	bp->cnic_kwq_last = bp->cnic_kwq + MAX_SP_DESC_CNT;
-
-	bp->cnic_spq_pending = 0;
-	bp->cnic_kwq_pending = 0;
-
-	bp->cnic_data = data;
-
-	cp->num_irq = 0;
-	cp->drv_state = CNIC_DRV_STATE_REGD;
-
-	bnx2x_init_sb(bp, bp->cnic_sb, bp->cnic_sb_mapping, CNIC_SB_ID(bp));
-
-	bnx2x_setup_cnic_irq_info(bp);
-	bnx2x_set_iscsi_eth_mac_addr(bp, 1);
-	bp->cnic_flags |= BNX2X_CNIC_FLAG_MAC_SET;
-	rcu_assign_pointer(bp->cnic_ops, ops);
-
-	return 0;
-}
-
-static int bnx2x_unregister_cnic(struct net_device *dev)
-{
-	struct bnx2x *bp = netdev_priv(dev);
-	struct cnic_eth_dev *cp = &bp->cnic_eth_dev;
-
-	mutex_lock(&bp->cnic_mutex);
-	if (bp->cnic_flags & BNX2X_CNIC_FLAG_MAC_SET) {
-		bp->cnic_flags &= ~BNX2X_CNIC_FLAG_MAC_SET;
-		bnx2x_set_iscsi_eth_mac_addr(bp, 0);
-	}
-	cp->drv_state = 0;
-	rcu_assign_pointer(bp->cnic_ops, NULL);
-	mutex_unlock(&bp->cnic_mutex);
-	synchronize_rcu();
-	kfree(bp->cnic_kwq);
-	bp->cnic_kwq = NULL;
-
-	return 0;
-}
-
-struct cnic_eth_dev *bnx2x_cnic_probe(struct net_device *dev)
-{
-	struct bnx2x *bp = netdev_priv(dev);
-	struct cnic_eth_dev *cp = &bp->cnic_eth_dev;
-
-	cp->drv_owner = THIS_MODULE;
-	cp->chip_id = CHIP_ID(bp);
-	cp->pdev = bp->pdev;
-	cp->io_base = bp->regview;
-	cp->io_base2 = bp->doorbells;
-	cp->max_kwqe_pending = 8;
-	cp->ctx_blk_size = CNIC_CTX_PER_ILT * sizeof(union cdu_context);
-	cp->ctx_tbl_offset = FUNC_ILT_BASE(BP_FUNC(bp)) + 1;
-	cp->ctx_tbl_len = CNIC_ILT_LINES;
-	cp->starting_cid = BCM_CNIC_CID_START;
-	cp->drv_submit_kwqes_16 = bnx2x_cnic_sp_queue;
-	cp->drv_ctl = bnx2x_drv_ctl;
-	cp->drv_register_cnic = bnx2x_register_cnic;
-	cp->drv_unregister_cnic = bnx2x_unregister_cnic;
-
-	return cp;
-}
-EXPORT_SYMBOL(bnx2x_cnic_probe);
-
-#endif /* BCM_CNIC */
-
diff -r f4bf81a7ff20 drivers/net/bnx2x_reg.h
--- a/drivers/net/bnx2x_reg.h
+++ /dev/null
@@ -1,5339 +0,0 @@
-/* bnx2x_reg.h: Broadcom Everest network driver.
- *
- * Copyright (c) 2007-2009 Broadcom Corporation
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation.
- *
- * The registers description starts with the register Access type followed
- * by size in bits. For example [RW 32]. The access types are:
- * R  - Read only
- * RC - Clear on read
- * RW - Read/Write
- * ST - Statistics register (clear on read)
- * W  - Write only
- * WB - Wide bus register - the size is over 32 bits and it should be
- *      read/write in consecutive 32 bits accesses
- * WR - Write Clear (write 1 to clear the bit)
- *
- */
-
-
-/* [R 19] Interrupt register #0 read */
-#define BRB1_REG_BRB1_INT_STS					 0x6011c
-/* [RW 4] Parity mask register #0 read/write */
-#define BRB1_REG_BRB1_PRTY_MASK 				 0x60138
-/* [R 4] Parity register #0 read */
-#define BRB1_REG_BRB1_PRTY_STS					 0x6012c
-/* [RW 10] At address BRB1_IND_FREE_LIST_PRS_CRDT initialize free head. At
-   address BRB1_IND_FREE_LIST_PRS_CRDT+1 initialize free tail. At address
-   BRB1_IND_FREE_LIST_PRS_CRDT+2 initialize parser initial credit. */
-#define BRB1_REG_FREE_LIST_PRS_CRDT				 0x60200
-/* [RW 10] The number of free blocks above which the High_llfc signal to
-   interface #n is de-asserted. */
-#define BRB1_REG_HIGH_LLFC_HIGH_THRESHOLD_0			 0x6014c
-/* [RW 10] The number of free blocks below which the High_llfc signal to
-   interface #n is asserted. */
-#define BRB1_REG_HIGH_LLFC_LOW_THRESHOLD_0			 0x6013c
-/* [RW 23] LL RAM data. */
-#define BRB1_REG_LL_RAM 					 0x61000
-/* [RW 10] The number of free blocks above which the Low_llfc signal to
-   interface #n is de-asserted. */
-#define BRB1_REG_LOW_LLFC_HIGH_THRESHOLD_0			 0x6016c
-/* [RW 10] The number of free blocks below which the Low_llfc signal to
-   interface #n is asserted. */
-#define BRB1_REG_LOW_LLFC_LOW_THRESHOLD_0			 0x6015c
-/* [R 24] The number of full blocks. */
-#define BRB1_REG_NUM_OF_FULL_BLOCKS				 0x60090
-/* [ST 32] The number of cycles that the write_full signal towards MAC #0
-   was asserted. */
-#define BRB1_REG_NUM_OF_FULL_CYCLES_0				 0x600c8
-#define BRB1_REG_NUM_OF_FULL_CYCLES_1				 0x600cc
-#define BRB1_REG_NUM_OF_FULL_CYCLES_4				 0x600d8
-/* [ST 32] The number of cycles that the pause signal towards MAC #0 was
-   asserted. */
-#define BRB1_REG_NUM_OF_PAUSE_CYCLES_0				 0x600b8
-#define BRB1_REG_NUM_OF_PAUSE_CYCLES_1				 0x600bc
-/* [RW 10] Write client 0: De-assert pause threshold. */
-#define BRB1_REG_PAUSE_HIGH_THRESHOLD_0 			 0x60078
-#define BRB1_REG_PAUSE_HIGH_THRESHOLD_1 			 0x6007c
-/* [RW 10] Write client 0: Assert pause threshold. */
-#define BRB1_REG_PAUSE_LOW_THRESHOLD_0				 0x60068
-#define BRB1_REG_PAUSE_LOW_THRESHOLD_1				 0x6006c
-/* [R 24] The number of full blocks occupied by port. */
-#define BRB1_REG_PORT_NUM_OCC_BLOCKS_0				 0x60094
-/* [RW 1] Reset the design by software. */
-#define BRB1_REG_SOFT_RESET					 0x600dc
-/* [R 5] Used to read the value of the XX protection CAM occupancy counter. */
-#define CCM_REG_CAM_OCCUP					 0xd0188
-/* [RW 1] CM - CFC Interface enable. If 0 - the valid input is disregarded;
-   acknowledge output is deasserted; all other signals are treated as usual;
-   if 1 - normal activity. */
-#define CCM_REG_CCM_CFC_IFEN					 0xd003c
-/* [RW 1] CM - QM Interface enable. If 0 - the acknowledge input is
-   disregarded; valid is deasserted; all other signals are treated as usual;
-   if 1 - normal activity. */
-#define CCM_REG_CCM_CQM_IFEN					 0xd000c
-/* [RW 1] If set the Q index; received from the QM is inserted to event ID.
-   Otherwise 0 is inserted. */
-#define CCM_REG_CCM_CQM_USE_Q					 0xd00c0
-/* [RW 11] Interrupt mask register #0 read/write */
-#define CCM_REG_CCM_INT_MASK					 0xd01e4
-/* [R 11] Interrupt register #0 read */
-#define CCM_REG_CCM_INT_STS					 0xd01d8
-/* [R 27] Parity register #0 read */
-#define CCM_REG_CCM_PRTY_STS					 0xd01e8
-/* [RW 3] The size of AG context region 0 in REG-pairs. Designates the MS
-   REG-pair number (e.g. if region 0 is 6 REG-pairs; the value should be 5).
-   Is used to determine the number of the AG context REG-pairs written back;
-   when the input message Reg1WbFlg isn't set. */
-#define CCM_REG_CCM_REG0_SZ					 0xd00c4
-/* [RW 1] CM - STORM 0 Interface enable. If 0 - the acknowledge input is
-   disregarded; valid is deasserted; all other signals are treated as usual;
-   if 1 - normal activity. */
-#define CCM_REG_CCM_STORM0_IFEN 				 0xd0004
-/* [RW 1] CM - STORM 1 Interface enable. If 0 - the acknowledge input is
-   disregarded; valid is deasserted; all other signals are treated as usual;
-   if 1 - normal activity. */
-#define CCM_REG_CCM_STORM1_IFEN 				 0xd0008
-/* [RW 1] CDU AG read Interface enable. If 0 - the request input is
-   disregarded; valid output is deasserted; all other signals are treated as
-   usual; if 1 - normal activity. */
-#define CCM_REG_CDU_AG_RD_IFEN					 0xd0030
-/* [RW 1] CDU AG write Interface enable. If 0 - the request and valid input
-   are disregarded; all other signals are treated as usual; if 1 - normal
-   activity. */
-#define CCM_REG_CDU_AG_WR_IFEN					 0xd002c
-/* [RW 1] CDU STORM read Interface enable. If 0 - the request input is
-   disregarded; valid output is deasserted; all other signals are treated as
-   usual; if 1 - normal activity. */
-#define CCM_REG_CDU_SM_RD_IFEN					 0xd0038
-/* [RW 1] CDU STORM write Interface enable. If 0 - the request and valid
-   input is disregarded; all other signals are treated as usual; if 1 -
-   normal activity. */
-#define CCM_REG_CDU_SM_WR_IFEN					 0xd0034
-/* [RW 4] CFC output initial credit. Max credit available - 15.Write writes
-   the initial credit value; read returns the current value of the credit
-   counter. Must be initialized to 1 at start-up. */
-#define CCM_REG_CFC_INIT_CRD					 0xd0204
-/* [RW 2] Auxillary counter flag Q number 1. */
-#define CCM_REG_CNT_AUX1_Q					 0xd00c8
-/* [RW 2] Auxillary counter flag Q number 2. */
-#define CCM_REG_CNT_AUX2_Q					 0xd00cc
-/* [RW 28] The CM header value for QM request (primary). */
-#define CCM_REG_CQM_CCM_HDR_P					 0xd008c
-/* [RW 28] The CM header value for QM request (secondary). */
-#define CCM_REG_CQM_CCM_HDR_S					 0xd0090
-/* [RW 1] QM - CM Interface enable. If 0 - the valid input is disregarded;
-   acknowledge output is deasserted; all other signals are treated as usual;
-   if 1 - normal activity. */
-#define CCM_REG_CQM_CCM_IFEN					 0xd0014
-/* [RW 6] QM output initial credit. Max credit available - 32. Write writes
-   the initial credit value; read returns the current value of the credit
-   counter. Must be initialized to 32 at start-up. */
-#define CCM_REG_CQM_INIT_CRD					 0xd020c
-/* [RW 3] The weight of the QM (primary) input in the WRR mechanism. 0
-   stands for weight 8 (the most prioritised); 1 stands for weight 1(least
-   prioritised); 2 stands for weight 2; tc. */
-#define CCM_REG_CQM_P_WEIGHT					 0xd00b8
-/* [RW 3] The weight of the QM (secondary) input in the WRR mechanism. 0
-   stands for weight 8 (the most prioritised); 1 stands for weight 1(least
-   prioritised); 2 stands for weight 2; tc. */
-#define CCM_REG_CQM_S_WEIGHT					 0xd00bc
-/* [RW 1] Input SDM Interface enable. If 0 - the valid input is disregarded;
-   acknowledge output is deasserted; all other signals are treated as usual;
-   if 1 - normal activity. */
-#define CCM_REG_CSDM_IFEN					 0xd0018
-/* [RC 1] Set when the message length mismatch (relative to last indication)
-   at the SDM interface is detected. */
-#define CCM_REG_CSDM_LENGTH_MIS 				 0xd0170
-/* [RW 3] The weight of the SDM input in the WRR mechanism. 0 stands for
-   weight 8 (the most prioritised); 1 stands for weight 1(least
-   prioritised); 2 stands for weight 2; tc. */
-#define CCM_REG_CSDM_WEIGHT					 0xd00b4
-/* [RW 28] The CM header for QM formatting in case of an error in the QM
-   inputs. */
-#define CCM_REG_ERR_CCM_HDR					 0xd0094
-/* [RW 8] The Event ID in case the input message ErrorFlg is set. */
-#define CCM_REG_ERR_EVNT_ID					 0xd0098
-/* [RW 8] FIC0 output initial credit. Max credit available - 255. Write
-   writes the initial credit value; read returns the current value of the
-   credit counter. Must be initialized to 64 at start-up. */
-#define CCM_REG_FIC0_INIT_CRD					 0xd0210
-/* [RW 8] FIC1 output initial credit. Max credit available - 255.Write
-   writes the initial credit value; read returns the current value of the
-   credit counter. Must be initialized to 64 at start-up. */
-#define CCM_REG_FIC1_INIT_CRD					 0xd0214
-/* [RW 1] Arbitration between Input Arbiter groups: 0 - fair Round-Robin; 1
-   - strict priority defined by ~ccm_registers_gr_ag_pr.gr_ag_pr;
-   ~ccm_registers_gr_ld0_pr.gr_ld0_pr and
-   ~ccm_registers_gr_ld1_pr.gr_ld1_pr. Groups are according to channels and
-   outputs to STORM: aggregation; load FIC0; load FIC1 and store. */
-#define CCM_REG_GR_ARB_TYPE					 0xd015c
-/* [RW 2] Load (FIC0) channel group priority. The lowest priority is 0; the
-   highest priority is 3. It is supposed; that the Store channel priority is
-   the compliment to 4 of the rest priorities - Aggregation channel; Load
-   (FIC0) channel and Load (FIC1). */
-#define CCM_REG_GR_LD0_PR					 0xd0164
-/* [RW 2] Load (FIC1) channel group priority. The lowest priority is 0; the
-   highest priority is 3. It is supposed; that the Store channel priority is
-   the compliment to 4 of the rest priorities - Aggregation channel; Load
-   (FIC0) channel and Load (FIC1). */
-#define CCM_REG_GR_LD1_PR					 0xd0168
-/* [RW 2] General flags index. */
-#define CCM_REG_INV_DONE_Q					 0xd0108
-/* [RW 4] The number of double REG-pairs(128 bits); loaded from the STORM
-   context and sent to STORM; for a specific connection type. The double
-   REG-pairs are used in order to align to STORM context row size of 128
-   bits. The offset of these data in the STORM context is always 0. Index
-   _(0..15) stands for the connection type (one of 16). */
-#define CCM_REG_N_SM_CTX_LD_0					 0xd004c
-#define CCM_REG_N_SM_CTX_LD_1					 0xd0050
-#define CCM_REG_N_SM_CTX_LD_2					 0xd0054
-#define CCM_REG_N_SM_CTX_LD_3					 0xd0058
-#define CCM_REG_N_SM_CTX_LD_4					 0xd005c
-/* [RW 1] Input pbf Interface enable. If 0 - the valid input is disregarded;
-   acknowledge output is deasserted; all other signals are treated as usual;
-   if 1 - normal activity. */
-#define CCM_REG_PBF_IFEN					 0xd0028
-/* [RC 1] Set when the message length mismatch (relative to last indication)
-   at the pbf interface is detected. */
-#define CCM_REG_PBF_LENGTH_MIS					 0xd0180
-/* [RW 3] The weight of the input pbf in the WRR mechanism. 0 stands for
-   weight 8 (the most prioritised); 1 stands for weight 1(least
-   prioritised); 2 stands for weight 2; tc. */
-#define CCM_REG_PBF_WEIGHT					 0xd00ac
-#define CCM_REG_PHYS_QNUM1_0					 0xd0134
-#define CCM_REG_PHYS_QNUM1_1					 0xd0138
-#define CCM_REG_PHYS_QNUM2_0					 0xd013c
-#define CCM_REG_PHYS_QNUM2_1					 0xd0140
-#define CCM_REG_PHYS_QNUM3_0					 0xd0144
-#define CCM_REG_PHYS_QNUM3_1					 0xd0148
-#define CCM_REG_QOS_PHYS_QNUM0_0				 0xd0114
-#define CCM_REG_QOS_PHYS_QNUM0_1				 0xd0118
-#define CCM_REG_QOS_PHYS_QNUM1_0				 0xd011c
-#define CCM_REG_QOS_PHYS_QNUM1_1				 0xd0120
-#define CCM_REG_QOS_PHYS_QNUM2_0				 0xd0124
-#define CCM_REG_QOS_PHYS_QNUM2_1				 0xd0128
-#define CCM_REG_QOS_PHYS_QNUM3_0				 0xd012c
-#define CCM_REG_QOS_PHYS_QNUM3_1				 0xd0130
-/* [RW 1] STORM - CM Interface enable. If 0 - the valid input is
-   disregarded; acknowledge output is deasserted; all other signals are
-   treated as usual; if 1 - normal activity. */
-#define CCM_REG_STORM_CCM_IFEN					 0xd0010
-/* [RC 1] Set when the message length mismatch (relative to last indication)
-   at the STORM interface is detected. */
-#define CCM_REG_STORM_LENGTH_MIS				 0xd016c
-/* [RW 3] The weight of the STORM input in the WRR (Weighted Round robin)
-   mechanism. 0 stands for weight 8 (the most prioritised); 1 stands for
-   weight 1(least prioritised); 2 stands for weight 2 (more prioritised);
-   tc. */
-#define CCM_REG_STORM_WEIGHT					 0xd009c
-/* [RW 1] Input tsem Interface enable. If 0 - the valid input is
-   disregarded; acknowledge output is deasserted; all other signals are
-   treated as usual; if 1 - normal activity. */
-#define CCM_REG_TSEM_IFEN					 0xd001c
-/* [RC 1] Set when the message length mismatch (relative to last indication)
-   at the tsem interface is detected. */
-#define CCM_REG_TSEM_LENGTH_MIS 				 0xd0174
-/* [RW 3] The weight of the input tsem in the WRR mechanism. 0 stands for
-   weight 8 (the most prioritised); 1 stands for weight 1(least
-   prioritised); 2 stands for weight 2; tc. */
-#define CCM_REG_TSEM_WEIGHT					 0xd00a0
-/* [RW 1] Input usem Interface enable. If 0 - the valid input is
-   disregarded; acknowledge output is deasserted; all other signals are
-   treated as usual; if 1 - normal activity. */
-#define CCM_REG_USEM_IFEN					 0xd0024
-/* [RC 1] Set when message length mismatch (relative to last indication) at
-   the usem interface is detected. */
-#define CCM_REG_USEM_LENGTH_MIS 				 0xd017c
-/* [RW 3] The weight of the input usem in the WRR mechanism. 0 stands for
-   weight 8 (the most prioritised); 1 stands for weight 1(least
-   prioritised); 2 stands for weight 2; tc. */
-#define CCM_REG_USEM_WEIGHT					 0xd00a8
-/* [RW 1] Input xsem Interface enable. If 0 - the valid input is
-   disregarded; acknowledge output is deasserted; all other signals are
-   treated as usual; if 1 - normal activity. */
-#define CCM_REG_XSEM_IFEN					 0xd0020
-/* [RC 1] Set when the message length mismatch (relative to last indication)
-   at the xsem interface is detected. */
-#define CCM_REG_XSEM_LENGTH_MIS 				 0xd0178
-/* [RW 3] The weight of the input xsem in the WRR mechanism. 0 stands for
-   weight 8 (the most prioritised); 1 stands for weight 1(least
-   prioritised); 2 stands for weight 2; tc. */
-#define CCM_REG_XSEM_WEIGHT					 0xd00a4
-/* [RW 19] Indirect access to the descriptor table of the XX protection
-   mechanism. The fields are: [5:0] - message length; [12:6] - message
-   pointer; 18:13] - next pointer. */
-#define CCM_REG_XX_DESCR_TABLE					 0xd0300
-#define CCM_REG_XX_DESCR_TABLE_SIZE				 36
-/* [R 7] Used to read the value of XX protection Free counter. */
-#define CCM_REG_XX_FREE 					 0xd0184
-/* [RW 6] Initial value for the credit counter; responsible for fulfilling
-   of the Input Stage XX protection buffer by the XX protection pending
-   messages. Max credit available - 127. Write writes the initial credit
-   value; read returns the current value of the credit counter. Must be
-   initialized to maximum XX protected message size - 2 at start-up. */
-#define CCM_REG_XX_INIT_CRD					 0xd0220
-/* [RW 7] The maximum number of pending messages; which may be stored in XX
-   protection. At read the ~ccm_registers_xx_free.xx_free counter is read.
-   At write comprises the start value of the ~ccm_registers_xx_free.xx_free
-   counter. */
-#define CCM_REG_XX_MSG_NUM					 0xd0224
-/* [RW 8] The Event ID; sent to the STORM in case of XX overflow. */
-#define CCM_REG_XX_OVFL_EVNT_ID 				 0xd0044
-/* [RW 18] Indirect access to the XX table of the XX protection mechanism.
-   The fields are: [5:0] - tail pointer; 11:6] - Link List size; 17:12] -
-   header pointer. */
-#define CCM_REG_XX_TABLE					 0xd0280
-#define CDU_REG_CDU_CHK_MASK0					 0x101000
-#define CDU_REG_CDU_CHK_MASK1					 0x101004
-#define CDU_REG_CDU_CONTROL0					 0x101008
-#define CDU_REG_CDU_DEBUG					 0x101010
-#define CDU_REG_CDU_GLOBAL_PARAMS				 0x101020
-/* [RW 7] Interrupt mask register #0 read/write */
-#define CDU_REG_CDU_INT_MASK					 0x10103c
-/* [R 7] Interrupt register #0 read */
-#define CDU_REG_CDU_INT_STS					 0x101030
-/* [RW 5] Parity mask register #0 read/write */
-#define CDU_REG_CDU_PRTY_MASK					 0x10104c
-/* [R 5] Parity register #0 read */
-#define CDU_REG_CDU_PRTY_STS					 0x101040
-/* [RC 32] logging of error data in case of a CDU load error:
-   {expected_cid[15:0]; xpected_type[2:0]; xpected_region[2:0]; ctive_error;
-   ype_error; ctual_active; ctual_compressed_context}; */
-#define CDU_REG_ERROR_DATA					 0x101014
-/* [WB 216] L1TT ram access. each entry has the following format :
-   {mrege_regions[7:0]; ffset12[5:0]...offset0[5:0];
-   ength12[5:0]...length0[5:0]; d12[3:0]...id0[3:0]} */
-#define CDU_REG_L1TT						 0x101800
-/* [WB 24] MATT ram access. each entry has the following
-   format:{RegionLength[11:0]; egionOffset[11:0]} */
-#define CDU_REG_MATT						 0x101100
-/* [RW 1] when this bit is set the CDU operates in e1hmf mode */
-#define CDU_REG_MF_MODE 					 0x101050
-/* [R 1] indication the initializing the activity counter by the hardware
-   was done. */
-#define CFC_REG_AC_INIT_DONE					 0x104078
-/* [RW 13] activity counter ram access */
-#define CFC_REG_ACTIVITY_COUNTER				 0x104400
-#define CFC_REG_ACTIVITY_COUNTER_SIZE				 256
-/* [R 1] indication the initializing the cams by the hardware was done. */
-#define CFC_REG_CAM_INIT_DONE					 0x10407c
-/* [RW 2] Interrupt mask register #0 read/write */
-#define CFC_REG_CFC_INT_MASK					 0x104108
-/* [R 2] Interrupt register #0 read */
-#define CFC_REG_CFC_INT_STS					 0x1040fc
-/* [RC 2] Interrupt register #0 read clear */
-#define CFC_REG_CFC_INT_STS_CLR 				 0x104100
-/* [RW 4] Parity mask register #0 read/write */
-#define CFC_REG_CFC_PRTY_MASK					 0x104118
-/* [R 4] Parity register #0 read */
-#define CFC_REG_CFC_PRTY_STS					 0x10410c
-/* [RW 21] CID cam access (21:1 - Data; alid - 0) */
-#define CFC_REG_CID_CAM 					 0x104800
-#define CFC_REG_CONTROL0					 0x104028
-#define CFC_REG_DEBUG0						 0x104050
-/* [RW 14] indicates per error (in #cfc_registers_cfc_error_vector.cfc_error
-   vector) whether the cfc should be disabled upon it */
-#define CFC_REG_DISABLE_ON_ERROR				 0x104044
-/* [RC 14] CFC error vector. when the CFC detects an internal error it will
-   set one of these bits. the bit description can be found in CFC
-   specifications */
-#define CFC_REG_ERROR_VECTOR					 0x10403c
-/* [WB 93] LCID info ram access */
-#define CFC_REG_INFO_RAM					 0x105000
-#define CFC_REG_INFO_RAM_SIZE					 1024
-#define CFC_REG_INIT_REG					 0x10404c
-#define CFC_REG_INTERFACES					 0x104058
-/* [RW 24] {weight_load_client7[2:0] to weight_load_client0[2:0]}. this
-   field allows changing the priorities of the weighted-round-robin arbiter
-   which selects which CFC load client should be served next */
-#define CFC_REG_LCREQ_WEIGHTS					 0x104084
-/* [RW 16] Link List ram access; data = {prev_lcid; ext_lcid} */
-#define CFC_REG_LINK_LIST					 0x104c00
-#define CFC_REG_LINK_LIST_SIZE					 256
-/* [R 1] indication the initializing the link list by the hardware was done. */
-#define CFC_REG_LL_INIT_DONE					 0x104074
-/* [R 9] Number of allocated LCIDs which are at empty state */
-#define CFC_REG_NUM_LCIDS_ALLOC 				 0x104020
-/* [R 9] Number of Arriving LCIDs in Link List Block */
-#define CFC_REG_NUM_LCIDS_ARRIVING				 0x104004
-/* [R 9] Number of Leaving LCIDs in Link List Block */
-#define CFC_REG_NUM_LCIDS_LEAVING				 0x104018
-/* [RW 8] The event id for aggregated interrupt 0 */
-#define CSDM_REG_AGG_INT_EVENT_0				 0xc2038
-#define CSDM_REG_AGG_INT_EVENT_10				 0xc2060
-#define CSDM_REG_AGG_INT_EVENT_11				 0xc2064
-#define CSDM_REG_AGG_INT_EVENT_12				 0xc2068
-#define CSDM_REG_AGG_INT_EVENT_13				 0xc206c
-#define CSDM_REG_AGG_INT_EVENT_14				 0xc2070
-#define CSDM_REG_AGG_INT_EVENT_15				 0xc2074
-#define CSDM_REG_AGG_INT_EVENT_16				 0xc2078
-#define CSDM_REG_AGG_INT_EVENT_2				 0xc2040
-#define CSDM_REG_AGG_INT_EVENT_3				 0xc2044
-#define CSDM_REG_AGG_INT_EVENT_4				 0xc2048
-#define CSDM_REG_AGG_INT_EVENT_5				 0xc204c
-#define CSDM_REG_AGG_INT_EVENT_6				 0xc2050
-#define CSDM_REG_AGG_INT_EVENT_7				 0xc2054
-#define CSDM_REG_AGG_INT_EVENT_8				 0xc2058
-#define CSDM_REG_AGG_INT_EVENT_9				 0xc205c
-/* [RW 1] For each aggregated interrupt index whether the mode is normal (0)
-   or auto-mask-mode (1) */
-#define CSDM_REG_AGG_INT_MODE_10				 0xc21e0
-#define CSDM_REG_AGG_INT_MODE_11				 0xc21e4
-#define CSDM_REG_AGG_INT_MODE_12				 0xc21e8
-#define CSDM_REG_AGG_INT_MODE_13				 0xc21ec
-#define CSDM_REG_AGG_INT_MODE_14				 0xc21f0
-#define CSDM_REG_AGG_INT_MODE_15				 0xc21f4
-#define CSDM_REG_AGG_INT_MODE_16				 0xc21f8
-#define CSDM_REG_AGG_INT_MODE_6 				 0xc21d0
-#define CSDM_REG_AGG_INT_MODE_7 				 0xc21d4
-#define CSDM_REG_AGG_INT_MODE_8 				 0xc21d8
-#define CSDM_REG_AGG_INT_MODE_9 				 0xc21dc
-/* [RW 13] The start address in the internal RAM for the cfc_rsp lcid */
-#define CSDM_REG_CFC_RSP_START_ADDR				 0xc2008
-/* [RW 16] The maximum value of the competion counter #0 */
-#define CSDM_REG_CMP_COUNTER_MAX0				 0xc201c
-/* [RW 16] The maximum value of the competion counter #1 */
-#define CSDM_REG_CMP_COUNTER_MAX1				 0xc2020
-/* [RW 16] The maximum value of the competion counter #2 */
-#define CSDM_REG_CMP_COUNTER_MAX2				 0xc2024
-/* [RW 16] The maximum value of the competion counter #3 */
-#define CSDM_REG_CMP_COUNTER_MAX3				 0xc2028
-/* [RW 13] The start address in the internal RAM for the completion
-   counters. */
-#define CSDM_REG_CMP_COUNTER_START_ADDR 			 0xc200c
-/* [RW 32] Interrupt mask register #0 read/write */
-#define CSDM_REG_CSDM_INT_MASK_0				 0xc229c
-#define CSDM_REG_CSDM_INT_MASK_1				 0xc22ac
-/* [R 32] Interrupt register #0 read */
-#define CSDM_REG_CSDM_INT_STS_0 				 0xc2290
-#define CSDM_REG_CSDM_INT_STS_1 				 0xc22a0
-/* [RW 11] Parity mask register #0 read/write */
-#define CSDM_REG_CSDM_PRTY_MASK 				 0xc22bc
-/* [R 11] Parity register #0 read */
-#define CSDM_REG_CSDM_PRTY_STS					 0xc22b0
-#define CSDM_REG_ENABLE_IN1					 0xc2238
-#define CSDM_REG_ENABLE_IN2					 0xc223c
-#define CSDM_REG_ENABLE_OUT1					 0xc2240
-#define CSDM_REG_ENABLE_OUT2					 0xc2244
-/* [RW 4] The initial number of messages that can be sent to the pxp control
-   interface without receiving any ACK. */
-#define CSDM_REG_INIT_CREDIT_PXP_CTRL				 0xc24bc
-/* [ST 32] The number of ACK after placement messages received */
-#define CSDM_REG_NUM_OF_ACK_AFTER_PLACE 			 0xc227c
-/* [ST 32] The number of packet end messages received from the parser */
-#define CSDM_REG_NUM_OF_PKT_END_MSG				 0xc2274
-/* [ST 32] The number of requests received from the pxp async if */
-#define CSDM_REG_NUM_OF_PXP_ASYNC_REQ				 0xc2278
-/* [ST 32] The number of commands received in queue 0 */
-#define CSDM_REG_NUM_OF_Q0_CMD					 0xc2248
-/* [ST 32] The number of commands received in queue 10 */
-#define CSDM_REG_NUM_OF_Q10_CMD 				 0xc226c
-/* [ST 32] The number of commands received in queue 11 */
-#define CSDM_REG_NUM_OF_Q11_CMD 				 0xc2270
-/* [ST 32] The number of commands received in queue 1 */
-#define CSDM_REG_NUM_OF_Q1_CMD					 0xc224c
-/* [ST 32] The number of commands received in queue 3 */
-#define CSDM_REG_NUM_OF_Q3_CMD					 0xc2250
-/* [ST 32] The number of commands received in queue 4 */
-#define CSDM_REG_NUM_OF_Q4_CMD					 0xc2254
-/* [ST 32] The number of commands received in queue 5 */
-#define CSDM_REG_NUM_OF_Q5_CMD					 0xc2258
-/* [ST 32] The number of commands received in queue 6 */
-#define CSDM_REG_NUM_OF_Q6_CMD					 0xc225c
-/* [ST 32] The number of commands received in queue 7 */
-#define CSDM_REG_NUM_OF_Q7_CMD					 0xc2260
-/* [ST 32] The number of commands received in queue 8 */
-#define CSDM_REG_NUM_OF_Q8_CMD					 0xc2264
-/* [ST 32] The number of commands received in queue 9 */
-#define CSDM_REG_NUM_OF_Q9_CMD					 0xc2268
-/* [RW 13] The start address in the internal RAM for queue counters */
-#define CSDM_REG_Q_COUNTER_START_ADDR				 0xc2010
-/* [R 1] pxp_ctrl rd_data fifo empty in sdm_dma_rsp block */
-#define CSDM_REG_RSP_PXP_CTRL_RDATA_EMPTY			 0xc2548
-/* [R 1] parser fifo empty in sdm_sync block */
-#define CSDM_REG_SYNC_PARSER_EMPTY				 0xc2550
-/* [R 1] parser serial fifo empty in sdm_sync block */
-#define CSDM_REG_SYNC_SYNC_EMPTY				 0xc2558
-/* [RW 32] Tick for timer counter. Applicable only when
-   ~csdm_registers_timer_tick_enable.timer_tick_enable =1 */
-#define CSDM_REG_TIMER_TICK					 0xc2000
-/* [RW 5] The number of time_slots in the arbitration cycle */
-#define CSEM_REG_ARB_CYCLE_SIZE 				 0x200034
-/* [RW 3] The source that is associated with arbitration element 0. Source
-   decoding is: 0- foc0; 1-fic1; 2-sleeping thread with priority 0; 3-
-   sleeping thread with priority 1; 4- sleeping thread with priority 2 */
-#define CSEM_REG_ARB_ELEMENT0					 0x200020
-/* [RW 3] The source that is associated with arbitration element 1. Source
-   decoding is: 0- foc0; 1-fic1; 2-sleeping thread with priority 0; 3-
-   sleeping thread with priority 1; 4- sleeping thread with priority 2.
-   Could not be equal to register ~csem_registers_arb_element0.arb_element0 */
-#define CSEM_REG_ARB_ELEMENT1					 0x200024
-/* [RW 3] The source that is associated with arbitration element 2. Source
-   decoding is: 0- foc0; 1-fic1; 2-sleeping thread with priority 0; 3-
-   sleeping thread with priority 1; 4- sleeping thread with priority 2.
-   Could not be equal to register ~csem_registers_arb_element0.arb_element0
-   and ~csem_registers_arb_element1.arb_element1 */
-#define CSEM_REG_ARB_ELEMENT2					 0x200028
-/* [RW 3] The source that is associated with arbitration element 3. Source
-   decoding is: 0- foc0; 1-fic1; 2-sleeping thread with priority 0; 3-
-   sleeping thread with priority 1; 4- sleeping thread with priority 2.Could
-   not be equal to register ~csem_registers_arb_element0.arb_element0 and
-   ~csem_registers_arb_element1.arb_element1 and
-   ~csem_registers_arb_element2.arb_element2 */
-#define CSEM_REG_ARB_ELEMENT3					 0x20002c
-/* [RW 3] The source that is associated with arbitration element 4. Source
-   decoding is: 0- foc0; 1-fic1; 2-sleeping thread with priority 0; 3-
-   sleeping thread with priority 1; 4- sleeping thread with priority 2.
-   Could not be equal to register ~csem_registers_arb_element0.arb_element0
-   and ~csem_registers_arb_element1.arb_element1 and
-   ~csem_registers_arb_element2.arb_element2 and
-   ~csem_registers_arb_element3.arb_element3 */
-#define CSEM_REG_ARB_ELEMENT4					 0x200030
-/* [RW 32] Interrupt mask register #0 read/write */
-#define CSEM_REG_CSEM_INT_MASK_0				 0x200110
-#define CSEM_REG_CSEM_INT_MASK_1				 0x200120
-/* [R 32] Interrupt register #0 read */
-#define CSEM_REG_CSEM_INT_STS_0 				 0x200104
-#define CSEM_REG_CSEM_INT_STS_1 				 0x200114
-/* [RW 32] Parity mask register #0 read/write */
-#define CSEM_REG_CSEM_PRTY_MASK_0				 0x200130
-#define CSEM_REG_CSEM_PRTY_MASK_1				 0x200140
-/* [R 32] Parity register #0 read */
-#define CSEM_REG_CSEM_PRTY_STS_0				 0x200124
-#define CSEM_REG_CSEM_PRTY_STS_1				 0x200134
-#define CSEM_REG_ENABLE_IN					 0x2000a4
-#define CSEM_REG_ENABLE_OUT					 0x2000a8
-/* [RW 32] This address space contains all registers and memories that are
-   placed in SEM_FAST block. The SEM_FAST registers are described in
-   appendix B. In order to access the sem_fast registers the base address
-   ~fast_memory.fast_memory should be added to eachsem_fast register offset. */
-#define CSEM_REG_FAST_MEMORY					 0x220000
-/* [RW 1] Disables input messages from FIC0 May be updated during run_time
-   by the microcode */
-#define CSEM_REG_FIC0_DISABLE					 0x200224
-/* [RW 1] Disables input messages from FIC1 May be updated during run_time
-   by the microcode */
-#define CSEM_REG_FIC1_DISABLE					 0x200234
-/* [RW 15] Interrupt table Read and write access to it is not possible in
-   the middle of the work */
-#define CSEM_REG_INT_TABLE					 0x200400
-/* [ST 24] Statistics register. The number of messages that entered through
-   FIC0 */
-#define CSEM_REG_MSG_NUM_FIC0					 0x200000
-/* [ST 24] Statistics register. The number of messages that entered through
-   FIC1 */
-#define CSEM_REG_MSG_NUM_FIC1					 0x200004
-/* [ST 24] Statistics register. The number of messages that were sent to
-   FOC0 */
-#define CSEM_REG_MSG_NUM_FOC0					 0x200008
-/* [ST 24] Statistics register. The number of messages that were sent to
-   FOC1 */
-#define CSEM_REG_MSG_NUM_FOC1					 0x20000c
-/* [ST 24] Statistics register. The number of messages that were sent to
-   FOC2 */
-#define CSEM_REG_MSG_NUM_FOC2					 0x200010
-/* [ST 24] Statistics register. The number of messages that were sent to
-   FOC3 */
-#define CSEM_REG_MSG_NUM_FOC3					 0x200014
-/* [RW 1] Disables input messages from the passive buffer May be updated
-   during run_time by the microcode */
-#define CSEM_REG_PAS_DISABLE					 0x20024c
-/* [WB 128] Debug only. Passive buffer memory */
-#define CSEM_REG_PASSIVE_BUFFER 				 0x202000
-/* [WB 46] pram memory. B45 is parity; b[44:0] - data. */
-#define CSEM_REG_PRAM						 0x240000
-/* [R 16] Valid sleeping threads indication have bit per thread */
-#define CSEM_REG_SLEEP_THREADS_VALID				 0x20026c
-/* [R 1] EXT_STORE FIFO is empty in sem_slow_ls_ext */
-#define CSEM_REG_SLOW_EXT_STORE_EMPTY				 0x2002a0
-/* [RW 16] List of free threads . There is a bit per thread. */
-#define CSEM_REG_THREADS_LIST					 0x2002e4
-/* [RW 3] The arbitration scheme of time_slot 0 */
-#define CSEM_REG_TS_0_AS					 0x200038
-/* [RW 3] The arbitration scheme of time_slot 10 */
-#define CSEM_REG_TS_10_AS					 0x200060
-/* [RW 3] The arbitration scheme of time_slot 11 */
-#define CSEM_REG_TS_11_AS					 0x200064
-/* [RW 3] The arbitration scheme of time_slot 12 */
-#define CSEM_REG_TS_12_AS					 0x200068
-/* [RW 3] The arbitration scheme of time_slot 13 */
-#define CSEM_REG_TS_13_AS					 0x20006c
-/* [RW 3] The arbitration scheme of time_slot 14 */
-#define CSEM_REG_TS_14_AS					 0x200070
-/* [RW 3] The arbitration scheme of time_slot 15 */
-#define CSEM_REG_TS_15_AS					 0x200074
-/* [RW 3] The arbitration scheme of time_slot 16 */
-#define CSEM_REG_TS_16_AS					 0x200078
-/* [RW 3] The arbitration scheme of time_slot 17 */
-#define CSEM_REG_TS_17_AS					 0x20007c
-/* [RW 3] The arbitration scheme of time_slot 18 */
-#define CSEM_REG_TS_18_AS					 0x200080
-/* [RW 3] The arbitration scheme of time_slot 1 */
-#define CSEM_REG_TS_1_AS					 0x20003c
-/* [RW 3] The arbitration scheme of time_slot 2 */
-#define CSEM_REG_TS_2_AS					 0x200040
-/* [RW 3] The arbitration scheme of time_slot 3 */
-#define CSEM_REG_TS_3_AS					 0x200044
-/* [RW 3] The arbitration scheme of time_slot 4 */
-#define CSEM_REG_TS_4_AS					 0x200048
-/* [RW 3] The arbitration scheme of time_slot 5 */
-#define CSEM_REG_TS_5_AS					 0x20004c
-/* [RW 3] The arbitration scheme of time_slot 6 */
-#define CSEM_REG_TS_6_AS					 0x200050
-/* [RW 3] The arbitration scheme of time_slot 7 */
-#define CSEM_REG_TS_7_AS					 0x200054
-/* [RW 3] The arbitration scheme of time_slot 8 */
-#define CSEM_REG_TS_8_AS					 0x200058
-/* [RW 3] The arbitration scheme of time_slot 9 */
-#define CSEM_REG_TS_9_AS					 0x20005c
-/* [RW 1] Parity mask register #0 read/write */
-#define DBG_REG_DBG_PRTY_MASK					 0xc0a8
-/* [R 1] Parity register #0 read */
-#define DBG_REG_DBG_PRTY_STS					 0xc09c
-/* [RW 32] Commands memory. The address to command X; row Y is to calculated
-   as 14*X+Y. */
-#define DMAE_REG_CMD_MEM					 0x102400
-#define DMAE_REG_CMD_MEM_SIZE					 224
-/* [RW 1] If 0 - the CRC-16c initial value is all zeroes; if 1 - the CRC-16c
-   initial value is all ones. */
-#define DMAE_REG_CRC16C_INIT					 0x10201c
-/* [RW 1] If 0 - the CRC-16 T10 initial value is all zeroes; if 1 - the
-   CRC-16 T10 initial value is all ones. */
-#define DMAE_REG_CRC16T10_INIT					 0x102020
-/* [RW 2] Interrupt mask register #0 read/write */
-#define DMAE_REG_DMAE_INT_MASK					 0x102054
-/* [RW 4] Parity mask register #0 read/write */
-#define DMAE_REG_DMAE_PRTY_MASK 				 0x102064
-/* [R 4] Parity register #0 read */
-#define DMAE_REG_DMAE_PRTY_STS					 0x102058
-/* [RW 1] Command 0 go. */
-#define DMAE_REG_GO_C0						 0x102080
-/* [RW 1] Command 1 go. */
-#define DMAE_REG_GO_C1						 0x102084
-/* [RW 1] Command 10 go. */
-#define DMAE_REG_GO_C10 					 0x102088
-/* [RW 1] Command 11 go. */
-#define DMAE_REG_GO_C11 					 0x10208c
-/* [RW 1] Command 12 go. */
-#define DMAE_REG_GO_C12 					 0x102090
-/* [RW 1] Command 13 go. */
-#define DMAE_REG_GO_C13 					 0x102094
-/* [RW 1] Command 14 go. */
-#define DMAE_REG_GO_C14 					 0x102098
-/* [RW 1] Command 15 go. */
-#define DMAE_REG_GO_C15 					 0x10209c
-/* [RW 1] Command 2 go. */
-#define DMAE_REG_GO_C2						 0x1020a0
-/* [RW 1] Command 3 go. */
-#define DMAE_REG_GO_C3						 0x1020a4
-/* [RW 1] Command 4 go. */
-#define DMAE_REG_GO_C4						 0x1020a8
-/* [RW 1] Command 5 go. */
-#define DMAE_REG_GO_C5						 0x1020ac
-/* [RW 1] Command 6 go. */
-#define DMAE_REG_GO_C6						 0x1020b0
-/* [RW 1] Command 7 go. */
-#define DMAE_REG_GO_C7						 0x1020b4
-/* [RW 1] Command 8 go. */
-#define DMAE_REG_GO_C8						 0x1020b8
-/* [RW 1] Command 9 go. */
-#define DMAE_REG_GO_C9						 0x1020bc
-/* [RW 1] DMAE GRC Interface (Target; aster) enable. If 0 - the acknowledge
-   input is disregarded; valid is deasserted; all other signals are treated
-   as usual; if 1 - normal activity. */
-#define DMAE_REG_GRC_IFEN					 0x102008
-/* [RW 1] DMAE PCI Interface (Request; ead; rite) enable. If 0 - the
-   acknowledge input is disregarded; valid is deasserted; full is asserted;
-   all other signals are treated as usual; if 1 - normal activity. */
-#define DMAE_REG_PCI_IFEN					 0x102004
-/* [RW 4] DMAE- PCI Request Interface initial credit. Write writes the
-   initial value to the credit counter; related to the address. Read returns
-   the current value of the counter. */
-#define DMAE_REG_PXP_REQ_INIT_CRD				 0x1020c0
-/* [RW 8] Aggregation command. */
-#define DORQ_REG_AGG_CMD0					 0x170060
-/* [RW 8] Aggregation command. */
-#define DORQ_REG_AGG_CMD1					 0x170064
-/* [RW 8] Aggregation command. */
-#define DORQ_REG_AGG_CMD2					 0x170068
-/* [RW 8] Aggregation command. */
-#define DORQ_REG_AGG_CMD3					 0x17006c
-/* [RW 28] UCM Header. */
-#define DORQ_REG_CMHEAD_RX					 0x170050
-/* [RW 32] Doorbell address for RBC doorbells (function 0). */
-#define DORQ_REG_DB_ADDR0					 0x17008c
-/* [RW 5] Interrupt mask register #0 read/write */
-#define DORQ_REG_DORQ_INT_MASK					 0x170180
-/* [R 5] Interrupt register #0 read */
-#define DORQ_REG_DORQ_INT_STS					 0x170174
-/* [RC 5] Interrupt register #0 read clear */
-#define DORQ_REG_DORQ_INT_STS_CLR				 0x170178
-/* [RW 2] Parity mask register #0 read/write */
-#define DORQ_REG_DORQ_PRTY_MASK 				 0x170190
-/* [R 2] Parity register #0 read */
-#define DORQ_REG_DORQ_PRTY_STS					 0x170184
-/* [RW 8] The address to write the DPM CID to STORM. */
-#define DORQ_REG_DPM_CID_ADDR					 0x170044
-/* [RW 5] The DPM mode CID extraction offset. */
-#define DORQ_REG_DPM_CID_OFST					 0x170030
-/* [RW 12] The threshold of the DQ FIFO to send the almost full interrupt. */
-#define DORQ_REG_DQ_FIFO_AFULL_TH				 0x17007c
-/* [RW 12] The threshold of the DQ FIFO to send the full interrupt. */
-#define DORQ_REG_DQ_FIFO_FULL_TH				 0x170078
-/* [R 13] Current value of the DQ FIFO fill level according to following
-   pointer. The range is 0 - 256 FIFO rows; where each row stands for the
-   doorbell. */
-#define DORQ_REG_DQ_FILL_LVLF					 0x1700a4
-/* [R 1] DQ FIFO full status. Is set; when FIFO filling level is more or
-   equal to full threshold; reset on full clear. */
-#define DORQ_REG_DQ_FULL_ST					 0x1700c0
-/* [RW 28] The value sent to CM header in the case of CFC load error. */
-#define DORQ_REG_ERR_CMHEAD					 0x170058
-#define DORQ_REG_IF_EN						 0x170004
-#define DORQ_REG_MODE_ACT					 0x170008
-/* [RW 5] The normal mode CID extraction offset. */
-#define DORQ_REG_NORM_CID_OFST					 0x17002c
-/* [RW 28] TCM Header when only TCP context is loaded. */
-#define DORQ_REG_NORM_CMHEAD_TX 				 0x17004c
-/* [RW 3] The number of simultaneous outstanding requests to Context Fetch
-   Interface. */
-#define DORQ_REG_OUTST_REQ					 0x17003c
-#define DORQ_REG_REGN						 0x170038
-/* [R 4] Current value of response A counter credit. Initial credit is
-   configured through write to ~dorq_registers_rsp_init_crd.rsp_init_crd
-   register. */
-#define DORQ_REG_RSPA_CRD_CNT					 0x1700ac
-/* [R 4] Current value of response B counter credit. Initial credit is
-   configured through write to ~dorq_registers_rsp_init_crd.rsp_init_crd
-   register. */
-#define DORQ_REG_RSPB_CRD_CNT					 0x1700b0
-/* [RW 4] The initial credit at the Doorbell Response Interface. The write
-   writes the same initial credit to the rspa_crd_cnt and rspb_crd_cnt. The
-   read reads this written value. */
-#define DORQ_REG_RSP_INIT_CRD					 0x170048
-/* [RW 4] Initial activity counter value on the load request; when the
-   shortcut is done. */
-#define DORQ_REG_SHRT_ACT_CNT					 0x170070
-/* [RW 28] TCM Header when both ULP and TCP context is loaded. */
-#define DORQ_REG_SHRT_CMHEAD					 0x170054
-#define HC_CONFIG_0_REG_ATTN_BIT_EN_0				 (0x1<<4)
-#define HC_CONFIG_0_REG_INT_LINE_EN_0				 (0x1<<3)
-#define HC_CONFIG_0_REG_MSI_ATTN_EN_0				 (0x1<<7)
-#define HC_CONFIG_0_REG_MSI_MSIX_INT_EN_0			 (0x1<<2)
-#define HC_CONFIG_0_REG_SINGLE_ISR_EN_0 			 (0x1<<1)
-#define HC_REG_AGG_INT_0					 0x108050
-#define HC_REG_AGG_INT_1					 0x108054
-#define HC_REG_ATTN_BIT 					 0x108120
-#define HC_REG_ATTN_IDX 					 0x108100
-#define HC_REG_ATTN_MSG0_ADDR_L 				 0x108018
-#define HC_REG_ATTN_MSG1_ADDR_L 				 0x108020
-#define HC_REG_ATTN_NUM_P0					 0x108038
-#define HC_REG_ATTN_NUM_P1					 0x10803c
-#define HC_REG_COMMAND_REG					 0x108180
-#define HC_REG_CONFIG_0 					 0x108000
-#define HC_REG_CONFIG_1 					 0x108004
-#define HC_REG_FUNC_NUM_P0					 0x1080ac
-#define HC_REG_FUNC_NUM_P1					 0x1080b0
-/* [RW 3] Parity mask register #0 read/write */
-#define HC_REG_HC_PRTY_MASK					 0x1080a0
-/* [R 3] Parity register #0 read */
-#define HC_REG_HC_PRTY_STS					 0x108094
-#define HC_REG_INT_MASK 					 0x108108
-#define HC_REG_LEADING_EDGE_0					 0x108040
-#define HC_REG_LEADING_EDGE_1					 0x108048
-#define HC_REG_P0_PROD_CONS					 0x108200
-#define HC_REG_P1_PROD_CONS					 0x108400
-#define HC_REG_PBA_COMMAND					 0x108140
-#define HC_REG_PCI_CONFIG_0					 0x108010
-#define HC_REG_PCI_CONFIG_1					 0x108014
-#define HC_REG_STATISTIC_COUNTERS				 0x109000
-#define HC_REG_TRAILING_EDGE_0					 0x108044
-#define HC_REG_TRAILING_EDGE_1					 0x10804c
-#define HC_REG_UC_RAM_ADDR_0					 0x108028
-#define HC_REG_UC_RAM_ADDR_1					 0x108030
-#define HC_REG_USTORM_ADDR_FOR_COALESCE 			 0x108068
-#define HC_REG_VQID_0						 0x108008
-#define HC_REG_VQID_1						 0x10800c
-#define MCP_REG_MCPR_NVM_ACCESS_ENABLE				 0x86424
-#define MCP_REG_MCPR_NVM_ADDR					 0x8640c
-#define MCP_REG_MCPR_NVM_CFG4					 0x8642c
-#define MCP_REG_MCPR_NVM_COMMAND				 0x86400
-#define MCP_REG_MCPR_NVM_READ					 0x86410
-#define MCP_REG_MCPR_NVM_SW_ARB 				 0x86420
-#define MCP_REG_MCPR_NVM_WRITE					 0x86408
-#define MCP_REG_MCPR_SCRATCH					 0xa0000
-/* [R 32] read first 32 bit after inversion of function 0. mapped as
-   follows: [0] NIG attention for function0; [1] NIG attention for
-   function1; [2] GPIO1 mcp; [3] GPIO2 mcp; [4] GPIO3 mcp; [5] GPIO4 mcp;
-   [6] GPIO1 function 1; [7] GPIO2 function 1; [8] GPIO3 function 1; [9]
-   GPIO4 function 1; [10] PCIE glue/PXP VPD event function0; [11] PCIE
-   glue/PXP VPD event function1; [12] PCIE glue/PXP Expansion ROM event0;
-   [13] PCIE glue/PXP Expansion ROM event1; [14] SPIO4; [15] SPIO5; [16]
-   MSI/X indication for mcp; [17] MSI/X indication for function 1; [18] BRB
-   Parity error; [19] BRB Hw interrupt; [20] PRS Parity error; [21] PRS Hw
-   interrupt; [22] SRC Parity error; [23] SRC Hw interrupt; [24] TSDM Parity
-   error; [25] TSDM Hw interrupt; [26] TCM Parity error; [27] TCM Hw
-   interrupt; [28] TSEMI Parity error; [29] TSEMI Hw interrupt; [30] PBF
-   Parity error; [31] PBF Hw interrupt; */
-#define MISC_REG_AEU_AFTER_INVERT_1_FUNC_0			 0xa42c
-#define MISC_REG_AEU_AFTER_INVERT_1_FUNC_1			 0xa430
-/* [R 32] read first 32 bit after inversion of mcp. mapped as follows: [0]
-   NIG attention for function0; [1] NIG attention for function1; [2] GPIO1
-   mcp; [3] GPIO2 mcp; [4] GPIO3 mcp; [5] GPIO4 mcp; [6] GPIO1 function 1;
-   [7] GPIO2 function 1; [8] GPIO3 function 1; [9] GPIO4 function 1; [10]
-   PCIE glue/PXP VPD event function0; [11] PCIE glue/PXP VPD event
-   function1; [12] PCIE glue/PXP Expansion ROM event0; [13] PCIE glue/PXP
-   Expansion ROM event1; [14] SPIO4; [15] SPIO5; [16] MSI/X indication for
-   mcp; [17] MSI/X indication for function 1; [18] BRB Parity error; [19]
-   BRB Hw interrupt; [20] PRS Parity error; [21] PRS Hw interrupt; [22] SRC
-   Parity error; [23] SRC Hw interrupt; [24] TSDM Parity error; [25] TSDM Hw
-   interrupt; [26] TCM Parity error; [27] TCM Hw interrupt; [28] TSEMI
-   Parity error; [29] TSEMI Hw interrupt; [30] PBF Parity error; [31] PBF Hw
-   interrupt; */
-#define MISC_REG_AEU_AFTER_INVERT_1_MCP 			 0xa434
-/* [R 32] read second 32 bit after inversion of function 0. mapped as
-   follows: [0] PBClient Parity error; [1] PBClient Hw interrupt; [2] QM
-   Parity error; [3] QM Hw interrupt; [4] Timers Parity error; [5] Timers Hw
-   interrupt; [6] XSDM Parity error; [7] XSDM Hw interrupt; [8] XCM Parity
-   error; [9] XCM Hw interrupt; [10] XSEMI Parity error; [11] XSEMI Hw
-   interrupt; [12] DoorbellQ Parity error; [13] DoorbellQ Hw interrupt; [14]
-   NIG Parity error; [15] NIG Hw interrupt; [16] Vaux PCI core Parity error;
-   [17] Vaux PCI core Hw interrupt; [18] Debug Parity error; [19] Debug Hw
-   interrupt; [20] USDM Parity error; [21] USDM Hw interrupt; [22] UCM
-   Parity error; [23] UCM Hw interrupt; [24] USEMI Parity error; [25] USEMI
-   Hw interrupt; [26] UPB Parity error; [27] UPB Hw interrupt; [28] CSDM
-   Parity error; [29] CSDM Hw interrupt; [30] CCM Parity error; [31] CCM Hw
-   interrupt; */
-#define MISC_REG_AEU_AFTER_INVERT_2_FUNC_0			 0xa438
-#define MISC_REG_AEU_AFTER_INVERT_2_FUNC_1			 0xa43c
-/* [R 32] read second 32 bit after inversion of mcp. mapped as follows: [0]
-   PBClient Parity error; [1] PBClient Hw interrupt; [2] QM Parity error;
-   [3] QM Hw interrupt; [4] Timers Parity error; [5] Timers Hw interrupt;
-   [6] XSDM Parity error; [7] XSDM Hw interrupt; [8] XCM Parity error; [9]
-   XCM Hw interrupt; [10] XSEMI Parity error; [11] XSEMI Hw interrupt; [12]
-   DoorbellQ Parity error; [13] DoorbellQ Hw interrupt; [14] NIG Parity
-   error; [15] NIG Hw interrupt; [16] Vaux PCI core Parity error; [17] Vaux
-   PCI core Hw interrupt; [18] Debug Parity error; [19] Debug Hw interrupt;
-   [20] USDM Parity error; [21] USDM Hw interrupt; [22] UCM Parity error;
-   [23] UCM Hw interrupt; [24] USEMI Parity error; [25] USEMI Hw interrupt;
-   [26] UPB Parity error; [27] UPB Hw interrupt; [28] CSDM Parity error;
-   [29] CSDM Hw interrupt; [30] CCM Parity error; [31] CCM Hw interrupt; */
-#define MISC_REG_AEU_AFTER_INVERT_2_MCP 			 0xa440
-/* [R 32] read third 32 bit after inversion of function 0. mapped as
-   follows: [0] CSEMI Parity error; [1] CSEMI Hw interrupt; [2] PXP Parity
-   error; [3] PXP Hw interrupt; [4] PXPpciClockClient Parity error; [5]
-   PXPpciClockClient Hw interrupt; [6] CFC Parity error; [7] CFC Hw
-   interrupt; [8] CDU Parity error; [9] CDU Hw interrupt; [10] DMAE Parity
-   error; [11] DMAE Hw interrupt; [12] IGU (HC) Parity error; [13] IGU (HC)
-   Hw interrupt; [14] MISC Parity error; [15] MISC Hw interrupt; [16]
-   pxp_misc_mps_attn; [17] Flash event; [18] SMB event; [19] MCP attn0; [20]
-   MCP attn1; [21] SW timers attn_1 func0; [22] SW timers attn_2 func0; [23]
-   SW timers attn_3 func0; [24] SW timers attn_4 func0; [25] PERST; [26] SW
-   timers attn_1 func1; [27] SW timers attn_2 func1; [28] SW timers attn_3
-   func1; [29] SW timers attn_4 func1; [30] General attn0; [31] General
-   attn1; */
-#define MISC_REG_AEU_AFTER_INVERT_3_FUNC_0			 0xa444
-#define MISC_REG_AEU_AFTER_INVERT_3_FUNC_1			 0xa448
-/* [R 32] read third 32 bit after inversion of mcp. mapped as follows: [0]
-   CSEMI Parity error; [1] CSEMI Hw interrupt; [2] PXP Parity error; [3] PXP
-   Hw interrupt; [4] PXPpciClockClient Parity error; [5] PXPpciClockClient
-   Hw interrupt; [6] CFC Parity error; [7] CFC Hw interrupt; [8] CDU Parity
-   error; [9] CDU Hw interrupt; [10] DMAE Parity error; [11] DMAE Hw
-   interrupt; [12] IGU (HC) Parity error; [13] IGU (HC) Hw interrupt; [14]
-   MISC Parity error; [15] MISC Hw interrupt; [16] pxp_misc_mps_attn; [17]
-   Flash event; [18] SMB event; [19] MCP attn0; [20] MCP attn1; [21] SW
-   timers attn_1 func0; [22] SW timers attn_2 func0; [23] SW timers attn_3
-   func0; [24] SW timers attn_4 func0; [25] PERST; [26] SW timers attn_1
-   func1; [27] SW timers attn_2 func1; [28] SW timers attn_3 func1; [29] SW
-   timers attn_4 func1; [30] General attn0; [31] General attn1; */
-#define MISC_REG_AEU_AFTER_INVERT_3_MCP 			 0xa44c
-/* [R 32] read fourth 32 bit after inversion of function 0. mapped as
-   follows: [0] General attn2; [1] General attn3; [2] General attn4; [3]
-   General attn5; [4] General attn6; [5] General attn7; [6] General attn8;
-   [7] General attn9; [8] General attn10; [9] General attn11; [10] General
-   attn12; [11] General attn13; [12] General attn14; [13] General attn15;
-   [14] General attn16; [15] General attn17; [16] General attn18; [17]
-   General attn19; [18] General attn20; [19] General attn21; [20] Main power
-   interrupt; [21] RBCR Latched attn; [22] RBCT Latched attn; [23] RBCN
-   Latched attn; [24] RBCU Latched attn; [25] RBCP Latched attn; [26] GRC
-   Latched timeout attention; [27] GRC Latched reserved access attention;
-   [28] MCP Latched rom_parity; [29] MCP Latched ump_rx_parity; [30] MCP
-   Latched ump_tx_parity; [31] MCP Latched scpad_parity; */
-#define MISC_REG_AEU_AFTER_INVERT_4_FUNC_0			 0xa450
-#define MISC_REG_AEU_AFTER_INVERT_4_FUNC_1			 0xa454
-/* [R 32] read fourth 32 bit after inversion of mcp. mapped as follows: [0]
-   General attn2; [1] General attn3; [2] General attn4; [3] General attn5;
-   [4] General attn6; [5] General attn7; [6] General attn8; [7] General
-   attn9; [8] General attn10; [9] General attn11; [10] General attn12; [11]
-   General attn13; [12] General attn14; [13] General attn15; [14] General
-   attn16; [15] General attn17; [16] General attn18; [17] General attn19;
-   [18] General attn20; [19] General attn21; [20] Main power interrupt; [21]
-   RBCR Latched attn; [22] RBCT Latched attn; [23] RBCN Latched attn; [24]
-   RBCU Latched attn; [25] RBCP Latched attn; [26] GRC Latched timeout
-   attention; [27] GRC Latched reserved access attention; [28] MCP Latched
-   rom_parity; [29] MCP Latched ump_rx_parity; [30] MCP Latched
-   ump_tx_parity; [31] MCP Latched scpad_parity; */
-#define MISC_REG_AEU_AFTER_INVERT_4_MCP 			 0xa458
-/* [W 14] write to this register results with the clear of the latched
-   signals; one in d0 clears RBCR latch; one in d1 clears RBCT latch; one in
-   d2 clears RBCN latch; one in d3 clears RBCU latch; one in d4 clears RBCP
-   latch; one in d5 clears GRC Latched timeout attention; one in d6 clears
-   GRC Latched reserved access attention; one in d7 clears Latched
-   rom_parity; one in d8 clears Latched ump_rx_parity; one in d9 clears
-   Latched ump_tx_parity; one in d10 clears Latched scpad_parity (both
-   ports); one in d11 clears pxpv_misc_mps_attn; one in d12 clears
-   pxp_misc_exp_rom_attn0; one in d13 clears pxp_misc_exp_rom_attn1; read
-   from this register return zero */
-#define MISC_REG_AEU_CLR_LATCH_SIGNAL				 0xa45c
-/* [RW 32] first 32b for enabling the output for function 0 output0. mapped
-   as follows: [0] NIG attention for function0; [1] NIG attention for
-   function1; [2] GPIO1 function 0; [3] GPIO2 function 0; [4] GPIO3 function
-   0; [5] GPIO4 function 0; [6] GPIO1 function 1; [7] GPIO2 function 1; [8]
-   GPIO3 function 1; [9] GPIO4 function 1; [10] PCIE glue/PXP VPD event
-   function0; [11] PCIE glue/PXP VPD event function1; [12] PCIE glue/PXP
-   Expansion ROM event0; [13] PCIE glue/PXP Expansion ROM event1; [14]
-   SPIO4; [15] SPIO5; [16] MSI/X indication for function 0; [17] MSI/X
-   indication for function 1; [18] BRB Parity error; [19] BRB Hw interrupt;
-   [20] PRS Parity error; [21] PRS Hw interrupt; [22] SRC Parity error; [23]
-   SRC Hw interrupt; [24] TSDM Parity error; [25] TSDM Hw interrupt; [26]
-   TCM Parity error; [27] TCM Hw interrupt; [28] TSEMI Parity error; [29]
-   TSEMI Hw interrupt; [30] PBF Parity error; [31] PBF Hw interrupt; */
-#define MISC_REG_AEU_ENABLE1_FUNC_0_OUT_0			 0xa06c
-#define MISC_REG_AEU_ENABLE1_FUNC_0_OUT_1			 0xa07c
-#define MISC_REG_AEU_ENABLE1_FUNC_0_OUT_2			 0xa08c
-#define MISC_REG_AEU_ENABLE1_FUNC_0_OUT_3			 0xa09c
-#define MISC_REG_AEU_ENABLE1_FUNC_0_OUT_5			 0xa0bc
-#define MISC_REG_AEU_ENABLE1_FUNC_0_OUT_6			 0xa0cc
-#define MISC_REG_AEU_ENABLE1_FUNC_0_OUT_7			 0xa0dc
-/* [RW 32] first 32b for enabling the output for function 1 output0. mapped
-   as follows: [0] NIG attention for function0; [1] NIG attention for
-   function1; [2] GPIO1 function 1; [3] GPIO2 function 1; [4] GPIO3 function
-   1; [5] GPIO4 function 1; [6] GPIO1 function 1; [7] GPIO2 function 1; [8]
-   GPIO3 function 1; [9] GPIO4 function 1; [10] PCIE glue/PXP VPD event
-   function0; [11] PCIE glue/PXP VPD event function1; [12] PCIE glue/PXP
-   Expansion ROM event0; [13] PCIE glue/PXP Expansion ROM event1; [14]
-   SPIO4; [15] SPIO5; [16] MSI/X indication for function 1; [17] MSI/X
-   indication for function 1; [18] BRB Parity error; [19] BRB Hw interrupt;
-   [20] PRS Parity error; [21] PRS Hw interrupt; [22] SRC Parity error; [23]
-   SRC Hw interrupt; [24] TSDM Parity error; [25] TSDM Hw interrupt; [26]
-   TCM Parity error; [27] TCM Hw interrupt; [28] TSEMI Parity error; [29]
-   TSEMI Hw interrupt; [30] PBF Parity error; [31] PBF Hw interrupt; */
-#define MISC_REG_AEU_ENABLE1_FUNC_1_OUT_0			 0xa10c
-#define MISC_REG_AEU_ENABLE1_FUNC_1_OUT_1			 0xa11c
-#define MISC_REG_AEU_ENABLE1_FUNC_1_OUT_2			 0xa12c
-#define MISC_REG_AEU_ENABLE1_FUNC_1_OUT_3			 0xa13c
-#define MISC_REG_AEU_ENABLE1_FUNC_1_OUT_5			 0xa15c
-#define MISC_REG_AEU_ENABLE1_FUNC_1_OUT_6			 0xa16c
-#define MISC_REG_AEU_ENABLE1_FUNC_1_OUT_7			 0xa17c
-/* [RW 32] first 32b for enabling the output for close the gate nig. mapped
-   as follows: [0] NIG attention for function0; [1] NIG attention for
-   function1; [2] GPIO1 function 0; [3] GPIO2 function 0; [4] GPIO3 function
-   0; [5] GPIO4 function 0; [6] GPIO1 function 1; [7] GPIO2 function 1; [8]
-   GPIO3 function 1; [9] GPIO4 function 1; [10] PCIE glue/PXP VPD event
-   function0; [11] PCIE glue/PXP VPD event function1; [12] PCIE glue/PXP
-   Expansion ROM event0; [13] PCIE glue/PXP Expansion ROM event1; [14]
-   SPIO4; [15] SPIO5; [16] MSI/X indication for function 0; [17] MSI/X
-   indication for function 1; [18] BRB Parity error; [19] BRB Hw interrupt;
-   [20] PRS Parity error; [21] PRS Hw interrupt; [22] SRC Parity error; [23]
-   SRC Hw interrupt; [24] TSDM Parity error; [25] TSDM Hw interrupt; [26]
-   TCM Parity error; [27] TCM Hw interrupt; [28] TSEMI Parity error; [29]
-   TSEMI Hw interrupt; [30] PBF Parity error; [31] PBF Hw interrupt; */
-#define MISC_REG_AEU_ENABLE1_NIG_0				 0xa0ec
-#define MISC_REG_AEU_ENABLE1_NIG_1				 0xa18c
-/* [RW 32] first 32b for enabling the output for close the gate pxp. mapped
-   as follows: [0] NIG attention for function0; [1] NIG attention for
-   function1; [2] GPIO1 function 0; [3] GPIO2 function 0; [4] GPIO3 function
-   0; [5] GPIO4 function 0; [6] GPIO1 function 1; [7] GPIO2 function 1; [8]
-   GPIO3 function 1; [9] GPIO4 function 1; [10] PCIE glue/PXP VPD event
-   function0; [11] PCIE glue/PXP VPD event function1; [12] PCIE glue/PXP
-   Expansion ROM event0; [13] PCIE glue/PXP Expansion ROM event1; [14]
-   SPIO4; [15] SPIO5; [16] MSI/X indication for function 0; [17] MSI/X
-   indication for function 1; [18] BRB Parity error; [19] BRB Hw interrupt;
-   [20] PRS Parity error; [21] PRS Hw interrupt; [22] SRC Parity error; [23]
-   SRC Hw interrupt; [24] TSDM Parity error; [25] TSDM Hw interrupt; [26]
-   TCM Parity error; [27] TCM Hw interrupt; [28] TSEMI Parity error; [29]
-   TSEMI Hw interrupt; [30] PBF Parity error; [31] PBF Hw interrupt; */
-#define MISC_REG_AEU_ENABLE1_PXP_0				 0xa0fc
-#define MISC_REG_AEU_ENABLE1_PXP_1				 0xa19c
-/* [RW 32] second 32b for enabling the output for function 0 output0. mapped
-   as follows: [0] PBClient Parity error; [1] PBClient Hw interrupt; [2] QM
-   Parity error; [3] QM Hw interrupt; [4] Timers Parity error; [5] Timers Hw
-   interrupt; [6] XSDM Parity error; [7] XSDM Hw interrupt; [8] XCM Parity
-   error; [9] XCM Hw interrupt; [10] XSEMI Parity error; [11] XSEMI Hw
-   interrupt; [12] DoorbellQ Parity error; [13] DoorbellQ Hw interrupt; [14]
-   NIG Parity error; [15] NIG Hw interrupt; [16] Vaux PCI core Parity error;
-   [17] Vaux PCI core Hw interrupt; [18] Debug Parity error; [19] Debug Hw
-   interrupt; [20] USDM Parity error; [21] USDM Hw interrupt; [22] UCM
-   Parity error; [23] UCM Hw interrupt; [24] USEMI Parity error; [25] USEMI
-   Hw interrupt; [26] UPB Parity error; [27] UPB Hw interrupt; [28] CSDM
-   Parity error; [29] CSDM Hw interrupt; [30] CCM Parity error; [31] CCM Hw
-   interrupt; */
-#define MISC_REG_AEU_ENABLE2_FUNC_0_OUT_0			 0xa070
-#define MISC_REG_AEU_ENABLE2_FUNC_0_OUT_1			 0xa080
-/* [RW 32] second 32b for enabling the output for function 1 output0. mapped
-   as follows: [0] PBClient Parity error; [1] PBClient Hw interrupt; [2] QM
-   Parity error; [3] QM Hw interrupt; [4] Timers Parity error; [5] Timers Hw
-   interrupt; [6] XSDM Parity error; [7] XSDM Hw interrupt; [8] XCM Parity
-   error; [9] XCM Hw interrupt; [10] XSEMI Parity error; [11] XSEMI Hw
-   interrupt; [12] DoorbellQ Parity error; [13] DoorbellQ Hw interrupt; [14]
-   NIG Parity error; [15] NIG Hw interrupt; [16] Vaux PCI core Parity error;
-   [17] Vaux PCI core Hw interrupt; [18] Debug Parity error; [19] Debug Hw
-   interrupt; [20] USDM Parity error; [21] USDM Hw interrupt; [22] UCM
-   Parity error; [23] UCM Hw interrupt; [24] USEMI Parity error; [25] USEMI
-   Hw interrupt; [26] UPB Parity error; [27] UPB Hw interrupt; [28] CSDM
-   Parity error; [29] CSDM Hw interrupt; [30] CCM Parity error; [31] CCM Hw
-   interrupt; */
-#define MISC_REG_AEU_ENABLE2_FUNC_1_OUT_0			 0xa110
-#define MISC_REG_AEU_ENABLE2_FUNC_1_OUT_1			 0xa120
-/* [RW 32] second 32b for enabling the output for close the gate nig. mapped
-   as follows: [0] PBClient Parity error; [1] PBClient Hw interrupt; [2] QM
-   Parity error; [3] QM Hw interrupt; [4] Timers Parity error; [5] Timers Hw
-   interrupt; [6] XSDM Parity error; [7] XSDM Hw interrupt; [8] XCM Parity
-   error; [9] XCM Hw interrupt; [10] XSEMI Parity error; [11] XSEMI Hw
-   interrupt; [12] DoorbellQ Parity error; [13] DoorbellQ Hw interrupt; [14]
-   NIG Parity error; [15] NIG Hw interrupt; [16] Vaux PCI core Parity error;
-   [17] Vaux PCI core Hw interrupt; [18] Debug Parity error; [19] Debug Hw
-   interrupt; [20] USDM Parity error; [21] USDM Hw interrupt; [22] UCM
-   Parity error; [23] UCM Hw interrupt; [24] USEMI Parity error; [25] USEMI
-   Hw interrupt; [26] UPB Parity error; [27] UPB Hw interrupt; [28] CSDM
-   Parity error; [29] CSDM Hw interrupt; [30] CCM Parity error; [31] CCM Hw
-   interrupt; */
-#define MISC_REG_AEU_ENABLE2_NIG_0				 0xa0f0
-#define MISC_REG_AEU_ENABLE2_NIG_1				 0xa190
-/* [RW 32] second 32b for enabling the output for close the gate pxp. mapped
-   as follows: [0] PBClient Parity error; [1] PBClient Hw interrupt; [2] QM
-   Parity error; [3] QM Hw interrupt; [4] Timers Parity error; [5] Timers Hw
-   interrupt; [6] XSDM Parity error; [7] XSDM Hw interrupt; [8] XCM Parity
-   error; [9] XCM Hw interrupt; [10] XSEMI Parity error; [11] XSEMI Hw
-   interrupt; [12] DoorbellQ Parity error; [13] DoorbellQ Hw interrupt; [14]
-   NIG Parity error; [15] NIG Hw interrupt; [16] Vaux PCI core Parity error;
-   [17] Vaux PCI core Hw interrupt; [18] Debug Parity error; [19] Debug Hw
-   interrupt; [20] USDM Parity error; [21] USDM Hw interrupt; [22] UCM
-   Parity error; [23] UCM Hw interrupt; [24] USEMI Parity error; [25] USEMI
-   Hw interrupt; [26] UPB Parity error; [27] UPB Hw interrupt; [28] CSDM
-   Parity error; [29] CSDM Hw interrupt; [30] CCM Parity error; [31] CCM Hw
-   interrupt; */
-#define MISC_REG_AEU_ENABLE2_PXP_0				 0xa100
-#define MISC_REG_AEU_ENABLE2_PXP_1				 0xa1a0
-/* [RW 32] third 32b for enabling the output for function 0 output0. mapped
-   as follows: [0] CSEMI Parity error; [1] CSEMI Hw interrupt; [2] PXP
-   Parity error; [3] PXP Hw interrupt; [4] PXPpciClockClient Parity error;
-   [5] PXPpciClockClient Hw interrupt; [6] CFC Parity error; [7] CFC Hw
-   interrupt; [8] CDU Parity error; [9] CDU Hw interrupt; [10] DMAE Parity
-   error; [11] DMAE Hw interrupt; [12] IGU (HC) Parity error; [13] IGU (HC)
-   Hw interrupt; [14] MISC Parity error; [15] MISC Hw interrupt; [16]
-   pxp_misc_mps_attn; [17] Flash event; [18] SMB event; [19] MCP attn0; [20]
-   MCP attn1; [21] SW timers attn_1 func0; [22] SW timers attn_2 func0; [23]
-   SW timers attn_3 func0; [24] SW timers attn_4 func0; [25] PERST; [26] SW
-   timers attn_1 func1; [27] SW timers attn_2 func1; [28] SW timers attn_3
-   func1; [29] SW timers attn_4 func1; [30] General attn0; [31] General
-   attn1; */
-#define MISC_REG_AEU_ENABLE3_FUNC_0_OUT_0			 0xa074
-#define MISC_REG_AEU_ENABLE3_FUNC_0_OUT_1			 0xa084
-/* [RW 32] third 32b for enabling the output for function 1 output0. mapped
-   as follows: [0] CSEMI Parity error; [1] CSEMI Hw interrupt; [2] PXP
-   Parity error; [3] PXP Hw interrupt; [4] PXPpciClockClient Parity error;
-   [5] PXPpciClockClient Hw interrupt; [6] CFC Parity error; [7] CFC Hw
-   interrupt; [8] CDU Parity error; [9] CDU Hw interrupt; [10] DMAE Parity
-   error; [11] DMAE Hw interrupt; [12] IGU (HC) Parity error; [13] IGU (HC)
-   Hw interrupt; [14] MISC Parity error; [15] MISC Hw interrupt; [16]
-   pxp_misc_mps_attn; [17] Flash event; [18] SMB event; [19] MCP attn0; [20]
-   MCP attn1; [21] SW timers attn_1 func0; [22] SW timers attn_2 func0; [23]
-   SW timers attn_3 func0; [24] SW timers attn_4 func0; [25] PERST; [26] SW
-   timers attn_1 func1; [27] SW timers attn_2 func1; [28] SW timers attn_3
-   func1; [29] SW timers attn_4 func1; [30] General attn0; [31] General
-   attn1; */
-#define MISC_REG_AEU_ENABLE3_FUNC_1_OUT_0			 0xa114
-#define MISC_REG_AEU_ENABLE3_FUNC_1_OUT_1			 0xa124
-/* [RW 32] third 32b for enabling the output for close the gate nig. mapped
-   as follows: [0] CSEMI Parity error; [1] CSEMI Hw interrupt; [2] PXP
-   Parity error; [3] PXP Hw interrupt; [4] PXPpciClockClient Parity error;
-   [5] PXPpciClockClient Hw interrupt; [6] CFC Parity error; [7] CFC Hw
-   interrupt; [8] CDU Parity error; [9] CDU Hw interrupt; [10] DMAE Parity
-   error; [11] DMAE Hw interrupt; [12] IGU (HC) Parity error; [13] IGU (HC)
-   Hw interrupt; [14] MISC Parity error; [15] MISC Hw interrupt; [16]
-   pxp_misc_mps_attn; [17] Flash event; [18] SMB event; [19] MCP attn0; [20]
-   MCP attn1; [21] SW timers attn_1 func0; [22] SW timers attn_2 func0; [23]
-   SW timers attn_3 func0; [24] SW timers attn_4 func0; [25] PERST; [26] SW
-   timers attn_1 func1; [27] SW timers attn_2 func1; [28] SW timers attn_3
-   func1; [29] SW timers attn_4 func1; [30] General attn0; [31] General
-   attn1; */
-#define MISC_REG_AEU_ENABLE3_NIG_0				 0xa0f4
-#define MISC_REG_AEU_ENABLE3_NIG_1				 0xa194
-/* [RW 32] third 32b for enabling the output for close the gate pxp. mapped
-   as follows: [0] CSEMI Parity error; [1] CSEMI Hw interrupt; [2] PXP
-   Parity error; [3] PXP Hw interrupt; [4] PXPpciClockClient Parity error;
-   [5] PXPpciClockClient Hw interrupt; [6] CFC Parity error; [7] CFC Hw
-   interrupt; [8] CDU Parity error; [9] CDU Hw interrupt; [10] DMAE Parity
-   error; [11] DMAE Hw interrupt; [12] IGU (HC) Parity error; [13] IGU (HC)
-   Hw interrupt; [14] MISC Parity error; [15] MISC Hw interrupt; [16]
-   pxp_misc_mps_attn; [17] Flash event; [18] SMB event; [19] MCP attn0; [20]
-   MCP attn1; [21] SW timers attn_1 func0; [22] SW timers attn_2 func0; [23]
-   SW timers attn_3 func0; [24] SW timers attn_4 func0; [25] PERST; [26] SW
-   timers attn_1 func1; [27] SW timers attn_2 func1; [28] SW timers attn_3
-   func1; [29] SW timers attn_4 func1; [30] General attn0; [31] General
-   attn1; */
-#define MISC_REG_AEU_ENABLE3_PXP_0				 0xa104
-#define MISC_REG_AEU_ENABLE3_PXP_1				 0xa1a4
-/* [RW 32] fourth 32b for enabling the output for function 0 output0.mapped
-   as follows: [0] General attn2; [1] General attn3; [2] General attn4; [3]
-   General attn5; [4] General attn6; [5] General attn7; [6] General attn8;
-   [7] General attn9; [8] General attn10; [9] General attn11; [10] General
-   attn12; [11] General attn13; [12] General attn14; [13] General attn15;
-   [14] General attn16; [15] General attn17; [16] General attn18; [17]
-   General attn19; [18] General attn20; [19] General attn21; [20] Main power
-   interrupt; [21] RBCR Latched attn; [22] RBCT Latched attn; [23] RBCN
-   Latched attn; [24] RBCU Latched attn; [25] RBCP Latched attn; [26] GRC
-   Latched timeout attention; [27] GRC Latched reserved access attention;
-   [28] MCP Latched rom_parity; [29] MCP Latched ump_rx_parity; [30] MCP
-   Latched ump_tx_parity; [31] MCP Latched scpad_parity; */
-#define MISC_REG_AEU_ENABLE4_FUNC_0_OUT_0			 0xa078
-#define MISC_REG_AEU_ENABLE4_FUNC_0_OUT_2			 0xa098
-#define MISC_REG_AEU_ENABLE4_FUNC_0_OUT_4			 0xa0b8
-#define MISC_REG_AEU_ENABLE4_FUNC_0_OUT_5			 0xa0c8
-#define MISC_REG_AEU_ENABLE4_FUNC_0_OUT_6			 0xa0d8
-#define MISC_REG_AEU_ENABLE4_FUNC_0_OUT_7			 0xa0e8
-/* [RW 32] fourth 32b for enabling the output for function 1 output0.mapped
-   as follows: [0] General attn2; [1] General attn3; [2] General attn4; [3]
-   General attn5; [4] General attn6; [5] General attn7; [6] General attn8;
-   [7] General attn9; [8] General attn10; [9] General attn11; [10] General
-   attn12; [11] General attn13; [12] General attn14; [13] General attn15;
-   [14] General attn16; [15] General attn17; [16] General attn18; [17]
-   General attn19; [18] General attn20; [19] General attn21; [20] Main power
-   interrupt; [21] RBCR Latched attn; [22] RBCT Latched attn; [23] RBCN
-   Latched attn; [24] RBCU Latched attn; [25] RBCP Latched attn; [26] GRC
-   Latched timeout attention; [27] GRC Latched reserved access attention;
-   [28] MCP Latched rom_parity; [29] MCP Latched ump_rx_parity; [30] MCP
-   Latched ump_tx_parity; [31] MCP Latched scpad_parity; */
-#define MISC_REG_AEU_ENABLE4_FUNC_1_OUT_0			 0xa118
-#define MISC_REG_AEU_ENABLE4_FUNC_1_OUT_2			 0xa138
-#define MISC_REG_AEU_ENABLE4_FUNC_1_OUT_4			 0xa158
-#define MISC_REG_AEU_ENABLE4_FUNC_1_OUT_5			 0xa168
-#define MISC_REG_AEU_ENABLE4_FUNC_1_OUT_6			 0xa178
-#define MISC_REG_AEU_ENABLE4_FUNC_1_OUT_7			 0xa188
-/* [RW 32] fourth 32b for enabling the output for close the gate nig.mapped
-   as follows: [0] General attn2; [1] General attn3; [2] General attn4; [3]
-   General attn5; [4] General attn6; [5] General attn7; [6] General attn8;
-   [7] General attn9; [8] General attn10; [9] General attn11; [10] General
-   attn12; [11] General attn13; [12] General attn14; [13] General attn15;
-   [14] General attn16; [15] General attn17; [16] General attn18; [17]
-   General attn19; [18] General attn20; [19] General attn21; [20] Main power
-   interrupt; [21] RBCR Latched attn; [22] RBCT Latched attn; [23] RBCN
-   Latched attn; [24] RBCU Latched attn; [25] RBCP Latched attn; [26] GRC
-   Latched timeout attention; [27] GRC Latched reserved access attention;
-   [28] MCP Latched rom_parity; [29] MCP Latched ump_rx_parity; [30] MCP
-   Latched ump_tx_parity; [31] MCP Latched scpad_parity; */
-#define MISC_REG_AEU_ENABLE4_NIG_0				 0xa0f8
-#define MISC_REG_AEU_ENABLE4_NIG_1				 0xa198
-/* [RW 32] fourth 32b for enabling the output for close the gate pxp.mapped
-   as follows: [0] General attn2; [1] General attn3; [2] General attn4; [3]
-   General attn5; [4] General attn6; [5] General attn7; [6] General attn8;
-   [7] General attn9; [8] General attn10; [9] General attn11; [10] General
-   attn12; [11] General attn13; [12] General attn14; [13] General attn15;
-   [14] General attn16; [15] General attn17; [16] General attn18; [17]
-   General attn19; [18] General attn20; [19] General attn21; [20] Main power
-   interrupt; [21] RBCR Latched attn; [22] RBCT Latched attn; [23] RBCN
-   Latched attn; [24] RBCU Latched attn; [25] RBCP Latched attn; [26] GRC
-   Latched timeout attention; [27] GRC Latched reserved access attention;
-   [28] MCP Latched rom_parity; [29] MCP Latched ump_rx_parity; [30] MCP
-   Latched ump_tx_parity; [31] MCP Latched scpad_parity; */
-#define MISC_REG_AEU_ENABLE4_PXP_0				 0xa108
-#define MISC_REG_AEU_ENABLE4_PXP_1				 0xa1a8
-/* [RW 1] set/clr general attention 0; this will set/clr bit 94 in the aeu
-   128 bit vector */
-#define MISC_REG_AEU_GENERAL_ATTN_0				 0xa000
-#define MISC_REG_AEU_GENERAL_ATTN_1				 0xa004
-#define MISC_REG_AEU_GENERAL_ATTN_10				 0xa028
-#define MISC_REG_AEU_GENERAL_ATTN_11				 0xa02c
-#define MISC_REG_AEU_GENERAL_ATTN_12				 0xa030
-#define MISC_REG_AEU_GENERAL_ATTN_2				 0xa008
-#define MISC_REG_AEU_GENERAL_ATTN_3				 0xa00c
-#define MISC_REG_AEU_GENERAL_ATTN_4				 0xa010
-#define MISC_REG_AEU_GENERAL_ATTN_5				 0xa014
-#define MISC_REG_AEU_GENERAL_ATTN_6				 0xa018
-#define MISC_REG_AEU_GENERAL_ATTN_7				 0xa01c
-#define MISC_REG_AEU_GENERAL_ATTN_8				 0xa020
-#define MISC_REG_AEU_GENERAL_ATTN_9				 0xa024
-#define MISC_REG_AEU_GENERAL_MASK				 0xa61c
-/* [RW 32] first 32b for inverting the input for function 0; for each bit:
-   0= do not invert; 1= invert; mapped as follows: [0] NIG attention for
-   function0; [1] NIG attention for function1; [2] GPIO1 mcp; [3] GPIO2 mcp;
-   [4] GPIO3 mcp; [5] GPIO4 mcp; [6] GPIO1 function 1; [7] GPIO2 function 1;
-   [8] GPIO3 function 1; [9] GPIO4 function 1; [10] PCIE glue/PXP VPD event
-   function0; [11] PCIE glue/PXP VPD event function1; [12] PCIE glue/PXP
-   Expansion ROM event0; [13] PCIE glue/PXP Expansion ROM event1; [14]
-   SPIO4; [15] SPIO5; [16] MSI/X indication for mcp; [17] MSI/X indication
-   for function 1; [18] BRB Parity error; [19] BRB Hw interrupt; [20] PRS
-   Parity error; [21] PRS Hw interrupt; [22] SRC Parity error; [23] SRC Hw
-   interrupt; [24] TSDM Parity error; [25] TSDM Hw interrupt; [26] TCM
-   Parity error; [27] TCM Hw interrupt; [28] TSEMI Parity error; [29] TSEMI
-   Hw interrupt; [30] PBF Parity error; [31] PBF Hw interrupt; */
-#define MISC_REG_AEU_INVERTER_1_FUNC_0				 0xa22c
-#define MISC_REG_AEU_INVERTER_1_FUNC_1				 0xa23c
-/* [RW 32] second 32b for inverting the input for function 0; for each bit:
-   0= do not invert; 1= invert. mapped as follows: [0] PBClient Parity
-   error; [1] PBClient Hw interrupt; [2] QM Parity error; [3] QM Hw
-   interrupt; [4] Timers Parity error; [5] Timers Hw interrupt; [6] XSDM
-   Parity error; [7] XSDM Hw interrupt; [8] XCM Parity error; [9] XCM Hw
-   interrupt; [10] XSEMI Parity error; [11] XSEMI Hw interrupt; [12]
-   DoorbellQ Parity error; [13] DoorbellQ Hw interrupt; [14] NIG Parity
-   error; [15] NIG Hw interrupt; [16] Vaux PCI core Parity error; [17] Vaux
-   PCI core Hw interrupt; [18] Debug Parity error; [19] Debug Hw interrupt;
-   [20] USDM Parity error; [21] USDM Hw interrupt; [22] UCM Parity error;
-   [23] UCM Hw interrupt; [24] USEMI Parity error; [25] USEMI Hw interrupt;
-   [26] UPB Parity error; [27] UPB Hw interrupt; [28] CSDM Parity error;
-   [29] CSDM Hw interrupt; [30] CCM Parity error; [31] CCM Hw interrupt; */
-#define MISC_REG_AEU_INVERTER_2_FUNC_0				 0xa230
-#define MISC_REG_AEU_INVERTER_2_FUNC_1				 0xa240
-/* [RW 10] [7:0] = mask 8 attention output signals toward IGU function0;
-   [9:8] = raserved. Zero = mask; one = unmask */
-#define MISC_REG_AEU_MASK_ATTN_FUNC_0				 0xa060
-#define MISC_REG_AEU_MASK_ATTN_FUNC_1				 0xa064
-/* [RW 1] If set a system kill occurred */
-#define MISC_REG_AEU_SYS_KILL_OCCURRED				 0xa610
-/* [RW 32] Represent the status of the input vector to the AEU when a system
-   kill occurred. The register is reset in por reset. Mapped as follows: [0]
-   NIG attention for function0; [1] NIG attention for function1; [2] GPIO1
-   mcp; [3] GPIO2 mcp; [4] GPIO3 mcp; [5] GPIO4 mcp; [6] GPIO1 function 1;
-   [7] GPIO2 function 1; [8] GPIO3 function 1; [9] GPIO4 function 1; [10]
-   PCIE glue/PXP VPD event function0; [11] PCIE glue/PXP VPD event
-   function1; [12] PCIE glue/PXP Expansion ROM event0; [13] PCIE glue/PXP
-   Expansion ROM event1; [14] SPIO4; [15] SPIO5; [16] MSI/X indication for
-   mcp; [17] MSI/X indication for function 1; [18] BRB Parity error; [19]
-   BRB Hw interrupt; [20] PRS Parity error; [21] PRS Hw interrupt; [22] SRC
-   Parity error; [23] SRC Hw interrupt; [24] TSDM Parity error; [25] TSDM Hw
-   interrupt; [26] TCM Parity error; [27] TCM Hw interrupt; [28] TSEMI
-   Parity error; [29] TSEMI Hw interrupt; [30] PBF Parity error; [31] PBF Hw
-   interrupt; */
-#define MISC_REG_AEU_SYS_KILL_STATUS_0				 0xa600
-#define MISC_REG_AEU_SYS_KILL_STATUS_1				 0xa604
-#define MISC_REG_AEU_SYS_KILL_STATUS_2				 0xa608
-#define MISC_REG_AEU_SYS_KILL_STATUS_3				 0xa60c
-/* [R 4] This field indicates the type of the device. '0' - 2 Ports; '1' - 1
-   Port. */
-#define MISC_REG_BOND_ID					 0xa400
-/* [R 8] These bits indicate the metal revision of the chip. This value
-   starts at 0x00 for each all-layer tape-out and increments by one for each
-   tape-out. */
-#define MISC_REG_CHIP_METAL					 0xa404
-/* [R 16] These bits indicate the part number for the chip. */
-#define MISC_REG_CHIP_NUM					 0xa408
-/* [R 4] These bits indicate the base revision of the chip. This value
-   starts at 0x0 for the A0 tape-out and increments by one for each
-   all-layer tape-out. */
-#define MISC_REG_CHIP_REV					 0xa40c
-/* [RW 32] The following driver registers(1...16) represent 16 drivers and
-   32 clients. Each client can be controlled by one driver only. One in each
-   bit represent that this driver control the appropriate client (Ex: bit 5
-   is set means this driver control client number 5). addr1 = set; addr0 =
-   clear; read from both addresses will give the same result = status. write
-   to address 1 will set a request to control all the clients that their
-   appropriate bit (in the write command) is set. if the client is free (the
-   appropriate bit in all the other drivers is clear) one will be written to
-   that driver register; if the client isn't free the bit will remain zero.
-   if the appropriate bit is set (the driver request to gain control on a
-   client it already controls the ~MISC_REGISTERS_INT_STS.GENERIC_SW
-   interrupt will be asserted). write to address 0 will set a request to
-   free all the clients that their appropriate bit (in the write command) is
-   set. if the appropriate bit is clear (the driver request to free a client
-   it doesn't controls the ~MISC_REGISTERS_INT_STS.GENERIC_SW interrupt will
-   be asserted). */
-#define MISC_REG_DRIVER_CONTROL_1				 0xa510
-#define MISC_REG_DRIVER_CONTROL_7				 0xa3c8
-/* [RW 1] e1hmf for WOL. If clr WOL signal o the PXP will be send on bit 0
-   only. */
-#define MISC_REG_E1HMF_MODE					 0xa5f8
-/* [RW 32] Debug only: spare RW register reset by core reset */
-#define MISC_REG_GENERIC_CR_0					 0xa460
-/* [RW 32] GPIO. [31-28] FLOAT port 0; [27-24] FLOAT port 0; When any of
-   these bits is written as a '1'; the corresponding SPIO bit will turn off
-   it's drivers and become an input. This is the reset state of all GPIO
-   pins. The read value of these bits will be a '1' if that last command
-   (#SET; #CLR; or #FLOAT) for this bit was a #FLOAT. (reset value 0xff).
-   [23-20] CLR port 1; 19-16] CLR port 0; When any of these bits is written
-   as a '1'; the corresponding GPIO bit will drive low. The read value of
-   these bits will be a '1' if that last command (#SET; #CLR; or #FLOAT) for
-   this bit was a #CLR. (reset value 0). [15-12] SET port 1; 11-8] port 0;
-   SET When any of these bits is written as a '1'; the corresponding GPIO
-   bit will drive high (if it has that capability). The read value of these
-   bits will be a '1' if that last command (#SET; #CLR; or #FLOAT) for this
-   bit was a #SET. (reset value 0). [7-4] VALUE port 1; [3-0] VALUE port 0;
-   RO; These bits indicate the read value of each of the eight GPIO pins.
-   This is the result value of the pin; not the drive value. Writing these
-   bits will have not effect. */
-#define MISC_REG_GPIO						 0xa490
-/* [RW 8] These bits enable the GPIO_INTs to signals event to the
-   IGU/MCP.according to the following map: [0] p0_gpio_0; [1] p0_gpio_1; [2]
-   p0_gpio_2; [3] p0_gpio_3; [4] p1_gpio_0; [5] p1_gpio_1; [6] p1_gpio_2;
-   [7] p1_gpio_3; */
-#define MISC_REG_GPIO_EVENT_EN					 0xa2bc
-/* [RW 32] GPIO INT. [31-28] OLD_CLR port1; [27-24] OLD_CLR port0; Writing a
-   '1' to these bit clears the corresponding bit in the #OLD_VALUE register.
-   This will acknowledge an interrupt on the falling edge of corresponding
-   GPIO input (reset value 0). [23-16] OLD_SET [23-16] port1; OLD_SET port0;
-   Writing a '1' to these bit sets the corresponding bit in the #OLD_VALUE
-   register. This will acknowledge an interrupt on the rising edge of
-   corresponding SPIO input (reset value 0). [15-12] OLD_VALUE [11-8] port1;
-   OLD_VALUE port0; RO; These bits indicate the old value of the GPIO input
-   value. When the ~INT_STATE bit is set; this bit indicates the OLD value
-   of the pin such that if ~INT_STATE is set and this bit is '0'; then the
-   interrupt is due to a low to high edge. If ~INT_STATE is set and this bit
-   is '1'; then the interrupt is due to a high to low edge (reset value 0).
-   [7-4] INT_STATE port1; [3-0] INT_STATE RO port0; These bits indicate the
-   current GPIO interrupt state for each GPIO pin. This bit is cleared when
-   the appropriate #OLD_SET or #OLD_CLR command bit is written. This bit is
-   set when the GPIO input does not match the current value in #OLD_VALUE
-   (reset value 0). */
-#define MISC_REG_GPIO_INT					 0xa494
-/* [R 28] this field hold the last information that caused reserved
-   attention. bits [19:0] - address; [22:20] function; [23] reserved;
-   [27:24] the master that caused the attention - according to the following
-   encodeing:1 = pxp; 2 = mcp; 3 = usdm; 4 = tsdm; 5 = xsdm; 6 = csdm; 7 =
-   dbu; 8 = dmae */
-#define MISC_REG_GRC_RSV_ATTN					 0xa3c0
-/* [R 28] this field hold the last information that caused timeout
-   attention. bits [19:0] - address; [22:20] function; [23] reserved;
-   [27:24] the master that caused the attention - according to the following
-   encodeing:1 = pxp; 2 = mcp; 3 = usdm; 4 = tsdm; 5 = xsdm; 6 = csdm; 7 =
-   dbu; 8 = dmae */
-#define MISC_REG_GRC_TIMEOUT_ATTN				 0xa3c4
-/* [RW 1] Setting this bit enables a timer in the GRC block to timeout any
-   access that does not finish within
-   ~misc_registers_grc_timout_val.grc_timeout_val cycles. When this bit is
-   cleared; this timeout is disabled. If this timeout occurs; the GRC shall
-   assert it attention output. */
-#define MISC_REG_GRC_TIMEOUT_EN 				 0xa280
-/* [RW 28] 28 LSB of LCPLL first register; reset val = 521. inside order of
-   the bits is: [2:0] OAC reset value 001) CML output buffer bias control;
-   111 for +40%; 011 for +20%; 001 for 0%; 000 for -20%. [5:3] Icp_ctrl
-   (reset value 001) Charge pump current control; 111 for 720u; 011 for
-   600u; 001 for 480u and 000 for 360u. [7:6] Bias_ctrl (reset value 00)
-   Global bias control; When bit 7 is high bias current will be 10 0gh; When
-   bit 6 is high bias will be 100w; Valid values are 00; 10; 01. [10:8]
-   Pll_observe (reset value 010) Bits to control observability. bit 10 is
-   for test bias; bit 9 is for test CK; bit 8 is test Vc. [12:11] Vth_ctrl
-   (reset value 00) Comparator threshold control. 00 for 0.6V; 01 for 0.54V
-   and 10 for 0.66V. [13] pllSeqStart (reset value 0) Enables VCO tuning
-   sequencer: 1= sequencer disabled; 0= sequencer enabled (inverted
-   internally). [14] reserved (reset value 0) Reset for VCO sequencer is
-   connected to RESET input directly. [15] capRetry_en (reset value 0)
-   enable retry on cap search failure (inverted). [16] freqMonitor_e (reset
-   value 0) bit to continuously monitor vco freq (inverted). [17]
-   freqDetRestart_en (reset value 0) bit to enable restart when not freq
-   locked (inverted). [18] freqDetRetry_en (reset value 0) bit to enable
-   retry on freq det failure(inverted). [19] pllForceFdone_en (reset value
-   0) bit to enable pllForceFdone & pllForceFpass into pllSeq. [20]
-   pllForceFdone (reset value 0) bit to force freqDone. [21] pllForceFpass
-   (reset value 0) bit to force freqPass. [22] pllForceDone_en (reset value
-   0) bit to enable pllForceCapDone. [23] pllForceCapDone (reset value 0)
-   bit to force capDone. [24] pllForceCapPass_en (reset value 0) bit to
-   enable pllForceCapPass. [25] pllForceCapPass (reset value 0) bit to force
-   capPass. [26] capRestart (reset value 0) bit to force cap sequencer to
-   restart. [27] capSelectM_en (reset value 0) bit to enable cap select
-   register bits. */
-#define MISC_REG_LCPLL_CTRL_1					 0xa2a4
-#define MISC_REG_LCPLL_CTRL_REG_2				 0xa2a8
-/* [RW 4] Interrupt mask register #0 read/write */
-#define MISC_REG_MISC_INT_MASK					 0xa388
-/* [RW 1] Parity mask register #0 read/write */
-#define MISC_REG_MISC_PRTY_MASK 				 0xa398
-/* [R 1] Parity register #0 read */
-#define MISC_REG_MISC_PRTY_STS					 0xa38c
-#define MISC_REG_NIG_WOL_P0					 0xa270
-#define MISC_REG_NIG_WOL_P1					 0xa274
-/* [R 1] If set indicate that the pcie_rst_b was asserted without perst
-   assertion */
-#define MISC_REG_PCIE_HOT_RESET 				 0xa618
-/* [RW 32] 32 LSB of storm PLL first register; reset val = 0x 071d2911.
-   inside order of the bits is: [0] P1 divider[0] (reset value 1); [1] P1
-   divider[1] (reset value 0); [2] P1 divider[2] (reset value 0); [3] P1
-   divider[3] (reset value 0); [4] P2 divider[0] (reset value 1); [5] P2
-   divider[1] (reset value 0); [6] P2 divider[2] (reset value 0); [7] P2
-   divider[3] (reset value 0); [8] ph_det_dis (reset value 1); [9]
-   freq_det_dis (reset value 0); [10] Icpx[0] (reset value 0); [11] Icpx[1]
-   (reset value 1); [12] Icpx[2] (reset value 0); [13] Icpx[3] (reset value
-   1); [14] Icpx[4] (reset value 0); [15] Icpx[5] (reset value 0); [16]
-   Rx[0] (reset value 1); [17] Rx[1] (reset value 0); [18] vc_en (reset
-   value 1); [19] vco_rng[0] (reset value 1); [20] vco_rng[1] (reset value
-   1); [21] Kvco_xf[0] (reset value 0); [22] Kvco_xf[1] (reset value 0);
-   [23] Kvco_xf[2] (reset value 0); [24] Kvco_xs[0] (reset value 1); [25]
-   Kvco_xs[1] (reset value 1); [26] Kvco_xs[2] (reset value 1); [27]
-   testd_en (reset value 0); [28] testd_sel[0] (reset value 0); [29]
-   testd_sel[1] (reset value 0); [30] testd_sel[2] (reset value 0); [31]
-   testa_en (reset value 0); */
-#define MISC_REG_PLL_STORM_CTRL_1				 0xa294
-#define MISC_REG_PLL_STORM_CTRL_2				 0xa298
-#define MISC_REG_PLL_STORM_CTRL_3				 0xa29c
-#define MISC_REG_PLL_STORM_CTRL_4				 0xa2a0
-/* [RW 32] reset reg#2; rite/read one = the specific block is out of reset;
-   write/read zero = the specific block is in reset; addr 0-wr- the write
-   value will be written to the register; addr 1-set - one will be written
-   to all the bits that have the value of one in the data written (bits that
-   have the value of zero will not be change) ; addr 2-clear - zero will be
-   written to all the bits that have the value of one in the data written
-   (bits that have the value of zero will not be change); addr 3-ignore;
-   read ignore from all addr except addr 00; inside order of the bits is:
-   [0] rst_bmac0; [1] rst_bmac1; [2] rst_emac0; [3] rst_emac1; [4] rst_grc;
-   [5] rst_mcp_n_reset_reg_hard_core; [6] rst_ mcp_n_hard_core_rst_b; [7]
-   rst_ mcp_n_reset_cmn_cpu; [8] rst_ mcp_n_reset_cmn_core; [9] rst_rbcn;
-   [10] rst_dbg; [11] rst_misc_core; [12] rst_dbue (UART); [13]
-   Pci_resetmdio_n; [14] rst_emac0_hard_core; [15] rst_emac1_hard_core; 16]
-   rst_pxp_rq_rd_wr; 31:17] reserved */
-#define MISC_REG_RESET_REG_2					 0xa590
-/* [RW 20] 20 bit GRC address where the scratch-pad of the MCP that is
-   shared with the driver resides */
-#define MISC_REG_SHARED_MEM_ADDR				 0xa2b4
-/* [RW 32] SPIO. [31-24] FLOAT When any of these bits is written as a '1';
-   the corresponding SPIO bit will turn off it's drivers and become an
-   input. This is the reset state of all SPIO pins. The read value of these
-   bits will be a '1' if that last command (#SET; #CL; or #FLOAT) for this
-   bit was a #FLOAT. (reset value 0xff). [23-16] CLR When any of these bits
-   is written as a '1'; the corresponding SPIO bit will drive low. The read
-   value of these bits will be a '1' if that last command (#SET; #CLR; or
-#FLOAT) for this bit was a #CLR. (reset value 0). [15-8] SET When any of
-   these bits is written as a '1'; the corresponding SPIO bit will drive
-   high (if it has that capability). The read value of these bits will be a
-   '1' if that last command (#SET; #CLR; or #FLOAT) for this bit was a #SET.
-   (reset value 0). [7-0] VALUE RO; These bits indicate the read value of
-   each of the eight SPIO pins. This is the result value of the pin; not the
-   drive value. Writing these bits will have not effect. Each 8 bits field
-   is divided as follows: [0] VAUX Enable; when pulsed low; enables supply
-   from VAUX. (This is an output pin only; the FLOAT field is not applicable
-   for this pin); [1] VAUX Disable; when pulsed low; disables supply form
-   VAUX. (This is an output pin only; FLOAT field is not applicable for this
-   pin); [2] SEL_VAUX_B - Control to power switching logic. Drive low to
-   select VAUX supply. (This is an output pin only; it is not controlled by
-   the SET and CLR fields; it is controlled by the Main Power SM; the FLOAT
-   field is not applicable for this pin; only the VALUE fields is relevant -
-   it reflects the output value); [3] port swap [4] spio_4; [5] spio_5; [6]
-   Bit 0 of UMP device ID select; read by UMP firmware; [7] Bit 1 of UMP
-   device ID select; read by UMP firmware. */
-#define MISC_REG_SPIO						 0xa4fc
-/* [RW 8] These bits enable the SPIO_INTs to signals event to the IGU/MC.
-   according to the following map: [3:0] reserved; [4] spio_4 [5] spio_5;
-   [7:0] reserved */
-#define MISC_REG_SPIO_EVENT_EN					 0xa2b8
-/* [RW 32] SPIO INT. [31-24] OLD_CLR Writing a '1' to these bit clears the
-   corresponding bit in the #OLD_VALUE register. This will acknowledge an
-   interrupt on the falling edge of corresponding SPIO input (reset value
-   0). [23-16] OLD_SET Writing a '1' to these bit sets the corresponding bit
-   in the #OLD_VALUE register. This will acknowledge an interrupt on the
-   rising edge of corresponding SPIO input (reset value 0). [15-8] OLD_VALUE
-   RO; These bits indicate the old value of the SPIO input value. When the
-   ~INT_STATE bit is set; this bit indicates the OLD value of the pin such
-   that if ~INT_STATE is set and this bit is '0'; then the interrupt is due
-   to a low to high edge. If ~INT_STATE is set and this bit is '1'; then the
-   interrupt is due to a high to low edge (reset value 0). [7-0] INT_STATE
-   RO; These bits indicate the current SPIO interrupt state for each SPIO
-   pin. This bit is cleared when the appropriate #OLD_SET or #OLD_CLR
-   command bit is written. This bit is set when the SPIO input does not
-   match the current value in #OLD_VALUE (reset value 0). */
-#define MISC_REG_SPIO_INT					 0xa500
-/* [RW 32] reload value for counter 4 if reload; the value will be reload if
-   the counter reached zero and the reload bit
-   (~misc_registers_sw_timer_cfg_4.sw_timer_cfg_4[1] ) is set */
-#define MISC_REG_SW_TIMER_RELOAD_VAL_4				 0xa2fc
-/* [RW 32] the value of the counter for sw timers1-8. there are 8 addresses
-   in this register. addres 0 - timer 1; address - timer 2�address 7 -
-   timer 8 */
-#define MISC_REG_SW_TIMER_VAL					 0xa5c0
-/* [RW 1] Set by the MCP to remember if one or more of the drivers is/are
-   loaded; 0-prepare; -unprepare */
-#define MISC_REG_UNPREPARED					 0xa424
-#define NIG_LLH0_BRB1_DRV_MASK_REG_LLH0_BRB1_DRV_MASK_BRCST	 (0x1<<0)
-#define NIG_LLH0_BRB1_DRV_MASK_REG_LLH0_BRB1_DRV_MASK_MLCST	 (0x1<<1)
-#define NIG_LLH0_BRB1_DRV_MASK_REG_LLH0_BRB1_DRV_MASK_NO_VLAN	 (0x1<<4)
-#define NIG_LLH0_BRB1_DRV_MASK_REG_LLH0_BRB1_DRV_MASK_UNCST	 (0x1<<2)
-#define NIG_LLH0_BRB1_DRV_MASK_REG_LLH0_BRB1_DRV_MASK_VLAN	 (0x1<<3)
-#define NIG_MASK_INTERRUPT_PORT0_REG_MASK_EMAC0_MISC_MI_INT	 (0x1<<0)
-#define NIG_MASK_INTERRUPT_PORT0_REG_MASK_SERDES0_LINK_STATUS	 (0x1<<9)
-#define NIG_MASK_INTERRUPT_PORT0_REG_MASK_XGXS0_LINK10G 	 (0x1<<15)
-#define NIG_MASK_INTERRUPT_PORT0_REG_MASK_XGXS0_LINK_STATUS	 (0xf<<18)
-/* [RW 1] Input enable for RX_BMAC0 IF */
-#define NIG_REG_BMAC0_IN_EN					 0x100ac
-/* [RW 1] output enable for TX_BMAC0 IF */
-#define NIG_REG_BMAC0_OUT_EN					 0x100e0
-/* [RW 1] output enable for TX BMAC pause port 0 IF */
-#define NIG_REG_BMAC0_PAUSE_OUT_EN				 0x10110
-/* [RW 1] output enable for RX_BMAC0_REGS IF */
-#define NIG_REG_BMAC0_REGS_OUT_EN				 0x100e8
-/* [RW 1] output enable for RX BRB1 port0 IF */
-#define NIG_REG_BRB0_OUT_EN					 0x100f8
-/* [RW 1] Input enable for TX BRB1 pause port 0 IF */
-#define NIG_REG_BRB0_PAUSE_IN_EN				 0x100c4
-/* [RW 1] output enable for RX BRB1 port1 IF */
-#define NIG_REG_BRB1_OUT_EN					 0x100fc
-/* [RW 1] Input enable for TX BRB1 pause port 1 IF */
-#define NIG_REG_BRB1_PAUSE_IN_EN				 0x100c8
-/* [RW 1] output enable for RX BRB1 LP IF */
-#define NIG_REG_BRB_LB_OUT_EN					 0x10100
-/* [WB_W 82] Debug packet to LP from RBC; Data spelling:[63:0] data; 64]
-   error; [67:65]eop_bvalid; [68]eop; [69]sop; [70]port_id; 71]flush;
-   72:73]-vnic_num; 81:74]-sideband_info */
-#define NIG_REG_DEBUG_PACKET_LB 				 0x10800
-/* [RW 1] Input enable for TX Debug packet */
-#define NIG_REG_EGRESS_DEBUG_IN_EN				 0x100dc
-/* [RW 1] If 1 - egress drain mode for port0 is active. In this mode all
-   packets from PBFare not forwarded to the MAC and just deleted from FIFO.
-   First packet may be deleted from the middle. And last packet will be
-   always deleted till the end. */
-#define NIG_REG_EGRESS_DRAIN0_MODE				 0x10060
-/* [RW 1] Output enable to EMAC0 */
-#define NIG_REG_EGRESS_EMAC0_OUT_EN				 0x10120
-/* [RW 1] MAC configuration for packets of port0. If 1 - all packet outputs
-   to emac for port0; other way to bmac for port0 */
-#define NIG_REG_EGRESS_EMAC0_PORT				 0x10058
-/* [RW 1] Input enable for TX PBF user packet port0 IF */
-#define NIG_REG_EGRESS_PBF0_IN_EN				 0x100cc
-/* [RW 1] Input enable for TX PBF user packet port1 IF */
-#define NIG_REG_EGRESS_PBF1_IN_EN				 0x100d0
-/* [RW 1] Input enable for TX UMP management packet port0 IF */
-#define NIG_REG_EGRESS_UMP0_IN_EN				 0x100d4
-/* [RW 1] Input enable for RX_EMAC0 IF */
-#define NIG_REG_EMAC0_IN_EN					 0x100a4
-/* [RW 1] output enable for TX EMAC pause port 0 IF */
-#define NIG_REG_EMAC0_PAUSE_OUT_EN				 0x10118
-/* [R 1] status from emac0. This bit is set when MDINT from either the
-   EXT_MDINT pin or from the Copper PHY is driven low. This condition must
-   be cleared in the attached PHY device that is driving the MINT pin. */
-#define NIG_REG_EMAC0_STATUS_MISC_MI_INT			 0x10494
-/* [WB 48] This address space contains BMAC0 registers. The BMAC registers
-   are described in appendix A. In order to access the BMAC0 registers; the
-   base address; NIG_REGISTERS_INGRESS_BMAC0_MEM; Offset: 0x10c00; should be
-   added to each BMAC register offset */
-#define NIG_REG_INGRESS_BMAC0_MEM				 0x10c00
-/* [WB 48] This address space contains BMAC1 registers. The BMAC registers
-   are described in appendix A. In order to access the BMAC0 registers; the
-   base address; NIG_REGISTERS_INGRESS_BMAC1_MEM; Offset: 0x11000; should be
-   added to each BMAC register offset */
-#define NIG_REG_INGRESS_BMAC1_MEM				 0x11000
-/* [R 1] FIFO empty in EOP descriptor FIFO of LP in NIG_RX_EOP */
-#define NIG_REG_INGRESS_EOP_LB_EMPTY				 0x104e0
-/* [RW 17] Debug only. RX_EOP_DSCR_lb_FIFO in NIG_RX_EOP. Data
-   packet_length[13:0]; mac_error[14]; trunc_error[15]; parity[16] */
-#define NIG_REG_INGRESS_EOP_LB_FIFO				 0x104e4
-/* [RW 27] 0 - must be active for Everest A0; 1- for Everest B0 when latch
-   logic for interrupts must be used. Enable per bit of interrupt of
-   ~latch_status.latch_status */
-#define NIG_REG_LATCH_BC_0					 0x16210
-/* [RW 27] Latch for each interrupt from Unicore.b[0]
-   status_emac0_misc_mi_int; b[1] status_emac0_misc_mi_complete;
-   b[2]status_emac0_misc_cfg_change; b[3]status_emac0_misc_link_status;
-   b[4]status_emac0_misc_link_change; b[5]status_emac0_misc_attn;
-   b[6]status_serdes0_mac_crs; b[7]status_serdes0_autoneg_complete;
-   b[8]status_serdes0_fiber_rxact; b[9]status_serdes0_link_status;
-   b[10]status_serdes0_mr_page_rx; b[11]status_serdes0_cl73_an_complete;
-   b[12]status_serdes0_cl73_mr_page_rx; b[13]status_serdes0_rx_sigdet;
-   b[14]status_xgxs0_remotemdioreq; b[15]status_xgxs0_link10g;
-   b[16]status_xgxs0_autoneg_complete; b[17]status_xgxs0_fiber_rxact;
-   b[21:18]status_xgxs0_link_status; b[22]status_xgxs0_mr_page_rx;
-   b[23]status_xgxs0_cl73_an_complete; b[24]status_xgxs0_cl73_mr_page_rx;
-   b[25]status_xgxs0_rx_sigdet; b[26]status_xgxs0_mac_crs */
-#define NIG_REG_LATCH_STATUS_0					 0x18000
-/* [RW 1] led 10g for port 0 */
-#define NIG_REG_LED_10G_P0					 0x10320
-/* [RW 1] led 10g for port 1 */
-#define NIG_REG_LED_10G_P1					 0x10324
-/* [RW 1] Port0: This bit is set to enable the use of the
-   ~nig_registers_led_control_blink_rate_p0.led_control_blink_rate_p0 field
-   defined below. If this bit is cleared; then the blink rate will be about
-   8Hz. */
-#define NIG_REG_LED_CONTROL_BLINK_RATE_ENA_P0			 0x10318
-/* [RW 12] Port0: Specifies the period of each blink cycle (on + off) for
-   Traffic LED in milliseconds. Must be a non-zero value. This 12-bit field
-   is reset to 0x080; giving a default blink period of approximately 8Hz. */
-#define NIG_REG_LED_CONTROL_BLINK_RATE_P0			 0x10310
-/* [RW 1] Port0: If set along with the
- ~nig_registers_led_control_override_traffic_p0.led_control_override_traffic_p0
-   bit and ~nig_registers_led_control_traffic_p0.led_control_traffic_p0 LED
-   bit; the Traffic LED will blink with the blink rate specified in
-   ~nig_registers_led_control_blink_rate_p0.led_control_blink_rate_p0 and
-   ~nig_registers_led_control_blink_rate_ena_p0.led_control_blink_rate_ena_p0
-   fields. */
-#define NIG_REG_LED_CONTROL_BLINK_TRAFFIC_P0			 0x10308
-/* [RW 1] Port0: If set overrides hardware control of the Traffic LED. The
-   Traffic LED will then be controlled via bit ~nig_registers_
-   led_control_traffic_p0.led_control_traffic_p0 and bit
-   ~nig_registers_led_control_blink_traffic_p0.led_control_blink_traffic_p0 */
-#define NIG_REG_LED_CONTROL_OVERRIDE_TRAFFIC_P0 		 0x102f8
-/* [RW 1] Port0: If set along with the led_control_override_trafic_p0 bit;
-   turns on the Traffic LED. If the led_control_blink_traffic_p0 bit is also
-   set; the LED will blink with blink rate specified in
-   ~nig_registers_led_control_blink_rate_p0.led_control_blink_rate_p0 and
-   ~nig_regsters_led_control_blink_rate_ena_p0.led_control_blink_rate_ena_p0
-   fields. */
-#define NIG_REG_LED_CONTROL_TRAFFIC_P0				 0x10300
-/* [RW 4] led mode for port0: 0 MAC; 1-3 PHY1; 4 MAC2; 5-7 PHY4; 8-MAC3;
-   9-11PHY7; 12 MAC4; 13-15 PHY10; */
-#define NIG_REG_LED_MODE_P0					 0x102f0
-/* [RW 3] for port0 enable for llfc ppp and pause. b0 - brb1 enable; b1-
-   tsdm enable; b2- usdm enable */
-#define NIG_REG_LLFC_EGRESS_SRC_ENABLE_0			 0x16070
-#define NIG_REG_LLFC_EGRESS_SRC_ENABLE_1			 0x16074
-/* [RW 1] SAFC enable for port0. This register may get 1 only when
-   ~ppp_enable.ppp_enable = 0 and pause_enable.pause_enable =0 for the same
-   port */
-#define NIG_REG_LLFC_ENABLE_0					 0x16208
-/* [RW 16] classes are high-priority for port0 */
-#define NIG_REG_LLFC_HIGH_PRIORITY_CLASSES_0			 0x16058
-/* [RW 16] classes are low-priority for port0 */
-#define NIG_REG_LLFC_LOW_PRIORITY_CLASSES_0			 0x16060
-/* [RW 1] Output enable of message to LLFC BMAC IF for port0 */
-#define NIG_REG_LLFC_OUT_EN_0					 0x160c8
-#define NIG_REG_LLH0_ACPI_PAT_0_CRC				 0x1015c
-#define NIG_REG_LLH0_ACPI_PAT_6_LEN				 0x10154
-#define NIG_REG_LLH0_BRB1_DRV_MASK				 0x10244
-#define NIG_REG_LLH0_BRB1_DRV_MASK_MF				 0x16048
-/* [RW 1] send to BRB1 if no match on any of RMP rules. */
-#define NIG_REG_LLH0_BRB1_NOT_MCP				 0x1025c
-/* [RW 2] Determine the classification participants. 0: no classification.1:
-   classification upon VLAN id. 2: classification upon MAC address. 3:
-   classification upon both VLAN id & MAC addr. */
-#define NIG_REG_LLH0_CLS_TYPE					 0x16080
-/* [RW 32] cm header for llh0 */
-#define NIG_REG_LLH0_CM_HEADER					 0x1007c
-#define NIG_REG_LLH0_DEST_IP_0_1				 0x101dc
-#define NIG_REG_LLH0_DEST_MAC_0_0				 0x101c0
-/* [RW 16] destination TCP address 1. The LLH will look for this address in
-   all incoming packets. */
-#define NIG_REG_LLH0_DEST_TCP_0 				 0x10220
-/* [RW 16] destination UDP address 1 The LLH will look for this address in
-   all incoming packets. */
-#define NIG_REG_LLH0_DEST_UDP_0 				 0x10214
-#define NIG_REG_LLH0_ERROR_MASK 				 0x1008c
-/* [RW 8] event id for llh0 */
-#define NIG_REG_LLH0_EVENT_ID					 0x10084
-#define NIG_REG_LLH0_FUNC_EN					 0x160fc
-#define NIG_REG_LLH0_FUNC_VLAN_ID				 0x16100
-/* [RW 1] Determine the IP version to look for in
-   ~nig_registers_llh0_dest_ip_0.llh0_dest_ip_0. 0 - IPv6; 1-IPv4 */
-#define NIG_REG_LLH0_IPV4_IPV6_0				 0x10208
-/* [RW 1] t bit for llh0 */
-#define NIG_REG_LLH0_T_BIT					 0x10074
-/* [RW 12] VLAN ID 1. In case of VLAN packet the LLH will look for this ID. */
-#define NIG_REG_LLH0_VLAN_ID_0					 0x1022c
-/* [RW 8] init credit counter for port0 in LLH */
-#define NIG_REG_LLH0_XCM_INIT_CREDIT				 0x10554
-#define NIG_REG_LLH0_XCM_MASK					 0x10130
-#define NIG_REG_LLH1_BRB1_DRV_MASK				 0x10248
-/* [RW 1] send to BRB1 if no match on any of RMP rules. */
-#define NIG_REG_LLH1_BRB1_NOT_MCP				 0x102dc
-/* [RW 2] Determine the classification participants. 0: no classification.1:
-   classification upon VLAN id. 2: classification upon MAC address. 3:
-   classification upon both VLAN id & MAC addr. */
-#define NIG_REG_LLH1_CLS_TYPE					 0x16084
-/* [RW 32] cm header for llh1 */
-#define NIG_REG_LLH1_CM_HEADER					 0x10080
-#define NIG_REG_LLH1_ERROR_MASK 				 0x10090
-/* [RW 8] event id for llh1 */
-#define NIG_REG_LLH1_EVENT_ID					 0x10088
-/* [RW 8] init credit counter for port1 in LLH */
-#define NIG_REG_LLH1_XCM_INIT_CREDIT				 0x10564
-#define NIG_REG_LLH1_XCM_MASK					 0x10134
-/* [RW 1] When this bit is set; the LLH will expect all packets to be with
-   e1hov */
-#define NIG_REG_LLH_E1HOV_MODE					 0x160d8
-/* [RW 1] When this bit is set; the LLH will classify the packet before
-   sending it to the BRB or calculating WoL on it. */
-#define NIG_REG_LLH_MF_MODE					 0x16024
-#define NIG_REG_MASK_INTERRUPT_PORT0				 0x10330
-#define NIG_REG_MASK_INTERRUPT_PORT1				 0x10334
-/* [RW 1] Output signal from NIG to EMAC0. When set enables the EMAC0 block. */
-#define NIG_REG_NIG_EMAC0_EN					 0x1003c
-/* [RW 1] Output signal from NIG to EMAC1. When set enables the EMAC1 block. */
-#define NIG_REG_NIG_EMAC1_EN					 0x10040
-/* [RW 1] Output signal from NIG to TX_EMAC0. When set indicates to the
-   EMAC0 to strip the CRC from the ingress packets. */
-#define NIG_REG_NIG_INGRESS_EMAC0_NO_CRC			 0x10044
-/* [R 32] Interrupt register #0 read */
-#define NIG_REG_NIG_INT_STS_0					 0x103b0
-#define NIG_REG_NIG_INT_STS_1					 0x103c0
-/* [R 32] Parity register #0 read */
-#define NIG_REG_NIG_PRTY_STS					 0x103d0
-/* [RW 1] Pause enable for port0. This register may get 1 only when
-   ~safc_enable.safc_enable = 0 and ppp_enable.ppp_enable =0 for the same
-   port */
-#define NIG_REG_PAUSE_ENABLE_0					 0x160c0
-/* [RW 1] Input enable for RX PBF LP IF */
-#define NIG_REG_PBF_LB_IN_EN					 0x100b4
-/* [RW 1] Value of this register will be transmitted to port swap when
-   ~nig_registers_strap_override.strap_override =1 */
-#define NIG_REG_PORT_SWAP					 0x10394
-/* [RW 1] output enable for RX parser descriptor IF */
-#define NIG_REG_PRS_EOP_OUT_EN					 0x10104
-/* [RW 1] Input enable for RX parser request IF */
-#define NIG_REG_PRS_REQ_IN_EN					 0x100b8
-/* [RW 5] control to serdes - CL45 DEVAD */
-#define NIG_REG_SERDES0_CTRL_MD_DEVAD				 0x10370
-/* [RW 1] control to serdes; 0 - clause 45; 1 - clause 22 */
-#define NIG_REG_SERDES0_CTRL_MD_ST				 0x1036c
-/* [RW 5] control to serdes - CL22 PHY_ADD and CL45 PRTAD */
-#define NIG_REG_SERDES0_CTRL_PHY_ADDR				 0x10374
-/* [R 1] status from serdes0 that inputs to interrupt logic of link status */
-#define NIG_REG_SERDES0_STATUS_LINK_STATUS			 0x10578
-/* [R 32] Rx statistics : In user packets discarded due to BRB backpressure
-   for port0 */
-#define NIG_REG_STAT0_BRB_DISCARD				 0x105f0
-/* [R 32] Rx statistics : In user packets truncated due to BRB backpressure
-   for port0 */
-#define NIG_REG_STAT0_BRB_TRUNCATE				 0x105f8
-/* [WB_R 36] Tx statistics : Number of packets from emac0 or bmac0 that
-   between 1024 and 1522 bytes for port0 */
-#define NIG_REG_STAT0_EGRESS_MAC_PKT0				 0x10750
-/* [WB_R 36] Tx statistics : Number of packets from emac0 or bmac0 that
-   between 1523 bytes and above for port0 */
-#define NIG_REG_STAT0_EGRESS_MAC_PKT1				 0x10760
-/* [R 32] Rx statistics : In user packets discarded due to BRB backpressure
-   for port1 */
-#define NIG_REG_STAT1_BRB_DISCARD				 0x10628
-/* [WB_R 36] Tx statistics : Number of packets from emac1 or bmac1 that
-   between 1024 and 1522 bytes for port1 */
-#define NIG_REG_STAT1_EGRESS_MAC_PKT0				 0x107a0
-/* [WB_R 36] Tx statistics : Number of packets from emac1 or bmac1 that
-   between 1523 bytes and above for port1 */
-#define NIG_REG_STAT1_EGRESS_MAC_PKT1				 0x107b0
-/* [WB_R 64] Rx statistics : User octets received for LP */
-#define NIG_REG_STAT2_BRB_OCTET 				 0x107e0
-#define NIG_REG_STATUS_INTERRUPT_PORT0				 0x10328
-#define NIG_REG_STATUS_INTERRUPT_PORT1				 0x1032c
-/* [RW 1] port swap mux selection. If this register equal to 0 then port
-   swap is equal to SPIO pin that inputs from ifmux_serdes_swap. If 1 then
-   ort swap is equal to ~nig_registers_port_swap.port_swap */
-#define NIG_REG_STRAP_OVERRIDE					 0x10398
-/* [RW 1] output enable for RX_XCM0 IF */
-#define NIG_REG_XCM0_OUT_EN					 0x100f0
-/* [RW 1] output enable for RX_XCM1 IF */
-#define NIG_REG_XCM1_OUT_EN					 0x100f4
-/* [RW 1] control to xgxs - remote PHY in-band MDIO */
-#define NIG_REG_XGXS0_CTRL_EXTREMOTEMDIOST			 0x10348
-/* [RW 5] control to xgxs - CL45 DEVAD */
-#define NIG_REG_XGXS0_CTRL_MD_DEVAD				 0x1033c
-/* [RW 1] control to xgxs; 0 - clause 45; 1 - clause 22 */
-#define NIG_REG_XGXS0_CTRL_MD_ST				 0x10338
-/* [RW 5] control to xgxs - CL22 PHY_ADD and CL45 PRTAD */
-#define NIG_REG_XGXS0_CTRL_PHY_ADDR				 0x10340
-/* [R 1] status from xgxs0 that inputs to interrupt logic of link10g. */
-#define NIG_REG_XGXS0_STATUS_LINK10G				 0x10680
-/* [R 4] status from xgxs0 that inputs to interrupt logic of link status */
-#define NIG_REG_XGXS0_STATUS_LINK_STATUS			 0x10684
-/* [RW 2] selection for XGXS lane of port 0 in NIG_MUX block */
-#define NIG_REG_XGXS_LANE_SEL_P0				 0x102e8
-/* [RW 1] selection for port0 for NIG_MUX block : 0 = SerDes; 1 = XGXS */
-#define NIG_REG_XGXS_SERDES0_MODE_SEL				 0x102e0
-#define NIG_STATUS_INTERRUPT_PORT0_REG_STATUS_EMAC0_MISC_MI_INT  (0x1<<0)
-#define NIG_STATUS_INTERRUPT_PORT0_REG_STATUS_SERDES0_LINK_STATUS (0x1<<9)
-#define NIG_STATUS_INTERRUPT_PORT0_REG_STATUS_XGXS0_LINK10G	 (0x1<<15)
-#define NIG_STATUS_INTERRUPT_PORT0_REG_STATUS_XGXS0_LINK_STATUS  (0xf<<18)
-#define NIG_STATUS_INTERRUPT_PORT0_REG_STATUS_XGXS0_LINK_STATUS_SIZE 18
-/* [RW 1] Disable processing further tasks from port 0 (after ending the
-   current task in process). */
-#define PBF_REG_DISABLE_NEW_TASK_PROC_P0			 0x14005c
-/* [RW 1] Disable processing further tasks from port 1 (after ending the
-   current task in process). */
-#define PBF_REG_DISABLE_NEW_TASK_PROC_P1			 0x140060
-/* [RW 1] Disable processing further tasks from port 4 (after ending the
-   current task in process). */
-#define PBF_REG_DISABLE_NEW_TASK_PROC_P4			 0x14006c
-#define PBF_REG_IF_ENABLE_REG					 0x140044
-/* [RW 1] Init bit. When set the initial credits are copied to the credit
-   registers (except the port credits). Should be set and then reset after
-   the configuration of the block has ended. */
-#define PBF_REG_INIT						 0x140000
-/* [RW 1] Init bit for port 0. When set the initial credit of port 0 is
-   copied to the credit register. Should be set and then reset after the
-   configuration of the port has ended. */
-#define PBF_REG_INIT_P0 					 0x140004
-/* [RW 1] Init bit for port 1. When set the initial credit of port 1 is
-   copied to the credit register. Should be set and then reset after the
-   configuration of the port has ended. */
-#define PBF_REG_INIT_P1 					 0x140008
-/* [RW 1] Init bit for port 4. When set the initial credit of port 4 is
-   copied to the credit register. Should be set and then reset after the
-   configuration of the port has ended. */
-#define PBF_REG_INIT_P4 					 0x14000c
-/* [RW 1] Enable for mac interface 0. */
-#define PBF_REG_MAC_IF0_ENABLE					 0x140030
-/* [RW 1] Enable for mac interface 1. */
-#define PBF_REG_MAC_IF1_ENABLE					 0x140034
-/* [RW 1] Enable for the loopback interface. */
-#define PBF_REG_MAC_LB_ENABLE					 0x140040
-/* [RW 10] Port 0 threshold used by arbiter in 16 byte lines used when pause
-   not suppoterd. */
-#define PBF_REG_P0_ARB_THRSH					 0x1400e4
-/* [R 11] Current credit for port 0 in the tx port buffers in 16 byte lines. */
-#define PBF_REG_P0_CREDIT					 0x140200
-/* [RW 11] Initial credit for port 0 in the tx port buffers in 16 byte
-   lines. */
-#define PBF_REG_P0_INIT_CRD					 0x1400d0
-/* [RW 1] Indication that pause is enabled for port 0. */
-#define PBF_REG_P0_PAUSE_ENABLE 				 0x140014
-/* [R 8] Number of tasks in port 0 task queue. */
-#define PBF_REG_P0_TASK_CNT					 0x140204
-/* [R 11] Current credit for port 1 in the tx port buffers in 16 byte lines. */
-#define PBF_REG_P1_CREDIT					 0x140208
-/* [RW 11] Initial credit for port 1 in the tx port buffers in 16 byte
-   lines. */
-#define PBF_REG_P1_INIT_CRD					 0x1400d4
-/* [R 8] Number of tasks in port 1 task queue. */
-#define PBF_REG_P1_TASK_CNT					 0x14020c
-/* [R 11] Current credit for port 4 in the tx port buffers in 16 byte lines. */
-#define PBF_REG_P4_CREDIT					 0x140210
-/* [RW 11] Initial credit for port 4 in the tx port buffers in 16 byte
-   lines. */
-#define PBF_REG_P4_INIT_CRD					 0x1400e0
-/* [R 8] Number of tasks in port 4 task queue. */
-#define PBF_REG_P4_TASK_CNT					 0x140214
-/* [RW 5] Interrupt mask register #0 read/write */
-#define PBF_REG_PBF_INT_MASK					 0x1401d4
-/* [R 5] Interrupt register #0 read */
-#define PBF_REG_PBF_INT_STS					 0x1401c8
-#define PB_REG_CONTROL						 0
-/* [RW 2] Interrupt mask register #0 read/write */
-#define PB_REG_PB_INT_MASK					 0x28
-/* [R 2] Interrupt register #0 read */
-#define PB_REG_PB_INT_STS					 0x1c
-/* [RW 4] Parity mask register #0 read/write */
-#define PB_REG_PB_PRTY_MASK					 0x38
-/* [R 4] Parity register #0 read */
-#define PB_REG_PB_PRTY_STS					 0x2c
-#define PRS_REG_A_PRSU_20					 0x40134
-/* [R 8] debug only: CFC load request current credit. Transaction based. */
-#define PRS_REG_CFC_LD_CURRENT_CREDIT				 0x40164
-/* [R 8] debug only: CFC search request current credit. Transaction based. */
-#define PRS_REG_CFC_SEARCH_CURRENT_CREDIT			 0x40168
-/* [RW 6] The initial credit for the search message to the CFC interface.
-   Credit is transaction based. */
-#define PRS_REG_CFC_SEARCH_INITIAL_CREDIT			 0x4011c
-/* [RW 24] CID for port 0 if no match */
-#define PRS_REG_CID_PORT_0					 0x400fc
-/* [RW 32] The CM header for flush message where 'load existed' bit in CFC
-   load response is reset and packet type is 0. Used in packet start message
-   to TCM. */
-#define PRS_REG_CM_HDR_FLUSH_LOAD_TYPE_0			 0x400dc
-#define PRS_REG_CM_HDR_FLUSH_LOAD_TYPE_1			 0x400e0
-#define PRS_REG_CM_HDR_FLUSH_LOAD_TYPE_2			 0x400e4
-#define PRS_REG_CM_HDR_FLUSH_LOAD_TYPE_3			 0x400e8
-#define PRS_REG_CM_HDR_FLUSH_LOAD_TYPE_4			 0x400ec
-#define PRS_REG_CM_HDR_FLUSH_LOAD_TYPE_5			 0x400f0
-/* [RW 32] The CM header for flush message where 'load existed' bit in CFC
-   load response is set and packet type is 0. Used in packet start message
-   to TCM. */
-#define PRS_REG_CM_HDR_FLUSH_NO_LOAD_TYPE_0			 0x400bc
-#define PRS_REG_CM_HDR_FLUSH_NO_LOAD_TYPE_1			 0x400c0
-#define PRS_REG_CM_HDR_FLUSH_NO_LOAD_TYPE_2			 0x400c4
-#define PRS_REG_CM_HDR_FLUSH_NO_LOAD_TYPE_3			 0x400c8
-#define PRS_REG_CM_HDR_FLUSH_NO_LOAD_TYPE_4			 0x400cc
-#define PRS_REG_CM_HDR_FLUSH_NO_LOAD_TYPE_5			 0x400d0
-/* [RW 32] The CM header for a match and packet type 1 for loopback port.
-   Used in packet start message to TCM. */
-#define PRS_REG_CM_HDR_LOOPBACK_TYPE_1				 0x4009c
-#define PRS_REG_CM_HDR_LOOPBACK_TYPE_2				 0x400a0
-#define PRS_REG_CM_HDR_LOOPBACK_TYPE_3				 0x400a4
-#define PRS_REG_CM_HDR_LOOPBACK_TYPE_4				 0x400a8
-/* [RW 32] The CM header for a match and packet type 0. Used in packet start
-   message to TCM. */
-#define PRS_REG_CM_HDR_TYPE_0					 0x40078
-#define PRS_REG_CM_HDR_TYPE_1					 0x4007c
-#define PRS_REG_CM_HDR_TYPE_2					 0x40080
-#define PRS_REG_CM_HDR_TYPE_3					 0x40084
-#define PRS_REG_CM_HDR_TYPE_4					 0x40088
-/* [RW 32] The CM header in case there was not a match on the connection */
-#define PRS_REG_CM_NO_MATCH_HDR 				 0x400b8
-/* [RW 1] Indicates if in e1hov mode. 0=non-e1hov mode; 1=e1hov mode. */
-#define PRS_REG_E1HOV_MODE					 0x401c8
-/* [RW 8] The 8-bit event ID for a match and packet type 1. Used in packet
-   start message to TCM. */
-#define PRS_REG_EVENT_ID_1					 0x40054
-#define PRS_REG_EVENT_ID_2					 0x40058
-#define PRS_REG_EVENT_ID_3					 0x4005c
-/* [RW 16] The Ethernet type value for FCoE */
-#define PRS_REG_FCOE_TYPE					 0x401d0
-/* [RW 8] Context region for flush packet with packet type 0. Used in CFC
-   load request message. */
-#define PRS_REG_FLUSH_REGIONS_TYPE_0				 0x40004
-#define PRS_REG_FLUSH_REGIONS_TYPE_1				 0x40008
-#define PRS_REG_FLUSH_REGIONS_TYPE_2				 0x4000c
-#define PRS_REG_FLUSH_REGIONS_TYPE_3				 0x40010
-#define PRS_REG_FLUSH_REGIONS_TYPE_4				 0x40014
-#define PRS_REG_FLUSH_REGIONS_TYPE_5				 0x40018
-#define PRS_REG_FLUSH_REGIONS_TYPE_6				 0x4001c
-#define PRS_REG_FLUSH_REGIONS_TYPE_7				 0x40020
-/* [RW 4] The increment value to send in the CFC load request message */
-#define PRS_REG_INC_VALUE					 0x40048
-/* [RW 1] If set indicates not to send messages to CFC on received packets */
-#define PRS_REG_NIC_MODE					 0x40138
-/* [RW 8] The 8-bit event ID for cases where there is no match on the
-   connection. Used in packet start message to TCM. */
-#define PRS_REG_NO_MATCH_EVENT_ID				 0x40070
-/* [ST 24] The number of input CFC flush packets */
-#define PRS_REG_NUM_OF_CFC_FLUSH_MESSAGES			 0x40128
-/* [ST 32] The number of cycles the Parser halted its operation since it
-   could not allocate the next serial number */
-#define PRS_REG_NUM_OF_DEAD_CYCLES				 0x40130
-/* [ST 24] The number of input packets */
-#define PRS_REG_NUM_OF_PACKETS					 0x40124
-/* [ST 24] The number of input transparent flush packets */
-#define PRS_REG_NUM_OF_TRANSPARENT_FLUSH_MESSAGES		 0x4012c
-/* [RW 8] Context region for received Ethernet packet with a match and
-   packet type 0. Used in CFC load request message */
-#define PRS_REG_PACKET_REGIONS_TYPE_0				 0x40028
-#define PRS_REG_PACKET_REGIONS_TYPE_1				 0x4002c
-#define PRS_REG_PACKET_REGIONS_TYPE_2				 0x40030
-#define PRS_REG_PACKET_REGIONS_TYPE_3				 0x40034
-#define PRS_REG_PACKET_REGIONS_TYPE_4				 0x40038
-#define PRS_REG_PACKET_REGIONS_TYPE_5				 0x4003c
-#define PRS_REG_PACKET_REGIONS_TYPE_6				 0x40040
-#define PRS_REG_PACKET_REGIONS_TYPE_7				 0x40044
-/* [R 2] debug only: Number of pending requests for CAC on port 0. */
-#define PRS_REG_PENDING_BRB_CAC0_RQ				 0x40174
-/* [R 2] debug only: Number of pending requests for header parsing. */
-#define PRS_REG_PENDING_BRB_PRS_RQ				 0x40170
-/* [R 1] Interrupt register #0 read */
-#define PRS_REG_PRS_INT_STS					 0x40188
-/* [RW 8] Parity mask register #0 read/write */
-#define PRS_REG_PRS_PRTY_MASK					 0x401a4
-/* [R 8] Parity register #0 read */
-#define PRS_REG_PRS_PRTY_STS					 0x40198
-/* [RW 8] Context region for pure acknowledge packets. Used in CFC load
-   request message */
-#define PRS_REG_PURE_REGIONS					 0x40024
-/* [R 32] debug only: Serial number status lsb 32 bits. '1' indicates this
-   serail number was released by SDM but cannot be used because a previous
-   serial number was not released. */
-#define PRS_REG_SERIAL_NUM_STATUS_LSB				 0x40154
-/* [R 32] debug only: Serial number status msb 32 bits. '1' indicates this
-   serail number was released by SDM but cannot be used because a previous
-   serial number was not released. */
-#define PRS_REG_SERIAL_NUM_STATUS_MSB				 0x40158
-/* [R 4] debug only: SRC current credit. Transaction based. */
-#define PRS_REG_SRC_CURRENT_CREDIT				 0x4016c
-/* [R 8] debug only: TCM current credit. Cycle based. */
-#define PRS_REG_TCM_CURRENT_CREDIT				 0x40160
-/* [R 8] debug only: TSDM current credit. Transaction based. */
-#define PRS_REG_TSDM_CURRENT_CREDIT				 0x4015c
-/* [R 6] Debug only: Number of used entries in the data FIFO */
-#define PXP2_REG_HST_DATA_FIFO_STATUS				 0x12047c
-/* [R 7] Debug only: Number of used entries in the header FIFO */
-#define PXP2_REG_HST_HEADER_FIFO_STATUS 			 0x120478
-#define PXP2_REG_PGL_ADDR_88_F0 				 0x120534
-#define PXP2_REG_PGL_ADDR_8C_F0 				 0x120538
-#define PXP2_REG_PGL_ADDR_90_F0 				 0x12053c
-#define PXP2_REG_PGL_ADDR_94_F0 				 0x120540
-#define PXP2_REG_PGL_CONTROL0					 0x120490
-#define PXP2_REG_PGL_CONTROL1					 0x120514
-#define PXP2_REG_PGL_DEBUG					 0x120520
-/* [RW 32] third dword data of expansion rom request. this register is
-   special. reading from it provides a vector outstanding read requests. if
-   a bit is zero it means that a read request on the corresponding tag did
-   not finish yet (not all completions have arrived for it) */
-#define PXP2_REG_PGL_EXP_ROM2					 0x120808
-/* [RW 32] Inbound interrupt table for CSDM: bits[31:16]-mask;
-   its[15:0]-address */
-#define PXP2_REG_PGL_INT_CSDM_0 				 0x1204f4
-#define PXP2_REG_PGL_INT_CSDM_1 				 0x1204f8
-#define PXP2_REG_PGL_INT_CSDM_2 				 0x1204fc
-#define PXP2_REG_PGL_INT_CSDM_3 				 0x120500
-#define PXP2_REG_PGL_INT_CSDM_4 				 0x120504
-#define PXP2_REG_PGL_INT_CSDM_5 				 0x120508
-#define PXP2_REG_PGL_INT_CSDM_6 				 0x12050c
-#define PXP2_REG_PGL_INT_CSDM_7 				 0x120510
-/* [RW 32] Inbound interrupt table for TSDM: bits[31:16]-mask;
-   its[15:0]-address */
-#define PXP2_REG_PGL_INT_TSDM_0 				 0x120494
-#define PXP2_REG_PGL_INT_TSDM_1 				 0x120498
-#define PXP2_REG_PGL_INT_TSDM_2 				 0x12049c
-#define PXP2_REG_PGL_INT_TSDM_3 				 0x1204a0
-#define PXP2_REG_PGL_INT_TSDM_4 				 0x1204a4
-#define PXP2_REG_PGL_INT_TSDM_5 				 0x1204a8
-#define PXP2_REG_PGL_INT_TSDM_6 				 0x1204ac
-#define PXP2_REG_PGL_INT_TSDM_7 				 0x1204b0
-/* [RW 32] Inbound interrupt table for USDM: bits[31:16]-mask;
-   its[15:0]-address */
-#define PXP2_REG_PGL_INT_USDM_0 				 0x1204b4
-#define PXP2_REG_PGL_INT_USDM_1 				 0x1204b8
-#define PXP2_REG_PGL_INT_USDM_2 				 0x1204bc
-#define PXP2_REG_PGL_INT_USDM_3 				 0x1204c0
-#define PXP2_REG_PGL_INT_USDM_4 				 0x1204c4
-#define PXP2_REG_PGL_INT_USDM_5 				 0x1204c8
-#define PXP2_REG_PGL_INT_USDM_6 				 0x1204cc
-#define PXP2_REG_PGL_INT_USDM_7 				 0x1204d0
-/* [RW 32] Inbound interrupt table for XSDM: bits[31:16]-mask;
-   its[15:0]-address */
-#define PXP2_REG_PGL_INT_XSDM_0 				 0x1204d4
-#define PXP2_REG_PGL_INT_XSDM_1 				 0x1204d8
-#define PXP2_REG_PGL_INT_XSDM_2 				 0x1204dc
-#define PXP2_REG_PGL_INT_XSDM_3 				 0x1204e0
-#define PXP2_REG_PGL_INT_XSDM_4 				 0x1204e4
-#define PXP2_REG_PGL_INT_XSDM_5 				 0x1204e8
-#define PXP2_REG_PGL_INT_XSDM_6 				 0x1204ec
-#define PXP2_REG_PGL_INT_XSDM_7 				 0x1204f0
-/* [RW 3] this field allows one function to pretend being another function
-   when accessing any BAR mapped resource within the device. the value of
-   the field is the number of the function that will be accessed
-   effectively. after software write to this bit it must read it in order to
-   know that the new value is updated */
-#define PXP2_REG_PGL_PRETEND_FUNC_F0				 0x120674
-#define PXP2_REG_PGL_PRETEND_FUNC_F1				 0x120678
-#define PXP2_REG_PGL_PRETEND_FUNC_F2				 0x12067c
-#define PXP2_REG_PGL_PRETEND_FUNC_F3				 0x120680
-#define PXP2_REG_PGL_PRETEND_FUNC_F4				 0x120684
-#define PXP2_REG_PGL_PRETEND_FUNC_F5				 0x120688
-#define PXP2_REG_PGL_PRETEND_FUNC_F6				 0x12068c
-#define PXP2_REG_PGL_PRETEND_FUNC_F7				 0x120690
-/* [R 1] this bit indicates that a read request was blocked because of
-   bus_master_en was deasserted */
-#define PXP2_REG_PGL_READ_BLOCKED				 0x120568
-#define PXP2_REG_PGL_TAGS_LIMIT 				 0x1205a8
-/* [R 18] debug only */
-#define PXP2_REG_PGL_TXW_CDTS					 0x12052c
-/* [R 1] this bit indicates that a write request was blocked because of
-   bus_master_en was deasserted */
-#define PXP2_REG_PGL_WRITE_BLOCKED				 0x120564
-#define PXP2_REG_PSWRQ_BW_ADD1					 0x1201c0
-#define PXP2_REG_PSWRQ_BW_ADD10 				 0x1201e4
-#define PXP2_REG_PSWRQ_BW_ADD11 				 0x1201e8
-#define PXP2_REG_PSWRQ_BW_ADD2					 0x1201c4
-#define PXP2_REG_PSWRQ_BW_ADD28 				 0x120228
-#define PXP2_REG_PSWRQ_BW_ADD3					 0x1201c8
-#define PXP2_REG_PSWRQ_BW_ADD6					 0x1201d4
-#define PXP2_REG_PSWRQ_BW_ADD7					 0x1201d8
-#define PXP2_REG_PSWRQ_BW_ADD8					 0x1201dc
-#define PXP2_REG_PSWRQ_BW_ADD9					 0x1201e0
-#define PXP2_REG_PSWRQ_BW_CREDIT				 0x12032c
-#define PXP2_REG_PSWRQ_BW_L1					 0x1202b0
-#define PXP2_REG_PSWRQ_BW_L10					 0x1202d4
-#define PXP2_REG_PSWRQ_BW_L11					 0x1202d8
-#define PXP2_REG_PSWRQ_BW_L2					 0x1202b4
-#define PXP2_REG_PSWRQ_BW_L28					 0x120318
-#define PXP2_REG_PSWRQ_BW_L3					 0x1202b8
-#define PXP2_REG_PSWRQ_BW_L6					 0x1202c4
-#define PXP2_REG_PSWRQ_BW_L7					 0x1202c8
-#define PXP2_REG_PSWRQ_BW_L8					 0x1202cc
-#define PXP2_REG_PSWRQ_BW_L9					 0x1202d0
-#define PXP2_REG_PSWRQ_BW_RD					 0x120324
-#define PXP2_REG_PSWRQ_BW_UB1					 0x120238
-#define PXP2_REG_PSWRQ_BW_UB10					 0x12025c
-#define PXP2_REG_PSWRQ_BW_UB11					 0x120260
-#define PXP2_REG_PSWRQ_BW_UB2					 0x12023c
-#define PXP2_REG_PSWRQ_BW_UB28					 0x1202a0
-#define PXP2_REG_PSWRQ_BW_UB3					 0x120240
-#define PXP2_REG_PSWRQ_BW_UB6					 0x12024c
-#define PXP2_REG_PSWRQ_BW_UB7					 0x120250
-#define PXP2_REG_PSWRQ_BW_UB8					 0x120254
-#define PXP2_REG_PSWRQ_BW_UB9					 0x120258
-#define PXP2_REG_PSWRQ_BW_WR					 0x120328
-#define PXP2_REG_PSWRQ_CDU0_L2P 				 0x120000
-#define PXP2_REG_PSWRQ_QM0_L2P					 0x120038
-#define PXP2_REG_PSWRQ_SRC0_L2P 				 0x120054
-#define PXP2_REG_PSWRQ_TM0_L2P					 0x12001c
-#define PXP2_REG_PSWRQ_TSDM0_L2P				 0x1200e0
-/* [RW 32] Interrupt mask register #0 read/write */
-#define PXP2_REG_PXP2_INT_MASK_0				 0x120578
-/* [R 32] Interrupt register #0 read */
-#define PXP2_REG_PXP2_INT_STS_0 				 0x12056c
-#define PXP2_REG_PXP2_INT_STS_1 				 0x120608
-/* [RC 32] Interrupt register #0 read clear */
-#define PXP2_REG_PXP2_INT_STS_CLR_0				 0x120570
-/* [RW 32] Parity mask register #0 read/write */
-#define PXP2_REG_PXP2_PRTY_MASK_0				 0x120588
-#define PXP2_REG_PXP2_PRTY_MASK_1				 0x120598
-/* [R 32] Parity register #0 read */
-#define PXP2_REG_PXP2_PRTY_STS_0				 0x12057c
-#define PXP2_REG_PXP2_PRTY_STS_1				 0x12058c
-/* [R 1] Debug only: The 'almost full' indication from each fifo (gives
-   indication about backpressure) */
-#define PXP2_REG_RD_ALMOST_FULL_0				 0x120424
-/* [R 8] Debug only: The blocks counter - number of unused block ids */
-#define PXP2_REG_RD_BLK_CNT					 0x120418
-/* [RW 8] Debug only: Total number of available blocks in Tetris Buffer.
-   Must be bigger than 6. Normally should not be changed. */
-#define PXP2_REG_RD_BLK_NUM_CFG 				 0x12040c
-/* [RW 2] CDU byte swapping mode configuration for master read requests */
-#define PXP2_REG_RD_CDURD_SWAP_MODE				 0x120404
-/* [RW 1] When '1'; inputs to the PSWRD block are ignored */
-#define PXP2_REG_RD_DISABLE_INPUTS				 0x120374
-/* [R 1] PSWRD internal memories initialization is done */
-#define PXP2_REG_RD_INIT_DONE					 0x120370
-/* [RW 8] The maximum number of blocks in Tetris Buffer that can be
-   allocated for vq10 */
-#define PXP2_REG_RD_MAX_BLKS_VQ10				 0x1203a0
-/* [RW 8] The maximum number of blocks in Tetris Buffer that can be
-   allocated for vq11 */
-#define PXP2_REG_RD_MAX_BLKS_VQ11				 0x1203a4
-/* [RW 8] The maximum number of blocks in Tetris Buffer that can be
-   allocated for vq17 */
-#define PXP2_REG_RD_MAX_BLKS_VQ17				 0x1203bc
-/* [RW 8] The maximum number of blocks in Tetris Buffer that can be
-   allocated for vq18 */
-#define PXP2_REG_RD_MAX_BLKS_VQ18				 0x1203c0
-/* [RW 8] The maximum number of blocks in Tetris Buffer that can be
-   allocated for vq19 */
-#define PXP2_REG_RD_MAX_BLKS_VQ19				 0x1203c4
-/* [RW 8] The maximum number of blocks in Tetris Buffer that can be
-   allocated for vq22 */
-#define PXP2_REG_RD_MAX_BLKS_VQ22				 0x1203d0
-/* [RW 8] The maximum number of blocks in Tetris Buffer that can be
-   allocated for vq25 */
-#define PXP2_REG_RD_MAX_BLKS_VQ25				 0x1203dc
-/* [RW 8] The maximum number of blocks in Tetris Buffer that can be
-   allocated for vq6 */
-#define PXP2_REG_RD_MAX_BLKS_VQ6				 0x120390
-/* [RW 8] The maximum number of blocks in Tetris Buffer that can be
-   allocated for vq9 */
-#define PXP2_REG_RD_MAX_BLKS_VQ9				 0x12039c
-/* [RW 2] PBF byte swapping mode configuration for master read requests */
-#define PXP2_REG_RD_PBF_SWAP_MODE				 0x1203f4
-/* [R 1] Debug only: Indication if delivery ports are idle */
-#define PXP2_REG_RD_PORT_IS_IDLE_0				 0x12041c
-#define PXP2_REG_RD_PORT_IS_IDLE_1				 0x120420
-/* [RW 2] QM byte swapping mode configuration for master read requests */
-#define PXP2_REG_RD_QM_SWAP_MODE				 0x1203f8
-/* [R 7] Debug only: The SR counter - number of unused sub request ids */
-#define PXP2_REG_RD_SR_CNT					 0x120414
-/* [RW 2] SRC byte swapping mode configuration for master read requests */
-#define PXP2_REG_RD_SRC_SWAP_MODE				 0x120400
-/* [RW 7] Debug only: Total number of available PCI read sub-requests. Must
-   be bigger than 1. Normally should not be changed. */
-#define PXP2_REG_RD_SR_NUM_CFG					 0x120408
-/* [RW 1] Signals the PSWRD block to start initializing internal memories */
-#define PXP2_REG_RD_START_INIT					 0x12036c
-/* [RW 2] TM byte swapping mode configuration for master read requests */
-#define PXP2_REG_RD_TM_SWAP_MODE				 0x1203fc
-/* [RW 10] Bandwidth addition to VQ0 write requests */
-#define PXP2_REG_RQ_BW_RD_ADD0					 0x1201bc
-/* [RW 10] Bandwidth addition to VQ12 read requests */
-#define PXP2_REG_RQ_BW_RD_ADD12 				 0x1201ec
-/* [RW 10] Bandwidth addition to VQ13 read requests */
-#define PXP2_REG_RQ_BW_RD_ADD13 				 0x1201f0
-/* [RW 10] Bandwidth addition to VQ14 read requests */
-#define PXP2_REG_RQ_BW_RD_ADD14 				 0x1201f4
-/* [RW 10] Bandwidth addition to VQ15 read requests */
-#define PXP2_REG_RQ_BW_RD_ADD15 				 0x1201f8
-/* [RW 10] Bandwidth addition to VQ16 read requests */
-#define PXP2_REG_RQ_BW_RD_ADD16 				 0x1201fc
-/* [RW 10] Bandwidth addition to VQ17 read requests */
-#define PXP2_REG_RQ_BW_RD_ADD17 				 0x120200
-/* [RW 10] Bandwidth addition to VQ18 read requests */
-#define PXP2_REG_RQ_BW_RD_ADD18 				 0x120204
-/* [RW 10] Bandwidth addition to VQ19 read requests */
-#define PXP2_REG_RQ_BW_RD_ADD19 				 0x120208
-/* [RW 10] Bandwidth addition to VQ20 read requests */
-#define PXP2_REG_RQ_BW_RD_ADD20 				 0x12020c
-/* [RW 10] Bandwidth addition to VQ22 read requests */
-#define PXP2_REG_RQ_BW_RD_ADD22 				 0x120210
-/* [RW 10] Bandwidth addition to VQ23 read requests */
-#define PXP2_REG_RQ_BW_RD_ADD23 				 0x120214
-/* [RW 10] Bandwidth addition to VQ24 read requests */
-#define PXP2_REG_RQ_BW_RD_ADD24 				 0x120218
-/* [RW 10] Bandwidth addition to VQ25 read requests */
-#define PXP2_REG_RQ_BW_RD_ADD25 				 0x12021c
-/* [RW 10] Bandwidth addition to VQ26 read requests */
-#define PXP2_REG_RQ_BW_RD_ADD26 				 0x120220
-/* [RW 10] Bandwidth addition to VQ27 read requests */
-#define PXP2_REG_RQ_BW_RD_ADD27 				 0x120224
-/* [RW 10] Bandwidth addition to VQ4 read requests */
-#define PXP2_REG_RQ_BW_RD_ADD4					 0x1201cc
-/* [RW 10] Bandwidth addition to VQ5 read requests */
-#define PXP2_REG_RQ_BW_RD_ADD5					 0x1201d0
-/* [RW 10] Bandwidth Typical L for VQ0 Read requests */
-#define PXP2_REG_RQ_BW_RD_L0					 0x1202ac
-/* [RW 10] Bandwidth Typical L for VQ12 Read requests */
-#define PXP2_REG_RQ_BW_RD_L12					 0x1202dc
-/* [RW 10] Bandwidth Typical L for VQ13 Read requests */
-#define PXP2_REG_RQ_BW_RD_L13					 0x1202e0
-/* [RW 10] Bandwidth Typical L for VQ14 Read requests */
-#define PXP2_REG_RQ_BW_RD_L14					 0x1202e4
-/* [RW 10] Bandwidth Typical L for VQ15 Read requests */
-#define PXP2_REG_RQ_BW_RD_L15					 0x1202e8
-/* [RW 10] Bandwidth Typical L for VQ16 Read requests */
-#define PXP2_REG_RQ_BW_RD_L16					 0x1202ec
-/* [RW 10] Bandwidth Typical L for VQ17 Read requests */
-#define PXP2_REG_RQ_BW_RD_L17					 0x1202f0
-/* [RW 10] Bandwidth Typical L for VQ18 Read requests */
-#define PXP2_REG_RQ_BW_RD_L18					 0x1202f4
-/* [RW 10] Bandwidth Typical L for VQ19 Read requests */
-#define PXP2_REG_RQ_BW_RD_L19					 0x1202f8
-/* [RW 10] Bandwidth Typical L for VQ20 Read requests */
-#define PXP2_REG_RQ_BW_RD_L20					 0x1202fc
-/* [RW 10] Bandwidth Typical L for VQ22 Read requests */
-#define PXP2_REG_RQ_BW_RD_L22					 0x120300
-/* [RW 10] Bandwidth Typical L for VQ23 Read requests */
-#define PXP2_REG_RQ_BW_RD_L23					 0x120304
-/* [RW 10] Bandwidth Typical L for VQ24 Read requests */
-#define PXP2_REG_RQ_BW_RD_L24					 0x120308
-/* [RW 10] Bandwidth Typical L for VQ25 Read requests */
-#define PXP2_REG_RQ_BW_RD_L25					 0x12030c
-/* [RW 10] Bandwidth Typical L for VQ26 Read requests */
-#define PXP2_REG_RQ_BW_RD_L26					 0x120310
-/* [RW 10] Bandwidth Typical L for VQ27 Read requests */
-#define PXP2_REG_RQ_BW_RD_L27					 0x120314
-/* [RW 10] Bandwidth Typical L for VQ4 Read requests */
-#define PXP2_REG_RQ_BW_RD_L4					 0x1202bc
-/* [RW 10] Bandwidth Typical L for VQ5 Read- currently not used */
-#define PXP2_REG_RQ_BW_RD_L5					 0x1202c0
-/* [RW 7] Bandwidth upper bound for VQ0 read requests */
-#define PXP2_REG_RQ_BW_RD_UBOUND0				 0x120234
-/* [RW 7] Bandwidth upper bound for VQ12 read requests */
-#define PXP2_REG_RQ_BW_RD_UBOUND12				 0x120264
-/* [RW 7] Bandwidth upper bound for VQ13 read requests */
-#define PXP2_REG_RQ_BW_RD_UBOUND13				 0x120268
-/* [RW 7] Bandwidth upper bound for VQ14 read requests */
-#define PXP2_REG_RQ_BW_RD_UBOUND14				 0x12026c
-/* [RW 7] Bandwidth upper bound for VQ15 read requests */
-#define PXP2_REG_RQ_BW_RD_UBOUND15				 0x120270
-/* [RW 7] Bandwidth upper bound for VQ16 read requests */
-#define PXP2_REG_RQ_BW_RD_UBOUND16				 0x120274
-/* [RW 7] Bandwidth upper bound for VQ17 read requests */
-#define PXP2_REG_RQ_BW_RD_UBOUND17				 0x120278
-/* [RW 7] Bandwidth upper bound for VQ18 read requests */
-#define PXP2_REG_RQ_BW_RD_UBOUND18				 0x12027c
-/* [RW 7] Bandwidth upper bound for VQ19 read requests */
-#define PXP2_REG_RQ_BW_RD_UBOUND19				 0x120280
-/* [RW 7] Bandwidth upper bound for VQ20 read requests */
-#define PXP2_REG_RQ_BW_RD_UBOUND20				 0x120284
-/* [RW 7] Bandwidth upper bound for VQ22 read requests */
-#define PXP2_REG_RQ_BW_RD_UBOUND22				 0x120288
-/* [RW 7] Bandwidth upper bound for VQ23 read requests */
-#define PXP2_REG_RQ_BW_RD_UBOUND23				 0x12028c
-/* [RW 7] Bandwidth upper bound for VQ24 read requests */
-#define PXP2_REG_RQ_BW_RD_UBOUND24				 0x120290
-/* [RW 7] Bandwidth upper bound for VQ25 read requests */
-#define PXP2_REG_RQ_BW_RD_UBOUND25				 0x120294
-/* [RW 7] Bandwidth upper bound for VQ26 read requests */
-#define PXP2_REG_RQ_BW_RD_UBOUND26				 0x120298
-/* [RW 7] Bandwidth upper bound for VQ27 read requests */
-#define PXP2_REG_RQ_BW_RD_UBOUND27				 0x12029c
-/* [RW 7] Bandwidth upper bound for VQ4 read requests */
-#define PXP2_REG_RQ_BW_RD_UBOUND4				 0x120244
-/* [RW 7] Bandwidth upper bound for VQ5 read requests */
-#define PXP2_REG_RQ_BW_RD_UBOUND5				 0x120248
-/* [RW 10] Bandwidth addition to VQ29 write requests */
-#define PXP2_REG_RQ_BW_WR_ADD29 				 0x12022c
-/* [RW 10] Bandwidth addition to VQ30 write requests */
-#define PXP2_REG_RQ_BW_WR_ADD30 				 0x120230
-/* [RW 10] Bandwidth Typical L for VQ29 Write requests */
-#define PXP2_REG_RQ_BW_WR_L29					 0x12031c
-/* [RW 10] Bandwidth Typical L for VQ30 Write requests */
-#define PXP2_REG_RQ_BW_WR_L30					 0x120320
-/* [RW 7] Bandwidth upper bound for VQ29 */
-#define PXP2_REG_RQ_BW_WR_UBOUND29				 0x1202a4
-/* [RW 7] Bandwidth upper bound for VQ30 */
-#define PXP2_REG_RQ_BW_WR_UBOUND30				 0x1202a8
-/* [RW 18] external first_mem_addr field in L2P table for CDU module port 0 */
-#define PXP2_REG_RQ_CDU0_EFIRST_MEM_ADDR			 0x120008
-/* [RW 2] Endian mode for cdu */
-#define PXP2_REG_RQ_CDU_ENDIAN_M				 0x1201a0
-#define PXP2_REG_RQ_CDU_FIRST_ILT				 0x12061c
-#define PXP2_REG_RQ_CDU_LAST_ILT				 0x120620
-/* [RW 3] page size in L2P table for CDU module; -4k; -8k; -16k; -32k; -64k;
-   -128k */
-#define PXP2_REG_RQ_CDU_P_SIZE					 0x120018
-/* [R 1] 1' indicates that the requester has finished its internal
-   configuration */
-#define PXP2_REG_RQ_CFG_DONE					 0x1201b4
-/* [RW 2] Endian mode for debug */
-#define PXP2_REG_RQ_DBG_ENDIAN_M				 0x1201a4
-/* [RW 1] When '1'; requests will enter input buffers but wont get out
-   towards the glue */
-#define PXP2_REG_RQ_DISABLE_INPUTS				 0x120330
-/* [RW 1] 1 - SR will be aligned by 64B; 0 - SR will be aligned by 8B */
-#define PXP2_REG_RQ_DRAM_ALIGN					 0x1205b0
-/* [RW 1] If 1 ILT failiue will not result in ELT access; An interrupt will
-   be asserted */
-#define PXP2_REG_RQ_ELT_DISABLE 				 0x12066c
-/* [RW 2] Endian mode for hc */
-#define PXP2_REG_RQ_HC_ENDIAN_M 				 0x1201a8
-/* [RW 1] when '0' ILT logic will work as in A0; otherwise B0; for back
-   compatibility needs; Note that different registers are used per mode */
-#define PXP2_REG_RQ_ILT_MODE					 0x1205b4
-/* [WB 53] Onchip address table */
-#define PXP2_REG_RQ_ONCHIP_AT					 0x122000
-/* [WB 53] Onchip address table - B0 */
-#define PXP2_REG_RQ_ONCHIP_AT_B0				 0x128000
-/* [RW 13] Pending read limiter threshold; in Dwords */
-#define PXP2_REG_RQ_PDR_LIMIT					 0x12033c
-/* [RW 2] Endian mode for qm */
-#define PXP2_REG_RQ_QM_ENDIAN_M 				 0x120194
-#define PXP2_REG_RQ_QM_FIRST_ILT				 0x120634
-#define PXP2_REG_RQ_QM_LAST_ILT 				 0x120638
-/* [RW 3] page size in L2P table for QM module; -4k; -8k; -16k; -32k; -64k;
-   -128k */
-#define PXP2_REG_RQ_QM_P_SIZE					 0x120050
-/* [RW 1] 1' indicates that the RBC has finished configuring the PSWRQ */
-#define PXP2_REG_RQ_RBC_DONE					 0x1201b0
-/* [RW 3] Max burst size filed for read requests port 0; 000 - 128B;
-   001:256B; 010: 512B; 11:1K:100:2K; 01:4K */
-#define PXP2_REG_RQ_RD_MBS0					 0x120160
-/* [RW 3] Max burst size filed for read requests port 1; 000 - 128B;
-   001:256B; 010: 512B; 11:1K:100:2K; 01:4K */
-#define PXP2_REG_RQ_RD_MBS1					 0x120168
-/* [RW 2] Endian mode for src */
-#define PXP2_REG_RQ_SRC_ENDIAN_M				 0x12019c
-#define PXP2_REG_RQ_SRC_FIRST_ILT				 0x12063c
-#define PXP2_REG_RQ_SRC_LAST_ILT				 0x120640
-/* [RW 3] page size in L2P table for SRC module; -4k; -8k; -16k; -32k; -64k;
-   -128k */
-#define PXP2_REG_RQ_SRC_P_SIZE					 0x12006c
-/* [RW 2] Endian mode for tm */
-#define PXP2_REG_RQ_TM_ENDIAN_M 				 0x120198
-#define PXP2_REG_RQ_TM_FIRST_ILT				 0x120644
-#define PXP2_REG_RQ_TM_LAST_ILT 				 0x120648
-/* [RW 3] page size in L2P table for TM module; -4k; -8k; -16k; -32k; -64k;
-   -128k */
-#define PXP2_REG_RQ_TM_P_SIZE					 0x120034
-/* [R 5] Number of entries in the ufifo; his fifo has l2p completions */
-#define PXP2_REG_RQ_UFIFO_NUM_OF_ENTRY				 0x12080c
-/* [RW 18] external first_mem_addr field in L2P table for USDM module port 0 */
-#define PXP2_REG_RQ_USDM0_EFIRST_MEM_ADDR			 0x120094
-/* [R 8] Number of entries occupied by vq 0 in pswrq memory */
-#define PXP2_REG_RQ_VQ0_ENTRY_CNT				 0x120810
-/* [R 8] Number of entries occupied by vq 10 in pswrq memory */
-#define PXP2_REG_RQ_VQ10_ENTRY_CNT				 0x120818
-/* [R 8] Number of entries occupied by vq 11 in pswrq memory */
-#define PXP2_REG_RQ_VQ11_ENTRY_CNT				 0x120820
-/* [R 8] Number of entries occupied by vq 12 in pswrq memory */
-#define PXP2_REG_RQ_VQ12_ENTRY_CNT				 0x120828
-/* [R 8] Number of entries occupied by vq 13 in pswrq memory */
-#define PXP2_REG_RQ_VQ13_ENTRY_CNT				 0x120830
-/* [R 8] Number of entries occupied by vq 14 in pswrq memory */
-#define PXP2_REG_RQ_VQ14_ENTRY_CNT				 0x120838
-/* [R 8] Number of entries occupied by vq 15 in pswrq memory */
-#define PXP2_REG_RQ_VQ15_ENTRY_CNT				 0x120840
-/* [R 8] Number of entries occupied by vq 16 in pswrq memory */
-#define PXP2_REG_RQ_VQ16_ENTRY_CNT				 0x120848
-/* [R 8] Number of entries occupied by vq 17 in pswrq memory */
-#define PXP2_REG_RQ_VQ17_ENTRY_CNT				 0x120850
-/* [R 8] Number of entries occupied by vq 18 in pswrq memory */
-#define PXP2_REG_RQ_VQ18_ENTRY_CNT				 0x120858
-/* [R 8] Number of entries occupied by vq 19 in pswrq memory */
-#define PXP2_REG_RQ_VQ19_ENTRY_CNT				 0x120860
-/* [R 8] Number of entries occupied by vq 1 in pswrq memory */
-#define PXP2_REG_RQ_VQ1_ENTRY_CNT				 0x120868
-/* [R 8] Number of entries occupied by vq 20 in pswrq memory */
-#define PXP2_REG_RQ_VQ20_ENTRY_CNT				 0x120870
-/* [R 8] Number of entries occupied by vq 21 in pswrq memory */
-#define PXP2_REG_RQ_VQ21_ENTRY_CNT				 0x120878
-/* [R 8] Number of entries occupied by vq 22 in pswrq memory */
-#define PXP2_REG_RQ_VQ22_ENTRY_CNT				 0x120880
-/* [R 8] Number of entries occupied by vq 23 in pswrq memory */
-#define PXP2_REG_RQ_VQ23_ENTRY_CNT				 0x120888
-/* [R 8] Number of entries occupied by vq 24 in pswrq memory */
-#define PXP2_REG_RQ_VQ24_ENTRY_CNT				 0x120890
-/* [R 8] Number of entries occupied by vq 25 in pswrq memory */
-#define PXP2_REG_RQ_VQ25_ENTRY_CNT				 0x120898
-/* [R 8] Number of entries occupied by vq 26 in pswrq memory */
-#define PXP2_REG_RQ_VQ26_ENTRY_CNT				 0x1208a0
-/* [R 8] Number of entries occupied by vq 27 in pswrq memory */
-#define PXP2_REG_RQ_VQ27_ENTRY_CNT				 0x1208a8
-/* [R 8] Number of entries occupied by vq 28 in pswrq memory */
-#define PXP2_REG_RQ_VQ28_ENTRY_CNT				 0x1208b0
-/* [R 8] Number of entries occupied by vq 29 in pswrq memory */
-#define PXP2_REG_RQ_VQ29_ENTRY_CNT				 0x1208b8
-/* [R 8] Number of entries occupied by vq 2 in pswrq memory */
-#define PXP2_REG_RQ_VQ2_ENTRY_CNT				 0x1208c0
-/* [R 8] Number of entries occupied by vq 30 in pswrq memory */
-#define PXP2_REG_RQ_VQ30_ENTRY_CNT				 0x1208c8
-/* [R 8] Number of entries occupied by vq 31 in pswrq memory */
-#define PXP2_REG_RQ_VQ31_ENTRY_CNT				 0x1208d0
-/* [R 8] Number of entries occupied by vq 3 in pswrq memory */
-#define PXP2_REG_RQ_VQ3_ENTRY_CNT				 0x1208d8
-/* [R 8] Number of entries occupied by vq 4 in pswrq memory */
-#define PXP2_REG_RQ_VQ4_ENTRY_CNT				 0x1208e0
-/* [R 8] Number of entries occupied by vq 5 in pswrq memory */
-#define PXP2_REG_RQ_VQ5_ENTRY_CNT				 0x1208e8
-/* [R 8] Number of entries occupied by vq 6 in pswrq memory */
-#define PXP2_REG_RQ_VQ6_ENTRY_CNT				 0x1208f0
-/* [R 8] Number of entries occupied by vq 7 in pswrq memory */
-#define PXP2_REG_RQ_VQ7_ENTRY_CNT				 0x1208f8
-/* [R 8] Number of entries occupied by vq 8 in pswrq memory */
-#define PXP2_REG_RQ_VQ8_ENTRY_CNT				 0x120900
-/* [R 8] Number of entries occupied by vq 9 in pswrq memory */
-#define PXP2_REG_RQ_VQ9_ENTRY_CNT				 0x120908
-/* [RW 3] Max burst size filed for write requests port 0; 000 - 128B;
-   001:256B; 010: 512B; */
-#define PXP2_REG_RQ_WR_MBS0					 0x12015c
-/* [RW 3] Max burst size filed for write requests port 1; 000 - 128B;
-   001:256B; 010: 512B; */
-#define PXP2_REG_RQ_WR_MBS1					 0x120164
-/* [RW 2] 0 - 128B;  - 256B;  - 512B;  - 1024B; when the payload in the
-   buffer reaches this number has_payload will be asserted */
-#define PXP2_REG_WR_CDU_MPS					 0x1205f0
-/* [RW 2] 0 - 128B;  - 256B;  - 512B;  - 1024B; when the payload in the
-   buffer reaches this number has_payload will be asserted */
-#define PXP2_REG_WR_CSDM_MPS					 0x1205d0
-/* [RW 2] 0 - 128B;  - 256B;  - 512B;  - 1024B; when the payload in the
-   buffer reaches this number has_payload will be asserted */
-#define PXP2_REG_WR_DBG_MPS					 0x1205e8
-/* [RW 2] 0 - 128B;  - 256B;  - 512B;  - 1024B; when the payload in the
-   buffer reaches this number has_payload will be asserted */
-#define PXP2_REG_WR_DMAE_MPS					 0x1205ec
-/* [RW 10] if Number of entries in dmae fifo will be higher than this
-   threshold then has_payload indication will be asserted; the default value
-   should be equal to &gt;  write MBS size! */
-#define PXP2_REG_WR_DMAE_TH					 0x120368
-/* [RW 2] 0 - 128B;  - 256B;  - 512B;  - 1024B; when the payload in the
-   buffer reaches this number has_payload will be asserted */
-#define PXP2_REG_WR_HC_MPS					 0x1205c8
-/* [RW 2] 0 - 128B;  - 256B;  - 512B;  - 1024B; when the payload in the
-   buffer reaches this number has_payload will be asserted */
-#define PXP2_REG_WR_QM_MPS					 0x1205dc
-/* [RW 1] 0 - working in A0 mode;  - working in B0 mode */
-#define PXP2_REG_WR_REV_MODE					 0x120670
-/* [RW 2] 0 - 128B;  - 256B;  - 512B;  - 1024B; when the payload in the
-   buffer reaches this number has_payload will be asserted */
-#define PXP2_REG_WR_SRC_MPS					 0x1205e4
-/* [RW 2] 0 - 128B;  - 256B;  - 512B;  - 1024B; when the payload in the
-   buffer reaches this number has_payload will be asserted */
-#define PXP2_REG_WR_TM_MPS					 0x1205e0
-/* [RW 2] 0 - 128B;  - 256B;  - 512B;  - 1024B; when the payload in the
-   buffer reaches this number has_payload will be asserted */
-#define PXP2_REG_WR_TSDM_MPS					 0x1205d4
-/* [RW 10] if Number of entries in usdmdp fifo will be higher than this
-   threshold then has_payload indication will be asserted; the default value
-   should be equal to &gt;  write MBS size! */
-#define PXP2_REG_WR_USDMDP_TH					 0x120348
-/* [RW 2] 0 - 128B;  - 256B;  - 512B;  - 1024B; when the payload in the
-   buffer reaches this number has_payload will be asserted */
-#define PXP2_REG_WR_USDM_MPS					 0x1205cc
-/* [RW 2] 0 - 128B;  - 256B;  - 512B;  - 1024B; when the payload in the
-   buffer reaches this number has_payload will be asserted */
-#define PXP2_REG_WR_XSDM_MPS					 0x1205d8
-/* [R 1] debug only: Indication if PSWHST arbiter is idle */
-#define PXP_REG_HST_ARB_IS_IDLE 				 0x103004
-/* [R 8] debug only: A bit mask for all PSWHST arbiter clients. '1' means
-   this client is waiting for the arbiter. */
-#define PXP_REG_HST_CLIENTS_WAITING_TO_ARB			 0x103008
-/* [R 1] debug only: '1' means this PSWHST is discarding doorbells. This bit
-   should update accoring to 'hst_discard_doorbells' register when the state
-   machine is idle */
-#define PXP_REG_HST_DISCARD_DOORBELLS_STATUS			 0x1030a0
-/* [R 6] debug only: A bit mask for all PSWHST internal write clients. '1'
-   means this PSWHST is discarding inputs from this client. Each bit should
-   update accoring to 'hst_discard_internal_writes' register when the state
-   machine is idle. */
-#define PXP_REG_HST_DISCARD_INTERNAL_WRITES_STATUS		 0x10309c
-/* [WB 160] Used for initialization of the inbound interrupts memory */
-#define PXP_REG_HST_INBOUND_INT 				 0x103800
-/* [RW 32] Interrupt mask register #0 read/write */
-#define PXP_REG_PXP_INT_MASK_0					 0x103074
-#define PXP_REG_PXP_INT_MASK_1					 0x103084
-/* [R 32] Interrupt register #0 read */
-#define PXP_REG_PXP_INT_STS_0					 0x103068
-#define PXP_REG_PXP_INT_STS_1					 0x103078
-/* [RC 32] Interrupt register #0 read clear */
-#define PXP_REG_PXP_INT_STS_CLR_0				 0x10306c
-/* [RW 26] Parity mask register #0 read/write */
-#define PXP_REG_PXP_PRTY_MASK					 0x103094
-/* [R 26] Parity register #0 read */
-#define PXP_REG_PXP_PRTY_STS					 0x103088
-/* [RW 4] The activity counter initial increment value sent in the load
-   request */
-#define QM_REG_ACTCTRINITVAL_0					 0x168040
-#define QM_REG_ACTCTRINITVAL_1					 0x168044
-#define QM_REG_ACTCTRINITVAL_2					 0x168048
-#define QM_REG_ACTCTRINITVAL_3					 0x16804c
-/* [RW 32] The base logical address (in bytes) of each physical queue. The
-   index I represents the physical queue number. The 12 lsbs are ignore and
-   considered zero so practically there are only 20 bits in this register;
-   queues 63-0 */
-#define QM_REG_BASEADDR 					 0x168900
-/* [RW 32] The base logical address (in bytes) of each physical queue. The
-   index I represents the physical queue number. The 12 lsbs are ignore and
-   considered zero so practically there are only 20 bits in this register;
-   queues 127-64 */
-#define QM_REG_BASEADDR_EXT_A					 0x16e100
-/* [RW 16] The byte credit cost for each task. This value is for both ports */
-#define QM_REG_BYTECRDCOST					 0x168234
-/* [RW 16] The initial byte credit value for both ports. */
-#define QM_REG_BYTECRDINITVAL					 0x168238
-/* [RW 32] A bit per physical queue. If the bit is cleared then the physical
-   queue uses port 0 else it uses port 1; queues 31-0 */
-#define QM_REG_BYTECRDPORT_LSB					 0x168228
-/* [RW 32] A bit per physical queue. If the bit is cleared then the physical
-   queue uses port 0 else it uses port 1; queues 95-64 */
-#define QM_REG_BYTECRDPORT_LSB_EXT_A				 0x16e520
-/* [RW 32] A bit per physical queue. If the bit is cleared then the physical
-   queue uses port 0 else it uses port 1; queues 63-32 */
-#define QM_REG_BYTECRDPORT_MSB					 0x168224
-/* [RW 32] A bit per physical queue. If the bit is cleared then the physical
-   queue uses port 0 else it uses port 1; queues 127-96 */
-#define QM_REG_BYTECRDPORT_MSB_EXT_A				 0x16e51c
-/* [RW 16] The byte credit value that if above the QM is considered almost
-   full */
-#define QM_REG_BYTECREDITAFULLTHR				 0x168094
-/* [RW 4] The initial credit for interface */
-#define QM_REG_CMINITCRD_0					 0x1680cc
-#define QM_REG_CMINITCRD_1					 0x1680d0
-#define QM_REG_CMINITCRD_2					 0x1680d4
-#define QM_REG_CMINITCRD_3					 0x1680d8
-#define QM_REG_CMINITCRD_4					 0x1680dc
-#define QM_REG_CMINITCRD_5					 0x1680e0
-#define QM_REG_CMINITCRD_6					 0x1680e4
-#define QM_REG_CMINITCRD_7					 0x1680e8
-/* [RW 8] A mask bit per CM interface. If this bit is 0 then this interface
-   is masked */
-#define QM_REG_CMINTEN						 0x1680ec
-/* [RW 12] A bit vector which indicates which one of the queues are tied to
-   interface 0 */
-#define QM_REG_CMINTVOQMASK_0					 0x1681f4
-#define QM_REG_CMINTVOQMASK_1					 0x1681f8
-#define QM_REG_CMINTVOQMASK_2					 0x1681fc
-#define QM_REG_CMINTVOQMASK_3					 0x168200
-#define QM_REG_CMINTVOQMASK_4					 0x168204
-#define QM_REG_CMINTVOQMASK_5					 0x168208
-#define QM_REG_CMINTVOQMASK_6					 0x16820c
-#define QM_REG_CMINTVOQMASK_7					 0x168210
-/* [RW 20] The number of connections divided by 16 which dictates the size
-   of each queue which belongs to even function number. */
-#define QM_REG_CONNNUM_0					 0x168020
-/* [R 6] Keep the fill level of the fifo from write client 4 */
-#define QM_REG_CQM_WRC_FIFOLVL					 0x168018
-/* [RW 8] The context regions sent in the CFC load request */
-#define QM_REG_CTXREG_0 					 0x168030
-#define QM_REG_CTXREG_1 					 0x168034
-#define QM_REG_CTXREG_2 					 0x168038
-#define QM_REG_CTXREG_3 					 0x16803c
-/* [RW 12] The VOQ mask used to select the VOQs which needs to be full for
-   bypass enable */
-#define QM_REG_ENBYPVOQMASK					 0x16823c
-/* [RW 32] A bit mask per each physical queue. If a bit is set then the
-   physical queue uses the byte credit; queues 31-0 */
-#define QM_REG_ENBYTECRD_LSB					 0x168220
-/* [RW 32] A bit mask per each physical queue. If a bit is set then the
-   physical queue uses the byte credit; queues 95-64 */
-#define QM_REG_ENBYTECRD_LSB_EXT_A				 0x16e518
-/* [RW 32] A bit mask per each physical queue. If a bit is set then the
-   physical queue uses the byte credit; queues 63-32 */
-#define QM_REG_ENBYTECRD_MSB					 0x16821c
-/* [RW 32] A bit mask per each physical queue. If a bit is set then the
-   physical queue uses the byte credit; queues 127-96 */
-#define QM_REG_ENBYTECRD_MSB_EXT_A				 0x16e514
-/* [RW 4] If cleared then the secondary interface will not be served by the
-   RR arbiter */
-#define QM_REG_ENSEC						 0x1680f0
-/* [RW 32] NA */
-#define QM_REG_FUNCNUMSEL_LSB					 0x168230
-/* [RW 32] NA */
-#define QM_REG_FUNCNUMSEL_MSB					 0x16822c
-/* [RW 32] A mask register to mask the Almost empty signals which will not
-   be use for the almost empty indication to the HW block; queues 31:0 */
-#define QM_REG_HWAEMPTYMASK_LSB 				 0x168218
-/* [RW 32] A mask register to mask the Almost empty signals which will not
-   be use for the almost empty indication to the HW block; queues 95-64 */
-#define QM_REG_HWAEMPTYMASK_LSB_EXT_A				 0x16e510
-/* [RW 32] A mask register to mask the Almost empty signals which will not
-   be use for the almost empty indication to the HW block; queues 63:32 */
-#define QM_REG_HWAEMPTYMASK_MSB 				 0x168214
-/* [RW 32] A mask register to mask the Almost empty signals which will not
-   be use for the almost empty indication to the HW block; queues 127-96 */
-#define QM_REG_HWAEMPTYMASK_MSB_EXT_A				 0x16e50c
-/* [RW 4] The number of outstanding request to CFC */
-#define QM_REG_OUTLDREQ 					 0x168804
-/* [RC 1] A flag to indicate that overflow error occurred in one of the
-   queues. */
-#define QM_REG_OVFERROR 					 0x16805c
-/* [RC 7] the Q where the overflow occurs */
-#define QM_REG_OVFQNUM						 0x168058
-/* [R 16] Pause state for physical queues 15-0 */
-#define QM_REG_PAUSESTATE0					 0x168410
-/* [R 16] Pause state for physical queues 31-16 */
-#define QM_REG_PAUSESTATE1					 0x168414
-/* [R 16] Pause state for physical queues 47-32 */
-#define QM_REG_PAUSESTATE2					 0x16e684
-/* [R 16] Pause state for physical queues 63-48 */
-#define QM_REG_PAUSESTATE3					 0x16e688
-/* [R 16] Pause state for physical queues 79-64 */
-#define QM_REG_PAUSESTATE4					 0x16e68c
-/* [R 16] Pause state for physical queues 95-80 */
-#define QM_REG_PAUSESTATE5					 0x16e690
-/* [R 16] Pause state for physical queues 111-96 */
-#define QM_REG_PAUSESTATE6					 0x16e694
-/* [R 16] Pause state for physical queues 127-112 */
-#define QM_REG_PAUSESTATE7					 0x16e698
-/* [RW 2] The PCI attributes field used in the PCI request. */
-#define QM_REG_PCIREQAT 					 0x168054
-/* [R 16] The byte credit of port 0 */
-#define QM_REG_PORT0BYTECRD					 0x168300
-/* [R 16] The byte credit of port 1 */
-#define QM_REG_PORT1BYTECRD					 0x168304
-/* [RW 3] pci function number of queues 15-0 */
-#define QM_REG_PQ2PCIFUNC_0					 0x16e6bc
-#define QM_REG_PQ2PCIFUNC_1					 0x16e6c0
-#define QM_REG_PQ2PCIFUNC_2					 0x16e6c4
-#define QM_REG_PQ2PCIFUNC_3					 0x16e6c8
-#define QM_REG_PQ2PCIFUNC_4					 0x16e6cc
-#define QM_REG_PQ2PCIFUNC_5					 0x16e6d0
-#define QM_REG_PQ2PCIFUNC_6					 0x16e6d4
-#define QM_REG_PQ2PCIFUNC_7					 0x16e6d8
-/* [WB 54] Pointer Table Memory for queues 63-0; The mapping is as follow:
-   ptrtbl[53:30] read pointer; ptrtbl[29:6] write pointer; ptrtbl[5:4] read
-   bank0; ptrtbl[3:2] read bank 1; ptrtbl[1:0] write bank; */
-#define QM_REG_PTRTBL						 0x168a00
-/* [WB 54] Pointer Table Memory for queues 127-64; The mapping is as follow:
-   ptrtbl[53:30] read pointer; ptrtbl[29:6] write pointer; ptrtbl[5:4] read
-   bank0; ptrtbl[3:2] read bank 1; ptrtbl[1:0] write bank; */
-#define QM_REG_PTRTBL_EXT_A					 0x16e200
-/* [RW 2] Interrupt mask register #0 read/write */
-#define QM_REG_QM_INT_MASK					 0x168444
-/* [R 2] Interrupt register #0 read */
-#define QM_REG_QM_INT_STS					 0x168438
-/* [RW 12] Parity mask register #0 read/write */
-#define QM_REG_QM_PRTY_MASK					 0x168454
-/* [R 12] Parity register #0 read */
-#define QM_REG_QM_PRTY_STS					 0x168448
-/* [R 32] Current queues in pipeline: Queues from 32 to 63 */
-#define QM_REG_QSTATUS_HIGH					 0x16802c
-/* [R 32] Current queues in pipeline: Queues from 96 to 127 */
-#define QM_REG_QSTATUS_HIGH_EXT_A				 0x16e408
-/* [R 32] Current queues in pipeline: Queues from 0 to 31 */
-#define QM_REG_QSTATUS_LOW					 0x168028
-/* [R 32] Current queues in pipeline: Queues from 64 to 95 */
-#define QM_REG_QSTATUS_LOW_EXT_A				 0x16e404
-/* [R 24] The number of tasks queued for each queue; queues 63-0 */
-#define QM_REG_QTASKCTR_0					 0x168308
-/* [R 24] The number of tasks queued for each queue; queues 127-64 */
-#define QM_REG_QTASKCTR_EXT_A_0 				 0x16e584
-/* [RW 4] Queue tied to VOQ */
-#define QM_REG_QVOQIDX_0					 0x1680f4
-#define QM_REG_QVOQIDX_10					 0x16811c
-#define QM_REG_QVOQIDX_100					 0x16e49c
-#define QM_REG_QVOQIDX_101					 0x16e4a0
-#define QM_REG_QVOQIDX_102					 0x16e4a4
-#define QM_REG_QVOQIDX_103					 0x16e4a8
-#define QM_REG_QVOQIDX_104					 0x16e4ac
-#define QM_REG_QVOQIDX_105					 0x16e4b0
-#define QM_REG_QVOQIDX_106					 0x16e4b4
-#define QM_REG_QVOQIDX_107					 0x16e4b8
-#define QM_REG_QVOQIDX_108					 0x16e4bc
-#define QM_REG_QVOQIDX_109					 0x16e4c0
-#define QM_REG_QVOQIDX_11					 0x168120
-#define QM_REG_QVOQIDX_110					 0x16e4c4
-#define QM_REG_QVOQIDX_111					 0x16e4c8
-#define QM_REG_QVOQIDX_112					 0x16e4cc
-#define QM_REG_QVOQIDX_113					 0x16e4d0
-#define QM_REG_QVOQIDX_114					 0x16e4d4
-#define QM_REG_QVOQIDX_115					 0x16e4d8
-#define QM_REG_QVOQIDX_116					 0x16e4dc
-#define QM_REG_QVOQIDX_117					 0x16e4e0
-#define QM_REG_QVOQIDX_118					 0x16e4e4
-#define QM_REG_QVOQIDX_119					 0x16e4e8
-#define QM_REG_QVOQIDX_12					 0x168124
-#define QM_REG_QVOQIDX_120					 0x16e4ec
-#define QM_REG_QVOQIDX_121					 0x16e4f0
-#define QM_REG_QVOQIDX_122					 0x16e4f4
-#define QM_REG_QVOQIDX_123					 0x16e4f8
-#define QM_REG_QVOQIDX_124					 0x16e4fc
-#define QM_REG_QVOQIDX_125					 0x16e500
-#define QM_REG_QVOQIDX_126					 0x16e504
-#define QM_REG_QVOQIDX_127					 0x16e508
-#define QM_REG_QVOQIDX_13					 0x168128
-#define QM_REG_QVOQIDX_14					 0x16812c
-#define QM_REG_QVOQIDX_15					 0x168130
-#define QM_REG_QVOQIDX_16					 0x168134
-#define QM_REG_QVOQIDX_17					 0x168138
-#define QM_REG_QVOQIDX_21					 0x168148
-#define QM_REG_QVOQIDX_22					 0x16814c
-#define QM_REG_QVOQIDX_23					 0x168150
-#define QM_REG_QVOQIDX_24					 0x168154
-#define QM_REG_QVOQIDX_25					 0x168158
-#define QM_REG_QVOQIDX_26					 0x16815c
-#define QM_REG_QVOQIDX_27					 0x168160
-#define QM_REG_QVOQIDX_28					 0x168164
-#define QM_REG_QVOQIDX_29					 0x168168
-#define QM_REG_QVOQIDX_30					 0x16816c
-#define QM_REG_QVOQIDX_31					 0x168170
-#define QM_REG_QVOQIDX_32					 0x168174
-#define QM_REG_QVOQIDX_33					 0x168178
-#define QM_REG_QVOQIDX_34					 0x16817c
-#define QM_REG_QVOQIDX_35					 0x168180
-#define QM_REG_QVOQIDX_36					 0x168184
-#define QM_REG_QVOQIDX_37					 0x168188
-#define QM_REG_QVOQIDX_38					 0x16818c
-#define QM_REG_QVOQIDX_39					 0x168190
-#define QM_REG_QVOQIDX_40					 0x168194
-#define QM_REG_QVOQIDX_41					 0x168198
-#define QM_REG_QVOQIDX_42					 0x16819c
-#define QM_REG_QVOQIDX_43					 0x1681a0
-#define QM_REG_QVOQIDX_44					 0x1681a4
-#define QM_REG_QVOQIDX_45					 0x1681a8
-#define QM_REG_QVOQIDX_46					 0x1681ac
-#define QM_REG_QVOQIDX_47					 0x1681b0
-#define QM_REG_QVOQIDX_48					 0x1681b4
-#define QM_REG_QVOQIDX_49					 0x1681b8
-#define QM_REG_QVOQIDX_5					 0x168108
-#define QM_REG_QVOQIDX_50					 0x1681bc
-#define QM_REG_QVOQIDX_51					 0x1681c0
-#define QM_REG_QVOQIDX_52					 0x1681c4
-#define QM_REG_QVOQIDX_53					 0x1681c8
-#define QM_REG_QVOQIDX_54					 0x1681cc
-#define QM_REG_QVOQIDX_55					 0x1681d0
-#define QM_REG_QVOQIDX_56					 0x1681d4
-#define QM_REG_QVOQIDX_57					 0x1681d8
-#define QM_REG_QVOQIDX_58					 0x1681dc
-#define QM_REG_QVOQIDX_59					 0x1681e0
-#define QM_REG_QVOQIDX_6					 0x16810c
-#define QM_REG_QVOQIDX_60					 0x1681e4
-#define QM_REG_QVOQIDX_61					 0x1681e8
-#define QM_REG_QVOQIDX_62					 0x1681ec
-#define QM_REG_QVOQIDX_63					 0x1681f0
-#define QM_REG_QVOQIDX_64					 0x16e40c
-#define QM_REG_QVOQIDX_65					 0x16e410
-#define QM_REG_QVOQIDX_69					 0x16e420
-#define QM_REG_QVOQIDX_7					 0x168110
-#define QM_REG_QVOQIDX_70					 0x16e424
-#define QM_REG_QVOQIDX_71					 0x16e428
-#define QM_REG_QVOQIDX_72					 0x16e42c
-#define QM_REG_QVOQIDX_73					 0x16e430
-#define QM_REG_QVOQIDX_74					 0x16e434
-#define QM_REG_QVOQIDX_75					 0x16e438
-#define QM_REG_QVOQIDX_76					 0x16e43c
-#define QM_REG_QVOQIDX_77					 0x16e440
-#define QM_REG_QVOQIDX_78					 0x16e444
-#define QM_REG_QVOQIDX_79					 0x16e448
-#define QM_REG_QVOQIDX_8					 0x168114
-#define QM_REG_QVOQIDX_80					 0x16e44c
-#define QM_REG_QVOQIDX_81					 0x16e450
-#define QM_REG_QVOQIDX_85					 0x16e460
-#define QM_REG_QVOQIDX_86					 0x16e464
-#define QM_REG_QVOQIDX_87					 0x16e468
-#define QM_REG_QVOQIDX_88					 0x16e46c
-#define QM_REG_QVOQIDX_89					 0x16e470
-#define QM_REG_QVOQIDX_9					 0x168118
-#define QM_REG_QVOQIDX_90					 0x16e474
-#define QM_REG_QVOQIDX_91					 0x16e478
-#define QM_REG_QVOQIDX_92					 0x16e47c
-#define QM_REG_QVOQIDX_93					 0x16e480
-#define QM_REG_QVOQIDX_94					 0x16e484
-#define QM_REG_QVOQIDX_95					 0x16e488
-#define QM_REG_QVOQIDX_96					 0x16e48c
-#define QM_REG_QVOQIDX_97					 0x16e490
-#define QM_REG_QVOQIDX_98					 0x16e494
-#define QM_REG_QVOQIDX_99					 0x16e498
-/* [RW 1] Initialization bit command */
-#define QM_REG_SOFT_RESET					 0x168428
-/* [RW 8] The credit cost per every task in the QM. A value per each VOQ */
-#define QM_REG_TASKCRDCOST_0					 0x16809c
-#define QM_REG_TASKCRDCOST_1					 0x1680a0
-#define QM_REG_TASKCRDCOST_2					 0x1680a4
-#define QM_REG_TASKCRDCOST_4					 0x1680ac
-#define QM_REG_TASKCRDCOST_5					 0x1680b0
-/* [R 6] Keep the fill level of the fifo from write client 3 */
-#define QM_REG_TQM_WRC_FIFOLVL					 0x168010
-/* [R 6] Keep the fill level of the fifo from write client 2 */
-#define QM_REG_UQM_WRC_FIFOLVL					 0x168008
-/* [RC 32] Credit update error register */
-#define QM_REG_VOQCRDERRREG					 0x168408
-/* [R 16] The credit value for each VOQ */
-#define QM_REG_VOQCREDIT_0					 0x1682d0
-#define QM_REG_VOQCREDIT_1					 0x1682d4
-#define QM_REG_VOQCREDIT_4					 0x1682e0
-/* [RW 16] The credit value that if above the QM is considered almost full */
-#define QM_REG_VOQCREDITAFULLTHR				 0x168090
-/* [RW 16] The init and maximum credit for each VoQ */
-#define QM_REG_VOQINITCREDIT_0					 0x168060
-#define QM_REG_VOQINITCREDIT_1					 0x168064
-#define QM_REG_VOQINITCREDIT_2					 0x168068
-#define QM_REG_VOQINITCREDIT_4					 0x168070
-#define QM_REG_VOQINITCREDIT_5					 0x168074
-/* [RW 1] The port of which VOQ belongs */
-#define QM_REG_VOQPORT_0					 0x1682a0
-#define QM_REG_VOQPORT_1					 0x1682a4
-#define QM_REG_VOQPORT_2					 0x1682a8
-/* [RW 32] The physical queue number associated with each VOQ; queues 31-0 */
-#define QM_REG_VOQQMASK_0_LSB					 0x168240
-/* [RW 32] The physical queue number associated with each VOQ; queues 95-64 */
-#define QM_REG_VOQQMASK_0_LSB_EXT_A				 0x16e524
-/* [RW 32] The physical queue number associated with each VOQ; queues 63-32 */
-#define QM_REG_VOQQMASK_0_MSB					 0x168244
-/* [RW 32] The physical queue number associated with each VOQ; queues 127-96 */
-#define QM_REG_VOQQMASK_0_MSB_EXT_A				 0x16e528
-/* [RW 32] The physical queue number associated with each VOQ; queues 31-0 */
-#define QM_REG_VOQQMASK_10_LSB					 0x168290
-/* [RW 32] The physical queue number associated with each VOQ; queues 95-64 */
-#define QM_REG_VOQQMASK_10_LSB_EXT_A				 0x16e574
-/* [RW 32] The physical queue number associated with each VOQ; queues 63-32 */
-#define QM_REG_VOQQMASK_10_MSB					 0x168294
-/* [RW 32] The physical queue number associated with each VOQ; queues 127-96 */
-#define QM_REG_VOQQMASK_10_MSB_EXT_A				 0x16e578
-/* [RW 32] The physical queue number associated with each VOQ; queues 31-0 */
-#define QM_REG_VOQQMASK_11_LSB					 0x168298
-/* [RW 32] The physical queue number associated with each VOQ; queues 95-64 */
-#define QM_REG_VOQQMASK_11_LSB_EXT_A				 0x16e57c
-/* [RW 32] The physical queue number associated with each VOQ; queues 63-32 */
-#define QM_REG_VOQQMASK_11_MSB					 0x16829c
-/* [RW 32] The physical queue number associated with each VOQ; queues 127-96 */
-#define QM_REG_VOQQMASK_11_MSB_EXT_A				 0x16e580
-/* [RW 32] The physical queue number associated with each VOQ; queues 31-0 */
-#define QM_REG_VOQQMASK_1_LSB					 0x168248
-/* [RW 32] The physical queue number associated with each VOQ; queues 95-64 */
-#define QM_REG_VOQQMASK_1_LSB_EXT_A				 0x16e52c
-/* [RW 32] The physical queue number associated with each VOQ; queues 63-32 */
-#define QM_REG_VOQQMASK_1_MSB					 0x16824c
-/* [RW 32] The physical queue number associated with each VOQ; queues 127-96 */
-#define QM_REG_VOQQMASK_1_MSB_EXT_A				 0x16e530
-/* [RW 32] The physical queue number associated with each VOQ; queues 31-0 */
-#define QM_REG_VOQQMASK_2_LSB					 0x168250
-/* [RW 32] The physical queue number associated with each VOQ; queues 95-64 */
-#define QM_REG_VOQQMASK_2_LSB_EXT_A				 0x16e534
-/* [RW 32] The physical queue number associated with each VOQ; queues 63-32 */
-#define QM_REG_VOQQMASK_2_MSB					 0x168254
-/* [RW 32] The physical queue number associated with each VOQ; queues 127-96 */
-#define QM_REG_VOQQMASK_2_MSB_EXT_A				 0x16e538
-/* [RW 32] The physical queue number associated with each VOQ; queues 31-0 */
-#define QM_REG_VOQQMASK_3_LSB					 0x168258
-/* [RW 32] The physical queue number associated with each VOQ; queues 95-64 */
-#define QM_REG_VOQQMASK_3_LSB_EXT_A				 0x16e53c
-/* [RW 32] The physical queue number associated with each VOQ; queues 127-96 */
-#define QM_REG_VOQQMASK_3_MSB_EXT_A				 0x16e540
-/* [RW 32] The physical queue number associated with each VOQ; queues 31-0 */
-#define QM_REG_VOQQMASK_4_LSB					 0x168260
-/* [RW 32] The physical queue number associated with each VOQ; queues 95-64 */
-#define QM_REG_VOQQMASK_4_LSB_EXT_A				 0x16e544
-/* [RW 32] The physical queue number associated with each VOQ; queues 63-32 */
-#define QM_REG_VOQQMASK_4_MSB					 0x168264
-/* [RW 32] The physical queue number associated with each VOQ; queues 127-96 */
-#define QM_REG_VOQQMASK_4_MSB_EXT_A				 0x16e548
-/* [RW 32] The physical queue number associated with each VOQ; queues 31-0 */
-#define QM_REG_VOQQMASK_5_LSB					 0x168268
-/* [RW 32] The physical queue number associated with each VOQ; queues 95-64 */
-#define QM_REG_VOQQMASK_5_LSB_EXT_A				 0x16e54c
-/* [RW 32] The physical queue number associated with each VOQ; queues 63-32 */
-#define QM_REG_VOQQMASK_5_MSB					 0x16826c
-/* [RW 32] The physical queue number associated with each VOQ; queues 127-96 */
-#define QM_REG_VOQQMASK_5_MSB_EXT_A				 0x16e550
-/* [RW 32] The physical queue number associated with each VOQ; queues 31-0 */
-#define QM_REG_VOQQMASK_6_LSB					 0x168270
-/* [RW 32] The physical queue number associated with each VOQ; queues 95-64 */
-#define QM_REG_VOQQMASK_6_LSB_EXT_A				 0x16e554
-/* [RW 32] The physical queue number associated with each VOQ; queues 63-32 */
-#define QM_REG_VOQQMASK_6_MSB					 0x168274
-/* [RW 32] The physical queue number associated with each VOQ; queues 127-96 */
-#define QM_REG_VOQQMASK_6_MSB_EXT_A				 0x16e558
-/* [RW 32] The physical queue number associated with each VOQ; queues 31-0 */
-#define QM_REG_VOQQMASK_7_LSB					 0x168278
-/* [RW 32] The physical queue number associated with each VOQ; queues 95-64 */
-#define QM_REG_VOQQMASK_7_LSB_EXT_A				 0x16e55c
-/* [RW 32] The physical queue number associated with each VOQ; queues 63-32 */
-#define QM_REG_VOQQMASK_7_MSB					 0x16827c
-/* [RW 32] The physical queue number associated with each VOQ; queues 127-96 */
-#define QM_REG_VOQQMASK_7_MSB_EXT_A				 0x16e560
-/* [RW 32] The physical queue number associated with each VOQ; queues 31-0 */
-#define QM_REG_VOQQMASK_8_LSB					 0x168280
-/* [RW 32] The physical queue number associated with each VOQ; queues 95-64 */
-#define QM_REG_VOQQMASK_8_LSB_EXT_A				 0x16e564
-/* [RW 32] The physical queue number associated with each VOQ; queues 63-32 */
-#define QM_REG_VOQQMASK_8_MSB					 0x168284
-/* [RW 32] The physical queue number associated with each VOQ; queues 127-96 */
-#define QM_REG_VOQQMASK_8_MSB_EXT_A				 0x16e568
-/* [RW 32] The physical queue number associated with each VOQ; queues 31-0 */
-#define QM_REG_VOQQMASK_9_LSB					 0x168288
-/* [RW 32] The physical queue number associated with each VOQ; queues 95-64 */
-#define QM_REG_VOQQMASK_9_LSB_EXT_A				 0x16e56c
-/* [RW 32] The physical queue number associated with each VOQ; queues 127-96 */
-#define QM_REG_VOQQMASK_9_MSB_EXT_A				 0x16e570
-/* [RW 32] Wrr weights */
-#define QM_REG_WRRWEIGHTS_0					 0x16880c
-#define QM_REG_WRRWEIGHTS_1					 0x168810
-#define QM_REG_WRRWEIGHTS_10					 0x168814
-#define QM_REG_WRRWEIGHTS_11					 0x168818
-#define QM_REG_WRRWEIGHTS_12					 0x16881c
-#define QM_REG_WRRWEIGHTS_13					 0x168820
-#define QM_REG_WRRWEIGHTS_14					 0x168824
-#define QM_REG_WRRWEIGHTS_15					 0x168828
-#define QM_REG_WRRWEIGHTS_16					 0x16e000
-#define QM_REG_WRRWEIGHTS_17					 0x16e004
-#define QM_REG_WRRWEIGHTS_18					 0x16e008
-#define QM_REG_WRRWEIGHTS_19					 0x16e00c
-#define QM_REG_WRRWEIGHTS_2					 0x16882c
-#define QM_REG_WRRWEIGHTS_20					 0x16e010
-#define QM_REG_WRRWEIGHTS_21					 0x16e014
-#define QM_REG_WRRWEIGHTS_22					 0x16e018
-#define QM_REG_WRRWEIGHTS_23					 0x16e01c
-#define QM_REG_WRRWEIGHTS_24					 0x16e020
-#define QM_REG_WRRWEIGHTS_25					 0x16e024
-#define QM_REG_WRRWEIGHTS_26					 0x16e028
-#define QM_REG_WRRWEIGHTS_27					 0x16e02c
-#define QM_REG_WRRWEIGHTS_28					 0x16e030
-#define QM_REG_WRRWEIGHTS_29					 0x16e034
-#define QM_REG_WRRWEIGHTS_3					 0x168830
-#define QM_REG_WRRWEIGHTS_30					 0x16e038
-#define QM_REG_WRRWEIGHTS_31					 0x16e03c
-#define QM_REG_WRRWEIGHTS_4					 0x168834
-#define QM_REG_WRRWEIGHTS_5					 0x168838
-#define QM_REG_WRRWEIGHTS_6					 0x16883c
-#define QM_REG_WRRWEIGHTS_7					 0x168840
-#define QM_REG_WRRWEIGHTS_8					 0x168844
-#define QM_REG_WRRWEIGHTS_9					 0x168848
-/* [R 6] Keep the fill level of the fifo from write client 1 */
-#define QM_REG_XQM_WRC_FIFOLVL					 0x168000
-#define SRC_REG_COUNTFREE0					 0x40500
-/* [RW 1] If clr the searcher is compatible to E1 A0 - support only two
-   ports. If set the searcher support 8 functions. */
-#define SRC_REG_E1HMF_ENABLE					 0x404cc
-#define SRC_REG_FIRSTFREE0					 0x40510
-#define SRC_REG_KEYRSS0_0					 0x40408
-#define SRC_REG_KEYRSS0_7					 0x40424
-#define SRC_REG_KEYRSS1_9					 0x40454
-#define SRC_REG_KEYSEARCH_0					 0x40458
-#define SRC_REG_KEYSEARCH_1					 0x4045c
-#define SRC_REG_KEYSEARCH_2					 0x40460
-#define SRC_REG_KEYSEARCH_3					 0x40464
-#define SRC_REG_KEYSEARCH_4					 0x40468
-#define SRC_REG_KEYSEARCH_5					 0x4046c
-#define SRC_REG_KEYSEARCH_6					 0x40470
-#define SRC_REG_KEYSEARCH_7					 0x40474
-#define SRC_REG_KEYSEARCH_8					 0x40478
-#define SRC_REG_KEYSEARCH_9					 0x4047c
-#define SRC_REG_LASTFREE0					 0x40530
-#define SRC_REG_NUMBER_HASH_BITS0				 0x40400
-/* [RW 1] Reset internal state machines. */
-#define SRC_REG_SOFT_RST					 0x4049c
-/* [R 3] Interrupt register #0 read */
-#define SRC_REG_SRC_INT_STS					 0x404ac
-/* [RW 3] Parity mask register #0 read/write */
-#define SRC_REG_SRC_PRTY_MASK					 0x404c8
-/* [R 3] Parity register #0 read */
-#define SRC_REG_SRC_PRTY_STS					 0x404bc
-/* [R 4] Used to read the value of the XX protection CAM occupancy counter. */
-#define TCM_REG_CAM_OCCUP					 0x5017c
-/* [RW 1] CDU AG read Interface enable. If 0 - the request input is
-   disregarded; valid output is deasserted; all other signals are treated as
-   usual; if 1 - normal activity. */
-#define TCM_REG_CDU_AG_RD_IFEN					 0x50034
-/* [RW 1] CDU AG write Interface enable. If 0 - the request and valid input
-   are disregarded; all other signals are treated as usual; if 1 - normal
-   activity. */
-#define TCM_REG_CDU_AG_WR_IFEN					 0x50030
-/* [RW 1] CDU STORM read Interface enable. If 0 - the request input is
-   disregarded; valid output is deasserted; all other signals are treated as
-   usual; if 1 - normal activity. */
-#define TCM_REG_CDU_SM_RD_IFEN					 0x5003c
-/* [RW 1] CDU STORM write Interface enable. If 0 - the request and valid
-   input is disregarded; all other signals are treated as usual; if 1 -
-   normal activity. */
-#define TCM_REG_CDU_SM_WR_IFEN					 0x50038
-/* [RW 4] CFC output initial credit. Max credit available - 15.Write writes
-   the initial credit value; read returns the current value of the credit
-   counter. Must be initialized to 1 at start-up. */
-#define TCM_REG_CFC_INIT_CRD					 0x50204
-/* [RW 3] The weight of the CP input in the WRR mechanism. 0 stands for
-   weight 8 (the most prioritised); 1 stands for weight 1(least
-   prioritised); 2 stands for weight 2; tc. */
-#define TCM_REG_CP_WEIGHT					 0x500c0
-/* [RW 1] Input csem Interface enable. If 0 - the valid input is
-   disregarded; acknowledge output is deasserted; all other signals are
-   treated as usual; if 1 - normal activity. */
-#define TCM_REG_CSEM_IFEN					 0x5002c
-/* [RC 1] Message length mismatch (relative to last indication) at the In#9
-   interface. */
-#define TCM_REG_CSEM_LENGTH_MIS 				 0x50174
-/* [RW 3] The weight of the input csem in the WRR mechanism. 0 stands for
-   weight 8 (the most prioritised); 1 stands for weight 1(least
-   prioritised); 2 stands for weight 2; tc. */
-#define TCM_REG_CSEM_WEIGHT					 0x500bc
-/* [RW 8] The Event ID in case of ErrorFlg is set in the input message. */
-#define TCM_REG_ERR_EVNT_ID					 0x500a0
-/* [RW 28] The CM erroneous header for QM and Timers formatting. */
-#define TCM_REG_ERR_TCM_HDR					 0x5009c
-/* [RW 8] The Event ID for Timers expiration. */
-#define TCM_REG_EXPR_EVNT_ID					 0x500a4
-/* [RW 8] FIC0 output initial credit. Max credit available - 255.Write
-   writes the initial credit value; read returns the current value of the
-   credit counter. Must be initialized to 64 at start-up. */
-#define TCM_REG_FIC0_INIT_CRD					 0x5020c
-/* [RW 8] FIC1 output initial credit. Max credit available - 255.Write
-   writes the initial credit value; read returns the current value of the
-   credit counter. Must be initialized to 64 at start-up. */
-#define TCM_REG_FIC1_INIT_CRD					 0x50210
-/* [RW 1] Arbitration between Input Arbiter groups: 0 - fair Round-Robin; 1
-   - strict priority defined by ~tcm_registers_gr_ag_pr.gr_ag_pr;
-   ~tcm_registers_gr_ld0_pr.gr_ld0_pr and
-   ~tcm_registers_gr_ld1_pr.gr_ld1_pr. */
-#define TCM_REG_GR_ARB_TYPE					 0x50114
-/* [RW 2] Load (FIC0) channel group priority. The lowest priority is 0; the
-   highest priority is 3. It is supposed that the Store channel is the
-   compliment of the other 3 groups. */
-#define TCM_REG_GR_LD0_PR					 0x5011c
-/* [RW 2] Load (FIC1) channel group priority. The lowest priority is 0; the
-   highest priority is 3. It is supposed that the Store channel is the
-   compliment of the other 3 groups. */
-#define TCM_REG_GR_LD1_PR					 0x50120
-/* [RW 4] The number of double REG-pairs; loaded from the STORM context and
-   sent to STORM; for a specific connection type. The double REG-pairs are
-   used to align to STORM context row size of 128 bits. The offset of these
-   data in the STORM context is always 0. Index _i stands for the connection
-   type (one of 16). */
-#define TCM_REG_N_SM_CTX_LD_0					 0x50050
-#define TCM_REG_N_SM_CTX_LD_1					 0x50054
-#define TCM_REG_N_SM_CTX_LD_2					 0x50058
-#define TCM_REG_N_SM_CTX_LD_3					 0x5005c
-#define TCM_REG_N_SM_CTX_LD_4					 0x50060
-#define TCM_REG_N_SM_CTX_LD_5					 0x50064
-/* [RW 1] Input pbf Interface enable. If 0 - the valid input is disregarded;
-   acknowledge output is deasserted; all other signals are treated as usual;
-   if 1 - normal activity. */
-#define TCM_REG_PBF_IFEN					 0x50024
-/* [RC 1] Message length mismatch (relative to last indication) at the In#7
-   interface. */
-#define TCM_REG_PBF_LENGTH_MIS					 0x5016c
-/* [RW 3] The weight of the input pbf in the WRR mechanism. 0 stands for
-   weight 8 (the most prioritised); 1 stands for weight 1(least
-   prioritised); 2 stands for weight 2; tc. */
-#define TCM_REG_PBF_WEIGHT					 0x500b4
-#define TCM_REG_PHYS_QNUM0_0					 0x500e0
-#define TCM_REG_PHYS_QNUM0_1					 0x500e4
-#define TCM_REG_PHYS_QNUM1_0					 0x500e8
-#define TCM_REG_PHYS_QNUM1_1					 0x500ec
-#define TCM_REG_PHYS_QNUM2_0					 0x500f0
-#define TCM_REG_PHYS_QNUM2_1					 0x500f4
-#define TCM_REG_PHYS_QNUM3_0					 0x500f8
-#define TCM_REG_PHYS_QNUM3_1					 0x500fc
-/* [RW 1] Input prs Interface enable. If 0 - the valid input is disregarded;
-   acknowledge output is deasserted; all other signals are treated as usual;
-   if 1 - normal activity. */
-#define TCM_REG_PRS_IFEN					 0x50020
-/* [RC 1] Message length mismatch (relative to last indication) at the In#6
-   interface. */
-#define TCM_REG_PRS_LENGTH_MIS					 0x50168
-/* [RW 3] The weight of the input prs in the WRR mechanism. 0 stands for
-   weight 8 (the most prioritised); 1 stands for weight 1(least
-   prioritised); 2 stands for weight 2; tc. */
-#define TCM_REG_PRS_WEIGHT					 0x500b0
-/* [RW 8] The Event ID for Timers formatting in case of stop done. */
-#define TCM_REG_STOP_EVNT_ID					 0x500a8
-/* [RC 1] Message length mismatch (relative to last indication) at the STORM
-   interface. */
-#define TCM_REG_STORM_LENGTH_MIS				 0x50160
-/* [RW 1] STORM - CM Interface enable. If 0 - the valid input is
-   disregarded; acknowledge output is deasserted; all other signals are
-   treated as usual; if 1 - normal activity. */
-#define TCM_REG_STORM_TCM_IFEN					 0x50010
-/* [RW 3] The weight of the STORM input in the WRR mechanism. 0 stands for
-   weight 8 (the most prioritised); 1 stands for weight 1(least
-   prioritised); 2 stands for weight 2; tc. */
-#define TCM_REG_STORM_WEIGHT					 0x500ac
-/* [RW 1] CM - CFC Interface enable. If 0 - the valid input is disregarded;
-   acknowledge output is deasserted; all other signals are treated as usual;
-   if 1 - normal activity. */
-#define TCM_REG_TCM_CFC_IFEN					 0x50040
-/* [RW 11] Interrupt mask register #0 read/write */
-#define TCM_REG_TCM_INT_MASK					 0x501dc
-/* [R 11] Interrupt register #0 read */
-#define TCM_REG_TCM_INT_STS					 0x501d0
-/* [R 27] Parity register #0 read */
-#define TCM_REG_TCM_PRTY_STS					 0x501e0
-/* [RW 3] The size of AG context region 0 in REG-pairs. Designates the MS
-   REG-pair number (e.g. if region 0 is 6 REG-pairs; the value should be 5).
-   Is used to determine the number of the AG context REG-pairs written back;
-   when the input message Reg1WbFlg isn't set. */
-#define TCM_REG_TCM_REG0_SZ					 0x500d8
-/* [RW 1] CM - STORM 0 Interface enable. If 0 - the acknowledge input is
-   disregarded; valid is deasserted; all other signals are treated as usual;
-   if 1 - normal activity. */
-#define TCM_REG_TCM_STORM0_IFEN 				 0x50004
-/* [RW 1] CM - STORM 1 Interface enable. If 0 - the acknowledge input is
-   disregarded; valid is deasserted; all other signals are treated as usual;
-   if 1 - normal activity. */
-#define TCM_REG_TCM_STORM1_IFEN 				 0x50008
-/* [RW 1] CM - QM Interface enable. If 0 - the acknowledge input is
-   disregarded; valid is deasserted; all other signals are treated as usual;
-   if 1 - normal activity. */
-#define TCM_REG_TCM_TQM_IFEN					 0x5000c
-/* [RW 1] If set the Q index; received from the QM is inserted to event ID. */
-#define TCM_REG_TCM_TQM_USE_Q					 0x500d4
-/* [RW 28] The CM header for Timers expiration command. */
-#define TCM_REG_TM_TCM_HDR					 0x50098
-/* [RW 1] Timers - CM Interface enable. If 0 - the valid input is
-   disregarded; acknowledge output is deasserted; all other signals are
-   treated as usual; if 1 - normal activity. */
-#define TCM_REG_TM_TCM_IFEN					 0x5001c
-/* [RW 3] The weight of the Timers input in the WRR mechanism. 0 stands for
-   weight 8 (the most prioritised); 1 stands for weight 1(least
-   prioritised); 2 stands for weight 2; tc. */
-#define TCM_REG_TM_WEIGHT					 0x500d0
-/* [RW 6] QM output initial credit. Max credit available - 32.Write writes
-   the initial credit value; read returns the current value of the credit
-   counter. Must be initialized to 32 at start-up. */
-#define TCM_REG_TQM_INIT_CRD					 0x5021c
-/* [RW 3] The weight of the QM (primary) input in the WRR mechanism. 0
-   stands for weight 8 (the most prioritised); 1 stands for weight 1(least
-   prioritised); 2 stands for weight 2; tc. */
-#define TCM_REG_TQM_P_WEIGHT					 0x500c8
-/* [RW 3] The weight of the QM (secondary) input in the WRR mechanism. 0
-   stands for weight 8 (the most prioritised); 1 stands for weight 1(least
-   prioritised); 2 stands for weight 2; tc. */
-#define TCM_REG_TQM_S_WEIGHT					 0x500cc
-/* [RW 28] The CM header value for QM request (primary). */
-#define TCM_REG_TQM_TCM_HDR_P					 0x50090
-/* [RW 28] The CM header value for QM request (secondary). */
-#define TCM_REG_TQM_TCM_HDR_S					 0x50094
-/* [RW 1] QM - CM Interface enable. If 0 - the valid input is disregarded;
-   acknowledge output is deasserted; all other signals are treated as usual;
-   if 1 - normal activity. */
-#define TCM_REG_TQM_TCM_IFEN					 0x50014
-/* [RW 1] Input SDM Interface enable. If 0 - the valid input is disregarded;
-   acknowledge output is deasserted; all other signals are treated as usual;
-   if 1 - normal activity. */
-#define TCM_REG_TSDM_IFEN					 0x50018
-/* [RC 1] Message length mismatch (relative to last indication) at the SDM
-   interface. */
-#define TCM_REG_TSDM_LENGTH_MIS 				 0x50164
-/* [RW 3] The weight of the SDM input in the WRR mechanism. 0 stands for
-   weight 8 (the most prioritised); 1 stands for weight 1(least
-   prioritised); 2 stands for weight 2; tc. */
-#define TCM_REG_TSDM_WEIGHT					 0x500c4
-/* [RW 1] Input usem Interface enable. If 0 - the valid input is
-   disregarded; acknowledge output is deasserted; all other signals are
-   treated as usual; if 1 - normal activity. */
-#define TCM_REG_USEM_IFEN					 0x50028
-/* [RC 1] Message length mismatch (relative to last indication) at the In#8
-   interface. */
-#define TCM_REG_USEM_LENGTH_MIS 				 0x50170
-/* [RW 3] The weight of the input usem in the WRR mechanism. 0 stands for
-   weight 8 (the most prioritised); 1 stands for weight 1(least
-   prioritised); 2 stands for weight 2; tc. */
-#define TCM_REG_USEM_WEIGHT					 0x500b8
-/* [RW 21] Indirect access to the descriptor table of the XX protection
-   mechanism. The fields are: [5:0] - length of the message; 15:6] - message
-   pointer; 20:16] - next pointer. */
-#define TCM_REG_XX_DESCR_TABLE					 0x50280
-#define TCM_REG_XX_DESCR_TABLE_SIZE				 32
-/* [R 6] Use to read the value of XX protection Free counter. */
-#define TCM_REG_XX_FREE 					 0x50178
-/* [RW 6] Initial value for the credit counter; responsible for fulfilling
-   of the Input Stage XX protection buffer by the XX protection pending
-   messages. Max credit available - 127.Write writes the initial credit
-   value; read returns the current value of the credit counter. Must be
-   initialized to 19 at start-up. */
-#define TCM_REG_XX_INIT_CRD					 0x50220
-/* [RW 6] Maximum link list size (messages locked) per connection in the XX
-   protection. */
-#define TCM_REG_XX_MAX_LL_SZ					 0x50044
-/* [RW 6] The maximum number of pending messages; which may be stored in XX
-   protection. ~tcm_registers_xx_free.xx_free is read on read. */
-#define TCM_REG_XX_MSG_NUM					 0x50224
-/* [RW 8] The Event ID; sent to the STORM in case of XX overflow. */
-#define TCM_REG_XX_OVFL_EVNT_ID 				 0x50048
-/* [RW 16] Indirect access to the XX table of the XX protection mechanism.
-   The fields are:[4:0] - tail pointer; [10:5] - Link List size; 15:11] -
-   header pointer. */
-#define TCM_REG_XX_TABLE					 0x50240
-/* [RW 4] Load value for cfc ac credit cnt. */
-#define TM_REG_CFC_AC_CRDCNT_VAL				 0x164208
-/* [RW 4] Load value for cfc cld credit cnt. */
-#define TM_REG_CFC_CLD_CRDCNT_VAL				 0x164210
-/* [RW 8] Client0 context region. */
-#define TM_REG_CL0_CONT_REGION					 0x164030
-/* [RW 8] Client1 context region. */
-#define TM_REG_CL1_CONT_REGION					 0x164034
-/* [RW 8] Client2 context region. */
-#define TM_REG_CL2_CONT_REGION					 0x164038
-/* [RW 2] Client in High priority client number. */
-#define TM_REG_CLIN_PRIOR0_CLIENT				 0x164024
-/* [RW 4] Load value for clout0 cred cnt. */
-#define TM_REG_CLOUT_CRDCNT0_VAL				 0x164220
-/* [RW 4] Load value for clout1 cred cnt. */
-#define TM_REG_CLOUT_CRDCNT1_VAL				 0x164228
-/* [RW 4] Load value for clout2 cred cnt. */
-#define TM_REG_CLOUT_CRDCNT2_VAL				 0x164230
-/* [RW 1] Enable client0 input. */
-#define TM_REG_EN_CL0_INPUT					 0x164008
-/* [RW 1] Enable client1 input. */
-#define TM_REG_EN_CL1_INPUT					 0x16400c
-/* [RW 1] Enable client2 input. */
-#define TM_REG_EN_CL2_INPUT					 0x164010
-#define TM_REG_EN_LINEAR0_TIMER 				 0x164014
-/* [RW 1] Enable real time counter. */
-#define TM_REG_EN_REAL_TIME_CNT 				 0x1640d8
-/* [RW 1] Enable for Timers state machines. */
-#define TM_REG_EN_TIMERS					 0x164000
-/* [RW 4] Load value for expiration credit cnt. CFC max number of
-   outstanding load requests for timers (expiration) context loading. */
-#define TM_REG_EXP_CRDCNT_VAL					 0x164238
-/* [RW 32] Linear0 logic address. */
-#define TM_REG_LIN0_LOGIC_ADDR					 0x164240
-/* [RW 18] Linear0 Max active cid (in banks of 32 entries). */
-#define TM_REG_LIN0_MAX_ACTIVE_CID				 0x164048
-/* [WB 64] Linear0 phy address. */
-#define TM_REG_LIN0_PHY_ADDR					 0x164270
-/* [RW 1] Linear0 physical address valid. */
-#define TM_REG_LIN0_PHY_ADDR_VALID				 0x164248
-#define TM_REG_LIN0_SCAN_ON					 0x1640d0
-/* [RW 24] Linear0 array scan timeout. */
-#define TM_REG_LIN0_SCAN_TIME					 0x16403c
-/* [RW 32] Linear1 logic address. */
-#define TM_REG_LIN1_LOGIC_ADDR					 0x164250
-/* [WB 64] Linear1 phy address. */
-#define TM_REG_LIN1_PHY_ADDR					 0x164280
-/* [RW 1] Linear1 physical address valid. */
-#define TM_REG_LIN1_PHY_ADDR_VALID				 0x164258
-/* [RW 6] Linear timer set_clear fifo threshold. */
-#define TM_REG_LIN_SETCLR_FIFO_ALFULL_THR			 0x164070
-/* [RW 2] Load value for pci arbiter credit cnt. */
-#define TM_REG_PCIARB_CRDCNT_VAL				 0x164260
-/* [RW 20] The amount of hardware cycles for each timer tick. */
-#define TM_REG_TIMER_TICK_SIZE					 0x16401c
-/* [RW 8] Timers Context region. */
-#define TM_REG_TM_CONTEXT_REGION				 0x164044
-/* [RW 1] Interrupt mask register #0 read/write */
-#define TM_REG_TM_INT_MASK					 0x1640fc
-/* [R 1] Interrupt register #0 read */
-#define TM_REG_TM_INT_STS					 0x1640f0
-/* [RW 8] The event id for aggregated interrupt 0 */
-#define TSDM_REG_AGG_INT_EVENT_0				 0x42038
-#define TSDM_REG_AGG_INT_EVENT_1				 0x4203c
-#define TSDM_REG_AGG_INT_EVENT_2				 0x42040
-#define TSDM_REG_AGG_INT_EVENT_3				 0x42044
-#define TSDM_REG_AGG_INT_EVENT_4				 0x42048
-/* [RW 1] The T bit for aggregated interrupt 0 */
-#define TSDM_REG_AGG_INT_T_0					 0x420b8
-#define TSDM_REG_AGG_INT_T_1					 0x420bc
-/* [RW 13] The start address in the internal RAM for the cfc_rsp lcid */
-#define TSDM_REG_CFC_RSP_START_ADDR				 0x42008
-/* [RW 16] The maximum value of the competion counter #0 */
-#define TSDM_REG_CMP_COUNTER_MAX0				 0x4201c
-/* [RW 16] The maximum value of the competion counter #1 */
-#define TSDM_REG_CMP_COUNTER_MAX1				 0x42020
-/* [RW 16] The maximum value of the competion counter #2 */
-#define TSDM_REG_CMP_COUNTER_MAX2				 0x42024
-/* [RW 16] The maximum value of the competion counter #3 */
-#define TSDM_REG_CMP_COUNTER_MAX3				 0x42028
-/* [RW 13] The start address in the internal RAM for the completion
-   counters. */
-#define TSDM_REG_CMP_COUNTER_START_ADDR 			 0x4200c
-#define TSDM_REG_ENABLE_IN1					 0x42238
-#define TSDM_REG_ENABLE_IN2					 0x4223c
-#define TSDM_REG_ENABLE_OUT1					 0x42240
-#define TSDM_REG_ENABLE_OUT2					 0x42244
-/* [RW 4] The initial number of messages that can be sent to the pxp control
-   interface without receiving any ACK. */
-#define TSDM_REG_INIT_CREDIT_PXP_CTRL				 0x424bc
-/* [ST 32] The number of ACK after placement messages received */
-#define TSDM_REG_NUM_OF_ACK_AFTER_PLACE 			 0x4227c
-/* [ST 32] The number of packet end messages received from the parser */
-#define TSDM_REG_NUM_OF_PKT_END_MSG				 0x42274
-/* [ST 32] The number of requests received from the pxp async if */
-#define TSDM_REG_NUM_OF_PXP_ASYNC_REQ				 0x42278
-/* [ST 32] The number of commands received in queue 0 */
-#define TSDM_REG_NUM_OF_Q0_CMD					 0x42248
-/* [ST 32] The number of commands received in queue 10 */
-#define TSDM_REG_NUM_OF_Q10_CMD 				 0x4226c
-/* [ST 32] The number of commands received in queue 11 */
-#define TSDM_REG_NUM_OF_Q11_CMD 				 0x42270
-/* [ST 32] The number of commands received in queue 1 */
-#define TSDM_REG_NUM_OF_Q1_CMD					 0x4224c
-/* [ST 32] The number of commands received in queue 3 */
-#define TSDM_REG_NUM_OF_Q3_CMD					 0x42250
-/* [ST 32] The number of commands received in queue 4 */
-#define TSDM_REG_NUM_OF_Q4_CMD					 0x42254
-/* [ST 32] The number of commands received in queue 5 */
-#define TSDM_REG_NUM_OF_Q5_CMD					 0x42258
-/* [ST 32] The number of commands received in queue 6 */
-#define TSDM_REG_NUM_OF_Q6_CMD					 0x4225c
-/* [ST 32] The number of commands received in queue 7 */
-#define TSDM_REG_NUM_OF_Q7_CMD					 0x42260
-/* [ST 32] The number of commands received in queue 8 */
-#define TSDM_REG_NUM_OF_Q8_CMD					 0x42264
-/* [ST 32] The number of commands received in queue 9 */
-#define TSDM_REG_NUM_OF_Q9_CMD					 0x42268
-/* [RW 13] The start address in the internal RAM for the packet end message */
-#define TSDM_REG_PCK_END_MSG_START_ADDR 			 0x42014
-/* [RW 13] The start address in the internal RAM for queue counters */
-#define TSDM_REG_Q_COUNTER_START_ADDR				 0x42010
-/* [R 1] pxp_ctrl rd_data fifo empty in sdm_dma_rsp block */
-#define TSDM_REG_RSP_PXP_CTRL_RDATA_EMPTY			 0x42548
-/* [R 1] parser fifo empty in sdm_sync block */
-#define TSDM_REG_SYNC_PARSER_EMPTY				 0x42550
-/* [R 1] parser serial fifo empty in sdm_sync block */
-#define TSDM_REG_SYNC_SYNC_EMPTY				 0x42558
-/* [RW 32] Tick for timer counter. Applicable only when
-   ~tsdm_registers_timer_tick_enable.timer_tick_enable =1 */
-#define TSDM_REG_TIMER_TICK					 0x42000
-/* [RW 32] Interrupt mask register #0 read/write */
-#define TSDM_REG_TSDM_INT_MASK_0				 0x4229c
-#define TSDM_REG_TSDM_INT_MASK_1				 0x422ac
-/* [R 32] Interrupt register #0 read */
-#define TSDM_REG_TSDM_INT_STS_0 				 0x42290
-#define TSDM_REG_TSDM_INT_STS_1 				 0x422a0
-/* [RW 11] Parity mask register #0 read/write */
-#define TSDM_REG_TSDM_PRTY_MASK 				 0x422bc
-/* [R 11] Parity register #0 read */
-#define TSDM_REG_TSDM_PRTY_STS					 0x422b0
-/* [RW 5] The number of time_slots in the arbitration cycle */
-#define TSEM_REG_ARB_CYCLE_SIZE 				 0x180034
-/* [RW 3] The source that is associated with arbitration element 0. Source
-   decoding is: 0- foc0; 1-fic1; 2-sleeping thread with priority 0; 3-
-   sleeping thread with priority 1; 4- sleeping thread with priority 2 */
-#define TSEM_REG_ARB_ELEMENT0					 0x180020
-/* [RW 3] The source that is associated with arbitration element 1. Source
-   decoding is: 0- foc0; 1-fic1; 2-sleeping thread with priority 0; 3-
-   sleeping thread with priority 1; 4- sleeping thread with priority 2.
-   Could not be equal to register ~tsem_registers_arb_element0.arb_element0 */
-#define TSEM_REG_ARB_ELEMENT1					 0x180024
-/* [RW 3] The source that is associated with arbitration element 2. Source
-   decoding is: 0- foc0; 1-fic1; 2-sleeping thread with priority 0; 3-
-   sleeping thread with priority 1; 4- sleeping thread with priority 2.
-   Could not be equal to register ~tsem_registers_arb_element0.arb_element0
-   and ~tsem_registers_arb_element1.arb_element1 */
-#define TSEM_REG_ARB_ELEMENT2					 0x180028
-/* [RW 3] The source that is associated with arbitration element 3. Source
-   decoding is: 0- foc0; 1-fic1; 2-sleeping thread with priority 0; 3-
-   sleeping thread with priority 1; 4- sleeping thread with priority 2.Could
-   not be equal to register ~tsem_registers_arb_element0.arb_element0 and
-   ~tsem_registers_arb_element1.arb_element1 and
-   ~tsem_registers_arb_element2.arb_element2 */
-#define TSEM_REG_ARB_ELEMENT3					 0x18002c
-/* [RW 3] The source that is associated with arbitration element 4. Source
-   decoding is: 0- foc0; 1-fic1; 2-sleeping thread with priority 0; 3-
-   sleeping thread with priority 1; 4- sleeping thread with priority 2.
-   Could not be equal to register ~tsem_registers_arb_element0.arb_element0
-   and ~tsem_registers_arb_element1.arb_element1 and
-   ~tsem_registers_arb_element2.arb_element2 and
-   ~tsem_registers_arb_element3.arb_element3 */
-#define TSEM_REG_ARB_ELEMENT4					 0x180030
-#define TSEM_REG_ENABLE_IN					 0x1800a4
-#define TSEM_REG_ENABLE_OUT					 0x1800a8
-/* [RW 32] This address space contains all registers and memories that are
-   placed in SEM_FAST block. The SEM_FAST registers are described in
-   appendix B. In order to access the sem_fast registers the base address
-   ~fast_memory.fast_memory should be added to eachsem_fast register offset. */
-#define TSEM_REG_FAST_MEMORY					 0x1a0000
-/* [RW 1] Disables input messages from FIC0 May be updated during run_time
-   by the microcode */
-#define TSEM_REG_FIC0_DISABLE					 0x180224
-/* [RW 1] Disables input messages from FIC1 May be updated during run_time
-   by the microcode */
-#define TSEM_REG_FIC1_DISABLE					 0x180234
-/* [RW 15] Interrupt table Read and write access to it is not possible in
-   the middle of the work */
-#define TSEM_REG_INT_TABLE					 0x180400
-/* [ST 24] Statistics register. The number of messages that entered through
-   FIC0 */
-#define TSEM_REG_MSG_NUM_FIC0					 0x180000
-/* [ST 24] Statistics register. The number of messages that entered through
-   FIC1 */
-#define TSEM_REG_MSG_NUM_FIC1					 0x180004
-/* [ST 24] Statistics register. The number of messages that were sent to
-   FOC0 */
-#define TSEM_REG_MSG_NUM_FOC0					 0x180008
-/* [ST 24] Statistics register. The number of messages that were sent to
-   FOC1 */
-#define TSEM_REG_MSG_NUM_FOC1					 0x18000c
-/* [ST 24] Statistics register. The number of messages that were sent to
-   FOC2 */
-#define TSEM_REG_MSG_NUM_FOC2					 0x180010
-/* [ST 24] Statistics register. The number of messages that were sent to
-   FOC3 */
-#define TSEM_REG_MSG_NUM_FOC3					 0x180014
-/* [RW 1] Disables input messages from the passive buffer May be updated
-   during run_time by the microcode */
-#define TSEM_REG_PAS_DISABLE					 0x18024c
-/* [WB 128] Debug only. Passive buffer memory */
-#define TSEM_REG_PASSIVE_BUFFER 				 0x181000
-/* [WB 46] pram memory. B45 is parity; b[44:0] - data. */
-#define TSEM_REG_PRAM						 0x1c0000
-/* [R 8] Valid sleeping threads indication have bit per thread */
-#define TSEM_REG_SLEEP_THREADS_VALID				 0x18026c
-/* [R 1] EXT_STORE FIFO is empty in sem_slow_ls_ext */
-#define TSEM_REG_SLOW_EXT_STORE_EMPTY				 0x1802a0
-/* [RW 8] List of free threads . There is a bit per thread. */
-#define TSEM_REG_THREADS_LIST					 0x1802e4
-/* [RW 3] The arbitration scheme of time_slot 0 */
-#define TSEM_REG_TS_0_AS					 0x180038
-/* [RW 3] The arbitration scheme of time_slot 10 */
-#define TSEM_REG_TS_10_AS					 0x180060
-/* [RW 3] The arbitration scheme of time_slot 11 */
-#define TSEM_REG_TS_11_AS					 0x180064
-/* [RW 3] The arbitration scheme of time_slot 12 */
-#define TSEM_REG_TS_12_AS					 0x180068
-/* [RW 3] The arbitration scheme of time_slot 13 */
-#define TSEM_REG_TS_13_AS					 0x18006c
-/* [RW 3] The arbitration scheme of time_slot 14 */
-#define TSEM_REG_TS_14_AS					 0x180070
-/* [RW 3] The arbitration scheme of time_slot 15 */
-#define TSEM_REG_TS_15_AS					 0x180074
-/* [RW 3] The arbitration scheme of time_slot 16 */
-#define TSEM_REG_TS_16_AS					 0x180078
-/* [RW 3] The arbitration scheme of time_slot 17 */
-#define TSEM_REG_TS_17_AS					 0x18007c
-/* [RW 3] The arbitration scheme of time_slot 18 */
-#define TSEM_REG_TS_18_AS					 0x180080
-/* [RW 3] The arbitration scheme of time_slot 1 */
-#define TSEM_REG_TS_1_AS					 0x18003c
-/* [RW 3] The arbitration scheme of time_slot 2 */
-#define TSEM_REG_TS_2_AS					 0x180040
-/* [RW 3] The arbitration scheme of time_slot 3 */
-#define TSEM_REG_TS_3_AS					 0x180044
-/* [RW 3] The arbitration scheme of time_slot 4 */
-#define TSEM_REG_TS_4_AS					 0x180048
-/* [RW 3] The arbitration scheme of time_slot 5 */
-#define TSEM_REG_TS_5_AS					 0x18004c
-/* [RW 3] The arbitration scheme of time_slot 6 */
-#define TSEM_REG_TS_6_AS					 0x180050
-/* [RW 3] The arbitration scheme of time_slot 7 */
-#define TSEM_REG_TS_7_AS					 0x180054
-/* [RW 3] The arbitration scheme of time_slot 8 */
-#define TSEM_REG_TS_8_AS					 0x180058
-/* [RW 3] The arbitration scheme of time_slot 9 */
-#define TSEM_REG_TS_9_AS					 0x18005c
-/* [RW 32] Interrupt mask register #0 read/write */
-#define TSEM_REG_TSEM_INT_MASK_0				 0x180100
-#define TSEM_REG_TSEM_INT_MASK_1				 0x180110
-/* [R 32] Interrupt register #0 read */
-#define TSEM_REG_TSEM_INT_STS_0 				 0x1800f4
-#define TSEM_REG_TSEM_INT_STS_1 				 0x180104
-/* [RW 32] Parity mask register #0 read/write */
-#define TSEM_REG_TSEM_PRTY_MASK_0				 0x180120
-#define TSEM_REG_TSEM_PRTY_MASK_1				 0x180130
-/* [R 32] Parity register #0 read */
-#define TSEM_REG_TSEM_PRTY_STS_0				 0x180114
-#define TSEM_REG_TSEM_PRTY_STS_1				 0x180124
-/* [R 5] Used to read the XX protection CAM occupancy counter. */
-#define UCM_REG_CAM_OCCUP					 0xe0170
-/* [RW 1] CDU AG read Interface enable. If 0 - the request input is
-   disregarded; valid output is deasserted; all other signals are treated as
-   usual; if 1 - normal activity. */
-#define UCM_REG_CDU_AG_RD_IFEN					 0xe0038
-/* [RW 1] CDU AG write Interface enable. If 0 - the request and valid input
-   are disregarded; all other signals are treated as usual; if 1 - normal
-   activity. */
-#define UCM_REG_CDU_AG_WR_IFEN					 0xe0034
-/* [RW 1] CDU STORM read Interface enable. If 0 - the request input is
-   disregarded; valid output is deasserted; all other signals are treated as
-   usual; if 1 - normal activity. */
-#define UCM_REG_CDU_SM_RD_IFEN					 0xe0040
-/* [RW 1] CDU STORM write Interface enable. If 0 - the request and valid
-   input is disregarded; all other signals are treated as usual; if 1 -
-   normal activity. */
-#define UCM_REG_CDU_SM_WR_IFEN					 0xe003c
-/* [RW 4] CFC output initial credit. Max credit available - 15.Write writes
-   the initial credit value; read returns the current value of the credit
-   counter. Must be initialized to 1 at start-up. */
-#define UCM_REG_CFC_INIT_CRD					 0xe0204
-/* [RW 3] The weight of the CP input in the WRR mechanism. 0 stands for
-   weight 8 (the most prioritised); 1 stands for weight 1(least
-   prioritised); 2 stands for weight 2; tc. */
-#define UCM_REG_CP_WEIGHT					 0xe00c4
-/* [RW 1] Input csem Interface enable. If 0 - the valid input is
-   disregarded; acknowledge output is deasserted; all other signals are
-   treated as usual; if 1 - normal activity. */
-#define UCM_REG_CSEM_IFEN					 0xe0028
-/* [RC 1] Set when the message length mismatch (relative to last indication)
-   at the csem interface is detected. */
-#define UCM_REG_CSEM_LENGTH_MIS 				 0xe0160
-/* [RW 3] The weight of the input csem in the WRR mechanism. 0 stands for
-   weight 8 (the most prioritised); 1 stands for weight 1(least
-   prioritised); 2 stands for weight 2; tc. */
-#define UCM_REG_CSEM_WEIGHT					 0xe00b8
-/* [RW 1] Input dorq Interface enable. If 0 - the valid input is
-   disregarded; acknowledge output is deasserted; all other signals are
-   treated as usual; if 1 - normal activity. */
-#define UCM_REG_DORQ_IFEN					 0xe0030
-/* [RC 1] Set when the message length mismatch (relative to last indication)
-   at the dorq interface is detected. */
-#define UCM_REG_DORQ_LENGTH_MIS 				 0xe0168
-/* [RW 3] The weight of the input dorq in the WRR mechanism. 0 stands for
-   weight 8 (the most prioritised); 1 stands for weight 1(least
-   prioritised); 2 stands for weight 2; tc. */
-#define UCM_REG_DORQ_WEIGHT					 0xe00c0
-/* [RW 8] The Event ID in case ErrorFlg input message bit is set. */
-#define UCM_REG_ERR_EVNT_ID					 0xe00a4
-/* [RW 28] The CM erroneous header for QM and Timers formatting. */
-#define UCM_REG_ERR_UCM_HDR					 0xe00a0
-/* [RW 8] The Event ID for Timers expiration. */
-#define UCM_REG_EXPR_EVNT_ID					 0xe00a8
-/* [RW 8] FIC0 output initial credit. Max credit available - 255.Write
-   writes the initial credit value; read returns the current value of the
-   credit counter. Must be initialized to 64 at start-up. */
-#define UCM_REG_FIC0_INIT_CRD					 0xe020c
-/* [RW 8] FIC1 output initial credit. Max credit available - 255.Write
-   writes the initial credit value; read returns the current value of the
-   credit counter. Must be initialized to 64 at start-up. */
-#define UCM_REG_FIC1_INIT_CRD					 0xe0210
-/* [RW 1] Arbitration between Input Arbiter groups: 0 - fair Round-Robin; 1
-   - strict priority defined by ~ucm_registers_gr_ag_pr.gr_ag_pr;
-   ~ucm_registers_gr_ld0_pr.gr_ld0_pr and
-   ~ucm_registers_gr_ld1_pr.gr_ld1_pr. */
-#define UCM_REG_GR_ARB_TYPE					 0xe0144
-/* [RW 2] Load (FIC0) channel group priority. The lowest priority is 0; the
-   highest priority is 3. It is supposed that the Store channel group is
-   compliment to the others. */
-#define UCM_REG_GR_LD0_PR					 0xe014c
-/* [RW 2] Load (FIC1) channel group priority. The lowest priority is 0; the
-   highest priority is 3. It is supposed that the Store channel group is
-   compliment to the others. */
-#define UCM_REG_GR_LD1_PR					 0xe0150
-/* [RW 2] The queue index for invalidate counter flag decision. */
-#define UCM_REG_INV_CFLG_Q					 0xe00e4
-/* [RW 5] The number of double REG-pairs; loaded from the STORM context and
-   sent to STORM; for a specific connection type. the double REG-pairs are
-   used in order to align to STORM context row size of 128 bits. The offset
-   of these data in the STORM context is always 0. Index _i stands for the
-   connection type (one of 16). */
-#define UCM_REG_N_SM_CTX_LD_0					 0xe0054
-#define UCM_REG_N_SM_CTX_LD_1					 0xe0058
-#define UCM_REG_N_SM_CTX_LD_2					 0xe005c
-#define UCM_REG_N_SM_CTX_LD_3					 0xe0060
-#define UCM_REG_N_SM_CTX_LD_4					 0xe0064
-#define UCM_REG_N_SM_CTX_LD_5					 0xe0068
-#define UCM_REG_PHYS_QNUM0_0					 0xe0110
-#define UCM_REG_PHYS_QNUM0_1					 0xe0114
-#define UCM_REG_PHYS_QNUM1_0					 0xe0118
-#define UCM_REG_PHYS_QNUM1_1					 0xe011c
-#define UCM_REG_PHYS_QNUM2_0					 0xe0120
-#define UCM_REG_PHYS_QNUM2_1					 0xe0124
-#define UCM_REG_PHYS_QNUM3_0					 0xe0128
-#define UCM_REG_PHYS_QNUM3_1					 0xe012c
-/* [RW 8] The Event ID for Timers formatting in case of stop done. */
-#define UCM_REG_STOP_EVNT_ID					 0xe00ac
-/* [RC 1] Set when the message length mismatch (relative to last indication)
-   at the STORM interface is detected. */
-#define UCM_REG_STORM_LENGTH_MIS				 0xe0154
-/* [RW 1] STORM - CM Interface enable. If 0 - the valid input is
-   disregarded; acknowledge output is deasserted; all other signals are
-   treated as usual; if 1 - normal activity. */
-#define UCM_REG_STORM_UCM_IFEN					 0xe0010
-/* [RW 3] The weight of the STORM input in the WRR mechanism. 0 stands for
-   weight 8 (the most prioritised); 1 stands for weight 1(least
-   prioritised); 2 stands for weight 2; tc. */
-#define UCM_REG_STORM_WEIGHT					 0xe00b0
-/* [RW 4] Timers output initial credit. Max credit available - 15.Write
-   writes the initial credit value; read returns the current value of the
-   credit counter. Must be initialized to 4 at start-up. */
-#define UCM_REG_TM_INIT_CRD					 0xe021c
-/* [RW 28] The CM header for Timers expiration command. */
-#define UCM_REG_TM_UCM_HDR					 0xe009c
-/* [RW 1] Timers - CM Interface enable. If 0 - the valid input is
-   disregarded; acknowledge output is deasserted; all other signals are
-   treated as usual; if 1 - normal activity. */
-#define UCM_REG_TM_UCM_IFEN					 0xe001c
-/* [RW 3] The weight of the Timers input in the WRR mechanism. 0 stands for
-   weight 8 (the most prioritised); 1 stands for weight 1(least
-   prioritised); 2 stands for weight 2; tc. */
-#define UCM_REG_TM_WEIGHT					 0xe00d4
-/* [RW 1] Input tsem Interface enable. If 0 - the valid input is
-   disregarded; acknowledge output is deasserted; all other signals are
-   treated as usual; if 1 - normal activity. */
-#define UCM_REG_TSEM_IFEN					 0xe0024
-/* [RC 1] Set when the message length mismatch (relative to last indication)
-   at the tsem interface is detected. */
-#define UCM_REG_TSEM_LENGTH_MIS 				 0xe015c
-/* [RW 3] The weight of the input tsem in the WRR mechanism. 0 stands for
-   weight 8 (the most prioritised); 1 stands for weight 1(least
-   prioritised); 2 stands for weight 2; tc. */
-#define UCM_REG_TSEM_WEIGHT					 0xe00b4
-/* [RW 1] CM - CFC Interface enable. If 0 - the valid input is disregarded;
-   acknowledge output is deasserted; all other signals are treated as usual;
-   if 1 - normal activity. */
-#define UCM_REG_UCM_CFC_IFEN					 0xe0044
-/* [RW 11] Interrupt mask register #0 read/write */
-#define UCM_REG_UCM_INT_MASK					 0xe01d4
-/* [R 11] Interrupt register #0 read */
-#define UCM_REG_UCM_INT_STS					 0xe01c8
-/* [R 27] Parity register #0 read */
-#define UCM_REG_UCM_PRTY_STS					 0xe01d8
-/* [RW 2] The size of AG context region 0 in REG-pairs. Designates the MS
-   REG-pair number (e.g. if region 0 is 6 REG-pairs; the value should be 5).
-   Is used to determine the number of the AG context REG-pairs written back;
-   when the Reg1WbFlg isn't set. */
-#define UCM_REG_UCM_REG0_SZ					 0xe00dc
-/* [RW 1] CM - STORM 0 Interface enable. If 0 - the acknowledge input is
-   disregarded; valid is deasserted; all other signals are treated as usual;
-   if 1 - normal activity. */
-#define UCM_REG_UCM_STORM0_IFEN 				 0xe0004
-/* [RW 1] CM - STORM 1 Interface enable. If 0 - the acknowledge input is
-   disregarded; valid is deasserted; all other signals are treated as usual;
-   if 1 - normal activity. */
-#define UCM_REG_UCM_STORM1_IFEN 				 0xe0008
-/* [RW 1] CM - Timers Interface enable. If 0 - the valid input is
-   disregarded; acknowledge output is deasserted; all other signals are
-   treated as usual; if 1 - normal activity. */
-#define UCM_REG_UCM_TM_IFEN					 0xe0020
-/* [RW 1] CM - QM Interface enable. If 0 - the acknowledge input is
-   disregarded; valid is deasserted; all other signals are treated as usual;
-   if 1 - normal activity. */
-#define UCM_REG_UCM_UQM_IFEN					 0xe000c
-/* [RW 1] If set the Q index; received from the QM is inserted to event ID. */
-#define UCM_REG_UCM_UQM_USE_Q					 0xe00d8
-/* [RW 6] QM output initial credit. Max credit available - 32.Write writes
-   the initial credit value; read returns the current value of the credit
-   counter. Must be initialized to 32 at start-up. */
-#define UCM_REG_UQM_INIT_CRD					 0xe0220
-/* [RW 3] The weight of the QM (primary) input in the WRR mechanism. 0
-   stands for weight 8 (the most prioritised); 1 stands for weight 1(least
-   prioritised); 2 stands for weight 2; tc. */
-#define UCM_REG_UQM_P_WEIGHT					 0xe00cc
-/* [RW 3] The weight of the QM (secondary) input in the WRR mechanism. 0
-   stands for weight 8 (the most prioritised); 1 stands for weight 1(least
-   prioritised); 2 stands for weight 2; tc. */
-#define UCM_REG_UQM_S_WEIGHT					 0xe00d0
-/* [RW 28] The CM header value for QM request (primary). */
-#define UCM_REG_UQM_UCM_HDR_P					 0xe0094
-/* [RW 28] The CM header value for QM request (secondary). */
-#define UCM_REG_UQM_UCM_HDR_S					 0xe0098
-/* [RW 1] QM - CM Interface enable. If 0 - the valid input is disregarded;
-   acknowledge output is deasserted; all other signals are treated as usual;
-   if 1 - normal activity. */
-#define UCM_REG_UQM_UCM_IFEN					 0xe0014
-/* [RW 1] Input SDM Interface enable. If 0 - the valid input is disregarded;
-   acknowledge output is deasserted; all other signals are treated as usual;
-   if 1 - normal activity. */
-#define UCM_REG_USDM_IFEN					 0xe0018
-/* [RC 1] Set when the message length mismatch (relative to last indication)
-   at the SDM interface is detected. */
-#define UCM_REG_USDM_LENGTH_MIS 				 0xe0158
-/* [RW 3] The weight of the SDM input in the WRR mechanism. 0 stands for
-   weight 8 (the most prioritised); 1 stands for weight 1(least
-   prioritised); 2 stands for weight 2; tc. */
-#define UCM_REG_USDM_WEIGHT					 0xe00c8
-/* [RW 1] Input xsem Interface enable. If 0 - the valid input is
-   disregarded; acknowledge output is deasserted; all other signals are
-   treated as usual; if 1 - normal activity. */
-#define UCM_REG_XSEM_IFEN					 0xe002c
-/* [RC 1] Set when the message length mismatch (relative to last indication)
-   at the xsem interface isdetected. */
-#define UCM_REG_XSEM_LENGTH_MIS 				 0xe0164
-/* [RW 3] The weight of the input xsem in the WRR mechanism. 0 stands for
-   weight 8 (the most prioritised); 1 stands for weight 1(least
-   prioritised); 2 stands for weight 2; tc. */
-#define UCM_REG_XSEM_WEIGHT					 0xe00bc
-/* [RW 20] Indirect access to the descriptor table of the XX protection
-   mechanism. The fields are:[5:0] - message length; 14:6] - message
-   pointer; 19:15] - next pointer. */
-#define UCM_REG_XX_DESCR_TABLE					 0xe0280
-#define UCM_REG_XX_DESCR_TABLE_SIZE				 32
-/* [R 6] Use to read the XX protection Free counter. */
-#define UCM_REG_XX_FREE 					 0xe016c
-/* [RW 6] Initial value for the credit counter; responsible for fulfilling
-   of the Input Stage XX protection buffer by the XX protection pending
-   messages. Write writes the initial credit value; read returns the current
-   value of the credit counter. Must be initialized to 12 at start-up. */
-#define UCM_REG_XX_INIT_CRD					 0xe0224
-/* [RW 6] The maximum number of pending messages; which may be stored in XX
-   protection. ~ucm_registers_xx_free.xx_free read on read. */
-#define UCM_REG_XX_MSG_NUM					 0xe0228
-/* [RW 8] The Event ID; sent to the STORM in case of XX overflow. */
-#define UCM_REG_XX_OVFL_EVNT_ID 				 0xe004c
-/* [RW 16] Indirect access to the XX table of the XX protection mechanism.
-   The fields are: [4:0] - tail pointer; 10:5] - Link List size; 15:11] -
-   header pointer. */
-#define UCM_REG_XX_TABLE					 0xe0300
-/* [RW 8] The event id for aggregated interrupt 0 */
-#define USDM_REG_AGG_INT_EVENT_0				 0xc4038
-#define USDM_REG_AGG_INT_EVENT_1				 0xc403c
-#define USDM_REG_AGG_INT_EVENT_2				 0xc4040
-#define USDM_REG_AGG_INT_EVENT_4				 0xc4048
-#define USDM_REG_AGG_INT_EVENT_5				 0xc404c
-#define USDM_REG_AGG_INT_EVENT_6				 0xc4050
-/* [RW 1] For each aggregated interrupt index whether the mode is normal (0)
-   or auto-mask-mode (1) */
-#define USDM_REG_AGG_INT_MODE_0 				 0xc41b8
-#define USDM_REG_AGG_INT_MODE_1 				 0xc41bc
-#define USDM_REG_AGG_INT_MODE_4 				 0xc41c8
-#define USDM_REG_AGG_INT_MODE_5 				 0xc41cc
-#define USDM_REG_AGG_INT_MODE_6 				 0xc41d0
-/* [RW 1] The T bit for aggregated interrupt 5 */
-#define USDM_REG_AGG_INT_T_5					 0xc40cc
-#define USDM_REG_AGG_INT_T_6					 0xc40d0
-/* [RW 13] The start address in the internal RAM for the cfc_rsp lcid */
-#define USDM_REG_CFC_RSP_START_ADDR				 0xc4008
-/* [RW 16] The maximum value of the competion counter #0 */
-#define USDM_REG_CMP_COUNTER_MAX0				 0xc401c
-/* [RW 16] The maximum value of the competion counter #1 */
-#define USDM_REG_CMP_COUNTER_MAX1				 0xc4020
-/* [RW 16] The maximum value of the competion counter #2 */
-#define USDM_REG_CMP_COUNTER_MAX2				 0xc4024
-/* [RW 16] The maximum value of the competion counter #3 */
-#define USDM_REG_CMP_COUNTER_MAX3				 0xc4028
-/* [RW 13] The start address in the internal RAM for the completion
-   counters. */
-#define USDM_REG_CMP_COUNTER_START_ADDR 			 0xc400c
-#define USDM_REG_ENABLE_IN1					 0xc4238
-#define USDM_REG_ENABLE_IN2					 0xc423c
-#define USDM_REG_ENABLE_OUT1					 0xc4240
-#define USDM_REG_ENABLE_OUT2					 0xc4244
-/* [RW 4] The initial number of messages that can be sent to the pxp control
-   interface without receiving any ACK. */
-#define USDM_REG_INIT_CREDIT_PXP_CTRL				 0xc44c0
-/* [ST 32] The number of ACK after placement messages received */
-#define USDM_REG_NUM_OF_ACK_AFTER_PLACE 			 0xc4280
-/* [ST 32] The number of packet end messages received from the parser */
-#define USDM_REG_NUM_OF_PKT_END_MSG				 0xc4278
-/* [ST 32] The number of requests received from the pxp async if */
-#define USDM_REG_NUM_OF_PXP_ASYNC_REQ				 0xc427c
-/* [ST 32] The number of commands received in queue 0 */
-#define USDM_REG_NUM_OF_Q0_CMD					 0xc4248
-/* [ST 32] The number of commands received in queue 10 */
-#define USDM_REG_NUM_OF_Q10_CMD 				 0xc4270
-/* [ST 32] The number of commands received in queue 11 */
-#define USDM_REG_NUM_OF_Q11_CMD 				 0xc4274
-/* [ST 32] The number of commands received in queue 1 */
-#define USDM_REG_NUM_OF_Q1_CMD					 0xc424c
-/* [ST 32] The number of commands received in queue 2 */
-#define USDM_REG_NUM_OF_Q2_CMD					 0xc4250
-/* [ST 32] The number of commands received in queue 3 */
-#define USDM_REG_NUM_OF_Q3_CMD					 0xc4254
-/* [ST 32] The number of commands received in queue 4 */
-#define USDM_REG_NUM_OF_Q4_CMD					 0xc4258
-/* [ST 32] The number of commands received in queue 5 */
-#define USDM_REG_NUM_OF_Q5_CMD					 0xc425c
-/* [ST 32] The number of commands received in queue 6 */
-#define USDM_REG_NUM_OF_Q6_CMD					 0xc4260
-/* [ST 32] The number of commands received in queue 7 */
-#define USDM_REG_NUM_OF_Q7_CMD					 0xc4264
-/* [ST 32] The number of commands received in queue 8 */
-#define USDM_REG_NUM_OF_Q8_CMD					 0xc4268
-/* [ST 32] The number of commands received in queue 9 */
-#define USDM_REG_NUM_OF_Q9_CMD					 0xc426c
-/* [RW 13] The start address in the internal RAM for the packet end message */
-#define USDM_REG_PCK_END_MSG_START_ADDR 			 0xc4014
-/* [RW 13] The start address in the internal RAM for queue counters */
-#define USDM_REG_Q_COUNTER_START_ADDR				 0xc4010
-/* [R 1] pxp_ctrl rd_data fifo empty in sdm_dma_rsp block */
-#define USDM_REG_RSP_PXP_CTRL_RDATA_EMPTY			 0xc4550
-/* [R 1] parser fifo empty in sdm_sync block */
-#define USDM_REG_SYNC_PARSER_EMPTY				 0xc4558
-/* [R 1] parser serial fifo empty in sdm_sync block */
-#define USDM_REG_SYNC_SYNC_EMPTY				 0xc4560
-/* [RW 32] Tick for timer counter. Applicable only when
-   ~usdm_registers_timer_tick_enable.timer_tick_enable =1 */
-#define USDM_REG_TIMER_TICK					 0xc4000
-/* [RW 32] Interrupt mask register #0 read/write */
-#define USDM_REG_USDM_INT_MASK_0				 0xc42a0
-#define USDM_REG_USDM_INT_MASK_1				 0xc42b0
-/* [R 32] Interrupt register #0 read */
-#define USDM_REG_USDM_INT_STS_0 				 0xc4294
-#define USDM_REG_USDM_INT_STS_1 				 0xc42a4
-/* [RW 11] Parity mask register #0 read/write */
-#define USDM_REG_USDM_PRTY_MASK 				 0xc42c0
-/* [R 11] Parity register #0 read */
-#define USDM_REG_USDM_PRTY_STS					 0xc42b4
-/* [RW 5] The number of time_slots in the arbitration cycle */
-#define USEM_REG_ARB_CYCLE_SIZE 				 0x300034
-/* [RW 3] The source that is associated with arbitration element 0. Source
-   decoding is: 0- foc0; 1-fic1; 2-sleeping thread with priority 0; 3-
-   sleeping thread with priority 1; 4- sleeping thread with priority 2 */
-#define USEM_REG_ARB_ELEMENT0					 0x300020
-/* [RW 3] The source that is associated with arbitration element 1. Source
-   decoding is: 0- foc0; 1-fic1; 2-sleeping thread with priority 0; 3-
-   sleeping thread with priority 1; 4- sleeping thread with priority 2.
-   Could not be equal to register ~usem_registers_arb_element0.arb_element0 */
-#define USEM_REG_ARB_ELEMENT1					 0x300024
-/* [RW 3] The source that is associated with arbitration element 2. Source
-   decoding is: 0- foc0; 1-fic1; 2-sleeping thread with priority 0; 3-
-   sleeping thread with priority 1; 4- sleeping thread with priority 2.
-   Could not be equal to register ~usem_registers_arb_element0.arb_element0
-   and ~usem_registers_arb_element1.arb_element1 */
-#define USEM_REG_ARB_ELEMENT2					 0x300028
-/* [RW 3] The source that is associated with arbitration element 3. Source
-   decoding is: 0- foc0; 1-fic1; 2-sleeping thread with priority 0; 3-
-   sleeping thread with priority 1; 4- sleeping thread with priority 2.Could
-   not be equal to register ~usem_registers_arb_element0.arb_element0 and
-   ~usem_registers_arb_element1.arb_element1 and
-   ~usem_registers_arb_element2.arb_element2 */
-#define USEM_REG_ARB_ELEMENT3					 0x30002c
-/* [RW 3] The source that is associated with arbitration element 4. Source
-   decoding is: 0- foc0; 1-fic1; 2-sleeping thread with priority 0; 3-
-   sleeping thread with priority 1; 4- sleeping thread with priority 2.
-   Could not be equal to register ~usem_registers_arb_element0.arb_element0
-   and ~usem_registers_arb_element1.arb_element1 and
-   ~usem_registers_arb_element2.arb_element2 and
-   ~usem_registers_arb_element3.arb_element3 */
-#define USEM_REG_ARB_ELEMENT4					 0x300030
-#define USEM_REG_ENABLE_IN					 0x3000a4
-#define USEM_REG_ENABLE_OUT					 0x3000a8
-/* [RW 32] This address space contains all registers and memories that are
-   placed in SEM_FAST block. The SEM_FAST registers are described in
-   appendix B. In order to access the sem_fast registers the base address
-   ~fast_memory.fast_memory should be added to eachsem_fast register offset. */
-#define USEM_REG_FAST_MEMORY					 0x320000
-/* [RW 1] Disables input messages from FIC0 May be updated during run_time
-   by the microcode */
-#define USEM_REG_FIC0_DISABLE					 0x300224
-/* [RW 1] Disables input messages from FIC1 May be updated during run_time
-   by the microcode */
-#define USEM_REG_FIC1_DISABLE					 0x300234
-/* [RW 15] Interrupt table Read and write access to it is not possible in
-   the middle of the work */
-#define USEM_REG_INT_TABLE					 0x300400
-/* [ST 24] Statistics register. The number of messages that entered through
-   FIC0 */
-#define USEM_REG_MSG_NUM_FIC0					 0x300000
-/* [ST 24] Statistics register. The number of messages that entered through
-   FIC1 */
-#define USEM_REG_MSG_NUM_FIC1					 0x300004
-/* [ST 24] Statistics register. The number of messages that were sent to
-   FOC0 */
-#define USEM_REG_MSG_NUM_FOC0					 0x300008
-/* [ST 24] Statistics register. The number of messages that were sent to
-   FOC1 */
-#define USEM_REG_MSG_NUM_FOC1					 0x30000c
-/* [ST 24] Statistics register. The number of messages that were sent to
-   FOC2 */
-#define USEM_REG_MSG_NUM_FOC2					 0x300010
-/* [ST 24] Statistics register. The number of messages that were sent to
-   FOC3 */
-#define USEM_REG_MSG_NUM_FOC3					 0x300014
-/* [RW 1] Disables input messages from the passive buffer May be updated
-   during run_time by the microcode */
-#define USEM_REG_PAS_DISABLE					 0x30024c
-/* [WB 128] Debug only. Passive buffer memory */
-#define USEM_REG_PASSIVE_BUFFER 				 0x302000
-/* [WB 46] pram memory. B45 is parity; b[44:0] - data. */
-#define USEM_REG_PRAM						 0x340000
-/* [R 16] Valid sleeping threads indication have bit per thread */
-#define USEM_REG_SLEEP_THREADS_VALID				 0x30026c
-/* [R 1] EXT_STORE FIFO is empty in sem_slow_ls_ext */
-#define USEM_REG_SLOW_EXT_STORE_EMPTY				 0x3002a0
-/* [RW 16] List of free threads . There is a bit per thread. */
-#define USEM_REG_THREADS_LIST					 0x3002e4
-/* [RW 3] The arbitration scheme of time_slot 0 */
-#define USEM_REG_TS_0_AS					 0x300038
-/* [RW 3] The arbitration scheme of time_slot 10 */
-#define USEM_REG_TS_10_AS					 0x300060
-/* [RW 3] The arbitration scheme of time_slot 11 */
-#define USEM_REG_TS_11_AS					 0x300064
-/* [RW 3] The arbitration scheme of time_slot 12 */
-#define USEM_REG_TS_12_AS					 0x300068
-/* [RW 3] The arbitration scheme of time_slot 13 */
-#define USEM_REG_TS_13_AS					 0x30006c
-/* [RW 3] The arbitration scheme of time_slot 14 */
-#define USEM_REG_TS_14_AS					 0x300070
-/* [RW 3] The arbitration scheme of time_slot 15 */
-#define USEM_REG_TS_15_AS					 0x300074
-/* [RW 3] The arbitration scheme of time_slot 16 */
-#define USEM_REG_TS_16_AS					 0x300078
-/* [RW 3] The arbitration scheme of time_slot 17 */
-#define USEM_REG_TS_17_AS					 0x30007c
-/* [RW 3] The arbitration scheme of time_slot 18 */
-#define USEM_REG_TS_18_AS					 0x300080
-/* [RW 3] The arbitration scheme of time_slot 1 */
-#define USEM_REG_TS_1_AS					 0x30003c
-/* [RW 3] The arbitration scheme of time_slot 2 */
-#define USEM_REG_TS_2_AS					 0x300040
-/* [RW 3] The arbitration scheme of time_slot 3 */
-#define USEM_REG_TS_3_AS					 0x300044
-/* [RW 3] The arbitration scheme of time_slot 4 */
-#define USEM_REG_TS_4_AS					 0x300048
-/* [RW 3] The arbitration scheme of time_slot 5 */
-#define USEM_REG_TS_5_AS					 0x30004c
-/* [RW 3] The arbitration scheme of time_slot 6 */
-#define USEM_REG_TS_6_AS					 0x300050
-/* [RW 3] The arbitration scheme of time_slot 7 */
-#define USEM_REG_TS_7_AS					 0x300054
-/* [RW 3] The arbitration scheme of time_slot 8 */
-#define USEM_REG_TS_8_AS					 0x300058
-/* [RW 3] The arbitration scheme of time_slot 9 */
-#define USEM_REG_TS_9_AS					 0x30005c
-/* [RW 32] Interrupt mask register #0 read/write */
-#define USEM_REG_USEM_INT_MASK_0				 0x300110
-#define USEM_REG_USEM_INT_MASK_1				 0x300120
-/* [R 32] Interrupt register #0 read */
-#define USEM_REG_USEM_INT_STS_0 				 0x300104
-#define USEM_REG_USEM_INT_STS_1 				 0x300114
-/* [RW 32] Parity mask register #0 read/write */
-#define USEM_REG_USEM_PRTY_MASK_0				 0x300130
-#define USEM_REG_USEM_PRTY_MASK_1				 0x300140
-/* [R 32] Parity register #0 read */
-#define USEM_REG_USEM_PRTY_STS_0				 0x300124
-#define USEM_REG_USEM_PRTY_STS_1				 0x300134
-/* [RW 2] The queue index for registration on Aux1 counter flag. */
-#define XCM_REG_AUX1_Q						 0x20134
-/* [RW 2] Per each decision rule the queue index to register to. */
-#define XCM_REG_AUX_CNT_FLG_Q_19				 0x201b0
-/* [R 5] Used to read the XX protection CAM occupancy counter. */
-#define XCM_REG_CAM_OCCUP					 0x20244
-/* [RW 1] CDU AG read Interface enable. If 0 - the request input is
-   disregarded; valid output is deasserted; all other signals are treated as
-   usual; if 1 - normal activity. */
-#define XCM_REG_CDU_AG_RD_IFEN					 0x20044
-/* [RW 1] CDU AG write Interface enable. If 0 - the request and valid input
-   are disregarded; all other signals are treated as usual; if 1 - normal
-   activity. */
-#define XCM_REG_CDU_AG_WR_IFEN					 0x20040
-/* [RW 1] CDU STORM read Interface enable. If 0 - the request input is
-   disregarded; valid output is deasserted; all other signals are treated as
-   usual; if 1 - normal activity. */
-#define XCM_REG_CDU_SM_RD_IFEN					 0x2004c
-/* [RW 1] CDU STORM write Interface enable. If 0 - the request and valid
-   input is disregarded; all other signals are treated as usual; if 1 -
-   normal activity. */
-#define XCM_REG_CDU_SM_WR_IFEN					 0x20048
-/* [RW 4] CFC output initial credit. Max credit available - 15.Write writes
-   the initial credit value; read returns the current value of the credit
-   counter. Must be initialized to 1 at start-up. */
-#define XCM_REG_CFC_INIT_CRD					 0x20404
-/* [RW 3] The weight of the CP input in the WRR mechanism. 0 stands for
-   weight 8 (the most prioritised); 1 stands for weight 1(least
-   prioritised); 2 stands for weight 2; tc. */
-#define XCM_REG_CP_WEIGHT					 0x200dc
-/* [RW 1] Input csem Interface enable. If 0 - the valid input is
-   disregarded; acknowledge output is deasserted; all other signals are
-   treated as usual; if 1 - normal activity. */
-#define XCM_REG_CSEM_IFEN					 0x20028
-/* [RC 1] Set at message length mismatch (relative to last indication) at
-   the csem interface. */
-#define XCM_REG_CSEM_LENGTH_MIS 				 0x20228
-/* [RW 3] The weight of the input csem in the WRR mechanism. 0 stands for
-   weight 8 (the most prioritised); 1 stands for weight 1(least
-   prioritised); 2 stands for weight 2; tc. */
-#define XCM_REG_CSEM_WEIGHT					 0x200c4
-/* [RW 1] Input dorq Interface enable. If 0 - the valid input is
-   disregarded; acknowledge output is deasserted; all other signals are
-   treated as usual; if 1 - normal activity. */
-#define XCM_REG_DORQ_IFEN					 0x20030
-/* [RC 1] Set at message length mismatch (relative to last indication) at
-   the dorq interface. */
-#define XCM_REG_DORQ_LENGTH_MIS 				 0x20230
-/* [RW 3] The weight of the input dorq in the WRR mechanism. 0 stands for
-   weight 8 (the most prioritised); 1 stands for weight 1(least
-   prioritised); 2 stands for weight 2; tc. */
-#define XCM_REG_DORQ_WEIGHT					 0x200cc
-/* [RW 8] The Event ID in case the ErrorFlg input message bit is set. */
-#define XCM_REG_ERR_EVNT_ID					 0x200b0
-/* [RW 28] The CM erroneous header for QM and Timers formatting. */
-#define XCM_REG_ERR_XCM_HDR					 0x200ac
-/* [RW 8] The Event ID for Timers expiration. */
-#define XCM_REG_EXPR_EVNT_ID					 0x200b4
-/* [RW 8] FIC0 output initial credit. Max credit available - 255.Write
-   writes the initial credit value; read returns the current value of the
-   credit counter. Must be initialized to 64 at start-up. */
-#define XCM_REG_FIC0_INIT_CRD					 0x2040c
-/* [RW 8] FIC1 output initial credit. Max credit available - 255.Write
-   writes the initial credit value; read returns the current value of the
-   credit counter. Must be initialized to 64 at start-up. */
-#define XCM_REG_FIC1_INIT_CRD					 0x20410
-#define XCM_REG_GLB_DEL_ACK_MAX_CNT_0				 0x20118
-#define XCM_REG_GLB_DEL_ACK_MAX_CNT_1				 0x2011c
-#define XCM_REG_GLB_DEL_ACK_TMR_VAL_0				 0x20108
-#define XCM_REG_GLB_DEL_ACK_TMR_VAL_1				 0x2010c
-/* [RW 1] Arbitratiojn between Input Arbiter groups: 0 - fair Round-Robin; 1
-   - strict priority defined by ~xcm_registers_gr_ag_pr.gr_ag_pr;
-   ~xcm_registers_gr_ld0_pr.gr_ld0_pr and
-   ~xcm_registers_gr_ld1_pr.gr_ld1_pr. */
-#define XCM_REG_GR_ARB_TYPE					 0x2020c
-/* [RW 2] Load (FIC0) channel group priority. The lowest priority is 0; the
-   highest priority is 3. It is supposed that the Channel group is the
-   compliment of the other 3 groups. */
-#define XCM_REG_GR_LD0_PR					 0x20214
-/* [RW 2] Load (FIC1) channel group priority. The lowest priority is 0; the
-   highest priority is 3. It is supposed that the Channel group is the
-   compliment of the other 3 groups. */
-#define XCM_REG_GR_LD1_PR					 0x20218
-/* [RW 1] Input nig0 Interface enable. If 0 - the valid input is
-   disregarded; acknowledge output is deasserted; all other signals are
-   treated as usual; if 1 - normal activity. */
-#define XCM_REG_NIG0_IFEN					 0x20038
-/* [RC 1] Set at message length mismatch (relative to last indication) at
-   the nig0 interface. */
-#define XCM_REG_NIG0_LENGTH_MIS 				 0x20238
-/* [RW 3] The weight of the input nig0 in the WRR mechanism. 0 stands for
-   weight 8 (the most prioritised); 1 stands for weight 1(least
-   prioritised); 2 stands for weight 2; tc. */
-#define XCM_REG_NIG0_WEIGHT					 0x200d4
-/* [RW 1] Input nig1 Interface enable. If 0 - the valid input is
-   disregarded; acknowledge output is deasserted; all other signals are
-   treated as usual; if 1 - normal activity. */
-#define XCM_REG_NIG1_IFEN					 0x2003c
-/* [RC 1] Set at message length mismatch (relative to last indication) at
-   the nig1 interface. */
-#define XCM_REG_NIG1_LENGTH_MIS 				 0x2023c
-/* [RW 5] The number of double REG-pairs; loaded from the STORM context and
-   sent to STORM; for a specific connection type. The double REG-pairs are
-   used in order to align to STORM context row size of 128 bits. The offset
-   of these data in the STORM context is always 0. Index _i stands for the
-   connection type (one of 16). */
-#define XCM_REG_N_SM_CTX_LD_0					 0x20060
-#define XCM_REG_N_SM_CTX_LD_1					 0x20064
-#define XCM_REG_N_SM_CTX_LD_2					 0x20068
-#define XCM_REG_N_SM_CTX_LD_3					 0x2006c
-#define XCM_REG_N_SM_CTX_LD_4					 0x20070
-#define XCM_REG_N_SM_CTX_LD_5					 0x20074
-/* [RW 1] Input pbf Interface enable. If 0 - the valid input is disregarded;
-   acknowledge output is deasserted; all other signals are treated as usual;
-   if 1 - normal activity. */
-#define XCM_REG_PBF_IFEN					 0x20034
-/* [RC 1] Set at message length mismatch (relative to last indication) at
-   the pbf interface. */
-#define XCM_REG_PBF_LENGTH_MIS					 0x20234
-/* [RW 3] The weight of the input pbf in the WRR mechanism. 0 stands for
-   weight 8 (the most prioritised); 1 stands for weight 1(least
-   prioritised); 2 stands for weight 2; tc. */
-#define XCM_REG_PBF_WEIGHT					 0x200d0
-#define XCM_REG_PHYS_QNUM3_0					 0x20100
-#define XCM_REG_PHYS_QNUM3_1					 0x20104
-/* [RW 8] The Event ID for Timers formatting in case of stop done. */
-#define XCM_REG_STOP_EVNT_ID					 0x200b8
-/* [RC 1] Set at message length mismatch (relative to last indication) at
-   the STORM interface. */
-#define XCM_REG_STORM_LENGTH_MIS				 0x2021c
-/* [RW 3] The weight of the STORM input in the WRR mechanism. 0 stands for
-   weight 8 (the most prioritised); 1 stands for weight 1(least
-   prioritised); 2 stands for weight 2; tc. */
-#define XCM_REG_STORM_WEIGHT					 0x200bc
-/* [RW 1] STORM - CM Interface enable. If 0 - the valid input is
-   disregarded; acknowledge output is deasserted; all other signals are
-   treated as usual; if 1 - normal activity. */
-#define XCM_REG_STORM_XCM_IFEN					 0x20010
-/* [RW 4] Timers output initial credit. Max credit available - 15.Write
-   writes the initial credit value; read returns the current value of the
-   credit counter. Must be initialized to 4 at start-up. */
-#define XCM_REG_TM_INIT_CRD					 0x2041c
-/* [RW 3] The weight of the Timers input in the WRR mechanism. 0 stands for
-   weight 8 (the most prioritised); 1 stands for weight 1(least
-   prioritised); 2 stands for weight 2; tc. */
-#define XCM_REG_TM_WEIGHT					 0x200ec
-/* [RW 28] The CM header for Timers expiration command. */
-#define XCM_REG_TM_XCM_HDR					 0x200a8
-/* [RW 1] Timers - CM Interface enable. If 0 - the valid input is
-   disregarded; acknowledge output is deasserted; all other signals are
-   treated as usual; if 1 - normal activity. */
-#define XCM_REG_TM_XCM_IFEN					 0x2001c
-/* [RW 1] Input tsem Interface enable. If 0 - the valid input is
-   disregarded; acknowledge output is deasserted; all other signals are
-   treated as usual; if 1 - normal activity. */
-#define XCM_REG_TSEM_IFEN					 0x20024
-/* [RC 1] Set at message length mismatch (relative to last indication) at
-   the tsem interface. */
-#define XCM_REG_TSEM_LENGTH_MIS 				 0x20224
-/* [RW 3] The weight of the input tsem in the WRR mechanism. 0 stands for
-   weight 8 (the most prioritised); 1 stands for weight 1(least
-   prioritised); 2 stands for weight 2; tc. */
-#define XCM_REG_TSEM_WEIGHT					 0x200c0
-/* [RW 2] The queue index for registration on UNA greater NXT decision rule. */
-#define XCM_REG_UNA_GT_NXT_Q					 0x20120
-/* [RW 1] Input usem Interface enable. If 0 - the valid input is
-   disregarded; acknowledge output is deasserted; all other signals are
-   treated as usual; if 1 - normal activity. */
-#define XCM_REG_USEM_IFEN					 0x2002c
-/* [RC 1] Message length mismatch (relative to last indication) at the usem
-   interface. */
-#define XCM_REG_USEM_LENGTH_MIS 				 0x2022c
-/* [RW 3] The weight of the input usem in the WRR mechanism. 0 stands for
-   weight 8 (the most prioritised); 1 stands for weight 1(least
-   prioritised); 2 stands for weight 2; tc. */
-#define XCM_REG_USEM_WEIGHT					 0x200c8
-#define XCM_REG_WU_DA_CNT_CMD00 				 0x201d4
-#define XCM_REG_WU_DA_CNT_CMD01 				 0x201d8
-#define XCM_REG_WU_DA_CNT_CMD10 				 0x201dc
-#define XCM_REG_WU_DA_CNT_CMD11 				 0x201e0
-#define XCM_REG_WU_DA_CNT_UPD_VAL00				 0x201e4
-#define XCM_REG_WU_DA_CNT_UPD_VAL01				 0x201e8
-#define XCM_REG_WU_DA_CNT_UPD_VAL10				 0x201ec
-#define XCM_REG_WU_DA_CNT_UPD_VAL11				 0x201f0
-#define XCM_REG_WU_DA_SET_TMR_CNT_FLG_CMD00			 0x201c4
-#define XCM_REG_WU_DA_SET_TMR_CNT_FLG_CMD01			 0x201c8
-#define XCM_REG_WU_DA_SET_TMR_CNT_FLG_CMD10			 0x201cc
-#define XCM_REG_WU_DA_SET_TMR_CNT_FLG_CMD11			 0x201d0
-/* [RW 1] CM - CFC Interface enable. If 0 - the valid input is disregarded;
-   acknowledge output is deasserted; all other signals are treated as usual;
-   if 1 - normal activity. */
-#define XCM_REG_XCM_CFC_IFEN					 0x20050
-/* [RW 14] Interrupt mask register #0 read/write */
-#define XCM_REG_XCM_INT_MASK					 0x202b4
-/* [R 14] Interrupt register #0 read */
-#define XCM_REG_XCM_INT_STS					 0x202a8
-/* [R 30] Parity register #0 read */
-#define XCM_REG_XCM_PRTY_STS					 0x202b8
-/* [RW 4] The size of AG context region 0 in REG-pairs. Designates the MS
-   REG-pair number (e.g. if region 0 is 6 REG-pairs; the value should be 5).
-   Is used to determine the number of the AG context REG-pairs written back;
-   when the Reg1WbFlg isn't set. */
-#define XCM_REG_XCM_REG0_SZ					 0x200f4
-/* [RW 1] CM - STORM 0 Interface enable. If 0 - the acknowledge input is
-   disregarded; valid is deasserted; all other signals are treated as usual;
-   if 1 - normal activity. */
-#define XCM_REG_XCM_STORM0_IFEN 				 0x20004
-/* [RW 1] CM - STORM 1 Interface enable. If 0 - the acknowledge input is
-   disregarded; valid is deasserted; all other signals are treated as usual;
-   if 1 - normal activity. */
-#define XCM_REG_XCM_STORM1_IFEN 				 0x20008
-/* [RW 1] CM - Timers Interface enable. If 0 - the valid input is
-   disregarded; acknowledge output is deasserted; all other signals are
-   treated as usual; if 1 - normal activity. */
-#define XCM_REG_XCM_TM_IFEN					 0x20020
-/* [RW 1] CM - QM Interface enable. If 0 - the acknowledge input is
-   disregarded; valid is deasserted; all other signals are treated as usual;
-   if 1 - normal activity. */
-#define XCM_REG_XCM_XQM_IFEN					 0x2000c
-/* [RW 1] If set the Q index; received from the QM is inserted to event ID. */
-#define XCM_REG_XCM_XQM_USE_Q					 0x200f0
-/* [RW 4] The value by which CFC updates the activity counter at QM bypass. */
-#define XCM_REG_XQM_BYP_ACT_UPD 				 0x200fc
-/* [RW 6] QM output initial credit. Max credit available - 32.Write writes
-   the initial credit value; read returns the current value of the credit
-   counter. Must be initialized to 32 at start-up. */
-#define XCM_REG_XQM_INIT_CRD					 0x20420
-/* [RW 3] The weight of the QM (primary) input in the WRR mechanism. 0
-   stands for weight 8 (the most prioritised); 1 stands for weight 1(least
-   prioritised); 2 stands for weight 2; tc. */
-#define XCM_REG_XQM_P_WEIGHT					 0x200e4
-/* [RW 3] The weight of the QM (secondary) input in the WRR mechanism. 0
-   stands for weight 8 (the most prioritised); 1 stands for weight 1(least
-   prioritised); 2 stands for weight 2; tc. */
-#define XCM_REG_XQM_S_WEIGHT					 0x200e8
-/* [RW 28] The CM header value for QM request (primary). */
-#define XCM_REG_XQM_XCM_HDR_P					 0x200a0
-/* [RW 28] The CM header value for QM request (secondary). */
-#define XCM_REG_XQM_XCM_HDR_S					 0x200a4
-/* [RW 1] QM - CM Interface enable. If 0 - the valid input is disregarded;
-   acknowledge output is deasserted; all other signals are treated as usual;
-   if 1 - normal activity. */
-#define XCM_REG_XQM_XCM_IFEN					 0x20014
-/* [RW 1] Input SDM Interface enable. If 0 - the valid input is disregarded;
-   acknowledge output is deasserted; all other signals are treated as usual;
-   if 1 - normal activity. */
-#define XCM_REG_XSDM_IFEN					 0x20018
-/* [RC 1] Set at message length mismatch (relative to last indication) at
-   the SDM interface. */
-#define XCM_REG_XSDM_LENGTH_MIS 				 0x20220
-/* [RW 3] The weight of the SDM input in the WRR mechanism. 0 stands for
-   weight 8 (the most prioritised); 1 stands for weight 1(least
-   prioritised); 2 stands for weight 2; tc. */
-#define XCM_REG_XSDM_WEIGHT					 0x200e0
-/* [RW 17] Indirect access to the descriptor table of the XX protection
-   mechanism. The fields are: [5:0] - message length; 11:6] - message
-   pointer; 16:12] - next pointer. */
-#define XCM_REG_XX_DESCR_TABLE					 0x20480
-#define XCM_REG_XX_DESCR_TABLE_SIZE				 32
-/* [R 6] Used to read the XX protection Free counter. */
-#define XCM_REG_XX_FREE 					 0x20240
-/* [RW 6] Initial value for the credit counter; responsible for fulfilling
-   of the Input Stage XX protection buffer by the XX protection pending
-   messages. Max credit available - 3.Write writes the initial credit value;
-   read returns the current value of the credit counter. Must be initialized
-   to 2 at start-up. */
-#define XCM_REG_XX_INIT_CRD					 0x20424
-/* [RW 6] The maximum number of pending messages; which may be stored in XX
-   protection. ~xcm_registers_xx_free.xx_free read on read. */
-#define XCM_REG_XX_MSG_NUM					 0x20428
-/* [RW 8] The Event ID; sent to the STORM in case of XX overflow. */
-#define XCM_REG_XX_OVFL_EVNT_ID 				 0x20058
-/* [RW 16] Indirect access to the XX table of the XX protection mechanism.
-   The fields are:[4:0] - tail pointer; 9:5] - Link List size; 14:10] -
-   header pointer. */
-#define XCM_REG_XX_TABLE					 0x20500
-/* [RW 8] The event id for aggregated interrupt 0 */
-#define XSDM_REG_AGG_INT_EVENT_0				 0x166038
-#define XSDM_REG_AGG_INT_EVENT_1				 0x16603c
-#define XSDM_REG_AGG_INT_EVENT_10				 0x166060
-#define XSDM_REG_AGG_INT_EVENT_11				 0x166064
-#define XSDM_REG_AGG_INT_EVENT_12				 0x166068
-#define XSDM_REG_AGG_INT_EVENT_13				 0x16606c
-#define XSDM_REG_AGG_INT_EVENT_14				 0x166070
-#define XSDM_REG_AGG_INT_EVENT_2				 0x166040
-#define XSDM_REG_AGG_INT_EVENT_3				 0x166044
-#define XSDM_REG_AGG_INT_EVENT_4				 0x166048
-#define XSDM_REG_AGG_INT_EVENT_5				 0x16604c
-#define XSDM_REG_AGG_INT_EVENT_6				 0x166050
-#define XSDM_REG_AGG_INT_EVENT_7				 0x166054
-#define XSDM_REG_AGG_INT_EVENT_8				 0x166058
-#define XSDM_REG_AGG_INT_EVENT_9				 0x16605c
-/* [RW 1] For each aggregated interrupt index whether the mode is normal (0)
-   or auto-mask-mode (1) */
-#define XSDM_REG_AGG_INT_MODE_0 				 0x1661b8
-#define XSDM_REG_AGG_INT_MODE_1 				 0x1661bc
-/* [RW 13] The start address in the internal RAM for the cfc_rsp lcid */
-#define XSDM_REG_CFC_RSP_START_ADDR				 0x166008
-/* [RW 16] The maximum value of the competion counter #0 */
-#define XSDM_REG_CMP_COUNTER_MAX0				 0x16601c
-/* [RW 16] The maximum value of the competion counter #1 */
-#define XSDM_REG_CMP_COUNTER_MAX1				 0x166020
-/* [RW 16] The maximum value of the competion counter #2 */
-#define XSDM_REG_CMP_COUNTER_MAX2				 0x166024
-/* [RW 16] The maximum value of the competion counter #3 */
-#define XSDM_REG_CMP_COUNTER_MAX3				 0x166028
-/* [RW 13] The start address in the internal RAM for the completion
-   counters. */
-#define XSDM_REG_CMP_COUNTER_START_ADDR 			 0x16600c
-#define XSDM_REG_ENABLE_IN1					 0x166238
-#define XSDM_REG_ENABLE_IN2					 0x16623c
-#define XSDM_REG_ENABLE_OUT1					 0x166240
-#define XSDM_REG_ENABLE_OUT2					 0x166244
-/* [RW 4] The initial number of messages that can be sent to the pxp control
-   interface without receiving any ACK. */
-#define XSDM_REG_INIT_CREDIT_PXP_CTRL				 0x1664bc
-/* [ST 32] The number of ACK after placement messages received */
-#define XSDM_REG_NUM_OF_ACK_AFTER_PLACE 			 0x16627c
-/* [ST 32] The number of packet end messages received from the parser */
-#define XSDM_REG_NUM_OF_PKT_END_MSG				 0x166274
-/* [ST 32] The number of requests received from the pxp async if */
-#define XSDM_REG_NUM_OF_PXP_ASYNC_REQ				 0x166278
-/* [ST 32] The number of commands received in queue 0 */
-#define XSDM_REG_NUM_OF_Q0_CMD					 0x166248
-/* [ST 32] The number of commands received in queue 10 */
-#define XSDM_REG_NUM_OF_Q10_CMD 				 0x16626c
-/* [ST 32] The number of commands received in queue 11 */
-#define XSDM_REG_NUM_OF_Q11_CMD 				 0x166270
-/* [ST 32] The number of commands received in queue 1 */
-#define XSDM_REG_NUM_OF_Q1_CMD					 0x16624c
-/* [ST 32] The number of commands received in queue 3 */
-#define XSDM_REG_NUM_OF_Q3_CMD					 0x166250
-/* [ST 32] The number of commands received in queue 4 */
-#define XSDM_REG_NUM_OF_Q4_CMD					 0x166254
-/* [ST 32] The number of commands received in queue 5 */
-#define XSDM_REG_NUM_OF_Q5_CMD					 0x166258
-/* [ST 32] The number of commands received in queue 6 */
-#define XSDM_REG_NUM_OF_Q6_CMD					 0x16625c
-/* [ST 32] The number of commands received in queue 7 */
-#define XSDM_REG_NUM_OF_Q7_CMD					 0x166260
-/* [ST 32] The number of commands received in queue 8 */
-#define XSDM_REG_NUM_OF_Q8_CMD					 0x166264
-/* [ST 32] The number of commands received in queue 9 */
-#define XSDM_REG_NUM_OF_Q9_CMD					 0x166268
-/* [RW 13] The start address in the internal RAM for queue counters */
-#define XSDM_REG_Q_COUNTER_START_ADDR				 0x166010
-/* [R 1] pxp_ctrl rd_data fifo empty in sdm_dma_rsp block */
-#define XSDM_REG_RSP_PXP_CTRL_RDATA_EMPTY			 0x166548
-/* [R 1] parser fifo empty in sdm_sync block */
-#define XSDM_REG_SYNC_PARSER_EMPTY				 0x166550
-/* [R 1] parser serial fifo empty in sdm_sync block */
-#define XSDM_REG_SYNC_SYNC_EMPTY				 0x166558
-/* [RW 32] Tick for timer counter. Applicable only when
-   ~xsdm_registers_timer_tick_enable.timer_tick_enable =1 */
-#define XSDM_REG_TIMER_TICK					 0x166000
-/* [RW 32] Interrupt mask register #0 read/write */
-#define XSDM_REG_XSDM_INT_MASK_0				 0x16629c
-#define XSDM_REG_XSDM_INT_MASK_1				 0x1662ac
-/* [R 32] Interrupt register #0 read */
-#define XSDM_REG_XSDM_INT_STS_0 				 0x166290
-#define XSDM_REG_XSDM_INT_STS_1 				 0x1662a0
-/* [RW 11] Parity mask register #0 read/write */
-#define XSDM_REG_XSDM_PRTY_MASK 				 0x1662bc
-/* [R 11] Parity register #0 read */
-#define XSDM_REG_XSDM_PRTY_STS					 0x1662b0
-/* [RW 5] The number of time_slots in the arbitration cycle */
-#define XSEM_REG_ARB_CYCLE_SIZE 				 0x280034
-/* [RW 3] The source that is associated with arbitration element 0. Source
-   decoding is: 0- foc0; 1-fic1; 2-sleeping thread with priority 0; 3-
-   sleeping thread with priority 1; 4- sleeping thread with priority 2 */
-#define XSEM_REG_ARB_ELEMENT0					 0x280020
-/* [RW 3] The source that is associated with arbitration element 1. Source
-   decoding is: 0- foc0; 1-fic1; 2-sleeping thread with priority 0; 3-
-   sleeping thread with priority 1; 4- sleeping thread with priority 2.
-   Could not be equal to register ~xsem_registers_arb_element0.arb_element0 */
-#define XSEM_REG_ARB_ELEMENT1					 0x280024
-/* [RW 3] The source that is associated with arbitration element 2. Source
-   decoding is: 0- foc0; 1-fic1; 2-sleeping thread with priority 0; 3-
-   sleeping thread with priority 1; 4- sleeping thread with priority 2.
-   Could not be equal to register ~xsem_registers_arb_element0.arb_element0
-   and ~xsem_registers_arb_element1.arb_element1 */
-#define XSEM_REG_ARB_ELEMENT2					 0x280028
-/* [RW 3] The source that is associated with arbitration element 3. Source
-   decoding is: 0- foc0; 1-fic1; 2-sleeping thread with priority 0; 3-
-   sleeping thread with priority 1; 4- sleeping thread with priority 2.Could
-   not be equal to register ~xsem_registers_arb_element0.arb_element0 and
-   ~xsem_registers_arb_element1.arb_element1 and
-   ~xsem_registers_arb_element2.arb_element2 */
-#define XSEM_REG_ARB_ELEMENT3					 0x28002c
-/* [RW 3] The source that is associated with arbitration element 4. Source
-   decoding is: 0- foc0; 1-fic1; 2-sleeping thread with priority 0; 3-
-   sleeping thread with priority 1; 4- sleeping thread with priority 2.
-   Could not be equal to register ~xsem_registers_arb_element0.arb_element0
-   and ~xsem_registers_arb_element1.arb_element1 and
-   ~xsem_registers_arb_element2.arb_element2 and
-   ~xsem_registers_arb_element3.arb_element3 */
-#define XSEM_REG_ARB_ELEMENT4					 0x280030
-#define XSEM_REG_ENABLE_IN					 0x2800a4
-#define XSEM_REG_ENABLE_OUT					 0x2800a8
-/* [RW 32] This address space contains all registers and memories that are
-   placed in SEM_FAST block. The SEM_FAST registers are described in
-   appendix B. In order to access the sem_fast registers the base address
-   ~fast_memory.fast_memory should be added to eachsem_fast register offset. */
-#define XSEM_REG_FAST_MEMORY					 0x2a0000
-/* [RW 1] Disables input messages from FIC0 May be updated during run_time
-   by the microcode */
-#define XSEM_REG_FIC0_DISABLE					 0x280224
-/* [RW 1] Disables input messages from FIC1 May be updated during run_time
-   by the microcode */
-#define XSEM_REG_FIC1_DISABLE					 0x280234
-/* [RW 15] Interrupt table Read and write access to it is not possible in
-   the middle of the work */
-#define XSEM_REG_INT_TABLE					 0x280400
-/* [ST 24] Statistics register. The number of messages that entered through
-   FIC0 */
-#define XSEM_REG_MSG_NUM_FIC0					 0x280000
-/* [ST 24] Statistics register. The number of messages that entered through
-   FIC1 */
-#define XSEM_REG_MSG_NUM_FIC1					 0x280004
-/* [ST 24] Statistics register. The number of messages that were sent to
-   FOC0 */
-#define XSEM_REG_MSG_NUM_FOC0					 0x280008
-/* [ST 24] Statistics register. The number of messages that were sent to
-   FOC1 */
-#define XSEM_REG_MSG_NUM_FOC1					 0x28000c
-/* [ST 24] Statistics register. The number of messages that were sent to
-   FOC2 */
-#define XSEM_REG_MSG_NUM_FOC2					 0x280010
-/* [ST 24] Statistics register. The number of messages that were sent to
-   FOC3 */
-#define XSEM_REG_MSG_NUM_FOC3					 0x280014
-/* [RW 1] Disables input messages from the passive buffer May be updated
-   during run_time by the microcode */
-#define XSEM_REG_PAS_DISABLE					 0x28024c
-/* [WB 128] Debug only. Passive buffer memory */
-#define XSEM_REG_PASSIVE_BUFFER 				 0x282000
-/* [WB 46] pram memory. B45 is parity; b[44:0] - data. */
-#define XSEM_REG_PRAM						 0x2c0000
-/* [R 16] Valid sleeping threads indication have bit per thread */
-#define XSEM_REG_SLEEP_THREADS_VALID				 0x28026c
-/* [R 1] EXT_STORE FIFO is empty in sem_slow_ls_ext */
-#define XSEM_REG_SLOW_EXT_STORE_EMPTY				 0x2802a0
-/* [RW 16] List of free threads . There is a bit per thread. */
-#define XSEM_REG_THREADS_LIST					 0x2802e4
-/* [RW 3] The arbitration scheme of time_slot 0 */
-#define XSEM_REG_TS_0_AS					 0x280038
-/* [RW 3] The arbitration scheme of time_slot 10 */
-#define XSEM_REG_TS_10_AS					 0x280060
-/* [RW 3] The arbitration scheme of time_slot 11 */
-#define XSEM_REG_TS_11_AS					 0x280064
-/* [RW 3] The arbitration scheme of time_slot 12 */
-#define XSEM_REG_TS_12_AS					 0x280068
-/* [RW 3] The arbitration scheme of time_slot 13 */
-#define XSEM_REG_TS_13_AS					 0x28006c
-/* [RW 3] The arbitration scheme of time_slot 14 */
-#define XSEM_REG_TS_14_AS					 0x280070
-/* [RW 3] The arbitration scheme of time_slot 15 */
-#define XSEM_REG_TS_15_AS					 0x280074
-/* [RW 3] The arbitration scheme of time_slot 16 */
-#define XSEM_REG_TS_16_AS					 0x280078
-/* [RW 3] The arbitration scheme of time_slot 17 */
-#define XSEM_REG_TS_17_AS					 0x28007c
-/* [RW 3] The arbitration scheme of time_slot 18 */
-#define XSEM_REG_TS_18_AS					 0x280080
-/* [RW 3] The arbitration scheme of time_slot 1 */
-#define XSEM_REG_TS_1_AS					 0x28003c
-/* [RW 3] The arbitration scheme of time_slot 2 */
-#define XSEM_REG_TS_2_AS					 0x280040
-/* [RW 3] The arbitration scheme of time_slot 3 */
-#define XSEM_REG_TS_3_AS					 0x280044
-/* [RW 3] The arbitration scheme of time_slot 4 */
-#define XSEM_REG_TS_4_AS					 0x280048
-/* [RW 3] The arbitration scheme of time_slot 5 */
-#define XSEM_REG_TS_5_AS					 0x28004c
-/* [RW 3] The arbitration scheme of time_slot 6 */
-#define XSEM_REG_TS_6_AS					 0x280050
-/* [RW 3] The arbitration scheme of time_slot 7 */
-#define XSEM_REG_TS_7_AS					 0x280054
-/* [RW 3] The arbitration scheme of time_slot 8 */
-#define XSEM_REG_TS_8_AS					 0x280058
-/* [RW 3] The arbitration scheme of time_slot 9 */
-#define XSEM_REG_TS_9_AS					 0x28005c
-/* [RW 32] Interrupt mask register #0 read/write */
-#define XSEM_REG_XSEM_INT_MASK_0				 0x280110
-#define XSEM_REG_XSEM_INT_MASK_1				 0x280120
-/* [R 32] Interrupt register #0 read */
-#define XSEM_REG_XSEM_INT_STS_0 				 0x280104
-#define XSEM_REG_XSEM_INT_STS_1 				 0x280114
-/* [RW 32] Parity mask register #0 read/write */
-#define XSEM_REG_XSEM_PRTY_MASK_0				 0x280130
-#define XSEM_REG_XSEM_PRTY_MASK_1				 0x280140
-/* [R 32] Parity register #0 read */
-#define XSEM_REG_XSEM_PRTY_STS_0				 0x280124
-#define XSEM_REG_XSEM_PRTY_STS_1				 0x280134
-#define MCPR_NVM_ACCESS_ENABLE_EN				 (1L<<0)
-#define MCPR_NVM_ACCESS_ENABLE_WR_EN				 (1L<<1)
-#define MCPR_NVM_ADDR_NVM_ADDR_VALUE				 (0xffffffL<<0)
-#define MCPR_NVM_CFG4_FLASH_SIZE				 (0x7L<<0)
-#define MCPR_NVM_COMMAND_DOIT					 (1L<<4)
-#define MCPR_NVM_COMMAND_DONE					 (1L<<3)
-#define MCPR_NVM_COMMAND_FIRST					 (1L<<7)
-#define MCPR_NVM_COMMAND_LAST					 (1L<<8)
-#define MCPR_NVM_COMMAND_WR					 (1L<<5)
-#define MCPR_NVM_SW_ARB_ARB_ARB1				 (1L<<9)
-#define MCPR_NVM_SW_ARB_ARB_REQ_CLR1				 (1L<<5)
-#define MCPR_NVM_SW_ARB_ARB_REQ_SET1				 (1L<<1)
-#define BIGMAC_REGISTER_BMAC_CONTROL				 (0x00<<3)
-#define BIGMAC_REGISTER_BMAC_XGXS_CONTROL			 (0x01<<3)
-#define BIGMAC_REGISTER_CNT_MAX_SIZE				 (0x05<<3)
-#define BIGMAC_REGISTER_RX_CONTROL				 (0x21<<3)
-#define BIGMAC_REGISTER_RX_LLFC_MSG_FLDS			 (0x46<<3)
-#define BIGMAC_REGISTER_RX_MAX_SIZE				 (0x23<<3)
-#define BIGMAC_REGISTER_RX_STAT_GR64				 (0x26<<3)
-#define BIGMAC_REGISTER_RX_STAT_GRIPJ				 (0x42<<3)
-#define BIGMAC_REGISTER_TX_CONTROL				 (0x07<<3)
-#define BIGMAC_REGISTER_TX_MAX_SIZE				 (0x09<<3)
-#define BIGMAC_REGISTER_TX_PAUSE_THRESHOLD			 (0x0A<<3)
-#define BIGMAC_REGISTER_TX_SOURCE_ADDR				 (0x08<<3)
-#define BIGMAC_REGISTER_TX_STAT_GTBYT				 (0x20<<3)
-#define BIGMAC_REGISTER_TX_STAT_GTPKT				 (0x0C<<3)
-#define EMAC_LED_1000MB_OVERRIDE				 (1L<<1)
-#define EMAC_LED_100MB_OVERRIDE 				 (1L<<2)
-#define EMAC_LED_10MB_OVERRIDE					 (1L<<3)
-#define EMAC_LED_2500MB_OVERRIDE				 (1L<<12)
-#define EMAC_LED_OVERRIDE					 (1L<<0)
-#define EMAC_LED_TRAFFIC					 (1L<<6)
-#define EMAC_MDIO_COMM_COMMAND_ADDRESS				 (0L<<26)
-#define EMAC_MDIO_COMM_COMMAND_READ_45				 (3L<<26)
-#define EMAC_MDIO_COMM_COMMAND_WRITE_45 			 (1L<<26)
-#define EMAC_MDIO_COMM_DATA					 (0xffffL<<0)
-#define EMAC_MDIO_COMM_START_BUSY				 (1L<<29)
-#define EMAC_MDIO_MODE_AUTO_POLL				 (1L<<4)
-#define EMAC_MDIO_MODE_CLAUSE_45				 (1L<<31)
-#define EMAC_MDIO_MODE_CLOCK_CNT				 (0x3fL<<16)
-#define EMAC_MDIO_MODE_CLOCK_CNT_BITSHIFT			 16
-#define EMAC_MODE_25G_MODE					 (1L<<5)
-#define EMAC_MODE_HALF_DUPLEX					 (1L<<1)
-#define EMAC_MODE_PORT_GMII					 (2L<<2)
-#define EMAC_MODE_PORT_MII					 (1L<<2)
-#define EMAC_MODE_PORT_MII_10M					 (3L<<2)
-#define EMAC_MODE_RESET 					 (1L<<0)
-#define EMAC_REG_EMAC_LED					 0xc
-#define EMAC_REG_EMAC_MAC_MATCH 				 0x10
-#define EMAC_REG_EMAC_MDIO_COMM 				 0xac
-#define EMAC_REG_EMAC_MDIO_MODE 				 0xb4
-#define EMAC_REG_EMAC_MODE					 0x0
-#define EMAC_REG_EMAC_RX_MODE					 0xc8
-#define EMAC_REG_EMAC_RX_MTU_SIZE				 0x9c
-#define EMAC_REG_EMAC_RX_STAT_AC				 0x180
-#define EMAC_REG_EMAC_RX_STAT_AC_28				 0x1f4
-#define EMAC_REG_EMAC_RX_STAT_AC_COUNT				 23
-#define EMAC_REG_EMAC_TX_MODE					 0xbc
-#define EMAC_REG_EMAC_TX_STAT_AC				 0x280
-#define EMAC_REG_EMAC_TX_STAT_AC_COUNT				 22
-#define EMAC_RX_MODE_FLOW_EN					 (1L<<2)
-#define EMAC_RX_MODE_KEEP_VLAN_TAG				 (1L<<10)
-#define EMAC_RX_MODE_PROMISCUOUS				 (1L<<8)
-#define EMAC_RX_MODE_RESET					 (1L<<0)
-#define EMAC_RX_MTU_SIZE_JUMBO_ENA				 (1L<<31)
-#define EMAC_TX_MODE_EXT_PAUSE_EN				 (1L<<3)
-#define EMAC_TX_MODE_FLOW_EN					 (1L<<4)
-#define EMAC_TX_MODE_RESET					 (1L<<0)
-#define MISC_REGISTERS_GPIO_0					 0
-#define MISC_REGISTERS_GPIO_1					 1
-#define MISC_REGISTERS_GPIO_2					 2
-#define MISC_REGISTERS_GPIO_3					 3
-#define MISC_REGISTERS_GPIO_CLR_POS				 16
-#define MISC_REGISTERS_GPIO_FLOAT				 (0xffL<<24)
-#define MISC_REGISTERS_GPIO_FLOAT_POS				 24
-#define MISC_REGISTERS_GPIO_HIGH				 1
-#define MISC_REGISTERS_GPIO_INPUT_HI_Z				 2
-#define MISC_REGISTERS_GPIO_INT_CLR_POS 			 24
-#define MISC_REGISTERS_GPIO_INT_OUTPUT_CLR			 0
-#define MISC_REGISTERS_GPIO_INT_OUTPUT_SET			 1
-#define MISC_REGISTERS_GPIO_INT_SET_POS 			 16
-#define MISC_REGISTERS_GPIO_LOW 				 0
-#define MISC_REGISTERS_GPIO_OUTPUT_HIGH 			 1
-#define MISC_REGISTERS_GPIO_OUTPUT_LOW				 0
-#define MISC_REGISTERS_GPIO_PORT_SHIFT				 4
-#define MISC_REGISTERS_GPIO_SET_POS				 8
-#define MISC_REGISTERS_RESET_REG_1_CLEAR			 0x588
-#define MISC_REGISTERS_RESET_REG_1_RST_NIG			 (0x1<<7)
-#define MISC_REGISTERS_RESET_REG_1_SET				 0x584
-#define MISC_REGISTERS_RESET_REG_2_CLEAR			 0x598
-#define MISC_REGISTERS_RESET_REG_2_RST_BMAC0			 (0x1<<0)
-#define MISC_REGISTERS_RESET_REG_2_RST_EMAC0_HARD_CORE		 (0x1<<14)
-#define MISC_REGISTERS_RESET_REG_2_SET				 0x594
-#define MISC_REGISTERS_RESET_REG_3_CLEAR			 0x5a8
-#define MISC_REGISTERS_RESET_REG_3_MISC_NIG_MUX_SERDES0_IDDQ	 (0x1<<1)
-#define MISC_REGISTERS_RESET_REG_3_MISC_NIG_MUX_SERDES0_PWRDWN	 (0x1<<2)
-#define MISC_REGISTERS_RESET_REG_3_MISC_NIG_MUX_SERDES0_PWRDWN_SD (0x1<<3)
-#define MISC_REGISTERS_RESET_REG_3_MISC_NIG_MUX_SERDES0_RSTB_HW  (0x1<<0)
-#define MISC_REGISTERS_RESET_REG_3_MISC_NIG_MUX_XGXS0_IDDQ	 (0x1<<5)
-#define MISC_REGISTERS_RESET_REG_3_MISC_NIG_MUX_XGXS0_PWRDWN	 (0x1<<6)
-#define MISC_REGISTERS_RESET_REG_3_MISC_NIG_MUX_XGXS0_PWRDWN_SD  (0x1<<7)
-#define MISC_REGISTERS_RESET_REG_3_MISC_NIG_MUX_XGXS0_RSTB_HW	 (0x1<<4)
-#define MISC_REGISTERS_RESET_REG_3_MISC_NIG_MUX_XGXS0_TXD_FIFO_RSTB (0x1<<8)
-#define MISC_REGISTERS_RESET_REG_3_SET				 0x5a4
-#define MISC_REGISTERS_SPIO_4					 4
-#define MISC_REGISTERS_SPIO_5					 5
-#define MISC_REGISTERS_SPIO_7					 7
-#define MISC_REGISTERS_SPIO_CLR_POS				 16
-#define MISC_REGISTERS_SPIO_FLOAT				 (0xffL<<24)
-#define MISC_REGISTERS_SPIO_FLOAT_POS				 24
-#define MISC_REGISTERS_SPIO_INPUT_HI_Z				 2
-#define MISC_REGISTERS_SPIO_INT_OLD_SET_POS			 16
-#define MISC_REGISTERS_SPIO_OUTPUT_HIGH 			 1
-#define MISC_REGISTERS_SPIO_OUTPUT_LOW				 0
-#define MISC_REGISTERS_SPIO_SET_POS				 8
-#define HW_LOCK_MAX_RESOURCE_VALUE				 31
-#define HW_LOCK_RESOURCE_GPIO					 1
-#define HW_LOCK_RESOURCE_MDIO					 0
-#define HW_LOCK_RESOURCE_PORT0_ATT_MASK 			 3
-#define HW_LOCK_RESOURCE_SPIO					 2
-#define HW_LOCK_RESOURCE_UNDI					 5
-#define PRS_FLAG_OVERETH_IPV4					 1
-#define AEU_INPUTS_ATTN_BITS_BRB_PARITY_ERROR		      (1<<18)
-#define AEU_INPUTS_ATTN_BITS_CCM_HW_INTERRUPT		      (1<<31)
-#define AEU_INPUTS_ATTN_BITS_CDU_HW_INTERRUPT		      (1<<9)
-#define AEU_INPUTS_ATTN_BITS_CDU_PARITY_ERROR		      (1<<8)
-#define AEU_INPUTS_ATTN_BITS_CFC_HW_INTERRUPT		      (1<<7)
-#define AEU_INPUTS_ATTN_BITS_CFC_PARITY_ERROR		      (1<<6)
-#define AEU_INPUTS_ATTN_BITS_CSDM_HW_INTERRUPT		      (1<<29)
-#define AEU_INPUTS_ATTN_BITS_CSDM_PARITY_ERROR		      (1<<28)
-#define AEU_INPUTS_ATTN_BITS_CSEMI_HW_INTERRUPT 	      (1<<1)
-#define AEU_INPUTS_ATTN_BITS_CSEMI_PARITY_ERROR 	      (1<<0)
-#define AEU_INPUTS_ATTN_BITS_DEBUG_PARITY_ERROR 	      (1<<18)
-#define AEU_INPUTS_ATTN_BITS_DMAE_HW_INTERRUPT		      (1<<11)
-#define AEU_INPUTS_ATTN_BITS_DOORBELLQ_HW_INTERRUPT	      (1<<13)
-#define AEU_INPUTS_ATTN_BITS_DOORBELLQ_PARITY_ERROR	      (1<<12)
-#define AEU_INPUTS_ATTN_BITS_GPIO3_FUNCTION_0		      (1<<5)
-#define AEU_INPUTS_ATTN_BITS_GPIO3_FUNCTION_1		      (1<<9)
-#define AEU_INPUTS_ATTN_BITS_IGU_PARITY_ERROR		      (1<<12)
-#define AEU_INPUTS_ATTN_BITS_MISC_HW_INTERRUPT		      (1<<15)
-#define AEU_INPUTS_ATTN_BITS_MISC_PARITY_ERROR		      (1<<14)
-#define AEU_INPUTS_ATTN_BITS_PARSER_PARITY_ERROR	      (1<<20)
-#define AEU_INPUTS_ATTN_BITS_PBCLIENT_PARITY_ERROR	      (1<<0)
-#define AEU_INPUTS_ATTN_BITS_PBF_HW_INTERRUPT		      (1<<31)
-#define AEU_INPUTS_ATTN_BITS_PXP_HW_INTERRUPT		      (1<<3)
-#define AEU_INPUTS_ATTN_BITS_PXP_PARITY_ERROR		      (1<<2)
-#define AEU_INPUTS_ATTN_BITS_PXPPCICLOCKCLIENT_HW_INTERRUPT   (1<<5)
-#define AEU_INPUTS_ATTN_BITS_PXPPCICLOCKCLIENT_PARITY_ERROR   (1<<4)
-#define AEU_INPUTS_ATTN_BITS_QM_HW_INTERRUPT		      (1<<3)
-#define AEU_INPUTS_ATTN_BITS_QM_PARITY_ERROR		      (1<<2)
-#define AEU_INPUTS_ATTN_BITS_SEARCHER_PARITY_ERROR	      (1<<22)
-#define AEU_INPUTS_ATTN_BITS_SPIO5			      (1<<15)
-#define AEU_INPUTS_ATTN_BITS_TCM_HW_INTERRUPT		      (1<<27)
-#define AEU_INPUTS_ATTN_BITS_TIMERS_HW_INTERRUPT	      (1<<5)
-#define AEU_INPUTS_ATTN_BITS_TSDM_HW_INTERRUPT		      (1<<25)
-#define AEU_INPUTS_ATTN_BITS_TSDM_PARITY_ERROR		      (1<<24)
-#define AEU_INPUTS_ATTN_BITS_TSEMI_HW_INTERRUPT 	      (1<<29)
-#define AEU_INPUTS_ATTN_BITS_TSEMI_PARITY_ERROR 	      (1<<28)
-#define AEU_INPUTS_ATTN_BITS_UCM_HW_INTERRUPT		      (1<<23)
-#define AEU_INPUTS_ATTN_BITS_UPB_HW_INTERRUPT		      (1<<27)
-#define AEU_INPUTS_ATTN_BITS_UPB_PARITY_ERROR		      (1<<26)
-#define AEU_INPUTS_ATTN_BITS_USDM_HW_INTERRUPT		      (1<<21)
-#define AEU_INPUTS_ATTN_BITS_USDM_PARITY_ERROR		      (1<<20)
-#define AEU_INPUTS_ATTN_BITS_USEMI_HW_INTERRUPT 	      (1<<25)
-#define AEU_INPUTS_ATTN_BITS_USEMI_PARITY_ERROR 	      (1<<24)
-#define AEU_INPUTS_ATTN_BITS_VAUX_PCI_CORE_PARITY_ERROR       (1<<16)
-#define AEU_INPUTS_ATTN_BITS_XCM_HW_INTERRUPT		      (1<<9)
-#define AEU_INPUTS_ATTN_BITS_XSDM_HW_INTERRUPT		      (1<<7)
-#define AEU_INPUTS_ATTN_BITS_XSDM_PARITY_ERROR		      (1<<6)
-#define AEU_INPUTS_ATTN_BITS_XSEMI_HW_INTERRUPT 	      (1<<11)
-#define AEU_INPUTS_ATTN_BITS_XSEMI_PARITY_ERROR 	      (1<<10)
-#define RESERVED_GENERAL_ATTENTION_BIT_0	0
-
-#define EVEREST_GEN_ATTN_IN_USE_MASK		0x3ffe0
-#define EVEREST_LATCHED_ATTN_IN_USE_MASK	0xffe00000
-
-#define RESERVED_GENERAL_ATTENTION_BIT_6	6
-#define RESERVED_GENERAL_ATTENTION_BIT_7	7
-#define RESERVED_GENERAL_ATTENTION_BIT_8	8
-#define RESERVED_GENERAL_ATTENTION_BIT_9	9
-#define RESERVED_GENERAL_ATTENTION_BIT_10	10
-#define RESERVED_GENERAL_ATTENTION_BIT_11	11
-#define RESERVED_GENERAL_ATTENTION_BIT_12	12
-#define RESERVED_GENERAL_ATTENTION_BIT_13	13
-#define RESERVED_GENERAL_ATTENTION_BIT_14	14
-#define RESERVED_GENERAL_ATTENTION_BIT_15	15
-#define RESERVED_GENERAL_ATTENTION_BIT_16	16
-#define RESERVED_GENERAL_ATTENTION_BIT_17	17
-#define RESERVED_GENERAL_ATTENTION_BIT_18	18
-#define RESERVED_GENERAL_ATTENTION_BIT_19	19
-#define RESERVED_GENERAL_ATTENTION_BIT_20	20
-#define RESERVED_GENERAL_ATTENTION_BIT_21	21
-
-/* storm asserts attention bits */
-#define TSTORM_FATAL_ASSERT_ATTENTION_BIT     RESERVED_GENERAL_ATTENTION_BIT_7
-#define USTORM_FATAL_ASSERT_ATTENTION_BIT     RESERVED_GENERAL_ATTENTION_BIT_8
-#define CSTORM_FATAL_ASSERT_ATTENTION_BIT     RESERVED_GENERAL_ATTENTION_BIT_9
-#define XSTORM_FATAL_ASSERT_ATTENTION_BIT     RESERVED_GENERAL_ATTENTION_BIT_10
-
-/* mcp error attention bit */
-#define MCP_FATAL_ASSERT_ATTENTION_BIT	      RESERVED_GENERAL_ATTENTION_BIT_11
-
-/*E1H NIG status sync attention mapped to group 4-7*/
-#define LINK_SYNC_ATTENTION_BIT_FUNC_0	    RESERVED_GENERAL_ATTENTION_BIT_12
-#define LINK_SYNC_ATTENTION_BIT_FUNC_1	    RESERVED_GENERAL_ATTENTION_BIT_13
-#define LINK_SYNC_ATTENTION_BIT_FUNC_2	    RESERVED_GENERAL_ATTENTION_BIT_14
-#define LINK_SYNC_ATTENTION_BIT_FUNC_3	    RESERVED_GENERAL_ATTENTION_BIT_15
-#define LINK_SYNC_ATTENTION_BIT_FUNC_4	    RESERVED_GENERAL_ATTENTION_BIT_16
-#define LINK_SYNC_ATTENTION_BIT_FUNC_5	    RESERVED_GENERAL_ATTENTION_BIT_17
-#define LINK_SYNC_ATTENTION_BIT_FUNC_6	    RESERVED_GENERAL_ATTENTION_BIT_18
-#define LINK_SYNC_ATTENTION_BIT_FUNC_7	    RESERVED_GENERAL_ATTENTION_BIT_19
-
-
-#define LATCHED_ATTN_RBCR			23
-#define LATCHED_ATTN_RBCT			24
-#define LATCHED_ATTN_RBCN			25
-#define LATCHED_ATTN_RBCU			26
-#define LATCHED_ATTN_RBCP			27
-#define LATCHED_ATTN_TIMEOUT_GRC		28
-#define LATCHED_ATTN_RSVD_GRC			29
-#define LATCHED_ATTN_ROM_PARITY_MCP		30
-#define LATCHED_ATTN_UM_RX_PARITY_MCP		31
-#define LATCHED_ATTN_UM_TX_PARITY_MCP		32
-#define LATCHED_ATTN_SCPAD_PARITY_MCP		33
-
-#define GENERAL_ATTEN_WORD(atten_name)	       ((94 + atten_name) / 32)
-#define GENERAL_ATTEN_OFFSET(atten_name)\
-	(1UL << ((94 + atten_name) % 32))
-/*
- * This file defines GRC base address for every block.
- * This file is included by chipsim, asm microcode and cpp microcode.
- * These values are used in Design.xml on regBase attribute
- * Use the base with the generated offsets of specific registers.
- */
-
-#define GRCBASE_PXPCS		0x000000
-#define GRCBASE_PCICONFIG	0x002000
-#define GRCBASE_PCIREG		0x002400
-#define GRCBASE_EMAC0		0x008000
-#define GRCBASE_EMAC1		0x008400
-#define GRCBASE_DBU		0x008800
-#define GRCBASE_MISC		0x00A000
-#define GRCBASE_DBG		0x00C000
-#define GRCBASE_NIG		0x010000
-#define GRCBASE_XCM		0x020000
-#define GRCBASE_PRS		0x040000
-#define GRCBASE_SRCH		0x040400
-#define GRCBASE_TSDM		0x042000
-#define GRCBASE_TCM		0x050000
-#define GRCBASE_BRB1		0x060000
-#define GRCBASE_MCP		0x080000
-#define GRCBASE_UPB		0x0C1000
-#define GRCBASE_CSDM		0x0C2000
-#define GRCBASE_USDM		0x0C4000
-#define GRCBASE_CCM		0x0D0000
-#define GRCBASE_UCM		0x0E0000
-#define GRCBASE_CDU		0x101000
-#define GRCBASE_DMAE		0x102000
-#define GRCBASE_PXP		0x103000
-#define GRCBASE_CFC		0x104000
-#define GRCBASE_HC		0x108000
-#define GRCBASE_PXP2		0x120000
-#define GRCBASE_PBF		0x140000
-#define GRCBASE_XPB		0x161000
-#define GRCBASE_TIMERS		0x164000
-#define GRCBASE_XSDM		0x166000
-#define GRCBASE_QM		0x168000
-#define GRCBASE_DQ		0x170000
-#define GRCBASE_TSEM		0x180000
-#define GRCBASE_CSEM		0x200000
-#define GRCBASE_XSEM		0x280000
-#define GRCBASE_USEM		0x300000
-#define GRCBASE_MISC_AEU	GRCBASE_MISC
-
-
-/* offset of configuration space in the pci core register */
-#define PCICFG_OFFSET					0x2000
-#define PCICFG_VENDOR_ID_OFFSET 			0x00
-#define PCICFG_DEVICE_ID_OFFSET 			0x02
-#define PCICFG_COMMAND_OFFSET				0x04
-#define PCICFG_COMMAND_IO_SPACE 		(1<<0)
-#define PCICFG_COMMAND_MEM_SPACE		(1<<1)
-#define PCICFG_COMMAND_BUS_MASTER		(1<<2)
-#define PCICFG_COMMAND_SPECIAL_CYCLES		(1<<3)
-#define PCICFG_COMMAND_MWI_CYCLES		(1<<4)
-#define PCICFG_COMMAND_VGA_SNOOP		(1<<5)
-#define PCICFG_COMMAND_PERR_ENA 		(1<<6)
-#define PCICFG_COMMAND_STEPPING 		(1<<7)
-#define PCICFG_COMMAND_SERR_ENA 		(1<<8)
-#define PCICFG_COMMAND_FAST_B2B 		(1<<9)
-#define PCICFG_COMMAND_INT_DISABLE		(1<<10)
-#define PCICFG_COMMAND_RESERVED 		(0x1f<<11)
-#define PCICFG_STATUS_OFFSET				0x06
-#define PCICFG_REVESION_ID_OFFSET			0x08
-#define PCICFG_CACHE_LINE_SIZE				0x0c
-#define PCICFG_LATENCY_TIMER				0x0d
-#define PCICFG_BAR_1_LOW				0x10
-#define PCICFG_BAR_1_HIGH				0x14
-#define PCICFG_BAR_2_LOW				0x18
-#define PCICFG_BAR_2_HIGH				0x1c
-#define PCICFG_SUBSYSTEM_VENDOR_ID_OFFSET		0x2c
-#define PCICFG_SUBSYSTEM_ID_OFFSET			0x2e
-#define PCICFG_INT_LINE 				0x3c
-#define PCICFG_INT_PIN					0x3d
-#define PCICFG_PM_CAPABILITY				0x48
-#define PCICFG_PM_CAPABILITY_VERSION		(0x3<<16)
-#define PCICFG_PM_CAPABILITY_CLOCK		(1<<19)
-#define PCICFG_PM_CAPABILITY_RESERVED		(1<<20)
-#define PCICFG_PM_CAPABILITY_DSI		(1<<21)
-#define PCICFG_PM_CAPABILITY_AUX_CURRENT	(0x7<<22)
-#define PCICFG_PM_CAPABILITY_D1_SUPPORT 	(1<<25)
-#define PCICFG_PM_CAPABILITY_D2_SUPPORT 	(1<<26)
-#define PCICFG_PM_CAPABILITY_PME_IN_D0		(1<<27)
-#define PCICFG_PM_CAPABILITY_PME_IN_D1		(1<<28)
-#define PCICFG_PM_CAPABILITY_PME_IN_D2		(1<<29)
-#define PCICFG_PM_CAPABILITY_PME_IN_D3_HOT	(1<<30)
-#define PCICFG_PM_CAPABILITY_PME_IN_D3_COLD	(1<<31)
-#define PCICFG_PM_CSR_OFFSET				0x4c
-#define PCICFG_PM_CSR_STATE			(0x3<<0)
-#define PCICFG_PM_CSR_PME_ENABLE		(1<<8)
-#define PCICFG_PM_CSR_PME_STATUS		(1<<15)
-#define PCICFG_MSI_CAP_ID_OFFSET			0x58
-#define PCICFG_MSI_CONTROL_ENABLE		(0x1<<16)
-#define PCICFG_MSI_CONTROL_MCAP 		(0x7<<17)
-#define PCICFG_MSI_CONTROL_MENA 		(0x7<<20)
-#define PCICFG_MSI_CONTROL_64_BIT_ADDR_CAP	(0x1<<23)
-#define PCICFG_MSI_CONTROL_MSI_PVMASK_CAPABLE	(0x1<<24)
-#define PCICFG_GRC_ADDRESS				0x78
-#define PCICFG_GRC_DATA 				0x80
-#define PCICFG_MSIX_CAP_ID_OFFSET			0xa0
-#define PCICFG_MSIX_CONTROL_TABLE_SIZE		(0x7ff<<16)
-#define PCICFG_MSIX_CONTROL_RESERVED		(0x7<<27)
-#define PCICFG_MSIX_CONTROL_FUNC_MASK		(0x1<<30)
-#define PCICFG_MSIX_CONTROL_MSIX_ENABLE 	(0x1<<31)
-
-#define PCICFG_DEVICE_CONTROL				0xb4
-#define PCICFG_DEVICE_STATUS				0xb6
-#define PCICFG_DEVICE_STATUS_CORR_ERR_DET	(1<<0)
-#define PCICFG_DEVICE_STATUS_NON_FATAL_ERR_DET	(1<<1)
-#define PCICFG_DEVICE_STATUS_FATAL_ERR_DET	(1<<2)
-#define PCICFG_DEVICE_STATUS_UNSUP_REQ_DET	(1<<3)
-#define PCICFG_DEVICE_STATUS_AUX_PWR_DET	(1<<4)
-#define PCICFG_DEVICE_STATUS_NO_PEND		(1<<5)
-#define PCICFG_LINK_CONTROL				0xbc
-
-
-#define BAR_USTRORM_INTMEM				0x400000
-#define BAR_CSTRORM_INTMEM				0x410000
-#define BAR_XSTRORM_INTMEM				0x420000
-#define BAR_TSTRORM_INTMEM				0x430000
-
-/* for accessing the IGU in case of status block ACK */
-#define BAR_IGU_INTMEM					0x440000
-
-#define BAR_DOORBELL_OFFSET				0x800000
-
-#define BAR_ME_REGISTER 				0x450000
-
-/* config_2 offset */
-#define GRC_CONFIG_2_SIZE_REG				0x408
-#define PCI_CONFIG_2_BAR1_SIZE			(0xfL<<0)
-#define PCI_CONFIG_2_BAR1_SIZE_DISABLED 	(0L<<0)
-#define PCI_CONFIG_2_BAR1_SIZE_64K		(1L<<0)
-#define PCI_CONFIG_2_BAR1_SIZE_128K		(2L<<0)
-#define PCI_CONFIG_2_BAR1_SIZE_256K		(3L<<0)
-#define PCI_CONFIG_2_BAR1_SIZE_512K		(4L<<0)
-#define PCI_CONFIG_2_BAR1_SIZE_1M		(5L<<0)
-#define PCI_CONFIG_2_BAR1_SIZE_2M		(6L<<0)
-#define PCI_CONFIG_2_BAR1_SIZE_4M		(7L<<0)
-#define PCI_CONFIG_2_BAR1_SIZE_8M		(8L<<0)
-#define PCI_CONFIG_2_BAR1_SIZE_16M		(9L<<0)
-#define PCI_CONFIG_2_BAR1_SIZE_32M		(10L<<0)
-#define PCI_CONFIG_2_BAR1_SIZE_64M		(11L<<0)
-#define PCI_CONFIG_2_BAR1_SIZE_128M		(12L<<0)
-#define PCI_CONFIG_2_BAR1_SIZE_256M		(13L<<0)
-#define PCI_CONFIG_2_BAR1_SIZE_512M		(14L<<0)
-#define PCI_CONFIG_2_BAR1_SIZE_1G		(15L<<0)
-#define PCI_CONFIG_2_BAR1_64ENA 		(1L<<4)
-#define PCI_CONFIG_2_EXP_ROM_RETRY		(1L<<5)
-#define PCI_CONFIG_2_CFG_CYCLE_RETRY		(1L<<6)
-#define PCI_CONFIG_2_FIRST_CFG_DONE		(1L<<7)
-#define PCI_CONFIG_2_EXP_ROM_SIZE		(0xffL<<8)
-#define PCI_CONFIG_2_EXP_ROM_SIZE_DISABLED	(0L<<8)
-#define PCI_CONFIG_2_EXP_ROM_SIZE_2K		(1L<<8)
-#define PCI_CONFIG_2_EXP_ROM_SIZE_4K		(2L<<8)
-#define PCI_CONFIG_2_EXP_ROM_SIZE_8K		(3L<<8)
-#define PCI_CONFIG_2_EXP_ROM_SIZE_16K		(4L<<8)
-#define PCI_CONFIG_2_EXP_ROM_SIZE_32K		(5L<<8)
-#define PCI_CONFIG_2_EXP_ROM_SIZE_64K		(6L<<8)
-#define PCI_CONFIG_2_EXP_ROM_SIZE_128K		(7L<<8)
-#define PCI_CONFIG_2_EXP_ROM_SIZE_256K		(8L<<8)
-#define PCI_CONFIG_2_EXP_ROM_SIZE_512K		(9L<<8)
-#define PCI_CONFIG_2_EXP_ROM_SIZE_1M		(10L<<8)
-#define PCI_CONFIG_2_EXP_ROM_SIZE_2M		(11L<<8)
-#define PCI_CONFIG_2_EXP_ROM_SIZE_4M		(12L<<8)
-#define PCI_CONFIG_2_EXP_ROM_SIZE_8M		(13L<<8)
-#define PCI_CONFIG_2_EXP_ROM_SIZE_16M		(14L<<8)
-#define PCI_CONFIG_2_EXP_ROM_SIZE_32M		(15L<<8)
-#define PCI_CONFIG_2_BAR_PREFETCH		(1L<<16)
-#define PCI_CONFIG_2_RESERVED0			(0x7fffL<<17)
-
-/* config_3 offset */
-#define GRC_CONFIG_3_SIZE_REG				0x40c
-#define PCI_CONFIG_3_STICKY_BYTE		(0xffL<<0)
-#define PCI_CONFIG_3_FORCE_PME			(1L<<24)
-#define PCI_CONFIG_3_PME_STATUS 		(1L<<25)
-#define PCI_CONFIG_3_PME_ENABLE 		(1L<<26)
-#define PCI_CONFIG_3_PM_STATE			(0x3L<<27)
-#define PCI_CONFIG_3_VAUX_PRESET		(1L<<30)
-#define PCI_CONFIG_3_PCI_POWER			(1L<<31)
-
-#define GRC_BAR2_CONFIG 				0x4e0
-#define PCI_CONFIG_2_BAR2_SIZE			(0xfL<<0)
-#define PCI_CONFIG_2_BAR2_SIZE_DISABLED 	(0L<<0)
-#define PCI_CONFIG_2_BAR2_SIZE_64K		(1L<<0)
-#define PCI_CONFIG_2_BAR2_SIZE_128K		(2L<<0)
-#define PCI_CONFIG_2_BAR2_SIZE_256K		(3L<<0)
-#define PCI_CONFIG_2_BAR2_SIZE_512K		(4L<<0)
-#define PCI_CONFIG_2_BAR2_SIZE_1M		(5L<<0)
-#define PCI_CONFIG_2_BAR2_SIZE_2M		(6L<<0)
-#define PCI_CONFIG_2_BAR2_SIZE_4M		(7L<<0)
-#define PCI_CONFIG_2_BAR2_SIZE_8M		(8L<<0)
-#define PCI_CONFIG_2_BAR2_SIZE_16M		(9L<<0)
-#define PCI_CONFIG_2_BAR2_SIZE_32M		(10L<<0)
-#define PCI_CONFIG_2_BAR2_SIZE_64M		(11L<<0)
-#define PCI_CONFIG_2_BAR2_SIZE_128M		(12L<<0)
-#define PCI_CONFIG_2_BAR2_SIZE_256M		(13L<<0)
-#define PCI_CONFIG_2_BAR2_SIZE_512M		(14L<<0)
-#define PCI_CONFIG_2_BAR2_SIZE_1G		(15L<<0)
-#define PCI_CONFIG_2_BAR2_64ENA 		(1L<<4)
-
-#define PCI_PM_DATA_A					0x410
-#define PCI_PM_DATA_B					0x414
-#define PCI_ID_VAL1					0x434
-#define PCI_ID_VAL2					0x438
-
-
-#define MDIO_REG_BANK_CL73_IEEEB0	0x0
-#define MDIO_CL73_IEEEB0_CL73_AN_CONTROL	0x0
-#define MDIO_CL73_IEEEB0_CL73_AN_CONTROL_RESTART_AN	0x0200
-#define MDIO_CL73_IEEEB0_CL73_AN_CONTROL_AN_EN		0x1000
-#define MDIO_CL73_IEEEB0_CL73_AN_CONTROL_MAIN_RST	0x8000
-
-#define MDIO_REG_BANK_CL73_IEEEB1	0x10
-#define MDIO_CL73_IEEEB1_AN_ADV1		0x00
-#define MDIO_CL73_IEEEB1_AN_ADV1_PAUSE			0x0400
-#define MDIO_CL73_IEEEB1_AN_ADV1_ASYMMETRIC		0x0800
-#define MDIO_CL73_IEEEB1_AN_ADV1_PAUSE_BOTH		0x0C00
-#define MDIO_CL73_IEEEB1_AN_ADV1_PAUSE_MASK		0x0C00
-#define MDIO_CL73_IEEEB1_AN_ADV2		0x01
-#define MDIO_CL73_IEEEB1_AN_ADV2_ADVR_1000M		0x0000
-#define MDIO_CL73_IEEEB1_AN_ADV2_ADVR_1000M_KX		0x0020
-#define MDIO_CL73_IEEEB1_AN_ADV2_ADVR_10G_KX4		0x0040
-#define MDIO_CL73_IEEEB1_AN_ADV2_ADVR_10G_KR		0x0080
-#define MDIO_CL73_IEEEB1_AN_LP_ADV1		0x03
-#define MDIO_CL73_IEEEB1_AN_LP_ADV1_PAUSE		0x0400
-#define MDIO_CL73_IEEEB1_AN_LP_ADV1_ASYMMETRIC		0x0800
-#define MDIO_CL73_IEEEB1_AN_LP_ADV1_PAUSE_BOTH		0x0C00
-#define MDIO_CL73_IEEEB1_AN_LP_ADV1_PAUSE_MASK		0x0C00
-
-#define MDIO_REG_BANK_RX0				0x80b0
-#define MDIO_RX0_RX_STATUS				0x10
-#define MDIO_RX0_RX_STATUS_SIGDET			0x8000
-#define MDIO_RX0_RX_STATUS_RX_SEQ_DONE			0x1000
-#define MDIO_RX0_RX_EQ_BOOST				0x1c
-#define MDIO_RX0_RX_EQ_BOOST_EQUALIZER_CTRL_MASK	0x7
-#define MDIO_RX0_RX_EQ_BOOST_OFFSET_CTRL		0x10
-
-#define MDIO_REG_BANK_RX1				0x80c0
-#define MDIO_RX1_RX_EQ_BOOST				0x1c
-#define MDIO_RX1_RX_EQ_BOOST_EQUALIZER_CTRL_MASK	0x7
-#define MDIO_RX1_RX_EQ_BOOST_OFFSET_CTRL		0x10
-
-#define MDIO_REG_BANK_RX2				0x80d0
-#define MDIO_RX2_RX_EQ_BOOST				0x1c
-#define MDIO_RX2_RX_EQ_BOOST_EQUALIZER_CTRL_MASK	0x7
-#define MDIO_RX2_RX_EQ_BOOST_OFFSET_CTRL		0x10
-
-#define MDIO_REG_BANK_RX3				0x80e0
-#define MDIO_RX3_RX_EQ_BOOST				0x1c
-#define MDIO_RX3_RX_EQ_BOOST_EQUALIZER_CTRL_MASK	0x7
-#define MDIO_RX3_RX_EQ_BOOST_OFFSET_CTRL		0x10
-
-#define MDIO_REG_BANK_RX_ALL				0x80f0
-#define MDIO_RX_ALL_RX_EQ_BOOST 			0x1c
-#define MDIO_RX_ALL_RX_EQ_BOOST_EQUALIZER_CTRL_MASK	0x7
-#define MDIO_RX_ALL_RX_EQ_BOOST_OFFSET_CTRL	0x10
-
-#define MDIO_REG_BANK_TX0				0x8060
-#define MDIO_TX0_TX_DRIVER				0x17
-#define MDIO_TX0_TX_DRIVER_PREEMPHASIS_MASK		0xf000
-#define MDIO_TX0_TX_DRIVER_PREEMPHASIS_SHIFT		12
-#define MDIO_TX0_TX_DRIVER_IDRIVER_MASK 		0x0f00
-#define MDIO_TX0_TX_DRIVER_IDRIVER_SHIFT		8
-#define MDIO_TX0_TX_DRIVER_IPREDRIVER_MASK		0x00f0
-#define MDIO_TX0_TX_DRIVER_IPREDRIVER_SHIFT		4
-#define MDIO_TX0_TX_DRIVER_IFULLSPD_MASK		0x000e
-#define MDIO_TX0_TX_DRIVER_IFULLSPD_SHIFT		1
-#define MDIO_TX0_TX_DRIVER_ICBUF1T			1
-
-#define MDIO_REG_BANK_TX1				0x8070
-#define MDIO_TX1_TX_DRIVER				0x17
-#define MDIO_TX0_TX_DRIVER_PREEMPHASIS_MASK		0xf000
-#define MDIO_TX0_TX_DRIVER_PREEMPHASIS_SHIFT		12
-#define MDIO_TX0_TX_DRIVER_IDRIVER_MASK 		0x0f00
-#define MDIO_TX0_TX_DRIVER_IDRIVER_SHIFT		8
-#define MDIO_TX0_TX_DRIVER_IPREDRIVER_MASK		0x00f0
-#define MDIO_TX0_TX_DRIVER_IPREDRIVER_SHIFT		4
-#define MDIO_TX0_TX_DRIVER_IFULLSPD_MASK		0x000e
-#define MDIO_TX0_TX_DRIVER_IFULLSPD_SHIFT		1
-#define MDIO_TX0_TX_DRIVER_ICBUF1T			1
-
-#define MDIO_REG_BANK_TX2				0x8080
-#define MDIO_TX2_TX_DRIVER				0x17
-#define MDIO_TX0_TX_DRIVER_PREEMPHASIS_MASK		0xf000
-#define MDIO_TX0_TX_DRIVER_PREEMPHASIS_SHIFT		12
-#define MDIO_TX0_TX_DRIVER_IDRIVER_MASK 		0x0f00
-#define MDIO_TX0_TX_DRIVER_IDRIVER_SHIFT		8
-#define MDIO_TX0_TX_DRIVER_IPREDRIVER_MASK		0x00f0
-#define MDIO_TX0_TX_DRIVER_IPREDRIVER_SHIFT		4
-#define MDIO_TX0_TX_DRIVER_IFULLSPD_MASK		0x000e
-#define MDIO_TX0_TX_DRIVER_IFULLSPD_SHIFT		1
-#define MDIO_TX0_TX_DRIVER_ICBUF1T			1
-
-#define MDIO_REG_BANK_TX3				0x8090
-#define MDIO_TX3_TX_DRIVER				0x17
-#define MDIO_TX0_TX_DRIVER_PREEMPHASIS_MASK		0xf000
-#define MDIO_TX0_TX_DRIVER_PREEMPHASIS_SHIFT		12
-#define MDIO_TX0_TX_DRIVER_IDRIVER_MASK 		0x0f00
-#define MDIO_TX0_TX_DRIVER_IDRIVER_SHIFT		8
-#define MDIO_TX0_TX_DRIVER_IPREDRIVER_MASK		0x00f0
-#define MDIO_TX0_TX_DRIVER_IPREDRIVER_SHIFT		4
-#define MDIO_TX0_TX_DRIVER_IFULLSPD_MASK		0x000e
-#define MDIO_TX0_TX_DRIVER_IFULLSPD_SHIFT		1
-#define MDIO_TX0_TX_DRIVER_ICBUF1T			1
-
-#define MDIO_REG_BANK_XGXS_BLOCK0			0x8000
-#define MDIO_BLOCK0_XGXS_CONTROL			0x10
-
-#define MDIO_REG_BANK_XGXS_BLOCK1			0x8010
-#define MDIO_BLOCK1_LANE_CTRL0				0x15
-#define MDIO_BLOCK1_LANE_CTRL1				0x16
-#define MDIO_BLOCK1_LANE_CTRL2				0x17
-#define MDIO_BLOCK1_LANE_PRBS				0x19
-
-#define MDIO_REG_BANK_XGXS_BLOCK2			0x8100
-#define MDIO_XGXS_BLOCK2_RX_LN_SWAP			0x10
-#define MDIO_XGXS_BLOCK2_RX_LN_SWAP_ENABLE		0x8000
-#define MDIO_XGXS_BLOCK2_RX_LN_SWAP_FORCE_ENABLE	0x4000
-#define MDIO_XGXS_BLOCK2_TX_LN_SWAP		0x11
-#define MDIO_XGXS_BLOCK2_TX_LN_SWAP_ENABLE		0x8000
-#define MDIO_XGXS_BLOCK2_UNICORE_MODE_10G	0x14
-#define MDIO_XGXS_BLOCK2_UNICORE_MODE_10G_CX4_XGXS	0x0001
-#define MDIO_XGXS_BLOCK2_UNICORE_MODE_10G_HIGIG_XGXS	0x0010
-#define MDIO_XGXS_BLOCK2_TEST_MODE_LANE 	0x15
-
-#define MDIO_REG_BANK_GP_STATUS 			0x8120
-#define MDIO_GP_STATUS_TOP_AN_STATUS1				0x1B
-#define MDIO_GP_STATUS_TOP_AN_STATUS1_CL73_AUTONEG_COMPLETE	0x0001
-#define MDIO_GP_STATUS_TOP_AN_STATUS1_CL37_AUTONEG_COMPLETE	0x0002
-#define MDIO_GP_STATUS_TOP_AN_STATUS1_LINK_STATUS		0x0004
-#define MDIO_GP_STATUS_TOP_AN_STATUS1_DUPLEX_STATUS		0x0008
-#define MDIO_GP_STATUS_TOP_AN_STATUS1_CL73_MR_LP_NP_AN_ABLE	0x0010
-#define MDIO_GP_STATUS_TOP_AN_STATUS1_CL73_LP_NP_BAM_ABLE	0x0020
-#define MDIO_GP_STATUS_TOP_AN_STATUS1_PAUSE_RSOLUTION_TXSIDE	0x0040
-#define MDIO_GP_STATUS_TOP_AN_STATUS1_PAUSE_RSOLUTION_RXSIDE	0x0080
-#define MDIO_GP_STATUS_TOP_AN_STATUS1_ACTUAL_SPEED_MASK 	0x3f00
-#define MDIO_GP_STATUS_TOP_AN_STATUS1_ACTUAL_SPEED_10M		0x0000
-#define MDIO_GP_STATUS_TOP_AN_STATUS1_ACTUAL_SPEED_100M 	0x0100
-#define MDIO_GP_STATUS_TOP_AN_STATUS1_ACTUAL_SPEED_1G		0x0200
-#define MDIO_GP_STATUS_TOP_AN_STATUS1_ACTUAL_SPEED_2_5G 	0x0300
-#define MDIO_GP_STATUS_TOP_AN_STATUS1_ACTUAL_SPEED_5G		0x0400
-#define MDIO_GP_STATUS_TOP_AN_STATUS1_ACTUAL_SPEED_6G		0x0500
-#define MDIO_GP_STATUS_TOP_AN_STATUS1_ACTUAL_SPEED_10G_HIG	0x0600
-#define MDIO_GP_STATUS_TOP_AN_STATUS1_ACTUAL_SPEED_10G_CX4	0x0700
-#define MDIO_GP_STATUS_TOP_AN_STATUS1_ACTUAL_SPEED_12G_HIG	0x0800
-#define MDIO_GP_STATUS_TOP_AN_STATUS1_ACTUAL_SPEED_12_5G	0x0900
-#define MDIO_GP_STATUS_TOP_AN_STATUS1_ACTUAL_SPEED_13G		0x0A00
-#define MDIO_GP_STATUS_TOP_AN_STATUS1_ACTUAL_SPEED_15G		0x0B00
-#define MDIO_GP_STATUS_TOP_AN_STATUS1_ACTUAL_SPEED_16G		0x0C00
-#define MDIO_GP_STATUS_TOP_AN_STATUS1_ACTUAL_SPEED_1G_KX	0x0D00
-#define MDIO_GP_STATUS_TOP_AN_STATUS1_ACTUAL_SPEED_10G_KX4	0x0E00
-
-
-#define MDIO_REG_BANK_10G_PARALLEL_DETECT		0x8130
-#define MDIO_10G_PARALLEL_DETECT_PAR_DET_10G_STATUS		0x10
-#define MDIO_10G_PARALLEL_DETECT_PAR_DET_10G_STATUS_PD_LINK		0x8000
-#define MDIO_10G_PARALLEL_DETECT_PAR_DET_10G_CONTROL		0x11
-#define MDIO_10G_PARALLEL_DETECT_PAR_DET_10G_CONTROL_PARDET10G_EN	0x1
-#define MDIO_10G_PARALLEL_DETECT_PAR_DET_10G_LINK		0x13
-#define MDIO_10G_PARALLEL_DETECT_PAR_DET_10G_LINK_CNT		(0xb71<<1)
-
-#define MDIO_REG_BANK_SERDES_DIGITAL			0x8300
-#define MDIO_SERDES_DIGITAL_A_1000X_CONTROL1			0x10
-#define MDIO_SERDES_DIGITAL_A_1000X_CONTROL1_FIBER_MODE 		0x0001
-#define MDIO_SERDES_DIGITAL_A_1000X_CONTROL1_TBI_IF			0x0002
-#define MDIO_SERDES_DIGITAL_A_1000X_CONTROL1_SIGNAL_DETECT_EN		0x0004
-#define MDIO_SERDES_DIGITAL_A_1000X_CONTROL1_INVERT_SIGNAL_DETECT	0x0008
-#define MDIO_SERDES_DIGITAL_A_1000X_CONTROL1_AUTODET			0x0010
-#define MDIO_SERDES_DIGITAL_A_1000X_CONTROL1_MSTR_MODE			0x0020
-#define MDIO_SERDES_DIGITAL_A_1000X_CONTROL2			0x11
-#define MDIO_SERDES_DIGITAL_A_1000X_CONTROL2_PRL_DT_EN			0x0001
-#define MDIO_SERDES_DIGITAL_A_1000X_CONTROL2_AN_FST_TMR 		0x0040
-#define MDIO_SERDES_DIGITAL_A_1000X_STATUS1			0x14
-#define MDIO_SERDES_DIGITAL_A_1000X_STATUS1_DUPLEX			0x0004
-#define MDIO_SERDES_DIGITAL_A_1000X_STATUS1_SPEED_MASK			0x0018
-#define MDIO_SERDES_DIGITAL_A_1000X_STATUS1_SPEED_SHIFT 		3
-#define MDIO_SERDES_DIGITAL_A_1000X_STATUS1_SPEED_2_5G			0x0018
-#define MDIO_SERDES_DIGITAL_A_1000X_STATUS1_SPEED_1G			0x0010
-#define MDIO_SERDES_DIGITAL_A_1000X_STATUS1_SPEED_100M			0x0008
-#define MDIO_SERDES_DIGITAL_A_1000X_STATUS1_SPEED_10M			0x0000
-#define MDIO_SERDES_DIGITAL_A_1000X_STATUS2			0x15
-#define MDIO_SERDES_DIGITAL_A_1000X_STATUS2_AN_DISABLED 		0x0002
-#define MDIO_SERDES_DIGITAL_MISC1				0x18
-#define MDIO_SERDES_DIGITAL_MISC1_REFCLK_SEL_MASK			0xE000
-#define MDIO_SERDES_DIGITAL_MISC1_REFCLK_SEL_25M			0x0000
-#define MDIO_SERDES_DIGITAL_MISC1_REFCLK_SEL_100M			0x2000
-#define MDIO_SERDES_DIGITAL_MISC1_REFCLK_SEL_125M			0x4000
-#define MDIO_SERDES_DIGITAL_MISC1_REFCLK_SEL_156_25M			0x6000
-#define MDIO_SERDES_DIGITAL_MISC1_REFCLK_SEL_187_5M			0x8000
-#define MDIO_SERDES_DIGITAL_MISC1_FORCE_SPEED_SEL			0x0010
-#define MDIO_SERDES_DIGITAL_MISC1_FORCE_SPEED_MASK			0x000f
-#define MDIO_SERDES_DIGITAL_MISC1_FORCE_SPEED_2_5G			0x0000
-#define MDIO_SERDES_DIGITAL_MISC1_FORCE_SPEED_5G			0x0001
-#define MDIO_SERDES_DIGITAL_MISC1_FORCE_SPEED_6G			0x0002
-#define MDIO_SERDES_DIGITAL_MISC1_FORCE_SPEED_10G_HIG			0x0003
-#define MDIO_SERDES_DIGITAL_MISC1_FORCE_SPEED_10G_CX4			0x0004
-#define MDIO_SERDES_DIGITAL_MISC1_FORCE_SPEED_12G			0x0005
-#define MDIO_SERDES_DIGITAL_MISC1_FORCE_SPEED_12_5G			0x0006
-#define MDIO_SERDES_DIGITAL_MISC1_FORCE_SPEED_13G			0x0007
-#define MDIO_SERDES_DIGITAL_MISC1_FORCE_SPEED_15G			0x0008
-#define MDIO_SERDES_DIGITAL_MISC1_FORCE_SPEED_16G			0x0009
-
-#define MDIO_REG_BANK_OVER_1G				0x8320
-#define MDIO_OVER_1G_DIGCTL_3_4 				0x14
-#define MDIO_OVER_1G_DIGCTL_3_4_MP_ID_MASK				0xffe0
-#define MDIO_OVER_1G_DIGCTL_3_4_MP_ID_SHIFT				5
-#define MDIO_OVER_1G_UP1					0x19
-#define MDIO_OVER_1G_UP1_2_5G						0x0001
-#define MDIO_OVER_1G_UP1_5G						0x0002
-#define MDIO_OVER_1G_UP1_6G						0x0004
-#define MDIO_OVER_1G_UP1_10G						0x0010
-#define MDIO_OVER_1G_UP1_10GH						0x0008
-#define MDIO_OVER_1G_UP1_12G						0x0020
-#define MDIO_OVER_1G_UP1_12_5G						0x0040
-#define MDIO_OVER_1G_UP1_13G						0x0080
-#define MDIO_OVER_1G_UP1_15G						0x0100
-#define MDIO_OVER_1G_UP1_16G						0x0200
-#define MDIO_OVER_1G_UP2					0x1A
-#define MDIO_OVER_1G_UP2_IPREDRIVER_MASK				0x0007
-#define MDIO_OVER_1G_UP2_IDRIVER_MASK					0x0038
-#define MDIO_OVER_1G_UP2_PREEMPHASIS_MASK				0x03C0
-#define MDIO_OVER_1G_UP3					0x1B
-#define MDIO_OVER_1G_UP3_HIGIG2 					0x0001
-#define MDIO_OVER_1G_LP_UP1					0x1C
-#define MDIO_OVER_1G_LP_UP2					0x1D
-#define MDIO_OVER_1G_LP_UP2_MR_ADV_OVER_1G_MASK 			0x03ff
-#define MDIO_OVER_1G_LP_UP2_PREEMPHASIS_MASK				0x0780
-#define MDIO_OVER_1G_LP_UP2_PREEMPHASIS_SHIFT				7
-#define MDIO_OVER_1G_LP_UP3						0x1E
-
-#define MDIO_REG_BANK_REMOTE_PHY			0x8330
-#define MDIO_REMOTE_PHY_MISC_RX_STATUS				0x10
-#define MDIO_REMOTE_PHY_MISC_RX_STATUS_CL37_FSM_RECEIVED_OVER1G_MSG	0x0010
-#define MDIO_REMOTE_PHY_MISC_RX_STATUS_CL37_FSM_RECEIVED_BRCM_OUI_MSG	0x0600
-
-#define MDIO_REG_BANK_BAM_NEXT_PAGE			0x8350
-#define MDIO_BAM_NEXT_PAGE_MP5_NEXT_PAGE_CTRL			0x10
-#define MDIO_BAM_NEXT_PAGE_MP5_NEXT_PAGE_CTRL_BAM_MODE			0x0001
-#define MDIO_BAM_NEXT_PAGE_MP5_NEXT_PAGE_CTRL_TETON_AN			0x0002
-
-#define MDIO_REG_BANK_CL73_USERB0		0x8370
-#define MDIO_CL73_USERB0_CL73_UCTRL				0x10
-#define MDIO_CL73_USERB0_CL73_UCTRL_USTAT1_MUXSEL			0x0002
-#define MDIO_CL73_USERB0_CL73_USTAT1				0x11
-#define MDIO_CL73_USERB0_CL73_USTAT1_LINK_STATUS_CHECK			0x0100
-#define MDIO_CL73_USERB0_CL73_USTAT1_AN_GOOD_CHECK_BAM37		0x0400
-#define MDIO_CL73_USERB0_CL73_BAM_CTRL1 			0x12
-#define MDIO_CL73_USERB0_CL73_BAM_CTRL1_BAM_EN				0x8000
-#define MDIO_CL73_USERB0_CL73_BAM_CTRL1_BAM_STATION_MNGR_EN		0x4000
-#define MDIO_CL73_USERB0_CL73_BAM_CTRL1_BAM_NP_AFTER_BP_EN		0x2000
-#define MDIO_CL73_USERB0_CL73_BAM_CTRL3 			0x14
-#define MDIO_CL73_USERB0_CL73_BAM_CTRL3_USE_CL73_HCD_MR 		0x0001
-
-#define MDIO_REG_BANK_AER_BLOCK 		0xFFD0
-#define MDIO_AER_BLOCK_AER_REG					0x1E
-
-#define MDIO_REG_BANK_COMBO_IEEE0		0xFFE0
-#define MDIO_COMBO_IEEE0_MII_CONTROL				0x10
-#define MDIO_COMBO_IEEO_MII_CONTROL_MAN_SGMII_SP_MASK			0x2040
-#define MDIO_COMBO_IEEO_MII_CONTROL_MAN_SGMII_SP_10			0x0000
-#define MDIO_COMBO_IEEO_MII_CONTROL_MAN_SGMII_SP_100			0x2000
-#define MDIO_COMBO_IEEO_MII_CONTROL_MAN_SGMII_SP_1000			0x0040
-#define MDIO_COMBO_IEEO_MII_CONTROL_FULL_DUPLEX 			0x0100
-#define MDIO_COMBO_IEEO_MII_CONTROL_RESTART_AN				0x0200
-#define MDIO_COMBO_IEEO_MII_CONTROL_AN_EN				0x1000
-#define MDIO_COMBO_IEEO_MII_CONTROL_LOOPBACK				0x4000
-#define MDIO_COMBO_IEEO_MII_CONTROL_RESET				0x8000
-#define MDIO_COMBO_IEEE0_MII_STATUS				0x11
-#define MDIO_COMBO_IEEE0_MII_STATUS_LINK_PASS				0x0004
-#define MDIO_COMBO_IEEE0_MII_STATUS_AUTONEG_COMPLETE			0x0020
-#define MDIO_COMBO_IEEE0_AUTO_NEG_ADV				0x14
-#define MDIO_COMBO_IEEE0_AUTO_NEG_ADV_FULL_DUPLEX			0x0020
-#define MDIO_COMBO_IEEE0_AUTO_NEG_ADV_HALF_DUPLEX			0x0040
-#define MDIO_COMBO_IEEE0_AUTO_NEG_ADV_PAUSE_MASK			0x0180
-#define MDIO_COMBO_IEEE0_AUTO_NEG_ADV_PAUSE_NONE			0x0000
-#define MDIO_COMBO_IEEE0_AUTO_NEG_ADV_PAUSE_SYMMETRIC			0x0080
-#define MDIO_COMBO_IEEE0_AUTO_NEG_ADV_PAUSE_ASYMMETRIC			0x0100
-#define MDIO_COMBO_IEEE0_AUTO_NEG_ADV_PAUSE_BOTH			0x0180
-#define MDIO_COMBO_IEEE0_AUTO_NEG_ADV_NEXT_PAGE 			0x8000
-#define MDIO_COMBO_IEEE0_AUTO_NEG_LINK_PARTNER_ABILITY1 	0x15
-#define MDIO_COMBO_IEEE0_AUTO_NEG_LINK_PARTNER_ABILITY1_NEXT_PAGE	0x8000
-#define MDIO_COMBO_IEEE0_AUTO_NEG_LINK_PARTNER_ABILITY1_ACK		0x4000
-#define MDIO_COMBO_IEEE0_AUTO_NEG_LINK_PARTNER_ABILITY1_PAUSE_MASK	0x0180
-#define MDIO_COMBO_IEEE0_AUTO_NEG_LINK_PARTNER_ABILITY1_PAUSE_NONE	0x0000
-#define MDIO_COMBO_IEEE0_AUTO_NEG_LINK_PARTNER_ABILITY1_PAUSE_BOTH	0x0180
-#define MDIO_COMBO_IEEE0_AUTO_NEG_LINK_PARTNER_ABILITY1_HALF_DUP_CAP	0x0040
-#define MDIO_COMBO_IEEE0_AUTO_NEG_LINK_PARTNER_ABILITY1_FULL_DUP_CAP	0x0020
-/*WhenthelinkpartnerisinSGMIImode(bit0=1),then
-bit15=link,bit12=duplex,bits11:10=speed,bit14=acknowledge.
-Theotherbitsarereservedandshouldbezero*/
-#define MDIO_COMBO_IEEE0_AUTO_NEG_LINK_PARTNER_ABILITY1_SGMII_MODE	0x0001
-
-
-#define MDIO_PMA_DEVAD			0x1
-/*ieee*/
-#define MDIO_PMA_REG_CTRL		0x0
-#define MDIO_PMA_REG_STATUS		0x1
-#define MDIO_PMA_REG_10G_CTRL2		0x7
-#define MDIO_PMA_REG_RX_SD		0xa
-/*bcm*/
-#define MDIO_PMA_REG_BCM_CTRL		0x0096
-#define MDIO_PMA_REG_FEC_CTRL		0x00ab
-#define MDIO_PMA_REG_RX_ALARM_CTRL	0x9000
-#define MDIO_PMA_REG_LASI_CTRL		0x9002
-#define MDIO_PMA_REG_RX_ALARM		0x9003
-#define MDIO_PMA_REG_TX_ALARM		0x9004
-#define MDIO_PMA_REG_LASI_STATUS	0x9005
-#define MDIO_PMA_REG_PHY_IDENTIFIER	0xc800
-#define MDIO_PMA_REG_DIGITAL_CTRL	0xc808
-#define MDIO_PMA_REG_DIGITAL_STATUS	0xc809
-#define MDIO_PMA_REG_TX_POWER_DOWN	0xca02
-#define MDIO_PMA_REG_CMU_PLL_BYPASS	0xca09
-#define MDIO_PMA_REG_MISC_CTRL		0xca0a
-#define MDIO_PMA_REG_GEN_CTRL		0xca10
-#define MDIO_PMA_REG_GEN_CTRL_ROM_RESET_INTERNAL_MP	0x0188
-#define MDIO_PMA_REG_GEN_CTRL_ROM_MICRO_RESET		0x018a
-#define MDIO_PMA_REG_M8051_MSGIN_REG	0xca12
-#define MDIO_PMA_REG_M8051_MSGOUT_REG	0xca13
-#define MDIO_PMA_REG_ROM_VER1		0xca19
-#define MDIO_PMA_REG_ROM_VER2		0xca1a
-#define MDIO_PMA_REG_EDC_FFE_MAIN	0xca1b
-#define MDIO_PMA_REG_PLL_BANDWIDTH	0xca1d
-#define MDIO_PMA_REG_PLL_CTRL		0xca1e
-#define MDIO_PMA_REG_MISC_CTRL0 	0xca23
-#define MDIO_PMA_REG_LRM_MODE		0xca3f
-#define MDIO_PMA_REG_CDR_BANDWIDTH	0xca46
-#define MDIO_PMA_REG_MISC_CTRL1 	0xca85
-
-#define MDIO_PMA_REG_SFP_TWO_WIRE_CTRL		0x8000
-#define MDIO_PMA_REG_SFP_TWO_WIRE_CTRL_STATUS_MASK	0x000c
-#define MDIO_PMA_REG_SFP_TWO_WIRE_STATUS_IDLE		0x0000
-#define MDIO_PMA_REG_SFP_TWO_WIRE_STATUS_COMPLETE	0x0004
-#define MDIO_PMA_REG_SFP_TWO_WIRE_STATUS_IN_PROGRESS	0x0008
-#define MDIO_PMA_REG_SFP_TWO_WIRE_STATUS_FAILED 	0x000c
-#define MDIO_PMA_REG_SFP_TWO_WIRE_BYTE_CNT	0x8002
-#define MDIO_PMA_REG_SFP_TWO_WIRE_MEM_ADDR	0x8003
-#define MDIO_PMA_REG_8726_TWO_WIRE_DATA_BUF	0xc820
-#define MDIO_PMA_REG_8726_TWO_WIRE_DATA_MASK 0xff
-#define MDIO_PMA_REG_8726_TX_CTRL1		0xca01
-#define MDIO_PMA_REG_8726_TX_CTRL2		0xca05
-
-#define MDIO_PMA_REG_8727_TWO_WIRE_SLAVE_ADDR	0x8005
-#define MDIO_PMA_REG_8727_TWO_WIRE_DATA_BUF	0x8007
-#define MDIO_PMA_REG_8727_TWO_WIRE_DATA_MASK 0xff
-#define MDIO_PMA_REG_8727_MISC_CTRL		0x8309
-#define MDIO_PMA_REG_8727_TX_CTRL1		0xca02
-#define MDIO_PMA_REG_8727_TX_CTRL2		0xca05
-#define MDIO_PMA_REG_8727_PCS_OPT_CTRL		0xc808
-#define MDIO_PMA_REG_8727_GPIO_CTRL		0xc80e
-
-#define MDIO_PMA_REG_8073_CHIP_REV			0xc801
-#define MDIO_PMA_REG_8073_SPEED_LINK_STATUS		0xc820
-#define MDIO_PMA_REG_8073_XAUI_WA			0xc841
-
-#define MDIO_PMA_REG_7101_RESET 	0xc000
-#define MDIO_PMA_REG_7107_LED_CNTL	0xc007
-#define MDIO_PMA_REG_7101_VER1		0xc026
-#define MDIO_PMA_REG_7101_VER2		0xc027
-
-#define MDIO_PMA_REG_8481_PMD_SIGNAL	0xa811
-#define MDIO_PMA_REG_8481_LED1_MASK	0xa82c
-#define MDIO_PMA_REG_8481_LED2_MASK	0xa82f
-#define MDIO_PMA_REG_8481_LED3_MASK	0xa832
-#define MDIO_PMA_REG_8481_LED3_BLINK	0xa834
-#define MDIO_PMA_REG_8481_SIGNAL_MASK	0xa835
-#define MDIO_PMA_REG_8481_LINK_SIGNAL	0xa83b
-
-
-#define MDIO_WIS_DEVAD			0x2
-/*bcm*/
-#define MDIO_WIS_REG_LASI_CNTL		0x9002
-#define MDIO_WIS_REG_LASI_STATUS	0x9005
-
-#define MDIO_PCS_DEVAD			0x3
-#define MDIO_PCS_REG_STATUS		0x0020
-#define MDIO_PCS_REG_LASI_STATUS	0x9005
-#define MDIO_PCS_REG_7101_DSP_ACCESS	0xD000
-#define MDIO_PCS_REG_7101_SPI_MUX	0xD008
-#define MDIO_PCS_REG_7101_SPI_CTRL_ADDR 0xE12A
-#define MDIO_PCS_REG_7101_SPI_RESET_BIT (5)
-#define MDIO_PCS_REG_7101_SPI_FIFO_ADDR 0xE02A
-#define MDIO_PCS_REG_7101_SPI_FIFO_ADDR_WRITE_ENABLE_CMD (6)
-#define MDIO_PCS_REG_7101_SPI_FIFO_ADDR_BULK_ERASE_CMD	 (0xC7)
-#define MDIO_PCS_REG_7101_SPI_FIFO_ADDR_PAGE_PROGRAM_CMD (2)
-#define MDIO_PCS_REG_7101_SPI_BYTES_TO_TRANSFER_ADDR 0xE028
-
-
-#define MDIO_XS_DEVAD			0x4
-#define MDIO_XS_PLL_SEQUENCER		0x8000
-#define MDIO_XS_SFX7101_XGXS_TEST1	0xc00a
-
-#define MDIO_XS_8706_REG_BANK_RX0	0x80bc
-#define MDIO_XS_8706_REG_BANK_RX1	0x80cc
-#define MDIO_XS_8706_REG_BANK_RX2	0x80dc
-#define MDIO_XS_8706_REG_BANK_RX3	0x80ec
-#define MDIO_XS_8706_REG_BANK_RXA	0x80fc
-
-#define MDIO_AN_DEVAD			0x7
-/*ieee*/
-#define MDIO_AN_REG_CTRL		0x0000
-#define MDIO_AN_REG_STATUS		0x0001
-#define MDIO_AN_REG_STATUS_AN_COMPLETE		0x0020
-#define MDIO_AN_REG_ADV_PAUSE		0x0010
-#define MDIO_AN_REG_ADV_PAUSE_PAUSE		0x0400
-#define MDIO_AN_REG_ADV_PAUSE_ASYMMETRIC	0x0800
-#define MDIO_AN_REG_ADV_PAUSE_BOTH		0x0C00
-#define MDIO_AN_REG_ADV_PAUSE_MASK		0x0C00
-#define MDIO_AN_REG_ADV 		0x0011
-#define MDIO_AN_REG_ADV2		0x0012
-#define MDIO_AN_REG_LP_AUTO_NEG 	0x0013
-#define MDIO_AN_REG_MASTER_STATUS	0x0021
-/*bcm*/
-#define MDIO_AN_REG_LINK_STATUS 	0x8304
-#define MDIO_AN_REG_CL37_CL73		0x8370
-#define MDIO_AN_REG_CL37_AN		0xffe0
-#define MDIO_AN_REG_CL37_FC_LD		0xffe4
-#define MDIO_AN_REG_CL37_FC_LP		0xffe5
-
-#define MDIO_AN_REG_8073_2_5G		0x8329
-
-#define MDIO_AN_REG_8481_LEGACY_MII_CTRL	0xffe0
-#define MDIO_AN_REG_8481_LEGACY_AN_ADV		0xffe4
-#define MDIO_AN_REG_8481_1000T_CTRL		0xffe9
-#define MDIO_AN_REG_8481_EXPANSION_REG_RD_RW	0xfff5
-#define MDIO_AN_REG_8481_EXPANSION_REG_ACCESS	0xfff7
-#define MDIO_AN_REG_8481_LEGACY_SHADOW		0xfffc
-
-#define IGU_FUNC_BASE			0x0400
-
-#define IGU_ADDR_MSIX			0x0000
-#define IGU_ADDR_INT_ACK		0x0200
-#define IGU_ADDR_PROD_UPD		0x0201
-#define IGU_ADDR_ATTN_BITS_UPD	0x0202
-#define IGU_ADDR_ATTN_BITS_SET	0x0203
-#define IGU_ADDR_ATTN_BITS_CLR	0x0204
-#define IGU_ADDR_COALESCE_NOW	0x0205
-#define IGU_ADDR_SIMD_MASK		0x0206
-#define IGU_ADDR_SIMD_NOMASK	0x0207
-#define IGU_ADDR_MSI_CTL		0x0210
-#define IGU_ADDR_MSI_ADDR_LO	0x0211
-#define IGU_ADDR_MSI_ADDR_HI	0x0212
-#define IGU_ADDR_MSI_DATA		0x0213
-
-#define IGU_INT_ENABLE			0
-#define IGU_INT_DISABLE 		1
-#define IGU_INT_NOP				2
-#define IGU_INT_NOP2			3
-
-#define COMMAND_REG_INT_ACK	    0x0
-#define COMMAND_REG_PROD_UPD	    0x4
-#define COMMAND_REG_ATTN_BITS_UPD   0x8
-#define COMMAND_REG_ATTN_BITS_SET   0xc
-#define COMMAND_REG_ATTN_BITS_CLR   0x10
-#define COMMAND_REG_COALESCE_NOW    0x14
-#define COMMAND_REG_SIMD_MASK	    0x18
-#define COMMAND_REG_SIMD_NOMASK     0x1c
-
-
-#define IGU_MEM_BASE						0x0000
-
-#define IGU_MEM_MSIX_BASE					0x0000
-#define IGU_MEM_MSIX_UPPER					0x007f
-#define IGU_MEM_MSIX_RESERVED_UPPER			0x01ff
-
-#define IGU_MEM_PBA_MSIX_BASE				0x0200
-#define IGU_MEM_PBA_MSIX_UPPER				0x0200
-
-#define IGU_CMD_BACKWARD_COMP_PROD_UPD		0x0201
-#define IGU_MEM_PBA_MSIX_RESERVED_UPPER 	0x03ff
-
-#define IGU_CMD_INT_ACK_BASE				0x0400
-#define IGU_CMD_INT_ACK_UPPER\
-	(IGU_CMD_INT_ACK_BASE + MAX_SB_PER_PORT * NUM_OF_PORTS_PER_PATH - 1)
-#define IGU_CMD_INT_ACK_RESERVED_UPPER		0x04ff
-
-#define IGU_CMD_E2_PROD_UPD_BASE			0x0500
-#define IGU_CMD_E2_PROD_UPD_UPPER\
-	(IGU_CMD_E2_PROD_UPD_BASE + MAX_SB_PER_PORT * NUM_OF_PORTS_PER_PATH - 1)
-#define IGU_CMD_E2_PROD_UPD_RESERVED_UPPER	0x059f
-
-#define IGU_CMD_ATTN_BIT_UPD_UPPER			0x05a0
-#define IGU_CMD_ATTN_BIT_SET_UPPER			0x05a1
-#define IGU_CMD_ATTN_BIT_CLR_UPPER			0x05a2
-
-#define IGU_REG_SISR_MDPC_WMASK_UPPER		0x05a3
-#define IGU_REG_SISR_MDPC_WMASK_LSB_UPPER	0x05a4
-#define IGU_REG_SISR_MDPC_WMASK_MSB_UPPER	0x05a5
-#define IGU_REG_SISR_MDPC_WOMASK_UPPER		0x05a6
-
-#define IGU_REG_RESERVED_UPPER				0x05ff
-
-
-#define CDU_REGION_NUMBER_XCM_AG 2
-#define CDU_REGION_NUMBER_UCM_AG 4
-
-
-/**
- * String-to-compress [31:8] = CID (all 24 bits)
- * String-to-compress [7:4] = Region
- * String-to-compress [3:0] = Type
- */
-#define CDU_VALID_DATA(_cid, _region, _type)\
-	(((_cid) << 8) | (((_region)&0xf)<<4) | (((_type)&0xf)))
-#define CDU_CRC8(_cid, _region, _type)\
-	(calc_crc8(CDU_VALID_DATA(_cid, _region, _type), 0xff))
-#define CDU_RSRVD_VALUE_TYPE_A(_cid, _region, _type)\
-	(0x80 | ((CDU_CRC8(_cid, _region, _type)) & 0x7f))
-#define CDU_RSRVD_VALUE_TYPE_B(_crc, _type)\
-	(0x80 | ((_type)&0xf << 3) | ((CDU_CRC8(_cid, _region, _type)) & 0x7))
-#define CDU_RSRVD_INVALIDATE_CONTEXT_VALUE(_val) ((_val) & ~0x80)
-
-/******************************************************************************
- * Description:
- *	   Calculates crc 8 on a word value: polynomial 0-1-2-8
- *	   Code was translated from Verilog.
- * Return:
- *****************************************************************************/
-static inline u8 calc_crc8(u32 data, u8 crc)
-{
-	u8 D[32];
-	u8 NewCRC[8];
-	u8 C[8];
-	u8 crc_res;
-	u8 i;
-
-	/* split the data into 31 bits */
-	for (i = 0; i < 32; i++) {
-		D[i] = (u8)(data & 1);
-		data = data >> 1;
-	}
-
-	/* split the crc into 8 bits */
-	for (i = 0; i < 8; i++) {
-		C[i] = crc & 1;
-		crc = crc >> 1;
-	}
-
-	NewCRC[0] = D[31] ^ D[30] ^ D[28] ^ D[23] ^ D[21] ^ D[19] ^ D[18] ^
-		    D[16] ^ D[14] ^ D[12] ^ D[8] ^ D[7] ^ D[6] ^ D[0] ^ C[4] ^
-		    C[6] ^ C[7];
-	NewCRC[1] = D[30] ^ D[29] ^ D[28] ^ D[24] ^ D[23] ^ D[22] ^ D[21] ^
-		    D[20] ^ D[18] ^ D[17] ^ D[16] ^ D[15] ^ D[14] ^ D[13] ^
-		    D[12] ^ D[9] ^ D[6] ^ D[1] ^ D[0] ^ C[0] ^ C[4] ^ C[5] ^
-		    C[6];
-	NewCRC[2] = D[29] ^ D[28] ^ D[25] ^ D[24] ^ D[22] ^ D[17] ^ D[15] ^
-		    D[13] ^ D[12] ^ D[10] ^ D[8] ^ D[6] ^ D[2] ^ D[1] ^ D[0] ^
-		    C[0] ^ C[1] ^ C[4] ^ C[5];
-	NewCRC[3] = D[30] ^ D[29] ^ D[26] ^ D[25] ^ D[23] ^ D[18] ^ D[16] ^
-		    D[14] ^ D[13] ^ D[11] ^ D[9] ^ D[7] ^ D[3] ^ D[2] ^ D[1] ^
-		    C[1] ^ C[2] ^ C[5] ^ C[6];
-	NewCRC[4] = D[31] ^ D[30] ^ D[27] ^ D[26] ^ D[24] ^ D[19] ^ D[17] ^
-		    D[15] ^ D[14] ^ D[12] ^ D[10] ^ D[8] ^ D[4] ^ D[3] ^ D[2] ^
-		    C[0] ^ C[2] ^ C[3] ^ C[6] ^ C[7];
-	NewCRC[5] = D[31] ^ D[28] ^ D[27] ^ D[25] ^ D[20] ^ D[18] ^ D[16] ^
-		    D[15] ^ D[13] ^ D[11] ^ D[9] ^ D[5] ^ D[4] ^ D[3] ^ C[1] ^
-		    C[3] ^ C[4] ^ C[7];
-	NewCRC[6] = D[29] ^ D[28] ^ D[26] ^ D[21] ^ D[19] ^ D[17] ^ D[16] ^
-		    D[14] ^ D[12] ^ D[10] ^ D[6] ^ D[5] ^ D[4] ^ C[2] ^ C[4] ^
-		    C[5];
-	NewCRC[7] = D[30] ^ D[29] ^ D[27] ^ D[22] ^ D[20] ^ D[18] ^ D[17] ^
-		    D[15] ^ D[13] ^ D[11] ^ D[7] ^ D[6] ^ D[5] ^ C[3] ^ C[5] ^
-		    C[6];
-
-	crc_res = 0;
-	for (i = 0; i < 8; i++)
-		crc_res |= (NewCRC[i] << i);
-
-	return crc_res;
-}
-
-
diff -r f4bf81a7ff20 drivers/net/cnic.c
--- a/drivers/net/cnic.c
+++ /dev/null
@@ -1,4635 +0,0 @@
-/* cnic.c: Broadcom CNIC core network driver.
- *
- * Copyright (c) 2006-2009 Broadcom Corporation
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation.
- *
- * Original skeleton written by: John(Zongxi) Chen (zongxi@broadcom.com)
- * Modified and maintained by: Michael Chan <mchan@broadcom.com>
- */
-
-#include <linux/module.h>
-
-#include <linux/kernel.h>
-#include <linux/errno.h>
-#include <linux/list.h>
-#include <linux/slab.h>
-#include <linux/pci.h>
-#include <linux/init.h>
-#include <linux/netdevice.h>
-#include <linux/uio_driver.h>
-#include <linux/in.h>
-#include <linux/dma-mapping.h>
-#include <linux/delay.h>
-#include <linux/ethtool.h>
-#include <linux/if_vlan.h>
-#if defined(CONFIG_VLAN_8021Q) || defined(CONFIG_VLAN_8021Q_MODULE)
-#define BCM_VLAN 1
-#endif
-#include <net/ip.h>
-#include <net/tcp.h>
-#include <net/route.h>
-#include <net/ipv6.h>
-#include <net/ip6_route.h>
-#include <net/ip6_checksum.h>
-#include <scsi/iscsi_if.h>
-
-#include "cnic_if.h"
-#include "bnx2.h"
-#include "bnx2x_reg.h"
-#include "bnx2x_fw_defs.h"
-#include "bnx2x_hsi.h"
-#include "../scsi/bnx2i/57xx_iscsi_constants.h"
-#include "../scsi/bnx2i/57xx_iscsi_hsi.h"
-#include "cnic.h"
-#include "cnic_defs.h"
-
-#define DRV_MODULE_NAME		"cnic"
-#define PFX DRV_MODULE_NAME	": "
-
-static char version[] __devinitdata =
-	"Broadcom NetXtreme II CNIC Driver " DRV_MODULE_NAME " v" CNIC_MODULE_VERSION " (" CNIC_MODULE_RELDATE ")\n";
-
-MODULE_AUTHOR("Michael Chan <mchan@broadcom.com> and John(Zongxi) "
-	      "Chen (zongxi@broadcom.com");
-MODULE_DESCRIPTION("Broadcom NetXtreme II CNIC Driver");
-MODULE_LICENSE("GPL");
-MODULE_VERSION(CNIC_MODULE_VERSION);
-
-static LIST_HEAD(cnic_dev_list);
-static DEFINE_RWLOCK(cnic_dev_lock);
-static DEFINE_MUTEX(cnic_lock);
-
-static struct cnic_ulp_ops *cnic_ulp_tbl[MAX_CNIC_ULP_TYPE];
-
-static int cnic_service_bnx2(void *, void *);
-static int cnic_service_bnx2x(void *, void *);
-static int cnic_ctl(void *, struct cnic_ctl_info *);
-
-static struct cnic_ops cnic_bnx2_ops = {
-	.cnic_owner	= THIS_MODULE,
-	.cnic_handler	= cnic_service_bnx2,
-	.cnic_ctl	= cnic_ctl,
-};
-
-static struct cnic_ops cnic_bnx2x_ops = {
-	.cnic_owner	= THIS_MODULE,
-	.cnic_handler	= cnic_service_bnx2x,
-	.cnic_ctl	= cnic_ctl,
-};
-
-static void cnic_shutdown_rings(struct cnic_dev *);
-static void cnic_init_rings(struct cnic_dev *);
-static int cnic_cm_set_pg(struct cnic_sock *);
-
-static int cnic_uio_open(struct uio_info *uinfo, struct inode *inode)
-{
-	struct cnic_dev *dev = uinfo->priv;
-	struct cnic_local *cp = dev->cnic_priv;
-
-	if (!capable(CAP_NET_ADMIN))
-		return -EPERM;
-
-	if (cp->uio_dev != -1)
-		return -EBUSY;
-
-	rtnl_lock();
-	if (!test_bit(CNIC_F_CNIC_UP, &dev->flags)) {
-		rtnl_unlock();
-		return -ENODEV;
-	}
-
-	cp->uio_dev = iminor(inode);
-
-	cnic_init_rings(dev);
-	rtnl_unlock();
-
-	return 0;
-}
-
-static int cnic_uio_close(struct uio_info *uinfo, struct inode *inode)
-{
-	struct cnic_dev *dev = uinfo->priv;
-	struct cnic_local *cp = dev->cnic_priv;
-
-	cnic_shutdown_rings(dev);
-
-	cp->uio_dev = -1;
-	return 0;
-}
-
-static inline void cnic_hold(struct cnic_dev *dev)
-{
-	atomic_inc(&dev->ref_count);
-}
-
-static inline void cnic_put(struct cnic_dev *dev)
-{
-	atomic_dec(&dev->ref_count);
-}
-
-static inline void csk_hold(struct cnic_sock *csk)
-{
-	atomic_inc(&csk->ref_count);
-}
-
-static inline void csk_put(struct cnic_sock *csk)
-{
-	atomic_dec(&csk->ref_count);
-}
-
-static struct cnic_dev *cnic_from_netdev(struct net_device *netdev)
-{
-	struct cnic_dev *cdev;
-
-	read_lock(&cnic_dev_lock);
-	list_for_each_entry(cdev, &cnic_dev_list, list) {
-		if (netdev == cdev->netdev) {
-			cnic_hold(cdev);
-			read_unlock(&cnic_dev_lock);
-			return cdev;
-		}
-	}
-	read_unlock(&cnic_dev_lock);
-	return NULL;
-}
-
-static inline void ulp_get(struct cnic_ulp_ops *ulp_ops)
-{
-	atomic_inc(&ulp_ops->ref_count);
-}
-
-static inline void ulp_put(struct cnic_ulp_ops *ulp_ops)
-{
-	atomic_dec(&ulp_ops->ref_count);
-}
-
-static void cnic_ctx_wr(struct cnic_dev *dev, u32 cid_addr, u32 off, u32 val)
-{
-	struct cnic_local *cp = dev->cnic_priv;
-	struct cnic_eth_dev *ethdev = cp->ethdev;
-	struct drv_ctl_info info;
-	struct drv_ctl_io *io = &info.data.io;
-
-	info.cmd = DRV_CTL_CTX_WR_CMD;
-	io->cid_addr = cid_addr;
-	io->offset = off;
-	io->data = val;
-	ethdev->drv_ctl(dev->netdev, &info);
-}
-
-static void cnic_ctx_tbl_wr(struct cnic_dev *dev, u32 off, dma_addr_t addr)
-{
-	struct cnic_local *cp = dev->cnic_priv;
-	struct cnic_eth_dev *ethdev = cp->ethdev;
-	struct drv_ctl_info info;
-	struct drv_ctl_io *io = &info.data.io;
-
-	info.cmd = DRV_CTL_CTXTBL_WR_CMD;
-	io->offset = off;
-	io->dma_addr = addr;
-	ethdev->drv_ctl(dev->netdev, &info);
-}
-
-static void cnic_ring_ctl(struct cnic_dev *dev, u32 cid, u32 cl_id, int start)
-{
-	struct cnic_local *cp = dev->cnic_priv;
-	struct cnic_eth_dev *ethdev = cp->ethdev;
-	struct drv_ctl_info info;
-	struct drv_ctl_l2_ring *ring = &info.data.ring;
-
-	if (start)
-		info.cmd = DRV_CTL_START_L2_CMD;
-	else
-		info.cmd = DRV_CTL_STOP_L2_CMD;
-
-	ring->cid = cid;
-	ring->client_id = cl_id;
-	ethdev->drv_ctl(dev->netdev, &info);
-}
-
-static void cnic_reg_wr_ind(struct cnic_dev *dev, u32 off, u32 val)
-{
-	struct cnic_local *cp = dev->cnic_priv;
-	struct cnic_eth_dev *ethdev = cp->ethdev;
-	struct drv_ctl_info info;
-	struct drv_ctl_io *io = &info.data.io;
-
-	info.cmd = DRV_CTL_IO_WR_CMD;
-	io->offset = off;
-	io->data = val;
-	ethdev->drv_ctl(dev->netdev, &info);
-}
-
-static u32 cnic_reg_rd_ind(struct cnic_dev *dev, u32 off)
-{
-	struct cnic_local *cp = dev->cnic_priv;
-	struct cnic_eth_dev *ethdev = cp->ethdev;
-	struct drv_ctl_info info;
-	struct drv_ctl_io *io = &info.data.io;
-
-	info.cmd = DRV_CTL_IO_RD_CMD;
-	io->offset = off;
-	ethdev->drv_ctl(dev->netdev, &info);
-	return io->data;
-}
-
-static int cnic_in_use(struct cnic_sock *csk)
-{
-	return test_bit(SK_F_INUSE, &csk->flags);
-}
-
-static void cnic_kwq_completion(struct cnic_dev *dev, u32 count)
-{
-	struct cnic_local *cp = dev->cnic_priv;
-	struct cnic_eth_dev *ethdev = cp->ethdev;
-	struct drv_ctl_info info;
-
-	info.cmd = DRV_CTL_COMPLETION_CMD;
-	info.data.comp.comp_count = count;
-	ethdev->drv_ctl(dev->netdev, &info);
-}
-
-static int cnic_get_l5_cid(struct cnic_local *cp, u32 cid, u32 *l5_cid)
-{
-	u32 i;
-
-	for (i = 0; i < MAX_ISCSI_TBL_SZ; i++) {
-		if (cp->ctx_tbl[i].cid == cid) {
-			*l5_cid = i;
-			return 0;
-		}
-	}
-	return -EINVAL;
-}
-
-static int cnic_send_nlmsg(struct cnic_local *cp, u32 type,
-			   struct cnic_sock *csk)
-{
-	struct iscsi_path path_req;
-	char *buf = NULL;
-	u16 len = 0;
-	u32 msg_type = ISCSI_KEVENT_IF_DOWN;
-	struct cnic_ulp_ops *ulp_ops;
-	int count = 0;
-
-	while (count < 40 && cp->uio_dev == -1) {
-		msleep(50);
-		count++;
-	}
-
-	if (cp->uio_dev == -1) {
-		printk(KERN_WARNING PFX "%s: no uio dev to send nl request\n",
-			cp->dev->netdev->name);
-		return -ENODEV;
-	}
-
-	if (csk) {
-		len = sizeof(path_req);
-		buf = (char *) &path_req;
-		memset(&path_req, 0, len);
-
-		msg_type = ISCSI_KEVENT_PATH_REQ;
-		path_req.handle = (u64) csk->l5_cid;
-		if (test_bit(SK_F_IPV6, &csk->flags)) {
-			memcpy(&path_req.dst.v6_addr, &csk->dst_ip[0],
-			       sizeof(struct in6_addr));
-			path_req.ip_addr_len = 16;
-		} else {
-			memcpy(&path_req.dst.v4_addr, &csk->dst_ip[0],
-			       sizeof(struct in_addr));
-			path_req.ip_addr_len = 4;
-		}
-		path_req.vlan_id = csk->vlan_id;
-		path_req.pmtu = csk->mtu;
-	}
-
-	rcu_read_lock();
-	ulp_ops = rcu_dereference(cnic_ulp_tbl[CNIC_ULP_ISCSI]);
-	if (ulp_ops)
-		ulp_ops->iscsi_nl_send_msg(cp->dev, msg_type, buf, len);
-	rcu_read_unlock();
-	return 0;
-}
-
-static int cnic_iscsi_nl_msg_recv(struct cnic_dev *dev, u32 msg_type,
-				  char *buf, u16 len)
-{
-	int rc = -EINVAL;
-
-	switch (msg_type) {
-	case ISCSI_UEVENT_PATH_UPDATE: {
-		struct cnic_local *cp;
-		u32 l5_cid;
-		struct cnic_sock *csk;
-		struct iscsi_path *path_resp;
-
-		if (len < sizeof(*path_resp))
-			break;
-
-		path_resp = (struct iscsi_path *) buf;
-		cp = dev->cnic_priv;
-		l5_cid = (u32) path_resp->handle;
-		if (l5_cid >= MAX_CM_SK_TBL_SZ)
-			break;
-
-		csk = &cp->csk_tbl[l5_cid];
-		csk_hold(csk);
-		if (cnic_in_use(csk)) {
-			memcpy(csk->ha, path_resp->mac_addr, 6);
-			if (test_bit(SK_F_IPV6, &csk->flags))
-				memcpy(&csk->src_ip[0], &path_resp->src.v6_addr,
-				       sizeof(struct in6_addr));
-			else
-				memcpy(&csk->src_ip[0], &path_resp->src.v4_addr,
-				       sizeof(struct in_addr));
-			if (is_valid_ether_addr(csk->ha))
-				cnic_cm_set_pg(csk);
-		}
-		csk_put(csk);
-		rc = 0;
-	}
-	}
-
-	return rc;
-}
-
-static int cnic_offld_prep(struct cnic_sock *csk)
-{
-	if (test_and_set_bit(SK_F_OFFLD_SCHED, &csk->flags))
-		return 0;
-
-	if (!test_bit(SK_F_CONNECT_START, &csk->flags)) {
-		clear_bit(SK_F_OFFLD_SCHED, &csk->flags);
-		return 0;
-	}
-
-	return 1;
-}
-
-static int cnic_close_prep(struct cnic_sock *csk)
-{
-	clear_bit(SK_F_CONNECT_START, &csk->flags);
-	smp_mb__after_clear_bit();
-
-	if (test_and_clear_bit(SK_F_OFFLD_COMPLETE, &csk->flags)) {
-		while (test_and_set_bit(SK_F_OFFLD_SCHED, &csk->flags))
-			msleep(1);
-
-		return 1;
-	}
-	return 0;
-}
-
-static int cnic_abort_prep(struct cnic_sock *csk)
-{
-	clear_bit(SK_F_CONNECT_START, &csk->flags);
-	smp_mb__after_clear_bit();
-
-	while (test_and_set_bit(SK_F_OFFLD_SCHED, &csk->flags))
-		msleep(1);
-
-	if (test_and_clear_bit(SK_F_OFFLD_COMPLETE, &csk->flags)) {
-		csk->state = L4_KCQE_OPCODE_VALUE_RESET_COMP;
-		return 1;
-	}
-
-	return 0;
-}
-
-static void cnic_uio_stop(void)
-{
-	struct cnic_dev *dev;
-
-	read_lock(&cnic_dev_lock);
-	list_for_each_entry(dev, &cnic_dev_list, list) {
-		struct cnic_local *cp = dev->cnic_priv;
-
-		if (cp->cnic_uinfo)
-			cnic_send_nlmsg(cp, ISCSI_KEVENT_IF_DOWN, NULL);
-	}
-	read_unlock(&cnic_dev_lock);
-}
-
-int cnic_register_driver(int ulp_type, struct cnic_ulp_ops *ulp_ops)
-{
-	struct cnic_dev *dev;
-
-	if (ulp_type < 0 || ulp_type >= MAX_CNIC_ULP_TYPE) {
-		printk(KERN_ERR PFX "cnic_register_driver: Bad type %d\n",
-		       ulp_type);
-		return -EINVAL;
-	}
-	mutex_lock(&cnic_lock);
-	if (cnic_ulp_tbl[ulp_type]) {
-		printk(KERN_ERR PFX "cnic_register_driver: Type %d has already "
-				    "been registered\n", ulp_type);
-		mutex_unlock(&cnic_lock);
-		return -EBUSY;
-	}
-
-	read_lock(&cnic_dev_lock);
-	list_for_each_entry(dev, &cnic_dev_list, list) {
-		struct cnic_local *cp = dev->cnic_priv;
-
-		clear_bit(ULP_F_INIT, &cp->ulp_flags[ulp_type]);
-	}
-	read_unlock(&cnic_dev_lock);
-
-	atomic_set(&ulp_ops->ref_count, 0);
-	rcu_assign_pointer(cnic_ulp_tbl[ulp_type], ulp_ops);
-	mutex_unlock(&cnic_lock);
-
-	/* Prevent race conditions with netdev_event */
-	rtnl_lock();
-	read_lock(&cnic_dev_lock);
-	list_for_each_entry(dev, &cnic_dev_list, list) {
-		struct cnic_local *cp = dev->cnic_priv;
-
-		if (!test_and_set_bit(ULP_F_INIT, &cp->ulp_flags[ulp_type]))
-			ulp_ops->cnic_init(dev);
-	}
-	read_unlock(&cnic_dev_lock);
-	rtnl_unlock();
-
-	return 0;
-}
-
-int cnic_unregister_driver(int ulp_type)
-{
-	struct cnic_dev *dev;
-	struct cnic_ulp_ops *ulp_ops;
-	int i = 0;
-
-	if (ulp_type < 0 || ulp_type >= MAX_CNIC_ULP_TYPE) {
-		printk(KERN_ERR PFX "cnic_unregister_driver: Bad type %d\n",
-		       ulp_type);
-		return -EINVAL;
-	}
-	mutex_lock(&cnic_lock);
-	ulp_ops = cnic_ulp_tbl[ulp_type];
-	if (!ulp_ops) {
-		printk(KERN_ERR PFX "cnic_unregister_driver: Type %d has not "
-				    "been registered\n", ulp_type);
-		goto out_unlock;
-	}
-	read_lock(&cnic_dev_lock);
-	list_for_each_entry(dev, &cnic_dev_list, list) {
-		struct cnic_local *cp = dev->cnic_priv;
-
-		if (rcu_dereference(cp->ulp_ops[ulp_type])) {
-			printk(KERN_ERR PFX "cnic_unregister_driver: Type %d "
-			       "still has devices registered\n", ulp_type);
-			read_unlock(&cnic_dev_lock);
-			goto out_unlock;
-		}
-	}
-	read_unlock(&cnic_dev_lock);
-
-	if (ulp_type == CNIC_ULP_ISCSI)
-		cnic_uio_stop();
-
-	rcu_assign_pointer(cnic_ulp_tbl[ulp_type], NULL);
-
-	mutex_unlock(&cnic_lock);
-	synchronize_rcu();
-	while ((atomic_read(&ulp_ops->ref_count) != 0) && (i < 20)) {
-		msleep(100);
-		i++;
-	}
-
-	if (atomic_read(&ulp_ops->ref_count) != 0)
-		printk(KERN_WARNING PFX "%s: Failed waiting for ref count to go"
-					" to zero.\n", dev->netdev->name);
-	return 0;
-
-out_unlock:
-	mutex_unlock(&cnic_lock);
-	return -EINVAL;
-}
-
-static int cnic_start_hw(struct cnic_dev *);
-static void cnic_stop_hw(struct cnic_dev *);
-
-static int cnic_register_device(struct cnic_dev *dev, int ulp_type,
-				void *ulp_ctx)
-{
-	struct cnic_local *cp = dev->cnic_priv;
-	struct cnic_ulp_ops *ulp_ops;
-
-	if (ulp_type < 0 || ulp_type >= MAX_CNIC_ULP_TYPE) {
-		printk(KERN_ERR PFX "cnic_register_device: Bad type %d\n",
-		       ulp_type);
-		return -EINVAL;
-	}
-	mutex_lock(&cnic_lock);
-	if (cnic_ulp_tbl[ulp_type] == NULL) {
-		printk(KERN_ERR PFX "cnic_register_device: Driver with type %d "
-				    "has not been registered\n", ulp_type);
-		mutex_unlock(&cnic_lock);
-		return -EAGAIN;
-	}
-	if (rcu_dereference(cp->ulp_ops[ulp_type])) {
-		printk(KERN_ERR PFX "cnic_register_device: Type %d has already "
-		       "been registered to this device\n", ulp_type);
-		mutex_unlock(&cnic_lock);
-		return -EBUSY;
-	}
-
-	clear_bit(ULP_F_START, &cp->ulp_flags[ulp_type]);
-	cp->ulp_handle[ulp_type] = ulp_ctx;
-	ulp_ops = cnic_ulp_tbl[ulp_type];
-	rcu_assign_pointer(cp->ulp_ops[ulp_type], ulp_ops);
-	cnic_hold(dev);
-
-	if (test_bit(CNIC_F_CNIC_UP, &dev->flags))
-		if (!test_and_set_bit(ULP_F_START, &cp->ulp_flags[ulp_type]))
-			ulp_ops->cnic_start(cp->ulp_handle[ulp_type]);
-
-	mutex_unlock(&cnic_lock);
-
-	return 0;
-
-}
-EXPORT_SYMBOL(cnic_register_driver);
-
-static int cnic_unregister_device(struct cnic_dev *dev, int ulp_type)
-{
-	struct cnic_local *cp = dev->cnic_priv;
-	int i = 0;
-
-	if (ulp_type < 0 || ulp_type >= MAX_CNIC_ULP_TYPE) {
-		printk(KERN_ERR PFX "cnic_unregister_device: Bad type %d\n",
-		       ulp_type);
-		return -EINVAL;
-	}
-	mutex_lock(&cnic_lock);
-	if (rcu_dereference(cp->ulp_ops[ulp_type])) {
-		rcu_assign_pointer(cp->ulp_ops[ulp_type], NULL);
-		cnic_put(dev);
-	} else {
-		printk(KERN_ERR PFX "cnic_unregister_device: device not "
-		       "registered to this ulp type %d\n", ulp_type);
-		mutex_unlock(&cnic_lock);
-		return -EINVAL;
-	}
-	mutex_unlock(&cnic_lock);
-
-	synchronize_rcu();
-
-	while (test_bit(ULP_F_CALL_PENDING, &cp->ulp_flags[ulp_type]) &&
-	       i < 20) {
-		msleep(100);
-		i++;
-	}
-	if (test_bit(ULP_F_CALL_PENDING, &cp->ulp_flags[ulp_type]))
-		printk(KERN_WARNING PFX "%s: Failed waiting for ULP up call"
-					" to complete.\n", dev->netdev->name);
-
-	return 0;
-}
-EXPORT_SYMBOL(cnic_unregister_driver);
-
-static int cnic_init_id_tbl(struct cnic_id_tbl *id_tbl, u32 size, u32 start_id)
-{
-	id_tbl->start = start_id;
-	id_tbl->max = size;
-	id_tbl->next = 0;
-	spin_lock_init(&id_tbl->lock);
-	id_tbl->table = kzalloc(DIV_ROUND_UP(size, 32) * 4, GFP_KERNEL);
-	if (!id_tbl->table)
-		return -ENOMEM;
-
-	return 0;
-}
-
-static void cnic_free_id_tbl(struct cnic_id_tbl *id_tbl)
-{
-	kfree(id_tbl->table);
-	id_tbl->table = NULL;
-}
-
-static int cnic_alloc_id(struct cnic_id_tbl *id_tbl, u32 id)
-{
-	int ret = -1;
-
-	id -= id_tbl->start;
-	if (id >= id_tbl->max)
-		return ret;
-
-	spin_lock(&id_tbl->lock);
-	if (!test_bit(id, id_tbl->table)) {
-		set_bit(id, id_tbl->table);
-		ret = 0;
-	}
-	spin_unlock(&id_tbl->lock);
-	return ret;
-}
-
-/* Returns -1 if not successful */
-static u32 cnic_alloc_new_id(struct cnic_id_tbl *id_tbl)
-{
-	u32 id;
-
-	spin_lock(&id_tbl->lock);
-	id = find_next_zero_bit(id_tbl->table, id_tbl->max, id_tbl->next);
-	if (id >= id_tbl->max) {
-		id = -1;
-		if (id_tbl->next != 0) {
-			id = find_first_zero_bit(id_tbl->table, id_tbl->next);
-			if (id >= id_tbl->next)
-				id = -1;
-		}
-	}
-
-	if (id < id_tbl->max) {
-		set_bit(id, id_tbl->table);
-		id_tbl->next = (id + 1) & (id_tbl->max - 1);
-		id += id_tbl->start;
-	}
-
-	spin_unlock(&id_tbl->lock);
-
-	return id;
-}
-
-static void cnic_free_id(struct cnic_id_tbl *id_tbl, u32 id)
-{
-	if (id == -1)
-		return;
-
-	id -= id_tbl->start;
-	if (id >= id_tbl->max)
-		return;
-
-	clear_bit(id, id_tbl->table);
-}
-
-static void cnic_free_dma(struct cnic_dev *dev, struct cnic_dma *dma)
-{
-	int i;
-
-	if (!dma->pg_arr)
-		return;
-
-	for (i = 0; i < dma->num_pages; i++) {
-		if (dma->pg_arr[i]) {
-			dma_free_coherent(&dev->pcidev->dev, BCM_PAGE_SIZE,
-					  dma->pg_arr[i], dma->pg_map_arr[i]);
-			dma->pg_arr[i] = NULL;
-		}
-	}
-	if (dma->pgtbl) {
-		dma_free_coherent(&dev->pcidev->dev, dma->pgtbl_size,
-				  dma->pgtbl, dma->pgtbl_map);
-		dma->pgtbl = NULL;
-	}
-	kfree(dma->pg_arr);
-	dma->pg_arr = NULL;
-	dma->num_pages = 0;
-}
-
-static void cnic_setup_page_tbl(struct cnic_dev *dev, struct cnic_dma *dma)
-{
-	int i;
-	u32 *page_table = dma->pgtbl;
-
-	for (i = 0; i < dma->num_pages; i++) {
-		/* Each entry needs to be in big endian format. */
-		*page_table = (u32) ((u64) dma->pg_map_arr[i] >> 32);
-		page_table++;
-		*page_table = (u32) dma->pg_map_arr[i];
-		page_table++;
-	}
-}
-
-static void cnic_setup_page_tbl_le(struct cnic_dev *dev, struct cnic_dma *dma)
-{
-	int i;
-	u32 *page_table = dma->pgtbl;
-
-	for (i = 0; i < dma->num_pages; i++) {
-		/* Each entry needs to be in little endian format. */
-		*page_table = dma->pg_map_arr[i] & 0xffffffff;
-		page_table++;
-		*page_table = (u32) ((u64) dma->pg_map_arr[i] >> 32);
-		page_table++;
-	}
-}
-
-static int cnic_alloc_dma(struct cnic_dev *dev, struct cnic_dma *dma,
-			  int pages, int use_pg_tbl)
-{
-	int i, size;
-	struct cnic_local *cp = dev->cnic_priv;
-
-	size = pages * (sizeof(void *) + sizeof(dma_addr_t));
-	dma->pg_arr = kzalloc(size, GFP_ATOMIC);
-	if (dma->pg_arr == NULL)
-		return -ENOMEM;
-
-	dma->pg_map_arr = (dma_addr_t *) (dma->pg_arr + pages);
-	dma->num_pages = pages;
-
-	for (i = 0; i < pages; i++) {
-		dma->pg_arr[i] = dma_alloc_coherent(&dev->pcidev->dev,
-						    BCM_PAGE_SIZE,
-						    &dma->pg_map_arr[i],
-						    GFP_ATOMIC);
-		if (dma->pg_arr[i] == NULL)
-			goto error;
-	}
-	if (!use_pg_tbl)
-		return 0;
-
-	dma->pgtbl_size = ((pages * 8) + BCM_PAGE_SIZE - 1) &
-			  ~(BCM_PAGE_SIZE - 1);
-	dma->pgtbl = dma_alloc_coherent(&dev->pcidev->dev, dma->pgtbl_size,
-					&dma->pgtbl_map, GFP_ATOMIC);
-	if (dma->pgtbl == NULL)
-		goto error;
-
-	cp->setup_pgtbl(dev, dma);
-
-	return 0;
-
-error:
-	cnic_free_dma(dev, dma);
-	return -ENOMEM;
-}
-
-static void cnic_free_context(struct cnic_dev *dev)
-{
-	struct cnic_local *cp = dev->cnic_priv;
-	int i;
-
-	for (i = 0; i < cp->ctx_blks; i++) {
-		if (cp->ctx_arr[i].ctx) {
-			dma_free_coherent(&dev->pcidev->dev, cp->ctx_blk_size,
-					  cp->ctx_arr[i].ctx,
-					  cp->ctx_arr[i].mapping);
-			cp->ctx_arr[i].ctx = NULL;
-		}
-	}
-}
-
-static void cnic_free_resc(struct cnic_dev *dev)
-{
-	struct cnic_local *cp = dev->cnic_priv;
-	int i = 0;
-
-	if (cp->cnic_uinfo) {
-		while (cp->uio_dev != -1 && i < 15) {
-			msleep(100);
-			i++;
-		}
-		uio_unregister_device(cp->cnic_uinfo);
-		kfree(cp->cnic_uinfo);
-		cp->cnic_uinfo = NULL;
-	}
-
-	if (cp->l2_buf) {
-		dma_free_coherent(&dev->pcidev->dev, cp->l2_buf_size,
-				  cp->l2_buf, cp->l2_buf_map);
-		cp->l2_buf = NULL;
-	}
-
-	if (cp->l2_ring) {
-		dma_free_coherent(&dev->pcidev->dev, cp->l2_ring_size,
-				  cp->l2_ring, cp->l2_ring_map);
-		cp->l2_ring = NULL;
-	}
-
-	cnic_free_context(dev);
-	kfree(cp->ctx_arr);
-	cp->ctx_arr = NULL;
-	cp->ctx_blks = 0;
-
-	cnic_free_dma(dev, &cp->gbl_buf_info);
-	cnic_free_dma(dev, &cp->conn_buf_info);
-	cnic_free_dma(dev, &cp->kwq_info);
-	cnic_free_dma(dev, &cp->kwq_16_data_info);
-	cnic_free_dma(dev, &cp->kcq_info);
-	kfree(cp->iscsi_tbl);
-	cp->iscsi_tbl = NULL;
-	kfree(cp->ctx_tbl);
-	cp->ctx_tbl = NULL;
-
-	cnic_free_id_tbl(&cp->cid_tbl);
-}
-
-static int cnic_alloc_context(struct cnic_dev *dev)
-{
-	struct cnic_local *cp = dev->cnic_priv;
-
-	if (CHIP_NUM(cp) == CHIP_NUM_5709) {
-		int i, k, arr_size;
-
-		cp->ctx_blk_size = BCM_PAGE_SIZE;
-		cp->cids_per_blk = BCM_PAGE_SIZE / 128;
-		arr_size = BNX2_MAX_CID / cp->cids_per_blk *
-			   sizeof(struct cnic_ctx);
-		cp->ctx_arr = kzalloc(arr_size, GFP_KERNEL);
-		if (cp->ctx_arr == NULL)
-			return -ENOMEM;
-
-		k = 0;
-		for (i = 0; i < 2; i++) {
-			u32 j, reg, off, lo, hi;
-
-			if (i == 0)
-				off = BNX2_PG_CTX_MAP;
-			else
-				off = BNX2_ISCSI_CTX_MAP;
-
-			reg = cnic_reg_rd_ind(dev, off);
-			lo = reg >> 16;
-			hi = reg & 0xffff;
-			for (j = lo; j < hi; j += cp->cids_per_blk, k++)
-				cp->ctx_arr[k].cid = j;
-		}
-
-		cp->ctx_blks = k;
-		if (cp->ctx_blks >= (BNX2_MAX_CID / cp->cids_per_blk)) {
-			cp->ctx_blks = 0;
-			return -ENOMEM;
-		}
-
-		for (i = 0; i < cp->ctx_blks; i++) {
-			cp->ctx_arr[i].ctx =
-				dma_alloc_coherent(&dev->pcidev->dev,
-						   BCM_PAGE_SIZE,
-						   &cp->ctx_arr[i].mapping,
-						   GFP_KERNEL);
-			if (cp->ctx_arr[i].ctx == NULL)
-				return -ENOMEM;
-		}
-	}
-	return 0;
-}
-
-static int cnic_alloc_l2_rings(struct cnic_dev *dev, int pages)
-{
-	struct cnic_local *cp = dev->cnic_priv;
-
-	cp->l2_ring_size = pages * BCM_PAGE_SIZE;
-	cp->l2_ring = dma_alloc_coherent(&dev->pcidev->dev, cp->l2_ring_size,
-					 &cp->l2_ring_map,
-					 GFP_KERNEL | __GFP_COMP);
-	if (!cp->l2_ring)
-		return -ENOMEM;
-
-	cp->l2_buf_size = (cp->l2_rx_ring_size + 1) * cp->l2_single_buf_size;
-	cp->l2_buf_size = PAGE_ALIGN(cp->l2_buf_size);
-	cp->l2_buf = dma_alloc_coherent(&dev->pcidev->dev, cp->l2_buf_size,
-					&cp->l2_buf_map,
-					GFP_KERNEL | __GFP_COMP);
-	if (!cp->l2_buf)
-		return -ENOMEM;
-
-	return 0;
-}
-
-static int cnic_alloc_uio(struct cnic_dev *dev) {
-	struct cnic_local *cp = dev->cnic_priv;
-	struct uio_info *uinfo;
-	int ret;
-
-	uinfo = kzalloc(sizeof(*uinfo), GFP_ATOMIC);
-	if (!uinfo)
-		return -ENOMEM;
-
-	uinfo->mem[0].addr = dev->netdev->base_addr;
-	uinfo->mem[0].internal_addr = dev->regview;
-	uinfo->mem[0].size = dev->netdev->mem_end - dev->netdev->mem_start;
-	uinfo->mem[0].memtype = UIO_MEM_PHYS;
-
-	if (test_bit(CNIC_F_BNX2_CLASS, &dev->flags)) {
-		uinfo->mem[1].addr = (unsigned long) cp->status_blk.gen &
-			PAGE_MASK;
-		if (cp->ethdev->drv_state & CNIC_DRV_STATE_USING_MSIX)
-			uinfo->mem[1].size = BNX2_SBLK_MSIX_ALIGN_SIZE * 9;
-		else
-			uinfo->mem[1].size = BNX2_SBLK_MSIX_ALIGN_SIZE;
-
-		uinfo->name = "bnx2_cnic";
-	} else if (test_bit(CNIC_F_BNX2X_CLASS, &dev->flags)) {
-		uinfo->mem[1].addr = (unsigned long) cp->bnx2x_def_status_blk &
-			PAGE_MASK;
-		uinfo->mem[1].size = sizeof(struct host_def_status_block);
-
-		uinfo->name = "bnx2x_cnic";
-	}
-
-	uinfo->mem[1].memtype = UIO_MEM_LOGICAL;
-
-	uinfo->mem[2].addr = (unsigned long) cp->l2_ring;
-	uinfo->mem[2].size = cp->l2_ring_size;
-	uinfo->mem[2].memtype = UIO_MEM_LOGICAL;
-
-	uinfo->mem[3].addr = (unsigned long) cp->l2_buf;
-	uinfo->mem[3].size = cp->l2_buf_size;
-	uinfo->mem[3].memtype = UIO_MEM_LOGICAL;
-
-	uinfo->version = CNIC_MODULE_VERSION;
-	uinfo->irq = UIO_IRQ_CUSTOM;
-
-	uinfo->open = cnic_uio_open;
-	uinfo->release = cnic_uio_close;
-
-	uinfo->priv = dev;
-
-	ret = uio_register_device(&dev->pcidev->dev, uinfo);
-	if (ret) {
-		kfree(uinfo);
-		return ret;
-	}
-
-	cp->cnic_uinfo = uinfo;
-	return 0;
-}
-
-static int cnic_alloc_bnx2_resc(struct cnic_dev *dev)
-{
-	struct cnic_local *cp = dev->cnic_priv;
-	int ret;
-
-	ret = cnic_alloc_dma(dev, &cp->kwq_info, KWQ_PAGE_CNT, 1);
-	if (ret)
-		goto error;
-	cp->kwq = (struct kwqe **) cp->kwq_info.pg_arr;
-
-	ret = cnic_alloc_dma(dev, &cp->kcq_info, KCQ_PAGE_CNT, 1);
-	if (ret)
-		goto error;
-	cp->kcq = (struct kcqe **) cp->kcq_info.pg_arr;
-
-	ret = cnic_alloc_context(dev);
-	if (ret)
-		goto error;
-
-	ret = cnic_alloc_l2_rings(dev, 2);
-	if (ret)
-		goto error;
-
-	ret = cnic_alloc_uio(dev);
-	if (ret)
-		goto error;
-
-	return 0;
-
-error:
-	cnic_free_resc(dev);
-	return ret;
-}
-
-static int cnic_alloc_bnx2x_context(struct cnic_dev *dev)
-{
-	struct cnic_local *cp = dev->cnic_priv;
-	struct cnic_eth_dev *ethdev = cp->ethdev;
-	int ctx_blk_size = cp->ethdev->ctx_blk_size;
-	int total_mem, blks, i, cid_space;
-
-	if (BNX2X_ISCSI_START_CID < ethdev->starting_cid)
-		return -EINVAL;
-
-	cid_space = MAX_ISCSI_TBL_SZ +
-		    (BNX2X_ISCSI_START_CID - ethdev->starting_cid);
-
-	total_mem = BNX2X_CONTEXT_MEM_SIZE * cid_space;
-	blks = total_mem / ctx_blk_size;
-	if (total_mem % ctx_blk_size)
-		blks++;
-
-	if (blks > cp->ethdev->ctx_tbl_len)
-		return -ENOMEM;
-
-	cp->ctx_arr = kzalloc(blks * sizeof(struct cnic_ctx), GFP_KERNEL);
-	if (cp->ctx_arr == NULL)
-		return -ENOMEM;
-
-	cp->ctx_blks = blks;
-	cp->ctx_blk_size = ctx_blk_size;
-	if (BNX2X_CHIP_IS_E1H(cp->chip_id))
-		cp->ctx_align = 0;
-	else
-		cp->ctx_align = ctx_blk_size;
-
-	cp->cids_per_blk = ctx_blk_size / BNX2X_CONTEXT_MEM_SIZE;
-
-	for (i = 0; i < blks; i++) {
-		cp->ctx_arr[i].ctx =
-			dma_alloc_coherent(&dev->pcidev->dev, cp->ctx_blk_size,
-					   &cp->ctx_arr[i].mapping,
-					   GFP_KERNEL);
-		if (cp->ctx_arr[i].ctx == NULL)
-			return -ENOMEM;
-
-		if (cp->ctx_align && cp->ctx_blk_size == ctx_blk_size) {
-			if (cp->ctx_arr[i].mapping & (cp->ctx_align - 1)) {
-				cnic_free_context(dev);
-				cp->ctx_blk_size += cp->ctx_align;
-				i = -1;
-				continue;
-			}
-		}
-	}
-	return 0;
-}
-
-static int cnic_alloc_bnx2x_resc(struct cnic_dev *dev)
-{
-	struct cnic_local *cp = dev->cnic_priv;
-	int i, j, n, ret, pages;
-	struct cnic_dma *kwq_16_dma = &cp->kwq_16_data_info;
-
-	cp->iscsi_tbl = kzalloc(sizeof(struct cnic_iscsi) * MAX_ISCSI_TBL_SZ,
-				GFP_KERNEL);
-	if (!cp->iscsi_tbl)
-		goto error;
-
-	cp->ctx_tbl = kzalloc(sizeof(struct cnic_context) *
-				  MAX_CNIC_L5_CONTEXT, GFP_KERNEL);
-	if (!cp->ctx_tbl)
-		goto error;
-
-	for (i = 0; i < MAX_ISCSI_TBL_SZ; i++) {
-		cp->ctx_tbl[i].proto.iscsi = &cp->iscsi_tbl[i];
-		cp->ctx_tbl[i].ulp_proto_id = CNIC_ULP_ISCSI;
-	}
-
-	pages = PAGE_ALIGN(MAX_CNIC_L5_CONTEXT * CNIC_KWQ16_DATA_SIZE) /
-		PAGE_SIZE;
-
-	ret = cnic_alloc_dma(dev, kwq_16_dma, pages, 0);
-	if (ret)
-		return -ENOMEM;
-
-	n = PAGE_SIZE / CNIC_KWQ16_DATA_SIZE;
-	for (i = 0, j = 0; i < MAX_ISCSI_TBL_SZ; i++) {
-		long off = CNIC_KWQ16_DATA_SIZE * (i % n);
-
-		cp->ctx_tbl[i].kwqe_data = kwq_16_dma->pg_arr[j] + off;
-		cp->ctx_tbl[i].kwqe_data_mapping = kwq_16_dma->pg_map_arr[j] +
-						   off;
-
-		if ((i % n) == (n - 1))
-			j++;
-	}
-
-	ret = cnic_alloc_dma(dev, &cp->kcq_info, KCQ_PAGE_CNT, 0);
-	if (ret)
-		goto error;
-	cp->kcq = (struct kcqe **) cp->kcq_info.pg_arr;
-
-	for (i = 0; i < KCQ_PAGE_CNT; i++) {
-		struct bnx2x_bd_chain_next *next =
-			(struct bnx2x_bd_chain_next *)
-			&cp->kcq[i][MAX_KCQE_CNT];
-		int j = i + 1;
-
-		if (j >= KCQ_PAGE_CNT)
-			j = 0;
-		next->addr_hi = (u64) cp->kcq_info.pg_map_arr[j] >> 32;
-		next->addr_lo = cp->kcq_info.pg_map_arr[j] & 0xffffffff;
-	}
-
-	pages = PAGE_ALIGN(BNX2X_ISCSI_NUM_CONNECTIONS *
-			   BNX2X_ISCSI_CONN_BUF_SIZE) / PAGE_SIZE;
-	ret = cnic_alloc_dma(dev, &cp->conn_buf_info, pages, 1);
-	if (ret)
-		goto error;
-
-	pages = PAGE_ALIGN(BNX2X_ISCSI_GLB_BUF_SIZE) / PAGE_SIZE;
-	ret = cnic_alloc_dma(dev, &cp->gbl_buf_info, pages, 0);
-	if (ret)
-		goto error;
-
-	ret = cnic_alloc_bnx2x_context(dev);
-	if (ret)
-		goto error;
-
-	cp->bnx2x_def_status_blk = cp->ethdev->irq_arr[1].status_blk;
-
-	memset(cp->status_blk.bnx2x, 0, sizeof(*cp->status_blk.bnx2x));
-
-	cp->l2_rx_ring_size = 15;
-
-	ret = cnic_alloc_l2_rings(dev, 4);
-	if (ret)
-		goto error;
-
-	ret = cnic_alloc_uio(dev);
-	if (ret)
-		goto error;
-
-	return 0;
-
-error:
-	cnic_free_resc(dev);
-	return -ENOMEM;
-}
-
-static inline u32 cnic_kwq_avail(struct cnic_local *cp)
-{
-	return cp->max_kwq_idx -
-		((cp->kwq_prod_idx - cp->kwq_con_idx) & cp->max_kwq_idx);
-}
-
-static int cnic_submit_bnx2_kwqes(struct cnic_dev *dev, struct kwqe *wqes[],
-				  u32 num_wqes)
-{
-	struct cnic_local *cp = dev->cnic_priv;
-	struct kwqe *prod_qe;
-	u16 prod, sw_prod, i;
-
-	if (!test_bit(CNIC_F_CNIC_UP, &dev->flags))
-		return -EAGAIN;		/* bnx2 is down */
-
-	spin_lock_bh(&cp->cnic_ulp_lock);
-	if (num_wqes > cnic_kwq_avail(cp) &&
-	    !(cp->cnic_local_flags & CNIC_LCL_FL_KWQ_INIT)) {
-		spin_unlock_bh(&cp->cnic_ulp_lock);
-		return -EAGAIN;
-	}
-
-	cp->cnic_local_flags &= ~CNIC_LCL_FL_KWQ_INIT;
-
-	prod = cp->kwq_prod_idx;
-	sw_prod = prod & MAX_KWQ_IDX;
-	for (i = 0; i < num_wqes; i++) {
-		prod_qe = &cp->kwq[KWQ_PG(sw_prod)][KWQ_IDX(sw_prod)];
-		memcpy(prod_qe, wqes[i], sizeof(struct kwqe));
-		prod++;
-		sw_prod = prod & MAX_KWQ_IDX;
-	}
-	cp->kwq_prod_idx = prod;
-
-	CNIC_WR16(dev, cp->kwq_io_addr, cp->kwq_prod_idx);
-
-	spin_unlock_bh(&cp->cnic_ulp_lock);
-	return 0;
-}
-
-static void *cnic_get_kwqe_16_data(struct cnic_local *cp, u32 l5_cid,
-				   union l5cm_specific_data *l5_data)
-{
-	struct cnic_context *ctx = &cp->ctx_tbl[l5_cid];
-	dma_addr_t map;
-
-	map = ctx->kwqe_data_mapping;
-	l5_data->phy_address.lo = (u64) map & 0xffffffff;
-	l5_data->phy_address.hi = (u64) map >> 32;
-	return ctx->kwqe_data;
-}
-
-static int cnic_submit_kwqe_16(struct cnic_dev *dev, u32 cmd, u32 cid,
-				u32 type, union l5cm_specific_data *l5_data)
-{
-	struct cnic_local *cp = dev->cnic_priv;
-	struct l5cm_spe kwqe;
-	struct kwqe_16 *kwq[1];
-	int ret;
-
-	kwqe.hdr.conn_and_cmd_data =
-		cpu_to_le32(((cmd << SPE_HDR_CMD_ID_SHIFT) |
-			     BNX2X_HW_CID(cid, cp->func)));
-	kwqe.hdr.type = cpu_to_le16(type);
-	kwqe.hdr.reserved = 0;
-	kwqe.data.phy_address.lo = cpu_to_le32(l5_data->phy_address.lo);
-	kwqe.data.phy_address.hi = cpu_to_le32(l5_data->phy_address.hi);
-
-	kwq[0] = (struct kwqe_16 *) &kwqe;
-
-	spin_lock_bh(&cp->cnic_ulp_lock);
-	ret = cp->ethdev->drv_submit_kwqes_16(dev->netdev, kwq, 1);
-	spin_unlock_bh(&cp->cnic_ulp_lock);
-
-	if (ret == 1)
-		return 0;
-
-	return -EBUSY;
-}
-
-static void cnic_reply_bnx2x_kcqes(struct cnic_dev *dev, int ulp_type,
-				   struct kcqe *cqes[], u32 num_cqes)
-{
-	struct cnic_local *cp = dev->cnic_priv;
-	struct cnic_ulp_ops *ulp_ops;
-
-	rcu_read_lock();
-	ulp_ops = rcu_dereference(cp->ulp_ops[ulp_type]);
-	if (likely(ulp_ops)) {
-		ulp_ops->indicate_kcqes(cp->ulp_handle[ulp_type],
-					  cqes, num_cqes);
-	}
-	rcu_read_unlock();
-}
-
-static int cnic_bnx2x_iscsi_init1(struct cnic_dev *dev, struct kwqe *kwqe)
-{
-	struct cnic_local *cp = dev->cnic_priv;
-	struct iscsi_kwqe_init1 *req1 = (struct iscsi_kwqe_init1 *) kwqe;
-	int func = cp->func, pages;
-	int hq_bds;
-
-	cp->num_iscsi_tasks = req1->num_tasks_per_conn;
-	cp->num_ccells = req1->num_ccells_per_conn;
-	cp->task_array_size = BNX2X_ISCSI_TASK_CONTEXT_SIZE *
-			      cp->num_iscsi_tasks;
-	cp->r2tq_size = cp->num_iscsi_tasks * BNX2X_ISCSI_MAX_PENDING_R2TS *
-			BNX2X_ISCSI_R2TQE_SIZE;
-	cp->hq_size = cp->num_ccells * BNX2X_ISCSI_HQ_BD_SIZE;
-	pages = PAGE_ALIGN(cp->hq_size) / PAGE_SIZE;
-	hq_bds = pages * (PAGE_SIZE / BNX2X_ISCSI_HQ_BD_SIZE);
-	cp->num_cqs = req1->num_cqs;
-
-	if (!dev->max_iscsi_conn)
-		return 0;
-
-	/* init Tstorm RAM */
-	CNIC_WR16(dev, BAR_TSTRORM_INTMEM + TSTORM_ISCSI_RQ_SIZE_OFFSET(func),
-		  req1->rq_num_wqes);
-	CNIC_WR16(dev, BAR_TSTRORM_INTMEM + TSTORM_ISCSI_PAGE_SIZE_OFFSET(func),
-		  PAGE_SIZE);
-	CNIC_WR8(dev, BAR_TSTRORM_INTMEM +
-		 TSTORM_ISCSI_PAGE_SIZE_LOG_OFFSET(func), PAGE_SHIFT);
-	CNIC_WR16(dev, BAR_TSTRORM_INTMEM +
-		  TSTORM_ISCSI_NUM_OF_TASKS_OFFSET(func),
-		  req1->num_tasks_per_conn);
-
-	/* init Ustorm RAM */
-	CNIC_WR16(dev, BAR_USTRORM_INTMEM +
-		  USTORM_ISCSI_RQ_BUFFER_SIZE_OFFSET(func),
-		  req1->rq_buffer_size);
-	CNIC_WR16(dev, BAR_USTRORM_INTMEM + USTORM_ISCSI_PAGE_SIZE_OFFSET(func),
-		  PAGE_SIZE);
-	CNIC_WR8(dev, BAR_USTRORM_INTMEM +
-		 USTORM_ISCSI_PAGE_SIZE_LOG_OFFSET(func), PAGE_SHIFT);
-	CNIC_WR16(dev, BAR_USTRORM_INTMEM +
-		  USTORM_ISCSI_NUM_OF_TASKS_OFFSET(func),
-		  req1->num_tasks_per_conn);
-	CNIC_WR16(dev, BAR_USTRORM_INTMEM + USTORM_ISCSI_RQ_SIZE_OFFSET(func),
-		  req1->rq_num_wqes);
-	CNIC_WR16(dev, BAR_USTRORM_INTMEM + USTORM_ISCSI_CQ_SIZE_OFFSET(func),
-		  req1->cq_num_wqes);
-	CNIC_WR16(dev, BAR_USTRORM_INTMEM + USTORM_ISCSI_R2TQ_SIZE_OFFSET(func),
-		  cp->num_iscsi_tasks * BNX2X_ISCSI_MAX_PENDING_R2TS);
-
-	/* init Xstorm RAM */
-	CNIC_WR16(dev, BAR_XSTRORM_INTMEM + XSTORM_ISCSI_PAGE_SIZE_OFFSET(func),
-		  PAGE_SIZE);
-	CNIC_WR8(dev, BAR_XSTRORM_INTMEM +
-		 XSTORM_ISCSI_PAGE_SIZE_LOG_OFFSET(func), PAGE_SHIFT);
-	CNIC_WR16(dev, BAR_XSTRORM_INTMEM +
-		  XSTORM_ISCSI_NUM_OF_TASKS_OFFSET(func),
-		  req1->num_tasks_per_conn);
-	CNIC_WR16(dev, BAR_XSTRORM_INTMEM + XSTORM_ISCSI_HQ_SIZE_OFFSET(func),
-		  hq_bds);
-	CNIC_WR16(dev, BAR_XSTRORM_INTMEM + XSTORM_ISCSI_SQ_SIZE_OFFSET(func),
-		  req1->num_tasks_per_conn);
-	CNIC_WR16(dev, BAR_XSTRORM_INTMEM + XSTORM_ISCSI_R2TQ_SIZE_OFFSET(func),
-		  cp->num_iscsi_tasks * BNX2X_ISCSI_MAX_PENDING_R2TS);
-
-	/* init Cstorm RAM */
-	CNIC_WR16(dev, BAR_CSTRORM_INTMEM + CSTORM_ISCSI_PAGE_SIZE_OFFSET(func),
-		  PAGE_SIZE);
-	CNIC_WR8(dev, BAR_CSTRORM_INTMEM +
-		 CSTORM_ISCSI_PAGE_SIZE_LOG_OFFSET(func), PAGE_SHIFT);
-	CNIC_WR16(dev, BAR_CSTRORM_INTMEM +
-		  CSTORM_ISCSI_NUM_OF_TASKS_OFFSET(func),
-		  req1->num_tasks_per_conn);
-	CNIC_WR16(dev, BAR_CSTRORM_INTMEM + CSTORM_ISCSI_CQ_SIZE_OFFSET(func),
-		  req1->cq_num_wqes);
-	CNIC_WR16(dev, BAR_CSTRORM_INTMEM + CSTORM_ISCSI_HQ_SIZE_OFFSET(func),
-		  hq_bds);
-
-	return 0;
-}
-
-static int cnic_bnx2x_iscsi_init2(struct cnic_dev *dev, struct kwqe *kwqe)
-{
-	struct iscsi_kwqe_init2 *req2 = (struct iscsi_kwqe_init2 *) kwqe;
-	struct cnic_local *cp = dev->cnic_priv;
-	int func = cp->func;
-	struct iscsi_kcqe kcqe;
-	struct kcqe *cqes[1];
-
-	memset(&kcqe, 0, sizeof(kcqe));
-	if (!dev->max_iscsi_conn) {
-		kcqe.completion_status =
-			ISCSI_KCQE_COMPLETION_STATUS_ISCSI_NOT_SUPPORTED;
-		goto done;
-	}
-
-	CNIC_WR(dev, BAR_TSTRORM_INTMEM +
-		TSTORM_ISCSI_ERROR_BITMAP_OFFSET(func), req2->error_bit_map[0]);
-	CNIC_WR(dev, BAR_TSTRORM_INTMEM +
-		TSTORM_ISCSI_ERROR_BITMAP_OFFSET(func) + 4,
-		req2->error_bit_map[1]);
-
-	CNIC_WR16(dev, BAR_USTRORM_INTMEM +
-		  USTORM_ISCSI_CQ_SQN_SIZE_OFFSET(func), req2->max_cq_sqn);
-	CNIC_WR(dev, BAR_USTRORM_INTMEM +
-		USTORM_ISCSI_ERROR_BITMAP_OFFSET(func), req2->error_bit_map[0]);
-	CNIC_WR(dev, BAR_USTRORM_INTMEM +
-		USTORM_ISCSI_ERROR_BITMAP_OFFSET(func) + 4,
-		req2->error_bit_map[1]);
-
-	CNIC_WR16(dev, BAR_CSTRORM_INTMEM +
-		  CSTORM_ISCSI_CQ_SQN_SIZE_OFFSET(func), req2->max_cq_sqn);
-
-	kcqe.completion_status = ISCSI_KCQE_COMPLETION_STATUS_SUCCESS;
-
-done:
-	kcqe.op_code = ISCSI_KCQE_OPCODE_INIT;
-	cqes[0] = (struct kcqe *) &kcqe;
-	cnic_reply_bnx2x_kcqes(dev, CNIC_ULP_ISCSI, cqes, 1);
-
-	return 0;
-}
-
-static void cnic_free_bnx2x_conn_resc(struct cnic_dev *dev, u32 l5_cid)
-{
-	struct cnic_local *cp = dev->cnic_priv;
-	struct cnic_context *ctx = &cp->ctx_tbl[l5_cid];
-
-	if (ctx->ulp_proto_id == CNIC_ULP_ISCSI) {
-		struct cnic_iscsi *iscsi = ctx->proto.iscsi;
-
-		cnic_free_dma(dev, &iscsi->hq_info);
-		cnic_free_dma(dev, &iscsi->r2tq_info);
-		cnic_free_dma(dev, &iscsi->task_array_info);
-	}
-	cnic_free_id(&cp->cid_tbl, ctx->cid);
-	ctx->cid = 0;
-}
-
-static int cnic_alloc_bnx2x_conn_resc(struct cnic_dev *dev, u32 l5_cid)
-{
-	u32 cid;
-	int ret, pages;
-	struct cnic_local *cp = dev->cnic_priv;
-	struct cnic_context *ctx = &cp->ctx_tbl[l5_cid];
-	struct cnic_iscsi *iscsi = ctx->proto.iscsi;
-
-	cid = cnic_alloc_new_id(&cp->cid_tbl);
-	if (cid == -1) {
-		ret = -ENOMEM;
-		goto error;
-	}
-
-	ctx->cid = cid;
-	pages = PAGE_ALIGN(cp->task_array_size) / PAGE_SIZE;
-
-	ret = cnic_alloc_dma(dev, &iscsi->task_array_info, pages, 1);
-	if (ret)
-		goto error;
-
-	pages = PAGE_ALIGN(cp->r2tq_size) / PAGE_SIZE;
-	ret = cnic_alloc_dma(dev, &iscsi->r2tq_info, pages, 1);
-	if (ret)
-		goto error;
-
-	pages = PAGE_ALIGN(cp->hq_size) / PAGE_SIZE;
-	ret = cnic_alloc_dma(dev, &iscsi->hq_info, pages, 1);
-	if (ret)
-		goto error;
-
-	return 0;
-
-error:
-	cnic_free_bnx2x_conn_resc(dev, l5_cid);
-	return ret;
-}
-
-static void *cnic_get_bnx2x_ctx(struct cnic_dev *dev, u32 cid, int init,
-				struct regpair *ctx_addr)
-{
-	struct cnic_local *cp = dev->cnic_priv;
-	struct cnic_eth_dev *ethdev = cp->ethdev;
-	int blk = (cid - ethdev->starting_cid) / cp->cids_per_blk;
-	int off = (cid - ethdev->starting_cid) % cp->cids_per_blk;
-	unsigned long align_off = 0;
-	dma_addr_t ctx_map;
-	void *ctx;
-
-	if (cp->ctx_align) {
-		unsigned long mask = cp->ctx_align - 1;
-
-		if (cp->ctx_arr[blk].mapping & mask)
-			align_off = cp->ctx_align -
-				    (cp->ctx_arr[blk].mapping & mask);
-	}
-	ctx_map = cp->ctx_arr[blk].mapping + align_off +
-		(off * BNX2X_CONTEXT_MEM_SIZE);
-	ctx = cp->ctx_arr[blk].ctx + align_off +
-	      (off * BNX2X_CONTEXT_MEM_SIZE);
-	if (init)
-		memset(ctx, 0, BNX2X_CONTEXT_MEM_SIZE);
-
-	ctx_addr->lo = ctx_map & 0xffffffff;
-	ctx_addr->hi = (u64) ctx_map >> 32;
-	return ctx;
-}
-
-static int cnic_setup_bnx2x_ctx(struct cnic_dev *dev, struct kwqe *wqes[],
-				u32 num)
-{
-	struct cnic_local *cp = dev->cnic_priv;
-	struct iscsi_kwqe_conn_offload1 *req1 =
-			(struct iscsi_kwqe_conn_offload1 *) wqes[0];
-	struct iscsi_kwqe_conn_offload2 *req2 =
-			(struct iscsi_kwqe_conn_offload2 *) wqes[1];
-	struct iscsi_kwqe_conn_offload3 *req3;
-	struct cnic_context *ctx = &cp->ctx_tbl[req1->iscsi_conn_id];
-	struct cnic_iscsi *iscsi = ctx->proto.iscsi;
-	u32 cid = ctx->cid;
-	u32 hw_cid = BNX2X_HW_CID(cid, cp->func);
-	struct iscsi_context *ictx;
-	struct regpair context_addr;
-	int i, j, n = 2, n_max;
-
-	ctx->ctx_flags = 0;
-	if (!req2->num_additional_wqes)
-		return -EINVAL;
-
-	n_max = req2->num_additional_wqes + 2;
-
-	ictx = cnic_get_bnx2x_ctx(dev, cid, 1, &context_addr);
-	if (ictx == NULL)
-		return -ENOMEM;
-
-	req3 = (struct iscsi_kwqe_conn_offload3 *) wqes[n++];
-
-	ictx->xstorm_ag_context.hq_prod = 1;
-
-	ictx->xstorm_st_context.iscsi.first_burst_length =
-		ISCSI_DEF_FIRST_BURST_LEN;
-	ictx->xstorm_st_context.iscsi.max_send_pdu_length =
-		ISCSI_DEF_MAX_RECV_SEG_LEN;
-	ictx->xstorm_st_context.iscsi.sq_pbl_base.lo =
-		req1->sq_page_table_addr_lo;
-	ictx->xstorm_st_context.iscsi.sq_pbl_base.hi =
-		req1->sq_page_table_addr_hi;
-	ictx->xstorm_st_context.iscsi.sq_curr_pbe.lo = req2->sq_first_pte.hi;
-	ictx->xstorm_st_context.iscsi.sq_curr_pbe.hi = req2->sq_first_pte.lo;
-	ictx->xstorm_st_context.iscsi.hq_pbl_base.lo =
-		iscsi->hq_info.pgtbl_map & 0xffffffff;
-	ictx->xstorm_st_context.iscsi.hq_pbl_base.hi =
-		(u64) iscsi->hq_info.pgtbl_map >> 32;
-	ictx->xstorm_st_context.iscsi.hq_curr_pbe_base.lo =
-		iscsi->hq_info.pgtbl[0];
-	ictx->xstorm_st_context.iscsi.hq_curr_pbe_base.hi =
-		iscsi->hq_info.pgtbl[1];
-	ictx->xstorm_st_context.iscsi.r2tq_pbl_base.lo =
-		iscsi->r2tq_info.pgtbl_map & 0xffffffff;
-	ictx->xstorm_st_context.iscsi.r2tq_pbl_base.hi =
-		(u64) iscsi->r2tq_info.pgtbl_map >> 32;
-	ictx->xstorm_st_context.iscsi.r2tq_curr_pbe_base.lo =
-		iscsi->r2tq_info.pgtbl[0];
-	ictx->xstorm_st_context.iscsi.r2tq_curr_pbe_base.hi =
-		iscsi->r2tq_info.pgtbl[1];
-	ictx->xstorm_st_context.iscsi.task_pbl_base.lo =
-		iscsi->task_array_info.pgtbl_map & 0xffffffff;
-	ictx->xstorm_st_context.iscsi.task_pbl_base.hi =
-		(u64) iscsi->task_array_info.pgtbl_map >> 32;
-	ictx->xstorm_st_context.iscsi.task_pbl_cache_idx =
-		BNX2X_ISCSI_PBL_NOT_CACHED;
-	ictx->xstorm_st_context.iscsi.flags.flags |=
-		XSTORM_ISCSI_CONTEXT_FLAGS_B_IMMEDIATE_DATA;
-	ictx->xstorm_st_context.iscsi.flags.flags |=
-		XSTORM_ISCSI_CONTEXT_FLAGS_B_INITIAL_R2T;
-
-	ictx->tstorm_st_context.iscsi.hdr_bytes_2_fetch = ISCSI_HEADER_SIZE;
-	/* TSTORM requires the base address of RQ DB & not PTE */
-	ictx->tstorm_st_context.iscsi.rq_db_phy_addr.lo =
-		req2->rq_page_table_addr_lo & PAGE_MASK;
-	ictx->tstorm_st_context.iscsi.rq_db_phy_addr.hi =
-		req2->rq_page_table_addr_hi;
-	ictx->tstorm_st_context.iscsi.iscsi_conn_id = req1->iscsi_conn_id;
-	ictx->tstorm_st_context.tcp.cwnd = 0x5A8;
-	ictx->tstorm_st_context.tcp.flags2 |=
-		TSTORM_TCP_ST_CONTEXT_SECTION_DA_EN;
-
-	ictx->timers_context.flags |= ISCSI_TIMERS_BLOCK_CONTEXT_CONN_VALID_FLG;
-
-	ictx->ustorm_st_context.ring.rq.pbl_base.lo =
-		req2->rq_page_table_addr_lo;
-	ictx->ustorm_st_context.ring.rq.pbl_base.hi =
-		req2->rq_page_table_addr_hi;
-	ictx->ustorm_st_context.ring.rq.curr_pbe.lo = req3->qp_first_pte[0].hi;
-	ictx->ustorm_st_context.ring.rq.curr_pbe.hi = req3->qp_first_pte[0].lo;
-	ictx->ustorm_st_context.ring.r2tq.pbl_base.lo =
-		iscsi->r2tq_info.pgtbl_map & 0xffffffff;
-	ictx->ustorm_st_context.ring.r2tq.pbl_base.hi =
-		(u64) iscsi->r2tq_info.pgtbl_map >> 32;
-	ictx->ustorm_st_context.ring.r2tq.curr_pbe.lo =
-		iscsi->r2tq_info.pgtbl[0];
-	ictx->ustorm_st_context.ring.r2tq.curr_pbe.hi =
-		iscsi->r2tq_info.pgtbl[1];
-	ictx->ustorm_st_context.ring.cq_pbl_base.lo =
-		req1->cq_page_table_addr_lo;
-	ictx->ustorm_st_context.ring.cq_pbl_base.hi =
-		req1->cq_page_table_addr_hi;
-	ictx->ustorm_st_context.ring.cq[0].cq_sn = ISCSI_INITIAL_SN;
-	ictx->ustorm_st_context.ring.cq[0].curr_pbe.lo = req2->cq_first_pte.hi;
-	ictx->ustorm_st_context.ring.cq[0].curr_pbe.hi = req2->cq_first_pte.lo;
-	ictx->ustorm_st_context.task_pbe_cache_index =
-		BNX2X_ISCSI_PBL_NOT_CACHED;
-	ictx->ustorm_st_context.task_pdu_cache_index =
-		BNX2X_ISCSI_PDU_HEADER_NOT_CACHED;
-
-	for (i = 1, j = 1; i < cp->num_cqs; i++, j++) {
-		if (j == 3) {
-			if (n >= n_max)
-				break;
-			req3 = (struct iscsi_kwqe_conn_offload3 *) wqes[n++];
-			j = 0;
-		}
-		ictx->ustorm_st_context.ring.cq[i].cq_sn = ISCSI_INITIAL_SN;
-		ictx->ustorm_st_context.ring.cq[i].curr_pbe.lo =
-			req3->qp_first_pte[j].hi;
-		ictx->ustorm_st_context.ring.cq[i].curr_pbe.hi =
-			req3->qp_first_pte[j].lo;
-	}
-
-	ictx->ustorm_st_context.task_pbl_base.lo =
-		iscsi->task_array_info.pgtbl_map & 0xffffffff;
-	ictx->ustorm_st_context.task_pbl_base.hi =
-		(u64) iscsi->task_array_info.pgtbl_map >> 32;
-	ictx->ustorm_st_context.tce_phy_addr.lo =
-		iscsi->task_array_info.pgtbl[0];
-	ictx->ustorm_st_context.tce_phy_addr.hi =
-		iscsi->task_array_info.pgtbl[1];
-	ictx->ustorm_st_context.iscsi_conn_id = req1->iscsi_conn_id;
-	ictx->ustorm_st_context.num_cqs = cp->num_cqs;
-	ictx->ustorm_st_context.negotiated_rx |= ISCSI_DEF_MAX_RECV_SEG_LEN;
-	ictx->ustorm_st_context.negotiated_rx_and_flags |=
-		ISCSI_DEF_MAX_BURST_LEN;
-	ictx->ustorm_st_context.negotiated_rx |=
-		ISCSI_DEFAULT_MAX_OUTSTANDING_R2T <<
-		USTORM_ISCSI_ST_CONTEXT_MAX_OUTSTANDING_R2TS_SHIFT;
-
-	ictx->cstorm_st_context.hq_pbl_base.lo =
-		iscsi->hq_info.pgtbl_map & 0xffffffff;
-	ictx->cstorm_st_context.hq_pbl_base.hi =
-		(u64) iscsi->hq_info.pgtbl_map >> 32;
-	ictx->cstorm_st_context.hq_curr_pbe.lo = iscsi->hq_info.pgtbl[0];
-	ictx->cstorm_st_context.hq_curr_pbe.hi = iscsi->hq_info.pgtbl[1];
-	ictx->cstorm_st_context.task_pbl_base.lo =
-		iscsi->task_array_info.pgtbl_map & 0xffffffff;
-	ictx->cstorm_st_context.task_pbl_base.hi =
-		(u64) iscsi->task_array_info.pgtbl_map >> 32;
-	/* CSTORM and USTORM initialization is different, CSTORM requires
-	 * CQ DB base & not PTE addr */
-	ictx->cstorm_st_context.cq_db_base.lo =
-		req1->cq_page_table_addr_lo & PAGE_MASK;
-	ictx->cstorm_st_context.cq_db_base.hi = req1->cq_page_table_addr_hi;
-	ictx->cstorm_st_context.iscsi_conn_id = req1->iscsi_conn_id;
-	ictx->cstorm_st_context.cq_proc_en_bit_map = (1 << cp->num_cqs) - 1;
-	for (i = 0; i < cp->num_cqs; i++) {
-		ictx->cstorm_st_context.cq_c_prod_sqn_arr.sqn[i] =
-			ISCSI_INITIAL_SN;
-		ictx->cstorm_st_context.cq_c_sqn_2_notify_arr.sqn[i] =
-			ISCSI_INITIAL_SN;
-	}
-
-	ictx->xstorm_ag_context.cdu_reserved =
-		CDU_RSRVD_VALUE_TYPE_A(hw_cid, CDU_REGION_NUMBER_XCM_AG,
-				       ISCSI_CONNECTION_TYPE);
-	ictx->ustorm_ag_context.cdu_usage =
-		CDU_RSRVD_VALUE_TYPE_A(hw_cid, CDU_REGION_NUMBER_UCM_AG,
-				       ISCSI_CONNECTION_TYPE);
-	return 0;
-
-}
-
-static int cnic_bnx2x_iscsi_ofld1(struct cnic_dev *dev, struct kwqe *wqes[],
-				   u32 num, int *work)
-{
-	struct iscsi_kwqe_conn_offload1 *req1;
-	struct iscsi_kwqe_conn_offload2 *req2;
-	struct cnic_local *cp = dev->cnic_priv;
-	struct iscsi_kcqe kcqe;
-	struct kcqe *cqes[1];
-	u32 l5_cid;
-	int ret;
-
-	if (num < 2) {
-		*work = num;
-		return -EINVAL;
-	}
-
-	req1 = (struct iscsi_kwqe_conn_offload1 *) wqes[0];
-	req2 = (struct iscsi_kwqe_conn_offload2 *) wqes[1];
-	if ((num - 2) < req2->num_additional_wqes) {
-		*work = num;
-		return -EINVAL;
-	}
-	*work = 2 + req2->num_additional_wqes;;
-
-	l5_cid = req1->iscsi_conn_id;
-	if (l5_cid >= MAX_ISCSI_TBL_SZ)
-		return -EINVAL;
-
-	memset(&kcqe, 0, sizeof(kcqe));
-	kcqe.op_code = ISCSI_KCQE_OPCODE_OFFLOAD_CONN;
-	kcqe.iscsi_conn_id = l5_cid;
-	kcqe.completion_status = ISCSI_KCQE_COMPLETION_STATUS_CTX_ALLOC_FAILURE;
-
-	if (atomic_inc_return(&cp->iscsi_conn) > dev->max_iscsi_conn) {
-		atomic_dec(&cp->iscsi_conn);
-		ret = 0;
-		goto done;
-	}
-	ret = cnic_alloc_bnx2x_conn_resc(dev, l5_cid);
-	if (ret) {
-		atomic_dec(&cp->iscsi_conn);
-		ret = 0;
-		goto done;
-	}
-	ret = cnic_setup_bnx2x_ctx(dev, wqes, num);
-	if (ret < 0) {
-		cnic_free_bnx2x_conn_resc(dev, l5_cid);
-		atomic_dec(&cp->iscsi_conn);
-		goto done;
-	}
-
-	kcqe.completion_status = ISCSI_KCQE_COMPLETION_STATUS_SUCCESS;
-	kcqe.iscsi_conn_context_id = BNX2X_HW_CID(cp->ctx_tbl[l5_cid].cid,
-						  cp->func);
-
-done:
-	cqes[0] = (struct kcqe *) &kcqe;
-	cnic_reply_bnx2x_kcqes(dev, CNIC_ULP_ISCSI, cqes, 1);
-	return ret;
-}
-
-
-static int cnic_bnx2x_iscsi_update(struct cnic_dev *dev, struct kwqe *kwqe)
-{
-	struct cnic_local *cp = dev->cnic_priv;
-	struct iscsi_kwqe_conn_update *req =
-		(struct iscsi_kwqe_conn_update *) kwqe;
-	void *data;
-	union l5cm_specific_data l5_data;
-	u32 l5_cid, cid = BNX2X_SW_CID(req->context_id);
-	int ret;
-
-	if (cnic_get_l5_cid(cp, cid, &l5_cid) != 0)
-		return -EINVAL;
-
-	data = cnic_get_kwqe_16_data(cp, l5_cid, &l5_data);
-	if (!data)
-		return -ENOMEM;
-
-	memcpy(data, kwqe, sizeof(struct kwqe));
-
-	ret = cnic_submit_kwqe_16(dev, ISCSI_RAMROD_CMD_ID_UPDATE_CONN,
-			req->context_id, ISCSI_CONNECTION_TYPE, &l5_data);
-	return ret;
-}
-
-static int cnic_bnx2x_iscsi_destroy(struct cnic_dev *dev, struct kwqe *kwqe)
-{
-	struct cnic_local *cp = dev->cnic_priv;
-	struct iscsi_kwqe_conn_destroy *req =
-		(struct iscsi_kwqe_conn_destroy *) kwqe;
-	union l5cm_specific_data l5_data;
-	u32 l5_cid = req->reserved0;
-	struct cnic_context *ctx = &cp->ctx_tbl[l5_cid];
-	int ret = 0;
-	struct iscsi_kcqe kcqe;
-	struct kcqe *cqes[1];
-
-	if (!(ctx->ctx_flags & CTX_FL_OFFLD_START))
-		goto skip_cfc_delete;
-
-	while (!time_after(jiffies, ctx->timestamp + (2 * HZ)))
-		msleep(250);
-
-	init_waitqueue_head(&ctx->waitq);
-	ctx->wait_cond = 0;
-	memset(&l5_data, 0, sizeof(l5_data));
-	ret = cnic_submit_kwqe_16(dev, RAMROD_CMD_ID_ETH_CFC_DEL,
-				  req->context_id,
-				  ETH_CONNECTION_TYPE |
-				  (1 << SPE_HDR_COMMON_RAMROD_SHIFT),
-				  &l5_data);
-	if (ret == 0)
-		wait_event(ctx->waitq, ctx->wait_cond);
-
-skip_cfc_delete:
-	cnic_free_bnx2x_conn_resc(dev, l5_cid);
-
-	atomic_dec(&cp->iscsi_conn);
-
-	memset(&kcqe, 0, sizeof(kcqe));
-	kcqe.op_code = ISCSI_KCQE_OPCODE_DESTROY_CONN;
-	kcqe.iscsi_conn_id = l5_cid;
-	kcqe.completion_status = ISCSI_KCQE_COMPLETION_STATUS_SUCCESS;
-	kcqe.iscsi_conn_context_id = req->context_id;
-
-	cqes[0] = (struct kcqe *) &kcqe;
-	cnic_reply_bnx2x_kcqes(dev, CNIC_ULP_ISCSI, cqes, 1);
-
-	return ret;
-}
-
-static void cnic_init_storm_conn_bufs(struct cnic_dev *dev,
-				      struct l4_kwq_connect_req1 *kwqe1,
-				      struct l4_kwq_connect_req3 *kwqe3,
-				      struct l5cm_active_conn_buffer *conn_buf)
-{
-	struct l5cm_conn_addr_params *conn_addr = &conn_buf->conn_addr_buf;
-	struct l5cm_xstorm_conn_buffer *xstorm_buf =
-		&conn_buf->xstorm_conn_buffer;
-	struct l5cm_tstorm_conn_buffer *tstorm_buf =
-		&conn_buf->tstorm_conn_buffer;
-	struct regpair context_addr;
-	u32 cid = BNX2X_SW_CID(kwqe1->cid);
-	struct in6_addr src_ip, dst_ip;
-	int i;
-	u32 *addrp;
-
-	addrp = (u32 *) &conn_addr->local_ip_addr;
-	for (i = 0; i < 4; i++, addrp++)
-		src_ip.in6_u.u6_addr32[i] = cpu_to_be32(*addrp);
-
-	addrp = (u32 *) &conn_addr->remote_ip_addr;
-	for (i = 0; i < 4; i++, addrp++)
-		dst_ip.in6_u.u6_addr32[i] = cpu_to_be32(*addrp);
-
-	cnic_get_bnx2x_ctx(dev, cid, 0, &context_addr);
-
-	xstorm_buf->context_addr.hi = context_addr.hi;
-	xstorm_buf->context_addr.lo = context_addr.lo;
-	xstorm_buf->mss = 0xffff;
-	xstorm_buf->rcv_buf = kwqe3->rcv_buf;
-	if (kwqe1->tcp_flags & L4_KWQ_CONNECT_REQ1_NAGLE_ENABLE)
-		xstorm_buf->params |= L5CM_XSTORM_CONN_BUFFER_NAGLE_ENABLE;
-	xstorm_buf->pseudo_header_checksum =
-		swab16(~csum_ipv6_magic(&src_ip, &dst_ip, 0, IPPROTO_TCP, 0));
-
-	if (!(kwqe1->tcp_flags & L4_KWQ_CONNECT_REQ1_NO_DELAY_ACK))
-		tstorm_buf->params |=
-			L5CM_TSTORM_CONN_BUFFER_DELAYED_ACK_ENABLE;
-	if (kwqe3->ka_timeout) {
-		tstorm_buf->ka_enable = 1;
-		tstorm_buf->ka_timeout = kwqe3->ka_timeout;
-		tstorm_buf->ka_interval = kwqe3->ka_interval;
-		tstorm_buf->ka_max_probe_count = kwqe3->ka_max_probe_count;
-	}
-	tstorm_buf->rcv_buf = kwqe3->rcv_buf;
-	tstorm_buf->snd_buf = kwqe3->snd_buf;
-	tstorm_buf->max_rt_time = 0xffffffff;
-}
-
-static void cnic_init_bnx2x_mac(struct cnic_dev *dev)
-{
-	struct cnic_local *cp = dev->cnic_priv;
-	int func = CNIC_FUNC(cp);
-	u8 *mac = dev->mac_addr;
-
-	CNIC_WR8(dev, BAR_XSTRORM_INTMEM +
-		 XSTORM_ISCSI_LOCAL_MAC_ADDR0_OFFSET(func), mac[0]);
-	CNIC_WR8(dev, BAR_XSTRORM_INTMEM +
-		 XSTORM_ISCSI_LOCAL_MAC_ADDR1_OFFSET(func), mac[1]);
-	CNIC_WR8(dev, BAR_XSTRORM_INTMEM +
-		 XSTORM_ISCSI_LOCAL_MAC_ADDR2_OFFSET(func), mac[2]);
-	CNIC_WR8(dev, BAR_XSTRORM_INTMEM +
-		 XSTORM_ISCSI_LOCAL_MAC_ADDR3_OFFSET(func), mac[3]);
-	CNIC_WR8(dev, BAR_XSTRORM_INTMEM +
-		 XSTORM_ISCSI_LOCAL_MAC_ADDR4_OFFSET(func), mac[4]);
-	CNIC_WR8(dev, BAR_XSTRORM_INTMEM +
-		 XSTORM_ISCSI_LOCAL_MAC_ADDR5_OFFSET(func), mac[5]);
-
-	CNIC_WR8(dev, BAR_TSTRORM_INTMEM +
-		 TSTORM_ISCSI_TCP_VARS_LSB_LOCAL_MAC_ADDR_OFFSET(func), mac[5]);
-	CNIC_WR8(dev, BAR_TSTRORM_INTMEM +
-		 TSTORM_ISCSI_TCP_VARS_LSB_LOCAL_MAC_ADDR_OFFSET(func) + 1,
-		 mac[4]);
-	CNIC_WR8(dev, BAR_TSTRORM_INTMEM +
-		 TSTORM_ISCSI_TCP_VARS_MSB_LOCAL_MAC_ADDR_OFFSET(func), mac[3]);
-	CNIC_WR8(dev, BAR_TSTRORM_INTMEM +
-		 TSTORM_ISCSI_TCP_VARS_MSB_LOCAL_MAC_ADDR_OFFSET(func) + 1,
-		 mac[2]);
-	CNIC_WR8(dev, BAR_TSTRORM_INTMEM +
-		 TSTORM_ISCSI_TCP_VARS_MSB_LOCAL_MAC_ADDR_OFFSET(func) + 2,
-		 mac[1]);
-	CNIC_WR8(dev, BAR_TSTRORM_INTMEM +
-		 TSTORM_ISCSI_TCP_VARS_MSB_LOCAL_MAC_ADDR_OFFSET(func) + 3,
-		 mac[0]);
-}
-
-static void cnic_bnx2x_set_tcp_timestamp(struct cnic_dev *dev, int tcp_ts)
-{
-	struct cnic_local *cp = dev->cnic_priv;
-	u8 xstorm_flags = XSTORM_L5CM_TCP_FLAGS_WND_SCL_EN;
-	u16 tstorm_flags = 0;
-
-	if (tcp_ts) {
-		xstorm_flags |= XSTORM_L5CM_TCP_FLAGS_TS_ENABLED;
-		tstorm_flags |= TSTORM_L5CM_TCP_FLAGS_TS_ENABLED;
-	}
-
-	CNIC_WR8(dev, BAR_XSTRORM_INTMEM +
-		 XSTORM_ISCSI_TCP_VARS_FLAGS_OFFSET(cp->func), xstorm_flags);
-
-	CNIC_WR16(dev, BAR_TSTRORM_INTMEM +
-		  TSTORM_ISCSI_TCP_VARS_FLAGS_OFFSET(cp->func), tstorm_flags);
-}
-
-static int cnic_bnx2x_connect(struct cnic_dev *dev, struct kwqe *wqes[],
-			      u32 num, int *work)
-{
-	struct cnic_local *cp = dev->cnic_priv;
-	struct l4_kwq_connect_req1 *kwqe1 =
-		(struct l4_kwq_connect_req1 *) wqes[0];
-	struct l4_kwq_connect_req3 *kwqe3;
-	struct l5cm_active_conn_buffer *conn_buf;
-	struct l5cm_conn_addr_params *conn_addr;
-	union l5cm_specific_data l5_data;
-	u32 l5_cid = kwqe1->pg_cid;
-	struct cnic_sock *csk = &cp->csk_tbl[l5_cid];
-	struct cnic_context *ctx = &cp->ctx_tbl[l5_cid];
-	int ret;
-
-	if (num < 2) {
-		*work = num;
-		return -EINVAL;
-	}
-
-	if (kwqe1->conn_flags & L4_KWQ_CONNECT_REQ1_IP_V6)
-		*work = 3;
-	else
-		*work = 2;
-
-	if (num < *work) {
-		*work = num;
-		return -EINVAL;
-	}
-
-	if (sizeof(*conn_buf) > CNIC_KWQ16_DATA_SIZE) {
-		printk(KERN_ERR PFX "%s: conn_buf size too big\n",
-			       dev->netdev->name);
-		return -ENOMEM;
-	}
-	conn_buf = cnic_get_kwqe_16_data(cp, l5_cid, &l5_data);
-	if (!conn_buf)
-		return -ENOMEM;
-
-	memset(conn_buf, 0, sizeof(*conn_buf));
-
-	conn_addr = &conn_buf->conn_addr_buf;
-	conn_addr->remote_addr_0 = csk->ha[0];
-	conn_addr->remote_addr_1 = csk->ha[1];
-	conn_addr->remote_addr_2 = csk->ha[2];
-	conn_addr->remote_addr_3 = csk->ha[3];
-	conn_addr->remote_addr_4 = csk->ha[4];
-	conn_addr->remote_addr_5 = csk->ha[5];
-
-	if (kwqe1->conn_flags & L4_KWQ_CONNECT_REQ1_IP_V6) {
-		struct l4_kwq_connect_req2 *kwqe2 =
-			(struct l4_kwq_connect_req2 *) wqes[1];
-
-		conn_addr->local_ip_addr.ip_addr_hi_hi = kwqe2->src_ip_v6_4;
-		conn_addr->local_ip_addr.ip_addr_hi_lo = kwqe2->src_ip_v6_3;
-		conn_addr->local_ip_addr.ip_addr_lo_hi = kwqe2->src_ip_v6_2;
-
-		conn_addr->remote_ip_addr.ip_addr_hi_hi = kwqe2->dst_ip_v6_4;
-		conn_addr->remote_ip_addr.ip_addr_hi_lo = kwqe2->dst_ip_v6_3;
-		conn_addr->remote_ip_addr.ip_addr_lo_hi = kwqe2->dst_ip_v6_2;
-		conn_addr->params |= L5CM_CONN_ADDR_PARAMS_IP_VERSION;
-	}
-	kwqe3 = (struct l4_kwq_connect_req3 *) wqes[*work - 1];
-
-	conn_addr->local_ip_addr.ip_addr_lo_lo = kwqe1->src_ip;
-	conn_addr->remote_ip_addr.ip_addr_lo_lo = kwqe1->dst_ip;
-	conn_addr->local_tcp_port = kwqe1->src_port;
-	conn_addr->remote_tcp_port = kwqe1->dst_port;
-
-	conn_addr->pmtu = kwqe3->pmtu;
-	cnic_init_storm_conn_bufs(dev, kwqe1, kwqe3, conn_buf);
-
-	CNIC_WR16(dev, BAR_XSTRORM_INTMEM +
-		  XSTORM_ISCSI_LOCAL_VLAN_OFFSET(cp->func), csk->vlan_id);
-
-	cnic_bnx2x_set_tcp_timestamp(dev,
-		kwqe1->tcp_flags & L4_KWQ_CONNECT_REQ1_TIME_STAMP);
-
-	ret = cnic_submit_kwqe_16(dev, L5CM_RAMROD_CMD_ID_TCP_CONNECT,
-			kwqe1->cid, ISCSI_CONNECTION_TYPE, &l5_data);
-	if (!ret)
-		ctx->ctx_flags |= CTX_FL_OFFLD_START;
-
-	return ret;
-}
-
-static int cnic_bnx2x_close(struct cnic_dev *dev, struct kwqe *kwqe)
-{
-	struct l4_kwq_close_req *req = (struct l4_kwq_close_req *) kwqe;
-	union l5cm_specific_data l5_data;
-	int ret;
-
-	memset(&l5_data, 0, sizeof(l5_data));
-	ret = cnic_submit_kwqe_16(dev, L5CM_RAMROD_CMD_ID_CLOSE,
-			req->cid, ISCSI_CONNECTION_TYPE, &l5_data);
-	return ret;
-}
-
-static int cnic_bnx2x_reset(struct cnic_dev *dev, struct kwqe *kwqe)
-{
-	struct l4_kwq_reset_req *req = (struct l4_kwq_reset_req *) kwqe;
-	union l5cm_specific_data l5_data;
-	int ret;
-
-	memset(&l5_data, 0, sizeof(l5_data));
-	ret = cnic_submit_kwqe_16(dev, L5CM_RAMROD_CMD_ID_ABORT,
-			req->cid, ISCSI_CONNECTION_TYPE, &l5_data);
-	return ret;
-}
-static int cnic_bnx2x_offload_pg(struct cnic_dev *dev, struct kwqe *kwqe)
-{
-	struct l4_kwq_offload_pg *req = (struct l4_kwq_offload_pg *) kwqe;
-	struct l4_kcq kcqe;
-	struct kcqe *cqes[1];
-
-	memset(&kcqe, 0, sizeof(kcqe));
-	kcqe.pg_host_opaque = req->host_opaque;
-	kcqe.pg_cid = req->host_opaque;
-	kcqe.op_code = L4_KCQE_OPCODE_VALUE_OFFLOAD_PG;
-	cqes[0] = (struct kcqe *) &kcqe;
-	cnic_reply_bnx2x_kcqes(dev, CNIC_ULP_L4, cqes, 1);
-	return 0;
-}
-
-static int cnic_bnx2x_update_pg(struct cnic_dev *dev, struct kwqe *kwqe)
-{
-	struct l4_kwq_update_pg *req = (struct l4_kwq_update_pg *) kwqe;
-	struct l4_kcq kcqe;
-	struct kcqe *cqes[1];
-
-	memset(&kcqe, 0, sizeof(kcqe));
-	kcqe.pg_host_opaque = req->pg_host_opaque;
-	kcqe.pg_cid = req->pg_cid;
-	kcqe.op_code = L4_KCQE_OPCODE_VALUE_UPDATE_PG;
-	cqes[0] = (struct kcqe *) &kcqe;
-	cnic_reply_bnx2x_kcqes(dev, CNIC_ULP_L4, cqes, 1);
-	return 0;
-}
-
-static int cnic_submit_bnx2x_kwqes(struct cnic_dev *dev, struct kwqe *wqes[],
-				   u32 num_wqes)
-{
-	int i, work, ret;
-	u32 opcode;
-	struct kwqe *kwqe;
-
-	if (!test_bit(CNIC_F_CNIC_UP, &dev->flags))
-		return -EAGAIN;		/* bnx2 is down */
-
-	for (i = 0; i < num_wqes; ) {
-		kwqe = wqes[i];
-		opcode = KWQE_OPCODE(kwqe->kwqe_op_flag);
-		work = 1;
-
-		switch (opcode) {
-		case ISCSI_KWQE_OPCODE_INIT1:
-			ret = cnic_bnx2x_iscsi_init1(dev, kwqe);
-			break;
-		case ISCSI_KWQE_OPCODE_INIT2:
-			ret = cnic_bnx2x_iscsi_init2(dev, kwqe);
-			break;
-		case ISCSI_KWQE_OPCODE_OFFLOAD_CONN1:
-			ret = cnic_bnx2x_iscsi_ofld1(dev, &wqes[i],
-						     num_wqes - i, &work);
-			break;
-		case ISCSI_KWQE_OPCODE_UPDATE_CONN:
-			ret = cnic_bnx2x_iscsi_update(dev, kwqe);
-			break;
-		case ISCSI_KWQE_OPCODE_DESTROY_CONN:
-			ret = cnic_bnx2x_iscsi_destroy(dev, kwqe);
-			break;
-		case L4_KWQE_OPCODE_VALUE_CONNECT1:
-			ret = cnic_bnx2x_connect(dev, &wqes[i], num_wqes - i,
-						 &work);
-			break;
-		case L4_KWQE_OPCODE_VALUE_CLOSE:
-			ret = cnic_bnx2x_close(dev, kwqe);
-			break;
-		case L4_KWQE_OPCODE_VALUE_RESET:
-			ret = cnic_bnx2x_reset(dev, kwqe);
-			break;
-		case L4_KWQE_OPCODE_VALUE_OFFLOAD_PG:
-			ret = cnic_bnx2x_offload_pg(dev, kwqe);
-			break;
-		case L4_KWQE_OPCODE_VALUE_UPDATE_PG:
-			ret = cnic_bnx2x_update_pg(dev, kwqe);
-			break;
-		case L4_KWQE_OPCODE_VALUE_UPLOAD_PG:
-			ret = 0;
-			break;
-		default:
-			ret = 0;
-			printk(KERN_ERR PFX "%s: Unknown type of KWQE(0x%x)\n",
-			       dev->netdev->name, opcode);
-			break;
-		}
-		if (ret < 0)
-			printk(KERN_ERR PFX "%s: KWQE(0x%x) failed\n",
-			       dev->netdev->name, opcode);
-		i += work;
-	}
-	return 0;
-}
-
-static void service_kcqes(struct cnic_dev *dev, int num_cqes)
-{
-	struct cnic_local *cp = dev->cnic_priv;
-	int i, j;
-
-	i = 0;
-	j = 1;
-	while (num_cqes) {
-		struct cnic_ulp_ops *ulp_ops;
-		int ulp_type;
-		u32 kcqe_op_flag = cp->completed_kcq[i]->kcqe_op_flag;
-		u32 kcqe_layer = kcqe_op_flag & KCQE_FLAGS_LAYER_MASK;
-
-		if (unlikely(kcqe_op_flag & KCQE_RAMROD_COMPLETION))
-			cnic_kwq_completion(dev, 1);
-
-		while (j < num_cqes) {
-			u32 next_op = cp->completed_kcq[i + j]->kcqe_op_flag;
-
-			if ((next_op & KCQE_FLAGS_LAYER_MASK) != kcqe_layer)
-				break;
-
-			if (unlikely(next_op & KCQE_RAMROD_COMPLETION))
-				cnic_kwq_completion(dev, 1);
-			j++;
-		}
-
-		if (kcqe_layer == KCQE_FLAGS_LAYER_MASK_L5_RDMA)
-			ulp_type = CNIC_ULP_RDMA;
-		else if (kcqe_layer == KCQE_FLAGS_LAYER_MASK_L5_ISCSI)
-			ulp_type = CNIC_ULP_ISCSI;
-		else if (kcqe_layer == KCQE_FLAGS_LAYER_MASK_L4)
-			ulp_type = CNIC_ULP_L4;
-		else if (kcqe_layer == KCQE_FLAGS_LAYER_MASK_L2)
-			goto end;
-		else {
-			printk(KERN_ERR PFX "%s: Unknown type of KCQE(0x%x)\n",
-			       dev->netdev->name, kcqe_op_flag);
-			goto end;
-		}
-
-		rcu_read_lock();
-		ulp_ops = rcu_dereference(cp->ulp_ops[ulp_type]);
-		if (likely(ulp_ops)) {
-			ulp_ops->indicate_kcqes(cp->ulp_handle[ulp_type],
-						  cp->completed_kcq + i, j);
-		}
-		rcu_read_unlock();
-end:
-		num_cqes -= j;
-		i += j;
-		j = 1;
-	}
-	return;
-}
-
-static u16 cnic_bnx2_next_idx(u16 idx)
-{
-	return idx + 1;
-}
-
-static u16 cnic_bnx2_hw_idx(u16 idx)
-{
-	return idx;
-}
-
-static u16 cnic_bnx2x_next_idx(u16 idx)
-{
-	idx++;
-	if ((idx & MAX_KCQE_CNT) == MAX_KCQE_CNT)
-		idx++;
-
-	return idx;
-}
-
-static u16 cnic_bnx2x_hw_idx(u16 idx)
-{
-	if ((idx & MAX_KCQE_CNT) == MAX_KCQE_CNT)
-		idx++;
-	return idx;
-}
-
-static int cnic_get_kcqes(struct cnic_dev *dev, u16 hw_prod, u16 *sw_prod)
-{
-	struct cnic_local *cp = dev->cnic_priv;
-	u16 i, ri, last;
-	struct kcqe *kcqe;
-	int kcqe_cnt = 0, last_cnt = 0;
-
-	i = ri = last = *sw_prod;
-	ri &= MAX_KCQ_IDX;
-
-	while ((i != hw_prod) && (kcqe_cnt < MAX_COMPLETED_KCQE)) {
-		kcqe = &cp->kcq[KCQ_PG(ri)][KCQ_IDX(ri)];
-		cp->completed_kcq[kcqe_cnt++] = kcqe;
-		i = cp->next_idx(i);
-		ri = i & MAX_KCQ_IDX;
-		if (likely(!(kcqe->kcqe_op_flag & KCQE_FLAGS_NEXT))) {
-			last_cnt = kcqe_cnt;
-			last = i;
-		}
-	}
-
-	*sw_prod = last;
-	return last_cnt;
-}
-
-static void cnic_chk_pkt_rings(struct cnic_local *cp)
-{
-	u16 rx_cons = *cp->rx_cons_ptr;
-	u16 tx_cons = *cp->tx_cons_ptr;
-
-	if (cp->tx_cons != tx_cons || cp->rx_cons != rx_cons) {
-		cp->tx_cons = tx_cons;
-		cp->rx_cons = rx_cons;
-
-		uio_event_notify(cp->cnic_uinfo);
-	}
-}
-
-static int cnic_service_bnx2(void *data, void *status_blk)
-{
-	struct cnic_dev *dev = data;
-	struct status_block *sblk = status_blk;
-	struct cnic_local *cp = dev->cnic_priv;
-	u32 status_idx = sblk->status_idx;
-	u16 hw_prod, sw_prod;
-	int kcqe_cnt;
-
-	if (unlikely(!test_bit(CNIC_F_CNIC_UP, &dev->flags)))
-		return status_idx;
-
-	cp->kwq_con_idx = *cp->kwq_con_idx_ptr;
-
-	hw_prod = sblk->status_completion_producer_index;
-	sw_prod = cp->kcq_prod_idx;
-	while (sw_prod != hw_prod) {
-		kcqe_cnt = cnic_get_kcqes(dev, hw_prod, &sw_prod);
-		if (kcqe_cnt == 0)
-			goto done;
-
-		service_kcqes(dev, kcqe_cnt);
-
-		/* Tell compiler that status_blk fields can change. */
-		barrier();
-		if (status_idx != sblk->status_idx) {
-			status_idx = sblk->status_idx;
-			cp->kwq_con_idx = *cp->kwq_con_idx_ptr;
-			hw_prod = sblk->status_completion_producer_index;
-		} else
-			break;
-	}
-
-done:
-	CNIC_WR16(dev, cp->kcq_io_addr, sw_prod);
-
-	cp->kcq_prod_idx = sw_prod;
-
-	cnic_chk_pkt_rings(cp);
-	return status_idx;
-}
-
-static void cnic_service_bnx2_msix(unsigned long data)
-{
-	struct cnic_dev *dev = (struct cnic_dev *) data;
-	struct cnic_local *cp = dev->cnic_priv;
-	struct status_block_msix *status_blk = cp->status_blk.bnx2;
-	u32 status_idx = status_blk->status_idx;
-	u16 hw_prod, sw_prod;
-	int kcqe_cnt;
-
-	cp->kwq_con_idx = status_blk->status_cmd_consumer_index;
-
-	hw_prod = status_blk->status_completion_producer_index;
-	sw_prod = cp->kcq_prod_idx;
-	while (sw_prod != hw_prod) {
-		kcqe_cnt = cnic_get_kcqes(dev, hw_prod, &sw_prod);
-		if (kcqe_cnt == 0)
-			goto done;
-
-		service_kcqes(dev, kcqe_cnt);
-
-		/* Tell compiler that status_blk fields can change. */
-		barrier();
-		if (status_idx != status_blk->status_idx) {
-			status_idx = status_blk->status_idx;
-			cp->kwq_con_idx = status_blk->status_cmd_consumer_index;
-			hw_prod = status_blk->status_completion_producer_index;
-		} else
-			break;
-	}
-
-done:
-	CNIC_WR16(dev, cp->kcq_io_addr, sw_prod);
-	cp->kcq_prod_idx = sw_prod;
-
-	cnic_chk_pkt_rings(cp);
-
-	cp->last_status_idx = status_idx;
-	CNIC_WR(dev, BNX2_PCICFG_INT_ACK_CMD, cp->int_num |
-		BNX2_PCICFG_INT_ACK_CMD_INDEX_VALID | cp->last_status_idx);
-}
-
-static irqreturn_t cnic_irq(int irq, void *dev_instance)
-{
-	struct cnic_dev *dev = dev_instance;
-	struct cnic_local *cp = dev->cnic_priv;
-	u16 prod = cp->kcq_prod_idx & MAX_KCQ_IDX;
-
-	if (cp->ack_int)
-		cp->ack_int(dev);
-
-	prefetch(cp->status_blk.gen);
-	prefetch(&cp->kcq[KCQ_PG(prod)][KCQ_IDX(prod)]);
-
-	if (likely(test_bit(CNIC_F_CNIC_UP, &dev->flags)))
-		tasklet_schedule(&cp->cnic_irq_task);
-
-	return IRQ_HANDLED;
-}
-
-static inline void cnic_ack_bnx2x_int(struct cnic_dev *dev, u8 id, u8 storm,
-				      u16 index, u8 op, u8 update)
-{
-	struct cnic_local *cp = dev->cnic_priv;
-	u32 hc_addr = (HC_REG_COMMAND_REG + CNIC_PORT(cp) * 32 +
-		       COMMAND_REG_INT_ACK);
-	struct igu_ack_register igu_ack;
-
-	igu_ack.status_block_index = index;
-	igu_ack.sb_id_and_flags =
-			((id << IGU_ACK_REGISTER_STATUS_BLOCK_ID_SHIFT) |
-			 (storm << IGU_ACK_REGISTER_STORM_ID_SHIFT) |
-			 (update << IGU_ACK_REGISTER_UPDATE_INDEX_SHIFT) |
-			 (op << IGU_ACK_REGISTER_INTERRUPT_MODE_SHIFT));
-
-	CNIC_WR(dev, hc_addr, (*(u32 *)&igu_ack));
-}
-
-static void cnic_ack_bnx2x_msix(struct cnic_dev *dev)
-{
-	struct cnic_local *cp = dev->cnic_priv;
-
-	cnic_ack_bnx2x_int(dev, cp->status_blk_num, CSTORM_ID, 0,
-			   IGU_INT_DISABLE, 0);
-}
-
-static void cnic_service_bnx2x_bh(unsigned long data)
-{
-	struct cnic_dev *dev = (struct cnic_dev *) data;
-	struct cnic_local *cp = dev->cnic_priv;
-	u16 hw_prod, sw_prod;
-	struct cstorm_status_block_c *sblk =
-		&cp->status_blk.bnx2x->c_status_block;
-	u32 status_idx = sblk->status_block_index;
-	int kcqe_cnt;
-
-	if (unlikely(!test_bit(CNIC_F_CNIC_UP, &dev->flags)))
-		return;
-
-	hw_prod = sblk->index_values[HC_INDEX_C_ISCSI_EQ_CONS];
-	hw_prod = cp->hw_idx(hw_prod);
-	sw_prod = cp->kcq_prod_idx;
-	while (sw_prod != hw_prod) {
-		kcqe_cnt = cnic_get_kcqes(dev, hw_prod, &sw_prod);
-		if (kcqe_cnt == 0)
-			goto done;
-
-		service_kcqes(dev, kcqe_cnt);
-
-		/* Tell compiler that sblk fields can change. */
-		barrier();
-		if (status_idx == sblk->status_block_index)
-			break;
-
-		status_idx = sblk->status_block_index;
-		hw_prod = sblk->index_values[HC_INDEX_C_ISCSI_EQ_CONS];
-		hw_prod = cp->hw_idx(hw_prod);
-	}
-
-done:
-	CNIC_WR16(dev, cp->kcq_io_addr, sw_prod + MAX_KCQ_IDX);
-	cnic_ack_bnx2x_int(dev, cp->status_blk_num, CSTORM_ID,
-			   status_idx, IGU_INT_ENABLE, 1);
-
-	cp->kcq_prod_idx = sw_prod;
-	return;
-}
-
-static int cnic_service_bnx2x(void *data, void *status_blk)
-{
-	struct cnic_dev *dev = data;
-	struct cnic_local *cp = dev->cnic_priv;
-	u16 prod = cp->kcq_prod_idx & MAX_KCQ_IDX;
-
-	if (likely(test_bit(CNIC_F_CNIC_UP, &dev->flags))) {
-		prefetch(cp->status_blk.bnx2x);
-		prefetch(&cp->kcq[KCQ_PG(prod)][KCQ_IDX(prod)]);
-
-		tasklet_schedule(&cp->cnic_irq_task);
-		cnic_chk_pkt_rings(cp);
-	}
-
-	return 0;
-}
-
-static void cnic_ulp_stop(struct cnic_dev *dev)
-{
-	struct cnic_local *cp = dev->cnic_priv;
-	int if_type;
-
-	if (cp->cnic_uinfo)
-		cnic_send_nlmsg(cp, ISCSI_KEVENT_IF_DOWN, NULL);
-
-	for (if_type = 0; if_type < MAX_CNIC_ULP_TYPE; if_type++) {
-		struct cnic_ulp_ops *ulp_ops;
-
-		mutex_lock(&cnic_lock);
-		ulp_ops = cp->ulp_ops[if_type];
-		if (!ulp_ops) {
-			mutex_unlock(&cnic_lock);
-			continue;
-		}
-		set_bit(ULP_F_CALL_PENDING, &cp->ulp_flags[if_type]);
-		mutex_unlock(&cnic_lock);
-
-		if (test_and_clear_bit(ULP_F_START, &cp->ulp_flags[if_type]))
-			ulp_ops->cnic_stop(cp->ulp_handle[if_type]);
-
-		clear_bit(ULP_F_CALL_PENDING, &cp->ulp_flags[if_type]);
-	}
-}
-
-static void cnic_ulp_start(struct cnic_dev *dev)
-{
-	struct cnic_local *cp = dev->cnic_priv;
-	int if_type;
-
-	for (if_type = 0; if_type < MAX_CNIC_ULP_TYPE; if_type++) {
-		struct cnic_ulp_ops *ulp_ops;
-
-		mutex_lock(&cnic_lock);
-		ulp_ops = cp->ulp_ops[if_type];
-		if (!ulp_ops || !ulp_ops->cnic_start) {
-			mutex_unlock(&cnic_lock);
-			continue;
-		}
-		set_bit(ULP_F_CALL_PENDING, &cp->ulp_flags[if_type]);
-		mutex_unlock(&cnic_lock);
-
-		if (!test_and_set_bit(ULP_F_START, &cp->ulp_flags[if_type]))
-			ulp_ops->cnic_start(cp->ulp_handle[if_type]);
-
-		clear_bit(ULP_F_CALL_PENDING, &cp->ulp_flags[if_type]);
-	}
-}
-
-static int cnic_ctl(void *data, struct cnic_ctl_info *info)
-{
-	struct cnic_dev *dev = data;
-
-	switch (info->cmd) {
-	case CNIC_CTL_STOP_CMD:
-		cnic_hold(dev);
-
-		cnic_ulp_stop(dev);
-		cnic_stop_hw(dev);
-
-		cnic_put(dev);
-		break;
-	case CNIC_CTL_START_CMD:
-		cnic_hold(dev);
-
-		if (!cnic_start_hw(dev))
-			cnic_ulp_start(dev);
-
-		cnic_put(dev);
-		break;
-	case CNIC_CTL_COMPLETION_CMD: {
-		u32 cid = BNX2X_SW_CID(info->data.comp.cid);
-		u32 l5_cid;
-		struct cnic_local *cp = dev->cnic_priv;
-
-		if (cnic_get_l5_cid(cp, cid, &l5_cid) == 0) {
-			struct cnic_context *ctx = &cp->ctx_tbl[l5_cid];
-
-			ctx->wait_cond = 1;
-			wake_up(&ctx->waitq);
-		}
-		break;
-	}
-	default:
-		return -EINVAL;
-	}
-	return 0;
-}
-
-static void cnic_ulp_init(struct cnic_dev *dev)
-{
-	int i;
-	struct cnic_local *cp = dev->cnic_priv;
-
-	for (i = 0; i < MAX_CNIC_ULP_TYPE_EXT; i++) {
-		struct cnic_ulp_ops *ulp_ops;
-
-		mutex_lock(&cnic_lock);
-		ulp_ops = cnic_ulp_tbl[i];
-		if (!ulp_ops || !ulp_ops->cnic_init) {
-			mutex_unlock(&cnic_lock);
-			continue;
-		}
-		ulp_get(ulp_ops);
-		mutex_unlock(&cnic_lock);
-
-		if (!test_and_set_bit(ULP_F_INIT, &cp->ulp_flags[i]))
-			ulp_ops->cnic_init(dev);
-
-		ulp_put(ulp_ops);
-	}
-}
-
-static void cnic_ulp_exit(struct cnic_dev *dev)
-{
-	int i;
-	struct cnic_local *cp = dev->cnic_priv;
-
-	for (i = 0; i < MAX_CNIC_ULP_TYPE_EXT; i++) {
-		struct cnic_ulp_ops *ulp_ops;
-
-		mutex_lock(&cnic_lock);
-		ulp_ops = cnic_ulp_tbl[i];
-		if (!ulp_ops || !ulp_ops->cnic_exit) {
-			mutex_unlock(&cnic_lock);
-			continue;
-		}
-		ulp_get(ulp_ops);
-		mutex_unlock(&cnic_lock);
-
-		if (test_and_clear_bit(ULP_F_INIT, &cp->ulp_flags[i]))
-			ulp_ops->cnic_exit(dev);
-
-		ulp_put(ulp_ops);
-	}
-}
-
-static int cnic_cm_offload_pg(struct cnic_sock *csk)
-{
-	struct cnic_dev *dev = csk->dev;
-	struct l4_kwq_offload_pg *l4kwqe;
-	struct kwqe *wqes[1];
-
-	l4kwqe = (struct l4_kwq_offload_pg *) &csk->kwqe1;
-	memset(l4kwqe, 0, sizeof(*l4kwqe));
-	wqes[0] = (struct kwqe *) l4kwqe;
-
-	l4kwqe->op_code = L4_KWQE_OPCODE_VALUE_OFFLOAD_PG;
-	l4kwqe->flags =
-		L4_LAYER_CODE << L4_KWQ_OFFLOAD_PG_LAYER_CODE_SHIFT;
-	l4kwqe->l2hdr_nbytes = ETH_HLEN;
-
-	l4kwqe->da0 = csk->ha[0];
-	l4kwqe->da1 = csk->ha[1];
-	l4kwqe->da2 = csk->ha[2];
-	l4kwqe->da3 = csk->ha[3];
-	l4kwqe->da4 = csk->ha[4];
-	l4kwqe->da5 = csk->ha[5];
-
-	l4kwqe->sa0 = dev->mac_addr[0];
-	l4kwqe->sa1 = dev->mac_addr[1];
-	l4kwqe->sa2 = dev->mac_addr[2];
-	l4kwqe->sa3 = dev->mac_addr[3];
-	l4kwqe->sa4 = dev->mac_addr[4];
-	l4kwqe->sa5 = dev->mac_addr[5];
-
-	l4kwqe->etype = ETH_P_IP;
-	l4kwqe->ipid_count = DEF_IPID_COUNT;
-	l4kwqe->host_opaque = csk->l5_cid;
-
-	if (csk->vlan_id) {
-		l4kwqe->pg_flags |= L4_KWQ_OFFLOAD_PG_VLAN_TAGGING;
-		l4kwqe->vlan_tag = csk->vlan_id;
-		l4kwqe->l2hdr_nbytes += 4;
-	}
-
-	return dev->submit_kwqes(dev, wqes, 1);
-}
-
-static int cnic_cm_update_pg(struct cnic_sock *csk)
-{
-	struct cnic_dev *dev = csk->dev;
-	struct l4_kwq_update_pg *l4kwqe;
-	struct kwqe *wqes[1];
-
-	l4kwqe = (struct l4_kwq_update_pg *) &csk->kwqe1;
-	memset(l4kwqe, 0, sizeof(*l4kwqe));
-	wqes[0] = (struct kwqe *) l4kwqe;
-
-	l4kwqe->opcode = L4_KWQE_OPCODE_VALUE_UPDATE_PG;
-	l4kwqe->flags =
-		L4_LAYER_CODE << L4_KWQ_UPDATE_PG_LAYER_CODE_SHIFT;
-	l4kwqe->pg_cid = csk->pg_cid;
-
-	l4kwqe->da0 = csk->ha[0];
-	l4kwqe->da1 = csk->ha[1];
-	l4kwqe->da2 = csk->ha[2];
-	l4kwqe->da3 = csk->ha[3];
-	l4kwqe->da4 = csk->ha[4];
-	l4kwqe->da5 = csk->ha[5];
-
-	l4kwqe->pg_host_opaque = csk->l5_cid;
-	l4kwqe->pg_valids = L4_KWQ_UPDATE_PG_VALIDS_DA;
-
-	return dev->submit_kwqes(dev, wqes, 1);
-}
-
-static int cnic_cm_upload_pg(struct cnic_sock *csk)
-{
-	struct cnic_dev *dev = csk->dev;
-	struct l4_kwq_upload *l4kwqe;
-	struct kwqe *wqes[1];
-
-	l4kwqe = (struct l4_kwq_upload *) &csk->kwqe1;
-	memset(l4kwqe, 0, sizeof(*l4kwqe));
-	wqes[0] = (struct kwqe *) l4kwqe;
-
-	l4kwqe->opcode = L4_KWQE_OPCODE_VALUE_UPLOAD_PG;
-	l4kwqe->flags =
-		L4_LAYER_CODE << L4_KWQ_UPLOAD_LAYER_CODE_SHIFT;
-	l4kwqe->cid = csk->pg_cid;
-
-	return dev->submit_kwqes(dev, wqes, 1);
-}
-
-static int cnic_cm_conn_req(struct cnic_sock *csk)
-{
-	struct cnic_dev *dev = csk->dev;
-	struct l4_kwq_connect_req1 *l4kwqe1;
-	struct l4_kwq_connect_req2 *l4kwqe2;
-	struct l4_kwq_connect_req3 *l4kwqe3;
-	struct kwqe *wqes[3];
-	u8 tcp_flags = 0;
-	int num_wqes = 2;
-
-	l4kwqe1 = (struct l4_kwq_connect_req1 *) &csk->kwqe1;
-	l4kwqe2 = (struct l4_kwq_connect_req2 *) &csk->kwqe2;
-	l4kwqe3 = (struct l4_kwq_connect_req3 *) &csk->kwqe3;
-	memset(l4kwqe1, 0, sizeof(*l4kwqe1));
-	memset(l4kwqe2, 0, sizeof(*l4kwqe2));
-	memset(l4kwqe3, 0, sizeof(*l4kwqe3));
-
-	l4kwqe3->op_code = L4_KWQE_OPCODE_VALUE_CONNECT3;
-	l4kwqe3->flags =
-		L4_LAYER_CODE << L4_KWQ_CONNECT_REQ3_LAYER_CODE_SHIFT;
-	l4kwqe3->ka_timeout = csk->ka_timeout;
-	l4kwqe3->ka_interval = csk->ka_interval;
-	l4kwqe3->ka_max_probe_count = csk->ka_max_probe_count;
-	l4kwqe3->tos = csk->tos;
-	l4kwqe3->ttl = csk->ttl;
-	l4kwqe3->snd_seq_scale = csk->snd_seq_scale;
-	l4kwqe3->pmtu = csk->mtu;
-	l4kwqe3->rcv_buf = csk->rcv_buf;
-	l4kwqe3->snd_buf = csk->snd_buf;
-	l4kwqe3->seed = csk->seed;
-
-	wqes[0] = (struct kwqe *) l4kwqe1;
-	if (test_bit(SK_F_IPV6, &csk->flags)) {
-		wqes[1] = (struct kwqe *) l4kwqe2;
-		wqes[2] = (struct kwqe *) l4kwqe3;
-		num_wqes = 3;
-
-		l4kwqe1->conn_flags = L4_KWQ_CONNECT_REQ1_IP_V6;
-		l4kwqe2->op_code = L4_KWQE_OPCODE_VALUE_CONNECT2;
-		l4kwqe2->flags =
-			L4_KWQ_CONNECT_REQ2_LINKED_WITH_NEXT |
-			L4_LAYER_CODE << L4_KWQ_CONNECT_REQ2_LAYER_CODE_SHIFT;
-		l4kwqe2->src_ip_v6_2 = be32_to_cpu(csk->src_ip[1]);
-		l4kwqe2->src_ip_v6_3 = be32_to_cpu(csk->src_ip[2]);
-		l4kwqe2->src_ip_v6_4 = be32_to_cpu(csk->src_ip[3]);
-		l4kwqe2->dst_ip_v6_2 = be32_to_cpu(csk->dst_ip[1]);
-		l4kwqe2->dst_ip_v6_3 = be32_to_cpu(csk->dst_ip[2]);
-		l4kwqe2->dst_ip_v6_4 = be32_to_cpu(csk->dst_ip[3]);
-		l4kwqe3->mss = l4kwqe3->pmtu - sizeof(struct ipv6hdr) -
-			       sizeof(struct tcphdr);
-	} else {
-		wqes[1] = (struct kwqe *) l4kwqe3;
-		l4kwqe3->mss = l4kwqe3->pmtu - sizeof(struct iphdr) -
-			       sizeof(struct tcphdr);
-	}
-
-	l4kwqe1->op_code = L4_KWQE_OPCODE_VALUE_CONNECT1;
-	l4kwqe1->flags =
-		(L4_LAYER_CODE << L4_KWQ_CONNECT_REQ1_LAYER_CODE_SHIFT) |
-		 L4_KWQ_CONNECT_REQ3_LINKED_WITH_NEXT;
-	l4kwqe1->cid = csk->cid;
-	l4kwqe1->pg_cid = csk->pg_cid;
-	l4kwqe1->src_ip = be32_to_cpu(csk->src_ip[0]);
-	l4kwqe1->dst_ip = be32_to_cpu(csk->dst_ip[0]);
-	l4kwqe1->src_port = be16_to_cpu(csk->src_port);
-	l4kwqe1->dst_port = be16_to_cpu(csk->dst_port);
-	if (csk->tcp_flags & SK_TCP_NO_DELAY_ACK)
-		tcp_flags |= L4_KWQ_CONNECT_REQ1_NO_DELAY_ACK;
-	if (csk->tcp_flags & SK_TCP_KEEP_ALIVE)
-		tcp_flags |= L4_KWQ_CONNECT_REQ1_KEEP_ALIVE;
-	if (csk->tcp_flags & SK_TCP_NAGLE)
-		tcp_flags |= L4_KWQ_CONNECT_REQ1_NAGLE_ENABLE;
-	if (csk->tcp_flags & SK_TCP_TIMESTAMP)
-		tcp_flags |= L4_KWQ_CONNECT_REQ1_TIME_STAMP;
-	if (csk->tcp_flags & SK_TCP_SACK)
-		tcp_flags |= L4_KWQ_CONNECT_REQ1_SACK;
-	if (csk->tcp_flags & SK_TCP_SEG_SCALING)
-		tcp_flags |= L4_KWQ_CONNECT_REQ1_SEG_SCALING;
-
-	l4kwqe1->tcp_flags = tcp_flags;
-
-	return dev->submit_kwqes(dev, wqes, num_wqes);
-}
-
-static int cnic_cm_close_req(struct cnic_sock *csk)
-{
-	struct cnic_dev *dev = csk->dev;
-	struct l4_kwq_close_req *l4kwqe;
-	struct kwqe *wqes[1];
-
-	l4kwqe = (struct l4_kwq_close_req *) &csk->kwqe2;
-	memset(l4kwqe, 0, sizeof(*l4kwqe));
-	wqes[0] = (struct kwqe *) l4kwqe;
-
-	l4kwqe->op_code = L4_KWQE_OPCODE_VALUE_CLOSE;
-	l4kwqe->flags = L4_LAYER_CODE << L4_KWQ_CLOSE_REQ_LAYER_CODE_SHIFT;
-	l4kwqe->cid = csk->cid;
-
-	return dev->submit_kwqes(dev, wqes, 1);
-}
-
-static int cnic_cm_abort_req(struct cnic_sock *csk)
-{
-	struct cnic_dev *dev = csk->dev;
-	struct l4_kwq_reset_req *l4kwqe;
-	struct kwqe *wqes[1];
-
-	l4kwqe = (struct l4_kwq_reset_req *) &csk->kwqe2;
-	memset(l4kwqe, 0, sizeof(*l4kwqe));
-	wqes[0] = (struct kwqe *) l4kwqe;
-
-	l4kwqe->op_code = L4_KWQE_OPCODE_VALUE_RESET;
-	l4kwqe->flags = L4_LAYER_CODE << L4_KWQ_RESET_REQ_LAYER_CODE_SHIFT;
-	l4kwqe->cid = csk->cid;
-
-	return dev->submit_kwqes(dev, wqes, 1);
-}
-
-static int cnic_cm_create(struct cnic_dev *dev, int ulp_type, u32 cid,
-			  u32 l5_cid, struct cnic_sock **csk, void *context)
-{
-	struct cnic_local *cp = dev->cnic_priv;
-	struct cnic_sock *csk1;
-
-	if (l5_cid >= MAX_CM_SK_TBL_SZ)
-		return -EINVAL;
-
-	csk1 = &cp->csk_tbl[l5_cid];
-	if (atomic_read(&csk1->ref_count))
-		return -EAGAIN;
-
-	if (test_and_set_bit(SK_F_INUSE, &csk1->flags))
-		return -EBUSY;
-
-	csk1->dev = dev;
-	csk1->cid = cid;
-	csk1->l5_cid = l5_cid;
-	csk1->ulp_type = ulp_type;
-	csk1->context = context;
-
-	csk1->ka_timeout = DEF_KA_TIMEOUT;
-	csk1->ka_interval = DEF_KA_INTERVAL;
-	csk1->ka_max_probe_count = DEF_KA_MAX_PROBE_COUNT;
-	csk1->tos = DEF_TOS;
-	csk1->ttl = DEF_TTL;
-	csk1->snd_seq_scale = DEF_SND_SEQ_SCALE;
-	csk1->rcv_buf = DEF_RCV_BUF;
-	csk1->snd_buf = DEF_SND_BUF;
-	csk1->seed = DEF_SEED;
-
-	*csk = csk1;
-	return 0;
-}
-
-static void cnic_cm_cleanup(struct cnic_sock *csk)
-{
-	if (csk->src_port) {
-		struct cnic_dev *dev = csk->dev;
-		struct cnic_local *cp = dev->cnic_priv;
-
-		cnic_free_id(&cp->csk_port_tbl, csk->src_port);
-		csk->src_port = 0;
-	}
-}
-
-static void cnic_close_conn(struct cnic_sock *csk)
-{
-	if (test_bit(SK_F_PG_OFFLD_COMPLETE, &csk->flags)) {
-		cnic_cm_upload_pg(csk);
-		clear_bit(SK_F_PG_OFFLD_COMPLETE, &csk->flags);
-	}
-	cnic_cm_cleanup(csk);
-}
-
-static int cnic_cm_destroy(struct cnic_sock *csk)
-{
-	if (!cnic_in_use(csk))
-		return -EINVAL;
-
-	csk_hold(csk);
-	clear_bit(SK_F_INUSE, &csk->flags);
-	smp_mb__after_clear_bit();
-	while (atomic_read(&csk->ref_count) != 1)
-		msleep(1);
-	cnic_cm_cleanup(csk);
-
-	csk->flags = 0;
-	csk_put(csk);
-	return 0;
-}
-
-static inline u16 cnic_get_vlan(struct net_device *dev,
-				struct net_device **vlan_dev)
-{
-	if (dev->priv_flags & IFF_802_1Q_VLAN) {
-		*vlan_dev = vlan_dev_real_dev(dev);
-		return vlan_dev_vlan_id(dev);
-	}
-	*vlan_dev = dev;
-	return 0;
-}
-
-static int cnic_get_v4_route(struct sockaddr_in *dst_addr,
-			     struct dst_entry **dst)
-{
-#if defined(CONFIG_INET)
-	struct flowi fl;
-	int err;
-	struct rtable *rt;
-
-	memset(&fl, 0, sizeof(fl));
-	fl.nl_u.ip4_u.daddr = dst_addr->sin_addr.s_addr;
-
-	err = ip_route_output_key(&init_net, &rt, &fl);
-	if (!err)
-		*dst = &rt->u.dst;
-	return err;
-#else
-	return -ENETUNREACH;
-#endif
-}
-
-static int cnic_get_v6_route(struct sockaddr_in6 *dst_addr,
-			     struct dst_entry **dst)
-{
-#if defined(CONFIG_IPV6) || (defined(CONFIG_IPV6_MODULE) && defined(MODULE))
-	struct flowi fl;
-
-	memset(&fl, 0, sizeof(fl));
-	ipv6_addr_copy(&fl.fl6_dst, &dst_addr->sin6_addr);
-	if (ipv6_addr_type(&fl.fl6_dst) & IPV6_ADDR_LINKLOCAL)
-		fl.oif = dst_addr->sin6_scope_id;
-
-	*dst = ip6_route_output(&init_net, NULL, &fl);
-	if (*dst)
-		return 0;
-#endif
-
-	return -ENETUNREACH;
-}
-
-static struct cnic_dev *cnic_cm_select_dev(struct sockaddr_in *dst_addr,
-					   int ulp_type)
-{
-	struct cnic_dev *dev = NULL;
-	struct dst_entry *dst;
-	struct net_device *netdev = NULL;
-	int err = -ENETUNREACH;
-
-	if (dst_addr->sin_family == AF_INET)
-		err = cnic_get_v4_route(dst_addr, &dst);
-	else if (dst_addr->sin_family == AF_INET6) {
-		struct sockaddr_in6 *dst_addr6 =
-			(struct sockaddr_in6 *) dst_addr;
-
-		err = cnic_get_v6_route(dst_addr6, &dst);
-	} else
-		return NULL;
-
-	if (err)
-		return NULL;
-
-	if (!dst->dev)
-		goto done;
-
-	cnic_get_vlan(dst->dev, &netdev);
-
-	dev = cnic_from_netdev(netdev);
-
-done:
-	dst_release(dst);
-	if (dev)
-		cnic_put(dev);
-	return dev;
-}
-
-static int cnic_resolve_addr(struct cnic_sock *csk, struct cnic_sockaddr *saddr)
-{
-	struct cnic_dev *dev = csk->dev;
-	struct cnic_local *cp = dev->cnic_priv;
-
-	return cnic_send_nlmsg(cp, ISCSI_KEVENT_PATH_REQ, csk);
-}
-
-static int cnic_get_route(struct cnic_sock *csk, struct cnic_sockaddr *saddr)
-{
-	struct cnic_dev *dev = csk->dev;
-	struct cnic_local *cp = dev->cnic_priv;
-	int is_v6, err, rc = -ENETUNREACH;
-	struct dst_entry *dst;
-	struct net_device *realdev;
-	u32 local_port;
-
-	if (saddr->local.v6.sin6_family == AF_INET6 &&
-	    saddr->remote.v6.sin6_family == AF_INET6)
-		is_v6 = 1;
-	else if (saddr->local.v4.sin_family == AF_INET &&
-		 saddr->remote.v4.sin_family == AF_INET)
-		is_v6 = 0;
-	else
-		return -EINVAL;
-
-	clear_bit(SK_F_IPV6, &csk->flags);
-
-	if (is_v6) {
-#if defined(CONFIG_IPV6) || (defined(CONFIG_IPV6_MODULE) && defined(MODULE))
-		set_bit(SK_F_IPV6, &csk->flags);
-		err = cnic_get_v6_route(&saddr->remote.v6, &dst);
-		if (err)
-			return err;
-
-		if (!dst || dst->error || !dst->dev)
-			goto err_out;
-
-		memcpy(&csk->dst_ip[0], &saddr->remote.v6.sin6_addr,
-		       sizeof(struct in6_addr));
-		csk->dst_port = saddr->remote.v6.sin6_port;
-		local_port = saddr->local.v6.sin6_port;
-#else
-		return rc;
-#endif
-
-	} else {
-		err = cnic_get_v4_route(&saddr->remote.v4, &dst);
-		if (err)
-			return err;
-
-		if (!dst || dst->error || !dst->dev)
-			goto err_out;
-
-		csk->dst_ip[0] = saddr->remote.v4.sin_addr.s_addr;
-		csk->dst_port = saddr->remote.v4.sin_port;
-		local_port = saddr->local.v4.sin_port;
-	}
-
-	csk->vlan_id = cnic_get_vlan(dst->dev, &realdev);
-	if (realdev != dev->netdev)
-		goto err_out;
-
-	if (local_port >= CNIC_LOCAL_PORT_MIN &&
-	    local_port < CNIC_LOCAL_PORT_MAX) {
-		if (cnic_alloc_id(&cp->csk_port_tbl, local_port))
-			local_port = 0;
-	} else
-		local_port = 0;
-
-	if (!local_port) {
-		local_port = cnic_alloc_new_id(&cp->csk_port_tbl);
-		if (local_port == -1) {
-			rc = -ENOMEM;
-			goto err_out;
-		}
-	}
-	csk->src_port = local_port;
-
-	csk->mtu = dst_mtu(dst);
-	rc = 0;
-
-err_out:
-	dst_release(dst);
-	return rc;
-}
-
-static void cnic_init_csk_state(struct cnic_sock *csk)
-{
-	csk->state = 0;
-	clear_bit(SK_F_OFFLD_SCHED, &csk->flags);
-	clear_bit(SK_F_CLOSING, &csk->flags);
-}
-
-static int cnic_cm_connect(struct cnic_sock *csk, struct cnic_sockaddr *saddr)
-{
-	int err = 0;
-
-	if (!cnic_in_use(csk))
-		return -EINVAL;
-
-	if (test_and_set_bit(SK_F_CONNECT_START, &csk->flags))
-		return -EINVAL;
-
-	cnic_init_csk_state(csk);
-
-	err = cnic_get_route(csk, saddr);
-	if (err)
-		goto err_out;
-
-	err = cnic_resolve_addr(csk, saddr);
-	if (!err)
-		return 0;
-
-err_out:
-	clear_bit(SK_F_CONNECT_START, &csk->flags);
-	return err;
-}
-
-static int cnic_cm_abort(struct cnic_sock *csk)
-{
-	struct cnic_local *cp = csk->dev->cnic_priv;
-	u32 opcode;
-
-	if (!cnic_in_use(csk))
-		return -EINVAL;
-
-	if (cnic_abort_prep(csk))
-		return cnic_cm_abort_req(csk);
-
-	/* Getting here means that we haven't started connect, or
-	 * connect was not successful.
-	 */
-
-	csk->state = L4_KCQE_OPCODE_VALUE_RESET_COMP;
-	if (test_bit(SK_F_PG_OFFLD_COMPLETE, &csk->flags))
-		opcode = csk->state;
-	else
-		opcode = L5CM_RAMROD_CMD_ID_TERMINATE_OFFLOAD;
-	cp->close_conn(csk, opcode);
-
-	return 0;
-}
-
-static int cnic_cm_close(struct cnic_sock *csk)
-{
-	if (!cnic_in_use(csk))
-		return -EINVAL;
-
-	if (cnic_close_prep(csk)) {
-		csk->state = L4_KCQE_OPCODE_VALUE_CLOSE_COMP;
-		return cnic_cm_close_req(csk);
-	}
-	return 0;
-}
-
-static void cnic_cm_upcall(struct cnic_local *cp, struct cnic_sock *csk,
-			   u8 opcode)
-{
-	struct cnic_ulp_ops *ulp_ops;
-	int ulp_type = csk->ulp_type;
-
-	rcu_read_lock();
-	ulp_ops = rcu_dereference(cp->ulp_ops[ulp_type]);
-	if (ulp_ops) {
-		if (opcode == L4_KCQE_OPCODE_VALUE_CONNECT_COMPLETE)
-			ulp_ops->cm_connect_complete(csk);
-		else if (opcode == L4_KCQE_OPCODE_VALUE_CLOSE_COMP)
-			ulp_ops->cm_close_complete(csk);
-		else if (opcode == L4_KCQE_OPCODE_VALUE_RESET_RECEIVED)
-			ulp_ops->cm_remote_abort(csk);
-		else if (opcode == L4_KCQE_OPCODE_VALUE_RESET_COMP)
-			ulp_ops->cm_abort_complete(csk);
-		else if (opcode == L4_KCQE_OPCODE_VALUE_CLOSE_RECEIVED)
-			ulp_ops->cm_remote_close(csk);
-	}
-	rcu_read_unlock();
-}
-
-static int cnic_cm_set_pg(struct cnic_sock *csk)
-{
-	if (cnic_offld_prep(csk)) {
-		if (test_bit(SK_F_PG_OFFLD_COMPLETE, &csk->flags))
-			cnic_cm_update_pg(csk);
-		else
-			cnic_cm_offload_pg(csk);
-	}
-	return 0;
-}
-
-static void cnic_cm_process_offld_pg(struct cnic_dev *dev, struct l4_kcq *kcqe)
-{
-	struct cnic_local *cp = dev->cnic_priv;
-	u32 l5_cid = kcqe->pg_host_opaque;
-	u8 opcode = kcqe->op_code;
-	struct cnic_sock *csk = &cp->csk_tbl[l5_cid];
-
-	csk_hold(csk);
-	if (!cnic_in_use(csk))
-		goto done;
-
-	if (opcode == L4_KCQE_OPCODE_VALUE_UPDATE_PG) {
-		clear_bit(SK_F_OFFLD_SCHED, &csk->flags);
-		goto done;
-	}
-	csk->pg_cid = kcqe->pg_cid;
-	set_bit(SK_F_PG_OFFLD_COMPLETE, &csk->flags);
-	cnic_cm_conn_req(csk);
-
-done:
-	csk_put(csk);
-}
-
-static void cnic_cm_process_kcqe(struct cnic_dev *dev, struct kcqe *kcqe)
-{
-	struct cnic_local *cp = dev->cnic_priv;
-	struct l4_kcq *l4kcqe = (struct l4_kcq *) kcqe;
-	u8 opcode = l4kcqe->op_code;
-	u32 l5_cid;
-	struct cnic_sock *csk;
-
-	if (opcode == L4_KCQE_OPCODE_VALUE_OFFLOAD_PG ||
-	    opcode == L4_KCQE_OPCODE_VALUE_UPDATE_PG) {
-		cnic_cm_process_offld_pg(dev, l4kcqe);
-		return;
-	}
-
-	l5_cid = l4kcqe->conn_id;
-	if (opcode & 0x80)
-		l5_cid = l4kcqe->cid;
-	if (l5_cid >= MAX_CM_SK_TBL_SZ)
-		return;
-
-	csk = &cp->csk_tbl[l5_cid];
-	csk_hold(csk);
-
-	if (!cnic_in_use(csk)) {
-		csk_put(csk);
-		return;
-	}
-
-	switch (opcode) {
-	case L4_KCQE_OPCODE_VALUE_CONNECT_COMPLETE:
-		if (l4kcqe->status == 0)
-			set_bit(SK_F_OFFLD_COMPLETE, &csk->flags);
-
-		smp_mb__before_clear_bit();
-		clear_bit(SK_F_OFFLD_SCHED, &csk->flags);
-		cnic_cm_upcall(cp, csk, opcode);
-		break;
-
-	case L4_KCQE_OPCODE_VALUE_RESET_RECEIVED:
-		if (test_and_clear_bit(SK_F_OFFLD_COMPLETE, &csk->flags))
-			csk->state = opcode;
-		/* fall through */
-	case L4_KCQE_OPCODE_VALUE_CLOSE_COMP:
-	case L4_KCQE_OPCODE_VALUE_RESET_COMP:
-	case L5CM_RAMROD_CMD_ID_SEARCHER_DELETE:
-	case L5CM_RAMROD_CMD_ID_TERMINATE_OFFLOAD:
-		cp->close_conn(csk, opcode);
-		break;
-
-	case L4_KCQE_OPCODE_VALUE_CLOSE_RECEIVED:
-		cnic_cm_upcall(cp, csk, opcode);
-		break;
-	}
-	csk_put(csk);
-}
-
-static void cnic_cm_indicate_kcqe(void *data, struct kcqe *kcqe[], u32 num)
-{
-	struct cnic_dev *dev = data;
-	int i;
-
-	for (i = 0; i < num; i++)
-		cnic_cm_process_kcqe(dev, kcqe[i]);
-}
-
-static struct cnic_ulp_ops cm_ulp_ops = {
-	.indicate_kcqes		= cnic_cm_indicate_kcqe,
-};
-
-static void cnic_cm_free_mem(struct cnic_dev *dev)
-{
-	struct cnic_local *cp = dev->cnic_priv;
-
-	kfree(cp->csk_tbl);
-	cp->csk_tbl = NULL;
-	cnic_free_id_tbl(&cp->csk_port_tbl);
-}
-
-static int cnic_cm_alloc_mem(struct cnic_dev *dev)
-{
-	struct cnic_local *cp = dev->cnic_priv;
-
-	cp->csk_tbl = kzalloc(sizeof(struct cnic_sock) * MAX_CM_SK_TBL_SZ,
-			      GFP_KERNEL);
-	if (!cp->csk_tbl)
-		return -ENOMEM;
-
-	if (cnic_init_id_tbl(&cp->csk_port_tbl, CNIC_LOCAL_PORT_RANGE,
-			     CNIC_LOCAL_PORT_MIN)) {
-		cnic_cm_free_mem(dev);
-		return -ENOMEM;
-	}
-	return 0;
-}
-
-static int cnic_ready_to_close(struct cnic_sock *csk, u32 opcode)
-{
-	if ((opcode == csk->state) ||
-	    (opcode == L4_KCQE_OPCODE_VALUE_RESET_RECEIVED &&
-	     csk->state == L4_KCQE_OPCODE_VALUE_CLOSE_COMP)) {
-		if (!test_and_set_bit(SK_F_CLOSING, &csk->flags))
-			return 1;
-	}
-	return 0;
-}
-
-static void cnic_close_bnx2_conn(struct cnic_sock *csk, u32 opcode)
-{
-	struct cnic_dev *dev = csk->dev;
-	struct cnic_local *cp = dev->cnic_priv;
-
-	clear_bit(SK_F_CONNECT_START, &csk->flags);
-	if (cnic_ready_to_close(csk, opcode)) {
-		cnic_close_conn(csk);
-		cnic_cm_upcall(cp, csk, opcode);
-	}
-}
-
-static void cnic_cm_stop_bnx2_hw(struct cnic_dev *dev)
-{
-}
-
-static int cnic_cm_init_bnx2_hw(struct cnic_dev *dev)
-{
-	u32 seed;
-
-	get_random_bytes(&seed, 4);
-	cnic_ctx_wr(dev, 45, 0, seed);
-	return 0;
-}
-
-static void cnic_close_bnx2x_conn(struct cnic_sock *csk, u32 opcode)
-{
-	struct cnic_dev *dev = csk->dev;
-	struct cnic_local *cp = dev->cnic_priv;
-	struct cnic_context *ctx = &cp->ctx_tbl[csk->l5_cid];
-	union l5cm_specific_data l5_data;
-	u32 cmd = 0;
-	int close_complete = 0;
-
-	switch (opcode) {
-	case L4_KCQE_OPCODE_VALUE_RESET_RECEIVED:
-	case L4_KCQE_OPCODE_VALUE_CLOSE_COMP:
-	case L4_KCQE_OPCODE_VALUE_RESET_COMP:
-		if (cnic_ready_to_close(csk, opcode))
-			cmd = L5CM_RAMROD_CMD_ID_SEARCHER_DELETE;
-		break;
-	case L5CM_RAMROD_CMD_ID_SEARCHER_DELETE:
-		cmd = L5CM_RAMROD_CMD_ID_TERMINATE_OFFLOAD;
-		break;
-	case L5CM_RAMROD_CMD_ID_TERMINATE_OFFLOAD:
-		close_complete = 1;
-		break;
-	}
-	if (cmd) {
-		memset(&l5_data, 0, sizeof(l5_data));
-
-		cnic_submit_kwqe_16(dev, cmd, csk->cid, ISCSI_CONNECTION_TYPE,
-				    &l5_data);
-	} else if (close_complete) {
-		ctx->timestamp = jiffies;
-		cnic_close_conn(csk);
-		cnic_cm_upcall(cp, csk, csk->state);
-	}
-}
-
-static void cnic_cm_stop_bnx2x_hw(struct cnic_dev *dev)
-{
-}
-
-static int cnic_cm_init_bnx2x_hw(struct cnic_dev *dev)
-{
-	struct cnic_local *cp = dev->cnic_priv;
-	int func = CNIC_FUNC(cp);
-
-	cnic_init_bnx2x_mac(dev);
-	cnic_bnx2x_set_tcp_timestamp(dev, 1);
-
-	CNIC_WR16(dev, BAR_XSTRORM_INTMEM +
-		  XSTORM_ISCSI_LOCAL_VLAN_OFFSET(func), 0);
-
-	CNIC_WR(dev, BAR_XSTRORM_INTMEM +
-		XSTORM_TCP_GLOBAL_DEL_ACK_COUNTER_ENABLED_OFFSET(func), 1);
-	CNIC_WR(dev, BAR_XSTRORM_INTMEM +
-		XSTORM_TCP_GLOBAL_DEL_ACK_COUNTER_MAX_COUNT_OFFSET(func),
-		DEF_MAX_DA_COUNT);
-
-	CNIC_WR8(dev, BAR_XSTRORM_INTMEM +
-		 XSTORM_ISCSI_TCP_VARS_TTL_OFFSET(func), DEF_TTL);
-	CNIC_WR8(dev, BAR_XSTRORM_INTMEM +
-		 XSTORM_ISCSI_TCP_VARS_TOS_OFFSET(func), DEF_TOS);
-	CNIC_WR8(dev, BAR_XSTRORM_INTMEM +
-		 XSTORM_ISCSI_TCP_VARS_ADV_WND_SCL_OFFSET(func), 2);
-	CNIC_WR(dev, BAR_XSTRORM_INTMEM +
-		XSTORM_TCP_TX_SWS_TIMER_VAL_OFFSET(func), DEF_SWS_TIMER);
-
-	CNIC_WR(dev, BAR_TSTRORM_INTMEM + TSTORM_TCP_MAX_CWND_OFFSET(func),
-		DEF_MAX_CWND);
-	return 0;
-}
-
-static int cnic_cm_open(struct cnic_dev *dev)
-{
-	struct cnic_local *cp = dev->cnic_priv;
-	int err;
-
-	err = cnic_cm_alloc_mem(dev);
-	if (err)
-		return err;
-
-	err = cp->start_cm(dev);
-
-	if (err)
-		goto err_out;
-
-	dev->cm_create = cnic_cm_create;
-	dev->cm_destroy = cnic_cm_destroy;
-	dev->cm_connect = cnic_cm_connect;
-	dev->cm_abort = cnic_cm_abort;
-	dev->cm_close = cnic_cm_close;
-	dev->cm_select_dev = cnic_cm_select_dev;
-
-	cp->ulp_handle[CNIC_ULP_L4] = dev;
-	rcu_assign_pointer(cp->ulp_ops[CNIC_ULP_L4], &cm_ulp_ops);
-	return 0;
-
-err_out:
-	cnic_cm_free_mem(dev);
-	return err;
-}
-
-static int cnic_cm_shutdown(struct cnic_dev *dev)
-{
-	struct cnic_local *cp = dev->cnic_priv;
-	int i;
-
-	cp->stop_cm(dev);
-
-	if (!cp->csk_tbl)
-		return 0;
-
-	for (i = 0; i < MAX_CM_SK_TBL_SZ; i++) {
-		struct cnic_sock *csk = &cp->csk_tbl[i];
-
-		clear_bit(SK_F_INUSE, &csk->flags);
-		cnic_cm_cleanup(csk);
-	}
-	cnic_cm_free_mem(dev);
-
-	return 0;
-}
-
-static void cnic_init_context(struct cnic_dev *dev, u32 cid)
-{
-	struct cnic_local *cp = dev->cnic_priv;
-	u32 cid_addr;
-	int i;
-
-	if (CHIP_NUM(cp) == CHIP_NUM_5709)
-		return;
-
-	cid_addr = GET_CID_ADDR(cid);
-
-	for (i = 0; i < CTX_SIZE; i += 4)
-		cnic_ctx_wr(dev, cid_addr, i, 0);
-}
-
-static int cnic_setup_5709_context(struct cnic_dev *dev, int valid)
-{
-	struct cnic_local *cp = dev->cnic_priv;
-	int ret = 0, i;
-	u32 valid_bit = valid ? BNX2_CTX_HOST_PAGE_TBL_DATA0_VALID : 0;
-
-	if (CHIP_NUM(cp) != CHIP_NUM_5709)
-		return 0;
-
-	for (i = 0; i < cp->ctx_blks; i++) {
-		int j;
-		u32 idx = cp->ctx_arr[i].cid / cp->cids_per_blk;
-		u32 val;
-
-		memset(cp->ctx_arr[i].ctx, 0, BCM_PAGE_SIZE);
-
-		CNIC_WR(dev, BNX2_CTX_HOST_PAGE_TBL_DATA0,
-			(cp->ctx_arr[i].mapping & 0xffffffff) | valid_bit);
-		CNIC_WR(dev, BNX2_CTX_HOST_PAGE_TBL_DATA1,
-			(u64) cp->ctx_arr[i].mapping >> 32);
-		CNIC_WR(dev, BNX2_CTX_HOST_PAGE_TBL_CTRL, idx |
-			BNX2_CTX_HOST_PAGE_TBL_CTRL_WRITE_REQ);
-		for (j = 0; j < 10; j++) {
-
-			val = CNIC_RD(dev, BNX2_CTX_HOST_PAGE_TBL_CTRL);
-			if (!(val & BNX2_CTX_HOST_PAGE_TBL_CTRL_WRITE_REQ))
-				break;
-			udelay(5);
-		}
-		if (val & BNX2_CTX_HOST_PAGE_TBL_CTRL_WRITE_REQ) {
-			ret = -EBUSY;
-			break;
-		}
-	}
-	return ret;
-}
-
-static void cnic_free_irq(struct cnic_dev *dev)
-{
-	struct cnic_local *cp = dev->cnic_priv;
-	struct cnic_eth_dev *ethdev = cp->ethdev;
-
-	if (ethdev->drv_state & CNIC_DRV_STATE_USING_MSIX) {
-		cp->disable_int_sync(dev);
-		tasklet_disable(&cp->cnic_irq_task);
-		free_irq(ethdev->irq_arr[0].vector, dev);
-	}
-}
-
-static int cnic_init_bnx2_irq(struct cnic_dev *dev)
-{
-	struct cnic_local *cp = dev->cnic_priv;
-	struct cnic_eth_dev *ethdev = cp->ethdev;
-
-	if (ethdev->drv_state & CNIC_DRV_STATE_USING_MSIX) {
-		int err, i = 0;
-		int sblk_num = cp->status_blk_num;
-		u32 base = ((sblk_num - 1) * BNX2_HC_SB_CONFIG_SIZE) +
-			   BNX2_HC_SB_CONFIG_1;
-
-		CNIC_WR(dev, base, BNX2_HC_SB_CONFIG_1_ONE_SHOT);
-
-		CNIC_WR(dev, base + BNX2_HC_COMP_PROD_TRIP_OFF, (2 << 16) | 8);
-		CNIC_WR(dev, base + BNX2_HC_COM_TICKS_OFF, (64 << 16) | 220);
-		CNIC_WR(dev, base + BNX2_HC_CMD_TICKS_OFF, (64 << 16) | 220);
-
-		cp->last_status_idx = cp->status_blk.bnx2->status_idx;
-		tasklet_init(&cp->cnic_irq_task, cnic_service_bnx2_msix,
-			     (unsigned long) dev);
-		err = request_irq(ethdev->irq_arr[0].vector, cnic_irq, 0,
-				  "cnic", dev);
-		if (err) {
-			tasklet_disable(&cp->cnic_irq_task);
-			return err;
-		}
-		while (cp->status_blk.bnx2->status_completion_producer_index &&
-		       i < 10) {
-			CNIC_WR(dev, BNX2_HC_COALESCE_NOW,
-				1 << (11 + sblk_num));
-			udelay(10);
-			i++;
-			barrier();
-		}
-		if (cp->status_blk.bnx2->status_completion_producer_index) {
-			cnic_free_irq(dev);
-			goto failed;
-		}
-
-	} else {
-		struct status_block *sblk = cp->status_blk.gen;
-		u32 hc_cmd = CNIC_RD(dev, BNX2_HC_COMMAND);
-		int i = 0;
-
-		while (sblk->status_completion_producer_index && i < 10) {
-			CNIC_WR(dev, BNX2_HC_COMMAND,
-				hc_cmd | BNX2_HC_COMMAND_COAL_NOW_WO_INT);
-			udelay(10);
-			i++;
-			barrier();
-		}
-		if (sblk->status_completion_producer_index)
-			goto failed;
-
-	}
-	return 0;
-
-failed:
-	printk(KERN_ERR PFX "%s: " "KCQ index not resetting to 0.\n",
-	       dev->netdev->name);
-	return -EBUSY;
-}
-
-static void cnic_enable_bnx2_int(struct cnic_dev *dev)
-{
-	struct cnic_local *cp = dev->cnic_priv;
-	struct cnic_eth_dev *ethdev = cp->ethdev;
-
-	if (!(ethdev->drv_state & CNIC_DRV_STATE_USING_MSIX))
-		return;
-
-	CNIC_WR(dev, BNX2_PCICFG_INT_ACK_CMD, cp->int_num |
-		BNX2_PCICFG_INT_ACK_CMD_INDEX_VALID | cp->last_status_idx);
-}
-
-static void cnic_disable_bnx2_int_sync(struct cnic_dev *dev)
-{
-	struct cnic_local *cp = dev->cnic_priv;
-	struct cnic_eth_dev *ethdev = cp->ethdev;
-
-	if (!(ethdev->drv_state & CNIC_DRV_STATE_USING_MSIX))
-		return;
-
-	CNIC_WR(dev, BNX2_PCICFG_INT_ACK_CMD, cp->int_num |
-		BNX2_PCICFG_INT_ACK_CMD_MASK_INT);
-	CNIC_RD(dev, BNX2_PCICFG_INT_ACK_CMD);
-	synchronize_irq(ethdev->irq_arr[0].vector);
-}
-
-static void cnic_init_bnx2_tx_ring(struct cnic_dev *dev)
-{
-	struct cnic_local *cp = dev->cnic_priv;
-	struct cnic_eth_dev *ethdev = cp->ethdev;
-	u32 cid_addr, tx_cid, sb_id;
-	u32 val, offset0, offset1, offset2, offset3;
-	int i;
-	struct tx_bd *txbd;
-	dma_addr_t buf_map;
-	struct status_block *s_blk = cp->status_blk.gen;
-
-	sb_id = cp->status_blk_num;
-	tx_cid = 20;
-	cnic_init_context(dev, tx_cid);
-	cnic_init_context(dev, tx_cid + 1);
-	cp->tx_cons_ptr = &s_blk->status_tx_quick_consumer_index2;
-	if (ethdev->drv_state & CNIC_DRV_STATE_USING_MSIX) {
-		struct status_block_msix *sblk = cp->status_blk.bnx2;
-
-		tx_cid = TX_TSS_CID + sb_id - 1;
-		cnic_init_context(dev, tx_cid);
-		CNIC_WR(dev, BNX2_TSCH_TSS_CFG, (sb_id << 24) |
-			(TX_TSS_CID << 7));
-		cp->tx_cons_ptr = &sblk->status_tx_quick_consumer_index;
-	}
-	cp->tx_cons = *cp->tx_cons_ptr;
-
-	cid_addr = GET_CID_ADDR(tx_cid);
-	if (CHIP_NUM(cp) == CHIP_NUM_5709) {
-		u32 cid_addr2 = GET_CID_ADDR(tx_cid + 4) + 0x40;
-
-		for (i = 0; i < PHY_CTX_SIZE; i += 4)
-			cnic_ctx_wr(dev, cid_addr2, i, 0);
-
-		offset0 = BNX2_L2CTX_TYPE_XI;
-		offset1 = BNX2_L2CTX_CMD_TYPE_XI;
-		offset2 = BNX2_L2CTX_TBDR_BHADDR_HI_XI;
-		offset3 = BNX2_L2CTX_TBDR_BHADDR_LO_XI;
-	} else {
-		offset0 = BNX2_L2CTX_TYPE;
-		offset1 = BNX2_L2CTX_CMD_TYPE;
-		offset2 = BNX2_L2CTX_TBDR_BHADDR_HI;
-		offset3 = BNX2_L2CTX_TBDR_BHADDR_LO;
-	}
-	val = BNX2_L2CTX_TYPE_TYPE_L2 | BNX2_L2CTX_TYPE_SIZE_L2;
-	cnic_ctx_wr(dev, cid_addr, offset0, val);
-
-	val = BNX2_L2CTX_CMD_TYPE_TYPE_L2 | (8 << 16);
-	cnic_ctx_wr(dev, cid_addr, offset1, val);
-
-	txbd = (struct tx_bd *) cp->l2_ring;
-
-	buf_map = cp->l2_buf_map;
-	for (i = 0; i < MAX_TX_DESC_CNT; i++, txbd++) {
-		txbd->tx_bd_haddr_hi = (u64) buf_map >> 32;
-		txbd->tx_bd_haddr_lo = (u64) buf_map & 0xffffffff;
-	}
-	val = (u64) cp->l2_ring_map >> 32;
-	cnic_ctx_wr(dev, cid_addr, offset2, val);
-	txbd->tx_bd_haddr_hi = val;
-
-	val = (u64) cp->l2_ring_map & 0xffffffff;
-	cnic_ctx_wr(dev, cid_addr, offset3, val);
-	txbd->tx_bd_haddr_lo = val;
-}
-
-static void cnic_init_bnx2_rx_ring(struct cnic_dev *dev)
-{
-	struct cnic_local *cp = dev->cnic_priv;
-	struct cnic_eth_dev *ethdev = cp->ethdev;
-	u32 cid_addr, sb_id, val, coal_reg, coal_val;
-	int i;
-	struct rx_bd *rxbd;
-	struct status_block *s_blk = cp->status_blk.gen;
-
-	sb_id = cp->status_blk_num;
-	cnic_init_context(dev, 2);
-	cp->rx_cons_ptr = &s_blk->status_rx_quick_consumer_index2;
-	coal_reg = BNX2_HC_COMMAND;
-	coal_val = CNIC_RD(dev, coal_reg);
-	if (ethdev->drv_state & CNIC_DRV_STATE_USING_MSIX) {
-		struct status_block_msix *sblk = cp->status_blk.bnx2;
-
-		cp->rx_cons_ptr = &sblk->status_rx_quick_consumer_index;
-		coal_reg = BNX2_HC_COALESCE_NOW;
-		coal_val = 1 << (11 + sb_id);
-	}
-	i = 0;
-	while (!(*cp->rx_cons_ptr != 0) && i < 10) {
-		CNIC_WR(dev, coal_reg, coal_val);
-		udelay(10);
-		i++;
-		barrier();
-	}
-	cp->rx_cons = *cp->rx_cons_ptr;
-
-	cid_addr = GET_CID_ADDR(2);
-	val = BNX2_L2CTX_CTX_TYPE_CTX_BD_CHN_TYPE_VALUE |
-	      BNX2_L2CTX_CTX_TYPE_SIZE_L2 | (0x02 << 8);
-	cnic_ctx_wr(dev, cid_addr, BNX2_L2CTX_CTX_TYPE, val);
-
-	if (sb_id == 0)
-		val = 2 << BNX2_L2CTX_L2_STATUSB_NUM_SHIFT;
-	else
-		val = BNX2_L2CTX_L2_STATUSB_NUM(sb_id);
-	cnic_ctx_wr(dev, cid_addr, BNX2_L2CTX_HOST_BDIDX, val);
-
-	rxbd = (struct rx_bd *) (cp->l2_ring + BCM_PAGE_SIZE);
-	for (i = 0; i < MAX_RX_DESC_CNT; i++, rxbd++) {
-		dma_addr_t buf_map;
-		int n = (i % cp->l2_rx_ring_size) + 1;
-
-		buf_map = cp->l2_buf_map + (n * cp->l2_single_buf_size);
-		rxbd->rx_bd_len = cp->l2_single_buf_size;
-		rxbd->rx_bd_flags = RX_BD_FLAGS_START | RX_BD_FLAGS_END;
-		rxbd->rx_bd_haddr_hi = (u64) buf_map >> 32;
-		rxbd->rx_bd_haddr_lo = (u64) buf_map & 0xffffffff;
-	}
-	val = (u64) (cp->l2_ring_map + BCM_PAGE_SIZE) >> 32;
-	cnic_ctx_wr(dev, cid_addr, BNX2_L2CTX_NX_BDHADDR_HI, val);
-	rxbd->rx_bd_haddr_hi = val;
-
-	val = (u64) (cp->l2_ring_map + BCM_PAGE_SIZE) & 0xffffffff;
-	cnic_ctx_wr(dev, cid_addr, BNX2_L2CTX_NX_BDHADDR_LO, val);
-	rxbd->rx_bd_haddr_lo = val;
-
-	val = cnic_reg_rd_ind(dev, BNX2_RXP_SCRATCH_RXP_FLOOD);
-	cnic_reg_wr_ind(dev, BNX2_RXP_SCRATCH_RXP_FLOOD, val | (1 << 2));
-}
-
-static void cnic_shutdown_bnx2_rx_ring(struct cnic_dev *dev)
-{
-	struct kwqe *wqes[1], l2kwqe;
-
-	memset(&l2kwqe, 0, sizeof(l2kwqe));
-	wqes[0] = &l2kwqe;
-	l2kwqe.kwqe_op_flag = (L2_LAYER_CODE << KWQE_FLAGS_LAYER_SHIFT) |
-			      (L2_KWQE_OPCODE_VALUE_FLUSH <<
-			       KWQE_OPCODE_SHIFT) | 2;
-	dev->submit_kwqes(dev, wqes, 1);
-}
-
-static void cnic_set_bnx2_mac(struct cnic_dev *dev)
-{
-	struct cnic_local *cp = dev->cnic_priv;
-	u32 val;
-
-	val = cp->func << 2;
-
-	cp->shmem_base = cnic_reg_rd_ind(dev, BNX2_SHM_HDR_ADDR_0 + val);
-
-	val = cnic_reg_rd_ind(dev, cp->shmem_base +
-			      BNX2_PORT_HW_CFG_ISCSI_MAC_UPPER);
-	dev->mac_addr[0] = (u8) (val >> 8);
-	dev->mac_addr[1] = (u8) val;
-
-	CNIC_WR(dev, BNX2_EMAC_MAC_MATCH4, val);
-
-	val = cnic_reg_rd_ind(dev, cp->shmem_base +
-			      BNX2_PORT_HW_CFG_ISCSI_MAC_LOWER);
-	dev->mac_addr[2] = (u8) (val >> 24);
-	dev->mac_addr[3] = (u8) (val >> 16);
-	dev->mac_addr[4] = (u8) (val >> 8);
-	dev->mac_addr[5] = (u8) val;
-
-	CNIC_WR(dev, BNX2_EMAC_MAC_MATCH5, val);
-
-	val = 4 | BNX2_RPM_SORT_USER2_BC_EN;
-	if (CHIP_NUM(cp) != CHIP_NUM_5709)
-		val |= BNX2_RPM_SORT_USER2_PROM_VLAN;
-
-	CNIC_WR(dev, BNX2_RPM_SORT_USER2, 0x0);
-	CNIC_WR(dev, BNX2_RPM_SORT_USER2, val);
-	CNIC_WR(dev, BNX2_RPM_SORT_USER2, val | BNX2_RPM_SORT_USER2_ENA);
-}
-
-static int cnic_start_bnx2_hw(struct cnic_dev *dev)
-{
-	struct cnic_local *cp = dev->cnic_priv;
-	struct cnic_eth_dev *ethdev = cp->ethdev;
-	struct status_block *sblk = cp->status_blk.gen;
-	u32 val;
-	int err;
-
-	cnic_set_bnx2_mac(dev);
-
-	val = CNIC_RD(dev, BNX2_MQ_CONFIG);
-	val &= ~BNX2_MQ_CONFIG_KNL_BYP_BLK_SIZE;
-	if (BCM_PAGE_BITS > 12)
-		val |= (12 - 8)  << 4;
-	else
-		val |= (BCM_PAGE_BITS - 8)  << 4;
-
-	CNIC_WR(dev, BNX2_MQ_CONFIG, val);
-
-	CNIC_WR(dev, BNX2_HC_COMP_PROD_TRIP, (2 << 16) | 8);
-	CNIC_WR(dev, BNX2_HC_COM_TICKS, (64 << 16) | 220);
-	CNIC_WR(dev, BNX2_HC_CMD_TICKS, (64 << 16) | 220);
-
-	err = cnic_setup_5709_context(dev, 1);
-	if (err)
-		return err;
-
-	cnic_init_context(dev, KWQ_CID);
-	cnic_init_context(dev, KCQ_CID);
-
-	cp->kwq_cid_addr = GET_CID_ADDR(KWQ_CID);
-	cp->kwq_io_addr = MB_GET_CID_ADDR(KWQ_CID) + L5_KRNLQ_HOST_QIDX;
-
-	cp->max_kwq_idx = MAX_KWQ_IDX;
-	cp->kwq_prod_idx = 0;
-	cp->kwq_con_idx = 0;
-	cp->cnic_local_flags |= CNIC_LCL_FL_KWQ_INIT;
-
-	if (CHIP_NUM(cp) == CHIP_NUM_5706 || CHIP_NUM(cp) == CHIP_NUM_5708)
-		cp->kwq_con_idx_ptr = &sblk->status_rx_quick_consumer_index15;
-	else
-		cp->kwq_con_idx_ptr = &sblk->status_cmd_consumer_index;
-
-	/* Initialize the kernel work queue context. */
-	val = KRNLQ_TYPE_TYPE_KRNLQ | KRNLQ_SIZE_TYPE_SIZE |
-	      (BCM_PAGE_BITS - 8) | KRNLQ_FLAGS_QE_SELF_SEQ;
-	cnic_ctx_wr(dev, cp->kwq_cid_addr, L5_KRNLQ_TYPE, val);
-
-	val = (BCM_PAGE_SIZE / sizeof(struct kwqe) - 1) << 16;
-	cnic_ctx_wr(dev, cp->kwq_cid_addr, L5_KRNLQ_QE_SELF_SEQ_MAX, val);
-
-	val = ((BCM_PAGE_SIZE / sizeof(struct kwqe)) << 16) | KWQ_PAGE_CNT;
-	cnic_ctx_wr(dev, cp->kwq_cid_addr, L5_KRNLQ_PGTBL_NPAGES, val);
-
-	val = (u32) ((u64) cp->kwq_info.pgtbl_map >> 32);
-	cnic_ctx_wr(dev, cp->kwq_cid_addr, L5_KRNLQ_PGTBL_HADDR_HI, val);
-
-	val = (u32) cp->kwq_info.pgtbl_map;
-	cnic_ctx_wr(dev, cp->kwq_cid_addr, L5_KRNLQ_PGTBL_HADDR_LO, val);
-
-	cp->kcq_cid_addr = GET_CID_ADDR(KCQ_CID);
-	cp->kcq_io_addr = MB_GET_CID_ADDR(KCQ_CID) + L5_KRNLQ_HOST_QIDX;
-
-	cp->kcq_prod_idx = 0;
-
-	/* Initialize the kernel complete queue context. */
-	val = KRNLQ_TYPE_TYPE_KRNLQ | KRNLQ_SIZE_TYPE_SIZE |
-	      (BCM_PAGE_BITS - 8) | KRNLQ_FLAGS_QE_SELF_SEQ;
-	cnic_ctx_wr(dev, cp->kcq_cid_addr, L5_KRNLQ_TYPE, val);
-
-	val = (BCM_PAGE_SIZE / sizeof(struct kcqe) - 1) << 16;
-	cnic_ctx_wr(dev, cp->kcq_cid_addr, L5_KRNLQ_QE_SELF_SEQ_MAX, val);
-
-	val = ((BCM_PAGE_SIZE / sizeof(struct kcqe)) << 16) | KCQ_PAGE_CNT;
-	cnic_ctx_wr(dev, cp->kcq_cid_addr, L5_KRNLQ_PGTBL_NPAGES, val);
-
-	val = (u32) ((u64) cp->kcq_info.pgtbl_map >> 32);
-	cnic_ctx_wr(dev, cp->kcq_cid_addr, L5_KRNLQ_PGTBL_HADDR_HI, val);
-
-	val = (u32) cp->kcq_info.pgtbl_map;
-	cnic_ctx_wr(dev, cp->kcq_cid_addr, L5_KRNLQ_PGTBL_HADDR_LO, val);
-
-	cp->int_num = 0;
-	if (ethdev->drv_state & CNIC_DRV_STATE_USING_MSIX) {
-		u32 sb_id = cp->status_blk_num;
-		u32 sb = BNX2_L2CTX_L5_STATUSB_NUM(sb_id);
-
-		cp->int_num = sb_id << BNX2_PCICFG_INT_ACK_CMD_INT_NUM_SHIFT;
-		cnic_ctx_wr(dev, cp->kwq_cid_addr, L5_KRNLQ_HOST_QIDX, sb);
-		cnic_ctx_wr(dev, cp->kcq_cid_addr, L5_KRNLQ_HOST_QIDX, sb);
-	}
-
-	/* Enable Commnad Scheduler notification when we write to the
-	 * host producer index of the kernel contexts. */
-	CNIC_WR(dev, BNX2_MQ_KNL_CMD_MASK1, 2);
-
-	/* Enable Command Scheduler notification when we write to either
-	 * the Send Queue or Receive Queue producer indexes of the kernel
-	 * bypass contexts. */
-	CNIC_WR(dev, BNX2_MQ_KNL_BYP_CMD_MASK1, 7);
-	CNIC_WR(dev, BNX2_MQ_KNL_BYP_WRITE_MASK1, 7);
-
-	/* Notify COM when the driver post an application buffer. */
-	CNIC_WR(dev, BNX2_MQ_KNL_RX_V2P_MASK2, 0x2000);
-
-	/* Set the CP and COM doorbells.  These two processors polls the
-	 * doorbell for a non zero value before running.  This must be done
-	 * after setting up the kernel queue contexts. */
-	cnic_reg_wr_ind(dev, BNX2_CP_SCRATCH + 0x20, 1);
-	cnic_reg_wr_ind(dev, BNX2_COM_SCRATCH + 0x20, 1);
-
-	cnic_init_bnx2_tx_ring(dev);
-	cnic_init_bnx2_rx_ring(dev);
-
-	err = cnic_init_bnx2_irq(dev);
-	if (err) {
-		printk(KERN_ERR PFX "%s: cnic_init_irq failed\n",
-		       dev->netdev->name);
-		cnic_reg_wr_ind(dev, BNX2_CP_SCRATCH + 0x20, 0);
-		cnic_reg_wr_ind(dev, BNX2_COM_SCRATCH + 0x20, 0);
-		return err;
-	}
-
-	return 0;
-}
-
-static void cnic_setup_bnx2x_context(struct cnic_dev *dev)
-{
-	struct cnic_local *cp = dev->cnic_priv;
-	struct cnic_eth_dev *ethdev = cp->ethdev;
-	u32 start_offset = ethdev->ctx_tbl_offset;
-	int i;
-
-	for (i = 0; i < cp->ctx_blks; i++) {
-		struct cnic_ctx *ctx = &cp->ctx_arr[i];
-		dma_addr_t map = ctx->mapping;
-
-		if (cp->ctx_align) {
-			unsigned long mask = cp->ctx_align - 1;
-
-			map = (map + mask) & ~mask;
-		}
-
-		cnic_ctx_tbl_wr(dev, start_offset + i, map);
-	}
-}
-
-static int cnic_init_bnx2x_irq(struct cnic_dev *dev)
-{
-	struct cnic_local *cp = dev->cnic_priv;
-	struct cnic_eth_dev *ethdev = cp->ethdev;
-	int err = 0;
-
-	tasklet_init(&cp->cnic_irq_task, cnic_service_bnx2x_bh,
-		     (unsigned long) dev);
-	if (ethdev->drv_state & CNIC_DRV_STATE_USING_MSIX) {
-		err = request_irq(ethdev->irq_arr[0].vector, cnic_irq, 0,
-				  "cnic", dev);
-		if (err)
-			tasklet_disable(&cp->cnic_irq_task);
-	}
-	return err;
-}
-
-static void cnic_enable_bnx2x_int(struct cnic_dev *dev)
-{
-	struct cnic_local *cp = dev->cnic_priv;
-	u8 sb_id = cp->status_blk_num;
-	int port = CNIC_PORT(cp);
-
-	CNIC_WR8(dev, BAR_CSTRORM_INTMEM +
-		 CSTORM_SB_HC_TIMEOUT_C_OFFSET(port, sb_id,
-					       HC_INDEX_C_ISCSI_EQ_CONS),
-		 64 / 12);
-	CNIC_WR16(dev, BAR_CSTRORM_INTMEM +
-		  CSTORM_SB_HC_DISABLE_C_OFFSET(port, sb_id,
-						HC_INDEX_C_ISCSI_EQ_CONS), 0);
-}
-
-static void cnic_disable_bnx2x_int_sync(struct cnic_dev *dev)
-{
-}
-
-static void cnic_init_bnx2x_tx_ring(struct cnic_dev *dev)
-{
-	struct cnic_local *cp = dev->cnic_priv;
-	union eth_tx_bd_types *txbd = (union eth_tx_bd_types *) cp->l2_ring;
-	struct eth_context *context;
-	struct regpair context_addr;
-	dma_addr_t buf_map;
-	int func = CNIC_FUNC(cp);
-	int port = CNIC_PORT(cp);
-	int i;
-	int cli = BNX2X_ISCSI_CL_ID(CNIC_E1HVN(cp));
-	u32 val;
-
-	memset(txbd, 0, BCM_PAGE_SIZE);
-
-	buf_map = cp->l2_buf_map;
-	for (i = 0; i < MAX_TX_DESC_CNT; i += 3, txbd += 3) {
-		struct eth_tx_start_bd *start_bd = &txbd->start_bd;
-		struct eth_tx_bd *reg_bd = &((txbd + 2)->reg_bd);
-
-		start_bd->addr_hi = cpu_to_le32((u64) buf_map >> 32);
-		start_bd->addr_lo = cpu_to_le32(buf_map & 0xffffffff);
-		reg_bd->addr_hi = start_bd->addr_hi;
-		reg_bd->addr_lo = start_bd->addr_lo + 0x10;
-		start_bd->nbytes = cpu_to_le16(0x10);
-		start_bd->nbd = cpu_to_le16(3);
-		start_bd->bd_flags.as_bitfield = ETH_TX_BD_FLAGS_START_BD;
-		start_bd->general_data = (UNICAST_ADDRESS <<
-			ETH_TX_START_BD_ETH_ADDR_TYPE_SHIFT);
-		start_bd->general_data |= (1 << ETH_TX_START_BD_HDR_NBDS_SHIFT);
-
-	}
-	context = cnic_get_bnx2x_ctx(dev, BNX2X_ISCSI_L2_CID, 1, &context_addr);
-
-	val = (u64) cp->l2_ring_map >> 32;
-	txbd->next_bd.addr_hi = cpu_to_le32(val);
-
-	context->xstorm_st_context.tx_bd_page_base_hi = val;
-
-	val = (u64) cp->l2_ring_map & 0xffffffff;
-	txbd->next_bd.addr_lo = cpu_to_le32(val);
-
-	context->xstorm_st_context.tx_bd_page_base_lo = val;
-
-	context->cstorm_st_context.sb_index_number =
-		HC_INDEX_DEF_C_ETH_ISCSI_CQ_CONS;
-	context->cstorm_st_context.status_block_id = BNX2X_DEF_SB_ID;
-
-	context->xstorm_st_context.statistics_data = (cli |
-				XSTORM_ETH_ST_CONTEXT_STATISTICS_ENABLE);
-
-	context->xstorm_ag_context.cdu_reserved =
-		CDU_RSRVD_VALUE_TYPE_A(BNX2X_HW_CID(BNX2X_ISCSI_L2_CID, func),
-					CDU_REGION_NUMBER_XCM_AG,
-					ETH_CONNECTION_TYPE);
-
-	/* reset xstorm per client statistics */
-	val = BAR_XSTRORM_INTMEM +
-	      XSTORM_PER_COUNTER_ID_STATS_OFFSET(port, cli);
-	for (i = 0; i < sizeof(struct xstorm_per_client_stats) / 4; i++)
-		CNIC_WR(dev, val + i * 4, 0);
-
-	cp->tx_cons_ptr =
-		&cp->bnx2x_def_status_blk->c_def_status_block.index_values[
-			HC_INDEX_DEF_C_ETH_ISCSI_CQ_CONS];
-}
-
-static void cnic_init_bnx2x_rx_ring(struct cnic_dev *dev)
-{
-	struct cnic_local *cp = dev->cnic_priv;
-	struct eth_rx_bd *rxbd = (struct eth_rx_bd *) (cp->l2_ring +
-				BCM_PAGE_SIZE);
-	struct eth_rx_cqe_next_page *rxcqe = (struct eth_rx_cqe_next_page *)
-				(cp->l2_ring + (2 * BCM_PAGE_SIZE));
-	struct eth_context *context;
-	struct regpair context_addr;
-	int i;
-	int port = CNIC_PORT(cp);
-	int func = CNIC_FUNC(cp);
-	int cli = BNX2X_ISCSI_CL_ID(CNIC_E1HVN(cp));
-	u32 val;
-	struct tstorm_eth_client_config tstorm_client = {0};
-
-	for (i = 0; i < BNX2X_MAX_RX_DESC_CNT; i++, rxbd++) {
-		dma_addr_t buf_map;
-		int n = (i % cp->l2_rx_ring_size) + 1;
-
-		buf_map = cp->l2_buf_map + (n * cp->l2_single_buf_size);
-		rxbd->addr_hi = cpu_to_le32((u64) buf_map >> 32);
-		rxbd->addr_lo = cpu_to_le32(buf_map & 0xffffffff);
-	}
-	context = cnic_get_bnx2x_ctx(dev, BNX2X_ISCSI_L2_CID, 0, &context_addr);
-
-	val = (u64) (cp->l2_ring_map + BCM_PAGE_SIZE) >> 32;
-	rxbd->addr_hi = cpu_to_le32(val);
-
-	context->ustorm_st_context.common.bd_page_base_hi = val;
-
-	val = (u64) (cp->l2_ring_map + BCM_PAGE_SIZE) & 0xffffffff;
-	rxbd->addr_lo = cpu_to_le32(val);
-
-	context->ustorm_st_context.common.bd_page_base_lo = val;
-
-	context->ustorm_st_context.common.sb_index_numbers =
-						BNX2X_ISCSI_RX_SB_INDEX_NUM;
-	context->ustorm_st_context.common.clientId = cli;
-	context->ustorm_st_context.common.status_block_id = BNX2X_DEF_SB_ID;
-	context->ustorm_st_context.common.flags =
-		USTORM_ETH_ST_CONTEXT_CONFIG_ENABLE_STATISTICS;
-	context->ustorm_st_context.common.statistics_counter_id = cli;
-	context->ustorm_st_context.common.mc_alignment_log_size = 0;
-	context->ustorm_st_context.common.bd_buff_size =
-						cp->l2_single_buf_size;
-
-	context->ustorm_ag_context.cdu_usage =
-		CDU_RSRVD_VALUE_TYPE_A(BNX2X_HW_CID(BNX2X_ISCSI_L2_CID, func),
-					CDU_REGION_NUMBER_UCM_AG,
-					ETH_CONNECTION_TYPE);
-
-	rxcqe += BNX2X_MAX_RCQ_DESC_CNT;
-	val = (u64) (cp->l2_ring_map + (2 * BCM_PAGE_SIZE)) >> 32;
-	rxcqe->addr_hi = cpu_to_le32(val);
-
-	CNIC_WR(dev, BAR_USTRORM_INTMEM +
-		USTORM_CQE_PAGE_BASE_OFFSET(port, cli) + 4, val);
-
-	CNIC_WR(dev, BAR_USTRORM_INTMEM +
-		USTORM_CQE_PAGE_NEXT_OFFSET(port, cli) + 4, val);
-
-	val = (u64) (cp->l2_ring_map + (2 * BCM_PAGE_SIZE)) & 0xffffffff;
-	rxcqe->addr_lo = cpu_to_le32(val);
-
-	CNIC_WR(dev, BAR_USTRORM_INTMEM +
-		USTORM_CQE_PAGE_BASE_OFFSET(port, cli), val);
-
-	CNIC_WR(dev, BAR_USTRORM_INTMEM +
-		USTORM_CQE_PAGE_NEXT_OFFSET(port, cli), val);
-
-	/* client tstorm info */
-	tstorm_client.mtu = cp->l2_single_buf_size - 14;
-	tstorm_client.config_flags =
-			(TSTORM_ETH_CLIENT_CONFIG_E1HOV_REM_ENABLE |
-			TSTORM_ETH_CLIENT_CONFIG_STATSITICS_ENABLE);
-	tstorm_client.statistics_counter_id = cli;
-
-	CNIC_WR(dev, BAR_TSTRORM_INTMEM +
-		   TSTORM_CLIENT_CONFIG_OFFSET(port, cli),
-		   ((u32 *)&tstorm_client)[0]);
-	CNIC_WR(dev, BAR_TSTRORM_INTMEM +
-		   TSTORM_CLIENT_CONFIG_OFFSET(port, cli) + 4,
-		   ((u32 *)&tstorm_client)[1]);
-
-	/* reset tstorm per client statistics */
-	val = BAR_TSTRORM_INTMEM +
-	      TSTORM_PER_COUNTER_ID_STATS_OFFSET(port, cli);
-	for (i = 0; i < sizeof(struct tstorm_per_client_stats) / 4; i++)
-		CNIC_WR(dev, val + i * 4, 0);
-
-	/* reset ustorm per client statistics */
-	val = BAR_USTRORM_INTMEM +
-	      USTORM_PER_COUNTER_ID_STATS_OFFSET(port, cli);
-	for (i = 0; i < sizeof(struct ustorm_per_client_stats) / 4; i++)
-		CNIC_WR(dev, val + i * 4, 0);
-
-	cp->rx_cons_ptr =
-		&cp->bnx2x_def_status_blk->u_def_status_block.index_values[
-			HC_INDEX_DEF_U_ETH_ISCSI_RX_CQ_CONS];
-}
-
-static void cnic_get_bnx2x_iscsi_info(struct cnic_dev *dev)
-{
-	struct cnic_local *cp = dev->cnic_priv;
-	u32 base, addr, val;
-	int port = CNIC_PORT(cp);
-
-	dev->max_iscsi_conn = 0;
-	base = CNIC_RD(dev, MISC_REG_SHARED_MEM_ADDR);
-	if (base < 0xa0000 || base >= 0xc0000)
-		return;
-
-	addr = BNX2X_SHMEM_ADDR(base,
-		dev_info.port_hw_config[port].iscsi_mac_upper);
-
-	val = CNIC_RD(dev, addr);
-
-	dev->mac_addr[0] = (u8) (val >> 8);
-	dev->mac_addr[1] = (u8) val;
-
-	addr = BNX2X_SHMEM_ADDR(base,
-		dev_info.port_hw_config[port].iscsi_mac_lower);
-
-	val = CNIC_RD(dev, addr);
-
-	dev->mac_addr[2] = (u8) (val >> 24);
-	dev->mac_addr[3] = (u8) (val >> 16);
-	dev->mac_addr[4] = (u8) (val >> 8);
-	dev->mac_addr[5] = (u8) val;
-
-	addr = BNX2X_SHMEM_ADDR(base, validity_map[port]);
-	val = CNIC_RD(dev, addr);
-
-	if (!(val & SHR_MEM_VALIDITY_LIC_NO_KEY_IN_EFFECT)) {
-		u16 val16;
-
-		addr = BNX2X_SHMEM_ADDR(base,
-				drv_lic_key[port].max_iscsi_init_conn);
-		val16 = CNIC_RD16(dev, addr);
-
-		if (val16)
-			val16 ^= 0x1e1e;
-		dev->max_iscsi_conn = val16;
-	}
-	if (BNX2X_CHIP_IS_E1H(cp->chip_id)) {
-		int func = CNIC_FUNC(cp);
-
-		addr = BNX2X_SHMEM_ADDR(base,
-				mf_cfg.func_mf_config[func].e1hov_tag);
-		val = CNIC_RD(dev, addr);
-		val &= FUNC_MF_CFG_E1HOV_TAG_MASK;
-		if (val != FUNC_MF_CFG_E1HOV_TAG_DEFAULT) {
-			addr = BNX2X_SHMEM_ADDR(base,
-				mf_cfg.func_mf_config[func].config);
-			val = CNIC_RD(dev, addr);
-			val &= FUNC_MF_CFG_PROTOCOL_MASK;
-			if (val != FUNC_MF_CFG_PROTOCOL_ISCSI)
-				dev->max_iscsi_conn = 0;
-		}
-	}
-}
-
-static int cnic_start_bnx2x_hw(struct cnic_dev *dev)
-{
-	struct cnic_local *cp = dev->cnic_priv;
-	int func = CNIC_FUNC(cp), ret, i;
-	int port = CNIC_PORT(cp);
-	u16 eq_idx;
-	u8 sb_id = cp->status_blk_num;
-
-	ret = cnic_init_id_tbl(&cp->cid_tbl, MAX_ISCSI_TBL_SZ,
-			       BNX2X_ISCSI_START_CID);
-
-	if (ret)
-		return -ENOMEM;
-
-	cp->kcq_io_addr = BAR_CSTRORM_INTMEM +
-			  CSTORM_ISCSI_EQ_PROD_OFFSET(func, 0);
-	cp->kcq_prod_idx = 0;
-
-	cnic_get_bnx2x_iscsi_info(dev);
-
-	/* Only 1 EQ */
-	CNIC_WR16(dev, cp->kcq_io_addr, MAX_KCQ_IDX);
-	CNIC_WR(dev, BAR_CSTRORM_INTMEM +
-		CSTORM_ISCSI_EQ_CONS_OFFSET(func, 0), 0);
-	CNIC_WR(dev, BAR_CSTRORM_INTMEM +
-		CSTORM_ISCSI_EQ_NEXT_PAGE_ADDR_OFFSET(func, 0),
-		cp->kcq_info.pg_map_arr[1] & 0xffffffff);
-	CNIC_WR(dev, BAR_CSTRORM_INTMEM +
-		CSTORM_ISCSI_EQ_NEXT_PAGE_ADDR_OFFSET(func, 0) + 4,
-		(u64) cp->kcq_info.pg_map_arr[1] >> 32);
-	CNIC_WR(dev, BAR_CSTRORM_INTMEM +
-		CSTORM_ISCSI_EQ_NEXT_EQE_ADDR_OFFSET(func, 0),
-		cp->kcq_info.pg_map_arr[0] & 0xffffffff);
-	CNIC_WR(dev, BAR_CSTRORM_INTMEM +
-		CSTORM_ISCSI_EQ_NEXT_EQE_ADDR_OFFSET(func, 0) + 4,
-		(u64) cp->kcq_info.pg_map_arr[0] >> 32);
-	CNIC_WR8(dev, BAR_CSTRORM_INTMEM +
-		CSTORM_ISCSI_EQ_NEXT_PAGE_ADDR_VALID_OFFSET(func, 0), 1);
-	CNIC_WR16(dev, BAR_CSTRORM_INTMEM +
-		CSTORM_ISCSI_EQ_SB_NUM_OFFSET(func, 0), cp->status_blk_num);
-	CNIC_WR8(dev, BAR_CSTRORM_INTMEM +
-		CSTORM_ISCSI_EQ_SB_INDEX_OFFSET(func, 0),
-		HC_INDEX_C_ISCSI_EQ_CONS);
-
-	for (i = 0; i < cp->conn_buf_info.num_pages; i++) {
-		CNIC_WR(dev, BAR_TSTRORM_INTMEM +
-			TSTORM_ISCSI_CONN_BUF_PBL_OFFSET(func, i),
-			cp->conn_buf_info.pgtbl[2 * i]);
-		CNIC_WR(dev, BAR_TSTRORM_INTMEM +
-			TSTORM_ISCSI_CONN_BUF_PBL_OFFSET(func, i) + 4,
-			cp->conn_buf_info.pgtbl[(2 * i) + 1]);
-	}
-
-	CNIC_WR(dev, BAR_USTRORM_INTMEM +
-		USTORM_ISCSI_GLOBAL_BUF_PHYS_ADDR_OFFSET(func),
-		cp->gbl_buf_info.pg_map_arr[0] & 0xffffffff);
-	CNIC_WR(dev, BAR_USTRORM_INTMEM +
-		USTORM_ISCSI_GLOBAL_BUF_PHYS_ADDR_OFFSET(func) + 4,
-		(u64) cp->gbl_buf_info.pg_map_arr[0] >> 32);
-
-	cnic_setup_bnx2x_context(dev);
-
-	eq_idx = CNIC_RD16(dev, BAR_CSTRORM_INTMEM +
-			   CSTORM_SB_HOST_STATUS_BLOCK_C_OFFSET(port, sb_id) +
-			   offsetof(struct cstorm_status_block_c,
-				    index_values[HC_INDEX_C_ISCSI_EQ_CONS]));
-	if (eq_idx != 0) {
-		printk(KERN_ERR PFX "%s: EQ cons index %x != 0\n",
-		       dev->netdev->name, eq_idx);
-		return -EBUSY;
-	}
-	ret = cnic_init_bnx2x_irq(dev);
-	if (ret)
-		return ret;
-
-	cnic_init_bnx2x_tx_ring(dev);
-	cnic_init_bnx2x_rx_ring(dev);
-
-	return 0;
-}
-
-static void cnic_init_rings(struct cnic_dev *dev)
-{
-	if (test_bit(CNIC_F_BNX2_CLASS, &dev->flags)) {
-		cnic_init_bnx2_tx_ring(dev);
-		cnic_init_bnx2_rx_ring(dev);
-	} else if (test_bit(CNIC_F_BNX2X_CLASS, &dev->flags)) {
-		struct cnic_local *cp = dev->cnic_priv;
-		u32 cli = BNX2X_ISCSI_CL_ID(CNIC_E1HVN(cp));
-		union l5cm_specific_data l5_data;
-		struct ustorm_eth_rx_producers rx_prods = {0};
-		u32 off, i;
-
-		rx_prods.bd_prod = 0;
-		rx_prods.cqe_prod = BNX2X_MAX_RCQ_DESC_CNT;
-		barrier();
-
-		off = BAR_USTRORM_INTMEM +
-			USTORM_RX_PRODS_OFFSET(CNIC_PORT(cp), cli);
-
-		for (i = 0; i < sizeof(struct ustorm_eth_rx_producers) / 4; i++)
-			CNIC_WR(dev, off + i * 4, ((u32 *) &rx_prods)[i]);
-
-		cnic_init_bnx2x_tx_ring(dev);
-		cnic_init_bnx2x_rx_ring(dev);
-
-		l5_data.phy_address.lo = cli;
-		l5_data.phy_address.hi = 0;
-		cnic_submit_kwqe_16(dev, RAMROD_CMD_ID_ETH_CLIENT_SETUP,
-			BNX2X_ISCSI_L2_CID, ETH_CONNECTION_TYPE, &l5_data);
-		cnic_ring_ctl(dev, BNX2X_ISCSI_L2_CID, cli, 1);
-	}
-}
-
-static void cnic_shutdown_rings(struct cnic_dev *dev)
-{
-	if (test_bit(CNIC_F_BNX2_CLASS, &dev->flags)) {
-		cnic_shutdown_bnx2_rx_ring(dev);
-	} else if (test_bit(CNIC_F_BNX2X_CLASS, &dev->flags)) {
-		struct cnic_local *cp = dev->cnic_priv;
-		u32 cli = BNX2X_ISCSI_CL_ID(CNIC_E1HVN(cp));
-		union l5cm_specific_data l5_data;
-
-		cnic_ring_ctl(dev, BNX2X_ISCSI_L2_CID, cli, 0);
-
-		l5_data.phy_address.lo = cli;
-		l5_data.phy_address.hi = 0;
-		cnic_submit_kwqe_16(dev, RAMROD_CMD_ID_ETH_HALT,
-			BNX2X_ISCSI_L2_CID, ETH_CONNECTION_TYPE, &l5_data);
-		msleep(10);
-
-		memset(&l5_data, 0, sizeof(l5_data));
-		cnic_submit_kwqe_16(dev, RAMROD_CMD_ID_ETH_CFC_DEL,
-			BNX2X_ISCSI_L2_CID, ETH_CONNECTION_TYPE |
-			(1 << SPE_HDR_COMMON_RAMROD_SHIFT), &l5_data);
-		msleep(10);
-	}
-}
-
-static int cnic_register_netdev(struct cnic_dev *dev)
-{
-	struct cnic_local *cp = dev->cnic_priv;
-	struct cnic_eth_dev *ethdev = cp->ethdev;
-	int err;
-
-	if (!ethdev)
-		return -ENODEV;
-
-	if (ethdev->drv_state & CNIC_DRV_STATE_REGD)
-		return 0;
-
-	err = ethdev->drv_register_cnic(dev->netdev, cp->cnic_ops, dev);
-	if (err)
-		printk(KERN_ERR PFX "%s: register_cnic failed\n",
-		       dev->netdev->name);
-
-	return err;
-}
-
-static void cnic_unregister_netdev(struct cnic_dev *dev)
-{
-	struct cnic_local *cp = dev->cnic_priv;
-	struct cnic_eth_dev *ethdev = cp->ethdev;
-
-	if (!ethdev)
-		return;
-
-	ethdev->drv_unregister_cnic(dev->netdev);
-}
-
-static int cnic_start_hw(struct cnic_dev *dev)
-{
-	struct cnic_local *cp = dev->cnic_priv;
-	struct cnic_eth_dev *ethdev = cp->ethdev;
-	int err;
-
-	if (test_bit(CNIC_F_CNIC_UP, &dev->flags))
-		return -EALREADY;
-
-	dev->regview = ethdev->io_base;
-	cp->chip_id = ethdev->chip_id;
-	pci_dev_get(dev->pcidev);
-	cp->func = PCI_FUNC(dev->pcidev->devfn);
-	cp->status_blk.gen = ethdev->irq_arr[0].status_blk;
-	cp->status_blk_num = ethdev->irq_arr[0].status_blk_num;
-
-	err = cp->alloc_resc(dev);
-	if (err) {
-		printk(KERN_ERR PFX "%s: allocate resource failure\n",
-		       dev->netdev->name);
-		goto err1;
-	}
-
-	err = cp->start_hw(dev);
-	if (err)
-		goto err1;
-
-	err = cnic_cm_open(dev);
-	if (err)
-		goto err1;
-
-	set_bit(CNIC_F_CNIC_UP, &dev->flags);
-
-	cp->enable_int(dev);
-
-	return 0;
-
-err1:
-	cp->free_resc(dev);
-	pci_dev_put(dev->pcidev);
-	return err;
-}
-
-static void cnic_stop_bnx2_hw(struct cnic_dev *dev)
-{
-	cnic_disable_bnx2_int_sync(dev);
-
-	cnic_reg_wr_ind(dev, BNX2_CP_SCRATCH + 0x20, 0);
-	cnic_reg_wr_ind(dev, BNX2_COM_SCRATCH + 0x20, 0);
-
-	cnic_init_context(dev, KWQ_CID);
-	cnic_init_context(dev, KCQ_CID);
-
-	cnic_setup_5709_context(dev, 0);
-	cnic_free_irq(dev);
-
-	cnic_free_resc(dev);
-}
-
-
-static void cnic_stop_bnx2x_hw(struct cnic_dev *dev)
-{
-	struct cnic_local *cp = dev->cnic_priv;
-	u8 sb_id = cp->status_blk_num;
-	int port = CNIC_PORT(cp);
-
-	cnic_free_irq(dev);
-	CNIC_WR16(dev, BAR_CSTRORM_INTMEM +
-		  CSTORM_SB_HOST_STATUS_BLOCK_C_OFFSET(port, sb_id) +
-		  offsetof(struct cstorm_status_block_c,
-			   index_values[HC_INDEX_C_ISCSI_EQ_CONS]),
-		  0);
-	CNIC_WR(dev, BAR_CSTRORM_INTMEM +
-		CSTORM_ISCSI_EQ_CONS_OFFSET(cp->func, 0), 0);
-	CNIC_WR16(dev, cp->kcq_io_addr, 0);
-	cnic_free_resc(dev);
-}
-
-static void cnic_stop_hw(struct cnic_dev *dev)
-{
-	if (test_bit(CNIC_F_CNIC_UP, &dev->flags)) {
-		struct cnic_local *cp = dev->cnic_priv;
-
-		clear_bit(CNIC_F_CNIC_UP, &dev->flags);
-		rcu_assign_pointer(cp->ulp_ops[CNIC_ULP_L4], NULL);
-		synchronize_rcu();
-		cnic_cm_shutdown(dev);
-		cp->stop_hw(dev);
-		pci_dev_put(dev->pcidev);
-	}
-}
-
-static void cnic_free_dev(struct cnic_dev *dev)
-{
-	int i = 0;
-
-	while ((atomic_read(&dev->ref_count) != 0) && i < 10) {
-		msleep(100);
-		i++;
-	}
-	if (atomic_read(&dev->ref_count) != 0)
-		printk(KERN_ERR PFX "%s: Failed waiting for ref count to go"
-				    " to zero.\n", dev->netdev->name);
-
-	printk(KERN_INFO PFX "Removed CNIC device: %s\n", dev->netdev->name);
-	dev_put(dev->netdev);
-	kfree(dev);
-}
-
-static struct cnic_dev *cnic_alloc_dev(struct net_device *dev,
-				       struct pci_dev *pdev)
-{
-	struct cnic_dev *cdev;
-	struct cnic_local *cp;
-	int alloc_size;
-
-	alloc_size = sizeof(struct cnic_dev) + sizeof(struct cnic_local);
-
-	cdev = kzalloc(alloc_size , GFP_KERNEL);
-	if (cdev == NULL) {
-		printk(KERN_ERR PFX "%s: allocate dev struct failure\n",
-		       dev->name);
-		return NULL;
-	}
-
-	cdev->netdev = dev;
-	cdev->cnic_priv = (char *)cdev + sizeof(struct cnic_dev);
-	cdev->register_device = cnic_register_device;
-	cdev->unregister_device = cnic_unregister_device;
-	cdev->iscsi_nl_msg_recv = cnic_iscsi_nl_msg_recv;
-
-	cp = cdev->cnic_priv;
-	cp->dev = cdev;
-	cp->uio_dev = -1;
-	cp->l2_single_buf_size = 0x400;
-	cp->l2_rx_ring_size = 3;
-
-	spin_lock_init(&cp->cnic_ulp_lock);
-
-	printk(KERN_INFO PFX "Added CNIC device: %s\n", dev->name);
-
-	return cdev;
-}
-
-static struct cnic_dev *init_bnx2_cnic(struct net_device *dev)
-{
-	struct pci_dev *pdev;
-	struct cnic_dev *cdev;
-	struct cnic_local *cp;
-	struct cnic_eth_dev *ethdev = NULL;
-	struct cnic_eth_dev *(*probe)(struct net_device *) = NULL;
-
-	probe = symbol_get(bnx2_cnic_probe);
-	if (probe) {
-		ethdev = (*probe)(dev);
-		symbol_put(bnx2_cnic_probe);
-	}
-	if (!ethdev)
-		return NULL;
-
-	pdev = ethdev->pdev;
-	if (!pdev)
-		return NULL;
-
-	dev_hold(dev);
-	pci_dev_get(pdev);
-	if (pdev->device == PCI_DEVICE_ID_NX2_5709 ||
-	    pdev->device == PCI_DEVICE_ID_NX2_5709S) {
-		u8 rev;
-
-		pci_read_config_byte(pdev, PCI_REVISION_ID, &rev);
-		if (rev < 0x10) {
-			pci_dev_put(pdev);
-			goto cnic_err;
-		}
-	}
-	pci_dev_put(pdev);
-
-	cdev = cnic_alloc_dev(dev, pdev);
-	if (cdev == NULL)
-		goto cnic_err;
-
-	set_bit(CNIC_F_BNX2_CLASS, &cdev->flags);
-	cdev->submit_kwqes = cnic_submit_bnx2_kwqes;
-
-	cp = cdev->cnic_priv;
-	cp->ethdev = ethdev;
-	cdev->pcidev = pdev;
-
-	cp->cnic_ops = &cnic_bnx2_ops;
-	cp->start_hw = cnic_start_bnx2_hw;
-	cp->stop_hw = cnic_stop_bnx2_hw;
-	cp->setup_pgtbl = cnic_setup_page_tbl;
-	cp->alloc_resc = cnic_alloc_bnx2_resc;
-	cp->free_resc = cnic_free_resc;
-	cp->start_cm = cnic_cm_init_bnx2_hw;
-	cp->stop_cm = cnic_cm_stop_bnx2_hw;
-	cp->enable_int = cnic_enable_bnx2_int;
-	cp->disable_int_sync = cnic_disable_bnx2_int_sync;
-	cp->close_conn = cnic_close_bnx2_conn;
-	cp->next_idx = cnic_bnx2_next_idx;
-	cp->hw_idx = cnic_bnx2_hw_idx;
-	return cdev;
-
-cnic_err:
-	dev_put(dev);
-	return NULL;
-}
-
-static struct cnic_dev *init_bnx2x_cnic(struct net_device *dev)
-{
-	struct pci_dev *pdev;
-	struct cnic_dev *cdev;
-	struct cnic_local *cp;
-	struct cnic_eth_dev *ethdev = NULL;
-	struct cnic_eth_dev *(*probe)(struct net_device *) = NULL;
-
-	probe = symbol_get(bnx2x_cnic_probe);
-	if (probe) {
-		ethdev = (*probe)(dev);
-		symbol_put(bnx2x_cnic_probe);
-	}
-	if (!ethdev)
-		return NULL;
-
-	pdev = ethdev->pdev;
-	if (!pdev)
-		return NULL;
-
-	dev_hold(dev);
-	cdev = cnic_alloc_dev(dev, pdev);
-	if (cdev == NULL) {
-		dev_put(dev);
-		return NULL;
-	}
-
-	set_bit(CNIC_F_BNX2X_CLASS, &cdev->flags);
-	cdev->submit_kwqes = cnic_submit_bnx2x_kwqes;
-
-	cp = cdev->cnic_priv;
-	cp->ethdev = ethdev;
-	cdev->pcidev = pdev;
-
-	cp->cnic_ops = &cnic_bnx2x_ops;
-	cp->start_hw = cnic_start_bnx2x_hw;
-	cp->stop_hw = cnic_stop_bnx2x_hw;
-	cp->setup_pgtbl = cnic_setup_page_tbl_le;
-	cp->alloc_resc = cnic_alloc_bnx2x_resc;
-	cp->free_resc = cnic_free_resc;
-	cp->start_cm = cnic_cm_init_bnx2x_hw;
-	cp->stop_cm = cnic_cm_stop_bnx2x_hw;
-	cp->enable_int = cnic_enable_bnx2x_int;
-	cp->disable_int_sync = cnic_disable_bnx2x_int_sync;
-	cp->ack_int = cnic_ack_bnx2x_msix;
-	cp->close_conn = cnic_close_bnx2x_conn;
-	cp->next_idx = cnic_bnx2x_next_idx;
-	cp->hw_idx = cnic_bnx2x_hw_idx;
-	return cdev;
-}
-
-static struct cnic_dev *is_cnic_dev(struct net_device *dev)
-{
-	struct ethtool_drvinfo drvinfo;
-	struct cnic_dev *cdev = NULL;
-
-	if (dev->ethtool_ops && dev->ethtool_ops->get_drvinfo) {
-		memset(&drvinfo, 0, sizeof(drvinfo));
-		dev->ethtool_ops->get_drvinfo(dev, &drvinfo);
-
-		if (!strcmp(drvinfo.driver, "bnx2"))
-			cdev = init_bnx2_cnic(dev);
-		if (!strcmp(drvinfo.driver, "bnx2x"))
-			cdev = init_bnx2x_cnic(dev);
-		if (cdev) {
-			write_lock(&cnic_dev_lock);
-			list_add(&cdev->list, &cnic_dev_list);
-			write_unlock(&cnic_dev_lock);
-		}
-	}
-	return cdev;
-}
-
-/**
- * netdev event handler
- */
-static int cnic_netdev_event(struct notifier_block *this, unsigned long event,
-							 void *ptr)
-{
-	struct net_device *netdev = ptr;
-	struct cnic_dev *dev;
-	int if_type;
-	int new_dev = 0;
-
-	dev = cnic_from_netdev(netdev);
-
-	if (!dev && (event == NETDEV_REGISTER || event == NETDEV_UP)) {
-		/* Check for the hot-plug device */
-		dev = is_cnic_dev(netdev);
-		if (dev) {
-			new_dev = 1;
-			cnic_hold(dev);
-		}
-	}
-	if (dev) {
-		struct cnic_local *cp = dev->cnic_priv;
-
-		if (new_dev)
-			cnic_ulp_init(dev);
-		else if (event == NETDEV_UNREGISTER)
-			cnic_ulp_exit(dev);
-
-		if (event == NETDEV_UP) {
-			if (cnic_register_netdev(dev) != 0) {
-				cnic_put(dev);
-				goto done;
-			}
-			if (!cnic_start_hw(dev))
-				cnic_ulp_start(dev);
-		}
-
-		rcu_read_lock();
-		for (if_type = 0; if_type < MAX_CNIC_ULP_TYPE; if_type++) {
-			struct cnic_ulp_ops *ulp_ops;
-			void *ctx;
-
-			ulp_ops = rcu_dereference(cp->ulp_ops[if_type]);
-			if (!ulp_ops || !ulp_ops->indicate_netevent)
-				continue;
-
-			ctx = cp->ulp_handle[if_type];
-
-			ulp_ops->indicate_netevent(ctx, event);
-		}
-		rcu_read_unlock();
-
-		if (event == NETDEV_GOING_DOWN) {
-			cnic_ulp_stop(dev);
-			cnic_stop_hw(dev);
-			cnic_unregister_netdev(dev);
-		} else if (event == NETDEV_UNREGISTER) {
-			write_lock(&cnic_dev_lock);
-			list_del_init(&dev->list);
-			write_unlock(&cnic_dev_lock);
-
-			cnic_put(dev);
-			cnic_free_dev(dev);
-			goto done;
-		}
-		cnic_put(dev);
-	}
-done:
-	return NOTIFY_DONE;
-}
-
-static struct notifier_block cnic_netdev_notifier = {
-	.notifier_call = cnic_netdev_event
-};
-
-static void cnic_release(void)
-{
-	struct cnic_dev *dev;
-
-	while (!list_empty(&cnic_dev_list)) {
-		dev = list_entry(cnic_dev_list.next, struct cnic_dev, list);
-		if (test_bit(CNIC_F_CNIC_UP, &dev->flags)) {
-			cnic_ulp_stop(dev);
-			cnic_stop_hw(dev);
-		}
-
-		cnic_ulp_exit(dev);
-		cnic_unregister_netdev(dev);
-		list_del_init(&dev->list);
-		cnic_free_dev(dev);
-	}
-}
-
-static int __init cnic_init(void)
-{
-	int rc = 0;
-
-	printk(KERN_INFO "%s", version);
-
-	rc = register_netdevice_notifier(&cnic_netdev_notifier);
-	if (rc) {
-		cnic_release();
-		return rc;
-	}
-
-	return 0;
-}
-
-static void __exit cnic_exit(void)
-{
-	unregister_netdevice_notifier(&cnic_netdev_notifier);
-	cnic_release();
-	return;
-}
-
-module_init(cnic_init);
-module_exit(cnic_exit);
diff -r f4bf81a7ff20 drivers/net/cnic.h
--- a/drivers/net/cnic.h
+++ /dev/null
@@ -1,367 +0,0 @@
-/* cnic.h: Broadcom CNIC core network driver.
- *
- * Copyright (c) 2006-2009 Broadcom Corporation
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation.
- *
- */
-
-
-#ifndef CNIC_H
-#define CNIC_H
-
-#define KWQ_PAGE_CNT	4
-#define KCQ_PAGE_CNT	16
-
-#define KWQ_CID 		24
-#define KCQ_CID 		25
-
-/*
- *	krnlq_context definition
- */
-#define L5_KRNLQ_FLAGS	0x00000000
-#define L5_KRNLQ_SIZE	0x00000000
-#define L5_KRNLQ_TYPE	0x00000000
-#define KRNLQ_FLAGS_PG_SZ					(0xf<<0)
-#define KRNLQ_FLAGS_PG_SZ_256					(0<<0)
-#define KRNLQ_FLAGS_PG_SZ_512					(1<<0)
-#define KRNLQ_FLAGS_PG_SZ_1K					(2<<0)
-#define KRNLQ_FLAGS_PG_SZ_2K					(3<<0)
-#define KRNLQ_FLAGS_PG_SZ_4K					(4<<0)
-#define KRNLQ_FLAGS_PG_SZ_8K					(5<<0)
-#define KRNLQ_FLAGS_PG_SZ_16K					(6<<0)
-#define KRNLQ_FLAGS_PG_SZ_32K					(7<<0)
-#define KRNLQ_FLAGS_PG_SZ_64K					(8<<0)
-#define KRNLQ_FLAGS_PG_SZ_128K					(9<<0)
-#define KRNLQ_FLAGS_PG_SZ_256K					(10<<0)
-#define KRNLQ_FLAGS_PG_SZ_512K					(11<<0)
-#define KRNLQ_FLAGS_PG_SZ_1M					(12<<0)
-#define KRNLQ_FLAGS_PG_SZ_2M					(13<<0)
-#define KRNLQ_FLAGS_QE_SELF_SEQ					(1<<15)
-#define KRNLQ_SIZE_TYPE_SIZE	((((0x28 + 0x1f) & ~0x1f) / 0x20) << 16)
-#define KRNLQ_TYPE_TYPE						(0xf<<28)
-#define KRNLQ_TYPE_TYPE_EMPTY					(0<<28)
-#define KRNLQ_TYPE_TYPE_KRNLQ					(6<<28)
-
-#define L5_KRNLQ_HOST_QIDX		0x00000004
-#define L5_KRNLQ_HOST_FW_QIDX		0x00000008
-#define L5_KRNLQ_NX_QE_SELF_SEQ 	0x0000000c
-#define L5_KRNLQ_QE_SELF_SEQ_MAX	0x0000000c
-#define L5_KRNLQ_NX_QE_HADDR_HI 	0x00000010
-#define L5_KRNLQ_NX_QE_HADDR_LO 	0x00000014
-#define L5_KRNLQ_PGTBL_PGIDX		0x00000018
-#define L5_KRNLQ_NX_PG_QIDX 		0x00000018
-#define L5_KRNLQ_PGTBL_NPAGES		0x0000001c
-#define L5_KRNLQ_QIDX_INCR		0x0000001c
-#define L5_KRNLQ_PGTBL_HADDR_HI 	0x00000020
-#define L5_KRNLQ_PGTBL_HADDR_LO 	0x00000024
-
-#define BNX2_PG_CTX_MAP			0x1a0034
-#define BNX2_ISCSI_CTX_MAP		0x1a0074
-
-struct cnic_redirect_entry {
-	struct dst_entry *old_dst;
-	struct dst_entry *new_dst;
-};
-
-#define MAX_COMPLETED_KCQE	64
-
-#define MAX_CNIC_L5_CONTEXT	256
-
-#define MAX_CM_SK_TBL_SZ	MAX_CNIC_L5_CONTEXT
-
-#define MAX_ISCSI_TBL_SZ	256
-
-#define CNIC_LOCAL_PORT_MIN	60000
-#define CNIC_LOCAL_PORT_MAX	61000
-#define CNIC_LOCAL_PORT_RANGE	(CNIC_LOCAL_PORT_MAX - CNIC_LOCAL_PORT_MIN)
-
-#define KWQE_CNT (BCM_PAGE_SIZE / sizeof(struct kwqe))
-#define KCQE_CNT (BCM_PAGE_SIZE / sizeof(struct kcqe))
-#define MAX_KWQE_CNT (KWQE_CNT - 1)
-#define MAX_KCQE_CNT (KCQE_CNT - 1)
-
-#define MAX_KWQ_IDX	((KWQ_PAGE_CNT * KWQE_CNT) - 1)
-#define MAX_KCQ_IDX	((KCQ_PAGE_CNT * KCQE_CNT) - 1)
-
-#define KWQ_PG(x) (((x) & ~MAX_KWQE_CNT) >> (BCM_PAGE_BITS - 5))
-#define KWQ_IDX(x) ((x) & MAX_KWQE_CNT)
-
-#define KCQ_PG(x) (((x) & ~MAX_KCQE_CNT) >> (BCM_PAGE_BITS - 5))
-#define KCQ_IDX(x) ((x) & MAX_KCQE_CNT)
-
-#define BNX2X_NEXT_KCQE(x) (((x) & (MAX_KCQE_CNT - 1)) ==		\
-		(MAX_KCQE_CNT - 1)) ?					\
-		(x) + 2 : (x) + 1
-
-#define BNX2X_KWQ_DATA_PG(cp, x) ((x) / (cp)->kwq_16_data_pp)
-#define BNX2X_KWQ_DATA_IDX(cp, x) ((x) % (cp)->kwq_16_data_pp)
-#define BNX2X_KWQ_DATA(cp, x)						\
-	&(cp)->kwq_16_data[BNX2X_KWQ_DATA_PG(cp, x)][BNX2X_KWQ_DATA_IDX(cp, x)]
-
-#define DEF_IPID_COUNT		0xc001
-
-#define DEF_KA_TIMEOUT		10000
-#define DEF_KA_INTERVAL		300000
-#define DEF_KA_MAX_PROBE_COUNT	3
-#define DEF_TOS			0
-#define DEF_TTL			0xfe
-#define DEF_SND_SEQ_SCALE	0
-#define DEF_RCV_BUF		0xffff
-#define DEF_SND_BUF		0xffff
-#define DEF_SEED		0
-#define DEF_MAX_RT_TIME		500
-#define DEF_MAX_DA_COUNT	2
-#define DEF_SWS_TIMER		1000
-#define DEF_MAX_CWND		0xffff
-
-struct cnic_ctx {
-	u32		cid;
-	void		*ctx;
-	dma_addr_t	mapping;
-};
-
-#define BNX2_MAX_CID		0x2000
-
-struct cnic_dma {
-	int		num_pages;
-	void		**pg_arr;
-	dma_addr_t	*pg_map_arr;
-	int		pgtbl_size;
-	u32		*pgtbl;
-	dma_addr_t	pgtbl_map;
-};
-
-struct cnic_id_tbl {
-	spinlock_t	lock;
-	u32		start;
-	u32		max;
-	u32		next;
-	unsigned long	*table;
-};
-
-#define CNIC_KWQ16_DATA_SIZE	128
-
-struct kwqe_16_data {
-	u8	data[CNIC_KWQ16_DATA_SIZE];
-};
-
-struct cnic_iscsi {
-	struct cnic_dma		task_array_info;
-	struct cnic_dma		r2tq_info;
-	struct cnic_dma		hq_info;
-};
-
-struct cnic_context {
-	u32			cid;
-	struct kwqe_16_data	*kwqe_data;
-	dma_addr_t		kwqe_data_mapping;
-	wait_queue_head_t	waitq;
-	int			wait_cond;
-	unsigned long		timestamp;
-	u32			ctx_flags;
-#define	CTX_FL_OFFLD_START	0x00000001
-	u8			ulp_proto_id;
-	union {
-		struct cnic_iscsi	*iscsi;
-	} proto;
-};
-
-struct cnic_local {
-
-	spinlock_t cnic_ulp_lock;
-	void *ulp_handle[MAX_CNIC_ULP_TYPE];
-	unsigned long ulp_flags[MAX_CNIC_ULP_TYPE];
-#define ULP_F_INIT	0
-#define ULP_F_START	1
-#define ULP_F_CALL_PENDING	2
-	struct cnic_ulp_ops *ulp_ops[MAX_CNIC_ULP_TYPE];
-
-	/* protected by ulp_lock */
-	u32 cnic_local_flags;
-#define	CNIC_LCL_FL_KWQ_INIT	0x00000001
-
-	struct cnic_dev *dev;
-
-	struct cnic_eth_dev *ethdev;
-
-	void		*l2_ring;
-	dma_addr_t	l2_ring_map;
-	int		l2_ring_size;
-	int		l2_rx_ring_size;
-
-	void		*l2_buf;
-	dma_addr_t	l2_buf_map;
-	int		l2_buf_size;
-	int		l2_single_buf_size;
-
-	u16		*rx_cons_ptr;
-	u16		*tx_cons_ptr;
-	u16		rx_cons;
-	u16		tx_cons;
-
-	u32 kwq_cid_addr;
-	u32 kcq_cid_addr;
-
-	struct cnic_dma		kwq_info;
-	struct kwqe		**kwq;
-
-	struct cnic_dma		kwq_16_data_info;
-
-	u16		max_kwq_idx;
-
-	u16		kwq_prod_idx;
-	u32		kwq_io_addr;
-
-	u16		*kwq_con_idx_ptr;
-	u16		kwq_con_idx;
-
-	struct cnic_dma	kcq_info;
-	struct kcqe	**kcq;
-
-	u16		kcq_prod_idx;
-	u32		kcq_io_addr;
-
-	union {
-		void				*gen;
-		struct status_block_msix	*bnx2;
-		struct host_status_block	*bnx2x;
-	} status_blk;
-
-	struct host_def_status_block	*bnx2x_def_status_blk;
-
-	u32				status_blk_num;
-	u32				int_num;
-	u32				last_status_idx;
-	struct tasklet_struct		cnic_irq_task;
-
-	struct kcqe		*completed_kcq[MAX_COMPLETED_KCQE];
-
-	struct cnic_sock	*csk_tbl;
-	struct cnic_id_tbl	csk_port_tbl;
-
-	struct cnic_dma		conn_buf_info;
-	struct cnic_dma		gbl_buf_info;
-
-	struct cnic_iscsi	*iscsi_tbl;
-	struct cnic_context	*ctx_tbl;
-	struct cnic_id_tbl	cid_tbl;
-	int			max_iscsi_conn;
-	atomic_t		iscsi_conn;
-
-	/* per connection parameters */
-	int			num_iscsi_tasks;
-	int			num_ccells;
-	int			task_array_size;
-	int			r2tq_size;
-	int			hq_size;
-	int			num_cqs;
-
-	struct cnic_ctx		*ctx_arr;
-	int			ctx_blks;
-	int			ctx_blk_size;
-	unsigned long		ctx_align;
-	int			cids_per_blk;
-
-	u32			chip_id;
-	int			func;
-	u32			shmem_base;
-
-	u32			uio_dev;
-	struct uio_info		*cnic_uinfo;
-
-	struct cnic_ops		*cnic_ops;
-	int			(*start_hw)(struct cnic_dev *);
-	void			(*stop_hw)(struct cnic_dev *);
-	void			(*setup_pgtbl)(struct cnic_dev *,
-					       struct cnic_dma *);
-	int			(*alloc_resc)(struct cnic_dev *);
-	void			(*free_resc)(struct cnic_dev *);
-	int			(*start_cm)(struct cnic_dev *);
-	void			(*stop_cm)(struct cnic_dev *);
-	void			(*enable_int)(struct cnic_dev *);
-	void			(*disable_int_sync)(struct cnic_dev *);
-	void			(*ack_int)(struct cnic_dev *);
-	void			(*close_conn)(struct cnic_sock *, u32 opcode);
-	u16			(*next_idx)(u16);
-	u16			(*hw_idx)(u16);
-};
-
-struct bnx2x_bd_chain_next {
-	u32	addr_lo;
-	u32	addr_hi;
-	u8	reserved[8];
-};
-
-#define ISCSI_DEFAULT_MAX_OUTSTANDING_R2T 	(1)
-
-#define ISCSI_RAMROD_CMD_ID_UPDATE_CONN		(ISCSI_KCQE_OPCODE_UPDATE_CONN)
-#define ISCSI_RAMROD_CMD_ID_INIT		(ISCSI_KCQE_OPCODE_INIT)
-
-#define CDU_REGION_NUMBER_XCM_AG 2
-#define CDU_REGION_NUMBER_UCM_AG 4
-
-#define CDU_VALID_DATA(_cid, _region, _type)	\
-	(((_cid) << 8) | (((_region)&0xf)<<4) | (((_type)&0xf)))
-
-#define CDU_CRC8(_cid, _region, _type)	\
-	(calc_crc8(CDU_VALID_DATA(_cid, _region, _type), 0xff))
-
-#define CDU_RSRVD_VALUE_TYPE_A(_cid, _region, _type)	\
-	(0x80 | ((CDU_CRC8(_cid, _region, _type)) & 0x7f))
-
-#define BNX2X_CONTEXT_MEM_SIZE		1024
-#define BNX2X_FCOE_CID			16
-
-/* iSCSI client IDs are 17, 19, 21, 23 */
-#define BNX2X_ISCSI_BASE_CL_ID		17
-#define BNX2X_ISCSI_CL_ID(vn)		(BNX2X_ISCSI_BASE_CL_ID + ((vn) << 1))
-
-#define BNX2X_ISCSI_L2_CID		17
-#define BNX2X_ISCSI_START_CID		18
-#define BNX2X_ISCSI_NUM_CONNECTIONS	128
-#define BNX2X_ISCSI_TASK_CONTEXT_SIZE	128
-#define BNX2X_ISCSI_MAX_PENDING_R2TS	4
-#define BNX2X_ISCSI_R2TQE_SIZE		8
-#define BNX2X_ISCSI_HQ_BD_SIZE		64
-#define BNX2X_ISCSI_CONN_BUF_SIZE	64
-#define BNX2X_ISCSI_GLB_BUF_SIZE	64
-#define BNX2X_ISCSI_PBL_NOT_CACHED	0xff
-#define BNX2X_ISCSI_PDU_HEADER_NOT_CACHED	0xff
-#define BNX2X_HW_CID(x, func)		((x) | (((func) % PORT_MAX) << 23) | \
-					 (((func) >> 1) << 17))
-#define BNX2X_SW_CID(x)			(x & 0x1ffff)
-#define BNX2X_CHIP_NUM_57711		0x164f
-#define BNX2X_CHIP_NUM_57711E		0x1650
-#define BNX2X_CHIP_NUM(x)		(x >> 16)
-#define BNX2X_CHIP_IS_57711(x)		\
-	(BNX2X_CHIP_NUM(x) == BNX2X_CHIP_NUM_57711)
-#define BNX2X_CHIP_IS_57711E(x)		\
-	(BNX2X_CHIP_NUM(x) == BNX2X_CHIP_NUM_57711E)
-#define BNX2X_CHIP_IS_E1H(x)		\
-	(BNX2X_CHIP_IS_57711(x) || BNX2X_CHIP_IS_57711E(x))
-#define IS_E1H_OFFSET       		BNX2X_CHIP_IS_E1H(cp->chip_id)
-
-#define BNX2X_RX_DESC_CNT		(BCM_PAGE_SIZE / sizeof(struct eth_rx_bd))
-#define BNX2X_MAX_RX_DESC_CNT		(BNX2X_RX_DESC_CNT - 2)
-#define BNX2X_RCQ_DESC_CNT		(BCM_PAGE_SIZE / sizeof(union eth_rx_cqe))
-#define BNX2X_MAX_RCQ_DESC_CNT		(BNX2X_RCQ_DESC_CNT - 1)
-
-#define BNX2X_DEF_SB_ID			16
-
-#define BNX2X_ISCSI_RX_SB_INDEX_NUM					\
-		((HC_INDEX_DEF_U_ETH_ISCSI_RX_CQ_CONS << \
-		  USTORM_ETH_ST_CONTEXT_CONFIG_CQE_SB_INDEX_NUMBER_SHIFT) & \
-		 USTORM_ETH_ST_CONTEXT_CONFIG_CQE_SB_INDEX_NUMBER)
-
-#define BNX2X_SHMEM_ADDR(base, field)	(base + \
-					 offsetof(struct shmem_region, field))
-
-#define CNIC_PORT(cp)			((cp)->func % PORT_MAX)
-#define CNIC_FUNC(cp)			((cp)->func)
-#define CNIC_E1HVN(cp)			((cp)->func >> 1)
-
-#endif
-
diff -r f4bf81a7ff20 drivers/net/cnic_defs.h
--- a/drivers/net/cnic_defs.h
+++ /dev/null
@@ -1,2497 +0,0 @@
-
-/* cnic.c: Broadcom CNIC core network driver.
- *
- * Copyright (c) 2006-2009 Broadcom Corporation
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation.
- *
- */
-
-#ifndef CNIC_DEFS_H
-#define CNIC_DEFS_H
-
-/* KWQ (kernel work queue) request op codes */
-#define L2_KWQE_OPCODE_VALUE_FLUSH                  (4)
-
-#define L4_KWQE_OPCODE_VALUE_CONNECT1               (50)
-#define L4_KWQE_OPCODE_VALUE_CONNECT2               (51)
-#define L4_KWQE_OPCODE_VALUE_CONNECT3               (52)
-#define L4_KWQE_OPCODE_VALUE_RESET                  (53)
-#define L4_KWQE_OPCODE_VALUE_CLOSE                  (54)
-#define L4_KWQE_OPCODE_VALUE_UPDATE_SECRET          (60)
-#define L4_KWQE_OPCODE_VALUE_INIT_ULP               (61)
-
-#define L4_KWQE_OPCODE_VALUE_OFFLOAD_PG             (1)
-#define L4_KWQE_OPCODE_VALUE_UPDATE_PG              (9)
-#define L4_KWQE_OPCODE_VALUE_UPLOAD_PG              (14)
-
-#define L5CM_RAMROD_CMD_ID_BASE			(0x80)
-#define L5CM_RAMROD_CMD_ID_TCP_CONNECT		(L5CM_RAMROD_CMD_ID_BASE + 3)
-#define L5CM_RAMROD_CMD_ID_CLOSE		(L5CM_RAMROD_CMD_ID_BASE + 12)
-#define L5CM_RAMROD_CMD_ID_ABORT		(L5CM_RAMROD_CMD_ID_BASE + 13)
-#define L5CM_RAMROD_CMD_ID_SEARCHER_DELETE	(L5CM_RAMROD_CMD_ID_BASE + 14)
-#define L5CM_RAMROD_CMD_ID_TERMINATE_OFFLOAD	(L5CM_RAMROD_CMD_ID_BASE + 15)
-
-/* KCQ (kernel completion queue) response op codes */
-#define L4_KCQE_OPCODE_VALUE_CLOSE_COMP             (53)
-#define L4_KCQE_OPCODE_VALUE_RESET_COMP             (54)
-#define L4_KCQE_OPCODE_VALUE_FW_TCP_UPDATE          (55)
-#define L4_KCQE_OPCODE_VALUE_CONNECT_COMPLETE       (56)
-#define L4_KCQE_OPCODE_VALUE_RESET_RECEIVED         (57)
-#define L4_KCQE_OPCODE_VALUE_CLOSE_RECEIVED         (58)
-#define L4_KCQE_OPCODE_VALUE_INIT_ULP               (61)
-
-#define L4_KCQE_OPCODE_VALUE_OFFLOAD_PG             (1)
-#define L4_KCQE_OPCODE_VALUE_UPDATE_PG              (9)
-#define L4_KCQE_OPCODE_VALUE_UPLOAD_PG              (14)
-
-/* KCQ (kernel completion queue) completion status */
-#define L4_KCQE_COMPLETION_STATUS_SUCCESS		    (0)
-#define L4_KCQE_COMPLETION_STATUS_TIMEOUT        (0x93)
-
-#define L4_KCQE_COMPLETION_STATUS_CTX_ALLOC_FAIL (0x83)
-#define L4_KCQE_COMPLETION_STATUS_OFFLOADED_PG   (0x89)
-
-#define L4_LAYER_CODE (4)
-#define L2_LAYER_CODE (2)
-
-/*
- * L4 KCQ CQE
- */
-struct l4_kcq {
-	u32 cid;
-	u32 pg_cid;
-	u32 conn_id;
-	u32 pg_host_opaque;
-#if defined(__BIG_ENDIAN)
-	u16 status;
-	u16 reserved1;
-#elif defined(__LITTLE_ENDIAN)
-	u16 reserved1;
-	u16 status;
-#endif
-	u32 reserved2[2];
-#if defined(__BIG_ENDIAN)
-	u8 flags;
-#define L4_KCQ_RESERVED3 (0x7<<0)
-#define L4_KCQ_RESERVED3_SHIFT 0
-#define L4_KCQ_RAMROD_COMPLETION (0x1<<3) /* Everest only */
-#define L4_KCQ_RAMROD_COMPLETION_SHIFT 3
-#define L4_KCQ_LAYER_CODE (0x7<<4)
-#define L4_KCQ_LAYER_CODE_SHIFT 4
-#define L4_KCQ_RESERVED4 (0x1<<7)
-#define L4_KCQ_RESERVED4_SHIFT 7
-	u8 op_code;
-	u16 qe_self_seq;
-#elif defined(__LITTLE_ENDIAN)
-	u16 qe_self_seq;
-	u8 op_code;
-	u8 flags;
-#define L4_KCQ_RESERVED3 (0xF<<0)
-#define L4_KCQ_RESERVED3_SHIFT 0
-#define L4_KCQ_RAMROD_COMPLETION (0x1<<3) /* Everest only */
-#define L4_KCQ_RAMROD_COMPLETION_SHIFT 3
-#define L4_KCQ_LAYER_CODE (0x7<<4)
-#define L4_KCQ_LAYER_CODE_SHIFT 4
-#define L4_KCQ_RESERVED4 (0x1<<7)
-#define L4_KCQ_RESERVED4_SHIFT 7
-#endif
-};
-
-
-/*
- * L4 KCQ CQE PG upload
- */
-struct l4_kcq_upload_pg {
-	u32 pg_cid;
-#if defined(__BIG_ENDIAN)
-	u16 pg_status;
-	u16 pg_ipid_count;
-#elif defined(__LITTLE_ENDIAN)
-	u16 pg_ipid_count;
-	u16 pg_status;
-#endif
-	u32 reserved1[5];
-#if defined(__BIG_ENDIAN)
-	u8 flags;
-#define L4_KCQ_UPLOAD_PG_RESERVED3 (0xF<<0)
-#define L4_KCQ_UPLOAD_PG_RESERVED3_SHIFT 0
-#define L4_KCQ_UPLOAD_PG_LAYER_CODE (0x7<<4)
-#define L4_KCQ_UPLOAD_PG_LAYER_CODE_SHIFT 4
-#define L4_KCQ_UPLOAD_PG_RESERVED4 (0x1<<7)
-#define L4_KCQ_UPLOAD_PG_RESERVED4_SHIFT 7
-	u8 op_code;
-	u16 qe_self_seq;
-#elif defined(__LITTLE_ENDIAN)
-	u16 qe_self_seq;
-	u8 op_code;
-	u8 flags;
-#define L4_KCQ_UPLOAD_PG_RESERVED3 (0xF<<0)
-#define L4_KCQ_UPLOAD_PG_RESERVED3_SHIFT 0
-#define L4_KCQ_UPLOAD_PG_LAYER_CODE (0x7<<4)
-#define L4_KCQ_UPLOAD_PG_LAYER_CODE_SHIFT 4
-#define L4_KCQ_UPLOAD_PG_RESERVED4 (0x1<<7)
-#define L4_KCQ_UPLOAD_PG_RESERVED4_SHIFT 7
-#endif
-};
-
-
-/*
- * Gracefully close the connection request
- */
-struct l4_kwq_close_req {
-#if defined(__BIG_ENDIAN)
-	u8 flags;
-#define L4_KWQ_CLOSE_REQ_RESERVED1 (0xF<<0)
-#define L4_KWQ_CLOSE_REQ_RESERVED1_SHIFT 0
-#define L4_KWQ_CLOSE_REQ_LAYER_CODE (0x7<<4)
-#define L4_KWQ_CLOSE_REQ_LAYER_CODE_SHIFT 4
-#define L4_KWQ_CLOSE_REQ_LINKED_WITH_NEXT (0x1<<7)
-#define L4_KWQ_CLOSE_REQ_LINKED_WITH_NEXT_SHIFT 7
-	u8 op_code;
-	u16 reserved0;
-#elif defined(__LITTLE_ENDIAN)
-	u16 reserved0;
-	u8 op_code;
-	u8 flags;
-#define L4_KWQ_CLOSE_REQ_RESERVED1 (0xF<<0)
-#define L4_KWQ_CLOSE_REQ_RESERVED1_SHIFT 0
-#define L4_KWQ_CLOSE_REQ_LAYER_CODE (0x7<<4)
-#define L4_KWQ_CLOSE_REQ_LAYER_CODE_SHIFT 4
-#define L4_KWQ_CLOSE_REQ_LINKED_WITH_NEXT (0x1<<7)
-#define L4_KWQ_CLOSE_REQ_LINKED_WITH_NEXT_SHIFT 7
-#endif
-	u32 cid;
-	u32 reserved2[6];
-};
-
-
-/*
- * The first request to be passed in order to establish connection in option2
- */
-struct l4_kwq_connect_req1 {
-#if defined(__BIG_ENDIAN)
-	u8 flags;
-#define L4_KWQ_CONNECT_REQ1_RESERVED1 (0xF<<0)
-#define L4_KWQ_CONNECT_REQ1_RESERVED1_SHIFT 0
-#define L4_KWQ_CONNECT_REQ1_LAYER_CODE (0x7<<4)
-#define L4_KWQ_CONNECT_REQ1_LAYER_CODE_SHIFT 4
-#define L4_KWQ_CONNECT_REQ1_LINKED_WITH_NEXT (0x1<<7)
-#define L4_KWQ_CONNECT_REQ1_LINKED_WITH_NEXT_SHIFT 7
-	u8 op_code;
-	u8 reserved0;
-	u8 conn_flags;
-#define L4_KWQ_CONNECT_REQ1_IS_PG_HOST_OPAQUE (0x1<<0)
-#define L4_KWQ_CONNECT_REQ1_IS_PG_HOST_OPAQUE_SHIFT 0
-#define L4_KWQ_CONNECT_REQ1_IP_V6 (0x1<<1)
-#define L4_KWQ_CONNECT_REQ1_IP_V6_SHIFT 1
-#define L4_KWQ_CONNECT_REQ1_PASSIVE_FLAG (0x1<<2)
-#define L4_KWQ_CONNECT_REQ1_PASSIVE_FLAG_SHIFT 2
-#define L4_KWQ_CONNECT_REQ1_RSRV (0x1F<<3)
-#define L4_KWQ_CONNECT_REQ1_RSRV_SHIFT 3
-#elif defined(__LITTLE_ENDIAN)
-	u8 conn_flags;
-#define L4_KWQ_CONNECT_REQ1_IS_PG_HOST_OPAQUE (0x1<<0)
-#define L4_KWQ_CONNECT_REQ1_IS_PG_HOST_OPAQUE_SHIFT 0
-#define L4_KWQ_CONNECT_REQ1_IP_V6 (0x1<<1)
-#define L4_KWQ_CONNECT_REQ1_IP_V6_SHIFT 1
-#define L4_KWQ_CONNECT_REQ1_PASSIVE_FLAG (0x1<<2)
-#define L4_KWQ_CONNECT_REQ1_PASSIVE_FLAG_SHIFT 2
-#define L4_KWQ_CONNECT_REQ1_RSRV (0x1F<<3)
-#define L4_KWQ_CONNECT_REQ1_RSRV_SHIFT 3
-	u8 reserved0;
-	u8 op_code;
-	u8 flags;
-#define L4_KWQ_CONNECT_REQ1_RESERVED1 (0xF<<0)
-#define L4_KWQ_CONNECT_REQ1_RESERVED1_SHIFT 0
-#define L4_KWQ_CONNECT_REQ1_LAYER_CODE (0x7<<4)
-#define L4_KWQ_CONNECT_REQ1_LAYER_CODE_SHIFT 4
-#define L4_KWQ_CONNECT_REQ1_LINKED_WITH_NEXT (0x1<<7)
-#define L4_KWQ_CONNECT_REQ1_LINKED_WITH_NEXT_SHIFT 7
-#endif
-	u32 cid;
-	u32 pg_cid;
-	u32 src_ip;
-	u32 dst_ip;
-#if defined(__BIG_ENDIAN)
-	u16 dst_port;
-	u16 src_port;
-#elif defined(__LITTLE_ENDIAN)
-	u16 src_port;
-	u16 dst_port;
-#endif
-#if defined(__BIG_ENDIAN)
-	u8 rsrv1[3];
-	u8 tcp_flags;
-#define L4_KWQ_CONNECT_REQ1_NO_DELAY_ACK (0x1<<0)
-#define L4_KWQ_CONNECT_REQ1_NO_DELAY_ACK_SHIFT 0
-#define L4_KWQ_CONNECT_REQ1_KEEP_ALIVE (0x1<<1)
-#define L4_KWQ_CONNECT_REQ1_KEEP_ALIVE_SHIFT 1
-#define L4_KWQ_CONNECT_REQ1_NAGLE_ENABLE (0x1<<2)
-#define L4_KWQ_CONNECT_REQ1_NAGLE_ENABLE_SHIFT 2
-#define L4_KWQ_CONNECT_REQ1_TIME_STAMP (0x1<<3)
-#define L4_KWQ_CONNECT_REQ1_TIME_STAMP_SHIFT 3
-#define L4_KWQ_CONNECT_REQ1_SACK (0x1<<4)
-#define L4_KWQ_CONNECT_REQ1_SACK_SHIFT 4
-#define L4_KWQ_CONNECT_REQ1_SEG_SCALING (0x1<<5)
-#define L4_KWQ_CONNECT_REQ1_SEG_SCALING_SHIFT 5
-#define L4_KWQ_CONNECT_REQ1_RESERVED2 (0x3<<6)
-#define L4_KWQ_CONNECT_REQ1_RESERVED2_SHIFT 6
-#elif defined(__LITTLE_ENDIAN)
-	u8 tcp_flags;
-#define L4_KWQ_CONNECT_REQ1_NO_DELAY_ACK (0x1<<0)
-#define L4_KWQ_CONNECT_REQ1_NO_DELAY_ACK_SHIFT 0
-#define L4_KWQ_CONNECT_REQ1_KEEP_ALIVE (0x1<<1)
-#define L4_KWQ_CONNECT_REQ1_KEEP_ALIVE_SHIFT 1
-#define L4_KWQ_CONNECT_REQ1_NAGLE_ENABLE (0x1<<2)
-#define L4_KWQ_CONNECT_REQ1_NAGLE_ENABLE_SHIFT 2
-#define L4_KWQ_CONNECT_REQ1_TIME_STAMP (0x1<<3)
-#define L4_KWQ_CONNECT_REQ1_TIME_STAMP_SHIFT 3
-#define L4_KWQ_CONNECT_REQ1_SACK (0x1<<4)
-#define L4_KWQ_CONNECT_REQ1_SACK_SHIFT 4
-#define L4_KWQ_CONNECT_REQ1_SEG_SCALING (0x1<<5)
-#define L4_KWQ_CONNECT_REQ1_SEG_SCALING_SHIFT 5
-#define L4_KWQ_CONNECT_REQ1_RESERVED2 (0x3<<6)
-#define L4_KWQ_CONNECT_REQ1_RESERVED2_SHIFT 6
-	u8 rsrv1[3];
-#endif
-	u32 rsrv2;
-};
-
-
-/*
- * The second ( optional )request to be passed in order to establish
- * connection in option2 - for IPv6 only
- */
-struct l4_kwq_connect_req2 {
-#if defined(__BIG_ENDIAN)
-	u8 flags;
-#define L4_KWQ_CONNECT_REQ2_RESERVED1 (0xF<<0)
-#define L4_KWQ_CONNECT_REQ2_RESERVED1_SHIFT 0
-#define L4_KWQ_CONNECT_REQ2_LAYER_CODE (0x7<<4)
-#define L4_KWQ_CONNECT_REQ2_LAYER_CODE_SHIFT 4
-#define L4_KWQ_CONNECT_REQ2_LINKED_WITH_NEXT (0x1<<7)
-#define L4_KWQ_CONNECT_REQ2_LINKED_WITH_NEXT_SHIFT 7
-	u8 op_code;
-	u8 reserved0;
-	u8 rsrv;
-#elif defined(__LITTLE_ENDIAN)
-	u8 rsrv;
-	u8 reserved0;
-	u8 op_code;
-	u8 flags;
-#define L4_KWQ_CONNECT_REQ2_RESERVED1 (0xF<<0)
-#define L4_KWQ_CONNECT_REQ2_RESERVED1_SHIFT 0
-#define L4_KWQ_CONNECT_REQ2_LAYER_CODE (0x7<<4)
-#define L4_KWQ_CONNECT_REQ2_LAYER_CODE_SHIFT 4
-#define L4_KWQ_CONNECT_REQ2_LINKED_WITH_NEXT (0x1<<7)
-#define L4_KWQ_CONNECT_REQ2_LINKED_WITH_NEXT_SHIFT 7
-#endif
-	u32 reserved2;
-	u32 src_ip_v6_2;
-	u32 src_ip_v6_3;
-	u32 src_ip_v6_4;
-	u32 dst_ip_v6_2;
-	u32 dst_ip_v6_3;
-	u32 dst_ip_v6_4;
-};
-
-
-/*
- * The third ( and last )request to be passed in order to establish
- * connection in option2
- */
-struct l4_kwq_connect_req3 {
-#if defined(__BIG_ENDIAN)
-	u8 flags;
-#define L4_KWQ_CONNECT_REQ3_RESERVED1 (0xF<<0)
-#define L4_KWQ_CONNECT_REQ3_RESERVED1_SHIFT 0
-#define L4_KWQ_CONNECT_REQ3_LAYER_CODE (0x7<<4)
-#define L4_KWQ_CONNECT_REQ3_LAYER_CODE_SHIFT 4
-#define L4_KWQ_CONNECT_REQ3_LINKED_WITH_NEXT (0x1<<7)
-#define L4_KWQ_CONNECT_REQ3_LINKED_WITH_NEXT_SHIFT 7
-	u8 op_code;
-	u16 reserved0;
-#elif defined(__LITTLE_ENDIAN)
-	u16 reserved0;
-	u8 op_code;
-	u8 flags;
-#define L4_KWQ_CONNECT_REQ3_RESERVED1 (0xF<<0)
-#define L4_KWQ_CONNECT_REQ3_RESERVED1_SHIFT 0
-#define L4_KWQ_CONNECT_REQ3_LAYER_CODE (0x7<<4)
-#define L4_KWQ_CONNECT_REQ3_LAYER_CODE_SHIFT 4
-#define L4_KWQ_CONNECT_REQ3_LINKED_WITH_NEXT (0x1<<7)
-#define L4_KWQ_CONNECT_REQ3_LINKED_WITH_NEXT_SHIFT 7
-#endif
-	u32 ka_timeout;
-	u32 ka_interval ;
-#if defined(__BIG_ENDIAN)
-	u8 snd_seq_scale;
-	u8 ttl;
-	u8 tos;
-	u8 ka_max_probe_count;
-#elif defined(__LITTLE_ENDIAN)
-	u8 ka_max_probe_count;
-	u8 tos;
-	u8 ttl;
-	u8 snd_seq_scale;
-#endif
-#if defined(__BIG_ENDIAN)
-	u16 pmtu;
-	u16 mss;
-#elif defined(__LITTLE_ENDIAN)
-	u16 mss;
-	u16 pmtu;
-#endif
-	u32 rcv_buf;
-	u32 snd_buf;
-	u32 seed;
-};
-
-
-/*
- * a KWQE request to offload a PG connection
- */
-struct l4_kwq_offload_pg {
-#if defined(__BIG_ENDIAN)
-	u8 flags;
-#define L4_KWQ_OFFLOAD_PG_RESERVED1 (0xF<<0)
-#define L4_KWQ_OFFLOAD_PG_RESERVED1_SHIFT 0
-#define L4_KWQ_OFFLOAD_PG_LAYER_CODE (0x7<<4)
-#define L4_KWQ_OFFLOAD_PG_LAYER_CODE_SHIFT 4
-#define L4_KWQ_OFFLOAD_PG_LINKED_WITH_NEXT (0x1<<7)
-#define L4_KWQ_OFFLOAD_PG_LINKED_WITH_NEXT_SHIFT 7
-	u8 op_code;
-	u16 reserved0;
-#elif defined(__LITTLE_ENDIAN)
-	u16 reserved0;
-	u8 op_code;
-	u8 flags;
-#define L4_KWQ_OFFLOAD_PG_RESERVED1 (0xF<<0)
-#define L4_KWQ_OFFLOAD_PG_RESERVED1_SHIFT 0
-#define L4_KWQ_OFFLOAD_PG_LAYER_CODE (0x7<<4)
-#define L4_KWQ_OFFLOAD_PG_LAYER_CODE_SHIFT 4
-#define L4_KWQ_OFFLOAD_PG_LINKED_WITH_NEXT (0x1<<7)
-#define L4_KWQ_OFFLOAD_PG_LINKED_WITH_NEXT_SHIFT 7
-#endif
-#if defined(__BIG_ENDIAN)
-	u8 l2hdr_nbytes;
-	u8 pg_flags;
-#define L4_KWQ_OFFLOAD_PG_SNAP_ENCAP (0x1<<0)
-#define L4_KWQ_OFFLOAD_PG_SNAP_ENCAP_SHIFT 0
-#define L4_KWQ_OFFLOAD_PG_VLAN_TAGGING (0x1<<1)
-#define L4_KWQ_OFFLOAD_PG_VLAN_TAGGING_SHIFT 1
-#define L4_KWQ_OFFLOAD_PG_RESERVED2 (0x3F<<2)
-#define L4_KWQ_OFFLOAD_PG_RESERVED2_SHIFT 2
-	u8 da0;
-	u8 da1;
-#elif defined(__LITTLE_ENDIAN)
-	u8 da1;
-	u8 da0;
-	u8 pg_flags;
-#define L4_KWQ_OFFLOAD_PG_SNAP_ENCAP (0x1<<0)
-#define L4_KWQ_OFFLOAD_PG_SNAP_ENCAP_SHIFT 0
-#define L4_KWQ_OFFLOAD_PG_VLAN_TAGGING (0x1<<1)
-#define L4_KWQ_OFFLOAD_PG_VLAN_TAGGING_SHIFT 1
-#define L4_KWQ_OFFLOAD_PG_RESERVED2 (0x3F<<2)
-#define L4_KWQ_OFFLOAD_PG_RESERVED2_SHIFT 2
-	u8 l2hdr_nbytes;
-#endif
-#if defined(__BIG_ENDIAN)
-	u8 da2;
-	u8 da3;
-	u8 da4;
-	u8 da5;
-#elif defined(__LITTLE_ENDIAN)
-	u8 da5;
-	u8 da4;
-	u8 da3;
-	u8 da2;
-#endif
-#if defined(__BIG_ENDIAN)
-	u8 sa0;
-	u8 sa1;
-	u8 sa2;
-	u8 sa3;
-#elif defined(__LITTLE_ENDIAN)
-	u8 sa3;
-	u8 sa2;
-	u8 sa1;
-	u8 sa0;
-#endif
-#if defined(__BIG_ENDIAN)
-	u8 sa4;
-	u8 sa5;
-	u16 etype;
-#elif defined(__LITTLE_ENDIAN)
-	u16 etype;
-	u8 sa5;
-	u8 sa4;
-#endif
-#if defined(__BIG_ENDIAN)
-	u16 vlan_tag;
-	u16 ipid_start;
-#elif defined(__LITTLE_ENDIAN)
-	u16 ipid_start;
-	u16 vlan_tag;
-#endif
-#if defined(__BIG_ENDIAN)
-	u16 ipid_count;
-	u16 reserved3;
-#elif defined(__LITTLE_ENDIAN)
-	u16 reserved3;
-	u16 ipid_count;
-#endif
-	u32 host_opaque;
-};
-
-
-/*
- * Abortively close the connection request
- */
-struct l4_kwq_reset_req {
-#if defined(__BIG_ENDIAN)
-	u8 flags;
-#define L4_KWQ_RESET_REQ_RESERVED1 (0xF<<0)
-#define L4_KWQ_RESET_REQ_RESERVED1_SHIFT 0
-#define L4_KWQ_RESET_REQ_LAYER_CODE (0x7<<4)
-#define L4_KWQ_RESET_REQ_LAYER_CODE_SHIFT 4
-#define L4_KWQ_RESET_REQ_LINKED_WITH_NEXT (0x1<<7)
-#define L4_KWQ_RESET_REQ_LINKED_WITH_NEXT_SHIFT 7
-	u8 op_code;
-	u16 reserved0;
-#elif defined(__LITTLE_ENDIAN)
-	u16 reserved0;
-	u8 op_code;
-	u8 flags;
-#define L4_KWQ_RESET_REQ_RESERVED1 (0xF<<0)
-#define L4_KWQ_RESET_REQ_RESERVED1_SHIFT 0
-#define L4_KWQ_RESET_REQ_LAYER_CODE (0x7<<4)
-#define L4_KWQ_RESET_REQ_LAYER_CODE_SHIFT 4
-#define L4_KWQ_RESET_REQ_LINKED_WITH_NEXT (0x1<<7)
-#define L4_KWQ_RESET_REQ_LINKED_WITH_NEXT_SHIFT 7
-#endif
-	u32 cid;
-	u32 reserved2[6];
-};
-
-
-/*
- * a KWQE request to update a PG connection
- */
-struct l4_kwq_update_pg {
-#if defined(__BIG_ENDIAN)
-	u8 flags;
-#define L4_KWQ_UPDATE_PG_RESERVED1 (0xF<<0)
-#define L4_KWQ_UPDATE_PG_RESERVED1_SHIFT 0
-#define L4_KWQ_UPDATE_PG_LAYER_CODE (0x7<<4)
-#define L4_KWQ_UPDATE_PG_LAYER_CODE_SHIFT 4
-#define L4_KWQ_UPDATE_PG_LINKED_WITH_NEXT (0x1<<7)
-#define L4_KWQ_UPDATE_PG_LINKED_WITH_NEXT_SHIFT 7
-	u8 opcode;
-	u16 oper16;
-#elif defined(__LITTLE_ENDIAN)
-	u16 oper16;
-	u8 opcode;
-	u8 flags;
-#define L4_KWQ_UPDATE_PG_RESERVED1 (0xF<<0)
-#define L4_KWQ_UPDATE_PG_RESERVED1_SHIFT 0
-#define L4_KWQ_UPDATE_PG_LAYER_CODE (0x7<<4)
-#define L4_KWQ_UPDATE_PG_LAYER_CODE_SHIFT 4
-#define L4_KWQ_UPDATE_PG_LINKED_WITH_NEXT (0x1<<7)
-#define L4_KWQ_UPDATE_PG_LINKED_WITH_NEXT_SHIFT 7
-#endif
-	u32 pg_cid;
-	u32 pg_host_opaque;
-#if defined(__BIG_ENDIAN)
-	u8 pg_valids;
-#define L4_KWQ_UPDATE_PG_VALIDS_IPID_COUNT (0x1<<0)
-#define L4_KWQ_UPDATE_PG_VALIDS_IPID_COUNT_SHIFT 0
-#define L4_KWQ_UPDATE_PG_VALIDS_DA (0x1<<1)
-#define L4_KWQ_UPDATE_PG_VALIDS_DA_SHIFT 1
-#define L4_KWQ_UPDATE_PG_RESERVERD2 (0x3F<<2)
-#define L4_KWQ_UPDATE_PG_RESERVERD2_SHIFT 2
-	u8 pg_unused_a;
-	u16 pg_ipid_count;
-#elif defined(__LITTLE_ENDIAN)
-	u16 pg_ipid_count;
-	u8 pg_unused_a;
-	u8 pg_valids;
-#define L4_KWQ_UPDATE_PG_VALIDS_IPID_COUNT (0x1<<0)
-#define L4_KWQ_UPDATE_PG_VALIDS_IPID_COUNT_SHIFT 0
-#define L4_KWQ_UPDATE_PG_VALIDS_DA (0x1<<1)
-#define L4_KWQ_UPDATE_PG_VALIDS_DA_SHIFT 1
-#define L4_KWQ_UPDATE_PG_RESERVERD2 (0x3F<<2)
-#define L4_KWQ_UPDATE_PG_RESERVERD2_SHIFT 2
-#endif
-#if defined(__BIG_ENDIAN)
-	u16 reserverd3;
-	u8 da0;
-	u8 da1;
-#elif defined(__LITTLE_ENDIAN)
-	u8 da1;
-	u8 da0;
-	u16 reserverd3;
-#endif
-#if defined(__BIG_ENDIAN)
-	u8 da2;
-	u8 da3;
-	u8 da4;
-	u8 da5;
-#elif defined(__LITTLE_ENDIAN)
-	u8 da5;
-	u8 da4;
-	u8 da3;
-	u8 da2;
-#endif
-	u32 reserved4;
-	u32 reserved5;
-};
-
-
-/*
- * a KWQE request to upload a PG or L4 context
- */
-struct l4_kwq_upload {
-#if defined(__BIG_ENDIAN)
-	u8 flags;
-#define L4_KWQ_UPLOAD_RESERVED1 (0xF<<0)
-#define L4_KWQ_UPLOAD_RESERVED1_SHIFT 0
-#define L4_KWQ_UPLOAD_LAYER_CODE (0x7<<4)
-#define L4_KWQ_UPLOAD_LAYER_CODE_SHIFT 4
-#define L4_KWQ_UPLOAD_LINKED_WITH_NEXT (0x1<<7)
-#define L4_KWQ_UPLOAD_LINKED_WITH_NEXT_SHIFT 7
-	u8 opcode;
-	u16 oper16;
-#elif defined(__LITTLE_ENDIAN)
-	u16 oper16;
-	u8 opcode;
-	u8 flags;
-#define L4_KWQ_UPLOAD_RESERVED1 (0xF<<0)
-#define L4_KWQ_UPLOAD_RESERVED1_SHIFT 0
-#define L4_KWQ_UPLOAD_LAYER_CODE (0x7<<4)
-#define L4_KWQ_UPLOAD_LAYER_CODE_SHIFT 4
-#define L4_KWQ_UPLOAD_LINKED_WITH_NEXT (0x1<<7)
-#define L4_KWQ_UPLOAD_LINKED_WITH_NEXT_SHIFT 7
-#endif
-	u32 cid;
-	u32 reserved2[6];
-};
-
-/*
- * bnx2x structures
- */
-
-/*
- * iSCSI context region, used only in iSCSI
- */
-struct ustorm_iscsi_rq_db {
-	struct regpair pbl_base;
-	struct regpair curr_pbe;
-};
-
-/*
- * iSCSI context region, used only in iSCSI
- */
-struct ustorm_iscsi_r2tq_db {
-	struct regpair pbl_base;
-	struct regpair curr_pbe;
-};
-
-/*
- * iSCSI context region, used only in iSCSI
- */
-struct ustorm_iscsi_cq_db {
-#if defined(__BIG_ENDIAN)
-	u16 cq_sn;
-	u16 prod;
-#elif defined(__LITTLE_ENDIAN)
-	u16 prod;
-	u16 cq_sn;
-#endif
-	struct regpair curr_pbe;
-};
-
-/*
- * iSCSI context region, used only in iSCSI
- */
-struct rings_db {
-	struct ustorm_iscsi_rq_db rq;
-	struct ustorm_iscsi_r2tq_db r2tq;
-	struct ustorm_iscsi_cq_db cq[8];
-#if defined(__BIG_ENDIAN)
-	u16 rq_prod;
-	u16 r2tq_prod;
-#elif defined(__LITTLE_ENDIAN)
-	u16 r2tq_prod;
-	u16 rq_prod;
-#endif
-	struct regpair cq_pbl_base;
-};
-
-/*
- * iSCSI context region, used only in iSCSI
- */
-struct ustorm_iscsi_placement_db {
-	u32 sgl_base_lo;
-	u32 sgl_base_hi;
-	u32 local_sge_0_address_hi;
-	u32 local_sge_0_address_lo;
-#if defined(__BIG_ENDIAN)
-	u16 curr_sge_offset;
-	u16 local_sge_0_size;
-#elif defined(__LITTLE_ENDIAN)
-	u16 local_sge_0_size;
-	u16 curr_sge_offset;
-#endif
-	u32 local_sge_1_address_hi;
-	u32 local_sge_1_address_lo;
-#if defined(__BIG_ENDIAN)
-	u16 reserved6;
-	u16 local_sge_1_size;
-#elif defined(__LITTLE_ENDIAN)
-	u16 local_sge_1_size;
-	u16 reserved6;
-#endif
-#if defined(__BIG_ENDIAN)
-	u8 sgl_size;
-	u8 local_sge_index_2b;
-	u16 reserved7;
-#elif defined(__LITTLE_ENDIAN)
-	u16 reserved7;
-	u8 local_sge_index_2b;
-	u8 sgl_size;
-#endif
-	u32 rem_pdu;
-	u32 place_db_bitfield_1;
-#define USTORM_ISCSI_PLACEMENT_DB_REM_PDU_PAYLOAD (0xFFFFFF<<0)
-#define USTORM_ISCSI_PLACEMENT_DB_REM_PDU_PAYLOAD_SHIFT 0
-#define USTORM_ISCSI_PLACEMENT_DB_CQ_ID (0xFF<<24)
-#define USTORM_ISCSI_PLACEMENT_DB_CQ_ID_SHIFT 24
-	u32 place_db_bitfield_2;
-#define USTORM_ISCSI_PLACEMENT_DB_BYTES_2_TRUNCATE (0xFFFFFF<<0)
-#define USTORM_ISCSI_PLACEMENT_DB_BYTES_2_TRUNCATE_SHIFT 0
-#define USTORM_ISCSI_PLACEMENT_DB_HOST_SGE_INDEX (0xFF<<24)
-#define USTORM_ISCSI_PLACEMENT_DB_HOST_SGE_INDEX_SHIFT 24
-	u32 nal;
-#define USTORM_ISCSI_PLACEMENT_DB_REM_SGE_SIZE (0xFFFFFF<<0)
-#define USTORM_ISCSI_PLACEMENT_DB_REM_SGE_SIZE_SHIFT 0
-#define USTORM_ISCSI_PLACEMENT_DB_EXP_PADDING_2B (0x3<<24)
-#define USTORM_ISCSI_PLACEMENT_DB_EXP_PADDING_2B_SHIFT 24
-#define USTORM_ISCSI_PLACEMENT_DB_EXP_DIGEST_3B (0x7<<26)
-#define USTORM_ISCSI_PLACEMENT_DB_EXP_DIGEST_3B_SHIFT 26
-#define USTORM_ISCSI_PLACEMENT_DB_NAL_LEN_3B (0x7<<29)
-#define USTORM_ISCSI_PLACEMENT_DB_NAL_LEN_3B_SHIFT 29
-};
-
-/*
- * Ustorm iSCSI Storm Context
- */
-struct ustorm_iscsi_st_context {
-	u32 exp_stat_sn;
-	u32 exp_data_sn;
-	struct rings_db ring;
-	struct regpair task_pbl_base;
-	struct regpair tce_phy_addr;
-	struct ustorm_iscsi_placement_db place_db;
-	u32 data_rcv_seq;
-	u32 rem_rcv_len;
-#if defined(__BIG_ENDIAN)
-	u16 hdr_itt;
-	u16 iscsi_conn_id;
-#elif defined(__LITTLE_ENDIAN)
-	u16 iscsi_conn_id;
-	u16 hdr_itt;
-#endif
-	u32 nal_bytes;
-#if defined(__BIG_ENDIAN)
-	u8 hdr_second_byte_union;
-	u8 bitfield_0;
-#define USTORM_ISCSI_ST_CONTEXT_BMIDDLEOFPDU (0x1<<0)
-#define USTORM_ISCSI_ST_CONTEXT_BMIDDLEOFPDU_SHIFT 0
-#define USTORM_ISCSI_ST_CONTEXT_BFENCECQE (0x1<<1)
-#define USTORM_ISCSI_ST_CONTEXT_BFENCECQE_SHIFT 1
-#define USTORM_ISCSI_ST_CONTEXT_RESERVED1 (0x3F<<2)
-#define USTORM_ISCSI_ST_CONTEXT_RESERVED1_SHIFT 2
-	u8 task_pdu_cache_index;
-	u8 task_pbe_cache_index;
-#elif defined(__LITTLE_ENDIAN)
-	u8 task_pbe_cache_index;
-	u8 task_pdu_cache_index;
-	u8 bitfield_0;
-#define USTORM_ISCSI_ST_CONTEXT_BMIDDLEOFPDU (0x1<<0)
-#define USTORM_ISCSI_ST_CONTEXT_BMIDDLEOFPDU_SHIFT 0
-#define USTORM_ISCSI_ST_CONTEXT_BFENCECQE (0x1<<1)
-#define USTORM_ISCSI_ST_CONTEXT_BFENCECQE_SHIFT 1
-#define USTORM_ISCSI_ST_CONTEXT_RESERVED1 (0x3F<<2)
-#define USTORM_ISCSI_ST_CONTEXT_RESERVED1_SHIFT 2
-	u8 hdr_second_byte_union;
-#endif
-#if defined(__BIG_ENDIAN)
-	u16 reserved3;
-	u8 reserved2;
-	u8 acDecrement;
-#elif defined(__LITTLE_ENDIAN)
-	u8 acDecrement;
-	u8 reserved2;
-	u16 reserved3;
-#endif
-	u32 task_stat;
-#if defined(__BIG_ENDIAN)
-	u8 hdr_opcode;
-	u8 num_cqs;
-	u16 reserved5;
-#elif defined(__LITTLE_ENDIAN)
-	u16 reserved5;
-	u8 num_cqs;
-	u8 hdr_opcode;
-#endif
-	u32 negotiated_rx;
-#define USTORM_ISCSI_ST_CONTEXT_MAX_RECV_PDU_LENGTH (0xFFFFFF<<0)
-#define USTORM_ISCSI_ST_CONTEXT_MAX_RECV_PDU_LENGTH_SHIFT 0
-#define USTORM_ISCSI_ST_CONTEXT_MAX_OUTSTANDING_R2TS (0xFF<<24)
-#define USTORM_ISCSI_ST_CONTEXT_MAX_OUTSTANDING_R2TS_SHIFT 24
-	u32 negotiated_rx_and_flags;
-#define USTORM_ISCSI_ST_CONTEXT_MAX_BURST_LENGTH (0xFFFFFF<<0)
-#define USTORM_ISCSI_ST_CONTEXT_MAX_BURST_LENGTH_SHIFT 0
-#define USTORM_ISCSI_ST_CONTEXT_B_CQE_POSTED_OR_HEADER_CACHED (0x1<<24)
-#define USTORM_ISCSI_ST_CONTEXT_B_CQE_POSTED_OR_HEADER_CACHED_SHIFT 24
-#define USTORM_ISCSI_ST_CONTEXT_B_HDR_DIGEST_EN (0x1<<25)
-#define USTORM_ISCSI_ST_CONTEXT_B_HDR_DIGEST_EN_SHIFT 25
-#define USTORM_ISCSI_ST_CONTEXT_B_DATA_DIGEST_EN (0x1<<26)
-#define USTORM_ISCSI_ST_CONTEXT_B_DATA_DIGEST_EN_SHIFT 26
-#define USTORM_ISCSI_ST_CONTEXT_B_PROTOCOL_ERROR (0x1<<27)
-#define USTORM_ISCSI_ST_CONTEXT_B_PROTOCOL_ERROR_SHIFT 27
-#define USTORM_ISCSI_ST_CONTEXT_B_TASK_VALID (0x1<<28)
-#define USTORM_ISCSI_ST_CONTEXT_B_TASK_VALID_SHIFT 28
-#define USTORM_ISCSI_ST_CONTEXT_TASK_TYPE (0x3<<29)
-#define USTORM_ISCSI_ST_CONTEXT_TASK_TYPE_SHIFT 29
-#define USTORM_ISCSI_ST_CONTEXT_B_ALL_DATA_ACKED (0x1<<31)
-#define USTORM_ISCSI_ST_CONTEXT_B_ALL_DATA_ACKED_SHIFT 31
-};
-
-/*
- * TCP context region, shared in TOE, RDMA and ISCSI
- */
-struct tstorm_tcp_st_context_section {
-	u32 flags1;
-#define TSTORM_TCP_ST_CONTEXT_SECTION_RTT_SRTT_20B (0xFFFFFF<<0)
-#define TSTORM_TCP_ST_CONTEXT_SECTION_RTT_SRTT_20B_SHIFT 0
-#define TSTORM_TCP_ST_CONTEXT_SECTION_PAWS_INVALID (0x1<<24)
-#define TSTORM_TCP_ST_CONTEXT_SECTION_PAWS_INVALID_SHIFT 24
-#define TSTORM_TCP_ST_CONTEXT_SECTION_TIMESTAMP_EXISTS (0x1<<25)
-#define TSTORM_TCP_ST_CONTEXT_SECTION_TIMESTAMP_EXISTS_SHIFT 25
-#define TSTORM_TCP_ST_CONTEXT_SECTION_ISLE_EXISTS (0x1<<26)
-#define TSTORM_TCP_ST_CONTEXT_SECTION_ISLE_EXISTS_SHIFT 26
-#define TSTORM_TCP_ST_CONTEXT_SECTION_STOP_RX_PAYLOAD (0x1<<27)
-#define TSTORM_TCP_ST_CONTEXT_SECTION_STOP_RX_PAYLOAD_SHIFT 27
-#define TSTORM_TCP_ST_CONTEXT_SECTION_KA_ENABLED (0x1<<28)
-#define TSTORM_TCP_ST_CONTEXT_SECTION_KA_ENABLED_SHIFT 28
-#define TSTORM_TCP_ST_CONTEXT_SECTION_FIRST_RTO_ESTIMATE (0x1<<29)
-#define TSTORM_TCP_ST_CONTEXT_SECTION_FIRST_RTO_ESTIMATE_SHIFT 29
-#define TSTORM_TCP_ST_CONTEXT_SECTION_MAX_SEG_RETRANSMIT_EN (0x1<<30)
-#define TSTORM_TCP_ST_CONTEXT_SECTION_MAX_SEG_RETRANSMIT_EN_SHIFT 30
-#define TSTORM_TCP_ST_CONTEXT_SECTION_RESERVED3 (0x1<<31)
-#define TSTORM_TCP_ST_CONTEXT_SECTION_RESERVED3_SHIFT 31
-	u32 flags2;
-#define TSTORM_TCP_ST_CONTEXT_SECTION_RTT_VARIATION_20B (0xFFFFFF<<0)
-#define TSTORM_TCP_ST_CONTEXT_SECTION_RTT_VARIATION_20B_SHIFT 0
-#define TSTORM_TCP_ST_CONTEXT_SECTION_DA_EN (0x1<<24)
-#define TSTORM_TCP_ST_CONTEXT_SECTION_DA_EN_SHIFT 24
-#define TSTORM_TCP_ST_CONTEXT_SECTION_DA_COUNTER_EN (0x1<<25)
-#define TSTORM_TCP_ST_CONTEXT_SECTION_DA_COUNTER_EN_SHIFT 25
-#define __TSTORM_TCP_ST_CONTEXT_SECTION_KA_PROBE_SENT (0x1<<26)
-#define __TSTORM_TCP_ST_CONTEXT_SECTION_KA_PROBE_SENT_SHIFT 26
-#define __TSTORM_TCP_ST_CONTEXT_SECTION_PERSIST_PROBE_SENT (0x1<<27)
-#define __TSTORM_TCP_ST_CONTEXT_SECTION_PERSIST_PROBE_SENT_SHIFT 27
-#define TSTORM_TCP_ST_CONTEXT_SECTION_UPDATE_L2_STATSTICS (0x1<<28)
-#define TSTORM_TCP_ST_CONTEXT_SECTION_UPDATE_L2_STATSTICS_SHIFT 28
-#define TSTORM_TCP_ST_CONTEXT_SECTION_UPDATE_L4_STATSTICS (0x1<<29)
-#define TSTORM_TCP_ST_CONTEXT_SECTION_UPDATE_L4_STATSTICS_SHIFT 29
-#define __TSTORM_TCP_ST_CONTEXT_SECTION_SECOND_ISLE_DROPPED (0x1<<30)
-#define __TSTORM_TCP_ST_CONTEXT_SECTION_SECOND_ISLE_DROPPED_SHIFT 30
-#define __TSTORM_TCP_ST_CONTEXT_SECTION_DONT_SUPPORT_OOO (0x1<<31)
-#define __TSTORM_TCP_ST_CONTEXT_SECTION_DONT_SUPPORT_OOO_SHIFT 31
-#if defined(__BIG_ENDIAN)
-	u16 reserved_slowpath;
-	u8 tcp_sm_state_3b;
-	u8 rto_exp_3b;
-#elif defined(__LITTLE_ENDIAN)
-	u8 rto_exp_3b;
-	u8 tcp_sm_state_3b;
-	u16 reserved_slowpath;
-#endif
-	u32 rcv_nxt;
-	u32 timestamp_recent;
-	u32 timestamp_recent_time;
-	u32 cwnd;
-	u32 ss_thresh;
-	u32 cwnd_accum;
-	u32 prev_seg_seq;
-	u32 expected_rel_seq;
-	u32 recover;
-#if defined(__BIG_ENDIAN)
-	u8 retransmit_count;
-	u8 ka_max_probe_count;
-	u8 persist_probe_count;
-	u8 ka_probe_count;
-#elif defined(__LITTLE_ENDIAN)
-	u8 ka_probe_count;
-	u8 persist_probe_count;
-	u8 ka_max_probe_count;
-	u8 retransmit_count;
-#endif
-#if defined(__BIG_ENDIAN)
-	u8 statistics_counter_id;
-	u8 ooo_support_mode;
-	u8 snd_wnd_scale_4b;
-	u8 dup_ack_count;
-#elif defined(__LITTLE_ENDIAN)
-	u8 dup_ack_count;
-	u8 snd_wnd_scale_4b;
-	u8 ooo_support_mode;
-	u8 statistics_counter_id;
-#endif
-	u32 retransmit_start_time;
-	u32 ka_timeout;
-	u32 ka_interval;
-	u32 isle_start_seq;
-	u32 isle_end_seq;
-#if defined(__BIG_ENDIAN)
-	u16 mss;
-	u16 recent_seg_wnd;
-#elif defined(__LITTLE_ENDIAN)
-	u16 recent_seg_wnd;
-	u16 mss;
-#endif
-	u32 reserved4;
-	u32 max_rt_time;
-#if defined(__BIG_ENDIAN)
-	u16 lsb_mac_address;
-	u16 vlan_id;
-#elif defined(__LITTLE_ENDIAN)
-	u16 vlan_id;
-	u16 lsb_mac_address;
-#endif
-	u32 msb_mac_address;
-	u32 reserved2;
-};
-
-/*
- * Termination variables
- */
-struct iscsi_term_vars {
-	u8 BitMap;
-#define ISCSI_TERM_VARS_TCP_STATE (0xF<<0)
-#define ISCSI_TERM_VARS_TCP_STATE_SHIFT 0
-#define ISCSI_TERM_VARS_FIN_RECEIVED_SBIT (0x1<<4)
-#define ISCSI_TERM_VARS_FIN_RECEIVED_SBIT_SHIFT 4
-#define ISCSI_TERM_VARS_ACK_ON_FIN_RECEIVED_SBIT (0x1<<5)
-#define ISCSI_TERM_VARS_ACK_ON_FIN_RECEIVED_SBIT_SHIFT 5
-#define ISCSI_TERM_VARS_TERM_ON_CHIP (0x1<<6)
-#define ISCSI_TERM_VARS_TERM_ON_CHIP_SHIFT 6
-#define ISCSI_TERM_VARS_RSRV (0x1<<7)
-#define ISCSI_TERM_VARS_RSRV_SHIFT 7
-};
-
-/*
- * iSCSI context region, used only in iSCSI
- */
-struct tstorm_iscsi_st_context_section {
-#if defined(__BIG_ENDIAN)
-	u16 rem_tcp_data_len;
-	u16 brb_offset;
-#elif defined(__LITTLE_ENDIAN)
-	u16 brb_offset;
-	u16 rem_tcp_data_len;
-#endif
-	u32 b2nh;
-#if defined(__BIG_ENDIAN)
-	u16 rq_cons;
-	u8 flags;
-#define TSTORM_ISCSI_ST_CONTEXT_SECTION_B_HDR_DIGEST_EN (0x1<<0)
-#define TSTORM_ISCSI_ST_CONTEXT_SECTION_B_HDR_DIGEST_EN_SHIFT 0
-#define TSTORM_ISCSI_ST_CONTEXT_SECTION_B_DATA_DIGEST_EN (0x1<<1)
-#define TSTORM_ISCSI_ST_CONTEXT_SECTION_B_DATA_DIGEST_EN_SHIFT 1
-#define TSTORM_ISCSI_ST_CONTEXT_SECTION_B_PARTIAL_HEADER (0x1<<2)
-#define TSTORM_ISCSI_ST_CONTEXT_SECTION_B_PARTIAL_HEADER_SHIFT 2
-#define TSTORM_ISCSI_ST_CONTEXT_SECTION_B_FULL_FEATURE (0x1<<3)
-#define TSTORM_ISCSI_ST_CONTEXT_SECTION_B_FULL_FEATURE_SHIFT 3
-#define TSTORM_ISCSI_ST_CONTEXT_SECTION_B_DROP_ALL_PDUS (0x1<<4)
-#define TSTORM_ISCSI_ST_CONTEXT_SECTION_B_DROP_ALL_PDUS_SHIFT 4
-#define TSTORM_ISCSI_ST_CONTEXT_SECTION_FLAGS_RSRV (0x7<<5)
-#define TSTORM_ISCSI_ST_CONTEXT_SECTION_FLAGS_RSRV_SHIFT 5
-	u8 hdr_bytes_2_fetch;
-#elif defined(__LITTLE_ENDIAN)
-	u8 hdr_bytes_2_fetch;
-	u8 flags;
-#define TSTORM_ISCSI_ST_CONTEXT_SECTION_B_HDR_DIGEST_EN (0x1<<0)
-#define TSTORM_ISCSI_ST_CONTEXT_SECTION_B_HDR_DIGEST_EN_SHIFT 0
-#define TSTORM_ISCSI_ST_CONTEXT_SECTION_B_DATA_DIGEST_EN (0x1<<1)
-#define TSTORM_ISCSI_ST_CONTEXT_SECTION_B_DATA_DIGEST_EN_SHIFT 1
-#define TSTORM_ISCSI_ST_CONTEXT_SECTION_B_PARTIAL_HEADER (0x1<<2)
-#define TSTORM_ISCSI_ST_CONTEXT_SECTION_B_PARTIAL_HEADER_SHIFT 2
-#define TSTORM_ISCSI_ST_CONTEXT_SECTION_B_FULL_FEATURE (0x1<<3)
-#define TSTORM_ISCSI_ST_CONTEXT_SECTION_B_FULL_FEATURE_SHIFT 3
-#define TSTORM_ISCSI_ST_CONTEXT_SECTION_B_DROP_ALL_PDUS (0x1<<4)
-#define TSTORM_ISCSI_ST_CONTEXT_SECTION_B_DROP_ALL_PDUS_SHIFT 4
-#define TSTORM_ISCSI_ST_CONTEXT_SECTION_FLAGS_RSRV (0x7<<5)
-#define TSTORM_ISCSI_ST_CONTEXT_SECTION_FLAGS_RSRV_SHIFT 5
-	u16 rq_cons;
-#endif
-	struct regpair rq_db_phy_addr;
-#if defined(__BIG_ENDIAN)
-	struct iscsi_term_vars term_vars;
-	u8 scratchpad_idx;
-	u16 iscsi_conn_id;
-#elif defined(__LITTLE_ENDIAN)
-	u16 iscsi_conn_id;
-	u8 scratchpad_idx;
-	struct iscsi_term_vars term_vars;
-#endif
-	u32 reserved2;
-};
-
-/*
- * The iSCSI non-aggregative context of Tstorm
- */
-struct tstorm_iscsi_st_context {
-	struct tstorm_tcp_st_context_section tcp;
-	struct tstorm_iscsi_st_context_section iscsi;
-};
-
-/*
- * The tcp aggregative context section of Xstorm
- */
-struct xstorm_tcp_tcp_ag_context_section {
-#if defined(__BIG_ENDIAN)
-	u8 __tcp_agg_vars1;
-	u8 __da_cnt;
-	u16 mss;
-#elif defined(__LITTLE_ENDIAN)
-	u16 mss;
-	u8 __da_cnt;
-	u8 __tcp_agg_vars1;
-#endif
-	u32 snd_nxt;
-	u32 tx_wnd;
-	u32 snd_una;
-	u32 local_adv_wnd;
-#if defined(__BIG_ENDIAN)
-	u8 __agg_val8_th;
-	u8 __agg_val8;
-	u16 tcp_agg_vars2;
-#define XSTORM_TCP_TCP_AG_CONTEXT_SECTION_TX_FIN_FLAG (0x1<<0)
-#define XSTORM_TCP_TCP_AG_CONTEXT_SECTION_TX_FIN_FLAG_SHIFT 0
-#define __XSTORM_TCP_TCP_AG_CONTEXT_SECTION_TX_UNBLOCKED (0x1<<1)
-#define __XSTORM_TCP_TCP_AG_CONTEXT_SECTION_TX_UNBLOCKED_SHIFT 1
-#define __XSTORM_TCP_TCP_AG_CONTEXT_SECTION_DA_TIMER_ACTIVE (0x1<<2)
-#define __XSTORM_TCP_TCP_AG_CONTEXT_SECTION_DA_TIMER_ACTIVE_SHIFT 2
-#define __XSTORM_TCP_TCP_AG_CONTEXT_SECTION_AUX3_FLAG (0x1<<3)
-#define __XSTORM_TCP_TCP_AG_CONTEXT_SECTION_AUX3_FLAG_SHIFT 3
-#define __XSTORM_TCP_TCP_AG_CONTEXT_SECTION_AUX4_FLAG (0x1<<4)
-#define __XSTORM_TCP_TCP_AG_CONTEXT_SECTION_AUX4_FLAG_SHIFT 4
-#define XSTORM_TCP_TCP_AG_CONTEXT_SECTION_DA_ENABLE (0x1<<5)
-#define XSTORM_TCP_TCP_AG_CONTEXT_SECTION_DA_ENABLE_SHIFT 5
-#define __XSTORM_TCP_TCP_AG_CONTEXT_SECTION_ACK_TO_FE_UPDATED_EN (0x1<<6)
-#define __XSTORM_TCP_TCP_AG_CONTEXT_SECTION_ACK_TO_FE_UPDATED_EN_SHIFT 6
-#define __XSTORM_TCP_TCP_AG_CONTEXT_SECTION_AUX3_CF_EN (0x1<<7)
-#define __XSTORM_TCP_TCP_AG_CONTEXT_SECTION_AUX3_CF_EN_SHIFT 7
-#define __XSTORM_TCP_TCP_AG_CONTEXT_SECTION_TX_FIN_FLAG_EN (0x1<<8)
-#define __XSTORM_TCP_TCP_AG_CONTEXT_SECTION_TX_FIN_FLAG_EN_SHIFT 8
-#define __XSTORM_TCP_TCP_AG_CONTEXT_SECTION_AUX1_FLAG (0x1<<9)
-#define __XSTORM_TCP_TCP_AG_CONTEXT_SECTION_AUX1_FLAG_SHIFT 9
-#define __XSTORM_TCP_TCP_AG_CONTEXT_SECTION_SET_RTO_CF (0x3<<10)
-#define __XSTORM_TCP_TCP_AG_CONTEXT_SECTION_SET_RTO_CF_SHIFT 10
-#define __XSTORM_TCP_TCP_AG_CONTEXT_SECTION_TS_TO_ECHO_UPDATED_CF (0x3<<12)
-#define __XSTORM_TCP_TCP_AG_CONTEXT_SECTION_TS_TO_ECHO_UPDATED_CF_SHIFT 12
-#define __XSTORM_TCP_TCP_AG_CONTEXT_SECTION_AUX8_CF (0x3<<14)
-#define __XSTORM_TCP_TCP_AG_CONTEXT_SECTION_AUX8_CF_SHIFT 14
-#elif defined(__LITTLE_ENDIAN)
-	u16 tcp_agg_vars2;
-#define XSTORM_TCP_TCP_AG_CONTEXT_SECTION_TX_FIN_FLAG (0x1<<0)
-#define XSTORM_TCP_TCP_AG_CONTEXT_SECTION_TX_FIN_FLAG_SHIFT 0
-#define __XSTORM_TCP_TCP_AG_CONTEXT_SECTION_TX_UNBLOCKED (0x1<<1)
-#define __XSTORM_TCP_TCP_AG_CONTEXT_SECTION_TX_UNBLOCKED_SHIFT 1
-#define __XSTORM_TCP_TCP_AG_CONTEXT_SECTION_DA_TIMER_ACTIVE (0x1<<2)
-#define __XSTORM_TCP_TCP_AG_CONTEXT_SECTION_DA_TIMER_ACTIVE_SHIFT 2
-#define __XSTORM_TCP_TCP_AG_CONTEXT_SECTION_AUX3_FLAG (0x1<<3)
-#define __XSTORM_TCP_TCP_AG_CONTEXT_SECTION_AUX3_FLAG_SHIFT 3
-#define __XSTORM_TCP_TCP_AG_CONTEXT_SECTION_AUX4_FLAG (0x1<<4)
-#define __XSTORM_TCP_TCP_AG_CONTEXT_SECTION_AUX4_FLAG_SHIFT 4
-#define XSTORM_TCP_TCP_AG_CONTEXT_SECTION_DA_ENABLE (0x1<<5)
-#define XSTORM_TCP_TCP_AG_CONTEXT_SECTION_DA_ENABLE_SHIFT 5
-#define __XSTORM_TCP_TCP_AG_CONTEXT_SECTION_ACK_TO_FE_UPDATED_EN (0x1<<6)
-#define __XSTORM_TCP_TCP_AG_CONTEXT_SECTION_ACK_TO_FE_UPDATED_EN_SHIFT 6
-#define __XSTORM_TCP_TCP_AG_CONTEXT_SECTION_AUX3_CF_EN (0x1<<7)
-#define __XSTORM_TCP_TCP_AG_CONTEXT_SECTION_AUX3_CF_EN_SHIFT 7
-#define __XSTORM_TCP_TCP_AG_CONTEXT_SECTION_TX_FIN_FLAG_EN (0x1<<8)
-#define __XSTORM_TCP_TCP_AG_CONTEXT_SECTION_TX_FIN_FLAG_EN_SHIFT 8
-#define __XSTORM_TCP_TCP_AG_CONTEXT_SECTION_AUX1_FLAG (0x1<<9)
-#define __XSTORM_TCP_TCP_AG_CONTEXT_SECTION_AUX1_FLAG_SHIFT 9
-#define __XSTORM_TCP_TCP_AG_CONTEXT_SECTION_SET_RTO_CF (0x3<<10)
-#define __XSTORM_TCP_TCP_AG_CONTEXT_SECTION_SET_RTO_CF_SHIFT 10
-#define __XSTORM_TCP_TCP_AG_CONTEXT_SECTION_TS_TO_ECHO_UPDATED_CF (0x3<<12)
-#define __XSTORM_TCP_TCP_AG_CONTEXT_SECTION_TS_TO_ECHO_UPDATED_CF_SHIFT 12
-#define __XSTORM_TCP_TCP_AG_CONTEXT_SECTION_AUX8_CF (0x3<<14)
-#define __XSTORM_TCP_TCP_AG_CONTEXT_SECTION_AUX8_CF_SHIFT 14
-	u8 __agg_val8;
-	u8 __agg_val8_th;
-#endif
-	u32 ack_to_far_end;
-	u32 rto_timer;
-	u32 ka_timer;
-	u32 ts_to_echo;
-#if defined(__BIG_ENDIAN)
-	u16 __agg_val7_th;
-	u16 __agg_val7;
-#elif defined(__LITTLE_ENDIAN)
-	u16 __agg_val7;
-	u16 __agg_val7_th;
-#endif
-#if defined(__BIG_ENDIAN)
-	u8 __tcp_agg_vars5;
-	u8 __tcp_agg_vars4;
-	u8 __tcp_agg_vars3;
-	u8 __force_pure_ack_cnt;
-#elif defined(__LITTLE_ENDIAN)
-	u8 __force_pure_ack_cnt;
-	u8 __tcp_agg_vars3;
-	u8 __tcp_agg_vars4;
-	u8 __tcp_agg_vars5;
-#endif
-	u32 tcp_agg_vars6;
-#define __XSTORM_TCP_TCP_AG_CONTEXT_SECTION_TS_TO_ECHO_CF_EN (0x1<<0)
-#define __XSTORM_TCP_TCP_AG_CONTEXT_SECTION_TS_TO_ECHO_CF_EN_SHIFT 0
-#define __XSTORM_TCP_TCP_AG_CONTEXT_SECTION_AUX8_CF_EN (0x1<<1)
-#define __XSTORM_TCP_TCP_AG_CONTEXT_SECTION_AUX8_CF_EN_SHIFT 1
-#define __XSTORM_TCP_TCP_AG_CONTEXT_SECTION_AUX9_CF_EN (0x1<<2)
-#define __XSTORM_TCP_TCP_AG_CONTEXT_SECTION_AUX9_CF_EN_SHIFT 2
-#define __XSTORM_TCP_TCP_AG_CONTEXT_SECTION_AUX10_CF_EN (0x1<<3)
-#define __XSTORM_TCP_TCP_AG_CONTEXT_SECTION_AUX10_CF_EN_SHIFT 3
-#define __XSTORM_TCP_TCP_AG_CONTEXT_SECTION_AUX6_FLAG (0x1<<4)
-#define __XSTORM_TCP_TCP_AG_CONTEXT_SECTION_AUX6_FLAG_SHIFT 4
-#define __XSTORM_TCP_TCP_AG_CONTEXT_SECTION_AUX7_FLAG (0x1<<5)
-#define __XSTORM_TCP_TCP_AG_CONTEXT_SECTION_AUX7_FLAG_SHIFT 5
-#define __XSTORM_TCP_TCP_AG_CONTEXT_SECTION_AUX5_CF (0x3<<6)
-#define __XSTORM_TCP_TCP_AG_CONTEXT_SECTION_AUX5_CF_SHIFT 6
-#define __XSTORM_TCP_TCP_AG_CONTEXT_SECTION_AUX9_CF (0x3<<8)
-#define __XSTORM_TCP_TCP_AG_CONTEXT_SECTION_AUX9_CF_SHIFT 8
-#define __XSTORM_TCP_TCP_AG_CONTEXT_SECTION_AUX10_CF (0x3<<10)
-#define __XSTORM_TCP_TCP_AG_CONTEXT_SECTION_AUX10_CF_SHIFT 10
-#define __XSTORM_TCP_TCP_AG_CONTEXT_SECTION_AUX11_CF (0x3<<12)
-#define __XSTORM_TCP_TCP_AG_CONTEXT_SECTION_AUX11_CF_SHIFT 12
-#define __XSTORM_TCP_TCP_AG_CONTEXT_SECTION_AUX12_CF (0x3<<14)
-#define __XSTORM_TCP_TCP_AG_CONTEXT_SECTION_AUX12_CF_SHIFT 14
-#define __XSTORM_TCP_TCP_AG_CONTEXT_SECTION_AUX13_CF (0x3<<16)
-#define __XSTORM_TCP_TCP_AG_CONTEXT_SECTION_AUX13_CF_SHIFT 16
-#define __XSTORM_TCP_TCP_AG_CONTEXT_SECTION_AUX14_CF (0x3<<18)
-#define __XSTORM_TCP_TCP_AG_CONTEXT_SECTION_AUX14_CF_SHIFT 18
-#define __XSTORM_TCP_TCP_AG_CONTEXT_SECTION_AUX15_CF (0x3<<20)
-#define __XSTORM_TCP_TCP_AG_CONTEXT_SECTION_AUX15_CF_SHIFT 20
-#define __XSTORM_TCP_TCP_AG_CONTEXT_SECTION_AUX16_CF (0x3<<22)
-#define __XSTORM_TCP_TCP_AG_CONTEXT_SECTION_AUX16_CF_SHIFT 22
-#define __XSTORM_TCP_TCP_AG_CONTEXT_SECTION_AUX17_CF (0x3<<24)
-#define __XSTORM_TCP_TCP_AG_CONTEXT_SECTION_AUX17_CF_SHIFT 24
-#define XSTORM_TCP_TCP_AG_CONTEXT_SECTION_ECE_FLAG (0x1<<26)
-#define XSTORM_TCP_TCP_AG_CONTEXT_SECTION_ECE_FLAG_SHIFT 26
-#define __XSTORM_TCP_TCP_AG_CONTEXT_SECTION_RESERVED71 (0x1<<27)
-#define __XSTORM_TCP_TCP_AG_CONTEXT_SECTION_RESERVED71_SHIFT 27
-#define __XSTORM_TCP_TCP_AG_CONTEXT_SECTION_FORCE_PURE_ACK_CNT_DIRTY (0x1<<28)
-#define __XSTORM_TCP_TCP_AG_CONTEXT_SECTION_FORCE_PURE_ACK_CNT_DIRTY_SHIFT 28
-#define __XSTORM_TCP_TCP_AG_CONTEXT_SECTION_TCP_AUTO_STOP_FLAG (0x1<<29)
-#define __XSTORM_TCP_TCP_AG_CONTEXT_SECTION_TCP_AUTO_STOP_FLAG_SHIFT 29
-#define __XSTORM_TCP_TCP_AG_CONTEXT_SECTION_DO_TS_UPDATE_FLAG (0x1<<30)
-#define __XSTORM_TCP_TCP_AG_CONTEXT_SECTION_DO_TS_UPDATE_FLAG_SHIFT 30
-#define __XSTORM_TCP_TCP_AG_CONTEXT_SECTION_CANCEL_RETRANSMIT_FLAG (0x1<<31)
-#define __XSTORM_TCP_TCP_AG_CONTEXT_SECTION_CANCEL_RETRANSMIT_FLAG_SHIFT 31
-#if defined(__BIG_ENDIAN)
-	u16 __agg_misc6;
-	u16 __tcp_agg_vars7;
-#elif defined(__LITTLE_ENDIAN)
-	u16 __tcp_agg_vars7;
-	u16 __agg_misc6;
-#endif
-	u32 __agg_val10;
-	u32 __agg_val10_th;
-#if defined(__BIG_ENDIAN)
-	u16 __reserved3;
-	u8 __reserved2;
-	u8 __da_only_cnt;
-#elif defined(__LITTLE_ENDIAN)
-	u8 __da_only_cnt;
-	u8 __reserved2;
-	u16 __reserved3;
-#endif
-};
-
-/*
- * The iscsi aggregative context of Xstorm
- */
-struct xstorm_iscsi_ag_context {
-#if defined(__BIG_ENDIAN)
-	u16 agg_val1;
-	u8 agg_vars1;
-#define __XSTORM_ISCSI_AG_CONTEXT_EXISTS_IN_QM0 (0x1<<0)
-#define __XSTORM_ISCSI_AG_CONTEXT_EXISTS_IN_QM0_SHIFT 0
-#define XSTORM_ISCSI_AG_CONTEXT_EXISTS_IN_QM1 (0x1<<1)
-#define XSTORM_ISCSI_AG_CONTEXT_EXISTS_IN_QM1_SHIFT 1
-#define XSTORM_ISCSI_AG_CONTEXT_EXISTS_IN_QM2 (0x1<<2)
-#define XSTORM_ISCSI_AG_CONTEXT_EXISTS_IN_QM2_SHIFT 2
-#define XSTORM_ISCSI_AG_CONTEXT_EXISTS_IN_QM3 (0x1<<3)
-#define XSTORM_ISCSI_AG_CONTEXT_EXISTS_IN_QM3_SHIFT 3
-#define __XSTORM_ISCSI_AG_CONTEXT_MORE_TO_SEND_EN (0x1<<4)
-#define __XSTORM_ISCSI_AG_CONTEXT_MORE_TO_SEND_EN_SHIFT 4
-#define XSTORM_ISCSI_AG_CONTEXT_NAGLE_EN (0x1<<5)
-#define XSTORM_ISCSI_AG_CONTEXT_NAGLE_EN_SHIFT 5
-#define __XSTORM_ISCSI_AG_CONTEXT_DQ_SPARE_FLAG (0x1<<6)
-#define __XSTORM_ISCSI_AG_CONTEXT_DQ_SPARE_FLAG_SHIFT 6
-#define __XSTORM_ISCSI_AG_CONTEXT_UNA_GT_NXT_EN (0x1<<7)
-#define __XSTORM_ISCSI_AG_CONTEXT_UNA_GT_NXT_EN_SHIFT 7
-	u8 state;
-#elif defined(__LITTLE_ENDIAN)
-	u8 state;
-	u8 agg_vars1;
-#define __XSTORM_ISCSI_AG_CONTEXT_EXISTS_IN_QM0 (0x1<<0)
-#define __XSTORM_ISCSI_AG_CONTEXT_EXISTS_IN_QM0_SHIFT 0
-#define XSTORM_ISCSI_AG_CONTEXT_EXISTS_IN_QM1 (0x1<<1)
-#define XSTORM_ISCSI_AG_CONTEXT_EXISTS_IN_QM1_SHIFT 1
-#define XSTORM_ISCSI_AG_CONTEXT_EXISTS_IN_QM2 (0x1<<2)
-#define XSTORM_ISCSI_AG_CONTEXT_EXISTS_IN_QM2_SHIFT 2
-#define XSTORM_ISCSI_AG_CONTEXT_EXISTS_IN_QM3 (0x1<<3)
-#define XSTORM_ISCSI_AG_CONTEXT_EXISTS_IN_QM3_SHIFT 3
-#define __XSTORM_ISCSI_AG_CONTEXT_MORE_TO_SEND_EN (0x1<<4)
-#define __XSTORM_ISCSI_AG_CONTEXT_MORE_TO_SEND_EN_SHIFT 4
-#define XSTORM_ISCSI_AG_CONTEXT_NAGLE_EN (0x1<<5)
-#define XSTORM_ISCSI_AG_CONTEXT_NAGLE_EN_SHIFT 5
-#define __XSTORM_ISCSI_AG_CONTEXT_DQ_SPARE_FLAG (0x1<<6)
-#define __XSTORM_ISCSI_AG_CONTEXT_DQ_SPARE_FLAG_SHIFT 6
-#define __XSTORM_ISCSI_AG_CONTEXT_UNA_GT_NXT_EN (0x1<<7)
-#define __XSTORM_ISCSI_AG_CONTEXT_UNA_GT_NXT_EN_SHIFT 7
-	u16 agg_val1;
-#endif
-#if defined(__BIG_ENDIAN)
-	u8 cdu_reserved;
-	u8 agg_vars4;
-#define XSTORM_ISCSI_AG_CONTEXT_R2TQ_PROD_CF (0x3<<0)
-#define XSTORM_ISCSI_AG_CONTEXT_R2TQ_PROD_CF_SHIFT 0
-#define __XSTORM_ISCSI_AG_CONTEXT_AUX21_CF (0x3<<2)
-#define __XSTORM_ISCSI_AG_CONTEXT_AUX21_CF_SHIFT 2
-#define __XSTORM_ISCSI_AG_CONTEXT_AUX18_CF_EN (0x1<<4)
-#define __XSTORM_ISCSI_AG_CONTEXT_AUX18_CF_EN_SHIFT 4
-#define __XSTORM_ISCSI_AG_CONTEXT_AUX19_CF_EN (0x1<<5)
-#define __XSTORM_ISCSI_AG_CONTEXT_AUX19_CF_EN_SHIFT 5
-#define __XSTORM_ISCSI_AG_CONTEXT_R2TQ_PROD_CF_EN (0x1<<6)
-#define __XSTORM_ISCSI_AG_CONTEXT_R2TQ_PROD_CF_EN_SHIFT 6
-#define __XSTORM_ISCSI_AG_CONTEXT_AUX21_CF_EN (0x1<<7)
-#define __XSTORM_ISCSI_AG_CONTEXT_AUX21_CF_EN_SHIFT 7
-	u8 agg_vars3;
-#define XSTORM_ISCSI_AG_CONTEXT_PHYSICAL_QUEUE_NUM2 (0x3F<<0)
-#define XSTORM_ISCSI_AG_CONTEXT_PHYSICAL_QUEUE_NUM2_SHIFT 0
-#define __XSTORM_ISCSI_AG_CONTEXT_AUX19_CF (0x3<<6)
-#define __XSTORM_ISCSI_AG_CONTEXT_AUX19_CF_SHIFT 6
-	u8 agg_vars2;
-#define __XSTORM_ISCSI_AG_CONTEXT_DQ_CF (0x3<<0)
-#define __XSTORM_ISCSI_AG_CONTEXT_DQ_CF_SHIFT 0
-#define __XSTORM_ISCSI_AG_CONTEXT_DQ_SPARE_FLAG_EN (0x1<<2)
-#define __XSTORM_ISCSI_AG_CONTEXT_DQ_SPARE_FLAG_EN_SHIFT 2
-#define __XSTORM_ISCSI_AG_CONTEXT_AUX8_FLAG (0x1<<3)
-#define __XSTORM_ISCSI_AG_CONTEXT_AUX8_FLAG_SHIFT 3
-#define __XSTORM_ISCSI_AG_CONTEXT_AUX9_FLAG (0x1<<4)
-#define __XSTORM_ISCSI_AG_CONTEXT_AUX9_FLAG_SHIFT 4
-#define XSTORM_ISCSI_AG_CONTEXT_DECISION_RULE1 (0x3<<5)
-#define XSTORM_ISCSI_AG_CONTEXT_DECISION_RULE1_SHIFT 5
-#define __XSTORM_ISCSI_AG_CONTEXT_DQ_CF_EN (0x1<<7)
-#define __XSTORM_ISCSI_AG_CONTEXT_DQ_CF_EN_SHIFT 7
-#elif defined(__LITTLE_ENDIAN)
-	u8 agg_vars2;
-#define __XSTORM_ISCSI_AG_CONTEXT_DQ_CF (0x3<<0)
-#define __XSTORM_ISCSI_AG_CONTEXT_DQ_CF_SHIFT 0
-#define __XSTORM_ISCSI_AG_CONTEXT_DQ_SPARE_FLAG_EN (0x1<<2)
-#define __XSTORM_ISCSI_AG_CONTEXT_DQ_SPARE_FLAG_EN_SHIFT 2
-#define __XSTORM_ISCSI_AG_CONTEXT_AUX8_FLAG (0x1<<3)
-#define __XSTORM_ISCSI_AG_CONTEXT_AUX8_FLAG_SHIFT 3
-#define __XSTORM_ISCSI_AG_CONTEXT_AUX9_FLAG (0x1<<4)
-#define __XSTORM_ISCSI_AG_CONTEXT_AUX9_FLAG_SHIFT 4
-#define XSTORM_ISCSI_AG_CONTEXT_DECISION_RULE1 (0x3<<5)
-#define XSTORM_ISCSI_AG_CONTEXT_DECISION_RULE1_SHIFT 5
-#define __XSTORM_ISCSI_AG_CONTEXT_DQ_CF_EN (0x1<<7)
-#define __XSTORM_ISCSI_AG_CONTEXT_DQ_CF_EN_SHIFT 7
-	u8 agg_vars3;
-#define XSTORM_ISCSI_AG_CONTEXT_PHYSICAL_QUEUE_NUM2 (0x3F<<0)
-#define XSTORM_ISCSI_AG_CONTEXT_PHYSICAL_QUEUE_NUM2_SHIFT 0
-#define __XSTORM_ISCSI_AG_CONTEXT_AUX19_CF (0x3<<6)
-#define __XSTORM_ISCSI_AG_CONTEXT_AUX19_CF_SHIFT 6
-	u8 agg_vars4;
-#define XSTORM_ISCSI_AG_CONTEXT_R2TQ_PROD_CF (0x3<<0)
-#define XSTORM_ISCSI_AG_CONTEXT_R2TQ_PROD_CF_SHIFT 0
-#define __XSTORM_ISCSI_AG_CONTEXT_AUX21_CF (0x3<<2)
-#define __XSTORM_ISCSI_AG_CONTEXT_AUX21_CF_SHIFT 2
-#define __XSTORM_ISCSI_AG_CONTEXT_AUX18_CF_EN (0x1<<4)
-#define __XSTORM_ISCSI_AG_CONTEXT_AUX18_CF_EN_SHIFT 4
-#define __XSTORM_ISCSI_AG_CONTEXT_AUX19_CF_EN (0x1<<5)
-#define __XSTORM_ISCSI_AG_CONTEXT_AUX19_CF_EN_SHIFT 5
-#define __XSTORM_ISCSI_AG_CONTEXT_R2TQ_PROD_CF_EN (0x1<<6)
-#define __XSTORM_ISCSI_AG_CONTEXT_R2TQ_PROD_CF_EN_SHIFT 6
-#define __XSTORM_ISCSI_AG_CONTEXT_AUX21_CF_EN (0x1<<7)
-#define __XSTORM_ISCSI_AG_CONTEXT_AUX21_CF_EN_SHIFT 7
-	u8 cdu_reserved;
-#endif
-	u32 more_to_send;
-#if defined(__BIG_ENDIAN)
-	u16 agg_vars5;
-#define XSTORM_ISCSI_AG_CONTEXT_DECISION_RULE5 (0x3<<0)
-#define XSTORM_ISCSI_AG_CONTEXT_DECISION_RULE5_SHIFT 0
-#define XSTORM_ISCSI_AG_CONTEXT_PHYSICAL_QUEUE_NUM0 (0x3F<<2)
-#define XSTORM_ISCSI_AG_CONTEXT_PHYSICAL_QUEUE_NUM0_SHIFT 2
-#define XSTORM_ISCSI_AG_CONTEXT_PHYSICAL_QUEUE_NUM1 (0x3F<<8)
-#define XSTORM_ISCSI_AG_CONTEXT_PHYSICAL_QUEUE_NUM1_SHIFT 8
-#define XSTORM_ISCSI_AG_CONTEXT_DECISION_RULE2 (0x3<<14)
-#define XSTORM_ISCSI_AG_CONTEXT_DECISION_RULE2_SHIFT 14
-	u16 sq_cons;
-#elif defined(__LITTLE_ENDIAN)
-	u16 sq_cons;
-	u16 agg_vars5;
-#define XSTORM_ISCSI_AG_CONTEXT_DECISION_RULE5 (0x3<<0)
-#define XSTORM_ISCSI_AG_CONTEXT_DECISION_RULE5_SHIFT 0
-#define XSTORM_ISCSI_AG_CONTEXT_PHYSICAL_QUEUE_NUM0 (0x3F<<2)
-#define XSTORM_ISCSI_AG_CONTEXT_PHYSICAL_QUEUE_NUM0_SHIFT 2
-#define XSTORM_ISCSI_AG_CONTEXT_PHYSICAL_QUEUE_NUM1 (0x3F<<8)
-#define XSTORM_ISCSI_AG_CONTEXT_PHYSICAL_QUEUE_NUM1_SHIFT 8
-#define XSTORM_ISCSI_AG_CONTEXT_DECISION_RULE2 (0x3<<14)
-#define XSTORM_ISCSI_AG_CONTEXT_DECISION_RULE2_SHIFT 14
-#endif
-	struct xstorm_tcp_tcp_ag_context_section tcp;
-#if defined(__BIG_ENDIAN)
-	u16 agg_vars7;
-#define __XSTORM_ISCSI_AG_CONTEXT_AGG_VAL11_DECISION_RULE (0x7<<0)
-#define __XSTORM_ISCSI_AG_CONTEXT_AGG_VAL11_DECISION_RULE_SHIFT 0
-#define __XSTORM_ISCSI_AG_CONTEXT_AUX13_FLAG (0x1<<3)
-#define __XSTORM_ISCSI_AG_CONTEXT_AUX13_FLAG_SHIFT 3
-#define XSTORM_ISCSI_AG_CONTEXT_AUX18_CF (0x3<<4)
-#define XSTORM_ISCSI_AG_CONTEXT_AUX18_CF_SHIFT 4
-#define XSTORM_ISCSI_AG_CONTEXT_DECISION_RULE3 (0x3<<6)
-#define XSTORM_ISCSI_AG_CONTEXT_DECISION_RULE3_SHIFT 6
-#define XSTORM_ISCSI_AG_CONTEXT_AUX1_CF (0x3<<8)
-#define XSTORM_ISCSI_AG_CONTEXT_AUX1_CF_SHIFT 8
-#define __XSTORM_ISCSI_AG_CONTEXT_COMPLETION_SEQ_DECISION_MASK (0x1<<10)
-#define __XSTORM_ISCSI_AG_CONTEXT_COMPLETION_SEQ_DECISION_MASK_SHIFT 10
-#define __XSTORM_ISCSI_AG_CONTEXT_AUX1_CF_EN (0x1<<11)
-#define __XSTORM_ISCSI_AG_CONTEXT_AUX1_CF_EN_SHIFT 11
-#define __XSTORM_ISCSI_AG_CONTEXT_AUX10_FLAG (0x1<<12)
-#define __XSTORM_ISCSI_AG_CONTEXT_AUX10_FLAG_SHIFT 12
-#define __XSTORM_ISCSI_AG_CONTEXT_AUX11_FLAG (0x1<<13)
-#define __XSTORM_ISCSI_AG_CONTEXT_AUX11_FLAG_SHIFT 13
-#define __XSTORM_ISCSI_AG_CONTEXT_AUX12_FLAG (0x1<<14)
-#define __XSTORM_ISCSI_AG_CONTEXT_AUX12_FLAG_SHIFT 14
-#define __XSTORM_ISCSI_AG_CONTEXT_AUX2_FLAG (0x1<<15)
-#define __XSTORM_ISCSI_AG_CONTEXT_AUX2_FLAG_SHIFT 15
-	u8 agg_val3_th;
-	u8 agg_vars6;
-#define XSTORM_ISCSI_AG_CONTEXT_DECISION_RULE6 (0x7<<0)
-#define XSTORM_ISCSI_AG_CONTEXT_DECISION_RULE6_SHIFT 0
-#define XSTORM_ISCSI_AG_CONTEXT_DECISION_RULE7 (0x7<<3)
-#define XSTORM_ISCSI_AG_CONTEXT_DECISION_RULE7_SHIFT 3
-#define XSTORM_ISCSI_AG_CONTEXT_DECISION_RULE4 (0x3<<6)
-#define XSTORM_ISCSI_AG_CONTEXT_DECISION_RULE4_SHIFT 6
-#elif defined(__LITTLE_ENDIAN)
-	u8 agg_vars6;
-#define XSTORM_ISCSI_AG_CONTEXT_DECISION_RULE6 (0x7<<0)
-#define XSTORM_ISCSI_AG_CONTEXT_DECISION_RULE6_SHIFT 0
-#define XSTORM_ISCSI_AG_CONTEXT_DECISION_RULE7 (0x7<<3)
-#define XSTORM_ISCSI_AG_CONTEXT_DECISION_RULE7_SHIFT 3
-#define XSTORM_ISCSI_AG_CONTEXT_DECISION_RULE4 (0x3<<6)
-#define XSTORM_ISCSI_AG_CONTEXT_DECISION_RULE4_SHIFT 6
-	u8 agg_val3_th;
-	u16 agg_vars7;
-#define __XSTORM_ISCSI_AG_CONTEXT_AGG_VAL11_DECISION_RULE (0x7<<0)
-#define __XSTORM_ISCSI_AG_CONTEXT_AGG_VAL11_DECISION_RULE_SHIFT 0
-#define __XSTORM_ISCSI_AG_CONTEXT_AUX13_FLAG (0x1<<3)
-#define __XSTORM_ISCSI_AG_CONTEXT_AUX13_FLAG_SHIFT 3
-#define XSTORM_ISCSI_AG_CONTEXT_AUX18_CF (0x3<<4)
-#define XSTORM_ISCSI_AG_CONTEXT_AUX18_CF_SHIFT 4
-#define XSTORM_ISCSI_AG_CONTEXT_DECISION_RULE3 (0x3<<6)
-#define XSTORM_ISCSI_AG_CONTEXT_DECISION_RULE3_SHIFT 6
-#define XSTORM_ISCSI_AG_CONTEXT_AUX1_CF (0x3<<8)
-#define XSTORM_ISCSI_AG_CONTEXT_AUX1_CF_SHIFT 8
-#define __XSTORM_ISCSI_AG_CONTEXT_COMPLETION_SEQ_DECISION_MASK (0x1<<10)
-#define __XSTORM_ISCSI_AG_CONTEXT_COMPLETION_SEQ_DECISION_MASK_SHIFT 10
-#define __XSTORM_ISCSI_AG_CONTEXT_AUX1_CF_EN (0x1<<11)
-#define __XSTORM_ISCSI_AG_CONTEXT_AUX1_CF_EN_SHIFT 11
-#define __XSTORM_ISCSI_AG_CONTEXT_AUX10_FLAG (0x1<<12)
-#define __XSTORM_ISCSI_AG_CONTEXT_AUX10_FLAG_SHIFT 12
-#define __XSTORM_ISCSI_AG_CONTEXT_AUX11_FLAG (0x1<<13)
-#define __XSTORM_ISCSI_AG_CONTEXT_AUX11_FLAG_SHIFT 13
-#define __XSTORM_ISCSI_AG_CONTEXT_AUX12_FLAG (0x1<<14)
-#define __XSTORM_ISCSI_AG_CONTEXT_AUX12_FLAG_SHIFT 14
-#define __XSTORM_ISCSI_AG_CONTEXT_AUX2_FLAG (0x1<<15)
-#define __XSTORM_ISCSI_AG_CONTEXT_AUX2_FLAG_SHIFT 15
-#endif
-#if defined(__BIG_ENDIAN)
-	u16 __agg_val11_th;
-	u16 __agg_val11;
-#elif defined(__LITTLE_ENDIAN)
-	u16 __agg_val11;
-	u16 __agg_val11_th;
-#endif
-#if defined(__BIG_ENDIAN)
-	u8 __reserved1;
-	u8 __agg_val6_th;
-	u16 __agg_val9;
-#elif defined(__LITTLE_ENDIAN)
-	u16 __agg_val9;
-	u8 __agg_val6_th;
-	u8 __reserved1;
-#endif
-#if defined(__BIG_ENDIAN)
-	u16 hq_prod;
-	u16 hq_cons;
-#elif defined(__LITTLE_ENDIAN)
-	u16 hq_cons;
-	u16 hq_prod;
-#endif
-	u32 agg_vars8;
-#define XSTORM_ISCSI_AG_CONTEXT_AGG_MISC2 (0xFFFFFF<<0)
-#define XSTORM_ISCSI_AG_CONTEXT_AGG_MISC2_SHIFT 0
-#define XSTORM_ISCSI_AG_CONTEXT_AGG_MISC3 (0xFF<<24)
-#define XSTORM_ISCSI_AG_CONTEXT_AGG_MISC3_SHIFT 24
-#if defined(__BIG_ENDIAN)
-	u16 r2tq_prod;
-	u16 sq_prod;
-#elif defined(__LITTLE_ENDIAN)
-	u16 sq_prod;
-	u16 r2tq_prod;
-#endif
-#if defined(__BIG_ENDIAN)
-	u8 agg_val3;
-	u8 agg_val6;
-	u8 agg_val5_th;
-	u8 agg_val5;
-#elif defined(__LITTLE_ENDIAN)
-	u8 agg_val5;
-	u8 agg_val5_th;
-	u8 agg_val6;
-	u8 agg_val3;
-#endif
-#if defined(__BIG_ENDIAN)
-	u16 __agg_misc1;
-	u16 agg_limit1;
-#elif defined(__LITTLE_ENDIAN)
-	u16 agg_limit1;
-	u16 __agg_misc1;
-#endif
-	u32 hq_cons_tcp_seq;
-	u32 exp_stat_sn;
-	u32 agg_misc5;
-};
-
-/*
- * The tcp aggregative context section of Tstorm
- */
-struct tstorm_tcp_tcp_ag_context_section {
-	u32 __agg_val1;
-#if defined(__BIG_ENDIAN)
-	u8 __tcp_agg_vars2;
-	u8 __agg_val3;
-	u16 __agg_val2;
-#elif defined(__LITTLE_ENDIAN)
-	u16 __agg_val2;
-	u8 __agg_val3;
-	u8 __tcp_agg_vars2;
-#endif
-#if defined(__BIG_ENDIAN)
-	u16 __agg_val5;
-	u8 __agg_val6;
-	u8 __tcp_agg_vars3;
-#elif defined(__LITTLE_ENDIAN)
-	u8 __tcp_agg_vars3;
-	u8 __agg_val6;
-	u16 __agg_val5;
-#endif
-	u32 snd_nxt;
-	u32 rtt_seq;
-	u32 rtt_time;
-	u32 __reserved66;
-	u32 wnd_right_edge;
-	u32 tcp_agg_vars1;
-#define TSTORM_TCP_TCP_AG_CONTEXT_SECTION_FIN_SENT_FLAG (0x1<<0)
-#define TSTORM_TCP_TCP_AG_CONTEXT_SECTION_FIN_SENT_FLAG_SHIFT 0
-#define TSTORM_TCP_TCP_AG_CONTEXT_SECTION_LAST_PACKET_FIN_FLAG (0x1<<1)
-#define TSTORM_TCP_TCP_AG_CONTEXT_SECTION_LAST_PACKET_FIN_FLAG_SHIFT 1
-#define TSTORM_TCP_TCP_AG_CONTEXT_SECTION_WND_UPD_CF (0x3<<2)
-#define TSTORM_TCP_TCP_AG_CONTEXT_SECTION_WND_UPD_CF_SHIFT 2
-#define TSTORM_TCP_TCP_AG_CONTEXT_SECTION_TIMEOUT_CF (0x3<<4)
-#define TSTORM_TCP_TCP_AG_CONTEXT_SECTION_TIMEOUT_CF_SHIFT 4
-#define TSTORM_TCP_TCP_AG_CONTEXT_SECTION_WND_UPD_CF_EN (0x1<<6)
-#define TSTORM_TCP_TCP_AG_CONTEXT_SECTION_WND_UPD_CF_EN_SHIFT 6
-#define TSTORM_TCP_TCP_AG_CONTEXT_SECTION_TIMEOUT_CF_EN (0x1<<7)
-#define TSTORM_TCP_TCP_AG_CONTEXT_SECTION_TIMEOUT_CF_EN_SHIFT 7
-#define TSTORM_TCP_TCP_AG_CONTEXT_SECTION_RETRANSMIT_SEQ_EN (0x1<<8)
-#define TSTORM_TCP_TCP_AG_CONTEXT_SECTION_RETRANSMIT_SEQ_EN_SHIFT 8
-#define TSTORM_TCP_TCP_AG_CONTEXT_SECTION_SND_NXT_EN (0x1<<9)
-#define TSTORM_TCP_TCP_AG_CONTEXT_SECTION_SND_NXT_EN_SHIFT 9
-#define TSTORM_TCP_TCP_AG_CONTEXT_SECTION_AUX1_FLAG (0x1<<10)
-#define TSTORM_TCP_TCP_AG_CONTEXT_SECTION_AUX1_FLAG_SHIFT 10
-#define TSTORM_TCP_TCP_AG_CONTEXT_SECTION_AUX2_FLAG (0x1<<11)
-#define TSTORM_TCP_TCP_AG_CONTEXT_SECTION_AUX2_FLAG_SHIFT 11
-#define TSTORM_TCP_TCP_AG_CONTEXT_SECTION_AUX1_CF_EN (0x1<<12)
-#define TSTORM_TCP_TCP_AG_CONTEXT_SECTION_AUX1_CF_EN_SHIFT 12
-#define TSTORM_TCP_TCP_AG_CONTEXT_SECTION_AUX2_CF_EN (0x1<<13)
-#define TSTORM_TCP_TCP_AG_CONTEXT_SECTION_AUX2_CF_EN_SHIFT 13
-#define TSTORM_TCP_TCP_AG_CONTEXT_SECTION_AUX1_CF (0x3<<14)
-#define TSTORM_TCP_TCP_AG_CONTEXT_SECTION_AUX1_CF_SHIFT 14
-#define TSTORM_TCP_TCP_AG_CONTEXT_SECTION_AUX2_CF (0x3<<16)
-#define TSTORM_TCP_TCP_AG_CONTEXT_SECTION_AUX2_CF_SHIFT 16
-#define TSTORM_TCP_TCP_AG_CONTEXT_SECTION_TX_BLOCKED (0x1<<18)
-#define TSTORM_TCP_TCP_AG_CONTEXT_SECTION_TX_BLOCKED_SHIFT 18
-#define __TSTORM_TCP_TCP_AG_CONTEXT_SECTION_AUX10_CF_EN (0x1<<19)
-#define __TSTORM_TCP_TCP_AG_CONTEXT_SECTION_AUX10_CF_EN_SHIFT 19
-#define __TSTORM_TCP_TCP_AG_CONTEXT_SECTION_AUX11_CF_EN (0x1<<20)
-#define __TSTORM_TCP_TCP_AG_CONTEXT_SECTION_AUX11_CF_EN_SHIFT 20
-#define __TSTORM_TCP_TCP_AG_CONTEXT_SECTION_AUX12_CF_EN (0x1<<21)
-#define __TSTORM_TCP_TCP_AG_CONTEXT_SECTION_AUX12_CF_EN_SHIFT 21
-#define __TSTORM_TCP_TCP_AG_CONTEXT_SECTION_RESERVED1 (0x3<<22)
-#define __TSTORM_TCP_TCP_AG_CONTEXT_SECTION_RESERVED1_SHIFT 22
-#define TSTORM_TCP_TCP_AG_CONTEXT_SECTION_RETRANSMIT_PEND_SEQ (0xF<<24)
-#define TSTORM_TCP_TCP_AG_CONTEXT_SECTION_RETRANSMIT_PEND_SEQ_SHIFT 24
-#define TSTORM_TCP_TCP_AG_CONTEXT_SECTION_RETRANSMIT_DONE_SEQ (0xF<<28)
-#define TSTORM_TCP_TCP_AG_CONTEXT_SECTION_RETRANSMIT_DONE_SEQ_SHIFT 28
-	u32 snd_max;
-	u32 snd_una;
-	u32 __reserved2;
-};
-
-/*
- * The iscsi aggregative context of Tstorm
- */
-struct tstorm_iscsi_ag_context {
-#if defined(__BIG_ENDIAN)
-	u16 ulp_credit;
-	u8 agg_vars1;
-#define TSTORM_ISCSI_AG_CONTEXT_EXISTS_IN_QM0 (0x1<<0)
-#define TSTORM_ISCSI_AG_CONTEXT_EXISTS_IN_QM0_SHIFT 0
-#define TSTORM_ISCSI_AG_CONTEXT_EXISTS_IN_QM1 (0x1<<1)
-#define TSTORM_ISCSI_AG_CONTEXT_EXISTS_IN_QM1_SHIFT 1
-#define TSTORM_ISCSI_AG_CONTEXT_EXISTS_IN_QM2 (0x1<<2)
-#define TSTORM_ISCSI_AG_CONTEXT_EXISTS_IN_QM2_SHIFT 2
-#define TSTORM_ISCSI_AG_CONTEXT_EXISTS_IN_QM3 (0x1<<3)
-#define TSTORM_ISCSI_AG_CONTEXT_EXISTS_IN_QM3_SHIFT 3
-#define __TSTORM_ISCSI_AG_CONTEXT_AUX3_CF (0x3<<4)
-#define __TSTORM_ISCSI_AG_CONTEXT_AUX3_CF_SHIFT 4
-#define __TSTORM_ISCSI_AG_CONTEXT_AUX3_FLAG (0x1<<6)
-#define __TSTORM_ISCSI_AG_CONTEXT_AUX3_FLAG_SHIFT 6
-#define __TSTORM_ISCSI_AG_CONTEXT_AUX4_FLAG (0x1<<7)
-#define __TSTORM_ISCSI_AG_CONTEXT_AUX4_FLAG_SHIFT 7
-	u8 state;
-#elif defined(__LITTLE_ENDIAN)
-	u8 state;
-	u8 agg_vars1;
-#define TSTORM_ISCSI_AG_CONTEXT_EXISTS_IN_QM0 (0x1<<0)
-#define TSTORM_ISCSI_AG_CONTEXT_EXISTS_IN_QM0_SHIFT 0
-#define TSTORM_ISCSI_AG_CONTEXT_EXISTS_IN_QM1 (0x1<<1)
-#define TSTORM_ISCSI_AG_CONTEXT_EXISTS_IN_QM1_SHIFT 1
-#define TSTORM_ISCSI_AG_CONTEXT_EXISTS_IN_QM2 (0x1<<2)
-#define TSTORM_ISCSI_AG_CONTEXT_EXISTS_IN_QM2_SHIFT 2
-#define TSTORM_ISCSI_AG_CONTEXT_EXISTS_IN_QM3 (0x1<<3)
-#define TSTORM_ISCSI_AG_CONTEXT_EXISTS_IN_QM3_SHIFT 3
-#define __TSTORM_ISCSI_AG_CONTEXT_AUX3_CF (0x3<<4)
-#define __TSTORM_ISCSI_AG_CONTEXT_AUX3_CF_SHIFT 4
-#define __TSTORM_ISCSI_AG_CONTEXT_AUX3_FLAG (0x1<<6)
-#define __TSTORM_ISCSI_AG_CONTEXT_AUX3_FLAG_SHIFT 6
-#define __TSTORM_ISCSI_AG_CONTEXT_AUX4_FLAG (0x1<<7)
-#define __TSTORM_ISCSI_AG_CONTEXT_AUX4_FLAG_SHIFT 7
-	u16 ulp_credit;
-#endif
-#if defined(__BIG_ENDIAN)
-	u16 __agg_val4;
-	u16 agg_vars2;
-#define __TSTORM_ISCSI_AG_CONTEXT_AUX5_FLAG (0x1<<0)
-#define __TSTORM_ISCSI_AG_CONTEXT_AUX5_FLAG_SHIFT 0
-#define __TSTORM_ISCSI_AG_CONTEXT_AUX6_FLAG (0x1<<1)
-#define __TSTORM_ISCSI_AG_CONTEXT_AUX6_FLAG_SHIFT 1
-#define __TSTORM_ISCSI_AG_CONTEXT_AUX4_CF (0x3<<2)
-#define __TSTORM_ISCSI_AG_CONTEXT_AUX4_CF_SHIFT 2
-#define __TSTORM_ISCSI_AG_CONTEXT_AUX5_CF (0x3<<4)
-#define __TSTORM_ISCSI_AG_CONTEXT_AUX5_CF_SHIFT 4
-#define __TSTORM_ISCSI_AG_CONTEXT_AUX6_CF (0x3<<6)
-#define __TSTORM_ISCSI_AG_CONTEXT_AUX6_CF_SHIFT 6
-#define __TSTORM_ISCSI_AG_CONTEXT_AUX7_CF (0x3<<8)
-#define __TSTORM_ISCSI_AG_CONTEXT_AUX7_CF_SHIFT 8
-#define __TSTORM_ISCSI_AG_CONTEXT_AUX7_FLAG (0x1<<10)
-#define __TSTORM_ISCSI_AG_CONTEXT_AUX7_FLAG_SHIFT 10
-#define TSTORM_ISCSI_AG_CONTEXT_AUX3_CF_EN (0x1<<11)
-#define TSTORM_ISCSI_AG_CONTEXT_AUX3_CF_EN_SHIFT 11
-#define TSTORM_ISCSI_AG_CONTEXT_AUX4_CF_EN (0x1<<12)
-#define TSTORM_ISCSI_AG_CONTEXT_AUX4_CF_EN_SHIFT 12
-#define TSTORM_ISCSI_AG_CONTEXT_AUX5_CF_EN (0x1<<13)
-#define TSTORM_ISCSI_AG_CONTEXT_AUX5_CF_EN_SHIFT 13
-#define TSTORM_ISCSI_AG_CONTEXT_AUX6_CF_EN (0x1<<14)
-#define TSTORM_ISCSI_AG_CONTEXT_AUX6_CF_EN_SHIFT 14
-#define TSTORM_ISCSI_AG_CONTEXT_AUX7_CF_EN (0x1<<15)
-#define TSTORM_ISCSI_AG_CONTEXT_AUX7_CF_EN_SHIFT 15
-#elif defined(__LITTLE_ENDIAN)
-	u16 agg_vars2;
-#define __TSTORM_ISCSI_AG_CONTEXT_AUX5_FLAG (0x1<<0)
-#define __TSTORM_ISCSI_AG_CONTEXT_AUX5_FLAG_SHIFT 0
-#define __TSTORM_ISCSI_AG_CONTEXT_AUX6_FLAG (0x1<<1)
-#define __TSTORM_ISCSI_AG_CONTEXT_AUX6_FLAG_SHIFT 1
-#define __TSTORM_ISCSI_AG_CONTEXT_AUX4_CF (0x3<<2)
-#define __TSTORM_ISCSI_AG_CONTEXT_AUX4_CF_SHIFT 2
-#define __TSTORM_ISCSI_AG_CONTEXT_AUX5_CF (0x3<<4)
-#define __TSTORM_ISCSI_AG_CONTEXT_AUX5_CF_SHIFT 4
-#define __TSTORM_ISCSI_AG_CONTEXT_AUX6_CF (0x3<<6)
-#define __TSTORM_ISCSI_AG_CONTEXT_AUX6_CF_SHIFT 6
-#define __TSTORM_ISCSI_AG_CONTEXT_AUX7_CF (0x3<<8)
-#define __TSTORM_ISCSI_AG_CONTEXT_AUX7_CF_SHIFT 8
-#define __TSTORM_ISCSI_AG_CONTEXT_AUX7_FLAG (0x1<<10)
-#define __TSTORM_ISCSI_AG_CONTEXT_AUX7_FLAG_SHIFT 10
-#define TSTORM_ISCSI_AG_CONTEXT_AUX3_CF_EN (0x1<<11)
-#define TSTORM_ISCSI_AG_CONTEXT_AUX3_CF_EN_SHIFT 11
-#define TSTORM_ISCSI_AG_CONTEXT_AUX4_CF_EN (0x1<<12)
-#define TSTORM_ISCSI_AG_CONTEXT_AUX4_CF_EN_SHIFT 12
-#define TSTORM_ISCSI_AG_CONTEXT_AUX5_CF_EN (0x1<<13)
-#define TSTORM_ISCSI_AG_CONTEXT_AUX5_CF_EN_SHIFT 13
-#define TSTORM_ISCSI_AG_CONTEXT_AUX6_CF_EN (0x1<<14)
-#define TSTORM_ISCSI_AG_CONTEXT_AUX6_CF_EN_SHIFT 14
-#define TSTORM_ISCSI_AG_CONTEXT_AUX7_CF_EN (0x1<<15)
-#define TSTORM_ISCSI_AG_CONTEXT_AUX7_CF_EN_SHIFT 15
-	u16 __agg_val4;
-#endif
-	struct tstorm_tcp_tcp_ag_context_section tcp;
-};
-
-/*
- * The iscsi aggregative context of Cstorm
- */
-struct cstorm_iscsi_ag_context {
-	u32 agg_vars1;
-#define CSTORM_ISCSI_AG_CONTEXT_STATE (0xFF<<0)
-#define CSTORM_ISCSI_AG_CONTEXT_STATE_SHIFT 0
-#define __CSTORM_ISCSI_AG_CONTEXT_EXISTS_IN_QM0 (0x1<<8)
-#define __CSTORM_ISCSI_AG_CONTEXT_EXISTS_IN_QM0_SHIFT 8
-#define __CSTORM_ISCSI_AG_CONTEXT_EXISTS_IN_QM1 (0x1<<9)
-#define __CSTORM_ISCSI_AG_CONTEXT_EXISTS_IN_QM1_SHIFT 9
-#define __CSTORM_ISCSI_AG_CONTEXT_EXISTS_IN_QM2 (0x1<<10)
-#define __CSTORM_ISCSI_AG_CONTEXT_EXISTS_IN_QM2_SHIFT 10
-#define __CSTORM_ISCSI_AG_CONTEXT_EXISTS_IN_QM3 (0x1<<11)
-#define __CSTORM_ISCSI_AG_CONTEXT_EXISTS_IN_QM3_SHIFT 11
-#define __CSTORM_ISCSI_AG_CONTEXT_RESERVED_ULP_RX_SE_CF_EN (0x1<<12)
-#define __CSTORM_ISCSI_AG_CONTEXT_RESERVED_ULP_RX_SE_CF_EN_SHIFT 12
-#define __CSTORM_ISCSI_AG_CONTEXT_RESERVED_ULP_RX_INV_CF_EN (0x1<<13)
-#define __CSTORM_ISCSI_AG_CONTEXT_RESERVED_ULP_RX_INV_CF_EN_SHIFT 13
-#define __CSTORM_ISCSI_AG_CONTEXT_PENDING_COMPLETION3_CF (0x3<<14)
-#define __CSTORM_ISCSI_AG_CONTEXT_PENDING_COMPLETION3_CF_SHIFT 14
-#define __CSTORM_ISCSI_AG_CONTEXT_RESERVED66 (0x3<<16)
-#define __CSTORM_ISCSI_AG_CONTEXT_RESERVED66_SHIFT 16
-#define __CSTORM_ISCSI_AG_CONTEXT_FIN_RECEIVED_CF_EN (0x1<<18)
-#define __CSTORM_ISCSI_AG_CONTEXT_FIN_RECEIVED_CF_EN_SHIFT 18
-#define __CSTORM_ISCSI_AG_CONTEXT_PENDING_COMPLETION0_CF_EN (0x1<<19)
-#define __CSTORM_ISCSI_AG_CONTEXT_PENDING_COMPLETION0_CF_EN_SHIFT 19
-#define __CSTORM_ISCSI_AG_CONTEXT_PENDING_COMPLETION1_CF_EN (0x1<<20)
-#define __CSTORM_ISCSI_AG_CONTEXT_PENDING_COMPLETION1_CF_EN_SHIFT 20
-#define __CSTORM_ISCSI_AG_CONTEXT_PENDING_COMPLETION2_CF_EN (0x1<<21)
-#define __CSTORM_ISCSI_AG_CONTEXT_PENDING_COMPLETION2_CF_EN_SHIFT 21
-#define __CSTORM_ISCSI_AG_CONTEXT_PENDING_COMPLETION3_CF_EN (0x1<<22)
-#define __CSTORM_ISCSI_AG_CONTEXT_PENDING_COMPLETION3_CF_EN_SHIFT 22
-#define __CSTORM_ISCSI_AG_CONTEXT_REL_SEQ_RULE (0x7<<23)
-#define __CSTORM_ISCSI_AG_CONTEXT_REL_SEQ_RULE_SHIFT 23
-#define CSTORM_ISCSI_AG_CONTEXT_HQ_PROD_RULE (0x3<<26)
-#define CSTORM_ISCSI_AG_CONTEXT_HQ_PROD_RULE_SHIFT 26
-#define __CSTORM_ISCSI_AG_CONTEXT_RESERVED52 (0x3<<28)
-#define __CSTORM_ISCSI_AG_CONTEXT_RESERVED52_SHIFT 28
-#define __CSTORM_ISCSI_AG_CONTEXT_RESERVED53 (0x3<<30)
-#define __CSTORM_ISCSI_AG_CONTEXT_RESERVED53_SHIFT 30
-#if defined(__BIG_ENDIAN)
-	u8 __aux1_th;
-	u8 __aux1_val;
-	u16 __agg_vars2;
-#elif defined(__LITTLE_ENDIAN)
-	u16 __agg_vars2;
-	u8 __aux1_val;
-	u8 __aux1_th;
-#endif
-	u32 rel_seq;
-	u32 rel_seq_th;
-#if defined(__BIG_ENDIAN)
-	u16 hq_cons;
-	u16 hq_prod;
-#elif defined(__LITTLE_ENDIAN)
-	u16 hq_prod;
-	u16 hq_cons;
-#endif
-#if defined(__BIG_ENDIAN)
-	u8 __reserved62;
-	u8 __reserved61;
-	u8 __reserved60;
-	u8 __reserved59;
-#elif defined(__LITTLE_ENDIAN)
-	u8 __reserved59;
-	u8 __reserved60;
-	u8 __reserved61;
-	u8 __reserved62;
-#endif
-#if defined(__BIG_ENDIAN)
-	u16 __reserved64;
-	u16 __cq_u_prod0;
-#elif defined(__LITTLE_ENDIAN)
-	u16 __cq_u_prod0;
-	u16 __reserved64;
-#endif
-	u32 __cq_u_prod1;
-#if defined(__BIG_ENDIAN)
-	u16 __agg_vars3;
-	u16 __cq_u_prod2;
-#elif defined(__LITTLE_ENDIAN)
-	u16 __cq_u_prod2;
-	u16 __agg_vars3;
-#endif
-#if defined(__BIG_ENDIAN)
-	u16 __aux2_th;
-	u16 __cq_u_prod3;
-#elif defined(__LITTLE_ENDIAN)
-	u16 __cq_u_prod3;
-	u16 __aux2_th;
-#endif
-};
-
-/*
- * The iscsi aggregative context of Ustorm
- */
-struct ustorm_iscsi_ag_context {
-#if defined(__BIG_ENDIAN)
-	u8 __aux_counter_flags;
-	u8 agg_vars2;
-#define USTORM_ISCSI_AG_CONTEXT_TX_CF (0x3<<0)
-#define USTORM_ISCSI_AG_CONTEXT_TX_CF_SHIFT 0
-#define __USTORM_ISCSI_AG_CONTEXT_TIMER_CF (0x3<<2)
-#define __USTORM_ISCSI_AG_CONTEXT_TIMER_CF_SHIFT 2
-#define USTORM_ISCSI_AG_CONTEXT_AGG_MISC4_RULE (0x7<<4)
-#define USTORM_ISCSI_AG_CONTEXT_AGG_MISC4_RULE_SHIFT 4
-#define __USTORM_ISCSI_AG_CONTEXT_AGG_VAL2_MASK (0x1<<7)
-#define __USTORM_ISCSI_AG_CONTEXT_AGG_VAL2_MASK_SHIFT 7
-	u8 agg_vars1;
-#define __USTORM_ISCSI_AG_CONTEXT_EXISTS_IN_QM0 (0x1<<0)
-#define __USTORM_ISCSI_AG_CONTEXT_EXISTS_IN_QM0_SHIFT 0
-#define USTORM_ISCSI_AG_CONTEXT_EXISTS_IN_QM1 (0x1<<1)
-#define USTORM_ISCSI_AG_CONTEXT_EXISTS_IN_QM1_SHIFT 1
-#define USTORM_ISCSI_AG_CONTEXT_EXISTS_IN_QM2 (0x1<<2)
-#define USTORM_ISCSI_AG_CONTEXT_EXISTS_IN_QM2_SHIFT 2
-#define USTORM_ISCSI_AG_CONTEXT_EXISTS_IN_QM3 (0x1<<3)
-#define USTORM_ISCSI_AG_CONTEXT_EXISTS_IN_QM3_SHIFT 3
-#define USTORM_ISCSI_AG_CONTEXT_INV_CF (0x3<<4)
-#define USTORM_ISCSI_AG_CONTEXT_INV_CF_SHIFT 4
-#define USTORM_ISCSI_AG_CONTEXT_COMPLETION_CF (0x3<<6)
-#define USTORM_ISCSI_AG_CONTEXT_COMPLETION_CF_SHIFT 6
-	u8 state;
-#elif defined(__LITTLE_ENDIAN)
-	u8 state;
-	u8 agg_vars1;
-#define __USTORM_ISCSI_AG_CONTEXT_EXISTS_IN_QM0 (0x1<<0)
-#define __USTORM_ISCSI_AG_CONTEXT_EXISTS_IN_QM0_SHIFT 0
-#define USTORM_ISCSI_AG_CONTEXT_EXISTS_IN_QM1 (0x1<<1)
-#define USTORM_ISCSI_AG_CONTEXT_EXISTS_IN_QM1_SHIFT 1
-#define USTORM_ISCSI_AG_CONTEXT_EXISTS_IN_QM2 (0x1<<2)
-#define USTORM_ISCSI_AG_CONTEXT_EXISTS_IN_QM2_SHIFT 2
-#define USTORM_ISCSI_AG_CONTEXT_EXISTS_IN_QM3 (0x1<<3)
-#define USTORM_ISCSI_AG_CONTEXT_EXISTS_IN_QM3_SHIFT 3
-#define USTORM_ISCSI_AG_CONTEXT_INV_CF (0x3<<4)
-#define USTORM_ISCSI_AG_CONTEXT_INV_CF_SHIFT 4
-#define USTORM_ISCSI_AG_CONTEXT_COMPLETION_CF (0x3<<6)
-#define USTORM_ISCSI_AG_CONTEXT_COMPLETION_CF_SHIFT 6
-	u8 agg_vars2;
-#define USTORM_ISCSI_AG_CONTEXT_TX_CF (0x3<<0)
-#define USTORM_ISCSI_AG_CONTEXT_TX_CF_SHIFT 0
-#define __USTORM_ISCSI_AG_CONTEXT_TIMER_CF (0x3<<2)
-#define __USTORM_ISCSI_AG_CONTEXT_TIMER_CF_SHIFT 2
-#define USTORM_ISCSI_AG_CONTEXT_AGG_MISC4_RULE (0x7<<4)
-#define USTORM_ISCSI_AG_CONTEXT_AGG_MISC4_RULE_SHIFT 4
-#define __USTORM_ISCSI_AG_CONTEXT_AGG_VAL2_MASK (0x1<<7)
-#define __USTORM_ISCSI_AG_CONTEXT_AGG_VAL2_MASK_SHIFT 7
-	u8 __aux_counter_flags;
-#endif
-#if defined(__BIG_ENDIAN)
-	u8 cdu_usage;
-	u8 agg_misc2;
-	u16 __cq_local_comp_itt_val;
-#elif defined(__LITTLE_ENDIAN)
-	u16 __cq_local_comp_itt_val;
-	u8 agg_misc2;
-	u8 cdu_usage;
-#endif
-	u32 agg_misc4;
-#if defined(__BIG_ENDIAN)
-	u8 agg_val3_th;
-	u8 agg_val3;
-	u16 agg_misc3;
-#elif defined(__LITTLE_ENDIAN)
-	u16 agg_misc3;
-	u8 agg_val3;
-	u8 agg_val3_th;
-#endif
-	u32 agg_val1;
-	u32 agg_misc4_th;
-#if defined(__BIG_ENDIAN)
-	u16 agg_val2_th;
-	u16 agg_val2;
-#elif defined(__LITTLE_ENDIAN)
-	u16 agg_val2;
-	u16 agg_val2_th;
-#endif
-#if defined(__BIG_ENDIAN)
-	u16 __reserved2;
-	u8 decision_rules;
-#define USTORM_ISCSI_AG_CONTEXT_AGG_VAL2_RULE (0x7<<0)
-#define USTORM_ISCSI_AG_CONTEXT_AGG_VAL2_RULE_SHIFT 0
-#define __USTORM_ISCSI_AG_CONTEXT_AGG_VAL3_RULE (0x7<<3)
-#define __USTORM_ISCSI_AG_CONTEXT_AGG_VAL3_RULE_SHIFT 3
-#define __USTORM_ISCSI_AG_CONTEXT_AGG_VAL2_ARM_N_FLAG (0x1<<6)
-#define __USTORM_ISCSI_AG_CONTEXT_AGG_VAL2_ARM_N_FLAG_SHIFT 6
-#define __USTORM_ISCSI_AG_CONTEXT_RESERVED1 (0x1<<7)
-#define __USTORM_ISCSI_AG_CONTEXT_RESERVED1_SHIFT 7
-	u8 decision_rule_enable_bits;
-#define USTORM_ISCSI_AG_CONTEXT_INV_CF_EN (0x1<<0)
-#define USTORM_ISCSI_AG_CONTEXT_INV_CF_EN_SHIFT 0
-#define USTORM_ISCSI_AG_CONTEXT_COMPLETION_CF_EN (0x1<<1)
-#define USTORM_ISCSI_AG_CONTEXT_COMPLETION_CF_EN_SHIFT 1
-#define USTORM_ISCSI_AG_CONTEXT_TX_CF_EN (0x1<<2)
-#define USTORM_ISCSI_AG_CONTEXT_TX_CF_EN_SHIFT 2
-#define __USTORM_ISCSI_AG_CONTEXT_TIMER_CF_EN (0x1<<3)
-#define __USTORM_ISCSI_AG_CONTEXT_TIMER_CF_EN_SHIFT 3
-#define __USTORM_ISCSI_AG_CONTEXT_CQ_LOCAL_COMP_CF_EN (0x1<<4)
-#define __USTORM_ISCSI_AG_CONTEXT_CQ_LOCAL_COMP_CF_EN_SHIFT 4
-#define __USTORM_ISCSI_AG_CONTEXT_QUEUES_FLUSH_Q0_CF_EN (0x1<<5)
-#define __USTORM_ISCSI_AG_CONTEXT_QUEUES_FLUSH_Q0_CF_EN_SHIFT 5
-#define __USTORM_ISCSI_AG_CONTEXT_AUX3_CF_EN (0x1<<6)
-#define __USTORM_ISCSI_AG_CONTEXT_AUX3_CF_EN_SHIFT 6
-#define __USTORM_ISCSI_AG_CONTEXT_DQ_CF_EN (0x1<<7)
-#define __USTORM_ISCSI_AG_CONTEXT_DQ_CF_EN_SHIFT 7
-#elif defined(__LITTLE_ENDIAN)
-	u8 decision_rule_enable_bits;
-#define USTORM_ISCSI_AG_CONTEXT_INV_CF_EN (0x1<<0)
-#define USTORM_ISCSI_AG_CONTEXT_INV_CF_EN_SHIFT 0
-#define USTORM_ISCSI_AG_CONTEXT_COMPLETION_CF_EN (0x1<<1)
-#define USTORM_ISCSI_AG_CONTEXT_COMPLETION_CF_EN_SHIFT 1
-#define USTORM_ISCSI_AG_CONTEXT_TX_CF_EN (0x1<<2)
-#define USTORM_ISCSI_AG_CONTEXT_TX_CF_EN_SHIFT 2
-#define __USTORM_ISCSI_AG_CONTEXT_TIMER_CF_EN (0x1<<3)
-#define __USTORM_ISCSI_AG_CONTEXT_TIMER_CF_EN_SHIFT 3
-#define __USTORM_ISCSI_AG_CONTEXT_CQ_LOCAL_COMP_CF_EN (0x1<<4)
-#define __USTORM_ISCSI_AG_CONTEXT_CQ_LOCAL_COMP_CF_EN_SHIFT 4
-#define __USTORM_ISCSI_AG_CONTEXT_QUEUES_FLUSH_Q0_CF_EN (0x1<<5)
-#define __USTORM_ISCSI_AG_CONTEXT_QUEUES_FLUSH_Q0_CF_EN_SHIFT 5
-#define __USTORM_ISCSI_AG_CONTEXT_AUX3_CF_EN (0x1<<6)
-#define __USTORM_ISCSI_AG_CONTEXT_AUX3_CF_EN_SHIFT 6
-#define __USTORM_ISCSI_AG_CONTEXT_DQ_CF_EN (0x1<<7)
-#define __USTORM_ISCSI_AG_CONTEXT_DQ_CF_EN_SHIFT 7
-	u8 decision_rules;
-#define USTORM_ISCSI_AG_CONTEXT_AGG_VAL2_RULE (0x7<<0)
-#define USTORM_ISCSI_AG_CONTEXT_AGG_VAL2_RULE_SHIFT 0
-#define __USTORM_ISCSI_AG_CONTEXT_AGG_VAL3_RULE (0x7<<3)
-#define __USTORM_ISCSI_AG_CONTEXT_AGG_VAL3_RULE_SHIFT 3
-#define __USTORM_ISCSI_AG_CONTEXT_AGG_VAL2_ARM_N_FLAG (0x1<<6)
-#define __USTORM_ISCSI_AG_CONTEXT_AGG_VAL2_ARM_N_FLAG_SHIFT 6
-#define __USTORM_ISCSI_AG_CONTEXT_RESERVED1 (0x1<<7)
-#define __USTORM_ISCSI_AG_CONTEXT_RESERVED1_SHIFT 7
-	u16 __reserved2;
-#endif
-};
-
-/*
- * Timers connection context
- */
-struct iscsi_timers_block_context {
-	u32 __reserved_0;
-	u32 __reserved_1;
-	u32 __reserved_2;
-	u32 flags;
-#define __ISCSI_TIMERS_BLOCK_CONTEXT_NUM_OF_ACTIVE_TIMERS (0x3<<0)
-#define __ISCSI_TIMERS_BLOCK_CONTEXT_NUM_OF_ACTIVE_TIMERS_SHIFT 0
-#define ISCSI_TIMERS_BLOCK_CONTEXT_CONN_VALID_FLG (0x1<<2)
-#define ISCSI_TIMERS_BLOCK_CONTEXT_CONN_VALID_FLG_SHIFT 2
-#define __ISCSI_TIMERS_BLOCK_CONTEXT_RESERVED0 (0x1FFFFFFF<<3)
-#define __ISCSI_TIMERS_BLOCK_CONTEXT_RESERVED0_SHIFT 3
-};
-
-/*
- * Ethernet context section, shared in TOE, RDMA and ISCSI
- */
-struct xstorm_eth_context_section {
-#if defined(__BIG_ENDIAN)
-	u8 remote_addr_4;
-	u8 remote_addr_5;
-	u8 local_addr_0;
-	u8 local_addr_1;
-#elif defined(__LITTLE_ENDIAN)
-	u8 local_addr_1;
-	u8 local_addr_0;
-	u8 remote_addr_5;
-	u8 remote_addr_4;
-#endif
-#if defined(__BIG_ENDIAN)
-	u8 remote_addr_0;
-	u8 remote_addr_1;
-	u8 remote_addr_2;
-	u8 remote_addr_3;
-#elif defined(__LITTLE_ENDIAN)
-	u8 remote_addr_3;
-	u8 remote_addr_2;
-	u8 remote_addr_1;
-	u8 remote_addr_0;
-#endif
-#if defined(__BIG_ENDIAN)
-	u16 reserved_vlan_type;
-	u16 params;
-#define XSTORM_ETH_CONTEXT_SECTION_VLAN_ID (0xFFF<<0)
-#define XSTORM_ETH_CONTEXT_SECTION_VLAN_ID_SHIFT 0
-#define XSTORM_ETH_CONTEXT_SECTION_CFI (0x1<<12)
-#define XSTORM_ETH_CONTEXT_SECTION_CFI_SHIFT 12
-#define XSTORM_ETH_CONTEXT_SECTION_PRIORITY (0x7<<13)
-#define XSTORM_ETH_CONTEXT_SECTION_PRIORITY_SHIFT 13
-#elif defined(__LITTLE_ENDIAN)
-	u16 params;
-#define XSTORM_ETH_CONTEXT_SECTION_VLAN_ID (0xFFF<<0)
-#define XSTORM_ETH_CONTEXT_SECTION_VLAN_ID_SHIFT 0
-#define XSTORM_ETH_CONTEXT_SECTION_CFI (0x1<<12)
-#define XSTORM_ETH_CONTEXT_SECTION_CFI_SHIFT 12
-#define XSTORM_ETH_CONTEXT_SECTION_PRIORITY (0x7<<13)
-#define XSTORM_ETH_CONTEXT_SECTION_PRIORITY_SHIFT 13
-	u16 reserved_vlan_type;
-#endif
-#if defined(__BIG_ENDIAN)
-	u8 local_addr_2;
-	u8 local_addr_3;
-	u8 local_addr_4;
-	u8 local_addr_5;
-#elif defined(__LITTLE_ENDIAN)
-	u8 local_addr_5;
-	u8 local_addr_4;
-	u8 local_addr_3;
-	u8 local_addr_2;
-#endif
-};
-
-/*
- * IpV4 context section, shared in TOE, RDMA and ISCSI
- */
-struct xstorm_ip_v4_context_section {
-#if defined(__BIG_ENDIAN)
-	u16 __pbf_hdr_cmd_rsvd_id;
-	u16 __pbf_hdr_cmd_rsvd_flags_offset;
-#elif defined(__LITTLE_ENDIAN)
-	u16 __pbf_hdr_cmd_rsvd_flags_offset;
-	u16 __pbf_hdr_cmd_rsvd_id;
-#endif
-#if defined(__BIG_ENDIAN)
-	u8 __pbf_hdr_cmd_rsvd_ver_ihl;
-	u8 tos;
-	u16 __pbf_hdr_cmd_rsvd_length;
-#elif defined(__LITTLE_ENDIAN)
-	u16 __pbf_hdr_cmd_rsvd_length;
-	u8 tos;
-	u8 __pbf_hdr_cmd_rsvd_ver_ihl;
-#endif
-	u32 ip_local_addr;
-#if defined(__BIG_ENDIAN)
-	u8 ttl;
-	u8 __pbf_hdr_cmd_rsvd_protocol;
-	u16 __pbf_hdr_cmd_rsvd_csum;
-#elif defined(__LITTLE_ENDIAN)
-	u16 __pbf_hdr_cmd_rsvd_csum;
-	u8 __pbf_hdr_cmd_rsvd_protocol;
-	u8 ttl;
-#endif
-	u32 __pbf_hdr_cmd_rsvd_1;
-	u32 ip_remote_addr;
-};
-
-/*
- * context section, shared in TOE, RDMA and ISCSI
- */
-struct xstorm_padded_ip_v4_context_section {
-	struct xstorm_ip_v4_context_section ip_v4;
-	u32 reserved1[4];
-};
-
-/*
- * IpV6 context section, shared in TOE, RDMA and ISCSI
- */
-struct xstorm_ip_v6_context_section {
-#if defined(__BIG_ENDIAN)
-	u16 pbf_hdr_cmd_rsvd_payload_len;
-	u8 pbf_hdr_cmd_rsvd_nxt_hdr;
-	u8 hop_limit;
-#elif defined(__LITTLE_ENDIAN)
-	u8 hop_limit;
-	u8 pbf_hdr_cmd_rsvd_nxt_hdr;
-	u16 pbf_hdr_cmd_rsvd_payload_len;
-#endif
-	u32 priority_flow_label;
-#define XSTORM_IP_V6_CONTEXT_SECTION_FLOW_LABEL (0xFFFFF<<0)
-#define XSTORM_IP_V6_CONTEXT_SECTION_FLOW_LABEL_SHIFT 0
-#define XSTORM_IP_V6_CONTEXT_SECTION_TRAFFIC_CLASS (0xFF<<20)
-#define XSTORM_IP_V6_CONTEXT_SECTION_TRAFFIC_CLASS_SHIFT 20
-#define XSTORM_IP_V6_CONTEXT_SECTION_PBF_HDR_CMD_RSVD_VER (0xF<<28)
-#define XSTORM_IP_V6_CONTEXT_SECTION_PBF_HDR_CMD_RSVD_VER_SHIFT 28
-	u32 ip_local_addr_lo_hi;
-	u32 ip_local_addr_lo_lo;
-	u32 ip_local_addr_hi_hi;
-	u32 ip_local_addr_hi_lo;
-	u32 ip_remote_addr_lo_hi;
-	u32 ip_remote_addr_lo_lo;
-	u32 ip_remote_addr_hi_hi;
-	u32 ip_remote_addr_hi_lo;
-};
-
-union xstorm_ip_context_section_types {
-	struct xstorm_padded_ip_v4_context_section padded_ip_v4;
-	struct xstorm_ip_v6_context_section ip_v6;
-};
-
-/*
- * TCP context section, shared in TOE, RDMA and ISCSI
- */
-struct xstorm_tcp_context_section {
-	u32 snd_max;
-#if defined(__BIG_ENDIAN)
-	u16 remote_port;
-	u16 local_port;
-#elif defined(__LITTLE_ENDIAN)
-	u16 local_port;
-	u16 remote_port;
-#endif
-#if defined(__BIG_ENDIAN)
-	u8 original_nagle_1b;
-	u8 ts_enabled_1b;
-	u16 tcp_params;
-#define XSTORM_TCP_CONTEXT_SECTION_TOTAL_HEADER_SIZE (0xFF<<0)
-#define XSTORM_TCP_CONTEXT_SECTION_TOTAL_HEADER_SIZE_SHIFT 0
-#define __XSTORM_TCP_CONTEXT_SECTION_ECT_BIT (0x1<<8)
-#define __XSTORM_TCP_CONTEXT_SECTION_ECT_BIT_SHIFT 8
-#define __XSTORM_TCP_CONTEXT_SECTION_ECN_ENABLED (0x1<<9)
-#define __XSTORM_TCP_CONTEXT_SECTION_ECN_ENABLED_SHIFT 9
-#define XSTORM_TCP_CONTEXT_SECTION_SACK_ENABLED (0x1<<10)
-#define XSTORM_TCP_CONTEXT_SECTION_SACK_ENABLED_SHIFT 10
-#define XSTORM_TCP_CONTEXT_SECTION_KA_STATE (0x1<<11)
-#define XSTORM_TCP_CONTEXT_SECTION_KA_STATE_SHIFT 11
-#define XSTORM_TCP_CONTEXT_SECTION_FIN_SENT_FLAG (0x1<<12)
-#define XSTORM_TCP_CONTEXT_SECTION_FIN_SENT_FLAG_SHIFT 12
-#define XSTORM_TCP_CONTEXT_SECTION_WINDOW_SATURATED (0x1<<13)
-#define XSTORM_TCP_CONTEXT_SECTION_WINDOW_SATURATED_SHIFT 13
-#define XSTORM_TCP_CONTEXT_SECTION_SLOWPATH_QUEUES_FLUSH_COUNTER (0x3<<14)
-#define XSTORM_TCP_CONTEXT_SECTION_SLOWPATH_QUEUES_FLUSH_COUNTER_SHIFT 14
-#elif defined(__LITTLE_ENDIAN)
-	u16 tcp_params;
-#define XSTORM_TCP_CONTEXT_SECTION_TOTAL_HEADER_SIZE (0xFF<<0)
-#define XSTORM_TCP_CONTEXT_SECTION_TOTAL_HEADER_SIZE_SHIFT 0
-#define __XSTORM_TCP_CONTEXT_SECTION_ECT_BIT (0x1<<8)
-#define __XSTORM_TCP_CONTEXT_SECTION_ECT_BIT_SHIFT 8
-#define __XSTORM_TCP_CONTEXT_SECTION_ECN_ENABLED (0x1<<9)
-#define __XSTORM_TCP_CONTEXT_SECTION_ECN_ENABLED_SHIFT 9
-#define XSTORM_TCP_CONTEXT_SECTION_SACK_ENABLED (0x1<<10)
-#define XSTORM_TCP_CONTEXT_SECTION_SACK_ENABLED_SHIFT 10
-#define XSTORM_TCP_CONTEXT_SECTION_KA_STATE (0x1<<11)
-#define XSTORM_TCP_CONTEXT_SECTION_KA_STATE_SHIFT 11
-#define XSTORM_TCP_CONTEXT_SECTION_FIN_SENT_FLAG (0x1<<12)
-#define XSTORM_TCP_CONTEXT_SECTION_FIN_SENT_FLAG_SHIFT 12
-#define XSTORM_TCP_CONTEXT_SECTION_WINDOW_SATURATED (0x1<<13)
-#define XSTORM_TCP_CONTEXT_SECTION_WINDOW_SATURATED_SHIFT 13
-#define XSTORM_TCP_CONTEXT_SECTION_SLOWPATH_QUEUES_FLUSH_COUNTER (0x3<<14)
-#define XSTORM_TCP_CONTEXT_SECTION_SLOWPATH_QUEUES_FLUSH_COUNTER_SHIFT 14
-	u8 ts_enabled_1b;
-	u8 original_nagle_1b;
-#endif
-#if defined(__BIG_ENDIAN)
-	u16 pseudo_csum;
-	u16 window_scaling_factor;
-#elif defined(__LITTLE_ENDIAN)
-	u16 window_scaling_factor;
-	u16 pseudo_csum;
-#endif
-	u32 reserved2;
-	u32 ts_time_diff;
-	u32 __next_timer_expir;
-};
-
-/*
- * Common context section, shared in TOE, RDMA and ISCSI
- */
-struct xstorm_common_context_section {
-	struct xstorm_eth_context_section ethernet;
-	union xstorm_ip_context_section_types ip_union;
-	struct xstorm_tcp_context_section tcp;
-#if defined(__BIG_ENDIAN)
-	u16 reserved;
-	u8 statistics_params;
-#define XSTORM_COMMON_CONTEXT_SECTION_UPDATE_L2_STATSTICS (0x1<<0)
-#define XSTORM_COMMON_CONTEXT_SECTION_UPDATE_L2_STATSTICS_SHIFT 0
-#define XSTORM_COMMON_CONTEXT_SECTION_UPDATE_L4_STATSTICS (0x1<<1)
-#define XSTORM_COMMON_CONTEXT_SECTION_UPDATE_L4_STATSTICS_SHIFT 1
-#define XSTORM_COMMON_CONTEXT_SECTION_STATISTICS_COUNTER_ID (0x1F<<2)
-#define XSTORM_COMMON_CONTEXT_SECTION_STATISTICS_COUNTER_ID_SHIFT 2
-#define XSTORM_COMMON_CONTEXT_SECTION_RESERVED0 (0x1<<7)
-#define XSTORM_COMMON_CONTEXT_SECTION_RESERVED0_SHIFT 7
-	u8 ip_version_1b;
-#elif defined(__LITTLE_ENDIAN)
-	u8 ip_version_1b;
-	u8 statistics_params;
-#define XSTORM_COMMON_CONTEXT_SECTION_UPDATE_L2_STATSTICS (0x1<<0)
-#define XSTORM_COMMON_CONTEXT_SECTION_UPDATE_L2_STATSTICS_SHIFT 0
-#define XSTORM_COMMON_CONTEXT_SECTION_UPDATE_L4_STATSTICS (0x1<<1)
-#define XSTORM_COMMON_CONTEXT_SECTION_UPDATE_L4_STATSTICS_SHIFT 1
-#define XSTORM_COMMON_CONTEXT_SECTION_STATISTICS_COUNTER_ID (0x1F<<2)
-#define XSTORM_COMMON_CONTEXT_SECTION_STATISTICS_COUNTER_ID_SHIFT 2
-#define XSTORM_COMMON_CONTEXT_SECTION_RESERVED0 (0x1<<7)
-#define XSTORM_COMMON_CONTEXT_SECTION_RESERVED0_SHIFT 7
-	u16 reserved;
-#endif
-};
-
-/*
- * Flags used in ISCSI context section
- */
-struct xstorm_iscsi_context_flags {
-	u8 flags;
-#define XSTORM_ISCSI_CONTEXT_FLAGS_B_IMMEDIATE_DATA (0x1<<0)
-#define XSTORM_ISCSI_CONTEXT_FLAGS_B_IMMEDIATE_DATA_SHIFT 0
-#define XSTORM_ISCSI_CONTEXT_FLAGS_B_INITIAL_R2T (0x1<<1)
-#define XSTORM_ISCSI_CONTEXT_FLAGS_B_INITIAL_R2T_SHIFT 1
-#define XSTORM_ISCSI_CONTEXT_FLAGS_B_EN_HEADER_DIGEST (0x1<<2)
-#define XSTORM_ISCSI_CONTEXT_FLAGS_B_EN_HEADER_DIGEST_SHIFT 2
-#define XSTORM_ISCSI_CONTEXT_FLAGS_B_EN_DATA_DIGEST (0x1<<3)
-#define XSTORM_ISCSI_CONTEXT_FLAGS_B_EN_DATA_DIGEST_SHIFT 3
-#define XSTORM_ISCSI_CONTEXT_FLAGS_B_HQ_BD_WRITTEN (0x1<<4)
-#define XSTORM_ISCSI_CONTEXT_FLAGS_B_HQ_BD_WRITTEN_SHIFT 4
-#define XSTORM_ISCSI_CONTEXT_FLAGS_B_LAST_OP_SQ (0x1<<5)
-#define XSTORM_ISCSI_CONTEXT_FLAGS_B_LAST_OP_SQ_SHIFT 5
-#define XSTORM_ISCSI_CONTEXT_FLAGS_B_UPDATE_SND_NXT (0x1<<6)
-#define XSTORM_ISCSI_CONTEXT_FLAGS_B_UPDATE_SND_NXT_SHIFT 6
-#define XSTORM_ISCSI_CONTEXT_FLAGS_RESERVED4 (0x1<<7)
-#define XSTORM_ISCSI_CONTEXT_FLAGS_RESERVED4_SHIFT 7
-};
-
-struct iscsi_task_context_entry_x {
-	u32 data_out_buffer_offset;
-	u32 itt;
-	u32 data_sn;
-};
-
-struct iscsi_task_context_entry_xuc_x_write_only {
-	u32 tx_r2t_sn;
-};
-
-struct iscsi_task_context_entry_xuc_xu_write_both {
-	u32 sgl_base_lo;
-	u32 sgl_base_hi;
-#if defined(__BIG_ENDIAN)
-	u8 sgl_size;
-	u8 sge_index;
-	u16 sge_offset;
-#elif defined(__LITTLE_ENDIAN)
-	u16 sge_offset;
-	u8 sge_index;
-	u8 sgl_size;
-#endif
-};
-
-/*
- * iSCSI context section
- */
-struct xstorm_iscsi_context_section {
-	u32 first_burst_length;
-	u32 max_send_pdu_length;
-	struct regpair sq_pbl_base;
-	struct regpair sq_curr_pbe;
-	struct regpair hq_pbl_base;
-	struct regpair hq_curr_pbe_base;
-	struct regpair r2tq_pbl_base;
-	struct regpair r2tq_curr_pbe_base;
-	struct regpair task_pbl_base;
-#if defined(__BIG_ENDIAN)
-	u16 data_out_count;
-	struct xstorm_iscsi_context_flags flags;
-	u8 task_pbl_cache_idx;
-#elif defined(__LITTLE_ENDIAN)
-	u8 task_pbl_cache_idx;
-	struct xstorm_iscsi_context_flags flags;
-	u16 data_out_count;
-#endif
-	u32 seq_more_2_send;
-	u32 pdu_more_2_send;
-	struct iscsi_task_context_entry_x temp_tce_x;
-	struct iscsi_task_context_entry_xuc_x_write_only temp_tce_x_wr;
-	struct iscsi_task_context_entry_xuc_xu_write_both temp_tce_xu_wr;
-	struct regpair lun;
-	u32 exp_data_transfer_len_ttt;
-	u32 pdu_data_2_rxmit;
-	u32 rxmit_bytes_2_dr;
-#if defined(__BIG_ENDIAN)
-	u16 rxmit_sge_offset;
-	u16 hq_rxmit_cons;
-#elif defined(__LITTLE_ENDIAN)
-	u16 hq_rxmit_cons;
-	u16 rxmit_sge_offset;
-#endif
-#if defined(__BIG_ENDIAN)
-	u16 r2tq_cons;
-	u8 rxmit_flags;
-#define XSTORM_ISCSI_CONTEXT_SECTION_B_NEW_HQ_BD (0x1<<0)
-#define XSTORM_ISCSI_CONTEXT_SECTION_B_NEW_HQ_BD_SHIFT 0
-#define XSTORM_ISCSI_CONTEXT_SECTION_B_RXMIT_PDU_HDR (0x1<<1)
-#define XSTORM_ISCSI_CONTEXT_SECTION_B_RXMIT_PDU_HDR_SHIFT 1
-#define XSTORM_ISCSI_CONTEXT_SECTION_B_RXMIT_END_PDU (0x1<<2)
-#define XSTORM_ISCSI_CONTEXT_SECTION_B_RXMIT_END_PDU_SHIFT 2
-#define XSTORM_ISCSI_CONTEXT_SECTION_B_RXMIT_DR (0x1<<3)
-#define XSTORM_ISCSI_CONTEXT_SECTION_B_RXMIT_DR_SHIFT 3
-#define XSTORM_ISCSI_CONTEXT_SECTION_B_RXMIT_START_DR (0x1<<4)
-#define XSTORM_ISCSI_CONTEXT_SECTION_B_RXMIT_START_DR_SHIFT 4
-#define XSTORM_ISCSI_CONTEXT_SECTION_B_RXMIT_PADDING (0x3<<5)
-#define XSTORM_ISCSI_CONTEXT_SECTION_B_RXMIT_PADDING_SHIFT 5
-#define XSTORM_ISCSI_CONTEXT_SECTION_B_ISCSI_CONT_FAST_RXMIT (0x1<<7)
-#define XSTORM_ISCSI_CONTEXT_SECTION_B_ISCSI_CONT_FAST_RXMIT_SHIFT 7
-	u8 rxmit_sge_idx;
-#elif defined(__LITTLE_ENDIAN)
-	u8 rxmit_sge_idx;
-	u8 rxmit_flags;
-#define XSTORM_ISCSI_CONTEXT_SECTION_B_NEW_HQ_BD (0x1<<0)
-#define XSTORM_ISCSI_CONTEXT_SECTION_B_NEW_HQ_BD_SHIFT 0
-#define XSTORM_ISCSI_CONTEXT_SECTION_B_RXMIT_PDU_HDR (0x1<<1)
-#define XSTORM_ISCSI_CONTEXT_SECTION_B_RXMIT_PDU_HDR_SHIFT 1
-#define XSTORM_ISCSI_CONTEXT_SECTION_B_RXMIT_END_PDU (0x1<<2)
-#define XSTORM_ISCSI_CONTEXT_SECTION_B_RXMIT_END_PDU_SHIFT 2
-#define XSTORM_ISCSI_CONTEXT_SECTION_B_RXMIT_DR (0x1<<3)
-#define XSTORM_ISCSI_CONTEXT_SECTION_B_RXMIT_DR_SHIFT 3
-#define XSTORM_ISCSI_CONTEXT_SECTION_B_RXMIT_START_DR (0x1<<4)
-#define XSTORM_ISCSI_CONTEXT_SECTION_B_RXMIT_START_DR_SHIFT 4
-#define XSTORM_ISCSI_CONTEXT_SECTION_B_RXMIT_PADDING (0x3<<5)
-#define XSTORM_ISCSI_CONTEXT_SECTION_B_RXMIT_PADDING_SHIFT 5
-#define XSTORM_ISCSI_CONTEXT_SECTION_B_ISCSI_CONT_FAST_RXMIT (0x1<<7)
-#define XSTORM_ISCSI_CONTEXT_SECTION_B_ISCSI_CONT_FAST_RXMIT_SHIFT 7
-	u16 r2tq_cons;
-#endif
-	u32 hq_rxmit_tcp_seq;
-};
-
-/*
- * Xstorm iSCSI Storm Context
- */
-struct xstorm_iscsi_st_context {
-	struct xstorm_common_context_section common;
-	struct xstorm_iscsi_context_section iscsi;
-};
-
-/*
- * CQ DB CQ producer and pending completion counter
- */
-struct iscsi_cq_db_prod_pnd_cmpltn_cnt {
-#if defined(__BIG_ENDIAN)
-	u16 cntr;
-	u16 prod;
-#elif defined(__LITTLE_ENDIAN)
-	u16 prod;
-	u16 cntr;
-#endif
-};
-
-/*
- * CQ DB pending completion ITT array
- */
-struct iscsi_cq_db_prod_pnd_cmpltn_cnt_arr {
-	struct iscsi_cq_db_prod_pnd_cmpltn_cnt prod_pend_comp[8];
-};
-
-/*
- * Cstorm CQ sequence to notify array, updated by driver
- */
-struct iscsi_cq_db_sqn_2_notify_arr {
-	u16 sqn[8];
-};
-
-/*
- * Cstorm iSCSI Storm Context
- */
-struct cstorm_iscsi_st_context {
-	struct iscsi_cq_db_prod_pnd_cmpltn_cnt_arr cq_c_prod_pend_comp_ctr_arr;
-	struct iscsi_cq_db_sqn_2_notify_arr cq_c_prod_sqn_arr;
-	struct iscsi_cq_db_sqn_2_notify_arr cq_c_sqn_2_notify_arr;
-	struct regpair hq_pbl_base;
-	struct regpair hq_curr_pbe;
-	struct regpair task_pbl_base;
-	struct regpair cq_db_base;
-#if defined(__BIG_ENDIAN)
-	u16 hq_bd_itt;
-	u16 iscsi_conn_id;
-#elif defined(__LITTLE_ENDIAN)
-	u16 iscsi_conn_id;
-	u16 hq_bd_itt;
-#endif
-	u32 hq_bd_data_segment_len;
-	u32 hq_bd_buffer_offset;
-#if defined(__BIG_ENDIAN)
-	u8 timer_entry_idx;
-	u8 cq_proc_en_bit_map;
-	u8 cq_pend_comp_itt_valid_bit_map;
-	u8 hq_bd_opcode;
-#elif defined(__LITTLE_ENDIAN)
-	u8 hq_bd_opcode;
-	u8 cq_pend_comp_itt_valid_bit_map;
-	u8 cq_proc_en_bit_map;
-	u8 timer_entry_idx;
-#endif
-	u32 hq_tcp_seq;
-#if defined(__BIG_ENDIAN)
-	u16 flags;
-#define CSTORM_ISCSI_ST_CONTEXT_DATA_DIGEST_EN (0x1<<0)
-#define CSTORM_ISCSI_ST_CONTEXT_DATA_DIGEST_EN_SHIFT 0
-#define CSTORM_ISCSI_ST_CONTEXT_HDR_DIGEST_EN (0x1<<1)
-#define CSTORM_ISCSI_ST_CONTEXT_HDR_DIGEST_EN_SHIFT 1
-#define CSTORM_ISCSI_ST_CONTEXT_HQ_BD_CTXT_VALID (0x1<<2)
-#define CSTORM_ISCSI_ST_CONTEXT_HQ_BD_CTXT_VALID_SHIFT 2
-#define CSTORM_ISCSI_ST_CONTEXT_HQ_BD_LCL_CMPLN_FLG (0x1<<3)
-#define CSTORM_ISCSI_ST_CONTEXT_HQ_BD_LCL_CMPLN_FLG_SHIFT 3
-#define CSTORM_ISCSI_ST_CONTEXT_HQ_BD_WRITE_TASK (0x1<<4)
-#define CSTORM_ISCSI_ST_CONTEXT_HQ_BD_WRITE_TASK_SHIFT 4
-#define CSTORM_ISCSI_ST_CONTEXT_CTRL_FLAGS_RSRV (0x7FF<<5)
-#define CSTORM_ISCSI_ST_CONTEXT_CTRL_FLAGS_RSRV_SHIFT 5
-	u16 hq_cons;
-#elif defined(__LITTLE_ENDIAN)
-	u16 hq_cons;
-	u16 flags;
-#define CSTORM_ISCSI_ST_CONTEXT_DATA_DIGEST_EN (0x1<<0)
-#define CSTORM_ISCSI_ST_CONTEXT_DATA_DIGEST_EN_SHIFT 0
-#define CSTORM_ISCSI_ST_CONTEXT_HDR_DIGEST_EN (0x1<<1)
-#define CSTORM_ISCSI_ST_CONTEXT_HDR_DIGEST_EN_SHIFT 1
-#define CSTORM_ISCSI_ST_CONTEXT_HQ_BD_CTXT_VALID (0x1<<2)
-#define CSTORM_ISCSI_ST_CONTEXT_HQ_BD_CTXT_VALID_SHIFT 2
-#define CSTORM_ISCSI_ST_CONTEXT_HQ_BD_LCL_CMPLN_FLG (0x1<<3)
-#define CSTORM_ISCSI_ST_CONTEXT_HQ_BD_LCL_CMPLN_FLG_SHIFT 3
-#define CSTORM_ISCSI_ST_CONTEXT_HQ_BD_WRITE_TASK (0x1<<4)
-#define CSTORM_ISCSI_ST_CONTEXT_HQ_BD_WRITE_TASK_SHIFT 4
-#define CSTORM_ISCSI_ST_CONTEXT_CTRL_FLAGS_RSRV (0x7FF<<5)
-#define CSTORM_ISCSI_ST_CONTEXT_CTRL_FLAGS_RSRV_SHIFT 5
-#endif
-	struct regpair rsrv1;
-};
-
-/*
- * Iscsi connection context
- */
-struct iscsi_context {
-	struct ustorm_iscsi_st_context ustorm_st_context;
-	struct tstorm_iscsi_st_context tstorm_st_context;
-	struct xstorm_iscsi_ag_context xstorm_ag_context;
-	struct tstorm_iscsi_ag_context tstorm_ag_context;
-	struct cstorm_iscsi_ag_context cstorm_ag_context;
-	struct ustorm_iscsi_ag_context ustorm_ag_context;
-	struct iscsi_timers_block_context timers_context;
-	struct regpair upb_context;
-	struct xstorm_iscsi_st_context xstorm_st_context;
-	struct regpair xpb_context;
-	struct cstorm_iscsi_st_context cstorm_st_context;
-};
-
-/*
- * Buffer per connection, used in Tstorm
- */
-struct iscsi_conn_buf {
-	struct regpair reserved[8];
-};
-
-/*
- * ipv6 structure
- */
-struct ip_v6_addr {
-	u32 ip_addr_lo_lo;
-	u32 ip_addr_lo_hi;
-	u32 ip_addr_hi_lo;
-	u32 ip_addr_hi_hi;
-};
-
-/*
- * l5cm- connection identification params
- */
-struct l5cm_conn_addr_params {
-	u32 pmtu;
-#if defined(__BIG_ENDIAN)
-	u8 remote_addr_3;
-	u8 remote_addr_2;
-	u8 remote_addr_1;
-	u8 remote_addr_0;
-#elif defined(__LITTLE_ENDIAN)
-	u8 remote_addr_0;
-	u8 remote_addr_1;
-	u8 remote_addr_2;
-	u8 remote_addr_3;
-#endif
-#if defined(__BIG_ENDIAN)
-	u16 params;
-#define L5CM_CONN_ADDR_PARAMS_IP_VERSION (0x1<<0)
-#define L5CM_CONN_ADDR_PARAMS_IP_VERSION_SHIFT 0
-#define L5CM_CONN_ADDR_PARAMS_RSRV (0x7FFF<<1)
-#define L5CM_CONN_ADDR_PARAMS_RSRV_SHIFT 1
-	u8 remote_addr_5;
-	u8 remote_addr_4;
-#elif defined(__LITTLE_ENDIAN)
-	u8 remote_addr_4;
-	u8 remote_addr_5;
-	u16 params;
-#define L5CM_CONN_ADDR_PARAMS_IP_VERSION (0x1<<0)
-#define L5CM_CONN_ADDR_PARAMS_IP_VERSION_SHIFT 0
-#define L5CM_CONN_ADDR_PARAMS_RSRV (0x7FFF<<1)
-#define L5CM_CONN_ADDR_PARAMS_RSRV_SHIFT 1
-#endif
-	struct ip_v6_addr local_ip_addr;
-	struct ip_v6_addr remote_ip_addr;
-	u32 ipv6_flow_label_20b;
-	u32 reserved1;
-#if defined(__BIG_ENDIAN)
-	u16 remote_tcp_port;
-	u16 local_tcp_port;
-#elif defined(__LITTLE_ENDIAN)
-	u16 local_tcp_port;
-	u16 remote_tcp_port;
-#endif
-};
-
-/*
- * l5cm-xstorm connection buffer
- */
-struct l5cm_xstorm_conn_buffer {
-#if defined(__BIG_ENDIAN)
-	u16 rsrv1;
-	u16 params;
-#define L5CM_XSTORM_CONN_BUFFER_NAGLE_ENABLE (0x1<<0)
-#define L5CM_XSTORM_CONN_BUFFER_NAGLE_ENABLE_SHIFT 0
-#define L5CM_XSTORM_CONN_BUFFER_RSRV (0x7FFF<<1)
-#define L5CM_XSTORM_CONN_BUFFER_RSRV_SHIFT 1
-#elif defined(__LITTLE_ENDIAN)
-	u16 params;
-#define L5CM_XSTORM_CONN_BUFFER_NAGLE_ENABLE (0x1<<0)
-#define L5CM_XSTORM_CONN_BUFFER_NAGLE_ENABLE_SHIFT 0
-#define L5CM_XSTORM_CONN_BUFFER_RSRV (0x7FFF<<1)
-#define L5CM_XSTORM_CONN_BUFFER_RSRV_SHIFT 1
-	u16 rsrv1;
-#endif
-#if defined(__BIG_ENDIAN)
-	u16 mss;
-	u16 pseudo_header_checksum;
-#elif defined(__LITTLE_ENDIAN)
-	u16 pseudo_header_checksum;
-	u16 mss;
-#endif
-	u32 rcv_buf;
-	u32 rsrv2;
-	struct regpair context_addr;
-};
-
-/*
- * l5cm-tstorm connection buffer
- */
-struct l5cm_tstorm_conn_buffer {
-	u32 snd_buf;
-	u32 rcv_buf;
-#if defined(__BIG_ENDIAN)
-	u16 params;
-#define L5CM_TSTORM_CONN_BUFFER_DELAYED_ACK_ENABLE (0x1<<0)
-#define L5CM_TSTORM_CONN_BUFFER_DELAYED_ACK_ENABLE_SHIFT 0
-#define L5CM_TSTORM_CONN_BUFFER_RSRV (0x7FFF<<1)
-#define L5CM_TSTORM_CONN_BUFFER_RSRV_SHIFT 1
-	u8 ka_max_probe_count;
-	u8 ka_enable;
-#elif defined(__LITTLE_ENDIAN)
-	u8 ka_enable;
-	u8 ka_max_probe_count;
-	u16 params;
-#define L5CM_TSTORM_CONN_BUFFER_DELAYED_ACK_ENABLE (0x1<<0)
-#define L5CM_TSTORM_CONN_BUFFER_DELAYED_ACK_ENABLE_SHIFT 0
-#define L5CM_TSTORM_CONN_BUFFER_RSRV (0x7FFF<<1)
-#define L5CM_TSTORM_CONN_BUFFER_RSRV_SHIFT 1
-#endif
-	u32 ka_timeout;
-	u32 ka_interval;
-	u32 max_rt_time;
-};
-
-/*
- * l5cm connection buffer for active side
- */
-struct l5cm_active_conn_buffer {
-	struct l5cm_conn_addr_params conn_addr_buf;
-	struct l5cm_xstorm_conn_buffer xstorm_conn_buffer;
-	struct l5cm_tstorm_conn_buffer tstorm_conn_buffer;
-};
-
-/*
- * l5cm slow path element
- */
-struct l5cm_packet_size {
-	u32 size;
-	u32 rsrv;
-};
-
-/*
- * l5cm connection parameters
- */
-union l5cm_reduce_param_union {
-	u32 passive_side_scramble_key;
-	u32 pcs_id;
-};
-
-/*
- * l5cm connection parameters
- */
-struct l5cm_reduce_conn {
-	union l5cm_reduce_param_union param;
-	u32 isn;
-};
-
-/*
- * l5cm slow path element
- */
-union l5cm_specific_data {
-	u8 protocol_data[8];
-	struct regpair phy_address;
-	struct l5cm_packet_size packet_size;
-	struct l5cm_reduce_conn reduced_conn;
-};
-
-/*
- * l5 slow path element
- */
-struct l5cm_spe {
-	struct spe_hdr hdr;
-	union l5cm_specific_data data;
-};
-
-/*
- * Tstorm Tcp flags
- */
-struct tstorm_l5cm_tcp_flags {
-	u16 flags;
-#define TSTORM_L5CM_TCP_FLAGS_VLAN_ID (0xFFF<<0)
-#define TSTORM_L5CM_TCP_FLAGS_VLAN_ID_SHIFT 0
-#define TSTORM_L5CM_TCP_FLAGS_RSRV0 (0x1<<12)
-#define TSTORM_L5CM_TCP_FLAGS_RSRV0_SHIFT 12
-#define TSTORM_L5CM_TCP_FLAGS_TS_ENABLED (0x1<<13)
-#define TSTORM_L5CM_TCP_FLAGS_TS_ENABLED_SHIFT 13
-#define TSTORM_L5CM_TCP_FLAGS_RSRV1 (0x3<<14)
-#define TSTORM_L5CM_TCP_FLAGS_RSRV1_SHIFT 14
-};
-
-/*
- * Xstorm Tcp flags
- */
-struct xstorm_l5cm_tcp_flags {
-	u8 flags;
-#define XSTORM_L5CM_TCP_FLAGS_ENC_ENABLED (0x1<<0)
-#define XSTORM_L5CM_TCP_FLAGS_ENC_ENABLED_SHIFT 0
-#define XSTORM_L5CM_TCP_FLAGS_TS_ENABLED (0x1<<1)
-#define XSTORM_L5CM_TCP_FLAGS_TS_ENABLED_SHIFT 1
-#define XSTORM_L5CM_TCP_FLAGS_WND_SCL_EN (0x1<<2)
-#define XSTORM_L5CM_TCP_FLAGS_WND_SCL_EN_SHIFT 2
-#define XSTORM_L5CM_TCP_FLAGS_RSRV (0x1F<<3)
-#define XSTORM_L5CM_TCP_FLAGS_RSRV_SHIFT 3
-};
-
-#endif /* CNIC_DEFS_H */
diff -r f4bf81a7ff20 drivers/net/cnic_if.h
--- a/drivers/net/cnic_if.h
+++ /dev/null
@@ -1,312 +0,0 @@
-/* cnic_if.h: Broadcom CNIC core network driver.
- *
- * Copyright (c) 2006 Broadcom Corporation
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation.
- *
- */
-
-
-#ifndef CNIC_IF_H
-#define CNIC_IF_H
-
-#define CNIC_MODULE_VERSION	"2.1.0"
-#define CNIC_MODULE_RELDATE	"Oct 10, 2009"
-
-#define CNIC_ULP_RDMA		0
-#define CNIC_ULP_ISCSI		1
-#define CNIC_ULP_L4		2
-#define MAX_CNIC_ULP_TYPE_EXT	2
-#define MAX_CNIC_ULP_TYPE	3
-
-struct kwqe {
-	u32 kwqe_op_flag;
-
-#define KWQE_OPCODE_MASK	0x00ff0000
-#define KWQE_OPCODE_SHIFT	16
-#define KWQE_FLAGS_LAYER_SHIFT	28
-#define KWQE_OPCODE(x)		((x & KWQE_OPCODE_MASK) >> KWQE_OPCODE_SHIFT)
-
-	u32 kwqe_info0;
-	u32 kwqe_info1;
-	u32 kwqe_info2;
-	u32 kwqe_info3;
-	u32 kwqe_info4;
-	u32 kwqe_info5;
-	u32 kwqe_info6;
-};
-
-struct kwqe_16 {
-	u32 kwqe_info0;
-	u32 kwqe_info1;
-	u32 kwqe_info2;
-	u32 kwqe_info3;
-};
-
-struct kcqe {
-	u32 kcqe_info0;
-	u32 kcqe_info1;
-	u32 kcqe_info2;
-	u32 kcqe_info3;
-	u32 kcqe_info4;
-	u32 kcqe_info5;
-	u32 kcqe_info6;
-	u32 kcqe_op_flag;
-		#define KCQE_RAMROD_COMPLETION		(0x1<<27) /* Everest */
-		#define KCQE_FLAGS_LAYER_MASK		(0x7<<28)
-		#define KCQE_FLAGS_LAYER_MASK_MISC	(0<<28)
-		#define KCQE_FLAGS_LAYER_MASK_L2	(2<<28)
-		#define KCQE_FLAGS_LAYER_MASK_L3	(3<<28)
-		#define KCQE_FLAGS_LAYER_MASK_L4	(4<<28)
-		#define KCQE_FLAGS_LAYER_MASK_L5_RDMA	(5<<28)
-		#define KCQE_FLAGS_LAYER_MASK_L5_ISCSI	(6<<28)
-		#define KCQE_FLAGS_NEXT 		(1<<31)
-		#define KCQE_FLAGS_OPCODE_MASK		(0xff<<16)
-		#define KCQE_FLAGS_OPCODE_SHIFT		(16)
-		#define KCQE_OPCODE(op)			\
-		(((op) & KCQE_FLAGS_OPCODE_MASK) >> KCQE_FLAGS_OPCODE_SHIFT)
-};
-
-#define MAX_CNIC_CTL_DATA	64
-#define MAX_DRV_CTL_DATA	64
-
-#define CNIC_CTL_STOP_CMD		1
-#define CNIC_CTL_START_CMD		2
-#define CNIC_CTL_COMPLETION_CMD		3
-
-#define DRV_CTL_IO_WR_CMD		0x101
-#define DRV_CTL_IO_RD_CMD		0x102
-#define DRV_CTL_CTX_WR_CMD		0x103
-#define DRV_CTL_CTXTBL_WR_CMD		0x104
-#define DRV_CTL_COMPLETION_CMD		0x105
-#define DRV_CTL_START_L2_CMD		0x106
-#define DRV_CTL_STOP_L2_CMD		0x107
-
-struct cnic_ctl_completion {
-	u32	cid;
-};
-
-struct drv_ctl_completion {
-	u32	comp_count;
-};
-
-struct cnic_ctl_info {
-	int	cmd;
-	union {
-		struct cnic_ctl_completion comp;
-		char bytes[MAX_CNIC_CTL_DATA];
-	} data;
-};
-
-struct drv_ctl_io {
-	u32		cid_addr;
-	u32		offset;
-	u32		data;
-	dma_addr_t	dma_addr;
-};
-
-struct drv_ctl_l2_ring {
-	u32		client_id;
-	u32		cid;
-};
-
-struct drv_ctl_info {
-	int	cmd;
-	union {
-		struct drv_ctl_completion comp;
-		struct drv_ctl_io io;
-		struct drv_ctl_l2_ring ring;
-		char bytes[MAX_DRV_CTL_DATA];
-	} data;
-};
-
-struct cnic_ops {
-	struct module	*cnic_owner;
-	/* Calls to these functions are protected by RCU.  When
-	 * unregistering, we wait for any calls to complete before
-	 * continuing.
-	 */
-	int		(*cnic_handler)(void *, void *);
-	int		(*cnic_ctl)(void *, struct cnic_ctl_info *);
-};
-
-#define MAX_CNIC_VEC	8
-
-struct cnic_irq {
-	unsigned int	vector;
-	void		*status_blk;
-	u32		status_blk_num;
-	u32		irq_flags;
-#define CNIC_IRQ_FL_MSIX		0x00000001
-};
-
-struct cnic_eth_dev {
-	struct module	*drv_owner;
-	u32		drv_state;
-#define CNIC_DRV_STATE_REGD		0x00000001
-#define CNIC_DRV_STATE_USING_MSIX	0x00000002
-	u32		chip_id;
-	u32		max_kwqe_pending;
-	struct pci_dev	*pdev;
-	void __iomem	*io_base;
-	void __iomem	*io_base2;
-
-	u32		ctx_tbl_offset;
-	u32		ctx_tbl_len;
-	int		ctx_blk_size;
-	u32		starting_cid;
-	u32		max_iscsi_conn;
-	u32		max_fcoe_conn;
-	u32		max_rdma_conn;
-	u32		reserved0[2];
-
-	int		num_irq;
-	struct cnic_irq	irq_arr[MAX_CNIC_VEC];
-	int		(*drv_register_cnic)(struct net_device *,
-					     struct cnic_ops *, void *);
-	int		(*drv_unregister_cnic)(struct net_device *);
-	int		(*drv_submit_kwqes_32)(struct net_device *,
-					       struct kwqe *[], u32);
-	int		(*drv_submit_kwqes_16)(struct net_device *,
-					       struct kwqe_16 *[], u32);
-	int		(*drv_ctl)(struct net_device *, struct drv_ctl_info *);
-	unsigned long	reserved1[2];
-};
-
-struct cnic_sockaddr {
-	union {
-		struct sockaddr_in	v4;
-		struct sockaddr_in6	v6;
-	} local;
-	union {
-		struct sockaddr_in	v4;
-		struct sockaddr_in6	v6;
-	} remote;
-};
-
-struct cnic_sock {
-	struct cnic_dev *dev;
-	void	*context;
-	u32	src_ip[4];
-	u32	dst_ip[4];
-	u16	src_port;
-	u16	dst_port;
-	u16	vlan_id;
-	unsigned char old_ha[6];
-	unsigned char ha[6];
-	u32	mtu;
-	u32	cid;
-	u32	l5_cid;
-	u32	pg_cid;
-	int	ulp_type;
-
-	u32	ka_timeout;
-	u32	ka_interval;
-	u8	ka_max_probe_count;
-	u8	tos;
-	u8	ttl;
-	u8	snd_seq_scale;
-	u32	rcv_buf;
-	u32	snd_buf;
-	u32	seed;
-
-	unsigned long	tcp_flags;
-#define SK_TCP_NO_DELAY_ACK	0x1
-#define SK_TCP_KEEP_ALIVE	0x2
-#define SK_TCP_NAGLE		0x4
-#define SK_TCP_TIMESTAMP	0x8
-#define SK_TCP_SACK		0x10
-#define SK_TCP_SEG_SCALING	0x20
-	unsigned long	flags;
-#define SK_F_INUSE		0
-#define SK_F_OFFLD_COMPLETE	1
-#define SK_F_OFFLD_SCHED	2
-#define SK_F_PG_OFFLD_COMPLETE	3
-#define SK_F_CONNECT_START	4
-#define SK_F_IPV6		5
-#define SK_F_CLOSING		7
-
-	atomic_t ref_count;
-	u32 state;
-	struct kwqe kwqe1;
-	struct kwqe kwqe2;
-	struct kwqe kwqe3;
-};
-
-struct cnic_dev {
-	struct net_device	*netdev;
-	struct pci_dev		*pcidev;
-	void __iomem		*regview;
-	struct list_head	list;
-
-	int (*register_device)(struct cnic_dev *dev, int ulp_type,
-			       void *ulp_ctx);
-	int (*unregister_device)(struct cnic_dev *dev, int ulp_type);
-	int (*submit_kwqes)(struct cnic_dev *dev, struct kwqe *wqes[],
-				u32 num_wqes);
-	int (*submit_kwqes_16)(struct cnic_dev *dev, struct kwqe_16 *wqes[],
-				u32 num_wqes);
-
-	int (*cm_create)(struct cnic_dev *, int, u32, u32, struct cnic_sock **,
-			 void *);
-	int (*cm_destroy)(struct cnic_sock *);
-	int (*cm_connect)(struct cnic_sock *, struct cnic_sockaddr *);
-	int (*cm_abort)(struct cnic_sock *);
-	int (*cm_close)(struct cnic_sock *);
-	struct cnic_dev *(*cm_select_dev)(struct sockaddr_in *, int ulp_type);
-	int (*iscsi_nl_msg_recv)(struct cnic_dev *dev, u32 msg_type,
-				 char *data, u16 data_size);
-	unsigned long	flags;
-#define CNIC_F_CNIC_UP		1
-#define CNIC_F_BNX2_CLASS	3
-#define CNIC_F_BNX2X_CLASS	4
-	atomic_t	ref_count;
-	u8		mac_addr[6];
-
-	int		max_iscsi_conn;
-	int		max_fcoe_conn;
-	int		max_rdma_conn;
-
-	void		*cnic_priv;
-};
-
-#define CNIC_WR(dev, off, val)		writel(val, dev->regview + off)
-#define CNIC_WR16(dev, off, val)	writew(val, dev->regview + off)
-#define CNIC_WR8(dev, off, val)		writeb(val, dev->regview + off)
-#define CNIC_RD(dev, off)		readl(dev->regview + off)
-#define CNIC_RD16(dev, off)		readw(dev->regview + off)
-
-struct cnic_ulp_ops {
-	/* Calls to these functions are protected by RCU.  When
-	 * unregistering, we wait for any calls to complete before
-	 * continuing.
-	 */
-
-	void (*cnic_init)(struct cnic_dev *dev);
-	void (*cnic_exit)(struct cnic_dev *dev);
-	void (*cnic_start)(void *ulp_ctx);
-	void (*cnic_stop)(void *ulp_ctx);
-	void (*indicate_kcqes)(void *ulp_ctx, struct kcqe *cqes[],
-				u32 num_cqes);
-	void (*indicate_netevent)(void *ulp_ctx, unsigned long event);
-	void (*cm_connect_complete)(struct cnic_sock *);
-	void (*cm_close_complete)(struct cnic_sock *);
-	void (*cm_abort_complete)(struct cnic_sock *);
-	void (*cm_remote_close)(struct cnic_sock *);
-	void (*cm_remote_abort)(struct cnic_sock *);
-	void (*iscsi_nl_send_msg)(struct cnic_dev *dev, u32 msg_type,
-				  char *data, u16 data_size);
-	struct module *owner;
-	atomic_t ref_count;
-};
-
-extern int cnic_register_driver(int ulp_type, struct cnic_ulp_ops *ulp_ops);
-
-extern int cnic_unregister_driver(int ulp_type);
-
-extern struct cnic_eth_dev *bnx2_cnic_probe(struct net_device *dev);
-extern struct cnic_eth_dev *bnx2x_cnic_probe(struct net_device *dev);
-
-#endif
