diff -r 6a4846854257 drivers/scsi/qla4xxx/Kconfig
--- a/drivers/scsi/qla4xxx/Kconfig	Mon Jan 11 10:15:26 2010 +0000
+++ b/drivers/scsi/qla4xxx/Kconfig	Mon Jan 11 11:15:25 2010 +0000
@@ -5,3 +5,8 @@
 	---help---
 	This driver supports the QLogic 40xx (ISP4XXX) iSCSI host 
 	adapter family.
+
+config QL4_IOCTLMOD
+        tristate
+        default (SCSI && PCI)
+        depends on SCSI && PCI
diff -r 6a4846854257 drivers/scsi/qla4xxx/Makefile
--- a/drivers/scsi/qla4xxx/Makefile	Mon Jan 11 10:15:26 2010 +0000
+++ b/drivers/scsi/qla4xxx/Makefile	Mon Jan 11 11:15:25 2010 +0000
@@ -3,3 +3,13 @@
 
 obj-$(CONFIG_SCSI_QLA_ISCSI) += qla4xxx.o
 
+qisioctl-y :=  ql4im_os.o ql4im_ioctl.o ql4im_dbg.o ql4im_dump.o
+
+obj-$(CONFIG_QL4_IOCTLMOD) += qisioctl.o
+
+CFLAGS_QISIOCTL += -DCONFIG_QL4_IOCTLMOD -DQLA_SLES11
+
+CFLAGS_ql4im_os.o += $(CFLAGS_QISIOCTL)
+CFLAGS_ql4im_ioctl.o += $(CFLAGS_QISIOCTL)
+CFLAGS_ql4im_dbg.o += $(CFLAGS_QISIOCTL)
+CFLAGS_ql4im_dump.o += $(CFLAGS_QISIOCTL)
diff -r 6a4846854257 drivers/scsi/qla4xxx/ql4im_dbg.c
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/drivers/scsi/qla4xxx/ql4im_dbg.c	Mon Jan 11 11:15:25 2010 +0000
@@ -0,0 +1,110 @@
+/*
+ * QLogic iSCSI HBA Driver
+ * Copyright (c)  2003-2006 QLogic Corporation
+ *
+ * See LICENSE.qla4xxx for copyright and licensing details.
+ */
+#include <linux/version.h>
+#include <linux/vmalloc.h>
+#include <linux/spinlock.h>
+#include <linux/module.h>
+#include <linux/timer.h>
+#include <linux/klist.h>
+
+#include "ql4_def.h"
+#include "ql4im_def.h"
+
+void dprt_hba_iscsi_portal(PEXT_HBA_ISCSI_PORTAL port)
+{
+	printk("\tIPAddr\t\t%d.%d.%d.%d\n", 
+		port->IPAddr.IPAddress[0],
+		port->IPAddr.IPAddress[1],
+		port->IPAddr.IPAddress[2],
+		port->IPAddr.IPAddress[3]);
+
+	printk("\tMACAddr\t\t%02x.%02x.%02x.%02x.%02x.%02x\n",
+		port->MacAddr[0],
+		port->MacAddr[1],
+		port->MacAddr[2],
+		port->MacAddr[3],
+		port->MacAddr[4],
+		port->MacAddr[5]);
+	printk("\tSerialNum\t0x%x\n", port->SerialNum);
+	printk("\tManufacturer\t%s\n", port->Manufacturer);
+	printk("\tModel\t\t%s\n", port->Model);
+	printk("\tDriverVersion\t%s\n", port->DriverVersion);
+	printk("\tFWVersion\t%s\n", port->FWVersion);
+	printk("\tOptRomVersion\t%s\n", port->OptRomVersion);
+	printk("\tState\t\t0x%x\n", port->State);
+	printk("\tType\t\t0x%x\n", port->Type);
+	printk("\tOptRomVersion\t0x%x\n", port->DriverAttr);
+	printk("\tFWAttr\t\t0x%x\n", port->FWAttr);
+	printk("\tDiscTargetCount\t0x%x\n", port->DiscTargetCount);
+}
+
+void dprt_chip_info(PEXT_CHIP_INFO pcinfo)
+{
+	printk("\tVendorId\t0x%x\n", pcinfo->VendorId);
+	printk("\tDeviceId\t0x%x\n", pcinfo->DeviceId);
+	printk("\tSubVendorId\t0x%x\n", pcinfo->SubVendorId);
+	printk("\tSubSystemId\t0x%x\n", pcinfo->SubSystemId);
+	printk("\tBoardID\t0x%x\n", pcinfo->BoardID);
+}
+
+void dprt_rw_flash(int rd, uint32_t offset, uint32_t len, uint32_t options)
+{
+	printk("\tDataLen 0x%08x", len);
+	if (!rd)
+		printk(" Options 0x%08x", options);
+	printk(" DataOffset 0x%08x", offset);
+	if (offset & INT_ISCSI_ACCESS_RAM)
+		printk(" RAM");
+	else
+		printk(" FLASH");
+	switch ((offset & INT_ISCSI_PAGE_MASK)) {
+		case INT_ISCSI_FW_IMAGE2_FLASH_OFFSET: 
+		printk(" FW Image 2\n");
+		break;
+		case INT_ISCSI_SYSINFO_FLASH_OFFSET: 
+		printk(" sysInfo\n");
+		break;
+		case INT_ISCSI_DRIVER_FLASH_OFFSET: 
+		printk(" driver\n");
+		break;
+		case INT_ISCSI_INITFW_FLASH_OFFSET: 
+		printk(" initfw\n");
+		break;
+		case INT_ISCSI_DDB_FLASH_OFFSET: 
+		printk(" ddb\n");
+		break;
+		case INT_ISCSI_CHAP_FLASH_OFFSET: 
+		printk(" CHAP\n");
+		break;
+		case INT_ISCSI_FW_IMAGE1_FLASH_OFFSET: 
+		printk(" FW Image 1\n");
+		break;
+		case INT_ISCSI_BIOS_FLASH_OFFSET: 
+		printk(" BIOS\n");
+		break;
+		default:
+		printk(" Illegal 0x%x\n",
+			(offset & INT_ISCSI_PAGE_MASK));
+		break;
+	}
+}
+
+void ql4_dump_buffer(unsigned char *buf, uint32_t len)
+{
+        uint32_t i;
+	uint32_t j, k;
+
+        for (i=0; i < len; i+=16) {
+                printk("0x%08x:", i);
+		k = len - i;
+		if (k >= 16) k = 16;
+		for (j = 0; j < k; j++) printk(" %02x", buf[i+j]);
+		printk("\n");
+        }
+}
+
+
diff -r 6a4846854257 drivers/scsi/qla4xxx/ql4im_dbg.h
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/drivers/scsi/qla4xxx/ql4im_dbg.h	Mon Jan 11 11:15:25 2010 +0000
@@ -0,0 +1,96 @@
+/*
+ * QLogic iSCSI HBA Driver ioctl module
+ * Copyright (c)  2003-2006 QLogic Corporation
+ *
+ * See LICENSE.qla4xxx for copyright and licensing details.
+ */
+
+#ifndef _QL4IM_DBG_H_ 
+#define _QL4IM_DBG_H_ 
+
+extern unsigned dbg_level;
+
+/*
+ * Driver debug definitions.
+ */
+
+#define QL_DBG_1	(1 << 0)
+#define QL_DBG_2	(1 << 1)
+#define QL_DBG_3	(1 << 2)
+#define QL_DBG_4	(1 << 3)
+#define QL_DBG_5	(1 << 4)
+#define QL_DBG_6	(1 << 5)
+#define QL_DBG_7	(1 << 6)
+#define QL_DBG_8	(1 << 7)
+#define QL_DBG_9	(1 << 8)
+#define QL_DBG_10	(1 << 9)
+#define QL_DBG_11	(1 << 10)
+#define QL_DBG_12	(1 << 11)
+
+#define QL_DEBUG
+
+#ifdef QL_DEBUG
+
+extern void dprt_hba_iscsi_portal(PEXT_HBA_ISCSI_PORTAL port);
+
+extern void dprt_chip_info(PEXT_CHIP_INFO pcinfo);
+extern void dprt_rw_flash(int rd, uint32_t offset, uint32_t len, uint32_t options);
+
+
+#define DEBUG1(x)	if (dbg_level & QL_DBG_1) {x;}
+#define DEBUG2(x)	if (dbg_level & QL_DBG_2) {x;}
+#define DEBUG3(x)	if (dbg_level & QL_DBG_3) {x;}
+#define DEBUG4(x)	if (dbg_level & QL_DBG_4) {x;}
+#define DEBUG5(x)	if (dbg_level & QL_DBG_5) {x;}
+#define DEBUG6(x)	if (dbg_level & QL_DBG_6) {x;}
+#define DEBUG7(x)	if (dbg_level & QL_DBG_7) {x;}
+#define DEBUG8(x)	if (dbg_level & QL_DBG_8) {x;}
+#define DEBUG9(x)	if (dbg_level & QL_DBG_9) {x;}
+#define DEBUG10(x)	if (dbg_level & QL_DBG_10) {x;}
+#define DEBUG11(x)	if (dbg_level & QL_DBG_11) {x;}
+#define DEBUG12(x)	if (dbg_level & QL_DBG_12) {x;}
+
+#define ENTER(x) 	DEBUG12(printk("qisioctl: Entering %s()\n", x))
+#define LEAVE(x) 	DEBUG12(printk("qisioctl: Leaving  %s()\n", x))
+
+#define ENTER_IOCTL(x,n) 	\
+	DEBUG12(printk("qisioctl(%d): Entering %s()\n", (int)n, x))
+
+#define LEAVE_IOCTL(x,n) 	\
+	DEBUG12(printk("qisioctl(%d): Leaving %s()\n", (int)n, x))
+
+#define DUMP_HBA_ISCSI_PORTAL(port) if (dbg_level & QL_DBG_11) \
+		dprt_hba_iscsi_portal(port);
+#define DUMP_CHIP_INFO(pcinfo) if (dbg_level & QL_DBG_11) \
+		dprt_chip_info(pcinfo);
+#define DUMP_SET_FLASH(a,b,c) if (dbg_level & QL_DBG_11) \
+		dprt_rw_flash(0, a, b, c);
+#define DUMP_GET_FLASH(a,b) if (dbg_level & QL_DBG_11) \
+		dprt_rw_flash(1, a, b, 0);
+
+#else
+
+#define DEBUG1(x)      
+#define DEBUG2(x)      
+#define DEBUG3(x)      
+#define DEBUG4(x)      
+#define DEBUG5(x)      
+#define DEBUG6(x)      
+#define DEBUG7(x)      
+#define DEBUG8(x)      
+#define DEBUG9(x)      
+#define DEBUG10(x)      
+#define DEBUG11(x)      
+#define DEBUG12(x)      
+
+#define ENTER(x)
+#define LEAVE(x)
+
+#define DUMP_HBA_ISCSI_PORTAL(port)
+#define DUMP_CHIP_INFO(pcinfo)
+#define DUMP_GET_FLASH(a,b,c)
+#define DUMP_SET_FLASH(a,b) 
+
+#endif
+
+#endif /* #ifndef _QL4IM_DBG_H_ */
diff -r 6a4846854257 drivers/scsi/qla4xxx/ql4im_def.h
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/drivers/scsi/qla4xxx/ql4im_def.h	Mon Jan 11 11:15:25 2010 +0000
@@ -0,0 +1,75 @@
+/*
+ * QLogic iSCSI HBA Driver
+ * Copyright (c)  2003-2006 QLogic Corporation
+ *
+ * See LICENSE.qla4xxx for copyright and licensing details.
+ */
+
+#ifndef __QIM_DEF_H__
+#define __QIM_DEF_H__
+
+#include <linux/blkdev.h>
+#include "qlisioct.h"
+#include "qlinioct.h"
+#include "ql4im_dbg.h"
+
+#define QL4IM_VERSION   "v2.01.00b14"
+#define QL_TMP_BUF_SIZE		PAGE_SIZE
+/* 
+ * INT_DEF_FLASH_BLK_SIZE is which is the maximum flash transfer that can
+ * happen is the maximum dma size that could ever happen
+ */
+#define QL_DMA_BUF_SIZE		\
+	(((INT_DEF_FLASH_BLK_SIZE + PAGE_SIZE -1)/PAGE_SIZE) * PAGE_SIZE)
+	
+struct hba_ioctl {
+	uint32_t		flag;
+#define HBA_IOCTL_BUSY		0x0001
+
+	struct mutex		ioctl_sem;
+	uint32_t		aen_reg_mask;
+	struct scsi_qla_host	*ha;
+	void			*dma_v;
+	dma_addr_t		dma_p;
+	int			dma_len;
+	uint16_t		pt_in_progress;
+	uint16_t		aen_read;
+	struct scsi_cmnd	pt_scsi_cmd;
+	struct srb		pt_srb;
+	struct scsi_device	pt_scsi_device;
+	struct request		pt_request;
+	struct ql4_aen_log	aen_log;
+	char			tmp_buf[QL_TMP_BUF_SIZE];
+	void			*core;
+	unsigned char		cmnd[32];
+	unsigned char		sense_buffer[SCSI_SENSE_BUFFERSIZE];
+};
+
+#define IOCTL_INVALID_STATUS			0xffff
+
+#define MIN_CMD_TOV		25
+
+#define MIN(x,y)            ((x)<(y)?(x):(y))
+#define MAX(x,y)            ((x)>(y)?(x):(y))
+#define LSB(x)  ((uint8_t)(x))
+#define MSB(x)  ((uint8_t)((uint16_t)(x) >> 8))
+
+#define SCSI_GOOD                         0x00
+
+#include "ql4im_glbl.h"
+
+static inline struct ddb_entry *get_ddb_from_osid(struct scsi_qla_host *ha,
+		uint16_t os_id)
+{
+	struct ddb_entry *ddb_entry;
+
+	list_for_each_entry(ddb_entry, &ha->ddb_list, list)
+		if (ddb_entry->os_target_id == os_id)
+			return ddb_entry;
+
+	return NULL;
+}
+
+#endif /* ifndef __QIM_DEF_H__ */
+
+
diff -r 6a4846854257 drivers/scsi/qla4xxx/ql4im_dump.c
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/drivers/scsi/qla4xxx/ql4im_dump.c	Mon Jan 11 11:15:25 2010 +0000
@@ -0,0 +1,705 @@
+/*
+ * QLogic iSCSI HBA Driver
+ * Copyright (c)  2003-2007 QLogic Corporation
+ *
+ * See LICENSE.qla4xxx for copyright and licensing details.
+ */
+#include <linux/version.h>
+#include <linux/vmalloc.h>
+#include <linux/spinlock.h>
+#include <linux/module.h>
+#include <linux/timer.h>
+#include <linux/klist.h>
+#include "ql4_def.h"
+#include "ql4im_def.h"
+#include "ql4im_dump.h"
+#include <scsi/scsi_dbg.h>
+
+static void ql4_dump_header(struct scsi_qla_host *ha, struct dump_image_header *hdr)
+{
+	extern char drvr_ver[];
+
+	ENTER_IOCTL(__func__, ha->host_no);
+
+	memset(hdr, 0, sizeof(struct dump_image_header));
+
+	hdr->cookie = QLGC_COOKIE;
+	sprintf((char *)&hdr->dump_id_string,"%4x Dump", ha->pdev->device);
+	hdr->time_stamp = get_jiffies_64();
+	hdr->total_image_size  = DUMP_IMAGE_SIZE;
+	hdr->core_dump_offset  = CORE_DUMP_OFFSET;
+	hdr->probe_dump_offset = PROBE_DUMP_OFFSET;
+	sprintf((char *)&hdr->driver,"qla4xxx_%d v%s", ha->instance, drvr_ver);
+	sprintf((char *)&hdr->ioctlmod,"qisioctl_%d %s",
+		    ha->instance, QL4IM_VERSION);
+
+	LEAVE_IOCTL(__func__, ha->host_no);
+}
+
+/************************************************************
+ *
+ *                  Core Dump Routines
+ *
+ ************************************************************/
+
+/*
+ * Perform a Write operation via the MADI registers
+ */
+static int qla4_write_MADI(struct scsi_qla_host *ha, uint32_t addr,
+				uint32_t data)
+{
+	int done = 0;
+	int count = 10000;
+	unsigned long flags;
+	int status = QLA_SUCCESS;
+	
+	spin_lock_irqsave(&ha->hardware_lock, flags);
+
+	if (((readl(&ha->reg->arc_madi_cmd) & MADI_STAT_MASK) >> 27) ==
+		MADI_STAT_COMMAND_BUSY) {
+		status = QLA_ERROR;
+		goto exit_write_MADI;
+	}
+
+	writel(addr, &ha->reg->arc_madi_cmd);
+	writel(data, &ha->reg->arc_madi_data);
+
+	while (!done && count--) {
+		switch ((readl(&ha->reg->arc_madi_cmd) & MADI_STAT_MASK) >> 27) {
+		case MADI_STAT_DATA_VALID:
+			done = 1;
+			break;
+
+		case MADI_STAT_DATA_INVALID:
+			writel(addr, &ha->reg->arc_madi_cmd);
+			writel(data, &ha->reg->arc_madi_data);
+			break;
+
+		default:
+			break;
+		}
+	}
+	if (!count)
+		status = QLA_ERROR;
+
+exit_write_MADI:
+	spin_unlock_irqrestore(&ha->hardware_lock, flags);
+	return status;
+}
+
+/*
+ * Perform a Read operation via the MADI registers
+ */
+static int qla4_read_MADI(struct scsi_qla_host *ha, uint32_t addr,
+			uint32_t *data)
+{
+	int done = 0;
+	int count = 10000;
+	unsigned long flags;
+	int status = QLA_SUCCESS;
+
+	spin_lock_irqsave(&ha->hardware_lock, flags);
+	writel((MADI_READ_CMD | addr), &ha->reg->arc_madi_cmd);
+
+	while (!done && count--) {
+		switch ((readl(&ha->reg->arc_madi_cmd) & MADI_STAT_MASK) >> 27){
+		case MADI_STAT_DATA_VALID:
+			done = 1;
+			break;
+
+		case MADI_STAT_DATA_INVALID:
+			writel((MADI_READ_CMD | addr), &ha->reg->arc_madi_cmd);
+			break;
+
+		default:
+			break;
+		}
+	}
+
+	if (!count)
+		status = QLA_ERROR;
+
+	*data = readl(&ha->reg->arc_madi_data);
+	spin_unlock_irqrestore(&ha->hardware_lock, flags);
+
+	return status;
+}
+
+static void
+ql4_dump_core(struct scsi_qla_host *ha, struct core_dump *core_dump)
+{
+	uint32_t		addr, data, rval;
+	volatile uint32_t	 __iomem *reg_ptr;
+	unsigned long		flags;
+	uint8_t			page, num_pci_pages;
+
+	ENTER_IOCTL(__func__, ha->host_no);
+
+	/* 1 - Select OAP Processor */
+	if (qla4_write_MADI(ha, MADI_DEST_ARC_DEBUG, 0x00000000) != QLA_SUCCESS) {
+		DEBUG2(printk("%s(%d): 1 - Select OAP Processor Failed1\n", __func__,
+			(int)ha->host_no));
+		goto core_dump_exit;
+	}
+
+	/* 2 - Halt the OAP Processor */
+	if (qla4_write_MADI(ha, MADI_DEST_AUX_REG | 0x00000005, 0x00000002) != QLA_SUCCESS) {
+		DEBUG2(printk("%s(%d): 2 - Halt OAP Processor Failed\n", __func__,
+			(int)ha->host_no));
+		goto core_dump_exit;
+	}
+
+	/* 3 - Disable SRAM Parity */
+	if (qla4_write_MADI(ha, MADI_DEST_AUX_REG | 0x00000020, 0x00000001) != QLA_SUCCESS) {
+		DEBUG2(printk("%s(%d): 3 - Disable SRAM Parity Failed\n", __func__,
+			(int)ha->host_no));
+		goto core_dump_exit;
+	}
+
+	/* 4 - Select IAP Processor */
+	if (qla4_write_MADI(ha, MADI_DEST_ARC_DEBUG, 0x00000001) != QLA_SUCCESS) {
+		DEBUG2(printk("%s(%d): 4 - Select IAP Processor Failed\n", __func__,
+			(int)ha->host_no));
+		goto core_dump_exit;
+	}
+
+	/* 5 - Halt IAP Processor */
+	if (qla4_write_MADI(ha, MADI_DEST_AUX_REG | 0x00000005, 0x00000002) != QLA_SUCCESS) {
+		DEBUG2(printk("%s(%d): 5 - Halt IAP Processor Failed\n",
+			__func__, (int)ha->host_no));
+		goto core_dump_exit;
+	}
+
+	/* 6 - Select OAP Processor */
+	if (qla4_write_MADI(ha, MADI_DEST_ARC_DEBUG, 0x00000000) != QLA_SUCCESS) {
+		DEBUG2(printk("%s(%d): 6 - Select OAP Processor Failed\n",
+			__func__, (int)ha->host_no));
+		goto core_dump_exit;
+	}
+
+	/* 7 - PCI Registers from Processor's Perspective */
+	for (addr = (PCI_START >> 2); (addr <= (PCI_END >> 2)) ; addr++) {
+		rval = qla4_read_MADI(ha, (addr | MADI_READ_CMD) , &data);
+		if (rval != QLA_SUCCESS) {
+			DEBUG2(printk("%s(%d): 7 - PCI Registers "
+				"from Processor's Perspective Failed\n",
+				__func__, (int)ha->host_no));
+			DEBUG2(printk("%s(%d): PCIReg 0 addr = 0x%08x Failed0\n",
+			__func__, (int)ha->host_no, (addr << 2)));
+			goto core_dump_exit;
+		}
+		core_dump->PCIRegProc[(addr & (0xFFC >> 2))] = data;
+	}
+	DEBUG10(printk("%s(%d): 7 - PCI Registers from Processor's Perspective:\n",
+			__func__, (int)ha->host_no));
+
+
+	/* 8 - SRAM Content */
+	for (addr = (RAM_START >> 2); (addr <= (RAM_END >> 2)) ; addr++) {
+		rval = qla4_read_MADI(ha, (addr | MADI_READ_CMD) , &data);
+		if (rval != QLA_SUCCESS) {
+			DEBUG2(printk("%s(%d): 8 - SRAM Content Failed,  addr = 0x%08x\n",
+				__func__, (int)ha->host_no, (addr << 2)));
+			goto core_dump_exit;
+		}
+		core_dump->SRAM[addr] = data;
+	}
+	DEBUG10(printk("%s(%d): 8 - SRAM Content:\n", __func__, (int)ha->host_no));
+
+
+	/* 9 - OAP Core Registers */
+	for (addr = CORE_START; (addr <= CORE_END) ; addr++) {
+		rval = qla4_read_MADI(ha, (addr | MADI_READ_CMD | MADI_DEST_CORE_REG) , &data);
+		if (rval != QLA_SUCCESS) {
+			DEBUG2(printk("%s(%d): 9 - OAP Core Reg Failed, addr = 0x%08x\n",
+                                __func__, (int)ha->host_no, (addr)));
+			goto core_dump_exit;
+		}
+		core_dump->OAPCoreReg[addr] = data;
+	}
+	DEBUG10(printk("%s(%d): 9 - OAP Core Register:\n", __func__, (int)ha->host_no));
+
+
+	/* 10 - OAP Auxiliary Registers */
+	for (addr = 0; (addr <= 0x309) ; addr++) {
+		rval = qla4_read_MADI(ha, (addr | MADI_READ_CMD | MADI_DEST_AUX_REG) , &data);
+		if (rval != QLA_SUCCESS) {
+			DEBUG2(printk("%s(%d): 10 - OAP Aux Reg Failed, "
+				"addr = 0x%08x\n", __func__, (int)ha->host_no, (addr)));
+			goto core_dump_exit;
+		}
+		core_dump->OAPAuxReg[addr] = data;
+	}
+	DEBUG10(printk("%s(%d): 10 - OAP Auxiliary Registers:\n", __func__, (int)ha->host_no));
+
+
+	/* 11 - Select IAP Processor */
+	if (qla4_write_MADI(ha, MADI_DEST_ARC_DEBUG, 0x00000001) != QLA_SUCCESS) {
+		DEBUG2(printk("%s(%d): 11 - Select IAP Processor Failed\n",
+			__func__, (int)ha->host_no));
+		goto core_dump_exit;
+	}
+
+	/* 12 - IAP Core Registers */
+	for (addr = 0; (addr <= 0x3F) ; addr++) {
+		rval = qla4_read_MADI(ha, (addr | MADI_READ_CMD | MADI_DEST_CORE_REG), &data);
+		if (rval != QLA_SUCCESS) {
+			DEBUG2(printk("%s(%d): 12 - IAP Core Reg Failed, "
+				"addr = 0x%08x \n", __func__, (int)ha->host_no, addr));
+			goto core_dump_exit;
+		}
+		core_dump->IAPCoreReg[addr] = data;
+	}
+	DEBUG10(printk("%s(%d): 12 - IAP Core Registers:\n", __func__, (int)ha->host_no));
+
+
+	/* 13 - IAP Auxiliary Registers */
+	for (addr = 0; (addr <= 0x309) ; addr++) {
+		rval = qla4_read_MADI(ha, (addr | MADI_READ_CMD | MADI_DEST_AUX_REG), &data);
+		if (rval != QLA_SUCCESS) {
+			DEBUG2(printk("%s(%d): 13 - IAP Aux Reg Failed, "
+				"addr = 0x%08x\n", __func__, (int)ha->host_no, (addr)));
+			goto core_dump_exit;
+		}
+		core_dump->IAPAuxReg[addr] = data;
+	}
+	DEBUG10(printk("%s(%d): 13 - IAP Auxiliary Registers:\n", __func__, (int)ha->host_no));
+
+	/* 14 - Save IAP load/store RAM */
+	for (addr = (LDST_START >> 2); (addr <= (LDST_END >> 2)) ; addr++) {
+		rval = qla4_read_MADI(ha, (addr | MADI_READ_CMD), &data);
+		if (rval != QLA_SUCCESS) {
+			DEBUG2(printk("%s(%d): 14 - IAP SRAM Content Failed, "
+				"addr = 0x%08x\n", __func__, (int)ha->host_no, (addr << 2)));
+			goto core_dump_exit;
+		}
+		core_dump->IAPSRAM[(addr & (0x1FFC >> 2))] = data;
+	}
+	DEBUG10(printk("%s(%d): 14 - IAP Load/Store RAM\n", __func__, (int)ha->host_no));
+
+
+	/* 15 - Select OAP Processor */
+	if (qla4_write_MADI(ha, MADI_DEST_ARC_DEBUG, 0x00000000) != QLA_SUCCESS) {
+		DEBUG2(printk("%s(%d): 15 - Select OAP Processor Failed3\n",
+			__func__, (int)ha->host_no));
+		goto core_dump_exit;
+	}
+
+	/* 16 - Save Host PCI Registers */
+	if (is_qla4010(ha))
+                num_pci_pages = 4;
+	else
+                num_pci_pages = 3;
+
+	for (page = 0; page < num_pci_pages; page++) {
+		spin_lock_irqsave(&ha->hardware_lock, flags);
+		writel((clr_rmask(CSR_SCSI_PAGE_SELECT) | page), &ha->reg->ctrl_status);
+		reg_ptr = &ha->reg->mailbox[0];
+		for (addr = 0; addr < 64; addr++) {
+			core_dump->HostPCIRegPage[page][addr] = readl(reg_ptr);
+			reg_ptr++;
+		}
+		spin_unlock_irqrestore(&ha->hardware_lock, flags);
+		DEBUG10(printk("%s(%d): 16 - Host PCI Registers Page %d:\n",
+			__func__, (int)ha->host_no, page));
+	}
+
+	/* 17 - Save statistics registers */
+	if (is_qla4010(ha)) {
+		/* Statistics registers were saved from page 3 registers above */
+	}
+	else {
+		spin_lock_irqsave(&ha->hardware_lock, flags);
+		writel(clr_rmask(CSR_SCSI_PAGE_SELECT), &ha->reg->ctrl_status);
+		writel(0, &ha->reg->u2.isp4022.p0.stats_index);
+		for (addr = 0; addr < 64; addr++) {
+			data = readl(&ha->reg->u2.isp4022.p0.stats_read_data_inc);
+			core_dump->HostPCIRegPage[PROT_STAT_PAGE][addr] = data;
+		}
+		DEBUG10(printk("%s(%d): 17 - Statistics Registers:\n",
+			__func__, (int)ha->host_no));
+		spin_unlock_irqrestore(&ha->hardware_lock, flags);
+	}
+
+	/* Select OAP Processor */
+	if (qla4_write_MADI(ha, MADI_DEST_ARC_DEBUG, 0x00000000) != QLA_SUCCESS) {
+		DEBUG2(printk("%s(%d): 18 - Select OAP Processor Failed\n",
+			__func__, (int)ha->host_no));
+		goto core_dump_exit;
+	}
+	/* Enable SRAM Parity */
+	if (qla4_write_MADI(ha, MADI_DEST_AUX_REG | 0x00000020, 0x00000000) != QLA_SUCCESS) {
+		DEBUG2(printk("%s(%d): 19 - Enable SRAM Parity Failed\n",
+			__func__, (int)ha->host_no));
+	}
+
+core_dump_exit:
+	LEAVE_IOCTL(__func__, ha->host_no);
+}
+
+
+/************************************************************
+ *
+ *                  Probe Dump Routines
+ *
+ ************************************************************/
+//
+// 4010 ProbeMux table
+//
+static PROBEMUX_INFO  probeModuleInfo4010[] = {
+     {"0"        , CLK_BIT(SYSCLK)                      , MUX_SELECT_MAX}
+   , {"DA"       , CLK_BIT(SYSCLK) | CLK_BIT(PCICLK)    , MUX_SELECT_MAX}
+   , {"NRM"      , CLK_BIT(SYSCLK)                      , MUX_SELECT_MAX}
+   , {"ODE"      , CLK_BIT(SYSCLK)                      , MUX_SELECT_MAX}
+   , {"SRM"      , CLK_BIT(SYSCLK)                      , MUX_SELECT_MAX}
+   , {"SCM"      , CLK_BIT(SYSCLK)                      , MUX_SELECT_MAX}
+   , {"NCM"      , CLK_BIT(SYSCLK)                      , MUX_SELECT_MAX}
+   , {"PRD"      , CLK_BIT(SYSCLK)                      , MUX_SELECT_MAX}
+   , {"SDE"      , CLK_BIT(SYSCLK)                      , MUX_SELECT_MAX}
+   , {"RBM"      , CLK_BIT(SYSCLK)                      , MUX_SELECT_MAX}
+   , {"IDE"      , CLK_BIT(SYSCLK)                      , MUX_SELECT_MAX}
+   , {"TDE"      , CLK_BIT(SYSCLK)                      , MUX_SELECT_MAX}
+   , {"RA"       , CLK_BIT(SYSCLK)                      , MUX_SELECT_MAX}
+   , {"ERM"      , CLK_BIT(SYSCLK) | CLK_BIT(CPUCLK)    , MUX_SELECT_MAX}
+   , {"RMI"      , CLK_BIT(SYSCLK) | CLK_BIT(CPUCLK)    , MUX_SELECT_MAX}
+   , {"OAP"      ,                   CLK_BIT(CPUCLK)    , MUX_SELECT_MAX}
+   , {"ECM"      , CLK_BIT(SYSCLK) | CLK_BIT(CPUCLK)    , MUX_SELECT_MAX}
+   , {"NPF"      , CLK_BIT(SYSCLK) | CLK_BIT(CPUCLK)    , MUX_SELECT_MAX}
+   , {"IAP"      , CLK_BIT(SYSCLK) | CLK_BIT(CPUCLK)    , MUX_SELECT_MAX}
+   , {"OTP"      , CLK_BIT(SYSCLK)                      , MUX_SELECT_MAX}
+   , {"TTM"      , CLK_BIT(SYSCLK)                      , MUX_SELECT_MAX}
+   , {"ITP"      , CLK_BIT(SYSCLK)                      , MUX_SELECT_MAX}
+   , {"MAM"      , CLK_BIT(SYSCLK) | CLK_BIT(CPUCLK)    , MUX_SELECT_MAX}
+   , {"BLM"      , CLK_BIT(SYSCLK)                      , MUX_SELECT_MAX}
+   , {"ILM"      , CLK_BIT(SYSCLK)                      , MUX_SELECT_MAX}
+   , {"IFP"      , CLK_BIT(SYSCLK)                      , MUX_SELECT_MAX}
+   , {"IPV"      , CLK_BIT(SYSCLK)                      , MUX_SELECT_MAX}
+   , {"OIP"      , CLK_BIT(SYSCLK)                      , MUX_SELECT_MAX}
+   , {"OFB"      , CLK_BIT(SYSCLK) | CLK_BIT(NRXCLK)    , MUX_SELECT_MAX}
+   , {"MAC"      , CLK_BIT(SYSCLK)                      , MUX_SELECT_MAX}
+   , {"IFB"      , CLK_BIT(SYSCLK) | CLK_BIT(NRXCLK)    , MUX_SELECT_MAX}
+   , {"PCORE"    , CLK_BIT(PCICLK)                      , MUX_SELECT_MAX}
+   , {"20"       , CLK_BIT(SYSCLK)                      , MUX_SELECT_MAX}
+   , {"21"       , CLK_BIT(SYSCLK)                      , MUX_SELECT_MAX}
+   , {"22"       , CLK_BIT(SYSCLK)                      , MUX_SELECT_MAX}
+   , {"23"       , CLK_BIT(SYSCLK)                      , MUX_SELECT_MAX}
+   , {"24"       , CLK_BIT(SYSCLK)                      , MUX_SELECT_MAX}
+   , {"25"       , CLK_BIT(SYSCLK)                      , MUX_SELECT_MAX}
+   , {"26"       , CLK_BIT(SYSCLK)                      , MUX_SELECT_MAX}
+   , {"27"       , CLK_BIT(SYSCLK)                      , MUX_SELECT_MAX}
+   , {"28"       , CLK_BIT(SYSCLK)                      , MUX_SELECT_MAX}
+   , {"29"       , CLK_BIT(SYSCLK)                      , MUX_SELECT_MAX}
+   , {"2A"       , CLK_BIT(SYSCLK)                      , MUX_SELECT_MAX}
+   , {"2B"       , CLK_BIT(SYSCLK)                      , MUX_SELECT_MAX}
+   , {"2C"       , CLK_BIT(SYSCLK)                      , MUX_SELECT_MAX}
+   , {"2D"       , CLK_BIT(SYSCLK)                      , MUX_SELECT_MAX}
+   , {"2E"       , CLK_BIT(SYSCLK)                      , MUX_SELECT_MAX}
+   , {"2F"       , CLK_BIT(SYSCLK)                      , MUX_SELECT_MAX}
+   , {"30"       , CLK_BIT(SYSCLK)                      , MUX_SELECT_MAX}
+   , {"31"       , CLK_BIT(SYSCLK)                      , MUX_SELECT_MAX}
+   , {"32"       , CLK_BIT(SYSCLK)                      , MUX_SELECT_MAX}
+   , {"33"       , CLK_BIT(SYSCLK)                      , MUX_SELECT_MAX}
+   , {"34"       , CLK_BIT(SYSCLK)                      , MUX_SELECT_MAX}
+   , {"35"       , CLK_BIT(SYSCLK)                      , MUX_SELECT_MAX}
+   , {"36"       , CLK_BIT(SYSCLK)                      , MUX_SELECT_MAX}
+   , {"37"       , CLK_BIT(SYSCLK)                      , MUX_SELECT_MAX}
+   , {"38"       , CLK_BIT(SYSCLK)                      , MUX_SELECT_MAX}
+   , {"39"       , CLK_BIT(SYSCLK)                      , MUX_SELECT_MAX}
+   , {"3a"       , CLK_BIT(SYSCLK)                      , MUX_SELECT_MAX}
+   , {"3b"       , CLK_BIT(SYSCLK)                      , MUX_SELECT_MAX}
+   , {"3c"       , CLK_BIT(SYSCLK)                      , MUX_SELECT_MAX}
+   , {"3d"       , CLK_BIT(SYSCLK)                      , MUX_SELECT_MAX}
+   , {"3e"       , CLK_BIT(SYSCLK)                      , MUX_SELECT_MAX}
+   , {"3f"       , CLK_BIT(SYSCLK)                      , MUX_SELECT_MAX}
+};
+
+//
+// 4022/4032 ProbeMux table
+//
+
+static PROBEMUX_INFO  probeModuleInfo4022[] = {
+     {"0"        , CLK_BIT(SYSCLK)                      , MUX_SELECT_MAX}
+   , {"DA"       , CLK_BIT(SYSCLK) | CLK_BIT(PCICLK)    , MUX_SELECT_MAX}
+   , {"BPM"      , CLK_BIT(SYSCLK)                      , MUX_SELECT_MAX}
+   , {"ODE"      , CLK_BIT(SYSCLK)                      , MUX_SELECT_MAX}
+   , {"SRM0"     , CLK_BIT(SYSCLK)                      , MUX_SELECT_MAX}
+   , {"SRM1"     , CLK_BIT(SYSCLK)                      , MUX_SELECT_MAX}
+   , {"PMD"      , CLK_BIT(SYSCLK)                      , MUX_SELECT_MAX}
+   , {"PRD"      , CLK_BIT(SYSCLK)                      , MUX_SELECT_MAX}
+   , {"SDE"      , CLK_BIT(SYSCLK)                      , MUX_SELECT_MAX}
+   , {"RMD"      , CLK_BIT(SYSCLK)                      , MUX_SELECT_MAX}
+   , {"IDE"      , CLK_BIT(SYSCLK)                      , MUX_SELECT_MAX}
+   , {"TDE"      , CLK_BIT(SYSCLK)                      , MUX_SELECT_MAX}
+   , {"RA"       , CLK_BIT(SYSCLK)                      , MUX_SELECT_MAX}
+   , {"REG"      , CLK_BIT(SYSCLK)                      , MUX_SELECT_MAX}
+   , {"RMI"      , CLK_BIT(SYSCLK) | CLK_BIT(CPUCLK)    , MUX_SELECT_MAX}
+   , {"OAP"      ,                   CLK_BIT(CPUCLK)    , MUX_SELECT_MAX}
+   , {"ECM"      , CLK_BIT(SYSCLK) | CLK_BIT(CPUCLK)    , MUX_SELECT_MAX}
+   , {"NPF"      , CLK_BIT(SYSCLK) | CLK_BIT(CPUCLK)    , MUX_SELECT_MAX}
+   , {"IAP"      , CLK_BIT(SYSCLK) | CLK_BIT(CPUCLK)    , MUX_SELECT_MAX}
+   , {"OTP"      , CLK_BIT(SYSCLK)                      , MUX_SELECT_MAX}
+   , {"TTM"      , CLK_BIT(SYSCLK)                      , MUX_SELECT_MAX}
+   , {"ITP"      , CLK_BIT(SYSCLK)                      , MUX_SELECT_MAX}
+   , {"MAM"      , CLK_BIT(SYSCLK) | CLK_BIT(CPUCLK)    , MUX_SELECT_MAX}
+   , {"BLM"      , CLK_BIT(SYSCLK)                      , MUX_SELECT_MAX}
+   , {"ILM"      , CLK_BIT(SYSCLK)                      , MUX_SELECT_MAX}
+   , {"IFP"      , CLK_BIT(SYSCLK)                      , MUX_SELECT_MAX}
+   , {"IPV"      , CLK_BIT(SYSCLK)                      , MUX_SELECT_MAX}
+   , {"OIP"      , CLK_BIT(SYSCLK)                      , MUX_SELECT_MAX}
+   , {"OFB"      , CLK_BIT(SYSCLK) | CLK_BIT(NRXCLK)    , MUX_SELECT_MAX}
+   , {"MAC"      , CLK_BIT(SYSCLK)                      , MUX_SELECT_MAX}
+   , {"IFB"      , CLK_BIT(SYSCLK) | CLK_BIT(NRXCLK)    , MUX_SELECT_MAX}
+   , {"PCORE"    , CLK_BIT(PCICLK)                      , MUX_SELECT_MAX}
+   , {"NRM0"     , CLK_BIT(SYSCLK)                      , MUX_SELECT_MAX}
+   , {"NRM1"     , CLK_BIT(SYSCLK)                      , MUX_SELECT_MAX}
+   , {"SCM0"     , CLK_BIT(SYSCLK)                      , MUX_SELECT_MAX}
+   , {"SCM1"     , CLK_BIT(SYSCLK)                      , MUX_SELECT_MAX}
+   , {"NCM0"     , CLK_BIT(SYSCLK)                      , MUX_SELECT_MAX}
+   , {"NCM1"     , CLK_BIT(SYSCLK)                      , MUX_SELECT_MAX}
+   , {"RBM0"     , CLK_BIT(SYSCLK)                      , MUX_SELECT_MAX}
+   , {"RBM1"     , CLK_BIT(SYSCLK)                      , MUX_SELECT_MAX}
+   , {"RBM2"     , CLK_BIT(SYSCLK)                      , MUX_SELECT_MAX}
+   , {"RBM3"     , CLK_BIT(SYSCLK)                      , MUX_SELECT_MAX}
+   , {"ERM0"     , CLK_BIT(SYSCLK) | CLK_BIT(CPUCLK)    , MUX_SELECT_MAX}
+   , {"ERM1"     , CLK_BIT(SYSCLK) | CLK_BIT(CPUCLK)    , MUX_SELECT_MAX}
+   , {"PERF0"    , CLK_BIT(SYSCLK)                      , MUX_SELECT_MAX}
+   , {"PERF1"    , CLK_BIT(SYSCLK)                      , MUX_SELECT_MAX}
+   , {"2E"       , CLK_BIT(SYSCLK)                      , MUX_SELECT_MAX}
+   , {"2F"       , CLK_BIT(SYSCLK)                      , MUX_SELECT_MAX}
+   , {"30"       , CLK_BIT(SYSCLK)                      , MUX_SELECT_MAX}
+   , {"31"       , CLK_BIT(SYSCLK)                      , MUX_SELECT_MAX}
+   , {"32"       , CLK_BIT(SYSCLK)                      , MUX_SELECT_MAX}
+   , {"33"       , CLK_BIT(SYSCLK)                      , MUX_SELECT_MAX}
+   , {"34"       , CLK_BIT(SYSCLK)                      , MUX_SELECT_MAX}
+   , {"35"       , CLK_BIT(SYSCLK)                      , MUX_SELECT_MAX}
+   , {"36"       , CLK_BIT(SYSCLK)                      , MUX_SELECT_MAX}
+   , {"37"       , CLK_BIT(SYSCLK)                      , MUX_SELECT_MAX}
+   , {"38"       , CLK_BIT(SYSCLK)                      , MUX_SELECT_MAX}
+   , {"39"       , CLK_BIT(SYSCLK)                      , MUX_SELECT_MAX}
+   , {"3a"       , CLK_BIT(SYSCLK)                      , MUX_SELECT_MAX}
+   , {"3b"       , CLK_BIT(SYSCLK)                      , MUX_SELECT_MAX}
+   , {"3c"       , CLK_BIT(SYSCLK)                      , MUX_SELECT_MAX}
+   , {"3d"       , CLK_BIT(SYSCLK)                      , MUX_SELECT_MAX}
+   , {"3e"       , CLK_BIT(SYSCLK)                      , MUX_SELECT_MAX}
+   , {"3f"       , CLK_BIT(SYSCLK)                      , MUX_SELECT_MAX}
+};
+
+static void
+ql4_probe_dump(struct scsi_qla_host *ha, struct probe_dump *probe_dump)
+{
+	uint32_t   probeModule;
+	uint32_t   probeClock;
+	uint32_t   muxSelect;
+	uint32_t   oldPage;
+	unsigned long	flags;
+	uint32_t   probeAddr;
+	struct probe_data *pd;
+
+	PROBEMUX_INFO  *probeModuleInfo;
+	
+	ENTER_IOCTL(__func__, ha->host_no);
+
+	probeModuleInfo = (is_qla4010(ha)) ? probeModuleInfo4010 : probeModuleInfo4022;
+	pd = (struct probe_data *)probe_dump;
+
+	for (probeModule = probe_DA; probeModule <= probe_PERF1; probeModule++) {
+		for (probeClock = 0; probeClock < 4; probeClock++) {
+			if (probeModuleInfo[probeModule].clocks & (1 << probeClock)) {
+				probeAddr = (probeModule << 8) | (probeClock << 6);
+				for (muxSelect = 0;
+					muxSelect < probeModuleInfo[probeModule].maxSelect;
+					muxSelect++) {
+					spin_lock_irqsave(&ha->hardware_lock, flags);
+					oldPage = readl(&ha->reg->ctrl_status) & 0x0003;
+					writel(0x00030000, &ha->reg->ctrl_status);  // Set to page 0
+	
+					writel((u_long)(probeAddr | PROBE_RE | PROBE_UP | muxSelect),
+						isp_probe_mux_addr(ha));
+					pd->high = (readl(isp_probe_mux_data(ha)) >> 24) & 0xff;
+
+					writel((u_long)(probeAddr | PROBE_RE | PROBE_LO | muxSelect),
+						isp_probe_mux_addr(ha));
+					pd->low = readl(isp_probe_mux_data(ha));
+
+					writel((u_long)(0x00030000 | oldPage), &ha->reg->ctrl_status); // Reset page
+					spin_unlock_irqrestore(&ha->hardware_lock, flags);
+					pd++;
+				}
+			}
+		}
+	}
+	LEAVE_IOCTL(__func__, ha->host_no);
+}
+
+void ql4_core_dump(struct scsi_qla_host *ha, void *pdump)
+{
+	struct dump_image *image = (struct dump_image *)pdump;
+
+	ENTER_IOCTL(__func__, ha->host_no);
+
+	ql4_dump_header(ha, &image->dump_header);
+	ql4_dump_core(ha, &image->core_dump);
+	ql4_probe_dump(ha, &image->probe_dump);
+
+	LEAVE_IOCTL(__func__, ha->host_no);
+}
+
+char *probe_clk_names[] = {
+	"SYSCLK",
+	"PCICLK",
+	"NRXCLK",
+	"CPUCLK"
+};
+
+static void ql4_print_probe_dump(struct scsi_qla_host *ha,
+		struct probe_dump *p_dump)
+{
+	uint32_t   probeModule;
+	uint32_t   probeClock;
+	uint32_t   muxSelect;
+	uint32_t   probeAddr;
+	struct probe_data *pd;
+	PROBEMUX_INFO  *probeModuleInfo;
+
+	probeModuleInfo =
+		(is_qla4010(ha)) ? probeModuleInfo4010 : probeModuleInfo4022;
+	pd = (struct probe_data *)p_dump;
+
+	for (probeModule = probe_DA; probeModule <= probe_PERF1;
+		probeModule++) {
+		for (probeClock = 0; probeClock < 4; probeClock++) {
+			if (probeModuleInfo[probeModule].clocks &
+				(1 << probeClock)) {
+				probeAddr = (probeModule << 8) |
+						(probeClock << 6);
+
+				dev_info(&ha->pdev->dev,
+					"%s: %s ModuleSelect:0x%x "
+					"Clock:0x%x (%s)"
+					" StartProbeAddr:0x%x\n",
+					__func__,
+					probeModuleInfo[probeModule].moduleName,
+					probeModule,
+					probeClock,
+					probe_clk_names[probeClock],
+					probeAddr);
+
+				for (muxSelect = 0;
+					muxSelect <
+					probeModuleInfo[probeModule].maxSelect;) {
+					dev_info(&ha->pdev->dev,
+						"%s %s %s:\t 0x%04x: "
+						"%02x_%08x %02x_%08x "
+						"%02x_%08x %02x_%08x\n",
+						__func__,
+						probeModuleInfo[probeModule].moduleName,
+						probe_clk_names[probeClock],
+						(probeAddr | muxSelect), 
+						pd->high, pd->low,
+						(pd + 1)->high, (pd + 1)->low,
+						(pd + 2)->high, (pd + 2)->low,
+						(pd + 3)->high, (pd + 3)->low);
+						
+					muxSelect = muxSelect + 4;
+					pd = pd + 4;
+				}
+			}
+		}
+	}
+
+}
+
+static void ql4_print_core_dump(struct scsi_qla_host *ha,
+	struct core_dump *c_dump)
+{
+	uint32_t i;
+	uint32_t addr, page;
+
+	/* print Proc PCI Registers */
+	dev_info(&ha->pdev->dev, "%s : Proc PCI Registers \n", __func__);
+	
+	for (i = 0 ; i < 1024; ) {
+		dev_info(&ha->pdev->dev, "%s : 0x%08x:"
+			"  0x%08x 0x%08x 0x%08x 0x%08x \n",
+			__func__, (PCI_START | i),
+			c_dump->PCIRegProc[i], c_dump->PCIRegProc[i+1],
+			c_dump->PCIRegProc[i+2], c_dump->PCIRegProc[i+3]);
+		i += 4;
+	}
+	
+	/* print OAP Core  Registers */
+	dev_info(&ha->pdev->dev, "%s : OAP Core Registers \n", __func__);
+	
+	for (i = 0 ; i < 64; ) {
+		dev_info(&ha->pdev->dev, "%s : 0x%08x:"
+			"  0x%08x 0x%08x 0x%08x 0x%08x \n",
+			__func__, i,
+			c_dump->OAPCoreReg[i], c_dump->OAPCoreReg[i+1],
+			c_dump->OAPCoreReg[i+2], c_dump->OAPCoreReg[i+3]);
+		i += 4;
+	}
+	
+	/* print OAP Aux  Registers */
+	dev_info(&ha->pdev->dev, "%s : OAP Aux Registers \n", __func__);
+	
+	for (i = 0 ; i < 778; ) {
+		dev_info(&ha->pdev->dev, "%s : 0x%08x:"
+			"  0x%08x 0x%08x 0x%08x 0x%08x \n",
+			__func__, i,
+			c_dump->OAPAuxReg[i], c_dump->OAPAuxReg[i+1],
+			c_dump->OAPAuxReg[i+2], c_dump->OAPAuxReg[i+3]);
+		i += 4;
+	}
+	
+	/* print IAP Core  Registers */
+	dev_info(&ha->pdev->dev, "%s : IAP Core Registers \n", __func__);
+	
+	for (i = 0 ; i < 64; ) {
+		dev_info(&ha->pdev->dev, "%s : 0x%08x:"
+			"  0x%08x 0x%08x 0x%08x 0x%08x \n",
+			__func__, i,
+			c_dump->IAPCoreReg[i], c_dump->IAPCoreReg[i+1],
+			c_dump->IAPCoreReg[i+2], c_dump->IAPCoreReg[i+3]);
+		i += 4;
+	}
+	
+	/* print IAP Aux  Registers */
+	dev_info(&ha->pdev->dev, "%s : IAP Aux Registers \n", __func__);
+	
+	for (i = 0 ; i < 778; ) {
+		dev_info(&ha->pdev->dev, "%s : 0x%08x:"
+			"  0x%08x 0x%08x 0x%08x 0x%08x \n",
+			__func__, i,
+			c_dump->IAPAuxReg[i], c_dump->IAPAuxReg[i+1],
+			c_dump->IAPAuxReg[i+2], c_dump->IAPAuxReg[i+3]);
+		i += 4;
+	}
+
+	/* print IAP SRAM  Registers */
+	dev_info(&ha->pdev->dev, "%s : IAP SRAM Registers \n", __func__);
+	
+	for (i = 0 ; i < 2048; ) {
+		dev_info(&ha->pdev->dev, "%s : 0x%08x:"
+			"  0x%08x 0x%08x 0x%08x 0x%08x \n",
+			__func__, i,
+			c_dump->IAPSRAM[i], c_dump->IAPSRAM[i+1],
+			c_dump->IAPSRAM[i+2], c_dump->IAPSRAM[i+3]);
+		i += 4;
+	}
+	
+	/* print Host PCI Registers */
+	dev_info(&ha->pdev->dev, "%s : Host PCI Registers \n", __func__);
+	for (page = 0; page < 4; page++) {
+		for (addr = 0; addr < 64; ) {
+			dev_info(&ha->pdev->dev, "%s : 0x%04x: 0x%08x:"
+			"  0x%08x 0x%08x 0x%08x 0x%08x \n",
+			__func__, page, i,
+			c_dump->HostPCIRegPage[page][addr],
+			c_dump->HostPCIRegPage[page][addr+1],
+			c_dump->HostPCIRegPage[page][addr+2],
+			c_dump->HostPCIRegPage[page][addr+3]);
+
+			addr += 4;
+		}
+	}
+}
diff -r 6a4846854257 drivers/scsi/qla4xxx/ql4im_dump.h
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/drivers/scsi/qla4xxx/ql4im_dump.h	Mon Jan 11 11:15:25 2010 +0000
@@ -0,0 +1,193 @@
+/*
+ * QLogic iSCSI HBA Driver
+ * Copyright (c)  2003-2007 QLogic Corporation
+ *
+ * See LICENSE.qla4xxx for copyright and licensing details.
+ */
+
+#ifndef __QL4IM_DUMP_H_
+#define __QL4IM_DUMP_H_
+/*
+ * Dump Image Header
+ */
+struct dump_image_header {
+	uint32_t cookie;                /* 0x00  QLGC 		*/
+	uint8_t  dump_id_string[12];    /* 0x04  "40xx Dump   "	*/
+	uint64_t time_stamp;		/* 0x10  timeb struct used by ftime() */
+	uint32_t total_image_size;      /* 0x18  image size excluding header  */
+	uint32_t core_dump_offset;      /* 0x1c  also represents size of header */
+	uint32_t probe_dump_offset;     /* 0x20  */
+	uint32_t queue_dump_offset;     /* 0x24  */
+	uint32_t reserved1[6];          /* 0x28  */
+	uint8_t driver[0x30];           /* 0x40  "qla4xxx_x vx.xx.xx-dx" */
+	uint8_t ioctlmod[0x30];         /* 0x70  "qisioctl_x vx.xx.xx-dx" */
+	uint8_t reserved2[0x60];        /* 0xA0  */
+};                  /* 0x100 (256) bytes */
+
+#define DUMP_IMAGE_HEADER_SIZE   (sizeof(struct dump_image_header))
+#define DUMP_IMAGE_HEADER_OFFSET 0
+
+#define QLGC_COOKIE     0x43474C51
+
+
+/*
+ * Core Dump
+ */
+struct core_dump {
+	uint32_t PCIRegProc[1024];      /* 4096    bytes */
+	uint32_t SRAM[524288];          /* 2097152 bytes */
+	uint32_t OAPCoreReg[64];        /* 256     bytes */
+	uint32_t OAPAuxReg[778];        /* 3112    bytes */
+	uint32_t IAPCoreReg[64];        /* 256     bytes */
+	uint32_t IAPAuxReg[778];        /* 3112    bytes */
+	uint32_t IAPSRAM[2048];         /* 8192    bytes */
+	uint32_t HostPCIRegPage[4][64];   /* 4 * 256     bytes */
+};                            /* 2117200 total */
+
+#define CORE_DUMP_SIZE   (sizeof(struct core_dump))
+#define CORE_DUMP_OFFSET (0 + DUMP_IMAGE_HEADER_SIZE)
+
+
+/*
+ * Probe Dump
+ */
+struct probe_dump {
+	uint8_t  data[28416];/* actually 28160 = 0x40x55x8 */
+};
+
+#define PROBE_DUMP_SIZE   (sizeof(struct probe_dump))
+#define PROBE_DUMP_OFFSET (CORE_DUMP_OFFSET + CORE_DUMP_SIZE)
+
+
+/*
+ * Dump Image
+ */
+struct dump_image{
+	struct dump_image_header	dump_header;
+	struct core_dump		core_dump;
+	struct probe_dump		probe_dump;
+};
+
+#define DUMP_IMAGE_SIZE (sizeof(struct dump_image))
+
+/****************************************************************
+ *
+ *                      Core Dump Defines
+ *
+ ****************************************************************/
+
+/* Defines used when accessing MADI */
+#define MADI_STAT_DATA_VALID   0
+#define MADI_STAT_DATA_INVALID 1
+#define MADI_STAT_COMMAND_BUSY 3
+
+#define MADI_DEST_SRAM         0x00000000
+#define MADI_DEST_CORE_REG     0x40000000
+#define MADI_DEST_AUX_REG      0x80000000
+#define MADI_DEST_ARC_DEBUG    0xc0000000
+
+#define MADI_STAT_MASK         0x18000000
+#define MADI_READ_CMD          0x20000000
+			
+#define PROC_OAP 1
+#define PROC_IAP 2
+
+#define RAM_START  0
+#define RAM_END    0x1fffff
+#define CORE_START 0
+#define CORE_END   63
+#define AUX_START  0
+#define AUX_END    0x309
+#define LDST_START 0x07f00000
+#define LDST_END   0x07f01fff
+#define PCI_START  0x08000000
+#define PCI_END    0x08000fff
+
+
+/****************************************************************
+ *
+ *                      Probe Dump Defines
+ *
+ ****************************************************************/
+
+#define MUX_SELECT_MAX  0x40
+#define MAX_MODULE      0x40
+#define MAX_CLOCK       0x4
+
+#define  SYSCLK   0
+#define  PCICLK   1
+#define  NRXCLK   2
+#define  CPUCLK   3
+
+#define  CLK_BIT(x)  (1<<x)
+
+
+typedef enum
+{
+     probe_DA = 1
+   , probe_BPM
+   , probe_ODE
+   , probe_SRM0
+   , probe_SRM1
+   , probe_PMD
+   , probe_PRD
+   , probe_SDE
+   , probe_RMD
+   , probe_IDE
+   , probe_TDE
+   , probe_RA
+   , probe_REG
+   , probe_RMI
+   , probe_OAP
+   , probe_ECM
+   , probe_NPF
+   , probe_IAP
+   , probe_OTP
+   , probe_TTM
+   , probe_ITP
+   , probe_MAM
+   , probe_BLM
+   , probe_ILM
+   , probe_IFP
+   , probe_IPV
+   , probe_OIP
+   , probe_OFB
+   , probe_MAC
+   , probe_IFB
+   , probe_PCORE
+   , probe_NRM0
+   , probe_NRM1
+   , probe_SCM0
+   , probe_SCM1
+   , probe_NCM0
+   , probe_NCM1
+   , probe_RBM0
+   , probe_RBM1
+   , probe_RBM2
+   , probe_RBM3
+   , probe_ERM0
+   , probe_ERM1
+   , probe_PERF0
+   , probe_PERF1
+} probe_Module;
+
+typedef struct
+{
+   char     *moduleName;
+   uint32_t   clocks;
+   uint32_t   maxSelect;
+} PROBEMUX_INFO;
+
+
+#define PROBE_RE  0x8000
+#define PROBE_UP  0x4000
+#define PROBE_LO  0x0000
+
+struct probe_data {
+   uint32_t   high;
+   uint32_t   low;
+};
+
+extern void ql4_core_dump(struct scsi_qla_host *ha, void *pdump);
+
+#endif
diff -r 6a4846854257 drivers/scsi/qla4xxx/ql4im_glbl.h
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/drivers/scsi/qla4xxx/ql4im_glbl.h	Mon Jan 11 11:15:25 2010 +0000
@@ -0,0 +1,32 @@
+/*
+ * QLogic iSCSI HBA Driver
+ * Copyright (c)  2003-2006 QLogic Corporation
+ *
+ * See LICENSE.qla4xxx for copyright and licensing details.
+ */
+
+/*
+ * Global include file.
+ */
+#ifndef __QL4IM_GBL_H
+#define	__QL4IM_GBL_H
+
+extern uint8_t drvr_major;
+extern uint8_t drvr_minor;
+extern uint8_t drvr_patch;
+extern uint8_t drvr_beta;
+extern char drvr_ver[];
+
+/*
+ * Defined in ql4im_os.c
+ */
+extern uint32_t ql4im_get_hba_count(void);
+
+/* 
+ * Defined in ql4im_ioctl.c
+ */
+extern int qla4xxx_ioctl(int cmd, void *arg);
+extern struct hba_ioctl *ql4im_get_adapter_handle(uint16_t instance);
+
+
+#endif /* _QL4IM_GBL_H */
diff -r 6a4846854257 drivers/scsi/qla4xxx/ql4im_ioctl.c
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/drivers/scsi/qla4xxx/ql4im_ioctl.c	Mon Jan 11 11:15:25 2010 +0000
@@ -0,0 +1,3575 @@
+/*
+ * QLogic iSCSI HBA Driver
+ * Copyright (c)  2003-2006 QLogic Corporation
+ *
+ * See LICENSE.qla4xxx for copyright and licensing details.
+ */
+
+/*
+ * ioctl support functions
+ */
+#include <linux/version.h>
+#include <linux/vmalloc.h>
+#include <linux/spinlock.h>
+#include <linux/module.h>
+#include <linux/timer.h>
+#include <linux/klist.h>
+
+#include "ql4_def.h"
+#include "ql4im_def.h"
+#include "ql4im_dump.h"
+#include <scsi/scsi_dbg.h>
+
+
+static void *
+Q64BIT_TO_PTR(uint64_t buf_addr, uint16_t addr_mode)
+{
+#if defined(CONFIG_COMPAT) || !defined(CONFIG_IA64) || !defined(CONFIG_64BIT)
+	union ql_doublelong {
+		struct {
+			uint32_t        lsl;
+			uint32_t        msl;
+		} longs;
+		uint64_t        dl;
+	};
+
+	union ql_doublelong tmpval;
+
+	tmpval.dl = buf_addr;
+
+#if defined(CONFIG_COMPAT) && !defined(CONFIG_IA64)
+	/* 32bit user - 64bit kernel */
+	if (addr_mode == EXT_DEF_ADDR_MODE_32) {
+		DEBUG9(printk("%s: got 32bit user address.\n", __func__);)
+		return((void *)(uint64_t)(tmpval.longs.lsl));
+	} else {
+		DEBUG9(printk("%s: got 64bit user address.\n", __func__);)
+		return((void *)buf_addr);
+	}
+#else
+	return((void *)(tmpval.longs.lsl));
+#endif
+#else
+	return((void *)buf_addr);
+#endif
+}
+
+#include "ql4im_os.h"
+
+/* Start of External ioctls */
+
+static int ql4_reg_aen(struct hba_ioctl *ql4im_ha, EXT_IOCTL_ISCSI *ioctl)
+{
+	int status = 0;
+	EXT_REG_AEN_ISCSI reg_aen;
+	struct scsi_qla_host *ha;
+
+	ha = ql4im_ha->ha;
+
+	ENTER_IOCTL(__func__, ha->host_no);
+
+	if (ioctl->RequestLen > sizeof(EXT_REG_AEN_ISCSI)) {
+		DEBUG2(printk("qisioctl%d: %s: memory area too small\n",
+		    (int)ha->host_no, __func__));
+
+		ioctl->Status = EXT_STATUS_BUFFER_TOO_SMALL;
+		goto exit_reg_aen;
+	}
+
+	if ((status = copy_from_user((void *)&reg_aen,
+	    Q64BIT_TO_PTR(ioctl->RequestAdr, ioctl->AddrMode),
+				     sizeof(EXT_REG_AEN_ISCSI))) != 0) {
+		DEBUG2(printk("qisioctl%d: %s: unable to copy data from "
+		    "user's memory area\n", (int)ha->host_no, __func__));
+
+		ioctl->Status = EXT_STATUS_COPY_ERR;
+		goto exit_reg_aen;
+	}
+
+	ql4im_ha->aen_reg_mask = reg_aen.Enable;
+
+	DEBUG4(printk("qisioctl%d: %s: mask = 0x%x\n",
+	    (int)ha->host_no, __func__, ql4im_ha->aen_reg_mask));
+
+	ioctl->Status = EXT_STATUS_OK;
+
+exit_reg_aen:
+	LEAVE_IOCTL(__func__, ha->host_no);
+
+	return(status);
+}
+
+static int get_rhel5_aen(struct hba_ioctl *ql4im_ha,
+	EXT_ASYNC_EVENT *async_event)
+{
+	struct scsi_qla_host *ha;
+	uint32_t num_aens = 0;
+	uint16_t i, aen_in;
+
+	ha = ql4im_ha->ha;
+
+	ENTER_IOCTL(__func__, ha->host_no);
+
+	aen_in = ha->aen_in;
+	if (ql4im_ha->aen_read < aen_in) {
+		for (i = ql4im_ha->aen_read;
+			((i < aen_in)&&(num_aens < EXT_DEF_MAX_AEN_QUEUE));
+			i++) {
+			async_event[num_aens].AsyncEventCode =
+				ha->aen_q[i].mbox_sts[0];
+			async_event[num_aens].Payload[0] =
+				ha->aen_q[i].mbox_sts[1];
+			async_event[num_aens].Payload[1] =
+				ha->aen_q[i].mbox_sts[2];
+			async_event[num_aens].Payload[2] =
+				ha->aen_q[i].mbox_sts[3];
+			async_event[num_aens].Payload[3] =
+				ha->aen_q[i].mbox_sts[4];
+			num_aens++;
+		}
+	} else if (ql4im_ha->aen_read > aen_in) {
+		for (i = ql4im_ha->aen_read;
+			((i < MAX_AEN_ENTRIES)&&
+				(num_aens < EXT_DEF_MAX_AEN_QUEUE));
+			i++) {
+			async_event[num_aens].AsyncEventCode =
+				ha->aen_q[i].mbox_sts[0];
+			async_event[num_aens].Payload[0] =
+				ha->aen_q[i].mbox_sts[1];
+			async_event[num_aens].Payload[1] =
+				ha->aen_q[i].mbox_sts[2];
+			async_event[num_aens].Payload[2] =
+				ha->aen_q[i].mbox_sts[3];
+			async_event[num_aens].Payload[3] =
+				ha->aen_q[i].mbox_sts[4];
+			num_aens++;
+		}
+		for (i = 0;
+			((i < aen_in)&&
+				(num_aens < EXT_DEF_MAX_AEN_QUEUE));
+			i++) {
+			async_event[num_aens].AsyncEventCode =
+				ha->aen_q[i].mbox_sts[0];
+			async_event[num_aens].Payload[0] =
+				ha->aen_q[i].mbox_sts[1];
+			async_event[num_aens].Payload[1] =
+				ha->aen_q[i].mbox_sts[2];
+			async_event[num_aens].Payload[2] =
+				ha->aen_q[i].mbox_sts[3];
+			async_event[num_aens].Payload[3] =
+				ha->aen_q[i].mbox_sts[4];
+			num_aens++;
+		}
+	}
+	ql4im_ha->aen_read = aen_in;
+
+	LEAVE_IOCTL(__func__, ha->host_no);
+
+	return num_aens;
+}
+
+static int ql4_get_aen(struct hba_ioctl *ql4im_ha, EXT_IOCTL_ISCSI *ioctl)
+{
+	EXT_ASYNC_EVENT *async_event;
+	uint32_t num_aens = 0;
+	uint16_t i, j;
+	int status = 0;
+	struct scsi_qla_host *ha;
+
+	ha = ql4im_ha->ha;
+	ENTER_IOCTL(__func__, ha->host_no);
+
+	DEBUG4(printk("qisioctl%d: %s: mask = 0x%x\n",
+		(int)ha->host_no, __func__, ql4im_ha->aen_reg_mask));
+
+	if (ql4im_ha->aen_reg_mask == EXT_DEF_ENABLE_NO_AENS) {
+		DEBUG2(printk("qisioctl%d: %s: AEN mask not enabled\n",
+			(int)ha->host_no, __func__));
+		ioctl->Status = EXT_STATUS_OK;
+		return 0;
+	}
+	if (ioctl->ResponseLen < 
+		(sizeof(EXT_ASYNC_EVENT) * EXT_DEF_MAX_AEN_QUEUE)) {
+		DEBUG2(printk("qisioctl%d: %s: memory area too small\n",
+			(int)ha->host_no, __func__));
+		ioctl->Status = EXT_STATUS_BUFFER_TOO_SMALL;
+		goto exit_get_gen;
+	}
+	async_event = (EXT_ASYNC_EVENT *)ql4im_ha->tmp_buf;
+	memset(async_event, 0, sizeof(EXT_ASYNC_EVENT) * EXT_DEF_MAX_AEN_QUEUE);
+
+	if ((drvr_major == 5)&&(drvr_minor == 0)){
+		num_aens = get_rhel5_aen(ql4im_ha, async_event);
+	} else {
+		ha->ql4getaenlog(ha, &ql4im_ha->aen_log);
+		if (ql4im_ha->aen_log.count) {
+		 	for (i = 0; (i < ql4im_ha->aen_log.count); i++) {
+				for (j = 0; j < MAX_AEN_ENTRIES; j++)
+					async_event[num_aens].AsyncEventCode =
+						ql4im_ha->aen_log.entry[i].mbox_sts[j];
+				num_aens++;
+			}
+		}
+	}
+
+	ioctl->ResponseLen = sizeof(EXT_ASYNC_EVENT) * num_aens;
+	ioctl->Status = EXT_STATUS_OK;
+
+	/*
+	 * Copy the IOCTL EXT_ASYNC_EVENT buffer to the user's data space
+	 */
+	if ((status = copy_to_user(Q64BIT_TO_PTR(ioctl->ResponseAdr,
+						 ioctl->AddrMode), async_event,
+				   ioctl->ResponseLen)) != 0) {
+		DEBUG2(printk("qisioctl%d: %s: memory area too small\n",
+		    (int)ha->host_no, __func__));
+
+		ioctl->Status = EXT_STATUS_COPY_ERR;
+	}
+exit_get_gen:
+	LEAVE_IOCTL(__func__, ha->host_no);
+	return(status);
+}
+
+
+
+static int
+ql4_query_hba_iscsi_node(struct hba_ioctl *ql4im_ha, EXT_IOCTL_ISCSI *ioctl)
+{
+	int			status = 0;
+	uint32_t		mbox_cmd[MBOX_REG_COUNT];
+	uint32_t		mbox_sts[MBOX_REG_COUNT];
+	EXT_HBA_ISCSI_NODE	*phba_node = NULL;
+	struct init_fw_ctrl_blk	*init_fw_cb;
+	struct scsi_qla_host	*ha;
+
+	ha = ql4im_ha->ha;
+
+	ENTER_IOCTL(__func__, ha->host_no);
+
+	phba_node = (EXT_HBA_ISCSI_NODE *)ql4im_ha->tmp_buf;
+
+	if (!ioctl->ResponseAdr ||
+		ioctl->ResponseLen < sizeof(EXT_HBA_ISCSI_NODE)) {
+		DEBUG2(printk("qisioctl%lx: %s: rsp buffer too small\n",
+		    ha->host_no, __func__));
+
+		ioctl->Status = EXT_STATUS_BUFFER_TOO_SMALL;
+		goto exit_query_hba_node;
+	}
+
+	/*
+	 * Send mailbox command
+	 */
+	memset(&mbox_cmd, 0, sizeof(mbox_cmd));
+	memset(&mbox_sts, 0, sizeof(mbox_sts));
+	mbox_cmd[0] = MBOX_CMD_GET_INIT_FW_CTRL_BLOCK;
+	mbox_cmd[2] = LSDW(ql4im_ha->dma_p);
+	mbox_cmd[3] = MSDW(ql4im_ha->dma_p);
+	mbox_cmd[4] = sizeof(struct init_fw_ctrl_blk);
+
+	if (ha->ql4mbx(ha, MBOX_REG_COUNT, 1, &mbox_cmd[0], &mbox_sts[0]) == QLA_ERROR) {
+		DEBUG2(printk("qisioctl%lx: %s: command failed \n",
+		    ha->host_no, __func__));
+
+		ioctl->Status = EXT_STATUS_MAILBOX;
+		ioctl->DetailStatus = mbox_sts[0];
+
+		goto exit_query_hba_node;
+	}
+
+	/*
+	 * Transfer data from Fw's DEV_DB_ENTRY buffer to IOCTL's
+	 * EXT_HBA_ISCSI_NODE buffer
+	 */
+	init_fw_cb = (struct init_fw_ctrl_blk *) ql4im_ha->dma_v;
+
+	memset(phba_node, 0, sizeof(EXT_HBA_ISCSI_NODE));
+	phba_node->PortNumber = le16_to_cpu(init_fw_cb->pri.ipv4_port);
+	phba_node->NodeInfo.PortalCount = 1;
+
+	memcpy(phba_node->NodeInfo.IPAddr.IPAddress, init_fw_cb->pri.ipv4_addr,
+	    sizeof(init_fw_cb->pri.ipv4_addr));
+	memcpy(phba_node->NodeInfo.iSCSIName, init_fw_cb->pri.iscsi_name,
+	    sizeof(init_fw_cb->pri.iscsi_name));
+
+	sprintf(phba_node->DeviceName, "/proc/scsi/qla4xxx/%d",
+	    (int)ha->host_no);
+
+	/*
+	 * Copy the IOCTL EXT_HBA_ISCSI_NODE buffer to the user's data space
+	 */
+	ioctl->Status = EXT_STATUS_OK;
+	if ((status = copy_to_user(Q64BIT_TO_PTR(ioctl->ResponseAdr,
+						 ioctl->AddrMode),
+				   phba_node, ioctl->ResponseLen)) != 0) {
+		DEBUG2(printk("qisioctl%lx %s: copy_to_user failed\n",
+			ha->host_no, __func__));
+
+		ioctl->Status = EXT_STATUS_COPY_ERR;
+	}
+
+exit_query_hba_node:
+	LEAVE_IOCTL(__func__, ha->host_no);
+
+	return(status);
+}
+
+static int
+ql4_query_hba_iscsi_portal(struct hba_ioctl *ql4im_ha,
+				    EXT_IOCTL_ISCSI *ioctl)
+{
+	int status = 0;
+	uint32_t mbox_cmd[MBOX_REG_COUNT];
+	uint32_t mbox_sts[MBOX_REG_COUNT];
+	EXT_HBA_ISCSI_PORTAL *phba_portal;
+	struct flash_sys_info *sys_info;
+	struct scsi_qla_host	*ha;
+
+	ha = ql4im_ha->ha;
+
+	ENTER_IOCTL(__func__, ha->host_no);
+
+	if (!ioctl->ResponseAdr ||
+		(ioctl->ResponseLen < sizeof(*phba_portal))) {
+		DEBUG2(printk("qisioctl(%d): %s: no response buffer found.\n",
+		    (int)ha->host_no, __func__));
+
+		ioctl->Status = EXT_STATUS_BUFFER_TOO_SMALL;
+		goto exit_query_hba_portal;
+	}
+
+	phba_portal = (EXT_HBA_ISCSI_PORTAL *)ql4im_ha->tmp_buf;
+	memset(phba_portal, 0, sizeof(EXT_HBA_ISCSI_PORTAL));
+
+	strcpy(phba_portal->DriverVersion, drvr_ver);
+	sprintf(phba_portal->FWVersion, "%02d.%02d Patch %02d Build %02d",
+		ha->firmware_version[0], ha->firmware_version[1],
+		ha->patch_number, ha->build_number);
+
+	/* Get firmware state information */
+	memset(&mbox_cmd, 0, sizeof(mbox_cmd));
+	memset(&mbox_sts, 0, sizeof(mbox_sts));
+
+	mbox_cmd[0] = MBOX_CMD_GET_FW_STATE;
+	if (ha->ql4mbx(ha, MBOX_REG_COUNT, 4, &mbox_cmd[0], &mbox_sts[0]) != QLA_SUCCESS) {
+		DEBUG2(printk("qisioctl(%d): %s: MBOX_CMD_GET_FW_STATE "
+		    "failed w/ status %04x\n",
+		    (int)ha->host_no, __func__, mbox_sts[0]));
+
+		ioctl->Status = EXT_STATUS_MAILBOX;
+		ioctl->DetailStatus = mbox_sts[0];
+		goto exit_query_hba_portal;
+	}
+
+	switch (mbox_sts[1]) {
+	case FW_STATE_READY:
+		phba_portal->State = EXT_DEF_CARD_STATE_READY;
+		break;
+	case FW_STATE_CONFIG_WAIT:
+		phba_portal->State = EXT_DEF_CARD_STATE_CONFIG_WAIT;
+		break;
+	case 0x0002: /*case FW_STATE_WAIT_LOGIN:*/
+		phba_portal->State = EXT_DEF_CARD_STATE_LOGIN;
+		break;
+	case FW_STATE_ERROR:
+		phba_portal->State = EXT_DEF_CARD_STATE_ERROR;
+		break;
+	}
+
+	switch (mbox_sts[3] & 0x0001) {
+	case 0:/* case FW_ADDSTATE_COPPER_MEDIA:*/
+		phba_portal->Type = EXT_DEF_TYPE_COPPER;
+		break;
+	case FW_ADDSTATE_OPTICAL_MEDIA:
+		phba_portal->Type = EXT_DEF_TYPE_OPTICAL;
+		break;
+	}
+
+	/* Get ddb entry information */
+	memset(&mbox_cmd, 0, sizeof(mbox_cmd));
+	memset(&mbox_sts, 0, sizeof(mbox_sts));
+
+	mbox_cmd[0] = MBOX_CMD_GET_DATABASE_ENTRY;
+	mbox_cmd[1] = 0;
+
+	if (ha->ql4mbx(ha, MBOX_REG_COUNT, 7, &mbox_cmd[0], &mbox_sts[0]) != QLA_SUCCESS) {
+		DEBUG2(printk("qisioctl(%d): %s: GET_DATABASE_ENTRY failed!\n",
+		    (int)ha->host_no, __func__));
+
+		ioctl->Status = EXT_STATUS_ERR;
+		ioctl->RequestLen = 0;
+		ioctl->DetailStatus = ioctl->Instance;
+
+		goto exit_query_hba_portal;
+	}
+
+	phba_portal->DiscTargetCount = (uint16_t) mbox_sts[2];
+
+	/* Get flash sys info information */
+	sys_info = (struct flash_sys_info *) ql4im_ha->dma_v;
+
+	memset(&mbox_cmd, 0, sizeof(mbox_cmd));
+	memset(&mbox_sts, 0, sizeof(mbox_sts));
+	mbox_cmd[0] = MBOX_CMD_READ_FLASH;
+	mbox_cmd[1] = LSDW(ql4im_ha->dma_p);
+	mbox_cmd[2] = MSDW(ql4im_ha->dma_p);
+	mbox_cmd[3] = INT_ISCSI_SYSINFO_FLASH_OFFSET;
+	mbox_cmd[4] = sizeof(*sys_info);
+
+	if (ha->ql4mbx(ha, MBOX_REG_COUNT, 2, &mbox_cmd[0], &mbox_sts[0]) != QLA_SUCCESS) {
+		DEBUG2(printk("qisioctl(%d): %s: MBOX_CMD_READ_FLASH failed w/"
+		    " status %04X\n",
+		    (int)ha->host_no, __func__, mbox_sts[0]));
+
+		ioctl->Status = EXT_STATUS_MAILBOX;
+		ioctl->DetailStatus = mbox_sts[0];
+
+		goto exit_query_hba_portal;
+	}
+
+	phba_portal->SerialNum = le32_to_cpu(sys_info->serialNumber);
+	memcpy(phba_portal->IPAddr.IPAddress, ha->ip_address,
+	    MIN(sizeof(phba_portal->IPAddr.IPAddress), sizeof(ha->ip_address)));
+	memcpy(phba_portal->MacAddr, sys_info->physAddr[0].address,
+	    sizeof(phba_portal->MacAddr));
+	memcpy(phba_portal->Manufacturer, sys_info->vendorId,
+	    sizeof(phba_portal->Manufacturer));
+	memcpy(phba_portal->Model, sys_info->productId,
+	    sizeof(phba_portal->Model));
+
+	/*
+	 * Copy the IOCTL EXT_HBA_ISCSI_PORTAL buffer to the user's data space
+	 */
+	ioctl->Status = EXT_STATUS_OK;
+	if ((status = copy_to_user(Q64BIT_TO_PTR(ioctl->ResponseAdr,
+						 ioctl->AddrMode),
+				   phba_portal, ioctl->ResponseLen)) != 0) {
+		DEBUG2(printk("qisioctl(%d): %s: copy_to_user failed\n",
+		    (int)ha->host_no, __func__));
+
+		ioctl->Status = EXT_STATUS_COPY_ERR;
+	}
+	DUMP_HBA_ISCSI_PORTAL(phba_portal);
+exit_query_hba_portal:
+	LEAVE_IOCTL(__func__, ha->host_no);
+	return(status);
+}
+
+static int ql4_query_disc_iscsi_node(struct hba_ioctl *ql4im_ha,
+				EXT_IOCTL_ISCSI *ioctl)
+{
+	int status = 0;
+	struct dev_db_entry *fw_ddb_entry = (struct dev_db_entry *)ql4im_ha->dma_v;
+	EXT_DISC_ISCSI_NODE *pdisc_node;
+	struct ddb_entry *ddb_entry = NULL;
+	struct scsi_qla_host *ha;
+	uint32_t mbox_cmd[MBOX_REG_COUNT];
+	uint32_t mbox_sts[MBOX_REG_COUNT];
+
+	ha = ql4im_ha->ha;
+
+	ENTER_IOCTL(__func__, ha->host_no);
+
+	if (!ioctl->ResponseAdr ||
+		(ioctl->ResponseLen < sizeof(*pdisc_node))) {
+		DEBUG2(printk("qisioctl%lx: %s: no response buffer found.\n",
+		    ha->host_no, __func__));
+		ioctl->Status = EXT_STATUS_BUFFER_TOO_SMALL;
+		goto exit_disc_node;
+	}
+
+	pdisc_node = (EXT_DISC_ISCSI_NODE *)ql4im_ha->tmp_buf;
+	
+	/* get device database entry info from firmware */
+	memset(&mbox_cmd, 0, sizeof(mbox_cmd));
+	memset(&mbox_sts, 0, sizeof(mbox_sts));
+
+	mbox_cmd[0] = MBOX_CMD_GET_DATABASE_ENTRY;
+	mbox_cmd[1] = (uint32_t)ioctl->Instance;
+	mbox_cmd[2] = LSDW(ql4im_ha->dma_p);
+	mbox_cmd[3] = MSDW(ql4im_ha->dma_p);
+
+	if (ha->ql4mbx(ha, MBOX_REG_COUNT, 7, &mbox_cmd[0], &mbox_sts[0]) != QLA_SUCCESS) {
+		DEBUG2(printk("qisioctl%lx: %s: failed to get DEV_DB_ENTRY\n",
+		    ha->host_no, __func__));
+
+		ioctl->Status = EXT_STATUS_ERR;
+		ioctl->RequestLen = 0;
+		ioctl->DetailStatus = ioctl->Instance;
+		goto exit_disc_node;
+	}
+
+	/* --- Transfer data from Fw's DEV_DB_ENTRY buffer to
+	*      IOCTL's EXT_DISC_ISCSI_PORTAL buffer --- */
+	memset(pdisc_node, 0, sizeof(EXT_DISC_ISCSI_NODE));
+	pdisc_node->NodeInfo.PortalCount = 1;
+	pdisc_node->NodeInfo.IPAddr.Type = EXT_DEF_TYPE_ISCSI_IP;
+	memcpy(pdisc_node->NodeInfo.IPAddr.IPAddress, fw_ddb_entry->ip_addr,
+	    MIN(sizeof(pdisc_node->NodeInfo.IPAddr.IPAddress),
+	    sizeof(fw_ddb_entry->ip_addr)));
+	strncpy(pdisc_node->NodeInfo.Alias, fw_ddb_entry->iscsi_alias,
+	    MIN(sizeof(pdisc_node->NodeInfo.Alias),
+	    sizeof(fw_ddb_entry->iscsi_alias)));
+	strncpy(pdisc_node->NodeInfo.iSCSIName, fw_ddb_entry->iscsi_name,
+	    MIN(sizeof(pdisc_node->NodeInfo.iSCSIName),
+	    sizeof(fw_ddb_entry->iscsi_name)));
+
+	if (ioctl->Instance < MAX_DDB_ENTRIES){
+		ddb_entry = ha->fw_ddb_index_map[ioctl->Instance];
+		if ((ddb_entry == NULL) ||
+			(ddb_entry == (struct ddb_entry *)INVALID_ENTRY))
+			ddb_entry = NULL;
+	}
+	
+	if (ddb_entry == NULL) {
+		DEBUG2(printk("qisioctl%lx: %s: device index [%d] not logged in. "
+		    "Dummy target info returned.\n",
+		    ha->host_no, __func__, ioctl->Instance));
+
+		pdisc_node->SessionID	    = 0xDEAD;
+		pdisc_node->ConnectionID    = 0xDEAD;
+		pdisc_node->PortalGroupID   = 0xDEAD;
+		pdisc_node->ScsiAddr.Bus    = 0xFF;
+		pdisc_node->ScsiAddr.Target = 0xFF;
+		pdisc_node->ScsiAddr.Lun    = 0xFF;
+	}
+	else {
+		pdisc_node->SessionID	    = ddb_entry->target_session_id;
+		pdisc_node->ConnectionID    = ddb_entry->connection_id;
+		pdisc_node->PortalGroupID   = 0;
+		pdisc_node->ScsiAddr.Bus    = 0;
+		pdisc_node->ScsiAddr.Target = QL4_DDB_TO_TGTID(ddb_entry);
+		pdisc_node->ScsiAddr.Lun    = 0;
+	}
+
+	/* --- Copy Results to user space --- */
+	ioctl->Status = EXT_STATUS_OK;
+	if ((status = copy_to_user(Q64BIT_TO_PTR(ioctl->ResponseAdr,
+						 ioctl->AddrMode),
+				   pdisc_node,
+				   sizeof(EXT_DISC_ISCSI_NODE))) != 0) {
+		DEBUG2(printk("qisioctl%lx: %s: copy_to_user failed\n",
+		    ha->host_no, __func__));
+
+		ioctl->Status = EXT_STATUS_COPY_ERR;
+	}
+
+exit_disc_node:
+	LEAVE_IOCTL(__func__, ha->host_no);
+
+	return(status);
+}
+
+static int ql4_query_disc_iscsi_portal(struct hba_ioctl *ql4im_ha,
+					EXT_IOCTL_ISCSI *ioctl)
+{
+	int status = 0;
+	struct dev_db_entry *fw_ddb_entry;
+	EXT_DISC_ISCSI_PORTAL *pdisc_portal;
+	uint32_t mbox_cmd[MBOX_REG_COUNT];
+	uint32_t mbox_sts[MBOX_REG_COUNT];
+	struct scsi_qla_host *ha;
+
+	ha = ql4im_ha->ha;
+	ENTER_IOCTL(__func__, ha->host_no);
+
+	if (!ioctl->ResponseAdr ||
+		(ioctl->ResponseLen < sizeof(*pdisc_portal))) {
+		DEBUG2(printk("qisioctl%lx: %s: no response buffer found.\n",
+		    ha->host_no, __func__));
+		ioctl->Status = EXT_STATUS_BUFFER_TOO_SMALL;
+		goto exit_disc_portal;
+	}
+
+	pdisc_portal = (EXT_DISC_ISCSI_PORTAL *)ql4im_ha->tmp_buf;
+
+	memset(&mbox_cmd, 0, sizeof(mbox_cmd));
+	memset(&mbox_sts, 0, sizeof(mbox_sts));
+
+	fw_ddb_entry = (struct dev_db_entry *) ql4im_ha->dma_v;
+
+	mbox_cmd[0] = MBOX_CMD_GET_DATABASE_ENTRY;
+	mbox_cmd[1] = (uint32_t)ioctl->Instance;
+	mbox_cmd[2] = LSDW(ql4im_ha->dma_p);
+	mbox_cmd[3] = MSDW(ql4im_ha->dma_p);
+
+	if (ha->ql4mbx(ha, MBOX_REG_COUNT, 7, &mbox_cmd[0], &mbox_sts[0]) != QLA_SUCCESS) {
+		DEBUG2(printk("qisioctl%lx: %s: failed to get DEV_DB_ENTRY\n",
+		    ha->host_no, __func__));
+
+		ioctl->Status = EXT_STATUS_ERR;
+		ioctl->RequestLen = 0;
+		ioctl->DetailStatus = ioctl->Instance;
+		goto exit_disc_portal;
+	}
+
+	memset(pdisc_portal, 0, sizeof(EXT_DISC_ISCSI_PORTAL));
+	memcpy(pdisc_portal->IPAddr.IPAddress, fw_ddb_entry->ip_addr,
+	    MIN(sizeof(pdisc_portal->IPAddr.IPAddress),
+	    sizeof(fw_ddb_entry->ip_addr)));
+
+	pdisc_portal->PortNumber = le16_to_cpu(fw_ddb_entry->port);
+	pdisc_portal->IPAddr.Type = EXT_DEF_TYPE_ISCSI_IP;
+	pdisc_portal->NodeCount = 0;
+
+	strncpy(pdisc_portal->HostName, fw_ddb_entry->iscsi_name,
+	    MIN(sizeof(pdisc_portal->HostName),
+	    sizeof(fw_ddb_entry->iscsi_name)));
+
+	ioctl->Status = EXT_STATUS_OK;
+	if ((status = copy_to_user(Q64BIT_TO_PTR(ioctl->ResponseAdr,
+						 ioctl->AddrMode),
+				   pdisc_portal,
+				   sizeof(EXT_DISC_ISCSI_PORTAL))) != 0) {
+		DEBUG2(printk("qisioctl%lx: %s: copy_to_user failed\n",
+		    ha->host_no, __func__));
+
+		ioctl->Status = EXT_STATUS_COPY_ERR;
+	}
+exit_disc_portal:
+	LEAVE_IOCTL(__func__, ha->host_no);
+	return(status);
+}
+
+static int ql4_query_driver(struct hba_ioctl *ql4im_ha,
+			EXT_IOCTL_ISCSI *ioctl)
+{
+	EXT_DRIVER_INFO *pdinfo;
+	struct scsi_qla_host *ha;
+	int status = 0;
+
+	ha = ql4im_ha->ha;
+	ENTER_IOCTL(__func__, ha->host_no);
+
+	if (!ioctl->ResponseAdr || (ioctl->ResponseLen < sizeof(*pdinfo))) {
+		DEBUG2(printk("qisioctl%lx: %s: no response buffer found.\n",
+		    ha->host_no, __func__));
+		ioctl->Status = EXT_STATUS_BUFFER_TOO_SMALL;
+		goto exit_query_driver;
+	}
+
+	pdinfo = (EXT_DRIVER_INFO *)ql4im_ha->tmp_buf;
+
+	memset(pdinfo, 0, sizeof(EXT_DRIVER_INFO));
+	strcpy(pdinfo->Version, drvr_ver);
+
+	pdinfo->NumOfBus	= EXT_DEF_MAX_HBA;
+	pdinfo->TargetsPerBus	= EXT_DEF_MAX_TARGET;
+	pdinfo->LunPerTarget	= EXT_DEF_MAX_LUN;
+	pdinfo->LunPerTargetOS	= EXT_DEF_MAX_BUS;
+
+	if (sizeof(dma_addr_t) > 4)
+		pdinfo->DmaBitAddresses = 1;  /* 64-bit */
+	else
+		pdinfo->DmaBitAddresses = 0;  /* 32-bit */
+
+	pdinfo->IoMapType	= 1;
+
+	ioctl->Status = EXT_STATUS_OK;
+	if ((status = copy_to_user(Q64BIT_TO_PTR(ioctl->ResponseAdr,
+						 ioctl->AddrMode), pdinfo,
+				   sizeof(EXT_DRIVER_INFO))) != 0) {
+		DEBUG2(printk("qisioctl%lx: %s: copy_to_user failed\n",
+		    ha->host_no, __func__));
+
+		ioctl->Status = EXT_STATUS_COPY_ERR;
+	}
+
+exit_query_driver:
+	LEAVE_IOCTL(__func__, ha->host_no);
+
+	return(status);
+}
+
+static int ql4_query_fw(struct hba_ioctl *ql4im_ha, 
+			EXT_IOCTL_ISCSI *ioctl)
+{
+	EXT_FW_INFO *pfw_info;
+	uint32_t mbox_cmd[MBOX_REG_COUNT];
+	uint32_t mbox_sts[MBOX_REG_COUNT];
+	struct scsi_qla_host *ha;
+	int status = 0;
+
+	ha = ql4im_ha->ha;
+
+	ENTER_IOCTL(__func__, ha->host_no);
+
+	if (!ioctl->ResponseAdr || (ioctl->ResponseLen < sizeof(*pfw_info))) {
+		DEBUG2(printk("qisioctl%lx: %s: no response buffer found.\n",
+		    ha->host_no, __func__));
+		ioctl->Status = EXT_STATUS_BUFFER_TOO_SMALL;
+		goto exit_query_fw;
+	}
+
+	pfw_info = (EXT_FW_INFO *)ql4im_ha->tmp_buf;
+	memset(pfw_info, 0, sizeof(EXT_FW_INFO));
+
+	/* ----- Get firmware version information ---- */
+	memset(&mbox_cmd, 0, sizeof(mbox_cmd));
+	memset(&mbox_sts, 0, sizeof(mbox_sts));
+	mbox_cmd[0] = MBOX_CMD_ABOUT_FW;
+
+	/*
+	 * NOTE: In QLA4010, mailboxes 2 & 3 may hold an address for data.
+	 * Make sure that we write 0 to those mailboxes, if unused.
+	 */
+	if (ha->ql4mbx(ha, MBOX_REG_COUNT, 5, &mbox_cmd[0], &mbox_sts[0]) != QLA_SUCCESS) {
+		DEBUG2(printk("qisioctl%lx: %s: MBOX_CMD_ABOUT_FW failed w/ "
+		    "status %04X\n", ha->host_no, __func__, mbox_sts[0]));
+		ioctl->Status = EXT_STATUS_MAILBOX;
+		ioctl->DetailStatus = mbox_sts[0];
+		goto exit_query_fw;
+	}
+
+	sprintf(pfw_info->Version, "FW Version %d.%d Patch %d Build %d",
+	    mbox_sts[1], mbox_sts[2], mbox_sts[3], mbox_sts[4]);
+
+	ioctl->Status = EXT_STATUS_OK;
+	if ((status = copy_to_user(Q64BIT_TO_PTR(ioctl->ResponseAdr,
+						 ioctl->AddrMode), pfw_info,
+				sizeof(EXT_FW_INFO))) != 0) {
+		DEBUG2(printk("qisioctl%lx: %s: copy_to_user failed\n",
+		    ha->host_no, __func__));
+		ioctl->Status = EXT_STATUS_COPY_ERR;
+	}
+
+exit_query_fw:
+	LEAVE_IOCTL(__func__, ha->host_no);
+
+	return(status);
+}
+
+static int ql4_query_chip(struct hba_ioctl *ql4im_ha,
+			EXT_IOCTL_ISCSI *ioctl)
+{
+	int		status = 0;
+	uint32_t	mbox_cmd[MBOX_REG_COUNT];
+	uint32_t	mbox_sts[MBOX_REG_COUNT];
+	EXT_CHIP_INFO	*pchip_info;
+	struct flash_sys_info *sys_info;
+	struct scsi_qla_host *ha;
+
+	ha = ql4im_ha->ha;
+
+	ENTER_IOCTL(__func__, ha->host_no);
+
+	if (!ioctl->ResponseAdr || 
+		(ioctl->ResponseLen < sizeof(EXT_CHIP_INFO))) {
+		DEBUG2(printk("qisioctl(%d): %s: no response buffer found.\n",
+		    (int)ha->host_no, __func__));
+		ioctl->Status = EXT_STATUS_BUFFER_TOO_SMALL;
+		goto exit_query_chip;
+	}
+
+	pchip_info = (EXT_CHIP_INFO *)ql4im_ha->tmp_buf;
+	memset(pchip_info, 0, sizeof(EXT_CHIP_INFO));
+
+	sys_info = (struct flash_sys_info *) ql4im_ha->dma_v;
+
+	memset(&mbox_cmd, 0, sizeof(mbox_cmd));
+	memset(&mbox_sts, 0, sizeof(mbox_sts));
+	mbox_cmd[0] = MBOX_CMD_READ_FLASH;
+	mbox_cmd[1] = LSDW(ql4im_ha->dma_p);
+	mbox_cmd[2] = MSDW(ql4im_ha->dma_p);
+	mbox_cmd[3] = INT_ISCSI_SYSINFO_FLASH_OFFSET;
+	mbox_cmd[4] = sizeof(*sys_info);
+
+	if (ha->ql4mbx(ha, MBOX_REG_COUNT, 2, &mbox_cmd[0], &mbox_sts[0]) != QLA_SUCCESS) {
+		DEBUG2(printk("qisioctl(%d): %s: MBOX_CMD_READ_FLASH failed w/"
+		    " status %04X\n",
+		    (int)ha->host_no, __func__, mbox_sts[0]));
+
+		ioctl->Status = EXT_STATUS_MAILBOX;
+		ioctl->DetailStatus = mbox_sts[0];
+
+		goto exit_query_chip;
+	}
+
+	pchip_info->VendorId	= le32_to_cpu(sys_info->pciDeviceVendor);
+	pchip_info->DeviceId	= le32_to_cpu(sys_info->pciDeviceId);
+	pchip_info->SubVendorId = le32_to_cpu(sys_info->pciSubsysVendor);
+	pchip_info->SubSystemId = le32_to_cpu(sys_info->pciSubsysId);
+	pchip_info->BoardID	= ha->board_id;
+
+	ioctl->Status = EXT_STATUS_OK;
+	if ((status = copy_to_user(
+		Q64BIT_TO_PTR(ioctl->ResponseAdr, ioctl->AddrMode), 
+		pchip_info, sizeof(EXT_CHIP_INFO))) != 0) {
+		DEBUG2(printk("qisioctl(%d): %s: copy_to_user failed\n",
+		    (int)ha->host_no, __func__));
+		ioctl->Status = EXT_STATUS_COPY_ERR;
+	}
+	DUMP_CHIP_INFO(pchip_info);
+
+exit_query_chip:
+	LEAVE_IOCTL(__func__, ha->host_no);
+	return(status);
+}
+
+static int ql4_query_ipstate(struct hba_ioctl *ql4im_ha,
+			EXT_IOCTL_ISCSI *ioctl)
+{
+	int		status = 0;
+	uint32_t	mbox_cmd[MBOX_REG_COUNT];
+	uint32_t	mbox_sts[MBOX_REG_COUNT];
+	EXT_QUERY_IP_STATE *ip_state;
+	struct scsi_qla_host *ha;
+
+	ha = ql4im_ha->ha;
+
+	ENTER_IOCTL(__func__, ha->host_no);
+
+	if (!ioctl->ResponseAdr || 
+		(ioctl->ResponseLen < sizeof(EXT_QUERY_IP_STATE))) {
+		DEBUG2(printk("qisioctl(%d): %s: no response buffer found.\n",
+		    (int)ha->host_no, __func__));
+		ioctl->Status = EXT_STATUS_BUFFER_TOO_SMALL;
+		goto exit_query_ipstate;
+	}
+
+	ip_state = (EXT_QUERY_IP_STATE *)ql4im_ha->tmp_buf;
+	memset(ip_state, 0, sizeof(EXT_QUERY_IP_STATE));
+
+	memset(&mbox_cmd, 0, sizeof(mbox_cmd));
+	memset(&mbox_sts, 0, sizeof(mbox_sts));
+	mbox_cmd[0] = MBOX_CMD_GET_IP_ADDR_STATE;
+	mbox_cmd[1] = ioctl->Instance;
+	mbox_cmd[2] = ioctl->Reserved1;
+
+	if (ha->ql4mbx(ha, MBOX_REG_COUNT, 8, &mbox_cmd[0], &mbox_sts[0]) != QLA_SUCCESS) {
+		DEBUG2(printk("qisioctl(%d): %s: MBOX_CMD 0x91 failed w/"
+		    " status 0x%04x\n",
+		    (int)ha->host_no, __func__, mbox_sts[0]));
+
+		ioctl->Status = EXT_STATUS_MAILBOX;
+		ioctl->DetailStatus = mbox_sts[0];
+		goto exit_query_ipstate;
+	}
+
+	memcpy(ip_state->IP_ACBState, &mbox_sts[1],
+		MIN(sizeof(ip_state->IP_ACBState), sizeof(mbox_sts[1])));
+
+	ip_state->ValidLifetime = le32_to_cpu(mbox_sts[2]);
+	ip_state->PreferredLifetime = le32_to_cpu(mbox_sts[3]);
+
+	memcpy(ip_state->IPAddressInfo1, &mbox_sts[4],
+		MIN(sizeof(ip_state->IPAddressInfo1), sizeof(mbox_sts[4])));
+	memcpy(ip_state->IPAddressInfo2, &mbox_sts[5],
+		MIN(sizeof(ip_state->IPAddressInfo2), sizeof(mbox_sts[5])));
+	memcpy(ip_state->IPAddressInfo3, &mbox_sts[6],
+		MIN(sizeof(ip_state->IPAddressInfo3), sizeof(mbox_sts[6])));
+	memcpy(ip_state->IPAddressInfo4, &mbox_sts[7],
+		MIN(sizeof(ip_state->IPAddressInfo4), sizeof(mbox_sts[7])));
+
+	ioctl->Status = EXT_STATUS_OK;
+
+	if ((status = copy_to_user(
+		Q64BIT_TO_PTR(ioctl->ResponseAdr, ioctl->AddrMode), 
+		ip_state, sizeof(EXT_QUERY_IP_STATE))) != 0) {
+		DEBUG2(printk("qisioctl(%d): %s: copy_to_user failed\n",
+		    (int)ha->host_no, __func__));
+		ioctl->Status = EXT_STATUS_COPY_ERR;
+	}
+
+exit_query_ipstate:
+	LEAVE_IOCTL(__func__, ha->host_no);
+	return(status);
+}
+
+static int ql4_query_cur_ip(struct hba_ioctl *ql4im_ha,
+			EXT_IOCTL_ISCSI *ioctl)
+{
+	int		status = 0;
+	uint32_t	mbox_cmd[MBOX_REG_COUNT];
+	uint32_t	mbox_sts[MBOX_REG_COUNT];
+	EXT_QUERY_DEVICE_CURRENT_IP *ip;
+	struct scsi_qla_host *ha;
+
+	ha = ql4im_ha->ha;
+
+	ENTER_IOCTL(__func__, ha->host_no);
+
+	if (!ioctl->ResponseAdr || 
+		(ioctl->ResponseLen < sizeof(EXT_QUERY_DEVICE_CURRENT_IP))) {
+		DEBUG2(printk("qisioctl(%d): %s: no response buffer found.\n",
+		    (int)ha->host_no, __func__));
+		ioctl->Status = EXT_STATUS_BUFFER_TOO_SMALL;
+		goto exit_query_ipstate;
+	}
+
+	ip = (EXT_QUERY_DEVICE_CURRENT_IP *)ql4im_ha->tmp_buf;
+	memset(ip, 0, sizeof(EXT_QUERY_DEVICE_CURRENT_IP));
+
+	memset(&mbox_cmd, 0, sizeof(mbox_cmd));
+	memset(&mbox_sts, 0, sizeof(mbox_sts));
+	mbox_cmd[0] = MBOX_CMD_GET_DB_ENTRY_CURRENT_IP_ADDR;
+	mbox_cmd[1] = ioctl->Instance;
+
+	if (ha->ql4mbx(ha, MBOX_REG_COUNT, 8, &mbox_cmd[0], &mbox_sts[0]) != QLA_SUCCESS) {
+		DEBUG2(printk("qisioctl(%d): %s: MBOX_CMD 0x93 failed w/"
+		    " status 0x%04x\n",
+		    (int)ha->host_no, __func__, mbox_sts[0]));
+
+		ioctl->Status = EXT_STATUS_MAILBOX;
+		ioctl->DetailStatus = mbox_sts[0];
+
+		goto exit_query_ipstate;
+	}
+
+	memcpy(&ip->Addr.IPAddress[0], &mbox_sts[3], sizeof(mbox_sts[3]));
+	memcpy(&ip->Addr.IPAddress[4], &mbox_sts[4], sizeof(mbox_sts[4]));
+	memcpy(&ip->Addr.IPAddress[8], &mbox_sts[5], sizeof(mbox_sts[5]));
+	memcpy(&ip->Addr.IPAddress[12], &mbox_sts[6], sizeof(mbox_sts[6]));
+
+	if (mbox_sts[2] & 0x10) 
+		ip->Addr.Type = EXT_DEF_TYPE_ISCSI_IPV6;
+
+	ip->DeviceState = le16_to_cpu((mbox_sts[1] >> 16));
+	ip->TCPPort 	= le16_to_cpu((mbox_sts[2] >> 16));
+	memcpy(&ip->Flags[0], &mbox_sts[2], sizeof(ip->Flags));
+
+	ioctl->Status = EXT_STATUS_OK;
+
+	if ((status = copy_to_user(
+		Q64BIT_TO_PTR(ioctl->ResponseAdr, ioctl->AddrMode), 
+		ip, sizeof(EXT_QUERY_DEVICE_CURRENT_IP))) != 0) {
+		DEBUG2(printk("qisioctl(%d): %s: copy_to_user failed\n",
+		    (int)ha->host_no, __func__));
+		ioctl->Status = EXT_STATUS_COPY_ERR;
+	}
+
+exit_query_ipstate:
+	LEAVE_IOCTL(__func__, ha->host_no);
+	return(status);
+}
+
+static int ql4_query(struct hba_ioctl *ql4im_ha, EXT_IOCTL_ISCSI *ioctl)
+{
+	int status = 0;
+
+	switch (ioctl->SubCode) {
+	case EXT_SC_QUERY_HBA_ISCSI_NODE:
+		status = ql4_query_hba_iscsi_node(ql4im_ha, ioctl);
+		break;
+	case EXT_SC_QUERY_HBA_ISCSI_PORTAL:
+		status = ql4_query_hba_iscsi_portal(ql4im_ha, ioctl);
+		break;
+	case EXT_SC_QUERY_DISC_ISCSI_NODE:
+		status = ql4_query_disc_iscsi_node(ql4im_ha, ioctl);
+		break;
+	case EXT_SC_QUERY_DISC_ISCSI_PORTAL:
+		status = ql4_query_disc_iscsi_portal(ql4im_ha, ioctl);
+		break;
+	case EXT_SC_QUERY_DRIVER:
+		status = ql4_query_driver(ql4im_ha, ioctl);
+		break;
+	case EXT_SC_QUERY_FW:
+		status = ql4_query_fw(ql4im_ha, ioctl);
+		break;
+	case EXT_SC_QUERY_CHIP:
+		status = ql4_query_chip(ql4im_ha, ioctl);
+		break;
+	case EXT_SC_QUERY_IP_STATE:
+		status = ql4_query_ipstate(ql4im_ha, ioctl);
+		break;
+	case EXT_SC_QUERY_DEVICE_CURRENT_IP:
+		status = ql4_query_cur_ip(ql4im_ha, ioctl);
+		break;
+	default:
+		DEBUG2(printk("qisioctl%lx: %s: unsupported qry sub-code(%x)\n",
+		    ql4im_ha->ha->host_no, __func__, ioctl->SubCode));
+
+		ioctl->Status = EXT_STATUS_UNSUPPORTED_SUBCODE;
+	}
+	return(status);
+}
+
+static int ql4_get_statistics_gen(struct hba_ioctl *ql4im_ha, 
+				EXT_IOCTL_ISCSI *ioctl)
+{
+	int			status = 0;
+	EXT_HBA_PORT_STAT_GEN	*pstat_gen;
+	struct scsi_qla_host	*ha;
+
+	ha = ql4im_ha->ha;
+
+	ENTER_IOCTL(__func__, ha->host_no);
+
+	if (ioctl->ResponseLen < sizeof(EXT_HBA_PORT_STAT_GEN)) {
+		DEBUG2(printk("qisioctl%lx: %s: memory area too small\n",
+			ha->host_no, __func__));
+
+		ioctl->Status = EXT_STATUS_BUFFER_TOO_SMALL;
+		goto exit_get_stat_gen;
+	}
+
+	pstat_gen = (EXT_HBA_PORT_STAT_GEN *)ql4im_ha->tmp_buf;
+	memset(pstat_gen, 0, sizeof(EXT_HBA_PORT_STAT_GEN));
+
+	pstat_gen->HBAPortErrorCount	 = ha->adapter_error_count;
+	pstat_gen->DevicePortErrorCount  = ha->device_error_count;
+	pstat_gen->IoCount		 = ha->total_io_count;
+	pstat_gen->MBytesCount		 = ha->total_mbytes_xferred;
+	pstat_gen->InterruptCount	 = ha->isr_count;
+	pstat_gen->LinkFailureCount	 = ha->link_failure_count;
+	pstat_gen->InvalidCrcCount	 = ha->invalid_crc_count;
+
+	ioctl->Status = EXT_STATUS_OK;
+
+	if ((status = copy_to_user(Q64BIT_TO_PTR(ioctl->ResponseAdr,
+						 ioctl->AddrMode), pstat_gen,
+				   ioctl->ResponseLen)) != 0) {
+		DEBUG2(printk("qisioctl%lx: %s: memory area too small\n",
+		    ha->host_no, __func__));
+
+		ioctl->Status = EXT_STATUS_COPY_ERR;
+	}
+
+exit_get_stat_gen:
+	LEAVE_IOCTL(__func__, ha->host_no);
+	return(status);
+}
+
+static int ql4_get_statistics_iscsi(struct hba_ioctl *ql4im_ha, 
+				EXT_IOCTL_ISCSI *ioctl)
+{
+	int status = 0;
+	uint32_t mbox_cmd[MBOX_REG_COUNT];
+	uint32_t mbox_sts[MBOX_REG_COUNT];
+	EXT_HBA_PORT_STAT_ISCSI *pstat_local;
+	EXT_HBA_PORT_STAT_ISCSI *pstat_user;
+	struct scsi_qla_host	*ha;
+
+	ha = ql4im_ha->ha;
+
+	ENTER_IOCTL(__func__, ha->host_no);
+
+	if (!ioctl->ResponseAdr || !ioctl->ResponseLen ||
+		(ioctl->ResponseLen < sizeof(EXT_HBA_PORT_STAT_ISCSI))) {
+		DEBUG2(printk("qisioctl%lx: %s: invalid parameter\n",
+		    ha->host_no, __func__));
+
+		ioctl->Status = EXT_STATUS_INVALID_PARAM;
+		goto exit_get_stats_iscsi;
+	}
+
+	pstat_user = (EXT_HBA_PORT_STAT_ISCSI *)ql4im_ha->tmp_buf;
+
+	/*
+	 * Make the mailbox call
+	 */
+	memset(&mbox_cmd, 0, sizeof(mbox_cmd));
+	memset(&mbox_sts, 0, sizeof(mbox_sts));
+	mbox_cmd[0] = MBOX_CMD_GET_MANAGEMENT_DATA; 
+	mbox_cmd[1] = ioctl->Instance;
+	mbox_cmd[2] = LSDW(ql4im_ha->dma_p);
+	mbox_cmd[3] = MSDW(ql4im_ha->dma_p);
+
+	if (ha->ql4mbx(ha, MBOX_REG_COUNT, 1, &mbox_cmd[0], &mbox_sts[0]) != QLA_SUCCESS) {
+		DEBUG2(printk("qisioctl%lx: %s: get mngmt data for index [%d] failed "
+		    "w/ mailbox ststus 0x%x\n",
+		    ha->host_no, __func__, ioctl->Instance, mbox_sts[0]));
+
+		ioctl->Status = EXT_STATUS_MAILBOX;
+		ioctl->DetailStatus = mbox_sts[0];
+		goto exit_get_stats_iscsi;
+	}
+
+	pstat_local = (EXT_HBA_PORT_STAT_ISCSI *) ql4im_ha->dma_v;
+	memset(pstat_user, 0, sizeof(EXT_HBA_PORT_STAT_ISCSI));
+	pstat_user->MACTxFramesCount	      =
+	    le64_to_cpu(pstat_local->MACTxFramesCount);
+	pstat_user->MACTxBytesCount	      =
+	    le64_to_cpu(pstat_local->MACTxBytesCount);
+	pstat_user->MACRxFramesCount	      =
+	    le64_to_cpu(pstat_local->MACRxFramesCount);
+	pstat_user->MACRxBytesCount	      =
+	    le64_to_cpu(pstat_local->MACRxBytesCount);
+	pstat_user->MACCRCErrorCount	      =
+	    le64_to_cpu(pstat_local->MACCRCErrorCount);
+	pstat_user->MACEncodingErrorCount     =
+	    le64_to_cpu(pstat_local->MACEncodingErrorCount);
+	pstat_user->IPTxPacketsCount	      =
+	    le64_to_cpu(pstat_local->IPTxPacketsCount);
+	pstat_user->IPTxBytesCount	      =
+	    le64_to_cpu(pstat_local->IPTxBytesCount);
+	pstat_user->IPTxFragmentsCount	      =
+	    le64_to_cpu(pstat_local->IPTxFragmentsCount);
+	pstat_user->IPRxPacketsCount	      =
+	    le64_to_cpu(pstat_local->IPRxPacketsCount);
+	pstat_user->IPRxBytesCount	      =
+	    le64_to_cpu(pstat_local->IPRxBytesCount);
+	pstat_user->IPRxFragmentsCount	      =
+	    le64_to_cpu(pstat_local->IPRxFragmentsCount);
+	pstat_user->IPDatagramReassemblyCount =
+	    le64_to_cpu(pstat_local->IPDatagramReassemblyCount);
+	pstat_user->IPv6RxPacketsCount	      =
+	    le64_to_cpu(pstat_local->IPv6RxPacketsCount);
+	pstat_user->IPRxPacketErrorCount      =
+	    le64_to_cpu(pstat_local->IPRxPacketErrorCount);
+	pstat_user->IPReassemblyErrorCount    =
+	    le64_to_cpu(pstat_local->IPReassemblyErrorCount);
+	pstat_user->TCPTxSegmentsCount	      =
+	    le64_to_cpu(pstat_local->TCPTxSegmentsCount);
+	pstat_user->TCPTxBytesCount	      =
+	    le64_to_cpu(pstat_local->TCPTxBytesCount);
+	pstat_user->TCPRxSegmentsCount	      =
+	    le64_to_cpu(pstat_local->TCPRxSegmentsCount);
+	pstat_user->TCPRxBytesCount	      =
+	    le64_to_cpu(pstat_local->TCPRxBytesCount);
+	pstat_user->TCPTimerExpiredCount      =
+	    le64_to_cpu(pstat_local->TCPTimerExpiredCount);
+	pstat_user->TCPRxACKCount	      =
+	    le64_to_cpu(pstat_local->TCPRxACKCount);
+	pstat_user->TCPTxACKCount	      =
+	    le64_to_cpu(pstat_local->TCPTxACKCount);
+	pstat_user->TCPRxErrorSegmentCount    =
+	    le64_to_cpu(pstat_local->TCPRxErrorSegmentCount);
+	pstat_user->TCPWindowProbeUpdateCount =
+	    le64_to_cpu(pstat_local->TCPWindowProbeUpdateCount);
+	pstat_user->iSCSITxPDUCount	      =
+	    le64_to_cpu(pstat_local->iSCSITxPDUCount);
+	pstat_user->iSCSITxBytesCount	      =
+	    le64_to_cpu(pstat_local->iSCSITxBytesCount);
+	pstat_user->iSCSIRxPDUCount	      =
+	    le64_to_cpu(pstat_local->iSCSIRxPDUCount);
+	pstat_user->iSCSIRxBytesCount	      =
+	    le64_to_cpu(pstat_local->iSCSIRxBytesCount);
+	pstat_user->iSCSICompleteIOsCount     =
+	    le64_to_cpu(pstat_local->iSCSICompleteIOsCount);
+	pstat_user->iSCSIUnexpectedIORxCount  =
+	    le64_to_cpu(pstat_local->iSCSIUnexpectedIORxCount);
+	pstat_user->iSCSIFormatErrorCount     =
+	    le64_to_cpu(pstat_local->iSCSIFormatErrorCount);
+	pstat_user->iSCSIHeaderDigestCount    =
+	    le64_to_cpu(pstat_local->iSCSIHeaderDigestCount);
+	pstat_user->iSCSIDataDigestErrorCount =
+	    le64_to_cpu(pstat_local->iSCSIDataDigestErrorCount);
+	pstat_user->iSCSISeqErrorCount	      =
+	    le64_to_cpu(pstat_local->iSCSISeqErrorCount);
+
+	/*
+	 * Copy the data from the dma buffer to the user's data space
+	 */
+	ioctl->Status = EXT_STATUS_OK;
+	if ((status = copy_to_user(Q64BIT_TO_PTR(ioctl->ResponseAdr,
+						 ioctl->AddrMode),
+				   pstat_user, ioctl->ResponseLen)) != 0) {
+		DEBUG2(printk("qisioctl%lx: %s: memory area too small\n",
+			ha->host_no, __func__));
+
+		ioctl->Status = EXT_STATUS_COPY_ERR;
+	}
+
+exit_get_stats_iscsi:
+
+	LEAVE_IOCTL(__func__, ha->host_no);
+
+	return(status);
+}
+
+static int ql4_get_device_entry_iscsi(struct hba_ioctl *ql4im_ha, 
+				EXT_IOCTL_ISCSI *ioctl)
+{
+	int			status = 0;
+	uint32_t		mbox_cmd[MBOX_REG_COUNT];
+	uint32_t		mbox_sts[MBOX_REG_COUNT];
+	struct dev_db_entry	*pfw_ddb_entry;
+	EXT_DEVICE_ENTRY_ISCSI	*pdev_entry;
+	struct scsi_qla_host	*ha;
+
+	ha = ql4im_ha->ha;
+
+	ENTER_IOCTL(__func__, ha->host_no);
+
+	if (!ioctl->ResponseAdr || !ioctl->ResponseLen ||
+		(ioctl->ResponseLen < sizeof(EXT_DEVICE_ENTRY_ISCSI))) {
+		DEBUG2(printk("qisioctl%lx: %s: invalid parameter\n",
+		    ha->host_no, __func__));
+
+		ioctl->Status = EXT_STATUS_INVALID_PARAM;
+		goto exit_get_dev_entry;
+	}
+
+	/*
+	 * Make the mailbox call
+	 */
+	memset(&mbox_cmd, 0, sizeof(mbox_cmd));
+	memset(&mbox_sts, 0, sizeof(mbox_sts));
+
+	if (ioctl->SubCode == EXT_SC_GET_DEVICE_ENTRY_ISCSI)
+		mbox_cmd[0] = MBOX_CMD_GET_DATABASE_ENTRY;
+	else
+		mbox_cmd[0] = MBOX_CMD_GET_DATABASE_ENTRY_DEFAULTS;
+
+	mbox_cmd[1] = ioctl->Instance;
+	mbox_cmd[2] = LSDW(ql4im_ha->dma_p);
+	mbox_cmd[3] = MSDW(ql4im_ha->dma_p);
+
+	if (ha->ql4mbx(ha, MBOX_REG_COUNT, 5, &mbox_cmd[0], &mbox_sts[0]) != QLA_SUCCESS) {
+		DEBUG2(printk("qisioctl%lx: %s: get ddb entry for index [%d] failed "
+		    "w/ mailbox ststus 0x%x\n",
+		    ha->host_no, __func__, ioctl->Instance, mbox_sts[0]));
+
+		ioctl->Status = EXT_STATUS_MAILBOX;
+		ioctl->DetailStatus = mbox_sts[0];
+		goto exit_get_dev_entry;
+	}
+
+	pdev_entry = (EXT_DEVICE_ENTRY_ISCSI *)ql4im_ha->tmp_buf;
+	memset(pdev_entry, 0, sizeof(EXT_DEVICE_ENTRY_ISCSI));
+	/*
+	 * Transfer data from Fw's DEV_DB_ENTRY buffer to IOCTL's
+	 * EXT_DEVICE_ENTRY_ISCSI buffer
+	 */
+	pfw_ddb_entry = (struct dev_db_entry *) ql4im_ha->dma_v;
+
+	pdev_entry->NumValid	 = mbox_sts[2];
+	pdev_entry->NextValid	 = mbox_sts[3];
+	pdev_entry->DeviceState  = mbox_sts[4];
+	pdev_entry->Options	 = pfw_ddb_entry->options;
+	pdev_entry->TargetSessID = le16_to_cpu(pfw_ddb_entry->tsid);
+	memcpy(pdev_entry->InitiatorSessID, pfw_ddb_entry->isid,
+	    sizeof(pfw_ddb_entry->isid));
+
+	pdev_entry->DeviceInfo.DeviceType = le16_to_cpu(EXT_DEF_ISCSI_REMOTE);
+	pdev_entry->DeviceInfo.ExeThrottle =
+	    le16_to_cpu(pfw_ddb_entry->exec_throttle);
+	pdev_entry->DeviceInfo.InitMarkerlessInt =
+	    le16_to_cpu(pfw_ddb_entry->iscsi_max_snd_data_seg_len);
+	pdev_entry->DeviceInfo.iSCSIOptions =
+	    le16_to_cpu(pfw_ddb_entry->iscsi_options);
+	pdev_entry->DeviceInfo.TCPOptions =
+	    le16_to_cpu(pfw_ddb_entry->tcp_options);
+	pdev_entry->DeviceInfo.IPOptions =
+	    le16_to_cpu(pfw_ddb_entry->ip_options);
+	pdev_entry->DeviceInfo.MaxPDUSize =
+	    le16_to_cpu(pfw_ddb_entry->iscsi_max_rcv_data_seg_len);
+	pdev_entry->DeviceInfo.FirstBurstSize =
+	    le16_to_cpu(pfw_ddb_entry->iscsi_first_burst_len);
+	pdev_entry->DeviceInfo.LogoutMinTime =
+	    le16_to_cpu(pfw_ddb_entry->iscsi_def_time2wait);
+	pdev_entry->DeviceInfo.LogoutMaxTime =
+	    le16_to_cpu(pfw_ddb_entry->iscsi_def_time2retain);
+	pdev_entry->DeviceInfo.MaxOutstandingR2T =
+	    le16_to_cpu(pfw_ddb_entry->iscsi_max_outsnd_r2t);
+	pdev_entry->DeviceInfo.KeepAliveTimeout =
+	    le16_to_cpu(pfw_ddb_entry->ka_timeout);
+	pdev_entry->DeviceInfo.PortNumber =
+	    le16_to_cpu(pfw_ddb_entry->port);
+	pdev_entry->DeviceInfo.MaxBurstSize =
+	    le16_to_cpu(pfw_ddb_entry->iscsi_max_burst_len);
+	pdev_entry->DeviceInfo.TaskMgmtTimeout =
+	    le16_to_cpu(pfw_ddb_entry->def_timeout);
+	pdev_entry->EntryInfo.PortalCount = mbox_sts[2];
+	pdev_entry->ExeCount = le16_to_cpu(pfw_ddb_entry->exec_count);
+	pdev_entry->DDBLink = le16_to_cpu(pfw_ddb_entry->ddb_link);
+
+	memcpy(pdev_entry->DeviceInfo.TargetAddr, pfw_ddb_entry->tgt_addr,
+	    MIN(sizeof(pdev_entry->DeviceInfo.TargetAddr), 
+		sizeof(pfw_ddb_entry->tgt_addr)));
+	memcpy(pdev_entry->EntryInfo.IPAddr.IPAddress, pfw_ddb_entry->ip_addr,
+	    MIN(sizeof(pdev_entry->EntryInfo.IPAddr.IPAddress),
+		sizeof(pfw_ddb_entry->ip_addr)));
+	memcpy(pdev_entry->EntryInfo.iSCSIName, pfw_ddb_entry->iscsi_name,
+	    MIN(sizeof(pdev_entry->EntryInfo.iSCSIName),
+		sizeof(pfw_ddb_entry->iscsi_name)));
+	memcpy(pdev_entry->EntryInfo.Alias, pfw_ddb_entry->iscsi_alias,
+	    MIN(sizeof(pdev_entry->EntryInfo.Alias),
+		sizeof(pfw_ddb_entry->iscsi_alias)));
+
+	/*
+	 * Copy the IOCTL EXT_DEVICE_ENTRY_ISCSI buffer to the user's data space
+	 */
+	ioctl->Status = EXT_STATUS_OK;
+	if ((status = copy_to_user(Q64BIT_TO_PTR(ioctl->ResponseAdr,
+						 ioctl->AddrMode),
+				   pdev_entry, ioctl->ResponseLen)) != 0) {
+		DEBUG2(printk("qisioctl%lx: %s: memory area too small\n",
+			ha->host_no, __func__));
+		ioctl->Status = EXT_STATUS_COPY_ERR;
+	}
+
+exit_get_dev_entry:
+	LEAVE_IOCTL(__func__, ha->host_no);
+	return(status);
+}
+
+
+static int ql4_get_init_fw_iscsi(struct hba_ioctl *ql4im_ha, 
+				EXT_IOCTL_ISCSI *ioctl)
+{
+	int		status = 0;
+	uint32_t	mbox_cmd[MBOX_REG_COUNT];
+	uint32_t	mbox_sts[MBOX_REG_COUNT];
+	EXT_INIT_FW_ISCSI *pinit_fw;
+	struct addr_ctrl_blk *acb;
+	struct scsi_qla_host *ha;
+
+	ha = ql4im_ha->ha;
+
+	ENTER_IOCTL(__func__, ha->host_no);
+
+	if (!ioctl->ResponseAdr || !ioctl->ResponseLen ||
+		(ioctl->ResponseLen < sizeof(EXT_DEVICE_ENTRY_ISCSI))) {
+		DEBUG2(printk("qisioctl%lx: %s: invalid parameter\n",
+		    ha->host_no, __func__));
+
+		ioctl->Status = EXT_STATUS_INVALID_PARAM;
+		goto exit_get_init_fw;
+	}
+
+	/*
+	 * Send mailbox command
+	 */
+	memset(&mbox_cmd, 0, sizeof(mbox_cmd));
+	memset(&mbox_sts, 0, sizeof(mbox_sts));
+	switch (ioctl->SubCode) {
+	case EXT_SC_GET_INIT_FW_ISCSI:
+		mbox_cmd[0] = MBOX_CMD_GET_INIT_FW_CTRL_BLOCK;
+		break;
+	case EXT_SC_GET_INIT_FW_DEFAULTS_ISCSI:
+		mbox_cmd[0] = MBOX_CMD_GET_INIT_FW_CTRL_BLOCK_DEFAULTS;
+		break;
+	default:
+		DEBUG2(printk("qisioctl%lx: %s: invalid subcode (0x%04X) speficied\n",
+			ha->host_no, __func__, ioctl->SubCode));
+
+		ioctl->Status = EXT_STATUS_INVALID_PARAM;
+		goto exit_get_init_fw;
+	}
+
+	mbox_cmd[1] = 0;
+	mbox_cmd[2] = LSDW(ql4im_ha->dma_p);
+	mbox_cmd[3] = MSDW(ql4im_ha->dma_p);
+	mbox_cmd[4] = sizeof(struct init_fw_ctrl_blk);
+
+	if (ha->ql4mbx(ha, MBOX_REG_COUNT, 1, &mbox_cmd[0], &mbox_sts[0]) != QLA_SUCCESS) {
+		DEBUG2(printk("qisioctl%lx: %s: command failed \n",
+			ha->host_no, __func__));
+
+		ioctl->Status = EXT_STATUS_ERR;
+		ioctl->DetailStatus = mbox_sts[0];
+		goto exit_get_init_fw;
+	}
+
+	pinit_fw = (EXT_INIT_FW_ISCSI *)ql4im_ha->tmp_buf;
+	memset(pinit_fw, 0, sizeof(EXT_INIT_FW_ISCSI));
+	/*
+	 * Transfer Data from DMA buffer to Local buffer
+	 */
+	acb = (struct addr_ctrl_blk *)ql4im_ha->dma_v;
+
+	pinit_fw->Version	  = acb->version;
+	pinit_fw->FWOptions	  = le16_to_cpu(acb->fw_options);
+	pinit_fw->AddFWOptions	  = le16_to_cpu(acb->add_fw_options);
+	//FIXME: pinit_fw->WakeupThreshold = le16_to_cpu(acb->WakeupThreshold);
+	memcpy(&pinit_fw->IPAddr.IPAddress, &acb->ipv4_addr,
+	    MIN(sizeof(pinit_fw->IPAddr.IPAddress),
+	    sizeof(acb->ipv4_addr)));
+	memcpy(&pinit_fw->SubnetMask.IPAddress, &acb->ipv4_subnet,
+	    MIN(sizeof(pinit_fw->SubnetMask.IPAddress),
+	    sizeof(acb->ipv4_subnet)));
+	memcpy(&pinit_fw->Gateway.IPAddress, &acb->ipv4_gw_addr,
+	    MIN(sizeof(pinit_fw->Gateway.IPAddress),
+	    sizeof(acb->ipv4_gw_addr)));
+	memcpy(&pinit_fw->DNSConfig.IPAddr.IPAddress,
+	    &acb->pri_dns_srvr_ip,
+	    MIN(sizeof(pinit_fw->DNSConfig.IPAddr.IPAddress),
+	    sizeof(acb->pri_dns_srvr_ip)));
+	memcpy(&pinit_fw->Alias, &acb->iscsi_alias,
+	    MIN(sizeof(pinit_fw->Alias), sizeof(acb->iscsi_alias)));
+	memcpy(&pinit_fw->iSCSIName, &acb->iscsi_name,
+	    MIN(sizeof(pinit_fw->iSCSIName),
+	    sizeof(acb->iscsi_name)));
+
+	pinit_fw->DeviceInfo.DeviceType = le16_to_cpu(EXT_DEF_ISCSI_LOCAL);
+	pinit_fw->DeviceInfo.ExeThrottle =
+	    le16_to_cpu(acb->exec_throttle);
+	pinit_fw->DeviceInfo.iSCSIOptions =
+	    le16_to_cpu(acb->iscsi_opts);
+	pinit_fw->DeviceInfo.TCPOptions = le16_to_cpu(acb->ipv4_tcp_opts);
+	pinit_fw->DeviceInfo.IPOptions = le16_to_cpu(acb->ipv4_ip_opts);
+	pinit_fw->DeviceInfo.MaxPDUSize = le16_to_cpu(acb->iscsi_max_pdu_size);
+	pinit_fw->DeviceInfo.FirstBurstSize =
+	    le16_to_cpu(acb->iscsi_fburst_len);
+	pinit_fw->DeviceInfo.LogoutMinTime =
+	    le16_to_cpu(acb->iscsi_def_time2wait);
+	pinit_fw->DeviceInfo.LogoutMaxTime =
+	    le16_to_cpu(acb->iscsi_def_time2retain);
+	pinit_fw->DeviceInfo.LogoutMaxTime =
+	    le16_to_cpu(acb->iscsi_def_time2retain);
+	pinit_fw->DeviceInfo.MaxOutstandingR2T =
+	    le16_to_cpu(acb->iscsi_max_outstnd_r2t);
+	pinit_fw->DeviceInfo.KeepAliveTimeout =
+	    le16_to_cpu(acb->conn_ka_timeout);
+	pinit_fw->DeviceInfo.PortNumber = le16_to_cpu(acb->ipv4_port);
+	pinit_fw->DeviceInfo.MaxBurstSize =
+	    le16_to_cpu(acb->iscsi_max_burst_len);
+
+	/*
+	 * Copy the local data to the user's buffer
+	 */
+	ioctl->Status = EXT_STATUS_OK;
+	if ((status = copy_to_user(Q64BIT_TO_PTR(ioctl->ResponseAdr,
+						 ioctl->AddrMode), pinit_fw,
+				   sizeof(EXT_INIT_FW_ISCSI))) != 0) {
+		DEBUG2(printk("qisioctl%lx: %s: unable to copy data to user's "
+		    "memory area\n", ha->host_no, __func__));
+		ioctl->Status = EXT_STATUS_COPY_ERR;
+	}
+
+exit_get_init_fw:
+	LEAVE_IOCTL(__func__, ha->host_no);
+	return(status);
+}
+
+static int ql4_get_acb(struct hba_ioctl *ql4im_ha, 
+			EXT_IOCTL_ISCSI *ioctl)
+{
+	int		status = 0;
+	uint32_t	mbox_cmd[MBOX_REG_COUNT];
+	uint32_t	mbox_sts[MBOX_REG_COUNT];
+	EXT_ACB		*pacb;
+	struct scsi_qla_host *ha;
+
+	ha = ql4im_ha->ha;
+
+	ENTER_IOCTL(__func__, ha->host_no);
+	if (!ioctl->ResponseAdr || !ioctl->ResponseLen ||
+		(ioctl->ResponseLen < sizeof(EXT_ACB))) {
+		DEBUG2(printk("qisioctl%lx: %s: invalid parameter\n",
+		    ha->host_no, __func__));
+
+		ioctl->Status = EXT_STATUS_INVALID_PARAM;
+		goto exit_get_acb;
+	}
+
+	pacb = (EXT_ACB *)ql4im_ha->dma_v;
+	memset(pacb, 0, sizeof(EXT_ACB));
+
+	memset(&mbox_cmd, 0, sizeof(mbox_cmd));
+	memset(&mbox_sts, 0, sizeof(mbox_sts));
+
+	mbox_cmd[0] = MBOX_CMD_GET_ACB;
+	mbox_cmd[1] = ioctl->Instance;
+	mbox_cmd[2] = LSDW(ql4im_ha->dma_p);
+	mbox_cmd[3] = MSDW(ql4im_ha->dma_p);
+	mbox_cmd[4] = ioctl->ResponseLen;
+
+	if (ha->ql4mbx(ha, MBOX_REG_COUNT, 5, &mbox_cmd[0], &mbox_sts[0]) != QLA_SUCCESS) {
+		DEBUG2(printk("qisioctl%lx: %s: command failed \n",
+			ha->host_no, __func__));
+
+		ioctl->Status = EXT_STATUS_ERR;
+		ioctl->DetailStatus = mbox_sts[0];
+		goto exit_get_acb;
+	}
+
+	/*
+	 * Copy the local data to the user's buffer
+	 */
+	ioctl->Status = EXT_STATUS_OK;
+	if ((status = copy_to_user(Q64BIT_TO_PTR(ioctl->ResponseAdr,
+						 ioctl->AddrMode), pacb,
+				   sizeof(EXT_ACB))) != 0) {
+		DEBUG2(printk("qisioctl%lx: %s: unable to copy data to user's "
+		    "memory area\n", ha->host_no, __func__));
+		ioctl->Status = EXT_STATUS_COPY_ERR;
+	}
+
+exit_get_acb:
+	LEAVE_IOCTL(__func__, ha->host_no);
+	return(status);
+}
+
+static int ql4_get_cache(struct hba_ioctl *ql4im_ha, 
+			EXT_IOCTL_ISCSI *ioctl, uint32_t cache_cmd)
+{
+	int			status = 0;
+	uint32_t		mbox_cmd[MBOX_REG_COUNT];
+	uint32_t		mbox_sts[MBOX_REG_COUNT];
+	EXT_NEIGHBOR_CACHE	cache;
+	EXT_NEIGHBOR_CACHE	*pcache, *pu_cache;
+	struct scsi_qla_host	*ha;
+
+	ha = ql4im_ha->ha;
+
+	ENTER_IOCTL(__func__, ha->host_no);
+	if (!ioctl->ResponseAdr || !ioctl->ResponseLen ||
+		(ioctl->ResponseLen > QL_DMA_BUF_SIZE)) {
+		DEBUG2(printk("qisioctl%lx: %s: invalid parameter\n",
+		    ha->host_no, __func__));
+
+		ioctl->Status = EXT_STATUS_INVALID_PARAM;
+		goto exit_get_cache;
+	}
+
+	memset(&cache, 0, sizeof(EXT_NEIGHBOR_CACHE));
+
+	/*
+	 * Copy the IOCTL EXT_DEVICE_ENTRY_ISCSI buffer from the user's
+	 * data space
+	 */
+	if ((status = copy_from_user((uint8_t *)&cache,
+				     Q64BIT_TO_PTR(ioctl->RequestAdr,
+						   ioctl->AddrMode),
+				     ioctl->RequestLen)) != 0) {
+		DEBUG2(printk("qisioctl%lx: %s: unable to copy data from user's "
+		    "memory area\n", ha->host_no, __func__));
+
+		ioctl->Status = EXT_STATUS_COPY_ERR;
+		goto exit_get_cache;
+	}
+
+	/*
+	 * Transfer data from IOCTL's EXT_DEVICE_ENTRY_ISCSI buffer to
+	 */
+	memset(&mbox_cmd, 0, sizeof(mbox_cmd));
+	memset(&mbox_sts, 0, sizeof(mbox_sts));
+
+	mbox_cmd[0] = cache_cmd;
+		
+	mbox_cmd[1] = ioctl->Instance;
+	mbox_cmd[2] = LSDW(ql4im_ha->dma_p);
+	mbox_cmd[3] = MSDW(ql4im_ha->dma_p);
+	mbox_cmd[4] = ioctl->Reserved1;
+	mbox_cmd[5] = cache.CacheBufferSize;
+
+	pcache = ql4im_ha->dma_v;
+	memset(pcache, 0, cache.CacheBufferSize);
+
+	if (ha->ql4mbx(ha, MBOX_REG_COUNT, 7, &mbox_cmd[0], &mbox_sts[0]) != QLA_SUCCESS) {
+		DEBUG2(printk("qisioctl%lx: %s: command failed \n",
+			ha->host_no, __func__));
+
+		ioctl->Status = EXT_STATUS_ERR;
+		ioctl->DetailStatus = mbox_sts[0];
+		goto exit_get_cache;
+	}
+
+	ioctl->VendorSpecificStatus[0] = mbox_sts[0];
+	ioctl->VendorSpecificStatus[1] = mbox_sts[1];
+	ioctl->VendorSpecificStatus[2] = mbox_sts[2];
+	ioctl->VendorSpecificStatus[3] = mbox_sts[3];
+	ioctl->VendorSpecificStatus[4] = mbox_sts[4];
+	ioctl->VendorSpecificStatus[5] = mbox_sts[5];
+	ioctl->VendorSpecificStatus[6] = mbox_sts[6];
+
+	/*
+	 * Copy the local data to the user's buffer
+	 */
+	pu_cache = Q64BIT_TO_PTR(ioctl->ResponseAdr, ioctl->AddrMode);
+	/*
+	 * Copy local DMA buffer to user's response data area
+	 */
+	if ((status = copy_to_user(pu_cache,
+                                   &cache,
+				   sizeof(EXT_NEIGHBOR_CACHE))) != 0) {
+		DEBUG2(printk("qisioctl(%d): %s: FlashData to user failed\n",
+			(int)ha->host_no, __func__));
+		ioctl->Status = EXT_STATUS_COPY_ERR;
+		goto exit_get_cache;
+	}
+
+	ioctl->Status = EXT_STATUS_OK;
+	if ((status = copy_to_user(&pu_cache->Buffer[0], pcache,
+				   cache.CacheBufferSize)) != 0) {
+		DEBUG2(printk("qisioctl%lx: %s: unable to copy data to user's "
+		    "memory area\n", ha->host_no, __func__));
+		ioctl->Status = EXT_STATUS_COPY_ERR;
+		goto exit_get_cache;
+	}
+
+exit_get_cache:
+	LEAVE_IOCTL(__func__, ha->host_no);
+	return(status);
+}
+
+static int ql4_get_isns_server(struct hba_ioctl *ql4im_ha, 
+			EXT_IOCTL_ISCSI *ioctl)
+{
+	int			status = 0;
+	EXT_ISNS_SERVER		isns;
+	struct scsi_qla_host	*ha;
+
+	ha = ql4im_ha->ha;
+
+	ENTER_IOCTL(__func__, ha->host_no);
+
+	if (!ioctl->ResponseAdr || !ioctl->ResponseLen ||
+		(ioctl->ResponseLen < sizeof(EXT_ISNS_SERVER))) {
+		DEBUG2(printk("qisioctl%lx: %s: invalid parameter\n",
+		    ha->host_no, __func__));
+
+		ioctl->Status = EXT_STATUS_INVALID_PARAM;
+		goto exit_get_isns;
+	}
+
+	memset(&isns, 0, sizeof(EXT_ISNS_SERVER));
+	isns.iSNSNotSupported = 1;
+
+	/*
+	 * Copy the local data to the user's buffer
+	 */
+	ioctl->Status = EXT_STATUS_OK;
+	if ((status = copy_to_user(Q64BIT_TO_PTR(ioctl->ResponseAdr,
+						 ioctl->AddrMode), &isns,
+				   sizeof(EXT_ISNS_SERVER))) != 0) {
+		DEBUG2(printk("qisioctl%lx: %s: unable to copy data to user's "
+		    "memory area\n", ha->host_no, __func__));
+		ioctl->Status = EXT_STATUS_COPY_ERR;
+	}
+
+exit_get_isns:
+	LEAVE_IOCTL(__func__, ha->host_no);
+	return(status);
+}
+
+static int ql4_get_stat_iscsi_block(struct hba_ioctl *ql4im_ha, 
+			EXT_IOCTL_ISCSI *ioctl)
+{
+	int		status = 0;
+	uint32_t	mbox_cmd[MBOX_REG_COUNT];
+	uint32_t	mbox_sts[MBOX_REG_COUNT];
+	EXT_HBA_PORT_STAT_ISCSI_BLOCK *pstat;
+	struct scsi_qla_host *ha;
+
+	ha = ql4im_ha->ha;
+
+	ENTER_IOCTL(__func__, ha->host_no);
+	if (!ioctl->ResponseAdr || !ioctl->ResponseLen ||
+		(ioctl->ResponseLen < sizeof(EXT_HBA_PORT_STAT_ISCSI_BLOCK))) {
+		DEBUG2(printk("qisioctl%lx: %s: invalid parameter\n",
+		    ha->host_no, __func__));
+
+		ioctl->Status = EXT_STATUS_INVALID_PARAM;
+		goto exit_get_stat_iscsi_block;
+	}
+
+	pstat = (EXT_HBA_PORT_STAT_ISCSI_BLOCK *)ql4im_ha->dma_v;
+	memset(pstat, 0, sizeof(EXT_HBA_PORT_STAT_ISCSI_BLOCK));
+
+	memset(&mbox_cmd, 0, sizeof(mbox_cmd));
+	memset(&mbox_sts, 0, sizeof(mbox_sts));
+
+	mbox_cmd[0] = MBOX_CMD_GET_MANAGEMENT_DATA;
+	mbox_cmd[1] = ioctl->Instance;
+	mbox_cmd[2] = LSDW(ql4im_ha->dma_p);
+	mbox_cmd[3] = MSDW(ql4im_ha->dma_p);
+
+	if (ha->ql4mbx(ha, MBOX_REG_COUNT, 5, &mbox_cmd[0], &mbox_sts[0]) != QLA_SUCCESS) {
+		DEBUG2(printk("qisioctl%lx: %s: command failed \n",
+			ha->host_no, __func__));
+
+		ioctl->Status = EXT_STATUS_ERR;
+		ioctl->DetailStatus = mbox_sts[0];
+		goto exit_get_stat_iscsi_block;
+	}
+
+	/*
+	 * Copy the local data to the user's buffer
+	 */
+	ioctl->Status = EXT_STATUS_OK;
+	if ((status = copy_to_user(Q64BIT_TO_PTR(ioctl->ResponseAdr,
+						 ioctl->AddrMode), pstat,
+			   sizeof(EXT_HBA_PORT_STAT_ISCSI_BLOCK))) != 0) {
+		DEBUG2(printk("qisioctl%lx: %s: unable to copy data to user's "
+		    "memory area\n", ha->host_no, __func__));
+		ioctl->Status = EXT_STATUS_COPY_ERR;
+	}
+
+exit_get_stat_iscsi_block:
+	LEAVE_IOCTL(__func__, ha->host_no);
+	return(status);
+}
+
+static int ql4_ext_get_data(struct hba_ioctl *ql4im_ha, EXT_IOCTL_ISCSI *ioctl)
+{
+	struct scsi_qla_host *ha;
+	int status;
+
+	ha = ql4im_ha->ha;
+	ENTER_IOCTL(__func__, ha->host_no);
+
+	switch (ioctl->SubCode) {
+	case EXT_SC_GET_STATISTICS_GEN:
+		status = ql4_get_statistics_gen(ql4im_ha, ioctl);
+		break;
+	case EXT_SC_GET_STATISTICS_ISCSI:
+		status = ql4_get_statistics_iscsi(ql4im_ha, ioctl);
+		break;
+	case EXT_SC_GET_DEVICE_ENTRY_ISCSI:
+	case EXT_SC_GET_DEVICE_ENTRY_DEFAULTS_ISCSI:
+		status = ql4_get_device_entry_iscsi(ql4im_ha, ioctl);
+		break;
+	case EXT_SC_GET_INIT_FW_ISCSI:
+	case EXT_SC_GET_INIT_FW_DEFAULTS_ISCSI:
+		status = ql4_get_init_fw_iscsi(ql4im_ha, ioctl);
+		break;
+	case EXT_SC_GET_ACB:
+		status = ql4_get_acb(ql4im_ha, ioctl);
+		break;
+	case EXT_SC_GET_NEIGHBOR_CACHE:
+		status = ql4_get_cache(ql4im_ha, ioctl,
+				MBOX_CMD_GET_IPV6_NEIGHBOR_CACHE);
+		break;
+	case EXT_SC_GET_DESTINATION_CACHE:
+		status = ql4_get_cache(ql4im_ha, ioctl,
+				MBOX_CMD_GET_IPV6_DEST_CACHE);
+		break;
+	case EXT_SC_GET_DEFAULT_ROUTER_LIST:
+		status = ql4_get_cache(ql4im_ha, ioctl,
+				MBOX_CMD_GET_IPV6_DEF_ROUTER_LIST);
+		break;
+	case EXT_SC_GET_LOCAL_PREFIX_LIST:
+		status = ql4_get_cache(ql4im_ha, ioctl,
+				MBOX_CMD_GET_IPV6_LCL_PREFIX_LIST);
+		break;
+	case EXT_SC_GET_ISNS_SERVER:
+		status = ql4_get_isns_server(ql4im_ha, ioctl);
+		break;
+	case EXT_SC_GET_STATISTICS_ISCSI_BLOCK:
+		status = ql4_get_stat_iscsi_block(ql4im_ha, ioctl);
+		break;
+
+	default:
+		DEBUG2(printk("qisioctl%lx: %s: unsupported external get "
+		    "data sub-command code (%X)\n",
+		    ha->host_no, __func__, ioctl->SubCode));
+
+		ioctl->Status = EXT_STATUS_UNSUPPORTED_SUBCODE;
+		break;
+	}
+
+	LEAVE_IOCTL(__func__, ha->host_no);
+	return(0);
+}
+
+static int ql4_rst_statistics_gen(struct hba_ioctl *ql4im_ha,
+				EXT_IOCTL_ISCSI *ioctl)
+{
+	struct scsi_qla_host *ha;
+
+	ha = ql4im_ha->ha;
+
+	ENTER_IOCTL(__func__, ha->host_no);
+	/*
+	 * Reset the general statistics fields
+	 */
+	ha->adapter_error_count = 0;
+	ha->device_error_count = 0;
+	ha->total_io_count = 0;
+	ha->total_mbytes_xferred = 0;
+	ha->isr_count = 0; 
+	ha->link_failure_count = 0;
+	ha->invalid_crc_count = 0;
+
+	ioctl->Status = EXT_STATUS_OK;
+
+	LEAVE_IOCTL(__func__, ha->host_no);
+	return(QLA_SUCCESS);
+}
+
+static int ql4_rst_statistics_iscsi(struct hba_ioctl *ql4im_ha,
+				EXT_IOCTL_ISCSI *ioctl)
+{
+	uint32_t mbox_cmd[MBOX_REG_COUNT];
+	uint32_t mbox_sts[MBOX_REG_COUNT];
+	struct scsi_qla_host *ha;
+
+	ha = ql4im_ha->ha;
+
+	ENTER_IOCTL(__func__, ha->host_no);
+
+	/*
+	 * Make the mailbox call
+	 */
+	memset(&mbox_cmd, 0, sizeof(mbox_cmd));
+	memset(&mbox_sts, 0, sizeof(mbox_sts));
+	mbox_cmd[0] = MBOX_CMD_GET_MANAGEMENT_DATA;
+	mbox_cmd[1] = ioctl->Instance;
+	mbox_cmd[2] = 0;
+	mbox_cmd[3] = 0;
+
+	ioctl->Status = EXT_STATUS_OK;
+	if (ha->ql4mbx(ha, MBOX_REG_COUNT, 1, &mbox_cmd[0], &mbox_sts[0]) != QLA_SUCCESS) {
+		DEBUG2(printk("qisioctl%lx: %s: get mngmt data for index [%d] failed! "
+		    "w/ mailbox ststus 0x%x\n",
+		    ha->host_no, __func__, ioctl->Instance, mbox_sts[0]));
+
+		ioctl->Status = EXT_STATUS_MAILBOX;
+		ioctl->DetailStatus = mbox_sts[0];
+	}
+
+	LEAVE_IOCTL(__func__, ha->host_no);
+	return(QLA_SUCCESS);
+}
+
+static int ql4_set_device_entry_iscsi(struct hba_ioctl *ql4im_ha,
+				    EXT_IOCTL_ISCSI *ioctl)
+{
+	int		status = 0;
+	struct dev_db_entry *pfw_ddb_entry;
+	EXT_DEVICE_ENTRY_ISCSI *pdev_entry;
+	uint32_t mbox_cmd[MBOX_REG_COUNT];
+	uint32_t mbox_sts[MBOX_REG_COUNT];
+	struct scsi_qla_host *ha;
+
+	ha = ql4im_ha->ha;
+
+	ENTER_IOCTL(__func__, ha->host_no);
+
+	if ((ioctl->RequestLen < sizeof(EXT_DEVICE_ENTRY_ISCSI)) || 
+		!ioctl->RequestAdr){
+		DEBUG2(printk("qisioctl%lx: %s: memory area too small\n",
+		    ha->host_no, __func__));
+
+		ioctl->Status = EXT_STATUS_BUFFER_TOO_SMALL;
+		goto exit_set_dev_entry;
+	}
+
+	pdev_entry = (EXT_DEVICE_ENTRY_ISCSI *)ql4im_ha->tmp_buf;
+	memset(pdev_entry, 0, sizeof(EXT_DEVICE_ENTRY_ISCSI));
+
+	/*
+	 * Copy the IOCTL EXT_DEVICE_ENTRY_ISCSI buffer from the user's
+	 * data space
+	 */
+	if ((status = copy_from_user((uint8_t *)pdev_entry,
+				     Q64BIT_TO_PTR(ioctl->RequestAdr,
+						   ioctl->AddrMode),
+				     ioctl->RequestLen)) != 0) {
+		DEBUG2(printk("qisioctl%lx: %s: unable to copy data from user's "
+		    "memory area\n", ha->host_no, __func__));
+
+		ioctl->Status = EXT_STATUS_COPY_ERR;
+		goto exit_set_dev_entry;
+	}
+
+	/*
+	 * Transfer data from IOCTL's EXT_DEVICE_ENTRY_ISCSI buffer to
+	 * Fw's DEV_DB_ENTRY buffer
+	 */
+	pfw_ddb_entry = (struct dev_db_entry *)ql4im_ha->dma_v;
+	memset(pfw_ddb_entry, 0, sizeof(struct dev_db_entry));
+
+	pfw_ddb_entry->options		= 
+		cpu_to_le16(pdev_entry->Control << 8 | pdev_entry->Options);
+	pfw_ddb_entry->tsid		= cpu_to_le16(pdev_entry->TargetSessID);
+	pfw_ddb_entry->exec_count 	= cpu_to_le16(pdev_entry->ExeCount);
+	pfw_ddb_entry->ddb_link		= cpu_to_le16(pdev_entry->DDBLink);
+	memcpy(pfw_ddb_entry->isid, pdev_entry->InitiatorSessID,
+	    sizeof(pdev_entry->InitiatorSessID));
+
+	pfw_ddb_entry->exec_throttle =
+	    cpu_to_le16(pdev_entry->DeviceInfo.ExeThrottle);
+	pfw_ddb_entry->iscsi_max_snd_data_seg_len =
+	    cpu_to_le16(pdev_entry->DeviceInfo.InitMarkerlessInt);
+	pfw_ddb_entry->iscsi_options =
+	    cpu_to_le16(pdev_entry->DeviceInfo.iSCSIOptions);
+	pfw_ddb_entry->tcp_options =
+	    cpu_to_le16(pdev_entry->DeviceInfo.TCPOptions);
+	pfw_ddb_entry->ip_options =
+	    cpu_to_le16(pdev_entry->DeviceInfo.IPOptions);
+	pfw_ddb_entry->iscsi_max_rcv_data_seg_len =
+	    cpu_to_le16(pdev_entry->DeviceInfo.MaxPDUSize);
+	pfw_ddb_entry->iscsi_first_burst_len =
+	    cpu_to_le16(pdev_entry->DeviceInfo.FirstBurstSize);
+	pfw_ddb_entry->iscsi_def_time2wait =
+	    cpu_to_le16(pdev_entry->DeviceInfo.LogoutMinTime);
+	pfw_ddb_entry->iscsi_def_time2retain =
+	    cpu_to_le16(pdev_entry->DeviceInfo.LogoutMaxTime);
+	pfw_ddb_entry->iscsi_max_outsnd_r2t =
+	    cpu_to_le16(pdev_entry->DeviceInfo.MaxOutstandingR2T);
+	pfw_ddb_entry->ka_timeout =
+	    cpu_to_le16(pdev_entry->DeviceInfo.KeepAliveTimeout);
+	pfw_ddb_entry->port =
+	    cpu_to_le16(pdev_entry->DeviceInfo.PortNumber);
+	pfw_ddb_entry->iscsi_max_burst_len =
+	    cpu_to_le16(pdev_entry->DeviceInfo.MaxBurstSize);
+	pfw_ddb_entry->def_timeout =
+	    cpu_to_le16(pdev_entry->DeviceInfo.TaskMgmtTimeout);
+	memcpy(pfw_ddb_entry->tgt_addr, pdev_entry->DeviceInfo.TargetAddr,
+	    sizeof(pdev_entry->DeviceInfo.TargetAddr));
+
+	memcpy(pfw_ddb_entry->ip_addr, pdev_entry->EntryInfo.IPAddr.IPAddress,
+	    sizeof(pdev_entry->EntryInfo.IPAddr.IPAddress));
+	memcpy(pfw_ddb_entry->iscsi_name, pdev_entry->EntryInfo.iSCSIName,
+	    sizeof(pdev_entry->EntryInfo.iSCSIName));
+	memcpy(pfw_ddb_entry->iscsi_alias, pdev_entry->EntryInfo.Alias,
+	    sizeof(pdev_entry->EntryInfo.Alias));
+
+	/*
+	 * Make the IOCTL call
+	 */
+	memset(&mbox_cmd, 0, sizeof(mbox_cmd));
+	memset(&mbox_sts, 0, sizeof(mbox_sts));
+	mbox_cmd[0] = MBOX_CMD_SET_DATABASE_ENTRY;
+	mbox_cmd[1] = (uint32_t) ioctl->Instance;
+	mbox_cmd[2] = LSDW(ql4im_ha->dma_p);
+	mbox_cmd[3] = MSDW(ql4im_ha->dma_p);
+
+	ioctl->Status = EXT_STATUS_OK;
+	if (ha->ql4mbx(ha, MBOX_REG_COUNT, 1, &mbox_cmd[0], &mbox_sts[0]) != QLA_SUCCESS) {
+		DEBUG2(printk("qisioctl%lx: %s: SET DDB Entry failed\n",
+		    ha->host_no, __func__));
+
+		ioctl->Status = EXT_STATUS_ERR;
+	}
+
+exit_set_dev_entry:
+
+	LEAVE_IOCTL(__func__, ha->host_no);
+
+	return(status);
+}
+
+static int
+ql4_set_init_fw_iscsi(struct hba_ioctl *ql4im_ha,
+				EXT_IOCTL_ISCSI *ioctl)
+{
+	int		status = 0;
+	EXT_INIT_FW_ISCSI *pinit_fw;
+	struct init_fw_ctrl_blk *pinit_fw_cb;
+	uint32_t	mbox_cmd[MBOX_REG_COUNT];
+	uint32_t	mbox_sts[MBOX_REG_COUNT];
+	struct scsi_qla_host *ha;
+
+	ha = ql4im_ha->ha;
+
+	ENTER_IOCTL(__func__, ha->host_no);
+
+	if ((ioctl->RequestLen < sizeof(EXT_INIT_FW_ISCSI)) || 
+		!ioctl->RequestAdr){
+		DEBUG2(printk("qisioctl%lx: %s: memory area too small\n",
+			ha->host_no, __func__));
+
+		ioctl->Status = EXT_STATUS_BUFFER_TOO_SMALL;
+		goto exit_set_init_fw;
+	}
+
+	pinit_fw = (EXT_INIT_FW_ISCSI *)ql4im_ha->tmp_buf;
+	memset(pinit_fw, 0, sizeof(EXT_INIT_FW_ISCSI));
+
+	/*
+	 * Copy the data from the user's buffer
+	 */
+	if ((status = copy_from_user((uint8_t *)pinit_fw,
+				     Q64BIT_TO_PTR(ioctl->RequestAdr,
+						   ioctl->AddrMode),
+				     sizeof(EXT_INIT_FW_ISCSI))) != 0) {
+		DEBUG2(printk("qisioctl%lx: %s: unable to copy data to user's "
+		    "memory area\n", ha->host_no, __func__));
+
+		ioctl->Status = EXT_STATUS_COPY_ERR;
+		goto exit_set_init_fw;
+	}
+
+	/*
+	 * First get Initialize Firmware Control Block, so as not to
+	 * destroy unaffected data
+	 */
+	memset(&mbox_cmd, 0, sizeof(mbox_cmd));
+	memset(&mbox_sts, 0, sizeof(mbox_sts));
+	mbox_cmd[0] = MBOX_CMD_GET_INIT_FW_CTRL_BLOCK;
+	mbox_cmd[2] = LSDW(ql4im_ha->dma_p);
+	mbox_cmd[3] = MSDW(ql4im_ha->dma_p);
+	mbox_cmd[4] = sizeof(struct init_fw_ctrl_blk);
+
+	if (ha->ql4mbx(ha, MBOX_REG_COUNT, 1, &mbox_cmd[0], &mbox_sts[0]) != QLA_SUCCESS) {
+		DEBUG2(printk("qisioctl%lx: %s: command failed \n",
+		    ha->host_no, __func__));
+
+		ioctl->Status = EXT_STATUS_ERR;
+		ioctl->DetailStatus = mbox_sts[0];
+		goto exit_set_init_fw;
+	}
+
+	/*
+	 * Transfer Data from Local buffer to DMA buffer
+	 */
+	pinit_fw_cb = (struct init_fw_ctrl_blk *)ql4im_ha->dma_v;
+	memset(pinit_fw_cb, 0, sizeof(struct init_fw_ctrl_blk));
+
+	pinit_fw_cb->pri.version	     = pinit_fw->Version;
+	pinit_fw_cb->pri.fw_options	     = cpu_to_le16(pinit_fw->FWOptions);
+	pinit_fw_cb->pri.add_fw_options    = cpu_to_le16(pinit_fw->AddFWOptions);
+	memcpy(pinit_fw_cb->pri.ipv4_addr, pinit_fw->IPAddr.IPAddress,
+	    MIN(sizeof(pinit_fw_cb->pri.ipv4_addr),
+	    sizeof(pinit_fw->IPAddr.IPAddress)));
+	memcpy(pinit_fw_cb->pri.ipv4_subnet, pinit_fw->SubnetMask.IPAddress,
+	    MIN(sizeof(pinit_fw_cb->pri.ipv4_subnet),
+	    sizeof(pinit_fw->SubnetMask.IPAddress)));
+	memcpy(pinit_fw_cb->pri.ipv4_gw_addr, pinit_fw->Gateway.IPAddress,
+	    MIN(sizeof(pinit_fw_cb->pri.ipv4_gw_addr),
+	    sizeof(pinit_fw->Gateway.IPAddress)));
+	memcpy(pinit_fw_cb->pri.pri_dns_srvr_ip, pinit_fw->DNSConfig.IPAddr.IPAddress,
+	    MIN(sizeof(pinit_fw_cb->pri.pri_dns_srvr_ip),
+	    sizeof(pinit_fw->DNSConfig.IPAddr.IPAddress)));
+	memcpy(pinit_fw_cb->pri.iscsi_alias, pinit_fw->Alias,
+	    MIN(sizeof(pinit_fw_cb->pri.iscsi_alias), sizeof(pinit_fw->Alias)));
+	memcpy(pinit_fw_cb->pri.iscsi_name, pinit_fw->iSCSIName,
+	    MIN(sizeof(pinit_fw_cb->pri.iscsi_name),
+	    sizeof(pinit_fw->iSCSIName)));
+
+	pinit_fw_cb->pri.exec_throttle =
+	    cpu_to_le16(pinit_fw->DeviceInfo.ExeThrottle);
+	pinit_fw_cb->pri.iscsi_opts =
+	    cpu_to_le16(pinit_fw->DeviceInfo.iSCSIOptions);
+	pinit_fw_cb->pri.ipv4_tcp_opts = cpu_to_le16(pinit_fw->DeviceInfo.TCPOptions);
+	pinit_fw_cb->pri.ipv4_ip_opts = cpu_to_le16(pinit_fw->DeviceInfo.IPOptions);
+	pinit_fw_cb->pri.iscsi_max_pdu_size = cpu_to_le16(pinit_fw->DeviceInfo.MaxPDUSize);
+	pinit_fw_cb->pri.iscsi_fburst_len =
+	    cpu_to_le16(pinit_fw->DeviceInfo.FirstBurstSize);
+	pinit_fw_cb->pri.iscsi_def_time2wait =
+	    cpu_to_le16(pinit_fw->DeviceInfo.LogoutMinTime);
+	pinit_fw_cb->pri.iscsi_def_time2retain =
+	    cpu_to_le16(pinit_fw->DeviceInfo.LogoutMaxTime);
+	pinit_fw_cb->pri.iscsi_max_outstnd_r2t =
+	    cpu_to_le16(pinit_fw->DeviceInfo.MaxOutstandingR2T);
+	pinit_fw_cb->pri.conn_ka_timeout =
+	    cpu_to_le16(pinit_fw->DeviceInfo.KeepAliveTimeout);
+	pinit_fw_cb->pri.ipv4_port = cpu_to_le16(pinit_fw->DeviceInfo.PortNumber);
+	pinit_fw_cb->pri.iscsi_max_burst_len =
+	    cpu_to_le16(pinit_fw->DeviceInfo.MaxBurstSize);
+
+	memset(&mbox_cmd, 0, sizeof(mbox_cmd));
+	memset(&mbox_sts, 0, sizeof(mbox_sts));
+	mbox_cmd[0] = MBOX_CMD_INITIALIZE_FIRMWARE;
+	mbox_cmd[2] = LSDW(ql4im_ha->dma_p);
+	mbox_cmd[3] = MSDW(ql4im_ha->dma_p);
+	mbox_cmd[4] = sizeof(struct init_fw_ctrl_blk);
+
+	ioctl->Status = EXT_STATUS_OK;
+	if (ha->ql4mbx(ha, MBOX_REG_COUNT, 1, &mbox_cmd[0], &mbox_sts[0]) != QLA_SUCCESS) {
+		DEBUG2(printk("qisioctl%lx: %s: command failed \n",
+		    ha->host_no, __func__));
+
+		ioctl->Status = EXT_STATUS_ERR;
+		ioctl->DetailStatus = mbox_sts[0];
+	}
+
+exit_set_init_fw:
+	LEAVE_IOCTL(__func__, ha->host_no);
+	return(status);
+}
+
+static int
+ql4_set_acb(struct hba_ioctl *ql4im_ha, EXT_IOCTL_ISCSI *ioctl)
+{
+	int		status = 0;
+	uint32_t	mbox_cmd[MBOX_REG_COUNT];
+	uint32_t	mbox_sts[MBOX_REG_COUNT];
+	void *pacb;
+	struct scsi_qla_host *ha;
+
+	ha = ql4im_ha->ha;
+
+	ENTER_IOCTL(__func__, ha->host_no);
+
+	if ((ioctl->RequestLen < EXT_DEF_ACB_SIZE) || 
+		!ioctl->RequestAdr){
+		DEBUG2(printk("qisioctl%lx: %s: memory area too small\n",
+			ha->host_no, __func__));
+
+		ioctl->Status = EXT_STATUS_BUFFER_TOO_SMALL;
+		goto exit_set_acb;
+	}
+
+	pacb = (void *)ql4im_ha->dma_v;
+	memset(pacb, 0, EXT_DEF_ACB_SIZE);
+
+	/*
+	 * Copy the data from the user's buffer
+	 */
+	if ((status = copy_from_user((uint8_t *)pacb,
+				     Q64BIT_TO_PTR(ioctl->RequestAdr,
+						   ioctl->AddrMode),
+				     EXT_DEF_ACB_SIZE)) != 0) {
+		DEBUG2(printk("qisioctl%lx: %s: unable to copy data to user's "
+		    "memory area\n", ha->host_no, __func__));
+
+		ioctl->Status = EXT_STATUS_COPY_ERR;
+		goto exit_set_acb;
+	}
+
+	/*
+	 * First get Initialize Firmware Control Block, so as not to
+	 * destroy unaffected data
+	 */
+	memset(&mbox_cmd, 0, sizeof(mbox_cmd));
+	memset(&mbox_sts, 0, sizeof(mbox_sts));
+	mbox_cmd[0] = MBOX_CMD_SET_ACB;
+	mbox_cmd[1] = ioctl->Instance;
+	mbox_cmd[2] = LSDW(ql4im_ha->dma_p);
+	mbox_cmd[3] = MSDW(ql4im_ha->dma_p);
+	mbox_cmd[4] = ioctl->RequestLen;
+
+	ioctl->Status = EXT_STATUS_OK;
+	if (ha->ql4mbx(ha, MBOX_REG_COUNT, MBOX_REG_COUNT, &mbox_cmd[0], &mbox_sts[0]) != QLA_SUCCESS) {
+		DEBUG2(printk("qisioctl%lx: %s: command failed \n",
+		    ha->host_no, __func__));
+
+		ioctl->Status = EXT_STATUS_ERR;
+		ioctl->DetailStatus = mbox_sts[0];
+		goto exit_set_acb;
+	}
+	ioctl->ResponseLen = mbox_sts[4];
+
+exit_set_acb:
+	LEAVE_IOCTL(__func__, ha->host_no);
+	return(status);
+}
+
+static int ql4_ext_set_data(struct hba_ioctl *ql4im_ha, EXT_IOCTL_ISCSI *ioctl)
+{
+	int status = 0;
+
+	switch (ioctl->SubCode) {
+	case EXT_SC_RST_STATISTICS_GEN:
+		status = ql4_rst_statistics_gen(ql4im_ha, ioctl);
+		break;
+	case EXT_SC_RST_STATISTICS_ISCSI:
+		status = ql4_rst_statistics_iscsi(ql4im_ha, ioctl);
+		break;
+	case EXT_SC_SET_DEVICE_ENTRY_ISCSI:
+		status = ql4_set_device_entry_iscsi(ql4im_ha, ioctl);
+		break;
+	case EXT_SC_SET_INIT_FW_ISCSI:
+		status = ql4_set_init_fw_iscsi(ql4im_ha, ioctl);
+		break;
+	case EXT_SC_SET_ACB:
+		status = ql4_set_acb(ql4im_ha, ioctl);
+		break;
+	case EXT_SC_SET_ISNS_SERVER:
+	default:
+		DEBUG2(printk("qisioctl%lx: %s: unsupported set data sub-command "
+		    "code (%X)\n",
+		    ql4im_ha->ha->host_no, __func__, ioctl->SubCode));
+
+		ioctl->Status = EXT_STATUS_UNSUPPORTED_SUBCODE;
+		break;
+	}
+	return(status);
+}
+
+/* End of External ioctls */
+
+static void
+qla4xxx_scsi_pass_done(struct scsi_cmnd *cmd)
+{
+	struct scsi_qla_host	*ha;
+	struct hba_ioctl *ql4im_ha;
+
+
+	ha = (struct scsi_qla_host *)cmd->device->host->hostdata;
+
+	ENTER_IOCTL(__func__, ha->host_no);
+
+	ql4im_ha = ql4im_get_adapter_handle(ha->instance);
+
+	if (ql4im_ha) 
+		ql4im_ha->pt_in_progress = 0;
+
+	LEAVE_IOCTL(__func__, ha->host_no);
+
+	return;
+}
+
+static int ql4_scsi_passthru(struct hba_ioctl *ql4im_ha, EXT_IOCTL_ISCSI *ioctl)
+{
+	int			status = 0;
+	struct ddb_entry	*ddb_entry;
+	EXT_SCSI_PASSTHRU_ISCSI *pscsi_pass;
+	struct scsi_cmnd	*pscsi_cmd;
+	struct srb		*srb;
+	struct scsi_qla_host	*ha;
+	int			ql_cmd_to = 6000;
+
+	ha = ql4im_ha->ha;
+
+	ENTER_IOCTL(__func__, ha->host_no);
+
+	if (!test_bit(AF_ONLINE, &ha->flags)) {
+		DEBUG2(printk("qisioctl%lx: %s: command not pocessed, "
+			"adapter link down.\n",
+			ha->host_no, __func__));
+		ioctl->Status = EXT_STATUS_HBA_NOT_READY;
+		goto exit_scsi_pass;
+	}
+
+	pscsi_pass = (EXT_SCSI_PASSTHRU_ISCSI *)ql4im_ha->tmp_buf;
+	memset(pscsi_pass, 0, sizeof(EXT_SCSI_PASSTHRU_ISCSI));
+
+	if ((status = copy_from_user((uint8_t *)pscsi_pass,
+				     Q64BIT_TO_PTR(ioctl->RequestAdr,
+						   ioctl->AddrMode),
+				     sizeof(EXT_SCSI_PASSTHRU_ISCSI))) != 0) {
+		DEBUG2(printk("qisioctl%lx: %s: unable to copy passthru struct "
+			"from user's memory area.\n",
+			ha->host_no, __func__));
+
+		ioctl->Status = EXT_STATUS_COPY_ERR;
+		goto exit_scsi_pass;
+	}
+
+	if (pscsi_pass->Addr.Target >= MAX_DDB_ENTRIES) {
+		ioctl->Status = EXT_STATUS_ERR;
+		goto exit_scsi_pass;
+	}
+
+	if (!test_bit(AF_OS_INDEX_VALID, &ha->flags))
+		ddb_entry = ha->fw_ddb_index_map[pscsi_pass->Addr.Target];
+	else
+		ddb_entry = get_ddb_from_osid(ha, pscsi_pass->Addr.Target);
+
+	if ((ddb_entry == NULL) ||
+		(ddb_entry == (struct ddb_entry *)INVALID_ENTRY)){
+		DEBUG2(printk("qisioctl%lx: %s: invalid device (t%d) specified.\n",
+		    ha->host_no, __func__, pscsi_pass->Addr.Target));
+
+		ioctl->Status = EXT_STATUS_DEV_NOT_FOUND;
+		goto exit_scsi_pass;
+	}
+	if (ddb_entry->fw_ddb_device_state != DDB_DS_SESSION_ACTIVE) {
+		DEBUG2(printk("qisioctl%lx: %s: device (t%d) not in active state\n",
+			ha->host_no, __func__, pscsi_pass->Addr.Target));
+
+		ioctl->Status = EXT_STATUS_DEVICE_NOT_READY;
+		goto exit_scsi_pass;
+	}
+	
+	srb = &ql4im_ha->pt_srb;
+	memset(srb, 0, sizeof(struct srb));
+
+	pscsi_cmd = &ql4im_ha->pt_scsi_cmd;
+	memset(pscsi_cmd, 0, sizeof(struct scsi_cmnd));
+
+	pscsi_cmd->device = &ql4im_ha->pt_scsi_device;
+	memset(pscsi_cmd->device, 0, sizeof(struct scsi_device));
+
+	pscsi_cmd->request = &ql4im_ha->pt_request;
+	memset(pscsi_cmd->request, 0, sizeof(struct request));
+
+	memset(ql4im_ha->dma_v, 0, ql4im_ha->dma_len);
+
+	pscsi_cmd->device->channel = pscsi_pass->Addr.Bus;
+	pscsi_cmd->device->id = pscsi_pass->Addr.Target;
+	pscsi_cmd->device->lun = pscsi_pass->Addr.Lun;
+	pscsi_cmd->device->host = ha->host;
+
+#ifndef QLA_SLES11
+	pscsi_cmd->request_buffer = ql4im_ha->dma_v;
+	pscsi_cmd->use_sg = 0;
+	pscsi_cmd->timeout_per_command = 60 * HZ;
+#endif
+	pscsi_cmd->scsi_done = qla4xxx_scsi_pass_done;
+
+	pscsi_cmd->SCp.ptr = (char *) srb;
+	srb->cmd = pscsi_cmd;
+	srb->fw_ddb_index = ddb_entry->fw_ddb_index;
+	srb->flags |= SRB_SCSI_PASSTHRU;
+	srb->ha = ha;
+	srb->dma_handle = ql4im_ha->dma_p;
+	srb->ddb = ddb_entry;
+
+	srb->dma_len = 0;
+
+	if (pscsi_pass->CdbLength == 6 || pscsi_pass->CdbLength == 10 ||
+	    pscsi_pass->CdbLength == 12 || pscsi_pass->CdbLength == 16) {
+		pscsi_cmd->cmd_len = pscsi_pass->CdbLength;
+	} else {
+		DEBUG2(printk("qisioctl%lx: %s: Unsupported CDB length 0x%x \n",
+			ha->host_no, __func__, pscsi_cmd->cmd_len));
+
+		ioctl->Status = EXT_STATUS_INVALID_PARAM;
+		goto exit_scsi_pass;
+	}
+
+	if (pscsi_pass->Direction == EXT_DEF_SCSI_PASSTHRU_DATA_IN) {
+		pscsi_cmd->sc_data_direction = DMA_FROM_DEVICE;
+		srb->dma_len = ioctl->ResponseLen -
+                    sizeof(EXT_SCSI_PASSTHRU_ISCSI);
+
+	} else if (pscsi_pass->Direction ==  EXT_DEF_SCSI_PASSTHRU_DATA_OUT) {
+		pscsi_cmd->sc_data_direction = DMA_TO_DEVICE;
+		srb->dma_len = ioctl->RequestLen -
+                    sizeof(EXT_SCSI_PASSTHRU_ISCSI);
+
+		/* Sending user data from ioctl->ResponseAddr to SCSI
+		 * command buffer
+		 */
+		if ((status = copy_from_user((uint8_t *)
+				ql4im_ha->dma_v,
+				Q64BIT_TO_PTR(ioctl->RequestAdr,
+					ioctl->AddrMode) +
+				sizeof(EXT_SCSI_PASSTHRU_ISCSI),
+					srb->dma_len)) != 0) {
+			DEBUG2(printk("qisioctl%lx: %s: unable to copy write buffer "
+				"from user's memory area.\n", 
+				ha->host_no, __func__));
+
+			ioctl->Status = EXT_STATUS_COPY_ERR;
+			goto exit_scsi_pass;
+		}
+	} else {
+		pscsi_cmd->sc_data_direction = DMA_NONE;
+#ifndef QLA_SLES11
+		pscsi_cmd->request_buffer  = 0;
+#endif
+	}
+#ifndef QLA_SLES11
+	pscsi_cmd->request_bufflen = srb->dma_len;
+#else
+	pscsi_cmd->sdb.length = srb->dma_len;
+	pscsi_cmd->cmnd = ql4im_ha->cmnd;
+	pscsi_cmd->sense_buffer = ql4im_ha->sense_buffer;
+#endif
+
+	memcpy(pscsi_cmd->cmnd, pscsi_pass->Cdb, pscsi_cmd->cmd_len);
+
+	DEBUG4(printk("qisioctl%lx:%d:%d:%d: %s:\n",
+		ha->host_no, pscsi_cmd->device->channel,
+		pscsi_cmd->device->id, pscsi_cmd->device->lun, __func__));
+
+	ql4im_ha->pt_in_progress = 1;
+
+	srb->cc_stat = IOCTL_INVALID_STATUS;
+
+	if (!test_bit(AF_ONLINE, &ha->flags)) {
+		DEBUG2(printk("qisioctl%lx: %s: command not pocessed, "
+			"adapter link down.\n",
+			ha->host_no, __func__));
+		ioctl->Status = EXT_STATUS_HBA_NOT_READY;
+		ql4im_ha->pt_in_progress = 0;
+		goto exit_scsi_pass;
+	}
+	if (ha->ql4cmd(ha, srb) != QLA_SUCCESS) {
+		DEBUG2(printk("qisioctl%lx: %s: error sending cmd to isp\n",
+		    ha->host_no, __func__));
+		ql4im_ha->pt_in_progress = 0;
+		ioctl->Status = EXT_STATUS_DEV_NOT_FOUND;
+		goto exit_scsi_pass;
+	}
+
+	while (ql4im_ha->pt_in_progress && ql_cmd_to) {
+		msleep(10);
+		ql_cmd_to--;
+	}
+	if (ql4im_ha->pt_in_progress) {
+		DEBUG2(printk("qisioctl%lx: %s: ERROR = command timeout.\n",
+			ha->host_no, __func__));
+
+		ioctl->Status = EXT_STATUS_ERR;
+
+		ql4im_ha->pt_in_progress = 0;
+		goto exit_scsi_pass;
+	}
+
+	DEBUG4(printk("\tresult 0x%x cc_stat 0x%x\n", pscsi_cmd->result, 
+		srb->cc_stat));
+	ioctl->DetailStatus = pscsi_cmd->result & 0xFFFF;
+	pscsi_pass->Reserved[0] = (uint8_t) (pscsi_cmd->result & 0xFFFF);
+	pscsi_pass->Reserved[1] = (uint8_t) srb->cc_stat;
+
+	if (((pscsi_cmd->result >> 16) == DID_OK) &&
+		((pscsi_cmd->result & 0xFFFF) == SCSI_CHECK_CONDITION)) {
+		pscsi_pass->Reserved[2] = 
+			(uint8_t)(sizeof(pscsi_cmd->sense_buffer));
+
+		memcpy(pscsi_pass->SenseData, pscsi_cmd->sense_buffer,
+		    MIN(sizeof(pscsi_cmd->sense_buffer),
+		    sizeof(pscsi_pass->SenseData)));
+
+		DEBUG10(printk("qisioctl%lx: %s: sense data dump:\n",
+		    ha->host_no, __func__));
+	}
+	pscsi_pass->Reserved[3] = (uint8_t) host_byte(pscsi_cmd->result);
+	pscsi_pass->Reserved[6] = (uint8_t) 0;
+	pscsi_pass->Reserved[7] = (uint8_t) 0;
+
+	if ((pscsi_cmd->result >> 16) == DID_OK) {
+
+		ioctl->Status = EXT_STATUS_OK;
+
+	} else if (srb->cc_stat == SCS_DATA_UNDERRUN) {
+		DEBUG2(printk("qisioctl%lx: %s: Data underrun.  Resid = 0x%x\n",
+			ha->host_no, __func__, QL_GET_SCSI_RESID(pscsi_cmd)));
+
+		ioctl->Status = EXT_STATUS_DATA_UNDERRUN;
+		pscsi_pass->Reserved[4] = MSB(QL_GET_SCSI_RESID(pscsi_cmd));
+		pscsi_pass->Reserved[5] = LSB(QL_GET_SCSI_RESID(pscsi_cmd));
+
+	} else if (srb->cc_stat == SCS_DATA_OVERRUN) {
+		DEBUG2(printk("qisioctl%lx: %s: Data overrun.  Resid = 0x%x\n",
+			ha->host_no, __func__, QL_GET_SCSI_RESID(pscsi_cmd)));
+
+		ioctl->Status = EXT_STATUS_DATA_OVERRUN;
+		pscsi_pass->Reserved[4] = MSB(QL_GET_SCSI_RESID(pscsi_cmd));
+		pscsi_pass->Reserved[5] = LSB(QL_GET_SCSI_RESID(pscsi_cmd));
+
+	} else {
+		DEBUG2(printk("qisioctl%lx: %s: Command completed in ERROR. "
+		    "cs=%04x, ss=%-4x\n", ha->host_no, __func__,
+		    srb->cc_stat, (pscsi_cmd->result & 0xFFFF)));
+
+		if ((pscsi_cmd->result & 0xFFFF) != SCSI_GOOD) {
+			ioctl->Status = EXT_STATUS_SCSI_STATUS;
+		} else {
+			ioctl->Status = EXT_STATUS_ERR;
+		}
+	}
+
+	if (copy_to_user(Q64BIT_TO_PTR(ioctl->ResponseAdr, ioctl->AddrMode),
+			 pscsi_pass, sizeof(EXT_SCSI_PASSTHRU_ISCSI)) != 0) {
+		DEBUG2(printk("qisioctl%lx: %s: unable to copy passthru struct "
+			"to user's memory area.\n", ha->host_no, __func__));
+
+		ioctl->Status = EXT_STATUS_COPY_ERR;
+		goto exit_scsi_pass;
+	}
+
+	if (pscsi_pass->Direction == EXT_DEF_SCSI_PASSTHRU_DATA_IN) {
+		void	*xfer_ptr = Q64BIT_TO_PTR(ioctl->ResponseAdr,
+						  ioctl->AddrMode) +
+				    sizeof(EXT_SCSI_PASSTHRU_ISCSI);
+		uint32_t xfer_len = ioctl->ResponseLen -
+				    sizeof(EXT_SCSI_PASSTHRU_ISCSI);
+
+		if (srb->cc_stat == SCS_DATA_UNDERRUN && QL_GET_SCSI_RESID(pscsi_cmd)) {
+			xfer_len -= QL_GET_SCSI_RESID(pscsi_cmd);
+		}
+
+		if ((status = copy_to_user(xfer_ptr, ql4im_ha->dma_v,
+		    xfer_len)) != 0) {
+			DEBUG2(printk("qisioctl%lx: %s: unable to copy READ data "
+			    "to user's memory area.\n",
+			     ha->host_no, __func__));
+
+			ioctl->Status = EXT_STATUS_COPY_ERR;
+		}
+	}
+
+exit_scsi_pass:
+	LEAVE_IOCTL(__func__, ha->host_no);
+	return(status);
+}
+
+
+static int ql4_get_hbacnt(struct hba_ioctl *ql4im_ha, 
+				EXT_IOCTL_ISCSI *ioctl)
+{
+	int		status = 0;
+	EXT_HBA_COUNT	hba_cnt;
+	struct scsi_qla_host	*ha;
+
+	ha = ql4im_ha->ha;
+	ENTER_IOCTL(__func__, ha->host_no);
+
+	memset(&hba_cnt, 0, sizeof(EXT_HBA_COUNT));
+	hba_cnt.HbaCnt = ql4im_get_hba_count();
+	if ((status = copy_to_user(Q64BIT_TO_PTR(ioctl->ResponseAdr,
+						 ioctl->AddrMode),
+		&hba_cnt, sizeof(hba_cnt))) != 0) {
+		DEBUG2(printk("qisioctl%d: %s: failed to copy data\n",
+		    (int)ql4im_ha->ha->host_no, __func__));
+
+		ioctl->Status = EXT_STATUS_COPY_ERR;
+		goto exit_get_hbacnt;
+	}
+
+	DEBUG2(printk("qisioctl%d: %s: hbacnt is %d\n",
+	    (int)ql4im_ha->ha->host_no, __func__, hba_cnt.HbaCnt));
+	ioctl->Status = EXT_STATUS_OK;
+
+exit_get_hbacnt:
+	LEAVE_IOCTL(__func__, ha->host_no);
+
+	return(status);
+}
+
+static int ql4_get_hostno(struct hba_ioctl *ql4im_ha, 
+				EXT_IOCTL_ISCSI *ioctl)
+{
+	struct scsi_qla_host	*ha;
+
+	ha = ql4im_ha->ha;
+	ENTER_IOCTL(__func__, ha->host_no);
+
+	ioctl->HbaSelect = ql4im_ha->ha->host_no;
+	ioctl->Status = EXT_STATUS_OK;
+
+	DEBUG4(printk("qisioctl%lxd: %s: nce is %d\n",
+	    ql4im_ha->ha->host_no, __func__, ioctl->HbaSelect));
+
+	LEAVE_IOCTL(__func__, ha->host_no);
+
+	return(0);
+}
+
+static int ql4_driver_specific(struct hba_ioctl *ql4im_ha, 
+					EXT_IOCTL_ISCSI *ioctl)
+{
+	int			status = 0;
+	EXT_LN_DRIVER_DATA	data;
+	struct scsi_qla_host	*ha;
+
+	ha = ql4im_ha->ha;
+	ENTER_IOCTL(__func__, ha->host_no);
+
+	if (ioctl->ResponseLen < sizeof(EXT_LN_DRIVER_DATA)) {
+		ioctl->Status = EXT_STATUS_BUFFER_TOO_SMALL;
+		DEBUG2(printk("qisioctl: %s: ERROR ResponseLen too small.\n", __func__));
+		goto exit_driver_specific;
+	}
+
+	data.DrvVer.Major = drvr_major;
+	data.DrvVer.Minor = drvr_minor;
+	data.DrvVer.Patch = drvr_patch;
+	data.DrvVer.Beta  = drvr_beta;
+
+	if (is_qla4010(ql4im_ha->ha))
+		data.AdapterModel = EXT_DEF_QLA4010_DRIVER;
+	else if (is_qla4022(ql4im_ha->ha))
+		data.AdapterModel = EXT_DEF_QLA4022_DRIVER;
+
+	status = copy_to_user(Q64BIT_TO_PTR(ioctl->ResponseAdr, ioctl->AddrMode),
+			      &data, sizeof(EXT_LN_DRIVER_DATA));
+
+	if (status) {
+		ioctl->Status = EXT_STATUS_COPY_ERR;
+		DEBUG2(printk("qisioctl: %s: ERROR copy resp buf\n", __func__));
+	}
+
+exit_driver_specific:
+
+	LEAVE_IOCTL(__func__, ha->host_no);
+
+	return(status);
+}
+
+static int ql4_disable_acb(struct hba_ioctl *ql4im_ha, EXT_IOCTL_ISCSI *ioctl)
+{
+	int			status = 0;
+	uint32_t		mbox_cmd[MBOX_REG_COUNT];
+	uint32_t		mbox_sts[MBOX_REG_COUNT];
+	struct scsi_qla_host	*ha;
+	int			count = 600;
+
+	ha = ql4im_ha->ha;
+	ENTER_IOCTL(__func__, ha->host_no);
+
+	memset(&mbox_cmd, 0, sizeof(mbox_cmd));
+	memset(&mbox_sts, 0, sizeof(mbox_sts));
+	mbox_cmd[0] = MBOX_CMD_DISABLE_ACB;
+	mbox_cmd[1] = ioctl->Instance;
+	mbox_cmd[2] = ioctl->Reserved1;
+
+	ioctl->Status = EXT_STATUS_OK;
+
+	if (ha->ql4mbx(ha, MBOX_REG_COUNT, MBOX_REG_COUNT, &mbox_cmd[0],
+					&mbox_sts[0]) != QLA_SUCCESS) {
+		if (mbox_sts[0] == MBOX_STS_INTERMEDIATE_COMPLETION) {
+
+			while (count--) {
+				memset(&mbox_cmd, 0, sizeof(mbox_cmd));
+				memset(&mbox_sts, 0, sizeof(mbox_sts));
+
+				mbox_cmd[0] = MBOX_CMD_GET_IP_ADDR_STATE;
+				mbox_cmd[1] = ioctl->Instance;
+				if (ha->ql4mbx(ha, MBOX_REG_COUNT, 8,
+					&mbox_cmd[0], &mbox_sts[0]) != QLA_SUCCESS) {
+					DEBUG2(printk("qisioctl%lx: %s: command failed \n",
+						ha->host_no, __func__));
+					ioctl->Status = EXT_STATUS_ERR;
+					ioctl->DetailStatus = mbox_sts[0];
+					break;
+				} else {
+					if (!(mbox_sts[1] & 0xF0000000))
+						break;
+					else
+						msleep(100);
+				}	
+			}
+			if (!count)
+				ioctl->Status = EXT_STATUS_ERR;
+		} else {
+			ioctl->Status = EXT_STATUS_ERR;
+			ioctl->DetailStatus = mbox_sts[0];
+		}
+	}
+
+	LEAVE_IOCTL(__func__, ha->host_no);
+	return(status);
+}
+
+static int ql4_send_router_sol(struct hba_ioctl *ql4im_ha, EXT_IOCTL_ISCSI *ioctl)
+{
+	int			status = 0;
+	uint32_t		mbox_cmd[MBOX_REG_COUNT];
+	uint32_t		mbox_sts[MBOX_REG_COUNT];
+	struct scsi_qla_host	*ha;
+	uint32_t		ip_addr;
+	EXT_SEND_ROUTER_SOL	sr_sol;
+
+	ha = ql4im_ha->ha;
+	ENTER_IOCTL(__func__, ha->host_no);
+
+	if (ioctl->ResponseLen < sizeof(EXT_LN_DRIVER_DATA)) {
+		ioctl->Status = EXT_STATUS_BUFFER_TOO_SMALL;
+		DEBUG2(printk("qisioctl: %s: ERROR ResponseLen too small.\n", __func__));
+		goto exit_sndr_sol;
+	}
+
+	if ((status = copy_from_user((uint8_t *)&sr_sol,
+                                     Q64BIT_TO_PTR(ioctl->RequestAdr,
+						   ioctl->AddrMode),
+				     sizeof(sr_sol))) != 0) {
+		DEBUG2(printk("qisioctl%lx: %s: unable to copy data from "
+		    "user's memory area\n", ha->host_no, __func__));
+
+		ioctl->Status = EXT_STATUS_COPY_ERR;
+		goto exit_sndr_sol;
+	}
+
+	memset(&mbox_cmd, 0, sizeof(mbox_cmd));
+	memset(&mbox_sts, 0, sizeof(mbox_sts));
+	mbox_cmd[0] = MBOX_CMD_SEND_IPV6_ROUTER_SOL;
+	mbox_cmd[1] = ioctl->Instance;
+	mbox_cmd[2] = sr_sol.Flags;
+	memcpy(&ip_addr, &sr_sol.Addr.IPAddress, sizeof(ip_addr));
+	mbox_cmd[3] = cpu_to_le32(ip_addr);
+	memcpy(&ip_addr, &sr_sol.Addr.IPAddress[4], sizeof(ip_addr));
+	mbox_cmd[4] = cpu_to_le32(ip_addr);
+	memcpy(&ip_addr, &sr_sol.Addr.IPAddress[8], sizeof(ip_addr));
+	mbox_cmd[5] = cpu_to_le32(ip_addr);
+	memcpy(&ip_addr, &sr_sol.Addr.IPAddress[12], sizeof(ip_addr));
+	mbox_cmd[6] = cpu_to_le32(ip_addr);
+
+	ioctl->Status = EXT_STATUS_OK;
+	if (ha->ql4mbx(ha, MBOX_REG_COUNT, 1, &mbox_cmd[0], &mbox_sts[0]) != QLA_SUCCESS) {
+		DEBUG2(printk("qisioctl%lx: %s: command failed \n",
+		    ha->host_no, __func__));
+
+		ioctl->Status = EXT_STATUS_ERR;
+		ioctl->DetailStatus = mbox_sts[0];
+	}
+	ioctl->VendorSpecificStatus[0] = mbox_sts[0];
+	ioctl->VendorSpecificStatus[1] = mbox_sts[1];
+
+exit_sndr_sol:
+	LEAVE_IOCTL(__func__, ha->host_no);
+	return(status);
+}
+
+/* Start of Internal ioctls */
+
+static int ql4_ping(struct hba_ioctl *ql4im_ha, EXT_IOCTL_ISCSI *ioctl)
+{
+	int			status = 0;
+	INT_PING		ping;
+	uint32_t		ip_addr;
+	uint32_t		mbox_cmd[MBOX_REG_COUNT];
+	uint32_t		mbox_sts[MBOX_REG_COUNT];
+	struct scsi_qla_host	*ha;
+
+	ha = ql4im_ha->ha;
+	ENTER_IOCTL(__func__, ha->host_no);
+
+	if ((status = copy_from_user((uint8_t *)&ping,
+                                     Q64BIT_TO_PTR(ioctl->RequestAdr,
+						   ioctl->AddrMode),
+				     sizeof(ping))) != 0) {
+		DEBUG2(printk("qisioctl%lx: %s: unable to copy data from "
+		    "user's memory area\n", ha->host_no, __func__));
+
+		ioctl->Status = EXT_STATUS_COPY_ERR;
+		goto exit_ping;
+	}
+
+	/*
+	 * Issue Mailbox Command
+	 */
+	memset(&mbox_cmd, 0, sizeof(mbox_cmd));
+	memset(&mbox_sts, 0, sizeof(mbox_sts));
+	mbox_cmd[0] = MBOX_CMD_PING;
+	mbox_cmd[1] = ping.Reserved;
+	memcpy(&ip_addr, &ping.IPAddr.IPAddress, sizeof(ip_addr));
+	mbox_cmd[2] = cpu_to_le32(ip_addr);
+	memcpy(&ip_addr, &ping.IPAddr.IPAddress[4], sizeof(ip_addr));
+	mbox_cmd[3] = cpu_to_le32(ip_addr);
+	memcpy(&ip_addr, &ping.IPAddr.IPAddress[8], sizeof(ip_addr));
+	mbox_cmd[4] = cpu_to_le32(ip_addr);
+	memcpy(&ip_addr, &ping.IPAddr.IPAddress[12], sizeof(ip_addr));
+	mbox_cmd[5] = cpu_to_le32(ip_addr);
+	mbox_cmd[6] = cpu_to_le32(ping.PacketSize);
+
+	ioctl->Status = EXT_STATUS_OK;
+
+	if (ha->ql4mbx(ha, MBOX_REG_COUNT, 1, &mbox_cmd[0], &mbox_sts[0]) != QLA_SUCCESS) {
+		DEBUG2(printk("qisioctl%lx: %s: command failed \n",
+		    ha->host_no, __func__));
+
+		ioctl->Status = EXT_STATUS_ERR;
+		ioctl->DetailStatus = mbox_sts[0];
+	}
+
+exit_ping:
+	LEAVE_IOCTL(__func__, ha->host_no);
+	return(status);
+}
+
+static int ql4_get_flash(struct hba_ioctl *ql4im_ha, EXT_IOCTL_ISCSI *ioctl)
+{
+	int			status = 0;
+	uint32_t		mbox_cmd[MBOX_REG_COUNT];
+	uint32_t		mbox_sts[MBOX_REG_COUNT];
+	uint32_t		data_len;
+	uint32_t		data_offset;
+	INT_ACCESS_FLASH	*puser_flash;
+	struct scsi_qla_host	*ha;
+
+	ha = ql4im_ha->ha;
+
+	ENTER_IOCTL(__func__, ha->host_no);
+
+	puser_flash = Q64BIT_TO_PTR(ioctl->RequestAdr, ioctl->AddrMode);
+
+	if ((status = copy_from_user((void *)&data_len,
+				 (void *)&puser_flash->DataLen,
+				 sizeof (uint32_t))) != 0) {
+		DEBUG2(printk("qisioctl(%d): %s: DataLen copy error\n",
+			(int)ha->host_no, __func__));
+
+		ioctl->Status = EXT_STATUS_COPY_ERR;
+		goto exit_get_flash;
+	}
+	if (data_len > sizeof(puser_flash->FlashData)) {
+		DEBUG2(printk("qisioctl(%d): %s: DataLen invalid 0x%x\n",
+			(int)ha->host_no, __func__, data_len));
+		ioctl->Status = EXT_STATUS_INVALID_PARAM;
+		goto exit_get_flash;
+	}
+	
+	if ((status = copy_from_user((void *)&data_offset,
+				 (void *)&puser_flash->DataOffset,
+				 sizeof (uint32_t))) != 0) {
+		DEBUG2(printk("qisioctl(%d): %s: DataOffset copy error\n",
+			(int)ha->host_no, __func__));
+
+		ioctl->Status = EXT_STATUS_COPY_ERR;
+		goto exit_get_flash;
+	}
+	DUMP_GET_FLASH(data_offset, data_len);
+
+	memset(&mbox_cmd, 0, sizeof(mbox_cmd));
+	memset(&mbox_sts, 0, sizeof(mbox_sts));
+	mbox_cmd[0] = MBOX_CMD_READ_FLASH;
+	mbox_cmd[1] = LSDW(ql4im_ha->dma_p);
+	mbox_cmd[2] = MSDW(ql4im_ha->dma_p);
+	mbox_cmd[3] = data_offset;
+	mbox_cmd[4] = data_len;
+
+	if (ha->ql4mbx(ha, MBOX_REG_COUNT, 2, &mbox_cmd[0], &mbox_sts[0]) != QLA_SUCCESS) {
+		DEBUG2(printk("qisioctl(%d): %s: READ_FLASH failed st 0x%x\n",
+			(int)ha->host_no, __func__, mbox_sts[0]));
+		ioctl->Status = EXT_STATUS_MAILBOX;
+		ioctl->DetailStatus = mbox_sts[0];
+		ioctl->VendorSpecificStatus[0] = mbox_sts[1];
+		goto exit_get_flash;
+	}
+
+	puser_flash = Q64BIT_TO_PTR(ioctl->ResponseAdr, ioctl->AddrMode);
+	/*
+	 * Copy local DMA buffer to user's response data area
+	 */
+	if ((status = copy_to_user(&puser_flash->FlashData[0],
+                                   ql4im_ha->dma_v,
+				   data_len)) != 0) {
+		DEBUG2(printk("qisioctl(%d): %s: FlashData to user failed\n",
+			(int)ha->host_no, __func__));
+
+		ioctl->Status = EXT_STATUS_COPY_ERR;
+		goto exit_get_flash;
+	}
+	if ((status = copy_to_user(&puser_flash->DataLen,
+                                   &data_len,
+				   sizeof (uint32_t))) != 0) {
+		DEBUG2(printk("qisioctl(%d): %s: DataLen to user failed\n",
+			(int)ha->host_no, __func__));
+
+		ioctl->Status = EXT_STATUS_COPY_ERR;
+		goto exit_get_flash;
+	}
+	if ((status = copy_to_user(&puser_flash->DataOffset,
+                                   &data_offset,
+				   sizeof (uint32_t))) != 0) {
+		DEBUG2(printk("qisioctl(%d): %s: DataOffset to user failed\n",
+			(int)ha->host_no, __func__));
+
+		ioctl->Status = EXT_STATUS_COPY_ERR;
+		goto exit_get_flash;
+	}
+
+	ioctl->Status = EXT_STATUS_OK;
+	ioctl->ResponseLen = data_len;
+
+exit_get_flash:
+	LEAVE_IOCTL(__func__, ha->host_no);
+	return(status);
+}
+
+static int ql4_get_host_no(struct hba_ioctl *ql4im_ha, EXT_IOCTL_ISCSI *ioctl)
+{
+	int status = 0;
+	struct scsi_qla_host	*ha;
+
+	ha = ql4im_ha->ha;
+
+	ENTER_IOCTL(__func__, ha->host_no);
+
+	if ((status = copy_to_user(Q64BIT_TO_PTR(ioctl->ResponseAdr,
+						 ioctl->AddrMode),
+                                   &(ha->host_no),
+				   sizeof(ha->host_no))) != 0) {
+		DEBUG2(printk("qisioctl%lx: %s: failed to copy data\n",
+		    ha->host_no, __func__));
+
+		ioctl->Status = EXT_STATUS_COPY_ERR;
+	} else {
+		ioctl->Status = EXT_STATUS_OK;
+	}
+
+	LEAVE_IOCTL(__func__, ha->host_no);
+
+	return(status);
+}
+
+static int ql4_get_core_dump(struct hba_ioctl *ql4im_ha, EXT_IOCTL_ISCSI *ioctl)
+{
+	int			status = 0;
+	INT_ACCESS_CORE_DUMP	cdump, *puser_cdump;
+	struct scsi_qla_host	*ha;
+	void 			*pdump;
+
+	ha = ql4im_ha->ha;
+	ENTER_IOCTL(__func__, ha->host_no);
+
+	if ((status = copy_from_user((uint8_t *)&cdump,
+                                     Q64BIT_TO_PTR(ioctl->RequestAdr,
+						   ioctl->AddrMode),
+				     sizeof(cdump))) != 0) {
+		DEBUG2(printk("qisioctl(%lx): %s: unable to copy data from "
+		    "user's memory area\n", ha->host_no, __func__));
+
+		ioctl->Status = EXT_STATUS_COPY_ERR;
+		goto exit_core_dump;
+	}
+
+        ioctl->Status = EXT_STATUS_OK;
+	
+	if ((!cdump.DataLen) || (cdump.Offset >= DUMP_IMAGE_SIZE))
+		goto exit_core_dump;
+
+	if (ql4im_ha->core == NULL) {
+		if((ql4im_ha->core = vmalloc(DUMP_IMAGE_SIZE)) == NULL){
+			ioctl->Status = EXT_STATUS_NO_MEMORY;
+			goto exit_core_dump;
+		}
+		ql4_core_dump(ha, ql4im_ha->core);
+	}
+
+		
+	puser_cdump = Q64BIT_TO_PTR(ioctl->ResponseAdr, ioctl->AddrMode);
+	pdump = (unsigned char *)ql4im_ha->core + cdump.Offset;
+
+        ioctl->ResponseLen = cdump.DataLen;
+	if ((cdump.Offset + cdump.DataLen) > DUMP_IMAGE_SIZE) {
+		cdump.LastBlockFlag = 1;
+		ioctl->ResponseLen = DUMP_IMAGE_SIZE - cdump.Offset;
+        	if (copy_to_user(puser_cdump, &cdump, sizeof(cdump)) != 0) {
+               		DEBUG2(printk("qisioctl(%d): %s: unable to copy data to user's "
+                    	"memory area\n", (int)ha->host_no, __func__));
+                	ioctl->Status = EXT_STATUS_COPY_ERR;
+        	}
+	} else 
+		cdump.LastBlockFlag = 0;
+
+        if (copy_to_user(&puser_cdump->Data[0], pdump, ioctl->ResponseLen) != 0) {
+                DEBUG2(printk("qisioctl(%d): %s: unable to copy data to user's "
+                    "memory area\n", (int)ha->host_no, __func__));
+                ioctl->Status = EXT_STATUS_COPY_ERR;
+        }
+
+	if (cdump.LastBlockFlag) {
+		vfree(ql4im_ha->core);
+		ql4im_ha->core = NULL;
+	}
+exit_core_dump:
+	LEAVE_IOCTL(__func__, ha->host_no);
+	return(status);
+}
+
+static int ql4_int_get_data(struct hba_ioctl *ql4im_ha, EXT_IOCTL_ISCSI *ioctl)
+{
+	int	status = 0;
+
+	switch (ioctl->SubCode) {
+	case INT_SC_GET_FLASH:
+		status = ql4_get_flash(ql4im_ha, ioctl);
+		break;
+	case INT_SC_GET_HOST_NO:
+		status = ql4_get_host_no(ql4im_ha, ioctl);
+		break;
+	case INT_SC_GET_CORE_DUMP:
+		status = ql4_get_core_dump(ql4im_ha, ioctl);
+		break;
+	default:
+		DEBUG2(printk("qisioctl%lx: %s: unsupported internal get data "
+		    "sub-command code (%X)\n",
+		    ql4im_ha->ha->host_no, __func__, ioctl->SubCode));
+
+		ioctl->Status = EXT_STATUS_UNSUPPORTED_SUBCODE;
+		break;
+	}
+
+	return status;
+}
+
+static int ql4_set_flash(struct hba_ioctl *ql4im_ha, EXT_IOCTL_ISCSI *ioctl)
+{
+	int			status = 0;
+	uint32_t		mbox_cmd[MBOX_REG_COUNT];
+	uint32_t		mbox_sts[MBOX_REG_COUNT];
+	uint32_t		area_type;
+	uint32_t		data_len;
+	uint32_t		data_offset;
+	uint32_t		data_options;
+	INT_ACCESS_FLASH	*puser_flash;
+	struct scsi_qla_host	*ha;
+
+	ha = ql4im_ha->ha;
+
+	ENTER_IOCTL(__func__, ha->host_no);
+
+	puser_flash = Q64BIT_TO_PTR(ioctl->RequestAdr, ioctl->AddrMode);
+
+	if ((status = copy_from_user((void *)&area_type,
+				 (void *)&puser_flash->AreaType,
+				 sizeof (uint32_t))) != 0) {
+		DEBUG2(printk("qisioctl(%d): %s: AreaType copy error\n",
+			(int)ha->host_no, __func__));
+
+		ioctl->Status = EXT_STATUS_COPY_ERR;
+		goto exit_set_flash;
+	}
+
+	if ((status = copy_from_user((void *)&data_len,
+				 (void *)&puser_flash->DataLen,
+				 sizeof (uint32_t))) != 0) {
+		DEBUG2(printk("qisioctl(%d): %s: DataLen copy error\n",
+			(int)ha->host_no, __func__));
+
+		ioctl->Status = EXT_STATUS_COPY_ERR;
+		goto exit_set_flash;
+	}
+	if (data_len > sizeof(puser_flash->FlashData)) {
+		DEBUG2(printk("qisioctl(%d): %s: DataLen invalid 0x%x\n",
+			(int)ha->host_no, __func__, data_len));
+		ioctl->Status = EXT_STATUS_INVALID_PARAM;
+		goto exit_set_flash;
+	}
+	
+	if ((status = copy_from_user((void *)&data_offset,
+				 (void *)&puser_flash->DataOffset,
+				 sizeof (uint32_t))) != 0) {
+		DEBUG2(printk("qisioctl(%d): %s: DataOffset copy error\n",
+			(int)ha->host_no, __func__));
+
+		ioctl->Status = EXT_STATUS_COPY_ERR;
+		goto exit_set_flash;
+	}
+	
+	if ((status = copy_from_user((void *)&data_options,
+				 (void *)&puser_flash->Options,
+				 sizeof (uint32_t))) != 0) {
+		DEBUG2(printk("qisioctl(%d): %s: Options copy error\n",
+			(int)ha->host_no, __func__));
+
+		ioctl->Status = EXT_STATUS_COPY_ERR;
+		goto exit_set_flash;
+	}
+	
+	if ((status = copy_from_user((void *)ql4im_ha->dma_v,
+				(void *)&puser_flash->FlashData[0],
+				data_len)) != 0) {
+		DEBUG2(printk("qisioctl(%d): %s: FlashData copy error\n",
+			(int)ha->host_no, __func__));
+
+		ioctl->Status = EXT_STATUS_COPY_ERR;
+		goto exit_set_flash;
+	}
+
+	DUMP_SET_FLASH(data_offset, data_len, data_options);
+
+	memset(&mbox_cmd, 0, sizeof(mbox_cmd));
+	memset(&mbox_sts, 0, sizeof(mbox_sts));
+	mbox_cmd[0] = MBOX_CMD_WRITE_FLASH;
+	mbox_cmd[1] = LSDW(ql4im_ha->dma_p);
+	mbox_cmd[2] = MSDW(ql4im_ha->dma_p);
+	mbox_cmd[3] = data_offset;
+	mbox_cmd[4] = data_len;
+	mbox_cmd[5] = data_options;
+
+	ioctl->Status = EXT_STATUS_OK;
+	ioctl->ResponseLen = data_len;
+
+	if (ha->ql4mbx(ha, MBOX_REG_COUNT, 2, &mbox_cmd[0], &mbox_sts[0]) != QLA_SUCCESS) {
+		DEBUG2(printk("qisioctl(%d): %s: WRITE_FLASH failed st 0x%x\n",
+			(int)ha->host_no, __func__, mbox_sts[0]));
+		ioctl->Status = EXT_STATUS_MAILBOX;
+		ioctl->DetailStatus = mbox_sts[0];
+		ioctl->VendorSpecificStatus[0] = mbox_sts[1];
+	}
+	msleep(10);
+exit_set_flash:
+	LEAVE_IOCTL(__func__, ha->host_no);
+	return(status);
+}
+
+/**
+ * ql4_int_set_data
+ *	This routine calls set data IOCTLs based on the IOCTL Sub Code.
+ *	Kernel context.
+ **/
+static int ql4_int_set_data(struct hba_ioctl *ql4im_ha, EXT_IOCTL_ISCSI *ioctl)
+{
+	int	status = 0;
+
+	switch (ioctl->SubCode) {
+	case INT_SC_SET_FLASH:
+		status = ql4_set_flash(ql4im_ha, ioctl);
+		break;
+	default:
+		DEBUG2(printk("qisioctl%lx: %s: unsupported subCode(0x%x)\n",
+			ql4im_ha->ha->host_no, __func__, ioctl->SubCode));
+
+		ioctl->Status = EXT_STATUS_UNSUPPORTED_SUBCODE;
+		break;
+	}
+
+	return status;
+}
+
+/**
+ * ql4_hba_reset
+ *	This routine resets the specified HBA.
+ **/
+static int ql4_hba_reset(struct hba_ioctl *ql4im_ha, EXT_IOCTL_ISCSI *ioctl)
+{
+	uint8_t		status = 0;
+	u_long		wait_count = 180;
+	struct scsi_qla_host *ha;
+
+	ha = ql4im_ha->ha;
+	ENTER_IOCTL(__func__, ha->host_no);
+
+	ql4im_ha->aen_read = 0;
+
+	ioctl->Status = EXT_STATUS_OK;
+
+	set_bit(DPC_RESET_HA_DESTROY_DDB_LIST, &ha->dpc_flags);
+
+	while (wait_count) {
+		ssleep(1);
+
+		if ((!test_bit(DPC_RESET_HA_DESTROY_DDB_LIST, &ha->dpc_flags))
+			&& test_bit(AF_ONLINE, &ha->flags)) {
+			msleep(30);
+			break;
+		}
+		wait_count--;
+	}
+
+	if (!wait_count)
+		ioctl->Status = EXT_STATUS_ERR;
+
+	LEAVE_IOCTL(__func__, ha->host_no);
+
+	return(status);
+}
+
+/**
+ * ql4_copy_fw_flash
+ *	This routine requests copying the FW image in FLASH from primary-to-
+ *	secondary or secondary-to-primary.
+ **/
+static int ql4_copy_fw_flash(struct hba_ioctl *ql4im_ha, EXT_IOCTL_ISCSI *ioctl)
+{
+	int status = 0;
+	INT_COPY_FW_FLASH copy_flash;
+	uint32_t mbox_cmd[MBOX_REG_COUNT];
+	uint32_t mbox_sts[MBOX_REG_COUNT];
+	struct scsi_qla_host *ha;
+
+	ha = ql4im_ha->ha;
+	ENTER_IOCTL(__func__, ha->host_no);
+
+	ioctl->Status = EXT_STATUS_OK;
+
+	if ((status = copy_from_user((uint8_t *)&copy_flash,
+                                     Q64BIT_TO_PTR(ioctl->RequestAdr,
+						   ioctl->AddrMode),
+				     sizeof (INT_COPY_FW_FLASH))) != 0) {
+		DEBUG2(printk("qisioctl%lx: %s: unable to copy data from user's "
+		    "memory area\n", ha->host_no, __func__));
+
+		ioctl->Status = EXT_STATUS_COPY_ERR;
+		goto exit_copy_flash;
+	}
+
+	memset(&mbox_cmd, 0, sizeof(mbox_cmd));
+	memset(&mbox_sts, 0, sizeof(mbox_sts));
+
+	mbox_cmd[0] = MBOX_CMD_COPY_FLASH;
+	mbox_cmd[1] = copy_flash.Options;
+
+	if (ha->ql4mbx(ha, MBOX_REG_COUNT, 2, &mbox_cmd[0], &mbox_sts[0]) != QLA_SUCCESS) {
+		DEBUG2(printk("qisioctl%lx: %s: COPY_FLASH failed w/ "
+		    "status %04X\n", ha->host_no, __func__, mbox_sts[0]));
+		ioctl->Status = EXT_STATUS_MAILBOX;
+		ioctl->DetailStatus = mbox_sts[0];
+		ioctl->VendorSpecificStatus[0] = mbox_sts[1];
+	}
+
+exit_copy_flash:
+	LEAVE_IOCTL(__func__, ha->host_no);
+
+	return(status);
+}
+
+/**
+ * ql4_restore_factory_defaults
+ *	This routine restores factory defaults of the adapter.
+**/
+static int ql4_restore_factory_defaults(struct hba_ioctl *ql4im_ha, 
+					EXT_IOCTL_ISCSI *ioctl)
+{
+	int status = 0;
+	INT_RESTORE_FACTORY_DEFAULTS defaults;
+	uint32_t mbox_cmd[MBOX_REG_COUNT];
+	uint32_t mbox_sts[MBOX_REG_COUNT];
+	struct scsi_qla_host *ha;
+
+	ha = ql4im_ha->ha;
+	ENTER_IOCTL(__func__, ha->host_no);
+	ioctl->Status = EXT_STATUS_OK;
+
+	if (ioctl->RequestLen > sizeof(INT_RESTORE_FACTORY_DEFAULTS)) {
+		DEBUG2(printk("qisioctl%lx: %s: memory area too small\n",
+		    ha->host_no, __func__));
+
+		ioctl->Status = EXT_STATUS_BUFFER_TOO_SMALL;
+		goto exit_defaults;
+	}
+
+	if ((status = copy_from_user((void *)&defaults,
+                                     Q64BIT_TO_PTR(ioctl->RequestAdr,
+						   ioctl->AddrMode),
+				     sizeof(INT_RESTORE_FACTORY_DEFAULTS))) != 0) {
+		DEBUG2(printk("qisioctl%lx: %s: unable to copy data from "
+		    "user's memory area\n", ha->host_no, __func__));
+
+		ioctl->Status = EXT_STATUS_COPY_ERR;
+		goto exit_defaults;
+	}
+
+	memset(&mbox_cmd, 0, sizeof(mbox_cmd));
+	memset(&mbox_sts, 0, sizeof(mbox_sts));
+	mbox_cmd[0] = MBOX_CMD_RESTORE_FACTORY_DEFAULTS;
+	mbox_cmd[3] = defaults.BlockMask;
+        mbox_cmd[4] = defaults.IFCBMask1;
+        mbox_cmd[5] = defaults.IFCBMask2;
+
+	if (ha->ql4mbx(ha, MBOX_REG_COUNT, 1, &mbox_cmd[0], &mbox_sts[0]) != QLA_SUCCESS) {
+		DEBUG2(printk("qisioctl%lx: %s: RESTORE_FACTORY_DEFAULTS failed w/ "
+		    "status %04X\n", ha->host_no, __func__, mbox_sts[0]));
+		ioctl->Status = EXT_STATUS_MAILBOX;
+	}
+
+exit_defaults:
+	LEAVE_IOCTL(__func__, ha->host_no);
+	return(status);
+}
+
+static int ql4_logout(struct hba_ioctl *ql4im_ha, 
+			EXT_IOCTL_ISCSI *ioctl)
+{
+	int status = 0;
+	INT_LOGOUT_ISCSI lo;
+	uint32_t mbox_cmd[MBOX_REG_COUNT];
+	uint32_t mbox_sts[MBOX_REG_COUNT];
+	struct scsi_qla_host *ha;
+	struct ddb_entry *ddb_entry = NULL;
+	int count = 30*100;
+
+	ha = ql4im_ha->ha;
+	ENTER_IOCTL(__func__, ha->host_no);
+	ioctl->Status = EXT_STATUS_OK;
+
+	if (ioctl->RequestLen > sizeof(INT_LOGOUT_ISCSI)) {
+		DEBUG2(printk("qisioctl%lx: %s: memory area too small\n",
+			ha->host_no, __func__));
+
+		ioctl->Status = EXT_STATUS_BUFFER_TOO_SMALL;
+		goto exit_logout;
+	}
+
+	if ((status = copy_from_user((void *)&lo,
+			Q64BIT_TO_PTR(ioctl->RequestAdr, ioctl->AddrMode),
+				sizeof(INT_LOGOUT_ISCSI))) != 0) {
+		DEBUG2(printk("qisioctl%lx: %s: unable to copy data from "
+			"user's memory area\n", ha->host_no, __func__));
+
+		ioctl->Status = EXT_STATUS_COPY_ERR;
+		goto exit_logout;
+	}
+	if (lo.TargetID < MAX_DDB_ENTRIES){
+		ddb_entry = ha->fw_ddb_index_map[lo.TargetID];
+		if ((ddb_entry == NULL) ||
+			(ddb_entry == (struct ddb_entry *)INVALID_ENTRY))
+			ddb_entry = NULL;
+	}
+
+	if (ddb_entry == NULL) {
+		ioctl->Status = EXT_STATUS_ERR;
+		goto exit_logout;
+	}
+
+
+	if (ddb_entry->fw_ddb_device_state != DDB_DS_SESSION_ACTIVE)
+		goto label_delete_ddb;
+
+	ddb_entry->sess->recovery_tmo = 0;
+
+	DEBUG2(printk("qisioctl(%lx): %s: TgtId=0x%04x ConId=0x%04x Opt=0x%04x NTId=0x%08x\n",
+		ha->host_no, __func__, lo.TargetID, lo.ConnectionID,
+		lo.Options, lo.NewTargetID));
+
+	memset(&mbox_cmd, 0, sizeof(mbox_cmd));
+	memset(&mbox_sts, 0, sizeof(mbox_sts));
+	mbox_cmd[0] = MBOX_CMD_CONN_CLOSE_SESS_LOGOUT;
+	mbox_cmd[1] = lo.TargetID;
+
+        mbox_cmd[3] = 0x4; /* reset and close the tcp connection */
+	if (lo.Options & INT_DEF_DELETE_DDB)
+        	mbox_cmd[3] |= 0x8;/* Free DDB */
+
+	if (ha->ql4mbx(ha, MBOX_REG_COUNT, 1, &mbox_cmd[0], &mbox_sts[0])
+		!= QLA_SUCCESS) {
+		DEBUG2(printk("qisioctl%lx: %s:"
+			" MBOX_CMD_CONN_CLOSE_SESS_LOGOUT failed w/ "
+			"cmd 0x%04x 0x%04x 0x%04x 0x%04x"
+			"status 0x%04x 0x%04x 0x%04x \n", 
+		ha->host_no, __func__, 
+		mbox_cmd[0], mbox_cmd[1], mbox_cmd[2], mbox_cmd[3],
+		mbox_sts[0], mbox_sts[1], mbox_sts[2]));
+		ioctl->Status = EXT_STATUS_MAILBOX;
+		goto exit_logout;
+	}
+        /* Wait for logout to complete */
+	while (count) {
+		if (ddb_entry->fw_ddb_device_state == DDB_DS_NO_CONNECTION_ACTIVE)
+			break;
+		msleep(10);
+		count--;
+	}
+	if (!count) {
+		ioctl->Status = EXT_STATUS_MAILBOX;
+		goto exit_logout;
+	}
+
+label_delete_ddb:
+        if (lo.Options & INT_DEF_DELETE_DDB) {
+		memset(&mbox_cmd, 0, sizeof(mbox_cmd));
+		memset(&mbox_sts, 0, sizeof(mbox_sts));
+		mbox_cmd[0] = MBOX_CMD_CLEAR_DATABASE_ENTRY;
+		mbox_cmd[1] = lo.TargetID;
+
+                if (ha->ql4mbx(ha, MBOX_REG_COUNT, 1, &mbox_cmd[0],
+			&mbox_sts[0]) != QLA_SUCCESS) {
+			DEBUG2(printk("qisioctl%lx: %s: "
+                        	"MBOX_CMD_CLEAR_DATABASE_ENTRY failed w/ "
+                        	"cmd 0x%04x 0x%04x 0x%04x 0x%04x status "
+				"0x%04x 0x%04x 0x%04x \n",
+			ha->host_no, __func__,
+			mbox_cmd[0], mbox_cmd[1], mbox_cmd[2], mbox_cmd[3],
+			mbox_sts[0], mbox_sts[1], mbox_sts[2]));
+			ioctl->Status = EXT_STATUS_MAILBOX;
+		}
+		count = 30*100;
+		while (count) {
+#ifdef __VMKLNX__
+			if (atomic_read(&ddb_entry->state) == DDB_STATE_DEAD) {
+#else
+			if (ha->fw_ddb_index_map[lo.TargetID] == NULL) {
+#endif
+				dev_info(&ha->pdev->dev, "%s: ddb[%d] ddb_entry freed\n",
+					__func__, lo.TargetID);
+				break;
+			}
+			msleep(10);
+			count--;
+		}
+		if (!count)
+			ioctl->Status = EXT_STATUS_MAILBOX;
+
+	}
+
+exit_logout:
+	LEAVE_IOCTL(__func__, ha->host_no);
+	return(status);
+}
+
+/* End of Internal ioctls */
+
+/**
+ * ql4_ioctl
+ * 	This the main entry point for all ioctl requests
+ *
+ * Input:
+ *	dev - pointer to SCSI device structure
+ *	cmd - internal or external ioctl command code
+ *	arg - pointer to the main ioctl structure
+ *
+ *	Instance field in ioctl structure - to determine which device to
+ *	perform ioctl
+ *	HbaSelect field in ioctl structure - to determine which adapter to
+ *	perform ioctl
+ *
+ * Output:
+ *	The resulting data/status is returned via the main ioctl structure.
+ *
+ *	When Status field in ioctl structure is valid for normal command errors
+ * 	this function returns 0 (QLA_SUCCESS).
+ *
+ *      All other return values indicate ioctl/system specific error which
+ *	prevented the actual ioctl command from completing.
+ *
+ * Returns:
+ *	 QLA_SUCCESS - command completed successfully, either with or without
+ *			errors in the Status field of the main ioctl structure
+ *    	-EFAULT      - arg pointer is NULL or memory access error
+ *    	-EINVAL      - command is invalid
+ *    	-ENOMEM      - memory allocation failed
+ *
+ * Context:
+ *	Kernel context.
+ **/
+int
+qla4xxx_ioctl(int cmd, void *arg)
+{
+	EXT_IOCTL_ISCSI *pioctl = NULL;
+	struct hba_ioctl *ql4im_ha = NULL;
+	struct scsi_qla_host *ha;
+	int status = 0;	/* ioctl status; errno value when function returns */
+
+	/* Catch any non-exioct ioctls */
+	if (_IOC_TYPE(cmd) != QLMULTIPATH_MAGIC) {
+		printk(KERN_WARNING "qisioctl: invalid ioctl magic number received.\n");
+		status = -EINVAL;
+		goto exit_qla4xxx_ioctl0;
+	}
+
+	/* 
+	 * Allocate ioctl structure buffer to support multiple concurrent
+	 * entries. NO static structures allowed.
+	 */
+	pioctl = kzalloc(sizeof(EXT_IOCTL_ISCSI), GFP_ATOMIC);
+	if (pioctl == NULL) {
+		printk(KERN_WARNING "qisioctl: %s: kzalloc failed\n", __func__);
+		status = -ENOMEM;
+		goto exit_qla4xxx_ioctl0;
+	}
+
+	/*
+	 * Check to see if we can access the ioctl command structure
+	 */
+	if (!ql4_access_ok(arg)) {
+		DEBUG2(printk("qisioctl: %s: access_ok error.\n", __func__));
+		status = (-EFAULT);
+		goto exit_qla4xxx_ioctl1;
+	}
+
+	/*
+	 * Copy the ioctl command structure from user space to local structure
+	 */
+	if ((status = copy_from_user((uint8_t *)pioctl, arg,
+	    sizeof(EXT_IOCTL_ISCSI)))) {
+		DEBUG2(printk("qisioctl: %s: copy_from_user error.\n",
+		    __func__));
+
+		goto exit_qla4xxx_ioctl1;
+	}
+
+	/*DEBUG10(printk("EXT_IOCTL_ISCSI structure dump: \n");)
+	DEBUG10(ql4im_dump_dwords(pioctl, sizeof(*pioctl));)
+	*/
+
+        /* check signature of this ioctl */
+	if (memcmp(pioctl->Signature, EXT_DEF_REGULAR_SIGNATURE,
+	    sizeof(EXT_DEF_REGULAR_SIGNATURE)) != 0) {
+		DEBUG2(printk("qisioctl: %s: signature did not match. "
+		    "received cmd=%x arg=%p signature=%s.\n",
+		    __func__, cmd, arg, pioctl->Signature));
+		pioctl->Status = EXT_STATUS_INVALID_PARAM;
+		goto exit_qla4xxx_ioctl;
+	}
+
+        /* check version of this ioctl */
+        if (pioctl->Version > EXT_VERSION) {
+                printk(KERN_WARNING
+                    "qisioctl: ioctl interface version not supported = %d.\n",
+                    pioctl->Version);
+
+		pioctl->Status = EXT_STATUS_UNSUPPORTED_VERSION;
+		goto exit_qla4xxx_ioctl;
+        }
+
+	/*
+	 * Get the adapter handle for the corresponding adapter instance
+	 */
+	ql4im_ha = ql4im_get_adapter_handle(pioctl->HbaSelect);
+	if (ql4im_ha == NULL) {
+		DEBUG2(printk("qisioctl: %s: NULL HBA select %d\n",
+			__func__, pioctl->HbaSelect));
+		pioctl->Status = EXT_STATUS_DEV_NOT_FOUND;
+		goto exit_qla4xxx_ioctl;
+	}
+
+	ha = ql4im_ha->ha;
+
+	if (!test_bit(AF_ONLINE, &ha->flags)) {
+		pioctl->Status = EXT_STATUS_HBA_NOT_READY;
+		goto exit_qla4xxx_ioctl;
+	}
+
+	mutex_lock(&ql4im_ha->ioctl_sem);
+	if (ql4im_ha->flag & HBA_IOCTL_BUSY) {
+		pioctl->Status = EXT_STATUS_BUSY;
+	} else {
+		ql4im_ha->flag |= HBA_IOCTL_BUSY;
+		pioctl->Status = EXT_STATUS_OK;
+	}
+	mutex_unlock(&ql4im_ha->ioctl_sem);
+
+	if (pioctl->Status == EXT_STATUS_BUSY) {
+		DEBUG2(printk("qisioctl: %s: busy\n", __func__));
+		goto exit_qla4xxx_ioctl;
+	}
+
+	/*
+	 * Issue the ioctl command
+	 */
+	switch (cmd) {
+
+	case EXT_CC_QUERY:
+		status = ql4_query(ql4im_ha, pioctl);
+		break;
+
+	case EXT_CC_REG_AEN:
+		status = ql4_reg_aen(ql4im_ha, pioctl);
+		break;
+
+	case EXT_CC_GET_AEN:
+		status = ql4_get_aen(ql4im_ha, pioctl);
+		break;
+
+	case EXT_CC_GET_DATA:
+		status = ql4_ext_get_data(ql4im_ha, pioctl);
+		break;
+
+	case EXT_CC_SET_DATA:
+		status = ql4_ext_set_data(ql4im_ha, pioctl);
+		break;
+
+	case EXT_CC_SEND_SCSI_PASSTHRU:
+		status = ql4_scsi_passthru(ql4im_ha, pioctl);
+		break;
+
+	case EXT_CC_GET_HBACNT:
+		status = ql4_get_hbacnt(ql4im_ha, pioctl);
+		break;
+
+	case EXT_CC_GET_HOST_NO:
+		status = ql4_get_hostno(ql4im_ha, pioctl);
+		break;
+
+	case EXT_CC_DRIVER_SPECIFIC:
+		status = ql4_driver_specific(ql4im_ha, pioctl);
+		break;
+
+	case EXT_CC_GET_PORT_DEVICE_NAME:
+		status = ql4_get_port_device_name(ql4im_ha, pioctl);
+		break;
+
+	case EXT_CC_DISABLE_ACB:
+		status = ql4_disable_acb(ql4im_ha, pioctl);
+		break;
+
+	case EXT_CC_SEND_ROUTER_SOL:
+		status = ql4_send_router_sol(ql4im_ha, pioctl);
+		break;
+
+	case INT_CC_RESTORE_FACTORY_DEFAULTS:
+		status = ql4_restore_factory_defaults(ql4im_ha, pioctl);
+		break;
+
+	case INT_CC_DIAG_PING:
+		status = ql4_ping(ql4im_ha, pioctl);
+		break;
+
+	case INT_CC_GET_DATA:
+		status = ql4_int_get_data(ql4im_ha, pioctl);
+		break;
+
+	case INT_CC_SET_DATA:
+		status = ql4_int_set_data(ql4im_ha, pioctl);
+		break;
+
+	case INT_CC_HBA_RESET:
+		status = ql4_hba_reset(ql4im_ha, pioctl);
+		break;
+
+	case INT_CC_COPY_FW_FLASH:
+		status = ql4_copy_fw_flash(ql4im_ha, pioctl);
+		break;
+
+	case INT_CC_LOGOUT_ISCSI:
+		status = ql4_logout(ql4im_ha, pioctl);
+		break;
+	default:
+		DEBUG2(printk("qisioctl%lx: %s: unsupported command code (%x)\n",
+		    ql4im_ha->ha->host_no, __func__, (uint32_t)cmd));
+
+		pioctl->Status = EXT_STATUS_UNSUPPORTED_SUBCODE;
+	}
+
+	if (!(ql4im_ha->flag & HBA_IOCTL_BUSY)) {
+		DEBUG2(printk("qisioctl%lx: %s: flag already clear!\n", 
+				ql4im_ha->ha->host_no, __func__));
+	}
+	mutex_lock(&ql4im_ha->ioctl_sem);
+	ql4im_ha->flag &= ~HBA_IOCTL_BUSY;
+	mutex_unlock(&ql4im_ha->ioctl_sem);
+
+exit_qla4xxx_ioctl:
+	status = copy_to_user(arg, (void *)pioctl, sizeof(EXT_IOCTL_ISCSI));
+exit_qla4xxx_ioctl1:
+	kfree(pioctl);
+exit_qla4xxx_ioctl0:
+
+	return(status);
+}
diff -r 6a4846854257 drivers/scsi/qla4xxx/ql4im_os.c
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/drivers/scsi/qla4xxx/ql4im_os.c	Mon Jan 11 11:15:25 2010 +0000
@@ -0,0 +1,418 @@
+/*
+ * QLogic iSCSI HBA Driver
+ * Copyright (c)  2003-2006 QLogic Corporation
+ *
+ * See LICENSE.qla4xxx for copyright and licensing details.
+ */
+
+/******************************************************************************
+ *             Please see release.txt for revision history.                   *
+ *                                                                            *
+ ******************************************************************************
+ * Function Table of Contents:
+ ****************************************************************************/
+
+#include <linux/version.h>
+#include <linux/vmalloc.h>
+#include <linux/spinlock.h>
+#include <linux/module.h>
+#include <linux/timer.h>
+#include <linux/klist.h>
+
+#include "ql4_def.h"
+#include "ql4im_def.h"
+
+/* Restrict compilation to 2.6.18 or greater */
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,18)
+#error "This module does not support kernel versions earlier than 2.6.18"
+#endif
+
+#define QL4_MODULE_NAME	"qla4xxx"
+	
+extern struct klist *qla4xxx_hostlist_ptr;
+static struct klist *ha_list;
+static int hba_count = 0;
+
+/*unsigned dbg_level = (QL_DBG_1 | QL_DBG_2 | QL_DBG_4 | QL_DBG_11 | QL_DBG_12);*/
+unsigned dbg_level = 0;
+
+static struct hba_ioctl *hba[EXT_DEF_MAX_HBAS];
+
+static struct class *apidev_class = NULL;
+static int apidev_major;
+
+extern char *qla4xxx_version_str;
+uint8_t drvr_major = 5;
+uint8_t drvr_minor = 0;
+uint8_t drvr_patch = 5;
+uint8_t drvr_beta = 9;
+char drvr_ver[40];
+#define DEFAULT_VER	"5.00.05b9-k"
+
+static int
+apidev_ioctl(struct inode *inode, struct file *fp, unsigned int cmd,
+    unsigned long arg)
+{
+	return (qla4xxx_ioctl((int)cmd, (void*)arg));
+}
+
+#ifdef CONFIG_COMPAT
+static long
+qla4xxx_ioctl32(struct file *file, unsigned int cmd, unsigned long arg)
+{
+	int rval = -ENOIOCTLCMD;
+
+	lock_kernel();
+	rval = qla4xxx_ioctl((int)cmd, (void*)arg);
+	unlock_kernel();
+
+	return rval;
+}
+#endif
+
+static struct file_operations apidev_fops = {
+	.owner = THIS_MODULE,
+	.ioctl = apidev_ioctl,
+#ifdef CONFIG_COMPAT
+	.compat_ioctl = qla4xxx_ioctl32,
+#endif
+};
+
+static char *getval(char *ver, uint8_t *val)
+{
+	*val = 0;
+
+        while (ver &&(*ver != '\0')&&(*ver != '.')&&(*ver != '-')&&
+                (*ver >= '0')&&(*ver <= '9')) {
+                *val = *val * 10 + *ver - '0';
+                ver++;
+        }
+        return ver;
+}
+
+struct hba_ioctl *ql4im_get_adapter_handle(uint16_t instance)
+{
+	if (instance >= EXT_DEF_MAX_HBAS) 
+		return NULL;
+	return hba[instance];
+}
+
+static int ql4_ioctl_alloc(int hba_idx, struct klist_node *node)
+{
+	struct hba_ioctl *haioctl;
+
+	haioctl = kzalloc(sizeof(struct hba_ioctl), GFP_ATOMIC);
+	if (haioctl == NULL)
+		return -ENOMEM;
+	
+	memset(haioctl, 0, sizeof(struct hba_ioctl));
+	hba[hba_idx] = haioctl;
+
+	haioctl->ha  = (struct scsi_qla_host *)node;
+	haioctl->dma_v = pci_alloc_consistent(haioctl->ha->pdev,
+					QL_DMA_BUF_SIZE,
+					&haioctl->dma_p);
+
+	if (haioctl->dma_v == NULL) {
+		printk(KERN_WARNING "qisitoctl: %s: %d: pcialloc failed\n",
+			__func__, hba_idx);
+		kfree(haioctl);
+		hba[hba_idx] = NULL;
+		return -ENOMEM;
+	}
+	mutex_init(&haioctl->ioctl_sem);
+
+	haioctl->dma_len = QL_DMA_BUF_SIZE;
+
+	return 0;
+}
+
+static void ql4_ioctl_free(void)
+{
+	int i;
+	struct hba_ioctl *haioctl;
+	
+	for (i = 0; i < EXT_DEF_MAX_HBAS; i++) {
+		if ((haioctl = hba[i]) != NULL) {
+			pci_free_consistent(haioctl->ha->pdev,
+					PAGE_SIZE,
+					haioctl->dma_v,
+					haioctl->dma_p);
+			kfree(haioctl);
+		}
+		hba[i] = NULL;
+	}
+}
+
+#ifndef __VMKLNX__
+uint32_t
+ql4im_get_hba_count(void)
+{
+	return(hba_count);
+}
+
+static void get_drvr_version(void)
+{
+	char *ver;
+
+	ver = ((char *)symbol_get(qla4xxx_version_str));
+	if (ver == NULL) { 
+		strcpy(drvr_ver, DEFAULT_VER);
+		printk(KERN_INFO "symbol_get(qla4xxx_version_str) failed\n"); 
+		return;
+	}
+
+	strcpy(drvr_ver, ver);
+	symbol_put(qla4xxx_version_str);
+
+	ver = drvr_ver;
+
+        ver = getval(ver, &drvr_major);
+
+        if (ver && *ver == '.') ver++;
+
+        ver = getval(ver, &drvr_minor);
+
+        if (ver && *ver == '.') ver++;
+
+        ver = getval(ver, &drvr_patch);
+
+	drvr_beta = 0;
+        if (ver && *ver == 'b') {
+                ver++;
+                ver = getval(ver, &drvr_beta);
+        }
+
+	printk(KERN_INFO "drvr_ver %s major %d minor %d patch %d beta %d\n", 
+		drvr_ver, drvr_major, drvr_minor, drvr_patch, drvr_beta);
+}
+
+static int ql4_ioctl_init(void)
+{
+	ENTER(__func__);
+
+	apidev_class = class_create(THIS_MODULE, QL4_MODULE_NAME);
+	if (IS_ERR(apidev_class)) {
+		DEBUG2(printk("qisioctl: %s: Unable to sysfs class\n", __func__));
+		apidev_class = NULL;
+		return 1;
+	}
+	DEBUG4(printk("qisioctl: %s: apidev_class=%p.\n", __func__, apidev_class));
+
+	apidev_major = register_chrdev(0, QL4_MODULE_NAME, &apidev_fops);
+	if (apidev_major < 0) {
+		DEBUG2(printk("qisioctl: %s: Unable to register CHAR device (%d)\n",
+		    __func__, apidev_major));
+
+		class_destroy(apidev_class);
+		apidev_class = NULL;
+		return apidev_major;
+	}
+	DEBUG4(printk("qisioctl: %s: apidev_major=%d.\n", __func__, apidev_major));
+
+#ifdef QLA_SLES11
+	device_create_drvdata(apidev_class, NULL, MKDEV(apidev_major, 0), NULL,
+            		QL4_MODULE_NAME);
+#else
+	class_device_create(apidev_class, NULL, MKDEV(apidev_major, 0), NULL,
+            		QL4_MODULE_NAME);
+#endif
+	LEAVE(__func__);
+	return 0;
+}
+
+static void ql4_ioctl_exit(void)
+{
+	ENTER(__func__);
+
+	if (!apidev_class)
+		return;
+
+#ifdef QLA_SLES11
+	device_destroy(apidev_class, MKDEV(apidev_major, 0));
+#else
+	class_device_destroy(apidev_class, MKDEV(apidev_major, 0));
+#endif
+
+	unregister_chrdev(apidev_major, QL4_MODULE_NAME);
+
+	class_destroy(apidev_class);
+
+	apidev_class = NULL;
+
+	LEAVE(__func__);
+}
+
+static int ql4im_init(void)
+{
+	struct klist_node *node;
+	struct klist **ql4_hl;
+	struct klist_iter iter;
+
+	ENTER( __func__ );
+
+	memset(&hba, 0,  sizeof (*hba));
+	ql4_hl = (struct klist **)symbol_get(qla4xxx_hostlist_ptr);
+
+	if (ql4_hl == NULL) {
+		printk("qistioctl: symbol_get failed qla4xxx_hostlist_ptr\n");
+		return -ENODEV;
+	}
+
+	ha_list = *ql4_hl;
+
+	if (ha_list == NULL) {
+		printk("qistioctl: ha_list == NULL\n");
+		return -ENODEV;
+	}
+
+	DEBUG1(printk("qisioctl: %s: ha_list %p.\n", __func__, ha_list));
+
+	get_drvr_version();
+
+	if (ql4_ioctl_init())
+		return -ENODEV;
+
+	klist_iter_init(ha_list, &iter);
+	
+	DEBUG1(printk("qisioctl: %s: klist_iter_init successful \n", __func__));
+
+	while ((node = klist_next(&iter)) != NULL) {
+		ql4_ioctl_alloc(hba_count, node);
+		hba_count++;
+		DEBUG1(printk("qisioctl: %s: node = %p\n", __func__, node));
+	}
+
+	klist_iter_exit(&iter);
+
+	LEAVE( __func__ );
+
+	printk(KERN_INFO "QLogic iSCSI IOCTL Module ver: %s\n", QL4IM_VERSION);
+
+	return 0;
+}
+
+static void __exit ql4im_exit(void)
+{
+	ENTER( __func__ );
+	symbol_put(qla4xxx_hostlist_ptr);
+	ql4_ioctl_free();
+	ql4_ioctl_exit();
+	LEAVE( __func__ );
+}
+
+module_init(ql4im_init);
+module_exit(ql4im_exit);
+
+MODULE_AUTHOR("QLogic Corporation");
+MODULE_DESCRIPTION("QLogic iSCSI Driver IOCTL Module");
+MODULE_VERSION(QL4IM_VERSION);
+MODULE_LICENSE("GPL");
+
+#else
+#include "ql4_version.h"
+uint32_t
+ql4im_get_hba_count(void)
+{
+	int i;
+
+	hba_count = 0;
+	for (i = 0; i < EXT_DEF_MAX_HBAS; i++)
+		if (hba[i] != NULL)
+			hba_count++;
+	return(hba_count);
+}
+
+static void get_drvr_version(void)
+{
+	char *ver = (char *)QLA4XXX_DRIVER_VERSION;
+
+	strcpy(drvr_ver, ver);
+	ver = drvr_ver;
+        ver = getval(ver, &drvr_major);
+        if (ver && *ver == '.') ver++;
+
+        ver = getval(ver, &drvr_minor);
+        if (ver && *ver == '.') ver++;
+
+        ver = getval(ver, &drvr_patch);
+	drvr_beta = 0;
+        if (ver && *ver == 'b') {
+                ver++;
+                ver = getval(ver, &drvr_beta);
+        }
+	printk(KERN_INFO "qisioctl: %s: ver %s maj %d min %d pat %d beta %d\n",
+		__func__, drvr_ver, drvr_major, drvr_minor, drvr_patch,
+		drvr_beta);
+}
+
+static int ql4_ioctl_init(void)
+{
+	ENTER(__func__);
+
+	apidev_major = register_chrdev(0, QL4_MODULE_NAME, &apidev_fops);
+	if (apidev_major < 0) {
+		DEBUG2(printk("qisioctl: %s: Unable to register CHAR device (%d)\n",
+		    __func__, apidev_major));
+		printk("qisioctl: %s: Unable to register CHAR device (%d)\n",
+		    __func__, apidev_major);
+		return apidev_major;
+	}
+	DEBUG4(printk("qisioctl: %s: apidev_major=%d.\n", __func__, apidev_major));
+	printk("qisioctl: %s: apidev_major=%d.\n", __func__, apidev_major);
+
+	LEAVE(__func__);
+	return 0;
+}
+
+static void ql4_ioctl_exit(void)
+{
+	ENTER(__func__);
+	unregister_chrdev(apidev_major, QL4_MODULE_NAME);
+	LEAVE(__func__);
+}
+
+int ql4im_mem_alloc(int hba_idx, struct scsi_qla_host *ha)
+{
+	return ql4_ioctl_alloc(hba_idx, (struct klist_node *)ha);
+}
+
+void ql4im_mem_free(int hba_idx)
+{
+	struct hba_ioctl *haioctl;
+
+	if ((haioctl = hba[hba_idx]) != NULL) {
+		pci_free_consistent(haioctl->ha->pdev,
+				PAGE_SIZE,
+				haioctl->dma_v,
+				haioctl->dma_p);
+		kfree(haioctl);
+	}
+	hba[hba_idx] = NULL;
+}
+
+int ql4im_init(void)
+{
+	int i ;
+
+	ENTER( __func__ );
+
+	get_drvr_version();
+	
+	for (i = 0; i < EXT_DEF_MAX_HBAS; i++)
+		hba[i] = NULL;
+
+	if (ql4_ioctl_init())
+		return -ENODEV;
+
+	LEAVE(__func__);
+	return 0;
+}
+
+void ql4im_exit(void)
+{
+	ENTER( __func__ );
+	ql4_ioctl_exit();
+	LEAVE( __func__ );
+}
+#endif
diff -r 6a4846854257 drivers/scsi/qla4xxx/ql4im_os.h
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/drivers/scsi/qla4xxx/ql4im_os.h	Mon Jan 11 11:15:25 2010 +0000
@@ -0,0 +1,88 @@
+/*
+ * QLogic iSCSI HBA Driver
+ * Copyright (c)  2003-2006 QLogic Corporation
+ *
+ * See LICENSE.qla4xxx for copyright and licensing details.
+ */
+
+/*
+ * Encapsulates all VMWare Specific code for ioctls
+ */
+
+#ifndef _QL4IM_OS_H_
+#define _QL4IM_OS_H_
+
+#ifdef __VMKLNX__
+#include <vmklinux26_scsi.h>  /* for vmklnx_get_vmhba_name */
+
+#define ql4_access_ok(x) 1
+#define QL4_DDB_TO_TGTID(ddb_entry) ddb_entry->sess->targetID
+
+static inline int ql4_get_port_device_name(struct hba_ioctl *ql4im_ha,
+                                        EXT_IOCTL_ISCSI *ioctl)
+{
+        int                     status = 0;
+        EXT_GET_PORT_DEVICE_NAME data;
+        struct scsi_qla_host    *ha;
+        char                    *vmhba_name;
+        int                     len;
+
+        ha = ql4im_ha->ha;
+        ENTER_IOCTL(__func__, ha->host_no);
+
+        if (ioctl->ResponseLen < sizeof(EXT_GET_PORT_DEVICE_NAME)) {
+                ioctl->Status = EXT_STATUS_BUFFER_TOO_SMALL;
+                DEBUG2(printk("qisioctl: %s: ERROR ResponseLen too small.\n",
+			__func__));
+                goto exit_get_port_device_name;
+        }
+
+        memset(&data, 0, sizeof(EXT_GET_PORT_DEVICE_NAME));
+
+        vmhba_name = vmklnx_get_vmhba_name(ha->host);
+        if (vmhba_name) {
+                len = MIN(strlen(vmhba_name), sizeof(data.deviceName));
+                strncpy(data.deviceName, vmhba_name, len);
+        }
+
+        status =
+		copy_to_user(Q64BIT_TO_PTR(ioctl->ResponseAdr, ioctl->AddrMode),
+                              &data, sizeof(EXT_GET_PORT_DEVICE_NAME));
+
+        if (status) {
+                ioctl->Status = EXT_STATUS_COPY_ERR;
+                DEBUG2(printk("qisioctl: %s: ERROR copy resp buf\n", __func__));
+        }
+
+exit_get_port_device_name:
+        LEAVE_IOCTL(__func__, ha->host_no);
+
+        return(status);
+}
+
+#else
+
+#define ql4_access_ok(arg) access_ok(VERIFY_WRITE, arg, sizeof(EXT_IOCTL_ISCSI))
+
+#define QL4_DDB_TO_TGTID(ddb_entry) ddb_entry->sess->target_id
+
+static inline int ql4_get_port_device_name(struct hba_ioctl *ql4im_ha,
+                                        EXT_IOCTL_ISCSI *ioctl)
+{
+	DEBUG2(printk("qisioctl%lx: %s: EXT_CC_GET_PORT_DEVICE_NAME"
+		" unsupported command code\n",
+		ql4im_ha->ha->host_no, __func__));
+
+	ioctl->Status = EXT_STATUS_UNSUPPORTED_SUBCODE;
+	return 0;
+}
+ 
+#endif
+
+#ifdef QLA_SLES11
+#define QL_GET_SCSI_RESID(cmd) scsi_get_resid(cmd)
+#else
+#define QL_GET_SCSI_RESID(cmd) pscsi_cmd->resid
+#endif
+
+#endif /*_QL4IM_OS_H_*/
diff -r 6a4846854257 drivers/scsi/qla4xxx/qlinioct.h
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/drivers/scsi/qla4xxx/qlinioct.h	Mon Jan 11 11:15:25 2010 +0000
@@ -0,0 +1,489 @@
+/*
+ * QLogic iSCSI HBA Driver
+ * Copyright (c)  2003-2006 QLogic Corporation
+ *
+ * See LICENSE.qla4xxx for copyright and licensing details.
+ */
+
+#ifndef _QLINIOCT_H_
+#define _QLINIOCT_H_
+
+#include "qlisioln.h"
+
+/*
+   Ioctl
+*/
+
+/*
+  General
+*/
+
+/*
+ * Command Codes definitions
+ */
+#define INT_CC_GET_DATA			EXT_CC_RESERVED0A_OS
+#define INT_CC_SET_DATA			EXT_CC_RESERVED0B_OS
+#define INT_CC_DIAG_PING		EXT_CC_RESERVED0C_OS
+#define INT_CC_ISCSI_LOOPBACK		EXT_CC_RESERVED0D_OS
+#define INT_CC_HBA_RESET		EXT_CC_RESERVED0E_OS
+#define INT_CC_COPY_FW_FLASH		EXT_CC_RESERVED0F_OS
+#define INT_CC_LOGOUT_ISCSI		EXT_CC_RESERVED0G_OS
+#define INT_CC_FW_PASSTHRU		EXT_CC_RESERVED0H_OS
+#define INT_CC_IOCB_PASSTHRU		EXT_CC_RESERVED0I_OS
+#define INT_CC_RESTORE_FACTORY_DEFAULTS EXT_CC_RESERVED0J_OS
+
+/*
+ * Sub codes for Get Data.
+ * Use in combination with INT_GET_DATA as the ioctl code
+ */
+#define INT_SC_GET_FLASH			1
+#define INT_SC_GET_CORE_DUMP			2
+
+/*
+ * Sub codes for Set Data.
+ * Use in combination with INT_SET_DATA as the ioctl code
+ */
+#define INT_SC_SET_FLASH			1
+
+#define INT_DEF_DNS_ENABLE                  0x0100
+#define INT_SC_GET_HOST_NO                    3
+
+/*
+ * ***********************************************************************
+ * INIT_FW_ISCSI_ALL
+ * ***********************************************************************
+ */
+typedef struct _INT_INIT_FW_ISCSI_ALL {
+	UINT8   Version;					/* 1   */
+	UINT8   Reserved0;					/* 1   */
+	UINT16  FWOptions;					/* 2   */
+	UINT16  exeThrottle;					/* 2   */
+	UINT8   retryCount;					/* 1   */
+	UINT8   retryDelay;					/* 1   */
+	UINT16  EthernetMTU;					/* 2   */
+	UINT16  addFWOptions;					/* 2   */
+	UINT8   HeartBeat;					/* 1   */
+	UINT8   Reserved1;					/* 1   */
+	UINT16  Reserved2;					/* 2   */
+	UINT16  ReqQOutPtr;					/* 2   */
+	UINT16  RespQInPtr;					/* 2   */
+	UINT16  ReqQLen;					/* 2   */
+	UINT16  RespQLen;					/* 2   */
+	UINT32  ReqQAddr[2];					/* 8   */
+	UINT32  RespQAddr[2];					/* 8   */
+	UINT32  IntRegBufAddr[2];				/* 8   */
+	UINT16  iSCSIOptions;					/* 2   */
+	UINT16  TCPOptions;					/* 2   */
+	UINT16  IPOptions;					/* 2   */
+	UINT16  MaxRxDataSegmentLen;				/* 2   */
+	UINT16  recvMarkerInt;					/* 2   */
+	UINT16  sendMarkerInt;					/* 2   */
+	UINT16  Reserved3;					/* 2   */
+	UINT16  firstBurstSize;					/* 2   */
+	UINT16  DefaultTime2Wait;				/* 2   */
+	UINT16  DefaultTime2Retain;				/* 2   */
+	UINT16  maxOutstandingR2T;				/* 2   */
+	UINT16  keepAliveTimeout;				/* 2   */
+	UINT16  portNumber;					/* 2   */
+	UINT16  maxBurstSize;					/* 2   */
+	UINT32  Reserved4;					/* 4   */
+	UINT8   IPAddr[16];					/* 16  */
+	UINT8   SubnetMask[16];					/* 16  */
+	UINT8   IPGateway[16];					/* 16  */
+	UINT8   DNSsvrIP[4];					/* 4  */
+	UINT8   DNSsecSvrIP[4];					/* 4  */
+	UINT8   Reserved5[8];					/* 8    */
+	UINT8   Alias[EXT_DEF_ISCSI_ALIAS_LEN];			/* 32  */
+	UINT32  targetAddr0;					/* 4   */
+	UINT32  targetAddr1;					/* 4   */
+	UINT32  CHAPTableAddr0;					/* 4   */
+	UINT32  CHAPTableAddr1;					/* 4   */
+	UINT8   EthernetMACAddr[6];				/* 6   */
+	UINT16  TargetPortalGrp;				/* 2   */
+	UINT8   SendScale;					/* 1   */
+	UINT8   RecvScale;					/* 1   */
+	UINT8   TypeOfService;					/* 1   */
+	UINT8   Time2Live;					/* 1   */
+	UINT16  VLANPriority;					/* 2   */
+	UINT16  Reserved6;					/* 2   */
+	UINT8   SecondaryIPAddr[16];				/* 16  */
+	UINT8   iSNSServerAdr[4];				/* 4    */
+	UINT16  iSNSServerPort;					/* 2    */
+	UINT8   Reserved7[10];					/* 10  */
+	UINT8   SLPDAAddr[16];					/* 16  */
+	UINT8   iSCSIName[EXT_DEF_ISCSI_NAME_LEN];		/* 256 */
+} INT_INIT_FW_ISCSI_ALL, *PINT_INIT_FW_ISCSI_ALL;		/* 512 */
+
+/*
+ * ***********************************************************************
+ * INT_DEVICE_ENTRY_ISCSI_ALL
+ * ***********************************************************************
+ */
+typedef struct _INT_DEVICE_ENTRY_ISCSI_ALL {
+	UINT8   Options;					/* 1 */
+	UINT8   Control;					/* 1 */
+	UINT16  exeThrottle;					/* 2 */
+	UINT16  exeCount;					/* 2 */
+	UINT8   retryCount;					/* 1 */
+	UINT8   retryDelay;					/* 1 */
+	UINT16  iSCSIOptions;					/* 2 */
+	UINT16  TCPOptions;					/* 2 */
+	UINT16  IPOptions;					/* 2 */
+	UINT16  MaxRxDataSegmentLen;				/* 2 */
+	UINT16  RecvMarkerInterval;				/* 2 */
+	UINT16  SendMarkerInterval;				/* 2 */
+	UINT16  MaxTxDataSegmentLen;				/* 2 */
+	UINT16  firstBurstSize;					/* 2 */
+	UINT16  DefaultTime2Wait;				/* 2 */
+	UINT16  DefaultTime2Retain;				/* 2 */
+	UINT16  maxOutstandingR2T;				/* 2 */
+	UINT16  keepAliveTimeout;				/* 2 */
+	UINT8   InitiatorSessID[EXT_DEF_ISCSI_ISID_SIZE];	/* 6 */
+	UINT16  TargetSessID;					/* 2 */
+	UINT16  portNumber;					/* 2 */
+	UINT16  maxBurstSize;					/* 2 */
+	UINT16  taskMngmntTimeout;				/* 2 */
+	UINT16  Reserved0;					/* 2 */
+	UINT8   IPAddress[16];					/* 16  */
+	UINT8   Alias[EXT_DEF_ISCSI_ALIAS_LEN];			/* 32  */
+	UINT8   targetAddr[EXT_DEF_ISCSI_TADDR_SIZE];		/* 32  */
+	/* need to find new definition XXX */
+	UINT8   res[64];
+	UINT8   iSCSIName[EXT_DEF_ISCSI_NAME_LEN];		/* 256 */
+	UINT16  ddbLink;					/* 2   */
+	UINT16  chapTableIndex;					/* 2   */
+	UINT16  targetPortalGrp;				/* 2   */
+	UINT16  Reserved1;					/* 2   */
+	UINT32  statSN;						/* 4 */
+	UINT32  expStatSN;					/* 4 */
+} INT_DEVICE_ENTRY_ISCSI_ALL, *PINT_DEVICE_ENTRY_ISCSI_ALL;	/* 464 */
+
+/*
+ * ****************************************************************************
+ * INT_DEVDDB_ENTRY
+ * ****************************************************************************
+ */
+
+typedef struct _FLASH_DEVDB_ENTRY {
+	INT_DEVICE_ENTRY_ISCSI_ALL      entryData;		/* 0-1C7   */
+	UINT8                           RES0[0x2C];		/* 1C8-1FB */
+	UINT16                          ddbValidCookie;		/* 1FC-1FD */
+	UINT16                          ddbValidSize;		/* 1FE-1FF */
+} FLASH_DEVDB_ENTRY, *PFLASH_DEVDB_ENTRY;
+
+/*
+ * ****************************************************************************
+ * INT_FLASH_INITFW
+ * ****************************************************************************
+ */
+
+typedef struct _FLASH_INITFW {
+	INT_INIT_FW_ISCSI_ALL   initFWData;
+	UINT32                  validCookie;
+} FLASH_INITFW, *PFLASH_INITFW;
+
+
+/*
+ * ***********************************************************************
+ * INT_ACCESS_FLASH
+ * ***********************************************************************
+ */
+
+#define INT_DEF_AREA_TYPE_FW_IMAGE1		0x01
+#define INT_DEF_AREA_TYPE_FW_IMAGE2		0x02
+#define INT_DEF_AREA_TYPE_DRIVER		0x03
+#define INT_DEF_AREA_TYPE_DDB			0x04
+#define INT_DEF_AREA_TYPE_INIT_FW		0x05
+#define INT_DEF_AREA_TYPE_SYS_INFO		0x06
+
+#define INT_DEF_FLASH_BLK_SIZE			0x4000
+#define INT_DEF_FLASH_PHYS_BLK_SIZE		0x20000
+
+#define INT_ISCSI_FW_IMAGE2_FLASH_OFFSET	0x01000000
+#define INT_ISCSI_SYSINFO_FLASH_OFFSET		0x02000000
+#define INT_ISCSI_DRIVER_FLASH_OFFSET		0x03000000
+#define INT_ISCSI_INITFW_FLASH_OFFSET		0x04000000
+#define INT_ISCSI_DDB_FLASH_OFFSET		0x05000000
+#define INT_ISCSI_CHAP_FLASH_OFFSET		0x06000000
+#define INT_ISCSI_FW_IMAGE1_FLASH_OFFSET	0x07000000
+#define INT_ISCSI_BIOS_FLASH_OFFSET		0x0d000000
+#define INT_ISCSI_OFFSET_MASK			0x00FFFFFF
+#define INT_ISCSI_PAGE_MASK			0x0F000000
+
+#define INT_ISCSI_ACCESS_FLASH			0x00000000
+#define INT_ISCSI_ACCESS_RAM			0x10000000
+#define INT_ISCSI_ACCESS_MASK			0xF0000000
+
+/* WRITE_FLASH option definitions */
+#define INT_WRITE_FLASH_OPT_HOLD		0 /* Write data to FLASH but
+						     do not Commit */
+#define INT_WRITE_FLASH_OPT_CLEAR_REMAINING	1 /* Write data to FLASH but
+						     do not Commit any data
+						     not written before
+						     commit will be cleared
+						     (set to 0xFF)	*/
+#define INT_WRITE_FLASH_OPT_COMMIT_DATA		2 /* Commit (Burn) data to
+						     FLASH */
+
+
+typedef struct _INT_ACCESS_FLASH {
+	UINT32  AreaType;					/* 4   */
+	UINT32  DataLen;					/* 4   */
+	UINT32  DataOffset;					/* 4   */
+	UINT8   FlashData[INT_DEF_FLASH_BLK_SIZE];		/* 0x4000 */
+	UINT32  Options;					/* 4   */
+} INT_ACCESS_FLASH, *PINT_ACCESS_FLASH;				/* 0x4010 */
+
+/*
+ * ****************************************************************************
+ * INT_FLASH_DRIVER_PARAM
+ * ****************************************************************************
+ */
+
+typedef struct _INT_FLASH_DRIVER_PARAM {
+	UINT16  DiscoveryTimeOut;				/* 2   */
+	UINT16  PortDownTimeout;				/* 2   */
+	UINT32  Reserved[32];					/* 128 */
+} INT_FLASH_DRIVER_PARAM, *PINT_FLASH_DRIVER_PARAM;		/* 132 */
+
+
+#define VALID_FLASH_INITFW		0x11BEAD5A
+
+#define FLASH_ISCSI_MAX_DDBS		64
+#define FLASH_DDB_VALID_COOKIE		0x9034 /* this value indicates this
+						  entry in flash is valid */
+#define FLASH_DDB_INVALID_COOKIE	0x0    /* this value is used to set
+						  the entry to invalid    */
+
+/*
+ * ****************************************************************************
+ * INT_HBA_SYS_INFO
+ * ****************************************************************************
+ */
+
+typedef struct _INT_HBA_SYS_INFO {
+	UINT32  cookie;						/* 4   */
+	UINT32  physAddrCount;					/* 4   */
+	UINT8   macAddr0[6];					/* 6   */
+	UINT8   reserved0[2];					/* 2   */
+	UINT8   macAddr1[6];					/* 6   */
+	UINT8   reserved1[2];					/* 2   */
+	UINT8   macAddr2[6];					/* 6   */
+	UINT8   reserved2[2];					/* 2   */
+	UINT8   macAddr3[6];					/* 6   */
+	UINT8   reserved3[2];					/* 2   */
+	UINT8   vendorId[128];					/* 128 */
+	UINT8   productId[128];					/* 128 */
+	UINT32  serialNumber;					/* 4   */
+	UINT32  pciDeviceVendor;				/* 4   */
+	UINT32  pciDeviceId;					/* 4   */
+	UINT32  pciSubsysVendor;				/* 4   */
+	UINT32  pciSubsysId;					/* 4   */
+	UINT32  crumbs;						/* 4   */
+	UINT32  enterpriseNumber;				/* 4   */
+	UINT32  crumbs2;					/* 4   */
+} INT_HBA_SYS_INFO, *PINT_HBA_SYS_INFO;				/* 328 */
+
+/*
+ * ****************************************************************************
+ * INT_FW_DW_HDR
+ * ****************************************************************************
+ */
+
+/* File header for FW */
+typedef struct _INT_FW_DL_HDR {
+	UINT32  Size;		/* download size, excluding DL_HDR & EXT_HDR*/
+	UINT32  Checksum;	/* Checksum of download file, excluding DL_HDR
+				   & EXT_HDR */
+	UINT32  HdrChecksum;	/* Checksum of header area should be zero */
+	UINT32  Flags;		/* See Flags bits defined above */
+	UINT32  Cookie;		/* Target specific identifier */
+	UINT32  Target;		/* Target specific identifier */
+	UINT32  Reserved0;	/* Reserved */
+	UINT32  Reserved1;	/* Reserved */
+	UINT8   Copyright[64];	/* Copyright */
+	UINT8   Version[32];	/* Version String */
+} INT_FW_DL_HDR, *PINT_FW_DL_HDR;
+
+/* File header for BIOS */
+typedef struct _INT_BIOS_HDR {
+	UINT8   BIOSidCode55;
+	UINT8   BIOSidCodeAA;
+	UINT8   reserved[52];
+	UINT8   BIOSminorVer;
+	UINT8   BIOSmajorVer;
+} INT_BIOS_HDR, *PINT_BIOS_HDR;
+
+typedef struct _INT_SDMBIOS_NVRAM {
+	UINT16  Flags;
+	UINT8   PriID;
+	UINT64  PriLUN;
+	UINT8   SecID;
+	UINT64  SecLUN;
+} INT_SDMBIOS_NVRAM, *PINT_SDMBIOS_NVRAM;
+
+/*
+ * ****************************************************************************
+ * INT_HBA_RESET
+ * ****************************************************************************
+ */
+
+typedef struct _INT_HBA_RESET {
+	UINT32  Reserved[2];					/* 8  */
+} INT_HBA_RESET, *PINT_HBA_RESET;				/* 8  */
+
+/*
+ * ****************************************************************************
+ * INT_COPY_FW_FLASH
+ * ****************************************************************************
+ */
+
+typedef struct _INT_COPY_FW_FLASH {
+	UINT32  Options;					/* 4  */
+} INT_COPY_FW_FLASH, *PINT_COPY_FW_FLASH;			/* 4  */
+
+#define INT_COPY_FLASH_PRIMARY_TO_SECONDARY	0
+#define INT_COPY_FLASH_SECONDARY_TO_PRIMARY	1
+
+/*
+ * ****************************************************************************
+ * INT_LOGOUT_ISCSI
+ * ****************************************************************************
+ */
+
+/* Logout Options */
+
+#define INT_DEF_CLOSE_SESSION			0x0001
+#define INT_DEF_RELOGIN_CONNECTION		0x0002
+#define INT_DEF_DELETE_DDB		      	0x0004
+#define INT_DEF_REINDEX_DDB		      	0x0008
+
+typedef struct _INT_LOGOUT_ISCSI {
+	UINT16    TargetID;					/* 2   */
+	UINT16    ConnectionID;					/* 2   */
+	UINT16    Options;					/* 2   */
+	UINT32    NewTargetID;					/* 4   */
+} INT_LOGOUT_ISCSI, *PINT_LOGOUT_ISCSI;				/* 10  */
+
+/*
+ * ****************************************************************************
+ * INT_PING
+ * ****************************************************************************
+ */
+
+typedef struct _INT_PING {
+	EXT_ISCSI_IP_ADDR       IPAddr;				/* 20  */
+	UINT16                  PacketSize;			/* 2   */
+	UINT16                  Reserved;			/* 2   */
+} INT_PING, *PINT_PING;						/* 24  */
+
+/*
+ * ****************************************************************************
+ * INT_IOCB_PASSTHRU
+ * ****************************************************************************
+ */
+
+#define INT_DEF_IOCB_BUF_SIZE			64
+#define INT_DEF_IOCB_DATA_SIZE			1500
+
+typedef struct _INT_IOCB_PASSTHRU {
+	UINT32    SendDMAOffset;				/* 4    */
+	UINT32    RspDMAOffset;					/* 4    */
+	UINT8     IOCBCmdBuffer[INT_DEF_IOCB_BUF_SIZE];		/* 64   */
+	UINT8     IOCBStatusBuffer[INT_DEF_IOCB_BUF_SIZE];	/* 64   */
+	UINT32    SendDataLen;					/* 4    */
+	UINT8     SendData[INT_DEF_IOCB_DATA_SIZE];		/* 1500 */
+	UINT32    RspDataLen;					/* 4    */
+	UINT8     RspData[INT_DEF_IOCB_DATA_SIZE];		/* 1500 */
+	UINT32    Reserved;					/* 4    */
+} INT_IOCB_PASSTHRU, *PINT_IOCB_PASSTHRU;			/* 3148 */
+
+
+/*
+ * ****************************************************************************
+ * INT_CC_FW_PASSTHRU
+ * ****************************************************************************
+ */
+
+/* FW PASSTHRU Defines */
+#define INT_DEF_FW_PASSHTRU_BLK_SIZE		0x4000
+
+#define INT_DEF_DATA_TYPE_CHAP_TABLE		0x0001
+#define INT_DEF_DATA_TYPE_DDB			0x0002
+#define INT_DEF_DATA_TYPE_INITFW		0x0003
+#define INT_DEF_DATA_TYPE_FW_IMAGE		0x0004
+
+#define INT_DEF_DATA_LOCATION_HBA_FLASH		0x0001
+#define INT_DEF_DATA_LOCATION_HBA_RAM		0x0002
+
+#define INT_DEF_DATA_READ			0x0001
+#define INT_DEF_DATA_WRITE			0x0002
+
+#define INT_DEF_DATA_INIT			0x0001
+#define INT_DEF_DATA_COMMIT			0x0002
+
+/*
+ * ****************************************************************************
+ * INT_RESTORE_FACTORY_DEFAULTS
+ * ****************************************************************************
+ */
+
+#define INT_DEF_FACT_DFLT_MASK_IFCB		0x00000001
+#define INT_DEF_FACT_DFLT_MASK_DDB		0x00000002
+#define INT_DEF_FACT_DFLT_MASK_CHAP		0x00000004
+#define INT_DEF_FACT_DFLT_MASK_IPSEC		0x00000008
+#define INT_DEF_FACT_DFLT_MASK_NVRAM		0x00000010
+#define INT_DEF_FACT_DFLT_MASK_INVERSE_INITFW   0x02000000
+
+#define INT_DEF_FACT_DFLT_IFCB_ALL		0xffffffff
+#define INT_DEF_FACT_DFLT_IFCB_FW_OPT		0x00000001
+#define INT_DEF_FACT_DFLT_IFCB_MTU		0x00000002
+#define INT_DEF_FACT_DFLT_IFCB_ADD_FW_OPT	0x00000004
+#define INT_DEF_FACT_DFLT_IFCB_HEARTBEAT	0x00000008
+#define INT_DEF_FACT_DFLT_IFCB_ISCSI_OPT	0x00000010
+#define INT_DEF_FACT_DFLT_IFCB_TCP_OPT		0x00000020
+#define INT_DEF_FACT_DFLT_IFCB_IP_OPT		0x00000040
+#define INT_DEF_FACT_DFLT_IFCB_MAX_RECV_SEG_LEN	0x00000080
+#define INT_DEF_FACT_DFLT_IFCB_FIRST_BURST_LEN	0x00000100
+#define INT_DEF_FACT_DFLT_IFCB_MAX_OUTSTANDING_R2T	0x00000200
+#define INT_DEF_FACT_DFLT_IFCB_ISCSI_PORT_NUM	0x00000400
+#define INT_DEF_FACT_DFLT_IFCB_MAX_BURST_LEN	0x00000800
+#define INT_DEF_FACT_DFLT_IFCB_IP_ADDR		0x00001000
+#define INT_DEF_FACT_DFLT_IFCB_SUBNET_MASK	0x00002000
+#define INT_DEF_FACT_DFLT_IFCB_GATEWAY_ADDR	0x00004000
+#define INT_DEF_FACT_DFLT_IFCB_PRI_DNS_ADDR	0x00008000
+#define INT_DEF_FACT_DFLT_IFCB_SEC_DNS_ADDR	0x00010000
+#define INT_DEF_FACT_DFLT_IFCB_MIN_EPHMRL_PORT_NUM	0x00020000
+#define INT_DEF_FACT_DFLT_IFCB_MAX_EPHMRL_PORT_NUM	0x00040000
+#define INT_DEF_FACT_DFLT_IFCB_ABORT_TIMER	0x00080000
+#define INT_DEF_FACT_DFLT_IFCB_ISCSI_ALIAS	0x00100000
+#define INT_DEF_FACT_DFLT_IFCB_TCP_WIN_SCALE	0x00200000
+#define INT_DEF_FACT_DFLT_IFCB_SEC_IP_ADDR	0x00400000
+#define INT_DEF_FACT_DFLT_IFCB_ISNS_IP_ADDR	0x00800000
+#define INT_DEF_FACT_DFLT_IFCB_ISNS_PORT_NUM	0x01000000
+#define INT_DEF_FACT_DFLT_IFCB_ISCSI_NAME	0x02000000
+
+typedef struct _INT_RESTORE_FACTORY_DEFAULTS
+{
+	UINT32	BlockMask;					/* 4   */
+	UINT32	IFCBMask1;					/* 4   */
+	UINT32	IFCBMask2;					/* 4   */
+	UINT32	Reserved[5];					/* 20  */
+} INT_RESTORE_FACTORY_DEFAULTS, *PINT_RESTORE_FACTORY_DEFAULTS; /* 32  */
+
+/*
+ * ****************************************************************************
+ * INT_ACCESS_CORE_DUMP
+ * ****************************************************************************
+ */
+
+typedef struct _INT_ACCESS_CORE_DUMP {
+	uint32_t	DataLen;				/* 4  - 0x00 */
+	uint32_t	Offset;					/* 4  - 0x04 */
+	uint8_t		LastBlockFlag;				/* 1  - 0x08 */
+	uint8_t		Reserved[7];				/* 7  - 0x09 */
+	uint8_t		Data[];					/* 0  - 0x10 */
+} INT_ACCESS_CORE_DUMP, *PINT_ACCESS_CORE_DUMP;                 /* 0x10  */
+
+#define CORE_DUMP_HEADER_SIZE                   0x256
+#endif /* _QLINIOCT_H_ */
diff -r 6a4846854257 drivers/scsi/qla4xxx/qlisioct.h
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/drivers/scsi/qla4xxx/qlisioct.h	Mon Jan 11 11:15:25 2010 +0000
@@ -0,0 +1,871 @@
+/*
+ * QLogic iSCSI HBA Driver
+ * Copyright (c)  2003-2006 QLogic Corporation
+ *
+ * See LICENSE.qla4xxx for copyright and licensing details.
+ */
+
+/*
+ * File Name: qlisioct.h
+ *
+ */
+#ifndef _QLISIOCT_H
+#define _QLISIOCT_H
+
+/*
+ * NOTE: the following version defines must be updated each time the
+ *	 changes made may affect the backward compatibility of the
+ *	 input/output relations of the IOCTL functions.
+ */
+#define EXT_VERSION				6
+
+/*
+ * OS independent General definitions
+ */
+#define EXT_DEF_SIGNATURE_SIZE			8
+#define EXT_DEF_SERIAL_NUM_SIZE			4
+#define EXT_DEF_MAX_STR_SIZE			128
+
+#define EXT_DEF_ADDR_MODE_32			1
+#define EXT_DEF_ADDR_MODE_64			2
+
+/*
+ * ****************************************************************************
+ * OS type definitions
+ * ****************************************************************************
+ */
+#ifdef _MSC_VER					/* NT */
+
+#include "qlisiont.h"
+
+#elif defined(linux)				/* Linux */
+
+#include "qlisioln.h"
+
+#elif defined(sun) || defined(__sun)		/* Solaris */
+
+#include "qlisioso.h"
+
+#endif
+
+/*
+ * ****************************************************************************
+ * OS dependent General configuration defines
+ * ****************************************************************************
+ */
+#define EXT_DEF_MAX_HBA				EXT_DEF_MAX_HBA_OS
+#define EXT_DEF_MAX_BUS				EXT_DEF_MAX_BUS_OS
+#define EXT_DEF_MAX_TARGET			EXT_DEF_MAX_TARGET_OS
+#define EXT_DEF_MAX_LUN				EXT_DEF_MAX_LUN_OS
+
+/*
+ * Addressing mode used by the user application
+ */
+#define EXT_ADDR_MODE				EXT_ADDR_MODE_OS
+
+/*
+ * Command Codes definitions
+ */
+#define EXT_CC_QUERY				EXT_CC_QUERY_OS
+#define EXT_CC_REG_AEN				EXT_CC_REG_AEN_OS
+#define EXT_CC_GET_AEN				EXT_CC_GET_AEN_OS
+#define EXT_CC_GET_DATA				EXT_CC_GET_DATA_OS
+#define EXT_CC_SET_DATA				EXT_CC_SET_DATA_OS
+#define EXT_CC_SEND_SCSI_PASSTHRU		EXT_CC_SEND_SCSI_PASSTHRU_OS
+#define EXT_CC_SEND_ISCSI_PASSTHRU		EXT_CC_SEND_ISCSI_PASSTHRU_OS
+#define EXT_CC_DISABLE_ACB			EXT_CC_DISABLE_ACB_OS
+#define EXT_CC_SEND_ROUTER_SOL			EXT_CC_SEND_ROUTER_SOL_OS
+
+/*
+ * ****************************************************************************
+ * EXT_IOCTL_ISCSI
+ * ****************************************************************************
+ */
+/*
+ * EXT_IOCTL_ISCSI SubCode definition.
+ * These macros are being used for setting SubCode field in EXT_IOCTL_ISCSI
+ * structure.
+ */
+
+/*
+ * Sub codes for Query.
+ * Uses in combination with EXT_QUERY as the ioctl code.
+ */
+#define EXT_SC_QUERY_HBA_ISCSI_NODE		1
+#define EXT_SC_QUERY_HBA_ISCSI_PORTAL		2
+#define EXT_SC_QUERY_DISC_ISCSI_NODE		3
+#define EXT_SC_QUERY_DISC_ISCSI_PORTAL		4
+#define EXT_SC_QUERY_DISC_LUN                   5
+#define EXT_SC_QUERY_DRIVER			6
+#define EXT_SC_QUERY_FW				7
+#define EXT_SC_QUERY_CHIP			8
+#define EXT_SC_QUERY_IP_STATE			9
+#define EXT_SC_QUERY_DEVICE_CURRENT_IP		10
+
+/*
+ * Sub codes for Get Data.
+ * Use in combination with EXT_GET_DATA as the ioctl code
+ */
+#define EXT_SC_GET_STATISTICS_GEN		1
+#define EXT_SC_GET_STATISTICS_ISCSI		2
+#define EXT_SC_GET_DEVICE_ENTRY_ISCSI		3
+#define EXT_SC_GET_INIT_FW_ISCSI		4
+#define EXT_SC_GET_INIT_FW_DEFAULTS_ISCSI	5
+#define EXT_SC_GET_DEVICE_ENTRY_DEFAULTS_ISCSI	6
+#define EXT_SC_GET_ISNS_SERVER			7
+#define EXT_SC_GET_ISNS_DISCOVERED_TARGETS	8
+#define EXT_SC_GET_ACB				9
+#define EXT_SC_GET_NEIGHBOR_CACHE		10
+#define EXT_SC_GET_DESTINATION_CACHE		11
+#define EXT_SC_GET_DEFAULT_ROUTER_LIST		12
+#define EXT_SC_GET_LOCAL_PREFIX_LIST		13
+#define EXT_SC_GET_STATISTICS_ISCSI_BLOCK	14
+
+/*
+ * Sub codes for Set Data.
+ * Use in combination with EXT_SET_DATA as the ioctl code
+ */
+#define EXT_SC_RST_STATISTICS_GEN		1
+#define EXT_SC_RST_STATISTICS_ISCSI		2
+#define EXT_SC_SET_DEVICE_ENTRY_ISCSI		3
+#define EXT_SC_SET_INIT_FW_ISCSI		4
+#define EXT_SC_SET_ISNS_SERVER			5
+#define EXT_SC_SET_ACB				6
+
+/*
+ * Status.  These macros are being used for setting Status field in
+ * EXT_IOCTL_ISCSI structure.
+ */
+#define EXT_STATUS_OK				0
+#define EXT_STATUS_ERR				1
+#define EXT_STATUS_BUSY				2
+#define EXT_STATUS_PENDING			3
+#define EXT_STATUS_SUSPENDED			4
+#define EXT_STATUS_RETRY_PENDING		5
+#define EXT_STATUS_INVALID_PARAM		6
+#define EXT_STATUS_DATA_OVERRUN			7
+#define EXT_STATUS_DATA_UNDERRUN		8
+#define EXT_STATUS_DEV_NOT_FOUND		9
+#define EXT_STATUS_COPY_ERR			10
+#define EXT_STATUS_MAILBOX			11
+#define EXT_STATUS_UNSUPPORTED_SUBCODE		12
+#define EXT_STATUS_UNSUPPORTED_VERSION		13
+#define EXT_STATUS_MS_NO_RESPONSE		14
+#define EXT_STATUS_SCSI_STATUS			15
+#define EXT_STATUS_BUFFER_TOO_SMALL		16
+#define EXT_STATUS_NO_MEMORY			17
+#define EXT_STATUS_UNKNOWN			18
+#define EXT_STATUS_UNKNOWN_DSTATUS		19
+#define EXT_STATUS_INVALID_REQUEST		20
+#define EXT_STATUS_DEVICE_NOT_READY		21
+#define EXT_STATUS_DEVICE_OFFLINE		22
+#define EXT_STATUS_HBA_NOT_READY		23
+#define EXT_STATUS_HBA_QUEUE_FULL		24
+
+/*
+ * Detail Status contains the SCSI bus status codes.
+ */
+#define EXT_DSTATUS_GOOD			0x00
+#define EXT_DSTATUS_CHECK_CONDITION		0x02
+#define EXT_DSTATUS_CONDITION_MET		0x04
+#define EXT_DSTATUS_BUSY			0x08
+#define EXT_DSTATUS_INTERMEDIATE		0x10
+#define EXT_DSTATUS_INTERMEDIATE_COND_MET	0x14
+#define EXT_DSTATUS_RESERVATION_CONFLICT	0x18
+#define EXT_DSTATUS_COMMAND_TERMINATED		0x22
+#define EXT_DSTATUS_QUEUE_FULL			0x28
+
+/*
+ * Detail Status contains one of the following codes
+ * when Status = EXT_STATUS_INVALID_PARAM or
+ *	       = EXT_STATUS_DEV_NOT_FOUND
+ */
+#define EXT_DSTATUS_NOADNL_INFO			0x00
+#define EXT_DSTATUS_HBA_INST			0x01
+#define EXT_DSTATUS_TARGET			0x02
+#define EXT_DSTATUS_LUN				0x03
+#define EXT_DSTATUS_REQUEST_LEN			0x04
+#define EXT_DSTATUS_PATH_INDEX			0x05
+
+/*
+ * FLASH error status
+*/
+#define EXT_FLASH_NO_INFO			0x00
+#define EXT_FLASH_NO_MEMORY			0x0a
+#define EXT_FLASH_FW_IMAGE_INVALID		0x0b
+#define EXT_FLASH_NO_BKUP_FW_IMAGE		0x0c
+#define EXT_FLASH_ERROR_ACCESSING_FLASH		0x0d
+
+/*
+ * Defines for VendorSpecificStatus
+ */
+#define VENDOR_SPECIFIC_STATUS_MB_STATUS_INDEX		0 /* [0-4]  mbSts */
+#define VENDOR_SPECIFIC_STATUS_MB_COMMAND_INDEX		5 /* [5-10] mbCmd */
+#define VENDOR_SPECIFIC_STATUS_IOSB_COMPLETION_INDEX	0
+#define VENDOR_SPECIFIC_STATUS_SCSI_STATUS_INDEX	1
+
+
+typedef struct _EXT_IOCTL_ISCSI {
+	UINT8	Signature[EXT_DEF_SIGNATURE_SIZE];	/* 8   */
+	UINT16	AddrMode;				/* 2   */
+	UINT16	Version;				/* 2   */
+	UINT16	SubCode;				/* 2   */
+	UINT16	Instance;				/* 2   */
+	UINT32	Status;					/* 4   */
+	UINT32	DetailStatus;				/* 4   */
+	UINT32	Reserved1;				/* 4   */
+	UINT32	RequestLen;				/* 4   */
+	UINT32	ResponseLen;				/* 4   */
+	UINT64	RequestAdr;				/* 8   */
+	UINT64	ResponseAdr;				/* 8   */
+	UINT16	HbaSelect;				/* 2   */
+	UINT32	VendorSpecificStatus[11];		/* 44  */
+	UINT64	Signature2;				/* 8   */
+} __attribute__((packed)) EXT_IOCTL_ISCSI, *PEXT_IOCTL_ISCSI;	/* 106 */
+
+/*
+ * ****************************************************************************
+ * EXT_ISCSI_DEVICE
+ * ****************************************************************************
+ */
+/* Device Type */
+#define EXT_DEF_ISCSI_REMOTE			0x02
+#define EXT_DEF_ISCSI_LOCAL			0x01
+
+#define EXT_ISCSI_ENABLE_DHCP			0x01
+
+#define EXT_DEF_ISCSI_TADDR_SIZE		32
+
+typedef struct _EXT_ISCSI_DEVICE {
+	UINT16	DeviceType;				/* 2   */
+	UINT16	ExeThrottle;				/* 2   */
+	UINT16	InitMarkerlessInt;			/* 2   */
+	UINT8	RetryCount;				/* 1   */
+	UINT8	RetryDelay;				/* 1   */
+	UINT16	iSCSIOptions;				/* 2   */
+	UINT16	TCPOptions;				/* 2   */
+	UINT16	IPOptions;				/* 2   */
+	UINT16	MaxPDUSize;				/* 2   */
+	UINT16	FirstBurstSize;				/* 2   */
+	UINT16	LogoutMinTime;				/* 2   */
+	UINT16	LogoutMaxTime;				/* 2   */
+	UINT16	MaxOutstandingR2T;			/* 2   */
+	UINT16	KeepAliveTimeout;			/* 2   */
+	UINT16	PortNumber;				/* 2   */
+	UINT16	MaxBurstSize;				/* 2   */
+	UINT16	TaskMgmtTimeout;			/* 2   */
+	UINT8	TargetAddr[EXT_DEF_ISCSI_TADDR_SIZE];	/* 32  */
+} EXT_ISCSI_DEVICE, *PEXT_ISCSI_DEVICE;		/* 64  */
+
+/*
+ * ****************************************************************************
+ * EXT_ISCSI_IP_ADDR
+ * ****************************************************************************
+ */
+#define EXT_DEF_IP_ADDR_SIZE			16
+#define EXT_DEF_TYPE_ISCSI_IP			0
+#define EXT_DEF_TYPE_ISCSI_IPV6			1
+
+typedef struct _EXT_ISCSI_IP_ADDR {
+	UINT8	IPAddress[EXT_DEF_IP_ADDR_SIZE];	/* 16  */
+	UINT16	Type;					/* 2   */
+	UINT16	Reserved;				/* 2   */
+} EXT_ISCSI_IP_ADDR, *PEXT_ISCSI_IP_ADDR;		/* 20  */
+
+/*
+ * ****************************************************************************
+ * EXT_NODE_INFO_ISCSI
+ * ****************************************************************************
+ */
+#define EXT_DEF_ISCSI_NAME_LEN			256
+#define EXT_DEF_ISCSI_ALIAS_LEN			32
+
+typedef struct _EXT_NODE_INFO_ISCSI {
+	EXT_ISCSI_IP_ADDR IPAddr;			/* 20  */
+	UINT8	iSCSIName[EXT_DEF_ISCSI_NAME_LEN];	/* 256 */
+	UINT8	Alias[EXT_DEF_ISCSI_ALIAS_LEN];		/* 32  */
+	UINT16	PortalCount;				/* 2   */
+	UINT8	Reserved[10];				/* 10  */
+} EXT_NODE_INFO_ISCSI, *PEXT_NODE_INFO_ISCSI;		/* 320 */
+
+/*
+ * ****************************************************************************
+ * EXT_SCSI_ADDR_ISCSI
+ * ****************************************************************************
+ */
+typedef struct _EXT_SCSI_ADDR_ISCSI {
+	UINT16	Bus;					/* 2   */
+	UINT16	Target;					/* 2   */
+	UINT16	Lun;					/* 2   */
+	UINT16	Padding[5];				/* 10  */
+} EXT_SCSI_ADDR_ISCSI, *PEXT_SCSI_ADDR_ISCSI;		/* 16  */
+
+/*
+ * ****************************************************************************
+ * EXT_REG_AEN_ISCSI
+ * ****************************************************************************
+ */
+#define EXT_DEF_ENABLE_AENS		0x00000000
+#define EXT_DEF_ENABLE_NO_AENS		0xFFFFFFFF
+
+typedef struct _EXT_REG_AEN_ISCSI {
+	UINT32	Enable;					/* 4   */
+	UINT32	Reserved[3];				/* 12  */
+} EXT_REG_AEN_ISCSI, *PEXT_REG_AEN_ISCSI;		/* 16  */
+
+/*
+ * ****************************************************************************
+ * EXT_ASYNC_EVENT
+ * ****************************************************************************
+ */
+
+/* Required # of entries in the queue buffer allocated. */
+#define EXT_DEF_MAX_AEN_QUEUE			EXT_DEF_MAX_AEN_QUEUE_OS
+#define EXT_DEF_MAX_AEN_PAYLOAD			7
+
+typedef struct _EXT_ASYNC_EVENT {
+	UINT32	AsyncEventCode;				/* 4   */
+	UINT32	Payload[EXT_DEF_MAX_AEN_PAYLOAD];	/* 28  */
+} EXT_ASYNC_EVENT, *PEXT_ASYNC_EVENT;			/* 32  */
+
+/*
+ * ****************************************************************************
+ * EXT_CHIP_INFO
+ * ****************************************************************************
+ */
+typedef struct _EXT_CHIP_INFO {
+	UINT16	VendorId;				/* 2   */
+	UINT16	DeviceId;				/* 2   */
+	UINT16	SubVendorId;				/* 2   */
+	UINT16	SubSystemId;				/* 2   */
+	UINT16	BoardID;				/* 2   */
+	UINT16	Reserved[35];				/* 70  */
+} EXT_CHIP_INFO, *PEXT_CHIP_INFO;			/* 80  */
+
+/*
+ * ****************************************************************************
+ * EXT_DEVICE_ENTRY_ISCSI
+ * ****************************************************************************
+ */
+/* Options */
+#define EXT_DEF_ISCSI_GRANT_ACCESS		0x04
+#define EXT_DEF_ISCSI_TARGET_DEVICE		0x02
+#define EXT_DEF_ISCSI_INITIATOR_DEVICE		0x01
+
+/* Control */
+#define EXT_DEF_SESS_RECVRY_IN_PROCESS		0x10
+#define EXT_DEF_ISCSI_TRANSMITTING		0x08
+#define EXT_DEF_ISCSI_TX_LINKED			0x04
+#define EXT_DEF_ISCSI_QUEUE_ABORTED		0x02
+#define EXT_DEF_ISCSI_TX_LOGGED_IN		0x01
+
+/* DeviceState */
+#define EXT_DEF_DEV_STATE_UNASSIGNED		0x00
+#define EXT_DEF_DEV_STATE_NO_CONNECTION_ACTIVE	0x01
+#define EXT_DEF_DEV_STATE_DISCOVERY		0x02
+#define EXT_DEF_DEV_STATE_NO_SESSION_ACTIVE	0x03
+#define EXT_DEF_DEV_STATE_SESSION_ACTIVE	0x04
+#define EXT_DEF_DEV_STATE_LOGGING_OUT		0x05
+#define EXT_DEF_DEV_STATE_SESSION_FAILED	0x06
+#define EXT_DEF_DEV_STATE_OPENING		0x07
+
+#define EXT_DEF_ISCSI_ISID_SIZE			6
+#define EXT_DEF_ISCSI_USER_ID_SIZE		32
+#define EXT_DEF_ISCSI_PASSWORD_SIZE		32
+
+typedef struct _EXT_DEVICE_ENTRY_ISCSI {
+	UINT8	Options;				/* 1   */
+	UINT8	Control;				/* 1   */
+	UINT8	InitiatorSessID[EXT_DEF_ISCSI_ISID_SIZE];	/* 6   */
+	UINT16	TargetSessID;				/* 2   */
+	UINT32	ReservedFlags;				/* 4   */
+	UINT8	UserID[EXT_DEF_ISCSI_USER_ID_SIZE];	/* 32  */
+	UINT8	Password[EXT_DEF_ISCSI_PASSWORD_SIZE];	/* 32  */
+	EXT_ISCSI_DEVICE	DeviceInfo;		/* 64  */
+	EXT_NODE_INFO_ISCSI	EntryInfo;		/* 320 */
+	UINT16	ExeCount;				/* 2   */
+	UINT32	NumValid;				/* 4   */
+	UINT32	NextValid;				/* 4   */
+	UINT32	DeviceState;				/* 4   */
+	UINT16	DDBLink;				/* 2   */
+	UINT16	Reserved[17];				/* 34  */
+} EXT_DEVICE_ENTRY_ISCSI, *PEXT_DEVICE_ENTRY_ISCSI;	/* 512 */
+
+/*
+ * ****************************************************************************
+ * EXT_DEST_ADDR_ISCSI
+ * ****************************************************************************
+ */
+typedef struct _EXT_DEST_ADDR_ISCSI {
+	UINT8	iSCSINameStr[EXT_DEF_ISCSI_NAME_LEN];	/* 256 */
+	UINT16	SessionID;				/* 2   */
+	UINT16	ConnectionID;				/* 2   */
+	UINT16	PortNumber;				/* 2   */
+	UINT16	Reserved[3];				/* 6   */
+} EXT_DEST_ADDR_ISCSI, *PEXT_DEST_ADDR_ISCSI;		/* 268 */
+
+/*
+ * ****************************************************************************
+ * EXT_DISC_ISCSI_PORTAL
+ * ****************************************************************************
+ */
+typedef struct _EXT_DISC_ISCSI_PORTAL {
+	EXT_ISCSI_IP_ADDR	IPAddr;			/* 20  */
+	UINT16	NodeCount;				/* 2   */
+	UINT8	HostName[EXT_DEF_MAX_STR_SIZE];		/* 128 */
+	UINT16	PortNumber;				/* 2   */
+	UINT16	Reserved;				/* 2   */
+} EXT_DISC_ISCSI_PORTAL, *PEXT_DISC_ISCSI_PORTAL;	/* 154 */
+
+/*
+ * ****************************************************************************
+ * EXT_DISC_ISCSI_NODE
+ * ****************************************************************************
+ */
+typedef struct _EXT_DISC_ISCSI_NODE {
+	UINT16	SessionID;				/* 2   */
+	UINT16	ConnectionID;				/* 2   */
+	UINT16	PortalGroupID;				/* 2   */
+	EXT_NODE_INFO_ISCSI	NodeInfo;		/* 320 */
+	EXT_SCSI_ADDR_ISCSI	ScsiAddr;		/* 16  */
+	UINT16	Reserved;				/* 2   */
+} EXT_DISC_ISCSI_NODE, *PEXT_DISC_ISCSI_NODE;		/* 344 */
+
+/*
+ * ****************************************************************************
+ * EXT_DNS
+ * ****************************************************************************
+ */
+typedef struct _EXT_DNS {
+	EXT_ISCSI_IP_ADDR	IPAddr;			/* 20  */
+	UINT8	Reserved[132];				/* 132 */
+} EXT_DNS, *PEXT_DNS;					/* 152 */
+
+/*
+ * ****************************************************************************
+ * EXT_DRIVER_INFO
+ * ****************************************************************************
+ */
+typedef struct _EXT_DRIVER_INFO {
+	UINT8	Version[EXT_DEF_MAX_STR_SIZE];		/* 128 */
+	UINT16	NumOfBus;				/* 2   */
+	UINT16	TargetsPerBus;				/* 2   */
+	UINT16	LunPerTarget;				/* 2   */
+	UINT16	LunPerTargetOS;				/* 2   */
+	UINT32	MaxTransferLen;				/* 4   */
+	UINT32	MaxDataSegments;			/* 4   */
+	UINT16	DmaBitAddresses;			/* 2   */
+	UINT16	IoMapType;				/* 2   */
+	UINT32	Attrib;					/* 4   */
+	UINT32	InternalFlags[4];			/* 16  */
+	UINT32	Reserved[8];				/* 32  */
+} EXT_DRIVER_INFO, *PEXT_DRIVER_INFO;			/* 200 */
+
+/*
+ * ****************************************************************************
+ * EXT_FW_INFO
+ * ****************************************************************************
+ */
+typedef struct _EXT_FW_INFO {
+	UINT8	Version[EXT_DEF_MAX_STR_SIZE];		/* 128 */
+	UINT32	Attrib;					/* 4   */
+	UINT32	Reserved[8];				/* 32  */
+} EXT_FW_INFO, *PEXT_FW_INFO;				/* 164 */
+
+/*
+ * ****************************************************************************
+ * EXT_HBA_ISCSI_NODE
+ * ****************************************************************************
+ */
+typedef struct _EXT_HBA_ISCSI_NODE {
+	UINT8	DeviceName[EXT_DEF_MAX_STR_SIZE];	/* 128 */
+	UINT16	PortNumber;				/* 2   */
+	EXT_NODE_INFO_ISCSI	NodeInfo;		/* 320 */
+	UINT16	Reserved;				/* 2   */
+} EXT_HBA_ISCSI_NODE, *PEXT_HBA_ISCSI_NODE;		/* 452 */
+
+/*
+ * ****************************************************************************
+ * EXT_HBA_ISCSI_PORTAL
+ * ****************************************************************************
+ */
+#define EXT_DEF_MAC_ADDR_SIZE			6
+
+/* State */
+#define EXT_DEF_CARD_STATE_READY		1
+#define EXT_DEF_CARD_STATE_CONFIG_WAIT		2
+#define EXT_DEF_CARD_STATE_LOGIN		3
+#define EXT_DEF_CARD_STATE_ERROR		4
+
+/* Type */
+#define EXT_DEF_TYPE_COPPER			1
+#define EXT_DEF_TYPE_OPTICAL			2
+
+#define EXT_DEF_SERIAL_NUM_SIZE			4
+
+typedef struct _EXT_HBA_ISCSI_PORTAL {
+	EXT_ISCSI_IP_ADDR IPAddr;			/* 20  */
+	UINT8	MacAddr[EXT_DEF_MAC_ADDR_SIZE];		/* 6   */
+	UINT8	Padding[2];				/* 2   */
+	UINT32	SerialNum;				/* 4   */
+	UINT8	Manufacturer[EXT_DEF_MAX_STR_SIZE];	/* 128 */
+	UINT8	Model[EXT_DEF_MAX_STR_SIZE];		/* 128 */
+	UINT8	DriverVersion[EXT_DEF_MAX_STR_SIZE];	/* 128 */
+	UINT8	FWVersion[EXT_DEF_MAX_STR_SIZE];	/* 128 */
+	UINT8	OptRomVersion[EXT_DEF_MAX_STR_SIZE];	/* 128 */
+	UINT16	State;					/* 2   */
+	UINT16	Type;					/* 2   */
+	UINT32	DriverAttr;				/* 4   */
+	UINT32	FWAttr;					/* 4   */
+	UINT16	DiscTargetCount;			/* 2   */
+	UINT32	Reserved;				/* 4   */
+} EXT_HBA_ISCSI_PORTAL, *PEXT_HBA_ISCSI_PORTAL;	/* 686 */
+
+/*
+ * ****************************************************************************
+ * EXT_HBA_PORT_STAT_GEN
+ * ****************************************************************************
+ */
+typedef struct _EXT_HBA_PORT_STAT_GEN {
+	UINT64	HBAPortErrorCount;			/* 8   */
+	UINT64	DevicePortErrorCount;			/* 8   */
+	UINT64	IoCount;				/* 8   */
+	UINT64	MBytesCount;				/* 8   */
+	UINT64	InterruptCount;				/* 8   */
+	UINT64	LinkFailureCount;			/* 8   */
+	UINT64	InvalidCrcCount;			/* 8   */
+	UINT32	Reserved[2];				/* 8   */
+} EXT_HBA_PORT_STAT_GEN, *PEXT_HBA_PORT_STAT_GEN;	/* 64  */
+
+/*
+ * ****************************************************************************
+ * EXT_HBA_PORT_STAT_ISCSI
+ * ****************************************************************************
+ */
+typedef struct _EXT_HBA_PORT_STAT_ISCSI {
+	UINT64	MACTxFramesCount;			/* 8   */
+	UINT64	MACTxBytesCount;			/* 8   */
+	UINT64	MACRxFramesCount;			/* 8   */
+	UINT64	MACRxBytesCount;			/* 8   */
+	UINT64	MACCRCErrorCount;			/* 8   */
+	UINT64	MACEncodingErrorCount;			/* 8   */
+	UINT64	IPTxPacketsCount;			/* 8   */
+	UINT64	IPTxBytesCount;				/* 8   */
+	UINT64	IPTxFragmentsCount;			/* 8   */
+	UINT64	IPRxPacketsCount;			/* 8   */
+	UINT64	IPRxBytesCount;				/* 8   */
+	UINT64	IPRxFragmentsCount;			/* 8   */
+	UINT64	IPDatagramReassemblyCount;		/* 8   */
+	UINT64	IPv6RxPacketsCount;			/* 8   */
+	UINT64	IPRxPacketErrorCount;			/* 8   */
+	UINT64	IPReassemblyErrorCount;			/* 8   */
+	UINT64	TCPTxSegmentsCount;			/* 8   */
+	UINT64	TCPTxBytesCount;			/* 8   */
+	UINT64	TCPRxSegmentsCount;			/* 8   */
+	UINT64	TCPRxBytesCount;			/* 8   */
+	UINT64	TCPTimerExpiredCount;			/* 8   */
+	UINT64	TCPRxACKCount;				/* 8   */
+	UINT64	TCPTxACKCount;				/* 8   */
+	UINT64	TCPRxErrorSegmentCount;			/* 8   */
+	UINT64	TCPWindowProbeUpdateCount;		/* 8   */
+	UINT64	iSCSITxPDUCount;			/* 8   */
+	UINT64	iSCSITxBytesCount;			/* 8   */
+	UINT64	iSCSIRxPDUCount;			/* 8   */
+	UINT64	iSCSIRxBytesCount;			/* 8   */
+	UINT64	iSCSICompleteIOsCount;			/* 8   */
+	UINT64	iSCSIUnexpectedIORxCount;		/* 8   */
+	UINT64	iSCSIFormatErrorCount;			/* 8   */
+	UINT64	iSCSIHeaderDigestCount;			/* 8   */
+	UINT64	iSCSIDataDigestErrorCount;		/* 8   */
+	UINT64	iSCSISeqErrorCount;			/* 8   */
+	UINT32	Reserved[2];				/* 8   */
+} EXT_HBA_PORT_STAT_ISCSI, *PEXT_HBA_PORT_STAT_ISCSI;	/* 272 */
+
+/*
+ * ****************************************************************************
+ * EXT_HBA_PORT_STAT_ISCSI_BLOCK
+ * ****************************************************************************
+ */
+typedef struct _EXT_HBA_PORT_STAT_ISCSI_BLOCK {
+	UINT8	DataBlock[4096];				
+} EXT_HBA_PORT_STAT_ISCSI_BLOCK, *PEXT_HBA_PORT_STAT_ISCSI_BLOCK;  /* 4096 */
+
+/*
+ * ****************************************************************************
+ * EXT_INIT_FW_ISCSI
+ * ****************************************************************************
+ */
+#define EXT_DEF_FW_MARKER_DISABLE		0x0400
+#define EXT_DEF_FW_ACCESS_CONTROL_ENABLE	0x0080
+#define EXT_DEF_FW_SESSION_MODE_ENABLE		0x0040
+#define EXT_DEF_FW_INITIATOR_MODE_ENABLE	0x0020
+#define EXT_DEF_FW_TARGET_MODE_ENABLE		0x0010
+#define EXT_DEF_FW_FAST_STATUS_ENABLE		0x0008
+#define EXT_DEF_FW_DMA_INT_ENABLE		0x0004
+#define EXT_DEF_FW_SENSE_BUFF_DESC_ENABLE	0x0002
+
+typedef struct _EXT_INIT_FW_ISCSI {
+	UINT8	Reserved1;				/* 1   */
+	UINT8	Version;				/* 1   */
+	UINT16	FWOptions;				/* 2   */
+	UINT16	AddFWOptions;				/* 2   */
+	UINT16	WakeupThreshold;			/* 2   */
+	EXT_ISCSI_IP_ADDR	IPAddr;			/* 20  */
+	EXT_ISCSI_IP_ADDR	SubnetMask;		/* 20  */
+	EXT_ISCSI_IP_ADDR	Gateway;		/* 20  */
+	EXT_DNS	DNSConfig;				/* 152 */
+	UINT8	Alias[EXT_DEF_ISCSI_ALIAS_LEN];		/* 32  */
+	UINT8	iSCSIName[EXT_DEF_ISCSI_NAME_LEN];	/* 256 */
+	EXT_ISCSI_DEVICE	DeviceInfo;		/* 64  */
+	UINT8	Reserved[4];				/* 4   */
+} EXT_INIT_FW_ISCSI , *PEXT_INIT_FW_ISCSI;		/* 576 */
+
+/*
+ * ****************************************************************************
+ * EXT_ISCSI_PASSTHRU
+ * ****************************************************************************
+ */
+#define EXT_DEF_ISCSI_PASSTHRU_PDU_LENGTH	64
+
+#define EXT_DEF_ISCSI_PASSTHRU_DATA_IN		1
+#define EXT_DEF_ISCSI_PASSTHRU_DATA_OUT	2
+
+typedef struct _EXT_ISCSI_PASSTHRU {
+	EXT_DEST_ADDR_ISCSI Addr;			/* 268 */
+	UINT16	Direction;				/* 2   */
+	UINT32	PduInLength;				/* 4   */
+	UINT8	PduIn[EXT_DEF_ISCSI_PASSTHRU_PDU_LENGTH];	/* 64  */
+	UINT32	PduOutLength;				/* 4   */
+	UINT8	PduOut[EXT_DEF_ISCSI_PASSTHRU_PDU_LENGTH];	/* 64  */
+	UINT32	Flags;					/* 4   */
+	UINT32	Reserved;				/* 4   */
+} EXT_ISCSI_PASSTHRU, *PEXT_ISCSI_PASSTHRU;		/* 282 */
+
+/*
+ * ****************************************************************************
+ * EXT_SCSI_PASSTHRU_ISCSI
+ * ****************************************************************************
+ */
+#define EXT_DEF_SCSI_PASSTHRU_CDB_LENGTH	16
+
+#define EXT_DEF_SCSI_PASSTHRU_DATA_IN		1
+#define EXT_DEF_SCSI_PASSTHRU_DATA_OUT		2
+
+#define EXT_DEF_SCSI_SENSE_DATA_SIZE		256
+
+typedef struct _EXT_SCSI_PASSTHRU_ISCSI {
+	EXT_SCSI_ADDR_ISCSI Addr;			/* 16  */
+	UINT8	Direction;				/* 1   */
+	UINT8	CdbLength;				/* 1   */
+	UINT8	Cdb[EXT_DEF_SCSI_PASSTHRU_CDB_LENGTH];	/* 16  */
+	UINT8	Reserved[16];				/* 16  */
+	UINT8	SenseData[EXT_DEF_SCSI_SENSE_DATA_SIZE];/* 256 */
+} EXT_SCSI_PASSTHRU_ISCSI, *PEXT_SCSI_PASSTHRU_ISCSI;	/* 306 */
+
+
+/*
+ * ****************************************************************************
+ * EXT_ISNS_SERVER
+ * ****************************************************************************
+ */
+
+#define EXT_DEF_ISNS_WELL_KNOWN_PORT		3205
+
+typedef struct _EXT_ISNS_SERVER {
+	UINT8	PerformiSNSDiscovery;			/* 1 */
+	UINT8	AutomaticiSNSDiscovery;			/* 1 */	
+	UINT8	iSNSNotSupported;			/* 1 */
+	UINT8	Reserved1[1];				/* 1 */
+	EXT_ISCSI_IP_ADDR	IPAddr;			/* 20 */
+	UINT16	PortNumber;				/* 2 */
+	UINT16	Reserved2;				/* 2 */
+	UINT8	InitiatorName[EXT_DEF_ISCSI_NAME_LEN];	/* 256 */		
+	UINT32	Reserved3;				/* 4   */
+} EXT_ISNS_SERVER, *PEXT_ISNS_SERVER;			/* 288 */
+
+/*
+ * ****************************************************************************
+ * EXT_ISNS_DISCOVERED_TARGET_PORTAL
+ * ****************************************************************************
+ */
+
+typedef struct _EXT_ISNS_DISCOVERED_TARGET_PORTAL
+{
+	EXT_ISCSI_IP_ADDR	IPAddr;			/* 20 */
+	UINT16	PortNumber;				/* 2 */
+	UINT16	Reserved;				/* 2 */
+} EXT_ISNS_DISCOVERED_TARGET_PORTAL, *PEXT_ISNS_DISCOVERED_TARGET_PORTAL;
+							/* 24 */
+
+/*
+ * ****************************************************************************
+ * EXT_ISNS_DISCOVERED_TARGET
+ * ****************************************************************************
+ */
+
+#define EXT_DEF_ISNS_MAX_PORTALS		4
+
+typedef struct _EXT_ISNS_DISCOVERED_TARGET
+{
+	UINT32	NumPortals;				/* 4 */
+	EXT_ISNS_DISCOVERED_TARGET_PORTAL Portal[EXT_DEF_ISNS_MAX_PORTALS];	/* 96 */
+	UINT32	DDID;					/* 4 */
+	UINT8	NameString[EXT_DEF_ISCSI_NAME_LEN];	/* 256 */
+	UINT8	Alias[EXT_DEF_ISCSI_ALIAS_LEN];		/* 32 */
+} EXT_ISNS_DISCOVERED_TARGET, *PEXT_ISNS_DISCOVERED_TARGET;	/* 392 */
+
+/*
+ * ****************************************************************************
+ * EXT_ISNS_DISCOVERED_TARGETS
+ * ****************************************************************************
+ */
+
+#define EXT_DEF_NUM_ISNS_DISCOVERED_TARGETS	32
+
+typedef struct _EXT_ISNS_DISCOVERED_TARGETS
+{
+	UINT32  iSNSDiscoveredTargetIndexStart;		/* 4 */
+	UINT32	NumiSNSDiscoveredTargets;		/* 4 */
+	EXT_ISNS_DISCOVERED_TARGET
+		iSNSDiscoveredTargets[EXT_DEF_NUM_ISNS_DISCOVERED_TARGETS];
+							/* 12544 */	
+} EXT_ISNS_DISCOVERED_TARGETS, *PEXT_ISNS_DISCOVERED_TARGETS;
+							/* 12548 */
+
+
+/*
+ * ****************************************************************************
+ * ACB Defines
+ * ****************************************************************************
+ */
+
+#define EXT_DEF_ACB_SIZE				0x300
+
+typedef struct _EXT_ACB
+{
+	UINT8 Buffer[EXT_DEF_ACB_SIZE];			
+} EXT_ACB, *PEXT_ACB;                                   /* 0x300 */
+		
+/* Specifies which ACB for all ACB IOCTLs*/
+#define EXT_DEF_ACB_PRIMARY				0
+#define EXT_DEF_ACB_SECONDARY	 			1
+
+/* Specifies Command Option for EXT_CC_DISABLE IOCTL */
+#define EXT_DEF_ACB_CMD_OPTION_NOT_FORCED		0x0000
+#define EXT_DEF_ACB_CMD_OPTION_FORCED			0x0001
+
+/* Specifies Parameter Error for EXT_CC_SET_DATA|EXT_SC_SET_ACB IOCTL */
+#define EXT_DEF_ACB_PARAM_ERR_INVALID_VALUE		0x0001
+#define EXT_DEF_ACB_PARAM_ERR_INVALID_SIZE		0x0002
+#define EXT_DEF_ACB_PARAM_ERR_INVALID_ADDR		0x0003
+
+/* Specifies the type of InitFW for the get defaults */
+#define EXT_DEF_VERSION_1						0x0000
+#define EXT_DEF_VERSION_2						0x0001
+
+
+/*
+ * ****************************************************************************
+ * QUERY_IP_STATE Defines
+ * ****************************************************************************
+ */
+
+typedef struct _EXT_QUERY_IP_STATE
+{
+	UINT8  	IP_ACBState[4];				/* 4 */
+	UINT32 	ValidLifetime;                          /* 4 */
+	UINT32 	PreferredLifetime;                      /* 4 */
+	UINT8  	IPAddressInfo1[4];                      /* 4 */
+	UINT8	IPAddressInfo2[4];                      /* 4 */
+	UINT8	IPAddressInfo3[4];                      /* 4 */
+	UINT8	IPAddressInfo4[4];                      /* 4 */
+	UINT8	Reserved[4];                            /* 4 */
+} EXT_QUERY_IP_STATE, *PEXT_QUERY_IP_STATE;
+
+
+/*
+ * ****************************************************************************
+ * NEIGHBOR_CACHE Defines
+ * ****************************************************************************
+ */
+typedef struct _EXT_NEIGHBOR_CACHE {
+	UINT32	CacheBufferSize;                        /* 4 */
+	UINT8	Reserved[4];                            /* 4 */
+	UINT8	Buffer[0];
+} EXT_NEIGHBOR_CACHE, *PEXT_NEIGHBOR_CACHE;
+
+#define EXT_DEF_IPv6INFO_ALL_ENTRIES			0xFFFFFFFF
+#define EXT_DEF_NEIGHBOR_CACHE_SIZE			0x28 /* 40 decimal */
+
+/*
+ * ****************************************************************************
+ * DESTINATION_CACHE Defines
+ * ****************************************************************************
+ */
+typedef struct _EXT_DESTINATION_CACHE {
+	UINT32	CacheBufferSize;                        /* 4 */
+	UINT8	Reserved[4];                            /* 4 */
+	UINT8	Buffer[0];
+} EXT_DESTINATION_CACHE, *PEXT_DESTINATION_CACHE;
+
+#define EXT_DEF_DESTINATION_CACHE_SIZE			0x38 /* 56 decimal */
+
+/*
+ * ****************************************************************************
+ * ROUTER_LIST Defines
+ * ****************************************************************************
+ */
+typedef struct _EXT_ROUTER_LIST {
+	UINT32	CacheBufferSize;                        /* 4 */
+	UINT8	Reserved[4];                            /* 4 */
+	UINT8	Buffer[0];
+} EXT_ROUTER_LIST, *PEXT_ROUTER_LIST;
+
+#define EXT_DEF_ROUTER_LISTE_SIZE			0x28 /* 40 decimal */
+
+/*
+ * ****************************************************************************
+ * PREFIX_LIST Defines
+ * ****************************************************************************
+ */
+typedef struct _EXT_PREFIX_LIST {
+	UINT32	CacheBufferSize;                        /* 4 */
+	UINT8	Reserved[4];                            /* 4 */
+	UINT8	Buffer[0];
+} EXT_PREFIX_LIST, *PEXT_PREFIX_LIST;
+
+#define EXT_DEF_PREFIX_LIST_SIZE			0x20
+
+/*
+ * ****************************************************************************
+ * SEND_ROUTER_SOL Defines
+ * ****************************************************************************
+ */
+typedef struct _EXT_SEND_ROUTER_SOL {
+	EXT_ISCSI_IP_ADDR	Addr;                   /* 20 */
+	UINT32			Flags;                  /* 4  */
+	UINT8			Reserved[8];            /* 8  */
+} EXT_SEND_ROUTER_SOL, *PEXT_SEND_ROUTER_SOL;
+
+#define EXT_DEF_SOURCE_NOT_AVAIL			0x0001
+#define EXT_DEF_ADDRESS_NOT_RESOLVED			0x0002
+#define EXT_DEF_NCB_FAIL				0x0003
+#define EXT_DEF_TIMEOUT					0x0004
+#define EXT_DEF_IPV6_DISABLED				0x0005
+#define EXT_DEF_EVENT_ERROR				0x0006
+
+/*
+ * ****************************************************************************
+ * QUERY_DEVICE_CURRENT_IP Defines
+ * ****************************************************************************
+ */
+
+typedef struct _EXT_QUERY_DEVICE_CURRENT_IP {
+	EXT_ISCSI_IP_ADDR	Addr;		/* 20 */
+	UINT32			DeviceState;	/* 4  */
+	UINT16			TCPPort; 	/* 2  */
+	UINT8			Flags[2];	/* 2  */
+	UINT8			Reserved[4];	/* 4  */
+} EXT_QUERY_DEVICE_CURRENT_IP, *PEXT_QUERY_DEVICE_CURRENT_IP;	/* 32 */
+
+#endif /* _QLISIOCT_H */
diff -r 6a4846854257 drivers/scsi/qla4xxx/qlisioln.h
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/drivers/scsi/qla4xxx/qlisioln.h	Mon Jan 11 11:15:25 2010 +0000
@@ -0,0 +1,240 @@
+/*
+ * QLogic iSCSI HBA Driver
+ * Copyright (c)  2003-2006 QLogic Corporation
+ *
+ * See LICENSE.qla4xxx for copyright and licensing details.
+ */
+
+#ifndef _QLISIOLN_H_
+#define _QLISIOLN_H_
+
+#include <linux/ioctl.h>
+
+#ifdef APILIB
+#include <stdint.h>
+#include <linux/types.h>
+#endif
+
+#ifndef INT8
+#define	INT8	int8_t
+#endif
+#ifndef INT16
+#define	INT16	int16_t
+#endif
+#ifndef INT32
+#define	INT32	int32_t
+#endif
+#ifndef UINT8
+#define	UINT8	uint8_t
+#endif
+#ifndef UINT16
+#define	UINT16	uint16_t
+#endif
+#ifndef UINT32
+#define	UINT32	uint32_t
+#endif
+
+#ifndef UINT64
+#define UINT64  unsigned long long
+#endif
+
+#ifndef BOOLEAN
+#define BOOLEAN uint8_t
+#endif
+
+
+#if BITS_PER_LONG <= 32
+#define EXT_ADDR_MODE_OS  EXT_DEF_ADDR_MODE_32
+#else
+#define EXT_ADDR_MODE_OS  EXT_DEF_ADDR_MODE_64
+#endif
+
+
+#define QLMULTIPATH_MAGIC 'z'
+
+#define _QLBUILD   /* for qlisioct.h to enable include of qinsdmgt.h */
+
+
+
+/* max index values */
+#define	EXT_DEF_MAX_HBA_OS		63	/* 0 - 0x3F */
+#define EXT_DEF_MAX_HBAS		64
+
+#define	EXT_DEF_MAX_BUS_OS		1
+
+#define	EXT_DEF_MAX_TARGET_OS		255	/* 0 - 0xFF */
+#define EXT_DEF_MAX_TARGETS		256
+
+#define	EXT_DEF_MAX_LUN_OS		255	/* 0 - 0xFF */
+#define EXT_DEF_MAX_LUNS		256
+
+#define EXT_DEF_MAX_AEN_QUEUE_OS        256
+
+#define EXT_DEF_USE_HBASELECT		0x02	/* bit 1: HbaSelect field is
+						 * used to specify destination
+						 * HBA of each command.
+						 * SetInstance cmd is now
+						 * issued only once during
+						 * API initialization.
+						 */
+
+
+#define EXT_DEF_REGULAR_SIGNATURE	"QLOGIC"
+
+
+/*************************************************************/
+/*                       Command codes                       */
+/*-----------------------------------------------------------*/
+/* Correctly defined to work on both 32bit and 64bit kernels */
+/*************************************************************/
+#define	QL_IOCTL_BASE(idx)	\
+    _IOWR(QLMULTIPATH_MAGIC, idx, EXT_IOCTL_ISCSI)
+
+#define	QL_IOCTL_CMD(idx)	QL_IOCTL_BASE(idx)
+
+
+/***********************************
+ * These are regular command codes
+ * idx range from 0x00 to 0x2f
+ ***********************************/
+#define EXT_DEF_REG_CC_START_IDX	0x00
+
+#define EXT_CC_QUERY_OS				/* QUERY */	\
+    QL_IOCTL_CMD(0x00)
+	
+#define EXT_CC_REG_AEN_OS			/* REG_AEN */ \
+    QL_IOCTL_CMD(0x01)
+
+#define EXT_CC_GET_AEN_OS			/* GET_AEN */ \
+    QL_IOCTL_CMD(0x02)
+
+#define EXT_CC_GET_DATA_OS			/* GET_DATA */ \
+    QL_IOCTL_CMD(0x03)
+
+#define EXT_CC_SET_DATA_OS			/* SET_DATA */ \
+    QL_IOCTL_CMD(0x04)
+	
+#define EXT_CC_SEND_SCSI_PASSTHRU_OS		/* SCSI_PASSTHRU */ \
+    QL_IOCTL_CMD(0x05)
+
+#define EXT_CC_SEND_ISCSI_PASSTHRU_OS		/* ISCSI_PASSTHRU */ \
+    QL_IOCTL_CMD(0x06)
+
+#define EXT_CC_DISABLE_ACB_OS			/* DISABLE_ACB */ \
+    QL_IOCTL_CMD(0x07)
+
+#define EXT_CC_SEND_ROUTER_SOL_OS		/* SEND_ROUTER_SOL */ \
+    QL_IOCTL_CMD(0x08)
+
+#define EXT_DEF_REG_CC_END_IDX		0x08
+
+/***********************************
+ * Internal command codes
+ * idx range from 0x10 to 0x2f
+ ***********************************/
+#define EXT_DEF_INT_CC_START_IDX	0x10
+
+#define EXT_CC_RESERVED0A_OS					\
+    QL_IOCTL_CMD(0x10)
+#define EXT_CC_RESERVED0B_OS					\
+    QL_IOCTL_CMD(0x11)
+#define EXT_CC_RESERVED0C_OS					\
+    QL_IOCTL_CMD(0x12)
+#define EXT_CC_RESERVED0D_OS					\
+    QL_IOCTL_CMD(0x13)
+#define EXT_CC_RESERVED0E_OS					\
+    QL_IOCTL_CMD(0x14)
+#define EXT_CC_RESERVED0F_OS					\
+    QL_IOCTL_CMD(0x15)
+#define EXT_CC_RESERVED0G_OS					\
+    QL_IOCTL_CMD(0x16)
+#define EXT_CC_RESERVED0H_OS					\
+    QL_IOCTL_CMD(0x17)
+#define EXT_CC_RESERVED0I_OS					\
+    QL_IOCTL_CMD(0x18)
+#define EXT_CC_RESERVED0J_OS					\
+    QL_IOCTL_CMD(0x19)
+
+#define EXT_DEF_INT_CC_END_IDX		0x19
+
+/***********************************
+ * NextGen Failover ioctl command
+ * codes range from 0x37 to 0x4f.
+ * See qlnfoln.h
+ ***********************************/
+
+/***********************************
+ * These are a Linux driver specific
+ * commands.
+ * idx range from highest value 0xff
+ * and in decreasing order.
+ ***********************************/
+#define EXT_DEF_DRV_SPC_CC_START_IDX	0xff
+
+#define EXT_CC_GET_HBACNT			/* GET_HBACNT */ \
+    QL_IOCTL_CMD(0xff)
+
+#define EXT_CC_GET_HOST_NO			/* SET_INSTANCE */ \
+    QL_IOCTL_CMD(0xfe)
+
+#define EXT_CC_DRIVER_SPECIFIC			/* DRIVER_SPECIFIC */ \
+    QL_IOCTL_CMD(0xfc)
+
+
+#define EXT_CC_GET_PORT_DEVICE_NAME	QL_IOCTL_CMD(0xfb)
+
+#define EXT_DEF_DRV_SPC_CC_END_IDX	0xfb
+
+/******************************/
+/* Response struct definition */
+/******************************/
+
+/*
+ * HBA Count
+ */
+typedef struct _EXT_HBA_COUNT {
+	UINT16	HbaCnt;				/* 2 */
+} EXT_HBA_COUNT, *PEXT_HBA_COUNT;		/* 2 */
+
+/*
+ * Driver Specific
+ */
+typedef struct _EXT_LN_DRV_VERSION {
+	UINT8   Major;
+	UINT8   Minor;
+	UINT8   Patch;
+	UINT8   Beta;
+	UINT8   Reserved[4];
+} EXT_LN_DRV_VERSION;				/* 8 */
+
+/*
+ * Get Port Device Name (VMWare Specific)
+ */
+typedef struct _EXT_GET_PORT_DEVICE_NAME {
+	UINT8	deviceName[32];
+	UINT8   reserved[32];
+} EXT_GET_PORT_DEVICE_NAME;
+
+typedef struct _EXT_LN_DRIVER_DATA {
+	EXT_LN_DRV_VERSION	DrvVer;		/* 8 */
+	UINT32	Flags;				/* 4 */
+	UINT32	AdapterModel;			/* 4 */
+	UINT32	Reserved[12];			/* 48 */
+} EXT_LN_DRIVER_DATA, *PEXT_LN_DRIVER_DATA;	/* 64 */
+
+/* Bit defines for the Flags field */
+#define EXT_DEF_NGFO_CAPABLE		0x0001	/* bit 0 */
+
+/* Bit defines for the AdapterModel field */
+/* bit 0 to bit 7 are used by FC driver. when adding new bit
+ * definitions they must be unique among all supported drivers
+ */
+#define EXT_DEF_QLA4010_DRIVER		0x0100	/* bit 8 */
+#define EXT_DEF_QLA4022_DRIVER		0x0200	/* bit 9 */
+
+#define EXT_DEF_QLA4XXX_DRIVER				\
+    (EXT_DEF_QLA4010_DRIVER | EXT_DEF_QLA4022_DRIVER)
+
+
+
+#endif //_QLISIOLN_H_
