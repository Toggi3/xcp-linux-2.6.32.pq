diff -r 5b3d4d3c1166 drivers/net/sfc/Kconfig
--- a/drivers/net/sfc/Kconfig	Fri Nov 05 15:20:28 2010 +0000
+++ b/drivers/net/sfc/Kconfig	Tue Nov 09 10:06:26 2010 +0000
@@ -1,5 +1,5 @@ config SFC
 config SFC
-	tristate "Solarflare Solarstorm SFC4000 support"
+	tristate "Solarflare Solarstorm SFC4000/SFC9000-family support"
 	depends on PCI && INET
 	select MDIO
 	select CRC32
@@ -7,26 +7,24 @@ config SFC
 	select I2C_ALGOBIT
 	help
 	  This driver supports 10-gigabit Ethernet cards based on
-	  the Solarflare Communications Solarstorm SFC4000 controller.
+	  the Solarflare Communications Solarstorm SFC4000 and
+	  SFC9000-family controllers.
 
 	  To compile this driver as a module, choose M here.  The module
 	  will be called sfc.
-
-config SFC_DRIVERLINK
-	bool
-
-config SFC_RESOURCE
-	depends on SFC && X86
-	select SFC_DRIVERLINK
-	tristate "Solarflare Solarstorm SFC4000 resource driver"
-	help
-	  This module provides the SFC resource manager driver.
-
 config SFC_MTD
-	bool "Solarflare Solarstorm SFC4000 flash MTD support"
+	bool "Solarflare Solarstorm SFC4000/SFC9000-family MTD support"
 	depends on SFC && MTD && !(SFC=y && MTD=m)
 	default y
 	help
-	  This exposes the on-board flash memory as an MTD device (e.g.
-          /dev/mtd1).  This makes it possible to upload new boot code
-          to the NIC.
+	  This exposes the on-board flash and/or EEPROM memory as MTD
+	  devices (e.g. /dev/mtd1).  This makes it possible to upload
+	  new boot code to the NIC.
+config SFC_SRIOV
+       bool "Solarflare Solarstorm SFC9000-family SR-IOV support"
+       depends on SFC && PCI_IOV
+       default y
+       help
+          This enables support for the SFC9000 I/O Virtualization
+	  features, allowing accelerated network performance in
+	  virtualized environments.
diff -r 5b3d4d3c1166 drivers/net/sfc/Makefile
--- a/drivers/net/sfc/Makefile	Fri Nov 05 15:20:28 2010 +0000
+++ b/drivers/net/sfc/Makefile	Tue Nov 09 10:06:26 2010 +0000
@@ -1,9 +1,11 @@ sfc-y			+= efx.o falcon.o tx.o rx.o falc
-sfc-y			+= efx.o falcon.o tx.o rx.o falcon_gmac.o \
-			   falcon_xmac.o selftest.o ethtool.o xfp_phy.o \
-			   mdio_10g.o tenxpress.o boards.o sfe4001.o
-sfc-$(CONFIG_SFC_DRIVERLINK) += driverlink.o
+sfc-y			+= efx.o nic.o falcon.o siena.o tx.o rx.o filter.o \
+			   falcon_xmac.o mcdi_mac.o selftest.o \
+			   driverlink.o ethtool.o qt202x_phy.o mdio_10g.o \
+			   tenxpress.o txc43128_phy.o falcon_boards.o mcdi.o \
+			   mcdi_phy.o ioctl.o kernel_compat.o linux_mdio.o
 sfc-$(CONFIG_SFC_MTD)	+= mtd.o
+sfc-$(CONFIG_SFC_SRIOV)	+= sriov.o
 
 obj-$(CONFIG_SFC)	+= sfc.o
 
-obj-$(CONFIG_SFC_RESOURCE) += sfc_resource/
+EXTRA_CFLAGS += -Wno-unused-label -Wno-deprecated-declarations -DEFX_USE_KCOMPAT=1 -DEFX_NOT_UPSTREAM=1
diff -r 5b3d4d3c1166 drivers/net/sfc/autocompat.h
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/drivers/net/sfc/autocompat.h	Tue Nov 09 10:06:26 2010 +0000
@@ -0,0 +1,134 @@
+// #define EFX_HAVE_OLD_NAPI
+// #define EFX_HAVE_OLD_CSUM
+// #define EFX_HAVE_OLD_IP_FAST_CSUM
+// #define EFX_NEED_BYTEORDER_TYPES
+// #define EFX_NEED_CSUM_UNFOLDED
+// #define EFX_NEED_CSUM_TCPUDP_NOFOLD
+// #define EFX_NEED_DEV_NOTICE
+// #define EFX_NEED_DUMMY_PCI_DISABLE_MSI
+// #define EFX_NEED_DUMMY_MSIX
+// #define EFX_NEED_ENABLE_MSIX
+#define EFX_HAVE_GRO yes
+// #define EFX_NEED_GFP_T
+// #define EFX_NEED_HEX_DUMP
+// #define EFX_NEED_HEX_DUMP_CONST_FIX
+// #define EFX_NEED_IF_MII
+// #define EFX_HAVE_IRQ_HANDLER_REGS
+// #define EFX_NEED_IRQ_HANDLER_T
+// #define EFX_NEED_KCALLOC
+// #define EFX_NEED_KZALLOC
+// #define EFX_NEED_MII_CONSTANTS
+// #define EFX_NEED_MII_ADVERTISE_FLOWCTRL
+// #define EFX_NEED_MII_RESOLVE_FLOWCTRL_FDX
+#define EFX_HAVE_LINUX_MDIO_H yes
+// #define EFX_NEED_MSECS_TO_JIFFIES
+// #define EFX_NEED_MDELAY
+// #define EFX_NEED_MSLEEP
+// #define EFX_NEED_SSLEEP
+// #define EFX_NEED_MTD_ERASE_CALLBACK
+// #define EFX_NEED_MUTEX
+// #define EFX_NEED_NETDEV_ALLOC_SKB
+// #define EFX_NEED_NETDEV_TX_T
+// #define EFX_NEED_NETIF_NAPI_DEL
+// #define EFX_NEED_NETIF_TX_LOCK
+// #define EFX_NEED_NETIF_ADDR_LOCK
+#define EFX_HAVE_ALLOC_ETHERDEV_MQ yes
+#define EFX_USE_TX_MQ yes
+#define EFX_NEED_NETIF_SET_REAL_NUM_TX_QUEUES yes
+#define EFX_NEED_NETIF_SET_REAL_NUM_RX_QUEUES yes
+// #define EFX_NEED_PCI_CLEAR_MASTER
+// #define EFX_NEED_PCI_MATCH_ID
+// #define EFX_NEED_PCI_SAVE_RESTORE_WRAPPERS
+// #define EFX_NEED_PRINT_MAC
+// #define EFX_NEED_RANDOM_ETHER_ADDR
+// #define EFX_NEED_RESOURCE_SIZE_T
+// #define EFX_NEED_RTNL_TRYLOCK
+#define EFX_HAVE_ROUND_JIFFIES_UP yes
+// #define EFX_NEED_SAFE_LISTS
+// #define EFX_NEED_SCHEDULE_TIMEOUT_INTERRUPTIBLE
+// #define EFX_NEED_SCHEDULE_TIMEOUT_UNINTERRUPTIBLE
+// #define EFX_NEED_SETUP_TIMER
+// #define EFX_NEED_SKB_HEADER_MACROS
+// #define EFX_NEED_ETH_HDR
+// #define EFX_NEED_VLAN_ETH_HDR
+// #define EFX_NEED_TCP_HDR
+// #define EFX_NEED_IP_HDR
+// #define EFX_NEED_IPV6_HDR
+// #define EFX_NEED_WORK_API_WRAPPERS
+#define EFX_USE_CANCEL_DELAYED_WORK_SYNC yes
+#define EFX_USE_CANCEL_WORK_SYNC yes
+#define EFX_USE_ETHTOOL_ETH_TP_MDIX yes
+// #define EFX_USE_ETHTOOL_GET_PERM_ADDR
+#define EFX_USE_ETHTOOL_FLAGS yes
+#define EFX_USE_ETHTOOL_LP_ADVERTISING yes
+#define EFX_USE_ETHTOOL_MDIO_SUPPORT yes
+#define EFX_USE_LINUX_IO_H yes
+#define EFX_USE_LINUX_UACCESS_H yes
+#define EFX_USE_MTD_ERASE_FAIL_ADDR yes
+#define EFX_USE_MTD_WRITESIZE yes
+#define EFX_USE_NETDEV_DEV yes
+#define EFX_USE_NETDEV_DEV_ID yes
+#define EFX_USE_NETDEV_STATS yes
+// #define EFX_USE_NETDEV_STATS64
+#define EFX_USE_PCI_DEV_REVISION yes
+#define EFX_USE_NETDEV_VLAN_FEATURES yes
+#define EFX_USE_DEV_MC_LIST yes
+// #define EFX_USE_I2C_LEGACY
+// #define EFX_NEED_I2C_NEW_DUMMY
+// #define EFX_HAVE_OLD_I2C_DRIVER_PROBE
+// #define EFX_HAVE_OLD_I2C_NEW_DUMMY
+// #define EFX_USE_I2C_DRIVER_NAME
+#define EFX_HAVE_HWMON_H yes
+// #define EFX_NEED_HWMON_VID
+// #define EFX_HAVE_I2C_SENSOR_H
+// #define EFX_HAVE_HWMON_CLASS_DEVICE
+// #define EFX_HAVE_OLD_DEVICE_ATTRIBUTE
+// #define EFX_NEED_BOOL
+#define EFX_USE_ETHTOOL_GET_SSET_COUNT yes
+// #define EFX_HAVE_ETHTOOL_RESET
+// #define EFX_NEED_I2C_LOCK_ADAPTER
+// #define EFX_USE_I2C_BUS_SEMAPHORE
+// #define EFX_HAVE_OLD_PCI_DMA_MAPPING_ERROR
+#define EFX_HAVE_LINUX_SEMAPHORE_H yes
+// #define EFX_NEED_DEV_GET_STATS
+// #define EFX_HAVE_OLD_CPUMASK_SCNPRINTF
+// #define EFX_NEED_NEW_CPUMASK_API
+// #define EFX_NEED_ZALLOC_CPUMASK_VAR
+#define EFX_USE_PM yes
+// #define EFX_USE_PM_EXT_OPS
+#define EFX_USE_DEV_PM_OPS yes
+// #define EFX_NEED_ATOMIC_CMPXCHG
+// #define EFX_NEED_WARN_ON
+// #define EFX_NEED_WAIT_EVENT_TIMEOUT
+// #define EFX_NEED_ETHTOOL_CONSTANTS
+// #define EFX_NEED_PCI_WAKE_FROM_D3
+#define EFX_HAVE_DEV_DISABLE_LRO yes
+// #define EFX_NEED_UNMASK_MSIX_VECTORS
+#define EFX_HAVE_PM_IDLE yes
+#define EFX_HAVE_SKB_RECORD_RX_QUEUE yes
+// #define EFX_HAVE_XEN_XEN_H yes
+#define EFX_HAVE_XEN_START_INFO yes
+#define EFX_HAVE_CPUMASK_OF_NODE yes
+// #define EFX_HAVE_TOPOLOGY_CPU_NODE_CPUMASK
+// #define EFX_HAVE_LLC_SHARED_MAP
+// #define EFX_HAVE_LLC_SHARED_MAP_VAR yes
+// #define EFX_HAVE_EXPORTED_CPU_DATA
+// #define EFX_NEED_SET_CPUS_ALLOWED_PTR
+// #define EFX_HAVE_GENERATED_AUTOCONF_H
+// #define EFX_NEED_ON_EACH_CPU_WRAPPER
+#define EFX_HAVE_EXPORTED_CPU_SIBLING_MAP yes
+#define EFX_HAVE_ROUNDDOWN_POW_OF_TWO yes
+#define EFX_HAVE_ROUNDUP_POW_OF_TWO yes
+#define EFX_HAVE_SRIOV yes
+#define EFX_HAVE_NDO_SET_VF_MAC yes
+// #define EFX_NEED_IS_ZERO_ETHER_ADDR
+// #define EFX_NEED_IS_BROADCAST_ETHER_ADDR
+// #define EFX_NEED_FOR_EACH_PCI_DEV
+// #define EFX_NEED_SCSI_SGLIST
+// #define EFX_NEED_SG_NEXT
+// #define EFX_HAVE_NEW_KFIFO
+// #define EFX_NEED_VMALLOC_NODE
+// #define EFX_NEED_VMALLOC_TO_PFN
+// #define EFX_NEED_KVEC
+// #define EFX_NEED_KERNEL_SENDMSG
+// #define EFX_HAVE_GENERATED_UTSRELEASE_H
diff -r 5b3d4d3c1166 drivers/net/sfc/bitfield.h
--- a/drivers/net/sfc/bitfield.h	Fri Nov 05 15:20:28 2010 +0000
+++ b/drivers/net/sfc/bitfield.h	Tue Nov 09 10:06:26 2010 +0000
@@ -1,7 +1,7 @@
 /****************************************************************************
  * Driver for Solarflare Solarstorm network controllers and boards
  * Copyright 2005-2006 Fen Systems Ltd.
- * Copyright 2006-2008 Solarflare Communications Inc.
+ * Copyright 2006-2009 Solarflare Communications Inc.
  *
  * This program is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 as published
@@ -25,6 +25,16 @@
  * we define our datatypes (efx_oword_t, efx_qword_t and
  * efx_dword_t) to be little-endian.
  */
+#ifdef EFX_NOT_UPSTREAM
+/*
+ * In the less common case of using PIO for individual register
+ * writes, we construct the little-endian datatype in host memory and
+ * then use non-swapping equivalents of writel/writeq, rather than
+ * constructing a native-endian datatype and relying on the implicit
+ * byte-swapping done by writel/writeq.  (We use a similar strategy
+ * for register reads.)
+ */
+#endif
 
 /* Lowest bit numbers and widths */
 #define EFX_DUMMY_FIELD_LBN 0
@@ -37,6 +47,8 @@
 #define EFX_DWORD_2_WIDTH 32
 #define EFX_DWORD_3_LBN 96
 #define EFX_DWORD_3_WIDTH 32
+#define EFX_QWORD_0_LBN 0
+#define EFX_QWORD_0_WIDTH 64
 
 /* Specified attribute (e.g. LBN) of the specified field */
 #define EFX_VAL(field, attribute) field ## _ ## attribute
@@ -520,19 +532,6 @@ typedef union efx_oword {
 #define EFX_SET_QWORD_FIELD EFX_SET_QWORD_FIELD32
 #endif
 
-#define EFX_SET_OWORD_FIELD_VER(efx, oword, field, value) do { \
-	if (falcon_rev(efx) >= FALCON_REV_B0) {			   \
-		EFX_SET_OWORD_FIELD((oword), field##_B0, (value)); \
-	} else { \
-		EFX_SET_OWORD_FIELD((oword), field##_A1, (value)); \
-	} \
-} while (0)
-
-#define EFX_QWORD_FIELD_VER(efx, qword, field)	\
-	(falcon_rev(efx) >= FALCON_REV_B0 ?	\
-	 EFX_QWORD_FIELD((qword), field##_B0) :	\
-	 EFX_QWORD_FIELD((qword), field##_A1))
-
 /* Used to avoid compiler warnings about shift range exceeding width
  * of the data types when dma_addr_t is only 32 bits wide.
  */
@@ -543,7 +542,7 @@ typedef union efx_oword {
 
 /* Static initialiser */
 #define EFX_OWORD32(a, b, c, d)						\
-	{ .u32 = { cpu_to_le32(a), cpu_to_le32(b), \
-		   cpu_to_le32(c), cpu_to_le32(d) } }
+	{ .u32 = { __constant_cpu_to_le32(a), __constant_cpu_to_le32(b), \
+		   __constant_cpu_to_le32(c), __constant_cpu_to_le32(d) } }
 
 #endif /* EFX_BITFIELD_H */
diff -r 5b3d4d3c1166 drivers/net/sfc/boards.c
--- a/drivers/net/sfc/boards.c	Fri Nov 05 15:20:28 2010 +0000
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,328 +0,0 @@
-/****************************************************************************
- * Driver for Solarflare Solarstorm network controllers and boards
- * Copyright 2007-2008 Solarflare Communications Inc.
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 as published
- * by the Free Software Foundation, incorporated herein by reference.
- */
-
-#include "net_driver.h"
-#include "phy.h"
-#include "boards.h"
-#include "efx.h"
-#include "workarounds.h"
-
-/* Macros for unpacking the board revision */
-/* The revision info is in host byte order. */
-#define BOARD_TYPE(_rev) (_rev >> 8)
-#define BOARD_MAJOR(_rev) ((_rev >> 4) & 0xf)
-#define BOARD_MINOR(_rev) (_rev & 0xf)
-
-/* Blink support. If the PHY has no auto-blink mode so we hang it off a timer */
-#define BLINK_INTERVAL (HZ/2)
-
-static void blink_led_timer(unsigned long context)
-{
-	struct efx_nic *efx = (struct efx_nic *)context;
-	struct efx_blinker *bl = &efx->board_info.blinker;
-	efx->board_info.set_id_led(efx, bl->state);
-	bl->state = !bl->state;
-	if (bl->resubmit)
-		mod_timer(&bl->timer, jiffies + BLINK_INTERVAL);
-}
-
-static void board_blink(struct efx_nic *efx, bool blink)
-{
-	struct efx_blinker *blinker = &efx->board_info.blinker;
-
-	/* The rtnl mutex serialises all ethtool ioctls, so
-	 * nothing special needs doing here. */
-	if (blink) {
-		blinker->resubmit = true;
-		blinker->state = false;
-		setup_timer(&blinker->timer, blink_led_timer,
-			    (unsigned long)efx);
-		mod_timer(&blinker->timer, jiffies + BLINK_INTERVAL);
-	} else {
-		blinker->resubmit = false;
-		if (blinker->timer.function)
-			del_timer_sync(&blinker->timer);
-		efx->board_info.init_leds(efx);
-	}
-}
-
-/*****************************************************************************
- * Support for LM87 sensor chip used on several boards
- */
-#define LM87_REG_ALARMS1		0x41
-#define LM87_REG_ALARMS2		0x42
-#define LM87_IN_LIMITS(nr, _min, _max)			\
-	0x2B + (nr) * 2, _max, 0x2C + (nr) * 2, _min
-#define LM87_AIN_LIMITS(nr, _min, _max)			\
-	0x3B + (nr), _max, 0x1A + (nr), _min
-#define LM87_TEMP_INT_LIMITS(_min, _max)		\
-	0x39, _max, 0x3A, _min
-#define LM87_TEMP_EXT1_LIMITS(_min, _max)		\
-	0x37, _max, 0x38, _min
-
-#define LM87_ALARM_TEMP_INT		0x10
-#define LM87_ALARM_TEMP_EXT1		0x20
-
-#if defined(CONFIG_SENSORS_LM87) || defined(CONFIG_SENSORS_LM87_MODULE)
-
-static int efx_init_lm87(struct efx_nic *efx, struct i2c_board_info *info,
-			 const u8 *reg_values)
-{
-	struct i2c_client *client = i2c_new_device(&efx->i2c_adap, info);
-	int rc;
-
-	if (!client)
-		return -EIO;
-
-	while (*reg_values) {
-		u8 reg = *reg_values++;
-		u8 value = *reg_values++;
-		rc = i2c_smbus_write_byte_data(client, reg, value);
-		if (rc)
-			goto err;
-	}
-
-	efx->board_info.hwmon_client = client;
-	return 0;
-
-err:
-	i2c_unregister_device(client);
-	return rc;
-}
-
-static void efx_fini_lm87(struct efx_nic *efx)
-{
-	i2c_unregister_device(efx->board_info.hwmon_client);
-}
-
-static int efx_check_lm87(struct efx_nic *efx, unsigned mask)
-{
-	struct i2c_client *client = efx->board_info.hwmon_client;
-	s32 alarms1, alarms2;
-
-	/* If link is up then do not monitor temperature */
-	if (EFX_WORKAROUND_7884(efx) && efx->link_up)
-		return 0;
-
-	alarms1 = i2c_smbus_read_byte_data(client, LM87_REG_ALARMS1);
-	alarms2 = i2c_smbus_read_byte_data(client, LM87_REG_ALARMS2);
-	if (alarms1 < 0)
-		return alarms1;
-	if (alarms2 < 0)
-		return alarms2;
-	alarms1 &= mask;
-	alarms2 &= mask >> 8;
-	if (alarms1 || alarms2) {
-		EFX_ERR(efx,
-			"LM87 detected a hardware failure (status %02x:%02x)"
-			"%s%s\n",
-			alarms1, alarms2,
-			(alarms1 & LM87_ALARM_TEMP_INT) ? " INTERNAL" : "",
-			(alarms1 & LM87_ALARM_TEMP_EXT1) ? " EXTERNAL" : "");
-		return -ERANGE;
-	}
-
-	return 0;
-}
-
-#else /* !CONFIG_SENSORS_LM87 */
-
-static inline int
-efx_init_lm87(struct efx_nic *efx, struct i2c_board_info *info,
-	      const u8 *reg_values)
-{
-	return 0;
-}
-static inline void efx_fini_lm87(struct efx_nic *efx)
-{
-}
-static inline int efx_check_lm87(struct efx_nic *efx, unsigned mask)
-{
-	return 0;
-}
-
-#endif /* CONFIG_SENSORS_LM87 */
-
-/*****************************************************************************
- * Support for the SFE4002
- *
- */
-static u8 sfe4002_lm87_channel = 0x03; /* use AIN not FAN inputs */
-
-static const u8 sfe4002_lm87_regs[] = {
-	LM87_IN_LIMITS(0, 0x83, 0x91),		/* 2.5V:  1.8V +/- 5% */
-	LM87_IN_LIMITS(1, 0x51, 0x5a),		/* Vccp1: 1.2V +/- 5% */
-	LM87_IN_LIMITS(2, 0xb6, 0xca),		/* 3.3V:  3.3V +/- 5% */
-	LM87_IN_LIMITS(3, 0xb0, 0xc9),		/* 5V:    4.6-5.2V */
-	LM87_IN_LIMITS(4, 0xb0, 0xe0),		/* 12V:   11-14V */
-	LM87_IN_LIMITS(5, 0x44, 0x4b),		/* Vccp2: 1.0V +/- 5% */
-	LM87_AIN_LIMITS(0, 0xa0, 0xb2),		/* AIN1:  1.66V +/- 5% */
-	LM87_AIN_LIMITS(1, 0x91, 0xa1),		/* AIN2:  1.5V +/- 5% */
-	LM87_TEMP_INT_LIMITS(10, 60),		/* board */
-	LM87_TEMP_EXT1_LIMITS(10, 70),		/* Falcon */
-	0
-};
-
-static struct i2c_board_info sfe4002_hwmon_info = {
-	I2C_BOARD_INFO("lm87", 0x2e),
-	.platform_data	= &sfe4002_lm87_channel,
-};
-
-/****************************************************************************/
-/* LED allocations. Note that on rev A0 boards the schematic and the reality
- * differ: red and green are swapped. Below is the fixed (A1) layout (there
- * are only 3 A0 boards in existence, so no real reason to make this
- * conditional).
- */
-#define SFE4002_FAULT_LED (2)	/* Red */
-#define SFE4002_RX_LED    (0)	/* Green */
-#define SFE4002_TX_LED    (1)	/* Amber */
-
-static void sfe4002_init_leds(struct efx_nic *efx)
-{
-	/* Set the TX and RX LEDs to reflect status and activity, and the
-	 * fault LED off */
-	xfp_set_led(efx, SFE4002_TX_LED,
-		    QUAKE_LED_TXLINK | QUAKE_LED_LINK_ACTSTAT);
-	xfp_set_led(efx, SFE4002_RX_LED,
-		    QUAKE_LED_RXLINK | QUAKE_LED_LINK_ACTSTAT);
-	xfp_set_led(efx, SFE4002_FAULT_LED, QUAKE_LED_OFF);
-}
-
-static void sfe4002_set_id_led(struct efx_nic *efx, bool state)
-{
-	xfp_set_led(efx, SFE4002_FAULT_LED, state ? QUAKE_LED_ON :
-			QUAKE_LED_OFF);
-}
-
-static int sfe4002_check_hw(struct efx_nic *efx)
-{
-	/* A0 board rev. 4002s report a temperature fault the whole time
-	 * (bad sensor) so we mask it out. */
-	unsigned alarm_mask =
-		(efx->board_info.major == 0 && efx->board_info.minor == 0) ?
-		~LM87_ALARM_TEMP_EXT1 : ~0;
-
-	return efx_check_lm87(efx, alarm_mask);
-}
-
-static int sfe4002_init(struct efx_nic *efx)
-{
-	int rc = efx_init_lm87(efx, &sfe4002_hwmon_info, sfe4002_lm87_regs);
-	if (rc)
-		return rc;
-	efx->board_info.monitor = sfe4002_check_hw;
-	efx->board_info.init_leds = sfe4002_init_leds;
-	efx->board_info.set_id_led = sfe4002_set_id_led;
-	efx->board_info.blink = board_blink;
-	efx->board_info.fini = efx_fini_lm87;
-	return 0;
-}
-
-/*****************************************************************************
- * Support for the SFN4112F
- *
- */
-static u8 sfn4112f_lm87_channel = 0x03; /* use AIN not FAN inputs */
-
-static const u8 sfn4112f_lm87_regs[] = {
-	LM87_IN_LIMITS(0, 0x83, 0x91),		/* 2.5V:  1.8V +/- 5% */
-	LM87_IN_LIMITS(1, 0x51, 0x5a),		/* Vccp1: 1.2V +/- 5% */
-	LM87_IN_LIMITS(2, 0xb6, 0xca),		/* 3.3V:  3.3V +/- 5% */
-	LM87_IN_LIMITS(4, 0xb0, 0xe0),		/* 12V:   11-14V */
-	LM87_IN_LIMITS(5, 0x44, 0x4b),		/* Vccp2: 1.0V +/- 5% */
-	LM87_AIN_LIMITS(1, 0x91, 0xa1),		/* AIN2:  1.5V +/- 5% */
-	LM87_TEMP_INT_LIMITS(10, 60),		/* board */
-	LM87_TEMP_EXT1_LIMITS(10, 70),		/* Falcon */
-	0
-};
-
-static struct i2c_board_info sfn4112f_hwmon_info = {
-	I2C_BOARD_INFO("lm87", 0x2e),
-	.platform_data	= &sfn4112f_lm87_channel,
-};
-
-#define SFN4112F_ACT_LED	0
-#define SFN4112F_LINK_LED	1
-
-static void sfn4112f_init_leds(struct efx_nic *efx)
-{
-	xfp_set_led(efx, SFN4112F_ACT_LED,
-		    QUAKE_LED_RXLINK | QUAKE_LED_LINK_ACT);
-	xfp_set_led(efx, SFN4112F_LINK_LED,
-		    QUAKE_LED_RXLINK | QUAKE_LED_LINK_STAT);
-}
-
-static void sfn4112f_set_id_led(struct efx_nic *efx, bool state)
-{
-	xfp_set_led(efx, SFN4112F_LINK_LED,
-		    state ? QUAKE_LED_ON : QUAKE_LED_OFF);
-}
-
-static int sfn4112f_check_hw(struct efx_nic *efx)
-{
-	/* Mask out unused sensors */
-	return efx_check_lm87(efx, ~0x48);
-}
-
-static int sfn4112f_init(struct efx_nic *efx)
-{
-	int rc = efx_init_lm87(efx, &sfn4112f_hwmon_info, sfn4112f_lm87_regs);
-	if (rc)
-		return rc;
-	efx->board_info.monitor = sfn4112f_check_hw;
-	efx->board_info.init_leds = sfn4112f_init_leds;
-	efx->board_info.set_id_led = sfn4112f_set_id_led;
-	efx->board_info.blink = board_blink;
-	efx->board_info.fini = efx_fini_lm87;
-	return 0;
-}
-
-/* This will get expanded as board-specific details get moved out of the
- * PHY drivers. */
-struct efx_board_data {
-	enum efx_board_type type;
-	const char *ref_model;
-	const char *gen_type;
-	int (*init) (struct efx_nic *nic);
-};
-
-
-static struct efx_board_data board_data[] = {
-	{ EFX_BOARD_SFE4001, "SFE4001", "10GBASE-T adapter", sfe4001_init },
-	{ EFX_BOARD_SFE4002, "SFE4002", "XFP adapter", sfe4002_init },
-	{ EFX_BOARD_SFN4111T, "SFN4111T", "100/1000/10GBASE-T adapter",
-	  sfn4111t_init },
-	{ EFX_BOARD_SFN4112F, "SFN4112F", "SFP+ adapter",
-	  sfn4112f_init },
-};
-
-void efx_set_board_info(struct efx_nic *efx, u16 revision_info)
-{
-	struct efx_board_data *data = NULL;
-	int i;
-
-	efx->board_info.type = BOARD_TYPE(revision_info);
-	efx->board_info.major = BOARD_MAJOR(revision_info);
-	efx->board_info.minor = BOARD_MINOR(revision_info);
-
-	for (i = 0; i < ARRAY_SIZE(board_data); i++)
-		if (board_data[i].type == efx->board_info.type)
-			data = &board_data[i];
-
-	if (data) {
-		EFX_INFO(efx, "board is %s rev %c%d\n",
-			 (efx->pci_dev->subsystem_vendor == EFX_VENDID_SFC)
-			 ? data->ref_model : data->gen_type,
-			 'A' + efx->board_info.major, efx->board_info.minor);
-		efx->board_info.init = data->init;
-	} else {
-		EFX_ERR(efx, "unknown board type %d\n", efx->board_info.type);
-	}
-}
diff -r 5b3d4d3c1166 drivers/net/sfc/boards.h
--- a/drivers/net/sfc/boards.h	Fri Nov 05 15:20:28 2010 +0000
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,28 +0,0 @@
-/****************************************************************************
- * Driver for Solarflare Solarstorm network controllers and boards
- * Copyright 2007-2008 Solarflare Communications Inc.
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 as published
- * by the Free Software Foundation, incorporated herein by reference.
- */
-
-#ifndef EFX_BOARDS_H
-#define EFX_BOARDS_H
-
-/* Board IDs (must fit in 8 bits) */
-enum efx_board_type {
-	EFX_BOARD_SFE4001 = 1,
-	EFX_BOARD_SFE4002 = 2,
-	EFX_BOARD_SFN4111T = 0x51,
-	EFX_BOARD_SFN4112F = 0x52,
-};
-
-extern void efx_set_board_info(struct efx_nic *efx, u16 revision_info);
-
-/* SFE4001 (10GBASE-T) */
-extern int sfe4001_init(struct efx_nic *efx);
-/* SFN4111T (100/1000/10GBASE-T) */
-extern int sfn4111t_init(struct efx_nic *efx);
-
-#endif
diff -r 5b3d4d3c1166 drivers/net/sfc/debugfs.c
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/drivers/net/sfc/debugfs.c	Tue Nov 09 10:06:26 2010 +0000
@@ -0,0 +1,959 @@
+/****************************************************************************
+ * Driver for Solarflare Solarstorm network controllers and boards
+ * Copyright 2005-2006 Fen Systems Ltd.
+ * Copyright 2006-2009 Solarflare Communications Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 as published
+ * by the Free Software Foundation, incorporated herein by reference.
+ */
+
+#include <linux/module.h>
+#include <linux/pci.h>
+#ifndef EFX_USE_KCOMPAT
+#include <linux/debugfs.h>
+#else
+/* For out-of-tree builds we always need procfs, if only for a compatibility
+ * symlink.
+ */
+#include <linux/proc_fs.h>
+#endif
+#include <linux/dcache.h>
+#include <linux/seq_file.h>
+#include <linux/slab.h>
+#include "net_driver.h"
+#include "efx.h"
+#include "debugfs.h"
+#include "nic.h"
+
+#ifdef EFX_USE_KCOMPAT
+
+/* EFX_USE_DEBUGFS is defined by kernel_compat.h so we can't decide whether to
+ * include this earlier.
+ */
+#ifdef EFX_USE_DEBUGFS
+#include <linux/debugfs.h>
+#endif
+
+#ifndef EFX_USE_DEBUGFS
+
+static void efx_debugfs_remove(struct proc_dir_entry *entry)
+{
+	if (entry)
+		remove_proc_entry(entry->name, entry->parent);
+}
+#define debugfs_remove efx_debugfs_remove
+
+#define debugfs_create_dir proc_mkdir
+#define debugfs_create_symlink proc_symlink
+
+#endif /* !EFX_USE_DEBUGFS */
+
+#endif /* EFX_USE_KCOMPAT */
+
+
+/* Parameter definition bound to a structure - each file has one of these */
+struct efx_debugfs_bound_param {
+	const struct efx_debugfs_parameter *param;
+	void *structure;
+};
+
+
+/* Maximum length for a name component or symlink target */
+#define EFX_DEBUGFS_NAME_LEN 32
+
+
+/* Top-level debug directory ([/sys/kernel]/debug/sfc) */
+static efx_debugfs_entry *efx_debug_root;
+
+/* "cards" directory ([/sys/kernel]/debug/sfc/cards) */
+static efx_debugfs_entry *efx_debug_cards;
+
+
+/* Sequential file interface to bound parameters */
+
+#if !defined(EFX_USE_KCOMPAT) || defined(EFX_USE_DEBUGFS)
+
+static int efx_debugfs_seq_show(struct seq_file *file, void *v)
+{
+	struct efx_debugfs_bound_param *binding = file->private;
+
+	return binding->param->reader(file,
+				      binding->structure +
+				      binding->param->offset);
+}
+
+static int efx_debugfs_open(struct inode *inode, struct file *file)
+{
+	return single_open(file, efx_debugfs_seq_show, inode->i_private);
+}
+
+#else /* EFX_USE_KCOMPAT && !EFX_USE_DEBUGFS */
+
+static int efx_debugfs_seq_show(struct seq_file *file, void *v)
+{
+	struct proc_dir_entry *entry = file->private;
+	struct efx_debugfs_parameter *param = entry->data;
+	void *structure = (void *)entry->read_proc;
+
+	if (!structure)
+		return -EIO;
+
+	return param->reader(file, structure + param->offset);
+}
+
+static int efx_debugfs_open(struct inode *inode, struct file *file)
+{
+	return single_open(file, efx_debugfs_seq_show, PROC_I(inode)->pde);
+}
+
+#endif /* !EFX_USE_KCOMPAT || EFX_USE_DEBUGFS */
+
+
+static struct file_operations efx_debugfs_file_ops = {
+	.owner   = THIS_MODULE,
+	.open    = efx_debugfs_open,
+	.read    = seq_read,
+	.llseek  = seq_lseek,
+	.release = single_release
+};
+
+
+#if !defined(EFX_USE_KCOMPAT) || defined(EFX_USE_DEBUGFS)
+
+/**
+ * efx_fini_debugfs_child - remove a named child of a debugfs directory
+ * @dir:		Directory
+ * @name:		Name of child
+ *
+ * This removes the named child from the directory, if it exists.
+ */
+void efx_fini_debugfs_child(efx_debugfs_entry *dir, const char *name)
+{
+	struct qstr child_name;
+	efx_debugfs_entry *child;
+
+	child_name.len = strlen(name);
+	child_name.name = name;
+	child_name.hash = full_name_hash(child_name.name, child_name.len);
+	child = d_lookup(dir, &child_name);
+	if (child) {
+		/* If it's a "regular" file, free its parameter binding */
+		if (S_ISREG(child->d_inode->i_mode))
+			kfree(child->d_inode->i_private);
+		debugfs_remove(child);
+		dput(child);
+	}
+}
+
+#else /* EFX_USE_KCOMPAT && !EFX_USE_DEBUGFS */
+
+void efx_fini_debugfs_child(struct proc_dir_entry *dir, const char *name)
+{
+	remove_proc_entry(name, dir);
+}
+
+#endif /* !EFX_USE_KCOMPAT || EFX_USE_DEBUGFS */
+
+/*
+ * Remove a debugfs directory.
+ *
+ * This removes the named parameter-files and sym-links from the
+ * directory, and the directory itself.  It does not do any recursion
+ * to subdirectories.
+ */
+static void efx_fini_debugfs_dir(efx_debugfs_entry *dir,
+				 struct efx_debugfs_parameter *params,
+				 const char *const *symlink_names)
+{
+	if (!dir)
+		return;
+
+	while (params->name) {
+		efx_fini_debugfs_child(dir, params->name);
+		params++;
+	}
+	while (symlink_names && *symlink_names) {
+		efx_fini_debugfs_child(dir, *symlink_names);
+		symlink_names++;
+	}
+	debugfs_remove(dir);
+}
+
+/* Functions for printing various types of parameter. */
+
+int efx_debugfs_read_uint(struct seq_file *file, void *data)
+{
+	return seq_printf(file, "%#x\n", *(unsigned int *)data);
+}
+
+int efx_debugfs_read_int(struct seq_file *file, void *data)
+{
+	return seq_printf(file, "%d\n", *(int *)data);
+}
+
+int efx_debugfs_read_atomic(struct seq_file *file, void *data)
+{
+	unsigned int value = atomic_read((atomic_t *) data);
+
+	return seq_printf(file, "%#x\n", value);
+}
+
+int efx_debugfs_read_dword(struct seq_file *file, void *data)
+{
+	unsigned int value = EFX_DWORD_FIELD(*(efx_dword_t *) data,
+					     EFX_DWORD_0);
+
+	return seq_printf(file, "%#x\n", value);
+}
+
+#ifdef EFX_NOT_UPSTREAM
+int efx_debugfs_read_u64(struct seq_file *file, void *data)
+{
+	unsigned long long value = *((u64 *) data);
+
+	return seq_printf(file, "%llu\n", value);
+}
+#endif
+
+int efx_debugfs_read_bool(struct seq_file *file, void *data)
+{
+	return seq_printf(file, "%d\n", *(bool *)data);
+}
+
+static int efx_debugfs_read_int_mode(struct seq_file *file, void *data)
+{
+	unsigned int value = *(enum efx_int_mode *) data;
+
+	return seq_printf(file, "%d => %s\n", value,
+			  STRING_TABLE_LOOKUP(value, efx_interrupt_mode));
+}
+
+#define EFX_INT_MODE_PARAMETER(container_type, parameter)		\
+	EFX_PARAMETER(container_type, parameter,			\
+		      enum efx_int_mode, efx_debugfs_read_int_mode)
+
+static int efx_debugfs_read_loop_mode(struct seq_file *file, void *data)
+{
+	unsigned int value = *(enum efx_loopback_mode *)data;
+
+	return seq_printf(file, "%d => %s\n", value,
+			  STRING_TABLE_LOOKUP(value, efx_loopback_mode));
+}
+
+#define EFX_LOOPBACK_MODE_PARAMETER(container_type, parameter)		\
+	EFX_PARAMETER(container_type, parameter,			\
+		      enum efx_loopback_mode, efx_debugfs_read_loop_mode)
+
+int efx_debugfs_read_string(struct seq_file *file, void *data)
+{
+	return seq_puts(file, (const char *)data);
+}
+
+
+/**
+ * efx_init_debugfs_files - create parameter-files in a debugfs directory
+ * @parent:		Containing directory
+ * @params:		Pointer to zero-terminated parameter definition array
+ * @ignore:		Bitmask of array entries to ignore
+ * @structure:		Structure containing parameters
+ *
+ * Add parameter-files to the given debugfs directory.  Return a
+ * negative error code or 0 on success.
+ */
+static int efx_init_debugfs_files(efx_debugfs_entry *parent,
+				  struct efx_debugfs_parameter *params,
+				  u64 ignore, void *structure)
+{
+	struct efx_debugfs_parameter *param = params;
+	unsigned int pos = 0;
+
+	while (param->name) {
+		efx_debugfs_entry *entry;
+#if !defined(EFX_USE_KCOMPAT) || defined(EFX_USE_DEBUGFS)
+		struct efx_debugfs_bound_param *binding;
+
+		if ((1ULL << pos++) & ignore)
+			continue;
+
+		binding = kmalloc(sizeof(*binding), GFP_KERNEL);
+		if (!binding)
+			goto err;
+		binding->param = param;
+		binding->structure = structure;
+
+		entry = debugfs_create_file(param->name, S_IRUGO, parent,
+					    binding, &efx_debugfs_file_ops);
+		if (!entry) {
+			kfree(binding);
+			goto err;
+		}
+#else
+		if ((1ULL << pos++) & ignore)
+			continue;
+
+		entry = create_proc_entry(param->name, S_IRUGO, parent);
+		if (!entry)
+			goto err;
+		/*
+		 * We have no good way to free a binding created here.
+		 * However, once we install our file_operations the
+		 * read_proc pointer becomes redundant and we can
+		 * abuse it as a structure pointer.
+		 */
+		entry->data = param;
+		entry->read_proc = NULL;
+		smp_wmb();
+		entry->proc_fops = &efx_debugfs_file_ops;
+		smp_wmb();
+		entry->read_proc = (read_proc_t *) structure;
+#endif
+
+		param++;
+	}
+
+	return 0;
+
+ err:
+	while (param != params) {
+		param--;
+		if ((1ULL << --pos) & ignore)
+			continue;
+
+		efx_fini_debugfs_child(parent, param->name);
+	}
+	return -ENOMEM;
+}
+
+/**
+ * efx_init_debugfs_netdev - create debugfs sym-links for net device
+ * @net_dev:		Net device
+ *
+ * Create sym-links named after @net_dev to the debugfs directories for
+ * the corresponding NIC and  port.  Return a negative error code or 0 on
+ * success.  The sym-links must be cleaned up using
+ * efx_fini_debugfs_netdev().
+ */
+int efx_init_debugfs_netdev(struct net_device *net_dev)
+{
+	struct efx_nic *efx = netdev_priv(net_dev);
+	char name[EFX_DEBUGFS_NAME_LEN];
+	char target[EFX_DEBUGFS_NAME_LEN];
+	size_t len;
+
+	if (snprintf(name, sizeof(name), "nic_%s", net_dev->name) >=
+	    sizeof(name))
+		return -ENAMETOOLONG;
+	if (snprintf(target, sizeof(target), "cards/%s", pci_name(efx->pci_dev))
+	    >= sizeof(target))
+		return -ENAMETOOLONG;
+	efx->debug_symlink = debugfs_create_symlink(name,
+						    efx_debug_root, target);
+	if (!efx->debug_symlink)
+		return -ENOMEM;
+
+	if (snprintf(name, sizeof(name), "if_%s", net_dev->name) >=
+	    sizeof(name))
+		return -ENAMETOOLONG;
+	len = snprintf(target, sizeof(target),
+		       "cards/%s/port0", pci_name(efx->pci_dev));
+	if (len >= sizeof(target))
+		return -ENAMETOOLONG;
+	efx->debug_port_symlink = debugfs_create_symlink(name,
+							 efx_debug_root,
+							 target);
+	if (!efx->debug_port_symlink)
+		return -ENOMEM;
+
+	return 0;
+}
+
+/**
+ * efx_fini_debugfs_netdev - remove debugfs sym-links for net device
+ * @net_dev:		Net device
+ *
+ * Remove sym-links created for @net_dev by efx_init_debugfs_netdev().
+ */
+void efx_fini_debugfs_netdev(struct net_device *net_dev)
+{
+	struct efx_nic *efx = netdev_priv(net_dev);
+
+	debugfs_remove(efx->debug_port_symlink);
+	efx->debug_port_symlink = NULL;
+	debugfs_remove(efx->debug_symlink);
+	efx->debug_symlink = NULL;
+}
+
+/* Per-port parameters */
+static struct efx_debugfs_parameter efx_debugfs_port_parameters[] = {
+	EFX_NAMED_PARAMETER(enabled, struct efx_nic, port_enabled,
+			    bool, efx_debugfs_read_bool),
+#if defined(EFX_USE_KCOMPAT) && !defined(NETIF_F_LRO)
+	EFX_BOOL_PARAMETER(struct efx_nic, lro_enabled),
+#endif
+	EFX_BOOL_PARAMETER(struct efx_nic, rx_checksum_enabled),
+	EFX_NAMED_PARAMETER(link_up, struct efx_nic, link_state.up,
+			    bool, efx_debugfs_read_bool),
+	EFX_BOOL_PARAMETER(struct efx_nic, xmac_poll_required),
+	EFX_NAMED_PARAMETER(link_fd, struct efx_nic, link_state.fd,
+			    bool, efx_debugfs_read_bool),
+	EFX_NAMED_PARAMETER(link_speed, struct efx_nic, link_state.speed,
+			    unsigned int, efx_debugfs_read_uint),
+	EFX_BOOL_PARAMETER(struct efx_nic, promiscuous),
+	EFX_U64_PARAMETER(struct efx_nic, loopback_modes),
+	EFX_LOOPBACK_MODE_PARAMETER(struct efx_nic, loopback_mode),
+	EFX_UINT_PARAMETER(struct efx_nic, phy_type),
+	EFX_STRING_PARAMETER(struct efx_nic, phy_name),
+	EFX_NAMED_PARAMETER(phy_id, struct efx_nic, mdio.prtad,
+			    int, efx_debugfs_read_int),
+	EFX_UINT_PARAMETER(struct efx_nic, n_link_state_changes),
+	{NULL},
+};
+
+/**
+ * efx_init_debugfs_port - create debugfs directory for port
+ * @efx:		Efx NIC
+ *
+ * Create a debugfs directory containing parameter-files for @efx.
+ * Return a negative error code or 0 on success.  The directory must be
+ * cleaned up using efx_fini_debugfs_port().
+ */
+int efx_init_debugfs_port(struct efx_nic *efx)
+{
+	int rc;
+
+	/* Create directory */
+	efx->debug_port_dir = debugfs_create_dir("port0", efx->debug_dir);
+	if (!efx->debug_port_dir)
+		return -ENOMEM;
+
+	/* Create files */
+	rc = efx_init_debugfs_files(efx->debug_port_dir,
+				    efx_debugfs_port_parameters, 0, efx);
+	if (rc)
+		efx_fini_debugfs_port(efx);
+
+	return rc;
+}
+
+/**
+ * efx_fini_debugfs_port - remove debugfs directory for port
+ * @efx:		Efx NIC
+ *
+ * Remove directory created for @efx by efx_init_debugfs_port().
+ */
+void efx_fini_debugfs_port(struct efx_nic *efx)
+{
+	efx_fini_debugfs_dir(efx->debug_port_dir,
+			     efx_debugfs_port_parameters, NULL);
+	efx->debug_port_dir = NULL;
+}
+
+/**
+ * efx_extend_debugfs_port - add parameter-files to directory for port
+ * @efx:		Efx NIC
+ * @structure:		Structure containing parameters
+ * @ignore:		Bitmask of structure elements to ignore
+ * @params:		Pointer to zero-terminated parameter definition array
+ *
+ * Add parameter-files to the debugfs directory for @efx.  Return
+ * a negative error code or 0 on success.  This is intended for
+ * PHY-specific parameters.  The files must be cleaned up using
+ * efx_trim_debugfs_port().
+ */
+int efx_extend_debugfs_port(struct efx_nic *efx,
+			    void *structure, u64 ignore,
+			    struct efx_debugfs_parameter *params)
+{
+	return efx_init_debugfs_files(efx->debug_port_dir, params, ignore,
+				      structure);
+}
+
+/**
+ * efx_trim_debugfs_port - remove parameter-files from directory for port
+ * @efx:		Efx NIC
+ * @params:		Pointer to zero-terminated parameter definition array
+ *
+ * Remove parameter-files previously added to the debugfs directory
+ * for @efx using efx_extend_debugfs_port().
+ */
+void efx_trim_debugfs_port(struct efx_nic *efx,
+			   struct efx_debugfs_parameter *params)
+{
+	efx_debugfs_entry *dir = efx->debug_port_dir;
+
+	if (dir) {
+		struct efx_debugfs_parameter *field;
+		for (field = params; field->name; field++)
+			efx_fini_debugfs_child(dir, field->name);
+	}
+}
+
+/* Per-TX-queue parameters */
+static struct efx_debugfs_parameter efx_debugfs_tx_queue_parameters[] = {
+	EFX_UINT_PARAMETER(struct efx_tx_queue, insert_count),
+	EFX_UINT_PARAMETER(struct efx_tx_queue, write_count),
+	EFX_UINT_PARAMETER(struct efx_tx_queue, read_count),
+	EFX_INT_PARAMETER(struct efx_tx_queue, stopped),
+	EFX_UINT_PARAMETER(struct efx_tx_queue, tso_bursts),
+	EFX_UINT_PARAMETER(struct efx_tx_queue, tso_long_headers),
+	EFX_UINT_PARAMETER(struct efx_tx_queue, tso_packets),
+#ifdef EFX_NOT_UPSTREAM
+	EFX_U64_PARAMETER(struct efx_tx_queue, tx_bytes),
+	EFX_UINT_PARAMETER(struct efx_tx_queue, tx_packets),
+#endif
+	{NULL},
+};
+
+static void efx_fini_debugfs_tx_queue(struct efx_tx_queue *tx_queue);
+
+/**
+ * efx_init_debugfs_tx_queue - create debugfs directory for TX queue
+ * @tx_queue:		Efx TX queue
+ *
+ * Create a debugfs directory containing parameter-files for @tx_queue.
+ * Return a negative error code or 0 on success.  The directory must be
+ * cleaned up using efx_fini_debugfs_tx_queue().
+ */
+static int efx_init_debugfs_tx_queue(struct efx_tx_queue *tx_queue)
+{
+	char name[EFX_DEBUGFS_NAME_LEN];
+	char target[EFX_DEBUGFS_NAME_LEN];
+	int rc;
+
+	/* Create directory */
+	if (snprintf(name, sizeof(name), EFX_TX_QUEUE_NAME(tx_queue))
+	    >= sizeof(name))
+		goto err_len;
+	tx_queue->debug_dir = debugfs_create_dir(name,
+						 tx_queue->efx->debug_dir);
+	if (!tx_queue->debug_dir)
+		goto err_mem;
+
+	/* Create files */
+	rc = efx_init_debugfs_files(tx_queue->debug_dir,
+				    efx_debugfs_tx_queue_parameters, 0,
+				    tx_queue);
+	if (rc)
+		goto err;
+
+	/* Create symlink to channel */
+	if (snprintf(target, sizeof(target),
+		     "../" EFX_CHANNEL_NAME(tx_queue->channel)) >=
+	    sizeof(target))
+		goto err_len;
+	if (!debugfs_create_symlink("channel", tx_queue->debug_dir, target))
+		goto err_mem;
+
+	/* Create symlink to port */
+	if (!debugfs_create_symlink("port", tx_queue->debug_dir, "../port0"))
+		goto err_mem;
+
+	return 0;
+
+ err_len:
+	rc = -ENAMETOOLONG;
+	goto err;
+ err_mem:
+	rc = -ENOMEM;
+ err:
+	efx_fini_debugfs_tx_queue(tx_queue);
+	return rc;
+}
+
+/**
+ * efx_fini_debugfs_tx_queue - remove debugfs directory for TX queue
+ * @tx_queue:		Efx TX queue
+ *
+ * Remove directory created for @tx_queue by efx_init_debugfs_tx_queue().
+ */
+static void efx_fini_debugfs_tx_queue(struct efx_tx_queue *tx_queue)
+{
+	static const char *const symlink_names[] = {
+		"channel", "port", NULL
+	};
+
+	efx_fini_debugfs_dir(tx_queue->debug_dir,
+			     efx_debugfs_tx_queue_parameters, symlink_names);
+	tx_queue->debug_dir = NULL;
+}
+
+/* Per-RX-queue parameters */
+static struct efx_debugfs_parameter efx_debugfs_rx_queue_parameters[] = {
+	EFX_INT_PARAMETER(struct efx_rx_queue, added_count),
+	EFX_INT_PARAMETER(struct efx_rx_queue, removed_count),
+	EFX_UINT_PARAMETER(struct efx_rx_queue, max_fill),
+	EFX_UINT_PARAMETER(struct efx_rx_queue, fast_fill_trigger),
+	EFX_UINT_PARAMETER(struct efx_rx_queue, fast_fill_limit),
+	EFX_UINT_PARAMETER(struct efx_rx_queue, min_fill),
+	EFX_UINT_PARAMETER(struct efx_rx_queue, alloc_page_count),
+	EFX_UINT_PARAMETER(struct efx_rx_queue, alloc_skb_count),
+	EFX_UINT_PARAMETER(struct efx_rx_queue, recycle_count),
+	EFX_UINT_PARAMETER(struct efx_rx_queue, resurrect_count),
+	EFX_UINT_PARAMETER(struct efx_rx_queue, resurrect_failed_count),
+	EFX_UINT_PARAMETER(struct efx_rx_queue, slow_fill_count),
+	{NULL},
+};
+
+static void efx_fini_debugfs_rx_queue(struct efx_rx_queue *rx_queue);
+
+/**
+ * efx_init_debugfs_rx_queue - create debugfs directory for RX queue
+ * @rx_queue:		Efx RX queue
+ *
+ * Create a debugfs directory containing parameter-files for @rx_queue.
+ * Return a negative error code or 0 on success.  The directory must be
+ * cleaned up using efx_fini_debugfs_rx_queue().
+ */
+static int efx_init_debugfs_rx_queue(struct efx_rx_queue *rx_queue)
+{
+	char name[EFX_DEBUGFS_NAME_LEN];
+	char target[EFX_DEBUGFS_NAME_LEN];
+	int rc;
+
+	/* Create directory */
+	if (snprintf(name, sizeof(name), EFX_RX_QUEUE_NAME(rx_queue))
+	    >= sizeof(name))
+		goto err_len;
+	rx_queue->debug_dir = debugfs_create_dir(name,
+						 rx_queue->efx->debug_dir);
+	if (!rx_queue->debug_dir)
+		goto err_mem;
+
+	/* Create files */
+	rc = efx_init_debugfs_files(rx_queue->debug_dir,
+				    efx_debugfs_rx_queue_parameters, 0,
+				    rx_queue);
+	if (rc)
+		goto err;
+
+	/* Create symlink to channel */
+	if (snprintf(target, sizeof(target),
+		     "../" EFX_CHANNEL_NAME(efx_rx_queue_channel(rx_queue))) >=
+	    sizeof(target))
+		goto err_len;
+	if (!debugfs_create_symlink("channel", rx_queue->debug_dir, target))
+		goto err_mem;
+
+	return 0;
+
+ err_len:
+	rc = -ENAMETOOLONG;
+	goto err;
+ err_mem:
+	rc = -ENOMEM;
+ err:
+	efx_fini_debugfs_rx_queue(rx_queue);
+	return rc;
+}
+
+/**
+ * efx_fini_debugfs_rx_queue - remove debugfs directory for RX queue
+ * @rx_queue:		Efx RX queue
+ *
+ * Remove directory created for @rx_queue by efx_init_debugfs_rx_queue().
+ */
+static void efx_fini_debugfs_rx_queue(struct efx_rx_queue *rx_queue)
+{
+	const char *const symlink_names[] = {
+		"channel", NULL
+	};
+
+	efx_fini_debugfs_dir(rx_queue->debug_dir,
+			     efx_debugfs_rx_queue_parameters, symlink_names);
+	rx_queue->debug_dir = NULL;
+}
+
+/* Per-channel parameters */
+static struct efx_debugfs_parameter efx_debugfs_channel_parameters[] = {
+	EFX_BOOL_PARAMETER(struct efx_channel, enabled),
+	EFX_INT_PARAMETER(struct efx_channel, irq),
+	EFX_UINT_PARAMETER(struct efx_channel, irq_moderation),
+	EFX_UINT_PARAMETER(struct efx_channel, eventq_read_ptr),
+	EFX_UINT_PARAMETER(struct efx_channel, n_rx_tobe_disc),
+	EFX_UINT_PARAMETER(struct efx_channel, n_rx_ip_frag),
+	EFX_UINT_PARAMETER(struct efx_channel, n_rx_ip_hdr_chksum_err),
+	EFX_UINT_PARAMETER(struct efx_channel, n_rx_tcp_udp_chksum_err),
+	EFX_UINT_PARAMETER(struct efx_channel, n_rx_eth_crc_err),
+	EFX_UINT_PARAMETER(struct efx_channel, n_rx_mcast_mismatch),
+	EFX_UINT_PARAMETER(struct efx_channel, n_rx_frm_trunc),
+	EFX_UINT_PARAMETER(struct efx_channel, n_rx_overlength),
+	EFX_UINT_PARAMETER(struct efx_channel, n_skbuff_leaks),
+	EFX_INT_PARAMETER(struct efx_channel, rx_alloc_level),
+	EFX_INT_PARAMETER(struct efx_channel, rx_alloc_push_pages),
+#ifdef EFX_NOT_UPSTREAM
+	EFX_U64_PARAMETER(struct efx_channel, rx_bytes),
+	EFX_UINT_PARAMETER(struct efx_channel, rx_packets),
+#if defined(EFX_USE_SFC_LRO)
+	EFX_INT_PARAMETER(struct efx_channel, rx_alloc_pop_pages),
+	EFX_UINT_PARAMETER(struct efx_channel, ssr.n_merges),
+	EFX_UINT_PARAMETER(struct efx_channel, ssr.n_bursts),
+	EFX_UINT_PARAMETER(struct efx_channel, ssr.n_slow_start),
+	EFX_UINT_PARAMETER(struct efx_channel, ssr.n_misorder),
+	EFX_UINT_PARAMETER(struct efx_channel, ssr.n_too_many),
+	EFX_UINT_PARAMETER(struct efx_channel, ssr.n_new_stream),
+	EFX_UINT_PARAMETER(struct efx_channel, ssr.n_drop_idle),
+	EFX_UINT_PARAMETER(struct efx_channel, ssr.n_drop_closed),
+#endif
+#endif
+	EFX_ATOMIC_PARAMETER(struct efx_channel, tx_stop_count),
+	{NULL},
+};
+
+static void efx_fini_debugfs_channel(struct efx_channel *channel);
+
+/**
+ * efx_init_debugfs_channel - create debugfs directory for channel
+ * @channel:		Efx channel
+ *
+ * Create a debugfs directory containing parameter-files for @channel.
+ * Return a negative error code or 0 on success.  The directory must be
+ * cleaned up using efx_fini_debugfs_channel().
+ */
+static int efx_init_debugfs_channel(struct efx_channel *channel)
+{
+	char name[EFX_DEBUGFS_NAME_LEN];
+	int rc;
+
+	/* Create directory */
+	if (snprintf(name, sizeof(name), EFX_CHANNEL_NAME(channel))
+	    >= sizeof(name))
+		goto err_len;
+	channel->debug_dir = debugfs_create_dir(name, channel->efx->debug_dir);
+	if (!channel->debug_dir)
+		goto err_mem;
+
+	/* Create files */
+	rc = efx_init_debugfs_files(channel->debug_dir,
+				    efx_debugfs_channel_parameters, 0,
+				    channel);
+	if (rc)
+		goto err;
+
+	return 0;
+
+ err_len:
+	rc = -ENAMETOOLONG;
+	goto err;
+ err_mem:
+	rc = -ENOMEM;
+ err:
+	efx_fini_debugfs_channel(channel);
+	return rc;
+}
+
+/**
+ * efx_fini_debugfs_channel - remove debugfs directory for channel
+ * @channel:		Efx channel
+ *
+ * Remove directory created for @channel by efx_init_debugfs_channel().
+ */
+static void efx_fini_debugfs_channel(struct efx_channel *channel)
+{
+	efx_fini_debugfs_dir(channel->debug_dir,
+			     efx_debugfs_channel_parameters, NULL);
+	channel->debug_dir = NULL;
+}
+
+/* Per-NIC parameters */
+static struct efx_debugfs_parameter efx_debugfs_nic_parameters[] = {
+	EFX_INT_PARAMETER(struct efx_nic, legacy_irq),
+	EFX_UINT_PARAMETER(struct efx_nic, irq_zero_count),
+	/* Runbench requires we call this n_rx_queues and use decimal format */
+	EFX_NAMED_PARAMETER(n_rx_queues, struct efx_nic, n_rx_channels,
+			    unsigned int, efx_debugfs_read_int),
+	EFX_UINT_PARAMETER(struct efx_nic, n_tx_channels),
+	EFX_UINT_PARAMETER(struct efx_nic, rx_buffer_len),
+	EFX_INT_MODE_PARAMETER(struct efx_nic, interrupt_mode),
+	EFX_UINT_PARAMETER(struct efx_nic, state),
+	{.name = "hardware_desc",
+	 .offset = 0,
+	 .reader = efx_nic_debugfs_read_desc},
+	{NULL},
+};
+
+/* Per-NIC error counts */
+static struct efx_debugfs_parameter efx_debugfs_nic_error_parameters[] = {
+	EFX_ATOMIC_PARAMETER(struct efx_nic_errors, missing_event),
+	EFX_ATOMIC_PARAMETER(struct efx_nic_errors, rx_reset),
+	EFX_ATOMIC_PARAMETER(struct efx_nic_errors, rx_desc_fetch),
+	EFX_ATOMIC_PARAMETER(struct efx_nic_errors, tx_desc_fetch),
+	EFX_ATOMIC_PARAMETER(struct efx_nic_errors, spurious_tx),
+	{NULL},
+};
+
+/**
+ * efx_init_debugfs_channels - create debugfs directories for NIC channels
+ * @efx:		Efx NIC
+ *
+ * Create subdirectories of @efx's debugfs directory for all the
+ * channels, RX queues and TX queues used by this driver.  Return a
+ * negative error code or 0 on success.  The subdirectories must be
+ * cleaned up using efx_fini_debugfs_channels().
+ */
+int efx_init_debugfs_channels(struct efx_nic *efx)
+{
+	struct efx_channel *channel;
+	struct efx_rx_queue *rx_queue;
+	struct efx_tx_queue *tx_queue;
+	int rc;
+
+	efx_for_each_channel(channel, efx) {
+		rc = efx_init_debugfs_channel(channel);
+		if (rc)
+			goto err;
+
+		efx_for_each_channel_rx_queue(rx_queue, channel) {
+			rc = efx_init_debugfs_rx_queue(rx_queue);
+			if (rc)
+				goto err;
+		}
+
+		efx_for_each_channel_tx_queue(tx_queue, channel) {
+			rc = efx_init_debugfs_tx_queue(tx_queue);
+			if (rc)
+				goto err;
+		}
+	}
+
+	return 0;
+
+ err:
+	efx_fini_debugfs_channels(efx);
+	return rc;
+}
+
+/**
+ * efx_fini_debugfs_channels - remove debugfs directories for NIC queues
+ * @efx:		Efx NIC
+ *
+ * Remove subdirectories of @efx's debugfs directory created by
+ * efx_init_debugfs_channels().
+ */
+void efx_fini_debugfs_channels(struct efx_nic *efx)
+{
+	struct efx_channel *channel;
+	struct efx_rx_queue *rx_queue;
+	struct efx_tx_queue *tx_queue;
+
+	efx_for_each_channel(channel, efx) {
+		efx_for_each_channel_tx_queue(tx_queue, channel)
+			efx_fini_debugfs_tx_queue(tx_queue);
+
+		efx_for_each_channel_rx_queue(rx_queue, channel)
+			efx_fini_debugfs_rx_queue(rx_queue);
+
+		efx_fini_debugfs_channel(channel);
+	}
+}
+
+/**
+ * efx_init_debugfs_nic - create debugfs directory for NIC
+ * @efx:		Efx NIC
+ *
+ * Create debugfs directory containing parameter-files for @efx,
+ * and a subdirectory "errors" containing per-NIC error counts.
+ * Return a negative error code or 0 on success.  The directories
+ * must be cleaned up using efx_fini_debugfs_nic().
+ */
+int efx_init_debugfs_nic(struct efx_nic *efx)
+{
+	int rc;
+
+	/* Create directory */
+	efx->debug_dir = debugfs_create_dir(pci_name(efx->pci_dev),
+					    efx_debug_cards);
+	if (!efx->debug_dir)
+		goto err_mem;
+
+	/* Create errors directory */
+	efx->errors.debug_dir = debugfs_create_dir("errors", efx->debug_dir);
+	if (!efx->errors.debug_dir)
+		goto err_mem;
+
+	/* Create files */
+	rc = efx_init_debugfs_files(efx->debug_dir,
+				    efx_debugfs_nic_parameters, 0, efx);
+	if (rc)
+		goto err;
+	rc = efx_init_debugfs_files(efx->errors.debug_dir,
+				    efx_debugfs_nic_error_parameters, 0,
+				    &efx->errors);
+	if (rc)
+		goto err;
+
+	return 0;
+
+ err_mem:
+	rc = -ENOMEM;
+ err:
+	efx_fini_debugfs_nic(efx);
+	return rc;
+}
+
+/**
+ * efx_fini_debugfs_nic - remove debugfs directories for NIC
+ * @efx:		Efx NIC
+ *
+ * Remove debugfs directories created for @efx by efx_init_debugfs_nic().
+ */
+void efx_fini_debugfs_nic(struct efx_nic *efx)
+{
+	efx_fini_debugfs_dir(efx->errors.debug_dir,
+			     efx_debugfs_nic_error_parameters, NULL);
+	efx->errors.debug_dir = NULL;
+	efx_fini_debugfs_dir(efx->debug_dir, efx_debugfs_nic_parameters, NULL);
+	efx->debug_dir = NULL;
+}
+
+/**
+ * efx_init_debugfs - create debugfs directories for sfc driver
+ *
+ * Create debugfs directories "sfc" and "sfc/cards".  This must be
+ * called before any of the other functions that create debugfs
+ * directories.  Return a negative error code or 0 on success.  The
+ * directories must be cleaned up using efx_fini_debugfs().
+ */
+int efx_init_debugfs(void)
+{
+	/* Create top-level directory */
+#if !defined(EFX_USE_KCOMPAT) || defined(EFX_USE_DEBUGFS)
+	efx_debug_root = debugfs_create_dir("sfc", NULL);
+#else
+	efx_debug_root = proc_mkdir("driver/sfc", NULL);
+#endif
+	if (!efx_debug_root)
+		goto err;
+
+	/* Create "cards" directory */
+	efx_debug_cards = debugfs_create_dir("cards", efx_debug_root);
+	if (!efx_debug_cards)
+		goto err;
+
+#if defined(EFX_USE_KCOMPAT) && defined(EFX_USE_DEBUGFS)
+	/* Create compatibility sym-link */
+	if (!proc_symlink("driver/sfc", NULL, "/sys/kernel/debug/sfc"))
+		goto err;
+#endif
+	return 0;
+
+ err:
+	efx_fini_debugfs();
+	return -ENOMEM;
+}
+
+/**
+ * efx_fini_debugfs - remove debugfs directories for sfc driver
+ *
+ * Remove directories created by efx_init_debugfs().
+ */
+void efx_fini_debugfs(void)
+{
+#if defined(EFX_USE_KCOMPAT) && defined(EFX_USE_DEBUGFS)
+	remove_proc_entry("driver/sfc", NULL);
+#endif
+	debugfs_remove(efx_debug_cards);
+	efx_debug_cards = NULL;
+	debugfs_remove(efx_debug_root);
+	efx_debug_root = NULL;
+}
diff -r 5b3d4d3c1166 drivers/net/sfc/debugfs.h
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/drivers/net/sfc/debugfs.h	Tue Nov 09 10:06:26 2010 +0000
@@ -0,0 +1,166 @@
+/****************************************************************************
+ * Driver for Solarflare Solarstorm network controllers and boards
+ * Copyright 2005-2006 Fen Systems Ltd.
+ * Copyright 2006-2008 Solarflare Communications Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 as published
+ * by the Free Software Foundation, incorporated herein by reference.
+ */
+
+#ifndef EFX_DEBUGFS_H
+#define EFX_DEBUGFS_H
+
+#ifdef CONFIG_SFC_DEBUGFS
+
+struct seq_file;
+
+struct efx_debugfs_parameter {
+	const char *name;
+	size_t offset;
+	int (*reader)(struct seq_file *, void *);
+};
+
+extern void efx_fini_debugfs_child(efx_debugfs_entry *dir, const char *name);
+extern int efx_init_debugfs_netdev(struct net_device *net_dev);
+extern void efx_fini_debugfs_netdev(struct net_device *net_dev);
+extern int efx_init_debugfs_port(struct efx_nic *efx);
+extern void efx_fini_debugfs_port(struct efx_nic *efx);
+extern int efx_init_debugfs_nic(struct efx_nic *efx);
+extern void efx_fini_debugfs_nic(struct efx_nic *efx);
+extern int efx_init_debugfs_channels(struct efx_nic *efx);
+extern void efx_fini_debugfs_channels(struct efx_nic *efx);
+extern int efx_init_debugfs(void);
+extern void efx_fini_debugfs(void);
+extern int efx_extend_debugfs_port(struct efx_nic *efx,
+				   void *context, u64 ignore,
+				   struct efx_debugfs_parameter *params);
+extern void efx_trim_debugfs_port(struct efx_nic *efx,
+				  struct efx_debugfs_parameter *params);
+
+/* Helpers for handling debugfs entry reads */
+extern int efx_debugfs_read_uint(struct seq_file *, void *);
+extern int efx_debugfs_read_string(struct seq_file *, void *);
+extern int efx_debugfs_read_int(struct seq_file *, void *);
+extern int efx_debugfs_read_atomic(struct seq_file *, void *);
+extern int efx_debugfs_read_dword(struct seq_file *, void *);
+extern int efx_debugfs_read_u64(struct seq_file *, void *);
+extern int efx_debugfs_read_bool(struct seq_file *, void *);
+
+/* Handy macros for filling out parameters */
+
+/* Initialiser for a struct efx_debugfs_parameter with type-checking */
+#define EFX_PARAMETER(container_type, parameter, field_type,		\
+			reader_function) {				\
+	.name = #parameter,						\
+	.offset = ((((field_type *) 0) ==				\
+		    &((container_type *) 0)->parameter) ?		\
+		   offsetof(container_type, parameter) :		\
+		   offsetof(container_type, parameter)),		\
+	.reader = reader_function,					\
+}
+
+/* Likewise, but the file name is not taken from the field name */
+#define EFX_NAMED_PARAMETER(_name, container_type, parameter, field_type, \
+				reader_function) {			\
+	.name = #_name,							\
+	.offset = ((((field_type *) 0) ==				\
+		    &((container_type *) 0)->parameter) ?		\
+		   offsetof(container_type, parameter) :		\
+		   offsetof(container_type, parameter)),		\
+	.reader = reader_function,					\
+}
+
+/* Likewise, but with one file for each of 4 lanes */
+#define EFX_PER_LANE_PARAMETER(prefix, suffix, container_type, parameter, \
+				field_type, reader_function) {		\
+	.name = prefix "0" suffix,					\
+	.offset = ((((field_type *) 0) ==				\
+		      ((container_type *) 0)->parameter) ?		\
+		    offsetof(container_type, parameter[0]) :		\
+		    offsetof(container_type, parameter[0])),		\
+	.reader = reader_function,					\
+},  {									\
+	.name = prefix "1" suffix,					\
+	.offset = offsetof(container_type, parameter[1]),		\
+	.reader = reader_function,					\
+}, {									\
+	.name = prefix "2" suffix,					\
+	.offset = offsetof(container_type, parameter[2]),		\
+	.reader = reader_function,					\
+}, {									\
+	.name = prefix "3" suffix,					\
+	.offset = offsetof(container_type, parameter[3]),		\
+	.reader = reader_function,					\
+}
+
+/* A string parameter (string embedded in the structure) */
+#define EFX_STRING_PARAMETER(container_type, parameter) {	\
+	.name = #parameter,					\
+	.offset = ((((char *) 0) ==				\
+		    ((container_type *) 0)->parameter) ?	\
+		   offsetof(container_type, parameter) :	\
+		   offsetof(container_type, parameter)),	\
+	.reader = efx_debugfs_read_string,			\
+}
+
+/* An unsigned integer parameter */
+#define EFX_UINT_PARAMETER(container_type, parameter)		\
+	EFX_PARAMETER(container_type, parameter,		\
+		      unsigned int, efx_debugfs_read_uint)
+
+/* A dword parameter */
+#define EFX_DWORD_PARAMETER(container_type, parameter)		\
+	EFX_PARAMETER(container_type, parameter,		\
+		      efx_dword_t, efx_debugfs_read_dword)
+
+/* A u64 parameter */
+#define EFX_U64_PARAMETER(container_type, parameter)		\
+	EFX_PARAMETER(container_type, parameter,		\
+		      u64, efx_debugfs_read_u64)
+
+/* An atomic_t parameter */
+#define EFX_ATOMIC_PARAMETER(container_type, parameter)		\
+	EFX_PARAMETER(container_type, parameter,		\
+		      atomic_t, efx_debugfs_read_atomic)
+
+/* An integer parameter */
+#define EFX_INT_PARAMETER(container_type, parameter)		\
+	EFX_PARAMETER(container_type, parameter,		\
+		      int, efx_debugfs_read_int)
+
+#define EFX_BOOL_PARAMETER(container_type, parameter)		\
+	EFX_PARAMETER(container_type, parameter,		\
+		      bool, efx_debugfs_read_bool)
+
+#else /* !CONFIG_SFC_DEBUGFS */
+
+static inline int efx_init_debugfs_netdev(struct net_device *net_dev)
+{
+	return 0;
+}
+static inline void efx_fini_debugfs_netdev(struct net_device *net_dev) {}
+static inline int efx_init_debugfs_port(struct efx_nic *efx)
+{
+	return 0;
+}
+static inline void efx_fini_debugfs_port(struct efx_nic *efx) {}
+static inline int efx_init_debugfs_nic(struct efx_nic *efx)
+{
+	return 0;
+}
+static inline void efx_fini_debugfs_nic(struct efx_nic *efx) {}
+static inline int efx_init_debugfs_channels(struct efx_nic *efx)
+{
+	return 0;
+}
+static inline void efx_fini_debugfs_channels(struct efx_nic *efx) {}
+static inline int efx_init_debugfs(void)
+{
+	return 0;
+}
+static inline void efx_fini_debugfs(void) {}
+
+#endif /* CONFIG_SFC_DEBUGFS */
+
+#endif /* EFX_DEBUGFS_H */
diff -r 5b3d4d3c1166 drivers/net/sfc/driverlink.c
--- a/drivers/net/sfc/driverlink.c	Fri Nov 05 15:20:28 2010 +0000
+++ b/drivers/net/sfc/driverlink.c	Tue Nov 09 10:06:27 2010 +0000
@@ -1,7 +1,7 @@
 /****************************************************************************
  * Driver for Solarflare Solarstorm network controllers and boards
  * Copyright 2005      Fen Systems Ltd.
- * Copyright 2005-2008 Solarflare Communications Inc.
+ * Copyright 2005-2009 Solarflare Communications Inc.
  *
  * This program is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 as published
@@ -12,18 +12,19 @@
 #include <linux/list.h>
 #include <linux/skbuff.h>
 #include <linux/rtnetlink.h>
+#include <linux/slab.h>
 #include "net_driver.h"
 #include "efx.h"
+#include "driverlink_api.h"
 #include "driverlink.h"
 
-/* Protects @efx_driverlink_lock and @efx_driver_list */
-static DEFINE_MUTEX(efx_driverlink_lock);
+/* Global lists are protected by rtnl_lock */
 
 /* List of all registered drivers */
 static LIST_HEAD(efx_driver_list);
 
-/* List of all registered Efx ports */
-static LIST_HEAD(efx_port_list);
+/* List of all registered Efx ports. Protected by the rtnl_lock */
+LIST_HEAD(efx_port_list);
 
 /**
  * Driver link handle used internally to track devices
@@ -45,13 +46,15 @@ static struct efx_dl_handle *efx_dl_hand
 }
 
 /* Remove an Efx device, and call the driver's remove() callback if
- * present. The caller must hold @efx_driverlink_lock. */
+ * present. The caller must hold rtnl_lock. */
 static void efx_dl_del_device(struct efx_dl_device *efx_dev)
 {
 	struct efx_dl_handle *efx_handle = efx_dl_handle(efx_dev);
+	struct efx_nic *efx = efx_handle->efx;
 
-	EFX_INFO(efx_handle->efx, "%s driverlink client unregistering\n",
-		 efx_dev->driver->name);
+	netif_info(efx, drv, efx->net_dev,
+		   "%s driverlink client unregistering\n",
+		   efx_dev->driver->name);
 
 	if (efx_dev->driver->remove)
 		efx_dev->driver->remove(efx_dev);
@@ -83,18 +86,20 @@ static void efx_dl_try_add_device(struct
 	INIT_LIST_HEAD(&efx_handle->driver_node);
 
 	rc = driver->probe(efx_dev, efx->net_dev,
-			   efx->dl_info, efx->silicon_rev);
+			   efx->dl_info, efx->type->dl_revision);
 	if (rc)
 		goto fail;
 
 	list_add_tail(&efx_handle->driver_node, &driver->device_list);
 	list_add_tail(&efx_handle->port_node, &efx->dl_device_list);
 
-	EFX_INFO(efx, "%s driverlink client registered\n", driver->name);
+	netif_info(efx, drv, efx->net_dev,
+		   "%s driverlink client registered\n", driver->name);
 	return;
 
  fail:
-	EFX_INFO(efx, "%s driverlink client skipped\n", driver->name);
+	netif_info(efx, drv, efx->net_dev,
+		   "%s driverlink client skipped\n", driver->name);
 
 	kfree(efx_handle);
 }
@@ -108,7 +113,7 @@ void efx_dl_unregister_driver(struct efx
 	printk(KERN_INFO "Efx driverlink unregistering %s driver\n",
 		 driver->name);
 
-	mutex_lock(&efx_driverlink_lock);
+	rtnl_lock();
 
 	list_for_each_entry_safe(efx_handle, efx_handle_n,
 				 &driver->device_list, driver_node)
@@ -116,7 +121,7 @@ void efx_dl_unregister_driver(struct efx
 
 	list_del(&driver->node);
 
-	mutex_unlock(&efx_driverlink_lock);
+	rtnl_unlock();
 }
 EXPORT_SYMBOL(efx_dl_unregister_driver);
 
@@ -125,7 +130,6 @@ int efx_dl_register_driver(struct efx_dl
 int efx_dl_register_driver(struct efx_dl_driver *driver)
 {
 	struct efx_nic *efx;
-	int rc;
 
 	printk(KERN_INFO "Efx driverlink registering %s driver\n",
 		 driver->name);
@@ -133,16 +137,13 @@ int efx_dl_register_driver(struct efx_dl
 	INIT_LIST_HEAD(&driver->node);
 	INIT_LIST_HEAD(&driver->device_list);
 
-	rc = mutex_lock_interruptible(&efx_driverlink_lock);
-	if (rc)
-		return rc;
+	rtnl_lock();
 
 	list_add_tail(&driver->node, &efx_driver_list);
 	list_for_each_entry(efx, &efx_port_list, dl_node)
 		efx_dl_try_add_device(efx, driver);
 
-	mutex_unlock(&efx_driverlink_lock);
-
+	rtnl_unlock();
 	return 0;
 }
 EXPORT_SYMBOL(efx_dl_register_driver);
@@ -151,7 +152,7 @@ void efx_dl_unregister_nic(struct efx_ni
 {
 	struct efx_dl_handle *efx_handle, *efx_handle_n;
 
-	mutex_lock(&efx_driverlink_lock);
+	ASSERT_RTNL();
 
 	list_for_each_entry_safe_reverse(efx_handle, efx_handle_n,
 					 &efx->dl_device_list,
@@ -159,39 +160,39 @@ void efx_dl_unregister_nic(struct efx_ni
 		efx_dl_del_device(&efx_handle->efx_dev);
 
 	list_del(&efx->dl_node);
-
-	mutex_unlock(&efx_driverlink_lock);
 }
 
-int efx_dl_register_nic(struct efx_nic *efx)
+void efx_dl_register_nic(struct efx_nic *efx)
 {
 	struct efx_dl_driver *driver;
-	int rc;
 
-	rc = mutex_lock_interruptible(&efx_driverlink_lock);
-	if (rc)
-		return rc;
+	ASSERT_RTNL();
 
 	list_add_tail(&efx->dl_node, &efx_port_list);
 	list_for_each_entry(driver, &efx_driver_list, node)
 		efx_dl_try_add_device(efx, driver);
-
-	mutex_unlock(&efx_driverlink_lock);
-
-	return 0;
 }
 
 /* Dummy callback implementations.
  * To avoid a branch point on the fast-path, the callbacks are always
  * implemented - they are never NULL.
  */
-static enum efx_veto efx_dummy_tx_packet_callback(struct efx_dl_device *efx_dev,
+
+static enum efx_veto
+#if defined(EFX_USE_KCOMPAT) && defined(EFX_USE_FASTCALL)
+fastcall
+#endif
+efx_dummy_tx_packet_callback(struct efx_dl_device *efx_dev,
 						  struct sk_buff *skb)
 {
 	return EFX_ALLOW_PACKET;
 }
 
-static enum efx_veto efx_dummy_rx_packet_callback(struct efx_dl_device *efx_dev,
+static enum efx_veto
+#if defined(EFX_USE_KCOMPAT) && defined(EFX_USE_FASTCALL)
+fastcall
+#endif
+efx_dummy_rx_packet_callback(struct efx_dl_device *efx_dev,
 						  const char *pkt_buf, int len)
 {
 	return EFX_ALLOW_PACKET;
@@ -228,10 +229,13 @@ void efx_dl_unregister_callbacks(struct 
 	struct efx_dl_handle *efx_handle = efx_dl_handle(efx_dev);
 	struct efx_nic *efx = efx_handle->efx;
 
-	efx_suspend(efx);
+	ASSERT_RTNL();
 
-	EFX_INFO(efx, "removing callback hooks into %s driver\n",
-		 efx_dev->driver->name);
+	efx_stop_all(efx);
+
+	netif_info(efx, drv, efx->net_dev,
+		   "removing callback hooks into %s driver\n",
+		   efx_dev->driver->name);
 
 	if (callbacks->tx_packet) {
 		BUG_ON(efx->dl_cb_dev.tx_packet != efx_dev);
@@ -259,7 +263,7 @@ void efx_dl_unregister_callbacks(struct 
 		efx->dl_cb_dev.event = NULL;
 	}
 
-	efx_resume(efx);
+	efx_start_all(efx);
 }
 EXPORT_SYMBOL(efx_dl_unregister_callbacks);
 
@@ -270,7 +274,9 @@ int efx_dl_register_callbacks(struct efx
 	struct efx_nic *efx = efx_handle->efx;
 	int rc = 0;
 
-	efx_suspend(efx);
+	ASSERT_RTNL();
+
+	efx_stop_all(efx);
 
 	/* Check that the requested callbacks are not already hooked. */
 	if ((callbacks->tx_packet && efx->dl_cb_dev.tx_packet) ||
@@ -282,8 +288,9 @@ int efx_dl_register_callbacks(struct efx
 		goto out;
 	}
 
-	EFX_INFO(efx, "adding callback hooks to %s driver\n",
-		 efx_dev->driver->name);
+	netif_info(efx, drv, efx->net_dev,
+		   "adding callback hooks to %s driver\n",
+		   efx_dev->driver->name);
 
 	/* Hook in the requested callbacks, leaving any NULL members
 	 * referencing the members of @efx_default_callbacks */
@@ -309,7 +316,7 @@ int efx_dl_register_callbacks(struct efx
 	}
 
  out:
-	efx_resume(efx);
+	efx_start_all(efx);
 
 	return rc;
 }
@@ -324,19 +331,14 @@ void efx_dl_schedule_reset(struct efx_dl
 }
 EXPORT_SYMBOL(efx_dl_schedule_reset);
 
-void efx_dl_reset_unlock(void)
-{
-	mutex_unlock(&efx_driverlink_lock);
-}
-
-/* Suspend ready for reset, serialising against all the driverlink interfacse
- * and calling the suspend() callback of every registered driver */
+/* Suspend ready for reset, calling the reset_suspend() callback of every
+ * registered driver */
 void efx_dl_reset_suspend(struct efx_nic *efx)
 {
 	struct efx_dl_handle *efx_handle;
 	struct efx_dl_device *efx_dev;
 
-	mutex_lock(&efx_driverlink_lock);
+	ASSERT_RTNL();
 
 	list_for_each_entry_reverse(efx_handle,
 				    &efx->dl_device_list,
@@ -348,12 +350,13 @@ void efx_dl_reset_suspend(struct efx_nic
 }
 
 /* Resume after a reset, calling the resume() callback of every registered
- * driver, and releasing @Efx_driverlink_lock acquired in
- * efx_dl_reset_resume() */
+ * driver */
 void efx_dl_reset_resume(struct efx_nic *efx, int ok)
 {
 	struct efx_dl_handle *efx_handle;
 	struct efx_dl_device *efx_dev;
+
+	ASSERT_RTNL();
 
 	list_for_each_entry(efx_handle, &efx->dl_device_list,
 			    port_node) {
@@ -361,6 +364,31 @@ void efx_dl_reset_resume(struct efx_nic 
 		if (efx_dev->driver->reset_resume)
 			efx_dev->driver->reset_resume(efx_dev, ok);
 	}
+}
 
-	mutex_unlock(&efx_driverlink_lock);
+int efx_dl_filter_insert(struct efx_dl_device *efx_dev,
+			 struct efx_filter_spec *spec,
+			 bool replace)
+{
+	return efx_filter_insert_filter(efx_dl_handle(efx_dev)->efx,
+					spec, replace);
 }
+EXPORT_SYMBOL(efx_dl_filter_insert);
+
+void efx_dl_filter_remove(struct efx_dl_device *efx_dev,
+			  enum efx_filter_table_id table_id,
+			  int filter_idx)
+{
+	efx_filter_remove_index(efx_dl_handle(efx_dev)->efx,
+				table_id, filter_idx);
+}
+EXPORT_SYMBOL(efx_dl_filter_remove);
+
+void efx_dl_filter_redirect(struct efx_dl_device *efx_dev,
+			    enum efx_filter_table_id table_id,
+			    int filter_i, int rxq_i)
+{
+	efx_filter_redirect_index(efx_dl_handle(efx_dev)->efx,
+				  table_id, filter_i, rxq_i);
+}
+EXPORT_SYMBOL(efx_dl_filter_redirect);
diff -r 5b3d4d3c1166 drivers/net/sfc/driverlink.h
--- a/drivers/net/sfc/driverlink.h	Fri Nov 05 15:20:28 2010 +0000
+++ b/drivers/net/sfc/driverlink.h	Tue Nov 09 10:06:27 2010 +0000
@@ -14,10 +14,6 @@
 /* Forward declarations */
 struct efx_dl_device;
 struct efx_nic;
-
-#ifdef CONFIG_SFC_DRIVERLINK
-
-#include "driverlink_api.h"
 
 /* Efx callback devices
  *
@@ -37,30 +33,14 @@ extern struct efx_dl_callbacks efx_defau
 #define EFX_DL_CALLBACK(_port, _name, ...)				\
 	(_port)->dl_cb._name((_port)->dl_cb_dev._name, __VA_ARGS__)
 
-extern int efx_dl_register_nic(struct efx_nic *efx);
+extern void efx_dl_register_nic(struct efx_nic *efx);
 extern void efx_dl_unregister_nic(struct efx_nic *efx);
 
 /* Suspend and resume client drivers over a hardware reset */
 extern void efx_dl_reset_suspend(struct efx_nic *efx);
 extern void efx_dl_reset_resume(struct efx_nic *efx, int ok);
 
-#define EFX_DL_LOG EFX_LOG
-
-#else /* CONFIG_SFC_DRIVERLINK */
-
-enum efx_veto { EFX_ALLOW_PACKET = 0 };
-
-static inline int efx_nop_callback(struct efx_nic *efx) { return 0; }
-#define EFX_DL_CALLBACK(port, name, ...) efx_nop_callback(port)
-
-static inline int efx_dl_register_nic(struct efx_nic *efx) { return 0; }
-static inline void efx_dl_unregister_nic(struct efx_nic *efx) {}
-
-static inline void efx_dl_reset_suspend(struct efx_nic *efx) {}
-static inline void efx_dl_reset_resume(struct efx_nic *efx, int ok) {}
-
-#define EFX_DL_LOG(efx, fmt, args...) ((void)(efx))
-
-#endif /* CONFIG_SFC_DRIVERLINK */
+/* List of all registered Efx ports. Protected by the rtnl_lock */
+extern struct list_head efx_port_list;
 
 #endif /* EFX_DRIVERLINK_H */
diff -r 5b3d4d3c1166 drivers/net/sfc/driverlink_api.h
--- a/drivers/net/sfc/driverlink_api.h	Fri Nov 05 15:20:28 2010 +0000
+++ b/drivers/net/sfc/driverlink_api.h	Tue Nov 09 10:06:27 2010 +0000
@@ -12,6 +12,15 @@
 #define EFX_DRIVERLINK_API_H
 
 #include <linux/list.h>
+#if defined(EFX_USE_KCOMPAT) && !defined(EFX_USE_FASTCALL)
+	#include <linux/version.h>
+	#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,20)
+		#define EFX_USE_FASTCALL yes
+		#include <linux/linkage.h>
+	#endif
+#endif
+
+#include "filter.h"
 
 /* Forward declarations */
 struct pci_dev;
@@ -34,21 +43,21 @@ struct efx_dl_device_info;
  * @probe: Called when device added
  *	The client should use the @def_info linked list and @silicon_rev
  *	to determine if they wish to attach to this device.
- *	Context: process, driverlink semaphore held
+ *	Context: process, rtnl_lock or driverlink mutex held
  * @remove: Called when device removed
  *	The client must ensure the finish all operations with this
  *	device before returning from this method.
- *	Context: process, driverlink semaphore held
+ *	Context: process, rtnl_lock or driverlink mutex held
  * @reset_suspend: Called before device is reset
  *	Called immediately before a hardware reset. The client must stop all
  *	hardware processing before returning from this method. Callbacks will
  *	be inactive when this method is called.
- *	Context: process, driverlink semaphore held. rtnl_lock may be held
+ *	Context: process, rtnl_lock and/or driverlink mutex held
  * @reset_resume: Called after device is reset
  *	Called after a hardware reset. If @ok is true, the client should
  *	state and resume normal operations. If @ok is false, the client should
  *	abandon use of the hardware resources. remove() will still be called.
- *	Context: process, driverlink semaphore held. rtnl_lock may be held
+ *	Context: process, rtnl_lock and/or driverlink mutex held
  */
 struct efx_dl_driver {
 	const char *name;
@@ -73,10 +82,12 @@ struct efx_dl_driver {
  * provided to each driverlink client in the probe() @dev_info member.
  *
  * @EFX_DL_FALCON_RESOURCES: Information type is &struct efx_dl_falcon_resources
+ * @EFX_DL_HASH_INSERTION: Information type is &struct efx_dl_hash_insertion
  */
 enum efx_dl_device_info_type {
 	/** Falcon resources available for export */
 	EFX_DL_FALCON_RESOURCES = 0,
+	EFX_DL_HASH_INSERTION = 1,
 };
 
 /**
@@ -103,10 +114,12 @@ struct efx_dl_device_info {
  *	Falcon supports traditional legacy interrupts and MSI/MSI-X
  *	interrupts. The choice is made at run time by the sfc driver, and
  *	notified to the clients by this enumeration
+ * @EFX_DL_FALCON_ONLOAD_UNSUPPORTED: OpenOnload unsupported on this port.
  */
 enum efx_dl_falcon_resource_flags {
 	EFX_DL_FALCON_DUAL_FUNC = 0x1,
 	EFX_DL_FALCON_USE_MSI = 0x2,
+	EFX_DL_FALCON_ONLOAD_UNSUPPORTED = 0x4,
 };
 
 /**
@@ -150,6 +163,36 @@ struct efx_dl_falcon_resources {
 };
 
 /**
+ * enum efx_dl_hash_type_flags - Hash insertion type flags
+ *
+ * @EFX_DL_HASH_TOEP_TCPIP4: Toeplitz hash of TCP/IPv4 4-tuple
+ * @EFX_DL_HASH_TOEP_IP4: Toeplitz hash of IPv4 addresses
+ * @EFX_DL_HASH_TOEP_TCPIP6: Toeplitz hash of TCP/IPv6 4-tuple
+ * @EFX_DL_HASH_TOEP_IP6: Toeplitz hash of IPv6 addresses
+ */
+enum efx_dl_hash_type_flags {
+	EFX_DL_HASH_TOEP_TCPIP4 = 0x1,
+	EFX_DL_HASH_TOEP_IP4 = 0x2,
+	EFX_DL_HASH_TOEP_TCPIP6 = 0x4,
+	EFX_DL_HASH_TOEP_IP6 = 0x8,
+};
+
+/**
+ * struct efx_dl_hash_insertion - Hash insertion behaviour
+ *
+ * @hdr: Resource linked list header
+ * @data_offset: Offset of packet data relative to start of buffer
+ * @hash_offset: Offset of hash relative to start of buffer
+ * @flags: Flags for hash type(s) enabled
+ */
+struct efx_dl_hash_insertion {
+	struct efx_dl_device_info hdr;
+	unsigned data_offset;
+	unsigned hash_offset;
+	enum efx_dl_hash_type_flags flags;
+};
+
+/**
  * struct efx_dl_device - An Efx driverlink device.
  *
  * @pci_dev: PCI device used by the sfc driver.
@@ -183,9 +226,9 @@ enum efx_veto {
 /**
  * struct efx_dl_callbacks - Efx callbacks
  *
- * This is a tighly controlled set of simple callbacks, that are attached
- * to the sfc driver via efx_dl_register_callbacks().  They export just enough
- * state to allow clients to make use of the available hardware resources.
+ * These methods can be hooked into the sfc driver via
+ * efx_dl_register_callbacks().  They allow clients to intercept and/or
+ * modify the behaviour of the sfc driver at predetermined points.
  *
  * For efficiency, only one client can hook each callback. Since these
  * callbacks are called on packet transmit and reception paths, and the
@@ -202,6 +245,7 @@ enum efx_veto {
  *	to snoop every received packet (on every rx queue), and veto
  *	reception by returning %EFX_VETO_PACKET.
  *	Context: tasklet
+ * @link_change: Never used
  * @request_mtu: Called to request MTU change.
  *	Called whenever the user requests the net_dev mtu to be changed.
  *	If the client returns an error, the mtu change is aborted. The sfc
@@ -216,10 +260,21 @@ enum efx_veto {
  *	Context: tasklet.
  */
 struct efx_dl_callbacks {
+#if defined(EFX_USE_KCOMPAT) && defined(EFX_USE_FASTCALL)
+	enum efx_veto fastcall (*tx_packet) (struct efx_dl_device *efx_dev,
+					     struct sk_buff *skb);
+#else
 	enum efx_veto (*tx_packet) (struct efx_dl_device *efx_dev,
 				    struct sk_buff *skb);
+#endif
+#if defined(EFX_USE_KCOMPAT) && defined(EFX_USE_FASTCALL)
+	enum efx_veto fastcall (*rx_packet) (struct efx_dl_device *efx_dev,
+					     const char *pkt_hdr, int pkt_len);
+#else
 	enum efx_veto (*rx_packet) (struct efx_dl_device *efx_dev,
 				    const char *pkt_hdr, int pkt_len);
+#endif
+	void (*link_change) (struct efx_dl_device *, int);
 	int (*request_mtu) (struct efx_dl_device *efx_dev, int new_mtu);
 	void (*mtu_changed) (struct efx_dl_device *efx_dev, int mtu);
 	void (*event) (struct efx_dl_device *efx_dev, void *p_event);
@@ -232,26 +287,58 @@ struct efx_dl_callbacks {
 	efx_dl_stringify_2(efx_dl_register_driver_api_ver_,	\
 			   EFX_DRIVERLINK_API_VERSION)
 
-/* Exported driverlink api used to register and unregister the client driver
- * and any callbacks [only one per port allowed], and to allow a client driver
- * to request reset to recover from an error condition.
+/**
+ * efx_dl_register_driver() - Register a client driver
+ * @driver: Driver operations structure
  *
- * All of these functions acquire the driverlink semaphore, so must not be
- * called from an efx_dl_driver or efx_dl_callbacks member, and must be called
- * from process context.
+ * This acquires the rtnl_lock and therefore must be called from
+ * process context.
  */
 extern int efx_dl_register_driver(struct efx_dl_driver *driver);
 
+/**
+ * efx_dl_unregister_driver() - Unregister a client driver
+ * @driver: Driver operations structure
+ *
+ * This acquires the rtnl_lock and therefore must be called from
+ * process context.
+ */
 extern void efx_dl_unregister_driver(struct efx_dl_driver *driver);
 
+/**
+ * efx_dl_register_callbacks() - Set callback functions for a device
+ * @efx_dev: Device to be affected
+ * @callbacks: Callback functions structure
+ *
+ * This must be called in process context from the driver's probe()
+ * operation.
+ */
 extern int efx_dl_register_callbacks(struct efx_dl_device *efx_dev,
 				     struct efx_dl_callbacks *callbacks);
 
+/**
+ * efx_dl_unregister_callbacks() - Unset callback functions for a device
+ * @efx_dev: Device to be affected
+ * @callbacks: Callback functions structure
+ *
+ * This must be called in process context from the driver's remove()
+ * operation.
+ */
 extern void efx_dl_unregister_callbacks(struct efx_dl_device *efx_dev,
 					struct efx_dl_callbacks *callbacks);
 
 /* Schedule a reset without grabbing any locks */
 extern void efx_dl_schedule_reset(struct efx_dl_device *efx_dev);
+
+extern int efx_dl_filter_insert(struct efx_dl_device *efx_dev,
+				struct efx_filter_spec *spec,
+				bool replace);
+extern void efx_dl_filter_remove(struct efx_dl_device *efx_dev,
+				 enum efx_filter_table_id table_id,
+				 int filter_idx);
+extern void efx_dl_filter_redirect(struct efx_dl_device *efx_dev,
+				   enum efx_filter_table_id table_id,
+				   int filter_i, int rxq_i);
 
 /**
  * efx_dl_for_each_device_info_matching - iterate an efx_dl_device_info list
diff -r 5b3d4d3c1166 drivers/net/sfc/efx.c
--- a/drivers/net/sfc/efx.c	Fri Nov 05 15:20:28 2010 +0000
+++ b/drivers/net/sfc/efx.c	Tue Nov 09 10:06:27 2010 +0000
@@ -1,7 +1,7 @@
 /****************************************************************************
  * Driver for Solarflare Solarstorm network controllers and boards
  * Copyright 2005-2006 Fen Systems Ltd.
- * Copyright 2005-2008 Solarflare Communications Inc.
+ * Copyright 2005-2009 Solarflare Communications Inc.
  *
  * This program is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 as published
@@ -20,22 +20,103 @@
 #include <linux/crc32.h>
 #include <linux/ethtool.h>
 #include <linux/topology.h>
+#include <linux/gfp.h>
+#ifdef EFX_NOT_UPSTREAM
+#ifdef EFX_USE_LINUX_UACCESS_H
+#include <linux/uaccess.h>
+#else
+#include <asm/uaccess.h>
+#endif
+#endif
 #include "net_driver.h"
-#include "ethtool.h"
-#include "tx.h"
-#include "rx.h"
+#include "driverlink.h"
+#ifdef EFX_NOT_UPSTREAM
+#include "selftest.h"
+#endif
+#include "debugfs.h"
 #include "efx.h"
 #include "mdio_10g.h"
-#include "falcon.h"
+#if defined(EFX_NOT_UPSTREAM) && defined(SFC_PCAP_SUPPORT)
+#include "pcap.h"
+#endif
+#include "nic.h"
+#ifdef EFX_USE_KCOMPAT
+#include "efx_ioctl.h"
+#endif
+
+#if defined(EFX_NOT_UPSTREAM) && defined(EFX_GCOV)
+#include "../linux/gcov.h"
+#endif
+
+#if defined (EFX_NOT_UPSTREAM) && defined(EFX_WITH_VMWARE_NETQ)
+#include "efx_netq.h"
+#endif
+#include "mcdi.h"
+#include "workarounds.h"
+
+/**************************************************************************
+ *
+ * Type name strings
+ *
+ **************************************************************************
+ */
+
+/* Loopback mode names (see LOOPBACK_MODE()) */
+const unsigned int efx_loopback_mode_max = LOOPBACK_MAX;
+const char *efx_loopback_mode_names[] = {
+	[LOOPBACK_NONE]		= "NONE",
+	[LOOPBACK_DATA]		= "DATAPATH",
+	[LOOPBACK_GMAC]		= "GMAC",
+	[LOOPBACK_XGMII]	= "XGMII",
+	[LOOPBACK_XGXS]		= "XGXS",
+	[LOOPBACK_XAUI]  	= "XAUI",
+	[LOOPBACK_GMII] 	= "GMII",
+	[LOOPBACK_SGMII] 	= "SGMII",
+	[LOOPBACK_XGBR]		= "XGBR",
+	[LOOPBACK_XFI]		= "XFI",
+	[LOOPBACK_XAUI_FAR]	= "XAUI_FAR",
+	[LOOPBACK_GMII_FAR]	= "GMII_FAR",
+	[LOOPBACK_SGMII_FAR]	= "SGMII_FAR",
+	[LOOPBACK_XFI_FAR]	= "XFI_FAR",
+	[LOOPBACK_GPHY]		= "GPHY",
+	[LOOPBACK_PHYXS]	= "PHYXS",
+	[LOOPBACK_PCS]	 	= "PCS",
+	[LOOPBACK_PMAPMD] 	= "PMA/PMD",
+	[LOOPBACK_XPORT]	= "XPORT",
+	[LOOPBACK_XGMII_WS]	= "XGMII_WS",
+	[LOOPBACK_XAUI_WS]  	= "XAUI_WS",
+	[LOOPBACK_XAUI_WS_FAR]  = "XAUI_WS_FAR",
+	[LOOPBACK_XAUI_WS_NEAR] = "XAUI_WS_NEAR",
+	[LOOPBACK_GMII_WS] 	= "GMII_WS",
+	[LOOPBACK_XFI_WS]	= "XFI_WS",
+	[LOOPBACK_XFI_WS_FAR]	= "XFI_WS_FAR",
+	[LOOPBACK_PHYXS_WS]  	= "PHYXS_WS",
+};
+
+/* Interrupt mode names (see INT_MODE())) */
+const unsigned int efx_interrupt_mode_max = EFX_INT_MODE_MAX;
+const char *efx_interrupt_mode_names[] = {
+	[EFX_INT_MODE_MSIX]   = "MSI-X",
+	[EFX_INT_MODE_MSI]    = "MSI",
+	[EFX_INT_MODE_LEGACY] = "legacy",
+};
+
+const unsigned int efx_reset_type_max = RESET_TYPE_MAX;
+const char *efx_reset_type_names[] = {
+	[RESET_TYPE_INVISIBLE]     = "INVISIBLE",
+	[RESET_TYPE_ALL]           = "ALL",
+	[RESET_TYPE_WORLD]         = "WORLD",
+	[RESET_TYPE_DISABLE]       = "DISABLE",
+	[RESET_TYPE_TX_WATCHDOG]   = "TX_WATCHDOG",
+	[RESET_TYPE_INT_ERROR]     = "INT_ERROR",
+	[RESET_TYPE_RX_RECOVERY]   = "RX_RECOVERY",
+	[RESET_TYPE_RX_DESC_FETCH] = "RX_DESC_FETCH",
+	[RESET_TYPE_TX_DESC_FETCH] = "TX_DESC_FETCH",
+	[RESET_TYPE_TX_SKIP]       = "TX_SKIP",
+	[RESET_TYPE_MC_FAILURE]    = "MC_FAILURE",
+};
 
 #define EFX_MAX_MTU (9 * 1024)
-
-/* RX slow fill workqueue. If memory allocation fails in the fast path,
- * a work item is pushed onto this work queue to retry the allocation later,
- * to avoid the NIC being starved of RX buffers. Since this is a per cpu
- * workqueue, there is nothing to be gained in making it per NIC
- */
-static struct workqueue_struct *refill_workqueue;
 
 /* Reset workqueue. If any NIC has a hardware failure then a reset will be
  * queued onto this work queue. This is not a per-nic work queue, because
@@ -43,11 +124,30 @@ static struct workqueue_struct *refill_w
  */
 static struct workqueue_struct *reset_workqueue;
 
+static unsigned debug = (NETIF_MSG_DRV | NETIF_MSG_PROBE |
+			 NETIF_MSG_LINK | NETIF_MSG_IFDOWN |
+			 NETIF_MSG_IFUP | NETIF_MSG_RX_ERR |
+			 NETIF_MSG_TX_ERR | NETIF_MSG_HW);
+module_param(debug, uint, 0);
+MODULE_PARM_DESC(debug, "Bitmapped debugging message enable value");
+
 /**************************************************************************
  *
  * Configurable values
  *
  *************************************************************************/
+
+#if defined(EFX_USE_KCOMPAT) && (defined(EFX_USE_GRO) || defined(EFX_USE_SFC_LRO))
+/*
+ * Enable large receive offload (LRO) aka soft segment reassembly (SSR)
+ *
+ * This sets the default for new devices.  It can be controlled later
+ * using ethtool.
+ */
+static int lro = true;
+module_param(lro, int, 0644);
+MODULE_PARM_DESC(lro, "Large receive offload acceleration");
+#endif
 
 /*
  * Use separate channels for TX and RX events
@@ -57,8 +157,8 @@ static struct workqueue_struct *reset_wo
  *
  * This is only used in MSI-X interrupt mode
  */
-static unsigned int separate_tx_channels;
-module_param(separate_tx_channels, uint, 0644);
+static unsigned int separate_tx_channels = false;
+module_param(separate_tx_channels, uint, 0444);
 MODULE_PARM_DESC(separate_tx_channels,
 		 "Use separate channels for TX and RX");
 
@@ -68,10 +168,11 @@ static int napi_weight = 64;
 static int napi_weight = 64;
 
 /* This is the time (in jiffies) between invocations of the hardware
- * monitor, which checks for known hardware bugs and resets the
- * hardware and driver as necessary.
+ * monitor.  On Falcon-based NICs, this will:
+ * - Check the on-board hardware monitor;
+ * - Poll the link state and reconfigure the hardware as necessary.
  */
-unsigned int efx_monitor_interval = 1 * HZ;
+static unsigned int efx_monitor_interval = 1 * HZ;
 
 /* This controls whether or not the driver will initialise devices
  * with invalid MAC addresses stored in the EEPROM or flash.  If true,
@@ -81,6 +182,14 @@ unsigned int efx_monitor_interval = 1 * 
  * address) have previously been erased.
  */
 static unsigned int allow_bad_hwaddr;
+
+#ifdef EFX_NOT_UPSTREAM
+/* This allows a card to continue operating after a fatal error has
+ * been detected.  Consider any relevant warranties to be completely
+ * voided by using this option.
+ */
+static unsigned int allow_zombie;
+#endif
 
 /* Initial interrupt moderation settings.  They can be modified after
  * module load with ethtool.
@@ -101,6 +210,15 @@ static unsigned int rx_irq_mod_usec = 60
  */
 static unsigned int tx_irq_mod_usec = 150;
 
+#ifdef EFX_NOT_UPSTREAM
+/* Ignore online self-test failures at load
+ *
+ * If set to 1, then the driver will not fail to load
+ * if the online self-test fails. Useful only during testing
+ */
+static unsigned int allow_load_on_failure;
+#endif
+
 /* This is the first interrupt mode to try out of:
  * 0 => MSI-X
  * 1 => MSI
@@ -108,20 +226,43 @@ static unsigned int tx_irq_mod_usec = 15
  */
 static unsigned int interrupt_mode;
 
-/* This is the requested number of CPUs to use for Receive-Side Scaling (RSS),
- * i.e. the number of CPUs among which we may distribute simultaneous
- * interrupt handling.
+#ifdef EFX_NOT_UPSTREAM
+/* If set to 1, then the driver will perform an offline self test
+ * when each interface first comes up. This will appear like the
+ * interface bounces up and down
+ */
+static unsigned int onload_offline_selftest = true;
+#endif
+
+/* This is the requested number of CPUs to use for Receive-Side Scaling
+ * (RSS), i.e. the number of CPUs among which we may distribute
+ * simultaneous interrupt handling.  Or alternatively it may be set to
+ * "packages", "cores" or "hyperthreads" to get one receive channel per
+ * package, core or hyperthread.
  *
- * Cards without MSI-X will only target one CPU via legacy or MSI interrupt.
- * The default (0) means to assign an interrupt to each package (level II cache)
+ * Systems without MSI-X will only target one CPU via legacy or MSI
+ * interrupt.  The default is "packages".
  */
-static unsigned int rss_cpus;
-module_param(rss_cpus, uint, 0444);
-MODULE_PARM_DESC(rss_cpus, "Number of CPUs to use for Receive-Side Scaling");
+static char *rss_cpus;
+module_param(rss_cpus, charp, 0444);
+MODULE_PARM_DESC(rss_cpus, "Number of CPUs to use for Receive-Side Scaling, "
+		 "or 'packages', 'cores' or 'hyperthreads'");
+
+enum rss_mode {
+	EFX_RSS_PACKAGES,
+	EFX_RSS_CORES,
+	EFX_RSS_HYPERTHREADS,
+	EFX_RSS_CUSTOM,
+};
 
 static int phy_flash_cfg;
 module_param(phy_flash_cfg, int, 0644);
 MODULE_PARM_DESC(phy_flash_cfg, "Set PHYs into reflash mode initially");
+
+static unsigned irq_adapt_enable = 1;
+module_param(irq_adapt_enable, uint, 0444);
+MODULE_PARM_DESC(irq_adapt_enable,
+		 "Enable adaptive interrupt moderation");
 
 static unsigned irq_adapt_low_thresh = 10000;
 module_param(irq_adapt_low_thresh, uint, 0644);
@@ -133,19 +274,36 @@ MODULE_PARM_DESC(irq_adapt_high_thresh,
 MODULE_PARM_DESC(irq_adapt_high_thresh,
 		 "Threshold score for increasing IRQ moderation");
 
+static unsigned irq_adapt_irqs = 1000;
+module_param(irq_adapt_irqs, uint, 0644);
+MODULE_PARM_DESC(irq_adapt_irqs,
+		 "Number of IRQs per IRQ moderation adaptation");
+
+static unsigned int rx_ring = EFX_DEFAULT_DMAQ_SIZE;
+module_param(rx_ring, uint, 0644);
+MODULE_PARM_DESC(rx_ring,
+		 "Maximum number of descriptors in a receive ring");
+
+static unsigned int tx_ring = EFX_DEFAULT_DMAQ_SIZE;
+module_param(tx_ring, uint, 0644);
+MODULE_PARM_DESC(tx_ring,
+		 "Maximum number of descriptors in a transmit ring");
+
 /**************************************************************************
  *
  * Utility functions and prototypes
  *
  *************************************************************************/
-static void efx_remove_channel(struct efx_channel *channel);
+
+static void efx_remove_channels(struct efx_nic *efx);
 static void efx_remove_port(struct efx_nic *efx);
 static void efx_fini_napi(struct efx_nic *efx);
-static void efx_fini_channels(struct efx_nic *efx);
+static void efx_fini_struct(struct efx_nic *efx);
 
 #define EFX_ASSERT_RESET_SERIALISED(efx)		\
 	do {						\
-		if (efx->state == STATE_RUNNING)	\
+		if ((efx->state == STATE_RUNNING) ||	\
+		    (efx->state == STATE_DISABLED))	\
 			ASSERT_RTNL();			\
 	} while (0)
 
@@ -162,17 +320,17 @@ static void efx_fini_channels(struct efx
  * never be concurrently called more than once on the same channel,
  * though different channels may be being processed concurrently.
  */
-static int efx_process_channel(struct efx_channel *channel, int rx_quota)
+static int efx_process_channel(struct efx_channel *channel, int budget)
 {
 	struct efx_nic *efx = channel->efx;
-	int rx_packets;
+	int spent;
 
 	if (unlikely(efx->reset_pending != RESET_TYPE_NONE ||
 		     !channel->enabled))
 		return 0;
 
-	rx_packets = falcon_process_eventq(channel, rx_quota);
-	if (rx_packets == 0)
+	spent = efx_nic_process_eventq(channel, budget);
+	if (spent == 0)
 		return 0;
 
 	/* Deliver last RX packet. */
@@ -182,11 +340,14 @@ static int efx_process_channel(struct ef
 		channel->rx_pkt = NULL;
 	}
 
+#if defined(EFX_NOT_UPSTREAM) && defined(EFX_USE_SFC_LRO)
+	efx_ssr_end_of_burst(channel);
+#endif
 	efx_rx_strategy(channel);
 
-	efx_fast_push_rx_descriptors(&efx->rx_queue[channel->channel]);
+	efx_fast_push_rx_descriptors(efx_channel_get_rx_queue(channel));
 
-	return rx_packets;
+	return spent;
 }
 
 /* Mark channel as finished processing
@@ -203,7 +364,7 @@ static inline void efx_channel_processed
 	channel->work_pending = false;
 	smp_wmb();
 
-	falcon_eventq_read_ack(channel);
+	efx_nic_eventq_read_ack(channel);
 }
 
 /* NAPI poll handler
@@ -211,43 +372,49 @@ static inline void efx_channel_processed
  * NAPI guarantees serialisation of polls of the same device, which
  * provides the guarantee required by efx_process_channel().
  */
+#if !defined(EFX_USE_KCOMPAT) || !defined(EFX_HAVE_OLD_NAPI)
 static int efx_poll(struct napi_struct *napi, int budget)
 {
 	struct efx_channel *channel =
 		container_of(napi, struct efx_channel, napi_str);
-	int rx_packets;
+#else
+static int efx_poll(struct net_device *dev, int *budget_ret)
+{
+	struct efx_channel *channel = dev->priv;
+	struct napi_struct *napi = &channel->napi_str;
+	int budget = min(dev->quota, *budget_ret);
+#endif
+	struct efx_nic *efx = channel->efx;
+	int spent;
 
-	EFX_TRACE(channel->efx, "channel %d NAPI poll executing on CPU %d\n",
-		  channel->channel, raw_smp_processor_id());
+	netif_vdbg(efx, intr, efx->net_dev,
+		   "channel %d NAPI poll executing on CPU %d\n",
+		   channel->channel, raw_smp_processor_id());
 
-	rx_packets = efx_process_channel(channel, budget);
+	spent = efx_process_channel(channel, budget);
+#if defined(EFX_USE_KCOMPAT) && defined(EFX_HAVE_OLD_NAPI)
+	dev->quota -= spent;
+	*budget_ret -= spent;
+#endif
 
-	if (rx_packets < budget) {
-		struct efx_nic *efx = channel->efx;
-
-		if (channel->used_flags & EFX_USED_BY_RX &&
+	if (spent < budget) {
+		if (channel->channel < efx->n_rx_channels &&
 		    efx->irq_rx_adaptive &&
-		    unlikely(++channel->irq_count == 1000)) {
-			unsigned old_irq_moderation = channel->irq_moderation;
-
+		    unlikely(++channel->irq_count == irq_adapt_irqs)) {
 			if (unlikely(channel->irq_mod_score <
 				     irq_adapt_low_thresh)) {
-				channel->irq_moderation =
-					max_t(int,
-					      channel->irq_moderation -
-					      FALCON_IRQ_MOD_RESOLUTION,
-					      FALCON_IRQ_MOD_RESOLUTION);
+				if (channel->irq_moderation > 1) {
+					channel->irq_moderation -= 1;
+					efx->type->push_irq_moderation(channel);
+				}
 			} else if (unlikely(channel->irq_mod_score >
 					    irq_adapt_high_thresh)) {
-				channel->irq_moderation =
-					min(channel->irq_moderation +
-					    FALCON_IRQ_MOD_RESOLUTION,
-					    efx->irq_rx_moderation);
+				if (channel->irq_moderation <
+				    efx->irq_rx_moderation) {
+					channel->irq_moderation += 1;
+					efx->type->push_irq_moderation(channel);
+				}
 			}
-
-			if (channel->irq_moderation != old_irq_moderation)
-				falcon_set_int_moderation(channel);
-
 			channel->irq_count = 0;
 			channel->irq_mod_score = 0;
 		}
@@ -261,7 +428,11 @@ static int efx_poll(struct napi_struct *
 		efx_channel_processed(channel);
 	}
 
-	return rx_packets;
+#if !defined(EFX_USE_KCOMPAT) || !defined(EFX_HAVE_OLD_NAPI)
+	return spent;
+#else
+	return (spent >= budget);
+#endif
 }
 
 /* Process the eventq of the specified channel immediately on this CPU
@@ -276,11 +447,11 @@ void efx_process_channel_now(struct efx_
 {
 	struct efx_nic *efx = channel->efx;
 
-	BUG_ON(!channel->used_flags);
+	BUG_ON(channel->channel >= efx->n_channels);
 	BUG_ON(!channel->enabled);
 
 	/* Disable interrupts and wait for ISRs to complete */
-	falcon_disable_interrupts(efx);
+	efx_nic_disable_interrupts(efx);
 	if (efx->legacy_irq)
 		synchronize_irq(efx->legacy_irq);
 	if (channel->irq)
@@ -290,14 +461,14 @@ void efx_process_channel_now(struct efx_
 	napi_disable(&channel->napi_str);
 
 	/* Poll the channel */
-	efx_process_channel(channel, efx->type->evq_size);
+	efx_process_channel(channel, channel->eventq_mask + 1);
 
 	/* Ack the eventq. This may cause an interrupt to be generated
 	 * when they are reenabled */
 	efx_channel_processed(channel);
 
 	napi_enable(&channel->napi_str);
-	falcon_enable_interrupts(efx);
+	efx_nic_enable_interrupts(efx);
 }
 
 /* Create event queue
@@ -307,33 +478,46 @@ void efx_process_channel_now(struct efx_
  */
 static int efx_probe_eventq(struct efx_channel *channel)
 {
-	EFX_LOG(channel->efx, "chan %d create event queue\n", channel->channel);
+	struct efx_nic *efx = channel->efx;
+	unsigned long entries;
 
-	return falcon_probe_eventq(channel);
+	netif_dbg(efx, probe, channel->efx->net_dev,
+		  "chan %d create event queue\n", channel->channel);
+
+	/* Build an event queue with room for one event per tx and rx buffer,
+	 * plus some extra for link state events and MCDI completions. */
+	entries = roundup_pow_of_two(efx->rxq_entries + efx->txq_entries + 128);
+	EFX_BUG_ON_PARANOID(entries > EFX_MAX_EVQ_SIZE);
+	channel->eventq_mask = max(entries, EFX_MIN_EVQ_SIZE) - 1;
+
+	return efx_nic_probe_eventq(channel);
 }
 
 /* Prepare channel's event queue */
 static void efx_init_eventq(struct efx_channel *channel)
 {
-	EFX_LOG(channel->efx, "chan %d init event queue\n", channel->channel);
+	netif_dbg(channel->efx, drv, channel->efx->net_dev,
+		  "chan %d init event queue\n", channel->channel);
 
 	channel->eventq_read_ptr = 0;
 
-	falcon_init_eventq(channel);
+	efx_nic_init_eventq(channel);
 }
 
 static void efx_fini_eventq(struct efx_channel *channel)
 {
-	EFX_LOG(channel->efx, "chan %d fini event queue\n", channel->channel);
+	netif_dbg(channel->efx, drv, channel->efx->net_dev,
+		  "chan %d fini event queue\n", channel->channel);
 
-	falcon_fini_eventq(channel);
+	efx_nic_fini_eventq(channel);
 }
 
 static void efx_remove_eventq(struct efx_channel *channel)
 {
-	EFX_LOG(channel->efx, "chan %d remove event queue\n", channel->channel);
+	netif_dbg(channel->efx, drv, channel->efx->net_dev,
+		  "chan %d remove event queue\n", channel->channel);
 
-	falcon_remove_eventq(channel);
+	efx_nic_remove_eventq(channel);
 }
 
 /**************************************************************************
@@ -342,13 +526,71 @@ static void efx_remove_eventq(struct efx
  *
  *************************************************************************/
 
+/* Allocate and initialise a channel structure, optionally copying
+ * parameters (but not resources) from an old channel structure. */
+static struct efx_channel *
+efx_alloc_channel(struct efx_nic *efx, int i, struct efx_channel *old_channel)
+{
+	struct efx_channel *channel;
+	struct efx_rx_queue *rx_queue;
+	struct efx_tx_queue *tx_queue;
+	int j;
+
+	if (old_channel) {
+		channel = kmalloc(sizeof(*channel), GFP_KERNEL);
+		if (!channel)
+			return NULL;
+
+		*channel = *old_channel;
+
+		memset(&channel->eventq, 0, sizeof(channel->eventq));
+
+		rx_queue = &channel->rx_queue;
+		rx_queue->buffer = NULL;
+		memset(&rx_queue->rxd, 0, sizeof(rx_queue->rxd));
+
+		for (j = 0; j < EFX_TXQ_TYPES; j++) {
+			tx_queue = &channel->tx_queue[j];
+			if (tx_queue->channel)
+				tx_queue->channel = channel;
+			tx_queue->buffer = NULL;
+			memset(&tx_queue->txd, 0, sizeof(tx_queue->txd));
+		}
+	} else {
+		channel = kzalloc(sizeof(*channel), GFP_KERNEL);
+		if (!channel)
+			return NULL;
+
+		channel->efx = efx;
+		channel->channel = i;
+
+		for (j = 0; j < EFX_TXQ_TYPES; j++) {
+			tx_queue = &channel->tx_queue[j];
+			tx_queue->efx = efx;
+			tx_queue->queue = i * EFX_TXQ_TYPES + j;
+			tx_queue->channel = channel;
+		}
+	}
+
+	spin_lock_init(&channel->tx_stop_lock);
+	atomic_set(&channel->tx_stop_count, 1);
+
+	rx_queue = &channel->rx_queue;
+	rx_queue->efx = efx;
+	setup_timer(&rx_queue->slow_fill, efx_rx_slow_fill,
+		    (unsigned long)rx_queue);
+
+	return channel;
+}
+
 static int efx_probe_channel(struct efx_channel *channel)
 {
 	struct efx_tx_queue *tx_queue;
 	struct efx_rx_queue *rx_queue;
 	int rc;
 
-	EFX_LOG(channel->efx, "creating channel %d\n", channel->channel);
+	netif_dbg(channel->efx, probe, channel->efx->net_dev,
+		  "creating channel %d\n", channel->channel);
 
 	rc = efx_probe_eventq(channel);
 	if (rc)
@@ -380,7 +622,6 @@ static int efx_probe_channel(struct efx_
 	return rc;
 }
 
-
 static void efx_set_channel_names(struct efx_nic *efx)
 {
 	struct efx_channel *channel;
@@ -388,18 +629,51 @@ static void efx_set_channel_names(struct
 	int number;
 
 	efx_for_each_channel(channel, efx) {
+		if (efx->vf_count && channel->channel == efx->n_channels - 1) {
+			snprintf(efx->channel_name[channel->channel],
+				 sizeof(efx->channel_name[0]),
+				 "%s-iov", efx->name);
+			continue;
+		}
 		number = channel->channel;
-		if (efx->n_channels > efx->n_rx_queues) {
-			if (channel->channel < efx->n_rx_queues) {
+		if (efx->n_channels > efx->n_rx_channels) {
+			if (channel->channel < efx->n_rx_channels) {
 				type = "-rx";
 			} else {
 				type = "-tx";
-				number -= efx->n_rx_queues;
+				number -= efx->n_rx_channels;
 			}
 		}
-		snprintf(channel->name, sizeof(channel->name),
+		snprintf(efx->channel_name[channel->channel],
+			 sizeof(efx->channel_name[0]),
 			 "%s%s-%d", efx->name, type, number);
 	}
+}
+
+static int efx_probe_channels(struct efx_nic *efx)
+{
+	struct efx_channel *channel;
+	int rc;
+
+	/* Buffer table is reserved for the maximum supported ring sizes */
+	efx->resources.buffer_table_min = 0;
+
+	efx_for_each_channel(channel, efx) {
+		rc = efx_probe_channel(channel);
+		if (rc) {
+			netif_err(efx, probe, efx->net_dev,
+				  "failed to create channel %d\n",
+				  channel->channel);
+			goto fail;
+		}
+	}
+	efx_set_channel_names(efx);
+
+	return 0;
+
+fail:
+	efx_remove_channels(efx);
+	return rc;
 }
 
 /* Channels are shutdown and reinitialised whilst the NIC is running
@@ -418,12 +692,15 @@ static void efx_init_channels(struct efx
 	 */
 	efx->rx_buffer_len = (max(EFX_PAGE_IP_ALIGN, NET_IP_ALIGN) +
 			      EFX_MAX_FRAME_LEN(efx->net_dev->mtu) +
+			      efx->type->rx_buffer_hash_size +
 			      efx->type->rx_buffer_padding);
-	efx->rx_buffer_order = get_order(efx->rx_buffer_len);
+	efx->rx_buffer_order = get_order(efx->rx_buffer_len +
+					 sizeof(struct efx_rx_page_state));
 
 	/* Initialise the channels */
 	efx_for_each_channel(channel, efx) {
-		EFX_LOG(channel->efx, "init chan %d\n", channel->channel);
+		netif_dbg(channel->efx, drv, channel->efx->net_dev,
+			  "init chan %d\n", channel->channel);
 
 		efx_init_eventq(channel);
 
@@ -450,7 +727,8 @@ static void efx_start_channel(struct efx
 {
 	struct efx_rx_queue *rx_queue;
 
-	EFX_LOG(channel->efx, "starting chan %d\n", channel->channel);
+	netif_dbg(channel->efx, ifup, channel->efx->net_dev,
+		  "starting chan %d\n", channel->channel);
 
 	/* The interrupt handler for this channel may set work_pending
 	 * as soon as we enable it.  Make sure it's cleared before
@@ -459,11 +737,11 @@ static void efx_start_channel(struct efx
 	channel->enabled = true;
 	smp_wmb();
 
-	napi_enable(&channel->napi_str);
-
-	/* Load up RX descriptors */
+	/* Fill the queues before enabling NAPI */
 	efx_for_each_channel_rx_queue(rx_queue, channel)
 		efx_fast_push_rx_descriptors(rx_queue);
+
+	napi_enable(&channel->napi_str);
 }
 
 /* This disables event queue processing and packet transmission.
@@ -472,21 +750,14 @@ static void efx_start_channel(struct efx
  */
 static void efx_stop_channel(struct efx_channel *channel)
 {
-	struct efx_rx_queue *rx_queue;
-
 	if (!channel->enabled)
 		return;
 
-	EFX_LOG(channel->efx, "stop chan %d\n", channel->channel);
+	netif_dbg(channel->efx, ifdown, channel->efx->net_dev,
+		  "stop chan %d\n", channel->channel);
 
 	channel->enabled = false;
 	napi_disable(&channel->napi_str);
-
-	/* Ensure that any worker threads have exited or will be no-ops */
-	efx_for_each_channel_rx_queue(rx_queue, channel) {
-		spin_lock_bh(&rx_queue->add_lock);
-		spin_unlock_bh(&rx_queue->add_lock);
-	}
 }
 
 static void efx_fini_channels(struct efx_nic *efx)
@@ -499,14 +770,25 @@ static void efx_fini_channels(struct efx
 	EFX_ASSERT_RESET_SERIALISED(efx);
 	BUG_ON(efx->port_enabled);
 
-	rc = falcon_flush_queues(efx);
-	if (rc)
-		EFX_ERR(efx, "failed to flush queues\n");
-	else
-		EFX_LOG(efx, "successfully flushed all queues\n");
+	rc = efx_nic_flush_queues(efx);
+	if (rc && EFX_WORKAROUND_7803(efx)) {
+		/* Schedule a reset to recover from the flush failure. The
+		 * descriptor caches reference memory we're about to free,
+		 * but falcon_reconfigure_mac_wrapper() won't reconnect
+		 * the MACs because of the pending reset. */
+		netif_err(efx, drv, efx->net_dev,
+			  "Resetting to recover from flush failure\n");
+		efx_schedule_reset(efx, RESET_TYPE_ALL);
+	} else if (rc) {
+		EFX_FATAL(efx, drv, efx->net_dev, "failed to flush queues\n");
+	} else {
+		netif_dbg(efx, drv, efx->net_dev,
+			  "successfully flushed all queues\n");
+	}
 
 	efx_for_each_channel(channel, efx) {
-		EFX_LOG(channel->efx, "shut down chan %d\n", channel->channel);
+		netif_dbg(channel->efx, drv, channel->efx->net_dev,
+			  "shut down chan %d\n", channel->channel);
 
 		efx_for_each_channel_rx_queue(rx_queue, channel)
 			efx_fini_rx_queue(rx_queue);
@@ -521,20 +803,88 @@ static void efx_remove_channel(struct ef
 	struct efx_tx_queue *tx_queue;
 	struct efx_rx_queue *rx_queue;
 
-	EFX_LOG(channel->efx, "destroy chan %d\n", channel->channel);
+	netif_dbg(channel->efx, drv, channel->efx->net_dev,
+		  "destroy chan %d\n", channel->channel);
 
 	efx_for_each_channel_rx_queue(rx_queue, channel)
 		efx_remove_rx_queue(rx_queue);
 	efx_for_each_channel_tx_queue(tx_queue, channel)
 		efx_remove_tx_queue(tx_queue);
 	efx_remove_eventq(channel);
-
-	channel->used_flags = 0;
 }
 
-void efx_schedule_slow_fill(struct efx_rx_queue *rx_queue, int delay)
+static void efx_remove_channels(struct efx_nic *efx)
 {
-	queue_delayed_work(refill_workqueue, &rx_queue->work, delay);
+	struct efx_channel *channel;
+
+	efx_for_each_channel(channel, efx)
+		efx_remove_channel(channel);
+}
+
+int
+efx_realloc_channels(struct efx_nic *efx, u32 rxq_entries, u32 txq_entries)
+{
+	struct efx_channel *other_channel[EFX_MAX_CHANNELS], *channel;
+	u32 old_rxq_entries, old_txq_entries;
+	unsigned i;
+	int rc;
+
+	efx_stop_all(efx);
+	efx_fini_channels(efx);
+
+	/* Clone channels */
+	memset(other_channel, 0, sizeof(other_channel));
+	for (i = 0; i < efx->n_channels; i++) {
+		channel = efx_alloc_channel(efx, i, efx->channel[i]);
+		if (!channel) {
+			rc = -ENOMEM;
+			goto out;
+		}
+		other_channel[i] = channel;
+	}
+
+	/* Swap entry counts and channel pointers */
+	old_rxq_entries = efx->rxq_entries;
+	old_txq_entries = efx->txq_entries;
+	efx->rxq_entries = rxq_entries;
+	efx->txq_entries = txq_entries;
+	for (i = 0; i < efx->n_channels; i++) {
+		channel = efx->channel[i];
+		efx->channel[i] = other_channel[i];
+		other_channel[i] = channel;
+	}
+
+	rc = efx_probe_channels(efx);
+	if (rc)
+		goto rollback;
+
+	/* Destroy old channels */
+	for (i = 0; i < efx->n_channels; i++)
+		efx_remove_channel(other_channel[i]);
+out:
+	/* Free unused channel structures */
+	for (i = 0; i < efx->n_channels; i++)
+		kfree(other_channel[i]);
+
+	efx_init_channels(efx);
+	efx_start_all(efx);
+	return rc;
+
+rollback:
+	/* Swap back */
+	efx->rxq_entries = old_rxq_entries;
+	efx->txq_entries = old_txq_entries;
+	for (i = 0; i < efx->n_channels; i++) {
+		channel = efx->channel[i];
+		efx->channel[i] = other_channel[i];
+		other_channel[i] = channel;
+	}
+	goto out;
+}
+
+void efx_schedule_slow_fill(struct efx_rx_queue *rx_queue)
+{
+	mod_timer(&rx_queue->slow_fill, jiffies + msecs_to_jiffies(100));
 }
 
 /**************************************************************************
@@ -547,8 +897,10 @@ void efx_schedule_slow_fill(struct efx_r
  * netif_carrier_on/off) of the link status, and also maintains the
  * link status's stop on the port's TX queue.
  */
-static void efx_link_status_changed(struct efx_nic *efx)
+void efx_link_status_changed(struct efx_nic *efx)
 {
+	struct efx_link_state *link_state = &efx->link_state;
+
 	/* SFC Bug 5356: A net_dev notifier is registered, so we must ensure
 	 * that no events are triggered between unregister_netdev() and the
 	 * driver unloading. A more general condition is that NETDEV_CHANGE
@@ -561,37 +913,85 @@ static void efx_link_status_changed(stru
 		return;
 	}
 
-	if (efx->link_up != netif_carrier_ok(efx->net_dev)) {
+	if (link_state->up != netif_carrier_ok(efx->net_dev)) {
 		efx->n_link_state_changes++;
 
-		if (efx->link_up)
+		if (link_state->up)
 			netif_carrier_on(efx->net_dev);
 		else
 			netif_carrier_off(efx->net_dev);
 	}
 
 	/* Status message for kernel log */
-	if (efx->link_up) {
-		EFX_INFO(efx, "link up at %uMbps %s-duplex (MTU %d)%s\n",
-			 efx->link_speed, efx->link_fd ? "full" : "half",
-			 efx->net_dev->mtu,
-			 (efx->promiscuous ? " [PROMISC]" : ""));
+	if (link_state->up) {
+		netif_info(efx, link, efx->net_dev,
+			   "link up at %uMbps %s-duplex (MTU %d)%s%s%s%s\n",
+			   link_state->speed, link_state->fd ? "full" : "half",
+			   efx->net_dev->mtu,
+			   (efx->loopback_mode ? " [" : ""),
+			   (efx->loopback_mode ? LOOPBACK_MODE(efx) : ""),
+			   (efx->loopback_mode ? " LOOPBACK]" : ""),
+			   (efx->promiscuous ? " [PROMISC]" : ""));
+
+		if ((efx->wanted_fc & EFX_FC_AUTO) &&
+		    (efx->wanted_fc & EFX_FC_TX) &&
+		    (~efx->link_state.fc & EFX_FC_TX))
+			/* There is no way to report this state
+			 * through ethtool, so print this information
+			 * to the kernel log */
+			netif_info(efx, link, efx->net_dev,
+				   "Flow control autonegotiated "
+				   "tx OFF (wanted ON)\n");
 	} else {
-		EFX_INFO(efx, "link down\n");
+		netif_info(efx, link, efx->net_dev, "link down%s\n",
+			   (efx->phy_mode & PHY_MODE_LOW_POWER) ? " [OFF]" : "");
 	}
 
 }
 
+void efx_link_set_advertising(struct efx_nic *efx, u32 advertising)
+{
+	efx->link_advertising = advertising;
+	if (advertising & ADVERTISED_Autoneg) {
+		if (advertising & ADVERTISED_Pause)
+			efx->wanted_fc |= (EFX_FC_TX | EFX_FC_RX);
+		else
+			efx->wanted_fc &= ~(EFX_FC_TX | EFX_FC_RX);
+		if (advertising & ADVERTISED_Asym_Pause)
+			efx->wanted_fc ^= EFX_FC_TX;
+	}
+}
+
+void efx_link_set_wanted_fc(struct efx_nic *efx, enum efx_fc_type wanted_fc)
+{
+	efx->wanted_fc = wanted_fc;
+	if (efx->link_advertising & ADVERTISED_Autoneg) {
+		if (wanted_fc & EFX_FC_RX)
+			efx->link_advertising |= (ADVERTISED_Pause |
+						  ADVERTISED_Asym_Pause);
+		else
+			efx->link_advertising &= ~(ADVERTISED_Pause |
+						   ADVERTISED_Asym_Pause);
+		if (wanted_fc & EFX_FC_TX)
+			efx->link_advertising ^= ADVERTISED_Asym_Pause;
+	}
+}
+
 static void efx_fini_port(struct efx_nic *efx);
 
-/* This call reinitialises the MAC to pick up new PHY settings. The
- * caller must hold the mac_lock */
-void __efx_reconfigure_port(struct efx_nic *efx)
+/* Push loopback/power/transmit disable settings to the PHY, and reconfigure
+ * the MAC appropriately. All other PHY configuration changes are pushed
+ * through phy_op->set_settings(), and pushed asynchronously to the MAC
+ * through efx_monitor().
+ *
+ * Callers must hold the mac_lock
+ */
+int __efx_reconfigure_port(struct efx_nic *efx)
 {
+	enum efx_phy_mode phy_mode;
+	int rc;
+
 	WARN_ON(!mutex_is_locked(&efx->mac_lock));
-
-	EFX_LOG(efx, "reconfiguring MAC from PHY settings on CPU %d\n",
-		raw_smp_processor_id());
 
 	/* Serialise the promiscuous flag with efx_set_multicast_list. */
 	if (efx_dev_registered(efx)) {
@@ -599,97 +999,108 @@ void __efx_reconfigure_port(struct efx_n
 		netif_addr_unlock_bh(efx->net_dev);
 	}
 
-	falcon_deconfigure_mac_wrapper(efx);
-
-	/* Reconfigure the PHY, disabling transmit in mac level loopback. */
+	/* Disable PHY transmit in mac level loopbacks */
+	phy_mode = efx->phy_mode;
 	if (LOOPBACK_INTERNAL(efx))
 		efx->phy_mode |= PHY_MODE_TX_DISABLED;
 	else
 		efx->phy_mode &= ~PHY_MODE_TX_DISABLED;
-	efx->phy_op->reconfigure(efx);
 
-	if (falcon_switch_mac(efx))
-		goto fail;
+	rc = efx->type->reconfigure_port(efx);
 
-	efx->mac_op->reconfigure(efx);
+	if (rc)
+		efx->phy_mode = phy_mode;
 
-	/* Inform kernel of loss/gain of carrier */
-	efx_link_status_changed(efx);
-	return;
-
-fail:
-	EFX_ERR(efx, "failed to reconfigure MAC\n");
-	efx->port_enabled = false;
-	efx_fini_port(efx);
+	return rc;
 }
 
 /* Reinitialise the MAC to pick up new PHY settings, even if the port is
  * disabled. */
-void efx_reconfigure_port(struct efx_nic *efx)
+int efx_reconfigure_port(struct efx_nic *efx)
 {
+	int rc;
+
 	EFX_ASSERT_RESET_SERIALISED(efx);
 
 	mutex_lock(&efx->mac_lock);
-	__efx_reconfigure_port(efx);
+	rc = __efx_reconfigure_port(efx);
 	mutex_unlock(&efx->mac_lock);
+
+	return rc;
 }
 
-/* Asynchronous efx_reconfigure_port work item. To speed up efx_flush_all()
- * we don't efx_reconfigure_port() if the port is disabled. Care is taken
- * in efx_stop_all() and efx_start_port() to prevent PHY events being lost */
-static void efx_phy_work(struct work_struct *data)
-{
-	struct efx_nic *efx = container_of(data, struct efx_nic, phy_work);
-
-	mutex_lock(&efx->mac_lock);
-	if (efx->port_enabled)
-		__efx_reconfigure_port(efx);
-	mutex_unlock(&efx->mac_lock);
-}
-
+/* Asynchronous work item for changing MAC promiscuity and multicast
+ * hash.  Avoid a drain/rx_ingress enable by reconfiguring the current
+ * MAC directly. */
 static void efx_mac_work(struct work_struct *data)
 {
 	struct efx_nic *efx = container_of(data, struct efx_nic, mac_work);
 
 	mutex_lock(&efx->mac_lock);
-	if (efx->port_enabled)
-		efx->mac_op->irq(efx);
+	if (efx->port_enabled) {
+		efx->type->push_multicast_hash(efx);
+		efx->mac_op->reconfigure(efx);
+	}
 	mutex_unlock(&efx->mac_lock);
 }
 
 static int efx_probe_port(struct efx_nic *efx)
 {
+#if defined(EFX_USE_KCOMPAT) && defined(EFX_USE_PRINT_MAC)
+	DECLARE_MAC_BUF(buf);
+#endif
 	int rc;
 
-	EFX_LOG(efx, "create port\n");
-
-	/* Connect up MAC/PHY operations table and read MAC address */
-	rc = falcon_probe_port(efx);
-	if (rc)
-		goto err;
+	netif_dbg(efx, probe, efx->net_dev, "create port\n");
 
 	if (phy_flash_cfg)
 		efx->phy_mode = PHY_MODE_SPECIAL;
+
+	/* Register debugfs entries */
+	rc = efx_init_debugfs_port(efx);
+	if (rc)
+		return rc;
+
+	/* Connect up MAC/PHY operations table */
+	rc = efx->type->probe_port(efx);
+	if (rc)
+		goto fail1;
 
 	/* Sanity check MAC address */
 	if (is_valid_ether_addr(efx->mac_address)) {
 		memcpy(efx->net_dev->dev_addr, efx->mac_address, ETH_ALEN);
 	} else {
-		EFX_ERR(efx, "invalid MAC address %pM\n",
-			efx->mac_address);
 		if (!allow_bad_hwaddr) {
+#if !defined(EFX_USE_KCOMPAT) || !defined(EFX_USE_PRINT_MAC)
+			netif_err(efx, probe, efx->net_dev,
+				  "invalid MAC address %pM\n",
+				  efx->mac_address);
+#else
+			netif_err(efx, probe, efx->net_dev,
+				  "invalid MAC address %s\n",
+				  print_mac(buf, efx->mac_address));
+#endif
 			rc = -EINVAL;
-			goto err;
+			goto fail2;
 		}
 		random_ether_addr(efx->net_dev->dev_addr);
-		EFX_INFO(efx, "using locally-generated MAC %pM\n",
-			 efx->net_dev->dev_addr);
+#if !defined(EFX_USE_KCOMPAT) || !defined(EFX_USE_PRINT_MAC)
+		netif_info(efx, probe, efx->net_dev,
+			   "using locally-generated MAC %pM\n",
+			   efx->net_dev->dev_addr);
+#else
+		netif_info(efx, probe, efx->net_dev,
+			   "using locally-generated MAC %s\n",
+			   print_mac(buf, efx->net_dev->dev_addr));
+#endif
 	}
 
 	return 0;
 
- err:
-	efx_remove_port(efx);
+fail2:
+	efx->type->remove_port(efx);
+fail1:
+	efx_fini_debugfs_port(efx);
 	return rc;
 }
 
@@ -697,56 +1108,60 @@ static int efx_init_port(struct efx_nic 
 {
 	int rc;
 
-	EFX_LOG(efx, "init port\n");
+	netif_dbg(efx, drv, efx->net_dev, "init port\n");
+
+	mutex_lock(&efx->mac_lock);
 
 	rc = efx->phy_op->init(efx);
 	if (rc)
-		return rc;
-	mutex_lock(&efx->mac_lock);
-	efx->phy_op->reconfigure(efx);
-	rc = falcon_switch_mac(efx);
-	mutex_unlock(&efx->mac_lock);
-	if (rc)
-		goto fail;
+		goto fail1;
+
+	efx->port_initialized = true;
+
+	/* Reconfigure the MAC before creating dma queues (required for
+	 * Falcon/A1 where RX_INGR_EN/TX_DRAIN_EN isn't supported) */
 	efx->mac_op->reconfigure(efx);
 
-	efx->port_initialized = true;
-	efx_stats_enable(efx);
+	/* Ensure the PHY advertises the correct flow control settings */
+	rc = efx->phy_op->reconfigure(efx);
+	if (rc)
+		goto fail2;
+
+	mutex_unlock(&efx->mac_lock);
 	return 0;
 
-fail:
+fail2:
 	efx->phy_op->fini(efx);
+fail1:
+	mutex_unlock(&efx->mac_lock);
 	return rc;
 }
 
-/* Allow efx_reconfigure_port() to be scheduled, and close the window
- * between efx_stop_port and efx_flush_all whereby a previously scheduled
- * efx_phy_work()/efx_mac_work() may have been cancelled */
 static void efx_start_port(struct efx_nic *efx)
 {
-	EFX_LOG(efx, "start port\n");
+	netif_dbg(efx, ifup, efx->net_dev, "start port\n");
 	BUG_ON(efx->port_enabled);
 
 	mutex_lock(&efx->mac_lock);
 	efx->port_enabled = true;
-	__efx_reconfigure_port(efx);
-	efx->mac_op->irq(efx);
+
+	/* efx_mac_work() might have been scheduled after efx_stop_port(),
+	 * and then cancelled by efx_flush_all() */
+	efx->type->push_multicast_hash(efx);
+	efx->mac_op->reconfigure(efx);
+
 	mutex_unlock(&efx->mac_lock);
 }
 
-/* Prevent efx_phy_work, efx_mac_work, and efx_monitor() from executing,
- * and efx_set_multicast_list() from scheduling efx_phy_work. efx_phy_work
- * and efx_mac_work may still be scheduled via NAPI processing until
- * efx_flush_all() is called */
+/* Prevent efx_mac_work() and efx_monitor() from working */
 static void efx_stop_port(struct efx_nic *efx)
 {
-	EFX_LOG(efx, "stop port\n");
+	netif_dbg(efx, ifdown, efx->net_dev, "stop port\n");
 
 	mutex_lock(&efx->mac_lock);
 	efx->port_enabled = false;
 	mutex_unlock(&efx->mac_lock);
 
-	/* Serialise against efx_set_multicast_list() */
 	if (efx_dev_registered(efx)) {
 		netif_addr_lock_bh(efx->net_dev);
 		netif_addr_unlock_bh(efx->net_dev);
@@ -755,24 +1170,24 @@ static void efx_stop_port(struct efx_nic
 
 static void efx_fini_port(struct efx_nic *efx)
 {
-	EFX_LOG(efx, "shut down port\n");
+	netif_dbg(efx, drv, efx->net_dev, "shut down port\n");
 
 	if (!efx->port_initialized)
 		return;
 
-	efx_stats_disable(efx);
 	efx->phy_op->fini(efx);
 	efx->port_initialized = false;
 
-	efx->link_up = false;
+	efx->link_state.up = false;
 	efx_link_status_changed(efx);
 }
 
 static void efx_remove_port(struct efx_nic *efx)
 {
-	EFX_LOG(efx, "destroying port\n");
+	netif_dbg(efx, drv, efx->net_dev, "destroying port\n");
 
-	falcon_remove_port(efx);
+	efx->type->remove_port(efx);
+	efx_fini_debugfs_port(efx);
 }
 
 /**************************************************************************
@@ -788,11 +1203,12 @@ static int efx_init_io(struct efx_nic *e
 	dma_addr_t dma_mask = efx->type->max_dma_mask;
 	int rc;
 
-	EFX_LOG(efx, "initialising I/O\n");
+	netif_dbg(efx, probe, efx->net_dev, "initialising I/O\n");
 
 	rc = pci_enable_device(pci_dev);
 	if (rc) {
-		EFX_ERR(efx, "failed to enable PCI device\n");
+		netif_err(efx, probe, efx->net_dev,
+			  "failed to enable PCI device\n");
 		goto fail1;
 	}
 
@@ -810,46 +1226,60 @@ static int efx_init_io(struct efx_nic *e
 		dma_mask >>= 1;
 	}
 	if (rc) {
-		EFX_ERR(efx, "could not find a suitable DMA mask\n");
+		netif_err(efx, probe, efx->net_dev,
+			  "could not find a suitable DMA mask\n");
 		goto fail2;
 	}
-	EFX_LOG(efx, "using DMA mask %llx\n", (unsigned long long) dma_mask);
+	netif_dbg(efx, probe, efx->net_dev,
+		  "using DMA mask %llx\n", (unsigned long long) dma_mask);
 	rc = pci_set_consistent_dma_mask(pci_dev, dma_mask);
 	if (rc) {
 		/* pci_set_consistent_dma_mask() is not *allowed* to
 		 * fail with a mask that pci_set_dma_mask() accepted,
 		 * but just in case...
 		 */
-		EFX_ERR(efx, "failed to set consistent DMA mask\n");
+		netif_err(efx, probe, efx->net_dev,
+			  "failed to set consistent DMA mask\n");
 		goto fail2;
 	}
 
-	efx->membase_phys = pci_resource_start(efx->pci_dev,
-					       efx->type->mem_bar);
-	rc = pci_request_region(pci_dev, efx->type->mem_bar, "sfc");
+	efx->membase_phys = pci_resource_start(efx->pci_dev, EFX_MEM_BAR);
+#if !defined(EFX_USE_KCOMPAT) || !defined(EFX_HAVE_MSIX_TABLE_RESERVED)
+	rc = pci_request_region(pci_dev, EFX_MEM_BAR, "sfc");
+#else
+	if (!request_mem_region(efx->membase_phys, efx->type->mem_map_size,
+				"sfc"))
+		rc = -EIO;
+#endif
 	if (rc) {
-		EFX_ERR(efx, "request for memory BAR failed\n");
+		netif_err(efx, probe, efx->net_dev,
+			  "request for memory BAR failed\n");
 		rc = -EIO;
 		goto fail3;
 	}
 	efx->membase = ioremap_nocache(efx->membase_phys,
 				       efx->type->mem_map_size);
 	if (!efx->membase) {
-		EFX_ERR(efx, "could not map memory BAR %d at %llx+%x\n",
-			efx->type->mem_bar,
-			(unsigned long long)efx->membase_phys,
-			efx->type->mem_map_size);
+		netif_err(efx, probe, efx->net_dev,
+			  "could not map memory BAR at %llx+%x\n",
+			  (unsigned long long)efx->membase_phys,
+			  efx->type->mem_map_size);
 		rc = -ENOMEM;
 		goto fail4;
 	}
-	EFX_LOG(efx, "memory BAR %u at %llx+%x (virtual %p)\n",
-		efx->type->mem_bar, (unsigned long long)efx->membase_phys,
-		efx->type->mem_map_size, efx->membase);
+	netif_dbg(efx, probe, efx->net_dev,
+		  "memory BAR at %llx+%x (virtual %p)\n",
+		  (unsigned long long)efx->membase_phys,
+		  efx->type->mem_map_size, efx->membase);
 
 	return 0;
 
  fail4:
-	pci_release_region(efx->pci_dev, efx->type->mem_bar);
+#if !defined(EFX_USE_KCOMPAT) || !defined(EFX_HAVE_MSIX_TABLE_RESERVED)
+	pci_release_region(efx->pci_dev, EFX_MEM_BAR);
+#else
+	release_mem_region(efx->membase_phys, efx->type->mem_map_size);
+#endif
  fail3:
 	efx->membase_phys = 0;
  fail2:
@@ -860,7 +1290,7 @@ static int efx_init_io(struct efx_nic *e
 
 static void efx_fini_io(struct efx_nic *efx)
 {
-	EFX_LOG(efx, "shutting down I/O\n");
+	netif_dbg(efx, drv, efx->net_dev, "shutting down I/O\n");
 
 	if (efx->membase) {
 		iounmap(efx->membase);
@@ -868,17 +1298,57 @@ static void efx_fini_io(struct efx_nic *
 	}
 
 	if (efx->membase_phys) {
-		pci_release_region(efx->pci_dev, efx->type->mem_bar);
+#if !defined(EFX_USE_KCOMPAT) || !defined(EFX_HAVE_MSIX_TABLE_RESERVED)
+		pci_release_region(efx->pci_dev, EFX_MEM_BAR);
+#else
+		release_mem_region(efx->membase_phys, efx->type->mem_map_size);
+#endif
 		efx->membase_phys = 0;
 	}
 
 	pci_disable_device(efx->pci_dev);
 }
 
-/* Get number of RX queues wanted.  Return number of online CPU
- * packages in the expectation that an IRQ balancer will spread
- * interrupts across them. */
-static int efx_wanted_rx_queues(void)
+#if !defined(EFX_USE_KCOMPAT) || (defined(topology_core_cpumask) && !defined(__VMKLNX__))
+#define HAVE_EFX_NUM_PACKAGES
+static int efx_num_packages(void)
+{
+	cpumask_var_t core_mask;
+	int count;
+	int cpu;
+
+	if (unlikely(!zalloc_cpumask_var(&core_mask, GFP_KERNEL))) {
+		printk(KERN_WARNING
+		       "sfc: RSS disabled due to allocation failure\n");
+		return 1;
+	}
+
+	count = 0;
+	for_each_online_cpu(cpu) {
+		if (!cpumask_test_cpu(cpu, core_mask)) {
+			++count;
+#if !defined(EFX_USE_KCOMPAT)
+			cpumask_or(core_mask, core_mask,
+				   topology_core_cpumask(cpu));
+#else
+			cpumask_or(core_mask, core_mask,
+				   topology_cpu_node_cpumask(cpu));
+#endif
+		}
+	}
+
+	/* Create two RSS queues even on a single package host */
+	if (count == 1)
+		count = 2;
+
+	free_cpumask_var(core_mask);
+	return count;
+}
+#endif
+
+#if !defined(EFX_USE_KCOMPAT) || (defined(topology_thread_cpumask) && !defined(__VMKLNX__) && defined(EFX_HAVE_EXPORTED_CPU_SIBLING_MAP))
+#define HAVE_EFX_NUM_CORES
+static int efx_num_cores(void)
 {
 	cpumask_var_t core_mask;
 	int count;
@@ -895,12 +1365,96 @@ static int efx_wanted_rx_queues(void)
 		if (!cpumask_test_cpu(cpu, core_mask)) {
 			++count;
 			cpumask_or(core_mask, core_mask,
-				   topology_core_cpumask(cpu));
+				   topology_thread_cpumask(cpu));
 		}
 	}
 
 	free_cpumask_var(core_mask);
 	return count;
+}
+#endif
+
+/* Get number of channels wanted.  Each channel will have its own IRQ,
+ * 1 RX queue and/or 2 TX queues. */
+static int efx_wanted_channels(struct efx_nic *efx)
+{
+	enum rss_mode rss_mode = EFX_RSS_PACKAGES;
+	bool selected = false;
+	int n_rxq = -1;
+
+	if (rss_cpus == NULL) {
+		/* Leave at default. */
+	} else if (strcmp(rss_cpus, "packages") == 0) {
+		rss_mode = EFX_RSS_PACKAGES;
+		selected = true;
+	} else if (strcmp(rss_cpus, "cores") == 0) {
+		rss_mode = EFX_RSS_CORES;
+		selected = true;
+	} else if (strcmp(rss_cpus, "hyperthreads") == 0) {
+		rss_mode = EFX_RSS_HYPERTHREADS;
+		selected = true;
+	} else if (sscanf(rss_cpus, "%d", &n_rxq) == 1 && n_rxq > 0) {
+		rss_mode = EFX_RSS_CUSTOM;
+		selected = true;
+	} else {
+		netif_err(efx, drv, efx->net_dev,
+			  "Bad value for module parameter rss_cpus='%s'\n",
+			  rss_cpus);
+	}
+
+	switch (rss_mode) {
+#if defined(HAVE_EFX_NUM_PACKAGES)
+	case EFX_RSS_PACKAGES:
+		if (xen_domain()) {
+			netif_warn(efx, drv, efx->net_dev,
+				   "Unable to determine CPU topology"
+				   " on Xen reliably. Using 4 rss channels.\n");
+			n_rxq = 4;
+		} else {
+			netif_dbg(efx,  drv, efx->net_dev,
+				  "using efx_num_packages()\n");
+			n_rxq = efx_num_packages();
+		}
+		break;
+#endif
+#if defined(HAVE_EFX_NUM_CORES)
+	case EFX_RSS_CORES:
+		if (xen_domain()) {
+			netif_warn(efx, drv, efx->net_dev,
+				   "Unable to determine CPU topology"
+				   " on Xen reliably. Assuming hyperthreading"
+				   " enabled.\n");
+			n_rxq = max_t(int, 1, num_online_cpus() / 2);
+		} else {
+			netif_dbg(efx, drv, efx->net_dev,
+				  "using efx_num_cores()\n");
+			n_rxq = efx_num_cores();
+		}
+		break;
+#endif
+	case EFX_RSS_HYPERTHREADS:
+		n_rxq = num_online_cpus();
+		break;
+	case EFX_RSS_CUSTOM:
+		break;
+	default:
+		if (selected)
+			netif_err(efx, drv, efx->net_dev,
+				  "Selected rss mode '%s' not available\n",
+				  rss_cpus);
+		rss_mode = EFX_RSS_HYPERTHREADS;
+		n_rxq = num_online_cpus();
+		break;
+	}
+
+	if (n_rxq > EFX_MAX_RX_QUEUES) {
+		netif_warn(efx, drv, efx->net_dev,
+			   "Reducing number of rss channels from %d to %d.\n",
+			   n_rxq, EFX_MAX_RX_QUEUES);
+		n_rxq = EFX_MAX_RX_QUEUES;
+	}
+
+	return n_rxq;
 }
 
 /* Probe the number and type of interrupts we are able to obtain, and
@@ -910,66 +1464,334 @@ static void efx_probe_interrupts(struct 
 {
 	int max_channels =
 		min_t(int, efx->type->phys_addr_channels, EFX_MAX_CHANNELS);
+	unsigned iov_channels = efx->vf_count ? 1 : 0;
 	int rc, i;
 
 	if (efx->interrupt_mode == EFX_INT_MODE_MSIX) {
 		struct msix_entry xentries[EFX_MAX_CHANNELS];
-		int wanted_ints;
-		int rx_queues;
+		int n_channels;
 
-		/* We want one RX queue and interrupt per CPU package
-		 * (or as specified by the rss_cpus module parameter).
-		 * We will need one channel per interrupt.
-		 */
-		rx_queues = rss_cpus ? rss_cpus : efx_wanted_rx_queues();
-		wanted_ints = rx_queues + (separate_tx_channels ? 1 : 0);
-		wanted_ints = min(wanted_ints, max_channels);
+		n_channels = efx_wanted_channels(efx);
+#if !defined(EFX_USE_KCOMPAT) || defined(EFX_USE_TX_MQ)
+		if (separate_tx_channels)
+			n_channels *= 2;
+#else
+		if (separate_tx_channels)
+			n_channels += 1;
+#endif
+		n_channels += iov_channels;
+		n_channels = min(n_channels, max_channels);
 
-		for (i = 0; i < wanted_ints; i++)
+		for (i = 0; i < n_channels; i++)
 			xentries[i].entry = i;
-		rc = pci_enable_msix(efx->pci_dev, xentries, wanted_ints);
+		rc = pci_enable_msix(efx->pci_dev, xentries, n_channels);
 		if (rc > 0) {
-			EFX_ERR(efx, "WARNING: Insufficient MSI-X vectors"
-				" available (%d < %d).\n", rc, wanted_ints);
-			EFX_ERR(efx, "WARNING: Performance may be reduced.\n");
-			EFX_BUG_ON_PARANOID(rc >= wanted_ints);
-			wanted_ints = rc;
+			netif_err(efx, drv, efx->net_dev,
+				  "WARNING: Insufficient MSI-X vectors"
+				  " available (%d < %d).\n", rc, n_channels);
+			netif_err(efx, drv, efx->net_dev,
+				  "WARNING: Performance may be reduced.\n");
+			EFX_BUG_ON_PARANOID(rc >= n_channels);
+		        n_channels = rc;
 			rc = pci_enable_msix(efx->pci_dev, xentries,
-					     wanted_ints);
+					     n_channels);
 		}
 
 		if (rc == 0) {
-			efx->n_rx_queues = min(rx_queues, wanted_ints);
-			efx->n_channels = wanted_ints;
-			for (i = 0; i < wanted_ints; i++)
-				efx->channel[i].irq = xentries[i].vector;
+			if (n_channels <= iov_channels) {
+				netif_err(efx, drv, efx->net_dev,
+					  "ERROR: Insufficient interrupts for "
+					  "IOV support. IOV disabled\n");
+				efx->vf_count = 0;
+			}
+			efx->n_channels = n_channels;
+			n_channels -= iov_channels;
+
+#if defined(EFX_USE_KCOMPAT) && !defined(EFX_USE_TX_MQ)
+			efx->n_tx_channels = 1;
+#endif
+			if (separate_tx_channels) {
+#if !defined(EFX_USE_KCOMPAT) || defined(EFX_USE_TX_MQ)
+				efx->n_tx_channels =
+					max(n_channels / 2, 1);
+#endif
+				efx->tx_channel_offset =
+					n_channels - efx->n_tx_channels;
+				efx->n_rx_channels =
+					max(n_channels -
+					    efx->n_tx_channels, 1U);
+			} else {
+#if !defined(EFX_USE_KCOMPAT) || defined(EFX_USE_TX_MQ)
+				efx->n_tx_channels = n_channels;
+#endif
+				efx->tx_channel_offset = 0;
+				efx->n_rx_channels = n_channels;
+			}
+			for (i = 0; i < efx->n_channels; i++)
+				efx_get_channel(efx, i)->irq =
+					xentries[i].vector;
 		} else {
 			/* Fall back to single channel MSI */
 			efx->interrupt_mode = EFX_INT_MODE_MSI;
-			EFX_ERR(efx, "could not enable MSI-X\n");
+			netif_err(efx, drv, efx->net_dev,
+				  "could not enable MSI-X\n");
 		}
+	} else if (efx->vf_count) {
+		netif_err(efx, drv, efx->net_dev,
+			  "ERROR: IOV is only supported with MSI-X interrupts\n");
+		efx->vf_count = 0;
 	}
 
 	/* Try single interrupt MSI */
 	if (efx->interrupt_mode == EFX_INT_MODE_MSI) {
-		efx->n_rx_queues = 1;
 		efx->n_channels = 1;
+		efx->n_rx_channels = 1;
+		efx->n_tx_channels = 1;
+		efx->tx_channel_offset = 0;
 		rc = pci_enable_msi(efx->pci_dev);
 		if (rc == 0) {
-			efx->channel[0].irq = efx->pci_dev->irq;
+			efx_get_channel(efx, 0)->irq = efx->pci_dev->irq;
 		} else {
-			EFX_ERR(efx, "could not enable MSI\n");
+			netif_err(efx, drv, efx->net_dev,
+				  "could not enable MSI\n");
 			efx->interrupt_mode = EFX_INT_MODE_LEGACY;
 		}
 	}
 
 	/* Assume legacy interrupts */
 	if (efx->interrupt_mode == EFX_INT_MODE_LEGACY) {
-		efx->n_rx_queues = 1;
 		efx->n_channels = 1 + (separate_tx_channels ? 1 : 0);
+		efx->n_rx_channels = 1;
+		efx->n_tx_channels = 1;
+		efx->tx_channel_offset = 0;
 		efx->legacy_irq = efx->pci_dev->irq;
 	}
 }
+
+#if defined(EFX_NOT_UPSTREAM) && defined(CONFIG_SMP) && !defined(__VMKLNX__)
+
+static int efx_irq_set_affinity = 1;
+module_param_named(irq_set_affinity, efx_irq_set_affinity, int, 0444);
+MODULE_PARM_DESC(irq_set_affinity,
+		 "Set SMP affinity of IRQs to support RSS "
+		 "(0=>disabled 1=>enabled (default))");
+
+static int efx_set_cpu_affinity(struct efx_channel *channel, int cpu)
+{
+	struct efx_nic *efx = channel->efx;
+	char *content, filename[64];
+	int content_len, rc = 0;
+	struct file *file;
+	mm_segment_t old_fs;
+	loff_t offset = 0;
+	ssize_t written;
+
+	/* Write the mask into a sufficient buffer. We need a byte
+	 * for every 4 bits of mask, plus comma's, plus a NULL. */
+	content_len = max(NR_CPUS, 8) / 2;
+	content = kmalloc(content_len, GFP_KERNEL);
+	if (!content)
+		return -ENOMEM;
+#ifdef EFX_HAVE_OLD_CPUMASK_SCNPRINTF
+	{
+		cpumask_t mask = cpumask_of_cpu(cpu);
+		cpumask_scnprintf(content, content_len, mask);
+	}
+#else
+	cpumask_scnprintf(content, content_len, cpumask_of(cpu));
+#endif
+
+	/* Open /proc/irq/XXX/smp_affinity */
+	snprintf(filename, sizeof(filename), "/proc/irq/%d/smp_affinity",
+		 channel->irq);
+	file = filp_open(filename, O_RDWR, 0);
+	if (IS_ERR(file)) {
+		netif_err(efx, drv, efx->net_dev,
+			  "Could not open %s: error %ld\n",
+			  filename, PTR_ERR(file));
+		rc = -EIO;
+		goto out1;
+	}
+
+	/* Write cpumask to file */
+	old_fs = get_fs();
+	set_fs(KERNEL_DS);
+	written = file->f_op->write(file, (__force __user char *)content,
+				    content_len, &offset);
+	set_fs(old_fs);
+
+	if (written != content_len) {
+		netif_err(efx, drv, efx->net_dev,
+			  "Unable to write affinity for channel %d"
+			  " interrupt %d\n", channel->channel, channel->irq);
+		rc = -EIO;
+		goto out2;
+	}
+
+	netif_dbg(efx, drv, efx->net_dev,
+		  "Set channel %d interrupt %d affinity\n",
+		  channel->channel, channel->irq);
+
+ out2:
+	filp_close(file, NULL);
+ out1:
+	kfree(content);
+
+	return rc;
+}
+
+/* Count of number of RSS channels allocated to each CPU
+ * in the system. Protected by the rtnl lock */
+static u16 *rss_cpu_usage;
+
+#ifdef HAVE_EFX_NUM_PACKAGES
+/* Select the package_set with the lowest useage count */
+static void efx_rss_choose_package(cpumask_t *set, cpumask_t *package_set,
+				   cpumask_t *used_set)
+{
+	unsigned int thresh, count;
+	int cpu, sibling;
+
+	thresh = 1;
+	for_each_online_cpu(cpu)
+		thresh += rss_cpu_usage[cpu];
+
+	cpumask_clear(used_set);
+	for_each_online_cpu(cpu) {
+		if (!cpumask_test_cpu(cpu, used_set)) {
+#if !defined(EFX_USE_KCOMPAT)
+			cpumask_copy(package_set,
+				     topology_core_cpumask(cpu));
+#else
+			cpumask_copy(package_set,
+				     topology_cpu_node_cpumask(cpu));
+#endif
+			cpumask_or(used_set, used_set, package_set);
+
+			count = 0;
+			for_each_cpu(sibling, package_set)
+				count += rss_cpu_usage[sibling];
+
+			if (count < thresh) {
+				cpumask_copy(set, package_set);
+				thresh = count;
+			}
+		}
+	}
+}
+#endif
+
+#ifdef HAVE_EFX_NUM_CORES
+/* Select the thread siblings within the package with the lowest usage count */
+static void efx_rss_choose_core(cpumask_t *set, const cpumask_t *package_set,
+				cpumask_t *core_set, cpumask_t *used_set)
+{
+	unsigned int thresh, count;
+	int cpu, sibling;
+
+	thresh = 1;
+	for_each_cpu(cpu, package_set)
+		thresh += rss_cpu_usage[cpu];
+
+	cpumask_clear(used_set);
+	for_each_cpu(cpu, package_set) {
+		if (!cpumask_test_cpu(cpu, used_set)) {
+			cpumask_copy(core_set, topology_thread_cpumask(cpu));
+			cpumask_or(used_set, used_set, core_set);
+
+			count = 0;
+			for_each_cpu(sibling, core_set)
+				count += rss_cpu_usage[sibling];
+
+			if (count < thresh) {
+				cpumask_copy(set, core_set);
+				thresh = count;
+			}
+		}
+	}
+}
+#endif
+
+/* Select the thread within the mask with the lowest usage count */
+static int efx_rss_choose_thread(const cpumask_t *set)
+{
+	int cpu, chosen;
+	unsigned int thresh;
+
+	thresh = 1;
+	for_each_cpu(cpu, set)
+		thresh += rss_cpu_usage[cpu];
+
+	chosen = 0;
+	for_each_cpu(cpu, set) {
+		if (rss_cpu_usage[cpu] < thresh) {
+			chosen = cpu;
+			thresh = rss_cpu_usage[cpu];
+		}
+	}
+
+	return chosen;
+}
+
+/* Stripe the RSS vectors across the CPUs. */
+static void efx_set_interrupt_affinity(struct efx_nic *efx)
+{
+	cpumask_var_t sets[4];
+	struct efx_channel *channel;
+	int cpu, sets_allocd;
+
+	/* Only do this for RSS/MSI-X */
+	if (efx->interrupt_mode != EFX_INT_MODE_MSIX)
+		return;
+
+	if (!efx_irq_set_affinity)
+		return;
+
+	for (sets_allocd = 0; sets_allocd < ARRAY_SIZE(sets); sets_allocd++) {
+		if (!zalloc_cpumask_var(&sets[sets_allocd], GFP_KERNEL)) {
+			netif_err(efx, drv, efx->net_dev,
+				  "Not enough temporary memory to"
+				  " set IRQ affinity\n");
+			goto out;
+		}
+	}
+
+	/* Serialise access to rss_cpu_usage */
+	rtnl_lock();
+
+	/* Assign each channel a CPU */
+	efx_for_each_channel(channel, efx) {
+#ifdef HAVE_EFX_NUM_PACKAGES
+		/* Select the package_set with the lowest useage count */
+		efx_rss_choose_package(sets[0], sets[2], sets[3]);
+		WARN_ON(!cpumask_weight(sets[0]));
+#else
+		cpumask_copy(sets[0], &cpu_online_map);
+#endif
+
+		/* Select the thread siblings within this package with the
+		 * lowest usage count */
+#ifdef HAVE_EFX_NUM_CORES
+		efx_rss_choose_core(sets[1], sets[0], sets[2], sets[3]);
+		WARN_ON(!cpumask_weight(sets[1]));
+#else
+		cpumask_copy(sets[1], sets[0]);
+#endif
+
+		/* Select the thread within this set with the lowest usage count */
+		cpu = efx_rss_choose_thread(sets[1]);
+		++rss_cpu_usage[cpu];
+		efx_set_cpu_affinity(channel, cpu);
+	}
+
+	rtnl_unlock();
+
+out:
+	while (sets_allocd--)
+		free_cpumask_var(sets[sets_allocd]);
+}
+
+#endif
 
 static void efx_remove_interrupts(struct efx_nic *efx)
 {
@@ -985,54 +1807,112 @@ static void efx_remove_interrupts(struct
 	efx->legacy_irq = 0;
 }
 
+struct efx_tx_queue *
+efx_get_tx_queue(struct efx_nic *efx, unsigned index, unsigned type)
+{
+	EFX_BUG_ON_PARANOID(index >= efx->n_tx_channels ||
+			    type >= EFX_TXQ_TYPES);
+	return &efx->channel[efx->tx_channel_offset + index]->tx_queue[type];
+}
+
 static void efx_set_channels(struct efx_nic *efx)
 {
+	struct efx_channel *channel;
 	struct efx_tx_queue *tx_queue;
-	struct efx_rx_queue *rx_queue;
 
-	efx_for_each_tx_queue(tx_queue, efx) {
-		if (separate_tx_channels)
-			tx_queue->channel = &efx->channel[efx->n_channels-1];
-		else
-			tx_queue->channel = &efx->channel[0];
-		tx_queue->channel->used_flags |= EFX_USED_BY_TX;
-	}
-
-	efx_for_each_rx_queue(rx_queue, efx) {
-		rx_queue->channel = &efx->channel[rx_queue->queue];
-		rx_queue->channel->used_flags |= EFX_USED_BY_RX;
+	/* Channel pointers were set in efx_init_struct() but we now
+	 * need to clear them for TX queues in any RX-only channels. */
+	efx_for_each_channel(channel, efx) {
+		if (channel->channel - efx->tx_channel_offset >=
+		    efx->n_tx_channels) {
+			efx_for_each_channel_tx_queue(tx_queue, channel)
+				tx_queue->channel = NULL;
+		}
 	}
 }
 
 static int efx_probe_nic(struct efx_nic *efx)
 {
+	size_t i;
 	int rc;
 
-	EFX_LOG(efx, "creating NIC\n");
+	netif_dbg(efx, probe, efx->net_dev, "creating NIC\n");
+
+	/* Initialise NIC resource information */
+	efx->resources = efx->type->resources;
+	efx->resources.biu_lock = &efx->biu_lock;
+	efx->dl_info = &efx->resources.hdr;
 
 	/* Carry out hardware-type specific initialisation */
-	rc = falcon_probe_nic(efx);
+	rc = efx->type->probe(efx);
 	if (rc)
-		return rc;
+		goto fail1;
 
-	/* Determine the number of channels and RX queues by trying to hook
+	/* Determine the number of channels and queues by trying to hook
 	 * in MSI-X interrupts. */
 	efx_probe_interrupts(efx);
 
+	if (EFX_INT_MODE_USE_MSI(efx))
+		efx->resources.flags |= EFX_DL_FALCON_USE_MSI;
+
+	if (efx->n_channels > 1)
+		get_random_bytes(&efx->rx_hash_key, sizeof(efx->rx_hash_key));
+
+#if defined(EFX_NOT_UPSTREAM) && defined(EFX_WITH_VMWARE_NETQ)
+	/* NetQ is there to do interrupt spreading under S/W control, so
+	 * we use the driver's rss_queues calculation to set up the correct
+	 * number of channels for the available CPUs but the RSS table
+	 * sends all unfiltered traffic to queue 0 */
+	(void)i;
+#else
+	for (i = 0; i < ARRAY_SIZE(efx->rx_indir_table); i++)
+		efx->rx_indir_table[i] = i % efx->n_rx_channels;
+#endif
+
 	efx_set_channels(efx);
+	netif_set_real_num_tx_queues(efx->net_dev, efx->n_tx_channels);
+	netif_set_real_num_rx_queues(efx->net_dev, efx->n_rx_channels);
 
+	/* Register debugfs entries */
+	rc = efx_init_debugfs_nic(efx);
+	if (rc)
+		goto fail2;
+#if defined(EFX_NOT_UPSTREAM) && defined(SFC_PCAP_SUPPORT)
+	rc = efx_pcap_nic_init(efx);
+	if (rc)
+		goto fail3;
+#endif
 	/* Initialise the interrupt moderation settings */
-	efx_init_irq_moderation(efx, tx_irq_mod_usec, rx_irq_mod_usec, true);
+	efx_init_irq_moderation(efx, tx_irq_mod_usec, rx_irq_mod_usec,
+				irq_adapt_enable);
 
 	return 0;
+
+#if defined(EFX_NOT_UPSTREAM) && defined(SFC_PCAP_SUPPORT)
+ fail3:
+	efx_fini_debugfs_nic(efx);
+#endif
+ fail2:
+	efx_remove_interrupts(efx);
+	efx->type->remove(efx);
+ fail1:
+	efx->dl_info = NULL;
+	return rc;
 }
 
 static void efx_remove_nic(struct efx_nic *efx)
 {
-	EFX_LOG(efx, "destroying NIC\n");
+	netif_dbg(efx, drv, efx->net_dev, "destroying NIC\n");
+
+#if defined(EFX_NOT_UPSTREAM) && defined(SFC_PCAP_SUPPORT)
+	efx_pcap_nic_fini(efx);
+#endif
 
 	efx_remove_interrupts(efx);
-	falcon_remove_nic(efx);
+	efx->type->remove(efx);
+	efx->dl_info = NULL;
+
+	efx_fini_debugfs_nic(efx);
 }
 
 /**************************************************************************
@@ -1043,39 +1923,56 @@ static void efx_remove_nic(struct efx_ni
 
 static int efx_probe_all(struct efx_nic *efx)
 {
-	struct efx_channel *channel;
 	int rc;
 
-	/* Create NIC */
 	rc = efx_probe_nic(efx);
 	if (rc) {
-		EFX_ERR(efx, "failed to create NIC\n");
+		netif_err(efx, probe, efx->net_dev, "failed to create NIC\n");
 		goto fail1;
 	}
 
-	/* Create port */
 	rc = efx_probe_port(efx);
 	if (rc) {
-		EFX_ERR(efx, "failed to create port\n");
+		netif_err(efx, probe, efx->net_dev, "failed to create port\n");
 		goto fail2;
 	}
 
-	/* Create channels */
-	efx_for_each_channel(channel, efx) {
-		rc = efx_probe_channel(channel);
-		if (rc) {
-			EFX_ERR(efx, "failed to create channel %d\n",
-				channel->channel);
-			goto fail3;
-		}
+	efx->rxq_entries = rx_ring;
+	efx->txq_entries = tx_ring;
+
+	if (efx->rxq_entries < EFX_MIN_RING_SIZE ||
+	    efx->rxq_entries > EFX_MAX_DMAQ_SIZE) {
+		netif_err(efx, drv, efx->net_dev,
+			  "rx_ring parameter must be between %ld and %ld",
+			  EFX_MIN_RING_SIZE, EFX_MAX_DMAQ_SIZE);
+		rc = -EINVAL;
+		goto fail3;
 	}
-	efx_set_channel_names(efx);
+	if (efx->txq_entries < EFX_MIN_RING_SIZE ||
+	    efx->txq_entries > EFX_MAX_DMAQ_SIZE) {
+		netif_err(efx, drv, efx->net_dev,
+			  "tx_ring parameter must be between %ld and %ld",
+			  EFX_MIN_RING_SIZE, EFX_MAX_DMAQ_SIZE);
+		rc = -EINVAL;
+		goto fail3;
+	}
+
+	rc = efx_probe_channels(efx);
+	if (rc)
+		goto fail3;
+
+	rc = efx_probe_filters(efx);
+	if (rc) {
+		netif_err(efx, probe, efx->net_dev,
+			  "failed to create filter tables\n");
+		goto fail4;
+	}
 
 	return 0;
 
+ fail4:
+	efx_remove_channels(efx);
  fail3:
-	efx_for_each_channel(channel, efx)
-		efx_remove_channel(channel);
 	efx_remove_port(efx);
  fail2:
 	efx_remove_nic(efx);
@@ -1088,7 +1985,7 @@ static int efx_probe_all(struct efx_nic 
  * and ensures that the port is scheduled to be reconfigured.
  * This function is safe to call multiple times when the NIC is in any
  * state. */
-static void efx_start_all(struct efx_nic *efx)
+void efx_start_all(struct efx_nic *efx)
 {
 	struct efx_channel *channel;
 
@@ -1106,18 +2003,45 @@ static void efx_start_all(struct efx_nic
 	/* Mark the port as enabled so port reconfigurations can start, then
 	 * restart the transmit interface early so the watchdog timer stops */
 	efx_start_port(efx);
-	if (efx_dev_registered(efx))
-		efx_wake_queue(efx);
 
-	efx_for_each_channel(channel, efx)
+	efx_for_each_channel(channel, efx) {
+		if (efx_dev_registered(efx))
+			efx_wake_queue(channel);
 		efx_start_channel(channel);
+	}
 
-	falcon_enable_interrupts(efx);
+	efx_nic_enable_interrupts(efx);
 
-	/* Start hardware monitor if we're in RUNNING */
+	/* Switch to event based MCDI completions after enabling interrupts.
+	 * If a reset has been scheduled, then we need to stay in polled mode.
+	 * Rather than serialising efx_mcdi_mode_event() [which sleeps] and
+	 * reset_pending [modified from an atomic context], we instead guarantee
+	 * that efx_mcdi_mode_poll() isn't reverted erroneously */
+#if EFX_NOT_UPSTREAM
 	if (efx->state == STATE_RUNNING)
+#endif
+	efx_mcdi_mode_event(efx);
+	if (efx->reset_pending != RESET_TYPE_NONE)
+		efx_mcdi_mode_poll(efx);
+
+	/* Start the hardware monitor if there is one. Otherwise (we're link
+	 * event driven), we have to poll the PHY because after an event queue
+	 * flush, we could have a missed a link state change */
+	if (efx->type->monitor != NULL) {
+#if !defined(EFX_USE_KCOMPAT) || !defined(EFX_NEED_WORK_API_WRAPPERS)
 		queue_delayed_work(efx->workqueue, &efx->monitor_work,
 				   efx_monitor_interval);
+#else
+		queue_work(efx->workqueue, &efx->monitor_work);
+#endif
+	} else {
+		mutex_lock(&efx->mac_lock);
+		if (efx->phy_op->poll(efx))
+			efx_link_status_changed(efx);
+		mutex_unlock(&efx->mac_lock);
+	}
+
+	efx->type->start_stats(efx);
 }
 
 /* Flush all delayed work. Should only be called when no more delayed work
@@ -1125,19 +2049,28 @@ static void efx_start_all(struct efx_nic
  * since we're holding the rtnl_lock at this point. */
 static void efx_flush_all(struct efx_nic *efx)
 {
-	struct efx_rx_queue *rx_queue;
-
+#if !defined(EFX_USE_KCOMPAT) || defined(EFX_USE_CANCEL_DELAYED_WORK_SYNC)
 	/* Make sure the hardware monitor is stopped */
 	cancel_delayed_work_sync(&efx->monitor_work);
-
-	/* Ensure that all RX slow refills are complete. */
-	efx_for_each_rx_queue(rx_queue, efx)
-		cancel_delayed_work_sync(&rx_queue->work);
-
+#endif
+#if !defined(EFX_USE_KCOMPAT) || defined(EFX_USE_CANCEL_WORK_SYNC)
 	/* Stop scheduled port reconfigurations */
 	cancel_work_sync(&efx->mac_work);
-	cancel_work_sync(&efx->phy_work);
-
+#endif
+#if defined(EFX_USE_KCOMPAT) && !defined(EFX_USE_CANCEL_DELAYED_WORK_SYNC)
+	/* Ensure efx_monitor() and efx_mac_work() are complete, which
+	 * are the only two consumers of efx->workqueue. Since the hardware
+	 * monitor runs on a long period, we put in some effort to cancel
+	 * the delayed work safely rather than just flushing the queue twice
+	 * (which is guaranteed to flush all the work since efx_monitor(),
+	 * and efx_mac_work() disarm if !efx->port_enabled). */
+	if (timer_pending(&efx->monitor_work.timer))
+		cancel_delayed_work(&efx->monitor_work);
+	flush_workqueue(efx->workqueue);
+	if (timer_pending(&efx->monitor_work.timer))
+		cancel_delayed_work(&efx->monitor_work);
+	flush_workqueue(efx->workqueue);
+#endif
 }
 
 /* Quiesce hardware and software without bringing the link down.
@@ -1145,7 +2078,7 @@ static void efx_flush_all(struct efx_nic
  * state. The caller is guaranteed to subsequently be in a position
  * to modify any hardware and software state they see fit without
  * taking locks. */
-static void efx_stop_all(struct efx_nic *efx)
+void efx_stop_all(struct efx_nic *efx)
 {
 	struct efx_channel *channel;
 
@@ -1155,8 +2088,13 @@ static void efx_stop_all(struct efx_nic 
 	if (!efx->port_enabled)
 		return;
 
+	efx->type->stop_stats(efx);
+
+	/* Switch to MCDI polling on Siena before disabling interrupts */
+	efx_mcdi_mode_poll(efx);
+
 	/* Disable interrupts and wait for ISR to complete */
-	falcon_disable_interrupts(efx);
+	efx_nic_disable_interrupts(efx);
 	if (efx->legacy_irq)
 		synchronize_irq(efx->legacy_irq);
 	efx_for_each_channel(channel, efx) {
@@ -1173,19 +2111,15 @@ static void efx_stop_all(struct efx_nic 
 	 * window to loose phy events */
 	efx_stop_port(efx);
 
-	/* Flush efx_phy_work, efx_mac_work, refill_workqueue, monitor_work */
+	/* Flush efx_mac_work(), refill_workqueue and efx_monitor_work() */
 	efx_flush_all(efx);
-
-	/* Isolate the MAC from the TX and RX engines, so that queue
-	 * flushes will complete in a timely fashion. */
-	falcon_deconfigure_mac_wrapper(efx);
-	msleep(10); /* Let the Rx FIFO drain */
-	falcon_drain_tx_fifo(efx);
 
 	/* Stop the kernel transmit interface late, so the watchdog
 	 * timer isn't ticking over the flush */
 	if (efx_dev_registered(efx)) {
-		efx_stop_queue(efx);
+		struct efx_channel *channel;
+		efx_for_each_channel(channel, efx)
+			efx_stop_queue(channel);
 		netif_tx_lock_bh(efx->net_dev);
 		netif_tx_unlock_bh(efx->net_dev);
 	}
@@ -1193,26 +2127,32 @@ static void efx_stop_all(struct efx_nic 
 
 static void efx_remove_all(struct efx_nic *efx)
 {
-	struct efx_channel *channel;
-
-	efx_for_each_channel(channel, efx)
-		efx_remove_channel(channel);
+	efx_remove_filters(efx);
+	efx_remove_channels(efx);
 	efx_remove_port(efx);
 	efx_remove_nic(efx);
 }
 
-/* A convinience function to safely flush all the queues */
-void efx_flush_queues(struct efx_nic *efx)
+#ifdef EFX_NOT_UPSTREAM
+static int efx_run_selftests(struct efx_nic *efx)
 {
-	EFX_ASSERT_RESET_SERIALISED(efx);
+	struct efx_self_tests tests;
+	int rc;
 
-	efx_stop_all(efx);
-
-	efx_fini_channels(efx);
-	efx_init_channels(efx);
-
-	efx_start_all(efx);
+	rc = efx_selftest(efx, &tests,
+			  EFX_TEST_FL_ONLOAD |
+			  (onload_offline_selftest ? ETH_TEST_FL_OFFLINE : 0));
+	if (rc)
+		netif_err(efx, probe, efx->net_dev,
+			  "FAILED self-tests with interrupt_mode of %s\n",
+			  INT_MODE(efx));
+	else
+		netif_dbg(efx, probe, efx->net_dev,
+			  "PASSED self-tests with interrupt_mode of %s\n",
+			  INT_MODE(efx));
+	return allow_load_on_failure ? 0 : rc;
 }
+#endif /* EFX_NOT_UPSTREAM */
 
 /**************************************************************************
  *
@@ -1220,22 +2160,33 @@ void efx_flush_queues(struct efx_nic *ef
  *
  **************************************************************************/
 
+static unsigned irq_mod_ticks(int usecs, int resolution)
+{
+	if (usecs <= 0)
+		return 0; /* cannot receive interrupts ahead of time :-) */
+	if (usecs < resolution)
+		return 1; /* never round down to 0 */
+	return usecs / resolution;
+}
+
 /* Set interrupt moderation parameters */
 void efx_init_irq_moderation(struct efx_nic *efx, int tx_usecs, int rx_usecs,
 			     bool rx_adaptive)
 {
-	struct efx_tx_queue *tx_queue;
-	struct efx_rx_queue *rx_queue;
+	struct efx_channel *channel;
+	unsigned tx_ticks = irq_mod_ticks(tx_usecs, EFX_IRQ_MOD_RESOLUTION);
+	unsigned rx_ticks = irq_mod_ticks(rx_usecs, EFX_IRQ_MOD_RESOLUTION);
 
 	EFX_ASSERT_RESET_SERIALISED(efx);
 
-	efx_for_each_tx_queue(tx_queue, efx)
-		tx_queue->channel->irq_moderation = tx_usecs;
-
 	efx->irq_rx_adaptive = rx_adaptive;
-	efx->irq_rx_moderation = rx_usecs;
-	efx_for_each_rx_queue(rx_queue, efx)
-		rx_queue->channel->irq_moderation = rx_usecs;
+	efx->irq_rx_moderation = rx_ticks;
+	efx_for_each_channel(channel, efx) {
+		if (efx_channel_get_rx_queue(channel))
+			channel->irq_moderation = rx_ticks;
+		else if (efx_channel_get_tx_queue(channel, 0))
+			channel->irq_moderation = tx_ticks;
+	}
 }
 
 /**************************************************************************
@@ -1244,37 +2195,43 @@ void efx_init_irq_moderation(struct efx_
  *
  **************************************************************************/
 
-/* Run periodically off the general workqueue. Serialised against
- * efx_reconfigure_port via the mac_lock */
+/* Run periodically off the general workqueue */
 static void efx_monitor(struct work_struct *data)
 {
+#if !defined(EFX_USE_KCOMPAT) || !defined(EFX_NEED_WORK_API_WRAPPERS)
 	struct efx_nic *efx = container_of(data, struct efx_nic,
 					   monitor_work.work);
-	int rc;
+#else
+	struct efx_nic *efx = container_of(data, struct efx_nic,
+					   monitor_work);
+#endif
 
-	EFX_TRACE(efx, "hardware monitor executing on CPU %d\n",
-		  raw_smp_processor_id());
-
+	netif_vdbg(efx, timer, efx->net_dev,
+		   "hardware monitor executing on CPU %d\n",
+		   raw_smp_processor_id());
+	BUG_ON(efx->type->monitor == NULL);
+#if defined(EFX_NOT_UPSTREAM) && defined(__VMKERNEL_MODULE__)
+        efx_vmware_monitor_checks(efx);
+#endif
+#if defined(EFX_USE_KCOMPAT) && !defined(EFX_USE_CANCEL_DELAYED_WORK_SYNC)
+	/* Without cancel_delayed_work_sync(), we have to make sure that
+	 * we don't rearm when !port_enabled */
+	mutex_lock(&efx->mac_lock);
+	if (!efx->port_enabled) {
+		mutex_unlock(&efx->mac_lock);
+		return;
+	} else {
+#else
 	/* If the mac_lock is already held then it is likely a port
 	 * reconfiguration is already in place, which will likely do
 	 * most of the work of check_hw() anyway. */
-	if (!mutex_trylock(&efx->mac_lock))
-		goto out_requeue;
-	if (!efx->port_enabled)
-		goto out_unlock;
-	rc = efx->board_info.monitor(efx);
-	if (rc) {
-		EFX_ERR(efx, "Board sensor %s; shutting down PHY\n",
-			(rc == -ERANGE) ? "reported fault" : "failed");
-		efx->phy_mode |= PHY_MODE_LOW_POWER;
-		falcon_sim_phy_event(efx);
+	if (mutex_trylock(&efx->mac_lock)) {
+#endif
+		if (efx->port_enabled)
+			efx->type->monitor(efx);
+		mutex_unlock(&efx->mac_lock);
 	}
-	efx->phy_op->poll(efx);
-	efx->mac_op->poll(efx);
 
-out_unlock:
-	mutex_unlock(&efx->mac_lock);
-out_requeue:
 	queue_delayed_work(efx->workqueue, &efx->monitor_work,
 			   efx_monitor_interval);
 }
@@ -1293,7 +2250,26 @@ static int efx_ioctl(struct net_device *
 	struct efx_nic *efx = netdev_priv(net_dev);
 	struct mii_ioctl_data *data = if_mii(ifr);
 
+#if defined(EFX_USE_KCOMPAT) && defined(EFX_NEED_BONDING_HACKS)
+	if (in_interrupt())
+		/* We can't execute mdio requests from an atomic context
+		 * on Siena. Luckily, the bonding driver falls back to
+		 * the ethtool API if this command fails. */
+		return -ENOSYS;
+#endif
 	EFX_ASSERT_RESET_SERIALISED(efx);
+
+#if defined(EFX_NOT_UPSTREAM) || (defined(EFX_USE_KCOMPAT) && !defined(EFX_HAVE_ETHTOOL_RESET))
+	if (cmd == SIOCEFX) {
+		struct efx_sock_ioctl __user *user_data =
+			(struct efx_sock_ioctl __user *)ifr->ifr_data;
+		u16 efx_cmd;
+
+		if (copy_from_user(&efx_cmd, &user_data->cmd, sizeof(efx_cmd)))
+			return -EFAULT;
+		return efx_private_ioctl(efx, efx_cmd, &user_data->u);
+	}
+#endif
 
 	/* Convert phy_id from older PRTAD/DEVAD format */
 	if ((cmd == SIOCGMIIREG || cmd == SIOCSMIIREG) &&
@@ -1314,9 +2290,34 @@ static int efx_init_napi(struct efx_nic 
 	struct efx_channel *channel;
 
 	efx_for_each_channel(channel, efx) {
+#if !defined(EFX_USE_KCOMPAT) || !defined(EFX_HAVE_OLD_NAPI)
 		channel->napi_dev = efx->net_dev;
+#else
+		channel->napi_dev = alloc_etherdev(0);
+		if (!channel->napi_dev) {
+			efx_fini_napi(efx);
+			return -ENOMEM;
+		}
+		channel->napi_dev->priv = channel;
+		atomic_set(&channel->napi_dev->refcnt, 1);
+#if defined(EFX_USE_GRO)
+		channel->napi_str.dev = efx->net_dev;
+#endif
+#if defined(__VMKLNX__)
+		channel->napi_str.dev = channel->napi_dev;
+#endif
+#endif
 		netif_napi_add(channel->napi_dev, &channel->napi_str,
 			       efx_poll, napi_weight);
+#if defined(EFX_NOT_UPSTREAM) && defined(EFX_USE_SFC_LRO)
+		{
+			int rc = efx_ssr_init(channel, efx);
+			if (rc) {
+				efx_fini_napi(efx);
+				return rc;
+			}
+		}
+#endif
 	}
 	return 0;
 }
@@ -1326,8 +2327,17 @@ static void efx_fini_napi(struct efx_nic
 	struct efx_channel *channel;
 
 	efx_for_each_channel(channel, efx) {
+#if defined(EFX_NOT_UPSTREAM) && defined(EFX_USE_SFC_LRO)
+		efx_ssr_fini(channel);
+#endif
 		if (channel->napi_dev)
 			netif_napi_del(&channel->napi_str);
+#if defined(EFX_USE_KCOMPAT) && defined(EFX_HAVE_OLD_NAPI)
+		if (channel->napi_dev) {
+			channel->napi_dev->priv = NULL;
+			free_netdev(channel->napi_dev);
+		}
+#endif
 		channel->napi_dev = NULL;
 	}
 }
@@ -1367,13 +2377,21 @@ static int efx_net_open(struct net_devic
 	struct efx_nic *efx = netdev_priv(net_dev);
 	EFX_ASSERT_RESET_SERIALISED(efx);
 
-	EFX_LOG(efx, "opening device %s on CPU %d\n", net_dev->name,
-		raw_smp_processor_id());
+	netif_dbg(efx, ifup, efx->net_dev, "opening device on CPU %d\n",
+		  raw_smp_processor_id());
 
-	if (efx->state == STATE_DISABLED)
+	if (efx->state == STATE_DISABLED) {
+		netif_err(efx, ifup, efx->net_dev, "Device is disabled.\n");
 		return -EIO;
+	}
 	if (efx->phy_mode & PHY_MODE_SPECIAL)
 		return -EBUSY;
+	if (efx_mcdi_poll_reboot(efx) && efx_reset(efx, RESET_TYPE_ALL))
+		return -EIO;
+
+	/* Notify the kernel of the link state polled during driver load,
+	 * before the monitor starts running */
+	efx_link_status_changed(efx);
 
 	efx_start_all(efx);
 	return 0;
@@ -1387,8 +2405,8 @@ static int efx_net_stop(struct net_devic
 {
 	struct efx_nic *efx = netdev_priv(net_dev);
 
-	EFX_LOG(efx, "closing %s on CPU %d\n", net_dev->name,
-		raw_smp_processor_id());
+	netif_dbg(efx, ifdown, efx->net_dev, "closing on CPU %d\n",
+		  raw_smp_processor_id());
 
 	if (efx->state != STATE_DISABLED) {
 		/* Stop the device and flush all the channels */
@@ -1400,48 +2418,37 @@ static int efx_net_stop(struct net_devic
 	return 0;
 }
 
-void efx_stats_disable(struct efx_nic *efx)
-{
-	spin_lock(&efx->stats_lock);
-	++efx->stats_disable_count;
-	spin_unlock(&efx->stats_lock);
-}
-
-void efx_stats_enable(struct efx_nic *efx)
-{
-	spin_lock(&efx->stats_lock);
-	--efx->stats_disable_count;
-	spin_unlock(&efx->stats_lock);
-}
-
 /* Context: process, dev_base_lock or RTNL held, non-blocking. */
+#if !defined(EFX_USE_KCOMPAT) || defined(EFX_USE_NETDEV_STATS64)
+static struct rtnl_link_stats64 *efx_net_stats(struct net_device *net_dev,
+					       struct rtnl_link_stats64 *stats)
+#else
 static struct net_device_stats *efx_net_stats(struct net_device *net_dev)
+#endif
 {
 	struct efx_nic *efx = netdev_priv(net_dev);
 	struct efx_mac_stats *mac_stats = &efx->mac_stats;
+#if defined(EFX_USE_KCOMPAT) && !defined(EFX_USE_NETDEV_STATS64) 
+#if defined(EFX_USE_NETDEV_STATS)
 	struct net_device_stats *stats = &net_dev->stats;
+#else
+	struct net_device_stats *stats = &efx->stats;
+#endif
+#endif
 
-	/* Update stats if possible, but do not wait if another thread
-	 * is updating them or if MAC stats fetches are temporarily
-	 * disabled; slightly stale stats are acceptable.
-	 */
-	if (!spin_trylock(&efx->stats_lock))
-		return stats;
-	if (!efx->stats_disable_count) {
-		efx->mac_op->update_stats(efx);
-		falcon_update_nic_stats(efx);
-	}
-	spin_unlock(&efx->stats_lock);
+	spin_lock_bh(&efx->stats_lock);
+	efx->type->update_stats(efx);
+	spin_unlock_bh(&efx->stats_lock);
 
 	stats->rx_packets = mac_stats->rx_packets;
 	stats->tx_packets = mac_stats->tx_packets;
 	stats->rx_bytes = mac_stats->rx_bytes;
 	stats->tx_bytes = mac_stats->tx_bytes;
+	stats->rx_dropped = efx->n_rx_nodesc_drop_cnt;
 	stats->multicast = mac_stats->rx_multicast;
 	stats->collisions = mac_stats->tx_collision;
 	stats->rx_length_errors = (mac_stats->rx_gtjumbo +
 				   mac_stats->rx_length_error);
-	stats->rx_over_errors = efx->n_rx_nodesc_drop_cnt;
 	stats->rx_crc_errors = mac_stats->rx_bad;
 	stats->rx_frame_errors = mac_stats->rx_align_error;
 	stats->rx_fifo_errors = mac_stats->rx_overflow;
@@ -1449,11 +2456,8 @@ static struct net_device_stats *efx_net_
 	stats->tx_window_errors = mac_stats->tx_late_collision;
 
 	stats->rx_errors = (stats->rx_length_errors +
-			    stats->rx_over_errors +
 			    stats->rx_crc_errors +
 			    stats->rx_frame_errors +
-			    stats->rx_fifo_errors +
-			    stats->rx_missed_errors +
 			    mac_stats->rx_symbol_error);
 	stats->tx_errors = (stats->tx_window_errors +
 			    mac_stats->tx_bad);
@@ -1466,9 +2470,9 @@ static void efx_watchdog(struct net_devi
 {
 	struct efx_nic *efx = netdev_priv(net_dev);
 
-	EFX_ERR(efx, "TX stuck with stop_count=%d port_enabled=%d:"
-		" resetting channels\n",
-		atomic_read(&efx->netif_stop_count), efx->port_enabled);
+	netif_err(efx, tx_err, efx->net_dev,
+		  "TX stuck with port_enabled=%d: resetting channels\n",
+		  efx->port_enabled);
 
 	efx_schedule_reset(efx, RESET_TYPE_TX_WATCHDOG);
 }
@@ -1489,13 +2493,24 @@ static int efx_change_mtu(struct net_dev
 
 	/* Ask driverlink client if we can change MTU */
 	rc = EFX_DL_CALLBACK(efx, request_mtu, new_mtu);
-	if (rc)
+	if (rc) {
+		netif_err(efx, drv, efx->net_dev,
+			  "MTU change vetoed by driverlink %s driver\n",
+			  efx->dl_cb_dev.request_mtu->driver->name);
 		goto out;
+	}
 
-	EFX_LOG(efx, "changing MTU to %d\n", new_mtu);
+	netif_dbg(efx, drv, efx->net_dev, "changing MTU to %d\n", new_mtu);
 
 	efx_fini_channels(efx);
+
+	mutex_lock(&efx->mac_lock);
+	/* Reconfigure the MAC before enabling the dma queues so that
+	 * the RX buffers don't overflow */
 	net_dev->mtu = new_mtu;
+	efx->mac_op->reconfigure(efx);
+	mutex_unlock(&efx->mac_lock);
+
 	efx_init_channels(efx);
 
 	/* Notify driverlink client of new MTU */
@@ -1510,20 +2525,32 @@ static int efx_set_mac_address(struct ne
 {
 	struct efx_nic *efx = netdev_priv(net_dev);
 	struct sockaddr *addr = data;
-	char *new_addr = addr->sa_data;
+	u8 *new_addr = addr->sa_data;
 
 	EFX_ASSERT_RESET_SERIALISED(efx);
 
 	if (!is_valid_ether_addr(new_addr)) {
-		EFX_ERR(efx, "invalid ethernet MAC address requested: %pM\n",
-			new_addr);
+#if !defined(EFX_USE_KCOMPAT) || !defined(EFX_USE_PRINT_MAC)
+		netif_err(efx, drv, efx->net_dev,
+			  "invalid ethernet MAC address requested: %pM\n",
+			  new_addr);
+#else
+		DECLARE_MAC_BUF(mac);
+		netif_err(efx, drv, efx->net_dev,
+			  "invalid ethernet MAC address requested: %s\n",
+			  print_mac(mac, new_addr));
+#endif
 		return -EINVAL;
 	}
 
 	memcpy(net_dev->dev_addr, new_addr, net_dev->addr_len);
+	if (efx->vf_count)
+		efx_sriov_mac_address_changed(efx);
 
 	/* Reconfigure the MAC */
-	efx_reconfigure_port(efx);
+	mutex_lock(&efx->mac_lock);
+	efx->mac_op->reconfigure(efx);
+	mutex_unlock(&efx->mac_lock);
 
 	return 0;
 }
@@ -1532,44 +2559,70 @@ static void efx_set_multicast_list(struc
 static void efx_set_multicast_list(struct net_device *net_dev)
 {
 	struct efx_nic *efx = netdev_priv(net_dev);
-	struct dev_mc_list *mc_list = net_dev->mc_list;
+#if !defined(EFX_USE_KCOMPAT) || !defined(EFX_USE_DEV_MC_LIST)
+	struct netdev_hw_addr *ha;
+#else
+	struct dev_mc_list *ha;
+#endif
 	union efx_multicast_hash *mc_hash = &efx->multicast_hash;
-	bool promiscuous = !!(net_dev->flags & IFF_PROMISC);
-	bool changed = (efx->promiscuous != promiscuous);
 	u32 crc;
 	int bit;
-	int i;
 
-	efx->promiscuous = promiscuous;
+	efx->promiscuous = !!(net_dev->flags & IFF_PROMISC);
 
 	/* Build multicast hash table */
-	if (promiscuous || (net_dev->flags & IFF_ALLMULTI)) {
+	if (efx->promiscuous || (net_dev->flags & IFF_ALLMULTI)) {
 		memset(mc_hash, 0xff, sizeof(*mc_hash));
 	} else {
 		memset(mc_hash, 0x00, sizeof(*mc_hash));
-		for (i = 0; i < net_dev->mc_count; i++) {
-			crc = ether_crc_le(ETH_ALEN, mc_list->dmi_addr);
+		netdev_for_each_mc_addr(ha, net_dev) {
+#if !defined(EFX_USE_KCOMPAT) || !defined(EFX_USE_DEV_MC_LIST)
+			crc = ether_crc_le(ETH_ALEN, ha->addr);
+#else
+			crc = ether_crc_le(ETH_ALEN, ha->dmi_addr);
+#endif
 			bit = crc & (EFX_MCAST_HASH_ENTRIES - 1);
 			set_bit_le(bit, mc_hash->byte);
-			mc_list = mc_list->next;
 		}
+
+		/* Broadcast packets go through the multicast hash filter.
+		 * ether_crc_le() of the broadcast address is 0xbe2612ff
+		 * so we always add bit 0xff to the mask.
+		 */
+		set_bit_le(0xff, mc_hash->byte);
 	}
 
-	if (!efx->port_enabled)
-		/* Delay pushing settings until efx_start_port() */
-		return;
-
-	if (changed)
-		queue_work(efx->workqueue, &efx->phy_work);
-
-	/* Create and activate new global multicast hash table */
-	falcon_set_multicast_hash(efx);
+	if (efx->port_enabled)
+		queue_work(efx->workqueue, &efx->mac_work);
+	/* Otherwise efx_start_port() will do this */
 }
 
+#if defined(EFX_NOT_UPSTREAM) && defined(EFX_USE_FAKE_VLAN_RX_ACCEL)
+static void
+efx_vlan_rx_register(struct net_device *dev, struct vlan_group *vlan_group)
+{
+	struct efx_nic *efx = netdev_priv(dev);
+	efx->vlan_group = vlan_group;
+}
+
+#ifdef EFX_USE_VLAN_RX_KILL_VID
+static void efx_vlan_rx_kill_vid(struct net_device *dev, unsigned short vid)
+{
+	/* Nothing to do since we don't filter */
+}
+#endif
+
+#endif /* EFX_NOT_UPSTREAM */
+
+#if !defined(EFX_USE_KCOMPAT) || defined(HAVE_NET_DEVICE_OPS)
 static const struct net_device_ops efx_netdev_ops = {
 	.ndo_open		= efx_net_open,
 	.ndo_stop		= efx_net_stop,
+#if !defined(EFX_USE_KCOMPAT) || defined(EFX_USE_NETDEV_STATS64)
+	.ndo_get_stats64	= efx_net_stats,
+#else
 	.ndo_get_stats		= efx_net_stats,
+#endif
 	.ndo_tx_timeout		= efx_watchdog,
 	.ndo_start_xmit		= efx_hard_start_xmit,
 	.ndo_validate_addr	= eth_validate_addr,
@@ -1577,16 +2630,31 @@ static const struct net_device_ops efx_n
 	.ndo_change_mtu		= efx_change_mtu,
 	.ndo_set_mac_address	= efx_set_mac_address,
 	.ndo_set_multicast_list = efx_set_multicast_list,
+#if defined(CONFIG_SFC_SRIOV) && (!defined(EFX_USE_KCOMPAT) || defined(EFX_HAVE_NDO_SET_VF_MAC))
+	.ndo_set_vf_mac		= efx_sriov_set_vf_mac,
+	.ndo_set_vf_vlan	= efx_sriov_set_vf_vlan,
+	.ndo_get_vf_config	= efx_sriov_get_vf_config,
+#endif
+#if defined(EFX_NOT_UPSTREAM) && defined(EFX_USE_FAKE_VLAN_RX_ACCEL)
+	.ndo_vlan_rx_register	= efx_vlan_rx_register,
+#endif
 #ifdef CONFIG_NET_POLL_CONTROLLER
 	.ndo_poll_controller = efx_netpoll,
 #endif
 };
+#endif
 
 static void efx_update_name(struct efx_nic *efx)
 {
 	strcpy(efx->name, efx->net_dev->name);
 	efx_mtd_rename(efx);
 	efx_set_channel_names(efx);
+#ifdef CONFIG_SFC_DEBUGFS
+	if (efx->debug_symlink) {
+		efx_fini_debugfs_netdev(efx->net_dev);
+		efx_init_debugfs_netdev(efx->net_dev);
+	}
+#endif
 }
 
 static int efx_netdev_event(struct notifier_block *this,
@@ -1594,9 +2662,17 @@ static int efx_netdev_event(struct notif
 {
 	struct net_device *net_dev = ptr;
 
+#if !defined(EFX_USE_KCOMPAT) || defined(HAVE_NET_DEVICE_OPS)
 	if (net_dev->netdev_ops == &efx_netdev_ops &&
-	    event == NETDEV_CHANGENAME)
-		efx_update_name(netdev_priv(net_dev));
+	    event == NETDEV_CHANGENAME) {
+#else
+	if (net_dev->open == efx_net_open && event == NETDEV_CHANGENAME) {
+#endif
+		struct efx_nic *efx = netdev_priv(net_dev);
+
+		if (efx->state == STATE_RUNNING)
+			efx_update_name(efx);
+	}
 
 	return NOTIFY_DONE;
 }
@@ -1604,6 +2680,50 @@ static struct notifier_block efx_netdev_
 static struct notifier_block efx_netdev_notifier = {
 	.notifier_call = efx_netdev_event,
 };
+
+#if defined(EFX_USE_KCOMPAT) && defined(EFX_NEED_BONDING_HACKS)
+/* Prior to Linux 2.6.24, the bonding driver may call change_mtu()
+ * without holding the RTNL, unlike all other callers.  We try to
+ * mitigate the risk of a race with other reconfiguration using
+ * rtnl_trylock(), but we cannot eliminate it completely.
+ */
+static int efx_locked_change_mtu(struct net_device *net_dev, int new_mtu)
+{
+	int must_unlock = rtnl_trylock();
+	int rc = efx_change_mtu(net_dev, new_mtu);
+	if (must_unlock)
+		rtnl_unlock();
+	return rc;
+}
+#define efx_change_mtu efx_locked_change_mtu
+#endif
+
+#if defined(EFX_NOT_UPSTREAM) && defined(EFX_USE_SFC_LRO)
+static ssize_t show_lro(struct device *dev, struct device_attribute *attr,
+			char *buf)
+{
+	struct efx_nic *efx = pci_get_drvdata(to_pci_dev(dev));
+	return sprintf(buf, "%d\n", efx_ssr_enabled(efx));
+}
+static ssize_t set_lro(struct device *dev, struct device_attribute *attr,
+		       const char *buf, size_t count)
+{
+	struct efx_nic *efx = pci_get_drvdata(to_pci_dev(dev));
+	bool enable = count > 0 && *buf != '0';
+#ifdef NETIF_F_LRO
+	if (enable != !!(efx->net_dev->features & NETIF_F_LRO)) {
+		rtnl_lock();
+		efx->net_dev->features ^= NETIF_F_LRO;
+		netdev_features_change(efx->net_dev);
+		rtnl_unlock();
+	}
+#else
+	efx->lro_enabled = enable;
+#endif
+	return count;
+}
+static DEVICE_ATTR(lro, 0644, show_lro, set_lro);
+#endif
 
 static ssize_t
 show_phy_type(struct device *dev, struct device_attribute *attr, char *buf)
@@ -1620,13 +2740,38 @@ static int efx_register_netdev(struct ef
 
 	net_dev->watchdog_timeo = 5 * HZ;
 	net_dev->irq = efx->pci_dev->irq;
+#if !defined(EFX_USE_KCOMPAT) || defined(HAVE_NET_DEVICE_OPS)
 	net_dev->netdev_ops = &efx_netdev_ops;
-	SET_NETDEV_DEV(net_dev, &efx->pci_dev->dev);
+#else
+	net_dev->open = efx_net_open;
+	net_dev->stop = efx_net_stop;
+	net_dev->get_stats = efx_net_stats;
+	net_dev->tx_timeout = efx_watchdog;
+	net_dev->hard_start_xmit = efx_hard_start_xmit;
+	net_dev->do_ioctl = efx_ioctl;
+	net_dev->change_mtu = efx_change_mtu;
+	net_dev->set_mac_address = efx_set_mac_address;
+	net_dev->set_multicast_list = efx_set_multicast_list;
+#if defined(EFX_NOT_UPSTREAM) && defined(EFX_USE_FAKE_VLAN_RX_ACCEL)
+	net_dev->vlan_rx_register = efx_vlan_rx_register;
+#endif
+#ifdef EFX_USE_VLAN_RX_KILL_VID
+	net_dev->vlan_rx_kill_vid = efx_vlan_rx_kill_vid;
+#endif
+#ifdef CONFIG_NET_POLL_CONTROLLER
+	net_dev->poll_controller = efx_netpoll;
+#endif
+#endif
 	SET_ETHTOOL_OPS(net_dev, &efx_ethtool_ops);
 
 	/* Clear MAC statistics */
 	efx->mac_op->update_stats(efx);
 	memset(&efx->mac_stats, 0, sizeof(efx->mac_stats));
+
+#if defined(EFX_NOT_UPSTREAM) && defined(EFX_WITH_VMWARE_NETQ)
+	if ( (rc = efx_netq_init(efx) ) != 0 )
+		return rc;
+#endif
 
 	rtnl_lock();
 
@@ -1640,48 +2785,97 @@ static int efx_register_netdev(struct ef
 		goto fail_locked;
 
 	/* Always start with carrier off; PHY events will detect the link */
-	netif_carrier_off(efx->net_dev);
+	netif_carrier_off(net_dev);
+
+	/* Register with driverlink layer */
+	efx_dl_register_nic(efx);
 
 	rtnl_unlock();
 
-	rc = device_create_file(&efx->pci_dev->dev, &dev_attr_phy_type);
+	/* Create debugfs symlinks */
+	rc = efx_init_debugfs_netdev(net_dev);
 	if (rc) {
-		EFX_ERR(efx, "failed to init net dev attributes\n");
+		netif_err(efx, drv, efx->net_dev,
+			  "failed to init net dev debugfs\n");
 		goto fail_registered;
 	}
 
+	rc = device_create_file(&efx->pci_dev->dev, &dev_attr_phy_type);
+	if (rc) {
+		netif_err(efx, drv, efx->net_dev,
+			  "failed to init net dev attributes\n");
+		goto fail_debugfs;
+	}
+#if defined(EFX_NOT_UPSTREAM) && defined(EFX_USE_SFC_LRO)
+	rc = device_create_file(&efx->pci_dev->dev, &dev_attr_lro);
+	if (rc) {
+		netif_err(efx, drv, efx->net_dev,
+			  "failed to init net dev attributes\n");
+		goto fail_attr_phy_type;
+	}
+#endif
+
 	return 0;
 
+#if defined(EFX_NOT_UPSTREAM) && defined(EFX_USE_SFC_LRO)
+fail_attr_phy_type:
+	device_remove_file(&efx->pci_dev->dev, &dev_attr_phy_type);
+#endif
+fail_debugfs:
+	efx_fini_debugfs_netdev(net_dev);
+fail_registered:
+	rtnl_lock();
+	efx_dl_unregister_nic(efx);
+	unregister_netdevice(net_dev);
 fail_locked:
 	rtnl_unlock();
-	EFX_ERR(efx, "could not register net dev\n");
-	return rc;
-
-fail_registered:
-	unregister_netdev(net_dev);
+	netif_err(efx, drv, efx->net_dev, "could not register net dev\n");
+#if defined(EFX_NOT_UPSTREAM) && defined(EFX_WITH_VMWARE_NETQ)
+	efx_netq_fini(efx);
+#endif
 	return rc;
 }
 
 static void efx_unregister_netdev(struct efx_nic *efx)
 {
+	struct efx_channel *channel;
 	struct efx_tx_queue *tx_queue;
-
-	if (!efx->net_dev)
-		return;
 
 	BUG_ON(netdev_priv(efx->net_dev) != efx);
 
 	/* Free up any skbs still remaining. This has to happen before
 	 * we try to unregister the netdev as running their destructors
 	 * may be needed to get the device ref. count to 0. */
-	efx_for_each_tx_queue(tx_queue, efx)
-		efx_release_tx_buffers(tx_queue);
+	efx_for_each_channel(channel, efx) {
+		efx_for_each_channel_tx_queue(tx_queue, channel)
+			efx_release_tx_buffers(tx_queue);
+	}
 
+#if defined(EFX_NOT_UPSTREAM)
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,6,9) &&	\
+	LINUX_VERSION_CODE < KERNEL_VERSION(2,6,18)
+	/* bug11519: This has only been seen on fc4, but the bug has never
+	 * been fully understood - so this workaround is applied to a range
+	 * of kernels. The issue is that if dev_close() is run too close
+	 * to a driver unload, then netlink can allow userspace to leak a
+	 * reference count. Sleeping here for a bit lowers the probability
+	 * of seeing this failure. */
+	schedule_timeout_uninterruptible(HZ * 2);
+
+#endif
+#endif
 	if (efx_dev_registered(efx)) {
 		strlcpy(efx->name, pci_name(efx->pci_dev), sizeof(efx->name));
+#if defined(EFX_NOT_UPSTREAM) && defined(EFX_USE_SFC_LRO)
+		device_remove_file(&efx->pci_dev->dev, &dev_attr_lro);
+#endif
 		device_remove_file(&efx->pci_dev->dev, &dev_attr_phy_type);
+		efx_fini_debugfs_netdev(efx->net_dev);
 		unregister_netdev(efx->net_dev);
 	}
+#if defined(EFX_NOT_UPSTREAM) && defined(EFX_WITH_VMWARE_NETQ)
+	efx_netq_fini(efx);
+#endif
 }
 
 /**************************************************************************
@@ -1689,43 +2883,21 @@ static void efx_unregister_netdev(struct
  * Device reset and suspend
  *
  **************************************************************************/
-#ifdef CONFIG_SFC_DRIVERLINK
-/* Serialise access to the driverlink callbacks, by quiescing event processing
- * (without flushing the descriptor queues), and acquiring the rtnl_lock */
-void efx_suspend(struct efx_nic *efx)
-{
-	EFX_LOG(efx, "suspending operations\n");
 
-	rtnl_lock();
-	efx_stop_all(efx);
-}
-
-void efx_resume(struct efx_nic *efx)
-{
-	EFX_LOG(efx, "resuming operations\n");
-
-	efx_start_all(efx);
-	rtnl_unlock();
-}
-#endif
-
-/* Tears down the entire software state and most of the hardware state
- * before reset.  */
-void efx_reset_down(struct efx_nic *efx, enum reset_type method,
-		    struct ethtool_cmd *ecmd)
+/* Tears down driverlink clients, the entire software state,
+ * and most of the hardware state before reset.  */
+void efx_reset_down(struct efx_nic *efx, enum reset_type method)
 {
 	EFX_ASSERT_RESET_SERIALISED(efx);
 
-	efx_stats_disable(efx);
 	efx_stop_all(efx);
 	mutex_lock(&efx->mac_lock);
 	mutex_lock(&efx->spi_lock);
 
-	efx->phy_op->get_settings(efx, ecmd);
-
 	efx_fini_channels(efx);
 	if (efx->port_initialized && method != RESET_TYPE_INVISIBLE)
 		efx->phy_op->fini(efx);
+	efx->type->fini(efx);
 }
 
 /* This function will always ensure that the locks acquired in
@@ -1733,79 +2905,75 @@ void efx_reset_down(struct efx_nic *efx,
  * that we were unable to reinitialise the hardware, and the
  * driver should be disabled. If ok is false, then the rx and tx
  * engines are not restarted, pending a RESET_DISABLE. */
-int efx_reset_up(struct efx_nic *efx, enum reset_type method,
-		 struct ethtool_cmd *ecmd, bool ok)
+int efx_reset_up(struct efx_nic *efx, enum reset_type method, bool ok)
 {
 	int rc;
 
 	EFX_ASSERT_RESET_SERIALISED(efx);
 
-	rc = falcon_init_nic(efx);
+	/* Ensure that SRAM is initialised even if we're disabling the device */
+	rc = efx->type->init(efx);
 	if (rc) {
-		EFX_ERR(efx, "failed to initialise NIC\n");
-		ok = false;
+		netif_err(efx, drv, efx->net_dev, "failed to initialise NIC\n");
+		goto fail;
 	}
 
+	if (!ok)
+		goto fail;
+
 	if (efx->port_initialized && method != RESET_TYPE_INVISIBLE) {
-		if (ok) {
-			rc = efx->phy_op->init(efx);
-			if (rc)
-				ok = false;
-		}
-		if (!ok)
-			efx->port_initialized = false;
+		rc = efx->phy_op->init(efx);
+		if (rc)
+			goto fail;
+		if (efx->phy_op->reconfigure(efx))
+			EFX_FATAL(efx, drv, efx->net_dev,
+				  "could not restore PHY settings\n");
 	}
 
-	if (ok) {
-		efx_init_channels(efx);
+	efx->mac_op->reconfigure(efx);
 
-		if (efx->phy_op->set_settings(efx, ecmd))
-			EFX_ERR(efx, "could not restore PHY settings\n");
-	}
+	efx_init_channels(efx);
+	efx_restore_filters(efx);
 
 	mutex_unlock(&efx->spi_lock);
 	mutex_unlock(&efx->mac_lock);
 
-	if (ok) {
-		efx_start_all(efx);
-		efx_stats_enable(efx);
-	}
+	efx_start_all(efx);
+
+	return 0;
+
+fail:
+	efx->port_initialized = false;
+
+	mutex_unlock(&efx->spi_lock);
+	mutex_unlock(&efx->mac_lock);
+
 	return rc;
 }
 
-/* Reset the NIC as transparently as possible. Do not reset the PHY
- * Note that the reset may fail, in which case the card will be left
- * in a most-probably-unusable state.
+/* Reset the NIC using the specified method.  Note that the reset may
+ * fail, in which case the card will be left in an unusable state.
  *
- * This function will sleep.  You cannot reset from within an atomic
- * state; use efx_schedule_reset() instead.
- *
- * Grabs the rtnl_lock.
+ * Caller must hold the rtnl_lock.
  */
-static int efx_reset(struct efx_nic *efx)
+int efx_reset(struct efx_nic *efx, enum reset_type method)
 {
-	struct ethtool_cmd ecmd;
-	enum reset_type method = efx->reset_pending;
-	int rc = 0;
+	int rc, rc2;
+	bool disabled;
 
-	rtnl_lock();
+	/* Notify driverlink clients of imminent reset then serialise
+	 * against other driver operations */
 	efx_dl_reset_suspend(efx);
 
-	/* If we're not RUNNING then don't reset. Leave the reset_pending
-	 * flag set so that efx_pci_probe_main will be retried */
-	if (efx->state != STATE_RUNNING) {
-		EFX_INFO(efx, "scheduled reset quenched. NIC not RUNNING\n");
-		goto out_unlock;
-	}
+	netif_info(efx, drv, efx->net_dev, "resetting (%s)\n",
+		   RESET_TYPE(method));
 
-	EFX_INFO(efx, "resetting (%d)\n", method);
+	efx_reset_down(efx, method);
 
-	efx_reset_down(efx, method, &ecmd);
-
-	rc = falcon_reset_hw(efx, method);
+	rc = efx->type->reset(efx, method);
 	if (rc) {
-		EFX_ERR(efx, "failed to reset hardware\n");
-		goto out_disable;
+		netif_err(efx, drv, efx->net_dev, "failed to reset hardware\n");
+		goto out;
 	}
 
 	/* Allow resets to be rescheduled. */
@@ -1817,26 +2985,31 @@ static int efx_reset(struct efx_nic *efx
 	 * can respond to requests. */
 	pci_set_master(efx->pci_dev);
 
+#ifdef EFX_NOT_UPSTREAM
+	if (method == RESET_TYPE_DISABLE && allow_zombie) {
+		netif_err(efx, drv, efx->net_dev, "is now a zombie\n");
+		method = RESET_TYPE_ALL;
+	}
+#endif
+
+out:
 	/* Leave device stopped if necessary */
-	if (method == RESET_TYPE_DISABLE) {
-		efx_reset_up(efx, method, &ecmd, false);
-		rc = -EIO;
-	} else {
-		rc = efx_reset_up(efx, method, &ecmd, true);
+	disabled = rc || method == RESET_TYPE_DISABLE;
+	rc2 = efx_reset_up(efx, method, !disabled);
+	if (rc2) {
+		disabled = true;
+		if (!rc)
+			rc = rc2;
 	}
 
-out_disable:
-	if (rc) {
-		EFX_ERR(efx, "has been disabled\n");
+	if (disabled) {
+		dev_close(efx->net_dev);
+		netif_err(efx, drv, efx->net_dev, "has been disabled\n");
 		efx->state = STATE_DISABLED;
-		dev_close(efx->net_dev);
 	} else {
-		EFX_LOG(efx, "reset complete\n");
+		netif_dbg(efx, drv, efx->net_dev, "reset complete\n");
 	}
-
-out_unlock:
-	efx_dl_reset_resume(efx, 1);
-	rtnl_unlock();
+	efx_dl_reset_resume(efx, !disabled);
 	return rc;
 }
 
@@ -1845,9 +3018,22 @@ out_unlock:
  */
 static void efx_reset_work(struct work_struct *data)
 {
-	struct efx_nic *nic = container_of(data, struct efx_nic, reset_work);
+	struct efx_nic *efx = container_of(data, struct efx_nic, reset_work);
 
-	efx_reset(nic);
+	if (efx->reset_pending == RESET_TYPE_NONE)
+		return;
+
+	/* If we're not RUNNING then don't reset. Leave the reset_pending
+	 * flag set so that efx_pci_probe_main will be retried */
+	if (efx->state != STATE_RUNNING) {
+		netif_info(efx, drv, efx->net_dev,
+			   "scheduled reset quenched. NIC not RUNNING\n");
+		return;
+	}
+
+	rtnl_lock();
+	(void)efx_reset(efx, efx->reset_pending);
+	rtnl_unlock();
 }
 
 void efx_schedule_reset(struct efx_nic *efx, enum reset_type type)
@@ -1855,7 +3041,8 @@ void efx_schedule_reset(struct efx_nic *
 	enum reset_type method;
 
 	if (efx->reset_pending != RESET_TYPE_NONE) {
-		EFX_INFO(efx, "quenching already scheduled reset\n");
+		netif_info(efx, drv, efx->net_dev,
+			   "quenching already scheduled reset\n");
 		return;
 	}
 
@@ -1872,17 +3059,25 @@ void efx_schedule_reset(struct efx_nic *
 	case RESET_TYPE_TX_SKIP:
 		method = RESET_TYPE_INVISIBLE;
 		break;
+	case RESET_TYPE_MC_FAILURE:
 	default:
 		method = RESET_TYPE_ALL;
 		break;
 	}
 
 	if (method != type)
-		EFX_LOG(efx, "scheduling reset (%d:%d)\n", type, method);
+		netif_dbg(efx, drv, efx->net_dev,
+			  "scheduling %s reset for %s\n",
+			  RESET_TYPE(method), RESET_TYPE(type));
 	else
-		EFX_LOG(efx, "scheduling reset (%d)\n", method);
+		netif_dbg(efx, drv, efx->net_dev, "scheduling %s reset\n",
+			  RESET_TYPE(method));
 
 	efx->reset_pending = method;
+
+	/* efx_process_channel() will no longer read events once a
+	 * reset is scheduled. So switch back to poll'd MCDI completions. */
+	efx_mcdi_mode_poll(efx);
 
 	queue_work(reset_workqueue, &efx->reset_work);
 }
@@ -1894,17 +3089,23 @@ void efx_schedule_reset(struct efx_nic *
  **************************************************************************/
 
 /* PCI device ID table */
-static struct pci_device_id efx_pci_table[] __devinitdata = {
+static DEFINE_PCI_DEVICE_TABLE(efx_pci_table) = {
+#ifndef __VMKERNEL_MODULE__
 	{PCI_DEVICE(EFX_VENDID_SFC, FALCON_A_P_DEVID),
-	 .driver_data = (unsigned long) &falcon_a_nic_type},
+	 .driver_data = (unsigned long) &falcon_a1_nic_type},
+#endif
 	{PCI_DEVICE(EFX_VENDID_SFC, FALCON_B_P_DEVID),
-	 .driver_data = (unsigned long) &falcon_b_nic_type},
+	 .driver_data = (unsigned long) &falcon_b0_nic_type},
+	{PCI_DEVICE(EFX_VENDID_SFC, BETHPAGE_A_P_DEVID),
+	 .driver_data = (unsigned long) &siena_a0_nic_type},
+	{PCI_DEVICE(EFX_VENDID_SFC, SIENA_A_P_DEVID),
+	 .driver_data = (unsigned long) &siena_a0_nic_type},
 	{0}			/* end of list */
 };
 
 /**************************************************************************
  *
- * Dummy PHY/MAC/Board operations
+ * Dummy PHY/MAC operations
  *
  * Can be used for some unimplemented operations
  * Needed so all function pointers are valid and do not have to be tested
@@ -1916,29 +3117,22 @@ int efx_port_dummy_op_int(struct efx_nic
 	return 0;
 }
 void efx_port_dummy_op_void(struct efx_nic *efx) {}
-void efx_port_dummy_op_blink(struct efx_nic *efx, bool blink) {}
 
-static struct efx_mac_operations efx_dummy_mac_operations = {
-	.reconfigure	= efx_port_dummy_op_void,
-	.poll		= efx_port_dummy_op_void,
-	.irq		= efx_port_dummy_op_void,
-};
+static bool efx_port_dummy_op_poll(struct efx_nic *efx)
+{
+	return false;
+}
 
 static struct efx_phy_operations efx_dummy_phy_operations = {
 	.init		 = efx_port_dummy_op_int,
-	.reconfigure	 = efx_port_dummy_op_void,
-	.poll		 = efx_port_dummy_op_void,
+	.reconfigure	 = efx_port_dummy_op_int,
+	.poll		 = efx_port_dummy_op_poll,
 	.fini		 = efx_port_dummy_op_void,
-	.clear_interrupt = efx_port_dummy_op_void,
-};
-
-static struct efx_board efx_dummy_board_info = {
-	.init		= efx_port_dummy_op_int,
-	.init_leds	= efx_port_dummy_op_void,
-	.set_id_led	= efx_port_dummy_op_blink,
-	.monitor	= efx_port_dummy_op_int,
-	.blink		= efx_port_dummy_op_blink,
-	.fini		= efx_port_dummy_op_void,
+#ifdef EFX_NOT_UPSTREAM
+	.probe		 = efx_port_dummy_op_int,
+	.remove		 = efx_port_dummy_op_void,
+	.test_alive	 = efx_port_dummy_op_int,
+#endif
 };
 
 /**************************************************************************
@@ -1953,102 +3147,136 @@ static int efx_init_struct(struct efx_ni
 static int efx_init_struct(struct efx_nic *efx, struct efx_nic_type *type,
 			   struct pci_dev *pci_dev, struct net_device *net_dev)
 {
-	struct efx_channel *channel;
-	struct efx_tx_queue *tx_queue;
-	struct efx_rx_queue *rx_queue;
 	int i;
 
 	/* Initialise common structures */
 	memset(efx, 0, sizeof(*efx));
 	spin_lock_init(&efx->biu_lock);
-	spin_lock_init(&efx->phy_lock);
+	mutex_init(&efx->mdio_lock);
 	mutex_init(&efx->spi_lock);
+#ifdef CONFIG_SFC_MTD
+	INIT_LIST_HEAD(&efx->mtd_list);
+#endif
 	INIT_WORK(&efx->reset_work, efx_reset_work);
 	INIT_DELAYED_WORK(&efx->monitor_work, efx_monitor);
 	efx->pci_dev = pci_dev;
+	efx->msg_enable = debug;
 	efx->state = STATE_INIT;
 	efx->reset_pending = RESET_TYPE_NONE;
 	strlcpy(efx->name, pci_name(pci_dev), sizeof(efx->name));
-	efx->board_info = efx_dummy_board_info;
 
 	efx->net_dev = net_dev;
 	efx->rx_checksum_enabled = true;
-	spin_lock_init(&efx->netif_stop_lock);
+#if defined(EFX_USE_KCOMPAT) && defined(EFX_USE_SFC_LRO) && !defined(NETIF_F_LRO)
+	efx->lro_enabled = lro;
+#endif
 	spin_lock_init(&efx->stats_lock);
-	efx->stats_disable_count = 1;
 	mutex_init(&efx->mac_lock);
-	efx->mac_op = &efx_dummy_mac_operations;
+	efx->mac_op = type->default_mac_ops;
 	efx->phy_op = &efx_dummy_phy_operations;
 	efx->mdio.dev = net_dev;
-#ifdef CONFIG_SFC_DRIVERLINK
 	INIT_LIST_HEAD(&efx->dl_node);
 	INIT_LIST_HEAD(&efx->dl_device_list);
 	efx->dl_cb = efx_default_callbacks;
-#endif
-	INIT_WORK(&efx->phy_work, efx_phy_work);
 	INIT_WORK(&efx->mac_work, efx_mac_work);
-	atomic_set(&efx->netif_stop_count, 1);
 
 	for (i = 0; i < EFX_MAX_CHANNELS; i++) {
-		channel = &efx->channel[i];
-		channel->efx = efx;
-		channel->channel = i;
-		channel->work_pending = false;
-	}
-	for (i = 0; i < EFX_TX_QUEUE_COUNT; i++) {
-		tx_queue = &efx->tx_queue[i];
-		tx_queue->efx = efx;
-		tx_queue->queue = i;
-		tx_queue->buffer = NULL;
-		tx_queue->channel = &efx->channel[0]; /* for safety */
-		tx_queue->tso_headers_free = NULL;
-	}
-	for (i = 0; i < EFX_MAX_RX_QUEUES; i++) {
-		rx_queue = &efx->rx_queue[i];
-		rx_queue->efx = efx;
-		rx_queue->queue = i;
-		rx_queue->channel = &efx->channel[0]; /* for safety */
-		rx_queue->buffer = NULL;
-		spin_lock_init(&rx_queue->add_lock);
-		INIT_DELAYED_WORK(&rx_queue->work, efx_rx_work);
+		/* TODO: NUMA affinity */
+		efx->channel[i] = efx_alloc_channel(efx, i, NULL);
+		if (!efx->channel[i])
+			goto fail;
 	}
 
 	efx->type = type;
 
-	/* Sanity-check NIC type */
-	EFX_BUG_ON_PARANOID(efx->type->txd_ring_mask &
-			    (efx->type->txd_ring_mask + 1));
-	EFX_BUG_ON_PARANOID(efx->type->rxd_ring_mask &
-			    (efx->type->rxd_ring_mask + 1));
-	EFX_BUG_ON_PARANOID(efx->type->evq_size &
-			    (efx->type->evq_size - 1));
-	/* As close as we can get to guaranteeing that we don't overflow */
-	EFX_BUG_ON_PARANOID(efx->type->evq_size <
-			    (efx->type->txd_ring_mask + 1 +
-			     efx->type->rxd_ring_mask + 1));
 	EFX_BUG_ON_PARANOID(efx->type->phys_addr_channels > EFX_MAX_CHANNELS);
 
 	/* Higher numbered interrupt modes are less capable! */
 	efx->interrupt_mode = max(efx->type->max_interrupt_mode,
 				  interrupt_mode);
+#if defined(EFX_USE_KCOMPAT) && defined(EFX_NEED_DUMMY_MSIX)
+	if (efx->interrupt_mode == EFX_INT_MODE_MSIX)
+		efx->interrupt_mode = EFX_INT_MODE_MSI;
+#endif
 
 	/* Would be good to use the net_dev name, but we're too early */
+#if defined(EFX_USE_KCOMPAT) && defined(EFX_HAVE_WORKQUEUE_NAME_LIMIT)
+	snprintf(efx->workqueue_name, 10 + 1, "sfc%02x:%02x.%d",
+		 pci_dev->bus->number, PCI_SLOT(pci_dev->devfn),
+		 PCI_FUNC(pci_dev->devfn));
+#else
 	snprintf(efx->workqueue_name, sizeof(efx->workqueue_name), "sfc%s",
 		 pci_name(pci_dev));
+#endif
 	efx->workqueue = create_singlethread_workqueue(efx->workqueue_name);
 	if (!efx->workqueue)
-		return -ENOMEM;
+		goto fail;
 
 	return 0;
+
+fail:
+	efx_fini_struct(efx);
+	return -ENOMEM;
 }
 
 static void efx_fini_struct(struct efx_nic *efx)
 {
+	int i;
+
+	for (i = 0; i < EFX_MAX_CHANNELS; i++)
+		kfree(efx->channel[i]);
+
 	if (efx->workqueue) {
 		destroy_workqueue(efx->workqueue);
 		efx->workqueue = NULL;
 	}
 }
+
+#if defined(EFX_NOT_UPSTREAM)
+
+/**************************************************************************
+ *
+ * Automatic loading of the sfc_tune driver
+ *
+ **************************************************************************/
+
+static void efx_probe_tune(struct work_struct *data)
+{
+	if (request_module("sfc_tune"))
+		printk(KERN_ERR "Unable to autoprobe sfc_tune driver. "
+		       "Expect reduced performance on Falcon/A1\n");
+}
+
+static struct work_struct probe_tune;
+enum {
+	PROBE_TUNE_WANT,
+	PROBE_TUNE_ENABLE,
+};
+
+static void efx_schedule_probe_tune(int what)
+{
+	static bool wanted;
+	static bool enabled;
+	bool kick;
+
+	rtnl_lock();
+	if (what == PROBE_TUNE_WANT) {
+		kick = enabled && !wanted;
+		wanted = true;
+	} else {
+		kick = wanted;
+		enabled = true;
+	}
+	rtnl_unlock();
+
+	if (!kick)
+		return;
+
+	INIT_WORK(&probe_tune, efx_probe_tune);
+	schedule_work(&probe_tune);
+}
+
+#endif
 
 /**************************************************************************
  *
@@ -2061,19 +3289,10 @@ static void efx_fini_struct(struct efx_n
  */
 static void efx_pci_remove_main(struct efx_nic *efx)
 {
-	EFX_ASSERT_RESET_SERIALISED(efx);
-
-	/* Skip everything if we never obtained a valid membase */
-	if (!efx->membase)
-		return;
-
+	efx_nic_fini_interrupt(efx);
 	efx_fini_channels(efx);
 	efx_fini_port(efx);
-
-	/* Shutdown the board, then the NIC and board state */
-	efx->board_info.fini(efx);
-	falcon_fini_interrupt(efx);
-
+	efx->type->fini(efx);
 	efx_fini_napi(efx);
 	efx_remove_all(efx);
 }
@@ -2088,34 +3307,36 @@ static void efx_pci_remove(struct pci_de
 	efx = pci_get_drvdata(pci_dev);
 	if (!efx)
 		return;
-	efx_dl_unregister_nic(efx);
 
 	/* Mark the NIC as fini, then stop the interface */
 	rtnl_lock();
+	efx_dl_unregister_nic(efx);
 	efx->state = STATE_FINI;
 	dev_close(efx->net_dev);
 
 	/* Allow any queued efx_resets() to complete */
 	rtnl_unlock();
 
-	if (efx->membase == NULL)
-		goto out;
-
+	efx_sriov_fini(efx);
 	efx_unregister_netdev(efx);
 
 	efx_mtd_remove(efx);
+	efx_fini_debugfs_channels(efx);
 
 	/* Wait for any scheduled resets to complete. No more will be
 	 * scheduled from this point because efx_stop_all() has been
 	 * called, we are no longer registered with driverlink, and
 	 * the net_device's have been removed. */
+#if !defined(EFX_USE_KCOMPAT) || defined(EFX_USE_CANCEL_WORK_SYNC)
 	cancel_work_sync(&efx->reset_work);
+#else
+	flush_workqueue(reset_workqueue);
+#endif
 
 	efx_pci_remove_main(efx);
 
-out:
 	efx_fini_io(efx);
-	EFX_LOG(efx, "shutdown successful\n");
+	netif_dbg(efx, drv, efx->net_dev, "shutdown successful\n");
 
 	pci_set_drvdata(pci_dev, NULL);
 	efx_fini_struct(efx);
@@ -2134,43 +3355,62 @@ static int efx_pci_probe_main(struct efx
 	if (rc)
 		goto fail1;
 
+#if defined(EFX_NOT_UPSTREAM)
+	if (efx_nic_rev(efx) < EFX_REV_FALCON_B0) {
+		/* Try and auto-probe the sfc_tune driver, so by default
+		 * users see high performance on A1 cards */
+		efx_schedule_probe_tune(PROBE_TUNE_WANT);
+	}
+#endif
+
 	rc = efx_init_napi(efx);
 	if (rc)
 		goto fail2;
 
-	/* Initialise the board */
-	rc = efx->board_info.init(efx);
+	rc = efx->type->init(efx);
 	if (rc) {
-		EFX_ERR(efx, "failed to initialise board\n");
+		netif_err(efx, probe, efx->net_dev,
+			  "failed to initialise NIC\n");
 		goto fail3;
-	}
-
-	rc = falcon_init_nic(efx);
-	if (rc) {
-		EFX_ERR(efx, "failed to initialise NIC\n");
-		goto fail4;
 	}
 
 	rc = efx_init_port(efx);
 	if (rc) {
-		EFX_ERR(efx, "failed to initialise port\n");
-		goto fail5;
+		netif_err(efx, probe, efx->net_dev,
+			  "failed to initialise port\n");
+		goto fail4;
 	}
 
 	efx_init_channels(efx);
 
-	rc = falcon_init_interrupt(efx);
+	rc = efx_nic_init_interrupt(efx);
 	if (rc)
-		goto fail6;
+		goto fail5;
+
+#if defined(EFX_NOT_UPSTREAM) && defined(CONFIG_SMP) && !defined(__VMKLNX__)
+	efx_set_interrupt_affinity(efx);
+#endif
+
+#ifdef EFX_NOT_UPSTREAM
+	if (efx->phy_mode == PHY_MODE_NORMAL && !efx_ignore_nvconfig) {
+		efx_start_all(efx);
+		rc = efx_run_selftests(efx);
+		if (rc)
+			goto fail6;
+		efx_stop_all(efx);
+	}
+#endif
 
 	return 0;
 
  fail6:
+	efx_stop_all(efx);
+	efx_nic_fini_interrupt(efx);
+ fail5:
 	efx_fini_channels(efx);
 	efx_fini_port(efx);
- fail5:
  fail4:
-	efx->board_info.fini(efx);
+	efx->type->fini(efx);
  fail3:
 	efx_fini_napi(efx);
  fail2:
@@ -2197,22 +3437,50 @@ static int __devinit efx_pci_probe(struc
 	int i, rc;
 
 	/* Allocate and initialise a struct net_device and struct efx_nic */
-	net_dev = alloc_etherdev(sizeof(*efx));
+	net_dev = alloc_etherdev_mq(sizeof(*efx), EFX_MAX_CORE_TX_QUEUES);
 	if (!net_dev)
 		return -ENOMEM;
-	net_dev->features |= (NETIF_F_IP_CSUM | NETIF_F_SG |
-			      NETIF_F_HIGHDMA | NETIF_F_TSO |
-			      NETIF_F_GRO);
+	net_dev->features |= (type->offload_features | NETIF_F_SG |
+			      NETIF_F_HIGHDMA | NETIF_F_TSO);
+#if !defined(EFX_USE_KCOMPAT) || defined(NETIF_F_TSO6)
+	if (type->offload_features & NETIF_F_V6_CSUM)
+		net_dev->features |= NETIF_F_TSO6;
+#endif
+#if !defined(EFX_USE_KCOMPAT)
+	net_dev->features |= NETIF_F_GRO;
+#elif defined(EFX_USE_GRO)
+	if (lro)
+		net_dev->features |= NETIF_F_GRO;
+#elif defined(EFX_NOT_UPSTREAM) && defined(EFX_USE_SFC_LRO) && defined(NETIF_F_LRO)
+	if (lro)
+		net_dev->features |= NETIF_F_LRO;
+#endif
+#if defined(EFX_NOT_UPSTREAM) && defined(EFX_USE_FAKE_VLAN_RX_ACCEL)
+	net_dev->features |= NETIF_F_HW_VLAN_RX;
+#endif
+#if !defined(EFX_USE_KCOMPAT) || defined(EFX_USE_NETDEV_VLAN_FEATURES)
 	/* Mask for features that also apply to VLAN devices */
 	net_dev->vlan_features |= (NETIF_F_ALL_CSUM | NETIF_F_SG |
 				   NETIF_F_HIGHDMA | NETIF_F_TSO);
+#else
+	/* Alternative to vlan_features in RHEL 5.5+ */
+#if defined(NETIF_F_VLAN_CSUM)
+	net_dev->features |= NETIF_F_VLAN_CSUM;
+#endif
+#if defined(NETIF_F_VLAN_TSO)
+	net_dev->features |= NETIF_F_VLAN_TSO;
+#endif
+#endif
 	efx = netdev_priv(net_dev);
 	pci_set_drvdata(pci_dev, efx);
+	SET_NETDEV_DEV(net_dev, &pci_dev->dev);
 	rc = efx_init_struct(efx, type, pci_dev, net_dev);
 	if (rc)
 		goto fail1;
 
-	EFX_INFO(efx, "Solarflare Communications NIC detected\n");
+	netif_info(efx, probe, efx->net_dev,
+		   "Solarflare Communications NIC detected PCI(%x:%x)\n",
+		   pci_dev->vendor, pci_dev->device);
 
 	/* Set up basic I/O (BAR mappings etc) */
 	rc = efx_init_io(efx);
@@ -2228,7 +3496,11 @@ static int __devinit efx_pci_probe(struc
 		 * scheduled since efx_stop_all() has been called, and we
 		 * have not and never have been registered with either
 		 * the rtnetlink or driverlink layers. */
+#if !defined(EFX_USE_KCOMPAT) || defined(EFX_USE_CANCEL_WORK_SYNC)
 		cancel_work_sync(&efx->reset_work);
+#else
+		flush_workqueue(reset_workqueue);
+#endif
 
 		if (rc == 0) {
 			if (efx->reset_pending != RESET_TYPE_NONE) {
@@ -2243,38 +3515,62 @@ static int __devinit efx_pci_probe(struc
 
 		/* Retry if a recoverably reset event has been scheduled */
 		if ((efx->reset_pending != RESET_TYPE_INVISIBLE) &&
-		    (efx->reset_pending != RESET_TYPE_ALL))
+		    (efx->reset_pending != RESET_TYPE_ALL)) {
+			if (efx->reset_pending != RESET_TYPE_NONE)
+				netif_err(efx, probe, efx->net_dev,
+					  "Unrecoverable scheduled reset: %s\n",
+					  RESET_TYPE(efx->reset_pending));
 			goto fail3;
+		}
 
 		efx->reset_pending = RESET_TYPE_NONE;
 	}
 
 	if (rc) {
-		EFX_ERR(efx, "Could not reset NIC\n");
+		netif_err(efx, probe, efx->net_dev,
+			  "Initialisation failed due to persistent reset\n");
 		goto fail4;
 	}
 
-	/* Switch to the running state before we expose the device to
-	 * the OS.  This is to ensure that the initial gathering of
-	 * MAC stats succeeds. */
+	/* Self-tests have all passed */
+	rc = efx_init_debugfs_channels(efx);
+	if (rc)
+		goto fail5;
+
+	/* Switch to the running state before we expose the device to the OS,
+	 * so that dev_open()|efx_start_all() will actually start the device */
+#ifdef EFX_NOT_UPSTREAM
+	if (efx_ignore_nvconfig)
+		efx->state = STATE_DISABLED;
+	else
+		/* fall through */
+#endif
 	efx->state = STATE_RUNNING;
-
-	efx_mtd_probe(efx); /* allowed to fail */
 
 	rc = efx_register_netdev(efx);
 	if (rc)
-		goto fail5;
-
-	/* Register with driverlink layer */
-	rc = efx_dl_register_nic(efx);
-	if (rc)
 		goto fail6;
 
-	EFX_LOG(efx, "initialisation successful\n");
+	if (efx->vf_count) {
+		rc = efx_sriov_init(efx);
+		if (rc) {
+			netif_err(efx, probe, efx->net_dev,
+				  "SR-IOV can't be enabled rc %d\n", rc);
+			efx->vf_count = 0;
+		}
+	}
+
+	netif_info(efx, probe, efx->net_dev,
+		   "is Solarflare Communications NIC PCI(%x:%x)\n",
+		   pci_dev->vendor, pci_dev->device);
+
+	rtnl_lock();
+	efx_mtd_probe(efx); /* allowed to fail */
+	rtnl_unlock();
 	return 0;
 
  fail6:
-	efx_unregister_netdev(efx);
+	efx_fini_debugfs_channels(efx);
  fail5:
 	efx_pci_remove_main(efx);
  fail4:
@@ -2283,16 +3579,178 @@ static int __devinit efx_pci_probe(struc
  fail2:
 	efx_fini_struct(efx);
  fail1:
-	EFX_LOG(efx, "initialisation failed. rc=%d\n", rc);
+	WARN_ON(rc > 0);
+	netif_dbg(efx, drv, efx->net_dev, "initialisation failed. rc=%d\n", rc);
 	free_netdev(net_dev);
 	return rc;
 }
 
+#if !defined(EFX_USE_KCOMPAT) || defined(EFX_USE_PM)
+
+static int efx_pm_freeze(struct device *dev)
+{
+	struct efx_nic *efx = pci_get_drvdata(to_pci_dev(dev));
+
+	rtnl_lock();
+	efx_dl_reset_suspend(efx);
+	rtnl_unlock();
+
+	efx->state = STATE_FINI;
+
+	netif_device_detach(efx->net_dev);
+
+	efx_stop_all(efx);
+	efx_fini_channels(efx);
+
+	return 0;
+}
+
+static int efx_pm_thaw(struct device *dev)
+{
+	struct efx_nic *efx = pci_get_drvdata(to_pci_dev(dev));
+
+	efx->state = STATE_INIT;
+
+	efx_init_channels(efx);
+
+	mutex_lock(&efx->mac_lock);
+	efx->phy_op->reconfigure(efx);
+	mutex_unlock(&efx->mac_lock);
+
+	efx_start_all(efx);
+
+	netif_device_attach(efx->net_dev);
+
+	efx->state = STATE_RUNNING;
+
+	rtnl_lock();
+	efx_dl_reset_resume(efx, true);
+	rtnl_unlock();
+
+	efx->type->resume_wol(efx);
+
+	/* Reschedule any quenched resets scheduled during efx_pm_freeze() */
+	queue_work(reset_workqueue, &efx->reset_work);
+
+	return 0;
+}
+
+static int efx_pm_poweroff(struct device *dev)
+{
+	struct pci_dev *pci_dev = to_pci_dev(dev);
+	struct efx_nic *efx = pci_get_drvdata(pci_dev);
+
+	efx->type->fini(efx);
+
+	efx->reset_pending = RESET_TYPE_NONE;
+
+	pci_save_state(pci_dev);
+	return pci_set_power_state(pci_dev, PCI_D3hot);
+}
+
+/* Used for both resume and restore */
+static int efx_pm_resume(struct device *dev)
+{
+	struct pci_dev *pci_dev = to_pci_dev(dev);
+	struct efx_nic *efx = pci_get_drvdata(pci_dev);
+	int rc;
+
+	rc = pci_set_power_state(pci_dev, PCI_D0);
+	if (rc)
+		goto fail;
+	pci_restore_state(pci_dev);
+	rc = pci_enable_device(pci_dev);
+	if (rc)
+		goto fail;
+	pci_set_master(efx->pci_dev);
+	rc = efx->type->reset(efx, RESET_TYPE_ALL);
+	if (rc)
+		goto fail;
+	rc = efx->type->init(efx);
+	if (rc)
+		goto fail;
+	efx_pm_thaw(dev);
+	return 0;
+
+fail:
+	efx_dl_reset_resume(efx, false);
+	return rc;
+}
+
+static int efx_pm_suspend(struct device *dev)
+{
+	int rc;
+
+	efx_pm_freeze(dev);
+	rc = efx_pm_poweroff(dev);
+	if (rc)
+		efx_pm_resume(dev);
+	return rc;
+}
+
+#if !defined(EFX_USE_KCOMPAT) || defined(EFX_USE_DEV_PM_OPS)
+
+static struct dev_pm_ops efx_pm_ops = {
+	.suspend	= efx_pm_suspend,
+	.resume		= efx_pm_resume,
+	.freeze		= efx_pm_freeze,
+	.thaw		= efx_pm_thaw,
+	.poweroff	= efx_pm_poweroff,
+	.restore	= efx_pm_resume,
+};
+
+#elif defined(EFX_USE_PM_EXT_OPS)
+
+static struct pm_ext_ops efx_pm_ops = {
+	.base = {
+		.suspend	= efx_pm_suspend,
+		.resume		= efx_pm_resume,
+		.freeze		= efx_pm_freeze,
+		.thaw		= efx_pm_thaw,
+		.poweroff	= efx_pm_poweroff,
+		.restore	= efx_pm_resume,
+	}
+};
+
+#else /* !EFX_USE_DEV_PM_OPS && !EFX_USE_PM_EXT_OPS */
+
+static int efx_pm_old_suspend(struct pci_dev *dev, pm_message_t state)
+{
+	switch (state.event) {
+	case PM_EVENT_FREEZE:
+#if defined(PM_EVENT_QUIESCE)
+	case PM_EVENT_QUIESCE:
+#elif defined(PM_EVENT_PRETHAW)
+	case PM_EVENT_PRETHAW:
+#endif
+		return efx_pm_freeze(&dev->dev);
+	default:
+		return efx_pm_suspend(&dev->dev);
+	}
+}
+
+static int efx_pm_old_resume(struct pci_dev *dev)
+{
+	return efx_pm_resume(&dev->dev);
+}
+
+#endif /* EFX_USE_PM_EXT_OPS */
+
+#endif /* EFX_USE_PM */
+
 static struct pci_driver efx_pci_driver = {
-	.name		= EFX_DRIVER_NAME,
+	.name		= KBUILD_MODNAME,
 	.id_table	= efx_pci_table,
 	.probe		= efx_pci_probe,
 	.remove		= efx_pci_remove,
+#if !defined(EFX_USE_KCOMPAT) || defined(EFX_USE_DEV_PM_OPS)
+	.driver.pm	= &efx_pm_ops,
+#elif defined(EFX_USE_PM_EXT_OPS)
+	.pm		= &efx_pm_ops,
+#elif defined(EFX_USE_PM)
+	.suspend	= efx_pm_old_suspend,
+	.resume		= efx_pm_old_resume,
+#endif
 };
 
 /**************************************************************************
@@ -2300,6 +3758,38 @@ static struct pci_driver efx_pci_driver 
  * Kernel module interface
  *
  *************************************************************************/
+
+#ifdef EFX_NOT_UPSTREAM
+
+module_param(napi_weight, int, 0444);
+MODULE_PARM_DESC(napi_weight, "NAPI weighting");
+
+module_param_named(monitor_interval, efx_monitor_interval, uint, 0644);
+MODULE_PARM_DESC(monitor_interval, "Hardware monitor interval (in jiffies)");
+
+module_param(allow_bad_hwaddr, uint, 0644);
+MODULE_PARM_DESC(allow_bad_hwaddr,
+		 "Initialise devices with bad MAC addresses");
+
+module_param(allow_zombie, uint, 0644);
+MODULE_PARM_DESC(allow_zombie, "Reanimate dead devices");
+
+module_param(rx_irq_mod_usec, uint, 0444);
+MODULE_PARM_DESC(rx_irq_mod_usec,
+		 "Receive interrupt moderation (microseconds)");
+
+module_param(tx_irq_mod_usec, uint, 0444);
+MODULE_PARM_DESC(tx_irq_mod_usec,
+		 "Transmit interrupt moderation (microseconds)");
+
+module_param(allow_load_on_failure, uint, 0444);
+MODULE_PARM_DESC(allow_load_on_failure,
+		 "If set then allow driver load when online self-tests fail");
+
+module_param(onload_offline_selftest, uint, 0444);
+MODULE_PARM_DESC(onload_offline_selftest, "Perform offline selftest on load");
+
+#endif /* EFX_NOT_UPSTREAM */
 
 module_param(interrupt_mode, uint, 0444);
 MODULE_PARM_DESC(interrupt_mode,
@@ -2311,34 +3801,93 @@ static int __init efx_init_module(void)
 
 	printk(KERN_INFO "Solarflare NET driver v" EFX_DRIVER_VERSION "\n");
 
+#if defined(EFX_NOT_UPSTREAM) && defined(EFX_GCOV)
+	gcov_provider_init(THIS_MODULE);
+#endif
+
+	rc = efx_init_debugfs();
+	if (rc)
+		goto err_debugfs;
+
 	rc = register_netdevice_notifier(&efx_netdev_notifier);
 	if (rc)
 		goto err_notifier;
 
-	refill_workqueue = create_workqueue("sfc_refill");
-	if (!refill_workqueue) {
-		rc = -ENOMEM;
-		goto err_refill;
-	}
 	reset_workqueue = create_singlethread_workqueue("sfc_reset");
 	if (!reset_workqueue) {
 		rc = -ENOMEM;
 		goto err_reset;
 	}
 
+#if defined(EFX_NOT_UPSTREAM) && defined(CONFIG_SMP) && !defined(__VMKLNX__)
+	rss_cpu_usage = kzalloc(NR_CPUS * sizeof(rss_cpu_usage[0]), GFP_KERNEL);
+	if (rss_cpu_usage == NULL) {
+		rc = -ENOMEM;
+		goto err_cpu_usage;
+	}
+#endif
+#ifdef CONFIG_SFC_HWMON
+#if defined(EFX_USE_KCOMPAT) && defined(EFX_NEED_LM87_DRIVER)
+	rc = i2c_add_driver(&efx_lm87_driver);
+	if (rc < 0)
+		goto err_lm87;
+#endif
+#if defined(EFX_USE_KCOMPAT) && defined(EFX_NEED_LM90_DRIVER)
+	rc = i2c_add_driver(&efx_lm90_driver);
+	if (rc < 0)
+		goto err_lm90;
+#endif
+#endif /* CONFIG_SFC_HWMON */
+#if defined(EFX_USE_KCOMPAT) && defined(EFX_NEED_I2C_NEW_DUMMY)
+	rc = i2c_add_driver(&efx_i2c_dummy_driver);
+	if (rc < 0)
+		goto err_i2c_dummy;
+#endif
+
+#if defined(EFX_NOT_UPSTREAM)
+	rc = efx_control_init();
+	if (rc)
+		goto err_control;
+#endif
 	rc = pci_register_driver(&efx_pci_driver);
 	if (rc < 0)
 		goto err_pci;
 
+#ifdef EFX_NOT_UPSTREAM
+	efx_schedule_probe_tune(PROBE_TUNE_ENABLE);
+#endif
+
 	return 0;
 
  err_pci:
+#if defined(EFX_NOT_UPSTREAM)
+	efx_control_fini();
+ err_control:
+#endif
+#if defined(EFX_USE_KCOMPAT) && defined(EFX_NEED_I2C_NEW_DUMMY)
+	i2c_del_driver(&efx_i2c_dummy_driver);
+ err_i2c_dummy:
+#endif
+#ifdef CONFIG_SFC_HWMON
+#if defined(EFX_USE_KCOMPAT) && defined(EFX_NEED_LM90_DRIVER)
+	i2c_del_driver(&efx_lm90_driver);
+ err_lm90:
+#endif
+#if defined(EFX_USE_KCOMPAT) && defined(EFX_NEED_LM87_DRIVER)
+	i2c_del_driver(&efx_lm87_driver);
+ err_lm87:
+#endif
+#endif /* CONFIG_SFC_HWMON */
+#if defined(EFX_NOT_UPSTREAM) && defined(CONFIG_SMP) && !defined(__VMKLNX__)
+	kfree(rss_cpu_usage);
+ err_cpu_usage:
+#endif
 	destroy_workqueue(reset_workqueue);
  err_reset:
-	destroy_workqueue(refill_workqueue);
- err_refill:
 	unregister_netdevice_notifier(&efx_netdev_notifier);
  err_notifier:
+	efx_fini_debugfs();
+ err_debugfs:
 	return rc;
 }
 
@@ -2347,17 +3896,43 @@ static void __exit efx_exit_module(void)
 	printk(KERN_INFO "Solarflare NET driver unloading\n");
 
 	pci_unregister_driver(&efx_pci_driver);
+#if defined(EFX_NOT_UPSTREAM)
+	efx_control_fini();
+#endif
+#if defined(EFX_USE_KCOMPAT) && defined(EFX_NEED_I2C_NEW_DUMMY)
+	i2c_del_driver(&efx_i2c_dummy_driver);
+#endif
+#ifdef CONFIG_SFC_HWMON
+#if defined(EFX_USE_KCOMPAT) && defined(EFX_NEED_LM90_DRIVER)
+	i2c_del_driver(&efx_lm90_driver);
+#endif
+#if defined(EFX_USE_KCOMPAT) && defined(EFX_NEED_LM87_DRIVER)
+	i2c_del_driver(&efx_lm87_driver);
+#endif
+#endif /* CONFIG_SFC_HWMON */
+#if defined(EFX_NOT_UPSTREAM) && defined(CONFIG_SMP) && !defined(__VMKLNX__)
+	kfree(rss_cpu_usage);
+#endif
 	destroy_workqueue(reset_workqueue);
-	destroy_workqueue(refill_workqueue);
 	unregister_netdevice_notifier(&efx_netdev_notifier);
+	efx_fini_debugfs();
 
+#if defined(EFX_NOT_UPSTREAM) && defined(EFX_GCOV)
+	gcov_provider_fini(THIS_MODULE);
+#endif
 }
+
+#if defined(EFX_NOT_UPSTREAM) && defined(EFX_ENABLE_DEBUG)
+/* Used by load.sh to reliably indicate DEBUG vs RELEASE */
+int __efx_enable_debug __attribute__((unused));
+#endif
 
 module_init(efx_init_module);
 module_exit(efx_exit_module);
 
-MODULE_AUTHOR("Michael Brown <mbrown@fensystems.co.uk> and "
-	      "Solarflare Communications");
+MODULE_AUTHOR("Solarflare Communications and "
+	      "Michael Brown <mbrown@fensystems.co.uk>");
 MODULE_DESCRIPTION("Solarflare Communications network driver");
 MODULE_LICENSE("GPL");
 MODULE_DEVICE_TABLE(pci, efx_pci_table);
+MODULE_VERSION(EFX_DRIVER_VERSION);
diff -r 5b3d4d3c1166 drivers/net/sfc/efx.h
--- a/drivers/net/sfc/efx.h	Fri Nov 05 15:20:28 2010 +0000
+++ b/drivers/net/sfc/efx.h	Tue Nov 09 10:06:27 2010 +0000
@@ -1,7 +1,7 @@
 /****************************************************************************
  * Driver for Solarflare Solarstorm network controllers and boards
  * Copyright 2005-2006 Fen Systems Ltd.
- * Copyright 2006-2008 Solarflare Communications Inc.
+ * Copyright 2006-2009 Solarflare Communications Inc.
  *
  * This program is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 as published
@@ -12,55 +12,156 @@
 #define EFX_EFX_H
 
 #include "net_driver.h"
+#include "filter.h"
 
 /* PCI IDs */
 #define EFX_VENDID_SFC	        0x1924
 #define FALCON_A_P_DEVID	0x0703
 #define FALCON_A_S_DEVID        0x6703
 #define FALCON_B_P_DEVID        0x0710
+#define BETHPAGE_A_P_DEVID      0x0803
+#define SIENA_A_P_DEVID         0x0813
+
+/* Solarstorm controllers use BAR 0 for I/O space and BAR 2(&3) for memory */
+#define EFX_MEM_BAR 2
 
 /* TX */
-extern netdev_tx_t efx_xmit(struct efx_nic *efx,
-				  struct efx_tx_queue *tx_queue,
-				  struct sk_buff *skb);
-extern void efx_stop_queue(struct efx_nic *efx);
-extern void efx_wake_queue(struct efx_nic *efx);
+extern int efx_probe_tx_queue(struct efx_tx_queue *tx_queue);
+extern void efx_remove_tx_queue(struct efx_tx_queue *tx_queue);
+extern void efx_init_tx_queue(struct efx_tx_queue *tx_queue);
+extern void efx_fini_tx_queue(struct efx_tx_queue *tx_queue);
+extern void efx_release_tx_buffers(struct efx_tx_queue *tx_queue);
+extern netdev_tx_t
+efx_hard_start_xmit(struct sk_buff *skb, struct net_device *net_dev);
+extern netdev_tx_t
+efx_enqueue_skb(struct efx_tx_queue *tx_queue, struct sk_buff *skb);
+#if defined(EFX_USE_KCOMPAT) && defined(EFX_USE_FASTCALL)
+extern void fastcall efx_xmit_done(struct efx_tx_queue *tx_queue,
+				   unsigned int index);
+#else
+extern void efx_xmit_done(struct efx_tx_queue *tx_queue, unsigned int index);
+#endif
+extern void efx_stop_queue(struct efx_channel *channel);
+extern void efx_wake_queue(struct efx_channel *channel);
 
 /* RX */
-extern void efx_xmit_done(struct efx_tx_queue *tx_queue, unsigned int index);
+extern int efx_probe_rx_queue(struct efx_rx_queue *rx_queue);
+extern void efx_remove_rx_queue(struct efx_rx_queue *rx_queue);
+extern void efx_init_rx_queue(struct efx_rx_queue *rx_queue);
+extern void efx_fini_rx_queue(struct efx_rx_queue *rx_queue);
+extern void efx_rx_strategy(struct efx_channel *channel);
+extern void efx_fast_push_rx_descriptors(struct efx_rx_queue *rx_queue);
+extern void efx_rx_slow_fill(unsigned long context);
+extern void __efx_rx_packet(struct efx_channel *channel,
+			    struct efx_rx_buffer *rx_buf, bool checksummed);
+#if defined(EFX_USE_KCOMPAT) && defined(EFX_USE_FASTCALL)
+extern void fastcall efx_rx_packet(struct efx_rx_queue *rx_queue,
+				   unsigned int index, unsigned int len,
+				   bool checksummed, bool discard);
+#else
 extern void efx_rx_packet(struct efx_rx_queue *rx_queue, unsigned int index,
 			  unsigned int len, bool checksummed, bool discard);
-extern void efx_schedule_slow_fill(struct efx_rx_queue *rx_queue, int delay);
+#endif
+extern void efx_schedule_slow_fill(struct efx_rx_queue *rx_queue);
+
+#define EFX_MAX_DMAQ_SIZE 4096UL
+#define EFX_DEFAULT_DMAQ_SIZE 1024UL
+#define EFX_MIN_DMAQ_SIZE 512UL
+
+#define EFX_MAX_EVQ_SIZE 16384UL
+#define EFX_MIN_EVQ_SIZE 512UL
+
+/* The smallest [rt]xq_entries that the driver supports. Callers of
+ * efx_wake_queue() assume that they can subsequently send at least one
+ * skb. Falcon/A1 may require up to three descriptors per skb_frag. */
+#define EFX_MIN_RING_SIZE (roundup_pow_of_two(2 * 3 * MAX_SKB_FRAGS))
+
+#if defined(EFX_NOT_UPSTREAM) && defined(EFX_USE_SFC_LRO)
+
+static inline bool efx_ssr_enabled(struct efx_nic *efx)
+{
+#ifdef NETIF_F_LRO
+	return !!(efx->net_dev->features & NETIF_F_LRO);
+#else
+	return efx->lro_enabled;
+#endif
+}
+
+extern int efx_ssr_init(struct efx_channel *channel, struct efx_nic *efx);
+extern void efx_ssr_fini(struct efx_channel *channel);
+extern void __efx_ssr_end_of_burst(struct efx_channel *channel);
+extern void efx_ssr(struct efx_channel *, struct efx_rx_buffer *rx_buf, u8 *eh);
+
+static inline void efx_ssr_end_of_burst(struct efx_channel *channel)
+{
+	if (!list_empty(&channel->ssr.active_conns))
+		__efx_ssr_end_of_burst(channel);
+}
+
+#endif /* EFX_USE_SFC_LRO */
+
+/* Filters */
+extern int efx_probe_filters(struct efx_nic *efx);
+extern void efx_restore_filters(struct efx_nic *efx);
+extern void efx_remove_filters(struct efx_nic *efx);
+extern int efx_filter_insert_filter(struct efx_nic *efx,
+				    struct efx_filter_spec *spec,
+				    bool replace);
+extern int efx_filter_remove_filter(struct efx_nic *efx,
+				    struct efx_filter_spec *spec);
+extern void efx_filter_remove_index(struct efx_nic *efx,
+				    enum efx_filter_table_id table_id,
+				    int filter_idx);
+extern void efx_filter_table_clear(struct efx_nic *efx,
+				   enum efx_filter_table_id table_id,
+				   enum efx_filter_priority priority);
+extern void efx_filter_redirect_index(struct efx_nic *efx,
+				      enum efx_filter_table_id table_id,
+				      int filter_i, int rxq_i);
 
 /* Channels */
 extern void efx_process_channel_now(struct efx_channel *channel);
-extern void efx_flush_queues(struct efx_nic *efx);
+extern int
+efx_realloc_channels(struct efx_nic *efx, u32 rxq_entries, u32 txq_entries);
 
 /* Ports */
-extern void efx_stats_disable(struct efx_nic *efx);
-extern void efx_stats_enable(struct efx_nic *efx);
-extern void efx_reconfigure_port(struct efx_nic *efx);
-extern void __efx_reconfigure_port(struct efx_nic *efx);
+extern int efx_reconfigure_port(struct efx_nic *efx);
+extern int __efx_reconfigure_port(struct efx_nic *efx);
+
+/* Ethtool support */
+#ifdef EFX_NOT_UPSTREAM
+extern int efx_ethtool_get_settings(struct net_device *net_dev,
+				    struct ethtool_cmd *ecmd);
+extern int efx_ethtool_set_settings(struct net_device *net_dev,
+				    struct ethtool_cmd *ecmd);
+extern int efx_ethtool_reset(struct net_device *net_dev, u32 *flags);
+extern int efx_ethtool_get_rxnfc(struct net_device *net_dev,
+				 struct ethtool_rxnfc *info, void *rules);
+extern int efx_ethtool_get_rxfh_indir(struct net_device *net_dev,
+				      struct ethtool_rxfh_indir *indir);
+extern int efx_ethtool_set_rxfh_indir(struct net_device *net_dev,
+				      const struct ethtool_rxfh_indir *indir);
+extern int efx_ethtool_set_rx_ntuple(struct net_device *net_dev,
+				     struct ethtool_rx_ntuple *ntuple);
+#endif
+extern const struct ethtool_ops efx_ethtool_ops;
 
 /* Reset handling */
-extern void efx_reset_down(struct efx_nic *efx, enum reset_type method,
-			   struct ethtool_cmd *ecmd);
-extern int efx_reset_up(struct efx_nic *efx, enum reset_type method,
-			struct ethtool_cmd *ecmd, bool ok);
+extern int efx_reset(struct efx_nic *efx, enum reset_type method);
+extern void efx_reset_down(struct efx_nic *efx, enum reset_type method);
+extern int efx_reset_up(struct efx_nic *efx, enum reset_type method, bool ok);
 
 /* Global */
 extern void efx_schedule_reset(struct efx_nic *efx, enum reset_type type);
-extern void efx_suspend(struct efx_nic *efx);
-extern void efx_resume(struct efx_nic *efx);
+extern void efx_start_all(struct efx_nic *efx);
+extern void efx_stop_all(struct efx_nic *efx);
 extern void efx_init_irq_moderation(struct efx_nic *efx, int tx_usecs,
 				    int rx_usecs, bool rx_adaptive);
-extern int efx_request_power(struct efx_nic *efx, int mw, const char *name);
-extern void efx_hex_dump(const u8 *, unsigned int, const char *);
 
 /* Dummy PHY ops for PHY drivers */
 extern int efx_port_dummy_op_int(struct efx_nic *efx);
 extern void efx_port_dummy_op_void(struct efx_nic *efx);
-extern void efx_port_dummy_op_blink(struct efx_nic *efx, bool blink);
+
 
 /* MTD */
 #ifdef CONFIG_SFC_MTD
@@ -73,15 +174,18 @@ static inline void efx_mtd_remove(struct
 static inline void efx_mtd_remove(struct efx_nic *efx) {}
 #endif
 
-extern unsigned int efx_monitor_interval;
-
 static inline void efx_schedule_channel(struct efx_channel *channel)
 {
-	EFX_TRACE(channel->efx, "channel %d scheduling NAPI poll on CPU%d\n",
-		  channel->channel, raw_smp_processor_id());
+	netif_vdbg(channel->efx, intr, channel->efx->net_dev,
+		   "channel %d scheduling NAPI poll on CPU%d\n",
+		   channel->channel, raw_smp_processor_id());
 	channel->work_pending = true;
 
 	napi_schedule(&channel->napi_str);
 }
 
+extern void efx_link_status_changed(struct efx_nic *efx);
+extern void efx_link_set_advertising(struct efx_nic *efx, u32);
+extern void efx_link_set_wanted_fc(struct efx_nic *efx, enum efx_fc_type);
+
 #endif /* EFX_EFX_H */
diff -r 5b3d4d3c1166 drivers/net/sfc/efx_ioctl.h
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/drivers/net/sfc/efx_ioctl.h	Tue Nov 09 10:06:27 2010 +0000
@@ -0,0 +1,192 @@
+/****************************************************************************
+ * Driver for Solarflare network controllers
+ *           (including support for SFE4001 10GBT NIC)
+ *
+ * Copyright 2005-2006: Fen Systems Ltd.
+ * Copyright 2006-2009: Solarflare Communications Inc,
+ *                      9501 Jeronimo Road, Suite 250,
+ *                      Irvine, CA 92618, USA
+ *
+ * Initially developed by Michael Brown <mbrown@fensystems.co.uk>
+ * Maintained by Solarflare Communications <linux-net-drivers@solarflare.com>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 as published
+ * by the Free Software Foundation, incorporated herein by reference.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ ****************************************************************************
+ */
+
+#ifndef EFX_IOCTL_H
+#define EFX_IOCTL_H
+
+#if defined(__KERNEL__)
+#include <linux/if.h>
+#else
+#include <net/if.h>
+#ifndef _LINUX_IF_H
+#define _LINUX_IF_H /* prevent <linux/if.h> from conflicting with <net/if.h> */
+#endif
+#endif
+#include <linux/if_ether.h>
+#include <linux/sockios.h>
+#include <linux/types.h>
+
+/* Old versions of <linux/ethtool.h> use the kernel type names (no
+ * '__' prefix).  To avoid conflicting with other workarounds using
+ * typedefs, temporarily define macros for them. */
+#define u8 __u8
+#define u16 __u16
+#define u32 __u32
+#define u64 __u64
+#include <linux/ethtool.h>
+#undef u8
+#undef u16
+#undef u32
+#undef u64
+
+/* Efx private ioctl number */
+/* We do not use the first 3 private ioctls because some utilities expect
+ * them to be the old MDIO ioctls. */
+#define SIOCEFX (SIOCDEVPRIVATE + 3)
+
+/*
+ * Efx private ioctls
+ */
+
+/* For talking MCDI to siena ************************************************/
+#define EFX_MCDI_REQUEST 0xef0c
+struct efx_mcdi_request {
+	__u32 payload[63];
+	__u8 cmd;
+	__u8 len; /* In and out */
+	__u8 rc;
+};
+
+/* Reset selected components, like ETHTOOL_RESET ****************************/
+#define EFX_RESET_FLAGS 0xef0d
+struct efx_reset_flags {
+	__u32 flags;
+};
+
+/* Get RX flow hashing capabilities, like ETHTOOL_GRX{RINGS,FH} *************/
+#define EFX_RXNFC 0xef0e
+#ifndef ETHTOOL_GRXRINGS
+	#ifndef ETHTOOL_GRXFH
+		/* Truncated definition of the structure; we don't need
+		 * the full definition. */
+		struct ethtool_rxnfc {
+			__u32				cmd;
+			__u32				flow_type;
+			__u64				data;
+		};
+		#define ETHTOOL_GRXFH		0x00000029
+	#endif
+	#define ETHTOOL_GRXRINGS	0x0000002d
+#endif
+
+/* Get/set RX flow hash indirection table, like ETHTOOL_{G,S}RXFHINDIR} *****/
+#define EFX_RXFHINDIR 0xef10
+#ifndef ETHTOOL_GRXFHINDIR
+	struct ethtool_rxfh_indir {
+		__u32	cmd;
+		/* On entry, this is the array size of the user buffer.  On
+		 * return from ETHTOOL_GRXFHINDIR, this is the array size of
+		 * the hardware indirection table. */
+		__u32	size;
+		__u32	ring_index[0];	/* ring/queue index for each hash value */
+	};
+	#define ETHTOOL_GRXFHINDIR	0x00000038
+	#define ETHTOOL_SRXFHINDIR	0x00000039
+#endif
+struct efx_rxfh_indir {
+	struct ethtool_rxfh_indir head;
+	__u32 table[128];
+};
+
+/* Set RX n-tuple filter, like ETHTOOL_SRXNTUPLE ****************************/
+#define EFX_RXNTUPLE 0xef11
+#ifndef ETHTOOL_GRXCLSRULE
+	struct ethtool_tcpip4_spec {
+		__u32	ip4src;
+		__u32	ip4dst;
+		__u16	psrc;
+		__u16	pdst;
+		__u8    tos;
+	};
+	#define ETHTOOL_GRXCLSRULE	0x0000002f
+#endif
+struct efx_ethtool_rx_ntuple_flow_spec {
+	__u32		 flow_type;
+	union {
+		struct ethtool_tcpip4_spec		tcp_ip4_spec;
+		struct ethtool_tcpip4_spec		udp_ip4_spec;
+		struct ethtool_tcpip4_spec		sctp_ip4_spec;
+		struct ethhdr				ether_spec;
+		__u8					hdata[72];
+	} h_u, m_u;
+	__u16	        vlan_tag;
+	__u16	        vlan_tag_mask;
+	__u64		data;
+	__u64		data_mask;
+	__s32		action;
+};
+struct efx_ethtool_rx_ntuple {
+	__u32					cmd;
+	struct efx_ethtool_rx_ntuple_flow_spec	fs;
+};
+#ifndef ETHTOOL_SRXNTUPLE
+	#define ETHTOOL_RXNTUPLE_ACTION_DROP	(-1)
+	#define ETHTOOL_SRXNTUPLE	0x00000035
+	#define ETHTOOL_GRXNTUPLE	0x00000036
+#endif
+#ifndef ETHTOOL_RXNTUPLE_ACTION_CLEAR
+	#define ETHTOOL_RXNTUPLE_ACTION_CLEAR	(-2)
+#endif
+
+/* Efx private ioctl command structures *************************************/
+
+union efx_ioctl_data {
+	struct efx_mcdi_request mcdi_request;
+	struct efx_reset_flags reset_flags;
+	struct ethtool_rxnfc rxnfc;
+	struct efx_rxfh_indir rxfh_indir;
+	struct efx_ethtool_rx_ntuple rxntuple;
+};
+
+#ifdef EFX_NOT_UPSTREAM
+struct efx_ioctl {
+	char if_name[IFNAMSIZ];
+	/* Command to run */
+	__u16 cmd;
+	/* Parameters */
+	union efx_ioctl_data u;
+} __attribute__ ((packed));
+#endif
+
+struct efx_sock_ioctl {
+	/* Command to run */
+	__u16 cmd;
+	__u16 reserved;
+	/* Parameters */
+	union efx_ioctl_data u;
+} __attribute__ ((packed));
+
+#ifdef __KERNEL__
+extern int efx_private_ioctl(struct efx_nic *efx, u16 cmd,
+			     union efx_ioctl_data __user *data);
+#ifdef EFX_NOT_UPSTREAM
+extern int efx_control_init(void);
+extern void efx_control_fini(void);
+#endif
+#endif
+
+#endif /* EFX_IOCTL_H */
diff -r 5b3d4d3c1166 drivers/net/sfc/enum.h
--- a/drivers/net/sfc/enum.h	Fri Nov 05 15:20:28 2010 +0000
+++ b/drivers/net/sfc/enum.h	Tue Nov 09 10:06:27 2010 +0000
@@ -1,6 +1,6 @@
 /****************************************************************************
  * Driver for Solarflare Solarstorm network controllers and boards
- * Copyright 2007-2008 Solarflare Communications Inc.
+ * Copyright 2007-2009 Solarflare Communications Inc.
  *
  * This program is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 as published
@@ -13,50 +13,110 @@
 /**
  * enum efx_loopback_mode - loopback modes
  * @LOOPBACK_NONE: no loopback
- * @LOOPBACK_GMAC: loopback within GMAC at unspecified level
- * @LOOPBACK_XGMII: loopback within XMAC at XGMII level
- * @LOOPBACK_XGXS: loopback within XMAC at XGXS level
- * @LOOPBACK_XAUI: loopback within XMAC at XAUI level
+ * @LOOPBACK_DATA: data path loopback
+ * @LOOPBACK_GMAC: loopback within GMAC
+ * @LOOPBACK_XGMII: loopback after XMAC
+ * @LOOPBACK_XGXS: loopback within BPX after XGXS
+ * @LOOPBACK_XAUI: loopback within BPX before XAUI serdes
+ * @LOOPBACK_GMII: loopback within BPX after GMAC
+ * @LOOPBACK_SGMII: loopback within BPX within SGMII
+ * @LOOPBACK_XGBR: loopback within BPX within XGBR
+ * @LOOPBACK_XFI: loopback within BPX before XFI serdes
+ * @LOOPBACK_XAUI_FAR: loopback within BPX after XAUI serdes
+ * @LOOPBACK_GMII_FAR: loopback within BPX before SGMII
+ * @LOOPBACK_SGMII_FAR: loopback within BPX after SGMII
+ * @LOOPBACK_XFI_FAR: loopback after XFI serdes
  * @LOOPBACK_GPHY: loopback within 1G PHY at unspecified level
  * @LOOPBACK_PHYXS: loopback within 10G PHY at PHYXS level
  * @LOOPBACK_PCS: loopback within 10G PHY at PCS level
  * @LOOPBACK_PMAPMD: loopback within 10G PHY at PMAPMD level
- * @LOOPBACK_NETWORK: reflecting loopback (even further than furthest!)
+ * @LOOPBACK_XPORT: cross port loopback
+ * @LOOPBACK_XGMII_WS: wireside loopback excluding XMAC
+ * @LOOPBACK_XAUI_WS: wireside loopback within BPX within XAUI serdes
+ * @LOOPBACK_XAUI_WS_FAR: wireside loopback within BPX including XAUI serdes
+ * @LOOPBACK_XAUI_WS_NEAR: wireside loopback within BPX excluding XAUI serdes
+ * @LOOPBACK_GMII_WS: wireside loopback excluding GMAC
+ * @LOOPBACK_XFI_WS: wireside loopback excluding XFI serdes
+ * @LOOPBACK_XFI_WS_FAR: wireside loopback including XFI serdes
+ * @LOOPBACK_PHYXS_WS: wireside loopback within 10G PHY at PHYXS level
  */
-/* Please keep in order and up-to-date w.r.t the following two #defines */
+/* Please keep up-to-date w.r.t the following two #defines */
 enum efx_loopback_mode {
 	LOOPBACK_NONE = 0,
-	LOOPBACK_GMAC = 1,
-	LOOPBACK_XGMII = 2,
-	LOOPBACK_XGXS = 3,
-	LOOPBACK_XAUI = 4,
-	LOOPBACK_GPHY = 5,
-	LOOPBACK_PHYXS = 6,
-	LOOPBACK_PCS = 7,
-	LOOPBACK_PMAPMD = 8,
-	LOOPBACK_NETWORK = 9,
+	LOOPBACK_DATA = 1,
+	LOOPBACK_GMAC = 2,
+	LOOPBACK_XGMII = 3,
+	LOOPBACK_XGXS = 4,
+	LOOPBACK_XAUI = 5,
+	LOOPBACK_GMII = 6,
+	LOOPBACK_SGMII = 7,
+	LOOPBACK_XGBR = 8,
+	LOOPBACK_XFI = 9,
+	LOOPBACK_XAUI_FAR = 10,
+	LOOPBACK_GMII_FAR = 11,
+	LOOPBACK_SGMII_FAR = 12,
+	LOOPBACK_XFI_FAR = 13,
+	LOOPBACK_GPHY = 14,
+	LOOPBACK_PHYXS = 15,
+	LOOPBACK_PCS = 16,
+	LOOPBACK_PMAPMD = 17,
+	LOOPBACK_XPORT = 18,
+	LOOPBACK_XGMII_WS = 19,
+	LOOPBACK_XAUI_WS = 20,
+	LOOPBACK_XAUI_WS_FAR = 21,
+	LOOPBACK_XAUI_WS_NEAR = 22,
+	LOOPBACK_GMII_WS = 23,
+	LOOPBACK_XFI_WS = 24,
+	LOOPBACK_XFI_WS_FAR = 25,
+	LOOPBACK_PHYXS_WS = 26,
 	LOOPBACK_MAX
 };
-
 #define LOOPBACK_TEST_MAX LOOPBACK_PMAPMD
 
-extern const char *efx_loopback_mode_names[];
-#define LOOPBACK_MODE_NAME(mode)			\
-	STRING_TABLE_LOOKUP(mode, efx_loopback_mode)
-#define LOOPBACK_MODE(efx)				\
-	LOOPBACK_MODE_NAME(efx->loopback_mode)
+/* These loopbacks occur within the controller */
+#define LOOPBACKS_INTERNAL ((1 << LOOPBACK_DATA) |		\
+			    (1 << LOOPBACK_GMAC) |		\
+			    (1 << LOOPBACK_XGMII)|		\
+			    (1 << LOOPBACK_XGXS) |		\
+			    (1 << LOOPBACK_XAUI) |		\
+			    (1 << LOOPBACK_GMII) |		\
+			    (1 << LOOPBACK_SGMII) |		\
+			    (1 << LOOPBACK_SGMII) |		\
+			    (1 << LOOPBACK_XGBR) |		\
+			    (1 << LOOPBACK_XFI) |		\
+			    (1 << LOOPBACK_XAUI_FAR) |		\
+			    (1 << LOOPBACK_GMII_FAR) |		\
+			    (1 << LOOPBACK_SGMII_FAR) |		\
+			    (1 << LOOPBACK_XFI_FAR) |		\
+			    (1 << LOOPBACK_XGMII_WS) |		\
+			    (1 << LOOPBACK_XAUI_WS) |		\
+			    (1 << LOOPBACK_XAUI_WS_FAR) |	\
+			    (1 << LOOPBACK_XAUI_WS_NEAR) |	\
+			    (1 << LOOPBACK_GMII_WS) |		\
+			    (1 << LOOPBACK_XFI_WS) |		\
+			    (1 << LOOPBACK_XFI_WS_FAR))
 
-/* These loopbacks occur within the controller */
-#define LOOPBACKS_INTERNAL ((1 << LOOPBACK_GMAC) |     \
-			    (1 << LOOPBACK_XGMII)|     \
-			    (1 << LOOPBACK_XGXS) |     \
-			    (1 << LOOPBACK_XAUI))
+#define LOOPBACKS_WS ((1 << LOOPBACK_XGMII_WS) |		\
+		      (1 << LOOPBACK_XAUI_WS) |			\
+		      (1 << LOOPBACK_XAUI_WS_FAR) |		\
+		      (1 << LOOPBACK_XAUI_WS_NEAR) |		\
+		      (1 << LOOPBACK_GMII_WS) |			\
+		      (1 << LOOPBACK_XFI_WS) |			\
+		      (1 << LOOPBACK_XFI_WS_FAR) |		\
+		      (1 << LOOPBACK_PHYXS_WS))
+
+#define LOOPBACKS_EXTERNAL(_efx)					\
+	((_efx)->loopback_modes & ~LOOPBACKS_INTERNAL &			\
+	 ~(1 << LOOPBACK_NONE))
 
 #define LOOPBACK_MASK(_efx)			\
 	(1 << (_efx)->loopback_mode)
 
 #define LOOPBACK_INTERNAL(_efx)				\
 	(!!(LOOPBACKS_INTERNAL & LOOPBACK_MASK(_efx)))
+
+#define LOOPBACK_EXTERNAL(_efx)				\
+	(!!(LOOPBACK_MASK(_efx) & LOOPBACKS_EXTERNAL(_efx)))
 
 #define LOOPBACK_CHANGED(_from, _to, _mask)				\
 	(!!((LOOPBACK_MASK(_from) ^ LOOPBACK_MASK(_to)) & (_mask)))
@@ -84,6 +144,7 @@ extern const char *efx_loopback_mode_nam
  * @RESET_TYPE_RX_DESC_FETCH: pcie error during rx descriptor fetch
  * @RESET_TYPE_TX_DESC_FETCH: pcie error during tx descriptor fetch
  * @RESET_TYPE_TX_SKIP: hardware completed empty tx descriptors
+ * @RESET_TYPE_MC_FAILURE: MC reboot/assertion
  */
 enum reset_type {
 	RESET_TYPE_NONE = -1,
@@ -98,6 +159,7 @@ enum reset_type {
 	RESET_TYPE_RX_DESC_FETCH,
 	RESET_TYPE_TX_DESC_FETCH,
 	RESET_TYPE_TX_SKIP,
+	RESET_TYPE_MC_FAILURE,
 	RESET_TYPE_MAX,
 };
 
diff -r 5b3d4d3c1166 drivers/net/sfc/ethtool.c
--- a/drivers/net/sfc/ethtool.c	Fri Nov 05 15:20:28 2010 +0000
+++ b/drivers/net/sfc/ethtool.c	Tue Nov 09 10:06:27 2010 +0000
@@ -1,7 +1,7 @@
 /****************************************************************************
  * Driver for Solarflare Solarstorm network controllers and boards
  * Copyright 2005-2006 Fen Systems Ltd.
- * Copyright 2006-2008 Solarflare Communications Inc.
+ * Copyright 2006-2009 Solarflare Communications Inc.
  *
  * This program is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 as published
@@ -10,29 +10,15 @@
 
 #include <linux/netdevice.h>
 #include <linux/ethtool.h>
-#include <linux/mdio.h>
 #include <linux/rtnetlink.h>
 #include "net_driver.h"
 #include "workarounds.h"
 #include "selftest.h"
 #include "efx.h"
-#include "ethtool.h"
-#include "falcon.h"
+#include "filter.h"
+#include "nic.h"
 #include "spi.h"
 #include "mdio_10g.h"
-
-const char *efx_loopback_mode_names[] = {
-	[LOOPBACK_NONE]		= "NONE",
-	[LOOPBACK_GMAC]		= "GMAC",
-	[LOOPBACK_XGMII]	= "XGMII",
-	[LOOPBACK_XGXS]		= "XGXS",
-	[LOOPBACK_XAUI] 	= "XAUI",
-	[LOOPBACK_GPHY]		= "GPHY",
-	[LOOPBACK_PHYXS]	= "PHYXS",
-	[LOOPBACK_PCS]	 	= "PCS",
-	[LOOPBACK_PMAPMD]	= "PMA/PMD",
-	[LOOPBACK_NETWORK]	= "NETWORK",
-};
 
 struct ethtool_string {
 	char name[ETH_GSTRING_LEN];
@@ -94,7 +80,7 @@ static u64 efx_get_atomic_stat(void *fie
 			 unsigned int, efx_get_uint_stat)
 
 #define EFX_ETHTOOL_ATOMIC_NIC_ERROR_STAT(field)		\
-	EFX_ETHTOOL_STAT(field, nic, field,			\
+	EFX_ETHTOOL_STAT(field, nic, errors.field,		\
 			 atomic_t, efx_get_atomic_stat)
 
 #define EFX_ETHTOOL_UINT_CHANNEL_STAT(field)			\
@@ -167,7 +153,18 @@ static struct efx_ethtool_stat efx_ethto
 	EFX_ETHTOOL_UINT_CHANNEL_STAT(rx_tobe_disc),
 	EFX_ETHTOOL_UINT_CHANNEL_STAT(rx_ip_hdr_chksum_err),
 	EFX_ETHTOOL_UINT_CHANNEL_STAT(rx_tcp_udp_chksum_err),
+	EFX_ETHTOOL_UINT_CHANNEL_STAT(rx_eth_crc_err),
+	EFX_ETHTOOL_UINT_CHANNEL_STAT(rx_mcast_mismatch),
 	EFX_ETHTOOL_UINT_CHANNEL_STAT(rx_frm_trunc),
+	EFX_ETHTOOL_ULONG_MAC_STAT(rx_char_error_lane0),
+	EFX_ETHTOOL_ULONG_MAC_STAT(rx_char_error_lane1),
+	EFX_ETHTOOL_ULONG_MAC_STAT(rx_char_error_lane2),
+	EFX_ETHTOOL_ULONG_MAC_STAT(rx_char_error_lane3),
+	EFX_ETHTOOL_ULONG_MAC_STAT(rx_disp_error_lane0),
+	EFX_ETHTOOL_ULONG_MAC_STAT(rx_disp_error_lane1),
+	EFX_ETHTOOL_ULONG_MAC_STAT(rx_disp_error_lane2),
+	EFX_ETHTOOL_ULONG_MAC_STAT(rx_disp_error_lane3),
+	EFX_ETHTOOL_U64_MAC_STAT(rx_match_fault),
 };
 
 /* Number of ethtool statistics */
@@ -187,52 +184,88 @@ static int efx_ethtool_phys_id(struct ne
 {
 	struct efx_nic *efx = netdev_priv(net_dev);
 
-	efx->board_info.blink(efx, 1);
-	set_current_state(TASK_INTERRUPTIBLE);
-	if (count)
-		schedule_timeout(count * HZ);
-	else
-		schedule();
-	efx->board_info.blink(efx, 0);
+	do {
+		efx->type->set_id_led(efx, EFX_LED_ON);
+		schedule_timeout_interruptible(HZ / 2);
+
+		efx->type->set_id_led(efx, EFX_LED_OFF);
+		schedule_timeout_interruptible(HZ / 2);
+	} while (!signal_pending(current) && --count != 0);
+
+	efx->type->set_id_led(efx, EFX_LED_DEFAULT);
 	return 0;
 }
 
 /* This must be called with rtnl_lock held. */
+#ifdef EFX_NOT_UPSTREAM
 int efx_ethtool_get_settings(struct net_device *net_dev,
 			     struct ethtool_cmd *ecmd)
+#else
+static int efx_ethtool_get_settings(struct net_device *net_dev,
+				    struct ethtool_cmd *ecmd)
+#endif
 {
 	struct efx_nic *efx = netdev_priv(net_dev);
+	struct efx_link_state *link_state = &efx->link_state;
+
+#if defined(EFX_USE_KCOMPAT) && defined(EFX_NEED_BONDING_HACKS)
+	if (in_interrupt()) {
+		memset(ecmd, 0, sizeof(*ecmd));
+		ecmd->speed = link_state->speed;
+		ecmd->duplex = link_state->fd ? DUPLEX_FULL : DUPLEX_HALF;
+		return 0;
+	}
+#endif
 
 	mutex_lock(&efx->mac_lock);
 	efx->phy_op->get_settings(efx, ecmd);
 	mutex_unlock(&efx->mac_lock);
 
-	/* Falcon GMAC does not support 1000Mbps HD */
+	/* GMAC does not support 1000Mbps HD */
 	ecmd->supported &= ~SUPPORTED_1000baseT_Half;
+	/* Both MACs support pause frames (bidirectional and respond-only) */
+	ecmd->supported |= SUPPORTED_Pause | SUPPORTED_Asym_Pause;
+
+	if (LOOPBACK_INTERNAL(efx)) {
+		ecmd->speed = link_state->speed;
+		ecmd->duplex = link_state->fd ? DUPLEX_FULL : DUPLEX_HALF;
+	}
 
 	return 0;
 }
 
 /* This must be called with rtnl_lock held. */
+#ifdef EFX_NOT_UPSTREAM
 int efx_ethtool_set_settings(struct net_device *net_dev,
 			     struct ethtool_cmd *ecmd)
+#else
+static int efx_ethtool_set_settings(struct net_device *net_dev,
+				    struct ethtool_cmd *ecmd)
+#endif
 {
 	struct efx_nic *efx = netdev_priv(net_dev);
 	int rc;
 
-	/* Falcon GMAC does not support 1000Mbps HD */
+	/* Older versions of ethtool don't set all the right bits when
+	 * turning autoneg on with no speed/duplex specified.  But they
+	 * always set more than one bit in this case, so test for that.
+	 * Allow overriding this in ethtool 6 by setting
+	 * ADVERTISED_Autoneg = 0x40.
+	 */
+	if (ecmd->advertising & (ecmd->advertising - 1) &&
+	    !(ecmd->advertising & ADVERTISED_Autoneg))
+		ecmd->advertising = ecmd->supported;
+
+	/* GMAC does not support 1000Mbps HD */
 	if (ecmd->speed == SPEED_1000 && ecmd->duplex != DUPLEX_FULL) {
-		EFX_LOG(efx, "rejecting unsupported 1000Mbps HD"
-			" setting\n");
+		netif_dbg(efx, drv, efx->net_dev,
+			  "rejecting unsupported 1000Mbps HD setting\n");
 		return -EINVAL;
 	}
 
 	mutex_lock(&efx->mac_lock);
 	rc = efx->phy_op->set_settings(efx, ecmd);
 	mutex_unlock(&efx->mac_lock);
-	if (!rc)
-		efx_reconfigure_port(efx);
-
 	return rc;
 }
 
@@ -241,9 +274,38 @@ static void efx_ethtool_get_drvinfo(stru
 {
 	struct efx_nic *efx = netdev_priv(net_dev);
 
-	strlcpy(info->driver, EFX_DRIVER_NAME, sizeof(info->driver));
+	strlcpy(info->driver, KBUILD_MODNAME, sizeof(info->driver));
 	strlcpy(info->version, EFX_DRIVER_VERSION, sizeof(info->version));
+	if (efx_nic_rev(efx) >= EFX_REV_SIENA_A0)
+		efx_mcdi_print_fwver(efx, info->fw_version,
+				     sizeof(info->fw_version));
 	strlcpy(info->bus_info, pci_name(efx->pci_dev), sizeof(info->bus_info));
+}
+
+static int efx_ethtool_get_regs_len(struct net_device *net_dev)
+{
+	return efx_nic_get_regs_len(netdev_priv(net_dev));
+}
+
+static void efx_ethtool_get_regs(struct net_device *net_dev,
+				 struct ethtool_regs *regs, void *buf)
+{
+	struct efx_nic *efx = netdev_priv(net_dev);
+
+	regs->version = efx->type->revision;
+	efx_nic_get_regs(efx, buf);
+}
+
+static u32 efx_ethtool_get_msglevel(struct net_device *net_dev)
+{
+	struct efx_nic *efx = netdev_priv(net_dev);
+	return efx->msg_enable;
+}
+
+static void efx_ethtool_set_msglevel(struct net_device *net_dev, u32 msg_enable)
+{
+	struct efx_nic *efx = netdev_priv(net_dev);
+	efx->msg_enable = msg_enable;
 }
 
 /**
@@ -285,11 +347,8 @@ static void efx_fill_test(unsigned int t
 	}
 }
 
-#define EFX_CHANNEL_NAME(_channel) "chan%d", _channel->channel
-#define EFX_TX_QUEUE_NAME(_tx_queue) "txq%d", _tx_queue->queue
-#define EFX_RX_QUEUE_NAME(_rx_queue) "rxq%d", _rx_queue->queue
 #define EFX_LOOPBACK_NAME(_mode, _counter)			\
-	"loopback.%s." _counter, LOOPBACK_MODE_NAME(mode)
+	"loopback.%s." _counter, STRING_TABLE_LOOKUP(_mode, efx_loopback_mode)
 
 /**
  * efx_fill_loopback_test - fill in a block of loopback self-test entries
@@ -299,6 +358,9 @@ static void efx_fill_test(unsigned int t
  * @test_index:		Starting index of the test
  * @strings:		Ethtool strings, or %NULL
  * @data:		Ethtool test results, or %NULL
+ *
+ * Fill in a block of loopback self-test entries.  Return new test
+ * index.
  */
 static int efx_fill_loopback_test(struct efx_nic *efx,
 				  struct efx_loopback_self_tests *lb_tests,
@@ -306,9 +368,10 @@ static int efx_fill_loopback_test(struct
 				  unsigned int test_index,
 				  struct ethtool_string *strings, u64 *data)
 {
+	struct efx_channel *channel = efx_get_channel(efx, 0);
 	struct efx_tx_queue *tx_queue;
 
-	efx_for_each_tx_queue(tx_queue, efx) {
+	efx_for_each_channel_tx_queue(tx_queue, channel) {
 		efx_fill_test(test_index++, strings, data,
 			      &lb_tests->tx_sent[tx_queue->queue],
 			      EFX_TX_QUEUE_NAME(tx_queue),
@@ -336,6 +399,12 @@ static int efx_fill_loopback_test(struct
  * @tests:		Efx self-test results structure, or %NULL
  * @strings:		Ethtool strings, or %NULL
  * @data:		Ethtool test results, or %NULL
+ *
+ * Get self-test number of strings, strings, and/or test results.
+ * Return number of strings (== number of test results).
+ *
+ * The reason for merging these three functions is to make sure that
+ * they can never be inconsistent.
  */
 static int efx_ethtool_fill_self_tests(struct efx_nic *efx,
 				       struct efx_self_tests *tests,
@@ -346,8 +415,8 @@ static int efx_ethtool_fill_self_tests(s
 	unsigned int n = 0, i;
 	enum efx_loopback_mode mode;
 
-	efx_fill_test(n++, strings, data, &tests->mdio,
-		      "core", 0, "mdio", NULL);
+	efx_fill_test(n++, strings, data, &tests->phy_alive,
+		      "phy", 0, "alive", NULL);
 	efx_fill_test(n++, strings, data, &tests->nvram,
 		      "core", 0, "nvram", NULL);
 	efx_fill_test(n++, strings, data, &tests->interrupt,
@@ -369,12 +438,26 @@ static int efx_ethtool_fill_self_tests(s
 			      "eventq.poll", NULL);
 	}
 
+	efx_fill_test(n++, strings, data, &tests->memory,
+		      "core", 0, "memory", NULL);
 	efx_fill_test(n++, strings, data, &tests->registers,
 		      "core", 0, "registers", NULL);
 
-	for (i = 0; i < efx->phy_op->num_tests; i++)
-		efx_fill_test(n++, strings, data, &tests->phy[i],
-			      "phy", 0, efx->phy_op->test_names[i], NULL);
+	if (efx->phy_op->run_tests != NULL) {
+		EFX_BUG_ON_PARANOID(efx->phy_op->test_name == NULL);
+
+		for (i = 0; true; ++i) {
+			const char *name;
+
+			EFX_BUG_ON_PARANOID(i >= EFX_MAX_PHY_TESTS);
+			name = efx->phy_op->test_name(efx, i);
+			if (name == NULL)
+				break;
+
+			efx_fill_test(n++, strings, data, &tests->phy_ext[i],
+				      "phy", 0, name, NULL);
+		}
+	}
 
 	/* Loopback tests */
 	for (mode = LOOPBACK_NONE; mode <= LOOPBACK_TEST_MAX; mode++) {
@@ -402,6 +485,17 @@ static int efx_ethtool_get_sset_count(st
 	}
 }
 
+#if defined(EFX_USE_KCOMPAT) && !defined(EFX_USE_ETHTOOL_GET_SSET_COUNT)
+static int efx_ethtool_get_stats_count(struct net_device *net_dev)
+{
+	return efx_ethtool_get_sset_count(net_dev, ETH_SS_STATS);
+}
+static int efx_ethtool_self_test_count(struct net_device *net_dev)
+{
+	return efx_ethtool_get_sset_count(net_dev, ETH_SS_TEST);
+}
+#endif
+
 static void efx_ethtool_get_strings(struct net_device *net_dev,
 				    u32 string_set, u8 *strings)
 {
@@ -428,19 +522,26 @@ static void efx_ethtool_get_strings(stru
 }
 
 static void efx_ethtool_get_stats(struct net_device *net_dev,
-				  struct ethtool_stats *stats,
-				  u64 *data)
+				  struct ethtool_stats *stats
+				  __attribute__ ((unused)), u64 *data)
 {
 	struct efx_nic *efx = netdev_priv(net_dev);
 	struct efx_mac_stats *mac_stats = &efx->mac_stats;
 	struct efx_ethtool_stat *stat;
 	struct efx_channel *channel;
+#if !defined(EFX_USE_KCOMPAT) || defined(EFX_USE_NETDEV_STATS64)
+	struct rtnl_link_stats64 temp;
+#endif
 	int i;
 
 	EFX_BUG_ON_PARANOID(stats->n_stats != EFX_ETHTOOL_NUM_STATS);
 
 	/* Update MAC and NIC statistics */
+#if !defined(EFX_USE_KCOMPAT) || defined(EFX_USE_NETDEV_STATS64)
+	dev_get_stats(net_dev, &temp);
+#else
 	dev_get_stats(net_dev);
+#endif
 
 	/* Fill detailed statistics buffer */
 	for (i = 0; i < EFX_ETHTOOL_NUM_STATS; i++) {
@@ -463,6 +564,69 @@ static void efx_ethtool_get_stats(struct
 	}
 }
 
+static int efx_ethtool_set_tso(struct net_device *net_dev, u32 enable)
+{
+	struct efx_nic *efx __attribute__ ((unused)) = netdev_priv(net_dev);
+	unsigned long features;
+
+#if defined(EFX_USE_KCOMPAT) && defined(EFX_NEED_ETHTOOL_OFFLOAD_SANITY_CHECKS)
+	if (enable && !(net_dev->features & NETIF_F_SG))
+		return -EINVAL;
+#endif
+
+	features = NETIF_F_TSO;
+#if !defined(EFX_USE_KCOMPAT) || defined(NETIF_F_TSO6)
+	if (efx->type->offload_features & NETIF_F_V6_CSUM)
+		features |= NETIF_F_TSO6;
+#endif
+
+	if (enable)
+		net_dev->features |= features;
+	else
+		net_dev->features &= ~features;
+
+	return 0;
+}
+
+#if defined(EFX_USE_KCOMPAT) && defined(EFX_NEED_ETHTOOL_OFFLOAD_SANITY_CHECKS)
+static int efx_ethtool_set_sg(struct net_device *net_dev, u32 enable)
+{
+	if (enable) {
+		if (!(net_dev->features & NETIF_F_ALL_CSUM))
+			return -EINVAL;
+		net_dev->features |= NETIF_F_SG;
+	} else {
+		efx_ethtool_set_tso(net_dev, 0);
+		net_dev->features &= ~NETIF_F_SG;
+	}
+	return 0;
+}
+#endif
+
+#if defined(EFX_USE_KCOMPAT) && !defined(EFX_USE_ETHTOOL_OP_GET_TX_CSUM)
+static u32 efx_ethtool_get_tx_csum(struct net_device *net_dev)
+{
+	return (net_dev->features & NETIF_F_ALL_CSUM) != 0;
+}
+#endif
+
+static int efx_ethtool_set_tx_csum(struct net_device *net_dev, u32 enable)
+{
+	struct efx_nic *efx = netdev_priv(net_dev);
+	unsigned long features = efx->type->offload_features & NETIF_F_ALL_CSUM;
+
+#if defined(EFX_USE_KCOMPAT) && defined(EFX_NEED_ETHTOOL_OFFLOAD_SANITY_CHECKS)
+	if (!enable)
+		efx_ethtool_set_sg(net_dev, 0);
+#endif
+	if (enable)
+		net_dev->features |= features;
+	else
+		net_dev->features &= ~features;
+
+	return 0;
+}
+
 static int efx_ethtool_set_rx_csum(struct net_device *net_dev, u32 enable)
 {
 	struct efx_nic *efx = netdev_priv(net_dev);
@@ -482,27 +646,65 @@ static u32 efx_ethtool_get_rx_csum(struc
 	return efx->rx_checksum_enabled;
 }
 
+#if !defined(EFX_USE_KCOMPAT) || defined(EFX_USE_ETHTOOL_FLAGS)
+static int efx_ethtool_set_flags(struct net_device *net_dev, u32 data)
+{
+	struct efx_nic *efx = netdev_priv(net_dev);
+	u32 supported = (efx->type->offload_features &
+			 (ETH_FLAG_RXHASH | ETH_FLAG_NTUPLE));
+	int rc;
+	
+#if defined(EFX_NOT_UPSTREAM) && defined(EFX_USE_SFC_LRO)
+	supported |= ETH_FLAG_LRO;
+#endif
+
+#ifndef EFX_USE_KCOMPAT
+	rc = ethtool_op_set_flags(net_dev, data, supported);
+#else
+	if (data & ~supported)
+		rc = -EINVAL;
+	else
+		net_dev->features = (net_dev->features & ~supported) | data;
+#endif
+	if (rc)
+		return rc;
+
+	if (!(data & ETH_FLAG_NTUPLE)) {
+		efx_filter_table_clear(efx, EFX_FILTER_TABLE_RX_IP,
+				       EFX_FILTER_PRI_MANUAL);
+		efx_filter_table_clear(efx, EFX_FILTER_TABLE_RX_MAC,
+				       EFX_FILTER_PRI_MANUAL);
+	}
+
+	return 0;
+}
+#endif
+
 static void efx_ethtool_self_test(struct net_device *net_dev,
 				  struct ethtool_test *test, u64 *data)
 {
 	struct efx_nic *efx = netdev_priv(net_dev);
 	struct efx_self_tests efx_tests;
-	int already_up;
+	bool already_up;
 	int rc;
 
 	ASSERT_RTNL();
 	if (efx->state != STATE_RUNNING) {
-		rc = -EIO;
-		goto fail1;
+		rc = -EBUSY;
+		goto out;
 	}
+
+	if (test->flags & ETH_TEST_FL_OFFLINE)
+		efx_dl_reset_suspend(efx);
 
 	/* We need rx buffers and interrupts. */
 	already_up = (efx->net_dev->flags & IFF_UP);
 	if (!already_up) {
 		rc = dev_open(efx->net_dev);
 		if (rc) {
-			EFX_ERR(efx, "failed opening device.\n");
-			goto fail2;
+			netif_err(efx, drv, efx->net_dev,
+				  "failed opening device.\n");
+			goto out_resume;
 		}
 	}
 
@@ -513,13 +715,17 @@ static void efx_ethtool_self_test(struct
 	if (!already_up)
 		dev_close(efx->net_dev);
 
-	EFX_LOG(efx, "%s %sline self-tests\n",
-		rc == 0 ? "passed" : "failed",
-		(test->flags & ETH_TEST_FL_OFFLINE) ? "off" : "on");
+	netif_dbg(efx, drv, efx->net_dev, "%s %sline self-tests\n",
+		  rc == 0 ? "passed" : "failed",
+		  (test->flags & ETH_TEST_FL_OFFLINE) ? "off" : "on");
 
- fail2:
- fail1:
-	/* Fill ethtool results structures */
+out_resume:
+	if (test->flags & ETH_TEST_FL_OFFLINE) {
+		/* Return success because if efx_reset_up() failed, an
+		 * EFX_RESET_DISABLE reset will have been scheduled */
+		efx_dl_reset_resume(efx, true);
+	}
+out:
 	efx_ethtool_fill_self_tests(efx, &efx_tests, NULL, data);
 	if (rc)
 		test->flags |= ETH_TEST_FL_FAILED;
@@ -537,7 +743,7 @@ static u32 efx_ethtool_get_link(struct n
 {
 	struct efx_nic *efx = netdev_priv(net_dev);
 
-	return efx->link_up;
+	return efx->link_state.up;
 }
 
 static int efx_ethtool_get_eeprom_len(struct net_device *net_dev)
@@ -562,7 +768,8 @@ static int efx_ethtool_get_eeprom(struct
 	rc = mutex_lock_interruptible(&efx->spi_lock);
 	if (rc)
 		return rc;
-	rc = falcon_spi_read(spi, eeprom->offset + EFX_EEPROM_BOOTCONFIG_START,
+	rc = falcon_spi_read(efx, spi,
+			     eeprom->offset + EFX_EEPROM_BOOTCONFIG_START,
 			     eeprom->len, &len, buf);
 	mutex_unlock(&efx->spi_lock);
 
@@ -585,7 +792,8 @@ static int efx_ethtool_set_eeprom(struct
 	rc = mutex_lock_interruptible(&efx->spi_lock);
 	if (rc)
 		return rc;
-	rc = falcon_spi_write(spi, eeprom->offset + EFX_EEPROM_BOOTCONFIG_START,
+	rc = falcon_spi_write(efx, spi,
+			      eeprom->offset + EFX_EEPROM_BOOTCONFIG_START,
 			      eeprom->len, &len, buf);
 	mutex_unlock(&efx->spi_lock);
 
@@ -597,17 +805,17 @@ static int efx_ethtool_get_coalesce(stru
 				    struct ethtool_coalesce *coalesce)
 {
 	struct efx_nic *efx = netdev_priv(net_dev);
-	struct efx_tx_queue *tx_queue;
 	struct efx_channel *channel;
 
 	memset(coalesce, 0, sizeof(*coalesce));
 
 	/* Find lowest IRQ moderation across all used TX queues */
 	coalesce->tx_coalesce_usecs_irq = ~((u32) 0);
-	efx_for_each_tx_queue(tx_queue, efx) {
-		channel = tx_queue->channel;
+	efx_for_each_channel(channel, efx) {
+		if (!efx_channel_get_tx_queue(channel, 0))
+			continue;
 		if (channel->irq_moderation < coalesce->tx_coalesce_usecs_irq) {
-			if (channel->used_flags != EFX_USED_BY_RX_TX)
+			if (channel->channel >= efx->n_rx_channels)
 				coalesce->tx_coalesce_usecs_irq =
 					channel->irq_moderation;
 			else
@@ -617,6 +825,9 @@ static int efx_ethtool_get_coalesce(stru
 
 	coalesce->use_adaptive_rx_coalesce = efx->irq_rx_adaptive;
 	coalesce->rx_coalesce_usecs_irq = efx->irq_rx_moderation;
+
+	coalesce->tx_coalesce_usecs_irq *= EFX_IRQ_MOD_RESOLUTION;
+	coalesce->rx_coalesce_usecs_irq *= EFX_IRQ_MOD_RESOLUTION;
 
 	return 0;
 }
@@ -629,15 +840,14 @@ static int efx_ethtool_set_coalesce(stru
 {
 	struct efx_nic *efx = netdev_priv(net_dev);
 	struct efx_channel *channel;
-	struct efx_tx_queue *tx_queue;
 	unsigned tx_usecs, rx_usecs, adaptive;
 
 	if (coalesce->use_adaptive_tx_coalesce)
 		return -EOPNOTSUPP;
 
 	if (coalesce->rx_coalesce_usecs || coalesce->tx_coalesce_usecs) {
-		EFX_ERR(efx, "invalid coalescing setting. "
-			"Only rx/tx_coalesce_usecs_irq are supported\n");
+		netif_err(efx, drv, efx->net_dev, "invalid coalescing setting. "
+			  "Only rx/tx_coalesce_usecs_irq are supported\n");
 		return -EOPNOTSUPP;
 	}
 
@@ -646,48 +856,87 @@ static int efx_ethtool_set_coalesce(stru
 	adaptive = coalesce->use_adaptive_rx_coalesce;
 
 	/* If the channel is shared only allow RX parameters to be set */
-	efx_for_each_tx_queue(tx_queue, efx) {
-		if ((tx_queue->channel->used_flags == EFX_USED_BY_RX_TX) &&
+	efx_for_each_channel(channel, efx) {
+		if (efx_channel_get_rx_queue(channel) &&
+		    efx_channel_get_tx_queue(channel, 0) &&
 		    tx_usecs) {
-			EFX_ERR(efx, "Channel is shared. "
-				"Only RX coalescing may be set\n");
+			netif_err(efx, drv, efx->net_dev, "Channel is shared. "
+				  "Only RX coalescing may be set\n");
 			return -EOPNOTSUPP;
 		}
 	}
 
 	efx_init_irq_moderation(efx, tx_usecs, rx_usecs, adaptive);
-
-	/* Reset channel to pick up new moderation value.  Note that
-	 * this may change the value of the irq_moderation field
-	 * (e.g. to allow for hardware timer granularity).
-	 */
 	efx_for_each_channel(channel, efx)
-		falcon_set_int_moderation(channel);
+		efx->type->push_irq_moderation(channel);
 
 	return 0;
+}
+
+static void efx_ethtool_get_ringparam(struct net_device *net_dev,
+				      struct ethtool_ringparam *ring)
+{
+	struct efx_nic *efx = netdev_priv(net_dev);
+
+	ring->rx_max_pending = EFX_MAX_DMAQ_SIZE;
+	ring->tx_max_pending = EFX_MAX_DMAQ_SIZE;
+	ring->rx_mini_max_pending = 0;
+	ring->rx_jumbo_max_pending = 0;
+	ring->rx_pending = efx->rxq_entries;
+	ring->tx_pending = efx->txq_entries;
+	ring->rx_mini_pending = 0;
+	ring->rx_jumbo_pending = 0;
+}
+
+static int efx_ethtool_set_ringparam(struct net_device *net_dev,
+				     struct ethtool_ringparam *ring)
+{
+	struct efx_nic *efx = netdev_priv(net_dev);
+
+	if (ring->rx_mini_pending || ring->rx_jumbo_pending ||
+	    ring->rx_pending > EFX_MAX_DMAQ_SIZE ||
+	    ring->tx_pending > EFX_MAX_DMAQ_SIZE)
+		return -EINVAL;
+
+	if (ring->rx_pending < EFX_MIN_RING_SIZE ||
+	    ring->tx_pending < EFX_MIN_RING_SIZE) {
+		netif_err(efx, drv, efx->net_dev,
+			  "TX and RX queues cannot be smaller than %ld\n",
+			  EFX_MIN_RING_SIZE);
+		return -EINVAL;
+	}
+
+	return efx_realloc_channels(efx, ring->rx_pending, ring->tx_pending);
 }
 
 static int efx_ethtool_set_pauseparam(struct net_device *net_dev,
 				      struct ethtool_pauseparam *pause)
 {
 	struct efx_nic *efx = netdev_priv(net_dev);
-	enum efx_fc_type wanted_fc;
+	enum efx_fc_type wanted_fc, old_fc;
+	u32 old_adv;
 	bool reset;
+	int rc = 0;
+
+	mutex_lock(&efx->mac_lock);
 
 	wanted_fc = ((pause->rx_pause ? EFX_FC_RX : 0) |
 		     (pause->tx_pause ? EFX_FC_TX : 0) |
 		     (pause->autoneg ? EFX_FC_AUTO : 0));
 
 	if ((wanted_fc & EFX_FC_TX) && !(wanted_fc & EFX_FC_RX)) {
-		EFX_LOG(efx, "Flow control unsupported: tx ON rx OFF\n");
-		return -EINVAL;
+		netif_dbg(efx, drv, efx->net_dev,
+			  "Flow control unsupported: tx ON rx OFF\n");
+		rc = -EINVAL;
+		goto out;
 	}
 
-	if (!(efx->phy_op->mmds & MDIO_DEVS_AN) &&
-	    (wanted_fc & EFX_FC_AUTO)) {
-		EFX_LOG(efx, "PHY does not support flow control "
-			"autonegotiation\n");
-		return -EINVAL;
+	if ((wanted_fc & EFX_FC_AUTO) &&
+	    !(efx->link_advertising & ADVERTISED_Autoneg)) {
+		netif_dbg(efx, drv, efx->net_dev,
+			  "Autonegotiation is disabled\n");
+		rc = -EINVAL;
+		goto out;
 	}
 
 	/* TX flow control may automatically turn itself off if the
@@ -697,27 +946,41 @@ static int efx_ethtool_set_pauseparam(st
 	 * and fix it be cycling transmit flow control on this end. */
 	reset = (wanted_fc & EFX_FC_TX) && !(efx->wanted_fc & EFX_FC_TX);
 	if (EFX_WORKAROUND_11482(efx) && reset) {
-		if (falcon_rev(efx) >= FALCON_REV_B0) {
+		if (efx_nic_rev(efx) == EFX_REV_FALCON_B0) {
 			/* Recover by resetting the EM block */
-			if (efx->link_up)
-				falcon_drain_tx_fifo(efx);
+			falcon_stop_nic_stats(efx);
+			falcon_drain_tx_fifo(efx);
+			efx->mac_op->reconfigure(efx);
+			falcon_start_nic_stats(efx);
 		} else {
 			/* Schedule a reset to recover */
 			efx_schedule_reset(efx, RESET_TYPE_INVISIBLE);
 		}
 	}
 
-	/* Try to push the pause parameters */
-	mutex_lock(&efx->mac_lock);
+	old_adv = efx->link_advertising;
+	old_fc = efx->wanted_fc;
+	efx_link_set_wanted_fc(efx, wanted_fc);
+	if (efx->link_advertising != old_adv ||
+	    (efx->wanted_fc ^ old_fc) & EFX_FC_AUTO) {
+		rc = efx->phy_op->reconfigure(efx);
+		if (rc) {
+			netif_err(efx, drv, efx->net_dev,
+				  "Unable to advertise requested flow "
+				  "control setting\n");
+			goto out;
+		}
+	}
 
-	efx->wanted_fc = wanted_fc;
-	if (efx->phy_op->mmds & MDIO_DEVS_AN)
-		mdio45_ethtool_spauseparam_an(&efx->mdio, pause);
-	__efx_reconfigure_port(efx);
+	/* Reconfigure the MAC. The PHY *may* generate a link state change event
+	 * if the user just changed the advertised capabilities, but there's no
+	 * harm doing this twice */
+	efx->mac_op->reconfigure(efx);
 
+out:
 	mutex_unlock(&efx->mac_lock);
 
-	return 0;
+	return rc;
 }
 
 static void efx_ethtool_get_pauseparam(struct net_device *net_dev,
@@ -731,10 +994,324 @@ static void efx_ethtool_get_pauseparam(s
 }
 
 
+#if defined(EFX_USE_KCOMPAT) && defined(EFX_USE_ETHTOOL_GET_PERM_ADDR)
+static int efx_ethtool_op_get_perm_addr(struct net_device *net_dev,
+					struct ethtool_perm_addr *addr,
+					u8 *data)
+{
+	struct efx_nic *efx = netdev_priv(net_dev);
+
+	memcpy(data, efx->mac_address, ETH_ALEN);
+
+	return 0;
+}
+#endif
+
+
+static void efx_ethtool_get_wol(struct net_device *net_dev,
+				struct ethtool_wolinfo *wol)
+{
+	struct efx_nic *efx = netdev_priv(net_dev);
+	return efx->type->get_wol(efx, wol);
+}
+
+
+static int efx_ethtool_set_wol(struct net_device *net_dev,
+			       struct ethtool_wolinfo *wol)
+{
+	struct efx_nic *efx = netdev_priv(net_dev);
+	return efx->type->set_wol(efx, wol->wolopts);
+}
+
+#ifdef EFX_NOT_UPSTREAM
+int efx_ethtool_reset(struct net_device *net_dev, u32 *flags)
+#else
+static int efx_ethtool_reset(struct net_device *net_dev, u32 *flags)
+#endif
+{
+	struct efx_nic *efx = netdev_priv(net_dev);
+	enum reset_type method;
+	enum {
+		ETH_RESET_EFX_INVISIBLE = (ETH_RESET_DMA | ETH_RESET_FILTER |
+					   ETH_RESET_OFFLOAD | ETH_RESET_MAC)
+	};
+
+	/* Check for minimal reset flags */
+	if ((*flags & ETH_RESET_EFX_INVISIBLE) != ETH_RESET_EFX_INVISIBLE)
+		return -EINVAL;
+	*flags ^= ETH_RESET_EFX_INVISIBLE;
+	method = RESET_TYPE_INVISIBLE;
+
+	if (*flags & ETH_RESET_PHY) {
+		*flags ^= ETH_RESET_PHY;
+		method = RESET_TYPE_ALL;
+	}
+
+	if ((*flags & efx->type->reset_world_flags) ==
+	    efx->type->reset_world_flags) {
+		*flags ^= efx->type->reset_world_flags;
+		method = RESET_TYPE_WORLD;
+	}
+
+	return efx_reset(efx, method);
+}
+
+#ifdef EFX_NOT_UPSTREAM
+int
+#else
+static int
+#endif
+efx_ethtool_get_rxnfc(struct net_device *net_dev,
+		      struct ethtool_rxnfc *info, void *rules __always_unused)
+{
+	struct efx_nic *efx = netdev_priv(net_dev);
+	
+	switch (info->cmd) {
+	case ETHTOOL_GRXRINGS:
+		info->data = efx->n_rx_channels;
+		return 0;
+
+	case ETHTOOL_GRXFH: {
+		unsigned min_revision = 0;
+
+		info->data = 0;
+		switch (info->flow_type) {
+		case TCP_V4_FLOW:
+			info->data |= RXH_L4_B_0_1 | RXH_L4_B_2_3;
+			/* fall through */
+		case UDP_V4_FLOW:
+		case SCTP_V4_FLOW:
+		case AH_ESP_V4_FLOW:
+		case IPV4_FLOW:
+			info->data |= RXH_IP_SRC | RXH_IP_DST;
+			min_revision = EFX_REV_FALCON_B0;
+			break;
+		case TCP_V6_FLOW:
+			info->data |= RXH_L4_B_0_1 | RXH_L4_B_2_3;
+			/* fall through */
+		case UDP_V6_FLOW:
+		case SCTP_V6_FLOW:
+		case AH_ESP_V6_FLOW:
+		case IPV6_FLOW:
+			info->data |= RXH_IP_SRC | RXH_IP_DST;
+			min_revision = EFX_REV_SIENA_A0;
+			break;
+		default:
+			break;
+		}
+		if (efx_nic_rev(efx) < min_revision)
+			info->data = 0;
+		return 0;
+	}
+
+	default:
+		return -EOPNOTSUPP;
+	}
+}
+
+#if defined(EFX_USE_KCOMPAT) && defined(EFX_HAVE_NTUPLE_SUPPORT)
+/*
+ * ethtool does not (or did not) set masks for flow parameters that are
+ * not specified, so if both value and mask are 0 then this must be
+ * treated as equivalent to a mask with all bits set.  Implement that
+ * here rather than in drivers.
+ */
+static void rx_ntuple_fix_masks(struct ethtool_rx_ntuple_flow_spec *fs)
+{
+	struct ethtool_tcpip4_spec *entry = &fs->h_u.tcp_ip4_spec;
+	struct ethtool_tcpip4_spec *mask = &fs->m_u.tcp_ip4_spec;
+
+	if (fs->flow_type != TCP_V4_FLOW &&
+	    fs->flow_type != UDP_V4_FLOW &&
+	    fs->flow_type != SCTP_V4_FLOW)
+		return;
+
+	if (!(entry->ip4src | mask->ip4src))
+		mask->ip4src = htonl(0xffffffff);
+	if (!(entry->ip4dst | mask->ip4dst))
+		mask->ip4dst = htonl(0xffffffff);
+	if (!(entry->psrc | mask->psrc))
+		mask->psrc = htons(0xffff);
+	if (!(entry->pdst | mask->pdst))
+		mask->pdst = htons(0xffff);
+	if (!(entry->tos | mask->tos))
+		mask->tos = 0xff;
+	if (!(fs->vlan_tag | fs->vlan_tag_mask))
+		fs->vlan_tag_mask = 0xffff;
+	if (!(fs->data | fs->data_mask))
+		fs->data_mask = 0xffffffffffffffffULL;
+}
+#endif
+
+#ifdef EFX_NOT_UPSTREAM
+int efx_ethtool_set_rx_ntuple(struct net_device *net_dev,
+			      struct ethtool_rx_ntuple *ntuple)
+#else
+static int efx_ethtool_set_rx_ntuple(struct net_device *net_dev,
+				     struct ethtool_rx_ntuple *ntuple)
+#endif
+{
+	struct efx_nic *efx = netdev_priv(net_dev);
+	struct ethtool_tcpip4_spec *ip_entry = &ntuple->fs.h_u.tcp_ip4_spec;
+	struct ethtool_tcpip4_spec *ip_mask = &ntuple->fs.m_u.tcp_ip4_spec;
+#ifdef EFX_USE_KCOMPAT
+	struct ethhdr *mac_entry = (struct ethhdr *)ntuple->fs.h_u.hdata;
+	struct ethhdr *mac_mask = (struct ethhdr *)ntuple->fs.m_u.hdata;
+#else
+	struct ethhdr *mac_entry = &ntuple->fs.h_u.ether_spec;
+	struct ethhdr *mac_mask = &ntuple->fs.m_u.ether_spec;
+#endif
+	struct efx_filter_spec filter;
+
+#if defined(EFX_USE_KCOMPAT) && defined(EFX_HAVE_NTUPLE_SUPPORT)
+	rx_ntuple_fix_masks(&ntuple->fs);
+#endif
+
+	/* Range-check action */
+	if (ntuple->fs.action < ETHTOOL_RXNTUPLE_ACTION_CLEAR ||
+	    ntuple->fs.action >= (s32)efx->n_rx_channels)
+		return -EINVAL;
+
+	if (~ntuple->fs.data_mask)
+		return -EINVAL;
+
+	switch (ntuple->fs.flow_type) {
+	case TCP_V4_FLOW:
+	case UDP_V4_FLOW:
+		/* Must match all of destination, */
+		if (ip_mask->ip4dst | ip_mask->pdst)
+			return -EINVAL;
+		/* all or none of source, */
+		if ((ip_mask->ip4src | ip_mask->psrc) &&
+		    ((__force u32)~ip_mask->ip4src |
+		     (__force u16)~ip_mask->psrc))
+			return -EINVAL;
+		/* and nothing else */
+		if ((u8)~ip_mask->tos | (u16)~ntuple->fs.vlan_tag_mask)
+			return -EINVAL;
+		break;
+	case ETHER_FLOW:
+		/* Must match all of destination, */
+		if (!is_zero_ether_addr(mac_mask->h_dest))
+			return -EINVAL;
+		/* all or none of VID, */
+		if (ntuple->fs.vlan_tag_mask != 0xf000 &&
+		    ntuple->fs.vlan_tag_mask != 0xffff)
+			return -EINVAL;
+		/* and nothing else */
+		if (!is_broadcast_ether_addr(mac_mask->h_source) ||
+		    mac_mask->h_proto != htons(0xffff))
+			return -EINVAL;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	filter.priority = EFX_FILTER_PRI_MANUAL;
+	filter.flags = 0;
+
+	switch (ntuple->fs.flow_type) {
+	case TCP_V4_FLOW:
+		if (!ip_mask->ip4src)
+			efx_filter_set_rx_tcp_full(&filter,
+						   htonl(ip_entry->ip4src),
+						   htons(ip_entry->psrc),
+						   htonl(ip_entry->ip4dst),
+						   htons(ip_entry->pdst));
+		else
+			efx_filter_set_rx_tcp_wild(&filter,
+						   htonl(ip_entry->ip4dst),
+						   htons(ip_entry->pdst));
+		break;
+	case UDP_V4_FLOW:
+		if (!ip_mask->ip4src)
+			efx_filter_set_rx_udp_full(&filter,
+						   htonl(ip_entry->ip4src),
+						   htons(ip_entry->psrc),
+						   htonl(ip_entry->ip4dst),
+						   htons(ip_entry->pdst));
+		else
+			efx_filter_set_rx_udp_wild(&filter,
+						   htonl(ip_entry->ip4dst),
+						   htons(ip_entry->pdst));
+		break;
+	case ETHER_FLOW:
+		if (ntuple->fs.vlan_tag_mask == 0xf000)
+			efx_filter_set_rx_mac_full(&filter,
+						   ntuple->fs.vlan_tag & 0xfff,
+						   mac_entry->h_dest);
+		else
+			efx_filter_set_rx_mac_wild(&filter, mac_entry->h_dest);
+		break;
+	}
+
+	if (ntuple->fs.action == ETHTOOL_RXNTUPLE_ACTION_CLEAR) {
+		return efx_filter_remove_filter(efx, &filter);
+	} else {
+		if (ntuple->fs.action == ETHTOOL_RXNTUPLE_ACTION_DROP)
+			filter.dmaq_id = 0xfff;
+		else
+			filter.dmaq_id = ntuple->fs.action;
+		return efx_filter_insert_filter(efx, &filter, true);
+	}
+}
+
+#ifdef EFX_NOT_UPSTREAM
+int efx_ethtool_get_rxfh_indir(struct net_device *net_dev,
+			       struct ethtool_rxfh_indir *indir)
+#else
+static int efx_ethtool_get_rxfh_indir(struct net_device *net_dev,
+				      struct ethtool_rxfh_indir *indir)
+#endif
+{
+	struct efx_nic *efx = netdev_priv(net_dev);
+	size_t copy_size =
+		min_t(size_t, indir->size, ARRAY_SIZE(efx->rx_indir_table));
+
+	if (efx_nic_rev(efx) < EFX_REV_FALCON_B0)
+		return -EOPNOTSUPP;
+
+	indir->size = ARRAY_SIZE(efx->rx_indir_table);
+	memcpy(indir->ring_index, efx->rx_indir_table,
+	       copy_size * sizeof(indir->ring_index[0]));
+	return 0;
+}
+
+#ifdef EFX_NOT_UPSTREAM
+int efx_ethtool_set_rxfh_indir(struct net_device *net_dev,
+			       const struct ethtool_rxfh_indir *indir)
+#else
+static int efx_ethtool_set_rxfh_indir(struct net_device *net_dev,
+				      const struct ethtool_rxfh_indir *indir)
+#endif
+{
+	struct efx_nic *efx = netdev_priv(net_dev);
+	size_t i;
+
+	if (efx_nic_rev(efx) < EFX_REV_FALCON_B0)
+		return -EOPNOTSUPP;
+
+	/* Validate size and indices */
+	if (indir->size != ARRAY_SIZE(efx->rx_indir_table))
+		return -EINVAL;
+	for (i = 0; i < ARRAY_SIZE(efx->rx_indir_table); i++)
+		if (indir->ring_index[i] >= efx->n_rx_channels)
+			return -EINVAL;
+
+	memcpy(efx->rx_indir_table, indir->ring_index,
+	       sizeof(efx->rx_indir_table));
+	efx_nic_push_rx_indir_table(efx);
+	return 0;
+}
+
 const struct ethtool_ops efx_ethtool_ops = {
 	.get_settings		= efx_ethtool_get_settings,
 	.set_settings		= efx_ethtool_set_settings,
 	.get_drvinfo		= efx_ethtool_get_drvinfo,
+	.get_regs_len		= efx_ethtool_get_regs_len,
+	.get_regs		= efx_ethtool_get_regs,
+	.get_msglevel		= efx_ethtool_get_msglevel,
+	.set_msglevel		= efx_ethtool_set_msglevel,
 	.nway_reset		= efx_ethtool_nway_reset,
 	.get_link		= efx_ethtool_get_link,
 	.get_eeprom_len		= efx_ethtool_get_eeprom_len,
@@ -742,21 +1319,58 @@ const struct ethtool_ops efx_ethtool_ops
 	.set_eeprom		= efx_ethtool_set_eeprom,
 	.get_coalesce		= efx_ethtool_get_coalesce,
 	.set_coalesce		= efx_ethtool_set_coalesce,
+	.get_ringparam		= efx_ethtool_get_ringparam,
+	.set_ringparam		= efx_ethtool_set_ringparam,
 	.get_pauseparam         = efx_ethtool_get_pauseparam,
 	.set_pauseparam         = efx_ethtool_set_pauseparam,
 	.get_rx_csum		= efx_ethtool_get_rx_csum,
 	.set_rx_csum		= efx_ethtool_set_rx_csum,
+#if !defined(EFX_USE_KCOMPAT) || defined(EFX_USE_ETHTOOL_OP_GET_TX_CSUM)
 	.get_tx_csum		= ethtool_op_get_tx_csum,
-	.set_tx_csum		= ethtool_op_set_tx_csum,
+#else
+	.get_tx_csum		= efx_ethtool_get_tx_csum,
+#endif
+	/* Need to enable/disable IPv6 too */
+	.set_tx_csum		= efx_ethtool_set_tx_csum,
 	.get_sg			= ethtool_op_get_sg,
+#if !defined(EFX_USE_KCOMPAT) || !defined(EFX_NEED_ETHTOOL_OFFLOAD_SANITY_CHECKS)
 	.set_sg			= ethtool_op_set_sg,
+#else
+	.set_sg			= efx_ethtool_set_sg,
+#endif
 	.get_tso		= ethtool_op_get_tso,
-	.set_tso		= ethtool_op_set_tso,
+	/* Need to enable/disable TSO-IPv6 too */
+	.set_tso		= efx_ethtool_set_tso,
+#if !defined(EFX_USE_KCOMPAT) || defined(EFX_USE_ETHTOOL_FLAGS)
 	.get_flags		= ethtool_op_get_flags,
-	.set_flags		= ethtool_op_set_flags,
+	.set_flags		= efx_ethtool_set_flags,
+#endif
+#if !defined(EFX_USE_KCOMPAT) || defined(EFX_USE_ETHTOOL_GET_SSET_COUNT)
 	.get_sset_count		= efx_ethtool_get_sset_count,
+#else
+	.self_test_count	= efx_ethtool_self_test_count,
+	.get_stats_count	= efx_ethtool_get_stats_count,
+#endif
 	.self_test		= efx_ethtool_self_test,
 	.get_strings		= efx_ethtool_get_strings,
 	.phys_id		= efx_ethtool_phys_id,
 	.get_ethtool_stats	= efx_ethtool_get_stats,
+#if defined(EFX_USE_KCOMPAT) && defined(EFX_USE_ETHTOOL_GET_PERM_ADDR)
+	.get_perm_addr          = efx_ethtool_op_get_perm_addr,
+#endif
+	.get_wol                = efx_ethtool_get_wol,
+	.set_wol                = efx_ethtool_set_wol,
+#if !defined(EFX_USE_KCOMPAT) || defined(EFX_HAVE_ETHTOOL_RESET)
+	.reset			= efx_ethtool_reset,
+#endif
+#if !defined(EFX_USE_KCOMPAT) || defined(EFX_HAVE_ETHTOOL_RXNFC)
+	.get_rxnfc		= efx_ethtool_get_rxnfc,
+#endif
+#if !defined(EFX_USE_KCOMPAT) || defined(EFX_HAVE_NTUPLE_SUPPORT)
+	.set_rx_ntuple		= efx_ethtool_set_rx_ntuple,
+#endif
+#if !defined(EFX_USE_KCOMPAT) || defined(EFX_HAVE_ETHTOOL_RXFH_INDIR)
+	.get_rxfh_indir		= efx_ethtool_get_rxfh_indir,
+	.set_rxfh_indir		= efx_ethtool_set_rxfh_indir,
+#endif
 };
diff -r 5b3d4d3c1166 drivers/net/sfc/ethtool.h
--- a/drivers/net/sfc/ethtool.h	Fri Nov 05 15:20:28 2010 +0000
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,27 +0,0 @@
-/****************************************************************************
- * Driver for Solarflare Solarstorm network controllers and boards
- * Copyright 2005 Fen Systems Ltd.
- * Copyright 2006 Solarflare Communications Inc.
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 as published
- * by the Free Software Foundation, incorporated herein by reference.
- */
-
-#ifndef EFX_ETHTOOL_H
-#define EFX_ETHTOOL_H
-
-#include "net_driver.h"
-
-/*
- * Ethtool support
- */
-
-extern int efx_ethtool_get_settings(struct net_device *net_dev,
-				    struct ethtool_cmd *ecmd);
-extern int efx_ethtool_set_settings(struct net_device *net_dev,
-				    struct ethtool_cmd *ecmd);
-
-extern const struct ethtool_ops efx_ethtool_ops;
-
-#endif /* EFX_ETHTOOL_H */
diff -r 5b3d4d3c1166 drivers/net/sfc/falcon.c
--- a/drivers/net/sfc/falcon.c	Fri Nov 05 15:20:28 2010 +0000
+++ b/drivers/net/sfc/falcon.c	Tue Nov 09 10:06:27 2010 +0000
@@ -1,7 +1,7 @@
 /****************************************************************************
  * Driver for Solarflare Solarstorm network controllers and boards
  * Copyright 2005-2006 Fen Systems Ltd.
- * Copyright 2006-2008 Solarflare Communications Inc.
+ * Copyright 2006-2009 Solarflare Communications Inc.
  *
  * This program is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 as published
@@ -14,79 +14,36 @@
 #include <linux/module.h>
 #include <linux/seq_file.h>
 #include <linux/i2c.h>
-#include <linux/i2c-algo-bit.h>
 #include <linux/mii.h>
+#include <linux/slab.h>
 #include "net_driver.h"
 #include "bitfield.h"
 #include "efx.h"
 #include "mac.h"
 #include "spi.h"
-#include "falcon.h"
-#include "falcon_hwdefs.h"
-#include "falcon_io.h"
+#include "nic.h"
+#include "regs.h"
+#include "io.h"
 #include "mdio_10g.h"
 #include "phy.h"
-#include "boards.h"
+#include "driverlink.h"
 #include "workarounds.h"
 
-/* Falcon hardware control.
- * Falcon is the internal codename for the SFC4000 controller that is
- * present in SFE400X evaluation boards
+/* Hardware control for SFC4000 (aka Falcon). */
+
+/*
+ * Override EEPROM/flash type from non-volatile configuration or GPIO;
+ * may need to be specified if bootstrapping from blank flash.
  */
-
-/**
- * struct falcon_nic_data - Falcon NIC state
- * @sram_cfg: SRAM configuration value
- * @tx_dc_base: Base address in SRAM of TX queue descriptor caches
- * @rx_dc_base: Base address in SRAM of RX queue descriptor caches
- * @next_buffer_table: First available buffer table id
- * @resources: Resource information for driverlink client
- * @pci_dev2: The secondary PCI device if present
- * @i2c_data: Operations and state for I2C bit-bashing algorithm
- * @int_error_count: Number of internal errors seen recently
- * @int_error_expire: Time at which error count will be expired
- */
-struct falcon_nic_data {
-	int sram_cfg;
-	unsigned tx_dc_base;
-	unsigned rx_dc_base;
-#ifndef CONFIG_SFC_DRIVERLINK
-	unsigned next_buffer_table;
-#else
-	struct efx_dl_falcon_resources resources;
-#endif
-	struct pci_dev *pci_dev2;
-	struct i2c_algo_bit_data i2c_data;
-
-	unsigned int_error_count;
-	unsigned long int_error_expire;
-};
-
-/**************************************************************************
- *
- * Configurable values
- *
- **************************************************************************
- */
-
-static int disable_dma_stats;
-
-/* This is set to 16 for a good reason.  In summary, if larger than
- * 16, the descriptor cache holds more than a default socket
- * buffer's worth of packets (for UDP we can only have at most one
- * socket buffer's worth outstanding).  This combined with the fact
- * that we only get 1 TX event per descriptor cache means the NIC
- * goes idle.
- */
-#define TX_DC_ENTRIES 16
-#define TX_DC_ENTRIES_ORDER 0
-#define TX_DC_INTERNAL_BASE 0x130000
-
-#define RX_DC_ENTRIES 64
-#define RX_DC_ENTRIES_ORDER 2
-#define RX_DC_INTERNAL_BASE 0x100000
+static unsigned int eeprom_type = -1;
+static unsigned int flash_type = -1;
 
 static const unsigned int
+/* "Small" EEPROM device: Atmel AT25040 or similar
+ * 512 B, 9-bit address, 8 B write block */
+small_eeprom_type = ((9 << SPI_DEV_TYPE_SIZE_LBN)
+		     | (1 << SPI_DEV_TYPE_ADDR_LEN_LBN)
+		     | (3 << SPI_DEV_TYPE_BLOCK_SIZE_LBN)),
 /* "Large" EEPROM device: Atmel AT25640 or similar
  * 8 KB, 16-bit address, 32 B write block */
 large_eeprom_type = ((13 << SPI_DEV_TYPE_SIZE_LBN)
@@ -100,103 +57,63 @@ default_flash_type = ((17 << SPI_DEV_TYP
 		      | (15 << SPI_DEV_TYPE_ERASE_SIZE_LBN)
 		      | (8 << SPI_DEV_TYPE_BLOCK_SIZE_LBN));
 
-/* RX FIFO XOFF watermark
- *
- * When the amount of the RX FIFO increases used increases past this
- * watermark send XOFF. Only used if RX flow control is enabled (ethtool -A)
- * This also has an effect on RX/TX arbitration
- */
-static int rx_xoff_thresh_bytes = -1;
-module_param(rx_xoff_thresh_bytes, int, 0644);
-MODULE_PARM_DESC(rx_xoff_thresh_bytes, "RX fifo XOFF threshold");
+#ifdef EFX_NOT_UPSTREAM
 
-/* RX FIFO XON watermark
- *
- * When the amount of the RX FIFO used decreases below this
- * watermark send XON. Only used if TX flow control is enabled (ethtool -A)
- * This also has an effect on RX/TX arbitration
- */
-static int rx_xon_thresh_bytes = -1;
-module_param(rx_xon_thresh_bytes, int, 0644);
-MODULE_PARM_DESC(rx_xon_thresh_bytes, "RX fifo XON threshold");
+module_param(eeprom_type, uint, 0444);
+MODULE_PARM_DESC(eeprom_type, "Force the type of EEPROM present");
 
-/* TX descriptor ring size - min 512 max 4k */
-#define FALCON_TXD_RING_ORDER TX_DESCQ_SIZE_1K
-#define FALCON_TXD_RING_SIZE 1024
-#define FALCON_TXD_RING_MASK (FALCON_TXD_RING_SIZE - 1)
+module_param(flash_type, uint, 0444);
+MODULE_PARM_DESC(flash_type, "Force the type of flash present");
 
-/* RX descriptor ring size - min 512 max 4k */
-#define FALCON_RXD_RING_ORDER RX_DESCQ_SIZE_1K
-#define FALCON_RXD_RING_SIZE 1024
-#define FALCON_RXD_RING_MASK (FALCON_RXD_RING_SIZE - 1)
+/* Force Falcon to use internal SRAM */
+static int falcon_force_internal_sram;
+module_param(falcon_force_internal_sram, int, 0644);
+MODULE_PARM_DESC(falcon_force_internal_sram, "Force internal SRAM to be used");
 
-/* Event queue size - max 32k */
-#define FALCON_EVQ_ORDER EVQ_SIZE_4K
-#define FALCON_EVQ_SIZE 4096
-#define FALCON_EVQ_MASK (FALCON_EVQ_SIZE - 1)
+#endif /* EFX_NOT_UPSTREAM */
 
-/* If FALCON_MAX_INT_ERRORS internal errors occur within
- * FALCON_INT_ERROR_EXPIRE seconds, we consider the NIC broken and
- * disable it.
- */
-#define FALCON_INT_ERROR_EXPIRE 3600
-#define FALCON_MAX_INT_ERRORS 5
+/* Dummy SRAM configuration code */
+#define SRAM_CONFIG_INTERNAL (-1)
 
-/* We poll for events every FLUSH_INTERVAL ms, and check FLUSH_POLL_COUNT times
- */
-#define FALCON_FLUSH_INTERVAL 10
-#define FALCON_FLUSH_POLL_COUNT 100
+/* Read dword from a Falcon PCIE core register */
+static void falcon_b0_pcie_core_read_reg(struct efx_nic *efx, int address,
+				      efx_dword_t *result)
+{
+	efx_oword_t temp;
 
-/**************************************************************************
- *
- * Falcon constants
- *
- **************************************************************************
- */
+	BUG_ON(efx_nic_rev(efx) != EFX_REV_FALCON_B0);
+	BUG_ON(address & 3 || address < 0);
 
-/* DMA address mask */
-#define FALCON_DMA_MASK DMA_BIT_MASK(46)
+	EFX_POPULATE_OWORD_1(temp, FRF_BB_PCIE_CORE_TARGET_REG_ADRS, address);
 
-/* TX DMA length mask (13-bit) */
-#define FALCON_TX_DMA_MASK (4096 - 1)
-
-/* Size and alignment of special buffers (4KB) */
-#define FALCON_BUF_SIZE 4096
-
-/* Dummy SRAM size code */
-#define SRM_NB_BSZ_ONCHIP_ONLY (-1)
-
-#define FALCON_IS_DUAL_FUNC(efx)		\
-	(falcon_rev(efx) < FALCON_REV_B0)
-
-/**************************************************************************
- *
- * Falcon hardware access
- *
- **************************************************************************/
-
-/* Read the current event from the event queue */
-static inline efx_qword_t *falcon_event(struct efx_channel *channel,
-					unsigned int index)
-{
-	return (((efx_qword_t *) (channel->eventq.addr)) + index);
+	efx_writeo(efx, &temp, FR_BB_PCIE_CORE_INDIRECT);
+	efx_reado(efx, &temp, FR_BB_PCIE_CORE_INDIRECT);
+	/* Extract PCIE_CORE_VALUE without byte-swapping */
+	BUILD_BUG_ON(FRF_BB_PCIE_CORE_TARGET_DATA_LBN != 32 ||
+		     FRF_BB_PCIE_CORE_TARGET_DATA_WIDTH != 32);
+	result->u32[0] = temp.u32[1];
 }
 
-/* See if an event is present
- *
- * We check both the high and low dword of the event for all ones.  We
- * wrote all ones when we cleared the event, and no valid event can
- * have all ones in either its high or low dwords.  This approach is
- * robust against reordering.
- *
- * Note that using a single 64-bit comparison is incorrect; even
- * though the CPU read will be atomic, the DMA write may not be.
- */
-static inline int falcon_event_present(efx_qword_t *event)
+/* Write dword to a Falcon PCIE core register */
+static void falcon_b0_pcie_core_write_reg(struct efx_nic *efx, int address,
+				       efx_dword_t value)
 {
-	return (!(EFX_DWORD_IS_ALL_ONES(event->dword[0]) |
-		  EFX_DWORD_IS_ALL_ONES(event->dword[1])));
+	efx_oword_t temp;
+
+	BUG_ON(efx_nic_rev(efx) != EFX_REV_FALCON_B0);
+	BUG_ON(address & 0x3 || address < 0);
+
+	EFX_POPULATE_OWORD_2(temp,
+			     FRF_BB_PCIE_CORE_TARGET_REG_ADRS, address,
+			     FRF_BB_PCIE_CORE_INDIRECT_ACCESS_DIR, 1);
+	/* Fill PCIE_CORE_VALUE without byte-swapping */
+	BUILD_BUG_ON(FRF_BB_PCIE_CORE_TARGET_DATA_LBN != 32 ||
+		     FRF_BB_PCIE_CORE_TARGET_DATA_WIDTH != 32);
+	temp.u32[1] = value.u32[0];
+	efx_writeo(efx, &temp, FR_BB_PCIE_CORE_INDIRECT);
 }
+
+#ifdef CONFIG_SFC_I2C
 
 /**************************************************************************
  *
@@ -211,9 +128,9 @@ static void falcon_setsda(void *data, in
 	struct efx_nic *efx = (struct efx_nic *)data;
 	efx_oword_t reg;
 
-	falcon_read(efx, &reg, GPIO_CTL_REG_KER);
-	EFX_SET_OWORD_FIELD(reg, GPIO3_OEN, !state);
-	falcon_write(efx, &reg, GPIO_CTL_REG_KER);
+	efx_reado(efx, &reg, FR_AB_GPIO_CTL);
+	EFX_SET_OWORD_FIELD(reg, FRF_AB_GPIO3_OEN, !state);
+	efx_writeo(efx, &reg, FR_AB_GPIO_CTL);
 }
 
 static void falcon_setscl(void *data, int state)
@@ -221,9 +138,9 @@ static void falcon_setscl(void *data, in
 	struct efx_nic *efx = (struct efx_nic *)data;
 	efx_oword_t reg;
 
-	falcon_read(efx, &reg, GPIO_CTL_REG_KER);
-	EFX_SET_OWORD_FIELD(reg, GPIO0_OEN, !state);
-	falcon_write(efx, &reg, GPIO_CTL_REG_KER);
+	efx_reado(efx, &reg, FR_AB_GPIO_CTL);
+	EFX_SET_OWORD_FIELD(reg, FRF_AB_GPIO0_OEN, !state);
+	efx_writeo(efx, &reg, FR_AB_GPIO_CTL);
 }
 
 static int falcon_getsda(void *data)
@@ -231,8 +148,8 @@ static int falcon_getsda(void *data)
 	struct efx_nic *efx = (struct efx_nic *)data;
 	efx_oword_t reg;
 
-	falcon_read(efx, &reg, GPIO_CTL_REG_KER);
-	return EFX_OWORD_FIELD(reg, GPIO3_IN);
+	efx_reado(efx, &reg, FR_AB_GPIO_CTL);
+	return EFX_OWORD_FIELD(reg, FRF_AB_GPIO3_IN);
 }
 
 static int falcon_getscl(void *data)
@@ -240,8 +157,8 @@ static int falcon_getscl(void *data)
 	struct efx_nic *efx = (struct efx_nic *)data;
 	efx_oword_t reg;
 
-	falcon_read(efx, &reg, GPIO_CTL_REG_KER);
-	return EFX_OWORD_FIELD(reg, GPIO0_IN);
+	efx_reado(efx, &reg, FR_AB_GPIO_CTL);
+	return EFX_OWORD_FIELD(reg, FRF_AB_GPIO0_IN);
 }
 
 static struct i2c_algo_bit_data falcon_i2c_bit_operations = {
@@ -254,1151 +171,41 @@ static struct i2c_algo_bit_data falcon_i
 	.timeout	= DIV_ROUND_UP(HZ, 20),
 };
 
-/**************************************************************************
- *
- * Falcon special buffer handling
- * Special buffers are used for event queues and the TX and RX
- * descriptor rings.
- *
- *************************************************************************/
+#endif /* CONFIG_SFC_I2C */
 
-/*
- * Initialise a Falcon special buffer
- *
- * This will define a buffer (previously allocated via
- * falcon_alloc_special_buffer()) in Falcon's buffer table, allowing
- * it to be used for event queues, descriptor rings etc.
- */
-static void
-falcon_init_special_buffer(struct efx_nic *efx,
-			   struct efx_special_buffer *buffer)
-{
-	efx_qword_t buf_desc;
-	int index;
-	dma_addr_t dma_addr;
-	int i;
-
-	EFX_BUG_ON_PARANOID(!buffer->addr);
-
-	/* Write buffer descriptors to NIC */
-	for (i = 0; i < buffer->entries; i++) {
-		index = buffer->index + i;
-		dma_addr = buffer->dma_addr + (i * 4096);
-		EFX_LOG(efx, "mapping special buffer %d at %llx\n",
-			index, (unsigned long long)dma_addr);
-		EFX_POPULATE_QWORD_4(buf_desc,
-				     IP_DAT_BUF_SIZE, IP_DAT_BUF_SIZE_4K,
-				     BUF_ADR_REGION, 0,
-				     BUF_ADR_FBUF, (dma_addr >> 12),
-				     BUF_OWNER_ID_FBUF, 0);
-		falcon_write_sram(efx, &buf_desc, index);
-	}
-}
-
-/* Unmaps a buffer from Falcon and clears the buffer table entries */
-static void
-falcon_fini_special_buffer(struct efx_nic *efx,
-			   struct efx_special_buffer *buffer)
-{
-	efx_oword_t buf_tbl_upd;
-	unsigned int start = buffer->index;
-	unsigned int end = (buffer->index + buffer->entries - 1);
-
-	if (!buffer->entries)
-		return;
-
-	EFX_LOG(efx, "unmapping special buffers %d-%d\n",
-		buffer->index, buffer->index + buffer->entries - 1);
-
-	EFX_POPULATE_OWORD_4(buf_tbl_upd,
-			     BUF_UPD_CMD, 0,
-			     BUF_CLR_CMD, 1,
-			     BUF_CLR_END_ID, end,
-			     BUF_CLR_START_ID, start);
-	falcon_write(efx, &buf_tbl_upd, BUF_TBL_UPD_REG_KER);
-}
-
-/*
- * Allocate a new Falcon special buffer
- *
- * This allocates memory for a new buffer, clears it and allocates a
- * new buffer ID range.  It does not write into Falcon's buffer table.
- *
- * This call will allocate 4KB buffers, since Falcon can't use 8KB
- * buffers for event queues and descriptor rings.
- */
-static int falcon_alloc_special_buffer(struct efx_nic *efx,
-				       struct efx_special_buffer *buffer,
-				       unsigned int len)
-{
-	struct falcon_nic_data *nic_data = efx->nic_data;
-
-	len = ALIGN(len, FALCON_BUF_SIZE);
-
-	buffer->addr = pci_alloc_consistent(efx->pci_dev, len,
-					    &buffer->dma_addr);
-	if (!buffer->addr)
-		return -ENOMEM;
-	buffer->len = len;
-	buffer->entries = len / FALCON_BUF_SIZE;
-	BUG_ON(buffer->dma_addr & (FALCON_BUF_SIZE - 1));
-
-	/* All zeros is a potentially valid event so memset to 0xff */
-	memset(buffer->addr, 0xff, len);
-
-	/* Select new buffer ID */
-#ifndef CONFIG_SFC_DRIVERLINK
-	buffer->index = nic_data->next_buffer_table;
-	nic_data->next_buffer_table += buffer->entries;
-#else
-	buffer->index = nic_data->resources.buffer_table_min;
-	nic_data->resources.buffer_table_min += buffer->entries;
-#endif
-
-	EFX_LOG(efx, "allocating special buffers %d-%d at %llx+%x "
-		"(virt %p phys %llx)\n", buffer->index,
-		buffer->index + buffer->entries - 1,
-		(u64)buffer->dma_addr, len,
-		buffer->addr, (u64)virt_to_phys(buffer->addr));
-
-	return 0;
-}
-
-static void falcon_free_special_buffer(struct efx_nic *efx,
-				       struct efx_special_buffer *buffer)
-{
-	if (!buffer->addr)
-		return;
-
-	EFX_LOG(efx, "deallocating special buffers %d-%d at %llx+%x "
-		"(virt %p phys %llx)\n", buffer->index,
-		buffer->index + buffer->entries - 1,
-		(u64)buffer->dma_addr, buffer->len,
-		buffer->addr, (u64)virt_to_phys(buffer->addr));
-
-	pci_free_consistent(efx->pci_dev, buffer->len, buffer->addr,
-			    buffer->dma_addr);
-	buffer->addr = NULL;
-	buffer->entries = 0;
-}
-
-/**************************************************************************
- *
- * Falcon generic buffer handling
- * These buffers are used for interrupt status and MAC stats
- *
- **************************************************************************/
-
-static int falcon_alloc_buffer(struct efx_nic *efx,
-			       struct efx_buffer *buffer, unsigned int len)
-{
-	buffer->addr = pci_alloc_consistent(efx->pci_dev, len,
-					    &buffer->dma_addr);
-	if (!buffer->addr)
-		return -ENOMEM;
-	buffer->len = len;
-	memset(buffer->addr, 0, len);
-	return 0;
-}
-
-static void falcon_free_buffer(struct efx_nic *efx, struct efx_buffer *buffer)
-{
-	if (buffer->addr) {
-		pci_free_consistent(efx->pci_dev, buffer->len,
-				    buffer->addr, buffer->dma_addr);
-		buffer->addr = NULL;
-	}
-}
-
-/**************************************************************************
- *
- * Falcon TX path
- *
- **************************************************************************/
-
-/* Returns a pointer to the specified transmit descriptor in the TX
- * descriptor queue belonging to the specified channel.
- */
-static inline efx_qword_t *falcon_tx_desc(struct efx_tx_queue *tx_queue,
-					       unsigned int index)
-{
-	return (((efx_qword_t *) (tx_queue->txd.addr)) + index);
-}
-
-/* This writes to the TX_DESC_WPTR; write pointer for TX descriptor ring */
-static inline void falcon_notify_tx_desc(struct efx_tx_queue *tx_queue)
-{
-	unsigned write_ptr;
-	efx_dword_t reg;
-
-	write_ptr = tx_queue->write_count & FALCON_TXD_RING_MASK;
-	EFX_POPULATE_DWORD_1(reg, TX_DESC_WPTR_DWORD, write_ptr);
-	falcon_writel_page(tx_queue->efx, &reg,
-			   TX_DESC_UPD_REG_KER_DWORD, tx_queue->queue);
-}
-
-
-/* For each entry inserted into the software descriptor ring, create a
- * descriptor in the hardware TX descriptor ring (in host memory), and
- * write a doorbell.
- */
-void falcon_push_buffers(struct efx_tx_queue *tx_queue)
-{
-
-	struct efx_tx_buffer *buffer;
-	efx_qword_t *txd;
-	unsigned write_ptr;
-
-	BUG_ON(tx_queue->write_count == tx_queue->insert_count);
-
-	do {
-		write_ptr = tx_queue->write_count & FALCON_TXD_RING_MASK;
-		buffer = &tx_queue->buffer[write_ptr];
-		txd = falcon_tx_desc(tx_queue, write_ptr);
-		++tx_queue->write_count;
-
-		/* Create TX descriptor ring entry */
-		EFX_POPULATE_QWORD_5(*txd,
-				     TX_KER_PORT, 0,
-				     TX_KER_CONT, buffer->continuation,
-				     TX_KER_BYTE_CNT, buffer->len,
-				     TX_KER_BUF_REGION, 0,
-				     TX_KER_BUF_ADR, buffer->dma_addr);
-	} while (tx_queue->write_count != tx_queue->insert_count);
-
-	wmb(); /* Ensure descriptors are written before they are fetched */
-	falcon_notify_tx_desc(tx_queue);
-}
-
-/* Allocate hardware resources for a TX queue */
-int falcon_probe_tx(struct efx_tx_queue *tx_queue)
-{
-	struct efx_nic *efx = tx_queue->efx;
-	int rc = falcon_alloc_special_buffer(efx, &tx_queue->txd,
-					    FALCON_TXD_RING_SIZE *
-					    sizeof(efx_qword_t));
-#ifdef CONFIG_SFC_DRIVERLINK
-	if (rc == 0) {
-		struct falcon_nic_data *nic_data = efx->nic_data;
-		nic_data->resources.txq_min = max(nic_data->resources.txq_min,
-						  (unsigned)tx_queue->queue + 1);
-	}
-#endif
-	return rc;
-}
-
-void falcon_init_tx(struct efx_tx_queue *tx_queue)
-{
-	efx_oword_t tx_desc_ptr;
-	struct efx_nic *efx = tx_queue->efx;
-
-	tx_queue->flushed = false;
-
-	/* Pin TX descriptor ring */
-	falcon_init_special_buffer(efx, &tx_queue->txd);
-
-	/* Push TX descriptor ring to card */
-	EFX_POPULATE_OWORD_10(tx_desc_ptr,
-			      TX_DESCQ_EN, 1,
-			      TX_ISCSI_DDIG_EN, 0,
-			      TX_ISCSI_HDIG_EN, 0,
-			      TX_DESCQ_BUF_BASE_ID, tx_queue->txd.index,
-			      TX_DESCQ_EVQ_ID, tx_queue->channel->channel,
-			      TX_DESCQ_OWNER_ID, 0,
-			      TX_DESCQ_LABEL, tx_queue->queue,
-			      TX_DESCQ_SIZE, FALCON_TXD_RING_ORDER,
-			      TX_DESCQ_TYPE, 0,
-			      TX_NON_IP_DROP_DIS_B0, 1);
-
-	if (falcon_rev(efx) >= FALCON_REV_B0) {
-		int csum = tx_queue->queue == EFX_TX_QUEUE_OFFLOAD_CSUM;
-		EFX_SET_OWORD_FIELD(tx_desc_ptr, TX_IP_CHKSM_DIS_B0, !csum);
-		EFX_SET_OWORD_FIELD(tx_desc_ptr, TX_TCP_CHKSM_DIS_B0, !csum);
-	}
-
-	falcon_write_table(efx, &tx_desc_ptr, efx->type->txd_ptr_tbl_base,
-			   tx_queue->queue);
-
-	if (falcon_rev(efx) < FALCON_REV_B0) {
-		efx_oword_t reg;
-
-		/* Only 128 bits in this register */
-		BUILD_BUG_ON(EFX_TX_QUEUE_COUNT >= 128);
-
-		falcon_read(efx, &reg, TX_CHKSM_CFG_REG_KER_A1);
-		if (tx_queue->queue == EFX_TX_QUEUE_OFFLOAD_CSUM)
-			clear_bit_le(tx_queue->queue, (void *)&reg);
-		else
-			set_bit_le(tx_queue->queue, (void *)&reg);
-		falcon_write(efx, &reg, TX_CHKSM_CFG_REG_KER_A1);
-	}
-}
-
-static void falcon_flush_tx_queue(struct efx_tx_queue *tx_queue)
-{
-	struct efx_nic *efx = tx_queue->efx;
-	efx_oword_t tx_flush_descq;
-
-	/* Post a flush command */
-	EFX_POPULATE_OWORD_2(tx_flush_descq,
-			     TX_FLUSH_DESCQ_CMD, 1,
-			     TX_FLUSH_DESCQ, tx_queue->queue);
-	falcon_write(efx, &tx_flush_descq, TX_FLUSH_DESCQ_REG_KER);
-}
-
-void falcon_fini_tx(struct efx_tx_queue *tx_queue)
-{
-	struct efx_nic *efx = tx_queue->efx;
-	efx_oword_t tx_desc_ptr;
-
-	/* The queue should have been flushed */
-	WARN_ON(!tx_queue->flushed);
-
-	/* Remove TX descriptor ring from card */
-	EFX_ZERO_OWORD(tx_desc_ptr);
-	falcon_write_table(efx, &tx_desc_ptr, efx->type->txd_ptr_tbl_base,
-			   tx_queue->queue);
-
-	/* Unpin TX descriptor ring */
-	falcon_fini_special_buffer(efx, &tx_queue->txd);
-}
-
-/* Free buffers backing TX queue */
-void falcon_remove_tx(struct efx_tx_queue *tx_queue)
-{
-	falcon_free_special_buffer(tx_queue->efx, &tx_queue->txd);
-}
-
-/**************************************************************************
- *
- * Falcon RX path
- *
- **************************************************************************/
-
-/* Returns a pointer to the specified descriptor in the RX descriptor queue */
-static inline efx_qword_t *falcon_rx_desc(struct efx_rx_queue *rx_queue,
-					       unsigned int index)
-{
-	return (((efx_qword_t *) (rx_queue->rxd.addr)) + index);
-}
-
-/* This creates an entry in the RX descriptor queue */
-static inline void falcon_build_rx_desc(struct efx_rx_queue *rx_queue,
-					unsigned index)
-{
-	struct efx_rx_buffer *rx_buf;
-	efx_qword_t *rxd;
-
-	rxd = falcon_rx_desc(rx_queue, index);
-	rx_buf = efx_rx_buffer(rx_queue, index);
-	EFX_POPULATE_QWORD_3(*rxd,
-			     RX_KER_BUF_SIZE,
-			     rx_buf->len -
-			     rx_queue->efx->type->rx_buffer_padding,
-			     RX_KER_BUF_REGION, 0,
-			     RX_KER_BUF_ADR, rx_buf->dma_addr);
-}
-
-/* This writes to the RX_DESC_WPTR register for the specified receive
- * descriptor ring.
- */
-void falcon_notify_rx_desc(struct efx_rx_queue *rx_queue)
-{
-	efx_dword_t reg;
-	unsigned write_ptr;
-
-	while (rx_queue->notified_count != rx_queue->added_count) {
-		falcon_build_rx_desc(rx_queue,
-				     rx_queue->notified_count &
-				     FALCON_RXD_RING_MASK);
-		++rx_queue->notified_count;
-	}
-
-	wmb();
-	write_ptr = rx_queue->added_count & FALCON_RXD_RING_MASK;
-	EFX_POPULATE_DWORD_1(reg, RX_DESC_WPTR_DWORD, write_ptr);
-	falcon_writel_page(rx_queue->efx, &reg,
-			   RX_DESC_UPD_REG_KER_DWORD, rx_queue->queue);
-}
-
-int falcon_probe_rx(struct efx_rx_queue *rx_queue)
-{
-	struct efx_nic *efx = rx_queue->efx;
-	int rc = falcon_alloc_special_buffer(efx, &rx_queue->rxd,
-					    FALCON_RXD_RING_SIZE *
-					    sizeof(efx_qword_t));
-#ifdef CONFIG_SFC_DRIVERLINK
-	if (rc == 0) {
-		struct falcon_nic_data *nic_data = efx->nic_data;
-		nic_data->resources.rxq_min = max(nic_data->resources.rxq_min,
-						  (unsigned)rx_queue->queue + 1);
-	}
-#endif
-	return rc;
-}
-
-void falcon_init_rx(struct efx_rx_queue *rx_queue)
-{
-	efx_oword_t rx_desc_ptr;
-	struct efx_nic *efx = rx_queue->efx;
-	bool is_b0 = falcon_rev(efx) >= FALCON_REV_B0;
-	bool iscsi_digest_en = is_b0;
-
-	EFX_LOG(efx, "RX queue %d ring in special buffers %d-%d\n",
-		rx_queue->queue, rx_queue->rxd.index,
-		rx_queue->rxd.index + rx_queue->rxd.entries - 1);
-
-	rx_queue->flushed = false;
-
-	/* Pin RX descriptor ring */
-	falcon_init_special_buffer(efx, &rx_queue->rxd);
-
-	/* Push RX descriptor ring to card */
-	EFX_POPULATE_OWORD_10(rx_desc_ptr,
-			      RX_ISCSI_DDIG_EN, iscsi_digest_en,
-			      RX_ISCSI_HDIG_EN, iscsi_digest_en,
-			      RX_DESCQ_BUF_BASE_ID, rx_queue->rxd.index,
-			      RX_DESCQ_EVQ_ID, rx_queue->channel->channel,
-			      RX_DESCQ_OWNER_ID, 0,
-			      RX_DESCQ_LABEL, rx_queue->queue,
-			      RX_DESCQ_SIZE, FALCON_RXD_RING_ORDER,
-			      RX_DESCQ_TYPE, 0 /* kernel queue */ ,
-			      /* For >=B0 this is scatter so disable */
-			      RX_DESCQ_JUMBO, !is_b0,
-			      RX_DESCQ_EN, 1);
-	falcon_write_table(efx, &rx_desc_ptr, efx->type->rxd_ptr_tbl_base,
-			   rx_queue->queue);
-}
-
-static void falcon_flush_rx_queue(struct efx_rx_queue *rx_queue)
-{
-	struct efx_nic *efx = rx_queue->efx;
-	efx_oword_t rx_flush_descq;
-
-	/* Post a flush command */
-	EFX_POPULATE_OWORD_2(rx_flush_descq,
-			     RX_FLUSH_DESCQ_CMD, 1,
-			     RX_FLUSH_DESCQ, rx_queue->queue);
-	falcon_write(efx, &rx_flush_descq, RX_FLUSH_DESCQ_REG_KER);
-}
-
-void falcon_fini_rx(struct efx_rx_queue *rx_queue)
-{
-	efx_oword_t rx_desc_ptr;
-	struct efx_nic *efx = rx_queue->efx;
-
-	/* The queue should already have been flushed */
-	WARN_ON(!rx_queue->flushed);
-
-	/* Remove RX descriptor ring from card */
-	EFX_ZERO_OWORD(rx_desc_ptr);
-	falcon_write_table(efx, &rx_desc_ptr, efx->type->rxd_ptr_tbl_base,
-			   rx_queue->queue);
-
-	/* Unpin RX descriptor ring */
-	falcon_fini_special_buffer(efx, &rx_queue->rxd);
-}
-
-/* Free buffers backing RX queue */
-void falcon_remove_rx(struct efx_rx_queue *rx_queue)
-{
-	falcon_free_special_buffer(rx_queue->efx, &rx_queue->rxd);
-}
-
-/**************************************************************************
- *
- * Falcon event queue processing
- * Event queues are processed by per-channel tasklets.
- *
- **************************************************************************/
-
-/* Update a channel's event queue's read pointer (RPTR) register
- *
- * This writes the EVQ_RPTR_REG register for the specified channel's
- * event queue.
- *
- * Note that EVQ_RPTR_REG contains the index of the "last read" event,
- * whereas channel->eventq_read_ptr contains the index of the "next to
- * read" event.
- */
-void falcon_eventq_read_ack(struct efx_channel *channel)
-{
-	efx_dword_t reg;
-	struct efx_nic *efx = channel->efx;
-
-	EFX_POPULATE_DWORD_1(reg, EVQ_RPTR_DWORD, channel->eventq_read_ptr);
-	falcon_writel_table(efx, &reg, efx->type->evq_rptr_tbl_base,
-			    channel->channel);
-}
-
-/* Use HW to insert a SW defined event */
-void falcon_generate_event(struct efx_channel *channel, efx_qword_t *event)
-{
-	efx_oword_t drv_ev_reg;
-
-	EFX_POPULATE_OWORD_2(drv_ev_reg,
-			     DRV_EV_QID, channel->channel,
-			     DRV_EV_DATA,
-			     EFX_QWORD_FIELD64(*event, WHOLE_EVENT));
-	falcon_write(channel->efx, &drv_ev_reg, DRV_EV_REG_KER);
-}
-
-/* Handle a transmit completion event
- *
- * Falcon batches TX completion events; the message we receive is of
- * the form "complete all TX events up to this index".
- */
-static void falcon_handle_tx_event(struct efx_channel *channel,
-				   efx_qword_t *event)
-{
-	unsigned int tx_ev_desc_ptr;
-	unsigned int tx_ev_q_label;
-	struct efx_tx_queue *tx_queue;
-	struct efx_nic *efx = channel->efx;
-
-	if (likely(EFX_QWORD_FIELD(*event, TX_EV_COMP))) {
-		/* Transmit completion */
-		tx_ev_desc_ptr = EFX_QWORD_FIELD(*event, TX_EV_DESC_PTR);
-		tx_ev_q_label = EFX_QWORD_FIELD(*event, TX_EV_Q_LABEL);
-		tx_queue = &efx->tx_queue[tx_ev_q_label];
-		channel->irq_mod_score +=
-			(tx_ev_desc_ptr - tx_queue->read_count) &
-			efx->type->txd_ring_mask;
-		efx_xmit_done(tx_queue, tx_ev_desc_ptr);
-	} else if (EFX_QWORD_FIELD(*event, TX_EV_WQ_FF_FULL)) {
-		/* Rewrite the FIFO write pointer */
-		tx_ev_q_label = EFX_QWORD_FIELD(*event, TX_EV_Q_LABEL);
-		tx_queue = &efx->tx_queue[tx_ev_q_label];
-
-		if (efx_dev_registered(efx))
-			netif_tx_lock(efx->net_dev);
-		falcon_notify_tx_desc(tx_queue);
-		if (efx_dev_registered(efx))
-			netif_tx_unlock(efx->net_dev);
-	} else if (EFX_QWORD_FIELD(*event, TX_EV_PKT_ERR) &&
-		   EFX_WORKAROUND_10727(efx)) {
-		efx_schedule_reset(efx, RESET_TYPE_TX_DESC_FETCH);
-	} else {
-		EFX_ERR(efx, "channel %d unexpected TX event "
-			EFX_QWORD_FMT"\n", channel->channel,
-			EFX_QWORD_VAL(*event));
-	}
-}
-
-/* Detect errors included in the rx_evt_pkt_ok bit. */
-static void falcon_handle_rx_not_ok(struct efx_rx_queue *rx_queue,
-				    const efx_qword_t *event,
-				    bool *rx_ev_pkt_ok,
-				    bool *discard)
-{
-	struct efx_nic *efx = rx_queue->efx;
-	bool rx_ev_buf_owner_id_err, rx_ev_ip_hdr_chksum_err;
-	bool rx_ev_tcp_udp_chksum_err, rx_ev_eth_crc_err;
-	bool rx_ev_frm_trunc, rx_ev_drib_nib, rx_ev_tobe_disc;
-	bool rx_ev_other_err, rx_ev_pause_frm;
-	bool rx_ev_ip_frag_err, rx_ev_hdr_type, rx_ev_mcast_pkt;
-	unsigned rx_ev_pkt_type;
-
-	rx_ev_hdr_type = EFX_QWORD_FIELD(*event, RX_EV_HDR_TYPE);
-	rx_ev_mcast_pkt = EFX_QWORD_FIELD(*event, RX_EV_MCAST_PKT);
-	rx_ev_tobe_disc = EFX_QWORD_FIELD(*event, RX_EV_TOBE_DISC);
-	rx_ev_pkt_type = EFX_QWORD_FIELD(*event, RX_EV_PKT_TYPE);
-	rx_ev_buf_owner_id_err = EFX_QWORD_FIELD(*event,
-						 RX_EV_BUF_OWNER_ID_ERR);
-	rx_ev_ip_frag_err = EFX_QWORD_FIELD(*event, RX_EV_IF_FRAG_ERR);
-	rx_ev_ip_hdr_chksum_err = EFX_QWORD_FIELD(*event,
-						  RX_EV_IP_HDR_CHKSUM_ERR);
-	rx_ev_tcp_udp_chksum_err = EFX_QWORD_FIELD(*event,
-						   RX_EV_TCP_UDP_CHKSUM_ERR);
-	rx_ev_eth_crc_err = EFX_QWORD_FIELD(*event, RX_EV_ETH_CRC_ERR);
-	rx_ev_frm_trunc = EFX_QWORD_FIELD(*event, RX_EV_FRM_TRUNC);
-	rx_ev_drib_nib = ((falcon_rev(efx) >= FALCON_REV_B0) ?
-			  0 : EFX_QWORD_FIELD(*event, RX_EV_DRIB_NIB));
-	rx_ev_pause_frm = EFX_QWORD_FIELD(*event, RX_EV_PAUSE_FRM_ERR);
-
-	/* Every error apart from tobe_disc and pause_frm */
-	rx_ev_other_err = (rx_ev_drib_nib | rx_ev_tcp_udp_chksum_err |
-			   rx_ev_buf_owner_id_err | rx_ev_eth_crc_err |
-			   rx_ev_frm_trunc | rx_ev_ip_hdr_chksum_err);
-
-	/* Count errors that are not in MAC stats.  Ignore expected
-	 * checksum errors during self-test. */
-	if (rx_ev_frm_trunc)
-		++rx_queue->channel->n_rx_frm_trunc;
-	else if (rx_ev_tobe_disc)
-		++rx_queue->channel->n_rx_tobe_disc;
-	else if (!efx->loopback_selftest) {
-		if (rx_ev_ip_hdr_chksum_err)
-			++rx_queue->channel->n_rx_ip_hdr_chksum_err;
-		else if (rx_ev_tcp_udp_chksum_err)
-			++rx_queue->channel->n_rx_tcp_udp_chksum_err;
-	}
-	if (rx_ev_ip_frag_err)
-		++rx_queue->channel->n_rx_ip_frag_err;
-
-	/* The frame must be discarded if any of these are true. */
-	*discard = (rx_ev_eth_crc_err | rx_ev_frm_trunc | rx_ev_drib_nib |
-		    rx_ev_tobe_disc | rx_ev_pause_frm);
-
-	/* TOBE_DISC is expected on unicast mismatches; don't print out an
-	 * error message.  FRM_TRUNC indicates RXDP dropped the packet due
-	 * to a FIFO overflow.
-	 */
-#ifdef EFX_ENABLE_DEBUG
-	if (rx_ev_other_err) {
-		EFX_INFO_RL(efx, " RX queue %d unexpected RX event "
-			    EFX_QWORD_FMT "%s%s%s%s%s%s%s%s\n",
-			    rx_queue->queue, EFX_QWORD_VAL(*event),
-			    rx_ev_buf_owner_id_err ? " [OWNER_ID_ERR]" : "",
-			    rx_ev_ip_hdr_chksum_err ?
-			    " [IP_HDR_CHKSUM_ERR]" : "",
-			    rx_ev_tcp_udp_chksum_err ?
-			    " [TCP_UDP_CHKSUM_ERR]" : "",
-			    rx_ev_eth_crc_err ? " [ETH_CRC_ERR]" : "",
-			    rx_ev_frm_trunc ? " [FRM_TRUNC]" : "",
-			    rx_ev_drib_nib ? " [DRIB_NIB]" : "",
-			    rx_ev_tobe_disc ? " [TOBE_DISC]" : "",
-			    rx_ev_pause_frm ? " [PAUSE]" : "");
-	}
-#endif
-}
-
-/* Handle receive events that are not in-order. */
-static void falcon_handle_rx_bad_index(struct efx_rx_queue *rx_queue,
-				       unsigned index)
-{
-	struct efx_nic *efx = rx_queue->efx;
-	unsigned expected, dropped;
-
-	expected = rx_queue->removed_count & FALCON_RXD_RING_MASK;
-	dropped = ((index + FALCON_RXD_RING_SIZE - expected) &
-		   FALCON_RXD_RING_MASK);
-	EFX_INFO(efx, "dropped %d events (index=%d expected=%d)\n",
-		dropped, index, expected);
-
-	efx_schedule_reset(efx, EFX_WORKAROUND_5676(efx) ?
-			   RESET_TYPE_RX_RECOVERY : RESET_TYPE_DISABLE);
-}
-
-/* Handle a packet received event
- *
- * Falcon silicon gives a "discard" flag if it's a unicast packet with the
- * wrong destination address
- * Also "is multicast" and "matches multicast filter" flags can be used to
- * discard non-matching multicast packets.
- */
-static void falcon_handle_rx_event(struct efx_channel *channel,
-				   const efx_qword_t *event)
-{
-	unsigned int rx_ev_desc_ptr, rx_ev_byte_cnt;
-	unsigned int rx_ev_hdr_type, rx_ev_mcast_pkt;
-	unsigned expected_ptr;
-	bool rx_ev_pkt_ok, discard = false, checksummed;
-	struct efx_rx_queue *rx_queue;
-	struct efx_nic *efx = channel->efx;
-
-	/* Basic packet information */
-	rx_ev_byte_cnt = EFX_QWORD_FIELD(*event, RX_EV_BYTE_CNT);
-	rx_ev_pkt_ok = EFX_QWORD_FIELD(*event, RX_EV_PKT_OK);
-	rx_ev_hdr_type = EFX_QWORD_FIELD(*event, RX_EV_HDR_TYPE);
-	WARN_ON(EFX_QWORD_FIELD(*event, RX_EV_JUMBO_CONT));
-	WARN_ON(EFX_QWORD_FIELD(*event, RX_EV_SOP) != 1);
-	WARN_ON(EFX_QWORD_FIELD(*event, RX_EV_Q_LABEL) != channel->channel);
-
-	rx_queue = &efx->rx_queue[channel->channel];
-
-	rx_ev_desc_ptr = EFX_QWORD_FIELD(*event, RX_EV_DESC_PTR);
-	expected_ptr = rx_queue->removed_count & FALCON_RXD_RING_MASK;
-	if (unlikely(rx_ev_desc_ptr != expected_ptr))
-		falcon_handle_rx_bad_index(rx_queue, rx_ev_desc_ptr);
-
-	if (likely(rx_ev_pkt_ok)) {
-		/* If packet is marked as OK and packet type is TCP/IPv4 or
-		 * UDP/IPv4, then we can rely on the hardware checksum.
-		 */
-		checksummed = RX_EV_HDR_TYPE_HAS_CHECKSUMS(rx_ev_hdr_type);
-	} else {
-		falcon_handle_rx_not_ok(rx_queue, event, &rx_ev_pkt_ok,
-					&discard);
-		checksummed = false;
-	}
-
-	/* Detect multicast packets that didn't match the filter */
-	rx_ev_mcast_pkt = EFX_QWORD_FIELD(*event, RX_EV_MCAST_PKT);
-	if (rx_ev_mcast_pkt) {
-		unsigned int rx_ev_mcast_hash_match =
-			EFX_QWORD_FIELD(*event, RX_EV_MCAST_HASH_MATCH);
-
-		if (unlikely(!rx_ev_mcast_hash_match))
-			discard = true;
-	}
-
-	channel->irq_mod_score += 2;
-
-	/* Handle received packet */
-	efx_rx_packet(rx_queue, rx_ev_desc_ptr, rx_ev_byte_cnt,
-		      checksummed, discard);
-}
-
-/* Global events are basically PHY events */
-static void falcon_handle_global_event(struct efx_channel *channel,
-				       efx_qword_t *event)
-{
-	struct efx_nic *efx = channel->efx;
-	bool handled = false;
-
-	if (EFX_QWORD_FIELD(*event, G_PHY0_INTR) ||
-	    EFX_QWORD_FIELD(*event, G_PHY1_INTR) ||
-	    EFX_QWORD_FIELD(*event, XG_PHY_INTR) ||
-	    EFX_QWORD_FIELD(*event, XFP_PHY_INTR)) {
-		efx->phy_op->clear_interrupt(efx);
-		queue_work(efx->workqueue, &efx->phy_work);
-		handled = true;
-	}
-
-	if ((falcon_rev(efx) >= FALCON_REV_B0) &&
-	    EFX_QWORD_FIELD(*event, XG_MNT_INTR_B0)) {
-		queue_work(efx->workqueue, &efx->mac_work);
-		handled = true;
-	}
-
-	if (EFX_QWORD_FIELD_VER(efx, *event, RX_RECOVERY)) {
-		EFX_ERR(efx, "channel %d seen global RX_RESET "
-			"event. Resetting.\n", channel->channel);
-
-		atomic_inc(&efx->rx_reset);
-		efx_schedule_reset(efx, EFX_WORKAROUND_6555(efx) ?
-				   RESET_TYPE_RX_RECOVERY : RESET_TYPE_DISABLE);
-		handled = true;
-	}
-
-	if (!handled)
-		EFX_ERR(efx, "channel %d unknown global event "
-			EFX_QWORD_FMT "\n", channel->channel,
-			EFX_QWORD_VAL(*event));
-}
-
-static void falcon_handle_driver_event(struct efx_channel *channel,
-				       efx_qword_t *event)
-{
-	struct efx_nic *efx = channel->efx;
-	unsigned int ev_sub_code;
-	unsigned int ev_sub_data;
-
-	ev_sub_code = EFX_QWORD_FIELD(*event, DRIVER_EV_SUB_CODE);
-	ev_sub_data = EFX_QWORD_FIELD(*event, DRIVER_EV_SUB_DATA);
-
-	switch (ev_sub_code) {
-	case TX_DESCQ_FLS_DONE_EV_DECODE:
-		EFX_TRACE(efx, "channel %d TXQ %d flushed\n",
-			  channel->channel, ev_sub_data);
-		EFX_DL_CALLBACK(efx, event, event);
-		break;
-	case RX_DESCQ_FLS_DONE_EV_DECODE:
-		EFX_TRACE(efx, "channel %d RXQ %d flushed\n",
-			  channel->channel, ev_sub_data);
-		EFX_DL_CALLBACK(efx, event, event);
-		break;
-	case EVQ_INIT_DONE_EV_DECODE:
-		EFX_LOG(efx, "channel %d EVQ %d initialised\n",
-			channel->channel, ev_sub_data);
-		break;
-	case SRM_UPD_DONE_EV_DECODE:
-		EFX_TRACE(efx, "channel %d SRAM update done\n",
-			  channel->channel);
-		EFX_DL_CALLBACK(efx, event, event);
-		break;
-	case WAKE_UP_EV_DECODE:
-		EFX_TRACE(efx, "channel %d RXQ %d wakeup event\n",
-			  channel->channel, ev_sub_data);
-		EFX_DL_CALLBACK(efx, event, event);
-		break;
-	case TIMER_EV_DECODE:
-		EFX_TRACE(efx, "channel %d RX queue %d timer expired\n",
-			  channel->channel, ev_sub_data);
-		EFX_DL_CALLBACK(efx, event, event);
-		break;
-	case RX_RECOVERY_EV_DECODE:
-		EFX_ERR(efx, "channel %d seen DRIVER RX_RESET event. "
-			"Resetting.\n", channel->channel);
-		atomic_inc(&efx->rx_reset);
-		efx_schedule_reset(efx,
-				   EFX_WORKAROUND_6555(efx) ?
-				   RESET_TYPE_RX_RECOVERY :
-				   RESET_TYPE_DISABLE);
-		break;
-	case RX_DSC_ERROR_EV_DECODE:
-		EFX_ERR(efx, "RX DMA Q %d reports descriptor fetch error."
-			" RX Q %d is disabled.\n", ev_sub_data, ev_sub_data);
-		efx_schedule_reset(efx, RESET_TYPE_RX_DESC_FETCH);
-		break;
-	case TX_DSC_ERROR_EV_DECODE:
-		EFX_ERR(efx, "TX DMA Q %d reports descriptor fetch error."
-			" TX Q %d is disabled.\n", ev_sub_data, ev_sub_data);
-		efx_schedule_reset(efx, RESET_TYPE_TX_DESC_FETCH);
-		break;
-	default:
-		EFX_TRACE(efx, "channel %d unknown driver event code %d "
-			  "data %04x\n", channel->channel, ev_sub_code,
-			  ev_sub_data);
-		EFX_DL_CALLBACK(efx, event, event);
-		break;
-	}
-}
-
-int falcon_process_eventq(struct efx_channel *channel, int rx_quota)
-{
-	unsigned int read_ptr;
-	efx_qword_t event, *p_event;
-	int ev_code;
-	int rx_packets = 0;
-
-	read_ptr = channel->eventq_read_ptr;
-
-	do {
-		p_event = falcon_event(channel, read_ptr);
-		event = *p_event;
-
-		if (!falcon_event_present(&event))
-			/* End of events */
-			break;
-
-		EFX_TRACE(channel->efx, "channel %d event is "EFX_QWORD_FMT"\n",
-			  channel->channel, EFX_QWORD_VAL(event));
-
-		/* Clear this event by marking it all ones */
-		EFX_SET_QWORD(*p_event);
-
-		ev_code = EFX_QWORD_FIELD(event, EV_CODE);
-
-		switch (ev_code) {
-		case RX_IP_EV_DECODE:
-			falcon_handle_rx_event(channel, &event);
-			++rx_packets;
-			break;
-		case TX_IP_EV_DECODE:
-			falcon_handle_tx_event(channel, &event);
-			break;
-		case DRV_GEN_EV_DECODE:
-			channel->eventq_magic
-				= EFX_QWORD_FIELD(event, EVQ_MAGIC);
-			EFX_LOG(channel->efx, "channel %d received generated "
-				"event "EFX_QWORD_FMT"\n", channel->channel,
-				EFX_QWORD_VAL(event));
-			break;
-		case GLOBAL_EV_DECODE:
-			falcon_handle_global_event(channel, &event);
-			break;
-		case DRIVER_EV_DECODE:
-			falcon_handle_driver_event(channel, &event);
-			break;
-		default:
-			EFX_ERR(channel->efx, "channel %d unknown event type %d"
-				" (data " EFX_QWORD_FMT ")\n", channel->channel,
-				ev_code, EFX_QWORD_VAL(event));
-		}
-
-		/* Increment read pointer */
-		read_ptr = (read_ptr + 1) & FALCON_EVQ_MASK;
-
-	} while (rx_packets < rx_quota);
-
-	channel->eventq_read_ptr = read_ptr;
-	return rx_packets;
-}
-
-void falcon_set_int_moderation(struct efx_channel *channel)
+static void falcon_push_irq_moderation(struct efx_channel *channel)
 {
 	efx_dword_t timer_cmd;
 	struct efx_nic *efx = channel->efx;
 
 	/* Set timer register */
 	if (channel->irq_moderation) {
-		/* Round to resolution supported by hardware.  The value we
-		 * program is based at 0.  So actual interrupt moderation
-		 * achieved is ((x + 1) * res).
-		 */
-		channel->irq_moderation -= (channel->irq_moderation %
-					    FALCON_IRQ_MOD_RESOLUTION);
-		if (channel->irq_moderation < FALCON_IRQ_MOD_RESOLUTION)
-			channel->irq_moderation = FALCON_IRQ_MOD_RESOLUTION;
 		EFX_POPULATE_DWORD_2(timer_cmd,
-				     TIMER_MODE, TIMER_MODE_INT_HLDOFF,
-				     TIMER_VAL,
-				     channel->irq_moderation /
-				     FALCON_IRQ_MOD_RESOLUTION - 1);
+				     FRF_AB_TC_TIMER_MODE,
+				     FFE_BB_TIMER_MODE_INT_HLDOFF,
+				     FRF_AB_TC_TIMER_VAL,
+				     channel->irq_moderation - 1);
 	} else {
 		EFX_POPULATE_DWORD_2(timer_cmd,
-				     TIMER_MODE, TIMER_MODE_DIS,
-				     TIMER_VAL, 0);
+				     FRF_AB_TC_TIMER_MODE,
+				     FFE_BB_TIMER_MODE_DIS,
+				     FRF_AB_TC_TIMER_VAL, 0);
 	}
-	falcon_writel_page_locked(efx, &timer_cmd, TIMER_CMD_REG_KER,
-				  channel->channel);
-
+	BUILD_BUG_ON(FR_AA_TIMER_COMMAND_KER != FR_BZ_TIMER_COMMAND_P0);
+	efx_writed_page_locked(efx, &timer_cmd, FR_BZ_TIMER_COMMAND_P0,
+			       channel->channel);
 }
 
-/* Allocate buffer table entries for event queue */
-int falcon_probe_eventq(struct efx_channel *channel)
+static void falcon_deconfigure_mac_wrapper(struct efx_nic *efx);
+
+static void falcon_prepare_flush(struct efx_nic *efx)
 {
-	struct efx_nic *efx = channel->efx;
-	unsigned int evq_size;
-	int rc;
+	falcon_deconfigure_mac_wrapper(efx);
 
-	evq_size = FALCON_EVQ_SIZE * sizeof(efx_qword_t);
-	rc = falcon_alloc_special_buffer(efx, &channel->eventq, evq_size);
-#ifdef CONFIG_SFC_DRIVERLINK
-	if (rc == 0) {
-		struct falcon_nic_data *nic_data = efx->nic_data;
-		nic_data->resources.evq_int_min = max(nic_data->resources.evq_int_min,
-						      (unsigned)channel->channel + 1);
-	}
-#endif
-	return rc;
-}
-
-void falcon_init_eventq(struct efx_channel *channel)
-{
-	efx_oword_t evq_ptr;
-	struct efx_nic *efx = channel->efx;
-
-	EFX_LOG(efx, "channel %d event queue in special buffers %d-%d\n",
-		channel->channel, channel->eventq.index,
-		channel->eventq.index + channel->eventq.entries - 1);
-
-	/* Pin event queue buffer */
-	falcon_init_special_buffer(efx, &channel->eventq);
-
-	/* Fill event queue with all ones (i.e. empty events) */
-	memset(channel->eventq.addr, 0xff, channel->eventq.len);
-
-	/* Push event queue to card */
-	EFX_POPULATE_OWORD_3(evq_ptr,
-			     EVQ_EN, 1,
-			     EVQ_SIZE, FALCON_EVQ_ORDER,
-			     EVQ_BUF_BASE_ID, channel->eventq.index);
-	falcon_write_table(efx, &evq_ptr, efx->type->evq_ptr_tbl_base,
-			   channel->channel);
-
-	falcon_set_int_moderation(channel);
-}
-
-void falcon_fini_eventq(struct efx_channel *channel)
-{
-	efx_oword_t eventq_ptr;
-	struct efx_nic *efx = channel->efx;
-
-	/* Remove event queue from card */
-	EFX_ZERO_OWORD(eventq_ptr);
-	falcon_write_table(efx, &eventq_ptr, efx->type->evq_ptr_tbl_base,
-			   channel->channel);
-
-	/* Unpin event queue */
-	falcon_fini_special_buffer(efx, &channel->eventq);
-}
-
-/* Free buffers backing event queue */
-void falcon_remove_eventq(struct efx_channel *channel)
-{
-	falcon_free_special_buffer(channel->efx, &channel->eventq);
-}
-
-
-/* Generates a test event on the event queue.  A subsequent call to
- * process_eventq() should pick up the event and place the value of
- * "magic" into channel->eventq_magic;
- */
-void falcon_generate_test_event(struct efx_channel *channel, unsigned int magic)
-{
-	efx_qword_t test_event;
-
-	EFX_POPULATE_QWORD_2(test_event,
-			     EV_CODE, DRV_GEN_EV_DECODE,
-			     EVQ_MAGIC, magic);
-	falcon_generate_event(channel, &test_event);
-}
-
-void falcon_sim_phy_event(struct efx_nic *efx)
-{
-	efx_qword_t phy_event;
-
-	EFX_POPULATE_QWORD_1(phy_event, EV_CODE, GLOBAL_EV_DECODE);
-	if (EFX_IS10G(efx))
-		EFX_SET_QWORD_FIELD(phy_event, XG_PHY_INTR, 1);
-	else
-		EFX_SET_QWORD_FIELD(phy_event, G_PHY0_INTR, 1);
-
-	falcon_generate_event(&efx->channel[0], &phy_event);
-}
-
-/**************************************************************************
- *
- * Flush handling
- *
- **************************************************************************/
-
-
-static void falcon_poll_flush_events(struct efx_nic *efx)
-{
-	struct efx_channel *channel = &efx->channel[0];
-	struct efx_tx_queue *tx_queue;
-	struct efx_rx_queue *rx_queue;
-	unsigned int read_ptr = channel->eventq_read_ptr;
-	unsigned int end_ptr = (read_ptr - 1) & FALCON_EVQ_MASK;
-
-	do {
-		efx_qword_t *event = falcon_event(channel, read_ptr);
-		int ev_code, ev_sub_code, ev_queue;
-		bool ev_failed;
-
-		if (!falcon_event_present(event))
-			break;
-
-		ev_code = EFX_QWORD_FIELD(*event, EV_CODE);
-		ev_sub_code = EFX_QWORD_FIELD(*event, DRIVER_EV_SUB_CODE);
-		if (ev_code == DRIVER_EV_DECODE &&
-		    ev_sub_code == TX_DESCQ_FLS_DONE_EV_DECODE) {
-			ev_queue = EFX_QWORD_FIELD(*event,
-						   DRIVER_EV_TX_DESCQ_ID);
-			if (ev_queue < EFX_TX_QUEUE_COUNT) {
-				tx_queue = efx->tx_queue + ev_queue;
-				tx_queue->flushed = true;
-			}
-		} else if (ev_code == DRIVER_EV_DECODE &&
-			   ev_sub_code == RX_DESCQ_FLS_DONE_EV_DECODE) {
-			ev_queue = EFX_QWORD_FIELD(*event,
-						   DRIVER_EV_RX_DESCQ_ID);
-			ev_failed = EFX_QWORD_FIELD(*event,
-						    DRIVER_EV_RX_FLUSH_FAIL);
-			if (ev_queue < efx->n_rx_queues) {
-				rx_queue = efx->rx_queue + ev_queue;
-
-				/* retry the rx flush */
-				if (ev_failed)
-					falcon_flush_rx_queue(rx_queue);
-				else
-					rx_queue->flushed = true;
-			}
-		}
-
-		read_ptr = (read_ptr + 1) & FALCON_EVQ_MASK;
-	} while (read_ptr != end_ptr);
-}
-
-/* Handle tx and rx flushes at the same time, since they run in
- * parallel in the hardware and there's no reason for us to
- * serialise them */
-int falcon_flush_queues(struct efx_nic *efx)
-{
-	struct efx_rx_queue *rx_queue;
-	struct efx_tx_queue *tx_queue;
-	int i;
-	bool outstanding;
-
-	/* Issue flush requests */
-	efx_for_each_tx_queue(tx_queue, efx) {
-		tx_queue->flushed = false;
-		falcon_flush_tx_queue(tx_queue);
-	}
-	efx_for_each_rx_queue(rx_queue, efx) {
-		rx_queue->flushed = false;
-		falcon_flush_rx_queue(rx_queue);
-	}
-
-	/* Poll the evq looking for flush completions. Since we're not pushing
-	 * any more rx or tx descriptors at this point, we're in no danger of
-	 * overflowing the evq whilst we wait */
-	for (i = 0; i < FALCON_FLUSH_POLL_COUNT; ++i) {
-		msleep(FALCON_FLUSH_INTERVAL);
-		falcon_poll_flush_events(efx);
-
-		/* Check if every queue has been succesfully flushed */
-		outstanding = false;
-		efx_for_each_tx_queue(tx_queue, efx)
-			outstanding |= !tx_queue->flushed;
-		efx_for_each_rx_queue(rx_queue, efx)
-			outstanding |= !rx_queue->flushed;
-		if (!outstanding)
-			return 0;
-	}
-
-	/* Mark the queues as all flushed. We're going to return failure
-	 * leading to a reset, or fake up success anyway. "flushed" now
-	 * indicates that we tried to flush. */
-	efx_for_each_tx_queue(tx_queue, efx) {
-		if (!tx_queue->flushed)
-			EFX_ERR(efx, "tx queue %d flush command timed out\n",
-				tx_queue->queue);
-		tx_queue->flushed = true;
-	}
-	efx_for_each_rx_queue(rx_queue, efx) {
-		if (!rx_queue->flushed)
-			EFX_ERR(efx, "rx queue %d flush command timed out\n",
-				rx_queue->queue);
-		rx_queue->flushed = true;
-	}
-
-	if (EFX_WORKAROUND_7803(efx))
-		return 0;
-
-	return -ETIMEDOUT;
-}
-
-/**************************************************************************
- *
- * Falcon hardware interrupts
- * The hardware interrupt handler does very little work; all the event
- * queue processing is carried out by per-channel tasklets.
- *
- **************************************************************************/
-
-/* Enable/disable/generate Falcon interrupts */
-static inline void falcon_interrupts(struct efx_nic *efx, int enabled,
-				     int force)
-{
-	efx_oword_t int_en_reg_ker;
-
-	EFX_POPULATE_OWORD_2(int_en_reg_ker,
-			     KER_INT_KER, force,
-			     DRV_INT_EN_KER, enabled);
-	falcon_write(efx, &int_en_reg_ker, INT_EN_REG_KER);
-}
-
-void falcon_enable_interrupts(struct efx_nic *efx)
-{
-	efx_oword_t int_adr_reg_ker;
-	struct efx_channel *channel;
-
-	EFX_ZERO_OWORD(*((efx_oword_t *) efx->irq_status.addr));
-	wmb(); /* Ensure interrupt vector is clear before interrupts enabled */
-
-	/* Program address */
-	EFX_POPULATE_OWORD_2(int_adr_reg_ker,
-			     NORM_INT_VEC_DIS_KER, EFX_INT_MODE_USE_MSI(efx),
-			     INT_ADR_KER, efx->irq_status.dma_addr);
-	falcon_write(efx, &int_adr_reg_ker, INT_ADR_REG_KER);
-
-	/* Enable interrupts */
-	falcon_interrupts(efx, 1, 0);
-
-	/* Force processing of all the channels to get the EVQ RPTRs up to
-	   date */
-	efx_for_each_channel(channel, efx)
-		efx_schedule_channel(channel);
-}
-
-void falcon_disable_interrupts(struct efx_nic *efx)
-{
-	/* Disable interrupts */
-	falcon_interrupts(efx, 0, 0);
-}
-
-/* Generate a Falcon test interrupt
- * Interrupt must already have been enabled, otherwise nasty things
- * may happen.
- */
-void falcon_generate_interrupt(struct efx_nic *efx)
-{
-	falcon_interrupts(efx, 1, 1);
+	/* Wait for the tx and rx fifo's to get to the next packet boundary
+	 * (~1ms without back-pressure), then to drain the remainder of the
+	 * fifo's at data path speeds (negligible), with a healthy margin. */
+	msleep(10);
 }
 
 /* Acknowledge a legacy interrupt from Falcon
@@ -1411,117 +218,25 @@ void falcon_generate_interrupt(struct ef
  *
  * NB most hardware supports MSI interrupts
  */
-static inline void falcon_irq_ack_a1(struct efx_nic *efx)
+inline void falcon_irq_ack_a1(struct efx_nic *efx)
 {
 	efx_dword_t reg;
 
-	EFX_POPULATE_DWORD_1(reg, INT_ACK_DUMMY_DATA, 0xb7eb7e);
-	falcon_writel(efx, &reg, INT_ACK_REG_KER_A1);
-	falcon_readl(efx, &reg, WORK_AROUND_BROKEN_PCI_READS_REG_KER_A1);
+	EFX_POPULATE_DWORD_1(reg, FRF_AA_INT_ACK_KER_FIELD, 0xb7eb7e);
+	efx_writed(efx, &reg, FR_AA_INT_ACK_KER);
+	efx_readd(efx, &reg, FR_AA_WORK_AROUND_BROKEN_PCI_READS);
 }
 
-/* Process a fatal interrupt
- * Disable bus mastering ASAP and schedule a reset
- */
-static irqreturn_t falcon_fatal_interrupt(struct efx_nic *efx)
-{
-	struct falcon_nic_data *nic_data = efx->nic_data;
-	efx_oword_t *int_ker = efx->irq_status.addr;
-	efx_oword_t fatal_intr;
-	int error, mem_perr;
-
-	falcon_read(efx, &fatal_intr, FATAL_INTR_REG_KER);
-	error = EFX_OWORD_FIELD(fatal_intr, INT_KER_ERROR);
-
-	EFX_ERR(efx, "SYSTEM ERROR " EFX_OWORD_FMT " status "
-		EFX_OWORD_FMT ": %s\n", EFX_OWORD_VAL(*int_ker),
-		EFX_OWORD_VAL(fatal_intr),
-		error ? "disabling bus mastering" : "no recognised error");
-	if (error == 0)
-		goto out;
-
-	/* If this is a memory parity error dump which blocks are offending */
-	mem_perr = EFX_OWORD_FIELD(fatal_intr, MEM_PERR_INT_KER);
-	if (mem_perr) {
-		efx_oword_t reg;
-		falcon_read(efx, &reg, MEM_STAT_REG_KER);
-		EFX_ERR(efx, "SYSTEM ERROR: memory parity error "
-			EFX_OWORD_FMT "\n", EFX_OWORD_VAL(reg));
-	}
-
-	/* Disable both devices */
-	pci_clear_master(efx->pci_dev);
-	if (FALCON_IS_DUAL_FUNC(efx))
-		pci_clear_master(nic_data->pci_dev2);
-	falcon_disable_interrupts(efx);
-
-	/* Count errors and reset or disable the NIC accordingly */
-	if (nic_data->int_error_count == 0 ||
-	    time_after(jiffies, nic_data->int_error_expire)) {
-		nic_data->int_error_count = 0;
-		nic_data->int_error_expire =
-			jiffies + FALCON_INT_ERROR_EXPIRE * HZ;
-	}
-	if (++nic_data->int_error_count < FALCON_MAX_INT_ERRORS) {
-		EFX_ERR(efx, "SYSTEM ERROR - reset scheduled\n");
-		efx_schedule_reset(efx, RESET_TYPE_INT_ERROR);
-	} else {
-		EFX_ERR(efx, "SYSTEM ERROR - max number of errors seen."
-			"NIC will be disabled\n");
-		efx_schedule_reset(efx, RESET_TYPE_DISABLE);
-	}
-out:
-	return IRQ_HANDLED;
-}
-
-/* Handle a legacy interrupt from Falcon
- * Acknowledges the interrupt and schedule event queue processing.
- */
-static irqreturn_t falcon_legacy_interrupt_b0(int irq, void *dev_id)
+#if !defined(EFX_USE_KCOMPAT) || !defined(EFX_HAVE_IRQ_HANDLER_REGS)
+irqreturn_t falcon_legacy_interrupt_a1(int irq, void *dev_id)
+#else
+irqreturn_t falcon_legacy_interrupt_a1(int irq, void *dev_id,
+				       struct pt_regs *regs
+				       __attribute__ ((unused)))
+#endif
 {
 	struct efx_nic *efx = dev_id;
 	efx_oword_t *int_ker = efx->irq_status.addr;
-	irqreturn_t result = IRQ_NONE;
-	struct efx_channel *channel;
-	efx_dword_t reg;
-	u32 queues;
-	int syserr;
-
-	/* Read the ISR which also ACKs the interrupts */
-	falcon_readl(efx, &reg, INT_ISR0_B0);
-	queues = EFX_EXTRACT_DWORD(reg, 0, 31);
-
-	/* Check to see if we have a serious error condition */
-	syserr = EFX_OWORD_FIELD(*int_ker, FATAL_INT);
-	if (unlikely(syserr))
-		return falcon_fatal_interrupt(efx);
-
-	/* Schedule processing of any interrupting queues */
-	efx_for_each_channel(channel, efx) {
-		if ((queues & 1) ||
-		    falcon_event_present(
-			    falcon_event(channel, channel->eventq_read_ptr))) {
-			efx_schedule_channel(channel);
-			result = IRQ_HANDLED;
-		}
-		queues >>= 1;
-	}
-
-	if (result == IRQ_HANDLED) {
-		efx->last_irq_cpu = raw_smp_processor_id();
-		EFX_TRACE(efx, "IRQ %d on CPU %d status " EFX_DWORD_FMT "\n",
-			  irq, raw_smp_processor_id(), EFX_DWORD_VAL(reg));
-	}
-
-	return result;
-}
-
-
-static irqreturn_t falcon_legacy_interrupt_a1(int irq, void *dev_id)
-{
-	struct efx_nic *efx = dev_id;
-	efx_oword_t *int_ker = efx->irq_status.addr;
-	struct efx_channel *channel;
 	int syserr;
 	int queues;
 
@@ -1529,157 +244,35 @@ static irqreturn_t falcon_legacy_interru
 	 * exit without having touched the hardware.
 	 */
 	if (unlikely(EFX_OWORD_IS_ZERO(*int_ker))) {
-		EFX_TRACE(efx, "IRQ %d on CPU %d not for me\n", irq,
-			  raw_smp_processor_id());
+		netif_vdbg(efx, intr, efx->net_dev,
+			   "IRQ %d on CPU %d not for me\n", irq,
+			   raw_smp_processor_id());
 		return IRQ_NONE;
 	}
 	efx->last_irq_cpu = raw_smp_processor_id();
-	EFX_TRACE(efx, "IRQ %d on CPU %d status " EFX_OWORD_FMT "\n",
-		  irq, raw_smp_processor_id(), EFX_OWORD_VAL(*int_ker));
-
-	/* Check to see if we have a serious error condition */
-	syserr = EFX_OWORD_FIELD(*int_ker, FATAL_INT);
-	if (unlikely(syserr))
-		return falcon_fatal_interrupt(efx);
+	netif_vdbg(efx, intr, efx->net_dev,
+		   "IRQ %d on CPU %d status " EFX_OWORD_FMT "\n",
+		   irq, raw_smp_processor_id(), EFX_OWORD_VAL(*int_ker));
 
 	/* Determine interrupting queues, clear interrupt status
 	 * register and acknowledge the device interrupt.
 	 */
-	BUILD_BUG_ON(INT_EVQS_WIDTH > EFX_MAX_CHANNELS);
-	queues = EFX_OWORD_FIELD(*int_ker, INT_EVQS);
+	BUILD_BUG_ON(FSF_AZ_NET_IVEC_INT_Q_WIDTH > EFX_MAX_CHANNELS);
+	queues = EFX_OWORD_FIELD(*int_ker, FSF_AZ_NET_IVEC_INT_Q);
+
+	/* Check to see if we have a serious error condition */
+	if (queues & (1U << efx->irq_level)) {
+		syserr = EFX_OWORD_FIELD(*int_ker, FSF_AZ_NET_IVEC_FATAL_INT);
+		if (unlikely(syserr))
+			return efx_nic_fatal_interrupt(efx);
+	}
+
 	EFX_ZERO_OWORD(*int_ker);
 	wmb(); /* Ensure the vector is cleared before interrupt ack */
 	falcon_irq_ack_a1(efx);
 
-	/* Schedule processing of any interrupting queues */
-	channel = &efx->channel[0];
-	while (queues) {
-		if (queues & 0x01)
-			efx_schedule_channel(channel);
-		channel++;
-		queues >>= 1;
-	}
-
+	efx_schedule_channel(efx->channel[0]);
 	return IRQ_HANDLED;
-}
-
-/* Handle an MSI interrupt from Falcon
- *
- * Handle an MSI hardware interrupt.  This routine schedules event
- * queue processing.  No interrupt acknowledgement cycle is necessary.
- * Also, we never need to check that the interrupt is for us, since
- * MSI interrupts cannot be shared.
- */
-static irqreturn_t falcon_msi_interrupt(int irq, void *dev_id)
-{
-	struct efx_channel *channel = dev_id;
-	struct efx_nic *efx = channel->efx;
-	efx_oword_t *int_ker = efx->irq_status.addr;
-	int syserr;
-
-	efx->last_irq_cpu = raw_smp_processor_id();
-	EFX_TRACE(efx, "IRQ %d on CPU %d status " EFX_OWORD_FMT "\n",
-		  irq, raw_smp_processor_id(), EFX_OWORD_VAL(*int_ker));
-
-	/* Check to see if we have a serious error condition */
-	syserr = EFX_OWORD_FIELD(*int_ker, FATAL_INT);
-	if (unlikely(syserr))
-		return falcon_fatal_interrupt(efx);
-
-	/* Schedule processing of the channel */
-	efx_schedule_channel(channel);
-
-	return IRQ_HANDLED;
-}
-
-
-/* Setup RSS indirection table.
- * This maps from the hash value of the packet to RXQ
- */
-static void falcon_setup_rss_indir_table(struct efx_nic *efx)
-{
-	int i = 0;
-	unsigned long offset;
-	efx_dword_t dword;
-
-	if (falcon_rev(efx) < FALCON_REV_B0)
-		return;
-
-	for (offset = RX_RSS_INDIR_TBL_B0;
-	     offset < RX_RSS_INDIR_TBL_B0 + 0x800;
-	     offset += 0x10) {
-		EFX_POPULATE_DWORD_1(dword, RX_RSS_INDIR_ENT_B0,
-				     i % efx->n_rx_queues);
-		falcon_writel(efx, &dword, offset);
-		i++;
-	}
-}
-
-/* Hook interrupt handler(s)
- * Try MSI and then legacy interrupts.
- */
-int falcon_init_interrupt(struct efx_nic *efx)
-{
-	struct efx_channel *channel;
-	int rc;
-
-	if (!EFX_INT_MODE_USE_MSI(efx)) {
-		irq_handler_t handler;
-		if (falcon_rev(efx) >= FALCON_REV_B0)
-			handler = falcon_legacy_interrupt_b0;
-		else
-			handler = falcon_legacy_interrupt_a1;
-
-		rc = request_irq(efx->legacy_irq, handler, IRQF_SHARED,
-				 efx->name, efx);
-		if (rc) {
-			EFX_ERR(efx, "failed to hook legacy IRQ %d\n",
-				efx->pci_dev->irq);
-			goto fail1;
-		}
-		return 0;
-	}
-
-	/* Hook MSI or MSI-X interrupt */
-	efx_for_each_channel(channel, efx) {
-		rc = request_irq(channel->irq, falcon_msi_interrupt,
-				 IRQF_PROBE_SHARED, /* Not shared */
-				 channel->name, channel);
-		if (rc) {
-			EFX_ERR(efx, "failed to hook IRQ %d\n", channel->irq);
-			goto fail2;
-		}
-	}
-
-	return 0;
-
- fail2:
-	efx_for_each_channel(channel, efx)
-		free_irq(channel->irq, channel);
- fail1:
-	return rc;
-}
-
-void falcon_fini_interrupt(struct efx_nic *efx)
-{
-	struct efx_channel *channel;
-	efx_oword_t reg;
-
-	/* Disable MSI/MSI-X interrupts */
-	efx_for_each_channel(channel, efx) {
-		if (channel->irq)
-			free_irq(channel->irq, channel);
-	}
-
-	/* ACK legacy interrupt */
-	if (falcon_rev(efx) >= FALCON_REV_B0)
-		falcon_read(efx, &reg, INT_ISR0_B0);
-	else
-		falcon_irq_ack_a1(efx);
-
-	/* Disable legacy interrupt */
-	if (efx->legacy_irq)
-		free_irq(efx->legacy_irq, efx);
 }
 
 /**************************************************************************
@@ -1694,8 +287,8 @@ static int falcon_spi_poll(struct efx_ni
 static int falcon_spi_poll(struct efx_nic *efx)
 {
 	efx_oword_t reg;
-	falcon_read(efx, &reg, EE_SPI_HCMD_REG_KER);
-	return EFX_OWORD_FIELD(reg, EE_SPI_HCMD_CMD_EN) ? -EBUSY : 0;
+	efx_reado(efx, &reg, FR_AB_EE_SPI_HCMD);
+	return EFX_OWORD_FIELD(reg, FRF_AB_EE_SPI_HCMD_CMD_EN) ? -EBUSY : 0;
 }
 
 /* Wait for SPI command completion */
@@ -1718,18 +311,18 @@ static int falcon_spi_wait(struct efx_ni
 		if (!falcon_spi_poll(efx))
 			return 0;
 		if (time_after_eq(jiffies, timeout)) {
-			EFX_ERR(efx, "timed out waiting for SPI\n");
+			netif_err(efx, hw, efx->net_dev,
+				  "timed out waiting for SPI\n");
 			return -ETIMEDOUT;
 		}
 		schedule_timeout_uninterruptible(1);
 	}
 }
 
-int falcon_spi_cmd(const struct efx_spi_device *spi,
+int falcon_spi_cmd(struct efx_nic *efx, const struct efx_spi_device *spi,
 		   unsigned int command, int address,
 		   const void *in, void *out, size_t len)
 {
-	struct efx_nic *efx = spi->efx;
 	bool addressed = (address >= 0);
 	bool reading = (out != NULL);
 	efx_oword_t reg;
@@ -1747,27 +340,27 @@ int falcon_spi_cmd(const struct efx_spi_
 
 	/* Program address register, if we have an address */
 	if (addressed) {
-		EFX_POPULATE_OWORD_1(reg, EE_SPI_HADR_ADR, address);
-		falcon_write(efx, &reg, EE_SPI_HADR_REG_KER);
+		EFX_POPULATE_OWORD_1(reg, FRF_AB_EE_SPI_HADR_ADR, address);
+		efx_writeo(efx, &reg, FR_AB_EE_SPI_HADR);
 	}
 
 	/* Program data register, if we have data */
 	if (in != NULL) {
 		memcpy(&reg, in, len);
-		falcon_write(efx, &reg, EE_SPI_HDATA_REG_KER);
+		efx_writeo(efx, &reg, FR_AB_EE_SPI_HDATA);
 	}
 
 	/* Issue read/write command */
 	EFX_POPULATE_OWORD_7(reg,
-			     EE_SPI_HCMD_CMD_EN, 1,
-			     EE_SPI_HCMD_SF_SEL, spi->device_id,
-			     EE_SPI_HCMD_DABCNT, len,
-			     EE_SPI_HCMD_READ, reading,
-			     EE_SPI_HCMD_DUBCNT, 0,
-			     EE_SPI_HCMD_ADBCNT,
+			     FRF_AB_EE_SPI_HCMD_CMD_EN, 1,
+			     FRF_AB_EE_SPI_HCMD_SF_SEL, spi->device_id,
+			     FRF_AB_EE_SPI_HCMD_DABCNT, len,
+			     FRF_AB_EE_SPI_HCMD_READ, reading,
+			     FRF_AB_EE_SPI_HCMD_DUBCNT, 0,
+			     FRF_AB_EE_SPI_HCMD_ADBCNT,
 			     (addressed ? spi->addr_len : 0),
-			     EE_SPI_HCMD_ENC, command);
-	falcon_write(efx, &reg, EE_SPI_HCMD_REG_KER);
+			     FRF_AB_EE_SPI_HCMD_ENC, command);
+	efx_writeo(efx, &reg, FR_AB_EE_SPI_HCMD);
 
 	/* Wait for read/write to complete */
 	rc = falcon_spi_wait(efx);
@@ -1776,7 +369,7 @@ int falcon_spi_cmd(const struct efx_spi_
 
 	/* Read data */
 	if (out != NULL) {
-		falcon_read(efx, &reg, EE_SPI_HDATA_REG_KER);
+		efx_reado(efx, &reg, FR_AB_EE_SPI_HDATA);
 		memcpy(out, &reg, len);
 	}
 
@@ -1798,32 +391,33 @@ efx_spi_munge_command(const struct efx_s
 }
 
 /* Wait up to 10 ms for buffered write completion */
-int falcon_spi_wait_write(const struct efx_spi_device *spi)
+int
+falcon_spi_wait_write(struct efx_nic *efx, const struct efx_spi_device *spi)
 {
-	struct efx_nic *efx = spi->efx;
 	unsigned long timeout = jiffies + 1 + DIV_ROUND_UP(HZ, 100);
 	u8 status;
 	int rc;
 
 	for (;;) {
-		rc = falcon_spi_cmd(spi, SPI_RDSR, -1, NULL,
+		rc = falcon_spi_cmd(efx, spi, SPI_RDSR, -1, NULL,
 				    &status, sizeof(status));
 		if (rc)
 			return rc;
 		if (!(status & SPI_STATUS_NRDY))
 			return 0;
 		if (time_after_eq(jiffies, timeout)) {
-			EFX_ERR(efx, "SPI write timeout on device %d"
-				" last status=0x%02x\n",
-				spi->device_id, status);
+			netif_err(efx, hw, efx->net_dev,
+				  "SPI write timeout on device %d"
+				  " last status=0x%02x\n",
+				  spi->device_id, status);
 			return -ETIMEDOUT;
 		}
 		schedule_timeout_uninterruptible(1);
 	}
 }
 
-int falcon_spi_read(const struct efx_spi_device *spi, loff_t start,
-		    size_t len, size_t *retlen, u8 *buffer)
+int falcon_spi_read(struct efx_nic *efx, const struct efx_spi_device *spi,
+		    loff_t start, size_t len, size_t *retlen, u8 *buffer)
 {
 	size_t block_len, pos = 0;
 	unsigned int command;
@@ -1833,7 +427,7 @@ int falcon_spi_read(const struct efx_spi
 		block_len = min(len - pos, FALCON_SPI_MAX_LEN);
 
 		command = efx_spi_munge_command(spi, SPI_READ, start + pos);
-		rc = falcon_spi_cmd(spi, command, start + pos, NULL,
+		rc = falcon_spi_cmd(efx, spi, command, start + pos, NULL,
 				    buffer + pos, block_len);
 		if (rc)
 			break;
@@ -1852,8 +446,9 @@ int falcon_spi_read(const struct efx_spi
 	return rc;
 }
 
-int falcon_spi_write(const struct efx_spi_device *spi, loff_t start,
-		     size_t len, size_t *retlen, const u8 *buffer)
+int
+falcon_spi_write(struct efx_nic *efx, const struct efx_spi_device *spi,
+		 loff_t start, size_t len, size_t *retlen, const u8 *buffer)
 {
 	u8 verify_buffer[FALCON_SPI_MAX_LEN];
 	size_t block_len, pos = 0;
@@ -1861,24 +456,24 @@ int falcon_spi_write(const struct efx_sp
 	int rc = 0;
 
 	while (pos < len) {
-		rc = falcon_spi_cmd(spi, SPI_WREN, -1, NULL, NULL, 0);
+		rc = falcon_spi_cmd(efx, spi, SPI_WREN, -1, NULL, NULL, 0);
 		if (rc)
 			break;
 
 		block_len = min(len - pos,
 				falcon_spi_write_limit(spi, start + pos));
 		command = efx_spi_munge_command(spi, SPI_WRITE, start + pos);
-		rc = falcon_spi_cmd(spi, command, start + pos,
+		rc = falcon_spi_cmd(efx, spi, command, start + pos,
 				    buffer + pos, NULL, block_len);
 		if (rc)
 			break;
 
-		rc = falcon_spi_wait_write(spi);
+		rc = falcon_spi_wait_write(efx, spi);
 		if (rc)
 			break;
 
 		command = efx_spi_munge_command(spi, SPI_READ, start + pos);
-		rc = falcon_spi_cmd(spi, command, start + pos,
+		rc = falcon_spi_cmd(efx, spi, command, start + pos,
 				    NULL, verify_buffer, block_len);
 		if (memcmp(verify_buffer, buffer + pos, block_len)) {
 			rc = -EIO;
@@ -1907,200 +502,264 @@ int falcon_spi_write(const struct efx_sp
  **************************************************************************
  */
 
-static int falcon_reset_macs(struct efx_nic *efx)
+static void falcon_push_multicast_hash(struct efx_nic *efx)
 {
-	efx_oword_t reg;
+	union efx_multicast_hash *mc_hash = &efx->multicast_hash;
+
+	WARN_ON(!mutex_is_locked(&efx->mac_lock));
+
+	efx_writeo(efx, &mc_hash->oword[0], FR_AB_MAC_MC_HASH_REG0);
+	efx_writeo(efx, &mc_hash->oword[1], FR_AB_MAC_MC_HASH_REG1);
+}
+
+static void falcon_reset_macs(struct efx_nic *efx)
+{
+	struct falcon_nic_data *nic_data = efx->nic_data;
+	efx_oword_t reg, mac_ctrl;
 	int count;
 
-	if (falcon_rev(efx) < FALCON_REV_B0) {
+	if (efx_nic_rev(efx) < EFX_REV_FALCON_B0) {
 		/* It's not safe to use GLB_CTL_REG to reset the
 		 * macs, so instead use the internal MAC resets
 		 */
-		if (!EFX_IS10G(efx)) {
-			EFX_POPULATE_OWORD_1(reg, GM_SW_RST, 1);
-			falcon_write(efx, &reg, GM_CFG1_REG);
-			udelay(1000);
+		EFX_POPULATE_OWORD_1(reg, FRF_AB_XM_CORE_RST, 1);
+		efx_writeo(efx, &reg, FR_AB_XM_GLB_CFG);
 
-			EFX_POPULATE_OWORD_1(reg, GM_SW_RST, 0);
-			falcon_write(efx, &reg, GM_CFG1_REG);
-			udelay(1000);
-			return 0;
-		} else {
-			EFX_POPULATE_OWORD_1(reg, XM_CORE_RST, 1);
-			falcon_write(efx, &reg, XM_GLB_CFG_REG);
+		for (count = 0; count < 10000; count++) {
+			efx_reado(efx, &reg, FR_AB_XM_GLB_CFG);
+			if (EFX_OWORD_FIELD(reg, FRF_AB_XM_CORE_RST) ==
+			    0)
+				return;
+			udelay(10);
+		}
 
-			for (count = 0; count < 10000; count++) {
-				falcon_read(efx, &reg, XM_GLB_CFG_REG);
-				if (EFX_OWORD_FIELD(reg, XM_CORE_RST) == 0)
-					return 0;
-				udelay(10);
-			}
-
-			EFX_ERR(efx, "timed out waiting for XMAC core reset\n");
-			return -ETIMEDOUT;
-		}
+		EFX_FATAL(efx, hw, efx->net_dev,
+			  "timed out waiting for XMAC core reset\n");
 	}
 
-	/* MAC stats will fail whilst the TX fifo is draining. Serialise
-	 * the drain sequence with the statistics fetch */
-	efx_stats_disable(efx);
+	/* Mac stats will fail whist the TX fifo is draining */
+	WARN_ON(nic_data->stats_disable_count == 0);
 
-	falcon_read(efx, &reg, MAC0_CTRL_REG_KER);
-	EFX_SET_OWORD_FIELD(reg, TXFIFO_DRAIN_EN_B0, 1);
-	falcon_write(efx, &reg, MAC0_CTRL_REG_KER);
+	efx_reado(efx, &mac_ctrl, FR_AB_MAC_CTRL);
+	EFX_SET_OWORD_FIELD(mac_ctrl, FRF_BB_TXFIFO_DRAIN_EN, 1);
+	efx_writeo(efx, &mac_ctrl, FR_AB_MAC_CTRL);
 
-	falcon_read(efx, &reg, GLB_CTL_REG_KER);
-	EFX_SET_OWORD_FIELD(reg, RST_XGTX, 1);
-	EFX_SET_OWORD_FIELD(reg, RST_XGRX, 1);
-	EFX_SET_OWORD_FIELD(reg, RST_EM, 1);
-	falcon_write(efx, &reg, GLB_CTL_REG_KER);
+	efx_reado(efx, &reg, FR_AB_GLB_CTL);
+	EFX_SET_OWORD_FIELD(reg, FRF_AB_RST_XGTX, 1);
+	EFX_SET_OWORD_FIELD(reg, FRF_AB_RST_XGRX, 1);
+	EFX_SET_OWORD_FIELD(reg, FRF_AB_RST_EM, 1);
+	efx_writeo(efx, &reg, FR_AB_GLB_CTL);
 
 	count = 0;
 	while (1) {
-		falcon_read(efx, &reg, GLB_CTL_REG_KER);
-		if (!EFX_OWORD_FIELD(reg, RST_XGTX) &&
-		    !EFX_OWORD_FIELD(reg, RST_XGRX) &&
-		    !EFX_OWORD_FIELD(reg, RST_EM)) {
-			EFX_LOG(efx, "Completed MAC reset after %d loops\n",
-				count);
+		efx_reado(efx, &reg, FR_AB_GLB_CTL);
+		if (!EFX_OWORD_FIELD(reg, FRF_AB_RST_XGTX) &&
+		    !EFX_OWORD_FIELD(reg, FRF_AB_RST_XGRX) &&
+		    !EFX_OWORD_FIELD(reg, FRF_AB_RST_EM)) {
+			netif_dbg(efx, hw, efx->net_dev,
+				  "Completed MAC reset after %d loops\n",
+				  count);
 			break;
 		}
 		if (count > 20) {
-			EFX_ERR(efx, "MAC reset failed\n");
+			EFX_FATAL(efx, hw, efx->net_dev, "MAC reset failed\n");
 			break;
 		}
 		count++;
 		udelay(10);
 	}
 
-	efx_stats_enable(efx);
+	/* Ensure the correct MAC is selected before statistics
+	 * are re-enabled by the caller */
+	efx_writeo(efx, &mac_ctrl, FR_AB_MAC_CTRL);
 
-	/* If we've reset the EM block and the link is up, then
-	 * we'll have to kick the XAUI link so the PHY can recover */
-	if (efx->link_up && EFX_IS10G(efx) && EFX_WORKAROUND_5147(efx))
-		falcon_reset_xaui(efx);
-
-	return 0;
+	falcon_setup_xaui(efx);
 }
 
 void falcon_drain_tx_fifo(struct efx_nic *efx)
 {
 	efx_oword_t reg;
 
-	if ((falcon_rev(efx) < FALCON_REV_B0) ||
+	if ((efx_nic_rev(efx) < EFX_REV_FALCON_B0) ||
 	    (efx->loopback_mode != LOOPBACK_NONE))
 		return;
 
-	falcon_read(efx, &reg, MAC0_CTRL_REG_KER);
+	efx_reado(efx, &reg, FR_AB_MAC_CTRL);
 	/* There is no point in draining more than once */
-	if (EFX_OWORD_FIELD(reg, TXFIFO_DRAIN_EN_B0))
+	if (EFX_OWORD_FIELD(reg, FRF_BB_TXFIFO_DRAIN_EN))
 		return;
 
 	falcon_reset_macs(efx);
 }
 
-void falcon_deconfigure_mac_wrapper(struct efx_nic *efx)
+static void falcon_deconfigure_mac_wrapper(struct efx_nic *efx)
 {
 	efx_oword_t reg;
 
-	if (falcon_rev(efx) < FALCON_REV_B0)
+	if (efx_nic_rev(efx) < EFX_REV_FALCON_B0)
 		return;
 
 	/* Isolate the MAC -> RX */
-	falcon_read(efx, &reg, RX_CFG_REG_KER);
-	EFX_SET_OWORD_FIELD(reg, RX_INGR_EN_B0, 0);
-	falcon_write(efx, &reg, RX_CFG_REG_KER);
+	efx_reado(efx, &reg, FR_AZ_RX_CFG);
+	EFX_SET_OWORD_FIELD(reg, FRF_BZ_RX_INGR_EN, 0);
+	efx_writeo(efx, &reg, FR_AZ_RX_CFG);
 
-	if (!efx->link_up)
-		falcon_drain_tx_fifo(efx);
+	/* Isolate TX -> MAC */
+	falcon_drain_tx_fifo(efx);
 }
 
 void falcon_reconfigure_mac_wrapper(struct efx_nic *efx)
 {
+	struct efx_link_state *link_state = &efx->link_state;
 	efx_oword_t reg;
-	int link_speed;
-	bool tx_fc;
+	int link_speed, isolate;
 
-	switch (efx->link_speed) {
+	isolate = (efx->reset_pending != RESET_TYPE_NONE);
+
+	switch (link_state->speed) {
 	case 10000: link_speed = 3; break;
 	case 1000:  link_speed = 2; break;
 	case 100:   link_speed = 1; break;
 	default:    link_speed = 0; break;
 	}
+
 	/* MAC_LINK_STATUS controls MAC backpressure but doesn't work
 	 * as advertised.  Disable to ensure packets are not
 	 * indefinitely held and TX queue can be flushed at any point
 	 * while the link is down. */
 	EFX_POPULATE_OWORD_5(reg,
-			     MAC_XOFF_VAL, 0xffff /* max pause time */,
-			     MAC_BCAD_ACPT, 1,
-			     MAC_UC_PROM, efx->promiscuous,
-			     MAC_LINK_STATUS, 1, /* always set */
-			     MAC_SPEED, link_speed);
+			     FRF_AB_MAC_XOFF_VAL, 0xffff /* max pause time */,
+			     FRF_AB_MAC_BCAD_ACPT, 1,
+			     FRF_AB_MAC_UC_PROM, efx->promiscuous,
+			     FRF_AB_MAC_LINK_STATUS, 1, /* always set */
+			     FRF_AB_MAC_SPEED, link_speed);
 	/* On B0, MAC backpressure can be disabled and packets get
 	 * discarded. */
-	if (falcon_rev(efx) >= FALCON_REV_B0) {
-		EFX_SET_OWORD_FIELD(reg, TXFIFO_DRAIN_EN_B0,
-				    !efx->link_up);
+	if (efx_nic_rev(efx) >= EFX_REV_FALCON_B0) {
+		EFX_SET_OWORD_FIELD(reg, FRF_BB_TXFIFO_DRAIN_EN,
+				    !link_state->up || isolate);
 	}
 
-	falcon_write(efx, &reg, MAC0_CTRL_REG_KER);
+	efx_writeo(efx, &reg, FR_AB_MAC_CTRL);
 
 	/* Restore the multicast hash registers. */
-	falcon_set_multicast_hash(efx);
+	falcon_push_multicast_hash(efx);
 
-	/* Transmission of pause frames when RX crosses the threshold is
-	 * covered by RX_XOFF_MAC_EN and XM_TX_CFG_REG:XM_FCNTL.
-	 * Action on receipt of pause frames is controller by XM_DIS_FCNTL */
-	tx_fc = !!(efx->link_fc & EFX_FC_TX);
-	falcon_read(efx, &reg, RX_CFG_REG_KER);
-	EFX_SET_OWORD_FIELD_VER(efx, reg, RX_XOFF_MAC_EN, tx_fc);
-
+	efx_reado(efx, &reg, FR_AZ_RX_CFG);
+	/* Enable XOFF signal from RX FIFO (we enabled it during NIC
+	 * initialisation but it may read back as 0) */
+	EFX_SET_OWORD_FIELD(reg, FRF_AZ_RX_XOFF_MAC_EN, 1);
 	/* Unisolate the MAC -> RX */
-	if (falcon_rev(efx) >= FALCON_REV_B0)
-		EFX_SET_OWORD_FIELD(reg, RX_INGR_EN_B0, 1);
-	falcon_write(efx, &reg, RX_CFG_REG_KER);
+	if (efx_nic_rev(efx) >= EFX_REV_FALCON_B0)
+		EFX_SET_OWORD_FIELD(reg, FRF_BZ_RX_INGR_EN, !isolate);
+	efx_writeo(efx, &reg, FR_AZ_RX_CFG);
 }
 
-int falcon_dma_stats(struct efx_nic *efx, unsigned int done_offset)
+static void falcon_stats_request(struct efx_nic *efx)
 {
+	struct falcon_nic_data *nic_data = efx->nic_data;
 	efx_oword_t reg;
-	u32 *dma_done;
-	int i;
 
-	if (disable_dma_stats)
-		return 0;
+	WARN_ON(nic_data->stats_pending);
+	WARN_ON(nic_data->stats_disable_count);
 
-	/* Statistics fetch will fail if the MAC is in TX drain */
-	if (falcon_rev(efx) >= FALCON_REV_B0) {
-		efx_oword_t temp;
-		falcon_read(efx, &temp, MAC0_CTRL_REG_KER);
-		if (EFX_OWORD_FIELD(temp, TXFIFO_DRAIN_EN_B0))
-			return 0;
-	}
+	if (nic_data->stats_dma_done == NULL)
+		return;	/* no mac selected */
 
-	dma_done = (efx->stats_buffer.addr + done_offset);
-	*dma_done = FALCON_STATS_NOT_DONE;
+	*nic_data->stats_dma_done = FALCON_STATS_NOT_DONE;
+	nic_data->stats_pending = true;
 	wmb(); /* ensure done flag is clear */
 
 	/* Initiate DMA transfer of stats */
 	EFX_POPULATE_OWORD_2(reg,
-			     MAC_STAT_DMA_CMD, 1,
-			     MAC_STAT_DMA_ADR,
+			     FRF_AB_MAC_STAT_DMA_CMD, 1,
+			     FRF_AB_MAC_STAT_DMA_ADR,
 			     efx->stats_buffer.dma_addr);
-	falcon_write(efx, &reg, MAC0_STAT_DMA_REG_KER);
+	efx_writeo(efx, &reg, FR_AB_MAC_STAT_DMA);
 
-	/* Wait for transfer to complete */
-	for (i = 0; i < 400; i++) {
-		if (*(volatile u32 *)dma_done == FALCON_STATS_DONE) {
-			rmb(); /* Ensure the stats are valid. */
-			return 0;
-		}
-		udelay(10);
+#if !defined(EFX_USE_KCOMPAT) || defined(EFX_HAVE_ROUND_JIFFIES_UP)
+	mod_timer(&nic_data->stats_timer, round_jiffies_up(jiffies + HZ / 2));
+#else
+	mod_timer(&nic_data->stats_timer, jiffies + HZ);
+#endif
+}
+
+static void falcon_stats_complete(struct efx_nic *efx)
+{
+	struct falcon_nic_data *nic_data = efx->nic_data;
+
+	if (!nic_data->stats_pending)
+		return;
+
+	nic_data->stats_pending = 0;
+	if (*nic_data->stats_dma_done == FALCON_STATS_DONE) {
+		rmb(); /* read the done flag before the stats */
+		efx->mac_op->update_stats(efx);
+	} else {
+		EFX_FATAL(efx, hw, efx->net_dev,
+			  "timed out waiting for statistics\n");
 	}
+}
 
-	EFX_ERR(efx, "timed out waiting for statistics\n");
-	return -ETIMEDOUT;
+static void falcon_stats_timer_func(unsigned long context)
+{
+	struct efx_nic *efx = (struct efx_nic *)context;
+	struct falcon_nic_data *nic_data = efx->nic_data;
+
+	spin_lock(&efx->stats_lock);
+
+	falcon_stats_complete(efx);
+	if (nic_data->stats_disable_count == 0)
+		falcon_stats_request(efx);
+
+	spin_unlock(&efx->stats_lock);
+}
+
+static bool falcon_loopback_link_poll(struct efx_nic *efx)
+{
+	struct efx_link_state old_state = efx->link_state;
+
+	WARN_ON(!mutex_is_locked(&efx->mac_lock));
+	WARN_ON(!LOOPBACK_INTERNAL(efx));
+
+	efx->link_state.fd = true;
+	efx->link_state.fc = efx->wanted_fc;
+	efx->link_state.up = true;
+	efx->link_state.speed = 10000;
+
+	return !efx_link_state_equal(&efx->link_state, &old_state);
+}
+
+static int falcon_reconfigure_port(struct efx_nic *efx)
+{
+	int rc;
+
+	WARN_ON(efx_nic_rev(efx) > EFX_REV_FALCON_B0);
+
+	/* Poll the PHY link state *before* reconfiguring it. This means we
+	 * will pick up the correct speed (in loopback) to select the correct
+	 * MAC.
+	 */
+	if (LOOPBACK_INTERNAL(efx))
+		falcon_loopback_link_poll(efx);
+	else
+		efx->phy_op->poll(efx);
+
+	falcon_stop_nic_stats(efx);
+	falcon_deconfigure_mac_wrapper(efx);
+
+	falcon_reset_macs(efx);
+
+	efx->phy_op->reconfigure(efx);
+	rc = efx->mac_op->reconfigure(efx);
+	BUG_ON(rc);
+
+	falcon_start_nic_stats(efx);
+
+	/* Synchronise efx->link_state with the kernel */
+	efx_link_status_changed(efx);
+
+	return 0;
 }
 
 /**************************************************************************
@@ -2113,25 +772,26 @@ int falcon_dma_stats(struct efx_nic *efx
 /* Wait for GMII access to complete */
 static int falcon_gmii_wait(struct efx_nic *efx)
 {
-	efx_dword_t md_stat;
+	efx_oword_t md_stat;
 	int count;
 
 	/* wait upto 50ms - taken max from datasheet */
 	for (count = 0; count < 5000; count++) {
-		falcon_readl(efx, &md_stat, MD_STAT_REG_KER);
-		if (EFX_DWORD_FIELD(md_stat, MD_BSY) == 0) {
-			if (EFX_DWORD_FIELD(md_stat, MD_LNFL) != 0 ||
-			    EFX_DWORD_FIELD(md_stat, MD_BSERR) != 0) {
-				EFX_ERR(efx, "error from GMII access "
-					EFX_DWORD_FMT"\n",
-					EFX_DWORD_VAL(md_stat));
+		efx_reado(efx, &md_stat, FR_AB_MD_STAT);
+		if (EFX_OWORD_FIELD(md_stat, FRF_AB_MD_BSY) == 0) {
+			if (EFX_OWORD_FIELD(md_stat, FRF_AB_MD_LNFL) != 0 ||
+			    EFX_OWORD_FIELD(md_stat, FRF_AB_MD_BSERR) != 0) {
+				netif_err(efx, hw, efx->net_dev,
+					  "error from GMII access "
+					  EFX_OWORD_FMT"\n",
+					  EFX_OWORD_VAL(md_stat));
 				return -EIO;
 			}
 			return 0;
 		}
 		udelay(10);
 	}
-	EFX_ERR(efx, "timed out waiting for GMII\n");
+	netif_err(efx, hw, efx->net_dev, "timed out waiting for GMII\n");
 	return -ETIMEDOUT;
 }
 
@@ -2143,10 +803,11 @@ static int falcon_mdio_write(struct net_
 	efx_oword_t reg;
 	int rc;
 
-	EFX_REGDUMP(efx, "writing MDIO %d register %d.%d with 0x%04x\n",
+	netif_vdbg(efx, hw, efx->net_dev,
+		   "writing MDIO %d register %d.%d with 0x%04x\n",
 		    prtad, devad, addr, value);
 
-	spin_lock_bh(&efx->phy_lock);
+	mutex_lock(&efx->mdio_lock);
 
 	/* Check MDIO not currently being accessed */
 	rc = falcon_gmii_wait(efx);
@@ -2154,34 +815,35 @@ static int falcon_mdio_write(struct net_
 		goto out;
 
 	/* Write the address/ID register */
-	EFX_POPULATE_OWORD_1(reg, MD_PHY_ADR, addr);
-	falcon_write(efx, &reg, MD_PHY_ADR_REG_KER);
+	EFX_POPULATE_OWORD_1(reg, FRF_AB_MD_PHY_ADR, addr);
+	efx_writeo(efx, &reg, FR_AB_MD_PHY_ADR);
 
-	EFX_POPULATE_OWORD_2(reg, MD_PRT_ADR, prtad, MD_DEV_ADR, devad);
-	falcon_write(efx, &reg, MD_ID_REG_KER);
+	EFX_POPULATE_OWORD_2(reg, FRF_AB_MD_PRT_ADR, prtad,
+			     FRF_AB_MD_DEV_ADR, devad);
+	efx_writeo(efx, &reg, FR_AB_MD_ID);
 
 	/* Write data */
-	EFX_POPULATE_OWORD_1(reg, MD_TXD, value);
-	falcon_write(efx, &reg, MD_TXD_REG_KER);
+	EFX_POPULATE_OWORD_1(reg, FRF_AB_MD_TXD, value);
+	efx_writeo(efx, &reg, FR_AB_MD_TXD);
 
 	EFX_POPULATE_OWORD_2(reg,
-			     MD_WRC, 1,
-			     MD_GC, 0);
-	falcon_write(efx, &reg, MD_CS_REG_KER);
+			     FRF_AB_MD_WRC, 1,
+			     FRF_AB_MD_GC, 0);
+	efx_writeo(efx, &reg, FR_AB_MD_CS);
 
 	/* Wait for data to be written */
 	rc = falcon_gmii_wait(efx);
 	if (rc) {
 		/* Abort the write operation */
 		EFX_POPULATE_OWORD_2(reg,
-				     MD_WRC, 0,
-				     MD_GC, 1);
-		falcon_write(efx, &reg, MD_CS_REG_KER);
+				     FRF_AB_MD_WRC, 0,
+				     FRF_AB_MD_GC, 1);
+		efx_writeo(efx, &reg, FR_AB_MD_CS);
 		udelay(10);
 	}
 
- out:
-	spin_unlock_bh(&efx->phy_lock);
+out:
+	mutex_unlock(&efx->mdio_lock);
 	return rc;
 }
 
@@ -2193,188 +855,118 @@ static int falcon_mdio_read(struct net_d
 	efx_oword_t reg;
 	int rc;
 
-	spin_lock_bh(&efx->phy_lock);
+	mutex_lock(&efx->mdio_lock);
 
 	/* Check MDIO not currently being accessed */
 	rc = falcon_gmii_wait(efx);
 	if (rc)
 		goto out;
 
-	EFX_POPULATE_OWORD_1(reg, MD_PHY_ADR, addr);
-	falcon_write(efx, &reg, MD_PHY_ADR_REG_KER);
+	EFX_POPULATE_OWORD_1(reg, FRF_AB_MD_PHY_ADR, addr);
+	efx_writeo(efx, &reg, FR_AB_MD_PHY_ADR);
 
-	EFX_POPULATE_OWORD_2(reg, MD_PRT_ADR, prtad, MD_DEV_ADR, devad);
-	falcon_write(efx, &reg, MD_ID_REG_KER);
+	EFX_POPULATE_OWORD_2(reg, FRF_AB_MD_PRT_ADR, prtad,
+			     FRF_AB_MD_DEV_ADR, devad);
+	efx_writeo(efx, &reg, FR_AB_MD_ID);
 
 	/* Request data to be read */
-	EFX_POPULATE_OWORD_2(reg, MD_RDC, 1, MD_GC, 0);
-	falcon_write(efx, &reg, MD_CS_REG_KER);
+	EFX_POPULATE_OWORD_2(reg, FRF_AB_MD_RDC, 1, FRF_AB_MD_GC, 0);
+	efx_writeo(efx, &reg, FR_AB_MD_CS);
 
 	/* Wait for data to become available */
 	rc = falcon_gmii_wait(efx);
 	if (rc == 0) {
-		falcon_read(efx, &reg, MD_RXD_REG_KER);
-		rc = EFX_OWORD_FIELD(reg, MD_RXD);
-		EFX_REGDUMP(efx, "read from MDIO %d register %d.%d, got %04x\n",
-			    prtad, devad, addr, rc);
+		efx_reado(efx, &reg, FR_AB_MD_RXD);
+		rc = EFX_OWORD_FIELD(reg, FRF_AB_MD_RXD);
+		netif_vdbg(efx, hw, efx->net_dev,
+			   "read from MDIO %d register %d.%d, got %04x\n",
+			   prtad, devad, addr, rc);
 	} else {
 		/* Abort the read operation */
 		EFX_POPULATE_OWORD_2(reg,
-				     MD_RIC, 0,
-				     MD_GC, 1);
-		falcon_write(efx, &reg, MD_CS_REG_KER);
+				     FRF_AB_MD_RIC, 0,
+				     FRF_AB_MD_GC, 1);
+		efx_writeo(efx, &reg, FR_AB_MD_CS);
 
-		EFX_LOG(efx, "read from MDIO %d register %d.%d, got error %d\n",
-			prtad, devad, addr, rc);
+		netif_dbg(efx, hw, efx->net_dev,
+			  "read from MDIO %d register %d.%d, got error %d\n",
+			  prtad, devad, addr, rc);
 	}
 
- out:
-	spin_unlock_bh(&efx->phy_lock);
+out:
+	mutex_unlock(&efx->mdio_lock);
 	return rc;
 }
 
-static int falcon_probe_phy(struct efx_nic *efx)
+/* This call is responsible for hooking in the MAC and PHY operations */
+static int falcon_probe_port(struct efx_nic *efx)
 {
+	struct falcon_nic_data *nic_data = efx->nic_data;
+	int rc;
+
+	/* Hook in PHY operations table */
 	switch (efx->phy_type) {
 	case PHY_TYPE_SFX7101:
 		efx->phy_op = &falcon_sfx7101_phy_ops;
 		break;
-	case PHY_TYPE_SFT9001A:
-	case PHY_TYPE_SFT9001B:
-		efx->phy_op = &falcon_sft9001_phy_ops;
-		break;
 	case PHY_TYPE_QT2022C2:
 	case PHY_TYPE_QT2025C:
-		efx->phy_op = &falcon_xfp_phy_ops;
+		efx->phy_op = &falcon_qt202x_phy_ops;
 		break;
+	case PHY_TYPE_TXC43128:
+		efx->phy_op = &falcon_txc_phy_ops;
+		break;
+#ifdef EFX_NOT_UPSTREAM
+	case PHY_TYPE_NONE:
+		/* Keep dummy operations */
+		efx->loopback_modes = FALCON_XMAC_LOOPBACKS;
+		break;
+#endif
 	default:
-		EFX_ERR(efx, "Unknown PHY type %d\n",
-			efx->phy_type);
-		return -1;
+		netif_err(efx, probe, efx->net_dev, "Unknown PHY type %d\n",
+			  efx->phy_type);
+		return -ENODEV;
 	}
 
-	if (efx->phy_op->macs & EFX_XMAC)
-		efx->loopback_modes |= ((1 << LOOPBACK_XGMII) |
-					(1 << LOOPBACK_XGXS) |
-					(1 << LOOPBACK_XAUI));
-	if (efx->phy_op->macs & EFX_GMAC)
-		efx->loopback_modes |= (1 << LOOPBACK_GMAC);
-	efx->loopback_modes |= efx->phy_op->loopbacks;
+	/* Fill out MDIO structure and loopback modes */
+	efx->mdio.mdio_read = falcon_mdio_read;
+	efx->mdio.mdio_write = falcon_mdio_write;
+	rc = efx->phy_op->probe(efx);
+	if (rc != 0)
+		return rc;
+
+	/* Initial assumption */
+	efx->link_state.speed = 10000;
+	efx->link_state.fd = true;
+
+	/* Hardware flow ctrl. FalconA RX FIFO too small for pause generation */
+	if (efx_nic_rev(efx) >= EFX_REV_FALCON_B0)
+		efx->wanted_fc = EFX_FC_RX | EFX_FC_TX;
+	else
+		efx->wanted_fc = EFX_FC_RX;
+	if (efx->mdio.mmds & MDIO_DEVS_AN)
+		efx->wanted_fc |= EFX_FC_AUTO;
+
+	/* Allocate buffer for stats */
+	rc = efx_nic_alloc_buffer(efx, &efx->stats_buffer,
+				  FALCON_MAC_STATS_SIZE);
+	if (rc)
+		return rc;
+	netif_dbg(efx, probe, efx->net_dev,
+		  "stats buffer at %llx (virt %p phys %llx)\n",
+		  (u64)efx->stats_buffer.dma_addr,
+		  efx->stats_buffer.addr,
+		  (u64)virt_to_phys(efx->stats_buffer.addr));
+	nic_data->stats_dma_done = efx->stats_buffer.addr + XgDmaDone_offset;
 
 	return 0;
 }
 
-int falcon_switch_mac(struct efx_nic *efx)
+static void falcon_remove_port(struct efx_nic *efx)
 {
-	struct efx_mac_operations *old_mac_op = efx->mac_op;
-	efx_oword_t nic_stat;
-	unsigned strap_val;
-	int rc = 0;
-
-	/* Don't try to fetch MAC stats while we're switching MACs */
-	efx_stats_disable(efx);
-
-	/* Internal loopbacks override the phy speed setting */
-	if (efx->loopback_mode == LOOPBACK_GMAC) {
-		efx->link_speed = 1000;
-		efx->link_fd = true;
-	} else if (LOOPBACK_INTERNAL(efx)) {
-		efx->link_speed = 10000;
-		efx->link_fd = true;
-	}
-
-	WARN_ON(!mutex_is_locked(&efx->mac_lock));
-	efx->mac_op = (EFX_IS10G(efx) ?
-		       &falcon_xmac_operations : &falcon_gmac_operations);
-
-	/* Always push the NIC_STAT_REG setting even if the mac hasn't
-	 * changed, because this function is run post online reset */
-	falcon_read(efx, &nic_stat, NIC_STAT_REG);
-	strap_val = EFX_IS10G(efx) ? 5 : 3;
-	if (falcon_rev(efx) >= FALCON_REV_B0) {
-		EFX_SET_OWORD_FIELD(nic_stat, EE_STRAP_EN, 1);
-		EFX_SET_OWORD_FIELD(nic_stat, EE_STRAP_OVR, strap_val);
-		falcon_write(efx, &nic_stat, NIC_STAT_REG);
-	} else {
-		/* Falcon A1 does not support 1G/10G speed switching
-		 * and must not be used with a PHY that does. */
-		BUG_ON(EFX_OWORD_FIELD(nic_stat, STRAP_PINS) != strap_val);
-	}
-
-	if (old_mac_op == efx->mac_op)
-		goto out;
-
-	EFX_LOG(efx, "selected %cMAC\n", EFX_IS10G(efx) ? 'X' : 'G');
-	/* Not all macs support a mac-level link state */
-	efx->mac_up = true;
-
-	rc = falcon_reset_macs(efx);
-out:
-	efx_stats_enable(efx);
-	return rc;
+	efx->phy_op->remove(efx);
+	efx_nic_free_buffer(efx, &efx->stats_buffer);
 }
-
-/* This call is responsible for hooking in the MAC and PHY operations */
-int falcon_probe_port(struct efx_nic *efx)
-{
-	int rc;
-
-	/* Hook in PHY operations table */
-	rc = falcon_probe_phy(efx);
-	if (rc)
-		return rc;
-
-	/* Set up MDIO structure for PHY */
-	efx->mdio.mmds = efx->phy_op->mmds;
-	efx->mdio.mode_support = MDIO_SUPPORTS_C45 | MDIO_EMULATE_C22;
-	efx->mdio.mdio_read = falcon_mdio_read;
-	efx->mdio.mdio_write = falcon_mdio_write;
-
-	/* Hardware flow ctrl. FalconA RX FIFO too small for pause generation */
-	if (falcon_rev(efx) >= FALCON_REV_B0)
-		efx->wanted_fc = EFX_FC_RX | EFX_FC_TX;
-	else
-		efx->wanted_fc = EFX_FC_RX;
-
-	/* Allocate buffer for stats */
-	rc = falcon_alloc_buffer(efx, &efx->stats_buffer,
-				 FALCON_MAC_STATS_SIZE);
-	if (rc)
-		return rc;
-	EFX_LOG(efx, "stats buffer at %llx (virt %p phys %llx)\n",
-		(u64)efx->stats_buffer.dma_addr,
-		efx->stats_buffer.addr,
-		(u64)virt_to_phys(efx->stats_buffer.addr));
-
-	return 0;
-}
-
-void falcon_remove_port(struct efx_nic *efx)
-{
-	falcon_free_buffer(efx, &efx->stats_buffer);
-}
-
-/**************************************************************************
- *
- * Multicast filtering
- *
- **************************************************************************
- */
-
-void falcon_set_multicast_hash(struct efx_nic *efx)
-{
-	union efx_multicast_hash *mc_hash = &efx->multicast_hash;
-
-	/* Broadcast packets go through the multicast hash filter.
-	 * ether_crc_le() of the broadcast address is 0xbe2612ff
-	 * so we always add bit 0xff to the mask.
-	 */
-	set_bit_le(0xff, mc_hash->byte);
-
-	falcon_write(efx, &mc_hash->oword[0], MAC_MCAST_HASH_REG0_KER);
-	falcon_write(efx, &mc_hash->oword[1], MAC_MCAST_HASH_REG1_KER);
-}
-
 
 /**************************************************************************
  *
@@ -2382,6 +974,8 @@ void falcon_set_multicast_hash(struct ef
  *
  **************************************************************************/
 
+/* Read and verify the correctness of the nvram, optionally returning a copy
+ * of the nvram configuration section if appropriate */
 int falcon_read_nvram(struct efx_nic *efx, struct falcon_nvconfig *nvconfig_out)
 {
 	struct falcon_nvconfig *nvconfig;
@@ -2398,14 +992,14 @@ int falcon_read_nvram(struct efx_nic *ef
 	region = kmalloc(FALCON_NVCONFIG_END, GFP_KERNEL);
 	if (!region)
 		return -ENOMEM;
-	nvconfig = region + NVCONFIG_OFFSET;
+	nvconfig = region + FALCON_NVCONFIG_OFFSET;
 
 	mutex_lock(&efx->spi_lock);
-	rc = falcon_spi_read(spi, 0, FALCON_NVCONFIG_END, NULL, region);
+	rc = falcon_spi_read(efx, spi, 0, FALCON_NVCONFIG_END, NULL, region);
 	mutex_unlock(&efx->spi_lock);
 	if (rc) {
-		EFX_ERR(efx, "Failed to read %s\n",
-			efx->spi_flash ? "flash" : "EEPROM");
+		netif_err(efx, hw, efx->net_dev, "Failed to read %s\n",
+			  efx->spi_flash ? "flash" : "EEPROM");
 		rc = -EIO;
 		goto out;
 	}
@@ -2414,12 +1008,14 @@ int falcon_read_nvram(struct efx_nic *ef
 	struct_ver = le16_to_cpu(nvconfig->board_struct_ver);
 
 	rc = -EINVAL;
-	if (magic_num != NVCONFIG_BOARD_MAGIC_NUM) {
-		EFX_ERR(efx, "NVRAM bad magic 0x%x\n", magic_num);
+	if (magic_num != FALCON_NVCONFIG_BOARD_MAGIC_NUM) {
+		netif_err(efx, hw, efx->net_dev,
+			  "NVRAM bad magic 0x%x\n", magic_num);
 		goto out;
 	}
 	if (struct_ver < 2) {
-		EFX_ERR(efx, "NVRAM has ancient version 0x%x\n", struct_ver);
+		netif_err(efx, hw, efx->net_dev,
+			  "NVRAM has ancient version 0x%x\n", struct_ver);
 		goto out;
 	} else if (struct_ver < 4) {
 		word = &nvconfig->board_magic_num;
@@ -2432,7 +1028,8 @@ int falcon_read_nvram(struct efx_nic *ef
 		csum += le16_to_cpu(*word);
 
 	if (~csum & 0xffff) {
-		EFX_ERR(efx, "NVRAM has incorrect checksum\n");
+		netif_err(efx, hw, efx->net_dev,
+			  "NVRAM has incorrect checksum\n");
 		goto out;
 	}
 
@@ -2445,107 +1042,150 @@ int falcon_read_nvram(struct efx_nic *ef
 	return rc;
 }
 
-/* Registers tested in the falcon register test */
-static struct {
-	unsigned address;
-	efx_oword_t mask;
-} efx_test_registers[] = {
-	{ ADR_REGION_REG_KER,
-	  EFX_OWORD32(0x0001FFFF, 0x0001FFFF, 0x0001FFFF, 0x0001FFFF) },
-	{ RX_CFG_REG_KER,
+static int
+falcon_b0_test_sram(struct efx_nic *efx,
+		    void (*pattern)(unsigned, efx_qword_t *, int, int),
+		    int a, int b)
+{
+	efx_qword_t buf1, buf2;
+	int wptr, rptr, finish, rc = 0;
+	void __iomem *membase;
+
+	/* So we can test the sram allocated to descriptor caches, access
+	 * via SRAM_DBG_REG rather than BUF_FULL_TBL. */
+	BUG_ON(efx->port_enabled);
+	membase = ioremap_nocache(efx->membase_phys + FR_BZ_SRM_DBG,
+				  efx->sram_lim);
+	if (!membase) {
+		netif_err(efx, hw, efx->net_dev, "Unable to map SRAM_DBG\n");
+		return -EIO;
+	}
+
+	finish = efx->sram_lim / sizeof(buf1) - 1;
+
+	/* write and verify the pattern in 64 8-byte chunks, to avoid
+	 * potentially overrunning the sram update fifo */
+	for (rptr = 0, wptr = 0; wptr <= finish; ++wptr) {
+		pattern(wptr, &buf1, a, b);
+		efx_sram_writeq(efx, membase, &buf1, wptr);
+
+		if (((wptr - rptr) < 64) && (wptr < finish))
+			continue;
+
+		for (; rptr <= wptr; ++rptr) {
+			pattern(rptr, &buf1, a, b);
+			efx_sram_readq(efx, membase, &buf2, rptr);
+
+			if (!memcmp(&buf1, &buf2, sizeof(buf1)))
+				continue;
+
+			netif_err(efx, hw, efx->net_dev,
+				  "sram test failed at index 0x%x. wrote "
+				  EFX_QWORD_FMT" read "EFX_QWORD_FMT"\n",
+				  rptr, EFX_QWORD_VAL(buf1),
+				  EFX_QWORD_VAL(buf2));
+			rc = -EIO;
+			goto out_unmap;
+		}
+	}
+
+out_unmap:
+	iounmap(membase);
+
+	return rc;
+}
+
+static int falcon_test_nvram(struct efx_nic *efx)
+{
+	return falcon_read_nvram(efx, NULL);
+}
+
+static const struct efx_nic_register_test falcon_b0_register_tests[] = {
+	{ FR_AZ_ADR_REGION,
+	  EFX_OWORD32(0x0003FFFF, 0x0003FFFF, 0x0003FFFF, 0x0003FFFF) },
+	{ FR_AZ_RX_CFG,
 	  EFX_OWORD32(0xFFFFFFFE, 0x00017FFF, 0x00000000, 0x00000000) },
-	{ TX_CFG_REG_KER,
+	{ FR_AZ_TX_CFG,
 	  EFX_OWORD32(0x7FFF0037, 0x00000000, 0x00000000, 0x00000000) },
-	{ TX_CFG2_REG_KER,
+	{ FR_AZ_TX_RESERVED,
 	  EFX_OWORD32(0xFFFEFE80, 0x1FFFFFFF, 0x020000FE, 0x007FFFFF) },
-	{ MAC0_CTRL_REG_KER,
+	{ FR_AB_MAC_CTRL,
 	  EFX_OWORD32(0xFFFF0000, 0x00000000, 0x00000000, 0x00000000) },
-	{ SRM_TX_DC_CFG_REG_KER,
+	{ FR_AZ_SRM_TX_DC_CFG,
 	  EFX_OWORD32(0x001FFFFF, 0x00000000, 0x00000000, 0x00000000) },
-	{ RX_DC_CFG_REG_KER,
+	{ FR_AZ_RX_DC_CFG,
 	  EFX_OWORD32(0x0000000F, 0x00000000, 0x00000000, 0x00000000) },
-	{ RX_DC_PF_WM_REG_KER,
+	{ FR_AZ_RX_DC_PF_WM,
 	  EFX_OWORD32(0x000003FF, 0x00000000, 0x00000000, 0x00000000) },
-	{ DP_CTRL_REG,
+	{ FR_BZ_DP_CTRL,
 	  EFX_OWORD32(0x00000FFF, 0x00000000, 0x00000000, 0x00000000) },
-	{ GM_CFG2_REG,
+	{ FR_AB_GM_CFG2,
 	  EFX_OWORD32(0x00007337, 0x00000000, 0x00000000, 0x00000000) },
-	{ GMF_CFG0_REG,
+	{ FR_AB_GMF_CFG0,
 	  EFX_OWORD32(0x00001F1F, 0x00000000, 0x00000000, 0x00000000) },
-	{ XM_GLB_CFG_REG,
+	{ FR_AB_XM_GLB_CFG,
 	  EFX_OWORD32(0x00000C68, 0x00000000, 0x00000000, 0x00000000) },
-	{ XM_TX_CFG_REG,
+	{ FR_AB_XM_TX_CFG,
 	  EFX_OWORD32(0x00080164, 0x00000000, 0x00000000, 0x00000000) },
-	{ XM_RX_CFG_REG,
+	{ FR_AB_XM_RX_CFG,
 	  EFX_OWORD32(0x07100A0C, 0x00000000, 0x00000000, 0x00000000) },
-	{ XM_RX_PARAM_REG,
+	{ FR_AB_XM_RX_PARAM,
 	  EFX_OWORD32(0x00001FF8, 0x00000000, 0x00000000, 0x00000000) },
-	{ XM_FC_REG,
+	{ FR_AB_XM_FC,
 	  EFX_OWORD32(0xFFFF0001, 0x00000000, 0x00000000, 0x00000000) },
-	{ XM_ADR_LO_REG,
+	{ FR_AB_XM_ADR_LO,
 	  EFX_OWORD32(0xFFFFFFFF, 0x00000000, 0x00000000, 0x00000000) },
-	{ XX_SD_CTL_REG,
+	{ FR_AB_XX_SD_CTL,
 	  EFX_OWORD32(0x0003FF0F, 0x00000000, 0x00000000, 0x00000000) },
 };
 
-static bool efx_masked_compare_oword(const efx_oword_t *a, const efx_oword_t *b,
-				     const efx_oword_t *mask)
+static const struct efx_nic_table_test falcon_b0_table_tests[] = {
+	{ FR_BZ_RX_FILTER_TBL0, FR_BZ_RX_FILTER_TBL0_STEP,
+	  FR_BZ_RX_FILTER_TBL0_ROWS,
+	  EFX_OWORD32(0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0x000003FF) },
+	{ FR_BB_RX_FILTER_TBL1, FR_BB_RX_FILTER_TBL1_STEP,
+	  FR_BB_RX_FILTER_TBL1_ROWS,
+	  EFX_OWORD32(0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0x000003FF) },
+	{ FR_BZ_RX_DESC_PTR_TBL, FR_BZ_RX_DESC_PTR_TBL_STEP,
+	  FR_BB_RX_DESC_PTR_TBL_ROWS,
+	  EFX_OWORD32(0xFFFFFFFF, 0x0FFFFFFF, 0x01800000, 0x00000000) },
+	{ FR_BZ_TX_DESC_PTR_TBL, FR_BZ_TX_DESC_PTR_TBL_STEP,
+	  FR_BB_TX_DESC_PTR_TBL_ROWS,
+	  EFX_OWORD32(0xFFFFFFFE, 0x0FFFFFFF, 0x0C000000, 0x00000000) },
+};
+
+static int falcon_b0_test_registers(struct efx_nic *efx)
 {
-	return ((a->u64[0] ^ b->u64[0]) & mask->u64[0]) ||
-		((a->u64[1] ^ b->u64[1]) & mask->u64[1]);
+	return efx_nic_test_registers(efx, falcon_b0_register_tests,
+				      ARRAY_SIZE(falcon_b0_register_tests));
 }
 
-int falcon_test_registers(struct efx_nic *efx)
+static int
+falcon_b0_test_memory(struct efx_nic *efx,
+		      void (*pattern)(unsigned, efx_qword_t *, int, int),
+		      int a, int b)
 {
-	unsigned address = 0, i, j;
-	efx_oword_t mask, imask, original, reg, buf;
+	struct falcon_nic_data *nic_data = efx->nic_data;
+	int rc, i;
 
-	/* Falcon should be in loopback to isolate the XMAC from the PHY */
-	WARN_ON(!LOOPBACK_INTERNAL(efx));
+	rc = falcon_b0_test_sram(efx, pattern, a, b);
+	if (rc)
+		return rc;
 
-	for (i = 0; i < ARRAY_SIZE(efx_test_registers); ++i) {
-		address = efx_test_registers[i].address;
-		mask = imask = efx_test_registers[i].mask;
-		EFX_INVERT_OWORD(imask);
+	for (i = 0; i < ARRAY_SIZE(falcon_b0_table_tests); i++) {
+		/* In internal SRAM mode, the odd filter bank is
+		 * remapped as a descriptor cache */
+		if (falcon_b0_table_tests[i].address == FR_BB_RX_FILTER_TBL1 &&
+		    nic_data->sram_config == SRAM_CONFIG_INTERNAL)
+			continue;
 
-		falcon_read(efx, &original, address);
-
-		/* bit sweep on and off */
-		for (j = 0; j < 128; j++) {
-			if (!EFX_EXTRACT_OWORD32(mask, j, j))
-				continue;
-
-			/* Test this testable bit can be set in isolation */
-			EFX_AND_OWORD(reg, original, mask);
-			EFX_SET_OWORD32(reg, j, j, 1);
-
-			falcon_write(efx, &reg, address);
-			falcon_read(efx, &buf, address);
-
-			if (efx_masked_compare_oword(&reg, &buf, &mask))
-				goto fail;
-
-			/* Test this testable bit can be cleared in isolation */
-			EFX_OR_OWORD(reg, original, mask);
-			EFX_SET_OWORD32(reg, j, j, 0);
-
-			falcon_write(efx, &reg, address);
-			falcon_read(efx, &buf, address);
-
-			if (efx_masked_compare_oword(&reg, &buf, &mask))
-				goto fail;
-		}
-
-		falcon_write(efx, &original, address);
+		rc = efx_nic_test_table(efx, &falcon_b0_table_tests[i],
+					pattern, a, b);
+		if (rc)
+			return rc;
 	}
 
 	return 0;
-
-fail:
-	EFX_ERR(efx, "wrote "EFX_OWORD_FMT" read "EFX_OWORD_FMT
-		" at address 0x%x mask "EFX_OWORD_FMT"\n", EFX_OWORD_VAL(reg),
-		EFX_OWORD_VAL(buf), address, EFX_OWORD_VAL(mask));
-	return -EIO;
 }
 
 /**************************************************************************
@@ -2557,80 +1197,97 @@ fail:
 
 /* Resets NIC to known state.  This routine must be called in process
  * context and is allowed to sleep. */
-int falcon_reset_hw(struct efx_nic *efx, enum reset_type method)
+static int falcon_reset_hw(struct efx_nic *efx, enum reset_type method)
 {
 	struct falcon_nic_data *nic_data = efx->nic_data;
 	efx_oword_t glb_ctl_reg_ker;
 	int rc;
 
-	EFX_LOG(efx, "performing hardware reset (%d)\n", method);
+#ifdef EFX_NOT_UPSTREAM
+	if (efx_nic_no_resets) {
+		netif_dbg(efx, hw, efx->net_dev, "skipping hardware reset %s\n",
+			  RESET_TYPE(method));
+		return 0;
+	}
+#endif
+
+	netif_dbg(efx, hw, efx->net_dev, "performing %s hardware reset\n",
+		  RESET_TYPE(method));
 
 	/* Initiate device reset */
 	if (method == RESET_TYPE_WORLD) {
 		rc = pci_save_state(efx->pci_dev);
 		if (rc) {
-			EFX_ERR(efx, "failed to backup PCI state of primary "
-				"function prior to hardware reset\n");
+			netif_err(efx, drv, efx->net_dev,
+				  "failed to backup PCI state of primary "
+				  "function prior to hardware reset\n");
 			goto fail1;
 		}
-		if (FALCON_IS_DUAL_FUNC(efx)) {
+		if (efx_nic_is_dual_func(efx)) {
 			rc = pci_save_state(nic_data->pci_dev2);
 			if (rc) {
-				EFX_ERR(efx, "failed to backup PCI state of "
-					"secondary function prior to "
-					"hardware reset\n");
+				netif_err(efx, drv, efx->net_dev,
+					  "failed to backup PCI state of "
+					  "secondary function prior to "
+					  "hardware reset\n");
 				goto fail2;
 			}
 		}
 
 		EFX_POPULATE_OWORD_2(glb_ctl_reg_ker,
-				     EXT_PHY_RST_DUR, 0x7,
-				     SWRST, 1);
+				     FRF_AB_EXT_PHY_RST_DUR,
+				     FFE_AB_EXT_PHY_RST_DUR_10240US,
+				     FRF_AB_SWRST, 1);
 	} else {
-		int reset_phy = (method == RESET_TYPE_INVISIBLE ?
-				 EXCLUDE_FROM_RESET : 0);
+		EFX_POPULATE_OWORD_7(glb_ctl_reg_ker,
+				     /* exclude PHY from "invisible" reset */
+				     FRF_AB_EXT_PHY_RST_CTL,
+				     method == RESET_TYPE_INVISIBLE,
+				     /* exclude EEPROM/flash and PCIe */
+				     FRF_AB_PCIE_CORE_RST_CTL, 1,
+				     FRF_AB_PCIE_NSTKY_RST_CTL, 1,
+				     FRF_AB_PCIE_SD_RST_CTL, 1,
+				     FRF_AB_EE_RST_CTL, 1,
+				     FRF_AB_EXT_PHY_RST_DUR,
+				     FFE_AB_EXT_PHY_RST_DUR_10240US,
+				     FRF_AB_SWRST, 1);
+	}
+	efx_writeo(efx, &glb_ctl_reg_ker, FR_AB_GLB_CTL);
 
-		EFX_POPULATE_OWORD_7(glb_ctl_reg_ker,
-				     EXT_PHY_RST_CTL, reset_phy,
-				     PCIE_CORE_RST_CTL, EXCLUDE_FROM_RESET,
-				     PCIE_NSTCK_RST_CTL, EXCLUDE_FROM_RESET,
-				     PCIE_SD_RST_CTL, EXCLUDE_FROM_RESET,
-				     EE_RST_CTL, EXCLUDE_FROM_RESET,
-				     EXT_PHY_RST_DUR, 0x7 /* 10ms */,
-				     SWRST, 1);
-	}
-	falcon_write(efx, &glb_ctl_reg_ker, GLB_CTL_REG_KER);
-
-	EFX_LOG(efx, "waiting for hardware reset\n");
+	netif_dbg(efx, hw, efx->net_dev, "waiting for hardware reset\n");
 	schedule_timeout_uninterruptible(HZ / 20);
 
 	/* Restore PCI configuration if needed */
 	if (method == RESET_TYPE_WORLD) {
-		if (FALCON_IS_DUAL_FUNC(efx)) {
+		if (efx_nic_is_dual_func(efx)) {
 			rc = pci_restore_state(nic_data->pci_dev2);
 			if (rc) {
-				EFX_ERR(efx, "failed to restore PCI config for "
-					"the secondary function\n");
+				netif_err(efx, drv, efx->net_dev,
+					  "failed to restore PCI config for "
+					  "the secondary function\n");
 				goto fail3;
 			}
 		}
 		rc = pci_restore_state(efx->pci_dev);
 		if (rc) {
-			EFX_ERR(efx, "failed to restore PCI config for the "
-				"primary function\n");
+			netif_err(efx, drv, efx->net_dev,
+				  "failed to restore PCI config for the "
+				  "primary function\n");
 			goto fail4;
 		}
-		EFX_LOG(efx, "successfully restored PCI config\n");
+		netif_dbg(efx, drv, efx->net_dev,
+			  "successfully restored PCI config\n");
 	}
 
 	/* Assert that reset complete */
-	falcon_read(efx, &glb_ctl_reg_ker, GLB_CTL_REG_KER);
-	if (EFX_OWORD_FIELD(glb_ctl_reg_ker, SWRST) != 0) {
+	efx_reado(efx, &glb_ctl_reg_ker, FR_AB_GLB_CTL);
+	if (EFX_OWORD_FIELD(glb_ctl_reg_ker, FRF_AB_SWRST) != 0) {
 		rc = -ETIMEDOUT;
-		EFX_ERR(efx, "timed out waiting for hardware reset\n");
+		netif_err(efx, hw, efx->net_dev,
+			  "timed out waiting for hardware reset\n");
 		goto fail5;
 	}
-	EFX_LOG(efx, "hardware reset complete\n");
+	netif_dbg(efx, hw, efx->net_dev, "hardware reset complete\n");
 
 	return 0;
 
@@ -2644,47 +1301,95 @@ fail5:
 	return rc;
 }
 
+void falcon_reset_phy(struct efx_nic *efx)
+{
+	efx_oword_t oword;
+
+	BUG_ON(!mutex_is_locked(&efx->mac_lock));
+
+	efx_reado(efx, &oword, FR_AB_GPIO_CTL);
+	EFX_SET_OWORD_FIELD(oword, FRF_AB_GPIO2_OUT, 0);
+	EFX_SET_OWORD_FIELD(oword, FRF_AB_GPIO2_OEN, 1);
+	efx_writeo(efx, &oword, FR_AB_GPIO_CTL);
+
+	msleep(10);
+
+	EFX_SET_OWORD_FIELD(oword, FRF_AB_GPIO2_OEN, 0);
+	efx_writeo(efx, &oword, FR_AB_GPIO_CTL);
+}
+
+static void falcon_monitor(struct efx_nic *efx)
+{
+	bool link_changed;
+	int rc;
+
+	BUG_ON(!mutex_is_locked(&efx->mac_lock));
+
+	rc = falcon_board(efx)->type->monitor(efx);
+	if (rc) {
+		netif_err(efx, hw, efx->net_dev,
+			  "Board sensor %s; shutting down PHY\n",
+			  (rc == -ERANGE) ? "reported fault" : "failed");
+		efx->phy_mode |= PHY_MODE_LOW_POWER;
+		rc = __efx_reconfigure_port(efx);
+		WARN_ON(rc);
+	}
+
+	if (LOOPBACK_INTERNAL(efx))
+		link_changed = falcon_loopback_link_poll(efx);
+	else
+		link_changed = efx->phy_op->poll(efx);
+
+	if (link_changed) {
+		falcon_stop_nic_stats(efx);
+		falcon_deconfigure_mac_wrapper(efx);
+
+		falcon_reset_macs(efx);
+		rc = efx->mac_op->reconfigure(efx);
+		BUG_ON(rc);
+
+		falcon_start_nic_stats(efx);
+
+		efx_link_status_changed(efx);
+	}
+
+	falcon_poll_xmac(efx);
+}
+
 /* Zeroes out the SRAM contents.  This routine must be called in
  * process context and is allowed to sleep.
  */
-static int falcon_reset_sram(struct efx_nic *efx)
+static int falcon_reset_sram(struct efx_nic *efx, int sram_config)
 {
-	struct falcon_nic_data *nic_data = efx->nic_data;
-	efx_oword_t srm_cfg_reg_ker, gpio_cfg_reg_ker;
-	int count, onchip, sram_cfg_val;
-
-	/* Set the SRAM wake/sleep GPIO appropriately. */
-	onchip = (nic_data->sram_cfg == SRM_NB_BSZ_ONCHIP_ONLY);
-	falcon_read(efx, &gpio_cfg_reg_ker, GPIO_CTL_REG_KER);
-	EFX_SET_OWORD_FIELD(gpio_cfg_reg_ker, GPIO1_OEN, 1);
-	EFX_SET_OWORD_FIELD(gpio_cfg_reg_ker, GPIO1_OUT, onchip);
-	falcon_write(efx, &gpio_cfg_reg_ker, GPIO_CTL_REG_KER);
+	efx_oword_t srm_cfg_reg_ker;
+	int count;
 
 	/* Initiate SRAM reset */
-	sram_cfg_val = onchip ? 0 : nic_data->sram_cfg;
 	EFX_POPULATE_OWORD_2(srm_cfg_reg_ker,
-			     SRAM_OOB_BT_INIT_EN, 1,
-			     SRM_NUM_BANKS_AND_BANK_SIZE, sram_cfg_val);
-	falcon_write(efx, &srm_cfg_reg_ker, SRM_CFG_REG_KER);
+			     FRF_AZ_SRM_INIT_EN, 1,
+			     FRF_AZ_SRM_NB_SZ, sram_config);
+	efx_writeo(efx, &srm_cfg_reg_ker, FR_AZ_SRM_CFG);
 
 	/* Wait for SRAM reset to complete */
 	count = 0;
 	do {
-		EFX_LOG(efx, "waiting for SRAM reset (attempt %d)...\n", count);
+		netif_dbg(efx, hw, efx->net_dev,
+			  "waiting for SRAM reset (attempt %d)...\n", count);
 
 		/* SRAM reset is slow; expect around 16ms */
 		schedule_timeout_uninterruptible(HZ / 50);
 
 		/* Check for reset complete */
-		falcon_read(efx, &srm_cfg_reg_ker, SRM_CFG_REG_KER);
-		if (!EFX_OWORD_FIELD(srm_cfg_reg_ker, SRAM_OOB_BT_INIT_EN)) {
-			EFX_LOG(efx, "SRAM reset complete\n");
+		efx_reado(efx, &srm_cfg_reg_ker, FR_AZ_SRM_CFG);
+		if (!EFX_OWORD_FIELD(srm_cfg_reg_ker, FRF_AZ_SRM_INIT_EN)) {
+			netif_dbg(efx, hw, efx->net_dev,
+				  "SRAM reset complete\n");
 
 			return 0;
 		}
 	} while (++count < 20);	/* wait upto 0.4 sec */
 
-	EFX_ERR(efx, "timed out waiting for SRAM reset\n");
+	netif_err(efx, hw, efx->net_dev, "timed out waiting for SRAM reset\n");
 	return -ETIMEDOUT;
 }
 
@@ -2713,8 +1418,6 @@ static int falcon_spi_device_init(struct
 		spi_device->block_size =
 			1 << SPI_DEV_TYPE_FIELD(device_type,
 						SPI_DEV_TYPE_BLOCK_SIZE);
-
-		spi_device->efx = efx;
 	} else {
 		spi_device = NULL;
 	}
@@ -2723,7 +1426,6 @@ static int falcon_spi_device_init(struct
 	*spi_device_ret = spi_device;
 	return 0;
 }
-
 
 static void falcon_remove_spi_devices(struct efx_nic *efx)
 {
@@ -2738,8 +1440,6 @@ static int falcon_probe_nvconfig(struct 
 {
 	struct falcon_nic_data *nic_data = efx->nic_data;
 	struct falcon_nvconfig *nvconfig;
-	int board_rev;
-	bool onchip_sram;
 	int rc;
 
 	nvconfig = kmalloc(sizeof(*nvconfig), GFP_KERNEL);
@@ -2747,224 +1447,108 @@ static int falcon_probe_nvconfig(struct 
 		return -ENOMEM;
 
 	rc = falcon_read_nvram(efx, nvconfig);
-	if (rc == -EINVAL) {
-		EFX_ERR(efx, "NVRAM is invalid therefore using defaults\n");
-		efx->phy_type = PHY_TYPE_NONE;
-		efx->mdio.prtad = MDIO_PRTAD_NONE;
-		board_rev = 0;
-		onchip_sram = true;
-		rc = 0;
-	} else if (rc) {
-		goto fail1;
-	} else {
-		struct falcon_nvconfig_board_v2 *v2 = &nvconfig->board_v2;
-		struct falcon_nvconfig_board_v3 *v3 = &nvconfig->board_v3;
+	if (rc)
+		goto out;
 
-		efx->phy_type = v2->port0_phy_type;
-		efx->mdio.prtad = v2->port0_phy_addr;
-		board_rev = le16_to_cpu(v2->board_revision);
-#ifdef CONFIG_SFC_DRIVERLINK
-		onchip_sram = EFX_OWORD_FIELD(nvconfig->nic_stat_reg,
-					      ONCHIP_SRAM);
-#else
-		/* We have no use for external SRAM */
-		onchip_sram = true;
-#endif
-
-		if (le16_to_cpu(nvconfig->board_struct_ver) >= 3) {
-			__le32 fl = v3->spi_device_type[EE_SPI_FLASH];
-			__le32 ee = v3->spi_device_type[EE_SPI_EEPROM];
-			rc = falcon_spi_device_init(efx, &efx->spi_flash,
-						    EE_SPI_FLASH,
-						    le32_to_cpu(fl));
-			if (rc)
-				goto fail2;
-			rc = falcon_spi_device_init(efx, &efx->spi_eeprom,
-						    EE_SPI_EEPROM,
-						    le32_to_cpu(ee));
-			if (rc)
-				goto fail2;
-		}
-	}
-
-	/* Read the MAC addresses */
 	memcpy(efx->mac_address, nvconfig->mac_address[0], ETH_ALEN);
 
-	EFX_LOG(efx, "PHY is %d phy_id %d\n", efx->phy_type, efx->mdio.prtad);
+	efx->phy_type = nvconfig->board_v2.port0_phy_type;
+	efx->mdio.prtad = nvconfig->board_v2.port0_phy_addr;
+	netif_dbg(efx, probe, efx->net_dev, "PHY is %s(%d) phy_id %d\n",
+		  efx->phy_name, efx->phy_type, efx->mdio.prtad);
 
-	efx_set_board_info(efx, board_rev);
+	rc = falcon_probe_board(efx,
+				le16_to_cpu(nvconfig->board_v2.board_revision));
+	if (rc)
+		goto out;
+
+	if (le16_to_cpu(nvconfig->board_struct_ver) >= 3) {
+		rc = falcon_spi_device_init(
+			efx, &efx->spi_flash, FFE_AB_SPI_DEVICE_FLASH,
+			le32_to_cpu(nvconfig->board_v3
+				    .spi_device_type[FFE_AB_SPI_DEVICE_FLASH]));
+		if (rc)
+			goto out;
+		rc = falcon_spi_device_init(
+			efx, &efx->spi_eeprom, FFE_AB_SPI_DEVICE_EEPROM,
+			le32_to_cpu(nvconfig->board_v3
+				    .spi_device_type[FFE_AB_SPI_DEVICE_EEPROM]));
+		if (rc)
+			goto out;
+	}
 
 	/* Read the SRAM configuration.  The register is initialised
 	 * automatically but might may been reset since boot.
 	 */
-	if (onchip_sram) {
-		nic_data->sram_cfg = SRM_NB_BSZ_ONCHIP_ONLY;
+#ifdef EFX_NOT_UPSTREAM
+	if (falcon_force_internal_sram)
+		nic_data->sram_config = SRAM_CONFIG_INTERNAL;
+	else
+		/* fall through to following statement */
+#endif
+	if (EFX_OWORD_FIELD(nvconfig->nic_stat_reg, FRF_AB_ONCHIP_SRAM)) {
+		nic_data->sram_config = SRAM_CONFIG_INTERNAL;
 	} else {
-		nic_data->sram_cfg =
-			EFX_OWORD_FIELD(nvconfig->srm_cfg_reg,
-					SRM_NUM_BANKS_AND_BANK_SIZE);
-		WARN_ON(nic_data->sram_cfg == SRM_NB_BSZ_RESERVED);
+		nic_data->sram_config = EFX_OWORD_FIELD(nvconfig->srm_cfg_reg,
+							FRF_AZ_SRM_NB_SZ);
+		WARN_ON(nic_data->sram_config == FFE_AB_SRM_NB_SZ_RES);
 		/* Replace invalid setting with the smallest defaults */
-		if (nic_data->sram_cfg == SRM_NB_BSZ_DEFAULT)
-			nic_data->sram_cfg = SRM_NB_BSZ_1BANKS_2M;
+		if (nic_data->sram_config == FFE_AB_SRM_NB_SZ_DEF)
+			nic_data->sram_config = FFE_AB_SRM_NB1_SZ2M;
 	}
+	netif_dbg(efx, probe, efx->net_dev,
+		  "sram_config=%d (>=0 is external)\n", nic_data->sram_config);
 
-	kfree(nvconfig);
-	return 0;
-
- fail2:
-	falcon_remove_spi_devices(efx);
- fail1:
+out:
 	kfree(nvconfig);
 	return rc;
 }
 
-/* Looks at available SRAM resources and silicon revision, and works out
- * how many queues we can support, and where things like descriptor caches
- * should live. */
 static int falcon_dimension_resources(struct efx_nic *efx)
 {
 	struct falcon_nic_data *nic_data = efx->nic_data;
-#ifdef CONFIG_SFC_DRIVERLINK
-	unsigned internal_dcs_entries;
-	struct efx_dl_falcon_resources *res = &nic_data->resources;
+	struct efx_dl_falcon_resources *res = &efx->resources;
 
-	/* Fill out the driverlink resource list */
-	res->hdr.type = EFX_DL_FALCON_RESOURCES;
-	res->biu_lock = &efx->biu_lock;
-	efx->dl_info = &res->hdr;
+	if (nic_data->sram_config == SRAM_CONFIG_INTERNAL) {
+		/* We scavenge internal memories to serve as the
+		 * buffer table and descriptor caches. */
+		unsigned internal_dcs_entries =
+			(efx_nic_rev(efx) == EFX_REV_FALCON_A1) ? 8192 : 4096;
 
-	/* NB. The minimum values get increased as this driver initialises
-	 * its resources, so this should prevent any overlap.
-	 */
-	switch (falcon_rev(efx)) {
-	case FALCON_REV_A1:
-		res->rxq_min = 16;
-		res->txq_min = 16;
-		res->evq_int_min = 4;
-		res->evq_int_lim = 5;
-		res->evq_timer_min = 5;
-		res->evq_timer_lim = 4096;
-		internal_dcs_entries = 8192;
-		break;
-	case FALCON_REV_B0:
-	default:
-		res->rxq_min = 0;
-		res->txq_min = 0;
-		res->evq_int_min = 0;
-		res->evq_int_lim = 64;
-		res->evq_timer_min = 64;
-		res->evq_timer_lim = 4096;
-		internal_dcs_entries = 4096;
-		break;
-	}
+		efx->rx_dc_entries = 64;
+		efx->tx_dc_entries = 16;
+		res->rxq_lim = internal_dcs_entries / efx->rx_dc_entries;
+		res->txq_lim = internal_dcs_entries / efx->tx_dc_entries;
+		res->buffer_table_lim = 8192;
+		efx->rx_dc_base = 0x100000;
+		efx->tx_dc_base = 0x130000;
+		efx->sram_lim = 0x140000;
+		return 0;
+	} else {
+		/* Otherwise we have a large block of external SRAM */
+		size_t sram_size;
 
-	if (nic_data->sram_cfg == SRM_NB_BSZ_ONCHIP_ONLY) {
-		res->rxq_lim = internal_dcs_entries / RX_DC_ENTRIES;
-		res->txq_lim = internal_dcs_entries / TX_DC_ENTRIES;
-		res->buffer_table_lim = 8192;
-		nic_data->tx_dc_base = TX_DC_INTERNAL_BASE;
-		nic_data->rx_dc_base = RX_DC_INTERNAL_BASE;
-	} else {
-		unsigned sram_bytes, vnic_bytes, max_vnics, n_vnics, dcs;
-
-		/* Determine how much SRAM we have to play with.  We have
-		 * to fit buffer table and descriptor caches in.
-		 */
-		switch (nic_data->sram_cfg) {
-		case SRM_NB_BSZ_1BANKS_2M:
+		switch (nic_data->sram_config) {
+		case FFE_AB_SRM_NB1_SZ2M:
 		default:
-			sram_bytes = 2 * 1024 * 1024;
+			sram_size = 2 * 1024 * 1024;
 			break;
-		case SRM_NB_BSZ_1BANKS_4M:
-		case SRM_NB_BSZ_2BANKS_4M:
-			sram_bytes = 4 * 1024 * 1024;
+		case FFE_AB_SRM_NB1_SZ4M:
+		case FFE_AB_SRM_NB2_SZ4M:
+			sram_size = 4 * 1024 * 1024;
 			break;
-		case SRM_NB_BSZ_1BANKS_8M:
-		case SRM_NB_BSZ_2BANKS_8M:
-			sram_bytes = 8 * 1024 * 1024;
+		case FFE_AB_SRM_NB1_SZ8M:
+		case FFE_AB_SRM_NB2_SZ8M:
+			sram_size = 8 * 1024 * 1024;
 			break;
-		case SRM_NB_BSZ_2BANKS_16M:
-			sram_bytes = 16 * 1024 * 1024;
+		case FFE_AB_SRM_NB2_SZ16M:
+			sram_size = 16 * 1024 * 1024;
 			break;
 		}
-		/* For each VNIC allow at least 512 buffer table entries
-		 * and descriptor cache for an rxq and txq.  Buffer table
-		 * space for evqs and dmaqs is relatively trivial, so not
-		 * considered in this calculation.
-		 */
-		vnic_bytes = 512 * 8 + RX_DC_ENTRIES * 8 + TX_DC_ENTRIES * 8;
-		max_vnics = sram_bytes / vnic_bytes;
-		for (n_vnics = 1; n_vnics < res->evq_timer_min + max_vnics;)
-			n_vnics *= 2;
-		res->rxq_lim = n_vnics;
-		res->txq_lim = n_vnics;
-
-		dcs = n_vnics * TX_DC_ENTRIES * 8;
-		nic_data->tx_dc_base = sram_bytes - dcs;
-		dcs = n_vnics * RX_DC_ENTRIES * 8;
-		nic_data->rx_dc_base = nic_data->tx_dc_base - dcs;
-		res->buffer_table_lim = nic_data->rx_dc_base / 8;
+		efx->resources.buffer_table_lim = sram_size / 8;
+		return efx_nic_dimension_resources(efx, sram_size,
+						   efx->resources.evq_timer_min);
 	}
-
-	if (FALCON_IS_DUAL_FUNC(efx))
-		res->flags |= EFX_DL_FALCON_DUAL_FUNC;
-
-	if (EFX_INT_MODE_USE_MSI(efx))
-		res->flags |= EFX_DL_FALCON_USE_MSI;
-#else
-	/* We ignore external SRAM */
-	EFX_BUG_ON_PARANOID(nic_data->sram_cfg != SRM_NB_BSZ_ONCHIP_ONLY);
-	nic_data->tx_dc_base = TX_DC_INTERNAL_BASE;
-	nic_data->rx_dc_base = RX_DC_INTERNAL_BASE;
-#endif
-
-	return 0;
-}
-
-/* Probe the NIC variant (revision, ASIC vs FPGA, function count, port
- * count, port speed).  Set workaround and feature flags accordingly.
- */
-static int falcon_probe_nic_variant(struct efx_nic *efx)
-{
-	efx_oword_t altera_build;
-	efx_oword_t nic_stat;
-
-	falcon_read(efx, &altera_build, ALTERA_BUILD_REG_KER);
-	if (EFX_OWORD_FIELD(altera_build, VER_ALL)) {
-		EFX_ERR(efx, "Falcon FPGA not supported\n");
-		return -ENODEV;
-	}
-
-	falcon_read(efx, &nic_stat, NIC_STAT_REG);
-
-	switch (falcon_rev(efx)) {
-	case FALCON_REV_A0:
-	case 0xff:
-		EFX_ERR(efx, "Falcon rev A0 not supported\n");
-		return -ENODEV;
-
-	case FALCON_REV_A1:
-		if (EFX_OWORD_FIELD(nic_stat, STRAP_PCIE) == 0) {
-			EFX_ERR(efx, "Falcon rev A1 PCI-X not supported\n");
-			return -ENODEV;
-		}
-		efx->silicon_rev = "falcon/a1";
-		break;
-
-	case FALCON_REV_B0:
-		efx->silicon_rev = "falcon/b0";
-		break;
-
-	default:
-		EFX_ERR(efx, "Unknown Falcon rev %d\n", falcon_rev(efx));
-		return -ENODEV;
-	}
-
-	/* Initial assumed speed */
-	efx->link_speed = EFX_OWORD_FIELD(nic_stat, STRAP_10G) ? 10000 : 1000;
-
-	return 0;
 }
 
 /* Probe all SPI devices on the NIC */
@@ -2973,40 +1557,61 @@ static void falcon_probe_spi_devices(str
 	efx_oword_t nic_stat, gpio_ctl, ee_vpd_cfg;
 	int boot_dev;
 
-	falcon_read(efx, &gpio_ctl, GPIO_CTL_REG_KER);
-	falcon_read(efx, &nic_stat, NIC_STAT_REG);
-	falcon_read(efx, &ee_vpd_cfg, EE_VPD_CFG_REG_KER);
+	efx_reado(efx, &gpio_ctl, FR_AB_GPIO_CTL);
+	efx_reado(efx, &nic_stat, FR_AB_NIC_STAT);
+	efx_reado(efx, &ee_vpd_cfg, FR_AB_EE_VPD_CFG0);
 
-	if (EFX_OWORD_FIELD(gpio_ctl, BOOTED_USING_NVDEVICE)) {
-		boot_dev = (EFX_OWORD_FIELD(nic_stat, SF_PRST) ?
-			    EE_SPI_FLASH : EE_SPI_EEPROM);
-		EFX_LOG(efx, "Booted from %s\n",
-			boot_dev == EE_SPI_FLASH ? "flash" : "EEPROM");
+	if (EFX_OWORD_FIELD(gpio_ctl, FRF_AB_GPIO3_PWRUP_VALUE)) {
+		boot_dev = (EFX_OWORD_FIELD(nic_stat, FRF_AB_SF_PRST) ?
+			    FFE_AB_SPI_DEVICE_FLASH : FFE_AB_SPI_DEVICE_EEPROM);
+		netif_dbg(efx, probe, efx->net_dev, "Booted from %s\n",
+			  boot_dev == FFE_AB_SPI_DEVICE_FLASH ?
+			  "flash" : "EEPROM");
 	} else {
 		/* Disable VPD and set clock dividers to safe
 		 * values for initial programming. */
 		boot_dev = -1;
-		EFX_LOG(efx, "Booted from internal ASIC settings;"
-			" setting SPI config\n");
-		EFX_POPULATE_OWORD_3(ee_vpd_cfg, EE_VPD_EN, 0,
+		netif_dbg(efx, probe, efx->net_dev,
+			  "Booted from internal ASIC settings;"
+			  " setting SPI config\n");
+		EFX_POPULATE_OWORD_3(ee_vpd_cfg, FRF_AB_EE_VPD_EN, 0,
 				     /* 125 MHz / 7 ~= 20 MHz */
-				     EE_SF_CLOCK_DIV, 7,
+				     FRF_AB_EE_SF_CLOCK_DIV, 7,
 				     /* 125 MHz / 63 ~= 2 MHz */
-				     EE_EE_CLOCK_DIV, 63);
-		falcon_write(efx, &ee_vpd_cfg, EE_VPD_CFG_REG_KER);
+				     FRF_AB_EE_EE_CLOCK_DIV, 63);
+		efx_writeo(efx, &ee_vpd_cfg, FR_AB_EE_VPD_CFG0);
 	}
 
-	if (boot_dev == EE_SPI_FLASH)
-		falcon_spi_device_init(efx, &efx->spi_flash, EE_SPI_FLASH,
-				       default_flash_type);
-	if (boot_dev == EE_SPI_EEPROM)
-		falcon_spi_device_init(efx, &efx->spi_eeprom, EE_SPI_EEPROM,
-				       large_eeprom_type);
+	if (boot_dev == FFE_AB_SPI_DEVICE_FLASH || flash_type != -1) {
+		u32 nic_flash_type =
+			flash_type == -1 ? default_flash_type : flash_type;
+		falcon_spi_device_init(efx, &efx->spi_flash,
+				       FFE_AB_SPI_DEVICE_FLASH,
+				       nic_flash_type);
+	}
+
+	if (boot_dev == FFE_AB_SPI_DEVICE_EEPROM || eeprom_type != -1) {
+		/* eeprom_type may be -1 (default) for automatic detection,
+		 * 0 or 1 to select the default or large EEPROM, or
+		 * some larger number to specify the precise configuration
+		 */
+		u32 nic_eeprom_type;
+		if (eeprom_type == 0)
+			nic_eeprom_type = small_eeprom_type;
+		else if (eeprom_type == -1 || eeprom_type == 1)
+			nic_eeprom_type = large_eeprom_type;
+		else
+			nic_eeprom_type = eeprom_type;
+		falcon_spi_device_init(efx, &efx->spi_eeprom,
+				       FFE_AB_SPI_DEVICE_EEPROM,
+				       nic_eeprom_type);
+	}
 }
 
-int falcon_probe_nic(struct efx_nic *efx)
+static int falcon_probe_nic(struct efx_nic *efx)
 {
 	struct falcon_nic_data *nic_data;
+	struct falcon_board *board;
 	int rc;
 
 	/* Allocate storage for hardware specific data */
@@ -3015,15 +1620,54 @@ int falcon_probe_nic(struct efx_nic *efx
 		return -ENOMEM;
 	efx->nic_data = nic_data;
 
-	/* Determine number of ports etc. */
-	rc = falcon_probe_nic_variant(efx);
-	if (rc)
+#ifdef EFX_NOT_UPSTREAM
+	/* Perform BIU self-test. If we can't read/write registers properly
+	 * then there's not much point on continuing
+	 */
+	rc = efx_nic_test_biu(efx);
+	if (rc) {
+		netif_err(efx, probe, efx->net_dev,
+			  "self-test failed rc %d\n", rc);
 		goto fail1;
+	}
+#endif
 
-	/* Probe secondary function if expected */
-	if (FALCON_IS_DUAL_FUNC(efx)) {
-		struct pci_dev *dev = pci_dev_get(efx->pci_dev);
+	rc = -ENODEV;
 
+	if (efx_nic_fpga_ver(efx) != 0) {
+		netif_err(efx, probe, efx->net_dev,
+			  "Falcon FPGA not supported\n");
+		goto fail1;
+	}
+
+	if (efx_nic_rev(efx) <= EFX_REV_FALCON_A1) {
+		efx_oword_t nic_stat;
+		struct pci_dev *dev;
+#if defined(EFX_USE_KCOMPAT) && !defined(EFX_USE_PCI_DEV_REVISION)
+		u8 pci_rev;
+		pci_read_config_byte(efx->pci_dev, PCI_CLASS_REVISION, &pci_rev);
+#else
+		u8 pci_rev = efx->pci_dev->revision;
+#endif
+
+		if ((pci_rev == 0xff) || (pci_rev == 0)) {
+			netif_err(efx, probe, efx->net_dev,
+				  "Falcon rev A0 not supported\n");
+			goto fail1;
+		}
+		efx_reado(efx, &nic_stat, FR_AB_NIC_STAT);
+		if (EFX_OWORD_FIELD(nic_stat, FRF_AB_STRAP_10G) == 0) {
+			netif_err(efx, probe, efx->net_dev,
+				  "Falcon rev A1 1G not supported\n");
+			goto fail1;
+		}
+		if (EFX_OWORD_FIELD(nic_stat, FRF_AA_STRAP_PCIE) == 0) {
+			netif_err(efx, probe, efx->net_dev,
+				  "Falcon rev A1 PCI-X not supported\n");
+			goto fail1;
+		}
+
+		dev = pci_dev_get(efx->pci_dev);
 		while ((dev = pci_get_device(EFX_VENDID_SFC, FALCON_A_S_DEVID,
 					     dev))) {
 			if (dev->bus == efx->pci_dev->bus &&
@@ -3033,234 +1677,386 @@ int falcon_probe_nic(struct efx_nic *efx
 			}
 		}
 		if (!nic_data->pci_dev2) {
-			EFX_ERR(efx, "failed to find secondary function\n");
-			rc = -ENODEV;
-			goto fail2;
+			netif_err(efx, probe, efx->net_dev,
+				  "failed to find secondary function\n");
+			goto fail1;
 		}
 	}
 
 	/* Now we can reset the NIC */
 	rc = falcon_reset_hw(efx, RESET_TYPE_ALL);
 	if (rc) {
-		EFX_ERR(efx, "failed to reset NIC\n");
-		goto fail3;
+		netif_err(efx, probe, efx->net_dev, "failed to reset NIC\n");
+		goto fail2;
 	}
 
 	/* Allocate memory for INT_KER */
-	rc = falcon_alloc_buffer(efx, &efx->irq_status, sizeof(efx_oword_t));
+	rc = efx_nic_alloc_buffer(efx, &efx->irq_status, sizeof(efx_oword_t));
 	if (rc)
-		goto fail4;
+		goto fail3;
 	BUG_ON(efx->irq_status.dma_addr & 0x0f);
 
-	EFX_LOG(efx, "INT_KER at %llx (virt %p phys %llx)\n",
-		(u64)efx->irq_status.dma_addr,
-		efx->irq_status.addr, (u64)virt_to_phys(efx->irq_status.addr));
+	netif_dbg(efx, probe, efx->net_dev,
+		  "INT_KER at %llx (virt %p phys %llx)\n",
+		  (u64)efx->irq_status.dma_addr,
+		  efx->irq_status.addr,
+		  (u64)virt_to_phys(efx->irq_status.addr));
 
 	falcon_probe_spi_devices(efx);
 
 	/* Read in the non-volatile configuration */
+#ifdef EFX_NOT_UPSTREAM
+	if (efx_ignore_nvconfig) {
+		falcon_probe_dummy_board(efx);
+		efx->phy_type = PHY_TYPE_NONE;
+		efx->mdio.prtad = MDIO_PRTAD_NONE;
+		nic_data->sram_config = SRAM_CONFIG_INTERNAL;
+		rc = 0;
+	} else
+		/* fall through to next statement */
+#endif
 	rc = falcon_probe_nvconfig(efx);
+	if (rc) {
+		if (rc == -EINVAL)
+			netif_err(efx, probe, efx->net_dev, "NVRAM is invalid\n");
+		goto fail4;
+	}
+
+	rc = falcon_dimension_resources(efx);
 	if (rc)
 		goto fail5;
 
-	rc = falcon_dimension_resources(efx);
+	/* Initialise I2C adapter */
+	board = falcon_board(efx);
+#ifdef CONFIG_SFC_I2C
+	board->i2c_adap.owner = THIS_MODULE;
+	board->i2c_data = falcon_i2c_bit_operations;
+	board->i2c_data.data = efx;
+	board->i2c_adap.algo_data = &board->i2c_data;
+	board->i2c_adap.dev.parent = &efx->pci_dev->dev;
+	strlcpy(board->i2c_adap.name, "SFC4000 GPIO",
+		sizeof(board->i2c_adap.name));
+	rc = i2c_bit_add_bus(&board->i2c_adap);
 	if (rc)
+		goto fail5;
+#endif
+
+	rc = falcon_board(efx)->type->init(efx);
+	if (rc) {
+		netif_err(efx, probe, efx->net_dev,
+			  "failed to initialise board\n");
 		goto fail6;
+	}
 
-	/* Initialise I2C adapter */
-	efx->i2c_adap.owner = THIS_MODULE;
-	nic_data->i2c_data = falcon_i2c_bit_operations;
-	nic_data->i2c_data.data = efx;
-	efx->i2c_adap.algo_data = &nic_data->i2c_data;
-	efx->i2c_adap.dev.parent = &efx->pci_dev->dev;
-	strlcpy(efx->i2c_adap.name, "SFC4000 GPIO", sizeof(efx->i2c_adap.name));
-	rc = i2c_bit_add_bus(&efx->i2c_adap);
-	if (rc)
-		goto fail6;
+	nic_data->stats_disable_count = 1;
+	setup_timer(&nic_data->stats_timer, &falcon_stats_timer_func,
+		    (unsigned long)efx);
 
 	return 0;
 
- fail6:
-#ifdef CONFIG_SFC_DRIVERLINK
-	efx->dl_info = NULL;
+fail6:
+#ifdef CONFIG_SFC_I2C
+	BUG_ON(i2c_del_adapter(&board->i2c_adap));
+	memset(&board->i2c_adap, 0, sizeof(board->i2c_adap));
 #endif
- fail5:
+fail5:
+fail4:
 	falcon_remove_spi_devices(efx);
-	falcon_free_buffer(efx, &efx->irq_status);
- fail4:
- fail3:
+	efx_nic_free_buffer(efx, &efx->irq_status);
+fail3:
+fail2:
 	if (nic_data->pci_dev2) {
 		pci_dev_put(nic_data->pci_dev2);
 		nic_data->pci_dev2 = NULL;
 	}
- fail2:
- fail1:
-	kfree(efx->nic_data);
+fail1:
+	kfree(nic_data);
 	return rc;
+}
+
+static void falcon_b0_init_ack_repl_timer(struct efx_nic *efx, int num_lanes)
+{
+	unsigned tlp_size;
+	efx_dword_t pcie_ack_rpl_reg;
+	efx_dword_t pcie_ack_freq_reg;
+	efx_dword_t pcie_ctrl_stat_reg;
+	u16 pcie_devicectrl;
+	int lut_index, tlp_size_decoded;
+	int current_replay, expected_replay;
+	int current_ack_timer, current_ack_freq;
+
+	static struct efx_tlp_ack_factor {
+		int tlp;
+		int replay[4]; /* 0=1x, 1=2x, 3=4x, 4=8x (see pcie docs) */
+	} tlp_ack_factor_lut[4] = {
+		{ 128,  { 421, 257, 174, 166 } },
+		{ 256,  { 689, 391, 241, 225 } },
+		{ 512,  { 903, 498, 295, 193 } },
+		{ 1024, { 1670, 881, 487, 290 } }
+	};
+	struct efx_tlp_ack_factor *tlp_ack_factor;
+
+	/* Get TLP size */
+	falcon_b0_pcie_core_read_reg(efx, FPCR_BB_PCIE_DEVICE_CTRL_STAT,
+				     &pcie_ctrl_stat_reg);
+	pcie_devicectrl = (u16) EFX_EXTRACT_DWORD(pcie_ctrl_stat_reg, 0, 15);
+	tlp_size = ((PCI_EXP_DEVCTL_PAYLOAD & pcie_devicectrl) >>
+		    __ffs(PCI_EXP_DEVCTL_PAYLOAD));
+	EFX_WARN_ON_PARANOID(tlp_size > 3); /* => 1024 bytes */
+	tlp_ack_factor = &tlp_ack_factor_lut[tlp_size & 0x3];
+	tlp_size_decoded = tlp_ack_factor->tlp;
+
+	/* Get actual ack & actual and expected replay settings */
+	falcon_b0_pcie_core_read_reg(efx, FPCR_BB_ACK_RPL_TIMER,
+				     &pcie_ack_rpl_reg);
+	current_replay = EFX_DWORD_FIELD(pcie_ack_rpl_reg, FPCRF_BB_RPL_TL);
+	current_ack_timer = EFX_DWORD_FIELD(pcie_ack_rpl_reg, FPCRF_BB_ACK_TL);
+
+	lut_index = ffs(num_lanes) - 1;
+	expected_replay = tlp_ack_factor->replay[lut_index & 0x3];
+
+	falcon_b0_pcie_core_read_reg(efx, FPCR_BB_ACK_FREQ, &pcie_ack_freq_reg);
+	current_ack_freq = EFX_DWORD_FIELD(pcie_ack_freq_reg,
+					   FPCRF_BB_ACK_FREQ);
+
+	netif_dbg(efx, hw, efx->net_dev,
+		  "pcie x%d tlp=%d replay_reg=" EFX_DWORD_FMT " { ack=%d "
+		  "current_replay=%d expected_replay=%d } ack_reg="
+		  EFX_DWORD_FMT " { current_freq=%d expected_freq=%d }\n",
+		  num_lanes, tlp_size_decoded,
+		  EFX_DWORD_VAL(pcie_ack_rpl_reg), current_ack_timer,
+		  current_replay, expected_replay,
+		  EFX_DWORD_VAL(pcie_ack_rpl_reg), current_ack_freq, 0);
+
+	/* If expected replay setting needs to be bigger then set it */
+	if (expected_replay > current_replay) {
+		EFX_SET_DWORD_FIELD(pcie_ack_rpl_reg, FPCRF_BB_RPL_TL,
+				    expected_replay);
+
+		falcon_b0_pcie_core_write_reg(efx, FPCR_BB_ACK_RPL_TIMER,
+					      pcie_ack_rpl_reg);
+	}
+}
+
+static int falcon_init_pcie_core(struct efx_nic *efx)
+{
+	unsigned num_lanes = efx_nic_check_pcie_link(efx, 8, 1);
+
+	if (EFX_WORKAROUND_6943(efx) && num_lanes > 0)
+		falcon_b0_init_ack_repl_timer(efx, num_lanes);
+
+	if (EFX_WORKAROUND_9096(efx)) {
+		efx_dword_t pcie_ack_freq_reg;
+
+		/* ensure ack freq timer is 0 = always ack after timeout */
+		falcon_b0_pcie_core_read_reg(efx, FPCR_BB_ACK_FREQ,
+					     &pcie_ack_freq_reg);
+		EFX_SET_DWORD_FIELD(pcie_ack_freq_reg, FPCRF_BB_ACK_FREQ, 0);
+		falcon_b0_pcie_core_write_reg(efx, FPCR_BB_ACK_FREQ,
+					      pcie_ack_freq_reg);
+	}
+
+	return 0;
+}
+
+static void falcon_fini_pcie_core(struct efx_nic *efx)
+{
+	efx_dword_t pcie_ack_freq_reg;
+
+	if (EFX_WORKAROUND_9096(efx)) {
+		/* Set the ACK frequency timer to 1, so TLP's are acked in
+		 * a timely fashion.
+		 */
+		falcon_b0_pcie_core_read_reg(efx, FPCR_BB_ACK_FREQ,
+					     &pcie_ack_freq_reg);
+		EFX_SET_DWORD_FIELD(pcie_ack_freq_reg, FPCRF_BB_ACK_FREQ, 1);
+		falcon_b0_pcie_core_write_reg(efx, FPCR_BB_ACK_FREQ,
+					      pcie_ack_freq_reg);
+	}
+}
+
+static void falcon_init_rx_cfg(struct efx_nic *efx)
+{
+	/* Prior to Siena the RX DMA engine will split each frame at
+	 * intervals of RX_USR_BUF_SIZE (32-byte units). We set it to
+	 * be so large that that never happens. */
+	const unsigned huge_buf_size = (3 * 4096) >> 5;
+	/* RX control FIFO thresholds (32 entries) */
+	const unsigned ctrl_xon_thr = 20;
+	const unsigned ctrl_xoff_thr = 25;
+	/* RX data FIFO thresholds (256-byte units; size varies) */
+	int data_xon_thr = efx_nic_rx_xon_thresh >> 8;
+	int data_xoff_thr = efx_nic_rx_xoff_thresh >> 8;
+	efx_oword_t reg;
+
+	efx_reado(efx, &reg, FR_AZ_RX_CFG);
+	if (efx_nic_rev(efx) <= EFX_REV_FALCON_A1) {
+		/* Data FIFO size is 5.5K */
+		if (data_xon_thr < 0)
+			data_xon_thr = 512 >> 8;
+		if (data_xoff_thr < 0)
+			data_xoff_thr = 2048 >> 8;
+		EFX_SET_OWORD_FIELD(reg, FRF_AA_RX_DESC_PUSH_EN, 0);
+		EFX_SET_OWORD_FIELD(reg, FRF_AA_RX_USR_BUF_SIZE,
+				    huge_buf_size);
+		EFX_SET_OWORD_FIELD(reg, FRF_AA_RX_XON_MAC_TH, data_xon_thr);
+		EFX_SET_OWORD_FIELD(reg, FRF_AA_RX_XOFF_MAC_TH, data_xoff_thr);
+		EFX_SET_OWORD_FIELD(reg, FRF_AA_RX_XON_TX_TH, ctrl_xon_thr);
+		EFX_SET_OWORD_FIELD(reg, FRF_AA_RX_XOFF_TX_TH, ctrl_xoff_thr);
+	} else {
+		/* Data FIFO size is 80K; register fields moved */
+		if (data_xon_thr < 0)
+			data_xon_thr = 27648 >> 8; /* ~3*max MTU */
+		if (data_xoff_thr < 0)
+			data_xoff_thr = 54272 >> 8; /* ~80Kb - 3*max MTU */
+		EFX_SET_OWORD_FIELD(reg, FRF_BZ_RX_DESC_PUSH_EN, 0);
+		EFX_SET_OWORD_FIELD(reg, FRF_BZ_RX_USR_BUF_SIZE,
+				    huge_buf_size);
+		EFX_SET_OWORD_FIELD(reg, FRF_BZ_RX_XON_MAC_TH, data_xon_thr);
+		EFX_SET_OWORD_FIELD(reg, FRF_BZ_RX_XOFF_MAC_TH, data_xoff_thr);
+		EFX_SET_OWORD_FIELD(reg, FRF_BZ_RX_XON_TX_TH, ctrl_xon_thr);
+		EFX_SET_OWORD_FIELD(reg, FRF_BZ_RX_XOFF_TX_TH, ctrl_xoff_thr);
+		EFX_SET_OWORD_FIELD(reg, FRF_BZ_RX_INGR_EN, 1);
+
+		/* Enable hash insertion. This is broken for the
+		 * 'Falcon' hash so also select Toeplitz TCP/IPv4 and
+		 * IPv4 hashes. */
+		EFX_SET_OWORD_FIELD(reg, FRF_BZ_RX_HASH_INSRT_HDR, 1);
+		EFX_SET_OWORD_FIELD(reg, FRF_BZ_RX_HASH_ALG, 1);
+		EFX_SET_OWORD_FIELD(reg, FRF_BZ_RX_IP_HASH, 1);
+	}
+	/* Always enable XOFF signal from RX FIFO.  We enable
+	 * or disable transmission of pause frames at the MAC. */
+	EFX_SET_OWORD_FIELD(reg, FRF_AZ_RX_XOFF_MAC_EN, 1);
+	efx_writeo(efx, &reg, FR_AZ_RX_CFG);
 }
 
 /* This call performs hardware-specific global initialisation, such as
  * defining the descriptor cache sizes and number of RSS channels.
  * It does not set up any buffers, descriptor rings or event queues.
  */
-int falcon_init_nic(struct efx_nic *efx)
+static int falcon_init_nic(struct efx_nic *efx)
 {
 	struct falcon_nic_data *nic_data = efx->nic_data;
 	efx_oword_t temp;
-	unsigned thresh;
 	int rc;
 
-	/* Use on-chip SRAM if wanted. */
-	falcon_read(efx, &temp, NIC_STAT_REG);
-	EFX_SET_OWORD_FIELD(temp, ONCHIP_SRAM,
-			    nic_data->sram_cfg == SRM_NB_BSZ_ONCHIP_ONLY);
-	falcon_write(efx, &temp, NIC_STAT_REG);
+	/* Use on-chip SRAM if needed */
+	efx_reado(efx, &temp, FR_AB_NIC_STAT);
+	EFX_SET_OWORD_FIELD(temp, FRF_AB_ONCHIP_SRAM,
+			    nic_data->sram_config == SRAM_CONFIG_INTERNAL);
+	efx_writeo(efx, &temp, FR_AB_NIC_STAT);
 
-	/* Set the source of the GMAC clock */
-	if (falcon_rev(efx) == FALCON_REV_B0) {
-		falcon_read(efx, &temp, GPIO_CTL_REG_KER);
-		EFX_SET_OWORD_FIELD(temp, GPIO_USE_NIC_CLK, true);
-		falcon_write(efx, &temp, GPIO_CTL_REG_KER);
-	}
+	/* Warn if <8 lanes of PCIe detected & set pcie timers */
+	rc = falcon_init_pcie_core(efx);
+	if (rc)
+		goto fail1;
 
-	/* Set buffer table mode */
-	EFX_POPULATE_OWORD_1(temp, BUF_TBL_MODE, BUF_TBL_MODE_FULL);
-	falcon_write(efx, &temp, BUF_TBL_CFG_REG_KER);
+	/* Set the SRAM wake/sleep GPIO appropriately. */
+	efx_reado(efx, &temp, FR_AB_GPIO_CTL);
+	EFX_SET_OWORD_FIELD(temp, FRF_AB_GPIO1_OEN, 1);
+	EFX_SET_OWORD_FIELD(temp, FRF_AB_GPIO1_OUT,
+			    nic_data->sram_config == SRAM_CONFIG_INTERNAL);
+	efx_writeo(efx, &temp, FR_AB_GPIO_CTL);
 
-	rc = falcon_reset_sram(efx);
+	rc = falcon_reset_sram(efx,
+			       nic_data->sram_config != SRAM_CONFIG_INTERNAL ?
+			       nic_data->sram_config : 0);
 	if (rc)
-		return rc;
-
-	/* Set positions of descriptor caches in SRAM. */
-	EFX_POPULATE_OWORD_1(temp, SRM_TX_DC_BASE_ADR, nic_data->tx_dc_base / 8);
-	falcon_write(efx, &temp, SRM_TX_DC_CFG_REG_KER);
-	EFX_POPULATE_OWORD_1(temp, SRM_RX_DC_BASE_ADR, nic_data->rx_dc_base / 8);
-	falcon_write(efx, &temp, SRM_RX_DC_CFG_REG_KER);
-
-	/* Set TX descriptor cache size. */
-	BUILD_BUG_ON(TX_DC_ENTRIES != (16 << TX_DC_ENTRIES_ORDER));
-	EFX_POPULATE_OWORD_1(temp, TX_DC_SIZE, TX_DC_ENTRIES_ORDER);
-	falcon_write(efx, &temp, TX_DC_CFG_REG_KER);
-
-	/* Set RX descriptor cache size.  Set low watermark to size-8, as
-	 * this allows most efficient prefetching.
-	 */
-	BUILD_BUG_ON(RX_DC_ENTRIES != (16 << RX_DC_ENTRIES_ORDER));
-	EFX_POPULATE_OWORD_1(temp, RX_DC_SIZE, RX_DC_ENTRIES_ORDER);
-	falcon_write(efx, &temp, RX_DC_CFG_REG_KER);
-	EFX_POPULATE_OWORD_1(temp, RX_DC_PF_LWM, RX_DC_ENTRIES - 8);
-	falcon_write(efx, &temp, RX_DC_PF_WM_REG_KER);
+		goto fail2;
 
 	/* Clear the parity enables on the TX data fifos as
 	 * they produce false parity errors because of timing issues
 	 */
 	if (EFX_WORKAROUND_5129(efx)) {
-		falcon_read(efx, &temp, SPARE_REG_KER);
-		EFX_SET_OWORD_FIELD(temp, MEM_PERR_EN_TX_DATA, 0);
-		falcon_write(efx, &temp, SPARE_REG_KER);
+		efx_reado(efx, &temp, FR_AZ_CSR_SPARE);
+		EFX_SET_OWORD_FIELD(temp, FRF_AB_MEM_PERR_EN_TX_DATA, 0);
+		efx_writeo(efx, &temp, FR_AZ_CSR_SPARE);
 	}
 
-	/* Enable all the genuinely fatal interrupts.  (They are still
-	 * masked by the overall interrupt mask, controlled by
-	 * falcon_interrupts()).
-	 *
-	 * Note: All other fatal interrupts are enabled
-	 */
-	EFX_POPULATE_OWORD_3(temp,
-			     ILL_ADR_INT_KER_EN, 1,
-			     RBUF_OWN_INT_KER_EN, 1,
-			     TBUF_OWN_INT_KER_EN, 1);
-	EFX_INVERT_OWORD(temp);
-	falcon_write(efx, &temp, FATAL_INTR_REG_KER);
-
 	if (EFX_WORKAROUND_7244(efx)) {
-		falcon_read(efx, &temp, RX_FILTER_CTL_REG);
-		EFX_SET_OWORD_FIELD(temp, UDP_FULL_SRCH_LIMIT, 8);
-		EFX_SET_OWORD_FIELD(temp, UDP_WILD_SRCH_LIMIT, 8);
-		EFX_SET_OWORD_FIELD(temp, TCP_FULL_SRCH_LIMIT, 8);
-		EFX_SET_OWORD_FIELD(temp, TCP_WILD_SRCH_LIMIT, 8);
-		falcon_write(efx, &temp, RX_FILTER_CTL_REG);
+		efx_reado(efx, &temp, FR_BZ_RX_FILTER_CTL);
+		EFX_SET_OWORD_FIELD(temp, FRF_BZ_UDP_FULL_SRCH_LIMIT, 8);
+		EFX_SET_OWORD_FIELD(temp, FRF_BZ_UDP_WILD_SRCH_LIMIT, 8);
+		EFX_SET_OWORD_FIELD(temp, FRF_BZ_TCP_FULL_SRCH_LIMIT, 8);
+		EFX_SET_OWORD_FIELD(temp, FRF_BZ_TCP_WILD_SRCH_LIMIT, 8);
+		efx_writeo(efx, &temp, FR_BZ_RX_FILTER_CTL);
 	}
 
-	falcon_setup_rss_indir_table(efx);
+	if (EFX_WORKAROUND_11368(efx)) {
+		/* Ensure that invalid BAR accesses are detected in
+		 * time (prevents denial of service by vNIC users).
+		 */
+		efx_reado(efx, &temp, FR_AZ_HW_INIT);
+		EFX_SET_OWORD_FIELD(temp, FRF_AZ_POST_WR_MASK, 0x0f);
+		EFX_SET_OWORD_FIELD(temp, FRF_AZ_WD_TIMER, 0x10);
+		efx_writeo(efx, &temp, FR_AZ_HW_INIT);
+	}
 
+	/* XXX This is documented only for Falcon A0/A1 */
 	/* Setup RX.  Wait for descriptor is broken and must
 	 * be disabled.  RXDP recovery shouldn't be needed, but is.
 	 */
-	falcon_read(efx, &temp, RX_SELF_RST_REG_KER);
-	EFX_SET_OWORD_FIELD(temp, RX_NODESC_WAIT_DIS, 1);
-	EFX_SET_OWORD_FIELD(temp, RX_RECOVERY_EN, 1);
+	efx_reado(efx, &temp, FR_AA_RX_SELF_RST);
+	EFX_SET_OWORD_FIELD(temp, FRF_AA_RX_NODESC_WAIT_DIS, 1);
+	EFX_SET_OWORD_FIELD(temp, FRF_AA_RX_SELF_RST_EN, 1);
 	if (EFX_WORKAROUND_5583(efx))
-		EFX_SET_OWORD_FIELD(temp, RX_ISCSI_DIS, 1);
-	falcon_write(efx, &temp, RX_SELF_RST_REG_KER);
-
-	/* Disable the ugly timer-based TX DMA backoff and allow TX DMA to be
-	 * controlled by the RX FIFO fill level. Set arbitration to one pkt/Q.
-	 */
-	falcon_read(efx, &temp, TX_CFG2_REG_KER);
-	EFX_SET_OWORD_FIELD(temp, TX_RX_SPACER, 0xfe);
-	EFX_SET_OWORD_FIELD(temp, TX_RX_SPACER_EN, 1);
-	EFX_SET_OWORD_FIELD(temp, TX_ONE_PKT_PER_Q, 1);
-	EFX_SET_OWORD_FIELD(temp, TX_CSR_PUSH_EN, 0);
-	EFX_SET_OWORD_FIELD(temp, TX_DIS_NON_IP_EV, 1);
-	/* Enable SW_EV to inherit in char driver - assume harmless here */
-	EFX_SET_OWORD_FIELD(temp, TX_SW_EV_EN, 1);
-	/* Prefetch threshold 2 => fetch when descriptor cache half empty */
-	EFX_SET_OWORD_FIELD(temp, TX_PREF_THRESHOLD, 2);
-	/* Squash TX of packets of 16 bytes or less */
-	if (falcon_rev(efx) >= FALCON_REV_B0 && EFX_WORKAROUND_9141(efx))
-		EFX_SET_OWORD_FIELD(temp, TX_FLUSH_MIN_LEN_EN_B0, 1);
-	falcon_write(efx, &temp, TX_CFG2_REG_KER);
+		EFX_SET_OWORD_FIELD(temp, FRF_AA_RX_ISCSI_DIS, 1);
+	efx_writeo(efx, &temp, FR_AA_RX_SELF_RST);
 
 	/* Do not enable TX_NO_EOP_DISC_EN, since it limits packets to 16
 	 * descriptors (which is bad).
 	 */
-	falcon_read(efx, &temp, TX_CFG_REG_KER);
-	EFX_SET_OWORD_FIELD(temp, TX_NO_EOP_DISC_EN, 0);
-	falcon_write(efx, &temp, TX_CFG_REG_KER);
+	efx_reado(efx, &temp, FR_AZ_TX_CFG);
+	EFX_SET_OWORD_FIELD(temp, FRF_AZ_TX_NO_EOP_DISC_EN, 0);
+	efx_writeo(efx, &temp, FR_AZ_TX_CFG);
 
-	/* RX config */
-	falcon_read(efx, &temp, RX_CFG_REG_KER);
-	EFX_SET_OWORD_FIELD_VER(efx, temp, RX_DESC_PUSH_EN, 0);
-	if (EFX_WORKAROUND_7575(efx))
-		EFX_SET_OWORD_FIELD_VER(efx, temp, RX_USR_BUF_SIZE,
-					(3 * 4096) / 32);
-	if (falcon_rev(efx) >= FALCON_REV_B0)
-		EFX_SET_OWORD_FIELD(temp, RX_INGR_EN_B0, 1);
+	falcon_init_rx_cfg(efx);
 
-	/* RX FIFO flow control thresholds */
-	thresh = ((rx_xon_thresh_bytes >= 0) ?
-		  rx_xon_thresh_bytes : efx->type->rx_xon_thresh);
-	EFX_SET_OWORD_FIELD_VER(efx, temp, RX_XON_MAC_TH, thresh / 256);
-	thresh = ((rx_xoff_thresh_bytes >= 0) ?
-		  rx_xoff_thresh_bytes : efx->type->rx_xoff_thresh);
-	EFX_SET_OWORD_FIELD_VER(efx, temp, RX_XOFF_MAC_TH, thresh / 256);
-	/* RX control FIFO thresholds [32 entries] */
-	EFX_SET_OWORD_FIELD_VER(efx, temp, RX_XON_TX_TH, 20);
-	EFX_SET_OWORD_FIELD_VER(efx, temp, RX_XOFF_TX_TH, 25);
-	falcon_write(efx, &temp, RX_CFG_REG_KER);
+	if (efx_nic_rev(efx) >= EFX_REV_FALCON_B0) {
+		/* Set hash key for IPv4 */
+		memcpy(&temp, efx->rx_hash_key, sizeof(temp));
+		efx_writeo(efx, &temp, FR_BZ_RX_RSS_TKEY);
 
-	/* Set destination of both TX and RX Flush events */
-	if (falcon_rev(efx) >= FALCON_REV_B0) {
-		EFX_POPULATE_OWORD_1(temp, FLS_EVQ_ID, 0);
-		falcon_write(efx, &temp, DP_CTRL_REG);
+		/* Set destination of both TX and RX Flush events */
+		EFX_POPULATE_OWORD_1(temp, FRF_BZ_FLS_EVQ_ID, 0);
+		efx_writeo(efx, &temp, FR_BZ_DP_CTRL);
 	}
 
+	efx_nic_init_common(efx);
+
 	return 0;
+
+fail2:
+fail1:
+	falcon_fini_pcie_core(efx);
+	return rc;
 }
 
-void falcon_remove_nic(struct efx_nic *efx)
+static void falcon_fini_nic(struct efx_nic *efx)
+{
+	falcon_fini_pcie_core(efx);
+}
+
+static void falcon_remove_nic(struct efx_nic *efx)
 {
 	struct falcon_nic_data *nic_data = efx->nic_data;
+	struct falcon_board *board = falcon_board(efx);
 	int rc;
 
+	board->type->fini(efx);
+
+#ifdef CONFIG_SFC_I2C
 	/* Remove I2C adapter and clear it in preparation for a retry */
-	rc = i2c_del_adapter(&efx->i2c_adap);
+	rc = i2c_del_adapter(&board->i2c_adap);
 	BUG_ON(rc);
-	memset(&efx->i2c_adap, 0, sizeof(efx->i2c_adap));
+	memset(&board->i2c_adap, 0, sizeof(board->i2c_adap));
+#else
+	(void)rc;
+#endif
 
 	falcon_remove_spi_devices(efx);
-	falcon_free_buffer(efx, &efx->irq_status);
+	efx_nic_free_buffer(efx, &efx->irq_status);
 
 	falcon_reset_hw(efx, RESET_TYPE_ALL);
 
@@ -3270,73 +2066,206 @@ void falcon_remove_nic(struct efx_nic *e
 		nic_data->pci_dev2 = NULL;
 	}
 
-	/* Tear down the private nic state */
+	/* Tear down the private nic state, and the driverlink nic params */
 	kfree(efx->nic_data);
 	efx->nic_data = NULL;
-#ifdef CONFIG_SFC_DRIVERLINK
-	efx->dl_info = NULL;
-#endif
 }
 
-void falcon_update_nic_stats(struct efx_nic *efx)
+static void falcon_update_nic_stats(struct efx_nic *efx)
 {
+	struct falcon_nic_data *nic_data = efx->nic_data;
 	efx_oword_t cnt;
 
-	falcon_read(efx, &cnt, RX_NODESC_DROP_REG_KER);
-	efx->n_rx_nodesc_drop_cnt += EFX_OWORD_FIELD(cnt, RX_NODESC_DROP_CNT);
+	if (nic_data->stats_disable_count)
+		return;
+
+	efx_reado(efx, &cnt, FR_AZ_RX_NODESC_DROP);
+	efx->n_rx_nodesc_drop_cnt +=
+		EFX_OWORD_FIELD(cnt, FRF_AB_RX_NODESC_DROP_CNT);
+
+	if (nic_data->stats_pending &&
+	    *nic_data->stats_dma_done == FALCON_STATS_DONE) {
+		nic_data->stats_pending = false;
+		rmb(); /* read the done flag before the stats */
+		efx->mac_op->update_stats(efx);
+	}
+}
+
+void falcon_start_nic_stats(struct efx_nic *efx)
+{
+	struct falcon_nic_data *nic_data = efx->nic_data;
+
+	spin_lock_bh(&efx->stats_lock);
+	if (--nic_data->stats_disable_count == 0)
+		falcon_stats_request(efx);
+	spin_unlock_bh(&efx->stats_lock);
+}
+
+void falcon_stop_nic_stats(struct efx_nic *efx)
+{
+	struct falcon_nic_data *nic_data = efx->nic_data;
+	int i;
+
+	might_sleep();
+
+	spin_lock_bh(&efx->stats_lock);
+	++nic_data->stats_disable_count;
+	spin_unlock_bh(&efx->stats_lock);
+
+	del_timer_sync(&nic_data->stats_timer);
+
+	/* Wait enough time for the most recent transfer to
+	 * complete. */
+	for (i = 0; i < 4 && nic_data->stats_pending; i++) {
+		if (*nic_data->stats_dma_done == FALCON_STATS_DONE)
+			break;
+		msleep(1);
+	}
+
+	spin_lock_bh(&efx->stats_lock);
+	falcon_stats_complete(efx);
+	spin_unlock_bh(&efx->stats_lock);
+}
+
+static void falcon_set_id_led(struct efx_nic *efx, enum efx_led_mode mode)
+{
+	falcon_board(efx)->type->set_id_led(efx, mode);
 }
 
 /**************************************************************************
  *
- * Revision-dependent attributes used by efx.c
+ * Wake on LAN
  *
  **************************************************************************
  */
 
-struct efx_nic_type falcon_a_nic_type = {
-	.mem_bar = 2,
+static void falcon_get_wol(struct efx_nic *efx, struct ethtool_wolinfo *wol)
+{
+	wol->supported = 0;
+	wol->wolopts = 0;
+	memset(&wol->sopass, 0, sizeof(wol->sopass));
+}
+
+static int falcon_set_wol(struct efx_nic *efx, u32 type)
+{
+	if (type != 0)
+		return -EINVAL;
+	return 0;
+}
+
+/**************************************************************************
+ *
+ * Revision-dependent attributes used by efx.c and nic.c
+ *
+ **************************************************************************
+ */
+
+struct efx_nic_type falcon_a1_nic_type = {
+	.probe = falcon_probe_nic,
+	.remove = falcon_remove_nic,
+	.init = falcon_init_nic,
+	.fini = falcon_fini_nic,
+	.monitor = falcon_monitor,
+	.reset = falcon_reset_hw,
+	.probe_port = falcon_probe_port,
+	.remove_port = falcon_remove_port,
+	.prepare_flush = falcon_prepare_flush,
+	.update_stats = falcon_update_nic_stats,
+	.start_stats = falcon_start_nic_stats,
+	.stop_stats = falcon_stop_nic_stats,
+	.set_id_led = falcon_set_id_led,
+	.push_irq_moderation = falcon_push_irq_moderation,
+	.push_multicast_hash = falcon_push_multicast_hash,
+	.reconfigure_port = falcon_reconfigure_port,
+	.get_wol = falcon_get_wol,
+	.set_wol = falcon_set_wol,
+	.resume_wol = efx_port_dummy_op_void,
+	.test_nvram = falcon_test_nvram,
+	.default_mac_ops = &falcon_xmac_operations,
+
+	.revision = EFX_REV_FALCON_A1,
+	.dl_revision = "falcon/a1",
 	.mem_map_size = 0x20000,
-	.txd_ptr_tbl_base = TX_DESC_PTR_TBL_KER_A1,
-	.rxd_ptr_tbl_base = RX_DESC_PTR_TBL_KER_A1,
-	.buf_tbl_base = BUF_TBL_KER_A1,
-	.evq_ptr_tbl_base = EVQ_PTR_TBL_KER_A1,
-	.evq_rptr_tbl_base = EVQ_RPTR_REG_KER_A1,
-	.txd_ring_mask = FALCON_TXD_RING_MASK,
-	.rxd_ring_mask = FALCON_RXD_RING_MASK,
-	.evq_size = FALCON_EVQ_SIZE,
-	.max_dma_mask = FALCON_DMA_MASK,
-	.tx_dma_mask = FALCON_TX_DMA_MASK,
-	.bug5391_mask = 0xf,
-	.rx_xoff_thresh = 2048,
-	.rx_xon_thresh = 512,
+	.txd_ptr_tbl_base = FR_AA_TX_DESC_PTR_TBL_KER,
+	.rxd_ptr_tbl_base = FR_AA_RX_DESC_PTR_TBL_KER,
+	.buf_tbl_base = FR_AA_BUF_FULL_TBL_KER,
+	.evq_ptr_tbl_base = FR_AA_EVQ_PTR_TBL_KER,
+	.evq_rptr_tbl_base = FR_AA_EVQ_RPTR_KER,
+	.max_dma_mask = DMA_BIT_MASK(FSF_AZ_TX_KER_BUF_ADDR_WIDTH),
 	.rx_buffer_padding = 0x24,
 	.max_interrupt_mode = EFX_INT_MODE_MSI,
 	.phys_addr_channels = 4,
+	.resources = {
+		.hdr.type = EFX_DL_FALCON_RESOURCES,
+		.flags = EFX_DL_FALCON_DUAL_FUNC,
+		.rxq_min = 16, .rxq_lim = 4096,
+		.txq_min = 16, .txq_lim = 4096,
+		.evq_int_min = 4, .evq_int_lim = 5,
+		.evq_timer_min = 5, .evq_timer_lim = 4096,
+	},
+	.offload_features = NETIF_F_IP_CSUM,
+	.reset_world_flags = ETH_RESET_IRQ,
 };
 
-struct efx_nic_type falcon_b_nic_type = {
-	.mem_bar = 2,
+struct efx_nic_type falcon_b0_nic_type = {
+	.probe = falcon_probe_nic,
+	.remove = falcon_remove_nic,
+	.init = falcon_init_nic,
+	.fini = falcon_fini_nic,
+	.monitor = falcon_monitor,
+	.reset = falcon_reset_hw,
+	.probe_port = falcon_probe_port,
+	.remove_port = falcon_remove_port,
+	.prepare_flush = falcon_prepare_flush,
+	.update_stats = falcon_update_nic_stats,
+	.start_stats = falcon_start_nic_stats,
+	.stop_stats = falcon_stop_nic_stats,
+	.set_id_led = falcon_set_id_led,
+	.push_irq_moderation = falcon_push_irq_moderation,
+	.push_multicast_hash = falcon_push_multicast_hash,
+	.reconfigure_port = falcon_reconfigure_port,
+	.get_wol = falcon_get_wol,
+	.set_wol = falcon_set_wol,
+	.resume_wol = efx_port_dummy_op_void,
+	.test_registers = falcon_b0_test_registers,
+	.test_memory = falcon_b0_test_memory,
+	.test_nvram = falcon_test_nvram,
+	.default_mac_ops = &falcon_xmac_operations,
+
+	.revision = EFX_REV_FALCON_B0,
+	.dl_revision = "falcon/b0",
 	/* Map everything up to and including the RSS indirection
 	 * table.  Don't map MSI-X table, MSI-X PBA since Linux
 	 * requires that they not be mapped.  */
-	.mem_map_size = RX_RSS_INDIR_TBL_B0 + 0x800,
-	.txd_ptr_tbl_base = TX_DESC_PTR_TBL_KER_B0,
-	.rxd_ptr_tbl_base = RX_DESC_PTR_TBL_KER_B0,
-	.buf_tbl_base = BUF_TBL_KER_B0,
-	.evq_ptr_tbl_base = EVQ_PTR_TBL_KER_B0,
-	.evq_rptr_tbl_base = EVQ_RPTR_REG_KER_B0,
-	.txd_ring_mask = FALCON_TXD_RING_MASK,
-	.rxd_ring_mask = FALCON_RXD_RING_MASK,
-	.evq_size = FALCON_EVQ_SIZE,
-	.max_dma_mask = FALCON_DMA_MASK,
-	.tx_dma_mask = FALCON_TX_DMA_MASK,
-	.bug5391_mask = 0,
-	.rx_xoff_thresh = 54272, /* ~80Kb - 3*max MTU */
-	.rx_xon_thresh = 27648,  /* ~3*max MTU */
+	.mem_map_size = (FR_BZ_RX_INDIRECTION_TBL +
+			 FR_BZ_RX_INDIRECTION_TBL_STEP *
+			 FR_BZ_RX_INDIRECTION_TBL_ROWS),
+	.txd_ptr_tbl_base = FR_BZ_TX_DESC_PTR_TBL,
+	.rxd_ptr_tbl_base = FR_BZ_RX_DESC_PTR_TBL,
+	.buf_tbl_base = FR_BZ_BUF_FULL_TBL,
+	.evq_ptr_tbl_base = FR_BZ_EVQ_PTR_TBL,
+	.evq_rptr_tbl_base = FR_BZ_EVQ_RPTR,
+	.max_dma_mask = DMA_BIT_MASK(FSF_AZ_TX_KER_BUF_ADDR_WIDTH),
+	.rx_buffer_hash_size = 0x10,
 	.rx_buffer_padding = 0,
 	.max_interrupt_mode = EFX_INT_MODE_MSIX,
 	.phys_addr_channels = 32, /* Hardware limit is 64, but the legacy
 				   * interrupt handler only supports 32
 				   * channels */
+	.resources = {
+		.hdr.next = &falcon_b0_nic_type.dl_hash_insertion.hdr,
+		.hdr.type = EFX_DL_FALCON_RESOURCES,
+		.rxq_min = 0, .rxq_lim = 4096,
+		.txq_min = 0, .txq_lim = 4096,
+		.evq_int_min = 0, .evq_int_lim = 64,
+		.evq_timer_min = 64, .evq_timer_lim = 4096,
+	},
+	.dl_hash_insertion = {
+		.hdr.type = EFX_DL_HASH_INSERTION,
+		.data_offset = 0x10,
+		.hash_offset = 0x0c,
+		.flags = EFX_DL_HASH_TOEP_TCPIP4 | EFX_DL_HASH_TOEP_IP4,
+	},
+	.offload_features = NETIF_F_IP_CSUM | NETIF_F_RXHASH | NETIF_F_NTUPLE,
+	.reset_world_flags = ETH_RESET_IRQ,
 };
-
diff -r 5b3d4d3c1166 drivers/net/sfc/falcon.h
--- a/drivers/net/sfc/falcon.h	Fri Nov 05 15:20:28 2010 +0000
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,145 +0,0 @@
-/****************************************************************************
- * Driver for Solarflare Solarstorm network controllers and boards
- * Copyright 2005-2006 Fen Systems Ltd.
- * Copyright 2006-2008 Solarflare Communications Inc.
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 as published
- * by the Free Software Foundation, incorporated herein by reference.
- */
-
-#ifndef EFX_FALCON_H
-#define EFX_FALCON_H
-
-#include "net_driver.h"
-#include "efx.h"
-
-/*
- * Falcon hardware control
- */
-
-enum falcon_revision {
-	FALCON_REV_A0 = 0,
-	FALCON_REV_A1 = 1,
-	FALCON_REV_B0 = 2,
-};
-
-static inline int falcon_rev(struct efx_nic *efx)
-{
-	return efx->pci_dev->revision;
-}
-
-extern struct efx_nic_type falcon_a_nic_type;
-extern struct efx_nic_type falcon_b_nic_type;
-
-/**************************************************************************
- *
- * Externs
- *
- **************************************************************************
- */
-
-/* TX data path */
-extern int falcon_probe_tx(struct efx_tx_queue *tx_queue);
-extern void falcon_init_tx(struct efx_tx_queue *tx_queue);
-extern void falcon_fini_tx(struct efx_tx_queue *tx_queue);
-extern void falcon_remove_tx(struct efx_tx_queue *tx_queue);
-extern void falcon_push_buffers(struct efx_tx_queue *tx_queue);
-
-/* RX data path */
-extern int falcon_probe_rx(struct efx_rx_queue *rx_queue);
-extern void falcon_init_rx(struct efx_rx_queue *rx_queue);
-extern void falcon_fini_rx(struct efx_rx_queue *rx_queue);
-extern void falcon_remove_rx(struct efx_rx_queue *rx_queue);
-extern void falcon_notify_rx_desc(struct efx_rx_queue *rx_queue);
-
-/* Event data path */
-extern int falcon_probe_eventq(struct efx_channel *channel);
-extern void falcon_init_eventq(struct efx_channel *channel);
-extern void falcon_fini_eventq(struct efx_channel *channel);
-extern void falcon_remove_eventq(struct efx_channel *channel);
-extern int falcon_process_eventq(struct efx_channel *channel, int rx_quota);
-extern void falcon_eventq_read_ack(struct efx_channel *channel);
-
-/* Ports */
-extern int falcon_probe_port(struct efx_nic *efx);
-extern void falcon_remove_port(struct efx_nic *efx);
-
-/* MAC/PHY */
-extern int falcon_switch_mac(struct efx_nic *efx);
-extern bool falcon_xaui_link_ok(struct efx_nic *efx);
-extern int falcon_dma_stats(struct efx_nic *efx,
-			    unsigned int done_offset);
-extern void falcon_drain_tx_fifo(struct efx_nic *efx);
-extern void falcon_deconfigure_mac_wrapper(struct efx_nic *efx);
-extern void falcon_reconfigure_mac_wrapper(struct efx_nic *efx);
-
-/* Interrupts and test events */
-extern int falcon_init_interrupt(struct efx_nic *efx);
-extern void falcon_enable_interrupts(struct efx_nic *efx);
-extern void falcon_generate_test_event(struct efx_channel *channel,
-				       unsigned int magic);
-extern void falcon_sim_phy_event(struct efx_nic *efx);
-extern void falcon_generate_interrupt(struct efx_nic *efx);
-extern void falcon_set_int_moderation(struct efx_channel *channel);
-extern void falcon_disable_interrupts(struct efx_nic *efx);
-extern void falcon_fini_interrupt(struct efx_nic *efx);
-
-#define FALCON_IRQ_MOD_RESOLUTION 5
-
-/* Global Resources */
-extern int falcon_probe_nic(struct efx_nic *efx);
-extern int falcon_probe_resources(struct efx_nic *efx);
-extern int falcon_init_nic(struct efx_nic *efx);
-extern int falcon_flush_queues(struct efx_nic *efx);
-extern int falcon_reset_hw(struct efx_nic *efx, enum reset_type method);
-extern void falcon_remove_resources(struct efx_nic *efx);
-extern void falcon_remove_nic(struct efx_nic *efx);
-extern void falcon_update_nic_stats(struct efx_nic *efx);
-extern void falcon_set_multicast_hash(struct efx_nic *efx);
-extern int falcon_reset_xaui(struct efx_nic *efx);
-
-/* Tests */
-struct falcon_nvconfig;
-extern int falcon_read_nvram(struct efx_nic *efx,
-			     struct falcon_nvconfig *nvconfig);
-extern int falcon_test_registers(struct efx_nic *efx);
-
-/**************************************************************************
- *
- * Falcon MAC stats
- *
- **************************************************************************
- */
-
-#define FALCON_STAT_OFFSET(falcon_stat) EFX_VAL(falcon_stat, offset)
-#define FALCON_STAT_WIDTH(falcon_stat) EFX_VAL(falcon_stat, WIDTH)
-
-/* Retrieve statistic from statistics block */
-#define FALCON_STAT(efx, falcon_stat, efx_stat) do {		\
-	if (FALCON_STAT_WIDTH(falcon_stat) == 16)		\
-		(efx)->mac_stats.efx_stat += le16_to_cpu(	\
-			*((__force __le16 *)				\
-			  (efx->stats_buffer.addr +		\
-			   FALCON_STAT_OFFSET(falcon_stat))));	\
-	else if (FALCON_STAT_WIDTH(falcon_stat) == 32)		\
-		(efx)->mac_stats.efx_stat += le32_to_cpu(	\
-			*((__force __le32 *)				\
-			  (efx->stats_buffer.addr +		\
-			   FALCON_STAT_OFFSET(falcon_stat))));	\
-	else							\
-		(efx)->mac_stats.efx_stat += le64_to_cpu(	\
-			*((__force __le64 *)				\
-			  (efx->stats_buffer.addr +		\
-			   FALCON_STAT_OFFSET(falcon_stat))));	\
-	} while (0)
-
-#define FALCON_MAC_STATS_SIZE 0x100
-
-#define MAC_DATA_LBN 0
-#define MAC_DATA_WIDTH 32
-
-extern void falcon_generate_event(struct efx_channel *channel,
-				  efx_qword_t *event);
-
-#endif /* EFX_FALCON_H */
diff -r 5b3d4d3c1166 drivers/net/sfc/falcon_boards.c
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/drivers/net/sfc/falcon_boards.c	Tue Nov 09 10:06:27 2010 +0000
@@ -0,0 +1,819 @@
+/****************************************************************************
+ * Driver for Solarflare Solarstorm network controllers and boards
+ * Copyright 2007-2009 Solarflare Communications Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 as published
+ * by the Free Software Foundation, incorporated herein by reference.
+ */
+
+#ifndef EFX_USE_KCOMPAT
+#include <linux/rtnetlink.h>
+#endif
+
+#include "net_driver.h"
+#include "phy.h"
+#include "efx.h"
+#include "nic.h"
+#include "regs.h"
+#include "io.h"
+#include "workarounds.h"
+
+/* Macros for unpacking the board revision */
+/* The revision info is in host byte order. */
+#define FALCON_BOARD_TYPE(_rev) (_rev >> 8)
+#define FALCON_BOARD_MAJOR(_rev) ((_rev >> 4) & 0xf)
+#define FALCON_BOARD_MINOR(_rev) (_rev & 0xf)
+
+/* Board types */
+#define FALCON_BOARD_SFE4001 0x01
+#define FALCON_BOARD_SFE4002 0x02
+#define FALCON_BOARD_SFE4003 0x03
+#define FALCON_BOARD_SFN4112F 0x52
+
+/* Board temperature is about 15°C above ambient when air flow is
+ * limited.  The maximum acceptable ambient temperature varies
+ * depending on the PHY specifications but the critical temperature
+ * above which we should shut down to avoid damage is 80°C. */
+#define FALCON_BOARD_TEMP_BIAS	15
+#define FALCON_BOARD_TEMP_CRIT	(80 + FALCON_BOARD_TEMP_BIAS)
+
+/* SFC4000 datasheet says: 'The maximum permitted junction temperature
+ * is 125°C; the thermal design of the environment for the SFC4000
+ * should aim to keep this well below 100°C.' */
+#define FALCON_JUNC_TEMP_MIN	0
+#define FALCON_JUNC_TEMP_MAX	90
+#define FALCON_JUNC_TEMP_CRIT	125
+
+/*****************************************************************************
+ * Support for LM87 sensor chip used on several boards
+ */
+#define LM87_REG_TEMP_HW_INT_LOCK	0x13
+#define LM87_REG_TEMP_HW_EXT_LOCK	0x14
+#define LM87_REG_TEMP_HW_INT		0x17
+#define LM87_REG_TEMP_HW_EXT		0x18
+#define LM87_REG_TEMP_EXT1		0x26
+#define LM87_REG_TEMP_INT		0x27
+#define LM87_REG_ALARMS1		0x41
+#define LM87_REG_ALARMS2		0x42
+#define LM87_IN_LIMITS(nr, _min, _max)			\
+	0x2B + (nr) * 2, _max, 0x2C + (nr) * 2, _min
+#define LM87_AIN_LIMITS(nr, _min, _max)			\
+	0x3B + (nr), _max, 0x1A + (nr), _min
+#define LM87_TEMP_INT_LIMITS(_min, _max)		\
+	0x39, _max, 0x3A, _min
+#define LM87_TEMP_EXT1_LIMITS(_min, _max)		\
+	0x37, _max, 0x38, _min
+
+#define LM87_ALARM_TEMP_INT		0x10
+#define LM87_ALARM_TEMP_EXT1		0x20
+
+#ifdef CONFIG_SFC_HWMON
+
+static int efx_poke_lm87(struct i2c_client *client, const u8 *reg_values)
+{
+	while (*reg_values) {
+		u8 reg = *reg_values++;
+		u8 value = *reg_values++;
+		int rc = i2c_smbus_write_byte_data(client, reg, value);
+		if (rc)
+			return rc;
+	}
+	return 0;
+}
+
+static const u8 falcon_lm87_common_regs[] = {
+	LM87_REG_TEMP_HW_INT_LOCK, FALCON_BOARD_TEMP_CRIT,
+	LM87_REG_TEMP_HW_INT, FALCON_BOARD_TEMP_CRIT,
+	LM87_TEMP_EXT1_LIMITS(FALCON_JUNC_TEMP_MIN, FALCON_JUNC_TEMP_MAX),
+	LM87_REG_TEMP_HW_EXT_LOCK, FALCON_JUNC_TEMP_CRIT,
+	LM87_REG_TEMP_HW_EXT, FALCON_JUNC_TEMP_CRIT,
+	0
+};
+
+static int efx_init_lm87(struct efx_nic *efx, struct i2c_board_info *info,
+			 const u8 *reg_values)
+{
+	struct falcon_board *board = falcon_board(efx);
+	struct i2c_client *client = i2c_new_device(&board->i2c_adap, info);
+	int rc;
+
+	if (!client)
+		return -EIO;
+
+	/* Read-to-clear alarm/interrupt status */
+	i2c_smbus_read_byte_data(client, LM87_REG_ALARMS1);
+	i2c_smbus_read_byte_data(client, LM87_REG_ALARMS2);
+
+	rc = efx_poke_lm87(client, reg_values);
+	if (rc)
+		goto err;
+	rc = efx_poke_lm87(client, falcon_lm87_common_regs);
+	if (rc)
+		goto err;
+
+	board->hwmon_client = client;
+	return 0;
+
+err:
+	i2c_unregister_device(client);
+	return rc;
+}
+
+static void efx_fini_lm87(struct efx_nic *efx)
+{
+	i2c_unregister_device(falcon_board(efx)->hwmon_client);
+}
+
+static int efx_check_lm87(struct efx_nic *efx, unsigned mask)
+{
+	struct i2c_client *client = falcon_board(efx)->hwmon_client;
+	bool temp_crit, elec_fault, is_failure;
+	u16 alarms;
+	s32 reg;
+
+	/* If link is up then do not monitor temperature */
+	if (EFX_WORKAROUND_7884(efx) && efx->link_state.up)
+		return 0;
+
+	reg = i2c_smbus_read_byte_data(client, LM87_REG_ALARMS1);
+	if (reg < 0)
+		return reg;
+	alarms = reg;
+	reg = i2c_smbus_read_byte_data(client, LM87_REG_ALARMS2);
+	if (reg < 0)
+		return reg;
+	alarms |= reg << 8;
+	alarms &= mask;
+
+	temp_crit = false;
+	if (alarms & LM87_ALARM_TEMP_INT) {
+		reg = i2c_smbus_read_byte_data(client, LM87_REG_TEMP_INT);
+		if (reg < 0)
+			return reg;
+		if (reg > FALCON_BOARD_TEMP_CRIT)
+			temp_crit = true;
+	}
+	if (alarms & LM87_ALARM_TEMP_EXT1) {
+		reg = i2c_smbus_read_byte_data(client, LM87_REG_TEMP_EXT1);
+		if (reg < 0)
+			return reg;
+		if (reg > FALCON_JUNC_TEMP_CRIT)
+			temp_crit = true;
+	}
+	elec_fault = alarms & ~(LM87_ALARM_TEMP_INT | LM87_ALARM_TEMP_EXT1);
+	is_failure = temp_crit || elec_fault;
+
+	if (alarms)
+		netif_err(efx, hw, efx->net_dev,
+			  "LM87 detected a hardware %s (status %02x:%02x)"
+			  "%s%s%s%s\n",
+			  is_failure ? "failure" : "problem",
+			  alarms & 0xff, alarms >> 8,
+			  (alarms & LM87_ALARM_TEMP_INT) ?
+			  "; board is overheating" : "",
+			  (alarms & LM87_ALARM_TEMP_EXT1) ?
+			  "; controller is overheating" : "",
+			  temp_crit ? "; reached critical temperature" : "",
+			  elec_fault ? "; electrical fault" : "");
+
+	return is_failure ? -ERANGE : 0;
+}
+
+#else /* !CONFIG_SFC_HWMON */
+
+static int efx_init_lm87(struct efx_nic *efx, struct i2c_board_info *info,
+			 const u8 *reg_values)
+{
+	return 0;
+}
+
+static void efx_fini_lm87(struct efx_nic *efx)
+{
+}
+
+static int efx_check_lm87(struct efx_nic *efx, unsigned mask)
+{
+	return 0;
+}
+
+#endif /* CONFIG_SFC_HWMON */
+
+/*****************************************************************************
+ * Support for the SFE4001 NIC.
+ *
+ * The SFE4001 does not power-up fully at reset due to its high power
+ * consumption.  We control its power via a PCA9539 I/O expander.
+ * It also has a MAX6647 temperature monitor which we expose to
+ * the lm90 driver.
+ *
+ * This also provides minimal support for reflashing the PHY, which is
+ * initiated by resetting it with the FLASH_CFG_1 pin pulled down.
+ * On SFE4001 rev A2 and later this is connected to the 3V3X output of
+ * the IO-expander.
+ * We represent reflash mode as PHY_MODE_SPECIAL and make it mutually
+ * exclusive with the network device being open.
+ */
+
+/**************************************************************************
+ * Support for I2C IO Expander device on SFE4001
+ */
+#define	PCA9539 0x74
+
+#define	P0_IN 0x00
+#define	P0_OUT 0x02
+#define	P0_INVERT 0x04
+#define	P0_CONFIG 0x06
+
+#define	P0_EN_1V0X_LBN 0
+#define	P0_EN_1V0X_WIDTH 1
+#define	P0_EN_1V2_LBN 1
+#define	P0_EN_1V2_WIDTH 1
+#define	P0_EN_2V5_LBN 2
+#define	P0_EN_2V5_WIDTH 1
+#define	P0_EN_3V3X_LBN 3
+#define	P0_EN_3V3X_WIDTH 1
+#define	P0_EN_5V_LBN 4
+#define	P0_EN_5V_WIDTH 1
+#define	P0_SHORTEN_JTAG_LBN 5
+#define	P0_SHORTEN_JTAG_WIDTH 1
+#define	P0_X_TRST_LBN 6
+#define	P0_X_TRST_WIDTH 1
+#define	P0_DSP_RESET_LBN 7
+#define	P0_DSP_RESET_WIDTH 1
+
+#define	P1_IN 0x01
+#define	P1_OUT 0x03
+#define	P1_INVERT 0x05
+#define	P1_CONFIG 0x07
+
+#define	P1_AFE_PWD_LBN 0
+#define	P1_AFE_PWD_WIDTH 1
+#define	P1_DSP_PWD25_LBN 1
+#define	P1_DSP_PWD25_WIDTH 1
+#define	P1_RESERVED_LBN 2
+#define	P1_RESERVED_WIDTH 2
+#define	P1_SPARE_LBN 4
+#define	P1_SPARE_WIDTH 4
+
+/* Temperature Sensor */
+#define MAX664X_REG_RSL		0x02
+#define MAX664X_REG_WLHO	0x0B
+
+#ifdef CONFIG_SFC_SFE4001
+
+static void sfe4001_poweroff(struct efx_nic *efx)
+{
+	struct i2c_client *ioexp_client = falcon_board(efx)->ioexp_client;
+	struct i2c_client *hwmon_client = falcon_board(efx)->hwmon_client;
+
+	/* Turn off all power rails and disable outputs */
+	i2c_smbus_write_byte_data(ioexp_client, P0_OUT, 0xff);
+	i2c_smbus_write_byte_data(ioexp_client, P1_CONFIG, 0xff);
+	i2c_smbus_write_byte_data(ioexp_client, P0_CONFIG, 0xff);
+
+	/* Clear any over-temperature alert */
+	i2c_smbus_read_byte_data(hwmon_client, MAX664X_REG_RSL);
+}
+
+static int sfe4001_poweron(struct efx_nic *efx)
+{
+	struct i2c_client *ioexp_client = falcon_board(efx)->ioexp_client;
+	struct i2c_client *hwmon_client = falcon_board(efx)->hwmon_client;
+	unsigned int i, j;
+	int rc;
+	u8 out;
+
+	/* Clear any previous over-temperature alert */
+	rc = i2c_smbus_read_byte_data(hwmon_client, MAX664X_REG_RSL);
+	if (rc < 0)
+		return rc;
+
+	/* Enable port 0 and port 1 outputs on IO expander */
+	rc = i2c_smbus_write_byte_data(ioexp_client, P0_CONFIG, 0x00);
+	if (rc)
+		return rc;
+	rc = i2c_smbus_write_byte_data(ioexp_client, P1_CONFIG,
+				       0xff & ~(1 << P1_SPARE_LBN));
+	if (rc)
+		goto fail_on;
+
+	/* If PHY power is on, turn it all off and wait 1 second to
+	 * ensure a full reset.
+	 */
+	rc = i2c_smbus_read_byte_data(ioexp_client, P0_OUT);
+	if (rc < 0)
+		goto fail_on;
+	out = 0xff & ~((0 << P0_EN_1V2_LBN) | (0 << P0_EN_2V5_LBN) |
+		       (0 << P0_EN_3V3X_LBN) | (0 << P0_EN_5V_LBN) |
+		       (0 << P0_EN_1V0X_LBN));
+	if (rc != out) {
+		netif_info(efx, hw, efx->net_dev, "power-cycling PHY\n");
+		rc = i2c_smbus_write_byte_data(ioexp_client, P0_OUT, out);
+		if (rc)
+			goto fail_on;
+		schedule_timeout_uninterruptible(HZ);
+	}
+
+	for (i = 0; i < 20; ++i) {
+		/* Turn on 1.2V, 2.5V, 3.3V and 5V power rails */
+		out = 0xff & ~((1 << P0_EN_1V2_LBN) | (1 << P0_EN_2V5_LBN) |
+			       (1 << P0_EN_3V3X_LBN) | (1 << P0_EN_5V_LBN) |
+			       (1 << P0_X_TRST_LBN));
+		if (efx->phy_mode & PHY_MODE_SPECIAL)
+			out |= 1 << P0_EN_3V3X_LBN;
+
+		rc = i2c_smbus_write_byte_data(ioexp_client, P0_OUT, out);
+		if (rc)
+			goto fail_on;
+		msleep(10);
+
+		/* Turn on 1V power rail */
+		out &= ~(1 << P0_EN_1V0X_LBN);
+		rc = i2c_smbus_write_byte_data(ioexp_client, P0_OUT, out);
+		if (rc)
+			goto fail_on;
+
+		netif_info(efx, hw, efx->net_dev,
+			   "waiting for DSP boot (attempt %d)...\n", i);
+
+		/* In flash config mode, DSP does not turn on AFE, so
+		 * just wait 1 second.
+		 */
+		if (efx->phy_mode & PHY_MODE_SPECIAL) {
+			schedule_timeout_uninterruptible(HZ);
+			return 0;
+		}
+
+		for (j = 0; j < 10; ++j) {
+			msleep(100);
+
+			/* Check DSP has asserted AFE power line */
+			rc = i2c_smbus_read_byte_data(ioexp_client, P1_IN);
+			if (rc < 0)
+				goto fail_on;
+			if (rc & (1 << P1_AFE_PWD_LBN))
+				return 0;
+		}
+	}
+
+	netif_info(efx, hw, efx->net_dev, "timed out waiting for DSP boot\n");
+	rc = -ETIMEDOUT;
+fail_on:
+	sfe4001_poweroff(efx);
+	return rc;
+}
+
+static ssize_t show_phy_flash_cfg(struct device *dev,
+				  struct device_attribute *attr, char *buf)
+{
+	struct efx_nic *efx = pci_get_drvdata(to_pci_dev(dev));
+	return sprintf(buf, "%d\n", !!(efx->phy_mode & PHY_MODE_SPECIAL));
+}
+
+static ssize_t set_phy_flash_cfg(struct device *dev,
+				 struct device_attribute *attr,
+				 const char *buf, size_t count)
+{
+	struct efx_nic *efx = pci_get_drvdata(to_pci_dev(dev));
+	enum efx_phy_mode old_mode, new_mode;
+	int err;
+
+	rtnl_lock();
+	old_mode = efx->phy_mode;
+	if (count == 0 || *buf == '0')
+		new_mode = old_mode & ~PHY_MODE_SPECIAL;
+	else
+		new_mode = PHY_MODE_SPECIAL;
+	if (!((old_mode ^ new_mode) & PHY_MODE_SPECIAL)) {
+		err = 0;
+	} else if (efx->state != STATE_RUNNING || netif_running(efx->net_dev)) {
+		err = -EBUSY;
+	} else {
+		/* Reset the PHY, reconfigure the MAC and enable/disable
+		 * MAC stats accordingly. */
+		efx->phy_mode = new_mode;
+		if (new_mode & PHY_MODE_SPECIAL)
+			falcon_stop_nic_stats(efx);
+		err = sfe4001_poweron(efx);
+		if (!err)
+			err = efx_reconfigure_port(efx);
+		if (!(new_mode & PHY_MODE_SPECIAL))
+			falcon_start_nic_stats(efx);
+	}
+	rtnl_unlock();
+
+	return err ? err : count;
+}
+
+static DEVICE_ATTR(phy_flash_cfg, 0644, show_phy_flash_cfg, set_phy_flash_cfg);
+
+static void sfe4001_fini(struct efx_nic *efx)
+{
+	struct falcon_board *board = falcon_board(efx);
+
+	netif_info(efx, drv, efx->net_dev, "%s\n", __func__);
+
+	device_remove_file(&efx->pci_dev->dev, &dev_attr_phy_flash_cfg);
+	sfe4001_poweroff(efx);
+	i2c_unregister_device(board->ioexp_client);
+	i2c_unregister_device(board->hwmon_client);
+}
+
+static int sfe4001_check_hw(struct efx_nic *efx)
+{
+	s32 status;
+
+	/* If XAUI link is up then do not monitor */
+	if (EFX_WORKAROUND_7884(efx) && !efx->xmac_poll_required)
+		return 0;
+	if (efx->phy_mode != PHY_MODE_NORMAL)
+		return 0;
+
+	/* Check the powered status of the PHY. Lack of power implies that
+	 * the MAX6647 has shut down power to it, probably due to a temp.
+	 * alarm. Reading the power status rather than the MAX6647 status
+	 * directly because the later is read-to-clear and would thus
+	 * start to power up the PHY again when polled, causing us to blip
+	 * the power undesirably.
+	 * We know we can read from the IO expander because we did
+	 * it during power-on. Assume failure now is bad news. */
+	status = i2c_smbus_read_byte_data(falcon_board(efx)->ioexp_client, P1_IN);
+	if (status >= 0 &&
+	    (status & ((1 << P1_AFE_PWD_LBN) | (1 << P1_DSP_PWD25_LBN))) != 0)
+		return 0;
+
+	/* Use board power control, not PHY power control */
+	sfe4001_poweroff(efx);
+	efx->phy_mode = PHY_MODE_OFF;
+
+	return (status < 0) ? -EIO : -ERANGE;
+}
+
+#ifdef CONFIG_SFC_HWMON
+static struct i2c_board_info sfe4001_hwmon_info = {
+	I2C_BOARD_INFO("max6647", 0x4e),
+};
+#endif
+
+/* This board uses an I2C expander to provider power to the PHY, which needs to
+ * be turned on before the PHY can be used.
+ * Context: Process context, rtnl lock held
+ */
+static int sfe4001_init(struct efx_nic *efx)
+{
+	struct falcon_board *board = falcon_board(efx);
+	int rc;
+
+#ifdef CONFIG_SFC_HWMON
+	board->hwmon_client =
+		i2c_new_device(&board->i2c_adap, &sfe4001_hwmon_info);
+#else
+	board->hwmon_client = i2c_new_dummy(&board->i2c_adap, 0x4e);
+#endif
+	if (!board->hwmon_client)
+		return -EIO;
+
+	/* Raise board/PHY high limit from 85 to 90 degrees Celsius */
+	rc = i2c_smbus_write_byte_data(board->hwmon_client,
+				       MAX664X_REG_WLHO, 90);
+	if (rc)
+		goto fail_hwmon;
+
+	board->ioexp_client = i2c_new_dummy(&board->i2c_adap, PCA9539);
+	if (!board->ioexp_client) {
+		rc = -EIO;
+		goto fail_hwmon;
+	}
+
+	if (efx->phy_mode & PHY_MODE_SPECIAL) {
+		/* PHY won't generate a 156.25 MHz clock and MAC stats fetch
+		 * will fail. */
+		falcon_stop_nic_stats(efx);
+	}
+	rc = sfe4001_poweron(efx);
+	if (rc)
+		goto fail_ioexp;
+
+	rc = device_create_file(&efx->pci_dev->dev, &dev_attr_phy_flash_cfg);
+	if (rc)
+		goto fail_on;
+
+	netif_info(efx, hw, efx->net_dev, "PHY is powered on\n");
+	return 0;
+
+fail_on:
+	sfe4001_poweroff(efx);
+fail_ioexp:
+	i2c_unregister_device(board->ioexp_client);
+fail_hwmon:
+	i2c_unregister_device(board->hwmon_client);
+	return rc;
+}
+
+#endif /* CONFIG_SFC_SFE4001 */
+
+/*****************************************************************************
+ * Support for the SFE4002
+ *
+ */
+static u8 sfe4002_lm87_channel = 0x03; /* use AIN not FAN inputs */
+
+static const u8 sfe4002_lm87_regs[] = {
+	LM87_IN_LIMITS(0, 0x7c, 0x99),		/* 2.5V:  1.8V +/- 10% */
+	LM87_IN_LIMITS(1, 0x4c, 0x5e),		/* Vccp1: 1.2V +/- 10% */
+	LM87_IN_LIMITS(2, 0xac, 0xd4),		/* 3.3V:  3.3V +/- 10% */
+	LM87_IN_LIMITS(3, 0xac, 0xd4),		/* 5V:    5.0V +/- 10% */
+	LM87_IN_LIMITS(4, 0xac, 0xe0),		/* 12V:   10.8-14V */
+	LM87_IN_LIMITS(5, 0x3f, 0x4f),		/* Vccp2: 1.0V +/- 10% */
+	LM87_AIN_LIMITS(0, 0x98, 0xbb),		/* AIN1:  1.66V +/- 10% */
+	LM87_AIN_LIMITS(1, 0x8a, 0xa9),		/* AIN2:  1.5V +/- 10% */
+	LM87_TEMP_INT_LIMITS(0, 80 + FALCON_BOARD_TEMP_BIAS),
+	0
+};
+
+static struct i2c_board_info sfe4002_hwmon_info = {
+#if !defined(EFX_USE_KCOMPAT) || !defined(EFX_NEED_LM87_DRIVER)
+	I2C_BOARD_INFO("lm87", 0x2e),
+#else
+	I2C_BOARD_INFO("sfc_lm87", 0x2e),
+#endif
+	.platform_data	= &sfe4002_lm87_channel,
+};
+
+/****************************************************************************/
+/* LED allocations. Note that on rev A0 boards the schematic and the reality
+ * differ: red and green are swapped. Below is the fixed (A1) layout (there
+ * are only 3 A0 boards in existence, so no real reason to make this
+ * conditional).
+ */
+#define SFE4002_FAULT_LED (2)	/* Red */
+#define SFE4002_RX_LED    (0)	/* Green */
+#define SFE4002_TX_LED    (1)	/* Amber */
+
+static void sfe4002_init_phy(struct efx_nic *efx)
+{
+	/* Set the TX and RX LEDs to reflect status and activity, and the
+	 * fault LED off */
+	falcon_qt202x_set_led(efx, SFE4002_TX_LED,
+			      QUAKE_LED_TXLINK | QUAKE_LED_LINK_ACTSTAT);
+	falcon_qt202x_set_led(efx, SFE4002_RX_LED,
+			      QUAKE_LED_RXLINK | QUAKE_LED_LINK_ACTSTAT);
+	falcon_qt202x_set_led(efx, SFE4002_FAULT_LED, QUAKE_LED_OFF);
+}
+
+static void sfe4002_set_id_led(struct efx_nic *efx, enum efx_led_mode mode)
+{
+	falcon_qt202x_set_led(
+		efx, SFE4002_FAULT_LED,
+		(mode == EFX_LED_ON) ? QUAKE_LED_ON : QUAKE_LED_OFF);
+}
+
+static int sfe4002_check_hw(struct efx_nic *efx)
+{
+	struct falcon_board *board = falcon_board(efx);
+
+	/* A0 board rev. 4002s report a temperature fault the whole time
+	 * (bad sensor) so we mask it out. */
+	unsigned alarm_mask =
+		(board->major == 0 && board->minor == 0) ?
+		~LM87_ALARM_TEMP_EXT1 : ~0;
+
+	return efx_check_lm87(efx, alarm_mask);
+}
+
+static int sfe4002_init(struct efx_nic *efx)
+{
+	return efx_init_lm87(efx, &sfe4002_hwmon_info, sfe4002_lm87_regs);
+}
+
+/*****************************************************************************
+ * Support for the SFN4112F
+ *
+ */
+static u8 sfn4112f_lm87_channel = 0x03; /* use AIN not FAN inputs */
+
+static const u8 sfn4112f_lm87_regs[] = {
+	LM87_IN_LIMITS(0, 0x7c, 0x99),		/* 2.5V:  1.8V +/- 10% */
+	LM87_IN_LIMITS(1, 0x4c, 0x5e),		/* Vccp1: 1.2V +/- 10% */
+	LM87_IN_LIMITS(2, 0xac, 0xd4),		/* 3.3V:  3.3V +/- 10% */
+	LM87_IN_LIMITS(4, 0xac, 0xe0),		/* 12V:   10.8-14V */
+	LM87_IN_LIMITS(5, 0x3f, 0x4f),		/* Vccp2: 1.0V +/- 10% */
+	LM87_AIN_LIMITS(1, 0x8a, 0xa9),		/* AIN2:  1.5V +/- 10% */
+	LM87_TEMP_INT_LIMITS(0, 60 + FALCON_BOARD_TEMP_BIAS),
+	0
+};
+
+static struct i2c_board_info sfn4112f_hwmon_info = {
+#if !defined(EFX_USE_KCOMPAT) || !defined(EFX_NEED_LM87_DRIVER)
+	I2C_BOARD_INFO("lm87", 0x2e),
+#else
+	I2C_BOARD_INFO("sfc_lm87", 0x2e),
+#endif
+	.platform_data	= &sfn4112f_lm87_channel,
+};
+
+#define SFN4112F_ACT_LED	0
+#define SFN4112F_LINK_LED	1
+
+static void sfn4112f_init_phy(struct efx_nic *efx)
+{
+	falcon_qt202x_set_led(efx, SFN4112F_ACT_LED,
+			      QUAKE_LED_RXLINK | QUAKE_LED_LINK_ACT);
+	falcon_qt202x_set_led(efx, SFN4112F_LINK_LED,
+			      QUAKE_LED_RXLINK | QUAKE_LED_LINK_STAT);
+}
+
+static void sfn4112f_set_id_led(struct efx_nic *efx, enum efx_led_mode mode)
+{
+	int reg;
+
+	switch (mode) {
+	case EFX_LED_OFF:
+		reg = QUAKE_LED_OFF;
+		break;
+	case EFX_LED_ON:
+		reg = QUAKE_LED_ON;
+		break;
+	default:
+		reg = QUAKE_LED_RXLINK | QUAKE_LED_LINK_STAT;
+		break;
+	}
+
+	falcon_qt202x_set_led(efx, SFN4112F_LINK_LED, reg);
+}
+
+static int sfn4112f_check_hw(struct efx_nic *efx)
+{
+	/* Mask out unused sensors */
+	return efx_check_lm87(efx, ~0x48);
+}
+
+static int sfn4112f_init(struct efx_nic *efx)
+{
+	return efx_init_lm87(efx, &sfn4112f_hwmon_info, sfn4112f_lm87_regs);
+}
+
+/*****************************************************************************
+ * Support for the SFE4003
+ *
+ */
+static u8 sfe4003_lm87_channel = 0x03; /* use AIN not FAN inputs */
+
+static const u8 sfe4003_lm87_regs[] = {
+	LM87_IN_LIMITS(0, 0x67, 0x7f),		/* 2.5V:  1.5V +/- 10% */
+	LM87_IN_LIMITS(1, 0x4c, 0x5e),		/* Vccp1: 1.2V +/- 10% */
+	LM87_IN_LIMITS(2, 0xac, 0xd4),		/* 3.3V:  3.3V +/- 10% */
+	LM87_IN_LIMITS(4, 0xac, 0xe0),		/* 12V:   10.8-14V */
+	LM87_IN_LIMITS(5, 0x3f, 0x4f),		/* Vccp2: 1.0V +/- 10% */
+	LM87_TEMP_INT_LIMITS(0, 70 + FALCON_BOARD_TEMP_BIAS),
+	0
+};
+
+static struct i2c_board_info sfe4003_hwmon_info = {
+#if !defined(EFX_USE_KCOMPAT) || !defined(EFX_NEED_LM87_DRIVER)
+	I2C_BOARD_INFO("lm87", 0x2e),
+#else
+	I2C_BOARD_INFO("sfc_lm87", 0x2e),
+#endif
+	.platform_data	= &sfe4003_lm87_channel,
+};
+
+/* Board-specific LED info. */
+#define SFE4003_RED_LED_GPIO	11
+#define SFE4003_LED_ON		1
+#define SFE4003_LED_OFF		0
+
+static void sfe4003_set_id_led(struct efx_nic *efx, enum efx_led_mode mode)
+{
+	struct falcon_board *board = falcon_board(efx);
+
+	/* The LEDs were not wired to GPIOs before A3 */
+	if (board->minor < 3 && board->major == 0)
+		return;
+
+	falcon_txc_set_gpio_val(
+		efx, SFE4003_RED_LED_GPIO,
+		(mode == EFX_LED_ON) ? SFE4003_LED_ON : SFE4003_LED_OFF);
+}
+
+static void sfe4003_init_phy(struct efx_nic *efx)
+{
+	struct falcon_board *board = falcon_board(efx);
+
+	/* The LEDs were not wired to GPIOs before A3 */
+	if (board->minor < 3 && board->major == 0)
+		return;
+
+	falcon_txc_set_gpio_dir(efx, SFE4003_RED_LED_GPIO, TXC_GPIO_DIR_OUTPUT);
+	falcon_txc_set_gpio_val(efx, SFE4003_RED_LED_GPIO, SFE4003_LED_OFF);
+}
+
+static int sfe4003_check_hw(struct efx_nic *efx)
+{
+	struct falcon_board *board = falcon_board(efx);
+
+	/* A0/A1/A2 board rev. 4003s  report a temperature fault the whole time
+	 * (bad sensor) so we mask it out. */
+	unsigned alarm_mask =
+		(board->major == 0 && board->minor <= 2) ?
+		~LM87_ALARM_TEMP_EXT1 : ~0;
+
+	return efx_check_lm87(efx, alarm_mask);
+}
+
+static int sfe4003_init(struct efx_nic *efx)
+{
+	return efx_init_lm87(efx, &sfe4003_hwmon_info, sfe4003_lm87_regs);
+}
+
+static const struct falcon_board_type board_types[] = {
+#ifdef CONFIG_SFC_SFE4001
+	{
+		.id		= FALCON_BOARD_SFE4001,
+		.ref_model	= "SFE4001",
+		.gen_type	= "10GBASE-T adapter",
+		.init		= sfe4001_init,
+		.init_phy	= efx_port_dummy_op_void,
+		.fini		= sfe4001_fini,
+		.set_id_led	= tenxpress_set_id_led,
+		.monitor	= sfe4001_check_hw,
+	},
+#endif
+	{
+		.id		= FALCON_BOARD_SFE4002,
+		.ref_model	= "SFE4002",
+		.gen_type	= "XFP adapter",
+		.init		= sfe4002_init,
+		.init_phy	= sfe4002_init_phy,
+		.fini		= efx_fini_lm87,
+		.set_id_led	= sfe4002_set_id_led,
+		.monitor	= sfe4002_check_hw,
+	},
+	{
+		.id		= FALCON_BOARD_SFE4003,
+		.ref_model	= "SFE4003",
+		.gen_type	= "10GBASE-CX4 adapter",
+		.init		= sfe4003_init,
+		.init_phy	= sfe4003_init_phy,
+		.fini		= efx_fini_lm87,
+		.set_id_led	= sfe4003_set_id_led,
+		.monitor	= sfe4003_check_hw,
+	},
+	{
+		.id		= FALCON_BOARD_SFN4112F,
+		.ref_model	= "SFN4112F",
+		.gen_type	= "SFP+ adapter",
+		.init		= sfn4112f_init,
+		.init_phy	= sfn4112f_init_phy,
+		.fini		= efx_fini_lm87,
+		.set_id_led	= sfn4112f_set_id_led,
+		.monitor	= sfn4112f_check_hw,
+	},
+};
+
+#ifdef EFX_NOT_UPSTREAM
+static void
+efx_port_dummy_op_set_id_led(struct efx_nic *efx, enum efx_led_mode mode)
+{
+}
+
+static const struct falcon_board_type falcon_dummy_board = {
+	.init		= efx_port_dummy_op_int,
+	.init_phy	= efx_port_dummy_op_void,
+	.fini		= efx_port_dummy_op_void,
+	.set_id_led	= efx_port_dummy_op_set_id_led,
+	.monitor	= efx_port_dummy_op_int,
+};
+
+void falcon_probe_dummy_board(struct efx_nic *efx)
+{
+	falcon_board(efx)->type = &falcon_dummy_board;
+}
+#endif
+
+int falcon_probe_board(struct efx_nic *efx, u16 revision_info)
+{
+	struct falcon_board *board = falcon_board(efx);
+	u8 type_id = FALCON_BOARD_TYPE(revision_info);
+	int i;
+
+	board->major = FALCON_BOARD_MAJOR(revision_info);
+	board->minor = FALCON_BOARD_MINOR(revision_info);
+
+	for (i = 0; i < ARRAY_SIZE(board_types); i++)
+		if (board_types[i].id == type_id)
+			board->type = &board_types[i];
+
+	if (board->type) {
+		netif_info(efx, probe, efx->net_dev, "board is %s rev %c%d\n",
+			 (efx->pci_dev->subsystem_vendor == EFX_VENDID_SFC)
+			 ? board->type->ref_model : board->type->gen_type,
+			 'A' + board->major, board->minor);
+		return 0;
+	} else {
+		netif_err(efx, probe, efx->net_dev, "unknown board type %d\n",
+			  type_id);
+		return -ENODEV;
+	}
+}
diff -r 5b3d4d3c1166 drivers/net/sfc/falcon_gmac.c
--- a/drivers/net/sfc/falcon_gmac.c	Fri Nov 05 15:20:28 2010 +0000
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,229 +0,0 @@
-/****************************************************************************
- * Driver for Solarflare Solarstorm network controllers and boards
- * Copyright 2005-2006 Fen Systems Ltd.
- * Copyright 2006-2008 Solarflare Communications Inc.
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 as published
- * by the Free Software Foundation, incorporated herein by reference.
- */
-
-#include <linux/delay.h>
-#include "net_driver.h"
-#include "efx.h"
-#include "falcon.h"
-#include "mac.h"
-#include "falcon_hwdefs.h"
-#include "falcon_io.h"
-#include "gmii.h"
-
-/**************************************************************************
- *
- * MAC operations
- *
- *************************************************************************/
-
-static void falcon_reconfigure_gmac(struct efx_nic *efx)
-{
-	bool loopback, tx_fc, rx_fc, bytemode;
-	int if_mode;
-	unsigned int max_frame_len;
-	efx_oword_t reg;
-
-	/* Configuration register 1 */
-	tx_fc = (efx->link_fc & EFX_FC_TX) || !efx->link_fd;
-	rx_fc = !!(efx->link_fc & EFX_FC_RX);
-	loopback = (efx->loopback_mode == LOOPBACK_GMAC);
-	bytemode = (efx->link_speed == 1000);
-
-	EFX_POPULATE_OWORD_5(reg,
-			     GM_LOOP, loopback,
-			     GM_TX_EN, 1,
-			     GM_TX_FC_EN, tx_fc,
-			     GM_RX_EN, 1,
-			     GM_RX_FC_EN, rx_fc);
-	falcon_write(efx, &reg, GM_CFG1_REG);
-	udelay(10);
-
-	/* Configuration register 2 */
-	if_mode = (bytemode) ? 2 : 1;
-	EFX_POPULATE_OWORD_5(reg,
-			     GM_IF_MODE, if_mode,
-			     GM_PAD_CRC_EN, 1,
-			     GM_LEN_CHK, 1,
-			     GM_FD, efx->link_fd,
-			     GM_PAMBL_LEN, 0x7/*datasheet recommended */);
-
-	falcon_write(efx, &reg, GM_CFG2_REG);
-	udelay(10);
-
-	/* Max frame len register */
-	max_frame_len = EFX_MAX_FRAME_LEN(efx->net_dev->mtu);
-	EFX_POPULATE_OWORD_1(reg, GM_MAX_FLEN, max_frame_len);
-	falcon_write(efx, &reg, GM_MAX_FLEN_REG);
-	udelay(10);
-
-	/* FIFO configuration register 0 */
-	EFX_POPULATE_OWORD_5(reg,
-			     GMF_FTFENREQ, 1,
-			     GMF_STFENREQ, 1,
-			     GMF_FRFENREQ, 1,
-			     GMF_SRFENREQ, 1,
-			     GMF_WTMENREQ, 1);
-	falcon_write(efx, &reg, GMF_CFG0_REG);
-	udelay(10);
-
-	/* FIFO configuration register 1 */
-	EFX_POPULATE_OWORD_2(reg,
-			     GMF_CFGFRTH, 0x12,
-			     GMF_CFGXOFFRTX, 0xffff);
-	falcon_write(efx, &reg, GMF_CFG1_REG);
-	udelay(10);
-
-	/* FIFO configuration register 2 */
-	EFX_POPULATE_OWORD_2(reg,
-			     GMF_CFGHWM, 0x3f,
-			     GMF_CFGLWM, 0xa);
-	falcon_write(efx, &reg, GMF_CFG2_REG);
-	udelay(10);
-
-	/* FIFO configuration register 3 */
-	EFX_POPULATE_OWORD_2(reg,
-			     GMF_CFGHWMFT, 0x1c,
-			     GMF_CFGFTTH, 0x08);
-	falcon_write(efx, &reg, GMF_CFG3_REG);
-	udelay(10);
-
-	/* FIFO configuration register 4 */
-	EFX_POPULATE_OWORD_1(reg, GMF_HSTFLTRFRM_PAUSE, 1);
-	falcon_write(efx, &reg, GMF_CFG4_REG);
-	udelay(10);
-
-	/* FIFO configuration register 5 */
-	falcon_read(efx, &reg, GMF_CFG5_REG);
-	EFX_SET_OWORD_FIELD(reg, GMF_CFGBYTMODE, bytemode);
-	EFX_SET_OWORD_FIELD(reg, GMF_CFGHDPLX, !efx->link_fd);
-	EFX_SET_OWORD_FIELD(reg, GMF_HSTDRPLT64, !efx->link_fd);
-	EFX_SET_OWORD_FIELD(reg, GMF_HSTFLTRFRMDC_PAUSE, 0);
-	falcon_write(efx, &reg, GMF_CFG5_REG);
-	udelay(10);
-
-	/* MAC address */
-	EFX_POPULATE_OWORD_4(reg,
-			     GM_HWADDR_5, efx->net_dev->dev_addr[5],
-			     GM_HWADDR_4, efx->net_dev->dev_addr[4],
-			     GM_HWADDR_3, efx->net_dev->dev_addr[3],
-			     GM_HWADDR_2, efx->net_dev->dev_addr[2]);
-	falcon_write(efx, &reg, GM_ADR1_REG);
-	udelay(10);
-	EFX_POPULATE_OWORD_2(reg,
-			     GM_HWADDR_1, efx->net_dev->dev_addr[1],
-			     GM_HWADDR_0, efx->net_dev->dev_addr[0]);
-	falcon_write(efx, &reg, GM_ADR2_REG);
-	udelay(10);
-
-	falcon_reconfigure_mac_wrapper(efx);
-}
-
-static void falcon_update_stats_gmac(struct efx_nic *efx)
-{
-	struct efx_mac_stats *mac_stats = &efx->mac_stats;
-	unsigned long old_rx_pause, old_tx_pause;
-	unsigned long new_rx_pause, new_tx_pause;
-	int rc;
-
-	rc = falcon_dma_stats(efx, GDmaDone_offset);
-	if (rc)
-		return;
-
-	/* Pause frames are erroneously counted as errors (SFC bug 3269) */
-	old_rx_pause = mac_stats->rx_pause;
-	old_tx_pause = mac_stats->tx_pause;
-
-	/* Update MAC stats from DMAed values */
-	FALCON_STAT(efx, GRxGoodOct, rx_good_bytes);
-	FALCON_STAT(efx, GRxBadOct, rx_bad_bytes);
-	FALCON_STAT(efx, GRxMissPkt, rx_missed);
-	FALCON_STAT(efx, GRxFalseCRS, rx_false_carrier);
-	FALCON_STAT(efx, GRxPausePkt, rx_pause);
-	FALCON_STAT(efx, GRxBadPkt, rx_bad);
-	FALCON_STAT(efx, GRxUcastPkt, rx_unicast);
-	FALCON_STAT(efx, GRxMcastPkt, rx_multicast);
-	FALCON_STAT(efx, GRxBcastPkt, rx_broadcast);
-	FALCON_STAT(efx, GRxGoodLt64Pkt, rx_good_lt64);
-	FALCON_STAT(efx, GRxBadLt64Pkt, rx_bad_lt64);
-	FALCON_STAT(efx, GRx64Pkt, rx_64);
-	FALCON_STAT(efx, GRx65to127Pkt, rx_65_to_127);
-	FALCON_STAT(efx, GRx128to255Pkt, rx_128_to_255);
-	FALCON_STAT(efx, GRx256to511Pkt, rx_256_to_511);
-	FALCON_STAT(efx, GRx512to1023Pkt, rx_512_to_1023);
-	FALCON_STAT(efx, GRx1024to15xxPkt, rx_1024_to_15xx);
-	FALCON_STAT(efx, GRx15xxtoJumboPkt, rx_15xx_to_jumbo);
-	FALCON_STAT(efx, GRxGtJumboPkt, rx_gtjumbo);
-	FALCON_STAT(efx, GRxFcsErr64to15xxPkt, rx_bad_64_to_15xx);
-	FALCON_STAT(efx, GRxFcsErr15xxtoJumboPkt, rx_bad_15xx_to_jumbo);
-	FALCON_STAT(efx, GRxFcsErrGtJumboPkt, rx_bad_gtjumbo);
-	FALCON_STAT(efx, GTxGoodBadOct, tx_bytes);
-	FALCON_STAT(efx, GTxGoodOct, tx_good_bytes);
-	FALCON_STAT(efx, GTxSglColPkt, tx_single_collision);
-	FALCON_STAT(efx, GTxMultColPkt, tx_multiple_collision);
-	FALCON_STAT(efx, GTxExColPkt, tx_excessive_collision);
-	FALCON_STAT(efx, GTxDefPkt, tx_deferred);
-	FALCON_STAT(efx, GTxLateCol, tx_late_collision);
-	FALCON_STAT(efx, GTxExDefPkt, tx_excessive_deferred);
-	FALCON_STAT(efx, GTxPausePkt, tx_pause);
-	FALCON_STAT(efx, GTxBadPkt, tx_bad);
-	FALCON_STAT(efx, GTxUcastPkt, tx_unicast);
-	FALCON_STAT(efx, GTxMcastPkt, tx_multicast);
-	FALCON_STAT(efx, GTxBcastPkt, tx_broadcast);
-	FALCON_STAT(efx, GTxLt64Pkt, tx_lt64);
-	FALCON_STAT(efx, GTx64Pkt, tx_64);
-	FALCON_STAT(efx, GTx65to127Pkt, tx_65_to_127);
-	FALCON_STAT(efx, GTx128to255Pkt, tx_128_to_255);
-	FALCON_STAT(efx, GTx256to511Pkt, tx_256_to_511);
-	FALCON_STAT(efx, GTx512to1023Pkt, tx_512_to_1023);
-	FALCON_STAT(efx, GTx1024to15xxPkt, tx_1024_to_15xx);
-	FALCON_STAT(efx, GTx15xxtoJumboPkt, tx_15xx_to_jumbo);
-	FALCON_STAT(efx, GTxGtJumboPkt, tx_gtjumbo);
-	FALCON_STAT(efx, GTxNonTcpUdpPkt, tx_non_tcpudp);
-	FALCON_STAT(efx, GTxMacSrcErrPkt, tx_mac_src_error);
-	FALCON_STAT(efx, GTxIpSrcErrPkt, tx_ip_src_error);
-
-	/* Pause frames are erroneously counted as errors (SFC bug 3269) */
-	new_rx_pause = mac_stats->rx_pause;
-	new_tx_pause = mac_stats->tx_pause;
-	mac_stats->rx_bad -= (new_rx_pause - old_rx_pause);
-	mac_stats->tx_bad -= (new_tx_pause - old_tx_pause);
-
-	/* Derive stats that the MAC doesn't provide directly */
-	mac_stats->tx_bad_bytes =
-		mac_stats->tx_bytes - mac_stats->tx_good_bytes;
-	mac_stats->tx_packets =
-		mac_stats->tx_lt64 + mac_stats->tx_64 +
-		mac_stats->tx_65_to_127 + mac_stats->tx_128_to_255 +
-		mac_stats->tx_256_to_511 + mac_stats->tx_512_to_1023 +
-		mac_stats->tx_1024_to_15xx + mac_stats->tx_15xx_to_jumbo +
-		mac_stats->tx_gtjumbo;
-	mac_stats->tx_collision =
-		mac_stats->tx_single_collision +
-		mac_stats->tx_multiple_collision +
-		mac_stats->tx_excessive_collision +
-		mac_stats->tx_late_collision;
-	mac_stats->rx_bytes =
-		mac_stats->rx_good_bytes + mac_stats->rx_bad_bytes;
-	mac_stats->rx_packets =
-		mac_stats->rx_good_lt64 + mac_stats->rx_bad_lt64 +
-		mac_stats->rx_64 + mac_stats->rx_65_to_127 +
-		mac_stats->rx_128_to_255 + mac_stats->rx_256_to_511 +
-		mac_stats->rx_512_to_1023 + mac_stats->rx_1024_to_15xx +
-		mac_stats->rx_15xx_to_jumbo + mac_stats->rx_gtjumbo;
-	mac_stats->rx_good = mac_stats->rx_packets - mac_stats->rx_bad;
-	mac_stats->rx_lt64 = mac_stats->rx_good_lt64 + mac_stats->rx_bad_lt64;
-}
-
-struct efx_mac_operations falcon_gmac_operations = {
-	.reconfigure	= falcon_reconfigure_gmac,
-	.update_stats	= falcon_update_stats_gmac,
-	.irq		= efx_port_dummy_op_void,
-	.poll		= efx_port_dummy_op_void,
-};
diff -r 5b3d4d3c1166 drivers/net/sfc/falcon_hwdefs.h
--- a/drivers/net/sfc/falcon_hwdefs.h	Fri Nov 05 15:20:28 2010 +0000
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,1333 +0,0 @@
-/****************************************************************************
- * Driver for Solarflare Solarstorm network controllers and boards
- * Copyright 2005-2006 Fen Systems Ltd.
- * Copyright 2006-2008 Solarflare Communications Inc.
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 as published
- * by the Free Software Foundation, incorporated herein by reference.
- */
-
-#ifndef EFX_FALCON_HWDEFS_H
-#define EFX_FALCON_HWDEFS_H
-
-/*
- * Falcon hardware value definitions.
- * Falcon is the internal codename for the SFC4000 controller that is
- * present in SFE400X evaluation boards
- */
-
-/**************************************************************************
- *
- * Falcon registers
- *
- **************************************************************************
- */
-
-/* Address region register */
-#define ADR_REGION_REG_KER	0x00
-#define ADR_REGION0_LBN	0
-#define ADR_REGION0_WIDTH	18
-#define ADR_REGION1_LBN	32
-#define ADR_REGION1_WIDTH	18
-#define ADR_REGION2_LBN	64
-#define ADR_REGION2_WIDTH	18
-#define ADR_REGION3_LBN	96
-#define ADR_REGION3_WIDTH	18
-
-/* Interrupt enable register */
-#define INT_EN_REG_KER 0x0010
-#define KER_INT_KER_LBN 3
-#define KER_INT_KER_WIDTH 1
-#define DRV_INT_EN_KER_LBN 0
-#define DRV_INT_EN_KER_WIDTH 1
-
-/* Interrupt status address register */
-#define INT_ADR_REG_KER	0x0030
-#define NORM_INT_VEC_DIS_KER_LBN 64
-#define NORM_INT_VEC_DIS_KER_WIDTH 1
-#define INT_ADR_KER_LBN 0
-#define INT_ADR_KER_WIDTH EFX_DMA_TYPE_WIDTH(64) /* not 46 for this one */
-
-/* Interrupt status register (B0 only) */
-#define INT_ISR0_B0 0x90
-#define INT_ISR1_B0 0xA0
-
-/* Interrupt acknowledge register (A0/A1 only) */
-#define INT_ACK_REG_KER_A1 0x0050
-#define INT_ACK_DUMMY_DATA_LBN 0
-#define INT_ACK_DUMMY_DATA_WIDTH 32
-
-/* Interrupt acknowledge work-around register (A0/A1 only )*/
-#define WORK_AROUND_BROKEN_PCI_READS_REG_KER_A1 0x0070
-
-/* SPI host command register */
-#define EE_SPI_HCMD_REG_KER 0x0100
-#define EE_SPI_HCMD_CMD_EN_LBN 31
-#define EE_SPI_HCMD_CMD_EN_WIDTH 1
-#define EE_WR_TIMER_ACTIVE_LBN 28
-#define EE_WR_TIMER_ACTIVE_WIDTH 1
-#define EE_SPI_HCMD_SF_SEL_LBN 24
-#define EE_SPI_HCMD_SF_SEL_WIDTH 1
-#define EE_SPI_EEPROM 0
-#define EE_SPI_FLASH 1
-#define EE_SPI_HCMD_DABCNT_LBN 16
-#define EE_SPI_HCMD_DABCNT_WIDTH 5
-#define EE_SPI_HCMD_READ_LBN 15
-#define EE_SPI_HCMD_READ_WIDTH 1
-#define EE_SPI_READ 1
-#define EE_SPI_WRITE 0
-#define EE_SPI_HCMD_DUBCNT_LBN 12
-#define EE_SPI_HCMD_DUBCNT_WIDTH 2
-#define EE_SPI_HCMD_ADBCNT_LBN 8
-#define EE_SPI_HCMD_ADBCNT_WIDTH 2
-#define EE_SPI_HCMD_ENC_LBN 0
-#define EE_SPI_HCMD_ENC_WIDTH 8
-
-/* SPI host address register */
-#define EE_SPI_HADR_REG_KER 0x0110
-#define EE_SPI_HADR_ADR_LBN 0
-#define EE_SPI_HADR_ADR_WIDTH 24
-
-/* SPI host data register */
-#define EE_SPI_HDATA_REG_KER 0x0120
-
-/* SPI/VPD config register */
-#define EE_VPD_CFG_REG_KER 0x0140
-#define EE_VPD_EN_LBN 0
-#define EE_VPD_EN_WIDTH 1
-#define EE_VPD_EN_AD9_MODE_LBN 1
-#define EE_VPD_EN_AD9_MODE_WIDTH 1
-#define EE_EE_CLOCK_DIV_LBN 112
-#define EE_EE_CLOCK_DIV_WIDTH 7
-#define EE_SF_CLOCK_DIV_LBN 120
-#define EE_SF_CLOCK_DIV_WIDTH 7
-
-/* PCIE CORE ACCESS REG */
-#define PCIE_CORE_ADDR_PCIE_DEVICE_CTRL_STAT 0x68
-#define PCIE_CORE_ADDR_PCIE_LINK_CTRL_STAT 0x70
-#define PCIE_CORE_ADDR_ACK_RPL_TIMER 0x700
-#define PCIE_CORE_ADDR_ACK_FREQ 0x70C
-
-/* NIC status register */
-#define NIC_STAT_REG 0x0200
-#define EE_STRAP_EN_LBN 31
-#define EE_STRAP_EN_WIDTH 1
-#define EE_STRAP_OVR_LBN 24
-#define EE_STRAP_OVR_WIDTH 4
-#define ONCHIP_SRAM_LBN 16
-#define ONCHIP_SRAM_WIDTH 1
-#define SF_PRST_LBN 9
-#define SF_PRST_WIDTH 1
-#define EE_PRST_LBN 8
-#define EE_PRST_WIDTH 1
-#define STRAP_PINS_LBN 0
-#define STRAP_PINS_WIDTH 3
-/* These bit definitions are extrapolated from the list of numerical
- * values for STRAP_PINS.
- */
-#define STRAP_10G_LBN 2
-#define STRAP_10G_WIDTH 1
-#define STRAP_PCIE_LBN 0
-#define STRAP_PCIE_WIDTH 1
-
-#define BOOTED_USING_NVDEVICE_LBN 3
-#define BOOTED_USING_NVDEVICE_WIDTH 1
-
-/* GPIO control register */
-#define GPIO_CTL_REG_KER 0x0210
-#define GPIO_USE_NIC_CLK_LBN (30)
-#define GPIO_USE_NIC_CLK_WIDTH (1)
-#define GPIO_OUTPUTS_LBN   (16)
-#define GPIO_OUTPUTS_WIDTH (4)
-#define GPIO_INPUTS_LBN (8)
-#define GPIO_DIRECTION_LBN (24)
-#define GPIO_DIRECTION_WIDTH (4)
-#define GPIO_DIRECTION_OUT (1)
-#define GPIO_SRAM_SLEEP (1 << 1)
-
-#define GPIO3_OEN_LBN (GPIO_DIRECTION_LBN + 3)
-#define	GPIO3_OEN_WIDTH 1
-#define	GPIO2_OEN_LBN (GPIO_DIRECTION_LBN + 2)
-#define	GPIO2_OEN_WIDTH 1
-#define	GPIO1_OEN_LBN (GPIO_DIRECTION_LBN + 1)
-#define	GPIO1_OEN_WIDTH 1
-#define GPIO0_OEN_LBN (GPIO_DIRECTION_LBN + 0)
-#define	GPIO0_OEN_WIDTH 1
-
-#define	GPIO3_OUT_LBN (GPIO_OUTPUTS_LBN + 3)
-#define	GPIO3_OUT_WIDTH 1
-#define	GPIO2_OUT_LBN (GPIO_OUTPUTS_LBN + 2)
-#define	GPIO2_OUT_WIDTH 1
-#define	GPIO1_OUT_LBN (GPIO_OUTPUTS_LBN + 1)
-#define	GPIO1_OUT_WIDTH 1
-#define	GPIO0_OUT_LBN (GPIO_OUTPUTS_LBN + 0)
-#define	GPIO0_OUT_WIDTH 1
-
-#define GPIO3_IN_LBN (GPIO_INPUTS_LBN + 3)
-#define	GPIO3_IN_WIDTH 1
-#define	GPIO2_IN_WIDTH 1
-#define	GPIO1_IN_WIDTH 1
-#define GPIO0_IN_LBN (GPIO_INPUTS_LBN + 0)
-#define	GPIO0_IN_WIDTH 1
-
-/* Global control register */
-#define GLB_CTL_REG_KER	0x0220
-#define EXT_PHY_RST_CTL_LBN 63
-#define EXT_PHY_RST_CTL_WIDTH 1
-#define PCIE_SD_RST_CTL_LBN 61
-#define PCIE_SD_RST_CTL_WIDTH 1
-
-#define PCIE_NSTCK_RST_CTL_LBN 58
-#define PCIE_NSTCK_RST_CTL_WIDTH 1
-#define PCIE_CORE_RST_CTL_LBN 57
-#define PCIE_CORE_RST_CTL_WIDTH 1
-#define EE_RST_CTL_LBN 49
-#define EE_RST_CTL_WIDTH 1
-#define RST_XGRX_LBN 24
-#define RST_XGRX_WIDTH 1
-#define RST_XGTX_LBN 23
-#define RST_XGTX_WIDTH 1
-#define RST_EM_LBN 22
-#define RST_EM_WIDTH 1
-#define EXT_PHY_RST_DUR_LBN 1
-#define EXT_PHY_RST_DUR_WIDTH 3
-#define SWRST_LBN 0
-#define SWRST_WIDTH 1
-#define INCLUDE_IN_RESET 0
-#define EXCLUDE_FROM_RESET 1
-
-/* Fatal interrupt register */
-#define FATAL_INTR_REG_KER 0x0230
-#define RBUF_OWN_INT_KER_EN_LBN 39
-#define RBUF_OWN_INT_KER_EN_WIDTH 1
-#define TBUF_OWN_INT_KER_EN_LBN 38
-#define TBUF_OWN_INT_KER_EN_WIDTH 1
-#define ILL_ADR_INT_KER_EN_LBN 33
-#define ILL_ADR_INT_KER_EN_WIDTH 1
-#define MEM_PERR_INT_KER_LBN 8
-#define MEM_PERR_INT_KER_WIDTH 1
-#define INT_KER_ERROR_LBN 0
-#define INT_KER_ERROR_WIDTH 12
-
-#define DP_CTRL_REG 0x250
-#define FLS_EVQ_ID_LBN 0
-#define FLS_EVQ_ID_WIDTH 11
-
-#define MEM_STAT_REG_KER 0x260
-
-/* Debug probe register */
-#define DEBUG_BLK_SEL_MISC 7
-#define DEBUG_BLK_SEL_SERDES 6
-#define DEBUG_BLK_SEL_EM 5
-#define DEBUG_BLK_SEL_SR 4
-#define DEBUG_BLK_SEL_EV 3
-#define DEBUG_BLK_SEL_RX 2
-#define DEBUG_BLK_SEL_TX 1
-#define DEBUG_BLK_SEL_BIU 0
-
-/* FPGA build version */
-#define ALTERA_BUILD_REG_KER 0x0300
-#define VER_ALL_LBN 0
-#define VER_ALL_WIDTH 32
-
-/* Spare EEPROM bits register (flash 0x390) */
-#define SPARE_REG_KER 0x310
-#define MEM_PERR_EN_TX_DATA_LBN 72
-#define MEM_PERR_EN_TX_DATA_WIDTH 2
-
-/* Timer table for kernel access */
-#define TIMER_CMD_REG_KER 0x420
-#define TIMER_MODE_LBN 12
-#define TIMER_MODE_WIDTH 2
-#define TIMER_MODE_DIS 0
-#define TIMER_MODE_INT_HLDOFF 2
-#define TIMER_VAL_LBN 0
-#define TIMER_VAL_WIDTH 12
-
-/* Driver generated event register */
-#define DRV_EV_REG_KER 0x440
-#define DRV_EV_QID_LBN 64
-#define DRV_EV_QID_WIDTH 12
-#define DRV_EV_DATA_LBN 0
-#define DRV_EV_DATA_WIDTH 64
-
-/* Buffer table configuration register */
-#define BUF_TBL_CFG_REG_KER 0x600
-#define BUF_TBL_MODE_LBN 3
-#define BUF_TBL_MODE_WIDTH 1
-#define BUF_TBL_MODE_HALF 0
-#define BUF_TBL_MODE_FULL 1
-
-/* SRAM receive descriptor cache configuration register */
-#define SRM_RX_DC_CFG_REG_KER 0x610
-#define SRM_RX_DC_BASE_ADR_LBN 0
-#define SRM_RX_DC_BASE_ADR_WIDTH 21
-
-/* SRAM transmit descriptor cache configuration register */
-#define SRM_TX_DC_CFG_REG_KER 0x620
-#define SRM_TX_DC_BASE_ADR_LBN 0
-#define SRM_TX_DC_BASE_ADR_WIDTH 21
-
-/* SRAM configuration register */
-#define SRM_CFG_REG_KER 0x630
-#define SRAM_OOB_BT_INIT_EN_LBN 3
-#define SRAM_OOB_BT_INIT_EN_WIDTH 1
-#define SRM_NUM_BANKS_AND_BANK_SIZE_LBN 0
-#define SRM_NUM_BANKS_AND_BANK_SIZE_WIDTH 3
-#define SRM_NB_BSZ_1BANKS_2M 0
-#define SRM_NB_BSZ_1BANKS_4M 1
-#define SRM_NB_BSZ_1BANKS_8M 2
-#define SRM_NB_BSZ_DEFAULT 3 /* char driver will set the default */
-#define SRM_NB_BSZ_2BANKS_4M 4
-#define SRM_NB_BSZ_2BANKS_8M 5
-#define SRM_NB_BSZ_2BANKS_16M 6
-#define SRM_NB_BSZ_RESERVED 7
-
-/* Special buffer table update register */
-#define BUF_TBL_UPD_REG_KER 0x0650
-#define BUF_UPD_CMD_LBN 63
-#define BUF_UPD_CMD_WIDTH 1
-#define BUF_CLR_CMD_LBN 62
-#define BUF_CLR_CMD_WIDTH 1
-#define BUF_CLR_END_ID_LBN 32
-#define BUF_CLR_END_ID_WIDTH 20
-#define BUF_CLR_START_ID_LBN 0
-#define BUF_CLR_START_ID_WIDTH 20
-
-/* Receive configuration register */
-#define RX_CFG_REG_KER 0x800
-
-/* B0 */
-#define RX_INGR_EN_B0_LBN 47
-#define RX_INGR_EN_B0_WIDTH 1
-#define RX_DESC_PUSH_EN_B0_LBN 43
-#define RX_DESC_PUSH_EN_B0_WIDTH 1
-#define RX_XON_TX_TH_B0_LBN 33
-#define RX_XON_TX_TH_B0_WIDTH 5
-#define RX_XOFF_TX_TH_B0_LBN 28
-#define RX_XOFF_TX_TH_B0_WIDTH 5
-#define RX_USR_BUF_SIZE_B0_LBN 19
-#define RX_USR_BUF_SIZE_B0_WIDTH 9
-#define RX_XON_MAC_TH_B0_LBN 10
-#define RX_XON_MAC_TH_B0_WIDTH 9
-#define RX_XOFF_MAC_TH_B0_LBN 1
-#define RX_XOFF_MAC_TH_B0_WIDTH 9
-#define RX_XOFF_MAC_EN_B0_LBN 0
-#define RX_XOFF_MAC_EN_B0_WIDTH 1
-
-/* A1 */
-#define RX_DESC_PUSH_EN_A1_LBN 35
-#define RX_DESC_PUSH_EN_A1_WIDTH 1
-#define RX_XON_TX_TH_A1_LBN 25
-#define RX_XON_TX_TH_A1_WIDTH 5
-#define RX_XOFF_TX_TH_A1_LBN 20
-#define RX_XOFF_TX_TH_A1_WIDTH 5
-#define RX_USR_BUF_SIZE_A1_LBN 11
-#define RX_USR_BUF_SIZE_A1_WIDTH 9
-#define RX_XON_MAC_TH_A1_LBN 6
-#define RX_XON_MAC_TH_A1_WIDTH 5
-#define RX_XOFF_MAC_TH_A1_LBN 1
-#define RX_XOFF_MAC_TH_A1_WIDTH 5
-#define RX_XOFF_MAC_EN_A1_LBN 0
-#define RX_XOFF_MAC_EN_A1_WIDTH 1
-
-/* Receive filter control register */
-#define RX_FILTER_CTL_REG 0x810
-#define UDP_FULL_SRCH_LIMIT_LBN 32
-#define UDP_FULL_SRCH_LIMIT_WIDTH 8
-#define NUM_KER_LBN 24
-#define NUM_KER_WIDTH 2
-#define UDP_WILD_SRCH_LIMIT_LBN 16
-#define UDP_WILD_SRCH_LIMIT_WIDTH 8
-#define TCP_WILD_SRCH_LIMIT_LBN 8
-#define TCP_WILD_SRCH_LIMIT_WIDTH 8
-#define TCP_FULL_SRCH_LIMIT_LBN 0
-#define TCP_FULL_SRCH_LIMIT_WIDTH 8
-
-/* RX queue flush register */
-#define RX_FLUSH_DESCQ_REG_KER 0x0820
-#define RX_FLUSH_DESCQ_CMD_LBN 24
-#define RX_FLUSH_DESCQ_CMD_WIDTH 1
-#define RX_FLUSH_DESCQ_LBN 0
-#define RX_FLUSH_DESCQ_WIDTH 12
-
-/* Receive descriptor update register */
-#define RX_DESC_UPD_REG_KER_DWORD (0x830 + 12)
-#define RX_DESC_WPTR_DWORD_LBN 0
-#define RX_DESC_WPTR_DWORD_WIDTH 12
-
-/* Receive descriptor cache configuration register */
-#define RX_DC_CFG_REG_KER 0x840
-#define RX_DC_SIZE_LBN 0
-#define RX_DC_SIZE_WIDTH 2
-
-#define RX_DC_PF_WM_REG_KER 0x850
-#define RX_DC_PF_LWM_LBN 0
-#define RX_DC_PF_LWM_WIDTH 6
-
-/* RX no descriptor drop counter */
-#define RX_NODESC_DROP_REG_KER 0x880
-#define RX_NODESC_DROP_CNT_LBN 0
-#define RX_NODESC_DROP_CNT_WIDTH 16
-
-/* RX black magic register */
-#define RX_SELF_RST_REG_KER 0x890
-#define RX_ISCSI_DIS_LBN 17
-#define RX_ISCSI_DIS_WIDTH 1
-#define RX_NODESC_WAIT_DIS_LBN 9
-#define RX_NODESC_WAIT_DIS_WIDTH 1
-#define RX_RECOVERY_EN_LBN 8
-#define RX_RECOVERY_EN_WIDTH 1
-
-/* TX queue flush register */
-#define TX_FLUSH_DESCQ_REG_KER 0x0a00
-#define TX_FLUSH_DESCQ_CMD_LBN 12
-#define TX_FLUSH_DESCQ_CMD_WIDTH 1
-#define TX_FLUSH_DESCQ_LBN 0
-#define TX_FLUSH_DESCQ_WIDTH 12
-
-/* Transmit descriptor update register */
-#define TX_DESC_UPD_REG_KER_DWORD (0xa10 + 12)
-#define TX_DESC_WPTR_DWORD_LBN 0
-#define TX_DESC_WPTR_DWORD_WIDTH 12
-
-/* Transmit descriptor cache configuration register */
-#define TX_DC_CFG_REG_KER 0xa20
-#define TX_DC_SIZE_LBN 0
-#define TX_DC_SIZE_WIDTH 2
-
-/* Transmit checksum configuration register (A0/A1 only) */
-#define TX_CHKSM_CFG_REG_KER_A1 0xa30
-
-/* Transmit configuration register */
-#define TX_CFG_REG_KER 0xa50
-#define TX_NO_EOP_DISC_EN_LBN 5
-#define TX_NO_EOP_DISC_EN_WIDTH 1
-
-/* Transmit configuration register 2 */
-#define TX_CFG2_REG_KER 0xa80
-#define TX_CSR_PUSH_EN_LBN 89
-#define TX_CSR_PUSH_EN_WIDTH 1
-#define TX_RX_SPACER_LBN 64
-#define TX_RX_SPACER_WIDTH 8
-#define TX_SW_EV_EN_LBN 59
-#define TX_SW_EV_EN_WIDTH 1
-#define TX_RX_SPACER_EN_LBN 57
-#define TX_RX_SPACER_EN_WIDTH 1
-#define TX_PREF_THRESHOLD_LBN 19
-#define TX_PREF_THRESHOLD_WIDTH 2
-#define TX_ONE_PKT_PER_Q_LBN 18
-#define TX_ONE_PKT_PER_Q_WIDTH 1
-#define TX_DIS_NON_IP_EV_LBN 17
-#define TX_DIS_NON_IP_EV_WIDTH 1
-#define TX_FLUSH_MIN_LEN_EN_B0_LBN 7
-#define TX_FLUSH_MIN_LEN_EN_B0_WIDTH 1
-
-/* PHY management transmit data register */
-#define MD_TXD_REG_KER 0xc00
-#define MD_TXD_LBN 0
-#define MD_TXD_WIDTH 16
-
-/* PHY management receive data register */
-#define MD_RXD_REG_KER 0xc10
-#define MD_RXD_LBN 0
-#define MD_RXD_WIDTH 16
-
-/* PHY management configuration & status register */
-#define MD_CS_REG_KER 0xc20
-#define MD_GC_LBN 4
-#define MD_GC_WIDTH 1
-#define MD_RIC_LBN 2
-#define MD_RIC_WIDTH 1
-#define MD_RDC_LBN 1
-#define MD_RDC_WIDTH 1
-#define MD_WRC_LBN 0
-#define MD_WRC_WIDTH 1
-
-/* PHY management PHY address register */
-#define MD_PHY_ADR_REG_KER 0xc30
-#define MD_PHY_ADR_LBN 0
-#define MD_PHY_ADR_WIDTH 16
-
-/* PHY management ID register */
-#define MD_ID_REG_KER 0xc40
-#define MD_PRT_ADR_LBN 11
-#define MD_PRT_ADR_WIDTH 5
-#define MD_DEV_ADR_LBN 6
-#define MD_DEV_ADR_WIDTH 5
-
-/* PHY management status & mask register (DWORD read only) */
-#define MD_STAT_REG_KER 0xc50
-#define MD_BSERR_LBN 2
-#define MD_BSERR_WIDTH 1
-#define MD_LNFL_LBN 1
-#define MD_LNFL_WIDTH 1
-#define MD_BSY_LBN 0
-#define MD_BSY_WIDTH 1
-
-/* Port 0 and 1 MAC stats registers */
-#define MAC0_STAT_DMA_REG_KER 0xc60
-#define MAC_STAT_DMA_CMD_LBN 48
-#define MAC_STAT_DMA_CMD_WIDTH 1
-#define MAC_STAT_DMA_ADR_LBN 0
-#define MAC_STAT_DMA_ADR_WIDTH EFX_DMA_TYPE_WIDTH(46)
-
-/* Port 0 and 1 MAC control registers */
-#define MAC0_CTRL_REG_KER 0xc80
-#define MAC_XOFF_VAL_LBN 16
-#define MAC_XOFF_VAL_WIDTH 16
-#define TXFIFO_DRAIN_EN_B0_LBN 7
-#define TXFIFO_DRAIN_EN_B0_WIDTH 1
-#define MAC_BCAD_ACPT_LBN 4
-#define MAC_BCAD_ACPT_WIDTH 1
-#define MAC_UC_PROM_LBN 3
-#define MAC_UC_PROM_WIDTH 1
-#define MAC_LINK_STATUS_LBN 2
-#define MAC_LINK_STATUS_WIDTH 1
-#define MAC_SPEED_LBN 0
-#define MAC_SPEED_WIDTH 2
-
-/* 10G XAUI XGXS default values */
-#define XX_TXDRV_DEQ_DEFAULT 0xe /* deq=.6 */
-#define XX_TXDRV_DTX_DEFAULT 0x5 /* 1.25 */
-#define XX_SD_CTL_DRV_DEFAULT 0  /* 20mA */
-
-/* Multicast address hash table */
-#define MAC_MCAST_HASH_REG0_KER 0xca0
-#define MAC_MCAST_HASH_REG1_KER 0xcb0
-
-/* GMAC configuration register 1 */
-#define GM_CFG1_REG 0xe00
-#define GM_SW_RST_LBN 31
-#define GM_SW_RST_WIDTH 1
-#define GM_LOOP_LBN 8
-#define GM_LOOP_WIDTH 1
-#define GM_RX_FC_EN_LBN 5
-#define GM_RX_FC_EN_WIDTH 1
-#define GM_TX_FC_EN_LBN 4
-#define GM_TX_FC_EN_WIDTH 1
-#define GM_RX_EN_LBN 2
-#define GM_RX_EN_WIDTH 1
-#define GM_TX_EN_LBN 0
-#define GM_TX_EN_WIDTH 1
-
-/* GMAC configuration register 2 */
-#define GM_CFG2_REG 0xe10
-#define GM_PAMBL_LEN_LBN 12
-#define GM_PAMBL_LEN_WIDTH 4
-#define GM_IF_MODE_LBN 8
-#define GM_IF_MODE_WIDTH 2
-#define GM_LEN_CHK_LBN 4
-#define GM_LEN_CHK_WIDTH 1
-#define GM_PAD_CRC_EN_LBN 2
-#define GM_PAD_CRC_EN_WIDTH 1
-#define GM_FD_LBN 0
-#define GM_FD_WIDTH 1
-
-/* GMAC maximum frame length register */
-#define GM_MAX_FLEN_REG 0xe40
-#define GM_MAX_FLEN_LBN 0
-#define GM_MAX_FLEN_WIDTH 16
-
-/* GMAC station address register 1 */
-#define GM_ADR1_REG 0xf00
-#define GM_HWADDR_5_LBN 24
-#define GM_HWADDR_5_WIDTH 8
-#define GM_HWADDR_4_LBN 16
-#define GM_HWADDR_4_WIDTH 8
-#define GM_HWADDR_3_LBN 8
-#define GM_HWADDR_3_WIDTH 8
-#define GM_HWADDR_2_LBN 0
-#define GM_HWADDR_2_WIDTH 8
-
-/* GMAC station address register 2 */
-#define GM_ADR2_REG 0xf10
-#define GM_HWADDR_1_LBN 24
-#define GM_HWADDR_1_WIDTH 8
-#define GM_HWADDR_0_LBN 16
-#define GM_HWADDR_0_WIDTH 8
-
-/* GMAC FIFO configuration register 0 */
-#define GMF_CFG0_REG 0xf20
-#define GMF_FTFENREQ_LBN 12
-#define GMF_FTFENREQ_WIDTH 1
-#define GMF_STFENREQ_LBN 11
-#define GMF_STFENREQ_WIDTH 1
-#define GMF_FRFENREQ_LBN 10
-#define GMF_FRFENREQ_WIDTH 1
-#define GMF_SRFENREQ_LBN 9
-#define GMF_SRFENREQ_WIDTH 1
-#define GMF_WTMENREQ_LBN 8
-#define GMF_WTMENREQ_WIDTH 1
-
-/* GMAC FIFO configuration register 1 */
-#define GMF_CFG1_REG 0xf30
-#define GMF_CFGFRTH_LBN 16
-#define GMF_CFGFRTH_WIDTH 5
-#define GMF_CFGXOFFRTX_LBN 0
-#define GMF_CFGXOFFRTX_WIDTH 16
-
-/* GMAC FIFO configuration register 2 */
-#define GMF_CFG2_REG 0xf40
-#define GMF_CFGHWM_LBN 16
-#define GMF_CFGHWM_WIDTH 6
-#define GMF_CFGLWM_LBN 0
-#define GMF_CFGLWM_WIDTH 6
-
-/* GMAC FIFO configuration register 3 */
-#define GMF_CFG3_REG 0xf50
-#define GMF_CFGHWMFT_LBN 16
-#define GMF_CFGHWMFT_WIDTH 6
-#define GMF_CFGFTTH_LBN 0
-#define GMF_CFGFTTH_WIDTH 6
-
-/* GMAC FIFO configuration register 4 */
-#define GMF_CFG4_REG 0xf60
-#define GMF_HSTFLTRFRM_PAUSE_LBN 12
-#define GMF_HSTFLTRFRM_PAUSE_WIDTH 12
-
-/* GMAC FIFO configuration register 5 */
-#define GMF_CFG5_REG 0xf70
-#define GMF_CFGHDPLX_LBN 22
-#define GMF_CFGHDPLX_WIDTH 1
-#define GMF_CFGBYTMODE_LBN 19
-#define GMF_CFGBYTMODE_WIDTH 1
-#define GMF_HSTDRPLT64_LBN 18
-#define GMF_HSTDRPLT64_WIDTH 1
-#define GMF_HSTFLTRFRMDC_PAUSE_LBN 12
-#define GMF_HSTFLTRFRMDC_PAUSE_WIDTH 1
-
-/* XGMAC address register low */
-#define XM_ADR_LO_REG 0x1200
-#define XM_ADR_3_LBN 24
-#define XM_ADR_3_WIDTH 8
-#define XM_ADR_2_LBN 16
-#define XM_ADR_2_WIDTH 8
-#define XM_ADR_1_LBN 8
-#define XM_ADR_1_WIDTH 8
-#define XM_ADR_0_LBN 0
-#define XM_ADR_0_WIDTH 8
-
-/* XGMAC address register high */
-#define XM_ADR_HI_REG 0x1210
-#define XM_ADR_5_LBN 8
-#define XM_ADR_5_WIDTH 8
-#define XM_ADR_4_LBN 0
-#define XM_ADR_4_WIDTH 8
-
-/* XGMAC global configuration */
-#define XM_GLB_CFG_REG 0x1220
-#define XM_RX_STAT_EN_LBN 11
-#define XM_RX_STAT_EN_WIDTH 1
-#define XM_TX_STAT_EN_LBN 10
-#define XM_TX_STAT_EN_WIDTH 1
-#define XM_RX_JUMBO_MODE_LBN 6
-#define XM_RX_JUMBO_MODE_WIDTH 1
-#define XM_INTCLR_MODE_LBN 3
-#define XM_INTCLR_MODE_WIDTH 1
-#define XM_CORE_RST_LBN 0
-#define XM_CORE_RST_WIDTH 1
-
-/* XGMAC transmit configuration */
-#define XM_TX_CFG_REG 0x1230
-#define XM_IPG_LBN 16
-#define XM_IPG_WIDTH 4
-#define XM_FCNTL_LBN 10
-#define XM_FCNTL_WIDTH 1
-#define XM_TXCRC_LBN 8
-#define XM_TXCRC_WIDTH 1
-#define XM_AUTO_PAD_LBN 5
-#define XM_AUTO_PAD_WIDTH 1
-#define XM_TX_PRMBL_LBN 2
-#define XM_TX_PRMBL_WIDTH 1
-#define XM_TXEN_LBN 1
-#define XM_TXEN_WIDTH 1
-
-/* XGMAC receive configuration */
-#define XM_RX_CFG_REG 0x1240
-#define XM_PASS_CRC_ERR_LBN 25
-#define XM_PASS_CRC_ERR_WIDTH 1
-#define XM_ACPT_ALL_MCAST_LBN 11
-#define XM_ACPT_ALL_MCAST_WIDTH 1
-#define XM_ACPT_ALL_UCAST_LBN 9
-#define XM_ACPT_ALL_UCAST_WIDTH 1
-#define XM_AUTO_DEPAD_LBN 8
-#define XM_AUTO_DEPAD_WIDTH 1
-#define XM_RXEN_LBN 1
-#define XM_RXEN_WIDTH 1
-
-/* XGMAC management interrupt mask register */
-#define XM_MGT_INT_MSK_REG_B0 0x1250
-#define XM_MSK_PRMBLE_ERR_LBN 2
-#define XM_MSK_PRMBLE_ERR_WIDTH 1
-#define XM_MSK_RMTFLT_LBN 1
-#define XM_MSK_RMTFLT_WIDTH 1
-#define XM_MSK_LCLFLT_LBN 0
-#define XM_MSK_LCLFLT_WIDTH 1
-
-/* XGMAC flow control register */
-#define XM_FC_REG 0x1270
-#define XM_PAUSE_TIME_LBN 16
-#define XM_PAUSE_TIME_WIDTH 16
-#define XM_DIS_FCNTL_LBN 0
-#define XM_DIS_FCNTL_WIDTH 1
-
-/* XGMAC pause time count register */
-#define XM_PAUSE_TIME_REG 0x1290
-
-/* XGMAC transmit parameter register */
-#define XM_TX_PARAM_REG 0x012d0
-#define XM_TX_JUMBO_MODE_LBN 31
-#define XM_TX_JUMBO_MODE_WIDTH 1
-#define XM_MAX_TX_FRM_SIZE_LBN 16
-#define XM_MAX_TX_FRM_SIZE_WIDTH 14
-
-/* XGMAC receive parameter register */
-#define XM_RX_PARAM_REG 0x12e0
-#define XM_MAX_RX_FRM_SIZE_LBN 0
-#define XM_MAX_RX_FRM_SIZE_WIDTH 14
-
-/* XGMAC management interrupt status register */
-#define XM_MGT_INT_REG_B0 0x12f0
-#define XM_PRMBLE_ERR 2
-#define XM_PRMBLE_WIDTH 1
-#define XM_RMTFLT_LBN 1
-#define XM_RMTFLT_WIDTH 1
-#define XM_LCLFLT_LBN 0
-#define XM_LCLFLT_WIDTH 1
-
-/* XGXS/XAUI powerdown/reset register */
-#define XX_PWR_RST_REG 0x1300
-
-#define XX_SD_RST_ACT_LBN 16
-#define XX_SD_RST_ACT_WIDTH 1
-#define XX_PWRDND_EN_LBN 15
-#define XX_PWRDND_EN_WIDTH 1
-#define XX_PWRDNC_EN_LBN 14
-#define XX_PWRDNC_EN_WIDTH 1
-#define XX_PWRDNB_EN_LBN 13
-#define XX_PWRDNB_EN_WIDTH 1
-#define XX_PWRDNA_EN_LBN 12
-#define XX_PWRDNA_EN_WIDTH 1
-#define XX_RSTPLLCD_EN_LBN 9
-#define XX_RSTPLLCD_EN_WIDTH 1
-#define XX_RSTPLLAB_EN_LBN 8
-#define XX_RSTPLLAB_EN_WIDTH 1
-#define XX_RESETD_EN_LBN 7
-#define XX_RESETD_EN_WIDTH 1
-#define XX_RESETC_EN_LBN 6
-#define XX_RESETC_EN_WIDTH 1
-#define XX_RESETB_EN_LBN 5
-#define XX_RESETB_EN_WIDTH 1
-#define XX_RESETA_EN_LBN 4
-#define XX_RESETA_EN_WIDTH 1
-#define XX_RSTXGXSRX_EN_LBN 2
-#define XX_RSTXGXSRX_EN_WIDTH 1
-#define XX_RSTXGXSTX_EN_LBN 1
-#define XX_RSTXGXSTX_EN_WIDTH 1
-#define XX_RST_XX_EN_LBN 0
-#define XX_RST_XX_EN_WIDTH 1
-
-/* XGXS/XAUI powerdown/reset control register */
-#define XX_SD_CTL_REG 0x1310
-#define XX_HIDRVD_LBN 15
-#define XX_HIDRVD_WIDTH 1
-#define XX_LODRVD_LBN 14
-#define XX_LODRVD_WIDTH 1
-#define XX_HIDRVC_LBN 13
-#define XX_HIDRVC_WIDTH 1
-#define XX_LODRVC_LBN 12
-#define XX_LODRVC_WIDTH 1
-#define XX_HIDRVB_LBN 11
-#define XX_HIDRVB_WIDTH 1
-#define XX_LODRVB_LBN 10
-#define XX_LODRVB_WIDTH 1
-#define XX_HIDRVA_LBN 9
-#define XX_HIDRVA_WIDTH 1
-#define XX_LODRVA_LBN 8
-#define XX_LODRVA_WIDTH 1
-#define XX_LPBKD_LBN 3
-#define XX_LPBKD_WIDTH 1
-#define XX_LPBKC_LBN 2
-#define XX_LPBKC_WIDTH 1
-#define XX_LPBKB_LBN 1
-#define XX_LPBKB_WIDTH 1
-#define XX_LPBKA_LBN 0
-#define XX_LPBKA_WIDTH 1
-
-#define XX_TXDRV_CTL_REG 0x1320
-#define XX_DEQD_LBN 28
-#define XX_DEQD_WIDTH 4
-#define XX_DEQC_LBN 24
-#define XX_DEQC_WIDTH 4
-#define XX_DEQB_LBN 20
-#define XX_DEQB_WIDTH 4
-#define XX_DEQA_LBN 16
-#define XX_DEQA_WIDTH 4
-#define XX_DTXD_LBN 12
-#define XX_DTXD_WIDTH 4
-#define XX_DTXC_LBN 8
-#define XX_DTXC_WIDTH 4
-#define XX_DTXB_LBN 4
-#define XX_DTXB_WIDTH 4
-#define XX_DTXA_LBN 0
-#define XX_DTXA_WIDTH 4
-
-/* XAUI XGXS core status register */
-#define XX_CORE_STAT_REG 0x1360
-#define XX_FORCE_SIG_LBN 24
-#define XX_FORCE_SIG_WIDTH 8
-#define XX_FORCE_SIG_DECODE_FORCED 0xff
-#define XX_XGXS_LB_EN_LBN 23
-#define XX_XGXS_LB_EN_WIDTH 1
-#define XX_XGMII_LB_EN_LBN 22
-#define XX_XGMII_LB_EN_WIDTH 1
-#define XX_ALIGN_DONE_LBN 20
-#define XX_ALIGN_DONE_WIDTH 1
-#define XX_SYNC_STAT_LBN 16
-#define XX_SYNC_STAT_WIDTH 4
-#define XX_SYNC_STAT_DECODE_SYNCED 0xf
-#define XX_COMMA_DET_LBN 12
-#define XX_COMMA_DET_WIDTH 4
-#define XX_COMMA_DET_DECODE_DETECTED 0xf
-#define XX_COMMA_DET_RESET 0xf
-#define XX_CHARERR_LBN 4
-#define XX_CHARERR_WIDTH 4
-#define XX_CHARERR_RESET 0xf
-#define XX_DISPERR_LBN 0
-#define XX_DISPERR_WIDTH 4
-#define XX_DISPERR_RESET 0xf
-
-/* Receive filter table */
-#define RX_FILTER_TBL0 0xF00000
-
-/* Receive descriptor pointer table */
-#define RX_DESC_PTR_TBL_KER_A1 0x11800
-#define RX_DESC_PTR_TBL_KER_B0 0xF40000
-#define RX_DESC_PTR_TBL_KER_P0 0x900
-#define RX_ISCSI_DDIG_EN_LBN 88
-#define RX_ISCSI_DDIG_EN_WIDTH 1
-#define RX_ISCSI_HDIG_EN_LBN 87
-#define RX_ISCSI_HDIG_EN_WIDTH 1
-#define RX_DESCQ_BUF_BASE_ID_LBN 36
-#define RX_DESCQ_BUF_BASE_ID_WIDTH 20
-#define RX_DESCQ_EVQ_ID_LBN 24
-#define RX_DESCQ_EVQ_ID_WIDTH 12
-#define RX_DESCQ_OWNER_ID_LBN 10
-#define RX_DESCQ_OWNER_ID_WIDTH 14
-#define RX_DESCQ_LABEL_LBN 5
-#define RX_DESCQ_LABEL_WIDTH 5
-#define RX_DESCQ_SIZE_LBN 3
-#define RX_DESCQ_SIZE_WIDTH 2
-#define RX_DESCQ_SIZE_4K 3
-#define RX_DESCQ_SIZE_2K 2
-#define RX_DESCQ_SIZE_1K 1
-#define RX_DESCQ_SIZE_512 0
-#define RX_DESCQ_TYPE_LBN 2
-#define RX_DESCQ_TYPE_WIDTH 1
-#define RX_DESCQ_JUMBO_LBN 1
-#define RX_DESCQ_JUMBO_WIDTH 1
-#define RX_DESCQ_EN_LBN 0
-#define RX_DESCQ_EN_WIDTH 1
-
-/* Transmit descriptor pointer table */
-#define TX_DESC_PTR_TBL_KER_A1 0x11900
-#define TX_DESC_PTR_TBL_KER_B0 0xF50000
-#define TX_DESC_PTR_TBL_KER_P0 0xa40
-#define TX_NON_IP_DROP_DIS_B0_LBN 91
-#define TX_NON_IP_DROP_DIS_B0_WIDTH 1
-#define TX_IP_CHKSM_DIS_B0_LBN 90
-#define TX_IP_CHKSM_DIS_B0_WIDTH 1
-#define TX_TCP_CHKSM_DIS_B0_LBN 89
-#define TX_TCP_CHKSM_DIS_B0_WIDTH 1
-#define TX_DESCQ_EN_LBN 88
-#define TX_DESCQ_EN_WIDTH 1
-#define TX_ISCSI_DDIG_EN_LBN 87
-#define TX_ISCSI_DDIG_EN_WIDTH 1
-#define TX_ISCSI_HDIG_EN_LBN 86
-#define TX_ISCSI_HDIG_EN_WIDTH 1
-#define TX_DESCQ_BUF_BASE_ID_LBN 36
-#define TX_DESCQ_BUF_BASE_ID_WIDTH 20
-#define TX_DESCQ_EVQ_ID_LBN 24
-#define TX_DESCQ_EVQ_ID_WIDTH 12
-#define TX_DESCQ_OWNER_ID_LBN 10
-#define TX_DESCQ_OWNER_ID_WIDTH 14
-#define TX_DESCQ_LABEL_LBN 5
-#define TX_DESCQ_LABEL_WIDTH 5
-#define TX_DESCQ_SIZE_LBN 3
-#define TX_DESCQ_SIZE_WIDTH 2
-#define TX_DESCQ_SIZE_4K 3
-#define TX_DESCQ_SIZE_2K 2
-#define TX_DESCQ_SIZE_1K 1
-#define TX_DESCQ_SIZE_512 0
-#define TX_DESCQ_TYPE_LBN 1
-#define TX_DESCQ_TYPE_WIDTH 2
-
-/* Event queue pointer */
-#define EVQ_PTR_TBL_KER_A1 0x11a00
-#define EVQ_PTR_TBL_KER_B0 0xf60000
-#define EVQ_PTR_TBL_KER_P0 0x500
-#define EVQ_EN_LBN 23
-#define EVQ_EN_WIDTH 1
-#define EVQ_SIZE_LBN 20
-#define EVQ_SIZE_WIDTH 3
-#define EVQ_SIZE_32K 6
-#define EVQ_SIZE_16K 5
-#define EVQ_SIZE_8K 4
-#define EVQ_SIZE_4K 3
-#define EVQ_SIZE_2K 2
-#define EVQ_SIZE_1K 1
-#define EVQ_SIZE_512 0
-#define EVQ_BUF_BASE_ID_LBN 0
-#define EVQ_BUF_BASE_ID_WIDTH 20
-
-/* Event queue read pointer */
-#define EVQ_RPTR_REG_KER_A1 0x11b00
-#define EVQ_RPTR_REG_KER_B0 0xfa0000
-#define EVQ_RPTR_REG_KER_DWORD (EVQ_RPTR_REG_KER + 0)
-#define EVQ_RPTR_DWORD_LBN 0
-#define EVQ_RPTR_DWORD_WIDTH 14
-
-/* RSS indirection table */
-#define RX_RSS_INDIR_TBL_B0 0xFB0000
-#define RX_RSS_INDIR_ENT_B0_LBN 0
-#define RX_RSS_INDIR_ENT_B0_WIDTH 6
-
-/* Special buffer descriptors (full-mode) */
-#define BUF_FULL_TBL_KER_A1 0x8000
-#define BUF_FULL_TBL_KER_B0 0x800000
-#define IP_DAT_BUF_SIZE_LBN 50
-#define IP_DAT_BUF_SIZE_WIDTH 1
-#define IP_DAT_BUF_SIZE_8K 1
-#define IP_DAT_BUF_SIZE_4K 0
-#define BUF_ADR_REGION_LBN 48
-#define BUF_ADR_REGION_WIDTH 2
-#define BUF_ADR_FBUF_LBN 14
-#define BUF_ADR_FBUF_WIDTH 34
-#define BUF_OWNER_ID_FBUF_LBN 0
-#define BUF_OWNER_ID_FBUF_WIDTH 14
-
-/* Transmit descriptor */
-#define TX_KER_PORT_LBN 63
-#define TX_KER_PORT_WIDTH 1
-#define TX_KER_CONT_LBN 62
-#define TX_KER_CONT_WIDTH 1
-#define TX_KER_BYTE_CNT_LBN 48
-#define TX_KER_BYTE_CNT_WIDTH 14
-#define TX_KER_BUF_REGION_LBN 46
-#define TX_KER_BUF_REGION_WIDTH 2
-#define TX_KER_BUF_REGION0_DECODE 0
-#define TX_KER_BUF_REGION1_DECODE 1
-#define TX_KER_BUF_REGION2_DECODE 2
-#define TX_KER_BUF_REGION3_DECODE 3
-#define TX_KER_BUF_ADR_LBN 0
-#define TX_KER_BUF_ADR_WIDTH EFX_DMA_TYPE_WIDTH(46)
-
-/* Receive descriptor */
-#define RX_KER_BUF_SIZE_LBN 48
-#define RX_KER_BUF_SIZE_WIDTH 14
-#define RX_KER_BUF_REGION_LBN 46
-#define RX_KER_BUF_REGION_WIDTH 2
-#define RX_KER_BUF_REGION0_DECODE 0
-#define RX_KER_BUF_REGION1_DECODE 1
-#define RX_KER_BUF_REGION2_DECODE 2
-#define RX_KER_BUF_REGION3_DECODE 3
-#define RX_KER_BUF_ADR_LBN 0
-#define RX_KER_BUF_ADR_WIDTH EFX_DMA_TYPE_WIDTH(46)
-
-/**************************************************************************
- *
- * Falcon events
- *
- **************************************************************************
- */
-
-/* Event queue entries */
-#define EV_CODE_LBN 60
-#define EV_CODE_WIDTH 4
-#define RX_IP_EV_DECODE 0
-#define TX_IP_EV_DECODE 2
-#define DRIVER_EV_DECODE 5
-#define GLOBAL_EV_DECODE 6
-#define DRV_GEN_EV_DECODE 7
-#define WHOLE_EVENT_LBN 0
-#define WHOLE_EVENT_WIDTH 64
-
-/* Receive events */
-#define RX_EV_PKT_OK_LBN 56
-#define RX_EV_PKT_OK_WIDTH 1
-#define RX_EV_PAUSE_FRM_ERR_LBN 55
-#define RX_EV_PAUSE_FRM_ERR_WIDTH 1
-#define RX_EV_BUF_OWNER_ID_ERR_LBN 54
-#define RX_EV_BUF_OWNER_ID_ERR_WIDTH 1
-#define RX_EV_IF_FRAG_ERR_LBN 53
-#define RX_EV_IF_FRAG_ERR_WIDTH 1
-#define RX_EV_IP_HDR_CHKSUM_ERR_LBN 52
-#define RX_EV_IP_HDR_CHKSUM_ERR_WIDTH 1
-#define RX_EV_TCP_UDP_CHKSUM_ERR_LBN 51
-#define RX_EV_TCP_UDP_CHKSUM_ERR_WIDTH 1
-#define RX_EV_ETH_CRC_ERR_LBN 50
-#define RX_EV_ETH_CRC_ERR_WIDTH 1
-#define RX_EV_FRM_TRUNC_LBN 49
-#define RX_EV_FRM_TRUNC_WIDTH 1
-#define RX_EV_DRIB_NIB_LBN 48
-#define RX_EV_DRIB_NIB_WIDTH 1
-#define RX_EV_TOBE_DISC_LBN 47
-#define RX_EV_TOBE_DISC_WIDTH 1
-#define RX_EV_PKT_TYPE_LBN 44
-#define RX_EV_PKT_TYPE_WIDTH 3
-#define RX_EV_PKT_TYPE_ETH_DECODE 0
-#define RX_EV_PKT_TYPE_LLC_DECODE 1
-#define RX_EV_PKT_TYPE_JUMBO_DECODE 2
-#define RX_EV_PKT_TYPE_VLAN_DECODE 3
-#define RX_EV_PKT_TYPE_VLAN_LLC_DECODE 4
-#define RX_EV_PKT_TYPE_VLAN_JUMBO_DECODE 5
-#define RX_EV_HDR_TYPE_LBN 42
-#define RX_EV_HDR_TYPE_WIDTH 2
-#define RX_EV_HDR_TYPE_TCP_IPV4_DECODE 0
-#define RX_EV_HDR_TYPE_UDP_IPV4_DECODE 1
-#define RX_EV_HDR_TYPE_OTHER_IP_DECODE 2
-#define RX_EV_HDR_TYPE_NON_IP_DECODE 3
-#define RX_EV_HDR_TYPE_HAS_CHECKSUMS(hdr_type) \
-	((hdr_type) <= RX_EV_HDR_TYPE_UDP_IPV4_DECODE)
-#define RX_EV_MCAST_HASH_MATCH_LBN 40
-#define RX_EV_MCAST_HASH_MATCH_WIDTH 1
-#define RX_EV_MCAST_PKT_LBN 39
-#define RX_EV_MCAST_PKT_WIDTH 1
-#define RX_EV_Q_LABEL_LBN 32
-#define RX_EV_Q_LABEL_WIDTH 5
-#define RX_EV_JUMBO_CONT_LBN 31
-#define RX_EV_JUMBO_CONT_WIDTH 1
-#define RX_EV_BYTE_CNT_LBN 16
-#define RX_EV_BYTE_CNT_WIDTH 14
-#define RX_EV_SOP_LBN 15
-#define RX_EV_SOP_WIDTH 1
-#define RX_EV_DESC_PTR_LBN 0
-#define RX_EV_DESC_PTR_WIDTH 12
-
-/* Transmit events */
-#define TX_EV_PKT_ERR_LBN 38
-#define TX_EV_PKT_ERR_WIDTH 1
-#define TX_EV_Q_LABEL_LBN 32
-#define TX_EV_Q_LABEL_WIDTH 5
-#define TX_EV_WQ_FF_FULL_LBN 15
-#define TX_EV_WQ_FF_FULL_WIDTH 1
-#define TX_EV_COMP_LBN 12
-#define TX_EV_COMP_WIDTH 1
-#define TX_EV_DESC_PTR_LBN 0
-#define TX_EV_DESC_PTR_WIDTH 12
-
-/* Driver events */
-#define DRIVER_EV_SUB_CODE_LBN 56
-#define DRIVER_EV_SUB_CODE_WIDTH 4
-#define DRIVER_EV_SUB_DATA_LBN 0
-#define DRIVER_EV_SUB_DATA_WIDTH 14
-#define TX_DESCQ_FLS_DONE_EV_DECODE 0
-#define RX_DESCQ_FLS_DONE_EV_DECODE 1
-#define EVQ_INIT_DONE_EV_DECODE 2
-#define EVQ_NOT_EN_EV_DECODE 3
-#define RX_DESCQ_FLSFF_OVFL_EV_DECODE 4
-#define SRM_UPD_DONE_EV_DECODE 5
-#define WAKE_UP_EV_DECODE 6
-#define TX_PKT_NON_TCP_UDP_DECODE 9
-#define TIMER_EV_DECODE 10
-#define RX_RECOVERY_EV_DECODE 11
-#define RX_DSC_ERROR_EV_DECODE 14
-#define TX_DSC_ERROR_EV_DECODE 15
-#define DRIVER_EV_TX_DESCQ_ID_LBN 0
-#define DRIVER_EV_TX_DESCQ_ID_WIDTH 12
-#define DRIVER_EV_RX_FLUSH_FAIL_LBN 12
-#define DRIVER_EV_RX_FLUSH_FAIL_WIDTH 1
-#define DRIVER_EV_RX_DESCQ_ID_LBN 0
-#define DRIVER_EV_RX_DESCQ_ID_WIDTH 12
-#define SRM_CLR_EV_DECODE 0
-#define SRM_UPD_EV_DECODE 1
-#define SRM_ILLCLR_EV_DECODE 2
-
-/* Global events */
-#define RX_RECOVERY_B0_LBN 12
-#define RX_RECOVERY_B0_WIDTH 1
-#define XG_MNT_INTR_B0_LBN 11
-#define XG_MNT_INTR_B0_WIDTH 1
-#define RX_RECOVERY_A1_LBN 11
-#define RX_RECOVERY_A1_WIDTH 1
-#define XFP_PHY_INTR_LBN 10
-#define XFP_PHY_INTR_WIDTH 1
-#define XG_PHY_INTR_LBN 9
-#define XG_PHY_INTR_WIDTH 1
-#define G_PHY1_INTR_LBN 8
-#define G_PHY1_INTR_WIDTH 1
-#define G_PHY0_INTR_LBN 7
-#define G_PHY0_INTR_WIDTH 1
-
-/* Driver-generated test events */
-#define EVQ_MAGIC_LBN 0
-#define EVQ_MAGIC_WIDTH 32
-
-/**************************************************************************
- *
- * Falcon MAC stats
- *
- **************************************************************************
- *
- */
-
-#define GRxGoodOct_offset 0x0
-#define GRxGoodOct_WIDTH 48
-#define GRxBadOct_offset 0x8
-#define GRxBadOct_WIDTH 48
-#define GRxMissPkt_offset 0x10
-#define GRxMissPkt_WIDTH 32
-#define GRxFalseCRS_offset 0x14
-#define GRxFalseCRS_WIDTH 32
-#define GRxPausePkt_offset 0x18
-#define GRxPausePkt_WIDTH 32
-#define GRxBadPkt_offset 0x1C
-#define GRxBadPkt_WIDTH 32
-#define GRxUcastPkt_offset 0x20
-#define GRxUcastPkt_WIDTH 32
-#define GRxMcastPkt_offset 0x24
-#define GRxMcastPkt_WIDTH 32
-#define GRxBcastPkt_offset 0x28
-#define GRxBcastPkt_WIDTH 32
-#define GRxGoodLt64Pkt_offset 0x2C
-#define GRxGoodLt64Pkt_WIDTH 32
-#define GRxBadLt64Pkt_offset 0x30
-#define GRxBadLt64Pkt_WIDTH 32
-#define GRx64Pkt_offset 0x34
-#define GRx64Pkt_WIDTH 32
-#define GRx65to127Pkt_offset 0x38
-#define GRx65to127Pkt_WIDTH 32
-#define GRx128to255Pkt_offset 0x3C
-#define GRx128to255Pkt_WIDTH 32
-#define GRx256to511Pkt_offset 0x40
-#define GRx256to511Pkt_WIDTH 32
-#define GRx512to1023Pkt_offset 0x44
-#define GRx512to1023Pkt_WIDTH 32
-#define GRx1024to15xxPkt_offset 0x48
-#define GRx1024to15xxPkt_WIDTH 32
-#define GRx15xxtoJumboPkt_offset 0x4C
-#define GRx15xxtoJumboPkt_WIDTH 32
-#define GRxGtJumboPkt_offset 0x50
-#define GRxGtJumboPkt_WIDTH 32
-#define GRxFcsErr64to15xxPkt_offset 0x54
-#define GRxFcsErr64to15xxPkt_WIDTH 32
-#define GRxFcsErr15xxtoJumboPkt_offset 0x58
-#define GRxFcsErr15xxtoJumboPkt_WIDTH 32
-#define GRxFcsErrGtJumboPkt_offset 0x5C
-#define GRxFcsErrGtJumboPkt_WIDTH 32
-#define GTxGoodBadOct_offset 0x80
-#define GTxGoodBadOct_WIDTH 48
-#define GTxGoodOct_offset 0x88
-#define GTxGoodOct_WIDTH 48
-#define GTxSglColPkt_offset 0x90
-#define GTxSglColPkt_WIDTH 32
-#define GTxMultColPkt_offset 0x94
-#define GTxMultColPkt_WIDTH 32
-#define GTxExColPkt_offset 0x98
-#define GTxExColPkt_WIDTH 32
-#define GTxDefPkt_offset 0x9C
-#define GTxDefPkt_WIDTH 32
-#define GTxLateCol_offset 0xA0
-#define GTxLateCol_WIDTH 32
-#define GTxExDefPkt_offset 0xA4
-#define GTxExDefPkt_WIDTH 32
-#define GTxPausePkt_offset 0xA8
-#define GTxPausePkt_WIDTH 32
-#define GTxBadPkt_offset 0xAC
-#define GTxBadPkt_WIDTH 32
-#define GTxUcastPkt_offset 0xB0
-#define GTxUcastPkt_WIDTH 32
-#define GTxMcastPkt_offset 0xB4
-#define GTxMcastPkt_WIDTH 32
-#define GTxBcastPkt_offset 0xB8
-#define GTxBcastPkt_WIDTH 32
-#define GTxLt64Pkt_offset 0xBC
-#define GTxLt64Pkt_WIDTH 32
-#define GTx64Pkt_offset 0xC0
-#define GTx64Pkt_WIDTH 32
-#define GTx65to127Pkt_offset 0xC4
-#define GTx65to127Pkt_WIDTH 32
-#define GTx128to255Pkt_offset 0xC8
-#define GTx128to255Pkt_WIDTH 32
-#define GTx256to511Pkt_offset 0xCC
-#define GTx256to511Pkt_WIDTH 32
-#define GTx512to1023Pkt_offset 0xD0
-#define GTx512to1023Pkt_WIDTH 32
-#define GTx1024to15xxPkt_offset 0xD4
-#define GTx1024to15xxPkt_WIDTH 32
-#define GTx15xxtoJumboPkt_offset 0xD8
-#define GTx15xxtoJumboPkt_WIDTH 32
-#define GTxGtJumboPkt_offset 0xDC
-#define GTxGtJumboPkt_WIDTH 32
-#define GTxNonTcpUdpPkt_offset 0xE0
-#define GTxNonTcpUdpPkt_WIDTH 16
-#define GTxMacSrcErrPkt_offset 0xE4
-#define GTxMacSrcErrPkt_WIDTH 16
-#define GTxIpSrcErrPkt_offset 0xE8
-#define GTxIpSrcErrPkt_WIDTH 16
-#define GDmaDone_offset 0xEC
-#define GDmaDone_WIDTH 32
-
-#define XgRxOctets_offset 0x0
-#define XgRxOctets_WIDTH 48
-#define XgRxOctetsOK_offset 0x8
-#define XgRxOctetsOK_WIDTH 48
-#define XgRxPkts_offset 0x10
-#define XgRxPkts_WIDTH 32
-#define XgRxPktsOK_offset 0x14
-#define XgRxPktsOK_WIDTH 32
-#define XgRxBroadcastPkts_offset 0x18
-#define XgRxBroadcastPkts_WIDTH 32
-#define XgRxMulticastPkts_offset 0x1C
-#define XgRxMulticastPkts_WIDTH 32
-#define XgRxUnicastPkts_offset 0x20
-#define XgRxUnicastPkts_WIDTH 32
-#define XgRxUndersizePkts_offset 0x24
-#define XgRxUndersizePkts_WIDTH 32
-#define XgRxOversizePkts_offset 0x28
-#define XgRxOversizePkts_WIDTH 32
-#define XgRxJabberPkts_offset 0x2C
-#define XgRxJabberPkts_WIDTH 32
-#define XgRxUndersizeFCSerrorPkts_offset 0x30
-#define XgRxUndersizeFCSerrorPkts_WIDTH 32
-#define XgRxDropEvents_offset 0x34
-#define XgRxDropEvents_WIDTH 32
-#define XgRxFCSerrorPkts_offset 0x38
-#define XgRxFCSerrorPkts_WIDTH 32
-#define XgRxAlignError_offset 0x3C
-#define XgRxAlignError_WIDTH 32
-#define XgRxSymbolError_offset 0x40
-#define XgRxSymbolError_WIDTH 32
-#define XgRxInternalMACError_offset 0x44
-#define XgRxInternalMACError_WIDTH 32
-#define XgRxControlPkts_offset 0x48
-#define XgRxControlPkts_WIDTH 32
-#define XgRxPausePkts_offset 0x4C
-#define XgRxPausePkts_WIDTH 32
-#define XgRxPkts64Octets_offset 0x50
-#define XgRxPkts64Octets_WIDTH 32
-#define XgRxPkts65to127Octets_offset 0x54
-#define XgRxPkts65to127Octets_WIDTH 32
-#define XgRxPkts128to255Octets_offset 0x58
-#define XgRxPkts128to255Octets_WIDTH 32
-#define XgRxPkts256to511Octets_offset 0x5C
-#define XgRxPkts256to511Octets_WIDTH 32
-#define XgRxPkts512to1023Octets_offset 0x60
-#define XgRxPkts512to1023Octets_WIDTH 32
-#define XgRxPkts1024to15xxOctets_offset 0x64
-#define XgRxPkts1024to15xxOctets_WIDTH 32
-#define XgRxPkts15xxtoMaxOctets_offset 0x68
-#define XgRxPkts15xxtoMaxOctets_WIDTH 32
-#define XgRxLengthError_offset 0x6C
-#define XgRxLengthError_WIDTH 32
-#define XgTxPkts_offset 0x80
-#define XgTxPkts_WIDTH 32
-#define XgTxOctets_offset 0x88
-#define XgTxOctets_WIDTH 48
-#define XgTxMulticastPkts_offset 0x90
-#define XgTxMulticastPkts_WIDTH 32
-#define XgTxBroadcastPkts_offset 0x94
-#define XgTxBroadcastPkts_WIDTH 32
-#define XgTxUnicastPkts_offset 0x98
-#define XgTxUnicastPkts_WIDTH 32
-#define XgTxControlPkts_offset 0x9C
-#define XgTxControlPkts_WIDTH 32
-#define XgTxPausePkts_offset 0xA0
-#define XgTxPausePkts_WIDTH 32
-#define XgTxPkts64Octets_offset 0xA4
-#define XgTxPkts64Octets_WIDTH 32
-#define XgTxPkts65to127Octets_offset 0xA8
-#define XgTxPkts65to127Octets_WIDTH 32
-#define XgTxPkts128to255Octets_offset 0xAC
-#define XgTxPkts128to255Octets_WIDTH 32
-#define XgTxPkts256to511Octets_offset 0xB0
-#define XgTxPkts256to511Octets_WIDTH 32
-#define XgTxPkts512to1023Octets_offset 0xB4
-#define XgTxPkts512to1023Octets_WIDTH 32
-#define XgTxPkts1024to15xxOctets_offset 0xB8
-#define XgTxPkts1024to15xxOctets_WIDTH 32
-#define XgTxPkts1519toMaxOctets_offset 0xBC
-#define XgTxPkts1519toMaxOctets_WIDTH 32
-#define XgTxUndersizePkts_offset 0xC0
-#define XgTxUndersizePkts_WIDTH 32
-#define XgTxOversizePkts_offset 0xC4
-#define XgTxOversizePkts_WIDTH 32
-#define XgTxNonTcpUdpPkt_offset 0xC8
-#define XgTxNonTcpUdpPkt_WIDTH 16
-#define XgTxMacSrcErrPkt_offset 0xCC
-#define XgTxMacSrcErrPkt_WIDTH 16
-#define XgTxIpSrcErrPkt_offset 0xD0
-#define XgTxIpSrcErrPkt_WIDTH 16
-#define XgDmaDone_offset 0xD4
-
-#define FALCON_STATS_NOT_DONE 0x00000000
-#define FALCON_STATS_DONE 0xffffffff
-
-/* Interrupt status register bits */
-#define FATAL_INT_LBN 64
-#define FATAL_INT_WIDTH 1
-#define INT_EVQS_LBN 40
-#define INT_EVQS_WIDTH 4
-
-/**************************************************************************
- *
- * Falcon non-volatile configuration
- *
- **************************************************************************
- */
-
-/* Board configuration v2 (v1 is obsolete; later versions are compatible) */
-struct falcon_nvconfig_board_v2 {
-	__le16 nports;
-	u8 port0_phy_addr;
-	u8 port0_phy_type;
-	u8 port1_phy_addr;
-	u8 port1_phy_type;
-	__le16 asic_sub_revision;
-	__le16 board_revision;
-} __packed;
-
-/* Board configuration v3 extra information */
-struct falcon_nvconfig_board_v3 {
-	__le32 spi_device_type[2];
-} __packed;
-
-/* Bit numbers for spi_device_type */
-#define SPI_DEV_TYPE_SIZE_LBN 0
-#define SPI_DEV_TYPE_SIZE_WIDTH 5
-#define SPI_DEV_TYPE_ADDR_LEN_LBN 6
-#define SPI_DEV_TYPE_ADDR_LEN_WIDTH 2
-#define SPI_DEV_TYPE_ERASE_CMD_LBN 8
-#define SPI_DEV_TYPE_ERASE_CMD_WIDTH 8
-#define SPI_DEV_TYPE_ERASE_SIZE_LBN 16
-#define SPI_DEV_TYPE_ERASE_SIZE_WIDTH 5
-#define SPI_DEV_TYPE_BLOCK_SIZE_LBN 24
-#define SPI_DEV_TYPE_BLOCK_SIZE_WIDTH 5
-#define SPI_DEV_TYPE_FIELD(type, field)					\
-	(((type) >> EFX_LOW_BIT(field)) & EFX_MASK32(EFX_WIDTH(field)))
-
-#define NVCONFIG_OFFSET 0x300
-
-#define NVCONFIG_BOARD_MAGIC_NUM 0xFA1C
-struct falcon_nvconfig {
-	efx_oword_t ee_vpd_cfg_reg;			/* 0x300 */
-	u8 mac_address[2][8];			/* 0x310 */
-	efx_oword_t pcie_sd_ctl0123_reg;		/* 0x320 */
-	efx_oword_t pcie_sd_ctl45_reg;			/* 0x330 */
-	efx_oword_t pcie_pcs_ctl_stat_reg;		/* 0x340 */
-	efx_oword_t hw_init_reg;			/* 0x350 */
-	efx_oword_t nic_stat_reg;			/* 0x360 */
-	efx_oword_t glb_ctl_reg;			/* 0x370 */
-	efx_oword_t srm_cfg_reg;			/* 0x380 */
-	efx_oword_t spare_reg;				/* 0x390 */
-	__le16 board_magic_num;			/* 0x3A0 */
-	__le16 board_struct_ver;
-	__le16 board_checksum;
-	struct falcon_nvconfig_board_v2 board_v2;
-	efx_oword_t ee_base_page_reg;			/* 0x3B0 */
-	struct falcon_nvconfig_board_v3 board_v3;
-} __packed;
-
-#endif /* EFX_FALCON_HWDEFS_H */
diff -r 5b3d4d3c1166 drivers/net/sfc/falcon_io.h
--- a/drivers/net/sfc/falcon_io.h	Fri Nov 05 15:20:28 2010 +0000
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,258 +0,0 @@
-/****************************************************************************
- * Driver for Solarflare Solarstorm network controllers and boards
- * Copyright 2005-2006 Fen Systems Ltd.
- * Copyright 2006-2008 Solarflare Communications Inc.
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 as published
- * by the Free Software Foundation, incorporated herein by reference.
- */
-
-#ifndef EFX_FALCON_IO_H
-#define EFX_FALCON_IO_H
-
-#include <linux/io.h>
-#include <linux/spinlock.h>
-
-/**************************************************************************
- *
- * Falcon hardware access
- *
- **************************************************************************
- *
- * Notes on locking strategy:
- *
- * Most Falcon registers require 16-byte (or 8-byte, for SRAM
- * registers) atomic writes which necessitates locking.
- * Under normal operation few writes to the Falcon BAR are made and these
- * registers (EVQ_RPTR_REG, RX_DESC_UPD_REG and TX_DESC_UPD_REG) are special
- * cased to allow 4-byte (hence lockless) accesses.
- *
- * It *is* safe to write to these 4-byte registers in the middle of an
- * access to an 8-byte or 16-byte register.  We therefore use a
- * spinlock to protect accesses to the larger registers, but no locks
- * for the 4-byte registers.
- *
- * A write barrier is needed to ensure that DW3 is written after DW0/1/2
- * due to the way the 16byte registers are "collected" in the Falcon BIU
- *
- * We also lock when carrying out reads, to ensure consistency of the
- * data (made possible since the BIU reads all 128 bits into a cache).
- * Reads are very rare, so this isn't a significant performance
- * impact.  (Most data transferred from NIC to host is DMAed directly
- * into host memory).
- *
- * I/O BAR access uses locks for both reads and writes (but is only provided
- * for testing purposes).
- */
-
-/* Special buffer descriptors (Falcon SRAM) */
-#define BUF_TBL_KER_A1 0x18000
-#define BUF_TBL_KER_B0 0x800000
-
-
-#if BITS_PER_LONG == 64
-#define FALCON_USE_QWORD_IO 1
-#endif
-
-#ifdef FALCON_USE_QWORD_IO
-static inline void _falcon_writeq(struct efx_nic *efx, __le64 value,
-				  unsigned int reg)
-{
-	__raw_writeq((__force u64)value, efx->membase + reg);
-}
-static inline __le64 _falcon_readq(struct efx_nic *efx, unsigned int reg)
-{
-	return (__force __le64)__raw_readq(efx->membase + reg);
-}
-#endif
-
-static inline void _falcon_writel(struct efx_nic *efx, __le32 value,
-				  unsigned int reg)
-{
-	__raw_writel((__force u32)value, efx->membase + reg);
-}
-static inline __le32 _falcon_readl(struct efx_nic *efx, unsigned int reg)
-{
-	return (__force __le32)__raw_readl(efx->membase + reg);
-}
-
-/* Writes to a normal 16-byte Falcon register, locking as appropriate. */
-static inline void falcon_write(struct efx_nic *efx, efx_oword_t *value,
-				unsigned int reg)
-{
-	unsigned long flags;
-
-	EFX_REGDUMP(efx, "writing register %x with " EFX_OWORD_FMT "\n", reg,
-		    EFX_OWORD_VAL(*value));
-
-	spin_lock_irqsave(&efx->biu_lock, flags);
-#ifdef FALCON_USE_QWORD_IO
-	_falcon_writeq(efx, value->u64[0], reg + 0);
-	wmb();
-	_falcon_writeq(efx, value->u64[1], reg + 8);
-#else
-	_falcon_writel(efx, value->u32[0], reg + 0);
-	_falcon_writel(efx, value->u32[1], reg + 4);
-	_falcon_writel(efx, value->u32[2], reg + 8);
-	wmb();
-	_falcon_writel(efx, value->u32[3], reg + 12);
-#endif
-	mmiowb();
-	spin_unlock_irqrestore(&efx->biu_lock, flags);
-}
-
-/* Writes to an 8-byte Falcon SRAM register, locking as appropriate. */
-static inline void falcon_write_sram(struct efx_nic *efx, efx_qword_t *value,
-				     unsigned int index)
-{
-	unsigned int reg = efx->type->buf_tbl_base + (index * sizeof(*value));
-	unsigned long flags;
-
-	EFX_REGDUMP(efx, "writing SRAM register %x with " EFX_QWORD_FMT "\n",
-		    reg, EFX_QWORD_VAL(*value));
-
-	spin_lock_irqsave(&efx->biu_lock, flags);
-#ifdef FALCON_USE_QWORD_IO
-	_falcon_writeq(efx, value->u64[0], reg + 0);
-#else
-	_falcon_writel(efx, value->u32[0], reg + 0);
-	wmb();
-	_falcon_writel(efx, value->u32[1], reg + 4);
-#endif
-	mmiowb();
-	spin_unlock_irqrestore(&efx->biu_lock, flags);
-}
-
-/* Write dword to Falcon register that allows partial writes
- *
- * Some Falcon registers (EVQ_RPTR_REG, RX_DESC_UPD_REG and
- * TX_DESC_UPD_REG) can be written to as a single dword.  This allows
- * for lockless writes.
- */
-static inline void falcon_writel(struct efx_nic *efx, efx_dword_t *value,
-				 unsigned int reg)
-{
-	EFX_REGDUMP(efx, "writing partial register %x with "EFX_DWORD_FMT"\n",
-		    reg, EFX_DWORD_VAL(*value));
-
-	/* No lock required */
-	_falcon_writel(efx, value->u32[0], reg);
-}
-
-/* Read from a Falcon register
- *
- * This reads an entire 16-byte Falcon register in one go, locking as
- * appropriate.  It is essential to read the first dword first, as this
- * prompts Falcon to load the current value into the shadow register.
- */
-static inline void falcon_read(struct efx_nic *efx, efx_oword_t *value,
-			       unsigned int reg)
-{
-	unsigned long flags;
-
-	spin_lock_irqsave(&efx->biu_lock, flags);
-	value->u32[0] = _falcon_readl(efx, reg + 0);
-	rmb();
-	value->u32[1] = _falcon_readl(efx, reg + 4);
-	value->u32[2] = _falcon_readl(efx, reg + 8);
-	value->u32[3] = _falcon_readl(efx, reg + 12);
-	spin_unlock_irqrestore(&efx->biu_lock, flags);
-
-	EFX_REGDUMP(efx, "read from register %x, got " EFX_OWORD_FMT "\n", reg,
-		    EFX_OWORD_VAL(*value));
-}
-
-/* This reads an 8-byte Falcon SRAM entry in one go. */
-static inline void falcon_read_sram(struct efx_nic *efx, efx_qword_t *value,
-				    unsigned int index)
-{
-	unsigned int reg = efx->type->buf_tbl_base + (index * sizeof(*value));
-	unsigned long flags;
-
-	spin_lock_irqsave(&efx->biu_lock, flags);
-#ifdef FALCON_USE_QWORD_IO
-	value->u64[0] = _falcon_readq(efx, reg + 0);
-#else
-	value->u32[0] = _falcon_readl(efx, reg + 0);
-	rmb();
-	value->u32[1] = _falcon_readl(efx, reg + 4);
-#endif
-	spin_unlock_irqrestore(&efx->biu_lock, flags);
-
-	EFX_REGDUMP(efx, "read from SRAM register %x, got "EFX_QWORD_FMT"\n",
-		    reg, EFX_QWORD_VAL(*value));
-}
-
-/* Read dword from Falcon register that allows partial writes (sic) */
-static inline void falcon_readl(struct efx_nic *efx, efx_dword_t *value,
-				unsigned int reg)
-{
-	value->u32[0] = _falcon_readl(efx, reg);
-	EFX_REGDUMP(efx, "read from register %x, got "EFX_DWORD_FMT"\n",
-		    reg, EFX_DWORD_VAL(*value));
-}
-
-/* Write to a register forming part of a table */
-static inline void falcon_write_table(struct efx_nic *efx, efx_oword_t *value,
-				      unsigned int reg, unsigned int index)
-{
-	falcon_write(efx, value, reg + index * sizeof(efx_oword_t));
-}
-
-/* Read to a register forming part of a table */
-static inline void falcon_read_table(struct efx_nic *efx, efx_oword_t *value,
-				     unsigned int reg, unsigned int index)
-{
-	falcon_read(efx, value, reg + index * sizeof(efx_oword_t));
-}
-
-/* Write to a dword register forming part of a table */
-static inline void falcon_writel_table(struct efx_nic *efx, efx_dword_t *value,
-				       unsigned int reg, unsigned int index)
-{
-	falcon_writel(efx, value, reg + index * sizeof(efx_oword_t));
-}
-
-/* Page-mapped register block size */
-#define FALCON_PAGE_BLOCK_SIZE 0x2000
-
-/* Calculate offset to page-mapped register block */
-#define FALCON_PAGED_REG(page, reg) \
-	((page) * FALCON_PAGE_BLOCK_SIZE + (reg))
-
-/* As for falcon_write(), but for a page-mapped register. */
-static inline void falcon_write_page(struct efx_nic *efx, efx_oword_t *value,
-				     unsigned int reg, unsigned int page)
-{
-	falcon_write(efx, value, FALCON_PAGED_REG(page, reg));
-}
-
-/* As for falcon_writel(), but for a page-mapped register. */
-static inline void falcon_writel_page(struct efx_nic *efx, efx_dword_t *value,
-				      unsigned int reg, unsigned int page)
-{
-	falcon_writel(efx, value, FALCON_PAGED_REG(page, reg));
-}
-
-/* Write dword to Falcon page-mapped register with an extra lock.
- *
- * As for falcon_writel_page(), but for a register that suffers from
- * SFC bug 3181.  If writing to page 0, take out a lock so the BIU
- * collector cannot be confused.
- */
-static inline void falcon_writel_page_locked(struct efx_nic *efx,
-					     efx_dword_t *value,
-					     unsigned int reg,
-					     unsigned int page)
-{
-	unsigned long flags = 0;
-
-	if (page == 0)
-		spin_lock_irqsave(&efx->biu_lock, flags);
-	falcon_writel(efx, value, FALCON_PAGED_REG(page, reg));
-	if (page == 0)
-		spin_unlock_irqrestore(&efx->biu_lock, flags);
-}
-
-#endif /* EFX_FALCON_IO_H */
diff -r 5b3d4d3c1166 drivers/net/sfc/falcon_xmac.c
--- a/drivers/net/sfc/falcon_xmac.c	Fri Nov 05 15:20:28 2010 +0000
+++ b/drivers/net/sfc/falcon_xmac.c	Tue Nov 09 10:06:27 2010 +0000
@@ -1,7 +1,7 @@
 /****************************************************************************
  * Driver for Solarflare Solarstorm network controllers and boards
  * Copyright 2005-2006 Fen Systems Ltd.
- * Copyright 2006-2008 Solarflare Communications Inc.
+ * Copyright 2006-2009 Solarflare Communications Inc.
  *
  * This program is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 as published
@@ -11,13 +11,12 @@
 #include <linux/delay.h>
 #include "net_driver.h"
 #include "efx.h"
-#include "falcon.h"
-#include "falcon_hwdefs.h"
-#include "falcon_io.h"
+#include "nic.h"
+#include "regs.h"
+#include "io.h"
 #include "mac.h"
 #include "mdio_10g.h"
 #include "phy.h"
-#include "boards.h"
 #include "workarounds.h"
 
 /**************************************************************************
@@ -27,7 +26,7 @@
  *************************************************************************/
 
 /* Configure the XAUI driver that is an output from Falcon */
-static void falcon_setup_xaui(struct efx_nic *efx)
+void falcon_setup_xaui(struct efx_nic *efx)
 {
 	efx_oword_t sdctl, txdrv;
 
@@ -36,167 +35,166 @@ static void falcon_setup_xaui(struct efx
 	if (efx->phy_type == PHY_TYPE_NONE)
 		return;
 
-	falcon_read(efx, &sdctl, XX_SD_CTL_REG);
-	EFX_SET_OWORD_FIELD(sdctl, XX_HIDRVD, XX_SD_CTL_DRV_DEFAULT);
-	EFX_SET_OWORD_FIELD(sdctl, XX_LODRVD, XX_SD_CTL_DRV_DEFAULT);
-	EFX_SET_OWORD_FIELD(sdctl, XX_HIDRVC, XX_SD_CTL_DRV_DEFAULT);
-	EFX_SET_OWORD_FIELD(sdctl, XX_LODRVC, XX_SD_CTL_DRV_DEFAULT);
-	EFX_SET_OWORD_FIELD(sdctl, XX_HIDRVB, XX_SD_CTL_DRV_DEFAULT);
-	EFX_SET_OWORD_FIELD(sdctl, XX_LODRVB, XX_SD_CTL_DRV_DEFAULT);
-	EFX_SET_OWORD_FIELD(sdctl, XX_HIDRVA, XX_SD_CTL_DRV_DEFAULT);
-	EFX_SET_OWORD_FIELD(sdctl, XX_LODRVA, XX_SD_CTL_DRV_DEFAULT);
-	falcon_write(efx, &sdctl, XX_SD_CTL_REG);
+	efx_reado(efx, &sdctl, FR_AB_XX_SD_CTL);
+	EFX_SET_OWORD_FIELD(sdctl, FRF_AB_XX_HIDRVD, FFE_AB_XX_SD_CTL_DRV_DEF);
+	EFX_SET_OWORD_FIELD(sdctl, FRF_AB_XX_LODRVD, FFE_AB_XX_SD_CTL_DRV_DEF);
+	EFX_SET_OWORD_FIELD(sdctl, FRF_AB_XX_HIDRVC, FFE_AB_XX_SD_CTL_DRV_DEF);
+	EFX_SET_OWORD_FIELD(sdctl, FRF_AB_XX_LODRVC, FFE_AB_XX_SD_CTL_DRV_DEF);
+	EFX_SET_OWORD_FIELD(sdctl, FRF_AB_XX_HIDRVB, FFE_AB_XX_SD_CTL_DRV_DEF);
+	EFX_SET_OWORD_FIELD(sdctl, FRF_AB_XX_LODRVB, FFE_AB_XX_SD_CTL_DRV_DEF);
+	EFX_SET_OWORD_FIELD(sdctl, FRF_AB_XX_HIDRVA, FFE_AB_XX_SD_CTL_DRV_DEF);
+	EFX_SET_OWORD_FIELD(sdctl, FRF_AB_XX_LODRVA, FFE_AB_XX_SD_CTL_DRV_DEF);
+	efx_writeo(efx, &sdctl, FR_AB_XX_SD_CTL);
 
 	EFX_POPULATE_OWORD_8(txdrv,
-			     XX_DEQD, XX_TXDRV_DEQ_DEFAULT,
-			     XX_DEQC, XX_TXDRV_DEQ_DEFAULT,
-			     XX_DEQB, XX_TXDRV_DEQ_DEFAULT,
-			     XX_DEQA, XX_TXDRV_DEQ_DEFAULT,
-			     XX_DTXD, XX_TXDRV_DTX_DEFAULT,
-			     XX_DTXC, XX_TXDRV_DTX_DEFAULT,
-			     XX_DTXB, XX_TXDRV_DTX_DEFAULT,
-			     XX_DTXA, XX_TXDRV_DTX_DEFAULT);
-	falcon_write(efx, &txdrv, XX_TXDRV_CTL_REG);
+			     FRF_AB_XX_DEQD, FFE_AB_XX_TXDRV_DEQ_DEF,
+			     FRF_AB_XX_DEQC, FFE_AB_XX_TXDRV_DEQ_DEF,
+			     FRF_AB_XX_DEQB, FFE_AB_XX_TXDRV_DEQ_DEF,
+			     FRF_AB_XX_DEQA, FFE_AB_XX_TXDRV_DEQ_DEF,
+			     FRF_AB_XX_DTXD, FFE_AB_XX_TXDRV_DTX_DEF,
+			     FRF_AB_XX_DTXC, FFE_AB_XX_TXDRV_DTX_DEF,
+			     FRF_AB_XX_DTXB, FFE_AB_XX_TXDRV_DTX_DEF,
+			     FRF_AB_XX_DTXA, FFE_AB_XX_TXDRV_DTX_DEF);
+	efx_writeo(efx, &txdrv, FR_AB_XX_TXDRV_CTL);
 }
 
 int falcon_reset_xaui(struct efx_nic *efx)
 {
+	struct falcon_nic_data *nic_data = efx->nic_data;
 	efx_oword_t reg;
 	int count;
 
+	/* Don't fetch MAC statistics over an XMAC reset */
+	WARN_ON(nic_data->stats_disable_count == 0);
+
 	/* Start reset sequence */
-	EFX_POPULATE_DWORD_1(reg, XX_RST_XX_EN, 1);
-	falcon_write(efx, &reg, XX_PWR_RST_REG);
+	EFX_POPULATE_OWORD_1(reg, FRF_AB_XX_RST_XX_EN, 1);
+	efx_writeo(efx, &reg, FR_AB_XX_PWR_RST);
 
 	/* Wait up to 10 ms for completion, then reinitialise */
 	for (count = 0; count < 1000; count++) {
-		falcon_read(efx, &reg, XX_PWR_RST_REG);
-		if (EFX_OWORD_FIELD(reg, XX_RST_XX_EN) == 0 &&
-		    EFX_OWORD_FIELD(reg, XX_SD_RST_ACT) == 0) {
+		efx_reado(efx, &reg, FR_AB_XX_PWR_RST);
+		if (EFX_OWORD_FIELD(reg, FRF_AB_XX_RST_XX_EN) == 0 &&
+		    EFX_OWORD_FIELD(reg, FRF_AB_XX_SD_RST_ACT) == 0) {
 			falcon_setup_xaui(efx);
 			return 0;
 		}
 		udelay(10);
 	}
-	EFX_ERR(efx, "timed out waiting for XAUI/XGXS reset\n");
+	netif_err(efx, hw, efx->net_dev,
+		  "timed out waiting for XAUI/XGXS reset\n");
 	return -ETIMEDOUT;
 }
 
-static void falcon_mask_status_intr(struct efx_nic *efx, bool enable)
+static void falcon_ack_status_intr(struct efx_nic *efx)
 {
 	efx_oword_t reg;
 
-	if ((falcon_rev(efx) != FALCON_REV_B0) || LOOPBACK_INTERNAL(efx))
+	if ((efx_nic_rev(efx) != EFX_REV_FALCON_B0) || LOOPBACK_INTERNAL(efx))
 		return;
 
-	/* We expect xgmii faults if the wireside link is up */
-	if (!EFX_WORKAROUND_5147(efx) || !efx->link_up)
+	/* We expect xgmii faults if the wireside link is down */
+	if (!EFX_WORKAROUND_5147(efx) || !efx->link_state.up)
 		return;
 
 	/* We can only use this interrupt to signal the negative edge of
 	 * xaui_align [we have to poll the positive edge]. */
-	if (!efx->mac_up)
+	if (efx->xmac_poll_required)
 		return;
 
-	/* Flush the ISR */
-	if (enable)
-		falcon_read(efx, &reg, XM_MGT_INT_REG_B0);
-
-	EFX_POPULATE_OWORD_2(reg,
-			     XM_MSK_RMTFLT, !enable,
-			     XM_MSK_LCLFLT, !enable);
-	falcon_write(efx, &reg, XM_MGT_INT_MSK_REG_B0);
+	efx_reado(efx, &reg, FR_AB_XM_MGT_INT_MSK);
 }
 
-/* Get status of XAUI link */
-bool falcon_xaui_link_ok(struct efx_nic *efx)
+static bool falcon_xgxs_link_ok(struct efx_nic *efx)
 {
 	efx_oword_t reg;
 	bool align_done, link_ok = false;
 	int sync_status;
 
-	if (LOOPBACK_INTERNAL(efx))
-		return true;
+	/* Read link status */
+	efx_reado(efx, &reg, FR_AB_XX_CORE_STAT);
 
-	/* Read link status */
-	falcon_read(efx, &reg, XX_CORE_STAT_REG);
-
-	align_done = EFX_OWORD_FIELD(reg, XX_ALIGN_DONE);
-	sync_status = EFX_OWORD_FIELD(reg, XX_SYNC_STAT);
-	if (align_done && (sync_status == XX_SYNC_STAT_DECODE_SYNCED))
+	align_done = EFX_OWORD_FIELD(reg, FRF_AB_XX_ALIGN_DONE);
+	sync_status = EFX_OWORD_FIELD(reg, FRF_AB_XX_SYNC_STAT);
+	if (align_done && (sync_status == FFE_AB_XX_STAT_ALL_LANES))
 		link_ok = true;
 
 	/* Clear link status ready for next read */
-	EFX_SET_OWORD_FIELD(reg, XX_COMMA_DET, XX_COMMA_DET_RESET);
-	EFX_SET_OWORD_FIELD(reg, XX_CHARERR, XX_CHARERR_RESET);
-	EFX_SET_OWORD_FIELD(reg, XX_DISPERR, XX_DISPERR_RESET);
-	falcon_write(efx, &reg, XX_CORE_STAT_REG);
-
-	/* If the link is up, then check the phy side of the xaui link */
-	if (efx->link_up && link_ok)
-		if (efx->phy_op->mmds & (1 << MDIO_MMD_PHYXS))
-			link_ok = efx_mdio_phyxgxs_lane_sync(efx);
+	EFX_SET_OWORD_FIELD(reg, FRF_AB_XX_COMMA_DET, FFE_AB_XX_STAT_ALL_LANES);
+	EFX_SET_OWORD_FIELD(reg, FRF_AB_XX_CHAR_ERR, FFE_AB_XX_STAT_ALL_LANES);
+	EFX_SET_OWORD_FIELD(reg, FRF_AB_XX_DISPERR, FFE_AB_XX_STAT_ALL_LANES);
+	efx_writeo(efx, &reg, FR_AB_XX_CORE_STAT);
 
 	return link_ok;
+}
+
+static bool falcon_xmac_link_ok(struct efx_nic *efx)
+{
+	/*
+	 * Check MAC's XGXS link status except when using XGMII loopback
+	 * which bypasses the XGXS block.
+	 * If possible, check PHY's XGXS link status except when using
+	 * MAC loopback.
+	 */
+	return (efx->loopback_mode == LOOPBACK_XGMII ||
+		falcon_xgxs_link_ok(efx)) &&
+		(!(efx->mdio.mmds & (1 << MDIO_MMD_PHYXS)) ||
+		 LOOPBACK_INTERNAL(efx) || 
+		 efx_mdio_phyxgxs_lane_sync(efx));
 }
 
 static void falcon_reconfigure_xmac_core(struct efx_nic *efx)
 {
 	unsigned int max_frame_len;
 	efx_oword_t reg;
-	bool rx_fc = !!(efx->link_fc & EFX_FC_RX);
+	bool rx_fc = !!(efx->link_state.fc & EFX_FC_RX);
+	bool tx_fc = !!(efx->link_state.fc & EFX_FC_TX);
 
 	/* Configure MAC  - cut-thru mode is hard wired on */
-	EFX_POPULATE_DWORD_3(reg,
-			     XM_RX_JUMBO_MODE, 1,
-			     XM_TX_STAT_EN, 1,
-			     XM_RX_STAT_EN, 1);
-	falcon_write(efx, &reg, XM_GLB_CFG_REG);
+	EFX_POPULATE_OWORD_3(reg,
+			     FRF_AB_XM_RX_JUMBO_MODE, 1,
+			     FRF_AB_XM_TX_STAT_EN, 1,
+			     FRF_AB_XM_RX_STAT_EN, 1);
+	efx_writeo(efx, &reg, FR_AB_XM_GLB_CFG);
 
 	/* Configure TX */
-	EFX_POPULATE_DWORD_6(reg,
-			     XM_TXEN, 1,
-			     XM_TX_PRMBL, 1,
-			     XM_AUTO_PAD, 1,
-			     XM_TXCRC, 1,
-			     XM_FCNTL, 1,
-			     XM_IPG, 0x3);
-	falcon_write(efx, &reg, XM_TX_CFG_REG);
+	EFX_POPULATE_OWORD_6(reg,
+			     FRF_AB_XM_TXEN, 1,
+			     FRF_AB_XM_TX_PRMBL, 1,
+			     FRF_AB_XM_AUTO_PAD, 1,
+			     FRF_AB_XM_TXCRC, 1,
+			     FRF_AB_XM_FCNTL, tx_fc,
+			     FRF_AB_XM_IPG, 0x3);
+	efx_writeo(efx, &reg, FR_AB_XM_TX_CFG);
 
 	/* Configure RX */
-	EFX_POPULATE_DWORD_5(reg,
-			     XM_RXEN, 1,
-			     XM_AUTO_DEPAD, 0,
-			     XM_ACPT_ALL_MCAST, 1,
-			     XM_ACPT_ALL_UCAST, efx->promiscuous,
-			     XM_PASS_CRC_ERR, 1);
-	falcon_write(efx, &reg, XM_RX_CFG_REG);
+	EFX_POPULATE_OWORD_5(reg,
+			     FRF_AB_XM_RXEN, 1,
+			     FRF_AB_XM_AUTO_DEPAD, 0,
+			     FRF_AB_XM_ACPT_ALL_MCAST, 1,
+			     FRF_AB_XM_ACPT_ALL_UCAST, efx->promiscuous,
+			     FRF_AB_XM_PASS_CRC_ERR, 1);
+	efx_writeo(efx, &reg, FR_AB_XM_RX_CFG);
 
 	/* Set frame length */
 	max_frame_len = EFX_MAX_FRAME_LEN(efx->net_dev->mtu);
-	EFX_POPULATE_DWORD_1(reg, XM_MAX_RX_FRM_SIZE, max_frame_len);
-	falcon_write(efx, &reg, XM_RX_PARAM_REG);
-	EFX_POPULATE_DWORD_2(reg,
-			     XM_MAX_TX_FRM_SIZE, max_frame_len,
-			     XM_TX_JUMBO_MODE, 1);
-	falcon_write(efx, &reg, XM_TX_PARAM_REG);
+	EFX_POPULATE_OWORD_1(reg, FRF_AB_XM_MAX_RX_FRM_SIZE, max_frame_len);
+	efx_writeo(efx, &reg, FR_AB_XM_RX_PARAM);
+	EFX_POPULATE_OWORD_2(reg,
+			     FRF_AB_XM_MAX_TX_FRM_SIZE, max_frame_len,
+			     FRF_AB_XM_TX_JUMBO_MODE, 1);
+	efx_writeo(efx, &reg, FR_AB_XM_TX_PARAM);
 
-	EFX_POPULATE_DWORD_2(reg,
-			     XM_PAUSE_TIME, 0xfffe, /* MAX PAUSE TIME */
-			     XM_DIS_FCNTL, !rx_fc);
-	falcon_write(efx, &reg, XM_FC_REG);
+	EFX_POPULATE_OWORD_2(reg,
+			     FRF_AB_XM_PAUSE_TIME, 0xfffe, /* MAX PAUSE TIME */
+			     FRF_AB_XM_DIS_FCNTL, !rx_fc);
+	efx_writeo(efx, &reg, FR_AB_XM_FC);
 
 	/* Set MAC address */
-	EFX_POPULATE_DWORD_4(reg,
-			     XM_ADR_0, efx->net_dev->dev_addr[0],
-			     XM_ADR_1, efx->net_dev->dev_addr[1],
-			     XM_ADR_2, efx->net_dev->dev_addr[2],
-			     XM_ADR_3, efx->net_dev->dev_addr[3]);
-	falcon_write(efx, &reg, XM_ADR_LO_REG);
-	EFX_POPULATE_DWORD_2(reg,
-			     XM_ADR_4, efx->net_dev->dev_addr[4],
-			     XM_ADR_5, efx->net_dev->dev_addr[5]);
-	falcon_write(efx, &reg, XM_ADR_HI_REG);
+	memcpy(&reg, &efx->net_dev->dev_addr[0], 4);
+	efx_writeo(efx, &reg, FR_AB_XM_ADR_LO);
+	memcpy(&reg, &efx->net_dev->dev_addr[4], 2);
+	efx_writeo(efx, &reg, FR_AB_XM_ADR_HI);
 }
 
 static void falcon_reconfigure_xgxs_core(struct efx_nic *efx)
@@ -212,12 +210,13 @@ static void falcon_reconfigure_xgxs_core
 		bool old_xgmii_loopback, old_xgxs_loopback, old_xaui_loopback;
 		bool reset_xgxs;
 
-		falcon_read(efx, &reg, XX_CORE_STAT_REG);
-		old_xgxs_loopback = EFX_OWORD_FIELD(reg, XX_XGXS_LB_EN);
-		old_xgmii_loopback = EFX_OWORD_FIELD(reg, XX_XGMII_LB_EN);
+		efx_reado(efx, &reg, FR_AB_XX_CORE_STAT);
+		old_xgxs_loopback = EFX_OWORD_FIELD(reg, FRF_AB_XX_XGXS_LB_EN);
+		old_xgmii_loopback =
+			EFX_OWORD_FIELD(reg, FRF_AB_XX_XGMII_LB_EN);
 
-		falcon_read(efx, &reg, XX_SD_CTL_REG);
-		old_xaui_loopback = EFX_OWORD_FIELD(reg, XX_LPBKA);
+		efx_reado(efx, &reg, FR_AB_XX_SD_CTL);
+		old_xaui_loopback = EFX_OWORD_FIELD(reg, FRF_AB_XX_LPBKA);
 
 		/* The PHY driver may have turned XAUI off */
 		reset_xgxs = ((xgxs_loopback != old_xgxs_loopback) ||
@@ -228,65 +227,70 @@ static void falcon_reconfigure_xgxs_core
 			falcon_reset_xaui(efx);
 	}
 
-	falcon_read(efx, &reg, XX_CORE_STAT_REG);
-	EFX_SET_OWORD_FIELD(reg, XX_FORCE_SIG,
+	efx_reado(efx, &reg, FR_AB_XX_CORE_STAT);
+	EFX_SET_OWORD_FIELD(reg, FRF_AB_XX_FORCE_SIG,
 			    (xgxs_loopback || xaui_loopback) ?
-			    XX_FORCE_SIG_DECODE_FORCED : 0);
-	EFX_SET_OWORD_FIELD(reg, XX_XGXS_LB_EN, xgxs_loopback);
-	EFX_SET_OWORD_FIELD(reg, XX_XGMII_LB_EN, xgmii_loopback);
-	falcon_write(efx, &reg, XX_CORE_STAT_REG);
+			    FFE_AB_XX_FORCE_SIG_ALL_LANES : 0);
+	EFX_SET_OWORD_FIELD(reg, FRF_AB_XX_XGXS_LB_EN, xgxs_loopback);
+	EFX_SET_OWORD_FIELD(reg, FRF_AB_XX_XGMII_LB_EN, xgmii_loopback);
+	efx_writeo(efx, &reg, FR_AB_XX_CORE_STAT);
 
-	falcon_read(efx, &reg, XX_SD_CTL_REG);
-	EFX_SET_OWORD_FIELD(reg, XX_LPBKD, xaui_loopback);
-	EFX_SET_OWORD_FIELD(reg, XX_LPBKC, xaui_loopback);
-	EFX_SET_OWORD_FIELD(reg, XX_LPBKB, xaui_loopback);
-	EFX_SET_OWORD_FIELD(reg, XX_LPBKA, xaui_loopback);
-	falcon_write(efx, &reg, XX_SD_CTL_REG);
+	efx_reado(efx, &reg, FR_AB_XX_SD_CTL);
+	EFX_SET_OWORD_FIELD(reg, FRF_AB_XX_LPBKD, xaui_loopback);
+	EFX_SET_OWORD_FIELD(reg, FRF_AB_XX_LPBKC, xaui_loopback);
+	EFX_SET_OWORD_FIELD(reg, FRF_AB_XX_LPBKB, xaui_loopback);
+	EFX_SET_OWORD_FIELD(reg, FRF_AB_XX_LPBKA, xaui_loopback);
+	efx_writeo(efx, &reg, FR_AB_XX_SD_CTL);
 }
 
 
-/* Try and bring the Falcon side of the Falcon-Phy XAUI link fails
- * to come back up. Bash it until it comes back up */
-static void falcon_check_xaui_link_up(struct efx_nic *efx, int tries)
+/* Try to bring up the Falcon side of the Falcon-Phy XAUI link */
+static bool falcon_xmac_link_ok_retry(struct efx_nic *efx, int tries)
 {
-	efx->mac_up = falcon_xaui_link_ok(efx);
+	bool mac_up = falcon_xmac_link_ok(efx);
 
-	if ((efx->loopback_mode == LOOPBACK_NETWORK) ||
+	if (LOOPBACK_MASK(efx) & LOOPBACKS_EXTERNAL(efx) & LOOPBACKS_WS ||
 	    efx_phy_mode_disabled(efx->phy_mode))
 		/* XAUI link is expected to be down */
-		return;
+		return mac_up;
 
-	while (!efx->mac_up && tries) {
-		EFX_LOG(efx, "bashing xaui\n");
+	falcon_stop_nic_stats(efx);
+
+	while (!mac_up && tries) {
+		netif_dbg(efx, hw, efx->net_dev, "bashing xaui\n");
 		falcon_reset_xaui(efx);
 		udelay(200);
 
-		efx->mac_up = falcon_xaui_link_ok(efx);
+		mac_up = falcon_xmac_link_ok(efx);
 		--tries;
 	}
+
+	falcon_start_nic_stats(efx);
+
+	return mac_up;
 }
 
-static void falcon_reconfigure_xmac(struct efx_nic *efx)
+static bool falcon_xmac_check_fault(struct efx_nic *efx)
 {
-	falcon_mask_status_intr(efx, false);
+	return !falcon_xmac_link_ok_retry(efx, 5);
+}
 
+static int falcon_reconfigure_xmac(struct efx_nic *efx)
+{
 	falcon_reconfigure_xgxs_core(efx);
 	falcon_reconfigure_xmac_core(efx);
 
 	falcon_reconfigure_mac_wrapper(efx);
 
-	falcon_check_xaui_link_up(efx, 5);
-	falcon_mask_status_intr(efx, true);
+	efx->xmac_poll_required = !falcon_xmac_link_ok_retry(efx, 5);
+	falcon_ack_status_intr(efx);
+
+	return 0;
 }
 
 static void falcon_update_stats_xmac(struct efx_nic *efx)
 {
 	struct efx_mac_stats *mac_stats = &efx->mac_stats;
-	int rc;
-
-	rc = falcon_dma_stats(efx, XgDmaDone_offset);
-	if (rc)
-		return;
 
 	/* Update MAC stats from DMAed values */
 	FALCON_STAT(efx, XgRxOctets, rx_bytes);
@@ -344,35 +348,18 @@ static void falcon_update_stats_xmac(str
 		 mac_stats->rx_control * 64);
 }
 
-static void falcon_xmac_irq(struct efx_nic *efx)
+void falcon_poll_xmac(struct efx_nic *efx)
 {
-	/* The XGMII link has a transient fault, which indicates either:
-	 *   - there's a transient xgmii fault
-	 *   - falcon's end of the xaui link may need a kick
-	 *   - the wire-side link may have gone down, but the lasi/poll()
-	 *     hasn't noticed yet.
-	 *
-	 * We only want to even bother polling XAUI if we're confident it's
-	 * not (1) or (3). In both cases, the only reliable way to spot this
-	 * is to wait a bit. We do this here by forcing the mac link state
-	 * to down, and waiting for the mac poll to come round and check
-	 */
-	efx->mac_up = false;
-}
-
-static void falcon_poll_xmac(struct efx_nic *efx)
-{
-	if (!EFX_WORKAROUND_5147(efx) || !efx->link_up || efx->mac_up)
+	if (!EFX_WORKAROUND_5147(efx) || !efx->link_state.up ||
+	    !efx->xmac_poll_required)
 		return;
 
-	falcon_mask_status_intr(efx, false);
-	falcon_check_xaui_link_up(efx, 1);
-	falcon_mask_status_intr(efx, true);
+	efx->xmac_poll_required = !falcon_xmac_link_ok_retry(efx, 1);
+	falcon_ack_status_intr(efx);
 }
 
 struct efx_mac_operations falcon_xmac_operations = {
 	.reconfigure	= falcon_reconfigure_xmac,
 	.update_stats	= falcon_update_stats_xmac,
-	.irq		= falcon_xmac_irq,
-	.poll		= falcon_poll_xmac,
+	.check_fault	= falcon_xmac_check_fault,
 };
diff -r 5b3d4d3c1166 drivers/net/sfc/filter.c
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/drivers/net/sfc/filter.c	Tue Nov 09 10:06:27 2010 +0000
@@ -0,0 +1,591 @@
+/****************************************************************************
+ * Driver for Solarflare Solarstorm network controllers and boards
+ * Copyright 2005-2010 Solarflare Communications Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 as published
+ * by the Free Software Foundation, incorporated herein by reference.
+ */
+
+#include "efx.h"
+#include "filter.h"
+#include "io.h"
+#include "nic.h"
+#include "regs.h"
+
+/* "Fudge factors" - difference between programmed value and actual depth.
+ * Due to pipelined implementation we need to program H/W with a value that
+ * is larger than the hop limit we want.
+ */
+#define FILTER_CTL_SRCH_FUDGE_WILD 3
+#define FILTER_CTL_SRCH_FUDGE_FULL 1
+
+/* Hard maximum hop limit.  Hardware will time-out beyond 200-something.
+ * We also need to avoid infinite loops in efx_filter_search() when the
+ * table is full.
+ */
+#define FILTER_CTL_SRCH_MAX 200
+
+struct efx_filter_table {
+	u32		offset;		/* address of table relative to BAR */
+	unsigned	size;		/* number of entries */
+	unsigned	step;		/* step between entries */
+	unsigned	used;		/* number currently used */
+	unsigned long	*used_bitmap;
+	struct efx_filter_spec *spec;
+};
+
+struct efx_filter_state {
+	spinlock_t 	lock;
+	struct efx_filter_table table[EFX_FILTER_TABLE_COUNT];
+	unsigned	search_depth[EFX_FILTER_TYPE_COUNT];
+};
+
+/* The filter hash function is LFSR polynomial x^16 + x^3 + 1 of a 32-bit
+ * key derived from the n-tuple.  The initial LFSR state is 0xffff. */
+static u16 efx_filter_hash(u32 key)
+{
+	u16 tmp;
+
+	/* First 16 rounds */
+	tmp = 0x1fff ^ key >> 16;
+	tmp = tmp ^ tmp >> 3 ^ tmp >> 6;
+	tmp = tmp ^ tmp >> 9;
+	/* Last 16 rounds */
+	tmp = tmp ^ tmp << 13 ^ key;
+	tmp = tmp ^ tmp >> 3 ^ tmp >> 6;
+	return tmp ^ tmp >> 9;
+}
+
+/* To allow for hash collisions, filter search continues at these
+ * increments from the first possible entry selected by the hash. */
+static u16 efx_filter_increment(u32 key)
+{
+	return key * 2 - 1;
+}
+
+static enum efx_filter_table_id
+efx_filter_type_table_id(enum efx_filter_type type)
+{
+	BUILD_BUG_ON(EFX_FILTER_TABLE_RX_IP != (EFX_FILTER_RX_TCP_FULL >> 2));
+	BUILD_BUG_ON(EFX_FILTER_TABLE_RX_IP != (EFX_FILTER_RX_TCP_WILD >> 2));
+	BUILD_BUG_ON(EFX_FILTER_TABLE_RX_IP != (EFX_FILTER_RX_UDP_FULL >> 2));
+	BUILD_BUG_ON(EFX_FILTER_TABLE_RX_IP != (EFX_FILTER_RX_UDP_WILD >> 2));
+	BUILD_BUG_ON(EFX_FILTER_TABLE_RX_MAC != (EFX_FILTER_RX_MAC_FULL >> 2));
+	BUILD_BUG_ON(EFX_FILTER_TABLE_RX_MAC != (EFX_FILTER_RX_MAC_WILD >> 2));
+	BUILD_BUG_ON(EFX_FILTER_TABLE_TX_IP != (EFX_FILTER_TX_TCP_FULL >> 2));
+	BUILD_BUG_ON(EFX_FILTER_TABLE_TX_IP != (EFX_FILTER_TX_TCP_WILD >> 2));
+	BUILD_BUG_ON(EFX_FILTER_TABLE_TX_IP != (EFX_FILTER_TX_UDP_FULL >> 2));
+	BUILD_BUG_ON(EFX_FILTER_TABLE_TX_IP != (EFX_FILTER_TX_UDP_WILD >> 2));
+	BUILD_BUG_ON(EFX_FILTER_TABLE_TX_MAC != (EFX_FILTER_TX_MAC_FULL >> 2));
+	BUILD_BUG_ON(EFX_FILTER_TABLE_TX_MAC != (EFX_FILTER_TX_MAC_WILD >> 2));
+	return type >> 2;
+}
+
+static void
+efx_filter_table_reset_search_depth(struct efx_filter_state *state,
+				    enum efx_filter_table_id table_id)
+{
+	memset(state->search_depth + (table_id << 2), 0,
+	       sizeof(state->search_depth[0]) << 2);
+}
+
+static void efx_filter_push_rx_limits(struct efx_nic *efx)
+{
+	struct efx_filter_state *state = efx->filter_state;
+	efx_oword_t filter_ctl;
+
+	efx_reado(efx, &filter_ctl, FR_BZ_RX_FILTER_CTL);
+
+	EFX_SET_OWORD_FIELD(filter_ctl, FRF_BZ_TCP_FULL_SRCH_LIMIT,
+			    state->search_depth[EFX_FILTER_RX_TCP_FULL] +
+			    FILTER_CTL_SRCH_FUDGE_FULL);
+	EFX_SET_OWORD_FIELD(filter_ctl, FRF_BZ_TCP_WILD_SRCH_LIMIT,
+			    state->search_depth[EFX_FILTER_RX_TCP_WILD] +
+			    FILTER_CTL_SRCH_FUDGE_WILD);
+	EFX_SET_OWORD_FIELD(filter_ctl, FRF_BZ_UDP_FULL_SRCH_LIMIT,
+			    state->search_depth[EFX_FILTER_RX_UDP_FULL] +
+			    FILTER_CTL_SRCH_FUDGE_FULL);
+	EFX_SET_OWORD_FIELD(filter_ctl, FRF_BZ_UDP_WILD_SRCH_LIMIT,
+			    state->search_depth[EFX_FILTER_RX_UDP_WILD] +
+			    FILTER_CTL_SRCH_FUDGE_WILD);
+
+	if (state->table[EFX_FILTER_TABLE_RX_MAC].size) {
+		EFX_SET_OWORD_FIELD(
+			filter_ctl, FRF_CZ_ETHERNET_FULL_SEARCH_LIMIT, 
+			state->search_depth[EFX_FILTER_RX_MAC_FULL] +
+			FILTER_CTL_SRCH_FUDGE_FULL);
+		EFX_SET_OWORD_FIELD(
+			filter_ctl, FRF_CZ_ETHERNET_WILDCARD_SEARCH_LIMIT,
+			state->search_depth[EFX_FILTER_RX_MAC_WILD] +
+			FILTER_CTL_SRCH_FUDGE_WILD);
+	}
+
+	efx_writeo(efx, &filter_ctl, FR_BZ_RX_FILTER_CTL);
+}
+
+static void efx_filter_push_tx_limits(struct efx_nic *efx)
+{
+	struct efx_filter_state *state = efx->filter_state;
+	efx_oword_t tx_cfg;
+
+	if (state->table[EFX_FILTER_TABLE_TX_IP].size == 0)
+		return;
+
+	efx_reado(efx, &tx_cfg, FR_AZ_TX_CFG);
+
+	EFX_SET_OWORD_FIELD(tx_cfg, FRF_CZ_TX_TCPIP_FILTER_FULL_SEARCH_RANGE,
+			    state->search_depth[EFX_FILTER_TX_TCP_FULL] +
+			    FILTER_CTL_SRCH_FUDGE_FULL);
+	EFX_SET_OWORD_FIELD(tx_cfg, FRF_CZ_TX_TCPIP_FILTER_WILD_SEARCH_RANGE,
+			    state->search_depth[EFX_FILTER_TX_TCP_WILD] +
+			    FILTER_CTL_SRCH_FUDGE_WILD);
+	EFX_SET_OWORD_FIELD(tx_cfg, FRF_CZ_TX_UDPIP_FILTER_FULL_SEARCH_RANGE,
+			    state->search_depth[EFX_FILTER_TX_UDP_FULL] +
+			    FILTER_CTL_SRCH_FUDGE_FULL);
+	EFX_SET_OWORD_FIELD(tx_cfg, FRF_CZ_TX_UDPIP_FILTER_WILD_SEARCH_RANGE,
+			    state->search_depth[EFX_FILTER_TX_UDP_WILD] +
+			    FILTER_CTL_SRCH_FUDGE_WILD);
+
+	efx_writeo(efx, &tx_cfg, FR_AZ_TX_CFG);
+}
+
+/* Build a filter entry and return its n-tuple key. */
+static u32 efx_filter_build(efx_oword_t *filter, struct efx_filter_spec *spec)
+{
+	u32 data3;
+
+	switch (efx_filter_type_table_id(spec->type)) {
+	case EFX_FILTER_TABLE_RX_IP: {
+		bool is_udp = (spec->type == EFX_FILTER_RX_UDP_FULL ||
+			       spec->type == EFX_FILTER_RX_UDP_WILD);
+		EFX_POPULATE_OWORD_7(
+			*filter,
+			FRF_BZ_RSS_EN,
+			!!(spec->flags & EFX_FILTER_FLAG_RX_RSS),
+			FRF_BZ_SCATTER_EN,
+			!!(spec->flags & EFX_FILTER_FLAG_RX_SCATTER),
+			FRF_BZ_TCP_UDP, is_udp,
+			FRF_BZ_RXQ_ID, spec->dmaq_id,
+			EFX_DWORD_2, spec->data[2],
+			EFX_DWORD_1, spec->data[1],
+			EFX_DWORD_0, spec->data[0]);
+		data3 = is_udp;
+		break;
+	}
+
+	case EFX_FILTER_TABLE_RX_MAC: {
+		bool is_wild = spec->type == EFX_FILTER_RX_MAC_WILD;
+		EFX_POPULATE_OWORD_8(
+			*filter,
+			FRF_CZ_RMFT_RSS_EN,
+			!!(spec->flags & EFX_FILTER_FLAG_RX_RSS),
+			FRF_CZ_RMFT_SCATTER_EN,
+			!!(spec->flags & EFX_FILTER_FLAG_RX_SCATTER),
+			FRF_CZ_RMFT_IP_OVERRIDE,
+			!!(spec->flags & EFX_FILTER_FLAG_RX_OVERRIDE_IP),
+			FRF_CZ_RMFT_RXQ_ID, spec->dmaq_id,
+			FRF_CZ_RMFT_WILDCARD_MATCH, is_wild,
+			FRF_CZ_RMFT_DEST_MAC_HI, spec->data[2],
+			FRF_CZ_RMFT_DEST_MAC_LO, spec->data[1],
+			FRF_CZ_RMFT_VLAN_ID, spec->data[0]);
+		data3 = is_wild;
+		break;
+	}
+
+	case EFX_FILTER_TABLE_TX_IP: {
+		bool is_udp = (spec->type == EFX_FILTER_TX_UDP_FULL ||
+			       spec->type == EFX_FILTER_TX_UDP_WILD);
+		EFX_POPULATE_OWORD_5(*filter,
+				     FRF_CZ_TIFT_TCP_UDP, is_udp,
+				     FRF_CZ_TIFT_TXQ_ID, spec->dmaq_id,
+				     EFX_DWORD_2, spec->data[2],
+				     EFX_DWORD_1, spec->data[1],
+				     EFX_DWORD_0, spec->data[0]);
+		data3 = is_udp | spec->dmaq_id << 1;
+		break;
+	}
+
+	case EFX_FILTER_TABLE_TX_MAC: {
+		bool is_wild = spec->type == EFX_FILTER_TX_MAC_WILD;
+		EFX_POPULATE_OWORD_5(*filter,
+				     FRF_CZ_TMFT_TXQ_ID, spec->dmaq_id,
+				     FRF_CZ_TMFT_WILDCARD_MATCH, is_wild,
+				     FRF_CZ_TMFT_SRC_MAC_HI, spec->data[2],
+				     FRF_CZ_TMFT_SRC_MAC_LO, spec->data[1],
+				     FRF_CZ_TMFT_VLAN_ID, spec->data[0]);
+		data3 = is_wild | spec->dmaq_id << 1;
+		break;
+	}
+
+	default:
+#ifdef EFX_USE_KCOMPAT
+		/* Needed if BUG() is not declared as noreturn */
+		data3 = 0;
+#endif
+		BUG();
+	}
+
+	return spec->data[0] ^ spec->data[1] ^ spec->data[2] ^ data3;
+}
+
+static bool efx_filter_equal(const struct efx_filter_spec *left,
+			     const struct efx_filter_spec *right)
+{
+	enum efx_filter_table_id table_id =
+		efx_filter_type_table_id(left->type);
+	
+	if (left->type != right->type ||
+	    memcmp(left->data, right->data, sizeof(left->data)))
+		return false;
+
+	if ((table_id == EFX_FILTER_TABLE_TX_IP ||
+	     table_id == EFX_FILTER_TABLE_TX_MAC) &&
+	    left->dmaq_id != right->dmaq_id)
+		return false;
+
+	return true;
+}
+
+static int efx_filter_search(struct efx_filter_table *table,
+			     struct efx_filter_spec *spec, u32 key,
+			     bool for_insert, int *depth_required)
+{
+	unsigned hash, incr, filter_idx, depth;
+	struct efx_filter_spec *cmp;
+	
+	hash = efx_filter_hash(key);
+	incr = efx_filter_increment(key);
+
+	for (depth = 1, filter_idx = hash & (table->size - 1);
+	     depth <= FILTER_CTL_SRCH_MAX &&
+		     test_bit(filter_idx, table->used_bitmap);
+	     ++depth) {
+		cmp = &table->spec[filter_idx];
+		if (efx_filter_equal(spec, cmp))
+			goto found;
+		filter_idx = (filter_idx + incr) & (table->size - 1);
+	}
+	if (!for_insert)
+		return -ENOENT;
+	if (depth > FILTER_CTL_SRCH_MAX)
+		return -EBUSY;
+found:
+	*depth_required = depth;
+	return filter_idx;
+}
+
+/**
+ * efx_filter_insert_filter - add or replace a filter
+ * @efx: NIC in which to insert the filter
+ * @spec: Specification for the filter
+ * @replace: Flag for whether the specified filter may replace a filter
+ *	with an identical match expression and equal or lower priority
+ *
+ * On success, return the filter index within its table.
+ * On failure, return a negative error code.
+ */
+int efx_filter_insert_filter(struct efx_nic *efx, struct efx_filter_spec *spec,
+			     bool replace)
+{
+	struct efx_filter_state *state = efx->filter_state;
+	enum efx_filter_table_id table_id =
+		efx_filter_type_table_id(spec->type);
+	struct efx_filter_table *table = &state->table[table_id];
+	struct efx_filter_spec *saved_spec;
+	efx_oword_t filter;
+	int filter_idx, depth;
+	u32 key;
+	int rc;
+
+	if (table->size == 0)
+		return -EINVAL;
+
+	key = efx_filter_build(&filter, spec);
+
+	netif_vdbg(efx, hw, efx->net_dev,
+		   "%s: type %d search_depth=%d", __func__, spec->type,
+		   state->search_depth[spec->type]);
+
+	spin_lock_bh(&state->lock);
+
+	rc = efx_filter_search(table, spec, key, true, &depth);
+	if (rc < 0)
+		goto out;
+	filter_idx = rc;
+	BUG_ON(filter_idx >= table->size);
+	saved_spec = &table->spec[filter_idx];
+
+	if (test_bit(filter_idx, table->used_bitmap)) {
+		/* Should we replace the existing filter? */
+		if (!replace) {
+			rc = -EEXIST;
+			goto out;
+		}
+		if (spec->priority < saved_spec->priority) {
+			rc = -EPERM;
+			goto out;
+		}
+	} else {
+		__set_bit(filter_idx, table->used_bitmap);
+		++table->used;
+	}
+	*saved_spec = *spec;
+
+	if (state->search_depth[spec->type] < depth) {
+		state->search_depth[spec->type] = depth;
+		if (table_id == EFX_FILTER_TABLE_TX_IP ||
+		    table_id == EFX_FILTER_TABLE_TX_MAC)
+			efx_filter_push_tx_limits(efx);
+		else
+			efx_filter_push_rx_limits(efx);
+	}
+
+	efx_writeo(efx, &filter, table->offset + table->step * filter_idx);
+
+	netif_vdbg(efx, hw, efx->net_dev,
+		   "%s: filter type %d index %d rxq %u set",
+		   __func__, spec->type, filter_idx, spec->dmaq_id);
+
+out:
+	spin_unlock_bh(&state->lock);
+	return rc;
+}
+
+static void efx_filter_table_clear_entry(struct efx_nic *efx,
+					 struct efx_filter_table *table,
+					 int filter_idx)
+{
+	static efx_oword_t filter;
+
+	if (test_bit(filter_idx, table->used_bitmap)) {
+		__clear_bit(filter_idx, table->used_bitmap);
+		--table->used;
+		memset(&table->spec[filter_idx], 0, sizeof(table->spec[0]));
+
+		efx_writeo(efx, &filter,
+			   table->offset + table->step * filter_idx);
+	}
+}
+
+/**
+ * efx_filter_remove_filter - remove a filter by specification
+ * @efx: NIC from which to remove the filter
+ * @spec: Specification for the filter
+ *
+ * On success, return zero.
+ * On failure, return a negative error code.
+ */
+int efx_filter_remove_filter(struct efx_nic *efx, struct efx_filter_spec *spec)
+{
+	struct efx_filter_state *state = efx->filter_state;
+	enum efx_filter_table_id table_id =
+		efx_filter_type_table_id(spec->type);
+	struct efx_filter_table *table = &state->table[table_id];
+	struct efx_filter_spec *saved_spec;
+	efx_oword_t filter;
+	int filter_idx, depth;
+	u32 key;
+	int rc;
+
+	key = efx_filter_build(&filter, spec);
+
+	spin_lock_bh(&state->lock);
+
+	rc = efx_filter_search(table, spec, key, false, &depth);
+	if (rc < 0)
+		goto out;
+	filter_idx = rc;
+	saved_spec = &table->spec[filter_idx];
+
+	if (spec->priority < saved_spec->priority) {
+		rc = -EPERM;
+		goto out;
+	}
+
+	efx_filter_table_clear_entry(efx, table, filter_idx);
+	if (table->used == 0)
+		efx_filter_table_reset_search_depth(state, table_id);
+	rc = 0;
+
+out:
+	spin_unlock_bh(&state->lock);
+	return rc;
+}
+
+/**
+ * efx_filter_remove_index - remove a filter by index
+ * @efx: NIC from which to remove the filter
+ * @table_id: Table from which to remove the filter
+ * @filter_idx: Index of filter, as returned by @efx_filter_insert_filter
+ *
+ * If @filter_idx is negative, do nothing.
+ */
+void efx_filter_remove_index(struct efx_nic *efx,
+			     enum efx_filter_table_id table_id,
+			     int filter_idx)
+{
+	struct efx_filter_state *state = efx->filter_state;
+	struct efx_filter_table *table = &state->table[table_id];
+
+	if (filter_idx < 0)
+		return;
+
+	spin_lock_bh(&state->lock);
+
+	efx_filter_table_clear_entry(efx, table, filter_idx);
+	if (table->used == 0)
+		efx_filter_table_reset_search_depth(state, table_id);
+
+	spin_unlock_bh(&state->lock);
+}
+
+/**
+ * efx_filter_table_clear - remove filters from a table by priority
+ * @efx: NIC from which to remove the filters
+ * @table_id: Table from which to remove the filters
+ * @priority: Maximum priority to remove
+ */
+void efx_filter_table_clear(struct efx_nic *efx,
+			    enum efx_filter_table_id table_id,
+			    enum efx_filter_priority priority)
+{
+	struct efx_filter_state *state = efx->filter_state;
+	struct efx_filter_table *table = &state->table[table_id];
+	int filter_idx;
+
+	spin_lock_bh(&state->lock);
+
+	for (filter_idx = 0; filter_idx < table->size; ++filter_idx)
+		if (table->spec[filter_idx].priority <= priority)
+			efx_filter_table_clear_entry(efx, table, filter_idx);
+	if (table->used == 0)
+		efx_filter_table_reset_search_depth(state, table_id);
+
+	spin_unlock_bh(&state->lock);
+}
+
+/**
+ * efx_filter_redirect_index - update the queue for an existing RX filter
+ * @efx: NIC in which to update the filter
+ * @table_id: Table in which the filter exists
+ * @filter_i: Index of filter, as returned by @efx_filter_insert_filter
+ * @rxq_i: Index of RX queue
+ */
+void efx_filter_redirect_index(struct efx_nic *efx,
+			       enum efx_filter_table_id table_id,
+			       int filter_i, int rxq_i)
+{
+	struct efx_filter_state *state = efx->filter_state;
+	struct efx_filter_table *table = &state->table[table_id];
+	struct efx_filter_spec *spec;
+	efx_oword_t filter;
+
+	spin_lock_bh(&state->lock);
+	
+	spec = &table->spec[filter_i];
+	spec->dmaq_id = rxq_i;
+	efx_filter_build(&filter, spec);
+	efx_writeo(efx, &filter, table->offset + table->step * filter_i);
+
+	spin_unlock_bh(&state->lock);
+}
+
+/* Restore filter stater after reset */
+void efx_restore_filters(struct efx_nic *efx)
+{
+	struct efx_filter_state *state = efx->filter_state;
+	enum efx_filter_table_id table_id;
+	struct efx_filter_table *table;
+	efx_oword_t filter;
+	int filter_idx;
+
+	spin_lock_bh(&state->lock);
+
+	for (table_id = 0; table_id < EFX_FILTER_TABLE_COUNT; table_id++) {
+		table = &state->table[table_id];
+		for (filter_idx = 0; filter_idx < table->size; filter_idx++) {
+			if (!test_bit(filter_idx, table->used_bitmap))
+				continue;
+			efx_filter_build(&filter, &table->spec[filter_idx]);
+			efx_writeo(efx, &filter,
+				   table->offset + table->step * filter_idx);
+		}
+	}
+
+	efx_filter_push_rx_limits(efx);
+	efx_filter_push_tx_limits(efx);
+
+	spin_unlock_bh(&state->lock);
+}
+
+int efx_probe_filters(struct efx_nic *efx)
+{
+	struct efx_filter_state *state;
+	struct efx_filter_table *table;
+	unsigned table_id;
+
+	state = kzalloc(sizeof(*efx->filter_state), GFP_KERNEL);
+	if (!state)
+		return -ENOMEM;
+	efx->filter_state = state;
+
+	spin_lock_init(&state->lock);
+
+	if (efx_nic_rev(efx) >= EFX_REV_FALCON_B0) {
+		table = &state->table[EFX_FILTER_TABLE_RX_IP];
+		table->offset = FR_BZ_RX_FILTER_TBL0;
+		table->size = FR_BZ_RX_FILTER_TBL0_ROWS;
+		table->step = FR_BZ_RX_FILTER_TBL0_STEP;
+	}
+
+	if (efx_nic_rev(efx) >= EFX_REV_SIENA_A0) {
+		table = &state->table[EFX_FILTER_TABLE_RX_MAC];
+		table->offset = FR_CZ_RX_MAC_FILTER_TBL0;
+		table->size = FR_CZ_RX_MAC_FILTER_TBL0_ROWS;
+		table->step = FR_CZ_RX_MAC_FILTER_TBL0_STEP;
+
+		table = &state->table[EFX_FILTER_TABLE_TX_IP];
+		table->offset = FR_CZ_TX_FILTER_TBL0;
+		table->size = FR_CZ_TX_FILTER_TBL0_ROWS;
+		table->step = FR_CZ_TX_FILTER_TBL0_STEP;
+
+		table = &state->table[EFX_FILTER_TABLE_TX_MAC];
+		table->offset = FR_CZ_TX_MAC_FILTER_TBL0;
+		table->size = FR_CZ_TX_MAC_FILTER_TBL0_ROWS;
+		table->step = FR_CZ_TX_MAC_FILTER_TBL0_STEP;
+	}
+
+	for (table_id = 0; table_id < EFX_FILTER_TABLE_COUNT; table_id++) {
+		table = &state->table[table_id];
+		if (table->size == 0)
+			continue;
+		table->used_bitmap = kcalloc(BITS_TO_LONGS(table->size),
+					     sizeof(unsigned long),
+					     GFP_KERNEL);
+		if (!table->used_bitmap)
+			goto fail;
+		table->spec = vmalloc(table->size * sizeof(*table->spec));
+		if (!table->spec)
+			goto fail;
+		memset(table->spec, 0, table->size * sizeof(*table->spec));
+	}
+
+	return 0;
+
+fail:
+	efx_remove_filters(efx);
+	return -ENOMEM;
+}
+
+void efx_remove_filters(struct efx_nic *efx)
+{
+	struct efx_filter_state *state = efx->filter_state;
+	enum efx_filter_table_id table_id;
+
+	for (table_id = 0; table_id < EFX_FILTER_TABLE_COUNT; table_id++) {
+		kfree(state->table[table_id].used_bitmap);
+		vfree(state->table[table_id].spec);
+	}
+	kfree(state);
+}
diff -r 5b3d4d3c1166 drivers/net/sfc/filter.h
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/drivers/net/sfc/filter.h	Tue Nov 09 10:06:27 2010 +0000
@@ -0,0 +1,302 @@
+/****************************************************************************
+ * Driver for Solarflare Solarstorm network controllers and boards
+ * Copyright 2005-2010 Solarflare Communications Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 as published
+ * by the Free Software Foundation, incorporated herein by reference.
+ */
+
+#ifndef EFX_FILTER_H
+#define EFX_FILTER_H
+
+#include <linux/types.h>
+
+enum efx_filter_table_id {
+	EFX_FILTER_TABLE_RX_IP = 0,
+	EFX_FILTER_TABLE_RX_MAC,
+	EFX_FILTER_TABLE_TX_IP,
+	EFX_FILTER_TABLE_TX_MAC,
+	EFX_FILTER_TABLE_COUNT,
+};
+
+/**
+ * enum efx_filter_type - type of hardware filter
+ * @EFX_FILTER_RX_TCP_FULL: RX, matching TCP/IPv4 4-tuple
+ * @EFX_FILTER_RX_TCP_WILD: RX, matching TCP/IPv4 destination (host, port)
+ * @EFX_FILTER_RX_UDP_FULL: RX, matching UDP/IPv4 4-tuple
+ * @EFX_FILTER_RX_UDP_WILD: RX, matching UDP/IPv4 destination (host, port)
+ * @EFX_FILTER_RX_MAC_FULL: RX, matching Ethernet destination MAC address, VID
+ * @EFX_FILTER_RX_MAC_WILD: RX, matching Ethernet destination MAC address
+ * @EFX_FILTER_TX_TCP_FULL: TX, matching TCP/IPv4 4-tuple
+ * @EFX_FILTER_TX_TCP_WILD: TX, matching TCP/IPv4 source (host, port)
+ * @EFX_FILTER_TX_UDP_FULL: TX, matching UDP/IPv4 4-tuple
+ * @EFX_FILTER_TX_UDP_WILD: TX, matching UDP/IPv4 source (host, port)
+ * @EFX_FILTER_TX_MAC_FULL: TX, matching Ethernet source MAC address, VID
+ * @EFX_FILTER_TX_MAC_WILD: TX, matching Ethernet source MAC address
+ *
+ * Falcon NICs only support the RX TCP/IPv4 and UDP/IPv4 filter types.
+ */
+enum efx_filter_type {
+	EFX_FILTER_RX_TCP_FULL = 0,
+	EFX_FILTER_RX_TCP_WILD,
+	EFX_FILTER_RX_UDP_FULL,
+	EFX_FILTER_RX_UDP_WILD,
+	EFX_FILTER_RX_MAC_FULL = 4,
+	EFX_FILTER_RX_MAC_WILD,
+	EFX_FILTER_TX_TCP_FULL = 8,
+	EFX_FILTER_TX_TCP_WILD,
+	EFX_FILTER_TX_UDP_FULL,
+	EFX_FILTER_TX_UDP_WILD,
+	EFX_FILTER_TX_MAC_FULL = 12,
+	EFX_FILTER_TX_MAC_WILD,
+	EFX_FILTER_TYPE_COUNT,
+};
+
+/**
+ * enum efx_filter_priority - priority of a hardware filter specification
+ * @EFX_FILTER_PRI_HINT: Performance hint
+ * @EFX_FILTER_PRI_MANUAL: Manually configured filter
+ * @EFX_FILTER_PRI_REQUIRED: Required for correct behaviour (user-level
+ *	networking and SR-IOV)
+ */
+enum efx_filter_priority {
+	EFX_FILTER_PRI_HINT = 0,
+	EFX_FILTER_PRI_MANUAL,
+	EFX_FILTER_PRI_REQUIRED,
+};
+
+/**
+ * enum efx_filter_flags - flags for hardware filter specifications
+ * @EFX_FILTER_FLAG_RX_RSS: Use RSS to spread across multiple queues.
+ *	By default, matching packets will be delivered only to the
+ *	specified queue. If this flag is set, they will be delivered
+ *	to a range of queues offset from the specified queue number
+ *	according to the indirection table.
+ * @EFX_FILTER_FLAG_RX_SCATTER: Enable DMA scatter on the receiving
+ *	queue.
+ * @EFX_FILTER_FLAG_RX_OVERRIDE_IP: Enables a MAC filter to override
+ *	any IP filter that matches the same packet.  By default, IP
+ *	filters take precedence.
+ *
+ * Currently, no flags are defined for TX filters.
+ */
+enum efx_filter_flags {
+	EFX_FILTER_FLAG_RX_RSS = 0x01,
+	EFX_FILTER_FLAG_RX_SCATTER = 0x02,
+	EFX_FILTER_FLAG_RX_OVERRIDE_IP = 0x04,
+};
+
+/**
+ * struct efx_filter_spec - specification for a hardware filter
+ * @type: Type of match to be performed, from &enum efx_filter_type
+ * @priority: Priority of the filter, from &enum efx_filter_priority
+ * @flags: Miscellaneous flags, from &enum efx_filter_flags
+ * @dmaq_id: Source/target queue index
+ * @data: Match data (type-dependent)
+ *
+ * Use the efx_filter_set_*() functions to initialise the @type and
+ * @data fields.
+ */
+struct efx_filter_spec {
+	u8	type : 4;
+	u8	priority : 4;
+	u8	flags;
+	u16	dmaq_id;
+	u32	data[3];
+};
+
+/**
+ * efx_filter_set_rx_tcp_full - specify RX filter with TCP/IPv4 full match
+ * @spec: Specification to initialise
+ * @shost: Source host address (host byte order)
+ * @sport: Source port (host byte order)
+ * @dhost: Destination host address (host byte order)
+ * @dport: Destination port (host byte order)
+ */
+static inline void
+efx_filter_set_rx_tcp_full(struct efx_filter_spec *spec,
+			   u32 shost, u16 sport, u32 dhost, u16 dport)
+{
+	spec->type = EFX_FILTER_RX_TCP_FULL;
+	spec->data[0] = sport | shost << 16;
+	spec->data[1] = dport << 16 | shost >> 16;
+	spec->data[2] = dhost;
+}
+
+/**
+ * efx_filter_set_rx_tcp_wild - specify RX filter with TCP/IPv4 wildcard match
+ * @spec: Specification to initialise
+ * @dhost: Destination host address (host byte order)
+ * @dport: Destination port (host byte order)
+ */
+static inline void
+efx_filter_set_rx_tcp_wild(struct efx_filter_spec *spec, u32 dhost, u16 dport)
+{
+	spec->type = EFX_FILTER_RX_TCP_WILD;
+	spec->data[0] = 0;
+	spec->data[1] = dport << 16;
+	spec->data[2] = dhost;
+}
+
+/**
+ * efx_filter_set_rx_udp_full - specify RX filter with UDP/IPv4 full match
+ * @spec: Specification to initialise
+ * @shost: Source host address (host byte order)
+ * @sport: Source port (host byte order)
+ * @dhost: Destination host address (host byte order)
+ * @dport: Destination port (host byte order)
+ */
+static inline void
+efx_filter_set_rx_udp_full(struct efx_filter_spec *spec,
+			   u32 shost, u16 sport, u32 dhost, u16 dport)
+{
+	spec->type = EFX_FILTER_RX_UDP_FULL;
+	spec->data[0] = sport | shost << 16;
+	spec->data[1] = dport << 16 | shost >> 16;
+	spec->data[2] = dhost;
+}
+
+/**
+ * efx_filter_set_rx_udp_wild - specify RX filter with UDP/IPv4 wildcard match
+ * @spec: Specification to initialise
+ * @dhost: Destination host address (host byte order)
+ * @dport: Destination port (host byte order)
+ */
+static inline void
+efx_filter_set_rx_udp_wild(struct efx_filter_spec *spec, u32 dhost, u16 dport)
+{
+	spec->type = EFX_FILTER_RX_UDP_WILD;
+	spec->data[0] = dport;
+	spec->data[1] = 0;
+	spec->data[2] = dhost;
+}
+
+/**
+ * efx_filter_set_rx_mac_full - specify RX filter with MAC full match
+ * @spec: Specification to initialise
+ * @vid: VLAN ID
+ * @addr: Destination MAC address
+ */
+static inline void efx_filter_set_rx_mac_full(struct efx_filter_spec *spec,
+					      u16 vid, const u8 *addr)
+{
+	spec->type = EFX_FILTER_RX_MAC_FULL;
+	spec->data[0] = vid;
+	spec->data[1] = addr[2] << 24 | addr[3] << 16 | addr[4] << 8 | addr[5];
+	spec->data[2] = addr[0] << 8 | addr[1];
+}
+
+/**
+ * efx_filter_set_rx_mac_full - specify RX filter with MAC wildcard match
+ * @spec: Specification to initialise
+ * @addr: Destination MAC address
+ */
+static inline void efx_filter_set_rx_mac_wild(struct efx_filter_spec *spec,
+					      const u8 *addr)
+{
+	spec->type = EFX_FILTER_RX_MAC_WILD;
+	spec->data[0] = 0;
+	spec->data[1] = addr[2] << 24 | addr[3] << 16 | addr[4] << 8 | addr[5];
+	spec->data[2] = addr[0] << 8 | addr[1];
+}
+
+/**
+ * efx_filter_set_tx_tcp_full - specify TX filter with TCP/IPv4 full match
+ * @spec: Specification to initialise
+ * @shost: Source host address (host byte order)
+ * @sport: Source port (host byte order)
+ * @dhost: Destination host address (host byte order)
+ * @dport: Destination port (host byte order)
+ */
+static inline void
+efx_filter_set_tx_tcp_full(struct efx_filter_spec *spec, unsigned qid,
+			   u32 shost, u16 sport, u32 dhost, u16 dport)
+{
+	spec->type = EFX_FILTER_TX_TCP_FULL;
+	spec->data[0] = sport | shost << 16;
+	spec->data[1] = dport << 16 | shost >> 16;
+	spec->data[2] = dhost;
+}
+
+/**
+ * efx_filter_set_tx_tcp_wild - specify TX filter with TCP/IPv4 wildcard match
+ * @spec: Specification to initialise
+ * @shost: Source host address (host byte order)
+ * @sport: Source port (host byte order)
+ */
+static inline void
+efx_filter_set_tx_tcp_wild(struct efx_filter_spec *spec, unsigned qid,
+			   u32 shost, u16 sport)
+{
+	spec->type = EFX_FILTER_TX_TCP_WILD;
+	spec->data[0] = sport | shost << 16;
+	spec->data[1] = shost >> 16;
+	spec->data[2] = 0;
+}
+
+/**
+ * efx_filter_set_tx_udp_full - specify TX filter with UDP/IPv4 full match
+ * @spec: Specification to initialise
+ * @shost: Source host address (host byte order)
+ * @sport: Source port (host byte order)
+ * @dhost: Destination host address (host byte order)
+ * @dport: Destination port (host byte order)
+ */
+static inline void
+efx_filter_set_tx_udp_full(struct efx_filter_spec *spec, unsigned qid,
+			   u32 shost, u16 sport, u32 dhost, u16 dport)
+{
+	spec->type = EFX_FILTER_TX_UDP_FULL;
+	spec->data[0] = sport | shost << 16;
+	spec->data[1] = dport << 16 | shost >> 16;
+	spec->data[2] = dhost;
+}
+
+/**
+ * efx_filter_set_tx_udp_wild - specify TX filter with UDP/IPv4 wildcard match
+ * @spec: Specification to initialise
+ * @shost: Source host address (host byte order)
+ * @sport: Source port (host byte order)
+ */
+static inline void
+efx_filter_set_tx_udp_wild(struct efx_filter_spec *spec, unsigned qid,
+			   u32 shost, u16 sport)
+{
+	spec->type = EFX_FILTER_TX_UDP_WILD;
+	spec->data[0] = shost << 16;
+	spec->data[1] = sport << 16 | shost >> 16;
+	spec->data[2] = 0;
+}
+
+/**
+ * efx_filter_set_tx_mac_full - specify TX filter with MAC full match
+ * @spec: Specification to initialise
+ * @vid: VLAN ID
+ * @addr: Source MAC address
+ */
+static inline void
+efx_filter_set_tx_mac_full(struct efx_filter_spec *spec, unsigned qid,
+			   u16 vid, const u8 *addr)
+{
+	spec->type = EFX_FILTER_TX_MAC_FULL;
+	spec->data[0] = vid;
+	spec->data[1] = addr[2] << 24 | addr[3] << 16 | addr[4] << 8 | addr[5];
+	spec->data[2] = addr[0] << 8 | addr[1];
+}
+
+/**
+ * efx_filter_set_tx_mac_wild - specify TX filter with MAC wildcard match
+ * @spec: Specification to initialise
+ * @addr: Source MAC address
+ */
+static inline void efx_filter_set_tx_mac_wild(struct efx_filter_spec *spec,
+					      unsigned qid, const u8 *addr)
+{
+	spec->type = EFX_FILTER_TX_MAC_WILD;
+	spec->data[0] = 0;
+	spec->data[1] = addr[2] << 24 | addr[3] << 16 | addr[4] << 8 | addr[5];
+	spec->data[2] = addr[0] << 8 | addr[1];
+}
+
+#endif /* EFX_FILTER_H */
diff -r 5b3d4d3c1166 drivers/net/sfc/gmii.h
--- a/drivers/net/sfc/gmii.h	Fri Nov 05 15:20:28 2010 +0000
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,60 +0,0 @@
-/****************************************************************************
- * Driver for Solarflare Solarstorm network controllers and boards
- * Copyright 2005-2006 Fen Systems Ltd.
- * Copyright 2006-2008 Solarflare Communications Inc.
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 as published
- * by the Free Software Foundation, incorporated herein by reference.
- */
-
-#ifndef EFX_GMII_H
-#define EFX_GMII_H
-
-/*
- * GMII interface
- */
-
-#include <linux/mii.h>
-
-/* GMII registers, excluding registers already defined as MII
- * registers in mii.h
- */
-#define GMII_IER		0x12	/* Interrupt enable register */
-#define GMII_ISR		0x13	/* Interrupt status register */
-
-/* Interrupt enable register */
-#define IER_ANEG_ERR		0x8000	/* Bit 15 - autonegotiation error */
-#define IER_SPEED_CHG		0x4000	/* Bit 14 - speed changed */
-#define IER_DUPLEX_CHG		0x2000	/* Bit 13 - duplex changed */
-#define IER_PAGE_RCVD		0x1000	/* Bit 12 - page received */
-#define IER_ANEG_DONE		0x0800	/* Bit 11 - autonegotiation complete */
-#define IER_LINK_CHG		0x0400	/* Bit 10 - link status changed */
-#define IER_SYM_ERR		0x0200	/* Bit 9 - symbol error */
-#define IER_FALSE_CARRIER	0x0100	/* Bit 8 - false carrier */
-#define IER_FIFO_ERR		0x0080	/* Bit 7 - FIFO over/underflow */
-#define IER_MDIX_CHG		0x0040	/* Bit 6 - MDI crossover changed */
-#define IER_DOWNSHIFT		0x0020	/* Bit 5 - downshift */
-#define IER_ENERGY		0x0010	/* Bit 4 - energy detect */
-#define IER_DTE_POWER		0x0004	/* Bit 2 - DTE power detect */
-#define IER_POLARITY_CHG	0x0002	/* Bit 1 - polarity changed */
-#define IER_JABBER		0x0001	/* Bit 0 - jabber */
-
-/* Interrupt status register */
-#define ISR_ANEG_ERR		0x8000	/* Bit 15 - autonegotiation error */
-#define ISR_SPEED_CHG		0x4000	/* Bit 14 - speed changed */
-#define ISR_DUPLEX_CHG		0x2000	/* Bit 13 - duplex changed */
-#define ISR_PAGE_RCVD		0x1000	/* Bit 12 - page received */
-#define ISR_ANEG_DONE		0x0800	/* Bit 11 - autonegotiation complete */
-#define ISR_LINK_CHG		0x0400	/* Bit 10 - link status changed */
-#define ISR_SYM_ERR		0x0200	/* Bit 9 - symbol error */
-#define ISR_FALSE_CARRIER	0x0100	/* Bit 8 - false carrier */
-#define ISR_FIFO_ERR		0x0080	/* Bit 7 - FIFO over/underflow */
-#define ISR_MDIX_CHG		0x0040	/* Bit 6 - MDI crossover changed */
-#define ISR_DOWNSHIFT		0x0020	/* Bit 5 - downshift */
-#define ISR_ENERGY		0x0010	/* Bit 4 - energy detect */
-#define ISR_DTE_POWER		0x0004	/* Bit 2 - DTE power detect */
-#define ISR_POLARITY_CHG	0x0002	/* Bit 1 - polarity changed */
-#define ISR_JABBER		0x0001	/* Bit 0 - jabber */
-
-#endif /* EFX_GMII_H */
diff -r 5b3d4d3c1166 drivers/net/sfc/idle.c
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/drivers/net/sfc/idle.c	Tue Nov 09 10:06:27 2010 +0000
@@ -0,0 +1,496 @@
+/****************************************************************************
+ * Driver for Solarflare Solarstorm network controllers and boards
+ * Copyright 2007-2008 Solarflare Communications Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 as published
+ * by the Free Software Foundation, incorporated herein by reference.
+ */
+
+/* This file implements an alternate idle loop to work-around an A1
+ * Silicon issue.
+ */
+
+#include <linux/version.h>
+#include <linux/module.h>
+
+#include <linux/sched.h>
+#include <linux/smp_lock.h>
+#include <linux/cpu.h>
+#include <linux/cpumask.h>
+#include <linux/percpu.h>
+#include <linux/sysdev.h>
+#include <asm/atomic.h>
+#include <linux/node.h>
+
+#ifdef EFX_USE_KCOMPAT
+# include "config.h"
+# include "kernel_compat.h"
+#endif
+
+#ifndef EFX_NEED_MUTEX
+#include <linux/mutex.h>
+#endif
+
+#include "idle.h"
+#include "efx.h"
+
+#ifdef EFX_HAVE_PM_IDLE
+
+#define IDLE_DEBUG 0
+
+/* Each CPU is put into a group.  In most cases, the group number is
+ * equal to the CPU number of one of the CPUs in the group.  The
+ * exception is group NR_CPUS which is the default group.  This is
+ * protected by efx_idle_startup_mutex. */
+DEFINE_PER_CPU(int, idle_cpu_group) = NR_CPUS;
+
+/* For each group, a count of the number of CPUs in the group which
+ * are known to be busy.  A busy CPU might be running the busy loop
+ * below or general kernel code.  The count is decremented on entry to
+ * the old pm_idle handler and incremented on exit.  The aim is to
+ * avoid the count going to zero or negative.  This situation can
+ * occur temporarily during module unload or CPU hot-plug but
+ * normality will be restored when the affected CPUs next exit the
+ * idle loop. */
+static atomic_t busy_cpu_count[NR_CPUS+1];
+
+/* A workqueue item to be executed to cause the CPU to exit from the
+ * idle loop. */
+DEFINE_PER_CPU(struct work_struct, efx_idle_cpu_work);
+
+#if IDLE_DEBUG
+
+DEFINE_PER_CPU(int, idle_cpu_state) = -1;
+#define idle_set_state(CPU,STATE) \
+	per_cpu(idle_cpu_state, (CPU)) = (STATE)
+
+static DEFINE_MUTEX(efx_idle_debug_mutex);
+static cpumask_t efx_idle_debug_cpumask;
+
+#else
+
+#define idle_set_state(CPU,STATE) \
+	do { } while(0)
+
+#endif
+
+static unsigned int idle_enable = 1;
+module_param(idle_enable, uint, 0444);
+MODULE_PARM_DESC(idle_enable, "sfc_tune: Idle polling (0=>disabled,"
+		 " 1=>auto, 2=>enabled)");
+
+static unsigned int idle_mode = 1;
+module_param(idle_mode, uint, 0444);
+MODULE_PARM_DESC(idle_mode, "sfc_tune: Entity to keep busy (0=>hyperthreads,"
+		 " 1=>cores, 2=>packages, 3=>NUMA nodes)");
+
+/* A mutex to protect most of the module datastructures. */
+static DEFINE_MUTEX(efx_idle_startup_mutex);
+
+/* The old pm_idle handler. */
+static void (*old_pm_idle)(void) = NULL;
+
+static void efx_pm_idle(void)
+{
+	atomic_t *busy_cpus_ptr;
+	int busy_cpus;
+	int cpu = smp_processor_id();
+
+	busy_cpus_ptr = &(busy_cpu_count[per_cpu(idle_cpu_group, cpu)]);
+
+	idle_set_state(cpu, 2);
+
+	local_irq_enable();
+	while (!need_resched()) {
+		busy_cpus = atomic_read(busy_cpus_ptr);
+
+		/* If other CPUs in this group are busy then let this
+		 * CPU go idle.  We mustn't let the number of busy
+		 * CPUs drop below 1. */
+		if ( busy_cpus > 1 &&
+		     old_pm_idle != NULL &&
+		     ( atomic_cmpxchg(busy_cpus_ptr, busy_cpus,
+				      busy_cpus-1) == busy_cpus ) ) {
+			local_irq_disable();
+			idle_set_state(cpu, 3);
+			/* This check might not be necessary, but it
+			 * seems safest to include it because there
+			 * might be a kernel version which requires
+			 * it. */
+			if (need_resched())
+				local_irq_enable();
+			else
+				old_pm_idle();
+			/* This CPU is busy again. */
+			idle_set_state(cpu, 1);
+			atomic_add(1, busy_cpus_ptr);
+			return;
+		}
+
+		cpu_relax();
+	}
+	idle_set_state(cpu, 0);
+}
+
+
+void efx_idle_work_func(struct work_struct *work)
+{
+	/* Do nothing.  Since this function is running in process
+	 * context, the idle thread isn't running on this CPU. */
+}
+
+
+#ifdef CONFIG_SMP
+static void efx_idle_smp_call(void *info)
+{
+	schedule_work(&get_cpu_var(efx_idle_cpu_work));
+	put_cpu_var(efx_idle_cpu_work);
+}
+#endif
+
+
+#ifdef CONFIG_SMP
+static void efx_idle_refresh(void)
+{
+	on_each_cpu(&efx_idle_smp_call, NULL, 1);
+}
+#else
+static void efx_idle_refresh(void)
+{
+	/* The current thread is executing on the one and only CPU so
+	 * the idle thread isn't running. */
+}
+#endif
+
+
+#if IDLE_DEBUG
+
+static void show_cpus_in_state_smp_call(void *info)
+{
+	int cpu = smp_processor_id();
+	int state = per_cpu(idle_cpu_state, cpu);
+	if (state == (long)info)
+		cpu_set(cpu, efx_idle_debug_cpumask);
+}
+
+static ssize_t show_cpus_in_state(char *buf, long state)
+{
+	ssize_t res;
+
+	mutex_lock(&efx_idle_debug_mutex);
+	cpus_clear(efx_idle_debug_cpumask);
+	on_each_cpu(&show_cpus_in_state_smp_call, (void*)state, 1);
+	res = cpumask_scnprintf(buf, PAGE_SIZE-2, efx_idle_debug_cpumask);
+	mutex_unlock(&efx_idle_debug_mutex);
+
+	buf[res++] = '\n';
+	buf[res] = 0;
+	
+	return res;
+}
+
+static ssize_t show_idle_cpu_set(struct sys_device *dev,
+				 char *buf)
+{
+	return show_cpus_in_state(buf, 3);
+}
+static SYSDEV_ATTR(idle_cpu_set, 0444, show_idle_cpu_set, NULL);
+
+
+static ssize_t show_spinning_cpu_set(struct sys_device *dev,
+				     char *buf)
+{
+	return show_cpus_in_state(buf, 2);
+}
+static SYSDEV_ATTR(spinning_cpu_set, 0444, show_spinning_cpu_set, NULL);
+
+
+static ssize_t show_idle_cpu_state(struct sys_device *dev,
+				   char *buf)
+{
+	int cpu = dev->id;
+	return sprintf(buf, "%u\n", per_cpu(idle_cpu_state, cpu));
+}
+static SYSDEV_ATTR(idle_cpu_state, 0444, show_idle_cpu_state, NULL);
+
+
+static ssize_t show_idle_cpu_group(struct sys_device *dev,
+				   char *buf)
+{
+	int cpu = dev->id;
+	return sprintf(buf, "%u\n", per_cpu(idle_cpu_group, cpu));
+}
+static SYSDEV_ATTR(idle_cpu_group, 0444, show_idle_cpu_group, NULL);
+
+
+static ssize_t show_busy_cpus(struct sys_device *dev,
+			      char *buf)
+{
+	int group = per_cpu(idle_cpu_group, dev->id);
+	return sprintf(buf, "%u\n", atomic_read(&(busy_cpu_count[group])));
+}
+static SYSDEV_ATTR(busy_cpus, 0444, show_busy_cpus, NULL);
+
+#endif
+
+
+static int efx_idle_cpu_group(int cpu)
+{
+#ifdef CONFIG_SMP
+	const cpumask_t *mask;
+	int node;
+	int other_cpu;
+	int group;
+
+	switch(idle_mode) {
+	default:
+	case 0:
+		/* Keep one hyperthread busy per hyperthread. */
+		return cpu;
+	case 1:
+#if defined(topology_thread_cpumask) && defined(EFX_HAVE_EXPORTED_CPU_SIBLING_MAP)
+		/* Keep one hyperthread busy per core. */
+		mask = topology_thread_cpumask(cpu);
+		break;
+#else
+		return cpu;
+#endif
+	case 2:
+#ifdef topology_core_cpumask
+		/* Keep one hyperthread busy per package. */
+		mask = topology_core_cpumask(cpu);
+		break;
+#else
+		return cpu;
+#endif
+	case 3:
+		/* Keep one hyperthread busy per NUMA node. */
+		node = cpu_to_node(cpu);
+		mask = cpumask_of_node(node);
+		break;
+	}
+
+	for_each_cpu(other_cpu, mask) {
+		group = per_cpu(idle_cpu_group, other_cpu);
+		if (group != NR_CPUS)
+			return group;
+	}
+#endif
+
+	return cpu;
+}
+
+
+static void efx_idle_add_cpu(int cpu)
+{
+#if IDLE_DEBUG
+	struct sys_device *sysdev = get_cpu_sysdev(cpu);
+#endif
+	int group;
+
+	/* Do nothing if this CPU has already been added. */
+	if (per_cpu(idle_cpu_group, cpu) != NR_CPUS)
+		return;
+
+	group = efx_idle_cpu_group(cpu);
+	per_cpu(idle_cpu_group, cpu) = group;
+	atomic_inc(&(busy_cpu_count[group]));
+
+#if IDLE_DEBUG
+	printk(KERN_INFO "sfc_idle: Adding CPU %d to group %d\n",
+	       cpu, group);
+
+	sysdev_create_file(sysdev, &attr_idle_cpu_set);
+	sysdev_create_file(sysdev, &attr_spinning_cpu_set);
+	sysdev_create_file(sysdev, &attr_idle_cpu_state);
+	sysdev_create_file(sysdev, &attr_idle_cpu_group);
+	sysdev_create_file(sysdev, &attr_busy_cpus);
+#endif
+}
+
+static void efx_idle_del_cpu(int cpu)
+{
+#if IDLE_DEBUG
+	struct sys_device *sysdev = get_cpu_sysdev(cpu);
+#endif
+	int group;
+
+	if (per_cpu(idle_cpu_group, cpu) == NR_CPUS)
+		return;
+
+	group = per_cpu(idle_cpu_group, cpu);
+	/* If the CPU was busy, this can cause the count to drop to
+	 * zero.  To rectify this, we need to cause one of the other
+	 * CPUs in the group to exit the idle loop.  If the CPU was
+	 * not busy then this causes the contribution for this CPU to
+	 * go to -1 which can cause the overall count to drop to zero
+	 * or go negative.  To rectify this situation we need to cause
+	 * this CPU to exit the idle loop. */
+	atomic_dec(&(busy_cpu_count[group]));
+	per_cpu(idle_cpu_group, cpu) = NR_CPUS;
+
+#if IDLE_DEBUG
+	printk(KERN_INFO "sfc_idle: Removing CPU %d from group %d\n",
+	       cpu, group);
+
+	sysdev_remove_file(sysdev, &attr_idle_cpu_set);
+	sysdev_remove_file(sysdev, &attr_spinning_cpu_set);
+	sysdev_remove_file(sysdev, &attr_idle_cpu_state);
+	sysdev_remove_file(sysdev, &attr_idle_cpu_group);
+	sysdev_remove_file(sysdev, &attr_busy_cpus);
+#endif
+}
+
+
+static int efx_idle_cpu_notify(struct notifier_block *self,
+			       unsigned long action, void *hcpu)
+{
+	int cpu = (long)hcpu;
+	
+	switch(action) {
+#ifdef CPU_ONLINE_FROZEN
+	case CPU_ONLINE_FROZEN:
+#endif
+	case CPU_ONLINE:
+		mutex_lock(&efx_idle_startup_mutex);
+		efx_idle_add_cpu(cpu);
+		mutex_unlock(&efx_idle_startup_mutex);
+		/* The CPU might have already entered the idle loop in
+		 * the wrong group.  Make sure it exits the idle loop
+		 * so that it picks up the correct group. */
+		efx_idle_refresh();
+		break;
+
+#ifdef CPU_DEAD_FROZEN
+	case CPU_DEAD_FROZEN:
+#endif
+	case CPU_DEAD:
+		mutex_lock(&efx_idle_startup_mutex);
+		efx_idle_del_cpu(cpu);
+		mutex_unlock(&efx_idle_startup_mutex);
+		/* The deleted CPU may have been the only busy CPU in
+		 * the group.  Make sure one of the other CPUs in the
+		 * group exits the idle loop. */
+		efx_idle_refresh();
+		break;
+	}
+	return NOTIFY_OK;
+}
+
+
+static struct notifier_block efx_idle_cpu_nb = {
+	.notifier_call = efx_idle_cpu_notify,
+};
+
+
+static void efx_idle_ensure_init(void)
+{
+	BUG_ON (old_pm_idle != NULL);
+
+	/* Atomically update pm_idle to &efx_pm_idle.  The old value
+	 * is stored in old_pm_idle before installing the new
+	 * handler. */
+	do {
+		old_pm_idle = pm_idle;
+	} while (cmpxchg(&pm_idle, old_pm_idle, &efx_pm_idle) !=
+		 old_pm_idle);
+}
+
+void efx_idle_fini(void)
+{
+	void (*old)(void);
+	int cpu;
+
+	unregister_cpu_notifier(&efx_idle_cpu_nb);
+
+	mutex_lock(&efx_idle_startup_mutex);
+
+	if (idle_enable >= 2) {
+		/* Atomically uninstall the handler.  If someone has
+		 * changed pm_idle in the mean-time, we're a bit
+		 * stuck. */
+		old = cmpxchg(&pm_idle, &efx_pm_idle, old_pm_idle);
+		BUG_ON(old != &efx_pm_idle);
+	}
+
+	for_each_online_cpu(cpu)
+		efx_idle_del_cpu(cpu);
+
+	mutex_unlock(&efx_idle_startup_mutex);
+	
+	/* Our handler may still be executing on other CPUs.
+	 * Schedule this thread on all CPUs to make sure all
+	 * idle threads get interrupted. */
+	efx_idle_refresh();
+
+	/* Make sure the work item has finished executing on all CPUs.
+	 * This in turn ensures that all idle threads have been
+	 * interrupted. */
+	flush_scheduled_work();
+}
+
+
+int efx_idle_init(void)
+{
+	int rc = 0;
+	int updated = 0;
+	int cpu;
+
+	for_each_possible_cpu(cpu) {
+		INIT_WORK(&per_cpu(efx_idle_cpu_work, cpu),
+			  efx_idle_work_func);
+	}
+
+	/* Start by registering the handler to ensure we don't miss
+	 * any updates. */
+	register_cpu_notifier(&efx_idle_cpu_nb);
+
+	mutex_lock(&efx_idle_startup_mutex);
+
+	for_each_online_cpu(cpu)
+		efx_idle_add_cpu(cpu);
+
+	if (idle_enable >= 2) {
+		efx_idle_ensure_init();
+		updated = 1;
+	}
+
+	mutex_unlock(&efx_idle_startup_mutex);
+
+	if (updated) {
+		/* Ensure our idle handler starts to run. */
+		efx_idle_refresh();
+	}
+
+	return rc;
+}
+
+int efx_idle_enhance(void)
+{
+	int rc = 0;
+	int updated = 0;
+
+	BUG_ON(xen_domain());
+
+	mutex_lock(&efx_idle_startup_mutex);
+	if (idle_enable == 1) {
+		/* Only ever try to start the enhanced idle loop
+		 * once. */
+		idle_enable = 2;
+		efx_idle_ensure_init();
+		updated = 1;
+	}
+	mutex_unlock(&efx_idle_startup_mutex);
+
+	if (updated) {
+		/* Ensure our idle handler starts to run. */
+		efx_idle_refresh();
+	}
+
+	return rc;
+}
+
+#elif !defined(CONFIG_XEN)
+#error "We should have pm_idle on non-Xen kernels."
+#endif
diff -r 5b3d4d3c1166 drivers/net/sfc/idle.h
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/drivers/net/sfc/idle.h	Tue Nov 09 10:06:27 2010 +0000
@@ -0,0 +1,17 @@
+/****************************************************************************
+ * Driver for Solarflare Solarstorm network controllers and boards
+ * Copyright 2007 Solarflare Communications Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 as published
+ * by the Free Software Foundation, incorporated herein by reference.
+ */
+
+#ifndef EFX_IDLE_H
+#define EFX_IDLE_H
+
+extern int efx_idle_init(void);
+extern void efx_idle_fini(void);
+extern int efx_idle_enhance(void);
+
+#endif /* EFX_IDLE_H */
diff -r 5b3d4d3c1166 drivers/net/sfc/io.h
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/drivers/net/sfc/io.h	Tue Nov 09 10:06:27 2010 +0000
@@ -0,0 +1,273 @@
+/****************************************************************************
+ * Driver for Solarflare Solarstorm network controllers and boards
+ * Copyright 2005-2006 Fen Systems Ltd.
+ * Copyright 2006-2009 Solarflare Communications Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 as published
+ * by the Free Software Foundation, incorporated herein by reference.
+ */
+
+#ifndef EFX_IO_H
+#define EFX_IO_H
+
+#if !defined(EFX_USE_KCOMPAT) || defined(EFX_USE_LINUX_IO_H)
+#include <linux/io.h>
+#else
+#include <asm/io.h>
+#endif
+#include <linux/spinlock.h>
+
+/**************************************************************************
+ *
+ * NIC register I/O
+ *
+ **************************************************************************
+ *
+ * Notes on locking strategy:
+ *
+ * Most NIC registers require 16-byte (or 8-byte, for SRAM) atomic writes
+ * which necessitates locking.
+ * Under normal operation few writes to NIC registers are made and these
+ * registers (EVQ_RPTR_REG, RX_DESC_UPD_REG and TX_DESC_UPD_REG) are special
+ * cased to allow 4-byte (hence lockless) accesses.
+ *
+ * It *is* safe to write to these 4-byte registers in the middle of an
+ * access to an 8-byte or 16-byte register.  We therefore use a
+ * spinlock to protect accesses to the larger registers, but no locks
+ * for the 4-byte registers.
+ *
+ * A write barrier is needed to ensure that DW3 is written after DW0/1/2
+ * due to the way the 16byte registers are "collected" in the BIU.
+ *
+ * We also lock when carrying out reads, to ensure consistency of the
+ * data (made possible since the BIU reads all 128 bits into a cache).
+ * Reads are very rare, so this isn't a significant performance
+ * impact.  (Most data transferred from NIC to host is DMAed directly
+ * into host memory).
+ *
+ * I/O BAR access uses locks for both reads and writes (but is only provided
+ * for testing purposes).
+ */
+
+#if BITS_PER_LONG == 64
+#define EFX_USE_QWORD_IO 1
+#endif
+
+#ifdef EFX_USE_QWORD_IO
+static inline void _efx_writeq(struct efx_nic *efx, __le64 value,
+				  unsigned int reg)
+{
+	__raw_writeq((__force u64)value, efx->membase + reg);
+}
+static inline __le64 _efx_readq(struct efx_nic *efx, unsigned int reg)
+{
+	return (__force __le64)__raw_readq(efx->membase + reg);
+}
+#endif
+
+static inline void _efx_writed(struct efx_nic *efx, __le32 value,
+				  unsigned int reg)
+{
+	__raw_writel((__force u32)value, efx->membase + reg);
+}
+static inline __le32 _efx_readd(struct efx_nic *efx, unsigned int reg)
+{
+	return (__force __le32)__raw_readl(efx->membase + reg);
+}
+
+/* Writes to a normal 16-byte Efx register, locking as appropriate. */
+static inline void efx_writeo(struct efx_nic *efx, efx_oword_t *value,
+			      unsigned int reg)
+{
+	unsigned long flags __attribute__ ((unused));
+
+	netif_vdbg(efx, hw, efx->net_dev,
+		   "writing register %x with " EFX_OWORD_FMT "\n", reg,
+		   EFX_OWORD_VAL(*value));
+
+	spin_lock_irqsave(&efx->biu_lock, flags);
+#ifdef EFX_USE_QWORD_IO
+	_efx_writeq(efx, value->u64[0], reg + 0);
+	wmb();
+	_efx_writeq(efx, value->u64[1], reg + 8);
+#else
+	_efx_writed(efx, value->u32[0], reg + 0);
+	_efx_writed(efx, value->u32[1], reg + 4);
+	_efx_writed(efx, value->u32[2], reg + 8);
+	wmb();
+	_efx_writed(efx, value->u32[3], reg + 12);
+#endif
+	mmiowb();
+	spin_unlock_irqrestore(&efx->biu_lock, flags);
+}
+
+/* Write an 8-byte NIC SRAM entry through the supplied mapping,
+ * locking as appropriate. */
+static inline void efx_sram_writeq(struct efx_nic *efx, void __iomem *membase,
+				   efx_qword_t *value, unsigned int index)
+{
+	unsigned int addr = index * sizeof(*value);
+	unsigned long flags __attribute__ ((unused));
+
+	netif_vdbg(efx, hw, efx->net_dev,
+		   "writing SRAM address %x with " EFX_QWORD_FMT "\n",
+		   addr, EFX_QWORD_VAL(*value));
+
+	spin_lock_irqsave(&efx->biu_lock, flags);
+#ifdef EFX_USE_QWORD_IO
+	__raw_writeq((__force u64)value->u64[0], membase + addr);
+#else
+	__raw_writel((__force u32)value->u32[0], membase + addr);
+	wmb();
+	__raw_writel((__force u32)value->u32[1], membase + addr + 4);
+#endif
+	mmiowb();
+	spin_unlock_irqrestore(&efx->biu_lock, flags);
+}
+
+/* Write dword to NIC register that allows partial writes
+ *
+ * Some registers (EVQ_RPTR_REG, RX_DESC_UPD_REG and
+ * TX_DESC_UPD_REG) can be written to as a single dword.  This allows
+ * for lockless writes.
+ */
+static inline void efx_writed(struct efx_nic *efx, efx_dword_t *value,
+			      unsigned int reg)
+{
+	netif_vdbg(efx, hw, efx->net_dev,
+		   "writing partial register %x with "EFX_DWORD_FMT"\n",
+		   reg, EFX_DWORD_VAL(*value));
+
+	/* No lock required */
+	_efx_writed(efx, value->u32[0], reg);
+}
+
+/* Read from a NIC register
+ *
+ * This reads an entire 16-byte register in one go, locking as
+ * appropriate.  It is essential to read the first dword first, as this
+ * prompts the NIC to load the current value into the shadow register.
+ */
+static inline void efx_reado(struct efx_nic *efx, efx_oword_t *value,
+			     unsigned int reg)
+{
+	unsigned long flags __attribute__ ((unused));
+
+	spin_lock_irqsave(&efx->biu_lock, flags);
+	value->u32[0] = _efx_readd(efx, reg + 0);
+	rmb();
+	value->u32[1] = _efx_readd(efx, reg + 4);
+	value->u32[2] = _efx_readd(efx, reg + 8);
+	value->u32[3] = _efx_readd(efx, reg + 12);
+	spin_unlock_irqrestore(&efx->biu_lock, flags);
+
+	netif_vdbg(efx, hw, efx->net_dev,
+		   "read from register %x, got " EFX_OWORD_FMT "\n", reg,
+		   EFX_OWORD_VAL(*value));
+}
+
+/* Read an 8-byte SRAM entry through supplied mapping,
+ * locking as appropriate. */
+static inline void efx_sram_readq(struct efx_nic *efx, void __iomem *membase,
+				  efx_qword_t *value, unsigned int index)
+{
+	unsigned int addr = index * sizeof(*value);
+	unsigned long flags __attribute__ ((unused));
+
+	spin_lock_irqsave(&efx->biu_lock, flags);
+#ifdef EFX_USE_QWORD_IO
+	value->u64[0] = (__force __le64)__raw_readq(membase + addr);
+#else
+	value->u32[0] = (__force __le32)__raw_readl(membase + addr);
+	rmb();
+	value->u32[1] = (__force __le32)__raw_readl(membase + addr + 4);
+#endif
+	spin_unlock_irqrestore(&efx->biu_lock, flags);
+
+	netif_vdbg(efx, hw, efx->net_dev,
+		   "read from SRAM address %x, got "EFX_QWORD_FMT"\n",
+		   addr, EFX_QWORD_VAL(*value));
+}
+
+/* Read dword from register that allows partial writes (sic) */
+static inline void efx_readd(struct efx_nic *efx, efx_dword_t *value,
+				unsigned int reg)
+{
+	value->u32[0] = _efx_readd(efx, reg);
+	netif_vdbg(efx, hw, efx->net_dev,
+		   "read from register %x, got "EFX_DWORD_FMT"\n",
+		   reg, EFX_DWORD_VAL(*value));
+}
+
+/* Write to a register forming part of a table */
+static inline void efx_writeo_table(struct efx_nic *efx, efx_oword_t *value,
+				      unsigned int reg, unsigned int index)
+{
+	efx_writeo(efx, value, reg + index * sizeof(efx_oword_t));
+}
+
+/* Read to a register forming part of a table */
+static inline void efx_reado_table(struct efx_nic *efx, efx_oword_t *value,
+				     unsigned int reg, unsigned int index)
+{
+	efx_reado(efx, value, reg + index * sizeof(efx_oword_t));
+}
+
+/* Write to a dword register forming part of a table */
+static inline void efx_writed_table(struct efx_nic *efx, efx_dword_t *value,
+				       unsigned int reg, unsigned int index)
+{
+	efx_writed(efx, value, reg + index * sizeof(efx_oword_t));
+}
+
+/* Read from a dword register forming part of a table */
+static inline void efx_readd_table(struct efx_nic *efx, efx_dword_t *value,
+				   unsigned int reg, unsigned int index)
+{
+	efx_readd(efx, value, reg + index * sizeof(efx_dword_t));
+}
+
+/* Page-mapped register block size */
+#define EFX_PAGE_BLOCK_SIZE 0x2000
+
+/* Calculate offset to page-mapped register block */
+#define EFX_PAGED_REG(page, reg) \
+	((page) * EFX_PAGE_BLOCK_SIZE + (reg))
+
+/* As for efx_writeo(), but for a page-mapped register. */
+static inline void efx_writeo_page(struct efx_nic *efx, efx_oword_t *value,
+				   unsigned int reg, unsigned int page)
+{
+	efx_writeo(efx, value, EFX_PAGED_REG(page, reg));
+}
+
+/* As for efx_writed(), but for a page-mapped register. */
+static inline void efx_writed_page(struct efx_nic *efx, efx_dword_t *value,
+				   unsigned int reg, unsigned int page)
+{
+	efx_writed(efx, value, EFX_PAGED_REG(page, reg));
+}
+
+/* Write dword to page-mapped register with an extra lock.
+ *
+ * As for efx_writed_page(), but for a register that suffers from
+ * SFC bug 3181. Take out a lock so the BIU collector cannot be
+ * confused. */
+static inline void efx_writed_page_locked(struct efx_nic *efx,
+					  efx_dword_t *value,
+					  unsigned int reg,
+					  unsigned int page)
+{
+	unsigned long flags __attribute__ ((unused));
+
+	if (page == 0) {
+		spin_lock_irqsave(&efx->biu_lock, flags);
+		efx_writed(efx, value, EFX_PAGED_REG(page, reg));
+		spin_unlock_irqrestore(&efx->biu_lock, flags);
+	} else {
+		efx_writed(efx, value, EFX_PAGED_REG(page, reg));
+	}
+}
+
+#endif /* EFX_IO_H */
diff -r 5b3d4d3c1166 drivers/net/sfc/ioctl.c
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/drivers/net/sfc/ioctl.c	Tue Nov 09 10:06:27 2010 +0000
@@ -0,0 +1,263 @@
+/****************************************************************************
+ * Driver for Solarflare network controllers
+ *           (including support for SFE4001 10GBT NIC)
+ *
+ * Copyright 2005-2006: Fen Systems Ltd.
+ * Copyright 2005-2009: Solarflare Communications Inc,
+ *                      9501 Jeronimo Road, Suite 250,
+ *                      Irvine, CA 92618, USA
+ *
+ * Initially developed by Michael Brown <mbrown@fensystems.co.uk>
+ * Maintained by Solarflare Communications <linux-net-drivers@solarflare.com>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 as published
+ * by the Free Software Foundation, incorporated herein by reference.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ ****************************************************************************
+ */
+#ifdef EFX_NOT_UPSTREAM
+#define EFX_DRIVER_NAME "sfc_control"
+#endif
+#include "net_driver.h"
+#include "efx.h"
+#include "efx_ioctl.h"
+#include "nic.h"
+#include "mcdi.h"
+#include "mcdi_pcol.h"
+
+#ifdef EFX_NOT_UPSTREAM
+
+#include <linux/module.h>
+#include <linux/skbuff.h>
+#include <linux/rtnetlink.h>
+#include <linux/fs.h>
+
+/* Major device number */
+static int major;
+module_param(major, int, 0444);
+MODULE_PARM_DESC(major, "char device major number to use");
+
+#endif /* EFX_NOT_UPSTREAM */
+
+static int efx_ioctl_do_mcdi(struct efx_nic *efx, union efx_ioctl_data *data)
+{
+	struct efx_mcdi_request *req = &data->mcdi_request;
+	size_t outlen;
+	int rc;
+
+	if (req->len > sizeof(req->payload)) {
+		netif_err(efx, drv, efx->net_dev, "inlen is too long");
+		return -EINVAL;
+	}
+
+	if (efx_nic_rev(efx) < EFX_REV_SIENA_A0) {
+		netif_err(efx, drv, efx->net_dev,
+			  "error: NIC has no MC for MCDI\n");
+		return -ENOTSUPP;
+	}
+
+	rc = efx_mcdi_rpc(efx, req->cmd, (const u8 *)req->payload,
+			  req->len, (u8 *)req->payload,
+			  sizeof(req->payload), &outlen);
+
+	/* efx_mcdi_rpc() will not schedule a reset if MC_CMD_PAYLOAD causes
+	 * a reboot. But from the user's POV, they're triggering a reboot
+	 * 'externally', and want both ports to recover. So schedule the
+	 * reset here */
+	if (req->cmd == MC_CMD_REBOOT && rc == -EIO) {
+		netif_err(efx, drv, efx->net_dev, "MC fatal error %d\n", -rc);
+		efx_schedule_reset(efx, RESET_TYPE_MC_FAILURE);
+	}
+
+	/* No distinction is made between RPC failures (driver timeouts) and
+	 * MCDI failures (timeouts, reboots etc) */
+	req->rc = -rc;
+	req->len = (__u8)outlen;
+	return 0;
+}
+
+static int
+efx_ioctl_reset_flags(struct efx_nic *efx, union efx_ioctl_data *data)
+{
+	return efx_ethtool_reset(efx->net_dev, &data->reset_flags.flags);
+}
+
+static int
+efx_ioctl_rxnfc(struct efx_nic *efx, union efx_ioctl_data *data)
+{
+	if (data->rxnfc.cmd != ETHTOOL_GRXRINGS &&
+	    data->rxnfc.cmd != ETHTOOL_GRXFH)
+		return -EOPNOTSUPP;
+	return efx_ethtool_get_rxnfc(efx->net_dev, &data->rxnfc, NULL);
+}
+
+static int
+efx_ioctl_rxfh_indir(struct efx_nic *efx, union efx_ioctl_data *data)
+{
+	BUILD_BUG_ON(ARRAY_SIZE(data->rxfh_indir.table) !=
+		     ARRAY_SIZE(efx->rx_indir_table));
+
+	switch (data->rxfh_indir.head.cmd) {
+	case ETHTOOL_GRXFHINDIR:
+		return efx_ethtool_get_rxfh_indir(efx->net_dev,
+						  &data->rxfh_indir.head);
+	case ETHTOOL_SRXFHINDIR:
+		return efx_ethtool_set_rxfh_indir(efx->net_dev,
+						  &data->rxfh_indir.head);
+	default:
+		return -EOPNOTSUPP;
+	}
+}
+
+static int
+efx_ioctl_rxntuple(struct efx_nic *efx, union efx_ioctl_data *data)
+{
+	if (data->rxntuple.cmd != ETHTOOL_SRXNTUPLE)
+		return -EOPNOTSUPP;
+	return efx_ethtool_set_rx_ntuple(
+		efx->net_dev, (struct ethtool_rx_ntuple *)&data->rxntuple);
+}
+
+/*****************************************************************************/
+
+int efx_private_ioctl(struct efx_nic *efx, u16 cmd,
+		      union efx_ioctl_data __user *user_data)
+{
+	int (*op)(struct efx_nic *, union efx_ioctl_data *);
+	union efx_ioctl_data data;
+	size_t size;
+	int rc;
+
+	if (!capable(CAP_NET_ADMIN))
+		return -EPERM;
+
+	switch (cmd) {
+	case EFX_MCDI_REQUEST:
+		size = sizeof(data.mcdi_request);
+		op = efx_ioctl_do_mcdi;
+		break;
+	case EFX_RESET_FLAGS:
+		size = sizeof(data.reset_flags);
+		op = efx_ioctl_reset_flags;
+		break;
+	case EFX_RXNFC:
+		size = sizeof(data.rxnfc);
+		op = efx_ioctl_rxnfc;
+		break;
+	case EFX_RXFHINDIR:
+		size = sizeof(data.rxfh_indir);
+		op = efx_ioctl_rxfh_indir;
+		break;
+	case EFX_RXNTUPLE:
+		size = sizeof(data.rxntuple);
+		op = efx_ioctl_rxntuple;
+		break;
+	default:
+		netif_err(efx, drv, efx->net_dev,
+			  "unknown private ioctl cmd %x\n", cmd);
+		return -EOPNOTSUPP;
+	}
+
+	if (copy_from_user(&data, user_data, size))
+		return -EFAULT;
+	rc = op(efx, &data);
+	if (rc)
+		return rc;
+	if (copy_to_user(user_data, &data, size))
+		return -EFAULT;
+	return 0;
+}
+
+#ifdef EFX_NOT_UPSTREAM
+
+static long
+control_ioctl(struct file *filp, unsigned int req, unsigned long arg)
+{
+	struct efx_nic *efx;
+	char if_name[IFNAMSIZ];
+	struct efx_ioctl __user *user_data = (struct efx_ioctl __user *)arg;
+	u16 efx_cmd;
+	int rc = 0;
+
+	if (req != SIOCEFX && req != SIOCDEVPRIVATE)
+		return -ENOTTY;
+
+	if (copy_from_user(if_name, &user_data->if_name, sizeof(if_name)) ||
+	    copy_from_user(&efx_cmd, &user_data->cmd, sizeof(efx_cmd)))
+		return -EFAULT;
+
+	/* Serialise ioctl access with efx_reset() by acquiring the rtnl_lock.
+	 * This also maintains compatability with ioctls directly hung off
+	 * the net_device */
+	rtnl_lock();
+
+	list_for_each_entry(efx, &efx_port_list, dl_node) {
+		if (strncmp(efx->net_dev->name, if_name, sizeof(if_name)) != 0)
+			continue;
+
+		rc = efx_private_ioctl(efx, efx_cmd, &user_data->u);
+		goto unlock;
+	}
+
+	/* Couldn't find the device */
+	rc = -ENOSYS;
+
+unlock:
+	rtnl_unlock();
+	return rc;
+}
+
+#ifndef HAVE_UNLOCKED_IOCTL
+static int control_legacy_ioctl(struct inode *ino, struct file *filp,
+				unsigned int req, unsigned long arg)
+{
+	return (int) control_ioctl(filp, req, arg);
+}
+#endif
+
+static struct file_operations control_fops = {
+	.owner = THIS_MODULE,
+#ifdef HAVE_UNLOCKED_IOCTL
+	.unlocked_ioctl = control_ioctl,
+#else
+	.ioctl = control_legacy_ioctl,
+#endif
+#ifdef HAVE_COMPAT_IOCTL
+	.compat_ioctl = control_ioctl,
+#endif
+};
+
+/*****************************************************************************/
+
+int efx_control_init(void)
+{
+	int rc;
+
+	if ((rc = register_chrdev(major, EFX_DRIVER_NAME, &control_fops))
+	    < 0) {
+		printk(KERN_ERR "Failed to register chrdev on %d (%d)\n", major, rc);
+		return rc;
+	}
+	if (!major)
+		major = rc;
+	printk(KERN_INFO "Registered control device on %d\n", major);
+
+	return 0;
+}
+
+void efx_control_fini(void)
+{
+	printk(KERN_INFO "Unregistering device %d from " EFX_DRIVER_NAME "\n", major);
+	unregister_chrdev(major, EFX_DRIVER_NAME);
+}
+
+#endif /* EFX_NOT_UPSTREAM */
diff -r 5b3d4d3c1166 drivers/net/sfc/kernel_compat.c
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/drivers/net/sfc/kernel_compat.c	Tue Nov 09 10:06:27 2010 +0000
@@ -0,0 +1,522 @@
+/****************************************************************************
+ * Driver for Solarflare Solarstorm network controllers and boards
+ * Copyright 2005-2006 Fen Systems Ltd.
+ * Copyright 2006-2009 Solarflare Communications Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 as published
+ * by the Free Software Foundation, incorporated herein by reference.
+ */
+
+#define EFX_IN_KCOMPAT_C 1
+
+#include "efx.h"
+#include <linux/mii.h>
+#include <linux/ethtool.h>
+#include <linux/random.h>
+#include <linux/pci.h>
+#include <linux/spinlock.h>
+#include <linux/rtnetlink.h>
+#include <linux/bootmem.h>
+#include <linux/slab.h>
+#include <asm/uaccess.h>
+
+/*
+ * Kernel backwards compatibility
+ *
+ * This file provides functionality missing from earlier kernels.
+ */
+
+#ifdef EFX_NEED_COMPOUND_PAGE_FIX
+
+void efx_compound_page_destructor(struct page *page)
+{
+	/* Fake up page state to keep __free_pages happy */
+	set_page_count(page, 1);
+	page[1].mapping = NULL;
+
+	__free_pages(page, (unsigned long)page[1].index);
+}
+
+#endif /* NEED_COMPOUND_PAGE_FIX */
+
+/**************************************************************************
+ *
+ * print_hex_dump, taken from lib/hexdump.c.
+ *
+ **************************************************************************
+ *
+ */
+#ifdef EFX_NEED_HEX_DUMP
+
+#define hex_asc(x)	"0123456789abcdef"[x]
+#define isascii(c) (((unsigned char)(c))<=0x7f)
+
+static void hex_dump_to_buffer(const void *buf, size_t len, int rowsize,
+			       int groupsize, char *linebuf, size_t linebuflen,
+			       int ascii)
+{
+        const u8 *ptr = buf;
+        u8 ch;
+        int j, lx = 0;
+        int ascii_column;
+
+        if (rowsize != 16 && rowsize != 32)
+                rowsize = 16;
+
+        if (!len)
+                goto nil;
+        if (len > rowsize)              /* limit to one line at a time */
+                len = rowsize;
+        if ((len % groupsize) != 0)     /* no mixed size output */
+                groupsize = 1;
+
+        switch (groupsize) {
+        case 8: {
+                const u64 *ptr8 = buf;
+                int ngroups = len / groupsize;
+
+                for (j = 0; j < ngroups; j++)
+                        lx += scnprintf(linebuf + lx, linebuflen - lx,
+				"%16.16llx ", (unsigned long long)*(ptr8 + j));
+                ascii_column = 17 * ngroups + 2;
+                break;
+        }
+
+        case 4: {
+                const u32 *ptr4 = buf;
+                int ngroups = len / groupsize;
+
+                for (j = 0; j < ngroups; j++)
+                        lx += scnprintf(linebuf + lx, linebuflen - lx,
+				"%8.8x ", *(ptr4 + j));
+                ascii_column = 9 * ngroups + 2;
+                break;
+        }
+
+        case 2: {
+                const u16 *ptr2 = buf;
+                int ngroups = len / groupsize;
+
+                for (j = 0; j < ngroups; j++)
+                        lx += scnprintf(linebuf + lx, linebuflen - lx,
+				"%4.4x ", *(ptr2 + j));
+                ascii_column = 5 * ngroups + 2;
+                break;
+        }
+
+        default:
+                for (j = 0; (j < rowsize) && (j < len) && (lx + 4) < linebuflen;
+                     j++) {
+                        ch = ptr[j];
+                        linebuf[lx++] = hex_asc(ch >> 4);
+                        linebuf[lx++] = hex_asc(ch & 0x0f);
+                        linebuf[lx++] = ' ';
+                }
+                ascii_column = 3 * rowsize + 2;
+                break;
+        }
+        if (!ascii)
+                goto nil;
+
+        while (lx < (linebuflen - 1) && lx < (ascii_column - 1))
+                linebuf[lx++] = ' ';
+	/* Removed is_print() check */
+        for (j = 0; (j < rowsize) && (j < len) && (lx + 2) < linebuflen; j++)
+                linebuf[lx++] = isascii(ptr[j]) ? ptr[j] : '.';
+nil:
+        linebuf[lx++] = '\0';
+}
+
+void print_hex_dump(const char *level, const char *prefix_str, int prefix_type,
+		    int rowsize, int groupsize,
+		    const void *buf, size_t len, int ascii)
+{
+        const u8 *ptr = buf;
+        int i, linelen, remaining = len;
+        char linebuf[200];
+
+        if (rowsize != 16 && rowsize != 32)
+                rowsize = 16;
+
+        for (i = 0; i < len; i += rowsize) {
+                linelen = min(remaining, rowsize);
+                remaining -= rowsize;
+                hex_dump_to_buffer(ptr + i, linelen, rowsize, groupsize,
+				   linebuf, sizeof(linebuf), ascii);
+
+                switch (prefix_type) {
+                case DUMP_PREFIX_ADDRESS:
+                        printk("%s%s%*p: %s\n", level, prefix_str,
+			       (int)(2 * sizeof(void *)), ptr + i, linebuf);
+                        break;
+                case DUMP_PREFIX_OFFSET:
+                        printk("%s%s%.8x: %s\n", level, prefix_str, i, linebuf);
+                        break;
+                default:
+                        printk("%s%s%s\n", level, prefix_str, linebuf);
+                        break;
+                }
+        }
+}
+
+#endif /* EFX_NEED_HEX_DUMP */
+
+/**************************************************************************
+ *
+ * print_mac, from net/ethernet/eth.c in v2.6.24
+ *
+ **************************************************************************
+ *
+ */
+#ifdef EFX_NEED_PRINT_MAC
+char *print_mac(char *buf, const u8 *addr)
+{
+        sprintf(buf, "%02x:%02x:%02x:%02x:%02x:%02x",
+                addr[0], addr[1], addr[2], addr[3], addr[4], addr[5]);
+        return buf;
+}
+#endif /* EFX_NEED_PRINT_MAC */
+
+#ifdef EFX_NEED_CSUM_TCPUDP_NOFOLD
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,20)
+__wsum
+csum_tcpudp_nofold (__be32 saddr, __be32 daddr, unsigned short len,
+		    unsigned short proto, __wsum sum)
+#else
+__wsum
+csum_tcpudp_nofold (unsigned long saddr, unsigned long daddr,
+		    unsigned short len, unsigned short proto, __wsum sum)
+#endif
+{
+	unsigned long result;
+
+	result = (__force u64)saddr + (__force u64)daddr +
+		(__force u64)sum + ((len + proto) << 8);
+
+	/* Fold down to 32-bits so we don't lose in the typedef-less network stack.  */
+	/* 64 to 33 */
+	result = (result & 0xffffffff) + (result >> 32);
+	/* 33 to 32 */
+	result = (result & 0xffffffff) + (result >> 32);
+	return (__force __wsum)result;
+
+}
+#endif /* EFX_NEED_CSUM_TCPUDP_NOFOLD */
+
+#ifdef EFX_NEED_RANDOM_ETHER_ADDR
+/* Generate random MAC address */
+void efx_random_ether_addr(uint8_t *addr) {
+        get_random_bytes (addr, ETH_ALEN);
+	addr [0] &= 0xfe;       /* clear multicast bit */
+	addr [0] |= 0x02;       /* set local assignment bit (IEEE802) */
+}
+#endif /* EFX_NEED_RANDOM_ETHER_ADDR */
+
+#ifdef EFX_NEED_MSECS_TO_JIFFIES
+/*
+ * When we convert to jiffies then we interpret incoming values
+ * the following way:
+ *
+ * - negative values mean 'infinite timeout' (MAX_JIFFY_OFFSET)
+ *
+ * - 'too large' values [that would result in larger than
+ *   MAX_JIFFY_OFFSET values] mean 'infinite timeout' too.
+ *
+ * - all other values are converted to jiffies by either multiplying
+ *   the input value by a factor or dividing it with a factor
+ *
+ * We must also be careful about 32-bit overflows.
+ */
+#ifndef MSEC_PER_SEC
+#define MSEC_PER_SEC	1000L
+#endif
+unsigned long msecs_to_jiffies(const unsigned int m)
+{
+	/*
+	 * Negative value, means infinite timeout:
+	 */
+	if ((int)m < 0)
+		return MAX_JIFFY_OFFSET;
+
+#if HZ <= MSEC_PER_SEC && !(MSEC_PER_SEC % HZ)
+	/*
+	 * HZ is equal to or smaller than 1000, and 1000 is a nice
+	 * round multiple of HZ, divide with the factor between them,
+	 * but round upwards:
+	 */
+	return (m + (MSEC_PER_SEC / HZ) - 1) / (MSEC_PER_SEC / HZ);
+#elif HZ > MSEC_PER_SEC && !(HZ % MSEC_PER_SEC)
+	/*
+	 * HZ is larger than 1000, and HZ is a nice round multiple of
+	 * 1000 - simply multiply with the factor between them.
+	 *
+	 * But first make sure the multiplication result cannot
+	 * overflow:
+	 */
+	if (m > jiffies_to_msecs(MAX_JIFFY_OFFSET))
+		return MAX_JIFFY_OFFSET;
+
+	return m * (HZ / MSEC_PER_SEC);
+#else
+	/*
+	 * Generic case - multiply, round and divide. But first
+	 * check that if we are doing a net multiplication, that
+	 * we wouldnt overflow:
+	 */
+	if (HZ > MSEC_PER_SEC && m > jiffies_to_msecs(MAX_JIFFY_OFFSET))
+		return MAX_JIFFY_OFFSET;
+
+	return (m * HZ + MSEC_PER_SEC - 1) / MSEC_PER_SEC;
+#endif
+}
+#endif /* EFX_NEED_MSECS_TO_JIFFIES */
+
+#ifdef EFX_NEED_MSLEEP
+/**
+ * msleep - sleep safely even with waitqueue interruptions
+ * @msecs: Time in milliseconds to sleep for
+ */
+void msleep(unsigned int msecs)
+{
+	unsigned long timeout = msecs_to_jiffies(msecs) + 1;
+
+	while (timeout)
+		timeout = schedule_timeout_uninterruptible(timeout);
+}
+#endif
+
+#ifdef EFX_USE_I2C_LEGACY
+
+#ifdef CONFIG_SFC_HWMON
+
+struct i2c_client *i2c_new_device(struct i2c_adapter *adap,
+				  struct i2c_board_info *info)
+{
+	return i2c_new_probed_device(adap, info, NULL);
+}
+
+struct i2c_client *i2c_new_probed_device(struct i2c_adapter *adap,
+					 struct i2c_board_info *info,
+					 const unsigned short *addr_list)
+{
+	int (*probe)(struct i2c_client *, const struct i2c_device_id *);
+	struct i2c_client *client;
+
+	client = kzalloc(sizeof(*client), GFP_KERNEL);
+	if (!client)
+		return NULL;
+
+	client->adapter = adap;
+	client->dev.platform_data = info->platform_data;
+	client->flags = info->flags;
+	client->addr = addr_list ? addr_list[0] : info->addr; /* FIXME */
+	strlcpy(client->name, info->type, sizeof client->name);
+
+	if (!strcmp(client->name, "sfc_lm87")) {
+		client->driver = &efx_lm87_driver;
+		probe = efx_lm87_probe;
+	} else if (!strcmp(client->name, "max6646") ||
+		   !strcmp(client->name, "max6647")) {
+		client->driver = &efx_lm90_driver;
+		probe = efx_lm90_probe;
+	} else {
+		BUG();
+		probe = NULL;
+	}
+
+	if (i2c_attach_client(client))
+		goto fail_client;
+
+	if (probe(client, NULL))
+		goto fail_attached;
+
+	return client;
+
+fail_attached:
+	i2c_detach_client(client);
+fail_client:
+	kfree(client);
+	return NULL;
+}
+
+#endif /* CONFIG_SFC_HWMON */
+
+void i2c_unregister_device(struct i2c_client *client)
+{
+	if (client->driver->detach_client) {
+		client->driver->detach_client(client);
+	} else {
+		if (!i2c_detach_client(client))
+			kfree(client);
+	}
+}
+
+#endif /* EFX_USE_I2C_LEGACY */
+
+#ifdef EFX_NEED_I2C_NEW_DUMMY
+
+struct i2c_driver efx_i2c_dummy_driver = {
+#ifdef EFX_USE_I2C_DRIVER_NAME
+	.name = "sfc_i2c_dummy"
+#else
+	.driver.name = "sfc_i2c_dummy"
+#endif
+};
+
+struct i2c_client *efx_i2c_new_dummy(struct i2c_adapter *adap, u16 address)
+{
+	struct i2c_client *client;
+
+	client = kzalloc(sizeof(*client), GFP_KERNEL);
+	if (!client)
+		return NULL;
+
+	client->adapter = adap;
+	client->addr = address;
+	strcpy(client->name, efx_i2c_dummy_driver.driver.name);
+
+	client->driver = &efx_i2c_dummy_driver;
+
+	if (i2c_attach_client(client)) {
+		kfree(client);
+		return NULL;
+	}
+
+	return client;
+}
+
+#endif /* EFX_NEED_I2C_NEW_DUMMY */
+
+#ifdef EFX_NEED_PCI_CLEAR_MASTER
+
+void pci_clear_master(struct pci_dev *dev)
+{
+	u16 old_cmd, cmd;
+
+	pci_read_config_word(dev, PCI_COMMAND, &old_cmd);
+	cmd = old_cmd & ~PCI_COMMAND_MASTER;
+	if (cmd != old_cmd) {
+		dev_dbg(&dev->dev, "disabling bus mastering\n");
+		pci_write_config_word(dev, PCI_COMMAND, cmd);
+	}
+	dev->is_busmaster = false;
+}
+
+#endif /* EFX_NEED_PCI_CLEAR_MASTER */
+
+
+#ifdef EFX_NEED_PCI_WAKE_FROM_D3
+
+#ifndef PCI_D3hot
+#define PCI_D3hot 3
+#endif
+
+int pci_wake_from_d3(struct pci_dev *dev, bool enable)
+{
+	/* We always support waking from D3hot on boards that do WoL,
+	 * so no need to check capabilities */
+	return pci_enable_wake(dev, PCI_D3hot, enable);
+}
+
+#endif /* EFX_NEED_PCI_WAKE_FROM_D3 */
+
+#if (defined(EFX_NEED_UNMASK_MSIX_VECTORS) || \
+     defined(EFX_NEED_SAVE_MSIX_MESSAGES)) && \
+	!defined(EFX_HAVE_MSIX_TABLE_RESERVED)
+
+#undef pci_save_state
+#undef pci_restore_state
+
+#include <linux/pci_regs.h>
+
+#define PCI_MSIX_TABLE         4
+#define PCI_MSIX_PBA           8
+#define  PCI_MSIX_BIR          0x7
+
+#define PCI_MSIX_ENTRY_SIZE		16
+#define  PCI_MSIX_ENTRY_LOWER_ADDR	0
+#define  PCI_MSIX_ENTRY_UPPER_ADDR	4
+#define  PCI_MSIX_ENTRY_DATA		8
+#define  PCI_MSIX_ENTRY_VECTOR_CTRL	12
+
+static void
+efx_for_each_msix_vector(struct efx_nic *efx,
+			 void (*fn)(struct efx_channel *, void __iomem *))
+{
+	struct pci_dev *pci_dev = efx->pci_dev;
+	resource_size_t membase_phys;
+	void __iomem *membase;
+	int msix, offset, bar, length, i;
+	u32 dword;
+
+	if (efx->interrupt_mode != EFX_INT_MODE_MSIX)
+		return;
+
+	/* Find the location (bar, offset) of the MSI-X table */
+	msix = pci_find_capability(pci_dev, PCI_CAP_ID_MSIX);
+	if (!msix)
+		return;
+	pci_read_config_dword(pci_dev, msix + PCI_MSIX_TABLE, &dword);
+	bar = dword & PCI_MSIX_BIR;
+	offset = dword & ~PCI_MSIX_BIR;
+
+	/* Map enough of the table for all our interrupts */
+	membase_phys = pci_resource_start(pci_dev, bar);
+	length = efx->n_channels * 0x10;
+	membase = ioremap_nocache(membase_phys + offset, length);
+	if (!membase) {
+		dev_dbg(&pci_dev->dev, "failed to remap MSI-X table\n");
+		return;
+	}
+
+	for (i = 0; i < efx->n_channels; i++)
+		fn(efx_get_channel(efx, i), membase + i * PCI_MSIX_ENTRY_SIZE);
+
+	/* Release the mapping */
+	iounmap(membase);
+}
+
+static void
+efx_save_msix_state(struct efx_channel *channel, void __iomem *entry)
+{
+#ifdef EFX_NEED_SAVE_MSIX_MESSAGES
+	channel->msix_msg.address_lo = readl(entry + PCI_MSIX_ENTRY_LOWER_ADDR);
+	channel->msix_msg.address_hi = readl(entry + PCI_MSIX_ENTRY_UPPER_ADDR);
+	channel->msix_msg.data = readl(entry + PCI_MSIX_ENTRY_DATA);
+#endif
+#ifdef EFX_NEED_UNMASK_MSIX_VECTORS
+	channel->msix_ctrl = readl(entry + PCI_MSIX_ENTRY_VECTOR_CTRL);
+#endif
+}
+
+int efx_pci_save_state(struct pci_dev *pci_dev)
+{
+	efx_for_each_msix_vector(pci_get_drvdata(pci_dev), efx_save_msix_state);
+	return pci_save_state(pci_dev);
+}
+
+static void
+efx_restore_msix_state(struct efx_channel *channel, void __iomem *entry)
+{
+#ifdef EFX_NEED_SAVE_MSIX_MESSAGES
+	writel(channel->msix_msg.address_lo, entry + PCI_MSIX_ENTRY_LOWER_ADDR);
+	writel(channel->msix_msg.address_hi, entry + PCI_MSIX_ENTRY_UPPER_ADDR);
+	writel(channel->msix_msg.data, entry + PCI_MSIX_ENTRY_DATA);
+#endif
+#ifdef EFX_NEED_UNMASK_MSIX_VECTORS
+	writel(channel->msix_ctrl, entry + PCI_MSIX_ENTRY_VECTOR_CTRL);
+#endif
+}
+
+int efx_pci_restore_state(struct pci_dev *pci_dev)
+{
+	int rc = pci_restore_state(pci_dev);
+	if (rc == 0)
+		efx_for_each_msix_vector(pci_get_drvdata(pci_dev),
+					 efx_restore_msix_state);
+	return rc;
+}
+
+#endif /* (EFX_NEED_UNMASK_MSIX_VECTORS || EFX_NEED_SAVE_MSIX_MESSAGES) &&
+	  !EFX_HAVE_MSIX_TABLE_RESERVED */
diff -r 5b3d4d3c1166 drivers/net/sfc/kernel_compat.h
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/drivers/net/sfc/kernel_compat.h	Tue Nov 09 10:06:27 2010 +0000
@@ -0,0 +1,1863 @@
+/****************************************************************************
+ * Driver for Solarflare Solarstorm network controllers and boards
+ * Copyright 2005-2006 Fen Systems Ltd.
+ * Copyright 2006-2009 Solarflare Communications Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 as published
+ * by the Free Software Foundation, incorporated herein by reference.
+ */
+
+#ifndef EFX_KERNEL_COMPAT_H
+#define EFX_KERNEL_COMPAT_H
+
+#include <linux/version.h>
+#include <linux/sched.h>
+#include <linux/errno.h>
+#include <linux/pci.h>
+#include <linux/workqueue.h>
+#include <linux/moduleparam.h>
+#include <linux/interrupt.h>
+#include <linux/skbuff.h>
+#include <linux/netdevice.h>
+#include <linux/rtnetlink.h>
+#include <linux/i2c.h>
+#include <linux/sysfs.h>
+#include <linux/stringify.h>
+#include <linux/device.h>
+#include <linux/delay.h>
+#include <linux/wait.h>
+#include <linux/cpumask.h>
+#include <linux/topology.h>
+#include <linux/ethtool.h>
+
+/**************************************************************************
+ *
+ * Autoconf compatability
+ *
+ **************************************************************************/
+
+#include "autocompat.h"
+
+#ifdef EFX_HAVE_GENERATED_AUTOCONF_H
+#include <generated/autoconf.h>
+#else
+#include <linux/autoconf.h>
+#endif
+
+/**************************************************************************
+ *
+ * Feature switches
+ *
+ **************************************************************************/
+
+#if !defined(EFX_USE_GRO) && !defined(EFX_USE_SFC_LRO)
+	#define EFX_USE_SFC_LRO yes
+#endif
+
+#ifdef CONFIG_SFC_PRIVATE_MDIO
+	#undef EFX_HAVE_LINUX_MDIO_H
+#endif
+
+#if !defined(EFX_HAVE_SRIOV) || !defined(CONFIG_PCI_IOV)
+	#undef CONFIG_SFC_SRIOV
+#endif
+
+/**************************************************************************
+ *
+ * Version/config/architecture compatability.
+ *
+ **************************************************************************
+ *
+ * The preferred kernel compatability mechanism is through the autoconf
+ * layer above. For compatability fixes that are safe to apply to any kernel
+ * version, or those that are impossible (or slow) to determine in autconf,
+ * it is acceptable to have a version check here.
+ */
+
+#if defined(__VMKLNX__) && defined (EFX_NOT_UPSTREAM)
+#include "kernel_compat_vmware.h"
+#endif
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,5)
+	#error "This kernel version is now unsupported"
+#endif
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,10)
+	#define EFX_NEED_ETHTOOL_OFFLOAD_SANITY_CHECKS yes
+#endif
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,12)
+	#define EFX_HAVE_MSIX_TABLE_RESERVED yes
+#else
+	#define EFX_USE_ETHTOOL_OP_GET_TX_CSUM yes
+#endif
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,13)
+	#define EFX_HAVE_WORKQUEUE_NAME_LIMIT yes
+#endif
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,15) || defined(CONFIG_HUGETLB_PAGE)
+	#define EFX_USE_COMPOUND_PAGES yes
+#endif
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,16) && defined(EFX_USE_COMPOUND_PAGES)
+	#define EFX_NEED_COMPOUND_PAGE_FIX
+#endif
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,17)
+	#define EFX_NEED_UNREGISTER_NETDEVICE_NOTIFIER_FIX yes
+#endif
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,19)
+	#define EFX_USE_GSO_SIZE_FOR_MSS yes
+#else
+	#define EFX_HAVE_NONCONST_ETHTOOL_OPS yes
+#endif
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,20)
+	#define EFX_USE_FASTCALL yes
+#endif
+
+/* debugfs only supports sym-links from 2.6.21 */
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,21) && defined(CONFIG_DEBUG_FS)
+	#define EFX_USE_DEBUGFS yes
+#endif
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,22)
+	#define EFX_USE_VLAN_RX_KILL_VID yes
+#endif
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,24)
+	#define EFX_NEED_BONDING_HACKS yes
+#endif
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,28)
+	#define EFX_NEED_LM87_DRIVER yes
+	#define EFX_NEED_LM90_DRIVER yes
+#endif
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,29)
+	#define EFX_USE_NET_DEVICE_LAST_RX yes
+#endif
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,31)
+	#define EFX_USE_NET_DEVICE_TRANS_START yes
+	#define EFX_USE_PRINT_MAC yes
+#endif
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,33)
+	#ifdef EFX_HAVE_LINUX_MDIO_H
+		/* mdio module has some bugs in pause frame advertising */
+		#define EFX_NEED_MDIO45_FLOW_CONTROL_HACKS yes
+	#endif
+#endif
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,37)
+	/* Register dump buffer is allocated with vmalloc not kmalloc */
+	#define EFX_HAVE_VMALLOC_REG_DUMP_BUF yes
+#endif
+
+#ifndef EFX_NEED_UNMASK_MSIX_VECTORS
+	/* Fixing that bug introduced a different one which is not yet fixed */
+	#define EFX_NEED_SAVE_MSIX_MESSAGES yes
+#endif
+
+#ifdef CONFIG_PPC64
+	/* __raw_writel and friends are broken on ppc64 */
+	#define EFX_NEED_RAW_READ_AND_WRITE_FIX yes
+#endif
+
+/**************************************************************************
+ *
+ * Definitions of missing constants, types, functions and macros
+ *
+ **************************************************************************
+ *
+ */
+
+#ifndef spin_trylock_irqsave
+	#define spin_trylock_irqsave(lock, flags)	\
+	({						\
+		local_irq_save(flags);			\
+		spin_trylock(lock) ?			\
+		1 : ({local_irq_restore(flags); 0;});	\
+	})
+#endif
+
+#ifndef raw_smp_processor_id
+	#define raw_smp_processor_id() (current_thread_info()->cpu)
+#endif
+
+#ifndef NETIF_F_GEN_CSUM
+	#define NETIF_F_GEN_CSUM (NETIF_F_NO_CSUM | NETIF_F_HW_CSUM)
+#endif
+#ifndef NETIF_F_V4_CSUM
+	#define NETIF_F_V4_CSUM (NETIF_F_GEN_CSUM | NETIF_F_IP_CSUM)
+#endif
+#ifndef NETIF_F_V6_CSUM
+	#define NETIF_F_V6_CSUM  NETIF_F_GEN_CSUM
+#endif
+#ifndef NETIF_F_ALL_CSUM
+	#define NETIF_F_ALL_CSUM (NETIF_F_V4_CSUM | NETIF_F_V6_CSUM)
+#endif
+
+#ifdef NETIF_F_RXHASH
+	#define EFX_HAVE_RXHASH_SUPPORT yes
+#else
+	/* This reduces the need for #ifdefs */
+	#define NETIF_F_RXHASH 0
+	#define ETH_FLAG_RXHASH 0
+#endif
+
+#ifdef NETIF_F_NTUPLE
+	#define EFX_HAVE_NTUPLE_SUPPORT yes
+#else
+	/* This reduces the need for #ifdefs */
+	#define NETIF_F_NTUPLE 0
+	#define ETH_FLAG_NTUPLE 0
+#endif
+
+/* Cope with small changes in PCI constants between minor kernel revisions */
+#if PCI_X_STATUS != 4
+	#undef PCI_X_STATUS
+	#define PCI_X_STATUS 4
+	#undef PCI_X_STATUS_MAX_SPLIT
+	#define PCI_X_STATUS_MAX_SPLIT 0x03800000
+#endif
+
+#ifndef __GFP_COMP
+	#define __GFP_COMP 0
+#endif
+
+#ifndef __iomem
+	#define __iomem
+#endif
+
+#ifndef NET_IP_ALIGN
+	#define NET_IP_ALIGN 2
+#endif
+
+#ifndef PCI_EXP_FLAGS
+	#define PCI_EXP_FLAGS		2	/* Capabilities register */
+	#define PCI_EXP_FLAGS_TYPE	0x00f0	/* Device/Port type */
+	#define  PCI_EXP_TYPE_ENDPOINT	0x0	/* Express Endpoint */
+	#define  PCI_EXP_TYPE_LEG_END	0x1	/* Legacy Endpoint */
+	#define  PCI_EXP_TYPE_ROOT_PORT 0x4	/* Root Port */
+#endif
+
+#ifndef PCI_EXP_DEVCAP
+	#define PCI_EXP_DEVCAP		4	/* Device capabilities */
+	#define  PCI_EXP_DEVCAP_PAYLOAD	0x07	/* Max_Payload_Size */
+	#define  PCI_EXP_DEVCAP_PWR_VAL	0x3fc0000 /* Slot Power Limit Value */
+	#define  PCI_EXP_DEVCAP_PWR_SCL	0xc000000 /* Slot Power Limit Scale */
+#endif
+
+#ifndef PCI_EXP_DEVCTL
+	#define PCI_EXP_DEVCTL		8	/* Device Control */
+	#define  PCI_EXP_DEVCTL_PAYLOAD	0x00e0	/* Max_Payload_Size */
+	#define  PCI_EXP_DEVCTL_READRQ	0x7000	/* Max_Read_Request_Size */
+#endif
+
+#ifndef PCI_EXP_LNKSTA
+	#define PCI_EXP_LNKSTA		18	/* Link Status */
+#endif
+#ifndef PCI_EXP_LNKSTA_CLS
+	#define  PCI_EXP_LNKSTA_CLS	0x000f	/* Current Link Speed */
+#endif
+#ifndef PCI_EXP_LNKSTA_NLW
+	#define  PCI_EXP_LNKSTA_NLW	0x03f0	/* Nogotiated Link Width */
+#endif
+
+#ifndef __force
+	#define __force
+#endif
+
+#if ! defined(for_each_cpu_mask) && ! defined(CONFIG_SMP)
+	#define for_each_cpu_mask(cpu, mask)            \
+		for ((cpu) = 0; (cpu) < 1; (cpu)++, (void)mask)
+#endif
+
+#ifndef IRQF_PROBE_SHARED
+	#ifdef SA_PROBEIRQ
+		#define IRQF_PROBE_SHARED  SA_PROBEIRQ
+	#else
+		#define IRQF_PROBE_SHARED  0
+	#endif
+#endif
+
+#ifndef IRQF_SHARED
+	#define IRQF_SHARED	   SA_SHIRQ
+#endif
+
+#ifndef mmiowb
+	#if defined(__i386__) || defined(__x86_64__)
+		#define mmiowb()
+	#elif defined(__ia64__)
+		#ifndef ia64_mfa
+			#define ia64_mfa() asm volatile ("mf.a" ::: "memory")
+		#endif
+		#define mmiowb ia64_mfa
+	#else
+		#error "Need definition for mmiowb()"
+	#endif
+#endif
+
+#ifndef CHECKSUM_PARTIAL
+	#define CHECKSUM_PARTIAL CHECKSUM_HW
+#endif
+
+#ifndef DMA_BIT_MASK
+	#define DMA_BIT_MASK(n) (((n) == 64) ? ~0ULL : ((1ULL<<(n))-1))
+#endif
+
+#if defined(__GNUC__) && !defined(inline)
+	#define inline inline __attribute__ ((always_inline))
+#endif
+
+#if defined(__GNUC__) && !defined(__packed)
+	#define __packed __attribute__((packed))
+#endif
+
+#ifndef DIV_ROUND_UP
+	#define DIV_ROUND_UP(n,d) (((n) + (d) - 1) / (d))
+#endif
+
+#ifndef __ATTR
+	#define __ATTR(_name,_mode,_show,_store) {			\
+		.attr = {.name = __stringify(_name), .mode = _mode },	\
+		.show   = _show,					\
+		.store  = _store,					\
+	}
+#endif
+
+#ifndef DEVICE_ATTR
+	#define DEVICE_ATTR(_name, _mode, _show, _store)		\
+		struct device_attribute dev_attr_ ## _name =		\
+			__ATTR(_name, _mode, _show, _store)
+#endif
+
+#ifndef to_i2c_adapter
+	#define to_i2c_adapter dev_to_i2c_adapter
+#endif
+
+#if defined(CONFIG_X86) && !defined(CONFIG_HAVE_EFFICIENT_UNALIGNED_ACCESS)
+	#define CONFIG_HAVE_EFFICIENT_UNALIGNED_ACCESS
+#endif
+
+#ifndef BUILD_BUG_ON_ZERO
+	#define BUILD_BUG_ON_ZERO(e) (sizeof(char[1 - 2 * !!(e)]) - 1)
+#endif
+
+#ifndef __bitwise
+	#define __bitwise
+#endif
+
+#ifdef EFX_NEED_ATOMIC_CMPXCHG
+	#define atomic_cmpxchg(v, old, new) ((int)cmpxchg(&((v)->counter), old, new))
+#endif
+
+#ifndef cpumask_of
+	/* This is an absolute nightmare. In old kernels, cpumask_of_cpu() is
+	 * a macro closure, so we can't use &cpumask_of_cpu(). This should
+	 * always be safe, and should provide some protection against
+	 * inter-file use of cpumask_of()
+	 */
+	static inline cpumask_t *cpumask_of(int cpu)
+	{
+		static cpumask_t var;
+
+		var = cpumask_of_cpu(cpu);
+		return &var;
+	}
+#endif
+
+#ifndef KBUILD_STR
+	/* KBUILD_MODNAME is not a string */
+	#define __KBUILD_STR(s) #s
+	#define KBUILD_STR(s) __KBUILD_STR(s)
+	static char efx_kbuild_modname[] __attribute__((unused)) =
+		KBUILD_STR(KBUILD_MODNAME);
+	#undef KBUILD_MODNAME
+	#define KBUILD_MODNAME efx_kbuild_modname
+#endif
+
+#ifndef VLAN_PRIO_SHIFT
+	#define VLAN_PRIO_SHIFT         13
+#endif
+
+/**************************************************************************/
+
+#ifdef EFX_NEED_IRQ_HANDLER_T
+	typedef irqreturn_t (*irq_handler_t)(int, void *, struct pt_regs *);
+#endif
+
+/* linux_mdio.h needs this */
+#ifdef EFX_NEED_BOOL
+	typedef _Bool bool;
+	enum { false, true };
+#endif
+
+#ifdef EFX_HAVE_LINUX_MDIO_H
+	#include <linux/mdio.h>
+#else
+	#include "linux_mdio.h"
+#endif
+
+#ifdef EFX_NEED_MII_CONSTANTS
+	#define BMCR_SPEED1000		0x0040
+	#define ADVERTISE_PAUSE_ASYM	0x0800
+	#define ADVERTISE_PAUSE_CAP	0x0400
+#endif
+
+#ifdef EFX_NEED_ETHTOOL_CONSTANTS
+	#define ADVERTISED_Pause	(1 << 13)
+	#define ADVERTISED_Asym_Pause	(1 << 14)
+#endif
+
+#ifndef EFX_HAVE_ETHTOOL_RESET
+	enum ethtool_reset_flags {
+		/* These flags represent components dedicated to the interface
+		 * the command is addressed to.  Shift any flag left by
+		 * ETH_RESET_SHARED_SHIFT to reset a shared component of the
+		 * same type.
+		 */
+	  	ETH_RESET_MGMT		= 1 << 0,	/* Management processor */
+		ETH_RESET_IRQ		= 1 << 1,	/* Interrupt requester */
+		ETH_RESET_DMA		= 1 << 2,	/* DMA engine */
+		ETH_RESET_FILTER	= 1 << 3,	/* Filtering/flow direction */
+		ETH_RESET_OFFLOAD	= 1 << 4,	/* Protocol offload */
+		ETH_RESET_MAC		= 1 << 5,	/* Media access controller */
+		ETH_RESET_PHY		= 1 << 6,	/* Transceiver/PHY */
+		ETH_RESET_RAM		= 1 << 7,	/* RAM shared between
+							 * multiple components */
+
+		ETH_RESET_DEDICATED	= 0x0000ffff,	/* All components dedicated to
+							 * this interface */
+		ETH_RESET_ALL		= 0xffffffff,	/* All components used by this
+							 * interface, even if shared */
+	};
+	#define ETH_RESET_SHARED_SHIFT	16
+#endif
+
+#ifdef ETHTOOL_GRXRINGS
+	#define EFX_HAVE_ETHTOOL_RXNFC yes
+#else
+	#ifndef ETHTOOL_GRXFH
+		/* Truncated definition of the structure; we don't need
+		 * the full definition. */
+		struct ethtool_rxnfc {
+			__u32				cmd;
+			__u32				flow_type;
+			__u64				data;
+		};
+		#define ETHTOOL_GRXFH		0x00000029
+	#endif
+	#define ETHTOOL_GRXRINGS	0x0000002d
+#endif
+
+#ifndef TCP_V4_FLOW
+	#define	TCP_V4_FLOW	0x01
+	#define	UDP_V4_FLOW	0x02
+	#define	SCTP_V4_FLOW	0x03
+	#define	AH_ESP_V4_FLOW	0x04
+	#define	TCP_V6_FLOW	0x05
+	#define	UDP_V6_FLOW	0x06
+	#define	SCTP_V6_FLOW	0x07
+	#define	AH_ESP_V6_FLOW	0x08
+#endif
+#ifndef AH_V4_FLOW
+	#define	AH_V4_FLOW	0x09
+	#define	ESP_V4_FLOW	0x0a
+	#define	AH_V6_FLOW	0x0b
+	#define	ESP_V6_FLOW	0x0c
+	#define	IP_USER_FLOW	0x0d
+#endif
+#ifndef IPV4_FLOW
+	#define	IPV4_FLOW	0x10
+	#define	IPV6_FLOW	0x11
+#endif
+#ifndef ETHER_FLOW
+	#define ETHER_FLOW	0x12
+#endif
+#ifndef RXH_L2DA
+	#define	RXH_L2DA	(1 << 1)
+	#define	RXH_VLAN	(1 << 2)
+	#define	RXH_L3_PROTO	(1 << 3)
+	#define	RXH_IP_SRC	(1 << 4)
+	#define	RXH_IP_DST	(1 << 5)
+	#define	RXH_L4_B_0_1	(1 << 6)
+	#define	RXH_L4_B_2_3	(1 << 7)
+	#define	RXH_DISCARD	(1 << 31)
+#endif
+
+#ifndef ETHTOOL_GRXCLSRULE
+	struct ethtool_tcpip4_spec {
+		__be32	ip4src;
+		__be32	ip4dst;
+		__be16	psrc;
+		__be16	pdst;
+		__u8    tos;
+	};
+	#define ETHTOOL_GRXCLSRULE	0x0000002f
+#endif
+#ifndef EFX_HAVE_NTUPLE_SUPPORT
+	struct ethtool_rx_ntuple_flow_spec {
+		__u32		 flow_type;
+		union {
+			struct ethtool_tcpip4_spec		tcp_ip4_spec;
+			struct ethtool_tcpip4_spec		udp_ip4_spec;
+			struct ethtool_tcpip4_spec		sctp_ip4_spec;
+			struct ethhdr				ether_spec;
+			__u8					hdata[72];
+		} h_u, m_u;
+		__u16	        vlan_tag;
+		__u16	        vlan_tag_mask;
+		__u64		data;
+		__u64		data_mask;
+		__s32		action;
+	#define ETHTOOL_RXNTUPLE_ACTION_DROP	(-1)
+	};
+	struct ethtool_rx_ntuple {
+		__u32					cmd;
+		struct ethtool_rx_ntuple_flow_spec	fs;
+	};
+	#define ETHTOOL_SRXNTUPLE	0x00000035
+	#define ETHTOOL_GRXNTUPLE	0x00000036
+#endif
+#ifndef ETHTOOL_RXNTUPLE_ACTION_CLEAR
+	#define ETHTOOL_RXNTUPLE_ACTION_CLEAR	(-2)
+#endif
+
+#ifdef ETHTOOL_GRXFHINDIR
+	#define EFX_HAVE_ETHTOOL_RXFH_INDIR yes
+#else
+	struct ethtool_rxfh_indir {
+		__u32	cmd;
+		/* On entry, this is the array size of the user buffer.  On
+		 * return from ETHTOOL_GRXFHINDIR, this is the array size of
+		 * the hardware indirection table. */
+		__u32	size;
+		__u32	ring_index[0];	/* ring/queue index for each hash value */
+	};
+	#define ETHTOOL_GRXFHINDIR	0x00000038
+	#define ETHTOOL_SRXFHINDIR	0x00000039
+#endif
+
+#ifndef FLOW_CTRL_TX
+	#define FLOW_CTRL_TX		0x01
+	#define FLOW_CTRL_RX		0x02
+#endif
+
+#ifdef EFX_NEED_MII_RESOLVE_FLOWCTRL_FDX
+	/**
+	 * mii_resolve_flowctrl_fdx
+	 * @lcladv: value of MII ADVERTISE register
+	 * @rmtadv: value of MII LPA register
+	 *
+	 * Resolve full duplex flow control as per IEEE 802.3-2005 table 28B-3
+	 */
+	static inline u8 mii_resolve_flowctrl_fdx(u16 lcladv, u16 rmtadv)
+	{
+		u8 cap = 0;
+
+		if (lcladv & rmtadv & ADVERTISE_PAUSE_CAP) {
+			cap = FLOW_CTRL_TX | FLOW_CTRL_RX;
+		} else if (lcladv & rmtadv & ADVERTISE_PAUSE_ASYM) {
+			if (lcladv & ADVERTISE_PAUSE_CAP)
+				cap = FLOW_CTRL_RX;
+			else if (rmtadv & ADVERTISE_PAUSE_CAP)
+				cap = FLOW_CTRL_TX;
+		}
+
+		return cap;
+	}
+#endif
+
+#ifdef EFX_NEED_MII_ADVERTISE_FLOWCTRL
+	/**
+	 * mii_advertise_flowctrl - get flow control advertisement flags
+	 * @cap: Flow control capabilities (FLOW_CTRL_RX, FLOW_CTRL_TX or both)
+	 */
+	static inline u16 mii_advertise_flowctrl(int cap)
+	{
+		u16 adv = 0;
+
+		if (cap & FLOW_CTRL_RX)
+			adv = ADVERTISE_PAUSE_CAP | ADVERTISE_PAUSE_ASYM;
+		if (cap & FLOW_CTRL_TX)
+			adv ^= ADVERTISE_PAUSE_ASYM;
+
+		return adv;
+	}
+#endif
+
+#ifndef PORT_OTHER
+	#define PORT_OTHER		0xff
+#endif
+
+#ifndef SUPPORTED_Pause
+	#define SUPPORTED_Pause			(1 << 13)
+	#define SUPPORTED_Asym_Pause		(1 << 14)
+#endif
+
+#ifndef SUPPORTED_Backplane
+	#define SUPPORTED_Backplane		(1 << 16)
+	#define SUPPORTED_1000baseKX_Full	(1 << 17)
+	#define SUPPORTED_10000baseKX4_Full	(1 << 18)
+	#define SUPPORTED_10000baseKR_Full	(1 << 19)
+	#define SUPPORTED_10000baseR_FEC	(1 << 20)
+#endif
+
+#ifdef EFX_NEED_SKB_HEADER_MACROS
+	#define skb_mac_header(skb)	((skb)->mac.raw)
+	#define skb_network_header(skb) ((skb)->nh.raw)
+	#define skb_tail_pointer(skb)   ((skb)->tail)
+	#define skb_set_mac_header(skb, offset)			\
+		((skb)->mac.raw = (skb)->data + (offset))
+#endif
+
+#ifndef EFX_HAVE_SKB_RECORD_RX_QUEUE
+	#define skb_record_rx_queue(_skb, _channel)
+#endif
+
+#ifdef EFX_NEED_ETH_HDR
+	#define eth_hdr(skb)		((struct ethhdr *)skb_mac_header(skb))
+#endif
+
+#ifdef EFX_NEED_VLAN_ETH_HDR
+	#define vlan_eth_hdr(skb)	((struct vlan_ethhdr *)skb_mac_header(skb))
+#endif
+
+#ifdef EFX_NEED_TCP_HDR
+	#define tcp_hdr(skb)		((skb)->h.th)
+#endif
+
+#ifdef EFX_NEED_IP_HDR
+	#define ip_hdr(skb)		((skb)->nh.iph)
+#endif
+
+#ifdef EFX_NEED_IPV6_HDR
+	#define ipv6_hdr(skb)		((skb)->nh.ipv6h)
+#endif
+
+#ifdef EFX_NEED_RAW_READ_AND_WRITE_FIX
+	#include <asm/io.h>
+	static inline void
+	efx_raw_writeb(u8 value, volatile void __iomem *addr)
+	{
+		writeb(value, addr);
+	}
+	static inline void
+	efx_raw_writew(u16 value, volatile void __iomem *addr)
+	{
+		writew(le16_to_cpu(value), addr);
+	}
+	static inline void
+	efx_raw_writel(u32 value, volatile void __iomem *addr)
+	{
+		writel(le32_to_cpu(value), addr);
+	}
+	static inline void
+	efx_raw_writeq(u64 value, volatile void __iomem *addr)
+	{
+		writeq(le64_to_cpu(value), addr);
+	}
+	static inline u8
+	efx_raw_readb(const volatile void __iomem *addr)
+	{
+		return readb(addr);
+	}
+	static inline u16
+	efx_raw_readw(const volatile void __iomem *addr)
+	{
+		return cpu_to_le16(readw(addr));
+	}
+	static inline u32
+	efx_raw_readl(const volatile void __iomem *addr)
+	{
+		return cpu_to_le32(readl(addr));
+	}
+	static inline u64
+	efx_raw_readq(const volatile void __iomem *addr)
+	{
+		return cpu_to_le64(readq(addr));
+	}
+
+	#undef __raw_writeb
+	#undef __raw_writew
+	#undef __raw_writel
+	#undef __raw_writeq
+	#undef __raw_readb
+	#undef __raw_readw
+	#undef __raw_readl
+	#undef __raw_readq
+	#define __raw_writeb efx_raw_writeb
+	#define __raw_writew efx_raw_writew
+	#define __raw_writel efx_raw_writel
+	#define __raw_writeq efx_raw_writeq
+	#define __raw_readb efx_raw_readb
+	#define __raw_readw efx_raw_readw
+	#define __raw_readl efx_raw_readl
+	#define __raw_readq efx_raw_readq
+#endif
+
+#ifdef EFX_NEED_SCHEDULE_TIMEOUT_INTERRUPTIBLE
+	static inline signed long
+	schedule_timeout_interruptible(signed long timeout)
+	{
+		set_current_state(TASK_INTERRUPTIBLE);
+		return schedule_timeout(timeout);
+	}
+#endif
+
+#ifdef EFX_NEED_SCHEDULE_TIMEOUT_UNINTERRUPTIBLE
+	static inline signed long
+	schedule_timeout_uninterruptible(signed long timeout)
+	{
+		set_current_state(TASK_UNINTERRUPTIBLE);
+		return schedule_timeout(timeout);
+	}
+#endif
+
+#ifdef EFX_NEED_KZALLOC
+	static inline void *kzalloc(size_t size, int flags)
+	{
+		void *buf = kmalloc(size, flags);
+		if (buf)
+			memset(buf, 0,size);
+		return buf;
+	}
+#endif
+
+#ifdef EFX_NEED_KCALLOC
+	static inline void *kcalloc(size_t n, size_t size, int flags)
+	{
+		if (size != 0 && n > ULONG_MAX / size)
+			return NULL;
+		return kzalloc(n * size, flags);
+	}
+#endif
+
+#ifdef EFX_NEED_SETUP_TIMER
+	static inline void setup_timer(struct timer_list * timer,
+				       void (*function)(unsigned long),
+				       unsigned long data)
+	{
+		timer->function = function;
+		timer->data = data;
+		init_timer(timer);
+	}
+#endif
+
+#ifdef EFX_NEED_MUTEX
+	#define EFX_DEFINE_MUTEX(x) DECLARE_MUTEX(x)
+	#undef DEFINE_MUTEX
+	#define DEFINE_MUTEX EFX_DEFINE_MUTEX
+
+	#define efx_mutex semaphore
+	#undef mutex
+	#define mutex efx_mutex
+
+	#define efx_mutex_init(x) init_MUTEX(x)
+	#undef mutex_init
+	#define mutex_init efx_mutex_init
+
+	#define efx_mutex_destroy(x) do { } while(0)
+	#undef mutex_destroy
+	#define mutex_destroy efx_mutex_destroy
+
+	#define efx_mutex_lock(x) down(x)
+	#undef mutex_lock
+	#define mutex_lock efx_mutex_lock
+
+	#define efx_mutex_lock_interruptible(x) down_interruptible(x)
+	#undef mutex_lock_interruptible
+	#define mutex_lock_interruptible efx_mutex_lock_interruptible
+
+	#define efx_mutex_unlock(x) up(x)
+	#undef mutex_unlock
+	#define mutex_unlock efx_mutex_unlock
+
+	#define efx_mutex_trylock(x) (!down_trylock(x))
+	#undef mutex_trylock
+	#define mutex_trylock efx_mutex_trylock
+
+	static inline int efx_mutex_is_locked(struct efx_mutex *m)
+	{
+		/* NB. This is quite inefficient, but it's the best we
+		 * can do with the semaphore API. */
+		if ( down_trylock(m) )
+			return 1;
+		/* Undo the effect of down_trylock. */
+		up(m);
+		return 0;
+	}
+	#undef mutex_is_locked
+	#define mutex_is_locked efx_mutex_is_locked
+#else
+	#include <linux/mutex.h>
+#endif
+
+#ifndef NETIF_F_GSO
+	#define efx_gso_size tso_size
+	#undef gso_size
+	#define gso_size efx_gso_size
+	#define efx_gso_segs tso_segs
+	#undef gso_segs
+	#define gso_segs efx_gso_segs
+#endif
+
+#ifdef EFX_NEED_NETDEV_ALLOC_SKB
+	#ifndef NET_SKB_PAD
+		#define NET_SKB_PAD 16
+	#endif
+
+	static inline
+	struct sk_buff *netdev_alloc_skb(struct net_device *dev,
+					 unsigned int length)
+	{
+		struct sk_buff *skb = alloc_skb(length + NET_SKB_PAD,
+						GFP_ATOMIC | __GFP_COLD);
+		if (likely(skb)) {
+			skb_reserve(skb, NET_SKB_PAD);
+			skb->dev = dev;
+		}
+		return skb;
+	}
+#endif
+
+#ifdef EFX_NEED_NETDEV_TX_T
+	typedef int netdev_tx_t;
+	#ifndef NETDEV_TX_OK
+		#define NETDEV_TX_OK 0
+	#endif
+	#ifndef NETDEV_TX_BUSY
+		#define NETDEV_TX_BUSY 1
+	#endif
+#endif
+
+#ifndef netdev_for_each_mc_addr
+	#define netdev_for_each_mc_addr(mclist, dev) \
+		for (mclist = dev->mc_list; mclist; mclist = mclist->next)
+#endif
+
+#ifndef EFX_HAVE_ALLOC_ETHERDEV_MQ
+	#define alloc_etherdev_mq(sizeof_priv, queue_count) 		\
+		({							\
+			BUILD_BUG_ON((queue_count) != 1);		\
+			alloc_etherdev(sizeof_priv);			\
+		})
+#endif
+
+#ifndef EFX_USE_TX_MQ
+	#define netdev_get_tx_queue(dev, index) (dev)
+	#define netif_tx_stop_queue netif_stop_queue
+	#define netif_tx_wake_queue netif_wake_queue
+	#define skb_get_queue_mapping(skb) 0
+#endif
+
+#ifdef EFX_NEED_NETIF_SET_REAL_NUM_TX_QUEUES
+	static inline void
+	netif_set_real_num_tx_queues(struct net_device *dev, unsigned int txq)
+	{
+#ifdef EFX_USE_TX_MQ
+		dev->real_num_tx_queues = txq;
+#endif
+	}
+#endif
+
+#ifdef EFX_NEED_NETIF_SET_REAL_NUM_RX_QUEUES
+	static inline void
+	netif_set_real_num_rx_queues(struct net_device *dev, unsigned int rxq)
+	{
+#ifdef CONFIG_RPS
+		dev->num_rx_queues = rxq;
+#endif
+	}
+#endif
+
+#ifdef EFX_HAVE_NONCONST_ETHTOOL_OPS
+	#undef SET_ETHTOOL_OPS
+	#define SET_ETHTOOL_OPS(netdev, ops)				\
+		((netdev)->ethtool_ops = (struct ethtool_ops *)(ops))
+#endif
+
+#ifdef EFX_NEED_RTNL_TRYLOCK
+	static inline int rtnl_trylock(void) {
+		return !rtnl_shlock_nowait();
+	}
+#endif
+
+#ifdef EFX_NEED_NETIF_TX_LOCK
+	static inline void netif_tx_lock(struct net_device *dev)
+	{
+		spin_lock(&dev->xmit_lock);
+		dev->xmit_lock_owner = smp_processor_id();
+	}
+	static inline void netif_tx_lock_bh(struct net_device *dev)
+	{
+		spin_lock_bh(&dev->xmit_lock);
+		dev->xmit_lock_owner = smp_processor_id();
+	}
+	static inline void netif_tx_unlock_bh(struct net_device *dev)
+	{
+		dev->xmit_lock_owner = -1;
+		spin_unlock_bh(&dev->xmit_lock);
+	}
+	static inline void netif_tx_unlock(struct net_device *dev)
+	{
+		dev->xmit_lock_owner = -1;
+		spin_unlock(&dev->xmit_lock);
+	}
+#endif
+
+#ifdef EFX_NEED_NETIF_ADDR_LOCK
+	static inline void netif_addr_lock(struct net_device *dev)
+	{
+		netif_tx_lock(dev);
+	}
+	static inline void netif_addr_lock_bh(struct net_device *dev)
+	{
+		netif_tx_lock_bh(dev);
+	}
+	static inline void netif_addr_unlock_bh(struct net_device *dev)
+	{
+		netif_tx_unlock_bh(dev);
+	}
+	static inline void netif_addr_unlock(struct net_device *dev)
+	{
+		netif_tx_unlock(dev);
+	}
+#endif
+
+#ifdef EFX_NEED_DEV_GET_STATS
+	static inline const struct net_device_stats *
+	dev_get_stats(struct net_device *dev)
+	{
+		return dev->get_stats(dev);
+	}
+#endif
+
+#ifdef EFX_HAVE_OLD_IP_FAST_CSUM
+	#include <net/checksum.h>
+	#define ip_fast_csum(iph, ihl) ip_fast_csum((unsigned char *)iph, ihl)
+#endif
+
+#ifdef EFX_HAVE_OLD_CSUM
+	typedef u16 __sum16;
+	typedef u32 __wsum;
+	#define csum_unfold(x) ((__force __wsum) x)
+#endif
+
+#ifdef EFX_NEED_HEX_DUMP
+	enum {
+		DUMP_PREFIX_NONE,
+		DUMP_PREFIX_ADDRESS,
+		DUMP_PREFIX_OFFSET
+	};
+#endif
+
+#if defined(EFX_NEED_PRINT_MAC) && !defined(DECLARE_MAC_BUF)
+	#define DECLARE_MAC_BUF(var) char var[18] __attribute__((unused))
+#endif
+
+#ifdef EFX_NEED_GFP_T
+	typedef unsigned int gfp_t;
+#endif
+
+#ifdef EFX_NEED_SAFE_LISTS
+	#define list_for_each_entry_safe_reverse(pos, n, head, member)	     \
+		for (pos = list_entry((head)->prev, typeof(*pos), member),   \
+		     n = list_entry(pos->member.prev, typeof(*pos), member); \
+		     &pos->member != (head);				     \
+		     pos = n,						     \
+		     n = list_entry(n->member.prev, typeof(*n), member))
+#endif
+
+#ifdef EFX_NEED_DEV_NOTICE
+	#define dev_notice dev_warn
+#endif
+
+#ifdef EFX_NEED_IF_MII
+	#include <linux/mii.h>
+	static inline struct mii_ioctl_data *efx_if_mii ( struct ifreq *rq ) {
+		return ( struct mii_ioctl_data * ) &rq->ifr_ifru;
+	}
+	#undef if_mii
+	#define if_mii efx_if_mii
+#endif
+
+#ifdef EFX_NEED_MTD_ERASE_CALLBACK
+	#include <linux/mtd/mtd.h>
+	static inline void efx_mtd_erase_callback(struct erase_info *instr) {
+		if ( instr->callback )
+			instr->callback ( instr );
+	}
+	#undef mtd_erase_callback
+	#define mtd_erase_callback efx_mtd_erase_callback
+#endif
+
+#ifdef EFX_NEED_DUMMY_PCI_DISABLE_MSI
+	#include <linux/pci.h>
+	static inline void dummy_pci_disable_msi ( struct pci_dev *dev ) {
+		/* Do nothing */
+	}
+	#undef pci_disable_msi
+	#define pci_disable_msi dummy_pci_disable_msi
+#endif
+
+#ifdef EFX_NEED_DUMMY_MSIX
+	struct msix_entry {
+		u16 	vector;	/* kernel uses to write allocated vector */
+		u16	entry;	/* driver uses to specify entry, OS writes */
+	};
+	static inline int pci_enable_msix(struct pci_dev* dev,
+					  struct msix_entry *entries, int nvec)
+		{return -1;}
+	static inline void pci_disable_msix(struct pci_dev *dev) { /* Do nothing */}
+#endif
+
+#ifdef EFX_NEED_BYTEORDER_TYPES
+	typedef __u16 __be16;
+	typedef __u32 __be32;
+	typedef __u64 __be64;
+	typedef __u16 __le16;
+	typedef __u32 __le32;
+	typedef __u64 __le64;
+#endif
+
+#ifdef EFX_NEED_RESOURCE_SIZE_T
+	typedef unsigned long resource_size_t;
+#endif
+
+#ifdef EFX_USE_I2C_LEGACY
+	#ifndef I2C_BOARD_INFO
+		struct i2c_board_info {
+			char type[I2C_NAME_SIZE];
+			unsigned short flags;
+			unsigned short addr;
+			void *platform_data;
+			int irq;
+		};
+		#define I2C_BOARD_INFO(dev_type, dev_addr) \
+			.type = (dev_type), .addr = (dev_addr)
+	#endif
+	struct i2c_client *
+	i2c_new_device(struct i2c_adapter *adap, struct i2c_board_info *info);
+	struct i2c_client *
+	i2c_new_probed_device(struct i2c_adapter *adap,
+			      struct i2c_board_info *info,
+			      const unsigned short *addr_list);
+	void i2c_unregister_device(struct i2c_client *);
+	struct i2c_device_id;
+#endif
+
+#ifdef EFX_NEED_I2C_NEW_DUMMY
+	extern struct i2c_driver efx_i2c_dummy_driver;
+	struct i2c_client *
+	efx_i2c_new_dummy(struct i2c_adapter *adap, u16 address);
+	#undef i2c_new_dummy
+	#define i2c_new_dummy efx_i2c_new_dummy
+#endif
+
+#ifdef EFX_HAVE_OLD_I2C_NEW_DUMMY
+	static inline struct i2c_client *
+	efx_i2c_new_dummy(struct i2c_adapter *adap, u16 address)
+	{
+		return i2c_new_dummy(adap, address, "dummy");
+	}
+	#undef i2c_new_dummy
+	#define i2c_new_dummy efx_i2c_new_dummy
+#endif
+
+#ifdef EFX_NEED_I2C_LOCK_ADAPTER
+	#ifdef EFX_USE_I2C_BUS_SEMAPHORE
+		static inline void i2c_lock_adapter(struct i2c_adapter *adap)
+		{
+			down(&adap->bus_lock);
+		}
+		static inline void i2c_unlock_adapter(struct i2c_adapter *adap)
+		{
+			up(&adap->bus_lock);
+		}
+	#else
+		static inline void i2c_lock_adapter(struct i2c_adapter *adap)
+		{
+			mutex_lock(&adap->bus_lock);
+		}
+		static inline void i2c_unlock_adapter(struct i2c_adapter *adap)
+		{
+			mutex_unlock(&adap->bus_lock);
+		}
+	#endif
+#endif
+
+#ifdef EFX_HAVE_OLD_PCI_DMA_MAPPING_ERROR
+	static inline int
+	efx_pci_dma_mapping_error(struct pci_dev *dev, dma_addr_t dma_addr)
+	{
+        	return pci_dma_mapping_error(dma_addr);
+	}
+	#undef pci_dma_mapping_error
+	#define pci_dma_mapping_error efx_pci_dma_mapping_error
+	static inline int
+	efx_dma_mapping_error(struct device *dev, dma_addr_t dma_addr)
+	{
+        	return dma_mapping_error(dma_addr);
+	}
+	#undef dma_mapping_error
+	#define dma_mapping_error efx_dma_mapping_error
+#endif
+
+#ifdef EFX_NEED_FOR_EACH_PCI_DEV
+	#define for_each_pci_dev(d)				\
+		while ((d = pci_get_device(PCI_ANY_ID,		\
+			PCI_ANY_ID, d)) != NULL)
+#endif
+
+#ifndef DEFINE_PCI_DEVICE_TABLE
+	#define DEFINE_PCI_DEVICE_TABLE(_table) \
+		const struct pci_device_id _table[] __devinitdata
+#endif
+
+#ifdef EFX_NEED_LM87_DRIVER
+#ifdef EFX_HAVE_OLD_I2C_DRIVER_PROBE
+int efx_lm87_probe(struct i2c_client *client);
+#else
+int efx_lm87_probe(struct i2c_client *client, const struct i2c_device_id *);
+#endif
+extern struct i2c_driver efx_lm87_driver;
+#endif
+
+#ifdef EFX_NEED_LM90_DRIVER
+#ifdef EFX_HAVE_OLD_I2C_DRIVER_PROBE
+int efx_lm90_probe(struct i2c_client *client);
+#else
+int efx_lm90_probe(struct i2c_client *client, const struct i2c_device_id *);
+#endif
+extern struct i2c_driver efx_lm90_driver;
+#endif
+
+#ifdef EFX_NEED_WAIT_EVENT_TIMEOUT
+#define __wait_event_timeout(wq, condition, ret)                        \
+do {                                                                    \
+        DEFINE_WAIT(__wait);                                            \
+                                                                        \
+        for (;;) {                                                      \
+                prepare_to_wait(&wq, &__wait, TASK_UNINTERRUPTIBLE);    \
+                if (condition)                                          \
+                        break;                                          \
+                ret = schedule_timeout(ret);                            \
+                if (!ret)                                               \
+                        break;                                          \
+        }                                                               \
+        finish_wait(&wq, &__wait);                                      \
+} while (0)
+
+/**
+ * wait_event_timeout - sleep until a condition gets true or a timeout elapses
+ * @wq: the waitqueue to wait on
+ * @condition: a C expression for the event to wait for
+ * @timeout: timeout, in jiffies
+ *
+ * The process is put to sleep (TASK_UNINTERRUPTIBLE) until the
+ * @condition evaluates to true. The @condition is checked each time
+ * the waitqueue @wq is woken up.
+ *
+ * wake_up() has to be called after changing any variable that could
+ * change the result of the wait condition.
+ *
+ * The function returns 0 if the @timeout elapsed, and the remaining
+ * jiffies if the condition evaluated to true before the timeout elapsed.
+ */
+#define wait_event_timeout(wq, condition, timeout)                      \
+({                                                                      \
+        long __ret = timeout;                                           \
+        if (!(condition))                                               \
+                __wait_event_timeout(wq, condition, __ret);             \
+        __ret;                                                          \
+})
+#endif
+
+/*
+ * Recent mainline kernels can be configured so that the resulting
+ * image will run both on 'bare metal' and in a Xen domU.
+ * xen_domain() or xen_start_info tells us which is the case at
+ * run-time.  If neither is defined, assume that CONFIG_XEN tells us
+ * at compile-time.
+ */
+#if defined(EFX_HAVE_XEN_XEN_H)
+	#include <xen/xen.h>
+#elif defined(CONFIG_XEN) && defined(EFX_HAVE_XEN_START_INFO)
+	/* We should be able to include <asm/xen/hypervisor.h> but that
+	 * is broken (#includes other headers that are not installed) in
+	 * Fedora 10. */
+	extern struct start_info *xen_start_info;
+	#define xen_domain() (xen_start_info ? 1 : 0)
+#endif
+#ifndef xen_domain
+	#ifdef CONFIG_XEN
+		#define xen_domain() 1
+	#else
+		#define xen_domain() 0
+	#endif
+#endif
+
+#ifndef IS_ALIGNED
+	#define IS_ALIGNED(x, a) (((x) & ((typeof(x))(a) - 1)) == 0)
+#endif
+
+#ifndef netif_printk
+
+	/* A counterpart to SET_NETDEV_DEV */
+	#ifdef EFX_USE_NETDEV_DEV
+		#define EFX_GET_NETDEV_DEV(netdev) ((netdev)->dev.parent)
+	#else
+		#define EFX_GET_NETDEV_DEV(netdev) ((netdev)->class_dev.dev)
+	#endif
+
+	static inline const char *netdev_name(const struct net_device *dev)
+	{
+		if (dev->reg_state != NETREG_REGISTERED)
+			return "(unregistered net_device)";
+		return dev->name;
+	}
+
+	#define netdev_printk(level, netdev, format, args...)		\
+		dev_printk(level, EFX_GET_NETDEV_DEV(netdev),		\
+			   "%s: " format,				\
+			   netdev_name(netdev), ##args)
+
+	#define netif_printk(priv, type, level, dev, fmt, args...)	\
+	do {					  			\
+		if (netif_msg_##type(priv))				\
+			netdev_printk(level, (dev), fmt, ##args);	\
+	} while (0)
+	
+	#define netif_emerg(priv, type, dev, fmt, args...)		\
+		netif_printk(priv, type, KERN_EMERG, dev, fmt, ##args)
+	#define netif_alert(priv, type, dev, fmt, args...)		\
+		netif_printk(priv, type, KERN_ALERT, dev, fmt, ##args)
+	#define netif_crit(priv, type, dev, fmt, args...)		\
+		netif_printk(priv, type, KERN_CRIT, dev, fmt, ##args)
+	#define netif_err(priv, type, dev, fmt, args...)		\
+		netif_printk(priv, type, KERN_ERR, dev, fmt, ##args)
+	#define netif_warn(priv, type, dev, fmt, args...)		\
+		netif_printk(priv, type, KERN_WARNING, dev, fmt, ##args)
+	#define netif_notice(priv, type, dev, fmt, args...)		\
+		netif_printk(priv, type, KERN_NOTICE, dev, fmt, ##args)
+	#define netif_info(priv, type, dev, fmt, args...)		\
+		netif_printk(priv, type, KERN_INFO, (dev), fmt, ##args)
+	
+	#if defined(DEBUG)
+	#define netif_dbg(priv, type, dev, format, args...)		\
+		netif_printk(priv, type, KERN_DEBUG, dev, format, ##args)
+	#elif defined(CONFIG_DYNAMIC_DEBUG)
+	#define netif_dbg(priv, type, netdev, format, args...)		\
+	do {								\
+		if (netif_msg_##type(priv))				\
+			dynamic_dev_dbg((netdev)->dev.parent,		\
+					"%s: " format,			\
+					netdev_name(netdev), ##args);	\
+	} while (0)
+	#else
+	#define netif_dbg(priv, type, dev, format, args...)		\
+	({								\
+		if (0)							\
+			netif_printk(priv, type, KERN_DEBUG, dev,	\
+				     format, ##args);			\
+		0;							\
+	})
+	#endif
+
+#endif
+
+/* netif_vdbg may be defined wrongly */
+#undef netif_vdbg
+#if defined(VERBOSE_DEBUG)
+#define netif_vdbg	netif_dbg
+#else
+#define netif_vdbg(priv, type, dev, format, args...)		\
+({								\
+	if (0)							\
+		netif_printk(priv, type, KERN_DEBUG, dev,	\
+			     format, ##args);			\
+	0;							\
+})
+#endif
+
+#ifndef pr_err
+	#define pr_err(fmt, arg...) \
+		printk(KERN_ERR fmt, ##arg)
+#endif
+
+#ifndef __always_unused
+	#define __always_unused __attribute__((unused))
+#endif
+
+#ifdef EFX_NEED_IS_ZERO_ETHER_ADDR
+	static inline int is_zero_ether_addr(const u8 *addr)
+	{
+		return !(addr[0] | addr[1] | addr[2] | addr[3] | addr[4] | addr[5]);
+	}
+#endif
+
+#ifdef EFX_NEED_IS_BROADCAST_ETHER_ADDR
+	static inline int is_broadcast_ether_addr(const u8 *addr)
+	{
+        	return (addr[0] & addr[1] & addr[2] & addr[3] & addr[4] & addr[5]) == 0xff;
+	}
+#endif
+
+/**************************************************************************
+ *
+ * Missing functions provided by kernel_compat.c
+ *
+ **************************************************************************
+ *
+ */
+#ifdef EFX_NEED_RANDOM_ETHER_ADDR
+	extern void efx_random_ether_addr(uint8_t *addr);
+	#ifndef EFX_IN_KCOMPAT_C
+		#undef random_ether_addr
+		#define random_ether_addr efx_random_ether_addr
+	#endif
+#endif
+
+#ifdef EFX_NEED_UNREGISTER_NETDEVICE_NOTIFIER_FIX
+	/* unregister_netdevice_notifier() does not wait for the notifier
+	 * to be unused before 2.6.17 */
+	static inline int efx_unregister_netdevice_notifier(struct notifier_block *nb)
+	{
+		int res;
+
+		res = unregister_netdevice_notifier(nb);
+		rtnl_lock();
+		rtnl_unlock();
+		return res;
+	}
+	#define unregister_netdevice_notifier		 \
+		efx_unregister_netdevice_notifier
+#endif
+
+#if defined(EFX_NEED_PRINT_MAC)
+	extern char *print_mac(char *buf, const u8 *addr);
+#endif
+
+#ifdef EFX_NEED_COMPOUND_PAGE_FIX
+	extern void efx_compound_page_destructor(struct page *page);
+#endif
+
+#ifdef EFX_NEED_HEX_DUMP
+	extern void
+	print_hex_dump(const char *level, const char *prefix_str,
+		       int prefix_type, int rowsize, int groupsize,
+		       const void *buf, size_t len, int ascii);
+#endif
+
+#ifdef EFX_NEED_PCI_CLEAR_MASTER
+	extern void pci_clear_master(struct pci_dev *dev);
+#endif
+
+#ifdef EFX_NEED_PCI_WAKE_FROM_D3
+	extern int pci_wake_from_d3(struct pci_dev *dev, bool enable);
+#endif
+
+#ifdef EFX_NEED_MSECS_TO_JIFFIES
+	extern unsigned long msecs_to_jiffies(const unsigned int m);
+#endif
+
+#ifdef EFX_NEED_MSLEEP
+	extern void msleep(unsigned int msecs);
+#endif
+
+#ifdef EFX_NEED_SSLEEP
+	static inline void ssleep(unsigned int seconds)
+	{
+		msleep(seconds * 1000);
+	}
+#endif
+
+#ifdef EFX_NEED_MDELAY
+	#include <linux/delay.h>
+	#undef mdelay
+	#define mdelay(_n)				\
+		do {					\
+			unsigned long __ms = _n;	\
+			while (__ms--) udelay(1000);	\
+		} while (0);
+#endif
+
+#if (defined(EFX_NEED_UNMASK_MSIX_VECTORS) || \
+     defined(EFX_NEED_SAVE_MSIX_MESSAGES)) && \
+	!defined(EFX_HAVE_MSIX_TABLE_RESERVED)
+
+	#if defined(EFX_NEED_SAVE_MSIX_MESSAGES)
+		#include <linux/msi.h>
+	#endif
+
+	extern int efx_pci_save_state(struct pci_dev *dev);
+	#define pci_save_state efx_pci_save_state
+
+	extern int efx_pci_restore_state(struct pci_dev *dev);
+	#define pci_restore_state efx_pci_restore_state
+
+#endif
+
+#if defined(EFX_NEED_NEW_CPUMASK_API)
+
+	static inline void cpumask_clear(cpumask_t *dstp)
+	{
+		cpus_clear(*dstp);
+	}
+
+	static inline void cpumask_copy(cpumask_t *dstp, const cpumask_t *srcp)
+	{
+		*dstp = *srcp;
+	}
+
+	#define cpumask_test_cpu(cpu, mask) cpu_isset(cpu, *(mask))
+
+	static inline void cpumask_or(cpumask_t *dstp, const cpumask_t *src1p,
+				      const cpumask_t *src2p)
+	{
+		cpus_or(*dstp, *src1p, *src2p);
+	}
+
+	static inline unsigned int cpumask_weight(const cpumask_t *srcp)
+	{
+		return cpus_weight(*srcp);
+	}
+
+	#undef for_each_cpu
+	#define for_each_cpu(cpu, mask) for_each_cpu_mask(cpu, *(mask))
+
+	#undef for_each_possible_cpu
+	#define for_each_possible_cpu(CPU)			\
+		for_each_cpu_mask((CPU), cpu_possible_map)
+
+	typedef cpumask_t cpumask_var_t[1];
+
+	static inline bool alloc_cpumask_var(cpumask_var_t *mask, gfp_t flags)
+	{
+		return true;
+	}
+
+	static inline bool zalloc_cpumask_var(cpumask_var_t *mask, gfp_t flags)
+	{
+		cpumask_clear(*mask);
+		return true;
+	}
+
+	static inline void free_cpumask_var(cpumask_t *mask) {}
+
+	#ifdef topology_core_siblings
+		#define topology_core_cpumask(cpu)		\
+			(&(topology_core_siblings(cpu)))
+	#endif
+
+	#ifdef topology_thread_siblings
+		#define topology_thread_cpumask(cpu)		\
+			(&(topology_thread_siblings(cpu)))
+	#endif
+
+#elif defined(EFX_NEED_ZALLOC_CPUMASK_VAR)
+
+	#ifdef CONFIG_CPUMASK_OFFSTACK
+		static inline bool
+		zalloc_cpumask_var(cpumask_var_t *mask, gfp_t flags)
+		{
+			return alloc_cpumask_var(mask, flags | __GFP_ZERO);
+		}
+	#else
+		static inline bool
+		zalloc_cpumask_var(cpumask_var_t *mask, gfp_t flags)
+		{
+			cpumask_clear(*mask);
+			return true;
+		}
+	#endif
+
+#endif
+
+#ifndef EFX_HAVE_CPUMASK_OF_NODE
+# ifdef node_to_cpumask_ptr
+#  define cpumask_of_node(NODE)				\
+	({						\
+		node_to_cpumask_ptr(result, NODE);	\
+		result;					\
+	})
+# else
+#  define cpumask_of_node(NODE) &(node_to_cpumask(NODE))
+# endif
+#endif
+
+#if !defined(EFX_HAVE_TOPOLOGY_CPU_NODE_CPUMASK)
+	/* On AMD processors, use the L3 cache information
+	 * rather than the package information.
+	 */
+	#include <asm/processor.h>
+	#if defined(EFX_HAVE_LLC_SHARED_MAP) && defined(cpu_data)
+		/* cpu_data is in the (always exported) per_cpu() state */
+		#define topology_cpu_node_cpumask(cpu)			\
+			(cpu_data(cpu).x86_vendor == X86_VENDOR_AMD ?	\
+			 &(cpu_data(cpu).llc_shared_map) :		\
+			 topology_core_cpumask(cpu))
+	#elif defined(EFX_HAVE_LLC_SHARED_MAP_VAR) && defined(cpu_data)
+		/* cpu_data is in the (always exported) per_cpu() state */
+		#define topology_cpu_node_cpumask(cpu)			\
+			(cpu_data(cpu).x86_vendor == X86_VENDOR_AMD ?	\
+			 cpu_data(cpu).llc_shared_map :			\
+			 topology_core_cpumask(cpu))
+	#elif defined(EFX_HAVE_LLC_SHARED_MAP) && defined(EFX_HAVE_EXPORTED_CPU_DATA)
+	       	/* cpu_data is an exported array */
+		#define topology_cpu_node_cpumask(cpu)			\
+			(cpu_data[cpu].x86_vendor == X86_VENDOR_AMD ?	\
+			 &(cpu_data[cpu].llc_shared_map) :		\
+			 topology_core_cpumask(cpu))
+	#elif defined(topology_core_cpumask)
+		#define topology_cpu_node_cpumask			\
+			topology_core_cpumask
+	#endif
+#endif
+
+#if defined(EFX_NEED_SET_CPUS_ALLOWED_PTR) && !defined(set_cpus_allowed_ptr)
+	/* kernel_compat.sh uses nexport for set_cpus_allowed_ptr() because of
+	 * redhat backport madness, but on !SMP machines it's a macro */
+	#define set_cpus_allowed_ptr efx_set_cpus_allowed_ptr
+	static inline int efx_set_cpus_allowed_ptr(struct task_struct *p,
+						   const cpumask_t *new_mask)
+	{
+	#if !defined(CONFIG_SMP)
+		/* Don't use set_cpus_allowed() if present, because 2.6.11-2.6.15
+		 * define it using an unexported symbol */
+		if (!cpu_isset(0, *new_mask))
+			return -EINVAL;
+		return 0;
+	#else
+       		return set_cpus_allowed(p, *new_mask);
+	#endif
+	}
+#endif
+
+/**************************************************************************
+ *
+ * Wrappers to fix bugs and parameter changes
+ *
+ **************************************************************************
+ *
+ */
+#ifdef EFX_NEED_PCI_SAVE_RESTORE_WRAPPERS
+	#define pci_save_state(_dev)					\
+		pci_save_state(_dev, (_dev)->saved_config_space)
+
+	#define pci_restore_state(_dev)					\
+		pci_restore_state(_dev, (_dev)->saved_config_space)
+#endif
+
+#ifdef EFX_NEED_PCI_MATCH_ID
+	#define pci_match_id pci_match_device
+#endif
+
+#ifdef EFX_NEED_WORK_API_WRAPPERS
+	#define delayed_work work_struct
+	#undef INIT_DELAYED_WORK
+	#define INIT_DELAYED_WORK INIT_WORK
+	#undef EFX_USE_CANCEL_DELAYED_WORK_SYNC /* we can't */
+
+	/**
+	 * The old and new work-function prototypes just differ
+	 * in the type of the pointer returned, so it's safe
+	 * to cast between the prototypes.
+	 */
+	typedef void (*efx_old_work_func_t)(void *p);
+
+	#undef INIT_WORK
+	#define INIT_WORK(_work, _func)					\
+		do {							\
+			INIT_LIST_HEAD(&(_work)->entry);		\
+			(_work)->pending = 0;				\
+			PREPARE_WORK((_work),				\
+				     (efx_old_work_func_t) (_func),	\
+				     (_work));				\
+	                init_timer(&(_work)->timer);                    \
+		} while (0)
+#endif
+
+#if defined(EFX_HAVE_OLD_NAPI)
+
+	#ifndef EFX_USE_GRO
+		struct efx_napi_dummy {};
+		#define napi_struct efx_napi_dummy
+		#define napi_gro_flush(napi)
+	#endif
+
+	static inline void netif_napi_add(struct net_device *dev,
+					  struct napi_struct *napi,
+					  int (*poll) (struct net_device *,
+						       int *),
+					  int weight)
+	{
+		dev->weight = weight;
+		dev->poll = poll;
+	}
+	static inline void netif_napi_del(struct napi_struct *napi) {}
+
+	#define efx_napi_get_device(napi)				\
+		(container_of(napi, struct efx_channel, napi_str)->napi_dev)
+
+	#define napi_enable(napi) netif_poll_enable(efx_napi_get_device(napi))
+	#define napi_disable(napi) netif_poll_disable(efx_napi_get_device(napi))
+	#define napi_complete(napi)					\
+		do {							\
+			napi_gro_flush(napi);				\
+			netif_rx_complete(efx_napi_get_device(napi));	\
+		} while (0)
+
+	static inline void efx_napi_schedule(struct net_device *dev)
+	{
+		if (!test_and_set_bit(__LINK_STATE_RX_SCHED, &dev->state))
+			__netif_rx_schedule(dev);
+	}
+	#define napi_schedule(napi)					\
+		efx_napi_schedule(efx_napi_get_device(napi))
+
+#elif defined(EFX_NEED_NETIF_NAPI_DEL)
+	static inline void netif_napi_del(struct napi_struct *napi)
+	{
+	#ifdef CONFIG_NETPOLL
+        	list_del(&napi->dev_list);
+	#endif
+	}
+#endif
+
+#ifdef EFX_NEED_COMPOUND_PAGE_FIX
+	static inline
+	struct page *efx_alloc_pages(gfp_t flags, unsigned int order)
+	{
+		struct page *p = alloc_pages(flags, order);
+		if ((flags & __GFP_COMP) && (p != NULL) && (order > 0))
+			p[1].mapping = (void *)efx_compound_page_destructor;
+		return p;
+	}
+	#undef alloc_pages
+	#define alloc_pages efx_alloc_pages
+
+	static inline
+	void efx_free_pages(struct page *p, unsigned int order)
+	{
+		if ((order > 0) && (page_count(p) == 1))
+			p[1].mapping = NULL;
+		__free_pages(p, order);
+	}
+	#define __free_pages efx_free_pages
+#endif
+
+#ifdef EFX_NEED_HEX_DUMP_CONST_FIX
+	#define print_hex_dump(v,s,t,r,g,b,l,a) \
+		print_hex_dump((v),(s),(t),(r),(g),(void*)(b),(l),(a))
+#endif
+
+#ifndef EFX_HAVE_HWMON_H
+	static inline struct device *hwmon_device_register(struct device *dev)
+	{
+		return dev;
+	}
+	static inline void hwmon_device_unregister(struct device *cdev)
+	{
+	}
+#endif
+
+#ifdef EFX_NEED_HWMON_VID
+	#include <linux/i2c-vid.h>
+	static inline u8 efx_vid_which_vrm(void)
+	{
+		/* we don't use i2c on the cpu */
+		return 0;
+	}
+	#define vid_which_vrm efx_vid_which_vrm
+#endif
+
+#ifdef EFX_HAVE_OLD_DEVICE_ATTRIBUTE
+	/*
+	 * show and store methods do not receive a pointer to the
+	 * device_attribute.  We have to add wrapper functions.
+	 */
+
+	#undef DEVICE_ATTR
+	#define DEVICE_ATTR(_name, _mode, _show, _store)		\
+		/*static*/ ssize_t __##_name##_##show(struct device *dev, \
+						      char *buf)	\
+		{							\
+			return _show(dev, NULL, buf);			\
+		}							\
+		static ssize_t __##_name##_##store(struct device *dev,	\
+						   const char *buf,	\
+						   size_t count)	\
+		{							\
+			ssize_t (*fn)(struct device *dev,		\
+				      struct device_attribute *attr,	\
+				      const char *buf,			\
+				      size_t count) = _store;		\
+			return fn(dev, NULL, buf, count);		\
+		}							\
+		static ssize_t __##_name##_##store(struct device *,	\
+						   const char *, size_t) \
+			__attribute__((unused));			\
+		static struct device_attribute dev_attr_##_name =	\
+			__ATTR(_name, _mode, __##_name##_##show,	\
+			       __builtin_choose_expr			\
+			       (__builtin_constant_p(_store) && _store == NULL, \
+				NULL, __##_name##_##store))
+
+	struct sensor_device_attribute {
+		struct device_attribute dev_attr;
+		int index;
+	};
+
+	#define SENSOR_ATTR(_name, _mode, _show, _store, _index)        \
+	{ .dev_attr = __ATTR(_name, _mode, _show, _store),		\
+	  .index = _index }
+
+	#define SENSOR_DEVICE_ATTR(_name, _mode, _show,	\
+				   _store, _index)			\
+		/*static*/ ssize_t __##_name##_show_##_index(struct device *dev, \
+							     char *buf)	\
+		{							\
+			struct sensor_device_attribute attr;		\
+			attr.index = _index;				\
+			return _show(dev, &attr.dev_attr, buf);		\
+		}							\
+		static ssize_t __##_name##_store_##_index(struct device *dev, \
+							  const char *buf, \
+							  size_t count)	\
+		{							\
+			ssize_t (*fn)(struct device *dev,		\
+				      struct device_attribute *attr,	\
+				      const char *buf,			\
+				      size_t count) = _store;		\
+			struct sensor_device_attribute attr;		\
+			attr.index = _index;				\
+			return fn(dev, &attr.dev_attr, buf, count);	\
+		}							\
+		static ssize_t __##_name##_store_##_index(struct device *, \
+							  const char *, size_t) \
+			__attribute__((unused));			\
+		static struct sensor_device_attribute			\
+			sensor_dev_attr_##_name =			\
+			SENSOR_ATTR(_name, _mode,			\
+				    __##_name##_show_##_index,		\
+				    __builtin_choose_expr		\
+				    (__builtin_constant_p(_store) && _store == NULL, \
+				     NULL, __##_name##_store_##_index), \
+				    _index)
+
+	#define to_sensor_dev_attr(_dev_attr) \
+		container_of(_dev_attr, struct sensor_device_attribute,	\
+			     dev_attr)
+
+#endif
+
+
+#ifdef EFX_NEED_SCSI_SGLIST
+	#include <scsi/scsi.h>
+	#include <scsi/scsi_cmnd.h>
+	#define scsi_sglist(sc)    ((struct scatterlist *)((sc)->request_buffer))
+	#define scsi_bufflen(sc)   ((sc)->request_bufflen)
+	#define scsi_sg_count(sc)  ((sc)->use_sg)
+	static inline void scsi_set_resid(struct scsi_cmnd *sc, int resid)
+	{
+		sc->resid = resid;
+	}
+	static inline int scsi_get_resid(struct scsi_cmnd *sc)
+	{
+		return sc->resid;
+	}
+#endif
+
+
+#ifdef EFX_NEED_SG_NEXT
+	#define sg_page(sg) ((sg)->page)
+	#define sg_next(sg) ((sg) + 1)
+	#define for_each_sg(sglist, sg, nr, __i) \
+	  for (__i = 0, sg = (sglist); __i < (nr); __i++, sg = sg_next(sg))
+#endif
+
+#ifdef EFX_NEED_WARN_ON
+	#undef WARN_ON
+	#define WARN_ON(condition) ({				\
+		typeof(condition) __ret_warn_on = (condition);	\
+		if (unlikely(__ret_warn_on)) {			\
+			printk("BUG: warning at %s:%d/%s()\n",	\
+			__FILE__, __LINE__, __FUNCTION__);	\
+				dump_stack();			\
+		}						\
+		unlikely(__ret_warn_on);			\
+	})
+#endif
+
+#ifdef EFX_NEED_VMALLOC_NODE
+	static inline void *vmalloc_node(unsigned long size, int node)
+	{
+		return vmalloc(size);
+	}
+#endif
+
+#ifdef EFX_NEED_VMALLOC_TO_PFN
+	static inline unsigned long vmalloc_to_pfn(const void *addr)
+	{
+		return page_to_pfn(vmalloc_to_page((void*)addr));
+	}
+#endif
+
+#ifdef EFX_NEED_KVEC
+	struct kvec {
+		struct iovec iov;
+	};
+#endif
+
+#ifdef EFX_NEED_KERNEL_SENDMSG
+	static inline int kernel_sendmsg(struct socket *sock,
+					 struct msghdr *msg,
+					 struct kvec *vec, size_t num,
+					 size_t size)
+	{
+		mm_segment_t oldfs = get_fs();
+		int result;
+
+		set_fs(KERNEL_DS);
+		/* the following is safe, since for compiler definitions of
+		 * kvec and iovec are identical, yielding the same in-core
+		 * layout and alignment. */
+		msg->msg_iov = (struct iovec *)vec;
+		msg->msg_iovlen = num;
+		result = sock_sendmsg(sock, msg, size);
+		set_fs(oldfs);
+		return result;
+	}
+#endif
+
+#ifndef EFX_HAVE_ROUNDUP_POW_OF_TWO
+static inline unsigned long __attribute_const__ roundup_pow_of_two(unsigned long x)
+{
+	return 1UL << fls(x - 1);
+}
+#endif
+
+#ifndef EFX_HAVE_ROUNDDOWN_POW_OF_TWO
+static inline unsigned long __attribute_const__ rounddown_pow_of_two(unsigned long x)
+{
+	return 1UL << (fls(x) - 1);
+}
+#endif
+
+#ifdef EFX_NEED_ON_EACH_CPU_WRAPPER
+static inline int efx_on_each_cpu(void (*func) (void *info), void *info, int wait)
+{
+	return on_each_cpu(func, info, 0, wait);
+}
+#undef on_each_cpu
+#define on_each_cpu efx_on_each_cpu
+#endif
+
+#endif /* EFX_KERNEL_COMPAT_H */
diff -r 5b3d4d3c1166 drivers/net/sfc/kernel_compat.sh
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/drivers/net/sfc/kernel_compat.sh	Tue Nov 09 10:06:27 2010 +0000
@@ -0,0 +1,715 @@
+#!/bin/bash -eu
+######################################################################
+
+me=$(basename "$0")
+
+err  () { echo >&2 "$*";    }
+log  () { err "$me: $*";    }
+vlog () { $verbose && err "$me: $*"; }
+fail () { log "$*"; exit 1; }
+try  () { "$@" || fail "'$*' failed"; }
+vmsg () { $quiet || log "$@"; }
+
+function usage()
+{
+    err
+    err "usage:"
+    err "  $me [options] <symbol1> <symbol2>"
+    err
+    err "description:"
+    err "  Produce a list of kernel compatability macros to match the "
+    err "  kernel_compat.c and kernel_compat.h files"
+    err
+    err "options:"
+    err "  -k KPATH        -- Specify the path to the kernel build source tree"
+    err "                     defaults to /lib/modules/VERSION/build"
+    err "  -r VERSION      -- Specify the kernel version instead to test"
+    err '                     defaults to `uname -r`'
+    err "  -a ARCH         -- Set the architecture to ARCH"
+    err "                     defaults to `uname -m`"
+    err "  -m MAP          -- Specify a System map for the build kernel."
+    err "                     By default will look in KPATH and /boot"
+    err "  -q              -- Quieten the checks"
+    err "  -v              -- Verbose output"
+    err "  <symbol>        -- Symbol to evaluate."
+    err "                     By default every symbol is evaluated"
+
+}
+
+######################################################################
+# Symbol definition map
+
+function generate_kompat_symbols() {
+    echo "
+EFX_HAVE_OLD_NAPI			nsymbol napi_schedule		include/linux/netdevice.h
+EFX_HAVE_OLD_CSUM			nsymbol __sum16			include/linux/types.h
+EFX_HAVE_OLD_IP_FAST_CSUM		custom
+EFX_NEED_BYTEORDER_TYPES		nsymbol	__be32			include/linux/types.h
+EFX_NEED_CSUM_UNFOLDED			nsymbol csum_unfold		include/net/checksum.h
+EFX_NEED_CSUM_TCPUDP_NOFOLD		custom
+EFX_NEED_DEV_NOTICE			nsymbol	dev_notice		include/linux/device.h
+EFX_NEED_DUMMY_PCI_DISABLE_MSI		nexport	pci_disable_msi		include/linux/pci.h	drivers/pci/msi.c
+EFX_NEED_DUMMY_MSIX			nsymbol msix_entry		include/linux/pci.h
+EFX_NEED_ENABLE_MSIX			nexport	pci_enable_msix		include/linux/pci.h	drivers/pci/msi.c
+EFX_HAVE_GRO				symtype	napi_gro_frags		include/linux/netdevice.h int(struct napi_struct *)
+EFX_NEED_GFP_T				custom
+EFX_NEED_HEX_DUMP			nexport	print_hex_dump		include/linux/kernel.h	lib/hexdump.c
+EFX_NEED_HEX_DUMP_CONST_FIX 		symtype	print_hex_dump		include/linux/kernel.h void(const char *, const char *, int, int, int, void *, size_t, bool)
+EFX_NEED_IF_MII				nsymbol	if_mii			include/linux/mii.h
+EFX_HAVE_IRQ_HANDLER_REGS		symbol	pt_regs			include/linux/interrupt.h
+EFX_NEED_IRQ_HANDLER_T			nsymbol	irq_handler_t		include/linux/interrupt.h
+EFX_NEED_KCALLOC			nsymbol	kcalloc			include/linux/slab.h
+EFX_NEED_KZALLOC			nsymbol	kzalloc			include/linux/slab.h
+EFX_NEED_MII_CONSTANTS			nsymbol	LPA_1000FULL		include/linux/mii.h
+EFX_NEED_MII_ADVERTISE_FLOWCTRL		nsymbol	mii_advertise_flowctrl	include/linux/mii.h
+EFX_NEED_MII_RESOLVE_FLOWCTRL_FDX	nsymbol	mii_resolve_flowctrl_fdx include/linux/mii.h
+EFX_HAVE_LINUX_MDIO_H			file				include/linux/mdio.h
+EFX_NEED_MSECS_TO_JIFFIES		custom
+EFX_NEED_MDELAY				custom
+EFX_NEED_MSLEEP				nexport	msleep			include/linux/delay.h	kernel/timer.c
+EFX_NEED_SSLEEP				nsymbol	ssleep			include/linux/delay.h
+EFX_NEED_MTD_ERASE_CALLBACK		nsymbol	mtd_erase_callback	include/linux/mtd/mtd.h
+EFX_NEED_MUTEX				nsymbol	mutex_is_locked		include/linux/mutex.h
+EFX_NEED_NETDEV_ALLOC_SKB		nsymbol	netdev_alloc_skb	include/linux/skbuff.h
+EFX_NEED_NETDEV_TX_T			nsymbol	netdev_tx_t		include/linux/netdevice.h
+EFX_NEED_NETIF_NAPI_DEL			nsymbol	netif_napi_del		include/linux/netdevice.h
+EFX_NEED_NETIF_TX_LOCK			nsymbol	netif_tx_lock		include/linux/netdevice.h
+EFX_NEED_NETIF_ADDR_LOCK		nsymbol	netif_addr_lock		include/linux/netdevice.h
+EFX_HAVE_ALLOC_ETHERDEV_MQ		symbol	alloc_etherdev_mq	include/linux/etherdevice.h
+EFX_USE_TX_MQ				symbol	netdev_get_tx_queue	include/linux/netdevice.h
+EFX_NEED_NETIF_SET_REAL_NUM_TX_QUEUES	nsymbol	netif_set_real_num_tx_queues include/linux/netdevice.h
+EFX_NEED_NETIF_SET_REAL_NUM_RX_QUEUES	nsymbol	netif_set_real_num_rx_queues include/linux/netdevice.h
+EFX_NEED_PCI_CLEAR_MASTER		nsymbol	pci_clear_master	include/linux/pci.h
+EFX_NEED_PCI_MATCH_ID			nsymbol pci_match_id		include/linux/pci.h
+EFX_NEED_PCI_SAVE_RESTORE_WRAPPERS	symtype	pci_save_state		include/linux/pci.h int(struct pci_dev *, u32 *)
+EFX_NEED_PRINT_MAC			nsymbol print_mac		include/linux/if_ether.h
+EFX_NEED_RANDOM_ETHER_ADDR		nsymbol	random_ether_addr	include/linux/etherdevice.h
+EFX_NEED_RESOURCE_SIZE_T		nsymbol resource_size_t		include/linux/types.h
+EFX_NEED_RTNL_TRYLOCK			nsymbol	rtnl_trylock		include/linux/rtnetlink.h
+EFX_HAVE_ROUND_JIFFIES_UP		symbol	round_jiffies_up	include/linux/timer.h
+EFX_NEED_SAFE_LISTS			nsymbol	list_for_each_entry_safe_reverse	include/linux/list.h
+EFX_NEED_SCHEDULE_TIMEOUT_INTERRUPTIBLE	nexport	schedule_timeout_interruptible		include/linux/sched.h	kernel/timer.c
+EFX_NEED_SCHEDULE_TIMEOUT_UNINTERRUPTIBLE	nexport	schedule_timeout_uninterruptible	include/linux/sched.h	kernel/timer.c
+EFX_NEED_SETUP_TIMER			nsymbol setup_timer		include/linux/timer.h
+EFX_NEED_SKB_HEADER_MACROS		nsymbol	skb_mac_header		include/linux/skbuff.h
+EFX_NEED_ETH_HDR			nsymbol	eth_hdr			include/linux/if_ether.h
+EFX_NEED_VLAN_ETH_HDR			nsymbol	vlan_eth_hdr		include/linux/if_vlan.h
+EFX_NEED_TCP_HDR			nsymbol	tcp_hdr			include/linux/tcp.h
+EFX_NEED_IP_HDR				nsymbol	ip_hdr			include/linux/ip.h
+EFX_NEED_IPV6_HDR			nsymbol	ipv6_hdr		include/linux/ipv6.h
+EFX_NEED_WORK_API_WRAPPERS		nmember	struct_delayed_work	timer	include/linux/workqueue.h
+EFX_USE_CANCEL_DELAYED_WORK_SYNC	symbol	cancel_delayed_work_sync		include/linux/workqueue.h
+EFX_USE_CANCEL_WORK_SYNC		symbol	cancel_work_sync	include/linux/workqueue.h
+EFX_USE_ETHTOOL_ETH_TP_MDIX		symbol	eth_tp_mdix		include/linux/ethtool.h
+EFX_USE_ETHTOOL_GET_PERM_ADDR		symbol	get_perm_addr		include/linux/ethtool.h
+EFX_USE_ETHTOOL_FLAGS			symbol	get_flags		include/linux/ethtool.h
+EFX_USE_ETHTOOL_LP_ADVERTISING		symbol	lp_advertising		include/linux/ethtool.h
+EFX_USE_ETHTOOL_MDIO_SUPPORT		symbol	mdio_support		include/linux/ethtool.h
+EFX_USE_LINUX_IO_H			file				include/linux/io.h
+EFX_USE_LINUX_UACCESS_H			file				include/linux/uaccess.h
+EFX_USE_MTD_ERASE_FAIL_ADDR		symbol	fail_addr		include/linux/mtd/mtd.h
+EFX_USE_MTD_WRITESIZE			symbol	writesize		include/linux/mtd/mtd.h
+EFX_USE_NETDEV_DEV			member	struct_net_device	dev	include/linux/netdevice.h
+EFX_USE_NETDEV_DEV_ID			member	struct_net_device	dev_id	include/linux/netdevice.h
+EFX_USE_NETDEV_STATS			custom
+EFX_USE_NETDEV_STATS64			member	struct_net_device_ops	ndo_get_stats64 include/linux/netdevice.h
+EFX_USE_PCI_DEV_REVISION		symbol	revision		include/linux/pci.h
+EFX_USE_NETDEV_VLAN_FEATURES		symbol	vlan_features		include/linux/netdevice.h
+EFX_USE_DEV_MC_LIST			memtype	struct_net_device	mc_list	include/linux/netdevice.h	struct dev_mc_list *
+EFX_USE_I2C_LEGACY			custom
+EFX_NEED_I2C_NEW_DUMMY			nsymbol	i2c_new_dummy		include/linux/i2c.h
+EFX_HAVE_OLD_I2C_DRIVER_PROBE		custom
+EFX_HAVE_OLD_I2C_NEW_DUMMY		symtype	i2c_new_dummy		include/linux/i2c.h struct i2c_client *(struct i2c_adapter *, u16, const char *)
+EFX_USE_I2C_DRIVER_NAME			custom
+EFX_HAVE_HWMON_H			file				include/linux/hwmon.h
+EFX_NEED_HWMON_VID			nfile				include/linux/hwmon-vid.h
+EFX_HAVE_I2C_SENSOR_H			file    			include/linux/i2c-sensor.h
+EFX_HAVE_HWMON_CLASS_DEVICE		symtype	hwmon_device_register	include/linux/hwmon.h struct class_device *(struct device *)
+EFX_HAVE_OLD_DEVICE_ATTRIBUTE		custom
+EFX_NEED_BOOL				nsymbol	bool			include/linux/types.h
+EFX_USE_ETHTOOL_GET_SSET_COUNT		symbol	get_sset_count		include/linux/ethtool.h
+EFX_HAVE_ETHTOOL_RESET			symbol	ethtool_reset_flags	include/linux/ethtool.h
+EFX_NEED_I2C_LOCK_ADAPTER		nsymbol	i2c_lock_adapter	include/linux/i2c.h
+EFX_USE_I2C_BUS_SEMAPHORE		custom
+EFX_HAVE_OLD_PCI_DMA_MAPPING_ERROR	custom
+EFX_HAVE_LINUX_SEMAPHORE_H		file				include/linux/semaphore.h
+EFX_NEED_DEV_GET_STATS			nsymbol	dev_get_stats		include/linux/netdevice.h
+EFX_HAVE_OLD_CPUMASK_SCNPRINTF		nsymtype cpumask_scnprintf	include/linux/cpumask.h int(char *, int, const struct cpumask *)
+EFX_NEED_NEW_CPUMASK_API		nsymbol	cpumask_var_t		include/linux/cpumask.h
+EFX_NEED_ZALLOC_CPUMASK_VAR		nsymbol zalloc_cpumask_var	include/linux/cpumask.h
+EFX_USE_PM				symbol	PM_EVENT_SUSPEND	include/linux/pm.h
+EFX_USE_PM_EXT_OPS			symbol	pm_ext_ops		include/linux/pm.h
+EFX_USE_DEV_PM_OPS			symbol	dev_pm_ops		include/linux/pm.h
+EFX_NEED_ATOMIC_CMPXCHG			custom
+EFX_NEED_WARN_ON			custom
+EFX_NEED_WAIT_EVENT_TIMEOUT		nsymbol wait_event_timeout	include/linux/wait.h
+EFX_NEED_ETHTOOL_CONSTANTS		nsymbol	ADVERTISED_Pause	include/linux/ethtool.h
+EFX_NEED_PCI_WAKE_FROM_D3		nsymbol pci_wake_from_d3        include/linux/pci.h
+EFX_HAVE_DEV_DISABLE_LRO		export	dev_disable_lro		include/linux/netdevice.h	net/core/dev.c
+EFX_NEED_UNMASK_MSIX_VECTORS		nsymbol	masked			include/linux/msi.h
+EFX_HAVE_PM_IDLE			export	pm_idle			include/linux/pm.h arch/$SRCARCH/kernel/process.c
+EFX_HAVE_SKB_RECORD_RX_QUEUE		symbol	skb_record_rx_queue	include/linux/skbuff.h
+EFX_HAVE_XEN_XEN_H			file				include/xen/xen.h
+EFX_HAVE_XEN_START_INFO			custom
+EFX_HAVE_CPUMASK_OF_NODE		symbol	cpumask_of_node		include/asm/topology.h	arch/$SRCARCH/include/asm/topology.h
+EFX_HAVE_TOPOLOGY_CPU_NODE_CPUMASK	symbol	topology_cpu_node_cpumask	include/linux/topology.h
+EFX_HAVE_LLC_SHARED_MAP			memtype	struct_cpuinfo_x86	llc_shared_map		include/asm/processor.h		cpumask_t
+EFX_HAVE_LLC_SHARED_MAP_VAR		memtype	struct_cpuinfo_x86	llc_shared_map		include/asm/processor.h		cpumask_var_t
+EFX_HAVE_EXPORTED_CPU_DATA		custom
+EFX_NEED_SET_CPUS_ALLOWED_PTR		nexport set_cpus_allowed_ptr	include/linux/sched.h		kernel/sched.c
+EFX_HAVE_GENERATED_AUTOCONF_H		file	include/generated/autoconf.h
+EFX_NEED_ON_EACH_CPU_WRAPPER 		nsymtype on_each_cpu		include/linux/smp.h int(void (*func) (void *), void *, int)
+EFX_HAVE_EXPORTED_CPU_SIBLING_MAP	export	(per_cpu__)?cpu_sibling_map	include/asm/smp.h	arch/$SRCARCH/include/asm/smp.h	arch/$SRCARCH/kernel/smpboot.c	drivers/xen/core/smpboot.c
+EFX_HAVE_ROUNDDOWN_POW_OF_TWO		symbol	rounddown_pow_of_two	include/linux/log2.h include/linux/kernel.h
+EFX_HAVE_ROUNDUP_POW_OF_TWO		symbol	roundup_pow_of_two	include/linux/log2.h include/linux/kernel.h
+EFX_HAVE_SRIOV				export	pci_enable_sriov	include/linux/pci.h	drivers/pci/iov.c
+EFX_HAVE_NDO_SET_VF_MAC 		symbol	ndo_set_vf_mac		include/linux/netdevice.h
+EFX_NEED_IS_ZERO_ETHER_ADDR		nsymbol	is_zero_ether_addr	include/linux/etherdevice.h
+EFX_NEED_IS_BROADCAST_ETHER_ADDR	nsymbol	is_broadcast_ether_addr	include/linux/etherdevice.h
+
+# Stuff needed in code other than the linux net driver
+EFX_NEED_FOR_EACH_PCI_DEV		nsymbol for_each_pci_dev	include/linux/pci.h
+EFX_NEED_SCSI_SGLIST			nsymbol scsi_sglist		include/scsi/scsi_cmnd.h
+EFX_NEED_SG_NEXT			nsymbol sg_next			include/linux/scatterlist.h
+EFX_HAVE_NEW_KFIFO			symbol kfifo_out		include/linux/kfifo.h
+EFX_NEED_VMALLOC_NODE			nsymbol vmalloc_node		include/linux/vmalloc.h
+EFX_NEED_VMALLOC_TO_PFN			nsymbol vmalloc_to_pfn		include/linux/mm.h
+EFX_NEED_KVEC				nsymbol	kvec			include/linux/uio.h
+EFX_NEED_KERNEL_SENDMSG			nsymbol kernel_sendmsg		include/linux/net.h
+EFX_HAVE_GENERATED_UTSRELEASE_H		file	include/generated/utsrelease.h
+" | egrep -v -e '^#' -e '^$' | sed 's/[ \t][ \t]*/:/g'
+}
+
+######################################################################
+# Generic methods for standard symbol types
+
+function do_symbol()  { shift 2; test_symbol "$@"; }
+function do_nsymbol() { shift 2; ! test_symbol "$@"; }
+function do_symtype() { shift 2; test_symtype "$@"; }
+function do_nsymtype() { shift 2; ! test_symtype "$@"; }
+function do_member() { shift 2; test_memtype "$@" void; }
+function do_nmember() { shift 2; ! test_memtype "$@" void; }
+function do_memtype() { shift 2; test_memtype "$@"; }
+function do_nmemtype() { shift 2; ! test_memtype "$@"; }
+function do_export()
+{
+    local sym=$3
+    shift 3
+
+    # Only scan header files for the symbol
+    test_symbol $sym $(echo "$@" | sed -r 's/ [^ ]+\.c/ /g') || return
+    test_export $sym "$@"
+}
+function do_nexport() { ! do_export "$@"; }
+function do_file()    { test -f $KBUILD_SRC/$3; }
+function do_nfile()   { ! test -f $KBUILD_SRC/$3; }
+
+function do_custom()  { do_$1; }
+
+######################################################################
+# Implementation of kernel feature checking
+
+function atexit_cleanup()
+{
+  rc=$?
+  [ -n "$rmfiles" ] && rm -f $rmfiles
+  return $rc
+}
+
+function strip_comments()
+{
+    local file=$1
+
+    cat $1 | sed -e '
+/\/\*/!b
+:a
+/\*\//!{
+N
+ba
+}
+s:/\*.*\*/::'
+}
+
+function test_symbol()
+{
+    local symbol=$1
+    shift
+    local file
+
+    for file in "$@"; do
+        # For speed, lets just grep through the file. The symbol may
+        # be of any of these forms:
+        #     #define SYMBOL
+        #     typedef void (SYMBOL)(void)
+        #     extern void SYMBOL(void)
+        #     void (*SYMBOL)(void)
+        #     enum { SYMBOL, } void
+        #
+        if [ $verbose = true ]; then
+            echo >&2 "Looking for '$symbol' in '$KBUILD_SRC/$file'"
+        fi
+        [ -f "$KBUILD_SRC/$file" ] &&  \
+            strip_comments $KBUILD_SRC/$file | \
+            egrep -w "$symbol" >/dev/null && \
+            return 0
+    done
+    return 1
+}
+
+function test_symtype()
+{
+    local symbol=$1
+    local file=$2
+    shift 2
+    local type="$*"
+
+    if [ ${file:0:8} != "include/" ]; then
+	fail "test_symtype() can work in include/ - request was '$file'"
+    fi
+
+    test_compile "
+#include <${file:8}>
+__typeof($type) *kernel_compat_dummy = &$symbol;
+"
+}
+
+function test_memtype()
+{
+    local aggtype="${1/_/ }"
+    local memname=$2
+    local file=$3
+    shift 3
+    local memtype="$*"
+
+    if [ ${file:0:8} != "include/" ]; then
+	fail "test_symtype() can work in include/ - request was '$file'"
+    fi
+
+    test_compile "
+#include <${file:8}>
+$aggtype kernel_compat_dummy_1;
+__typeof($memtype) *kernel_compat_dummy_2 = &kernel_compat_dummy_1.$memname;
+"
+}
+
+function test_inline_symbol()
+{
+    local symbol=$1
+    local file=$2
+    local t=$(mktemp)
+    rmfiles="$rmfiles $t"
+
+    [ -f "$KBUILD_SRC/$file" ] || return
+
+    # TODO: This isn't very satisfactory. Alternative options are:
+    #   1. Come up with a clever sed version
+    #   2. Do a test compile, and look for an undefined symbol (extern)
+
+    # look for the inline..symbol. This is complicated since the inline
+    # and the symbol may be on different lines.
+    strip_comments $KBUILD_SRC/$file | \
+	egrep -m 1 -B 1 '(^|[,\* \(])'"$symbol"'($|[,; \(\)])' > $t
+    [ $? = 0 ] || return $?
+        
+    # there is either an inline on the final line, or an inline and
+    # no semicolon on the previous line
+    head -1 $t | egrep -q 'inline[^;]*$' && return
+    tail -1 $t | egrep -q 'inline' && return
+
+    return 1
+}
+
+function test_export()
+{
+    local symbol=$1
+    shift
+    local files="$@"
+    local file match
+
+    # Looks for the given export symbol $symbol, defined in $file
+    # Since this symbol is exported, we can look for it in:
+    #     1. If the full source is installed, look in there
+    #     2. $KPATH/Module.symvers
+    #     3. The MAP file if present - though this only lists
+    #        defined symbols not exported symbols (so it's not
+    #        100% reliable
+    for file in $files; do
+        if [ $verbose = true ]; then
+            echo >&2 "Looking for export of $symbol in $KBUILD_SRC/$file"
+        fi
+        if [ -f $KBUILD_SRC/$file ]; then
+	    egrep -q 'EXPORT_(PER_CPU)?SYMBOL(_GPL)?\('"$symbol"'\)' $KBUILD_SRC/$file && return
+        fi
+    done
+
+    if [ $verbose = true ]; then
+        echo >&2 "Looking for export of $symbol in $KPATH/Module.symvers"
+    fi
+    if [ -f $KPATH/Module.symvers ]; then
+	[ -n "$(awk '/0x[0-9a-f]+[\t ]+'$symbol'[\t ]+/' $KPATH/Module.symvers)" ] && return
+
+    elif [ -n "$MAP" ]; then
+        if [ $verbose = true ]; then
+            echo >&2 "Looking for export of $symbol in $MAP"
+        fi
+	egrep -q "[A-Z] $symbol\$" $MAP && return
+    fi
+
+    return 1
+}
+
+function test_compile()
+{
+    local source="$1"
+    local rc
+    local dir=$(mktemp -d)
+    echo "$source" > $dir/test.c
+    cat > $dir/Makefile <<EOF
+obj-m := test.o
+EOF
+    make -C $KPATH $EXTRA_MAKEFLAGS EXTRA_CFLAGS=-Werror M=$dir >$dir/log 2>&1
+    rc=$?
+
+    if [ $verbose = true ]; then
+	echo >&2 "tried to compile:"
+	sed >&2 's/^/    /' $dir/test.c
+	echo >&2 "compiler output:"
+	sed >&2 's/^/    /' $dir/log
+    fi
+
+    rm -rf $dir
+    return $rc
+}
+
+function read_make_variables()
+{
+    local regexp=''
+    local split='('
+    local variable
+    local variables="$@"
+    local dir=$(mktemp -d)
+
+    for variable in $variables; do
+	echo "\$(warning $variable=\$($variable))" >> $dir/Makefile
+	regexp=$regexp$split$variable
+	split='|'
+    done
+    make -C $KPATH $EXTRA_MAKEFLAGS M=$dir 2>&1 >/dev/null | sed -r "s#$dir/Makefile:.*: ($regexp)=.*$)#\1#; t; d"
+    rc=$?
+
+    rm -rf $dir
+    return $rc
+}
+
+function read_define()
+{
+    local variable="$1"
+    local file="$2"
+    cat $KPATH/$2 | sed -r 's/#define '"$variable"' (.*)/\1/; t; d'
+}
+
+######################################################################
+# Implementation for more tricky types
+
+function do_EFX_HAVE_OLD_IP_FAST_CSUM()
+{
+    # ip_fast_csum takes (unsigned char*) in older kernels
+    local source="
+#include <asm/checksum.h>
+void test(const void *iph) { ip_fast_csum(iph, 20); }"
+    ! test_compile "$source"
+}
+
+function do_EFX_NEED_CSUM_TCPUDP_NOFOLD()
+{
+    # csum_tcpudp_nofold is defined in archicture specific code, and
+    # is either inline in include/asm/checksum.h, or exported in
+    # arch/ARCH/lib/checksum.c.
+    local s=csum_tcpudp_nofold
+    ! test_inline_symbol $s include/asm-$SRCARCH/checksum.h && \
+	! test_inline_symbol $s include/asm-$SRCARCH/checksum$WORDSUFFIX.h && \
+	! test_inline_symbol $s arch/$SRCARCH/include/asm/checksum.h && \
+	! test_inline_symbol $s arch/$SRCARCH/include/asm/checksum$WORDSUFFIX.h && \
+	! test_export $s arch/$SRCARCH/lib/checksum.c && \
+	! test_export $s arch/$SRCARCH/lib/checksum$WORDSUFFIX.c
+}
+
+function do_EFX_NEED_MDELAY()
+{
+    # rhel4 buggered up mdelay with -Werror builds
+    local source="
+#include <linux/delay.h>
+void test(void) { mdelay(100); }"
+    ! test_compile "$source"
+}
+
+function do_EFX_NEED_MSECS_TO_JIFFIES()
+{
+    # inline up to 2.6.20, then became extern
+    local s=msecs_to_jiffies
+
+    ! test_inline_symbol $s include/linux/jiffies.h && \
+	! test_inline_symbol $s include/linux/time.h && \
+	! test_export $s kernel/time.c
+}
+
+function do_EFX_NEED_GFP_T()
+{
+    ! test_symbol gfp_t include/linux/types.h && \
+	! test_symbol gfp_t include/linux/gfp.h
+}
+
+function do_EFX_USE_NETDEV_STATS()
+{
+    local source="
+#include <linux/netdevice.h>
+struct net_device_stats *stats;
+void test(struct net_device *net_dev) { stats = &net_dev->stats; }"
+    test_compile "$source"
+}
+
+function do_EFX_USE_I2C_LEGACY()
+{
+    local source="
+#include <linux/i2c.h>
+struct i2c_driver d = {
+	.probe = 0,
+};"
+    ! test_compile "$source"
+}
+
+function do_EFX_HAVE_OLD_I2C_DRIVER_PROBE()
+{
+    local source="
+#include <linux/i2c.h>
+int f(struct i2c_client *);
+struct i2c_driver d = {
+	.probe = f
+};"
+    test_compile "$source"
+}
+
+function do_EFX_USE_I2C_DRIVER_NAME()
+{
+    local source="
+#include <linux/i2c.h>
+struct i2c_driver d = {
+	.name = \"\"
+};"
+    test_compile "$source"
+}
+
+function do_EFX_HAVE_OLD_DEVICE_ATTRIBUTE()
+{
+    local source="
+#include <linux/device.h>
+ssize_t f(struct device *, char *);
+struct device_attribute d = {
+	.show = f
+};"
+    test_compile "$source"
+}
+
+function do_EFX_USE_I2C_BUS_SEMAPHORE()
+{
+    test_compile "
+#include <linux/i2c.h>
+struct semaphore *f(struct i2c_adapter *a) { return &a->bus_lock; }
+"
+}
+
+function do_EFX_HAVE_OLD_PCI_DMA_MAPPING_ERROR()
+{
+    # We should be able to use symtype for this, but pci_dma_mapping_error
+    # used to be defined as a macro on some architectures.
+    test_compile "
+#include <linux/pci.h>
+int f(void) { return pci_dma_mapping_error(0); }
+"
+}
+
+function do_EFX_NEED_ATOMIC_CMPXCHG()
+{
+    local s=atomic_cmpxchg
+    [ -f $KBUILD_SRC/include/asm-$SRCARCH/atomic.h ] &&
+        ! test_symbol $s include/asm-$SRCARCH/atomic.h &&
+        ! test_symbol $s include/asm-$SRCARCH/atomic$WORDSUFFIX.h
+}
+
+function do_EFX_NEED_WARN_ON()
+{
+    local source="
+#include <asm/bug.h>
+int f(void) { return WARN_ON(1); }
+"
+    ! test_compile "$source"
+}
+
+function do_EFX_HAVE_XEN_START_INFO()
+{
+    case $SRCARCH in
+	i386 | x86)
+	    test_export xen_start_info arch/$SRCARCH/xen/enlighten.c || return
+	    ;;
+	ia64)
+	    test_export xen_start_info arch/ia64/xen/hypervisor.c || return
+	    ;;
+	*)
+	    return 1
+	    ;;
+    esac
+
+    test_symbol xen_start_info \
+	include/asm/xen/hypervisor.h \
+	arch/$SRCARCH/include/asm/xen/hypervisor.h
+}
+
+function do_EFX_HAVE_EXPORTED_CPU_DATA()
+{
+    test_symtype cpu_data include/asm/processor.h 'struct cpuinfo_x86[]' || return
+
+    # cpu_data gets exported in lots of places in various kernels
+    test_export cpu_data \
+        arch/x86_64/kernel/x8664_ksyms.c \
+        arch/i386/kernel/i386_ksyms.c \
+        arch/$SRCARCH/kernel/smpboot.c \
+        drivers/xen/core/smpboot.c
+}
+
+######################################################################
+# main()
+
+quiet=false
+verbose=false
+
+KVER=
+KPATH=
+FILTER=
+unset ARCH  # avoid exporting ARCH during initial checks
+ARCH=
+MAP=
+EXTRA_MAKEFLAGS=
+
+# These variables from an outer build will interfere with our test builds
+unset KBUILD_EXTMOD
+unset KBUILD_SRC
+unset M
+unset MAKEFLAGS
+unset TOPDIR
+
+# Clean-up temporary files when we exit.
+rmfiles=
+trap atexit_cleanup EXIT
+
+while [ $# -gt 0 ]; do
+    case "$1" in
+	-r) KVER=$2; shift;;
+	-k) KPATH=$2; shift;;
+	-q) quiet=true;;
+	-m) MAP=$2; shift;;
+	-v) verbose=true;;
+	-*) usage; exit -1;;
+	*)  [ -z $FILTER ] && FILTER=$1 || FILTER="$FILTER|$1";;
+	*)  break;
+    esac
+    shift
+done
+
+# resolve KVER and KPATH
+[ -z "$KVER" ] && [ -z "$KPATH" ] && KVER=`uname -r`
+[ -z "$KPATH" ] && KPATH=/lib/modules/$KVER/build
+
+# Need to set CC explicitly on the kernel make line
+# Needs to override top-level kernel Makefile setting
+set +u
+if [ -n "$CC" ]; then
+    EXTRA_MAKEFLAGS="CC=$CC"
+fi
+set -u
+
+# Ensure it looks like a build tree and we can build a module
+[ -d "$KPATH" ] || fail "$KPATH is not a directory"
+[ -f "$KPATH/Makefile" ] || fail "$KPATH/Makefile is not present"
+test_compile "#include <linux/module.h>" || \
+    fail "Kernel build tree is unable to build modules"
+
+# strip the KVER out of UTS_RELEASE, and compare to the specified KVER
+_KVER=
+for F in include/generated/utsrelease.h include/linux/utsrelease.h include/linux/version.h; do
+    [ -f $KPATH/$F ] && _KVER="$(eval echo $(read_define UTS_RELEASE $F))" && break
+done
+[ -n "$_KVER" ] || fail "Unable to identify kernel version from $KPATH"
+if [ -n "$KVER" ]; then
+    [ "$KVER" = "$_KVER" ] || fail "$KPATH kernel version $_KVER does not match $KVER"
+fi
+KVER=$_KVER
+unset _KVER
+
+vmsg "KVER       := $KVER"
+vmsg "KPATH      := $KPATH"
+
+# Read the following variables from the Makefile:
+#     KBUILD_SRC:         Root of source tree (not the same as KPATH under SUSE)
+#     ARCH:               Target architecture name
+#     SRCARCH:            Target architecture directory name (2.6.24 onward)
+#     CONFIG_X86_{32,64}: Work around ARCH = x86 madness
+[ -n "$ARCH" ] && export ARCH
+eval $(read_make_variables KBUILD_SRC ARCH SRCARCH CONFIG_X86_32 CONFIG_X86_64)
+
+# Define:
+#     KBUILD_SRC:         If not already set, same as KPATH
+#     SRCARCH:            If not already set, same as ARCH
+#     WORDSUFFIX:         Suffix added to some filenames by the i386/amd64 merge
+[ -n "$KBUILD_SRC" ] || KBUILD_SRC=$KPATH
+[ -n "$SRCARCH" ] || SRCARCH=$ARCH
+if [ "$ARCH" = "i386" ] || [ "$CONFIG_X86_32" = "y" ]; then
+    WORDSUFFIX=_32
+elif [ "$ARCH" = "x86_64" ] || [ "$CONFIG_X86_64" = "y" ]; then
+    WORDSUFFIX=_64
+else
+    WORDSUFFIX=
+fi
+[ -f "$KBUILD_SRC/arch/$SRCARCH/Makefile" ] || fail "$KBUILD_SRC doesn't directly build $SRCARCH"
+
+vmsg "KBUILD_SRC := $KBUILD_SRC"
+vmsg "SRCARCH    := $SRCARCH"
+vmsg "WORDSUFFIX := $WORDSUFFIX"
+
+# try and find the System map [used by test_export]
+if [ -z "$MAP" ]; then
+    if [ -f /boot/System.map-$KVER ]; then
+	MAP=/boot/System.map-$KVER
+    elif [ $KVER = "`uname -r`" ] && [ -f /proc/kallsyms ]; then
+	MAP=/proc/kallsyms
+    elif [ -f $KPATH/Module.symvers ]; then
+	# can use this to find external symbols only
+	true
+    else
+	vmsg "!!Unable to find a valid System map. Export symbol checks may not work"
+    fi
+fi
+
+kompat_symbols="$(generate_kompat_symbols)"
+
+# filter the available symbols
+if [ -n "$FILTER" ]; then
+    kompat_symbols="$(echo "$kompat_symbols" | egrep "^($FILTER):")"
+fi
+
+# process each symbol
+for symbol in $kompat_symbols; do
+    # split symbol at colons; disable globbing (pathname expansion)
+    set -o noglob
+    IFS=:
+    set -- $symbol
+    unset IFS
+    set +o noglob
+
+    key="$1"
+    method="$2"
+    if do_${method} "$@"; then
+	echo "#define $key yes"
+    else
+	echo "// #define $key"
+    fi
+done
diff -r 5b3d4d3c1166 drivers/net/sfc/linux_mdio.c
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/drivers/net/sfc/linux_mdio.c	Tue Nov 09 10:06:27 2010 +0000
@@ -0,0 +1,453 @@
+/*
+ * mdio.c: Generic support for MDIO-compatible transceivers
+ * Copyright 2006-2009 Solarflare Communications Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 as published
+ * by the Free Software Foundation, incorporated herein by reference.
+ */
+
+#include "kernel_compat.h"
+
+#if defined(CONFIG_SFC_PRIVATE_MDIO) || (!defined(CONFIG_MDIO) && !defined(CONFIG_MDIO_MODULE))
+
+#include <linux/kernel.h>
+#include <linux/capability.h>
+#include <linux/errno.h>
+#include <linux/ethtool.h>
+#include "linux_mdio.h"
+#include <linux/module.h>
+
+/**
+ * mdio45_probe - probe for an MDIO (clause 45) device
+ * @mdio: MDIO interface
+ * @prtad: Expected PHY address
+ *
+ * This sets @prtad and @mmds in the MDIO interface if successful.
+ * Returns 0 on success, negative on error.
+ */
+int mdio45_probe(struct mdio_if_info *mdio, int prtad)
+{
+	int mmd, stat2, devs1, devs2;
+
+	/* Assume PHY must have at least one of PMA/PMD, WIS, PCS, PHY
+	 * XS or DTE XS; give up if none is present. */
+	for (mmd = 1; mmd <= 5; mmd++) {
+		/* Is this MMD present? */
+		stat2 = mdio->mdio_read(mdio->dev, prtad, mmd, MDIO_STAT2);
+		if (stat2 < 0 ||
+		    (stat2 & MDIO_STAT2_DEVPRST) != MDIO_STAT2_DEVPRST_VAL)
+			continue;
+
+		/* It should tell us about all the other MMDs */
+		devs1 = mdio->mdio_read(mdio->dev, prtad, mmd, MDIO_DEVS1);
+		devs2 = mdio->mdio_read(mdio->dev, prtad, mmd, MDIO_DEVS2);
+		if (devs1 < 0 || devs2 < 0)
+			continue;
+
+		mdio->prtad = prtad;
+		mdio->mmds = devs1 | (devs2 << 16);
+		return 0;
+	}
+
+	return -ENODEV;
+}
+/*EXPORT_SYMBOL(mdio45_probe);*/
+
+/**
+ * mdio_set_flag - set or clear flag in an MDIO register
+ * @mdio: MDIO interface
+ * @prtad: PHY address
+ * @devad: MMD address
+ * @addr: Register address
+ * @mask: Mask for flag (single bit set)
+ * @sense: New value of flag
+ *
+ * This debounces changes: it does not write the register if the flag
+ * already has the proper value.  Returns 0 on success, negative on error.
+ */
+int mdio_set_flag(const struct mdio_if_info *mdio,
+		  int prtad, int devad, u16 addr, int mask,
+		  bool sense)
+{
+	int old_val = mdio->mdio_read(mdio->dev, prtad, devad, addr);
+	int new_val;
+
+	if (old_val < 0)
+		return old_val;
+	if (sense)
+		new_val = old_val | mask;
+	else
+		new_val = old_val & ~mask;
+	if (old_val == new_val)
+		return 0;
+	return mdio->mdio_write(mdio->dev, prtad, devad, addr, new_val);
+}
+/*EXPORT_SYMBOL(mdio_set_flag);*/
+
+/**
+ * mdio_link_ok - is link status up/OK
+ * @mdio: MDIO interface
+ * @mmd_mask: Mask for MMDs to check
+ *
+ * Returns 1 if the PHY reports link status up/OK, 0 otherwise.
+ * @mmd_mask is normally @mdio->mmds, but if loopback is enabled
+ * the MMDs being bypassed should be excluded from the mask.
+ */
+int mdio45_links_ok(const struct mdio_if_info *mdio, u32 mmd_mask)
+{
+	int devad, reg;
+
+	if (!mmd_mask) {
+		/* Use absence of XGMII faults in lieu of link state */
+		reg = mdio->mdio_read(mdio->dev, mdio->prtad,
+				      MDIO_MMD_PHYXS, MDIO_STAT2);
+		return reg >= 0 && !(reg & MDIO_STAT2_RXFAULT);
+	}
+
+	for (devad = 0; mmd_mask; devad++) {
+		if (mmd_mask & (1 << devad)) {
+			mmd_mask &= ~(1 << devad);
+
+			/* Reset the latched status and fault flags */
+			mdio->mdio_read(mdio->dev, mdio->prtad,
+					devad, MDIO_STAT1);
+			if (devad == MDIO_MMD_PMAPMD || devad == MDIO_MMD_PCS ||
+			    devad == MDIO_MMD_PHYXS || devad == MDIO_MMD_DTEXS)
+				mdio->mdio_read(mdio->dev, mdio->prtad,
+						devad, MDIO_STAT2);
+
+			/* Check the current status and fault flags */
+			reg = mdio->mdio_read(mdio->dev, mdio->prtad,
+					      devad, MDIO_STAT1);
+			if (reg < 0 ||
+			    (reg & (MDIO_STAT1_FAULT | MDIO_STAT1_LSTATUS)) !=
+			    MDIO_STAT1_LSTATUS)
+				return false;
+		}
+	}
+
+	return true;
+}
+/*EXPORT_SYMBOL(mdio45_links_ok);*/
+
+/**
+ * mdio45_nway_restart - restart auto-negotiation for this interface
+ * @mdio: MDIO interface
+ *
+ * Returns 0 on success, negative on error.
+ */
+int mdio45_nway_restart(const struct mdio_if_info *mdio)
+{
+	if (!(mdio->mmds & MDIO_DEVS_AN))
+		return -EOPNOTSUPP;
+
+	mdio_set_flag(mdio, mdio->prtad, MDIO_MMD_AN, MDIO_CTRL1,
+		      MDIO_AN_CTRL1_RESTART, true);
+	return 0;
+}
+/*EXPORT_SYMBOL(mdio45_nway_restart);*/
+
+static u32 mdio45_get_an(const struct mdio_if_info *mdio, u16 addr)
+{
+	u32 result = 0;
+	int reg;
+
+	reg = mdio->mdio_read(mdio->dev, mdio->prtad, MDIO_MMD_AN, addr);
+	if (reg & ADVERTISE_10HALF)
+		result |= ADVERTISED_10baseT_Half;
+	if (reg & ADVERTISE_10FULL)
+		result |= ADVERTISED_10baseT_Full;
+	if (reg & ADVERTISE_100HALF)
+		result |= ADVERTISED_100baseT_Half;
+	if (reg & ADVERTISE_100FULL)
+		result |= ADVERTISED_100baseT_Full;
+	if (reg & ADVERTISE_PAUSE_CAP)
+		result |= ADVERTISED_Pause;
+	if (reg & ADVERTISE_PAUSE_ASYM)
+		result |= ADVERTISED_Asym_Pause;
+	return result;
+}
+
+/**
+ * mdio45_ethtool_gset_npage - get settings for ETHTOOL_GSET
+ * @mdio: MDIO interface
+ * @ecmd: Ethtool request structure
+ * @npage_adv: Modes currently advertised on next pages
+ * @npage_lpa: Modes advertised by link partner on next pages
+ *
+ * Since the CSRs for auto-negotiation using next pages are not fully
+ * standardised, this function does not attempt to decode them.  The
+ * caller must pass them in.
+ */
+void mdio45_ethtool_gset_npage(const struct mdio_if_info *mdio,
+			       struct ethtool_cmd *ecmd,
+			       u32 npage_adv, u32 npage_lpa)
+{
+	int reg;
+
+	ecmd->transceiver = XCVR_INTERNAL;
+	ecmd->phy_address = mdio->prtad;
+#ifdef EFX_USE_ETHTOOL_MDIO_SUPPORT
+	ecmd->mdio_support =
+		mdio->mode_support & (MDIO_SUPPORTS_C45 | MDIO_SUPPORTS_C22);
+#endif
+
+	reg = mdio->mdio_read(mdio->dev, mdio->prtad, MDIO_MMD_PMAPMD,
+			      MDIO_CTRL2);
+	switch (reg & MDIO_PMA_CTRL2_TYPE) {
+	case MDIO_PMA_CTRL2_10GBT:
+	case MDIO_PMA_CTRL2_1000BT:
+	case MDIO_PMA_CTRL2_100BTX:
+	case MDIO_PMA_CTRL2_10BT:
+		ecmd->port = PORT_TP;
+		ecmd->supported = SUPPORTED_TP;
+		reg = mdio->mdio_read(mdio->dev, mdio->prtad, MDIO_MMD_PMAPMD,
+				      MDIO_SPEED);
+		if (reg & MDIO_SPEED_10G)
+			ecmd->supported |= SUPPORTED_10000baseT_Full;
+		if (reg & MDIO_PMA_SPEED_1000)
+			ecmd->supported |= (SUPPORTED_1000baseT_Full |
+					    SUPPORTED_1000baseT_Half);
+		if (reg & MDIO_PMA_SPEED_100)
+			ecmd->supported |= (SUPPORTED_100baseT_Full |
+					    SUPPORTED_100baseT_Half);
+		if (reg & MDIO_PMA_SPEED_10)
+			ecmd->supported |= (SUPPORTED_10baseT_Full |
+					    SUPPORTED_10baseT_Half);
+		ecmd->advertising = ADVERTISED_TP;
+		break;
+
+	case MDIO_PMA_CTRL2_10GBCX4:
+		ecmd->port = PORT_OTHER;
+		ecmd->supported = 0;
+		ecmd->advertising = 0;
+		break;
+
+/*
+	case MDIO_PMA_CTRL2_10GBKX4:
+	case MDIO_PMA_CTRL2_10GBKR:
+	case MDIO_PMA_CTRL2_1000BKX:
+		ecmd->port = PORT_OTHER;
+		ecmd->supported = SUPPORTED_Backplane;
+		reg = mdio->mdio_read(mdio->dev, mdio->prtad, MDIO_MMD_PMAPMD,
+				      MDIO_PMA_EXTABLE);
+		if (reg & MDIO_PMA_EXTABLE_10GBKX4)
+			ecmd->supported |= SUPPORTED_10000baseKX4_Full;
+		if (reg & MDIO_PMA_EXTABLE_10GBKR)
+			ecmd->supported |= SUPPORTED_10000baseKR_Full;
+		if (reg & MDIO_PMA_EXTABLE_1000BKX)
+			ecmd->supported |= SUPPORTED_1000baseKX_Full;
+		reg = mdio->mdio_read(mdio->dev, mdio->prtad, MDIO_MMD_PMAPMD,
+				      MDIO_PMA_10GBR_FECABLE);
+		if (reg & MDIO_PMA_10GBR_FECABLE_ABLE)
+			ecmd->supported |= SUPPORTED_10000baseR_FEC;
+		ecmd->advertising = ADVERTISED_Backplane;
+		break;
+*/
+
+	/* All the other defined modes are flavours of optical */
+	default:
+		ecmd->port = PORT_FIBRE;
+		ecmd->supported = SUPPORTED_FIBRE;
+		ecmd->advertising = ADVERTISED_FIBRE;
+		break;
+	}
+
+	if (mdio->mmds & MDIO_DEVS_AN) {
+		ecmd->supported |= SUPPORTED_Autoneg;
+		reg = mdio->mdio_read(mdio->dev, mdio->prtad, MDIO_MMD_AN,
+				      MDIO_CTRL1);
+		if (reg & MDIO_AN_CTRL1_ENABLE) {
+			ecmd->autoneg = AUTONEG_ENABLE;
+			ecmd->advertising |=
+				ADVERTISED_Autoneg |
+				mdio45_get_an(mdio, MDIO_AN_ADVERTISE) |
+				npage_adv;
+		} else {
+			ecmd->autoneg = AUTONEG_DISABLE;
+		}
+	} else {
+		ecmd->autoneg = AUTONEG_DISABLE;
+	}
+
+	if (ecmd->autoneg) {
+		u32 modes = 0;
+		int an_stat = mdio->mdio_read(mdio->dev, mdio->prtad,
+					      MDIO_MMD_AN, MDIO_STAT1);
+
+		/* If AN is complete and successful, report best common
+		 * mode, otherwise report best advertised mode. */
+		if (an_stat & MDIO_AN_STAT1_COMPLETE) {
+			u32 lp_advertising;
+			lp_advertising =
+				mdio45_get_an(mdio, MDIO_AN_LPA) | npage_lpa;
+			if (an_stat & MDIO_AN_STAT1_LPABLE)
+				lp_advertising |= ADVERTISED_Autoneg;
+			modes = ecmd->advertising & lp_advertising;
+#ifdef EFX_USE_ETHTOOL_LP_ADVERTISING
+			ecmd->lp_advertising = lp_advertising;
+#endif
+		}
+		if ((modes & ~ADVERTISED_Autoneg) == 0)
+			modes = ecmd->advertising;
+
+		if (modes & (ADVERTISED_10000baseT_Full/* |
+			     ADVERTISED_10000baseKX4_Full |
+			     ADVERTISED_10000baseKR_Full*/)) {
+			ecmd->speed = SPEED_10000;
+			ecmd->duplex = DUPLEX_FULL;
+		} else if (modes & (ADVERTISED_1000baseT_Full |
+				    ADVERTISED_1000baseT_Half/* |
+				    ADVERTISED_1000baseKX_Full*/)) {
+			ecmd->speed = SPEED_1000;
+			ecmd->duplex = !(modes & ADVERTISED_1000baseT_Half);
+		} else if (modes & (ADVERTISED_100baseT_Full |
+				    ADVERTISED_100baseT_Half)) {
+			ecmd->speed = SPEED_100;
+			ecmd->duplex = !!(modes & ADVERTISED_100baseT_Full);
+		} else {
+			ecmd->speed = SPEED_10;
+			ecmd->duplex = !!(modes & ADVERTISED_10baseT_Full);
+		}
+	} else {
+		/* Report forced settings */
+		reg = mdio->mdio_read(mdio->dev, mdio->prtad, MDIO_MMD_PMAPMD,
+				      MDIO_CTRL1);
+		ecmd->speed = (((reg & MDIO_PMA_CTRL1_SPEED1000) ? 100 : 1) *
+			       ((reg & MDIO_PMA_CTRL1_SPEED100) ? 100 : 10));
+		ecmd->duplex = (reg & MDIO_CTRL1_FULLDPLX ||
+				ecmd->speed == SPEED_10000);
+	}
+
+#ifdef EFX_USE_ETHTOOL_ETH_TP_MDIX
+	/* 10GBASE-T MDI/MDI-X */
+	if (ecmd->port == PORT_TP && ecmd->speed == SPEED_10000) {
+		switch (mdio->mdio_read(mdio->dev, mdio->prtad, MDIO_MMD_PMAPMD,
+					MDIO_PMA_10GBT_SWAPPOL)) {
+		case MDIO_PMA_10GBT_SWAPPOL_ABNX | MDIO_PMA_10GBT_SWAPPOL_CDNX:
+			ecmd->eth_tp_mdix = ETH_TP_MDI;
+			break;
+		case 0:
+			ecmd->eth_tp_mdix = ETH_TP_MDI_X;
+			break;
+		default:
+			/* It's complicated... */
+			ecmd->eth_tp_mdix = ETH_TP_MDI_INVALID;
+			break;
+		}
+	}
+#endif
+}
+/*EXPORT_SYMBOL(mdio45_ethtool_gset_npage);*/
+
+/**
+ * mdio45_ethtool_spauseparam_an - set auto-negotiated pause parameters
+ * @mdio: MDIO interface
+ * @ecmd: Ethtool request structure
+ *
+ * This function assumes that the PHY has an auto-negotiation MMD.  It
+ * will enable and disable advertising of flow control as appropriate.
+ */
+void mdio45_ethtool_spauseparam_an(const struct mdio_if_info *mdio,
+				   const struct ethtool_pauseparam *ecmd)
+{
+	int adv, old_adv;
+
+	WARN_ON(!(mdio->mmds & MDIO_DEVS_AN));
+
+	old_adv = mdio->mdio_read(mdio->dev, mdio->prtad, MDIO_MMD_AN,
+				  MDIO_AN_ADVERTISE);
+	adv = ((old_adv & ~(ADVERTISE_PAUSE_CAP | ADVERTISE_PAUSE_ASYM)) |
+	       mii_advertise_flowctrl((ecmd->rx_pause ? FLOW_CTRL_RX : 0) |
+				      (ecmd->tx_pause ? FLOW_CTRL_TX : 0)));
+	if (adv != old_adv) {
+		mdio->mdio_write(mdio->dev, mdio->prtad, MDIO_MMD_AN,
+				 MDIO_AN_ADVERTISE, adv);
+		mdio45_nway_restart(mdio);
+	}
+}
+/*EXPORT_SYMBOL(mdio45_ethtool_spauseparam_an);*/
+
+/**
+ * mdio_mii_ioctl - MII ioctl interface for MDIO (clause 22 or 45) PHYs
+ * @mdio: MDIO interface
+ * @mii_data: MII ioctl data structure
+ * @cmd: MII ioctl command
+ *
+ * Returns 0 on success, negative on error.
+ */
+int mdio_mii_ioctl(const struct mdio_if_info *mdio,
+		   struct mii_ioctl_data *mii_data, int cmd)
+{
+	int prtad, devad;
+	u16 addr = mii_data->reg_num;
+
+	/* Validate/convert cmd to one of SIOC{G,S}MIIREG */
+	switch (cmd) {
+	case SIOCGMIIPHY:
+		if (mdio->prtad == MDIO_PRTAD_NONE)
+			return -EOPNOTSUPP;
+		mii_data->phy_id = mdio->prtad;
+		cmd = SIOCGMIIREG;
+		break;
+	case SIOCGMIIREG:
+	case SIOCSMIIREG:
+		break;
+	default:
+		return -EOPNOTSUPP;
+	}
+
+	/* Validate/convert phy_id */
+	if ((mdio->mode_support & MDIO_SUPPORTS_C45) &&
+	    mdio_phy_id_is_c45(mii_data->phy_id)) {
+		prtad = mdio_phy_id_prtad(mii_data->phy_id);
+		devad = mdio_phy_id_devad(mii_data->phy_id);
+	} else if ((mdio->mode_support & MDIO_SUPPORTS_C22) &&
+		   mii_data->phy_id < 0x20) {
+		prtad = mii_data->phy_id;
+		devad = MDIO_DEVAD_NONE;
+		addr &= 0x1f;
+	} else if ((mdio->mode_support & MDIO_EMULATE_C22) &&
+		   mdio->prtad != MDIO_PRTAD_NONE &&
+		   mii_data->phy_id == mdio->prtad) {
+		/* Remap commonly-used MII registers. */
+		prtad = mdio->prtad;
+		switch (addr) {
+		case MII_BMCR:
+		case MII_BMSR:
+		case MII_PHYSID1:
+		case MII_PHYSID2:
+			devad = __ffs(mdio->mmds);
+			break;
+		case MII_ADVERTISE:
+		case MII_LPA:
+			if (!(mdio->mmds & MDIO_DEVS_AN))
+				return -EINVAL;
+			devad = MDIO_MMD_AN;
+			if (addr == MII_ADVERTISE)
+				addr = MDIO_AN_ADVERTISE;
+			else
+				addr = MDIO_AN_LPA;
+			break;
+		default:
+			return -EINVAL;
+		}
+	} else {
+		return -EINVAL;
+	}
+
+	if (cmd == SIOCGMIIREG) {
+		int rc = mdio->mdio_read(mdio->dev, prtad, devad, addr);
+		if (rc < 0)
+			return rc;
+		mii_data->val_out = rc;
+		return 0;
+	} else {
+		return mdio->mdio_write(mdio->dev, prtad, devad, addr,
+					mii_data->val_in);
+	}
+}
+/*EXPORT_SYMBOL(mdio_mii_ioctl);*/
+
+#endif /* !CONFIG_MDIO && !CONFIG_MDIO_MODULE */
diff -r 5b3d4d3c1166 drivers/net/sfc/linux_mdio.h
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/drivers/net/sfc/linux_mdio.h	Tue Nov 09 10:06:27 2010 +0000
@@ -0,0 +1,356 @@
+/*
+ * linux/mdio.h: definitions for MDIO (clause 45) transceivers
+ * Copyright 2006-2009 Solarflare Communications Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 as published
+ * by the Free Software Foundation, incorporated herein by reference.
+ */
+
+#ifndef __LINUX_MDIO_H__
+#define __LINUX_MDIO_H__
+
+#include <linux/mii.h>
+
+/* MDIO Manageable Devices (MMDs). */
+#define MDIO_MMD_PMAPMD		1	/* Physical Medium Attachment/
+					 * Physical Medium Dependent */
+#define MDIO_MMD_WIS		2	/* WAN Interface Sublayer */
+#define MDIO_MMD_PCS		3	/* Physical Coding Sublayer */
+#define MDIO_MMD_PHYXS		4	/* PHY Extender Sublayer */
+#define MDIO_MMD_DTEXS		5	/* DTE Extender Sublayer */
+#define MDIO_MMD_TC		6	/* Transmission Convergence */
+#define MDIO_MMD_AN		7	/* Auto-Negotiation */
+#define MDIO_MMD_C22EXT		29	/* Clause 22 extension */
+#define MDIO_MMD_VEND1		30	/* Vendor specific 1 */
+#define MDIO_MMD_VEND2		31	/* Vendor specific 2 */
+
+/* Generic MDIO registers. */
+#define MDIO_CTRL1		MII_BMCR
+#define MDIO_STAT1		MII_BMSR
+#define MDIO_DEVID1		MII_PHYSID1
+#define MDIO_DEVID2		MII_PHYSID2
+#define MDIO_SPEED		4	/* Speed ability */
+#define MDIO_DEVS1		5	/* Devices in package */
+#define MDIO_DEVS2		6
+#define MDIO_CTRL2		7	/* 10G control 2 */
+#define MDIO_STAT2		8	/* 10G status 2 */
+#define MDIO_PMA_TXDIS		9	/* 10G PMA/PMD transmit disable */
+#define MDIO_PMA_RXDET		10	/* 10G PMA/PMD receive signal detect */
+#define MDIO_PMA_EXTABLE	11	/* 10G PMA/PMD extended ability */
+#define MDIO_PKGID1		14	/* Package identifier */
+#define MDIO_PKGID2		15
+#define MDIO_AN_ADVERTISE	16	/* AN advertising (base page) */
+#define MDIO_AN_LPA		19	/* AN LP abilities (base page) */
+#define MDIO_PHYXS_LNSTAT	24	/* PHY XGXS lane state */
+
+/* Media-dependent registers. */
+#define MDIO_PMA_10GBT_SWAPPOL	130	/* 10GBASE-T pair swap & polarity */
+#define MDIO_PMA_10GBT_TXPWR	131	/* 10GBASE-T TX power control */
+#define MDIO_PMA_10GBT_SNR	133	/* 10GBASE-T SNR margin, lane A.
+					 * Lanes B-D are numbered 134-136. */
+#define MDIO_PMA_10GBR_FECABLE	170	/* 10GBASE-R FEC ability */
+#define MDIO_PCS_10GBX_STAT1	24	/* 10GBASE-X PCS status 1 */
+#define MDIO_PCS_10GBRT_STAT1	32	/* 10GBASE-R/-T PCS status 1 */
+#define MDIO_PCS_10GBRT_STAT2	33	/* 10GBASE-R/-T PCS status 2 */
+#define MDIO_AN_10GBT_CTRL	32	/* 10GBASE-T auto-negotiation control */
+#define MDIO_AN_10GBT_STAT	33	/* 10GBASE-T auto-negotiation status */
+
+/* LASI (Link Alarm Status Interrupt) registers, defined by XENPAK MSA. */
+#define MDIO_PMA_LASI_RXCTRL	0x9000	/* RX_ALARM control */
+#define MDIO_PMA_LASI_TXCTRL	0x9001	/* TX_ALARM control */
+#define MDIO_PMA_LASI_CTRL	0x9002	/* LASI control */
+#define MDIO_PMA_LASI_RXSTAT	0x9003	/* RX_ALARM status */
+#define MDIO_PMA_LASI_TXSTAT	0x9004	/* TX_ALARM status */
+#define MDIO_PMA_LASI_STAT	0x9005	/* LASI status */
+
+/* Control register 1. */
+/* Enable extended speed selection */
+#define MDIO_CTRL1_SPEEDSELEXT		(BMCR_SPEED1000 | BMCR_SPEED100)
+/* All speed selection bits */
+#define MDIO_CTRL1_SPEEDSEL		(MDIO_CTRL1_SPEEDSELEXT | 0x003c)
+#define MDIO_CTRL1_FULLDPLX		BMCR_FULLDPLX
+#define MDIO_CTRL1_LPOWER		BMCR_PDOWN
+#define MDIO_CTRL1_RESET		BMCR_RESET
+#define MDIO_PMA_CTRL1_LOOPBACK		0x0001
+#define MDIO_PMA_CTRL1_SPEED1000	BMCR_SPEED1000
+#define MDIO_PMA_CTRL1_SPEED100		BMCR_SPEED100
+#define MDIO_PCS_CTRL1_LOOPBACK		BMCR_LOOPBACK
+#define MDIO_PHYXS_CTRL1_LOOPBACK	BMCR_LOOPBACK
+#define MDIO_AN_CTRL1_RESTART		BMCR_ANRESTART
+#define MDIO_AN_CTRL1_ENABLE		BMCR_ANENABLE
+#define MDIO_AN_CTRL1_XNP		0x2000	/* Enable extended next page */
+
+/* 10 Gb/s */
+#define MDIO_CTRL1_SPEED10G		(MDIO_CTRL1_SPEEDSELEXT | 0x00)
+/* 10PASS-TS/2BASE-TL */
+#define MDIO_CTRL1_SPEED10P2B		(MDIO_CTRL1_SPEEDSELEXT | 0x04)
+
+/* Status register 1. */
+#define MDIO_STAT1_LPOWERABLE		0x0002	/* Low-power ability */
+#define MDIO_STAT1_LSTATUS		BMSR_LSTATUS
+#define MDIO_STAT1_FAULT		0x0080	/* Fault */
+#define MDIO_AN_STAT1_LPABLE		0x0001	/* Link partner AN ability */
+#define MDIO_AN_STAT1_ABLE		BMSR_ANEGCAPABLE
+#define MDIO_AN_STAT1_RFAULT		BMSR_RFAULT
+#define MDIO_AN_STAT1_COMPLETE		BMSR_ANEGCOMPLETE
+#define MDIO_AN_STAT1_PAGE		0x0040	/* Page received */
+#define MDIO_AN_STAT1_XNP		0x0080	/* Extended next page status */
+
+/* Speed register. */
+#define MDIO_SPEED_10G			0x0001	/* 10G capable */
+#define MDIO_PMA_SPEED_2B		0x0002	/* 2BASE-TL capable */
+#define MDIO_PMA_SPEED_10P		0x0004	/* 10PASS-TS capable */
+#define MDIO_PMA_SPEED_1000		0x0010	/* 1000M capable */
+#define MDIO_PMA_SPEED_100		0x0020	/* 100M capable */
+#define MDIO_PMA_SPEED_10		0x0040	/* 10M capable */
+#define MDIO_PCS_SPEED_10P2B		0x0002	/* 10PASS-TS/2BASE-TL capable */
+
+/* Device present registers. */
+#define MDIO_DEVS_PRESENT(devad)	(1 << (devad))
+#define MDIO_DEVS_PMAPMD		MDIO_DEVS_PRESENT(MDIO_MMD_PMAPMD)
+#define MDIO_DEVS_WIS			MDIO_DEVS_PRESENT(MDIO_MMD_WIS)
+#define MDIO_DEVS_PCS			MDIO_DEVS_PRESENT(MDIO_MMD_PCS)
+#define MDIO_DEVS_PHYXS			MDIO_DEVS_PRESENT(MDIO_MMD_PHYXS)
+#define MDIO_DEVS_DTEXS			MDIO_DEVS_PRESENT(MDIO_MMD_DTEXS)
+#define MDIO_DEVS_TC			MDIO_DEVS_PRESENT(MDIO_MMD_TC)
+#define MDIO_DEVS_AN			MDIO_DEVS_PRESENT(MDIO_MMD_AN)
+#define MDIO_DEVS_C22EXT		MDIO_DEVS_PRESENT(MDIO_MMD_C22EXT)
+
+/* Control register 2. */
+#define MDIO_PMA_CTRL2_TYPE		0x000f	/* PMA/PMD type selection */
+#define MDIO_PMA_CTRL2_10GBCX4		0x0000	/* 10GBASE-CX4 type */
+#define MDIO_PMA_CTRL2_10GBEW		0x0001	/* 10GBASE-EW type */
+#define MDIO_PMA_CTRL2_10GBLW		0x0002	/* 10GBASE-LW type */
+#define MDIO_PMA_CTRL2_10GBSW		0x0003	/* 10GBASE-SW type */
+#define MDIO_PMA_CTRL2_10GBLX4		0x0004	/* 10GBASE-LX4 type */
+#define MDIO_PMA_CTRL2_10GBER		0x0005	/* 10GBASE-ER type */
+#define MDIO_PMA_CTRL2_10GBLR		0x0006	/* 10GBASE-LR type */
+#define MDIO_PMA_CTRL2_10GBSR		0x0007	/* 10GBASE-SR type */
+#define MDIO_PMA_CTRL2_10GBLRM		0x0008	/* 10GBASE-LRM type */
+#define MDIO_PMA_CTRL2_10GBT		0x0009	/* 10GBASE-T type */
+#define MDIO_PMA_CTRL2_10GBKX4		0x000a	/* 10GBASE-KX4 type */
+#define MDIO_PMA_CTRL2_10GBKR		0x000b	/* 10GBASE-KR type */
+#define MDIO_PMA_CTRL2_1000BT		0x000c	/* 1000BASE-T type */
+#define MDIO_PMA_CTRL2_1000BKX		0x000d	/* 1000BASE-KX type */
+#define MDIO_PMA_CTRL2_100BTX		0x000e	/* 100BASE-TX type */
+#define MDIO_PMA_CTRL2_10BT		0x000f	/* 10BASE-T type */
+#define MDIO_PCS_CTRL2_TYPE		0x0003	/* PCS type selection */
+#define MDIO_PCS_CTRL2_10GBR		0x0000	/* 10GBASE-R type */
+#define MDIO_PCS_CTRL2_10GBX		0x0001	/* 10GBASE-X type */
+#define MDIO_PCS_CTRL2_10GBW		0x0002	/* 10GBASE-W type */
+#define MDIO_PCS_CTRL2_10GBT		0x0003	/* 10GBASE-T type */
+
+/* Status register 2. */
+#define MDIO_STAT2_RXFAULT		0x0400	/* Receive fault */
+#define MDIO_STAT2_TXFAULT		0x0800	/* Transmit fault */
+#define MDIO_STAT2_DEVPRST		0xc000	/* Device present */
+#define MDIO_STAT2_DEVPRST_VAL		0x8000	/* Device present value */
+#define MDIO_PMA_STAT2_LBABLE		0x0001	/* PMA loopback ability */
+#define MDIO_PMA_STAT2_10GBEW		0x0002	/* 10GBASE-EW ability */
+#define MDIO_PMA_STAT2_10GBLW		0x0004	/* 10GBASE-LW ability */
+#define MDIO_PMA_STAT2_10GBSW		0x0008	/* 10GBASE-SW ability */
+#define MDIO_PMA_STAT2_10GBLX4		0x0010	/* 10GBASE-LX4 ability */
+#define MDIO_PMA_STAT2_10GBER		0x0020	/* 10GBASE-ER ability */
+#define MDIO_PMA_STAT2_10GBLR		0x0040	/* 10GBASE-LR ability */
+#define MDIO_PMA_STAT2_10GBSR		0x0080	/* 10GBASE-SR ability */
+#define MDIO_PMD_STAT2_TXDISAB		0x0100	/* PMD TX disable ability */
+#define MDIO_PMA_STAT2_EXTABLE		0x0200	/* Extended abilities */
+#define MDIO_PMA_STAT2_RXFLTABLE	0x1000	/* Receive fault ability */
+#define MDIO_PMA_STAT2_TXFLTABLE	0x2000	/* Transmit fault ability */
+#define MDIO_PCS_STAT2_10GBR		0x0001	/* 10GBASE-R capable */
+#define MDIO_PCS_STAT2_10GBX		0x0002	/* 10GBASE-X capable */
+#define MDIO_PCS_STAT2_10GBW		0x0004	/* 10GBASE-W capable */
+#define MDIO_PCS_STAT2_RXFLTABLE	0x1000	/* Receive fault ability */
+#define MDIO_PCS_STAT2_TXFLTABLE	0x2000	/* Transmit fault ability */
+
+/* Transmit disable register. */
+#define MDIO_PMD_TXDIS_GLOBAL		0x0001	/* Global PMD TX disable */
+#define MDIO_PMD_TXDIS_0		0x0002	/* PMD TX disable 0 */
+#define MDIO_PMD_TXDIS_1		0x0004	/* PMD TX disable 1 */
+#define MDIO_PMD_TXDIS_2		0x0008	/* PMD TX disable 2 */
+#define MDIO_PMD_TXDIS_3		0x0010	/* PMD TX disable 3 */
+
+/* Receive signal detect register. */
+#define MDIO_PMD_RXDET_GLOBAL		0x0001	/* Global PMD RX signal detect */
+#define MDIO_PMD_RXDET_0		0x0002	/* PMD RX signal detect 0 */
+#define MDIO_PMD_RXDET_1		0x0004	/* PMD RX signal detect 1 */
+#define MDIO_PMD_RXDET_2		0x0008	/* PMD RX signal detect 2 */
+#define MDIO_PMD_RXDET_3		0x0010	/* PMD RX signal detect 3 */
+
+/* Extended abilities register. */
+#define MDIO_PMA_EXTABLE_10GCX4		0x0001	/* 10GBASE-CX4 ability */
+#define MDIO_PMA_EXTABLE_10GBLRM	0x0002	/* 10GBASE-LRM ability */
+#define MDIO_PMA_EXTABLE_10GBT		0x0004	/* 10GBASE-T ability */
+#define MDIO_PMA_EXTABLE_10GBKX4	0x0008	/* 10GBASE-KX4 ability */
+#define MDIO_PMA_EXTABLE_10GBKR		0x0010	/* 10GBASE-KR ability */
+#define MDIO_PMA_EXTABLE_1000BT		0x0020	/* 1000BASE-T ability */
+#define MDIO_PMA_EXTABLE_1000BKX	0x0040	/* 1000BASE-KX ability */
+#define MDIO_PMA_EXTABLE_100BTX		0x0080	/* 100BASE-TX ability */
+#define MDIO_PMA_EXTABLE_10BT		0x0100	/* 10BASE-T ability */
+
+/* PHY XGXS lane state register. */
+#define MDIO_PHYXS_LNSTAT_SYNC0		0x0001
+#define MDIO_PHYXS_LNSTAT_SYNC1		0x0002
+#define MDIO_PHYXS_LNSTAT_SYNC2		0x0004
+#define MDIO_PHYXS_LNSTAT_SYNC3		0x0008
+#define MDIO_PHYXS_LNSTAT_ALIGN		0x1000
+
+/* PMA 10GBASE-T pair swap & polarity */
+#define MDIO_PMA_10GBT_SWAPPOL_ABNX	0x0001	/* Pair A/B uncrossed */
+#define MDIO_PMA_10GBT_SWAPPOL_CDNX	0x0002	/* Pair C/D uncrossed */
+#define MDIO_PMA_10GBT_SWAPPOL_AREV	0x0100	/* Pair A polarity reversed */
+#define MDIO_PMA_10GBT_SWAPPOL_BREV	0x0200	/* Pair B polarity reversed */
+#define MDIO_PMA_10GBT_SWAPPOL_CREV	0x0400	/* Pair C polarity reversed */
+#define MDIO_PMA_10GBT_SWAPPOL_DREV	0x0800	/* Pair D polarity reversed */
+
+/* PMA 10GBASE-T TX power register. */
+#define MDIO_PMA_10GBT_TXPWR_SHORT	0x0001	/* Short-reach mode */
+
+/* PMA 10GBASE-T SNR registers. */
+/* Value is SNR margin in dB, clamped to range [-127, 127], plus 0x8000. */
+#define MDIO_PMA_10GBT_SNR_BIAS		0x8000
+#define MDIO_PMA_10GBT_SNR_MAX		127
+
+/* PMA 10GBASE-R FEC ability register. */
+#define MDIO_PMA_10GBR_FECABLE_ABLE	0x0001	/* FEC ability */
+#define MDIO_PMA_10GBR_FECABLE_ERRABLE	0x0002	/* FEC error indic. ability */
+
+/* PCS 10GBASE-R/-T status register 1. */
+#define MDIO_PCS_10GBRT_STAT1_BLKLK	0x0001	/* Block lock attained */
+
+/* PCS 10GBASE-R/-T status register 2. */
+#define MDIO_PCS_10GBRT_STAT2_ERR	0x00ff
+#define MDIO_PCS_10GBRT_STAT2_BER	0x3f00
+
+/* AN 10GBASE-T control register. */
+#define MDIO_AN_10GBT_CTRL_ADV10G	0x1000	/* Advertise 10GBASE-T */
+
+/* AN 10GBASE-T status register. */
+#define MDIO_AN_10GBT_STAT_LPTRR	0x0200	/* LP training reset req. */
+#define MDIO_AN_10GBT_STAT_LPLTABLE	0x0400	/* LP loop timing ability */
+#define MDIO_AN_10GBT_STAT_LP10G	0x0800	/* LP is 10GBT capable */
+#define MDIO_AN_10GBT_STAT_REMOK	0x1000	/* Remote OK */
+#define MDIO_AN_10GBT_STAT_LOCOK	0x2000	/* Local OK */
+#define MDIO_AN_10GBT_STAT_MS		0x4000	/* Master/slave config */
+#define MDIO_AN_10GBT_STAT_MSFLT	0x8000	/* Master/slave config fault */
+
+/* LASI RX_ALARM control/status registers. */
+#define MDIO_PMA_LASI_RX_PHYXSLFLT	0x0001	/* PHY XS RX local fault */
+#define MDIO_PMA_LASI_RX_PCSLFLT	0x0008	/* PCS RX local fault */
+#define MDIO_PMA_LASI_RX_PMALFLT	0x0010	/* PMA/PMD RX local fault */
+#define MDIO_PMA_LASI_RX_OPTICPOWERFLT	0x0020	/* RX optical power fault */
+#define MDIO_PMA_LASI_RX_WISLFLT	0x0200	/* WIS local fault */
+
+/* LASI TX_ALARM control/status registers. */
+#define MDIO_PMA_LASI_TX_PHYXSLFLT	0x0001	/* PHY XS TX local fault */
+#define MDIO_PMA_LASI_TX_PCSLFLT	0x0008	/* PCS TX local fault */
+#define MDIO_PMA_LASI_TX_PMALFLT	0x0010	/* PMA/PMD TX local fault */
+#define MDIO_PMA_LASI_TX_LASERPOWERFLT	0x0080	/* Laser output power fault */
+#define MDIO_PMA_LASI_TX_LASERTEMPFLT	0x0100	/* Laser temperature fault */
+#define MDIO_PMA_LASI_TX_LASERBICURRFLT	0x0200	/* Laser bias current fault */
+
+/* LASI control/status registers. */
+#define MDIO_PMA_LASI_LSALARM		0x0001	/* LS_ALARM enable/status */
+#define MDIO_PMA_LASI_TXALARM		0x0002	/* TX_ALARM enable/status */
+#define MDIO_PMA_LASI_RXALARM		0x0004	/* RX_ALARM enable/status */
+
+/* Mapping between MDIO PRTAD/DEVAD and mii_ioctl_data::phy_id */
+
+#define MDIO_PHY_ID_C45			0x8000
+#define MDIO_PHY_ID_PRTAD		0x03e0
+#define MDIO_PHY_ID_DEVAD		0x001f
+#define MDIO_PHY_ID_C45_MASK						\
+	(MDIO_PHY_ID_C45 | MDIO_PHY_ID_PRTAD | MDIO_PHY_ID_DEVAD)
+
+static inline __u16 mdio_phy_id_c45(int prtad, int devad)
+{
+	return MDIO_PHY_ID_C45 | (prtad << 5) | devad;
+}
+
+static inline bool mdio_phy_id_is_c45(int phy_id)
+{
+	return (phy_id & MDIO_PHY_ID_C45) && !(phy_id & ~MDIO_PHY_ID_C45_MASK);
+}
+
+static inline __u16 mdio_phy_id_prtad(int phy_id)
+{
+	return (phy_id & MDIO_PHY_ID_PRTAD) >> 5;
+}
+
+static inline __u16 mdio_phy_id_devad(int phy_id)
+{
+	return phy_id & MDIO_PHY_ID_DEVAD;
+}
+
+#define MDIO_SUPPORTS_C22		1
+#define MDIO_SUPPORTS_C45		2
+
+#ifdef __KERNEL__ 
+
+/**
+ * struct mdio_if_info - Ethernet controller MDIO interface
+ * @prtad: PRTAD of the PHY (%MDIO_PRTAD_NONE if not present/unknown)
+ * @mmds: Mask of MMDs expected to be present in the PHY.  This must be
+ *	non-zero unless @prtad = %MDIO_PRTAD_NONE.
+ * @mode_support: MDIO modes supported.  If %MDIO_SUPPORTS_C22 is set then
+ *	MII register access will be passed through with @devad =
+ *	%MDIO_DEVAD_NONE.  If %MDIO_EMULATE_C22 is set then access to
+ *	commonly used clause 22 registers will be translated into
+ *	clause 45 registers.
+ * @dev: Net device structure
+ * @mdio_read: Register read function; returns value or negative error code
+ * @mdio_write: Register write function; returns 0 or negative error code
+ */
+struct mdio_if_info {
+	int prtad;
+	u32 mmds;
+	unsigned mode_support;
+
+	struct net_device *dev;
+	int (*mdio_read)(struct net_device *dev, int prtad, int devad,
+			 u16 addr);
+	int (*mdio_write)(struct net_device *dev, int prtad, int devad,
+			  u16 addr, u16 val);
+};
+
+#define MDIO_PRTAD_NONE			(-1)
+#define MDIO_DEVAD_NONE			(-1)
+#define MDIO_EMULATE_C22		4
+
+struct ethtool_cmd;
+struct ethtool_pauseparam;
+extern int mdio45_probe(struct mdio_if_info *mdio, int prtad);
+extern int mdio_set_flag(const struct mdio_if_info *mdio,
+			 int prtad, int devad, u16 addr, int mask,
+			 bool sense);
+extern int mdio45_links_ok(const struct mdio_if_info *mdio, u32 mmds);
+extern int mdio45_nway_restart(const struct mdio_if_info *mdio);
+extern void mdio45_ethtool_gset_npage(const struct mdio_if_info *mdio,
+				      struct ethtool_cmd *ecmd,
+				      u32 npage_adv, u32 npage_lpa);
+extern void
+mdio45_ethtool_spauseparam_an(const struct mdio_if_info *mdio,
+			      const struct ethtool_pauseparam *ecmd);
+
+/**
+ * mdio45_ethtool_gset - get settings for ETHTOOL_GSET
+ * @mdio: MDIO interface
+ * @ecmd: Ethtool request structure
+ *
+ * Since the CSRs for auto-negotiation using next pages are not fully
+ * standardised, this function does not attempt to decode them.  Use
+ * mdio45_ethtool_gset_npage() to specify advertisement bits from next
+ * pages.
+ */
+static inline void mdio45_ethtool_gset(const struct mdio_if_info *mdio,
+				       struct ethtool_cmd *ecmd)
+{
+	mdio45_ethtool_gset_npage(mdio, ecmd, 0, 0);
+}
+
+extern int mdio_mii_ioctl(const struct mdio_if_info *mdio,
+			  struct mii_ioctl_data *mii_data, int cmd);
+
+#endif /* __KERNEL__ */
+#endif /* __LINUX_MDIO_H__ */
diff -r 5b3d4d3c1166 drivers/net/sfc/lm87.c
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/drivers/net/sfc/lm87.c	Tue Nov 09 10:06:27 2010 +0000
@@ -0,0 +1,959 @@
+/*
+ * lm87.c
+ *
+ * Copyright (C) 2000       Frodo Looijaard <frodol@dds.nl>
+ *                          Philip Edelbrock <phil@netroedge.com>
+ *                          Stephen Rousset <stephen.rousset@rocketlogix.com>
+ *                          Dan Eaton <dan.eaton@rocketlogix.com>
+ * Copyright (C) 2004-2008  Jean Delvare <khali@linux-fr.org>
+ *
+ * Original port to Linux 2.6 by Jeff Oliver.
+ *
+ * The LM87 is a sensor chip made by National Semiconductor. It monitors up
+ * to 8 voltages (including its own power source), up to three temperatures
+ * (its own plus up to two external ones) and up to two fans. The default
+ * configuration is 6 voltages, two temperatures and two fans (see below).
+ * Voltages are scaled internally with ratios such that the nominal value of
+ * each voltage correspond to a register value of 192 (which means a
+ * resolution of about 0.5% of the nominal value). Temperature values are
+ * reported with a 1 deg resolution and a 3-4 deg accuracy. Complete
+ * datasheet can be obtained from National's website at:
+ *   http://www.national.com/pf/LM/LM87.html
+ *
+ * Some functions share pins, so not all functions are available at the same
+ * time. Which are depends on the hardware setup. This driver normally
+ * assumes that firmware configured the chip correctly. Where this is not
+ * the case, platform code must set the I2C client's platform_data to point
+ * to a u8 value to be written to the channel register.
+ * For reference, here is the list of exclusive functions:
+ *  - in0+in5 (default) or temp3
+ *  - fan1 (default) or in6
+ *  - fan2 (default) or in7
+ *  - VID lines (default) or IRQ lines (not handled by this driver)
+ *
+ * The LM87 additionally features an analog output, supposedly usable to
+ * control the speed of a fan. All new chips use pulse width modulation
+ * instead. The LM87 is the only hardware monitoring chipset I know of
+ * which uses amplitude modulation. Be careful when using this feature.
+ *
+ * This driver also supports the ADM1024, a sensor chip made by Analog
+ * Devices. That chip is fully compatible with the LM87. Complete
+ * datasheet can be obtained from Analog's website at:
+ *   http://www.analog.com/en/prod/0,2877,ADM1024,00.html
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/slab.h>
+#include <linux/jiffies.h>
+#include <linux/i2c.h>
+#include <linux/err.h>
+
+#include "kernel_compat.h"
+#ifdef EFX_HAVE_HWMON_H
+#include <linux/hwmon.h>
+#endif
+#ifdef EFX_HAVE_I2C_SENSOR_H
+#include <linux/i2c-sensor.h>
+#endif
+#ifndef EFX_HAVE_OLD_DEVICE_ATTRIBUTE
+#include <linux/hwmon-sysfs.h>
+#endif
+#ifndef EFX_NEED_HWMON_VID
+#include <linux/hwmon-vid.h>
+#endif
+
+#ifdef EFX_NEED_LM87_DRIVER
+
+/*
+ * The LM87 registers
+ */
+
+/* nr in 0..5 */
+#define LM87_REG_IN(nr)			(0x20 + (nr))
+#define LM87_REG_IN_MAX(nr)		(0x2B + (nr) * 2)
+#define LM87_REG_IN_MIN(nr)		(0x2C + (nr) * 2)
+/* nr in 0..1 */
+#define LM87_REG_AIN(nr)		(0x28 + (nr))
+#define LM87_REG_AIN_MIN(nr)		(0x1A + (nr))
+#define LM87_REG_AIN_MAX(nr)		(0x3B + (nr))
+
+static u8 LM87_REG_TEMP[3] = { 0x27, 0x26, 0x20 };
+static u8 LM87_REG_TEMP_HIGH[3] = { 0x39, 0x37, 0x2B };
+static u8 LM87_REG_TEMP_LOW[3] = { 0x3A, 0x38, 0x2C };
+
+#define LM87_REG_TEMP_HW_INT_LOCK	0x13
+#define LM87_REG_TEMP_HW_EXT_LOCK	0x14
+#define LM87_REG_TEMP_HW_INT		0x17
+#define LM87_REG_TEMP_HW_EXT		0x18
+
+/* nr in 0..1 */
+#define LM87_REG_FAN(nr)		(0x28 + (nr))
+#define LM87_REG_FAN_MIN(nr)		(0x3B + (nr))
+#define LM87_REG_AOUT			0x19
+
+#define LM87_REG_CONFIG			0x40
+#define LM87_REG_CHANNEL_MODE		0x16
+#define LM87_REG_VID_FAN_DIV		0x47
+#define LM87_REG_VID4			0x49
+
+#define LM87_REG_ALARMS1		0x41
+#define LM87_REG_ALARMS2		0x42
+
+#define LM87_REG_COMPANY_ID		0x3E
+#define LM87_REG_REVISION		0x3F
+
+/*
+ * Conversions and various macros
+ * The LM87 uses signed 8-bit values for temperatures.
+ */
+
+#define IN_FROM_REG(reg,scale)	(((reg) * (scale) + 96) / 192)
+#define IN_TO_REG(val,scale)	((val) <= 0 ? 0 : \
+				 (val) * 192 >= (scale) * 255 ? 255 : \
+				 ((val) * 192 + (scale)/2) / (scale))
+
+#define TEMP_FROM_REG(reg)	((reg) * 1000)
+#define TEMP_TO_REG(val)	((val) <= -127500 ? -128 : \
+				 (val) >= 126500 ? 127 : \
+				 (((val) < 0 ? (val)-500 : (val)+500) / 1000))
+
+#define FAN_FROM_REG(reg,div)	((reg) == 255 || (reg) == 0 ? 0 : \
+				 (1350000 + (reg)*(div) / 2) / ((reg)*(div)))
+#define FAN_TO_REG(val,div)	((val)*(div) * 255 <= 1350000 ? 255 : \
+				 (1350000 + (val)*(div) / 2) / ((val)*(div)))
+
+#define FAN_DIV_FROM_REG(reg)	(1 << (reg))
+
+/* analog out is 9.80mV/LSB */
+#define AOUT_FROM_REG(reg)	(((reg) * 98 + 5) / 10)
+#define AOUT_TO_REG(val)	((val) <= 0 ? 0 : \
+				 (val) >= 2500 ? 255 : \
+				 ((val) * 10 + 49) / 98)
+
+/* nr in 0..1 */
+#define CHAN_NO_FAN(nr)		(1 << (nr))
+#define CHAN_TEMP3		(1 << 2)
+#define CHAN_VCC_5V		(1 << 3)
+#define CHAN_NO_VID		(1 << 7)
+
+/*
+ * Functions declaration
+ */
+
+static void lm87_init_client(struct i2c_client *client);
+static int lm87_remove(struct i2c_client *client);
+static struct lm87_data *lm87_update_device(struct device *dev);
+#ifdef EFX_USE_I2C_LEGACY
+static int lm87_detach_client(struct i2c_client *client);
+#endif
+
+/*
+ * Driver data (common to all clients)
+ */
+
+#if !defined(EFX_USE_I2C_LEGACY) && !defined(EFX_HAVE_OLD_I2C_DRIVER_PROBE)
+static const struct i2c_device_id lm87_id[] = {
+	{ "sfc_lm87" },
+	{ }
+};
+#endif
+
+struct i2c_driver efx_lm87_driver = {
+#ifdef EFX_USE_I2C_DRIVER_NAME
+	.name		= "sfc_lm87",
+#else
+	.driver.name	= "sfc_lm87",
+#endif
+#ifdef EFX_USE_I2C_LEGACY
+	.detach_client	= lm87_detach_client,
+#else
+	.probe		= efx_lm87_probe,
+	.remove		= lm87_remove,
+#ifndef EFX_HAVE_OLD_I2C_DRIVER_PROBE
+	.id_table	= lm87_id,
+#endif
+#endif
+};
+
+/*
+ * Client data (each client gets its own)
+ */
+
+struct lm87_data {
+#ifdef EFX_HAVE_HWMON_CLASS_DEVICE
+	struct class_device *hwmon_dev;
+#else
+	struct device *hwmon_dev;
+#endif
+	struct mutex update_lock;
+	char valid; /* zero until following fields are valid */
+	unsigned long last_updated; /* In jiffies */
+
+	u8 channel;		/* register value */
+	u8 config;		/* original register value */
+
+	u8 in[8];		/* register value */
+	u8 in_max[8];		/* register value */
+	u8 in_min[8];		/* register value */
+	u16 in_scale[8];
+
+	s8 temp[3];		/* register value */
+	s8 temp_high[3];	/* register value */
+	s8 temp_low[3];		/* register value */
+	s8 temp_crit_int;	/* min of two register values */
+	s8 temp_crit_ext;	/* min of two register values */
+
+	u8 fan[2];		/* register value */
+	u8 fan_min[2];		/* register value */
+	u8 fan_div[2];		/* register value, shifted right */
+	u8 aout;		/* register value */
+
+	u16 alarms;		/* register values, combined */
+	u8 vid;			/* register values, combined */
+	u8 vrm;
+};
+
+/*
+ * Sysfs stuff
+ */
+
+static inline int lm87_read_value(struct i2c_client *client, u8 reg)
+{
+	return i2c_smbus_read_byte_data(client, reg);
+}
+
+static inline int lm87_write_value(struct i2c_client *client, u8 reg, u8 value)
+{
+	return i2c_smbus_write_byte_data(client, reg, value);
+}
+
+#define show_in(offset) \
+static ssize_t show_in##offset##_input(struct device *dev, struct device_attribute *attr, char *buf) \
+{ \
+	struct lm87_data *data = lm87_update_device(dev); \
+	return sprintf(buf, "%u\n", IN_FROM_REG(data->in[offset], \
+		       data->in_scale[offset])); \
+} \
+static ssize_t show_in##offset##_min(struct device *dev, struct device_attribute *attr, char *buf) \
+{ \
+	struct lm87_data *data = lm87_update_device(dev); \
+	return sprintf(buf, "%u\n", IN_FROM_REG(data->in_min[offset], \
+		       data->in_scale[offset])); \
+} \
+static ssize_t show_in##offset##_max(struct device *dev, struct device_attribute *attr, char *buf) \
+{ \
+	struct lm87_data *data = lm87_update_device(dev); \
+	return sprintf(buf, "%u\n", IN_FROM_REG(data->in_max[offset], \
+		       data->in_scale[offset])); \
+} \
+static DEVICE_ATTR(in##offset##_input, S_IRUGO, \
+		show_in##offset##_input, NULL);
+show_in(0);
+show_in(1);
+show_in(2);
+show_in(3);
+show_in(4);
+show_in(5);
+show_in(6);
+show_in(7);
+
+static void set_in_min(struct device *dev, const char *buf, int nr)
+{
+	struct i2c_client *client = to_i2c_client(dev);
+	struct lm87_data *data = i2c_get_clientdata(client);
+	long val = simple_strtol(buf, NULL, 10);
+
+	mutex_lock(&data->update_lock);
+	data->in_min[nr] = IN_TO_REG(val, data->in_scale[nr]);
+	lm87_write_value(client, nr<6 ? LM87_REG_IN_MIN(nr) :
+			 LM87_REG_AIN_MIN(nr-6), data->in_min[nr]);
+	mutex_unlock(&data->update_lock);
+}
+
+static void set_in_max(struct device *dev, const char *buf, int nr)
+{
+	struct i2c_client *client = to_i2c_client(dev);
+	struct lm87_data *data = i2c_get_clientdata(client);
+	long val = simple_strtol(buf, NULL, 10);
+
+	mutex_lock(&data->update_lock);
+	data->in_max[nr] = IN_TO_REG(val, data->in_scale[nr]);
+	lm87_write_value(client, nr<6 ? LM87_REG_IN_MAX(nr) :
+			 LM87_REG_AIN_MAX(nr-6), data->in_max[nr]);
+	mutex_unlock(&data->update_lock);
+}
+
+#define set_in(offset) \
+static ssize_t set_in##offset##_min(struct device *dev, struct device_attribute *attr, \
+		const char *buf, size_t count) \
+{ \
+	set_in_min(dev, buf, offset); \
+	return count; \
+} \
+static ssize_t set_in##offset##_max(struct device *dev, struct device_attribute *attr, \
+		const char *buf, size_t count) \
+{ \
+	set_in_max(dev, buf, offset); \
+	return count; \
+} \
+static DEVICE_ATTR(in##offset##_min, S_IRUGO | S_IWUSR, \
+		show_in##offset##_min, set_in##offset##_min); \
+static DEVICE_ATTR(in##offset##_max, S_IRUGO | S_IWUSR, \
+		show_in##offset##_max, set_in##offset##_max);
+set_in(0);
+set_in(1);
+set_in(2);
+set_in(3);
+set_in(4);
+set_in(5);
+set_in(6);
+set_in(7);
+
+#define show_temp(offset) \
+static ssize_t show_temp##offset##_input(struct device *dev, struct device_attribute *attr, char *buf) \
+{ \
+	struct lm87_data *data = lm87_update_device(dev); \
+	return sprintf(buf, "%d\n", TEMP_FROM_REG(data->temp[offset-1])); \
+} \
+static ssize_t show_temp##offset##_low(struct device *dev, struct device_attribute *attr, char *buf) \
+{ \
+	struct lm87_data *data = lm87_update_device(dev); \
+	return sprintf(buf, "%d\n", TEMP_FROM_REG(data->temp_low[offset-1])); \
+} \
+static ssize_t show_temp##offset##_high(struct device *dev, struct device_attribute *attr, char *buf) \
+{ \
+	struct lm87_data *data = lm87_update_device(dev); \
+	return sprintf(buf, "%d\n", TEMP_FROM_REG(data->temp_high[offset-1])); \
+}\
+static DEVICE_ATTR(temp##offset##_input, S_IRUGO, \
+		show_temp##offset##_input, NULL);
+show_temp(1);
+show_temp(2);
+show_temp(3);
+
+static void set_temp_low(struct device *dev, const char *buf, int nr)
+{
+	struct i2c_client *client = to_i2c_client(dev);
+	struct lm87_data *data = i2c_get_clientdata(client);
+	long val = simple_strtol(buf, NULL, 10);
+
+	mutex_lock(&data->update_lock);
+	data->temp_low[nr] = TEMP_TO_REG(val);
+	lm87_write_value(client, LM87_REG_TEMP_LOW[nr], data->temp_low[nr]);
+	mutex_unlock(&data->update_lock);
+}
+
+static void set_temp_high(struct device *dev, const char *buf, int nr)
+{
+	struct i2c_client *client = to_i2c_client(dev);
+	struct lm87_data *data = i2c_get_clientdata(client);
+	long val = simple_strtol(buf, NULL, 10);
+
+	mutex_lock(&data->update_lock);
+	data->temp_high[nr] = TEMP_TO_REG(val);
+	lm87_write_value(client, LM87_REG_TEMP_HIGH[nr], data->temp_high[nr]);
+	mutex_unlock(&data->update_lock);
+}
+
+#define set_temp(offset) \
+static ssize_t set_temp##offset##_low(struct device *dev, struct device_attribute *attr, \
+		const char *buf, size_t count) \
+{ \
+	set_temp_low(dev, buf, offset-1); \
+	return count; \
+} \
+static ssize_t set_temp##offset##_high(struct device *dev, struct device_attribute *attr, \
+		const char *buf, size_t count) \
+{ \
+	set_temp_high(dev, buf, offset-1); \
+	return count; \
+} \
+static DEVICE_ATTR(temp##offset##_max, S_IRUGO | S_IWUSR, \
+		show_temp##offset##_high, set_temp##offset##_high); \
+static DEVICE_ATTR(temp##offset##_min, S_IRUGO | S_IWUSR, \
+		show_temp##offset##_low, set_temp##offset##_low);
+set_temp(1);
+set_temp(2);
+set_temp(3);
+
+static ssize_t show_temp_crit_int(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	struct lm87_data *data = lm87_update_device(dev);
+	return sprintf(buf, "%d\n", TEMP_FROM_REG(data->temp_crit_int));
+}
+
+static ssize_t show_temp_crit_ext(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	struct lm87_data *data = lm87_update_device(dev);
+	return sprintf(buf, "%d\n", TEMP_FROM_REG(data->temp_crit_ext));
+}
+
+static DEVICE_ATTR(temp1_crit, S_IRUGO, show_temp_crit_int, NULL);
+static DEVICE_ATTR(temp2_crit, S_IRUGO, show_temp_crit_ext, NULL);
+static DEVICE_ATTR(temp3_crit, S_IRUGO, show_temp_crit_ext, NULL);
+
+#define show_fan(offset) \
+static ssize_t show_fan##offset##_input(struct device *dev, struct device_attribute *attr, char *buf) \
+{ \
+	struct lm87_data *data = lm87_update_device(dev); \
+	return sprintf(buf, "%d\n", FAN_FROM_REG(data->fan[offset-1], \
+		       FAN_DIV_FROM_REG(data->fan_div[offset-1]))); \
+} \
+static ssize_t show_fan##offset##_min(struct device *dev, struct device_attribute *attr, char *buf) \
+{ \
+	struct lm87_data *data = lm87_update_device(dev); \
+	return sprintf(buf, "%d\n", FAN_FROM_REG(data->fan_min[offset-1], \
+		       FAN_DIV_FROM_REG(data->fan_div[offset-1]))); \
+} \
+static ssize_t show_fan##offset##_div(struct device *dev, struct device_attribute *attr, char *buf) \
+{ \
+	struct lm87_data *data = lm87_update_device(dev); \
+	return sprintf(buf, "%d\n", FAN_DIV_FROM_REG(data->fan_div[offset-1])); \
+} \
+static DEVICE_ATTR(fan##offset##_input, S_IRUGO, \
+		show_fan##offset##_input, NULL);
+show_fan(1);
+show_fan(2);
+
+static void set_fan_min(struct device *dev, const char *buf, int nr)
+{
+	struct i2c_client *client = to_i2c_client(dev);
+	struct lm87_data *data = i2c_get_clientdata(client);
+	long val = simple_strtol(buf, NULL, 10);
+
+	mutex_lock(&data->update_lock);
+	data->fan_min[nr] = FAN_TO_REG(val,
+			    FAN_DIV_FROM_REG(data->fan_div[nr]));
+	lm87_write_value(client, LM87_REG_FAN_MIN(nr), data->fan_min[nr]);
+	mutex_unlock(&data->update_lock);
+}
+
+/* Note: we save and restore the fan minimum here, because its value is
+   determined in part by the fan clock divider.  This follows the principle
+   of least surprise; the user doesn't expect the fan minimum to change just
+   because the divider changed. */
+static ssize_t set_fan_div(struct device *dev, const char *buf,
+		size_t count, int nr)
+{
+	struct i2c_client *client = to_i2c_client(dev);
+	struct lm87_data *data = i2c_get_clientdata(client);
+	long val = simple_strtol(buf, NULL, 10);
+	unsigned long min;
+	u8 reg;
+
+	mutex_lock(&data->update_lock);
+	min = FAN_FROM_REG(data->fan_min[nr],
+			   FAN_DIV_FROM_REG(data->fan_div[nr]));
+
+	switch (val) {
+	case 1: data->fan_div[nr] = 0; break;
+	case 2: data->fan_div[nr] = 1; break;
+	case 4: data->fan_div[nr] = 2; break;
+	case 8: data->fan_div[nr] = 3; break;
+	default:
+		mutex_unlock(&data->update_lock);
+		return -EINVAL;
+	}
+
+	reg = lm87_read_value(client, LM87_REG_VID_FAN_DIV);
+	switch (nr) {
+	case 0:
+	    reg = (reg & 0xCF) | (data->fan_div[0] << 4);
+	    break;
+	case 1:
+	    reg = (reg & 0x3F) | (data->fan_div[1] << 6);
+	    break;
+	}
+	lm87_write_value(client, LM87_REG_VID_FAN_DIV, reg);
+
+	data->fan_min[nr] = FAN_TO_REG(min, val);
+	lm87_write_value(client, LM87_REG_FAN_MIN(nr),
+			 data->fan_min[nr]);
+	mutex_unlock(&data->update_lock);
+
+	return count;
+}
+
+#define set_fan(offset) \
+static ssize_t set_fan##offset##_min(struct device *dev, struct device_attribute *attr, const char *buf, \
+		size_t count) \
+{ \
+	set_fan_min(dev, buf, offset-1); \
+	return count; \
+} \
+static ssize_t set_fan##offset##_div(struct device *dev, struct device_attribute *attr, const char *buf, \
+		size_t count) \
+{ \
+	return set_fan_div(dev, buf, count, offset-1); \
+} \
+static DEVICE_ATTR(fan##offset##_min, S_IRUGO | S_IWUSR, \
+		show_fan##offset##_min, set_fan##offset##_min); \
+static DEVICE_ATTR(fan##offset##_div, S_IRUGO | S_IWUSR, \
+		show_fan##offset##_div, set_fan##offset##_div);
+set_fan(1);
+set_fan(2);
+
+static ssize_t show_alarms(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	struct lm87_data *data = lm87_update_device(dev);
+	return sprintf(buf, "%d\n", data->alarms);
+}
+static DEVICE_ATTR(alarms, S_IRUGO, show_alarms, NULL);
+
+static ssize_t show_vid(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	struct lm87_data *data = lm87_update_device(dev);
+	return sprintf(buf, "%d\n", vid_from_reg(data->vid, data->vrm));
+}
+static DEVICE_ATTR(cpu0_vid, S_IRUGO, show_vid, NULL);
+
+static ssize_t show_vrm(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	struct lm87_data *data = dev_get_drvdata(dev);
+	return sprintf(buf, "%d\n", data->vrm);
+}
+static ssize_t set_vrm(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
+{
+	struct lm87_data *data = dev_get_drvdata(dev);
+	data->vrm = simple_strtoul(buf, NULL, 10);
+	return count;
+}
+static DEVICE_ATTR(vrm, S_IRUGO | S_IWUSR, show_vrm, set_vrm);
+
+static ssize_t show_aout(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	struct lm87_data *data = lm87_update_device(dev);
+	return sprintf(buf, "%d\n", AOUT_FROM_REG(data->aout));
+}
+static ssize_t set_aout(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
+{
+	struct i2c_client *client = to_i2c_client(dev);
+	struct lm87_data *data = i2c_get_clientdata(client);
+	long val = simple_strtol(buf, NULL, 10);
+
+	mutex_lock(&data->update_lock);
+	data->aout = AOUT_TO_REG(val);
+	lm87_write_value(client, LM87_REG_AOUT, data->aout);
+	mutex_unlock(&data->update_lock);
+	return count;
+}
+static DEVICE_ATTR(aout_output, S_IRUGO | S_IWUSR, show_aout, set_aout);
+
+static ssize_t show_alarm(struct device *dev, struct device_attribute *attr,
+			  char *buf)
+{
+	struct lm87_data *data = lm87_update_device(dev);
+	int bitnr = to_sensor_dev_attr(attr)->index;
+	return sprintf(buf, "%u\n", (data->alarms >> bitnr) & 1);
+}
+static SENSOR_DEVICE_ATTR(in0_alarm, S_IRUGO, show_alarm, NULL, 0);
+static SENSOR_DEVICE_ATTR(in1_alarm, S_IRUGO, show_alarm, NULL, 1);
+static SENSOR_DEVICE_ATTR(in2_alarm, S_IRUGO, show_alarm, NULL, 2);
+static SENSOR_DEVICE_ATTR(in3_alarm, S_IRUGO, show_alarm, NULL, 3);
+static SENSOR_DEVICE_ATTR(in4_alarm, S_IRUGO, show_alarm, NULL, 8);
+static SENSOR_DEVICE_ATTR(in5_alarm, S_IRUGO, show_alarm, NULL, 9);
+static SENSOR_DEVICE_ATTR(in6_alarm, S_IRUGO, show_alarm, NULL, 6);
+static SENSOR_DEVICE_ATTR(in7_alarm, S_IRUGO, show_alarm, NULL, 7);
+static SENSOR_DEVICE_ATTR(temp1_alarm, S_IRUGO, show_alarm, NULL, 4);
+static SENSOR_DEVICE_ATTR(temp2_alarm, S_IRUGO, show_alarm, NULL, 5);
+static SENSOR_DEVICE_ATTR(temp3_alarm, S_IRUGO, show_alarm, NULL, 5);
+static SENSOR_DEVICE_ATTR(fan1_alarm, S_IRUGO, show_alarm, NULL, 6);
+static SENSOR_DEVICE_ATTR(fan2_alarm, S_IRUGO, show_alarm, NULL, 7);
+static SENSOR_DEVICE_ATTR(temp2_fault, S_IRUGO, show_alarm, NULL, 14);
+static SENSOR_DEVICE_ATTR(temp3_fault, S_IRUGO, show_alarm, NULL, 15);
+
+/*
+ * Real code
+ */
+
+static struct attribute *lm87_attributes[] = {
+	&dev_attr_in1_input.attr,
+	&dev_attr_in1_min.attr,
+	&dev_attr_in1_max.attr,
+	&sensor_dev_attr_in1_alarm.dev_attr.attr,
+	&dev_attr_in2_input.attr,
+	&dev_attr_in2_min.attr,
+	&dev_attr_in2_max.attr,
+	&sensor_dev_attr_in2_alarm.dev_attr.attr,
+	&dev_attr_in3_input.attr,
+	&dev_attr_in3_min.attr,
+	&dev_attr_in3_max.attr,
+	&sensor_dev_attr_in3_alarm.dev_attr.attr,
+	&dev_attr_in4_input.attr,
+	&dev_attr_in4_min.attr,
+	&dev_attr_in4_max.attr,
+	&sensor_dev_attr_in4_alarm.dev_attr.attr,
+
+	&dev_attr_temp1_input.attr,
+	&dev_attr_temp1_max.attr,
+	&dev_attr_temp1_min.attr,
+	&dev_attr_temp1_crit.attr,
+	&sensor_dev_attr_temp1_alarm.dev_attr.attr,
+	&dev_attr_temp2_input.attr,
+	&dev_attr_temp2_max.attr,
+	&dev_attr_temp2_min.attr,
+	&dev_attr_temp2_crit.attr,
+	&sensor_dev_attr_temp2_alarm.dev_attr.attr,
+	&sensor_dev_attr_temp2_fault.dev_attr.attr,
+
+	&dev_attr_alarms.attr,
+	&dev_attr_aout_output.attr,
+
+	NULL
+};
+
+static const struct attribute_group lm87_group = {
+	.attrs = lm87_attributes,
+};
+
+static struct attribute *lm87_attributes_opt[] = {
+	&dev_attr_in6_input.attr,
+	&dev_attr_in6_min.attr,
+	&dev_attr_in6_max.attr,
+	&sensor_dev_attr_in6_alarm.dev_attr.attr,
+
+	&dev_attr_fan1_input.attr,
+	&dev_attr_fan1_min.attr,
+	&dev_attr_fan1_div.attr,
+	&sensor_dev_attr_fan1_alarm.dev_attr.attr,
+
+	&dev_attr_in7_input.attr,
+	&dev_attr_in7_min.attr,
+	&dev_attr_in7_max.attr,
+	&sensor_dev_attr_in7_alarm.dev_attr.attr,
+
+	&dev_attr_fan2_input.attr,
+	&dev_attr_fan2_min.attr,
+	&dev_attr_fan2_div.attr,
+	&sensor_dev_attr_fan2_alarm.dev_attr.attr,
+
+	&dev_attr_temp3_input.attr,
+	&dev_attr_temp3_max.attr,
+	&dev_attr_temp3_min.attr,
+	&dev_attr_temp3_crit.attr,
+	&sensor_dev_attr_temp3_alarm.dev_attr.attr,
+	&sensor_dev_attr_temp3_fault.dev_attr.attr,
+
+	&dev_attr_in0_input.attr,
+	&dev_attr_in0_min.attr,
+	&dev_attr_in0_max.attr,
+	&sensor_dev_attr_in0_alarm.dev_attr.attr,
+	&dev_attr_in5_input.attr,
+	&dev_attr_in5_min.attr,
+	&dev_attr_in5_max.attr,
+	&sensor_dev_attr_in5_alarm.dev_attr.attr,
+
+	&dev_attr_cpu0_vid.attr,
+	&dev_attr_vrm.attr,
+
+	NULL
+};
+
+static const struct attribute_group lm87_group_opt = {
+	.attrs = lm87_attributes_opt,
+};
+
+#ifdef EFX_HAVE_OLD_I2C_DRIVER_PROBE
+int efx_lm87_probe(struct i2c_client *new_client)
+#else
+int efx_lm87_probe(struct i2c_client *new_client,
+		   const struct i2c_device_id *id)
+#endif
+{
+	struct lm87_data *data;
+	int err;
+
+	data = kzalloc(sizeof(struct lm87_data), GFP_KERNEL);
+	if (!data) {
+		err = -ENOMEM;
+		goto exit;
+	}
+
+	i2c_set_clientdata(new_client, data);
+	data->valid = 0;
+	mutex_init(&data->update_lock);
+
+	/* Initialize the LM87 chip */
+	lm87_init_client(new_client);
+
+	data->in_scale[0] = 2500;
+	data->in_scale[1] = 2700;
+	data->in_scale[2] = (data->channel & CHAN_VCC_5V) ? 5000 : 3300;
+	data->in_scale[3] = 5000;
+	data->in_scale[4] = 12000;
+	data->in_scale[5] = 2700;
+	data->in_scale[6] = 1875;
+	data->in_scale[7] = 1875;
+
+	/* Register sysfs hooks */
+	if ((err = sysfs_create_group(&new_client->dev.kobj, &lm87_group)))
+		goto exit_free;
+
+	if (data->channel & CHAN_NO_FAN(0)) {
+		if ((err = device_create_file(&new_client->dev,
+					&dev_attr_in6_input))
+		 || (err = device_create_file(&new_client->dev,
+					&dev_attr_in6_min))
+		 || (err = device_create_file(&new_client->dev,
+					&dev_attr_in6_max))
+		 || (err = device_create_file(&new_client->dev,
+					&sensor_dev_attr_in6_alarm.dev_attr)))
+			goto exit_remove;
+	} else {
+		if ((err = device_create_file(&new_client->dev,
+					&dev_attr_fan1_input))
+		 || (err = device_create_file(&new_client->dev,
+					&dev_attr_fan1_min))
+		 || (err = device_create_file(&new_client->dev,
+					&dev_attr_fan1_div))
+		 || (err = device_create_file(&new_client->dev,
+					&sensor_dev_attr_fan1_alarm.dev_attr)))
+			goto exit_remove;
+	}
+
+	if (data->channel & CHAN_NO_FAN(1)) {
+		if ((err = device_create_file(&new_client->dev,
+					&dev_attr_in7_input))
+		 || (err = device_create_file(&new_client->dev,
+					&dev_attr_in7_min))
+		 || (err = device_create_file(&new_client->dev,
+					&dev_attr_in7_max))
+		 || (err = device_create_file(&new_client->dev,
+					&sensor_dev_attr_in7_alarm.dev_attr)))
+			goto exit_remove;
+	} else {
+		if ((err = device_create_file(&new_client->dev,
+					&dev_attr_fan2_input))
+		 || (err = device_create_file(&new_client->dev,
+					&dev_attr_fan2_min))
+		 || (err = device_create_file(&new_client->dev,
+					&dev_attr_fan2_div))
+		 || (err = device_create_file(&new_client->dev,
+					&sensor_dev_attr_fan2_alarm.dev_attr)))
+			goto exit_remove;
+	}
+
+	if (data->channel & CHAN_TEMP3) {
+		if ((err = device_create_file(&new_client->dev,
+					&dev_attr_temp3_input))
+		 || (err = device_create_file(&new_client->dev,
+					&dev_attr_temp3_max))
+		 || (err = device_create_file(&new_client->dev,
+					&dev_attr_temp3_min))
+		 || (err = device_create_file(&new_client->dev,
+					&dev_attr_temp3_crit))
+		 || (err = device_create_file(&new_client->dev,
+					&sensor_dev_attr_temp3_alarm.dev_attr))
+		 || (err = device_create_file(&new_client->dev,
+					&sensor_dev_attr_temp3_fault.dev_attr)))
+			goto exit_remove;
+	} else {
+		if ((err = device_create_file(&new_client->dev,
+					&dev_attr_in0_input))
+		 || (err = device_create_file(&new_client->dev,
+					&dev_attr_in0_min))
+		 || (err = device_create_file(&new_client->dev,
+					&dev_attr_in0_max))
+		 || (err = device_create_file(&new_client->dev,
+					&sensor_dev_attr_in0_alarm.dev_attr))
+		 || (err = device_create_file(&new_client->dev,
+					&dev_attr_in5_input))
+		 || (err = device_create_file(&new_client->dev,
+					&dev_attr_in5_min))
+		 || (err = device_create_file(&new_client->dev,
+					&dev_attr_in5_max))
+		 || (err = device_create_file(&new_client->dev,
+					&sensor_dev_attr_in5_alarm.dev_attr)))
+			goto exit_remove;
+	}
+
+	if (!(data->channel & CHAN_NO_VID)) {
+		data->vrm = vid_which_vrm();
+		if ((err = device_create_file(&new_client->dev,
+					&dev_attr_cpu0_vid))
+		 || (err = device_create_file(&new_client->dev,
+					&dev_attr_vrm)))
+			goto exit_remove;
+	}
+
+	data->hwmon_dev = hwmon_device_register(&new_client->dev);
+	if (IS_ERR(data->hwmon_dev)) {
+		err = PTR_ERR(data->hwmon_dev);
+		goto exit_remove;
+	}
+
+	return 0;
+
+exit_remove:
+	sysfs_remove_group(&new_client->dev.kobj, &lm87_group);
+	sysfs_remove_group(&new_client->dev.kobj, &lm87_group_opt);
+exit_free:
+	lm87_write_value(new_client, LM87_REG_CONFIG, data->config);
+	kfree(data);
+exit:
+	return err;
+}
+
+static void lm87_init_client(struct i2c_client *client)
+{
+	struct lm87_data *data = i2c_get_clientdata(client);
+
+	if (client->dev.platform_data) {
+		data->channel = *(u8 *)client->dev.platform_data;
+		lm87_write_value(client,
+				 LM87_REG_CHANNEL_MODE, data->channel);
+	} else {
+		data->channel = lm87_read_value(client, LM87_REG_CHANNEL_MODE);
+	}
+	data->config = lm87_read_value(client, LM87_REG_CONFIG);
+
+	if (!(data->config & 0x01)) {
+		int i;
+
+		/* Limits are left uninitialized after power-up */
+		for (i = 1; i < 6; i++) {
+			lm87_write_value(client, LM87_REG_IN_MIN(i), 0x00);
+			lm87_write_value(client, LM87_REG_IN_MAX(i), 0xFF);
+		}
+		for (i = 0; i < 2; i++) {
+			lm87_write_value(client, LM87_REG_TEMP_HIGH[i], 0x7F);
+			lm87_write_value(client, LM87_REG_TEMP_LOW[i], 0x00);
+			lm87_write_value(client, LM87_REG_AIN_MIN(i), 0x00);
+			lm87_write_value(client, LM87_REG_AIN_MAX(i), 0xFF);
+		}
+		if (data->channel & CHAN_TEMP3) {
+			lm87_write_value(client, LM87_REG_TEMP_HIGH[2], 0x7F);
+			lm87_write_value(client, LM87_REG_TEMP_LOW[2], 0x00);
+		} else {
+			lm87_write_value(client, LM87_REG_IN_MIN(0), 0x00);
+			lm87_write_value(client, LM87_REG_IN_MAX(0), 0xFF);
+		}
+	}
+
+	/* Make sure Start is set and INT#_Clear is clear */
+	if ((data->config & 0x09) != 0x01)
+		lm87_write_value(client, LM87_REG_CONFIG,
+				 (data->config & 0x77) | 0x01);
+}
+
+static int lm87_remove(struct i2c_client *client)
+{
+	struct lm87_data *data = i2c_get_clientdata(client);
+
+	hwmon_device_unregister(data->hwmon_dev);
+	sysfs_remove_group(&client->dev.kobj, &lm87_group);
+	sysfs_remove_group(&client->dev.kobj, &lm87_group_opt);
+
+	lm87_write_value(client, LM87_REG_CONFIG, data->config);
+	kfree(data);
+	return 0;
+}
+
+#ifdef EFX_USE_I2C_LEGACY
+static int lm87_detach_client(struct i2c_client *client)
+{
+	int err;
+
+	lm87_remove(client);
+	err = i2c_detach_client(client);
+	if (!err)
+		kfree(client);
+	return err;
+}
+#endif
+
+static struct lm87_data *lm87_update_device(struct device *dev)
+{
+	struct i2c_client *client = to_i2c_client(dev);
+	struct lm87_data *data = i2c_get_clientdata(client);
+
+	mutex_lock(&data->update_lock);
+
+	if (time_after(jiffies, data->last_updated + HZ) || !data->valid) {
+		int i, j;
+
+		dev_dbg(&client->dev, "Updating data.\n");
+
+		i = (data->channel & CHAN_TEMP3) ? 1 : 0;
+		j = (data->channel & CHAN_TEMP3) ? 5 : 6;
+		for (; i < j; i++) {
+			data->in[i] = lm87_read_value(client,
+				      LM87_REG_IN(i));
+			data->in_min[i] = lm87_read_value(client,
+					  LM87_REG_IN_MIN(i));
+			data->in_max[i] = lm87_read_value(client,
+					  LM87_REG_IN_MAX(i));
+		}
+
+		for (i = 0; i < 2; i++) {
+			if (data->channel & CHAN_NO_FAN(i)) {
+				data->in[6+i] = lm87_read_value(client,
+						LM87_REG_AIN(i));
+				data->in_max[6+i] = lm87_read_value(client,
+						    LM87_REG_AIN_MAX(i));
+				data->in_min[6+i] = lm87_read_value(client,
+						    LM87_REG_AIN_MIN(i));
+
+			} else {
+				data->fan[i] = lm87_read_value(client,
+					       LM87_REG_FAN(i));
+				data->fan_min[i] = lm87_read_value(client,
+						   LM87_REG_FAN_MIN(i));
+			}
+		}
+
+		j = (data->channel & CHAN_TEMP3) ? 3 : 2;
+		for (i = 0 ; i < j; i++) {
+			data->temp[i] = lm87_read_value(client,
+					LM87_REG_TEMP[i]);
+			data->temp_high[i] = lm87_read_value(client,
+					     LM87_REG_TEMP_HIGH[i]);
+			data->temp_low[i] = lm87_read_value(client,
+					    LM87_REG_TEMP_LOW[i]);
+		}
+
+		i = lm87_read_value(client, LM87_REG_TEMP_HW_INT_LOCK);
+		j = lm87_read_value(client, LM87_REG_TEMP_HW_INT);
+		data->temp_crit_int = min(i, j);
+
+		i = lm87_read_value(client, LM87_REG_TEMP_HW_EXT_LOCK);
+		j = lm87_read_value(client, LM87_REG_TEMP_HW_EXT);
+		data->temp_crit_ext = min(i, j);
+
+		i = lm87_read_value(client, LM87_REG_VID_FAN_DIV);
+		data->fan_div[0] = (i >> 4) & 0x03;
+		data->fan_div[1] = (i >> 6) & 0x03;
+		data->vid = (i & 0x0F)
+			  | (lm87_read_value(client, LM87_REG_VID4) & 0x01)
+			     << 4;
+
+		data->alarms = lm87_read_value(client, LM87_REG_ALARMS1)
+			     | (lm87_read_value(client, LM87_REG_ALARMS2)
+				<< 8);
+		data->aout = lm87_read_value(client, LM87_REG_AOUT);
+
+		data->last_updated = jiffies;
+		data->valid = 1;
+	}
+
+	mutex_unlock(&data->update_lock);
+
+	return data;
+}
+
+#endif /* EFX_NEED_LM87_DRIVER */
diff -r 5b3d4d3c1166 drivers/net/sfc/lm90.c
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/drivers/net/sfc/lm90.c	Tue Nov 09 10:06:27 2010 +0000
@@ -0,0 +1,829 @@
+/*
+ * lm90.c - Part of lm_sensors, Linux kernel modules for hardware
+ *          monitoring
+ * Copyright (C) 2003-2008  Jean Delvare <khali@linux-fr.org>
+ *
+ * Based on the lm83 driver. The LM90 is a sensor chip made by National
+ * Semiconductor. It reports up to two temperatures (its own plus up to
+ * one external one) with a 0.125 deg resolution (1 deg for local
+ * temperature) and a 3-4 deg accuracy.
+ *
+ * This driver also supports the LM89 and LM99, two other sensor chips
+ * made by National Semiconductor. Both have an increased remote
+ * temperature measurement accuracy (1 degree), and the LM99
+ * additionally shifts remote temperatures (measured and limits) by 16
+ * degrees, which allows for higher temperatures measurement. The
+ * driver doesn't handle it since it can be done easily in user-space.
+ * Note that there is no way to differentiate between both chips.
+ *
+ * This driver also supports the LM86, another sensor chip made by
+ * National Semiconductor. It is exactly similar to the LM90 except it
+ * has a higher accuracy.
+ *
+ * This driver also supports the ADM1032, a sensor chip made by Analog
+ * Devices. That chip is similar to the LM90, with a few differences
+ * that are not handled by this driver. Among others, it has a higher
+ * accuracy than the LM90, much like the LM86 does.
+ *
+ * This driver also supports the MAX6657, MAX6658 and MAX6659 sensor
+ * chips made by Maxim. These chips are similar to the LM86.
+ * Note that there is no easy way to differentiate between the three
+ * variants. The extra address and features of the MAX6659 are not
+ * supported by this driver. These chips lack the remote temperature
+ * offset feature.
+ *
+ * This driver also supports the MAX6646, MAX6647 and MAX6649 chips
+ * made by Maxim.  These are again similar to the LM86, but they use
+ * unsigned temperature values and can report temperatures from 0 to
+ * 145 degrees.
+ *
+ * This driver also supports the MAX6680 and MAX6681, two other sensor
+ * chips made by Maxim. These are quite similar to the other Maxim
+ * chips. The MAX6680 and MAX6681 only differ in the pinout so they can
+ * be treated identically.
+ *
+ * This driver also supports the ADT7461 chip from Analog Devices.
+ * It's supported in both compatibility and extended mode. It is mostly
+ * compatible with LM90 except for a data format difference for the
+ * temperature value registers.
+ *
+ * Since the LM90 was the first chipset supported by this driver, most
+ * comments will refer to this chipset, but are actually general and
+ * concern all supported chipsets, unless mentioned otherwise.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/slab.h>
+#include <linux/jiffies.h>
+#include <linux/i2c.h>
+#include <linux/err.h>
+#include <linux/sysfs.h>
+
+#include "kernel_compat.h"
+#ifndef EFX_HAVE_OLD_DEVICE_ATTRIBUTE
+#include <linux/hwmon-sysfs.h>
+#endif
+#ifdef EFX_HAVE_HWMON_H
+#include <linux/hwmon.h>
+#endif
+#ifdef EFX_HAVE_I2C_SENSOR_H
+#include <linux/i2c-sensor.h>
+#endif
+
+#ifdef EFX_NEED_LM90_DRIVER
+
+enum { lm90 = 1, adm1032, lm99, lm86, max6657, adt7461, max6680, max6646 };
+
+/*
+ * The LM90 registers
+ */
+
+#define LM90_REG_R_MAN_ID		0xFE
+#define LM90_REG_R_CHIP_ID		0xFF
+#define LM90_REG_R_CONFIG1		0x03
+#define LM90_REG_W_CONFIG1		0x09
+#define LM90_REG_R_CONFIG2		0xBF
+#define LM90_REG_W_CONFIG2		0xBF
+#define LM90_REG_R_CONVRATE		0x04
+#define LM90_REG_W_CONVRATE		0x0A
+#define LM90_REG_R_STATUS		0x02
+#define LM90_REG_R_LOCAL_TEMP		0x00
+#define LM90_REG_R_LOCAL_HIGH		0x05
+#define LM90_REG_W_LOCAL_HIGH		0x0B
+#define LM90_REG_R_LOCAL_LOW		0x06
+#define LM90_REG_W_LOCAL_LOW		0x0C
+#define LM90_REG_R_LOCAL_CRIT		0x20
+#define LM90_REG_W_LOCAL_CRIT		0x20
+#define LM90_REG_R_REMOTE_TEMPH		0x01
+#define LM90_REG_R_REMOTE_TEMPL		0x10
+#define LM90_REG_R_REMOTE_OFFSH		0x11
+#define LM90_REG_W_REMOTE_OFFSH		0x11
+#define LM90_REG_R_REMOTE_OFFSL		0x12
+#define LM90_REG_W_REMOTE_OFFSL		0x12
+#define LM90_REG_R_REMOTE_HIGHH		0x07
+#define LM90_REG_W_REMOTE_HIGHH		0x0D
+#define LM90_REG_R_REMOTE_HIGHL		0x13
+#define LM90_REG_W_REMOTE_HIGHL		0x13
+#define LM90_REG_R_REMOTE_LOWH		0x08
+#define LM90_REG_W_REMOTE_LOWH		0x0E
+#define LM90_REG_R_REMOTE_LOWL		0x14
+#define LM90_REG_W_REMOTE_LOWL		0x14
+#define LM90_REG_R_REMOTE_CRIT		0x19
+#define LM90_REG_W_REMOTE_CRIT		0x19
+#define LM90_REG_R_TCRIT_HYST		0x21
+#define LM90_REG_W_TCRIT_HYST		0x21
+
+/* MAX6646/6647/6649/6657/6658/6659 registers */
+
+#define MAX6657_REG_R_LOCAL_TEMPL	0x11
+
+/*
+ * Device flags
+ */
+#define LM90_FLAG_ADT7461_EXT		0x01	/* ADT7461 extended mode */
+
+/*
+ * Functions declaration
+ */
+
+static void lm90_init_client(struct i2c_client *client);
+static int lm90_remove(struct i2c_client *client);
+#ifdef EFX_USE_I2C_LEGACY
+static int lm90_detach_client(struct i2c_client *client);
+#endif
+static struct lm90_data *lm90_update_device(struct device *dev);
+
+/*
+ * Driver data (common to all clients)
+ */
+
+#if !defined(EFX_USE_I2C_LEGACY) && !defined(EFX_HAVE_OLD_I2C_DRIVER_PROBE)
+static const struct i2c_device_id lm90_id[] = {
+        { "sfc_max6647" },
+        { }
+};
+#endif
+
+struct i2c_driver efx_lm90_driver = {
+#ifdef EFX_USE_I2C_DRIVER_NAME
+	.name		= "sfc_lm90",
+#else
+	.driver.name	= "sfc_lm90",
+#endif
+#ifdef EFX_USE_I2C_LEGACY
+        .detach_client  = lm90_detach_client,
+#else
+	.probe		= efx_lm90_probe,
+	.remove		= lm90_remove,
+#ifndef EFX_HAVE_OLD_I2C_DRIVER_PROBE
+	.id_table	= lm90_id,
+#endif
+#endif
+};
+
+/*
+ * Client data (each client gets its own)
+ */
+
+struct lm90_data {
+#ifdef EFX_HAVE_HWMON_CLASS_DEVICE
+        struct class_device *hwmon_dev;
+#else
+	struct device *hwmon_dev;
+#endif
+	struct mutex update_lock;
+	char valid; /* zero until following fields are valid */
+	unsigned long last_updated; /* in jiffies */
+	int kind;
+	int flags;
+
+	/* registers values */
+	s8 temp8[4];	/* 0: local low limit
+			   1: local high limit
+			   2: local critical limit
+			   3: remote critical limit */
+	s16 temp11[5];	/* 0: remote input
+			   1: remote low limit
+			   2: remote high limit
+			   3: remote offset (except max6646 and max6657)
+			   4: local input */
+	u8 temp_hyst;
+	u8 alarms; /* bitvector */
+};
+
+/*
+ * Conversions
+ * For local temperatures and limits, critical limits and the hysteresis
+ * value, the LM90 uses signed 8-bit values with LSB = 1 degree Celsius.
+ * For remote temperatures and limits, it uses signed 11-bit values with
+ * LSB = 0.125 degree Celsius, left-justified in 16-bit registers.  Some
+ * Maxim chips use unsigned values.
+ */
+
+static inline int temp_from_s8(s8 val)
+{
+	return val * 1000;
+}
+
+static inline int temp_from_u8(u8 val)
+{
+	return val * 1000;
+}
+
+static inline int temp_from_s16(s16 val)
+{
+	return val / 32 * 125;
+}
+
+static inline int temp_from_u16(u16 val)
+{
+	return val / 32 * 125;
+}
+
+static s8 temp_to_s8(long val)
+{
+	if (val <= -128000)
+		return -128;
+	if (val >= 127000)
+		return 127;
+	if (val < 0)
+		return (val - 500) / 1000;
+	return (val + 500) / 1000;
+}
+
+static u8 temp_to_u8(long val)
+{
+	if (val <= 0)
+		return 0;
+	if (val >= 255000)
+		return 255;
+	return (val + 500) / 1000;
+}
+
+static s16 temp_to_s16(long val)
+{
+	if (val <= -128000)
+		return 0x8000;
+	if (val >= 127875)
+		return 0x7FE0;
+	if (val < 0)
+		return (val - 62) / 125 * 32;
+	return (val + 62) / 125 * 32;
+}
+
+static u8 hyst_to_reg(long val)
+{
+	if (val <= 0)
+		return 0;
+	if (val >= 30500)
+		return 31;
+	return (val + 500) / 1000;
+}
+
+/*
+ * ADT7461 in compatibility mode is almost identical to LM90 except that
+ * attempts to write values that are outside the range 0 < temp < 127 are
+ * treated as the boundary value.
+ *
+ * ADT7461 in "extended mode" operation uses unsigned integers offset by
+ * 64 (e.g., 0 -> -64 degC).  The range is restricted to -64..191 degC.
+ */
+static inline int temp_from_u8_adt7461(struct lm90_data *data, u8 val)
+{
+	if (data->flags & LM90_FLAG_ADT7461_EXT)
+		return (val - 64) * 1000;
+	else
+		return temp_from_s8(val);
+}
+
+static inline int temp_from_u16_adt7461(struct lm90_data *data, u16 val)
+{
+	if (data->flags & LM90_FLAG_ADT7461_EXT)
+		return (val - 0x4000) / 64 * 250;
+	else
+		return temp_from_s16(val);
+}
+
+static u8 temp_to_u8_adt7461(struct lm90_data *data, long val)
+{
+	if (data->flags & LM90_FLAG_ADT7461_EXT) {
+		if (val <= -64000)
+			return 0;
+		if (val >= 191000)
+			return 0xFF;
+		return (val + 500 + 64000) / 1000;
+	} else {
+		if (val <= 0)
+			return 0;
+		if (val >= 127000)
+			return 127;
+		return (val + 500) / 1000;
+	}
+}
+
+static u16 temp_to_u16_adt7461(struct lm90_data *data, long val)
+{
+	if (data->flags & LM90_FLAG_ADT7461_EXT) {
+		if (val <= -64000)
+			return 0;
+		if (val >= 191750)
+			return 0xFFC0;
+		return (val + 64000 + 125) / 250 * 64;
+	} else {
+		if (val <= 0)
+			return 0;
+		if (val >= 127750)
+			return 0x7FC0;
+		return (val + 125) / 250 * 64;
+	}
+}
+
+/*
+ * Sysfs stuff
+ */
+
+static ssize_t show_temp8(struct device *dev, struct device_attribute *devattr,
+			  char *buf)
+{
+	struct sensor_device_attribute *attr = to_sensor_dev_attr(devattr);
+	struct lm90_data *data = lm90_update_device(dev);
+	int temp;
+
+	if (data->kind == adt7461)
+		temp = temp_from_u8_adt7461(data, data->temp8[attr->index]);
+	else if (data->kind == max6646)
+		temp = temp_from_u8(data->temp8[attr->index]);
+	else
+		temp = temp_from_s8(data->temp8[attr->index]);
+
+	return sprintf(buf, "%d\n", temp);
+}
+
+static ssize_t set_temp8(struct device *dev, struct device_attribute *devattr,
+			 const char *buf, size_t count)
+{
+	static const u8 reg[4] = {
+		LM90_REG_W_LOCAL_LOW,
+		LM90_REG_W_LOCAL_HIGH,
+		LM90_REG_W_LOCAL_CRIT,
+		LM90_REG_W_REMOTE_CRIT,
+	};
+
+	struct sensor_device_attribute *attr = to_sensor_dev_attr(devattr);
+	struct i2c_client *client = to_i2c_client(dev);
+	struct lm90_data *data = i2c_get_clientdata(client);
+	long val = simple_strtol(buf, NULL, 10);
+	int nr = attr->index;
+
+	mutex_lock(&data->update_lock);
+	if (data->kind == adt7461)
+		data->temp8[nr] = temp_to_u8_adt7461(data, val);
+	else if (data->kind == max6646)
+		data->temp8[nr] = temp_to_u8(val);
+	else
+		data->temp8[nr] = temp_to_s8(val);
+	i2c_smbus_write_byte_data(client, reg[nr], data->temp8[nr]);
+	mutex_unlock(&data->update_lock);
+	return count;
+}
+
+static ssize_t show_temp11(struct device *dev, struct device_attribute *devattr,
+			   char *buf)
+{
+	struct sensor_device_attribute *attr = to_sensor_dev_attr(devattr);
+	struct lm90_data *data = lm90_update_device(dev);
+	int temp;
+
+	if (data->kind == adt7461)
+		temp = temp_from_u16_adt7461(data, data->temp11[attr->index]);
+	else if (data->kind == max6646)
+		temp = temp_from_u16(data->temp11[attr->index]);
+	else
+		temp = temp_from_s16(data->temp11[attr->index]);
+
+	return sprintf(buf, "%d\n", temp);
+}
+
+static ssize_t set_temp11(struct device *dev, struct device_attribute *devattr,
+			  const char *buf, size_t count)
+{
+	static const u8 reg[6] = {
+		LM90_REG_W_REMOTE_LOWH,
+		LM90_REG_W_REMOTE_LOWL,
+		LM90_REG_W_REMOTE_HIGHH,
+		LM90_REG_W_REMOTE_HIGHL,
+		LM90_REG_W_REMOTE_OFFSH,
+		LM90_REG_W_REMOTE_OFFSL,
+	};
+
+	struct sensor_device_attribute *attr = to_sensor_dev_attr(devattr);
+	struct i2c_client *client = to_i2c_client(dev);
+	struct lm90_data *data = i2c_get_clientdata(client);
+	long val = simple_strtol(buf, NULL, 10);
+	int nr = attr->index;
+
+	mutex_lock(&data->update_lock);
+	if (data->kind == adt7461)
+		data->temp11[nr] = temp_to_u16_adt7461(data, val);
+	else if (data->kind == max6657 || data->kind == max6680)
+		data->temp11[nr] = temp_to_s8(val) << 8;
+	else if (data->kind == max6646)
+		data->temp11[nr] = temp_to_u8(val) << 8;
+	else
+		data->temp11[nr] = temp_to_s16(val);
+
+	i2c_smbus_write_byte_data(client, reg[(nr - 1) * 2],
+				  data->temp11[nr] >> 8);
+	if (data->kind != max6657 && data->kind != max6680
+	    && data->kind != max6646)
+		i2c_smbus_write_byte_data(client, reg[(nr - 1) * 2 + 1],
+					  data->temp11[nr] & 0xff);
+	mutex_unlock(&data->update_lock);
+	return count;
+}
+
+static ssize_t show_temphyst(struct device *dev, struct device_attribute *devattr,
+			     char *buf)
+{
+	struct sensor_device_attribute *attr = to_sensor_dev_attr(devattr);
+	struct lm90_data *data = lm90_update_device(dev);
+	int temp;
+
+	if (data->kind == adt7461)
+		temp = temp_from_u8_adt7461(data, data->temp8[attr->index]);
+	else
+		temp = temp_from_s8(data->temp8[attr->index]);
+
+	return sprintf(buf, "%d\n", temp - temp_from_s8(data->temp_hyst));
+}
+
+static ssize_t set_temphyst(struct device *dev, struct device_attribute *dummy,
+			    const char *buf, size_t count)
+{
+	struct i2c_client *client = to_i2c_client(dev);
+	struct lm90_data *data = i2c_get_clientdata(client);
+	long val = simple_strtol(buf, NULL, 10);
+	long hyst;
+
+	mutex_lock(&data->update_lock);
+	hyst = temp_from_s8(data->temp8[2]) - val;
+	i2c_smbus_write_byte_data(client, LM90_REG_W_TCRIT_HYST,
+				  hyst_to_reg(hyst));
+	mutex_unlock(&data->update_lock);
+	return count;
+}
+
+static ssize_t show_alarms(struct device *dev, struct device_attribute *dummy,
+			   char *buf)
+{
+	struct lm90_data *data = lm90_update_device(dev);
+	return sprintf(buf, "%d\n", data->alarms);
+}
+
+static ssize_t show_alarm(struct device *dev, struct device_attribute
+			  *devattr, char *buf)
+{
+	struct sensor_device_attribute *attr = to_sensor_dev_attr(devattr);
+	struct lm90_data *data = lm90_update_device(dev);
+	int bitnr = attr->index;
+
+	return sprintf(buf, "%d\n", (data->alarms >> bitnr) & 1);
+}
+
+static SENSOR_DEVICE_ATTR(temp1_input, S_IRUGO, show_temp11, NULL, 4);
+static SENSOR_DEVICE_ATTR(temp2_input, S_IRUGO, show_temp11, NULL, 0);
+static SENSOR_DEVICE_ATTR(temp1_min, S_IWUSR | S_IRUGO, show_temp8,
+	set_temp8, 0);
+static SENSOR_DEVICE_ATTR(temp2_min, S_IWUSR | S_IRUGO, show_temp11,
+	set_temp11, 1);
+static SENSOR_DEVICE_ATTR(temp1_max, S_IWUSR | S_IRUGO, show_temp8,
+	set_temp8, 1);
+static SENSOR_DEVICE_ATTR(temp2_max, S_IWUSR | S_IRUGO, show_temp11,
+	set_temp11, 2);
+static SENSOR_DEVICE_ATTR(temp1_crit, S_IWUSR | S_IRUGO, show_temp8,
+	set_temp8, 2);
+static SENSOR_DEVICE_ATTR(temp2_crit, S_IWUSR | S_IRUGO, show_temp8,
+	set_temp8, 3);
+static SENSOR_DEVICE_ATTR(temp1_crit_hyst, S_IWUSR | S_IRUGO, show_temphyst,
+	set_temphyst, 2);
+static SENSOR_DEVICE_ATTR(temp2_crit_hyst, S_IRUGO, show_temphyst, NULL, 3);
+static SENSOR_DEVICE_ATTR(temp2_offset, S_IWUSR | S_IRUGO, show_temp11,
+	set_temp11, 3);
+
+/* Individual alarm files */
+static SENSOR_DEVICE_ATTR(temp1_crit_alarm, S_IRUGO, show_alarm, NULL, 0);
+static SENSOR_DEVICE_ATTR(temp2_crit_alarm, S_IRUGO, show_alarm, NULL, 1);
+static SENSOR_DEVICE_ATTR(temp2_fault, S_IRUGO, show_alarm, NULL, 2);
+static SENSOR_DEVICE_ATTR(temp2_min_alarm, S_IRUGO, show_alarm, NULL, 3);
+static SENSOR_DEVICE_ATTR(temp2_max_alarm, S_IRUGO, show_alarm, NULL, 4);
+static SENSOR_DEVICE_ATTR(temp1_min_alarm, S_IRUGO, show_alarm, NULL, 5);
+static SENSOR_DEVICE_ATTR(temp1_max_alarm, S_IRUGO, show_alarm, NULL, 6);
+/* Raw alarm file for compatibility */
+static DEVICE_ATTR(alarms, S_IRUGO, show_alarms, NULL);
+
+static struct attribute *lm90_attributes[] = {
+	&sensor_dev_attr_temp1_input.dev_attr.attr,
+	&sensor_dev_attr_temp2_input.dev_attr.attr,
+	&sensor_dev_attr_temp1_min.dev_attr.attr,
+	&sensor_dev_attr_temp2_min.dev_attr.attr,
+	&sensor_dev_attr_temp1_max.dev_attr.attr,
+	&sensor_dev_attr_temp2_max.dev_attr.attr,
+	&sensor_dev_attr_temp1_crit.dev_attr.attr,
+	&sensor_dev_attr_temp2_crit.dev_attr.attr,
+	&sensor_dev_attr_temp1_crit_hyst.dev_attr.attr,
+	&sensor_dev_attr_temp2_crit_hyst.dev_attr.attr,
+
+	&sensor_dev_attr_temp1_crit_alarm.dev_attr.attr,
+	&sensor_dev_attr_temp2_crit_alarm.dev_attr.attr,
+	&sensor_dev_attr_temp2_fault.dev_attr.attr,
+	&sensor_dev_attr_temp2_min_alarm.dev_attr.attr,
+	&sensor_dev_attr_temp2_max_alarm.dev_attr.attr,
+	&sensor_dev_attr_temp1_min_alarm.dev_attr.attr,
+	&sensor_dev_attr_temp1_max_alarm.dev_attr.attr,
+	&dev_attr_alarms.attr,
+	NULL
+};
+
+static const struct attribute_group lm90_group = {
+	.attrs = lm90_attributes,
+};
+
+/* pec used for ADM1032 only */
+static ssize_t show_pec(struct device *dev, struct device_attribute *dummy,
+			char *buf)
+{
+	struct i2c_client *client = to_i2c_client(dev);
+	return sprintf(buf, "%d\n", !!(client->flags & I2C_CLIENT_PEC));
+}
+
+static ssize_t set_pec(struct device *dev, struct device_attribute *dummy,
+		       const char *buf, size_t count)
+{
+	struct i2c_client *client = to_i2c_client(dev);
+	long val = simple_strtol(buf, NULL, 10);
+
+	switch (val) {
+	case 0:
+		client->flags &= ~I2C_CLIENT_PEC;
+		break;
+	case 1:
+		client->flags |= I2C_CLIENT_PEC;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	return count;
+}
+
+static DEVICE_ATTR(pec, S_IWUSR | S_IRUGO, show_pec, set_pec);
+
+/*
+ * Real code
+ */
+
+/* The ADM1032 supports PEC but not on write byte transactions, so we need
+   to explicitly ask for a transaction without PEC. */
+static inline s32 adm1032_write_byte(struct i2c_client *client, u8 value)
+{
+	return i2c_smbus_xfer(client->adapter, client->addr,
+			      client->flags & ~I2C_CLIENT_PEC,
+			      I2C_SMBUS_WRITE, value, I2C_SMBUS_BYTE, NULL);
+}
+
+/* It is assumed that client->update_lock is held (unless we are in
+   detection or initialization steps). This matters when PEC is enabled,
+   because we don't want the address pointer to change between the write
+   byte and the read byte transactions. */
+static int lm90_read_reg(struct i2c_client* client, u8 reg, u8 *value)
+{
+	int err;
+
+ 	if (client->flags & I2C_CLIENT_PEC) {
+ 		err = adm1032_write_byte(client, reg);
+ 		if (err >= 0)
+ 			err = i2c_smbus_read_byte(client);
+ 	} else
+ 		err = i2c_smbus_read_byte_data(client, reg);
+
+	if (err < 0) {
+		dev_warn(&client->dev, "Register %#02x read failed (%d)\n",
+			 reg, err);
+		return err;
+	}
+	*value = err;
+
+	return 0;
+}
+
+#ifdef EFX_HAVE_OLD_I2C_DRIVER_PROBE
+int efx_lm90_probe(struct i2c_client *new_client)
+#else
+int efx_lm90_probe(struct i2c_client *new_client,
+		   const struct i2c_device_id *id)
+#endif
+{
+	struct lm90_data *data;
+	int err;
+
+	data = kzalloc(sizeof(struct lm90_data), GFP_KERNEL);
+	if (!data) {
+		err = -ENOMEM;
+		goto exit;
+	}
+	i2c_set_clientdata(new_client, data);
+	mutex_init(&data->update_lock);
+
+	/* Set the device type */
+	data->kind = max6646;
+
+	/* Initialize the LM90 chip */
+	lm90_init_client(new_client);
+
+	/* Register sysfs hooks */
+	if ((err = sysfs_create_group(&new_client->dev.kobj, &lm90_group)))
+		goto exit_free;
+	if (new_client->flags & I2C_CLIENT_PEC) {
+		if ((err = device_create_file(&new_client->dev,
+					      &dev_attr_pec)))
+			goto exit_remove_files;
+	}
+	if (data->kind != max6657 && data->kind != max6646) {
+		if ((err = device_create_file(&new_client->dev,
+				&sensor_dev_attr_temp2_offset.dev_attr)))
+			goto exit_remove_files;
+	}
+
+	data->hwmon_dev = hwmon_device_register(&new_client->dev);
+	if (IS_ERR(data->hwmon_dev)) {
+		err = PTR_ERR(data->hwmon_dev);
+		goto exit_remove_files;
+	}
+
+	return 0;
+
+exit_remove_files:
+	sysfs_remove_group(&new_client->dev.kobj, &lm90_group);
+	device_remove_file(&new_client->dev, &dev_attr_pec);
+exit_free:
+	kfree(data);
+exit:
+	return err;
+}
+
+static void lm90_init_client(struct i2c_client *client)
+{
+	u8 config, config_orig;
+	struct lm90_data *data = i2c_get_clientdata(client);
+
+	/*
+	 * Start the conversions.
+	 */
+	i2c_smbus_write_byte_data(client, LM90_REG_W_CONVRATE,
+				  5); /* 2 Hz */
+	if (lm90_read_reg(client, LM90_REG_R_CONFIG1, &config) < 0) {
+		dev_warn(&client->dev, "Initialization failed!\n");
+		return;
+	}
+	config_orig = config;
+
+	/* Check Temperature Range Select */
+	if (data->kind == adt7461) {
+		if (config & 0x04)
+			data->flags |= LM90_FLAG_ADT7461_EXT;
+	}
+
+	/*
+	 * Put MAX6680/MAX8881 into extended resolution (bit 0x10,
+	 * 0.125 degree resolution) and range (0x08, extend range
+	 * to -64 degree) mode for the remote temperature sensor.
+	 */
+	if (data->kind == max6680) {
+		config |= 0x18;
+	}
+
+	config &= 0xBF;	/* run */
+	if (config != config_orig) /* Only write if changed */
+		i2c_smbus_write_byte_data(client, LM90_REG_W_CONFIG1, config);
+}
+
+static int lm90_remove(struct i2c_client *client)
+{
+	struct lm90_data *data = i2c_get_clientdata(client);
+
+	hwmon_device_unregister(data->hwmon_dev);
+	sysfs_remove_group(&client->dev.kobj, &lm90_group);
+	device_remove_file(&client->dev, &dev_attr_pec);
+	if (data->kind != max6657 && data->kind != max6646)
+		device_remove_file(&client->dev,
+				   &sensor_dev_attr_temp2_offset.dev_attr);
+
+	kfree(data);
+	return 0;
+}
+
+#ifdef EFX_USE_I2C_LEGACY
+static int lm90_detach_client(struct i2c_client *client)
+{
+        int err;
+
+        lm90_remove(client);
+        err = i2c_detach_client(client);
+        if (!err)
+                kfree(client);
+        return err;
+}
+#endif
+
+static int lm90_read16(struct i2c_client *client, u8 regh, u8 regl, u16 *value)
+{
+	int err;
+	u8 oldh, newh, l;
+
+	/*
+	 * There is a trick here. We have to read two registers to have the
+	 * sensor temperature, but we have to beware a conversion could occur
+	 * inbetween the readings. The datasheet says we should either use
+	 * the one-shot conversion register, which we don't want to do
+	 * (disables hardware monitoring) or monitor the busy bit, which is
+	 * impossible (we can't read the values and monitor that bit at the
+	 * exact same time). So the solution used here is to read the high
+	 * byte once, then the low byte, then the high byte again. If the new
+	 * high byte matches the old one, then we have a valid reading. Else
+	 * we have to read the low byte again, and now we believe we have a
+	 * correct reading.
+	 */
+	if ((err = lm90_read_reg(client, regh, &oldh))
+	 || (err = lm90_read_reg(client, regl, &l))
+	 || (err = lm90_read_reg(client, regh, &newh)))
+		return err;
+	if (oldh != newh) {
+		err = lm90_read_reg(client, regl, &l);
+		if (err)
+			return err;
+	}
+	*value = (newh << 8) | l;
+
+	return 0;
+}
+
+static struct lm90_data *lm90_update_device(struct device *dev)
+{
+	struct i2c_client *client = to_i2c_client(dev);
+	struct lm90_data *data = i2c_get_clientdata(client);
+
+	mutex_lock(&data->update_lock);
+
+	if (time_after(jiffies, data->last_updated + HZ * 2) || !data->valid) {
+		u8 h, l;
+
+		dev_dbg(&client->dev, "Updating lm90 data.\n");
+		lm90_read_reg(client, LM90_REG_R_LOCAL_LOW, &data->temp8[0]);
+		lm90_read_reg(client, LM90_REG_R_LOCAL_HIGH, &data->temp8[1]);
+		lm90_read_reg(client, LM90_REG_R_LOCAL_CRIT, &data->temp8[2]);
+		lm90_read_reg(client, LM90_REG_R_REMOTE_CRIT, &data->temp8[3]);
+		lm90_read_reg(client, LM90_REG_R_TCRIT_HYST, &data->temp_hyst);
+
+		if (data->kind == max6657 || data->kind == max6646) {
+			lm90_read16(client, LM90_REG_R_LOCAL_TEMP,
+				    MAX6657_REG_R_LOCAL_TEMPL,
+				    &data->temp11[4]);
+		} else {
+			if (lm90_read_reg(client, LM90_REG_R_LOCAL_TEMP,
+					  &h) == 0)
+				data->temp11[4] = h << 8;
+		}
+		lm90_read16(client, LM90_REG_R_REMOTE_TEMPH,
+			    LM90_REG_R_REMOTE_TEMPL, &data->temp11[0]);
+
+		if (lm90_read_reg(client, LM90_REG_R_REMOTE_LOWH, &h) == 0) {
+			data->temp11[1] = h << 8;
+			if (data->kind != max6657 && data->kind != max6680
+			 && data->kind != max6646
+			 && lm90_read_reg(client, LM90_REG_R_REMOTE_LOWL,
+					  &l) == 0)
+				data->temp11[1] |= l;
+		}
+		if (lm90_read_reg(client, LM90_REG_R_REMOTE_HIGHH, &h) == 0) {
+			data->temp11[2] = h << 8;
+			if (data->kind != max6657 && data->kind != max6680
+			 && data->kind != max6646
+			 && lm90_read_reg(client, LM90_REG_R_REMOTE_HIGHL,
+					  &l) == 0)
+				data->temp11[2] |= l;
+		}
+
+		if (data->kind != max6657 && data->kind != max6646) {
+			if (lm90_read_reg(client, LM90_REG_R_REMOTE_OFFSH,
+					  &h) == 0
+			 && lm90_read_reg(client, LM90_REG_R_REMOTE_OFFSL,
+					  &l) == 0)
+				data->temp11[3] = (h << 8) | l;
+		}
+		lm90_read_reg(client, LM90_REG_R_STATUS, &data->alarms);
+
+		data->last_updated = jiffies;
+		data->valid = 1;
+	}
+
+	mutex_unlock(&data->update_lock);
+
+	return data;
+}
+
+#endif /* EFX_NEED_LM90_DRIVER */
diff -r 5b3d4d3c1166 drivers/net/sfc/mac.h
--- a/drivers/net/sfc/mac.h	Fri Nov 05 15:20:28 2010 +0000
+++ b/drivers/net/sfc/mac.h	Tue Nov 09 10:06:27 2010 +0000
@@ -1,7 +1,7 @@
 /****************************************************************************
  * Driver for Solarflare Solarstorm network controllers and boards
  * Copyright 2005-2006 Fen Systems Ltd.
- * Copyright 2006-2008 Solarflare Communications Inc.
+ * Copyright 2006-2009 Solarflare Communications Inc.
  *
  * This program is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 as published
@@ -13,7 +13,9 @@
 
 #include "net_driver.h"
 
-extern struct efx_mac_operations falcon_gmac_operations;
 extern struct efx_mac_operations falcon_xmac_operations;
+extern struct efx_mac_operations efx_mcdi_mac_operations;
+extern int efx_mcdi_mac_stats(struct efx_nic *efx, dma_addr_t dma_addr,
+			      u32 dma_len, int enable, int clear);
 
 #endif
diff -r 5b3d4d3c1166 drivers/net/sfc/mcdi.c
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/drivers/net/sfc/mcdi.c	Tue Nov 09 10:06:27 2010 +0000
@@ -0,0 +1,1279 @@
+/****************************************************************************
+ * Driver for Solarflare Solarstorm network controllers and boards
+ * Copyright 2008-2009 Solarflare Communications Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 as published
+ * by the Free Software Foundation, incorporated herein by reference.
+ */
+
+#include <linux/delay.h>
+#include "net_driver.h"
+#include "nic.h"
+#include "io.h"
+#include "regs.h"
+#include "mcdi_pcol.h"
+#include "phy.h"
+
+/**************************************************************************
+ *
+ * Management-Controller-to-Driver Interface
+ *
+ **************************************************************************
+ */
+
+/* Software-defined structure to the shared-memory */
+#define CMD_NOTIFY_PORT0 0
+#define CMD_NOTIFY_PORT1 4
+#define CMD_PDU_PORT0    0x008
+#define CMD_PDU_PORT1    0x108
+#define REBOOT_FLAG_PORT0 0x3f8
+#define REBOOT_FLAG_PORT1 0x3fc
+
+#define MCDI_RPC_TIMEOUT       10 /*seconds */
+
+#define MCDI_PDU(efx)							\
+	(efx_port_num(efx) ? CMD_PDU_PORT1 : CMD_PDU_PORT0)
+#define MCDI_DOORBELL(efx)						\
+	(efx_port_num(efx) ? CMD_NOTIFY_PORT1 : CMD_NOTIFY_PORT0)
+#define MCDI_REBOOT_FLAG(efx)						\
+	(efx_port_num(efx) ? REBOOT_FLAG_PORT1 : REBOOT_FLAG_PORT0)
+
+#define SEQ_MASK							\
+	EFX_MASK32(EFX_WIDTH(MCDI_HEADER_SEQ))
+
+static inline struct efx_mcdi_iface *efx_mcdi(struct efx_nic *efx)
+{
+	struct siena_nic_data *nic_data;
+	EFX_BUG_ON_PARANOID(efx_nic_rev(efx) < EFX_REV_SIENA_A0);
+	nic_data = efx->nic_data;
+	return &nic_data->mcdi;
+}
+
+void efx_mcdi_init(struct efx_nic *efx)
+{
+	struct efx_mcdi_iface *mcdi;
+
+	if (efx_nic_rev(efx) < EFX_REV_SIENA_A0)
+		return;
+
+	mcdi = efx_mcdi(efx);
+	init_waitqueue_head(&mcdi->wq);
+	spin_lock_init(&mcdi->iface_lock);
+	atomic_set(&mcdi->state, MCDI_STATE_QUIESCENT);
+	mcdi->mode = MCDI_MODE_POLL;
+
+	(void) efx_mcdi_poll_reboot(efx);
+}
+
+static void efx_mcdi_copyin(struct efx_nic *efx, unsigned cmd,
+			    const u8 *inbuf, size_t inlen)
+{
+	struct efx_mcdi_iface *mcdi = efx_mcdi(efx);
+	unsigned pdu = FR_CZ_MC_TREG_SMEM + MCDI_PDU(efx);
+	unsigned doorbell = FR_CZ_MC_TREG_SMEM + MCDI_DOORBELL(efx);
+	unsigned int i;
+	efx_dword_t hdr;
+	u32 xflags, seqno;
+
+	BUG_ON(atomic_read(&mcdi->state) == MCDI_STATE_QUIESCENT);
+	BUG_ON(inlen & 3 || inlen >= 0x100);
+
+	seqno = mcdi->seqno & SEQ_MASK;
+	xflags = 0;
+	if (mcdi->mode == MCDI_MODE_EVENTS)
+		xflags |= MCDI_HEADER_XFLAGS_EVREQ;
+
+	EFX_POPULATE_DWORD_6(hdr,
+			     MCDI_HEADER_RESPONSE, 0,
+			     MCDI_HEADER_RESYNC, 1,
+			     MCDI_HEADER_CODE, cmd,
+			     MCDI_HEADER_DATALEN, inlen,
+			     MCDI_HEADER_SEQ, seqno,
+			     MCDI_HEADER_XFLAGS, xflags);
+
+	efx_writed(efx, &hdr, pdu);
+
+	for (i = 0; i < inlen; i += 4)
+		_efx_writed(efx, *((__le32 *)(inbuf + i)), pdu + 4 + i);
+
+	/* Ensure the payload is written out before the header */
+	wmb();
+
+	/* ring the doorbell with a distinctive value */
+	_efx_writed(efx, (__force __le32) 0x45789abc, doorbell);
+}
+
+static void efx_mcdi_copyout(struct efx_nic *efx, u8 *outbuf, size_t outlen)
+{
+	struct efx_mcdi_iface *mcdi = efx_mcdi(efx);
+	unsigned int pdu = FR_CZ_MC_TREG_SMEM + MCDI_PDU(efx);
+	int i;
+
+	BUG_ON(atomic_read(&mcdi->state) == MCDI_STATE_QUIESCENT);
+	BUG_ON(outlen & 3 || outlen >= 0x100);
+
+	for (i = 0; i < outlen; i += 4)
+		*((__le32 *)(outbuf + i)) = _efx_readd(efx, pdu + 4 + i);
+}
+
+static int efx_mcdi_poll(struct efx_nic *efx)
+{
+	struct efx_mcdi_iface *mcdi = efx_mcdi(efx);
+	unsigned int time, finish;
+	unsigned int respseq, respcmd, error;
+	unsigned int pdu = FR_CZ_MC_TREG_SMEM + MCDI_PDU(efx);
+	unsigned int rc, spins;
+	efx_dword_t reg;
+
+	/* Check for a reboot atomically with respect to efx_mcdi_copyout() */
+	rc = -efx_mcdi_poll_reboot(efx);
+	if (rc)
+		goto out;
+
+	/* Poll for completion. Poll quickly (once a us) for the 1st jiffy,
+	 * because generally mcdi responses are fast. After that, back off
+	 * and poll once a jiffy (approximately)
+	 */
+	spins = TICK_USEC;
+	finish = get_seconds() + MCDI_RPC_TIMEOUT;
+
+	while (1) {
+		if (spins != 0) {
+			--spins;
+			udelay(1);
+		} else {
+			schedule_timeout_uninterruptible(1);
+		}
+
+		time = get_seconds();
+
+		rmb();
+		efx_readd(efx, &reg, pdu);
+
+		/* All 1's indicates that shared memory is in reset (and is
+		 * not a valid header). Wait for it to come out reset before
+		 * completing the command */
+		if (EFX_DWORD_FIELD(reg, EFX_DWORD_0) != 0xffffffff &&
+		    EFX_DWORD_FIELD(reg, MCDI_HEADER_RESPONSE))
+			break;
+
+		if (time >= finish)
+			return -ETIMEDOUT;
+	}
+
+	mcdi->resplen = EFX_DWORD_FIELD(reg, MCDI_HEADER_DATALEN);
+	respseq = EFX_DWORD_FIELD(reg, MCDI_HEADER_SEQ);
+	respcmd = EFX_DWORD_FIELD(reg, MCDI_HEADER_CODE);
+	error = EFX_DWORD_FIELD(reg, MCDI_HEADER_ERROR);
+
+	if (error && mcdi->resplen == 0) {
+		netif_err(efx, hw, efx->net_dev, "MC rebooted\n");
+		rc = EIO;
+	} else if ((respseq ^ mcdi->seqno) & SEQ_MASK) {
+		netif_err(efx, hw, efx->net_dev,
+			  "MC response mismatch tx seq 0x%x rx seq 0x%x\n",
+			  respseq, mcdi->seqno);
+		rc = EIO;
+	} else if (error) {
+		efx_readd(efx, &reg, pdu + 4);
+		switch (EFX_DWORD_FIELD(reg, EFX_DWORD_0)) {
+#define TRANSLATE_ERROR(name)					\
+		case MC_CMD_ERR_ ## name:			\
+			rc = name;				\
+			break
+			TRANSLATE_ERROR(ENOENT);
+			TRANSLATE_ERROR(EINTR);
+			TRANSLATE_ERROR(EACCES);
+			TRANSLATE_ERROR(EBUSY);
+			TRANSLATE_ERROR(EINVAL);
+			TRANSLATE_ERROR(EDEADLK);
+			TRANSLATE_ERROR(ENOSYS);
+			TRANSLATE_ERROR(ETIME);
+#undef TRANSLATE_ERROR
+		default:
+			rc = EIO;
+			break;
+		}
+	} else
+		rc = 0;
+
+out:
+	mcdi->resprc = rc;
+	if (rc)
+		mcdi->resplen = 0;
+
+	/* Return rc=0 like wait_event_timeout() */
+	return 0;
+}
+
+/* Test and clear MC-rebooted flag for this port/function */
+int efx_mcdi_poll_reboot(struct efx_nic *efx)
+{
+	unsigned int addr = FR_CZ_MC_TREG_SMEM + MCDI_REBOOT_FLAG(efx);
+	efx_dword_t reg;
+	uint32_t value;
+
+	if (efx_nic_rev(efx) < EFX_REV_SIENA_A0)
+		return false;
+
+	efx_readd(efx, &reg, addr);
+	value = EFX_DWORD_FIELD(reg, EFX_DWORD_0);
+
+	if (value == 0)
+		return 0;
+
+	EFX_ZERO_DWORD(reg);
+	efx_writed(efx, &reg, addr);
+
+	if (value == MC_STATUS_DWORD_ASSERT)
+		return -EINTR;
+	else
+		return -EIO;
+}
+
+static void efx_mcdi_acquire(struct efx_mcdi_iface *mcdi)
+{
+	/* Wait until the interface becomes QUIESCENT and we win the race
+	 * to mark it RUNNING. */
+	wait_event(mcdi->wq,
+		   atomic_cmpxchg(&mcdi->state,
+				  MCDI_STATE_QUIESCENT,
+				  MCDI_STATE_RUNNING)
+		   == MCDI_STATE_QUIESCENT);
+}
+
+static int efx_mcdi_await_completion(struct efx_nic *efx)
+{
+	struct efx_mcdi_iface *mcdi = efx_mcdi(efx);
+
+	if (wait_event_timeout(
+		    mcdi->wq,
+		    atomic_read(&mcdi->state) == MCDI_STATE_COMPLETED,
+		    msecs_to_jiffies(MCDI_RPC_TIMEOUT * 1000)) == 0)
+		return -ETIMEDOUT;
+
+	/* Check if efx_mcdi_set_mode() switched us back to polled completions.
+	 * In which case, poll for completions directly. If efx_mcdi_ev_cpl()
+	 * completed the request first, then we'll just end up completing the
+	 * request again, which is safe.
+	 *
+	 * We need an smp_rmb() to synchronise with efx_mcdi_mode_poll(), which
+	 * wait_event_timeout() implicitly provides.
+	 */
+	if (mcdi->mode == MCDI_MODE_POLL)
+		return efx_mcdi_poll(efx);
+
+	return 0;
+}
+
+static bool efx_mcdi_complete(struct efx_mcdi_iface *mcdi)
+{
+	/* If the interface is RUNNING, then move to COMPLETED and wake any
+	 * waiters. If the interface isn't in RUNNING then we've received a
+	 * duplicate completion after we've already transitioned back to
+	 * QUIESCENT. [A subsequent invocation would increment seqno, so would
+	 * have failed the seqno check].
+	 */
+	if (atomic_cmpxchg(&mcdi->state,
+			   MCDI_STATE_RUNNING,
+			   MCDI_STATE_COMPLETED) == MCDI_STATE_RUNNING) {
+		wake_up(&mcdi->wq);
+		return true;
+	}
+
+	return false;
+}
+
+static void efx_mcdi_release(struct efx_mcdi_iface *mcdi)
+{
+	atomic_set(&mcdi->state, MCDI_STATE_QUIESCENT);
+	wake_up(&mcdi->wq);
+}
+
+static void efx_mcdi_ev_cpl(struct efx_nic *efx, unsigned int seqno,
+			    unsigned int datalen, unsigned int errno)
+{
+	struct efx_mcdi_iface *mcdi = efx_mcdi(efx);
+	bool wake = false;
+
+	spin_lock(&mcdi->iface_lock);
+
+	if ((seqno ^ mcdi->seqno) & SEQ_MASK) {
+		if (mcdi->credits)
+			/* The request has been cancelled */
+			--mcdi->credits;
+		else
+			EFX_FATAL(efx, hw, efx->net_dev,
+				  "MC response mismatch tx seq 0x%x rx "
+				  "seq 0x%x\n", seqno, mcdi->seqno);
+	} else {
+		mcdi->resprc = errno;
+		mcdi->resplen = datalen;
+
+		wake = true;
+	}
+
+	spin_unlock(&mcdi->iface_lock);
+
+	if (wake)
+		efx_mcdi_complete(mcdi);
+}
+
+/* Issue the given command by writing the data into the shared memory PDU,
+ * ring the doorbell and wait for completion. Copyout the result. */
+int efx_mcdi_rpc(struct efx_nic *efx, unsigned cmd,
+		 const u8 *inbuf, size_t inlen, u8 *outbuf, size_t outlen,
+		 size_t *outlen_actual)
+{
+	struct efx_mcdi_iface *mcdi = efx_mcdi(efx);
+	int rc;
+
+	BUG_ON(efx_nic_rev(efx) < EFX_REV_SIENA_A0);
+
+	efx_mcdi_acquire(mcdi);
+
+	/* Serialise with efx_mcdi_ev_cpl() and efx_mcdi_ev_death() */
+	spin_lock_bh(&mcdi->iface_lock);
+	++mcdi->seqno;
+	spin_unlock_bh(&mcdi->iface_lock);
+
+	efx_mcdi_copyin(efx, cmd, inbuf, inlen);
+
+	if (mcdi->mode == MCDI_MODE_POLL)
+		rc = efx_mcdi_poll(efx);
+	else
+		rc = efx_mcdi_await_completion(efx);
+
+	if (rc != 0) {
+		/* Close the race with efx_mcdi_ev_cpl() executing just too late
+		 * and completing a request we've just cancelled, by ensuring
+		 * that the seqno check therein fails.
+		 */
+		spin_lock_bh(&mcdi->iface_lock);
+		++mcdi->seqno;
+		++mcdi->credits;
+		spin_unlock_bh(&mcdi->iface_lock);
+
+		netif_err(efx, hw, efx->net_dev,
+			  "MC command 0x%x inlen %d mode %d timed out\n",
+			  cmd, (int)inlen, mcdi->mode);
+	} else {
+		size_t resplen;
+
+		/* At the very least we need a memory barrier here to ensure
+		 * we pick up changes from efx_mcdi_ev_cpl(). Protect against
+		 * a spurious efx_mcdi_ev_cpl() running concurrently by
+		 * acquiring the iface_lock. */
+		spin_lock_bh(&mcdi->iface_lock);
+		rc = -mcdi->resprc;
+		resplen = mcdi->resplen;
+		spin_unlock_bh(&mcdi->iface_lock);
+
+		if (rc == 0) {
+			efx_mcdi_copyout(efx, outbuf,
+					 min(outlen, mcdi->resplen + 3) & ~0x3);
+			if (outlen_actual != NULL)
+				*outlen_actual = resplen;
+		} else if (cmd == MC_CMD_REBOOT && rc == -EIO)
+			; /* Don't reset if MC_CMD_REBOOT returns EIO */
+		else if (rc == -EIO || rc == -EINTR) {
+			netif_err(efx, hw, efx->net_dev, "MC fatal error %d\n",
+				  -rc);
+			efx_schedule_reset(efx, RESET_TYPE_MC_FAILURE);
+		} else
+			netif_err(efx, hw, efx->net_dev,
+				  "MC command 0x%x inlen %d failed rc=%d\n",
+				  cmd, (int)inlen, -rc);
+	}
+
+	efx_mcdi_release(mcdi);
+	return rc;
+}
+
+void efx_mcdi_mode_poll(struct efx_nic *efx)
+{
+	struct efx_mcdi_iface *mcdi;
+
+	if (efx_nic_rev(efx) < EFX_REV_SIENA_A0)
+		return;
+
+	mcdi = efx_mcdi(efx);
+	if (mcdi->mode == MCDI_MODE_POLL)
+		return;
+
+	/* We can switch from event completion to polled completion, because
+	 * mcdi requests are always completed in shared memory. We do this by
+	 * switching the mode to POLL'd then completing the request.
+	 * efx_mcdi_await_completion() will then call efx_mcdi_poll().
+	 *
+	 * We need an smp_wmb() to synchronise with efx_mcdi_await_completion(),
+	 * which efx_mcdi_complete() provides for us.
+	 */
+	mcdi->mode = MCDI_MODE_POLL;
+
+	efx_mcdi_complete(mcdi);
+}
+
+void efx_mcdi_mode_event(struct efx_nic *efx)
+{
+	struct efx_mcdi_iface *mcdi;
+
+	if (efx_nic_rev(efx) < EFX_REV_SIENA_A0)
+		return;
+
+	mcdi = efx_mcdi(efx);
+
+	if (mcdi->mode == MCDI_MODE_EVENTS)
+		return;
+
+	/* We can't switch from polled to event completion in the middle of a
+	 * request, because the completion method is specified in the request.
+	 * So acquire the interface to serialise the requestors. We don't need
+	 * to acquire the iface_lock to change the mode here, but we do need a
+	 * write memory barrier ensure that efx_mcdi_rpc() sees it, which
+	 * efx_mcdi_acquire() provides.
+	 */
+	efx_mcdi_acquire(mcdi);
+	mcdi->mode = MCDI_MODE_EVENTS;
+	efx_mcdi_release(mcdi);
+}
+
+static void efx_mcdi_ev_death(struct efx_nic *efx, int rc)
+{
+	struct efx_mcdi_iface *mcdi = efx_mcdi(efx);
+
+	/* If there is an outstanding MCDI request, it has been terminated
+	 * either by a BADASSERT or REBOOT event. If the mcdi interface is
+	 * in polled mode, then do nothing because the MC reboot handler will
+	 * set the header correctly. However, if the mcdi interface is waiting
+	 * for a CMDDONE event it won't receive it [and since all MCDI events
+	 * are sent to the same queue, we can't be racing with
+	 * efx_mcdi_ev_cpl()]
+	 *
+	 * There's a race here with efx_mcdi_rpc(), because we might receive
+	 * a REBOOT event *before* the request has been copied out. In polled
+	 * mode (during startup) this is irrelevent, because efx_mcdi_complete()
+	 * is ignored. In event mode, this condition is just an edge-case of
+	 * receiving a REBOOT event after posting the MCDI request. Did the mc
+	 * reboot before or after the copyout? The best we can do always is
+	 * just return failure.
+	 */
+	spin_lock(&mcdi->iface_lock);
+	if (efx_mcdi_complete(mcdi)) {
+		if (mcdi->mode == MCDI_MODE_EVENTS) {
+			mcdi->resprc = rc;
+			mcdi->resplen = 0;
+		}
+	} else
+		/* Nobody was waiting for an MCDI request, so trigger a reset */
+		efx_schedule_reset(efx, RESET_TYPE_MC_FAILURE);
+
+	spin_unlock(&mcdi->iface_lock);
+}
+
+static unsigned int efx_mcdi_event_link_speed[] = {
+	[MCDI_EVENT_LINKCHANGE_SPEED_100M] = 100,
+	[MCDI_EVENT_LINKCHANGE_SPEED_1G] = 1000,
+	[MCDI_EVENT_LINKCHANGE_SPEED_10G] = 10000,
+};
+
+
+static void efx_mcdi_process_link_change(struct efx_nic *efx, efx_qword_t *ev)
+{
+	u32 flags, fcntl, speed, lpa;
+
+	speed = EFX_QWORD_FIELD(*ev, MCDI_EVENT_LINKCHANGE_SPEED);
+	EFX_BUG_ON_PARANOID(speed >= ARRAY_SIZE(efx_mcdi_event_link_speed));
+	speed = efx_mcdi_event_link_speed[speed];
+
+	flags = EFX_QWORD_FIELD(*ev, MCDI_EVENT_LINKCHANGE_LINK_FLAGS);
+	fcntl = EFX_QWORD_FIELD(*ev, MCDI_EVENT_LINKCHANGE_FCNTL);
+	lpa = EFX_QWORD_FIELD(*ev, MCDI_EVENT_LINKCHANGE_LP_CAP);
+
+	/* efx->link_state is only modified by efx_mcdi_phy_get_link(),
+	 * which is only run after flushing the event queues. Therefore, it
+	 * is safe to modify the link state outside of the mac_lock here.
+	 */
+	efx_mcdi_phy_decode_link(efx, &efx->link_state, speed, flags, fcntl);
+
+	efx_mcdi_phy_check_fcntl(efx, lpa);
+
+	efx_link_status_changed(efx);
+}
+
+static const char *sensor_names[] = {
+	[MC_CMD_SENSOR_CONTROLLER_TEMP] = "Controller temp. sensor",
+	[MC_CMD_SENSOR_PHY_COMMON_TEMP] = "PHY shared temp. sensor",
+	[MC_CMD_SENSOR_CONTROLLER_COOLING] = "Controller cooling",
+	[MC_CMD_SENSOR_PHY0_TEMP] = "PHY 0 temp. sensor",
+	[MC_CMD_SENSOR_PHY0_COOLING] = "PHY 0 cooling",
+	[MC_CMD_SENSOR_PHY1_TEMP] = "PHY 1 temp. sensor",
+	[MC_CMD_SENSOR_PHY1_COOLING] = "PHY 1 cooling",
+	[MC_CMD_SENSOR_IN_1V0] = "1.0V supply sensor",
+	[MC_CMD_SENSOR_IN_1V2] = "1.2V supply sensor",
+	[MC_CMD_SENSOR_IN_1V8] = "1.8V supply sensor",
+	[MC_CMD_SENSOR_IN_2V5] = "2.5V supply sensor",
+	[MC_CMD_SENSOR_IN_3V3] = "3.3V supply sensor",
+	[MC_CMD_SENSOR_IN_12V0] = "12V supply sensor"
+};
+
+static const char *sensor_status_names[] = {
+	[MC_CMD_SENSOR_STATE_OK] = "OK",
+	[MC_CMD_SENSOR_STATE_WARNING] = "Warning",
+	[MC_CMD_SENSOR_STATE_FATAL] = "Fatal",
+	[MC_CMD_SENSOR_STATE_BROKEN] = "Device failure",
+};
+
+static void efx_mcdi_sensor_event(struct efx_nic *efx, efx_qword_t *ev)
+{
+	unsigned int monitor, state, value;
+	const char *name, *state_txt;
+	monitor = EFX_QWORD_FIELD(*ev, MCDI_EVENT_SENSOREVT_MONITOR);
+	state = EFX_QWORD_FIELD(*ev, MCDI_EVENT_SENSOREVT_STATE);
+	value = EFX_QWORD_FIELD(*ev, MCDI_EVENT_SENSOREVT_VALUE);
+	/* Deal gracefully with the board having more drivers than we
+	 * know about, but do not expect new sensor states. */
+	name = (monitor >= ARRAY_SIZE(sensor_names))
+				    ? "No sensor name available" :
+				    sensor_names[monitor];
+	EFX_BUG_ON_PARANOID(state >= ARRAY_SIZE(sensor_status_names));
+	state_txt = sensor_status_names[state];
+
+	netif_err(efx, hw, efx->net_dev,
+		  "Sensor %d (%s) reports condition '%s' for raw value %d\n",
+		  monitor, name, state_txt, value);
+}
+
+static void efx_mcdi_fwalert_event(struct efx_nic *efx, efx_qword_t *ev)
+{
+	unsigned int reason, data;
+
+	reason = EFX_QWORD_FIELD(*ev, MCDI_EVENT_FWALERT_REASON);
+	data = EFX_QWORD_FIELD(*ev, MCDI_EVENT_FWALERT_DATA);
+
+	switch (reason) {
+	case MCDI_EVENT_FWALERT_REASON_SRAM_ACCESS:
+		netif_err(efx, hw, efx->net_dev,
+			  "Error - controller firmware has detected a write"
+			  " to an illegal SRAM address\n");
+		break;
+	default:
+		netif_err(efx, hw, efx->net_dev,
+			  "Firmware alert reason %u: 0x%x\n", reason, data);
+	}
+}
+
+/* Called from  falcon_process_eventq for MCDI events */
+void efx_mcdi_process_event(struct efx_channel *channel,
+			    efx_qword_t *event)
+{
+	struct efx_nic *efx = channel->efx;
+	int code = EFX_QWORD_FIELD(*event, MCDI_EVENT_CODE);
+	u32 data = EFX_QWORD_FIELD(*event, MCDI_EVENT_DATA);
+
+	switch (code) {
+	case MCDI_EVENT_CODE_BADSSERT:
+		netif_err(efx, hw, efx->net_dev,
+			  "MC watchdog or assertion failure at 0x%x\n", data);
+		efx_mcdi_ev_death(efx, EINTR);
+		break;
+
+	case MCDI_EVENT_CODE_PMNOTICE:
+		netif_info(efx, wol, efx->net_dev, "MCDI PM event.\n");
+		break;
+
+	case MCDI_EVENT_CODE_CMDDONE:
+		efx_mcdi_ev_cpl(efx,
+				MCDI_EVENT_FIELD(*event, CMDDONE_SEQ),
+				MCDI_EVENT_FIELD(*event, CMDDONE_DATALEN),
+				MCDI_EVENT_FIELD(*event, CMDDONE_ERRNO));
+		break;
+
+	case MCDI_EVENT_CODE_LINKCHANGE:
+		efx_mcdi_process_link_change(efx, event);
+		break;
+	case MCDI_EVENT_CODE_SENSOREVT:
+		efx_mcdi_sensor_event(efx, event);
+		break;
+	case MCDI_EVENT_CODE_SCHEDERR:
+		netif_info(efx, hw, efx->net_dev,
+			   "MC Scheduler error address=0x%x\n", data);
+		break;
+	case MCDI_EVENT_CODE_REBOOT:
+		netif_info(efx, hw, efx->net_dev, "MC Reboot\n");
+		efx_mcdi_ev_death(efx, EIO);
+		break;
+	case MCDI_EVENT_CODE_MAC_STATS_DMA:
+		/* MAC stats are gather lazily.  We can ignore this. */
+		break;
+	case MCDI_EVENT_CODE_FWALERT:
+		efx_mcdi_fwalert_event(efx, event);
+		break;
+	case MCDI_EVENT_CODE_FLR:
+		efx_sriov_flr(efx, MCDI_EVENT_FIELD(*event, FLR_VF));
+		break;
+	default:
+		netif_err(efx, hw, efx->net_dev, "Unknown MCDI event 0x%x\n",
+			  code);
+	}
+}
+
+/**************************************************************************
+ *
+ * Specific request functions
+ *
+ **************************************************************************
+ */
+
+void efx_mcdi_print_fwver(struct efx_nic *efx, char *buf, size_t len)
+{
+	u8 outbuf[ALIGN(MC_CMD_GET_VERSION_OUT_LEN, 4)];
+	size_t outlength;
+	const __le16 *ver_words;
+	int rc;
+
+	BUILD_BUG_ON(MC_CMD_GET_VERSION_IN_LEN != 0);
+
+	rc = efx_mcdi_rpc(efx, MC_CMD_GET_VERSION, NULL, 0,
+			  outbuf, sizeof(outbuf), &outlength);
+	if (rc)
+		goto fail;
+
+	if (outlength < MC_CMD_GET_VERSION_OUT_LEN) {
+		rc = -EIO;
+		goto fail;
+	}
+
+	ver_words = (__le16 *)MCDI_PTR(outbuf, GET_VERSION_OUT_VERSION);
+	snprintf(buf, len, "%u.%u.%u.%u",
+		 le16_to_cpu(ver_words[0]), le16_to_cpu(ver_words[1]),
+		 le16_to_cpu(ver_words[2]), le16_to_cpu(ver_words[3]));
+	return;
+
+fail:
+	netif_err(efx, probe, efx->net_dev, "%s: failed rc=%d\n", __func__, rc);
+	buf[0] = 0;
+}
+
+int efx_mcdi_drv_attach(struct efx_nic *efx, bool driver_operating,
+			bool *was_attached)
+{
+	u8 inbuf[MC_CMD_DRV_ATTACH_IN_LEN];
+	u8 outbuf[MC_CMD_DRV_ATTACH_OUT_LEN];
+	size_t outlen;
+	int rc;
+
+	MCDI_SET_DWORD(inbuf, DRV_ATTACH_IN_NEW_STATE,
+		       driver_operating ? 1 : 0);
+	MCDI_SET_DWORD(inbuf, DRV_ATTACH_IN_UPDATE, 1);
+
+	rc = efx_mcdi_rpc(efx, MC_CMD_DRV_ATTACH, inbuf, sizeof(inbuf),
+			  outbuf, sizeof(outbuf), &outlen);
+	if (rc)
+		goto fail;
+	if (outlen < MC_CMD_DRV_ATTACH_OUT_LEN) {
+		rc = -EIO;
+		goto fail;
+	}
+
+	if (was_attached != NULL)
+		*was_attached = MCDI_DWORD(outbuf, DRV_ATTACH_OUT_OLD_STATE);
+	return 0;
+
+fail:
+	netif_err(efx, probe, efx->net_dev, "%s: failed rc=%d\n", __func__, rc);
+	return rc;
+}
+
+int efx_mcdi_get_board_cfg(struct efx_nic *efx, u8 *mac_address,
+			   u16 *fw_subtype_list, u32 *capabilities)
+{
+	uint8_t outbuf[MC_CMD_GET_BOARD_CFG_OUT_LEN];
+	size_t outlen;
+	int port_num = efx_port_num(efx);
+	int offset;
+	int rc;
+
+	BUILD_BUG_ON(MC_CMD_GET_BOARD_CFG_IN_LEN != 0);
+
+	rc = efx_mcdi_rpc(efx, MC_CMD_GET_BOARD_CFG, NULL, 0,
+			  outbuf, sizeof(outbuf), &outlen);
+	if (rc)
+		goto fail;
+
+	if (outlen < MC_CMD_GET_BOARD_CFG_OUT_LEN) {
+		rc = -EIO;
+		goto fail;
+	}
+
+	offset = (port_num)
+		? MC_CMD_GET_BOARD_CFG_OUT_MAC_ADDR_BASE_PORT1_OFST
+		: MC_CMD_GET_BOARD_CFG_OUT_MAC_ADDR_BASE_PORT0_OFST;
+	if (mac_address)
+		memcpy(mac_address, outbuf + offset, ETH_ALEN);
+	if (fw_subtype_list)
+		memcpy(fw_subtype_list,
+		       outbuf + MC_CMD_GET_BOARD_CFG_OUT_FW_SUBTYPE_LIST_OFST,
+		       MC_CMD_GET_BOARD_CFG_OUT_FW_SUBTYPE_LIST_LEN * 
+		       MC_CMD_GET_BOARD_CFG_OUT_FW_SUBTYPE_LIST_NUM);
+	if (capabilities) {
+		if (port_num)
+			*capabilities = MCDI_DWORD(outbuf,
+				   	GET_BOARD_CFG_OUT_CAPABILITIES_PORT1);
+		else
+			*capabilities = MCDI_DWORD(outbuf,
+				   	GET_BOARD_CFG_OUT_CAPABILITIES_PORT0);
+	}
+
+	return 0;
+
+fail:
+	netif_err(efx, hw, efx->net_dev, "%s: failed rc=%d len=%d\n",
+		  __func__, rc, (int)outlen);
+
+	return rc;
+}
+
+int efx_mcdi_log_ctrl(struct efx_nic *efx, bool evq, bool uart, u32 dest_evq)
+{
+	u8 inbuf[MC_CMD_LOG_CTRL_IN_LEN];
+	u32 dest = 0;
+	int rc;
+
+	if (uart)
+		dest |= MC_CMD_LOG_CTRL_IN_LOG_DEST_UART;
+	if (evq)
+		dest |= MC_CMD_LOG_CTRL_IN_LOG_DEST_EVQ;
+
+	MCDI_SET_DWORD(inbuf, LOG_CTRL_IN_LOG_DEST, dest);
+	MCDI_SET_DWORD(inbuf, LOG_CTRL_IN_LOG_DEST_EVQ, dest_evq);
+
+	BUILD_BUG_ON(MC_CMD_LOG_CTRL_OUT_LEN != 0);
+
+	rc = efx_mcdi_rpc(efx, MC_CMD_LOG_CTRL, inbuf, sizeof(inbuf),
+			  NULL, 0, NULL);
+	if (rc)
+		goto fail;
+
+	return 0;
+
+fail:
+	netif_err(efx, hw, efx->net_dev, "%s: failed rc=%d\n", __func__, rc);
+	return rc;
+}
+
+int efx_mcdi_nvram_types(struct efx_nic *efx, u32 *nvram_types_out)
+{
+	u8 outbuf[MC_CMD_NVRAM_TYPES_OUT_LEN];
+	size_t outlen;
+	int rc;
+
+	BUILD_BUG_ON(MC_CMD_NVRAM_TYPES_IN_LEN != 0);
+
+	rc = efx_mcdi_rpc(efx, MC_CMD_NVRAM_TYPES, NULL, 0,
+			  outbuf, sizeof(outbuf), &outlen);
+	if (rc)
+		goto fail;
+	if (outlen < MC_CMD_NVRAM_TYPES_OUT_LEN) {
+		rc = -EIO;
+		goto fail;
+	}
+
+	*nvram_types_out = MCDI_DWORD(outbuf, NVRAM_TYPES_OUT_TYPES);
+	return 0;
+
+fail:
+	netif_err(efx, hw, efx->net_dev, "%s: failed rc=%d\n",
+		  __func__, rc);
+	return rc;
+}
+
+int efx_mcdi_nvram_info(struct efx_nic *efx, unsigned int type,
+			size_t *size_out, size_t *erase_size_out,
+			bool *protected_out)
+{
+	u8 inbuf[MC_CMD_NVRAM_INFO_IN_LEN];
+	u8 outbuf[MC_CMD_NVRAM_INFO_OUT_LEN];
+	size_t outlen;
+	int rc;
+
+	MCDI_SET_DWORD(inbuf, NVRAM_INFO_IN_TYPE, type);
+
+	rc = efx_mcdi_rpc(efx, MC_CMD_NVRAM_INFO, inbuf, sizeof(inbuf),
+			  outbuf, sizeof(outbuf), &outlen);
+	if (rc)
+		goto fail;
+	if (outlen < MC_CMD_NVRAM_INFO_OUT_LEN) {
+		rc = -EIO;
+		goto fail;
+	}
+
+	*size_out = MCDI_DWORD(outbuf, NVRAM_INFO_OUT_SIZE);
+	*erase_size_out = MCDI_DWORD(outbuf, NVRAM_INFO_OUT_ERASESIZE);
+	*protected_out = !!(MCDI_DWORD(outbuf, NVRAM_INFO_OUT_FLAGS) &
+				(1 << MC_CMD_NVRAM_INFO_OUT_PROTECTED_LBN));
+	return 0;
+
+fail:
+	netif_err(efx, hw, efx->net_dev, "%s: failed rc=%d\n", __func__, rc);
+	return rc;
+}
+
+int efx_mcdi_nvram_update_start(struct efx_nic *efx, unsigned int type)
+{
+	u8 inbuf[MC_CMD_NVRAM_UPDATE_START_IN_LEN];
+	int rc;
+
+	MCDI_SET_DWORD(inbuf, NVRAM_UPDATE_START_IN_TYPE, type);
+
+	BUILD_BUG_ON(MC_CMD_NVRAM_UPDATE_START_OUT_LEN != 0);
+
+	rc = efx_mcdi_rpc(efx, MC_CMD_NVRAM_UPDATE_START, inbuf, sizeof(inbuf),
+			  NULL, 0, NULL);
+	if (rc)
+		goto fail;
+
+	return 0;
+
+fail:
+	netif_err(efx, hw, efx->net_dev, "%s: failed rc=%d\n", __func__, rc);
+	return rc;
+}
+
+int efx_mcdi_nvram_read(struct efx_nic *efx, unsigned int type,
+			loff_t offset, u8 *buffer, size_t length)
+{
+	u8 inbuf[MC_CMD_NVRAM_READ_IN_LEN];
+	u8 outbuf[MC_CMD_NVRAM_READ_OUT_LEN(EFX_MCDI_NVRAM_LEN_MAX)];
+	size_t outlen;
+	int rc;
+
+	MCDI_SET_DWORD(inbuf, NVRAM_READ_IN_TYPE, type);
+	MCDI_SET_DWORD(inbuf, NVRAM_READ_IN_OFFSET, offset);
+	MCDI_SET_DWORD(inbuf, NVRAM_READ_IN_LENGTH, length);
+
+	rc = efx_mcdi_rpc(efx, MC_CMD_NVRAM_READ, inbuf, sizeof(inbuf),
+			  outbuf, sizeof(outbuf), &outlen);
+	if (rc)
+		goto fail;
+
+	memcpy(buffer, MCDI_PTR(outbuf, NVRAM_READ_OUT_READ_BUFFER), length);
+	return 0;
+
+fail:
+	netif_err(efx, hw, efx->net_dev, "%s: failed rc=%d\n", __func__, rc);
+	return rc;
+}
+
+int efx_mcdi_nvram_write(struct efx_nic *efx, unsigned int type,
+			   loff_t offset, const u8 *buffer, size_t length)
+{
+	u8 inbuf[MC_CMD_NVRAM_WRITE_IN_LEN(EFX_MCDI_NVRAM_LEN_MAX)];
+	int rc;
+
+	MCDI_SET_DWORD(inbuf, NVRAM_WRITE_IN_TYPE, type);
+	MCDI_SET_DWORD(inbuf, NVRAM_WRITE_IN_OFFSET, offset);
+	MCDI_SET_DWORD(inbuf, NVRAM_WRITE_IN_LENGTH, length);
+	memcpy(MCDI_PTR(inbuf, NVRAM_WRITE_IN_WRITE_BUFFER), buffer, length);
+
+	BUILD_BUG_ON(MC_CMD_NVRAM_WRITE_OUT_LEN != 0);
+
+	rc = efx_mcdi_rpc(efx, MC_CMD_NVRAM_WRITE, inbuf,
+			  ALIGN(MC_CMD_NVRAM_WRITE_IN_LEN(length), 4),
+			  NULL, 0, NULL);
+	if (rc)
+		goto fail;
+
+	return 0;
+
+fail:
+	netif_err(efx, hw, efx->net_dev, "%s: failed rc=%d\n", __func__, rc);
+	return rc;
+}
+
+int efx_mcdi_nvram_erase(struct efx_nic *efx, unsigned int type,
+			 loff_t offset, size_t length)
+{
+	u8 inbuf[MC_CMD_NVRAM_ERASE_IN_LEN];
+	int rc;
+
+	MCDI_SET_DWORD(inbuf, NVRAM_ERASE_IN_TYPE, type);
+	MCDI_SET_DWORD(inbuf, NVRAM_ERASE_IN_OFFSET, offset);
+	MCDI_SET_DWORD(inbuf, NVRAM_ERASE_IN_LENGTH, length);
+
+	BUILD_BUG_ON(MC_CMD_NVRAM_ERASE_OUT_LEN != 0);
+
+	rc = efx_mcdi_rpc(efx, MC_CMD_NVRAM_ERASE, inbuf, sizeof(inbuf),
+			  NULL, 0, NULL);
+	if (rc)
+		goto fail;
+
+	return 0;
+
+fail:
+	netif_err(efx, hw, efx->net_dev, "%s: failed rc=%d\n", __func__, rc);
+	return rc;
+}
+
+int efx_mcdi_nvram_update_finish(struct efx_nic *efx, unsigned int type)
+{
+	u8 inbuf[MC_CMD_NVRAM_UPDATE_FINISH_IN_LEN];
+	u32 reboot;
+	int rc;
+
+	/* Reboot PHY's into the new firmware. mcfw reboot is handled
+	 * explicity via ethtool. */
+	reboot = (type == MC_CMD_NVRAM_TYPE_PHY_PORT0 ||
+		  type == MC_CMD_NVRAM_TYPE_PHY_PORT1 ||
+		  type == MC_CMD_NVRAM_TYPE_DISABLED_CALLISTO);
+	MCDI_SET_DWORD(inbuf, NVRAM_UPDATE_FINISH_IN_TYPE, type);
+	MCDI_SET_DWORD(inbuf, NVRAM_UPDATE_FINISH_IN_REBOOT, reboot);
+
+	BUILD_BUG_ON(MC_CMD_NVRAM_UPDATE_FINISH_OUT_LEN != 0);
+
+	rc = efx_mcdi_rpc(efx, MC_CMD_NVRAM_UPDATE_FINISH, inbuf, sizeof(inbuf),
+			  NULL, 0, NULL);
+	if (rc)
+		goto fail;
+
+	return 0;
+
+fail:
+	netif_err(efx, hw, efx->net_dev, "%s: failed rc=%d\n", __func__, rc);
+	return rc;
+}
+
+static int efx_mcdi_nvram_test(struct efx_nic *efx, unsigned int type)
+{
+	u8 inbuf[MC_CMD_NVRAM_TEST_IN_LEN];
+	u8 outbuf[MC_CMD_NVRAM_TEST_OUT_LEN];
+	int rc;
+
+	MCDI_SET_DWORD(inbuf, NVRAM_TEST_IN_TYPE, type);
+
+	rc = efx_mcdi_rpc(efx, MC_CMD_NVRAM_TEST, inbuf, sizeof(inbuf),
+			  outbuf, sizeof(outbuf), NULL);
+	if (rc)
+		return rc;
+
+	switch (MCDI_DWORD(outbuf, NVRAM_TEST_OUT_RESULT)) {
+	case MC_CMD_NVRAM_TEST_PASS:
+	case MC_CMD_NVRAM_TEST_NOTSUPP:
+		return 0;
+	default:
+		return -EIO;
+	}
+}
+
+int efx_mcdi_nvram_test_all(struct efx_nic *efx)
+{
+	u32 nvram_types = 0;
+	unsigned int type;
+	int rc;
+
+	rc = efx_mcdi_nvram_types(efx, &nvram_types);
+	if (rc)
+		goto fail1;
+
+	type = 0;
+	while (nvram_types != 0) {
+		if (nvram_types & 1) {
+			rc = efx_mcdi_nvram_test(efx, type);
+			if (rc)
+				goto fail2;
+		}
+		type++;
+		nvram_types >>= 1;
+	}
+
+	return 0;
+
+fail2:
+	netif_err(efx, hw, efx->net_dev, "%s: failed type=%u\n",
+		  __func__, type);
+fail1:
+	netif_err(efx, hw, efx->net_dev, "%s: failed rc=%d\n", __func__, rc);
+	return rc;
+}
+
+static int efx_mcdi_read_assertion(struct efx_nic *efx)
+{
+	u8 inbuf[MC_CMD_GET_ASSERTS_IN_LEN];
+	u8 outbuf[MC_CMD_GET_ASSERTS_OUT_LEN];
+	unsigned int flags, index, ofst;
+	const char *reason;
+	size_t outlen;
+	int retry;
+	int rc;
+
+	/* Attempt to read any stored assertion state before we reboot
+	 * the mcfw out of the assertion handler. Retry twice, once
+	 * because a boot-time assertion might cause this command to fail
+	 * with EINTR. And once again because GET_ASSERTS can race with
+	 * MC_CMD_REBOOT running on the other port. */
+	retry = 2;
+	do {
+		MCDI_SET_DWORD(inbuf, GET_ASSERTS_IN_CLEAR, 1);
+		rc = efx_mcdi_rpc(efx, MC_CMD_GET_ASSERTS,
+				  inbuf, MC_CMD_GET_ASSERTS_IN_LEN,
+				  outbuf, sizeof(outbuf), &outlen);
+	} while ((rc == -EINTR || rc == -EIO) && retry-- > 0);
+
+	if (rc)
+		return rc;
+	if (outlen < MC_CMD_GET_ASSERTS_OUT_LEN)
+		return -EIO;
+
+	/* Print out any recorded assertion state */
+	flags = MCDI_DWORD(outbuf, GET_ASSERTS_OUT_GLOBAL_FLAGS);
+	if (flags == MC_CMD_GET_ASSERTS_FLAGS_NO_FAILS)
+		return 0;
+
+	reason = (flags == MC_CMD_GET_ASSERTS_FLAGS_SYS_FAIL)
+		? "system-level assertion"
+		: (flags == MC_CMD_GET_ASSERTS_FLAGS_THR_FAIL)
+		? "thread-level assertion"
+		: (flags == MC_CMD_GET_ASSERTS_FLAGS_WDOG_FIRED)
+		? "watchdog reset"
+		: "unknown assertion";
+	netif_err(efx, hw, efx->net_dev,
+		  "MCPU %s at PC = 0x%.8x in thread 0x%.8x\n", reason,
+		  MCDI_DWORD(outbuf, GET_ASSERTS_OUT_SAVED_PC_OFFS),
+		  MCDI_DWORD(outbuf, GET_ASSERTS_OUT_THREAD_OFFS));
+
+	/* Print out the registers */
+	ofst = MC_CMD_GET_ASSERTS_OUT_GP_REGS_OFFS_OFST;
+	for (index = 1; index < 32; index++) {
+		netif_err(efx, hw, efx->net_dev, "R%.2d (?): 0x%.8x\n", index,
+			MCDI_DWORD2(outbuf, ofst));
+		ofst += sizeof(efx_dword_t);
+	}
+
+	return 0;
+}
+
+static void efx_mcdi_exit_assertion(struct efx_nic *efx)
+{
+	u8 inbuf[MC_CMD_REBOOT_IN_LEN];
+
+	/* Atomically reboot the mcfw out of the assertion handler */
+	BUILD_BUG_ON(MC_CMD_REBOOT_OUT_LEN != 0);
+	MCDI_SET_DWORD(inbuf, REBOOT_IN_FLAGS,
+		       MC_CMD_REBOOT_FLAGS_AFTER_ASSERTION);
+	efx_mcdi_rpc(efx, MC_CMD_REBOOT, inbuf, MC_CMD_REBOOT_IN_LEN,
+		     NULL, 0, NULL);
+}
+
+int efx_mcdi_handle_assertion(struct efx_nic *efx)
+{
+	int rc;
+
+	rc = efx_mcdi_read_assertion(efx);
+	if (rc)
+		return rc;
+
+	efx_mcdi_exit_assertion(efx);
+
+	return 0;
+}
+
+void efx_mcdi_set_id_led(struct efx_nic *efx, enum efx_led_mode mode)
+{
+	u8 inbuf[MC_CMD_SET_ID_LED_IN_LEN];
+	int rc;
+
+	BUILD_BUG_ON(EFX_LED_OFF != MC_CMD_LED_OFF);
+	BUILD_BUG_ON(EFX_LED_ON != MC_CMD_LED_ON);
+	BUILD_BUG_ON(EFX_LED_DEFAULT != MC_CMD_LED_DEFAULT);
+
+	BUILD_BUG_ON(MC_CMD_SET_ID_LED_OUT_LEN != 0);
+
+	MCDI_SET_DWORD(inbuf, SET_ID_LED_IN_STATE, mode);
+
+	rc = efx_mcdi_rpc(efx, MC_CMD_SET_ID_LED, inbuf, sizeof(inbuf),
+			  NULL, 0, NULL);
+	if (rc)
+		netif_err(efx, hw, efx->net_dev, "%s: failed rc=%d\n",
+			  __func__, rc);
+}
+
+int efx_mcdi_reset_port(struct efx_nic *efx)
+{
+	int rc = efx_mcdi_rpc(efx, MC_CMD_PORT_RESET, NULL, 0, NULL, 0, NULL);
+	if (rc)
+		netif_err(efx, hw, efx->net_dev, "%s: failed rc=%d\n",
+			  __func__, rc);
+	return rc;
+}
+
+int efx_mcdi_reset_mc(struct efx_nic *efx)
+{
+	u8 inbuf[MC_CMD_REBOOT_IN_LEN];
+	int rc;
+
+	BUILD_BUG_ON(MC_CMD_REBOOT_OUT_LEN != 0);
+	MCDI_SET_DWORD(inbuf, REBOOT_IN_FLAGS, 0);
+	rc = efx_mcdi_rpc(efx, MC_CMD_REBOOT, inbuf, sizeof(inbuf),
+			  NULL, 0, NULL);
+	/* White is black, and up is down */
+	if (rc == -EIO)
+		return 0;
+	if (rc == 0)
+		rc = -EIO;
+	netif_err(efx, hw, efx->net_dev, "%s: failed rc=%d\n", __func__, rc);
+	return rc;
+}
+
+static int efx_mcdi_wol_filter_set(struct efx_nic *efx, u32 type,
+				   const u8 *mac, int *id_out)
+{
+	u8 inbuf[MC_CMD_WOL_FILTER_SET_IN_LEN];
+	u8 outbuf[MC_CMD_WOL_FILTER_SET_OUT_LEN];
+	size_t outlen;
+	int rc;
+
+	MCDI_SET_DWORD(inbuf, WOL_FILTER_SET_IN_WOL_TYPE, type);
+	MCDI_SET_DWORD(inbuf, WOL_FILTER_SET_IN_FILTER_MODE,
+		       MC_CMD_FILTER_MODE_SIMPLE);
+	memcpy(MCDI_PTR(inbuf, WOL_FILTER_SET_IN_MAGIC_MAC), mac, ETH_ALEN);
+
+	rc = efx_mcdi_rpc(efx, MC_CMD_WOL_FILTER_SET, inbuf, sizeof(inbuf),
+			  outbuf, sizeof(outbuf), &outlen);
+	if (rc)
+		goto fail;
+
+	if (outlen < MC_CMD_WOL_FILTER_SET_OUT_LEN) {
+		rc = -EIO;
+		goto fail;
+	}
+
+	*id_out = (int)MCDI_DWORD(outbuf, WOL_FILTER_SET_OUT_FILTER_ID);
+
+	return 0;
+
+fail:
+	*id_out = -1;
+	netif_err(efx, hw, efx->net_dev, "%s: failed rc=%d\n", __func__, rc);
+	return rc;
+
+}
+
+
+int
+efx_mcdi_wol_filter_set_magic(struct efx_nic *efx,  const u8 *mac, int *id_out)
+{
+	return efx_mcdi_wol_filter_set(efx, MC_CMD_WOL_TYPE_MAGIC, mac, id_out);
+}
+
+
+int efx_mcdi_wol_filter_get_magic(struct efx_nic *efx, int *id_out)
+{
+	u8 outbuf[MC_CMD_WOL_FILTER_GET_OUT_LEN];
+	size_t outlen;
+	int rc;
+
+	rc = efx_mcdi_rpc(efx, MC_CMD_WOL_FILTER_GET, NULL, 0,
+			  outbuf, sizeof(outbuf), &outlen);
+	if (rc)
+		goto fail;
+
+	if (outlen < MC_CMD_WOL_FILTER_GET_OUT_LEN) {
+		rc = -EIO;
+		goto fail;
+	}
+
+	*id_out = (int)MCDI_DWORD(outbuf, WOL_FILTER_GET_OUT_FILTER_ID);
+
+	return 0;
+
+fail:
+	*id_out = -1;
+	netif_err(efx, hw, efx->net_dev, "%s: failed rc=%d\n", __func__, rc);
+	return rc;
+}
+
+
+int efx_mcdi_wol_filter_remove(struct efx_nic *efx, int id)
+{
+	u8 inbuf[MC_CMD_WOL_FILTER_REMOVE_IN_LEN];
+	int rc;
+
+	MCDI_SET_DWORD(inbuf, WOL_FILTER_REMOVE_IN_FILTER_ID, (u32)id);
+
+	rc = efx_mcdi_rpc(efx, MC_CMD_WOL_FILTER_REMOVE, inbuf, sizeof(inbuf),
+			  NULL, 0, NULL);
+	if (rc)
+		goto fail;
+
+	return 0;
+
+fail:
+	netif_err(efx, hw, efx->net_dev, "%s: failed rc=%d\n", __func__, rc);
+	return rc;
+}
+
+int efx_mcdi_flush_rxqs(struct efx_nic *efx)
+{
+	struct efx_channel *channel;
+	struct efx_rx_queue *rx_queue;
+	__le32 *qid;
+	int rc, count;
+
+	count = 0;
+	efx_for_each_channel(channel, efx) {
+		efx_for_each_channel_rx_queue(rx_queue, efx) {
+			if (rx_queue->flushed == FLUSH_NONE)
+				++count;
+		}
+	}
+	if (count == 0)
+		return 0;
+
+	qid = kmalloc(count * sizeof(*qid), GFP_KERNEL);
+	if (qid == NULL)
+		return -ENOMEM;
+
+	count = 0;
+	efx_for_each_channel(channel, efx) {
+		efx_for_each_channel_rx_queue(rx_queue, efx) {
+			if (rx_queue->flushed == FLUSH_NONE)
+				qid[count++] = cpu_to_le32(
+					efx_rx_queue_index(rx_queue));
+		}
+	}
+	
+	rc = efx_mcdi_rpc(efx, MC_CMD_FLUSH_RX_QUEUES, (u8 *)qid,
+			  count * sizeof(*qid), NULL, 0, NULL);
+	WARN_ON(rc > 0);
+
+	kfree(qid);
+
+	if (rc < 0)
+		return rc;
+
+	efx_for_each_channel(channel, efx) {
+		efx_for_each_channel_rx_queue(rx_queue, efx) {
+			if (rx_queue->flushed == FLUSH_NONE)
+				rx_queue->flushed = FLUSH_PENDING;
+		}
+	}
+
+	return count;
+}
+
+int efx_mcdi_wol_filter_reset(struct efx_nic *efx)
+{
+	int rc;
+
+	rc = efx_mcdi_rpc(efx, MC_CMD_WOL_FILTER_RESET, NULL, 0, NULL, 0, NULL);
+	if (rc)
+		goto fail;
+
+	return 0;
+
+fail:
+	netif_err(efx, hw, efx->net_dev, "%s: failed rc=%d\n", __func__, rc);
+	return rc;
+}
+
diff -r 5b3d4d3c1166 drivers/net/sfc/mcdi.h
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/drivers/net/sfc/mcdi.h	Tue Nov 09 10:06:27 2010 +0000
@@ -0,0 +1,131 @@
+/****************************************************************************
+ * Driver for Solarflare Solarstorm network controllers and boards
+ * Copyright 2008-2009 Solarflare Communications Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 as published
+ * by the Free Software Foundation, incorporated herein by reference.
+ */
+
+#ifndef EFX_MCDI_H
+#define EFX_MCDI_H
+
+/**
+ * enum efx_mcdi_state
+ * @MCDI_STATE_QUIESCENT: No pending MCDI requests. If the caller holds the
+ *	mcdi_lock then they are able to move to MCDI_STATE_RUNNING
+ * @MCDI_STATE_RUNNING: There is an MCDI request pending. Only the thread that
+ *	moved into this state is allowed to move out of it.
+ * @MCDI_STATE_COMPLETED: An MCDI request has completed, but the owning thread
+ *	has not yet consumed the result. For all other threads, equivalent to
+ *	MCDI_STATE_RUNNING.
+ */
+enum efx_mcdi_state {
+	MCDI_STATE_QUIESCENT,
+	MCDI_STATE_RUNNING,
+	MCDI_STATE_COMPLETED,
+};
+
+enum efx_mcdi_mode {
+	MCDI_MODE_POLL,
+	MCDI_MODE_EVENTS,
+};
+
+/**
+ * struct efx_mcdi_iface
+ * @state: Interface state. Waited for by mcdi_wq.
+ * @wq: Wait queue for threads waiting for state != STATE_RUNNING
+ * @iface_lock: Protects @credits, @seqno, @resprc, @resplen
+ * @mode: Poll for mcdi completion, or wait for an mcdi_event.
+ *	Serialised by @lock
+ * @seqno: The next sequence number to use for mcdi requests.
+ *	Serialised by @lock
+ * @credits: Number of spurious MCDI completion events allowed before we
+ *	trigger a fatal error. Protected by @lock
+ * @resprc: Returned MCDI completion
+ * @resplen: Returned payload length
+ */
+struct efx_mcdi_iface {
+	atomic_t state;
+	wait_queue_head_t wq;
+	spinlock_t iface_lock;
+	enum efx_mcdi_mode mode;
+	unsigned int credits;
+	unsigned int seqno;
+	unsigned int resprc;
+	size_t resplen;
+};
+
+extern void efx_mcdi_init(struct efx_nic *efx);
+
+extern int efx_mcdi_rpc(struct efx_nic *efx, unsigned cmd, const u8 *inbuf,
+			size_t inlen, u8 *outbuf, size_t outlen,
+			size_t *outlen_actual);
+
+extern int efx_mcdi_poll_reboot(struct efx_nic *efx);
+extern void efx_mcdi_mode_poll(struct efx_nic *efx);
+extern void efx_mcdi_mode_event(struct efx_nic *efx);
+
+extern void efx_mcdi_process_event(struct efx_channel *channel,
+				   efx_qword_t *event);
+
+#define MCDI_PTR2(_buf, _ofst)						\
+	(((u8 *)_buf) + _ofst)
+#define MCDI_SET_DWORD2(_buf, _ofst, _value)				\
+	EFX_POPULATE_DWORD_1(*((efx_dword_t *)MCDI_PTR2(_buf, _ofst)),	\
+			     EFX_DWORD_0, _value)
+#define MCDI_DWORD2(_buf, _ofst)					\
+	EFX_DWORD_FIELD(*((efx_dword_t *)MCDI_PTR2(_buf, _ofst)),	\
+			EFX_DWORD_0)
+#define MCDI_QWORD2(_buf, _ofst)					\
+	EFX_QWORD_FIELD64(*((efx_qword_t *)MCDI_PTR2(_buf, _ofst)),	\
+			  EFX_QWORD_0)
+
+#define MCDI_PTR(_buf, _ofst)						\
+	MCDI_PTR2(_buf, MC_CMD_ ## _ofst ## _OFST)
+#define MCDI_SET_DWORD(_buf, _ofst, _value)				\
+	MCDI_SET_DWORD2(_buf, MC_CMD_ ## _ofst ## _OFST, _value)
+#define MCDI_DWORD(_buf, _ofst)						\
+	MCDI_DWORD2(_buf, MC_CMD_ ## _ofst ## _OFST)
+#define MCDI_QWORD(_buf, _ofst)						\
+	MCDI_QWORD2(_buf, MC_CMD_ ## _ofst ## _OFST)
+
+#define MCDI_EVENT_FIELD(_ev, _field)			\
+	EFX_QWORD_FIELD(_ev, MCDI_EVENT_ ## _field)
+
+extern void efx_mcdi_print_fwver(struct efx_nic *efx, char *buf, size_t len);
+extern int efx_mcdi_drv_attach(struct efx_nic *efx, bool driver_operating,
+			       bool *was_attached_out);
+extern int efx_mcdi_get_board_cfg(struct efx_nic *efx, u8 *mac_address,
+				  u16 *fw_subtype_list, u32 *capabilities);
+extern int efx_mcdi_log_ctrl(struct efx_nic *efx, bool evq, bool uart,
+			     u32 dest_evq);
+extern int efx_mcdi_nvram_types(struct efx_nic *efx, u32 *nvram_types_out);
+extern int efx_mcdi_nvram_info(struct efx_nic *efx, unsigned int type,
+			       size_t *size_out, size_t *erase_size_out,
+			       bool *protected_out);
+extern int efx_mcdi_nvram_update_start(struct efx_nic *efx,
+				       unsigned int type);
+extern int efx_mcdi_nvram_read(struct efx_nic *efx, unsigned int type,
+			       loff_t offset, u8 *buffer, size_t length);
+extern int efx_mcdi_nvram_write(struct efx_nic *efx, unsigned int type,
+				loff_t offset, const u8 *buffer,
+				size_t length);
+#define EFX_MCDI_NVRAM_LEN_MAX 128
+extern int efx_mcdi_nvram_erase(struct efx_nic *efx, unsigned int type,
+				loff_t offset, size_t length);
+extern int efx_mcdi_nvram_update_finish(struct efx_nic *efx,
+					unsigned int type);
+extern int efx_mcdi_nvram_test_all(struct efx_nic *efx);
+extern int efx_mcdi_handle_assertion(struct efx_nic *efx);
+extern void efx_mcdi_set_id_led(struct efx_nic *efx, enum efx_led_mode mode);
+extern int efx_mcdi_reset_port(struct efx_nic *efx);
+extern int efx_mcdi_reset_mc(struct efx_nic *efx);
+extern int efx_mcdi_wol_filter_set_magic(struct efx_nic *efx,
+					 const u8 *mac, int *id_out);
+extern int efx_mcdi_wol_filter_get_magic(struct efx_nic *efx, int *id_out);
+extern int efx_mcdi_wol_filter_remove(struct efx_nic *efx, int id);
+extern int efx_mcdi_wol_filter_reset(struct efx_nic *efx);
+extern int efx_mcdi_flush_rxqs(struct efx_nic *efx);
+
+#endif /* EFX_MCDI_H */
diff -r 5b3d4d3c1166 drivers/net/sfc/mcdi_mac.c
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/drivers/net/sfc/mcdi_mac.c	Tue Nov 09 10:06:27 2010 +0000
@@ -0,0 +1,145 @@
+/****************************************************************************
+ * Driver for Solarflare Solarstorm network controllers and boards
+ * Copyright 2009 Solarflare Communications Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 as published
+ * by the Free Software Foundation, incorporated herein by reference.
+ */
+
+#include "net_driver.h"
+#include "efx.h"
+#include "mac.h"
+#include "mcdi.h"
+#include "mcdi_pcol.h"
+
+static int efx_mcdi_set_mac(struct efx_nic *efx)
+{
+	u32 reject, fcntl;
+	u8 cmdbytes[MC_CMD_SET_MAC_IN_LEN];
+
+	memcpy(cmdbytes + MC_CMD_SET_MAC_IN_ADDR_OFST,
+	       efx->net_dev->dev_addr, ETH_ALEN);
+
+	MCDI_SET_DWORD(cmdbytes, SET_MAC_IN_MTU,
+			EFX_MAX_FRAME_LEN(efx->net_dev->mtu));
+	MCDI_SET_DWORD(cmdbytes, SET_MAC_IN_DRAIN, 0);
+
+	/* The MCDI command provides for controlling accept/reject
+	 * of broadcast packets too, but the driver doesn't currently
+	 * expose this. */
+	reject = (efx->promiscuous) ? 0 :
+		(1 << MC_CMD_SET_MAC_IN_REJECT_UNCST_LBN);
+	MCDI_SET_DWORD(cmdbytes, SET_MAC_IN_REJECT, reject);
+
+	switch (efx->wanted_fc) {
+	case EFX_FC_RX | EFX_FC_TX:
+		fcntl = MC_CMD_FCNTL_BIDIR;
+		break;
+	case EFX_FC_RX:
+		fcntl = MC_CMD_FCNTL_RESPOND;
+		break;
+	default:
+		fcntl = MC_CMD_FCNTL_OFF;
+		break;
+	}
+	if (efx->wanted_fc & EFX_FC_AUTO)
+		fcntl = MC_CMD_FCNTL_AUTO;
+
+	MCDI_SET_DWORD(cmdbytes, SET_MAC_IN_FCNTL, fcntl);
+
+	return efx_mcdi_rpc(efx, MC_CMD_SET_MAC, cmdbytes, sizeof(cmdbytes),
+			    NULL, 0, NULL);
+}
+
+static int efx_mcdi_get_mac_faults(struct efx_nic *efx, u32 *faults)
+{
+	u8 outbuf[MC_CMD_GET_LINK_OUT_LEN];
+	size_t outlength;
+	int rc;
+
+	BUILD_BUG_ON(MC_CMD_GET_LINK_IN_LEN != 0);
+
+	rc = efx_mcdi_rpc(efx, MC_CMD_GET_LINK, NULL, 0,
+			  outbuf, sizeof(outbuf), &outlength);
+	if (rc)
+		goto fail;
+
+	*faults = MCDI_DWORD(outbuf, GET_LINK_OUT_MAC_FAULT);
+	return 0;
+
+fail:
+	netif_err(efx, hw, efx->net_dev, "%s: failed rc=%d\n",
+		  __func__, rc);
+	return rc;
+}
+
+int efx_mcdi_mac_stats(struct efx_nic *efx, dma_addr_t dma_addr,
+		       u32 dma_len, int enable, int clear)
+{
+	u8 inbuf[MC_CMD_MAC_STATS_IN_LEN];
+	int rc;
+	efx_dword_t *cmd_ptr;
+	int period = enable ? 1000 : 0;
+	u32 addr_hi;
+	u32 addr_lo;
+
+	BUILD_BUG_ON(MC_CMD_MAC_STATS_OUT_DMA_LEN != 0);
+
+	addr_lo = ((u64)dma_addr) >> 0;
+	addr_hi = ((u64)dma_addr) >> 32;
+
+	MCDI_SET_DWORD(inbuf, MAC_STATS_IN_DMA_ADDR_LO, addr_lo);
+	MCDI_SET_DWORD(inbuf, MAC_STATS_IN_DMA_ADDR_HI, addr_hi);
+	cmd_ptr = (efx_dword_t *)MCDI_PTR(inbuf, MAC_STATS_IN_CMD);
+	EFX_POPULATE_DWORD_7(*cmd_ptr,
+			     MC_CMD_MAC_STATS_IN_DMA, !!enable,
+			     MC_CMD_MAC_STATS_IN_CLEAR, clear,
+			     MC_CMD_MAC_STATS_IN_PERIODIC_CHANGE, 1,
+			     MC_CMD_MAC_STATS_IN_PERIODIC_ENABLE, !!enable,
+			     MC_CMD_MAC_STATS_IN_PERIODIC_CLEAR, 0,
+			     MC_CMD_MAC_STATS_IN_PERIODIC_NOEVENT, 1,
+			     MC_CMD_MAC_STATS_IN_PERIOD_MS, period);
+	MCDI_SET_DWORD(inbuf, MAC_STATS_IN_DMA_LEN, dma_len);
+
+	rc = efx_mcdi_rpc(efx, MC_CMD_MAC_STATS, inbuf, sizeof(inbuf),
+			  NULL, 0, NULL);
+	if (rc)
+		goto fail;
+
+	return 0;
+
+fail:
+	netif_err(efx, hw, efx->net_dev, "%s: %s failed rc=%d\n",
+		  __func__, enable ? "enable" : "disable", rc);
+	return rc;
+}
+
+static int efx_mcdi_mac_reconfigure(struct efx_nic *efx)
+{
+	int rc;
+
+	rc = efx_mcdi_set_mac(efx);
+	if (rc != 0)
+		return rc;
+
+	/* Restore the multicast hash registers. */
+	efx->type->push_multicast_hash(efx);
+
+	return 0;
+}
+
+
+static bool efx_mcdi_mac_check_fault(struct efx_nic *efx)
+{
+	u32 faults;
+	int rc = efx_mcdi_get_mac_faults(efx, &faults);
+	return (rc != 0) || (faults != 0);
+}
+
+
+struct efx_mac_operations efx_mcdi_mac_operations = {
+	.reconfigure	= efx_mcdi_mac_reconfigure,
+	.update_stats	= efx_port_dummy_op_void,
+	.check_fault 	= efx_mcdi_mac_check_fault,
+};
diff -r 5b3d4d3c1166 drivers/net/sfc/mcdi_pcol.h
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/drivers/net/sfc/mcdi_pcol.h	Tue Nov 09 10:06:27 2010 +0000
@@ -0,0 +1,2476 @@
+/****************************************************************************
+ * Driver for Solarflare Solarstorm network controllers and boards
+ * Copyright 2009 Solarflare Communications Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 as published
+ * by the Free Software Foundation, incorporated herein by reference.
+ */
+
+
+#ifndef MCDI_PCOL_H
+#define MCDI_PCOL_H
+
+
+/* Values to be written into FMCR_CZ_RESET_STATE_REG to control boot. */
+/* Power-on reset state */
+#define MC_FW_STATE_POR (1)
+/* If this is set in MC_RESET_STATE_REG then it should be
+ * possible to jump into IMEM without loading code from flash. */
+#define MC_FW_WARM_BOOT_OK (2)
+/* The MC main image has started to boot. */
+#define MC_FW_STATE_BOOTING (4)
+/* The Scheduler has started. */
+#define MC_FW_STATE_SCHED (8)
+
+/* Values to be written to the per-port status dword in shared
+ * memory on reboot and assert */
+#define MC_STATUS_DWORD_REBOOT (0xb007b007)
+#define MC_STATUS_DWORD_ASSERT (0xdeaddead)
+
+/* The current version of the MCDI protocol.
+ *
+ * Note that the ROM burnt into the card only talks V0, so at the very
+ * least every driver must support version 0 and MCDI_PCOL_VERSION
+ */
+#ifdef WITH_MCDI_V2
+#define MCDI_PCOL_VERSION 2
+#else
+#define MCDI_PCOL_VERSION 1
+#endif
+
+/* Unused commands: 0x23, 0x27, 0x30, 0x31 */
+
+/* Unused commands: 0x23, 0x27, 0x30, 0x31 */
+
+/**
+ * MCDI version 1
+ *
+ * Each MCDI request starts with an MCDI_HEADER, which is a 32byte
+ * structure, filled in by the client.
+ *
+ *       0       7  8     16    20     22  23  24    31
+ *      | CODE | R | LEN | SEQ | Rsvd | E | R | XFLAGS |
+ *               |                      |   |
+ *               |                      |   \--- Response
+ *               |                      \------- Error
+ *               \------------------------------ Resync (always set)
+ *
+ * The client writes it's request into MC shared memory, and rings the
+ * doorbell. Each request is completed by either by the MC writting
+ * back into shared memory, or by writting out an event.
+ *
+ * All MCDI commands support completion by shared memory response. Each
+ * request may also contain additional data (accounted for by HEADER.LEN),
+ * and some response's may also contain additional data (again, accounted
+ * for by HEADER.LEN).
+ *
+ * Some MCDI commands support completion by event, in which any associated
+ * response data is included in the event.
+ *
+ * The protocol requires one response to be delivered for every request, a
+ * request should not be sent unless the response for the previous request
+ * has been received (either by polling shared memory, or by receiving
+ * an event).
+ */
+
+/** Request/Response structure */
+#define MCDI_HEADER_OFST 0
+#define MCDI_HEADER_CODE_LBN 0
+#define MCDI_HEADER_CODE_WIDTH 7
+#define MCDI_HEADER_RESYNC_LBN 7
+#define MCDI_HEADER_RESYNC_WIDTH 1
+#define MCDI_HEADER_DATALEN_LBN 8
+#define MCDI_HEADER_DATALEN_WIDTH 8
+#define MCDI_HEADER_SEQ_LBN 16
+#define MCDI_HEADER_RSVD_LBN 20
+#define MCDI_HEADER_RSVD_WIDTH 2
+#define MCDI_HEADER_SEQ_WIDTH 4
+#define MCDI_HEADER_ERROR_LBN 22
+#define MCDI_HEADER_ERROR_WIDTH 1
+#define MCDI_HEADER_RESPONSE_LBN 23
+#define MCDI_HEADER_RESPONSE_WIDTH 1
+#define MCDI_HEADER_XFLAGS_LBN 24
+#define MCDI_HEADER_XFLAGS_WIDTH 8
+/* Request response using event */
+#define MCDI_HEADER_XFLAGS_EVREQ 0x01
+
+/* Maximum number of payload bytes */
+#define MCDI_CTL_SDU_LEN_MAX 0xfc
+
+/* The MC can generate events for two reasons:
+ *   - To complete a shared memory request if XFLAGS_EVREQ was set
+ *   - As a notification (link state, i2c event), controlled
+ *     via MC_CMD_LOG_CTRL
+ *
+ * Both events share a common structure:
+ *
+ *  0      32     33      36    44     52     60
+ * | Data | Cont | Level | Src | Code | Rsvd |
+ *           |
+ *           \ There is another event pending in this notification
+ *
+ * If Code==CMDDONE, then the fields are further interpreted as:
+ *
+ *   - LEVEL==INFO    Command succeded
+ *   - LEVEL==ERR     Command failed
+ *
+ *    0     8         16      24     32
+ *   | Seq | Datalen | Errno | Rsvd |
+ *
+ *   These fields are taken directly out of the standard MCDI header, i.e.,
+ *   LEVEL==ERR, Datalen == 0 => Reboot
+ *
+ * Events can be squirted out of the UART (using LOG_CTRL) without a
+ * MCDI header.  An event can be distinguished from a MCDI response by
+ * examining the first byte which is 0xc0.  This corresponds to the
+ * non-existent MCDI command MC_CMD_DEBUG_LOG.
+ *
+ *      0         7        8
+ *     | command | Resync |     = 0xc0
+ *
+ * Since the event is written in big-endian byte order, this works
+ * providing bits 56-63 of the event are 0xc0.
+ *
+ *      56     60  63
+ *     | Rsvd | Code |    = 0xc0
+ *
+ * Which means for convenience the event code is 0xc for all MC
+ * generated events.
+ */
+#define FSE_AZ_EV_CODE_MCDI_EVRESPONSE 0xc
+
+
+/* Non-existent command target */
+#define MC_CMD_ERR_ENOENT 2
+/* assert() has killed the MC */
+#define MC_CMD_ERR_EINTR 4
+/* Caller does not hold required locks */
+#define MC_CMD_ERR_EACCES 13
+/* Resource is currently unavailable (e.g. lock contention) */
+#define MC_CMD_ERR_EBUSY 16
+/* Invalid argument to target */
+#define MC_CMD_ERR_EINVAL 22
+/* Non-recursive resource is already acquired */
+#define MC_CMD_ERR_EDEADLK 35
+/* Operation not implemented */
+#define MC_CMD_ERR_ENOSYS 38
+/* Operation timed out */
+#define MC_CMD_ERR_ETIME 62
+
+#define MC_CMD_ERR_CODE_OFST 0
+
+/* We define 8 "escape" commands to allow
+   for command number space extension */
+
+#define MC_CMD_CMD_SPACE_ESCAPE_0	      0x78
+#define MC_CMD_CMD_SPACE_ESCAPE_1	      0x79
+#define MC_CMD_CMD_SPACE_ESCAPE_2	      0x7A
+#define MC_CMD_CMD_SPACE_ESCAPE_3	      0x7B
+#define MC_CMD_CMD_SPACE_ESCAPE_4	      0x7C
+#define MC_CMD_CMD_SPACE_ESCAPE_5	      0x7D
+#define MC_CMD_CMD_SPACE_ESCAPE_6	      0x7E
+#define MC_CMD_CMD_SPACE_ESCAPE_7	      0x7F
+
+/* Vectors in the boot ROM */
+/* Point to the copycode entry point. */
+#define MC_BOOTROM_COPYCODE_VEC (0x7f4)
+/* Points to the recovery mode entry point. */
+#define MC_BOOTROM_NOFLASH_VEC (0x7f8)
+
+/* The command set exported by the boot ROM (MCDI v0) */
+#define MC_CMD_GET_VERSION_V0_SUPPORTED_FUNCS {		\
+	(1 << MC_CMD_READ32)	|			\
+	(1 << MC_CMD_WRITE32)	|			\
+	(1 << MC_CMD_COPYCODE)	|			\
+	(1 << MC_CMD_GET_VERSION),			\
+	0, 0, 0 }
+
+#define MC_CMD_SENSOR_INFO_OUT_OFFSET_OFST(_x) \
+	(MC_CMD_SENSOR_ENTRY_OFST + (_x))
+
+#define MC_CMD_DBI_WRITE_IN_ADDRESS_OFST(n) (  \
+        (MC_CMD_DBI_WRITE_IN_DBIWROP_OFST+     \
+         MC_CMD_DBIWROP_TYPEDEF_ADDRESS_OFST)+ \
+         ((n)*MC_CMD_DBIWROP_TYPEDEF_LEN))
+
+#define MC_CMD_DBI_WRITE_IN_BYTE_MASK_OFST(n) (  \
+        (MC_CMD_DBI_WRITE_IN_DBIWROP_OFST+     \
+         MC_CMD_DBIWROP_TYPEDEF_BYTE_MASK_OFST)+ \
+         ((n)*MC_CMD_DBIWROP_TYPEDEF_LEN))
+
+#define MC_CMD_DBI_WRITE_IN_VALUE_OFST(n) (  \
+        (MC_CMD_DBI_WRITE_IN_DBIWROP_OFST+     \
+         MC_CMD_DBIWROP_TYPEDEF_VALUE_OFST)+ \
+         ((n)*MC_CMD_DBIWROP_TYPEDEF_LEN))
+
+
+#ifdef WITH_MCDI_V2
+
+/* New errno values */
+#define MC_CMD_ERR_ENOSPC 28
+
+/* Version 2 adds an optional argument to error returns: the errno value
+ * may be followed by the (0-based) number of the first argument that
+ * could not be processed.
+ */
+#define MC_CMD_ERR_ARG_OFST 4
+
+#endif
+
+/* MCDI_EVENT structuredef */
+#define    MCDI_EVENT_LEN 8
+#define       MCDI_EVENT_CONT_LBN 32
+#define       MCDI_EVENT_CONT_WIDTH 1
+#define       MCDI_EVENT_LEVEL_LBN 33
+#define       MCDI_EVENT_LEVEL_WIDTH 3
+#define       MCDI_EVENT_DATA_OFST 0
+#define          MCDI_EVENT_LEVEL_INFO  0x0 /* enum */
+#define          MCDI_EVENT_LEVEL_WARN 0x1 /* enum */
+#define          MCDI_EVENT_LEVEL_ERR 0x2 /* enum */
+#define          MCDI_EVENT_LEVEL_FATAL 0x3 /* enum */
+#define        MCDI_EVENT_CMDDONE_SEQ_LBN 0
+#define        MCDI_EVENT_CMDDONE_SEQ_WIDTH 8
+#define        MCDI_EVENT_CMDDONE_DATALEN_LBN 8
+#define        MCDI_EVENT_CMDDONE_DATALEN_WIDTH 8
+#define        MCDI_EVENT_CMDDONE_ERRNO_LBN 16
+#define        MCDI_EVENT_CMDDONE_ERRNO_WIDTH 8
+#define        MCDI_EVENT_LINKCHANGE_LP_CAP_LBN 0
+#define        MCDI_EVENT_LINKCHANGE_LP_CAP_WIDTH 16
+#define        MCDI_EVENT_LINKCHANGE_SPEED_LBN 16
+#define        MCDI_EVENT_LINKCHANGE_SPEED_WIDTH 4
+#define          MCDI_EVENT_LINKCHANGE_SPEED_100M  0x1 /* enum */
+#define          MCDI_EVENT_LINKCHANGE_SPEED_1G  0x2 /* enum */
+#define          MCDI_EVENT_LINKCHANGE_SPEED_10G  0x3 /* enum */
+#define        MCDI_EVENT_LINKCHANGE_FCNTL_LBN 20
+#define        MCDI_EVENT_LINKCHANGE_FCNTL_WIDTH 4
+#define        MCDI_EVENT_LINKCHANGE_LINK_FLAGS_LBN 24
+#define        MCDI_EVENT_LINKCHANGE_LINK_FLAGS_WIDTH 8
+#define        MCDI_EVENT_SENSOREVT_MONITOR_LBN 0
+#define        MCDI_EVENT_SENSOREVT_MONITOR_WIDTH 8
+#define        MCDI_EVENT_SENSOREVT_STATE_LBN 8
+#define        MCDI_EVENT_SENSOREVT_STATE_WIDTH 8
+#define        MCDI_EVENT_SENSOREVT_VALUE_LBN 16
+#define        MCDI_EVENT_SENSOREVT_VALUE_WIDTH 16
+#define        MCDI_EVENT_FWALERT_DATA_LBN 8
+#define        MCDI_EVENT_FWALERT_DATA_WIDTH 24
+#define        MCDI_EVENT_FWALERT_REASON_LBN 0
+#define        MCDI_EVENT_FWALERT_REASON_WIDTH 8
+#define          MCDI_EVENT_FWALERT_REASON_SRAM_ACCESS 0x1 /* enum */
+#define        MCDI_EVENT_FLR_VF_LBN 0
+#define        MCDI_EVENT_FLR_VF_WIDTH 8
+#define       MCDI_EVENT_DATA_LBN 0
+#define       MCDI_EVENT_DATA_WIDTH 32
+#define       MCDI_EVENT_SRC_LBN 36
+#define       MCDI_EVENT_SRC_WIDTH 8
+#define       MCDI_EVENT_EV_CODE_LBN 60
+#define       MCDI_EVENT_EV_CODE_WIDTH 4
+#define       MCDI_EVENT_CODE_LBN 44
+#define       MCDI_EVENT_CODE_WIDTH 8
+#define          MCDI_EVENT_CODE_BADSSERT 0x1 /* enum */
+#define          MCDI_EVENT_CODE_PMNOTICE 0x2 /* enum */
+#define          MCDI_EVENT_CODE_CMDDONE 0x3 /* enum */
+#define          MCDI_EVENT_CODE_LINKCHANGE 0x4 /* enum */
+#define          MCDI_EVENT_CODE_SENSOREVT 0x5 /* enum */
+#define          MCDI_EVENT_CODE_SCHEDERR 0x6 /* enum */
+#define          MCDI_EVENT_CODE_REBOOT 0x7 /* enum */
+#define          MCDI_EVENT_CODE_MAC_STATS_DMA 0x8 /* enum */
+#define          MCDI_EVENT_CODE_FWALERT 0x9 /* enum */
+#define          MCDI_EVENT_CODE_FLR 0xa /* enum */
+#define       MCDI_EVENT_CMDDONE_DATA_OFST 0
+#define       MCDI_EVENT_CMDDONE_DATA_LBN 0
+#define       MCDI_EVENT_CMDDONE_DATA_WIDTH 32
+#define       MCDI_EVENT_LINKCHANGE_DATA_OFST 0
+#define       MCDI_EVENT_LINKCHANGE_DATA_LBN 0
+#define       MCDI_EVENT_LINKCHANGE_DATA_WIDTH 32
+#define       MCDI_EVENT_SENSOREVT_DATA_OFST 0
+#define       MCDI_EVENT_SENSOREVT_DATA_LBN 0
+#define       MCDI_EVENT_SENSOREVT_DATA_WIDTH 32
+#define       MCDI_EVENT_MAC_STATS_DMA_GENERATION_OFST 0
+#define       MCDI_EVENT_MAC_STATS_DMA_GENERATION_LBN 0
+#define       MCDI_EVENT_MAC_STATS_DMA_GENERATION_WIDTH 32
+
+
+/***********************************/
+/* MC_CMD_READ32
+ * Read multiple 32byte words from MC memory.
+ */
+#define MC_CMD_READ32 0x1
+
+/* MC_CMD_READ32_IN msgrequest */
+#define    MC_CMD_READ32_IN_LEN 8
+#define       MC_CMD_READ32_IN_ADDR_OFST 0
+#define       MC_CMD_READ32_IN_NUMWORDS_OFST 4
+
+/* MC_CMD_READ32_OUT msgresponse */
+#define    MC_CMD_READ32_OUT_LENMIN 4
+#define    MC_CMD_READ32_OUT_LENMAX 252
+#define    MC_CMD_READ32_OUT_LEN(num) (0+4*(num))
+#define       MC_CMD_READ32_OUT_BUFFER_OFST 0
+#define       MC_CMD_READ32_OUT_BUFFER_LEN 4
+#define       MC_CMD_READ32_OUT_BUFFER_MINNUM 1
+#define       MC_CMD_READ32_OUT_BUFFER_MAXNUM 63
+
+
+/***********************************/
+/* MC_CMD_WRITE32
+ * Write multiple 32byte words to MC memory.
+ */
+#define MC_CMD_WRITE32 0x2
+
+/* MC_CMD_WRITE32_IN msgrequest */
+#define    MC_CMD_WRITE32_IN_LENMIN 8
+#define    MC_CMD_WRITE32_IN_LENMAX 252
+#define    MC_CMD_WRITE32_IN_LEN(num) (4+4*(num))
+#define       MC_CMD_WRITE32_IN_ADDR_OFST 0
+#define       MC_CMD_WRITE32_IN_BUFFER_OFST 4
+#define       MC_CMD_WRITE32_IN_BUFFER_LEN 4
+#define       MC_CMD_WRITE32_IN_BUFFER_MINNUM 1
+#define       MC_CMD_WRITE32_IN_BUFFER_MAXNUM 62
+
+/* MC_CMD_WRITE32_OUT msgresponse */
+#define    MC_CMD_WRITE32_OUT_LEN 0
+
+
+/***********************************/
+/* MC_CMD_COPYCODE
+ * Copy MC code between two locations and jump.
+ */
+#define MC_CMD_COPYCODE 0x3
+
+/* MC_CMD_COPYCODE_IN msgrequest */
+#define    MC_CMD_COPYCODE_IN_LEN 16
+#define       MC_CMD_COPYCODE_IN_SRC_ADDR_OFST 0
+#define       MC_CMD_COPYCODE_IN_DEST_ADDR_OFST 4
+#define       MC_CMD_COPYCODE_IN_NUMWORDS_OFST 8
+#define       MC_CMD_COPYCODE_IN_JUMP_OFST 12
+#define          MC_CMD_COPYCODE_JUMP_NONE 0x1 /* enum */
+
+/* MC_CMD_COPYCODE_OUT msgresponse */
+#define    MC_CMD_COPYCODE_OUT_LEN 0
+
+
+/***********************************/
+/* MC_CMD_SET_FUNC 
+ */
+#define MC_CMD_SET_FUNC  0x4
+
+/* MC_CMD_SET_FUNC_IN msgrequest */
+#define    MC_CMD_SET_FUNC_IN_LEN 4
+#define       MC_CMD_SET_FUNC_IN_FUNC_OFST 0
+
+/* MC_CMD_SET_FUNC_OUT msgresponse */
+#define    MC_CMD_SET_FUNC_OUT_LEN 0
+
+
+/***********************************/
+/* MC_CMD_GET_BOOT_STATUS
+ */
+#define MC_CMD_GET_BOOT_STATUS 0x5
+
+/* MC_CMD_GET_BOOT_STATUS_IN msgrequest */
+#define    MC_CMD_GET_BOOT_STATUS_IN_LEN 0
+
+/* MC_CMD_GET_BOOT_STATUS_OUT msgresponse */
+#define    MC_CMD_GET_BOOT_STATUS_OUT_LEN 8
+#define       MC_CMD_GET_BOOT_STATUS_OUT_BOOT_OFFSET_OFST 0
+#define       MC_CMD_GET_BOOT_STATUS_OUT_FLAGS_OFST 4
+#define        MC_CMD_GET_BOOT_STATUS_OUT_FLAGS_WATCHDOG_LBN 0
+#define        MC_CMD_GET_BOOT_STATUS_OUT_FLAGS_WATCHDOG_WIDTH 1
+#define        MC_CMD_GET_BOOT_STATUS_OUT_FLAGS_PRIMARY_LBN 1
+#define        MC_CMD_GET_BOOT_STATUS_OUT_FLAGS_PRIMARY_WIDTH 1
+#define        MC_CMD_GET_BOOT_STATUS_OUT_FLAGS_BACKUP_LBN 2
+#define        MC_CMD_GET_BOOT_STATUS_OUT_FLAGS_BACKUP_WIDTH 1
+
+
+/***********************************/
+/* MC_CMD_GET_ASSERTS 
+ * Get and clear any assertion status.
+ */
+#define MC_CMD_GET_ASSERTS  0x6
+
+/* MC_CMD_GET_ASSERTS_IN msgrequest */
+#define    MC_CMD_GET_ASSERTS_IN_LEN 4
+#define       MC_CMD_GET_ASSERTS_IN_CLEAR_OFST 0
+
+/* MC_CMD_GET_ASSERTS_OUT msgresponse */
+#define    MC_CMD_GET_ASSERTS_OUT_LEN 140
+#define       MC_CMD_GET_ASSERTS_OUT_GLOBAL_FLAGS_OFST 0
+#define          MC_CMD_GET_ASSERTS_FLAGS_NO_FAILS 0x1 /* enum */
+#define          MC_CMD_GET_ASSERTS_FLAGS_SYS_FAIL 0x2 /* enum */
+#define          MC_CMD_GET_ASSERTS_FLAGS_THR_FAIL 0x3 /* enum */
+#define          MC_CMD_GET_ASSERTS_FLAGS_WDOG_FIRED 0x4 /* enum */
+#define       MC_CMD_GET_ASSERTS_OUT_SAVED_PC_OFFS_OFST 4
+#define       MC_CMD_GET_ASSERTS_OUT_GP_REGS_OFFS_OFST 8
+#define       MC_CMD_GET_ASSERTS_OUT_GP_REGS_OFFS_LEN 4
+#define       MC_CMD_GET_ASSERTS_OUT_GP_REGS_OFFS_NUM 31
+#define       MC_CMD_GET_ASSERTS_OUT_THREAD_OFFS_OFST 132
+#define       MC_CMD_GET_ASSERTS_OUT_RESERVED_OFST 136
+
+
+/***********************************/
+/* MC_CMD_LOG_CTRL 
+ * Configure the output stream for various events and messages.
+ */
+#define MC_CMD_LOG_CTRL  0x7
+
+/* MC_CMD_LOG_CTRL_IN msgrequest */
+#define    MC_CMD_LOG_CTRL_IN_LEN 8
+#define       MC_CMD_LOG_CTRL_IN_LOG_DEST_OFST 0
+#define          MC_CMD_LOG_CTRL_IN_LOG_DEST_UART 0x1 /* enum */
+#define          MC_CMD_LOG_CTRL_IN_LOG_DEST_EVQ 0x2 /* enum */
+#define       MC_CMD_LOG_CTRL_IN_LOG_DEST_EVQ_OFST 4
+
+/* MC_CMD_LOG_CTRL_OUT msgresponse */
+#define    MC_CMD_LOG_CTRL_OUT_LEN 0
+
+
+/***********************************/
+/* MC_CMD_GET_VERSION 
+ * Get version information about the MC firmware.
+ */
+#define MC_CMD_GET_VERSION  0x8
+
+/* MC_CMD_GET_VERSION_IN msgrequest */
+#define    MC_CMD_GET_VERSION_IN_LEN 0
+
+/* MC_CMD_GET_VERSION_V0_OUT msgresponse */
+#define    MC_CMD_GET_VERSION_V0_OUT_LEN 4
+#define       MC_CMD_GET_VERSION_OUT_FIRMWARE_OFST 0
+#define          MC_CMD_GET_VERSION_OUT_FIRMWARE_ANY 0xffffffff /* enum */
+#define          MC_CMD_GET_VERSION_OUT_FIRMWARE_BOOTROM 0xb0070000 /* enum */
+
+/* MC_CMD_GET_VERSION_OUT msgresponse */
+#define    MC_CMD_GET_VERSION_OUT_LEN 32
+/*            MC_CMD_GET_VERSION_OUT_FIRMWARE_OFST 0 */
+/*            Enum values, see field(s): */
+/*               MC_CMD_GET_VERSION_V0_OUT/MC_CMD_GET_VERSION_OUT_FIRMWARE */
+#define       MC_CMD_GET_VERSION_OUT_PCOL_OFST 4
+#define       MC_CMD_GET_VERSION_OUT_SUPPORTED_FUNCS_OFST 8
+#define       MC_CMD_GET_VERSION_OUT_SUPPORTED_FUNCS_LEN 16
+#define       MC_CMD_GET_VERSION_OUT_VERSION_OFST 24
+#define       MC_CMD_GET_VERSION_OUT_VERSION_LEN 8
+#define       MC_CMD_GET_VERSION_OUT_VERSION_LO_OFST 24
+#define       MC_CMD_GET_VERSION_OUT_VERSION_HI_OFST 28
+
+
+/***********************************/
+/* MC_CMD_CSR_READ32 
+ * Read 32bit words from the indirect memory map.
+ */
+#define MC_CMD_CSR_READ32  0xc
+
+/* MC_CMD_CSR_READ32_IN msgrequest */
+#define    MC_CMD_CSR_READ32_IN_LEN 12
+#define       MC_CMD_CSR_READ32_IN_ADDR_OFST 0
+#define       MC_CMD_CSR_READ32_IN_STEP_OFST 4
+#define       MC_CMD_CSR_READ32_IN_NUMWORDS_OFST 8
+
+/* MC_CMD_CSR_READ32_OUT msgresponse */
+#define    MC_CMD_CSR_READ32_OUT_LENMIN 8
+#define    MC_CMD_CSR_READ32_OUT_LENMAX 252
+#define    MC_CMD_CSR_READ32_OUT_LEN(num) (4+4*(num))
+#define       MC_CMD_CSR_READ32_OUT_IREG_STATUS_OFST 0
+#define       MC_CMD_CSR_READ32_OUT_BUFFER_OFST 4
+#define       MC_CMD_CSR_READ32_OUT_BUFFER_LEN 4
+#define       MC_CMD_CSR_READ32_OUT_BUFFER_MINNUM 1
+#define       MC_CMD_CSR_READ32_OUT_BUFFER_MAXNUM 62
+
+
+/***********************************/
+/* MC_CMD_CSR_WRITE32 
+ * Write 32bit dwords to the indirect memory map.
+ */
+#define MC_CMD_CSR_WRITE32  0xd
+
+/* MC_CMD_CSR_WRITE32_IN msgrequest */
+#define    MC_CMD_CSR_WRITE32_IN_LENMIN 12
+#define    MC_CMD_CSR_WRITE32_IN_LENMAX 252
+#define    MC_CMD_CSR_WRITE32_IN_LEN(num) (8+4*(num))
+#define       MC_CMD_CSR_WRITE32_IN_ADDR_OFST 0
+#define       MC_CMD_CSR_WRITE32_IN_STEP_OFST 4
+#define       MC_CMD_CSR_WRITE32_IN_BUFFER_OFST 8
+#define       MC_CMD_CSR_WRITE32_IN_BUFFER_LEN 4
+#define       MC_CMD_CSR_WRITE32_IN_BUFFER_MINNUM 1
+#define       MC_CMD_CSR_WRITE32_IN_BUFFER_MAXNUM 61
+
+/* MC_CMD_CSR_WRITE32_OUT msgresponse */
+#define    MC_CMD_CSR_WRITE32_OUT_LEN 4
+#define       MC_CMD_CSR_WRITE32_OUT_STATUS_OFST 0
+
+
+/***********************************/
+/* MC_CMD_STACKINFO 
+ * Get stack information.
+ */
+#define MC_CMD_STACKINFO  0xf
+
+/* MC_CMD_STACKINFO_IN msgrequest */
+#define    MC_CMD_STACKINFO_IN_LEN 0
+
+/* MC_CMD_STACKINFO_OUT msgresponse */
+#define    MC_CMD_STACKINFO_OUT_LENMIN 12
+#define    MC_CMD_STACKINFO_OUT_LENMAX 252
+#define    MC_CMD_STACKINFO_OUT_LEN(num) (0+12*(num))
+#define       MC_CMD_STACKINFO_OUT_THREAD_INFO_OFST 0
+#define       MC_CMD_STACKINFO_OUT_THREAD_INFO_LEN 12
+#define       MC_CMD_STACKINFO_OUT_THREAD_INFO_MINNUM 1
+#define       MC_CMD_STACKINFO_OUT_THREAD_INFO_MAXNUM 21
+
+
+/***********************************/
+/* MC_CMD_MDIO_READ 
+ * MDIO register read.
+ */
+#define MC_CMD_MDIO_READ  0x10
+
+/* MC_CMD_MDIO_READ_IN msgrequest */
+#define    MC_CMD_MDIO_READ_IN_LEN 16
+#define       MC_CMD_MDIO_READ_IN_BUS_OFST 0
+#define          MC_CMD_MDIO_BUS_INTERNAL 0x0 /* enum */
+#define          MC_CMD_MDIO_BUS_EXTERNAL 0x1 /* enum */
+#define       MC_CMD_MDIO_READ_IN_PRTAD_OFST 4
+#define       MC_CMD_MDIO_READ_IN_DEVAD_OFST 8
+#define          MC_CMD_MDIO_CLAUSE22 0x20 /* enum */
+#define       MC_CMD_MDIO_READ_IN_ADDR_OFST 12
+
+/* MC_CMD_MDIO_READ_OUT msgresponse */
+#define    MC_CMD_MDIO_READ_OUT_LEN 8
+#define       MC_CMD_MDIO_READ_OUT_VALUE_OFST 0
+#define       MC_CMD_MDIO_READ_OUT_STATUS_OFST 4
+#define          MC_CMD_MDIO_STATUS_GOOD 0x8 /* enum */
+
+
+/***********************************/
+/* MC_CMD_MDIO_WRITE 
+ * MDIO register write.
+ */
+#define MC_CMD_MDIO_WRITE  0x11
+
+/* MC_CMD_MDIO_WRITE_IN msgrequest */
+#define    MC_CMD_MDIO_WRITE_IN_LEN 20
+#define       MC_CMD_MDIO_WRITE_IN_BUS_OFST 0
+/*               MC_CMD_MDIO_BUS_INTERNAL 0x0 */
+/*               MC_CMD_MDIO_BUS_EXTERNAL 0x1 */
+#define       MC_CMD_MDIO_WRITE_IN_PRTAD_OFST 4
+#define       MC_CMD_MDIO_WRITE_IN_DEVAD_OFST 8
+/*               MC_CMD_MDIO_CLAUSE22 0x20 */
+#define       MC_CMD_MDIO_WRITE_IN_ADDR_OFST 12
+#define       MC_CMD_MDIO_WRITE_IN_VALUE_OFST 16
+
+/* MC_CMD_MDIO_WRITE_OUT msgresponse */
+#define    MC_CMD_MDIO_WRITE_OUT_LEN 4
+#define       MC_CMD_MDIO_WRITE_OUT_STATUS_OFST 0
+/*               MC_CMD_MDIO_STATUS_GOOD 0x8 */
+
+
+/***********************************/
+/* MC_CMD_DBI_WRITE 
+ * Write DBI register(s).
+ */
+#define MC_CMD_DBI_WRITE  0x12
+
+/* MC_CMD_DBI_WRITE_IN msgrequest */
+#define    MC_CMD_DBI_WRITE_IN_LENMIN 12
+#define    MC_CMD_DBI_WRITE_IN_LENMAX 252
+#define    MC_CMD_DBI_WRITE_IN_LEN(num) (0+12*(num))
+#define       MC_CMD_DBI_WRITE_IN_DBIWROP_OFST 0
+#define       MC_CMD_DBI_WRITE_IN_DBIWROP_LEN 12
+#define       MC_CMD_DBI_WRITE_IN_DBIWROP_MINNUM 1
+#define       MC_CMD_DBI_WRITE_IN_DBIWROP_MAXNUM 21
+
+/* MC_CMD_DBI_WRITE_OUT msgresponse */
+#define    MC_CMD_DBI_WRITE_OUT_LEN 0
+
+/* MC_CMD_DBIWROP_TYPEDEF structuredef */
+#define    MC_CMD_DBIWROP_TYPEDEF_LEN 12
+#define       MC_CMD_DBIWROP_TYPEDEF_ADDRESS_OFST 0
+#define       MC_CMD_DBIWROP_TYPEDEF_ADDRESS_LBN 0
+#define       MC_CMD_DBIWROP_TYPEDEF_ADDRESS_WIDTH 32
+#define       MC_CMD_DBIWROP_TYPEDEF_BYTE_MASK_OFST 4
+#define       MC_CMD_DBIWROP_TYPEDEF_BYTE_MASK_LBN 32
+#define       MC_CMD_DBIWROP_TYPEDEF_BYTE_MASK_WIDTH 32
+#define       MC_CMD_DBIWROP_TYPEDEF_VALUE_OFST 8
+#define       MC_CMD_DBIWROP_TYPEDEF_VALUE_LBN 64
+#define       MC_CMD_DBIWROP_TYPEDEF_VALUE_WIDTH 32
+
+
+/***********************************/
+/* MC_CMD_PORT_READ32 
+ * Read a 32-bit register from the indirect port register map.
+ */
+#define MC_CMD_PORT_READ32  0x14
+
+/* MC_CMD_PORT_READ32_IN msgrequest */
+#define    MC_CMD_PORT_READ32_IN_LEN 4
+#define       MC_CMD_PORT_READ32_IN_ADDR_OFST 0
+
+/* MC_CMD_PORT_READ32_OUT msgresponse */
+#define    MC_CMD_PORT_READ32_OUT_LEN 8
+#define       MC_CMD_PORT_READ32_OUT_VALUE_OFST 0
+#define       MC_CMD_PORT_READ32_OUT_STATUS_OFST 4
+
+
+/***********************************/
+/* MC_CMD_PORT_WRITE32 
+ * Write a 32-bit register to the indirect port register map.
+ */
+#define MC_CMD_PORT_WRITE32  0x15
+
+/* MC_CMD_PORT_WRITE32_IN msgrequest */
+#define    MC_CMD_PORT_WRITE32_IN_LEN 8
+#define       MC_CMD_PORT_WRITE32_IN_ADDR_OFST 0
+#define       MC_CMD_PORT_WRITE32_IN_VALUE_OFST 4
+
+/* MC_CMD_PORT_WRITE32_OUT msgresponse */
+#define    MC_CMD_PORT_WRITE32_OUT_LEN 4
+#define       MC_CMD_PORT_WRITE32_OUT_STATUS_OFST 0
+
+
+/***********************************/
+/* MC_CMD_PORT_READ128 
+ * Read a 128-bit register from the indirect port register map.
+ */
+#define MC_CMD_PORT_READ128  0x16
+
+/* MC_CMD_PORT_READ128_IN msgrequest */
+#define    MC_CMD_PORT_READ128_IN_LEN 4
+#define       MC_CMD_PORT_READ128_IN_ADDR_OFST 0
+
+/* MC_CMD_PORT_READ128_OUT msgresponse */
+#define    MC_CMD_PORT_READ128_OUT_LEN 20
+#define       MC_CMD_PORT_READ128_OUT_VALUE_OFST 0
+#define       MC_CMD_PORT_READ128_OUT_VALUE_LEN 16
+#define       MC_CMD_PORT_READ128_OUT_STATUS_OFST 16
+
+
+/***********************************/
+/* MC_CMD_PORT_WRITE128 
+ * Write a 128-bit register to the indirect port register map.
+ */
+#define MC_CMD_PORT_WRITE128  0x17
+
+/* MC_CMD_PORT_WRITE128_IN msgrequest */
+#define    MC_CMD_PORT_WRITE128_IN_LEN 20
+#define       MC_CMD_PORT_WRITE128_IN_ADDR_OFST 0
+#define       MC_CMD_PORT_WRITE128_IN_VALUE_OFST 4
+#define       MC_CMD_PORT_WRITE128_IN_VALUE_LEN 16
+
+/* MC_CMD_PORT_WRITE128_OUT msgresponse */
+#define    MC_CMD_PORT_WRITE128_OUT_LEN 4
+#define       MC_CMD_PORT_WRITE128_OUT_STATUS_OFST 0
+
+
+/***********************************/
+/* MC_CMD_GET_BOARD_CFG 
+ * Returns the MC firmware configuration structure.
+ */
+#define MC_CMD_GET_BOARD_CFG  0x18
+
+/* MC_CMD_GET_BOARD_CFG_IN msgrequest */
+#define    MC_CMD_GET_BOARD_CFG_IN_LEN 0
+
+/* MC_CMD_GET_BOARD_CFG_OUT msgresponse */
+#define    MC_CMD_GET_BOARD_CFG_OUT_LEN 96
+#define       MC_CMD_GET_BOARD_CFG_OUT_BOARD_TYPE_OFST 0
+#define       MC_CMD_GET_BOARD_CFG_OUT_BOARD_NAME_OFST 4
+#define       MC_CMD_GET_BOARD_CFG_OUT_BOARD_NAME_LEN 32
+#define       MC_CMD_GET_BOARD_CFG_OUT_CAPABILITIES_PORT0_OFST 36
+#define          MC_CMD_CAPABILITIES_SMALL_BUF_TBL_LBN 0x0 /* enum */
+#define          MC_CMD_CAPABILITIES_SMALL_BUF_TBL_WIDTH 0x1 /* enum */
+#define       MC_CMD_GET_BOARD_CFG_OUT_CAPABILITIES_PORT1_OFST 40
+/*            Enum values, see field(s): */
+/*               CAPABILITIES_PORT0 */
+#define       MC_CMD_GET_BOARD_CFG_OUT_MAC_ADDR_BASE_PORT0_OFST 44
+#define       MC_CMD_GET_BOARD_CFG_OUT_MAC_ADDR_BASE_PORT0_LEN 6
+#define       MC_CMD_GET_BOARD_CFG_OUT_MAC_ADDR_BASE_PORT1_OFST 50
+#define       MC_CMD_GET_BOARD_CFG_OUT_MAC_ADDR_BASE_PORT1_LEN 6
+#define       MC_CMD_GET_BOARD_CFG_OUT_MAC_COUNT_PORT0_OFST 56
+#define       MC_CMD_GET_BOARD_CFG_OUT_MAC_COUNT_PORT1_OFST 60
+#define       MC_CMD_GET_BOARD_CFG_OUT_MAC_STRIDE_PORT0_OFST 64
+#define       MC_CMD_GET_BOARD_CFG_OUT_MAC_STRIDE_PORT1_OFST 68
+#define       MC_CMD_GET_BOARD_CFG_OUT_FW_SUBTYPE_LIST_OFST 72
+#define       MC_CMD_GET_BOARD_CFG_OUT_FW_SUBTYPE_LIST_LEN 2
+#define       MC_CMD_GET_BOARD_CFG_OUT_FW_SUBTYPE_LIST_NUM 12
+
+
+/***********************************/
+/* MC_CMD_DBI_READX 
+ * Read DBI register(s).
+ */
+#define MC_CMD_DBI_READX  0x19
+
+/* MC_CMD_DBI_READX_IN msgrequest */
+#define    MC_CMD_DBI_READX_IN_LENMIN 8
+#define    MC_CMD_DBI_READX_IN_LENMAX 248
+#define    MC_CMD_DBI_READX_IN_LEN(num) (0+8*(num))
+#define       MC_CMD_DBI_READX_IN_DBIRDOP_OFST 0
+#define       MC_CMD_DBI_READX_IN_DBIRDOP_LEN 8
+#define       MC_CMD_DBI_READX_IN_DBIRDOP_LO_OFST 0
+#define       MC_CMD_DBI_READX_IN_DBIRDOP_HI_OFST 4
+#define       MC_CMD_DBI_READX_IN_DBIRDOP_MINNUM 1
+#define       MC_CMD_DBI_READX_IN_DBIRDOP_MAXNUM 31
+
+/* MC_CMD_DBI_READX_OUT msgresponse */
+#define    MC_CMD_DBI_READX_OUT_LENMIN 4
+#define    MC_CMD_DBI_READX_OUT_LENMAX 252
+#define    MC_CMD_DBI_READX_OUT_LEN(num) (0+4*(num))
+#define       MC_CMD_DBI_READX_OUT_VALUE_OFST 0
+#define       MC_CMD_DBI_READX_OUT_VALUE_LEN 4
+#define       MC_CMD_DBI_READX_OUT_VALUE_MINNUM 1
+#define       MC_CMD_DBI_READX_OUT_VALUE_MAXNUM 63
+
+
+/***********************************/
+/* MC_CMD_SET_RAND_SEED 
+ * Set the 16byte seed for the MC psuedo-random generator.
+ */
+#define MC_CMD_SET_RAND_SEED  0x1a
+
+/* MC_CMD_SET_RAND_SEED_IN msgrequest */
+#define    MC_CMD_SET_RAND_SEED_IN_LEN 16
+#define       MC_CMD_SET_RAND_SEED_IN_SEED_OFST 0
+#define       MC_CMD_SET_RAND_SEED_IN_SEED_LEN 16
+
+/* MC_CMD_SET_RAND_SEED_OUT msgresponse */
+#define    MC_CMD_SET_RAND_SEED_OUT_LEN 0
+
+
+/***********************************/
+/* MC_CMD_LTSSM_HIST 
+ * Retrieve the history of the PCIE LTSSM.
+ */
+#define MC_CMD_LTSSM_HIST  0x1b
+
+/* MC_CMD_LTSSM_HIST_IN msgrequest */
+#define    MC_CMD_LTSSM_HIST_IN_LEN 0
+
+/* MC_CMD_LTSSM_HIST_OUT msgresponse */
+#define    MC_CMD_LTSSM_HIST_OUT_LENMIN 0
+#define    MC_CMD_LTSSM_HIST_OUT_LENMAX 252
+#define    MC_CMD_LTSSM_HIST_OUT_LEN(num) (0+4*(num))
+#define       MC_CMD_LTSSM_HIST_OUT_DATA_OFST 0
+#define       MC_CMD_LTSSM_HIST_OUT_DATA_LEN 4
+#define       MC_CMD_LTSSM_HIST_OUT_DATA_MINNUM 0
+#define       MC_CMD_LTSSM_HIST_OUT_DATA_MAXNUM 63
+
+
+/***********************************/
+/* MC_CMD_DRV_ATTACH 
+ * Inform MCPU that this port is managed on the host.
+ */
+#define MC_CMD_DRV_ATTACH  0x1c
+
+/* MC_CMD_DRV_ATTACH_IN msgrequest */
+#define    MC_CMD_DRV_ATTACH_IN_LEN 8
+#define       MC_CMD_DRV_ATTACH_IN_NEW_STATE_OFST 0
+#define       MC_CMD_DRV_ATTACH_IN_UPDATE_OFST 4
+
+/* MC_CMD_DRV_ATTACH_OUT msgresponse */
+#define    MC_CMD_DRV_ATTACH_OUT_LEN 4
+#define       MC_CMD_DRV_ATTACH_OUT_OLD_STATE_OFST 0
+
+
+/***********************************/
+/* MC_CMD_NCSI_PROD 
+ * Trigger an NC-SI event.
+ */
+#define MC_CMD_NCSI_PROD  0x1d
+
+/* MC_CMD_NCSI_PROD_IN msgrequest */
+#define    MC_CMD_NCSI_PROD_IN_LEN 4
+#define       MC_CMD_NCSI_PROD_IN_EVENTS_OFST 0
+#define          MC_CMD_NCSI_PROD_LINKCHANGE 0x0 /* enum */
+#define          MC_CMD_NCSI_PROD_RESET 0x1 /* enum */
+#define          MC_CMD_NCSI_PROD_DRVATTACH 0x2 /* enum */
+#define        MC_CMD_NCSI_PROD_IN_LINKCHANGE_LBN 0
+#define        MC_CMD_NCSI_PROD_IN_LINKCHANGE_WIDTH 1
+#define        MC_CMD_NCSI_PROD_IN_RESET_LBN 1
+#define        MC_CMD_NCSI_PROD_IN_RESET_WIDTH 1
+#define        MC_CMD_NCSI_PROD_IN_DRVATTACH_LBN 2
+#define        MC_CMD_NCSI_PROD_IN_DRVATTACH_WIDTH 1
+
+/* MC_CMD_NCSI_PROD_OUT msgresponse */
+#define    MC_CMD_NCSI_PROD_OUT_LEN 0
+
+
+/***********************************/
+/* MC_CMD_SHMUART 
+ * Route UART output to circular buffer in shared memory instead.
+ */
+#define MC_CMD_SHMUART  0x1f
+
+/* MC_CMD_SHMUART_IN msgrequest */
+#define    MC_CMD_SHMUART_IN_LEN 4
+#define       MC_CMD_SHMUART_IN_FLAG_OFST 0
+
+/* MC_CMD_SHMUART_OUT msgresponse */
+#define    MC_CMD_SHMUART_OUT_LEN 0
+
+
+/***********************************/
+/* MC_CMD_PORT_RESET 
+ * Generic per-port reset.
+ */
+#define MC_CMD_PORT_RESET  0x20
+
+/* MC_CMD_PORT_RESET_IN msgrequest */
+#define    MC_CMD_PORT_RESET_IN_LEN 0
+
+/* MC_CMD_PORT_RESET_OUT msgresponse */
+#define    MC_CMD_PORT_RESET_OUT_LEN 0
+
+
+/***********************************/
+/* MC_CMD_PCIE_CREDITS 
+ * Read instantaneous and minimum flow control thresholds.
+ */
+#define MC_CMD_PCIE_CREDITS  0x21
+
+/* MC_CMD_PCIE_CREDITS_IN msgrequest */
+#define    MC_CMD_PCIE_CREDITS_IN_LEN 8
+#define       MC_CMD_PCIE_CREDITS_IN_POLL_PERIOD_OFST 0
+#define       MC_CMD_PCIE_CREDITS_IN_WIPE_OFST 4
+
+/* MC_CMD_PCIE_CREDITS_OUT msgresponse */
+#define    MC_CMD_PCIE_CREDITS_OUT_LEN 16
+#define       MC_CMD_PCIE_CREDITS_OUT_CURRENT_P_HDR_OFST 0
+#define       MC_CMD_PCIE_CREDITS_OUT_CURRENT_P_HDR_LEN 2
+#define       MC_CMD_PCIE_CREDITS_OUT_CURRENT_P_DATA_OFST 2
+#define       MC_CMD_PCIE_CREDITS_OUT_CURRENT_P_DATA_LEN 2
+#define       MC_CMD_PCIE_CREDITS_OUT_CURRENT_NP_HDR_OFST 4
+#define       MC_CMD_PCIE_CREDITS_OUT_CURRENT_NP_HDR_LEN 2
+#define       MC_CMD_PCIE_CREDITS_OUT_CURRENT_NP_DATA_OFST 6
+#define       MC_CMD_PCIE_CREDITS_OUT_CURRENT_NP_DATA_LEN 2
+#define       MC_CMD_PCIE_CREDITS_OUT_MINIMUM_P_HDR_OFST 8
+#define       MC_CMD_PCIE_CREDITS_OUT_MINIMUM_P_HDR_LEN 2
+#define       MC_CMD_PCIE_CREDITS_OUT_MINIMUM_P_DATA_OFST 10
+#define       MC_CMD_PCIE_CREDITS_OUT_MINIMUM_P_DATA_LEN 2
+#define       MC_CMD_PCIE_CREDITS_OUT_MINIMUM_NP_HDR_OFST 12
+#define       MC_CMD_PCIE_CREDITS_OUT_MINIMUM_NP_HDR_LEN 2
+#define       MC_CMD_PCIE_CREDITS_OUT_MINIMUM_NP_DATA_OFST 14
+#define       MC_CMD_PCIE_CREDITS_OUT_MINIMUM_NP_DATA_LEN 2
+
+
+/***********************************/
+/* MC_CMD_RXD_MONITOR 
+ * Get histogram of RX queue fill level.
+ */
+#define MC_CMD_RXD_MONITOR  0x22
+
+/* MC_CMD_RXD_MONITOR_IN msgrequest */
+#define    MC_CMD_RXD_MONITOR_IN_LEN 12
+#define       MC_CMD_RXD_MONITOR_IN_QID_OFST 0
+#define       MC_CMD_RXD_MONITOR_IN_POLL_PERIOD_OFST 4
+#define       MC_CMD_RXD_MONITOR_IN_WIPE_OFST 8
+
+/* MC_CMD_RXD_MONITOR_OUT msgresponse */
+#define    MC_CMD_RXD_MONITOR_OUT_LEN 80
+#define       MC_CMD_RXD_MONITOR_OUT_QID_OFST 0
+#define       MC_CMD_RXD_MONITOR_OUT_RING_FILL_OFST 4
+#define       MC_CMD_RXD_MONITOR_OUT_CACHE_FILL_OFST 8
+#define       MC_CMD_RXD_MONITOR_OUT_RING_LT_1_OFST 12
+#define       MC_CMD_RXD_MONITOR_OUT_RING_LT_2_OFST 16
+#define       MC_CMD_RXD_MONITOR_OUT_RING_LT_4_OFST 20
+#define       MC_CMD_RXD_MONITOR_OUT_RING_LT_8_OFST 24
+#define       MC_CMD_RXD_MONITOR_OUT_RING_LT_16_OFST 28
+#define       MC_CMD_RXD_MONITOR_OUT_RING_LT_32_OFST 32
+#define       MC_CMD_RXD_MONITOR_OUT_RING_LT_64_OFST 36
+#define       MC_CMD_RXD_MONITOR_OUT_RING_LT_128_OFST 40
+#define       MC_CMD_RXD_MONITOR_OUT_RING_LT_256_OFST 44
+#define       MC_CMD_RXD_MONITOR_OUT_RING_GE_256_OFST 48
+#define       MC_CMD_RXD_MONITOR_OUT_CACHE_LT_1_OFST 52
+#define       MC_CMD_RXD_MONITOR_OUT_CACHE_LT_2_OFST 56
+#define       MC_CMD_RXD_MONITOR_OUT_CACHE_LT_4_OFST 60
+#define       MC_CMD_RXD_MONITOR_OUT_CACHE_LT_8_OFST 64
+#define       MC_CMD_RXD_MONITOR_OUT_CACHE_LT_16_OFST 68
+#define       MC_CMD_RXD_MONITOR_OUT_CACHE_LT_32_OFST 72
+#define       MC_CMD_RXD_MONITOR_OUT_CACHE_GE_32_OFST 76
+
+
+/***********************************/
+/* MC_CMD_GET_PHY_CFG 
+ * Report PHY configuration.
+ */
+#define MC_CMD_GET_PHY_CFG  0x24
+
+/* MC_CMD_GET_PHY_CFG_IN msgrequest */
+#define    MC_CMD_GET_PHY_CFG_IN_LEN 0
+
+/* MC_CMD_GET_PHY_CFG_OUT msgresponse */
+#define    MC_CMD_GET_PHY_CFG_OUT_LEN 72
+#define       MC_CMD_GET_PHY_CFG_OUT_FLAGS_OFST 0
+#define        MC_CMD_GET_PHY_CFG_OUT_PRESENT_LBN 0
+#define        MC_CMD_GET_PHY_CFG_OUT_PRESENT_WIDTH 1
+#define        MC_CMD_GET_PHY_CFG_OUT_BIST_CABLE_SHORT_LBN 1
+#define        MC_CMD_GET_PHY_CFG_OUT_BIST_CABLE_SHORT_WIDTH 1
+#define        MC_CMD_GET_PHY_CFG_OUT_BIST_CABLE_LONG_LBN 2
+#define        MC_CMD_GET_PHY_CFG_OUT_BIST_CABLE_LONG_WIDTH 1
+#define        MC_CMD_GET_PHY_CFG_OUT_LOWPOWER_LBN 3
+#define        MC_CMD_GET_PHY_CFG_OUT_LOWPOWER_WIDTH 1
+#define        MC_CMD_GET_PHY_CFG_OUT_POWEROFF_LBN 4
+#define        MC_CMD_GET_PHY_CFG_OUT_POWEROFF_WIDTH 1
+#define        MC_CMD_GET_PHY_CFG_OUT_TXDIS_LBN 5
+#define        MC_CMD_GET_PHY_CFG_OUT_TXDIS_WIDTH 1
+#define        MC_CMD_GET_PHY_CFG_OUT_BIST_LBN 6
+#define        MC_CMD_GET_PHY_CFG_OUT_BIST_WIDTH 1
+#define       MC_CMD_GET_PHY_CFG_OUT_TYPE_OFST 4
+#define       MC_CMD_GET_PHY_CFG_OUT_SUPPORTED_CAP_OFST 8
+#define        MC_CMD_PHY_CAP_10HDX_LBN 1
+#define        MC_CMD_PHY_CAP_10HDX_WIDTH 1
+#define        MC_CMD_PHY_CAP_10FDX_LBN 2
+#define        MC_CMD_PHY_CAP_10FDX_WIDTH 1
+#define        MC_CMD_PHY_CAP_100HDX_LBN 3
+#define        MC_CMD_PHY_CAP_100HDX_WIDTH 1
+#define        MC_CMD_PHY_CAP_100FDX_LBN 4
+#define        MC_CMD_PHY_CAP_100FDX_WIDTH 1
+#define        MC_CMD_PHY_CAP_1000HDX_LBN 5
+#define        MC_CMD_PHY_CAP_1000HDX_WIDTH 1
+#define        MC_CMD_PHY_CAP_1000FDX_LBN 6
+#define        MC_CMD_PHY_CAP_1000FDX_WIDTH 1
+#define        MC_CMD_PHY_CAP_10000FDX_LBN 7
+#define        MC_CMD_PHY_CAP_10000FDX_WIDTH 1
+#define        MC_CMD_PHY_CAP_PAUSE_LBN 8
+#define        MC_CMD_PHY_CAP_PAUSE_WIDTH 1
+#define        MC_CMD_PHY_CAP_ASYM_LBN 9
+#define        MC_CMD_PHY_CAP_ASYM_WIDTH 1
+#define        MC_CMD_PHY_CAP_AN_LBN 10
+#define        MC_CMD_PHY_CAP_AN_WIDTH 1
+#define       MC_CMD_GET_PHY_CFG_OUT_CHANNEL_OFST 12
+#define       MC_CMD_GET_PHY_CFG_OUT_PRT_OFST 16
+#define       MC_CMD_GET_PHY_CFG_OUT_STATS_MASK_OFST 20
+#define       MC_CMD_GET_PHY_CFG_OUT_NAME_OFST 24
+#define       MC_CMD_GET_PHY_CFG_OUT_NAME_LEN 20
+#define       MC_CMD_GET_PHY_CFG_OUT_MEDIA_TYPE_OFST 44
+#define          MC_CMD_MEDIA_XAUI 0x1 /* enum */
+#define          MC_CMD_MEDIA_CX4 0x2 /* enum */
+#define          MC_CMD_MEDIA_KX4 0x3 /* enum */
+#define          MC_CMD_MEDIA_XFP 0x4 /* enum */
+#define          MC_CMD_MEDIA_SFP_PLUS 0x5 /* enum */
+#define          MC_CMD_MEDIA_BASE_T 0x6 /* enum */
+#define       MC_CMD_GET_PHY_CFG_OUT_MMD_MASK_OFST 48
+#define          MC_CMD_MMD_CLAUSE22 0x0 /* enum */
+#define          MC_CMD_MMD_CLAUSE45_PMAPMD 0x1 /* enum */
+#define          MC_CMD_MMD_CLAUSE45_WIS 0x2 /* enum */
+#define          MC_CMD_MMD_CLAUSE45_PCS 0x3 /* enum */
+#define          MC_CMD_MMD_CLAUSE45_PHYXS 0x4 /* enum */
+#define          MC_CMD_MMD_CLAUSE45_DTEXS 0x5 /* enum */
+#define          MC_CMD_MMD_CLAUSE45_TC 0x6 /* enum */
+#define          MC_CMD_MMD_CLAUSE45_AN 0x7 /* enum */
+#define          MC_CMD_MMD_CLAUSE45_C22EXT 0x1d /* enum */
+#define          MC_CMD_MMD_CLAUSE45_VEND1 0x1e /* enum */
+#define          MC_CMD_MMD_CLAUSE45_VEND2 0x1f /* enum */
+#define       MC_CMD_GET_PHY_CFG_OUT_REVISION_OFST 52
+#define       MC_CMD_GET_PHY_CFG_OUT_REVISION_LEN 20
+
+
+/***********************************/
+/* MC_CMD_START_BIST 
+ * Start a BIST test on the PHY.
+ */
+#define MC_CMD_START_BIST  0x25
+
+/* MC_CMD_START_BIST_IN msgrequest */
+#define    MC_CMD_START_BIST_IN_LEN 4
+#define       MC_CMD_START_BIST_IN_TYPE_OFST 0
+#define          MC_CMD_PHY_BIST_CABLE_SHORT 0x1 /* enum */
+#define          MC_CMD_PHY_BIST_CABLE_LONG 0x2 /* enum */
+#define          MC_CMD_BPX_SERDES_BIST 0x3 /* enum */
+#define          MC_CMD_MC_LOOPBACK_BIST 0x4 /* enum */
+#define          MC_CMD_PHY_BIST 0x5 /* enum */
+
+/* MC_CMD_START_BIST_OUT msgresponse */
+#define    MC_CMD_START_BIST_OUT_LEN 0
+
+
+/***********************************/
+/* MC_CMD_POLL_BIST 
+ * Poll for BIST completion.
+ */
+#define MC_CMD_POLL_BIST  0x26
+
+/* MC_CMD_POLL_BIST_IN msgrequest */
+#define    MC_CMD_POLL_BIST_IN_LEN 0
+
+/* MC_CMD_POLL_BIST_OUT msgresponse */
+#define    MC_CMD_POLL_BIST_OUT_LEN 8
+#define       MC_CMD_POLL_BIST_OUT_RESULT_OFST 0
+#define          MC_CMD_POLL_BIST_RUNNING 0x1 /* enum */
+#define          MC_CMD_POLL_BIST_PASSED 0x2 /* enum */
+#define          MC_CMD_POLL_BIST_FAILED 0x3 /* enum */
+#define          MC_CMD_POLL_BIST_TIMEOUT 0x4 /* enum */
+#define       MC_CMD_POLL_BIST_OUT_PRIVATE_OFST 4
+
+/* MC_CMD_POLL_BIST_OUT_SFT9001 msgresponse */
+#define    MC_CMD_POLL_BIST_OUT_SFT9001_LEN 36
+/*            MC_CMD_POLL_BIST_OUT_RESULT_OFST 0 */
+/*            Enum values, see field(s): */
+/*               MC_CMD_POLL_BIST_OUT/MC_CMD_POLL_BIST_OUT_RESULT */
+#define       MC_CMD_POLL_BIST_OUT_SFT9001_CABLE_LENGTH_A_OFST 4
+#define       MC_CMD_POLL_BIST_OUT_SFT9001_CABLE_LENGTH_B_OFST 8
+#define       MC_CMD_POLL_BIST_OUT_SFT9001_CABLE_LENGTH_C_OFST 12
+#define       MC_CMD_POLL_BIST_OUT_SFT9001_CABLE_LENGTH_D_OFST 16
+#define       MC_CMD_POLL_BIST_OUT_SFT9001_CABLE_STATUS_A_OFST 20
+#define          MC_CMD_POLL_BIST_SFT9001_PAIR_OK 0x1 /* enum */
+#define          MC_CMD_POLL_BIST_SFT9001_PAIR_OPEN 0x2 /* enum */
+#define          MC_CMD_POLL_BIST_SFT9001_INTRA_PAIR_SHORT 0x3 /* enum */
+#define          MC_CMD_POLL_BIST_SFT9001_INTER_PAIR_SHORT 0x4 /* enum */
+#define          MC_CMD_POLL_BIST_SFT9001_PAIR_BUSY 0x9 /* enum */
+#define       MC_CMD_POLL_BIST_OUT_SFT9001_CABLE_STATUS_B_OFST 24
+/*            Enum values, see field(s): */
+/*               CABLE_STATUS_A */
+#define       MC_CMD_POLL_BIST_OUT_SFT9001_CABLE_STATUS_C_OFST 28
+/*            Enum values, see field(s): */
+/*               CABLE_STATUS_A */
+#define       MC_CMD_POLL_BIST_OUT_SFT9001_CABLE_STATUS_D_OFST 32
+/*            Enum values, see field(s): */
+/*               CABLE_STATUS_A */
+
+/* MC_CMD_POLL_BIST_OUT_MRSFP msgresponse */
+#define    MC_CMD_POLL_BIST_OUT_MRSFP_LEN 8
+/*            MC_CMD_POLL_BIST_OUT_RESULT_OFST 0 */
+/*            Enum values, see field(s): */
+/*               MC_CMD_POLL_BIST_OUT/MC_CMD_POLL_BIST_OUT_RESULT */
+#define       MC_CMD_POLL_BIST_OUT_MRSFP_TEST_OFST 4
+#define          MC_CMD_POLL_BIST_MRSFP_TEST_COMPLETE 0x0 /* enum */
+#define          MC_CMD_POLL_BIST_MRSFP_TEST_BUS_SWITCH_OFF_I2C_WRITE 0x1 /* enum */
+#define          MC_CMD_POLL_BIST_MRSFP_TEST_BUS_SWITCH_OFF_I2C_NO_ACCESS_IO_EXP 0x2 /* enum */
+#define          MC_CMD_POLL_BIST_MRSFP_TEST_BUS_SWITCH_OFF_I2C_NO_ACCESS_MODULE 0x3 /* enum */
+#define          MC_CMD_POLL_BIST_MRSFP_TEST_IO_EXP_I2C_CONFIGURE 0x4 /* enum */
+#define          MC_CMD_POLL_BIST_MRSFP_TEST_BUS_SWITCH_I2C_NO_CROSSTALK 0x5 /* enum */
+#define          MC_CMD_POLL_BIST_MRSFP_TEST_MODULE_PRESENCE 0x6 /* enum */
+#define          MC_CMD_POLL_BIST_MRSFP_TEST_MODULE_ID_I2C_ACCESS 0x7 /* enum */
+#define          MC_CMD_POLL_BIST_MRSFP_TEST_MODULE_ID_SANE_VALUE 0x8 /* enum */
+
+
+/***********************************/
+/* MC_CMD_FLUSH_RX_QUEUES 
+ * Flush receive queue(s).
+ */
+#define MC_CMD_FLUSH_RX_QUEUES  0x27
+
+/* MC_CMD_FLUSH_RX_QUEUES_IN msgrequest */
+#define    MC_CMD_FLUSH_RX_QUEUES_IN_LENMIN 4
+#define    MC_CMD_FLUSH_RX_QUEUES_IN_LENMAX 252
+#define    MC_CMD_FLUSH_RX_QUEUES_IN_LEN(num) (0+4*(num))
+#define       MC_CMD_FLUSH_RX_QUEUES_IN_QID_OFST_OFST 0
+#define       MC_CMD_FLUSH_RX_QUEUES_IN_QID_OFST_LEN 4
+#define       MC_CMD_FLUSH_RX_QUEUES_IN_QID_OFST_MINNUM 1
+#define       MC_CMD_FLUSH_RX_QUEUES_IN_QID_OFST_MAXNUM 63
+
+/* MC_CMD_FLUSH_RX_QUEUES_OUT msgresponse */
+#define    MC_CMD_FLUSH_RX_QUEUES_OUT_LEN 0
+
+
+/***********************************/
+/* MC_CMD_GET_LOOPBACK_MODES 
+ * Get port's loopback modes.
+ */
+#define MC_CMD_GET_LOOPBACK_MODES  0x28
+
+/* MC_CMD_GET_LOOPBACK_MODES_IN msgrequest */
+#define    MC_CMD_GET_LOOPBACK_MODES_IN_LEN 0
+
+/* MC_CMD_GET_LOOPBACK_MODES_OUT msgresponse */
+#define    MC_CMD_GET_LOOPBACK_MODES_OUT_LEN 32
+#define       MC_CMD_GET_LOOPBACK_MODES_OUT_100M_OFST 0
+#define       MC_CMD_GET_LOOPBACK_MODES_OUT_100M_LEN 8
+#define       MC_CMD_GET_LOOPBACK_MODES_OUT_100M_LO_OFST 0
+#define       MC_CMD_GET_LOOPBACK_MODES_OUT_100M_HI_OFST 4
+#define          MC_CMD_LOOPBACK_NONE  0x0 /* enum */
+#define          MC_CMD_LOOPBACK_DATA  0x1 /* enum */
+#define          MC_CMD_LOOPBACK_GMAC  0x2 /* enum */
+#define          MC_CMD_LOOPBACK_XGMII 0x3 /* enum */
+#define          MC_CMD_LOOPBACK_XGXS  0x4 /* enum */
+#define          MC_CMD_LOOPBACK_XAUI  0x5 /* enum */
+#define          MC_CMD_LOOPBACK_GMII  0x6 /* enum */
+#define          MC_CMD_LOOPBACK_SGMII  0x7 /* enum */
+#define          MC_CMD_LOOPBACK_XGBR  0x8 /* enum */
+#define          MC_CMD_LOOPBACK_XFI  0x9 /* enum */
+#define          MC_CMD_LOOPBACK_XAUI_FAR  0xa /* enum */
+#define          MC_CMD_LOOPBACK_GMII_FAR  0xb /* enum */
+#define          MC_CMD_LOOPBACK_SGMII_FAR  0xc /* enum */
+#define          MC_CMD_LOOPBACK_XFI_FAR  0xd /* enum */
+#define          MC_CMD_LOOPBACK_GPHY  0xe /* enum */
+#define          MC_CMD_LOOPBACK_PHYXS  0xf /* enum */
+#define          MC_CMD_LOOPBACK_PCS  0x10 /* enum */
+#define          MC_CMD_LOOPBACK_PMAPMD  0x11 /* enum */
+#define          MC_CMD_LOOPBACK_XPORT  0x12 /* enum */
+#define          MC_CMD_LOOPBACK_XGMII_WS  0x13 /* enum */
+#define          MC_CMD_LOOPBACK_XAUI_WS  0x14 /* enum */
+#define          MC_CMD_LOOPBACK_XAUI_WS_FAR  0x15 /* enum */
+#define          MC_CMD_LOOPBACK_XAUI_WS_NEAR  0x16 /* enum */
+#define          MC_CMD_LOOPBACK_GMII_WS  0x17 /* enum */
+#define          MC_CMD_LOOPBACK_XFI_WS  0x18 /* enum */
+#define          MC_CMD_LOOPBACK_XFI_WS_FAR  0x19 /* enum */
+#define          MC_CMD_LOOPBACK_PHYXS_WS  0x1a /* enum */
+#define       MC_CMD_GET_LOOPBACK_MODES_OUT_1G_OFST 8
+#define       MC_CMD_GET_LOOPBACK_MODES_OUT_1G_LEN 8
+#define       MC_CMD_GET_LOOPBACK_MODES_OUT_1G_LO_OFST 8
+#define       MC_CMD_GET_LOOPBACK_MODES_OUT_1G_HI_OFST 12
+/*            Enum values, see field(s): */
+/*               100M */
+#define       MC_CMD_GET_LOOPBACK_MODES_OUT_10G_OFST 16
+#define       MC_CMD_GET_LOOPBACK_MODES_OUT_10G_LEN 8
+#define       MC_CMD_GET_LOOPBACK_MODES_OUT_10G_LO_OFST 16
+#define       MC_CMD_GET_LOOPBACK_MODES_OUT_10G_HI_OFST 20
+/*            Enum values, see field(s): */
+/*               100M */
+#define       MC_CMD_GET_LOOPBACK_MODES_OUT_SUGGESTED_OFST 24
+#define       MC_CMD_GET_LOOPBACK_MODES_OUT_SUGGESTED_LEN 8
+#define       MC_CMD_GET_LOOPBACK_MODES_OUT_SUGGESTED_LO_OFST 24
+#define       MC_CMD_GET_LOOPBACK_MODES_OUT_SUGGESTED_HI_OFST 28
+/*            Enum values, see field(s): */
+/*               100M */
+
+
+/***********************************/
+/* MC_CMD_GET_LINK 
+ * Read the unified MAC/PHY link state.
+ */
+#define MC_CMD_GET_LINK  0x29
+
+/* MC_CMD_GET_LINK_IN msgrequest */
+#define    MC_CMD_GET_LINK_IN_LEN 0
+
+/* MC_CMD_GET_LINK_OUT msgresponse */
+#define    MC_CMD_GET_LINK_OUT_LEN 28
+#define       MC_CMD_GET_LINK_OUT_CAP_OFST 0
+#define       MC_CMD_GET_LINK_OUT_LP_CAP_OFST 4
+#define       MC_CMD_GET_LINK_OUT_LINK_SPEED_OFST 8
+#define       MC_CMD_GET_LINK_OUT_LOOPBACK_MODE_OFST 12
+/*            Enum values, see field(s): */
+/*               MC_CMD_GET_LOOPBACK_MODES/MC_CMD_GET_LOOPBACK_MODES_OUT/100M */
+#define       MC_CMD_GET_LINK_OUT_FLAGS_OFST 16
+#define        MC_CMD_GET_LINK_OUT_LINK_UP_LBN 0
+#define        MC_CMD_GET_LINK_OUT_LINK_UP_WIDTH 1
+#define        MC_CMD_GET_LINK_OUT_FULL_DUPLEX_LBN 1
+#define        MC_CMD_GET_LINK_OUT_FULL_DUPLEX_WIDTH 1
+#define        MC_CMD_GET_LINK_OUT_BPX_LINK_LBN 2
+#define        MC_CMD_GET_LINK_OUT_BPX_LINK_WIDTH 1
+#define        MC_CMD_GET_LINK_OUT_PHY_LINK_LBN 3
+#define        MC_CMD_GET_LINK_OUT_PHY_LINK_WIDTH 1
+#define       MC_CMD_GET_LINK_OUT_FCNTL_OFST 20
+#define          MC_CMD_FCNTL_OFF 0x0 /* enum */
+#define          MC_CMD_FCNTL_RESPOND 0x1 /* enum */
+#define          MC_CMD_FCNTL_BIDIR 0x2 /* enum */
+#define       MC_CMD_GET_LINK_OUT_MAC_FAULT_OFST 24
+#define        MC_CMD_MAC_FAULT_XGMII_LOCAL_LBN 0
+#define        MC_CMD_MAC_FAULT_XGMII_LOCAL_WIDTH 1
+#define        MC_CMD_MAC_FAULT_XGMII_REMOTE_LBN 1
+#define        MC_CMD_MAC_FAULT_XGMII_REMOTE_WIDTH 1
+#define        MC_CMD_MAC_FAULT_SGMII_REMOTE_LBN 2
+#define        MC_CMD_MAC_FAULT_SGMII_REMOTE_WIDTH 1
+#define        MC_CMD_MAC_FAULT_PENDING_RECONFIG_LBN 3
+#define        MC_CMD_MAC_FAULT_PENDING_RECONFIG_WIDTH 1
+
+
+/***********************************/
+/* MC_CMD_SET_LINK 
+ * Write the unified MAC/PHY link configuration.
+ */
+#define MC_CMD_SET_LINK  0x2a
+
+/* MC_CMD_SET_LINK_IN msgrequest */
+#define    MC_CMD_SET_LINK_IN_LEN 16
+#define       MC_CMD_SET_LINK_IN_CAP_OFST 0
+#define       MC_CMD_SET_LINK_IN_FLAGS_OFST 4
+#define        MC_CMD_SET_LINK_IN_LOWPOWER_LBN 0
+#define        MC_CMD_SET_LINK_IN_LOWPOWER_WIDTH 1
+#define        MC_CMD_SET_LINK_IN_POWEROFF_LBN 1
+#define        MC_CMD_SET_LINK_IN_POWEROFF_WIDTH 1
+#define        MC_CMD_SET_LINK_IN_TXDIS_LBN 2
+#define        MC_CMD_SET_LINK_IN_TXDIS_WIDTH 1
+#define       MC_CMD_SET_LINK_IN_LOOPBACK_MODE_OFST 8
+/*            Enum values, see field(s): */
+/*               MC_CMD_GET_LOOPBACK_MODES/MC_CMD_GET_LOOPBACK_MODES_OUT/100M */
+#define       MC_CMD_SET_LINK_IN_LOOPBACK_SPEED_OFST 12
+
+/* MC_CMD_SET_LINK_OUT msgresponse */
+#define    MC_CMD_SET_LINK_OUT_LEN 0
+
+
+/***********************************/
+/* MC_CMD_SET_ID_LED 
+ * Set indentification LED state.
+ */
+#define MC_CMD_SET_ID_LED  0x2b
+
+/* MC_CMD_SET_ID_LED_IN msgrequest */
+#define    MC_CMD_SET_ID_LED_IN_LEN 4
+#define       MC_CMD_SET_ID_LED_IN_STATE_OFST 0
+#define          MC_CMD_LED_OFF  0x0 /* enum */
+#define          MC_CMD_LED_ON  0x1 /* enum */
+#define          MC_CMD_LED_DEFAULT  0x2 /* enum */
+
+/* MC_CMD_SET_ID_LED_OUT msgresponse */
+#define    MC_CMD_SET_ID_LED_OUT_LEN 0
+
+
+/***********************************/
+/* MC_CMD_SET_MAC 
+ * Set MAC configuration.
+ */
+#define MC_CMD_SET_MAC  0x2c
+
+/* MC_CMD_SET_MAC_IN msgrequest */
+#define    MC_CMD_SET_MAC_IN_LEN 24
+#define       MC_CMD_SET_MAC_IN_MTU_OFST 0
+#define       MC_CMD_SET_MAC_IN_DRAIN_OFST 4
+#define       MC_CMD_SET_MAC_IN_ADDR_OFST 8
+#define       MC_CMD_SET_MAC_IN_ADDR_LEN 8
+#define       MC_CMD_SET_MAC_IN_ADDR_LO_OFST 8
+#define       MC_CMD_SET_MAC_IN_ADDR_HI_OFST 12
+#define       MC_CMD_SET_MAC_IN_REJECT_OFST 16
+#define        MC_CMD_SET_MAC_IN_REJECT_UNCST_LBN 0
+#define        MC_CMD_SET_MAC_IN_REJECT_UNCST_WIDTH 1
+#define        MC_CMD_SET_MAC_IN_REJECT_BRDCST_LBN 1
+#define        MC_CMD_SET_MAC_IN_REJECT_BRDCST_WIDTH 1
+#define       MC_CMD_SET_MAC_IN_FCNTL_OFST 20
+/*               MC_CMD_FCNTL_OFF 0x0 */
+/*               MC_CMD_FCNTL_RESPOND 0x1 */
+/*               MC_CMD_FCNTL_BIDIR 0x2 */
+#define          MC_CMD_FCNTL_AUTO 0x3 /* enum */
+
+/* MC_CMD_SET_MAC_OUT msgresponse */
+#define    MC_CMD_SET_MAC_OUT_LEN 0
+
+
+/***********************************/
+/* MC_CMD_PHY_STATS 
+ * Get generic PHY statistics.
+ */
+#define MC_CMD_PHY_STATS  0x2d
+
+/* MC_CMD_PHY_STATS_IN msgrequest */
+#define    MC_CMD_PHY_STATS_IN_LEN 8
+#define       MC_CMD_PHY_STATS_IN_DMA_ADDR_OFST 0
+#define       MC_CMD_PHY_STATS_IN_DMA_ADDR_LEN 8
+#define       MC_CMD_PHY_STATS_IN_DMA_ADDR_LO_OFST 0
+#define       MC_CMD_PHY_STATS_IN_DMA_ADDR_HI_OFST 4
+
+/* MC_CMD_PHY_STATS_OUT_DMA msgresponse */
+#define    MC_CMD_PHY_STATS_OUT_DMA_LEN 0
+
+/* MC_CMD_PHY_STATS_OUT_NO_DMA msgresponse */
+#define    MC_CMD_PHY_STATS_OUT_NO_DMA_LEN (((MC_CMD_PHY_NSTATS*32))>>3)
+#define       MC_CMD_PHY_STATS_OUT_NO_DMA_STATISTICS_OFST 0
+#define       MC_CMD_PHY_STATS_OUT_NO_DMA_STATISTICS_LEN 4
+#define       MC_CMD_PHY_STATS_OUT_NO_DMA_STATISTICS_NUM MC_CMD_PHY_NSTATS
+#define          MC_CMD_OUI  0x0 /* enum */
+#define          MC_CMD_PMA_PMD_LINK_UP  0x1 /* enum */
+#define          MC_CMD_PMA_PMD_RX_FAULT  0x2 /* enum */
+#define          MC_CMD_PMA_PMD_TX_FAULT  0x3 /* enum */
+#define          MC_CMD_PMA_PMD_SIGNAL  0x4 /* enum */
+#define          MC_CMD_PMA_PMD_SNR_A  0x5 /* enum */
+#define          MC_CMD_PMA_PMD_SNR_B  0x6 /* enum */
+#define          MC_CMD_PMA_PMD_SNR_C  0x7 /* enum */
+#define          MC_CMD_PMA_PMD_SNR_D  0x8 /* enum */
+#define          MC_CMD_PCS_LINK_UP  0x9 /* enum */
+#define          MC_CMD_PCS_RX_FAULT  0xa /* enum */
+#define          MC_CMD_PCS_TX_FAULT  0xb /* enum */
+#define          MC_CMD_PCS_BER  0xc /* enum */
+#define          MC_CMD_PCS_BLOCK_ERRORS  0xd /* enum */
+#define          MC_CMD_PHYXS_LINK_UP  0xe /* enum */
+#define          MC_CMD_PHYXS_RX_FAULT  0xf /* enum */
+#define          MC_CMD_PHYXS_TX_FAULT  0x10 /* enum */
+#define          MC_CMD_PHYXS_ALIGN  0x11 /* enum */
+#define          MC_CMD_PHYXS_SYNC  0x12 /* enum */
+#define          MC_CMD_AN_LINK_UP  0x13 /* enum */
+#define          MC_CMD_AN_COMPLETE  0x14 /* enum */
+#define          MC_CMD_AN_10GBT_STATUS  0x15 /* enum */
+#define          MC_CMD_CL22_LINK_UP  0x16 /* enum */
+#define          MC_CMD_PHY_NSTATS  0x17 /* enum */
+
+
+/***********************************/
+/* MC_CMD_MAC_STATS 
+ * Get generic MAC statistics.
+ */
+#define MC_CMD_MAC_STATS  0x2e
+
+/* MC_CMD_MAC_STATS_IN msgrequest */
+#define    MC_CMD_MAC_STATS_IN_LEN 16
+#define       MC_CMD_MAC_STATS_IN_DMA_ADDR_OFST 0
+#define       MC_CMD_MAC_STATS_IN_DMA_ADDR_LEN 8
+#define       MC_CMD_MAC_STATS_IN_DMA_ADDR_LO_OFST 0
+#define       MC_CMD_MAC_STATS_IN_DMA_ADDR_HI_OFST 4
+#define       MC_CMD_MAC_STATS_IN_CMD_OFST 8
+#define        MC_CMD_MAC_STATS_IN_DMA_LBN 0
+#define        MC_CMD_MAC_STATS_IN_DMA_WIDTH 1
+#define        MC_CMD_MAC_STATS_IN_CLEAR_LBN 1
+#define        MC_CMD_MAC_STATS_IN_CLEAR_WIDTH 1
+#define        MC_CMD_MAC_STATS_IN_PERIODIC_CHANGE_LBN 2
+#define        MC_CMD_MAC_STATS_IN_PERIODIC_CHANGE_WIDTH 1
+#define        MC_CMD_MAC_STATS_IN_PERIODIC_ENABLE_LBN 3
+#define        MC_CMD_MAC_STATS_IN_PERIODIC_ENABLE_WIDTH 1
+#define        MC_CMD_MAC_STATS_IN_PERIODIC_CLEAR_LBN 4
+#define        MC_CMD_MAC_STATS_IN_PERIODIC_CLEAR_WIDTH 1
+#define        MC_CMD_MAC_STATS_IN_PERIODIC_NOEVENT_LBN 5
+#define        MC_CMD_MAC_STATS_IN_PERIODIC_NOEVENT_WIDTH 1
+#define        MC_CMD_MAC_STATS_IN_PERIOD_MS_LBN 16
+#define        MC_CMD_MAC_STATS_IN_PERIOD_MS_WIDTH 16
+#define       MC_CMD_MAC_STATS_IN_DMA_LEN_OFST 12
+
+/* MC_CMD_MAC_STATS_OUT_DMA msgresponse */
+#define    MC_CMD_MAC_STATS_OUT_DMA_LEN 0
+
+/* MC_CMD_MAC_STATS_OUT_NO_DMA msgresponse */
+#define    MC_CMD_MAC_STATS_OUT_NO_DMA_LEN (((MC_CMD_MAC_NSTATS*64))>>3)
+#define       MC_CMD_MAC_STATS_OUT_NO_DMA_STATISTICS_OFST 0
+#define       MC_CMD_MAC_STATS_OUT_NO_DMA_STATISTICS_LEN 8
+#define       MC_CMD_MAC_STATS_OUT_NO_DMA_STATISTICS_LO_OFST 0
+#define       MC_CMD_MAC_STATS_OUT_NO_DMA_STATISTICS_HI_OFST 4
+#define       MC_CMD_MAC_STATS_OUT_NO_DMA_STATISTICS_NUM MC_CMD_MAC_NSTATS
+#define          MC_CMD_MAC_GENERATION_START  0x0 /* enum */
+#define          MC_CMD_MAC_TX_PKTS  0x1 /* enum */
+#define          MC_CMD_MAC_TX_PAUSE_PKTS  0x2 /* enum */
+#define          MC_CMD_MAC_TX_CONTROL_PKTS  0x3 /* enum */
+#define          MC_CMD_MAC_TX_UNICAST_PKTS  0x4 /* enum */
+#define          MC_CMD_MAC_TX_MULTICAST_PKTS  0x5 /* enum */
+#define          MC_CMD_MAC_TX_BROADCAST_PKTS  0x6 /* enum */
+#define          MC_CMD_MAC_TX_BYTES  0x7 /* enum */
+#define          MC_CMD_MAC_TX_BAD_BYTES  0x8 /* enum */
+#define          MC_CMD_MAC_TX_LT64_PKTS  0x9 /* enum */
+#define          MC_CMD_MAC_TX_64_PKTS  0xa /* enum */
+#define          MC_CMD_MAC_TX_65_TO_127_PKTS  0xb /* enum */
+#define          MC_CMD_MAC_TX_128_TO_255_PKTS  0xc /* enum */
+#define          MC_CMD_MAC_TX_256_TO_511_PKTS  0xd /* enum */
+#define          MC_CMD_MAC_TX_512_TO_1023_PKTS  0xe /* enum */
+#define          MC_CMD_MAC_TX_1024_TO_15XX_PKTS  0xf /* enum */
+#define          MC_CMD_MAC_TX_15XX_TO_JUMBO_PKTS  0x10 /* enum */
+#define          MC_CMD_MAC_TX_GTJUMBO_PKTS  0x11 /* enum */
+#define          MC_CMD_MAC_TX_BAD_FCS_PKTS  0x12 /* enum */
+#define          MC_CMD_MAC_TX_SINGLE_COLLISION_PKTS  0x13 /* enum */
+#define          MC_CMD_MAC_TX_MULTIPLE_COLLISION_PKTS  0x14 /* enum */
+#define          MC_CMD_MAC_TX_EXCESSIVE_COLLISION_PKTS  0x15 /* enum */
+#define          MC_CMD_MAC_TX_LATE_COLLISION_PKTS  0x16 /* enum */
+#define          MC_CMD_MAC_TX_DEFERRED_PKTS  0x17 /* enum */
+#define          MC_CMD_MAC_TX_EXCESSIVE_DEFERRED_PKTS  0x18 /* enum */
+#define          MC_CMD_MAC_TX_NON_TCPUDP_PKTS  0x19 /* enum */
+#define          MC_CMD_MAC_TX_MAC_SRC_ERR_PKTS  0x1a /* enum */
+#define          MC_CMD_MAC_TX_IP_SRC_ERR_PKTS  0x1b /* enum */
+#define          MC_CMD_MAC_RX_PKTS  0x1c /* enum */
+#define          MC_CMD_MAC_RX_PAUSE_PKTS  0x1d /* enum */
+#define          MC_CMD_MAC_RX_GOOD_PKTS  0x1e /* enum */
+#define          MC_CMD_MAC_RX_CONTROL_PKTS  0x1f /* enum */
+#define          MC_CMD_MAC_RX_UNICAST_PKTS  0x20 /* enum */
+#define          MC_CMD_MAC_RX_MULTICAST_PKTS  0x21 /* enum */
+#define          MC_CMD_MAC_RX_BROADCAST_PKTS  0x22 /* enum */
+#define          MC_CMD_MAC_RX_BYTES  0x23 /* enum */
+#define          MC_CMD_MAC_RX_BAD_BYTES  0x24 /* enum */
+#define          MC_CMD_MAC_RX_64_PKTS  0x25 /* enum */
+#define          MC_CMD_MAC_RX_65_TO_127_PKTS  0x26 /* enum */
+#define          MC_CMD_MAC_RX_128_TO_255_PKTS  0x27 /* enum */
+#define          MC_CMD_MAC_RX_256_TO_511_PKTS  0x28 /* enum */
+#define          MC_CMD_MAC_RX_512_TO_1023_PKTS  0x29 /* enum */
+#define          MC_CMD_MAC_RX_1024_TO_15XX_PKTS  0x2a /* enum */
+#define          MC_CMD_MAC_RX_15XX_TO_JUMBO_PKTS  0x2b /* enum */
+#define          MC_CMD_MAC_RX_GTJUMBO_PKTS  0x2c /* enum */
+#define          MC_CMD_MAC_RX_UNDERSIZE_PKTS  0x2d /* enum */
+#define          MC_CMD_MAC_RX_BAD_FCS_PKTS  0x2e /* enum */
+#define          MC_CMD_MAC_RX_OVERFLOW_PKTS  0x2f /* enum */
+#define          MC_CMD_MAC_RX_FALSE_CARRIER_PKTS  0x30 /* enum */
+#define          MC_CMD_MAC_RX_SYMBOL_ERROR_PKTS  0x31 /* enum */
+#define          MC_CMD_MAC_RX_ALIGN_ERROR_PKTS  0x32 /* enum */
+#define          MC_CMD_MAC_RX_LENGTH_ERROR_PKTS  0x33 /* enum */
+#define          MC_CMD_MAC_RX_INTERNAL_ERROR_PKTS  0x34 /* enum */
+#define          MC_CMD_MAC_RX_JABBER_PKTS  0x35 /* enum */
+#define          MC_CMD_MAC_RX_NODESC_DROPS  0x36 /* enum */
+#define          MC_CMD_MAC_RX_LANES01_CHAR_ERR  0x37 /* enum */
+#define          MC_CMD_MAC_RX_LANES23_CHAR_ERR  0x38 /* enum */
+#define          MC_CMD_MAC_RX_LANES01_DISP_ERR  0x39 /* enum */
+#define          MC_CMD_MAC_RX_LANES23_DISP_ERR  0x3a /* enum */
+#define          MC_CMD_MAC_RX_MATCH_FAULT  0x3b /* enum */
+#define          MC_CMD_GMAC_DMABUF_START  0x40 /* enum */
+#define          MC_CMD_GMAC_DMABUF_END    0x5f /* enum */
+#define          MC_CMD_MAC_GENERATION_END 0x60 /* enum */
+#define          MC_CMD_MAC_NSTATS  0x61 /* enum */
+
+
+/***********************************/
+/* MC_CMD_SRIOV 
+ * to be documented
+ */
+#define MC_CMD_SRIOV  0x30
+
+/* MC_CMD_SRIOV_IN msgrequest */
+#define    MC_CMD_SRIOV_IN_LEN 12
+#define       MC_CMD_SRIOV_IN_ENABLE_OFST 0
+#define       MC_CMD_SRIOV_IN_VI_BASE_OFST 4
+#define       MC_CMD_SRIOV_IN_VF_COUNT_OFST 8
+
+/* MC_CMD_SRIOV_OUT msgresponse */
+#define    MC_CMD_SRIOV_OUT_LEN 8
+#define       MC_CMD_SRIOV_OUT_VI_SCALE_OFST 0
+#define       MC_CMD_SRIOV_OUT_VF_TOTAL_OFST 4
+
+/* MC_CMD_MEMCPY_RECORD_TYPEDEF structuredef */
+#define    MC_CMD_MEMCPY_RECORD_TYPEDEF_LEN 32
+#define       MC_CMD_MEMCPY_RECORD_TYPEDEF_NUM_RECORDS_OFST 0
+#define       MC_CMD_MEMCPY_RECORD_TYPEDEF_NUM_RECORDS_LBN 0
+#define       MC_CMD_MEMCPY_RECORD_TYPEDEF_NUM_RECORDS_WIDTH 32
+#define       MC_CMD_MEMCPY_RECORD_TYPEDEF_TO_RID_OFST 4
+#define       MC_CMD_MEMCPY_RECORD_TYPEDEF_TO_RID_LBN 32
+#define       MC_CMD_MEMCPY_RECORD_TYPEDEF_TO_RID_WIDTH 32
+#define       MC_CMD_MEMCPY_RECORD_TYPEDEF_TO_ADDR_OFST 8
+#define       MC_CMD_MEMCPY_RECORD_TYPEDEF_TO_ADDR_LEN 8
+#define       MC_CMD_MEMCPY_RECORD_TYPEDEF_TO_ADDR_LO_OFST 8
+#define       MC_CMD_MEMCPY_RECORD_TYPEDEF_TO_ADDR_HI_OFST 12
+#define       MC_CMD_MEMCPY_RECORD_TYPEDEF_TO_ADDR_LBN 64
+#define       MC_CMD_MEMCPY_RECORD_TYPEDEF_TO_ADDR_WIDTH 64
+#define       MC_CMD_MEMCPY_RECORD_TYPEDEF_FROM_RID_OFST 16
+#define          MC_CMD_MEMCPY_RECORD_TYPEDEF_RID_INLINE 0x100 /* enum */
+#define       MC_CMD_MEMCPY_RECORD_TYPEDEF_FROM_RID_LBN 128
+#define       MC_CMD_MEMCPY_RECORD_TYPEDEF_FROM_RID_WIDTH 32
+#define       MC_CMD_MEMCPY_RECORD_TYPEDEF_FROM_ADDR_OFST 20
+#define       MC_CMD_MEMCPY_RECORD_TYPEDEF_FROM_ADDR_LEN 8
+#define       MC_CMD_MEMCPY_RECORD_TYPEDEF_FROM_ADDR_LO_OFST 20
+#define       MC_CMD_MEMCPY_RECORD_TYPEDEF_FROM_ADDR_HI_OFST 24
+#define       MC_CMD_MEMCPY_RECORD_TYPEDEF_FROM_ADDR_LBN 160
+#define       MC_CMD_MEMCPY_RECORD_TYPEDEF_FROM_ADDR_WIDTH 64
+#define       MC_CMD_MEMCPY_RECORD_TYPEDEF_LENGTH_OFST 28
+#define       MC_CMD_MEMCPY_RECORD_TYPEDEF_LENGTH_LBN 224
+#define       MC_CMD_MEMCPY_RECORD_TYPEDEF_LENGTH_WIDTH 32
+
+
+/***********************************/
+/* MC_CMD_MEMCPY 
+ * Perform memory copy operation.
+ */
+#define MC_CMD_MEMCPY  0x31
+
+/* MC_CMD_MEMCPY_IN msgrequest */
+#define    MC_CMD_MEMCPY_IN_LENMIN 32
+#define    MC_CMD_MEMCPY_IN_LENMAX 224
+#define    MC_CMD_MEMCPY_IN_LEN(num) (0+32*(num))
+#define       MC_CMD_MEMCPY_IN_RECORD_OFST 0
+#define       MC_CMD_MEMCPY_IN_RECORD_LEN 32
+#define       MC_CMD_MEMCPY_IN_RECORD_MINNUM 1
+#define       MC_CMD_MEMCPY_IN_RECORD_MAXNUM 7
+
+/* MC_CMD_MEMCPY_OUT msgresponse */
+#define    MC_CMD_MEMCPY_OUT_LEN 0
+
+
+/***********************************/
+/* MC_CMD_WOL_FILTER_SET 
+ * Set a WoL filter.
+ */
+#define MC_CMD_WOL_FILTER_SET  0x32
+
+/* MC_CMD_WOL_FILTER_SET_IN msgrequest */
+#define    MC_CMD_WOL_FILTER_SET_IN_LEN 192
+#define       MC_CMD_WOL_FILTER_SET_IN_FILTER_MODE_OFST 0
+#define          MC_CMD_FILTER_MODE_SIMPLE    0x0 /* enum */
+#define          MC_CMD_FILTER_MODE_STRUCTURED 0xffffffff /* enum */
+#define       MC_CMD_WOL_FILTER_SET_IN_WOL_TYPE_OFST 4
+#define          MC_CMD_WOL_TYPE_MAGIC      0x0 /* enum */
+#define          MC_CMD_WOL_TYPE_WIN_MAGIC 0x2 /* enum */
+#define          MC_CMD_WOL_TYPE_IPV4_SYN   0x3 /* enum */
+#define          MC_CMD_WOL_TYPE_IPV6_SYN   0x4 /* enum */
+#define          MC_CMD_WOL_TYPE_BITMAP     0x5 /* enum */
+#define          MC_CMD_WOL_TYPE_LINK       0x6 /* enum */
+#define          MC_CMD_WOL_TYPE_MAX        0x7 /* enum */
+#define       MC_CMD_WOL_FILTER_SET_IN_DATA_OFST 8
+#define       MC_CMD_WOL_FILTER_SET_IN_DATA_LEN 4
+#define       MC_CMD_WOL_FILTER_SET_IN_DATA_NUM 46
+
+/* MC_CMD_WOL_FILTER_SET_IN_MAGIC msgrequest */
+#define    MC_CMD_WOL_FILTER_SET_IN_MAGIC_LEN 16
+/*            MC_CMD_WOL_FILTER_SET_IN_FILTER_MODE_OFST 0 */
+/*            MC_CMD_WOL_FILTER_SET_IN_WOL_TYPE_OFST 4 */
+#define       MC_CMD_WOL_FILTER_SET_IN_MAGIC_MAC_OFST 8
+#define       MC_CMD_WOL_FILTER_SET_IN_MAGIC_MAC_LEN 8
+#define       MC_CMD_WOL_FILTER_SET_IN_MAGIC_MAC_LO_OFST 8
+#define       MC_CMD_WOL_FILTER_SET_IN_MAGIC_MAC_HI_OFST 12
+
+/* MC_CMD_WOL_FILTER_SET_IN_IPV4_SYN msgrequest */
+#define    MC_CMD_WOL_FILTER_SET_IN_IPV4_SYN_LEN 20
+/*            MC_CMD_WOL_FILTER_SET_IN_FILTER_MODE_OFST 0 */
+/*            MC_CMD_WOL_FILTER_SET_IN_WOL_TYPE_OFST 4 */
+#define       MC_CMD_WOL_FILTER_SET_IN_IPV4_SYN_SRC_IP_OFST 8
+#define       MC_CMD_WOL_FILTER_SET_IN_IPV4_SYN_DST_IP_OFST 12
+#define       MC_CMD_WOL_FILTER_SET_IN_IPV4_SYN_SRC_PORT_OFST 16
+#define       MC_CMD_WOL_FILTER_SET_IN_IPV4_SYN_SRC_PORT_LEN 2
+#define       MC_CMD_WOL_FILTER_SET_IN_IPV4_SYN_DST_PORT_OFST 18
+#define       MC_CMD_WOL_FILTER_SET_IN_IPV4_SYN_DST_PORT_LEN 2
+
+/* MC_CMD_WOL_FILTER_SET_IN_IPV6_SYN msgrequest */
+#define    MC_CMD_WOL_FILTER_SET_IN_IPV6_SYN_LEN 44
+/*            MC_CMD_WOL_FILTER_SET_IN_FILTER_MODE_OFST 0 */
+/*            MC_CMD_WOL_FILTER_SET_IN_WOL_TYPE_OFST 4 */
+#define       MC_CMD_WOL_FILTER_SET_IN_IPV6_SYN_SRC_IP_OFST 8
+#define       MC_CMD_WOL_FILTER_SET_IN_IPV6_SYN_SRC_IP_LEN 16
+#define       MC_CMD_WOL_FILTER_SET_IN_IPV6_SYN_DST_IP_OFST 24
+#define       MC_CMD_WOL_FILTER_SET_IN_IPV6_SYN_DST_IP_LEN 16
+#define       MC_CMD_WOL_FILTER_SET_IN_IPV6_SYN_SRC_PORT_OFST 40
+#define       MC_CMD_WOL_FILTER_SET_IN_IPV6_SYN_SRC_PORT_LEN 2
+#define       MC_CMD_WOL_FILTER_SET_IN_IPV6_SYN_DST_PORT_OFST 42
+#define       MC_CMD_WOL_FILTER_SET_IN_IPV6_SYN_DST_PORT_LEN 2
+
+/* MC_CMD_WOL_FILTER_SET_IN_BITMAP msgrequest */
+#define    MC_CMD_WOL_FILTER_SET_IN_BITMAP_LEN 187
+/*            MC_CMD_WOL_FILTER_SET_IN_FILTER_MODE_OFST 0 */
+/*            MC_CMD_WOL_FILTER_SET_IN_WOL_TYPE_OFST 4 */
+#define       MC_CMD_WOL_FILTER_SET_IN_BITMAP_MASK_OFST 8
+#define       MC_CMD_WOL_FILTER_SET_IN_BITMAP_MASK_LEN 48
+#define       MC_CMD_WOL_FILTER_SET_IN_BITMAP_BITMAP_OFST 56
+#define       MC_CMD_WOL_FILTER_SET_IN_BITMAP_BITMAP_LEN 128
+#define       MC_CMD_WOL_FILTER_SET_IN_BITMAP_LEN_OFST 184
+#define       MC_CMD_WOL_FILTER_SET_IN_BITMAP_LEN_LEN 1
+#define       MC_CMD_WOL_FILTER_SET_IN_BITMAP_LAYER3_OFST 185
+#define       MC_CMD_WOL_FILTER_SET_IN_BITMAP_LAYER3_LEN 1
+#define       MC_CMD_WOL_FILTER_SET_IN_BITMAP_LAYER4_OFST 186
+#define       MC_CMD_WOL_FILTER_SET_IN_BITMAP_LAYER4_LEN 1
+
+/* MC_CMD_WOL_FILTER_SET_IN_LINK msgrequest */
+#define    MC_CMD_WOL_FILTER_SET_IN_LINK_LEN 12
+/*            MC_CMD_WOL_FILTER_SET_IN_FILTER_MODE_OFST 0 */
+/*            MC_CMD_WOL_FILTER_SET_IN_WOL_TYPE_OFST 4 */
+#define       MC_CMD_WOL_FILTER_SET_IN_LINK_MASK_OFST 8
+#define        MC_CMD_WOL_FILTER_SET_IN_LINK_UP_LBN 0
+#define        MC_CMD_WOL_FILTER_SET_IN_LINK_UP_WIDTH 1
+#define        MC_CMD_WOL_FILTER_SET_IN_LINK_DOWN_LBN 1
+#define        MC_CMD_WOL_FILTER_SET_IN_LINK_DOWN_WIDTH 1
+
+/* MC_CMD_WOL_FILTER_SET_OUT msgresponse */
+#define    MC_CMD_WOL_FILTER_SET_OUT_LEN 4
+#define       MC_CMD_WOL_FILTER_SET_OUT_FILTER_ID_OFST 0
+
+
+/***********************************/
+/* MC_CMD_WOL_FILTER_REMOVE 
+ * Remove a WoL filter.
+ */
+#define MC_CMD_WOL_FILTER_REMOVE  0x33
+
+/* MC_CMD_WOL_FILTER_REMOVE_IN msgrequest */
+#define    MC_CMD_WOL_FILTER_REMOVE_IN_LEN 4
+#define       MC_CMD_WOL_FILTER_REMOVE_IN_FILTER_ID_OFST 0
+
+/* MC_CMD_WOL_FILTER_REMOVE_OUT msgresponse */
+#define    MC_CMD_WOL_FILTER_REMOVE_OUT_LEN 0
+
+
+/***********************************/
+/* MC_CMD_WOL_FILTER_RESET 
+ * Reset (i.e. remove all) WoL filters.
+ */
+#define MC_CMD_WOL_FILTER_RESET  0x34
+
+/* MC_CMD_WOL_FILTER_RESET_IN msgrequest */
+#define    MC_CMD_WOL_FILTER_RESET_IN_LEN 4
+#define       MC_CMD_WOL_FILTER_RESET_IN_MASK_OFST 0
+#define          MC_CMD_WOL_FILTER_RESET_IN_WAKE_FILTERS 0x1 /* enum */
+#define          MC_CMD_WOL_FILTER_RESET_IN_LIGHTSOUT_OFFLOADS 0x2 /* enum */
+
+/* MC_CMD_WOL_FILTER_RESET_OUT msgresponse */
+#define    MC_CMD_WOL_FILTER_RESET_OUT_LEN 0
+
+
+/***********************************/
+/* MC_CMD_SET_MCAST_HASH 
+ * Set the MCASH hash value.
+ */
+#define MC_CMD_SET_MCAST_HASH  0x35
+
+/* MC_CMD_SET_MCAST_HASH_IN msgrequest */
+#define    MC_CMD_SET_MCAST_HASH_IN_LEN 32
+#define       MC_CMD_SET_MCAST_HASH_IN_HASH0_OFST 0
+#define       MC_CMD_SET_MCAST_HASH_IN_HASH0_LEN 16
+#define       MC_CMD_SET_MCAST_HASH_IN_HASH1_OFST 16
+#define       MC_CMD_SET_MCAST_HASH_IN_HASH1_LEN 16
+
+/* MC_CMD_SET_MCAST_HASH_OUT msgresponse */
+#define    MC_CMD_SET_MCAST_HASH_OUT_LEN 0
+
+
+/***********************************/
+/* MC_CMD_NVRAM_TYPES 
+ * Get virtual NVRAM partitions information.
+ */
+#define MC_CMD_NVRAM_TYPES  0x36
+
+/* MC_CMD_NVRAM_TYPES_IN msgrequest */
+#define    MC_CMD_NVRAM_TYPES_IN_LEN 0
+
+/* MC_CMD_NVRAM_TYPES_OUT msgresponse */
+#define    MC_CMD_NVRAM_TYPES_OUT_LEN 4
+#define       MC_CMD_NVRAM_TYPES_OUT_TYPES_OFST 0
+#define          MC_CMD_NVRAM_TYPE_DISABLED_CALLISTO 0x0 /* enum */
+#define          MC_CMD_NVRAM_TYPE_MC_FW 0x1 /* enum */
+#define          MC_CMD_NVRAM_TYPE_MC_FW_BACKUP 0x2 /* enum */
+#define          MC_CMD_NVRAM_TYPE_STATIC_CFG_PORT0 0x3 /* enum */
+#define          MC_CMD_NVRAM_TYPE_STATIC_CFG_PORT1 0x4 /* enum */
+#define          MC_CMD_NVRAM_TYPE_DYNAMIC_CFG_PORT0 0x5 /* enum */
+#define          MC_CMD_NVRAM_TYPE_DYNAMIC_CFG_PORT1 0x6 /* enum */
+#define          MC_CMD_NVRAM_TYPE_EXP_ROM 0x7 /* enum */
+#define          MC_CMD_NVRAM_TYPE_EXP_ROM_CFG_PORT0 0x8 /* enum */
+#define          MC_CMD_NVRAM_TYPE_EXP_ROM_CFG_PORT1 0x9 /* enum */
+#define          MC_CMD_NVRAM_TYPE_PHY_PORT0 0xa /* enum */
+#define          MC_CMD_NVRAM_TYPE_PHY_PORT1 0xb /* enum */
+#define          MC_CMD_NVRAM_TYPE_LOG 0xc /* enum */
+
+
+/***********************************/
+/* MC_CMD_NVRAM_INFO 
+ * Read info about a virtual NVRAM partition.
+ */
+#define MC_CMD_NVRAM_INFO  0x37
+
+/* MC_CMD_NVRAM_INFO_IN msgrequest */
+#define    MC_CMD_NVRAM_INFO_IN_LEN 4
+#define       MC_CMD_NVRAM_INFO_IN_TYPE_OFST 0
+/*            Enum values, see field(s): */
+/*               MC_CMD_NVRAM_TYPES/MC_CMD_NVRAM_TYPES_OUT/TYPES */
+
+/* MC_CMD_NVRAM_INFO_OUT msgresponse */
+#define    MC_CMD_NVRAM_INFO_OUT_LEN 24
+#define       MC_CMD_NVRAM_INFO_OUT_TYPE_OFST 0
+/*            Enum values, see field(s): */
+/*               MC_CMD_NVRAM_TYPES/MC_CMD_NVRAM_TYPES_OUT/TYPES */
+#define       MC_CMD_NVRAM_INFO_OUT_SIZE_OFST 4
+#define       MC_CMD_NVRAM_INFO_OUT_ERASESIZE_OFST 8
+#define       MC_CMD_NVRAM_INFO_OUT_FLAGS_OFST 12
+#define        MC_CMD_NVRAM_INFO_OUT_PROTECTED_LBN 0
+#define        MC_CMD_NVRAM_INFO_OUT_PROTECTED_WIDTH 1
+#define       MC_CMD_NVRAM_INFO_OUT_PHYSDEV_OFST 16
+#define       MC_CMD_NVRAM_INFO_OUT_PHYSADDR_OFST 20
+
+
+/***********************************/
+/* MC_CMD_NVRAM_UPDATE_START 
+ * Start a group of update operations on a virtual NVRAM partition.
+ */
+#define MC_CMD_NVRAM_UPDATE_START  0x38
+
+/* MC_CMD_NVRAM_UPDATE_START_IN msgrequest */
+#define    MC_CMD_NVRAM_UPDATE_START_IN_LEN 4
+#define       MC_CMD_NVRAM_UPDATE_START_IN_TYPE_OFST 0
+/*            Enum values, see field(s): */
+/*               MC_CMD_NVRAM_TYPES/MC_CMD_NVRAM_TYPES_OUT/TYPES */
+
+/* MC_CMD_NVRAM_UPDATE_START_OUT msgresponse */
+#define    MC_CMD_NVRAM_UPDATE_START_OUT_LEN 0
+
+
+/***********************************/
+/* MC_CMD_NVRAM_READ 
+ * Read data from a virtual NVRAM partition.
+ */
+#define MC_CMD_NVRAM_READ  0x39
+
+/* MC_CMD_NVRAM_READ_IN msgrequest */
+#define    MC_CMD_NVRAM_READ_IN_LEN 12
+#define       MC_CMD_NVRAM_READ_IN_TYPE_OFST 0
+/*            Enum values, see field(s): */
+/*               MC_CMD_NVRAM_TYPES/MC_CMD_NVRAM_TYPES_OUT/TYPES */
+#define       MC_CMD_NVRAM_READ_IN_OFFSET_OFST 4
+#define       MC_CMD_NVRAM_READ_IN_LENGTH_OFST 8
+
+/* MC_CMD_NVRAM_READ_OUT msgresponse */
+#define    MC_CMD_NVRAM_READ_OUT_LENMIN 1
+#define    MC_CMD_NVRAM_READ_OUT_LENMAX 255
+#define    MC_CMD_NVRAM_READ_OUT_LEN(num) (0+1*(num))
+#define       MC_CMD_NVRAM_READ_OUT_READ_BUFFER_OFST 0
+#define       MC_CMD_NVRAM_READ_OUT_READ_BUFFER_LEN 1
+#define       MC_CMD_NVRAM_READ_OUT_READ_BUFFER_MINNUM 1
+#define       MC_CMD_NVRAM_READ_OUT_READ_BUFFER_MAXNUM 255
+
+
+/***********************************/
+/* MC_CMD_NVRAM_WRITE 
+ * Write data to a virtual NVRAM partition.
+ */
+#define MC_CMD_NVRAM_WRITE  0x3a
+
+/* MC_CMD_NVRAM_WRITE_IN msgrequest */
+#define    MC_CMD_NVRAM_WRITE_IN_LENMIN 13
+#define    MC_CMD_NVRAM_WRITE_IN_LENMAX 255
+#define    MC_CMD_NVRAM_WRITE_IN_LEN(num) (12+1*(num))
+#define       MC_CMD_NVRAM_WRITE_IN_TYPE_OFST 0
+/*            Enum values, see field(s): */
+/*               MC_CMD_NVRAM_TYPES/MC_CMD_NVRAM_TYPES_OUT/TYPES */
+#define       MC_CMD_NVRAM_WRITE_IN_OFFSET_OFST 4
+#define       MC_CMD_NVRAM_WRITE_IN_LENGTH_OFST 8
+#define       MC_CMD_NVRAM_WRITE_IN_WRITE_BUFFER_OFST 12
+#define       MC_CMD_NVRAM_WRITE_IN_WRITE_BUFFER_LEN 1
+#define       MC_CMD_NVRAM_WRITE_IN_WRITE_BUFFER_MINNUM 1
+#define       MC_CMD_NVRAM_WRITE_IN_WRITE_BUFFER_MAXNUM 243
+
+/* MC_CMD_NVRAM_WRITE_OUT msgresponse */
+#define    MC_CMD_NVRAM_WRITE_OUT_LEN 0
+
+
+/***********************************/
+/* MC_CMD_NVRAM_ERASE 
+ * Erase sector(s) from a virtual NVRAM partition.
+ */
+#define MC_CMD_NVRAM_ERASE  0x3b
+
+/* MC_CMD_NVRAM_ERASE_IN msgrequest */
+#define    MC_CMD_NVRAM_ERASE_IN_LEN 12
+#define       MC_CMD_NVRAM_ERASE_IN_TYPE_OFST 0
+/*            Enum values, see field(s): */
+/*               MC_CMD_NVRAM_TYPES/MC_CMD_NVRAM_TYPES_OUT/TYPES */
+#define       MC_CMD_NVRAM_ERASE_IN_OFFSET_OFST 4
+#define       MC_CMD_NVRAM_ERASE_IN_LENGTH_OFST 8
+
+/* MC_CMD_NVRAM_ERASE_OUT msgresponse */
+#define    MC_CMD_NVRAM_ERASE_OUT_LEN 0
+
+
+/***********************************/
+/* MC_CMD_NVRAM_UPDATE_FINISH 
+ * Finish a group of update operations on a virtual NVRAM partition.
+ */
+#define MC_CMD_NVRAM_UPDATE_FINISH  0x3c
+
+/* MC_CMD_NVRAM_UPDATE_FINISH_IN msgrequest */
+#define    MC_CMD_NVRAM_UPDATE_FINISH_IN_LEN 8
+#define       MC_CMD_NVRAM_UPDATE_FINISH_IN_TYPE_OFST 0
+/*            Enum values, see field(s): */
+/*               MC_CMD_NVRAM_TYPES/MC_CMD_NVRAM_TYPES_OUT/TYPES */
+#define       MC_CMD_NVRAM_UPDATE_FINISH_IN_REBOOT_OFST 4
+
+/* MC_CMD_NVRAM_UPDATE_FINISH_OUT msgresponse */
+#define    MC_CMD_NVRAM_UPDATE_FINISH_OUT_LEN 0
+
+
+/***********************************/
+/* MC_CMD_REBOOT 
+ * Reboot the MC.
+ */
+#define MC_CMD_REBOOT  0x3d
+
+/* MC_CMD_REBOOT_IN msgrequest */
+#define    MC_CMD_REBOOT_IN_LEN 4
+#define       MC_CMD_REBOOT_IN_FLAGS_OFST 0
+#define          MC_CMD_REBOOT_FLAGS_AFTER_ASSERTION 0x1 /* enum */
+
+/* MC_CMD_REBOOT_OUT msgresponse */
+#define    MC_CMD_REBOOT_OUT_LEN 0
+
+
+/***********************************/
+/* MC_CMD_SCHEDINFO 
+ * Request scheduler info.
+ */
+#define MC_CMD_SCHEDINFO  0x3e
+
+/* MC_CMD_SCHEDINFO_IN msgrequest */
+#define    MC_CMD_SCHEDINFO_IN_LEN 0
+
+/* MC_CMD_SCHEDINFO_OUT msgresponse */
+#define    MC_CMD_SCHEDINFO_OUT_LENMIN 4
+#define    MC_CMD_SCHEDINFO_OUT_LENMAX 252
+#define    MC_CMD_SCHEDINFO_OUT_LEN(num) (0+4*(num))
+#define       MC_CMD_SCHEDINFO_OUT_DATA_OFST 0
+#define       MC_CMD_SCHEDINFO_OUT_DATA_LEN 4
+#define       MC_CMD_SCHEDINFO_OUT_DATA_MINNUM 1
+#define       MC_CMD_SCHEDINFO_OUT_DATA_MAXNUM 63
+
+
+/***********************************/
+/* MC_CMD_REBOOT_MODE 
+ */
+#define MC_CMD_REBOOT_MODE  0x3f
+
+/* MC_CMD_REBOOT_MODE_IN msgrequest */
+#define    MC_CMD_REBOOT_MODE_IN_LEN 4
+#define       MC_CMD_REBOOT_MODE_IN_VALUE_OFST 0
+#define          MC_CMD_REBOOT_MODE_NORMAL 0x0 /* enum */
+#define          MC_CMD_REBOOT_MODE_SNAPPER 0x3 /* enum */
+
+/* MC_CMD_REBOOT_MODE_OUT msgresponse */
+#define    MC_CMD_REBOOT_MODE_OUT_LEN 4
+#define       MC_CMD_REBOOT_MODE_OUT_VALUE_OFST 0
+
+
+/***********************************/
+/* MC_CMD_SENSOR_INFO 
+ * Returns information about every available sensor.
+ */
+#define MC_CMD_SENSOR_INFO  0x41
+
+/* MC_CMD_SENSOR_INFO_IN msgrequest */
+#define    MC_CMD_SENSOR_INFO_IN_LEN 0
+
+/* MC_CMD_SENSOR_INFO_OUT msgresponse */
+#define    MC_CMD_SENSOR_INFO_OUT_LENMIN 12
+#define    MC_CMD_SENSOR_INFO_OUT_LENMAX 252
+#define    MC_CMD_SENSOR_INFO_OUT_LEN(num) (4+8*(num))
+#define       MC_CMD_SENSOR_INFO_OUT_MASK_OFST 0
+#define          MC_CMD_SENSOR_CONTROLLER_TEMP  0x0 /* enum */
+#define          MC_CMD_SENSOR_PHY_COMMON_TEMP  0x1 /* enum */
+#define          MC_CMD_SENSOR_CONTROLLER_COOLING  0x2 /* enum */
+#define          MC_CMD_SENSOR_PHY0_TEMP  0x3 /* enum */
+#define          MC_CMD_SENSOR_PHY0_COOLING  0x4 /* enum */
+#define          MC_CMD_SENSOR_PHY1_TEMP  0x5 /* enum */
+#define          MC_CMD_SENSOR_PHY1_COOLING  0x6 /* enum */
+#define          MC_CMD_SENSOR_IN_1V0  0x7 /* enum */
+#define          MC_CMD_SENSOR_IN_1V2  0x8 /* enum */
+#define          MC_CMD_SENSOR_IN_1V8  0x9 /* enum */
+#define          MC_CMD_SENSOR_IN_2V5  0xa /* enum */
+#define          MC_CMD_SENSOR_IN_3V3  0xb /* enum */
+#define          MC_CMD_SENSOR_IN_12V0  0xc /* enum */
+#define       MC_CMD_SENSOR_ENTRY_OFST 4
+#define       MC_CMD_SENSOR_ENTRY_LEN 8
+#define       MC_CMD_SENSOR_ENTRY_LO_OFST 4
+#define       MC_CMD_SENSOR_ENTRY_HI_OFST 8
+#define       MC_CMD_SENSOR_ENTRY_MINNUM 1
+#define       MC_CMD_SENSOR_ENTRY_MAXNUM 31
+
+/* MC_CMD_SENSOR_INFO_ENTRY_TYPEDEF structuredef */
+#define    MC_CMD_SENSOR_INFO_ENTRY_TYPEDEF_LEN 8
+#define       MC_CMD_SENSOR_INFO_ENTRY_TYPEDEF_MIN1_OFST 0
+#define       MC_CMD_SENSOR_INFO_ENTRY_TYPEDEF_MIN1_LEN 2
+#define       MC_CMD_SENSOR_INFO_ENTRY_TYPEDEF_MIN1_LBN 0
+#define       MC_CMD_SENSOR_INFO_ENTRY_TYPEDEF_MIN1_WIDTH 16
+#define       MC_CMD_SENSOR_INFO_ENTRY_TYPEDEF_MAX1_OFST 2
+#define       MC_CMD_SENSOR_INFO_ENTRY_TYPEDEF_MAX1_LEN 2
+#define       MC_CMD_SENSOR_INFO_ENTRY_TYPEDEF_MAX1_LBN 16
+#define       MC_CMD_SENSOR_INFO_ENTRY_TYPEDEF_MAX1_WIDTH 16
+#define       MC_CMD_SENSOR_INFO_ENTRY_TYPEDEF_MIN2_OFST 4
+#define       MC_CMD_SENSOR_INFO_ENTRY_TYPEDEF_MIN2_LEN 2
+#define       MC_CMD_SENSOR_INFO_ENTRY_TYPEDEF_MIN2_LBN 32
+#define       MC_CMD_SENSOR_INFO_ENTRY_TYPEDEF_MIN2_WIDTH 16
+#define       MC_CMD_SENSOR_INFO_ENTRY_TYPEDEF_MAX2_OFST 6
+#define       MC_CMD_SENSOR_INFO_ENTRY_TYPEDEF_MAX2_LEN 2
+#define       MC_CMD_SENSOR_INFO_ENTRY_TYPEDEF_MAX2_LBN 48
+#define       MC_CMD_SENSOR_INFO_ENTRY_TYPEDEF_MAX2_WIDTH 16
+
+
+/***********************************/
+/* MC_CMD_READ_SENSORS 
+ * Returns the current reading from each sensor.
+ */
+#define MC_CMD_READ_SENSORS  0x42
+
+/* MC_CMD_READ_SENSORS_IN msgrequest */
+#define    MC_CMD_READ_SENSORS_IN_LEN 8
+#define       MC_CMD_READ_SENSORS_IN_DMA_ADDR_OFST 0
+#define       MC_CMD_READ_SENSORS_IN_DMA_ADDR_LEN 8
+#define       MC_CMD_READ_SENSORS_IN_DMA_ADDR_LO_OFST 0
+#define       MC_CMD_READ_SENSORS_IN_DMA_ADDR_HI_OFST 4
+
+/* MC_CMD_READ_SENSORS_OUT msgresponse */
+#define    MC_CMD_READ_SENSORS_OUT_LEN 0
+
+/* MC_CMD_SENSOR_VALUE_ENTRY_TYPEDEF structuredef */
+#define    MC_CMD_SENSOR_VALUE_ENTRY_TYPEDEF_LEN 3
+#define       MC_CMD_SENSOR_VALUE_ENTRY_TYPEDEF_VALUE_OFST 0
+#define       MC_CMD_SENSOR_VALUE_ENTRY_TYPEDEF_VALUE_LEN 2
+#define       MC_CMD_SENSOR_VALUE_ENTRY_TYPEDEF_VALUE_LBN 0
+#define       MC_CMD_SENSOR_VALUE_ENTRY_TYPEDEF_VALUE_WIDTH 16
+#define       MC_CMD_SENSOR_VALUE_ENTRY_TYPEDEF_STATE_OFST 2
+#define       MC_CMD_SENSOR_VALUE_ENTRY_TYPEDEF_STATE_LEN 1
+#define          MC_CMD_SENSOR_STATE_OK  0x0 /* enum */
+#define          MC_CMD_SENSOR_STATE_WARNING  0x1 /* enum */
+#define          MC_CMD_SENSOR_STATE_FATAL  0x2 /* enum */
+#define          MC_CMD_SENSOR_STATE_BROKEN  0x3 /* enum */
+#define       MC_CMD_SENSOR_VALUE_ENTRY_TYPEDEF_STATE_LBN 16
+#define       MC_CMD_SENSOR_VALUE_ENTRY_TYPEDEF_STATE_WIDTH 8
+
+
+/***********************************/
+/* MC_CMD_GET_PHY_STATE 
+ * Report current state of PHY.
+ */
+#define MC_CMD_GET_PHY_STATE  0x43
+
+/* MC_CMD_GET_PHY_STATE_IN msgrequest */
+#define    MC_CMD_GET_PHY_STATE_IN_LEN 0
+
+/* MC_CMD_GET_PHY_STATE_OUT msgresponse */
+#define    MC_CMD_GET_PHY_STATE_OUT_LEN 4
+#define       MC_CMD_GET_PHY_STATE_OUT_STATE_OFST 0
+#define          MC_CMD_PHY_STATE_OK 0x1 /* enum */
+#define          MC_CMD_PHY_STATE_ZOMBIE 0x2 /* enum */
+
+
+/***********************************/
+/* MC_CMD_SETUP_8021QBB 
+ * 802.1Qbb control.
+ */
+#define MC_CMD_SETUP_8021QBB  0x44
+
+/* MC_CMD_SETUP_8021QBB_IN msgrequest */
+#define    MC_CMD_SETUP_8021QBB_IN_LEN 32
+#define       MC_CMD_SETUP_8021QBB_IN_TXQS_OFST 0
+#define       MC_CMD_SETUP_8021QBB_IN_TXQS_LEN 32
+
+/* MC_CMD_SETUP_8021QBB_OUT msgresponse */
+#define    MC_CMD_SETUP_8021QBB_OUT_LEN 0
+
+
+/***********************************/
+/* MC_CMD_WOL_FILTER_GET 
+ * Retrieve ID of any WoL filters.
+ */
+#define MC_CMD_WOL_FILTER_GET  0x45
+
+/* MC_CMD_WOL_FILTER_GET_IN msgrequest */
+#define    MC_CMD_WOL_FILTER_GET_IN_LEN 0
+
+/* MC_CMD_WOL_FILTER_GET_OUT msgresponse */
+#define    MC_CMD_WOL_FILTER_GET_OUT_LEN 4
+#define       MC_CMD_WOL_FILTER_GET_OUT_FILTER_ID_OFST 0
+
+
+/***********************************/
+/* MC_CMD_ADD_LIGHTSOUT_OFFLOAD 
+ * Add a protocol offload to NIC for lights-out state.
+ */
+#define MC_CMD_ADD_LIGHTSOUT_OFFLOAD  0x46
+
+/* MC_CMD_ADD_LIGHTSOUT_OFFLOAD_IN msgrequest */
+#define    MC_CMD_ADD_LIGHTSOUT_OFFLOAD_IN_LENMIN 8
+#define    MC_CMD_ADD_LIGHTSOUT_OFFLOAD_IN_LENMAX 252
+#define    MC_CMD_ADD_LIGHTSOUT_OFFLOAD_IN_LEN(num) (4+4*(num))
+#define       MC_CMD_ADD_LIGHTSOUT_OFFLOAD_IN_PROTOCOL_OFST 0
+#define          MC_CMD_LIGHTSOUT_OFFLOAD_PROTOCOL_ARP 0x1 /* enum */
+#define          MC_CMD_LIGHTSOUT_OFFLOAD_PROTOCOL_NS  0x2 /* enum */
+#define       MC_CMD_ADD_LIGHTSOUT_OFFLOAD_IN_DATA_OFST 4
+#define       MC_CMD_ADD_LIGHTSOUT_OFFLOAD_IN_DATA_LEN 4
+#define       MC_CMD_ADD_LIGHTSOUT_OFFLOAD_IN_DATA_MINNUM 1
+#define       MC_CMD_ADD_LIGHTSOUT_OFFLOAD_IN_DATA_MAXNUM 62
+
+/* MC_CMD_ADD_LIGHTSOUT_OFFLOAD_IN_ARP msgrequest */
+#define    MC_CMD_ADD_LIGHTSOUT_OFFLOAD_IN_ARP_LEN 14
+/*            MC_CMD_ADD_LIGHTSOUT_OFFLOAD_IN_PROTOCOL_OFST 0 */
+#define       MC_CMD_ADD_LIGHTSOUT_OFFLOAD_IN_ARP_MAC_OFST 4
+#define       MC_CMD_ADD_LIGHTSOUT_OFFLOAD_IN_ARP_MAC_LEN 6
+#define       MC_CMD_ADD_LIGHTSOUT_OFFLOAD_IN_ARP_IP_OFST 10
+
+/* MC_CMD_ADD_LIGHTSOUT_OFFLOAD_IN_NS msgrequest */
+#define    MC_CMD_ADD_LIGHTSOUT_OFFLOAD_IN_NS_LEN 42
+/*            MC_CMD_ADD_LIGHTSOUT_OFFLOAD_IN_PROTOCOL_OFST 0 */
+#define       MC_CMD_ADD_LIGHTSOUT_OFFLOAD_IN_NS_MAC_OFST 4
+#define       MC_CMD_ADD_LIGHTSOUT_OFFLOAD_IN_NS_MAC_LEN 6
+#define       MC_CMD_ADD_LIGHTSOUT_OFFLOAD_IN_NS_SNIPV6_OFST 10
+#define       MC_CMD_ADD_LIGHTSOUT_OFFLOAD_IN_NS_SNIPV6_LEN 16
+#define       MC_CMD_ADD_LIGHTSOUT_OFFLOAD_IN_NS_IPV6_OFST 26
+#define       MC_CMD_ADD_LIGHTSOUT_OFFLOAD_IN_NS_IPV6_LEN 16
+
+/* MC_CMD_ADD_LIGHTSOUT_OFFLOAD_OUT msgresponse */
+#define    MC_CMD_ADD_LIGHTSOUT_OFFLOAD_OUT_LEN 4
+#define       MC_CMD_ADD_LIGHTSOUT_OFFLOAD_OUT_FILTER_ID_OFST 0
+
+
+/***********************************/
+/* MC_CMD_REMOVE_LIGHTSOUT_OFFLOAD 
+ * Remove a protocol offload from NIC for lights-out state.
+ */
+#define MC_CMD_REMOVE_LIGHTSOUT_OFFLOAD  0x47
+
+/* MC_CMD_REMOVE_LIGHTSOUT_OFFLOAD_IN msgrequest */
+#define    MC_CMD_REMOVE_LIGHTSOUT_OFFLOAD_IN_LEN 8
+#define       MC_CMD_REMOVE_LIGHTSOUT_OFFLOAD_IN_PROTOCOL_OFST 0
+#define       MC_CMD_REMOVE_LIGHTSOUT_OFFLOAD_IN_FILTER_ID_OFST 4
+
+/* MC_CMD_REMOVE_LIGHTSOUT_OFFLOAD_OUT msgresponse */
+#define    MC_CMD_REMOVE_LIGHTSOUT_OFFLOAD_OUT_LEN 0
+
+
+/***********************************/
+/* MC_CMD_MAC_RESET_RESTORE 
+ * Restore MAC after block reset.
+ */
+#define MC_CMD_MAC_RESET_RESTORE  0x48
+
+/* MC_CMD_MAC_RESET_RESTORE_IN msgrequest */
+#define    MC_CMD_MAC_RESET_RESTORE_IN_LEN 0
+
+/* MC_CMD_MAC_RESET_RESTORE_OUT msgresponse */
+#define    MC_CMD_MAC_RESET_RESTORE_OUT_LEN 0
+
+
+/***********************************/
+/* MC_CMD_TESTASSERT  
+ */
+#define MC_CMD_TESTASSERT   0x49
+
+/* MC_CMD_TESTASSERT_IN msgrequest */
+#define    MC_CMD_TESTASSERT_IN_LEN 0
+
+/* MC_CMD_TESTASSERT_OUT msgresponse */
+#define    MC_CMD_TESTASSERT_OUT_LEN 0
+
+
+/***********************************/
+/* MC_CMD_WORKAROUND 
+ * Enable/Disable a given workaround.
+ */
+#define MC_CMD_WORKAROUND  0x4a
+
+/* MC_CMD_WORKAROUND_IN msgrequest */
+#define    MC_CMD_WORKAROUND_IN_LEN 8
+#define       MC_CMD_WORKAROUND_IN_TYPE_OFST 0
+#define          MC_CMD_WORKAROUND_BUG17230 0x1 /* enum */
+#define       MC_CMD_WORKAROUND_IN_ENABLED_OFST 4
+
+/* MC_CMD_WORKAROUND_OUT msgresponse */
+#define    MC_CMD_WORKAROUND_OUT_LEN 0
+
+
+/***********************************/
+/* MC_CMD_GET_PHY_MEDIA_INFO 
+ * Read media-specific data from PHY.
+ */
+#define MC_CMD_GET_PHY_MEDIA_INFO  0x4b
+
+/* MC_CMD_GET_PHY_MEDIA_INFO_IN msgrequest */
+#define    MC_CMD_GET_PHY_MEDIA_INFO_IN_LEN 4
+#define       MC_CMD_GET_PHY_MEDIA_INFO_IN_PAGE_OFST 0
+
+/* MC_CMD_GET_PHY_MEDIA_INFO_OUT msgresponse */
+#define    MC_CMD_GET_PHY_MEDIA_INFO_OUT_LENMIN 5
+#define    MC_CMD_GET_PHY_MEDIA_INFO_OUT_LENMAX 255
+#define    MC_CMD_GET_PHY_MEDIA_INFO_OUT_LEN(num) (4+1*(num))
+#define       MC_CMD_GET_PHY_MEDIA_INFO_OUT_DATALEN_OFST 0
+#define       MC_CMD_GET_PHY_MEDIA_INFO_OUT_DATA_OFST 4
+#define       MC_CMD_GET_PHY_MEDIA_INFO_OUT_DATA_LEN 1
+#define       MC_CMD_GET_PHY_MEDIA_INFO_OUT_DATA_MINNUM 1
+#define       MC_CMD_GET_PHY_MEDIA_INFO_OUT_DATA_MAXNUM 251
+
+
+/***********************************/
+/* MC_CMD_NVRAM_TEST 
+ * Test a particular NVRAM partition.
+ */
+#define MC_CMD_NVRAM_TEST  0x4c
+
+/* MC_CMD_NVRAM_TEST_IN msgrequest */
+#define    MC_CMD_NVRAM_TEST_IN_LEN 4
+#define       MC_CMD_NVRAM_TEST_IN_TYPE_OFST 0
+/*            Enum values, see field(s): */
+/*               MC_CMD_NVRAM_TYPES/MC_CMD_NVRAM_TYPES_OUT/TYPES */
+
+/* MC_CMD_NVRAM_TEST_OUT msgresponse */
+#define    MC_CMD_NVRAM_TEST_OUT_LEN 4
+#define       MC_CMD_NVRAM_TEST_OUT_RESULT_OFST 0
+#define          MC_CMD_NVRAM_TEST_PASS 0x0 /* enum */
+#define          MC_CMD_NVRAM_TEST_FAIL 0x1 /* enum */
+#define          MC_CMD_NVRAM_TEST_NOTSUPP 0x2 /* enum */
+
+
+/***********************************/
+/* MC_CMD_MRSFP_TWEAK 
+ * Read status and/or set parameters for the 'mrsfp' driver.
+ */
+#define MC_CMD_MRSFP_TWEAK  0x4d
+
+/* MC_CMD_MRSFP_TWEAK_IN_EQ_CONFIG msgrequest */
+#define    MC_CMD_MRSFP_TWEAK_IN_EQ_CONFIG_LEN 16
+#define       MC_CMD_MRSFP_TWEAK_IN_EQ_CONFIG_TXEQ_LEVEL_OFST 0
+#define       MC_CMD_MRSFP_TWEAK_IN_EQ_CONFIG_TXEQ_DT_CFG_OFST 4
+#define       MC_CMD_MRSFP_TWEAK_IN_EQ_CONFIG_RXEQ_BOOST_OFST 8
+#define       MC_CMD_MRSFP_TWEAK_IN_EQ_CONFIG_RXEQ_DT_CFG_OFST 12
+
+/* MC_CMD_MRSFP_TWEAK_IN_READ_ONLY msgrequest */
+#define    MC_CMD_MRSFP_TWEAK_IN_READ_ONLY_LEN 0
+
+/* MC_CMD_MRSFP_TWEAK_OUT msgresponse */
+#define    MC_CMD_MRSFP_TWEAK_OUT_LEN 12
+#define       MC_CMD_MRSFP_TWEAK_OUT_IOEXP_INPUTS_OFST 0
+#define       MC_CMD_MRSFP_TWEAK_OUT_IOEXP_OUTPUTS_OFST 4
+#define       MC_CMD_MRSFP_TWEAK_OUT_IOEXP_DIRECTION_OFST 8
+#define          MC_CMD_MRSFP_TWEAK_OUT_IOEXP_DIRECTION_OUT 0x0 /* enum */
+#define          MC_CMD_MRSFP_TWEAK_OUT_IOEXP_DIRECTION_IN 0x1 /* enum */
+
+
+/***********************************/
+/* MC_CMD_SENSOR_SET_LIMS 
+ * Adjusts the sensor limits.
+ */
+#define MC_CMD_SENSOR_SET_LIMS  0x4e
+
+/* MC_CMD_SENSOR_SET_LIMS_IN msgrequest */
+#define    MC_CMD_SENSOR_SET_LIMS_IN_LEN 20
+#define       MC_CMD_SENSOR_SET_LIMS_IN_SENSOR_OFST 0
+/*            Enum values, see field(s): */
+/*               MC_CMD_SENSOR_INFO/MC_CMD_SENSOR_INFO_OUT/MASK */
+#define       MC_CMD_SENSOR_SET_LIMS_IN_LOW0_OFST 4
+#define       MC_CMD_SENSOR_SET_LIMS_IN_HI0_OFST 8
+#define       MC_CMD_SENSOR_SET_LIMS_IN_LOW1_OFST 12
+#define       MC_CMD_SENSOR_SET_LIMS_IN_HI1_OFST 16
+
+/* MC_CMD_SENSOR_SET_LIMS_OUT msgresponse */
+#define    MC_CMD_SENSOR_SET_LIMS_OUT_LEN 0
+
+
+/***********************************/
+/* MC_CMD_GET_RESOURCE_LIMITS 
+ */
+#define MC_CMD_GET_RESOURCE_LIMITS  0x4f
+
+/* MC_CMD_GET_RESOURCE_LIMITS_IN msgrequest */
+#define    MC_CMD_GET_RESOURCE_LIMITS_IN_LEN 0
+
+/* MC_CMD_GET_RESOURCE_LIMITS_OUT msgresponse */
+#define    MC_CMD_GET_RESOURCE_LIMITS_OUT_LEN 16
+#define       MC_CMD_GET_RESOURCE_LIMITS_OUT_BUFTBL_OFST 0
+#define       MC_CMD_GET_RESOURCE_LIMITS_OUT_EVQ_OFST 4
+#define       MC_CMD_GET_RESOURCE_LIMITS_OUT_RXQ_OFST 8
+#define       MC_CMD_GET_RESOURCE_LIMITS_OUT_TXQ_OFST 12
+
+
+/***********************************/
+/* MC_CMD_INIT_EVQ 
+ */
+#define MC_CMD_INIT_EVQ  0x50
+
+/* MC_CMD_INIT_EVQ_IN msgrequest */
+#define    MC_CMD_INIT_EVQ_IN_LENMIN 36
+#define    MC_CMD_INIT_EVQ_IN_LENMAX 252
+#define    MC_CMD_INIT_EVQ_IN_LEN(num) (28+8*(num))
+#define       MC_CMD_INIT_EVQ_IN_SIZE_OFST 0
+#define       MC_CMD_INIT_EVQ_IN_INSTANCE_OFST 4
+#define          MC_CMD_RESOURCE_INSTANCE_ANY 0xffffffff /* enum */
+#define          MC_CMD_RESOURCE_INSTANCE_NONE 0xfffffffe /* enum */
+#define       MC_CMD_INIT_EVQ_IN_TMR_LOAD_OFST 8
+#define       MC_CMD_INIT_EVQ_IN_TMR_RELOAD_OFST 12
+#define       MC_CMD_INIT_EVQ_IN_FLAGS_OFST 16
+#define        MC_CMD_INIT_EVQ_IN_FLAG_INTERRUPTING_LBN 0
+#define        MC_CMD_INIT_EVQ_IN_FLAG_INTERRUPTING_WIDTH 1
+#define        MC_CMD_INIT_EVQ_IN_FLAG_RPTR_DOS_LBN 1
+#define        MC_CMD_INIT_EVQ_IN_FLAG_RPTR_DOS_WIDTH 1
+#define       MC_CMD_INIT_EVQ_IN_TMR_MODE_OFST 20
+#define          MC_CMD_INIT_EVQ_IN_TMR_MODE_DIS 0x0 /* enum */
+#define          MC_CMD_INIT_EVQ_IN_TMR_IMMED_START 0x1 /* enum */
+#define          MC_CMD_INIT_EVQ_IN_TMR_TRIG_START 0x2 /* enum */
+#define          MC_CMD_INIT_EVQ_IN_TMR_INT_HLDOFF 0x3 /* enum */
+#define       MC_CMD_INIT_EVQ_IN_TARGET_EVQ_OFST 24
+#define       MC_CMD_INIT_EVQ_IN_IRQ_NUM_OFST 24
+#define       MC_CMD_INIT_EVQ_IN_DMA_ADDR_OFST 28
+#define       MC_CMD_INIT_EVQ_IN_DMA_ADDR_LEN 8
+#define       MC_CMD_INIT_EVQ_IN_DMA_ADDR_LO_OFST 28
+#define       MC_CMD_INIT_EVQ_IN_DMA_ADDR_HI_OFST 32
+#define       MC_CMD_INIT_EVQ_IN_DMA_ADDR_MINNUM 1
+#define       MC_CMD_INIT_EVQ_IN_DMA_ADDR_MAXNUM 28
+
+/* MC_CMD_INIT_EVQ_OUT msgresponse */
+#define    MC_CMD_INIT_EVQ_OUT_LEN 12
+#define       MC_CMD_INIT_EVQ_OUT_HANDLE_OFST 0
+#define       MC_CMD_INIT_EVQ_OUT_IDX_OFST 4
+#define       MC_CMD_INIT_EVQ_OUT_IRQ_OFST 8
+
+
+/***********************************/
+/* MC_CMD_INIT_RXQ 
+ */
+#define MC_CMD_INIT_RXQ  0x51
+
+/* MC_CMD_INIT_RXQ_IN msgrequest */
+#define    MC_CMD_INIT_RXQ_IN_LENMIN 32
+#define    MC_CMD_INIT_RXQ_IN_LENMAX 248
+#define    MC_CMD_INIT_RXQ_IN_LEN(num) (24+8*(num))
+#define       MC_CMD_INIT_RXQ_IN_SIZE_OFST 0
+#define       MC_CMD_INIT_RXQ_IN_TARGET_EVQ_OFST 4
+#define       MC_CMD_INIT_RXQ_IN_LABEL_OFST 8
+#define       MC_CMD_INIT_RXQ_IN_INSTANCE_OFST 12
+/*               MC_CMD_RESOURCE_INSTANCE_ANY 0xffffffff */
+/*               MC_CMD_RESOURCE_INSTANCE_NONE 0xfffffffe */
+#define       MC_CMD_INIT_RXQ_IN_FLAGS_OFST 16
+#define        MC_CMD_INIT_RXQ_IN_FLAG_BUFF_MODE_LBN 0
+#define        MC_CMD_INIT_RXQ_IN_FLAG_BUFF_MODE_WIDTH 1
+#define        MC_CMD_INIT_RXQ_IN_FLAG_ISCSI_HDIG_LBN 1
+#define        MC_CMD_INIT_RXQ_IN_FLAG_ISCSI_HDIG_WIDTH 1
+#define        MC_CMD_INIT_RXQ_IN_FLAG_ISCSI_DDIG_LBN 2
+#define        MC_CMD_INIT_RXQ_IN_FLAG_ISCSI_DDIG_WIDTH 1
+#define        MC_CMD_INIT_RXQ_IN_FLAG_HDR_SPLIT_LBN 3
+#define        MC_CMD_INIT_RXQ_IN_FLAG_HDR_SPLIT_WIDTH 1
+#define        MC_CMD_INIT_RXQ_IN_FLAG_PKT_EDIT_LBN 31
+#define        MC_CMD_INIT_RXQ_IN_FLAG_PKT_EDIT_WIDTH 1
+#define       MC_CMD_INIT_RXQ_IN_OWNER_ID_OFST 20
+#define       MC_CMD_INIT_RXQ_IN_DMA_ADDR_OFST 24
+#define       MC_CMD_INIT_RXQ_IN_DMA_ADDR_LEN 8
+#define       MC_CMD_INIT_RXQ_IN_DMA_ADDR_LO_OFST 24
+#define       MC_CMD_INIT_RXQ_IN_DMA_ADDR_HI_OFST 28
+#define       MC_CMD_INIT_RXQ_IN_DMA_ADDR_MINNUM 1
+#define       MC_CMD_INIT_RXQ_IN_DMA_ADDR_MAXNUM 28
+
+/* MC_CMD_INIT_RXQ_OUT msgresponse */
+#define    MC_CMD_INIT_RXQ_OUT_LEN 8
+#define       MC_CMD_INIT_RXQ_OUT_HANDLE_OFST 0
+#define       MC_CMD_INIT_RXQ_OUT_IDX_OFST 4
+
+
+/***********************************/
+/* MC_CMD_INIT_TXQ 
+ */
+#define MC_CMD_INIT_TXQ  0x52
+
+/* MC_CMD_INIT_TXQ_IN msgrequest */
+#define    MC_CMD_INIT_TXQ_IN_LENMIN 32
+#define    MC_CMD_INIT_TXQ_IN_LENMAX 248
+#define    MC_CMD_INIT_TXQ_IN_LEN(num) (24+8*(num))
+#define       MC_CMD_INIT_TXQ_IN_SIZE_OFST 0
+#define       MC_CMD_INIT_TXQ_IN_TARGET_EVQ_OFST 4
+#define       MC_CMD_INIT_TXQ_IN_LABEL_OFST 8
+#define       MC_CMD_INIT_TXQ_IN_INSTANCE_OFST 12
+/*               MC_CMD_RESOURCE_INSTANCE_ANY 0xffffffff */
+/*               MC_CMD_RESOURCE_INSTANCE_NONE 0xfffffffe */
+#define       MC_CMD_INIT_TXQ_IN_FLAGS_OFST 16
+#define        MC_CMD_INIT_TXQ_IN_FLAG_BUFF_MODE_LBN 0
+#define        MC_CMD_INIT_TXQ_IN_FLAG_BUFF_MODE_WIDTH 1
+#define        MC_CMD_INIT_TXQ_IN_FLAG_IP_CSUM_DIS_LBN 1
+#define        MC_CMD_INIT_TXQ_IN_FLAG_IP_CSUM_DIS_WIDTH 1
+#define        MC_CMD_INIT_TXQ_IN_FLAG_TCP_CSUM_DIS_LBN 2
+#define        MC_CMD_INIT_TXQ_IN_FLAG_TCP_CSUM_DIS_WIDTH 1
+#define        MC_CMD_INIT_TXQ_IN_FLAG_TCP_UDP_ONLY_LBN 3
+#define        MC_CMD_INIT_TXQ_IN_FLAG_TCP_UDP_ONLY_WIDTH 1
+#define        MC_CMD_INIT_TXQ_IN_FLAG_ISCSI_HDIG_LBN 4
+#define        MC_CMD_INIT_TXQ_IN_FLAG_ISCSI_HDIG_WIDTH 1
+#define        MC_CMD_INIT_TXQ_IN_FLAG_ISCSI_DDIG_LBN 5
+#define        MC_CMD_INIT_TXQ_IN_FLAG_ISCSI_DDIG_WIDTH 1
+#define        MC_CMD_INIT_TXQ_IN_FLAG_IP_FILT_LBN 6
+#define        MC_CMD_INIT_TXQ_IN_FLAG_IP_FILT_WIDTH 1
+#define        MC_CMD_INIT_TXQ_IN_FLAG_MAC_FILT_LBN 7
+#define        MC_CMD_INIT_TXQ_IN_FLAG_MAC_FILT_WIDTH 1
+#define        MC_CMD_INIT_TXQ_IN_FLAG_QID_MASK_LBN 8
+#define        MC_CMD_INIT_TXQ_IN_FLAG_QID_MASK_WIDTH 2
+#define       MC_CMD_INIT_TXQ_IN_OWNER_ID_OFST 20
+#define       MC_CMD_INIT_TXQ_IN_DMA_ADDR_OFST 24
+#define       MC_CMD_INIT_TXQ_IN_DMA_ADDR_LEN 8
+#define       MC_CMD_INIT_TXQ_IN_DMA_ADDR_LO_OFST 24
+#define       MC_CMD_INIT_TXQ_IN_DMA_ADDR_HI_OFST 28
+#define       MC_CMD_INIT_TXQ_IN_DMA_ADDR_MINNUM 1
+#define       MC_CMD_INIT_TXQ_IN_DMA_ADDR_MAXNUM 28
+
+/* MC_CMD_INIT_TXQ_OUT msgresponse */
+#define    MC_CMD_INIT_TXQ_OUT_LEN 8
+#define       MC_CMD_INIT_TXQ_OUT_HANDLE_OFST 0
+#define       MC_CMD_INIT_TXQ_OUT_IDX_OFST 4
+
+
+/***********************************/
+/* MC_CMD_INSERT_FILTER 
+ */
+#define MC_CMD_INSERT_FILTER  0x53
+
+/* MC_CMD_INSERT_FILTER_IN msgrequest */
+#define    MC_CMD_INSERT_FILTER_IN_LEN 24
+#define       MC_CMD_INSERT_FILTER_IN_DSTQ_OFST 0
+#define       MC_CMD_INSERT_FILTER_IN_SRCQ_OFST 4
+#define       MC_CMD_INSERT_FILTER_IN_TYPE_OFST 8
+#define          MC_CMD_INSERT_FILTER_IN_TYPE_TCP 0x1 /* enum */
+#define          MC_CMD_INSERT_FILTER_IN_TYPE_UDP 0x2 /* enum */
+#define          MC_CMD_INSERT_FILTER_IN_TYPE_MAC 0x3 /* enum */
+#define          MC_CMD_INSERT_FILTER_IN_TYPE_MACVLAN 0x4 /* enum */
+#define          MC_CMD_INSERT_FILTER_IN_TYPE_TCPWILD 0x5 /* enum */
+#define          MC_CMD_INSERT_FILTER_IN_TYPE_UDPWILD 0x6 /* enum */
+#define       MC_CMD_INSERT_FILTER_IN_DATA_OFST 12
+#define       MC_CMD_INSERT_FILTER_IN_DATA_LEN 12
+
+/* MC_CMD_INSERT_FILTER_IN_IPV4TCP msgrequest */
+#define    MC_CMD_INSERT_FILTER_IN_IPV4TCP_LEN 28
+/*            MC_CMD_INSERT_FILTER_IN_DSTQ_OFST 0 */
+/*            MC_CMD_INSERT_FILTER_IN_SRCQ_OFST 4 */
+/*            MC_CMD_INSERT_FILTER_IN_TYPE_OFST 8 */
+/*            Enum values, see field(s): */
+/*               MC_CMD_INSERT_FILTER_IN/TYPE */
+#define       MC_CMD_INSERT_FILTER_IN_IPV4TCP_SRC_ADDR_OFST 12
+#define       MC_CMD_INSERT_FILTER_IN_IPV4TCP_SRC_PORT_OFST 16
+#define       MC_CMD_INSERT_FILTER_IN_IPV4TCP_DST_ADDR_OFST 20
+#define       MC_CMD_INSERT_FILTER_IN_IPV4TCP_DST_PORT_OFST 24
+
+/* MC_CMD_INSERT_FILTER_IN_IPV4UDP msgrequest */
+#define    MC_CMD_INSERT_FILTER_IN_IPV4UDP_LEN 28
+/*            MC_CMD_INSERT_FILTER_IN_DSTQ_OFST 0 */
+/*            MC_CMD_INSERT_FILTER_IN_SRCQ_OFST 4 */
+/*            MC_CMD_INSERT_FILTER_IN_TYPE_OFST 8 */
+/*            Enum values, see field(s): */
+/*               MC_CMD_INSERT_FILTER_IN/TYPE */
+#define       MC_CMD_INSERT_FILTER_IN_IPV4UDP_SRC_ADDR_OFST 12
+#define       MC_CMD_INSERT_FILTER_IN_IPV4UDP_SRC_PORT_OFST 16
+#define       MC_CMD_INSERT_FILTER_IN_IPV4UDP_DST_ADDR_OFST 20
+#define       MC_CMD_INSERT_FILTER_IN_IPV4UDP_DST_PORT_OFST 24
+
+/* MC_CMD_INSERT_FILTER_IN_MAC msgrequest */
+#define    MC_CMD_INSERT_FILTER_IN_MAC_LEN 18
+/*            MC_CMD_INSERT_FILTER_IN_DSTQ_OFST 0 */
+/*            MC_CMD_INSERT_FILTER_IN_SRCQ_OFST 4 */
+/*            MC_CMD_INSERT_FILTER_IN_TYPE_OFST 8 */
+/*            Enum values, see field(s): */
+/*               MC_CMD_INSERT_FILTER_IN/TYPE */
+#define       MC_CMD_INSERT_FILTER_IN_MAC_ADDR_OFST 12
+#define       MC_CMD_INSERT_FILTER_IN_MAC_ADDR_LEN 6
+
+/* MC_CMD_INSERT_FILTER_IN_MACVLAN msgrequest */
+#define    MC_CMD_INSERT_FILTER_IN_MACVLAN_LEN 20
+/*            MC_CMD_INSERT_FILTER_IN_DSTQ_OFST 0 */
+/*            MC_CMD_INSERT_FILTER_IN_SRCQ_OFST 4 */
+/*            MC_CMD_INSERT_FILTER_IN_TYPE_OFST 8 */
+/*            Enum values, see field(s): */
+/*               MC_CMD_INSERT_FILTER_IN/TYPE */
+#define       MC_CMD_INSERT_FILTER_IN_MACVLAN_ADDR_OFST 12
+#define       MC_CMD_INSERT_FILTER_IN_MACVLAN_ADDR_LEN 6
+#define       MC_CMD_INSERT_FILTER_IN_MACVLAN_VLAN_OFST 18
+#define       MC_CMD_INSERT_FILTER_IN_MACVLAN_VLAN_LEN 2
+
+/* MC_CMD_INSERT_FILTER_OUT msgresponse */
+#define    MC_CMD_INSERT_FILTER_OUT_LEN 4
+#define       MC_CMD_INSERT_FILTER_OUT_HANDLE_OFST 0
+
+
+/***********************************/
+/* MC_CMD_FINI_EVQ 
+ */
+#define MC_CMD_FINI_EVQ  0x55
+
+/* MC_CMD_FINI_EVQ_IN msgrequest */
+#define    MC_CMD_FINI_EVQ_IN_LEN 4
+#define       MC_CMD_FINI_EVQ_IN_HANDLE_OFST 0
+
+/* MC_CMD_FINI_EVQ_OUT msgresponse */
+#define    MC_CMD_FINI_EVQ_OUT_LEN 0
+
+
+/***********************************/
+/* MC_CMD_FINI_RXQ 
+ */
+#define MC_CMD_FINI_RXQ  0x56
+
+/* MC_CMD_FINI_RXQ_IN msgrequest */
+#define    MC_CMD_FINI_RXQ_IN_LEN 4
+#define       MC_CMD_FINI_RXQ_IN_HANDLE_OFST 0
+
+/* MC_CMD_FINI_RXQ_OUT msgresponse */
+#define    MC_CMD_FINI_RXQ_OUT_LEN 0
+
+
+/***********************************/
+/* MC_CMD_FINI_TXQ 
+ */
+#define MC_CMD_FINI_TXQ  0x57
+
+/* MC_CMD_FINI_TXQ_IN msgrequest */
+#define    MC_CMD_FINI_TXQ_IN_LEN 4
+#define       MC_CMD_FINI_TXQ_IN_HANDLE_OFST 0
+
+/* MC_CMD_FINI_TXQ_OUT msgresponse */
+#define    MC_CMD_FINI_TXQ_OUT_LEN 0
+
+
+/***********************************/
+/* MC_CMD_REMOVE_FILTER 
+ */
+#define MC_CMD_REMOVE_FILTER  0x58
+
+/* MC_CMD_REMOVE_FILTER_IN msgrequest */
+#define    MC_CMD_REMOVE_FILTER_IN_LEN 4
+#define       MC_CMD_REMOVE_FILTER_IN_HANDLE_OFST 0
+
+/* MC_CMD_REMOVE_FILTER_OUT msgresponse */
+#define    MC_CMD_REMOVE_FILTER_OUT_LEN 0
+
+
+/***********************************/
+/* MC_CMD_DRIVER_EVENT 
+ */
+#define MC_CMD_DRIVER_EVENT  0x5a
+
+/* MC_CMD_DRIVER_EVENT_IN msgrequest */
+#define    MC_CMD_DRIVER_EVENT_IN_LEN 12
+#define       MC_CMD_DRIVER_EVENT_IN_EVQ_OFST 0
+#define       MC_CMD_DRIVER_EVENT_IN_DATA_OFST 4
+#define       MC_CMD_DRIVER_EVENT_IN_DATA_LEN 8
+#define       MC_CMD_DRIVER_EVENT_IN_DATA_LO_OFST 4
+#define       MC_CMD_DRIVER_EVENT_IN_DATA_HI_OFST 8
+
+
+/***********************************/
+/* MC_CMD_PROXY_CMD 
+ */
+#define MC_CMD_PROXY_CMD  0x5b
+
+/* MC_CMD_PROXY_CMD_IN msgrequest */
+#define    MC_CMD_PROXY_CMD_IN_LEN 4
+#define       MC_CMD_PROXY_CMD_IN_TARGET_OFST 0
+
+
+/***********************************/
+/* MC_CMD_ALLOC_OWNER_IDS 
+ */
+#define MC_CMD_ALLOC_OWNER_IDS  0x54
+
+/* MC_CMD_ALLOC_OWNER_IDS_IN msgrequest */
+#define    MC_CMD_ALLOC_OWNER_IDS_IN_LEN 4
+#define       MC_CMD_ALLOC_OWNER_IDS_IN_NIDS_OFST 0
+
+/* MC_CMD_ALLOC_OWNER_IDS_OUT msgresponse */
+#define    MC_CMD_ALLOC_OWNER_IDS_OUT_LEN 12
+#define       MC_CMD_ALLOC_OWNER_IDS_OUT_HANDLE_OFST 0
+#define       MC_CMD_ALLOC_OWNER_IDS_OUT_NIDS_OFST 4
+#define       MC_CMD_ALLOC_OWNER_IDS_OUT_BASE_OFST 8
+
+
+/***********************************/
+/* MC_CMD_FREE_OWNER_IDS 
+ */
+#define MC_CMD_FREE_OWNER_IDS  0x59
+
+/* MC_CMD_FREE_OWNER_IDS_IN msgrequest */
+#define    MC_CMD_FREE_OWNER_IDS_IN_LEN 4
+#define       MC_CMD_FREE_OWNER_IDS_IN_HANDLE_OFST 0
+
+/* MC_CMD_FREE_OWNER_IDS_OUT msgresponse */
+#define    MC_CMD_FREE_OWNER_IDS_OUT_LEN 0
+
+
+/***********************************/
+/* MC_CMD_ALLOC_BUFTBL_CHUNK 
+ */
+#define MC_CMD_ALLOC_BUFTBL_CHUNK  0x5c
+
+/* MC_CMD_ALLOC_BUFTBL_CHUNK_IN msgrequest */
+#define    MC_CMD_ALLOC_BUFTBL_CHUNK_IN_LEN 4
+#define       MC_CMD_ALLOC_BUFTBL_CHUNK_IN_OWNER_OFST 0
+
+/* MC_CMD_ALLOC_BUFTBL_CHUNK_OUT msgresponse */
+#define    MC_CMD_ALLOC_BUFTBL_CHUNK_OUT_LEN 12
+#define       MC_CMD_ALLOC_BUFTBL_CHUNK_OUT_HANDLE_OFST 0
+#define       MC_CMD_ALLOC_BUFTBL_CHUNK_OUT_NUMENTRIES_OFST 4
+#define       MC_CMD_ALLOC_BUFTBL_CHUNK_OUT_ID_OFST 8
+
+
+/***********************************/
+/* MC_CMD_PROGRAM_BUFTBL_ENTRIES 
+ */
+#define MC_CMD_PROGRAM_BUFTBL_ENTRIES  0x5d
+
+/* MC_CMD_PROGRAM_BUFTBL_ENTRIES_IN msgrequest */
+#define    MC_CMD_PROGRAM_BUFTBL_ENTRIES_IN_LENMIN 20
+#define    MC_CMD_PROGRAM_BUFTBL_ENTRIES_IN_LENMAX 252
+#define    MC_CMD_PROGRAM_BUFTBL_ENTRIES_IN_LEN(num) (12+8*(num))
+#define       MC_CMD_PROGRAM_BUFTBL_ENTRIES_IN_HANDLE_OFST 0
+#define       MC_CMD_PROGRAM_BUFTBL_ENTRIES_IN_FIRSTID_OFST 4
+#define       MC_CMD_PROGRAM_BUFTBL_ENTRIES_IN_NUMENTRIES_OFST 8
+#define       MC_CMD_PROGRAM_BUFTBL_ENTRIES_IN_ENTRY_OFST 12
+#define       MC_CMD_PROGRAM_BUFTBL_ENTRIES_IN_ENTRY_LEN 8
+#define       MC_CMD_PROGRAM_BUFTBL_ENTRIES_IN_ENTRY_LO_OFST 12
+#define       MC_CMD_PROGRAM_BUFTBL_ENTRIES_IN_ENTRY_HI_OFST 16
+#define       MC_CMD_PROGRAM_BUFTBL_ENTRIES_IN_ENTRY_MINNUM 1
+#define       MC_CMD_PROGRAM_BUFTBL_ENTRIES_IN_ENTRY_MAXNUM 30
+
+/* MC_CMD_PROGRAM_BUFTBL_ENTRIES_OUT msgresponse */
+#define    MC_CMD_PROGRAM_BUFTBL_ENTRIES_OUT_LEN 0
+
+
+/***********************************/
+/* MC_CMD_FREE_BUFTBL_CHUNK 
+ */
+#define MC_CMD_FREE_BUFTBL_CHUNK  0x5e
+
+/* MC_CMD_FREE_BUFTBL_CHUNK_IN msgrequest */
+#define    MC_CMD_FREE_BUFTBL_CHUNK_IN_LEN 4
+#define       MC_CMD_FREE_BUFTBL_CHUNK_IN_HANDLE_OFST 0
+
+/* MC_CMD_FREE_BUFTBL_CHUNK_OUT msgresponse */
+#define    MC_CMD_FREE_BUFTBL_CHUNK_OUT_LEN 0
+
+
+#endif /* MCDI_PCOL_H */
diff -r 5b3d4d3c1166 drivers/net/sfc/mcdi_phy.c
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/drivers/net/sfc/mcdi_phy.c	Tue Nov 09 10:06:27 2010 +0000
@@ -0,0 +1,904 @@
+/****************************************************************************
+ * Driver for Solarflare Solarstorm network controllers and boards
+ * Copyright 2009 Solarflare Communications Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 as published
+ * by the Free Software Foundation, incorporated herein by reference.
+ */
+
+/*
+ * Driver for PHY related operations via MCDI.
+ */
+
+#include <linux/slab.h>
+#include <linux/seq_file.h>
+#include "efx.h"
+#include "debugfs.h"
+#include "phy.h"
+#include "mcdi.h"
+#include "mcdi_pcol.h"
+#include "mdio_10g.h"
+#include "nic.h"
+#include "selftest.h"
+
+struct efx_mcdi_phy_data {
+	u32 flags;
+	u32 type;
+	u32 supported_cap;
+	u32 channel;
+	u32 port;
+	u32 stats_mask;
+	u8 name[20];
+	u32 media;
+	u32 mmd_mask;
+	u8 revision[20];
+#ifdef CONFIG_SFC_DEBUGFS
+	struct efx_nic *efx;
+	void *stats;
+	dma_addr_t stats_addr;
+	u8 index[MC_CMD_PHY_NSTATS];
+#endif
+};
+
+#ifdef CONFIG_SFC_DEBUGFS
+
+/* DMA all of the phy statistics, and return a single statistic out of the block.
+ * Means we can't view a snapshot of all the statistics, but they're not
+ * populated in zero time anyway */
+static int efx_mcdi_phy_stats_read(struct seq_file *file, void *data)
+{
+	u8 pos = *((u8 *)data);
+	struct efx_mcdi_phy_data *phy_data =
+		container_of(data, struct efx_mcdi_phy_data, index[pos]);
+	struct efx_nic *efx = phy_data->efx;
+	efx_dword_t *value;
+	u8 inbuf[MC_CMD_PHY_STATS_IN_LEN];
+	int rc;
+
+	MCDI_SET_DWORD(inbuf, PHY_STATS_IN_DMA_ADDR_LO,
+		       (u32)phy_data->stats_addr);
+	MCDI_SET_DWORD(inbuf, PHY_STATS_IN_DMA_ADDR_HI,
+		       (u32)((u64)phy_data->stats_addr >> 32));
+	BUILD_BUG_ON(MC_CMD_PHY_STATS_OUT_DMA_LEN != 0);
+
+	rc = efx_mcdi_rpc(efx, MC_CMD_PHY_STATS, inbuf, MC_CMD_PHY_STATS_IN_LEN,
+			  NULL, 0, NULL);
+	if (rc)
+		return rc;
+
+	value = (efx_dword_t *)phy_data->stats + pos;
+
+	return seq_printf(file, "%d", EFX_DWORD_FIELD(*value, EFX_DWORD_0));
+}
+
+#define PHY_STAT_PARAMETER(_index, _name)				\
+	[_index] = EFX_NAMED_PARAMETER(_name,				\
+				       struct efx_mcdi_phy_data,	\
+				       index[_index], u8,		\
+				       efx_mcdi_phy_stats_read)
+
+static struct efx_debugfs_parameter debug_entries[] = {
+	PHY_STAT_PARAMETER(MC_CMD_OUI, oui),
+	PHY_STAT_PARAMETER(MC_CMD_PMA_PMD_LINK_UP, pma_pmd_link_up),
+	PHY_STAT_PARAMETER(MC_CMD_PMA_PMD_RX_FAULT, pma_pmd_rx_fault),
+	PHY_STAT_PARAMETER(MC_CMD_PMA_PMD_TX_FAULT, pma_pmd_tx_fault),
+	PHY_STAT_PARAMETER(MC_CMD_PMA_PMD_SIGNAL, pma_pmd_signal),
+	PHY_STAT_PARAMETER(MC_CMD_PMA_PMD_SNR_A, pma_pmd_snr_a),
+	PHY_STAT_PARAMETER(MC_CMD_PMA_PMD_SNR_B, pma_pmd_snr_b),
+	PHY_STAT_PARAMETER(MC_CMD_PMA_PMD_SNR_C, pma_pmd_snr_c),
+	PHY_STAT_PARAMETER(MC_CMD_PMA_PMD_SNR_D, pma_pmd_snr_d),
+	PHY_STAT_PARAMETER(MC_CMD_PCS_LINK_UP, pcs_link_up),
+	PHY_STAT_PARAMETER(MC_CMD_PCS_RX_FAULT, pcs_rx_fault),
+	PHY_STAT_PARAMETER(MC_CMD_PCS_TX_FAULT, pcs_tx_fault),
+	PHY_STAT_PARAMETER(MC_CMD_PCS_BER, pcs_ber),
+	PHY_STAT_PARAMETER(MC_CMD_PCS_BLOCK_ERRORS, pcs_block_errors),
+	PHY_STAT_PARAMETER(MC_CMD_PHYXS_LINK_UP, phyxs_link_up),
+	PHY_STAT_PARAMETER(MC_CMD_PHYXS_RX_FAULT, phxys_rx_fault),
+	PHY_STAT_PARAMETER(MC_CMD_PHYXS_TX_FAULT, phyxs_tx_fault),
+	PHY_STAT_PARAMETER(MC_CMD_PHYXS_ALIGN, phyxs_align),
+	PHY_STAT_PARAMETER(MC_CMD_PHYXS_SYNC, phyxs_sync),
+	PHY_STAT_PARAMETER(MC_CMD_AN_LINK_UP, an_link_up),
+	PHY_STAT_PARAMETER(MC_CMD_AN_COMPLETE, an_complete),
+	PHY_STAT_PARAMETER(MC_CMD_AN_10GBT_STATUS, an_10gbt_status),
+	PHY_STAT_PARAMETER(MC_CMD_CL22_LINK_UP, cl22_link_up),
+	{NULL},
+};
+
+static int efx_mcdi_phy_stats_init(struct efx_nic *efx)
+{
+	struct efx_mcdi_phy_data *phy_data = efx->phy_data;
+	int pos, rc;
+
+	/* debug_entries[] must be contiguous */
+	BUILD_BUG_ON(ARRAY_SIZE(debug_entries) != MC_CMD_PHY_NSTATS + 1);
+
+	/* Allocata a DMA buffer for phy stats */
+	phy_data->stats = pci_alloc_consistent(efx->pci_dev, PAGE_SIZE,
+					       &phy_data->stats_addr);
+	if (phy_data->stats == NULL)
+		return -ENOMEM;
+
+	phy_data->efx = efx;
+	for (pos = 0; pos < MC_CMD_PHY_NSTATS; ++pos)
+		phy_data->index[pos] = pos;
+	rc = efx_extend_debugfs_port(efx, phy_data, ~phy_data->stats_mask,
+				     debug_entries);
+	if (rc < 0)
+		goto fail;
+
+	return 0;
+
+fail:
+	pci_free_consistent(efx->pci_dev, PAGE_SIZE, phy_data->stats,
+			    phy_data->stats_addr);
+
+	return rc;
+}
+	
+static void efx_mcdi_phy_stats_fini(struct efx_nic *efx)
+{
+	struct efx_mcdi_phy_data *phy_data = efx->phy_data;
+
+	efx_trim_debugfs_port(efx, debug_entries);
+	pci_free_consistent(efx->pci_dev, PAGE_SIZE, phy_data->stats,
+			    phy_data->stats_addr);
+}
+
+#endif
+
+
+static int
+efx_mcdi_get_phy_cfg(struct efx_nic *efx, struct efx_mcdi_phy_data *cfg)
+{
+	u8 outbuf[MC_CMD_GET_PHY_CFG_OUT_LEN];
+	size_t outlen;
+	int rc;
+
+	BUILD_BUG_ON(MC_CMD_GET_PHY_CFG_IN_LEN != 0);
+	BUILD_BUG_ON(MC_CMD_GET_PHY_CFG_OUT_NAME_LEN != sizeof(cfg->name));
+
+	rc = efx_mcdi_rpc(efx, MC_CMD_GET_PHY_CFG, NULL, 0,
+			  outbuf, sizeof(outbuf), &outlen);
+	if (rc)
+		goto fail;
+
+	if (outlen < MC_CMD_GET_PHY_CFG_OUT_LEN) {
+		rc = -EIO;
+		goto fail;
+	}
+
+	cfg->flags = MCDI_DWORD(outbuf, GET_PHY_CFG_OUT_FLAGS);
+	cfg->type = MCDI_DWORD(outbuf, GET_PHY_CFG_OUT_TYPE);
+	cfg->supported_cap =
+		MCDI_DWORD(outbuf, GET_PHY_CFG_OUT_SUPPORTED_CAP);
+	cfg->channel = MCDI_DWORD(outbuf, GET_PHY_CFG_OUT_CHANNEL);
+	cfg->port = MCDI_DWORD(outbuf, GET_PHY_CFG_OUT_PRT);
+	cfg->stats_mask = MCDI_DWORD(outbuf, GET_PHY_CFG_OUT_STATS_MASK);
+	memcpy(cfg->name, MCDI_PTR(outbuf, GET_PHY_CFG_OUT_NAME),
+	       sizeof(cfg->name));
+	cfg->media = MCDI_DWORD(outbuf, GET_PHY_CFG_OUT_MEDIA_TYPE);
+	cfg->mmd_mask = MCDI_DWORD(outbuf, GET_PHY_CFG_OUT_MMD_MASK);
+	memcpy(cfg->revision, MCDI_PTR(outbuf, GET_PHY_CFG_OUT_REVISION),
+	       sizeof(cfg->revision));
+
+	return 0;
+
+fail:
+	netif_err(efx, hw, efx->net_dev, "%s: failed rc=%d\n", __func__, rc);
+	return rc;
+}
+
+static int efx_mcdi_set_link(struct efx_nic *efx, u32 capabilities,
+			     u32 flags, u32 loopback_mode,
+			     u32 loopback_speed)
+{
+	u8 inbuf[MC_CMD_SET_LINK_IN_LEN];
+	int rc;
+
+	BUILD_BUG_ON(MC_CMD_SET_LINK_OUT_LEN != 0);
+
+	MCDI_SET_DWORD(inbuf, SET_LINK_IN_CAP, capabilities);
+	MCDI_SET_DWORD(inbuf, SET_LINK_IN_FLAGS, flags);
+	MCDI_SET_DWORD(inbuf, SET_LINK_IN_LOOPBACK_MODE, loopback_mode);
+	MCDI_SET_DWORD(inbuf, SET_LINK_IN_LOOPBACK_SPEED, loopback_speed);
+
+	rc = efx_mcdi_rpc(efx, MC_CMD_SET_LINK, inbuf, sizeof(inbuf),
+			  NULL, 0, NULL);
+	if (rc)
+		goto fail;
+
+	return 0;
+
+fail:
+	netif_err(efx, hw, efx->net_dev, "%s: failed rc=%d\n", __func__, rc);
+	return rc;
+}
+
+static int efx_mcdi_loopback_modes(struct efx_nic *efx, u64 *loopback_modes)
+{
+	u8 outbuf[MC_CMD_GET_LOOPBACK_MODES_OUT_LEN];
+	size_t outlen;
+	int rc;
+
+	rc = efx_mcdi_rpc(efx, MC_CMD_GET_LOOPBACK_MODES, NULL, 0,
+			  outbuf, sizeof(outbuf), &outlen);
+	if (rc)
+		goto fail;
+
+	if (outlen < MC_CMD_GET_LOOPBACK_MODES_OUT_LEN) {
+		rc = -EIO;
+		goto fail;
+	}
+
+	*loopback_modes = MCDI_QWORD(outbuf, 
+				     GET_LOOPBACK_MODES_OUT_SUGGESTED);
+
+	return 0;
+
+fail:
+	netif_err(efx, hw, efx->net_dev, "%s: failed rc=%d\n", __func__, rc);
+	return rc;
+}
+
+int efx_mcdi_mdio_read(struct efx_nic *efx, unsigned int bus,
+			 unsigned int prtad, unsigned int devad, u16 addr,
+			 u16 *value_out, u32 *status_out)
+{
+	u8 inbuf[MC_CMD_MDIO_READ_IN_LEN];
+	u8 outbuf[MC_CMD_MDIO_READ_OUT_LEN];
+	size_t outlen;
+	int rc;
+
+	MCDI_SET_DWORD(inbuf, MDIO_READ_IN_BUS, bus);
+	MCDI_SET_DWORD(inbuf, MDIO_READ_IN_PRTAD, prtad);
+	MCDI_SET_DWORD(inbuf, MDIO_READ_IN_DEVAD, devad);
+	MCDI_SET_DWORD(inbuf, MDIO_READ_IN_ADDR, addr);
+
+	rc = efx_mcdi_rpc(efx, MC_CMD_MDIO_READ, inbuf, sizeof(inbuf),
+			  outbuf, sizeof(outbuf), &outlen);
+	if (rc)
+		goto fail;
+
+	*value_out = (u16)MCDI_DWORD(outbuf, MDIO_READ_OUT_VALUE);
+	*status_out = MCDI_DWORD(outbuf, MDIO_READ_OUT_STATUS);
+	return 0;
+
+fail:
+	netif_err(efx, hw, efx->net_dev, "%s: failed rc=%d\n", __func__, rc);
+	return rc;
+}
+
+int efx_mcdi_mdio_write(struct efx_nic *efx, unsigned int bus,
+			  unsigned int prtad, unsigned int devad, u16 addr,
+			  u16 value, u32 *status_out)
+{
+	u8 inbuf[MC_CMD_MDIO_WRITE_IN_LEN];
+	u8 outbuf[MC_CMD_MDIO_WRITE_OUT_LEN];
+	size_t outlen;
+	int rc;
+
+	MCDI_SET_DWORD(inbuf, MDIO_WRITE_IN_BUS, bus);
+	MCDI_SET_DWORD(inbuf, MDIO_WRITE_IN_PRTAD, prtad);
+	MCDI_SET_DWORD(inbuf, MDIO_WRITE_IN_DEVAD, devad);
+	MCDI_SET_DWORD(inbuf, MDIO_WRITE_IN_ADDR, addr);
+	MCDI_SET_DWORD(inbuf, MDIO_WRITE_IN_VALUE, value);
+
+	rc = efx_mcdi_rpc(efx, MC_CMD_MDIO_WRITE, inbuf, sizeof(inbuf),
+			  outbuf, sizeof(outbuf), &outlen);
+	if (rc)
+		goto fail;
+
+	*status_out = MCDI_DWORD(outbuf, MDIO_WRITE_OUT_STATUS);
+	return 0;
+
+fail:
+	netif_err(efx, hw, efx->net_dev, "%s: failed rc=%d\n", __func__, rc);
+	return rc;
+}
+
+static u32 mcdi_to_ethtool_cap(u32 media, u32 cap)
+{
+	u32 result = 0;
+
+	switch (media) {
+	case MC_CMD_MEDIA_KX4:
+		result |= SUPPORTED_Backplane;
+		if (cap & (1 << MC_CMD_PHY_CAP_1000FDX_LBN))
+			result |= SUPPORTED_1000baseKX_Full;
+		if (cap & (1 << MC_CMD_PHY_CAP_10000FDX_LBN))
+			result |= SUPPORTED_10000baseKX4_Full;
+		break;
+
+	case MC_CMD_MEDIA_XFP:
+	case MC_CMD_MEDIA_SFP_PLUS:
+		result |= SUPPORTED_FIBRE;
+		if (cap & (1 << MC_CMD_PHY_CAP_1000FDX_LBN))
+			result |= SUPPORTED_1000baseT_Full;
+		if (cap & (1 << MC_CMD_PHY_CAP_10000FDX_LBN))
+			result |= SUPPORTED_10000baseT_Full;	
+		break;
+
+	case MC_CMD_MEDIA_BASE_T:
+		result |= SUPPORTED_TP;
+		if (cap & (1 << MC_CMD_PHY_CAP_10HDX_LBN))
+			result |= SUPPORTED_10baseT_Half;
+		if (cap & (1 << MC_CMD_PHY_CAP_10FDX_LBN))
+			result |= SUPPORTED_10baseT_Full;
+		if (cap & (1 << MC_CMD_PHY_CAP_100HDX_LBN))
+			result |= SUPPORTED_100baseT_Half;
+		if (cap & (1 << MC_CMD_PHY_CAP_100FDX_LBN))
+			result |= SUPPORTED_100baseT_Full;
+		if (cap & (1 << MC_CMD_PHY_CAP_1000HDX_LBN))
+			result |= SUPPORTED_1000baseT_Half;
+		if (cap & (1 << MC_CMD_PHY_CAP_1000FDX_LBN))
+			result |= SUPPORTED_1000baseT_Full;
+		if (cap & (1 << MC_CMD_PHY_CAP_10000FDX_LBN))
+			result |= SUPPORTED_10000baseT_Full;
+		break;
+	}
+
+	if (cap & (1 << MC_CMD_PHY_CAP_PAUSE_LBN))
+		result |= SUPPORTED_Pause;
+	if (cap & (1 << MC_CMD_PHY_CAP_ASYM_LBN))
+		result |= SUPPORTED_Asym_Pause;
+	if (cap & (1 << MC_CMD_PHY_CAP_AN_LBN))
+		result |= SUPPORTED_Autoneg;
+
+	return result;
+}
+
+static u32 ethtool_to_mcdi_cap(u32 cap)
+{
+	u32 result = 0;
+
+	if (cap & SUPPORTED_10baseT_Half)
+		result |= (1 << MC_CMD_PHY_CAP_10HDX_LBN);
+	if (cap & SUPPORTED_10baseT_Full)
+		result |= (1 << MC_CMD_PHY_CAP_10FDX_LBN);
+	if (cap & SUPPORTED_100baseT_Half)
+		result |= (1 << MC_CMD_PHY_CAP_100HDX_LBN);
+	if (cap & SUPPORTED_100baseT_Full)
+		result |= (1 << MC_CMD_PHY_CAP_100FDX_LBN);
+	if (cap & SUPPORTED_1000baseT_Half)
+		result |= (1 << MC_CMD_PHY_CAP_1000HDX_LBN);
+	if (cap & (SUPPORTED_1000baseT_Full | SUPPORTED_1000baseKX_Full))
+		result |= (1 << MC_CMD_PHY_CAP_1000FDX_LBN);
+	if (cap & (SUPPORTED_10000baseT_Full | SUPPORTED_10000baseKX4_Full))
+		result |= (1 << MC_CMD_PHY_CAP_10000FDX_LBN);
+	if (cap & SUPPORTED_Pause)
+		result |= (1 << MC_CMD_PHY_CAP_PAUSE_LBN);
+	if (cap & SUPPORTED_Asym_Pause)
+		result |= (1 << MC_CMD_PHY_CAP_ASYM_LBN);
+	if (cap & SUPPORTED_Autoneg)
+		result |= (1 << MC_CMD_PHY_CAP_AN_LBN);
+
+	return result;
+}
+
+static u32 efx_get_mcdi_phy_flags(struct efx_nic *efx)
+{
+	struct efx_mcdi_phy_data *phy_cfg = efx->phy_data;
+	enum efx_phy_mode mode, supported;
+	u32 flags;
+
+	/* TODO: Advertise the capabilities supported by this PHY */
+	supported = 0;
+	if (phy_cfg->flags & (1 << MC_CMD_GET_PHY_CFG_OUT_TXDIS_LBN))
+		supported |= PHY_MODE_TX_DISABLED;
+	if (phy_cfg->flags & (1 << MC_CMD_GET_PHY_CFG_OUT_LOWPOWER_LBN))
+		supported |= PHY_MODE_LOW_POWER;
+	if (phy_cfg->flags & (1 << MC_CMD_GET_PHY_CFG_OUT_POWEROFF_LBN))
+		supported |= PHY_MODE_OFF;
+
+	mode = efx->phy_mode & supported;
+
+	flags = 0;
+	if (mode & PHY_MODE_TX_DISABLED)
+		flags |= (1 << MC_CMD_SET_LINK_IN_TXDIS_LBN);
+	if (mode & PHY_MODE_LOW_POWER)
+		flags |= (1 << MC_CMD_SET_LINK_IN_LOWPOWER_LBN);
+	if (mode & PHY_MODE_OFF)
+		flags |= (1 << MC_CMD_SET_LINK_IN_POWEROFF_LBN);
+
+	return flags;
+}
+
+static u32 mcdi_to_ethtool_media(u32 media)
+{
+	switch (media) {
+	case MC_CMD_MEDIA_XAUI:
+	case MC_CMD_MEDIA_CX4:
+	case MC_CMD_MEDIA_KX4:
+		return PORT_OTHER;
+
+	case MC_CMD_MEDIA_XFP:
+	case MC_CMD_MEDIA_SFP_PLUS:
+		return PORT_FIBRE;
+
+	case MC_CMD_MEDIA_BASE_T:
+		return PORT_TP;
+
+	default:
+		return PORT_OTHER;
+	}
+}
+
+static int efx_mcdi_phy_probe(struct efx_nic *efx)
+{
+	struct efx_mcdi_phy_data *phy_data;
+	u8 outbuf[MC_CMD_GET_LINK_OUT_LEN];
+	u32 caps;
+	int rc;
+
+	/* Initialise and populate phy_data */
+	phy_data = kzalloc(sizeof(*phy_data), GFP_KERNEL);
+	if (phy_data == NULL)
+		return -ENOMEM;
+
+	rc = efx_mcdi_get_phy_cfg(efx, phy_data);
+	if (rc != 0)
+		goto fail;
+
+	/* Read initial link advertisement */
+	BUILD_BUG_ON(MC_CMD_GET_LINK_IN_LEN != 0);
+	rc = efx_mcdi_rpc(efx, MC_CMD_GET_LINK, NULL, 0,
+			  outbuf, sizeof(outbuf), NULL);
+	if (rc)
+		goto fail;
+
+	/* Fill out nic state */
+	efx->phy_data = phy_data;
+	efx->phy_type = phy_data->type;
+	strlcpy(efx->phy_name, phy_data->name, sizeof(efx->phy_name));
+
+	efx->mdio_bus = phy_data->channel;
+	efx->mdio.prtad = phy_data->port;
+	efx->mdio.mmds = phy_data->mmd_mask & ~(1 << MC_CMD_MMD_CLAUSE22);
+	efx->mdio.mode_support = 0;
+	if (phy_data->mmd_mask & (1 << MC_CMD_MMD_CLAUSE22))
+		efx->mdio.mode_support |= MDIO_SUPPORTS_C22;
+	if (phy_data->mmd_mask & ~(1 << MC_CMD_MMD_CLAUSE22))
+		efx->mdio.mode_support |= MDIO_SUPPORTS_C45 | MDIO_EMULATE_C22;
+
+	caps = MCDI_DWORD(outbuf, GET_LINK_OUT_CAP);
+	efx->link_advertising = mcdi_to_ethtool_cap(phy_data->media, caps);
+
+	/* Assert that we can map efx -> mcdi loopback modes */
+	BUILD_BUG_ON(LOOPBACK_NONE != MC_CMD_LOOPBACK_NONE);
+	BUILD_BUG_ON(LOOPBACK_DATA != MC_CMD_LOOPBACK_DATA);
+	BUILD_BUG_ON(LOOPBACK_GMAC != MC_CMD_LOOPBACK_GMAC);
+	BUILD_BUG_ON(LOOPBACK_XGMII != MC_CMD_LOOPBACK_XGMII);
+	BUILD_BUG_ON(LOOPBACK_XGXS != MC_CMD_LOOPBACK_XGXS);
+	BUILD_BUG_ON(LOOPBACK_XAUI != MC_CMD_LOOPBACK_XAUI);
+	BUILD_BUG_ON(LOOPBACK_GMII != MC_CMD_LOOPBACK_GMII);
+	BUILD_BUG_ON(LOOPBACK_SGMII != MC_CMD_LOOPBACK_SGMII);
+	BUILD_BUG_ON(LOOPBACK_XGBR != MC_CMD_LOOPBACK_XGBR);
+	BUILD_BUG_ON(LOOPBACK_XFI != MC_CMD_LOOPBACK_XFI);
+	BUILD_BUG_ON(LOOPBACK_XAUI_FAR != MC_CMD_LOOPBACK_XAUI_FAR);
+	BUILD_BUG_ON(LOOPBACK_GMII_FAR != MC_CMD_LOOPBACK_GMII_FAR);
+	BUILD_BUG_ON(LOOPBACK_SGMII_FAR != MC_CMD_LOOPBACK_SGMII_FAR);
+	BUILD_BUG_ON(LOOPBACK_XFI_FAR != MC_CMD_LOOPBACK_XFI_FAR);
+	BUILD_BUG_ON(LOOPBACK_GPHY != MC_CMD_LOOPBACK_GPHY);
+	BUILD_BUG_ON(LOOPBACK_PHYXS != MC_CMD_LOOPBACK_PHYXS);
+	BUILD_BUG_ON(LOOPBACK_PCS != MC_CMD_LOOPBACK_PCS);
+	BUILD_BUG_ON(LOOPBACK_PMAPMD != MC_CMD_LOOPBACK_PMAPMD);
+	BUILD_BUG_ON(LOOPBACK_XPORT != MC_CMD_LOOPBACK_XPORT);
+	BUILD_BUG_ON(LOOPBACK_XGMII_WS != MC_CMD_LOOPBACK_XGMII_WS);
+	BUILD_BUG_ON(LOOPBACK_XAUI_WS != MC_CMD_LOOPBACK_XAUI_WS);
+	BUILD_BUG_ON(LOOPBACK_XAUI_WS_FAR != MC_CMD_LOOPBACK_XAUI_WS_FAR);
+	BUILD_BUG_ON(LOOPBACK_XAUI_WS_NEAR != MC_CMD_LOOPBACK_XAUI_WS_NEAR);
+	BUILD_BUG_ON(LOOPBACK_GMII_WS != MC_CMD_LOOPBACK_GMII_WS);
+	BUILD_BUG_ON(LOOPBACK_XFI_WS != MC_CMD_LOOPBACK_XFI_WS);
+	BUILD_BUG_ON(LOOPBACK_XFI_WS_FAR != MC_CMD_LOOPBACK_XFI_WS_FAR);
+	BUILD_BUG_ON(LOOPBACK_PHYXS_WS != MC_CMD_LOOPBACK_PHYXS_WS);
+
+	rc = efx_mcdi_loopback_modes(efx, &efx->loopback_modes);
+	if (rc != 0)
+		goto fail;
+	/* The MC indicates that LOOPBACK_NONE is a valid loopback mode,
+	 * but by convention we don't */
+	efx->loopback_modes &= ~(1 << LOOPBACK_NONE);
+	efx->startup_loopback_mode = __ffs(efx->loopback_modes);
+
+	/* Set the initial link mode */
+	efx_mcdi_phy_decode_link(
+		efx, &efx->link_state,
+		MCDI_DWORD(outbuf, GET_LINK_OUT_LINK_SPEED),
+		MCDI_DWORD(outbuf, GET_LINK_OUT_FLAGS),
+		MCDI_DWORD(outbuf, GET_LINK_OUT_FCNTL));
+
+	/* Default to Autonegotiated flow control if the PHY supports it */
+	efx->wanted_fc = EFX_FC_RX | EFX_FC_TX;
+	if (phy_data->supported_cap & (1 << MC_CMD_PHY_CAP_AN_LBN))
+		efx->wanted_fc |= EFX_FC_AUTO;
+	efx_link_set_wanted_fc(efx, efx->wanted_fc);
+
+#ifdef CONFIG_SFC_DEBUGFS
+	rc = efx_mcdi_phy_stats_init(efx);
+	if (rc != 0)
+		goto fail;
+#endif
+
+	return 0;
+
+fail:
+	kfree(phy_data);
+	return rc;
+}
+
+int efx_mcdi_phy_reconfigure(struct efx_nic *efx)
+{
+	u32 caps = ethtool_to_mcdi_cap(efx->link_advertising);
+
+	return efx_mcdi_set_link(efx, caps, efx_get_mcdi_phy_flags(efx),
+				 efx->loopback_mode, 0);
+}
+
+void efx_mcdi_phy_decode_link(struct efx_nic *efx,
+			      struct efx_link_state *link_state,
+			      u32 speed, u32 flags, u32 fcntl)
+{
+	switch (fcntl) {
+	case MC_CMD_FCNTL_AUTO:
+		WARN_ON(1);	/* This is not a link mode */
+		link_state->fc = EFX_FC_AUTO | EFX_FC_TX | EFX_FC_RX;
+		break;
+	case MC_CMD_FCNTL_BIDIR:
+		link_state->fc = EFX_FC_TX | EFX_FC_RX;
+		break;
+	case MC_CMD_FCNTL_RESPOND:
+		link_state->fc = EFX_FC_RX;
+		break;
+	default:
+		WARN_ON(1);
+	case MC_CMD_FCNTL_OFF:
+		link_state->fc = 0;
+		break;
+	}
+
+	link_state->up = !!(flags & (1 << MC_CMD_GET_LINK_OUT_LINK_UP_LBN));
+	link_state->fd = !!(flags & (1 << MC_CMD_GET_LINK_OUT_FULL_DUPLEX_LBN));
+	link_state->speed = speed;
+}
+
+/* Verify that the forced flow control settings (!EFX_FC_AUTO) are
+ * supported by the link partner. Warn the user if this isn't the case
+ */
+void efx_mcdi_phy_check_fcntl(struct efx_nic *efx, u32 lpa)
+{
+	struct efx_mcdi_phy_data *phy_cfg = efx->phy_data;
+	u32 rmtadv;
+
+	/* The link partner capabilities are only relevent if the
+	 * link supports flow control autonegotiation */
+	if (~phy_cfg->supported_cap & (1 << MC_CMD_PHY_CAP_AN_LBN))
+		return;
+
+	/* If flow control autoneg is supported and enabled, then fine */
+	if (efx->wanted_fc & EFX_FC_AUTO)
+		return;
+
+	rmtadv = 0;
+	if (lpa & (1 << MC_CMD_PHY_CAP_PAUSE_LBN))
+		rmtadv |= ADVERTISED_Pause;
+	if (lpa & (1 << MC_CMD_PHY_CAP_ASYM_LBN))
+		rmtadv |=  ADVERTISED_Asym_Pause;
+
+	if ((efx->wanted_fc & EFX_FC_TX) && rmtadv == ADVERTISED_Asym_Pause)
+		netif_err(efx, link, efx->net_dev,
+			  "warning: link partner doesn't support pause frames");
+}
+
+static bool efx_mcdi_phy_poll(struct efx_nic *efx)
+{
+	struct efx_link_state old_state = efx->link_state;
+	u8 outbuf[MC_CMD_GET_LINK_OUT_LEN];
+	int rc;
+
+	WARN_ON(!mutex_is_locked(&efx->mac_lock));
+
+	BUILD_BUG_ON(MC_CMD_GET_LINK_IN_LEN != 0);
+
+	rc = efx_mcdi_rpc(efx, MC_CMD_GET_LINK, NULL, 0,
+			  outbuf, sizeof(outbuf), NULL);
+	if (rc) {
+		netif_err(efx, hw, efx->net_dev, "%s: failed rc=%d\n",
+			  __func__, rc);
+		efx->link_state.up = false;
+	} else {
+		efx_mcdi_phy_decode_link(
+			efx, &efx->link_state,
+			MCDI_DWORD(outbuf, GET_LINK_OUT_LINK_SPEED),
+			MCDI_DWORD(outbuf, GET_LINK_OUT_FLAGS),
+			MCDI_DWORD(outbuf, GET_LINK_OUT_FCNTL));
+	}
+
+	return !efx_link_state_equal(&efx->link_state, &old_state);
+}
+
+static void efx_mcdi_phy_remove(struct efx_nic *efx)
+{
+	struct efx_mcdi_phy_data *phy_data = efx->phy_data;
+
+#ifdef CONFIG_SFC_DEBUGFS
+	efx_mcdi_phy_stats_fini(efx);
+#endif
+	efx->phy_data = NULL;
+	kfree(phy_data);
+}
+
+static void efx_mcdi_phy_get_settings(struct efx_nic *efx, struct ethtool_cmd *ecmd)
+{
+	struct efx_mcdi_phy_data *phy_cfg = efx->phy_data;
+#if !defined(EFX_USE_KCOMPAT) || defined(EFX_USE_ETHTOOL_LP_ADVERTISING)
+	u8 outbuf[MC_CMD_GET_LINK_OUT_LEN];
+	int rc;
+#endif
+
+	ecmd->supported =
+		mcdi_to_ethtool_cap(phy_cfg->media, phy_cfg->supported_cap);
+	ecmd->advertising = efx->link_advertising;
+	ecmd->speed = efx->link_state.speed;
+	ecmd->duplex = efx->link_state.fd;
+	ecmd->port = mcdi_to_ethtool_media(phy_cfg->media);
+	ecmd->phy_address = phy_cfg->port;
+	ecmd->transceiver = XCVR_INTERNAL;
+	ecmd->autoneg = !!(efx->link_advertising & ADVERTISED_Autoneg);
+#if !defined(EFX_USE_KCOMPAT) || defined(EFX_USE_ETHTOOL_MDIO_SUPPORT)
+	ecmd->mdio_support = (efx->mdio.mode_support &
+			      (MDIO_SUPPORTS_C45 | MDIO_SUPPORTS_C22));
+#endif
+
+#if !defined(EFX_USE_KCOMPAT) || defined(EFX_USE_ETHTOOL_LP_ADVERTISING)
+	BUILD_BUG_ON(MC_CMD_GET_LINK_IN_LEN != 0);
+	rc = efx_mcdi_rpc(efx, MC_CMD_GET_LINK, NULL, 0,
+			  outbuf, sizeof(outbuf), NULL);
+	if (rc) {
+		netif_err(efx, hw, efx->net_dev, "%s: failed rc=%d\n",
+			  __func__, rc);
+		return;
+	}
+	ecmd->lp_advertising =
+		mcdi_to_ethtool_cap(phy_cfg->media,
+				    MCDI_DWORD(outbuf, GET_LINK_OUT_LP_CAP));
+#endif
+}
+
+static int efx_mcdi_phy_set_settings(struct efx_nic *efx, struct ethtool_cmd *ecmd)
+{
+	struct efx_mcdi_phy_data *phy_cfg = efx->phy_data;
+	u32 caps;
+	int rc;
+
+	if (ecmd->autoneg) {
+		caps = (ethtool_to_mcdi_cap(ecmd->advertising) |
+			 1 << MC_CMD_PHY_CAP_AN_LBN);
+	} else if (ecmd->advertising &&
+		   !(phy_cfg->supported_cap & (1 << MC_CMD_PHY_CAP_AN_LBN))) {
+		caps = ethtool_to_mcdi_cap(ecmd->advertising);
+
+		/* Remove flow control settings that the MAC supports
+		 * but that the PHY can't advertise. */
+		caps &= ~(~phy_cfg->supported_cap &
+			  ((1 << MC_CMD_PHY_CAP_PAUSE_LBN) |
+			   (1 << MC_CMD_PHY_CAP_ASYM_LBN)));
+
+	} else if (ecmd->duplex) {
+		switch (ecmd->speed) {
+		case 10:    caps = 1 << MC_CMD_PHY_CAP_10FDX_LBN;    break;
+		case 100:   caps = 1 << MC_CMD_PHY_CAP_100FDX_LBN;   break;
+		case 1000:  caps = 1 << MC_CMD_PHY_CAP_1000FDX_LBN;  break;
+		case 10000: caps = 1 << MC_CMD_PHY_CAP_10000FDX_LBN; break;
+		default:    return -EINVAL;
+		}
+	} else {
+		switch (ecmd->speed) {
+		case 10:    caps = 1 << MC_CMD_PHY_CAP_10HDX_LBN;    break;
+		case 100:   caps = 1 << MC_CMD_PHY_CAP_100HDX_LBN;   break;
+		case 1000:  caps = 1 << MC_CMD_PHY_CAP_1000HDX_LBN;  break;
+		default:    return -EINVAL;
+		}
+	}
+
+	rc = efx_mcdi_set_link(efx, caps, efx_get_mcdi_phy_flags(efx),
+			       efx->loopback_mode, 0);
+	if (rc) {
+		if (rc == -EINVAL)
+			netif_err(efx, link, efx->net_dev,
+				  "invalid link settings: autoneg=%u"
+				  " advertising=%#x speed=%u duplex=%u"
+				  " translated to caps=%#x\n",
+				  ecmd->autoneg, ecmd->advertising,
+				  ecmd->speed, ecmd->duplex, caps);
+		return rc;
+	}
+
+	efx_link_set_advertising(efx, ecmd->advertising |
+		(ecmd->autoneg ? ADVERTISED_Autoneg : 0));
+
+	return 0;
+}
+
+static int efx_mcdi_phy_test_alive(struct efx_nic *efx)
+{
+	u8 outbuf[MC_CMD_GET_PHY_STATE_OUT_LEN];
+	size_t outlen;
+	int rc;
+
+	BUILD_BUG_ON(MC_CMD_GET_PHY_STATE_IN_LEN != 0);
+
+	rc = efx_mcdi_rpc(efx, MC_CMD_GET_PHY_STATE, NULL, 0,
+			  outbuf, sizeof(outbuf), &outlen);
+	if (rc)
+		return rc;
+
+	if (outlen < MC_CMD_GET_PHY_STATE_OUT_LEN)
+		return -EIO;
+	if (MCDI_DWORD(outbuf, GET_PHY_STATE_OUT_STATE) != 
+	    MC_CMD_PHY_STATE_OK)
+		return -EINVAL;
+
+	return 0;
+}
+
+static const char *const mcdi_sft9001_cable_diag_names[] = {
+	"cable.pairA.length",
+	"cable.pairB.length",
+	"cable.pairC.length",
+	"cable.pairD.length",
+	"cable.pairA.status",
+	"cable.pairB.status",
+	"cable.pairC.status",
+	"cable.pairD.status",
+};
+
+static int efx_mcdi_bist(struct efx_nic *efx, unsigned int bist_mode,
+			 int *results)
+{
+	unsigned int retry, i, count = 0;
+	size_t outlen;
+	u32 status;
+	u8 *buf, *ptr;
+	int rc;
+
+	buf = kzalloc(0x100, GFP_KERNEL);
+	if (buf == NULL)
+		return -ENOMEM;
+
+	BUILD_BUG_ON(MC_CMD_START_BIST_OUT_LEN != 0);
+	MCDI_SET_DWORD(buf, START_BIST_IN_TYPE, bist_mode);
+	rc = efx_mcdi_rpc(efx, MC_CMD_START_BIST, buf, MC_CMD_START_BIST_IN_LEN,
+			  NULL, 0, NULL);
+	if (rc)
+		goto out;
+
+	/* Wait up to 10s for BIST to finish */
+	for( retry = 0; retry < 100; ++retry) {
+		BUILD_BUG_ON(MC_CMD_POLL_BIST_IN_LEN != 0);
+		rc = efx_mcdi_rpc(efx, MC_CMD_POLL_BIST, NULL, 0,
+				  buf, 0x100, &outlen);
+		if (rc)
+			goto out;
+
+		status = MCDI_DWORD(buf, POLL_BIST_OUT_RESULT);
+		if (status != MC_CMD_POLL_BIST_RUNNING)
+			goto finished;
+
+		msleep(100);
+	}
+
+	rc = -ETIMEDOUT;
+	goto out;
+
+finished:
+	results[count++] = (status == MC_CMD_POLL_BIST_PASSED) ? 1 : -1;
+
+	/* SFT9001 specific cable diagnostics output */
+	if (efx->phy_type == PHY_TYPE_SFT9001B &&
+	    (bist_mode == MC_CMD_PHY_BIST_CABLE_SHORT ||
+	     bist_mode == MC_CMD_PHY_BIST_CABLE_LONG)) {
+		ptr = MCDI_PTR(buf, POLL_BIST_OUT_SFT9001_CABLE_LENGTH_A);
+		if (status == MC_CMD_POLL_BIST_PASSED &&
+		    outlen >= MC_CMD_POLL_BIST_OUT_SFT9001_LEN) {
+			for (i = 0; i < 8; i++) {
+				results[count + i] =
+					EFX_DWORD_FIELD(((efx_dword_t *)ptr)[i],
+							EFX_DWORD_0);
+			}
+		}
+		count += 8;
+	}
+	rc = count;
+
+out:
+	kfree(buf);
+
+	return rc;
+}
+
+static int efx_mcdi_phy_run_tests(struct efx_nic *efx, int *results,
+				  unsigned flags)
+{
+	struct efx_mcdi_phy_data *phy_cfg = efx->phy_data;
+	u32 mode;
+	int rc;
+
+#ifdef EFX_NOT_UPSTREAM
+	/* We don't know how long anything will take */
+	if (flags & EFX_TEST_FL_ONLOAD)
+		return 0;
+#endif
+
+	if (phy_cfg->flags & (1 << MC_CMD_GET_PHY_CFG_OUT_BIST_LBN)) {
+		rc = efx_mcdi_bist(efx, MC_CMD_PHY_BIST, results);
+		if (rc < 0)
+			return rc;
+
+		results += rc;
+	}
+
+	/* If we support both LONG and SHORT, then run each in response to
+	 * break or not. Otherwise, run the one we support */
+	mode = 0;
+	if (phy_cfg->flags & (1 << MC_CMD_GET_PHY_CFG_OUT_BIST_CABLE_SHORT_LBN)) {
+		if ((flags & ETH_TEST_FL_OFFLINE) &&
+		    (phy_cfg->flags &
+		     (1 << MC_CMD_GET_PHY_CFG_OUT_BIST_CABLE_LONG_LBN)))
+			mode = MC_CMD_PHY_BIST_CABLE_LONG;
+		else
+			mode = MC_CMD_PHY_BIST_CABLE_SHORT;
+	} else if (phy_cfg->flags &
+		   (1 << MC_CMD_GET_PHY_CFG_OUT_BIST_CABLE_LONG_LBN))
+		mode = MC_CMD_PHY_BIST_CABLE_LONG;
+
+	if (mode != 0) {
+		rc = efx_mcdi_bist(efx, mode, results);
+		if (rc < 0)
+			return rc;
+		results += rc;
+	}	
+
+	return 0;
+}
+
+static const char *efx_mcdi_phy_test_name(struct efx_nic *efx,
+					  unsigned int index)
+{
+	struct efx_mcdi_phy_data *phy_cfg = efx->phy_data;
+
+	if (phy_cfg->flags & (1 << MC_CMD_GET_PHY_CFG_OUT_BIST_LBN)) {
+		if (index == 0)
+			return "bist";
+		--index;
+	}
+
+	if (phy_cfg->flags & ((1 << MC_CMD_GET_PHY_CFG_OUT_BIST_CABLE_SHORT_LBN) |
+			      (1 << MC_CMD_GET_PHY_CFG_OUT_BIST_CABLE_LONG_LBN))) {
+		if (index == 0)
+			return "cable";
+		--index;
+
+		if (efx->phy_type == PHY_TYPE_SFT9001B) {
+			if (index < ARRAY_SIZE(mcdi_sft9001_cable_diag_names))
+				return mcdi_sft9001_cable_diag_names[index];
+			index -= ARRAY_SIZE(mcdi_sft9001_cable_diag_names);
+		}
+	}
+
+	return NULL;
+}
+
+struct efx_phy_operations efx_mcdi_phy_ops = {
+	.probe		= efx_mcdi_phy_probe,
+	.init 	 	= efx_port_dummy_op_int,
+	.reconfigure	= efx_mcdi_phy_reconfigure,
+	.poll		= efx_mcdi_phy_poll,
+	.fini		= efx_port_dummy_op_void,
+	.remove		= efx_mcdi_phy_remove,
+	.get_settings	= efx_mcdi_phy_get_settings,
+	.set_settings	= efx_mcdi_phy_set_settings,
+	.test_alive	= efx_mcdi_phy_test_alive,
+	.run_tests	= efx_mcdi_phy_run_tests,
+	.test_name	= efx_mcdi_phy_test_name,
+};
diff -r 5b3d4d3c1166 drivers/net/sfc/mdio_10g.c
--- a/drivers/net/sfc/mdio_10g.c	Fri Nov 05 15:20:28 2010 +0000
+++ b/drivers/net/sfc/mdio_10g.c	Tue Nov 09 10:06:27 2010 +0000
@@ -1,6 +1,6 @@
 /****************************************************************************
  * Driver for Solarflare Solarstorm network controllers and boards
- * Copyright 2006-2008 Solarflare Communications Inc.
+ * Copyright 2006-2009 Solarflare Communications Inc.
  *
  * This program is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 as published
@@ -14,8 +14,26 @@
 #include <linux/delay.h>
 #include "net_driver.h"
 #include "mdio_10g.h"
-#include "boards.h"
 #include "workarounds.h"
+#include "nic.h"
+
+static const char *mmd_block_names[] = {
+	[0]               = "(illegal)",
+	[MDIO_MMD_PMAPMD] = "PMA/PMD",
+	[MDIO_MMD_WIS]    = "WIS",
+	[MDIO_MMD_PCS]    = "PCS",
+	[MDIO_MMD_PHYXS]  = "PHY XS",
+	[MDIO_MMD_DTEXS]  = "DTE XS",
+	[MDIO_MMD_TC]     = "TC",
+	[MDIO_MMD_AN]     = "AN",
+	[MDIO_MMD_C22EXT] = "c22 ext",
+};
+static const int mmd_block_max = ARRAY_SIZE(mmd_block_names);
+
+const char *efx_mdio_mmd_name(int mmd)
+{
+	return STRING_TABLE_LOOKUP(mmd, mmd_block);
+}
 
 unsigned efx_mdio_id_oui(u32 id)
 {
@@ -33,7 +51,7 @@ unsigned efx_mdio_id_oui(u32 id)
 }
 
 int efx_mdio_reset_mmd(struct efx_nic *port, int mmd,
-			    int spins, int spintime)
+		       int spins, int spintime)
 {
 	u32 ctrl;
 
@@ -55,6 +73,7 @@ static int efx_mdio_check_mmd(struct efx
 static int efx_mdio_check_mmd(struct efx_nic *efx, int mmd, int fault_fatal)
 {
 	int status;
+	const char *mmdname = STRING_TABLE_LOOKUP(mmd, mmd_block);
 
 	if (LOOPBACK_INTERNAL(efx))
 		return 0;
@@ -63,7 +82,8 @@ static int efx_mdio_check_mmd(struct efx
 		/* Read MMD STATUS2 to check it is responding. */
 		status = efx_mdio_read(efx, mmd, MDIO_STAT2);
 		if ((status & MDIO_STAT2_DEVPRST) != MDIO_STAT2_DEVPRST_VAL) {
-			EFX_ERR(efx, "PHY MMD %d not responding.\n", mmd);
+			netif_err(efx, hw, efx->net_dev,
+				  "PHY MMD %s not responding.\n", mmdname);
 			return -EIO;
 		}
 	}
@@ -72,12 +92,14 @@ static int efx_mdio_check_mmd(struct efx
 	status = efx_mdio_read(efx, mmd, MDIO_STAT1);
 	if (status & MDIO_STAT1_FAULT) {
 		if (fault_fatal) {
-			EFX_ERR(efx, "PHY MMD %d reporting fatal"
-				" fault: status %x\n", mmd, status);
+			netif_err(efx, hw, efx->net_dev,
+				  "PHY MMD %s reporting fatal"
+				  " fault: status %x\n", mmdname, status);
 			return -EIO;
 		} else {
-			EFX_LOG(efx, "PHY MMD %d reporting status"
-				" %x (expected)\n", mmd, status);
+			netif_dbg(efx, hw, efx->net_dev,
+				  "PHY MMD %s reporting status"
+				  " %x (expected)\n", mmdname, status);
 		}
 	}
 	return 0;
@@ -103,8 +125,11 @@ int efx_mdio_wait_reset_mmds(struct efx_
 			if (mask & 1) {
 				stat = efx_mdio_read(efx, mmd, MDIO_CTRL1);
 				if (stat < 0) {
-					EFX_ERR(efx, "failed to read status of"
-						" MMD %d\n", mmd);
+					netif_err(efx, hw, efx->net_dev,
+						  "failed to read status of"
+						  " MMD %s\n",
+						  STRING_TABLE_LOOKUP(
+							  mmd, mmd_block));
 					return -EIO;
 				}
 				if (stat & MDIO_CTRL1_RESET)
@@ -119,10 +144,15 @@ int efx_mdio_wait_reset_mmds(struct efx_
 		msleep(spintime);
 	}
 	if (in_reset != 0) {
-		EFX_ERR(efx, "not all MMDs came out of reset in time."
-			" MMDs still in reset: %x\n", in_reset);
+		netif_err(efx, hw, efx->net_dev,
+			  "not all MMDs came out of reset in time."
+			  " MMDs still in reset: %x\n", in_reset);
 		rc = -ETIMEDOUT;
 	}
+	else
+		netif_info(efx, hw, efx->net_dev,
+			   "mmds %x came out of reset in %d ms\n",
+			   mmd_mask, spintime * (MDIO45_RESET_ITERS - tries));
 	return rc;
 }
 
@@ -142,16 +172,18 @@ int efx_mdio_check_mmds(struct efx_nic *
 	devs1 = efx_mdio_read(efx, probe_mmd, MDIO_DEVS1);
 	devs2 = efx_mdio_read(efx, probe_mmd, MDIO_DEVS2);
 	if (devs1 < 0 || devs2 < 0) {
-		EFX_ERR(efx, "failed to read devices present\n");
+		netif_err(efx, hw, efx->net_dev,
+			  "failed to read devices present\n");
 		return -EIO;
 	}
 	devices = devs1 | (devs2 << 16);
 	if ((devices & mmd_mask) != mmd_mask) {
-		EFX_ERR(efx, "required MMDs not present: got %x, "
-			"wanted %x\n", devices, mmd_mask);
+		netif_err(efx, hw, efx->net_dev,
+			  "required MMDs not present: got %x, wanted %x\n",
+			  devices, mmd_mask);
 		return -ENODEV;
 	}
-	EFX_TRACE(efx, "Devices present: %x\n", devices);
+	netif_vdbg(efx, hw, efx->net_dev, "Devices present: %x\n", devices);
 
 	/* Check all required MMDs are responding and happy. */
 	while (mmd_mask) {
@@ -170,11 +202,13 @@ int efx_mdio_check_mmds(struct efx_nic *
 
 bool efx_mdio_links_ok(struct efx_nic *efx, unsigned int mmd_mask)
 {
+	WARN_ON(LOOPBACK_INTERNAL(efx));
+
 	/* If the port is in loopback, then we should only consider a subset
 	 * of mmd's */
 	if (LOOPBACK_INTERNAL(efx))
 		return true;
-	else if (efx->loopback_mode == LOOPBACK_NETWORK)
+	else if ((1 << efx->loopback_mode) & LOOPBACKS_WS)
 		return false;
 	else if (efx_phy_mode_disabled(efx->phy_mode))
 		return false;
@@ -211,16 +245,19 @@ void efx_mdio_phy_reconfigure(struct efx
 			  efx->loopback_mode == LOOPBACK_PCS);
 	efx_mdio_set_flag(efx, MDIO_MMD_PHYXS,
 			  MDIO_CTRL1, MDIO_PHYXS_CTRL1_LOOPBACK,
-			  efx->loopback_mode == LOOPBACK_NETWORK);
+			  efx->loopback_mode == LOOPBACK_PHYXS_WS);
 }
 
 static void efx_mdio_set_mmd_lpower(struct efx_nic *efx,
 				    int lpower, int mmd)
 {
+	const char *mmdname __attribute__((unused)) =
+		STRING_TABLE_LOOKUP(mmd, mmd_block);
 	int stat = efx_mdio_read(efx, mmd, MDIO_STAT1);
 
-	EFX_TRACE(efx, "Setting low power mode for MMD %d to %d\n",
-		  mmd, lpower);
+	netif_vdbg(efx, hw, efx->net_dev,
+		   "Setting low power mode for MMD %s to %d\n",
+		   mmdname, lpower);
 
 	if (stat & MDIO_STAT1_LPOWERABLE) {
 		efx_mdio_set_flag(efx, mmd, MDIO_CTRL1,
@@ -249,8 +286,6 @@ int efx_mdio_set_settings(struct efx_nic
 int efx_mdio_set_settings(struct efx_nic *efx, struct ethtool_cmd *ecmd)
 {
 	struct ethtool_cmd prev;
-	u32 required;
-	int reg;
 
 	efx->phy_op->get_settings(efx, &prev);
 
@@ -266,86 +301,76 @@ int efx_mdio_set_settings(struct efx_nic
 		return -EINVAL;
 
 	/* Check that PHY supports these settings */
-	if (ecmd->autoneg) {
-		required = SUPPORTED_Autoneg;
-	} else if (ecmd->duplex) {
-		switch (ecmd->speed) {
-		case SPEED_10:  required = SUPPORTED_10baseT_Full;  break;
-		case SPEED_100: required = SUPPORTED_100baseT_Full; break;
-		default:        return -EINVAL;
-		}
-	} else {
-		switch (ecmd->speed) {
-		case SPEED_10:  required = SUPPORTED_10baseT_Half;  break;
-		case SPEED_100: required = SUPPORTED_100baseT_Half; break;
-		default:        return -EINVAL;
-		}
-	}
-	required |= ecmd->advertising;
-	if (required & ~prev.supported)
+	if (!ecmd->autoneg ||
+	    (ecmd->advertising | SUPPORTED_Autoneg) & ~prev.supported)
 		return -EINVAL;
 
-	if (ecmd->autoneg) {
-		bool xnp = (ecmd->advertising & ADVERTISED_10000baseT_Full
-			    || EFX_WORKAROUND_13204(efx));
+	efx_link_set_advertising(efx, ecmd->advertising | ADVERTISED_Autoneg);
+	efx_mdio_an_reconfigure(efx);
+	return 0;
+}
 
-		/* Set up the base page */
-		reg = ADVERTISE_CSMA;
-		if (ecmd->advertising & ADVERTISED_10baseT_Half)
-			reg |= ADVERTISE_10HALF;
-		if (ecmd->advertising & ADVERTISED_10baseT_Full)
-			reg |= ADVERTISE_10FULL;
-		if (ecmd->advertising & ADVERTISED_100baseT_Half)
-			reg |= ADVERTISE_100HALF;
-		if (ecmd->advertising & ADVERTISED_100baseT_Full)
-			reg |= ADVERTISE_100FULL;
-		if (xnp)
-			reg |= ADVERTISE_RESV;
-		else if (ecmd->advertising & (ADVERTISED_1000baseT_Half |
-					      ADVERTISED_1000baseT_Full))
-			reg |= ADVERTISE_NPAGE;
-		reg |= mii_advertise_flowctrl(efx->wanted_fc);
-		efx_mdio_write(efx, MDIO_MMD_AN, MDIO_AN_ADVERTISE, reg);
+/**
+ * efx_mdio_an_reconfigure - Push advertising flags and restart autonegotiation
+ * @efx:		Efx NIC
+ */
+void efx_mdio_an_reconfigure(struct efx_nic *efx)
+{
+	int reg;
 
-		/* Set up the (extended) next page if necessary */
-		if (efx->phy_op->set_npage_adv)
-			efx->phy_op->set_npage_adv(efx, ecmd->advertising);
+	WARN_ON(!(efx->mdio.mmds & MDIO_DEVS_AN));
 
-		/* Enable and restart AN */
-		reg = efx_mdio_read(efx, MDIO_MMD_AN, MDIO_CTRL1);
-		reg |= MDIO_AN_CTRL1_ENABLE;
-		if (!(EFX_WORKAROUND_15195(efx) &&
-		      LOOPBACK_MASK(efx) & efx->phy_op->loopbacks))
-			reg |= MDIO_AN_CTRL1_RESTART;
-		if (xnp)
-			reg |= MDIO_AN_CTRL1_XNP;
-		else
-			reg &= ~MDIO_AN_CTRL1_XNP;
-		efx_mdio_write(efx, MDIO_MMD_AN, MDIO_CTRL1, reg);
-	} else {
-		/* Disable AN */
-		efx_mdio_set_flag(efx, MDIO_MMD_AN, MDIO_CTRL1,
-				  MDIO_AN_CTRL1_ENABLE, false);
+	/* Set up the base page */
+	reg = ADVERTISE_CSMA | ADVERTISE_RESV;
+	if (efx->link_advertising & ADVERTISED_Pause)
+		reg |= ADVERTISE_PAUSE_CAP;
+	if (efx->link_advertising & ADVERTISED_Asym_Pause)
+		reg |= ADVERTISE_PAUSE_ASYM;
+	efx_mdio_write(efx, MDIO_MMD_AN, MDIO_AN_ADVERTISE, reg);
 
-		/* Set the basic control bits */
-		reg = efx_mdio_read(efx, MDIO_MMD_PMAPMD, MDIO_CTRL1);
-		reg &= ~(MDIO_CTRL1_SPEEDSEL | MDIO_CTRL1_FULLDPLX);
-		if (ecmd->speed == SPEED_100)
-			reg |= MDIO_PMA_CTRL1_SPEED100;
-		if (ecmd->duplex)
-			reg |= MDIO_CTRL1_FULLDPLX;
-		efx_mdio_write(efx, MDIO_MMD_PMAPMD, MDIO_CTRL1, reg);
-	}
+	/* Set up the (extended) next page */
+	efx->phy_op->set_npage_adv(efx, efx->link_advertising);
 
-	return 0;
+	/* Enable and restart AN */
+	reg = efx_mdio_read(efx, MDIO_MMD_AN, MDIO_CTRL1);
+	reg |= MDIO_AN_CTRL1_ENABLE | MDIO_AN_CTRL1_RESTART | MDIO_AN_CTRL1_XNP;
+	efx_mdio_write(efx, MDIO_MMD_AN, MDIO_CTRL1, reg);
 }
 
 enum efx_fc_type efx_mdio_get_pause(struct efx_nic *efx)
 {
-	int lpa;
+	BUILD_BUG_ON(EFX_FC_AUTO & (EFX_FC_RX | EFX_FC_TX));
 
-	if (!(efx->phy_op->mmds & MDIO_DEVS_AN))
+	if (!(efx->wanted_fc & EFX_FC_AUTO))
 		return efx->wanted_fc;
-	lpa = efx_mdio_read(efx, MDIO_MMD_AN, MDIO_AN_LPA);
-	return efx_fc_resolve(efx->wanted_fc, lpa);
+
+	WARN_ON(!(efx->mdio.mmds & MDIO_DEVS_AN));
+
+	return mii_resolve_flowctrl_fdx(
+		mii_advertise_flowctrl(efx->wanted_fc),
+		efx_mdio_read(efx, MDIO_MMD_AN, MDIO_AN_LPA));
 }
+
+int efx_mdio_test_alive(struct efx_nic *efx)
+{
+	int rc;
+	int devad = __ffs(efx->mdio.mmds);
+	u16 physid1, physid2;
+
+	mutex_lock(&efx->mac_lock);
+
+	physid1 = efx_mdio_read(efx, devad, MDIO_DEVID1);
+	physid2 = efx_mdio_read(efx, devad, MDIO_DEVID2);
+
+	if ((physid1 == 0x0000) || (physid1 == 0xffff) ||
+	    (physid2 == 0x0000) || (physid2 == 0xffff)) {
+		netif_err(efx, hw, efx->net_dev,
+			  "no MDIO PHY present with ID %d\n", efx->mdio.prtad);
+		rc = -EINVAL;
+	} else {
+		rc = efx_mdio_check_mmds(efx, efx->mdio.mmds, 0);
+	}
+
+	mutex_unlock(&efx->mac_lock);
+	return rc;
+}
diff -r 5b3d4d3c1166 drivers/net/sfc/mdio_10g.h
--- a/drivers/net/sfc/mdio_10g.h	Fri Nov 05 15:20:28 2010 +0000
+++ b/drivers/net/sfc/mdio_10g.h	Tue Nov 09 10:06:27 2010 +0000
@@ -1,6 +1,6 @@
 /****************************************************************************
  * Driver for Solarflare Solarstorm network controllers and boards
- * Copyright 2006-2008 Solarflare Communications Inc.
+ * Copyright 2006-2009 Solarflare Communications Inc.
  *
  * This program is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 as published
@@ -10,14 +10,17 @@
 #ifndef EFX_MDIO_10G_H
 #define EFX_MDIO_10G_H
 
+#if !defined(EFX_USE_KCOMPAT)
 #include <linux/mdio.h>
+#else
+#include "kernel_compat.h"
+#endif
 
 /*
  * Helper functions for doing 10G MDIO as specified in IEEE 802.3 clause 45.
  */
 
 #include "efx.h"
-#include "boards.h"
 
 static inline unsigned efx_mdio_id_rev(u32 id) { return id & 0xf; }
 static inline unsigned efx_mdio_id_model(u32 id) { return (id >> 4) & 0x3f; }
@@ -52,7 +55,8 @@ static inline bool efx_mdio_phyxgxs_lane
 
 	sync = !!(lane_status & MDIO_PHYXS_LNSTAT_ALIGN);
 	if (!sync)
-		EFX_LOG(efx, "XGXS lane status: %x\n", lane_status);
+		netif_dbg(efx, hw, efx->net_dev, "XGXS lane status: %x\n",
+			  lane_status);
 	return sync;
 }
 
@@ -87,6 +91,9 @@ extern void efx_mdio_set_mmds_lpower(str
 /* Set (some of) the PHY settings over MDIO */
 extern int efx_mdio_set_settings(struct efx_nic *efx, struct ethtool_cmd *ecmd);
 
+/* Push advertising flags and restart autonegotiation */
+extern void efx_mdio_an_reconfigure(struct efx_nic *efx);
+
 /* Get pause parameters from AN if available (otherwise return
  * requested pause parameters)
  */
@@ -104,4 +111,7 @@ efx_mdio_set_flag(struct efx_nic *efx, i
 	mdio_set_flag(&efx->mdio, efx->mdio.prtad, devad, addr, mask, state);
 }
 
+/* Liveness self-test for MDIO PHYs */
+extern int efx_mdio_test_alive(struct efx_nic *efx);
+
 #endif /* EFX_MDIO_10G_H */
diff -r 5b3d4d3c1166 drivers/net/sfc/mtd.c
--- a/drivers/net/sfc/mtd.c	Fri Nov 05 15:20:28 2010 +0000
+++ b/drivers/net/sfc/mtd.c	Tue Nov 09 10:06:27 2010 +0000
@@ -1,36 +1,94 @@
 /****************************************************************************
  * Driver for Solarflare Solarstorm network controllers and boards
  * Copyright 2005-2006 Fen Systems Ltd.
- * Copyright 2006-2008 Solarflare Communications Inc.
+ * Copyright 2006-2009 Solarflare Communications Inc.
  *
  * This program is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 as published
  * by the Free Software Foundation, incorporated herein by reference.
  */
 
+#include <linux/bitops.h>
 #include <linux/module.h>
 #include <linux/mtd/mtd.h>
 #include <linux/delay.h>
+#include <linux/slab.h>
+#ifndef EFX_USE_KCOMPAT
+#include <linux/rtnetlink.h>
+#endif
 
-#define EFX_DRIVER_NAME "sfc_mtd"
 #include "net_driver.h"
 #include "spi.h"
 #include "efx.h"
+#include "nic.h"
+#include "mcdi.h"
+#include "mcdi_pcol.h"
 
 #define EFX_SPI_VERIFY_BUF_LEN 16
 
-struct efx_mtd {
-	const struct efx_spi_device *spi;
+/* Some partitions should only be written during manufacturing.  Not
+ * only should they not be rewritten later, but exposing all of them
+ * can easily fill up the MTD table (16 or 32 entries).
+ */
+static unsigned int efx_allow_nvconfig_writes;
+#ifdef EFX_NOT_UPSTREAM
+module_param(efx_allow_nvconfig_writes, uint, 0644);
+MODULE_PARM_DESC(efx_allow_nvconfig_writes,
+		 "Allow access to static config and backup firmware");
+#endif /* EFX_NOT_UPSTREAM */
+
+struct efx_mtd_partition {
 	struct mtd_info mtd;
+	union {
+		struct {
+			bool updating;
+			u8 nvram_type;
+			u16 fw_subtype;
+		} mcdi;
+		size_t offset;
+	};
+	const char *type_name;
 	char name[IFNAMSIZ + 20];
 };
 
+struct efx_mtd_ops {
+	int (*read)(struct mtd_info *mtd, loff_t start, size_t len,
+		    size_t *retlen, u8 *buffer);
+	int (*erase)(struct mtd_info *mtd, loff_t start, size_t len);
+	int (*write)(struct mtd_info *mtd, loff_t start, size_t len,
+		     size_t *retlen, const u8 *buffer);
+	int (*sync)(struct mtd_info *mtd);
+};
+
+struct efx_mtd {
+	struct list_head node;
+	struct efx_nic *efx;
+	const struct efx_spi_device *spi;
+	const char *name;
+	const struct efx_mtd_ops *ops;
+	size_t n_parts;
+	struct efx_mtd_partition part[0];
+};
+
+#define efx_for_each_partition(part, efx_mtd)			\
+	for ((part) = &(efx_mtd)->part[0];			\
+	     (part) != &(efx_mtd)->part[(efx_mtd)->n_parts];	\
+	     (part)++)
+
+#define to_efx_mtd_partition(mtd)				\
+	container_of(mtd, struct efx_mtd_partition, mtd)
+
+static int falcon_mtd_probe(struct efx_nic *efx);
+static int siena_mtd_probe(struct efx_nic *efx);
+
 /* SPI utilities */
 
-static int efx_spi_slow_wait(struct efx_mtd *efx_mtd, bool uninterruptible)
+static int
+efx_spi_slow_wait(struct efx_mtd_partition *part, bool uninterruptible)
 {
+	struct efx_mtd *efx_mtd = part->mtd.priv;	
 	const struct efx_spi_device *spi = efx_mtd->spi;
-	struct efx_nic *efx = spi->efx;
+	struct efx_nic *efx = efx_mtd->efx;
 	u8 status;
 	int rc, i;
 
@@ -39,7 +97,7 @@ static int efx_spi_slow_wait(struct efx_
 		__set_current_state(uninterruptible ?
 				    TASK_UNINTERRUPTIBLE : TASK_INTERRUPTIBLE);
 		schedule_timeout(HZ / 10);
-		rc = falcon_spi_cmd(spi, SPI_RDSR, -1, NULL,
+		rc = falcon_spi_cmd(efx, spi, SPI_RDSR, -1, NULL,
 				    &status, sizeof(status));
 		if (rc)
 			return rc;
@@ -48,45 +106,51 @@ static int efx_spi_slow_wait(struct efx_
 		if (signal_pending(current))
 			return -EINTR;
 	}
-	EFX_ERR(efx, "timed out waiting for %s\n", efx_mtd->name);
+	pr_err("%s: timed out waiting for %s\n", part->name, efx_mtd->name);
 	return -ETIMEDOUT;
 }
 
-static int efx_spi_unlock(const struct efx_spi_device *spi)
+static int
+efx_spi_unlock(struct efx_nic *efx, const struct efx_spi_device *spi)
 {
 	const u8 unlock_mask = (SPI_STATUS_BP2 | SPI_STATUS_BP1 |
 				SPI_STATUS_BP0);
 	u8 status;
 	int rc;
 
-	rc = falcon_spi_cmd(spi, SPI_RDSR, -1, NULL, &status, sizeof(status));
+	rc = falcon_spi_cmd(efx, spi, SPI_RDSR, -1, NULL,
+			    &status, sizeof(status));
 	if (rc)
 		return rc;
 
 	if (!(status & unlock_mask))
 		return 0; /* already unlocked */
 
-	rc = falcon_spi_cmd(spi, SPI_WREN, -1, NULL, NULL, 0);
+	rc = falcon_spi_cmd(efx, spi, SPI_WREN, -1, NULL, NULL, 0);
 	if (rc)
 		return rc;
-	rc = falcon_spi_cmd(spi, SPI_SST_EWSR, -1, NULL, NULL, 0);
+	rc = falcon_spi_cmd(efx, spi, SPI_SST_EWSR, -1, NULL, NULL, 0);
 	if (rc)
 		return rc;
 
 	status &= ~unlock_mask;
-	rc = falcon_spi_cmd(spi, SPI_WRSR, -1, &status, NULL, sizeof(status));
+	rc = falcon_spi_cmd(efx, spi, SPI_WRSR, -1, &status,
+			    NULL, sizeof(status));
 	if (rc)
 		return rc;
-	rc = falcon_spi_wait_write(spi);
+	rc = falcon_spi_wait_write(efx, spi);
 	if (rc)
 		return rc;
 
 	return 0;
 }
 
-static int efx_spi_erase(struct efx_mtd *efx_mtd, loff_t start, size_t len)
+static int
+efx_spi_erase(struct efx_mtd_partition *part, loff_t start, size_t len)
 {
+	struct efx_mtd *efx_mtd = part->mtd.priv;	
 	const struct efx_spi_device *spi = efx_mtd->spi;
+	struct efx_nic *efx = efx_mtd->efx;
 	unsigned pos, block_len;
 	u8 empty[EFX_SPI_VERIFY_BUF_LEN];
 	u8 buffer[EFX_SPI_VERIFY_BUF_LEN];
@@ -98,22 +162,24 @@ static int efx_spi_erase(struct efx_mtd 
 	if (spi->erase_command == 0)
 		return -EOPNOTSUPP;
 
-	rc = efx_spi_unlock(spi);
+	rc = efx_spi_unlock(efx, spi);
 	if (rc)
 		return rc;
-	rc = falcon_spi_cmd(spi, SPI_WREN, -1, NULL, NULL, 0);
+	rc = falcon_spi_cmd(efx, spi, SPI_WREN, -1, NULL, NULL, 0);
 	if (rc)
 		return rc;
-	rc = falcon_spi_cmd(spi, spi->erase_command, start, NULL, NULL, 0);
+	rc = falcon_spi_cmd(efx, spi, spi->erase_command, start, NULL,
+			    NULL, 0);
 	if (rc)
 		return rc;
-	rc = efx_spi_slow_wait(efx_mtd, false);
+	rc = efx_spi_slow_wait(part, false);
 
 	/* Verify the entire region has been wiped */
 	memset(empty, 0xff, sizeof(empty));
 	for (pos = 0; pos < len; pos += block_len) {
 		block_len = min(len - pos, sizeof(buffer));
-		rc = falcon_spi_read(spi, start + pos, block_len, NULL, buffer);
+		rc = falcon_spi_read(efx, spi, start + pos, block_len,
+				     NULL, buffer);
 		if (rc)
 			return rc;
 		if (memcmp(empty, buffer, block_len))
@@ -130,140 +196,563 @@ static int efx_spi_erase(struct efx_mtd 
 
 /* MTD interface */
 
-static int efx_mtd_read(struct mtd_info *mtd, loff_t start, size_t len,
-			size_t *retlen, u8 *buffer)
+static int efx_mtd_erase(struct mtd_info *mtd, struct erase_info *erase)
 {
 	struct efx_mtd *efx_mtd = mtd->priv;
+	int rc;
+
+	rc = efx_mtd->ops->erase(mtd, erase->addr, erase->len);
+	if (rc == 0) {
+		erase->state = MTD_ERASE_DONE;
+	} else {
+		erase->state = MTD_ERASE_FAILED;
+#if !defined(EFX_USE_KCOMPAT) || defined(EFX_USE_MTD_ERASE_FAIL_ADDR)
+		erase->fail_addr = 0xffffffff;
+#endif
+	}
+	mtd_erase_callback(erase);
+	return rc;
+}
+
+static void efx_mtd_sync(struct mtd_info *mtd)
+{
+	struct efx_mtd_partition *part = to_efx_mtd_partition(mtd);
+	struct efx_mtd *efx_mtd = mtd->priv;
+	int rc;
+
+	rc = efx_mtd->ops->sync(mtd);
+	if (rc)
+		pr_err("%s: %s sync failed (%d)\n",
+		       part->name, efx_mtd->name, rc);
+}
+
+static void efx_mtd_remove_partition(struct efx_mtd_partition *part)
+{
+	int rc;
+
+	for (;;) {
+		rc = del_mtd_device(&part->mtd);
+		if (rc != -EBUSY)
+			break;
+		ssleep(1);
+	}
+	WARN_ON(rc);
+}
+
+static void efx_mtd_remove_device(struct efx_mtd *efx_mtd)
+{
+	struct efx_mtd_partition *part;
+
+	efx_for_each_partition(part, efx_mtd)
+		efx_mtd_remove_partition(part);
+	list_del(&efx_mtd->node);
+	kfree(efx_mtd);
+}
+
+static void efx_mtd_rename_device(struct efx_mtd *efx_mtd)
+{
+	struct efx_mtd_partition *part;
+
+	efx_for_each_partition(part, efx_mtd)
+		if (efx_nic_rev(efx_mtd->efx) >= EFX_REV_SIENA_A0)
+			snprintf(part->name, sizeof(part->name),
+				 "%s %s:%02x", efx_mtd->efx->name,
+				 part->type_name, part->mcdi.fw_subtype);
+		else
+			snprintf(part->name, sizeof(part->name),
+				 "%s %s", efx_mtd->efx->name,
+				 part->type_name);
+}
+
+static int efx_mtd_probe_device(struct efx_nic *efx, struct efx_mtd *efx_mtd)
+{
+	struct efx_mtd_partition *part;
+
+	efx_mtd->efx = efx;
+
+	efx_mtd_rename_device(efx_mtd);
+
+	efx_for_each_partition(part, efx_mtd) {
+#if !defined(EFX_USE_KCOMPAT) || defined(EFX_USE_MTD_WRITESIZE)
+		part->mtd.writesize = 1;
+#endif
+		if (efx_allow_nvconfig_writes)
+			part->mtd.flags |= MTD_WRITEABLE;
+
+		part->mtd.owner = THIS_MODULE;
+		part->mtd.priv = efx_mtd;
+		part->mtd.name = part->name;
+		part->mtd.erase = efx_mtd_erase;
+		part->mtd.read = efx_mtd->ops->read;
+		part->mtd.write = efx_mtd->ops->write;
+		part->mtd.sync = efx_mtd_sync;
+
+		if (add_mtd_device(&part->mtd))
+			goto fail;
+	}
+
+	list_add(&efx_mtd->node, &efx->mtd_list);
+	return 0;
+
+fail:
+	while (part != &efx_mtd->part[0]) {
+		--part;
+		efx_mtd_remove_partition(part);
+	}
+	/* add_mtd_device() returns 1 if the MTD table is full */
+	return -ENOMEM;
+}
+
+void efx_mtd_remove(struct efx_nic *efx)
+{
+	struct efx_mtd *efx_mtd, *next;
+
+	WARN_ON(efx_dev_registered(efx));
+
+	list_for_each_entry_safe(efx_mtd, next, &efx->mtd_list, node)
+		efx_mtd_remove_device(efx_mtd);
+}
+
+void efx_mtd_rename(struct efx_nic *efx)
+{
+	struct efx_mtd *efx_mtd;
+
+	ASSERT_RTNL();
+
+	list_for_each_entry(efx_mtd, &efx->mtd_list, node)
+		efx_mtd_rename_device(efx_mtd);
+}
+
+int efx_mtd_probe(struct efx_nic *efx)
+{
+	if (efx_nic_rev(efx) >= EFX_REV_SIENA_A0)
+		return siena_mtd_probe(efx);
+	else
+		return falcon_mtd_probe(efx);
+}
+
+/* Implementation of MTD operations for Falcon */
+
+static int falcon_mtd_read(struct mtd_info *mtd, loff_t start,
+			   size_t len, size_t *retlen, u8 *buffer)
+{
+	struct efx_mtd_partition *part = to_efx_mtd_partition(mtd);
+	struct efx_mtd *efx_mtd = mtd->priv;
 	const struct efx_spi_device *spi = efx_mtd->spi;
-	struct efx_nic *efx = spi->efx;
+	struct efx_nic *efx = efx_mtd->efx;
 	int rc;
 
 	rc = mutex_lock_interruptible(&efx->spi_lock);
 	if (rc)
 		return rc;
-	rc = falcon_spi_read(spi, FALCON_FLASH_BOOTCODE_START + start,
-			     len, retlen, buffer);
+	rc = falcon_spi_read(efx, spi, part->offset + start, len,
+			     retlen, buffer);
 	mutex_unlock(&efx->spi_lock);
 	return rc;
 }
 
-static int efx_mtd_erase(struct mtd_info *mtd, struct erase_info *erase)
+static int falcon_mtd_erase(struct mtd_info *mtd, loff_t start, size_t len)
 {
+	struct efx_mtd_partition *part = to_efx_mtd_partition(mtd);
 	struct efx_mtd *efx_mtd = mtd->priv;
-	struct efx_nic *efx = efx_mtd->spi->efx;
+	struct efx_nic *efx = efx_mtd->efx;
 	int rc;
 
 	rc = mutex_lock_interruptible(&efx->spi_lock);
 	if (rc)
 		return rc;
-	rc = efx_spi_erase(efx_mtd, FALCON_FLASH_BOOTCODE_START + erase->addr,
-			   erase->len);
+	rc = efx_spi_erase(part, part->offset + start, len);
 	mutex_unlock(&efx->spi_lock);
-
-	if (rc == 0) {
-		erase->state = MTD_ERASE_DONE;
-	} else {
-		erase->state = MTD_ERASE_FAILED;
-		erase->fail_addr = 0xffffffff;
-	}
-	mtd_erase_callback(erase);
 	return rc;
 }
 
-static int efx_mtd_write(struct mtd_info *mtd, loff_t start,
-			 size_t len, size_t *retlen, const u8 *buffer)
+static int falcon_mtd_write(struct mtd_info *mtd, loff_t start,
+			    size_t len, size_t *retlen, const u8 *buffer)
 {
+	struct efx_mtd_partition *part = to_efx_mtd_partition(mtd);
 	struct efx_mtd *efx_mtd = mtd->priv;
 	const struct efx_spi_device *spi = efx_mtd->spi;
-	struct efx_nic *efx = spi->efx;
+	struct efx_nic *efx = efx_mtd->efx;
 	int rc;
 
 	rc = mutex_lock_interruptible(&efx->spi_lock);
 	if (rc)
 		return rc;
-	rc = falcon_spi_write(spi, FALCON_FLASH_BOOTCODE_START + start,
-			      len, retlen, buffer);
+	rc = falcon_spi_write(efx, spi, part->offset + start, len,
+			      retlen, buffer);
 	mutex_unlock(&efx->spi_lock);
 	return rc;
 }
 
-static void efx_mtd_sync(struct mtd_info *mtd)
+static int falcon_mtd_sync(struct mtd_info *mtd)
 {
+	struct efx_mtd_partition *part = to_efx_mtd_partition(mtd);
 	struct efx_mtd *efx_mtd = mtd->priv;
-	struct efx_nic *efx = efx_mtd->spi->efx;
+	struct efx_nic *efx = efx_mtd->efx;
 	int rc;
 
 	mutex_lock(&efx->spi_lock);
-	rc = efx_spi_slow_wait(efx_mtd, true);
+	rc = efx_spi_slow_wait(part, true);
 	mutex_unlock(&efx->spi_lock);
-
-	if (rc)
-		EFX_ERR(efx, "%s sync failed (%d)\n", efx_mtd->name, rc);
-	return;
+	return rc;
 }
 
-void efx_mtd_remove(struct efx_nic *efx)
+static struct efx_mtd_ops falcon_mtd_ops = {
+	.read	= falcon_mtd_read,
+	.erase	= falcon_mtd_erase,
+	.write	= falcon_mtd_write,
+	.sync	= falcon_mtd_sync,
+};
+
+static int falcon_mtd_probe(struct efx_nic *efx)
 {
-	if (efx->spi_flash && efx->spi_flash->mtd) {
-		struct efx_mtd *efx_mtd = efx->spi_flash->mtd;
-		int rc;
+	struct efx_mtd *efx_mtd;
+	int rc = -ENODEV;
 
-		for (;;) {
-			rc = del_mtd_device(&efx_mtd->mtd);
-			if (rc != -EBUSY)
-				break;
-			ssleep(1);
+	ASSERT_RTNL();
+
+	if (efx->spi_flash) {
+		size_t n_parts =
+			(efx->spi_flash->size > FALCON_FLASH_BOOTCODE_START)
+			? 2 : 1;
+
+		efx_mtd = kzalloc(sizeof(*efx_mtd) +
+				  n_parts * sizeof(efx_mtd->part[0]),
+				  GFP_KERNEL);
+		if (!efx_mtd)
+			return -ENOMEM;
+
+		efx_mtd->spi = efx->spi_flash;
+		efx_mtd->name = "flash";
+
+		efx_mtd->ops = &falcon_mtd_ops;
+
+		efx_mtd->n_parts = n_parts;
+
+		efx_mtd->part[0].mtd.type = MTD_NORFLASH;
+		efx_mtd->part[0].mtd.flags = MTD_CAP_NORFLASH & ~MTD_WRITEABLE;
+		efx_mtd->part[0].mtd.size = min(efx->spi_flash->size,
+						FALCON_FLASH_BOOTCODE_START);
+		efx_mtd->part[0].mtd.erasesize = efx->spi_flash->erase_size;
+		efx_mtd->part[0].offset = 0;
+		efx_mtd->part[0].type_name = "sfc_flash_config";
+
+		if (n_parts > 1) {
+			efx_mtd->part[1].mtd.type = MTD_NORFLASH;
+			efx_mtd->part[1].mtd.flags = MTD_CAP_NORFLASH;
+			efx_mtd->part[1].mtd.size = (efx->spi_flash->size
+						     - FALCON_FLASH_BOOTCODE_START);
+			efx_mtd->part[1].mtd.erasesize =
+						efx->spi_flash->erase_size;
+			efx_mtd->part[1].offset = FALCON_FLASH_BOOTCODE_START;
+			efx_mtd->part[1].type_name = "sfc_flash_bootrom";
 		}
-		WARN_ON(rc);
-		kfree(efx_mtd);
+
+		rc = efx_mtd_probe_device(efx, efx_mtd);
+		if (rc) {
+			kfree(efx_mtd);
+			return rc;
+		}
 	}
+
+	if (efx->spi_eeprom) {
+		size_t n_parts =
+			(efx->spi_eeprom->size > EFX_EEPROM_BOOTCONFIG_END)
+			? 3
+			: (efx->spi_eeprom->size > EFX_EEPROM_BOOTCONFIG_START)
+			? 2 : 1;
+		efx_mtd = kzalloc(sizeof(*efx_mtd) +
+				  n_parts * sizeof(efx_mtd->part[0]),
+				  GFP_KERNEL);
+		if (!efx_mtd)
+			return -ENOMEM;
+
+		efx_mtd->spi = efx->spi_eeprom;
+		efx_mtd->name = "EEPROM";
+
+		efx_mtd->ops = &falcon_mtd_ops;
+
+		efx_mtd->n_parts = n_parts;
+
+		efx_mtd->part[0].mtd.type = MTD_RAM;
+		efx_mtd->part[0].mtd.flags = MTD_CAP_RAM;
+		efx_mtd->part[0].mtd.size = min(efx->spi_eeprom->size,
+						EFX_EEPROM_BOOTCONFIG_START);
+		efx_mtd->part[0].mtd.erasesize = efx->spi_eeprom->erase_size;
+		efx_mtd->part[0].offset = 0;
+		if (efx->spi_eeprom->size >= FALCON_NVCONFIG_END) {
+			/* Chip and board config are in EEPROM */
+			efx_mtd->part[0].mtd.flags &= ~MTD_WRITEABLE;
+			efx_mtd->part[0].type_name = "sfc_large_config";
+		} else {
+			efx_mtd->part[0].type_name = "sfc_small_config";
+		}
+
+		if (n_parts > 1) {
+			efx_mtd->part[1].mtd.type = MTD_RAM;
+			efx_mtd->part[1].mtd.flags = MTD_CAP_RAM;
+			efx_mtd->part[1].mtd.size =
+				min(efx->spi_eeprom->size, EFX_EEPROM_BOOTCONFIG_END) -
+				EFX_EEPROM_BOOTCONFIG_START;
+			efx_mtd->part[1].mtd.erasesize =
+						efx->spi_eeprom->erase_size;
+			efx_mtd->part[1].offset = EFX_EEPROM_BOOTCONFIG_START;
+			efx_mtd->part[1].type_name = "sfc_bootconfig";
+		}
+
+		if (n_parts > 2) {
+			efx_mtd->part[2].mtd.type = MTD_RAM;
+			efx_mtd->part[2].mtd.flags = MTD_CAP_RAM;
+			efx_mtd->part[2].mtd.size =
+				efx->spi_eeprom->size - EFX_EEPROM_BOOTCONFIG_END;
+			efx_mtd->part[2].mtd.erasesize =
+						efx->spi_eeprom->erase_size;
+			efx_mtd->part[2].offset = EFX_EEPROM_BOOTCONFIG_END;
+			efx_mtd->part[2].type_name = "sfc_eeprom_spare";
+		}
+
+		rc = efx_mtd_probe_device(efx, efx_mtd);
+		if (rc) {
+			kfree(efx_mtd);
+			return rc;
+		}
+	}
+
+	return rc;
 }
 
-void efx_mtd_rename(struct efx_nic *efx)
+/* Implementation of MTD operations for Siena */
+
+static int siena_mtd_read(struct mtd_info *mtd, loff_t start,
+			  size_t len, size_t *retlen, u8 *buffer)
 {
-	if (efx->spi_flash && efx->spi_flash->mtd) {
-		struct efx_mtd *efx_mtd = efx->spi_flash->mtd;
-		snprintf(efx_mtd->name, sizeof(efx_mtd->name),
-			 "%s sfc_flash_bootrom", efx->name);
+	struct efx_mtd_partition *part = to_efx_mtd_partition(mtd);
+	struct efx_mtd *efx_mtd = mtd->priv;
+	struct efx_nic *efx = efx_mtd->efx;
+	loff_t offset = start;
+	loff_t end = min_t(loff_t, start + len, mtd->size);
+	size_t chunk;
+	int rc = 0;
+
+	while (offset < end) {
+		chunk = min_t(size_t, end - offset, EFX_MCDI_NVRAM_LEN_MAX);
+		rc = efx_mcdi_nvram_read(efx, part->mcdi.nvram_type, offset,
+					 buffer, chunk);
+		if (rc)
+			goto out;
+		offset += chunk;
+		buffer += chunk;
 	}
+out:
+	*retlen = offset - start;
+	return rc;
 }
 
-int efx_mtd_probe(struct efx_nic *efx)
+static int siena_mtd_erase(struct mtd_info *mtd, loff_t start, size_t len)
 {
-	struct efx_spi_device *spi = efx->spi_flash;
-	struct efx_mtd *efx_mtd;
+	struct efx_mtd_partition *part = to_efx_mtd_partition(mtd);
+	struct efx_mtd *efx_mtd = mtd->priv;
+	struct efx_nic *efx = efx_mtd->efx;
+	loff_t offset = start & ~((loff_t)(mtd->erasesize - 1));
+	loff_t end = min_t(loff_t, start + len, mtd->size);
+	size_t chunk = part->mtd.erasesize;
+	int rc = 0;
 
-	if (!spi || spi->size <= FALCON_FLASH_BOOTCODE_START)
+	if (!part->mcdi.updating) {
+		rc = efx_mcdi_nvram_update_start(efx, part->mcdi.nvram_type);
+		if (rc)
+			goto out;
+		part->mcdi.updating = 1;
+	}
+
+	/* The MCDI interface can in fact do multiple erase blocks at once;
+	 * but erasing may be slow, so we make multiple calls here to avoid
+	 * tripping the MCDI RPC timeout. */
+	while (offset < end) {
+		rc = efx_mcdi_nvram_erase(efx, part->mcdi.nvram_type, offset,
+					  chunk);
+		if (rc)
+			goto out;
+		offset += chunk;
+	}
+out:
+	return rc;
+}
+
+static int siena_mtd_write(struct mtd_info *mtd, loff_t start,
+			   size_t len, size_t *retlen, const u8 *buffer)
+{
+	struct efx_mtd_partition *part = to_efx_mtd_partition(mtd);
+	struct efx_mtd *efx_mtd = mtd->priv;
+	struct efx_nic *efx = efx_mtd->efx;
+	loff_t offset = start;
+	loff_t end = min_t(loff_t, start + len, mtd->size);
+	size_t chunk;
+	int rc = 0;
+
+	if (!part->mcdi.updating) {
+		rc = efx_mcdi_nvram_update_start(efx, part->mcdi.nvram_type);
+		if (rc)
+			goto out;
+		part->mcdi.updating = 1;
+	}
+
+	while (offset < end) {
+		chunk = min_t(size_t, end - offset, EFX_MCDI_NVRAM_LEN_MAX);
+		rc = efx_mcdi_nvram_write(efx, part->mcdi.nvram_type, offset,
+					  buffer, chunk);
+		if (rc)
+			goto out;
+		offset += chunk;
+		buffer += chunk;
+	}
+out:
+	*retlen = offset - start;
+	return rc;
+}
+
+static int siena_mtd_sync(struct mtd_info *mtd)
+{
+	struct efx_mtd_partition *part = to_efx_mtd_partition(mtd);
+	struct efx_mtd *efx_mtd = mtd->priv;
+	struct efx_nic *efx = efx_mtd->efx;
+	int rc = 0;
+
+	if (part->mcdi.updating) {
+		part->mcdi.updating = 0;
+		rc = efx_mcdi_nvram_update_finish(efx, part->mcdi.nvram_type);
+	}
+
+	return rc;
+}
+
+static struct efx_mtd_ops siena_mtd_ops = {
+	.read	= siena_mtd_read,
+	.erase	= siena_mtd_erase,
+	.write	= siena_mtd_write,
+	.sync	= siena_mtd_sync,
+};
+
+struct siena_nvram_type_info {
+	int port;
+	const char *name;
+};
+
+static struct siena_nvram_type_info siena_nvram_types[] = {
+	[MC_CMD_NVRAM_TYPE_DISABLED_CALLISTO]	= { 0, "sfc_dummy_phy" },
+	[MC_CMD_NVRAM_TYPE_MC_FW]		= { 0, "sfc_mcfw" },
+	[MC_CMD_NVRAM_TYPE_MC_FW_BACKUP]	= { 0, "sfc_mcfw_backup" },
+	[MC_CMD_NVRAM_TYPE_STATIC_CFG_PORT0]	= { 0, "sfc_static_cfg" },
+	[MC_CMD_NVRAM_TYPE_STATIC_CFG_PORT1]	= { 1, "sfc_static_cfg" },
+	[MC_CMD_NVRAM_TYPE_DYNAMIC_CFG_PORT0]	= { 0, "sfc_dynamic_cfg" },
+	[MC_CMD_NVRAM_TYPE_DYNAMIC_CFG_PORT1]	= { 1, "sfc_dynamic_cfg" },
+	[MC_CMD_NVRAM_TYPE_EXP_ROM]		= { 0, "sfc_exp_rom" },
+	[MC_CMD_NVRAM_TYPE_EXP_ROM_CFG_PORT0]	= { 0, "sfc_exp_rom_cfg" },
+	[MC_CMD_NVRAM_TYPE_EXP_ROM_CFG_PORT1]	= { 1, "sfc_exp_rom_cfg" },
+	[MC_CMD_NVRAM_TYPE_PHY_PORT0]		= { 0, "sfc_phy_fw" },
+	[MC_CMD_NVRAM_TYPE_PHY_PORT1]		= { 1, "sfc_phy_fw" },
+};
+
+static int siena_mtd_probe_partition(struct efx_nic *efx,
+				     struct efx_mtd *efx_mtd,
+				     unsigned int part_id,
+				     unsigned int type)
+{
+	struct efx_mtd_partition *part = &efx_mtd->part[part_id];
+	struct siena_nvram_type_info *info;
+	size_t size, erase_size;
+	bool protected;
+	int rc;
+
+	if (type >= ARRAY_SIZE(siena_nvram_types))
 		return -ENODEV;
 
-	efx_mtd = kzalloc(sizeof(*efx_mtd), GFP_KERNEL);
+	info = &siena_nvram_types[type];
+
+	if (info->port != efx_port_num(efx))
+		return -ENODEV;
+
+	rc = efx_mcdi_nvram_info(efx, type, &size, &erase_size, &protected);
+	if (rc)
+		return rc;
+	if (protected && !efx_allow_nvconfig_writes)
+		return -ENODEV; /* hide it */
+
+	part->mcdi.nvram_type = type;
+	part->type_name = info->name;
+
+	part->mtd.type = MTD_NORFLASH;
+	part->mtd.flags = MTD_CAP_NORFLASH;
+	part->mtd.size = size;
+	part->mtd.erasesize = erase_size;
+
+	return 0;
+}
+
+static int siena_mtd_get_fw_subtypes(struct efx_nic *efx,
+				     struct efx_mtd *efx_mtd)
+{
+	struct efx_mtd_partition *part;
+	uint16_t fw_subtype_list[MC_CMD_GET_BOARD_CFG_OUT_FW_SUBTYPE_LIST_NUM];
+	int rc;
+
+	rc = efx_mcdi_get_board_cfg(efx, NULL, fw_subtype_list, NULL);
+	if (rc)
+		return rc;
+
+	efx_for_each_partition(part, efx_mtd)
+		part->mcdi.fw_subtype = fw_subtype_list[part->mcdi.nvram_type];
+
+	return 0;
+}
+
+static int siena_mtd_probe(struct efx_nic *efx)
+{
+	struct efx_mtd *efx_mtd;
+	int rc = -ENODEV;
+	u32 nvram_types;
+	unsigned int type;
+
+	ASSERT_RTNL();
+
+	rc = efx_mcdi_nvram_types(efx, &nvram_types);
+	if (rc)
+		return rc;
+
+	efx_mtd = kzalloc(sizeof(*efx_mtd) +
+			  hweight32(nvram_types) * sizeof(efx_mtd->part[0]),
+			  GFP_KERNEL);
 	if (!efx_mtd)
 		return -ENOMEM;
 
-	efx_mtd->spi = spi;
-	spi->mtd = efx_mtd;
+	efx_mtd->name = "Siena NVRAM manager";
 
-	efx_mtd->mtd.type = MTD_NORFLASH;
-	efx_mtd->mtd.flags = MTD_CAP_NORFLASH;
-	efx_mtd->mtd.size = spi->size - FALCON_FLASH_BOOTCODE_START;
-	efx_mtd->mtd.erasesize = spi->erase_size;
-	efx_mtd->mtd.writesize = 1;
-	efx_mtd_rename(efx);
+	efx_mtd->ops = &siena_mtd_ops;
 
-	efx_mtd->mtd.owner = THIS_MODULE;
-	efx_mtd->mtd.priv = efx_mtd;
-	efx_mtd->mtd.name = efx_mtd->name;
-	efx_mtd->mtd.erase = efx_mtd_erase;
-	efx_mtd->mtd.read = efx_mtd_read;
-	efx_mtd->mtd.write = efx_mtd_write;
-	efx_mtd->mtd.sync = efx_mtd_sync;
+	type = 0;
+	efx_mtd->n_parts = 0;
 
-	if (add_mtd_device(&efx_mtd->mtd)) {
-		kfree(efx_mtd);
-		spi->mtd = NULL;
-		/* add_mtd_device() returns 1 if the MTD table is full */
-		return -ENOMEM;
+	while (nvram_types != 0) {
+		if (nvram_types & 1) {
+			rc = siena_mtd_probe_partition(efx, efx_mtd,
+						       efx_mtd->n_parts, type);
+			if (rc == 0)
+				efx_mtd->n_parts++;
+			else if (rc != -ENODEV)
+				goto fail;
+		}
+		type++;
+		nvram_types >>= 1;
 	}
 
-	return 0;
+	rc = siena_mtd_get_fw_subtypes(efx, efx_mtd);
+	if (rc)
+		goto fail;
+
+	rc = efx_mtd_probe_device(efx, efx_mtd);
+fail:
+	if (rc)
+		kfree(efx_mtd);
+	return rc;
 }
+
diff -r 5b3d4d3c1166 drivers/net/sfc/net_driver.h
--- a/drivers/net/sfc/net_driver.h	Fri Nov 05 15:20:28 2010 +0000
+++ b/drivers/net/sfc/net_driver.h	Tue Nov 09 10:06:27 2010 +0000
@@ -1,7 +1,7 @@
 /****************************************************************************
  * Driver for Solarflare Solarstorm network controllers and boards
  * Copyright 2005-2006 Fen Systems Ltd.
- * Copyright 2005-2008 Solarflare Communications Inc.
+ * Copyright 2005-2009 Solarflare Communications Inc.
  *
  * This program is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 as published
@@ -13,33 +13,57 @@
 #ifndef EFX_NET_DRIVER_H
 #define EFX_NET_DRIVER_H
 
+#if defined(EFX_ENABLE_DEBUG) && !defined(DEBUG)
+#define DEBUG
+#endif
+
 #include <linux/version.h>
 #include <linux/netdevice.h>
 #include <linux/etherdevice.h>
 #include <linux/ethtool.h>
 #include <linux/if_vlan.h>
 #include <linux/timer.h>
+#ifndef EFX_USE_KCOMPAT
 #include <linux/mdio.h>
+#endif
 #include <linux/list.h>
 #include <linux/pci.h>
 #include <linux/device.h>
+#ifndef EFX_USE_KCOMPAT
 #include <linux/highmem.h>
 #include <linux/workqueue.h>
+#include <linux/mutex.h>
+#endif
+#include <linux/vmalloc.h>
 #include <linux/i2c.h>
+
+#ifdef EFX_USE_KCOMPAT
+/* Must come before other headers */
+#include "kernel_compat.h"
+#endif
 
 #include "enum.h"
 #include "bitfield.h"
+#include "driverlink_api.h"
 #include "driverlink.h"
+
+#ifdef EFX_USE_KCOMPAT
+	#ifdef EFX_USE_DEBUGFS
+		struct dentry;
+		typedef struct dentry efx_debugfs_entry;
+	#else
+		struct proc_dir_entry;
+		typedef struct proc_dir_entry efx_debugfs_entry;
+	#endif
+#endif
 
 /**************************************************************************
  *
  * Build definitions
  *
  **************************************************************************/
-#ifndef EFX_DRIVER_NAME
-#define EFX_DRIVER_NAME	"sfc"
-#endif
-#define EFX_DRIVER_VERSION	"2.3"
+
+#define EFX_DRIVER_VERSION	"3.1.0.4014"
 
 #ifdef EFX_ENABLE_DEBUG
 #define EFX_BUG_ON_PARANOID(x) BUG_ON(x)
@@ -49,34 +73,23 @@
 #define EFX_WARN_ON_PARANOID(x) do {} while (0)
 #endif
 
-/* Un-rate-limited logging */
-#define EFX_ERR(efx, fmt, args...) \
-dev_err(&((efx)->pci_dev->dev), "ERR: %s " fmt, efx_dev_name(efx), ##args)
+#if defined(EFX_NOT_UPSTREAM)
 
-#define EFX_INFO(efx, fmt, args...) \
-dev_info(&((efx)->pci_dev->dev), "INFO: %s " fmt, efx_dev_name(efx), ##args)
-
-#ifdef EFX_ENABLE_DEBUG
-#define EFX_LOG(efx, fmt, args...) \
-dev_info(&((efx)->pci_dev->dev), "DBG: %s " fmt, efx_dev_name(efx), ##args)
+#ifdef NDEBUG
+#define EFX_FATAL netif_err
 #else
-#define EFX_LOG(efx, fmt, args...) \
-dev_dbg(&((efx)->pci_dev->dev), "DBG: %s " fmt, efx_dev_name(efx), ##args)
+/* fatal error that cannot be ignored */
+#define EFX_FATAL(efx, type, netdev, fmt, args...) do {		\
+	netif_err(efx, type, netdev, "FTL: " fmt, ##args);	\
+	efx_schedule_reset(efx, RESET_TYPE_DISABLE);		\
+} while (0)
 #endif
 
-#define EFX_TRACE(efx, fmt, args...) do {} while (0)
+#endif
 
-#define EFX_REGDUMP(efx, fmt, args...) do {} while (0)
-
-/* Rate-limited logging */
-#define EFX_ERR_RL(efx, fmt, args...) \
-do {if (net_ratelimit()) EFX_ERR(efx, fmt, ##args); } while (0)
-
-#define EFX_INFO_RL(efx, fmt, args...) \
-do {if (net_ratelimit()) EFX_INFO(efx, fmt, ##args); } while (0)
-
-#define EFX_LOG_RL(efx, fmt, args...) \
-do {if (net_ratelimit()) EFX_LOG(efx, fmt, ##args); } while (0)
+#if defined(EFX_NOT_UPSTREAM) && !defined(__VMKLNX__)
+#define EFX_USE_FAKE_VLAN_RX_ACCEL 1
+#endif
 
 /**************************************************************************
  *
@@ -87,9 +100,23 @@ do {if (net_ratelimit()) EFX_LOG(efx, fm
 #define EFX_MAX_CHANNELS 32
 #define EFX_MAX_RX_QUEUES EFX_MAX_CHANNELS
 
-#define EFX_TX_QUEUE_OFFLOAD_CSUM	0
-#define EFX_TX_QUEUE_NO_CSUM		1
-#define EFX_TX_QUEUE_COUNT		2
+/* Checksum generation is a per-queue option in hardware, so each
+ * queue visible to the networking core is backed by two hardware TX
+ * queues. */
+#if !defined(EFX_USE_KCOMPAT) || defined(EFX_USE_TX_MQ)
+#define EFX_MAX_CORE_TX_QUEUES	EFX_MAX_CHANNELS
+#else
+#define EFX_MAX_CORE_TX_QUEUES	1
+#endif
+#define EFX_TXQ_TYPE_OFFLOAD	1
+#define EFX_TXQ_TYPES		2
+#define EFX_MAX_TX_QUEUES	(EFX_TXQ_TYPES * EFX_MAX_CORE_TX_QUEUES)
+
+#if defined(EFX_NOT_UPSTREAM) && defined(__VMKNETDDI_QUEUEOPS__)
+/* Forward declare structures used in the VMWare netq support. */
+struct netq_sw_filter;
+struct netq_hw_filter;
+#endif
 
 /**
  * struct efx_special_buffer - An Efx special buffer
@@ -103,7 +130,7 @@ do {if (net_ratelimit()) EFX_LOG(efx, fm
  * descriptor queues for each channel.  They are *not* used for the
  * actual transmit and receive buffers.
  *
- * Note that for Falcon, TX and RX descriptor queues live in host memory.
+ * Note that for TX and RX descriptor queues live in host memory.
  * Allocation and freeing procedures must take this into account.
  */
 struct efx_special_buffer {
@@ -112,6 +139,13 @@ struct efx_special_buffer {
 	unsigned int len;
 	int index;
 	int entries;
+};
+
+enum efx_flush_state {
+	FLUSH_NONE,
+	FLUSH_PENDING,
+	FLUSH_FAILED,
+	FLUSH_DONE,
 };
 
 /**
@@ -157,6 +191,8 @@ struct efx_tx_buffer {
  * @channel: The associated channel
  * @buffer: The software buffer ring
  * @txd: The hardware descriptor ring
+ * @ptr_mask: The size of the ring minus 1.
+ * @debug_dir: debugfs directory
  * @flushed: Used when handling queue flushing
  * @read_count: Current read pointer.
  *	This is the number of buffers that have been removed from both rings.
@@ -185,12 +221,16 @@ struct efx_tx_queue {
 struct efx_tx_queue {
 	/* Members which don't change on the fast path */
 	struct efx_nic *efx ____cacheline_aligned_in_smp;
-	int queue;
+	unsigned queue;
 	struct efx_channel *channel;
 	struct efx_nic *nic;
 	struct efx_tx_buffer *buffer;
 	struct efx_special_buffer txd;
-	bool flushed;
+	unsigned int ptr_mask;
+#ifdef CONFIG_SFC_DEBUGFS
+	efx_debugfs_entry *debug_dir;
+#endif
+	enum efx_flush_state flushed;
 
 	/* Members used mainly on the completion path */
 	unsigned int read_count ____cacheline_aligned_in_smp;
@@ -204,6 +244,15 @@ struct efx_tx_queue {
 	unsigned int tso_bursts;
 	unsigned int tso_long_headers;
 	unsigned int tso_packets;
+#ifdef EFX_NOT_UPSTREAM
+	/* Statistics to supplement MAC stats */
+	u64 tx_bytes;
+	u32 tx_packets;
+#endif /* EFX_NOT_UPSTREAM */
+#if defined(EFX_NOT_UPSTREAM) && defined(__VMKERNEL_MODULE__)
+	unsigned int prev_read_count;
+	unsigned int prev_write_count;
+#endif
 };
 
 /**
@@ -213,33 +262,46 @@ struct efx_tx_queue {
  *	If both this and page are %NULL, the buffer slot is currently free.
  * @page: The associated page buffer, if any.
  *	If both this and skb are %NULL, the buffer slot is currently free.
- * @data: Pointer to ethernet header
  * @len: Buffer length, in bytes.
- * @unmap_addr: DMA address to unmap
+ * @is_page: Indicates if @page is valid. If false, @skb is valid.
  */
 struct efx_rx_buffer {
 	dma_addr_t dma_addr;
-	struct sk_buff *skb;
-	struct page *page;
-	char *data;
+	union {
+		struct sk_buff *skb;
+		struct page *page;
+	} u;
 	unsigned int len;
-	dma_addr_t unmap_addr;
+	bool is_page;
+};
+
+/**
+ * struct efx_rx_page_state - Page-based rx buffer state
+ *
+ * Inserted at the start of every page allocated for receive buffers.
+ * Used to facilitate sharing dma mappings between recycled rx buffers
+ * and those passed up to the kernel.
+ *
+ * @refcnt: Number of struct efx_rx_buffer's referencing this page.
+ *	When refcnt falls to zero, the page is unmapped for dma
+ * @dma_addr: The dma address of this page.
+ */
+struct efx_rx_page_state {
+	unsigned refcnt;
+	dma_addr_t dma_addr;
+
+	unsigned int __pad[0] ____cacheline_aligned;
 };
 
 /**
  * struct efx_rx_queue - An Efx RX queue
  * @efx: The associated Efx NIC
- * @queue: DMA queue number
- * @channel: The associated channel
  * @buffer: The software buffer ring
  * @rxd: The hardware descriptor ring
+ * @ptr_mask: The size of the ring minus 1.
  * @added_count: Number of buffers added to the receive queue.
  * @notified_count: Number of buffers given to NIC (<= @added_count).
  * @removed_count: Number of buffers removed from the receive queue.
- * @add_lock: Receive queue descriptor add spin lock.
- *	This lock must be held in order to add buffers to the RX
- *	descriptor ring (rxd and buffer) and to update added_count (but
- *	not removed_count).
  * @max_fill: RX descriptor maximum fill level (<= ring size)
  * @fast_fill_trigger: RX descriptor fill level that will trigger a fast fill
  *	(<= @max_fill)
@@ -248,30 +310,24 @@ struct efx_rx_buffer {
  * @min_fill: RX descriptor minimum non-zero fill level.
  *	This records the minimum fill level observed when a ring
  *	refill was triggered.
- * @min_overfill: RX descriptor minimum overflow fill level.
- *	This records the minimum fill level at which RX queue
- *	overflow was observed.  It should never be set.
  * @alloc_page_count: RX allocation strategy counter.
  * @alloc_skb_count: RX allocation strategy counter.
- * @work: Descriptor push work thread
- * @buf_page: Page for next RX buffer.
- *	We can use a single page for multiple RX buffers. This tracks
- *	the remaining space in the allocation.
- * @buf_dma_addr: Page's DMA address.
- * @buf_data: Page's host address.
+ * @recycle_count: RX buffer recycle counter.
+ * @resurrect_count: Shared RX buffer resurrection counter.
+ * @resurrect_failed_count: Shared RX buffer resurrection failed counter.
+ * @slow_fill: Timer used to defer efx_nic_generate_fill_event().
  * @flushed: Use when handling queue flushing
+ * @debug_dir: debugfs directory
  */
 struct efx_rx_queue {
 	struct efx_nic *efx;
-	int queue;
-	struct efx_channel *channel;
 	struct efx_rx_buffer *buffer;
 	struct efx_special_buffer rxd;
+	unsigned int ptr_mask;
 
 	int added_count;
 	int notified_count;
 	int removed_count;
-	spinlock_t add_lock;
 	unsigned int max_fill;
 	unsigned int fast_fill_trigger;
 	unsigned int fast_fill_limit;
@@ -279,13 +335,17 @@ struct efx_rx_queue {
 	unsigned int min_overfill;
 	unsigned int alloc_page_count;
 	unsigned int alloc_skb_count;
-	struct delayed_work work;
+	unsigned int recycle_count;
+	unsigned int resurrect_count;
+	unsigned int resurrect_failed_count;
+	struct timer_list slow_fill;
 	unsigned int slow_fill_count;
 
-	struct page *buf_page;
-	dma_addr_t buf_dma_addr;
-	char *buf_data;
-	bool flushed;
+	enum efx_flush_state flushed;
+
+#ifdef CONFIG_SFC_DEBUGFS
+	efx_debugfs_entry *debug_dir;
+#endif
 };
 
 /**
@@ -294,7 +354,7 @@ struct efx_rx_queue {
  * @dma_addr: DMA base address of the buffer
  * @len: Buffer length, in bytes
  *
- * Falcon uses these buffers for its interrupt status registers and
+ * The NIC uses these buffers for its interrupt status registers and
  * MAC stats dumps.
  */
 struct efx_buffer {
@@ -304,10 +364,87 @@ struct efx_buffer {
 };
 
 
-/* Flags for channel->used_flags */
-#define EFX_USED_BY_RX 1
-#define EFX_USED_BY_TX 2
-#define EFX_USED_BY_RX_TX (EFX_USED_BY_RX | EFX_USED_BY_TX)
+#if defined(EFX_NOT_UPSTREAM) && defined(EFX_USE_SFC_LRO)
+
+/**
+ * struct efx_ssr_conn - Connection state for Soft Segment Reassembly (SSR) aka LRO
+ * @link: Link for hash table and free list.
+ * @active_link: Link for active_conns list
+ * @l2_id: Identifying information from layer 2
+ * @conn_hash: Hash of connection 4-tuple
+ * @source: Source TCP port number
+ * @dest: Destination TCP port number
+ * @n_in_order_pkts: Number of in-order packets with payload.
+ * @next_seq: Next in-order sequence number.
+ * @last_pkt_jiffies: Time we last saw a packet on this connection.
+ * @skb: The SKB we are currently holding.
+ *	If %NULL, then all following fields are undefined.
+ * @skb_tail: The tail of the frag_list of SKBs we're holding.
+ *	Only valid after at least one merge (and when not in page-mode).
+ * @th_last: The TCP header of the last packet merged.
+ * @next_buf: The next RX buffer to process.
+ * @next_eh: Ethernet header of the next buffer.
+ * @next_iph: IP header of the next buffer.
+ * @delivered: True if we've delivered a payload packet up this interrupt.
+ */
+struct efx_ssr_conn {
+	struct list_head link;
+	struct list_head active_link;
+	u16 l2_id;
+	u32 conn_hash;
+	__be16 source, dest;
+	int n_in_order_pkts;
+	unsigned next_seq;
+	unsigned last_pkt_jiffies;
+	struct sk_buff *skb;
+	struct sk_buff *skb_tail;
+	struct tcphdr *th_last;
+	struct efx_rx_buffer next_buf;
+	char *next_eh;
+	void *next_iph;
+	int delivered;
+};
+
+/**
+ * struct efx_ssr_state - Port state for Soft Segment Reassembly (SSR) aka LRO
+ * @efx: The associated NIC.
+ * @conns_mask: Number of hash buckets - 1.
+ * @conns: Hash buckets for tracked connections.
+ * @conns_n: Length of linked list for each hash bucket.
+ * @active_conns: Connections that are holding a packet.
+ *	Connections are self-linked when not in this list.
+ * @free_conns: Free efx_ssr_conn instances.
+ * @last_purge_jiffies: The value of jiffies last time we purged idle
+ *	connections.
+ * @n_merges: Number of packets absorbed by SSR.
+ * @n_bursts: Number of bursts spotted by SSR.
+ * @n_slow_start: Number of packets not merged because connection may be in
+ *	slow-start.
+ * @n_misorder: Number of out-of-order packets seen in tracked streams.
+ * @n_too_many: Incremented when we're trying to track too many streams.
+ * @n_new_stream: Number of distinct streams we've tracked.
+ * @n_drop_idle: Number of streams discarded because they went idle.
+ * @n_drop_closed: Number of streams that have seen a FIN or RST.
+ */
+struct efx_ssr_state {
+	struct efx_nic *efx;
+	unsigned conns_mask;
+	struct list_head *conns;
+	unsigned *conns_n;
+	struct list_head active_conns;
+	struct list_head free_conns;
+	unsigned last_purge_jiffies;
+	unsigned n_merges;
+	unsigned n_bursts;
+	unsigned n_slow_start;
+	unsigned n_misorder;
+	unsigned n_too_many;
+	unsigned n_new_stream;
+	unsigned n_drop_idle;
+	unsigned n_drop_closed;
+};
+
+#endif
 
 enum efx_rx_alloc_method {
 	RX_ALLOC_METHOD_AUTO = 0,
@@ -324,38 +461,42 @@ enum efx_rx_alloc_method {
  *
  * @efx: Associated Efx NIC
  * @channel: Channel instance number
- * @name: Name for channel and IRQ
- * @used_flags: Channel is used by net driver
  * @enabled: Channel enabled indicator
  * @irq: IRQ number (MSI and MSI-X only)
- * @irq_moderation: IRQ moderation value (in us)
+ * @irq_moderation: IRQ moderation value (in hardware ticks)
  * @napi_dev: Net device used with NAPI
  * @napi_str: NAPI control structure
  * @reset_work: Scheduled reset work thread
  * @work_pending: Is work pending via NAPI?
  * @eventq: Event queue buffer
+ * @eventq_mask: Event queue pointer mask
  * @eventq_read_ptr: Event queue read pointer
  * @last_eventq_read_ptr: Last event queue read pointer value.
- * @eventq_magic: Event queue magic value for driver-generated test events
+ * @magic_count: Event queue test event count
  * @irq_count: Number of IRQs since last adaptive moderation decision
  * @irq_mod_score: IRQ moderation score
+ * @debug_dir: debugfs directory
  * @rx_alloc_level: Watermark based heuristic counter for pushing descriptors
  *	and diagnostic counters
  * @rx_alloc_push_pages: RX allocation method currently in use for pushing
  *	descriptors
  * @n_rx_tobe_disc: Count of RX_TOBE_DISC errors
- * @n_rx_ip_frag_err: Count of RX IP fragment errors
+ * @n_rx_ip_frag: Count of RX packets containing fragmented IP
  * @n_rx_ip_hdr_chksum_err: Count of RX IP header checksum errors
  * @n_rx_tcp_udp_chksum_err: Count of RX TCP and UDP checksum errors
+ * @n_rx_eth_crc_err: Count of RX CRC errors
+ * @n_rx_mcast_mismatch: Count of unmatched multicast frames
  * @n_rx_frm_trunc: Count of RX_FRM_TRUNC errors
  * @n_rx_overlength: Count of RX_OVERLENGTH errors
  * @n_skbuff_leaks: Count of skbuffs leaked due to RX overrun
+ * @rx_queue: RX queue for this channel
+ * @tx_stop_count: Core TX queue stop count
+ * @tx_stop_lock: Core TX queue stop lock
+ * @tx_queue: TX queues for this channel
  */
 struct efx_channel {
 	struct efx_nic *efx;
 	int channel;
-	char name[IFNAMSIZ + 6];
-	int used_flags;
 	bool enabled;
 	int irq;
 	unsigned int irq_moderation;
@@ -363,20 +504,38 @@ struct efx_channel {
 	struct napi_struct napi_str;
 	bool work_pending;
 	struct efx_special_buffer eventq;
+	unsigned int eventq_mask;
 	unsigned int eventq_read_ptr;
 	unsigned int last_eventq_read_ptr;
-	unsigned int eventq_magic;
+	unsigned int magic_count;
 
 	unsigned int irq_count;
 	unsigned int irq_mod_score;
 
+#ifdef CONFIG_SFC_DEBUGFS
+	efx_debugfs_entry *debug_dir;
+#endif
+#if defined(EFX_USE_KCOMPAT) && defined(EFX_NEED_SAVE_MSIX_MESSAGES)
+	struct msi_msg msix_msg;
+#endif
+#if defined(EFX_USE_KCOMPAT) && defined(EFX_NEED_UNMASK_MSIX_VECTORS)
+	u32 msix_ctrl;
+#endif
+
+#if defined(EFX_NOT_UPSTREAM) && defined(EFX_USE_SFC_LRO)
+	struct efx_ssr_state ssr;
+	/* RX allocation method currently in use for popping descriptors */
+	int rx_alloc_pop_pages;
+#endif
 	int rx_alloc_level;
 	int rx_alloc_push_pages;
 
 	unsigned n_rx_tobe_disc;
-	unsigned n_rx_ip_frag_err;
+	unsigned n_rx_ip_frag;
 	unsigned n_rx_ip_hdr_chksum_err;
 	unsigned n_rx_tcp_udp_chksum_err;
+	unsigned n_rx_eth_crc_err;
+	unsigned n_rx_mcast_mismatch;
 	unsigned n_rx_frm_trunc;
 	unsigned n_rx_overlength;
 	unsigned n_skbuff_leaks;
@@ -387,55 +546,49 @@ struct efx_channel {
 	struct efx_rx_buffer *rx_pkt;
 	bool rx_pkt_csummed;
 
+#if defined(EFX_NOT_UPSTREAM)
+	/* Statistics to supplement MAC stats */
+	u64 rx_bytes;
+	u32 rx_packets;
+#endif
+#if defined(EFX_NOT_UPSTREAM) && defined(__VMKNETDDI_QUEUEOPS__)
+	/** Used to track use by VMWare netqueue code. */
+	int netq_use;
+	struct net_device_stats	netq_stats;
+	char irqid[IFNAMSIZ + 8];
+#endif
+
+	struct efx_rx_queue rx_queue;
+
+	atomic_t tx_stop_count;
+	spinlock_t tx_stop_lock;
+
+	struct efx_tx_queue tx_queue[2];
 };
 
-/**
- * struct efx_blinker - S/W LED blinking context
- * @state: Current state - on or off
- * @resubmit: Timer resubmission flag
- * @timer: Control timer for blinking
- */
-struct efx_blinker {
-	bool state;
-	bool resubmit;
-	struct timer_list timer;
+enum efx_led_mode {
+	EFX_LED_OFF	= 0,
+	EFX_LED_ON	= 1,
+	EFX_LED_DEFAULT	= 2
 };
 
+#define STRING_TABLE_LOOKUP(val, member) \
+	((val) < member ## _max) ? member ## _names[val] : "(invalid)"
 
-/**
- * struct efx_board - board information
- * @type: Board model type
- * @major: Major rev. ('A', 'B' ...)
- * @minor: Minor rev. (0, 1, ...)
- * @init: Initialisation function
- * @init_leds: Sets up board LEDs. May be called repeatedly.
- * @set_id_led: Turns the identification LED on or off
- * @blink: Starts/stops blinking
- * @monitor: Board-specific health check function
- * @fini: Cleanup function
- * @blinker: used to blink LEDs in software
- * @hwmon_client: I2C client for hardware monitor
- * @ioexp_client: I2C client for power/port control
- */
-struct efx_board {
-	int type;
-	int major;
-	int minor;
-	int (*init) (struct efx_nic *nic);
-	/* As the LEDs are typically attached to the PHY, LEDs
-	 * have a separate init callback that happens later than
-	 * board init. */
-	void (*init_leds)(struct efx_nic *efx);
-	void (*set_id_led) (struct efx_nic *efx, bool state);
-	int (*monitor) (struct efx_nic *nic);
-	void (*blink) (struct efx_nic *efx, bool start);
-	void (*fini) (struct efx_nic *nic);
-	struct efx_blinker blinker;
-	struct i2c_client *hwmon_client, *ioexp_client;
-};
+extern const char *efx_loopback_mode_names[];
+extern const unsigned int efx_loopback_mode_max;
+#define LOOPBACK_MODE(efx) \
+	STRING_TABLE_LOOKUP((efx)->loopback_mode, efx_loopback_mode)
 
-#define STRING_TABLE_LOOKUP(val, member)	\
-	member ## _names[val]
+extern const char *efx_interrupt_mode_names[];
+extern const unsigned int efx_interrupt_mode_max;
+#define INT_MODE(efx) \
+	STRING_TABLE_LOOKUP(efx->interrupt_mode, efx_interrupt_mode)
+
+extern const char *efx_reset_type_names[];
+extern const unsigned int efx_reset_type_max;
+#define RESET_TYPE(type) \
+	STRING_TABLE_LOOKUP(type, efx_reset_type)
 
 enum efx_int_mode {
 	/* Be careful if altering to correct macro below */
@@ -445,21 +598,6 @@ enum efx_int_mode {
 	EFX_INT_MODE_MAX	/* Insert any new items before this */
 };
 #define EFX_INT_MODE_USE_MSI(x) (((x)->interrupt_mode) <= EFX_INT_MODE_MSI)
-
-enum phy_type {
-	PHY_TYPE_NONE = 0,
-	PHY_TYPE_TXC43128 = 1,
-	PHY_TYPE_88E1111 = 2,
-	PHY_TYPE_SFX7101 = 3,
-	PHY_TYPE_QT2022C2 = 4,
-	PHY_TYPE_PM8358 = 6,
-	PHY_TYPE_SFT9001A = 8,
-	PHY_TYPE_QT2025C = 9,
-	PHY_TYPE_SFT9001B = 10,
-	PHY_TYPE_MAX	/* Insert any new items before this */
-};
-
-#define EFX_IS10G(efx) ((efx)->link_speed == 10000)
 
 enum nic_state {
 	STATE_INIT = 0,
@@ -501,73 +639,72 @@ enum efx_fc_type {
 	EFX_FC_AUTO = 4,
 };
 
-/* Supported MAC bit-mask */
-enum efx_mac_type {
-	EFX_GMAC = 1,
-	EFX_XMAC = 2,
+/**
+ * struct efx_link_state - Current state of the link
+ * @up: Link is up
+ * @fd: Link is full-duplex
+ * @fc: Actual flow control flags
+ * @speed: Link speed (Mbps)
+ */
+struct efx_link_state {
+	bool up;
+	bool fd;
+	enum efx_fc_type fc;
+	unsigned int speed;
 };
 
-static inline enum efx_fc_type efx_fc_resolve(enum efx_fc_type wanted_fc,
-					      unsigned int lpa)
+static inline bool efx_link_state_equal(const struct efx_link_state *left,
+					const struct efx_link_state *right)
 {
-	BUILD_BUG_ON(EFX_FC_AUTO & (EFX_FC_RX | EFX_FC_TX));
-
-	if (!(wanted_fc & EFX_FC_AUTO))
-		return wanted_fc;
-
-	return mii_resolve_flowctrl_fdx(mii_advertise_flowctrl(wanted_fc), lpa);
+	return left->up == right->up && left->fd == right->fd &&
+		left->fc == right->fc && left->speed == right->speed;
 }
 
 /**
  * struct efx_mac_operations - Efx MAC operations table
  * @reconfigure: Reconfigure MAC. Serialised by the mac_lock
  * @update_stats: Update statistics
- * @irq: Hardware MAC event callback. Serialised by the mac_lock
- * @poll: Poll for hardware state. Serialised by the mac_lock
+ * @check_fault: Check fault state. True if fault present.
  */
 struct efx_mac_operations {
-	void (*reconfigure) (struct efx_nic *efx);
+	int (*reconfigure) (struct efx_nic *efx);
 	void (*update_stats) (struct efx_nic *efx);
-	void (*irq) (struct efx_nic *efx);
-	void (*poll) (struct efx_nic *efx);
+	bool (*check_fault)(struct efx_nic *efx);
 };
 
 /**
  * struct efx_phy_operations - Efx PHY operations table
+ * @probe: Probe PHY and initialise efx->mdio.mode_support, efx->mdio.mmds,
+ *	efx->loopback_modes.
  * @init: Initialise PHY
  * @fini: Shut down PHY
  * @reconfigure: Reconfigure PHY (e.g. for new link parameters)
- * @clear_interrupt: Clear down interrupt
- * @blink: Blink LEDs
- * @poll: Poll for hardware state. Serialised by the mac_lock.
+ * @poll: Update @link_state and report whether it changed.
+ *	Serialised by the mac_lock.
  * @get_settings: Get ethtool settings. Serialised by the mac_lock.
  * @set_settings: Set ethtool settings. Serialised by the mac_lock.
  * @set_npage_adv: Set abilities advertised in (Extended) Next Page
  *	(only needed where AN bit is set in mmds)
- * @num_tests: Number of PHY-specific tests/results
- * @test_names: Names of the tests/results
- * @run_tests: Run tests and record results as appropriate.
+ * @test_alive: Test that PHY is 'alive' (online)
+ * @test_name: Get the name of a PHY-specific test/result
+ * @run_tests: Run tests and record results as appropriate (offline).
  *	Flags are the ethtool tests flags.
- * @mmds: MMD presence mask
- * @loopbacks: Supported loopback modes mask
  */
 struct efx_phy_operations {
-	enum efx_mac_type macs;
+	int (*probe) (struct efx_nic *efx);
 	int (*init) (struct efx_nic *efx);
 	void (*fini) (struct efx_nic *efx);
-	void (*reconfigure) (struct efx_nic *efx);
-	void (*clear_interrupt) (struct efx_nic *efx);
-	void (*poll) (struct efx_nic *efx);
+	void (*remove) (struct efx_nic *efx);
+	int (*reconfigure) (struct efx_nic *efx);
+	bool (*poll) (struct efx_nic *efx);
 	void (*get_settings) (struct efx_nic *efx,
 			      struct ethtool_cmd *ecmd);
 	int (*set_settings) (struct efx_nic *efx,
 			     struct ethtool_cmd *ecmd);
 	void (*set_npage_adv) (struct efx_nic *efx, u32);
-	u32 num_tests;
-	const char *const *test_names;
+	int (*test_alive) (struct efx_nic *efx);
+	const char *(*test_name) (struct efx_nic *efx, unsigned int index);
 	int (*run_tests) (struct efx_nic *efx, int *results, unsigned flags);
-	int mmds;
-	unsigned loopbacks;
 };
 
 /**
@@ -660,6 +797,15 @@ struct efx_mac_stats {
 	unsigned long rx_length_error;
 	unsigned long rx_internal_error;
 	unsigned long rx_good_lt64;
+	unsigned long rx_char_error_lane0;
+	unsigned long rx_char_error_lane1;
+	unsigned long rx_char_error_lane2;
+	unsigned long rx_char_error_lane3;
+	unsigned long rx_disp_error_lane0;
+	unsigned long rx_disp_error_lane1;
+	unsigned long rx_disp_error_lane2;
+	unsigned long rx_disp_error_lane3;
+	u64 rx_match_fault;
 };
 
 /* Number of bits used in a multicast filter hash address */
@@ -674,10 +820,29 @@ union efx_multicast_hash {
 	efx_oword_t oword[EFX_MCAST_HASH_ENTRIES / sizeof(efx_oword_t) / 8];
 };
 
+/* Efx Error condition statistics */
+struct efx_nic_errors {
+	atomic_t missing_event;
+	atomic_t rx_reset;
+	atomic_t rx_desc_fetch;
+	atomic_t tx_desc_fetch;
+	atomic_t spurious_tx;
+
+#ifdef CONFIG_SFC_DEBUGFS
+	efx_debugfs_entry *debug_dir;
+#endif
+};
+
+struct efx_filter_state;
+struct efx_vf;
+struct vfdi_status;
+
 /**
  * struct efx_nic - an Efx NIC
  * @name: Device name (net device name or bus id before net device registered)
  * @pci_dev: The PCI device
+ * @revision: Hardware architecture revision
+ * @dl_revision: Revision name for driverlink
  * @type: Controller type attributes
  * @legacy_irq: IRQ number
  * @workqueue: Workqueue for port reconfigures and the HW monitor.
@@ -691,83 +856,103 @@ union efx_multicast_hash {
  * @interrupt_mode: Interrupt mode
  * @irq_rx_adaptive: Adaptive IRQ moderation enabled for RX event queues
  * @irq_rx_moderation: IRQ moderation time for RX event queues
- * @i2c_adap: I2C adapter
- * @board_info: Board-level information
+ * @msg_enable: Log message enable flags
  * @state: Device state flag. Serialised by the rtnl_lock.
  * @reset_pending: Pending reset method (normally RESET_TYPE_NONE)
  * @tx_queue: TX DMA queues
  * @rx_queue: RX DMA queues
  * @channel: Channels
- * @n_rx_queues: Number of RX queues
+ * @channel_name: Names for channels and their IRQs
+ * @rxq_entries: Size of receive queues requested by user.
+ * @txq_entries: Size of transmit queues requested by user.
+ * @tx_dc_entries: Number of entries in each TX queue descriptor cache
+ * @rx_dc_entries: Number of entries in each RX queue descriptor cache
+ * @tx_dc_base: Base address in SRAM of TX queue descriptor caches
+ * @rx_dc_base: Base address in SRAM of RX queue descriptor caches
+ * @sram_lim: High address limit of SRAM
+ * @resources: Driverlink parameters
  * @n_channels: Number of channels in use
+ * @n_rx_channels: Number of channels used for RX (= number of RX queues)
+ * @n_tx_channels: Number of channels used for TX
+ * @tx_channel_offset: Offset of zeroth channel used for TX.
  * @rx_buffer_len: RX buffer length
  * @rx_buffer_order: Order (log2) of number of pages for each RX buffer
+ * @rx_indir_table: Indirection table for RSS
+ * @errors: Error condition stats
+ * @int_error_count: Number of internal errors seen recently
+ * @int_error_expire: Time at which error count will be expired
  * @irq_status: Interrupt status buffer
  * @last_irq_cpu: Last CPU to handle interrupt.
  *	This register is written with the SMP processor ID whenever an
- *	interrupt is handled.  It is used by falcon_test_interrupt()
+ *	interrupt is handled.  It is used by efx_nic_test_interrupt()
  *	to verify that an interrupt has occurred.
  * @spi_flash: SPI flash device
- *	This field will be %NULL if no flash device is present.
+ *	This field will be %NULL if no flash device is present (or for Siena).
  * @spi_eeprom: SPI EEPROM device
- *	This field will be %NULL if no EEPROM device is present.
+ *	This field will be %NULL if no EEPROM device is present (or for Siena).
  * @spi_lock: SPI bus lock
+ * @mtd_list: List of MTDs attached to the NIC
  * @n_rx_nodesc_drop_cnt: RX no descriptor drop count
  * @nic_data: Hardware dependant state
- * @mac_lock: MAC access lock. Protects @port_enabled, @phy_mode,
- *	@port_inhibited, efx_monitor() and efx_reconfigure_port()
+ * @mac_lock: MAC access lock. Protects @port_enabled, @link_up, @phy_mode,
+ *	@port_inhibited, efx_monitor() and efx_mac_work()
+ * @mac_work: Work item for changing MAC promiscuity and multicast hash
  * @port_enabled: Port enabled indicator.
- *	Serialises efx_stop_all(), efx_start_all(), efx_monitor(),
- *	efx_phy_work(), and efx_mac_work() with kernel interfaces. Safe to read
- *	under any one of the rtnl_lock, mac_lock, or netif_tx_lock, but all
- *	three must be held to modify it.
+ *	Serialises efx_stop_all(), efx_start_all(), efx_monitor() and
+ *	efx_mac_work() with kernel interfaces. Safe to read under any
+ *	one of the rtnl_lock, mac_lock, or netif_tx_lock, but all three must
+ *	be held to modify it.
  * @port_inhibited: If set, the netif_carrier is always off. Hold the mac_lock
  * @port_initialized: Port initialized?
  * @net_dev: Operating system network device. Consider holding the rtnl lock
  * @rx_checksum_enabled: RX checksumming enabled
- * @netif_stop_count: Port stop count
- * @netif_stop_lock: Port stop lock
  * @mac_stats: MAC statistics. These include all statistics the MACs
  *	can provide.  Generic code converts these into a standard
  *	&struct net_device_stats.
  * @stats_buffer: DMA buffer for statistics
  * @stats_lock: Statistics update lock. Serialises statistics fetches
- * @stats_disable_count: Nest count for disabling statistics fetches
  * @mac_op: MAC interface
  * @mac_address: Permanent MAC address
  * @phy_type: PHY type
- * @phy_lock: PHY access lock
+ * @mdio_lock: MDIO lock
  * @phy_op: PHY interface
  * @phy_data: PHY private data (including PHY-specific stats)
  * @mdio: PHY MDIO interface
+ * @mdio_bus: PHY MDIO bus ID (only used by Siena)
  * @phy_mode: PHY operating mode. Serialised by @mac_lock.
- * @mac_up: MAC link state
- * @link_up: Link status
- * @link_fd: Link is full duplex
- * @link_fc: Actualy flow control flags
- * @link_speed: Link speed (Mbps)
+ * @xmac_poll_required: XMAC link state needs polling
+ * @link_advertising: Autonegotiation advertising flags
+ * @link_state: Current state of the link
  * @n_link_state_changes: Number of times the link has changed state
  * @promiscuous: Promiscuous flag. Protected by netif_tx_lock.
  * @multicast_hash: Multicast hash table
  * @wanted_fc: Wanted flow control flags
- * @phy_work: work item for dealing with PHY events
- * @mac_work: work item for dealing with MAC events
  * @loopback_mode: Loopback status
  * @loopback_modes: Supported loopback mode bitmask
  * @loopback_selftest: Offline self-test private state
- * @silicon_rev: Silicon revision description for driverlink
  * @dl_info: Linked list of hardware parameters exposed through driverlink
  * @dl_node: Driverlink port list
  * @dl_device_list: Driverlink device list
  * @dl_cb: Driverlink callbacks table
  * @dl_cb_dev: Driverlink callback owner devices
+ * @debug_dir: NIC debugfs directory
+ * @debug_symlink: NIC debugfs sym-link (nic_eth\%d)
+ * @debug_port_dir: Port debugfs directory
+ * @debug_port_symlink: Port debugfs sym-link (if_eth\%d)
+ * @vf: Array of &struct efx_vf objects.
+ * @vf_count: Number of VFs that have been enabled.
+ * @vi_scale: log2 number of vnics per VF.
+ * @vfdi_status: Common VFDI status page to be dmad to VF address space.
+ * @vfdi_status_addr: PF dma address of %vfdi_status.
  *
- * The @priv field of the corresponding &struct net_device points to
- * this.
+ * This is stored in the private area of the &struct net_device.
  */
 struct efx_nic {
 	char name[IFNAMSIZ];
 	struct pci_dev *pci_dev;
+#if defined(EFX_USE_KCOMPAT) && !defined(EFX_USE_NETDEV_DEV_ID)
+	unsigned port_num;
+#endif
 	const struct efx_nic_type *type;
 	int legacy_irq;
 	struct workqueue_struct *workqueue;
@@ -780,32 +965,52 @@ struct efx_nic {
 	enum efx_int_mode interrupt_mode;
 	bool irq_rx_adaptive;
 	unsigned int irq_rx_moderation;
-
-	struct i2c_adapter i2c_adap;
-	struct efx_board board_info;
+	u32 msg_enable;
 
 	enum nic_state state;
 	enum reset_type reset_pending;
 
-	struct efx_tx_queue tx_queue[EFX_TX_QUEUE_COUNT];
-	struct efx_rx_queue rx_queue[EFX_MAX_RX_QUEUES];
-	struct efx_channel channel[EFX_MAX_CHANNELS];
+	struct efx_channel *channel[EFX_MAX_CHANNELS];
+	char channel_name[EFX_MAX_CHANNELS][IFNAMSIZ + 6];
 
-	int n_rx_queues;
-	int n_channels;
+	unsigned rxq_entries;
+	unsigned txq_entries;
+
+	unsigned tx_dc_entries;
+	unsigned rx_dc_entries;
+	unsigned tx_dc_base;
+	unsigned rx_dc_base;
+	unsigned sram_lim;
+	struct efx_dl_falcon_resources resources;
+
+	unsigned n_channels;
+	unsigned n_rx_channels;
+	unsigned n_tx_channels;
+	unsigned tx_channel_offset;
 	unsigned int rx_buffer_len;
 	unsigned int rx_buffer_order;
+	u8 rx_hash_key[40];
+	u32 rx_indir_table[128];
+
+	struct efx_nic_errors errors;
+	unsigned int_error_count;
+	unsigned long int_error_expire;
 
 	struct efx_buffer irq_status;
 	volatile signed int last_irq_cpu;
+	unsigned irq_zero_count;
+	unsigned long irq_level;
 
 	struct efx_spi_device *spi_flash;
 	struct efx_spi_device *spi_eeprom;
 	struct mutex spi_lock;
+#ifdef CONFIG_SFC_MTD
+	struct list_head mtd_list;
+#endif
 
 	unsigned n_rx_nodesc_drop_cnt;
 
-	struct falcon_nic_data *nic_data;
+	void *nic_data;
 
 	struct mutex mac_lock;
 	struct work_struct mac_work;
@@ -815,51 +1020,74 @@ struct efx_nic {
 	bool port_initialized;
 	struct net_device *net_dev;
 	bool rx_checksum_enabled;
-
-	atomic_t netif_stop_count;
-	spinlock_t netif_stop_lock;
+#if defined(EFX_USE_KCOMPAT) && !defined(NETIF_F_LRO)
+	bool lro_enabled;
+#endif
 
 	struct efx_mac_stats mac_stats;
+#if defined(EFX_USE_KCOMPAT) && !defined(EFX_USE_NETDEV_STATS)
+	struct net_device_stats stats;
+#endif
 	struct efx_buffer stats_buffer;
 	spinlock_t stats_lock;
-	unsigned int stats_disable_count;
 
 	struct efx_mac_operations *mac_op;
 	unsigned char mac_address[ETH_ALEN];
+#if defined(EFX_NOT_UPSTREAM) && defined(EFX_USE_FAKE_VLAN_RX_ACCEL)
+	struct vlan_group *vlan_group;
+#endif
 
-	enum phy_type phy_type;
-	spinlock_t phy_lock;
-	struct work_struct phy_work;
+	unsigned int phy_type;
+	char phy_name[20];
+	struct mutex mdio_lock;
 	struct efx_phy_operations *phy_op;
 	void *phy_data;
 	struct mdio_if_info mdio;
+	unsigned int mdio_bus;
 	enum efx_phy_mode phy_mode;
 
-	bool mac_up;
-	bool link_up;
-	bool link_fd;
-	enum efx_fc_type link_fc;
-	unsigned int link_speed;
+	bool xmac_poll_required;
+	u32 link_advertising;
+	struct efx_link_state link_state;
 	unsigned int n_link_state_changes;
 
 	bool promiscuous;
 	union efx_multicast_hash multicast_hash;
 	enum efx_fc_type wanted_fc;
 
-	atomic_t rx_reset;
 	enum efx_loopback_mode loopback_mode;
-	unsigned int loopback_modes;
-
+	u64 loopback_modes;
+	unsigned int startup_loopback_mode;
 	void *loopback_selftest;
 
-	const char *silicon_rev;
-#ifdef CONFIG_SFC_DRIVERLINK
+	struct efx_filter_state *filter_state;
+
 	struct efx_dl_device_info *dl_info;
 	struct list_head dl_node;
 	struct list_head dl_device_list;
 	struct efx_dl_callbacks dl_cb;
 	struct efx_dl_cb_devices dl_cb_dev;
+
+#ifdef CONFIG_SFC_DEBUGFS
+	efx_debugfs_entry *debug_dir;
+	efx_debugfs_entry *debug_symlink;
+	efx_debugfs_entry *debug_port_dir;
+	efx_debugfs_entry *debug_port_symlink;
 #endif
+#if defined(EFX_NOT_UPSTREAM) && defined(__VMKNETDDI_QUEUEOPS__)
+	struct netq_sw_filter *sw_filters;
+	struct netq_hw_filter *hw_filters;
+	struct netq_hw_filter *free_hw_filters;
+	void *netq_hash;
+	spinlock_t hwfilt_lock;
+	int netq_active;
+#endif
+
+	struct efx_vf *vf;
+	unsigned vf_count;
+	unsigned vi_scale;
+	struct vfdi_status *vfdi_status;
+	dma_addr_t vfdi_status_addr;
 };
 
 static inline int efx_dev_registered(struct efx_nic *efx)
@@ -876,50 +1104,111 @@ static inline const char *efx_dev_name(s
 	return efx_dev_registered(efx) ? efx->name : "";
 }
 
+static inline unsigned int efx_port_num(struct efx_nic *efx)
+{
+#if !defined(EFX_USE_KCOMPAT) || defined(EFX_USE_NETDEV_DEV_ID)
+	return efx->net_dev->dev_id;
+#else
+	return efx->port_num;
+#endif
+}
+
+struct efx_nic_register_mask;
+struct efx_nic_table_mask;
+
 /**
  * struct efx_nic_type - Efx device type definition
- * @mem_bar: Memory BAR number
+ * @probe: Probe the controller
+ * @remove: Free resources allocated by probe()
+ * @init: Initialise the controller
+ * @fini: Shut down the controller
+ * @monitor: Periodic function for polling link state and hardware monitor
+ * @reset: Reset the controller hardware and possibly the PHY.  This will
+ *	be called while the controller is uninitialised.
+ * @probe_port: Probe the MAC and PHY
+ * @remove_port: Free resources allocated by probe_port()
+ * @prepare_flush: Prepare the hardware for flushing the DMA queues
+ * @update_stats: Update statistics not provided by event handling
+ * @start_stats: Start the regular fetching of statistics
+ * @stop_stats: Stop the regular fetching of statistics
+ * @set_id_led: Set state of identifying LED or revert to automatic function
+ * @push_irq_moderation: Apply interrupt moderation value
+ * @push_multicast_hash: Apply multicast hash table
+ * @reconfigure_port: Push loopback/power/txdis changes to the MAC and PHY
+ * @get_wol: Get WoL configuration from driver state
+ * @set_wol: Push WoL configuration to the NIC
+ * @resume_wol: Synchronise WoL state between driver and MC (e.g. after resume)
+ * @test_registers: Test read/write functionality of control registers
+ * @test_memory: Test read/write functionality of memory blocks, using
+ *	the given test pattern generator
+ * @test_nvram: Test validity of NVRAM contents
+ * @default_mac_ops: efx_mac_operations to set at startup
+ * @revision: Hardware architecture revision
+ * @dl_revision: Driverlink revision string
  * @mem_map_size: Memory BAR mapped size
  * @txd_ptr_tbl_base: TX descriptor ring base address
  * @rxd_ptr_tbl_base: RX descriptor ring base address
  * @buf_tbl_base: Buffer table base address
  * @evq_ptr_tbl_base: Event queue pointer table base address
  * @evq_rptr_tbl_base: Event queue read-pointer table base address
- * @txd_ring_mask: TX descriptor ring size - 1 (must be a power of two - 1)
- * @rxd_ring_mask: RX descriptor ring size - 1 (must be a power of two - 1)
- * @evq_size: Event queue size (must be a power of two)
  * @max_dma_mask: Maximum possible DMA mask
- * @tx_dma_mask: TX DMA mask
- * @bug5391_mask: Address mask for bug 5391 workaround
- * @rx_xoff_thresh: RX FIFO XOFF watermark (bytes)
- * @rx_xon_thresh: RX FIFO XON watermark (bytes)
- * @rx_buffer_padding: Padding added to each RX buffer
+ * @rx_buffer_hash_size: Size of hash at start of RX buffer
+ * @rx_buffer_padding: Size of padding at end of RX buffer
  * @max_interrupt_mode: Highest capability interrupt mode supported
  *	from &enum efx_init_mode.
  * @phys_addr_channels: Number of channels with physically addressed
  *	descriptors
+ * @resources: Resources to be shared via driverlink (copied and
+ *	updated as efx_nic::resources)
+ * @offload_features: net_device feature flags for protocol offload
+ *	features implemented in hardware
+ * @reset_world_flags: Flags for additional components covered by
+ *	reset method RESET_TYPE_WORLD
  */
 struct efx_nic_type {
-	unsigned int mem_bar;
+	int (*probe)(struct efx_nic *efx);
+	void (*remove)(struct efx_nic *efx);
+	int (*init)(struct efx_nic *efx);
+	void (*fini)(struct efx_nic *efx);
+	void (*monitor)(struct efx_nic *efx);
+	int (*reset)(struct efx_nic *efx, enum reset_type method);
+	int (*probe_port)(struct efx_nic *efx);
+	void (*remove_port)(struct efx_nic *efx);
+	void (*prepare_flush)(struct efx_nic *efx);
+	void (*update_stats)(struct efx_nic *efx);
+	void (*start_stats)(struct efx_nic *efx);
+	void (*stop_stats)(struct efx_nic *efx);
+	void (*set_id_led)(struct efx_nic *efx, enum efx_led_mode mode);
+	void (*push_irq_moderation)(struct efx_channel *channel);
+	void (*push_multicast_hash)(struct efx_nic *efx);
+	int (*reconfigure_port)(struct efx_nic *efx);
+	void (*get_wol)(struct efx_nic *efx, struct ethtool_wolinfo *wol);
+	int (*set_wol)(struct efx_nic *efx, u32 type);
+	void (*resume_wol)(struct efx_nic *efx);
+	int (*test_registers)(struct efx_nic *efx);
+	int (*test_memory)(struct efx_nic *efx,
+			   void (*pattern)(unsigned, efx_qword_t *, int, int),
+			   int a, int b);
+	int (*test_nvram)(struct efx_nic *efx);
+	struct efx_mac_operations *default_mac_ops;
+
+	int revision;
+	const char *dl_revision;
 	unsigned int mem_map_size;
 	unsigned int txd_ptr_tbl_base;
 	unsigned int rxd_ptr_tbl_base;
 	unsigned int buf_tbl_base;
 	unsigned int evq_ptr_tbl_base;
 	unsigned int evq_rptr_tbl_base;
-
-	unsigned int txd_ring_mask;
-	unsigned int rxd_ring_mask;
-	unsigned int evq_size;
 	u64 max_dma_mask;
-	unsigned int tx_dma_mask;
-	unsigned bug5391_mask;
-
-	int rx_xoff_thresh;
-	int rx_xon_thresh;
+	unsigned int rx_buffer_hash_size;
 	unsigned int rx_buffer_padding;
 	unsigned int max_interrupt_mode;
 	unsigned int phys_addr_channels;
+	struct efx_dl_falcon_resources resources;
+	struct efx_dl_hash_insertion dl_hash_insertion;
+	unsigned long offload_features;
+	u32 reset_world_flags;
 };
 
 /**************************************************************************
@@ -928,44 +1217,72 @@ struct efx_nic_type {
  *
  *************************************************************************/
 
+static inline struct efx_channel *
+efx_get_channel(struct efx_nic *efx, unsigned index)
+{
+	EFX_BUG_ON_PARANOID(index >= efx->n_channels);
+	return efx->channel[index];
+}
+
 /* Iterate over all used channels */
 #define efx_for_each_channel(_channel, _efx)				\
-	for (_channel = &_efx->channel[0];				\
-	     _channel < &_efx->channel[EFX_MAX_CHANNELS];		\
-	     _channel++)						\
-		if (!_channel->used_flags)				\
-			continue;					\
-		else
+	for (_channel = (_efx)->channel[0];				\
+	     _channel;							\
+	     _channel = (_channel->channel + 1 < (_efx)->n_channels) ?	\
+		     (_efx)->channel[_channel->channel + 1] : NULL)
 
-/* Iterate over all used TX queues */
-#define efx_for_each_tx_queue(_tx_queue, _efx)				\
-	for (_tx_queue = &_efx->tx_queue[0];				\
-	     _tx_queue < &_efx->tx_queue[EFX_TX_QUEUE_COUNT];		\
-	     _tx_queue++)
+extern struct efx_tx_queue *
+efx_get_tx_queue(struct efx_nic *efx, unsigned index, unsigned type);
+
+static inline struct efx_tx_queue *
+efx_channel_get_tx_queue(struct efx_channel *channel, unsigned type)
+{
+	struct efx_tx_queue *tx_queue = channel->tx_queue;
+	EFX_BUG_ON_PARANOID(type >= EFX_TXQ_TYPES);
+	return tx_queue->channel ? tx_queue + type : NULL;
+}
 
 /* Iterate over all TX queues belonging to a channel */
 #define efx_for_each_channel_tx_queue(_tx_queue, _channel)		\
-	for (_tx_queue = &_channel->efx->tx_queue[0];			\
-	     _tx_queue < &_channel->efx->tx_queue[EFX_TX_QUEUE_COUNT];	\
-	     _tx_queue++)						\
-		if (_tx_queue->channel != _channel)			\
-			continue;					\
-		else
+	for (_tx_queue = efx_channel_get_tx_queue(channel, 0);		\
+	     _tx_queue && _tx_queue < (_channel)->tx_queue + EFX_TXQ_TYPES; \
+	     _tx_queue++)
 
-/* Iterate over all used RX queues */
-#define efx_for_each_rx_queue(_rx_queue, _efx)				\
-	for (_rx_queue = &_efx->rx_queue[0];				\
-	     _rx_queue < &_efx->rx_queue[_efx->n_rx_queues];		\
-	     _rx_queue++)
+static inline struct efx_rx_queue *
+efx_get_rx_queue(struct efx_nic *efx, unsigned index)
+{
+	EFX_BUG_ON_PARANOID(index >= efx->n_rx_channels);
+	return &efx->channel[index]->rx_queue;
+}
+
+static inline struct efx_rx_queue *
+efx_channel_get_rx_queue(struct efx_channel *channel)
+{
+	return channel->channel < channel->efx->n_rx_channels ?
+		&channel->rx_queue : NULL;
+}
 
 /* Iterate over all RX queues belonging to a channel */
 #define efx_for_each_channel_rx_queue(_rx_queue, _channel)		\
-	for (_rx_queue = &_channel->efx->rx_queue[_channel->channel];	\
+	for (_rx_queue = efx_channel_get_rx_queue(channel);		\
 	     _rx_queue;							\
-	     _rx_queue = NULL)						\
-		if (_rx_queue->channel != _channel)			\
-			continue;					\
-		else
+	     _rx_queue = NULL)
+
+/* Name formats */
+#define EFX_CHANNEL_NAME(_channel) "chan%d", (_channel)->channel
+#define EFX_TX_QUEUE_NAME(_tx_queue) "txq%d", (_tx_queue)->queue
+#define EFX_RX_QUEUE_NAME(_rx_queue) "rxq%d", efx_rx_queue_index(_rx_queue)
+
+static inline struct efx_channel *
+efx_rx_queue_channel(struct efx_rx_queue *rx_queue)
+{
+	return container_of(rx_queue, struct efx_channel, rx_queue);
+}
+
+static inline int efx_rx_queue_index(struct efx_rx_queue *rx_queue)
+{
+	return efx_rx_queue_channel(rx_queue)->channel;
+}
 
 /* Returns a pointer to the specified receive buffer in the RX
  * descriptor queue.
@@ -973,7 +1290,7 @@ static inline struct efx_rx_buffer *efx_
 static inline struct efx_rx_buffer *efx_rx_buffer(struct efx_rx_queue *rx_queue,
 						  unsigned int index)
 {
-	return (&rx_queue->buffer[index]);
+	return &rx_queue->buffer[index];
 }
 
 /* Set bit in a little-endian bitfield */
@@ -998,7 +1315,7 @@ static inline void clear_bit_le(unsigned
  * that the net driver will program into the MAC as the maximum frame
  * length.
  *
- * The 10G MAC used in Falcon requires 8-byte alignment on the frame
+ * The 10G MAC requires 8-byte alignment on the frame
  * length, so we round up to the nearest 8.
  *
  * Re-clocking by the XGXS on RX can reduce an IPG to 32 bits (half an
diff -r 5b3d4d3c1166 drivers/net/sfc/nic.c
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/drivers/net/sfc/nic.c	Tue Nov 09 10:06:27 2010 +0000
@@ -0,0 +1,2379 @@
+/****************************************************************************
+ * Driver for Solarflare Solarstorm network controllers and boards
+ * Copyright 2005-2006 Fen Systems Ltd.
+ * Copyright 2006-2009 Solarflare Communications Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 as published
+ * by the Free Software Foundation, incorporated herein by reference.
+ */
+
+#include <linux/bitops.h>
+#include <linux/delay.h>
+#include <linux/pci.h>
+#include <linux/module.h>
+#include <linux/seq_file.h>
+#include "net_driver.h"
+#include "bitfield.h"
+#include "efx.h"
+#include "nic.h"
+#include "regs.h"
+#include "io.h"
+#include "workarounds.h"
+
+/**************************************************************************
+ *
+ * Configurable values
+ *
+ **************************************************************************
+ */
+
+/* Specify the size of the RX descriptor cache.
+ * Values 16, 32 and 64 are supported (8 won't work).
+ */
+static int rx_desc_cache_size = 64;
+
+/* This is set to 16 for a good reason.  In summary, if larger than
+ * 16, the descriptor cache holds more than a default socket
+ * buffer's worth of packets (for UDP we can only have at most one
+ * socket buffer's worth outstanding).  This combined with the fact
+ * that we only get 1 TX event per descriptor cache means the NIC
+ * goes idle.
+ * 16 gives us up to 256 TXQs on Falcon B in internal-SRAM mode,
+ * and up to 512 on Falcon A.
+ */
+static int tx_desc_cache_size = 16;
+
+
+#ifdef EFX_NOT_UPSTREAM
+
+unsigned int efx_nic_no_resets;
+module_param_named(no_resets, efx_nic_no_resets, uint, 0444);
+MODULE_PARM_DESC(no_resets, "Never ever reset the NIC HW");
+
+int efx_ignore_nvconfig;
+module_param(efx_ignore_nvconfig, int, 0644);
+MODULE_PARM_DESC(efx_ignore_nvconfig, "Ignore config from flash/EEPROM");
+
+module_param(rx_desc_cache_size, int, 0644);
+MODULE_PARM_DESC(rx_desc_cache_size, "Set RX descriptor cache size");
+
+module_param(tx_desc_cache_size, int, 0644);
+MODULE_PARM_DESC(tx_desc_cache_size, "Set TX descriptor cache size");
+
+static unsigned target_num_vis;
+module_param_named(num_vis, target_num_vis, uint, 0644);
+MODULE_PARM_DESC(num_vis, "Set number of VIs");
+
+#endif /* EFX_NOT_UPSTREAM */
+
+/* RX FIFO XOFF watermark
+ *
+ * When the amount of the RX FIFO increases used increases past this
+ * watermark send XOFF. Only used if RX flow control is enabled (ethtool -A)
+ * This also has an effect on RX/TX arbitration
+ */
+int efx_nic_rx_xoff_thresh = -1;
+module_param_named(rx_xoff_thresh_bytes, efx_nic_rx_xoff_thresh, int, 0644);
+MODULE_PARM_DESC(rx_xoff_thresh_bytes, "RX fifo XOFF threshold");
+
+/* RX FIFO XON watermark
+ *
+ * When the amount of the RX FIFO used decreases below this
+ * watermark send XON. Only used if TX flow control is enabled (ethtool -A)
+ * This also has an effect on RX/TX arbitration
+ */
+int efx_nic_rx_xon_thresh = -1;
+module_param_named(rx_xon_thresh_bytes, efx_nic_rx_xon_thresh, int, 0644);
+MODULE_PARM_DESC(rx_xon_thresh_bytes, "RX fifo XON threshold");
+
+/* If EFX_MAX_INT_ERRORS internal errors occur within
+ * EFX_INT_ERROR_EXPIRE seconds, we consider the NIC broken and
+ * disable it.
+ */
+#define EFX_INT_ERROR_EXPIRE 3600
+#define EFX_MAX_INT_ERRORS 5
+
+/* We poll for events every FLUSH_INTERVAL ms, and check FLUSH_POLL_COUNT times
+ */
+#define EFX_FLUSH_INTERVAL 10
+#define EFX_FLUSH_POLL_COUNT 100
+
+/* Depth of RX flush request fifo */
+#define EFX_RX_FLUSH_COUNT 4
+
+/* Generated event code for efx_generate_test_event() */
+#define EFX_CHANNEL_MAGIC_TEST(_channel)	\
+	(0x00010100 + (_channel)->channel)
+
+/* Generated event code for efx_generate_fill_event() */
+#define EFX_CHANNEL_MAGIC_FILL(_channel)	\
+	(0x00010200 + (_channel)->channel)
+
+/**************************************************************************
+ *
+ * Solarstorm hardware access
+ *
+ **************************************************************************/
+
+/* Write to a buffer table entry, locking as appropriate. */
+static inline void efx_write_buf_tbl(struct efx_nic *efx, efx_qword_t *value,
+				     unsigned int index)
+{
+	efx_sram_writeq(efx, efx->membase + efx->type->buf_tbl_base,
+			value, index);
+}
+
+/* Read the current event from the event queue */
+static inline efx_qword_t *efx_event(struct efx_channel *channel,
+				     unsigned int index)
+{
+	return ((efx_qword_t *) (channel->eventq.addr)) + index;
+}
+
+/* See if an event is present
+ *
+ * We check both the high and low dword of the event for all ones.  We
+ * wrote all ones when we cleared the event, and no valid event can
+ * have all ones in either its high or low dwords.  This approach is
+ * robust against reordering.
+ *
+ * Note that using a single 64-bit comparison is incorrect; even
+ * though the CPU read will be atomic, the DMA write may not be.
+ */
+static inline int efx_event_present(efx_qword_t *event)
+{
+	return !(EFX_DWORD_IS_ALL_ONES(event->dword[0]) |
+		  EFX_DWORD_IS_ALL_ONES(event->dword[1]));
+}
+
+#ifdef EFX_NOT_UPSTREAM
+
+static void efx_write_scratch(struct efx_nic *efx, u32 value,
+			      unsigned int addr)
+{
+	efx_oword_t scratch;
+
+	EFX_POPULATE_OWORD_1(scratch, FRF_AZ_DRIVER_DW0, value);
+	efx_writeo(efx, &scratch, addr);
+}
+
+/* Verify that the specified scratch register contains the expected value */
+static int efx_verify_scratch(struct efx_nic *efx, u32 expected,
+			      unsigned int reg)
+{
+	efx_oword_t scratch;
+	u32 readback;
+
+	efx_reado(efx, &scratch, reg);
+	readback = EFX_OWORD_FIELD(scratch, FRF_AZ_DRIVER_DW0);
+	if (readback != expected) {
+		netif_err(efx, hw, efx->net_dev,
+			  "scratch register %x failure: "
+			  "expected %08x got %08x\n",
+			  reg, expected, readback);
+		return -EIO;
+	}
+
+	return 0;
+}
+
+/*
+ * Test BIU by writing to scratch registers and reading back the
+ * contents.
+ *
+ * As well as testing operation of the BIU, this routine also flushes
+ * any BIU cache, so can be used as a component of other verify
+ * operations.
+ */
+int efx_nic_test_biu(struct efx_nic *efx)
+{
+	unsigned int magic_a = 0x01234567;
+	unsigned int magic_b = 0xfedcba98;
+	int rc;
+
+	/* Write magic values to scratch registers 0 and 1, then
+	 * verify that the values were written correctly.  Interleave
+	 * the accesses to ensure that the BIU is not just reading
+	 * back the cached value that was last written.
+	 */
+	efx_write_scratch(efx, magic_a, FR_AZ_DRIVER);
+	efx_write_scratch(efx, magic_b, FR_AZ_DRIVER + FR_AZ_DRIVER_STEP);
+	rc = efx_verify_scratch(efx, magic_a, FR_AZ_DRIVER);
+	if (rc)
+		return rc;
+	rc = efx_verify_scratch(efx, magic_b,
+				   FR_AZ_DRIVER + FR_AZ_DRIVER_STEP);
+	if (rc)
+		return rc;
+
+	/* Perform the same test, with the values swapped.  This
+	 * ensures that subsequent tests don't start with the correct
+	 * values already written into the scratch registers.
+	 */
+	efx_write_scratch(efx, magic_b, FR_AZ_DRIVER);
+	efx_write_scratch(efx, magic_a, FR_AZ_DRIVER + FR_AZ_DRIVER_STEP);
+	rc = efx_verify_scratch(efx, magic_b, FR_AZ_DRIVER);
+	if (rc)
+		return rc;
+	rc = efx_verify_scratch(efx, magic_a,
+				FR_AZ_DRIVER + FR_AZ_DRIVER_STEP);
+	if (rc)
+		return rc;
+
+	return 0;
+}
+
+/* Read a buffer table entry, locking as appropriate. */
+static inline void efx_read_buf_tbl(struct efx_nic *efx, efx_qword_t *value,
+				    unsigned int index)
+{
+	efx_sram_readq(efx, efx->membase + efx->type->buf_tbl_base,
+		       value, index);
+}
+
+#ifndef EFX_USE_IO_BAR
+/*
+ * Verified write to buffer table
+ *
+ * This writes a value to buffer table and verifies that the value was
+ * correctly written.
+ */
+static int efx_write_buf_tbl_verify(struct efx_nic *efx,
+				    efx_qword_t *value, unsigned int index)
+{
+	efx_qword_t verify;
+	int rc;
+
+	efx_write_buf_tbl(efx, value, index);
+
+	/* Flush BIU cache */
+	rc = efx_nic_test_biu(efx);
+	if (rc)
+		return rc;
+
+	efx_read_buf_tbl(efx, &verify, index);
+	if (memcmp(&verify, value, sizeof(verify)) != 0) {
+		netif_err(efx, hw, efx->net_dev,
+			  "SRAM index %x failure: wrote " EFX_QWORD_FMT
+			  " got " EFX_QWORD_FMT "\n", index,
+			  EFX_QWORD_VAL(*value), EFX_QWORD_VAL(verify));
+		return -EIO;
+	}
+
+	return 0;
+}
+#endif /* EFX_USE_IO_BAR */
+
+#endif /* EFX_NOT_UPSTREAM */
+
+static bool efx_masked_compare_oword(const efx_oword_t *a, const efx_oword_t *b,
+				     const efx_oword_t *mask)
+{
+	return ((a->u64[0] ^ b->u64[0]) & mask->u64[0]) ||
+		((a->u64[1] ^ b->u64[1]) & mask->u64[1]);
+}
+
+int efx_nic_test_registers(struct efx_nic *efx,
+			   const struct efx_nic_register_test *regs,
+			   size_t n_regs)
+{
+	unsigned address = 0, i, j;
+	efx_oword_t mask, imask, original, reg, buf;
+
+	/* Falcon should be in loopback to isolate the XMAC from the PHY */
+	WARN_ON(!LOOPBACK_INTERNAL(efx));
+
+	for (i = 0; i < n_regs; ++i) {
+		address = regs[i].address;
+		mask = imask = regs[i].mask;
+		EFX_INVERT_OWORD(imask);
+
+		efx_reado(efx, &original, address);
+
+		/* bit sweep on and off */
+		for (j = 0; j < 128; j++) {
+			if (!EFX_EXTRACT_OWORD32(mask, j, j))
+				continue;
+
+			/* Test this testable bit can be set in isolation */
+			EFX_AND_OWORD(reg, original, mask);
+			EFX_SET_OWORD32(reg, j, j, 1);
+
+			efx_writeo(efx, &reg, address);
+			efx_reado(efx, &buf, address);
+
+			if (efx_masked_compare_oword(&reg, &buf, &mask))
+				goto fail;
+
+			/* Test this testable bit can be cleared in isolation */
+			EFX_OR_OWORD(reg, original, mask);
+			EFX_SET_OWORD32(reg, j, j, 0);
+
+			efx_writeo(efx, &reg, address);
+			efx_reado(efx, &buf, address);
+
+			if (efx_masked_compare_oword(&reg, &buf, &mask))
+				goto fail;
+		}
+
+		efx_writeo(efx, &original, address);
+	}
+
+	return 0;
+
+fail:
+	netif_err(efx, hw, efx->net_dev,
+		  "wrote "EFX_OWORD_FMT" read "EFX_OWORD_FMT
+		  " at address 0x%x mask "EFX_OWORD_FMT"\n", EFX_OWORD_VAL(reg),
+		  EFX_OWORD_VAL(buf), address, EFX_OWORD_VAL(mask));
+	return -EIO;
+}
+
+int efx_nic_test_table(struct efx_nic *efx,
+		       const struct efx_nic_table_test *table,
+		       void (*pattern)(unsigned, efx_qword_t *, int, int),
+		       int a, int b)
+{
+	efx_oword_t reg, buf;
+	int index;
+
+	/* write */
+	for (index = 0; index < table->rows; index += table->step) {
+		pattern(2 * index + 0, &reg.qword[0], a, b);
+		pattern(2 * index + 1, &reg.qword[1], a, b);
+		reg.u64[0] &= table->mask.u64[0];
+		reg.u64[1] &= table->mask.u64[1];
+
+		efx_writeo_table(efx, &reg, table->address, index);
+	}
+
+	/* verify */
+	for (index = 0; index < table->rows; index += table->step) {
+		pattern(2 * index + 0, &reg.qword[0], a, b);
+		pattern(2 * index + 1, &reg.qword[1], a, b);
+		reg.u64[0] &= table->mask.u64[0];
+		reg.u64[1] &= table->mask.u64[1];
+
+		efx_reado_table(efx, &buf, table->address, index);
+		if (memcmp(&reg, &buf, sizeof(reg))) {
+			netif_err(efx, hw, efx->net_dev,
+				  "table test failed at address 0x%x"
+				  " index 0x%x. wrote "EFX_OWORD_FMT
+				  " read "EFX_OWORD_FMT"\n",
+				  table->address, index,
+				  EFX_OWORD_VAL(reg), EFX_OWORD_VAL(buf));
+			return -EIO;
+		}
+	}
+
+	return 0;
+}
+
+/**************************************************************************
+ *
+ * Special buffer handling
+ * Special buffers are used for event queues and the TX and RX
+ * descriptor rings.
+ *
+ *************************************************************************/
+
+/*
+ * Initialise a special buffer
+ *
+ * This will define a buffer (previously allocated via
+ * efx_alloc_special_buffer()) in the buffer table, allowing
+ * it to be used for event queues, descriptor rings etc.
+ */
+static void
+efx_init_special_buffer(struct efx_nic *efx, struct efx_special_buffer *buffer)
+{
+	efx_qword_t buf_desc;
+	int index;
+	dma_addr_t dma_addr;
+	int i;
+
+	EFX_BUG_ON_PARANOID(!buffer->addr);
+
+	/* Write buffer descriptors to NIC */
+	for (i = 0; i < buffer->entries; i++) {
+		index = buffer->index + i;
+		dma_addr = buffer->dma_addr + (i * 4096);
+		netif_dbg(efx, probe, efx->net_dev,
+			  "mapping special buffer %d at %llx\n",
+			  index, (unsigned long long)dma_addr);
+		EFX_POPULATE_QWORD_3(buf_desc,
+				     FRF_AZ_BUF_ADR_REGION, 0,
+				     FRF_AZ_BUF_ADR_FBUF, dma_addr >> 12,
+				     FRF_AZ_BUF_OWNER_ID_FBUF, 0);
+#if !defined(EFX_NOT_UPSTREAM) || defined(EFX_USE_IO_BAR)
+		efx_write_buf_tbl(efx, &buf_desc, index);
+#else
+		if (efx_write_buf_tbl_verify(efx, &buf_desc, index))
+			efx_schedule_reset(efx, RESET_TYPE_DISABLE);
+#endif
+	}
+}
+
+/* Unmaps a buffer and clears the buffer table entries */
+static void
+efx_fini_special_buffer(struct efx_nic *efx, struct efx_special_buffer *buffer)
+{
+	efx_oword_t buf_tbl_upd;
+	unsigned int start = buffer->index;
+	unsigned int end = (buffer->index + buffer->entries - 1);
+
+	if (!buffer->entries)
+		return;
+
+	netif_dbg(efx, hw, efx->net_dev, "unmapping special buffers %d-%d\n",
+		  buffer->index, buffer->index + buffer->entries - 1);
+
+	EFX_POPULATE_OWORD_4(buf_tbl_upd,
+			     FRF_AZ_BUF_UPD_CMD, 0,
+			     FRF_AZ_BUF_CLR_CMD, 1,
+			     FRF_AZ_BUF_CLR_END_ID, end,
+			     FRF_AZ_BUF_CLR_START_ID, start);
+	efx_writeo(efx, &buf_tbl_upd, FR_AZ_BUF_TBL_UPD);
+}
+
+/*
+ * Allocate a new special buffer
+ *
+ * This allocates memory for a new buffer, clears it and allocates a
+ * new buffer ID range.  It does not write into the buffer table.
+ *
+ * This call will allocate 4KB buffers, since 8KB buffers can't be
+ * used for event queues and descriptor rings.
+ */
+static int efx_alloc_special_buffer(struct efx_nic *efx,
+				    struct efx_special_buffer *buffer,
+				    unsigned int count, unsigned int reserve)
+{
+	unsigned int bytes;
+
+	bytes = ALIGN(count * sizeof(efx_qword_t), EFX_BUF_SIZE);
+	buffer->addr = dma_alloc_coherent(&efx->pci_dev->dev, bytes,
+					  &buffer->dma_addr, GFP_KERNEL);
+	if (!buffer->addr)
+		return -ENOMEM;
+	buffer->len = bytes;
+	buffer->entries = bytes / EFX_BUF_SIZE;
+	BUG_ON(buffer->dma_addr & (EFX_BUF_SIZE - 1));
+	buffer->index = efx->resources.buffer_table_min;
+
+	/* All zeros is a potentially valid event so memset to 0xff */
+	memset(buffer->addr, 0xff, bytes);
+
+	/* Select new buffer ID */
+	BUG_ON(count > reserve);
+	BUG_ON(!IS_ALIGNED(reserve * sizeof(efx_qword_t), EFX_BUF_SIZE));
+	efx->resources.buffer_table_min +=
+		reserve * sizeof(efx_qword_t) / EFX_BUF_SIZE;
+
+	netif_dbg(efx, hw, efx->net_dev,
+		  "allocated special buffers %d-%d..%d at %llx+%x "
+		  "(virt %p phys %llx)\n", buffer->index,
+		  buffer->index + buffer->entries - 1,
+		  efx->resources.buffer_table_min - 1,
+		  (u64)buffer->dma_addr, bytes,
+		  buffer->addr, (u64)virt_to_phys(buffer->addr));
+
+	return 0;
+}
+
+static void
+efx_free_special_buffer(struct efx_nic *efx, struct efx_special_buffer *buffer)
+{
+	if (!buffer->addr)
+		return;
+
+	netif_dbg(efx, hw, efx->net_dev,
+		  "deallocating special buffers %d-%d at %llx+%x "
+		  "(virt %p phys %llx)\n", buffer->index,
+		  buffer->index + buffer->entries - 1,
+		  (u64)buffer->dma_addr, buffer->len,
+		  buffer->addr, (u64)virt_to_phys(buffer->addr));
+
+	dma_free_coherent(&efx->pci_dev->dev, buffer->len, buffer->addr,
+			  buffer->dma_addr);
+	buffer->addr = NULL;
+	buffer->entries = 0;
+}
+
+/**************************************************************************
+ *
+ * Generic buffer handling
+ * These buffers are used for interrupt status and MAC stats
+ *
+ **************************************************************************/
+
+int efx_nic_alloc_buffer(struct efx_nic *efx, struct efx_buffer *buffer,
+			 unsigned int len)
+{
+	buffer->addr = pci_alloc_consistent(efx->pci_dev, len,
+					    &buffer->dma_addr);
+	if (!buffer->addr)
+		return -ENOMEM;
+	buffer->len = len;
+	memset(buffer->addr, 0, len);
+	return 0;
+}
+
+void efx_nic_free_buffer(struct efx_nic *efx, struct efx_buffer *buffer)
+{
+	if (buffer->addr) {
+		pci_free_consistent(efx->pci_dev, buffer->len,
+				    buffer->addr, buffer->dma_addr);
+		buffer->addr = NULL;
+	}
+}
+
+/**************************************************************************
+ *
+ * TX path
+ *
+ **************************************************************************/
+
+/* Returns a pointer to the specified transmit descriptor in the TX
+ * descriptor queue belonging to the specified channel.
+ */
+static inline efx_qword_t *
+efx_tx_desc(struct efx_tx_queue *tx_queue, unsigned int index)
+{
+	return ((efx_qword_t *) (tx_queue->txd.addr)) + index;
+}
+
+/* This writes to the TX_DESC_WPTR; write pointer for TX descriptor ring */
+static inline void efx_notify_tx_desc(struct efx_tx_queue *tx_queue)
+{
+	unsigned write_ptr;
+	efx_dword_t reg;
+
+	write_ptr = tx_queue->write_count & tx_queue->ptr_mask;
+	EFX_POPULATE_DWORD_1(reg, FRF_AZ_TX_DESC_WPTR_DWORD, write_ptr);
+	efx_writed_page(tx_queue->efx, &reg,
+			FR_AZ_TX_DESC_UPD_DWORD_P0, tx_queue->queue);
+}
+
+
+/* For each entry inserted into the software descriptor ring, create a
+ * descriptor in the hardware TX descriptor ring (in host memory), and
+ * write a doorbell.
+ */
+#if defined(EFX_USE_KCOMPAT) && defined(EFX_USE_FASTCALL)
+void fastcall efx_nic_push_buffers(struct efx_tx_queue *tx_queue)
+#else
+void efx_nic_push_buffers(struct efx_tx_queue *tx_queue)
+#endif
+{
+	struct efx_tx_buffer *buffer;
+	efx_qword_t *txd;
+	unsigned write_ptr;
+
+	BUG_ON(tx_queue->write_count == tx_queue->insert_count);
+
+	do {
+		write_ptr = tx_queue->write_count & tx_queue->ptr_mask;
+		buffer = &tx_queue->buffer[write_ptr];
+		txd = efx_tx_desc(tx_queue, write_ptr);
+		++tx_queue->write_count;
+
+		/* Create TX descriptor ring entry */
+		EFX_POPULATE_QWORD_4(*txd,
+				     FSF_AZ_TX_KER_CONT, buffer->continuation,
+				     FSF_AZ_TX_KER_BYTE_COUNT, buffer->len,
+				     FSF_AZ_TX_KER_BUF_REGION, 0,
+				     FSF_AZ_TX_KER_BUF_ADDR, buffer->dma_addr);
+	} while (tx_queue->write_count != tx_queue->insert_count);
+
+	wmb(); /* Ensure descriptors are written before they are fetched */
+	efx_notify_tx_desc(tx_queue);
+}
+
+/* Allocate hardware resources for a TX queue */
+int efx_nic_probe_tx(struct efx_tx_queue *tx_queue)
+{
+	struct efx_nic *efx = tx_queue->efx;
+	unsigned entries;
+	int rc;
+
+	entries = tx_queue->ptr_mask + 1;
+	rc = efx_alloc_special_buffer(efx, &tx_queue->txd,
+				      entries, EFX_MAX_DMAQ_SIZE);
+	if (rc)
+		return rc;
+
+	efx->resources.txq_min = max(efx->resources.txq_min,
+				     (unsigned)tx_queue->queue + 1);
+
+	return 0;
+}
+
+void efx_nic_init_tx(struct efx_tx_queue *tx_queue)
+{
+	efx_oword_t tx_desc_ptr;
+	struct efx_nic *efx = tx_queue->efx;
+
+	tx_queue->flushed = FLUSH_NONE;
+
+	/* Pin TX descriptor ring */
+	efx_init_special_buffer(efx, &tx_queue->txd);
+
+	/* Push TX descriptor ring to card */
+	EFX_POPULATE_OWORD_10(tx_desc_ptr,
+			      FRF_AZ_TX_DESCQ_EN, 1,
+			      FRF_AZ_TX_ISCSI_DDIG_EN, 0,
+			      FRF_AZ_TX_ISCSI_HDIG_EN, 0,
+			      FRF_AZ_TX_DESCQ_BUF_BASE_ID, tx_queue->txd.index,
+			      FRF_AZ_TX_DESCQ_EVQ_ID,
+			      tx_queue->channel->channel,
+			      FRF_AZ_TX_DESCQ_OWNER_ID, 0,
+			      FRF_AZ_TX_DESCQ_LABEL, tx_queue->queue,
+			      FRF_AZ_TX_DESCQ_SIZE,
+			      __ffs(tx_queue->txd.entries),
+			      FRF_AZ_TX_DESCQ_TYPE, 0,
+			      FRF_BZ_TX_NON_IP_DROP_DIS, 1);
+
+	if (efx_nic_rev(efx) >= EFX_REV_FALCON_B0) {
+		int csum = tx_queue->queue & EFX_TXQ_TYPE_OFFLOAD;
+		EFX_SET_OWORD_FIELD(tx_desc_ptr, FRF_BZ_TX_IP_CHKSM_DIS, !csum);
+		EFX_SET_OWORD_FIELD(tx_desc_ptr, FRF_BZ_TX_TCP_CHKSM_DIS,
+				    !csum);
+	}
+
+	efx_writeo_table(efx, &tx_desc_ptr, efx->type->txd_ptr_tbl_base,
+			 tx_queue->queue);
+
+	if (efx_nic_rev(efx) < EFX_REV_FALCON_B0) {
+		efx_oword_t reg;
+
+		/* Only 128 bits in this register */
+		BUILD_BUG_ON(EFX_MAX_TX_QUEUES > 128);
+
+		efx_reado(efx, &reg, FR_AA_TX_CHKSM_CFG);
+		if (tx_queue->queue & EFX_TXQ_TYPE_OFFLOAD)
+			clear_bit_le(tx_queue->queue, (void *)&reg);
+		else
+			set_bit_le(tx_queue->queue, (void *)&reg);
+		efx_writeo(efx, &reg, FR_AA_TX_CHKSM_CFG);
+	}
+}
+
+static void efx_flush_tx_queue(struct efx_tx_queue *tx_queue)
+{
+	struct efx_nic *efx = tx_queue->efx;
+	efx_oword_t tx_flush_descq;
+
+	tx_queue->flushed = FLUSH_PENDING;
+
+	/* Post a flush command */
+	EFX_POPULATE_OWORD_2(tx_flush_descq,
+			     FRF_AZ_TX_FLUSH_DESCQ_CMD, 1,
+			     FRF_AZ_TX_FLUSH_DESCQ, tx_queue->queue);
+	efx_writeo(efx, &tx_flush_descq, FR_AZ_TX_FLUSH_DESCQ);
+}
+
+void efx_nic_fini_tx(struct efx_tx_queue *tx_queue)
+{
+	struct efx_nic *efx = tx_queue->efx;
+	efx_oword_t tx_desc_ptr;
+
+	/* The queue should have been flushed */
+	WARN_ON(tx_queue->flushed != FLUSH_DONE);
+
+	/* Remove TX descriptor ring from card */
+	EFX_ZERO_OWORD(tx_desc_ptr);
+	efx_writeo_table(efx, &tx_desc_ptr, efx->type->txd_ptr_tbl_base,
+			 tx_queue->queue);
+
+	/* Unpin TX descriptor ring */
+	efx_fini_special_buffer(efx, &tx_queue->txd);
+}
+
+/* Free buffers backing TX queue */
+void efx_nic_remove_tx(struct efx_tx_queue *tx_queue)
+{
+	efx_free_special_buffer(tx_queue->efx, &tx_queue->txd);
+}
+
+/**************************************************************************
+ *
+ * RX path
+ *
+ **************************************************************************/
+
+/* Returns a pointer to the specified descriptor in the RX descriptor queue */
+static inline efx_qword_t *
+efx_rx_desc(struct efx_rx_queue *rx_queue, unsigned int index)
+{
+	return ((efx_qword_t *) (rx_queue->rxd.addr)) + index;
+}
+
+/* This creates an entry in the RX descriptor queue */
+static inline void
+efx_build_rx_desc(struct efx_rx_queue *rx_queue, unsigned index)
+{
+	struct efx_rx_buffer *rx_buf;
+	efx_qword_t *rxd;
+
+	rxd = efx_rx_desc(rx_queue, index);
+	rx_buf = efx_rx_buffer(rx_queue, index);
+	EFX_POPULATE_QWORD_3(*rxd,
+			     FSF_AZ_RX_KER_BUF_SIZE,
+			     rx_buf->len -
+			     rx_queue->efx->type->rx_buffer_padding,
+			     FSF_AZ_RX_KER_BUF_REGION, 0,
+			     FSF_AZ_RX_KER_BUF_ADDR, rx_buf->dma_addr);
+}
+
+/* This writes to the RX_DESC_WPTR register for the specified receive
+ * descriptor ring.
+ */
+#if defined(EFX_USE_KCOMPAT) && defined(EFX_USE_FASTCALL)
+void fastcall efx_nic_notify_rx_desc(struct efx_rx_queue *rx_queue)
+#else
+void efx_nic_notify_rx_desc(struct efx_rx_queue *rx_queue)
+#endif
+{
+	struct efx_nic *efx = rx_queue->efx;
+	efx_dword_t reg;
+	unsigned write_ptr;
+
+	while (rx_queue->notified_count != rx_queue->added_count) {
+		efx_build_rx_desc(
+			rx_queue,
+			rx_queue->notified_count & rx_queue->ptr_mask);
+		++rx_queue->notified_count;
+	}
+
+	wmb();
+	write_ptr = rx_queue->added_count & rx_queue->ptr_mask;
+	EFX_POPULATE_DWORD_1(reg, FRF_AZ_RX_DESC_WPTR_DWORD, write_ptr);
+	efx_writed_page(efx, &reg, FR_AZ_RX_DESC_UPD_DWORD_P0,
+			efx_rx_queue_index(rx_queue));
+}
+
+int efx_nic_probe_rx(struct efx_rx_queue *rx_queue)
+{
+	struct efx_nic *efx = rx_queue->efx;
+	unsigned entries;
+	int rc;
+
+	entries = rx_queue->ptr_mask + 1;
+	rc = efx_alloc_special_buffer(efx, &rx_queue->rxd,
+				      entries, EFX_MAX_DMAQ_SIZE);
+	if (rc)
+		return rc;
+
+	/* Increment the rxq_min counter */
+	efx->resources.rxq_min = max(efx->resources.rxq_min,
+				     (unsigned)efx_rx_queue_index(rx_queue) + 1);
+
+	return 0;
+}
+
+void efx_nic_init_rx(struct efx_rx_queue *rx_queue)
+{
+	efx_oword_t rx_desc_ptr;
+	struct efx_nic *efx = rx_queue->efx;
+	bool is_b0 = efx_nic_rev(efx) >= EFX_REV_FALCON_B0;
+	bool iscsi_digest_en = is_b0;
+
+	netif_dbg(efx, hw, efx->net_dev,
+		  "RX queue %d ring in special buffers %d-%d\n",
+		  efx_rx_queue_index(rx_queue), rx_queue->rxd.index,
+		  rx_queue->rxd.index + rx_queue->rxd.entries - 1);
+
+	rx_queue->flushed = FLUSH_NONE;
+
+	/* Pin RX descriptor ring */
+	efx_init_special_buffer(efx, &rx_queue->rxd);
+
+	/* Push RX descriptor ring to card */
+	EFX_POPULATE_OWORD_10(rx_desc_ptr,
+			      FRF_AZ_RX_ISCSI_DDIG_EN, iscsi_digest_en,
+			      FRF_AZ_RX_ISCSI_HDIG_EN, iscsi_digest_en,
+			      FRF_AZ_RX_DESCQ_BUF_BASE_ID, rx_queue->rxd.index,
+			      FRF_AZ_RX_DESCQ_EVQ_ID,
+			      efx_rx_queue_channel(rx_queue)->channel,
+			      FRF_AZ_RX_DESCQ_OWNER_ID, 0,
+			      FRF_AZ_RX_DESCQ_LABEL,
+			      efx_rx_queue_index(rx_queue),
+			      FRF_AZ_RX_DESCQ_SIZE,
+			      __ffs(rx_queue->rxd.entries),
+			      FRF_AZ_RX_DESCQ_TYPE, 0 /* kernel queue */ ,
+			      /* For >=B0 this is scatter so disable */
+			      FRF_AZ_RX_DESCQ_JUMBO, !is_b0,
+			      FRF_AZ_RX_DESCQ_EN, 1);
+	efx_writeo_table(efx, &rx_desc_ptr, efx->type->rxd_ptr_tbl_base,
+			 efx_rx_queue_index(rx_queue));
+}
+
+static void efx_flush_rx_queue(struct efx_rx_queue *rx_queue)
+{
+	struct efx_nic *efx = rx_queue->efx;
+	efx_oword_t rx_flush_descq;
+
+	rx_queue->flushed = FLUSH_PENDING;
+
+	/* Post a flush command */
+	EFX_POPULATE_OWORD_2(rx_flush_descq,
+			     FRF_AZ_RX_FLUSH_DESCQ_CMD, 1,
+			     FRF_AZ_RX_FLUSH_DESCQ,
+			     efx_rx_queue_index(rx_queue));
+	efx_writeo(efx, &rx_flush_descq, FR_AZ_RX_FLUSH_DESCQ);
+}
+
+void efx_nic_fini_rx(struct efx_rx_queue *rx_queue)
+{
+	efx_oword_t rx_desc_ptr;
+	struct efx_nic *efx = rx_queue->efx;
+
+	/* The queue should already have been flushed */
+	WARN_ON(rx_queue->flushed != FLUSH_DONE);
+
+	/* Remove RX descriptor ring from card */
+	EFX_ZERO_OWORD(rx_desc_ptr);
+	efx_writeo_table(efx, &rx_desc_ptr, efx->type->rxd_ptr_tbl_base,
+			 efx_rx_queue_index(rx_queue));
+
+	/* Unpin RX descriptor ring */
+	efx_fini_special_buffer(efx, &rx_queue->rxd);
+}
+
+/* Free buffers backing RX queue */
+void efx_nic_remove_rx(struct efx_rx_queue *rx_queue)
+{
+	efx_free_special_buffer(rx_queue->efx, &rx_queue->rxd);
+}
+
+/**************************************************************************
+ *
+ * Event queue processing
+ * Event queues are processed by per-channel tasklets.
+ *
+ **************************************************************************/
+
+/* Update a channel's event queue's read pointer (RPTR) register
+ *
+ * This writes the EVQ_RPTR_REG register for the specified channel's
+ * event queue.
+ */
+#if defined(EFX_USE_KCOMPAT) && defined(EFX_USE_FASTCALL)
+void fastcall efx_nic_eventq_read_ack(struct efx_channel *channel)
+#else
+void efx_nic_eventq_read_ack(struct efx_channel *channel)
+#endif
+{
+	efx_dword_t reg;
+	struct efx_nic *efx = channel->efx;
+
+	EFX_POPULATE_DWORD_1(reg, FRF_AZ_EVQ_RPTR, channel->eventq_read_ptr);
+	efx_writed_table(efx, &reg, efx->type->evq_rptr_tbl_base,
+			 channel->channel);
+}
+
+/* Use HW to insert a SW defined event */
+void efx_generate_event(struct efx_nic *efx, unsigned int evq,
+			efx_qword_t *event)
+{
+	efx_oword_t drv_ev_reg;
+
+	BUILD_BUG_ON(FRF_AZ_DRV_EV_DATA_LBN != 0 ||
+		     FRF_AZ_DRV_EV_DATA_WIDTH != 64);
+	drv_ev_reg.u32[0] = event->u32[0];
+	drv_ev_reg.u32[1] = event->u32[1];
+	drv_ev_reg.u32[2] = 0;
+	drv_ev_reg.u32[3] = 0;
+	EFX_SET_OWORD_FIELD(drv_ev_reg, FRF_AZ_DRV_EV_QID, evq);
+	efx_writeo(efx, &drv_ev_reg, FR_AZ_DRV_EV);
+}
+
+/* Handle a transmit completion event
+ *
+ * The NIC batches TX completion events; the message we receive is of
+ * the form "complete all TX events up to this index".
+ */
+static int
+efx_handle_tx_event(struct efx_channel *channel, efx_qword_t *event)
+{
+	unsigned int tx_ev_desc_ptr;
+	unsigned int tx_ev_q_label;
+	struct efx_tx_queue *tx_queue;
+	struct efx_nic *efx = channel->efx;
+	int tx_packets = 0;
+
+	if (likely(EFX_QWORD_FIELD(*event, FSF_AZ_TX_EV_COMP))) {
+		/* Transmit completion */
+		tx_ev_desc_ptr = EFX_QWORD_FIELD(*event, FSF_AZ_TX_EV_DESC_PTR);
+		tx_ev_q_label = EFX_QWORD_FIELD(*event, FSF_AZ_TX_EV_Q_LABEL);
+		tx_queue = efx_channel_get_tx_queue(
+			channel, tx_ev_q_label % EFX_TXQ_TYPES);
+		tx_packets = ((tx_ev_desc_ptr - tx_queue->read_count) &
+			      tx_queue->ptr_mask);
+		channel->irq_mod_score += tx_packets;
+		efx_xmit_done(tx_queue, tx_ev_desc_ptr);
+	} else if (EFX_QWORD_FIELD(*event, FSF_AZ_TX_EV_WQ_FF_FULL)) {
+		/* Rewrite the FIFO write pointer */
+		tx_ev_q_label = EFX_QWORD_FIELD(*event, FSF_AZ_TX_EV_Q_LABEL);
+		tx_queue = efx_channel_get_tx_queue(
+			channel, tx_ev_q_label % EFX_TXQ_TYPES);
+
+		if (efx_dev_registered(efx))
+			netif_tx_lock(efx->net_dev);
+		efx_notify_tx_desc(tx_queue);
+		if (efx_dev_registered(efx))
+			netif_tx_unlock(efx->net_dev);
+	} else if (EFX_QWORD_FIELD(*event, FSF_AZ_TX_EV_PKT_ERR) &&
+		   EFX_WORKAROUND_10727(efx)) {
+		netif_err(efx, tx_err, efx->net_dev,
+			  "TX DMA Q reports TX_EV_PKT_ERR.\n");
+		efx_schedule_reset(efx, RESET_TYPE_TX_DESC_FETCH);
+	} else {
+		EFX_FATAL(efx, hw, efx->net_dev,
+			  "channel %d unexpected TX event "
+			  EFX_QWORD_FMT"\n", channel->channel,
+			  EFX_QWORD_VAL(*event));
+	}
+
+	return tx_packets;
+}
+
+/* Detect errors included in the rx_evt_pkt_ok bit. */
+static void efx_handle_rx_not_ok(struct efx_rx_queue *rx_queue,
+				 const efx_qword_t *event,
+				 bool *rx_ev_pkt_ok,
+				 bool *discard)
+{
+	struct efx_channel *channel = efx_rx_queue_channel(rx_queue);
+	struct efx_nic *efx = rx_queue->efx;
+	bool rx_ev_buf_owner_id_err, rx_ev_ip_hdr_chksum_err;
+	bool rx_ev_tcp_udp_chksum_err, rx_ev_eth_crc_err;
+	bool rx_ev_frm_trunc, rx_ev_drib_nib, rx_ev_tobe_disc;
+	bool rx_ev_other_err, rx_ev_pause_frm;
+	bool rx_ev_ip_frag_err, rx_ev_hdr_type, rx_ev_mcast_pkt;
+	unsigned rx_ev_pkt_type;
+
+	rx_ev_hdr_type = EFX_QWORD_FIELD(*event, FSF_AZ_RX_EV_HDR_TYPE);
+	rx_ev_mcast_pkt = EFX_QWORD_FIELD(*event, FSF_AZ_RX_EV_MCAST_PKT);
+	rx_ev_tobe_disc = EFX_QWORD_FIELD(*event, FSF_AZ_RX_EV_TOBE_DISC);
+	rx_ev_pkt_type = EFX_QWORD_FIELD(*event, FSF_AZ_RX_EV_PKT_TYPE);
+	rx_ev_buf_owner_id_err = EFX_QWORD_FIELD(*event,
+						 FSF_AZ_RX_EV_BUF_OWNER_ID_ERR);
+	rx_ev_ip_frag_err = EFX_QWORD_FIELD(*event, FSF_AZ_RX_EV_IP_FRAG_ERR);
+	rx_ev_ip_hdr_chksum_err = EFX_QWORD_FIELD(*event,
+						  FSF_AZ_RX_EV_IP_HDR_CHKSUM_ERR);
+	rx_ev_tcp_udp_chksum_err = EFX_QWORD_FIELD(*event,
+						   FSF_AZ_RX_EV_TCP_UDP_CHKSUM_ERR);
+	rx_ev_eth_crc_err = EFX_QWORD_FIELD(*event, FSF_AZ_RX_EV_ETH_CRC_ERR);
+	rx_ev_frm_trunc = EFX_QWORD_FIELD(*event, FSF_AZ_RX_EV_FRM_TRUNC);
+	rx_ev_drib_nib = ((efx_nic_rev(efx) >= EFX_REV_FALCON_B0) ?
+			  0 : EFX_QWORD_FIELD(*event, FSF_AA_RX_EV_DRIB_NIB));
+	rx_ev_pause_frm = EFX_QWORD_FIELD(*event, FSF_AZ_RX_EV_PAUSE_FRM_ERR);
+
+	/* Every error apart from tobe_disc and pause_frm */
+	rx_ev_other_err = (rx_ev_drib_nib | rx_ev_tcp_udp_chksum_err |
+			   rx_ev_buf_owner_id_err | rx_ev_eth_crc_err |
+			   rx_ev_frm_trunc | rx_ev_ip_hdr_chksum_err);
+
+	/* Count errors that are not in MAC stats.  Ignore expected
+	 * checksum errors during self-test. */
+	if (rx_ev_frm_trunc)
+		++channel->n_rx_frm_trunc;
+	else if (rx_ev_tobe_disc)
+		++channel->n_rx_tobe_disc;
+	else if (!efx->loopback_selftest) {
+		if (rx_ev_eth_crc_err)
+			++channel->n_rx_eth_crc_err;
+		else if (rx_ev_ip_hdr_chksum_err)
+			++channel->n_rx_ip_hdr_chksum_err;
+		else if (rx_ev_tcp_udp_chksum_err)
+			++channel->n_rx_tcp_udp_chksum_err;
+	}
+	if (rx_ev_ip_frag_err)
+		++channel->n_rx_ip_frag;
+
+	/* The frame must be discarded if any of these are true. */
+	*discard = (rx_ev_eth_crc_err | rx_ev_frm_trunc | rx_ev_drib_nib |
+		    rx_ev_tobe_disc | rx_ev_pause_frm);
+
+	/* TOBE_DISC is expected on unicast mismatches; don't print out an
+	 * error message.  FRM_TRUNC indicates RXDP dropped the packet due
+	 * to a FIFO overflow.
+	 */
+#ifdef EFX_ENABLE_DEBUG
+	if (rx_ev_other_err && net_ratelimit()) {
+		netif_dbg(efx, rx_err, efx->net_dev,
+			  " RX queue %d unexpected RX event "
+			  EFX_QWORD_FMT "%s%s%s%s%s%s%s%s\n",
+			  efx_rx_queue_index(rx_queue), EFX_QWORD_VAL(*event),
+			  rx_ev_buf_owner_id_err ? " [OWNER_ID_ERR]" : "",
+			  rx_ev_ip_hdr_chksum_err ?
+			  " [IP_HDR_CHKSUM_ERR]" : "",
+			  rx_ev_tcp_udp_chksum_err ?
+			  " [TCP_UDP_CHKSUM_ERR]" : "",
+			  rx_ev_eth_crc_err ? " [ETH_CRC_ERR]" : "",
+			  rx_ev_frm_trunc ? " [FRM_TRUNC]" : "",
+			  rx_ev_drib_nib ? " [DRIB_NIB]" : "",
+			  rx_ev_tobe_disc ? " [TOBE_DISC]" : "",
+			  rx_ev_pause_frm ? " [PAUSE]" : "");
+	}
+#endif
+}
+
+/* Handle receive events that are not in-order. */
+static void
+efx_handle_rx_bad_index(struct efx_rx_queue *rx_queue, unsigned index)
+{
+	struct efx_nic *efx = rx_queue->efx;
+	unsigned expected, dropped;
+
+	expected = rx_queue->removed_count & rx_queue->ptr_mask;
+	dropped = (index - expected) & rx_queue->ptr_mask;
+	netif_info(efx, hw, efx->net_dev,
+		   "dropped %d events (index=%d expected=%d)\n",
+		   dropped, index, expected);
+
+	atomic_inc(&efx->errors.missing_event);
+	efx_schedule_reset(efx, EFX_WORKAROUND_5676(efx) ?
+			   RESET_TYPE_RX_RECOVERY : RESET_TYPE_DISABLE);
+}
+
+/* Handle a packet received event
+ *
+ * The NIC gives a "discard" flag if it's a unicast packet with the
+ * wrong destination address
+ * Also "is multicast" and "matches multicast filter" flags can be used to
+ * discard non-matching multicast packets.
+ */
+static void
+efx_handle_rx_event(struct efx_channel *channel, const efx_qword_t *event)
+{
+	unsigned int rx_ev_desc_ptr, rx_ev_byte_cnt;
+	unsigned int rx_ev_hdr_type, rx_ev_mcast_pkt;
+	unsigned expected_ptr;
+	bool rx_ev_pkt_ok, discard = false, checksummed;
+	struct efx_rx_queue *rx_queue;
+	struct efx_nic *efx = channel->efx;
+
+	/* Basic packet information */
+	rx_ev_byte_cnt = EFX_QWORD_FIELD(*event, FSF_AZ_RX_EV_BYTE_CNT);
+	rx_ev_pkt_ok = EFX_QWORD_FIELD(*event, FSF_AZ_RX_EV_PKT_OK);
+	rx_ev_hdr_type = EFX_QWORD_FIELD(*event, FSF_AZ_RX_EV_HDR_TYPE);
+	WARN_ON(EFX_QWORD_FIELD(*event, FSF_AZ_RX_EV_JUMBO_CONT));
+	WARN_ON(EFX_QWORD_FIELD(*event, FSF_AZ_RX_EV_SOP) != 1);
+	WARN_ON(EFX_QWORD_FIELD(*event, FSF_AZ_RX_EV_Q_LABEL) !=
+		channel->channel);
+
+	rx_queue = efx_channel_get_rx_queue(channel);
+
+	rx_ev_desc_ptr = EFX_QWORD_FIELD(*event, FSF_AZ_RX_EV_DESC_PTR);
+	expected_ptr = rx_queue->removed_count & rx_queue->ptr_mask;
+	if (unlikely(rx_ev_desc_ptr != expected_ptr))
+		efx_handle_rx_bad_index(rx_queue, rx_ev_desc_ptr);
+
+	if (likely(rx_ev_pkt_ok)) {
+		/* If packet is marked as OK and packet type is TCP/IP or
+		 * UDP/IP, then we can rely on the hardware checksum.
+		 */
+		checksummed =
+			likely(efx->rx_checksum_enabled) &&
+			(rx_ev_hdr_type == FSE_CZ_RX_EV_HDR_TYPE_IPV4V6_TCP ||
+			 rx_ev_hdr_type == FSE_CZ_RX_EV_HDR_TYPE_IPV4V6_UDP);
+	} else {
+		efx_handle_rx_not_ok(rx_queue, event, &rx_ev_pkt_ok, &discard);
+		checksummed = false;
+	}
+
+	/* Detect multicast packets that didn't match the filter */
+	rx_ev_mcast_pkt = EFX_QWORD_FIELD(*event, FSF_AZ_RX_EV_MCAST_PKT);
+	if (rx_ev_mcast_pkt) {
+		unsigned int rx_ev_mcast_hash_match =
+			EFX_QWORD_FIELD(*event, FSF_AZ_RX_EV_MCAST_HASH_MATCH);
+
+		if (unlikely(!rx_ev_mcast_hash_match)) {
+			++channel->n_rx_mcast_mismatch;
+			discard = true;
+		}
+	}
+
+	channel->irq_mod_score += 2;
+
+	/* Handle received packet */
+	efx_rx_packet(rx_queue, rx_ev_desc_ptr, rx_ev_byte_cnt,
+		      checksummed, discard);
+}
+
+static void
+efx_handle_generated_event(struct efx_channel *channel, efx_qword_t *event)
+{
+	struct efx_nic *efx = channel->efx;
+	unsigned code;
+
+	code = EFX_QWORD_FIELD(*event, FSF_AZ_DRV_GEN_EV_MAGIC);
+	if (code == EFX_CHANNEL_MAGIC_TEST(channel))
+		++channel->magic_count;
+	else if (code == EFX_CHANNEL_MAGIC_FILL(channel))
+		/* The queue must be empty, so we won't receive any rx
+		 * events, so efx_process_channel() won't refill the
+		 * queue. Refill it here */
+		efx_fast_push_rx_descriptors(efx_channel_get_rx_queue(channel));
+	else
+		netif_dbg(efx, hw, efx->net_dev, "channel %d received "
+			  "generated event "EFX_QWORD_FMT"\n",
+			  channel->channel, EFX_QWORD_VAL(*event));
+}
+
+/* Global events are basically PHY events */
+static void
+efx_handle_global_event(struct efx_channel *channel, efx_qword_t *event)
+{
+	struct efx_nic *efx = channel->efx;
+	bool handled = false;
+
+	if (EFX_QWORD_FIELD(*event, FSF_AB_GLB_EV_G_PHY0_INTR) ||
+	    EFX_QWORD_FIELD(*event, FSF_AB_GLB_EV_XG_PHY0_INTR) ||
+	    EFX_QWORD_FIELD(*event, FSF_AB_GLB_EV_XFP_PHY0_INTR)) {
+		/* Ignored */
+		handled = true;
+	}
+
+	if ((efx_nic_rev(efx) == EFX_REV_FALCON_B0) &&
+	    EFX_QWORD_FIELD(*event, FSF_BB_GLB_EV_XG_MGT_INTR)) {
+		efx->xmac_poll_required = true;
+		handled = true;
+	}
+
+	if (efx_nic_rev(efx) <= EFX_REV_FALCON_A1 ?
+	    EFX_QWORD_FIELD(*event, FSF_AA_GLB_EV_RX_RECOVERY) :
+	    EFX_QWORD_FIELD(*event, FSF_BB_GLB_EV_RX_RECOVERY)) {
+		netif_err(efx, rx_err, efx->net_dev,
+			  "channel %d seen global RX_RESET event. Resetting.\n",
+			  channel->channel);
+
+		atomic_inc(&efx->errors.rx_reset);
+		efx_schedule_reset(efx, EFX_WORKAROUND_6555(efx) ?
+				   RESET_TYPE_RX_RECOVERY : RESET_TYPE_DISABLE);
+		handled = true;
+	}
+
+	if (!handled)
+		EFX_FATAL(efx, hw, efx->net_dev,
+			  "channel %d unknown global event "
+			  EFX_QWORD_FMT "\n", channel->channel,
+			  EFX_QWORD_VAL(*event));
+}
+
+static void
+efx_handle_driver_event(struct efx_channel *channel, efx_qword_t *event)
+{
+	struct efx_nic *efx = channel->efx;
+	unsigned int ev_sub_code;
+	unsigned int ev_sub_data;
+
+	ev_sub_code = EFX_QWORD_FIELD(*event, FSF_AZ_DRIVER_EV_SUBCODE);
+	ev_sub_data = EFX_QWORD_FIELD(*event, FSF_AZ_DRIVER_EV_SUBDATA);
+
+	switch (ev_sub_code) {
+	case FSE_AZ_TX_DESCQ_FLS_DONE_EV:
+		netif_vdbg(efx, hw, efx->net_dev, "channel %d TXQ %d flushed\n",
+			  channel->channel, ev_sub_data);
+		efx_sriov_tx_flush_done(efx, event);
+		EFX_DL_CALLBACK(efx, event, event);
+		break;
+	case FSE_AZ_RX_DESCQ_FLS_DONE_EV:
+		netif_vdbg(efx, hw, efx->net_dev, "channel %d RXQ %d flushed\n",
+			  channel->channel, ev_sub_data);
+		efx_sriov_rx_flush_done(efx, event);
+		EFX_DL_CALLBACK(efx, event, event);
+		break;
+	case FSE_AZ_EVQ_INIT_DONE_EV:
+		netif_dbg(efx, hw, efx->net_dev,
+			  "channel %d EVQ %d initialised\n",
+			  channel->channel, ev_sub_data);
+		break;
+	case FSE_AZ_SRM_UPD_DONE_EV:
+		netif_vdbg(efx, hw, efx->net_dev,
+			   "channel %d SRAM update done\n", channel->channel);
+		EFX_DL_CALLBACK(efx, event, event);
+		break;
+	case FSE_AZ_WAKE_UP_EV:
+		netif_vdbg(efx, hw, efx->net_dev,
+			   "channel %d RXQ %d wakeup event\n",
+			   channel->channel, ev_sub_data);
+		EFX_DL_CALLBACK(efx, event, event);
+		break;
+	case FSE_AZ_TIMER_EV:
+		netif_vdbg(efx, hw, efx->net_dev,
+			   "channel %d RX queue %d timer expired\n",
+			   channel->channel, ev_sub_data);
+		EFX_DL_CALLBACK(efx, event, event);
+		break;
+	case FSE_AA_RX_RECOVER_EV:
+		netif_err(efx, hw, efx->net_dev,
+			  "channel %d seen DRIVER RX_RESET event. Resetting.\n",
+			  channel->channel);
+		atomic_inc(&efx->errors.rx_reset);
+		efx_schedule_reset(efx,
+				   EFX_WORKAROUND_6555(efx) ?
+				   RESET_TYPE_RX_RECOVERY :
+				   RESET_TYPE_DISABLE);
+		break;
+	case FSE_BZ_RX_DSC_ERROR_EV:
+		netif_err(efx, rx_err, efx->net_dev,
+			  "RX DMA Q %d reports descriptor fetch error."
+			  " RX Q %d is disabled.\n", ev_sub_data, ev_sub_data);
+		atomic_inc(&efx->errors.rx_desc_fetch);
+		efx_schedule_reset(efx, RESET_TYPE_RX_DESC_FETCH);
+		break;
+	case FSE_BZ_TX_DSC_ERROR_EV:
+		netif_err(efx, tx_err, efx->net_dev,
+			  "TX DMA Q %d reports descriptor fetch error."
+			  " TX Q %d is disabled.\n", ev_sub_data, ev_sub_data);
+		atomic_inc(&efx->errors.tx_desc_fetch);
+		efx_schedule_reset(efx, RESET_TYPE_TX_DESC_FETCH);
+		break;
+	default:
+		netif_vdbg(efx, hw, efx->net_dev,
+			   "channel %d unknown driver event code %d data %04x\n",
+			   channel->channel, ev_sub_code,
+			  ev_sub_data);
+		EFX_DL_CALLBACK(efx, event, event);
+		break;
+	}
+}
+
+#if defined(EFX_USE_KCOMPAT) && defined(EFX_USE_FASTCALL)
+int fastcall efx_nic_process_eventq(struct efx_channel *channel, int budget)
+#else
+int efx_nic_process_eventq(struct efx_channel *channel, int budget)
+#endif
+{
+	struct efx_nic *efx = channel->efx;
+	unsigned int read_ptr;
+	efx_qword_t event, *p_event;
+	int ev_code;
+	int tx_packets = 0;
+	int spent = 0;
+
+	read_ptr = channel->eventq_read_ptr;
+
+	for (;;) {
+		p_event = efx_event(channel, read_ptr);
+		event = *p_event;
+
+		if (!efx_event_present(&event))
+			/* End of events */
+			break;
+
+		netif_vdbg(efx, hw, efx->net_dev, "channel %d event is "EFX_QWORD_FMT"\n",
+			  channel->channel, EFX_QWORD_VAL(event));
+
+		/* Clear this event by marking it all ones */
+		EFX_SET_QWORD(*p_event);
+
+		/* Increment read pointer */
+		read_ptr = (read_ptr + 1) & channel->eventq_mask;
+
+		ev_code = EFX_QWORD_FIELD(event, FSF_AZ_EV_CODE);
+
+		switch (ev_code) {
+		case FSE_AZ_EV_CODE_RX_EV:
+			efx_handle_rx_event(channel, &event);
+			if (++spent == budget)
+				goto out;
+			break;
+		case FSE_AZ_EV_CODE_TX_EV:
+			tx_packets += efx_handle_tx_event(channel, &event);
+			if (tx_packets > efx->txq_entries) {
+				spent = budget;
+				goto out;
+			}
+			break;
+		case FSE_AZ_EV_CODE_DRV_GEN_EV:
+			efx_handle_generated_event(channel, &event);
+			break;
+		case FSE_AZ_EV_CODE_GLOBAL_EV:
+			efx_handle_global_event(channel, &event);
+			break;
+		case FSE_AZ_EV_CODE_DRIVER_EV:
+			efx_handle_driver_event(channel, &event);
+			break;
+		case FSE_CZ_EV_CODE_USER_EV:
+			efx_sriov_event(channel, &event);
+			break;
+		case FSE_CZ_EV_CODE_MCDI_EV:
+			efx_mcdi_process_event(channel, &event);
+			break;
+		default:
+			EFX_FATAL(efx, hw, efx->net_dev,
+				  "channel %d unknown event type %d"
+				  " (data " EFX_QWORD_FMT ")\n",
+				  channel->channel, ev_code,
+				  EFX_QWORD_VAL(event));
+		}
+	}
+
+out:
+	channel->eventq_read_ptr = read_ptr;
+	return spent;
+}
+
+
+/* Allocate buffer table entries for event queue */
+int efx_nic_probe_eventq(struct efx_channel *channel)
+{
+	struct efx_nic *efx = channel->efx;
+	unsigned entries;
+	int rc;
+
+	entries = channel->eventq_mask + 1;
+	rc = efx_alloc_special_buffer(efx, &channel->eventq,
+				      entries, EFX_MAX_EVQ_SIZE);
+	if (rc)
+		return rc;
+
+	efx->resources.evq_int_min = max(efx->resources.evq_int_min,
+					 (unsigned)channel->channel + 1);
+
+	return 0;
+}
+
+void efx_nic_init_eventq(struct efx_channel *channel)
+{
+	efx_oword_t reg;
+	struct efx_nic *efx = channel->efx;
+
+	netif_dbg(efx, hw, efx->net_dev,
+		  "channel %d event queue in special buffers %d-%d\n",
+		  channel->channel, channel->eventq.index,
+		  channel->eventq.index + channel->eventq.entries - 1);
+
+	if (efx_nic_rev(efx) >= EFX_REV_SIENA_A0) {
+		EFX_POPULATE_OWORD_3(reg,
+				     FRF_CZ_TIMER_Q_EN, 1,
+				     FRF_CZ_HOST_NOTIFY_MODE, 0,
+				     FRF_CZ_TIMER_MODE, FFE_CZ_TIMER_MODE_DIS);
+		efx_writeo_table(efx, &reg, FR_BZ_TIMER_TBL, channel->channel);
+	}
+
+	/* Pin event queue buffer */
+	efx_init_special_buffer(efx, &channel->eventq);
+
+	/* Fill event queue with all ones (i.e. empty events) */
+	memset(channel->eventq.addr, 0xff, channel->eventq.len);
+
+	/* Push event queue to card */
+	EFX_POPULATE_OWORD_3(reg,
+			     FRF_AZ_EVQ_EN, 1,
+			     FRF_AZ_EVQ_SIZE, __ffs(channel->eventq.entries),
+			     FRF_AZ_EVQ_BUF_BASE_ID, channel->eventq.index);
+	efx_writeo_table(efx, &reg, efx->type->evq_ptr_tbl_base,
+			 channel->channel);
+
+	efx->type->push_irq_moderation(channel);
+}
+
+void efx_nic_fini_eventq(struct efx_channel *channel)
+{
+	efx_oword_t reg;
+	struct efx_nic *efx = channel->efx;
+
+	/* Remove event queue from card */
+	EFX_ZERO_OWORD(reg);
+	efx_writeo_table(efx, &reg, efx->type->evq_ptr_tbl_base,
+			 channel->channel);
+	if (efx_nic_rev(efx) >= EFX_REV_SIENA_A0)
+		efx_writeo_table(efx, &reg, FR_BZ_TIMER_TBL, channel->channel);
+
+	/* Unpin event queue */
+	efx_fini_special_buffer(efx, &channel->eventq);
+}
+
+/* Free buffers backing event queue */
+void efx_nic_remove_eventq(struct efx_channel *channel)
+{
+	efx_free_special_buffer(channel->efx, &channel->eventq);
+}
+
+
+void efx_nic_generate_test_event(struct efx_channel *channel)
+{
+	unsigned int magic = EFX_CHANNEL_MAGIC_TEST(channel);
+	efx_qword_t test_event;
+
+	EFX_POPULATE_QWORD_2(test_event, FSF_AZ_EV_CODE,
+			     FSE_AZ_EV_CODE_DRV_GEN_EV,
+			     FSF_AZ_DRV_GEN_EV_MAGIC, magic);
+	efx_generate_event(channel->efx, channel->channel, &test_event);
+}
+
+void efx_nic_generate_fill_event(struct efx_channel *channel)
+{
+	unsigned int magic = EFX_CHANNEL_MAGIC_FILL(channel);
+	efx_qword_t test_event;
+
+	EFX_POPULATE_QWORD_2(test_event, FSF_AZ_EV_CODE,
+			     FSE_AZ_EV_CODE_DRV_GEN_EV,
+			     FSF_AZ_DRV_GEN_EV_MAGIC, magic);
+	efx_generate_event(channel->efx, channel->channel, &test_event);
+}
+
+/**************************************************************************
+ *
+ * Flush handling
+ *
+ **************************************************************************/
+
+
+static void efx_poll_flush_events(struct efx_nic *efx)
+{
+	struct efx_channel *channel = efx_get_channel(efx, 0);
+	struct efx_tx_queue *tx_queue;
+	struct efx_rx_queue *rx_queue;
+	unsigned int read_ptr = channel->eventq_read_ptr;
+	unsigned int end_ptr = (read_ptr - 1) & channel->eventq_mask;
+
+	do {
+		efx_qword_t *event = efx_event(channel, read_ptr);
+		int ev_code, ev_sub_code, ev_queue;
+		bool ev_failed;
+
+		if (!efx_event_present(event))
+			break;
+
+		ev_code = EFX_QWORD_FIELD(*event, FSF_AZ_EV_CODE);
+		ev_sub_code = EFX_QWORD_FIELD(*event,
+					      FSF_AZ_DRIVER_EV_SUBCODE);
+		if (ev_code == FSE_AZ_EV_CODE_DRIVER_EV &&
+		    ev_sub_code == FSE_AZ_TX_DESCQ_FLS_DONE_EV) {
+			ev_queue = EFX_QWORD_FIELD(*event,
+						   FSF_AZ_DRIVER_EV_SUBDATA);
+			if (ev_queue < EFX_TXQ_TYPES * efx->n_tx_channels) {
+				tx_queue = efx_get_tx_queue(
+					efx, ev_queue / EFX_TXQ_TYPES,
+					ev_queue % EFX_TXQ_TYPES);
+				tx_queue->flushed = FLUSH_DONE;
+			}
+		} else if (ev_code == FSE_AZ_EV_CODE_DRIVER_EV &&
+			   ev_sub_code == FSE_AZ_RX_DESCQ_FLS_DONE_EV) {
+			ev_queue = EFX_QWORD_FIELD(
+				*event, FSF_AZ_DRIVER_EV_RX_DESCQ_ID);
+			ev_failed = EFX_QWORD_FIELD(
+				*event, FSF_AZ_DRIVER_EV_RX_FLUSH_FAIL);
+			if (ev_queue < efx->n_rx_channels) {
+				rx_queue = efx_get_rx_queue(efx, ev_queue);
+				rx_queue->flushed =
+					ev_failed ? FLUSH_FAILED : FLUSH_DONE;
+			}
+		}
+
+		/* We're about to destroy the queue anyway, so
+		 * it's ok to throw away every non-flush event */
+		EFX_SET_QWORD(*event);
+
+		read_ptr = (read_ptr + 1) & channel->eventq_mask;
+	} while (read_ptr != end_ptr);
+
+	channel->eventq_read_ptr = read_ptr;
+}
+
+/* Handle tx and rx flushes at the same time, since they run in
+ * parallel in the hardware and there's no reason for us to
+ * serialise them */
+int efx_nic_flush_queues(struct efx_nic *efx)
+{
+	struct efx_channel *channel;
+	struct efx_rx_queue *rx_queue;
+	struct efx_tx_queue *tx_queue;
+	int i, tx_pending, rx_pending, rc;
+
+	/* If necessary prepare the hardware for flushing */
+	efx->type->prepare_flush(efx);
+
+	/* Flush all tx queues in parallel */
+	efx_for_each_channel(channel, efx) {
+		efx_for_each_channel_tx_queue(tx_queue, channel)
+			efx_flush_tx_queue(tx_queue);
+	}
+
+	for (i = 0; i < EFX_FLUSH_POLL_COUNT; ++i) {
+		rx_pending = tx_pending = 0;
+		efx_for_each_channel(channel, efx) {
+			efx_for_each_channel_rx_queue(rx_queue, channel) {
+				if (rx_queue->flushed == FLUSH_PENDING)
+					++rx_pending;
+			}
+		}
+
+		/* If SRIOV is enabled, then offload receive queue flushing to
+		 * the firmware (though we will still have to poll for
+		 * completion). If that fails, fall back to the old scheme. */
+		if (efx->vf_count) {
+			rc = efx_mcdi_flush_rxqs(efx);
+			if (rc >= 0) {
+				rx_pending += rc;
+				goto wait;
+			}
+		}
+
+		/* The hardware supports four concurrent rx flushes, each of
+		 * which may need to be retried if there is an outstanding
+		 * descriptor fetch */
+		efx_for_each_channel(channel, efx) {
+			efx_for_each_channel_rx_queue(rx_queue, channel) {
+				if (rx_pending == EFX_RX_FLUSH_COUNT)
+					break;
+				if (rx_queue->flushed == FLUSH_FAILED ||
+				    rx_queue->flushed == FLUSH_NONE) {
+					efx_flush_rx_queue(rx_queue);
+					++rx_pending;
+				}
+			}
+		}
+
+	wait:
+		efx_for_each_channel(channel, efx) {
+			efx_for_each_channel_tx_queue(tx_queue, channel) {
+				if (tx_queue->flushed != FLUSH_DONE)
+					++tx_pending;
+			}
+		}
+
+		if (rx_pending == 0 && tx_pending == 0)
+			return 0;
+
+		msleep(EFX_FLUSH_INTERVAL);
+		efx_poll_flush_events(efx);
+	}
+
+	/* Mark the queues as all flushed. We're going to return failure
+	 * leading to a reset, or fake up success anyway */
+	efx_for_each_channel(channel, efx) {
+		efx_for_each_channel_tx_queue(tx_queue, channel) {
+			if (tx_queue->flushed != FLUSH_DONE)
+				netif_err(efx, hw, efx->net_dev,
+					  "tx queue %d flush command timed out\n",
+					  tx_queue->queue);
+			tx_queue->flushed = FLUSH_DONE;
+		}
+		efx_for_each_channel_rx_queue(rx_queue, channel) {
+			if (rx_queue->flushed != FLUSH_DONE)
+				netif_err(efx, hw, efx->net_dev,
+					  "rx queue %d flush command timed out\n",
+					  efx_rx_queue_index(rx_queue));
+			rx_queue->flushed = FLUSH_DONE;
+		}
+	}
+
+	return -ETIMEDOUT;
+}
+
+/**************************************************************************
+ *
+ * Hardware interrupts
+ * The hardware interrupt handler does very little work; all the event
+ * queue processing is carried out by per-channel tasklets.
+ *
+ **************************************************************************/
+
+/* Enable/disable/generate interrupts */
+static inline void efx_nic_interrupts(struct efx_nic *efx,
+				      bool enabled, bool force)
+{
+	efx_oword_t int_en_reg_ker;
+
+	EFX_POPULATE_OWORD_3(int_en_reg_ker,
+			     FRF_AZ_KER_INT_LEVE_SEL, efx->irq_level,
+			     FRF_AZ_KER_INT_KER, force,
+			     FRF_AZ_DRV_INT_EN_KER, enabled);
+	efx_writeo(efx, &int_en_reg_ker, FR_AZ_INT_EN_KER);
+}
+
+void efx_nic_enable_interrupts(struct efx_nic *efx)
+{
+	struct efx_channel *channel;
+
+	EFX_ZERO_OWORD(*((efx_oword_t *) efx->irq_status.addr));
+	wmb(); /* Ensure interrupt vector is clear before interrupts enabled */
+
+	/* Enable interrupts */
+	efx_nic_interrupts(efx, true, false);
+
+	/* Force processing of all the channels to get the EVQ RPTRs up to
+	   date */
+	efx_for_each_channel(channel, efx)
+		efx_schedule_channel(channel);
+}
+
+void efx_nic_disable_interrupts(struct efx_nic *efx)
+{
+	/* Disable interrupts */
+	efx_nic_interrupts(efx, false, false);
+}
+
+/* Generate a test interrupt
+ * Interrupt must already have been enabled, otherwise nasty things
+ * may happen.
+ */
+void efx_nic_generate_interrupt(struct efx_nic *efx)
+{
+	efx_nic_interrupts(efx, true, true);
+}
+
+/* Process a fatal interrupt
+ * Disable bus mastering ASAP and schedule a reset
+ */
+irqreturn_t efx_nic_fatal_interrupt(struct efx_nic *efx)
+{
+	struct falcon_nic_data *nic_data = efx->nic_data;
+	efx_oword_t *int_ker = efx->irq_status.addr;
+	efx_oword_t fatal_intr;
+	int error, mem_perr;
+
+	efx_reado(efx, &fatal_intr, FR_AZ_FATAL_INTR_KER);
+	error = EFX_OWORD_FIELD(fatal_intr, FRF_AZ_FATAL_INTR);
+
+	netif_err(efx, hw, efx->net_dev, "SYSTEM ERROR "EFX_OWORD_FMT" status "
+		  EFX_OWORD_FMT ": %s\n", EFX_OWORD_VAL(*int_ker),
+		  EFX_OWORD_VAL(fatal_intr),
+		  error ? "disabling bus mastering" : "no recognised error");
+
+	/* If this is a memory parity error dump which blocks are offending */
+	mem_perr = (EFX_OWORD_FIELD(fatal_intr, FRF_AZ_MEM_PERR_INT_KER) ||
+		    EFX_OWORD_FIELD(fatal_intr, FRF_AZ_SRM_PERR_INT_KER));
+	if (mem_perr) {
+		efx_oword_t reg;
+		efx_reado(efx, &reg, FR_AZ_MEM_STAT);
+		netif_err(efx, hw, efx->net_dev,
+			  "SYSTEM ERROR: memory parity error "EFX_OWORD_FMT"\n",
+			  EFX_OWORD_VAL(reg));
+	}
+
+	/* Disable both devices */
+	pci_clear_master(efx->pci_dev);
+	if (efx_nic_is_dual_func(efx))
+		pci_clear_master(nic_data->pci_dev2);
+	efx_nic_disable_interrupts(efx);
+
+	/* Count errors and reset or disable the NIC accordingly */
+	if (efx->int_error_count == 0 ||
+	    time_after(jiffies, efx->int_error_expire)) {
+		efx->int_error_count = 0;
+		efx->int_error_expire =
+			jiffies + EFX_INT_ERROR_EXPIRE * HZ;
+	}
+	if (++efx->int_error_count < EFX_MAX_INT_ERRORS) {
+		netif_err(efx, hw, efx->net_dev,
+			  "SYSTEM ERROR - reset scheduled\n");
+		efx_schedule_reset(efx, RESET_TYPE_INT_ERROR);
+	} else {
+		netif_err(efx, hw, efx->net_dev,
+			  "SYSTEM ERROR - max number of errors seen."
+			  "NIC will be disabled\n");
+		efx_schedule_reset(efx, RESET_TYPE_DISABLE);
+	}
+
+	return IRQ_HANDLED;
+}
+
+/* Handle a legacy interrupt
+ * Acknowledges the interrupt and schedule event queue processing.
+ *
+ * This routine must guarantee not to touch the hardware when
+ * interrupts are disabled, to allow for correct semantics of
+ * efx_suspend() and efx_resume().
+ */
+#if !defined(EFX_USE_KCOMPAT) || !defined(EFX_HAVE_IRQ_HANDLER_REGS)
+static irqreturn_t efx_legacy_interrupt(int irq, void *dev_id)
+#else
+static irqreturn_t efx_legacy_interrupt(int irq, void *dev_id,
+					struct pt_regs *regs
+					__attribute__ ((unused)))
+#endif
+{
+	struct efx_nic *efx = dev_id;
+	efx_oword_t *int_ker = efx->irq_status.addr;
+	irqreturn_t result = IRQ_NONE;
+	struct efx_channel *channel;
+	efx_dword_t reg;
+	u32 queues;
+	int syserr;
+
+	/* Read the ISR which also ACKs the interrupts */
+	efx_readd(efx, &reg, FR_BZ_INT_ISR0);
+	queues = EFX_EXTRACT_DWORD(reg, 0, 31);
+
+	/* Check to see if we have a serious error condition */
+	if (queues & (1U << efx->irq_level)) {
+		syserr = EFX_OWORD_FIELD(*int_ker, FSF_AZ_NET_IVEC_FATAL_INT);
+		if (unlikely(syserr))
+			return efx_nic_fatal_interrupt(efx);
+	}
+
+	if (queues != 0) {
+		if (EFX_WORKAROUND_15783(efx))
+			efx->irq_zero_count = 0;
+
+		/* Schedule processing of any interrupting queues */
+		efx_for_each_channel(channel, efx) {
+			if (queues & 1)
+				efx_schedule_channel(channel);
+			queues >>= 1;
+		}
+		result = IRQ_HANDLED;
+
+	} else if (EFX_WORKAROUND_15783(efx)) {
+		efx_qword_t *event;
+
+		/* We can't return IRQ_HANDLED more than once on seeing ISR=0
+		 * because this might be a shared interrupt. */
+		if (efx->irq_zero_count++ == 0)
+			result = IRQ_HANDLED;
+
+		/* Ensure we schedule or rearm all event queues */
+		efx_for_each_channel(channel, efx) {
+			event = efx_event(channel, channel->eventq_read_ptr);
+			if (efx_event_present(event))
+				efx_schedule_channel(channel);
+			else
+				efx_nic_eventq_read_ack(channel);
+		}
+	}
+
+	if (result == IRQ_HANDLED) {
+		efx->last_irq_cpu = raw_smp_processor_id();
+		netif_vdbg(efx, intr, efx->net_dev,
+			   "IRQ %d on CPU %d status " EFX_DWORD_FMT "\n",
+			   irq, raw_smp_processor_id(), EFX_DWORD_VAL(reg));
+	}
+
+	return result;
+}
+
+/* Handle an MSI interrupt
+ *
+ * Handle an MSI hardware interrupt.  This routine schedules event
+ * queue processing.  No interrupt acknowledgement cycle is necessary.
+ * Also, we never need to check that the interrupt is for us, since
+ * MSI interrupts cannot be shared.
+ *
+ * This routine must guarantee not to touch the hardware when
+ * interrupts are disabled, to allow for correct semantics of
+ * efx_suspend() and efx_resume().
+ */
+#if !defined(EFX_USE_KCOMPAT) || !defined(EFX_HAVE_IRQ_HANDLER_REGS)
+static irqreturn_t efx_msi_interrupt(int irq, void *dev_id)
+#else
+static irqreturn_t efx_msi_interrupt(int irq, void *dev_id,
+				     struct pt_regs *regs
+				     __attribute__ ((unused)))
+#endif
+{
+	struct efx_channel *channel = *(struct efx_channel **)dev_id;
+	struct efx_nic *efx = channel->efx;
+	efx_oword_t *int_ker = efx->irq_status.addr;
+	int syserr;
+
+	efx->last_irq_cpu = raw_smp_processor_id();
+	netif_vdbg(efx, intr, efx->net_dev,
+		   "IRQ %d on CPU %d status " EFX_OWORD_FMT "\n",
+		   irq, raw_smp_processor_id(), EFX_OWORD_VAL(*int_ker));
+
+	/* Check to see if we have a serious error condition */
+	if (channel->channel == efx->irq_level) {
+		syserr = EFX_OWORD_FIELD(*int_ker, FSF_AZ_NET_IVEC_FATAL_INT);
+		if (unlikely(syserr))
+			return efx_nic_fatal_interrupt(efx);
+	}
+
+	/* Schedule processing of the channel */
+	efx_schedule_channel(channel);
+
+	return IRQ_HANDLED;
+}
+
+/* Setup RSS indirection table.
+ * This maps from the hash value of the packet to RXQ
+ */
+void efx_nic_push_rx_indir_table(struct efx_nic *efx)
+{
+	size_t i = 0;
+	efx_dword_t dword;
+
+	if (efx_nic_rev(efx) < EFX_REV_FALCON_B0)
+		return;
+
+	BUILD_BUG_ON(ARRAY_SIZE(efx->rx_indir_table) !=
+		     FR_BZ_RX_INDIRECTION_TBL_ROWS);
+
+	for (i = 0; i < FR_BZ_RX_INDIRECTION_TBL_ROWS; i++) {
+		EFX_POPULATE_DWORD_1(dword, FRF_BZ_IT_QUEUE,
+				     efx->rx_indir_table[i]);
+		efx_writed_table(efx, &dword, FR_BZ_RX_INDIRECTION_TBL, i);
+	}
+}
+
+/* Hook interrupt handler(s)
+ * Try MSI and then legacy interrupts.
+ */
+int efx_nic_init_interrupt(struct efx_nic *efx)
+{
+	struct efx_channel *channel;
+	int rc;
+
+	if (!EFX_INT_MODE_USE_MSI(efx)) {
+		irq_handler_t handler;
+		if (efx_nic_rev(efx) >= EFX_REV_FALCON_B0)
+			handler = efx_legacy_interrupt;
+		else
+			handler = falcon_legacy_interrupt_a1;
+
+		rc = request_irq(efx->legacy_irq, handler, IRQF_SHARED,
+				 efx->name, efx);
+		if (rc) {
+			netif_err(efx, drv, efx->net_dev,
+				  "failed to hook legacy IRQ %d\n",
+				  efx->pci_dev->irq);
+			goto fail1;
+		}
+		return 0;
+	}
+
+	/* Hook MSI or MSI-X interrupt */
+	efx_for_each_channel(channel, efx) {
+		rc = request_irq(channel->irq, efx_msi_interrupt,
+				 IRQF_PROBE_SHARED, /* Not shared */
+				 efx->channel_name[channel->channel],
+				 &efx->channel[channel->channel]);
+		if (rc) {
+			netif_err(efx, drv, efx->net_dev,
+				  "failed to hook IRQ %d\n", channel->irq);
+			goto fail2;
+		}
+	}
+
+	return 0;
+
+ fail2:
+	efx_for_each_channel(channel, efx)
+		free_irq(channel->irq, &efx->channel[channel->channel]);
+ fail1:
+	return rc;
+}
+
+void efx_nic_fini_interrupt(struct efx_nic *efx)
+{
+	struct efx_channel *channel;
+	efx_oword_t reg;
+
+	/* Disable MSI/MSI-X interrupts */
+	efx_for_each_channel(channel, efx) {
+		if (channel->irq)
+			free_irq(channel->irq, &efx->channel[channel->channel]);
+	}
+
+	/* ACK legacy interrupt */
+	if (efx_nic_rev(efx) >= EFX_REV_FALCON_B0)
+		efx_reado(efx, &reg, FR_BZ_INT_ISR0);
+	else
+		falcon_irq_ack_a1(efx);
+
+	/* Disable legacy interrupt */
+	if (efx->legacy_irq)
+		free_irq(efx->legacy_irq, efx);
+}
+
+/* Looks at available SRAM resources and works out how many queues we
+ * can support, and where things like descriptor caches should live. */
+int efx_nic_dimension_resources(struct efx_nic *efx, size_t sram_size,
+				unsigned used_vi_count)
+{
+	struct efx_dl_falcon_resources *res = &efx->resources;
+	unsigned dcs, entries_per_vi, vi_count;
+
+	efx->sram_lim = sram_size;
+
+	if (rx_desc_cache_size & (rx_desc_cache_size - 1) ||
+	    rx_desc_cache_size < 8 || rx_desc_cache_size > 64) {
+		netif_err(efx, drv, efx->net_dev,
+			  "bad rx_desc_cache_size=%d\n", rx_desc_cache_size);
+		return -EINVAL;
+	}
+	efx->rx_dc_entries = rx_desc_cache_size;
+
+	if (tx_desc_cache_size & (tx_desc_cache_size - 1) ||
+	    tx_desc_cache_size < 8 || tx_desc_cache_size > 32) {
+		netif_err(efx, drv, efx->net_dev,
+			  "bad tx_desc_cache_size=%d\n", tx_desc_cache_size);
+		return -EINVAL;
+	}
+	efx->tx_dc_entries = tx_desc_cache_size;
+
+	/* Account for buffer table space backing a vNICs queues */
+	entries_per_vi = efx->rx_dc_entries + efx->tx_dc_entries +
+		((EFX_MAX_DMAQ_SIZE * 2 + EFX_MAX_EVQ_SIZE) *
+		 sizeof(efx_qword_t) / EFX_BUF_SIZE);
+	if (target_num_vis)
+		vi_count = max(used_vi_count, target_num_vis);
+	else {
+		/* All VIs use entries_per_vi buffer table entries per queue.
+		 * Onload queues are considered to use an additional 512
+		 * entries per VI for buffer table entries backing descriptors.
+		 */
+		vi_count = used_vi_count +
+			((res->buffer_table_lim -
+			  res->evq_timer_min * entries_per_vi)
+			 / (512 + entries_per_vi));
+	}
+	if (vi_count > res->evq_timer_lim)
+		vi_count = res->evq_timer_lim;
+	if (vi_count < res->rxq_lim)
+		res->rxq_lim = vi_count;
+	if (vi_count < res->txq_lim)
+		res->txq_lim = vi_count;
+
+	dcs = vi_count * efx->tx_dc_entries * 8;
+	efx->tx_dc_base = sram_size - dcs;
+	dcs = vi_count * efx->rx_dc_entries * 8;
+	efx->rx_dc_base = efx->tx_dc_base - dcs;
+	res->buffer_table_lim = min(res->buffer_table_lim, efx->rx_dc_base / 8);
+
+	netif_dbg(efx, hw, efx->net_dev,
+		  "Available resources: RXQs [%u,%u), TXQs [%u,%u),"
+		  " buffer table entries [%u,%u)\n",
+		  res->evq_timer_min, res->rxq_lim,
+		  res->evq_timer_min, res->txq_lim,
+		  res->buffer_table_min, res->buffer_table_lim);
+
+	return 0;
+}
+
+u32 efx_nic_fpga_ver(struct efx_nic *efx)
+{
+	efx_oword_t altera_build;
+	efx_reado(efx, &altera_build, FR_AZ_ALTERA_BUILD);
+	return EFX_OWORD_FIELD(altera_build, FRF_AZ_ALTERA_BUILD_VER);
+}
+
+#ifdef CONFIG_SFC_DEBUGFS
+
+/* Generate a hardware revision string */
+int efx_nic_debugfs_read_desc(struct seq_file *file, void *data)
+{
+	struct efx_nic *efx = data;
+	int rc, len;
+
+	rc = seq_puts(file, "Falcon ASIC");
+	len = rc;
+
+	switch (efx_nic_rev(efx)) {
+	case EFX_REV_FALCON_A1:
+		rc = seq_puts(file, " Falcon rev A1 ");
+		break;
+	case EFX_REV_FALCON_B0:
+		rc = seq_puts(file, " Falcon rev B0 ");
+		break;
+	case EFX_REV_SIENA_A0:
+		rc = seq_puts(file, " Siena rev A0 ");
+		break;
+	default:
+		rc = seq_puts(file, " rev ?? ");
+		break;
+	}
+	len += rc;
+
+	rc = seq_printf(file, "%s %s board ",
+			((efx)->link_state.speed == 10000) ? "10G" : "1G",
+			efx->phy_name);
+	len += rc;
+
+	if (efx_nic_rev(efx) <= EFX_REV_FALCON_B0) {
+		rc = seq_printf(file, "PCB %c%d\n",
+				'A' + falcon_board(efx)->major,
+				falcon_board(efx)->minor);
+		len += rc;
+	}
+
+	return rc < 0 ? rc : len;
+}
+
+#endif /* CONFIG_SFC_DEBUGFS */
+
+void efx_nic_init_common(struct efx_nic *efx)
+{
+	efx_oword_t temp;
+
+	/* Set positions of descriptor caches in SRAM. */
+	EFX_POPULATE_OWORD_1(temp, FRF_AZ_SRM_TX_DC_BASE_ADR,
+			     efx->tx_dc_base / 8);
+	efx_writeo(efx, &temp, FR_AZ_SRM_TX_DC_CFG);
+	EFX_POPULATE_OWORD_1(temp, FRF_AZ_SRM_RX_DC_BASE_ADR,
+			     efx->rx_dc_base / 8);
+	efx_writeo(efx, &temp, FR_AZ_SRM_RX_DC_CFG);
+
+	/* Set TX descriptor cache size. */
+	EFX_POPULATE_OWORD_1(temp, FRF_AZ_TX_DC_SIZE,
+			     ffs(efx->tx_dc_entries) - 4);
+	efx_writeo(efx, &temp, FR_AZ_TX_DC_CFG);
+
+	/* Set RX descriptor cache size.  Set low watermark to size-8, as
+	 * this allows most efficient prefetching.
+	 */
+	EFX_POPULATE_OWORD_1(temp, FRF_AZ_RX_DC_SIZE,
+			     ffs(efx->rx_dc_entries) - 4);
+	efx_writeo(efx, &temp, FR_AZ_RX_DC_CFG);
+	EFX_POPULATE_OWORD_1(temp, FRF_AZ_RX_DC_PF_LWM,
+			     efx->rx_dc_entries - 8);
+	efx_writeo(efx, &temp, FR_AZ_RX_DC_PF_WM);
+
+	/* Program INT_KER address */
+	EFX_POPULATE_OWORD_2(temp,
+			     FRF_AZ_NORM_INT_VEC_DIS_KER,
+			     EFX_INT_MODE_USE_MSI(efx),
+			     FRF_AZ_INT_ADR_KER, efx->irq_status.dma_addr);
+	efx_writeo(efx, &temp, FR_AZ_INT_ADR_KER);
+
+	if (EFX_WORKAROUND_17213(efx) && !EFX_INT_MODE_USE_MSI(efx))
+		/* Use an interrupt level unused by event queues */
+		efx->irq_level = 0x1f;
+	else
+		/* Use a valid MSI-X vector */
+		efx->irq_level = 0;
+
+	/* Enable all the genuinely fatal interrupts.  (They are still
+	 * masked by the overall interrupt mask, controlled by
+	 * falcon_interrupts()).
+	 *
+	 * Note: All other fatal interrupts are enabled
+	 */
+	EFX_POPULATE_OWORD_3(temp,
+			     FRF_AZ_ILL_ADR_INT_KER_EN, 1,
+			     FRF_AZ_RBUF_OWN_INT_KER_EN, 1,
+			     FRF_AZ_TBUF_OWN_INT_KER_EN, 1);
+	if (efx_nic_rev(efx) >= EFX_REV_SIENA_A0)
+		EFX_SET_OWORD_FIELD(temp, FRF_CZ_SRAM_PERR_INT_P_KER_EN, 1);
+	EFX_INVERT_OWORD(temp);
+	efx_writeo(efx, &temp, FR_AZ_FATAL_INTR_KER);
+
+	efx_nic_push_rx_indir_table(efx);
+
+	/* Disable the ugly timer-based TX DMA backoff and allow TX DMA to be
+	 * controlled by the RX FIFO fill level. Set arbitration to one pkt/Q.
+	 */
+	efx_reado(efx, &temp, FR_AZ_TX_RESERVED);
+	EFX_SET_OWORD_FIELD(temp, FRF_AZ_TX_RX_SPACER, 0xfe);
+	EFX_SET_OWORD_FIELD(temp, FRF_AZ_TX_RX_SPACER_EN, 1);
+	EFX_SET_OWORD_FIELD(temp, FRF_AZ_TX_ONE_PKT_PER_Q, 1);
+	EFX_SET_OWORD_FIELD(temp, FRF_AZ_TX_PUSH_EN, 1);
+	EFX_SET_OWORD_FIELD(temp, FRF_AZ_TX_DIS_NON_IP_EV, 1);
+	/* Enable SW_EV to inherit in char driver - assume harmless here */
+	EFX_SET_OWORD_FIELD(temp, FRF_AZ_TX_SOFT_EVT_EN, 1);
+	/* Prefetch threshold 2 => fetch when descriptor cache half empty */
+	EFX_SET_OWORD_FIELD(temp, FRF_AZ_TX_PREF_THRESHOLD, 2);
+	/* Disable hardware watchdog which can misfire */
+	EFX_SET_OWORD_FIELD(temp, FRF_AZ_TX_PREF_WD_TMR, 0x3fffff);
+	/* Squash TX of packets of 16 bytes or less */
+	if (efx_nic_rev(efx) >= EFX_REV_FALCON_B0)
+		EFX_SET_OWORD_FIELD(temp, FRF_BZ_TX_FLUSH_MIN_LEN_EN, 1);
+	efx_writeo(efx, &temp, FR_AZ_TX_RESERVED);
+}
+
+unsigned
+efx_nic_check_pcie_link(struct efx_nic *efx,
+			unsigned full_width, unsigned full_speed)
+{
+	int cap = pci_find_capability(efx->pci_dev, PCI_CAP_ID_EXP);
+	u16 stat;
+	unsigned width, speed;
+
+	if (!cap ||
+	    pci_read_config_word(efx->pci_dev, cap + PCI_EXP_LNKSTA, &stat))
+		return 0;
+
+	width = (stat & PCI_EXP_LNKSTA_NLW) >> __ffs(PCI_EXP_LNKSTA_NLW);
+	EFX_WARN_ON_PARANOID(width == 0 || width > full_width);
+	speed = stat & PCI_EXP_LNKSTA_CLS;
+	EFX_WARN_ON_PARANOID(speed == 0 || speed > full_speed);
+
+	if (width < full_width || speed < full_speed)
+
+		netif_warn(efx, drv, efx->net_dev,
+			   "This Solarflare Network Adapter requires a "
+			   "slot with %d lanes at PCI Express %d speed for "
+			   "full performance, but is currently limited to "
+			   "%d lanes at PCI Express %d speed. Consult your "
+			   "motherboard documentation to find a more "
+			   "suitable slot\n",
+			   full_width, full_speed, width, speed);
+
+	return width;
+}
+
+/* Register dump */
+
+#define REGISTER_REVISION_A	1
+#define REGISTER_REVISION_B	2
+#define REGISTER_REVISION_C	3
+#define REGISTER_REVISION_Z	3	/* latest revision */
+
+struct efx_nic_reg {
+	u32 offset:24;
+	u32 min_revision:2, max_revision:2;
+};
+
+#define REGISTER(name, min_rev, max_rev) {				\
+	FR_ ## min_rev ## max_rev ## _ ## name,				\
+	REGISTER_REVISION_ ## min_rev, REGISTER_REVISION_ ## max_rev	\
+}
+#define REGISTER_AA(name) REGISTER(name, A, A)
+#define REGISTER_AB(name) REGISTER(name, A, B)
+#define REGISTER_AZ(name) REGISTER(name, A, Z)
+#define REGISTER_BB(name) REGISTER(name, B, B)
+#define REGISTER_BZ(name) REGISTER(name, B, Z)
+#define REGISTER_CZ(name) REGISTER(name, C, Z)
+
+static const struct efx_nic_reg efx_nic_regs[] = {
+	REGISTER_AZ(ADR_REGION),
+	REGISTER_AZ(INT_EN_KER),
+	REGISTER_BZ(INT_EN_CHAR),
+	REGISTER_AZ(INT_ADR_KER),
+	REGISTER_BZ(INT_ADR_CHAR),
+	/* INT_ACK_KER is WO */
+	/* INT_ISR0 is RC */
+	REGISTER_AZ(HW_INIT),
+	REGISTER_CZ(USR_EV_CFG),
+	REGISTER_AB(EE_SPI_HCMD),
+	REGISTER_AB(EE_SPI_HADR),
+	REGISTER_AB(EE_SPI_HDATA),
+	REGISTER_AB(EE_BASE_PAGE),
+	REGISTER_AB(EE_VPD_CFG0),
+	/* EE_VPD_SW_CNTL and EE_VPD_SW_DATA are not used */
+	/* PMBX_DBG_IADDR and PBMX_DBG_IDATA are indirect */
+	/* PCIE_CORE_INDIRECT is indirect */
+	REGISTER_AB(NIC_STAT),
+	REGISTER_AB(GPIO_CTL),
+	REGISTER_AB(GLB_CTL),
+	/* FATAL_INTR_KER and FATAL_INTR_CHAR are partly RC */
+	REGISTER_BZ(DP_CTRL),
+	REGISTER_AZ(MEM_STAT),
+	REGISTER_AZ(CS_DEBUG),
+	REGISTER_AZ(ALTERA_BUILD),
+	REGISTER_AZ(CSR_SPARE),
+	REGISTER_AB(PCIE_SD_CTL0123),
+	REGISTER_AB(PCIE_SD_CTL45),
+	REGISTER_AB(PCIE_PCS_CTL_STAT),
+	/* DEBUG_DATA_OUT is not used */
+	/* DRV_EV is WO */
+	REGISTER_AZ(EVQ_CTL),
+	REGISTER_AZ(EVQ_CNT1),
+	REGISTER_AZ(EVQ_CNT2),
+	REGISTER_AZ(BUF_TBL_CFG),
+	REGISTER_AZ(SRM_RX_DC_CFG),
+	REGISTER_AZ(SRM_TX_DC_CFG),
+	REGISTER_AZ(SRM_CFG),
+	/* BUF_TBL_UPD is WO */
+	REGISTER_AZ(SRM_UPD_EVQ),
+	REGISTER_AZ(SRAM_PARITY),
+	REGISTER_AZ(RX_CFG),
+	REGISTER_BZ(RX_FILTER_CTL),
+	/* RX_FLUSH_DESCQ is WO */
+	REGISTER_AZ(RX_DC_CFG),
+	REGISTER_AZ(RX_DC_PF_WM),
+	REGISTER_BZ(RX_RSS_TKEY),
+	/* RX_NODESC_DROP is RC */
+	REGISTER_AA(RX_SELF_RST),
+	/* RX_DEBUG, RX_PUSH_DROP are not used */
+	REGISTER_CZ(RX_RSS_IPV6_REG1),
+	REGISTER_CZ(RX_RSS_IPV6_REG2),
+	REGISTER_CZ(RX_RSS_IPV6_REG3),
+	/* TX_FLUSH_DESCQ is WO */
+	REGISTER_AZ(TX_DC_CFG),
+	REGISTER_AA(TX_CHKSM_CFG),
+	REGISTER_AZ(TX_CFG),
+	/* TX_PUSH_DROP is not used */
+	REGISTER_AZ(TX_RESERVED),
+	REGISTER_BZ(TX_PACE),
+	/* TX_PACE_DROP_QID is RC */
+	REGISTER_BB(TX_VLAN),
+	REGISTER_BZ(TX_IPFIL_PORTEN),
+	REGISTER_AB(MD_TXD),
+	REGISTER_AB(MD_RXD),
+	REGISTER_AB(MD_CS),
+	REGISTER_AB(MD_PHY_ADR),
+	REGISTER_AB(MD_ID),
+	/* MD_STAT is RC */
+	REGISTER_AB(MAC_STAT_DMA),
+	REGISTER_AB(MAC_CTRL),
+	REGISTER_BB(GEN_MODE),
+	REGISTER_AB(MAC_MC_HASH_REG0),
+	REGISTER_AB(MAC_MC_HASH_REG1),
+	REGISTER_AB(GM_CFG1),
+	REGISTER_AB(GM_CFG2),
+	/* GM_IPG and GM_HD are not used */
+	REGISTER_AB(GM_MAX_FLEN),
+	/* GM_TEST is not used */
+	REGISTER_AB(GM_ADR1),
+	REGISTER_AB(GM_ADR2),
+	REGISTER_AB(GMF_CFG0),
+	REGISTER_AB(GMF_CFG1),
+	REGISTER_AB(GMF_CFG2),
+	REGISTER_AB(GMF_CFG3),
+	REGISTER_AB(GMF_CFG4),
+	REGISTER_AB(GMF_CFG5),
+	REGISTER_BB(TX_SRC_MAC_CTL),
+	REGISTER_AB(XM_ADR_LO),
+	REGISTER_AB(XM_ADR_HI),
+	REGISTER_AB(XM_GLB_CFG),
+	REGISTER_AB(XM_TX_CFG),
+	REGISTER_AB(XM_RX_CFG),
+	REGISTER_AB(XM_MGT_INT_MASK),
+	REGISTER_AB(XM_FC),
+	REGISTER_AB(XM_PAUSE_TIME),
+	REGISTER_AB(XM_TX_PARAM),
+	REGISTER_AB(XM_RX_PARAM),
+	/* XM_MGT_INT_MSK (note no 'A') is RC */
+	REGISTER_AB(XX_PWR_RST),
+	REGISTER_AB(XX_SD_CTL),
+	REGISTER_AB(XX_TXDRV_CTL),
+	/* XX_PRBS_CTL, XX_PRBS_CHK and XX_PRBS_ERR are not used */
+	/* XX_CORE_STAT is partly RC */
+};
+
+struct efx_nic_reg_table {
+	u32 offset:24;
+	u32 min_revision:2, max_revision:2;
+	u32 step:6, rows:21;
+};
+
+#define REGISTER_TABLE_DIMENSIONS(_, offset, min_rev, max_rev, step, rows) { \
+	offset,								\
+	REGISTER_REVISION_ ## min_rev, REGISTER_REVISION_ ## max_rev,	\
+	step, rows							\
+}
+#define REGISTER_TABLE(name, min_rev, max_rev) 				\
+	REGISTER_TABLE_DIMENSIONS(					\
+		name, FR_ ## min_rev ## max_rev ## _ ## name,		\
+		min_rev, max_rev,					\
+		FR_ ## min_rev ## max_rev ## _ ## name ## _STEP,	\
+		FR_ ## min_rev ## max_rev ## _ ## name ## _ROWS)
+#define REGISTER_TABLE_AA(name) REGISTER_TABLE(name, A, A)
+#define REGISTER_TABLE_AZ(name) REGISTER_TABLE(name, A, Z)
+#define REGISTER_TABLE_BB(name) REGISTER_TABLE(name, B, B)
+#define REGISTER_TABLE_BZ(name) REGISTER_TABLE(name, B, Z)
+#define REGISTER_TABLE_BB_CZ(name)					\
+	REGISTER_TABLE_DIMENSIONS(name, FR_BZ_ ## name, B, B,		\
+				  FR_BZ_ ## name ## _STEP,		\
+				  FR_BB_ ## name ## _ROWS),		\
+	REGISTER_TABLE_DIMENSIONS(name, FR_BZ_ ## name, C, Z,		\
+				  FR_BZ_ ## name ## _STEP,		\
+				  FR_CZ_ ## name ## _ROWS)
+#define REGISTER_TABLE_CZ(name) REGISTER_TABLE(name, C, Z)
+
+static const struct efx_nic_reg_table efx_nic_reg_tables[] = {
+	/* DRIVER is not used */
+	/* EVQ_RPTR, TIMER_COMMAND, USR_EV and {RX,TX}_DESC_UPD are WO */
+	REGISTER_TABLE_BB(TX_IPFIL_TBL),
+	REGISTER_TABLE_BB(TX_SRC_MAC_TBL),
+	REGISTER_TABLE_AA(RX_DESC_PTR_TBL_KER),
+	REGISTER_TABLE_BB_CZ(RX_DESC_PTR_TBL),
+	REGISTER_TABLE_AA(TX_DESC_PTR_TBL_KER),
+	REGISTER_TABLE_BB_CZ(TX_DESC_PTR_TBL),
+	REGISTER_TABLE_AA(EVQ_PTR_TBL_KER),
+	REGISTER_TABLE_BB_CZ(EVQ_PTR_TBL),
+	/* We can't reasonably read all of the buffer table (up to 8MB!).
+	 * However this driver will only use a few entries.  Reading
+	 * 1K entries allows for some expansion of queue count and
+	 * size before we need to change the version. */
+	REGISTER_TABLE_DIMENSIONS(BUF_FULL_TBL_KER, FR_AA_BUF_FULL_TBL_KER,
+				  A, A, 8, 1024),
+	REGISTER_TABLE_DIMENSIONS(BUF_FULL_TBL, FR_BZ_BUF_FULL_TBL,
+				  B, Z, 8, 1024),
+	REGISTER_TABLE_CZ(RX_MAC_FILTER_TBL0),
+	REGISTER_TABLE_BB_CZ(TIMER_TBL),
+	REGISTER_TABLE_BB_CZ(TX_PACE_TBL),
+	REGISTER_TABLE_BZ(RX_INDIRECTION_TBL),
+	/* TX_FILTER_TBL0 is huge and not used by this driver */
+	REGISTER_TABLE_CZ(TX_MAC_FILTER_TBL0),
+	REGISTER_TABLE_CZ(MC_TREG_SMEM),
+	/* MSIX_PBA_TABLE is not mapped */
+	/* SRM_DBG is not mapped (and is redundant with BUF_FLL_TBL) */
+#if !defined(EFX_USE_KCOMPAT) || defined(EFX_HAVE_VMALLOC_REG_DUMP_BUF)
+	REGISTER_TABLE_BZ(RX_FILTER_TBL0),
+#endif
+};
+
+size_t efx_nic_get_regs_len(struct efx_nic *efx)
+{
+	const struct efx_nic_reg *reg;
+	const struct efx_nic_reg_table *table;
+	size_t len = 0;
+
+	for (reg = efx_nic_regs;
+	     reg < efx_nic_regs + ARRAY_SIZE(efx_nic_regs);
+	     reg++)
+		if (efx->type->revision >= reg->min_revision &&
+		    efx->type->revision <= reg->max_revision)
+			len += sizeof(efx_oword_t);
+
+	for (table = efx_nic_reg_tables;
+	     table < efx_nic_reg_tables + ARRAY_SIZE(efx_nic_reg_tables);
+	     table++)
+		if (efx->type->revision >= table->min_revision &&
+		    efx->type->revision <= table->max_revision)
+			len += table->rows * min_t(size_t, table->step, 16);
+
+	return len;
+}
+
+void efx_nic_get_regs(struct efx_nic *efx, void *buf)
+{
+	const struct efx_nic_reg *reg;
+	const struct efx_nic_reg_table *table;
+
+	for (reg = efx_nic_regs;
+	     reg < efx_nic_regs + ARRAY_SIZE(efx_nic_regs);
+	     reg++) {
+		if (efx->type->revision >= reg->min_revision &&
+		    efx->type->revision <= reg->max_revision) {
+			efx_reado(efx, (efx_oword_t *)buf, reg->offset);
+			buf += sizeof(efx_oword_t);
+		}
+	}
+
+	for (table = efx_nic_reg_tables;
+	     table < efx_nic_reg_tables + ARRAY_SIZE(efx_nic_reg_tables);
+	     table++) {
+		size_t size, i;
+
+		if (!(efx->type->revision >= table->min_revision &&
+		      efx->type->revision <= table->max_revision))
+			continue;
+
+		size = min_t(size_t, table->step, 16);
+
+		for (i = 0; i < table->rows; i++) {
+			switch (table->step) {
+			case 4: /* 32-bit register or SRAM */
+				efx_readd_table(efx, buf, table->offset, i);
+				break;
+			case 8: /* 64-bit SRAM */
+				efx_sram_readq(efx,
+					       efx->membase + table->offset,
+					       buf, i);
+				break;
+			case 16: /* 128-bit register */
+				efx_reado_table(efx, buf, table->offset, i);
+				break;
+			case 32: /* 128-bit register, interleaved */
+				efx_reado_table(efx, buf, table->offset, 2 * i);
+				break;
+			default:
+				WARN_ON(1);
+				return;
+			}
+			buf += size;
+		}
+	}
+}
diff -r 5b3d4d3c1166 drivers/net/sfc/nic.h
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/drivers/net/sfc/nic.h	Tue Nov 09 10:06:27 2010 +0000
@@ -0,0 +1,363 @@
+/****************************************************************************
+ * Driver for Solarflare Solarstorm network controllers and boards
+ * Copyright 2005-2006 Fen Systems Ltd.
+ * Copyright 2006-2009 Solarflare Communications Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 as published
+ * by the Free Software Foundation, incorporated herein by reference.
+ */
+
+#ifndef EFX_NIC_H
+#define EFX_NIC_H
+
+#include <linux/i2c-algo-bit.h>
+#include <linux/timer.h>
+
+#include "net_driver.h"
+#include "efx.h"
+#include "mcdi.h"
+
+/*
+ * Falcon hardware control
+ */
+
+enum {
+	EFX_REV_FALCON_A0 = 0,
+	EFX_REV_FALCON_A1 = 1,
+	EFX_REV_FALCON_B0 = 2,
+	EFX_REV_SIENA_A0 = 3,
+};
+
+static inline int efx_nic_rev(struct efx_nic *efx)
+{
+	return efx->type->revision;
+}
+
+extern u32 efx_nic_fpga_ver(struct efx_nic *efx);
+
+/* NIC has two interlinked PCI functions for the same port. */
+static inline bool efx_nic_is_dual_func(struct efx_nic *efx)
+{
+	return efx_nic_rev(efx) < EFX_REV_FALCON_B0;
+}
+
+enum {
+	PHY_TYPE_NONE = 0,
+	PHY_TYPE_TXC43128 = 1,
+	PHY_TYPE_88E1111 = 2,
+	PHY_TYPE_SFX7101 = 3,
+	PHY_TYPE_QT2022C2 = 4,
+	PHY_TYPE_PM8358 = 6,
+	PHY_TYPE_SFT9001A = 8,
+	PHY_TYPE_QT2025C = 9,
+	PHY_TYPE_SFT9001B = 10,
+};
+
+#define FALCON_XMAC_LOOPBACKS			\
+	((1 << LOOPBACK_XGMII) |		\
+	 (1 << LOOPBACK_XGXS) |			\
+	 (1 << LOOPBACK_XAUI))
+
+#define FALCON_GMAC_LOOPBACKS			\
+	(1 << LOOPBACK_GMAC)
+
+/* Size and alignment of buffer table entries (4KB) */
+#define EFX_BUF_SIZE 4096
+
+/**
+ * struct falcon_board_type - board operations and type information
+ * @id: Board type id, as found in NVRAM
+ * @ref_model: Model number of Solarflare reference design
+ * @gen_type: Generic board type description
+ * @init: Allocate resources and initialise peripheral hardware
+ * @init_phy: Do board-specific PHY initialisation
+ * @fini: Shut down hardware and free resources
+ * @set_id_led: Set state of identifying LED or revert to automatic function
+ * @monitor: Board-specific health check function
+ */
+struct falcon_board_type {
+	u8 id;
+	const char *ref_model;
+	const char *gen_type;
+	int (*init) (struct efx_nic *nic);
+	void (*init_phy) (struct efx_nic *efx);
+	void (*fini) (struct efx_nic *nic);
+	void (*set_id_led) (struct efx_nic *efx, enum efx_led_mode mode);
+	int (*monitor) (struct efx_nic *nic);
+};
+
+/**
+ * struct falcon_board - board information
+ * @type: Type of board
+ * @major: Major rev. ('A', 'B' ...)
+ * @minor: Minor rev. (0, 1, ...)
+ * @i2c_adap: I2C adapter for on-board peripherals
+ * @i2c_data: Data for bit-banging algorithm
+ * @hwmon_client: I2C client for hardware monitor
+ * @ioexp_client: I2C client for power/port control
+ */
+struct falcon_board {
+	const struct falcon_board_type *type;
+	int major;
+	int minor;
+#ifdef CONFIG_SFC_I2C
+	struct i2c_adapter i2c_adap;
+	struct i2c_algo_bit_data i2c_data;
+	struct i2c_client *hwmon_client;
+#if defined(CONFIG_SFC_SFE4001) || defined(CONFIG_SFC_SFE4005)
+	struct i2c_client *ioexp_client;
+#endif
+#endif
+};
+
+/**
+ * struct falcon_nic_data - Falcon NIC state
+ * @sram_config: NIC SRAM configuration code
+ * @pci_dev2: Secondary function of Falcon A
+ * @board: Board state and functions
+ * @stats_disable_count: Nest count for disabling statistics fetches
+ * @stats_pending: Is there a pending DMA of MAC statistics.
+ * @stats_timer: A timer for regularly fetching MAC statistics.
+ * @stats_dma_done: Pointer to the flag which indicates DMA completion.
+ */
+struct falcon_nic_data {
+	int sram_config;
+	struct pci_dev *pci_dev2;
+	struct falcon_board board;
+	unsigned int stats_disable_count;
+	bool stats_pending;
+	struct timer_list stats_timer;
+	u32 *stats_dma_done;
+};
+
+static inline struct falcon_board *falcon_board(struct efx_nic *efx)
+{
+	struct falcon_nic_data *nic_data;
+	EFX_BUG_ON_PARANOID(efx_nic_rev(efx) > EFX_REV_FALCON_B0);
+	nic_data = efx->nic_data;
+	return &nic_data->board;
+}
+
+/**
+ * struct siena_nic_data - Siena NIC state
+ * @mcdi: Management-Controller-to-Driver Interface
+ * @wol_filter_id: Wake-on-LAN packet filter id
+ * @ipv6_rss_key: Toeplitz hash key for IPv6 RSS
+ */
+struct siena_nic_data {
+	struct efx_mcdi_iface mcdi;
+	int wol_filter_id;
+};
+
+extern void siena_print_fwver(struct efx_nic *efx, char *buf, size_t len);
+
+/* Maximum VI_SCALE parameter supported by Siena */
+#define EFX_VI_SCALE_MAX 6
+/* Base VI to use for SR-IOV. Must be aligned to (1 << EFX_VI_SCALE_MAX),
+ * so this is the smallest allowed value. */
+#define EFX_VI_BASE 64
+/* Maximum number of VFs allowed */
+#define EFX_VF_COUNT_MAX 127
+
+#ifdef CONFIG_SFC_SRIOV
+extern void efx_sriov_probe(struct efx_nic *efx);
+extern int efx_sriov_init(struct efx_nic *efx);
+extern void efx_sriov_mac_address_changed(struct efx_nic *efx);
+extern void efx_sriov_tx_flush_done(struct efx_nic *efx, efx_qword_t *event);
+extern void efx_sriov_rx_flush_done(struct efx_nic *efx, efx_qword_t *event);
+extern void efx_sriov_event(struct efx_channel *channel, efx_qword_t *event);
+extern void efx_sriov_flr(struct efx_nic *efx, unsigned flr);
+extern void efx_sriov_fini(struct efx_nic *efx);
+#else
+static inline void efx_sriov_probe(struct efx_nic *efx) {}
+static inline int efx_sriov_init(struct efx_nic *efx) { return -EOPNOTSUPP; }
+static inline void efx_sriov_mac_address_changed(struct efx_nic *efx) {}
+static inline void efx_sriov_tx_flush_done(struct efx_nic *efx,
+					   efx_qword_t *event) {}
+static inline void efx_sriov_rx_flush_done(struct efx_nic *efx,
+					   efx_qword_t *event) {}
+static inline void efx_sriov_event(struct efx_channel *channel,
+				   efx_qword_t *event) {}
+static inline void efx_sriov_flr(struct efx_nic *efx, unsigned flr) {}
+static inline void efx_sriov_fini(struct efx_nic *efx) {}
+#endif
+
+#if !defined(EFX_USE_KCOMPAT) || defined(EFX_HAVE_NDO_SET_VF_MAC)
+extern int efx_sriov_set_vf_mac(struct net_device *dev, int vf, u8 *mac);
+extern int efx_sriov_set_vf_vlan(struct net_device *dev, int vf,
+				 u16 vlan, u8 qos);
+extern int efx_sriov_get_vf_config(struct net_device *dev, int vf,
+				   struct ifla_vf_info *ivf);
+#endif
+
+extern struct efx_nic_type falcon_a1_nic_type;
+extern struct efx_nic_type falcon_b0_nic_type;
+extern struct efx_nic_type siena_a0_nic_type;
+
+/**************************************************************************
+ *
+ * Externs
+ *
+ **************************************************************************
+ */
+
+extern int falcon_probe_board(struct efx_nic *efx, u16 revision_info);
+#ifdef EFX_NOT_UPSTREAM
+extern void falcon_probe_dummy_board(struct efx_nic *efx);
+#endif
+
+/* TX data path */
+extern int efx_nic_probe_tx(struct efx_tx_queue *tx_queue);
+extern void efx_nic_init_tx(struct efx_tx_queue *tx_queue);
+extern void efx_nic_fini_tx(struct efx_tx_queue *tx_queue);
+extern void efx_nic_remove_tx(struct efx_tx_queue *tx_queue);
+#if defined(EFX_USE_KCOMPAT) && defined(EFX_USE_FASTCALL)
+extern void fastcall efx_nic_push_buffers(struct efx_tx_queue *tx_queue);
+#else
+extern void efx_nic_push_buffers(struct efx_tx_queue *tx_queue);
+#endif
+
+/* RX data path */
+extern int efx_nic_probe_rx(struct efx_rx_queue *rx_queue);
+extern void efx_nic_init_rx(struct efx_rx_queue *rx_queue);
+extern void efx_nic_fini_rx(struct efx_rx_queue *rx_queue);
+extern void efx_nic_remove_rx(struct efx_rx_queue *rx_queue);
+#if defined(EFX_USE_KCOMPAT) && defined(EFX_USE_FASTCALL)
+extern void fastcall efx_nic_notify_rx_desc(struct efx_rx_queue *rx_queue);
+#else
+extern void efx_nic_notify_rx_desc(struct efx_rx_queue *rx_queue);
+#endif
+
+/* Event data path */
+extern int efx_nic_probe_eventq(struct efx_channel *channel);
+extern void efx_nic_init_eventq(struct efx_channel *channel);
+extern void efx_nic_fini_eventq(struct efx_channel *channel);
+extern void efx_nic_remove_eventq(struct efx_channel *channel);
+#if defined(EFX_USE_KCOMPAT) && defined(EFX_USE_FASTCALL)
+extern int fastcall efx_nic_process_eventq(struct efx_channel *channel,
+					   int rx_quota);
+#else
+extern int efx_nic_process_eventq(struct efx_channel *channel, int rx_quota);
+#endif
+#if defined(EFX_USE_KCOMPAT) && defined(EFX_USE_FASTCALL)
+extern void fastcall efx_nic_eventq_read_ack(struct efx_channel *channel);
+#else
+extern void efx_nic_eventq_read_ack(struct efx_channel *channel);
+#endif
+
+/* MAC/PHY */
+extern void falcon_drain_tx_fifo(struct efx_nic *efx);
+extern void falcon_reconfigure_mac_wrapper(struct efx_nic *efx);
+extern int efx_nic_rx_xoff_thresh, efx_nic_rx_xon_thresh;
+
+/* Interrupts and test events */
+extern int efx_nic_init_interrupt(struct efx_nic *efx);
+extern void efx_nic_enable_interrupts(struct efx_nic *efx);
+extern void efx_nic_generate_test_event(struct efx_channel *channel);
+extern void efx_nic_generate_fill_event(struct efx_channel *channel);
+extern void efx_nic_generate_interrupt(struct efx_nic *efx);
+extern void efx_nic_disable_interrupts(struct efx_nic *efx);
+extern void efx_nic_fini_interrupt(struct efx_nic *efx);
+extern irqreturn_t efx_nic_fatal_interrupt(struct efx_nic *efx);
+#if !defined(EFX_USE_KCOMPAT) || !defined(EFX_HAVE_IRQ_HANDLER_REGS)
+extern irqreturn_t falcon_legacy_interrupt_a1(int irq, void *dev_id);
+#else
+extern irqreturn_t falcon_legacy_interrupt_a1(int irq, void *dev_id,
+					      struct pt_regs *);
+#endif
+extern void falcon_irq_ack_a1(struct efx_nic *efx);
+
+#define EFX_IRQ_MOD_RESOLUTION 5
+
+/* Global Resources */
+extern int efx_nic_flush_queues(struct efx_nic *efx);
+extern void falcon_start_nic_stats(struct efx_nic *efx);
+extern void falcon_stop_nic_stats(struct efx_nic *efx);
+extern void falcon_setup_xaui(struct efx_nic *efx);
+extern int falcon_reset_xaui(struct efx_nic *efx);
+extern void falcon_reset_phy(struct efx_nic *efx);
+extern int efx_nic_dimension_resources(struct efx_nic *efx, size_t sram_size,
+				       unsigned used_vi_count);
+extern void efx_nic_init_common(struct efx_nic *efx);
+extern void efx_nic_push_rx_indir_table(struct efx_nic *efx);
+extern unsigned efx_nic_check_pcie_link(struct efx_nic *efx,
+					unsigned full_width,
+					unsigned full_speed);
+#ifdef EFX_NOT_UPSTREAM
+extern int efx_nic_test_biu(struct efx_nic *efx);
+extern unsigned int efx_nic_no_resets;
+extern int efx_ignore_nvconfig;
+#endif
+
+int efx_nic_alloc_buffer(struct efx_nic *efx, struct efx_buffer *buffer,
+			 unsigned int len);
+void efx_nic_free_buffer(struct efx_nic *efx, struct efx_buffer *buffer);
+
+/* Tests */
+struct efx_nic_register_test {
+	unsigned address;
+	efx_oword_t mask;
+};
+struct efx_nic_table_test {
+	unsigned address;
+	unsigned step;
+	unsigned rows;
+	efx_oword_t mask;
+};
+extern int efx_nic_test_registers(struct efx_nic *efx,
+				  const struct efx_nic_register_test *regs,
+				  size_t n_regs);
+extern int efx_nic_test_table(struct efx_nic *efx,
+			      const struct efx_nic_table_test *table,
+			      void (*pattern)(unsigned, efx_qword_t *, int, int),
+			      int a, int b);
+
+extern size_t efx_nic_get_regs_len(struct efx_nic *efx);
+extern void efx_nic_get_regs(struct efx_nic *efx, void *buf);
+
+/**************************************************************************
+ *
+ * Falcon MAC stats
+ *
+ **************************************************************************
+ */
+
+#define FALCON_STAT_OFFSET(falcon_stat) EFX_VAL(falcon_stat, offset)
+#define FALCON_STAT_WIDTH(falcon_stat) EFX_VAL(falcon_stat, WIDTH)
+
+/* Retrieve statistic from statistics block */
+#define FALCON_STAT(efx, falcon_stat, efx_stat) do {		\
+	if (FALCON_STAT_WIDTH(falcon_stat) == 16)		\
+		(efx)->mac_stats.efx_stat += le16_to_cpu(	\
+			*((__force __le16 *)				\
+			  (efx->stats_buffer.addr +		\
+			   FALCON_STAT_OFFSET(falcon_stat))));	\
+	else if (FALCON_STAT_WIDTH(falcon_stat) == 32)		\
+		(efx)->mac_stats.efx_stat += le32_to_cpu(	\
+			*((__force __le32 *)				\
+			  (efx->stats_buffer.addr +		\
+			   FALCON_STAT_OFFSET(falcon_stat))));	\
+	else							\
+		(efx)->mac_stats.efx_stat += le64_to_cpu(	\
+			*((__force __le64 *)				\
+			  (efx->stats_buffer.addr +		\
+			   FALCON_STAT_OFFSET(falcon_stat))));	\
+	} while (0)
+
+#define FALCON_MAC_STATS_SIZE 0x100
+
+#define MAC_DATA_LBN 0
+#define MAC_DATA_WIDTH 32
+
+extern void efx_generate_event(struct efx_nic *efx, unsigned int evq,
+			       efx_qword_t *event);
+
+#ifdef CONFIG_SFC_DEBUGFS
+struct seq_file;
+extern int efx_nic_debugfs_read_desc(struct seq_file *file, void *data);
+#endif
+
+extern void falcon_poll_xmac(struct efx_nic *efx);
+
+#endif /* EFX_NIC_H */
diff -r 5b3d4d3c1166 drivers/net/sfc/pcap.h
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/drivers/net/sfc/pcap.h	Tue Nov 09 10:06:27 2010 +0000
@@ -0,0 +1,17 @@
+/****************************************************************************
+ * Driver for Solarflare Solarstorm network controllers and boards
+ * Copyright 2007 Solarflare Communications Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 as published
+ * by the Free Software Foundation, incorporated herein by reference.
+ */
+
+#ifndef EFX_PCAP_H
+#define EFX_PCAP_H
+
+extern int efx_pcap_nic_init(struct efx_nic *efx);
+void efx_pcap_nic_fini(struct efx_nic *efx);
+extern void efx_capture_packet(struct efx_nic *efx, u8 *data, int len);
+
+#endif
diff -r 5b3d4d3c1166 drivers/net/sfc/phy.h
--- a/drivers/net/sfc/phy.h	Fri Nov 05 15:20:28 2010 +0000
+++ b/drivers/net/sfc/phy.h	Tue Nov 09 10:06:27 2010 +0000
@@ -1,6 +1,6 @@
 /****************************************************************************
  * Driver for Solarflare Solarstorm network controllers and boards
- * Copyright 2007-2008 Solarflare Communications Inc.
+ * Copyright 2007-2009 Solarflare Communications Inc.
  *
  * This program is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 as published
@@ -11,21 +11,16 @@
 #define EFX_PHY_H
 
 /****************************************************************************
- * 10Xpress (SFX7101 and SFT9001) PHYs
+ * 10Xpress (SFX7101) PHY
  */
 extern struct efx_phy_operations falcon_sfx7101_phy_ops;
-extern struct efx_phy_operations falcon_sft9001_phy_ops;
 
-extern void tenxpress_phy_blink(struct efx_nic *efx, bool blink);
-
-/* Wait for the PHY to boot. Return 0 on success, -EINVAL if the PHY failed
- * to boot due to corrupt flash, or some other negative error code. */
-extern int sft9001_wait_boot(struct efx_nic *efx);
+extern void tenxpress_set_id_led(struct efx_nic *efx, enum efx_led_mode mode);
 
 /****************************************************************************
- * AMCC/Quake QT20xx PHYs
+ * AMCC/Quake QT202x PHYs
  */
-extern struct efx_phy_operations falcon_xfp_phy_ops;
+extern struct efx_phy_operations falcon_qt202x_phy_ops;
 
 /* These PHYs provide various H/W control states for LEDs */
 #define QUAKE_LED_LINK_INVAL	(0)
@@ -39,6 +34,34 @@ extern struct efx_phy_operations falcon_
 #define QUAKE_LED_TXLINK	(0)
 #define QUAKE_LED_RXLINK	(8)
 
-extern void xfp_set_led(struct efx_nic *p, int led, int state);
+extern void falcon_qt202x_set_led(struct efx_nic *p, int led, int state);
+
+/****************************************************************************
+* Transwitch CX4 retimer
+*/
+extern struct efx_phy_operations falcon_txc_phy_ops;
+
+#define TXC_GPIO_DIR_INPUT	0
+#define TXC_GPIO_DIR_OUTPUT	1
+
+extern void falcon_txc_set_gpio_dir(struct efx_nic *efx, int pin, int dir);
+extern void falcon_txc_set_gpio_val(struct efx_nic *efx, int pin, int val);
+
+/****************************************************************************
+ * Siena managed PHYs
+ */
+extern struct efx_phy_operations efx_mcdi_phy_ops;
+
+extern int efx_mcdi_mdio_read(struct efx_nic *efx, unsigned int bus,
+			      unsigned int prtad, unsigned int devad,
+			      u16 addr, u16 *value_out, u32 *status_out);
+extern int efx_mcdi_mdio_write(struct efx_nic *efx, unsigned int bus,
+			       unsigned int prtad, unsigned int devad,
+			       u16 addr, u16 value, u32 *status_out);
+extern void efx_mcdi_phy_decode_link(struct efx_nic *efx,
+				     struct efx_link_state *link_state,
+				     u32 speed, u32 flags, u32 fcntl);
+extern int efx_mcdi_phy_reconfigure(struct efx_nic *efx);
+extern void efx_mcdi_phy_check_fcntl(struct efx_nic *efx, u32 lpa);
 
 #endif
diff -r 5b3d4d3c1166 drivers/net/sfc/qt202x_phy.c
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/drivers/net/sfc/qt202x_phy.c	Tue Nov 09 10:06:27 2010 +0000
@@ -0,0 +1,477 @@
+/****************************************************************************
+ * Driver for Solarflare Solarstorm network controllers and boards
+ * Copyright 2006-2009 Solarflare Communications Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 as published
+ * by the Free Software Foundation, incorporated herein by reference.
+ */
+/*
+ * Driver for AMCC QT202x SFP+ and XFP adapters; see www.amcc.com for details
+ */
+
+#include <linux/slab.h>
+#include <linux/timer.h>
+#include <linux/delay.h>
+#include "efx.h"
+#include "mdio_10g.h"
+#include "phy.h"
+#include "nic.h"
+
+#define QT202X_REQUIRED_DEVS (MDIO_DEVS_PCS |		\
+			      MDIO_DEVS_PMAPMD |	\
+			      MDIO_DEVS_PHYXS)
+
+#define QT202X_LOOPBACKS ((1 << LOOPBACK_PCS) |		\
+			  (1 << LOOPBACK_PMAPMD) |	\
+			  (1 << LOOPBACK_PHYXS_WS))
+
+/****************************************************************************/
+/* Quake-specific MDIO registers */
+#define MDIO_QUAKE_LED0_REG	(0xD006)
+
+/* QT2025C only */
+#define PCS_FW_HEARTBEAT_REG	0xd7ee
+#define PCS_FW_HEARTB_LBN	0
+#define PCS_FW_HEARTB_WIDTH	8
+#define PCS_FW_PRODUCT_CODE_1	0xd7f0
+#define PCS_FW_VERSION_1	0xd7f3
+#define PCS_FW_BUILD_1		0xd7f6
+#define PCS_UC8051_STATUS_REG	0xd7fd
+#define PCS_UC_STATUS_LBN	0
+#define PCS_UC_STATUS_WIDTH	8
+#define PCS_UC_STATUS_FW_SAVE	0x20
+#define PMA_PMD_MODE_REG	0xc301
+#define PMA_PMD_RXIN_SEL_LBN	6
+#define PMA_PMD_FTX_CTRL2_REG	0xc309
+#define PMA_PMD_FTX_STATIC_LBN	13
+#define PMA_PMD_VEND1_REG	0xc001
+#define PMA_PMD_VEND1_LBTXD_LBN	15
+#define PCS_VEND1_REG	   	0xc000
+#define PCS_VEND1_LBTXD_LBN	5
+
+void falcon_qt202x_set_led(struct efx_nic *p, int led, int mode)
+{
+	int addr = MDIO_QUAKE_LED0_REG + led;
+	efx_mdio_write(p, MDIO_MMD_PMAPMD, addr, mode);
+}
+
+static int qt202x_phy_reconfigure(struct efx_nic *efx);
+
+struct qt202x_phy_data {
+	enum efx_phy_mode phy_mode;
+	bool bug17190_in_bad_state;
+	unsigned long bug17190_timer;
+	u32 firmware_ver;
+};
+
+#define QT2022C2_MAX_RESET_TIME 500
+#define QT2022C2_RESET_WAIT 10
+
+#define QT2025C_MAX_HEARTB_TIME (5 * HZ)
+#define QT2025C_HEARTB_WAIT 100
+#define QT2025C_MAX_FWSTART_TIME (25 * HZ / 10)
+#define QT2025C_FWSTART_WAIT 100
+
+#define BUG17190_INTERVAL (2 * HZ)
+
+static int qt2025c_wait_heartbeat(struct efx_nic *efx)
+{
+	unsigned long timeout = jiffies + QT2025C_MAX_HEARTB_TIME;
+	int reg, old_counter = 0;
+
+	/* Wait for firmware heartbeat to start */
+	for (;;) {
+		int counter;
+		reg = efx_mdio_read(efx, MDIO_MMD_PCS, PCS_FW_HEARTBEAT_REG);
+		if (reg < 0)
+			return reg;
+		counter = ((reg >> PCS_FW_HEARTB_LBN) &
+			    ((1 << PCS_FW_HEARTB_WIDTH) - 1));
+		if (old_counter == 0)
+			old_counter = counter;
+		else if (counter != old_counter)
+			break;
+		if (time_after(jiffies, timeout)) {
+			/* Some cables have EEPROMs that conflict with the
+			 * PHY's on-board EEPROM so it cannot load firmware */
+			netif_err(efx, hw, efx->net_dev,
+				  "If an SFP+ direct attach cable is"
+				  " connected, please check that it complies"
+				  " with the SFP+ specification\n");
+			return -ETIMEDOUT;
+		}
+		msleep(QT2025C_HEARTB_WAIT);
+	}
+
+	return 0;
+}
+
+static int qt2025c_wait_fw_status_good(struct efx_nic *efx)
+{
+	unsigned long timeout = jiffies + QT2025C_MAX_FWSTART_TIME;
+	int reg;
+
+	/* Wait for firmware status to look good */
+	for (;;) {
+		reg = efx_mdio_read(efx, MDIO_MMD_PCS, PCS_UC8051_STATUS_REG);
+		if (reg < 0)
+			return reg;
+		if ((reg &
+		     ((1 << PCS_UC_STATUS_WIDTH) - 1) << PCS_UC_STATUS_LBN) >=
+		    PCS_UC_STATUS_FW_SAVE)
+			break;
+		if (time_after(jiffies, timeout))
+			return -ETIMEDOUT;
+		msleep(QT2025C_FWSTART_WAIT);
+	}
+
+	return 0;
+}
+
+static void qt2025c_restart_firmware(struct efx_nic *efx)
+{
+	/* Restart microcontroller execution of firmware from RAM */
+	efx_mdio_write(efx, 3, 0xe854, 0x00c0);
+	efx_mdio_write(efx, 3, 0xe854, 0x0040);
+	msleep(50);
+}
+
+static int qt2025c_wait_reset(struct efx_nic *efx)
+{
+	int rc;
+
+	rc = qt2025c_wait_heartbeat(efx);
+	if (rc != 0)
+		return rc;
+
+	rc = qt2025c_wait_fw_status_good(efx);
+	if (rc == -ETIMEDOUT) {
+		/* Bug 17689: occasionally heartbeat starts but firmware status
+		 * code never progresses beyond 0x00.  Try again, once, after
+		 * restarting execution of the firmware image. */
+		netif_dbg(efx, hw, efx->net_dev,
+			  "bashing QT2025C microcontroller\n");
+		qt2025c_restart_firmware(efx);
+		rc = qt2025c_wait_heartbeat(efx);
+		if (rc != 0)
+			return rc;
+		rc = qt2025c_wait_fw_status_good(efx);
+	}
+
+	return rc;
+}
+
+static void qt2025c_firmware_id(struct efx_nic *efx)
+{
+	struct qt202x_phy_data *phy_data = efx->phy_data;
+	u8 firmware_id[9];
+	size_t i;
+
+	for (i = 0; i < sizeof(firmware_id); i++)
+		firmware_id[i] = efx_mdio_read(efx, MDIO_MMD_PCS,
+					       PCS_FW_PRODUCT_CODE_1 + i);
+	netif_info(efx, probe, efx->net_dev,
+		   "QT2025C firmware %xr%d v%d.%d.%d.%d [20%02d-%02d-%02d]\n",
+		   (firmware_id[0] << 8) | firmware_id[1], firmware_id[2],
+		   firmware_id[3] >> 4, firmware_id[3] & 0xf,
+		   firmware_id[4], firmware_id[5],
+		   firmware_id[6], firmware_id[7], firmware_id[8]);
+	phy_data->firmware_ver = ((firmware_id[3] & 0xf0) << 20) |
+				 ((firmware_id[3] & 0x0f) << 16) |
+				 (firmware_id[4] << 8) | firmware_id[5];
+}
+
+/* The PHY can get stuck in a state where it reports PHY_XS and PMA/PMD layers
+ * up, but PCS down (no block_lock).  If we notice this state persisting
+ * for a couple of seconds, we switch PMA/PMD loopback briefly on and then
+ * off again, which is normally sufficient to recover it.
+ */
+static void qt2025c_bug17190_workaround(struct efx_nic *efx)
+{
+	struct qt202x_phy_data *phy_data = efx->phy_data;
+
+	if (efx->link_state.up ||
+	    !efx_mdio_links_ok(efx, MDIO_DEVS_PMAPMD | MDIO_DEVS_PHYXS)) {
+		phy_data->bug17190_in_bad_state = false;
+		return;
+	}
+
+	if (!phy_data->bug17190_in_bad_state) {
+		phy_data->bug17190_in_bad_state = true;
+		phy_data->bug17190_timer = jiffies + BUG17190_INTERVAL;
+		return;
+	}
+
+	if (time_after_eq(jiffies, phy_data->bug17190_timer)) {
+		netif_dbg(efx, hw, efx->net_dev, "bashing QT2025C PMA/PMD\n");
+		efx_mdio_set_flag(efx, MDIO_MMD_PMAPMD, MDIO_CTRL1,
+				  MDIO_PMA_CTRL1_LOOPBACK, true);
+		msleep(100);
+		efx_mdio_set_flag(efx, MDIO_MMD_PMAPMD, MDIO_CTRL1,
+				  MDIO_PMA_CTRL1_LOOPBACK, false);
+		phy_data->bug17190_timer = jiffies + BUG17190_INTERVAL;
+	}
+}
+
+static int qt2025c_select_phy_mode(struct efx_nic *efx)
+{
+	struct qt202x_phy_data *phy_data = efx->phy_data;
+	struct falcon_board *board = falcon_board(efx);
+	int reg, rc, i;
+	uint16_t phy_op_mode;
+
+	/* Only 2.0.1.0+ PHY firmware supports the more optimal SFP+
+	 * Self-Configure mode.  Don't attempt any switching if we encounter
+	 * older firmware. */
+	if (phy_data->firmware_ver < 0x02000100)
+		return 0;
+
+	/* In general we will get optimal behaviour in "SFP+ Self-Configure"
+	 * mode; however, that powers down most of the PHY when no module is
+	 * present, so we must use a different mode (any fixed mode will do)
+	 * to be sure that loopbacks will work. */
+	phy_op_mode = (efx->loopback_mode == LOOPBACK_NONE) ? 0x0038 : 0x0020;
+
+	/* Only change mode if really necessary */
+	reg = efx_mdio_read(efx, 1, 0xc319);
+	if ((reg & 0x0038) == phy_op_mode)
+		return 0;
+	netif_dbg(efx, hw, efx->net_dev, "Switching PHY to mode 0x%04x\n",
+		  phy_op_mode);
+
+	/* This sequence replicates the register writes configured in the boot
+	 * EEPROM (including the differences between board revisions), except
+	 * that the operating mode is changed, and the PHY is prevented from
+	 * unnecessarily reloading the main firmware image again. */
+	efx_mdio_write(efx, 1, 0xc300, 0x0000);
+	/* (Note: this portion of the boot EEPROM sequence, which bit-bashes 9
+	 * STOPs onto the firmware/module I2C bus to reset it, varies across
+	 * board revisions, as the bus is connected to different GPIO/LED
+	 * outputs on the PHY.) */
+	if (board->major == 0 && board->minor < 2) {
+		efx_mdio_write(efx, 1, 0xc303, 0x4498);
+		for (i = 0; i < 9; i++) {
+			efx_mdio_write(efx, 1, 0xc303, 0x4488);
+			efx_mdio_write(efx, 1, 0xc303, 0x4480);
+			efx_mdio_write(efx, 1, 0xc303, 0x4490);
+			efx_mdio_write(efx, 1, 0xc303, 0x4498);
+		}
+	} else {
+		efx_mdio_write(efx, 1, 0xc303, 0x0920);
+		efx_mdio_write(efx, 1, 0xd008, 0x0004);
+		for (i = 0; i < 9; i++) {
+			efx_mdio_write(efx, 1, 0xc303, 0x0900);
+			efx_mdio_write(efx, 1, 0xd008, 0x0005);
+			efx_mdio_write(efx, 1, 0xc303, 0x0920);
+			efx_mdio_write(efx, 1, 0xd008, 0x0004);
+		}
+		efx_mdio_write(efx, 1, 0xc303, 0x4900);
+	}
+	efx_mdio_write(efx, 1, 0xc303, 0x4900);
+	efx_mdio_write(efx, 1, 0xc302, 0x0004);
+	efx_mdio_write(efx, 1, 0xc316, 0x0013);
+	efx_mdio_write(efx, 1, 0xc318, 0x0054);
+	efx_mdio_write(efx, 1, 0xc319, phy_op_mode);
+	efx_mdio_write(efx, 1, 0xc31a, 0x0098);
+	efx_mdio_write(efx, 3, 0x0026, 0x0e00);
+	efx_mdio_write(efx, 3, 0x0027, 0x0013);
+	efx_mdio_write(efx, 3, 0x0028, 0xa528);
+	efx_mdio_write(efx, 1, 0xd006, 0x000a);
+	efx_mdio_write(efx, 1, 0xd007, 0x0009);
+	efx_mdio_write(efx, 1, 0xd008, 0x0004);
+	/* This additional write is not present in the boot EEPROM.  It
+	 * prevents the PHY's internal boot ROM doing another pointless (and
+	 * slow) reload of the firmware image (the microcontroller's code
+	 * memory is not affected by the microcontroller reset). */
+	efx_mdio_write(efx, 1, 0xc317, 0x00ff);
+	/* PMA/PMD loopback sets RXIN to inverse polarity and the firmware
+	 * restart doesn't reset it. We need to do that ourselves. */
+	efx_mdio_set_flag(efx, 1, PMA_PMD_MODE_REG,
+			  1 << PMA_PMD_RXIN_SEL_LBN, false);
+	efx_mdio_write(efx, 1, 0xc300, 0x0002);
+	msleep(20);
+
+	/* Restart microcontroller execution of firmware from RAM */
+	qt2025c_restart_firmware(efx);
+
+	/* Wait for the microcontroller to be ready again */
+	rc = qt2025c_wait_reset(efx);
+	if (rc < 0) {
+		netif_err(efx, hw, efx->net_dev,
+			  "PHY microcontroller reset during mode switch "
+			  "timed out\n");
+		return rc;
+	}
+
+	return 0;
+}
+
+static int qt202x_reset_phy(struct efx_nic *efx)
+{
+	int rc;
+
+	if (efx->phy_type == PHY_TYPE_QT2025C) {
+		/* Wait for the reset triggered by falcon_reset_hw()
+		 * to complete */
+		rc = qt2025c_wait_reset(efx);
+		if (rc < 0)
+			goto fail;
+	} else {
+		/* Reset the PHYXS MMD. This is documented as doing
+		 * a complete soft reset. */
+		rc = efx_mdio_reset_mmd(efx, MDIO_MMD_PHYXS,
+					QT2022C2_MAX_RESET_TIME /
+					QT2022C2_RESET_WAIT,
+					QT2022C2_RESET_WAIT);
+		if (rc < 0)
+			goto fail;
+	}
+
+	/* Wait 250ms for the PHY to complete bootup */
+	msleep(250);
+
+	falcon_board(efx)->type->init_phy(efx);
+
+	return 0;
+
+ fail:
+	netif_err(efx, hw, efx->net_dev, "PHY reset timed out\n");
+	return rc;
+}
+
+static int qt202x_phy_probe(struct efx_nic *efx)
+{
+	struct qt202x_phy_data *phy_data;
+
+	phy_data = kzalloc(sizeof(struct qt202x_phy_data), GFP_KERNEL);
+	if (!phy_data)
+		return -ENOMEM;
+	efx->phy_data = phy_data;
+	phy_data->phy_mode = efx->phy_mode;
+
+	efx->mdio.mmds = QT202X_REQUIRED_DEVS;
+	efx->mdio.mode_support = MDIO_SUPPORTS_C45 | MDIO_EMULATE_C22;
+
+	efx->loopback_modes = QT202X_LOOPBACKS | FALCON_XMAC_LOOPBACKS;
+	efx->startup_loopback_mode = LOOPBACK_PCS;
+
+	strlcpy(efx->phy_name,
+		(efx->phy_type == PHY_TYPE_QT2025C) ? "Quake SFP+" : "Quake XFP",
+		sizeof(efx->phy_name));
+
+	return 0;
+}
+
+static int qt202x_phy_init(struct efx_nic *efx)
+{
+	u32 devid;
+	int rc;
+
+	/* Reset the PHY before reading the firmware version */
+	rc = qt202x_reset_phy(efx);
+	if (rc) {
+		netif_err(efx, probe, efx->net_dev, "PHY init failed\n");
+		return rc;
+	}
+
+	devid = efx_mdio_read_id(efx, MDIO_MMD_PHYXS);
+	netif_info(efx, probe, efx->net_dev,
+		   "PHY ID reg %x (OUI %06x model %02x revision %x)\n",
+		   devid, efx_mdio_id_oui(devid), efx_mdio_id_model(devid),
+		   efx_mdio_id_rev(devid));
+
+	if (efx->phy_type == PHY_TYPE_QT2025C)
+		qt2025c_firmware_id(efx);
+
+	return 0;
+}
+
+static int qt202x_link_ok(struct efx_nic *efx)
+{
+	return efx_mdio_links_ok(efx, QT202X_REQUIRED_DEVS);
+}
+
+static bool qt202x_phy_poll(struct efx_nic *efx)
+{
+	bool was_up = efx->link_state.up;
+
+	efx->link_state.up = qt202x_link_ok(efx);
+	efx->link_state.speed = 10000;
+	efx->link_state.fd = true;
+	efx->link_state.fc = efx->wanted_fc;
+
+	if (efx->phy_type == PHY_TYPE_QT2025C)
+		qt2025c_bug17190_workaround(efx);
+
+	return efx->link_state.up != was_up;
+}
+
+static int qt202x_phy_reconfigure(struct efx_nic *efx)
+{
+	struct qt202x_phy_data *phy_data = efx->phy_data;
+
+	if (efx->phy_type == PHY_TYPE_QT2025C) {
+		int rc = qt2025c_select_phy_mode(efx);
+		if (rc)
+			return rc;
+
+		/* There are several different register bits which can
+		 * disable TX (and save power) on direct-attach cables
+		 * or optical transceivers, varying somewhat between
+		 * firmware versions.  Only 'static mode' appears to
+		 * cover everything. */
+		mdio_set_flag(
+			&efx->mdio, efx->mdio.prtad, MDIO_MMD_PMAPMD,
+			PMA_PMD_FTX_CTRL2_REG, 1 << PMA_PMD_FTX_STATIC_LBN,
+			efx->phy_mode & PHY_MODE_TX_DISABLED ||
+			efx->phy_mode & PHY_MODE_LOW_POWER ||
+			efx->loopback_mode == LOOPBACK_PCS ||
+			efx->loopback_mode == LOOPBACK_PMAPMD);
+	} else {
+		/* Reset the PHY when moving from transmitter off or powered
+		 * off, to transmitter on and powered on */
+		unsigned mask = PHY_MODE_TX_DISABLED | PHY_MODE_LOW_POWER;
+		if (!(efx->phy_mode & mask) && (phy_data->phy_mode & mask)) {
+			int rc = qt202x_reset_phy(efx);
+			if (rc)
+				EFX_FATAL(efx, hw, efx->net_dev,
+					  "Error resetting phy\n");
+		}
+
+		efx_mdio_transmit_disable(efx);
+		efx_mdio_set_mmds_lpower(efx,
+					 !!(efx->phy_mode & PHY_MODE_LOW_POWER),
+					 QT202X_REQUIRED_DEVS);
+	}
+
+	efx_mdio_phy_reconfigure(efx);
+
+	phy_data->phy_mode = efx->phy_mode;
+
+	return 0;
+}
+
+static void qt202x_phy_get_settings(struct efx_nic *efx, struct ethtool_cmd *ecmd)
+{
+	mdio45_ethtool_gset(&efx->mdio, ecmd);
+}
+
+static void qt202x_phy_remove(struct efx_nic *efx)
+{
+	/* Free the context block */
+	kfree(efx->phy_data);
+	efx->phy_data = NULL;
+}
+
+struct efx_phy_operations falcon_qt202x_phy_ops = {
+	.probe		 = qt202x_phy_probe,
+	.init		 = qt202x_phy_init,
+	.reconfigure	 = qt202x_phy_reconfigure,
+	.poll	     	 = qt202x_phy_poll,
+	.fini		 = efx_port_dummy_op_void,
+	.remove	  	 = qt202x_phy_remove,
+	.get_settings	 = qt202x_phy_get_settings,
+	.set_settings	 = efx_mdio_set_settings,
+	.test_alive	 = efx_mdio_test_alive,
+};
diff -r 5b3d4d3c1166 drivers/net/sfc/regs.h
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/drivers/net/sfc/regs.h	Tue Nov 09 10:06:27 2010 +0000
@@ -0,0 +1,3182 @@
+/****************************************************************************
+ * Driver for Solarflare Solarstorm network controllers and boards
+ * Copyright 2005-2006 Fen Systems Ltd.
+ * Copyright 2006-2009 Solarflare Communications Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 as published
+ * by the Free Software Foundation, incorporated herein by reference.
+ */
+
+#ifndef EFX_REGS_H
+#define EFX_REGS_H
+
+/*
+ * Falcon hardware architecture definitions have a name prefix following
+ * the format:
+ *
+ *     F<type>_<min-rev><max-rev>_
+ *
+ * The following <type> strings are used:
+ *
+ *             MMIO register  MC register  Host memory structure
+ * -------------------------------------------------------------
+ * Address     R              MCR
+ * Bitfield    RF             MCRF         SF
+ * Enumerator  FE             MCFE         SE
+ *
+ * <min-rev> is the first revision to which the definition applies:
+ *
+ *     A: Falcon A1 (SFC4000AB)
+ *     B: Falcon B0 (SFC4000BA)
+ *     C: Siena A0 (SFL9021AA)
+ *
+ * If the definition has been changed or removed in later revisions
+ * then <max-rev> is the last revision to which the definition applies;
+ * otherwise it is "Z".
+ */
+
+/**************************************************************************
+ *
+ * Falcon/Siena registers and descriptors
+ *
+ **************************************************************************
+ */
+
+/* ADR_REGION_REG: Address region register */
+#define	FR_AZ_ADR_REGION 0x00000000
+#define	FRF_AZ_ADR_REGION3_LBN 96
+#define	FRF_AZ_ADR_REGION3_WIDTH 18
+#define	FRF_AZ_ADR_REGION2_LBN 64
+#define	FRF_AZ_ADR_REGION2_WIDTH 18
+#define	FRF_AZ_ADR_REGION1_LBN 32
+#define	FRF_AZ_ADR_REGION1_WIDTH 18
+#define	FRF_AZ_ADR_REGION0_LBN 0
+#define	FRF_AZ_ADR_REGION0_WIDTH 18
+
+/* INT_EN_REG_KER: Kernel driver Interrupt enable register */
+#define	FR_AZ_INT_EN_KER 0x00000010
+#define	FRF_AZ_KER_INT_LEVE_SEL_LBN 8
+#define	FRF_AZ_KER_INT_LEVE_SEL_WIDTH 6
+#define	FRF_AZ_KER_INT_CHAR_LBN 4
+#define	FRF_AZ_KER_INT_CHAR_WIDTH 1
+#define	FRF_AZ_KER_INT_KER_LBN 3
+#define	FRF_AZ_KER_INT_KER_WIDTH 1
+#define	FRF_AZ_DRV_INT_EN_KER_LBN 0
+#define	FRF_AZ_DRV_INT_EN_KER_WIDTH 1
+
+/* INT_EN_REG_CHAR: Char Driver interrupt enable register */
+#define	FR_BZ_INT_EN_CHAR 0x00000020
+#define	FRF_BZ_CHAR_INT_LEVE_SEL_LBN 8
+#define	FRF_BZ_CHAR_INT_LEVE_SEL_WIDTH 6
+#define	FRF_BZ_CHAR_INT_CHAR_LBN 4
+#define	FRF_BZ_CHAR_INT_CHAR_WIDTH 1
+#define	FRF_BZ_CHAR_INT_KER_LBN 3
+#define	FRF_BZ_CHAR_INT_KER_WIDTH 1
+#define	FRF_BZ_DRV_INT_EN_CHAR_LBN 0
+#define	FRF_BZ_DRV_INT_EN_CHAR_WIDTH 1
+
+/* INT_ADR_REG_KER: Interrupt host address for Kernel driver */
+#define	FR_AZ_INT_ADR_KER 0x00000030
+#define	FRF_AZ_NORM_INT_VEC_DIS_KER_LBN 64
+#define	FRF_AZ_NORM_INT_VEC_DIS_KER_WIDTH 1
+#define	FRF_AZ_INT_ADR_KER_LBN 0
+#define	FRF_AZ_INT_ADR_KER_WIDTH 64
+
+/* INT_ADR_REG_CHAR: Interrupt host address for Char driver */
+#define	FR_BZ_INT_ADR_CHAR 0x00000040
+#define	FRF_BZ_NORM_INT_VEC_DIS_CHAR_LBN 64
+#define	FRF_BZ_NORM_INT_VEC_DIS_CHAR_WIDTH 1
+#define	FRF_BZ_INT_ADR_CHAR_LBN 0
+#define	FRF_BZ_INT_ADR_CHAR_WIDTH 64
+
+/* INT_ACK_KER: Kernel interrupt acknowledge register */
+#define	FR_AA_INT_ACK_KER 0x00000050
+#define	FRF_AA_INT_ACK_KER_FIELD_LBN 0
+#define	FRF_AA_INT_ACK_KER_FIELD_WIDTH 32
+
+/* INT_ISR0_REG: Function 0 Interrupt Acknowlege Status register */
+#define	FR_BZ_INT_ISR0 0x00000090
+#define	FRF_BZ_INT_ISR_REG_LBN 0
+#define	FRF_BZ_INT_ISR_REG_WIDTH 64
+
+/* HW_INIT_REG: Hardware initialization register */
+#define	FR_AZ_HW_INIT 0x000000c0
+#define	FRF_BB_BDMRD_CPLF_FULL_LBN 124
+#define	FRF_BB_BDMRD_CPLF_FULL_WIDTH 1
+#define	FRF_BB_PCIE_CPL_TIMEOUT_CTRL_LBN 121
+#define	FRF_BB_PCIE_CPL_TIMEOUT_CTRL_WIDTH 3
+#define	FRF_CZ_TX_MRG_TAGS_LBN 120
+#define	FRF_CZ_TX_MRG_TAGS_WIDTH 1
+#define	FRF_AB_TRGT_MASK_ALL_LBN 100
+#define	FRF_AB_TRGT_MASK_ALL_WIDTH 1
+#define	FRF_AZ_DOORBELL_DROP_LBN 92
+#define	FRF_AZ_DOORBELL_DROP_WIDTH 8
+#define	FRF_AB_TX_RREQ_MASK_EN_LBN 76
+#define	FRF_AB_TX_RREQ_MASK_EN_WIDTH 1
+#define	FRF_AB_PE_EIDLE_DIS_LBN 75
+#define	FRF_AB_PE_EIDLE_DIS_WIDTH 1
+#define	FRF_AA_FC_BLOCKING_EN_LBN 45
+#define	FRF_AA_FC_BLOCKING_EN_WIDTH 1
+#define	FRF_BZ_B2B_REQ_EN_LBN 45
+#define	FRF_BZ_B2B_REQ_EN_WIDTH 1
+#define	FRF_AA_B2B_REQ_EN_LBN 44
+#define	FRF_AA_B2B_REQ_EN_WIDTH 1
+#define	FRF_BB_FC_BLOCKING_EN_LBN 44
+#define	FRF_BB_FC_BLOCKING_EN_WIDTH 1
+#define	FRF_AZ_POST_WR_MASK_LBN 40
+#define	FRF_AZ_POST_WR_MASK_WIDTH 4
+#define	FRF_AZ_TLP_TC_LBN 34
+#define	FRF_AZ_TLP_TC_WIDTH 3
+#define	FRF_AZ_TLP_ATTR_LBN 32
+#define	FRF_AZ_TLP_ATTR_WIDTH 2
+#define	FRF_AB_INTB_VEC_LBN 24
+#define	FRF_AB_INTB_VEC_WIDTH 5
+#define	FRF_AB_INTA_VEC_LBN 16
+#define	FRF_AB_INTA_VEC_WIDTH 5
+#define	FRF_AZ_WD_TIMER_LBN 8
+#define	FRF_AZ_WD_TIMER_WIDTH 8
+#define	FRF_AZ_US_DISABLE_LBN 5
+#define	FRF_AZ_US_DISABLE_WIDTH 1
+#define	FRF_AZ_TLP_EP_LBN 4
+#define	FRF_AZ_TLP_EP_WIDTH 1
+#define	FRF_AZ_ATTR_SEL_LBN 3
+#define	FRF_AZ_ATTR_SEL_WIDTH 1
+#define	FRF_AZ_TD_SEL_LBN 1
+#define	FRF_AZ_TD_SEL_WIDTH 1
+#define	FRF_AZ_TLP_TD_LBN 0
+#define	FRF_AZ_TLP_TD_WIDTH 1
+
+/* EE_SPI_HCMD_REG: SPI host command register */
+#define	FR_AB_EE_SPI_HCMD 0x00000100
+#define	FRF_AB_EE_SPI_HCMD_CMD_EN_LBN 31
+#define	FRF_AB_EE_SPI_HCMD_CMD_EN_WIDTH 1
+#define	FRF_AB_EE_WR_TIMER_ACTIVE_LBN 28
+#define	FRF_AB_EE_WR_TIMER_ACTIVE_WIDTH 1
+#define	FRF_AB_EE_SPI_HCMD_SF_SEL_LBN 24
+#define	FRF_AB_EE_SPI_HCMD_SF_SEL_WIDTH 1
+#define	FRF_AB_EE_SPI_HCMD_DABCNT_LBN 16
+#define	FRF_AB_EE_SPI_HCMD_DABCNT_WIDTH 5
+#define	FRF_AB_EE_SPI_HCMD_READ_LBN 15
+#define	FRF_AB_EE_SPI_HCMD_READ_WIDTH 1
+#define	FRF_AB_EE_SPI_HCMD_DUBCNT_LBN 12
+#define	FRF_AB_EE_SPI_HCMD_DUBCNT_WIDTH 2
+#define	FRF_AB_EE_SPI_HCMD_ADBCNT_LBN 8
+#define	FRF_AB_EE_SPI_HCMD_ADBCNT_WIDTH 2
+#define	FRF_AB_EE_SPI_HCMD_ENC_LBN 0
+#define	FRF_AB_EE_SPI_HCMD_ENC_WIDTH 8
+
+/* USR_EV_CFG: User Level Event Configuration register */
+#define	FR_CZ_USR_EV_CFG 0x00000100
+#define	FRF_CZ_USREV_DIS_LBN 16
+#define	FRF_CZ_USREV_DIS_WIDTH 1
+#define	FRF_CZ_DFLT_EVQ_LBN 0
+#define	FRF_CZ_DFLT_EVQ_WIDTH 10
+
+/* EE_SPI_HADR_REG: SPI host address register */
+#define	FR_AB_EE_SPI_HADR 0x00000110
+#define	FRF_AB_EE_SPI_HADR_DUBYTE_LBN 24
+#define	FRF_AB_EE_SPI_HADR_DUBYTE_WIDTH 8
+#define	FRF_AB_EE_SPI_HADR_ADR_LBN 0
+#define	FRF_AB_EE_SPI_HADR_ADR_WIDTH 24
+
+/* EE_SPI_HDATA_REG: SPI host data register */
+#define	FR_AB_EE_SPI_HDATA 0x00000120
+#define	FRF_AB_EE_SPI_HDATA3_LBN 96
+#define	FRF_AB_EE_SPI_HDATA3_WIDTH 32
+#define	FRF_AB_EE_SPI_HDATA2_LBN 64
+#define	FRF_AB_EE_SPI_HDATA2_WIDTH 32
+#define	FRF_AB_EE_SPI_HDATA1_LBN 32
+#define	FRF_AB_EE_SPI_HDATA1_WIDTH 32
+#define	FRF_AB_EE_SPI_HDATA0_LBN 0
+#define	FRF_AB_EE_SPI_HDATA0_WIDTH 32
+
+/* EE_BASE_PAGE_REG: Expansion ROM base mirror register */
+#define	FR_AB_EE_BASE_PAGE 0x00000130
+#define	FRF_AB_EE_EXPROM_MASK_LBN 16
+#define	FRF_AB_EE_EXPROM_MASK_WIDTH 13
+#define	FRF_AB_EE_EXP_ROM_WINDOW_BASE_LBN 0
+#define	FRF_AB_EE_EXP_ROM_WINDOW_BASE_WIDTH 13
+
+/* EE_VPD_CFG0_REG: SPI/VPD configuration register 0 */
+#define	FR_AB_EE_VPD_CFG0 0x00000140
+#define	FRF_AB_EE_SF_FASTRD_EN_LBN 127
+#define	FRF_AB_EE_SF_FASTRD_EN_WIDTH 1
+#define	FRF_AB_EE_SF_CLOCK_DIV_LBN 120
+#define	FRF_AB_EE_SF_CLOCK_DIV_WIDTH 7
+#define	FRF_AB_EE_VPD_WIP_POLL_LBN 119
+#define	FRF_AB_EE_VPD_WIP_POLL_WIDTH 1
+#define	FRF_AB_EE_EE_CLOCK_DIV_LBN 112
+#define	FRF_AB_EE_EE_CLOCK_DIV_WIDTH 7
+#define	FRF_AB_EE_EE_WR_TMR_VALUE_LBN 96
+#define	FRF_AB_EE_EE_WR_TMR_VALUE_WIDTH 16
+#define	FRF_AB_EE_VPDW_LENGTH_LBN 80
+#define	FRF_AB_EE_VPDW_LENGTH_WIDTH 15
+#define	FRF_AB_EE_VPDW_BASE_LBN 64
+#define	FRF_AB_EE_VPDW_BASE_WIDTH 15
+#define	FRF_AB_EE_VPD_WR_CMD_EN_LBN 56
+#define	FRF_AB_EE_VPD_WR_CMD_EN_WIDTH 8
+#define	FRF_AB_EE_VPD_BASE_LBN 32
+#define	FRF_AB_EE_VPD_BASE_WIDTH 24
+#define	FRF_AB_EE_VPD_LENGTH_LBN 16
+#define	FRF_AB_EE_VPD_LENGTH_WIDTH 15
+#define	FRF_AB_EE_VPD_AD_SIZE_LBN 8
+#define	FRF_AB_EE_VPD_AD_SIZE_WIDTH 5
+#define	FRF_AB_EE_VPD_ACCESS_ON_LBN 5
+#define	FRF_AB_EE_VPD_ACCESS_ON_WIDTH 1
+#define	FRF_AB_EE_VPD_ACCESS_BLOCK_LBN 4
+#define	FRF_AB_EE_VPD_ACCESS_BLOCK_WIDTH 1
+#define	FRF_AB_EE_VPD_DEV_SF_SEL_LBN 2
+#define	FRF_AB_EE_VPD_DEV_SF_SEL_WIDTH 1
+#define	FRF_AB_EE_VPD_EN_AD9_MODE_LBN 1
+#define	FRF_AB_EE_VPD_EN_AD9_MODE_WIDTH 1
+#define	FRF_AB_EE_VPD_EN_LBN 0
+#define	FRF_AB_EE_VPD_EN_WIDTH 1
+
+/* EE_VPD_SW_CNTL_REG: VPD access SW control register */
+#define	FR_AB_EE_VPD_SW_CNTL 0x00000150
+#define	FRF_AB_EE_VPD_CYCLE_PENDING_LBN 31
+#define	FRF_AB_EE_VPD_CYCLE_PENDING_WIDTH 1
+#define	FRF_AB_EE_VPD_CYC_WRITE_LBN 28
+#define	FRF_AB_EE_VPD_CYC_WRITE_WIDTH 1
+#define	FRF_AB_EE_VPD_CYC_ADR_LBN 0
+#define	FRF_AB_EE_VPD_CYC_ADR_WIDTH 15
+
+/* EE_VPD_SW_DATA_REG: VPD access SW data register */
+#define	FR_AB_EE_VPD_SW_DATA 0x00000160
+#define	FRF_AB_EE_VPD_CYC_DAT_LBN 0
+#define	FRF_AB_EE_VPD_CYC_DAT_WIDTH 32
+
+/* PBMX_DBG_IADDR_REG: Capture Module address register */
+#define	FR_CZ_PBMX_DBG_IADDR 0x000001f0
+#define	FRF_CZ_PBMX_DBG_IADDR_LBN 0
+#define	FRF_CZ_PBMX_DBG_IADDR_WIDTH 32
+
+/* PCIE_CORE_INDIRECT_REG: Indirect Access to PCIE Core registers */
+#define	FR_BB_PCIE_CORE_INDIRECT 0x000001f0
+#define	FRF_BB_PCIE_CORE_TARGET_DATA_LBN 32
+#define	FRF_BB_PCIE_CORE_TARGET_DATA_WIDTH 32
+#define	FRF_BB_PCIE_CORE_INDIRECT_ACCESS_DIR_LBN 15
+#define	FRF_BB_PCIE_CORE_INDIRECT_ACCESS_DIR_WIDTH 1
+#define	FRF_BB_PCIE_CORE_TARGET_REG_ADRS_LBN 0
+#define	FRF_BB_PCIE_CORE_TARGET_REG_ADRS_WIDTH 12
+
+/* PBMX_DBG_IDATA_REG: Capture Module data register */
+#define	FR_CZ_PBMX_DBG_IDATA 0x000001f8
+#define	FRF_CZ_PBMX_DBG_IDATA_LBN 0
+#define	FRF_CZ_PBMX_DBG_IDATA_WIDTH 64
+
+/* NIC_STAT_REG: NIC status register */
+#define	FR_AB_NIC_STAT 0x00000200
+#define	FRF_BB_AER_DIS_LBN 34
+#define	FRF_BB_AER_DIS_WIDTH 1
+#define	FRF_BB_EE_STRAP_EN_LBN 31
+#define	FRF_BB_EE_STRAP_EN_WIDTH 1
+#define	FRF_BB_EE_STRAP_LBN 24
+#define	FRF_BB_EE_STRAP_WIDTH 4
+#define	FRF_BB_REVISION_ID_LBN 17
+#define	FRF_BB_REVISION_ID_WIDTH 7
+#define	FRF_AB_ONCHIP_SRAM_LBN 16
+#define	FRF_AB_ONCHIP_SRAM_WIDTH 1
+#define	FRF_AB_SF_PRST_LBN 9
+#define	FRF_AB_SF_PRST_WIDTH 1
+#define	FRF_AB_EE_PRST_LBN 8
+#define	FRF_AB_EE_PRST_WIDTH 1
+#define	FRF_AB_ATE_MODE_LBN 3
+#define	FRF_AB_ATE_MODE_WIDTH 1
+#define	FRF_AB_STRAP_PINS_LBN 0
+#define	FRF_AB_STRAP_PINS_WIDTH 3
+
+/* GPIO_CTL_REG: GPIO control register */
+#define	FR_AB_GPIO_CTL 0x00000210
+#define	FRF_AB_GPIO_OUT3_LBN 112
+#define	FRF_AB_GPIO_OUT3_WIDTH 16
+#define	FRF_AB_GPIO_IN3_LBN 104
+#define	FRF_AB_GPIO_IN3_WIDTH 8
+#define	FRF_AB_GPIO_PWRUP_VALUE3_LBN 96
+#define	FRF_AB_GPIO_PWRUP_VALUE3_WIDTH 8
+#define	FRF_AB_GPIO_OUT2_LBN 80
+#define	FRF_AB_GPIO_OUT2_WIDTH 16
+#define	FRF_AB_GPIO_IN2_LBN 72
+#define	FRF_AB_GPIO_IN2_WIDTH 8
+#define	FRF_AB_GPIO_PWRUP_VALUE2_LBN 64
+#define	FRF_AB_GPIO_PWRUP_VALUE2_WIDTH 8
+#define	FRF_AB_GPIO15_OEN_LBN 63
+#define	FRF_AB_GPIO15_OEN_WIDTH 1
+#define	FRF_AB_GPIO14_OEN_LBN 62
+#define	FRF_AB_GPIO14_OEN_WIDTH 1
+#define	FRF_AB_GPIO13_OEN_LBN 61
+#define	FRF_AB_GPIO13_OEN_WIDTH 1
+#define	FRF_AB_GPIO12_OEN_LBN 60
+#define	FRF_AB_GPIO12_OEN_WIDTH 1
+#define	FRF_AB_GPIO11_OEN_LBN 59
+#define	FRF_AB_GPIO11_OEN_WIDTH 1
+#define	FRF_AB_GPIO10_OEN_LBN 58
+#define	FRF_AB_GPIO10_OEN_WIDTH 1
+#define	FRF_AB_GPIO9_OEN_LBN 57
+#define	FRF_AB_GPIO9_OEN_WIDTH 1
+#define	FRF_AB_GPIO8_OEN_LBN 56
+#define	FRF_AB_GPIO8_OEN_WIDTH 1
+#define	FRF_AB_GPIO15_OUT_LBN 55
+#define	FRF_AB_GPIO15_OUT_WIDTH 1
+#define	FRF_AB_GPIO14_OUT_LBN 54
+#define	FRF_AB_GPIO14_OUT_WIDTH 1
+#define	FRF_AB_GPIO13_OUT_LBN 53
+#define	FRF_AB_GPIO13_OUT_WIDTH 1
+#define	FRF_AB_GPIO12_OUT_LBN 52
+#define	FRF_AB_GPIO12_OUT_WIDTH 1
+#define	FRF_AB_GPIO11_OUT_LBN 51
+#define	FRF_AB_GPIO11_OUT_WIDTH 1
+#define	FRF_AB_GPIO10_OUT_LBN 50
+#define	FRF_AB_GPIO10_OUT_WIDTH 1
+#define	FRF_AB_GPIO9_OUT_LBN 49
+#define	FRF_AB_GPIO9_OUT_WIDTH 1
+#define	FRF_AB_GPIO8_OUT_LBN 48
+#define	FRF_AB_GPIO8_OUT_WIDTH 1
+#define	FRF_AB_GPIO15_IN_LBN 47
+#define	FRF_AB_GPIO15_IN_WIDTH 1
+#define	FRF_AB_GPIO14_IN_LBN 46
+#define	FRF_AB_GPIO14_IN_WIDTH 1
+#define	FRF_AB_GPIO13_IN_LBN 45
+#define	FRF_AB_GPIO13_IN_WIDTH 1
+#define	FRF_AB_GPIO12_IN_LBN 44
+#define	FRF_AB_GPIO12_IN_WIDTH 1
+#define	FRF_AB_GPIO11_IN_LBN 43
+#define	FRF_AB_GPIO11_IN_WIDTH 1
+#define	FRF_AB_GPIO10_IN_LBN 42
+#define	FRF_AB_GPIO10_IN_WIDTH 1
+#define	FRF_AB_GPIO9_IN_LBN 41
+#define	FRF_AB_GPIO9_IN_WIDTH 1
+#define	FRF_AB_GPIO8_IN_LBN 40
+#define	FRF_AB_GPIO8_IN_WIDTH 1
+#define	FRF_AB_GPIO15_PWRUP_VALUE_LBN 39
+#define	FRF_AB_GPIO15_PWRUP_VALUE_WIDTH 1
+#define	FRF_AB_GPIO14_PWRUP_VALUE_LBN 38
+#define	FRF_AB_GPIO14_PWRUP_VALUE_WIDTH 1
+#define	FRF_AB_GPIO13_PWRUP_VALUE_LBN 37
+#define	FRF_AB_GPIO13_PWRUP_VALUE_WIDTH 1
+#define	FRF_AB_GPIO12_PWRUP_VALUE_LBN 36
+#define	FRF_AB_GPIO12_PWRUP_VALUE_WIDTH 1
+#define	FRF_AB_GPIO11_PWRUP_VALUE_LBN 35
+#define	FRF_AB_GPIO11_PWRUP_VALUE_WIDTH 1
+#define	FRF_AB_GPIO10_PWRUP_VALUE_LBN 34
+#define	FRF_AB_GPIO10_PWRUP_VALUE_WIDTH 1
+#define	FRF_AB_GPIO9_PWRUP_VALUE_LBN 33
+#define	FRF_AB_GPIO9_PWRUP_VALUE_WIDTH 1
+#define	FRF_AB_GPIO8_PWRUP_VALUE_LBN 32
+#define	FRF_AB_GPIO8_PWRUP_VALUE_WIDTH 1
+#define	FRF_AB_CLK156_OUT_EN_LBN 31
+#define	FRF_AB_CLK156_OUT_EN_WIDTH 1
+#define	FRF_AB_USE_NIC_CLK_LBN 30
+#define	FRF_AB_USE_NIC_CLK_WIDTH 1
+#define	FRF_AB_GPIO5_OEN_LBN 29
+#define	FRF_AB_GPIO5_OEN_WIDTH 1
+#define	FRF_AB_GPIO4_OEN_LBN 28
+#define	FRF_AB_GPIO4_OEN_WIDTH 1
+#define	FRF_AB_GPIO3_OEN_LBN 27
+#define	FRF_AB_GPIO3_OEN_WIDTH 1
+#define	FRF_AB_GPIO2_OEN_LBN 26
+#define	FRF_AB_GPIO2_OEN_WIDTH 1
+#define	FRF_AB_GPIO1_OEN_LBN 25
+#define	FRF_AB_GPIO1_OEN_WIDTH 1
+#define	FRF_AB_GPIO0_OEN_LBN 24
+#define	FRF_AB_GPIO0_OEN_WIDTH 1
+#define	FRF_AB_GPIO7_OUT_LBN 23
+#define	FRF_AB_GPIO7_OUT_WIDTH 1
+#define	FRF_AB_GPIO6_OUT_LBN 22
+#define	FRF_AB_GPIO6_OUT_WIDTH 1
+#define	FRF_AB_GPIO5_OUT_LBN 21
+#define	FRF_AB_GPIO5_OUT_WIDTH 1
+#define	FRF_AB_GPIO4_OUT_LBN 20
+#define	FRF_AB_GPIO4_OUT_WIDTH 1
+#define	FRF_AB_GPIO3_OUT_LBN 19
+#define	FRF_AB_GPIO3_OUT_WIDTH 1
+#define	FRF_AB_GPIO2_OUT_LBN 18
+#define	FRF_AB_GPIO2_OUT_WIDTH 1
+#define	FRF_AB_GPIO1_OUT_LBN 17
+#define	FRF_AB_GPIO1_OUT_WIDTH 1
+#define	FRF_AB_GPIO0_OUT_LBN 16
+#define	FRF_AB_GPIO0_OUT_WIDTH 1
+#define	FRF_AB_GPIO7_IN_LBN 15
+#define	FRF_AB_GPIO7_IN_WIDTH 1
+#define	FRF_AB_GPIO6_IN_LBN 14
+#define	FRF_AB_GPIO6_IN_WIDTH 1
+#define	FRF_AB_GPIO5_IN_LBN 13
+#define	FRF_AB_GPIO5_IN_WIDTH 1
+#define	FRF_AB_GPIO4_IN_LBN 12
+#define	FRF_AB_GPIO4_IN_WIDTH 1
+#define	FRF_AB_GPIO3_IN_LBN 11
+#define	FRF_AB_GPIO3_IN_WIDTH 1
+#define	FRF_AB_GPIO2_IN_LBN 10
+#define	FRF_AB_GPIO2_IN_WIDTH 1
+#define	FRF_AB_GPIO1_IN_LBN 9
+#define	FRF_AB_GPIO1_IN_WIDTH 1
+#define	FRF_AB_GPIO0_IN_LBN 8
+#define	FRF_AB_GPIO0_IN_WIDTH 1
+#define	FRF_AB_GPIO7_PWRUP_VALUE_LBN 7
+#define	FRF_AB_GPIO7_PWRUP_VALUE_WIDTH 1
+#define	FRF_AB_GPIO6_PWRUP_VALUE_LBN 6
+#define	FRF_AB_GPIO6_PWRUP_VALUE_WIDTH 1
+#define	FRF_AB_GPIO5_PWRUP_VALUE_LBN 5
+#define	FRF_AB_GPIO5_PWRUP_VALUE_WIDTH 1
+#define	FRF_AB_GPIO4_PWRUP_VALUE_LBN 4
+#define	FRF_AB_GPIO4_PWRUP_VALUE_WIDTH 1
+#define	FRF_AB_GPIO3_PWRUP_VALUE_LBN 3
+#define	FRF_AB_GPIO3_PWRUP_VALUE_WIDTH 1
+#define	FRF_AB_GPIO2_PWRUP_VALUE_LBN 2
+#define	FRF_AB_GPIO2_PWRUP_VALUE_WIDTH 1
+#define	FRF_AB_GPIO1_PWRUP_VALUE_LBN 1
+#define	FRF_AB_GPIO1_PWRUP_VALUE_WIDTH 1
+#define	FRF_AB_GPIO0_PWRUP_VALUE_LBN 0
+#define	FRF_AB_GPIO0_PWRUP_VALUE_WIDTH 1
+
+/* GLB_CTL_REG: Global control register */
+#define	FR_AB_GLB_CTL 0x00000220
+#define	FRF_AB_EXT_PHY_RST_CTL_LBN 63
+#define	FRF_AB_EXT_PHY_RST_CTL_WIDTH 1
+#define	FRF_AB_XAUI_SD_RST_CTL_LBN 62
+#define	FRF_AB_XAUI_SD_RST_CTL_WIDTH 1
+#define	FRF_AB_PCIE_SD_RST_CTL_LBN 61
+#define	FRF_AB_PCIE_SD_RST_CTL_WIDTH 1
+#define	FRF_AA_PCIX_RST_CTL_LBN 60
+#define	FRF_AA_PCIX_RST_CTL_WIDTH 1
+#define	FRF_BB_BIU_RST_CTL_LBN 60
+#define	FRF_BB_BIU_RST_CTL_WIDTH 1
+#define	FRF_AB_PCIE_STKY_RST_CTL_LBN 59
+#define	FRF_AB_PCIE_STKY_RST_CTL_WIDTH 1
+#define	FRF_AB_PCIE_NSTKY_RST_CTL_LBN 58
+#define	FRF_AB_PCIE_NSTKY_RST_CTL_WIDTH 1
+#define	FRF_AB_PCIE_CORE_RST_CTL_LBN 57
+#define	FRF_AB_PCIE_CORE_RST_CTL_WIDTH 1
+#define	FRF_AB_XGRX_RST_CTL_LBN 56
+#define	FRF_AB_XGRX_RST_CTL_WIDTH 1
+#define	FRF_AB_XGTX_RST_CTL_LBN 55
+#define	FRF_AB_XGTX_RST_CTL_WIDTH 1
+#define	FRF_AB_EM_RST_CTL_LBN 54
+#define	FRF_AB_EM_RST_CTL_WIDTH 1
+#define	FRF_AB_EV_RST_CTL_LBN 53
+#define	FRF_AB_EV_RST_CTL_WIDTH 1
+#define	FRF_AB_SR_RST_CTL_LBN 52
+#define	FRF_AB_SR_RST_CTL_WIDTH 1
+#define	FRF_AB_RX_RST_CTL_LBN 51
+#define	FRF_AB_RX_RST_CTL_WIDTH 1
+#define	FRF_AB_TX_RST_CTL_LBN 50
+#define	FRF_AB_TX_RST_CTL_WIDTH 1
+#define	FRF_AB_EE_RST_CTL_LBN 49
+#define	FRF_AB_EE_RST_CTL_WIDTH 1
+#define	FRF_AB_CS_RST_CTL_LBN 48
+#define	FRF_AB_CS_RST_CTL_WIDTH 1
+#define	FRF_AB_HOT_RST_CTL_LBN 40
+#define	FRF_AB_HOT_RST_CTL_WIDTH 2
+#define	FRF_AB_RST_EXT_PHY_LBN 31
+#define	FRF_AB_RST_EXT_PHY_WIDTH 1
+#define	FRF_AB_RST_XAUI_SD_LBN 30
+#define	FRF_AB_RST_XAUI_SD_WIDTH 1
+#define	FRF_AB_RST_PCIE_SD_LBN 29
+#define	FRF_AB_RST_PCIE_SD_WIDTH 1
+#define	FRF_AA_RST_PCIX_LBN 28
+#define	FRF_AA_RST_PCIX_WIDTH 1
+#define	FRF_BB_RST_BIU_LBN 28
+#define	FRF_BB_RST_BIU_WIDTH 1
+#define	FRF_AB_RST_PCIE_STKY_LBN 27
+#define	FRF_AB_RST_PCIE_STKY_WIDTH 1
+#define	FRF_AB_RST_PCIE_NSTKY_LBN 26
+#define	FRF_AB_RST_PCIE_NSTKY_WIDTH 1
+#define	FRF_AB_RST_PCIE_CORE_LBN 25
+#define	FRF_AB_RST_PCIE_CORE_WIDTH 1
+#define	FRF_AB_RST_XGRX_LBN 24
+#define	FRF_AB_RST_XGRX_WIDTH 1
+#define	FRF_AB_RST_XGTX_LBN 23
+#define	FRF_AB_RST_XGTX_WIDTH 1
+#define	FRF_AB_RST_EM_LBN 22
+#define	FRF_AB_RST_EM_WIDTH 1
+#define	FRF_AB_RST_EV_LBN 21
+#define	FRF_AB_RST_EV_WIDTH 1
+#define	FRF_AB_RST_SR_LBN 20
+#define	FRF_AB_RST_SR_WIDTH 1
+#define	FRF_AB_RST_RX_LBN 19
+#define	FRF_AB_RST_RX_WIDTH 1
+#define	FRF_AB_RST_TX_LBN 18
+#define	FRF_AB_RST_TX_WIDTH 1
+#define	FRF_AB_RST_SF_LBN 17
+#define	FRF_AB_RST_SF_WIDTH 1
+#define	FRF_AB_RST_CS_LBN 16
+#define	FRF_AB_RST_CS_WIDTH 1
+#define	FRF_AB_INT_RST_DUR_LBN 4
+#define	FRF_AB_INT_RST_DUR_WIDTH 3
+#define	FRF_AB_EXT_PHY_RST_DUR_LBN 1
+#define	FRF_AB_EXT_PHY_RST_DUR_WIDTH 3
+#define	FFE_AB_EXT_PHY_RST_DUR_10240US 7
+#define	FFE_AB_EXT_PHY_RST_DUR_5120US 6
+#define	FFE_AB_EXT_PHY_RST_DUR_2560US 5
+#define	FFE_AB_EXT_PHY_RST_DUR_1280US 4
+#define	FFE_AB_EXT_PHY_RST_DUR_640US 3
+#define	FFE_AB_EXT_PHY_RST_DUR_320US 2
+#define	FFE_AB_EXT_PHY_RST_DUR_160US 1
+#define	FFE_AB_EXT_PHY_RST_DUR_80US 0
+#define	FRF_AB_SWRST_LBN 0
+#define	FRF_AB_SWRST_WIDTH 1
+
+/* FATAL_INTR_REG_KER: Fatal interrupt register for Kernel */
+#define	FR_AZ_FATAL_INTR_KER 0x00000230
+#define	FRF_CZ_SRAM_PERR_INT_P_KER_EN_LBN 44
+#define	FRF_CZ_SRAM_PERR_INT_P_KER_EN_WIDTH 1
+#define	FRF_AB_PCI_BUSERR_INT_KER_EN_LBN 43
+#define	FRF_AB_PCI_BUSERR_INT_KER_EN_WIDTH 1
+#define	FRF_CZ_MBU_PERR_INT_KER_EN_LBN 43
+#define	FRF_CZ_MBU_PERR_INT_KER_EN_WIDTH 1
+#define	FRF_AZ_SRAM_OOB_INT_KER_EN_LBN 42
+#define	FRF_AZ_SRAM_OOB_INT_KER_EN_WIDTH 1
+#define	FRF_AZ_BUFID_OOB_INT_KER_EN_LBN 41
+#define	FRF_AZ_BUFID_OOB_INT_KER_EN_WIDTH 1
+#define	FRF_AZ_MEM_PERR_INT_KER_EN_LBN 40
+#define	FRF_AZ_MEM_PERR_INT_KER_EN_WIDTH 1
+#define	FRF_AZ_RBUF_OWN_INT_KER_EN_LBN 39
+#define	FRF_AZ_RBUF_OWN_INT_KER_EN_WIDTH 1
+#define	FRF_AZ_TBUF_OWN_INT_KER_EN_LBN 38
+#define	FRF_AZ_TBUF_OWN_INT_KER_EN_WIDTH 1
+#define	FRF_AZ_RDESCQ_OWN_INT_KER_EN_LBN 37
+#define	FRF_AZ_RDESCQ_OWN_INT_KER_EN_WIDTH 1
+#define	FRF_AZ_TDESCQ_OWN_INT_KER_EN_LBN 36
+#define	FRF_AZ_TDESCQ_OWN_INT_KER_EN_WIDTH 1
+#define	FRF_AZ_EVQ_OWN_INT_KER_EN_LBN 35
+#define	FRF_AZ_EVQ_OWN_INT_KER_EN_WIDTH 1
+#define	FRF_AZ_EVF_OFLO_INT_KER_EN_LBN 34
+#define	FRF_AZ_EVF_OFLO_INT_KER_EN_WIDTH 1
+#define	FRF_AZ_ILL_ADR_INT_KER_EN_LBN 33
+#define	FRF_AZ_ILL_ADR_INT_KER_EN_WIDTH 1
+#define	FRF_AZ_SRM_PERR_INT_KER_EN_LBN 32
+#define	FRF_AZ_SRM_PERR_INT_KER_EN_WIDTH 1
+#define	FRF_CZ_SRAM_PERR_INT_P_KER_LBN 12
+#define	FRF_CZ_SRAM_PERR_INT_P_KER_WIDTH 1
+#define	FRF_AB_PCI_BUSERR_INT_KER_LBN 11
+#define	FRF_AB_PCI_BUSERR_INT_KER_WIDTH 1
+#define	FRF_CZ_MBU_PERR_INT_KER_LBN 11
+#define	FRF_CZ_MBU_PERR_INT_KER_WIDTH 1
+#define	FRF_AZ_SRAM_OOB_INT_KER_LBN 10
+#define	FRF_AZ_SRAM_OOB_INT_KER_WIDTH 1
+#define	FRF_AZ_BUFID_DC_OOB_INT_KER_LBN 9
+#define	FRF_AZ_BUFID_DC_OOB_INT_KER_WIDTH 1
+#define	FRF_AZ_MEM_PERR_INT_KER_LBN 8
+#define	FRF_AZ_MEM_PERR_INT_KER_WIDTH 1
+#define	FRF_AZ_RBUF_OWN_INT_KER_LBN 7
+#define	FRF_AZ_RBUF_OWN_INT_KER_WIDTH 1
+#define	FRF_AZ_TBUF_OWN_INT_KER_LBN 6
+#define	FRF_AZ_TBUF_OWN_INT_KER_WIDTH 1
+#define	FRF_AZ_RDESCQ_OWN_INT_KER_LBN 5
+#define	FRF_AZ_RDESCQ_OWN_INT_KER_WIDTH 1
+#define	FRF_AZ_TDESCQ_OWN_INT_KER_LBN 4
+#define	FRF_AZ_TDESCQ_OWN_INT_KER_WIDTH 1
+#define	FRF_AZ_EVQ_OWN_INT_KER_LBN 3
+#define	FRF_AZ_EVQ_OWN_INT_KER_WIDTH 1
+#define	FRF_AZ_EVF_OFLO_INT_KER_LBN 2
+#define	FRF_AZ_EVF_OFLO_INT_KER_WIDTH 1
+#define	FRF_AZ_ILL_ADR_INT_KER_LBN 1
+#define	FRF_AZ_ILL_ADR_INT_KER_WIDTH 1
+#define	FRF_AZ_SRM_PERR_INT_KER_LBN 0
+#define	FRF_AZ_SRM_PERR_INT_KER_WIDTH 1
+
+/* FATAL_INTR_REG_CHAR: Fatal interrupt register for Char */
+#define	FR_BZ_FATAL_INTR_CHAR 0x00000240
+#define	FRF_CZ_SRAM_PERR_INT_P_CHAR_EN_LBN 44
+#define	FRF_CZ_SRAM_PERR_INT_P_CHAR_EN_WIDTH 1
+#define	FRF_BB_PCI_BUSERR_INT_CHAR_EN_LBN 43
+#define	FRF_BB_PCI_BUSERR_INT_CHAR_EN_WIDTH 1
+#define	FRF_CZ_MBU_PERR_INT_CHAR_EN_LBN 43
+#define	FRF_CZ_MBU_PERR_INT_CHAR_EN_WIDTH 1
+#define	FRF_BZ_SRAM_OOB_INT_CHAR_EN_LBN 42
+#define	FRF_BZ_SRAM_OOB_INT_CHAR_EN_WIDTH 1
+#define	FRF_BZ_BUFID_OOB_INT_CHAR_EN_LBN 41
+#define	FRF_BZ_BUFID_OOB_INT_CHAR_EN_WIDTH 1
+#define	FRF_BZ_MEM_PERR_INT_CHAR_EN_LBN 40
+#define	FRF_BZ_MEM_PERR_INT_CHAR_EN_WIDTH 1
+#define	FRF_BZ_RBUF_OWN_INT_CHAR_EN_LBN 39
+#define	FRF_BZ_RBUF_OWN_INT_CHAR_EN_WIDTH 1
+#define	FRF_BZ_TBUF_OWN_INT_CHAR_EN_LBN 38
+#define	FRF_BZ_TBUF_OWN_INT_CHAR_EN_WIDTH 1
+#define	FRF_BZ_RDESCQ_OWN_INT_CHAR_EN_LBN 37
+#define	FRF_BZ_RDESCQ_OWN_INT_CHAR_EN_WIDTH 1
+#define	FRF_BZ_TDESCQ_OWN_INT_CHAR_EN_LBN 36
+#define	FRF_BZ_TDESCQ_OWN_INT_CHAR_EN_WIDTH 1
+#define	FRF_BZ_EVQ_OWN_INT_CHAR_EN_LBN 35
+#define	FRF_BZ_EVQ_OWN_INT_CHAR_EN_WIDTH 1
+#define	FRF_BZ_EVF_OFLO_INT_CHAR_EN_LBN 34
+#define	FRF_BZ_EVF_OFLO_INT_CHAR_EN_WIDTH 1
+#define	FRF_BZ_ILL_ADR_INT_CHAR_EN_LBN 33
+#define	FRF_BZ_ILL_ADR_INT_CHAR_EN_WIDTH 1
+#define	FRF_BZ_SRM_PERR_INT_CHAR_EN_LBN 32
+#define	FRF_BZ_SRM_PERR_INT_CHAR_EN_WIDTH 1
+#define	FRF_CZ_SRAM_PERR_INT_P_CHAR_LBN 12
+#define	FRF_CZ_SRAM_PERR_INT_P_CHAR_WIDTH 1
+#define	FRF_BB_PCI_BUSERR_INT_CHAR_LBN 11
+#define	FRF_BB_PCI_BUSERR_INT_CHAR_WIDTH 1
+#define	FRF_CZ_MBU_PERR_INT_CHAR_LBN 11
+#define	FRF_CZ_MBU_PERR_INT_CHAR_WIDTH 1
+#define	FRF_BZ_SRAM_OOB_INT_CHAR_LBN 10
+#define	FRF_BZ_SRAM_OOB_INT_CHAR_WIDTH 1
+#define	FRF_BZ_BUFID_DC_OOB_INT_CHAR_LBN 9
+#define	FRF_BZ_BUFID_DC_OOB_INT_CHAR_WIDTH 1
+#define	FRF_BZ_MEM_PERR_INT_CHAR_LBN 8
+#define	FRF_BZ_MEM_PERR_INT_CHAR_WIDTH 1
+#define	FRF_BZ_RBUF_OWN_INT_CHAR_LBN 7
+#define	FRF_BZ_RBUF_OWN_INT_CHAR_WIDTH 1
+#define	FRF_BZ_TBUF_OWN_INT_CHAR_LBN 6
+#define	FRF_BZ_TBUF_OWN_INT_CHAR_WIDTH 1
+#define	FRF_BZ_RDESCQ_OWN_INT_CHAR_LBN 5
+#define	FRF_BZ_RDESCQ_OWN_INT_CHAR_WIDTH 1
+#define	FRF_BZ_TDESCQ_OWN_INT_CHAR_LBN 4
+#define	FRF_BZ_TDESCQ_OWN_INT_CHAR_WIDTH 1
+#define	FRF_BZ_EVQ_OWN_INT_CHAR_LBN 3
+#define	FRF_BZ_EVQ_OWN_INT_CHAR_WIDTH 1
+#define	FRF_BZ_EVF_OFLO_INT_CHAR_LBN 2
+#define	FRF_BZ_EVF_OFLO_INT_CHAR_WIDTH 1
+#define	FRF_BZ_ILL_ADR_INT_CHAR_LBN 1
+#define	FRF_BZ_ILL_ADR_INT_CHAR_WIDTH 1
+#define	FRF_BZ_SRM_PERR_INT_CHAR_LBN 0
+#define	FRF_BZ_SRM_PERR_INT_CHAR_WIDTH 1
+
+/* DP_CTRL_REG: Datapath control register */
+#define	FR_BZ_DP_CTRL 0x00000250
+#define	FRF_BZ_FLS_EVQ_ID_LBN 0
+#define	FRF_BZ_FLS_EVQ_ID_WIDTH 12
+
+/* MEM_STAT_REG: Memory status register */
+#define	FR_AZ_MEM_STAT 0x00000260
+#define	FRF_AB_MEM_PERR_VEC_LBN 53
+#define	FRF_AB_MEM_PERR_VEC_WIDTH 38
+#define	FRF_AB_MBIST_CORR_LBN 38
+#define	FRF_AB_MBIST_CORR_WIDTH 15
+#define	FRF_AB_MBIST_ERR_LBN 0
+#define	FRF_AB_MBIST_ERR_WIDTH 40
+#define	FRF_CZ_MEM_PERR_VEC_LBN 0
+#define	FRF_CZ_MEM_PERR_VEC_WIDTH 35
+
+/* CS_DEBUG_REG: Debug register */
+#define	FR_AZ_CS_DEBUG 0x00000270
+#define	FRF_AB_GLB_DEBUG2_SEL_LBN 50
+#define	FRF_AB_GLB_DEBUG2_SEL_WIDTH 3
+#define	FRF_AB_DEBUG_BLK_SEL2_LBN 47
+#define	FRF_AB_DEBUG_BLK_SEL2_WIDTH 3
+#define	FRF_AB_DEBUG_BLK_SEL1_LBN 44
+#define	FRF_AB_DEBUG_BLK_SEL1_WIDTH 3
+#define	FRF_AB_DEBUG_BLK_SEL0_LBN 41
+#define	FRF_AB_DEBUG_BLK_SEL0_WIDTH 3
+#define	FRF_CZ_CS_PORT_NUM_LBN 40
+#define	FRF_CZ_CS_PORT_NUM_WIDTH 2
+#define	FRF_AB_MISC_DEBUG_ADDR_LBN 36
+#define	FRF_AB_MISC_DEBUG_ADDR_WIDTH 5
+#define	FRF_AB_SERDES_DEBUG_ADDR_LBN 31
+#define	FRF_AB_SERDES_DEBUG_ADDR_WIDTH 5
+#define	FRF_CZ_CS_PORT_FPE_LBN 1
+#define	FRF_CZ_CS_PORT_FPE_WIDTH 35
+#define	FRF_AB_EM_DEBUG_ADDR_LBN 26
+#define	FRF_AB_EM_DEBUG_ADDR_WIDTH 5
+#define	FRF_AB_SR_DEBUG_ADDR_LBN 21
+#define	FRF_AB_SR_DEBUG_ADDR_WIDTH 5
+#define	FRF_AB_EV_DEBUG_ADDR_LBN 16
+#define	FRF_AB_EV_DEBUG_ADDR_WIDTH 5
+#define	FRF_AB_RX_DEBUG_ADDR_LBN 11
+#define	FRF_AB_RX_DEBUG_ADDR_WIDTH 5
+#define	FRF_AB_TX_DEBUG_ADDR_LBN 6
+#define	FRF_AB_TX_DEBUG_ADDR_WIDTH 5
+#define	FRF_AB_CS_BIU_DEBUG_ADDR_LBN 1
+#define	FRF_AB_CS_BIU_DEBUG_ADDR_WIDTH 5
+#define	FRF_AZ_CS_DEBUG_EN_LBN 0
+#define	FRF_AZ_CS_DEBUG_EN_WIDTH 1
+
+/* DRIVER_REG: Driver scratch register [0-7] */
+#define	FR_AZ_DRIVER 0x00000280
+#define	FR_AZ_DRIVER_STEP 16
+#define	FR_AZ_DRIVER_ROWS 8
+#define	FRF_AZ_DRIVER_DW0_LBN 0
+#define	FRF_AZ_DRIVER_DW0_WIDTH 32
+
+/* ALTERA_BUILD_REG: Altera build register */
+#define	FR_AZ_ALTERA_BUILD 0x00000300
+#define	FRF_AZ_ALTERA_BUILD_VER_LBN 0
+#define	FRF_AZ_ALTERA_BUILD_VER_WIDTH 32
+
+/* CSR_SPARE_REG: Spare register */
+#define	FR_AZ_CSR_SPARE 0x00000310
+#define	FRF_AB_MEM_PERR_EN_LBN 64
+#define	FRF_AB_MEM_PERR_EN_WIDTH 38
+#define	FRF_CZ_MEM_PERR_EN_LBN 64
+#define	FRF_CZ_MEM_PERR_EN_WIDTH 35
+#define	FRF_AB_MEM_PERR_EN_TX_DATA_LBN 72
+#define	FRF_AB_MEM_PERR_EN_TX_DATA_WIDTH 2
+#define	FRF_AZ_CSR_SPARE_BITS_LBN 0
+#define	FRF_AZ_CSR_SPARE_BITS_WIDTH 32
+
+/* PCIE_SD_CTL0123_REG: PCIE SerDes control register 0 to 3 */
+#define	FR_AB_PCIE_SD_CTL0123 0x00000320
+#define	FRF_AB_PCIE_TESTSIG_H_LBN 96
+#define	FRF_AB_PCIE_TESTSIG_H_WIDTH 19
+#define	FRF_AB_PCIE_TESTSIG_L_LBN 64
+#define	FRF_AB_PCIE_TESTSIG_L_WIDTH 19
+#define	FRF_AB_PCIE_OFFSET_LBN 56
+#define	FRF_AB_PCIE_OFFSET_WIDTH 8
+#define	FRF_AB_PCIE_OFFSETEN_H_LBN 55
+#define	FRF_AB_PCIE_OFFSETEN_H_WIDTH 1
+#define	FRF_AB_PCIE_OFFSETEN_L_LBN 54
+#define	FRF_AB_PCIE_OFFSETEN_L_WIDTH 1
+#define	FRF_AB_PCIE_HIVMODE_H_LBN 53
+#define	FRF_AB_PCIE_HIVMODE_H_WIDTH 1
+#define	FRF_AB_PCIE_HIVMODE_L_LBN 52
+#define	FRF_AB_PCIE_HIVMODE_L_WIDTH 1
+#define	FRF_AB_PCIE_PARRESET_H_LBN 51
+#define	FRF_AB_PCIE_PARRESET_H_WIDTH 1
+#define	FRF_AB_PCIE_PARRESET_L_LBN 50
+#define	FRF_AB_PCIE_PARRESET_L_WIDTH 1
+#define	FRF_AB_PCIE_LPBKWDRV_H_LBN 49
+#define	FRF_AB_PCIE_LPBKWDRV_H_WIDTH 1
+#define	FRF_AB_PCIE_LPBKWDRV_L_LBN 48
+#define	FRF_AB_PCIE_LPBKWDRV_L_WIDTH 1
+#define	FRF_AB_PCIE_LPBK_LBN 40
+#define	FRF_AB_PCIE_LPBK_WIDTH 8
+#define	FRF_AB_PCIE_PARLPBK_LBN 32
+#define	FRF_AB_PCIE_PARLPBK_WIDTH 8
+#define	FRF_AB_PCIE_RXTERMADJ_H_LBN 30
+#define	FRF_AB_PCIE_RXTERMADJ_H_WIDTH 2
+#define	FRF_AB_PCIE_RXTERMADJ_L_LBN 28
+#define	FRF_AB_PCIE_RXTERMADJ_L_WIDTH 2
+#define	FFE_AB_PCIE_RXTERMADJ_MIN15PCNT 3
+#define	FFE_AB_PCIE_RXTERMADJ_PL10PCNT 2
+#define	FFE_AB_PCIE_RXTERMADJ_MIN17PCNT 1
+#define	FFE_AB_PCIE_RXTERMADJ_NOMNL 0
+#define	FRF_AB_PCIE_TXTERMADJ_H_LBN 26
+#define	FRF_AB_PCIE_TXTERMADJ_H_WIDTH 2
+#define	FRF_AB_PCIE_TXTERMADJ_L_LBN 24
+#define	FRF_AB_PCIE_TXTERMADJ_L_WIDTH 2
+#define	FFE_AB_PCIE_TXTERMADJ_MIN15PCNT 3
+#define	FFE_AB_PCIE_TXTERMADJ_PL10PCNT 2
+#define	FFE_AB_PCIE_TXTERMADJ_MIN17PCNT 1
+#define	FFE_AB_PCIE_TXTERMADJ_NOMNL 0
+#define	FRF_AB_PCIE_RXEQCTL_H_LBN 18
+#define	FRF_AB_PCIE_RXEQCTL_H_WIDTH 2
+#define	FRF_AB_PCIE_RXEQCTL_L_LBN 16
+#define	FRF_AB_PCIE_RXEQCTL_L_WIDTH 2
+#define	FFE_AB_PCIE_RXEQCTL_OFF_ALT 3
+#define	FFE_AB_PCIE_RXEQCTL_OFF 2
+#define	FFE_AB_PCIE_RXEQCTL_MIN 1
+#define	FFE_AB_PCIE_RXEQCTL_MAX 0
+#define	FRF_AB_PCIE_HIDRV_LBN 8
+#define	FRF_AB_PCIE_HIDRV_WIDTH 8
+#define	FRF_AB_PCIE_LODRV_LBN 0
+#define	FRF_AB_PCIE_LODRV_WIDTH 8
+
+/* PCIE_SD_CTL45_REG: PCIE SerDes control register 4 and 5 */
+#define	FR_AB_PCIE_SD_CTL45 0x00000330
+#define	FRF_AB_PCIE_DTX7_LBN 60
+#define	FRF_AB_PCIE_DTX7_WIDTH 4
+#define	FRF_AB_PCIE_DTX6_LBN 56
+#define	FRF_AB_PCIE_DTX6_WIDTH 4
+#define	FRF_AB_PCIE_DTX5_LBN 52
+#define	FRF_AB_PCIE_DTX5_WIDTH 4
+#define	FRF_AB_PCIE_DTX4_LBN 48
+#define	FRF_AB_PCIE_DTX4_WIDTH 4
+#define	FRF_AB_PCIE_DTX3_LBN 44
+#define	FRF_AB_PCIE_DTX3_WIDTH 4
+#define	FRF_AB_PCIE_DTX2_LBN 40
+#define	FRF_AB_PCIE_DTX2_WIDTH 4
+#define	FRF_AB_PCIE_DTX1_LBN 36
+#define	FRF_AB_PCIE_DTX1_WIDTH 4
+#define	FRF_AB_PCIE_DTX0_LBN 32
+#define	FRF_AB_PCIE_DTX0_WIDTH 4
+#define	FRF_AB_PCIE_DEQ7_LBN 28
+#define	FRF_AB_PCIE_DEQ7_WIDTH 4
+#define	FRF_AB_PCIE_DEQ6_LBN 24
+#define	FRF_AB_PCIE_DEQ6_WIDTH 4
+#define	FRF_AB_PCIE_DEQ5_LBN 20
+#define	FRF_AB_PCIE_DEQ5_WIDTH 4
+#define	FRF_AB_PCIE_DEQ4_LBN 16
+#define	FRF_AB_PCIE_DEQ4_WIDTH 4
+#define	FRF_AB_PCIE_DEQ3_LBN 12
+#define	FRF_AB_PCIE_DEQ3_WIDTH 4
+#define	FRF_AB_PCIE_DEQ2_LBN 8
+#define	FRF_AB_PCIE_DEQ2_WIDTH 4
+#define	FRF_AB_PCIE_DEQ1_LBN 4
+#define	FRF_AB_PCIE_DEQ1_WIDTH 4
+#define	FRF_AB_PCIE_DEQ0_LBN 0
+#define	FRF_AB_PCIE_DEQ0_WIDTH 4
+
+/* PCIE_PCS_CTL_STAT_REG: PCIE PCS control and status register */
+#define	FR_AB_PCIE_PCS_CTL_STAT 0x00000340
+#define	FRF_AB_PCIE_PRBSERRCOUNT0_H_LBN 52
+#define	FRF_AB_PCIE_PRBSERRCOUNT0_H_WIDTH 4
+#define	FRF_AB_PCIE_PRBSERRCOUNT0_L_LBN 48
+#define	FRF_AB_PCIE_PRBSERRCOUNT0_L_WIDTH 4
+#define	FRF_AB_PCIE_PRBSERR_LBN 40
+#define	FRF_AB_PCIE_PRBSERR_WIDTH 8
+#define	FRF_AB_PCIE_PRBSERRH0_LBN 32
+#define	FRF_AB_PCIE_PRBSERRH0_WIDTH 8
+#define	FRF_AB_PCIE_FASTINIT_H_LBN 15
+#define	FRF_AB_PCIE_FASTINIT_H_WIDTH 1
+#define	FRF_AB_PCIE_FASTINIT_L_LBN 14
+#define	FRF_AB_PCIE_FASTINIT_L_WIDTH 1
+#define	FRF_AB_PCIE_CTCDISABLE_H_LBN 13
+#define	FRF_AB_PCIE_CTCDISABLE_H_WIDTH 1
+#define	FRF_AB_PCIE_CTCDISABLE_L_LBN 12
+#define	FRF_AB_PCIE_CTCDISABLE_L_WIDTH 1
+#define	FRF_AB_PCIE_PRBSSYNC_H_LBN 11
+#define	FRF_AB_PCIE_PRBSSYNC_H_WIDTH 1
+#define	FRF_AB_PCIE_PRBSSYNC_L_LBN 10
+#define	FRF_AB_PCIE_PRBSSYNC_L_WIDTH 1
+#define	FRF_AB_PCIE_PRBSERRACK_H_LBN 9
+#define	FRF_AB_PCIE_PRBSERRACK_H_WIDTH 1
+#define	FRF_AB_PCIE_PRBSERRACK_L_LBN 8
+#define	FRF_AB_PCIE_PRBSERRACK_L_WIDTH 1
+#define	FRF_AB_PCIE_PRBSSEL_LBN 0
+#define	FRF_AB_PCIE_PRBSSEL_WIDTH 8
+
+/* DEBUG_DATA_OUT_REG: Live Debug and Debug 2 out ports */
+#define	FR_BB_DEBUG_DATA_OUT 0x00000350
+#define	FRF_BB_DEBUG2_PORT_LBN 25
+#define	FRF_BB_DEBUG2_PORT_WIDTH 15
+#define	FRF_BB_DEBUG1_PORT_LBN 0
+#define	FRF_BB_DEBUG1_PORT_WIDTH 25
+
+/* EVQ_RPTR_REGP0: Event queue read pointer register */
+#define	FR_BZ_EVQ_RPTR_P0 0x00000400
+#define	FR_BZ_EVQ_RPTR_P0_STEP 8192
+#define	FR_BZ_EVQ_RPTR_P0_ROWS 1024
+/* EVQ_RPTR_REG_KER: Event queue read pointer register */
+#define	FR_AA_EVQ_RPTR_KER 0x00011b00
+#define	FR_AA_EVQ_RPTR_KER_STEP 4
+#define	FR_AA_EVQ_RPTR_KER_ROWS 4
+/* EVQ_RPTR_REG: Event queue read pointer register */
+#define	FR_BZ_EVQ_RPTR 0x00fa0000
+#define	FR_BZ_EVQ_RPTR_STEP 16
+#define	FR_BB_EVQ_RPTR_ROWS 4096
+#define	FR_CZ_EVQ_RPTR_ROWS 1024
+/* EVQ_RPTR_REGP123: Event queue read pointer register */
+#define	FR_BB_EVQ_RPTR_P123 0x01000400
+#define	FR_BB_EVQ_RPTR_P123_STEP 8192
+#define	FR_BB_EVQ_RPTR_P123_ROWS 3072
+#define	FRF_AZ_EVQ_RPTR_VLD_LBN 15
+#define	FRF_AZ_EVQ_RPTR_VLD_WIDTH 1
+#define	FRF_AZ_EVQ_RPTR_LBN 0
+#define	FRF_AZ_EVQ_RPTR_WIDTH 15
+
+/* TIMER_COMMAND_REGP0: Timer Command Registers */
+#define	FR_BZ_TIMER_COMMAND_P0 0x00000420
+#define	FR_BZ_TIMER_COMMAND_P0_STEP 8192
+#define	FR_BZ_TIMER_COMMAND_P0_ROWS 1024
+/* TIMER_COMMAND_REG_KER: Timer Command Registers */
+#define	FR_AA_TIMER_COMMAND_KER 0x00000420
+#define	FR_AA_TIMER_COMMAND_KER_STEP 8192
+#define	FR_AA_TIMER_COMMAND_KER_ROWS 4
+/* TIMER_COMMAND_REGP123: Timer Command Registers */
+#define	FR_BB_TIMER_COMMAND_P123 0x01000420
+#define	FR_BB_TIMER_COMMAND_P123_STEP 8192
+#define	FR_BB_TIMER_COMMAND_P123_ROWS 3072
+#define	FRF_CZ_TC_TIMER_MODE_LBN 14
+#define	FRF_CZ_TC_TIMER_MODE_WIDTH 2
+#define	FRF_AB_TC_TIMER_MODE_LBN 12
+#define	FRF_AB_TC_TIMER_MODE_WIDTH 2
+#define	FRF_CZ_TC_TIMER_VAL_LBN 0
+#define	FRF_CZ_TC_TIMER_VAL_WIDTH 14
+#define	FRF_AB_TC_TIMER_VAL_LBN 0
+#define	FRF_AB_TC_TIMER_VAL_WIDTH 12
+
+/* DRV_EV_REG: Driver generated event register */
+#define	FR_AZ_DRV_EV 0x00000440
+#define	FRF_AZ_DRV_EV_QID_LBN 64
+#define	FRF_AZ_DRV_EV_QID_WIDTH 12
+#define	FRF_AZ_DRV_EV_DATA_LBN 0
+#define	FRF_AZ_DRV_EV_DATA_WIDTH 64
+
+/* EVQ_CTL_REG: Event queue control register */
+#define	FR_AZ_EVQ_CTL 0x00000450
+#define	FRF_CZ_RX_EVQ_WAKEUP_MASK_LBN 15
+#define	FRF_CZ_RX_EVQ_WAKEUP_MASK_WIDTH 10
+#define	FRF_BB_RX_EVQ_WAKEUP_MASK_LBN 15
+#define	FRF_BB_RX_EVQ_WAKEUP_MASK_WIDTH 6
+#define	FRF_AZ_EVQ_OWNERR_CTL_LBN 14
+#define	FRF_AZ_EVQ_OWNERR_CTL_WIDTH 1
+#define	FRF_AZ_EVQ_FIFO_AF_TH_LBN 7
+#define	FRF_AZ_EVQ_FIFO_AF_TH_WIDTH 7
+#define	FRF_AZ_EVQ_FIFO_NOTAF_TH_LBN 0
+#define	FRF_AZ_EVQ_FIFO_NOTAF_TH_WIDTH 7
+
+/* EVQ_CNT1_REG: Event counter 1 register */
+#define	FR_AZ_EVQ_CNT1 0x00000460
+#define	FRF_AZ_EVQ_CNT_PRE_FIFO_LBN 120
+#define	FRF_AZ_EVQ_CNT_PRE_FIFO_WIDTH 7
+#define	FRF_AZ_EVQ_CNT_TOBIU_LBN 100
+#define	FRF_AZ_EVQ_CNT_TOBIU_WIDTH 20
+#define	FRF_AZ_EVQ_TX_REQ_CNT_LBN 80
+#define	FRF_AZ_EVQ_TX_REQ_CNT_WIDTH 20
+#define	FRF_AZ_EVQ_RX_REQ_CNT_LBN 60
+#define	FRF_AZ_EVQ_RX_REQ_CNT_WIDTH 20
+#define	FRF_AZ_EVQ_EM_REQ_CNT_LBN 40
+#define	FRF_AZ_EVQ_EM_REQ_CNT_WIDTH 20
+#define	FRF_AZ_EVQ_CSR_REQ_CNT_LBN 20
+#define	FRF_AZ_EVQ_CSR_REQ_CNT_WIDTH 20
+#define	FRF_AZ_EVQ_ERR_REQ_CNT_LBN 0
+#define	FRF_AZ_EVQ_ERR_REQ_CNT_WIDTH 20
+
+/* EVQ_CNT2_REG: Event counter 2 register */
+#define	FR_AZ_EVQ_CNT2 0x00000470
+#define	FRF_AZ_EVQ_UPD_REQ_CNT_LBN 104
+#define	FRF_AZ_EVQ_UPD_REQ_CNT_WIDTH 20
+#define	FRF_AZ_EVQ_CLR_REQ_CNT_LBN 84
+#define	FRF_AZ_EVQ_CLR_REQ_CNT_WIDTH 20
+#define	FRF_AZ_EVQ_RDY_CNT_LBN 80
+#define	FRF_AZ_EVQ_RDY_CNT_WIDTH 4
+#define	FRF_AZ_EVQ_WU_REQ_CNT_LBN 60
+#define	FRF_AZ_EVQ_WU_REQ_CNT_WIDTH 20
+#define	FRF_AZ_EVQ_WET_REQ_CNT_LBN 40
+#define	FRF_AZ_EVQ_WET_REQ_CNT_WIDTH 20
+#define	FRF_AZ_EVQ_INIT_REQ_CNT_LBN 20
+#define	FRF_AZ_EVQ_INIT_REQ_CNT_WIDTH 20
+#define	FRF_AZ_EVQ_TM_REQ_CNT_LBN 0
+#define	FRF_AZ_EVQ_TM_REQ_CNT_WIDTH 20
+
+/* USR_EV_REG: Event mailbox register */
+#define	FR_CZ_USR_EV 0x00000540
+#define	FR_CZ_USR_EV_STEP 8192
+#define	FR_CZ_USR_EV_ROWS 1024
+#define	FRF_CZ_USR_EV_DATA_LBN 0
+#define	FRF_CZ_USR_EV_DATA_WIDTH 32
+
+/* BUF_TBL_CFG_REG: Buffer table configuration register */
+#define	FR_AZ_BUF_TBL_CFG 0x00000600
+#define	FRF_AZ_BUF_TBL_MODE_LBN 3
+#define	FRF_AZ_BUF_TBL_MODE_WIDTH 1
+
+/* SRM_RX_DC_CFG_REG: SRAM receive descriptor cache configuration register */
+#define	FR_AZ_SRM_RX_DC_CFG 0x00000610
+#define	FRF_AZ_SRM_CLK_TMP_EN_LBN 21
+#define	FRF_AZ_SRM_CLK_TMP_EN_WIDTH 1
+#define	FRF_AZ_SRM_RX_DC_BASE_ADR_LBN 0
+#define	FRF_AZ_SRM_RX_DC_BASE_ADR_WIDTH 21
+
+/* SRM_TX_DC_CFG_REG: SRAM transmit descriptor cache configuration register */
+#define	FR_AZ_SRM_TX_DC_CFG 0x00000620
+#define	FRF_AZ_SRM_TX_DC_BASE_ADR_LBN 0
+#define	FRF_AZ_SRM_TX_DC_BASE_ADR_WIDTH 21
+
+/* SRM_CFG_REG: SRAM configuration register */
+#define	FR_AZ_SRM_CFG 0x00000630
+#define	FRF_AZ_SRM_OOB_ADR_INTEN_LBN 5
+#define	FRF_AZ_SRM_OOB_ADR_INTEN_WIDTH 1
+#define	FRF_AZ_SRM_OOB_BUF_INTEN_LBN 4
+#define	FRF_AZ_SRM_OOB_BUF_INTEN_WIDTH 1
+#define	FRF_AZ_SRM_INIT_EN_LBN 3
+#define	FRF_AZ_SRM_INIT_EN_WIDTH 1
+#define	FRF_AZ_SRM_NUM_BANK_LBN 2
+#define	FRF_AZ_SRM_NUM_BANK_WIDTH 1
+#define	FRF_AZ_SRM_BANK_SIZE_LBN 0
+#define	FRF_AZ_SRM_BANK_SIZE_WIDTH 2
+
+/* BUF_TBL_UPD_REG: Buffer table update register */
+#define	FR_AZ_BUF_TBL_UPD 0x00000650
+#define	FRF_AZ_BUF_UPD_CMD_LBN 63
+#define	FRF_AZ_BUF_UPD_CMD_WIDTH 1
+#define	FRF_AZ_BUF_CLR_CMD_LBN 62
+#define	FRF_AZ_BUF_CLR_CMD_WIDTH 1
+#define	FRF_AZ_BUF_CLR_END_ID_LBN 32
+#define	FRF_AZ_BUF_CLR_END_ID_WIDTH 20
+#define	FRF_AZ_BUF_CLR_START_ID_LBN 0
+#define	FRF_AZ_BUF_CLR_START_ID_WIDTH 20
+
+/* SRM_UPD_EVQ_REG: Buffer table update register */
+#define	FR_AZ_SRM_UPD_EVQ 0x00000660
+#define	FRF_AZ_SRM_UPD_EVQ_ID_LBN 0
+#define	FRF_AZ_SRM_UPD_EVQ_ID_WIDTH 12
+
+/* SRAM_PARITY_REG: SRAM parity register. */
+#define	FR_AZ_SRAM_PARITY 0x00000670
+#define	FRF_CZ_BYPASS_ECC_LBN 3
+#define	FRF_CZ_BYPASS_ECC_WIDTH 1
+#define	FRF_CZ_SEC_INT_LBN 2
+#define	FRF_CZ_SEC_INT_WIDTH 1
+#define	FRF_CZ_FORCE_SRAM_DOUBLE_ERR_LBN 1
+#define	FRF_CZ_FORCE_SRAM_DOUBLE_ERR_WIDTH 1
+#define	FRF_AB_FORCE_SRAM_PERR_LBN 0
+#define	FRF_AB_FORCE_SRAM_PERR_WIDTH 1
+#define	FRF_CZ_FORCE_SRAM_SINGLE_ERR_LBN 0
+#define	FRF_CZ_FORCE_SRAM_SINGLE_ERR_WIDTH 1
+
+/* RX_CFG_REG: Receive configuration register */
+#define	FR_AZ_RX_CFG 0x00000800
+#define	FRF_CZ_RX_MIN_KBUF_SIZE_LBN 72
+#define	FRF_CZ_RX_MIN_KBUF_SIZE_WIDTH 14
+#define	FRF_CZ_RX_HDR_SPLIT_EN_LBN 71
+#define	FRF_CZ_RX_HDR_SPLIT_EN_WIDTH 1
+#define	FRF_CZ_RX_HDR_SPLIT_PLD_BUF_SIZE_LBN 62
+#define	FRF_CZ_RX_HDR_SPLIT_PLD_BUF_SIZE_WIDTH 9
+#define	FRF_CZ_RX_HDR_SPLIT_HDR_BUF_SIZE_LBN 53
+#define	FRF_CZ_RX_HDR_SPLIT_HDR_BUF_SIZE_WIDTH 9
+#define	FRF_CZ_RX_PRE_RFF_IPG_LBN 49
+#define	FRF_CZ_RX_PRE_RFF_IPG_WIDTH 4
+#define	FRF_BZ_RX_TCP_SUP_LBN 48
+#define	FRF_BZ_RX_TCP_SUP_WIDTH 1
+#define	FRF_BZ_RX_INGR_EN_LBN 47
+#define	FRF_BZ_RX_INGR_EN_WIDTH 1
+#define	FRF_BZ_RX_IP_HASH_LBN 46
+#define	FRF_BZ_RX_IP_HASH_WIDTH 1
+#define	FRF_BZ_RX_HASH_ALG_LBN 45
+#define	FRF_BZ_RX_HASH_ALG_WIDTH 1
+#define	FRF_BZ_RX_HASH_INSRT_HDR_LBN 44
+#define	FRF_BZ_RX_HASH_INSRT_HDR_WIDTH 1
+#define	FRF_BZ_RX_DESC_PUSH_EN_LBN 43
+#define	FRF_BZ_RX_DESC_PUSH_EN_WIDTH 1
+#define	FRF_BZ_RX_RDW_PATCH_EN_LBN 42
+#define	FRF_BZ_RX_RDW_PATCH_EN_WIDTH 1
+#define	FRF_BB_RX_PCI_BURST_SIZE_LBN 39
+#define	FRF_BB_RX_PCI_BURST_SIZE_WIDTH 3
+#define	FRF_BZ_RX_OWNERR_CTL_LBN 38
+#define	FRF_BZ_RX_OWNERR_CTL_WIDTH 1
+#define	FRF_BZ_RX_XON_TX_TH_LBN 33
+#define	FRF_BZ_RX_XON_TX_TH_WIDTH 5
+#define	FRF_AA_RX_DESC_PUSH_EN_LBN 35
+#define	FRF_AA_RX_DESC_PUSH_EN_WIDTH 1
+#define	FRF_AA_RX_RDW_PATCH_EN_LBN 34
+#define	FRF_AA_RX_RDW_PATCH_EN_WIDTH 1
+#define	FRF_AA_RX_PCI_BURST_SIZE_LBN 31
+#define	FRF_AA_RX_PCI_BURST_SIZE_WIDTH 3
+#define	FRF_BZ_RX_XOFF_TX_TH_LBN 28
+#define	FRF_BZ_RX_XOFF_TX_TH_WIDTH 5
+#define	FRF_AA_RX_OWNERR_CTL_LBN 30
+#define	FRF_AA_RX_OWNERR_CTL_WIDTH 1
+#define	FRF_AA_RX_XON_TX_TH_LBN 25
+#define	FRF_AA_RX_XON_TX_TH_WIDTH 5
+#define	FRF_BZ_RX_USR_BUF_SIZE_LBN 19
+#define	FRF_BZ_RX_USR_BUF_SIZE_WIDTH 9
+#define	FRF_AA_RX_XOFF_TX_TH_LBN 20
+#define	FRF_AA_RX_XOFF_TX_TH_WIDTH 5
+#define	FRF_AA_RX_USR_BUF_SIZE_LBN 11
+#define	FRF_AA_RX_USR_BUF_SIZE_WIDTH 9
+#define	FRF_BZ_RX_XON_MAC_TH_LBN 10
+#define	FRF_BZ_RX_XON_MAC_TH_WIDTH 9
+#define	FRF_AA_RX_XON_MAC_TH_LBN 6
+#define	FRF_AA_RX_XON_MAC_TH_WIDTH 5
+#define	FRF_BZ_RX_XOFF_MAC_TH_LBN 1
+#define	FRF_BZ_RX_XOFF_MAC_TH_WIDTH 9
+#define	FRF_AA_RX_XOFF_MAC_TH_LBN 1
+#define	FRF_AA_RX_XOFF_MAC_TH_WIDTH 5
+#define	FRF_AZ_RX_XOFF_MAC_EN_LBN 0
+#define	FRF_AZ_RX_XOFF_MAC_EN_WIDTH 1
+
+/* RX_FILTER_CTL_REG: Receive filter control registers */
+#define	FR_BZ_RX_FILTER_CTL 0x00000810
+#define	FRF_CZ_ETHERNET_WILDCARD_SEARCH_LIMIT_LBN 94
+#define	FRF_CZ_ETHERNET_WILDCARD_SEARCH_LIMIT_WIDTH 8
+#define	FRF_CZ_ETHERNET_FULL_SEARCH_LIMIT_LBN 86
+#define	FRF_CZ_ETHERNET_FULL_SEARCH_LIMIT_WIDTH 8
+#define	FRF_CZ_RX_FILTER_ALL_VLAN_ETHERTYPES_LBN 85
+#define	FRF_CZ_RX_FILTER_ALL_VLAN_ETHERTYPES_WIDTH 1
+#define	FRF_CZ_RX_VLAN_MATCH_ETHERTYPE_LBN 69
+#define	FRF_CZ_RX_VLAN_MATCH_ETHERTYPE_WIDTH 16
+#define	FRF_CZ_MULTICAST_NOMATCH_Q_ID_LBN 57
+#define	FRF_CZ_MULTICAST_NOMATCH_Q_ID_WIDTH 12
+#define	FRF_CZ_MULTICAST_NOMATCH_RSS_ENABLED_LBN 56
+#define	FRF_CZ_MULTICAST_NOMATCH_RSS_ENABLED_WIDTH 1
+#define	FRF_CZ_MULTICAST_NOMATCH_IP_OVERRIDE_LBN 55
+#define	FRF_CZ_MULTICAST_NOMATCH_IP_OVERRIDE_WIDTH 1
+#define	FRF_CZ_UNICAST_NOMATCH_Q_ID_LBN 43
+#define	FRF_CZ_UNICAST_NOMATCH_Q_ID_WIDTH 12
+#define	FRF_CZ_UNICAST_NOMATCH_RSS_ENABLED_LBN 42
+#define	FRF_CZ_UNICAST_NOMATCH_RSS_ENABLED_WIDTH 1
+#define	FRF_CZ_UNICAST_NOMATCH_IP_OVERRIDE_LBN 41
+#define	FRF_CZ_UNICAST_NOMATCH_IP_OVERRIDE_WIDTH 1
+#define	FRF_BZ_SCATTER_ENBL_NO_MATCH_Q_LBN 40
+#define	FRF_BZ_SCATTER_ENBL_NO_MATCH_Q_WIDTH 1
+#define	FRF_BZ_UDP_FULL_SRCH_LIMIT_LBN 32
+#define	FRF_BZ_UDP_FULL_SRCH_LIMIT_WIDTH 8
+#define	FRF_BZ_NUM_KER_LBN 24
+#define	FRF_BZ_NUM_KER_WIDTH 2
+#define	FRF_BZ_UDP_WILD_SRCH_LIMIT_LBN 16
+#define	FRF_BZ_UDP_WILD_SRCH_LIMIT_WIDTH 8
+#define	FRF_BZ_TCP_WILD_SRCH_LIMIT_LBN 8
+#define	FRF_BZ_TCP_WILD_SRCH_LIMIT_WIDTH 8
+#define	FRF_BZ_TCP_FULL_SRCH_LIMIT_LBN 0
+#define	FRF_BZ_TCP_FULL_SRCH_LIMIT_WIDTH 8
+
+/* RX_FLUSH_DESCQ_REG: Receive flush descriptor queue register */
+#define	FR_AZ_RX_FLUSH_DESCQ 0x00000820
+#define	FRF_AZ_RX_FLUSH_DESCQ_CMD_LBN 24
+#define	FRF_AZ_RX_FLUSH_DESCQ_CMD_WIDTH 1
+#define	FRF_AZ_RX_FLUSH_DESCQ_LBN 0
+#define	FRF_AZ_RX_FLUSH_DESCQ_WIDTH 12
+
+/* RX_DESC_UPD_REGP0: Receive descriptor update register. */
+#define	FR_BZ_RX_DESC_UPD_P0 0x00000830
+#define	FR_BZ_RX_DESC_UPD_P0_STEP 8192
+#define	FR_BZ_RX_DESC_UPD_P0_ROWS 1024
+/* RX_DESC_UPD_REG_KER: Receive descriptor update register. */
+#define	FR_AA_RX_DESC_UPD_KER 0x00000830
+#define	FR_AA_RX_DESC_UPD_KER_STEP 8192
+#define	FR_AA_RX_DESC_UPD_KER_ROWS 4
+/* RX_DESC_UPD_REGP123: Receive descriptor update register. */
+#define	FR_BB_RX_DESC_UPD_P123 0x01000830
+#define	FR_BB_RX_DESC_UPD_P123_STEP 8192
+#define	FR_BB_RX_DESC_UPD_P123_ROWS 3072
+#define	FRF_AZ_RX_DESC_WPTR_LBN 96
+#define	FRF_AZ_RX_DESC_WPTR_WIDTH 12
+#define	FRF_AZ_RX_DESC_PUSH_CMD_LBN 95
+#define	FRF_AZ_RX_DESC_PUSH_CMD_WIDTH 1
+#define	FRF_AZ_RX_DESC_LBN 0
+#define	FRF_AZ_RX_DESC_WIDTH 64
+
+/* RX_DC_CFG_REG: Receive descriptor cache configuration register */
+#define	FR_AZ_RX_DC_CFG 0x00000840
+#define	FRF_AB_RX_MAX_PF_LBN 2
+#define	FRF_AB_RX_MAX_PF_WIDTH 2
+#define	FRF_AZ_RX_DC_SIZE_LBN 0
+#define	FRF_AZ_RX_DC_SIZE_WIDTH 2
+#define	FFE_AZ_RX_DC_SIZE_64 3
+#define	FFE_AZ_RX_DC_SIZE_32 2
+#define	FFE_AZ_RX_DC_SIZE_16 1
+#define	FFE_AZ_RX_DC_SIZE_8 0
+
+/* RX_DC_PF_WM_REG: Receive descriptor cache pre-fetch watermark register */
+#define	FR_AZ_RX_DC_PF_WM 0x00000850
+#define	FRF_AZ_RX_DC_PF_HWM_LBN 6
+#define	FRF_AZ_RX_DC_PF_HWM_WIDTH 6
+#define	FRF_AZ_RX_DC_PF_LWM_LBN 0
+#define	FRF_AZ_RX_DC_PF_LWM_WIDTH 6
+
+/* RX_RSS_TKEY_REG: RSS Toeplitz hash key */
+#define	FR_BZ_RX_RSS_TKEY 0x00000860
+#define	FRF_BZ_RX_RSS_TKEY_HI_LBN 64
+#define	FRF_BZ_RX_RSS_TKEY_HI_WIDTH 64
+#define	FRF_BZ_RX_RSS_TKEY_LO_LBN 0
+#define	FRF_BZ_RX_RSS_TKEY_LO_WIDTH 64
+
+/* RX_NODESC_DROP_REG: Receive dropped packet counter register */
+#define	FR_AZ_RX_NODESC_DROP 0x00000880
+#define	FRF_CZ_RX_NODESC_DROP_CNT_LBN 0
+#define	FRF_CZ_RX_NODESC_DROP_CNT_WIDTH 32
+#define	FRF_AB_RX_NODESC_DROP_CNT_LBN 0
+#define	FRF_AB_RX_NODESC_DROP_CNT_WIDTH 16
+
+/* RX_SELF_RST_REG: Receive self reset register */
+#define	FR_AA_RX_SELF_RST 0x00000890
+#define	FRF_AA_RX_ISCSI_DIS_LBN 17
+#define	FRF_AA_RX_ISCSI_DIS_WIDTH 1
+#define	FRF_AA_RX_SW_RST_REG_LBN 16
+#define	FRF_AA_RX_SW_RST_REG_WIDTH 1
+#define	FRF_AA_RX_NODESC_WAIT_DIS_LBN 9
+#define	FRF_AA_RX_NODESC_WAIT_DIS_WIDTH 1
+#define	FRF_AA_RX_SELF_RST_EN_LBN 8
+#define	FRF_AA_RX_SELF_RST_EN_WIDTH 1
+#define	FRF_AA_RX_MAX_PF_LAT_LBN 4
+#define	FRF_AA_RX_MAX_PF_LAT_WIDTH 4
+#define	FRF_AA_RX_MAX_LU_LAT_LBN 0
+#define	FRF_AA_RX_MAX_LU_LAT_WIDTH 4
+
+/* RX_DEBUG_REG: undocumented register */
+#define	FR_AZ_RX_DEBUG 0x000008a0
+#define	FRF_AZ_RX_DEBUG_LBN 0
+#define	FRF_AZ_RX_DEBUG_WIDTH 64
+
+/* RX_PUSH_DROP_REG: Receive descriptor push dropped counter register */
+#define	FR_AZ_RX_PUSH_DROP 0x000008b0
+#define	FRF_AZ_RX_PUSH_DROP_CNT_LBN 0
+#define	FRF_AZ_RX_PUSH_DROP_CNT_WIDTH 32
+
+/* RX_RSS_IPV6_REG1: IPv6 RSS Toeplitz hash key low bytes */
+#define	FR_CZ_RX_RSS_IPV6_REG1 0x000008d0
+#define	FRF_CZ_RX_RSS_IPV6_TKEY_LO_LBN 0
+#define	FRF_CZ_RX_RSS_IPV6_TKEY_LO_WIDTH 128
+
+/* RX_RSS_IPV6_REG2: IPv6 RSS Toeplitz hash key middle bytes */
+#define	FR_CZ_RX_RSS_IPV6_REG2 0x000008e0
+#define	FRF_CZ_RX_RSS_IPV6_TKEY_MID_LBN 0
+#define	FRF_CZ_RX_RSS_IPV6_TKEY_MID_WIDTH 128
+
+/* RX_RSS_IPV6_REG3: IPv6 RSS Toeplitz hash key upper bytes and IPv6 RSS settings */
+#define	FR_CZ_RX_RSS_IPV6_REG3 0x000008f0
+#define	FRF_CZ_RX_RSS_IPV6_THASH_ENABLE_LBN 66
+#define	FRF_CZ_RX_RSS_IPV6_THASH_ENABLE_WIDTH 1
+#define	FRF_CZ_RX_RSS_IPV6_IP_THASH_ENABLE_LBN 65
+#define	FRF_CZ_RX_RSS_IPV6_IP_THASH_ENABLE_WIDTH 1
+#define	FRF_CZ_RX_RSS_IPV6_TCP_SUPPRESS_LBN 64
+#define	FRF_CZ_RX_RSS_IPV6_TCP_SUPPRESS_WIDTH 1
+#define	FRF_CZ_RX_RSS_IPV6_TKEY_HI_LBN 0
+#define	FRF_CZ_RX_RSS_IPV6_TKEY_HI_WIDTH 64
+
+/* TX_FLUSH_DESCQ_REG: Transmit flush descriptor queue register */
+#define	FR_AZ_TX_FLUSH_DESCQ 0x00000a00
+#define	FRF_AZ_TX_FLUSH_DESCQ_CMD_LBN 12
+#define	FRF_AZ_TX_FLUSH_DESCQ_CMD_WIDTH 1
+#define	FRF_AZ_TX_FLUSH_DESCQ_LBN 0
+#define	FRF_AZ_TX_FLUSH_DESCQ_WIDTH 12
+
+/* TX_DESC_UPD_REGP0: Transmit descriptor update register. */
+#define	FR_BZ_TX_DESC_UPD_P0 0x00000a10
+#define	FR_BZ_TX_DESC_UPD_P0_STEP 8192
+#define	FR_BZ_TX_DESC_UPD_P0_ROWS 1024
+/* TX_DESC_UPD_REG_KER: Transmit descriptor update register. */
+#define	FR_AA_TX_DESC_UPD_KER 0x00000a10
+#define	FR_AA_TX_DESC_UPD_KER_STEP 8192
+#define	FR_AA_TX_DESC_UPD_KER_ROWS 8
+/* TX_DESC_UPD_REGP123: Transmit descriptor update register. */
+#define	FR_BB_TX_DESC_UPD_P123 0x01000a10
+#define	FR_BB_TX_DESC_UPD_P123_STEP 8192
+#define	FR_BB_TX_DESC_UPD_P123_ROWS 3072
+#define	FRF_AZ_TX_DESC_WPTR_LBN 96
+#define	FRF_AZ_TX_DESC_WPTR_WIDTH 12
+#define	FRF_AZ_TX_DESC_PUSH_CMD_LBN 95
+#define	FRF_AZ_TX_DESC_PUSH_CMD_WIDTH 1
+#define	FRF_AZ_TX_DESC_LBN 0
+#define	FRF_AZ_TX_DESC_WIDTH 95
+
+/* TX_DC_CFG_REG: Transmit descriptor cache configuration register */
+#define	FR_AZ_TX_DC_CFG 0x00000a20
+#define	FRF_AZ_TX_DC_SIZE_LBN 0
+#define	FRF_AZ_TX_DC_SIZE_WIDTH 2
+#define	FFE_AZ_TX_DC_SIZE_32 2
+#define	FFE_AZ_TX_DC_SIZE_16 1
+#define	FFE_AZ_TX_DC_SIZE_8 0
+
+/* TX_CHKSM_CFG_REG: Transmit checksum configuration register */
+#define	FR_AA_TX_CHKSM_CFG 0x00000a30
+#define	FRF_AA_TX_Q_CHKSM_DIS_96_127_LBN 96
+#define	FRF_AA_TX_Q_CHKSM_DIS_96_127_WIDTH 32
+#define	FRF_AA_TX_Q_CHKSM_DIS_64_95_LBN 64
+#define	FRF_AA_TX_Q_CHKSM_DIS_64_95_WIDTH 32
+#define	FRF_AA_TX_Q_CHKSM_DIS_32_63_LBN 32
+#define	FRF_AA_TX_Q_CHKSM_DIS_32_63_WIDTH 32
+#define	FRF_AA_TX_Q_CHKSM_DIS_0_31_LBN 0
+#define	FRF_AA_TX_Q_CHKSM_DIS_0_31_WIDTH 32
+
+/* TX_CFG_REG: Transmit configuration register */
+#define	FR_AZ_TX_CFG 0x00000a50
+#define	FRF_CZ_TX_CONT_LOOKUP_THRESH_RANGE_LBN 114
+#define	FRF_CZ_TX_CONT_LOOKUP_THRESH_RANGE_WIDTH 8
+#define	FRF_CZ_TX_FILTER_TEST_MODE_BIT_LBN 113
+#define	FRF_CZ_TX_FILTER_TEST_MODE_BIT_WIDTH 1
+#define	FRF_CZ_TX_ETH_FILTER_WILD_SEARCH_RANGE_LBN 105
+#define	FRF_CZ_TX_ETH_FILTER_WILD_SEARCH_RANGE_WIDTH 8
+#define	FRF_CZ_TX_ETH_FILTER_FULL_SEARCH_RANGE_LBN 97
+#define	FRF_CZ_TX_ETH_FILTER_FULL_SEARCH_RANGE_WIDTH 8
+#define	FRF_CZ_TX_UDPIP_FILTER_WILD_SEARCH_RANGE_LBN 89
+#define	FRF_CZ_TX_UDPIP_FILTER_WILD_SEARCH_RANGE_WIDTH 8
+#define	FRF_CZ_TX_UDPIP_FILTER_FULL_SEARCH_RANGE_LBN 81
+#define	FRF_CZ_TX_UDPIP_FILTER_FULL_SEARCH_RANGE_WIDTH 8
+#define	FRF_CZ_TX_TCPIP_FILTER_WILD_SEARCH_RANGE_LBN 73
+#define	FRF_CZ_TX_TCPIP_FILTER_WILD_SEARCH_RANGE_WIDTH 8
+#define	FRF_CZ_TX_TCPIP_FILTER_FULL_SEARCH_RANGE_LBN 65
+#define	FRF_CZ_TX_TCPIP_FILTER_FULL_SEARCH_RANGE_WIDTH 8
+#define	FRF_CZ_TX_FILTER_ALL_VLAN_ETHERTYPES_BIT_LBN 64
+#define	FRF_CZ_TX_FILTER_ALL_VLAN_ETHERTYPES_BIT_WIDTH 1
+#define	FRF_CZ_TX_VLAN_MATCH_ETHERTYPE_RANGE_LBN 48
+#define	FRF_CZ_TX_VLAN_MATCH_ETHERTYPE_RANGE_WIDTH 16
+#define	FRF_CZ_TX_FILTER_EN_BIT_LBN 47
+#define	FRF_CZ_TX_FILTER_EN_BIT_WIDTH 1
+#define	FRF_AZ_TX_IP_ID_P0_OFS_LBN 16
+#define	FRF_AZ_TX_IP_ID_P0_OFS_WIDTH 15
+#define	FRF_AZ_TX_NO_EOP_DISC_EN_LBN 5
+#define	FRF_AZ_TX_NO_EOP_DISC_EN_WIDTH 1
+#define	FRF_AZ_TX_P1_PRI_EN_LBN 4
+#define	FRF_AZ_TX_P1_PRI_EN_WIDTH 1
+#define	FRF_AZ_TX_OWNERR_CTL_LBN 2
+#define	FRF_AZ_TX_OWNERR_CTL_WIDTH 1
+#define	FRF_AA_TX_NON_IP_DROP_DIS_LBN 1
+#define	FRF_AA_TX_NON_IP_DROP_DIS_WIDTH 1
+#define	FRF_AZ_TX_IP_ID_REP_EN_LBN 0
+#define	FRF_AZ_TX_IP_ID_REP_EN_WIDTH 1
+
+/* TX_PUSH_DROP_REG: Transmit push dropped register */
+#define	FR_AZ_TX_PUSH_DROP 0x00000a60
+#define	FRF_AZ_TX_PUSH_DROP_CNT_LBN 0
+#define	FRF_AZ_TX_PUSH_DROP_CNT_WIDTH 32
+
+/* TX_RESERVED_REG: Transmit configuration register */
+#define	FR_AZ_TX_RESERVED 0x00000a80
+#define	FRF_AZ_TX_EVT_CNT_LBN 121
+#define	FRF_AZ_TX_EVT_CNT_WIDTH 7
+#define	FRF_AZ_TX_PREF_AGE_CNT_LBN 119
+#define	FRF_AZ_TX_PREF_AGE_CNT_WIDTH 2
+#define	FRF_AZ_TX_RD_COMP_TMR_LBN 96
+#define	FRF_AZ_TX_RD_COMP_TMR_WIDTH 23
+#define	FRF_AZ_TX_PUSH_EN_LBN 89
+#define	FRF_AZ_TX_PUSH_EN_WIDTH 1
+#define	FRF_AZ_TX_PUSH_CHK_DIS_LBN 88
+#define	FRF_AZ_TX_PUSH_CHK_DIS_WIDTH 1
+#define	FRF_AZ_TX_D_FF_FULL_P0_LBN 85
+#define	FRF_AZ_TX_D_FF_FULL_P0_WIDTH 1
+#define	FRF_AZ_TX_DMAR_ST_P0_LBN 81
+#define	FRF_AZ_TX_DMAR_ST_P0_WIDTH 1
+#define	FRF_AZ_TX_DMAQ_ST_LBN 78
+#define	FRF_AZ_TX_DMAQ_ST_WIDTH 1
+#define	FRF_AZ_TX_RX_SPACER_LBN 64
+#define	FRF_AZ_TX_RX_SPACER_WIDTH 8
+#define	FRF_AZ_TX_DROP_ABORT_EN_LBN 60
+#define	FRF_AZ_TX_DROP_ABORT_EN_WIDTH 1
+#define	FRF_AZ_TX_SOFT_EVT_EN_LBN 59
+#define	FRF_AZ_TX_SOFT_EVT_EN_WIDTH 1
+#define	FRF_AZ_TX_PS_EVT_DIS_LBN 58
+#define	FRF_AZ_TX_PS_EVT_DIS_WIDTH 1
+#define	FRF_AZ_TX_RX_SPACER_EN_LBN 57
+#define	FRF_AZ_TX_RX_SPACER_EN_WIDTH 1
+#define	FRF_AZ_TX_XP_TIMER_LBN 52
+#define	FRF_AZ_TX_XP_TIMER_WIDTH 5
+#define	FRF_AZ_TX_PREF_SPACER_LBN 44
+#define	FRF_AZ_TX_PREF_SPACER_WIDTH 8
+#define	FRF_AZ_TX_PREF_WD_TMR_LBN 22
+#define	FRF_AZ_TX_PREF_WD_TMR_WIDTH 22
+#define	FRF_AZ_TX_ONLY1TAG_LBN 21
+#define	FRF_AZ_TX_ONLY1TAG_WIDTH 1
+#define	FRF_AZ_TX_PREF_THRESHOLD_LBN 19
+#define	FRF_AZ_TX_PREF_THRESHOLD_WIDTH 2
+#define	FRF_AZ_TX_ONE_PKT_PER_Q_LBN 18
+#define	FRF_AZ_TX_ONE_PKT_PER_Q_WIDTH 1
+#define	FRF_AZ_TX_DIS_NON_IP_EV_LBN 17
+#define	FRF_AZ_TX_DIS_NON_IP_EV_WIDTH 1
+#define	FRF_AA_TX_DMA_FF_THR_LBN 16
+#define	FRF_AA_TX_DMA_FF_THR_WIDTH 1
+#define	FRF_AZ_TX_DMA_SPACER_LBN 8
+#define	FRF_AZ_TX_DMA_SPACER_WIDTH 8
+#define	FRF_AA_TX_TCP_DIS_LBN 7
+#define	FRF_AA_TX_TCP_DIS_WIDTH 1
+#define	FRF_BZ_TX_FLUSH_MIN_LEN_EN_LBN 7
+#define	FRF_BZ_TX_FLUSH_MIN_LEN_EN_WIDTH 1
+#define	FRF_AA_TX_IP_DIS_LBN 6
+#define	FRF_AA_TX_IP_DIS_WIDTH 1
+#define	FRF_AZ_TX_MAX_CPL_LBN 2
+#define	FRF_AZ_TX_MAX_CPL_WIDTH 2
+#define	FFE_AZ_TX_MAX_CPL_16 3
+#define	FFE_AZ_TX_MAX_CPL_8 2
+#define	FFE_AZ_TX_MAX_CPL_4 1
+#define	FFE_AZ_TX_MAX_CPL_NOLIMIT 0
+#define	FRF_AZ_TX_MAX_PREF_LBN 0
+#define	FRF_AZ_TX_MAX_PREF_WIDTH 2
+#define	FFE_AZ_TX_MAX_PREF_32 3
+#define	FFE_AZ_TX_MAX_PREF_16 2
+#define	FFE_AZ_TX_MAX_PREF_8 1
+#define	FFE_AZ_TX_MAX_PREF_OFF 0
+
+/* TX_PACE_REG: Transmit pace control register */
+#define	FR_BZ_TX_PACE 0x00000a90
+#define	FRF_BZ_TX_PACE_SB_NOT_AF_LBN 19
+#define	FRF_BZ_TX_PACE_SB_NOT_AF_WIDTH 10
+#define	FRF_BZ_TX_PACE_SB_AF_LBN 9
+#define	FRF_BZ_TX_PACE_SB_AF_WIDTH 10
+#define	FRF_BZ_TX_PACE_FB_BASE_LBN 5
+#define	FRF_BZ_TX_PACE_FB_BASE_WIDTH 4
+#define	FRF_BZ_TX_PACE_BIN_TH_LBN 0
+#define	FRF_BZ_TX_PACE_BIN_TH_WIDTH 5
+
+/* TX_PACE_DROP_QID_REG: PACE Drop QID Counter */
+#define	FR_BZ_TX_PACE_DROP_QID 0x00000aa0
+#define	FRF_BZ_TX_PACE_QID_DRP_CNT_LBN 0
+#define	FRF_BZ_TX_PACE_QID_DRP_CNT_WIDTH 16
+
+/* TX_VLAN_REG: Transmit VLAN tag register */
+#define	FR_BB_TX_VLAN 0x00000ae0
+#define	FRF_BB_TX_VLAN_EN_LBN 127
+#define	FRF_BB_TX_VLAN_EN_WIDTH 1
+#define	FRF_BB_TX_VLAN7_PORT1_EN_LBN 125
+#define	FRF_BB_TX_VLAN7_PORT1_EN_WIDTH 1
+#define	FRF_BB_TX_VLAN7_PORT0_EN_LBN 124
+#define	FRF_BB_TX_VLAN7_PORT0_EN_WIDTH 1
+#define	FRF_BB_TX_VLAN7_LBN 112
+#define	FRF_BB_TX_VLAN7_WIDTH 12
+#define	FRF_BB_TX_VLAN6_PORT1_EN_LBN 109
+#define	FRF_BB_TX_VLAN6_PORT1_EN_WIDTH 1
+#define	FRF_BB_TX_VLAN6_PORT0_EN_LBN 108
+#define	FRF_BB_TX_VLAN6_PORT0_EN_WIDTH 1
+#define	FRF_BB_TX_VLAN6_LBN 96
+#define	FRF_BB_TX_VLAN6_WIDTH 12
+#define	FRF_BB_TX_VLAN5_PORT1_EN_LBN 93
+#define	FRF_BB_TX_VLAN5_PORT1_EN_WIDTH 1
+#define	FRF_BB_TX_VLAN5_PORT0_EN_LBN 92
+#define	FRF_BB_TX_VLAN5_PORT0_EN_WIDTH 1
+#define	FRF_BB_TX_VLAN5_LBN 80
+#define	FRF_BB_TX_VLAN5_WIDTH 12
+#define	FRF_BB_TX_VLAN4_PORT1_EN_LBN 77
+#define	FRF_BB_TX_VLAN4_PORT1_EN_WIDTH 1
+#define	FRF_BB_TX_VLAN4_PORT0_EN_LBN 76
+#define	FRF_BB_TX_VLAN4_PORT0_EN_WIDTH 1
+#define	FRF_BB_TX_VLAN4_LBN 64
+#define	FRF_BB_TX_VLAN4_WIDTH 12
+#define	FRF_BB_TX_VLAN3_PORT1_EN_LBN 61
+#define	FRF_BB_TX_VLAN3_PORT1_EN_WIDTH 1
+#define	FRF_BB_TX_VLAN3_PORT0_EN_LBN 60
+#define	FRF_BB_TX_VLAN3_PORT0_EN_WIDTH 1
+#define	FRF_BB_TX_VLAN3_LBN 48
+#define	FRF_BB_TX_VLAN3_WIDTH 12
+#define	FRF_BB_TX_VLAN2_PORT1_EN_LBN 45
+#define	FRF_BB_TX_VLAN2_PORT1_EN_WIDTH 1
+#define	FRF_BB_TX_VLAN2_PORT0_EN_LBN 44
+#define	FRF_BB_TX_VLAN2_PORT0_EN_WIDTH 1
+#define	FRF_BB_TX_VLAN2_LBN 32
+#define	FRF_BB_TX_VLAN2_WIDTH 12
+#define	FRF_BB_TX_VLAN1_PORT1_EN_LBN 29
+#define	FRF_BB_TX_VLAN1_PORT1_EN_WIDTH 1
+#define	FRF_BB_TX_VLAN1_PORT0_EN_LBN 28
+#define	FRF_BB_TX_VLAN1_PORT0_EN_WIDTH 1
+#define	FRF_BB_TX_VLAN1_LBN 16
+#define	FRF_BB_TX_VLAN1_WIDTH 12
+#define	FRF_BB_TX_VLAN0_PORT1_EN_LBN 13
+#define	FRF_BB_TX_VLAN0_PORT1_EN_WIDTH 1
+#define	FRF_BB_TX_VLAN0_PORT0_EN_LBN 12
+#define	FRF_BB_TX_VLAN0_PORT0_EN_WIDTH 1
+#define	FRF_BB_TX_VLAN0_LBN 0
+#define	FRF_BB_TX_VLAN0_WIDTH 12
+
+/* TX_IPFIL_PORTEN_REG: Transmit filter control register */
+#define	FR_BZ_TX_IPFIL_PORTEN 0x00000af0
+#define	FRF_BZ_TX_MADR0_FIL_EN_LBN 64
+#define	FRF_BZ_TX_MADR0_FIL_EN_WIDTH 1
+#define	FRF_BB_TX_IPFIL31_PORT_EN_LBN 62
+#define	FRF_BB_TX_IPFIL31_PORT_EN_WIDTH 1
+#define	FRF_BB_TX_IPFIL30_PORT_EN_LBN 60
+#define	FRF_BB_TX_IPFIL30_PORT_EN_WIDTH 1
+#define	FRF_BB_TX_IPFIL29_PORT_EN_LBN 58
+#define	FRF_BB_TX_IPFIL29_PORT_EN_WIDTH 1
+#define	FRF_BB_TX_IPFIL28_PORT_EN_LBN 56
+#define	FRF_BB_TX_IPFIL28_PORT_EN_WIDTH 1
+#define	FRF_BB_TX_IPFIL27_PORT_EN_LBN 54
+#define	FRF_BB_TX_IPFIL27_PORT_EN_WIDTH 1
+#define	FRF_BB_TX_IPFIL26_PORT_EN_LBN 52
+#define	FRF_BB_TX_IPFIL26_PORT_EN_WIDTH 1
+#define	FRF_BB_TX_IPFIL25_PORT_EN_LBN 50
+#define	FRF_BB_TX_IPFIL25_PORT_EN_WIDTH 1
+#define	FRF_BB_TX_IPFIL24_PORT_EN_LBN 48
+#define	FRF_BB_TX_IPFIL24_PORT_EN_WIDTH 1
+#define	FRF_BB_TX_IPFIL23_PORT_EN_LBN 46
+#define	FRF_BB_TX_IPFIL23_PORT_EN_WIDTH 1
+#define	FRF_BB_TX_IPFIL22_PORT_EN_LBN 44
+#define	FRF_BB_TX_IPFIL22_PORT_EN_WIDTH 1
+#define	FRF_BB_TX_IPFIL21_PORT_EN_LBN 42
+#define	FRF_BB_TX_IPFIL21_PORT_EN_WIDTH 1
+#define	FRF_BB_TX_IPFIL20_PORT_EN_LBN 40
+#define	FRF_BB_TX_IPFIL20_PORT_EN_WIDTH 1
+#define	FRF_BB_TX_IPFIL19_PORT_EN_LBN 38
+#define	FRF_BB_TX_IPFIL19_PORT_EN_WIDTH 1
+#define	FRF_BB_TX_IPFIL18_PORT_EN_LBN 36
+#define	FRF_BB_TX_IPFIL18_PORT_EN_WIDTH 1
+#define	FRF_BB_TX_IPFIL17_PORT_EN_LBN 34
+#define	FRF_BB_TX_IPFIL17_PORT_EN_WIDTH 1
+#define	FRF_BB_TX_IPFIL16_PORT_EN_LBN 32
+#define	FRF_BB_TX_IPFIL16_PORT_EN_WIDTH 1
+#define	FRF_BB_TX_IPFIL15_PORT_EN_LBN 30
+#define	FRF_BB_TX_IPFIL15_PORT_EN_WIDTH 1
+#define	FRF_BB_TX_IPFIL14_PORT_EN_LBN 28
+#define	FRF_BB_TX_IPFIL14_PORT_EN_WIDTH 1
+#define	FRF_BB_TX_IPFIL13_PORT_EN_LBN 26
+#define	FRF_BB_TX_IPFIL13_PORT_EN_WIDTH 1
+#define	FRF_BB_TX_IPFIL12_PORT_EN_LBN 24
+#define	FRF_BB_TX_IPFIL12_PORT_EN_WIDTH 1
+#define	FRF_BB_TX_IPFIL11_PORT_EN_LBN 22
+#define	FRF_BB_TX_IPFIL11_PORT_EN_WIDTH 1
+#define	FRF_BB_TX_IPFIL10_PORT_EN_LBN 20
+#define	FRF_BB_TX_IPFIL10_PORT_EN_WIDTH 1
+#define	FRF_BB_TX_IPFIL9_PORT_EN_LBN 18
+#define	FRF_BB_TX_IPFIL9_PORT_EN_WIDTH 1
+#define	FRF_BB_TX_IPFIL8_PORT_EN_LBN 16
+#define	FRF_BB_TX_IPFIL8_PORT_EN_WIDTH 1
+#define	FRF_BB_TX_IPFIL7_PORT_EN_LBN 14
+#define	FRF_BB_TX_IPFIL7_PORT_EN_WIDTH 1
+#define	FRF_BB_TX_IPFIL6_PORT_EN_LBN 12
+#define	FRF_BB_TX_IPFIL6_PORT_EN_WIDTH 1
+#define	FRF_BB_TX_IPFIL5_PORT_EN_LBN 10
+#define	FRF_BB_TX_IPFIL5_PORT_EN_WIDTH 1
+#define	FRF_BB_TX_IPFIL4_PORT_EN_LBN 8
+#define	FRF_BB_TX_IPFIL4_PORT_EN_WIDTH 1
+#define	FRF_BB_TX_IPFIL3_PORT_EN_LBN 6
+#define	FRF_BB_TX_IPFIL3_PORT_EN_WIDTH 1
+#define	FRF_BB_TX_IPFIL2_PORT_EN_LBN 4
+#define	FRF_BB_TX_IPFIL2_PORT_EN_WIDTH 1
+#define	FRF_BB_TX_IPFIL1_PORT_EN_LBN 2
+#define	FRF_BB_TX_IPFIL1_PORT_EN_WIDTH 1
+#define	FRF_BB_TX_IPFIL0_PORT_EN_LBN 0
+#define	FRF_BB_TX_IPFIL0_PORT_EN_WIDTH 1
+
+/* TX_IPFIL_TBL: Transmit IP source address filter table */
+#define	FR_BB_TX_IPFIL_TBL 0x00000b00
+#define	FR_BB_TX_IPFIL_TBL_STEP 16
+#define	FR_BB_TX_IPFIL_TBL_ROWS 16
+#define	FRF_BB_TX_IPFIL_MASK_1_LBN 96
+#define	FRF_BB_TX_IPFIL_MASK_1_WIDTH 32
+#define	FRF_BB_TX_IP_SRC_ADR_1_LBN 64
+#define	FRF_BB_TX_IP_SRC_ADR_1_WIDTH 32
+#define	FRF_BB_TX_IPFIL_MASK_0_LBN 32
+#define	FRF_BB_TX_IPFIL_MASK_0_WIDTH 32
+#define	FRF_BB_TX_IP_SRC_ADR_0_LBN 0
+#define	FRF_BB_TX_IP_SRC_ADR_0_WIDTH 32
+
+/* MD_TXD_REG: PHY management transmit data register */
+#define	FR_AB_MD_TXD 0x00000c00
+#define	FRF_AB_MD_TXD_LBN 0
+#define	FRF_AB_MD_TXD_WIDTH 16
+
+/* MD_RXD_REG: PHY management receive data register */
+#define	FR_AB_MD_RXD 0x00000c10
+#define	FRF_AB_MD_RXD_LBN 0
+#define	FRF_AB_MD_RXD_WIDTH 16
+
+/* MD_CS_REG: PHY management configuration & status register */
+#define	FR_AB_MD_CS 0x00000c20
+#define	FRF_AB_MD_RD_EN_CMD_LBN 15
+#define	FRF_AB_MD_RD_EN_CMD_WIDTH 1
+#define	FRF_AB_MD_WR_EN_CMD_LBN 14
+#define	FRF_AB_MD_WR_EN_CMD_WIDTH 1
+#define	FRF_AB_MD_ADDR_CMD_LBN 13
+#define	FRF_AB_MD_ADDR_CMD_WIDTH 1
+#define	FRF_AB_MD_PT_LBN 7
+#define	FRF_AB_MD_PT_WIDTH 3
+#define	FRF_AB_MD_PL_LBN 6
+#define	FRF_AB_MD_PL_WIDTH 1
+#define	FRF_AB_MD_INT_CLR_LBN 5
+#define	FRF_AB_MD_INT_CLR_WIDTH 1
+#define	FRF_AB_MD_GC_LBN 4
+#define	FRF_AB_MD_GC_WIDTH 1
+#define	FRF_AB_MD_PRSP_LBN 3
+#define	FRF_AB_MD_PRSP_WIDTH 1
+#define	FRF_AB_MD_RIC_LBN 2
+#define	FRF_AB_MD_RIC_WIDTH 1
+#define	FRF_AB_MD_RDC_LBN 1
+#define	FRF_AB_MD_RDC_WIDTH 1
+#define	FRF_AB_MD_WRC_LBN 0
+#define	FRF_AB_MD_WRC_WIDTH 1
+
+/* MD_PHY_ADR_REG: PHY management PHY address register */
+#define	FR_AB_MD_PHY_ADR 0x00000c30
+#define	FRF_AB_MD_PHY_ADR_LBN 0
+#define	FRF_AB_MD_PHY_ADR_WIDTH 16
+
+/* MD_ID_REG: PHY management ID register */
+#define	FR_AB_MD_ID 0x00000c40
+#define	FRF_AB_MD_PRT_ADR_LBN 11
+#define	FRF_AB_MD_PRT_ADR_WIDTH 5
+#define	FRF_AB_MD_DEV_ADR_LBN 6
+#define	FRF_AB_MD_DEV_ADR_WIDTH 5
+
+/* MD_STAT_REG: PHY management status & mask register */
+#define	FR_AB_MD_STAT 0x00000c50
+#define	FRF_AB_MD_PINT_LBN 4
+#define	FRF_AB_MD_PINT_WIDTH 1
+#define	FRF_AB_MD_DONE_LBN 3
+#define	FRF_AB_MD_DONE_WIDTH 1
+#define	FRF_AB_MD_BSERR_LBN 2
+#define	FRF_AB_MD_BSERR_WIDTH 1
+#define	FRF_AB_MD_LNFL_LBN 1
+#define	FRF_AB_MD_LNFL_WIDTH 1
+#define	FRF_AB_MD_BSY_LBN 0
+#define	FRF_AB_MD_BSY_WIDTH 1
+
+/* MAC_STAT_DMA_REG: Port MAC statistical counter DMA register */
+#define	FR_AB_MAC_STAT_DMA 0x00000c60
+#define	FRF_AB_MAC_STAT_DMA_CMD_LBN 48
+#define	FRF_AB_MAC_STAT_DMA_CMD_WIDTH 1
+#define	FRF_AB_MAC_STAT_DMA_ADR_LBN 0
+#define	FRF_AB_MAC_STAT_DMA_ADR_WIDTH 48
+
+/* MAC_CTRL_REG: Port MAC control register */
+#define	FR_AB_MAC_CTRL 0x00000c80
+#define	FRF_AB_MAC_XOFF_VAL_LBN 16
+#define	FRF_AB_MAC_XOFF_VAL_WIDTH 16
+#define	FRF_BB_TXFIFO_DRAIN_EN_LBN 7
+#define	FRF_BB_TXFIFO_DRAIN_EN_WIDTH 1
+#define	FRF_AB_MAC_XG_DISTXCRC_LBN 5
+#define	FRF_AB_MAC_XG_DISTXCRC_WIDTH 1
+#define	FRF_AB_MAC_BCAD_ACPT_LBN 4
+#define	FRF_AB_MAC_BCAD_ACPT_WIDTH 1
+#define	FRF_AB_MAC_UC_PROM_LBN 3
+#define	FRF_AB_MAC_UC_PROM_WIDTH 1
+#define	FRF_AB_MAC_LINK_STATUS_LBN 2
+#define	FRF_AB_MAC_LINK_STATUS_WIDTH 1
+#define	FRF_AB_MAC_SPEED_LBN 0
+#define	FRF_AB_MAC_SPEED_WIDTH 2
+#define	FFE_AB_MAC_SPEED_10G 3
+#define	FFE_AB_MAC_SPEED_1G 2
+#define	FFE_AB_MAC_SPEED_100M 1
+#define	FFE_AB_MAC_SPEED_10M 0
+
+/* GEN_MODE_REG: General Purpose mode register (external interrupt mask) */
+#define	FR_BB_GEN_MODE 0x00000c90
+#define	FRF_BB_XFP_PHY_INT_POL_SEL_LBN 3
+#define	FRF_BB_XFP_PHY_INT_POL_SEL_WIDTH 1
+#define	FRF_BB_XG_PHY_INT_POL_SEL_LBN 2
+#define	FRF_BB_XG_PHY_INT_POL_SEL_WIDTH 1
+#define	FRF_BB_XFP_PHY_INT_MASK_LBN 1
+#define	FRF_BB_XFP_PHY_INT_MASK_WIDTH 1
+#define	FRF_BB_XG_PHY_INT_MASK_LBN 0
+#define	FRF_BB_XG_PHY_INT_MASK_WIDTH 1
+
+/* MAC_MC_HASH_REG0: Multicast address hash table */
+#define	FR_AB_MAC_MC_HASH_REG0 0x00000ca0
+#define	FRF_AB_MAC_MCAST_HASH0_LBN 0
+#define	FRF_AB_MAC_MCAST_HASH0_WIDTH 128
+
+/* MAC_MC_HASH_REG1: Multicast address hash table */
+#define	FR_AB_MAC_MC_HASH_REG1 0x00000cb0
+#define	FRF_AB_MAC_MCAST_HASH1_LBN 0
+#define	FRF_AB_MAC_MCAST_HASH1_WIDTH 128
+
+/* GM_CFG1_REG: GMAC configuration register 1 */
+#define	FR_AB_GM_CFG1 0x00000e00
+#define	FRF_AB_GM_SW_RST_LBN 31
+#define	FRF_AB_GM_SW_RST_WIDTH 1
+#define	FRF_AB_GM_SIM_RST_LBN 30
+#define	FRF_AB_GM_SIM_RST_WIDTH 1
+#define	FRF_AB_GM_RST_RX_MAC_CTL_LBN 19
+#define	FRF_AB_GM_RST_RX_MAC_CTL_WIDTH 1
+#define	FRF_AB_GM_RST_TX_MAC_CTL_LBN 18
+#define	FRF_AB_GM_RST_TX_MAC_CTL_WIDTH 1
+#define	FRF_AB_GM_RST_RX_FUNC_LBN 17
+#define	FRF_AB_GM_RST_RX_FUNC_WIDTH 1
+#define	FRF_AB_GM_RST_TX_FUNC_LBN 16
+#define	FRF_AB_GM_RST_TX_FUNC_WIDTH 1
+#define	FRF_AB_GM_LOOP_LBN 8
+#define	FRF_AB_GM_LOOP_WIDTH 1
+#define	FRF_AB_GM_RX_FC_EN_LBN 5
+#define	FRF_AB_GM_RX_FC_EN_WIDTH 1
+#define	FRF_AB_GM_TX_FC_EN_LBN 4
+#define	FRF_AB_GM_TX_FC_EN_WIDTH 1
+#define	FRF_AB_GM_SYNC_RXEN_LBN 3
+#define	FRF_AB_GM_SYNC_RXEN_WIDTH 1
+#define	FRF_AB_GM_RX_EN_LBN 2
+#define	FRF_AB_GM_RX_EN_WIDTH 1
+#define	FRF_AB_GM_SYNC_TXEN_LBN 1
+#define	FRF_AB_GM_SYNC_TXEN_WIDTH 1
+#define	FRF_AB_GM_TX_EN_LBN 0
+#define	FRF_AB_GM_TX_EN_WIDTH 1
+
+/* GM_CFG2_REG: GMAC configuration register 2 */
+#define	FR_AB_GM_CFG2 0x00000e10
+#define	FRF_AB_GM_PAMBL_LEN_LBN 12
+#define	FRF_AB_GM_PAMBL_LEN_WIDTH 4
+#define	FRF_AB_GM_IF_MODE_LBN 8
+#define	FRF_AB_GM_IF_MODE_WIDTH 2
+#define	FFE_AB_IF_MODE_BYTE_MODE 2
+#define	FFE_AB_IF_MODE_NIBBLE_MODE 1
+#define	FRF_AB_GM_HUGE_FRM_EN_LBN 5
+#define	FRF_AB_GM_HUGE_FRM_EN_WIDTH 1
+#define	FRF_AB_GM_LEN_CHK_LBN 4
+#define	FRF_AB_GM_LEN_CHK_WIDTH 1
+#define	FRF_AB_GM_PAD_CRC_EN_LBN 2
+#define	FRF_AB_GM_PAD_CRC_EN_WIDTH 1
+#define	FRF_AB_GM_CRC_EN_LBN 1
+#define	FRF_AB_GM_CRC_EN_WIDTH 1
+#define	FRF_AB_GM_FD_LBN 0
+#define	FRF_AB_GM_FD_WIDTH 1
+
+/* GM_IPG_REG: GMAC IPG register */
+#define	FR_AB_GM_IPG 0x00000e20
+#define	FRF_AB_GM_NONB2B_IPG1_LBN 24
+#define	FRF_AB_GM_NONB2B_IPG1_WIDTH 7
+#define	FRF_AB_GM_NONB2B_IPG2_LBN 16
+#define	FRF_AB_GM_NONB2B_IPG2_WIDTH 7
+#define	FRF_AB_GM_MIN_IPG_ENF_LBN 8
+#define	FRF_AB_GM_MIN_IPG_ENF_WIDTH 8
+#define	FRF_AB_GM_B2B_IPG_LBN 0
+#define	FRF_AB_GM_B2B_IPG_WIDTH 7
+
+/* GM_HD_REG: GMAC half duplex register */
+#define	FR_AB_GM_HD 0x00000e30
+#define	FRF_AB_GM_ALT_BOFF_VAL_LBN 20
+#define	FRF_AB_GM_ALT_BOFF_VAL_WIDTH 4
+#define	FRF_AB_GM_ALT_BOFF_EN_LBN 19
+#define	FRF_AB_GM_ALT_BOFF_EN_WIDTH 1
+#define	FRF_AB_GM_BP_NO_BOFF_LBN 18
+#define	FRF_AB_GM_BP_NO_BOFF_WIDTH 1
+#define	FRF_AB_GM_DIS_BOFF_LBN 17
+#define	FRF_AB_GM_DIS_BOFF_WIDTH 1
+#define	FRF_AB_GM_EXDEF_TX_EN_LBN 16
+#define	FRF_AB_GM_EXDEF_TX_EN_WIDTH 1
+#define	FRF_AB_GM_RTRY_LIMIT_LBN 12
+#define	FRF_AB_GM_RTRY_LIMIT_WIDTH 4
+#define	FRF_AB_GM_COL_WIN_LBN 0
+#define	FRF_AB_GM_COL_WIN_WIDTH 10
+
+/* GM_MAX_FLEN_REG: GMAC maximum frame length register */
+#define	FR_AB_GM_MAX_FLEN 0x00000e40
+#define	FRF_AB_GM_MAX_FLEN_LBN 0
+#define	FRF_AB_GM_MAX_FLEN_WIDTH 16
+
+/* GM_TEST_REG: GMAC test register */
+#define	FR_AB_GM_TEST 0x00000e70
+#define	FRF_AB_GM_MAX_BOFF_LBN 3
+#define	FRF_AB_GM_MAX_BOFF_WIDTH 1
+#define	FRF_AB_GM_REG_TX_FLOW_EN_LBN 2
+#define	FRF_AB_GM_REG_TX_FLOW_EN_WIDTH 1
+#define	FRF_AB_GM_TEST_PAUSE_LBN 1
+#define	FRF_AB_GM_TEST_PAUSE_WIDTH 1
+#define	FRF_AB_GM_SHORT_SLOT_LBN 0
+#define	FRF_AB_GM_SHORT_SLOT_WIDTH 1
+
+/* GM_ADR1_REG: GMAC station address register 1 */
+#define	FR_AB_GM_ADR1 0x00000f00
+#define	FRF_AB_GM_ADR_B0_LBN 24
+#define	FRF_AB_GM_ADR_B0_WIDTH 8
+#define	FRF_AB_GM_ADR_B1_LBN 16
+#define	FRF_AB_GM_ADR_B1_WIDTH 8
+#define	FRF_AB_GM_ADR_B2_LBN 8
+#define	FRF_AB_GM_ADR_B2_WIDTH 8
+#define	FRF_AB_GM_ADR_B3_LBN 0
+#define	FRF_AB_GM_ADR_B3_WIDTH 8
+
+/* GM_ADR2_REG: GMAC station address register 2 */
+#define	FR_AB_GM_ADR2 0x00000f10
+#define	FRF_AB_GM_ADR_B4_LBN 24
+#define	FRF_AB_GM_ADR_B4_WIDTH 8
+#define	FRF_AB_GM_ADR_B5_LBN 16
+#define	FRF_AB_GM_ADR_B5_WIDTH 8
+
+/* GMF_CFG0_REG: GMAC FIFO configuration register 0 */
+#define	FR_AB_GMF_CFG0 0x00000f20
+#define	FRF_AB_GMF_FTFENRPLY_LBN 20
+#define	FRF_AB_GMF_FTFENRPLY_WIDTH 1
+#define	FRF_AB_GMF_STFENRPLY_LBN 19
+#define	FRF_AB_GMF_STFENRPLY_WIDTH 1
+#define	FRF_AB_GMF_FRFENRPLY_LBN 18
+#define	FRF_AB_GMF_FRFENRPLY_WIDTH 1
+#define	FRF_AB_GMF_SRFENRPLY_LBN 17
+#define	FRF_AB_GMF_SRFENRPLY_WIDTH 1
+#define	FRF_AB_GMF_WTMENRPLY_LBN 16
+#define	FRF_AB_GMF_WTMENRPLY_WIDTH 1
+#define	FRF_AB_GMF_FTFENREQ_LBN 12
+#define	FRF_AB_GMF_FTFENREQ_WIDTH 1
+#define	FRF_AB_GMF_STFENREQ_LBN 11
+#define	FRF_AB_GMF_STFENREQ_WIDTH 1
+#define	FRF_AB_GMF_FRFENREQ_LBN 10
+#define	FRF_AB_GMF_FRFENREQ_WIDTH 1
+#define	FRF_AB_GMF_SRFENREQ_LBN 9
+#define	FRF_AB_GMF_SRFENREQ_WIDTH 1
+#define	FRF_AB_GMF_WTMENREQ_LBN 8
+#define	FRF_AB_GMF_WTMENREQ_WIDTH 1
+#define	FRF_AB_GMF_HSTRSTFT_LBN 4
+#define	FRF_AB_GMF_HSTRSTFT_WIDTH 1
+#define	FRF_AB_GMF_HSTRSTST_LBN 3
+#define	FRF_AB_GMF_HSTRSTST_WIDTH 1
+#define	FRF_AB_GMF_HSTRSTFR_LBN 2
+#define	FRF_AB_GMF_HSTRSTFR_WIDTH 1
+#define	FRF_AB_GMF_HSTRSTSR_LBN 1
+#define	FRF_AB_GMF_HSTRSTSR_WIDTH 1
+#define	FRF_AB_GMF_HSTRSTWT_LBN 0
+#define	FRF_AB_GMF_HSTRSTWT_WIDTH 1
+
+/* GMF_CFG1_REG: GMAC FIFO configuration register 1 */
+#define	FR_AB_GMF_CFG1 0x00000f30
+#define	FRF_AB_GMF_CFGFRTH_LBN 16
+#define	FRF_AB_GMF_CFGFRTH_WIDTH 5
+#define	FRF_AB_GMF_CFGXOFFRTX_LBN 0
+#define	FRF_AB_GMF_CFGXOFFRTX_WIDTH 16
+
+/* GMF_CFG2_REG: GMAC FIFO configuration register 2 */
+#define	FR_AB_GMF_CFG2 0x00000f40
+#define	FRF_AB_GMF_CFGHWM_LBN 16
+#define	FRF_AB_GMF_CFGHWM_WIDTH 6
+#define	FRF_AB_GMF_CFGLWM_LBN 0
+#define	FRF_AB_GMF_CFGLWM_WIDTH 6
+
+/* GMF_CFG3_REG: GMAC FIFO configuration register 3 */
+#define	FR_AB_GMF_CFG3 0x00000f50
+#define	FRF_AB_GMF_CFGHWMFT_LBN 16
+#define	FRF_AB_GMF_CFGHWMFT_WIDTH 6
+#define	FRF_AB_GMF_CFGFTTH_LBN 0
+#define	FRF_AB_GMF_CFGFTTH_WIDTH 6
+
+/* GMF_CFG4_REG: GMAC FIFO configuration register 4 */
+#define	FR_AB_GMF_CFG4 0x00000f60
+#define	FRF_AB_GMF_HSTFLTRFRM_LBN 0
+#define	FRF_AB_GMF_HSTFLTRFRM_WIDTH 18
+
+/* GMF_CFG5_REG: GMAC FIFO configuration register 5 */
+#define	FR_AB_GMF_CFG5 0x00000f70
+#define	FRF_AB_GMF_CFGHDPLX_LBN 22
+#define	FRF_AB_GMF_CFGHDPLX_WIDTH 1
+#define	FRF_AB_GMF_SRFULL_LBN 21
+#define	FRF_AB_GMF_SRFULL_WIDTH 1
+#define	FRF_AB_GMF_HSTSRFULLCLR_LBN 20
+#define	FRF_AB_GMF_HSTSRFULLCLR_WIDTH 1
+#define	FRF_AB_GMF_CFGBYTMODE_LBN 19
+#define	FRF_AB_GMF_CFGBYTMODE_WIDTH 1
+#define	FRF_AB_GMF_HSTDRPLT64_LBN 18
+#define	FRF_AB_GMF_HSTDRPLT64_WIDTH 1
+#define	FRF_AB_GMF_HSTFLTRFRMDC_LBN 0
+#define	FRF_AB_GMF_HSTFLTRFRMDC_WIDTH 18
+
+/* TX_SRC_MAC_TBL: Transmit IP source address filter table */
+#define	FR_BB_TX_SRC_MAC_TBL 0x00001000
+#define	FR_BB_TX_SRC_MAC_TBL_STEP 16
+#define	FR_BB_TX_SRC_MAC_TBL_ROWS 16
+#define	FRF_BB_TX_SRC_MAC_ADR_1_LBN 64
+#define	FRF_BB_TX_SRC_MAC_ADR_1_WIDTH 48
+#define	FRF_BB_TX_SRC_MAC_ADR_0_LBN 0
+#define	FRF_BB_TX_SRC_MAC_ADR_0_WIDTH 48
+
+/* TX_SRC_MAC_CTL_REG: Transmit MAC source address filter control */
+#define	FR_BB_TX_SRC_MAC_CTL 0x00001100
+#define	FRF_BB_TX_SRC_DROP_CTR_LBN 16
+#define	FRF_BB_TX_SRC_DROP_CTR_WIDTH 16
+#define	FRF_BB_TX_SRC_FLTR_EN_LBN 15
+#define	FRF_BB_TX_SRC_FLTR_EN_WIDTH 1
+#define	FRF_BB_TX_DROP_CTR_CLR_LBN 12
+#define	FRF_BB_TX_DROP_CTR_CLR_WIDTH 1
+#define	FRF_BB_TX_MAC_QID_SEL_LBN 0
+#define	FRF_BB_TX_MAC_QID_SEL_WIDTH 3
+
+/* XM_ADR_LO_REG: XGMAC address register low */
+#define	FR_AB_XM_ADR_LO 0x00001200
+#define	FRF_AB_XM_ADR_LO_LBN 0
+#define	FRF_AB_XM_ADR_LO_WIDTH 32
+
+/* XM_ADR_HI_REG: XGMAC address register high */
+#define	FR_AB_XM_ADR_HI 0x00001210
+#define	FRF_AB_XM_ADR_HI_LBN 0
+#define	FRF_AB_XM_ADR_HI_WIDTH 16
+
+/* XM_GLB_CFG_REG: XGMAC global configuration */
+#define	FR_AB_XM_GLB_CFG 0x00001220
+#define	FRF_AB_XM_RMTFLT_GEN_LBN 17
+#define	FRF_AB_XM_RMTFLT_GEN_WIDTH 1
+#define	FRF_AB_XM_DEBUG_MODE_LBN 16
+#define	FRF_AB_XM_DEBUG_MODE_WIDTH 1
+#define	FRF_AB_XM_RX_STAT_EN_LBN 11
+#define	FRF_AB_XM_RX_STAT_EN_WIDTH 1
+#define	FRF_AB_XM_TX_STAT_EN_LBN 10
+#define	FRF_AB_XM_TX_STAT_EN_WIDTH 1
+#define	FRF_AB_XM_RX_JUMBO_MODE_LBN 6
+#define	FRF_AB_XM_RX_JUMBO_MODE_WIDTH 1
+#define	FRF_AB_XM_WAN_MODE_LBN 5
+#define	FRF_AB_XM_WAN_MODE_WIDTH 1
+#define	FRF_AB_XM_INTCLR_MODE_LBN 3
+#define	FRF_AB_XM_INTCLR_MODE_WIDTH 1
+#define	FRF_AB_XM_CORE_RST_LBN 0
+#define	FRF_AB_XM_CORE_RST_WIDTH 1
+
+/* XM_TX_CFG_REG: XGMAC transmit configuration */
+#define	FR_AB_XM_TX_CFG 0x00001230
+#define	FRF_AB_XM_TX_PROG_LBN 24
+#define	FRF_AB_XM_TX_PROG_WIDTH 1
+#define	FRF_AB_XM_IPG_LBN 16
+#define	FRF_AB_XM_IPG_WIDTH 4
+#define	FRF_AB_XM_FCNTL_LBN 10
+#define	FRF_AB_XM_FCNTL_WIDTH 1
+#define	FRF_AB_XM_TXCRC_LBN 8
+#define	FRF_AB_XM_TXCRC_WIDTH 1
+#define	FRF_AB_XM_EDRC_LBN 6
+#define	FRF_AB_XM_EDRC_WIDTH 1
+#define	FRF_AB_XM_AUTO_PAD_LBN 5
+#define	FRF_AB_XM_AUTO_PAD_WIDTH 1
+#define	FRF_AB_XM_TX_PRMBL_LBN 2
+#define	FRF_AB_XM_TX_PRMBL_WIDTH 1
+#define	FRF_AB_XM_TXEN_LBN 1
+#define	FRF_AB_XM_TXEN_WIDTH 1
+#define	FRF_AB_XM_TX_RST_LBN 0
+#define	FRF_AB_XM_TX_RST_WIDTH 1
+
+/* XM_RX_CFG_REG: XGMAC receive configuration */
+#define	FR_AB_XM_RX_CFG 0x00001240
+#define	FRF_AB_XM_PASS_LENERR_LBN 26
+#define	FRF_AB_XM_PASS_LENERR_WIDTH 1
+#define	FRF_AB_XM_PASS_CRC_ERR_LBN 25
+#define	FRF_AB_XM_PASS_CRC_ERR_WIDTH 1
+#define	FRF_AB_XM_PASS_PRMBLE_ERR_LBN 24
+#define	FRF_AB_XM_PASS_PRMBLE_ERR_WIDTH 1
+#define	FRF_AB_XM_REJ_BCAST_LBN 20
+#define	FRF_AB_XM_REJ_BCAST_WIDTH 1
+#define	FRF_AB_XM_ACPT_ALL_MCAST_LBN 11
+#define	FRF_AB_XM_ACPT_ALL_MCAST_WIDTH 1
+#define	FRF_AB_XM_ACPT_ALL_UCAST_LBN 9
+#define	FRF_AB_XM_ACPT_ALL_UCAST_WIDTH 1
+#define	FRF_AB_XM_AUTO_DEPAD_LBN 8
+#define	FRF_AB_XM_AUTO_DEPAD_WIDTH 1
+#define	FRF_AB_XM_RXCRC_LBN 3
+#define	FRF_AB_XM_RXCRC_WIDTH 1
+#define	FRF_AB_XM_RX_PRMBL_LBN 2
+#define	FRF_AB_XM_RX_PRMBL_WIDTH 1
+#define	FRF_AB_XM_RXEN_LBN 1
+#define	FRF_AB_XM_RXEN_WIDTH 1
+#define	FRF_AB_XM_RX_RST_LBN 0
+#define	FRF_AB_XM_RX_RST_WIDTH 1
+
+/* XM_MGT_INT_MASK: documentation to be written for sum_XM_MGT_INT_MASK */
+#define	FR_AB_XM_MGT_INT_MASK 0x00001250
+#define	FRF_AB_XM_MSK_STA_INTR_LBN 16
+#define	FRF_AB_XM_MSK_STA_INTR_WIDTH 1
+#define	FRF_AB_XM_MSK_STAT_CNTR_HF_LBN 9
+#define	FRF_AB_XM_MSK_STAT_CNTR_HF_WIDTH 1
+#define	FRF_AB_XM_MSK_STAT_CNTR_OF_LBN 8
+#define	FRF_AB_XM_MSK_STAT_CNTR_OF_WIDTH 1
+#define	FRF_AB_XM_MSK_PRMBLE_ERR_LBN 2
+#define	FRF_AB_XM_MSK_PRMBLE_ERR_WIDTH 1
+#define	FRF_AB_XM_MSK_RMTFLT_LBN 1
+#define	FRF_AB_XM_MSK_RMTFLT_WIDTH 1
+#define	FRF_AB_XM_MSK_LCLFLT_LBN 0
+#define	FRF_AB_XM_MSK_LCLFLT_WIDTH 1
+
+/* XM_FC_REG: XGMAC flow control register */
+#define	FR_AB_XM_FC 0x00001270
+#define	FRF_AB_XM_PAUSE_TIME_LBN 16
+#define	FRF_AB_XM_PAUSE_TIME_WIDTH 16
+#define	FRF_AB_XM_RX_MAC_STAT_LBN 11
+#define	FRF_AB_XM_RX_MAC_STAT_WIDTH 1
+#define	FRF_AB_XM_TX_MAC_STAT_LBN 10
+#define	FRF_AB_XM_TX_MAC_STAT_WIDTH 1
+#define	FRF_AB_XM_MCNTL_PASS_LBN 8
+#define	FRF_AB_XM_MCNTL_PASS_WIDTH 2
+#define	FRF_AB_XM_REJ_CNTL_UCAST_LBN 6
+#define	FRF_AB_XM_REJ_CNTL_UCAST_WIDTH 1
+#define	FRF_AB_XM_REJ_CNTL_MCAST_LBN 5
+#define	FRF_AB_XM_REJ_CNTL_MCAST_WIDTH 1
+#define	FRF_AB_XM_ZPAUSE_LBN 2
+#define	FRF_AB_XM_ZPAUSE_WIDTH 1
+#define	FRF_AB_XM_XMIT_PAUSE_LBN 1
+#define	FRF_AB_XM_XMIT_PAUSE_WIDTH 1
+#define	FRF_AB_XM_DIS_FCNTL_LBN 0
+#define	FRF_AB_XM_DIS_FCNTL_WIDTH 1
+
+/* XM_PAUSE_TIME_REG: XGMAC pause time register */
+#define	FR_AB_XM_PAUSE_TIME 0x00001290
+#define	FRF_AB_XM_TX_PAUSE_CNT_LBN 16
+#define	FRF_AB_XM_TX_PAUSE_CNT_WIDTH 16
+#define	FRF_AB_XM_RX_PAUSE_CNT_LBN 0
+#define	FRF_AB_XM_RX_PAUSE_CNT_WIDTH 16
+
+/* XM_TX_PARAM_REG: XGMAC transmit parameter register */
+#define	FR_AB_XM_TX_PARAM 0x000012d0
+#define	FRF_AB_XM_TX_JUMBO_MODE_LBN 31
+#define	FRF_AB_XM_TX_JUMBO_MODE_WIDTH 1
+#define	FRF_AB_XM_MAX_TX_FRM_SIZE_HI_LBN 19
+#define	FRF_AB_XM_MAX_TX_FRM_SIZE_HI_WIDTH 11
+#define	FRF_AB_XM_MAX_TX_FRM_SIZE_LO_LBN 16
+#define	FRF_AB_XM_MAX_TX_FRM_SIZE_LO_WIDTH 3
+#define	FRF_AB_XM_PAD_CHAR_LBN 0
+#define	FRF_AB_XM_PAD_CHAR_WIDTH 8
+
+/* XM_RX_PARAM_REG: XGMAC receive parameter register */
+#define	FR_AB_XM_RX_PARAM 0x000012e0
+#define	FRF_AB_XM_MAX_RX_FRM_SIZE_HI_LBN 3
+#define	FRF_AB_XM_MAX_RX_FRM_SIZE_HI_WIDTH 11
+#define	FRF_AB_XM_MAX_RX_FRM_SIZE_LO_LBN 0
+#define	FRF_AB_XM_MAX_RX_FRM_SIZE_LO_WIDTH 3
+
+/* XM_MGT_INT_MSK_REG: XGMAC management interrupt mask register */
+#define	FR_AB_XM_MGT_INT_MSK 0x000012f0
+#define	FRF_AB_XM_STAT_CNTR_OF_LBN 9
+#define	FRF_AB_XM_STAT_CNTR_OF_WIDTH 1
+#define	FRF_AB_XM_STAT_CNTR_HF_LBN 8
+#define	FRF_AB_XM_STAT_CNTR_HF_WIDTH 1
+#define	FRF_AB_XM_PRMBLE_ERR_LBN 2
+#define	FRF_AB_XM_PRMBLE_ERR_WIDTH 1
+#define	FRF_AB_XM_RMTFLT_LBN 1
+#define	FRF_AB_XM_RMTFLT_WIDTH 1
+#define	FRF_AB_XM_LCLFLT_LBN 0
+#define	FRF_AB_XM_LCLFLT_WIDTH 1
+
+/* XX_PWR_RST_REG: XGXS/XAUI powerdown/reset register */
+#define	FR_AB_XX_PWR_RST 0x00001300
+#define	FRF_AB_XX_PWRDND_SIG_LBN 31
+#define	FRF_AB_XX_PWRDND_SIG_WIDTH 1
+#define	FRF_AB_XX_PWRDNC_SIG_LBN 30
+#define	FRF_AB_XX_PWRDNC_SIG_WIDTH 1
+#define	FRF_AB_XX_PWRDNB_SIG_LBN 29
+#define	FRF_AB_XX_PWRDNB_SIG_WIDTH 1
+#define	FRF_AB_XX_PWRDNA_SIG_LBN 28
+#define	FRF_AB_XX_PWRDNA_SIG_WIDTH 1
+#define	FRF_AB_XX_SIM_MODE_LBN 27
+#define	FRF_AB_XX_SIM_MODE_WIDTH 1
+#define	FRF_AB_XX_RSTPLLCD_SIG_LBN 25
+#define	FRF_AB_XX_RSTPLLCD_SIG_WIDTH 1
+#define	FRF_AB_XX_RSTPLLAB_SIG_LBN 24
+#define	FRF_AB_XX_RSTPLLAB_SIG_WIDTH 1
+#define	FRF_AB_XX_RESETD_SIG_LBN 23
+#define	FRF_AB_XX_RESETD_SIG_WIDTH 1
+#define	FRF_AB_XX_RESETC_SIG_LBN 22
+#define	FRF_AB_XX_RESETC_SIG_WIDTH 1
+#define	FRF_AB_XX_RESETB_SIG_LBN 21
+#define	FRF_AB_XX_RESETB_SIG_WIDTH 1
+#define	FRF_AB_XX_RESETA_SIG_LBN 20
+#define	FRF_AB_XX_RESETA_SIG_WIDTH 1
+#define	FRF_AB_XX_RSTXGXSRX_SIG_LBN 18
+#define	FRF_AB_XX_RSTXGXSRX_SIG_WIDTH 1
+#define	FRF_AB_XX_RSTXGXSTX_SIG_LBN 17
+#define	FRF_AB_XX_RSTXGXSTX_SIG_WIDTH 1
+#define	FRF_AB_XX_SD_RST_ACT_LBN 16
+#define	FRF_AB_XX_SD_RST_ACT_WIDTH 1
+#define	FRF_AB_XX_PWRDND_EN_LBN 15
+#define	FRF_AB_XX_PWRDND_EN_WIDTH 1
+#define	FRF_AB_XX_PWRDNC_EN_LBN 14
+#define	FRF_AB_XX_PWRDNC_EN_WIDTH 1
+#define	FRF_AB_XX_PWRDNB_EN_LBN 13
+#define	FRF_AB_XX_PWRDNB_EN_WIDTH 1
+#define	FRF_AB_XX_PWRDNA_EN_LBN 12
+#define	FRF_AB_XX_PWRDNA_EN_WIDTH 1
+#define	FRF_AB_XX_RSTPLLCD_EN_LBN 9
+#define	FRF_AB_XX_RSTPLLCD_EN_WIDTH 1
+#define	FRF_AB_XX_RSTPLLAB_EN_LBN 8
+#define	FRF_AB_XX_RSTPLLAB_EN_WIDTH 1
+#define	FRF_AB_XX_RESETD_EN_LBN 7
+#define	FRF_AB_XX_RESETD_EN_WIDTH 1
+#define	FRF_AB_XX_RESETC_EN_LBN 6
+#define	FRF_AB_XX_RESETC_EN_WIDTH 1
+#define	FRF_AB_XX_RESETB_EN_LBN 5
+#define	FRF_AB_XX_RESETB_EN_WIDTH 1
+#define	FRF_AB_XX_RESETA_EN_LBN 4
+#define	FRF_AB_XX_RESETA_EN_WIDTH 1
+#define	FRF_AB_XX_RSTXGXSRX_EN_LBN 2
+#define	FRF_AB_XX_RSTXGXSRX_EN_WIDTH 1
+#define	FRF_AB_XX_RSTXGXSTX_EN_LBN 1
+#define	FRF_AB_XX_RSTXGXSTX_EN_WIDTH 1
+#define	FRF_AB_XX_RST_XX_EN_LBN 0
+#define	FRF_AB_XX_RST_XX_EN_WIDTH 1
+
+/* XX_SD_CTL_REG: XGXS/XAUI powerdown/reset control register */
+#define	FR_AB_XX_SD_CTL 0x00001310
+#define	FRF_AB_XX_TERMADJ1_LBN 17
+#define	FRF_AB_XX_TERMADJ1_WIDTH 1
+#define	FRF_AB_XX_TERMADJ0_LBN 16
+#define	FRF_AB_XX_TERMADJ0_WIDTH 1
+#define	FRF_AB_XX_HIDRVD_LBN 15
+#define	FRF_AB_XX_HIDRVD_WIDTH 1
+#define	FRF_AB_XX_LODRVD_LBN 14
+#define	FRF_AB_XX_LODRVD_WIDTH 1
+#define	FRF_AB_XX_HIDRVC_LBN 13
+#define	FRF_AB_XX_HIDRVC_WIDTH 1
+#define	FRF_AB_XX_LODRVC_LBN 12
+#define	FRF_AB_XX_LODRVC_WIDTH 1
+#define	FRF_AB_XX_HIDRVB_LBN 11
+#define	FRF_AB_XX_HIDRVB_WIDTH 1
+#define	FRF_AB_XX_LODRVB_LBN 10
+#define	FRF_AB_XX_LODRVB_WIDTH 1
+#define	FRF_AB_XX_HIDRVA_LBN 9
+#define	FRF_AB_XX_HIDRVA_WIDTH 1
+#define	FRF_AB_XX_LODRVA_LBN 8
+#define	FRF_AB_XX_LODRVA_WIDTH 1
+#define	FRF_AB_XX_LPBKD_LBN 3
+#define	FRF_AB_XX_LPBKD_WIDTH 1
+#define	FRF_AB_XX_LPBKC_LBN 2
+#define	FRF_AB_XX_LPBKC_WIDTH 1
+#define	FRF_AB_XX_LPBKB_LBN 1
+#define	FRF_AB_XX_LPBKB_WIDTH 1
+#define	FRF_AB_XX_LPBKA_LBN 0
+#define	FRF_AB_XX_LPBKA_WIDTH 1
+
+/* XX_TXDRV_CTL_REG: XAUI SerDes transmit drive control register */
+#define	FR_AB_XX_TXDRV_CTL 0x00001320
+#define	FRF_AB_XX_DEQD_LBN 28
+#define	FRF_AB_XX_DEQD_WIDTH 4
+#define	FRF_AB_XX_DEQC_LBN 24
+#define	FRF_AB_XX_DEQC_WIDTH 4
+#define	FRF_AB_XX_DEQB_LBN 20
+#define	FRF_AB_XX_DEQB_WIDTH 4
+#define	FRF_AB_XX_DEQA_LBN 16
+#define	FRF_AB_XX_DEQA_WIDTH 4
+#define	FRF_AB_XX_DTXD_LBN 12
+#define	FRF_AB_XX_DTXD_WIDTH 4
+#define	FRF_AB_XX_DTXC_LBN 8
+#define	FRF_AB_XX_DTXC_WIDTH 4
+#define	FRF_AB_XX_DTXB_LBN 4
+#define	FRF_AB_XX_DTXB_WIDTH 4
+#define	FRF_AB_XX_DTXA_LBN 0
+#define	FRF_AB_XX_DTXA_WIDTH 4
+
+/* XX_PRBS_CTL_REG: documentation to be written for sum_XX_PRBS_CTL_REG */
+#define	FR_AB_XX_PRBS_CTL 0x00001330
+#define	FRF_AB_XX_CH3_RX_PRBS_SEL_LBN 30
+#define	FRF_AB_XX_CH3_RX_PRBS_SEL_WIDTH 2
+#define	FRF_AB_XX_CH3_RX_PRBS_INV_LBN 29
+#define	FRF_AB_XX_CH3_RX_PRBS_INV_WIDTH 1
+#define	FRF_AB_XX_CH3_RX_PRBS_CHKEN_LBN 28
+#define	FRF_AB_XX_CH3_RX_PRBS_CHKEN_WIDTH 1
+#define	FRF_AB_XX_CH2_RX_PRBS_SEL_LBN 26
+#define	FRF_AB_XX_CH2_RX_PRBS_SEL_WIDTH 2
+#define	FRF_AB_XX_CH2_RX_PRBS_INV_LBN 25
+#define	FRF_AB_XX_CH2_RX_PRBS_INV_WIDTH 1
+#define	FRF_AB_XX_CH2_RX_PRBS_CHKEN_LBN 24
+#define	FRF_AB_XX_CH2_RX_PRBS_CHKEN_WIDTH 1
+#define	FRF_AB_XX_CH1_RX_PRBS_SEL_LBN 22
+#define	FRF_AB_XX_CH1_RX_PRBS_SEL_WIDTH 2
+#define	FRF_AB_XX_CH1_RX_PRBS_INV_LBN 21
+#define	FRF_AB_XX_CH1_RX_PRBS_INV_WIDTH 1
+#define	FRF_AB_XX_CH1_RX_PRBS_CHKEN_LBN 20
+#define	FRF_AB_XX_CH1_RX_PRBS_CHKEN_WIDTH 1
+#define	FRF_AB_XX_CH0_RX_PRBS_SEL_LBN 18
+#define	FRF_AB_XX_CH0_RX_PRBS_SEL_WIDTH 2
+#define	FRF_AB_XX_CH0_RX_PRBS_INV_LBN 17
+#define	FRF_AB_XX_CH0_RX_PRBS_INV_WIDTH 1
+#define	FRF_AB_XX_CH0_RX_PRBS_CHKEN_LBN 16
+#define	FRF_AB_XX_CH0_RX_PRBS_CHKEN_WIDTH 1
+#define	FRF_AB_XX_CH3_TX_PRBS_SEL_LBN 14
+#define	FRF_AB_XX_CH3_TX_PRBS_SEL_WIDTH 2
+#define	FRF_AB_XX_CH3_TX_PRBS_INV_LBN 13
+#define	FRF_AB_XX_CH3_TX_PRBS_INV_WIDTH 1
+#define	FRF_AB_XX_CH3_TX_PRBS_CHKEN_LBN 12
+#define	FRF_AB_XX_CH3_TX_PRBS_CHKEN_WIDTH 1
+#define	FRF_AB_XX_CH2_TX_PRBS_SEL_LBN 10
+#define	FRF_AB_XX_CH2_TX_PRBS_SEL_WIDTH 2
+#define	FRF_AB_XX_CH2_TX_PRBS_INV_LBN 9
+#define	FRF_AB_XX_CH2_TX_PRBS_INV_WIDTH 1
+#define	FRF_AB_XX_CH2_TX_PRBS_CHKEN_LBN 8
+#define	FRF_AB_XX_CH2_TX_PRBS_CHKEN_WIDTH 1
+#define	FRF_AB_XX_CH1_TX_PRBS_SEL_LBN 6
+#define	FRF_AB_XX_CH1_TX_PRBS_SEL_WIDTH 2
+#define	FRF_AB_XX_CH1_TX_PRBS_INV_LBN 5
+#define	FRF_AB_XX_CH1_TX_PRBS_INV_WIDTH 1
+#define	FRF_AB_XX_CH1_TX_PRBS_CHKEN_LBN 4
+#define	FRF_AB_XX_CH1_TX_PRBS_CHKEN_WIDTH 1
+#define	FRF_AB_XX_CH0_TX_PRBS_SEL_LBN 2
+#define	FRF_AB_XX_CH0_TX_PRBS_SEL_WIDTH 2
+#define	FRF_AB_XX_CH0_TX_PRBS_INV_LBN 1
+#define	FRF_AB_XX_CH0_TX_PRBS_INV_WIDTH 1
+#define	FRF_AB_XX_CH0_TX_PRBS_CHKEN_LBN 0
+#define	FRF_AB_XX_CH0_TX_PRBS_CHKEN_WIDTH 1
+
+/* XX_PRBS_CHK_REG: documentation to be written for sum_XX_PRBS_CHK_REG */
+#define	FR_AB_XX_PRBS_CHK 0x00001340
+#define	FRF_AB_XX_REV_LB_EN_LBN 16
+#define	FRF_AB_XX_REV_LB_EN_WIDTH 1
+#define	FRF_AB_XX_CH3_DEG_DET_LBN 15
+#define	FRF_AB_XX_CH3_DEG_DET_WIDTH 1
+#define	FRF_AB_XX_CH3_LFSR_LOCK_IND_LBN 14
+#define	FRF_AB_XX_CH3_LFSR_LOCK_IND_WIDTH 1
+#define	FRF_AB_XX_CH3_PRBS_FRUN_LBN 13
+#define	FRF_AB_XX_CH3_PRBS_FRUN_WIDTH 1
+#define	FRF_AB_XX_CH3_ERR_CHK_LBN 12
+#define	FRF_AB_XX_CH3_ERR_CHK_WIDTH 1
+#define	FRF_AB_XX_CH2_DEG_DET_LBN 11
+#define	FRF_AB_XX_CH2_DEG_DET_WIDTH 1
+#define	FRF_AB_XX_CH2_LFSR_LOCK_IND_LBN 10
+#define	FRF_AB_XX_CH2_LFSR_LOCK_IND_WIDTH 1
+#define	FRF_AB_XX_CH2_PRBS_FRUN_LBN 9
+#define	FRF_AB_XX_CH2_PRBS_FRUN_WIDTH 1
+#define	FRF_AB_XX_CH2_ERR_CHK_LBN 8
+#define	FRF_AB_XX_CH2_ERR_CHK_WIDTH 1
+#define	FRF_AB_XX_CH1_DEG_DET_LBN 7
+#define	FRF_AB_XX_CH1_DEG_DET_WIDTH 1
+#define	FRF_AB_XX_CH1_LFSR_LOCK_IND_LBN 6
+#define	FRF_AB_XX_CH1_LFSR_LOCK_IND_WIDTH 1
+#define	FRF_AB_XX_CH1_PRBS_FRUN_LBN 5
+#define	FRF_AB_XX_CH1_PRBS_FRUN_WIDTH 1
+#define	FRF_AB_XX_CH1_ERR_CHK_LBN 4
+#define	FRF_AB_XX_CH1_ERR_CHK_WIDTH 1
+#define	FRF_AB_XX_CH0_DEG_DET_LBN 3
+#define	FRF_AB_XX_CH0_DEG_DET_WIDTH 1
+#define	FRF_AB_XX_CH0_LFSR_LOCK_IND_LBN 2
+#define	FRF_AB_XX_CH0_LFSR_LOCK_IND_WIDTH 1
+#define	FRF_AB_XX_CH0_PRBS_FRUN_LBN 1
+#define	FRF_AB_XX_CH0_PRBS_FRUN_WIDTH 1
+#define	FRF_AB_XX_CH0_ERR_CHK_LBN 0
+#define	FRF_AB_XX_CH0_ERR_CHK_WIDTH 1
+
+/* XX_PRBS_ERR_REG: documentation to be written for sum_XX_PRBS_ERR_REG */
+#define	FR_AB_XX_PRBS_ERR 0x00001350
+#define	FRF_AB_XX_CH3_PRBS_ERR_CNT_LBN 24
+#define	FRF_AB_XX_CH3_PRBS_ERR_CNT_WIDTH 8
+#define	FRF_AB_XX_CH2_PRBS_ERR_CNT_LBN 16
+#define	FRF_AB_XX_CH2_PRBS_ERR_CNT_WIDTH 8
+#define	FRF_AB_XX_CH1_PRBS_ERR_CNT_LBN 8
+#define	FRF_AB_XX_CH1_PRBS_ERR_CNT_WIDTH 8
+#define	FRF_AB_XX_CH0_PRBS_ERR_CNT_LBN 0
+#define	FRF_AB_XX_CH0_PRBS_ERR_CNT_WIDTH 8
+
+/* XX_CORE_STAT_REG: XAUI XGXS core status register */
+#define	FR_AB_XX_CORE_STAT 0x00001360
+#define	FRF_AB_XX_FORCE_SIG3_LBN 31
+#define	FRF_AB_XX_FORCE_SIG3_WIDTH 1
+#define	FRF_AB_XX_FORCE_SIG3_VAL_LBN 30
+#define	FRF_AB_XX_FORCE_SIG3_VAL_WIDTH 1
+#define	FRF_AB_XX_FORCE_SIG2_LBN 29
+#define	FRF_AB_XX_FORCE_SIG2_WIDTH 1
+#define	FRF_AB_XX_FORCE_SIG2_VAL_LBN 28
+#define	FRF_AB_XX_FORCE_SIG2_VAL_WIDTH 1
+#define	FRF_AB_XX_FORCE_SIG1_LBN 27
+#define	FRF_AB_XX_FORCE_SIG1_WIDTH 1
+#define	FRF_AB_XX_FORCE_SIG1_VAL_LBN 26
+#define	FRF_AB_XX_FORCE_SIG1_VAL_WIDTH 1
+#define	FRF_AB_XX_FORCE_SIG0_LBN 25
+#define	FRF_AB_XX_FORCE_SIG0_WIDTH 1
+#define	FRF_AB_XX_FORCE_SIG0_VAL_LBN 24
+#define	FRF_AB_XX_FORCE_SIG0_VAL_WIDTH 1
+#define	FRF_AB_XX_XGXS_LB_EN_LBN 23
+#define	FRF_AB_XX_XGXS_LB_EN_WIDTH 1
+#define	FRF_AB_XX_XGMII_LB_EN_LBN 22
+#define	FRF_AB_XX_XGMII_LB_EN_WIDTH 1
+#define	FRF_AB_XX_MATCH_FAULT_LBN 21
+#define	FRF_AB_XX_MATCH_FAULT_WIDTH 1
+#define	FRF_AB_XX_ALIGN_DONE_LBN 20
+#define	FRF_AB_XX_ALIGN_DONE_WIDTH 1
+#define	FRF_AB_XX_SYNC_STAT3_LBN 19
+#define	FRF_AB_XX_SYNC_STAT3_WIDTH 1
+#define	FRF_AB_XX_SYNC_STAT2_LBN 18
+#define	FRF_AB_XX_SYNC_STAT2_WIDTH 1
+#define	FRF_AB_XX_SYNC_STAT1_LBN 17
+#define	FRF_AB_XX_SYNC_STAT1_WIDTH 1
+#define	FRF_AB_XX_SYNC_STAT0_LBN 16
+#define	FRF_AB_XX_SYNC_STAT0_WIDTH 1
+#define	FRF_AB_XX_COMMA_DET_CH3_LBN 15
+#define	FRF_AB_XX_COMMA_DET_CH3_WIDTH 1
+#define	FRF_AB_XX_COMMA_DET_CH2_LBN 14
+#define	FRF_AB_XX_COMMA_DET_CH2_WIDTH 1
+#define	FRF_AB_XX_COMMA_DET_CH1_LBN 13
+#define	FRF_AB_XX_COMMA_DET_CH1_WIDTH 1
+#define	FRF_AB_XX_COMMA_DET_CH0_LBN 12
+#define	FRF_AB_XX_COMMA_DET_CH0_WIDTH 1
+#define	FRF_AB_XX_CGRP_ALIGN_CH3_LBN 11
+#define	FRF_AB_XX_CGRP_ALIGN_CH3_WIDTH 1
+#define	FRF_AB_XX_CGRP_ALIGN_CH2_LBN 10
+#define	FRF_AB_XX_CGRP_ALIGN_CH2_WIDTH 1
+#define	FRF_AB_XX_CGRP_ALIGN_CH1_LBN 9
+#define	FRF_AB_XX_CGRP_ALIGN_CH1_WIDTH 1
+#define	FRF_AB_XX_CGRP_ALIGN_CH0_LBN 8
+#define	FRF_AB_XX_CGRP_ALIGN_CH0_WIDTH 1
+#define	FRF_AB_XX_CHAR_ERR_CH3_LBN 7
+#define	FRF_AB_XX_CHAR_ERR_CH3_WIDTH 1
+#define	FRF_AB_XX_CHAR_ERR_CH2_LBN 6
+#define	FRF_AB_XX_CHAR_ERR_CH2_WIDTH 1
+#define	FRF_AB_XX_CHAR_ERR_CH1_LBN 5
+#define	FRF_AB_XX_CHAR_ERR_CH1_WIDTH 1
+#define	FRF_AB_XX_CHAR_ERR_CH0_LBN 4
+#define	FRF_AB_XX_CHAR_ERR_CH0_WIDTH 1
+#define	FRF_AB_XX_DISPERR_CH3_LBN 3
+#define	FRF_AB_XX_DISPERR_CH3_WIDTH 1
+#define	FRF_AB_XX_DISPERR_CH2_LBN 2
+#define	FRF_AB_XX_DISPERR_CH2_WIDTH 1
+#define	FRF_AB_XX_DISPERR_CH1_LBN 1
+#define	FRF_AB_XX_DISPERR_CH1_WIDTH 1
+#define	FRF_AB_XX_DISPERR_CH0_LBN 0
+#define	FRF_AB_XX_DISPERR_CH0_WIDTH 1
+
+/* RX_DESC_PTR_TBL_KER: Receive descriptor pointer table */
+#define	FR_AA_RX_DESC_PTR_TBL_KER 0x00011800
+#define	FR_AA_RX_DESC_PTR_TBL_KER_STEP 16
+#define	FR_AA_RX_DESC_PTR_TBL_KER_ROWS 4
+/* RX_DESC_PTR_TBL: Receive descriptor pointer table */
+#define	FR_BZ_RX_DESC_PTR_TBL 0x00f40000
+#define	FR_BZ_RX_DESC_PTR_TBL_STEP 16
+#define	FR_BB_RX_DESC_PTR_TBL_ROWS 4096
+#define	FR_CZ_RX_DESC_PTR_TBL_ROWS 1024
+#define	FRF_CZ_RX_HDR_SPLIT_LBN 90
+#define	FRF_CZ_RX_HDR_SPLIT_WIDTH 1
+#define	FRF_AA_RX_RESET_LBN 89
+#define	FRF_AA_RX_RESET_WIDTH 1
+#define	FRF_AZ_RX_ISCSI_DDIG_EN_LBN 88
+#define	FRF_AZ_RX_ISCSI_DDIG_EN_WIDTH 1
+#define	FRF_AZ_RX_ISCSI_HDIG_EN_LBN 87
+#define	FRF_AZ_RX_ISCSI_HDIG_EN_WIDTH 1
+#define	FRF_AZ_RX_DESC_PREF_ACT_LBN 86
+#define	FRF_AZ_RX_DESC_PREF_ACT_WIDTH 1
+#define	FRF_AZ_RX_DC_HW_RPTR_LBN 80
+#define	FRF_AZ_RX_DC_HW_RPTR_WIDTH 6
+#define	FRF_AZ_RX_DESCQ_HW_RPTR_LBN 68
+#define	FRF_AZ_RX_DESCQ_HW_RPTR_WIDTH 12
+#define	FRF_AZ_RX_DESCQ_SW_WPTR_LBN 56
+#define	FRF_AZ_RX_DESCQ_SW_WPTR_WIDTH 12
+#define	FRF_AZ_RX_DESCQ_BUF_BASE_ID_LBN 36
+#define	FRF_AZ_RX_DESCQ_BUF_BASE_ID_WIDTH 20
+#define	FRF_AZ_RX_DESCQ_EVQ_ID_LBN 24
+#define	FRF_AZ_RX_DESCQ_EVQ_ID_WIDTH 12
+#define	FRF_AZ_RX_DESCQ_OWNER_ID_LBN 10
+#define	FRF_AZ_RX_DESCQ_OWNER_ID_WIDTH 14
+#define	FRF_AZ_RX_DESCQ_LABEL_LBN 5
+#define	FRF_AZ_RX_DESCQ_LABEL_WIDTH 5
+#define	FRF_AZ_RX_DESCQ_SIZE_LBN 3
+#define	FRF_AZ_RX_DESCQ_SIZE_WIDTH 2
+#define	FFE_AZ_RX_DESCQ_SIZE_4K 3
+#define	FFE_AZ_RX_DESCQ_SIZE_2K 2
+#define	FFE_AZ_RX_DESCQ_SIZE_1K 1
+#define	FFE_AZ_RX_DESCQ_SIZE_512 0
+#define	FRF_AZ_RX_DESCQ_TYPE_LBN 2
+#define	FRF_AZ_RX_DESCQ_TYPE_WIDTH 1
+#define	FRF_AZ_RX_DESCQ_JUMBO_LBN 1
+#define	FRF_AZ_RX_DESCQ_JUMBO_WIDTH 1
+#define	FRF_AZ_RX_DESCQ_EN_LBN 0
+#define	FRF_AZ_RX_DESCQ_EN_WIDTH 1
+
+/* TX_DESC_PTR_TBL_KER: Transmit descriptor pointer */
+#define	FR_AA_TX_DESC_PTR_TBL_KER 0x00011900
+#define	FR_AA_TX_DESC_PTR_TBL_KER_STEP 16
+#define	FR_AA_TX_DESC_PTR_TBL_KER_ROWS 8
+/* TX_DESC_PTR_TBL: Transmit descriptor pointer */
+#define	FR_BZ_TX_DESC_PTR_TBL 0x00f50000
+#define	FR_BZ_TX_DESC_PTR_TBL_STEP 16
+#define	FR_BB_TX_DESC_PTR_TBL_ROWS 4096
+#define	FR_CZ_TX_DESC_PTR_TBL_ROWS 1024
+#define	FRF_CZ_TX_DPT_Q_MASK_WIDTH_LBN 94
+#define	FRF_CZ_TX_DPT_Q_MASK_WIDTH_WIDTH 2
+#define	FRF_CZ_TX_DPT_ETH_FILT_EN_LBN 93
+#define	FRF_CZ_TX_DPT_ETH_FILT_EN_WIDTH 1
+#define	FRF_CZ_TX_DPT_IP_FILT_EN_LBN 92
+#define	FRF_CZ_TX_DPT_IP_FILT_EN_WIDTH 1
+#define	FRF_BZ_TX_NON_IP_DROP_DIS_LBN 91
+#define	FRF_BZ_TX_NON_IP_DROP_DIS_WIDTH 1
+#define	FRF_BZ_TX_IP_CHKSM_DIS_LBN 90
+#define	FRF_BZ_TX_IP_CHKSM_DIS_WIDTH 1
+#define	FRF_BZ_TX_TCP_CHKSM_DIS_LBN 89
+#define	FRF_BZ_TX_TCP_CHKSM_DIS_WIDTH 1
+#define	FRF_AZ_TX_DESCQ_EN_LBN 88
+#define	FRF_AZ_TX_DESCQ_EN_WIDTH 1
+#define	FRF_AZ_TX_ISCSI_DDIG_EN_LBN 87
+#define	FRF_AZ_TX_ISCSI_DDIG_EN_WIDTH 1
+#define	FRF_AZ_TX_ISCSI_HDIG_EN_LBN 86
+#define	FRF_AZ_TX_ISCSI_HDIG_EN_WIDTH 1
+#define	FRF_AZ_TX_DC_HW_RPTR_LBN 80
+#define	FRF_AZ_TX_DC_HW_RPTR_WIDTH 6
+#define	FRF_AZ_TX_DESCQ_HW_RPTR_LBN 68
+#define	FRF_AZ_TX_DESCQ_HW_RPTR_WIDTH 12
+#define	FRF_AZ_TX_DESCQ_SW_WPTR_LBN 56
+#define	FRF_AZ_TX_DESCQ_SW_WPTR_WIDTH 12
+#define	FRF_AZ_TX_DESCQ_BUF_BASE_ID_LBN 36
+#define	FRF_AZ_TX_DESCQ_BUF_BASE_ID_WIDTH 20
+#define	FRF_AZ_TX_DESCQ_EVQ_ID_LBN 24
+#define	FRF_AZ_TX_DESCQ_EVQ_ID_WIDTH 12
+#define	FRF_AZ_TX_DESCQ_OWNER_ID_LBN 10
+#define	FRF_AZ_TX_DESCQ_OWNER_ID_WIDTH 14
+#define	FRF_AZ_TX_DESCQ_LABEL_LBN 5
+#define	FRF_AZ_TX_DESCQ_LABEL_WIDTH 5
+#define	FRF_AZ_TX_DESCQ_SIZE_LBN 3
+#define	FRF_AZ_TX_DESCQ_SIZE_WIDTH 2
+#define	FFE_AZ_TX_DESCQ_SIZE_4K 3
+#define	FFE_AZ_TX_DESCQ_SIZE_2K 2
+#define	FFE_AZ_TX_DESCQ_SIZE_1K 1
+#define	FFE_AZ_TX_DESCQ_SIZE_512 0
+#define	FRF_AZ_TX_DESCQ_TYPE_LBN 1
+#define	FRF_AZ_TX_DESCQ_TYPE_WIDTH 2
+#define	FRF_AZ_TX_DESCQ_FLUSH_LBN 0
+#define	FRF_AZ_TX_DESCQ_FLUSH_WIDTH 1
+
+/* EVQ_PTR_TBL_KER: Event queue pointer table */
+#define	FR_AA_EVQ_PTR_TBL_KER 0x00011a00
+#define	FR_AA_EVQ_PTR_TBL_KER_STEP 16
+#define	FR_AA_EVQ_PTR_TBL_KER_ROWS 4
+/* EVQ_PTR_TBL: Event queue pointer table */
+#define	FR_BZ_EVQ_PTR_TBL 0x00f60000
+#define	FR_BZ_EVQ_PTR_TBL_STEP 16
+#define	FR_CZ_EVQ_PTR_TBL_ROWS 1024
+#define	FR_BB_EVQ_PTR_TBL_ROWS 4096
+#define	FRF_BZ_EVQ_RPTR_IGN_LBN 40
+#define	FRF_BZ_EVQ_RPTR_IGN_WIDTH 1
+#define	FRF_AB_EVQ_WKUP_OR_INT_EN_LBN 39
+#define	FRF_AB_EVQ_WKUP_OR_INT_EN_WIDTH 1
+#define	FRF_CZ_EVQ_DOS_PROTECT_EN_LBN 39
+#define	FRF_CZ_EVQ_DOS_PROTECT_EN_WIDTH 1
+#define	FRF_AZ_EVQ_NXT_WPTR_LBN 24
+#define	FRF_AZ_EVQ_NXT_WPTR_WIDTH 15
+#define	FRF_AZ_EVQ_EN_LBN 23
+#define	FRF_AZ_EVQ_EN_WIDTH 1
+#define	FRF_AZ_EVQ_SIZE_LBN 20
+#define	FRF_AZ_EVQ_SIZE_WIDTH 3
+#define	FFE_AZ_EVQ_SIZE_32K 6
+#define	FFE_AZ_EVQ_SIZE_16K 5
+#define	FFE_AZ_EVQ_SIZE_8K 4
+#define	FFE_AZ_EVQ_SIZE_4K 3
+#define	FFE_AZ_EVQ_SIZE_2K 2
+#define	FFE_AZ_EVQ_SIZE_1K 1
+#define	FFE_AZ_EVQ_SIZE_512 0
+#define	FRF_AZ_EVQ_BUF_BASE_ID_LBN 0
+#define	FRF_AZ_EVQ_BUF_BASE_ID_WIDTH 20
+
+/* BUF_HALF_TBL_KER: Buffer table in half buffer table mode direct access by driver */
+#define	FR_AA_BUF_HALF_TBL_KER 0x00018000
+#define	FR_AA_BUF_HALF_TBL_KER_STEP 8
+#define	FR_AA_BUF_HALF_TBL_KER_ROWS 4096
+/* BUF_HALF_TBL: Buffer table in half buffer table mode direct access by driver */
+#define	FR_BZ_BUF_HALF_TBL 0x00800000
+#define	FR_BZ_BUF_HALF_TBL_STEP 8
+#define	FR_CZ_BUF_HALF_TBL_ROWS 147456
+#define	FR_BB_BUF_HALF_TBL_ROWS 524288
+#define	FRF_AZ_BUF_ADR_HBUF_ODD_LBN 44
+#define	FRF_AZ_BUF_ADR_HBUF_ODD_WIDTH 20
+#define	FRF_AZ_BUF_OWNER_ID_HBUF_ODD_LBN 32
+#define	FRF_AZ_BUF_OWNER_ID_HBUF_ODD_WIDTH 12
+#define	FRF_AZ_BUF_ADR_HBUF_EVEN_LBN 12
+#define	FRF_AZ_BUF_ADR_HBUF_EVEN_WIDTH 20
+#define	FRF_AZ_BUF_OWNER_ID_HBUF_EVEN_LBN 0
+#define	FRF_AZ_BUF_OWNER_ID_HBUF_EVEN_WIDTH 12
+
+/* BUF_FULL_TBL_KER: Buffer table in full buffer table mode direct access by driver */
+#define	FR_AA_BUF_FULL_TBL_KER 0x00018000
+#define	FR_AA_BUF_FULL_TBL_KER_STEP 8
+#define	FR_AA_BUF_FULL_TBL_KER_ROWS 4096
+/* BUF_FULL_TBL: Buffer table in full buffer table mode direct access by driver */
+#define	FR_BZ_BUF_FULL_TBL 0x00800000
+#define	FR_BZ_BUF_FULL_TBL_STEP 8
+#define	FR_CZ_BUF_FULL_TBL_ROWS 147456
+#define	FR_BB_BUF_FULL_TBL_ROWS 917504
+#define	FRF_AZ_BUF_FULL_UNUSED_LBN 51
+#define	FRF_AZ_BUF_FULL_UNUSED_WIDTH 13
+#define	FRF_AZ_IP_DAT_BUF_SIZE_LBN 50
+#define	FRF_AZ_IP_DAT_BUF_SIZE_WIDTH 1
+#define	FRF_AZ_BUF_ADR_REGION_LBN 48
+#define	FRF_AZ_BUF_ADR_REGION_WIDTH 2
+#define	FFE_AZ_BUF_ADR_REGN3 3
+#define	FFE_AZ_BUF_ADR_REGN2 2
+#define	FFE_AZ_BUF_ADR_REGN1 1
+#define	FFE_AZ_BUF_ADR_REGN0 0
+#define	FRF_AZ_BUF_ADR_FBUF_LBN 14
+#define	FRF_AZ_BUF_ADR_FBUF_WIDTH 34
+#define	FRF_AZ_BUF_OWNER_ID_FBUF_LBN 0
+#define	FRF_AZ_BUF_OWNER_ID_FBUF_WIDTH 14
+
+/* RX_FILTER_TBL0: TCP/IPv4 Receive filter table */
+#define	FR_BZ_RX_FILTER_TBL0 0x00f00000
+#define	FR_BZ_RX_FILTER_TBL0_STEP 32
+#define	FR_BZ_RX_FILTER_TBL0_ROWS 8192
+/* RX_FILTER_TBL1: TCP/IPv4 Receive filter table */
+#define	FR_BB_RX_FILTER_TBL1 0x00f00010
+#define	FR_BB_RX_FILTER_TBL1_STEP 32
+#define	FR_BB_RX_FILTER_TBL1_ROWS 8192
+#define	FRF_BZ_RSS_EN_LBN 110
+#define	FRF_BZ_RSS_EN_WIDTH 1
+#define	FRF_BZ_SCATTER_EN_LBN 109
+#define	FRF_BZ_SCATTER_EN_WIDTH 1
+#define	FRF_BZ_TCP_UDP_LBN 108
+#define	FRF_BZ_TCP_UDP_WIDTH 1
+#define	FRF_BZ_RXQ_ID_LBN 96
+#define	FRF_BZ_RXQ_ID_WIDTH 12
+#define	FRF_BZ_DEST_IP_LBN 64
+#define	FRF_BZ_DEST_IP_WIDTH 32
+#define	FRF_BZ_DEST_PORT_TCP_LBN 48
+#define	FRF_BZ_DEST_PORT_TCP_WIDTH 16
+#define	FRF_BZ_SRC_IP_LBN 16
+#define	FRF_BZ_SRC_IP_WIDTH 32
+#define	FRF_BZ_SRC_TCP_DEST_UDP_LBN 0
+#define	FRF_BZ_SRC_TCP_DEST_UDP_WIDTH 16
+
+/* RX_MAC_FILTER_TBL0: Receive Ethernet filter table */
+#define	FR_CZ_RX_MAC_FILTER_TBL0 0x00f00010
+#define	FR_CZ_RX_MAC_FILTER_TBL0_STEP 32
+#define	FR_CZ_RX_MAC_FILTER_TBL0_ROWS 512
+#define	FRF_CZ_RMFT_RSS_EN_LBN 75
+#define	FRF_CZ_RMFT_RSS_EN_WIDTH 1
+#define	FRF_CZ_RMFT_SCATTER_EN_LBN 74
+#define	FRF_CZ_RMFT_SCATTER_EN_WIDTH 1
+#define	FRF_CZ_RMFT_IP_OVERRIDE_LBN 73
+#define	FRF_CZ_RMFT_IP_OVERRIDE_WIDTH 1
+#define	FRF_CZ_RMFT_RXQ_ID_LBN 61
+#define	FRF_CZ_RMFT_RXQ_ID_WIDTH 12
+#define	FRF_CZ_RMFT_WILDCARD_MATCH_LBN 60
+#define	FRF_CZ_RMFT_WILDCARD_MATCH_WIDTH 1
+#define	FRF_CZ_RMFT_DEST_MAC_LBN 12
+#define	FRF_CZ_RMFT_DEST_MAC_WIDTH 48
+#define	FRF_CZ_RMFT_VLAN_ID_LBN 0
+#define	FRF_CZ_RMFT_VLAN_ID_WIDTH 12
+
+/* TIMER_TBL: Timer table */
+#define	FR_BZ_TIMER_TBL 0x00f70000
+#define	FR_BZ_TIMER_TBL_STEP 16
+#define	FR_CZ_TIMER_TBL_ROWS 1024
+#define	FR_BB_TIMER_TBL_ROWS 4096
+#define	FRF_CZ_TIMER_Q_EN_LBN 33
+#define	FRF_CZ_TIMER_Q_EN_WIDTH 1
+#define	FRF_CZ_INT_ARMD_LBN 32
+#define	FRF_CZ_INT_ARMD_WIDTH 1
+#define	FRF_CZ_INT_PEND_LBN 31
+#define	FRF_CZ_INT_PEND_WIDTH 1
+#define	FRF_CZ_HOST_NOTIFY_MODE_LBN 30
+#define	FRF_CZ_HOST_NOTIFY_MODE_WIDTH 1
+#define	FRF_CZ_RELOAD_TIMER_VAL_LBN 16
+#define	FRF_CZ_RELOAD_TIMER_VAL_WIDTH 14
+#define	FRF_CZ_TIMER_MODE_LBN 14
+#define	FRF_CZ_TIMER_MODE_WIDTH 2
+#define	FFE_CZ_TIMER_MODE_INT_HLDOFF 3
+#define	FFE_CZ_TIMER_MODE_TRIG_START 2
+#define	FFE_CZ_TIMER_MODE_IMMED_START 1
+#define	FFE_CZ_TIMER_MODE_DIS 0
+#define	FRF_BB_TIMER_MODE_LBN 12
+#define	FRF_BB_TIMER_MODE_WIDTH 2
+#define	FFE_BB_TIMER_MODE_INT_HLDOFF 2
+#define	FFE_BB_TIMER_MODE_TRIG_START 2
+#define	FFE_BB_TIMER_MODE_IMMED_START 1
+#define	FFE_BB_TIMER_MODE_DIS 0
+#define	FRF_CZ_TIMER_VAL_LBN 0
+#define	FRF_CZ_TIMER_VAL_WIDTH 14
+#define	FRF_BB_TIMER_VAL_LBN 0
+#define	FRF_BB_TIMER_VAL_WIDTH 12
+
+/* TX_PACE_TBL: Transmit pacing table */
+#define	FR_BZ_TX_PACE_TBL 0x00f80000
+#define	FR_BZ_TX_PACE_TBL_STEP 16
+#define	FR_CZ_TX_PACE_TBL_ROWS 1024
+#define	FR_BB_TX_PACE_TBL_ROWS 4096
+#define	FRF_BZ_TX_PACE_LBN 0
+#define	FRF_BZ_TX_PACE_WIDTH 5
+
+/* RX_INDIRECTION_TBL: RX Indirection Table */
+#define	FR_BZ_RX_INDIRECTION_TBL 0x00fb0000
+#define	FR_BZ_RX_INDIRECTION_TBL_STEP 16
+#define	FR_BZ_RX_INDIRECTION_TBL_ROWS 128
+#define	FRF_BZ_IT_QUEUE_LBN 0
+#define	FRF_BZ_IT_QUEUE_WIDTH 6
+
+/* TX_FILTER_TBL0: TCP/IPv4 Transmit filter table */
+#define	FR_CZ_TX_FILTER_TBL0 0x00fc0000
+#define	FR_CZ_TX_FILTER_TBL0_STEP 16
+#define	FR_CZ_TX_FILTER_TBL0_ROWS 8192
+#define	FRF_CZ_TIFT_TCP_UDP_LBN 108
+#define	FRF_CZ_TIFT_TCP_UDP_WIDTH 1
+#define	FRF_CZ_TIFT_TXQ_ID_LBN 96
+#define	FRF_CZ_TIFT_TXQ_ID_WIDTH 12
+#define	FRF_CZ_TIFT_DEST_IP_LBN 64
+#define	FRF_CZ_TIFT_DEST_IP_WIDTH 32
+#define	FRF_CZ_TIFT_DEST_PORT_TCP_LBN 48
+#define	FRF_CZ_TIFT_DEST_PORT_TCP_WIDTH 16
+#define	FRF_CZ_TIFT_SRC_IP_LBN 16
+#define	FRF_CZ_TIFT_SRC_IP_WIDTH 32
+#define	FRF_CZ_TIFT_SRC_TCP_DEST_UDP_LBN 0
+#define	FRF_CZ_TIFT_SRC_TCP_DEST_UDP_WIDTH 16
+
+/* TX_MAC_FILTER_TBL0: Transmit Ethernet filter table */
+#define	FR_CZ_TX_MAC_FILTER_TBL0 0x00fe0000
+#define	FR_CZ_TX_MAC_FILTER_TBL0_STEP 16
+#define	FR_CZ_TX_MAC_FILTER_TBL0_ROWS 512
+#define	FRF_CZ_TMFT_TXQ_ID_LBN 61
+#define	FRF_CZ_TMFT_TXQ_ID_WIDTH 12
+#define	FRF_CZ_TMFT_WILDCARD_MATCH_LBN 60
+#define	FRF_CZ_TMFT_WILDCARD_MATCH_WIDTH 1
+#define	FRF_CZ_TMFT_SRC_MAC_LBN 12
+#define	FRF_CZ_TMFT_SRC_MAC_WIDTH 48
+#define	FRF_CZ_TMFT_VLAN_ID_LBN 0
+#define	FRF_CZ_TMFT_VLAN_ID_WIDTH 12
+
+/* MC_TREG_SMEM: MC Shared Memory */
+#define	FR_CZ_MC_TREG_SMEM 0x00ff0000
+#define	FR_CZ_MC_TREG_SMEM_STEP 4
+#define	FR_CZ_MC_TREG_SMEM_ROWS 512
+#define	FRF_CZ_MC_TREG_SMEM_ROW_LBN 0
+#define	FRF_CZ_MC_TREG_SMEM_ROW_WIDTH 32
+
+/* MSIX_VECTOR_TABLE: MSIX Vector Table */
+#define	FR_BB_MSIX_VECTOR_TABLE 0x00ff0000
+#define	FR_BZ_MSIX_VECTOR_TABLE_STEP 16
+#define	FR_BB_MSIX_VECTOR_TABLE_ROWS 64
+/* MSIX_VECTOR_TABLE: MSIX Vector Table */
+#define	FR_CZ_MSIX_VECTOR_TABLE 0x00000000
+/* FR_BZ_MSIX_VECTOR_TABLE_STEP 16 */
+#define	FR_CZ_MSIX_VECTOR_TABLE_ROWS 1024
+#define	FRF_BZ_MSIX_VECTOR_RESERVED_LBN 97
+#define	FRF_BZ_MSIX_VECTOR_RESERVED_WIDTH 31
+#define	FRF_BZ_MSIX_VECTOR_MASK_LBN 96
+#define	FRF_BZ_MSIX_VECTOR_MASK_WIDTH 1
+#define	FRF_BZ_MSIX_MESSAGE_DATA_LBN 64
+#define	FRF_BZ_MSIX_MESSAGE_DATA_WIDTH 32
+#define	FRF_BZ_MSIX_MESSAGE_ADDRESS_HI_LBN 32
+#define	FRF_BZ_MSIX_MESSAGE_ADDRESS_HI_WIDTH 32
+#define	FRF_BZ_MSIX_MESSAGE_ADDRESS_LO_LBN 0
+#define	FRF_BZ_MSIX_MESSAGE_ADDRESS_LO_WIDTH 32
+
+/* MSIX_PBA_TABLE: MSIX Pending Bit Array */
+#define	FR_BB_MSIX_PBA_TABLE 0x00ff2000
+#define	FR_BZ_MSIX_PBA_TABLE_STEP 4
+#define	FR_BB_MSIX_PBA_TABLE_ROWS 2
+/* MSIX_PBA_TABLE: MSIX Pending Bit Array */
+#define	FR_CZ_MSIX_PBA_TABLE 0x00008000
+/* FR_BZ_MSIX_PBA_TABLE_STEP 4 */
+#define	FR_CZ_MSIX_PBA_TABLE_ROWS 32
+#define	FRF_BZ_MSIX_PBA_PEND_DWORD_LBN 0
+#define	FRF_BZ_MSIX_PBA_PEND_DWORD_WIDTH 32
+
+/* SRM_DBG_REG: SRAM debug access */
+#define	FR_BZ_SRM_DBG 0x03000000
+#define	FR_BZ_SRM_DBG_STEP 8
+#define	FR_CZ_SRM_DBG_ROWS 262144
+#define	FR_BB_SRM_DBG_ROWS 2097152
+#define	FRF_BZ_SRM_DBG_LBN 0
+#define	FRF_BZ_SRM_DBG_WIDTH 64
+
+/* TB_MSIX_PBA_TABLE: MSIX Pending Bit Array */
+#define	FR_CZ_TB_MSIX_PBA_TABLE 0x00008000
+#define	FR_CZ_TB_MSIX_PBA_TABLE_STEP 4
+#define	FR_CZ_TB_MSIX_PBA_TABLE_ROWS 1024
+#define	FRF_CZ_TB_MSIX_PBA_PEND_DWORD_LBN 0
+#define	FRF_CZ_TB_MSIX_PBA_PEND_DWORD_WIDTH 32
+
+/* DRIVER_EV */
+#define	FSF_AZ_DRIVER_EV_SUBCODE_LBN 56
+#define	FSF_AZ_DRIVER_EV_SUBCODE_WIDTH 4
+#define	FSE_BZ_TX_DSC_ERROR_EV 15
+#define	FSE_BZ_RX_DSC_ERROR_EV 14
+#define	FSE_AA_RX_RECOVER_EV 11
+#define	FSE_AZ_TIMER_EV 10
+#define	FSE_AZ_TX_PKT_NON_TCP_UDP 9
+#define	FSE_AZ_WAKE_UP_EV 6
+#define	FSE_AZ_SRM_UPD_DONE_EV 5
+#define	FSE_AB_EVQ_NOT_EN_EV 3
+#define	FSE_AZ_EVQ_INIT_DONE_EV 2
+#define	FSE_AZ_RX_DESCQ_FLS_DONE_EV 1
+#define	FSE_AZ_TX_DESCQ_FLS_DONE_EV 0
+#define	FSF_AZ_DRIVER_EV_SUBDATA_LBN 0
+#define	FSF_AZ_DRIVER_EV_SUBDATA_WIDTH 14
+
+/* EVENT_ENTRY */
+#define	FSF_AZ_EV_CODE_LBN 60
+#define	FSF_AZ_EV_CODE_WIDTH 4
+#define	FSE_CZ_EV_CODE_MCDI_EV 12
+#define	FSE_CZ_EV_CODE_USER_EV 8
+#define	FSE_AZ_EV_CODE_DRV_GEN_EV 7
+#define	FSE_AZ_EV_CODE_GLOBAL_EV 6
+#define	FSE_AZ_EV_CODE_DRIVER_EV 5
+#define	FSE_AZ_EV_CODE_TX_EV 2
+#define	FSE_AZ_EV_CODE_RX_EV 0
+#define	FSF_AZ_EV_DATA_LBN 0
+#define	FSF_AZ_EV_DATA_WIDTH 60
+
+/* GLOBAL_EV */
+#define	FSF_BB_GLB_EV_RX_RECOVERY_LBN 12
+#define	FSF_BB_GLB_EV_RX_RECOVERY_WIDTH 1
+#define	FSF_AA_GLB_EV_RX_RECOVERY_LBN 11
+#define	FSF_AA_GLB_EV_RX_RECOVERY_WIDTH 1
+#define	FSF_BB_GLB_EV_XG_MGT_INTR_LBN 11
+#define	FSF_BB_GLB_EV_XG_MGT_INTR_WIDTH 1
+#define	FSF_AB_GLB_EV_XFP_PHY0_INTR_LBN 10
+#define	FSF_AB_GLB_EV_XFP_PHY0_INTR_WIDTH 1
+#define	FSF_AB_GLB_EV_XG_PHY0_INTR_LBN 9
+#define	FSF_AB_GLB_EV_XG_PHY0_INTR_WIDTH 1
+#define	FSF_AB_GLB_EV_G_PHY0_INTR_LBN 7
+#define	FSF_AB_GLB_EV_G_PHY0_INTR_WIDTH 1
+
+/* LEGACY_INT_VEC */
+#define	FSF_AZ_NET_IVEC_FATAL_INT_LBN 64
+#define	FSF_AZ_NET_IVEC_FATAL_INT_WIDTH 1
+#define	FSF_AZ_NET_IVEC_INT_Q_LBN 40
+#define	FSF_AZ_NET_IVEC_INT_Q_WIDTH 4
+#define	FSF_AZ_NET_IVEC_INT_FLAG_LBN 32
+#define	FSF_AZ_NET_IVEC_INT_FLAG_WIDTH 1
+#define	FSF_AZ_NET_IVEC_EVQ_FIFO_HF_LBN 1
+#define	FSF_AZ_NET_IVEC_EVQ_FIFO_HF_WIDTH 1
+#define	FSF_AZ_NET_IVEC_EVQ_FIFO_AF_LBN 0
+#define	FSF_AZ_NET_IVEC_EVQ_FIFO_AF_WIDTH 1
+
+/* MC_XGMAC_FLTR_RULE_DEF */
+#define	FSF_CZ_MC_XFRC_MODE_LBN 416
+#define	FSF_CZ_MC_XFRC_MODE_WIDTH 1
+#define	FSE_CZ_MC_XFRC_MODE_LAYERED 1
+#define	FSE_CZ_MC_XFRC_MODE_SIMPLE 0
+#define	FSF_CZ_MC_XFRC_HASH_LBN 384
+#define	FSF_CZ_MC_XFRC_HASH_WIDTH 32
+#define	FSF_CZ_MC_XFRC_LAYER4_BYTE_MASK_LBN 256
+#define	FSF_CZ_MC_XFRC_LAYER4_BYTE_MASK_WIDTH 128
+#define	FSF_CZ_MC_XFRC_LAYER3_BYTE_MASK_LBN 128
+#define	FSF_CZ_MC_XFRC_LAYER3_BYTE_MASK_WIDTH 128
+#define	FSF_CZ_MC_XFRC_LAYER2_OR_SIMPLE_BYTE_MASK_LBN 0
+#define	FSF_CZ_MC_XFRC_LAYER2_OR_SIMPLE_BYTE_MASK_WIDTH 128
+
+/* RX_EV */
+#define	FSF_CZ_RX_EV_PKT_NOT_PARSED_LBN 58
+#define	FSF_CZ_RX_EV_PKT_NOT_PARSED_WIDTH 1
+#define	FSF_CZ_RX_EV_IPV6_PKT_LBN 57
+#define	FSF_CZ_RX_EV_IPV6_PKT_WIDTH 1
+#define	FSF_AZ_RX_EV_PKT_OK_LBN 56
+#define	FSF_AZ_RX_EV_PKT_OK_WIDTH 1
+#define	FSF_AZ_RX_EV_PAUSE_FRM_ERR_LBN 55
+#define	FSF_AZ_RX_EV_PAUSE_FRM_ERR_WIDTH 1
+#define	FSF_AZ_RX_EV_BUF_OWNER_ID_ERR_LBN 54
+#define	FSF_AZ_RX_EV_BUF_OWNER_ID_ERR_WIDTH 1
+#define	FSF_AZ_RX_EV_IP_FRAG_ERR_LBN 53
+#define	FSF_AZ_RX_EV_IP_FRAG_ERR_WIDTH 1
+#define	FSF_AZ_RX_EV_IP_HDR_CHKSUM_ERR_LBN 52
+#define	FSF_AZ_RX_EV_IP_HDR_CHKSUM_ERR_WIDTH 1
+#define	FSF_AZ_RX_EV_TCP_UDP_CHKSUM_ERR_LBN 51
+#define	FSF_AZ_RX_EV_TCP_UDP_CHKSUM_ERR_WIDTH 1
+#define	FSF_AZ_RX_EV_ETH_CRC_ERR_LBN 50
+#define	FSF_AZ_RX_EV_ETH_CRC_ERR_WIDTH 1
+#define	FSF_AZ_RX_EV_FRM_TRUNC_LBN 49
+#define	FSF_AZ_RX_EV_FRM_TRUNC_WIDTH 1
+#define	FSF_AA_RX_EV_DRIB_NIB_LBN 49
+#define	FSF_AA_RX_EV_DRIB_NIB_WIDTH 1
+#define	FSF_AZ_RX_EV_TOBE_DISC_LBN 47
+#define	FSF_AZ_RX_EV_TOBE_DISC_WIDTH 1
+#define	FSF_AZ_RX_EV_PKT_TYPE_LBN 44
+#define	FSF_AZ_RX_EV_PKT_TYPE_WIDTH 3
+#define	FSE_AZ_RX_EV_PKT_TYPE_VLAN_JUMBO 5
+#define	FSE_AZ_RX_EV_PKT_TYPE_VLAN_LLC 4
+#define	FSE_AZ_RX_EV_PKT_TYPE_VLAN 3
+#define	FSE_AZ_RX_EV_PKT_TYPE_JUMBO 2
+#define	FSE_AZ_RX_EV_PKT_TYPE_LLC 1
+#define	FSE_AZ_RX_EV_PKT_TYPE_ETH 0
+#define	FSF_AZ_RX_EV_HDR_TYPE_LBN 42
+#define	FSF_AZ_RX_EV_HDR_TYPE_WIDTH 2
+#define	FSE_AZ_RX_EV_HDR_TYPE_OTHER 3
+#define	FSE_AB_RX_EV_HDR_TYPE_IPV4_OTHER 2
+#define	FSE_CZ_RX_EV_HDR_TYPE_IPV4V6_OTHER 2
+#define	FSE_AB_RX_EV_HDR_TYPE_IPV4_UDP 1
+#define	FSE_CZ_RX_EV_HDR_TYPE_IPV4V6_UDP 1
+#define	FSE_AB_RX_EV_HDR_TYPE_IPV4_TCP 0
+#define	FSE_CZ_RX_EV_HDR_TYPE_IPV4V6_TCP 0
+#define	FSF_AZ_RX_EV_DESC_Q_EMPTY_LBN 41
+#define	FSF_AZ_RX_EV_DESC_Q_EMPTY_WIDTH 1
+#define	FSF_AZ_RX_EV_MCAST_HASH_MATCH_LBN 40
+#define	FSF_AZ_RX_EV_MCAST_HASH_MATCH_WIDTH 1
+#define	FSF_AZ_RX_EV_MCAST_PKT_LBN 39
+#define	FSF_AZ_RX_EV_MCAST_PKT_WIDTH 1
+#define	FSF_AA_RX_EV_RECOVERY_FLAG_LBN 37
+#define	FSF_AA_RX_EV_RECOVERY_FLAG_WIDTH 1
+#define	FSF_AZ_RX_EV_Q_LABEL_LBN 32
+#define	FSF_AZ_RX_EV_Q_LABEL_WIDTH 5
+#define	FSF_AZ_RX_EV_JUMBO_CONT_LBN 31
+#define	FSF_AZ_RX_EV_JUMBO_CONT_WIDTH 1
+#define	FSF_AZ_RX_EV_PORT_LBN 30
+#define	FSF_AZ_RX_EV_PORT_WIDTH 1
+#define	FSF_AZ_RX_EV_BYTE_CNT_LBN 16
+#define	FSF_AZ_RX_EV_BYTE_CNT_WIDTH 14
+#define	FSF_AZ_RX_EV_SOP_LBN 15
+#define	FSF_AZ_RX_EV_SOP_WIDTH 1
+#define	FSF_AZ_RX_EV_ISCSI_PKT_OK_LBN 14
+#define	FSF_AZ_RX_EV_ISCSI_PKT_OK_WIDTH 1
+#define	FSF_AZ_RX_EV_ISCSI_DDIG_ERR_LBN 13
+#define	FSF_AZ_RX_EV_ISCSI_DDIG_ERR_WIDTH 1
+#define	FSF_AZ_RX_EV_ISCSI_HDIG_ERR_LBN 12
+#define	FSF_AZ_RX_EV_ISCSI_HDIG_ERR_WIDTH 1
+#define	FSF_AZ_RX_EV_DESC_PTR_LBN 0
+#define	FSF_AZ_RX_EV_DESC_PTR_WIDTH 12
+
+/* RX_KER_DESC */
+#define	FSF_AZ_RX_KER_BUF_SIZE_LBN 48
+#define	FSF_AZ_RX_KER_BUF_SIZE_WIDTH 14
+#define	FSF_AZ_RX_KER_BUF_REGION_LBN 46
+#define	FSF_AZ_RX_KER_BUF_REGION_WIDTH 2
+#define	FSF_AZ_RX_KER_BUF_ADDR_LBN 0
+#define	FSF_AZ_RX_KER_BUF_ADDR_WIDTH 46
+
+/* RX_USER_DESC */
+#define	FSF_AZ_RX_USER_2BYTE_OFFSET_LBN 20
+#define	FSF_AZ_RX_USER_2BYTE_OFFSET_WIDTH 12
+#define	FSF_AZ_RX_USER_BUF_ID_LBN 0
+#define	FSF_AZ_RX_USER_BUF_ID_WIDTH 20
+
+/* TX_EV */
+#define	FSF_AZ_TX_EV_PKT_ERR_LBN 38
+#define	FSF_AZ_TX_EV_PKT_ERR_WIDTH 1
+#define	FSF_AZ_TX_EV_PKT_TOO_BIG_LBN 37
+#define	FSF_AZ_TX_EV_PKT_TOO_BIG_WIDTH 1
+#define	FSF_AZ_TX_EV_Q_LABEL_LBN 32
+#define	FSF_AZ_TX_EV_Q_LABEL_WIDTH 5
+#define	FSF_AZ_TX_EV_PORT_LBN 16
+#define	FSF_AZ_TX_EV_PORT_WIDTH 1
+#define	FSF_AZ_TX_EV_WQ_FF_FULL_LBN 15
+#define	FSF_AZ_TX_EV_WQ_FF_FULL_WIDTH 1
+#define	FSF_AZ_TX_EV_BUF_OWNER_ID_ERR_LBN 14
+#define	FSF_AZ_TX_EV_BUF_OWNER_ID_ERR_WIDTH 1
+#define	FSF_AZ_TX_EV_COMP_LBN 12
+#define	FSF_AZ_TX_EV_COMP_WIDTH 1
+#define	FSF_AZ_TX_EV_DESC_PTR_LBN 0
+#define	FSF_AZ_TX_EV_DESC_PTR_WIDTH 12
+
+/* TX_KER_DESC */
+#define	FSF_AZ_TX_KER_CONT_LBN 62
+#define	FSF_AZ_TX_KER_CONT_WIDTH 1
+#define	FSF_AZ_TX_KER_BYTE_COUNT_LBN 48
+#define	FSF_AZ_TX_KER_BYTE_COUNT_WIDTH 14
+#define	FSF_AZ_TX_KER_BUF_REGION_LBN 46
+#define	FSF_AZ_TX_KER_BUF_REGION_WIDTH 2
+#define	FSF_AZ_TX_KER_BUF_ADDR_LBN 0
+#define	FSF_AZ_TX_KER_BUF_ADDR_WIDTH 46
+
+/* TX_USER_DESC */
+#define	FSF_AZ_TX_USER_SW_EV_EN_LBN 48
+#define	FSF_AZ_TX_USER_SW_EV_EN_WIDTH 1
+#define	FSF_AZ_TX_USER_CONT_LBN 46
+#define	FSF_AZ_TX_USER_CONT_WIDTH 1
+#define	FSF_AZ_TX_USER_BYTE_CNT_LBN 33
+#define	FSF_AZ_TX_USER_BYTE_CNT_WIDTH 13
+#define	FSF_AZ_TX_USER_BUF_ID_LBN 13
+#define	FSF_AZ_TX_USER_BUF_ID_WIDTH 20
+#define	FSF_AZ_TX_USER_BYTE_OFS_LBN 0
+#define	FSF_AZ_TX_USER_BYTE_OFS_WIDTH 13
+
+/* USER_EV */
+#define	FSF_CZ_USER_QID_LBN 32
+#define	FSF_CZ_USER_QID_WIDTH 10
+#define	FSF_CZ_USER_EV_REG_VALUE_LBN 0
+#define	FSF_CZ_USER_EV_REG_VALUE_WIDTH 32
+
+/**************************************************************************
+ *
+ * Falcon B0 PCIe core indirect registers
+ *
+ **************************************************************************
+ */
+
+#define FPCR_BB_PCIE_DEVICE_CTRL_STAT 0x68
+
+#define FPCR_BB_PCIE_LINK_CTRL_STAT 0x70
+
+#define FPCR_BB_ACK_RPL_TIMER 0x700
+#define FPCRF_BB_ACK_TL_LBN 0
+#define FPCRF_BB_ACK_TL_WIDTH 16
+#define FPCRF_BB_RPL_TL_LBN 16
+#define FPCRF_BB_RPL_TL_WIDTH 16
+
+#define FPCR_BB_ACK_FREQ 0x70C
+#define FPCRF_BB_ACK_FREQ_LBN 0
+#define FPCRF_BB_ACK_FREQ_WIDTH 7
+
+/**************************************************************************
+ *
+ * Pseudo-registers and fields
+ *
+ **************************************************************************
+ */
+
+/* Interrupt acknowledge work-around register (A0/A1 only) */
+#define FR_AA_WORK_AROUND_BROKEN_PCI_READS 0x0070
+
+/* EE_SPI_HCMD_REG: SPI host command register */
+/* Values for the EE_SPI_HCMD_SF_SEL register field */
+#define FFE_AB_SPI_DEVICE_EEPROM 0
+#define FFE_AB_SPI_DEVICE_FLASH 1
+
+/* NIC_STAT_REG: NIC status register */
+#define FRF_AB_STRAP_10G_LBN 2
+#define FRF_AB_STRAP_10G_WIDTH 1
+#define FRF_AA_STRAP_PCIE_LBN 0
+#define FRF_AA_STRAP_PCIE_WIDTH 1
+
+/* FATAL_INTR_REG_KER: Fatal interrupt register for Kernel */
+#define FRF_AZ_FATAL_INTR_LBN 0
+#define FRF_AZ_FATAL_INTR_WIDTH 12
+
+/* SRM_CFG_REG: SRAM configuration register */
+/* We treat the number of SRAM banks and bank size as a single field */
+#define	FRF_AZ_SRM_NB_SZ_LBN FRF_AZ_SRM_BANK_SIZE_LBN
+#define	FRF_AZ_SRM_NB_SZ_WIDTH \
+	(FRF_AZ_SRM_BANK_SIZE_WIDTH + FRF_AZ_SRM_NUM_BANK_WIDTH)
+#define FFE_AB_SRM_NB1_SZ2M 0
+#define FFE_AB_SRM_NB1_SZ4M 1
+#define FFE_AB_SRM_NB1_SZ8M 2
+#define FFE_AB_SRM_NB_SZ_DEF 3
+#define FFE_AB_SRM_NB2_SZ4M 4
+#define FFE_AB_SRM_NB2_SZ8M 5
+#define FFE_AB_SRM_NB2_SZ16M 6
+#define FFE_AB_SRM_NB_SZ_RES 7
+
+/* RX_DESC_UPD_REGP0: Receive descriptor update register. */
+/* We write just the last dword of these registers */
+#define	FR_AZ_RX_DESC_UPD_DWORD_P0 \
+	(BUILD_BUG_ON_ZERO(FR_AA_RX_DESC_UPD_KER != FR_BZ_RX_DESC_UPD_P0) + \
+	 FR_BZ_RX_DESC_UPD_P0 + 3 * 4)
+#define	FRF_AZ_RX_DESC_WPTR_DWORD_LBN (FRF_AZ_RX_DESC_WPTR_LBN - 3 * 32)
+#define	FRF_AZ_RX_DESC_WPTR_DWORD_WIDTH FRF_AZ_RX_DESC_WPTR_WIDTH
+
+/* TX_DESC_UPD_REGP0: Transmit descriptor update register. */
+#define FR_AZ_TX_DESC_UPD_DWORD_P0 \
+	(BUILD_BUG_ON_ZERO(FR_AA_TX_DESC_UPD_KER != FR_BZ_TX_DESC_UPD_P0) + \
+	 FR_BZ_TX_DESC_UPD_P0 + 3 * 4)
+#define	FRF_AZ_TX_DESC_WPTR_DWORD_LBN (FRF_AZ_TX_DESC_WPTR_LBN - 3 * 32)
+#define	FRF_AZ_TX_DESC_WPTR_DWORD_WIDTH FRF_AZ_TX_DESC_WPTR_WIDTH
+
+/* GMF_CFG4_REG: GMAC FIFO configuration register 4 */
+#define FRF_AB_GMF_HSTFLTRFRM_PAUSE_LBN 12
+#define FRF_AB_GMF_HSTFLTRFRM_PAUSE_WIDTH 1
+
+/* GMF_CFG5_REG: GMAC FIFO configuration register 5 */
+#define FRF_AB_GMF_HSTFLTRFRMDC_PAUSE_LBN 12
+#define FRF_AB_GMF_HSTFLTRFRMDC_PAUSE_WIDTH 1
+
+/* XM_TX_PARAM_REG: XGMAC transmit parameter register */
+#define	FRF_AB_XM_MAX_TX_FRM_SIZE_LBN FRF_AB_XM_MAX_TX_FRM_SIZE_LO_LBN
+#define	FRF_AB_XM_MAX_TX_FRM_SIZE_WIDTH (FRF_AB_XM_MAX_TX_FRM_SIZE_HI_WIDTH + \
+					 FRF_AB_XM_MAX_TX_FRM_SIZE_LO_WIDTH)
+
+/* XM_RX_PARAM_REG: XGMAC receive parameter register */
+#define	FRF_AB_XM_MAX_RX_FRM_SIZE_LBN FRF_AB_XM_MAX_RX_FRM_SIZE_LO_LBN
+#define	FRF_AB_XM_MAX_RX_FRM_SIZE_WIDTH (FRF_AB_XM_MAX_RX_FRM_SIZE_HI_WIDTH + \
+					 FRF_AB_XM_MAX_RX_FRM_SIZE_LO_WIDTH)
+
+/* XX_TXDRV_CTL_REG: XAUI SerDes transmit drive control register */
+/* Default values */
+#define FFE_AB_XX_TXDRV_DEQ_DEF 0xe /* deq=.6 */
+#define FFE_AB_XX_TXDRV_DTX_DEF 0x5 /* 1.25 */
+#define FFE_AB_XX_SD_CTL_DRV_DEF 0  /* 20mA */
+
+/* XX_CORE_STAT_REG: XAUI XGXS core status register */
+/* XGXS all-lanes status fields */
+#define	FRF_AB_XX_SYNC_STAT_LBN FRF_AB_XX_SYNC_STAT0_LBN
+#define	FRF_AB_XX_SYNC_STAT_WIDTH 4
+#define	FRF_AB_XX_COMMA_DET_LBN FRF_AB_XX_COMMA_DET_CH0_LBN
+#define	FRF_AB_XX_COMMA_DET_WIDTH 4
+#define	FRF_AB_XX_CHAR_ERR_LBN FRF_AB_XX_CHAR_ERR_CH0_LBN
+#define	FRF_AB_XX_CHAR_ERR_WIDTH 4
+#define	FRF_AB_XX_DISPERR_LBN FRF_AB_XX_DISPERR_CH0_LBN
+#define	FRF_AB_XX_DISPERR_WIDTH 4
+#define	FFE_AB_XX_STAT_ALL_LANES 0xf
+#define	FRF_AB_XX_FORCE_SIG_LBN FRF_AB_XX_FORCE_SIG0_VAL_LBN
+#define	FRF_AB_XX_FORCE_SIG_WIDTH 8
+#define	FFE_AB_XX_FORCE_SIG_ALL_LANES 0xff
+
+/* RX_MAC_FILTER_TBL0 */
+/* RMFT_DEST_MAC is wider than 32 bits */
+#define FRF_CZ_RMFT_DEST_MAC_LO_LBN 12
+#define FRF_CZ_RMFT_DEST_MAC_LO_WIDTH 32
+#define FRF_CZ_RMFT_DEST_MAC_HI_LBN 44
+#define FRF_CZ_RMFT_DEST_MAC_HI_WIDTH 16
+
+/* TX_MAC_FILTER_TBL0 */
+/* TMFT_SRC_MAC is wider than 32 bits */
+#define FRF_CZ_TMFT_SRC_MAC_LO_LBN 12
+#define FRF_CZ_TMFT_SRC_MAC_LO_WIDTH 32
+#define FRF_CZ_TMFT_SRC_MAC_HI_LBN 44
+#define FRF_CZ_TMFT_SRC_MAC_HI_WIDTH 16
+
+/* DRIVER_EV */
+/* Sub-fields of an RX flush completion event */
+#define FSF_AZ_DRIVER_EV_RX_FLUSH_FAIL_LBN 12
+#define FSF_AZ_DRIVER_EV_RX_FLUSH_FAIL_WIDTH 1
+#define FSF_AZ_DRIVER_EV_RX_DESCQ_ID_LBN 0
+#define FSF_AZ_DRIVER_EV_RX_DESCQ_ID_WIDTH 12
+
+/* EVENT_ENTRY */
+/* Magic number field for event test */
+#define FSF_AZ_DRV_GEN_EV_MAGIC_LBN 0
+#define FSF_AZ_DRV_GEN_EV_MAGIC_WIDTH 32
+
+/**************************************************************************
+ *
+ * Falcon MAC stats
+ *
+ **************************************************************************
+ *
+ */
+
+#define GRxGoodOct_offset 0x0
+#define GRxGoodOct_WIDTH 48
+#define GRxBadOct_offset 0x8
+#define GRxBadOct_WIDTH 48
+#define GRxMissPkt_offset 0x10
+#define GRxMissPkt_WIDTH 32
+#define GRxFalseCRS_offset 0x14
+#define GRxFalseCRS_WIDTH 32
+#define GRxPausePkt_offset 0x18
+#define GRxPausePkt_WIDTH 32
+#define GRxBadPkt_offset 0x1C
+#define GRxBadPkt_WIDTH 32
+#define GRxUcastPkt_offset 0x20
+#define GRxUcastPkt_WIDTH 32
+#define GRxMcastPkt_offset 0x24
+#define GRxMcastPkt_WIDTH 32
+#define GRxBcastPkt_offset 0x28
+#define GRxBcastPkt_WIDTH 32
+#define GRxGoodLt64Pkt_offset 0x2C
+#define GRxGoodLt64Pkt_WIDTH 32
+#define GRxBadLt64Pkt_offset 0x30
+#define GRxBadLt64Pkt_WIDTH 32
+#define GRx64Pkt_offset 0x34
+#define GRx64Pkt_WIDTH 32
+#define GRx65to127Pkt_offset 0x38
+#define GRx65to127Pkt_WIDTH 32
+#define GRx128to255Pkt_offset 0x3C
+#define GRx128to255Pkt_WIDTH 32
+#define GRx256to511Pkt_offset 0x40
+#define GRx256to511Pkt_WIDTH 32
+#define GRx512to1023Pkt_offset 0x44
+#define GRx512to1023Pkt_WIDTH 32
+#define GRx1024to15xxPkt_offset 0x48
+#define GRx1024to15xxPkt_WIDTH 32
+#define GRx15xxtoJumboPkt_offset 0x4C
+#define GRx15xxtoJumboPkt_WIDTH 32
+#define GRxGtJumboPkt_offset 0x50
+#define GRxGtJumboPkt_WIDTH 32
+#define GRxFcsErr64to15xxPkt_offset 0x54
+#define GRxFcsErr64to15xxPkt_WIDTH 32
+#define GRxFcsErr15xxtoJumboPkt_offset 0x58
+#define GRxFcsErr15xxtoJumboPkt_WIDTH 32
+#define GRxFcsErrGtJumboPkt_offset 0x5C
+#define GRxFcsErrGtJumboPkt_WIDTH 32
+#define GTxGoodBadOct_offset 0x80
+#define GTxGoodBadOct_WIDTH 48
+#define GTxGoodOct_offset 0x88
+#define GTxGoodOct_WIDTH 48
+#define GTxSglColPkt_offset 0x90
+#define GTxSglColPkt_WIDTH 32
+#define GTxMultColPkt_offset 0x94
+#define GTxMultColPkt_WIDTH 32
+#define GTxExColPkt_offset 0x98
+#define GTxExColPkt_WIDTH 32
+#define GTxDefPkt_offset 0x9C
+#define GTxDefPkt_WIDTH 32
+#define GTxLateCol_offset 0xA0
+#define GTxLateCol_WIDTH 32
+#define GTxExDefPkt_offset 0xA4
+#define GTxExDefPkt_WIDTH 32
+#define GTxPausePkt_offset 0xA8
+#define GTxPausePkt_WIDTH 32
+#define GTxBadPkt_offset 0xAC
+#define GTxBadPkt_WIDTH 32
+#define GTxUcastPkt_offset 0xB0
+#define GTxUcastPkt_WIDTH 32
+#define GTxMcastPkt_offset 0xB4
+#define GTxMcastPkt_WIDTH 32
+#define GTxBcastPkt_offset 0xB8
+#define GTxBcastPkt_WIDTH 32
+#define GTxLt64Pkt_offset 0xBC
+#define GTxLt64Pkt_WIDTH 32
+#define GTx64Pkt_offset 0xC0
+#define GTx64Pkt_WIDTH 32
+#define GTx65to127Pkt_offset 0xC4
+#define GTx65to127Pkt_WIDTH 32
+#define GTx128to255Pkt_offset 0xC8
+#define GTx128to255Pkt_WIDTH 32
+#define GTx256to511Pkt_offset 0xCC
+#define GTx256to511Pkt_WIDTH 32
+#define GTx512to1023Pkt_offset 0xD0
+#define GTx512to1023Pkt_WIDTH 32
+#define GTx1024to15xxPkt_offset 0xD4
+#define GTx1024to15xxPkt_WIDTH 32
+#define GTx15xxtoJumboPkt_offset 0xD8
+#define GTx15xxtoJumboPkt_WIDTH 32
+#define GTxGtJumboPkt_offset 0xDC
+#define GTxGtJumboPkt_WIDTH 32
+#define GTxNonTcpUdpPkt_offset 0xE0
+#define GTxNonTcpUdpPkt_WIDTH 16
+#define GTxMacSrcErrPkt_offset 0xE4
+#define GTxMacSrcErrPkt_WIDTH 16
+#define GTxIpSrcErrPkt_offset 0xE8
+#define GTxIpSrcErrPkt_WIDTH 16
+#define GDmaDone_offset 0xEC
+#define GDmaDone_WIDTH 32
+
+#define XgRxOctets_offset 0x0
+#define XgRxOctets_WIDTH 48
+#define XgRxOctetsOK_offset 0x8
+#define XgRxOctetsOK_WIDTH 48
+#define XgRxPkts_offset 0x10
+#define XgRxPkts_WIDTH 32
+#define XgRxPktsOK_offset 0x14
+#define XgRxPktsOK_WIDTH 32
+#define XgRxBroadcastPkts_offset 0x18
+#define XgRxBroadcastPkts_WIDTH 32
+#define XgRxMulticastPkts_offset 0x1C
+#define XgRxMulticastPkts_WIDTH 32
+#define XgRxUnicastPkts_offset 0x20
+#define XgRxUnicastPkts_WIDTH 32
+#define XgRxUndersizePkts_offset 0x24
+#define XgRxUndersizePkts_WIDTH 32
+#define XgRxOversizePkts_offset 0x28
+#define XgRxOversizePkts_WIDTH 32
+#define XgRxJabberPkts_offset 0x2C
+#define XgRxJabberPkts_WIDTH 32
+#define XgRxUndersizeFCSerrorPkts_offset 0x30
+#define XgRxUndersizeFCSerrorPkts_WIDTH 32
+#define XgRxDropEvents_offset 0x34
+#define XgRxDropEvents_WIDTH 32
+#define XgRxFCSerrorPkts_offset 0x38
+#define XgRxFCSerrorPkts_WIDTH 32
+#define XgRxAlignError_offset 0x3C
+#define XgRxAlignError_WIDTH 32
+#define XgRxSymbolError_offset 0x40
+#define XgRxSymbolError_WIDTH 32
+#define XgRxInternalMACError_offset 0x44
+#define XgRxInternalMACError_WIDTH 32
+#define XgRxControlPkts_offset 0x48
+#define XgRxControlPkts_WIDTH 32
+#define XgRxPausePkts_offset 0x4C
+#define XgRxPausePkts_WIDTH 32
+#define XgRxPkts64Octets_offset 0x50
+#define XgRxPkts64Octets_WIDTH 32
+#define XgRxPkts65to127Octets_offset 0x54
+#define XgRxPkts65to127Octets_WIDTH 32
+#define XgRxPkts128to255Octets_offset 0x58
+#define XgRxPkts128to255Octets_WIDTH 32
+#define XgRxPkts256to511Octets_offset 0x5C
+#define XgRxPkts256to511Octets_WIDTH 32
+#define XgRxPkts512to1023Octets_offset 0x60
+#define XgRxPkts512to1023Octets_WIDTH 32
+#define XgRxPkts1024to15xxOctets_offset 0x64
+#define XgRxPkts1024to15xxOctets_WIDTH 32
+#define XgRxPkts15xxtoMaxOctets_offset 0x68
+#define XgRxPkts15xxtoMaxOctets_WIDTH 32
+#define XgRxLengthError_offset 0x6C
+#define XgRxLengthError_WIDTH 32
+#define XgTxPkts_offset 0x80
+#define XgTxPkts_WIDTH 32
+#define XgTxOctets_offset 0x88
+#define XgTxOctets_WIDTH 48
+#define XgTxMulticastPkts_offset 0x90
+#define XgTxMulticastPkts_WIDTH 32
+#define XgTxBroadcastPkts_offset 0x94
+#define XgTxBroadcastPkts_WIDTH 32
+#define XgTxUnicastPkts_offset 0x98
+#define XgTxUnicastPkts_WIDTH 32
+#define XgTxControlPkts_offset 0x9C
+#define XgTxControlPkts_WIDTH 32
+#define XgTxPausePkts_offset 0xA0
+#define XgTxPausePkts_WIDTH 32
+#define XgTxPkts64Octets_offset 0xA4
+#define XgTxPkts64Octets_WIDTH 32
+#define XgTxPkts65to127Octets_offset 0xA8
+#define XgTxPkts65to127Octets_WIDTH 32
+#define XgTxPkts128to255Octets_offset 0xAC
+#define XgTxPkts128to255Octets_WIDTH 32
+#define XgTxPkts256to511Octets_offset 0xB0
+#define XgTxPkts256to511Octets_WIDTH 32
+#define XgTxPkts512to1023Octets_offset 0xB4
+#define XgTxPkts512to1023Octets_WIDTH 32
+#define XgTxPkts1024to15xxOctets_offset 0xB8
+#define XgTxPkts1024to15xxOctets_WIDTH 32
+#define XgTxPkts1519toMaxOctets_offset 0xBC
+#define XgTxPkts1519toMaxOctets_WIDTH 32
+#define XgTxUndersizePkts_offset 0xC0
+#define XgTxUndersizePkts_WIDTH 32
+#define XgTxOversizePkts_offset 0xC4
+#define XgTxOversizePkts_WIDTH 32
+#define XgTxNonTcpUdpPkt_offset 0xC8
+#define XgTxNonTcpUdpPkt_WIDTH 16
+#define XgTxMacSrcErrPkt_offset 0xCC
+#define XgTxMacSrcErrPkt_WIDTH 16
+#define XgTxIpSrcErrPkt_offset 0xD0
+#define XgTxIpSrcErrPkt_WIDTH 16
+#define XgDmaDone_offset 0xD4
+#define XgDmaDone_WIDTH 32
+
+#define FALCON_STATS_NOT_DONE 0x00000000
+#define FALCON_STATS_DONE 0xffffffff
+
+/**************************************************************************
+ *
+ * Falcon non-volatile configuration
+ *
+ **************************************************************************
+ */
+
+/* Board configuration v2 (v1 is obsolete; later versions are compatible) */
+struct falcon_nvconfig_board_v2 {
+	__le16 nports;
+	u8 port0_phy_addr;
+	u8 port0_phy_type;
+	u8 port1_phy_addr;
+	u8 port1_phy_type;
+	__le16 asic_sub_revision;
+	__le16 board_revision;
+} __packed;
+
+/* Board configuration v3 extra information */
+struct falcon_nvconfig_board_v3 {
+	__le32 spi_device_type[2];
+} __packed;
+
+/* Bit numbers for spi_device_type */
+#define SPI_DEV_TYPE_SIZE_LBN 0
+#define SPI_DEV_TYPE_SIZE_WIDTH 5
+#define SPI_DEV_TYPE_ADDR_LEN_LBN 6
+#define SPI_DEV_TYPE_ADDR_LEN_WIDTH 2
+#define SPI_DEV_TYPE_ERASE_CMD_LBN 8
+#define SPI_DEV_TYPE_ERASE_CMD_WIDTH 8
+#define SPI_DEV_TYPE_ERASE_SIZE_LBN 16
+#define SPI_DEV_TYPE_ERASE_SIZE_WIDTH 5
+#define SPI_DEV_TYPE_BLOCK_SIZE_LBN 24
+#define SPI_DEV_TYPE_BLOCK_SIZE_WIDTH 5
+#define SPI_DEV_TYPE_FIELD(type, field)					\
+	(((type) >> EFX_LOW_BIT(field)) & EFX_MASK32(EFX_WIDTH(field)))
+
+#define FALCON_NVCONFIG_OFFSET 0x300
+
+#define FALCON_NVCONFIG_BOARD_MAGIC_NUM 0xFA1C
+struct falcon_nvconfig {
+	efx_oword_t ee_vpd_cfg_reg;			/* 0x300 */
+	u8 mac_address[2][8];			/* 0x310 */
+	efx_oword_t pcie_sd_ctl0123_reg;		/* 0x320 */
+	efx_oword_t pcie_sd_ctl45_reg;			/* 0x330 */
+	efx_oword_t pcie_pcs_ctl_stat_reg;		/* 0x340 */
+	efx_oword_t hw_init_reg;			/* 0x350 */
+	efx_oword_t nic_stat_reg;			/* 0x360 */
+	efx_oword_t glb_ctl_reg;			/* 0x370 */
+	efx_oword_t srm_cfg_reg;			/* 0x380 */
+	efx_oword_t spare_reg;				/* 0x390 */
+	__le16 board_magic_num;			/* 0x3A0 */
+	__le16 board_struct_ver;
+	__le16 board_checksum;
+	struct falcon_nvconfig_board_v2 board_v2;
+	efx_oword_t ee_base_page_reg;			/* 0x3B0 */
+	struct falcon_nvconfig_board_v3 board_v3;	/* 0x3C0 */
+} __packed;
+
+#endif /* EFX_REGS_H */
diff -r 5b3d4d3c1166 drivers/net/sfc/rx.c
--- a/drivers/net/sfc/rx.c	Fri Nov 05 15:20:28 2010 +0000
+++ b/drivers/net/sfc/rx.c	Tue Nov 09 10:06:27 2010 +0000
@@ -1,7 +1,7 @@
 /****************************************************************************
  * Driver for Solarflare Solarstorm network controllers and boards
  * Copyright 2005-2006 Fen Systems Ltd.
- * Copyright 2005-2008 Solarflare Communications Inc.
+ * Copyright 2005-2009 Solarflare Communications Inc.
  *
  * This program is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 as published
@@ -10,20 +10,31 @@
 
 #include <linux/socket.h>
 #include <linux/in.h>
+#include <linux/slab.h>
 #include <linux/ip.h>
 #include <linux/tcp.h>
 #include <linux/udp.h>
 #include <net/ip.h>
+#include <net/tcp.h>
 #include <net/checksum.h>
+#ifdef EFX_NOT_UPSTREAM
+#include <linux/ipv6.h>
+#include <net/ipv6.h>
+#endif
 #include "net_driver.h"
-#include "rx.h"
 #include "efx.h"
-#include "falcon.h"
+#include "nic.h"
 #include "selftest.h"
 #include "workarounds.h"
+#if defined (EFX_NOT_UPSTREAM) && defined(EFX_WITH_VMWARE_NETQ)
+#include "efx_netq.h"
+#endif
 
 /* Number of RX descriptors pushed at once. */
 #define EFX_RX_BATCH  8
+
+/* Maximum size of a buffer sharing a page */
+#define EFX_RX_HALF_PAGE ((PAGE_SIZE >> 1) - sizeof(struct efx_rx_page_state))
 
 /* Size of buffer allocated for skb header area. */
 #define EFX_SKB_HEADERS  64u
@@ -61,7 +72,15 @@
  *   rx_alloc_method = (rx_alloc_level > RX_ALLOC_LEVEL_LRO ?
  *                      RX_ALLOC_METHOD_PAGE : RX_ALLOC_METHOD_SKB)
  */
+#if !defined(EFX_USE_KCOMPAT) || defined(EFX_USE_GRO) || defined(EFX_HAVE_DEV_DISABLE_LRO)
+static int rx_alloc_method = RX_ALLOC_METHOD_AUTO;
+#else
+/* LRO using SKB chaining will cause a BUG() if bridging is used. This was
+ * fixed by GRO, and worked around by dev_disable_lro(). Change the default
+ * to avoid the BUG(), but allow the user to override this.
+ */
 static int rx_alloc_method = RX_ALLOC_METHOD_PAGE;
+#endif
 
 #define RX_ALLOC_LEVEL_LRO 0x2000
 #define RX_ALLOC_LEVEL_MAX 0x3000
@@ -86,169 +105,179 @@ static unsigned int rx_refill_limit = 95
  */
 #define EFX_RXD_HEAD_ROOM 2
 
-static inline unsigned int efx_rx_buf_offset(struct efx_rx_buffer *buf)
+/* Offset of ethernet header within page */
+static inline unsigned int efx_rx_buf_offset(struct efx_nic *efx,
+					     struct efx_rx_buffer *buf)
 {
 	/* Offset is always within one page, so we don't need to consider
 	 * the page order.
 	 */
-	return (__force unsigned long) buf->data & (PAGE_SIZE - 1);
+	return (((__force unsigned long) buf->dma_addr & (PAGE_SIZE - 1)) +
+		efx->type->rx_buffer_hash_size);
 }
 static inline unsigned int efx_rx_buf_size(struct efx_nic *efx)
 {
 	return PAGE_SIZE << efx->rx_buffer_order;
 }
 
+static u8 *efx_rx_buf_eh(struct efx_nic *efx, struct efx_rx_buffer *buf)
+{
+	if (buf->is_page)
+		return page_address(buf->u.page) + efx_rx_buf_offset(efx, buf);
+	else
+		return ((u8 *)buf->u.skb->data +
+			efx->type->rx_buffer_hash_size);
+}
+
+static inline u32 efx_rx_buf_hash(const u8 *eh)
+{
+	/* The ethernet header is always directly after any hash. */
+#if defined(CONFIG_HAVE_EFFICIENT_UNALIGNED_ACCESS) || NET_IP_ALIGN % 4 == 0
+	return __le32_to_cpup((const __le32 *)(eh - 4));
+#else
+	const u8 *data = eh - 4;
+	return ((u32)data[0]       |
+		(u32)data[1] << 8  |
+		(u32)data[2] << 16 |
+		(u32)data[3] << 24);
+#endif
+}
 
 /**
- * efx_init_rx_buffer_skb - create new RX buffer using skb-based allocation
+ * efx_init_rx_buffers_skb - create EFX_RX_BATCH skb-based RX buffers
  *
  * @rx_queue:		Efx RX queue
- * @rx_buf:		RX buffer structure to populate
  *
- * This allocates memory for a new receive buffer, maps it for DMA,
- * and populates a struct efx_rx_buffer with the relevant
- * information.  Return a negative error code or 0 on success.
+ * This allocates EFX_RX_BATCH skbs, maps them for DMA, and populates a
+ * struct efx_rx_buffer for each one. Return a negative error code or 0
+ * on success. May fail having only inserted fewer than EFX_RX_BATCH
+ * buffers.
  */
-static int efx_init_rx_buffer_skb(struct efx_rx_queue *rx_queue,
-				  struct efx_rx_buffer *rx_buf)
+static int efx_init_rx_buffers_skb(struct efx_rx_queue *rx_queue)
 {
 	struct efx_nic *efx = rx_queue->efx;
 	struct net_device *net_dev = efx->net_dev;
+	struct efx_rx_buffer *rx_buf;
+	struct sk_buff *skb;
 	int skb_len = efx->rx_buffer_len;
+	unsigned index, count;
 
-	rx_buf->skb = netdev_alloc_skb(net_dev, skb_len);
-	if (unlikely(!rx_buf->skb))
-		return -ENOMEM;
+	for (count = 0; count < EFX_RX_BATCH; ++count) {
+		index = rx_queue->added_count & rx_queue->ptr_mask;
+		rx_buf = efx_rx_buffer(rx_queue, index);
 
-	/* Adjust the SKB for padding and checksum */
-	skb_reserve(rx_buf->skb, NET_IP_ALIGN);
-	rx_buf->len = skb_len - NET_IP_ALIGN;
-	rx_buf->data = (char *)rx_buf->skb->data;
-	rx_buf->skb->ip_summed = CHECKSUM_UNNECESSARY;
+		rx_buf->u.skb = skb = netdev_alloc_skb(net_dev, skb_len);
+		if (unlikely(!skb))
+			return -ENOMEM;
 
-	rx_buf->dma_addr = pci_map_single(efx->pci_dev,
-					  rx_buf->data, rx_buf->len,
-					  PCI_DMA_FROMDEVICE);
+		/* Adjust the SKB for padding and checksum */
+		skb_reserve(skb, NET_IP_ALIGN);
+		rx_buf->len = skb_len - NET_IP_ALIGN;
+		rx_buf->is_page = false;
+		skb->ip_summed = CHECKSUM_UNNECESSARY;
 
-	if (unlikely(pci_dma_mapping_error(efx->pci_dev, rx_buf->dma_addr))) {
-		dev_kfree_skb_any(rx_buf->skb);
-		rx_buf->skb = NULL;
-		return -EIO;
+#if defined(EFX_NOT_UPSTREAM) && defined(EFX_VMWARE_3_DOT_5)
+		rx_buf->dma_addr = skb->headMA;
+#else
+		rx_buf->dma_addr = pci_map_single(efx->pci_dev,
+						  skb->data, rx_buf->len,
+						  PCI_DMA_FROMDEVICE);
+#endif
+		if (unlikely(pci_dma_mapping_error(efx->pci_dev,
+						   rx_buf->dma_addr))) {
+			dev_kfree_skb_any(skb);
+			rx_buf->u.skb = NULL;
+			return -EIO;
+		}
+
+		++rx_queue->added_count;
+		++rx_queue->alloc_skb_count;
 	}
 
 	return 0;
 }
 
 /**
- * efx_init_rx_buffer_page - create new RX buffer using page-based allocation
+ * efx_init_rx_buffers_page - create EFX_RX_BATCH page-based RX buffers
  *
  * @rx_queue:		Efx RX queue
- * @rx_buf:		RX buffer structure to populate
  *
- * This allocates memory for a new receive buffer, maps it for DMA,
- * and populates a struct efx_rx_buffer with the relevant
- * information.  Return a negative error code or 0 on success.
+ * This allocates memory for EFX_RX_BATCH receive buffers, maps them for DMA,
+ * and populates struct efx_rx_buffers for each one. Return a negative error
+ * code or 0 on success. If a single page can be split between two buffers,
+ * then the page will either be inserted fully, or not at at all.
  */
-static int efx_init_rx_buffer_page(struct efx_rx_queue *rx_queue,
-				   struct efx_rx_buffer *rx_buf)
+static int efx_init_rx_buffers_page(struct efx_rx_queue *rx_queue)
 {
 	struct efx_nic *efx = rx_queue->efx;
-	int bytes, space, offset;
+	struct efx_rx_buffer *rx_buf;
+	struct page *page;
+	void *page_addr;
+	struct efx_rx_page_state *state;
+	dma_addr_t dma_addr;
+	unsigned index, count;
 
-	bytes = efx->rx_buffer_len - EFX_PAGE_IP_ALIGN;
+	/* We can split a page between two buffers */
+	BUILD_BUG_ON(EFX_RX_BATCH & 1);
 
-	/* If there is space left in the previously allocated page,
-	 * then use it. Otherwise allocate a new one */
-	rx_buf->page = rx_queue->buf_page;
-	if (rx_buf->page == NULL) {
-		dma_addr_t dma_addr;
-
-		rx_buf->page = alloc_pages(__GFP_COLD | __GFP_COMP | GFP_ATOMIC,
-					   efx->rx_buffer_order);
-		if (unlikely(rx_buf->page == NULL))
+	for (count = 0; count < EFX_RX_BATCH; ++count) {
+		page = alloc_pages(__GFP_COLD | __GFP_COMP | GFP_ATOMIC,
+				   efx->rx_buffer_order);
+		if (unlikely(page == NULL))
 			return -ENOMEM;
-
-		dma_addr = pci_map_page(efx->pci_dev, rx_buf->page,
-					0, efx_rx_buf_size(efx),
+		dma_addr = pci_map_page(efx->pci_dev, page, 0,
+					efx_rx_buf_size(efx),
 					PCI_DMA_FROMDEVICE);
-
 		if (unlikely(pci_dma_mapping_error(efx->pci_dev, dma_addr))) {
-			__free_pages(rx_buf->page, efx->rx_buffer_order);
-			rx_buf->page = NULL;
+			__free_pages(page, efx->rx_buffer_order);
 			return -EIO;
 		}
+		page_addr = page_address(page);
+		state = page_addr;
+		state->refcnt = 0;
+		state->dma_addr = dma_addr;
 
-		rx_queue->buf_page = rx_buf->page;
-		rx_queue->buf_dma_addr = dma_addr;
-		rx_queue->buf_data = (page_address(rx_buf->page) +
-				      EFX_PAGE_IP_ALIGN);
-	}
+		page_addr += sizeof(struct efx_rx_page_state);
+		dma_addr += sizeof(struct efx_rx_page_state);
 
-	rx_buf->len = bytes;
-	rx_buf->data = rx_queue->buf_data;
-	offset = efx_rx_buf_offset(rx_buf);
-	rx_buf->dma_addr = rx_queue->buf_dma_addr + offset;
+	split:
+		index = rx_queue->added_count & rx_queue->ptr_mask;
+		rx_buf = efx_rx_buffer(rx_queue, index);
+		rx_buf->dma_addr = dma_addr + EFX_PAGE_IP_ALIGN;
+		rx_buf->u.page = page;
+		rx_buf->len = efx->rx_buffer_len - EFX_PAGE_IP_ALIGN;
+		rx_buf->is_page = true;
+		++rx_queue->added_count;
+		++rx_queue->alloc_page_count;
+		++state->refcnt;
 
-	/* Try to pack multiple buffers per page */
-	if (efx->rx_buffer_order == 0) {
-		/* The next buffer starts on the next 512 byte boundary */
-		rx_queue->buf_data += ((bytes + 0x1ff) & ~0x1ff);
-		offset += ((bytes + 0x1ff) & ~0x1ff);
-
-		space = efx_rx_buf_size(efx) - offset;
-		if (space >= bytes) {
-			/* Refs dropped on kernel releasing each skb */
-			get_page(rx_queue->buf_page);
-			goto out;
+		if ((~count & 1) && (efx->rx_buffer_len <= EFX_RX_HALF_PAGE)) {
+			/* Use the second half of the page */
+			get_page(page);
+			dma_addr += (PAGE_SIZE >> 1);
+			page_addr += (PAGE_SIZE >> 1);
+			++count;
+			goto split;
 		}
 	}
 
-	/* This is the final RX buffer for this page, so mark it for
-	 * unmapping */
-	rx_queue->buf_page = NULL;
-	rx_buf->unmap_addr = rx_queue->buf_dma_addr;
-
- out:
 	return 0;
-}
-
-/* This allocates memory for a new receive buffer, maps it for DMA,
- * and populates a struct efx_rx_buffer with the relevant
- * information.
- */
-static int efx_init_rx_buffer(struct efx_rx_queue *rx_queue,
-			      struct efx_rx_buffer *new_rx_buf)
-{
-	int rc = 0;
-
-	if (rx_queue->channel->rx_alloc_push_pages) {
-		new_rx_buf->skb = NULL;
-		rc = efx_init_rx_buffer_page(rx_queue, new_rx_buf);
-		rx_queue->alloc_page_count++;
-	} else {
-		new_rx_buf->page = NULL;
-		rc = efx_init_rx_buffer_skb(rx_queue, new_rx_buf);
-		rx_queue->alloc_skb_count++;
-	}
-
-	if (unlikely(rc < 0))
-		EFX_LOG_RL(rx_queue->efx, "%s RXQ[%d] =%d\n", __func__,
-			   rx_queue->queue, rc);
-	return rc;
 }
 
 static void efx_unmap_rx_buffer(struct efx_nic *efx,
 				struct efx_rx_buffer *rx_buf)
 {
-	if (rx_buf->page) {
-		EFX_BUG_ON_PARANOID(rx_buf->skb);
-		if (rx_buf->unmap_addr) {
-			pci_unmap_page(efx->pci_dev, rx_buf->unmap_addr,
+	if (rx_buf->is_page && rx_buf->u.page) {
+		struct efx_rx_page_state *state;
+
+		state = page_address(rx_buf->u.page);
+		if (--state->refcnt == 0) {
+			pci_unmap_page(efx->pci_dev,
+				       state->dma_addr,
 				       efx_rx_buf_size(efx),
 				       PCI_DMA_FROMDEVICE);
-			rx_buf->unmap_addr = 0;
 		}
-	} else if (likely(rx_buf->skb)) {
+	} else if (!rx_buf->is_page && rx_buf->u.skb) {
 		pci_unmap_single(efx->pci_dev, rx_buf->dma_addr,
 				 rx_buf->len, PCI_DMA_FROMDEVICE);
 	}
@@ -257,12 +286,12 @@ static void efx_free_rx_buffer(struct ef
 static void efx_free_rx_buffer(struct efx_nic *efx,
 			       struct efx_rx_buffer *rx_buf)
 {
-	if (rx_buf->page) {
-		__free_pages(rx_buf->page, efx->rx_buffer_order);
-		rx_buf->page = NULL;
-	} else if (likely(rx_buf->skb)) {
-		dev_kfree_skb_any(rx_buf->skb);
-		rx_buf->skb = NULL;
+	if (rx_buf->is_page && rx_buf->u.page) {
+		__free_pages(rx_buf->u.page, efx->rx_buffer_order);
+		rx_buf->u.page = NULL;
+	} else if (!rx_buf->is_page && rx_buf->u.skb) {
+		dev_kfree_skb_any(rx_buf->u.skb);
+		rx_buf->u.skb = NULL;
 	}
 }
 
@@ -273,32 +302,85 @@ static void efx_fini_rx_buffer(struct ef
 	efx_free_rx_buffer(rx_queue->efx, rx_buf);
 }
 
+/* Attempt to resurrect the other receive buffer that used to share this page,
+ * which had previously been passed up to the kernel and freed. */
+static void efx_resurrect_rx_buffer(struct efx_rx_queue *rx_queue,
+				    struct efx_rx_buffer *rx_buf)
+{
+	struct efx_rx_page_state *state = page_address(rx_buf->u.page);
+	struct efx_rx_buffer *new_buf;
+	unsigned fill_level, index;
+
+	/* +1 because efx_rx_packet() incremented removed_count. +1 because
+	 * we'd like to insert an additional descriptor whilst leaving
+	 * EFX_RXD_HEAD_ROOM for the non-recycle path */
+	fill_level = (rx_queue->added_count - rx_queue->removed_count + 2);
+	if (unlikely(fill_level > rx_queue->max_fill)) {
+		/* We could place "state" on a list, and drain the list in
+		 * efx_fast_push_rx_descriptors(). For now, this will do. */
+		++rx_queue->resurrect_failed_count;
+		return;
+	}
+
+	++state->refcnt;
+	get_page(rx_buf->u.page);
+
+	index = rx_queue->added_count & rx_queue->ptr_mask;
+	new_buf = efx_rx_buffer(rx_queue, index);
+	new_buf->dma_addr = rx_buf->dma_addr ^ (PAGE_SIZE >> 1);
+	new_buf->u.page = rx_buf->u.page;
+	new_buf->len = rx_buf->len;
+	new_buf->is_page = true;
+	++rx_queue->added_count;
+	++rx_queue->recycle_count;
+	++rx_queue->resurrect_count;
+}
+
+/* Recycle the given rx buffer directly back into the rx_queue. There is
+ * always room to add this buffer, because we've just popped a buffer. */
+static void efx_recycle_rx_buffer(struct efx_channel *channel,
+				  struct efx_rx_buffer *rx_buf)
+{
+	struct efx_nic *efx = channel->efx;
+	struct efx_rx_queue *rx_queue = efx_channel_get_rx_queue(channel);
+	struct efx_rx_buffer *new_buf;
+	unsigned index;
+
+	if (rx_buf->is_page && efx->rx_buffer_len <= EFX_RX_HALF_PAGE &&
+	    page_count(rx_buf->u.page) == 1)
+		efx_resurrect_rx_buffer(rx_queue, rx_buf);
+
+	index = rx_queue->added_count & rx_queue->ptr_mask;
+	new_buf = efx_rx_buffer(rx_queue, index);
+
+	memcpy(new_buf, rx_buf, sizeof(*new_buf));
+	rx_buf->u.page = NULL;
+	++rx_queue->added_count;
+	++rx_queue->recycle_count;
+}
+
 /**
  * efx_fast_push_rx_descriptors - push new RX descriptors quickly
  * @rx_queue:		RX descriptor queue
- * @retry:              Recheck the fill level
  * This will aim to fill the RX descriptor queue up to
  * @rx_queue->@fast_fill_limit. If there is insufficient atomic
- * memory to do so, the caller should retry.
+ * memory to do so, a slow fill will be scheduled.
+ *
+ * The caller must provide serialisation (none is used here). In practise,
+ * this means this function must run from the NAPI handler, or be called
+ * when NAPI is disabled.
  */
-static int __efx_fast_push_rx_descriptors(struct efx_rx_queue *rx_queue,
-					  int retry)
+void efx_fast_push_rx_descriptors(struct efx_rx_queue *rx_queue)
 {
-	struct efx_rx_buffer *rx_buf;
-	unsigned fill_level, index;
-	int i, space, rc = 0;
+	struct efx_channel *channel = efx_rx_queue_channel(rx_queue);
+	unsigned fill_level;
+	int space, rc = 0;
 
-	/* Calculate current fill level.  Do this outside the lock,
-	 * because most of the time we'll end up not wanting to do the
-	 * fill anyway.
-	 */
+	/* Calculate current fill level, and exit if we don't need to fill */
 	fill_level = (rx_queue->added_count - rx_queue->removed_count);
-	EFX_BUG_ON_PARANOID(fill_level >
-			    rx_queue->efx->type->rxd_ring_mask + 1);
-
-	/* Don't fill if we don't need to */
+	EFX_BUG_ON_PARANOID(fill_level > rx_queue->efx->rxq_entries);
 	if (fill_level >= rx_queue->fast_fill_trigger)
-		return 0;
+		goto out;
 
 	/* Record minimum fill level */
 	if (unlikely(fill_level < rx_queue->min_fill)) {
@@ -306,101 +388,48 @@ static int __efx_fast_push_rx_descriptor
 			rx_queue->min_fill = fill_level;
 	}
 
-	/* Acquire RX add lock.  If this lock is contended, then a fast
-	 * fill must already be in progress (e.g. in the refill
-	 * tasklet), so we don't need to do anything
-	 */
-	if (!spin_trylock_bh(&rx_queue->add_lock))
-		return -1;
-
- retry:
-	/* Recalculate current fill level now that we have the lock */
-	fill_level = (rx_queue->added_count - rx_queue->removed_count);
-	EFX_BUG_ON_PARANOID(fill_level >
-			    rx_queue->efx->type->rxd_ring_mask + 1);
 	space = rx_queue->fast_fill_limit - fill_level;
 	if (space < EFX_RX_BATCH)
-		goto out_unlock;
+		goto out;
 
-	EFX_TRACE(rx_queue->efx, "RX queue %d fast-filling descriptor ring from"
-		  " level %d to level %d using %s allocation\n",
-		  rx_queue->queue, fill_level, rx_queue->fast_fill_limit,
-		  rx_queue->channel->rx_alloc_push_pages ? "page" : "skb");
+	netif_vdbg(rx_queue->efx, rx_status, rx_queue->efx->net_dev,
+		   "RX queue %d fast-filling descriptor ring from"
+		   " level %d to level %d using %s allocation\n",
+		   efx_rx_queue_index(rx_queue), fill_level,
+		   rx_queue->fast_fill_limit,
+		   channel->rx_alloc_push_pages ? "page" : "skb");
 
 	do {
-		for (i = 0; i < EFX_RX_BATCH; ++i) {
-			index = (rx_queue->added_count &
-				 rx_queue->efx->type->rxd_ring_mask);
-			rx_buf = efx_rx_buffer(rx_queue, index);
-			rc = efx_init_rx_buffer(rx_queue, rx_buf);
-			if (unlikely(rc))
-				goto out;
-			++rx_queue->added_count;
+		if (channel->rx_alloc_push_pages)
+			rc = efx_init_rx_buffers_page(rx_queue);
+		else
+			rc = efx_init_rx_buffers_skb(rx_queue);
+		if (unlikely(rc)) {
+			/* Ensure that we don't leave the rx queue empty */
+			if (rx_queue->added_count == rx_queue->removed_count)
+				efx_schedule_slow_fill(rx_queue);
+			goto out;
 		}
 	} while ((space -= EFX_RX_BATCH) >= EFX_RX_BATCH);
 
-	EFX_TRACE(rx_queue->efx, "RX queue %d fast-filled descriptor ring "
-		  "to level %d\n", rx_queue->queue,
-		  rx_queue->added_count - rx_queue->removed_count);
+	netif_vdbg(rx_queue->efx, rx_status, rx_queue->efx->net_dev,
+		   "RX queue %d fast-filled descriptor ring "
+		   "to level %d\n", efx_rx_queue_index(rx_queue),
+		   rx_queue->added_count - rx_queue->removed_count);
 
- out:
-	/* Send write pointer to card. */
-	falcon_notify_rx_desc(rx_queue);
-
-	/* If the fast fill is running inside from the refill tasklet, then
-	 * for SMP systems it may be running on a different CPU to
-	 * RX event processing, which means that the fill level may now be
-	 * out of date. */
-	if (unlikely(retry && (rc == 0)))
-		goto retry;
-
- out_unlock:
-	spin_unlock_bh(&rx_queue->add_lock);
-
-	return rc;
+out:
+	if (rx_queue->notified_count != rx_queue->added_count)
+		efx_nic_notify_rx_desc(rx_queue);
 }
 
-/**
- * efx_fast_push_rx_descriptors - push new RX descriptors quickly
- * @rx_queue:		RX descriptor queue
- *
- * This will aim to fill the RX descriptor queue up to
- * @rx_queue->@fast_fill_limit.  If there is insufficient memory to do so,
- * it will schedule a work item to immediately continue the fast fill
- */
-void efx_fast_push_rx_descriptors(struct efx_rx_queue *rx_queue)
+void efx_rx_slow_fill(unsigned long context)
 {
-	int rc;
+	struct efx_rx_queue *rx_queue = (struct efx_rx_queue *)context;
+	struct efx_channel *channel = efx_rx_queue_channel(rx_queue);
 
-	rc = __efx_fast_push_rx_descriptors(rx_queue, 0);
-	if (unlikely(rc)) {
-		/* Schedule the work item to run immediately. The hope is
-		 * that work is immediately pending to free some memory
-		 * (e.g. an RX event or TX completion)
-		 */
-		efx_schedule_slow_fill(rx_queue, 0);
-	}
-}
-
-void efx_rx_work(struct work_struct *data)
-{
-	struct efx_rx_queue *rx_queue;
-	int rc;
-
-	rx_queue = container_of(data, struct efx_rx_queue, work.work);
-
-	if (unlikely(!rx_queue->channel->enabled))
-		return;
-
-	EFX_TRACE(rx_queue->efx, "RX queue %d worker thread executing on CPU "
-		  "%d\n", rx_queue->queue, raw_smp_processor_id());
-
+	/* Post an event to cause NAPI to run and refill the queue */
+	efx_nic_generate_fill_event(channel);
 	++rx_queue->slow_fill_count;
-	/* Push new RX descriptors, allowing at least 1 jiffy for
-	 * the kernel to free some more memory. */
-	rc = __efx_fast_push_rx_descriptors(rx_queue, 1);
-	if (rc)
-		efx_schedule_slow_fill(rx_queue, 1);
 }
 
 static void efx_rx_packet__check_len(struct efx_rx_queue *rx_queue,
@@ -420,23 +449,30 @@ static void efx_rx_packet__check_len(str
 	*discard = true;
 
 	if ((len > rx_buf->len) && EFX_WORKAROUND_8071(efx)) {
-		EFX_ERR_RL(efx, " RX queue %d seriously overlength "
-			   "RX event (0x%x > 0x%x+0x%x). Leaking\n",
-			   rx_queue->queue, len, max_len,
-			   efx->type->rx_buffer_padding);
+		if (net_ratelimit())
+			netif_err(efx, rx_err, efx->net_dev,
+				  " RX queue %d seriously overlength "
+				  "RX event (0x%x > 0x%x+0x%x). Leaking\n",
+				  efx_rx_queue_index(rx_queue), len, max_len,
+				  efx->type->rx_buffer_padding);
 		/* If this buffer was skb-allocated, then the meta
 		 * data at the end of the skb will be trashed. So
 		 * we have no choice but to leak the fragment.
 		 */
-		*leak_packet = (rx_buf->skb != NULL);
+		*leak_packet = !rx_buf->is_page;
 		efx_schedule_reset(efx, RESET_TYPE_RX_RECOVERY);
 	} else {
-		EFX_ERR_RL(efx, " RX queue %d overlength RX event "
-			   "(0x%x > 0x%x)\n", rx_queue->queue, len, max_len);
+		if (net_ratelimit())
+			netif_err(efx, rx_err, efx->net_dev,
+				  " RX queue %d overlength RX event "
+				  "(0x%x > 0x%x)\n",
+				  efx_rx_queue_index(rx_queue), len, max_len);
 	}
 
-	rx_queue->channel->n_rx_overlength++;
+	efx_rx_queue_channel(rx_queue)->n_rx_overlength++;
 }
+
+#if !defined(EFX_USE_KCOMPAT) || defined(EFX_USE_GRO)
 
 /* Pass a received packet up through the generic LRO stack
  *
@@ -445,36 +481,42 @@ static void efx_rx_packet__check_len(str
  */
 static void efx_rx_packet_lro(struct efx_channel *channel,
 			      struct efx_rx_buffer *rx_buf,
-			      bool checksummed)
+			      const u8 *eh, bool checksummed)
 {
 	struct efx_nic *efx = channel->efx;
 	struct napi_struct *napi = &channel->napi_str;
-	enum efx_veto veto;
+	int veto;
 
 	/* It would be faster if we had access to packets at the
 	 * other side of generic LRO. Unfortunately, there isn't
 	 * an obvious interface to this, so veto packets before LRO */
-	veto = EFX_DL_CALLBACK(efx, rx_packet, rx_buf->data, rx_buf->len);
+	veto = EFX_DL_CALLBACK(efx, rx_packet, eh, rx_buf->len);
 	if (unlikely(veto)) {
-		EFX_DL_LOG(efx, "LRO RX vetoed by driverlink %s driver\n",
-			   efx->dl_cb_dev.rx_packet->driver->name);
+		netif_dbg(efx, rx_status, efx->net_dev,
+			  "LRO RX vetoed by driverlink %s driver\n",
+			  efx->dl_cb_dev.rx_packet->driver->name);
 		/* Free the buffer now */
 		efx_free_rx_buffer(efx, rx_buf);
 		return;
 	}
 
 	/* Pass the skb/page into the LRO engine */
-	if (rx_buf->page) {
+	if (rx_buf->is_page) {
 		struct sk_buff *skb = napi_get_frags(napi);
 
 		if (!skb) {
-			put_page(rx_buf->page);
+			put_page(rx_buf->u.page);
 			goto out;
 		}
 
-		skb_shinfo(skb)->frags[0].page = rx_buf->page;
+#if !defined(EFX_USE_KCOMPAT) || defined(EFX_HAVE_RXHASH_SUPPORT)
+		if (efx->net_dev->features & NETIF_F_RXHASH)
+			skb->rxhash = efx_rx_buf_hash(eh);
+#endif
+
+		skb_shinfo(skb)->frags[0].page = rx_buf->u.page;
 		skb_shinfo(skb)->frags[0].page_offset =
-			efx_rx_buf_offset(rx_buf);
+			efx_rx_buf_offset(efx, rx_buf);
 		skb_shinfo(skb)->frags[0].size = rx_buf->len;
 		skb_shinfo(skb)->nr_frags = 1;
 
@@ -487,28 +529,83 @@ static void efx_rx_packet_lro(struct efx
 		napi_gro_frags(napi);
 
 out:
-		EFX_BUG_ON_PARANOID(rx_buf->skb);
-		rx_buf->page = NULL;
+		rx_buf->u.page = NULL;
 	} else {
-		EFX_BUG_ON_PARANOID(!rx_buf->skb);
 		EFX_BUG_ON_PARANOID(!checksummed);
 
-		napi_gro_receive(napi, rx_buf->skb);
-		rx_buf->skb = NULL;
+		napi_gro_receive(napi, rx_buf->u.skb);
+		rx_buf->u.skb = NULL;
 	}
 }
 
+#else /* EFX_USE_KCOMPAT && !EFX_USE_GRO */
+
+/* Allocate and construct an SKB around a struct page.*/
+static struct sk_buff *efx_rx_mk_skb(struct efx_nic *efx,
+				     struct efx_rx_buffer *rx_buf,
+				     u8 *eh, int hdr_len)
+{
+	struct sk_buff *skb;
+
+	/* Allocate an SKB to store the headers */
+	skb = netdev_alloc_skb(efx->net_dev, hdr_len + EFX_PAGE_SKB_ALIGN);
+	if (unlikely(skb == NULL)) {
+		if (net_ratelimit())
+			netif_err(efx, drv, efx->net_dev,
+				  "RX out of memory for skb\n");
+		return NULL;
+	}
+
+	EFX_BUG_ON_PARANOID(skb_shinfo(skb)->nr_frags);
+	EFX_BUG_ON_PARANOID(rx_buf->len < hdr_len);
+
+	skb->ip_summed = CHECKSUM_UNNECESSARY;
+	skb_reserve(skb, EFX_PAGE_SKB_ALIGN);
+
+	skb->len = rx_buf->len;
+	skb->truesize = rx_buf->len + sizeof(struct sk_buff);
+	memcpy(skb->data, eh, hdr_len);
+	skb->tail += hdr_len;
+
+	/* Append the remaining page onto the frag list */
+	if (unlikely(rx_buf->len > hdr_len)) {
+		struct skb_frag_struct *frag = skb_shinfo(skb)->frags;
+		frag->page = rx_buf->u.page;
+		frag->page_offset = efx_rx_buf_offset(efx, rx_buf) + hdr_len;
+		frag->size = skb->len - hdr_len;
+		skb_shinfo(skb)->nr_frags = 1;
+		skb->data_len = frag->size;
+	} else {
+		__free_pages(rx_buf->u.page, efx->rx_buffer_order);
+		skb->data_len = 0;
+	}
+
+	/* Ownership has transferred from the rx_buf to skb */
+	rx_buf->u.page = NULL;
+
+	/* Move past the ethernet header */
+	skb->protocol = eth_type_trans(skb, efx->net_dev);
+
+	return skb;
+}
+
+#endif /* !EFX_USE_KCOMPAT || EFX_USE_GRO */
+
+#if defined(EFX_USE_KCOMPAT) && defined(EFX_USE_FASTCALL)
+void fastcall efx_rx_packet(struct efx_rx_queue *rx_queue,
+			    unsigned int index, unsigned int len,
+			    bool checksummed, bool discard)
+#else
 void efx_rx_packet(struct efx_rx_queue *rx_queue, unsigned int index,
 		   unsigned int len, bool checksummed, bool discard)
+#endif
 {
 	struct efx_nic *efx = rx_queue->efx;
+	struct efx_channel *channel = efx_rx_queue_channel(rx_queue);
 	struct efx_rx_buffer *rx_buf;
 	bool leak_packet = false;
 
 	rx_buf = efx_rx_buffer(rx_queue, index);
-	EFX_BUG_ON_PARANOID(!rx_buf->data);
-	EFX_BUG_ON_PARANOID(rx_buf->skb && rx_buf->page);
-	EFX_BUG_ON_PARANOID(!(rx_buf->skb || rx_buf->page));
 
 	/* This allows the refill path to post another buffer.
 	 * EFX_RXD_HEAD_ROOM ensures that the slot we are using
@@ -520,21 +617,26 @@ void efx_rx_packet(struct efx_rx_queue *
 	efx_rx_packet__check_len(rx_queue, rx_buf, len,
 				 &discard, &leak_packet);
 
-	EFX_TRACE(efx, "RX queue %d received id %x at %llx+%x %s%s\n",
-		  rx_queue->queue, index,
-		  (unsigned long long)rx_buf->dma_addr, len,
-		  (checksummed ? " [SUMMED]" : ""),
-		  (discard ? " [DISCARD]" : ""));
+	netif_vdbg(efx, rx_status, efx->net_dev,
+		   "RX queue %d received id %x at %llx+%x %s%s\n",
+		   efx_rx_queue_index(rx_queue), index,
+		   (unsigned long long)rx_buf->dma_addr, len,
+		   (checksummed ? " [SUMMED]" : ""),
+		   (discard ? " [DISCARD]" : ""));
 
 	/* Discard packet, if instructed to do so */
 	if (unlikely(discard)) {
+#if defined(EFX_NOT_UPSTREAM) && defined(SFC_PCAP_SUPPORT)
+		efx_capture_packet(efx, buf_addr, len);
+#endif
 		if (unlikely(leak_packet))
-			rx_queue->channel->n_skbuff_leaks++;
+			channel->n_skbuff_leaks++;
 		else
-			/* We haven't called efx_unmap_rx_buffer yet,
-			 * so fini the entire rx_buffer here */
-			efx_fini_rx_buffer(rx_queue, rx_buf);
-		return;
+			efx_recycle_rx_buffer(channel, rx_buf);
+
+		/* Don't hold off the previous receive */
+		rx_buf = NULL;
+		goto out;
 	}
 
 	/* Release card resources - assumes all RX buffers consumed in-order
@@ -545,18 +647,116 @@ void efx_rx_packet(struct efx_rx_queue *
 	/* Prefetch nice and early so data will (hopefully) be in cache by
 	 * the time we look at it.
 	 */
-	prefetch(rx_buf->data);
+	prefetch(efx_rx_buf_eh(efx, rx_buf));
 
 	/* Pipeline receives so that we give time for packet headers to be
 	 * prefetched into cache.
 	 */
-	rx_buf->len = len;
-	if (rx_queue->channel->rx_pkt)
-		__efx_rx_packet(rx_queue->channel,
-				rx_queue->channel->rx_pkt,
-				rx_queue->channel->rx_pkt_csummed);
-	rx_queue->channel->rx_pkt = rx_buf;
-	rx_queue->channel->rx_pkt_csummed = checksummed;
+	rx_buf->len = len - efx->type->rx_buffer_hash_size;
+out:
+	if (channel->rx_pkt)
+		__efx_rx_packet(channel,
+				channel->rx_pkt, channel->rx_pkt_csummed);
+	channel->rx_pkt = rx_buf;
+	channel->rx_pkt_csummed = checksummed;
+}
+
+#if defined(EFX_NOT_UPSTREAM) && defined(EFX_USE_FAKE_VLAN_RX_ACCEL)
+static void
+efx_vlan_receive_skb(struct vlan_group *vlan_group, struct sk_buff *skb)
+{
+	/* Extract the tag and convert into a regular frame so that
+	 * VLAN devices can claim the skb before bridge devices
+	 * (bug 18220). */
+
+	struct vlan_ethhdr *veh = vlan_eth_hdr(skb);
+	u16 vlan_tci = ntohs(veh->h_vlan_TCI);
+
+	skb->protocol = veh->h_vlan_encapsulated_proto;
+	memmove((char *)veh + VLAN_HLEN, veh, 2 * ETH_ALEN);
+	skb_set_mac_header(skb, -ETH_HLEN);
+
+       vlan_hwaccel_receive_skb(skb, vlan_group, vlan_tci);
+}
+#endif
+
+static void efx_rx_deliver(struct efx_channel *channel, u8 *eh,
+			   struct efx_rx_buffer *rx_buf, int checksummed)
+{
+	struct efx_nic *efx = channel->efx;
+	struct sk_buff *skb;
+	enum efx_veto veto;
+
+	/* Allow callback to veto the packet */
+	veto = EFX_DL_CALLBACK(efx, rx_packet, eh, rx_buf->len);
+#if defined(EFX_NOT_UPSTREAM) && defined(EFX_VMWARE_3_DOT_5)
+	/* Trying to receive a packet before we attach to the stack
+	 * will die messily. */
+	veto = veto || !efx_dev_registered(efx);
+#endif
+	if (unlikely(veto)) {
+		netif_dbg(efx, rx_status, efx->net_dev,
+			  "RX vetoed by driverlink %s driver\n",
+			  efx->dl_cb_dev.rx_packet->driver->name);
+		/* Free the buffer now */
+		efx_free_rx_buffer(efx, rx_buf);
+		return;
+	}
+
+
+
+#if defined(EFX_USE_KCOMPAT) && !defined(EFX_USE_GRO)
+	/* Form an skb if required */
+	if (rx_buf->is_page) {
+		int hdr_len = min(rx_buf->len, EFX_SKB_HEADERS);
+		skb = efx_rx_mk_skb(efx, rx_buf, eh, hdr_len);
+		if (unlikely(skb == NULL)) {
+			efx_free_rx_buffer(efx, rx_buf);
+			return;
+		}
+	} else {
+		/* We now own the SKB */
+		skb = rx_buf->u.skb;
+		rx_buf->u.skb = NULL;
+	}
+#else
+	/* We now own the SKB */
+	skb = rx_buf->u.skb;
+	rx_buf->u.skb = NULL;
+#endif
+
+	/* Set the SKB flags */
+#if defined(EFX_USE_KCOMPAT) && !defined(EFX_USE_GRO)
+	if (unlikely(!checksummed))
+		/* fall through to next statement, else skip */
+#endif
+	skb->ip_summed = CHECKSUM_NONE;
+
+#if defined(EFX_NOT_UPSTREAM) && defined(EFX_WITH_VMWARE_NETQ)
+	/* This will mark the skb with the correct queue ID.
+	 * It may also insert a hardware filter. We pass in
+	 * the channel as a hint, since in the common case it
+	 * should map to the correct queue. Note that this
+	 * is the only netif_receive_skb() call site that is
+	 * active in the VMWare build.*/
+	if (efx->netq_active)
+		efx_netq_process_rx(efx, channel, skb);
+#endif
+	skb_record_rx_queue(skb, channel->channel);
+
+	/* Pass the packet up */
+#if defined(EFX_NOT_UPSTREAM) && defined(EFX_USE_FAKE_VLAN_RX_ACCEL)
+	if (efx->vlan_group && skb->protocol == htons(ETH_P_8021Q) &&
+	    likely(skb->len >= VLAN_HLEN)) {
+		skb_pull(skb, VLAN_HLEN);
+		efx_vlan_receive_skb(efx->vlan_group, skb);
+	} else
+		/* fall through */
+#endif
+	netif_receive_skb(skb);
+
+	/* Update allocation strategy method */
+	channel->rx_alloc_level += RX_ALLOC_FACTOR_SKB;
 }
 
 /* Handle a received packet.  Second half: Touches packet payload. */
@@ -564,73 +764,79 @@ void __efx_rx_packet(struct efx_channel 
 		     struct efx_rx_buffer *rx_buf, bool checksummed)
 {
 	struct efx_nic *efx = channel->efx;
-	enum efx_veto veto;
-	struct sk_buff *skb;
+	u8 *eh = efx_rx_buf_eh(efx, rx_buf);
 
 	/* If we're in loopback test, then pass the packet directly to the
 	 * loopback layer, and free the rx_buf here
 	 */
 	if (unlikely(efx->loopback_selftest)) {
-		efx_loopback_rx_packet(efx, rx_buf->data, rx_buf->len);
+		efx_loopback_rx_packet(efx, eh, rx_buf->len);
 		efx_free_rx_buffer(efx, rx_buf);
-		goto done;
+		return;
 	}
 
-	/* Allow callback to veto the packet */
-	veto = EFX_DL_CALLBACK(efx, rx_packet, rx_buf->data, rx_buf->len);
-	if (unlikely(veto)) {
-		EFX_DL_LOG(efx, "RX vetoed by driverlink %s driver\n",
-			   efx->dl_cb_dev.rx_packet->driver->name);
-		/* Free the buffer now */
-		efx_free_rx_buffer(efx, rx_buf);
-		goto done;
+	if (!rx_buf->is_page) {
+		struct sk_buff *skb = rx_buf->u.skb;
+
+		prefetch(skb_shinfo(skb));
+		skb_reserve(skb, efx->type->rx_buffer_hash_size);
+		skb_put(skb, rx_buf->len);
+
+#if !defined(EFX_USE_KCOMPAT) || defined(EFX_HAVE_RXHASH_SUPPORT)
+		if (efx->net_dev->features & NETIF_F_RXHASH)
+			skb->rxhash = efx_rx_buf_hash(eh);
+#endif
+
+		/* Move past the ethernet header */
+		skb->protocol = eth_type_trans(skb, efx->net_dev);
 	}
+#ifdef EFX_NOT_UPSTREAM
+	channel->rx_packets++;
+	channel->rx_bytes += rx_buf->len;
+#endif
 
-	if (rx_buf->skb) {
-		prefetch(skb_shinfo(rx_buf->skb));
-
-		skb_put(rx_buf->skb, rx_buf->len);
-
-		/* Move past the ethernet header. rx_buf->data still points
-		 * at the ethernet header */
-		rx_buf->skb->protocol = eth_type_trans(rx_buf->skb,
-						       efx->net_dev);
+#if !defined(EFX_USE_KCOMPAT) || defined(EFX_USE_GRO)
+	if (likely(checksummed || rx_buf->is_page))
+		efx_rx_packet_lro(channel, rx_buf, eh, checksummed);
+	else
+#elif defined(EFX_NOT_UPSTREAM) && defined(EFX_USE_SFC_LRO)
+	/* SFC-SSR supports both skb and page based, but not switching
+	 * from one to the other on the fly. If we spot that the
+	 * allocation mode has changed, then flush the LRO state.
+	 */
+	if (unlikely(channel->rx_alloc_pop_pages != rx_buf->is_page)) {
+		efx_ssr_end_of_burst(channel);
+		channel->rx_alloc_pop_pages = rx_buf->is_page;
 	}
-
-	if (likely(checksummed || rx_buf->page)) {
-		efx_rx_packet_lro(channel, rx_buf, checksummed);
-		goto done;
-	}
-
-	/* We now own the SKB */
-	skb = rx_buf->skb;
-	rx_buf->skb = NULL;
-
-	EFX_BUG_ON_PARANOID(rx_buf->page);
-	EFX_BUG_ON_PARANOID(rx_buf->skb);
-	EFX_BUG_ON_PARANOID(!skb);
-
-	/* Set the SKB flags */
-	skb->ip_summed = CHECKSUM_NONE;
-
-	skb_record_rx_queue(skb, channel->channel);
-
-	/* Pass the packet up */
-	netif_receive_skb(skb);
-
-	/* Update allocation strategy method */
-	channel->rx_alloc_level += RX_ALLOC_FACTOR_SKB;
-
-done:
-	;
+	if (likely(checksummed && efx_ssr_enabled(efx)))
+		efx_ssr(channel, rx_buf, eh);
+	else
+#endif
+		efx_rx_deliver(channel, eh, rx_buf, checksummed);
+#if defined(EFX_USE_KCOMPAT) && defined(EFX_USE_NET_DEVICE_LAST_RX)
+	efx->net_dev->last_rx = jiffies;
+#endif
 }
 
 void efx_rx_strategy(struct efx_channel *channel)
 {
 	enum efx_rx_alloc_method method = rx_alloc_method;
 
+#if defined(EFX_NOT_UPSTREAM) && !defined(EFX_USE_COMPOUND_PAGES)
+	if (channel->efx->rx_buffer_order > 0) {
+		channel->rx_alloc_push_pages = 0;
+		return;
+	}
+#endif
+
 	/* Only makes sense to use page based allocation if LRO is enabled */
+#if !defined(EFX_USE_KCOMPAT) || defined(EFX_USE_GRO)
 	if (!(channel->efx->net_dev->features & NETIF_F_GRO)) {
+#elif defined(EFX_NOT_UPSTREAM) && defined(EFX_USE_SFC_LRO)
+	if (!efx_ssr_enabled(channel->efx)) {
+#else
+	if (1) {
+#endif
 		method = RX_ALLOC_METHOD_SKB;
 	} else if (method == RX_ALLOC_METHOD_AUTO) {
 		/* Constrain the rx_alloc_level */
@@ -651,18 +857,26 @@ int efx_probe_rx_queue(struct efx_rx_que
 int efx_probe_rx_queue(struct efx_rx_queue *rx_queue)
 {
 	struct efx_nic *efx = rx_queue->efx;
-	unsigned int rxq_size;
+	unsigned int entries;
 	int rc;
 
-	EFX_LOG(efx, "creating RX queue %d\n", rx_queue->queue);
+	/* Create the smallest power-of-two aligned ring */
+	entries = max(roundup_pow_of_two(efx->rxq_entries), EFX_MIN_DMAQ_SIZE);
+	EFX_BUG_ON_PARANOID(entries > EFX_MAX_DMAQ_SIZE);
+	rx_queue->ptr_mask = entries - 1;
+
+	netif_dbg(efx, probe, efx->net_dev,
+		  "creating RX queue %d size 0x%x mask 0x%x\n",
+		  efx_rx_queue_index(rx_queue), efx->rxq_entries,
+		  rx_queue->ptr_mask);
 
 	/* Allocate RX buffers */
-	rxq_size = (efx->type->rxd_ring_mask + 1) * sizeof(*rx_queue->buffer);
-	rx_queue->buffer = kzalloc(rxq_size, GFP_KERNEL);
+	rx_queue->buffer = kzalloc(entries * sizeof(*rx_queue->buffer),
+				   GFP_KERNEL);
 	if (!rx_queue->buffer)
 		return -ENOMEM;
 
-	rc = falcon_probe_rx(rx_queue);
+	rc = efx_nic_probe_rx(rx_queue);
 	if (rc) {
 		kfree(rx_queue->buffer);
 		rx_queue->buffer = NULL;
@@ -675,17 +889,17 @@ void efx_init_rx_queue(struct efx_rx_que
 	struct efx_nic *efx = rx_queue->efx;
 	unsigned int max_fill, trigger, limit;
 
-	EFX_LOG(rx_queue->efx, "initialising RX queue %d\n", rx_queue->queue);
+	netif_dbg(rx_queue->efx, drv, rx_queue->efx->net_dev,
+		  "initialising RX queue %d\n", efx_rx_queue_index(rx_queue));
 
 	/* Initialise ptr fields */
 	rx_queue->added_count = 0;
 	rx_queue->notified_count = 0;
 	rx_queue->removed_count = 0;
 	rx_queue->min_fill = -1U;
-	rx_queue->min_overfill = -1U;
 
 	/* Initialise limit fields */
-	max_fill = efx->type->rxd_ring_mask + 1 - EFX_RXD_HEAD_ROOM;
+	max_fill = efx->rxq_entries - EFX_RXD_HEAD_ROOM;
 	trigger = max_fill * min(rx_refill_threshold, 100U) / 100U;
 	limit = max_fill * min(rx_refill_limit, 100U) / 100U;
 
@@ -694,7 +908,7 @@ void efx_init_rx_queue(struct efx_rx_que
 	rx_queue->fast_fill_limit = limit;
 
 	/* Set up RX descriptor ring */
-	falcon_init_rx(rx_queue);
+	efx_nic_init_rx(rx_queue);
 }
 
 void efx_fini_rx_queue(struct efx_rx_queue *rx_queue)
@@ -702,34 +916,27 @@ void efx_fini_rx_queue(struct efx_rx_que
 	int i;
 	struct efx_rx_buffer *rx_buf;
 
-	EFX_LOG(rx_queue->efx, "shutting down RX queue %d\n", rx_queue->queue);
+	netif_dbg(rx_queue->efx, drv, rx_queue->efx->net_dev,
+		  "shutting down RX queue %d\n", efx_rx_queue_index(rx_queue));
 
-	falcon_fini_rx(rx_queue);
+	del_timer_sync(&rx_queue->slow_fill);
+	efx_nic_fini_rx(rx_queue);
 
 	/* Release RX buffers NB start at index 0 not current HW ptr */
 	if (rx_queue->buffer) {
-		for (i = 0; i <= rx_queue->efx->type->rxd_ring_mask; i++) {
+		for (i = 0; i <= rx_queue->ptr_mask; i++) {
 			rx_buf = efx_rx_buffer(rx_queue, i);
 			efx_fini_rx_buffer(rx_queue, rx_buf);
 		}
-	}
-
-	/* For a page that is part-way through splitting into RX buffers */
-	if (rx_queue->buf_page != NULL) {
-		pci_unmap_page(rx_queue->efx->pci_dev, rx_queue->buf_dma_addr,
-			       efx_rx_buf_size(rx_queue->efx),
-			       PCI_DMA_FROMDEVICE);
-		__free_pages(rx_queue->buf_page,
-			     rx_queue->efx->rx_buffer_order);
-		rx_queue->buf_page = NULL;
 	}
 }
 
 void efx_remove_rx_queue(struct efx_rx_queue *rx_queue)
 {
-	EFX_LOG(rx_queue->efx, "destroying RX queue %d\n", rx_queue->queue);
+	netif_dbg(rx_queue->efx, drv, rx_queue->efx->net_dev,
+		  "destroying RX queue %d\n", efx_rx_queue_index(rx_queue));
 
-	falcon_remove_rx(rx_queue);
+	efx_nic_remove_rx(rx_queue);
 
 	kfree(rx_queue->buffer);
 	rx_queue->buffer = NULL;
@@ -743,3 +950,671 @@ MODULE_PARM_DESC(rx_refill_threshold,
 MODULE_PARM_DESC(rx_refill_threshold,
 		 "RX descriptor ring fast/slow fill threshold (%)");
 
+#if defined(EFX_NOT_UPSTREAM) && defined(EFX_USE_SFC_LRO)
+
+
+/* Size of the LRO hash table.  Must be a power of 2.  A larger table
+ * means we can accelerate a larger number of streams.
+ */
+static unsigned lro_table_size = 128;
+module_param(lro_table_size, uint, 0644);
+MODULE_PARM_DESC(lro_table_size,
+		 "Size of the LRO hash table.  Must be a power of 2");
+
+/* Maximum length of a hash chain.  If chains get too long then the lookup
+ * time increases and may exceed the benefit of LRO.
+ */
+static unsigned lro_chain_max = 20;
+module_param(lro_chain_max, uint, 0644);
+MODULE_PARM_DESC(lro_chain_max,
+		 "Maximum length of chains in the LRO hash table");
+
+
+/* Maximum time (in jiffies) that a connection can be idle before it's LRO
+ * state is discarded.
+ */
+static unsigned lro_idle_jiffies = HZ / 10 + 1;	/* 100ms */
+module_param(lro_idle_jiffies, uint, 0644);
+MODULE_PARM_DESC(lro_idle_jiffies, "Time (in jiffies) after which an"
+		 " idle connection's LRO state is discarded");
+
+
+/* Number of packets with payload that must arrive in-order before a
+ * connection is eligible for LRO.  The idea is we should avoid coalescing
+ * segments when the sender is in slow-start because reducing the ACK rate
+ * can damage performance.
+ */
+static int lro_slow_start_packets = 2000;
+module_param(lro_slow_start_packets, uint, 0644);
+MODULE_PARM_DESC(lro_slow_start_packets, "Number of packets that must "
+		 "pass in-order before starting LRO.");
+
+
+/* Number of packets with payload that must arrive in-order following loss
+ * before a connection is eligible for LRO.  The idea is we should avoid
+ * coalescing segments when the sender is recovering from loss, because
+ * reducing the ACK rate can damage performance.
+ */
+static int lro_loss_packets = 20;
+module_param(lro_loss_packets, uint, 0644);
+MODULE_PARM_DESC(lro_loss_packets, "Number of packets that must "
+		 "pass in-order following loss before restarting LRO.");
+
+
+/* Flags for efx_ssr_conn::l2_id; must not collide with VLAN_VID_MASK */
+#define EFX_SSR_L2_ID_VLAN 0x4000
+#define EFX_SSR_L2_ID_IPV6 0x8000
+#define EFX_SSR_CONN_IS_VLAN_ENCAP(c) ((c)->l2_id & EFX_SSR_L2_ID_VLAN)
+#define EFX_SSR_CONN_IS_TCPIPV4(c) (!((c)->l2_id & EFX_SSR_L2_ID_IPV6))
+
+int efx_ssr_init(struct efx_channel *channel, struct efx_nic *efx)
+{
+	struct efx_ssr_state *st = &channel->ssr;
+	unsigned i;
+
+	st->conns_mask = lro_table_size - 1;
+	if ((st->conns_mask + 1) & st->conns_mask) {
+		netif_err(efx, drv, efx->net_dev,
+			  "lro_table_size(=%u) must be a power of 2\n",
+			  lro_table_size);
+		return -EINVAL;
+	}
+	st->efx = efx;
+	st->conns = kmalloc((st->conns_mask + 1)
+			    * sizeof(st->conns[0]), GFP_KERNEL);
+	if (st->conns == NULL)
+		return -ENOMEM;
+	st->conns_n = kmalloc((st->conns_mask + 1)
+			      * sizeof(st->conns_n[0]), GFP_KERNEL);
+	if (st->conns_n == NULL) {
+		kfree(st->conns);
+		st->conns = NULL;
+		return -ENOMEM;
+	}
+	for (i = 0; i <= st->conns_mask; ++i) {
+		INIT_LIST_HEAD(&st->conns[i]);
+		st->conns_n[i] = 0;
+	}
+	INIT_LIST_HEAD(&st->active_conns);
+	INIT_LIST_HEAD(&st->free_conns);
+	return 0;
+}
+
+static inline bool efx_rx_buffer_is_full(struct efx_rx_buffer *rx_buf)
+{
+	return rx_buf->u.page;
+}
+
+static inline void efx_rx_buffer_set_empty(struct efx_rx_buffer *rx_buf)
+{
+	rx_buf->u.page = NULL;
+}
+
+/* Drop the given connection, and add it to the free list. */
+static void efx_ssr_drop(struct efx_channel *channel, struct efx_ssr_conn *c)
+{
+	unsigned bucket;
+
+	EFX_BUG_ON_PARANOID(c->skb);
+
+	if (efx_rx_buffer_is_full(&c->next_buf)) {
+		efx_rx_deliver(channel, c->next_eh, &c->next_buf, 1);
+		list_del(&c->active_link);
+	}
+
+	bucket = c->conn_hash & channel->ssr.conns_mask;
+	EFX_BUG_ON_PARANOID(channel->ssr.conns_n[bucket] <= 0);
+	--channel->ssr.conns_n[bucket];
+	list_del(&c->link);
+	list_add(&c->link, &channel->ssr.free_conns);
+}
+
+void efx_ssr_fini(struct efx_channel *channel)
+{
+	struct efx_ssr_state *st = &channel->ssr;
+	struct efx_ssr_conn *c;
+	unsigned i;
+
+	/* Return cleanly if efx_ssr_init() has not been called. */
+	if (st->conns == NULL)
+		return;
+
+	EFX_BUG_ON_PARANOID(!list_empty(&st->active_conns));
+
+	for (i = 0; i <= st->conns_mask; ++i) {
+		while (!list_empty(&st->conns[i])) {
+			c = list_entry(st->conns[i].prev,
+				       struct efx_ssr_conn, link);
+			efx_ssr_drop(channel, c);
+		}
+	}
+
+	while (!list_empty(&st->free_conns)) {
+		c = list_entry(st->free_conns.prev, struct efx_ssr_conn, link);
+		list_del(&c->link);
+		EFX_BUG_ON_PARANOID(c->skb);
+		kfree(c);
+	}
+
+	kfree(st->conns_n);
+	kfree(st->conns);
+	st->conns = NULL;
+}
+
+/* Calc IP checksum and deliver to the OS */
+static void efx_ssr_deliver(struct efx_ssr_state *st, struct efx_ssr_conn *c)
+{
+	struct efx_nic *efx = st->efx;
+	struct ethhdr *c_eh;
+	struct tcphdr *c_th;
+	enum efx_veto veto;
+	int len;
+
+	EFX_BUG_ON_PARANOID(!c->skb);
+
+	++st->n_bursts;
+
+	/* Finish off packet munging and recalculate IP header checksum. */
+	if (EFX_SSR_CONN_IS_TCPIPV4(c)) {
+		struct iphdr *iph = (struct iphdr *) c->skb->data;
+		iph->tot_len = htons(iph->tot_len);
+		iph->check = 0;
+		iph->check = ip_fast_csum((u8 *) iph, iph->ihl);
+		c_th = (struct tcphdr *)(iph + 1);
+	} else {
+		struct ipv6hdr *iph = (struct ipv6hdr *) c->skb->data;
+		iph->payload_len = htons(iph->payload_len);
+		c_th = (struct tcphdr *)(iph + 1);
+	}
+
+	c_eh = eth_hdr(c->skb);
+	len = c->skb->len + ((u8 *)c->skb->data - (u8 *)c_eh);
+	c->skb->truesize = len + sizeof(struct sk_buff);
+
+	c_th->window = c->th_last->window;
+	c_th->ack_seq = c->th_last->ack_seq;
+	if (c_th->doff == c->th_last->doff) {
+		/* Copy TCP options (take care to avoid going negative). */
+		int optlen = ((c_th->doff - 5) & 0xf) << 2u;
+		memcpy(c_th + 1, c->th_last + 1, optlen);
+	}
+
+	/* Allow callback to veto the packet. */
+	veto = EFX_DL_CALLBACK(efx, rx_packet, (char *)c_eh, len);
+	if (unlikely(veto)) {
+		netif_dbg(efx, rx_status, efx->net_dev,
+			  "RX vetoed by driverlink %s driver\n",
+			  efx->dl_cb_dev.rx_packet->driver->name);
+		dev_kfree_skb_any(c->skb);
+	} else {
+#if defined(EFX_USE_FAKE_VLAN_RX_ACCEL)
+		if (EFX_SSR_CONN_IS_VLAN_ENCAP(c)) {
+			if (efx->vlan_group) {
+				efx_vlan_receive_skb(efx->vlan_group, c->skb);
+			} else {
+				skb_push(c->skb, VLAN_HLEN);
+				netif_receive_skb(c->skb);
+			}
+		} else
+			/* fall through */
+#endif
+			netif_receive_skb(c->skb);
+	}
+
+	c->skb = NULL;
+	c->delivered = 1;
+}
+
+/* Stop tracking connections that have gone idle in order to keep hash
+ * chains short.
+ */
+static void efx_ssr_purge_idle(struct efx_channel *channel, unsigned now)
+{
+	struct efx_ssr_conn *c;
+	unsigned i;
+
+	EFX_BUG_ON_PARANOID(!list_empty(&channel->ssr.active_conns));
+
+	channel->ssr.last_purge_jiffies = now;
+	for (i = 0; i <= channel->ssr.conns_mask; ++i) {
+		if (list_empty(&channel->ssr.conns[i]))
+			continue;
+
+		c = list_entry(channel->ssr.conns[i].prev,
+			       struct efx_ssr_conn, link);
+		if (now - c->last_pkt_jiffies > lro_idle_jiffies) {
+			++channel->ssr.n_drop_idle;
+			efx_ssr_drop(channel, c);
+		}
+	}
+}
+
+/* Construct an skb Push held skbs down into network stack.
+ * Only called when active list is non-empty.
+ */
+static int
+efx_ssr_merge(struct efx_ssr_state *st, struct efx_ssr_conn *c,
+	      struct tcphdr *th, int data_length)
+{
+	struct tcphdr *c_th;
+
+	/* Increase lengths appropriately */
+	c->skb->len += data_length;
+	c->skb->data_len += data_length;
+
+#ifdef EFX_USE_GSO_SIZE_FOR_MSS
+	if (data_length > skb_shinfo(c->skb)->gso_size)
+		skb_shinfo(c->skb)->gso_size = data_length;
+#endif
+
+	/* Update the connection state flags */
+	if (EFX_SSR_CONN_IS_TCPIPV4(c)) {
+		struct iphdr *iph = (struct iphdr *) c->skb->data;
+		iph->tot_len += data_length;
+		c_th = (struct tcphdr *)(iph + 1);
+	} else {
+		struct ipv6hdr *iph = (struct ipv6hdr *) c->skb->data;
+		iph->payload_len += data_length;
+		c_th = (struct tcphdr *)(iph + 1);
+	}
+	c_th->psh |= th->psh;
+	c->th_last = th;
+	++st->n_merges;
+
+#ifndef EFX_USE_GSO_SIZE_FOR_MSS
+	/* This kernel version does not understand LRO, and uses the max
+	 * frame received to update rcv_mss.  If we're going above 1/4 of
+	 * max window size without scaling pass the packet up.  This is
+	 * slightly conservative, but close enough, and avoids rcv_mss
+	 * growing too large.  Also stop merging if we got a PSH flag
+	 * because if the sender is pushing messages a few times larger
+	 * than the real MSS and we let rcv_mss grow larger than that
+	 * message size we will end up delaying ACKs that the sender
+	 * is waiting for.
+	 */
+	return (c->skb->len > 16384 || th->psh);
+#else
+	/* Pass packet up now if another segment could overflow the IP
+	 * length.
+	 */
+	return (c->skb->len > 65536 - 9200);
+#endif
+}
+
+static void
+efx_ssr_start(struct efx_ssr_state *st, struct efx_ssr_conn *c,
+	      struct tcphdr *th, int data_length)
+{
+#ifdef EFX_USE_GSO_SIZE_FOR_MSS
+	skb_shinfo(c->skb)->gso_size = data_length;
+#endif
+
+	/* Mangle header fields for later processing */
+	if (EFX_SSR_CONN_IS_TCPIPV4(c)) {
+		struct iphdr *iph = (struct iphdr *) c->skb->data;
+		iph->tot_len = ntohs(iph->tot_len);
+	} else {
+		struct ipv6hdr *iph = (struct ipv6hdr *) c->skb->data;
+		iph->payload_len = ntohs(iph->payload_len);
+	}
+}
+
+static int
+efx_ssr_merge_page(struct efx_ssr_state *st, struct efx_ssr_conn *c,
+		   struct tcphdr *th, int hdr_length, int data_length)
+{
+	struct efx_nic *efx = st->efx;
+	struct efx_rx_buffer *rx_buf = &c->next_buf;
+	char *eh = c->next_eh;
+
+	if (likely(c->skb)) {
+		struct skb_frag_struct *frag;
+		frag = skb_shinfo(c->skb)->frags;
+		frag += skb_shinfo(c->skb)->nr_frags;
+		frag->page = rx_buf->u.page;
+		frag->page_offset = efx_rx_buf_offset(efx, rx_buf) + hdr_length;
+		frag->size = data_length;
+		++skb_shinfo(c->skb)->nr_frags;
+		rx_buf->u.page = NULL;
+
+		if (efx_ssr_merge(st, c, th, data_length) ||
+		    (skb_shinfo(c->skb)->nr_frags == MAX_SKB_FRAGS))
+			efx_ssr_deliver(st, c);
+
+		return 1;
+	} else {
+		c->skb = efx_rx_mk_skb(efx, rx_buf, eh, hdr_length);
+		if (unlikely(c->skb == NULL))
+			return 0;
+
+#ifdef EFX_HAVE_RXHASH_SUPPORT
+		c->skb->rxhash = c->conn_hash;
+#endif
+		if (EFX_SSR_CONN_IS_VLAN_ENCAP(c))
+			skb_pull(c->skb, VLAN_HLEN);
+		if (EFX_SSR_CONN_IS_TCPIPV4(c)) {
+			struct iphdr *iph = (struct iphdr *) c->skb->data;
+			c->th_last = (struct tcphdr *)(iph + 1);
+		} else {
+			struct ipv6hdr *iph = (struct ipv6hdr *) c->skb->data;
+			c->th_last = (struct tcphdr *)(iph + 1);
+		}
+		efx_ssr_start(st, c, th, data_length);
+
+		return 1;
+	}
+}
+
+static void
+efx_ssr_merge_skb(struct efx_ssr_state *st, struct efx_ssr_conn *c,
+		  struct efx_rx_buffer *rx_buf,
+		  struct tcphdr *th, int data_length)
+{
+	/* Transfer ownership of the rx_buf->skb to the LRO chain */
+	struct sk_buff *skb = rx_buf->u.skb;
+	rx_buf->u.skb = NULL;
+
+	if (likely(c->skb)) {
+		/* Remove padding and headers */
+		skb_trim(skb, rx_buf->len);
+		skb_pull(skb, rx_buf->len - data_length);
+
+		/* Tack the new skb onto the head skb's frag_list. */
+		EFX_BUG_ON_PARANOID(skb->next);
+		if (!skb_shinfo(c->skb)->frag_list)
+			skb_shinfo(c->skb)->frag_list = skb;
+		else
+			c->skb_tail->next = skb;
+		c->skb_tail = skb;
+
+		if (efx_ssr_merge(st, c, th, data_length))
+			efx_ssr_deliver(st, c);
+	} else {
+		c->skb = skb;
+		if (EFX_SSR_CONN_IS_VLAN_ENCAP(c))
+			skb_pull(c->skb, VLAN_HLEN);
+		c->th_last = th;
+		efx_ssr_start(st, c, th, data_length);
+	}
+}
+
+/* Try to merge or otherwise hold or deliver (as appropriate) the
+ * packet buffered for this connection (c->next_buf).  Return a flag
+ * indicating whether the connection is still active for SSR purposes.
+ */
+static bool
+efx_ssr_try_merge(struct efx_channel *channel, struct efx_ssr_conn *c)
+{
+	struct efx_rx_buffer *rx_buf = &c->next_buf;
+	u8 *eh = c->next_eh;
+	int data_length, hdr_length, dont_merge;
+	unsigned th_seq, pkt_length;
+	struct tcphdr *th;
+	unsigned now;
+
+	if (EFX_SSR_CONN_IS_TCPIPV4(c)) {
+		struct iphdr *iph = c->next_iph;
+		th = (struct tcphdr *)(iph + 1);
+		pkt_length = ntohs(iph->tot_len) + (u8 *) iph - (u8 *) eh;
+	} else {
+		struct ipv6hdr *iph = c->next_iph;
+		th = (struct tcphdr *)(iph + 1);
+		pkt_length = ntohs(iph->payload_len) + (u8 *) th - (u8 *) eh;
+	}
+	
+	hdr_length = (u8 *) th + th->doff * 4 - (u8 *) eh;
+	rx_buf->len = min(pkt_length, rx_buf->len);
+	data_length = rx_buf->len - hdr_length;
+	th_seq = ntohl(th->seq);
+	dont_merge = ((data_length <= 0)
+		      | th->urg | th->syn | th->rst | th->fin);
+
+	/* Check for options other than aligned timestamp. */
+	if (th->doff != 5) {
+		const u32 *opt_ptr = (const u32 *) (th + 1);
+		if (th->doff == 8 &&
+		    opt_ptr[0] == ntohl((TCPOPT_NOP << 24) |
+					(TCPOPT_NOP << 16) |
+					(TCPOPT_TIMESTAMP << 8) |
+					TCPOLEN_TIMESTAMP)) {
+			/* timestamp option -- okay */
+		} else {
+			dont_merge = 1;
+		}
+	}
+
+	if (unlikely(th_seq - c->next_seq)) {
+		/* Out-of-order, so start counting again. */
+		if (c->skb)
+			efx_ssr_deliver(&channel->ssr, c);
+		c->n_in_order_pkts -= lro_loss_packets;
+		c->next_seq = th_seq + data_length;
+		++channel->ssr.n_misorder;
+		goto deliver_buf_out;
+	}
+	c->next_seq = th_seq + data_length;
+
+	now = jiffies;
+	if (now - c->last_pkt_jiffies > lro_idle_jiffies) {
+		++channel->ssr.n_drop_idle;
+		if (c->skb)
+			efx_ssr_deliver(&channel->ssr, c);
+		efx_ssr_drop(channel, c);
+		return false;
+	}
+	c->last_pkt_jiffies = jiffies;
+
+	if (c->n_in_order_pkts < lro_slow_start_packets) {
+		/* May be in slow-start, so don't merge. */
+		++channel->ssr.n_slow_start;
+		++c->n_in_order_pkts;
+		goto deliver_buf_out;
+	}
+
+	if (unlikely(dont_merge)) {
+		if (c->skb)
+			efx_ssr_deliver(&channel->ssr, c);
+		if (th->fin || th->rst) {
+			++channel->ssr.n_drop_closed;
+			efx_ssr_drop(channel, c);
+			return false;
+		}
+		goto deliver_buf_out;
+	}
+
+	if (rx_buf->is_page) {
+		if (efx_ssr_merge_page(&channel->ssr, c, th,
+				       hdr_length, data_length) == 0)
+			goto deliver_buf_out;
+	} else {
+		efx_ssr_merge_skb(&channel->ssr, c, rx_buf, th, data_length);
+	}
+	channel->rx_alloc_level += RX_ALLOC_FACTOR_LRO;
+	channel->irq_mod_score += 2;
+	return true;
+
+ deliver_buf_out:
+	efx_rx_deliver(channel, eh, rx_buf, 1);
+	return true;
+}
+
+static void efx_ssr_new_conn(struct efx_ssr_state *st, u32 conn_hash,
+			     __be16 l2_id, struct tcphdr *th)
+{
+	unsigned bucket = conn_hash & st->conns_mask;
+	struct efx_ssr_conn *c;
+
+	if (st->conns_n[bucket] >= lro_chain_max) {
+		++st->n_too_many;
+		return;
+	}
+
+	if (!list_empty(&st->free_conns)) {
+		c = list_entry(st->free_conns.next, struct efx_ssr_conn, link);
+		list_del(&c->link);
+	} else {
+		c = kmalloc(sizeof(*c), GFP_ATOMIC);
+		if (c == NULL)
+			return;
+		c->skb = NULL;
+		efx_rx_buffer_set_empty(&c->next_buf);
+	}
+
+	/* Create the connection tracking data */
+	++st->conns_n[bucket];
+	list_add(&c->link, &st->conns[bucket]);
+	c->l2_id = l2_id;
+	c->conn_hash = conn_hash;
+	c->source = th->source;
+	c->dest = th->dest;
+	c->n_in_order_pkts = 0;
+	c->last_pkt_jiffies = jiffies;
+	c->delivered = 0;
+	++st->n_new_stream;
+	/* NB. We don't initialise c->next_seq, and it doesn't matter what
+	 * value it has.  Most likely the next packet received for this
+	 * connection will not match -- no harm done.
+	 */
+}
+
+/* Process SKB and decide whether to dispatch it to the stack now or
+ * later.
+ */
+void efx_ssr(struct efx_channel *channel, struct efx_rx_buffer *rx_buf,
+	     u8 *rx_data)
+{
+	struct efx_nic *efx = channel->efx;
+	struct ethhdr *eh = (struct ethhdr *)rx_data;
+	struct efx_ssr_conn *c;
+	__be16 l2_id; 
+	__be16 l3_proto;
+        void *nh;
+	struct tcphdr *th;
+	u32 conn_hash;
+	unsigned bucket;
+
+	/* Get the hardware hash if available */
+#ifdef EFX_HAVE_RXHASH_SUPPORT
+	if (efx->net_dev->features & NETIF_F_RXHASH)
+#else
+	if (efx->type->rx_buffer_hash_size)
+#endif
+		conn_hash = efx_rx_buf_hash(rx_data);
+	else
+		conn_hash = 0;
+
+	if (eh->h_proto == htons(ETH_P_8021Q)) {
+		struct vlan_ethhdr *veh = (struct vlan_ethhdr *)eh;
+		l2_id = (ntohs(veh->h_vlan_TCI) & VLAN_VID_MASK) |
+			EFX_SSR_L2_ID_VLAN;
+		l3_proto = veh->h_vlan_encapsulated_proto;
+		nh = veh + 1;
+	} else {
+		l2_id = 0;
+		l3_proto = eh->h_proto;
+		nh = eh + 1;
+	}
+
+	/* Check whether this is a suitable packet (unfragmented
+	 * TCP/IPv4 or TCP/IPv6).  If so, find the TCP header and
+	 * length, and compute a hash if necessary.  If not, return.
+	 */
+	if (l3_proto == htons(ETH_P_IP)) {
+		struct iphdr *iph = nh;
+		if ((iph->protocol - IPPROTO_TCP) |
+		    (iph->ihl - (sizeof(*iph) >> 2u)) |
+		    (iph->frag_off & htons(IP_MF | IP_OFFSET)))
+			goto deliver_now;
+		th = (struct tcphdr *)(iph + 1);
+		if (conn_hash == 0)
+			conn_hash = (ip_fast_csum(&iph->saddr, 2) ^
+				     th->source ^ th->dest);
+	} else if (l3_proto == htons(ETH_P_IPV6)) {
+		struct ipv6hdr *iph = nh;
+		if (iph->nexthdr != NEXTHDR_TCP)
+			goto deliver_now;
+		l2_id |= EFX_SSR_L2_ID_IPV6;
+		th = (struct tcphdr *)(iph + 1);
+		if (conn_hash == 0)
+			conn_hash = (ip_fast_csum(&iph->saddr, 8) ^
+				     th->source ^ th->dest);
+	} else {
+		goto deliver_now;
+	}
+
+	bucket = conn_hash & channel->ssr.conns_mask;
+
+	list_for_each_entry(c, &channel->ssr.conns[bucket], link) {
+		if ((c->l2_id - l2_id) | (c->conn_hash - conn_hash))
+			continue;
+		if ((c->source - th->source) | (c->dest - th->dest))
+			continue;
+		if (c->skb) {
+			if (EFX_SSR_CONN_IS_TCPIPV4(c)) {
+				struct iphdr *c_iph, *iph = nh;
+				c_iph = (struct iphdr *) c->skb->data;
+				if ((c_iph->saddr - iph->saddr) |
+				    (c_iph->daddr - iph->daddr))
+					continue;
+			} else {
+				struct ipv6hdr *c_iph, *iph = nh;
+				c_iph = (struct ipv6hdr *) c->skb->data;
+				if (ipv6_addr_cmp(&c_iph->saddr, &iph->saddr) |
+				    ipv6_addr_cmp(&c_iph->daddr, &iph->daddr))
+					continue;
+			}
+		}
+
+		/* Re-insert at head of list to reduce lookup time. */
+		list_del(&c->link);
+		list_add(&c->link, &channel->ssr.conns[bucket]);
+
+		if (efx_rx_buffer_is_full(&c->next_buf)) {
+			if (!efx_ssr_try_merge(channel, c))
+				goto deliver_now;
+		} else {
+			list_add(&c->active_link, &channel->ssr.active_conns);
+		}
+		c->next_buf = *rx_buf;
+		c->next_eh = efx_rx_buf_eh(efx, rx_buf);
+		efx_rx_buffer_set_empty(rx_buf);
+		c->next_iph = nh;
+		return;
+	}
+
+	efx_ssr_new_conn(&channel->ssr, conn_hash, l2_id, th);
+ deliver_now:
+	efx_rx_deliver(channel, rx_data, rx_buf, 1);
+}
+
+/* Push held skbs down into network stack.
+ * Only called when active list is non-empty.
+ */
+void __efx_ssr_end_of_burst(struct efx_channel *channel)
+{
+	struct efx_ssr_state *st = &channel->ssr;
+	struct efx_ssr_conn *c;
+	unsigned j;
+
+	EFX_BUG_ON_PARANOID(list_empty(&st->active_conns));
+
+	do {
+		c = list_entry(st->active_conns.next, struct efx_ssr_conn,
+			       active_link);
+		if (!c->delivered && c->skb)
+			efx_ssr_deliver(st, c);
+		if (efx_ssr_try_merge(channel, c)) {
+			if (c->skb)
+				efx_ssr_deliver(st, c);
+			list_del(&c->active_link);
+		}
+		c->delivered = 0;
+	} while (!list_empty(&st->active_conns));
+
+	j = jiffies;
+	if (unlikely(j != st->last_purge_jiffies))
+		efx_ssr_purge_idle(channel, j);
+}
+
+
+#endif /* EFX_USE_SFC_LRO */
diff -r 5b3d4d3c1166 drivers/net/sfc/rx.h
--- a/drivers/net/sfc/rx.h	Fri Nov 05 15:20:28 2010 +0000
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,26 +0,0 @@
-/****************************************************************************
- * Driver for Solarflare Solarstorm network controllers and boards
- * Copyright 2006 Solarflare Communications Inc.
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 as published
- * by the Free Software Foundation, incorporated herein by reference.
- */
-
-#ifndef EFX_RX_H
-#define EFX_RX_H
-
-#include "net_driver.h"
-
-int efx_probe_rx_queue(struct efx_rx_queue *rx_queue);
-void efx_remove_rx_queue(struct efx_rx_queue *rx_queue);
-void efx_init_rx_queue(struct efx_rx_queue *rx_queue);
-void efx_fini_rx_queue(struct efx_rx_queue *rx_queue);
-
-void efx_rx_strategy(struct efx_channel *channel);
-void efx_fast_push_rx_descriptors(struct efx_rx_queue *rx_queue);
-void efx_rx_work(struct work_struct *data);
-void __efx_rx_packet(struct efx_channel *channel,
-		     struct efx_rx_buffer *rx_buf, bool checksummed);
-
-#endif /* EFX_RX_H */
diff -r 5b3d4d3c1166 drivers/net/sfc/selftest.c
--- a/drivers/net/sfc/selftest.c	Fri Nov 05 15:20:28 2010 +0000
+++ b/drivers/net/sfc/selftest.c	Tue Nov 09 10:06:27 2010 +0000
@@ -1,7 +1,7 @@
 /****************************************************************************
  * Driver for Solarflare Solarstorm network controllers and boards
  * Copyright 2005-2006 Fen Systems Ltd.
- * Copyright 2006-2008 Solarflare Communications Inc.
+ * Copyright 2006-2009 Solarflare Communications Inc.
  *
  * This program is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 as published
@@ -18,16 +18,13 @@
 #include <linux/in.h>
 #include <linux/udp.h>
 #include <linux/rtnetlink.h>
+#include <linux/slab.h>
 #include <asm/io.h>
 #include "net_driver.h"
-#include "ethtool.h"
 #include "efx.h"
-#include "falcon.h"
+#include "nic.h"
 #include "selftest.h"
-#include "boards.h"
 #include "workarounds.h"
-#include "spi.h"
-#include "falcon_io.h"
 #include "mdio_10g.h"
 
 /*
@@ -42,14 +39,14 @@ struct efx_loopback_payload {
 	struct udphdr udp;
 	__be16 iteration;
 	const char msg[64];
-} __attribute__ ((packed));
+} __packed;
 
 /* Loopback test source MAC address */
 static const unsigned char payload_source[ETH_ALEN] = {
 	0x00, 0x0f, 0x53, 0x1b, 0x1b, 0x1b,
 };
 
-static const char *payload_msg =
+static const char payload_msg[] =
 	"Hello world! This is an Efx loopback test in progress!";
 
 /**
@@ -57,6 +54,7 @@ static const char *payload_msg =
  * @flush:		Drop all packets in efx_loopback_rx_packet
  * @packet_count:	Number of packets being used in this test
  * @skbs:		An array of skbs transmitted
+ * @offload_csum:	Checksums are being offloaded
  * @rx_good:		RX good packet count
  * @rx_bad:		RX bad packet count
  * @payload:		Payload used in tests
@@ -65,14 +63,19 @@ struct efx_loopback_state {
 	bool flush;
 	int packet_count;
 	struct sk_buff **skbs;
-
-	/* Checksums are being offloaded */
 	bool offload_csum;
-
 	atomic_t rx_good;
 	atomic_t rx_bad;
 	struct efx_loopback_payload payload;
 };
+
+/* How long to wait for all the packets to arrive (in ms) */
+#if defined(EFX_NOT_UPSTREAM) && defined(EFX_VMWARE_3_DOT_5)
+/* ESX3.5 with serial logging on can take a _long_ time.*/
+#define LOOPBACK_TIMEOUT_MS (1000)
+#else
+#define LOOPBACK_TIMEOUT_MS (100)
+#endif
 
 /**************************************************************************
  *
@@ -80,61 +83,106 @@ struct efx_loopback_state {
  *
  **************************************************************************/
 
-static int efx_test_mdio(struct efx_nic *efx, struct efx_self_tests *tests)
+static int efx_test_phy_alive(struct efx_nic *efx, struct efx_self_tests *tests)
 {
 	int rc = 0;
-	int devad = __ffs(efx->mdio.mmds);
-	u16 physid1, physid2;
 
-	if (efx->phy_type == PHY_TYPE_NONE)
-		return 0;
-
-	mutex_lock(&efx->mac_lock);
-	tests->mdio = -1;
-
-	physid1 = efx_mdio_read(efx, devad, MDIO_DEVID1);
-	physid2 = efx_mdio_read(efx, devad, MDIO_DEVID2);
-
-	if ((physid1 == 0x0000) || (physid1 == 0xffff) ||
-	    (physid2 == 0x0000) || (physid2 == 0xffff)) {
-		EFX_ERR(efx, "no MDIO PHY present with ID %d\n",
-			efx->mdio.prtad);
-		rc = -EINVAL;
-		goto out;
+	if (efx->phy_op->test_alive) {
+		rc = efx->phy_op->test_alive(efx);
+		netif_dbg(efx, drv, efx->net_dev, "%s PHY liveness selftest\n",
+			  rc ? "Failed" : "Passed");
+		tests->phy_alive = rc ? -1 : 1;
 	}
 
-	if (EFX_IS10G(efx)) {
-		rc = efx_mdio_check_mmds(efx, efx->phy_op->mmds, 0);
-		if (rc)
-			goto out;
-	}
-
-out:
-	mutex_unlock(&efx->mac_lock);
-	tests->mdio = rc ? -1 : 1;
 	return rc;
 }
 
 static int efx_test_nvram(struct efx_nic *efx, struct efx_self_tests *tests)
 {
-	int rc;
+	int rc = 0;
 
-	rc = falcon_read_nvram(efx, NULL);
-	tests->nvram = rc ? -1 : 1;
+	if (efx->type->test_nvram) {
+		rc = efx->type->test_nvram(efx);
+		tests->nvram = rc ? -1 : 1;
+	}
+
 	return rc;
 }
 
+static void memtest_simple(unsigned id, efx_qword_t *reg, int a, int b)
+{
+	EFX_POPULATE_QWORD_2(*reg, EFX_DWORD_0, a, EFX_DWORD_1, b);
+}
+
+static void memtest_changing_bytes(unsigned id, efx_qword_t *reg,
+				   int a, int b)
+{
+	int i;
+	u8 *byte;
+	for (i = 0; i < sizeof(efx_qword_t); i++) {
+		unsigned int addr = id * sizeof(efx_qword_t) + i;
+		byte = (u8 *)reg + i;
+		if ((addr >> 8) == 0)
+			*byte = (u8) (addr % 257);
+		else
+			*byte = (u8) ~((addr >> 8) % 257);
+
+		if (addr & 0x40)
+			*byte = ~*byte;
+	}
+}
+
+static void memtest_bit_sweep(unsigned int id, efx_qword_t *reg,
+			      int a, int b)
+{
+	int bit = id % 64;
+	int xor = (id & 64) ? ~0 : 0;
+
+	EFX_POPULATE_QWORD_2(*reg,
+			     EFX_DWORD_0, (bit < 32 ? bit : 0) ^ xor,
+			     EFX_DWORD_1, (bit >= 32 ? bit - 32 : 0) ^ xor);
+}
+
+struct memtest {
+	void (*pattern)(unsigned id, efx_qword_t *reg, int a, int b);
+	int a;
+	int b;
+};
+
+static struct memtest memtests[] = {
+	{memtest_simple, 0x55AA55AA, 0x55AA55AA},
+	{memtest_simple, 0xAA55AA55, 0xAA55AA55},
+	{memtest_changing_bytes, 0, 0},
+	{memtest_bit_sweep, 0, 0},
+};
+
 static int efx_test_chip(struct efx_nic *efx, struct efx_self_tests *tests)
 {
-	int rc;
+	int rc, i;
 
-	/* Not supported on A-series silicon */
-	if (falcon_rev(efx) < FALCON_REV_B0)
-		return 0;
+	/* Test SRAM and register tables */
+	if (efx->type->test_memory) {
+		for (i = 0; i < ARRAY_SIZE(memtests); ++i) {
+			rc = efx->type->test_memory(
+				efx, memtests[i].pattern,
+				memtests[i].a, memtests[i].b);
+			if (rc)
+				break;
+		}
+		netif_dbg(efx, drv, efx->net_dev, "%s memory selftest\n",
+			  rc ? "Failed" : "Passed");
+		tests->memory = rc ? -1 : 1;
+	}
 
-	rc = falcon_test_registers(efx);
-	tests->registers = rc ? -1 : 1;
-	return rc;
+	/* Test register access */
+	if (efx->type->test_registers) {
+		rc = efx->type->test_registers(efx);
+		netif_dbg(efx, drv, efx->net_dev, "%s register selftest\n",
+			  rc ? "Failed" : "Passed");
+		tests->registers = rc ? -1 : 1;
+	}
+
+	return (tests->memory >= 0 && tests->registers >= 0) ? 0 : -EIO;
 }
 
 /**************************************************************************
@@ -149,7 +197,7 @@ static int efx_test_interrupts(struct ef
 {
 	struct efx_channel *channel;
 
-	EFX_LOG(efx, "testing interrupts\n");
+	netif_dbg(efx, drv, efx->net_dev, "testing interrupts\n");
 	tests->interrupt = -1;
 
 	/* Reset interrupt flag */
@@ -165,20 +213,21 @@ static int efx_test_interrupts(struct ef
 			goto success;
 	}
 
-	falcon_generate_interrupt(efx);
+	efx_nic_generate_interrupt(efx);
 
 	/* Wait for arrival of test interrupt. */
-	EFX_LOG(efx, "waiting for test interrupt\n");
+	netif_dbg(efx, drv, efx->net_dev, "waiting for test interrupt\n");
 	schedule_timeout_uninterruptible(HZ / 10);
 	if (efx->last_irq_cpu >= 0)
 		goto success;
 
-	EFX_ERR(efx, "timed out waiting for interrupt\n");
+	netif_err(efx, drv, efx->net_dev, "timed out waiting for interrupt\n");
 	return -ETIMEDOUT;
 
  success:
-	EFX_LOG(efx, "test interrupt (mode %d) seen on CPU%d\n",
-		efx->interrupt_mode, efx->last_irq_cpu);
+	netif_dbg(efx, drv, efx->net_dev, "%s test interrupt seen on CPU%d\n",
+		  INT_MODE(efx),
+		efx->last_irq_cpu);
 	tests->interrupt = 1;
 	return 0;
 }
@@ -187,23 +236,18 @@ static int efx_test_eventq_irq(struct ef
 static int efx_test_eventq_irq(struct efx_channel *channel,
 			       struct efx_self_tests *tests)
 {
-	unsigned int magic, count;
-
-	/* Channel specific code, limited to 20 bits */
-	magic = (0x00010150 + channel->channel);
-	EFX_LOG(channel->efx, "channel %d testing event queue with code %x\n",
-		channel->channel, magic);
+	struct efx_nic *efx = channel->efx;
+	unsigned int magic_count, count;
 
 	tests->eventq_dma[channel->channel] = -1;
 	tests->eventq_int[channel->channel] = -1;
 	tests->eventq_poll[channel->channel] = -1;
 
-	/* Reset flag and zero magic word */
+	magic_count = channel->magic_count;
 	channel->efx->last_irq_cpu = -1;
-	channel->eventq_magic = 0;
 	smp_wmb();
 
-	falcon_generate_test_event(channel, magic);
+	efx_nic_generate_test_event(channel);
 
 	/* Wait for arrival of interrupt */
 	count = 0;
@@ -213,33 +257,36 @@ static int efx_test_eventq_irq(struct ef
 		if (channel->work_pending)
 			efx_process_channel_now(channel);
 
-		if (channel->eventq_magic == magic)
+		if (channel->magic_count != magic_count)
 			goto eventq_ok;
 	} while (++count < 2);
 
-	EFX_ERR(channel->efx, "channel %d timed out waiting for event queue\n",
-		channel->channel);
+	netif_err(efx, drv, efx->net_dev,
+		  "channel %d timed out waiting for event queue\n",
+		  channel->channel);
 
 	/* See if interrupt arrived */
 	if (channel->efx->last_irq_cpu >= 0) {
-		EFX_ERR(channel->efx, "channel %d saw interrupt on CPU%d "
-			"during event queue test\n", channel->channel,
-			raw_smp_processor_id());
+		netif_err(efx, drv, efx->net_dev,
+			  "channel %d saw interrupt on CPU%d "
+			  "during event queue test\n", channel->channel,
+			  raw_smp_processor_id());
 		tests->eventq_int[channel->channel] = 1;
 	}
 
 	/* Check to see if event was received even if interrupt wasn't */
 	efx_process_channel_now(channel);
-	if (channel->eventq_magic == magic) {
-		EFX_ERR(channel->efx, "channel %d event was generated, but "
-			"failed to trigger an interrupt\n", channel->channel);
+	if (channel->magic_count != magic_count) {
+		netif_err(efx, drv, efx->net_dev,
+			  "channel %d event was generated, but "
+			  "failed to trigger an interrupt\n", channel->channel);
 		tests->eventq_dma[channel->channel] = 1;
 	}
 
 	return -ETIMEDOUT;
  eventq_ok:
-	EFX_LOG(channel->efx, "channel %d event queue passed\n",
-		channel->channel);
+	netif_dbg(efx, drv, efx->net_dev, "channel %d event queue passed\n",
+		  channel->channel);
 	tests->eventq_dma[channel->channel] = 1;
 	tests->eventq_int[channel->channel] = 1;
 	tests->eventq_poll[channel->channel] = 1;
@@ -254,12 +301,11 @@ static int efx_test_phy(struct efx_nic *
 	if (!efx->phy_op->run_tests)
 		return 0;
 
-	EFX_BUG_ON_PARANOID(efx->phy_op->num_tests == 0 ||
-			    efx->phy_op->num_tests > EFX_MAX_PHY_TESTS);
-
 	mutex_lock(&efx->mac_lock);
-	rc = efx->phy_op->run_tests(efx, tests->phy, flags);
+	rc = efx->phy_op->run_tests(efx, tests->phy_ext, flags);
 	mutex_unlock(&efx->mac_lock);
+	netif_info(efx, drv, efx->net_dev,
+		   "%s phy selftest\n", rc ? "Failed" : "Passed");
 	return rc;
 }
 
@@ -295,51 +341,57 @@ void efx_loopback_rx_packet(struct efx_n
 
 	/* Check that header exists */
 	if (pkt_len < sizeof(received->header)) {
-		EFX_ERR(efx, "saw runt RX packet (length %d) in %s loopback "
-			"test\n", pkt_len, LOOPBACK_MODE(efx));
+		netif_err(efx, drv, efx->net_dev,
+			  "saw runt RX packet (length %d) in %s loopback "
+			  "test\n", pkt_len, LOOPBACK_MODE(efx));
 		goto err;
 	}
 
 	/* Check that the ethernet header exists */
 	if (memcmp(&received->header, &payload->header, ETH_HLEN) != 0) {
-		EFX_ERR(efx, "saw non-loopback RX packet in %s loopback test\n",
-			LOOPBACK_MODE(efx));
+		netif_err(efx, drv, efx->net_dev,
+			  "saw non-loopback RX packet in %s loopback test\n",
+			  LOOPBACK_MODE(efx));
 		goto err;
 	}
 
 	/* Check packet length */
 	if (pkt_len != sizeof(*payload)) {
-		EFX_ERR(efx, "saw incorrect RX packet length %d (wanted %d) in "
-			"%s loopback test\n", pkt_len, (int)sizeof(*payload),
-			LOOPBACK_MODE(efx));
+		netif_err(efx, drv, efx->net_dev,
+			  "saw incorrect RX packet length %d (wanted %d) in "
+			  "%s loopback test\n", pkt_len, (int)sizeof(*payload),
+			  LOOPBACK_MODE(efx));
 		goto err;
 	}
 
 	/* Check that IP header matches */
 	if (memcmp(&received->ip, &payload->ip, sizeof(payload->ip)) != 0) {
-		EFX_ERR(efx, "saw corrupted IP header in %s loopback test\n",
-			LOOPBACK_MODE(efx));
+		netif_err(efx, drv, efx->net_dev,
+			  "saw corrupted IP header in %s loopback test\n",
+			  LOOPBACK_MODE(efx));
 		goto err;
 	}
 
 	/* Check that msg and padding matches */
 	if (memcmp(&received->msg, &payload->msg, sizeof(received->msg)) != 0) {
-		EFX_ERR(efx, "saw corrupted RX packet in %s loopback test\n",
-			LOOPBACK_MODE(efx));
+		netif_err(efx, drv, efx->net_dev,
+			  "saw corrupted RX packet in %s loopback test\n",
+			  LOOPBACK_MODE(efx));
 		goto err;
 	}
 
 	/* Check that iteration matches */
 	if (received->iteration != payload->iteration) {
-		EFX_ERR(efx, "saw RX packet from iteration %d (wanted %d) in "
-			"%s loopback test\n", ntohs(received->iteration),
-			ntohs(payload->iteration), LOOPBACK_MODE(efx));
+		netif_err(efx, drv, efx->net_dev,
+			  "saw RX packet from iteration %d (wanted %d) in "
+			  "%s loopback test\n", ntohs(received->iteration),
+			  ntohs(payload->iteration), LOOPBACK_MODE(efx));
 		goto err;
 	}
 
 	/* Increase correct RX count */
-	EFX_TRACE(efx, "got loopback RX in %s loopback test\n",
-		  LOOPBACK_MODE(efx));
+	netif_vdbg(efx, drv, efx->net_dev,
+		   "got loopback RX in %s loopback test\n", LOOPBACK_MODE(efx));
 
 	atomic_inc(&state->rx_good);
 	return;
@@ -347,10 +399,10 @@ void efx_loopback_rx_packet(struct efx_n
  err:
 #ifdef EFX_ENABLE_DEBUG
 	if (atomic_read(&state->rx_bad) == 0) {
-		EFX_ERR(efx, "received packet:\n");
+		netif_err(efx, drv, efx->net_dev, "received packet:\n");
 		print_hex_dump(KERN_ERR, "", DUMP_PREFIX_OFFSET, 0x10, 1,
 			       buf_ptr, pkt_len, 0);
-		EFX_ERR(efx, "expected packet:\n");
+		netif_err(efx, drv, efx->net_dev, "expected packet:\n");
 		print_hex_dump(KERN_ERR, "", DUMP_PREFIX_OFFSET, 0x10, 1,
 			       &state->payload, sizeof(state->payload), 0);
 	}
@@ -426,20 +478,21 @@ static int efx_begin_loopback(struct efx
 
 		if (efx_dev_registered(efx))
 			netif_tx_lock_bh(efx->net_dev);
-		rc = efx_xmit(efx, tx_queue, skb);
+		rc = efx_enqueue_skb(tx_queue, skb);
 		if (efx_dev_registered(efx))
 			netif_tx_unlock_bh(efx->net_dev);
 
 		if (rc != NETDEV_TX_OK) {
-			EFX_ERR(efx, "TX queue %d could not transmit packet %d "
-				"of %d in %s loopback test\n", tx_queue->queue,
-				i + 1, state->packet_count, LOOPBACK_MODE(efx));
+			netif_err(efx, drv, efx->net_dev,
+				  "TX queue %d could not transmit packet %d of "
+				  "%d in %s loopback test\n", tx_queue->queue,
+				  i + 1, state->packet_count,
+				  LOOPBACK_MODE(efx));
 
 			/* Defer cleaning up the other skbs for the caller */
 			kfree_skb(skb);
 			return -EPIPE;
 		}
-		efx->net_dev->trans_start = jiffies;
 	}
 
 	return 0;
@@ -448,6 +501,7 @@ static int efx_poll_loopback(struct efx_
 static int efx_poll_loopback(struct efx_nic *efx)
 {
 	struct efx_loopback_state *state = efx->loopback_selftest;
+#if !defined(EFX_USE_KCOMPAT) || !defined(EFX_HAVE_OLD_NAPI)
 	struct efx_channel *channel;
 
 	/* NAPI polling is not enabled, so process channels
@@ -456,6 +510,7 @@ static int efx_poll_loopback(struct efx_
 		if (channel->work_pending)
 			efx_process_channel_now(channel);
 	}
+#endif
 	return atomic_read(&state->rx_good) == state->packet_count;
 }
 
@@ -490,20 +545,22 @@ static int efx_end_loopback(struct efx_t
 		/* Don't free the skbs; they will be picked up on TX
 		 * overflow or channel teardown.
 		 */
-		EFX_ERR(efx, "TX queue %d saw only %d out of an expected %d "
-			"TX completion events in %s loopback test\n",
-			tx_queue->queue, tx_done, state->packet_count,
-			LOOPBACK_MODE(efx));
+		netif_err(efx, drv, efx->net_dev,
+			  "TX queue %d saw only %d out of an expected %d "
+			  "TX completion events in %s loopback test\n",
+			  tx_queue->queue, tx_done, state->packet_count,
+			  LOOPBACK_MODE(efx));
 		rc = -ETIMEDOUT;
 		/* Allow to fall through so we see the RX errors as well */
 	}
 
 	/* We may always be up to a flush away from our desired packet total */
 	if (rx_good != state->packet_count) {
-		EFX_LOG(efx, "TX queue %d saw only %d out of an expected %d "
-			"received packets in %s loopback test\n",
-			tx_queue->queue, rx_good, state->packet_count,
-			LOOPBACK_MODE(efx));
+		netif_dbg(efx, drv, efx->net_dev,
+			  "TX queue %d saw only %d out of an expected %d "
+			  "received packets in %s loopback test\n",
+			  tx_queue->queue, rx_good, state->packet_count,
+			  LOOPBACK_MODE(efx));
 		rc = -ETIMEDOUT;
 		/* Fall through */
 	}
@@ -519,15 +576,16 @@ static int efx_end_loopback(struct efx_t
 
 static int
 efx_test_loopback(struct efx_tx_queue *tx_queue,
-		  struct efx_loopback_self_tests *lb_tests)
+		  struct efx_loopback_self_tests *lb_tests,
+		  int level)
 {
 	struct efx_nic *efx = tx_queue->efx;
 	struct efx_loopback_state *state = efx->loopback_selftest;
 	int i, begin_rc, end_rc;
 
-	for (i = 0; i < 3; i++) {
-		/* Determine how many packets to send */
-		state->packet_count = (efx->type->txd_ring_mask + 1) / 3;
+	for (i = 0; i < level; i++) {
+		/* Determine how many packets to send - up to 16**(level-1) */
+		state->packet_count = efx->txq_entries / 3;
 		state->packet_count = min(1 << (i << 2), state->packet_count);
 		state->skbs = kzalloc(sizeof(state->skbs[0]) *
 				      state->packet_count, GFP_KERNEL);
@@ -535,18 +593,19 @@ efx_test_loopback(struct efx_tx_queue *t
 			return -ENOMEM;
 		state->flush = false;
 
-		EFX_LOG(efx, "TX queue %d testing %s loopback with %d "
-			"packets\n", tx_queue->queue, LOOPBACK_MODE(efx),
-			state->packet_count);
+		netif_dbg(efx, drv, efx->net_dev,
+			  "TX queue %d testing %s loopback with %d packets\n",
+			  tx_queue->queue, LOOPBACK_MODE(efx),
+			  state->packet_count);
 
 		efx_iterate_state(efx);
 		begin_rc = efx_begin_loopback(tx_queue);
 
 		/* This will normally complete very quickly, but be
-		 * prepared to wait up to 100 ms. */
+		 * prepared to wait much longer. */
 		msleep(1);
 		if (!efx_poll_loopback(efx)) {
-			msleep(100);
+			msleep(LOOPBACK_TIMEOUT_MS);
 			efx_poll_loopback(efx);
 		}
 
@@ -561,21 +620,65 @@ efx_test_loopback(struct efx_tx_queue *t
 		}
 	}
 
-	EFX_LOG(efx, "TX queue %d passed %s loopback test with a burst length "
-		"of %d packets\n", tx_queue->queue, LOOPBACK_MODE(efx),
-		state->packet_count);
+	netif_dbg(efx, drv, efx->net_dev,
+		  "TX queue %d passed %s loopback test with a burst length "
+		  "of %d packets\n", tx_queue->queue, LOOPBACK_MODE(efx),
+		  state->packet_count);
 
 	return 0;
 }
 
+/* Wait for link up. On Falcon, we would prefer to rely on efx_monitor, but
+ * any contention on the mac lock (via e.g. efx_mac_mcast_work) causes it
+ * to delay and retry. Therefore, it's safer to just poll directly. Wait
+ * for link up and any faults to dissipate. */
+static int efx_wait_for_link(struct efx_nic *efx)
+{
+	struct efx_link_state *link_state = &efx->link_state;
+	int count, link_up_count = 0;
+	bool link_up;
+
+	for (count = 0; count < 40; count++) {
+		schedule_timeout_uninterruptible(HZ / 10);
+
+		if (efx->type->monitor != NULL) {
+			mutex_lock(&efx->mac_lock);
+			efx->type->monitor(efx);
+			mutex_unlock(&efx->mac_lock);
+		} else {
+#if !defined(EFX_USE_KCOMPAT) || !defined(EFX_HAVE_OLD_NAPI)
+			struct efx_channel *channel = efx_get_channel(efx, 0);
+			if (channel->work_pending)
+				efx_process_channel_now(channel);
+#endif
+		}
+
+		mutex_lock(&efx->mac_lock);
+		link_up = link_state->up;
+		if (link_up)
+			link_up = !efx->mac_op->check_fault(efx);
+		mutex_unlock(&efx->mac_lock);
+
+		if (link_up) {
+			if (++link_up_count == 2)
+				return 0;
+		} else {
+			link_up_count = 0;
+		}
+	}
+
+	return -ETIMEDOUT;
+}
+
 static int efx_test_loopbacks(struct efx_nic *efx, struct efx_self_tests *tests,
-			      unsigned int loopback_modes)
+			      unsigned int loopback_modes, int level)
 {
 	enum efx_loopback_mode mode;
 	struct efx_loopback_state *state;
+	struct efx_channel *channel = efx_get_channel(efx, 0);
 	struct efx_tx_queue *tx_queue;
-	bool link_up;
-	int count, rc = 0;
+	int rc = 0;
+	bool retry;
 
 	/* Set the port loopback_selftest member. From this point on
 	 * all received packets will be dropped. Mark the state as
@@ -592,56 +695,59 @@ static int efx_test_loopbacks(struct efx
 		if (!(loopback_modes & (1 << mode)))
 			continue;
 
+		retry = EFX_WORKAROUND_8568(efx);
+	set_loopback:
 		/* Move the port into the specified loopback mode. */
 		state->flush = true;
+		mutex_lock(&efx->mac_lock);
 		efx->loopback_mode = mode;
-		efx_reconfigure_port(efx);
-
-		/* Wait for the PHY to signal the link is up. Interrupts
-		 * are enabled for PHY's using LASI, otherwise we poll()
-		 * quickly */
-		count = 0;
-		do {
-			struct efx_channel *channel = &efx->channel[0];
-
-			efx->phy_op->poll(efx);
-			schedule_timeout_uninterruptible(HZ / 10);
-			if (channel->work_pending)
-				efx_process_channel_now(channel);
-			/* Wait for PHY events to be processed */
-			flush_workqueue(efx->workqueue);
-			rmb();
-
-			/* We need both the phy and xaui links to be ok.
-			 * rather than relying on the falcon_xmac irq/poll
-			 * regime, just poll xaui directly */
-			link_up = efx->link_up;
-			if (link_up && EFX_IS10G(efx) &&
-			    !falcon_xaui_link_ok(efx))
-				link_up = false;
-
-		} while ((++count < 20) && !link_up);
-
-		/* The link should now be up. If it isn't, there is no point
-		 * in attempting a loopback test */
-		if (!link_up) {
-			EFX_ERR(efx, "loopback %s never came up\n",
-				LOOPBACK_MODE(efx));
-			rc = -EIO;
+		rc = __efx_reconfigure_port(efx);
+		mutex_unlock(&efx->mac_lock);
+		if (rc) {
+			netif_err(efx, drv, efx->net_dev,
+				  "unable to move into %s loopback\n",
+				  LOOPBACK_MODE(efx));
 			goto out;
 		}
 
-		EFX_LOG(efx, "link came up in %s loopback in %d iterations\n",
-			LOOPBACK_MODE(efx), count);
+		rc = efx_wait_for_link(efx);
+		if (rc) {
+			netif_err(efx, drv, efx->net_dev,
+				  "loopback %s never came up\n",
+				  LOOPBACK_MODE(efx));
+			goto out;
+		}
 
-		/* Test every TX queue */
-		efx_for_each_tx_queue(tx_queue, efx) {
-			state->offload_csum = (tx_queue->queue ==
-					       EFX_TX_QUEUE_OFFLOAD_CSUM);
+		/* Test both types of TX queue */
+		efx_for_each_channel_tx_queue(tx_queue, channel) {
+			state->offload_csum = (tx_queue->queue &
+					       EFX_TXQ_TYPE_OFFLOAD);
 			rc = efx_test_loopback(tx_queue,
-					       &tests->loopback[mode]);
-			if (rc)
+					       &tests->loopback[mode],
+					       level);
+			if (rc && !retry)
 				goto out;
+			if (rc) {
+				/* Give the PHY a kick by moving into
+				 * a Falcon internal loopback mode and
+				 * then back out */
+				int first = ffs(efx->loopback_modes) - 1;
+
+				netif_info(efx, drv, efx->net_dev,
+					   "retrying %s loopback\n",
+					   LOOPBACK_MODE(efx));
+
+				state->flush = true;
+				mutex_lock(&efx->mac_lock);
+				efx->loopback_mode = first;
+				__efx_reconfigure_port(efx);
+				mutex_unlock(&efx->mac_lock);
+
+				memset(&tests->loopback[mode], 0,
+				       sizeof(tests->loopback[mode]));
+				retry = false;
+				goto set_loopback;
+			}
 		}
 	}
 
@@ -666,21 +772,25 @@ int efx_selftest(struct efx_nic *efx, st
 {
 	enum efx_loopback_mode loopback_mode = efx->loopback_mode;
 	int phy_mode = efx->phy_mode;
-	enum reset_type reset_method = RESET_TYPE_INVISIBLE;
-	struct ethtool_cmd ecmd;
 	struct efx_channel *channel;
 	int rc_test = 0, rc_reset = 0, rc;
 
 	/* Online (i.e. non-disruptive) testing
 	 * This checks interrupt generation, event delivery and PHY presence. */
 
-	rc = efx_test_mdio(efx, tests);
-	if (rc && !rc_test)
-		rc_test = rc;
+#ifdef EFX_NOT_UPSTREAM
+	/* Don't repeat standard initialisation during the onload online test */
+	if (!(flags & EFX_TEST_FL_ONLOAD)) 
+#endif
+	{
+		rc = efx_test_phy_alive(efx, tests);
+		if (rc && !rc_test)
+			rc_test = rc;
 
-	rc = efx_test_nvram(efx, tests);
-	if (rc && !rc_test)
-		rc_test = rc;
+		rc = efx_test_nvram(efx, tests);
+		if (rc && !rc_test)
+			rc_test = rc;
+	}
 
 	rc = efx_test_interrupts(efx, tests);
 	if (rc && !rc_test)
@@ -695,8 +805,14 @@ int efx_selftest(struct efx_nic *efx, st
 	if (rc_test)
 		return rc_test;
 
-	if (!(flags & ETH_TEST_FL_OFFLINE))
-		return efx_test_phy(efx, tests, flags);
+	if (!(flags & ETH_TEST_FL_OFFLINE)) {
+#ifdef EFX_NOT_UPSTREAM
+		if (flags & EFX_TEST_FL_ONLOAD)
+			return 0;
+		else
+#endif
+			return efx_test_phy(efx, tests, flags);
+	}
 
 	/* Offline (i.e. disruptive) testing
 	 * This checks MAC and PHY loopback on the specified port. */
@@ -707,7 +823,11 @@ int efx_selftest(struct efx_nic *efx, st
 	 */
 	mutex_lock(&efx->mac_lock);
 	efx->port_inhibited = true;
+#ifdef EFX_NOT_UPSTREAM
+	if (!(flags & EFX_TEST_FL_ONLOAD) && efx->loopback_modes) {
+#else
 	if (efx->loopback_modes) {
+#endif
 		/* We need the 312 clock from the PHY to test the XMAC
 		 * registers, so move into XGMII loopback if available */
 		if (efx->loopback_modes & (1 << LOOPBACK_XGMII))
@@ -719,44 +839,63 @@ int efx_selftest(struct efx_nic *efx, st
 	__efx_reconfigure_port(efx);
 	mutex_unlock(&efx->mac_lock);
 
-	/* free up all consumers of SRAM (including all the queues) */
-	efx_reset_down(efx, reset_method, &ecmd);
+#ifdef EFX_NOT_UPSTREAM
+	if (!(flags & EFX_TEST_FL_ONLOAD))
+#endif
+	{
+		enum reset_type method = RESET_TYPE_INVISIBLE;
 
-	rc = efx_test_chip(efx, tests);
-	if (rc && !rc_test)
-		rc_test = rc;
+		/* free up all consumers of SRAM (including all the queues) */
+		efx_dl_reset_suspend(efx);
+		efx_reset_down(efx, method);
 
-	/* reset the chip to recover from the register test */
-	rc_reset = falcon_reset_hw(efx, reset_method);
+		rc = efx_test_chip(efx, tests);
+		if (rc && !rc_test)
+			rc_test = rc;
 
-	/* Ensure that the phy is powered and out of loopback
-	 * for the bist and loopback tests */
-	efx->phy_mode &= ~PHY_MODE_LOW_POWER;
-	efx->loopback_mode = LOOPBACK_NONE;
+		/* reset the chip to recover from the register test */
+		rc_reset = efx->type->reset(efx, method);
 
-	rc = efx_reset_up(efx, reset_method, &ecmd, rc_reset == 0);
-	if (rc && !rc_reset)
-		rc_reset = rc;
+		/* Ensure that the phy is powered and out of loopback
+		 * for the bist and loopback tests */
+		efx->phy_mode &= ~PHY_MODE_LOW_POWER;
+		efx->loopback_mode = LOOPBACK_NONE;
+		rc = efx_reset_up(efx, method, rc_reset == 0);
+		if (rc && !rc_reset)
+			rc_reset = rc;
+		efx_dl_reset_resume(efx, rc_reset == 0);
 
-	if (rc_reset) {
-		EFX_ERR(efx, "Unable to recover from chip test\n");
-		efx_schedule_reset(efx, RESET_TYPE_DISABLE);
-		return rc_reset;
+		if (rc_reset) {
+			netif_err(efx, hw, efx->net_dev,
+				  "Unable to recover from chip test\n");
+			efx_schedule_reset(efx, RESET_TYPE_DISABLE);
+			return rc_reset;
+		}
+
+		rc = efx_test_phy(efx, tests, flags);
+		if (rc && !rc_test)
+			rc_test = rc;
+
+		rc = efx_test_loopbacks(efx, tests, efx->loopback_modes, 3);
+		if (rc && !rc_test)
+			rc_test = rc;
 	}
-
-	rc = efx_test_phy(efx, tests, flags);
-	if (rc && !rc_test)
-		rc_test = rc;
-
-	rc = efx_test_loopbacks(efx, tests, efx->loopback_modes);
-	if (rc && !rc_test)
-		rc_test = rc;
+#ifdef EFX_NOT_UPSTREAM
+	else {
+		rc = efx_test_loopbacks(efx, tests,
+					1 << efx->startup_loopback_mode, 2);
+		if (rc && !rc_test)
+			rc_test = rc;
+	}
+#endif
 
 	/* restore the PHY to the previous state */
-	efx->loopback_mode = loopback_mode;
+	mutex_lock(&efx->mac_lock);
 	efx->phy_mode = phy_mode;
 	efx->port_inhibited = false;
-	efx_ethtool_set_settings(efx->net_dev, &ecmd);
+	efx->loopback_mode = loopback_mode;
+	__efx_reconfigure_port(efx);
+	mutex_unlock(&efx->mac_lock);
 
 	return rc_test;
 }
diff -r 5b3d4d3c1166 drivers/net/sfc/selftest.h
--- a/drivers/net/sfc/selftest.h	Fri Nov 05 15:20:28 2010 +0000
+++ b/drivers/net/sfc/selftest.h	Tue Nov 09 10:06:27 2010 +0000
@@ -18,8 +18,8 @@
  */
 
 struct efx_loopback_self_tests {
-	int tx_sent[EFX_TX_QUEUE_COUNT];
-	int tx_done[EFX_TX_QUEUE_COUNT];
+	int tx_sent[EFX_TXQ_TYPES];
+	int tx_done[EFX_TXQ_TYPES];
 	int rx_good;
 	int rx_bad;
 };
@@ -32,15 +32,16 @@ struct efx_loopback_self_tests {
  */
 struct efx_self_tests {
 	/* online tests */
-	int mdio;
+	int phy_alive;
 	int nvram;
 	int interrupt;
 	int eventq_dma[EFX_MAX_CHANNELS];
 	int eventq_int[EFX_MAX_CHANNELS];
 	int eventq_poll[EFX_MAX_CHANNELS];
 	/* offline tests */
+	int memory;
 	int registers;
-	int phy[EFX_MAX_PHY_TESTS];
+	int phy_ext[EFX_MAX_PHY_TESTS];
 	struct efx_loopback_self_tests loopback[LOOPBACK_TEST_MAX + 1];
 };
 
@@ -49,5 +50,11 @@ extern int efx_selftest(struct efx_nic *
 extern int efx_selftest(struct efx_nic *efx,
 			struct efx_self_tests *tests,
 			unsigned flags);
+#ifdef EFX_NOT_UPSTREAM
+/* Valid flags are ETH_TEST_FL_OFFLINE and the following */
+enum {
+	EFX_TEST_FL_ONLOAD = (1 << 16), /* quick test at probe time */
+};
+#endif
 
 #endif /* EFX_SELFTEST_H */
diff -r 5b3d4d3c1166 drivers/net/sfc/sfc_resource/Makefile
--- a/drivers/net/sfc/sfc_resource/Makefile	Fri Nov 05 15:20:28 2010 +0000
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,14 +0,0 @@
-obj-$(CONFIG_SFC_RESOURCE) := sfc_resource.o
-
-EXTRA_CFLAGS += -D__CI_HARDWARE_CONFIG_FALCON__
-EXTRA_CFLAGS += -D__ci_driver__
-EXTRA_CFLAGS += -Werror
-EXTRA_CFLAGS += -Idrivers/net/sfc -Idrivers/net/sfc/sfc_resource
-
-sfc_resource-objs := resource_driver.o iopage.o efx_vi_shm.o \
-	driverlink_new.o kernel_proc.o kfifo.o \
-	nic.o eventq.o falcon.o falcon_hash.o \
-	assert_valid.o buddy.o buffer_table.o filter_resource.o \
-	iobufset_resource.o resource_manager.o resources.o \
-	vi_resource_alloc.o vi_resource_event.o vi_resource_flush.o \
-	vi_resource_manager.o driver_object.o kernel_compat.o
diff -r 5b3d4d3c1166 drivers/net/sfc/sfc_resource/assert_valid.c
--- a/drivers/net/sfc/sfc_resource/assert_valid.c	Fri Nov 05 15:20:28 2010 +0000
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,92 +0,0 @@
-/****************************************************************************
- * Driver for Solarflare network controllers -
- *          resource management for Xen backend, OpenOnload, etc
- *           (including support for SFE4001 10GBT NIC)
- *
- * This file contains functions to assert validness of resources and
- * resource manager in DEBUG build of the resource driver.
- *
- * Copyright 2005-2007: Solarflare Communications Inc,
- *                      9501 Jeronimo Road, Suite 250,
- *                      Irvine, CA 92618, USA
- *
- * Developed and maintained by Solarflare Communications:
- *                      <linux-xen-drivers@solarflare.com>
- *                      <onload-dev@solarflare.com>
- *
- * Certain parts of the driver were implemented by
- *          Alexandra Kossovsky <Alexandra.Kossovsky@oktetlabs.ru>
- *          OKTET Labs Ltd, Russia,
- *          http://oktetlabs.ru, <info@oktetlabs.ru>
- *          by request of Solarflare Communications
- *
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 as published
- * by the Free Software Foundation, incorporated herein by reference.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
- ****************************************************************************
- */
-
-#include <ci/efrm/sysdep.h>
-
-#ifndef NDEBUG
-#include <ci/efrm/resource.h>
-#include <ci/efrm/driver_private.h>
-#include <ci/efrm/debug.h>
-
-void
-efrm_resource_manager_assert_valid(struct efrm_resource_manager *rm,
-				   const char *file, int line)
-{
-	_EFRM_ASSERT(rm, file, line);
-	_EFRM_ASSERT(rm->rm_name, file, line);
-	_EFRM_ASSERT(rm->rm_type < EFRM_RESOURCE_NUM, file, line);
-	_EFRM_ASSERT(rm->rm_dtor, file, line);
-}
-EXPORT_SYMBOL(efrm_resource_manager_assert_valid);
-
-/*
- * \param rs                    resource to validate
- * \param ref_count_is_zero     One of 3 values
- *                                > 0  - check ref count is zero
- *                                = 0  - check ref count is non-zero
- *                                < 0  - ref count could be any value
- */
-void
-efrm_resource_assert_valid(struct efrm_resource *rs, int ref_count_is_zero,
-			   const char *file, int line)
-{
-	struct efrm_resource_manager *rm;
-
-	_EFRM_ASSERT(rs, file, line);
-
-	if (ref_count_is_zero >= 0) {
-		if (!(ref_count_is_zero || rs->rs_ref_count > 0)
-		    || !(!ref_count_is_zero || rs->rs_ref_count == 0))
-			EFRM_WARN("%s: check %szero ref=%d " EFRM_RESOURCE_FMT,
-				  __func__,
-				  ref_count_is_zero == 0 ? "non-" : "",
-				  rs->rs_ref_count,
-				  EFRM_RESOURCE_PRI_ARG(rs->rs_handle));
-
-		_EFRM_ASSERT(!(ref_count_is_zero == 0) ||
-			     rs->rs_ref_count != 0, file, line);
-		_EFRM_ASSERT(!(ref_count_is_zero > 0) ||
-			     rs->rs_ref_count == 0, file, line);
-	}
-
-	rm = efrm_rm_table[EFRM_RESOURCE_TYPE(rs->rs_handle)];
-	efrm_resource_manager_assert_valid(rm, file, line);
-}
-EXPORT_SYMBOL(efrm_resource_assert_valid);
-
-#endif
diff -r 5b3d4d3c1166 drivers/net/sfc/sfc_resource/buddy.c
--- a/drivers/net/sfc/sfc_resource/buddy.c	Fri Nov 05 15:20:28 2010 +0000
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,220 +0,0 @@
-
-/****************************************************************************
- * Driver for Solarflare network controllers -
- *          resource management for Xen backend, OpenOnload, etc
- *           (including support for SFE4001 10GBT NIC)
- *
- * This file contains implementation of a buddy allocator.
- *
- * Copyright 2005-2007: Solarflare Communications Inc,
- *                      9501 Jeronimo Road, Suite 250,
- *                      Irvine, CA 92618, USA
- *
- * Developed and maintained by Solarflare Communications:
- *                      <linux-xen-drivers@solarflare.com>
- *                      <onload-dev@solarflare.com>
- *
- * Certain parts of the driver were implemented by
- *          Alexandra Kossovsky <Alexandra.Kossovsky@oktetlabs.ru>
- *          OKTET Labs Ltd, Russia,
- *          http://oktetlabs.ru, <info@oktetlabs.ru>
- *          by request of Solarflare Communications
- *
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 as published
- * by the Free Software Foundation, incorporated herein by reference.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
- ****************************************************************************
- */
-
-#include <ci/efhw/common.h> /* get uintXX types on win32 */
-#include <ci/efrm/sysdep.h>
-#include <ci/efrm/buddy.h>
-#include <ci/efrm/debug.h>
-
-#if 1
-#define DEBUG_ALLOC(x)
-#else
-#define DEBUG_ALLOC(x) x
-
-static inline void efrm_buddy_dump(struct efrm_buddy_allocator *b)
-{
-	unsigned o;
-
-	EFRM_NOTICE("%s: dump allocator with order %u",
-		    __func__, b->order);
-	for (o = 0; o <= b->order; o++) {
-		struct list_head *l = &b->free_lists[o];
-		while (l->next != &b->free_lists[o]) {
-			l = l->next;
-			EFRM_NOTICE("%s: order %x: %zx", __func__, o,
-				    l - b->links);
-		}
-	}
-}
-#endif
-
-/*
- * The purpose of the following inline functions is to give the
- * understandable names to the simple actions.
- */
-static inline void
-efrm_buddy_free_list_add(struct efrm_buddy_allocator *b,
-			 unsigned order, unsigned addr)
-{
-	list_add(&b->links[addr], &b->free_lists[order]);
-	b->orders[addr] = (uint8_t) order;
-}
-static inline void
-efrm_buddy_free_list_del(struct efrm_buddy_allocator *b, unsigned addr)
-{
-	list_del(&b->links[addr]);
-	b->links[addr].next = NULL;
-}
-static inline int
-efrm_buddy_free_list_empty(struct efrm_buddy_allocator *b, unsigned order)
-{
-	return list_empty(&b->free_lists[order]);
-}
-static inline unsigned
-efrm_buddy_free_list_pop(struct efrm_buddy_allocator *b, unsigned order)
-{
-	struct list_head *l = list_pop(&b->free_lists[order]);
-	l->next = NULL;
-	return (unsigned)(l - b->links);
-}
-static inline int
-efrm_buddy_addr_in_free_list(struct efrm_buddy_allocator *b, unsigned addr)
-{
-	return b->links[addr].next != NULL;
-}
-static inline unsigned
-efrm_buddy_free_list_first(struct efrm_buddy_allocator *b, unsigned order)
-{
-	return (unsigned)(b->free_lists[order].next - b->links);
-}
-
-int efrm_buddy_ctor(struct efrm_buddy_allocator *b, unsigned order)
-{
-	unsigned o;
-	unsigned size = 1 << order;
-
-	DEBUG_ALLOC(EFRM_NOTICE("%s(%u)", __func__, order));
-	EFRM_ASSERT(b);
-	EFRM_ASSERT(order <= sizeof(unsigned) * 8 - 1);
-
-	b->order = order;
-	b->free_lists = vmalloc((order + 1) * sizeof(struct list_head));
-	if (b->free_lists == NULL)
-		goto fail1;
-
-	b->links = vmalloc(size * sizeof(struct list_head));
-	if (b->links == NULL)
-		goto fail2;
-
-	b->orders = vmalloc(size);
-	if (b->orders == NULL)
-		goto fail3;
-
-	memset(b->links, 0, size * sizeof(struct list_head));
-
-	for (o = 0; o <= b->order; ++o)
-		INIT_LIST_HEAD(b->free_lists + o);
-
-	efrm_buddy_free_list_add(b, b->order, 0);
-
-	return 0;
-
-fail3:
-	vfree(b->links);
-fail2:
-	vfree(b->free_lists);
-fail1:
-	return -ENOMEM;
-}
-
-void efrm_buddy_dtor(struct efrm_buddy_allocator *b)
-{
-	EFRM_ASSERT(b);
-
-	vfree(b->free_lists);
-	vfree(b->links);
-	vfree(b->orders);
-}
-
-int efrm_buddy_alloc(struct efrm_buddy_allocator *b, unsigned order)
-{
-	unsigned smallest;
-	unsigned addr;
-
-	DEBUG_ALLOC(EFRM_NOTICE("%s(%u)", __func__, order));
-	EFRM_ASSERT(b);
-
-	/* Find smallest chunk that is big enough.  ?? Can optimise this by
-	 ** keeping array of pointers to smallest chunk for each order.
-	 */
-	smallest = order;
-	while (smallest <= b->order &&
-	       efrm_buddy_free_list_empty(b, smallest))
-		++smallest;
-
-	if (smallest > b->order) {
-		DEBUG_ALLOC(EFRM_NOTICE
-			    ("buddy - alloc order %d failed - max order %d",
-			     order, b->order););
-		return -ENOMEM;
-	}
-
-	/* Split blocks until we get one of the correct size. */
-	addr = efrm_buddy_free_list_pop(b, smallest);
-
-	DEBUG_ALLOC(EFRM_NOTICE("buddy - alloc %x order %d cut from order %d",
-				addr, order, smallest););
-	while (smallest-- > order)
-		efrm_buddy_free_list_add(b, smallest, addr + (1 << smallest));
-
-	EFRM_DO_DEBUG(b->orders[addr] = (uint8_t) order);
-
-	EFRM_ASSERT(addr < 1u << b->order);
-	return addr;
-}
-
-void
-efrm_buddy_free(struct efrm_buddy_allocator *b, unsigned addr,
-		unsigned order)
-{
-	unsigned buddy_addr;
-
-	DEBUG_ALLOC(EFRM_NOTICE("%s(%u, %u)", __func__, addr, order));
-	EFRM_ASSERT(b);
-	EFRM_ASSERT(order <= b->order);
-	EFRM_ASSERT((unsigned long)addr + ((unsigned long)1 << order) <=
-		    (unsigned long)1 << b->order);
-	EFRM_ASSERT(!efrm_buddy_addr_in_free_list(b, addr));
-	EFRM_ASSERT(b->orders[addr] == order);
-
-	/* merge free blocks */
-	while (order < b->order) {
-		buddy_addr = addr ^ (1 << order);
-		if (!efrm_buddy_addr_in_free_list(b, buddy_addr) ||
-		    b->orders[buddy_addr] != order)
-			break;
-		efrm_buddy_free_list_del(b, buddy_addr);
-		if (buddy_addr < addr)
-			addr = buddy_addr;
-		++order;
-	}
-
-	DEBUG_ALLOC(EFRM_NOTICE
-		    ("buddy - free %x merged into order %d", addr, order););
-	efrm_buddy_free_list_add(b, order, addr);
-}
diff -r 5b3d4d3c1166 drivers/net/sfc/sfc_resource/buffer_table.c
--- a/drivers/net/sfc/sfc_resource/buffer_table.c	Fri Nov 05 15:20:28 2010 +0000
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,209 +0,0 @@
-/****************************************************************************
- * Driver for Solarflare network controllers -
- *          resource management for Xen backend, OpenOnload, etc
- *           (including support for SFE4001 10GBT NIC)
- *
- * This file contains abstraction of the buffer table on the NIC.
- *
- * Copyright 2005-2007: Solarflare Communications Inc,
- *                      9501 Jeronimo Road, Suite 250,
- *                      Irvine, CA 92618, USA
- *
- * Developed and maintained by Solarflare Communications:
- *                      <linux-xen-drivers@solarflare.com>
- *                      <onload-dev@solarflare.com>
- *
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 as published
- * by the Free Software Foundation, incorporated herein by reference.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
- ****************************************************************************
- */
-
-/*
-** Might be worth keeping a bitmap of which entries are clear.  Then we
-** wouldn't need to clear them all again when we free an allocation.
-*/
-
-#include <ci/efrm/debug.h>
-#include <ci/driver/efab/hardware.h>
-#include <ci/efrm/nic_table.h>
-#include <ci/efrm/buffer_table.h>
-#include <ci/efrm/buddy.h>
-
-/*! Comment? */
-struct efrm_buffer_table {
-	spinlock_t lock;
-	struct efrm_buddy_allocator buddy;
-};
-
-/* Efab buffer state. */
-static struct efrm_buffer_table efrm_buffers;
-
-int efrm_buffer_table_ctor(unsigned low, unsigned high)
-{
-	int log2_n_entries, rc, i;
-
-	EFRM_ASSERT(high > 0);
-	EFRM_ASSERT(low < high);
-
-	EFRM_TRACE("%s: low=%u high=%u", __func__, low, high);
-	EFRM_NOTICE("%s: low=%u high=%u", __func__, low, high);
-
-	log2_n_entries = fls(high - 1);
-
-	rc = efrm_buddy_ctor(&efrm_buffers.buddy, log2_n_entries);
-	if (rc < 0) {
-		EFRM_ERR("efrm_buffer_table_ctor: efrm_buddy_ctor(%d) "
-			 "failed (%d)", log2_n_entries, rc);
-		return rc;
-	}
-	for (i = 0; i < (1 << log2_n_entries); ++i) {
-		rc = efrm_buddy_alloc(&efrm_buffers.buddy, 0);
-		EFRM_ASSERT(rc >= 0);
-		EFRM_ASSERT(rc < (1 << log2_n_entries));
-	}
-	for (i = low; i < (int) high; ++i)
-		efrm_buddy_free(&efrm_buffers.buddy, i, 0);
-
-	spin_lock_init(&efrm_buffers.lock);
-
-	EFRM_TRACE("%s: done", __func__);
-
-	return 0;
-}
-
-void efrm_buffer_table_dtor(void)
-{
-	/* ?? debug check that all allocations have been freed? */
-
-	spin_lock_destroy(&efrm_buffers.lock);
-	efrm_buddy_dtor(&efrm_buffers.buddy);
-
-	EFRM_TRACE("%s: done", __func__);
-}
-
-/**********************************************************************/
-
-int
-efrm_buffer_table_alloc(unsigned order,
-			struct efhw_buffer_table_allocation *a)
-{
-	irq_flags_t lock_flags;
-	int rc;
-
-	EFRM_ASSERT(&efrm_buffers.buddy);
-	EFRM_ASSERT(a);
-
-	/* Round up to multiple of two, as the buffer clear logic works in
-	 * pairs when not in "full" mode. */
-	order = max_t(unsigned, order, 1);
-
-	spin_lock_irqsave(&efrm_buffers.lock, lock_flags);
-	rc = efrm_buddy_alloc(&efrm_buffers.buddy, order);
-	spin_unlock_irqrestore(&efrm_buffers.lock, lock_flags);
-
-	if (rc < 0) {
-		EFRM_ERR("efrm_buffer_table_alloc: failed (n=%ld) rc %d",
-			 1ul << order, rc);
-		return rc;
-	}
-
-	EFRM_TRACE("efrm_buffer_table_alloc: base=%d n=%ld",
-		   rc, 1ul << order);
-	a->order = order;
-	a->base = (unsigned)rc;
-	return 0;
-}
-
-void efrm_buffer_table_free(struct efhw_buffer_table_allocation *a)
-{
-	irq_flags_t lock_flags;
-	struct efhw_nic *nic;
-	int nic_i;
-
-	EFRM_ASSERT(&efrm_buffers.buddy);
-	EFRM_ASSERT(a);
-	EFRM_ASSERT(a->base != -1);
-	EFRM_ASSERT((unsigned long)a->base + (1ul << a->order) <=
-		    efrm_buddy_size(&efrm_buffers.buddy));
-
-	EFRM_TRACE("efrm_buffer_table_free: base=%d n=%ld",
-		   a->base, (1ul << a->order));
-
-	EFRM_FOR_EACH_NIC(nic_i, nic)
-	    efhw_nic_buffer_table_clear(nic, a->base, 1ul << a->order);
-
-	spin_lock_irqsave(&efrm_buffers.lock, lock_flags);
-	efrm_buddy_free(&efrm_buffers.buddy, a->base, a->order);
-	spin_unlock_irqrestore(&efrm_buffers.lock, lock_flags);
-
-	EFRM_DO_DEBUG(a->base = a->order = -1);
-}
-
-/**********************************************************************/
-
-void
-efrm_buffer_table_set(struct efhw_buffer_table_allocation *a,
-		      struct efhw_nic *nic,
-		      unsigned i, dma_addr_t dma_addr, int owner)
-{
-	EFRM_ASSERT(a);
-	EFRM_ASSERT(i < (unsigned)1 << a->order);
-
-	efhw_nic_buffer_table_set(nic, dma_addr, EFHW_NIC_PAGE_SIZE,
-				  0, owner, a->base + i);
-}
-
-
-int efrm_buffer_table_size(void)
-{
-	return efrm_buddy_size(&efrm_buffers.buddy);
-}
-
-/**********************************************************************/
-
-int
-efrm_page_register(struct efhw_nic *nic, dma_addr_t dma_addr, int owner,
-		   efhw_buffer_addr_t *buf_addr_out)
-{
-	struct efhw_buffer_table_allocation alloc;
-	int rc;
-
-	rc = efrm_buffer_table_alloc(0, &alloc);
-	if (rc == 0) {
-		efrm_buffer_table_set(&alloc, nic, 0, dma_addr, owner);
-		efrm_buffer_table_commit();
-		*buf_addr_out = EFHW_BUFFER_ADDR(alloc.base, 0);
-	}
-	return rc;
-}
-EXPORT_SYMBOL(efrm_page_register);
-
-void efrm_page_unregister(efhw_buffer_addr_t buf_addr)
-{
-	struct efhw_buffer_table_allocation alloc;
-
-	alloc.order = 0;
-	alloc.base = EFHW_BUFFER_PAGE(buf_addr);
-	efrm_buffer_table_free(&alloc);
-}
-EXPORT_SYMBOL(efrm_page_unregister);
-
-void efrm_buffer_table_commit(void)
-{
-	struct efhw_nic *nic;
-	int nic_i;
-
-	EFRM_FOR_EACH_NIC(nic_i, nic)
-	    efhw_nic_buffer_table_commit(nic);
-}
diff -r 5b3d4d3c1166 drivers/net/sfc/sfc_resource/ci/driver/efab/hardware.h
--- a/drivers/net/sfc/sfc_resource/ci/driver/efab/hardware.h	Fri Nov 05 15:20:28 2010 +0000
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,188 +0,0 @@
-/****************************************************************************
- * Driver for Solarflare network controllers -
- *          resource management for Xen backend, OpenOnload, etc
- *           (including support for SFE4001 10GBT NIC)
- *
- * This file provides EtherFabric NIC hardware interface.
- *
- * Copyright 2005-2007: Solarflare Communications Inc,
- *                      9501 Jeronimo Road, Suite 250,
- *                      Irvine, CA 92618, USA
- *
- * Developed and maintained by Solarflare Communications:
- *                      <linux-xen-drivers@solarflare.com>
- *                      <onload-dev@solarflare.com>
- *
- * Certain parts of the driver were implemented by
- *          Alexandra Kossovsky <Alexandra.Kossovsky@oktetlabs.ru>
- *          OKTET Labs Ltd, Russia,
- *          http://oktetlabs.ru, <info@oktetlabs.ru>
- *          by request of Solarflare Communications
- *
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 as published
- * by the Free Software Foundation, incorporated herein by reference.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
- ****************************************************************************
- */
-
-#ifndef __CI_DRIVER_EFAB_HARDWARE_H__
-#define __CI_DRIVER_EFAB_HARDWARE_H__
-
-#include "ci/driver/efab/hardware/workarounds.h"
-#include <ci/efhw/hardware_sysdep.h>
-
-
-/*----------------------------------------------------------------------------
- *
- * Common EtherFabric definitions
- *
- *---------------------------------------------------------------------------*/
-
-#include <ci/efhw/debug.h>
-#include <ci/efhw/common.h>
-#include <ci/driver/efab/hardware/common.h>
-
-/*----------------------------------------------------------------------------
- *
- * EtherFabric varients
- *
- *---------------------------------------------------------------------------*/
-
-#include <ci/driver/efab/hardware/falcon.h>
-
-/*----------------------------------------------------------------------------
- *
- * EtherFabric Portable Hardware Layer defines
- *
- *---------------------------------------------------------------------------*/
-
-  /*-------------- Initialisation ------------ */
-#define efhw_nic_close_hardware(nic) \
-	((nic)->efhw_func->close_hardware(nic))
-
-#define efhw_nic_init_hardware(nic, ev_handlers, mac_addr, non_irq_evq) \
-	((nic)->efhw_func->init_hardware((nic), (ev_handlers), (mac_addr), \
-					 (non_irq_evq)))
-
-/*-------------- Interrupt support  ------------ */
-/** Handle interrupt.  Return 0 if not handled, 1 if handled. */
-#define efhw_nic_interrupt(nic) \
-	((nic)->efhw_func->interrupt(nic))
-
-#define efhw_nic_interrupt_enable(nic) \
-	((nic)->efhw_func->interrupt_enable(nic))
-
-#define efhw_nic_interrupt_disable(nic) \
-	((nic)->efhw_func->interrupt_disable(nic))
-
-#define efhw_nic_set_interrupt_moderation(nic, evq, val)                 \
-	((nic)->efhw_func->set_interrupt_moderation(nic, evq, val))
-
-/*-------------- Event support  ------------ */
-
-#define efhw_nic_event_queue_enable(nic, evq, size, q_base, buf_base,   \
-				    interrupting)                       \
-	((nic)->efhw_func->event_queue_enable((nic), (evq), (size), (q_base), \
-					      (buf_base), (interrupting)))
-
-#define efhw_nic_event_queue_disable(nic, evq, timer_only) \
-	((nic)->efhw_func->event_queue_disable(nic, evq, timer_only))
-
-#define efhw_nic_wakeup_request(nic, q_base, index, evq) \
-	((nic)->efhw_func->wakeup_request(nic, q_base, index, evq))
-
-#define efhw_nic_sw_event(nic, data, ev) \
-	((nic)->efhw_func->sw_event(nic, data, ev))
-
-/*-------------- Filter support  ------------ */
-#define efhw_nic_ipfilter_set(nic, type, index, dmaq,		\
-			      saddr, sport, daddr, dport)	\
-	((nic)->efhw_func->ipfilter_set(nic, type, index, dmaq,	\
-					saddr, sport, daddr, dport))
-
-#define efhw_nic_ipfilter_clear(nic, index) \
-	((nic)->efhw_func->ipfilter_clear(nic, index))
-
-/*-------------- DMA support  ------------ */
-#define efhw_nic_dmaq_tx_q_init(nic, dmaq, evq, owner, tag,		\
-				dmaq_size, index, flags)		\
-	((nic)->efhw_func->dmaq_tx_q_init(nic, dmaq, evq, owner, tag,	\
-					  dmaq_size, index, flags))
-
-#define efhw_nic_dmaq_rx_q_init(nic, dmaq, evq, owner, tag,		\
-				dmaq_size, index, flags) \
-	((nic)->efhw_func->dmaq_rx_q_init(nic, dmaq, evq, owner, tag,	\
-					  dmaq_size, index, flags))
-
-#define efhw_nic_dmaq_tx_q_disable(nic, dmaq) \
-	((nic)->efhw_func->dmaq_tx_q_disable(nic, dmaq))
-
-#define efhw_nic_dmaq_rx_q_disable(nic, dmaq) \
-	((nic)->efhw_func->dmaq_rx_q_disable(nic, dmaq))
-
-#define efhw_nic_flush_tx_dma_channel(nic, dmaq) \
-	((nic)->efhw_func->flush_tx_dma_channel(nic, dmaq))
-
-#define efhw_nic_flush_rx_dma_channel(nic, dmaq) \
-	((nic)->efhw_func->flush_rx_dma_channel(nic, dmaq))
-
-/*-------------- MAC Low level interface ---- */
-#define efhw_gmac_get_mac_addr(nic) \
-	((nic)->gmac->get_mac_addr((nic)->gmac))
-
-/*-------------- Buffer table -------------- */
-#define efhw_nic_buffer_table_set(nic, addr, bufsz, region,		\
-				  own_id, buf_id)			\
-	((nic)->efhw_func->buffer_table_set(nic, addr, bufsz, region,	\
-					    own_id, buf_id))
-
-#define efhw_nic_buffer_table_set_n(nic, buf_id, addr, bufsz,		\
-				    region, n_pages, own_id) \
-	((nic)->efhw_func->buffer_table_set_n(nic, buf_id, addr, bufsz,	\
-					      region, n_pages, own_id))
-
-#define efhw_nic_buffer_table_clear(nic, id, num) \
-	((nic)->efhw_func->buffer_table_clear(nic, id, num))
-
-#define efhw_nic_buffer_table_commit(nic) \
-	((nic)->efhw_func->buffer_table_commit(nic))
-
-/*-------------- New filter API ------------ */
-#define efhw_nic_filter_set(nic, spec, index_out) \
-	((nic)->efhw_func->filter_set(nic, spec, index_out))
-
-#define efhw_nic_filter_clear(nic, type, index_out) \
-	((nic)->efhw_func->filter_clear(nic, type, index_out))
-
-
-/* --- DMA --- */
-#define EFHW_DMA_ADDRMASK		(0xffffffffffffffffULL)
-
-/* --- Buffers --- */
-#define EFHW_BUFFER_ADDR		FALCON_BUFFER_4K_ADDR
-#define EFHW_BUFFER_PAGE		FALCON_BUFFER_4K_PAGE
-#define EFHW_BUFFER_OFF			FALCON_BUFFER_4K_OFF
-
-/* --- Filters --- */
-#define EFHW_IP_FILTER_NUM		FALCON_FILTER_TBL_NUM
-
-#define EFHW_MAX_PAGE_SIZE		FALCON_MAX_PAGE_SIZE
-
-#if PAGE_SIZE <= EFHW_MAX_PAGE_SIZE
-#define EFHW_NIC_PAGE_SIZE PAGE_SIZE
-#else
-#define EFHW_NIC_PAGE_SIZE EFHW_MAX_PAGE_SIZE
-#endif
-#define EFHW_NIC_PAGE_MASK (~(EFHW_NIC_PAGE_SIZE-1))
-
-#endif /* __CI_DRIVER_EFAB_HARDWARE_H__ */
diff -r 5b3d4d3c1166 drivers/net/sfc/sfc_resource/ci/driver/efab/hardware/common.h
--- a/drivers/net/sfc/sfc_resource/ci/driver/efab/hardware/common.h	Fri Nov 05 15:20:28 2010 +0000
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,68 +0,0 @@
-/****************************************************************************
- * Driver for Solarflare network controllers -
- *          resource management for Xen backend, OpenOnload, etc
- *           (including support for SFE4001 10GBT NIC)
- *
- * This file provides EtherFabric NIC hardware interface common
- * definitions.
- *
- * Copyright 2005-2007: Solarflare Communications Inc,
- *                      9501 Jeronimo Road, Suite 250,
- *                      Irvine, CA 92618, USA
- *
- * Developed and maintained by Solarflare Communications:
- *                      <linux-xen-drivers@solarflare.com>
- *                      <onload-dev@solarflare.com>
- *
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 as published
- * by the Free Software Foundation, incorporated herein by reference.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
- ****************************************************************************
- */
-
-#ifndef __CI_DRIVER_EFAB_HARDWARE_COMMON_H__
-#define __CI_DRIVER_EFAB_HARDWARE_COMMON_H__
-
-/*----------------------------------------------------------------------------
- *
- * EtherFabric constants
- *
- *---------------------------------------------------------------------------*/
-
-#define EFHW_1K		0x00000400u
-#define EFHW_2K		0x00000800u
-#define EFHW_4K		0x00001000u
-#define EFHW_8K		0x00002000u
-#define EFHW_16K	0x00004000u
-#define EFHW_32K	0x00008000u
-#define EFHW_64K	0x00010000u
-#define EFHW_128K	0x00020000u
-#define EFHW_256K	0x00040000u
-#define EFHW_512K	0x00080000u
-#define EFHW_1M		0x00100000u
-#define EFHW_2M		0x00200000u
-#define EFHW_4M		0x00400000u
-#define EFHW_8M		0x00800000u
-#define EFHW_16M	0x01000000u
-#define EFHW_32M	0x02000000u
-#define EFHW_48M	0x03000000u
-#define EFHW_64M	0x04000000u
-#define EFHW_128M	0x08000000u
-#define EFHW_256M	0x10000000u
-#define EFHW_512M	0x20000000u
-#define EFHW_1G 	0x40000000u
-#define EFHW_2G		0x80000000u
-#define EFHW_4G		0x100000000ULL
-#define EFHW_8G		0x200000000ULL
-
-#endif /* __CI_DRIVER_EFAB_HARDWARE_COMMON_H__ */
diff -r 5b3d4d3c1166 drivers/net/sfc/sfc_resource/ci/driver/efab/hardware/falcon.h
--- a/drivers/net/sfc/sfc_resource/ci/driver/efab/hardware/falcon.h	Fri Nov 05 15:20:28 2010 +0000
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,422 +0,0 @@
-/****************************************************************************
- * Driver for Solarflare network controllers -
- *          resource management for Xen backend, OpenOnload, etc
- *           (including support for SFE4001 10GBT NIC)
- *
- * This file provides EtherFabric NIC - EFXXXX (aka Falcon) specific
- * definitions.
- *
- * Copyright 2005-2007: Solarflare Communications Inc,
- *                      9501 Jeronimo Road, Suite 250,
- *                      Irvine, CA 92618, USA
- *
- * Developed and maintained by Solarflare Communications:
- *                      <linux-xen-drivers@solarflare.com>
- *                      <onload-dev@solarflare.com>
- *
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 as published
- * by the Free Software Foundation, incorporated herein by reference.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
- ****************************************************************************
- */
-
-#ifndef __CI_DRIVER_EFAB_HARDWARE_FALCON_H__
-#define __CI_DRIVER_EFAB_HARDWARE_FALCON_H__
-
-/*----------------------------------------------------------------------------
- * Compile options
- *---------------------------------------------------------------------------*/
-
-/* Falcon has an 8K maximum page size. */
-#define FALCON_MAX_PAGE_SIZE EFHW_8K
-
-/* include the register definitions */
-#include <ci/driver/efab/hardware/falcon/falcon_core.h>
-#include <ci/driver/efab/hardware/falcon/falcon_desc.h>
-#include <ci/driver/efab/hardware/falcon/falcon_event.h>
-#include <ci/driver/efab/hardware/falcon/falcon_intr_vec.h>
-
-#define FALCON_DMA_TX_DESC_BYTES	8
-#define FALCON_DMA_RX_PHYS_DESC_BYTES	8
-#define FALCON_DMA_RX_BUF_DESC_BYTES	4
-
-
-/* ---- efhw_event_t helpers --- */
-
-#ifndef EFHW_IS_LITTLE_ENDIAN
-#error This needs lots of cpu_to_le64s() in
-#endif
-
-/*!\ TODO look at whether there is an efficiency gain to be had by
-  treating the event codes to 32bit masks as is done for EF1
-
-  These masks apply to the full 64 bits of the event to extract the
-  event code - followed by the common event codes to expect
- */
-#define __FALCON_OPEN_MASK(WIDTH)  ((((uint64_t)1) << (WIDTH)) - 1)
-#define FALCON_EVENT_CODE_MASK \
-	(__FALCON_OPEN_MASK(EV_CODE_WIDTH) << EV_CODE_LBN)
-#define FALCON_EVENT_EV_Q_ID_MASK \
-	(__FALCON_OPEN_MASK(DRIVER_EV_EVQ_ID_WIDTH) << DRIVER_EV_EVQ_ID_LBN)
-#define FALCON_EVENT_TX_FLUSH_Q_ID_MASK \
-	(__FALCON_OPEN_MASK(DRIVER_EV_TX_DESCQ_ID_WIDTH) << \
-	 DRIVER_EV_TX_DESCQ_ID_LBN)
-#define FALCON_EVENT_RX_FLUSH_Q_ID_MASK \
-	(__FALCON_OPEN_MASK(DRIVER_EV_RX_DESCQ_ID_WIDTH) << \
-	 DRIVER_EV_RX_DESCQ_ID_LBN)
-#define FALCON_EVENT_DRV_SUBCODE_MASK \
-	(__FALCON_OPEN_MASK(DRIVER_EV_SUB_CODE_WIDTH) << \
-	 DRIVER_EV_SUB_CODE_LBN)
-
-#define FALCON_EVENT_FMT         "[ev:%x:%08x:%08x]"
-#define FALCON_EVENT_PRI_ARG(e) \
-	((unsigned)(((e).u64 & FALCON_EVENT_CODE_MASK) >> EV_CODE_LBN)), \
-	((unsigned)((e).u64 >> 32)), ((unsigned)((e).u64 & 0xFFFFFFFF))
-
-#define FALCON_EVENT_CODE(evp)		((evp)->u64 & FALCON_EVENT_CODE_MASK)
-#define FALCON_EVENT_WAKE_EVQ_ID(evp) \
-	(((evp)->u64 & FALCON_EVENT_EV_Q_ID_MASK) >> DRIVER_EV_EVQ_ID_LBN)
-#define FALCON_EVENT_TX_FLUSH_Q_ID(evp) \
-	(((evp)->u64 & FALCON_EVENT_TX_FLUSH_Q_ID_MASK) >> \
-	 DRIVER_EV_TX_DESCQ_ID_LBN)
-#define FALCON_EVENT_RX_FLUSH_Q_ID(evp) \
-	(((evp)->u64 & FALCON_EVENT_RX_FLUSH_Q_ID_MASK) >> \
-	 DRIVER_EV_RX_DESCQ_ID_LBN)
-#define FALCON_EVENT_DRIVER_SUBCODE(evp) \
-	(((evp)->u64 & FALCON_EVENT_DRV_SUBCODE_MASK) >> \
-	 DRIVER_EV_SUB_CODE_LBN)
-
-#define FALCON_EVENT_CODE_CHAR	((uint64_t)DRIVER_EV_DECODE << EV_CODE_LBN)
-#define FALCON_EVENT_CODE_SW	((uint64_t)DRV_GEN_EV_DECODE << EV_CODE_LBN)
-
-
-/* so this is the size in bytes of an awful lot of things */
-#define FALCON_REGISTER128          (16)
-
-/* we define some unique dummy values as a debug aid */
-#ifdef _WIN32
-#define FALCON_ATOMIC_BASE		0xdeadbeef00000000ui64
-#else
-#define FALCON_ATOMIC_BASE		0xdeadbeef00000000ULL
-#endif
-#define FALCON_ATOMIC_UPD_REG		(FALCON_ATOMIC_BASE | 0x1)
-#define FALCON_ATOMIC_PTR_TBL_REG	(FALCON_ATOMIC_BASE | 0x2)
-#define FALCON_ATOMIC_SRPM_UDP_EVQ_REG	(FALCON_ATOMIC_BASE | 0x3)
-#define FALCON_ATOMIC_RX_FLUSH_DESCQ	(FALCON_ATOMIC_BASE | 0x4)
-#define FALCON_ATOMIC_TX_FLUSH_DESCQ	(FALCON_ATOMIC_BASE | 0x5)
-#define FALCON_ATOMIC_INT_EN_REG	(FALCON_ATOMIC_BASE | 0x6)
-#define FALCON_ATOMIC_TIMER_CMD_REG	(FALCON_ATOMIC_BASE | 0x7)
-#define FALCON_ATOMIC_PACE_REG		(FALCON_ATOMIC_BASE | 0x8)
-#define FALCON_ATOMIC_INT_ACK_REG	(FALCON_ATOMIC_BASE | 0x9)
-/* XXX It crashed with odd value in FALCON_ATOMIC_INT_ADR_REG */
-#define FALCON_ATOMIC_INT_ADR_REG	(FALCON_ATOMIC_BASE | 0xa)
-
-/*----------------------------------------------------------------------------
- *
- * PCI control blocks for Falcon -
- *          (P) primary is for NET
- *          (S) secondary is for CHAR
- *
- *---------------------------------------------------------------------------*/
-
-#define FALCON_P_CTR_AP_BAR	2
-#define FALCON_S_CTR_AP_BAR	0
-#define FALCON_S_DEVID		0x6703
-
-
-/*----------------------------------------------------------------------------
- *
- * Falcon constants
- *
- *---------------------------------------------------------------------------*/
-
-/* Note: the following constants have moved to values in struct efhw_nic:
- *   FALCON_EVQ_TBL_NUM  ->  nic->num_evqs
- *   FALCON_DMAQ_NUM     ->  nic->num_dmaqs
- *   FALCON_TIMERS_NUM   ->  nic->num_times
- * These replacement constants are used as sanity checks in assertions in
- * certain functions that don't have access to struct efhw_nic.
- */
-#define FALCON_DMAQ_NUM_SANITY          (EFHW_4K)
-#define FALCON_EVQ_TBL_NUM_SANITY       (EFHW_4K)
-#define FALCON_TIMERS_NUM_SANITY        (EFHW_4K)
-
-/* This value is an upper limit on the total number of filter table
- * entries.  The actual size of filter table is determined at runtime, as
- * it can vary.
- */
-#define FALCON_FILTER_TBL_NUM		(EFHW_8K)
-
-/* max number of buffers which can be pushed before commiting */
-#define FALCON_BUFFER_UPD_MAX		(128)
-
-/* We can tell falcon to write its RX buffers in 32 byte quantums,
-   and since we pad packets 2 bytes to the right we can't use
-   a full page (not unless we use jumbo mode for all queues)
-
-   NOTE: tests/nic/dma.c assumes that the value here is the real NIC
-   value, so we explicitly round it down to the nearest 32 bytes */
-
-/* #define FALCON_RX_USR_BUF_SIZE    round_down(4096-2,32) */
-#define FALCON_RX_USR_BUF_SIZE		4064
-
-#define FALCON_EVQ_RPTR_REG_P0		0x400
-
-/*----------------------------------------------------------------------------
- *
- * Falcon requires user-space descriptor pushes to be:
- *    dword[0-2]; wiob(); dword[3]
- *
- * Driver register access must be locked against other threads from
- * the same driver but can be in any order: i.e dword[0-3]; wiob()
- *
- * The following helpers ensure that valid dword orderings are exercised
- *
- *---------------------------------------------------------------------------*/
-
-/* A union to allow writting 64bit values as 32bit values, without
- * hitting the compilers aliasing rules. We hope the compiler optimises
- * away the copy's anyway */
-union __u64to32 {
-	uint64_t u64;
-	struct {
-#ifdef EFHW_IS_LITTLE_ENDIAN
-		uint32_t a;
-		uint32_t b;
-#else
-		uint32_t b;
-		uint32_t a;
-#endif
-	} s;
-};
-
-static inline void
-falcon_write_ddd_d(volatile char __iomem *kva,
-		   uint32_t d0, uint32_t d1, uint32_t d2, uint32_t d3)
-{
-	writel(d0, kva + 0);
-	writel(d1, kva + 4);
-	writel(d2, kva + 8);
-	mmiowb();
-	writel(d3, kva + 12);
-}
-
-static inline void falcon_write_q(volatile char __iomem *kva, uint64_t q)
-{
-	union __u64to32 u;
-	u.u64 = q;
-
-	writel(u.s.a, kva);
-	mmiowb();
-	writel(u.s.b, kva + 4);
-}
-
-static inline void falcon_read_q(volatile char __iomem *addr, uint64_t *q0)
-{
-	/* It is essential that we read dword0 first, so that
-	 * the shadow register is updated with the latest value
-	 * and we get a self consistent value.
-	 */
-	union __u64to32 u;
-	u.s.a = readl(addr);
-	rmb();
-	u.s.b = readl(addr + 4);
-
-	*q0 = u.u64;
-}
-
-static inline void
-falcon_write_qq(volatile char __iomem *kva, uint64_t q0, uint64_t q1)
-{
-	writeq(q0, kva + 0);
-	falcon_write_q(kva + 8, q1);
-}
-
-static inline void
-falcon_read_qq(volatile char __iomem *addr, uint64_t *q0, uint64_t *q1)
-{
-	falcon_read_q(addr, q0);
-	*q1 = readq(addr + 8);
-}
-
-
-
-/*----------------------------------------------------------------------------
- *
- * Buffer virtual addresses (4K buffers)
- *
- *---------------------------------------------------------------------------*/
-
-/* Form a buffer virtual address from buffer ID and offset.  If the offset
-** is larger than the buffer size, then the buffer indexed will be
-** calculated appropriately.  It is the responsibility of the caller to
-** ensure that they have valid buffers programmed at that address.
-*/
-#define FALCON_VADDR_8K_S	(13)
-#define FALCON_VADDR_4K_S	(12)
-#define FALCON_VADDR_M		0xfffff	/* post shift mask  */
-
-#define FALCON_BUFFER_8K_ADDR(id, off)	(((id) << FALCON_VADDR_8K_S) + (off))
-#define FALCON_BUFFER_8K_PAGE(vaddr) \
-	(((vaddr) >> FALCON_VADDR_8K_S) & FALCON_VADDR_M)
-#define FALCON_BUFFER_8K_OFF(vaddr) \
-	((vaddr) & __FALCON_MASK32(FALCON_VADDR_8K_S))
-
-#define FALCON_BUFFER_4K_ADDR(id, off)	(((id) << FALCON_VADDR_4K_S) + (off))
-#define FALCON_BUFFER_4K_PAGE(vaddr) \
-	(((vaddr) >> FALCON_VADDR_4K_S) & FALCON_VADDR_M)
-#define FALCON_BUFFER_4K_OFF(vaddr) \
-	((vaddr) & __FALCON_MASK32(FALCON_VADDR_4K_S))
-
-/*----------------------------------------------------------------------------
- *
- * Timer helpers
- *
- *---------------------------------------------------------------------------*/
-
-static inline int falcon_timer_page_addr(uint idx)
-{
-
-	EFHW_ASSERT(TIMER_CMD_REG_KER_OFST ==
-		    (TIMER_CMD_REG_PAGE4_OFST - 4 * EFHW_8K));
-
-	EFHW_ASSERT(idx < FALCON_TIMERS_NUM_SANITY);
-
-	if (idx < 4)
-		return TIMER_CMD_REG_KER_OFST + (idx * EFHW_8K);
-	else if (idx < 1024)
-		return TIMER_CMD_REG_PAGE4_OFST + ((idx - 4) * EFHW_8K);
-	else
-		return TIMER_CMD_REG_PAGE123K_OFST + ((idx - 1024) * EFHW_8K);
-}
-
-#define FALCON_TIMER_PAGE_MASK		(EFHW_8K-1)
-
-static inline int falcon_timer_page_offset(uint idx)
-{
-	return falcon_timer_page_addr(idx) & FALCON_TIMER_PAGE_MASK;
-}
-
-/*----------------------------------------------------------------------------
- *
- * DMA Queue helpers
- *
- *---------------------------------------------------------------------------*/
-
-/* iSCSI queue for A1; see bug 5427 for more details. */
-#define FALCON_A1_ISCSI_DMAQ 4
-
-/*! returns an address within a bar of the TX DMA doorbell */
-static inline uint falcon_tx_dma_page_addr(uint dmaq_idx)
-{
-	uint page;
-
-	EFHW_ASSERT((((TX_DESC_UPD_REG_PAGE123K_OFST) & (EFHW_8K - 1)) ==
-		     (((TX_DESC_UPD_REG_PAGE4_OFST) & (EFHW_8K - 1)))));
-
-	EFHW_ASSERT(dmaq_idx < FALCON_DMAQ_NUM_SANITY);
-
-	if (dmaq_idx < 1024)
-		page = TX_DESC_UPD_REG_PAGE4_OFST + ((dmaq_idx - 4) * EFHW_8K);
-	else
-		page =
-		    TX_DESC_UPD_REG_PAGE123K_OFST +
-		    ((dmaq_idx - 1024) * EFHW_8K);
-
-	return page;
-}
-
-/*! returns an address within a bar of the RX DMA doorbell */
-static inline uint falcon_rx_dma_page_addr(uint dmaq_idx)
-{
-	uint page;
-
-	EFHW_ASSERT((((RX_DESC_UPD_REG_PAGE123K_OFST) & (EFHW_8K - 1)) ==
-		     ((RX_DESC_UPD_REG_PAGE4_OFST) & (EFHW_8K - 1))));
-
-	EFHW_ASSERT(dmaq_idx < FALCON_DMAQ_NUM_SANITY);
-
-	if (dmaq_idx < 1024)
-		page = RX_DESC_UPD_REG_PAGE4_OFST + ((dmaq_idx - 4) * EFHW_8K);
-	else
-		page =
-		    RX_DESC_UPD_REG_PAGE123K_OFST +
-		    ((dmaq_idx - 1024) * EFHW_8K);
-
-	return page;
-}
-
-/*! "page"=NIC-dependent register set size */
-#define FALCON_DMA_PAGE_MASK  (EFHW_8K-1)
-
-/*! returns an address within a bar of the start of the "page"
-    containing the TX DMA doorbell */
-static inline int falcon_tx_dma_page_base(uint dma_idx)
-{
-	return falcon_tx_dma_page_addr(dma_idx) & ~FALCON_DMA_PAGE_MASK;
-}
-
-/*! returns an address within a bar of the start of the "page"
-    containing the RX DMA doorbell */
-static inline int falcon_rx_dma_page_base(uint dma_idx)
-{
-	return falcon_rx_dma_page_addr(dma_idx) & ~FALCON_DMA_PAGE_MASK;
-}
-
-/*! returns an offset within a "page" of the TX DMA doorbell */
-static inline int falcon_tx_dma_page_offset(uint dma_idx)
-{
-	return falcon_tx_dma_page_addr(dma_idx) & FALCON_DMA_PAGE_MASK;
-}
-
-/*! returns an offset within a "page" of the RX DMA doorbell */
-static inline int falcon_rx_dma_page_offset(uint dma_idx)
-{
-	return falcon_rx_dma_page_addr(dma_idx) & FALCON_DMA_PAGE_MASK;
-}
-
-/*----------------------------------------------------------------------------
- *
- * Events
- *
- *---------------------------------------------------------------------------*/
-
-/* Falcon nails down the event queue mappings */
-#define FALCON_EVQ_KERNEL0   (0)	/* hardwired for net driver */
-#define FALCON_EVQ_CHAR      (4)	/* char driver's event queue      */
-
-/* reserved by the drivers */
-#define FALCON_EVQ_TBL_RESERVED	   (8)
-
-/* default DMA-Q sizes */
-#define FALCON_DMA_Q_DEFAULT_TX_SIZE  512
-
-#define FALCON_DMA_Q_DEFAULT_RX_SIZE  512
-
-#define FALCON_DMA_Q_DEFAULT_MMAP \
-	(FALCON_DMA_Q_DEFAULT_TX_SIZE * (FALCON_DMA_TX_DESC_BYTES * 2))
-
-/*----------------------------------------------------------------------------
- *
- * DEBUG - Analyser trigger
- *
- *---------------------------------------------------------------------------*/
-
-static inline void
-falcon_deadbeef(volatile char __iomem *efhw_kva, unsigned what)
-{
-	writel(what, efhw_kva + 0x300);
-	mmiowb();
-}
-#endif /* __CI_DRIVER_EFAB_HARDWARE_FALCON_H__ */
-/*! \cidoxg_end */
diff -r 5b3d4d3c1166 drivers/net/sfc/sfc_resource/ci/driver/efab/hardware/falcon/falcon_core.h
--- a/drivers/net/sfc/sfc_resource/ci/driver/efab/hardware/falcon/falcon_core.h	Fri Nov 05 15:20:28 2010 +0000
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,1147 +0,0 @@
-/****************************************************************************
- * Driver for Solarflare network controllers -
- *          resource management for Xen backend, OpenOnload, etc
- *           (including support for SFE4001 10GBT NIC)
- *
- * This file provides EtherFabric NIC - EFXXXX (aka Falcon) core register
- * definitions.
- *
- * Copyright 2005-2007: Solarflare Communications Inc,
- *                      9501 Jeronimo Road, Suite 250,
- *                      Irvine, CA 92618, USA
- *
- * Developed and maintained by Solarflare Communications:
- *                      <linux-xen-drivers@solarflare.com>
- *                      <onload-dev@solarflare.com>
- *
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 as published
- * by the Free Software Foundation, incorporated herein by reference.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
- ****************************************************************************
- */
-
-#define  FALCON_EXTENDED_P_BAR 1
-
-/*************---- Bus Interface Unit Registers C Header ----*************/
-#define IOM_IND_ADR_REG_OFST 0x0 /* IO-mapped indirect access address
-				    register */
-  #define IOM_AUTO_ADR_INC_EN_LBN 16
-  #define IOM_AUTO_ADR_INC_EN_WIDTH 1
-  #define IOM_IND_ADR_LBN 0
-  #define IOM_IND_ADR_WIDTH 16
-#define IOM_IND_DAT_REG_OFST 0x4 /* IO-mapped indirect access data register */
-  #define IOM_IND_DAT_LBN 0
-  #define IOM_IND_DAT_WIDTH 32
-#define ADR_REGION_REG_KER_OFST 0x0 /* Address region register */
-#define ADR_REGION_REG_OFST 0x0 /* Address region register */
-  #define ADR_REGION3_LBN 96
-  #define ADR_REGION3_WIDTH 18
-  #define ADR_REGION2_LBN 64
-  #define ADR_REGION2_WIDTH 18
-  #define ADR_REGION1_LBN 32
-  #define ADR_REGION1_WIDTH 18
-  #define ADR_REGION0_LBN 0
-  #define ADR_REGION0_WIDTH 18
-#define INT_EN_REG_KER_OFST 0x10 /* Kernel driver Interrupt enable register */
-  #define KER_INT_CHAR_LBN 4
-  #define KER_INT_CHAR_WIDTH 1
-  #define KER_INT_KER_LBN 3
-  #define KER_INT_KER_WIDTH 1
-  #define ILL_ADR_ERR_INT_EN_KER_LBN 2
-  #define ILL_ADR_ERR_INT_EN_KER_WIDTH 1
-  #define SRM_PERR_INT_EN_KER_LBN 1
-  #define SRM_PERR_INT_EN_KER_WIDTH 1
-  #define DRV_INT_EN_KER_LBN 0
-  #define DRV_INT_EN_KER_WIDTH 1
-#define INT_EN_REG_CHAR_OFST 0x20 /* Char Driver interrupt enable register */
-  #define CHAR_INT_CHAR_LBN 4
-  #define CHAR_INT_CHAR_WIDTH 1
-  #define CHAR_INT_KER_LBN 3
-  #define CHAR_INT_KER_WIDTH 1
-  #define ILL_ADR_ERR_INT_EN_CHAR_LBN 2
-  #define ILL_ADR_ERR_INT_EN_CHAR_WIDTH 1
-  #define SRM_PERR_INT_EN_CHAR_LBN 1
-  #define SRM_PERR_INT_EN_CHAR_WIDTH 1
-  #define DRV_INT_EN_CHAR_LBN 0
-  #define DRV_INT_EN_CHAR_WIDTH 1
-#define INT_ADR_REG_KER_OFST 0x30 /* Interrupt host address for Kernel driver */
-  #define INT_ADR_KER_LBN 0
-  #define INT_ADR_KER_WIDTH 64
-  #define DRV_INT_KER_LBN 32
-  #define DRV_INT_KER_WIDTH 1
-  #define EV_FF_HALF_INT_KER_LBN 3
-  #define EV_FF_HALF_INT_KER_WIDTH 1
-  #define EV_FF_FULL_INT_KER_LBN 2
-  #define EV_FF_FULL_INT_KER_WIDTH 1
-  #define ILL_ADR_ERR_INT_KER_LBN 1
-  #define ILL_ADR_ERR_INT_KER_WIDTH 1
-  #define SRAM_PERR_INT_KER_LBN 0
-  #define SRAM_PERR_INT_KER_WIDTH 1
-#define INT_ADR_REG_CHAR_OFST 0x40 /* Interrupt host address for Char driver */
-  #define INT_ADR_CHAR_LBN 0
-  #define INT_ADR_CHAR_WIDTH 64
-  #define DRV_INT_CHAR_LBN 32
-  #define DRV_INT_CHAR_WIDTH 1
-  #define EV_FF_HALF_INT_CHAR_LBN 3
-  #define EV_FF_HALF_INT_CHAR_WIDTH 1
-  #define EV_FF_FULL_INT_CHAR_LBN 2
-  #define EV_FF_FULL_INT_CHAR_WIDTH 1
-  #define ILL_ADR_ERR_INT_CHAR_LBN 1
-  #define ILL_ADR_ERR_INT_CHAR_WIDTH 1
-  #define SRAM_PERR_INT_CHAR_LBN 0
-  #define SRAM_PERR_INT_CHAR_WIDTH 1
-#define INT_ISR0_B0_OFST 0x90 /* B0 only */
-#define INT_ISR1_B0_OFST 0xA0
-#define INT_ACK_REG_KER_A1_OFST 0x50 /* Kernel interrupt acknowledge register */
-  #define RESERVED_LBN 0
-  #define RESERVED_WIDTH 32
-#define INT_ACK_REG_CHAR_A1_OFST 0x60 /* CHAR interrupt acknowledge register */
-  #define RESERVED_LBN 0
-  #define RESERVED_WIDTH 32
-/*************---- Global CSR Registers C Header ----*************/
-#define NIC_STAT_REG_KER_OFST 0x200 /* ASIC strap status register */
-#define NIC_STAT_REG_OFST 0x200 /* ASIC strap status register */
-  #define ONCHIP_SRAM_LBN 16
-  #define ONCHIP_SRAM_WIDTH 0
-  #define STRAP_PINS_LBN 0
-  #define STRAP_PINS_WIDTH 3
-#define GPIO_CTL_REG_KER_OFST 0x210 /* GPIO control register */
-#define GPIO_CTL_REG_OFST 0x210 /* GPIO control register */
-  #define GPIO_OEN_LBN 24
-  #define GPIO_OEN_WIDTH 4
-  #define GPIO_OUT_LBN 16
-  #define GPIO_OUT_WIDTH 4
-  #define GPIO_IN_LBN 8
-  #define GPIO_IN_WIDTH 4
-  #define GPIO_PWRUP_VALUE_LBN 0
-  #define GPIO_PWRUP_VALUE_WIDTH 4
-#define GLB_CTL_REG_KER_OFST 0x220 /* Global control register */
-#define GLB_CTL_REG_OFST 0x220 /* Global control register */
-  #define SWRST_LBN 0
-  #define SWRST_WIDTH 1
-#define FATAL_INTR_REG_KER_OFST 0x230 /* Fatal interrupt register for Kernel */
-  #define PCI_BUSERR_INT_KER_EN_LBN 43
-  #define PCI_BUSERR_INT_KER_EN_WIDTH 1
-  #define SRAM_OOB_INT_KER_EN_LBN 42
-  #define SRAM_OOB_INT_KER_EN_WIDTH 1
-  #define BUFID_OOB_INT_KER_EN_LBN 41
-  #define BUFID_OOB_INT_KER_EN_WIDTH 1
-  #define MEM_PERR_INT_KER_EN_LBN 40
-  #define MEM_PERR_INT_KER_EN_WIDTH 1
-  #define RBUF_OWN_INT_KER_EN_LBN 39
-  #define RBUF_OWN_INT_KER_EN_WIDTH 1
-  #define TBUF_OWN_INT_KER_EN_LBN 38
-  #define TBUF_OWN_INT_KER_EN_WIDTH 1
-  #define RDESCQ_OWN_INT_KER_EN_LBN 37
-  #define RDESCQ_OWN_INT_KER_EN_WIDTH 1
-  #define TDESCQ_OWN_INT_KER_EN_LBN 36
-  #define TDESCQ_OWN_INT_KER_EN_WIDTH 1
-  #define EVQ_OWN_INT_KER_EN_LBN 35
-  #define EVQ_OWN_INT_KER_EN_WIDTH 1
-  #define EVFF_OFLO_INT_KER_EN_LBN 34
-  #define EVFF_OFLO_INT_KER_EN_WIDTH 1
-  #define ILL_ADR_INT_KER_EN_LBN 33
-  #define ILL_ADR_INT_KER_EN_WIDTH 1
-  #define SRM_PERR_INT_KER_EN_LBN 32
-  #define SRM_PERR_INT_KER_EN_WIDTH 1
-  #define PCI_BUSERR_INT_KER_LBN 11
-  #define PCI_BUSERR_INT_KER_WIDTH 1
-  #define SRAM_OOB_INT_KER_LBN 10
-  #define SRAM_OOB_INT_KER_WIDTH 1
-  #define BUFID_OOB_INT_KER_LBN 9
-  #define BUFID_OOB_INT_KER_WIDTH 1
-  #define MEM_PERR_INT_KER_LBN 8
-  #define MEM_PERR_INT_KER_WIDTH 1
-  #define RBUF_OWN_INT_KER_LBN 7
-  #define RBUF_OWN_INT_KER_WIDTH 1
-  #define TBUF_OWN_INT_KER_LBN 6
-  #define TBUF_OWN_INT_KER_WIDTH 1
-  #define RDESCQ_OWN_INT_KER_LBN 5
-  #define RDESCQ_OWN_INT_KER_WIDTH 1
-  #define TDESCQ_OWN_INT_KER_LBN 4
-  #define TDESCQ_OWN_INT_KER_WIDTH 1
-  #define EVQ_OWN_INT_KER_LBN 3
-  #define EVQ_OWN_INT_KER_WIDTH 1
-  #define EVFF_OFLO_INT_KER_LBN 2
-  #define EVFF_OFLO_INT_KER_WIDTH 1
-  #define ILL_ADR_INT_KER_LBN 1
-  #define ILL_ADR_INT_KER_WIDTH 1
-  #define SRM_PERR_INT_KER_LBN 0
-  #define SRM_PERR_INT_KER_WIDTH 1
-#define FATAL_INTR_REG_OFST 0x240 /* Fatal interrupt register for Char */
-  #define PCI_BUSERR_INT_CHAR_EN_LBN 43
-  #define PCI_BUSERR_INT_CHAR_EN_WIDTH 1
-  #define SRAM_OOB_INT_CHAR_EN_LBN 42
-  #define SRAM_OOB_INT_CHAR_EN_WIDTH 1
-  #define BUFID_OOB_INT_CHAR_EN_LBN 41
-  #define BUFID_OOB_INT_CHAR_EN_WIDTH 1
-  #define MEM_PERR_INT_CHAR_EN_LBN 40
-  #define MEM_PERR_INT_CHAR_EN_WIDTH 1
-  #define RBUF_OWN_INT_CHAR_EN_LBN 39
-  #define RBUF_OWN_INT_CHAR_EN_WIDTH 1
-  #define TBUF_OWN_INT_CHAR_EN_LBN 38
-  #define TBUF_OWN_INT_CHAR_EN_WIDTH 1
-  #define RDESCQ_OWN_INT_CHAR_EN_LBN 37
-  #define RDESCQ_OWN_INT_CHAR_EN_WIDTH 1
-  #define TDESCQ_OWN_INT_CHAR_EN_LBN 36
-  #define TDESCQ_OWN_INT_CHAR_EN_WIDTH 1
-  #define EVQ_OWN_INT_CHAR_EN_LBN 35
-  #define EVQ_OWN_INT_CHAR_EN_WIDTH 1
-  #define EVFF_OFLO_INT_CHAR_EN_LBN 34
-  #define EVFF_OFLO_INT_CHAR_EN_WIDTH 1
-  #define ILL_ADR_INT_CHAR_EN_LBN 33
-  #define ILL_ADR_INT_CHAR_EN_WIDTH 1
-  #define SRM_PERR_INT_CHAR_EN_LBN 32
-  #define SRM_PERR_INT_CHAR_EN_WIDTH 1
-  #define FATAL_INTR_REG_EN_BITS    0xffffffffffffffffULL
-  #define PCI_BUSERR_INT_CHAR_LBN 11
-  #define PCI_BUSERR_INT_CHAR_WIDTH 1
-  #define SRAM_OOB_INT_CHAR_LBN 10
-  #define SRAM_OOB_INT_CHAR_WIDTH 1
-  #define BUFID_OOB_INT_CHAR_LBN 9
-  #define BUFID_OOB_INT_CHAR_WIDTH 1
-  #define MEM_PERR_INT_CHAR_LBN 8
-  #define MEM_PERR_INT_CHAR_WIDTH 1
-  #define RBUF_OWN_INT_CHAR_LBN 7
-  #define RBUF_OWN_INT_CHAR_WIDTH 1
-  #define TBUF_OWN_INT_CHAR_LBN 6
-  #define TBUF_OWN_INT_CHAR_WIDTH 1
-  #define RDESCQ_OWN_INT_CHAR_LBN 5
-  #define RDESCQ_OWN_INT_CHAR_WIDTH 1
-  #define TDESCQ_OWN_INT_CHAR_LBN 4
-  #define TDESCQ_OWN_INT_CHAR_WIDTH 1
-  #define EVQ_OWN_INT_CHAR_LBN 3
-  #define EVQ_OWN_INT_CHAR_WIDTH 1
-  #define EVFF_OFLO_INT_CHAR_LBN 2
-  #define EVFF_OFLO_INT_CHAR_WIDTH 1
-  #define ILL_ADR_INT_CHAR_LBN 1
-  #define ILL_ADR_INT_CHAR_WIDTH 1
-  #define SRM_PERR_INT_CHAR_LBN 0
-  #define SRM_PERR_INT_CHAR_WIDTH 1
-#define DP_CTRL_REG_OFST 0x250 /* Datapath control register */
-  #define FLS_EVQ_ID_LBN 0
-  #define FLS_EVQ_ID_WIDTH 12
-#define MEM_STAT_REG_KER_OFST 0x260 /* Memory status register */
-#define MEM_STAT_REG_OFST 0x260 /* Memory status register */
-  #define MEM_PERR_VEC_LBN 53
-  #define MEM_PERR_VEC_WIDTH 38
-  #define MBIST_CORR_LBN 38
-  #define MBIST_CORR_WIDTH 15
-  #define MBIST_ERR_LBN 0
-  #define MBIST_ERR_WIDTH 38
-#define DEBUG_REG_KER_OFST 0x270 /* Debug register */
-#define DEBUG_REG_OFST 0x270 /* Debug register */
-  #define DEBUG_BLK_SEL2_LBN 47
-  #define DEBUG_BLK_SEL2_WIDTH 3
-  #define DEBUG_BLK_SEL1_LBN 44
-  #define DEBUG_BLK_SEL1_WIDTH 3
-  #define DEBUG_BLK_SEL0_LBN 41
-  #define DEBUG_BLK_SEL0_WIDTH 3
-  #define MISC_DEBUG_ADDR_LBN 36
-  #define MISC_DEBUG_ADDR_WIDTH 5
-  #define SERDES_DEBUG_ADDR_LBN 31
-  #define SERDES_DEBUG_ADDR_WIDTH 5
-  #define EM_DEBUG_ADDR_LBN 26
-  #define EM_DEBUG_ADDR_WIDTH 5
-  #define SR_DEBUG_ADDR_LBN 21
-  #define SR_DEBUG_ADDR_WIDTH 5
-  #define EV_DEBUG_ADDR_LBN 16
-  #define EV_DEBUG_ADDR_WIDTH 5
-  #define RX_DEBUG_ADDR_LBN 11
-  #define RX_DEBUG_ADDR_WIDTH 5
-  #define TX_DEBUG_ADDR_LBN 6
-  #define TX_DEBUG_ADDR_WIDTH 5
-  #define BIU_DEBUG_ADDR_LBN 1
-  #define BIU_DEBUG_ADDR_WIDTH 5
-  #define DEBUG_EN_LBN 0
-  #define DEBUG_EN_WIDTH 1
-#define DRIVER_REG0_KER_OFST 0x280 /* Driver scratch register 0 */
-#define DRIVER_REG0_OFST 0x280 /* Driver scratch register 0 */
-  #define DRIVER_DW0_LBN 0
-  #define DRIVER_DW0_WIDTH 32
-#define DRIVER_REG1_KER_OFST 0x290 /* Driver scratch register 1 */
-#define DRIVER_REG1_OFST 0x290 /* Driver scratch register 1 */
-  #define DRIVER_DW1_LBN 0
-  #define DRIVER_DW1_WIDTH 32
-#define DRIVER_REG2_KER_OFST 0x2A0 /* Driver scratch register 2 */
-#define DRIVER_REG2_OFST 0x2A0 /* Driver scratch register 2 */
-  #define DRIVER_DW2_LBN 0
-  #define DRIVER_DW2_WIDTH 32
-#define DRIVER_REG3_KER_OFST 0x2B0 /* Driver scratch register 3 */
-#define DRIVER_REG3_OFST 0x2B0 /* Driver scratch register 3 */
-  #define DRIVER_DW3_LBN 0
-  #define DRIVER_DW3_WIDTH 32
-#define DRIVER_REG4_KER_OFST 0x2C0 /* Driver scratch register 4 */
-#define DRIVER_REG4_OFST 0x2C0 /* Driver scratch register 4 */
-  #define DRIVER_DW4_LBN 0
-  #define DRIVER_DW4_WIDTH 32
-#define DRIVER_REG5_KER_OFST 0x2D0 /* Driver scratch register 5 */
-#define DRIVER_REG5_OFST 0x2D0 /* Driver scratch register 5 */
-  #define DRIVER_DW5_LBN 0
-  #define DRIVER_DW5_WIDTH 32
-#define DRIVER_REG6_KER_OFST 0x2E0 /* Driver scratch register 6 */
-#define DRIVER_REG6_OFST 0x2E0 /* Driver scratch register 6 */
-  #define DRIVER_DW6_LBN 0
-  #define DRIVER_DW6_WIDTH 32
-#define DRIVER_REG7_KER_OFST 0x2F0 /* Driver scratch register 7 */
-#define DRIVER_REG7_OFST 0x2F0 /* Driver scratch register 7 */
-  #define DRIVER_DW7_LBN 0
-  #define DRIVER_DW7_WIDTH 32
-#define ALTERA_BUILD_REG_OFST 0x300 /* Altera build register */
-#define ALTERA_BUILD_REG_OFST 0x300 /* Altera build register */
-  #define ALTERA_BUILD_VER_LBN 0
-  #define ALTERA_BUILD_VER_WIDTH 32
-
-/* so called CSR spare register
-    - contains separate parity enable bits for the various internal memory
-    blocks */
-#define MEM_PARITY_ERR_EN_REG_KER 0x310
-#define MEM_PARITY_ALL_BLOCKS_EN_LBN 64
-#define MEM_PARITY_ALL_BLOCKS_EN_WIDTH 38
-#define MEM_PARITY_TX_DATA_EN_LBN   72
-#define MEM_PARITY_TX_DATA_EN_WIDTH 2
-
-/*************---- Event & Timer Module Registers C Header ----*************/
-
-#if FALCON_EXTENDED_P_BAR
-#define EVQ_RPTR_REG_KER_OFST 0x11B00 /* Event queue read pointer register */
-#else
-#define EVQ_RPTR_REG_KER_OFST 0x1B00 /* Event queue read pointer register */
-#endif
-
-#define EVQ_RPTR_REG_OFST 0xFA0000 /* Event queue read pointer register
-				      array. */
-  #define EVQ_RPTR_LBN 0
-  #define EVQ_RPTR_WIDTH 15
-
-#if FALCON_EXTENDED_P_BAR
-#define EVQ_PTR_TBL_KER_OFST 0x11A00 /* Event queue pointer table for kernel
-					access */
-#else
-#define EVQ_PTR_TBL_KER_OFST 0x1A00 /* Event queue pointer table for kernel
-				       access */
-#endif
-
-#define EVQ_PTR_TBL_CHAR_OFST 0xF60000 /* Event queue pointer table for char
-					  direct access */
-  #define EVQ_WKUP_OR_INT_EN_LBN 39
-  #define EVQ_WKUP_OR_INT_EN_WIDTH 1
-  #define EVQ_NXT_WPTR_LBN 24
-  #define EVQ_NXT_WPTR_WIDTH 15
-  #define EVQ_EN_LBN 23
-  #define EVQ_EN_WIDTH 1
-  #define EVQ_SIZE_LBN 20
-  #define EVQ_SIZE_WIDTH 3
-  #define EVQ_BUF_BASE_ID_LBN 0
-  #define EVQ_BUF_BASE_ID_WIDTH 20
-#define TIMER_CMD_REG_KER_OFST 0x420 /* Timer table for kernel access.
-					Page-mapped */
-#define TIMER_CMD_REG_PAGE4_OFST 0x8420 /* Timer table for user-level access.
-					   Page-mapped. For lowest 1K queues.
-					 */
-#define TIMER_CMD_REG_PAGE123K_OFST 0x1000420 /* Timer table for user-level
-						 access. Page-mapped.
-						 For upper 3K queues. */
-#define TIMER_TBL_OFST 0xF70000 /* Timer table for char driver direct access */
-  #define TIMER_MODE_LBN 12
-  #define TIMER_MODE_WIDTH 2
-  #define TIMER_VAL_LBN 0
-  #define TIMER_VAL_WIDTH 12
-  #define TIMER_MODE_INT_HLDOFF 2
-  #define EVQ_BUF_SIZE_LBN 0
-  #define EVQ_BUF_SIZE_WIDTH 1
-#define DRV_EV_REG_KER_OFST 0x440 /* Driver generated event register */
-#define DRV_EV_REG_OFST 0x440 /* Driver generated event register */
-  #define DRV_EV_QID_LBN 64
-  #define DRV_EV_QID_WIDTH 12
-  #define DRV_EV_DATA_LBN 0
-  #define DRV_EV_DATA_WIDTH 64
-#define EVQ_CTL_REG_KER_OFST 0x450 /* Event queue control register */
-#define EVQ_CTL_REG_OFST 0x450 /* Event queue control register */
-  #define RX_EVQ_WAKEUP_MASK_B0_LBN 15
-  #define RX_EVQ_WAKEUP_MASK_B0_WIDTH 6
-  #define EVQ_OWNERR_CTL_LBN 14
-  #define EVQ_OWNERR_CTL_WIDTH 1
-  #define EVQ_FIFO_AF_TH_LBN 8
-  #define EVQ_FIFO_AF_TH_WIDTH 6
-  #define EVQ_FIFO_NOTAF_TH_LBN 0
-  #define EVQ_FIFO_NOTAF_TH_WIDTH 6
-/*************---- SRAM Module Registers C Header ----*************/
-#define BUF_TBL_CFG_REG_KER_OFST 0x600 /* Buffer table configuration register */
-#define BUF_TBL_CFG_REG_OFST 0x600 /* Buffer table configuration register */
-  #define BUF_TBL_MODE_LBN 3
-  #define BUF_TBL_MODE_WIDTH 1
-#define SRM_RX_DC_CFG_REG_KER_OFST 0x610 /* SRAM receive descriptor cache
-					    configuration register */
-#define SRM_RX_DC_CFG_REG_OFST 0x610 /* SRAM receive descriptor cache
-					configuration register */
-  #define SRM_RX_DC_BASE_ADR_LBN 0
-  #define SRM_RX_DC_BASE_ADR_WIDTH 21
-#define SRM_TX_DC_CFG_REG_KER_OFST 0x620 /* SRAM transmit descriptor cache
-					    configuration register */
-#define SRM_TX_DC_CFG_REG_OFST 0x620 /* SRAM transmit descriptor cache
-					configuration register */
-  #define SRM_TX_DC_BASE_ADR_LBN 0
-  #define SRM_TX_DC_BASE_ADR_WIDTH 21
-#define SRM_CFG_REG_KER_OFST 0x630 /* SRAM configuration register */
-#define SRM_CFG_REG_OFST 0x630 /* SRAM configuration register */
-  #define SRAM_OOB_ADR_INTEN_LBN 5
-  #define SRAM_OOB_ADR_INTEN_WIDTH 1
-  #define SRAM_OOB_BUF_INTEN_LBN 4
-  #define SRAM_OOB_BUF_INTEN_WIDTH 1
-  #define SRAM_BT_INIT_EN_LBN 3
-  #define SRAM_BT_INIT_EN_WIDTH 1
-  #define SRM_NUM_BANK_LBN 2
-  #define SRM_NUM_BANK_WIDTH 1
-  #define SRM_BANK_SIZE_LBN 0
-  #define SRM_BANK_SIZE_WIDTH 2
-#define BUF_TBL_UPD_REG_KER_OFST 0x650 /* Buffer table update register */
-#define BUF_TBL_UPD_REG_OFST 0x650 /* Buffer table update register */
-  #define BUF_UPD_CMD_LBN 63
-  #define BUF_UPD_CMD_WIDTH 1
-  #define BUF_CLR_CMD_LBN 62
-  #define BUF_CLR_CMD_WIDTH 1
-  #define BUF_CLR_END_ID_LBN 32
-  #define BUF_CLR_END_ID_WIDTH 20
-  #define BUF_CLR_START_ID_LBN 0
-  #define BUF_CLR_START_ID_WIDTH 20
-#define SRM_UPD_EVQ_REG_KER_OFST 0x660 /* Buffer table update register */
-#define SRM_UPD_EVQ_REG_OFST 0x660 /* Buffer table update register */
-  #define SRM_UPD_EVQ_ID_LBN 0
-  #define SRM_UPD_EVQ_ID_WIDTH 12
-#define SRAM_PARITY_REG_KER_OFST 0x670 /* SRAM parity register. */
-#define SRAM_PARITY_REG_OFST 0x670 /* SRAM parity register. */
-  #define FORCE_SRAM_PERR_LBN 0
-  #define FORCE_SRAM_PERR_WIDTH 1
-
-#if FALCON_EXTENDED_P_BAR
-#define BUF_HALF_TBL_KER_OFST 0x18000 /* Buffer table in half buffer table
-					 mode direct access by kernel driver */
-#else
-#define BUF_HALF_TBL_KER_OFST 0x8000 /* Buffer table in half buffer table
-					mode direct access by kernel driver */
-#endif
-
-
-#define BUF_HALF_TBL_OFST 0x800000 /* Buffer table in half buffer table mode
-				      direct access by char driver */
-  #define BUF_ADR_HBUF_ODD_LBN 44
-  #define BUF_ADR_HBUF_ODD_WIDTH 20
-  #define BUF_OWNER_ID_HBUF_ODD_LBN 32
-  #define BUF_OWNER_ID_HBUF_ODD_WIDTH 12
-  #define BUF_ADR_HBUF_EVEN_LBN 12
-  #define BUF_ADR_HBUF_EVEN_WIDTH 20
-  #define BUF_OWNER_ID_HBUF_EVEN_LBN 0
-  #define BUF_OWNER_ID_HBUF_EVEN_WIDTH 12
-
-
-#if FALCON_EXTENDED_P_BAR
-#define BUF_FULL_TBL_KER_OFST 0x18000 /* Buffer table in full buffer table
-					 mode direct access by kernel driver */
-#else
-#define BUF_FULL_TBL_KER_OFST 0x8000 /* Buffer table in full buffer table mode
-					direct access by kernel driver */
-#endif
-
-
-
-
-#define BUF_FULL_TBL_OFST 0x800000 /* Buffer table in full buffer table mode
-				      direct access by char driver */
-  #define IP_DAT_BUF_SIZE_LBN 50
-  #define IP_DAT_BUF_SIZE_WIDTH 1
-  #define BUF_ADR_REGION_LBN 48
-  #define BUF_ADR_REGION_WIDTH 2
-  #define BUF_ADR_FBUF_LBN 14
-  #define BUF_ADR_FBUF_WIDTH 34
-  #define BUF_OWNER_ID_FBUF_LBN 0
-  #define BUF_OWNER_ID_FBUF_WIDTH 14
-#define SRM_DBG_REG_OFST 0x3000000 /* SRAM debug access */
-  #define SRM_DBG_LBN 0
-  #define SRM_DBG_WIDTH 64
-/*************---- RX Datapath Registers C Header ----*************/
-
-#define RX_CFG_REG_KER_OFST 0x800 /* Receive configuration register */
-#define RX_CFG_REG_OFST 0x800 /* Receive configuration register */
-
-#if !defined(FALCON_64K_RXFIFO) && !defined(FALCON_PRE_02020029)
-# if !defined(FALCON_128K_RXFIFO)
-#  define FALCON_128K_RXFIFO
-# endif
-#endif
-
-#if defined(FALCON_128K_RXFIFO)
-
-/* new for B0 */
-  #define RX_TOEP_TCP_SUPPRESS_B0_LBN 48
-  #define RX_TOEP_TCP_SUPPRESS_B0_WIDTH 1
-  #define RX_INGR_EN_B0_LBN 47
-  #define RX_INGR_EN_B0_WIDTH 1
-  #define RX_TOEP_IPV4_B0_LBN 46
-  #define RX_TOEP_IPV4_B0_WIDTH 1
-  #define RX_HASH_ALG_B0_LBN 45
-  #define RX_HASH_ALG_B0_WIDTH 1
-  #define RX_HASH_INSERT_HDR_B0_LBN 44
-  #define RX_HASH_INSERT_HDR_B0_WIDTH 1
-/* moved for B0 */
-  #define RX_DESC_PUSH_EN_B0_LBN 43
-  #define RX_DESC_PUSH_EN_B0_WIDTH 1
-  #define RX_RDW_PATCH_EN_LBN 42 /* Non head of line blocking */
-  #define RX_RDW_PATCH_EN_WIDTH 1
-  #define RX_PCI_BURST_SIZE_B0_LBN 39
-  #define RX_PCI_BURST_SIZE_B0_WIDTH 3
-  #define RX_OWNERR_CTL_B0_LBN 38
-  #define RX_OWNERR_CTL_B0_WIDTH 1
-  #define RX_XON_TX_TH_B0_LBN 33
-  #define RX_XON_TX_TH_B0_WIDTH 5
-  #define RX_XOFF_TX_TH_B0_LBN 28
-  #define RX_XOFF_TX_TH_B0_WIDTH 5
-  #define RX_USR_BUF_SIZE_B0_LBN 19
-  #define RX_USR_BUF_SIZE_B0_WIDTH 9
-  #define RX_XON_MAC_TH_B0_LBN 10
-  #define RX_XON_MAC_TH_B0_WIDTH 9
-  #define RX_XOFF_MAC_TH_B0_LBN 1
-  #define RX_XOFF_MAC_TH_B0_WIDTH 9
-  #define RX_XOFF_MAC_EN_B0_LBN 0
-  #define RX_XOFF_MAC_EN_B0_WIDTH 1
-
-#elif !defined(FALCON_PRE_02020029)
-/* new for B0 */
-  #define RX_TOEP_TCP_SUPPRESS_B0_LBN 46
-  #define RX_TOEP_TCP_SUPPRESS_B0_WIDTH 1
-  #define RX_INGR_EN_B0_LBN 45
-  #define RX_INGR_EN_B0_WIDTH 1
-  #define RX_TOEP_IPV4_B0_LBN 44
-  #define RX_TOEP_IPV4_B0_WIDTH 1
-  #define RX_HASH_ALG_B0_LBN 43
-  #define RX_HASH_ALG_B0_WIDTH 41
-  #define RX_HASH_INSERT_HDR_B0_LBN 42
-  #define RX_HASH_INSERT_HDR_B0_WIDTH 1
-/* moved for B0 */
-  #define RX_DESC_PUSH_EN_B0_LBN 41
-  #define RX_DESC_PUSH_EN_B0_WIDTH 1
-  #define RX_PCI_BURST_SIZE_B0_LBN 37
-  #define RX_PCI_BURST_SIZE_B0_WIDTH 3
-  #define RX_OWNERR_CTL_B0_LBN 36
-  #define RX_OWNERR_CTL_B0_WIDTH 1
-  #define RX_XON_TX_TH_B0_LBN 31
-  #define RX_XON_TX_TH_B0_WIDTH 5
-  #define RX_XOFF_TX_TH_B0_LBN 26
-  #define RX_XOFF_TX_TH_B0_WIDTH 5
-  #define RX_USR_BUF_SIZE_B0_LBN 17
-  #define RX_USR_BUF_SIZE_B0_WIDTH 9
-  #define RX_XON_MAC_TH_B0_LBN 9
-  #define RX_XON_MAC_TH_B0_WIDTH 8
-  #define RX_XOFF_MAC_TH_B0_LBN 1
-  #define RX_XOFF_MAC_TH_B0_WIDTH 8
-  #define RX_XOFF_MAC_EN_B0_LBN 0
-  #define RX_XOFF_MAC_EN_B0_WIDTH 1
-
-#else
-/* new for B0 */
-  #define RX_TOEP_TCP_SUPPRESS_B0_LBN 44
-  #define RX_TOEP_TCP_SUPPRESS_B0_WIDTH 1
-  #define RX_INGR_EN_B0_LBN 43
-  #define RX_INGR_EN_B0_WIDTH 1
-  #define RX_TOEP_IPV4_B0_LBN 42
-  #define RX_TOEP_IPV4_B0_WIDTH 1
-  #define RX_HASH_ALG_B0_LBN 41
-  #define RX_HASH_ALG_B0_WIDTH 41
-  #define RX_HASH_INSERT_HDR_B0_LBN 40
-  #define RX_HASH_INSERT_HDR_B0_WIDTH 1
-/* moved for B0 */
-  #define RX_DESC_PUSH_EN_B0_LBN 35
-  #define RX_DESC_PUSH_EN_B0_WIDTH 1
-  #define RX_PCI_BURST_SIZE_B0_LBN 35
-  #define RX_PCI_BURST_SIZE_B0_WIDTH 2
-  #define RX_OWNERR_CTL_B0_LBN 34
-  #define RX_OWNERR_CTL_B0_WIDTH 1
-  #define RX_XON_TX_TH_B0_LBN 29
-  #define RX_XON_TX_TH_B0_WIDTH 5
-  #define RX_XOFF_TX_TH_B0_LBN 24
-  #define RX_XOFF_TX_TH_B0_WIDTH 5
-  #define RX_USR_BUF_SIZE_B0_LBN 15
-  #define RX_USR_BUF_SIZE_B0_WIDTH 9
-  #define RX_XON_MAC_TH_B0_LBN 8
-  #define RX_XON_MAC_TH_B0_WIDTH 7
-  #define RX_XOFF_MAC_TH_B0_LBN 1
-  #define RX_XOFF_MAC_TH_B0_WIDTH 7
-  #define RX_XOFF_MAC_EN_B0_LBN 0
-  #define RX_XOFF_MAC_EN_B0_WIDTH 1
-
-#endif
-
-/* A0/A1 */
-  #define RX_PUSH_EN_A1_LBN 35
-  #define RX_PUSH_EN_A1_WIDTH 1
-  #define RX_PCI_BURST_SIZE_A1_LBN 31
-  #define RX_PCI_BURST_SIZE_A1_WIDTH 3
-  #define RX_OWNERR_CTL_A1_LBN 30
-  #define RX_OWNERR_CTL_A1_WIDTH 1
-  #define RX_XON_TX_TH_A1_LBN 25
-  #define RX_XON_TX_TH_A1_WIDTH 5
-  #define RX_XOFF_TX_TH_A1_LBN 20
-  #define RX_XOFF_TX_TH_A1_WIDTH 5
-  #define RX_USR_BUF_SIZE_A1_LBN 11
-  #define RX_USR_BUF_SIZE_A1_WIDTH 9
-  #define RX_XON_MAC_TH_A1_LBN 6
-  #define RX_XON_MAC_TH_A1_WIDTH 5
-  #define RX_XOFF_MAC_TH_A1_LBN 1
-  #define RX_XOFF_MAC_TH_A1_WIDTH 5
-  #define RX_XOFF_MAC_EN_A1_LBN 0
-  #define RX_XOFF_MAC_EN_A1_WIDTH 1
-
-#define RX_FILTER_CTL_REG_OFST 0x810 /* Receive filter control registers */
-  #define SCATTER_ENBL_NO_MATCH_Q_B0_LBN 40
-  #define SCATTER_ENBL_NO_MATCH_Q_B0_WIDTH 1
-  #define UDP_FULL_SRCH_LIMIT_LBN 32
-  #define UDP_FULL_SRCH_LIMIT_WIDTH 8
-  #define NUM_KER_LBN 24
-  #define NUM_KER_WIDTH 2
-  #define UDP_WILD_SRCH_LIMIT_LBN 16
-  #define UDP_WILD_SRCH_LIMIT_WIDTH 8
-  #define TCP_WILD_SRCH_LIMIT_LBN 8
-  #define TCP_WILD_SRCH_LIMIT_WIDTH 8
-  #define TCP_FULL_SRCH_LIMIT_LBN 0
-  #define TCP_FULL_SRCH_LIMIT_WIDTH 8
-#define RX_FLUSH_DESCQ_REG_KER_OFST 0x820 /* Receive flush descriptor queue
-					     register */
-#define RX_FLUSH_DESCQ_REG_OFST 0x820 /* Receive flush descriptor queue
-					 register */
-  #define RX_FLUSH_DESCQ_CMD_LBN 24
-  #define RX_FLUSH_DESCQ_CMD_WIDTH 1
-  #define RX_FLUSH_EVQ_ID_LBN 12
-  #define RX_FLUSH_EVQ_ID_WIDTH 12
-  #define RX_FLUSH_DESCQ_LBN 0
-  #define RX_FLUSH_DESCQ_WIDTH 12
-#define RX_DESC_UPD_REG_KER_OFST 0x830 /* Kernel  receive descriptor update
-					  register. Page-mapped */
-#define RX_DESC_UPD_REG_PAGE4_OFST 0x8830 /* Char & user receive descriptor
-					     update register. Page-mapped.
-					     For lowest 1K queues. */
-#define RX_DESC_UPD_REG_PAGE123K_OFST 0x1000830 /* Char & user receive
-						   descriptor update register.
-						   Page-mapped. For upper
-						   3K queues. */
-  #define RX_DESC_WPTR_LBN 96
-  #define RX_DESC_WPTR_WIDTH 12
-  #define RX_DESC_PUSH_CMD_LBN 95
-  #define RX_DESC_PUSH_CMD_WIDTH 1
-  #define RX_DESC_LBN 0
-  #define RX_DESC_WIDTH 64
-  #define RX_KER_DESC_LBN 0
-  #define RX_KER_DESC_WIDTH 64
-  #define RX_USR_DESC_LBN 0
-  #define RX_USR_DESC_WIDTH 32
-#define RX_DC_CFG_REG_KER_OFST 0x840 /* Receive descriptor cache
-					configuration register */
-#define RX_DC_CFG_REG_OFST 0x840 /* Receive descriptor cache
-				    configuration register */
-  #define RX_DC_SIZE_LBN 0
-  #define RX_DC_SIZE_WIDTH 2
-#define RX_DC_PF_WM_REG_KER_OFST 0x850 /* Receive descriptor cache pre-fetch
-					  watermark register */
-#define RX_DC_PF_WM_REG_OFST 0x850 /* Receive descriptor cache pre-fetch
-				      watermark register */
-  #define RX_DC_PF_LWM_LO_LBN 0
-  #define RX_DC_PF_LWM_LO_WIDTH 6
-
-#define RX_RSS_TKEY_B0_OFST 0x860 /* RSS Toeplitz hash key (B0 only) */
-
-#define RX_NODESC_DROP_REG 0x880
-  #define RX_NODESC_DROP_CNT_LBN 0
-  #define RX_NODESC_DROP_CNT_WIDTH 16
-
-#define XM_TX_CFG_REG_OFST 0x1230
-  #define XM_AUTO_PAD_LBN 5
-  #define XM_AUTO_PAD_WIDTH 1
-
-#define RX_FILTER_TBL0_OFST 0xF00000 /* Receive filter table - even entries */
-  #define RSS_EN_0_B0_LBN 110
-  #define RSS_EN_0_B0_WIDTH 1
-  #define SCATTER_EN_0_B0_LBN 109
-  #define SCATTER_EN_0_B0_WIDTH 1
-  #define TCP_UDP_0_LBN 108
-  #define TCP_UDP_0_WIDTH 1
-  #define RXQ_ID_0_LBN 96
-  #define RXQ_ID_0_WIDTH 12
-  #define DEST_IP_0_LBN 64
-  #define DEST_IP_0_WIDTH 32
-  #define DEST_PORT_TCP_0_LBN 48
-  #define DEST_PORT_TCP_0_WIDTH 16
-  #define SRC_IP_0_LBN 16
-  #define SRC_IP_0_WIDTH 32
-  #define SRC_TCP_DEST_UDP_0_LBN 0
-  #define SRC_TCP_DEST_UDP_0_WIDTH 16
-#define RX_FILTER_TBL1_OFST 0xF00010 /* Receive filter table - odd entries */
-  #define RSS_EN_1_B0_LBN 110
-  #define RSS_EN_1_B0_WIDTH 1
-  #define SCATTER_EN_1_B0_LBN 109
-  #define SCATTER_EN_1_B0_WIDTH 1
-  #define TCP_UDP_1_LBN 108
-  #define TCP_UDP_1_WIDTH 1
-  #define RXQ_ID_1_LBN 96
-  #define RXQ_ID_1_WIDTH 12
-  #define DEST_IP_1_LBN 64
-  #define DEST_IP_1_WIDTH 32
-  #define DEST_PORT_TCP_1_LBN 48
-  #define DEST_PORT_TCP_1_WIDTH 16
-  #define SRC_IP_1_LBN 16
-  #define SRC_IP_1_WIDTH 32
-  #define SRC_TCP_DEST_UDP_1_LBN 0
-  #define SRC_TCP_DEST_UDP_1_WIDTH 16
-
-#if FALCON_EXTENDED_P_BAR
-#define RX_DESC_PTR_TBL_KER_OFST 0x11800 /* Receive descriptor pointer
-					    kernel access */
-#else
-#define RX_DESC_PTR_TBL_KER_OFST 0x1800 /* Receive descriptor pointer
-					   kernel access */
-#endif
-
-
-#define RX_DESC_PTR_TBL_OFST 0xF40000 /* Receive descriptor pointer table */
-  #define RX_ISCSI_DDIG_EN_LBN 88
-  #define RX_ISCSI_DDIG_EN_WIDTH 1
-  #define RX_ISCSI_HDIG_EN_LBN 87
-  #define RX_ISCSI_HDIG_EN_WIDTH 1
-  #define RX_DESC_PREF_ACT_LBN 86
-  #define RX_DESC_PREF_ACT_WIDTH 1
-  #define RX_DC_HW_RPTR_LBN 80
-  #define RX_DC_HW_RPTR_WIDTH 6
-  #define RX_DESCQ_HW_RPTR_LBN 68
-  #define RX_DESCQ_HW_RPTR_WIDTH 12
-  #define RX_DESCQ_SW_WPTR_LBN 56
-  #define RX_DESCQ_SW_WPTR_WIDTH 12
-  #define RX_DESCQ_BUF_BASE_ID_LBN 36
-  #define RX_DESCQ_BUF_BASE_ID_WIDTH 20
-  #define RX_DESCQ_EVQ_ID_LBN 24
-  #define RX_DESCQ_EVQ_ID_WIDTH 12
-  #define RX_DESCQ_OWNER_ID_LBN 10
-  #define RX_DESCQ_OWNER_ID_WIDTH 14
-  #define RX_DESCQ_LABEL_LBN 5
-  #define RX_DESCQ_LABEL_WIDTH 5
-  #define RX_DESCQ_SIZE_LBN 3
-  #define RX_DESCQ_SIZE_WIDTH 2
-  #define RX_DESCQ_TYPE_LBN 2
-  #define RX_DESCQ_TYPE_WIDTH 1
-  #define RX_DESCQ_JUMBO_LBN 1
-  #define RX_DESCQ_JUMBO_WIDTH 1
-  #define RX_DESCQ_EN_LBN 0
-  #define RX_DESCQ_EN_WIDTH 1
-
-
-#define RX_RSS_INDIR_TBL_B0_OFST 0xFB0000 /* RSS indirection table (B0 only) */
-  #define RX_RSS_INDIR_ENT_B0_LBN 0
-  #define RX_RSS_INDIR_ENT_B0_WIDTH 6
-
-/*************---- TX Datapath Registers C Header ----*************/
-#define TX_FLUSH_DESCQ_REG_KER_OFST 0xA00 /* Transmit flush descriptor
-					     queue register */
-#define TX_FLUSH_DESCQ_REG_OFST 0xA00 /* Transmit flush descriptor queue
-					 register */
-  #define TX_FLUSH_DESCQ_CMD_LBN 12
-  #define TX_FLUSH_DESCQ_CMD_WIDTH 1
-  #define TX_FLUSH_DESCQ_LBN 0
-  #define TX_FLUSH_DESCQ_WIDTH 12
-#define TX_DESC_UPD_REG_KER_OFST 0xA10 /* Kernel transmit descriptor update
-					  register. Page-mapped */
-#define TX_DESC_UPD_REG_PAGE4_OFST 0x8A10 /* Char & user transmit descriptor
-					     update register. Page-mapped */
-#define TX_DESC_UPD_REG_PAGE123K_OFST 0x1000A10 /* Char & user transmit
-						   descriptor update register.
-						   Page-mapped */
-  #define TX_DESC_WPTR_LBN 96
-  #define TX_DESC_WPTR_WIDTH 12
-  #define TX_DESC_PUSH_CMD_LBN 95
-  #define TX_DESC_PUSH_CMD_WIDTH 1
-  #define TX_DESC_LBN 0
-  #define TX_DESC_WIDTH 95
-  #define TX_KER_DESC_LBN 0
-  #define TX_KER_DESC_WIDTH 64
-  #define TX_USR_DESC_LBN 0
-  #define TX_USR_DESC_WIDTH 64
-#define TX_DC_CFG_REG_KER_OFST 0xA20 /* Transmit descriptor cache
-					configuration register */
-#define TX_DC_CFG_REG_OFST 0xA20 /* Transmit descriptor cache configuration
-				    register */
-  #define TX_DC_SIZE_LBN 0
-  #define TX_DC_SIZE_WIDTH 2
-
-#if FALCON_EXTENDED_P_BAR
-#define TX_DESC_PTR_TBL_KER_OFST 0x11900 /* Transmit descriptor pointer. */
-#else
-#define TX_DESC_PTR_TBL_KER_OFST 0x1900 /* Transmit descriptor pointer. */
-#endif
-
-
-#define TX_DESC_PTR_TBL_OFST 0xF50000 /* Transmit descriptor pointer */
-  #define TX_NON_IP_DROP_DIS_B0_LBN 91
-  #define TX_NON_IP_DROP_DIS_B0_WIDTH 1
-  #define TX_IP_CHKSM_DIS_B0_LBN 90
-  #define TX_IP_CHKSM_DIS_B0_WIDTH 1
-  #define TX_TCP_CHKSM_DIS_B0_LBN 89
-  #define TX_TCP_CHKSM_DIS_B0_WIDTH 1
-  #define TX_DESCQ_EN_LBN 88
-  #define TX_DESCQ_EN_WIDTH 1
-  #define TX_ISCSI_DDIG_EN_LBN 87
-  #define TX_ISCSI_DDIG_EN_WIDTH 1
-  #define TX_ISCSI_HDIG_EN_LBN 86
-  #define TX_ISCSI_HDIG_EN_WIDTH 1
-  #define TX_DC_HW_RPTR_LBN 80
-  #define TX_DC_HW_RPTR_WIDTH 6
-  #define TX_DESCQ_HW_RPTR_LBN 68
-  #define TX_DESCQ_HW_RPTR_WIDTH 12
-  #define TX_DESCQ_SW_WPTR_LBN 56
-  #define TX_DESCQ_SW_WPTR_WIDTH 12
-  #define TX_DESCQ_BUF_BASE_ID_LBN 36
-  #define TX_DESCQ_BUF_BASE_ID_WIDTH 20
-  #define TX_DESCQ_EVQ_ID_LBN 24
-  #define TX_DESCQ_EVQ_ID_WIDTH 12
-  #define TX_DESCQ_OWNER_ID_LBN 10
-  #define TX_DESCQ_OWNER_ID_WIDTH 14
-  #define TX_DESCQ_LABEL_LBN 5
-  #define TX_DESCQ_LABEL_WIDTH 5
-  #define TX_DESCQ_SIZE_LBN 3
-  #define TX_DESCQ_SIZE_WIDTH 2
-  #define TX_DESCQ_TYPE_LBN 1
-  #define TX_DESCQ_TYPE_WIDTH 2
-  #define TX_DESCQ_FLUSH_LBN 0
-  #define TX_DESCQ_FLUSH_WIDTH 1
-#define TX_CFG_REG_KER_OFST 0xA50 /* Transmit configuration register */
-#define TX_CFG_REG_OFST 0xA50 /* Transmit configuration register */
-  #define TX_IP_ID_P1_OFS_LBN 32
-  #define TX_IP_ID_P1_OFS_WIDTH 15
-  #define TX_IP_ID_P0_OFS_LBN 16
-  #define TX_IP_ID_P0_OFS_WIDTH 15
-  #define TX_TURBO_EN_LBN 3
-  #define TX_TURBO_EN_WIDTH 1
-  #define TX_OWNERR_CTL_LBN 2
-  #define TX_OWNERR_CTL_WIDTH 2
-  #define TX_NON_IP_DROP_DIS_LBN 1
-  #define TX_NON_IP_DROP_DIS_WIDTH 1
-  #define TX_IP_ID_REP_EN_LBN 0
-  #define TX_IP_ID_REP_EN_WIDTH 1
-#define TX_RESERVED_REG_KER_OFST 0xA80 /* Transmit configuration register */
-#define TX_RESERVED_REG_OFST 0xA80 /* Transmit configuration register */
-  #define TX_CSR_PUSH_EN_LBN 89
-  #define TX_CSR_PUSH_EN_WIDTH 1
-  #define TX_RX_SPACER_LBN 64
-  #define TX_RX_SPACER_WIDTH 8
-  #define TX_SW_EV_EN_LBN 59
-  #define TX_SW_EV_EN_WIDTH 1
-  #define TX_RX_SPACER_EN_LBN 57
-  #define TX_RX_SPACER_EN_WIDTH 1
-  #define TX_CSR_PREF_WD_TMR_LBN 24
-  #define TX_CSR_PREF_WD_TMR_WIDTH 16
-  #define TX_CSR_ONLY1TAG_LBN 21
-  #define TX_CSR_ONLY1TAG_WIDTH 1
-  #define TX_PREF_THRESHOLD_LBN 19
-  #define TX_PREF_THRESHOLD_WIDTH 2
-  #define TX_ONE_PKT_PER_Q_LBN 18
-  #define TX_ONE_PKT_PER_Q_WIDTH 1
-  #define TX_DIS_NON_IP_EV_LBN 17
-  #define TX_DIS_NON_IP_EV_WIDTH 1
-  #define TX_DMA_SPACER_LBN 8
-  #define TX_DMA_SPACER_WIDTH 8
-  #define TX_FLUSH_MIN_LEN_EN_B0_LBN 7
-  #define TX_FLUSH_MIN_LEN_EN_B0_WIDTH 1
-  #define TX_TCP_DIS_A1_LBN 7
-  #define TX_TCP_DIS_A1_WIDTH 1
-  #define TX_IP_DIS_A1_LBN 6
-  #define TX_IP_DIS_A1_WIDTH 1
-  #define TX_MAX_CPL_LBN 2
-  #define TX_MAX_CPL_WIDTH 2
-  #define TX_MAX_PREF_LBN 0
-  #define TX_MAX_PREF_WIDTH 2
-#define TX_VLAN_REG_OFST 0xAE0 /* Transmit VLAN tag register */
-  #define TX_VLAN_EN_LBN 127
-  #define TX_VLAN_EN_WIDTH 1
-  #define TX_VLAN7_PORT1_EN_LBN 125
-  #define TX_VLAN7_PORT1_EN_WIDTH 1
-  #define TX_VLAN7_PORT0_EN_LBN 124
-  #define TX_VLAN7_PORT0_EN_WIDTH 1
-  #define TX_VLAN7_LBN 112
-  #define TX_VLAN7_WIDTH 12
-  #define TX_VLAN6_PORT1_EN_LBN 109
-  #define TX_VLAN6_PORT1_EN_WIDTH 1
-  #define TX_VLAN6_PORT0_EN_LBN 108
-  #define TX_VLAN6_PORT0_EN_WIDTH 1
-  #define TX_VLAN6_LBN 96
-  #define TX_VLAN6_WIDTH 12
-  #define TX_VLAN5_PORT1_EN_LBN 93
-  #define TX_VLAN5_PORT1_EN_WIDTH 1
-  #define TX_VLAN5_PORT0_EN_LBN 92
-  #define TX_VLAN5_PORT0_EN_WIDTH 1
-  #define TX_VLAN5_LBN 80
-  #define TX_VLAN5_WIDTH 12
-  #define TX_VLAN4_PORT1_EN_LBN 77
-  #define TX_VLAN4_PORT1_EN_WIDTH 1
-  #define TX_VLAN4_PORT0_EN_LBN 76
-  #define TX_VLAN4_PORT0_EN_WIDTH 1
-  #define TX_VLAN4_LBN 64
-  #define TX_VLAN4_WIDTH 12
-  #define TX_VLAN3_PORT1_EN_LBN 61
-  #define TX_VLAN3_PORT1_EN_WIDTH 1
-  #define TX_VLAN3_PORT0_EN_LBN 60
-  #define TX_VLAN3_PORT0_EN_WIDTH 1
-  #define TX_VLAN3_LBN 48
-  #define TX_VLAN3_WIDTH 12
-  #define TX_VLAN2_PORT1_EN_LBN 45
-  #define TX_VLAN2_PORT1_EN_WIDTH 1
-  #define TX_VLAN2_PORT0_EN_LBN 44
-  #define TX_VLAN2_PORT0_EN_WIDTH 1
-  #define TX_VLAN2_LBN 32
-  #define TX_VLAN2_WIDTH 12
-  #define TX_VLAN1_PORT1_EN_LBN 29
-  #define TX_VLAN1_PORT1_EN_WIDTH 1
-  #define TX_VLAN1_PORT0_EN_LBN 28
-  #define TX_VLAN1_PORT0_EN_WIDTH 1
-  #define TX_VLAN1_LBN 16
-  #define TX_VLAN1_WIDTH 12
-  #define TX_VLAN0_PORT1_EN_LBN 13
-  #define TX_VLAN0_PORT1_EN_WIDTH 1
-  #define TX_VLAN0_PORT0_EN_LBN 12
-  #define TX_VLAN0_PORT0_EN_WIDTH 1
-  #define TX_VLAN0_LBN 0
-  #define TX_VLAN0_WIDTH 12
-#define TX_FIL_CTL_REG_OFST 0xAF0 /* Transmit filter control register */
-  #define TX_MADR1_FIL_EN_LBN 65
-  #define TX_MADR1_FIL_EN_WIDTH 1
-  #define TX_MADR0_FIL_EN_LBN 64
-  #define TX_MADR0_FIL_EN_WIDTH 1
-  #define TX_IPFIL31_PORT1_EN_LBN 63
-  #define TX_IPFIL31_PORT1_EN_WIDTH 1
-  #define TX_IPFIL31_PORT0_EN_LBN 62
-  #define TX_IPFIL31_PORT0_EN_WIDTH 1
-  #define TX_IPFIL30_PORT1_EN_LBN 61
-  #define TX_IPFIL30_PORT1_EN_WIDTH 1
-  #define TX_IPFIL30_PORT0_EN_LBN 60
-  #define TX_IPFIL30_PORT0_EN_WIDTH 1
-  #define TX_IPFIL29_PORT1_EN_LBN 59
-  #define TX_IPFIL29_PORT1_EN_WIDTH 1
-  #define TX_IPFIL29_PORT0_EN_LBN 58
-  #define TX_IPFIL29_PORT0_EN_WIDTH 1
-  #define TX_IPFIL28_PORT1_EN_LBN 57
-  #define TX_IPFIL28_PORT1_EN_WIDTH 1
-  #define TX_IPFIL28_PORT0_EN_LBN 56
-  #define TX_IPFIL28_PORT0_EN_WIDTH 1
-  #define TX_IPFIL27_PORT1_EN_LBN 55
-  #define TX_IPFIL27_PORT1_EN_WIDTH 1
-  #define TX_IPFIL27_PORT0_EN_LBN 54
-  #define TX_IPFIL27_PORT0_EN_WIDTH 1
-  #define TX_IPFIL26_PORT1_EN_LBN 53
-  #define TX_IPFIL26_PORT1_EN_WIDTH 1
-  #define TX_IPFIL26_PORT0_EN_LBN 52
-  #define TX_IPFIL26_PORT0_EN_WIDTH 1
-  #define TX_IPFIL25_PORT1_EN_LBN 51
-  #define TX_IPFIL25_PORT1_EN_WIDTH 1
-  #define TX_IPFIL25_PORT0_EN_LBN 50
-  #define TX_IPFIL25_PORT0_EN_WIDTH 1
-  #define TX_IPFIL24_PORT1_EN_LBN 49
-  #define TX_IPFIL24_PORT1_EN_WIDTH 1
-  #define TX_IPFIL24_PORT0_EN_LBN 48
-  #define TX_IPFIL24_PORT0_EN_WIDTH 1
-  #define TX_IPFIL23_PORT1_EN_LBN 47
-  #define TX_IPFIL23_PORT1_EN_WIDTH 1
-  #define TX_IPFIL23_PORT0_EN_LBN 46
-  #define TX_IPFIL23_PORT0_EN_WIDTH 1
-  #define TX_IPFIL22_PORT1_EN_LBN 45
-  #define TX_IPFIL22_PORT1_EN_WIDTH 1
-  #define TX_IPFIL22_PORT0_EN_LBN 44
-  #define TX_IPFIL22_PORT0_EN_WIDTH 1
-  #define TX_IPFIL21_PORT1_EN_LBN 43
-  #define TX_IPFIL21_PORT1_EN_WIDTH 1
-  #define TX_IPFIL21_PORT0_EN_LBN 42
-  #define TX_IPFIL21_PORT0_EN_WIDTH 1
-  #define TX_IPFIL20_PORT1_EN_LBN 41
-  #define TX_IPFIL20_PORT1_EN_WIDTH 1
-  #define TX_IPFIL20_PORT0_EN_LBN 40
-  #define TX_IPFIL20_PORT0_EN_WIDTH 1
-  #define TX_IPFIL19_PORT1_EN_LBN 39
-  #define TX_IPFIL19_PORT1_EN_WIDTH 1
-  #define TX_IPFIL19_PORT0_EN_LBN 38
-  #define TX_IPFIL19_PORT0_EN_WIDTH 1
-  #define TX_IPFIL18_PORT1_EN_LBN 37
-  #define TX_IPFIL18_PORT1_EN_WIDTH 1
-  #define TX_IPFIL18_PORT0_EN_LBN 36
-  #define TX_IPFIL18_PORT0_EN_WIDTH 1
-  #define TX_IPFIL17_PORT1_EN_LBN 35
-  #define TX_IPFIL17_PORT1_EN_WIDTH 1
-  #define TX_IPFIL17_PORT0_EN_LBN 34
-  #define TX_IPFIL17_PORT0_EN_WIDTH 1
-  #define TX_IPFIL16_PORT1_EN_LBN 33
-  #define TX_IPFIL16_PORT1_EN_WIDTH 1
-  #define TX_IPFIL16_PORT0_EN_LBN 32
-  #define TX_IPFIL16_PORT0_EN_WIDTH 1
-  #define TX_IPFIL15_PORT1_EN_LBN 31
-  #define TX_IPFIL15_PORT1_EN_WIDTH 1
-  #define TX_IPFIL15_PORT0_EN_LBN 30
-  #define TX_IPFIL15_PORT0_EN_WIDTH 1
-  #define TX_IPFIL14_PORT1_EN_LBN 29
-  #define TX_IPFIL14_PORT1_EN_WIDTH 1
-  #define TX_IPFIL14_PORT0_EN_LBN 28
-  #define TX_IPFIL14_PORT0_EN_WIDTH 1
-  #define TX_IPFIL13_PORT1_EN_LBN 27
-  #define TX_IPFIL13_PORT1_EN_WIDTH 1
-  #define TX_IPFIL13_PORT0_EN_LBN 26
-  #define TX_IPFIL13_PORT0_EN_WIDTH 1
-  #define TX_IPFIL12_PORT1_EN_LBN 25
-  #define TX_IPFIL12_PORT1_EN_WIDTH 1
-  #define TX_IPFIL12_PORT0_EN_LBN 24
-  #define TX_IPFIL12_PORT0_EN_WIDTH 1
-  #define TX_IPFIL11_PORT1_EN_LBN 23
-  #define TX_IPFIL11_PORT1_EN_WIDTH 1
-  #define TX_IPFIL11_PORT0_EN_LBN 22
-  #define TX_IPFIL11_PORT0_EN_WIDTH 1
-  #define TX_IPFIL10_PORT1_EN_LBN 21
-  #define TX_IPFIL10_PORT1_EN_WIDTH 1
-  #define TX_IPFIL10_PORT0_EN_LBN 20
-  #define TX_IPFIL10_PORT0_EN_WIDTH 1
-  #define TX_IPFIL9_PORT1_EN_LBN 19
-  #define TX_IPFIL9_PORT1_EN_WIDTH 1
-  #define TX_IPFIL9_PORT0_EN_LBN 18
-  #define TX_IPFIL9_PORT0_EN_WIDTH 1
-  #define TX_IPFIL8_PORT1_EN_LBN 17
-  #define TX_IPFIL8_PORT1_EN_WIDTH 1
-  #define TX_IPFIL8_PORT0_EN_LBN 16
-  #define TX_IPFIL8_PORT0_EN_WIDTH 1
-  #define TX_IPFIL7_PORT1_EN_LBN 15
-  #define TX_IPFIL7_PORT1_EN_WIDTH 1
-  #define TX_IPFIL7_PORT0_EN_LBN 14
-  #define TX_IPFIL7_PORT0_EN_WIDTH 1
-  #define TX_IPFIL6_PORT1_EN_LBN 13
-  #define TX_IPFIL6_PORT1_EN_WIDTH 1
-  #define TX_IPFIL6_PORT0_EN_LBN 12
-  #define TX_IPFIL6_PORT0_EN_WIDTH 1
-  #define TX_IPFIL5_PORT1_EN_LBN 11
-  #define TX_IPFIL5_PORT1_EN_WIDTH 1
-  #define TX_IPFIL5_PORT0_EN_LBN 10
-  #define TX_IPFIL5_PORT0_EN_WIDTH 1
-  #define TX_IPFIL4_PORT1_EN_LBN 9
-  #define TX_IPFIL4_PORT1_EN_WIDTH 1
-  #define TX_IPFIL4_PORT0_EN_LBN 8
-  #define TX_IPFIL4_PORT0_EN_WIDTH 1
-  #define TX_IPFIL3_PORT1_EN_LBN 7
-  #define TX_IPFIL3_PORT1_EN_WIDTH 1
-  #define TX_IPFIL3_PORT0_EN_LBN 6
-  #define TX_IPFIL3_PORT0_EN_WIDTH 1
-  #define TX_IPFIL2_PORT1_EN_LBN 5
-  #define TX_IPFIL2_PORT1_EN_WIDTH 1
-  #define TX_IPFIL2_PORT0_EN_LBN 4
-  #define TX_IPFIL2_PORT0_EN_WIDTH 1
-  #define TX_IPFIL1_PORT1_EN_LBN 3
-  #define TX_IPFIL1_PORT1_EN_WIDTH 1
-  #define TX_IPFIL1_PORT0_EN_LBN 2
-  #define TX_IPFIL1_PORT0_EN_WIDTH 1
-  #define TX_IPFIL0_PORT1_EN_LBN 1
-  #define TX_IPFIL0_PORT1_EN_WIDTH 1
-  #define TX_IPFIL0_PORT0_EN_LBN 0
-  #define TX_IPFIL0_PORT0_EN_WIDTH 1
-#define TX_IPFIL_TBL_OFST 0xB00 /* Transmit IP source address filter table */
-  #define TX_IPFIL_MASK_LBN 32
-  #define TX_IPFIL_MASK_WIDTH 32
-  #define TX_IP_SRC_ADR_LBN 0
-  #define TX_IP_SRC_ADR_WIDTH 32
-#define TX_PACE_REG_A1_OFST 0xF80000 /* Transmit pace control register */
-#define TX_PACE_REG_B0_OFST 0xA90    /* Transmit pace control register */
-  #define TX_PACE_SB_NOTAF_LBN 19
-  #define TX_PACE_SB_NOTAF_WIDTH 10
-  #define TX_PACE_SB_AF_LBN 9
-  #define TX_PACE_SB_AF_WIDTH 10
-  #define TX_PACE_FB_BASE_LBN 5
-  #define TX_PACE_FB_BASE_WIDTH 4
-  #define TX_PACE_BIN_TH_LBN 0
-  #define TX_PACE_BIN_TH_WIDTH 5
-#define TX_PACE_TBL_A1_OFST 0xF80040 /* Transmit pacing table */
-#define TX_PACE_TBL_FIRST_QUEUE_A1 4
-#define TX_PACE_TBL_B0_OFST 0xF80000 /* Transmit pacing table */
-#define TX_PACE_TBL_FIRST_QUEUE_B0 0
-  #define TX_PACE_LBN 0
-  #define TX_PACE_WIDTH 5
-
-/*************---- EE/Flash Registers C Header ----*************/
-#define EE_SPI_HCMD_REG_KER_OFST 0x100 /* SPI host command register */
-#define EE_SPI_HCMD_REG_OFST 0x100 /* SPI host command register */
-  #define EE_SPI_HCMD_CMD_EN_LBN 31
-  #define EE_SPI_HCMD_CMD_EN_WIDTH 1
-  #define EE_WR_TIMER_ACTIVE_LBN 28
-  #define EE_WR_TIMER_ACTIVE_WIDTH 1
-  #define EE_SPI_HCMD_SF_SEL_LBN 24
-  #define EE_SPI_HCMD_SF_SEL_WIDTH 1
-  #define EE_SPI_HCMD_DABCNT_LBN 16
-  #define EE_SPI_HCMD_DABCNT_WIDTH 5
-  #define EE_SPI_HCMD_READ_LBN 15
-  #define EE_SPI_HCMD_READ_WIDTH 1
-  #define EE_SPI_HCMD_DUBCNT_LBN 12
-  #define EE_SPI_HCMD_DUBCNT_WIDTH 2
-  #define EE_SPI_HCMD_ADBCNT_LBN 8
-  #define EE_SPI_HCMD_ADBCNT_WIDTH 2
-  #define EE_SPI_HCMD_ENC_LBN 0
-  #define EE_SPI_HCMD_ENC_WIDTH 8
-#define EE_SPI_HADR_REG_KER_OFST 0X110 /* SPI host address register */
-#define EE_SPI_HADR_REG_OFST 0X110 /* SPI host address register */
-  #define EE_SPI_HADR_DUBYTE_LBN 24
-  #define EE_SPI_HADR_DUBYTE_WIDTH 8
-  #define EE_SPI_HADR_ADR_LBN 0
-  #define EE_SPI_HADR_ADR_WIDTH 24
-#define EE_SPI_HDATA_REG_KER_OFST 0x120 /* SPI host data register */
-#define EE_SPI_HDATA_REG_OFST 0x120 /* SPI host data register */
-  #define EE_SPI_HDATA3_LBN 96
-  #define EE_SPI_HDATA3_WIDTH 32
-  #define EE_SPI_HDATA2_LBN 64
-  #define EE_SPI_HDATA2_WIDTH 32
-  #define EE_SPI_HDATA1_LBN 32
-  #define EE_SPI_HDATA1_WIDTH 32
-  #define EE_SPI_HDATA0_LBN 0
-  #define EE_SPI_HDATA0_WIDTH 32
-#define EE_BASE_PAGE_REG_KER_OFST 0x130 /* Expansion ROM base mirror register */
-#define EE_BASE_PAGE_REG_OFST 0x130 /* Expansion ROM base mirror register */
-  #define EE_EXP_ROM_WINDOW_BASE_LBN 16
-  #define EE_EXP_ROM_WINDOW_BASE_WIDTH 13
-  #define EE_EXPROM_MASK_LBN 0
-  #define EE_EXPROM_MASK_WIDTH 13
-#define EE_VPD_CFG0_REG_KER_OFST 0X140 /* SPI/VPD configuration register */
-#define EE_VPD_CFG0_REG_OFST 0X140 /* SPI/VPD configuration register */
-  #define EE_SF_FASTRD_EN_LBN 127
-  #define EE_SF_FASTRD_EN_WIDTH 1
-  #define EE_SF_CLOCK_DIV_LBN 120
-  #define EE_SF_CLOCK_DIV_WIDTH 7
-  #define EE_VPD_WIP_POLL_LBN 119
-  #define EE_VPD_WIP_POLL_WIDTH 1
-  #define EE_VPDW_LENGTH_LBN 80
-  #define EE_VPDW_LENGTH_WIDTH 15
-  #define EE_VPDW_BASE_LBN 64
-  #define EE_VPDW_BASE_WIDTH 15
-  #define EE_VPD_WR_CMD_EN_LBN 56
-  #define EE_VPD_WR_CMD_EN_WIDTH 8
-  #define EE_VPD_BASE_LBN 32
-  #define EE_VPD_BASE_WIDTH 24
-  #define EE_VPD_LENGTH_LBN 16
-  #define EE_VPD_LENGTH_WIDTH 13
-  #define EE_VPD_AD_SIZE_LBN 8
-  #define EE_VPD_AD_SIZE_WIDTH 5
-  #define EE_VPD_ACCESS_ON_LBN 5
-  #define EE_VPD_ACCESS_ON_WIDTH 1
-#define EE_VPD_SW_CNTL_REG_KER_OFST 0X150 /* VPD access SW control register */
-#define EE_VPD_SW_CNTL_REG_OFST 0X150 /* VPD access SW control register */
-  #define EE_VPD_CYCLE_PENDING_LBN 31
-  #define EE_VPD_CYCLE_PENDING_WIDTH 1
-  #define EE_VPD_CYC_WRITE_LBN 28
-  #define EE_VPD_CYC_WRITE_WIDTH 1
-  #define EE_VPD_CYC_ADR_LBN 0
-  #define EE_VPD_CYC_ADR_WIDTH 15
-#define EE_VPD_SW_DATA_REG_KER_OFST 0x160 /* VPD access SW data register */
-#define EE_VPD_SW_DATA_REG_OFST 0x160 /* VPD access SW data register */
-  #define EE_VPD_CYC_DAT_LBN 0
-  #define EE_VPD_CYC_DAT_WIDTH 32
diff -r 5b3d4d3c1166 drivers/net/sfc/sfc_resource/ci/driver/efab/hardware/falcon/falcon_desc.h
--- a/drivers/net/sfc/sfc_resource/ci/driver/efab/hardware/falcon/falcon_desc.h	Fri Nov 05 15:20:28 2010 +0000
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,75 +0,0 @@
-/****************************************************************************
- * Driver for Solarflare network controllers -
- *          resource management for Xen backend, OpenOnload, etc
- *           (including support for SFE4001 10GBT NIC)
- *
- * This file provides EtherFabric NIC - EFXXXX (aka Falcon) descriptor
- * definitions.
- *
- * Copyright 2005-2007: Solarflare Communications Inc,
- *                      9501 Jeronimo Road, Suite 250,
- *                      Irvine, CA 92618, USA
- *
- * Developed and maintained by Solarflare Communications:
- *                      <linux-xen-drivers@solarflare.com>
- *                      <onload-dev@solarflare.com>
- *
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 as published
- * by the Free Software Foundation, incorporated herein by reference.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
- ****************************************************************************
- */
-
-/*************---- Descriptors C Headers ----*************/
-/* Receive Kernel IP Descriptor */
-  #define RX_KER_BUF_SIZE_LBN 48
-  #define RX_KER_BUF_SIZE_WIDTH 14
-  #define RX_KER_BUF_REGION_LBN 46
-  #define RX_KER_BUF_REGION_WIDTH 2
-      #define RX_KER_BUF_REGION0_DECODE 0
-      #define RX_KER_BUF_REGION1_DECODE 1
-      #define RX_KER_BUF_REGION2_DECODE 2
-      #define RX_KER_BUF_REGION3_DECODE 3
-  #define RX_KER_BUF_ADR_LBN 0
-  #define RX_KER_BUF_ADR_WIDTH 46
-/* Receive User IP Descriptor */
-  #define RX_USR_2BYTE_OFS_LBN 20
-  #define RX_USR_2BYTE_OFS_WIDTH 12
-  #define RX_USR_BUF_ID_LBN 0
-  #define RX_USR_BUF_ID_WIDTH 20
-/* Transmit Kernel IP Descriptor */
-  #define TX_KER_PORT_LBN 63
-  #define TX_KER_PORT_WIDTH 1
-  #define TX_KER_CONT_LBN 62
-  #define TX_KER_CONT_WIDTH 1
-  #define TX_KER_BYTE_CNT_LBN 48
-  #define TX_KER_BYTE_CNT_WIDTH 14
-  #define TX_KER_BUF_REGION_LBN 46
-  #define TX_KER_BUF_REGION_WIDTH 2
-      #define TX_KER_BUF_REGION0_DECODE 0
-      #define TX_KER_BUF_REGION1_DECODE 1
-      #define TX_KER_BUF_REGION2_DECODE 2
-      #define TX_KER_BUF_REGION3_DECODE 3
-  #define TX_KER_BUF_ADR_LBN 0
-  #define TX_KER_BUF_ADR_WIDTH 46
-/* Transmit User IP Descriptor */
-  #define TX_USR_PORT_LBN 47
-  #define TX_USR_PORT_WIDTH 1
-  #define TX_USR_CONT_LBN 46
-  #define TX_USR_CONT_WIDTH 1
-  #define TX_USR_BYTE_CNT_LBN 33
-  #define TX_USR_BYTE_CNT_WIDTH 13
-  #define TX_USR_BUF_ID_LBN 13
-  #define TX_USR_BUF_ID_WIDTH 20
-  #define TX_USR_BYTE_OFS_LBN 0
-  #define TX_USR_BYTE_OFS_WIDTH 13
diff -r 5b3d4d3c1166 drivers/net/sfc/sfc_resource/ci/driver/efab/hardware/falcon/falcon_event.h
--- a/drivers/net/sfc/sfc_resource/ci/driver/efab/hardware/falcon/falcon_event.h	Fri Nov 05 15:20:28 2010 +0000
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,155 +0,0 @@
-/****************************************************************************
- * Driver for Solarflare network controllers -
- *          resource management for Xen backend, OpenOnload, etc
- *           (including support for SFE4001 10GBT NIC)
- *
- * This file provides EtherFabric NIC - EFXXXX (aka Falcon) event
- * definitions.
- *
- * Copyright 2005-2007: Solarflare Communications Inc,
- *                      9501 Jeronimo Road, Suite 250,
- *                      Irvine, CA 92618, USA
- *
- * Developed and maintained by Solarflare Communications:
- *                      <linux-xen-drivers@solarflare.com>
- *                      <onload-dev@solarflare.com>
- *
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 as published
- * by the Free Software Foundation, incorporated herein by reference.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
- ****************************************************************************
- */
-
-/*************---- Events Format C Header ----*************/
-/*************---- Event entry ----*************/
-  #define EV_CODE_LBN 60
-  #define EV_CODE_WIDTH 4
-      #define RX_IP_EV_DECODE 0
-      #define TX_IP_EV_DECODE 2
-      #define DRIVER_EV_DECODE 5
-      #define GLOBAL_EV_DECODE 6
-      #define DRV_GEN_EV_DECODE 7
-  #define EV_DATA_LBN 0
-  #define EV_DATA_WIDTH 60
-/******---- Receive IP events for both Kernel & User event queues ----******/
-  #define RX_EV_PKT_OK_LBN 56
-  #define RX_EV_PKT_OK_WIDTH 1
-  #define RX_EV_BUF_OWNER_ID_ERR_LBN 54
-  #define RX_EV_BUF_OWNER_ID_ERR_WIDTH 1
-  #define RX_EV_IP_HDR_CHKSUM_ERR_LBN 52
-  #define RX_EV_IP_HDR_CHKSUM_ERR_WIDTH 1
-  #define RX_EV_TCP_UDP_CHKSUM_ERR_LBN 51
-  #define RX_EV_TCP_UDP_CHKSUM_ERR_WIDTH 1
-  #define RX_EV_ETH_CRC_ERR_LBN 50
-  #define RX_EV_ETH_CRC_ERR_WIDTH 1
-  #define RX_EV_FRM_TRUNC_LBN 49
-  #define RX_EV_FRM_TRUNC_WIDTH 1
-  #define RX_EV_DRIB_NIB_LBN 48
-  #define RX_EV_DRIB_NIB_WIDTH 1
-  #define RX_EV_TOBE_DISC_LBN 47
-  #define RX_EV_TOBE_DISC_WIDTH 1
-  #define RX_EV_PKT_TYPE_LBN 44
-  #define RX_EV_PKT_TYPE_WIDTH 3
-      #define RX_EV_PKT_TYPE_ETH_DECODE 0
-      #define RX_EV_PKT_TYPE_LLC_DECODE 1
-      #define RX_EV_PKT_TYPE_JUMBO_DECODE 2
-      #define RX_EV_PKT_TYPE_VLAN_DECODE 3
-      #define RX_EV_PKT_TYPE_VLAN_LLC_DECODE 4
-      #define RX_EV_PKT_TYPE_VLAN_JUMBO_DECODE 5
-  #define RX_EV_HDR_TYPE_LBN 42
-  #define RX_EV_HDR_TYPE_WIDTH 2
-      #define RX_EV_HDR_TYPE_TCP_IPV4_DECODE 0
-      #define RX_EV_HDR_TYPE_UDP_IPV4_DECODE 1
-      #define RX_EV_HDR_TYPE_OTHER_IP_DECODE 2
-      #define RX_EV_HDR_TYPE_NON_IP_DECODE 3
-  #define RX_EV_DESC_Q_EMPTY_LBN 41
-  #define RX_EV_DESC_Q_EMPTY_WIDTH 1
-  #define RX_EV_MCAST_HASH_MATCH_LBN 40
-  #define RX_EV_MCAST_HASH_MATCH_WIDTH 1
-  #define RX_EV_MCAST_PKT_LBN 39
-  #define RX_EV_MCAST_PKT_WIDTH 1
-  #define RX_EV_Q_LABEL_LBN 32
-  #define RX_EV_Q_LABEL_WIDTH 5
-  #define RX_JUMBO_CONT_LBN 31
-  #define RX_JUMBO_CONT_WIDTH 1
-  #define RX_SOP_LBN 15
-  #define RX_SOP_WIDTH 1
-  #define RX_PORT_LBN 30
-  #define RX_PORT_WIDTH 1
-  #define RX_EV_BYTE_CNT_LBN 16
-  #define RX_EV_BYTE_CNT_WIDTH 14
-  #define RX_iSCSI_PKT_OK_LBN 14
-  #define RX_iSCSI_PKT_OK_WIDTH 1
-  #define RX_ISCSI_DDIG_ERR_LBN 13
-  #define RX_ISCSI_DDIG_ERR_WIDTH 1
-  #define RX_ISCSI_HDIG_ERR_LBN 12
-  #define RX_ISCSI_HDIG_ERR_WIDTH 1
-  #define RX_EV_DESC_PTR_LBN 0
-  #define RX_EV_DESC_PTR_WIDTH 12
-/******---- Transmit IP events for both Kernel & User event queues ----******/
-  #define TX_EV_PKT_ERR_LBN 38
-  #define TX_EV_PKT_ERR_WIDTH 1
-  #define TX_EV_PKT_TOO_BIG_LBN 37
-  #define TX_EV_PKT_TOO_BIG_WIDTH 1
-  #define TX_EV_Q_LABEL_LBN 32
-  #define TX_EV_Q_LABEL_WIDTH 5
-  #define TX_EV_PORT_LBN 16
-  #define TX_EV_PORT_WIDTH 1
-  #define TX_EV_WQ_FF_FULL_LBN 15
-  #define TX_EV_WQ_FF_FULL_WIDTH 1
-  #define TX_EV_BUF_OWNER_ID_ERR_LBN 14
-  #define TX_EV_BUF_OWNER_ID_ERR_WIDTH 1
-  #define TX_EV_COMP_LBN 12
-  #define TX_EV_COMP_WIDTH 1
-  #define TX_EV_DESC_PTR_LBN 0
-  #define TX_EV_DESC_PTR_WIDTH 12
-/*************---- Char or Kernel driver events ----*************/
-  #define DRIVER_EV_SUB_CODE_LBN 56
-  #define DRIVER_EV_SUB_CODE_WIDTH 4
-      #define TX_DESCQ_FLS_DONE_EV_DECODE 0x0
-      #define RX_DESCQ_FLS_DONE_EV_DECODE 0x1
-      #define EVQ_INIT_DONE_EV_DECODE 0x2
-      #define EVQ_NOT_EN_EV_DECODE 0x3
-      #define RX_DESCQ_FLSFF_OVFL_EV_DECODE 0x4
-      #define SRM_UPD_DONE_EV_DECODE 0x5
-      #define WAKE_UP_EV_DECODE 0x6
-      #define TX_PKT_NON_TCP_UDP_DECODE 0x9
-      #define TIMER_EV_DECODE 0xA
-      #define RX_DSC_ERROR_EV_DECODE 0xE
-  #define DRIVER_EV_TX_DESCQ_ID_LBN 0
-  #define DRIVER_EV_TX_DESCQ_ID_WIDTH 12
-  #define DRIVER_EV_RX_DESCQ_ID_LBN 0
-  #define DRIVER_EV_RX_DESCQ_ID_WIDTH 12
-  #define DRIVER_EV_EVQ_ID_LBN 0
-  #define DRIVER_EV_EVQ_ID_WIDTH 12
-  #define DRIVER_TMR_ID_LBN 0
-  #define DRIVER_TMR_ID_WIDTH 12
-  #define DRIVER_EV_SRM_UPD_LBN 0
-  #define DRIVER_EV_SRM_UPD_WIDTH 2
-      #define SRM_CLR_EV_DECODE 0
-      #define SRM_UPD_EV_DECODE 1
-      #define SRM_ILLCLR_EV_DECODE 2
-/********---- Global events. Sent to both event queue 0 and 4. ----********/
-  #define XFP_PHY_INTR_LBN 10
-  #define XFP_PHY_INTR_WIDTH 1
-  #define XG_PHY_INTR_LBN 9
-  #define XG_PHY_INTR_WIDTH 1
-  #define G_PHY1_INTR_LBN 8
-  #define G_PHY1_INTR_WIDTH 1
-  #define G_PHY0_INTR_LBN 7
-  #define G_PHY0_INTR_WIDTH 1
-/*************---- Driver generated events ----*************/
-  #define DRV_GEN_EV_CODE_LBN 60
-  #define DRV_GEN_EV_CODE_WIDTH 4
-  #define DRV_GEN_EV_DATA_LBN 0
-  #define DRV_GEN_EV_DATA_WIDTH 60
diff -r 5b3d4d3c1166 drivers/net/sfc/sfc_resource/ci/driver/efab/hardware/falcon/falcon_intr_vec.h
--- a/drivers/net/sfc/sfc_resource/ci/driver/efab/hardware/falcon/falcon_intr_vec.h	Fri Nov 05 15:20:28 2010 +0000
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,44 +0,0 @@
-/****************************************************************************
- * Driver for Solarflare network controllers -
- *          resource management for Xen backend, OpenOnload, etc
- *           (including support for SFE4001 10GBT NIC)
- *
- * This file provides EtherFabric NIC - EFXXXX (aka Falcon) interrupt
- * vector definitions.
- *
- * Copyright 2005-2007: Solarflare Communications Inc,
- *                      9501 Jeronimo Road, Suite 250,
- *                      Irvine, CA 92618, USA
- *
- * Developed and maintained by Solarflare Communications:
- *                      <linux-xen-drivers@solarflare.com>
- *                      <onload-dev@solarflare.com>
- *
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 as published
- * by the Free Software Foundation, incorporated herein by reference.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
- ****************************************************************************
- */
-
-/*************---- Interrupt Vector Format C Header ----*************/
-#define DW0_OFST 0x0 /* Double-word 0: Event queue FIFO interrupts */
-  #define EVQ_FIFO_HF_LBN 1
-  #define EVQ_FIFO_HF_WIDTH 1
-  #define EVQ_FIFO_AF_LBN 0
-  #define EVQ_FIFO_AF_WIDTH 1
-#define DW1_OFST 0x4 /* Double-word 1: Interrupt indicator */
-  #define INT_FLAG_LBN 0
-  #define INT_FLAG_WIDTH 1
-#define DW2_OFST 0x8 /* Double-word 2: Fatal interrupts */
-  #define FATAL_INT_LBN 0
-  #define FATAL_INT_WIDTH 1
diff -r 5b3d4d3c1166 drivers/net/sfc/sfc_resource/ci/driver/efab/hardware/workarounds.h
--- a/drivers/net/sfc/sfc_resource/ci/driver/efab/hardware/workarounds.h	Fri Nov 05 15:20:28 2010 +0000
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,67 +0,0 @@
-/****************************************************************************
- * Driver for Solarflare network controllers -
- *          resource management for Xen backend, OpenOnload, etc
- *           (including support for SFE4001 10GBT NIC)
- *
- * This file provides workaround settings for EtherFabric NICs.
- *
- * Copyright 2005-2007: Solarflare Communications Inc,
- *                      9501 Jeronimo Road, Suite 250,
- *                      Irvine, CA 92618, USA
- *
- * Developed and maintained by Solarflare Communications:
- *                      <linux-xen-drivers@solarflare.com>
- *                      <onload-dev@solarflare.com>
- *
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 as published
- * by the Free Software Foundation, incorporated herein by reference.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
- ****************************************************************************
- */
-
-#ifndef __CI_DRIVER_EFAB_WORKAROUNDS_H__
-#define __CI_DRIVER_EFAB_WORKAROUNDS_H__
-
-/*----------------------------------------------------------------------------
- *
- * Hardware workarounds which have global scope
- *
- *---------------------------------------------------------------------------*/
-
-#if defined(__CI_HARDWARE_CONFIG_FALCON_B0__)
-/*------------------------------- B0 ---------------------------------------*/
-
-#define BUG2175_WORKAROUND 0	/* TX event batching for dual port operation.
-				   This removes the effect (dup TX events)
-				   of the fix
-				   (TX event per packet + batch events) */
-#define BUG5302_WORKAROUND 0	/* unstick TX DMAQ after out-of-range wr ptr */
-#define BUG5762_WORKAROUND 0	/* Set all queues to jumbo mode */
-#define BUG5391_WORKAROUND 0	/* Misaligned TX can't span 512-byte boundary */
-#define BUG7916_WORKAROUND 0	/* RX flush gets lost */
-
-#else
-/*------------------------------- A0/A1 ------------------------------------*/
-
-#define BUG2175_WORKAROUND 1	/* TX event batching for dual port operation.
-				   This removes the effect (dup TX events)
-				   of the fix
-				   (TX event per packet + batch events) */
-#define BUG5302_WORKAROUND 1	/* unstick TX DMAQ after out-of-range wr ptr */
-#define BUG5762_WORKAROUND 1	/* Set all queues to jumbo mode */
-#define BUG5391_WORKAROUND 1	/* Misaligned TX can't span 512-byte boundary */
-#define BUG7916_WORKAROUND 1	/* RX flush gets lost */
-
-#endif /* B0/A01 */
-
-#endif /* __CI_DRIVER_EFAB_WORKAROUNDS_H__ */
diff -r 5b3d4d3c1166 drivers/net/sfc/sfc_resource/ci/driver/resource/efx_vi.h
--- a/drivers/net/sfc/sfc_resource/ci/driver/resource/efx_vi.h	Fri Nov 05 15:20:28 2010 +0000
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,273 +0,0 @@
-/****************************************************************************
- * Driver for Solarflare network controllers -
- *          resource management for Xen backend, OpenOnload, etc
- *           (including support for SFE4001 10GBT NIC)
- *
- * This file contains public EFX VI API to Solarflare resource manager.
- *
- * Copyright 2005-2007: Solarflare Communications Inc,
- *                      9501 Jeronimo Road, Suite 250,
- *                      Irvine, CA 92618, USA
- *
- * Developed and maintained by Solarflare Communications:
- *                      <linux-xen-drivers@solarflare.com>
- *                      <onload-dev@solarflare.com>
- *
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 as published
- * by the Free Software Foundation, incorporated herein by reference.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
- ****************************************************************************
- */
-
-#ifndef __CI_DRIVER_RESOURCE_EFX_VI_H__
-#define __CI_DRIVER_RESOURCE_EFX_VI_H__
-
-/* Default size of event queue in the efx_vi resource.  Copied from
- * CI_CFG_NETIF_EVENTQ_SIZE */
-#define EFX_VI_EVENTQ_SIZE_DEFAULT 1024
-
-extern int efx_vi_eventq_size;
-
-/**************************************************************************
- * efx_vi_state types, allocation and free
- **************************************************************************/
-
-/*! Handle for refering to a efx_vi */
-struct efx_vi_state;
-
-/*!
- * Allocate an efx_vi, including event queue and pt_endpoint
- *
- * \param vih_out Pointer to a handle that is set on success
- * \param ifindex Index of the network interface desired
- * \return Zero on success (and vih_out set), non-zero on failure.
- */
-extern int
-efx_vi_alloc(struct efx_vi_state **vih_out, int ifindex);
-
-/*!
- * Free a previously allocated efx_vi
- *
- * \param vih The handle of the efx_vi to free
- */
-extern void
-efx_vi_free(struct efx_vi_state *vih);
-
-/*!
- * Reset a previously allocated efx_vi
- *
- * \param vih The handle of the efx_vi to reset
- */
-extern void
-efx_vi_reset(struct efx_vi_state *vih);
-
-/**************************************************************************
- * efx_vi_eventq types and functions
- **************************************************************************/
-
-/*!
- * Register a function to receive callbacks when event queue timeouts
- * or wakeups occur.  Only one function per efx_vi can be registered
- * at once.
- *
- * \param vih The handle to identify the efx_vi
- * \param callback The function to callback
- * \param context An argument to pass to the callback function
- * \return Zero on success, non-zero on failure.
- */
-extern int
-efx_vi_eventq_register_callback(struct efx_vi_state *vih,
-				void (*callback)(void *context, int is_timeout),
-				void *context);
-
-/*!
- * Remove the current eventq timeout or wakeup callback function
- *
- * \param vih The handle to identify the efx_vi
- * \return Zero on success, non-zero on failure
- */
-extern int
-efx_vi_eventq_kill_callback(struct efx_vi_state *vih);
-
-/**************************************************************************
- * efx_vi_dma_map types and functions
- **************************************************************************/
-
-/*!
- * Handle for refering to a efx_vi
- */
-struct efx_vi_dma_map_state;
-
-/*!
- * Map a list of buffer pages so they are registered with the hardware
- *
- * \param vih The handle to identify the efx_vi
- * \param addrs An array of page pointers to map
- * \param n_addrs Length of the page pointer array.  Must be a power of two.
- * \param dmh_out Set on success to a handle used to refer to this mapping
- * \return Zero on success, non-zero on failure.
- */
-extern int
-efx_vi_dma_map_pages(struct efx_vi_state *vih, struct page **pages,
-			 int n_pages, struct efx_vi_dma_map_state **dmh_out);
-extern int
-efx_vi_dma_map_addrs(struct efx_vi_state *vih,
-		     unsigned long long *dev_bus_addrs, int n_pages,
-		     struct efx_vi_dma_map_state **dmh_out);
-
-/*!
- * Unmap a previously mapped set of pages so they are no longer registered
- * with the hardware.
- *
- * \param vih The handle to identify the efx_vi
- * \param dmh The handle to identify the dma mapping
- */
-extern void
-efx_vi_dma_unmap_pages(struct efx_vi_state *vih,
-		       struct efx_vi_dma_map_state *dmh);
-extern void
-efx_vi_dma_unmap_addrs(struct efx_vi_state *vih,
-		       struct efx_vi_dma_map_state *dmh);
-
-/*!
- * Retrieve the buffer address of the mapping
- *
- * \param vih The handle to identify the efx_vi
- * \param dmh The handle to identify the buffer mapping
- * \return The buffer address on success, or zero on failure
- */
-extern unsigned
-efx_vi_dma_get_map_addr(struct efx_vi_state *vih,
-			struct efx_vi_dma_map_state *dmh);
-
-/**************************************************************************
- * efx_vi filter functions
- **************************************************************************/
-
-#define EFX_VI_STATIC_FILTERS 32
-
-/*! Handle to refer to a filter instance */
-struct filter_resource_t;
-
-/*!
- * Allocate and add a filter
- *
- * \param vih The handle to identify the efx_vi
- * \param protocol The protocol of the new filter: UDP or TCP
- * \param ip_addr_be32 The local ip address of the filter
- * \param port_le16 The local port of the filter
- * \param fh_out Set on success to be a handle to refer to this filter
- * \return Zero on success, non-zero on failure.
- */
-extern int
-efx_vi_filter(struct efx_vi_state *vih, int protocol, unsigned ip_addr_be32,
-	      int port_le16, struct filter_resource_t **fh_out);
-
-/*!
- * Remove a filter and free resources associated with it
- *
- * \param vih The handle to identify the efx_vi
- * \param fh The handle to identify the filter
- * \return Zero on success, non-zero on failure
- */
-extern int
-efx_vi_filter_stop(struct efx_vi_state *vih, struct filter_resource_t *fh);
-
-/**************************************************************************
- * efx_vi hw resources types and functions
- **************************************************************************/
-
-/*! Constants for the type field in efx_vi_hw_resource */
-#define EFX_VI_HW_RESOURCE_TXDMAQ    0x0	/* PFN of TX DMA Q */
-#define EFX_VI_HW_RESOURCE_RXDMAQ    0x1	/* PFN of RX DMA Q */
-#define EFX_VI_HW_RESOURCE_EVQTIMER  0x4	/* Address of event q timer */
-
-/* Address of event q pointer (EF1) */
-#define EFX_VI_HW_RESOURCE_EVQPTR    0x5
-/* Address of register pointer (Falcon A) */
-#define EFX_VI_HW_RESOURCE_EVQRPTR   0x6
-/* Offset of register pointer (Falcon B) */
-#define EFX_VI_HW_RESOURCE_EVQRPTR_OFFSET 0x7
-/* Address of mem KVA */
-#define EFX_VI_HW_RESOURCE_EVQMEMKVA 0x8
-/* PFN of doorbell page (Falcon) */
-#define EFX_VI_HW_RESOURCE_BELLPAGE  0x9
-
-/*! How large an array to allocate for the get_() functions - smaller
-  than the total number of constants as some are mutually exclusive */
-#define EFX_VI_HW_RESOURCE_MAXSIZE   0x7
-
-/*! Constants for the mem_type field in efx_vi_hw_resource */
-#define EFX_VI_HW_RESOURCE_IOBUFFER   0	/* Host memory */
-#define EFX_VI_HW_RESOURCE_PERIPHERAL 1	/* Card memory/registers */
-
-/*!
- * Data structure providing information on a hardware resource mapping
- */
-struct efx_vi_hw_resource {
-	u8 type;		/*!< What this resource represents */
-	u8 mem_type;		/*!< What type of memory is it in, eg,
-				 * host or iomem */
-	u8 more_to_follow;	/*!< Is this part of a multi-region resource */
-	u32 length;		/*!< Length of the resource in bytes */
-	unsigned long address;	/*!< Address of this resource */
-};
-
-/*!
- * Metadata concerning the list of hardware resource mappings
- */
-struct efx_vi_hw_resource_metadata {
-	int evq_order;
-	int evq_offs;
-	int evq_capacity;
-	int instance;
-	unsigned rx_capacity;
-	unsigned tx_capacity;
-	int nic_arch;
-	int nic_revision;
-	char nic_variant;
-};
-
-/*!
- * Obtain a list of hardware resource mappings, using virtual addresses
- *
- * \param vih The handle to identify the efx_vi
- * \param mdata Pointer to a structure to receive the metadata
- * \param hw_res_array An array to receive the list of hardware resources
- * \param length The length of hw_res_array.  Updated on success to contain
- * the number of entries in the supplied array that were used.
- * \return Zero on success, non-zero on failure
- */
-extern int
-efx_vi_hw_resource_get_virt(struct efx_vi_state *vih,
-			    struct efx_vi_hw_resource_metadata *mdata,
-			    struct efx_vi_hw_resource *hw_res_array,
-			    int *length);
-
-/*!
- * Obtain a list of hardware resource mappings, using physical addresses
- *
- * \param vih The handle to identify the efx_vi
- * \param mdata Pointer to a structure to receive the metadata
- * \param hw_res_array An array to receive the list of hardware resources
- * \param length The length of hw_res_array.  Updated on success to contain
- * the number of entries in the supplied array that were used.
- * \return Zero on success, non-zero on failure
- */
-extern int
-efx_vi_hw_resource_get_phys(struct efx_vi_state *vih,
-			    struct efx_vi_hw_resource_metadata *mdata,
-			    struct efx_vi_hw_resource *hw_res_array,
-			    int *length);
-
-#endif /* __CI_DRIVER_RESOURCE_EFX_VI_H__ */
diff -r 5b3d4d3c1166 drivers/net/sfc/sfc_resource/ci/driver/resource/linux_efhw_nic.h
--- a/drivers/net/sfc/sfc_resource/ci/driver/resource/linux_efhw_nic.h	Fri Nov 05 15:20:28 2010 +0000
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,69 +0,0 @@
-/****************************************************************************
- * Driver for Solarflare network controllers -
- *          resource management for Xen backend, OpenOnload, etc
- *           (including support for SFE4001 10GBT NIC)
- *
- * This file contains definition of the public type struct linux_efhw_nic.
- *
- * Copyright 2005-2007: Solarflare Communications Inc,
- *                      9501 Jeronimo Road, Suite 250,
- *                      Irvine, CA 92618, USA
- *
- * Developed and maintained by Solarflare Communications:
- *                      <linux-xen-drivers@solarflare.com>
- *                      <onload-dev@solarflare.com>
- *
- * Certain parts of the driver were implemented by
- *          Alexandra Kossovsky <Alexandra.Kossovsky@oktetlabs.ru>
- *          OKTET Labs Ltd, Russia,
- *          http://oktetlabs.ru, <info@oktetlabs.ru>
- *          by request of Solarflare Communications
- *
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 as published
- * by the Free Software Foundation, incorporated herein by reference.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
- ****************************************************************************
- */
-
-#ifndef __CI_DRIVER_RESOURCE_LINUX_RESOURCE__
-#define __CI_DRIVER_RESOURCE_LINUX_RESOURCE__
-
-#include <ci/efrm/efrm_nic.h>
-#include <linux/interrupt.h>
-
-
-/************************************************************************
- * Per-nic structure in the resource driver                             *
- ************************************************************************/
-
-struct linux_efhw_nic {
-	struct efrm_nic efrm_nic;
-
-	struct pci_dev *pci_dev;	/*!< pci descriptor */
-	struct tasklet_struct tasklet;	/*!< for interrupt bottom half */
-
-	/* Physical addresses of the control aperture bar. */
-	unsigned long ctr_ap_pci_addr;
-
-	/*! Callbacks for driverlink, when needed. */
-	struct efx_dl_callbacks *dl_callbacks;
-
-	/*! Event handlers. */
-	struct efhw_ev_handler *ev_handlers;
-
-};
-
-#define linux_efhw_nic(_efhw_nic)					\
-  container_of(_efhw_nic, struct linux_efhw_nic, efrm_nic.efhw_nic)
-
-#endif /* __CI_DRIVER_RESOURCE_LINUX_RESOURCE__ */
diff -r 5b3d4d3c1166 drivers/net/sfc/sfc_resource/ci/efhw/checks.h
--- a/drivers/net/sfc/sfc_resource/ci/efhw/checks.h	Fri Nov 05 15:20:28 2010 +0000
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,118 +0,0 @@
-/****************************************************************************
- * Driver for Solarflare network controllers -
- *          resource management for Xen backend, OpenOnload, etc
- *           (including support for SFE4001 10GBT NIC)
- *
- * This file provides helpers to turn bit shifts into dword shifts and
- * check that the bit fields haven't overflown the dword etc.
- *
- * Copyright 2005-2007: Solarflare Communications Inc,
- *                      9501 Jeronimo Road, Suite 250,
- *                      Irvine, CA 92618, USA
- *
- * Developed and maintained by Solarflare Communications:
- *                      <linux-xen-drivers@solarflare.com>
- *                      <onload-dev@solarflare.com>
- *
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 as published
- * by the Free Software Foundation, incorporated herein by reference.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
- ****************************************************************************
- */
-
-#ifndef __CI_EFHW_CHECK_H__
-#define __CI_EFHW_CHECK_H__
-
-/*----------------------------------------------------------------------------
- *
- * Helpers to turn bit shifts into dword shifts and check that the bit fields
- * haven't overflown the dword etc. Aim is to preserve consistency with the
- * autogenerated headers - once stable we could hard code.
- *
- *---------------------------------------------------------------------------*/
-
-/* mask constructors */
-#define __FALCON_MASK(WIDTH, T)	((((T)1) << (WIDTH)) - 1)
-#define __FALCON_MASK32(WIDTH)	__FALCON_MASK((WIDTH), uint32_t)
-#define __FALCON_MASK64(WIDTH)	__FALCON_MASK((WIDTH), uint64_t)
-
-#define __FALCON_MASKFIELD32(LBN, WIDTH) \
-	((uint32_t)(__FALCON_MASK32(WIDTH) << (LBN)))
-
-/* constructors for fields which span the first and second dwords */
-#define __LW(LBN)		(32 - LBN)
-#define __LOW(v, LBN, WIDTH) \
-	((uint32_t)(((v) & __FALCON_MASK64(__LW((LBN)))) << (LBN)))
-#define __HIGH(v, LBN, WIDTH) \
-	((uint32_t)(((v) >> __LW((LBN))) & \
-		    __FALCON_MASK64((WIDTH - __LW((LBN))))))
-/* constructors for fields within the second dword */
-#define __DW2(LBN)		((LBN) - 32)
-
-/* constructors for fields which span the second and third dwords */
-#define __LW2(LBN)		(64 - LBN)
-#define __LOW2(v, LBN, WIDTH) \
-	((uint32_t)(((v) & __FALCON_MASK64(__LW2((LBN)))) << ((LBN) - 32)))
-#define __HIGH2(v, LBN, WIDTH) \
-	((uint32_t)(((v) >> __LW2((LBN))) & \
-		    __FALCON_MASK64((WIDTH - __LW2((LBN))))))
-
-/* constructors for fields within the third dword */
-#define __DW3(LBN)		((LBN) - 64)
-
-/* constructors for fields which span the third and fourth dwords */
-#define __LW3(LBN)		(96 - LBN)
-#define __LOW3(v, LBN, WIDTH) \
-	((uint32_t)(((v) & __FALCON_MASK64(__LW3((LBN)))) << ((LBN) - 64)))
-#define __HIGH3(v, LBN, WIDTH) \
-	((ci_unit32)(((v) >> __LW3((LBN))) & \
-		     __FALCON_MASK64((WIDTH - __LW3((LBN))))))
-
-/* constructors for fields within the fourth dword */
-#define __DW4(LBN)		((LBN) - 96)
-
-/* checks that the autogenerated headers are consistent with our model */
-#define __WIDTHCHCK(a, b)	EFHW_ASSERT((a) == (b))
-#define __RANGECHCK(v, WIDTH) \
-	EFHW_ASSERT(((uint64_t)(v) & ~(__FALCON_MASK64((WIDTH)))) == 0)
-
-/* fields within the first dword */
-#define __DWCHCK(LBN, WIDTH) \
-	EFHW_ASSERT(((LBN) >= 0) && (((LBN)+(WIDTH)) <= 32))
-
-/* fields which span the first and second dwords */
-#define __LWCHK(LBN, WIDTH)	EFHW_ASSERT(WIDTH >= __LW(LBN))
-
-/* fields within the second dword */
-#define __DW2CHCK(LBN, WIDTH) \
-	EFHW_ASSERT(((LBN) >= 32) && (((LBN)+(WIDTH)) <= 64))
-
-/* fields which span the second and third dwords */
-#define __LW2CHK(LBN, WIDTH)	EFHW_ASSERT(WIDTH >= __LW2(LBN))
-
-/* fields within the third dword */
-#define __DW3CHCK(LBN, WIDTH) \
-	EFHW_ASSERT(((LBN) >= 64) && (((LBN)+(WIDTH)) <= 96))
-
-/* fields which span the third and fourth dwords */
-#define __LW3CHK(LBN, WIDTH)	EFHW_ASSERT(WIDTH >= __LW3(LBN))
-
-/* fields within the fourth dword */
-#define __DW4CHCK(LBN, WIDTH) \
-	EFHW_ASSERT(((LBN) >= 96) && (((LBN)+(WIDTH)) <= 128))
-
-/* fields in the first qword */
-#define __QWCHCK(LBN, WIDTH) \
-	EFHW_ASSERT(((LBN) >= 0) && (((LBN)+(WIDTH)) <= 64))
-
-#endif /* __CI_EFHW_CHECK_H__ */
diff -r 5b3d4d3c1166 drivers/net/sfc/sfc_resource/ci/efhw/common.h
--- a/drivers/net/sfc/sfc_resource/ci/efhw/common.h	Fri Nov 05 15:20:28 2010 +0000
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,97 +0,0 @@
-/****************************************************************************
- * Driver for Solarflare network controllers -
- *          resource management for Xen backend, OpenOnload, etc
- *           (including support for SFE4001 10GBT NIC)
- *
- * This file provides API of the efhw library which may be used both from
- * the kernel and from the user-space code.
- *
- * Copyright 2005-2007: Solarflare Communications Inc,
- *                      9501 Jeronimo Road, Suite 250,
- *                      Irvine, CA 92618, USA
- *
- * Developed and maintained by Solarflare Communications:
- *                      <linux-xen-drivers@solarflare.com>
- *                      <onload-dev@solarflare.com>
- *
- * Certain parts of the driver were implemented by
- *          Alexandra Kossovsky <Alexandra.Kossovsky@oktetlabs.ru>
- *          OKTET Labs Ltd, Russia,
- *          http://oktetlabs.ru, <info@oktetlabs.ru>
- *          by request of Solarflare Communications
- *
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 as published
- * by the Free Software Foundation, incorporated herein by reference.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
- ****************************************************************************
- */
-
-#ifndef __CI_EFHW_COMMON_H__
-#define __CI_EFHW_COMMON_H__
-
-#include <ci/efhw/common_sysdep.h>
-
-enum efhw_arch {
-	EFHW_ARCH_FALCON,
-};
-
-typedef uint32_t efhw_buffer_addr_t;
-#define EFHW_BUFFER_ADDR_FMT	"[ba:%"PRIx32"]"
-
-/*! Comment? */
-typedef union {
-	uint64_t u64;
-	struct {
-		uint32_t a;
-		uint32_t b;
-	} opaque;
-} efhw_event_t;
-
-/* Flags for TX/RX queues */
-#define EFHW_VI_JUMBO_EN           0x01    /*! scatter RX over multiple desc */
-#define EFHW_VI_ISCSI_RX_HDIG_EN   0x02    /*! iscsi rx header digest */
-#define EFHW_VI_ISCSI_TX_HDIG_EN   0x04    /*! iscsi tx header digest */
-#define EFHW_VI_ISCSI_RX_DDIG_EN   0x08    /*! iscsi rx data digest */
-#define EFHW_VI_ISCSI_TX_DDIG_EN   0x10    /*! iscsi tx data digest */
-#define EFHW_VI_TX_PHYS_ADDR_EN    0x20    /*! TX physical address mode */
-#define EFHW_VI_RX_PHYS_ADDR_EN    0x40    /*! RX physical address mode */
-#define EFHW_VI_RM_WITH_INTERRUPT  0x80    /*! VI with an interrupt */
-#define EFHW_VI_TX_IP_CSUM_DIS     0x100   /*! enable ip checksum generation */
-#define EFHW_VI_TX_TCPUDP_CSUM_DIS 0x200   /*! enable tcp/udp checksum
-					       generation */
-#define EFHW_VI_TX_TCPUDP_ONLY     0x400   /*! drop non-tcp/udp packets */
-
-/* Types of hardware filter */
-/* Each of these values implicitly selects scatter filters on B0 - or in
-   EFHW_IP_FILTER_TYPE_NOSCAT_B0_MASK if a non-scatter filter is required */
-#define EFHW_IP_FILTER_TYPE_UDP_WILDCARD  (0)	/* dest host only */
-#define EFHW_IP_FILTER_TYPE_UDP_FULL      (1)	/* dest host and port */
-#define EFHW_IP_FILTER_TYPE_TCP_WILDCARD  (2)	/* dest based filter */
-#define EFHW_IP_FILTER_TYPE_TCP_FULL      (3)	/* src  filter */
-/* Same again, but with RSS (for B0 only) */
-#define EFHW_IP_FILTER_TYPE_UDP_WILDCARD_RSS_B0  (4)
-#define EFHW_IP_FILTER_TYPE_UDP_FULL_RSS_B0      (5)
-#define EFHW_IP_FILTER_TYPE_TCP_WILDCARD_RSS_B0  (6)
-#define EFHW_IP_FILTER_TYPE_TCP_FULL_RSS_B0      (7)
-
-#define EFHW_IP_FILTER_TYPE_FULL_MASK      (0x1) /* Mask for full / wildcard */
-#define EFHW_IP_FILTER_TYPE_TCP_MASK       (0x2) /* Mask for TCP type */
-#define EFHW_IP_FILTER_TYPE_RSS_B0_MASK    (0x4) /* Mask for B0 RSS enable */
-#define EFHW_IP_FILTER_TYPE_NOSCAT_B0_MASK (0x8) /* Mask for B0 SCATTER dsbl */
-
-#define EFHW_IP_FILTER_TYPE_MASK	(0xffff) /* Mask of types above */
-
-#define EFHW_IP_FILTER_BROADCAST	(0x10000) /* driverlink filter
-						     support */
-
-#endif /* __CI_EFHW_COMMON_H__ */
diff -r 5b3d4d3c1166 drivers/net/sfc/sfc_resource/ci/efhw/common_sysdep.h
--- a/drivers/net/sfc/sfc_resource/ci/efhw/common_sysdep.h	Fri Nov 05 15:20:28 2010 +0000
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,61 +0,0 @@
-/****************************************************************************
- * Driver for Solarflare network controllers -
- *          resource management for Xen backend, OpenOnload, etc
- *           (including support for SFE4001 10GBT NIC)
- *
- * This file provides version-independent Linux kernel API for
- * userland-to-kernel interfaces.
- * Only kernels >=2.6.9 are supported.
- *
- * Copyright 2005-2007: Solarflare Communications Inc,
- *                      9501 Jeronimo Road, Suite 250,
- *                      Irvine, CA 92618, USA
- *
- * Developed and maintained by Solarflare Communications:
- *                      <linux-xen-drivers@solarflare.com>
- *                      <onload-dev@solarflare.com>
- *
- * Certain parts of the driver were implemented by
- *          Alexandra Kossovsky <Alexandra.Kossovsky@oktetlabs.ru>
- *          OKTET Labs Ltd, Russia,
- *          http://oktetlabs.ru, <info@oktetlabs.ru>
- *          by request of Solarflare Communications
- *
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 as published
- * by the Free Software Foundation, incorporated herein by reference.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
- ****************************************************************************
- */
-
-#ifndef __CI_EFHW_COMMON_LINUX_H__
-#define __CI_EFHW_COMMON_LINUX_H__
-
-#include <linux/types.h>
-
-/* Dirty hack, but Linux kernel does not provide DMA_ADDR_T_FMT */
-#if BITS_PER_LONG == 64 || defined(CONFIG_HIGHMEM64G)
-#define DMA_ADDR_T_FMT "%llx"
-#else
-#define DMA_ADDR_T_FMT "%x"
-#endif
-
-/* Linux kernel also does not provide PRIx32... Sigh. */
-#define PRIx32 "x"
-
-#ifdef __ia64__
-# define PRIx64 "lx"
-#else
-# define PRIx64 "llx"
-#endif
-
-#endif /* __CI_EFHW_COMMON_LINUX_H__ */
diff -r 5b3d4d3c1166 drivers/net/sfc/sfc_resource/ci/efhw/debug.h
--- a/drivers/net/sfc/sfc_resource/ci/efhw/debug.h	Fri Nov 05 15:20:28 2010 +0000
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,84 +0,0 @@
-/****************************************************************************
- * Driver for Solarflare network controllers -
- *          resource management for Xen backend, OpenOnload, etc
- *           (including support for SFE4001 10GBT NIC)
- *
- * This file provides debug-related API for efhw library using Linux kernel
- * primitives.
- *
- * Copyright 2005-2007: Solarflare Communications Inc,
- *                      9501 Jeronimo Road, Suite 250,
- *                      Irvine, CA 92618, USA
- *
- * Developed and maintained by Solarflare Communications:
- *                      <linux-xen-drivers@solarflare.com>
- *                      <onload-dev@solarflare.com>
- *
- * Certain parts of the driver were implemented by
- *          Alexandra Kossovsky <Alexandra.Kossovsky@oktetlabs.ru>
- *          OKTET Labs Ltd, Russia,
- *          http://oktetlabs.ru, <info@oktetlabs.ru>
- *          by request of Solarflare Communications
- *
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 as published
- * by the Free Software Foundation, incorporated herein by reference.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
- ****************************************************************************
- */
-
-#ifndef __CI_EFHW_DEBUG_LINUX_H__
-#define __CI_EFHW_DEBUG_LINUX_H__
-
-#define EFHW_PRINTK_PREFIX "[sfc efhw] "
-
-#define EFHW_PRINTK(level, fmt, ...) \
-	printk(level EFHW_PRINTK_PREFIX fmt "\n", __VA_ARGS__)
-
-/* Following macros should be used with non-zero format parameters
- * due to __VA_ARGS__ limitations.  Use "%s" with __func__ if you can't
- * find better parameters. */
-#define EFHW_ERR(fmt, ...)     EFHW_PRINTK(KERN_ERR, fmt, __VA_ARGS__)
-#define EFHW_WARN(fmt, ...)    EFHW_PRINTK(KERN_WARNING, fmt, __VA_ARGS__)
-#define EFHW_NOTICE(fmt, ...)  EFHW_PRINTK(KERN_NOTICE, fmt, __VA_ARGS__)
-#if 0 && !defined(NDEBUG)
-#define EFHW_TRACE(fmt, ...) EFHW_PRINTK(KERN_DEBUG, fmt, __VA_ARGS__)
-#else
-#define EFHW_TRACE(fmt, ...)
-#endif
-
-#ifndef NDEBUG
-#define EFHW_ASSERT(cond)  BUG_ON((cond) == 0)
-#define EFHW_DO_DEBUG(expr) expr
-#else
-#define EFHW_ASSERT(cond)
-#define EFHW_DO_DEBUG(expr)
-#endif
-
-#define EFHW_TEST(expr)			\
-	do {				\
-		if (unlikely(!(expr)))	\
-		BUG();			\
-	} while (0)
-
-/* Build time asserts. We paste the line number into the type name
- * so that the macro can be used more than once per file even if the
- * compiler objects to multiple identical typedefs. Collisions
- * between use in different header files is still possible. */
-#ifndef EFHW_BUILD_ASSERT
-#define __EFHW_BUILD_ASSERT_NAME(_x) __EFHW_BUILD_ASSERT_ILOATHECPP(_x)
-#define __EFHW_BUILD_ASSERT_ILOATHECPP(_x)  __EFHW_BUILD_ASSERT__ ##_x
-#define EFHW_BUILD_ASSERT(e) \
-	typedef char __EFHW_BUILD_ASSERT_NAME(__LINE__)[(e) ? 1 : -1]
-#endif
-
-#endif /* __CI_EFHW_DEBUG_LINUX_H__ */
diff -r 5b3d4d3c1166 drivers/net/sfc/sfc_resource/ci/efhw/efhw_config.h
--- a/drivers/net/sfc/sfc_resource/ci/efhw/efhw_config.h	Fri Nov 05 15:20:28 2010 +0000
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,43 +0,0 @@
-/****************************************************************************
- * Driver for Solarflare network controllers -
- *          resource management for Xen backend, OpenOnload, etc
- *           (including support for SFE4001 10GBT NIC)
- *
- * This file provides some limits used in both kernel and userland code.
- *
- * Copyright 2005-2007: Solarflare Communications Inc,
- *                      9501 Jeronimo Road, Suite 250,
- *                      Irvine, CA 92618, USA
- *
- * Developed and maintained by Solarflare Communications:
- *                      <linux-xen-drivers@solarflare.com>
- *                      <onload-dev@solarflare.com>
- *
- * Certain parts of the driver were implemented by
- *          Alexandra Kossovsky <Alexandra.Kossovsky@oktetlabs.ru>
- *          OKTET Labs Ltd, Russia,
- *          http://oktetlabs.ru, <info@oktetlabs.ru>
- *          by request of Solarflare Communications
- *
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 as published
- * by the Free Software Foundation, incorporated herein by reference.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
- ****************************************************************************
- */
-
-#ifndef __CI_EFHW_EFAB_CONFIG_H__
-#define __CI_EFHW_EFAB_CONFIG_H__
-
-#define EFHW_MAX_NR_DEVS 5	/* max number of efhw devices supported */
-
-#endif /* __CI_EFHW_EFAB_CONFIG_H__ */
diff -r 5b3d4d3c1166 drivers/net/sfc/sfc_resource/ci/efhw/efhw_types.h
--- a/drivers/net/sfc/sfc_resource/ci/efhw/efhw_types.h	Fri Nov 05 15:20:28 2010 +0000
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,382 +0,0 @@
-/****************************************************************************
- * Driver for Solarflare network controllers -
- *          resource management for Xen backend, OpenOnload, etc
- *           (including support for SFE4001 10GBT NIC)
- *
- * This file provides struct efhw_nic and some related types.
- *
- * Copyright 2005-2007: Solarflare Communications Inc,
- *                      9501 Jeronimo Road, Suite 250,
- *                      Irvine, CA 92618, USA
- *
- * Developed and maintained by Solarflare Communications:
- *                      <linux-xen-drivers@solarflare.com>
- *                      <onload-dev@solarflare.com>
- *
- * Certain parts of the driver were implemented by
- *          Alexandra Kossovsky <Alexandra.Kossovsky@oktetlabs.ru>
- *          OKTET Labs Ltd, Russia,
- *          http://oktetlabs.ru, <info@oktetlabs.ru>
- *          by request of Solarflare Communications
- *
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 as published
- * by the Free Software Foundation, incorporated herein by reference.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
- ****************************************************************************
- */
-
-#ifndef __CI_EFHW_EFAB_TYPES_H__
-#define __CI_EFHW_EFAB_TYPES_H__
-
-#include <ci/efhw/efhw_config.h>
-#include <ci/efhw/hardware_sysdep.h>
-#include <ci/efhw/iopage_types.h>
-#include <ci/efhw/sysdep.h>
-
-/*--------------------------------------------------------------------
- *
- * forward type declarations
- *
- *--------------------------------------------------------------------*/
-
-struct efhw_nic;
-
-/*--------------------------------------------------------------------
- *
- * Managed interface
- *
- *--------------------------------------------------------------------*/
-
-struct efhw_buffer_table_allocation{
-	unsigned base;
-	unsigned order;
-};
-
-struct eventq_resource_hardware {
-	/*!iobuffer allocated for eventq - can be larger than eventq */
-	struct efhw_iopages iobuff;
-	unsigned iobuff_off;
-	struct efhw_buffer_table_allocation buf_tbl_alloc;
-	int capacity;		/*!< capacity of event queue */
-};
-
-/*--------------------------------------------------------------------
- *
- * event queues and event driven callbacks
- *
- *--------------------------------------------------------------------*/
-
-struct efhw_keventq {
-	int lock;
-	caddr_t evq_base;
-	int32_t evq_ptr;
-	uint32_t evq_mask;
-	unsigned instance;
-	struct eventq_resource_hardware hw;
-	struct efhw_ev_handler *ev_handlers;
-};
-
-/*--------------------------------------------------------------------
- *
- * filters
- *
- *--------------------------------------------------------------------*/
-
-struct efhw_filter_spec {
-	uint dmaq_id;
-	uint32_t saddr_le32;
-	uint32_t daddr_le32;
-	uint16_t sport_le16;
-	uint16_t dport_le16;
-	unsigned tcp     : 1;
-	unsigned full    : 1;
-	unsigned rss     : 1;  /* not supported on A1 */
-	unsigned scatter : 1;  /* not supported on A1 */
-};
-
-struct efhw_filter_depth {
-	unsigned needed;
-	unsigned max;
-};
-
-struct efhw_filter_search_limits {
-	unsigned tcp_full;
-	unsigned tcp_wild;
-	unsigned udp_full;
-	unsigned udp_wild;
-};
-
-
-/**********************************************************************
- * Portable HW interface. ***************************************
- **********************************************************************/
-
-/*--------------------------------------------------------------------
- *
- * EtherFabric Functional units - configuration and control
- *
- *--------------------------------------------------------------------*/
-
-struct efhw_func_ops {
-
-  /*-------------- Initialisation ------------ */
-
-	/*! close down all hardware functional units - leaves NIC in a safe
-	   state for driver unload */
-	void (*close_hardware) (struct efhw_nic *nic);
-
-	/*! initialise all hardware functional units */
-	int (*init_hardware) (struct efhw_nic *nic,
-			      struct efhw_ev_handler *,
-			      const uint8_t *mac_addr, int non_irq_evq);
-
-  /*-------------- Interrupt support  ------------ */
-
-	/*! Main interrupt routine
-	 **        This function returns,
-	 **  - zero,       if the IRQ was not generated by EF1
-	 **  - non-zero,   if EF1 was the source of the IRQ
-	 **
-	 **
-	 ** opaque is an OS provided pointer for use by the OS callbacks
-	 ** e.g in Windows used to indicate DPC scheduled
-	 */
-	int (*interrupt) (struct efhw_nic *nic);
-
-	/*! Enable the interrupt */
-	void (*interrupt_enable) (struct efhw_nic *nic);
-
-	/*! Disable the interrupt */
-	void (*interrupt_disable) (struct efhw_nic *nic);
-
-	/*! Set interrupt moderation strategy for the given IRQ unit
-	 ** val is in usec
-	 */
-	void (*set_interrupt_moderation)(struct efhw_nic *nic, int evq,
-					 uint val);
-
-  /*-------------- Event support  ------------ */
-
-	/*! Enable the given event queue
-	   depending on the underlying implementation (EF1 or Falcon) then
-	   either a q_base_addr in host memory, or a buffer base id should
-	   be proivded
-	 */
-	void (*event_queue_enable) (struct efhw_nic *nic,
-				    uint evq,	/* evnt queue index */
-				    uint evq_size,	/* units of #entries */
-				    dma_addr_t q_base_addr, uint buf_base_id,
-				    int interrupting);
-
-	/*! Disable the given event queue (and any associated timer) */
-	void (*event_queue_disable) (struct efhw_nic *nic, uint evq,
-				     int timer_only);
-
-	/*! request wakeup from the NIC on a given event Q */
-	void (*wakeup_request) (struct efhw_nic *nic, dma_addr_t q_base_addr,
-				int next_i, int evq);
-
-	/*! Push a SW event on a given eventQ */
-	void (*sw_event) (struct efhw_nic *nic, int data, int evq);
-
-  /*-------------- IP Filter API  ------------ */
-
-	/*! Setup a given filter - The software can request a filter_i,
-	 * but some EtherFabric implementations will override with
-	 * a more suitable index
-	 */
-	int (*ipfilter_set) (struct efhw_nic *nic, int type,
-			     int *filter_i, int dmaq,
-			     unsigned saddr_be32, unsigned sport_be16,
-			     unsigned daddr_be32, unsigned dport_be16);
-
-	/*! Clear down a given filter */
-	void (*ipfilter_clear) (struct efhw_nic *nic, int filter_idx);
-
-  /*-------------- DMA support  ------------ */
-
-	/*! Initialise NIC state for a given TX DMAQ */
-	void (*dmaq_tx_q_init) (struct efhw_nic *nic,
-				uint dmaq, uint evq, uint owner, uint tag,
-				uint dmaq_size, uint buf_idx, uint flags);
-
-	/*! Initialise NIC state for a given RX DMAQ */
-	void (*dmaq_rx_q_init) (struct efhw_nic *nic,
-				uint dmaq, uint evq, uint owner, uint tag,
-				uint dmaq_size, uint buf_idx, uint flags);
-
-	/*! Disable a given TX DMAQ */
-	void (*dmaq_tx_q_disable) (struct efhw_nic *nic, uint dmaq);
-
-	/*! Disable a given RX DMAQ */
-	void (*dmaq_rx_q_disable) (struct efhw_nic *nic, uint dmaq);
-
-	/*! Flush a given TX DMA channel */
-	int (*flush_tx_dma_channel) (struct efhw_nic *nic, uint dmaq);
-
-	/*! Flush a given RX DMA channel */
-	int (*flush_rx_dma_channel) (struct efhw_nic *nic, uint dmaq);
-
-  /*-------------- Buffer table Support ------------ */
-
-	/*! Initialise a buffer table page */
-	void (*buffer_table_set) (struct efhw_nic *nic,
-				  dma_addr_t dma_addr,
-				  uint bufsz, uint region,
-				  int own_id, int buffer_id);
-
-	/*! Initialise a block of buffer table pages */
-	void (*buffer_table_set_n) (struct efhw_nic *nic, int buffer_id,
-				    dma_addr_t dma_addr,
-				    uint bufsz, uint region,
-				    int n_pages, int own_id);
-
-	/*! Clear a block of buffer table pages */
-	void (*buffer_table_clear) (struct efhw_nic *nic, int buffer_id,
-				    int num);
-
-	/*! Commit a buffer table update  */
-	void (*buffer_table_commit) (struct efhw_nic *nic);
-
-  /*-------------- New filter API ------------ */
-
-	/*! Set a given filter */
-	int (*filter_set) (struct efhw_nic *nic, struct efhw_filter_spec *spec,
-			   int *filter_idx_out);
-
-	/*! Clear a given filter */
-	void (*filter_clear) (struct efhw_nic *nic, int filter_idx);
-};
-
-
-/*----------------------------------------------------------------------------
- *
- * NIC type
- *
- *---------------------------------------------------------------------------*/
-
-struct efhw_device_type {
-	int  arch;            /* enum efhw_arch */
-	char variant;         /* 'A', 'B', ... */
-	int  revision;        /* 0, 1, ... */
-};
-
-
-/*----------------------------------------------------------------------------
- *
- * EtherFabric NIC instance - nic.c for HW independent functions
- *
- *---------------------------------------------------------------------------*/
-
-/*! */
-struct efhw_nic {
-	/*! zero base index in efrm_nic_tablep->nic array */
-	int index;
-	int ifindex;		/*!< OS level nic index */
-	struct net *nd_net;
-
-	struct efhw_device_type devtype;
-
-	/*! Options that can be set by user. */
-	unsigned options;
-# define NIC_OPT_EFTEST             0x1	/* owner is an eftest app */
-
-# define NIC_OPT_DEFAULT            0
-
-	/*! Internal flags that indicate hardware properties at runtime. */
-	unsigned flags;
-# define NIC_FLAG_NO_INTERRUPT          0x01 /* to be set at init time only */
-# define NIC_FLAG_TRY_MSI               0x02
-# define NIC_FLAG_MSI                   0x04
-# define NIC_FLAG_OS_IRQ_EN             0x08
-
-	unsigned mtu;		/*!< MAC MTU (includes MAC hdr) */
-
-	/* hardware resources */
-
-	/*! I/O address of the start of the bar */
-	volatile char __iomem *bar_ioaddr;
-
-	/*! Bar number of control aperture. */
-	unsigned ctr_ap_bar;
-	/*! Length of control aperture in bytes. */
-	unsigned ctr_ap_bytes;
-
-	uint8_t mac_addr[ETH_ALEN];	/*!< mac address  */
-
-	/*! EtherFabric Functional Units -- functions */
-	const struct efhw_func_ops *efhw_func;
-
-	/*! This lock protects a number of misc NIC resources.  It should
-	 * only be used for things that can be at the bottom of the lock
-	 * order.  ie. You mustn't attempt to grab any other lock while
-	 * holding this one.
-	 */
-	spinlock_t *reg_lock;
-	spinlock_t the_reg_lock;
-
-	int buf_commit_outstanding;	/*!< outstanding buffer commits */
-
-	/*! interrupt callbacks (hard-irq) */
-	void (*irq_handler) (struct efhw_nic *, int unit);
-
-	/*! event queues per driver */
-	struct efhw_keventq interrupting_evq;
-
-/* for marking when we are not using an IRQ unit
-      - 0 is a valid offset to an IRQ unit on EF1! */
-#define EFHW_IRQ_UNIT_UNUSED  0xffff
-	/*! interrupt unit in use for the interrupting event queue  */
-	unsigned int irq_unit;
-
-	struct efhw_keventq non_interrupting_evq;
-
-	struct efhw_iopage irq_iobuff;	/*!<  Falcon SYSERR interrupt */
-
-	/* The new driverlink infrastructure. */
-	struct efx_dl_device *net_driver_dev;
-	struct efx_dlfilt_cb_s *dlfilter_cb;
-
-	/*! Bit masks of the sizes of event queues and dma queues supported
-	 * by the nic. */
-	unsigned evq_sizes;
-	unsigned rxq_sizes;
-	unsigned txq_sizes;
-
-	/* Size of filter table. */
-	unsigned ip_filter_tbl_size;
-
-	/* Number of filters currently used */
-	unsigned ip_filter_tbl_used;
-
-	/* Dynamically allocated filter state. */
-	uint8_t *filter_in_use;
-	struct efhw_filter_spec *filter_spec_cache;
-
-	/* Currently required and maximum filter table search depths. */
-	struct efhw_filter_depth tcp_full_srch;
-	struct efhw_filter_depth tcp_wild_srch;
-	struct efhw_filter_depth udp_full_srch;
-	struct efhw_filter_depth udp_wild_srch;
-
-	/* Number of event queues, DMA queues and timers. */
-	unsigned num_evqs;
-	unsigned num_dmaqs;
-	unsigned num_timers;
-};
-
-
-#define EFHW_KVA(nic)       ((nic)->bar_ioaddr)
-
-
-#endif /* __CI_EFHW_EFHW_TYPES_H__ */
diff -r 5b3d4d3c1166 drivers/net/sfc/sfc_resource/ci/efhw/eventq.h
--- a/drivers/net/sfc/sfc_resource/ci/efhw/eventq.h	Fri Nov 05 15:20:28 2010 +0000
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,72 +0,0 @@
-/****************************************************************************
- * Driver for Solarflare network controllers -
- *          resource management for Xen backend, OpenOnload, etc
- *           (including support for SFE4001 10GBT NIC)
- *
- * This file contains API provided by efhw/eventq.c file.  This file is not
- * designed for use outside of the SFC resource driver.
- *
- * Copyright 2005-2007: Solarflare Communications Inc,
- *                      9501 Jeronimo Road, Suite 250,
- *                      Irvine, CA 92618, USA
- *
- * Developed and maintained by Solarflare Communications:
- *                      <linux-xen-drivers@solarflare.com>
- *                      <onload-dev@solarflare.com>
- *
- * Certain parts of the driver were implemented by
- *          Alexandra Kossovsky <Alexandra.Kossovsky@oktetlabs.ru>
- *          OKTET Labs Ltd, Russia,
- *          http://oktetlabs.ru, <info@oktetlabs.ru>
- *          by request of Solarflare Communications
- *
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 as published
- * by the Free Software Foundation, incorporated herein by reference.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
- ****************************************************************************
- */
-
-#ifndef __CI_EFHW_EVENTQ_H__
-#define __CI_EFHW_EVENTQ_H__
-
-#include <ci/efhw/efhw_types.h>
-#include <ci/efhw/eventq_macros.h>
-
-/*! Poll the event queue. */
-extern int efhw_keventq_poll(struct efhw_nic *, struct efhw_keventq *);
-
-/*! Callbacks for handling events. */
-struct efhw_ev_handler {
-	void (*wakeup_fn)(struct efhw_nic *nic, unsigned);
-	void (*timeout_fn)(struct efhw_nic *nic, unsigned);
-	void (*dmaq_flushed_fn) (struct efhw_nic *, unsigned, int);
-};
-
-extern int efhw_keventq_ctor(struct efhw_nic *, int instance,
-			     struct efhw_keventq *, struct efhw_ev_handler *);
-extern void efhw_keventq_dtor(struct efhw_nic *, struct efhw_keventq *);
-
-extern void efhw_handle_txdmaq_flushed(struct efhw_nic *,
-				       struct efhw_ev_handler *,
-				       efhw_event_t *);
-extern void efhw_handle_rxdmaq_flushed(struct efhw_nic *,
-				       struct efhw_ev_handler *,
-				       efhw_event_t *);
-extern void efhw_handle_wakeup_event(struct efhw_nic *,
-				     struct efhw_ev_handler *,
-				     efhw_event_t *);
-extern void efhw_handle_timeout_event(struct efhw_nic *,
-				      struct efhw_ev_handler *,
-				      efhw_event_t *);
-
-#endif /* __CI_EFHW_EVENTQ_H__ */
diff -r 5b3d4d3c1166 drivers/net/sfc/sfc_resource/ci/efhw/eventq_macros.h
--- a/drivers/net/sfc/sfc_resource/ci/efhw/eventq_macros.h	Fri Nov 05 15:20:28 2010 +0000
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,77 +0,0 @@
-/****************************************************************************
- * Driver for Solarflare network controllers -
- *          resource management for Xen backend, OpenOnload, etc
- *           (including support for SFE4001 10GBT NIC)
- *
- * This file provides some event-related macros.  This file is designed for
- * use from kernel and from the userland contexts.
- *
- * Copyright 2005-2007: Solarflare Communications Inc,
- *                      9501 Jeronimo Road, Suite 250,
- *                      Irvine, CA 92618, USA
- *
- * Developed and maintained by Solarflare Communications:
- *                      <linux-xen-drivers@solarflare.com>
- *                      <onload-dev@solarflare.com>
- *
- * Certain parts of the driver were implemented by
- *          Alexandra Kossovsky <Alexandra.Kossovsky@oktetlabs.ru>
- *          OKTET Labs Ltd, Russia,
- *          http://oktetlabs.ru, <info@oktetlabs.ru>
- *          by request of Solarflare Communications
- *
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 as published
- * by the Free Software Foundation, incorporated herein by reference.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
- ****************************************************************************
- */
-
-#ifndef __CI_EFHW_EVENTQ_MACROS_H__
-#define __CI_EFHW_EVENTQ_MACROS_H__
-
-#include <ci/efhw/common.h>
-
-/*--------------------------------------------------------------------
- *
- * Event Queue manipulation
- *
- *--------------------------------------------------------------------*/
-
-#define EFHW_EVENT_OFFSET(q, s, i)					\
-	(((s)->evq_ptr - (i) * (int32_t)sizeof(efhw_event_t))		\
-	 & (q)->evq_mask)
-
-#define EFHW_EVENT_PTR(q, s, i)						\
-	((efhw_event_t *)((q)->evq_base + EFHW_EVENT_OFFSET(q, s, i)))
-
-#define EFHW_EVENTQ_NEXT(s)						\
-	do { ((s)->evq_ptr += sizeof(efhw_event_t)); } while (0)
-
-#define EFHW_EVENTQ_PREV(s)						\
-	do { ((s)->evq_ptr -= sizeof(efhw_event_t)); } while (0)
-
-/* Be worried about this on byteswapped machines */
-/* Due to crazy chipsets, we see the event words being written in
-** arbitrary order (bug4539).  So test for presence of event must ensure
-** that both halves have changed from the null.
-*/
-#define EFHW_IS_EVENT(evp)			\
-	(((evp)->opaque.a != (uint32_t)-1) &&	\
-	 ((evp)->opaque.b != (uint32_t)-1))
-#define EFHW_CLEAR_EVENT(evp)       ((evp)->u64 = (uint64_t)-1)
-#define EFHW_CLEAR_EVENT_VALUE      0xff
-
-#define EFHW_EVENT_OVERFLOW(evq, s)			\
-	(EFHW_IS_EVENT(EFHW_EVENT_PTR(evq, s, 1)))
-
-#endif /* __CI_EFHW_EVENTQ_MACROS_H__ */
diff -r 5b3d4d3c1166 drivers/net/sfc/sfc_resource/ci/efhw/falcon.h
--- a/drivers/net/sfc/sfc_resource/ci/efhw/falcon.h	Fri Nov 05 15:20:28 2010 +0000
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,94 +0,0 @@
-/****************************************************************************
- * Driver for Solarflare network controllers -
- *          resource management for Xen backend, OpenOnload, etc
- *           (including support for SFE4001 10GBT NIC)
- *
- * This file contains API provided by efhw/falcon.c file.  This file is not
- * designed for use outside of the SFC resource driver.
- *
- * Copyright 2005-2007: Solarflare Communications Inc,
- *                      9501 Jeronimo Road, Suite 250,
- *                      Irvine, CA 92618, USA
- *
- * Developed and maintained by Solarflare Communications:
- *                      <linux-xen-drivers@solarflare.com>
- *                      <onload-dev@solarflare.com>
- *
- * Certain parts of the driver were implemented by
- *          Alexandra Kossovsky <Alexandra.Kossovsky@oktetlabs.ru>
- *          OKTET Labs Ltd, Russia,
- *          http://oktetlabs.ru, <info@oktetlabs.ru>
- *          by request of Solarflare Communications
- *
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 as published
- * by the Free Software Foundation, incorporated herein by reference.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
- ****************************************************************************
- */
-
-#ifndef __CI_EFHW_FALCON_H__
-#define __CI_EFHW_FALCON_H__
-
-#include <ci/efhw/efhw_types.h>
-#include <ci/efhw/common.h>
-
-/*----------------------------------------------------------------------------
- *
- * Locks - unfortunately required
- *
- *---------------------------------------------------------------------------*/
-
-#define FALCON_LOCK_DECL        irq_flags_t lock_state
-#define FALCON_LOCK_LOCK(nic) \
-	spin_lock_irqsave((nic)->reg_lock, lock_state)
-#define FALCON_LOCK_UNLOCK(nic) \
-	spin_unlock_irqrestore((nic)->reg_lock, lock_state)
-
-extern struct efhw_func_ops falcon_char_functional_units;
-
-/*! specify a pace value for a TX DMA Queue */
-extern void falcon_nic_pace(struct efhw_nic *nic, uint dmaq, uint pace);
-
-/*! configure the pace engine */
-extern void falcon_nic_pace_cfg(struct efhw_nic *nic, int fb_base,
-				int bin_thresh);
-
-/*! confirm buffer table updates - should be used for items where
-   loss of data would be unacceptable. E.g for the buffers that back
-   an event or DMA queue */
-extern void falcon_nic_buffer_table_confirm(struct efhw_nic *nic);
-
-/*! Reset the all the TX DMA queue pointers. */
-extern void falcon_clobber_tx_dma_ptrs(struct efhw_nic *nic, uint dmaq);
-
-extern int
-falcon_handle_char_event(struct efhw_nic *nic,
-			 struct efhw_ev_handler *h, efhw_event_t *evp);
-
-/*! Acknowledge to HW that processing is complete on a given event queue */
-extern void falcon_nic_evq_ack(struct efhw_nic *nic, uint evq,	/* evq id */
-			       uint rptr,	/* new read pointer update */
-			       bool wakeup	/* request a wakeup event if
-						   ptr's != */
-    );
-
-extern void
-falcon_nic_buffer_table_set_n(struct efhw_nic *nic, int buffer_id,
-			      dma_addr_t dma_addr, uint bufsz, uint region,
-			      int n_pages, int own_id);
-
-extern int falcon_nic_filter_ctor(struct efhw_nic *nic);
-
-extern void falcon_nic_filter_dtor(struct efhw_nic *nic);
-
-#endif /* __CI_EFHW_FALCON_H__ */
diff -r 5b3d4d3c1166 drivers/net/sfc/sfc_resource/ci/efhw/falcon_hash.h
--- a/drivers/net/sfc/sfc_resource/ci/efhw/falcon_hash.h	Fri Nov 05 15:20:28 2010 +0000
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,58 +0,0 @@
-/****************************************************************************
- * Driver for Solarflare network controllers -
- *          resource management for Xen backend, OpenOnload, etc
- *           (including support for SFE4001 10GBT NIC)
- *
- * This file contains API provided by efhw/falcon_hash.c file.
- * Function declared in this file are not exported from the Linux
- * sfc_resource driver.
- *
- * Copyright 2005-2007: Solarflare Communications Inc,
- *                      9501 Jeronimo Road, Suite 250,
- *                      Irvine, CA 92618, USA
- *
- * Developed and maintained by Solarflare Communications:
- *                      <linux-xen-drivers@solarflare.com>
- *                      <onload-dev@solarflare.com>
- *
- * Certain parts of the driver were implemented by
- *          Alexandra Kossovsky <Alexandra.Kossovsky@oktetlabs.ru>
- *          OKTET Labs Ltd, Russia,
- *          http://oktetlabs.ru, <info@oktetlabs.ru>
- *          by request of Solarflare Communications
- *
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 as published
- * by the Free Software Foundation, incorporated herein by reference.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
- ****************************************************************************
- */
-
-#ifndef __CI_EFHW_FALCON_HASH_H__
-#define __CI_EFHW_FALCON_HASH_H__
-
-extern unsigned int
-falcon_hash_get_ip_key(unsigned int src_ip, unsigned int src_port,
-		       unsigned int dest_ip, unsigned int dest_port,
-		       int tcp, int full);
-
-extern unsigned int
-falcon_hash_function1(unsigned int key, unsigned int nfilters);
-
-extern unsigned int
-falcon_hash_function2(unsigned int key, unsigned int nfilters);
-
-extern unsigned int
-falcon_hash_iterator(unsigned int hash1, unsigned int hash2,
-		     unsigned int n_search, unsigned int nfilters);
-
-#endif /* __CI_EFHW_FALCON_HASH_H__ */
diff -r 5b3d4d3c1166 drivers/net/sfc/sfc_resource/ci/efhw/hardware_sysdep.h
--- a/drivers/net/sfc/sfc_resource/ci/efhw/hardware_sysdep.h	Fri Nov 05 15:20:28 2010 +0000
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,69 +0,0 @@
-/****************************************************************************
- * Driver for Solarflare network controllers -
- *          resource management for Xen backend, OpenOnload, etc
- *           (including support for SFE4001 10GBT NIC)
- *
- * This file provides version-independent Linux kernel API for header files
- * with hardware-related definitions (in ci/driver/efab/hardware*).
- * Only kernels >=2.6.9 are supported.
- *
- * Copyright 2005-2007: Solarflare Communications Inc,
- *                      9501 Jeronimo Road, Suite 250,
- *                      Irvine, CA 92618, USA
- *
- * Developed and maintained by Solarflare Communications:
- *                      <linux-xen-drivers@solarflare.com>
- *                      <onload-dev@solarflare.com>
- *
- * Certain parts of the driver were implemented by
- *          Alexandra Kossovsky <Alexandra.Kossovsky@oktetlabs.ru>
- *          OKTET Labs Ltd, Russia,
- *          http://oktetlabs.ru, <info@oktetlabs.ru>
- *          by request of Solarflare Communications
- *
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 as published
- * by the Free Software Foundation, incorporated herein by reference.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
- ****************************************************************************
- */
-
-#ifndef __CI_EFHW_HARDWARE_LINUX_H__
-#define __CI_EFHW_HARDWARE_LINUX_H__
-
-#include <linux/io.h>
-
-#if defined(__LITTLE_ENDIAN)
-#define EFHW_IS_LITTLE_ENDIAN
-#elif defined(__BIG_ENDIAN)
-#define EFHW_IS_BIG_ENDIAN
-#else
-#error Unknown endianness
-#endif
-
-#ifndef readq
-static inline uint64_t __readq(volatile void __iomem *addr)
-{
-	return *(volatile uint64_t *)addr;
-}
-#define readq(x) __readq(x)
-#endif
-
-#ifndef writeq
-static inline void __writeq(uint64_t v, volatile void __iomem *addr)
-{
-	*(volatile uint64_t *)addr = v;
-}
-#define writeq(val, addr) __writeq((val), (addr))
-#endif
-
-#endif /* __CI_EFHW_HARDWARE_LINUX_H__ */
diff -r 5b3d4d3c1166 drivers/net/sfc/sfc_resource/ci/efhw/iopage.h
--- a/drivers/net/sfc/sfc_resource/ci/efhw/iopage.h	Fri Nov 05 15:20:28 2010 +0000
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,58 +0,0 @@
-/****************************************************************************
- * Driver for Solarflare network controllers -
- *          resource management for Xen backend, OpenOnload, etc
- *           (including support for SFE4001 10GBT NIC)
- *
- * This file contains OS-independent API for allocating iopage types.
- * The implementation of these functions is highly OS-dependent.
- * This file is not designed for use outside of the SFC resource driver.
- *
- * Copyright 2005-2007: Solarflare Communications Inc,
- *                      9501 Jeronimo Road, Suite 250,
- *                      Irvine, CA 92618, USA
- *
- * Developed and maintained by Solarflare Communications:
- *                      <linux-xen-drivers@solarflare.com>
- *                      <onload-dev@solarflare.com>
- *
- * Certain parts of the driver were implemented by
- *          Alexandra Kossovsky <Alexandra.Kossovsky@oktetlabs.ru>
- *          OKTET Labs Ltd, Russia,
- *          http://oktetlabs.ru, <info@oktetlabs.ru>
- *          by request of Solarflare Communications
- *
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 as published
- * by the Free Software Foundation, incorporated herein by reference.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
- ****************************************************************************
- */
-
-#ifndef __CI_DRIVER_RESOURCE_IOPAGE_H__
-#define __CI_DRIVER_RESOURCE_IOPAGE_H__
-
-#include <ci/efhw/efhw_types.h>
-
-/*--------------------------------------------------------------------
- *
- * memory allocation
- *
- *--------------------------------------------------------------------*/
-
-extern int efhw_iopage_alloc(struct efhw_nic *, struct efhw_iopage *p);
-extern void efhw_iopage_free(struct efhw_nic *, struct efhw_iopage *p);
-
-extern int efhw_iopages_alloc(struct efhw_nic *, struct efhw_iopages *p,
-			      unsigned order);
-extern void efhw_iopages_free(struct efhw_nic *, struct efhw_iopages *p);
-
-#endif /* __CI_DRIVER_RESOURCE_IOPAGE_H__ */
diff -r 5b3d4d3c1166 drivers/net/sfc/sfc_resource/ci/efhw/iopage_types.h
--- a/drivers/net/sfc/sfc_resource/ci/efhw/iopage_types.h	Fri Nov 05 15:20:28 2010 +0000
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,190 +0,0 @@
-/****************************************************************************
- * Driver for Solarflare network controllers -
- *          resource management for Xen backend, OpenOnload, etc
- *           (including support for SFE4001 10GBT NIC)
- *
- * This file provides struct efhw_page and struct efhw_iopage for Linux
- * kernel.
- *
- * Copyright 2005-2007: Solarflare Communications Inc,
- *                      9501 Jeronimo Road, Suite 250,
- *                      Irvine, CA 92618, USA
- *
- * Developed and maintained by Solarflare Communications:
- *                      <linux-xen-drivers@solarflare.com>
- *                      <onload-dev@solarflare.com>
- *
- * Certain parts of the driver were implemented by
- *          Alexandra Kossovsky <Alexandra.Kossovsky@oktetlabs.ru>
- *          OKTET Labs Ltd, Russia,
- *          http://oktetlabs.ru, <info@oktetlabs.ru>
- *          by request of Solarflare Communications
- *
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 as published
- * by the Free Software Foundation, incorporated herein by reference.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
- ****************************************************************************
- */
-
-#ifndef __CI_EFHW_IOPAGE_LINUX_H__
-#define __CI_EFHW_IOPAGE_LINUX_H__
-
-#include <linux/gfp.h>
-#include <linux/hardirq.h>
-#include <linux/errno.h>
-#include <ci/efhw/debug.h>
-
-/*--------------------------------------------------------------------
- *
- * struct efhw_page: A single page of memory.  Directly mapped in the
- * driver, and can be mapped to userlevel.
- *
- *--------------------------------------------------------------------*/
-
-struct efhw_page {
-	unsigned long kva;
-};
-
-static inline int efhw_page_alloc(struct efhw_page *p)
-{
-	p->kva = __get_free_page(in_interrupt()? GFP_ATOMIC : GFP_KERNEL);
-	return p->kva ? 0 : -ENOMEM;
-}
-
-static inline int efhw_page_alloc_zeroed(struct efhw_page *p)
-{
-	p->kva = get_zeroed_page(in_interrupt()? GFP_ATOMIC : GFP_KERNEL);
-	return p->kva ? 0 : -ENOMEM;
-}
-
-static inline void efhw_page_free(struct efhw_page *p)
-{
-	free_page(p->kva);
-	EFHW_DO_DEBUG(memset(p, 0, sizeof(*p)));
-}
-
-static inline char *efhw_page_ptr(struct efhw_page *p)
-{
-	return (char *)p->kva;
-}
-
-static inline unsigned efhw_page_pfn(struct efhw_page *p)
-{
-	return (unsigned)(__pa(p->kva) >> PAGE_SHIFT);
-}
-
-static inline void efhw_page_mark_invalid(struct efhw_page *p)
-{
-	p->kva = 0;
-}
-
-static inline int efhw_page_is_valid(struct efhw_page *p)
-{
-	return p->kva != 0;
-}
-
-static inline void efhw_page_init_from_va(struct efhw_page *p, void *va)
-{
-	p->kva = (unsigned long)va;
-}
-
-/*--------------------------------------------------------------------
- *
- * struct efhw_iopage: A single page of memory.  Directly mapped in the driver,
- * and can be mapped to userlevel.  Can also be accessed by the NIC.
- *
- *--------------------------------------------------------------------*/
-
-struct efhw_iopage {
-	struct efhw_page p;
-	dma_addr_t dma_addr;
-};
-
-static inline dma_addr_t efhw_iopage_dma_addr(struct efhw_iopage *p)
-{
-	return p->dma_addr;
-}
-
-#define efhw_iopage_ptr(iop)		efhw_page_ptr(&(iop)->p)
-#define efhw_iopage_pfn(iop)		efhw_page_pfn(&(iop)->p)
-#define efhw_iopage_mark_invalid(iop)	efhw_page_mark_invalid(&(iop)->p)
-#define efhw_iopage_is_valid(iop)	efhw_page_is_valid(&(iop)->p)
-
-/*--------------------------------------------------------------------
- *
- * struct efhw_iopages: A set of pages that are contiguous in physical
- * memory.  Directly mapped in the driver, and can be mapped to userlevel.
- * Can also be accessed by the NIC.
- *
- * NB. The O/S may be unwilling to allocate many, or even any of these.  So
- * only use this type where the NIC really needs a physically contiguous
- * buffer.
- *
- *--------------------------------------------------------------------*/
-
-struct efhw_iopages {
-	caddr_t kva;
-	unsigned order;
-	dma_addr_t dma_addr;
-};
-
-static inline caddr_t efhw_iopages_ptr(struct efhw_iopages *p)
-{
-	return p->kva;
-}
-
-static inline unsigned efhw_iopages_pfn(struct efhw_iopages *p)
-{
-	return (unsigned)(__pa(p->kva) >> PAGE_SHIFT);
-}
-
-static inline dma_addr_t efhw_iopages_dma_addr(struct efhw_iopages *p)
-{
-	return p->dma_addr;
-}
-
-static inline unsigned efhw_iopages_size(struct efhw_iopages *p)
-{
-	return 1u << (p->order + PAGE_SHIFT);
-}
-
-/* struct efhw_iopage <-> struct efhw_iopages conversions for handling
- * physically contiguous allocations in iobufsets for iSCSI.  This allows
- * the essential information about contiguous allocations from
- * efhw_iopages_alloc() to be saved away in the struct efhw_iopage array in
- * an iobufset.  (Changing the iobufset resource to use a union type would
- * involve a lot of code changes, and make the iobufset's metadata larger
- * which could be bad as it's supposed to fit into a single page on some
- * platforms.)
- */
-static inline void
-efhw_iopage_init_from_iopages(struct efhw_iopage *iopage,
-			      struct efhw_iopages *iopages, unsigned pageno)
-{
-	iopage->p.kva = ((unsigned long)efhw_iopages_ptr(iopages))
-	    + (pageno * PAGE_SIZE);
-	iopage->dma_addr = efhw_iopages_dma_addr(iopages) +
-	    (pageno * PAGE_SIZE);
-}
-
-static inline void
-efhw_iopages_init_from_iopage(struct efhw_iopages *iopages,
-			      struct efhw_iopage *iopage, unsigned order)
-{
-	iopages->kva = (caddr_t) efhw_iopage_ptr(iopage);
-	EFHW_ASSERT(iopages->kva);
-	iopages->order = order;
-	iopages->dma_addr = efhw_iopage_dma_addr(iopage);
-}
-
-#endif /* __CI_EFHW_IOPAGE_LINUX_H__ */
diff -r 5b3d4d3c1166 drivers/net/sfc/sfc_resource/ci/efhw/nic.h
--- a/drivers/net/sfc/sfc_resource/ci/efhw/nic.h	Fri Nov 05 15:20:28 2010 +0000
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,62 +0,0 @@
-/****************************************************************************
- * Driver for Solarflare network controllers -
- *          resource management for Xen backend, OpenOnload, etc
- *           (including support for SFE4001 10GBT NIC)
- *
- * This file contains API provided by efhw/nic.c file.  This file is not
- * designed for use outside of the SFC resource driver.
- *
- * Copyright 2005-2007: Solarflare Communications Inc,
- *                      9501 Jeronimo Road, Suite 250,
- *                      Irvine, CA 92618, USA
- *
- * Developed and maintained by Solarflare Communications:
- *                      <linux-xen-drivers@solarflare.com>
- *                      <onload-dev@solarflare.com>
- *
- * Certain parts of the driver were implemented by
- *          Alexandra Kossovsky <Alexandra.Kossovsky@oktetlabs.ru>
- *          OKTET Labs Ltd, Russia,
- *          http://oktetlabs.ru, <info@oktetlabs.ru>
- *          by request of Solarflare Communications
- *
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 as published
- * by the Free Software Foundation, incorporated herein by reference.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
- ****************************************************************************
- */
-
-#ifndef __CI_EFHW_NIC_H__
-#define __CI_EFHW_NIC_H__
-
-#include <ci/efhw/efhw_types.h>
-#include <ci/efhw/public.h>
-
-
-/* Convert PCI info to device type.  Returns false when device is not
- * recognised.
- */
-extern int efhw_device_type_init(struct efhw_device_type *dt,
-				 int vendor_id, int device_id, int revision);
-
-/* Initialise fields that do not involve touching hardware. */
-extern void efhw_nic_init(struct efhw_nic *nic, unsigned flags,
-			  unsigned options, struct efhw_device_type dev_type);
-
-/*! Destruct NIC resources */
-extern void efhw_nic_dtor(struct efhw_nic *nic);
-
-/*! Shutdown interrupts */
-extern void efhw_nic_close_interrupts(struct efhw_nic *nic);
-
-#endif /* __CI_EFHW_NIC_H__ */
diff -r 5b3d4d3c1166 drivers/net/sfc/sfc_resource/ci/efhw/public.h
--- a/drivers/net/sfc/sfc_resource/ci/efhw/public.h	Fri Nov 05 15:20:28 2010 +0000
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,104 +0,0 @@
-/****************************************************************************
- * Driver for Solarflare network controllers -
- *          resource management for Xen backend, OpenOnload, etc
- *           (including support for SFE4001 10GBT NIC)
- *
- * This file provides public API of efhw library exported from the SFC
- * resource driver.
- *
- * Copyright 2005-2007: Solarflare Communications Inc,
- *                      9501 Jeronimo Road, Suite 250,
- *                      Irvine, CA 92618, USA
- *
- * Developed and maintained by Solarflare Communications:
- *                      <linux-xen-drivers@solarflare.com>
- *                      <onload-dev@solarflare.com>
- *
- * Certain parts of the driver were implemented by
- *          Alexandra Kossovsky <Alexandra.Kossovsky@oktetlabs.ru>
- *          OKTET Labs Ltd, Russia,
- *          http://oktetlabs.ru, <info@oktetlabs.ru>
- *          by request of Solarflare Communications
- *
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 as published
- * by the Free Software Foundation, incorporated herein by reference.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
- ****************************************************************************
- */
-
-#ifndef __CI_EFHW_PUBLIC_H__
-#define __CI_EFHW_PUBLIC_H__
-
-#include <ci/efhw/common.h>
-#include <ci/efhw/efhw_types.h>
-
-/*! Returns true if we have some EtherFabric functional units -
-  whether configured or not */
-static inline int efhw_nic_have_functional_units(struct efhw_nic *nic)
-{
-	return nic->efhw_func != 0;
-}
-
-/*! Returns true if the EtherFabric functional units have been configured  */
-static inline int efhw_nic_have_hw(struct efhw_nic *nic)
-{
-	return efhw_nic_have_functional_units(nic) && (EFHW_KVA(nic) != 0);
-}
-
-/*! Helper function to allocate the iobuffer needed by an eventq
- *   - it ensures the eventq has the correct alignment for the NIC
- *
- * \param rm        Event-queue resource manager
- * \param instance  Event-queue instance (index)
- * \param buf_bytes Requested size of eventq
- * \return          < 0 if iobuffer allocation fails
- */
-int efhw_nic_event_queue_alloc_iobuffer(struct efhw_nic *nic,
-					struct eventq_resource_hardware *h,
-					int evq_instance, unsigned buf_bytes);
-
-extern void falcon_nic_set_rx_usr_buf_size(struct efhw_nic *,
-					   int rx_usr_buf_size);
-
-/*! Get RX filter search limits from RX_FILTER_CTL_REG.
- *  use_raw_values = 0 to get actual depth of search, or 1 to get raw values
- *  from register.
- */
-extern void
-falcon_nic_get_rx_filter_search_limits(struct efhw_nic *nic,
-				       struct efhw_filter_search_limits *lim,
-				       int use_raw_values);
-
-/*! Set RX filter search limits in RX_FILTER_CTL_REG.
- *  use_raw_values = 0 if specifying actual depth of search, or 1 if specifying
- *  raw values to write to the register.
- */
-extern void
-falcon_nic_set_rx_filter_search_limits(struct efhw_nic *nic,
-				       struct efhw_filter_search_limits *lim,
-				       int use_raw_values);
-
-
-/*! Legacy RX IP filter search depth control interface */
-extern void
-falcon_nic_rx_filter_ctl_set(struct efhw_nic *nic, uint32_t tcp_full,
-			     uint32_t tcp_wild,
-			     uint32_t udp_full, uint32_t udp_wild);
-
-/*! Legacy RX IP filter search depth control interface */
-extern void
-falcon_nic_rx_filter_ctl_get(struct efhw_nic *nic, uint32_t *tcp_full,
-			     uint32_t *tcp_wild,
-			     uint32_t *udp_full, uint32_t *udp_wild);
-
-#endif /* __CI_EFHW_PUBLIC_H__ */
diff -r 5b3d4d3c1166 drivers/net/sfc/sfc_resource/ci/efhw/sysdep.h
--- a/drivers/net/sfc/sfc_resource/ci/efhw/sysdep.h	Fri Nov 05 15:20:28 2010 +0000
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,55 +0,0 @@
-/****************************************************************************
- * Driver for Solarflare network controllers -
- *          resource management for Xen backend, OpenOnload, etc
- *           (including support for SFE4001 10GBT NIC)
- *
- * This file provides version-independent Linux kernel API for efhw library.
- * Only kernels >=2.6.9 are supported.
- *
- * Copyright 2005-2007: Solarflare Communications Inc,
- *                      9501 Jeronimo Road, Suite 250,
- *                      Irvine, CA 92618, USA
- *
- * Developed and maintained by Solarflare Communications:
- *                      <linux-xen-drivers@solarflare.com>
- *                      <onload-dev@solarflare.com>
- *
- * Certain parts of the driver were implemented by
- *          Alexandra Kossovsky <Alexandra.Kossovsky@oktetlabs.ru>
- *          OKTET Labs Ltd, Russia,
- *          http://oktetlabs.ru, <info@oktetlabs.ru>
- *          by request of Solarflare Communications
- *
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 as published
- * by the Free Software Foundation, incorporated herein by reference.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
- ****************************************************************************
- */
-
-#ifndef __CI_EFHW_SYSDEP_LINUX_H__
-#define __CI_EFHW_SYSDEP_LINUX_H__
-
-#include <linux/module.h>
-#include <linux/spinlock.h>
-#include <linux/delay.h>
-#include <linux/vmalloc.h>
-#include <linux/if_ether.h>
-
-#include <linux/netdevice.h> /* necessary for etherdevice.h on some kernels */
-#include <linux/etherdevice.h>
-
-typedef unsigned long irq_flags_t;
-
-#define spin_lock_destroy(l_)  do {} while (0)
-
-#endif /* __CI_EFHW_SYSDEP_LINUX_H__ */
diff -r 5b3d4d3c1166 drivers/net/sfc/sfc_resource/ci/efrm/buddy.h
--- a/drivers/net/sfc/sfc_resource/ci/efrm/buddy.h	Fri Nov 05 15:20:28 2010 +0000
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,68 +0,0 @@
-/****************************************************************************
- * Driver for Solarflare network controllers -
- *          resource management for Xen backend, OpenOnload, etc
- *           (including support for SFE4001 10GBT NIC)
- *
- * This file provides private API for buddy allocator.  This API is not
- * designed for use outside of SFC resource driver.
- *
- * Copyright 2005-2007: Solarflare Communications Inc,
- *                      9501 Jeronimo Road, Suite 250,
- *                      Irvine, CA 92618, USA
- *
- * Developed and maintained by Solarflare Communications:
- *                      <linux-xen-drivers@solarflare.com>
- *                      <onload-dev@solarflare.com>
- *
- * Certain parts of the driver were implemented by
- *          Alexandra Kossovsky <Alexandra.Kossovsky@oktetlabs.ru>
- *          OKTET Labs Ltd, Russia,
- *          http://oktetlabs.ru, <info@oktetlabs.ru>
- *          by request of Solarflare Communications
- *
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 as published
- * by the Free Software Foundation, incorporated herein by reference.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
- ****************************************************************************
- */
-
-#ifndef __CI_EFRM_BUDDY_H__
-#define __CI_EFRM_BUDDY_H__
-
-#include <ci/efrm/sysdep.h>
-
-/*! Comment? */
-struct efrm_buddy_allocator {
-	struct list_head *free_lists;	/* array[order+1] */
-	struct list_head *links;	/* array[1<<order] */
-	uint8_t *orders;		/* array[1<<order] */
-	unsigned order;		/*!< total size == (1 << order) */
-	/* ?? Consider recording largest available order + for each order the
-	 ** smallest available order that is big enough.
-	 */
-};
-
-  /*! Returns total size of managed space. */
-static inline unsigned long efrm_buddy_size(struct efrm_buddy_allocator *b)
-{
-	return 1ul << b->order;
-}
-
-int efrm_buddy_ctor(struct efrm_buddy_allocator *b, unsigned order);
-void efrm_buddy_dtor(struct efrm_buddy_allocator *b);
-int efrm_buddy_alloc(struct efrm_buddy_allocator *b, unsigned order);
-void efrm_buddy_free(struct efrm_buddy_allocator *b, unsigned addr,
-		     unsigned order);
-
-
-#endif /* __CI_EFRM_BUDDY_H__ */
diff -r 5b3d4d3c1166 drivers/net/sfc/sfc_resource/ci/efrm/buffer_table.h
--- a/drivers/net/sfc/sfc_resource/ci/efrm/buffer_table.h	Fri Nov 05 15:20:28 2010 +0000
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,81 +0,0 @@
-/****************************************************************************
- * Driver for Solarflare network controllers -
- *          resource management for Xen backend, OpenOnload, etc
- *           (including support for SFE4001 10GBT NIC)
- *
- * This file provides private buffer table API.  This API is not designed
- * for use outside of SFC resource driver.
- *
- * Copyright 2005-2007: Solarflare Communications Inc,
- *                      9501 Jeronimo Road, Suite 250,
- *                      Irvine, CA 92618, USA
- *
- * Developed and maintained by Solarflare Communications:
- *                      <linux-xen-drivers@solarflare.com>
- *                      <onload-dev@solarflare.com>
- *
- * Certain parts of the driver were implemented by
- *          Alexandra Kossovsky <Alexandra.Kossovsky@oktetlabs.ru>
- *          OKTET Labs Ltd, Russia,
- *          http://oktetlabs.ru, <info@oktetlabs.ru>
- *          by request of Solarflare Communications
- *
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 as published
- * by the Free Software Foundation, incorporated herein by reference.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
- ****************************************************************************
- */
-
-#ifndef __CI_EFRM_BUFFER_TABLE_H__
-#define __CI_EFRM_BUFFER_TABLE_H__
-
-#include <ci/efhw/efhw_types.h>
-
-/*--------------------------------------------------------------------
- *
- * NIC's buffer table.
- *
- *--------------------------------------------------------------------*/
-
-/*! Managed interface. */
-
-/*! construct a managed buffer table object, allocated over a region of
- *  the NICs buffer table space
- */
-extern int efrm_buffer_table_ctor(unsigned low, unsigned high);
-/*! destructor for above */
-extern void efrm_buffer_table_dtor(void);
-
-/*! allocate a contiguous region of buffer table space */
-extern int efrm_buffer_table_alloc(unsigned order,
-				   struct efhw_buffer_table_allocation *a);
-
-
-/*--------------------------------------------------------------------
- *
- * buffer table operations through the HW independent API
- *
- *--------------------------------------------------------------------*/
-
-/*! free a previously allocated region of buffer table space */
-extern void efrm_buffer_table_free(struct efhw_buffer_table_allocation *a);
-
-/*! commit the update of a buffer table entry to every NIC */
-extern void efrm_buffer_table_commit(void);
-
-extern void efrm_buffer_table_set(struct efhw_buffer_table_allocation *,
-				  struct efhw_nic *,
-				  unsigned i, dma_addr_t dma_addr, int owner);
-
-
-#endif /* __CI_EFRM_BUFFER_TABLE_H__ */
diff -r 5b3d4d3c1166 drivers/net/sfc/sfc_resource/ci/efrm/debug.h
--- a/drivers/net/sfc/sfc_resource/ci/efrm/debug.h	Fri Nov 05 15:20:28 2010 +0000
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,78 +0,0 @@
-/****************************************************************************
- * Driver for Solarflare network controllers -
- *          resource management for Xen backend, OpenOnload, etc
- *           (including support for SFE4001 10GBT NIC)
- *
- * This file provides debug-related API for efrm library using Linux kernel
- * primitives.
- *
- * Copyright 2005-2007: Solarflare Communications Inc,
- *                      9501 Jeronimo Road, Suite 250,
- *                      Irvine, CA 92618, USA
- *
- * Developed and maintained by Solarflare Communications:
- *                      <linux-xen-drivers@solarflare.com>
- *                      <onload-dev@solarflare.com>
- *
- * Certain parts of the driver were implemented by
- *          Alexandra Kossovsky <Alexandra.Kossovsky@oktetlabs.ru>
- *          OKTET Labs Ltd, Russia,
- *          http://oktetlabs.ru, <info@oktetlabs.ru>
- *          by request of Solarflare Communications
- *
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 as published
- * by the Free Software Foundation, incorporated herein by reference.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
- ****************************************************************************
- */
-
-#ifndef __CI_EFRM_DEBUG_LINUX_H__
-#define __CI_EFRM_DEBUG_LINUX_H__
-
-#define EFRM_PRINTK_PREFIX "[sfc efrm] "
-
-#define EFRM_PRINTK(level, fmt, ...) \
-	printk(level EFRM_PRINTK_PREFIX fmt "\n", __VA_ARGS__)
-
-/* Following macros should be used with non-zero format parameters
- * due to __VA_ARGS__ limitations.  Use "%s" with __func__ if you can't
- * find better parameters. */
-#define EFRM_ERR(fmt, ...)     EFRM_PRINTK(KERN_ERR, fmt, __VA_ARGS__)
-#define EFRM_WARN(fmt, ...)    EFRM_PRINTK(KERN_WARNING, fmt, __VA_ARGS__)
-#define EFRM_NOTICE(fmt, ...)  EFRM_PRINTK(KERN_NOTICE, fmt, __VA_ARGS__)
-#if !defined(NDEBUG)
-#define EFRM_TRACE(fmt, ...) EFRM_PRINTK(KERN_DEBUG, fmt, __VA_ARGS__)
-#else
-#define EFRM_TRACE(fmt, ...)
-#endif
-
-#ifndef NDEBUG
-#define EFRM_ASSERT(cond)  BUG_ON((cond) == 0)
-#define _EFRM_ASSERT(cond, file, line) \
-	do {								\
-		if (unlikely(!(cond))) {				\
-			EFRM_ERR("assertion \"%s\" failed at %s %d",	\
-				 #cond, file, line);			\
-			BUG();						\
-		}							\
-	} while (0)
-
-#define EFRM_DO_DEBUG(expr) expr
-#define EFRM_VERIFY_EQ(expr, val) EFRM_ASSERT((expr) == (val))
-#else
-#define EFRM_ASSERT(cond)
-#define EFRM_DO_DEBUG(expr)
-#define EFRM_VERIFY_EQ(expr, val) expr
-#endif
-
-#endif /* __CI_EFRM_DEBUG_LINUX_H__ */
diff -r 5b3d4d3c1166 drivers/net/sfc/sfc_resource/ci/efrm/driver_private.h
--- a/drivers/net/sfc/sfc_resource/ci/efrm/driver_private.h	Fri Nov 05 15:20:28 2010 +0000
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,89 +0,0 @@
-/****************************************************************************
- * Driver for Solarflare network controllers -
- *          resource management for Xen backend, OpenOnload, etc
- *           (including support for SFE4001 10GBT NIC)
- *
- * This file provides private API of efrm library to be used from the SFC
- * resource driver.
- *
- * Copyright 2005-2007: Solarflare Communications Inc,
- *                      9501 Jeronimo Road, Suite 250,
- *                      Irvine, CA 92618, USA
- *
- * Developed and maintained by Solarflare Communications:
- *                      <linux-xen-drivers@solarflare.com>
- *                      <onload-dev@solarflare.com>
- *
- * Certain parts of the driver were implemented by
- *          Alexandra Kossovsky <Alexandra.Kossovsky@oktetlabs.ru>
- *          OKTET Labs Ltd, Russia,
- *          http://oktetlabs.ru, <info@oktetlabs.ru>
- *          by request of Solarflare Communications
- *
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 as published
- * by the Free Software Foundation, incorporated herein by reference.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
- ****************************************************************************
- */
-
-#ifndef __CI_EFRM_DRIVER_PRIVATE_H__
-#define __CI_EFRM_DRIVER_PRIVATE_H__
-
-#include <ci/efrm/resource.h>
-#include <ci/efrm/sysdep.h>
-
-/*--------------------------------------------------------------------
- *
- * global variables
- *
- *--------------------------------------------------------------------*/
-
-/* Internal structure for resource driver */
-extern struct efrm_resource_manager *efrm_rm_table[];
-
-/*--------------------------------------------------------------------
- *
- * efrm_nic_table handling
- *
- *--------------------------------------------------------------------*/
-
-struct efrm_nic;
-
-extern void efrm_driver_ctor(void);
-extern void efrm_driver_dtor(void);
-extern int efrm_driver_register_nic(struct efrm_nic *, int nic_index,
-				    int ifindex);
-extern int efrm_driver_unregister_nic(struct efrm_nic *);
-
-/*--------------------------------------------------------------------
- *
- * create/destroy resource managers
- *
- *--------------------------------------------------------------------*/
-
-struct vi_resource_dimensions {
-	unsigned evq_int_min, evq_int_lim;
-	unsigned evq_timer_min, evq_timer_lim;
-	unsigned rxq_min, rxq_lim;
-	unsigned txq_min, txq_lim;
-};
-
-/*! Initialise resources */
-extern int
-efrm_resources_init(const struct vi_resource_dimensions *,
-		    int buffer_table_min, int buffer_table_lim);
-
-/*! Tear down resources */
-extern void efrm_resources_fini(void);
-
-#endif /* __CI_EFRM_DRIVER_PRIVATE_H__ */
diff -r 5b3d4d3c1166 drivers/net/sfc/sfc_resource/ci/efrm/efrm_client.h
--- a/drivers/net/sfc/sfc_resource/ci/efrm/efrm_client.h	Fri Nov 05 15:20:28 2010 +0000
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,32 +0,0 @@
-#ifndef __EFRM_CLIENT_H__
-#define __EFRM_CLIENT_H__
-
-
-struct efrm_client;
-
-
-struct efrm_client_callbacks {
-	/* Called before device is reset.  Callee may block. */
-	void (*pre_reset)(struct efrm_client *, void *user_data);
-	void (*stop)(struct efrm_client *, void *user_data);
-	void (*restart)(struct efrm_client *, void *user_data);
-};
-
-
-#define EFRM_IFINDEX_DEFAULT  -1
-
-
-/* NB. Callbacks may be invoked even before this returns. */
-extern int  efrm_client_get(int ifindex, struct efrm_client_callbacks *,
-			    void *user_data, struct efrm_client **client_out);
-extern void efrm_client_put(struct efrm_client *);
-
-extern struct efhw_nic *efrm_client_get_nic(struct efrm_client *);
-
-#if 0
-/* For each resource type... */
-extern void efrm_x_resource_resume(struct x_resource *);
-#endif
-
-
-#endif  /* __EFRM_CLIENT_H__ */
diff -r 5b3d4d3c1166 drivers/net/sfc/sfc_resource/ci/efrm/efrm_nic.h
--- a/drivers/net/sfc/sfc_resource/ci/efrm/efrm_nic.h	Fri Nov 05 15:20:28 2010 +0000
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,26 +0,0 @@
-#ifndef __EFRM_NIC_H__
-#define __EFRM_NIC_H__
-
-#include <ci/efhw/efhw_types.h>
-
-
-struct efrm_nic_per_vi {
-	unsigned long state;
-	struct vi_resource *vi;
-};
-
-
-struct efrm_nic {
-	struct efhw_nic efhw_nic;
-	struct list_head link;
-	struct list_head clients;
-	struct efrm_nic_per_vi *vis;
-};
-
-
-#define efrm_nic(_efhw_nic)				\
-  container_of(_efhw_nic, struct efrm_nic, efhw_nic)
-
-
-
-#endif  /* __EFRM_NIC_H__ */
diff -r 5b3d4d3c1166 drivers/net/sfc/sfc_resource/ci/efrm/filter.h
--- a/drivers/net/sfc/sfc_resource/ci/efrm/filter.h	Fri Nov 05 15:20:28 2010 +0000
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,122 +0,0 @@
-/****************************************************************************
- * Driver for Solarflare network controllers -
- *          resource management for Xen backend, OpenOnload, etc
- *           (including support for SFE4001 10GBT NIC)
- *
- * This file provides public API for filter resource.
- *
- * Copyright 2005-2007: Solarflare Communications Inc,
- *                      9501 Jeronimo Road, Suite 250,
- *                      Irvine, CA 92618, USA
- *
- * Developed and maintained by Solarflare Communications:
- *                      <linux-xen-drivers@solarflare.com>
- *                      <onload-dev@solarflare.com>
- *
- * Certain parts of the driver were implemented by
- *          Alexandra Kossovsky <Alexandra.Kossovsky@oktetlabs.ru>
- *          OKTET Labs Ltd, Russia,
- *          http://oktetlabs.ru, <info@oktetlabs.ru>
- *          by request of Solarflare Communications
- *
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 as published
- * by the Free Software Foundation, incorporated herein by reference.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
- ****************************************************************************
- */
-
-#ifndef __CI_EFRM_FILTER_H__
-#define __CI_EFRM_FILTER_H__
-
-#include <ci/efrm/resource.h>
-#include <ci/efhw/common.h>
-
-
-struct filter_resource;
-struct vi_resource;
-struct efrm_client;
-
-
-/*!
- * Allocate filter resource.
- *
- * \param vi_parent VI resource to use as parent. The function takes
- *                  reference to the VI resource on success.
- * \param frs_out   pointer to return the new filter resource
- *
- * \return          status code; if non-zero, frs_out is unchanged
- */
-extern int
-efrm_filter_resource_alloc(struct vi_resource *vi_parent,
-			   struct filter_resource **frs_out);
-
-extern void
-efrm_filter_resource_release(struct filter_resource *);
-
-
-extern int efrm_filter_resource_clear(struct filter_resource *frs);
-
-extern int __efrm_filter_resource_set(struct filter_resource *frs, int type,
-				      unsigned saddr_be32, uint16_t sport_be16,
-				      unsigned daddr_be32, uint16_t dport_be16);
-
-static inline int
-efrm_filter_resource_tcp_set(struct filter_resource *frs,
-			     unsigned saddr, uint16_t sport,
-			     unsigned daddr, uint16_t dport)
-{
-	int type;
-
-	EFRM_ASSERT((saddr && sport) || (!saddr && !sport));
-
-	type =
-	    saddr ? EFHW_IP_FILTER_TYPE_TCP_FULL :
-	    EFHW_IP_FILTER_TYPE_TCP_WILDCARD;
-
-	return __efrm_filter_resource_set(frs, type,
-					  saddr, sport, daddr, dport);
-}
-
-static inline int
-efrm_filter_resource_udp_set(struct filter_resource *frs,
-			     unsigned saddr, uint16_t sport,
-			     unsigned daddr, uint16_t dport)
-{
-	int type;
-
-	EFRM_ASSERT((saddr && sport) || (!saddr && !sport));
-
-	type =
-	    saddr ? EFHW_IP_FILTER_TYPE_UDP_FULL :
-	    EFHW_IP_FILTER_TYPE_UDP_WILDCARD;
-
-	return __efrm_filter_resource_set(frs,
-					  type, saddr, sport, daddr, dport);
-}
-
-
-extern int
-efrm_filter_resource_instance(struct filter_resource *);
-
-extern struct efrm_resource *
-efrm_filter_resource_to_resource(struct filter_resource *);
-
-extern struct filter_resource *
-efrm_filter_resource_from_resource(struct efrm_resource *);
-
-extern void
-efrm_filter_resource_free(struct filter_resource *);
-
-
-#endif /* __CI_EFRM_FILTER_H__ */
-/*! \cidoxg_end */
diff -r 5b3d4d3c1166 drivers/net/sfc/sfc_resource/ci/efrm/iobufset.h
--- a/drivers/net/sfc/sfc_resource/ci/efrm/iobufset.h	Fri Nov 05 15:20:28 2010 +0000
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,110 +0,0 @@
-/****************************************************************************
- * Driver for Solarflare network controllers -
- *          resource management for Xen backend, OpenOnload, etc
- *           (including support for SFE4001 10GBT NIC)
- *
- * This file provides public API for iobufset resource.
- *
- * Copyright 2005-2007: Solarflare Communications Inc,
- *                      9501 Jeronimo Road, Suite 250,
- *                      Irvine, CA 92618, USA
- *
- * Developed and maintained by Solarflare Communications:
- *                      <linux-xen-drivers@solarflare.com>
- *                      <onload-dev@solarflare.com>
- *
- * Certain parts of the driver were implemented by
- *          Alexandra Kossovsky <Alexandra.Kossovsky@oktetlabs.ru>
- *          OKTET Labs Ltd, Russia,
- *          http://oktetlabs.ru, <info@oktetlabs.ru>
- *          by request of Solarflare Communications
- *
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 as published
- * by the Free Software Foundation, incorporated herein by reference.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
- ****************************************************************************
- */
-
-#ifndef __CI_EFRM_IOBUFSET_H__
-#define __CI_EFRM_IOBUFSET_H__
-
-#include <ci/efrm/vi_resource.h>
-
-/*! Iobufset resource structture.
- * Users should not access the structure fields directly, but use the API
- * below.
- * However, this structure should not be moved out of public headers,
- * because part of API (ex. efrm_iobufset_dma_addr function) is inline and
- * is used in the fast-path code.
- */
-struct iobufset_resource {
-	struct efrm_resource rs;
-	struct vi_resource *evq;
-	struct iobufset_resource *linked;
-	struct efhw_buffer_table_allocation buf_tbl_alloc;
-	unsigned int n_bufs;
-	unsigned int pages_per_contiguous_chunk;
-	unsigned chunk_order;
-	struct efhw_iopage bufs[1];
-	/*!< up to n_bufs can follow this, so this must be the last member */
-};
-
-#define iobufset_resource(rs1) \
-	container_of((rs1), struct iobufset_resource, rs)
-
-/*!
- * Allocate iobufset resource.
- *
- * \param vi        VI that "owns" these buffers. Grabs a reference
- *                  on success.
- * \param linked    Uses memory from an existing iobufset.  Grabs a
- *                  reference on success.
- * \param iobrs_out pointer to return the new filter resource
- *
- * \return          status code; if non-zero, frs_out is unchanged
- */
-extern int
-efrm_iobufset_resource_alloc(int32_t n_pages,
-			     int32_t pages_per_contiguous_chunk,
-			     struct vi_resource *vi,
-			     struct iobufset_resource *linked,
-			     bool phys_addr_mode,
-			     struct iobufset_resource **iobrs_out);
-
-extern void efrm_iobufset_resource_free(struct iobufset_resource *);
-extern void efrm_iobufset_resource_release(struct iobufset_resource *);
-
-static inline char *
-efrm_iobufset_ptr(struct iobufset_resource *rs, unsigned offs)
-{
-	EFRM_ASSERT(offs < (unsigned)(rs->n_bufs << PAGE_SHIFT));
-	return efhw_iopage_ptr(&rs->bufs[offs >> PAGE_SHIFT])
-	    + (offs & (PAGE_SIZE - 1));
-}
-
-static inline char *efrm_iobufset_page_ptr(struct iobufset_resource *rs,
-				       unsigned page_i)
-{
-	EFRM_ASSERT(page_i < (unsigned)rs->n_bufs);
-	return efhw_iopage_ptr(&rs->bufs[page_i]);
-}
-
-static inline dma_addr_t
-efrm_iobufset_dma_addr(struct iobufset_resource *rs, unsigned offs)
-{
-	EFRM_ASSERT(offs < (unsigned)(rs->n_bufs << PAGE_SHIFT));
-	return efhw_iopage_dma_addr(&rs->bufs[offs >> PAGE_SHIFT])
-	    + (offs & (PAGE_SIZE - 1));
-}
-
-#endif /* __CI_EFRM_IOBUFSET_H__ */
diff -r 5b3d4d3c1166 drivers/net/sfc/sfc_resource/ci/efrm/nic_set.h
--- a/drivers/net/sfc/sfc_resource/ci/efrm/nic_set.h	Fri Nov 05 15:20:28 2010 +0000
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,104 +0,0 @@
-/****************************************************************************
- * Driver for Solarflare network controllers -
- *          resource management for Xen backend, OpenOnload, etc
- *           (including support for SFE4001 10GBT NIC)
- *
- * This file provides public API for NIC sets.
- *
- * Copyright 2005-2007: Solarflare Communications Inc,
- *                      9501 Jeronimo Road, Suite 250,
- *                      Irvine, CA 92618, USA
- *
- * Developed and maintained by Solarflare Communications:
- *                      <linux-xen-drivers@solarflare.com>
- *                      <onload-dev@solarflare.com>
- *
- * Certain parts of the driver were implemented by
- *          Alexandra Kossovsky <Alexandra.Kossovsky@oktetlabs.ru>
- *          OKTET Labs Ltd, Russia,
- *          http://oktetlabs.ru, <info@oktetlabs.ru>
- *          by request of Solarflare Communications
- *
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 as published
- * by the Free Software Foundation, incorporated herein by reference.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
- ****************************************************************************
- */
-
-#ifndef __CI_EFRM_NIC_SET_H__
-#define __CI_EFRM_NIC_SET_H__
-
-#include <ci/efrm/debug.h>
-#include <ci/efhw/common_sysdep.h>
-#include <ci/efhw/efhw_config.h>
-
-/*--------------------------------------------------------------------
- *
- * efrm_nic_set_t - tracks which NICs something has been done on
- *
- *--------------------------------------------------------------------*/
-
-/* Internal suructure of efrm_nic_set_t should not be referenced outside of
- * this file.  Add a new accessor if you should do it. */
-typedef struct {
-	uint32_t nics;
-} efrm_nic_set_t;
-
-#if EFHW_MAX_NR_DEVS > 32
-#error change efrm_nic_set to handle EFHW_MAX_NR_DEVS number of devices
-#endif
-
-static inline bool
-efrm_nic_set_read(const efrm_nic_set_t *nic_set, unsigned index)
-{
-	EFRM_ASSERT(nic_set);
-	EFRM_ASSERT(index < EFHW_MAX_NR_DEVS && index < 32);
-	return (nic_set->nics & (1 << index)) ? true : false;
-}
-
-static inline void
-efrm_nic_set_write(efrm_nic_set_t *nic_set, unsigned index, bool value)
-{
-	EFRM_ASSERT(nic_set);
-	EFRM_ASSERT(index < EFHW_MAX_NR_DEVS && index < 32);
-	EFRM_ASSERT(value == false || value == true);
-	nic_set->nics = (nic_set->nics & (~(1 << index))) + (value << index);
-}
-
-static inline void efrm_nic_set_clear(efrm_nic_set_t *nic_set)
-{
-	nic_set->nics = 0;
-}
-
-static inline void efrm_nic_set_all(efrm_nic_set_t *nic_set)
-{
-	nic_set->nics = 0xffffffff;
-}
-
-static inline bool efrm_nic_set_is_all_clear(efrm_nic_set_t *nic_set)
-{
-	return nic_set->nics == 0 ? true : false;
-}
-
-#define EFRM_NIC_SET_FMT "%x"
-
-static inline uint32_t efrm_nic_set_pri_arg(efrm_nic_set_t *nic_set)
-{
-	return nic_set->nics;
-}
-
-#define EFRM_FOR_EACH_NIC_INDEX_IN_SET(_set, _nic_i)			\
-	for ((_nic_i) = 0; (_nic_i) < EFHW_MAX_NR_DEVS; ++(_nic_i))	\
-		if (efrm_nic_set_read((_set), (_nic_i)))
-
-#endif /* __CI_EFRM_NIC_SET_H__ */
diff -r 5b3d4d3c1166 drivers/net/sfc/sfc_resource/ci/efrm/nic_table.h
--- a/drivers/net/sfc/sfc_resource/ci/efrm/nic_table.h	Fri Nov 05 15:20:28 2010 +0000
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,98 +0,0 @@
-/****************************************************************************
- * Driver for Solarflare network controllers -
- *          resource management for Xen backend, OpenOnload, etc
- *           (including support for SFE4001 10GBT NIC)
- *
- * This file provides public API for NIC table.
- *
- * Copyright 2005-2007: Solarflare Communications Inc,
- *                      9501 Jeronimo Road, Suite 250,
- *                      Irvine, CA 92618, USA
- *
- * Developed and maintained by Solarflare Communications:
- *                      <linux-xen-drivers@solarflare.com>
- *                      <onload-dev@solarflare.com>
- *
- * Certain parts of the driver were implemented by
- *          Alexandra Kossovsky <Alexandra.Kossovsky@oktetlabs.ru>
- *          OKTET Labs Ltd, Russia,
- *          http://oktetlabs.ru, <info@oktetlabs.ru>
- *          by request of Solarflare Communications
- *
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 as published
- * by the Free Software Foundation, incorporated herein by reference.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
- ****************************************************************************
- */
-
-#ifndef __CI_EFRM_NIC_TABLE_H__
-#define __CI_EFRM_NIC_TABLE_H__
-
-#include <ci/efhw/efhw_types.h>
-#include <ci/efrm/sysdep.h>
-
-/*--------------------------------------------------------------------
- *
- * struct efrm_nic_table - top level driver object keeping all NICs -
- * implemented in driver_object.c
- *
- *--------------------------------------------------------------------*/
-
-/*! Comment? */
-struct efrm_nic_table {
-	/*! nics attached to this driver */
-	struct efhw_nic *nic[EFHW_MAX_NR_DEVS];
-	/*! pointer to an arbitrary struct efhw_nic if one exists;
-	 * for code which does not care which NIC it wants but
-	 * still needs one. Note you cannot assume nic[0] exists. */
-	struct efhw_nic *a_nic;
-	uint32_t nic_count;	/*!< number of nics attached to this driver */
-	spinlock_t lock;	/*!< lock for table modifications */
-	atomic_t ref_count;	/*!< refcount for users of nic table */
-};
-
-/* Resource driver structures used by other drivers as well */
-extern struct efrm_nic_table *efrm_nic_tablep;
-
-static inline void efrm_nic_table_hold(void)
-{
-	atomic_inc(&efrm_nic_tablep->ref_count);
-}
-
-static inline void efrm_nic_table_rele(void)
-{
-	atomic_dec(&efrm_nic_tablep->ref_count);
-}
-
-static inline int efrm_nic_table_held(void)
-{
-	return atomic_read(&efrm_nic_tablep->ref_count) != 0;
-}
-
-/* Run code block _x multiple times with variable nic set to each
- * registered NIC in turn.
- * DO NOT "break" out of this loop early. */
-#define EFRM_FOR_EACH_NIC(_nic_i, _nic)					\
-	for ((_nic_i) = (efrm_nic_table_hold(), 0);			\
-	     (_nic_i) < EFHW_MAX_NR_DEVS || (efrm_nic_table_rele(), 0);	\
-	     (_nic_i)++)						\
-		if (((_nic) = efrm_nic_tablep->nic[_nic_i]))
-
-#define EFRM_FOR_EACH_NIC_IN_SET(_set, _i, _nic)			\
-	for ((_i) = (efrm_nic_table_hold(), 0);				\
-	     (_i) < EFHW_MAX_NR_DEVS || (efrm_nic_table_rele(), 0);	\
-	     ++(_i))							\
-		if (((_nic) = efrm_nic_tablep->nic[_i]) &&		\
-		    efrm_nic_set_read((_set), (_i)))
-
-#endif /* __CI_EFRM_NIC_TABLE_H__ */
diff -r 5b3d4d3c1166 drivers/net/sfc/sfc_resource/ci/efrm/private.h
--- a/drivers/net/sfc/sfc_resource/ci/efrm/private.h	Fri Nov 05 15:20:28 2010 +0000
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,118 +0,0 @@
-/****************************************************************************
- * Driver for Solarflare network controllers -
- *          resource management for Xen backend, OpenOnload, etc
- *           (including support for SFE4001 10GBT NIC)
- *
- * This file provides private API of efrm library -- resource handling.
- * This API is not designed for use outside of SFC resource driver.
- *
- * Copyright 2005-2007: Solarflare Communications Inc,
- *                      9501 Jeronimo Road, Suite 250,
- *                      Irvine, CA 92618, USA
- *
- * Developed and maintained by Solarflare Communications:
- *                      <linux-xen-drivers@solarflare.com>
- *                      <onload-dev@solarflare.com>
- *
- * Certain parts of the driver were implemented by
- *          Alexandra Kossovsky <Alexandra.Kossovsky@oktetlabs.ru>
- *          OKTET Labs Ltd, Russia,
- *          http://oktetlabs.ru, <info@oktetlabs.ru>
- *          by request of Solarflare Communications
- *
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 as published
- * by the Free Software Foundation, incorporated herein by reference.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
- ****************************************************************************
- */
-
-#ifndef __CI_EFRM_PRIVATE_H__
-#define __CI_EFRM_PRIVATE_H__
-
-#include <ci/efrm/resource.h>
-#include <ci/efrm/driver_private.h>
-#include <ci/efrm/sysdep.h>
-#include <ci/efrm/debug.h>
-
-/*--------------------------------------------------------------------
- *
- * create resource managers
- *
- *--------------------------------------------------------------------*/
-
-/*! Create a resource manager for various types of resources
- */
-extern int
-efrm_create_iobufset_resource_manager(struct efrm_resource_manager **out);
-
-extern int
-efrm_create_filter_resource_manager(struct efrm_resource_manager **out);
-
-extern int
-efrm_create_vi_resource_manager(struct efrm_resource_manager **out,
-				const struct vi_resource_dimensions *);
-
-
-/*--------------------------------------------------------------------
- *
- * Instance pool management
- *
- *--------------------------------------------------------------------*/
-
-/*! Allocate instance pool. Use kfifo_vfree to destroy it. */
-static inline int
-efrm_kfifo_id_ctor(struct kfifo **ids_out,
-		   unsigned int base, unsigned int limit, spinlock_t *lock)
-{
-	unsigned int i;
-	struct kfifo *ids;
-	unsigned char *buffer;
-	unsigned int size = roundup_pow_of_two((limit - base) * sizeof(int));
-	EFRM_ASSERT(base <= limit);
-	buffer = vmalloc(size);
-	ids = kfifo_init(buffer, size, GFP_KERNEL, lock);
-	if (IS_ERR(ids))
-		return PTR_ERR(ids);
-	for (i = base; i < limit; i++)
-		EFRM_VERIFY_EQ(__kfifo_put(ids, (unsigned char *)&i,
-					   sizeof(i)), sizeof(i));
-
-	*ids_out = ids;
-	return 0;
-}
-
-/*--------------------------------------------------------------------
- *
- * Various private functions
- *
- *--------------------------------------------------------------------*/
-
-/*! Initialize the fields in the provided resource manager memory area
- *   \param rm         The area of memory to be initialized
- *   \param dtor       A method to destroy the resource manager
- *   \param name       A Textual name for the resource manager
- *   \param type       The type of resource managed
- *   \param initial_table_size Initial size of the ID table
- *   \param auto_destroy Destroy resource manager on driver onload iff true
- *
- * A default table size is provided if the value 0 is provided.
- */
-extern int
-efrm_resource_manager_ctor(struct efrm_resource_manager *rm,
-			   void (*dtor)(struct efrm_resource_manager *),
-			   const char *name, unsigned type);
-
-extern void efrm_resource_manager_dtor(struct efrm_resource_manager *rm);
-
-
-#endif /* __CI_EFRM_PRIVATE_H__ */
diff -r 5b3d4d3c1166 drivers/net/sfc/sfc_resource/ci/efrm/resource.h
--- a/drivers/net/sfc/sfc_resource/ci/efrm/resource.h	Fri Nov 05 15:20:28 2010 +0000
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,119 +0,0 @@
-/****************************************************************************
- * Driver for Solarflare network controllers -
- *          resource management for Xen backend, OpenOnload, etc
- *           (including support for SFE4001 10GBT NIC)
- *
- * This file provides public interface of efrm library -- resource handling.
- *
- * Copyright 2005-2007: Solarflare Communications Inc,
- *                      9501 Jeronimo Road, Suite 250,
- *                      Irvine, CA 92618, USA
- *
- * Developed and maintained by Solarflare Communications:
- *                      <linux-xen-drivers@solarflare.com>
- *                      <onload-dev@solarflare.com>
- *
- * Certain parts of the driver were implemented by
- *          Alexandra Kossovsky <Alexandra.Kossovsky@oktetlabs.ru>
- *          OKTET Labs Ltd, Russia,
- *          http://oktetlabs.ru, <info@oktetlabs.ru>
- *          by request of Solarflare Communications
- *
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 as published
- * by the Free Software Foundation, incorporated herein by reference.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
- ****************************************************************************
- */
-
-#ifndef __CI_EFRM_RESOURCE_H__
-#define __CI_EFRM_RESOURCE_H__
-
-/*--------------------------------------------------------------------
- *
- * headers for type dependencies
- *
- *--------------------------------------------------------------------*/
-
-#include <ci/efhw/efhw_types.h>
-#include <ci/efrm/resource_id.h>
-#include <ci/efrm/sysdep.h>
-#include <ci/efhw/common_sysdep.h>
-
-#ifndef __ci_driver__
-#error "Driver-only file"
-#endif
-
-/*--------------------------------------------------------------------
- *
- * struct efrm_resource - represents an allocated resource
- *                   (eg. pinned pages of memory, or resource on a NIC)
- *
- *--------------------------------------------------------------------*/
-
-/*! Representation of an allocated resource */
-struct efrm_resource {
-	int rs_ref_count;
-	efrm_resource_handle_t rs_handle;
-	struct efrm_client *rs_client;
-	struct list_head rs_client_link;
-	struct list_head rs_manager_link;
-};
-
-/*--------------------------------------------------------------------
- *
- * managed resource abstraction
- *
- *--------------------------------------------------------------------*/
-
-/*! Factory for resources of a specific type */
-struct efrm_resource_manager {
-	const char *rm_name;	/*!< human readable only */
-	spinlock_t rm_lock;
-#ifndef NDEBUG
-	unsigned rm_type;
-#endif
-	int rm_resources;
-	int rm_resources_hiwat;
-	struct list_head rm_resources_list;
-	/**
-	 * Destructor for the resource manager. Other resource managers
-	 * might be already dead, although the system guarantees that
-	 * managers are destructed in the order by which they were created
-	 */
-	void (*rm_dtor)(struct efrm_resource_manager *);
-};
-
-#ifdef NDEBUG
-# define EFRM_RESOURCE_ASSERT_VALID(rs, rc_mbz)
-# define EFRM_RESOURCE_MANAGER_ASSERT_VALID(rm)
-#else
-/*! Check validity of resource and report on failure */
-extern void efrm_resource_assert_valid(struct efrm_resource *,
-				       int rc_may_be_zero,
-				       const char *file, int line);
-# define EFRM_RESOURCE_ASSERT_VALID(rs, rc_mbz) \
-	efrm_resource_assert_valid((rs), (rc_mbz), __FILE__, __LINE__)
-
-/*! Check validity of resource manager and report on failure */
-extern void efrm_resource_manager_assert_valid(struct efrm_resource_manager *,
-					       const char *file, int line);
-# define EFRM_RESOURCE_MANAGER_ASSERT_VALID(rm) \
-	efrm_resource_manager_assert_valid((rm), __FILE__, __LINE__)
-#endif
-
-
-extern void efrm_resource_ref(struct efrm_resource *rs);
-extern int  __efrm_resource_release(struct efrm_resource *);
-
-
-#endif /* __CI_EFRM_RESOURCE_H__ */
diff -r 5b3d4d3c1166 drivers/net/sfc/sfc_resource/ci/efrm/resource_id.h
--- a/drivers/net/sfc/sfc_resource/ci/efrm/resource_id.h	Fri Nov 05 15:20:28 2010 +0000
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,104 +0,0 @@
-/****************************************************************************
- * Driver for Solarflare network controllers -
- *          resource management for Xen backend, OpenOnload, etc
- *           (including support for SFE4001 10GBT NIC)
- *
- * This file provides public type and definitions resource handle, and the
- * definitions of resource types.
- *
- * Copyright 2005-2007: Solarflare Communications Inc,
- *                      9501 Jeronimo Road, Suite 250,
- *                      Irvine, CA 92618, USA
- *
- * Developed and maintained by Solarflare Communications:
- *                      <linux-xen-drivers@solarflare.com>
- *                      <onload-dev@solarflare.com>
- *
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 as published
- * by the Free Software Foundation, incorporated herein by reference.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
- ****************************************************************************
- */
-
-#ifndef __CI_DRIVER_EFRM_RESOURCE_ID_H__
-#define __CI_DRIVER_EFRM_RESOURCE_ID_H__
-
-/***********************************************************************
- * Resource handles
- *
- * Resource handles are intended for identifying resources at kernel
- * level, within the context of a particular NIC. particularly because
- * for some resource types, the low 16 bites correspond to hardware
- * IDs. They were historically also used at user level, with a nonce
- * stored in the bits 16 to 27 (inclusive), but that approach is
- * deprecated (but sill alive!).
- *
- * The handle value 0 is used to mean "no resource".
- * Identify resources within the context of a file descriptor at user
- * level.
- ***********************************************************************/
-
-typedef struct {
-	uint32_t handle;
-} efrm_resource_handle_t;
-
-/* You may think these following functions should all have
- * _HANDLE_ in their names, but really we are providing an abstract set
- * of methods on a (hypothetical) efrm_resource_t object, with
- * efrm_resource_handle_t being just the reference one holds to access
- * the object (aka "this" or "self").
- */
-
-/* Below I use inline instead of macros where possible in order to get
- * more type checking help from the compiler; hopefully we'll never
- * have to rewrite these to use #define as we've found some horrible
- * compiler on which we cannot make static inline do the Right Thing (tm).
- *
- * For consistency and to avoid pointless change I spell these
- * routines as macro names (CAPTILIZE_UNDERSCORED), which also serves
- * to remind people they are compact and inlined.
- */
-
-#define EFRM_RESOURCE_FMT  "[rs:%08x]"
-
-static inline unsigned EFRM_RESOURCE_PRI_ARG(efrm_resource_handle_t h)
-{
-	return h.handle;
-}
-
-static inline unsigned EFRM_RESOURCE_INSTANCE(efrm_resource_handle_t h)
-{
-	return h.handle & 0x0000ffff;
-}
-
-static inline unsigned EFRM_RESOURCE_TYPE(efrm_resource_handle_t h)
-{
-	return (h.handle & 0xf0000000) >> 28;
-}
-
-/***********************************************************************
- * Resource type codes
- ***********************************************************************/
-
-#define EFRM_RESOURCE_IOBUFSET          0x0
-#define EFRM_RESOURCE_VI                0x1
-#define EFRM_RESOURCE_FILTER            0x2
-#define EFRM_RESOURCE_NUM               0x3	/* This isn't a resource! */
-
-#define	EFRM_RESOURCE_NAME(type) \
-	((type) == EFRM_RESOURCE_IOBUFSET?	"IOBUFSET"	: \
-	 (type) == EFRM_RESOURCE_VI?		"VI"		: \
-	 (type) == EFRM_RESOURCE_FILTER?	"FILTER"	: \
-						"<invalid>")
-
-#endif /* __CI_DRIVER_EFRM_RESOURCE_ID_H__ */
diff -r 5b3d4d3c1166 drivers/net/sfc/sfc_resource/ci/efrm/sysdep.h
--- a/drivers/net/sfc/sfc_resource/ci/efrm/sysdep.h	Fri Nov 05 15:20:28 2010 +0000
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,46 +0,0 @@
-/****************************************************************************
- * Driver for Solarflare network controllers -
- *          resource management for Xen backend, OpenOnload, etc
- *           (including support for SFE4001 10GBT NIC)
- *
- * This file provides Linux-like system-independent API for efrm library.
- *
- * Copyright 2005-2007: Solarflare Communications Inc,
- *                      9501 Jeronimo Road, Suite 250,
- *                      Irvine, CA 92618, USA
- *
- * Developed and maintained by Solarflare Communications:
- *                      <linux-xen-drivers@solarflare.com>
- *                      <onload-dev@solarflare.com>
- *
- * Certain parts of the driver were implemented by
- *          Alexandra Kossovsky <Alexandra.Kossovsky@oktetlabs.ru>
- *          OKTET Labs Ltd, Russia,
- *          http://oktetlabs.ru, <info@oktetlabs.ru>
- *          by request of Solarflare Communications
- *
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 as published
- * by the Free Software Foundation, incorporated herein by reference.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
- ****************************************************************************
- */
-
-#ifndef __CI_EFRM_SYSDEP_H__
-#define __CI_EFRM_SYSDEP_H__
-
-/* Spinlocks are defined in efhw/sysdep.h */
-#include <ci/efhw/sysdep.h>
-
-#include <ci/efrm/sysdep_linux.h>
-
-#endif /* __CI_EFRM_SYSDEP_H__ */
diff -r 5b3d4d3c1166 drivers/net/sfc/sfc_resource/ci/efrm/sysdep_linux.h
--- a/drivers/net/sfc/sfc_resource/ci/efrm/sysdep_linux.h	Fri Nov 05 15:20:28 2010 +0000
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,93 +0,0 @@
-/****************************************************************************
- * Driver for Solarflare network controllers -
- *          resource management for Xen backend, OpenOnload, etc
- *           (including support for SFE4001 10GBT NIC)
- *
- * This file provides version-independent Linux kernel API for efrm library.
- * Only kernels >=2.6.9 are supported.
- *
- * Copyright 2005-2007: Solarflare Communications Inc,
- *                      9501 Jeronimo Road, Suite 250,
- *                      Irvine, CA 92618, USA
- *
- * Kfifo API is partially stolen from linux-2.6.22/include/linux/list.h
- * Copyright (C) 2004 Stelian Pop <stelian@popies.net>
- *
- * Developed and maintained by Solarflare Communications:
- *                      <linux-xen-drivers@solarflare.com>
- *                      <onload-dev@solarflare.com>
- *
- * Certain parts of the driver were implemented by
- *          Alexandra Kossovsky <Alexandra.Kossovsky@oktetlabs.ru>
- *          OKTET Labs Ltd, Russia,
- *          http://oktetlabs.ru, <info@oktetlabs.ru>
- *          by request of Solarflare Communications
- *
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 as published
- * by the Free Software Foundation, incorporated herein by reference.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
- ****************************************************************************
- */
-
-#ifndef __CI_EFRM_SYSDEP_LINUX_H__
-#define __CI_EFRM_SYSDEP_LINUX_H__
-
-#include <linux/list.h>
-#include <linux/vmalloc.h>
-#include <linux/errno.h>
-#include <linux/string.h>
-#include <linux/workqueue.h>
-#include <linux/gfp.h>
-#include <linux/slab.h>
-#include <linux/hardirq.h>
-#include <linux/kernel.h>
-#include <linux/if_ether.h>
-#include <linux/completion.h>
-#include <linux/in.h>
-#include <linux/log2.h>
-#include <linux/kfifo.h>
-
-
-/********************************************************************
- *
- * List API
- *
- ********************************************************************/
-
-static inline struct list_head *list_pop(struct list_head *list)
-{
-	struct list_head *link = list->next;
-	list_del(link);
-	return link;
-}
-
-static inline struct list_head *list_pop_tail(struct list_head *list)
-{
-	struct list_head *link = list->prev;
-	list_del(link);
-	return link;
-}
-
-/********************************************************************
- *
- * Kfifo API
- *
- ********************************************************************/
-
-static inline void kfifo_vfree(struct kfifo *fifo)
-{
-	vfree(fifo->buffer);
-	kfree(fifo);
-}
-
-#endif /* __CI_EFRM_SYSDEP_LINUX_H__ */
diff -r 5b3d4d3c1166 drivers/net/sfc/sfc_resource/ci/efrm/vi_resource.h
--- a/drivers/net/sfc/sfc_resource/ci/efrm/vi_resource.h	Fri Nov 05 15:20:28 2010 +0000
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,157 +0,0 @@
-/****************************************************************************
- * Driver for Solarflare network controllers -
- *          resource management for Xen backend, OpenOnload, etc
- *           (including support for SFE4001 10GBT NIC)
- *
- * This file contains public API for VI resource.
- *
- * Copyright 2005-2007: Solarflare Communications Inc,
- *                      9501 Jeronimo Road, Suite 250,
- *                      Irvine, CA 92618, USA
- *
- * Developed and maintained by Solarflare Communications:
- *                      <linux-xen-drivers@solarflare.com>
- *                      <onload-dev@solarflare.com>
- *
- * Certain parts of the driver were implemented by
- *          Alexandra Kossovsky <Alexandra.Kossovsky@oktetlabs.ru>
- *          OKTET Labs Ltd, Russia,
- *          http://oktetlabs.ru, <info@oktetlabs.ru>
- *          by request of Solarflare Communications
- *
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 as published
- * by the Free Software Foundation, incorporated herein by reference.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
- ****************************************************************************
- */
-
-#ifndef __CI_EFRM_VI_RESOURCE_H__
-#define __CI_EFRM_VI_RESOURCE_H__
-
-#include <ci/efhw/efhw_types.h>
-#include <ci/efrm/resource.h>
-#include <ci/efrm/debug.h>
-
-struct vi_resource;
-
-/* Make these inline instead of macros for type checking */
-static inline struct vi_resource *
-efrm_to_vi_resource(struct efrm_resource *rs)
-{
-	EFRM_ASSERT(EFRM_RESOURCE_TYPE(rs->rs_handle) == EFRM_RESOURCE_VI);
-	return (struct vi_resource *) rs;
-}
-static inline struct
-efrm_resource *efrm_from_vi_resource(struct vi_resource *rs)
-{
-	return (struct efrm_resource *)rs;
-}
-
-#define EFAB_VI_RESOURCE_INSTANCE(virs) \
-    EFRM_RESOURCE_INSTANCE(efrm_from_vi_resource(virs)->rs_handle)
-
-#define EFAB_VI_RESOURCE_PRI_ARG(virs) \
-    EFRM_RESOURCE_PRI_ARG(efrm_from_vi_resource(virs)->rs_handle)
-
-extern int
-efrm_vi_resource_alloc(struct efrm_client *client,
-		       struct vi_resource *evq_virs,
-		       uint16_t vi_flags, int32_t evq_capacity,
-		       int32_t txq_capacity, int32_t rxq_capacity,
-		       uint8_t tx_q_tag, uint8_t rx_q_tag,
-		       struct vi_resource **virs_in_out,
-		       uint32_t *out_io_mmap_bytes,
-		       uint32_t *out_mem_mmap_bytes,
-		       uint32_t *out_txq_capacity,
-		       uint32_t *out_rxq_capacity);
-
-extern void efrm_vi_resource_free(struct vi_resource *);
-extern void efrm_vi_resource_release(struct vi_resource *);
-
-
-/*--------------------------------------------------------------------
- *
- * eventq handling
- *
- *--------------------------------------------------------------------*/
-
-/*! Reset an event queue and clear any associated timers */
-extern void efrm_eventq_reset(struct vi_resource *virs);
-
-/*! Register a kernel-level handler for the event queue.  This function is
- * called whenever a timer expires, or whenever the event queue is woken
- * but no thread is blocked on it.
- *
- * This function returns -EBUSY if a callback is already installed.
- *
- * \param rs      Event-queue resource
- * \param handler Callback-handler
- * \param arg     Argument to pass to callback-handler
- * \return        Status code
- */
-extern int
-efrm_eventq_register_callback(struct vi_resource *rs,
-			      void (*handler)(void *arg, int is_timeout,
-					      struct efhw_nic *nic),
-			      void *arg);
-
-/*! Kill the kernel-level callback.
- *
- * This function stops the timer from running and unregisters the callback
- * function.  It waits for any running timeout handlers to complete before
- * returning.
- *
- * \param rs      Event-queue resource
- * \return        Nothing
- */
-extern void efrm_eventq_kill_callback(struct vi_resource *rs);
-
-/*! Ask the NIC to generate a wakeup when an event is next delivered. */
-extern void efrm_eventq_request_wakeup(struct vi_resource *rs,
-				       unsigned current_ptr);
-
-/*! Register a kernel-level handler for flush completions.
- * \TODO Currently, it is unsafe to install a callback more than once.
- *
- * \param rs      VI resource being flushed.
- * \param handler Callback handler function.
- * \param arg     Argument to be passed to handler.
- */
-extern void
-efrm_vi_register_flush_callback(struct vi_resource *rs,
-				void (*handler)(void *),
-				void *arg);
-
-int efrm_vi_resource_flush_retry(struct vi_resource *virs);
-
-/*! Comment? */
-extern int efrm_pt_flush(struct vi_resource *);
-
-/*! Comment? */
-extern int efrm_pt_pace(struct vi_resource *, unsigned int val);
-
-uint32_t efrm_vi_rm_txq_bytes(struct vi_resource *virs
-			      /*,struct efhw_nic *nic */);
-uint32_t efrm_vi_rm_rxq_bytes(struct vi_resource *virs
-			      /*,struct efhw_nic *nic */);
-uint32_t efrm_vi_rm_evq_bytes(struct vi_resource *virs
-			      /*,struct efhw_nic *nic */);
-
-
-/* Fill [out_vi_data] with information required to allow a VI to be init'd.
- * [out_vi_data] must ref at least VI_MAPPINGS_SIZE bytes.
- */
-extern void efrm_vi_resource_mappings(struct vi_resource *, void *out_vi_data);
-
-
-#endif /* __CI_EFRM_VI_RESOURCE_H__ */
diff -r 5b3d4d3c1166 drivers/net/sfc/sfc_resource/ci/efrm/vi_resource_manager.h
--- a/drivers/net/sfc/sfc_resource/ci/efrm/vi_resource_manager.h	Fri Nov 05 15:20:28 2010 +0000
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,155 +0,0 @@
-/****************************************************************************
- * Driver for Solarflare network controllers -
- *          resource management for Xen backend, OpenOnload, etc
- *           (including support for SFE4001 10GBT NIC)
- *
- * This file contains type definitions for VI resource.  These types
- * may be used outside of the SFC resource driver, but such use is not
- * recommended.
- *
- * Copyright 2005-2007: Solarflare Communications Inc,
- *                      9501 Jeronimo Road, Suite 250,
- *                      Irvine, CA 92618, USA
- *
- * Developed and maintained by Solarflare Communications:
- *                      <linux-xen-drivers@solarflare.com>
- *                      <onload-dev@solarflare.com>
- *
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 as published
- * by the Free Software Foundation, incorporated herein by reference.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
- ****************************************************************************
- */
-
-#ifndef __CI_DRIVER_EFAB_VI_RESOURCE_MANAGER_H__
-#define __CI_DRIVER_EFAB_VI_RESOURCE_MANAGER_H__
-
-#include <ci/efhw/common.h>
-#include <ci/efrm/vi_resource.h>
-
-
-#define EFRM_VI_RM_DMA_QUEUE_COUNT 2
-#define EFRM_VI_RM_DMA_QUEUE_TX    0
-#define EFRM_VI_RM_DMA_QUEUE_RX    1
-
-/** Numbers of bits which can be set in the evq_state member of
- * vi_resource_evq_info. */
-enum {
-  /** This bit is set if a wakeup has been requested on the NIC. */
-	VI_RESOURCE_EVQ_STATE_WAKEUP_PENDING,
-  /** This bit is set if the wakeup is valid for the sleeping
-   * process. */
-	VI_RESOURCE_EVQ_STATE_CALLBACK_REGISTERED,
-  /** This bit is set if a wakeup or timeout event is currently being
-   * processed. */
-	VI_RESOURCE_EVQ_STATE_BUSY,
-};
-#define VI_RESOURCE_EVQ_STATE(X) \
-	(((int32_t)1) << (VI_RESOURCE_EVQ_STATE_##X))
-
-
-/*! Global information for the VI resource manager. */
-struct vi_resource_manager {
-	struct efrm_resource_manager rm;
-
-	struct kfifo *instances_with_timer;
-	int with_timer_base;
-	int with_timer_limit;
-	struct kfifo *instances_with_interrupt;
-	int with_interrupt_base;
-	int with_interrupt_limit;
-
-	bool iscsi_dmaq_instance_is_free;
-
-	/* We keep VI resources which need flushing on these lists.  The VI
-	 * is put on the outstanding list when the flush request is issued
-	 * to the hardware and removed when the flush event arrives.  The
-	 * hardware can only handle a limited number of RX flush requests at
-	 * once, so VIs are placed in the waiting list until the flush can
-	 * be issued.  Flushes can be requested by the client or internally
-	 * by the VI resource manager.  In the former case, the reference
-	 * count must be non-zero for the duration of the flush and in the
-	 * later case, the reference count must be zero. */
-	struct list_head rx_flush_waiting_list;
-	struct list_head rx_flush_outstanding_list;
-	struct list_head tx_flush_outstanding_list;
-	int rx_flush_outstanding_count;
-
-	/* once the flush has happened we push the close into the work queue
-	 * so its OK on Windows to free the resources (Bug 3469).  Resources
-	 * on this list have zero reference count.
-	 */
-	struct list_head close_pending;
-	struct work_struct work_item;
-	struct workqueue_struct *workqueue;
-};
-
-struct vi_resource_nic_info {
-	struct eventq_resource_hardware evq_pages;
-	struct efhw_iopages dmaq_pages[EFRM_VI_RM_DMA_QUEUE_COUNT];
-};
-
-struct vi_resource {
-	/* Some macros make the assumption that the struct efrm_resource is
-	 * the first member of a struct vi_resource. */
-	struct efrm_resource rs;
-	atomic_t evq_refs;	/*!< Number of users of the event queue. */
-
-	uint32_t bar_mmap_bytes;
-	uint32_t mem_mmap_bytes;
-
-	int32_t evq_capacity;
-	int32_t dmaq_capacity[EFRM_VI_RM_DMA_QUEUE_COUNT];
-
-	uint8_t dmaq_tag[EFRM_VI_RM_DMA_QUEUE_COUNT];
-	uint16_t flags;
-
-	/* we keep PT endpoints that have been destroyed on a list
-	 * until we have seen their TX and RX DMAQs flush complete
-	 * (see Bug 1217)
-	 */
-	struct list_head rx_flush_link;
-	struct list_head tx_flush_link;
-	int rx_flushing;
-	int rx_flush_outstanding;
-	int tx_flushing;
-	uint64_t flush_time;
-	int flush_count;
-
-	void (*flush_callback_fn)(void *);
-	void *flush_callback_arg;
-
-	void (*evq_callback_fn) (void *arg, int is_timeout,
-				 struct efhw_nic *nic);
-	void *evq_callback_arg;
-
-	struct vi_resource *evq_virs;	/*!< EVQ for DMA queues */
-
-	 struct efhw_buffer_table_allocation
-	    dmaq_buf_tbl_alloc[EFRM_VI_RM_DMA_QUEUE_COUNT];
-
-	struct vi_resource_nic_info nic_info;
-};
-
-#undef vi_resource
-#define vi_resource(rs1)  container_of((rs1), struct vi_resource, rs)
-
-static inline dma_addr_t
-efrm_eventq_dma_addr(struct vi_resource *virs)
-{
-	struct eventq_resource_hardware *hw;
-	hw = &virs->nic_info.evq_pages;
-	return efhw_iopages_dma_addr(&hw->iobuff) + hw->iobuff_off;
-}
-
-#endif /* __CI_DRIVER_EFAB_VI_RESOURCE_MANAGER_H__ */
diff -r 5b3d4d3c1166 drivers/net/sfc/sfc_resource/ci/efrm/vi_resource_private.h
--- a/drivers/net/sfc/sfc_resource/ci/efrm/vi_resource_private.h	Fri Nov 05 15:20:28 2010 +0000
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,65 +0,0 @@
-/****************************************************************************
- * Driver for Solarflare network controllers -
- *          resource management for Xen backend, OpenOnload, etc
- *           (including support for SFE4001 10GBT NIC)
- *
- * This file contains private API for VI resource.  The API is not designed
- * to be used outside of the SFC resource driver.
- *
- * Copyright 2005-2007: Solarflare Communications Inc,
- *                      9501 Jeronimo Road, Suite 250,
- *                      Irvine, CA 92618, USA
- *
- * Developed and maintained by Solarflare Communications:
- *                      <linux-xen-drivers@solarflare.com>
- *                      <onload-dev@solarflare.com>
- *
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 as published
- * by the Free Software Foundation, incorporated herein by reference.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
- ****************************************************************************
- */
-
-#ifndef __CI_EFRM_VI_RESOURCE_PRIVATE_H__
-#define __CI_EFRM_VI_RESOURCE_PRIVATE_H__
-
-#include <ci/efhw/common.h>
-#include <ci/efrm/vi_resource_manager.h>
-
-extern struct vi_resource_manager *efrm_vi_manager;
-
-/*************************************************************************/
-
-extern void efrm_vi_rm_delayed_free(struct work_struct *data);
-
-extern void efrm_vi_rm_salvage_flushed_vis(void);
-
-void efrm_vi_rm_free_flushed_resource(struct vi_resource *virs);
-
-void efrm_vi_rm_init_dmaq(struct vi_resource *virs, int queue_index,
-			  struct efhw_nic *nic);
-
-/*! Wakeup handler */
-extern void efrm_handle_wakeup_event(struct efhw_nic *nic, unsigned id);
-
-/*! Timeout handler */
-extern void efrm_handle_timeout_event(struct efhw_nic *nic, unsigned id);
-
-/*! DMA flush handler */
-extern void efrm_handle_dmaq_flushed(struct efhw_nic *nic, unsigned id,
-				   int rx_flush);
-
-/*! SRAM update handler */
-extern void efrm_handle_sram_event(struct efhw_nic *nic);
-
-#endif /* __CI_EFRM_VI_RESOURCE_PRIVATE_H__ */
diff -r 5b3d4d3c1166 drivers/net/sfc/sfc_resource/driver_object.c
--- a/drivers/net/sfc/sfc_resource/driver_object.c	Fri Nov 05 15:20:28 2010 +0000
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,328 +0,0 @@
-/****************************************************************************
- * Driver for Solarflare network controllers -
- *          resource management for Xen backend, OpenOnload, etc
- *           (including support for SFE4001 10GBT NIC)
- *
- * This file contains support for the global driver variables.
- *
- * Copyright 2005-2007: Solarflare Communications Inc,
- *                      9501 Jeronimo Road, Suite 250,
- *                      Irvine, CA 92618, USA
- *
- * Developed and maintained by Solarflare Communications:
- *                      <linux-xen-drivers@solarflare.com>
- *                      <onload-dev@solarflare.com>
- *
- * Certain parts of the driver were implemented by
- *          Alexandra Kossovsky <Alexandra.Kossovsky@oktetlabs.ru>
- *          OKTET Labs Ltd, Russia,
- *          http://oktetlabs.ru, <info@oktetlabs.ru>
- *          by request of Solarflare Communications
- *
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 as published
- * by the Free Software Foundation, incorporated herein by reference.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
- ****************************************************************************
- */
-
-#include <ci/efrm/nic_table.h>
-#include <ci/efrm/resource.h>
-#include <ci/efrm/debug.h>
-#include <ci/efrm/efrm_client.h>
-#include <ci/efrm/efrm_nic.h>
-#include "efrm_internal.h"
-
-/* We use #define rather than static inline here so that the Windows
- * "prefast" compiler can see its own locking primitive when these
- * two function are used (and then perform extra checking where they
- * are used)
- *
- * Both macros operate on an irq_flags_t
-*/
-
-#define efrm_driver_lock(irqlock_state) \
-	spin_lock_irqsave(&efrm_nic_tablep->lock, irqlock_state)
-
-#define efrm_driver_unlock(irqlock_state)		\
-	spin_unlock_irqrestore(&efrm_nic_tablep->lock,	\
-			       irqlock_state);
-
-/* These routines are all methods on the architecturally singleton
-   global variables: efrm_nic_table, efrm_rm_table.
-
-   I hope we never find a driver model that does not allow global
-   structure variables :) (but that would break almost every driver I've
-   ever seen).
-*/
-
-/*! Exported driver state */
-static struct efrm_nic_table efrm_nic_table;
-struct efrm_nic_table *efrm_nic_tablep;
-EXPORT_SYMBOL(efrm_nic_tablep);
-
-
-/* Internal table with resource managers.
- * We'd like to not export it, but we are still using efrm_rm_table
- * in the char driver. So, it is declared in the private header with
- * a purpose. */
-struct efrm_resource_manager *efrm_rm_table[EFRM_RESOURCE_NUM];
-EXPORT_SYMBOL(efrm_rm_table);
-
-
-/* List of registered nics. */
-static LIST_HEAD(efrm_nics);
-
-
-void efrm_driver_ctor(void)
-{
-	efrm_nic_tablep = &efrm_nic_table;
-	spin_lock_init(&efrm_nic_tablep->lock);
-	EFRM_TRACE("%s: driver created", __func__);
-}
-
-void efrm_driver_dtor(void)
-{
-	EFRM_ASSERT(!efrm_nic_table_held());
-
-	spin_lock_destroy(&efrm_nic_tablep->lock);
-	memset(&efrm_nic_table, 0, sizeof(efrm_nic_table));
-	memset(&efrm_rm_table, 0, sizeof(efrm_rm_table));
-	EFRM_TRACE("%s: driver deleted", __func__);
-}
-
-int efrm_driver_register_nic(struct efrm_nic *rnic, int nic_index,
-			     int ifindex)
-{
-	struct efhw_nic *nic = &rnic->efhw_nic;
-	struct efrm_nic_per_vi *vis;
-	int max_vis, rc = 0;
-	irq_flags_t lock_flags;
-
-	EFRM_ASSERT(nic_index >= 0);
-	EFRM_ASSERT(ifindex >= 0);
-
-	max_vis = 4096; /* TODO: Get runtime value. */
-	vis = vmalloc(max_vis * sizeof(rnic->vis[0]));
-	if (vis == NULL) {
-		EFRM_ERR("%s: Out of memory", __func__);
-		return -ENOMEM;
-	}
-
-	efrm_driver_lock(lock_flags);
-
-	if (efrm_nic_table_held()) {
-		EFRM_ERR("%s: driver object is in use", __func__);
-		rc = -EBUSY;
-		goto done;
-	}
-
-	if (efrm_nic_tablep->nic_count == EFHW_MAX_NR_DEVS) {
-		EFRM_ERR("%s: filled up NIC table size %d", __func__,
-			 EFHW_MAX_NR_DEVS);
-		rc = -E2BIG;
-		goto done;
-	}
-
-	rnic->vis = vis;
-
-	EFRM_ASSERT(efrm_nic_tablep->nic[nic_index] == NULL);
-	efrm_nic_tablep->nic[nic_index] = nic;
-	nic->index = nic_index;
-	nic->ifindex = ifindex;
-
-	if (efrm_nic_tablep->a_nic == NULL)
-		efrm_nic_tablep->a_nic = nic;
-
-	efrm_nic_tablep->nic_count++;
-
-	INIT_LIST_HEAD(&rnic->clients);
-	list_add(&rnic->link, &efrm_nics);
-
-	efrm_driver_unlock(lock_flags);
-	return 0;
-
-done:
-	efrm_driver_unlock(lock_flags);
-	vfree(vis);
-	return rc;
-}
-
-int efrm_driver_unregister_nic(struct efrm_nic *rnic)
-{
-	struct efhw_nic *nic = &rnic->efhw_nic;
-	int rc = 0;
-	int nic_index = nic->index;
-	irq_flags_t lock_flags;
-
-	EFRM_ASSERT(nic_index >= 0);
-
-	efrm_driver_lock(lock_flags);
-
-	if (efrm_nic_table_held()) {
-		EFRM_ERR("%s: driver object is in use", __func__);
-		rc = -EBUSY;
-		goto done;
-	}
-	if (!list_empty(&rnic->clients)) {
-		EFRM_ERR("%s: nic has active clients", __func__);
-		rc = -EBUSY;
-		goto done;
-	}
-
-	EFRM_ASSERT(efrm_nic_tablep->nic[nic_index] == nic);
-	EFRM_ASSERT(list_empty(&rnic->clients));
-
-	list_del(&rnic->link);
-
-	nic->index = -1;
-	efrm_nic_tablep->nic[nic_index] = NULL;
-
-	--efrm_nic_tablep->nic_count;
-
-	if (efrm_nic_tablep->a_nic == nic) {
-		if (efrm_nic_tablep->nic_count == 0) {
-			efrm_nic_tablep->a_nic = NULL;
-		} else {
-			for (nic_index = 0; nic_index < EFHW_MAX_NR_DEVS;
-			     nic_index++) {
-				if (efrm_nic_tablep->nic[nic_index] != NULL)
-					efrm_nic_tablep->a_nic =
-					    efrm_nic_tablep->nic[nic_index];
-			}
-			EFRM_ASSERT(efrm_nic_tablep->a_nic);
-		}
-	}
-
-done:
-	efrm_driver_unlock(lock_flags);
-	return rc;
-}
-
-
-int efrm_nic_pre_reset(struct efhw_nic *nic)
-{
-	struct efrm_nic *rnic = efrm_nic(nic);
-	struct efrm_client *client;
-	struct efrm_resource *rs;
-	struct list_head *client_link;
-	struct list_head *rs_link;
-	irq_flags_t lock_flags;
-
-	spin_lock_irqsave(&efrm_nic_tablep->lock, lock_flags);
-	list_for_each(client_link, &rnic->clients) {
-		client = container_of(client_link, struct efrm_client, link);
-		EFRM_ERR("%s: client %p", __func__, client);
-		if (client->callbacks->pre_reset)
-			client->callbacks->pre_reset(client, client->user_data);
-		list_for_each(rs_link, &client->resources) {
-			rs = container_of(rs_link, struct efrm_resource,
-					  rs_client_link);
-			EFRM_ERR("%s: resource %p", __func__, rs);
-			/* TODO: mark rs defunct */
-		}
-	}
-	spin_unlock_irqrestore(&efrm_nic_tablep->lock, lock_flags);
-
-	return 0;
-}
-
-
-int efrm_nic_stop(struct efhw_nic *nic)
-{
-	/* TODO */
-	return 0;
-}
-
-
-int efrm_nic_resume(struct efhw_nic *nic)
-{
-	/* TODO */
-	return 0;
-}
-
-
-static void efrm_client_nullcb(struct efrm_client *client, void *user_data)
-{
-}
-
-static struct efrm_client_callbacks efrm_null_callbacks = {
-	efrm_client_nullcb,
-	efrm_client_nullcb,
-	efrm_client_nullcb
-};
-
-
-int efrm_client_get(int ifindex, struct efrm_client_callbacks *callbacks,
-		    void *user_data, struct efrm_client **client_out)
-{
-	struct efrm_nic *n, *rnic = NULL;
-	irq_flags_t lock_flags;
-	struct list_head *link;
-	struct efrm_client *client;
-
-	if (callbacks == NULL)
-		callbacks = &efrm_null_callbacks;
-
-	client = kmalloc(sizeof(*client), GFP_KERNEL);
-	if (client == NULL)
-		return -ENOMEM;
-
-	spin_lock_irqsave(&efrm_nic_tablep->lock, lock_flags);
-	list_for_each(link, &efrm_nics) {
-		n = container_of(link, struct efrm_nic, link);
-		if (n->efhw_nic.ifindex == ifindex || ifindex < 0) {
-			rnic = n;
-			break;
-		}
-	}
-	if (rnic) {
-		client->user_data = user_data;
-		client->callbacks = callbacks;
-		client->nic = &rnic->efhw_nic;
-		client->ref_count = 1;
-		INIT_LIST_HEAD(&client->resources);
-		list_add(&client->link, &rnic->clients);
-	}
-	spin_unlock_irqrestore(&efrm_nic_tablep->lock, lock_flags);
-
-	if (rnic == NULL)
-		return -ENODEV;
-
-	*client_out = client;
-	return 0;
-}
-EXPORT_SYMBOL(efrm_client_get);
-
-
-void efrm_client_put(struct efrm_client *client)
-{
-	irq_flags_t lock_flags;
-
-	EFRM_ASSERT(client->ref_count > 0);
-
-	spin_lock_irqsave(&efrm_nic_tablep->lock, lock_flags);
-	if (--client->ref_count > 0)
-		client = NULL;
-	else
-		list_del(&client->link);
-	spin_unlock_irqrestore(&efrm_nic_tablep->lock, lock_flags);
-	kfree(client);
-}
-EXPORT_SYMBOL(efrm_client_put);
-
-
-struct efhw_nic *efrm_client_get_nic(struct efrm_client *client)
-{
-	return client->nic;
-}
-EXPORT_SYMBOL(efrm_client_get_nic);
diff -r 5b3d4d3c1166 drivers/net/sfc/sfc_resource/driverlink_new.c
--- a/drivers/net/sfc/sfc_resource/driverlink_new.c	Fri Nov 05 15:20:28 2010 +0000
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,260 +0,0 @@
-/****************************************************************************
- * Driver for Solarflare network controllers -
- *          resource management for Xen backend, OpenOnload, etc
- *           (including support for SFE4001 10GBT NIC)
- *
- * This file contains driverlink code which interacts with the sfc network
- * driver.
- *
- * Copyright 2005-2007: Solarflare Communications Inc,
- *                      9501 Jeronimo Road, Suite 250,
- *                      Irvine, CA 92618, USA
- *
- * Developed and maintained by Solarflare Communications:
- *                      <linux-xen-drivers@solarflare.com>
- *                      <onload-dev@solarflare.com>
- *
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 as published
- * by the Free Software Foundation, incorporated herein by reference.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
- ****************************************************************************
- */
-
-#include "linux_resource_internal.h"
-#include "driverlink_api.h"
-#include "kernel_compat.h"
-#include <ci/efhw/falcon.h>
-
-#include <linux/rtnetlink.h>
-#include <linux/netdevice.h>
-#include <net/net_namespace.h>
-
-/* The DL driver and associated calls */
-static int efrm_dl_probe(struct efx_dl_device *efrm_dev,
-			 const struct net_device *net_dev,
-			 const struct efx_dl_device_info *dev_info,
-			 const char *silicon_rev);
-
-static void efrm_dl_remove(struct efx_dl_device *efrm_dev);
-
-static void efrm_dl_reset_suspend(struct efx_dl_device *efrm_dev);
-
-static void efrm_dl_reset_resume(struct efx_dl_device *efrm_dev, int ok);
-
-static void efrm_dl_mtu_changed(struct efx_dl_device *, int);
-static void efrm_dl_event_falcon(struct efx_dl_device *efx_dev, void *p_event);
-
-static struct efx_dl_driver efrm_dl_driver = {
-	.name = "resource",
-	.probe = efrm_dl_probe,
-	.remove = efrm_dl_remove,
-	.reset_suspend = efrm_dl_reset_suspend,
-	.reset_resume = efrm_dl_reset_resume
-};
-
-static void
-init_vi_resource_dimensions(struct vi_resource_dimensions *rd,
-			    const struct efx_dl_falcon_resources *res)
-{
-	rd->evq_timer_min = res->evq_timer_min;
-	rd->evq_timer_lim = res->evq_timer_lim;
-	rd->evq_int_min = res->evq_int_min;
-	rd->evq_int_lim = res->evq_int_lim;
-	rd->rxq_min = res->rxq_min;
-	rd->rxq_lim = res->rxq_lim;
-	rd->txq_min = res->txq_min;
-	rd->txq_lim = res->txq_lim;
-	EFRM_TRACE
-	    ("Using evq_int(%d-%d) evq_timer(%d-%d) RXQ(%d-%d) TXQ(%d-%d)",
-	     res->evq_int_min, res->evq_int_lim, res->evq_timer_min,
-	     res->evq_timer_lim, res->rxq_min, res->rxq_lim, res->txq_min,
-	     res->txq_lim);
-}
-
-static int
-efrm_dl_probe(struct efx_dl_device *efrm_dev,
-	      const struct net_device *net_dev,
-	      const struct efx_dl_device_info *dev_info,
-	      const char *silicon_rev)
-{
-	struct vi_resource_dimensions res_dim;
-	struct efx_dl_falcon_resources *res;
-	struct linux_efhw_nic *lnic;
-	struct pci_dev *dev;
-	struct efhw_nic *nic;
-	unsigned probe_flags = 0;
-	int non_irq_evq;
-	int rc;
-
-	efrm_dev->priv = NULL;
-
-	efx_dl_search_device_info(dev_info, EFX_DL_FALCON_RESOURCES,
-				  struct efx_dl_falcon_resources,
-				  hdr, res);
-
-	if (res == NULL) {
-		EFRM_ERR("%s: Unable to find falcon driverlink resources",
-			 __func__);
-		return -EINVAL;
-	}
-
-	if (res->flags & EFX_DL_FALCON_USE_MSI)
-		probe_flags |= NIC_FLAG_TRY_MSI;
-
-	dev = efrm_dev->pci_dev;
-	if (res->flags & EFX_DL_FALCON_DUAL_FUNC) {
-		unsigned vendor = dev->vendor;
-		EFRM_ASSERT(dev->bus != NULL);
-		dev = NULL;
-
-		while ((dev = pci_get_device(vendor, FALCON_S_DEVID, dev))
-		       != NULL) {
-			EFRM_ASSERT(dev->bus != NULL);
-			/* With PCIe (since it's point to point)
-			 * the slot ID is usually 0 and
-			 * the bus ID changes NIC to NIC, so we really
-			 * need to check both. */
-			if (PCI_SLOT(dev->devfn) ==
-			    PCI_SLOT(efrm_dev->pci_dev->devfn)
-			    && dev->bus->number ==
-			    efrm_dev->pci_dev->bus->number)
-				break;
-		}
-		if (dev == NULL) {
-			EFRM_ERR("%s: Unable to find falcon secondary "
-				 "PCI device.", __func__);
-			return -ENODEV;
-		}
-		pci_dev_put(dev);
-	}
-
-	init_vi_resource_dimensions(&res_dim, res);
-
-	EFRM_ASSERT(res_dim.evq_timer_lim > res_dim.evq_timer_min);
-	res_dim.evq_timer_lim--;
-	non_irq_evq = res_dim.evq_timer_lim;
-
-	rc = efrm_nic_add(dev, probe_flags, net_dev->dev_addr, &lnic,
-			  res->biu_lock,
-			  res->buffer_table_min, res->buffer_table_lim,
-			  non_irq_evq, &res_dim);
-	if (rc != 0)
-		return rc;
-
-	nic = &lnic->efrm_nic.efhw_nic;
-	nic->mtu = net_dev->mtu + ETH_HLEN;
-	nic->net_driver_dev = efrm_dev;
-	nic->ifindex = net_dev->ifindex;
-#ifdef CONFIG_NET_NS
-	nic->nd_net = net_dev->nd_net;
-#endif
-	efrm_dev->priv = nic;
-
-	/* Register a callback so we're told when MTU changes.
-	 * We dynamically allocate efx_dl_callbacks, because
-	 * the callbacks that we want depends on the NIC type.
-	 */
-	lnic->dl_callbacks =
-	    kmalloc(sizeof(struct efx_dl_callbacks), GFP_KERNEL);
-	if (!lnic->dl_callbacks) {
-		EFRM_ERR("Out of memory (%s)", __func__);
-		efrm_nic_del(lnic);
-		return -ENOMEM;
-	}
-	memset(lnic->dl_callbacks, 0, sizeof(*lnic->dl_callbacks));
-	lnic->dl_callbacks->mtu_changed = efrm_dl_mtu_changed;
-
-	if ((res->flags & EFX_DL_FALCON_DUAL_FUNC) == 0) {
-		/* Net driver receives all management events.
-		 * Register a callback to receive the ones
-		 * we're interested in. */
-		lnic->dl_callbacks->event = efrm_dl_event_falcon;
-	}
-
-	rc = efx_dl_register_callbacks(efrm_dev, lnic->dl_callbacks);
-	if (rc < 0) {
-		EFRM_ERR("%s: efx_dl_register_callbacks failed (%d)",
-			 __func__, rc);
-		kfree(lnic->dl_callbacks);
-		efrm_nic_del(lnic);
-		return rc;
-	}
-
-	return 0;
-}
-
-/* When we unregister ourselves on module removal, this function will be
- * called for all the devices we claimed */
-static void efrm_dl_remove(struct efx_dl_device *efrm_dev)
-{
-	struct efhw_nic *nic = efrm_dev->priv;
-	struct linux_efhw_nic *lnic = linux_efhw_nic(nic);
-	EFRM_TRACE("%s called", __func__);
-	if (lnic->dl_callbacks) {
-		efx_dl_unregister_callbacks(efrm_dev, lnic->dl_callbacks);
-		kfree(lnic->dl_callbacks);
-	}
-	if (efrm_dev->priv)
-		efrm_nic_del(lnic);
-	EFRM_TRACE("%s OK", __func__);
-}
-
-static void efrm_dl_reset_suspend(struct efx_dl_device *efrm_dev)
-{
-	EFRM_NOTICE("%s:", __func__);
-}
-
-static void efrm_dl_reset_resume(struct efx_dl_device *efrm_dev, int ok)
-{
-	EFRM_NOTICE("%s: ok=%d", __func__, ok);
-}
-
-int efrm_driverlink_register(void)
-{
-	EFRM_TRACE("%s:", __func__);
-	return efx_dl_register_driver(&efrm_dl_driver);
-}
-
-void efrm_driverlink_unregister(void)
-{
-	EFRM_TRACE("%s:", __func__);
-	efx_dl_unregister_driver(&efrm_dl_driver);
-}
-
-static void efrm_dl_mtu_changed(struct efx_dl_device *efx_dev, int mtu)
-{
-	struct efhw_nic *nic = efx_dev->priv;
-
-	ASSERT_RTNL();	/* Since we're looking at efx_dl_device::port_net_dev */
-
-	EFRM_TRACE("%s: old=%d new=%d", __func__, nic->mtu, mtu + ETH_HLEN);
-	/* If this happened we must have agreed to it above */
-	nic->mtu = mtu + ETH_HLEN;
-}
-
-static void efrm_dl_event_falcon(struct efx_dl_device *efx_dev, void *p_event)
-{
-	struct efhw_nic *nic = efx_dev->priv;
-	struct linux_efhw_nic *lnic = linux_efhw_nic(nic);
-	efhw_event_t *ev = p_event;
-
-	switch (FALCON_EVENT_CODE(ev)) {
-	case FALCON_EVENT_CODE_CHAR:
-		falcon_handle_char_event(nic, lnic->ev_handlers, ev);
-		break;
-	default:
-		EFRM_WARN("%s: unknown event type=%x", __func__,
-			  (unsigned)FALCON_EVENT_CODE(ev));
-		break;
-	}
-}
diff -r 5b3d4d3c1166 drivers/net/sfc/sfc_resource/efrm_internal.h
--- a/drivers/net/sfc/sfc_resource/efrm_internal.h	Fri Nov 05 15:20:28 2010 +0000
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,41 +0,0 @@
-#ifndef __EFRM_INTERNAL_H__
-#define __EFRM_INTERNAL_H__
-
-
-struct filter_resource {
-	struct efrm_resource rs;
-	struct vi_resource *pt;
-	int filter_idx;
-};
-
-#define filter_resource(rs1)  container_of((rs1), struct filter_resource, rs)
-
-
-struct efrm_client {
-	void *user_data;
-	struct list_head link;
-	struct efrm_client_callbacks *callbacks;
-	struct efhw_nic *nic;
-	int ref_count;
-	struct list_head resources;
-};
-
-
-extern void efrm_client_add_resource(struct efrm_client *,
-				     struct efrm_resource *);
-
-extern int efrm_buffer_table_size(void);
-
-
-static inline void efrm_resource_init(struct efrm_resource *rs,
-				      int type, int instance)
-{
-	EFRM_ASSERT(instance >= 0);
-	EFRM_ASSERT(type >= 0 && type < EFRM_RESOURCE_NUM);
-	rs->rs_ref_count = 1;
-	rs->rs_handle.handle = (type << 28u) |
-		(((unsigned)jiffies & 0xfff) << 16) | instance;
-}
-
-
-#endif  /* __EFRM_INTERNAL_H__ */
diff -r 5b3d4d3c1166 drivers/net/sfc/sfc_resource/efx_vi_shm.c
--- a/drivers/net/sfc/sfc_resource/efx_vi_shm.c	Fri Nov 05 15:20:28 2010 +0000
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,707 +0,0 @@
-/****************************************************************************
- * Driver for Solarflare network controllers -
- *          resource management for Xen backend, OpenOnload, etc
- *           (including support for SFE4001 10GBT NIC)
- *
- * This file provides implementation of EFX VI API, used from Xen
- * acceleration driver.
- *
- * Copyright 2005-2007: Solarflare Communications Inc,
- *                      9501 Jeronimo Road, Suite 250,
- *                      Irvine, CA 92618, USA
- *
- * Developed and maintained by Solarflare Communications:
- *                      <linux-xen-drivers@solarflare.com>
- *                      <onload-dev@solarflare.com>
- *
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 as published
- * by the Free Software Foundation, incorporated herein by reference.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
- ****************************************************************************
- */
-
-#include "linux_resource_internal.h"
-#include <ci/efrm/vi_resource_manager.h>
-#include <ci/driver/resource/efx_vi.h>
-#include <ci/efrm/filter.h>
-#include <ci/efrm/buffer_table.h>
-#include <ci/efrm/efrm_client.h>
-#include <linux/pci.h>
-#include "kernel_compat.h"
-
-#if EFX_VI_STATIC_FILTERS
-struct filter_list_t {
-	struct filter_list_t *next;
-	struct filter_resource *fres;
-};
-#endif
-
-struct efx_vi_state {
-	struct vi_resource *vi_res;
-
-	int ifindex;
-	struct efrm_client *efrm_client;
-	struct efhw_nic *nic;
-
-	void (*callback_fn)(void *arg, int is_timeout);
-	void *callback_arg;
-
-	struct completion flush_completion;
-
-#if EFX_VI_STATIC_FILTERS
-	struct filter_list_t fres[EFX_VI_STATIC_FILTERS];
-	struct filter_list_t *free_fres;
-	struct filter_list_t *used_fres;
-#endif
-};
-
-static void efx_vi_flush_complete(void *state_void)
-{
-	struct efx_vi_state *state = (struct efx_vi_state *)state_void;
-
-	complete(&state->flush_completion);
-}
-
-static inline int alloc_ep(struct efx_vi_state *state)
-{
-	int rc;
-
-	rc = efrm_vi_resource_alloc(state->efrm_client, NULL, EFHW_VI_JUMBO_EN,
-				    efx_vi_eventq_size,
-				    FALCON_DMA_Q_DEFAULT_TX_SIZE,
-				    FALCON_DMA_Q_DEFAULT_RX_SIZE,
-				    0, 0, &state->vi_res, NULL, NULL, NULL,
-				    NULL);
-	if (rc < 0) {
-		EFRM_ERR("%s: ERROR efrm_vi_resource_alloc error %d",
-			 __func__, rc);
-		return rc;
-	}
-
-	efrm_vi_register_flush_callback(state->vi_res, &efx_vi_flush_complete,
-					(void *)state);
-
-	return 0;
-}
-
-static int free_ep(struct efx_vi_state *efx_state)
-{
-	efrm_vi_resource_release(efx_state->vi_res);
-
-	return 0;
-}
-
-#if EFX_VI_STATIC_FILTERS
-static int efx_vi_alloc_static_filters(struct efx_vi_state *efx_state)
-{
-	int i;
-	int rc;
-
-	efx_state->free_fres = efx_state->used_fres = NULL;
-
-	for (i = 0; i < EFX_VI_STATIC_FILTERS; i++) {
-		rc = efrm_filter_resource_alloc(efx_state->vi_res,
-						&efx_state->fres[i].fres);
-		if (rc < 0) {
-			EFRM_ERR("%s: efrm_filter_resource_alloc failed: %d",
-			     __func__, rc);
-			while (i > 0) {
-				i--;
-				efrm_filter_resource_release(efx_state->
-							     fres[i].fres);
-			}
-			efx_state->free_fres = NULL;
-			return rc;
-		}
-		efx_state->fres[i].next = efx_state->free_fres;
-		efx_state->free_fres = &efx_state->fres[i];
-	}
-
-	return 0;
-}
-#endif
-
-int efx_vi_alloc(struct efx_vi_state **vih_out, int ifindex)
-{
-	struct efx_vi_state *efx_state;
-	int rc;
-
-	efx_state = kmalloc(sizeof(struct efx_vi_state), GFP_KERNEL);
-
-	if (!efx_state) {
-		EFRM_ERR("%s: failed to allocate memory for efx_vi_state",
-			 __func__);
-		rc = -ENOMEM;
-		goto fail;
-	}
-
-	efx_state->ifindex = ifindex;
-	rc = efrm_client_get(ifindex, NULL, NULL, &efx_state->efrm_client);
-	if (rc < 0) {
-		EFRM_ERR("%s: efrm_client_get(%d) failed: %d", __func__,
-			 ifindex, rc);
-		rc = -ENODEV;
-		goto fail_no_ifindex;
-	}
-	efx_state->nic = efrm_client_get_nic(efx_state->efrm_client);
-
-	init_completion(&efx_state->flush_completion);
-
-	/* basically allocate_pt_endpoint() */
-	rc = alloc_ep(efx_state);
-	if (rc) {
-		EFRM_ERR("%s: alloc_ep failed: %d", __func__, rc);
-		goto fail_no_pt;
-	}
-#if EFX_VI_STATIC_FILTERS
-	/* Statically allocate a set of filter resources - removes the
-	   restriction on not being able to use efx_vi_filter() from
-	   in_atomic() */
-	rc = efx_vi_alloc_static_filters(efx_state);
-	if (rc)
-		goto fail_no_filters;
-#endif
-
-	*vih_out = efx_state;
-
-	return 0;
-#if EFX_VI_STATIC_FILTERS
-fail_no_filters:
-	free_ep(efx_state);
-#endif
-fail_no_pt:
-	efrm_client_put(efx_state->efrm_client);
-fail_no_ifindex:
-	kfree(efx_state);
-fail:
-	return rc;
-}
-EXPORT_SYMBOL(efx_vi_alloc);
-
-void efx_vi_free(struct efx_vi_state *vih)
-{
-	struct efx_vi_state *efx_state = vih;
-
-	/* TODO flush dma channels, init dma queues?.  See ef_free_vnic() */
-#if EFX_VI_STATIC_FILTERS
-	int i;
-
-	for (i = 0; i < EFX_VI_STATIC_FILTERS; i++)
-		efrm_filter_resource_release(efx_state->fres[i].fres);
-#endif
-
-	if (efx_state->vi_res)
-		free_ep(efx_state);
-
-	efrm_client_put(efx_state->efrm_client);
-
-	kfree(efx_state);
-}
-EXPORT_SYMBOL(efx_vi_free);
-
-void efx_vi_reset(struct efx_vi_state *vih)
-{
-	struct efx_vi_state *efx_state = vih;
-
-	efrm_pt_flush(efx_state->vi_res);
-
-	while (wait_for_completion_timeout(&efx_state->flush_completion, HZ)
-	       == 0)
-		efrm_vi_resource_flush_retry(efx_state->vi_res);
-
-	/* Bosch the eventq */
-	efrm_eventq_reset(efx_state->vi_res);
-	return;
-}
-EXPORT_SYMBOL(efx_vi_reset);
-
-static void
-efx_vi_eventq_callback(void *context, int is_timeout, struct efhw_nic *nic)
-{
-	struct efx_vi_state *efx_state = (struct efx_vi_state *)context;
-
-	EFRM_ASSERT(efx_state->callback_fn);
-
-	return efx_state->callback_fn(efx_state->callback_arg, is_timeout);
-}
-
-int
-efx_vi_eventq_register_callback(struct efx_vi_state *vih,
-			void (*callback)(void *context, int is_timeout),
-			void *context)
-{
-	struct efx_vi_state *efx_state = vih;
-
-	efx_state->callback_fn = callback;
-	efx_state->callback_arg = context;
-
-	/* Register the eventq timeout event callback */
-	efrm_eventq_register_callback(efx_state->vi_res,
-				      efx_vi_eventq_callback, efx_state);
-
-	return 0;
-}
-EXPORT_SYMBOL(efx_vi_eventq_register_callback);
-
-int efx_vi_eventq_kill_callback(struct efx_vi_state *vih)
-{
-	struct efx_vi_state *efx_state = vih;
-
-	if (efx_state->vi_res->evq_callback_fn)
-		efrm_eventq_kill_callback(efx_state->vi_res);
-
-	efx_state->callback_fn = NULL;
-	efx_state->callback_arg = NULL;
-
-	return 0;
-}
-EXPORT_SYMBOL(efx_vi_eventq_kill_callback);
-
-struct efx_vi_dma_map_state {
-	struct efhw_buffer_table_allocation bt_handle;
-	int n_pages;
-	dma_addr_t *dma_addrs;
-};
-
-int
-efx_vi_dma_map_pages(struct efx_vi_state *vih, struct page **pages,
-		     int n_pages, struct efx_vi_dma_map_state **dmh_out)
-{
-	struct efx_vi_state *efx_state = vih;
-	int order = fls(n_pages - 1), rc, i, evq_id;
-	dma_addr_t dma_addr;
-	struct efx_vi_dma_map_state *dm_state;
-
-	if (n_pages != (1 << order)) {
-		EFRM_WARN("%s: Can only allocate buffers in power of 2 "
-			  "sizes (not %d)", __func__, n_pages);
-		return -EINVAL;
-	}
-
-	dm_state = kmalloc(sizeof(struct efx_vi_dma_map_state), GFP_KERNEL);
-	if (!dm_state)
-		return -ENOMEM;
-
-	dm_state->dma_addrs = kmalloc(sizeof(dma_addr_t) * n_pages,
-				      GFP_KERNEL);
-	if (!dm_state->dma_addrs) {
-		kfree(dm_state);
-		return -ENOMEM;
-	}
-
-	rc = efrm_buffer_table_alloc(order, &dm_state->bt_handle);
-	if (rc < 0) {
-		kfree(dm_state->dma_addrs);
-		kfree(dm_state);
-		return rc;
-	}
-
-	evq_id = EFRM_RESOURCE_INSTANCE(efx_state->vi_res->rs.rs_handle);
-	for (i = 0; i < n_pages; i++) {
-		/* TODO do we need to get_page() here ? */
-
-		dma_addr = pci_map_page(linux_efhw_nic(efx_state->nic)->
-					  pci_dev, pages[i], 0, PAGE_SIZE,
-					PCI_DMA_TODEVICE);
-
-		efrm_buffer_table_set(&dm_state->bt_handle, efx_state->nic,
-				      i, dma_addr, evq_id);
-
-		dm_state->dma_addrs[i] = dma_addr;
-
-		/* Would be nice to not have to call commit each time, but
-		 * comment says there are hardware restrictions on how often
-		 * you can go without it, so do this to be safe */
-		efrm_buffer_table_commit();
-	}
-
-	dm_state->n_pages = n_pages;
-
-	*dmh_out = dm_state;
-
-	return 0;
-}
-EXPORT_SYMBOL(efx_vi_dma_map_pages);
-
-/* Function needed as Xen can't get pages for grants in dom0, but can
-   get dma address */
-int
-efx_vi_dma_map_addrs(struct efx_vi_state *vih,
-		     unsigned long long *bus_dev_addrs,
-		     int n_pages, struct efx_vi_dma_map_state **dmh_out)
-{
-	struct efx_vi_state *efx_state = vih;
-	int order = fls(n_pages - 1), rc, i, evq_id;
-	dma_addr_t dma_addr;
-	struct efx_vi_dma_map_state *dm_state;
-
-	if (n_pages != (1 << order)) {
-		EFRM_WARN("%s: Can only allocate buffers in power of 2 "
-			  "sizes (not %d)", __func__, n_pages);
-		return -EINVAL;
-	}
-
-	dm_state = kmalloc(sizeof(struct efx_vi_dma_map_state), GFP_KERNEL);
-	if (!dm_state)
-		return -ENOMEM;
-
-	dm_state->dma_addrs = kmalloc(sizeof(dma_addr_t) * n_pages,
-				      GFP_KERNEL);
-	if (!dm_state->dma_addrs) {
-		kfree(dm_state);
-		return -ENOMEM;
-	}
-
-	rc = efrm_buffer_table_alloc(order, &dm_state->bt_handle);
-	if (rc < 0) {
-		kfree(dm_state->dma_addrs);
-		kfree(dm_state);
-		return rc;
-	}
-
-	evq_id = EFRM_RESOURCE_INSTANCE(efx_state->vi_res->rs.rs_handle);
-#if 0
-	EFRM_WARN("%s: mapping %d pages to evq %d, bt_ids %d-%d\n",
-		  __func__, n_pages, evq_id,
-		  dm_state->bt_handle.base,
-		  dm_state->bt_handle.base + n_pages);
-#endif
-	for (i = 0; i < n_pages; i++) {
-
-		dma_addr = (dma_addr_t)bus_dev_addrs[i];
-
-		efrm_buffer_table_set(&dm_state->bt_handle, efx_state->nic,
-				      i, dma_addr, evq_id);
-
-		dm_state->dma_addrs[i] = dma_addr;
-
-		/* Would be nice to not have to call commit each time, but
-		 * comment says there are hardware restrictions on how often
-		 * you can go without it, so do this to be safe */
-		efrm_buffer_table_commit();
-	}
-
-	dm_state->n_pages = n_pages;
-
-	*dmh_out = dm_state;
-
-	return 0;
-}
-EXPORT_SYMBOL(efx_vi_dma_map_addrs);
-
-void
-efx_vi_dma_unmap_pages(struct efx_vi_state *vih,
-		       struct efx_vi_dma_map_state *dmh)
-{
-	struct efx_vi_state *efx_state = vih;
-	struct efx_vi_dma_map_state *dm_state =
-	    (struct efx_vi_dma_map_state *)dmh;
-	int i;
-
-	efrm_buffer_table_free(&dm_state->bt_handle);
-
-	for (i = 0; i < dm_state->n_pages; ++i)
-		pci_unmap_page(linux_efhw_nic(efx_state->nic)->pci_dev,
-			       dm_state->dma_addrs[i], PAGE_SIZE,
-			       PCI_DMA_TODEVICE);
-
-	kfree(dm_state->dma_addrs);
-	kfree(dm_state);
-
-	return;
-}
-EXPORT_SYMBOL(efx_vi_dma_unmap_pages);
-
-void
-efx_vi_dma_unmap_addrs(struct efx_vi_state *vih,
-		       struct efx_vi_dma_map_state *dmh)
-{
-	struct efx_vi_dma_map_state *dm_state =
-	    (struct efx_vi_dma_map_state *)dmh;
-
-	efrm_buffer_table_free(&dm_state->bt_handle);
-
-	kfree(dm_state->dma_addrs);
-	kfree(dm_state);
-
-	return;
-}
-EXPORT_SYMBOL(efx_vi_dma_unmap_addrs);
-
-unsigned
-efx_vi_dma_get_map_addr(struct efx_vi_state *vih,
-			struct efx_vi_dma_map_state *dmh)
-{
-	struct efx_vi_dma_map_state *dm_state =
-	    (struct efx_vi_dma_map_state *)dmh;
-
-	return EFHW_BUFFER_ADDR(dm_state->bt_handle.base, 0);
-}
-EXPORT_SYMBOL(efx_vi_dma_get_map_addr);
-
-#if EFX_VI_STATIC_FILTERS
-static int
-get_filter(struct efx_vi_state *efx_state,
-	   efrm_resource_handle_t pthandle, struct filter_resource **fres_out)
-{
-	struct filter_list_t *flist;
-	if (efx_state->free_fres == NULL)
-		return -ENOMEM;
-	else {
-		flist = efx_state->free_fres;
-		efx_state->free_fres = flist->next;
-		flist->next = efx_state->used_fres;
-		efx_state->used_fres = flist;
-		*fres_out = flist->fres;
-		return 0;
-	}
-}
-#endif
-
-static void
-release_filter(struct efx_vi_state *efx_state, struct filter_resource *fres)
-{
-#if EFX_VI_STATIC_FILTERS
-	struct filter_list_t *flist = efx_state->used_fres, *prev = NULL;
-	while (flist) {
-		if (flist->fres == fres) {
-			if (prev)
-				prev->next = flist->next;
-			else
-				efx_state->used_fres = flist->next;
-			flist->next = efx_state->free_fres;
-			efx_state->free_fres = flist;
-			return;
-		}
-		prev = flist;
-		flist = flist->next;
-	}
-	EFRM_ERR("%s: couldn't find filter", __func__);
-#else
-	return efrm_filter_resource_release(fres);
-#endif
-}
-
-int
-efx_vi_filter(struct efx_vi_state *vih, int protocol,
-	      unsigned ip_addr_be32, int port_le16,
-	      struct filter_resource_t **fh_out)
-{
-	struct efx_vi_state *efx_state = vih;
-	struct filter_resource *uninitialized_var(frs);
-	int rc;
-
-#if EFX_VI_STATIC_FILTERS
-	rc = get_filter(efx_state, efx_state->vi_res->rs.rs_handle, &frs);
-#else
-	rc = efrm_filter_resource_alloc(efx_state->vi_res, &frs);
-#endif
-	if (rc < 0)
-		return rc;
-
-	/* Add the hardware filter. We pass in the source port and address
-	 * as 0 (wildcard) to minimise the number of filters needed. */
-	if (protocol == IPPROTO_TCP) {
-		rc = efrm_filter_resource_tcp_set(frs, 0, 0, ip_addr_be32,
-						  port_le16);
-	} else {
-		rc = efrm_filter_resource_udp_set(frs, 0, 0, ip_addr_be32,
-						  port_le16);
-	}
-
-	*fh_out = (struct filter_resource_t *)frs;
-
-	return rc;
-}
-EXPORT_SYMBOL(efx_vi_filter);
-
-int
-efx_vi_filter_stop(struct efx_vi_state *vih, struct filter_resource_t *fh)
-{
-	struct efx_vi_state *efx_state = vih;
-	struct filter_resource *frs = (struct filter_resource *)fh;
-	int rc;
-
-	rc = efrm_filter_resource_clear(frs);
-	release_filter(efx_state, frs);
-
-	return rc;
-}
-EXPORT_SYMBOL(efx_vi_filter_stop);
-
-int
-efx_vi_hw_resource_get_virt(struct efx_vi_state *vih,
-			    struct efx_vi_hw_resource_metadata *mdata,
-			    struct efx_vi_hw_resource *hw_res_array,
-			    int *length)
-{
-	EFRM_NOTICE("%s: TODO!", __func__);
-
-	return 0;
-}
-EXPORT_SYMBOL(efx_vi_hw_resource_get_virt);
-
-int
-efx_vi_hw_resource_get_phys(struct efx_vi_state *vih,
-			    struct efx_vi_hw_resource_metadata *mdata,
-			    struct efx_vi_hw_resource *hw_res_array,
-			    int *length)
-{
-	struct efx_vi_state *efx_state = vih;
-	struct linux_efhw_nic *lnic = linux_efhw_nic(efx_state->nic);
-	unsigned long phys = lnic->ctr_ap_pci_addr;
-	struct efrm_resource *ep_res = &efx_state->vi_res->rs;
-	unsigned ep_mmap_bytes;
-	int i;
-
-	if (*length < EFX_VI_HW_RESOURCE_MAXSIZE)
-		return -EINVAL;
-
-	mdata->nic_arch = efx_state->nic->devtype.arch;
-	mdata->nic_variant = efx_state->nic->devtype.variant;
-	mdata->nic_revision = efx_state->nic->devtype.revision;
-
-	mdata->evq_order =
-	    efx_state->vi_res->nic_info.evq_pages.iobuff.order;
-	mdata->evq_offs = efx_state->vi_res->nic_info.evq_pages.iobuff_off;
-	mdata->evq_capacity = efx_vi_eventq_size;
-	mdata->instance = EFRM_RESOURCE_INSTANCE(ep_res->rs_handle);
-	mdata->rx_capacity = FALCON_DMA_Q_DEFAULT_RX_SIZE;
-	mdata->tx_capacity = FALCON_DMA_Q_DEFAULT_TX_SIZE;
-
-	ep_mmap_bytes = FALCON_DMA_Q_DEFAULT_MMAP;
-	EFRM_ASSERT(ep_mmap_bytes == PAGE_SIZE * 2);
-
-#ifndef NDEBUG
-	{
-		/* Sanity about doorbells */
-		unsigned long tx_dma_page_addr, rx_dma_page_addr;
-
-		/* get rx doorbell address */
-		rx_dma_page_addr =
-		    phys + falcon_rx_dma_page_addr(mdata->instance);
-		/* get tx doorbell address */
-		tx_dma_page_addr =
-		    phys + falcon_tx_dma_page_addr(mdata->instance);
-
-		/* Check the lower bits of the TX doorbell will be
-		 * consistent. */
-		EFRM_ASSERT((TX_DESC_UPD_REG_PAGE4_OFST &
-			     FALCON_DMA_PAGE_MASK) ==
-			    (TX_DESC_UPD_REG_PAGE123K_OFST &
-			     FALCON_DMA_PAGE_MASK));
-
-		/* Check the lower bits of the RX doorbell will be
-		 * consistent. */
-		EFRM_ASSERT((RX_DESC_UPD_REG_PAGE4_OFST &
-			     FALCON_DMA_PAGE_MASK) ==
-			    (RX_DESC_UPD_REG_PAGE123K_OFST &
-			     FALCON_DMA_PAGE_MASK));
-
-		/* Check that the doorbells will be in the same page. */
-		EFRM_ASSERT((TX_DESC_UPD_REG_PAGE4_OFST & PAGE_MASK) ==
-			    (RX_DESC_UPD_REG_PAGE4_OFST & PAGE_MASK));
-
-		/* Check that the doorbells are in the same page. */
-		EFRM_ASSERT((tx_dma_page_addr & PAGE_MASK) ==
-			    (rx_dma_page_addr & PAGE_MASK));
-
-		/* Check that the TX doorbell offset is correct. */
-		EFRM_ASSERT((TX_DESC_UPD_REG_PAGE4_OFST & ~PAGE_MASK) ==
-			    (tx_dma_page_addr & ~PAGE_MASK));
-
-		/* Check that the RX doorbell offset is correct. */
-		EFRM_ASSERT((RX_DESC_UPD_REG_PAGE4_OFST & ~PAGE_MASK) ==
-			    (rx_dma_page_addr & ~PAGE_MASK));
-	}
-#endif
-
-	i = 0;
-	hw_res_array[i].type = EFX_VI_HW_RESOURCE_TXDMAQ;
-	hw_res_array[i].mem_type = EFX_VI_HW_RESOURCE_PERIPHERAL;
-	hw_res_array[i].more_to_follow = 0;
-	hw_res_array[i].length = PAGE_SIZE;
-	hw_res_array[i].address =
-		(unsigned long)efx_state->vi_res->nic_info.
-			dmaq_pages[EFRM_VI_RM_DMA_QUEUE_TX].kva;
-
-	i++;
-	hw_res_array[i].type = EFX_VI_HW_RESOURCE_RXDMAQ;
-	hw_res_array[i].mem_type = EFX_VI_HW_RESOURCE_PERIPHERAL;
-	hw_res_array[i].more_to_follow = 0;
-	hw_res_array[i].length = PAGE_SIZE;
-	hw_res_array[i].address =
-		(unsigned long)efx_state->vi_res->nic_info.
-			dmaq_pages[EFRM_VI_RM_DMA_QUEUE_RX].kva;
-
-	i++;
-	hw_res_array[i].type = EFX_VI_HW_RESOURCE_EVQTIMER;
-	hw_res_array[i].mem_type = EFX_VI_HW_RESOURCE_PERIPHERAL;
-	hw_res_array[i].more_to_follow = 0;
-	hw_res_array[i].length = PAGE_SIZE;
-	hw_res_array[i].address =
-		(unsigned long)phys + falcon_timer_page_addr(mdata->instance);
-
-	/* NB EFX_VI_HW_RESOURCE_EVQPTR not used on Falcon */
-
-	i++;
-	switch (efx_state->nic->devtype.variant) {
-	case 'A':
-		hw_res_array[i].type = EFX_VI_HW_RESOURCE_EVQRPTR;
-		hw_res_array[i].mem_type = EFX_VI_HW_RESOURCE_PERIPHERAL;
-		hw_res_array[i].more_to_follow = 0;
-		hw_res_array[i].length = PAGE_SIZE;
-		hw_res_array[i].address = (unsigned long)phys +
-			EVQ_RPTR_REG_OFST +
-			(FALCON_REGISTER128 * mdata->instance);
-		break;
-	case 'B':
-		hw_res_array[i].type = EFX_VI_HW_RESOURCE_EVQRPTR_OFFSET;
-		hw_res_array[i].mem_type = EFX_VI_HW_RESOURCE_PERIPHERAL;
-		hw_res_array[i].more_to_follow = 0;
-		hw_res_array[i].length = PAGE_SIZE;
-		hw_res_array[i].address =
-			(unsigned long)FALCON_EVQ_RPTR_REG_P0;
-		break;
-	default:
-		EFRM_ASSERT(0);
-		break;
-	}
-
-	i++;
-	hw_res_array[i].type = EFX_VI_HW_RESOURCE_EVQMEMKVA;
-	hw_res_array[i].mem_type = EFX_VI_HW_RESOURCE_IOBUFFER;
-	hw_res_array[i].more_to_follow = 0;
-	hw_res_array[i].length = PAGE_SIZE;
-	hw_res_array[i].address = (unsigned long)efx_state->vi_res->
-		nic_info.evq_pages.iobuff.kva;
-
-	i++;
-	hw_res_array[i].type = EFX_VI_HW_RESOURCE_BELLPAGE;
-	hw_res_array[i].mem_type = EFX_VI_HW_RESOURCE_PERIPHERAL;
-	hw_res_array[i].more_to_follow = 0;
-	hw_res_array[i].length = PAGE_SIZE;
-	hw_res_array[i].address =
-		(unsigned long)(phys +
-				falcon_tx_dma_page_addr(mdata->instance))
-		>> PAGE_SHIFT;
-
-	i++;
-
-	EFRM_ASSERT(i <= *length);
-
-	*length = i;
-
-	return 0;
-}
-EXPORT_SYMBOL(efx_vi_hw_resource_get_phys);
diff -r 5b3d4d3c1166 drivers/net/sfc/sfc_resource/eventq.c
--- a/drivers/net/sfc/sfc_resource/eventq.c	Fri Nov 05 15:20:28 2010 +0000
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,321 +0,0 @@
-/****************************************************************************
- * Driver for Solarflare network controllers -
- *          resource management for Xen backend, OpenOnload, etc
- *           (including support for SFE4001 10GBT NIC)
- *
- * This file contains event queue support.
- *
- * Copyright 2005-2007: Solarflare Communications Inc,
- *                      9501 Jeronimo Road, Suite 250,
- *                      Irvine, CA 92618, USA
- *
- * Developed and maintained by Solarflare Communications:
- *                      <linux-xen-drivers@solarflare.com>
- *                      <onload-dev@solarflare.com>
- *
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 as published
- * by the Free Software Foundation, incorporated herein by reference.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
- ****************************************************************************
- */
-
-#include <ci/efhw/debug.h>
-#include <ci/efhw/iopage.h>
-#include <ci/driver/efab/hardware.h>
-#include <ci/efhw/eventq.h>
-#include <ci/efhw/falcon.h>
-#include <ci/efhw/nic.h>
-
-#define KEVENTQ_MAGIC 0x07111974
-
-/*! Helper function to allocate the iobuffer needed by an eventq
- *   - it ensures the eventq has the correct alignment for the NIC
- *
- * \param rm        Event-queue resource manager
- * \param instance  Event-queue instance (index)
- * \param buf_bytes Requested size of eventq
- * \return          < 0 if iobuffer allocation fails
- */
-int
-efhw_nic_event_queue_alloc_iobuffer(struct efhw_nic *nic,
-				    struct eventq_resource_hardware *h,
-				    int evq_instance, unsigned buf_bytes)
-{
-	unsigned int page_order;
-	int rc;
-
-	/* Allocate an iobuffer. */
-	page_order = get_order(buf_bytes);
-
-	h->iobuff_off = 0;
-
-	EFHW_TRACE("allocating eventq size %x",
-		   1u << (page_order + PAGE_SHIFT));
-	rc = efhw_iopages_alloc(nic, &h->iobuff, page_order);
-	if (rc < 0) {
-		EFHW_WARN("%s: failed to allocate %u pages",
-			  __func__, 1u << page_order);
-		return rc;
-	}
-
-	/* Set the eventq pages to match EFHW_CLEAR_EVENT() */
-	if (EFHW_CLEAR_EVENT_VALUE)
-		memset(efhw_iopages_ptr(&h->iobuff) + h->iobuff_off,
-		       EFHW_CLEAR_EVENT_VALUE, (1u << page_order) * PAGE_SIZE);
-
-	EFHW_TRACE("%s: allocated %u pages", __func__, 1u << (page_order));
-
-	/* For Falcon the NIC is programmed with the base buffer address of a
-	 * contiguous region of buffer space. This means that larger than a
-	 * PAGE event queues can be expected to allocate even when the host's
-	 * physical memory is fragmented */
-	EFHW_ASSERT(efhw_nic_have_hw(nic));
-	EFHW_ASSERT(page_order <= h->buf_tbl_alloc.order);
-
-	/* Initialise the buffer table entries. */
-	falcon_nic_buffer_table_set_n(nic, h->buf_tbl_alloc.base,
-				      efhw_iopages_dma_addr(&h->iobuff) +
-				      h->iobuff_off, EFHW_NIC_PAGE_SIZE, 0,
-				      1 << page_order, 0);
-
-	if (evq_instance >= FALCON_EVQ_TBL_RESERVED)
-		falcon_nic_buffer_table_confirm(nic);
-	return 0;
-}
-
-/**********************************************************************
- * Kernel event queue management.
- */
-
-/* Values for [struct efhw_keventq::lock] field. */
-#define KEVQ_UNLOCKED      0
-#define KEVQ_LOCKED        1
-#define KEVQ_RECHECK       2
-
-int
-efhw_keventq_ctor(struct efhw_nic *nic, int instance,
-		  struct efhw_keventq *evq,
-		  struct efhw_ev_handler *ev_handlers)
-{
-	int rc;
-	unsigned buf_bytes = evq->hw.capacity * sizeof(efhw_event_t);
-
-	evq->instance = instance;
-	evq->ev_handlers = ev_handlers;
-
-	/* allocate an IObuffer for the eventq */
-	rc = efhw_nic_event_queue_alloc_iobuffer(nic, &evq->hw, evq->instance,
-						 buf_bytes);
-	if (rc < 0)
-		return rc;
-
-	/* Zero the timer-value for this queue.
-	   AND Tell the nic about the event queue. */
-	efhw_nic_event_queue_enable(nic, evq->instance, evq->hw.capacity,
-				    efhw_iopages_dma_addr(&evq->hw.iobuff) +
-				    evq->hw.iobuff_off,
-				    evq->hw.buf_tbl_alloc.base,
-				    1 /* interrupting */);
-
-	evq->lock = KEVQ_UNLOCKED;
-	evq->evq_base = efhw_iopages_ptr(&evq->hw.iobuff) + evq->hw.iobuff_off;
-	evq->evq_ptr = 0;
-	evq->evq_mask = (evq->hw.capacity * sizeof(efhw_event_t)) - 1u;
-
-	EFHW_TRACE("%s: [%d] base=%p end=%p", __func__, evq->instance,
-		   evq->evq_base, evq->evq_base + buf_bytes);
-
-	return 0;
-}
-
-void efhw_keventq_dtor(struct efhw_nic *nic, struct efhw_keventq *evq)
-{
-	EFHW_ASSERT(evq);
-
-	EFHW_TRACE("%s: [%d]", __func__, evq->instance);
-
-	/* Zero the timer-value for this queue.
-	   And Tell NIC to stop using this event queue. */
-	efhw_nic_event_queue_disable(nic, evq->instance, 0);
-
-	/* free the pages used by the eventq itself */
-	efhw_iopages_free(nic, &evq->hw.iobuff);
-}
-
-void
-efhw_handle_txdmaq_flushed(struct efhw_nic *nic, struct efhw_ev_handler *h,
-			   efhw_event_t *evp)
-{
-	int instance = (int)FALCON_EVENT_TX_FLUSH_Q_ID(evp);
-	EFHW_TRACE("%s: instance=%d", __func__, instance);
-
-	if (!h->dmaq_flushed_fn) {
-		EFHW_WARN("%s: no handler registered", __func__);
-		return;
-	}
-
-	h->dmaq_flushed_fn(nic, instance, false);
-}
-
-void
-efhw_handle_rxdmaq_flushed(struct efhw_nic *nic, struct efhw_ev_handler *h,
-			   efhw_event_t *evp)
-{
-	unsigned instance = (unsigned)FALCON_EVENT_RX_FLUSH_Q_ID(evp);
-	EFHW_TRACE("%s: instance=%d", __func__, instance);
-
-	if (!h->dmaq_flushed_fn) {
-		EFHW_WARN("%s: no handler registered", __func__);
-		return;
-	}
-
-	h->dmaq_flushed_fn(nic, instance, true);
-}
-
-void
-efhw_handle_wakeup_event(struct efhw_nic *nic, struct efhw_ev_handler *h,
-			 efhw_event_t *evp)
-{
-	unsigned instance = (unsigned)FALCON_EVENT_WAKE_EVQ_ID(evp);
-
-	if (!h->wakeup_fn) {
-		EFHW_WARN("%s: no handler registered", __func__);
-		return;
-	}
-
-	h->wakeup_fn(nic, instance);
-}
-
-void
-efhw_handle_timeout_event(struct efhw_nic *nic, struct efhw_ev_handler *h,
-			  efhw_event_t *evp)
-{
-	unsigned instance = (unsigned)FALCON_EVENT_WAKE_EVQ_ID(evp);
-
-	if (!h->timeout_fn) {
-		EFHW_WARN("%s: no handler registered", __func__);
-		return;
-	}
-
-	h->timeout_fn(nic, instance);
-}
-
-/**********************************************************************
- * Kernel event queue event handling.
- */
-
-int efhw_keventq_poll(struct efhw_nic *nic, struct efhw_keventq *q)
-{
-	efhw_event_t *ev;
-	int l, count = 0;
-
-	EFHW_ASSERT(nic);
-	EFHW_ASSERT(q);
-	EFHW_ASSERT(q->ev_handlers);
-
-	/* Acquire the lock, or mark the queue as needing re-checking. */
-	for (;;) {
-		l = q->lock;
-		if (l == KEVQ_UNLOCKED) {
-			if ((int)cmpxchg(&q->lock, l, KEVQ_LOCKED) == l)
-				break;
-		} else if (l == KEVQ_LOCKED) {
-			if ((int)cmpxchg(&q->lock, l, KEVQ_RECHECK) == l)
-				return 0;
-		} else {	/* already marked for re-checking */
-			EFHW_ASSERT(l == KEVQ_RECHECK);
-			return 0;
-		}
-	}
-
-	if (unlikely(EFHW_EVENT_OVERFLOW(q, q)))
-		goto overflow;
-
-	ev = EFHW_EVENT_PTR(q, q, 0);
-
-#ifndef NDEBUG
-	if (!EFHW_IS_EVENT(ev))
-		EFHW_TRACE("%s: %d NO EVENTS!", __func__, q->instance);
-#endif
-
-	for (;;) {
-		/* Convention for return codes for handlers is:
-		 **   0   - no error, event consumed
-		 **   1   - no error, event not consumed
-		 **   -ve - error,    event not consumed
-		 */
-		if (likely(EFHW_IS_EVENT(ev))) {
-			count++;
-
-			switch (FALCON_EVENT_CODE(ev)) {
-
-			case FALCON_EVENT_CODE_CHAR:
-				falcon_handle_char_event(nic, q->ev_handlers,
-							 ev);
-				break;
-
-			default:
-				EFHW_ERR("efhw_keventq_poll: [%d] UNEXPECTED "
-					 "EVENT:"FALCON_EVENT_FMT,
-					 q->instance,
-					 FALCON_EVENT_PRI_ARG(*ev));
-			}
-
-			EFHW_CLEAR_EVENT(ev);
-			EFHW_EVENTQ_NEXT(q);
-
-			ev = EFHW_EVENT_PTR(q, q, 0);
-		} else {
-			/* No events left.  Release the lock (checking if we
-			 * need to re-poll to avoid race). */
-			l = q->lock;
-			if (l == KEVQ_LOCKED) {
-				if ((int)cmpxchg(&q->lock, l, KEVQ_UNLOCKED)
-				    == l) {
-					EFHW_TRACE
-					    ("efhw_keventq_poll: %d clean exit",
-					     q->instance);
-					goto clean_exit;
-				}
-			}
-
-			/* Potentially more work to do. */
-			l = q->lock;
-			EFHW_ASSERT(l == KEVQ_RECHECK);
-			EFHW_TEST((int)cmpxchg(&q->lock, l, KEVQ_LOCKED) == l);
-			EFHW_TRACE("efhw_keventq_poll: %d re-poll required",
-				   q->instance);
-		}
-	}
-
-	/* shouldn't get here */
-	EFHW_ASSERT(0);
-
-overflow:
-	/* ?? Oh dear.  Should we poll everything that could have possibly
-	 ** happened?  Or merely cry out in anguish...
-	 */
-	EFHW_WARN("efhw_keventq_poll: %d ***** OVERFLOW nic %d *****",
-		  q->instance, nic->index);
-
-	q->lock = KEVQ_UNLOCKED;
-	return count;
-
-clean_exit:
-	/* Ack the processed events so that this event queue can potentially
-	   raise interrupts again */
-	falcon_nic_evq_ack(nic, q->instance,
-			   (EFHW_EVENT_OFFSET(q, q, 0) / sizeof(efhw_event_t)),
-			   false);
-	return count;
-}
diff -r 5b3d4d3c1166 drivers/net/sfc/sfc_resource/falcon.c
--- a/drivers/net/sfc/sfc_resource/falcon.c	Fri Nov 05 15:20:28 2010 +0000
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,2525 +0,0 @@
-/****************************************************************************
- * Driver for Solarflare network controllers -
- *          resource management for Xen backend, OpenOnload, etc
- *           (including support for SFE4001 10GBT NIC)
- *
- * This file contains Falcon hardware support.
- *
- * Copyright 2005-2007: Solarflare Communications Inc,
- *                      9501 Jeronimo Road, Suite 250,
- *                      Irvine, CA 92618, USA
- *
- * Developed and maintained by Solarflare Communications:
- *                      <linux-xen-drivers@solarflare.com>
- *                      <onload-dev@solarflare.com>
- *
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 as published
- * by the Free Software Foundation, incorporated herein by reference.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
- ****************************************************************************
- */
-
-#include <ci/driver/efab/hardware.h>
-#include <ci/efhw/debug.h>
-#include <ci/efhw/iopage.h>
-#include <ci/efhw/falcon.h>
-#include <ci/efhw/falcon_hash.h>
-#include <ci/efhw/nic.h>
-#include <ci/efhw/eventq.h>
-#include <ci/efhw/checks.h>
-
-
-/*----------------------------------------------------------------------------
- *
- * Workarounds and options
- *
- *---------------------------------------------------------------------------*/
-
-/* Keep a software copy of the filter table and check for duplicates. */
-#define FALCON_FULL_FILTER_CACHE 1
-
-/* Read filters back from the hardware to detect corruption. */
-#define FALCON_VERIFY_FILTERS    0
-
-/* Options */
-#define RX_FILTER_CTL_SRCH_LIMIT_TCP_FULL 8	/* default search limit */
-#define RX_FILTER_CTL_SRCH_LIMIT_TCP_WILD 8	/* default search limit */
-#define RX_FILTER_CTL_SRCH_LIMIT_UDP_FULL 8	/* default search limit */
-#define RX_FILTER_CTL_SRCH_LIMIT_UDP_WILD 8	/* default search limit */
-
-#define FALCON_MAC_SET_TYPE_BY_SPEED           0
-
-/* FIXME: We should detect mode at runtime. */
-#define FALCON_BUFFER_TABLE_FULL_MODE          1
-
-/* "Fudge factors" - difference between programmed value and actual depth */
-#define RX_FILTER_CTL_SRCH_FUDGE_WILD 3	/* increase the search limit */
-#define RX_FILTER_CTL_SRCH_FUDGE_FULL 1	/* increase the search limit */
-#define TX_FILTER_CTL_SRCH_FUDGE_WILD 3	/* increase the search limit */
-#define TX_FILTER_CTL_SRCH_FUDGE_FULL 1	/* increase the search limit */
-
-/*----------------------------------------------------------------------------
- *
- * Debug Macros
- *
- *---------------------------------------------------------------------------*/
-
-#define _DEBUG_SYM_ static
-
- /*----------------------------------------------------------------------------
-  *
-  * Macros and forward declarations
-  *
-  *--------------------------------------------------------------------------*/
-
-#define FALCON_REGION_NUM 4	/* number of supported memory regions */
-
-#define FALCON_BUFFER_TBL_HALF_BYTES 4
-#define FALCON_BUFFER_TBL_FULL_BYTES 8
-
-/* Shadow buffer table - hack for testing only */
-#if FALCON_BUFFER_TABLE_FULL_MODE == 0
-# define FALCON_USE_SHADOW_BUFFER_TABLE 1
-#else
-# define FALCON_USE_SHADOW_BUFFER_TABLE 0
-#endif
-
-
-/*----------------------------------------------------------------------------
- *
- * Header assertion checks
- *
- *---------------------------------------------------------------------------*/
-
-#define FALCON_ASSERT_VALID()	/* nothing yet */
-
-/* Falcon has a 128bit register model but most registers have useful
-   defaults or only implement a small number of bits. Some registers
-   can be programmed 32bits UNLOCKED all others should be interlocked
-   against other threads within the same protection domain.
-
-   Aim is for software to perform the minimum number of writes and
-   also to minimise the read-modify-write activity (which generally
-   indicates a lack of clarity in the use model).
-
-   Registers which are programmed in this module are listed below
-   together with the method of access. Care must be taken to ensure
-   remain adequate if the register spec changes.
-
-   All 128bits programmed
-    FALCON_BUFFER_TBL_HALF
-    RX_FILTER_TBL
-    TX_DESC_PTR_TBL
-    RX_DESC_PTR_TBL
-    DRV_EV_REG
-
-   All 64bits programmed
-    FALCON_BUFFER_TBL_FULL
-
-   32 bits are programmed (UNLOCKED)
-    EVQ_RPTR_REG
-
-   Low 64bits programmed remainder are written with a random number
-    RX_DC_CFG_REG
-    TX_DC_CFG_REG
-    SRM_RX_DC_CFG_REG
-    SRM_TX_DC_CFG_REG
-    BUF_TBL_CFG_REG
-    BUF_TBL_UPD_REG
-    SRM_UPD_EVQ_REG
-    EVQ_PTR_TBL
-    TIMER_CMD_REG
-    TX_PACE_TBL
-    FATAL_INTR_REG
-    INT_EN_REG (When enabling interrupts)
-    TX_FLUSH_DESCQ_REG
-    RX_FLUSH_DESCQ
-
-  Read Modify Write on low 32bits remainder are written with a random number
-    INT_EN_REG (When sending a driver interrupt)
-    DRIVER_REGX
-
-  Read Modify Write on low 64bits remainder are written with a random number
-   SRM_CFG_REG_OFST
-   RX_CFG_REG_OFST
-   RX_FILTER_CTL_REG
-
-  Read Modify Write on full 128bits
-   TXDP_RESERVED_REG  (aka TXDP_UNDOCUMENTED)
-   TX_CFG_REG
-
-*/
-
-
-/*----------------------------------------------------------------------------
- *
- * DMAQ low-level register interface
- *
- *---------------------------------------------------------------------------*/
-
-static unsigned dmaq_sizes[] = {
-	512,
-	EFHW_1K,
-	EFHW_2K,
-	EFHW_4K,
-};
-
-#define N_DMAQ_SIZES  (sizeof(dmaq_sizes) / sizeof(dmaq_sizes[0]))
-
-static inline ulong falcon_dma_tx_q_offset(struct efhw_nic *nic, unsigned dmaq)
-{
-	EFHW_ASSERT(dmaq < nic->num_dmaqs);
-	return TX_DESC_PTR_TBL_OFST + dmaq * FALCON_REGISTER128;
-}
-
-static inline uint falcon_dma_tx_q_size_index(uint dmaq_size)
-{
-	uint i;
-
-	/* size must be one of the various options, otherwise we assert */
-	for (i = 0; i < N_DMAQ_SIZES; i++) {
-		if (dmaq_size == dmaq_sizes[i])
-			break;
-	}
-	EFHW_ASSERT(i < N_DMAQ_SIZES);
-	return i;
-}
-
-static void
-falcon_dmaq_tx_q_init(struct efhw_nic *nic,
-		      uint dmaq, uint evq_id, uint own_id,
-		      uint tag, uint dmaq_size, uint buf_idx, uint flags)
-{
-	FALCON_LOCK_DECL;
-	uint index, desc_type;
-	uint64_t val1, val2, val3;
-	ulong offset;
-	volatile char __iomem *efhw_kva = EFHW_KVA(nic);
-
-	/* Q attributes */
-	int iscsi_hdig_en = ((flags & EFHW_VI_ISCSI_TX_HDIG_EN) != 0);
-	int iscsi_ddig_en = ((flags & EFHW_VI_ISCSI_TX_DDIG_EN) != 0);
-	int csum_ip_dis = ((flags & EFHW_VI_TX_IP_CSUM_DIS) != 0);
-	int csum_tcp_dis = ((flags & EFHW_VI_TX_TCPUDP_CSUM_DIS) != 0);
-	int non_ip_drop_dis = ((flags & EFHW_VI_TX_TCPUDP_ONLY) == 0);
-
-	/* initialise the TX descriptor queue pointer table */
-
-	/* NB physical vs buffer addressing is determined by the Queue ID. */
-
-	offset = falcon_dma_tx_q_offset(nic, dmaq);
-	index = falcon_dma_tx_q_size_index(dmaq_size);
-
-	/* allow VI flag to override this queue's descriptor type */
-	desc_type = (flags & EFHW_VI_TX_PHYS_ADDR_EN) ? 0 : 1;
-
-	/* bug9403: It is dangerous to allow buffer-addressed queues to
-	 * have owner_id=0. */
-	EFHW_ASSERT((own_id > 0) || desc_type == 0);
-
-	/* dword 1 */
-	__DWCHCK(TX_DESCQ_FLUSH_LBN, TX_DESCQ_FLUSH_WIDTH);
-	__DWCHCK(TX_DESCQ_TYPE_LBN, TX_DESCQ_TYPE_WIDTH);
-	__DWCHCK(TX_DESCQ_SIZE_LBN, TX_DESCQ_SIZE_WIDTH);
-	__DWCHCK(TX_DESCQ_LABEL_LBN, TX_DESCQ_LABEL_WIDTH);
-	__DWCHCK(TX_DESCQ_OWNER_ID_LBN, TX_DESCQ_OWNER_ID_WIDTH);
-
-	__LWCHK(TX_DESCQ_EVQ_ID_LBN, TX_DESCQ_EVQ_ID_WIDTH);
-
-	__RANGECHCK(1, TX_DESCQ_FLUSH_WIDTH);
-	__RANGECHCK(desc_type, TX_DESCQ_TYPE_WIDTH);
-	__RANGECHCK(index, TX_DESCQ_SIZE_WIDTH);
-	__RANGECHCK(tag, TX_DESCQ_LABEL_WIDTH);
-	__RANGECHCK(own_id, TX_DESCQ_OWNER_ID_WIDTH);
-	__RANGECHCK(evq_id, TX_DESCQ_EVQ_ID_WIDTH);
-
-	val1 = ((desc_type << TX_DESCQ_TYPE_LBN) |
-		(index << TX_DESCQ_SIZE_LBN) |
-		(tag << TX_DESCQ_LABEL_LBN) |
-		(own_id << TX_DESCQ_OWNER_ID_LBN) |
-		(__LOW(evq_id, TX_DESCQ_EVQ_ID_LBN, TX_DESCQ_EVQ_ID_WIDTH)));
-
-	/* dword 2 */
-	__DW2CHCK(TX_DESCQ_BUF_BASE_ID_LBN, TX_DESCQ_BUF_BASE_ID_WIDTH);
-	__RANGECHCK(buf_idx, TX_DESCQ_BUF_BASE_ID_WIDTH);
-
-	val2 = ((__HIGH(evq_id, TX_DESCQ_EVQ_ID_LBN, TX_DESCQ_EVQ_ID_WIDTH)) |
-		(buf_idx << __DW2(TX_DESCQ_BUF_BASE_ID_LBN)));
-
-	/* dword 3 */
-	__DW3CHCK(TX_ISCSI_HDIG_EN_LBN, TX_ISCSI_HDIG_EN_WIDTH);
-	__DW3CHCK(TX_ISCSI_DDIG_EN_LBN, TX_ISCSI_DDIG_EN_WIDTH);
-	__RANGECHCK(iscsi_hdig_en, TX_ISCSI_HDIG_EN_WIDTH);
-	__RANGECHCK(iscsi_ddig_en, TX_ISCSI_DDIG_EN_WIDTH);
-
-	val3 = ((iscsi_hdig_en << __DW3(TX_ISCSI_HDIG_EN_LBN)) |
-		(iscsi_ddig_en << __DW3(TX_ISCSI_DDIG_EN_LBN)) |
-		(1 << __DW3(TX_DESCQ_EN_LBN)));	/* queue enable bit */
-
-	switch (nic->devtype.variant) {
-	case 'B':
-		__DW3CHCK(TX_NON_IP_DROP_DIS_B0_LBN,
-			  TX_NON_IP_DROP_DIS_B0_WIDTH);
-		__DW3CHCK(TX_IP_CHKSM_DIS_B0_LBN, TX_IP_CHKSM_DIS_B0_WIDTH);
-		__DW3CHCK(TX_TCP_CHKSM_DIS_B0_LBN, TX_TCP_CHKSM_DIS_B0_WIDTH);
-
-		val3 |= ((non_ip_drop_dis << __DW3(TX_NON_IP_DROP_DIS_B0_LBN))|
-			 (csum_ip_dis << __DW3(TX_IP_CHKSM_DIS_B0_LBN)) |
-			 (csum_tcp_dis << __DW3(TX_TCP_CHKSM_DIS_B0_LBN)));
-		break;
-	case 'A':
-		if (csum_ip_dis || csum_tcp_dis || !non_ip_drop_dis)
-			EFHW_WARN
-				("%s: bad settings for A1 csum_ip_dis=%d "
-				 "csum_tcp_dis=%d non_ip_drop_dis=%d",
-				 __func__, csum_ip_dis,
-				 csum_tcp_dis, non_ip_drop_dis);
-		break;
-	default:
-		EFHW_ASSERT(0);
-		break;
-	}
-
-	EFHW_TRACE("%s: txq %x evq %u tag %x id %x buf %x "
-		   "%x:%x:%x->%" PRIx64 ":%" PRIx64 ":%" PRIx64,
-		   __func__,
-		   dmaq, evq_id, tag, own_id, buf_idx, dmaq_size,
-		   iscsi_hdig_en, iscsi_ddig_en, val1, val2, val3);
-
-	/* Falcon requires 128 bit atomic access for this register */
-	FALCON_LOCK_LOCK(nic);
-	falcon_write_qq(efhw_kva + offset, ((val2 << 32) | val1), val3);
-	mmiowb();
-	FALCON_LOCK_UNLOCK(nic);
-	return;
-}
-
-static inline ulong
-falcon_dma_rx_q_offset(struct efhw_nic *nic, unsigned dmaq)
-{
-	EFHW_ASSERT(dmaq < nic->num_dmaqs);
-	return RX_DESC_PTR_TBL_OFST + dmaq * FALCON_REGISTER128;
-}
-
-static void
-falcon_dmaq_rx_q_init(struct efhw_nic *nic,
-		      uint dmaq, uint evq_id, uint own_id,
-		      uint tag, uint dmaq_size, uint buf_idx, uint flags)
-{
-	FALCON_LOCK_DECL;
-	uint i, desc_type = 1;
-	uint64_t val1, val2, val3;
-	ulong offset;
-	volatile char __iomem *efhw_kva = EFHW_KVA(nic);
-
-	/* Q attributes */
-#if BUG5762_WORKAROUND
-	int jumbo = 1;		/* Queues must not have mixed types */
-#else
-	int jumbo = ((flags & EFHW_VI_JUMBO_EN) != 0);
-#endif
-	int iscsi_hdig_en = ((flags & EFHW_VI_ISCSI_RX_HDIG_EN) != 0);
-	int iscsi_ddig_en = ((flags & EFHW_VI_ISCSI_RX_DDIG_EN) != 0);
-
-	/* initialise the TX descriptor queue pointer table */
-	offset = falcon_dma_rx_q_offset(nic, dmaq);
-
-	/* size must be one of the various options, otherwise we assert */
-	for (i = 0; i < N_DMAQ_SIZES; i++) {
-		if (dmaq_size == dmaq_sizes[i])
-			break;
-	}
-	EFHW_ASSERT(i < N_DMAQ_SIZES);
-
-	/* allow VI flag to override this queue's descriptor type */
-	desc_type = (flags & EFHW_VI_RX_PHYS_ADDR_EN) ? 0 : 1;
-
-	/* bug9403: It is dangerous to allow buffer-addressed queues to have
-	 * owner_id=0 */
-	EFHW_ASSERT((own_id > 0) || desc_type == 0);
-
-	/* dword 1 */
-	__DWCHCK(RX_DESCQ_EN_LBN, RX_DESCQ_EN_WIDTH);
-	__DWCHCK(RX_DESCQ_JUMBO_LBN, RX_DESCQ_JUMBO_WIDTH);
-	__DWCHCK(RX_DESCQ_TYPE_LBN, RX_DESCQ_TYPE_WIDTH);
-	__DWCHCK(RX_DESCQ_SIZE_LBN, RX_DESCQ_SIZE_WIDTH);
-	__DWCHCK(RX_DESCQ_LABEL_LBN, RX_DESCQ_LABEL_WIDTH);
-	__DWCHCK(RX_DESCQ_OWNER_ID_LBN, RX_DESCQ_OWNER_ID_WIDTH);
-
-	__LWCHK(RX_DESCQ_EVQ_ID_LBN, RX_DESCQ_EVQ_ID_WIDTH);
-
-	__RANGECHCK(1, RX_DESCQ_EN_WIDTH);
-	__RANGECHCK(jumbo, RX_DESCQ_JUMBO_WIDTH);
-	__RANGECHCK(desc_type, RX_DESCQ_TYPE_WIDTH);
-	__RANGECHCK(i, RX_DESCQ_SIZE_WIDTH);
-	__RANGECHCK(tag, RX_DESCQ_LABEL_WIDTH);
-	__RANGECHCK(own_id, RX_DESCQ_OWNER_ID_WIDTH);
-	__RANGECHCK(evq_id, RX_DESCQ_EVQ_ID_WIDTH);
-
-	val1 = ((1 << RX_DESCQ_EN_LBN) |
-		(jumbo << RX_DESCQ_JUMBO_LBN) |
-		(desc_type << RX_DESCQ_TYPE_LBN) |
-		(i << RX_DESCQ_SIZE_LBN) |
-		(tag << RX_DESCQ_LABEL_LBN) |
-		(own_id << RX_DESCQ_OWNER_ID_LBN) |
-		(__LOW(evq_id, RX_DESCQ_EVQ_ID_LBN, RX_DESCQ_EVQ_ID_WIDTH)));
-
-	/* dword 2 */
-	__DW2CHCK(RX_DESCQ_BUF_BASE_ID_LBN, RX_DESCQ_BUF_BASE_ID_WIDTH);
-	__RANGECHCK(buf_idx, RX_DESCQ_BUF_BASE_ID_WIDTH);
-
-	val2 = ((__HIGH(evq_id, RX_DESCQ_EVQ_ID_LBN, RX_DESCQ_EVQ_ID_WIDTH)) |
-		(buf_idx << __DW2(RX_DESCQ_BUF_BASE_ID_LBN)));
-
-	/* dword 3 */
-	__DW3CHCK(RX_ISCSI_HDIG_EN_LBN, RX_ISCSI_HDIG_EN_WIDTH);
-	__DW3CHCK(RX_ISCSI_DDIG_EN_LBN, RX_ISCSI_DDIG_EN_WIDTH);
-	__RANGECHCK(iscsi_hdig_en, RX_ISCSI_HDIG_EN_WIDTH);
-	__RANGECHCK(iscsi_ddig_en, RX_ISCSI_DDIG_EN_WIDTH);
-
-	val3 = (iscsi_hdig_en << __DW3(RX_ISCSI_HDIG_EN_LBN)) |
-	    (iscsi_ddig_en << __DW3(RX_ISCSI_DDIG_EN_LBN));
-
-	EFHW_TRACE("%s: rxq %x evq %u tag %x id %x buf %x %s "
-		   "%x:%x:%x -> %" PRIx64 ":%" PRIx64 ":%" PRIx64,
-		   __func__,
-		   dmaq, evq_id, tag, own_id, buf_idx,
-		   jumbo ? "jumbo" : "normal", dmaq_size,
-		   iscsi_hdig_en, iscsi_ddig_en, val1, val2, val3);
-
-	/* Falcon requires 128 bit atomic access for this register */
-	FALCON_LOCK_LOCK(nic);
-	falcon_write_qq(efhw_kva + offset, ((val2 << 32) | val1), val3);
-	mmiowb();
-	FALCON_LOCK_UNLOCK(nic);
-	return;
-}
-
-static void falcon_dmaq_tx_q_disable(struct efhw_nic *nic, uint dmaq)
-{
-	FALCON_LOCK_DECL;
-	uint64_t val1, val2, val3;
-	ulong offset;
-	volatile char __iomem *efhw_kva = EFHW_KVA(nic);
-
-	/* initialise the TX descriptor queue pointer table */
-
-	offset = falcon_dma_tx_q_offset(nic, dmaq);
-
-	/* dword 1 */
-	__DWCHCK(TX_DESCQ_TYPE_LBN, TX_DESCQ_TYPE_WIDTH);
-
-	val1 = ((uint64_t) 1 << TX_DESCQ_TYPE_LBN);
-
-	/* dword 2 */
-	val2 = 0;
-
-	/* dword 3 */
-	val3 = (0 << __DW3(TX_DESCQ_EN_LBN));	/* queue enable bit */
-
-	EFHW_TRACE("%s: %x->%" PRIx64 ":%" PRIx64 ":%" PRIx64,
-		   __func__, dmaq, val1, val2, val3);
-
-	/* Falcon requires 128 bit atomic access for this register */
-	FALCON_LOCK_LOCK(nic);
-	falcon_write_qq(efhw_kva + offset, ((val2 << 32) | val1), val3);
-	mmiowb();
-	FALCON_LOCK_UNLOCK(nic);
-	return;
-}
-
-static void falcon_dmaq_rx_q_disable(struct efhw_nic *nic, uint dmaq)
-{
-	FALCON_LOCK_DECL;
-	uint64_t val1, val2, val3;
-	ulong offset;
-	volatile char __iomem *efhw_kva = EFHW_KVA(nic);
-
-	/* initialise the TX descriptor queue pointer table */
-	offset = falcon_dma_rx_q_offset(nic, dmaq);
-
-	/* dword 1 */
-	__DWCHCK(RX_DESCQ_EN_LBN, RX_DESCQ_EN_WIDTH);
-	__DWCHCK(RX_DESCQ_TYPE_LBN, RX_DESCQ_TYPE_WIDTH);
-
-	val1 = ((0 << RX_DESCQ_EN_LBN) | (1 << RX_DESCQ_TYPE_LBN));
-
-	/* dword 2 */
-	val2 = 0;
-
-	/* dword 3 */
-	val3 = 0;
-
-	EFHW_TRACE("falcon_dmaq_rx_q_disable: %x->%"
-		   PRIx64 ":%" PRIx64 ":%" PRIx64,
-		   dmaq, val1, val2, val3);
-
-	/* Falcon requires 128 bit atomic access for this register */
-	FALCON_LOCK_LOCK(nic);
-	falcon_write_qq(efhw_kva + offset, ((val2 << 32) | val1), val3);
-	mmiowb();
-	FALCON_LOCK_UNLOCK(nic);
-	return;
-}
-
-
-/*----------------------------------------------------------------------------
- *
- * Buffer Table low-level register interface
- *
- *---------------------------------------------------------------------------*/
-
-/*! Convert a (potentially) 64-bit physical address to 32-bits.  Every use
-** of this function is a place where we're not 64-bit clean.
-*/
-static inline uint32_t dma_addr_to_u32(dma_addr_t addr)
-{
-	/* Top bits had better be zero! */
-	EFHW_ASSERT(addr == (addr & 0xffffffff));
-	return (uint32_t) addr;
-}
-
-static inline uint32_t
-falcon_nic_buffer_table_entry32_mk(dma_addr_t dma_addr, int own_id)
-{
-	uint32_t dma_addr32 = FALCON_BUFFER_4K_PAGE(dma_addr_to_u32(dma_addr));
-
-	/* don't do this to me */
-	EFHW_BUILD_ASSERT(BUF_ADR_HBUF_ODD_LBN == BUF_ADR_HBUF_EVEN_LBN + 32);
-	EFHW_BUILD_ASSERT(BUF_OWNER_ID_HBUF_ODD_LBN ==
-			  BUF_OWNER_ID_HBUF_EVEN_LBN + 32);
-
-	EFHW_BUILD_ASSERT(BUF_OWNER_ID_HBUF_ODD_WIDTH ==
-			  BUF_OWNER_ID_HBUF_EVEN_WIDTH);
-	EFHW_BUILD_ASSERT(BUF_ADR_HBUF_ODD_WIDTH == BUF_ADR_HBUF_EVEN_WIDTH);
-
-	__DWCHCK(BUF_ADR_HBUF_EVEN_LBN, BUF_ADR_HBUF_EVEN_WIDTH);
-	__DWCHCK(BUF_OWNER_ID_HBUF_EVEN_LBN, BUF_OWNER_ID_HBUF_EVEN_WIDTH);
-
-	__RANGECHCK(dma_addr32, BUF_ADR_HBUF_EVEN_WIDTH);
-	__RANGECHCK(own_id, BUF_OWNER_ID_HBUF_EVEN_WIDTH);
-
-	return (dma_addr32 << BUF_ADR_HBUF_EVEN_LBN) |
-		(own_id << BUF_OWNER_ID_HBUF_EVEN_LBN);
-}
-
-static inline uint64_t
-falcon_nic_buffer_table_entry64_mk(dma_addr_t dma_addr,
-				   int bufsz,	/* bytes */
-				   int region, int own_id)
-{
-	__DW2CHCK(IP_DAT_BUF_SIZE_LBN, IP_DAT_BUF_SIZE_WIDTH);
-	__DW2CHCK(BUF_ADR_REGION_LBN, BUF_ADR_REGION_WIDTH);
-	__LWCHK(BUF_ADR_FBUF_LBN, BUF_ADR_FBUF_WIDTH);
-	__DWCHCK(BUF_OWNER_ID_FBUF_LBN, BUF_OWNER_ID_FBUF_WIDTH);
-
-	EFHW_ASSERT((bufsz == EFHW_4K) || (bufsz == EFHW_8K));
-
-	dma_addr = (dma_addr >> 12) & __FALCON_MASK64(BUF_ADR_FBUF_WIDTH);
-
-	__RANGECHCK(dma_addr, BUF_ADR_FBUF_WIDTH);
-	__RANGECHCK(1, IP_DAT_BUF_SIZE_WIDTH);
-	__RANGECHCK(region, BUF_ADR_REGION_WIDTH);
-	__RANGECHCK(own_id, BUF_OWNER_ID_FBUF_WIDTH);
-
-	return ((uint64_t) (bufsz == EFHW_8K) << IP_DAT_BUF_SIZE_LBN) |
-		((uint64_t) region << BUF_ADR_REGION_LBN) |
-		((uint64_t) dma_addr << BUF_ADR_FBUF_LBN) |
-		((uint64_t) own_id << BUF_OWNER_ID_FBUF_LBN);
-}
-
-static inline void
-_falcon_nic_buffer_table_set32(struct efhw_nic *nic,
-			       dma_addr_t dma_addr, uint bufsz,
-			       uint region, /* not used */
-			       int own_id, int buffer_id)
-{
-	/* programming the half table needs to be done in pairs. */
-	uint64_t entry, val, shift;
-	volatile char __iomem *efhw_kva = EFHW_KVA(nic);
-	volatile char __iomem *offset;
-
-	EFHW_BUILD_ASSERT(BUF_ADR_HBUF_ODD_LBN == BUF_ADR_HBUF_EVEN_LBN + 32);
-	EFHW_BUILD_ASSERT(BUF_OWNER_ID_HBUF_ODD_LBN ==
-			  BUF_OWNER_ID_HBUF_EVEN_LBN + 32);
-
-	shift = (buffer_id & 1) ? 32 : 0;
-
-	offset = (efhw_kva + BUF_HALF_TBL_OFST +
-		  ((buffer_id & ~1) * FALCON_BUFFER_TBL_HALF_BYTES));
-
-	entry = falcon_nic_buffer_table_entry32_mk(dma_addr_to_u32(dma_addr),
-						   own_id);
-
-#if FALCON_USE_SHADOW_BUFFER_TABLE
-	val = _falcon_buffer_table[buffer_id & ~1];
-#else
-	/* This will not work unless we've completed
-	 * the buffer table updates */
-	falcon_read_q(offset, &val);
-#endif
-	val &= ~(((uint64_t) 0xffffffff) << shift);
-	val |= (entry << shift);
-
-	EFHW_TRACE("%s[%x]: %lx:%x:%" PRIx64 "->%x = %"
-		   PRIx64, __func__, buffer_id, (unsigned long) dma_addr,
-		   own_id, entry, (unsigned)(offset - efhw_kva), val);
-
-	/* Falcon requires that access to this register is serialised */
-	falcon_write_q(offset, val);
-
-	/* NB. No mmiowb().  Caller should do that e.g by calling commit  */
-
-#if FALCON_USE_SHADOW_BUFFER_TABLE
-	_falcon_buffer_table[buffer_id & ~1] = val;
-#endif
-
-	/* Confirm the entry if the event queues haven't been set up. */
-	if (!nic->irq_handler) {
-		uint64_t new_val;
-		int count = 0;
-		while (1) {
-			mmiowb();
-			falcon_read_q(offset, &new_val);
-			if (new_val == val)
-				break;
-			count++;
-			if (count > 1000) {
-				EFHW_WARN("%s: poll Timeout", __func__);
-				break;
-			}
-			udelay(1);
-		}
-	}
-}
-
-static inline void
-_falcon_nic_buffer_table_set64(struct efhw_nic *nic,
-			       dma_addr_t dma_addr, uint bufsz,
-			       uint region, int own_id, int buffer_id)
-{
-	volatile char __iomem *offset;
-	uint64_t entry;
-	volatile char __iomem *efhw_kva = EFHW_KVA(nic);
-
-	EFHW_ASSERT(region < FALCON_REGION_NUM);
-
-	EFHW_ASSERT((bufsz == EFHW_4K) ||
-		    (bufsz == EFHW_8K && FALCON_BUFFER_TABLE_FULL_MODE));
-
-	offset = (efhw_kva + BUF_FULL_TBL_OFST +
-		  (buffer_id * FALCON_BUFFER_TBL_FULL_BYTES));
-
-	entry = falcon_nic_buffer_table_entry64_mk(dma_addr, bufsz, region,
-						   own_id);
-
-	EFHW_TRACE("%s[%x]: %lx:bufsz=%x:region=%x:ownid=%x",
-		   __func__, buffer_id, (unsigned long) dma_addr, bufsz,
-		   region, own_id);
-
-	EFHW_TRACE("%s: BUF[%x]:NIC[%x]->%" PRIx64,
-		   __func__, buffer_id,
-		   (unsigned int)(offset - efhw_kva), entry);
-
-	/* Falcon requires that access to this register is serialised */
-	falcon_write_q(offset, entry);
-
-	/* NB. No mmiowb().  Caller should do that e.g by calling commit */
-
-	/* Confirm the entry if the event queues haven't been set up. */
-	if (!nic->irq_handler) {
-		uint64_t new_entry;
-		int count = 0;
-		while (1) {
-			mmiowb();
-			falcon_read_q(offset, &new_entry);
-			if (new_entry == entry)
-				return;
-			count++;
-			if (count > 1000) {
-				EFHW_WARN("%s: poll Timeout waiting for "
-					  "value %"PRIx64
-					  " (last was %"PRIx64")",
-					  __func__, entry, new_entry);
-				break;
-			}
-			udelay(1);
-		}
-	}
-}
-
-#if FALCON_BUFFER_TABLE_FULL_MODE
-#define _falcon_nic_buffer_table_set _falcon_nic_buffer_table_set64
-#else
-#define _falcon_nic_buffer_table_set _falcon_nic_buffer_table_set32
-#endif
-
-static inline void _falcon_nic_buffer_table_commit(struct efhw_nic *nic)
-{
-	/* MUST be called holding the FALCON_LOCK */
-	volatile char __iomem *efhw_kva = EFHW_KVA(nic);
-	uint64_t cmd;
-
-	EFHW_BUILD_ASSERT(BUF_TBL_UPD_REG_KER_OFST == BUF_TBL_UPD_REG_OFST);
-
-	__DW2CHCK(BUF_UPD_CMD_LBN, BUF_UPD_CMD_WIDTH);
-	__RANGECHCK(1, BUF_UPD_CMD_WIDTH);
-
-	cmd = ((uint64_t) 1 << BUF_UPD_CMD_LBN);
-
-	/* Falcon requires 128 bit atomic access for this register */
-	falcon_write_qq(efhw_kva + BUF_TBL_UPD_REG_OFST,
-			cmd, FALCON_ATOMIC_UPD_REG);
-	mmiowb();
-
-	nic->buf_commit_outstanding++;
-	EFHW_TRACE("COMMIT REQ out=%d", nic->buf_commit_outstanding);
-}
-
-static void falcon_nic_buffer_table_commit(struct efhw_nic *nic)
-{
-	/* nothing to do */
-}
-
-static inline void
-_falcon_nic_buffer_table_clear(struct efhw_nic *nic, int buffer_id, int num)
-{
-	uint64_t cmd;
-	uint64_t start_id = buffer_id;
-	uint64_t end_id = buffer_id + num - 1;
-	volatile char __iomem *efhw_kva = EFHW_KVA(nic);
-
-	volatile char __iomem *offset = (efhw_kva + BUF_TBL_UPD_REG_OFST);
-
-	EFHW_BUILD_ASSERT(BUF_TBL_UPD_REG_KER_OFST == BUF_TBL_UPD_REG_OFST);
-
-#if !FALCON_BUFFER_TABLE_FULL_MODE
-	/* buffer_ids in half buffer mode reference pairs of buffers */
-	EFHW_ASSERT(buffer_id % 1 == 0);
-	EFHW_ASSERT(num % 1 == 0);
-	start_id = start_id >> 1;
-	end_id = end_id >> 1;
-#endif
-
-	EFHW_ASSERT(num >= 1);
-
-	__DWCHCK(BUF_CLR_START_ID_LBN, BUF_CLR_START_ID_WIDTH);
-	__DW2CHCK(BUF_CLR_END_ID_LBN, BUF_CLR_END_ID_WIDTH);
-
-	__DW2CHCK(BUF_CLR_CMD_LBN, BUF_CLR_CMD_WIDTH);
-	__RANGECHCK(1, BUF_CLR_CMD_WIDTH);
-
-	__RANGECHCK(start_id, BUF_CLR_START_ID_WIDTH);
-	__RANGECHCK(end_id, BUF_CLR_END_ID_WIDTH);
-
-	cmd = (((uint64_t) 1 << BUF_CLR_CMD_LBN) |
-	       (start_id << BUF_CLR_START_ID_LBN) |
-	       (end_id << BUF_CLR_END_ID_LBN));
-
-	/* Falcon requires 128 bit atomic access for this register */
-	falcon_write_qq(offset, cmd, FALCON_ATOMIC_UPD_REG);
-	mmiowb();
-
-	nic->buf_commit_outstanding++;
-	EFHW_TRACE("COMMIT CLEAR out=%d", nic->buf_commit_outstanding);
-}
-
-/*----------------------------------------------------------------------------
- *
- * Events low-level register interface
- *
- *---------------------------------------------------------------------------*/
-
-static unsigned eventq_sizes[] = {
-	512,
-	EFHW_1K,
-	EFHW_2K,
-	EFHW_4K,
-	EFHW_8K,
-	EFHW_16K,
-	EFHW_32K
-};
-
-#define N_EVENTQ_SIZES  (sizeof(eventq_sizes) / sizeof(eventq_sizes[0]))
-
-static inline void falcon_nic_srm_upd_evq(struct efhw_nic *nic, int evq)
-{
-	/* set up the eventq which will receive events from the SRAM module.
-	 * i.e buffer table updates and clears, TX and RX aperture table
-	 * updates */
-
-	FALCON_LOCK_DECL;
-	volatile char __iomem *efhw_kva = EFHW_KVA(nic);
-
-	EFHW_BUILD_ASSERT(SRM_UPD_EVQ_REG_OFST == SRM_UPD_EVQ_REG_KER_OFST);
-
-	__DWCHCK(SRM_UPD_EVQ_ID_LBN, SRM_UPD_EVQ_ID_WIDTH);
-	__RANGECHCK(evq, SRM_UPD_EVQ_ID_WIDTH);
-
-	/* Falcon requires 128 bit atomic access for this register */
-	FALCON_LOCK_LOCK(nic);
-	falcon_write_qq(efhw_kva + SRM_UPD_EVQ_REG_OFST,
-			((uint64_t) evq << SRM_UPD_EVQ_ID_LBN),
-			FALCON_ATOMIC_SRPM_UDP_EVQ_REG);
-	mmiowb();
-	FALCON_LOCK_UNLOCK(nic);
-}
-
-static void
-falcon_nic_evq_ptr_tbl(struct efhw_nic *nic,
-		       uint evq,	/* evq id */
-		       uint enable,	/* 1 to enable, 0 to disable */
-		       uint buf_base_id,/* Buffer table base for EVQ */
-		       uint evq_size	/* Number of events */)
-{
-	FALCON_LOCK_DECL;
-	uint i, val;
-	ulong offset;
-	volatile char __iomem *efhw_kva = EFHW_KVA(nic);
-
-	/* size must be one of the various options, otherwise we assert */
-	for (i = 0; i < N_EVENTQ_SIZES; i++) {
-		if (evq_size <= eventq_sizes[i])
-			break;
-	}
-	EFHW_ASSERT(i < N_EVENTQ_SIZES);
-
-	__DWCHCK(EVQ_BUF_BASE_ID_LBN, EVQ_BUF_BASE_ID_WIDTH);
-	__DWCHCK(EVQ_SIZE_LBN, EVQ_SIZE_WIDTH);
-	__DWCHCK(EVQ_EN_LBN, EVQ_EN_WIDTH);
-
-	__RANGECHCK(i, EVQ_SIZE_WIDTH);
-	__RANGECHCK(buf_base_id, EVQ_BUF_BASE_ID_WIDTH);
-	__RANGECHCK(1, EVQ_EN_WIDTH);
-
-	/* if !enable then only evq needs to be correct, although valid
-	 * values need to be passed in for other arguments to prevent
-	 * assertions */
-
-	val = ((i << EVQ_SIZE_LBN) | (buf_base_id << EVQ_BUF_BASE_ID_LBN) |
-	       (enable ? (1 << EVQ_EN_LBN) : 0));
-
-	EFHW_ASSERT(evq < nic->num_evqs);
-
-	offset = EVQ_PTR_TBL_CHAR_OFST;
-	offset += evq * FALCON_REGISTER128;
-
-	EFHW_TRACE("%s: evq %u en=%x:buf=%x:size=%x->%x at %lx",
-		   __func__, evq, enable, buf_base_id, evq_size, val,
-		   offset);
-
-	/* Falcon requires 128 bit atomic access for this register */
-	FALCON_LOCK_LOCK(nic);
-	falcon_write_qq(efhw_kva + offset, val, FALCON_ATOMIC_PTR_TBL_REG);
-	mmiowb();
-	FALCON_LOCK_UNLOCK(nic);
-
-	/* caller must wait for an update done event before writing any more
-	   table entries */
-
-	return;
-}
-
-void
-falcon_nic_evq_ack(struct efhw_nic *nic,
-		   uint evq,	/* evq id */
-		   uint rptr,	/* new read pointer update */
-		   bool wakeup	/* request a wakeup event if ptr's != */
-    )
-{
-	uint val;
-	ulong offset;
-	volatile char __iomem *efhw_kva = EFHW_KVA(nic);
-
-	EFHW_BUILD_ASSERT(FALCON_EVQ_CHAR == 4);
-
-	__DWCHCK(EVQ_RPTR_LBN, EVQ_RPTR_WIDTH);
-	__RANGECHCK(rptr, EVQ_RPTR_WIDTH);
-
-	val = (rptr << EVQ_RPTR_LBN);
-
-	EFHW_ASSERT(evq < nic->num_evqs);
-
-	if (evq < FALCON_EVQ_CHAR) {
-		offset = EVQ_RPTR_REG_KER_OFST;
-		offset += evq * FALCON_REGISTER128;
-
-		EFHW_ASSERT(!wakeup);	/* don't try this at home */
-	} else {
-		offset = EVQ_RPTR_REG_OFST + (FALCON_EVQ_CHAR *
-					      FALCON_REGISTER128);
-		offset += (evq - FALCON_EVQ_CHAR) * FALCON_REGISTER128;
-
-		/* nothing to do for interruptless event queues which do
-		 * not want a wakeup */
-		if (evq != FALCON_EVQ_CHAR && !wakeup)
-			return;
-	}
-
-	EFHW_TRACE("%s: %x %x %x->%x", __func__, evq, rptr, wakeup, val);
-
-	writel(val, efhw_kva + offset);
-	mmiowb();
-}
-
-/*---------------------------------------------------------------------------*/
-
-static inline void
-falcon_drv_ev(struct efhw_nic *nic, uint64_t data, uint qid)
-{
-	FALCON_LOCK_DECL;
-	volatile char __iomem *efhw_kva = EFHW_KVA(nic);
-
-	/* send an event from one driver to the other */
-	EFHW_BUILD_ASSERT(DRV_EV_REG_KER_OFST == DRV_EV_REG_OFST);
-	EFHW_BUILD_ASSERT(DRV_EV_DATA_LBN == 0);
-	EFHW_BUILD_ASSERT(DRV_EV_DATA_WIDTH == 64);
-	EFHW_BUILD_ASSERT(DRV_EV_QID_LBN == 64);
-	EFHW_BUILD_ASSERT(DRV_EV_QID_WIDTH == 12);
-
-	FALCON_LOCK_LOCK(nic);
-	falcon_write_qq(efhw_kva + DRV_EV_REG_OFST, data, qid);
-	mmiowb();
-	FALCON_LOCK_UNLOCK(nic);
-}
-
-_DEBUG_SYM_ void
-falcon_ab_timer_tbl_set(struct efhw_nic *nic,
-			uint evq,	/* timer id */
-			uint mode,	/* mode bits */
-			uint countdown /* counting value to set */)
-{
-	FALCON_LOCK_DECL;
-	uint val;
-	ulong offset;
-	volatile char __iomem *efhw_kva = EFHW_KVA(nic);
-
-	EFHW_BUILD_ASSERT(TIMER_VAL_LBN == 0);
-
-	__DWCHCK(TIMER_MODE_LBN, TIMER_MODE_WIDTH);
-	__DWCHCK(TIMER_VAL_LBN, TIMER_VAL_WIDTH);
-
-	__RANGECHCK(mode, TIMER_MODE_WIDTH);
-	__RANGECHCK(countdown, TIMER_VAL_WIDTH);
-
-	val = ((mode << TIMER_MODE_LBN) | (countdown << TIMER_VAL_LBN));
-
-	if (evq < FALCON_EVQ_CHAR) {
-		offset = TIMER_CMD_REG_KER_OFST;
-		offset += evq * EFHW_8K;	/* PAGE mapped register */
-	} else {
-		offset = TIMER_TBL_OFST;
-		offset += evq * FALCON_REGISTER128;
-	}
-	EFHW_ASSERT(evq < nic->num_evqs);
-
-	EFHW_TRACE("%s: evq %u mode %x (%s) time %x -> %08x",
-		   __func__, evq, mode,
-		   mode == 0 ? "DISABLE" :
-		   mode == 1 ? "IMMED" :
-		   mode == 2 ? (evq < 5 ? "HOLDOFF" : "RX_TRIG") :
-		   "<BAD>", countdown, val);
-
-	/* Falcon requires 128 bit atomic access for this register when
-	 * accessed from the driver. User access to timers is paged mapped
-	 */
-	FALCON_LOCK_LOCK(nic);
-	falcon_write_qq(efhw_kva + offset, val, FALCON_ATOMIC_TIMER_CMD_REG);
-	mmiowb();
-	FALCON_LOCK_UNLOCK(nic);
-	return;
-}
-
-
-/*--------------------------------------------------------------------
- *
- * Rate pacing - Low level interface
- *
- *--------------------------------------------------------------------*/
-void falcon_nic_pace(struct efhw_nic *nic, uint dmaq, uint pace)
-{
-	/* Pace specified in 2^(units of microseconds). This is the minimum
-	   additional delay imposed over and above the IPG.
-
-	   Pacing only available on the virtual interfaces
-	 */
-	FALCON_LOCK_DECL;
-	volatile char __iomem *efhw_kva = EFHW_KVA(nic);
-	ulong offset;
-
-	if (pace > 20)
-		pace = 20;	/* maxm supported value */
-
-	__DWCHCK(TX_PACE_LBN, TX_PACE_WIDTH);
-	__RANGECHCK(pace, TX_PACE_WIDTH);
-
-	switch (nic->devtype.variant) {
-	case 'A':
-		EFHW_ASSERT(dmaq >= TX_PACE_TBL_FIRST_QUEUE_A1);
-		offset = TX_PACE_TBL_A1_OFST;
-		offset += (dmaq - TX_PACE_TBL_FIRST_QUEUE_A1) * 16;
-		break;
-	case 'B':
-		/* Would be nice to assert this, but as dmaq is unsigned and
-		 * TX_PACE_TBL_FIRST_QUEUE_B0 is 0, it makes no sense
-		 * EFHW_ASSERT(dmaq >= TX_PACE_TBL_FIRST_QUEUE_B0);
-		 */
-		offset = TX_PACE_TBL_B0_OFST;
-		offset += (dmaq - TX_PACE_TBL_FIRST_QUEUE_B0) * 16;
-		break;
-	default:
-		EFHW_ASSERT(0);
-		offset = 0;
-		break;
-	}
-
-	/* Falcon requires 128 bit atomic access for this register */
-	FALCON_LOCK_LOCK(nic);
-	falcon_write_qq(efhw_kva + offset, pace, FALCON_ATOMIC_PACE_REG);
-	mmiowb();
-	FALCON_LOCK_UNLOCK(nic);
-
-	EFHW_TRACE("%s: txq %d offset=%lx pace=2^%x",
-		   __func__, dmaq, offset, pace);
-}
-
-/*--------------------------------------------------------------------
- *
- * Interrupt - Low level interface
- *
- *--------------------------------------------------------------------*/
-
-static void falcon_nic_handle_fatal_int(struct efhw_nic *nic)
-{
-	FALCON_LOCK_DECL;
-	volatile char __iomem *offset;
-	volatile char __iomem *efhw_kva = EFHW_KVA(nic);
-	uint64_t val;
-
-	offset = (efhw_kva + FATAL_INTR_REG_OFST);
-
-	/* Falcon requires 32 bit atomic access for this register */
-	FALCON_LOCK_LOCK(nic);
-	val = readl(offset);
-	FALCON_LOCK_UNLOCK(nic);
-
-	/* ?? BUG3249 - need to disable illegal address interrupt */
-	/* ?? BUG3114 - need to backport interrupt storm protection code */
-	EFHW_ERR("fatal interrupt: %s%s%s%s%s%s%s%s%s%s%s%s[%" PRIx64 "]",
-		 val & (1 << PCI_BUSERR_INT_CHAR_LBN) ? "PCI-bus-error " : "",
-		 val & (1 << SRAM_OOB_INT_CHAR_LBN) ? "SRAM-oob " : "",
-		 val & (1 << BUFID_OOB_INT_CHAR_LBN) ? "bufid-oob " : "",
-		 val & (1 << MEM_PERR_INT_CHAR_LBN) ? "int-parity " : "",
-		 val & (1 << RBUF_OWN_INT_CHAR_LBN) ? "rx-bufid-own " : "",
-		 val & (1 << TBUF_OWN_INT_CHAR_LBN) ? "tx-bufid-own " : "",
-		 val & (1 << RDESCQ_OWN_INT_CHAR_LBN) ? "rx-desc-own " : "",
-		 val & (1 << TDESCQ_OWN_INT_CHAR_LBN) ? "tx-desc-own " : "",
-		 val & (1 << EVQ_OWN_INT_CHAR_LBN) ? "evq-own " : "",
-		 val & (1 << EVFF_OFLO_INT_CHAR_LBN) ? "evq-fifo " : "",
-		 val & (1 << ILL_ADR_INT_CHAR_LBN) ? "ill-addr " : "",
-		 val & (1 << SRM_PERR_INT_CHAR_LBN) ? "sram-parity " : "", val);
-}
-
-static void falcon_nic_interrupt_hw_enable(struct efhw_nic *nic)
-{
-	FALCON_LOCK_DECL;
-	uint val;
-	volatile char __iomem *offset;
-	volatile char __iomem *efhw_kva = EFHW_KVA(nic);
-
-	EFHW_BUILD_ASSERT(DRV_INT_EN_CHAR_WIDTH == 1);
-
-	if (nic->flags & NIC_FLAG_NO_INTERRUPT)
-		return;
-
-	offset = (efhw_kva + INT_EN_REG_CHAR_OFST);
-	val = 1 << DRV_INT_EN_CHAR_LBN;
-
-	EFHW_NOTICE("%s: %x -> %x", __func__, (int)(offset - efhw_kva),
-		    val);
-
-	/* Falcon requires 128 bit atomic access for this register */
-	FALCON_LOCK_LOCK(nic);
-	falcon_write_qq(offset, val, FALCON_ATOMIC_INT_EN_REG);
-	mmiowb();
-	FALCON_LOCK_UNLOCK(nic);
-}
-
-static void falcon_nic_interrupt_hw_disable(struct efhw_nic *nic)
-{
-	FALCON_LOCK_DECL;
-	volatile char __iomem *offset;
-	volatile char __iomem *efhw_kva = EFHW_KVA(nic);
-
-	EFHW_BUILD_ASSERT(SRAM_PERR_INT_KER_WIDTH == 1);
-	EFHW_BUILD_ASSERT(DRV_INT_EN_KER_LBN == 0);
-	EFHW_BUILD_ASSERT(SRAM_PERR_INT_CHAR_WIDTH == 1);
-	EFHW_BUILD_ASSERT(DRV_INT_EN_CHAR_LBN == 0);
-	EFHW_BUILD_ASSERT(SRAM_PERR_INT_KER_LBN == SRAM_PERR_INT_CHAR_LBN);
-	EFHW_BUILD_ASSERT(DRV_INT_EN_KER_LBN == DRV_INT_EN_CHAR_LBN);
-
-	if (nic->flags & NIC_FLAG_NO_INTERRUPT)
-		return;
-
-	offset = (efhw_kva + INT_EN_REG_CHAR_OFST);
-
-	EFHW_NOTICE("%s: %x -> 0", __func__, (int)(offset - efhw_kva));
-
-	/* Falcon requires 128 bit atomic access for this register */
-	FALCON_LOCK_LOCK(nic);
-	falcon_write_qq(offset, 0, FALCON_ATOMIC_INT_EN_REG);
-	mmiowb();
-	FALCON_LOCK_UNLOCK(nic);
-}
-
-static void falcon_nic_irq_addr_set(struct efhw_nic *nic, dma_addr_t dma_addr)
-{
-	FALCON_LOCK_DECL;
-	volatile char __iomem *offset;
-	volatile char __iomem *efhw_kva = EFHW_KVA(nic);
-
-	offset = (efhw_kva + INT_ADR_REG_CHAR_OFST);
-
-	EFHW_NOTICE("%s: %x -> " DMA_ADDR_T_FMT, __func__,
-		    (int)(offset - efhw_kva), dma_addr);
-
-	/* Falcon requires 128 bit atomic access for this register */
-	FALCON_LOCK_LOCK(nic);
-	falcon_write_qq(offset, dma_addr, FALCON_ATOMIC_INT_ADR_REG);
-	mmiowb();
-	FALCON_LOCK_UNLOCK(nic);
-}
-
-
-/*--------------------------------------------------------------------
- *
- * RXDP - low level interface
- *
- *--------------------------------------------------------------------*/
-
-void
-falcon_nic_set_rx_usr_buf_size(struct efhw_nic *nic, int usr_buf_bytes)
-{
-	FALCON_LOCK_DECL;
-	volatile char __iomem *efhw_kva = EFHW_KVA(nic);
-	uint64_t val, val2, usr_buf_size = usr_buf_bytes / 32;
-	int rubs_lbn, rubs_width, roec_lbn;
-
-	EFHW_BUILD_ASSERT(RX_CFG_REG_OFST == RX_CFG_REG_KER_OFST);
-
-	switch (nic->devtype.variant) {
-	default:
-		EFHW_ASSERT(0);
-		/* Fall-through to avoid compiler warnings. */
-	case 'A':
-		rubs_lbn = RX_USR_BUF_SIZE_A1_LBN;
-		rubs_width = RX_USR_BUF_SIZE_A1_WIDTH;
-		roec_lbn = RX_OWNERR_CTL_A1_LBN;
-		break;
-	case 'B':
-		rubs_lbn = RX_USR_BUF_SIZE_B0_LBN;
-		rubs_width = RX_USR_BUF_SIZE_B0_WIDTH;
-		roec_lbn = RX_OWNERR_CTL_B0_LBN;
-		break;
-	}
-
-	__DWCHCK(rubs_lbn, rubs_width);
-	__QWCHCK(roec_lbn, 1);
-	__RANGECHCK(usr_buf_size, rubs_width);
-
-	/* Falcon requires 128 bit atomic access for this register */
-	FALCON_LOCK_LOCK(nic);
-	falcon_read_qq(efhw_kva + RX_CFG_REG_OFST, &val, &val2);
-
-	val &= ~((__FALCON_MASK64(rubs_width)) << rubs_lbn);
-	val |= (usr_buf_size << rubs_lbn);
-
-	/* shouldn't be needed for a production driver */
-	val |= ((uint64_t) 1 << roec_lbn);
-
-	falcon_write_qq(efhw_kva + RX_CFG_REG_OFST, val, val2);
-	mmiowb();
-	FALCON_LOCK_UNLOCK(nic);
-}
-EXPORT_SYMBOL(falcon_nic_set_rx_usr_buf_size);
-
-
-/*--------------------------------------------------------------------
- *
- * TXDP - low level interface
- *
- *--------------------------------------------------------------------*/
-
-_DEBUG_SYM_ void falcon_nic_tx_cfg(struct efhw_nic *nic, int unlocked)
-{
-	FALCON_LOCK_DECL;
-	volatile char __iomem *efhw_kva = EFHW_KVA(nic);
-	uint64_t val1, val2;
-
-	EFHW_BUILD_ASSERT(TX_CFG_REG_OFST == TX_CFG_REG_KER_OFST);
-	__DWCHCK(TX_OWNERR_CTL_LBN, TX_OWNERR_CTL_WIDTH);
-	__DWCHCK(TX_NON_IP_DROP_DIS_LBN, TX_NON_IP_DROP_DIS_WIDTH);
-
-	FALCON_LOCK_LOCK(nic);
-	falcon_read_qq(efhw_kva + TX_CFG_REG_OFST, &val1, &val2);
-
-	/* Will flag fatal interrupts on owner id errors. This should not be
-	   on for production code because there is otherwise a denial of
-	   serivce attack possible */
-	val1 |= (1 << TX_OWNERR_CTL_LBN);
-
-	/* Setup user queue TCP/UDP only packet security */
-	if (unlocked)
-		val1 |= (1 << TX_NON_IP_DROP_DIS_LBN);
-	else
-		val1 &= ~(1 << TX_NON_IP_DROP_DIS_LBN);
-
-	falcon_write_qq(efhw_kva + TX_CFG_REG_OFST, val1, val2);
-	mmiowb();
-	FALCON_LOCK_UNLOCK(nic);
-}
-
-/*--------------------------------------------------------------------
- *
- * Random thresholds - Low level interface (Would like these to be op
- * defaults wherever possible)
- *
- *--------------------------------------------------------------------*/
-
-void falcon_nic_pace_cfg(struct efhw_nic *nic, int fb_base, int bin_thresh)
-{
-	FALCON_LOCK_DECL;
-	volatile char __iomem *efhw_kva = EFHW_KVA(nic);
-	unsigned offset = 0;
-	uint64_t val;
-
-	__DWCHCK(TX_PACE_FB_BASE_LBN, TX_PACE_FB_BASE_WIDTH);
-	__DWCHCK(TX_PACE_BIN_TH_LBN, TX_PACE_BIN_TH_WIDTH);
-
-	switch (nic->devtype.variant) {
-	case 'A':  offset = TX_PACE_REG_A1_OFST;  break;
-	case 'B':  offset = TX_PACE_REG_B0_OFST;  break;
-	default:   EFHW_ASSERT(0);                break;
-	}
-
-	val = (0x15 << TX_PACE_SB_NOTAF_LBN);
-	val |= (0xb << TX_PACE_SB_AF_LBN);
-
-	val |= ((fb_base & __FALCON_MASK64(TX_PACE_FB_BASE_WIDTH)) <<
-		 TX_PACE_FB_BASE_LBN);
-	val |= ((bin_thresh & __FALCON_MASK64(TX_PACE_BIN_TH_WIDTH)) <<
-		 TX_PACE_BIN_TH_LBN);
-
-	/* Falcon requires 128 bit atomic access for this register */
-	FALCON_LOCK_LOCK(nic);
-	falcon_write_qq(efhw_kva + offset, val, 0);
-	mmiowb();
-	FALCON_LOCK_UNLOCK(nic);
-}
-
-
-/**********************************************************************
- * Implementation of the HAL. ********************************************
- **********************************************************************/
-
-/*----------------------------------------------------------------------------
- *
- * Initialisation and configuration discovery
- *
- *---------------------------------------------------------------------------*/
-
-static int falcon_nic_init_irq_channel(struct efhw_nic *nic, int enable)
-{
-	/* create a buffer for the irq channel */
-	int rc;
-
-	if (enable) {
-		rc = efhw_iopage_alloc(nic, &nic->irq_iobuff);
-		if (rc < 0)
-			return rc;
-
-		falcon_nic_irq_addr_set(nic,
-				efhw_iopage_dma_addr(&nic->irq_iobuff));
-	} else {
-		if (efhw_iopage_is_valid(&nic->irq_iobuff))
-			efhw_iopage_free(nic, &nic->irq_iobuff);
-
-		efhw_iopage_mark_invalid(&nic->irq_iobuff);
-		falcon_nic_irq_addr_set(nic, 0);
-	}
-
-	EFHW_TRACE("%s: %lx %sable", __func__,
-		   (unsigned long) efhw_iopage_dma_addr(&nic->irq_iobuff),
-		   enable ? "en" : "dis");
-
-	return 0;
-}
-
-static void falcon_nic_close_hardware(struct efhw_nic *nic)
-{
-	/* check we are in possession of some hardware */
-	if (!efhw_nic_have_hw(nic))
-		return;
-
-	falcon_nic_init_irq_channel(nic, 0);
-	falcon_nic_filter_dtor(nic);
-
-	EFHW_NOTICE("%s:", __func__);
-}
-
-static int
-falcon_nic_init_hardware(struct efhw_nic *nic,
-			 struct efhw_ev_handler *ev_handlers,
-			 const uint8_t *mac_addr, int non_irq_evq)
-{
-	int rc;
-
-	/* header sanity checks */
-	FALCON_ASSERT_VALID();
-
-	/* Initialise supporting modules */
-	rc = falcon_nic_filter_ctor(nic);
-	if (rc < 0)
-		return rc;
-
-#if FALCON_USE_SHADOW_BUFFER_TABLE
-	CI_ZERO_ARRAY(_falcon_buffer_table, FALCON_BUFFER_TBL_NUM);
-#endif
-
-	/* Initialise the top level hardware blocks */
-	memcpy(nic->mac_addr, mac_addr, ETH_ALEN);
-
-	EFHW_TRACE("%s:", __func__);
-
-	/* nic.c:efhw_nic_init marks all the interrupt units as unused.
-
-	   ?? TODO we should be able to request the non-interrupting event
-	   queue and the net driver's (for a net driver that is using libefhw)
-	   additional RSS queues here.
-
-	   Result would be that that net driver could call
-	   nic.c:efhw_nic_allocate_common_hardware_resources() and that the
-	   IFDEF FALCON's can be removed from
-	   nic.c:efhw_nic_allocate_common_hardware_resources()
-	 */
-	nic->irq_unit = INT_EN_REG_CHAR_OFST;
-
-	/*****************************************************************
-	 * The rest of this function deals with initialization of the NICs
-	 * hardware (as opposed to the initialization of the
-	 * struct efhw_nic data structure */
-
-	/* char driver grabs SRM events onto the non interrupting
-	 * event queue */
-	falcon_nic_srm_upd_evq(nic, non_irq_evq);
-
-	/* RXDP tweaks */
-
-	/* ?? bug2396 rx_cfg should be ok so long as the net driver
-	 * always pushes buffers big enough for the link MTU */
-
-	/* set the RX buffer cutoff size to be the same as PAGE_SIZE.
-	 * Use this value when we think that there will be a lot of
-	 * jumbo frames.
-	 *
-	 * The default value 1600 is useful when packets are small,
-	 * but would means that jumbo frame RX queues would need more
-	 * descriptors pushing */
-	falcon_nic_set_rx_usr_buf_size(nic, FALCON_RX_USR_BUF_SIZE);
-
-	/* TXDP tweaks */
-	/* ?? bug2396 looks ok */
-	falcon_nic_tx_cfg(nic, /*unlocked(for non-UDP/TCP)= */ 0);
-	falcon_nic_pace_cfg(nic, 4, 2);
-
-	/* ?? bug2396
-	 * netdriver must load first or else must RMW this register */
-	falcon_nic_rx_filter_ctl_set(nic, RX_FILTER_CTL_SRCH_LIMIT_TCP_FULL,
-				     RX_FILTER_CTL_SRCH_LIMIT_TCP_WILD,
-				     RX_FILTER_CTL_SRCH_LIMIT_UDP_FULL,
-				     RX_FILTER_CTL_SRCH_LIMIT_UDP_WILD);
-
-	if (!(nic->flags & NIC_FLAG_NO_INTERRUPT)) {
-		rc = efhw_keventq_ctor(nic, FALCON_EVQ_CHAR,
-				       &nic->interrupting_evq, ev_handlers);
-		if (rc < 0) {
-			EFHW_ERR("%s: efhw_keventq_ctor() failed (%d) evq=%d",
-				 __func__, rc, FALCON_EVQ_CHAR);
-			return rc;
-		}
-	}
-	rc = efhw_keventq_ctor(nic, non_irq_evq,
-			       &nic->non_interrupting_evq, NULL);
-	if (rc < 0) {
-		EFHW_ERR("%s: efhw_keventq_ctor() failed (%d) evq=%d",
-			 __func__, rc, non_irq_evq);
-		return rc;
-	}
-
-	/* allocate IRQ channel */
-	rc = falcon_nic_init_irq_channel(nic, 1);
-	/* ignore failure at user-level for eftest */
-	if ((rc < 0) && !(nic->options & NIC_OPT_EFTEST))
-		return rc;
-
-	return 0;
-}
-
-/*--------------------------------------------------------------------
- *
- * Interrupt
- *
- *--------------------------------------------------------------------*/
-
-static void
-falcon_nic_interrupt_enable(struct efhw_nic *nic)
-{
-	struct efhw_keventq *q;
-	unsigned rdptr;
-
-	if (nic->flags & NIC_FLAG_NO_INTERRUPT)
-		return;
-
-	/* Enable driver interrupts */
-	EFHW_NOTICE("%s: enable master interrupt", __func__);
-	falcon_nic_interrupt_hw_enable(nic);
-
-	/* An interrupting eventq must start of day ack its read pointer */
-	q = &nic->interrupting_evq;
-	rdptr = EFHW_EVENT_OFFSET(q, q, 1) / sizeof(efhw_event_t);
-	falcon_nic_evq_ack(nic, FALCON_EVQ_CHAR, rdptr, false);
-	EFHW_NOTICE("%s: ACK evq[%d]:%x", __func__,
-		    FALCON_EVQ_CHAR, rdptr);
-}
-
-static void falcon_nic_interrupt_disable(struct efhw_nic *nic)
-{
-	/* NB. No need to check for NIC_FLAG_NO_INTERRUPT, as
-	 ** falcon_nic_interrupt_hw_disable() will do it. */
-	falcon_nic_interrupt_hw_disable(nic);
-}
-
-static void
-falcon_nic_set_interrupt_moderation(struct efhw_nic *nic, int evq,
-				    uint32_t val)
-{
-	if (evq < 0)
-		evq = FALCON_EVQ_CHAR;
-
-	falcon_ab_timer_tbl_set(nic, evq, TIMER_MODE_INT_HLDOFF, val / 5);
-}
-
-static inline void legacy_irq_ack(struct efhw_nic *nic)
-{
-	EFHW_ASSERT(!(nic->flags & NIC_FLAG_NO_INTERRUPT));
-
-	if (!(nic->flags & NIC_FLAG_MSI)) {
-		writel(1, EFHW_KVA(nic) + INT_ACK_REG_CHAR_A1_OFST);
-		mmiowb();
-		/* ?? FIXME: We should be doing a read here to ensure IRQ is
-		 * thoroughly acked before we return from ISR. */
-	}
-}
-
-static int falcon_nic_interrupt(struct efhw_nic *nic)
-{
-	uint32_t *syserr_ptr =
-	    (uint32_t *) efhw_iopage_ptr(&nic->irq_iobuff);
-	int handled = 0;
-	int done_ack = 0;
-
-	EFHW_ASSERT(!(nic->flags & NIC_FLAG_NO_INTERRUPT));
-	EFHW_ASSERT(syserr_ptr);
-
-	/* FIFO fill level interrupt - just log it. */
-	if (unlikely(*(syserr_ptr + (DW0_OFST / 4)))) {
-		EFHW_WARN("%s: *** FIFO *** %x", __func__,
-			  *(syserr_ptr + (DW0_OFST / 4)));
-		*(syserr_ptr + (DW0_OFST / 4)) = 0;
-		handled++;
-	}
-
-	/* Fatal interrupts. */
-	if (unlikely(*(syserr_ptr + (DW2_OFST / 4)))) {
-		*(syserr_ptr + (DW2_OFST / 4)) = 0;
-		falcon_nic_handle_fatal_int(nic);
-		handled++;
-	}
-
-	/* Event queue interrupt.  For legacy interrupts we have to check
-	 * that the interrupt is for us, because it could be shared. */
-	if (*(syserr_ptr + (DW1_OFST / 4))) {
-		*(syserr_ptr + (DW1_OFST / 4)) = 0;
-		/* ACK must come before callback to handler fn. */
-		legacy_irq_ack(nic);
-		done_ack = 1;
-		handled++;
-		if (nic->irq_handler)
-			nic->irq_handler(nic, 0);
-	}
-
-	if (unlikely(!done_ack)) {
-		if (!handled)
-			/* Shared interrupt line (hopefully). */
-			return 0;
-		legacy_irq_ack(nic);
-	}
-
-	EFHW_TRACE("%s: handled %d", __func__, handled);
-	return 1;
-}
-
-/*--------------------------------------------------------------------
- *
- * Event Management - and SW event posting
- *
- *--------------------------------------------------------------------*/
-
-static void
-falcon_nic_event_queue_enable(struct efhw_nic *nic, uint evq, uint evq_size,
-			      dma_addr_t q_base_addr,	/* not used */
-			      uint buf_base_id, int interrupting)
-{
-	EFHW_ASSERT(nic);
-
-	/* Whether or not queue has an interrupt depends on
-	 * instance number and h/w variant, so [interrupting] is
-	 * ignored.
-	 */
-	falcon_ab_timer_tbl_set(nic, evq, 0/*disable*/, 0);
-
-	falcon_nic_evq_ptr_tbl(nic, evq, 1, buf_base_id, evq_size);
-	EFHW_TRACE("%s: enable evq %u size %u", __func__, evq, evq_size);
-}
-
-static void
-falcon_nic_event_queue_disable(struct efhw_nic *nic, uint evq, int timer_only)
-{
-	EFHW_ASSERT(nic);
-
-	falcon_ab_timer_tbl_set(nic, evq, 0 /* disable */ , 0);
-
-	if (!timer_only)
-		falcon_nic_evq_ptr_tbl(nic, evq, 0, 0, 0);
-	EFHW_TRACE("%s: disenable evq %u", __func__, evq);
-}
-
-static void
-falcon_nic_wakeup_request(struct efhw_nic *nic, dma_addr_t q_base_addr,
-			  int next_i, int evq)
-{
-	EFHW_ASSERT(evq > FALCON_EVQ_CHAR);
-	falcon_nic_evq_ack(nic, evq, next_i, true);
-	EFHW_TRACE("%s: evq %d next_i %d", __func__, evq, next_i);
-}
-
-static void falcon_nic_sw_event(struct efhw_nic *nic, int data, int evq)
-{
-	uint64_t ev_data = data;
-
-	ev_data &= ~FALCON_EVENT_CODE_MASK;
-	ev_data |= FALCON_EVENT_CODE_SW;
-
-	falcon_drv_ev(nic, ev_data, evq);
-	EFHW_NOTICE("%s: evq[%d]->%x", __func__, evq, data);
-}
-
-
-/*--------------------------------------------------------------------
- *
- * Buffer table - helpers
- *
- *--------------------------------------------------------------------*/
-
-#define FALCON_LAZY_COMMIT_HWM (FALCON_BUFFER_UPD_MAX - 16)
-
-/* Note re.:
- *  falcon_nic_buffer_table_lazy_commit(struct efhw_nic *nic)
- *  falcon_nic_buffer_table_update_poll(struct efhw_nic *nic)
- *  falcon_nic_buffer_table_confirm(struct efhw_nic *nic)
- * -- these are no-ops in the user-level driver because it would need to
- * coordinate with the real driver on the number of outstanding commits.
- *
- * An exception is made for eftest apps, which manage the hardware without
- * using the char driver.
- */
-
-static inline void falcon_nic_buffer_table_lazy_commit(struct efhw_nic *nic)
-{
-	/* Do nothing if operating in synchronous mode. */
-	if (!nic->irq_handler)
-		return;
-}
-
-static inline void falcon_nic_buffer_table_update_poll(struct efhw_nic *nic)
-{
-	FALCON_LOCK_DECL;
-	int count = 0, rc = 0;
-
-	/* We can be called here early days */
-	if (!nic->irq_handler)
-		return;
-
-	/* If we need to gather buffer update events then poll the
-	   non-interrupting event queue */
-
-	/* For each _buffer_table_commit there will be an update done
-	   event. We don't keep track of how many buffers each commit has
-	   committed, just make sure that all the expected events have been
-	   gathered */
-	FALCON_LOCK_LOCK(nic);
-
-	EFHW_TRACE("%s: %d", __func__, nic->buf_commit_outstanding);
-
-	while (nic->buf_commit_outstanding > 0) {
-		/* we're not expecting to handle any events that require
-		 * upcalls into the core driver */
-		struct efhw_ev_handler handler;
-		memset(&handler, 0, sizeof(handler));
-		nic->non_interrupting_evq.ev_handlers = &handler;
-		rc = efhw_keventq_poll(nic, &nic->non_interrupting_evq);
-		nic->non_interrupting_evq.ev_handlers = NULL;
-
-		if (rc < 0) {
-			EFHW_ERR("%s: poll ERROR (%d:%d) ***** ",
-				 __func__, rc,
-				 nic->buf_commit_outstanding);
-			goto out;
-		}
-
-		FALCON_LOCK_UNLOCK(nic);
-
-		if (count++)
-			udelay(1);
-
-		if (count > 1000) {
-			EFHW_WARN("%s: poll Timeout ***** (%d)", __func__,
-				  nic->buf_commit_outstanding);
-			nic->buf_commit_outstanding = 0;
-			return;
-		}
-		FALCON_LOCK_LOCK(nic);
-	}
-
-out:
-	FALCON_LOCK_UNLOCK(nic);
-	return;
-}
-
-void falcon_nic_buffer_table_confirm(struct efhw_nic *nic)
-{
-	/* confirm buffer table updates - should be used for items where
-	   loss of data would be unacceptable. E.g for the buffers that back
-	   an event or DMA queue */
-	FALCON_LOCK_DECL;
-
-	/* Do nothing if operating in synchronous mode. */
-	if (!nic->irq_handler)
-		return;
-
-	FALCON_LOCK_LOCK(nic);
-
-	_falcon_nic_buffer_table_commit(nic);
-
-	FALCON_LOCK_UNLOCK(nic);
-
-	falcon_nic_buffer_table_update_poll(nic);
-}
-
-/*--------------------------------------------------------------------
- *
- * Buffer table - API
- *
- *--------------------------------------------------------------------*/
-
-static void
-falcon_nic_buffer_table_clear(struct efhw_nic *nic, int buffer_id, int num)
-{
-	FALCON_LOCK_DECL;
-	FALCON_LOCK_LOCK(nic);
-	_falcon_nic_buffer_table_clear(nic, buffer_id, num);
-	FALCON_LOCK_UNLOCK(nic);
-}
-
-static void
-falcon_nic_buffer_table_set(struct efhw_nic *nic, dma_addr_t dma_addr,
-			    uint bufsz, uint region,
-			    int own_id, int buffer_id)
-{
-	FALCON_LOCK_DECL;
-
-	EFHW_ASSERT(region < FALCON_REGION_NUM);
-
-	EFHW_ASSERT((bufsz == EFHW_4K) ||
-		    (bufsz == EFHW_8K && FALCON_BUFFER_TABLE_FULL_MODE));
-
-	falcon_nic_buffer_table_update_poll(nic);
-
-	FALCON_LOCK_LOCK(nic);
-
-	_falcon_nic_buffer_table_set(nic, dma_addr, bufsz, region, own_id,
-				     buffer_id);
-
-	falcon_nic_buffer_table_lazy_commit(nic);
-
-	FALCON_LOCK_UNLOCK(nic);
-}
-
-void
-falcon_nic_buffer_table_set_n(struct efhw_nic *nic, int buffer_id,
-			      dma_addr_t dma_addr, uint bufsz, uint region,
-			      int n_pages, int own_id)
-{
-	/* used to set up a contiguous range of buffers */
-	FALCON_LOCK_DECL;
-
-	EFHW_ASSERT(region < FALCON_REGION_NUM);
-
-	EFHW_ASSERT((bufsz == EFHW_4K) ||
-		    (bufsz == EFHW_8K && FALCON_BUFFER_TABLE_FULL_MODE));
-
-	while (n_pages--) {
-
-		falcon_nic_buffer_table_update_poll(nic);
-
-		FALCON_LOCK_LOCK(nic);
-
-		_falcon_nic_buffer_table_set(nic, dma_addr, bufsz, region,
-					     own_id, buffer_id++);
-
-		falcon_nic_buffer_table_lazy_commit(nic);
-
-		FALCON_LOCK_UNLOCK(nic);
-
-		dma_addr += bufsz;
-	}
-}
-
-/*--------------------------------------------------------------------
- *
- * DMA Queues - mid level API
- *
- *--------------------------------------------------------------------*/
-
-#if BUG5302_WORKAROUND
-
-/* Tx queues can get stuck if the software write pointer is set to an index
- * beyond the configured size of the queue, such that they will not flush.
- * This code can be run before attempting a flush; it will detect the bogus
- * value and reset it.  This fixes most instances of this problem, although
- * sometimes it does not work, or we may not detect it in the first place,
- * if the out-of-range value was replaced by an in-range value earlier.
- * (In those cases we have to apply a bigger hammer later, if we see that
- * the queue is still not flushing.)
- */
-static void
-falcon_check_for_bogus_tx_dma_wptr(struct efhw_nic *nic, uint dmaq)
-{
-	FALCON_LOCK_DECL;
-	uint64_t val_low64, val_high64;
-	uint64_t size, hwptr, swptr, val;
-	volatile char __iomem *efhw_kva = EFHW_KVA(nic);
-	ulong offset = falcon_dma_tx_q_offset(nic, dmaq);
-
-	/* Falcon requires 128 bit atomic access for this register */
-	FALCON_LOCK_LOCK(nic);
-	falcon_read_qq(efhw_kva + offset, &val_low64, &val_high64);
-	FALCON_LOCK_UNLOCK(nic);
-
-	size = (val_low64 >> TX_DESCQ_SIZE_LBN)
-	    & __FALCON_MASK64(TX_DESCQ_SIZE_WIDTH);
-	size = (1 << size) * 512;
-	hwptr = (val_high64 >> __DW3(TX_DESCQ_HW_RPTR_LBN))
-	    & __FALCON_MASK64(TX_DESCQ_HW_RPTR_WIDTH);
-	swptr = (val_low64 >> TX_DESCQ_SW_WPTR_LBN)
-	    & __FALCON_MASK64(__LW2(TX_DESCQ_SW_WPTR_LBN));
-	val = (val_high64)
-	    &
-	    __FALCON_MASK64(__DW3
-			    (TX_DESCQ_SW_WPTR_LBN + TX_DESCQ_SW_WPTR_WIDTH));
-	val = val << __LW2(TX_DESCQ_SW_WPTR_LBN);
-	swptr = swptr | val;
-
-	if (swptr >= size) {
-		EFHW_WARN("Resetting bad write pointer for TXQ[%d]", dmaq);
-		writel((uint32_t) ((hwptr + 0) & (size - 1)),
-		       efhw_kva + falcon_tx_dma_page_addr(dmaq) + 12);
-		mmiowb();
-	}
-}
-
-/* Here's that "bigger hammer": we reset all the pointers (hardware read,
- * hardware descriptor cache read, software write) to zero.
- */
-void falcon_clobber_tx_dma_ptrs(struct efhw_nic *nic, uint dmaq)
-{
-	FALCON_LOCK_DECL;
-	uint64_t val_low64, val_high64;
-	volatile char __iomem *efhw_kva = EFHW_KVA(nic);
-	ulong offset = falcon_dma_tx_q_offset(nic, dmaq);
-
-	EFHW_WARN("Recovering stuck TXQ[%d]", dmaq);
-	FALCON_LOCK_LOCK(nic);
-	falcon_read_qq(efhw_kva + offset, &val_low64, &val_high64);
-	val_high64 &= ~(__FALCON_MASK64(TX_DESCQ_HW_RPTR_WIDTH)
-			<< __DW3(TX_DESCQ_HW_RPTR_LBN));
-	val_high64 &= ~(__FALCON_MASK64(TX_DC_HW_RPTR_WIDTH)
-			<< __DW3(TX_DC_HW_RPTR_LBN));
-	falcon_write_qq(efhw_kva + offset, val_low64, val_high64);
-	mmiowb();
-	writel(0, efhw_kva + falcon_tx_dma_page_addr(dmaq) + 12);
-	mmiowb();
-	FALCON_LOCK_UNLOCK(nic);
-}
-
-#endif
-
-static inline int
-__falcon_really_flush_tx_dma_channel(struct efhw_nic *nic, uint dmaq)
-{
-	FALCON_LOCK_DECL;
-	volatile char __iomem *efhw_kva = EFHW_KVA(nic);
-	uint val;
-
-	EFHW_BUILD_ASSERT(TX_FLUSH_DESCQ_REG_KER_OFST ==
-			  TX_FLUSH_DESCQ_REG_OFST);
-
-	__DWCHCK(TX_FLUSH_DESCQ_CMD_LBN, TX_FLUSH_DESCQ_CMD_WIDTH);
-	__DWCHCK(TX_FLUSH_DESCQ_LBN, TX_FLUSH_DESCQ_WIDTH);
-	__RANGECHCK(dmaq, TX_FLUSH_DESCQ_WIDTH);
-
-	val = ((1 << TX_FLUSH_DESCQ_CMD_LBN) | (dmaq << TX_FLUSH_DESCQ_LBN));
-
-	EFHW_TRACE("TX DMA flush[%d]", dmaq);
-
-#if BUG5302_WORKAROUND
-	falcon_check_for_bogus_tx_dma_wptr(nic, dmaq);
-#endif
-
-	/* Falcon requires 128 bit atomic access for this register */
-	FALCON_LOCK_LOCK(nic);
-	falcon_write_qq(efhw_kva + TX_FLUSH_DESCQ_REG_OFST,
-			val, FALCON_ATOMIC_TX_FLUSH_DESCQ);
-
-	mmiowb();
-	FALCON_LOCK_UNLOCK(nic);
-	return 0;
-}
-
-static inline int
-__falcon_is_tx_dma_channel_flushed(struct efhw_nic *nic, uint dmaq)
-{
-	FALCON_LOCK_DECL;
-	uint64_t val_low64, val_high64;
-	uint64_t enable, flush_pending;
-	volatile char __iomem *efhw_kva = EFHW_KVA(nic);
-	ulong offset = falcon_dma_tx_q_offset(nic, dmaq);
-
-	/* Falcon requires 128 bit atomic access for this register */
-	FALCON_LOCK_LOCK(nic);
-	falcon_read_qq(efhw_kva + offset, &val_low64, &val_high64);
-	FALCON_LOCK_UNLOCK(nic);
-
-	/* should see one of three values for these 2 bits
-	 *   1, queue enabled no flush pending
-	 *	- i.e. first flush request
-	 *   2, queue enabled, flush pending
-	 *	- i.e. request to reflush before flush finished
-	 *   3, queue disabled (no flush pending)
-	 *	- flush complete
-	 */
-	__DWCHCK(TX_DESCQ_FLUSH_LBN, TX_DESCQ_FLUSH_WIDTH);
-	__DW3CHCK(TX_DESCQ_EN_LBN, TX_DESCQ_EN_WIDTH);
-	enable = val_high64 & (1 << __DW3(TX_DESCQ_EN_LBN));
-	flush_pending = val_low64 & (1 << TX_DESCQ_FLUSH_LBN);
-
-	if (enable && !flush_pending)
-		return 0;
-
-	EFHW_TRACE("%d, %s: %s, %sflush pending", dmaq, __func__,
-		   enable ? "enabled" : "disabled",
-		   flush_pending ? "" : "NO ");
-	/* still in progress */
-	if (enable && flush_pending)
-		return -EALREADY;
-
-	return -EAGAIN;
-}
-
-static int falcon_flush_tx_dma_channel(struct efhw_nic *nic, uint dmaq)
-{
-	int rc;
-	rc = __falcon_is_tx_dma_channel_flushed(nic, dmaq);
-	if (rc < 0) {
-		EFHW_WARN("%s: failed %d", __func__, rc);
-		return rc;
-	}
-	return __falcon_really_flush_tx_dma_channel(nic, dmaq);
-}
-
-static int
-__falcon_really_flush_rx_dma_channel(struct efhw_nic *nic, uint dmaq)
-{
-	FALCON_LOCK_DECL;
-	volatile char __iomem *efhw_kva = EFHW_KVA(nic);
-	uint val;
-
-	EFHW_BUILD_ASSERT(RX_FLUSH_DESCQ_REG_KER_OFST ==
-			  RX_FLUSH_DESCQ_REG_OFST);
-
-	__DWCHCK(RX_FLUSH_DESCQ_CMD_LBN, RX_FLUSH_DESCQ_CMD_WIDTH);
-	__DWCHCK(RX_FLUSH_DESCQ_LBN, RX_FLUSH_DESCQ_WIDTH);
-	__RANGECHCK(dmaq, RX_FLUSH_DESCQ_WIDTH);
-
-	val = ((1 << RX_FLUSH_DESCQ_CMD_LBN) | (dmaq << RX_FLUSH_DESCQ_LBN));
-
-	EFHW_TRACE("RX DMA flush[%d]", dmaq);
-
-	/* Falcon requires 128 bit atomic access for this register */
-	FALCON_LOCK_LOCK(nic);
-	falcon_write_qq(efhw_kva + RX_FLUSH_DESCQ_REG_OFST, val,
-			FALCON_ATOMIC_RX_FLUSH_DESCQ);
-	mmiowb();
-	FALCON_LOCK_UNLOCK(nic);
-	return 0;
-}
-
-static inline int
-__falcon_is_rx_dma_channel_flushed(struct efhw_nic *nic, uint dmaq)
-{
-	FALCON_LOCK_DECL;
-	uint64_t val;
-	volatile char __iomem *efhw_kva = EFHW_KVA(nic);
-	ulong offset = falcon_dma_rx_q_offset(nic, dmaq);
-
-	/* Falcon requires 128 bit atomic access for this register */
-	FALCON_LOCK_LOCK(nic);
-	falcon_read_q(efhw_kva + offset, &val);
-	FALCON_LOCK_UNLOCK(nic);
-
-	__DWCHCK(RX_DESCQ_EN_LBN, RX_DESCQ_EN_WIDTH);
-
-	/* is it enabled? */
-	return (val & (1 << RX_DESCQ_EN_LBN))
-	    ? 0 : -EAGAIN;
-}
-
-static int falcon_flush_rx_dma_channel(struct efhw_nic *nic, uint dmaq)
-{
-	int rc;
-	rc = __falcon_is_rx_dma_channel_flushed(nic, dmaq);
-	if (rc < 0) {
-		EFHW_ERR("%s: failed %d", __func__, rc);
-		return rc;
-	}
-	return __falcon_really_flush_rx_dma_channel(nic, dmaq);
-}
-
-/*--------------------------------------------------------------------
- *
- * Falcon specific event callbacks
- *
- *--------------------------------------------------------------------*/
-
-int
-falcon_handle_char_event(struct efhw_nic *nic, struct efhw_ev_handler *h,
-			 efhw_event_t *ev)
-{
-	EFHW_TRACE("DRIVER EVENT: "FALCON_EVENT_FMT,
-		   FALCON_EVENT_PRI_ARG(*ev));
-
-	switch (FALCON_EVENT_DRIVER_SUBCODE(ev)) {
-
-	case TX_DESCQ_FLS_DONE_EV_DECODE:
-		EFHW_TRACE("TX[%d] flushed",
-			   (int)FALCON_EVENT_TX_FLUSH_Q_ID(ev));
-		efhw_handle_txdmaq_flushed(nic, h, ev);
-		break;
-
-	case RX_DESCQ_FLS_DONE_EV_DECODE:
-		EFHW_TRACE("RX[%d] flushed",
-			   (int)FALCON_EVENT_TX_FLUSH_Q_ID(ev));
-		efhw_handle_rxdmaq_flushed(nic, h, ev);
-		break;
-
-	case SRM_UPD_DONE_EV_DECODE:
-		nic->buf_commit_outstanding =
-		    max(0, nic->buf_commit_outstanding - 1);
-		EFHW_TRACE("COMMIT DONE %d", nic->buf_commit_outstanding);
-		break;
-
-	case EVQ_INIT_DONE_EV_DECODE:
-		EFHW_TRACE("%sEVQ INIT", "");
-		break;
-
-	case WAKE_UP_EV_DECODE:
-		EFHW_TRACE("%sWAKE UP", "");
-		efhw_handle_wakeup_event(nic, h, ev);
-		break;
-
-	case TIMER_EV_DECODE:
-		EFHW_TRACE("%sTIMER", "");
-		efhw_handle_timeout_event(nic, h, ev);
-		break;
-
-	case RX_DESCQ_FLSFF_OVFL_EV_DECODE:
-		/* This shouldn't happen. */
-		EFHW_ERR("%s: RX flush fifo overflowed", __func__);
-		return -EINVAL;
-
-	default:
-		EFHW_TRACE("UNKOWN DRIVER EVENT: " FALCON_EVENT_FMT,
-			   FALCON_EVENT_PRI_ARG(*ev));
-		break;
-	}
-	return 0;
-}
-
-
-/*--------------------------------------------------------------------
- *
- * Filter search depth control
- *
- *--------------------------------------------------------------------*/
-
-
-#define Q0_READ(q0, name) \
-	((unsigned)(((q0) >> name##_LBN) & (__FALCON_MASK64(name##_WIDTH))))
-#define Q0_MASK(name) \
-	((__FALCON_MASK64(name##_WIDTH)) << name##_LBN)
-#define Q0_VALUE(name, value) \
-	(((uint64_t)(value)) << name##_LBN)
-
-#define Q1_READ(q1, name) \
-	((unsigned)(((q1) >> (name##_LBN - 64)) & \
-		    (__FALCON_MASK64(name##_WIDTH))))
-#define Q1_MASK(name) \
-	((__FALCON_MASK64(name##_WIDTH)) << (name##_LBN - 64))
-#define Q1_VALUE(name, value) \
-	(((uint64_t)(value)) << (name##_LBN - 64))
-
-
-void
-falcon_nic_get_rx_filter_search_limits(struct efhw_nic *nic,
-				       struct efhw_filter_search_limits *lim,
-				       int use_raw_values)
-{
-	volatile char __iomem *efhw_kva = EFHW_KVA(nic);
-	FALCON_LOCK_DECL;
-	uint64_t q0, q1;
-	unsigned ff = (use_raw_values ? 0 : RX_FILTER_CTL_SRCH_FUDGE_FULL);
-	unsigned wf = (use_raw_values ? 0 : RX_FILTER_CTL_SRCH_FUDGE_WILD);
-
-	FALCON_LOCK_LOCK(nic);
-	falcon_read_qq(efhw_kva + RX_FILTER_CTL_REG_OFST, &q0, &q1);
-	FALCON_LOCK_UNLOCK(nic);
-
-	lim->tcp_full = Q0_READ(q0, TCP_FULL_SRCH_LIMIT) - ff;
-	lim->tcp_wild = Q0_READ(q0, TCP_WILD_SRCH_LIMIT) - wf;
-	lim->udp_full = Q0_READ(q0, UDP_FULL_SRCH_LIMIT) - ff;
-	lim->udp_wild = Q0_READ(q0, UDP_WILD_SRCH_LIMIT) - wf;
-}
-EXPORT_SYMBOL(falcon_nic_get_rx_filter_search_limits);
-
-
-void
-falcon_nic_set_rx_filter_search_limits(struct efhw_nic *nic,
-				       struct efhw_filter_search_limits *lim,
-				       int use_raw_values)
-{
-	volatile char __iomem *efhw_kva = EFHW_KVA(nic);
-	FALCON_LOCK_DECL;
-	uint64_t q0, q1;
-	unsigned ff = (use_raw_values ? 0 : RX_FILTER_CTL_SRCH_FUDGE_FULL);
-	unsigned wf = (use_raw_values ? 0 : RX_FILTER_CTL_SRCH_FUDGE_WILD);
-
-	FALCON_LOCK_LOCK(nic);
-	falcon_read_qq(efhw_kva + RX_FILTER_CTL_REG_OFST, &q0, &q1);
-
-	q0 &= ~Q0_MASK(TCP_FULL_SRCH_LIMIT);
-	q0 &= ~Q0_MASK(TCP_WILD_SRCH_LIMIT);
-	q0 &= ~Q0_MASK(UDP_FULL_SRCH_LIMIT);
-	q0 &= ~Q0_MASK(UDP_WILD_SRCH_LIMIT);
-	q0 |= Q0_VALUE(TCP_FULL_SRCH_LIMIT, lim->tcp_full + ff);
-	q0 |= Q0_VALUE(TCP_WILD_SRCH_LIMIT, lim->tcp_wild + wf);
-	q0 |= Q0_VALUE(UDP_FULL_SRCH_LIMIT, lim->udp_full + ff);
-	q0 |= Q0_VALUE(UDP_WILD_SRCH_LIMIT, lim->udp_wild + wf);
-	nic->tcp_full_srch.max = lim->tcp_full + ff
-					- RX_FILTER_CTL_SRCH_FUDGE_FULL;
-	nic->tcp_wild_srch.max = lim->tcp_wild + wf
-					- RX_FILTER_CTL_SRCH_FUDGE_WILD;
-	nic->udp_full_srch.max = lim->udp_full + ff
-					- RX_FILTER_CTL_SRCH_FUDGE_FULL;
-	nic->udp_wild_srch.max = lim->udp_wild + wf
-					- RX_FILTER_CTL_SRCH_FUDGE_WILD;
-
-	falcon_write_qq(efhw_kva + RX_FILTER_CTL_REG_OFST, q0, q1);
-	mmiowb();
-	FALCON_LOCK_UNLOCK(nic);
-}
-EXPORT_SYMBOL(falcon_nic_set_rx_filter_search_limits);
-
-
-#undef READ_Q0
-#undef Q0_MASK
-#undef Q0_VALUE
-#undef READ_Q1
-#undef Q1_MASK
-#undef Q1_VALUE
-
-
-/*--------------------------------------------------------------------
- *
- * New unified filter API
- *
- *--------------------------------------------------------------------*/
-
-
-#if FALCON_FULL_FILTER_CACHE
-static inline struct efhw_filter_spec *
-filter_spec_cache_entry(struct efhw_nic *nic, int filter_idx)
-{
-	EFHW_ASSERT(nic->filter_spec_cache);
-	return &nic->filter_spec_cache[filter_idx];
-}
-#endif
-
-
-static int filter_is_active(struct efhw_nic *nic, int filter_idx)
-{
-	return nic->filter_in_use[filter_idx];
-}
-
-
-static void set_filter_cache_entry(struct efhw_nic *nic,
-				   struct efhw_filter_spec *spec,
-				   int filter_idx)
-{
-	nic->filter_in_use[filter_idx] = 1;
-#if FALCON_FULL_FILTER_CACHE
-	memcpy(filter_spec_cache_entry(nic, filter_idx), spec,
-	       sizeof(struct efhw_filter_spec));
-#endif
-}
-
-
-static void clear_filter_cache_entry(struct efhw_nic *nic,
-				     int filter_idx)
-{
-	nic->filter_in_use[filter_idx] = 0;
-#if FALCON_FULL_FILTER_CACHE
-	memset(filter_spec_cache_entry(nic, filter_idx), 0,
-	       sizeof(struct efhw_filter_spec));
-#endif
-}
-
-
-#if FALCON_FULL_FILTER_CACHE
-static int filter_is_duplicate(struct efhw_nic *nic,
-			       struct efhw_filter_spec *spec, int filter_idx)
-{
-	struct efhw_filter_spec *cmp;
-
-	cmp = filter_spec_cache_entry(nic, filter_idx);
-
-	EFHW_ASSERT(filter_is_active(nic, filter_idx));
-
-	return (spec->saddr_le32 == cmp->saddr_le32) &&
-	       (spec->daddr_le32 == cmp->daddr_le32) &&
-	       (spec->sport_le16 == cmp->sport_le16) &&
-	       (spec->dport_le16 == cmp->dport_le16) &&
-	       (spec->tcp == cmp->tcp) &&
-	       (spec->full == cmp->full);
-}
-#endif
-
-
-static void common_build_ip_filter(struct efhw_nic *nic, int tcp, int full,
-				   int rss, int scatter, uint dmaq_id,
-				   unsigned saddr_le32, unsigned sport_le16,
-				   unsigned daddr_le32, unsigned dport_le16,
-				   uint64_t *q0, uint64_t *q1)
-{
-	uint64_t v1, v2, v3, v4;
-	unsigned tmp_port_le16;
-
-	if (!full) {
-		saddr_le32 = 0;
-		sport_le16 = 0;
-		if (!tcp) {
-			tmp_port_le16 = sport_le16;
-			sport_le16 = dport_le16;
-			dport_le16 = tmp_port_le16;
-		}
-	}
-
-	v4 = (((!tcp) << __DW4(TCP_UDP_0_LBN)) |
-	      (dmaq_id << __DW4(RXQ_ID_0_LBN)));
-
-	switch (nic->devtype.variant) {
-	case 'A':
-		EFHW_ASSERT(!rss);
-		break;
-	case 'B':
-		v4 |= scatter << __DW4(SCATTER_EN_0_B0_LBN);
-		v4 |= rss << __DW4(RSS_EN_0_B0_LBN);
-		break;
-	default:
-		EFHW_ASSERT(0);
-		break;
-	}
-
-	v3 = daddr_le32;
-	v2 = ((dport_le16 << __DW2(DEST_PORT_TCP_0_LBN)) |
-	      (__HIGH(saddr_le32, SRC_IP_0_LBN, SRC_IP_0_WIDTH)));
-	v1 = ((__LOW(saddr_le32, SRC_IP_0_LBN, SRC_IP_0_WIDTH)) |
-	      (sport_le16 << SRC_TCP_DEST_UDP_0_LBN));
-
-	*q0 = (v2 << 32) | v1;
-	*q1 = (v4 << 32) | v3;
-}
-
-
-static void build_filter(struct efhw_nic *nic, struct efhw_filter_spec *spec,
-			 unsigned *key, unsigned *tbl_size,
-			 struct efhw_filter_depth **depth,
-			 uint64_t *q0, uint64_t *q1)
-{
-	*key = falcon_hash_get_ip_key(spec->saddr_le32,
-				      spec->sport_le16,
-				      spec->daddr_le32,
-				      spec->dport_le16,
-				      spec->tcp,
-				      spec->full);
-	*tbl_size = nic->ip_filter_tbl_size;
-	if (spec->tcp && spec->full)
-		*depth = &nic->tcp_full_srch;
-	else if (spec->tcp && !spec->full)
-		*depth = &nic->tcp_wild_srch;
-	else if (!spec->tcp && spec->full)
-		*depth = &nic->udp_full_srch;
-	else
-		*depth = &nic->udp_wild_srch;
-	common_build_ip_filter(nic, spec->tcp, spec->full,
-			       spec->rss, spec->scatter,
-			       spec->dmaq_id,
-			       spec->saddr_le32,
-			       spec->sport_le16,
-			       spec->daddr_le32,
-			       spec->dport_le16,
-			       q0, q1);
-}
-
-
-#if FALCON_VERIFY_FILTERS
-static void verify_filters(struct efhw_nic *nic)
-{
-	unsigned table_offset, table_stride;
-	unsigned i, dummy_key, dummy_tbl_size;
-	struct efhw_filter_depth *dummy_depth;
-	unsigned filter_tbl_size;
-	struct efhw_filter_spec *spec;
-	uint64_t q0_expect, q1_expect, q0_got, q1_got;
-
-	filter_tbl_size = nic->ip_filter_tbl_size;
-	table_offset = RX_FILTER_TBL0_OFST;
-	table_stride = 2 * FALCON_REGISTER128;
-
-	for (i = 0; i < filter_tbl_size; i++) {
-		if (!filter_is_active(nic, type, i))
-			continue;
-
-		spec = filter_spec_cache_entry(nic, type, i);
-
-		build_filter(nic, spec, &dummy_key, &dummy_tbl_size,
-			     &dummy_depth, &q0_expect, &q1_expect);
-
-		falcon_read_qq(EFHW_KVA(nic) + table_offset + i * table_stride,
-			       &q0_got, &q1_got);
-
-		if ((q0_got != q0_expect) || (q1_got != q1_expect)) {
-			falcon_write_qq(EFHW_KVA(nic) + 0x300,
-					q0_got, q1_got);
-			EFHW_ERR("ERROR: RX-filter[%d][%d] was "
-				 "%"PRIx64":%" PRIx64" expected "
-				 "%"PRIx64":%"PRIx64,
-				 nic->index, i, q0_got, q1_got,
-				 q0_expect, q1_expect);
-		}
-	}
-}
-#endif
-
-
-static void write_filter_table_entry(struct efhw_nic *nic,
-				     unsigned filter_idx,
-				     uint64_t q0, uint64_t q1)
-{
-	unsigned table_offset, table_stride, offset;
-
-	EFHW_ASSERT(filter_idx < nic->ip_filter_tbl_size);
-	table_offset = RX_FILTER_TBL0_OFST;
-	table_stride = 2 * FALCON_REGISTER128;
-
-	offset = table_offset + filter_idx * table_stride;
-	falcon_write_qq(EFHW_KVA(nic) + offset, q0, q1);
-	mmiowb();
-
-#if FALCON_VERIFY_FILTERS
-	{
-		uint64_t q0read, q1read;
-
-		/* Read a different entry first - ensure BIU flushed shadow */
-		falcon_read_qq(EFHW_KVA(nic) + offset + 0x10, &q0read, &q1read);
-		falcon_read_qq(EFHW_KVA(nic) + offset, &q0read, &q1read);
-		EFHW_ASSERT(q0read == q0);
-		EFHW_ASSERT(q1read == q1);
-
-		verify_filters(nic, type);
-	}
-#endif
-}
-
-
-static int falcon_nic_filter_set(struct efhw_nic *nic,
-				 struct efhw_filter_spec *spec,
-				 int *filter_idx_out)
-{
-	FALCON_LOCK_DECL;
-	unsigned key = 0, tbl_size = 0, hash1, hash2, k;
-	struct efhw_filter_depth *depth = NULL;
-	int filter_idx = -1;
-	int rc = 0;
-	uint64_t q0, q1;
-
-	build_filter(nic, spec, &key, &tbl_size, &depth, &q0, &q1);
-
-	if (tbl_size == 0)
-		return -EINVAL;
-
-	EFHW_TRACE("%s: depth->max=%d", __func__, depth->max);
-
-	hash1 = falcon_hash_function1(key, tbl_size);
-	hash2 = falcon_hash_function2(key, tbl_size);
-
-	FALCON_LOCK_LOCK(nic);
-
-	for (k = 0; k < depth->max; k++) {
-		filter_idx = falcon_hash_iterator(hash1, hash2, k, tbl_size);
-		if (!filter_is_active(nic, filter_idx))
-			break;
-#if FALCON_FULL_FILTER_CACHE
-		if (filter_is_duplicate(nic, spec, filter_idx)) {
-			EFHW_WARN("%s: ERROR: duplicate filter (disabling "
-				  "interrupts)", __func__);
-			falcon_nic_interrupt_hw_disable(nic);
-			rc = -EINVAL;
-			goto fail1;
-		}
-#endif
-	}
-	if (k == depth->max) {
-		rc = -EADDRINUSE;
-		filter_idx = -1;
-		goto fail1;
-	} else if (depth->needed < (k + 1)) {
-		depth->needed = k + 1;
-	}
-
-	EFHW_ASSERT(filter_idx < (int)tbl_size);
-
-	set_filter_cache_entry(nic, spec, filter_idx);
-	write_filter_table_entry(nic, filter_idx, q0, q1);
-
-	++nic->ip_filter_tbl_used;
-
-	*filter_idx_out = filter_idx;
-
-	EFHW_TRACE("%s: filter index %d rxq %u set in %u",
-		   __func__, filter_idx, spec->dmaq_id, k);
-
-fail1:
-	FALCON_LOCK_UNLOCK(nic);
-	return rc;
-}
-
-
-static void falcon_nic_filter_clear(struct efhw_nic *nic,
-				    int filter_idx)
-{
-	FALCON_LOCK_DECL;
-
-	if (filter_idx < 0)
-		return;
-
-	FALCON_LOCK_LOCK(nic);
-	if (filter_is_active(nic, filter_idx)) {
-		if (--nic->ip_filter_tbl_used == 0) {
-			nic->tcp_full_srch.needed = 0;
-			nic->tcp_wild_srch.needed = 0;
-			nic->udp_full_srch.needed = 0;
-			nic->udp_wild_srch.needed = 0;
-		}
-	}
-	clear_filter_cache_entry(nic, filter_idx);
-	write_filter_table_entry(nic, filter_idx, 0, 0);
-	FALCON_LOCK_UNLOCK(nic);
-}
-
-
-int
-falcon_nic_filter_ctor(struct efhw_nic *nic)
-{
-	nic->ip_filter_tbl_size = 8 * 1024;
-	nic->ip_filter_tbl_used = 0;
-
-	nic->tcp_full_srch.needed = 0;
-	nic->tcp_full_srch.max = RX_FILTER_CTL_SRCH_LIMIT_TCP_FULL
-				   - RX_FILTER_CTL_SRCH_FUDGE_FULL;
-	nic->tcp_wild_srch.needed = 0;
-	nic->tcp_wild_srch.max = RX_FILTER_CTL_SRCH_LIMIT_TCP_WILD
-				   - RX_FILTER_CTL_SRCH_FUDGE_WILD;
-	nic->udp_full_srch.needed = 0;
-	nic->udp_full_srch.max = RX_FILTER_CTL_SRCH_LIMIT_UDP_FULL
-				   - RX_FILTER_CTL_SRCH_FUDGE_FULL;
-	nic->udp_wild_srch.needed = 0;
-	nic->udp_wild_srch.max = RX_FILTER_CTL_SRCH_LIMIT_UDP_WILD
-				   - RX_FILTER_CTL_SRCH_FUDGE_WILD;
-
-	nic->filter_in_use = vmalloc(FALCON_FILTER_TBL_NUM);
-	if (nic->filter_in_use == NULL)
-		return -ENOMEM;
-	memset(nic->filter_in_use, 0, FALCON_FILTER_TBL_NUM);
-#if FALCON_FULL_FILTER_CACHE
-	nic->filter_spec_cache = vmalloc(FALCON_FILTER_TBL_NUM
-					 * sizeof(struct efhw_filter_spec));
-	if (nic->filter_spec_cache == NULL)
-		return -ENOMEM;
-	memset(nic->filter_spec_cache, 0, FALCON_FILTER_TBL_NUM
-					  * sizeof(struct efhw_filter_spec));
-#endif
-
-	return 0;
-}
-
-
-void
-falcon_nic_filter_dtor(struct efhw_nic *nic)
-{
-#if FALCON_FULL_FILTER_CACHE
-	if (nic->filter_spec_cache)
-		vfree(nic->filter_spec_cache);
-#endif
-	if (nic->filter_in_use)
-		vfree(nic->filter_in_use);
-}
-
-
-/*--------------------------------------------------------------------
- *
- * Compatibility with old filter API
- *
- *--------------------------------------------------------------------*/
-
-void
-falcon_nic_rx_filter_ctl_get(struct efhw_nic *nic, uint32_t *tcp_full,
-			     uint32_t *tcp_wild,
-			     uint32_t *udp_full, uint32_t *udp_wild)
-{
-	struct efhw_filter_search_limits lim;
-
-	falcon_nic_get_rx_filter_search_limits(nic, &lim, 0);
-	*tcp_full = (uint32_t)lim.tcp_full;
-	*tcp_wild = (uint32_t)lim.tcp_wild;
-	*udp_full = (uint32_t)lim.udp_full;
-	*udp_wild = (uint32_t)lim.udp_wild;
-}
-EXPORT_SYMBOL(falcon_nic_rx_filter_ctl_get);
-
-
-void
-falcon_nic_rx_filter_ctl_set(struct efhw_nic *nic, uint32_t tcp_full,
-			     uint32_t tcp_wild,
-			     uint32_t udp_full, uint32_t udp_wild)
-{
-	struct efhw_filter_search_limits lim;
-
-	lim.tcp_full = (unsigned)tcp_full;
-	lim.tcp_wild = (unsigned)tcp_wild;
-	lim.udp_full = (unsigned)udp_full;
-	lim.udp_wild = (unsigned)udp_wild;
-	falcon_nic_set_rx_filter_search_limits(nic, &lim, 0);
-}
-EXPORT_SYMBOL(falcon_nic_rx_filter_ctl_set);
-
-
-static int
-falcon_nic_ipfilter_set(struct efhw_nic *nic, int type, int *_filter_idx,
-			int dmaq,
-			unsigned saddr_be32, unsigned sport_be16,
-			unsigned daddr_be32, unsigned dport_be16)
-{
-	struct efhw_filter_spec spec;
-
-	spec.dmaq_id = dmaq;
-	spec.saddr_le32 = ntohl(saddr_be32);
-	spec.daddr_le32 = ntohl(daddr_be32);
-	spec.sport_le16 = ntohs((unsigned short) sport_be16);
-	spec.dport_le16 = ntohs((unsigned short) dport_be16);
-	spec.tcp = ((type & EFHW_IP_FILTER_TYPE_TCP_MASK) != 0);
-	spec.full = ((type & EFHW_IP_FILTER_TYPE_FULL_MASK) != 0);
-	spec.rss = ((type & EFHW_IP_FILTER_TYPE_RSS_B0_MASK) != 0);
-	spec.scatter = ((type & EFHW_IP_FILTER_TYPE_NOSCAT_B0_MASK) == 0);
-	return falcon_nic_filter_set(nic, &spec, _filter_idx);
-}
-
-static void falcon_nic_ipfilter_clear(struct efhw_nic *nic, int filter_idx)
-{
-	falcon_nic_filter_clear(nic, filter_idx);
-}
-
-
-/*--------------------------------------------------------------------
- *
- * Abstraction Layer Hooks
- *
- *--------------------------------------------------------------------*/
-
-struct efhw_func_ops falcon_char_functional_units = {
-	falcon_nic_close_hardware,
-	falcon_nic_init_hardware,
-	falcon_nic_interrupt,
-	falcon_nic_interrupt_enable,
-	falcon_nic_interrupt_disable,
-	falcon_nic_set_interrupt_moderation,
-	falcon_nic_event_queue_enable,
-	falcon_nic_event_queue_disable,
-	falcon_nic_wakeup_request,
-	falcon_nic_sw_event,
-	falcon_nic_ipfilter_set,
-	falcon_nic_ipfilter_clear,
-	falcon_dmaq_tx_q_init,
-	falcon_dmaq_rx_q_init,
-	falcon_dmaq_tx_q_disable,
-	falcon_dmaq_rx_q_disable,
-	falcon_flush_tx_dma_channel,
-	falcon_flush_rx_dma_channel,
-	falcon_nic_buffer_table_set,
-	falcon_nic_buffer_table_set_n,
-	falcon_nic_buffer_table_clear,
-	falcon_nic_buffer_table_commit,
-	falcon_nic_filter_set,
-	falcon_nic_filter_clear,
-};
-
-
diff -r 5b3d4d3c1166 drivers/net/sfc/sfc_resource/falcon_hash.c
--- a/drivers/net/sfc/sfc_resource/falcon_hash.c	Fri Nov 05 15:20:28 2010 +0000
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,159 +0,0 @@
-/****************************************************************************
- * Driver for Solarflare network controllers -
- *          resource management for Xen backend, OpenOnload, etc
- *           (including support for SFE4001 10GBT NIC)
- *
- * This file contains EtherFabric NIC hash algorithms implementation.
- *
- * Copyright 2005-2007: Solarflare Communications Inc,
- *                      9501 Jeronimo Road, Suite 250,
- *                      Irvine, CA 92618, USA
- *
- * Developed and maintained by Solarflare Communications:
- *                      <linux-xen-drivers@solarflare.com>
- *                      <onload-dev@solarflare.com>
- *
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 as published
- * by the Free Software Foundation, incorporated herein by reference.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
- ****************************************************************************
- */
-
-#include <ci/efhw/debug.h>
-#include <ci/driver/efab/hardware.h>
-
-
-static unsigned int
-common_get_ip_key(unsigned int src_ip, unsigned int src_port,
-		  unsigned int dest_ip, unsigned int dest_port,
-		  int tcp, int full, int tx, unsigned int masked_q_id)
-{
-
-	unsigned int tmp_port, result;
-
-	EFHW_ASSERT(tcp == 0 || tcp == 1);
-	EFHW_ASSERT(full == 0 || full == 1);
-	EFHW_ASSERT(masked_q_id < (1 << 10));
-
-	/* m=masked_q_id(TX)/0(RX)  u=UDP  S,D=src/dest addr  s,d=src/dest port
-	 *
-	 * Wildcard filters have src(TX)/dest(RX) addr and port = 0;
-	 * and UDP wildcard filters have the src and dest port fields swapped.
-	 *
-	 * Addr/port fields are little-endian.
-	 *
-	 * 3322222222221111111111
-	 * 10987654321098765432109876543210
-	 *
-	 * 000000000000000000000mmmmmmmmmmu ^
-	 * DDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDD ^
-	 * ddddddddddddddddSSSSSSSSSSSSSSSS ^
-	 * SSSSSSSSSSSSSSSSssssssssssssssss
-	 */
-
-	if (!tx)
-		masked_q_id = 0;
-
-	if (!full) {
-		if (tx) {
-			dest_ip = 0;
-			dest_port = 0;
-		} else {
-			src_ip = 0;
-			src_port = 0;
-		}
-		if (!tcp) {
-			tmp_port = src_port;
-			src_port = dest_port;
-			dest_port = tmp_port;
-		}
-	}
-
-	result = ((masked_q_id << 1) | (!tcp))                              ^
-		 (dest_ip)                                                  ^
-		 (((dest_port & 0xffff) << 16) | ((src_ip >> 16) & 0xffff)) ^
-		 (((src_ip & 0xffff) << 16) | (src_port & 0xffff));
-
-	EFHW_TRACE("%s: IP %s %s %x", __func__, tcp ? "TCP" : "UDP",
-		   full ? "Full" : "Wildcard", result);
-
-	return result;
-}
-
-
-unsigned int
-falcon_hash_get_ip_key(unsigned int src_ip, unsigned int src_port,
-		       unsigned int dest_ip, unsigned int dest_port,
-		       int tcp, int full)
-{
-	return common_get_ip_key(src_ip, src_port, dest_ip, dest_port, tcp,
-				 full, 0, 0);
-}
-
-
-/* This function generates the First Hash key */
-unsigned int falcon_hash_function1(unsigned int key, unsigned int nfilters)
-{
-
-	unsigned short int lfsr_reg;
-	unsigned int tmp_key;
-	int index;
-
-	unsigned short int lfsr_input;
-	unsigned short int single_bit_key;
-	unsigned short int bit16_lfsr;
-	unsigned short int bit3_lfsr;
-
-	lfsr_reg = 0xFFFF;
-	tmp_key = key;
-
-	/* For Polynomial equation X^16+X^3+1 */
-	for (index = 0; index < 32; index++) {
-		/* Get the bit from key and shift the key */
-		single_bit_key = (tmp_key & 0x80000000) >> 31;
-		tmp_key = tmp_key << 1;
-
-		/* get the Tap bits to XOR operation */
-		bit16_lfsr = (lfsr_reg & 0x8000) >> 15;
-		bit3_lfsr = (lfsr_reg & 0x0004) >> 2;
-
-		/* Get the Input value to the LFSR */
-		lfsr_input = ((bit16_lfsr ^ bit3_lfsr) ^ single_bit_key);
-
-		/* Shift and store out of the two TAPs */
-		lfsr_reg = lfsr_reg << 1;
-		lfsr_reg = lfsr_reg | (lfsr_input & 0x0001);
-
-	}
-
-	lfsr_reg = lfsr_reg & (nfilters - 1);
-
-	return lfsr_reg;
-}
-
-/* This function generates the Second Hash */
-unsigned int
-falcon_hash_function2(unsigned int key, unsigned int nfilters)
-{
-	return (unsigned int)(((unsigned long long)key * 2 - 1) &
-			      (nfilters - 1));
-}
-
-/* This function iterates through the hash table */
-unsigned int
-falcon_hash_iterator(unsigned int hash1, unsigned int hash2,
-		     unsigned int n_search, unsigned int nfilters)
-{
-	return (hash1 + (n_search * hash2)) & (nfilters - 1);
-}
-
diff -r 5b3d4d3c1166 drivers/net/sfc/sfc_resource/filter_resource.c
--- a/drivers/net/sfc/sfc_resource/filter_resource.c	Fri Nov 05 15:20:28 2010 +0000
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,250 +0,0 @@
-/****************************************************************************
- * Driver for Solarflare network controllers -
- *          resource management for Xen backend, OpenOnload, etc
- *           (including support for SFE4001 10GBT NIC)
- *
- * This file contains filters support.
- *
- * Copyright 2005-2007: Solarflare Communications Inc,
- *                      9501 Jeronimo Road, Suite 250,
- *                      Irvine, CA 92618, USA
- *
- * Developed and maintained by Solarflare Communications:
- *                      <linux-xen-drivers@solarflare.com>
- *                      <onload-dev@solarflare.com>
- *
- * Certain parts of the driver were implemented by
- *          Alexandra Kossovsky <Alexandra.Kossovsky@oktetlabs.ru>
- *          OKTET Labs Ltd, Russia,
- *          http://oktetlabs.ru, <info@oktetlabs.ru>
- *          by request of Solarflare Communications
- *
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 as published
- * by the Free Software Foundation, incorporated herein by reference.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
- ****************************************************************************
- */
-
-#include <ci/efrm/nic_table.h>
-#include <ci/driver/efab/hardware.h>
-#include <ci/efhw/falcon.h>
-#include <ci/efrm/vi_resource_manager.h>
-#include <ci/efrm/private.h>
-#include <ci/efrm/filter.h>
-#include <ci/efrm/buffer_table.h>
-#include <ci/efrm/efrm_client.h>
-#include "efrm_internal.h"
-
-
-struct filter_resource_manager {
-	struct efrm_resource_manager rm;
-	struct kfifo *free_ids;
-};
-
-static struct filter_resource_manager *efrm_filter_manager;
-
-
-void efrm_filter_resource_free(struct filter_resource *frs)
-{
-	struct efhw_nic *nic = frs->rs.rs_client->nic;
-	int id;
-
-	EFRM_RESOURCE_ASSERT_VALID(&frs->rs, 1);
-
-	EFRM_TRACE("%s: " EFRM_RESOURCE_FMT, __func__,
-		   EFRM_RESOURCE_PRI_ARG(frs->rs.rs_handle));
-
-	efhw_nic_ipfilter_clear(nic, frs->filter_idx);
-	frs->filter_idx = -1;
-	efrm_vi_resource_release(frs->pt);
-
-	/* Free this filter. */
-	id = EFRM_RESOURCE_INSTANCE(frs->rs.rs_handle);
-	EFRM_VERIFY_EQ(kfifo_put(efrm_filter_manager->free_ids,
-				 (unsigned char *)&id, sizeof(id)),
-		       sizeof(id));
-
-	efrm_client_put(frs->rs.rs_client);
-	EFRM_DO_DEBUG(memset(frs, 0, sizeof(*frs)));
-	kfree(frs);
-}
-EXPORT_SYMBOL(efrm_filter_resource_free);
-
-
-void efrm_filter_resource_release(struct filter_resource *frs)
-{
-	if (__efrm_resource_release(&frs->rs))
-		efrm_filter_resource_free(frs);
-}
-EXPORT_SYMBOL(efrm_filter_resource_release);
-
-
-static void filter_rm_dtor(struct efrm_resource_manager *rm)
-{
-	EFRM_TRACE("%s:", __func__);
-
-	EFRM_RESOURCE_MANAGER_ASSERT_VALID(&efrm_filter_manager->rm);
-	EFRM_ASSERT(&efrm_filter_manager->rm == rm);
-
-	kfifo_vfree(efrm_filter_manager->free_ids);
-	EFRM_TRACE("%s: done", __func__);
-}
-
-/**********************************************************************/
-/**********************************************************************/
-/**********************************************************************/
-
-int efrm_create_filter_resource_manager(struct efrm_resource_manager **rm_out)
-{
-	int rc;
-
-	EFRM_ASSERT(rm_out);
-
-	efrm_filter_manager =
-	    kmalloc(sizeof(struct filter_resource_manager), GFP_KERNEL);
-	if (efrm_filter_manager == 0)
-		return -ENOMEM;
-	memset(efrm_filter_manager, 0, sizeof(*efrm_filter_manager));
-
-	rc = efrm_resource_manager_ctor(&efrm_filter_manager->rm,
-					filter_rm_dtor, "FILTER",
-					EFRM_RESOURCE_FILTER);
-	if (rc < 0)
-		goto fail1;
-
-	/* Create a pool of free instances */
-	rc = efrm_kfifo_id_ctor(&efrm_filter_manager->free_ids,
-				0, EFHW_IP_FILTER_NUM,
-				&efrm_filter_manager->rm.rm_lock);
-	if (rc != 0)
-		goto fail2;
-
-	*rm_out = &efrm_filter_manager->rm;
-	EFRM_TRACE("%s: filter resources created - %d IDs",
-		   __func__, kfifo_len(efrm_filter_manager->free_ids));
-	return 0;
-
-fail2:
-	efrm_resource_manager_dtor(&efrm_filter_manager->rm);
-fail1:
-	memset(efrm_filter_manager, 0, sizeof(*efrm_filter_manager));
-	kfree(efrm_filter_manager);
-	return rc;
-
-}
-
-
-int efrm_filter_resource_clear(struct filter_resource *frs)
-{
-	struct efhw_nic *nic = frs->rs.rs_client->nic;
-
-	efhw_nic_ipfilter_clear(nic, frs->filter_idx);
-	frs->filter_idx = -1;
-	return 0;
-}
-EXPORT_SYMBOL(efrm_filter_resource_clear);
-
-
-int
-__efrm_filter_resource_set(struct filter_resource *frs, int type,
-			   unsigned saddr, uint16_t sport,
-			   unsigned daddr, uint16_t dport)
-{
-	struct efhw_nic *nic = frs->rs.rs_client->nic;
-	int vi_instance;
-
-	EFRM_ASSERT(frs);
-
-	if (efrm_nic_tablep->a_nic->devtype.variant >= 'B' &&
-	    (frs->pt->flags & EFHW_VI_JUMBO_EN) == 0)
-		type |= EFHW_IP_FILTER_TYPE_NOSCAT_B0_MASK;
-	vi_instance = EFRM_RESOURCE_INSTANCE(frs->pt->rs.rs_handle);
-
-	return efhw_nic_ipfilter_set(nic, type, &frs->filter_idx,
-				     vi_instance, saddr, sport, daddr, dport);
-}
-EXPORT_SYMBOL(__efrm_filter_resource_set);;
-
-
-int
-efrm_filter_resource_alloc(struct vi_resource *vi_parent,
-			   struct filter_resource **frs_out)
-{
-	struct filter_resource *frs;
-	int rc, instance;
-
-	EFRM_ASSERT(frs_out);
-	EFRM_ASSERT(efrm_filter_manager);
-	EFRM_RESOURCE_MANAGER_ASSERT_VALID(&efrm_filter_manager->rm);
-	EFRM_ASSERT(vi_parent != NULL);
-	EFRM_ASSERT(EFRM_RESOURCE_TYPE(vi_parent->rs.rs_handle) ==
-		    EFRM_RESOURCE_VI);
-
-	/* Allocate resource data structure. */
-	frs = kmalloc(sizeof(struct filter_resource), GFP_KERNEL);
-	if (!frs)
-		return -ENOMEM;
-
-	/* Allocate an instance. */
-	rc = kfifo_get(efrm_filter_manager->free_ids,
-		       (unsigned char *)&instance, sizeof(instance));
-	if (rc != sizeof(instance)) {
-		EFRM_TRACE("%s: out of instances", __func__);
-		EFRM_ASSERT(rc == 0);
-		rc = -EBUSY;
-		goto fail1;
-	}
-
-	/* Initialise the resource DS. */
-	efrm_resource_init(&frs->rs, EFRM_RESOURCE_FILTER, instance);
-	frs->pt = vi_parent;
-	efrm_resource_ref(&frs->pt->rs);
-	frs->filter_idx = -1;
-
-	EFRM_TRACE("%s: " EFRM_RESOURCE_FMT " VI %d", __func__,
-		   EFRM_RESOURCE_PRI_ARG(frs->rs.rs_handle),
-		   EFRM_RESOURCE_INSTANCE(vi_parent->rs.rs_handle));
-
-	efrm_client_add_resource(vi_parent->rs.rs_client, &frs->rs);
-	*frs_out = frs;
-	return 0;
-
-fail1:
-	memset(frs, 0, sizeof(*frs));
-	kfree(frs);
-	return rc;
-}
-EXPORT_SYMBOL(efrm_filter_resource_alloc);
-
-
-int efrm_filter_resource_instance(struct filter_resource *frs)
-{
-	return EFRM_RESOURCE_INSTANCE(frs->rs.rs_handle);
-}
-EXPORT_SYMBOL(efrm_filter_resource_instance);
-
-
-struct efrm_resource *
-efrm_filter_resource_to_resource(struct filter_resource *frs)
-{
-	return &frs->rs;
-}
-EXPORT_SYMBOL(efrm_filter_resource_to_resource);
-
-
-struct filter_resource *
-efrm_filter_resource_from_resource(struct efrm_resource *rs)
-{
-	return filter_resource(rs);
-}
-EXPORT_SYMBOL(efrm_filter_resource_from_resource);
diff -r 5b3d4d3c1166 drivers/net/sfc/sfc_resource/iobufset_resource.c
--- a/drivers/net/sfc/sfc_resource/iobufset_resource.c	Fri Nov 05 15:20:28 2010 +0000
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,404 +0,0 @@
-/****************************************************************************
- * Driver for Solarflare network controllers -
- *          resource management for Xen backend, OpenOnload, etc
- *           (including support for SFE4001 10GBT NIC)
- *
- * This file contains non-contiguous I/O buffers support.
- *
- * Copyright 2005-2007: Solarflare Communications Inc,
- *                      9501 Jeronimo Road, Suite 250,
- *                      Irvine, CA 92618, USA
- *
- * Developed and maintained by Solarflare Communications:
- *                      <linux-xen-drivers@solarflare.com>
- *                      <onload-dev@solarflare.com>
- *
- * Certain parts of the driver were implemented by
- *          Alexandra Kossovsky <Alexandra.Kossovsky@oktetlabs.ru>
- *          OKTET Labs Ltd, Russia,
- *          http://oktetlabs.ru, <info@oktetlabs.ru>
- *          by request of Solarflare Communications
- *
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 as published
- * by the Free Software Foundation, incorporated herein by reference.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
- ****************************************************************************
- */
-
-#include <ci/efrm/nic_table.h>
-#include <ci/efhw/iopage.h>
-#include <ci/driver/efab/hardware.h>
-#include <ci/efrm/private.h>
-#include <ci/efrm/iobufset.h>
-#include <ci/efrm/vi_resource_manager.h>
-#include <ci/efrm/buffer_table.h>
-#include <ci/efrm/efrm_client.h>
-#include "efrm_internal.h"
-
-
-#define EFRM_IOBUFSET_MAX_NUM_INSTANCES 0x00010000
-
-struct iobufset_resource_manager {
-	struct efrm_resource_manager rm;
-	struct kfifo *free_ids;
-};
-
-struct iobufset_resource_manager *efrm_iobufset_manager;
-
-#define iobsrs(rs1)  iobufset_resource(rs1)
-
-/* Returns size of iobufset resource data structure. */
-static inline size_t iobsrs_size(int n_pages)
-{
-	return offsetof(struct iobufset_resource, bufs) +
-	    n_pages * sizeof(struct efhw_iopage);
-}
-
-void efrm_iobufset_resource_free(struct iobufset_resource *rs)
-{
-	unsigned int i;
-	int id;
-
-	EFRM_RESOURCE_ASSERT_VALID(&rs->rs, 1);
-
-	if (!rs->linked && rs->buf_tbl_alloc.base != (unsigned) -1)
-		efrm_buffer_table_free(&rs->buf_tbl_alloc);
-
-	/* see comment on call to efhw_iopage_alloc in the alloc routine above
-	   for discussion on use of efrm_nic_tablep->a_nic here */
-	EFRM_ASSERT(efrm_nic_tablep->a_nic);
-	if (rs->linked) {
-		/* Nothing to do. */
-	} else if (rs->chunk_order == 0) {
-		for (i = 0; i < rs->n_bufs; ++i)
-			efhw_iopage_free(efrm_nic_tablep->a_nic, &rs->bufs[i]);
-	} else {
-		/* it is important that this is executed in increasing page
-		 * order because some implementations of
-		 * efhw_iopages_init_from_iopage() assume this */
-		for (i = 0; i < rs->n_bufs;
-		     i += rs->pages_per_contiguous_chunk) {
-			struct efhw_iopages iopages;
-			efhw_iopages_init_from_iopage(&iopages, &rs->bufs[i],
-						    rs->chunk_order);
-			efhw_iopages_free(efrm_nic_tablep->a_nic, &iopages);
-		}
-	}
-
-	/* free the instance number */
-	id = EFRM_RESOURCE_INSTANCE(rs->rs.rs_handle);
-	EFRM_VERIFY_EQ(kfifo_put(efrm_iobufset_manager->free_ids,
-				 (unsigned char *)&id, sizeof(id)), sizeof(id));
-
-	efrm_vi_resource_release(rs->evq);
-	if (rs->linked)
-		efrm_iobufset_resource_release(rs->linked);
-
-	efrm_client_put(rs->rs.rs_client);
-	if (iobsrs_size(rs->n_bufs) < PAGE_SIZE) {
-		EFRM_DO_DEBUG(memset(rs, 0, sizeof(*rs)));
-		kfree(rs);
-	} else {
-		EFRM_DO_DEBUG(memset(rs, 0, sizeof(*rs)));
-		vfree(rs);
-	}
-}
-EXPORT_SYMBOL(efrm_iobufset_resource_free);
-
-
-void efrm_iobufset_resource_release(struct iobufset_resource *iobrs)
-{
-	if (__efrm_resource_release(&iobrs->rs))
-		efrm_iobufset_resource_free(iobrs);
-}
-EXPORT_SYMBOL(efrm_iobufset_resource_release);
-
-
-
-int
-efrm_iobufset_resource_alloc(int32_t n_pages,
-			     int32_t pages_per_contiguous_chunk,
-			     struct vi_resource *vi_evq,
-			     struct iobufset_resource *linked,
-			     bool phys_addr_mode,
-			     struct iobufset_resource **iobrs_out)
-{
-	struct iobufset_resource *iobrs;
-	int rc, instance, object_size;
-	unsigned int i;
-
-	EFRM_ASSERT(iobrs_out);
-	EFRM_ASSERT(efrm_iobufset_manager);
-	EFRM_RESOURCE_MANAGER_ASSERT_VALID(&efrm_iobufset_manager->rm);
-	EFRM_RESOURCE_ASSERT_VALID(&vi_evq->rs, 0);
-	EFRM_ASSERT(EFRM_RESOURCE_TYPE(vi_evq->rs.rs_handle) ==
-		    EFRM_RESOURCE_VI);
-	EFRM_ASSERT(efrm_nic_tablep->a_nic);
-
-	if (linked) {
-		/* This resource will share properties and memory with
-		 * another.  Only difference is that we'll program it into
-		 * the buffer table of another nic.
-		 */
-		n_pages = linked->n_bufs;
-		pages_per_contiguous_chunk = linked->pages_per_contiguous_chunk;
-		phys_addr_mode = linked->buf_tbl_alloc.base == (unsigned) -1;
-	}
-
-	/* allocate the resource data structure. */
-	object_size = iobsrs_size(n_pages);
-	if (object_size < PAGE_SIZE) {
-		/* this should be OK from a tasklet */
-		/* Necessary to do atomic alloc() as this
-		   can be called from a weird-ass iSCSI context that is
-		   !in_interrupt but is in_atomic - See BUG3163 */
-		iobrs = kmalloc(object_size, GFP_ATOMIC);
-	} else {		/* can't do this within a tasklet */
-#ifndef NDEBUG
-		if (in_interrupt() || in_atomic()) {
-			EFRM_ERR("%s(): alloc->u.iobufset.in_n_pages=%d",
-				 __func__, n_pages);
-			EFRM_ASSERT(!in_interrupt());
-			EFRM_ASSERT(!in_atomic());
-		}
-#endif
-		iobrs = (struct iobufset_resource *) vmalloc(object_size);
-	}
-	if (iobrs == NULL) {
-		EFRM_WARN("%s: failed to allocate container", __func__);
-		rc = -ENOMEM;
-		goto fail1;
-	}
-
-	/* Allocate an instance number. */
-	rc = kfifo_get(efrm_iobufset_manager->free_ids,
-		       (unsigned char *)&instance, sizeof(instance));
-	if (rc != sizeof(instance)) {
-		EFRM_WARN("%s: out of instances", __func__);
-		EFRM_ASSERT(rc == 0);
-		rc = -EBUSY;
-		goto fail3;
-	}
-
-	efrm_resource_init(&iobrs->rs, EFRM_RESOURCE_IOBUFSET, instance);
-
-	iobrs->evq = vi_evq;
-	iobrs->linked = linked;
-	iobrs->n_bufs = n_pages;
-	iobrs->pages_per_contiguous_chunk = pages_per_contiguous_chunk;
-	iobrs->chunk_order = fls(iobrs->pages_per_contiguous_chunk - 1);
-	iobrs->buf_tbl_alloc.base = (unsigned) -1;
-
-	EFRM_TRACE("%s: " EFRM_RESOURCE_FMT " %u pages", __func__,
-		   EFRM_RESOURCE_PRI_ARG(iobrs->rs.rs_handle), iobrs->n_bufs);
-
-	/* Allocate the iobuffers. */
-	if (linked) {
-		memcpy(iobrs->bufs, linked->bufs,
-		       iobrs->n_bufs * sizeof(iobrs->bufs[0]));
-	} else if (iobrs->chunk_order == 0) {
-		memset(iobrs->bufs, 0, iobrs->n_bufs * sizeof(iobrs->bufs[0]));
-		for (i = 0; i < iobrs->n_bufs; ++i) {
-			/* due to bug2426 we have to specifiy a NIC when
-			 * allocating a DMAable page, which is a bit messy.
-			 * For now we assume that if the page is suitable
-			 * (e.g. DMAable) by one nic (efrm_nic_tablep->a_nic),
-			 * it is suitable for all NICs.
-			 * XXX I bet that breaks in Solaris.
-			 */
-			rc = efhw_iopage_alloc(efrm_nic_tablep->a_nic,
-					     &iobrs->bufs[i]);
-			if (rc < 0) {
-				EFRM_WARN("%s: failed (rc %d) to allocate "
-					  "page (i=%u)", __func__, rc, i);
-				goto fail4;
-			}
-		}
-	} else {
-		struct efhw_iopages iopages;
-		unsigned j;
-
-		memset(iobrs->bufs, 0, iobrs->n_bufs * sizeof(iobrs->bufs[0]));
-		for (i = 0; i < iobrs->n_bufs;
-		     i += iobrs->pages_per_contiguous_chunk) {
-			rc = efhw_iopages_alloc(efrm_nic_tablep->a_nic,
-						&iopages, iobrs->chunk_order);
-			if (rc < 0) {
-				EFRM_WARN("%s: failed (rc %d) to allocate "
-					  "pages (i=%u order %d)",
-					  __func__, rc, i,
-					  iobrs->chunk_order);
-				goto fail4;
-			}
-			for (j = 0; j < iobrs->pages_per_contiguous_chunk;
-			     j++) {
-				/* some implementation of
-				 * efhw_iopage_init_from_iopages() rely on
-				 * this function being called for
-				 * _all_ pages in the chunk */
-				efhw_iopage_init_from_iopages(
-							&iobrs->bufs[i + j],
-							&iopages, j);
-			}
-		}
-	}
-
-	if (!phys_addr_mode) {
-		unsigned owner_id = EFAB_VI_RESOURCE_INSTANCE(iobrs->evq);
-
-		if (!linked) {
-			/* Allocate space in the NIC's buffer table. */
-			rc = efrm_buffer_table_alloc(fls(iobrs->n_bufs - 1),
-						     &iobrs->buf_tbl_alloc);
-			if (rc < 0) {
-				EFRM_WARN("%s: failed (%d) to alloc %d buffer "
-					  "table entries", __func__, rc,
-					  iobrs->n_bufs);
-				goto fail5;
-			}
-			EFRM_ASSERT(((unsigned)1 << iobrs->buf_tbl_alloc.order)
-				    >= (unsigned) iobrs->n_bufs);
-		} else {
-			iobrs->buf_tbl_alloc = linked->buf_tbl_alloc;
-		}
-
-		/* Initialise the buffer table entries. */
-		for (i = 0; i < iobrs->n_bufs; ++i) {
-			/*\ ?? \TODO burst them! */
-			efrm_buffer_table_set(&iobrs->buf_tbl_alloc,
-					      vi_evq->rs.rs_client->nic,
-					      i,
-					      efhw_iopage_dma_addr(&iobrs->
-								   bufs[i]),
-					      owner_id);
-		}
-		efrm_buffer_table_commit();
-	}
-
-	EFRM_TRACE("%s: " EFRM_RESOURCE_FMT " %d pages @ "
-		   EFHW_BUFFER_ADDR_FMT, __func__,
-		   EFRM_RESOURCE_PRI_ARG(iobrs->rs.rs_handle),
-		   iobrs->n_bufs, EFHW_BUFFER_ADDR(iobrs->buf_tbl_alloc.base,
-						   0));
-	efrm_resource_ref(&iobrs->evq->rs);
-	if (linked != NULL)
-		efrm_resource_ref(&linked->rs);
-	efrm_client_add_resource(vi_evq->rs.rs_client, &iobrs->rs);
-	*iobrs_out = iobrs;
-	return 0;
-
-fail5:
-	i = iobrs->n_bufs;
-fail4:
-	/* see comment on call to efhw_iopage_alloc above for a discussion
-	 * on use of efrm_nic_tablep->a_nic here */
-	if (linked) {
-		/* Nothing to do. */
-	} else if (iobrs->chunk_order == 0) {
-		while (i--) {
-			struct efhw_iopage *page = &iobrs->bufs[i];
-			efhw_iopage_free(efrm_nic_tablep->a_nic, page);
-		}
-	} else {
-		unsigned int j;
-		for (j = 0; j < i; j += iobrs->pages_per_contiguous_chunk) {
-			struct efhw_iopages iopages;
-
-			EFRM_ASSERT(j % iobrs->pages_per_contiguous_chunk
-				    == 0);
-			/* it is important that this is executed in increasing
-			 * page order because some implementations of
-			 * efhw_iopages_init_from_iopage() assume this */
-			efhw_iopages_init_from_iopage(&iopages,
-						      &iobrs->bufs[j],
-						      iobrs->chunk_order);
-			efhw_iopages_free(efrm_nic_tablep->a_nic, &iopages);
-		}
-	}
-fail3:
-	if (object_size < PAGE_SIZE)
-		kfree(iobrs);
-	else
-		vfree(iobrs);
-fail1:
-	return rc;
-}
-EXPORT_SYMBOL(efrm_iobufset_resource_alloc);
-
-static void iobufset_rm_dtor(struct efrm_resource_manager *rm)
-{
-	EFRM_ASSERT(&efrm_iobufset_manager->rm == rm);
-	kfifo_vfree(efrm_iobufset_manager->free_ids);
-}
-
-int
-efrm_create_iobufset_resource_manager(struct efrm_resource_manager **rm_out)
-{
-	int rc, max;
-
-	EFRM_ASSERT(rm_out);
-
-	efrm_iobufset_manager =
-	    kmalloc(sizeof(*efrm_iobufset_manager), GFP_KERNEL);
-	if (efrm_iobufset_manager == 0)
-		return -ENOMEM;
-	memset(efrm_iobufset_manager, 0, sizeof(*efrm_iobufset_manager));
-
-	/*
-	 * Bug 1145, 1370: We need to set initial size of both the resource
-	 * table and instance id table so they never need to grow as we
-	 * want to be allocate new iobufset at tasklet time. Lets make
-	 * a pessimistic guess at maximum number of iobufsets possible.
-	 * Could be less because
-	 *   - jumbo frames have same no of packets per iobufset BUT more
-	 *     pages per buffer
-	 *   - buffer table entries used independently of iobufsets by
-	 *     sendfile
-	 *
-	 * Based on TCP/IP stack setting of PKTS_PER_SET_S=5 ...
-	 *  - can't use this define here as it breaks the layering.
-	 */
-#define MIN_PAGES_PER_IOBUFSET  (1 << 4)
-
-	max = efrm_buffer_table_size() / MIN_PAGES_PER_IOBUFSET;
-	max = min_t(int, max, EFRM_IOBUFSET_MAX_NUM_INSTANCES);
-
-	/* HACK: There currently exists an option to allocate buffers that
-	 * are not programmed into the buffer table, so the max number is
-	 * not limited by the buffer table size.  I'm hoping this usage
-	 * will go away eventually.
-	 */
-	max = 32768;
-
-	rc = efrm_kfifo_id_ctor(&efrm_iobufset_manager->free_ids,
-				0, max, &efrm_iobufset_manager->rm.rm_lock);
-	if (rc != 0)
-		goto fail1;
-
-	rc = efrm_resource_manager_ctor(&efrm_iobufset_manager->rm,
-					iobufset_rm_dtor, "IOBUFSET",
-					EFRM_RESOURCE_IOBUFSET);
-	if (rc < 0)
-		goto fail2;
-
-	*rm_out = &efrm_iobufset_manager->rm;
-	return 0;
-
-fail2:
-	kfifo_vfree(efrm_iobufset_manager->free_ids);
-fail1:
-	EFRM_DO_DEBUG(memset(efrm_iobufset_manager, 0,
-			     sizeof(*efrm_iobufset_manager)));
-	kfree(efrm_iobufset_manager);
-	return rc;
-}
diff -r 5b3d4d3c1166 drivers/net/sfc/sfc_resource/iopage.c
--- a/drivers/net/sfc/sfc_resource/iopage.c	Fri Nov 05 15:20:28 2010 +0000
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,103 +0,0 @@
-/****************************************************************************
- * Driver for Solarflare network controllers -
- *          resource management for Xen backend, OpenOnload, etc
- *           (including support for SFE4001 10GBT NIC)
- *
- * This file provides Linux-specific implementation for iopage API used
- * from efhw library.
- *
- * Copyright 2005-2007: Solarflare Communications Inc,
- *                      9501 Jeronimo Road, Suite 250,
- *                      Irvine, CA 92618, USA
- *
- * Developed and maintained by Solarflare Communications:
- *                      <linux-xen-drivers@solarflare.com>
- *                      <onload-dev@solarflare.com>
- *
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 as published
- * by the Free Software Foundation, incorporated herein by reference.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
- ****************************************************************************
- */
-
-#include <ci/driver/resource/linux_efhw_nic.h>
-#include "kernel_compat.h"
-#include <ci/efhw/common_sysdep.h> /* for dma_addr_t */
-
-int efhw_iopage_alloc(struct efhw_nic *nic, struct efhw_iopage *p)
-{
-	struct linux_efhw_nic *lnic = linux_efhw_nic(nic);
-	dma_addr_t handle;
-	void *kva;
-
-	kva = efrm_pci_alloc_consistent(lnic->pci_dev, PAGE_SIZE,
-					&handle);
-	if (kva == 0)
-		return -ENOMEM;
-
-	EFHW_ASSERT((handle & ~PAGE_MASK) == 0);
-
-	memset((void *)kva, 0, PAGE_SIZE);
-	efhw_page_init_from_va(&p->p, kva);
-
-	p->dma_addr = handle;
-
-	return 0;
-}
-
-void efhw_iopage_free(struct efhw_nic *nic, struct efhw_iopage *p)
-{
-	struct linux_efhw_nic *lnic = linux_efhw_nic(nic);
-	EFHW_ASSERT(efhw_page_is_valid(&p->p));
-
-	efrm_pci_free_consistent(lnic->pci_dev, PAGE_SIZE,
-				 efhw_iopage_ptr(p), p->dma_addr);
-}
-
-int
-efhw_iopages_alloc(struct efhw_nic *nic, struct efhw_iopages *p,
-		   unsigned order)
-{
-	unsigned bytes = 1u << (order + PAGE_SHIFT);
-	struct linux_efhw_nic *lnic = linux_efhw_nic(nic);
-	dma_addr_t handle;
-	caddr_t addr;
-	int gfp_flag;
-
-	/* Set __GFP_COMP if available to make reference counting work.
-	 * This is recommended here:
-	 *   http://www.forbiddenweb.org/viewtopic.php?id=83167&page=4#348331
-	 */
-	gfp_flag = ((in_atomic() ? GFP_ATOMIC : GFP_KERNEL) | __GFP_COMP);
-	addr = efrm_dma_alloc_coherent(&lnic->pci_dev->dev, bytes, &handle,
-				       gfp_flag);
-	if (addr == NULL)
-		return -ENOMEM;
-
-	EFHW_ASSERT((handle & ~PAGE_MASK) == 0);
-
-	p->order = order;
-	p->dma_addr = handle;
-	p->kva = addr;
-
-	return 0;
-}
-
-void efhw_iopages_free(struct efhw_nic *nic, struct efhw_iopages *p)
-{
-	unsigned bytes = 1u << (p->order + PAGE_SHIFT);
-	struct linux_efhw_nic *lnic = linux_efhw_nic(nic);
-
-	efrm_dma_free_coherent(&lnic->pci_dev->dev, bytes,
-			       (void *)p->kva, p->dma_addr);
-}
diff -r 5b3d4d3c1166 drivers/net/sfc/sfc_resource/kernel_compat.c
--- a/drivers/net/sfc/sfc_resource/kernel_compat.c	Fri Nov 05 15:20:28 2010 +0000
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,118 +0,0 @@
-/****************************************************************************
- * Driver for Solarflare network controllers -
- *          resource management for Xen backend, OpenOnload, etc
- *           (including support for SFE4001 10GBT NIC)
- *
- * This file provides compatibility layer for various Linux kernel versions
- * (starting from 2.6.9 RHEL kernel).
- *
- * Copyright 2005-2007: Solarflare Communications Inc,
- *                      9501 Jeronimo Road, Suite 250,
- *                      Irvine, CA 92618, USA
- *
- * Developed and maintained by Solarflare Communications:
- *                      <linux-xen-drivers@solarflare.com>
- *                      <onload-dev@solarflare.com>
- *
- * Certain parts of the driver were implemented by
- *          Alexandra Kossovsky <Alexandra.Kossovsky@oktetlabs.ru>
- *          OKTET Labs Ltd, Russia,
- *          http://oktetlabs.ru, <info@oktetlabs.ru>
- *          by request of Solarflare Communications
- *
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 as published
- * by the Free Software Foundation, incorporated herein by reference.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
- ****************************************************************************
- */
-
-#define IN_KERNEL_COMPAT_C
-#include <linux/types.h>
-#include <ci/efrm/debug.h>
-#include "kernel_compat.h"
-
-/* Set this to 1 to enable very basic counting of iopage(s) allocations, then
- * call dump_iopage_counts() to show the number of current allocations of
- * orders 0-7.
- */
-#define EFRM_IOPAGE_COUNTS_ENABLED 0
-
-
-/****************************************************************************
- *
- * allocate a buffer suitable for DMA to/from the NIC
- *
- ****************************************************************************/
-
-#if EFRM_IOPAGE_COUNTS_ENABLED
-
-static int iopage_counts[8];
-
-void dump_iopage_counts(void)
-{
-	EFRM_NOTICE("iopage counts: %d %d %d %d %d %d %d %d", iopage_counts[0],
-		    iopage_counts[1], iopage_counts[2], iopage_counts[3],
-		    iopage_counts[4], iopage_counts[5], iopage_counts[6],
-		    iopage_counts[7]);
-}
-
-#endif
-
-
-
-/*********** pci_alloc_consistent / pci_free_consistent ***********/
-
-void *efrm_dma_alloc_coherent(struct device *dev, size_t size,
-			      dma_addr_t *dma_addr, int flag)
-{
-	void *ptr;
-	unsigned order;
-
-	order = __ffs(size/PAGE_SIZE);
-	EFRM_ASSERT(size == (PAGE_SIZE<<order));
-
-	/* Can't take a spinlock here since the allocation can
-	 * block. */
-	ptr = dma_alloc_coherent(dev, size, dma_addr, flag);
-	if (ptr == NULL)
-		return ptr;
-
-#if EFRM_IOPAGE_COUNTS_ENABLED
-	if (order < 8)
-		iopage_counts[order]++;
-	else
-		EFRM_ERR("Huge iopages alloc (order=%d) ??? (not counted)",
-			 order);
-#endif
-
-	return ptr;
-}
-
-void efrm_dma_free_coherent(struct device *dev, size_t size,
-			    void *ptr, dma_addr_t dma_addr)
-{
-	unsigned order;
-
-	order = __ffs(size/PAGE_SIZE);
-	EFRM_ASSERT(size == (PAGE_SIZE<<order));
-
-#if EFRM_IOPAGE_COUNTS_ENABLED
-	if (order < 8)
-		--iopage_counts[order];
-	else
-		EFRM_ERR("Huge iopages free (order=%d) ??? (not counted)",
-			 order);
-#endif
-
-	dma_free_coherent(dev, size, ptr, dma_addr);
-}
diff -r 5b3d4d3c1166 drivers/net/sfc/sfc_resource/kernel_compat.h
--- a/drivers/net/sfc/sfc_resource/kernel_compat.h	Fri Nov 05 15:20:28 2010 +0000
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,70 +0,0 @@
-/****************************************************************************
- * Driver for Solarflare network controllers -
- *          resource management for Xen backend, OpenOnload, etc
- *           (including support for SFE4001 10GBT NIC)
- *
- * This file provides compatibility layer for various Linux kernel versions
- * (starting from 2.6.9 RHEL kernel).
- *
- * Copyright 2005-2007: Solarflare Communications Inc,
- *                      9501 Jeronimo Road, Suite 250,
- *                      Irvine, CA 92618, USA
- *
- * Developed and maintained by Solarflare Communications:
- *                      <linux-xen-drivers@solarflare.com>
- *                      <onload-dev@solarflare.com>
- *
- * Certain parts of the driver were implemented by
- *          Alexandra Kossovsky <Alexandra.Kossovsky@oktetlabs.ru>
- *          OKTET Labs Ltd, Russia,
- *          http://oktetlabs.ru, <info@oktetlabs.ru>
- *          by request of Solarflare Communications
- *
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 as published
- * by the Free Software Foundation, incorporated herein by reference.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
- ****************************************************************************
- */
-
-#ifndef DRIVER_LINUX_RESOURCE_KERNEL_COMPAT_H
-#define DRIVER_LINUX_RESOURCE_KERNEL_COMPAT_H
-
-#include <linux/moduleparam.h>
-#include <linux/sched.h>
-#include <linux/io.h>
-#include <linux/pci.h>
-
-/********* pci_map_*() ********************/
-
-extern void *efrm_dma_alloc_coherent(struct device *dev, size_t size,
-				     dma_addr_t *dma_addr, int flag);
-
-extern void efrm_dma_free_coherent(struct device *dev, size_t size,
-				   void *ptr, dma_addr_t dma_addr);
-
-static inline void *efrm_pci_alloc_consistent(struct pci_dev *hwdev,
-					      size_t size,
-					      dma_addr_t *dma_addr)
-{
-	return efrm_dma_alloc_coherent(&hwdev->dev, size, dma_addr,
-				       GFP_ATOMIC);
-}
-
-static inline void efrm_pci_free_consistent(struct pci_dev *hwdev, size_t size,
-					    void *ptr, dma_addr_t dma_addr)
-{
-	efrm_dma_free_coherent(&hwdev->dev, size, ptr, dma_addr);
-}
-
-
-#endif /* DRIVER_LINUX_RESOURCE_KERNEL_COMPAT_H */
diff -r 5b3d4d3c1166 drivers/net/sfc/sfc_resource/kernel_proc.c
--- a/drivers/net/sfc/sfc_resource/kernel_proc.c	Fri Nov 05 15:20:28 2010 +0000
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,109 +0,0 @@
-/****************************************************************************
- * Driver for Solarflare network controllers -
- *          resource management for Xen backend, OpenOnload, etc
- *           (including support for SFE4001 10GBT NIC)
- *
- * This file contains /proc/driver/sfc_resource/ implementation.
- *
- * Copyright 2005-2007: Solarflare Communications Inc,
- *                      9501 Jeronimo Road, Suite 250,
- *                      Irvine, CA 92618, USA
- *
- * Developed and maintained by Solarflare Communications:
- *                      <linux-xen-drivers@solarflare.com>
- *                      <onload-dev@solarflare.com>
- *
- * Certain parts of the driver were implemented by
- *          Alexandra Kossovsky <Alexandra.Kossovsky@oktetlabs.ru>
- *          OKTET Labs Ltd, Russia,
- *          http://oktetlabs.ru, <info@oktetlabs.ru>
- *          by request of Solarflare Communications
- *
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 as published
- * by the Free Software Foundation, incorporated herein by reference.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
- ****************************************************************************
- */
-
-#include <ci/efrm/debug.h>
-#include <ci/efrm/driver_private.h>
-#include <linux/proc_fs.h>
-
-/** Top level directory for sfc specific stats **/
-static struct proc_dir_entry *efrm_proc_root; /* = NULL */
-
-static int
-efrm_resource_read_proc(char *buf, char **start, off_t offset, int count,
-			int *eof, void *data);
-
-int efrm_install_proc_entries(void)
-{
-	/* create the top-level directory for etherfabric specific stuff */
-	efrm_proc_root = proc_mkdir("driver/sfc_resource", NULL);
-	if (!efrm_proc_root)
-		return -ENOMEM;
-
-	if (create_proc_read_entry("resources", 0, efrm_proc_root,
-				   efrm_resource_read_proc, 0) == NULL) {
-		EFRM_WARN("%s: Unable to create /proc/drivers/sfc_resource/"
-			  "resources", __func__);
-	}
-	return 0;
-}
-
-void efrm_uninstall_proc_entries(void)
-{
-	EFRM_ASSERT(efrm_proc_root);
-	remove_proc_entry("resources", efrm_proc_root);
-	remove_proc_entry(efrm_proc_root->name, efrm_proc_root->parent);
-	efrm_proc_root = NULL;
-}
-
-/****************************************************************************
- *
- * /proc/drivers/sfc/resources
- *
- ****************************************************************************/
-
-#define EFRM_PROC_PRINTF(buf, len, fmt, ...)				\
-	do {								\
-		if (count - len > 0)					\
-			len += snprintf(buf+len, count-len, (fmt),	\
-					__VA_ARGS__);			\
-	} while (0)
-
-static int
-efrm_resource_read_proc(char *buf, char **start, off_t offset, int count,
-			int *eof, void *data)
-{
-	irq_flags_t lock_flags;
-	int len = 0;
-	int type;
-	struct efrm_resource_manager *rm;
-
-	for (type = 0; type < EFRM_RESOURCE_NUM; type++) {
-		rm = efrm_rm_table[type];
-		if (rm == NULL)
-			continue;
-
-		EFRM_PROC_PRINTF(buf, len, "*** %s ***\n", rm->rm_name);
-
-		spin_lock_irqsave(&rm->rm_lock, lock_flags);
-		EFRM_PROC_PRINTF(buf, len, "current = %u\n", rm->rm_resources);
-		EFRM_PROC_PRINTF(buf, len, "    max = %u\n\n",
-				 rm->rm_resources_hiwat);
-		spin_unlock_irqrestore(&rm->rm_lock, lock_flags);
-	}
-
-	return count ? strlen(buf) : 0;
-}
diff -r 5b3d4d3c1166 drivers/net/sfc/sfc_resource/kfifo.c
--- a/drivers/net/sfc/sfc_resource/kfifo.c	Fri Nov 05 15:20:28 2010 +0000
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,208 +0,0 @@
-/*
- * A simple kernel FIFO implementation.
- *
- * Copyright (C) 2004 Stelian Pop <stelian@popies.net>
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
- *
- */
-
-/*
- * This file is stolen from the Linux kernel sources
- * (linux-2.6.22/kernel/kfifo.c) into sfc_resource driver.
- * It should be used for old kernels without kfifo implementation.
- * Most part of linux/kfifo.h is incorporated into
- * ci/efrm/sysdep_linux.h.
- */
-#include <ci/efrm/sysdep_linux.h>
-#ifdef HAS_NO_KFIFO
-
-#include <linux/kernel.h>
-#include <linux/module.h>
-#include <linux/slab.h>
-#include <linux/err.h>
-/*#include <linux/kfifo.h>*/
-
-/**
- * kfifo_init - allocates a new FIFO using a preallocated buffer
- * @buffer: the preallocated buffer to be used.
- * @size: the size of the internal buffer, this have to be a power of 2.
- * @gfp_mask: get_free_pages mask, passed to kmalloc()
- * @lock: the lock to be used to protect the fifo buffer
- *
- * Do NOT pass the kfifo to kfifo_free() after use! Simply free the
- * &struct kfifo with kfree().
- */
-struct kfifo *kfifo_init(unsigned char *buffer, unsigned int size,
-			 gfp_t gfp_mask, spinlock_t *lock)
-{
-	struct kfifo *fifo;
-
-	/* size must be a power of 2 */
-	BUG_ON(size & (size - 1));
-
-	fifo = kmalloc(sizeof(struct kfifo), gfp_mask);
-	if (!fifo)
-		return ERR_PTR(-ENOMEM);
-
-	fifo->buffer = buffer;
-	fifo->size = size;
-	fifo->in = fifo->out = 0;
-	fifo->lock = lock;
-
-	return fifo;
-}
-EXPORT_SYMBOL(kfifo_init);
-
-/**
- * kfifo_alloc - allocates a new FIFO and its internal buffer
- * @size: the size of the internal buffer to be allocated.
- * @gfp_mask: get_free_pages mask, passed to kmalloc()
- * @lock: the lock to be used to protect the fifo buffer
- *
- * The size will be rounded-up to a power of 2.
- */
-struct kfifo *kfifo_alloc(unsigned int size, gfp_t gfp_mask, spinlock_t *lock)
-{
-	unsigned char *buffer;
-	struct kfifo *ret;
-
-	/*
-	 * round up to the next power of 2, since our 'let the indices
-	 * wrap' tachnique works only in this case.
-	 */
-	if (size & (size - 1)) {
-		BUG_ON(size > 0x80000000);
-		size = roundup_pow_of_two(size);
-	}
-
-	buffer = kmalloc(size, gfp_mask);
-	if (!buffer)
-		return ERR_PTR(-ENOMEM);
-
-	ret = kfifo_init(buffer, size, gfp_mask, lock);
-
-	if (IS_ERR(ret))
-		kfree(buffer);
-
-	return ret;
-}
-EXPORT_SYMBOL(kfifo_alloc);
-
-/**
- * kfifo_free - frees the FIFO
- * @fifo: the fifo to be freed.
- */
-void kfifo_free(struct kfifo *fifo)
-{
-	kfree(fifo->buffer);
-	kfree(fifo);
-}
-EXPORT_SYMBOL(kfifo_free);
-
-/**
- * __kfifo_put - puts some data into the FIFO, no locking version
- * @fifo: the fifo to be used.
- * @buffer: the data to be added.
- * @len: the length of the data to be added.
- *
- * This function copies at most @len bytes from the @buffer into
- * the FIFO depending on the free space, and returns the number of
- * bytes copied.
- *
- * Note that with only one concurrent reader and one concurrent
- * writer, you don't need extra locking to use these functions.
- */
-unsigned int
-__kfifo_put(struct kfifo *fifo, unsigned char *buffer, unsigned int len)
-{
-	unsigned int l;
-
-	len = min(len, fifo->size - fifo->in + fifo->out);
-
-	/*
-	 * Ensure that we sample the fifo->out index -before- we
-	 * start putting bytes into the kfifo.
-	 */
-
-	smp_mb();
-
-	/* first put the data starting from fifo->in to buffer end */
-	l = min(len, fifo->size - (fifo->in & (fifo->size - 1)));
-	memcpy(fifo->buffer + (fifo->in & (fifo->size - 1)), buffer, l);
-
-	/* then put the rest (if any) at the beginning of the buffer */
-	memcpy(fifo->buffer, buffer + l, len - l);
-
-	/*
-	 * Ensure that we add the bytes to the kfifo -before-
-	 * we update the fifo->in index.
-	 */
-
-	smp_wmb();
-
-	fifo->in += len;
-
-	return len;
-}
-EXPORT_SYMBOL(__kfifo_put);
-
-/**
- * __kfifo_get - gets some data from the FIFO, no locking version
- * @fifo: the fifo to be used.
- * @buffer: where the data must be copied.
- * @len: the size of the destination buffer.
- *
- * This function copies at most @len bytes from the FIFO into the
- * @buffer and returns the number of copied bytes.
- *
- * Note that with only one concurrent reader and one concurrent
- * writer, you don't need extra locking to use these functions.
- */
-unsigned int
-__kfifo_get(struct kfifo *fifo, unsigned char *buffer, unsigned int len)
-{
-	unsigned int l;
-
-	len = min(len, fifo->in - fifo->out);
-
-	/*
-	 * Ensure that we sample the fifo->in index -before- we
-	 * start removing bytes from the kfifo.
-	 */
-
-	smp_rmb();
-
-	/* first get the data from fifo->out until the end of the buffer */
-	l = min(len, fifo->size - (fifo->out & (fifo->size - 1)));
-	memcpy(buffer, fifo->buffer + (fifo->out & (fifo->size - 1)), l);
-
-	/* then get the rest (if any) from the beginning of the buffer */
-	memcpy(buffer + l, fifo->buffer, len - l);
-
-	/*
-	 * Ensure that we remove the bytes from the kfifo -before-
-	 * we update the fifo->out index.
-	 */
-
-	smp_mb();
-
-	fifo->out += len;
-
-	return len;
-}
-EXPORT_SYMBOL(__kfifo_get);
-
-#endif
diff -r 5b3d4d3c1166 drivers/net/sfc/sfc_resource/linux_resource_internal.h
--- a/drivers/net/sfc/sfc_resource/linux_resource_internal.h	Fri Nov 05 15:20:28 2010 +0000
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,76 +0,0 @@
-/****************************************************************************
- * Driver for Solarflare network controllers -
- *          resource management for Xen backend, OpenOnload, etc
- *           (including support for SFE4001 10GBT NIC)
- *
- * This file contains Linux-specific API internal for the resource driver.
- *
- * Copyright 2005-2007: Solarflare Communications Inc,
- *                      9501 Jeronimo Road, Suite 250,
- *                      Irvine, CA 92618, USA
- *
- * Developed and maintained by Solarflare Communications:
- *                      <linux-xen-drivers@solarflare.com>
- *                      <onload-dev@solarflare.com>
- *
- * Certain parts of the driver were implemented by
- *          Alexandra Kossovsky <Alexandra.Kossovsky@oktetlabs.ru>
- *          OKTET Labs Ltd, Russia,
- *          http://oktetlabs.ru, <info@oktetlabs.ru>
- *          by request of Solarflare Communications
- *
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 as published
- * by the Free Software Foundation, incorporated herein by reference.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
- ****************************************************************************
- */
-
-#ifndef __LINUX_RESOURCE_INTERNAL__
-#define __LINUX_RESOURCE_INTERNAL__
-
-#include <ci/driver/resource/linux_efhw_nic.h>
-#include <ci/efrm/debug.h>
-#include <ci/efrm/driver_private.h>
-#include <ci/driver/efab/hardware.h>
-
-
-/*! Linux specific EtherFabric initialisation */
-extern int
-linux_efrm_nic_ctor(struct linux_efhw_nic *, struct pci_dev *,
-		    spinlock_t *reg_lock,
-		    unsigned nic_flags, unsigned nic_options);
-
-/*! Linux specific EtherFabric initialisation */
-extern void linux_efrm_nic_dtor(struct linux_efhw_nic *);
-
-/*! Linux specific EtherFabric initialisation -- interrupt registration */
-extern int linux_efrm_irq_ctor(struct linux_efhw_nic *);
-
-/*! Linux specific  EtherFabric initialisation -- interrupt deregistration */
-extern void linux_efrm_irq_dtor(struct linux_efhw_nic *);
-
-extern int  efrm_driverlink_register(void);
-extern void efrm_driverlink_unregister(void);
-
-extern int
-efrm_nic_add(struct pci_dev *dev, unsigned int opts, const uint8_t *mac_addr,
-	     struct linux_efhw_nic **lnic_out, spinlock_t *reg_lock,
-	     int bt_min, int bt_max, int non_irq_evq,
-	     const struct vi_resource_dimensions *);
-extern void efrm_nic_del(struct linux_efhw_nic *);
-
-
-extern int efrm_install_proc_entries(void);
-extern void efrm_uninstall_proc_entries(void);
-
-#endif  /* __LINUX_RESOURCE_INTERNAL__ */
diff -r 5b3d4d3c1166 drivers/net/sfc/sfc_resource/nic.c
--- a/drivers/net/sfc/sfc_resource/nic.c	Fri Nov 05 15:20:28 2010 +0000
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,176 +0,0 @@
-/****************************************************************************
- * Driver for Solarflare network controllers -
- *          resource management for Xen backend, OpenOnload, etc
- *           (including support for SFE4001 10GBT NIC)
- *
- * This file contains EtherFabric Generic NIC instance (init, interrupts,
- * etc)
- *
- * Copyright 2005-2007: Solarflare Communications Inc,
- *                      9501 Jeronimo Road, Suite 250,
- *                      Irvine, CA 92618, USA
- *
- * Developed and maintained by Solarflare Communications:
- *                      <linux-xen-drivers@solarflare.com>
- *                      <onload-dev@solarflare.com>
- *
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 as published
- * by the Free Software Foundation, incorporated herein by reference.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
- ****************************************************************************
- */
-
-#include <ci/efhw/debug.h>
-#include <ci/driver/efab/hardware.h>
-#include <ci/efhw/falcon.h>
-#include <ci/efhw/nic.h>
-#include <ci/efhw/eventq.h>
-
-
-int efhw_device_type_init(struct efhw_device_type *dt,
-			  int vendor_id, int device_id,
-			  int class_revision)
-{
-	if (vendor_id != 0x1924)
-		return 0;
-
-	switch (device_id) {
-	case 0x0703:
-	case 0x6703:
-		dt->arch = EFHW_ARCH_FALCON;
-		dt->variant = 'A';
-		switch (class_revision) {
-		case 0:
-			dt->revision = 0;
-			break;
-		case 1:
-			dt->revision = 1;
-			break;
-		default:
-			return 0;
-		}
-		break;
-	case 0x0710:
-		dt->arch = EFHW_ARCH_FALCON;
-		dt->variant = 'B';
-		switch (class_revision) {
-		case 2:
-			dt->revision = 0;
-			break;
-		default:
-			return 0;
-		}
-		break;
-	default:
-		return 0;
-	}
-
-	return 1;
-}
-
-
-/*--------------------------------------------------------------------
- *
- * NIC Initialisation
- *
- *--------------------------------------------------------------------*/
-
-/* make this separate from initialising data structure
-** to allow this to be called at a later time once we can access PCI
-** config space to find out what hardware we have
-*/
-void efhw_nic_init(struct efhw_nic *nic, unsigned flags, unsigned options,
-		   struct efhw_device_type dev_type)
-{
-	nic->devtype = dev_type;
-	nic->flags = flags;
-	nic->options = options;
-	nic->bar_ioaddr = 0;
-	spin_lock_init(&nic->the_reg_lock);
-	nic->reg_lock = &nic->the_reg_lock;
-	nic->mtu = 1500 + ETH_HLEN;
-
-	nic->irq_unit = EFHW_IRQ_UNIT_UNUSED;
-
-	nic->evq_sizes = 512 | 1024 | 2048 | 4096 | 8192 |
-		16384 | 32768;
-	nic->txq_sizes = 512 | 1024 | 2048 | 4096;
-	nic->rxq_sizes = 512 | 1024 | 2048 | 4096;
-	nic->efhw_func = &falcon_char_functional_units;
-	nic->ctr_ap_bytes = EFHW_64M;
-	switch (nic->devtype.variant) {
-	case 'A':
-		nic->ctr_ap_bar = FALCON_S_CTR_AP_BAR;
-		nic->num_evqs   = 4096;
-		nic->num_dmaqs  = 4096;
-		nic->num_timers = 4096;
-		break;
-	case 'B':
-		nic->flags |= NIC_FLAG_NO_INTERRUPT;
-		nic->ctr_ap_bar = FALCON_P_CTR_AP_BAR;
-		nic->num_evqs   = 4096;
-		nic->num_dmaqs  = 4096;
-		nic->num_timers = 4096;
-		break;
-	default:
-		EFHW_ASSERT(0);
-		break;
-	}
-}
-
-
-void efhw_nic_close_interrupts(struct efhw_nic *nic)
-{
-	EFHW_ASSERT(nic);
-	if (!efhw_nic_have_hw(nic))
-		return;
-
-	EFHW_ASSERT(efhw_nic_have_hw(nic));
-
-	if (nic->irq_unit != EFHW_IRQ_UNIT_UNUSED)
-		efhw_nic_interrupt_disable(nic);
-}
-
-void efhw_nic_dtor(struct efhw_nic *nic)
-{
-	EFHW_ASSERT(nic);
-
-	/* Check that we have functional units because the software only
-	 * driver doesn't initialise anything hardware related any more */
-
-	/* close interrupts is called first because the act of deregistering
-	   the driver could cause this driver to change from master to slave
-	   and hence the implicit interrupt mappings would be wrong */
-
-	EFHW_TRACE("%s: functional units ... ", __func__);
-
-	if (efhw_nic_have_functional_units(nic)) {
-		efhw_nic_close_interrupts(nic);
-		efhw_nic_close_hardware(nic);
-	}
-	EFHW_TRACE("%s: functional units ... done", __func__);
-
-	/* destroy event queues */
-	EFHW_TRACE("%s: event queues ... ", __func__);
-
-	if (nic->interrupting_evq.evq_mask)
-		efhw_keventq_dtor(nic, &nic->interrupting_evq);
-	if (nic->non_interrupting_evq.evq_mask)
-		efhw_keventq_dtor(nic, &nic->non_interrupting_evq);
-
-	EFHW_TRACE("%s: event queues ... done", __func__);
-
-	spin_lock_destroy(&nic->the_reg_lock);
-
-	EFHW_TRACE("%s: DONE", __func__);
-}
diff -r 5b3d4d3c1166 drivers/net/sfc/sfc_resource/resource_driver.c
--- a/drivers/net/sfc/sfc_resource/resource_driver.c	Fri Nov 05 15:20:28 2010 +0000
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,600 +0,0 @@
-/****************************************************************************
- * Driver for Solarflare network controllers -
- *          resource management for Xen backend, OpenOnload, etc
- *           (including support for SFE4001 10GBT NIC)
- *
- * This file contains main driver entry points.
- *
- * Copyright 2005-2007: Solarflare Communications Inc,
- *                      9501 Jeronimo Road, Suite 250,
- *                      Irvine, CA 92618, USA
- *
- * Developed and maintained by Solarflare Communications:
- *                      <linux-xen-drivers@solarflare.com>
- *                      <onload-dev@solarflare.com>
- *
- * Certain parts of the driver were implemented by
- *          Alexandra Kossovsky <Alexandra.Kossovsky@oktetlabs.ru>
- *          OKTET Labs Ltd, Russia,
- *          http://oktetlabs.ru, <info@oktetlabs.ru>
- *          by request of Solarflare Communications
- *
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 as published
- * by the Free Software Foundation, incorporated herein by reference.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
- ****************************************************************************
- */
-
-#include "linux_resource_internal.h"
-#include "kernel_compat.h"
-#include <ci/efrm/nic_table.h>
-#include <ci/driver/resource/efx_vi.h>
-#include <ci/efhw/eventq.h>
-#include <ci/efhw/nic.h>
-#include <ci/efrm/buffer_table.h>
-#include <ci/efrm/vi_resource_private.h>
-#include <ci/efrm/driver_private.h>
-
-MODULE_AUTHOR("Solarflare Communications");
-MODULE_LICENSE("GPL");
-
-static struct efhw_ev_handler ev_handler = {
-	.wakeup_fn = efrm_handle_wakeup_event,
-	.timeout_fn = efrm_handle_timeout_event,
-	.dmaq_flushed_fn = efrm_handle_dmaq_flushed,
-};
-
-const int max_hardware_init_repeats = 10;
-
-/*--------------------------------------------------------------------
- *
- * Module load time variables
- *
- *--------------------------------------------------------------------*/
-/* See docs/notes/pci_alloc_consistent */
-static int do_irq = 1;		/* enable interrupts */
-
-#if defined(CONFIG_X86_XEN)
-static int irq_moderation = 60;	/* interrupt moderation (60 usec) */
-#else
-static int irq_moderation = 20;	/* interrupt moderation (20 usec) */
-#endif
-static int nic_options = NIC_OPT_DEFAULT;
-int efx_vi_eventq_size = EFX_VI_EVENTQ_SIZE_DEFAULT;
-
-module_param(do_irq, int, S_IRUGO);
-MODULE_PARM_DESC(do_irq, "Enable interrupts.  "
-		 "Do not turn it off unless you know what are you doing.");
-module_param(irq_moderation, int, S_IRUGO);
-MODULE_PARM_DESC(irq_moderation, "IRQ moderation in usec");
-module_param(nic_options, int, S_IRUGO);
-MODULE_PARM_DESC(nic_options, "Nic options -- see efhw_types.h");
-module_param(efx_vi_eventq_size, int, S_IRUGO);
-MODULE_PARM_DESC(efx_vi_eventq_size,
-		 "Size of event queue allocated by efx_vi library");
-
-/*--------------------------------------------------------------------
- *
- * Linux specific NIC initialisation
- *
- *--------------------------------------------------------------------*/
-
-static inline irqreturn_t
-linux_efrm_interrupt(int irr, void *dev_id)
-{
-	return efhw_nic_interrupt((struct efhw_nic *)dev_id);
-}
-
-int linux_efrm_irq_ctor(struct linux_efhw_nic *lnic)
-{
-	struct efhw_nic *nic = &lnic->efrm_nic.efhw_nic;
-
-	nic->flags &= ~NIC_FLAG_MSI;
-	if (nic->flags & NIC_FLAG_TRY_MSI) {
-		int rc = pci_enable_msi(lnic->pci_dev);
-		if (rc < 0) {
-			EFRM_WARN("%s: Could not enable MSI (%d)",
-				  __func__, rc);
-			EFRM_WARN("%s: Continuing with legacy interrupt mode",
-				  __func__);
-		} else {
-			EFRM_NOTICE("%s: MSI enabled", __func__);
-			nic->flags |= NIC_FLAG_MSI;
-		}
-	}
-
-	if (request_irq(lnic->pci_dev->irq, linux_efrm_interrupt,
-			IRQF_SHARED, "sfc_resource", nic)) {
-		EFRM_ERR("Request for interrupt #%d failed",
-			 lnic->pci_dev->irq);
-		nic->flags &= ~NIC_FLAG_OS_IRQ_EN;
-		return -EBUSY;
-	}
-	nic->flags |= NIC_FLAG_OS_IRQ_EN;
-
-	return 0;
-}
-
-void linux_efrm_irq_dtor(struct linux_efhw_nic *lnic)
-{
-	EFRM_TRACE("%s: start", __func__);
-
-	if (lnic->efrm_nic.efhw_nic.flags & NIC_FLAG_OS_IRQ_EN) {
-		free_irq(lnic->pci_dev->irq, &lnic->efrm_nic.efhw_nic);
-		lnic->efrm_nic.efhw_nic.flags &= ~NIC_FLAG_OS_IRQ_EN;
-	}
-
-	if (lnic->efrm_nic.efhw_nic.flags & NIC_FLAG_MSI) {
-		pci_disable_msi(lnic->pci_dev);
-		lnic->efrm_nic.efhw_nic.flags &= ~NIC_FLAG_MSI;
-	}
-
-	EFRM_TRACE("%s: done", __func__);
-}
-
-/* Allocate buffer table entries for a particular NIC.
- */
-static int efrm_nic_buffer_table_alloc(struct efhw_nic *nic)
-{
-	int capacity;
-	int page_order;
-	int rc;
-
-	/* Choose queue size. */
-	for (capacity = 8192; capacity <= nic->evq_sizes; capacity <<= 1) {
-		if (capacity > nic->evq_sizes) {
-			EFRM_ERR
-			    ("%s: Unable to choose EVQ size (supported=%x)",
-			     __func__, nic->evq_sizes);
-			return -E2BIG;
-		} else if (capacity & nic->evq_sizes)
-			break;
-	}
-
-	nic->interrupting_evq.hw.capacity = capacity;
-	nic->interrupting_evq.hw.buf_tbl_alloc.base = (unsigned)-1;
-
-	nic->non_interrupting_evq.hw.capacity = capacity;
-	nic->non_interrupting_evq.hw.buf_tbl_alloc.base = (unsigned)-1;
-
-	/* allocate buffer table entries to map onto the iobuffer */
-	page_order = get_order(capacity * sizeof(efhw_event_t));
-	if (!(nic->flags & NIC_FLAG_NO_INTERRUPT)) {
-		rc = efrm_buffer_table_alloc(page_order,
-					     &nic->interrupting_evq
-					     .hw.buf_tbl_alloc);
-		if (rc < 0) {
-			EFRM_WARN
-			    ("%s: failed (%d) to alloc %d buffer table entries",
-			     __func__, rc, page_order);
-			return rc;
-		}
-	}
-	rc = efrm_buffer_table_alloc(page_order,
-				     &nic->non_interrupting_evq.hw.
-				     buf_tbl_alloc);
-	if (rc < 0) {
-		EFRM_WARN
-		    ("%s: failed (%d) to alloc %d buffer table entries",
-		     __func__, rc, page_order);
-		return rc;
-	}
-
-	return 0;
-}
-
-/* Free buffer table entries allocated for a particular NIC.
- */
-static void efrm_nic_buffer_table_free(struct efhw_nic *nic)
-{
-	if (nic->interrupting_evq.hw.buf_tbl_alloc.base != (unsigned)-1)
-		efrm_buffer_table_free(&nic->interrupting_evq.hw
-				       .buf_tbl_alloc);
-	if (nic->non_interrupting_evq.hw.buf_tbl_alloc.base != (unsigned)-1)
-		efrm_buffer_table_free(&nic->non_interrupting_evq
-				       .hw.buf_tbl_alloc);
-}
-
-static int iomap_bar(struct linux_efhw_nic *lnic, size_t len)
-{
-	volatile char __iomem *ioaddr;
-
-	ioaddr = ioremap_nocache(lnic->ctr_ap_pci_addr, len);
-	if (ioaddr == 0)
-		return -ENOMEM;
-
-	lnic->efrm_nic.efhw_nic.bar_ioaddr = ioaddr;
-	return 0;
-}
-
-static int linux_efhw_nic_map_ctr_ap(struct linux_efhw_nic *lnic)
-{
-	struct efhw_nic *nic = &lnic->efrm_nic.efhw_nic;
-	int rc;
-
-	rc = iomap_bar(lnic, nic->ctr_ap_bytes);
-
-	/* Bug 5195: workaround for now. */
-	if (rc != 0 && nic->ctr_ap_bytes > 16 * 1024 * 1024) {
-		/* Try half the size for now. */
-		nic->ctr_ap_bytes /= 2;
-		EFRM_WARN("Bug 5195 WORKAROUND: retrying iomap of %d bytes",
-			  nic->ctr_ap_bytes);
-		rc = iomap_bar(lnic, nic->ctr_ap_bytes);
-	}
-
-	if (rc < 0) {
-		EFRM_ERR("Failed (%d) to map bar (%d bytes)",
-			 rc, nic->ctr_ap_bytes);
-		return rc;
-	}
-
-	return rc;
-}
-
-int
-linux_efrm_nic_ctor(struct linux_efhw_nic *lnic, struct pci_dev *dev,
-		    spinlock_t *reg_lock,
-		    unsigned nic_flags, unsigned nic_options)
-{
-	struct efhw_device_type dev_type;
-	struct efhw_nic *nic = &lnic->efrm_nic.efhw_nic;
-	u8 class_revision;
-	int rc;
-
-	rc = pci_read_config_byte(dev, PCI_CLASS_REVISION, &class_revision);
-	if (rc != 0) {
-		EFRM_ERR("%s: pci_read_config_byte failed (%d)",
-			 __func__, rc);
-		return rc;
-	}
-
-	if (!efhw_device_type_init(&dev_type, dev->vendor, dev->device,
-				   class_revision)) {
-		EFRM_ERR("%s: efhw_device_type_init failed %04x:%04x(%d)",
-			 __func__, (unsigned) dev->vendor,
-			 (unsigned) dev->device, (int) class_revision);
-		return -ENODEV;
-	}
-
-	EFRM_NOTICE("attaching device type %04x:%04x %d:%c%d",
-		    (unsigned) dev->vendor, (unsigned) dev->device,
-		    dev_type.arch, dev_type.variant, dev_type.revision);
-
-	/* Initialise the adapter-structure. */
-	efhw_nic_init(nic, nic_flags, nic_options, dev_type);
-	lnic->pci_dev = dev;
-
-	rc = pci_enable_device(dev);
-	if (rc < 0) {
-		EFRM_ERR("%s: pci_enable_device failed (%d)",
-			 __func__, rc);
-		return rc;
-	}
-
-	lnic->ctr_ap_pci_addr = pci_resource_start(dev, nic->ctr_ap_bar);
-
-	if (!pci_dma_supported(dev, (dma_addr_t)EFHW_DMA_ADDRMASK)) {
-		EFRM_ERR("%s: pci_dma_supported(%lx) failed", __func__,
-			 (unsigned long)EFHW_DMA_ADDRMASK);
-		return -ENODEV;
-	}
-
-	if (pci_set_dma_mask(dev, (dma_addr_t)EFHW_DMA_ADDRMASK)) {
-		EFRM_ERR("%s: pci_set_dma_mask(%lx) failed", __func__,
-			 (unsigned long)EFHW_DMA_ADDRMASK);
-		return -ENODEV;
-	}
-
-	if (pci_set_consistent_dma_mask(dev, (dma_addr_t)EFHW_DMA_ADDRMASK)) {
-		EFRM_ERR("%s: pci_set_consistent_dma_mask(%lx) failed",
-			 __func__, (unsigned long)EFHW_DMA_ADDRMASK);
-		return -ENODEV;
-	}
-
-	rc = linux_efhw_nic_map_ctr_ap(lnic);
-	if (rc < 0)
-		return rc;
-
-	/* By default struct efhw_nic contains its own lock for protecting
-	 * access to nic registers.  We override it with a pointer to the
-	 * lock in the net driver.  This is needed when resource and net
-	 * drivers share a single PCI function (falcon B series).
-	 */
-	nic->reg_lock = reg_lock;
-	return 0;
-}
-
-void linux_efrm_nic_dtor(struct linux_efhw_nic *lnic)
-{
-	struct efhw_nic *nic = &lnic->efrm_nic.efhw_nic;
-	volatile char __iomem *bar_ioaddr = nic->bar_ioaddr;
-
-	efhw_nic_dtor(nic);
-
-	/* Unmap the bar. */
-	EFRM_ASSERT(bar_ioaddr);
-	iounmap(bar_ioaddr);
-	nic->bar_ioaddr = 0;
-}
-
-/****************************************************************************
- *
- * efrm_tasklet - used to poll the eventq which may result in further callbacks
- *
- ****************************************************************************/
-
-static void efrm_tasklet(unsigned long pdev)
-{
-	struct efhw_nic *nic = (struct efhw_nic *)pdev;
-
-	EFRM_ASSERT(!(nic->flags & NIC_FLAG_NO_INTERRUPT));
-
-	efhw_keventq_poll(nic, &nic->interrupting_evq);
-	EFRM_TRACE("%s: complete", __func__);
-}
-
-/****************************************************************************
- *
- * char driver specific interrupt callbacks -- run at hard IRQL
- *
- ****************************************************************************/
-static void efrm_handle_eventq_irq(struct efhw_nic *nic, int evq)
-{
-	/* NB. The interrupt must have already been acked (for legacy mode). */
-
-	EFRM_TRACE("%s: starting tasklet", __func__);
-	EFRM_ASSERT(!(nic->flags & NIC_FLAG_NO_INTERRUPT));
-
-	tasklet_schedule(&linux_efhw_nic(nic)->tasklet);
-}
-
-/* A count of how many NICs this driver knows about. */
-static int n_nics_probed;
-
-/****************************************************************************
- *
- * efrm_nic_add: add the NIC to the resource driver
- *
- * NOTE: the flow of control through this routine is quite subtle
- * because of the number of operations that can fail. We therefore
- * take the apporaching of keeping the return code (rc) variable
- * accurate, and only do operations while it is non-negative. Tear down
- * is done at the end if rc is negative, depending on what has been set up
- * by that point.
- *
- * So basically just make sure that any code you add checks rc>=0 before
- * doing any work and you'll be fine.
- *
- ****************************************************************************/
-int
-efrm_nic_add(struct pci_dev *dev, unsigned flags, const uint8_t *mac_addr,
-	     struct linux_efhw_nic **lnic_out, spinlock_t *reg_lock,
-	     int bt_min, int bt_lim, int non_irq_evq,
-	     const struct vi_resource_dimensions *res_dim)
-{
-	struct linux_efhw_nic *lnic = NULL;
-	struct efhw_nic *nic = NULL;
-	int count = 0, rc = 0, resources_init = 0;
-	int constructed = 0;
-	int registered_nic = 0;
-	int buffers_allocated = 0;
-	static unsigned nic_index; /* = 0; */
-
-	EFRM_TRACE("%s: device detected (Slot '%s', IRQ %d)", __func__,
-		   pci_name(dev) ? pci_name(dev) : "?", dev->irq);
-
-	/* Ensure that we have room for the new adapter-structure. */
-	if (efrm_nic_tablep->nic_count == EFHW_MAX_NR_DEVS) {
-		EFRM_WARN("%s: WARNING: too many devices", __func__);
-		rc = -ENOMEM;
-		goto failed;
-	}
-
-	if (n_nics_probed == 0) {
-		rc = efrm_resources_init(res_dim, bt_min, bt_lim);
-		if (rc != 0)
-			goto failed;
-		resources_init = 1;
-	}
-
-	/* Allocate memory for the new adapter-structure. */
-	lnic = kmalloc(sizeof(*lnic), GFP_KERNEL);
-	if (lnic == NULL) {
-		EFRM_ERR("%s: ERROR: failed to allocate memory", __func__);
-		rc = -ENOMEM;
-		goto failed;
-	}
-	memset(lnic, 0, sizeof(*lnic));
-	nic = &lnic->efrm_nic.efhw_nic;
-
-	lnic->ev_handlers = &ev_handler;
-
-	/* OS specific hardware mappings */
-	rc = linux_efrm_nic_ctor(lnic, dev, reg_lock, flags, nic_options);
-	if (rc < 0) {
-		EFRM_ERR("%s: ERROR: initialisation failed", __func__);
-		goto failed;
-	}
-
-	constructed = 1;
-
-	/* Tell the driver about the NIC - this needs to be done before the
-	   resources managers get created below. Note we haven't initialised
-	   the hardware yet, and I don't like doing this before the perhaps
-	   unreliable hardware initialisation. However, there's quite a lot
-	   of code to review if we wanted to hardware init before bringing
-	   up the resource managers. */
-	rc = efrm_driver_register_nic(&lnic->efrm_nic, nic_index,
-				      /* TODO: ifindex */ nic_index);
-	if (rc < 0) {
-		EFRM_ERR("%s: cannot register nic %d with nic error code %d",
-			 __func__, efrm_nic_tablep->nic_count, rc);
-		goto failed;
-	}
-	++nic_index;
-	registered_nic = 1;
-
-	rc = efrm_nic_buffer_table_alloc(nic);
-	if (rc < 0)
-		goto failed;
-	buffers_allocated = 1;
-
-	/****************************************************/
-	/* hardware bringup                                 */
-	/****************************************************/
-	/* Detecting hardware can be a slightly unreliable process;
-	   we want to make sure that we maximise our chances, so we
-	   loop a few times until all is good. */
-	for (count = 0; count < max_hardware_init_repeats; count++) {
-		rc = efhw_nic_init_hardware(nic, &ev_handler, mac_addr,
-					    non_irq_evq);
-		if (rc >= 0)
-			break;
-
-		/* pain */
-		EFRM_ERR
-		    ("error - hardware initialisation failed code %d, "
-		     "attempt %d of %d", rc, count + 1,
-		     max_hardware_init_repeats);
-	}
-	if (rc < 0)
-		goto failed;
-
-	tasklet_init(&lnic->tasklet, efrm_tasklet, (ulong)nic);
-
-	/* set up interrupt handlers (hard-irq) */
-	nic->irq_handler = &efrm_handle_eventq_irq;
-
-	/* this device can now take management interrupts */
-	if (do_irq && !(nic->flags & NIC_FLAG_NO_INTERRUPT)) {
-		rc = linux_efrm_irq_ctor(lnic);
-		if (rc < 0) {
-			EFRM_ERR("Interrupt initialisation failed (%d)", rc);
-			goto failed;
-		}
-		efhw_nic_set_interrupt_moderation(nic, -1, irq_moderation);
-		efhw_nic_interrupt_enable(nic);
-	}
-	EFRM_TRACE("interrupts are %sregistered", do_irq ? "" : "not ");
-
-	*lnic_out = lnic;
-	EFRM_ASSERT(rc == 0);
-	++n_nics_probed;
-	return 0;
-
-failed:
-	if (buffers_allocated)
-		efrm_nic_buffer_table_free(nic);
-	if (registered_nic)
-		efrm_driver_unregister_nic(&lnic->efrm_nic);
-	if (constructed)
-		linux_efrm_nic_dtor(lnic);
-	kfree(lnic); /* safe in any case */
-	if (resources_init)
-		efrm_resources_fini();
-	return rc;
-}
-
-/****************************************************************************
- *
- * efrm_nic_del: Remove the nic from the resource driver structures
- *
- ****************************************************************************/
-void efrm_nic_del(struct linux_efhw_nic *lnic)
-{
-	struct efhw_nic *nic = &lnic->efrm_nic.efhw_nic;
-
-	EFRM_TRACE("%s:", __func__);
-	EFRM_ASSERT(nic);
-
-	efrm_nic_buffer_table_free(nic);
-
-	efrm_driver_unregister_nic(&lnic->efrm_nic);
-
-	/*
-	 * Synchronise here with any running ISR.
-	 * Remove the OS handler. There should be no IRQs being generated
-	 * by our NIC at this point.
-	 */
-	if (efhw_nic_have_functional_units(nic)) {
-		efhw_nic_close_interrupts(nic);
-		linux_efrm_irq_dtor(lnic);
-		tasklet_kill(&lnic->tasklet);
-	}
-
-	/* Close down hardware and free resources. */
-	linux_efrm_nic_dtor(lnic);
-	kfree(lnic);
-
-	if (--n_nics_probed == 0)
-		efrm_resources_fini();
-
-	EFRM_TRACE("%s: done", __func__);
-}
-
-/****************************************************************************
- *
- * init_module: register as a PCI driver.
- *
- ****************************************************************************/
-static int init_sfc_resource(void)
-{
-	int rc = 0;
-
-	EFRM_TRACE("%s: RESOURCE driver starting", __func__);
-
-	efrm_driver_ctor();
-
-	/* Register the driver so that our 'probe' function is called for
-	 * each EtherFabric device in the system.
-	 */
-	rc = efrm_driverlink_register();
-	if (rc == -ENODEV)
-		EFRM_ERR("%s: no devices found", __func__);
-	if (rc < 0)
-		goto failed_driverlink;
-
-	if (efrm_install_proc_entries() != 0) {
-		/* Do not fail, but print a warning */
-		EFRM_WARN("%s: WARNING: failed to install /proc entries",
-			  __func__);
-	}
-
-	return 0;
-
-failed_driverlink:
-	efrm_driver_dtor();
-	return rc;
-}
-
-/****************************************************************************
- *
- * cleanup_module: module-removal entry-point
- *
- ****************************************************************************/
-static void cleanup_sfc_resource(void)
-{
-	efrm_uninstall_proc_entries();
-
-	efrm_driverlink_unregister();
-
-	/* Clean up char-driver specific initialisation.
-	   - driver dtor can use both work queue and buffer table entries */
-	efrm_driver_dtor();
-
-	EFRM_TRACE("%s: unloaded", __func__);
-}
-
-module_init(init_sfc_resource);
-module_exit(cleanup_sfc_resource);
diff -r 5b3d4d3c1166 drivers/net/sfc/sfc_resource/resource_manager.c
--- a/drivers/net/sfc/sfc_resource/resource_manager.c	Fri Nov 05 15:20:28 2010 +0000
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,145 +0,0 @@
-/****************************************************************************
- * Driver for Solarflare network controllers -
- *          resource management for Xen backend, OpenOnload, etc
- *           (including support for SFE4001 10GBT NIC)
- *
- * This file contains generic code for resources and resource managers.
- *
- * Copyright 2005-2007: Solarflare Communications Inc,
- *                      9501 Jeronimo Road, Suite 250,
- *                      Irvine, CA 92618, USA
- *
- * Developed and maintained by Solarflare Communications:
- *                      <linux-xen-drivers@solarflare.com>
- *                      <onload-dev@solarflare.com>
- *
- * Certain parts of the driver were implemented by
- *          Alexandra Kossovsky <Alexandra.Kossovsky@oktetlabs.ru>
- *          OKTET Labs Ltd, Russia,
- *          http://oktetlabs.ru, <info@oktetlabs.ru>
- *          by request of Solarflare Communications
- *
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 as published
- * by the Free Software Foundation, incorporated herein by reference.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
- ****************************************************************************
- */
-
-#include <ci/efrm/debug.h>
-#include <ci/efrm/nic_table.h>
-#include <ci/efhw/iopage.h>
-#include <ci/efrm/driver_private.h>
-#include <ci/efrm/private.h>
-#include "efrm_internal.h"
-
-/**********************************************************************
- * struct efrm_resource_manager
- */
-
-void efrm_resource_manager_dtor(struct efrm_resource_manager *rm)
-{
-	EFRM_RESOURCE_MANAGER_ASSERT_VALID(rm);
-
-	/* call destructor */
-	EFRM_DO_DEBUG(if (rm->rm_resources)
-		      EFRM_ERR("%s: %s leaked %d resources",
-			       __func__, rm->rm_name, rm->rm_resources));
-	EFRM_ASSERT(rm->rm_resources == 0);
-	EFRM_ASSERT(list_empty(&rm->rm_resources_list));
-
-	rm->rm_dtor(rm);
-
-	/* clear out things built by efrm_resource_manager_ctor */
-	spin_lock_destroy(&rm->rm_lock);
-
-	/* and the free the memory */
-	EFRM_DO_DEBUG(memset(rm, 0, sizeof(*rm)));
-	kfree(rm);
-}
-
-/* Construct a resource manager.  Resource managers are singletons. */
-int
-efrm_resource_manager_ctor(struct efrm_resource_manager *rm,
-			   void (*dtor)(struct efrm_resource_manager *),
-			   const char *name, unsigned type)
-{
-	EFRM_ASSERT(rm);
-	EFRM_ASSERT(dtor);
-
-	rm->rm_name = name;
-	EFRM_DO_DEBUG(rm->rm_type = type);
-	rm->rm_dtor = dtor;
-	spin_lock_init(&rm->rm_lock);
-	rm->rm_resources = 0;
-	rm->rm_resources_hiwat = 0;
-	INIT_LIST_HEAD(&rm->rm_resources_list);
-	EFRM_RESOURCE_MANAGER_ASSERT_VALID(rm);
-	return 0;
-}
-
-
-void efrm_client_add_resource(struct efrm_client *client,
-			      struct efrm_resource *rs)
-{
-	struct efrm_resource_manager *rm;
-	irq_flags_t lock_flags;
-
-	EFRM_ASSERT(client != NULL);
-	EFRM_ASSERT(rs != NULL);
-
-	spin_lock_irqsave(&efrm_nic_tablep->lock, lock_flags);
-	rm = efrm_rm_table[EFRM_RESOURCE_TYPE(rs->rs_handle)];
-	++rm->rm_resources;
-	list_add(&rs->rs_manager_link, &rm->rm_resources_list);
-	if (rm->rm_resources > rm->rm_resources_hiwat)
-		rm->rm_resources_hiwat = rm->rm_resources;
-	rs->rs_client = client;
-	++client->ref_count;
-	list_add(&rs->rs_client_link, &client->resources);
-	spin_unlock_irqrestore(&efrm_nic_tablep->lock, lock_flags);
-}
-
-
-void efrm_resource_ref(struct efrm_resource *rs)
-{
-	irq_flags_t lock_flags;
-	spin_lock_irqsave(&efrm_nic_tablep->lock, lock_flags);
-	++rs->rs_ref_count;
-	spin_unlock_irqrestore(&efrm_nic_tablep->lock, lock_flags);
-}
-EXPORT_SYMBOL(efrm_resource_ref);
-
-
-int __efrm_resource_release(struct efrm_resource *rs)
-{
-	struct efrm_resource_manager *rm;
-	irq_flags_t lock_flags;
-	int free_rs;
-
-	spin_lock_irqsave(&efrm_nic_tablep->lock, lock_flags);
-	free_rs = --rs->rs_ref_count == 0;
-	if (free_rs) {
-		rm = efrm_rm_table[EFRM_RESOURCE_TYPE(rs->rs_handle)];
-		EFRM_ASSERT(rm->rm_resources > 0);
-		--rm->rm_resources;
-		list_del(&rs->rs_manager_link);
-		list_del(&rs->rs_client_link);
-	}
-	spin_unlock_irqrestore(&efrm_nic_tablep->lock, lock_flags);
-	return free_rs;
-}
-EXPORT_SYMBOL(__efrm_resource_release);
-
-/*
- * vi: sw=8:ai:aw
- */
diff -r 5b3d4d3c1166 drivers/net/sfc/sfc_resource/resources.c
--- a/drivers/net/sfc/sfc_resource/resources.c	Fri Nov 05 15:20:28 2010 +0000
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,94 +0,0 @@
-/****************************************************************************
- * Driver for Solarflare network controllers -
- *          resource management for Xen backend, OpenOnload, etc
- *           (including support for SFE4001 10GBT NIC)
- *
- * This file contains resource managers initialisation functions.
- *
- * Copyright 2005-2007: Solarflare Communications Inc,
- *                      9501 Jeronimo Road, Suite 250,
- *                      Irvine, CA 92618, USA
- *
- * Developed and maintained by Solarflare Communications:
- *                      <linux-xen-drivers@solarflare.com>
- *                      <onload-dev@solarflare.com>
- *
- * Certain parts of the driver were implemented by
- *          Alexandra Kossovsky <Alexandra.Kossovsky@oktetlabs.ru>
- *          OKTET Labs Ltd, Russia,
- *          http://oktetlabs.ru, <info@oktetlabs.ru>
- *          by request of Solarflare Communications
- *
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 as published
- * by the Free Software Foundation, incorporated herein by reference.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
- ****************************************************************************
- */
-
-#include <ci/efrm/private.h>
-#include <ci/efrm/buffer_table.h>
-
-int
-efrm_resources_init(const struct vi_resource_dimensions *vi_res_dim,
-		    int buffer_table_min, int buffer_table_lim)
-{
-	int i, rc;
-
-	rc = efrm_buffer_table_ctor(buffer_table_min, buffer_table_lim);
-	if (rc != 0)
-		return rc;
-
-	/* Create resources in the correct order */
-	for (i = 0; i < EFRM_RESOURCE_NUM; ++i) {
-		struct efrm_resource_manager **rmp = &efrm_rm_table[i];
-
-		EFRM_ASSERT(*rmp == NULL);
-		switch (i) {
-		case EFRM_RESOURCE_VI:
-			rc = efrm_create_vi_resource_manager(rmp,
-							     vi_res_dim);
-			break;
-		case EFRM_RESOURCE_FILTER:
-			rc = efrm_create_filter_resource_manager(rmp);
-			break;
-		case EFRM_RESOURCE_IOBUFSET:
-			rc = efrm_create_iobufset_resource_manager(rmp);
-			break;
-		default:
-			rc = 0;
-			break;
-		}
-
-		if (rc < 0) {
-			EFRM_ERR("%s: failed type=%d (%d)",
-				 __func__, i, rc);
-			efrm_buffer_table_dtor();
-			return rc;
-		}
-	}
-
-	return 0;
-}
-
-void efrm_resources_fini(void)
-{
-	int i;
-
-	for (i = EFRM_RESOURCE_NUM - 1; i >= 0; --i)
-		if (efrm_rm_table[i]) {
-			efrm_resource_manager_dtor(efrm_rm_table[i]);
-			efrm_rm_table[i] = NULL;
-		}
-
-	efrm_buffer_table_dtor();
-}
diff -r 5b3d4d3c1166 drivers/net/sfc/sfc_resource/vi_resource_alloc.c
--- a/drivers/net/sfc/sfc_resource/vi_resource_alloc.c	Fri Nov 05 15:20:28 2010 +0000
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,820 +0,0 @@
-/****************************************************************************
- * Driver for Solarflare network controllers -
- *          resource management for Xen backend, OpenOnload, etc
- *           (including support for SFE4001 10GBT NIC)
- *
- * This file contains allocation of VI resources.
- *
- * Copyright 2005-2007: Solarflare Communications Inc,
- *                      9501 Jeronimo Road, Suite 250,
- *                      Irvine, CA 92618, USA
- *
- * Developed and maintained by Solarflare Communications:
- *                      <linux-xen-drivers@solarflare.com>
- *                      <onload-dev@solarflare.com>
- *
- * Certain parts of the driver were implemented by
- *          Alexandra Kossovsky <Alexandra.Kossovsky@oktetlabs.ru>
- *          OKTET Labs Ltd, Russia,
- *          http://oktetlabs.ru, <info@oktetlabs.ru>
- *          by request of Solarflare Communications
- *
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 as published
- * by the Free Software Foundation, incorporated herein by reference.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
- ****************************************************************************
- */
-
-#include <ci/efrm/nic_table.h>
-#include <ci/efhw/iopage.h>
-#include <ci/driver/efab/hardware.h>
-#include <ci/efhw/public.h>
-#include <ci/efhw/falcon.h>
-#include <ci/efrm/private.h>
-#include <ci/efrm/buffer_table.h>
-#include <ci/efrm/vi_resource_private.h>
-#include <ci/efrm/efrm_client.h>
-#include "efrm_internal.h"
-
-
-/*** Data definitions ****************************************************/
-
-static const char *dmaq_names[] = { "TX", "RX" };
-
-struct vi_resource_manager *efrm_vi_manager;
-
-/*** Forward references **************************************************/
-
-static int
-efrm_vi_resource_alloc_or_free(struct efrm_client *client,
-			       int alloc, struct vi_resource *evq_virs,
-			       uint16_t vi_flags, int32_t evq_capacity,
-			       int32_t txq_capacity, int32_t rxq_capacity,
-			       uint8_t tx_q_tag, uint8_t rx_q_tag,
-			       struct vi_resource **virs_in_out);
-
-/*** Reference count handling ********************************************/
-
-static inline void efrm_vi_rm_get_ref(struct vi_resource *virs)
-{
-	atomic_inc(&virs->evq_refs);
-}
-
-static inline void efrm_vi_rm_drop_ref(struct vi_resource *virs)
-{
-	EFRM_ASSERT(atomic_read(&virs->evq_refs) != 0);
-	if (atomic_dec_and_test(&virs->evq_refs))
-		efrm_vi_resource_alloc_or_free(virs->rs.rs_client, false, NULL,
-					       0, 0, 0, 0, 0, 0, &virs);
-}
-
-/*** Instance numbers ****************************************************/
-
-static inline int efrm_vi_rm_alloc_id(uint16_t vi_flags, int32_t evq_capacity)
-{
-	irq_flags_t lock_flags;
-	int instance;
-	int rc;
-
-	if (efrm_nic_tablep->a_nic == NULL)	/* ?? FIXME: surely not right */
-		return -ENODEV;
-
-	spin_lock_irqsave(&efrm_vi_manager->rm.rm_lock, lock_flags);
-
-	/* Falcon A1 RX phys addr wierdness. */
-	if (efrm_nic_tablep->a_nic->devtype.variant == 'A' &&
-	    (vi_flags & EFHW_VI_RX_PHYS_ADDR_EN)) {
-		if (vi_flags & EFHW_VI_JUMBO_EN) {
-			/* Falcon-A cannot do phys + scatter. */
-			EFRM_WARN
-			    ("%s: falcon-A does not support phys+scatter mode",
-			     __func__);
-			instance = -1;
-		} else if (efrm_vi_manager->iscsi_dmaq_instance_is_free
-			   && evq_capacity == 0) {
-			/* Falcon-A has a single RXQ that gives the correct
-			 * semantics for physical addressing.  However, it
-			 * happens to have the same instance number as the
-			 * 'char' event queue, so we cannot also hand out
-			 * the event queue. */
-			efrm_vi_manager->iscsi_dmaq_instance_is_free = false;
-			instance = FALCON_A1_ISCSI_DMAQ;
-		} else {
-			EFRM_WARN("%s: iSCSI receive queue not free",
-				  __func__);
-			instance = -1;
-		}
-		goto unlock_out;
-	}
-
-	if (vi_flags & EFHW_VI_RM_WITH_INTERRUPT) {
-		rc = __kfifo_get(efrm_vi_manager->instances_with_interrupt,
-				 (unsigned char *)&instance, sizeof(instance));
-		if (rc != sizeof(instance)) {
-			EFRM_ASSERT(rc == 0);
-			instance = -1;
-		}
-		goto unlock_out;
-	}
-
-	/* Otherwise a normal run-of-the-mill VI. */
-	rc = __kfifo_get(efrm_vi_manager->instances_with_timer,
-			 (unsigned char *)&instance, sizeof(instance));
-	if (rc != sizeof(instance)) {
-		EFRM_ASSERT(rc == 0);
-		instance = -1;
-	}
-
-unlock_out:
-	spin_unlock_irqrestore(&efrm_vi_manager->rm.rm_lock, lock_flags);
-	return instance;
-}
-
-static void efrm_vi_rm_free_id(int instance)
-{
-	irq_flags_t lock_flags;
-	struct kfifo *instances;
-
-	if (efrm_nic_tablep->a_nic == NULL)	/* ?? FIXME: surely not right */
-		return;
-
-	if (efrm_nic_tablep->a_nic->devtype.variant == 'A' &&
-	    instance == FALCON_A1_ISCSI_DMAQ) {
-		EFRM_ASSERT(efrm_vi_manager->iscsi_dmaq_instance_is_free ==
-			    false);
-		spin_lock_irqsave(&efrm_vi_manager->rm.rm_lock, lock_flags);
-		efrm_vi_manager->iscsi_dmaq_instance_is_free = true;
-		spin_unlock_irqrestore(&efrm_vi_manager->rm.rm_lock,
-				       lock_flags);
-	} else {
-		if (instance >= efrm_vi_manager->with_timer_base &&
-		    instance < efrm_vi_manager->with_timer_limit) {
-			instances = efrm_vi_manager->instances_with_timer;
-		} else {
-			EFRM_ASSERT(instance >=
-				    efrm_vi_manager->with_interrupt_base);
-			EFRM_ASSERT(instance <
-				    efrm_vi_manager->with_interrupt_limit);
-			instances = efrm_vi_manager->instances_with_interrupt;
-		}
-
-		EFRM_VERIFY_EQ(kfifo_put(instances, (unsigned char *)&instance,
-					 sizeof(instance)), sizeof(instance));
-	}
-}
-
-/*** Queue sizes *********************************************************/
-
-/* NB. This should really take a nic as an argument, but that makes
- * the buffer table allocation difficult. */
-uint32_t efrm_vi_rm_evq_bytes(struct vi_resource *virs
-			      /*,struct efhw_nic *nic */)
-{
-	return virs->evq_capacity * sizeof(efhw_event_t);
-}
-EXPORT_SYMBOL(efrm_vi_rm_evq_bytes);
-
-/* NB. This should really take a nic as an argument, but that makes
- * the buffer table allocation difficult. */
-uint32_t efrm_vi_rm_txq_bytes(struct vi_resource *virs
-			      /*,struct efhw_nic *nic */)
-{
-	return virs->dmaq_capacity[EFRM_VI_RM_DMA_QUEUE_TX] *
-	    FALCON_DMA_TX_DESC_BYTES;
-}
-EXPORT_SYMBOL(efrm_vi_rm_txq_bytes);
-
-/* NB. This should really take a nic as an argument, but that makes
- * the buffer table allocation difficult. */
-uint32_t efrm_vi_rm_rxq_bytes(struct vi_resource *virs
-			      /*,struct efhw_nic *nic */)
-{
-	uint32_t bytes_per_desc = ((virs->flags & EFHW_VI_RX_PHYS_ADDR_EN)
-				   ? FALCON_DMA_RX_PHYS_DESC_BYTES
-				   : FALCON_DMA_RX_BUF_DESC_BYTES);
-	return virs->dmaq_capacity[EFRM_VI_RM_DMA_QUEUE_RX] * bytes_per_desc;
-}
-EXPORT_SYMBOL(efrm_vi_rm_rxq_bytes);
-
-static int choose_size(int size_rq, unsigned sizes)
-{
-	int size;
-
-	/* size_rq < 0 means default, but we interpret this as 'minimum'. */
-
-	for (size = 256;; size <<= 1)
-		if ((size & sizes) && size >= size_rq)
-			return size;
-		else if ((sizes & ~((size - 1) | size)) == 0)
-			return -1;
-}
-
-static int
-efrm_vi_rm_adjust_alloc_request(struct vi_resource *virs, struct efhw_nic *nic)
-{
-	int capacity;
-
-	EFRM_ASSERT(nic->efhw_func);
-
-	if (virs->evq_capacity) {
-		capacity = choose_size(virs->evq_capacity, nic->evq_sizes);
-		if (capacity < 0) {
-			EFRM_ERR("vi_resource: bad evq size %d (supported=%x)",
-				 virs->evq_capacity, nic->evq_sizes);
-			return -E2BIG;
-		}
-		virs->evq_capacity = capacity;
-	}
-	if (virs->dmaq_capacity[EFRM_VI_RM_DMA_QUEUE_TX]) {
-		capacity =
-		    choose_size(virs->dmaq_capacity[EFRM_VI_RM_DMA_QUEUE_TX],
-				nic->txq_sizes);
-		if (capacity < 0) {
-			EFRM_ERR("vi_resource: bad txq size %d (supported=%x)",
-				 virs->dmaq_capacity[EFRM_VI_RM_DMA_QUEUE_TX],
-				 nic->txq_sizes);
-			return -E2BIG;
-		}
-		virs->dmaq_capacity[EFRM_VI_RM_DMA_QUEUE_TX] = capacity;
-	}
-	if (virs->dmaq_capacity[EFRM_VI_RM_DMA_QUEUE_RX]) {
-		capacity =
-		    choose_size(virs->dmaq_capacity[EFRM_VI_RM_DMA_QUEUE_RX],
-				nic->rxq_sizes);
-		if (capacity < 0) {
-			EFRM_ERR("vi_resource: bad rxq size %d (supported=%x)",
-				 virs->dmaq_capacity[EFRM_VI_RM_DMA_QUEUE_RX],
-				 nic->rxq_sizes);
-			return -E2BIG;
-		}
-		virs->dmaq_capacity[EFRM_VI_RM_DMA_QUEUE_RX] = capacity;
-	}
-
-	return 0;
-}
-
-/* remove the reference to the event queue in this VI resource and decrement
-   the event queue's use count */
-static inline void efrm_vi_rm_detach_evq(struct vi_resource *virs)
-{
-	struct vi_resource *evq_virs;
-
-	EFRM_ASSERT(virs != NULL);
-
-	evq_virs = virs->evq_virs;
-
-	if (evq_virs != NULL) {
-		virs->evq_virs = NULL;
-		if (evq_virs == virs) {
-			EFRM_TRACE("%s: " EFRM_RESOURCE_FMT
-				   " had internal event queue ", __func__,
-				   EFRM_RESOURCE_PRI_ARG(virs->rs.rs_handle));
-		} else {
-			efrm_vi_rm_drop_ref(evq_virs);
-			EFRM_TRACE("%s: " EFRM_RESOURCE_FMT " had event queue "
-				   EFRM_RESOURCE_FMT, __func__,
-				   EFRM_RESOURCE_PRI_ARG(virs->rs.rs_handle),
-				   EFRM_RESOURCE_PRI_ARG(evq_virs->rs.
-							 rs_handle));
-		}
-	} else {
-		EFRM_TRACE("%s: " EFRM_RESOURCE_FMT
-			   " had no event queue (nothing to do)",
-			   __func__,
-			   EFRM_RESOURCE_PRI_ARG(virs->rs.rs_handle));
-	}
-}
-
-/*** Buffer Table allocations ********************************************/
-
-static int
-efrm_vi_rm_alloc_or_free_buffer_table(struct vi_resource *virs, bool is_alloc)
-{
-	uint32_t bytes;
-	int page_order;
-	int rc;
-
-	if (!is_alloc)
-		goto destroy;
-
-	if (virs->dmaq_capacity[EFRM_VI_RM_DMA_QUEUE_TX]) {
-		bytes = efrm_vi_rm_txq_bytes(virs);
-		page_order = get_order(bytes);
-		rc = efrm_buffer_table_alloc(page_order,
-					     (virs->dmaq_buf_tbl_alloc +
-					      EFRM_VI_RM_DMA_QUEUE_TX));
-		if (rc != 0) {
-			EFRM_TRACE
-			    ("%s: Error %d allocating TX buffer table entry",
-			     __func__, rc);
-			goto fail_txq_alloc;
-		}
-	}
-
-	if (virs->dmaq_capacity[EFRM_VI_RM_DMA_QUEUE_RX]) {
-		bytes = efrm_vi_rm_rxq_bytes(virs);
-		page_order = get_order(bytes);
-		rc = efrm_buffer_table_alloc(page_order,
-					     (virs->dmaq_buf_tbl_alloc +
-					      EFRM_VI_RM_DMA_QUEUE_RX));
-		if (rc != 0) {
-			EFRM_TRACE
-			    ("%s: Error %d allocating RX buffer table entry",
-			     __func__, rc);
-			goto fail_rxq_alloc;
-		}
-	}
-	return 0;
-
-destroy:
-	rc = 0;
-
-	if (virs->dmaq_capacity[EFRM_VI_RM_DMA_QUEUE_RX]) {
-		efrm_buffer_table_free(&virs->
-				       dmaq_buf_tbl_alloc
-				       [EFRM_VI_RM_DMA_QUEUE_RX]);
-	}
-fail_rxq_alloc:
-
-	if (virs->dmaq_capacity[EFRM_VI_RM_DMA_QUEUE_TX]) {
-		efrm_buffer_table_free(&virs->
-				       dmaq_buf_tbl_alloc
-				       [EFRM_VI_RM_DMA_QUEUE_TX]);
-	}
-fail_txq_alloc:
-
-	return rc;
-}
-
-/*** Per-NIC allocations *************************************************/
-
-static inline int
-efrm_vi_rm_init_evq(struct vi_resource *virs, struct efhw_nic *nic)
-{
-	int instance = EFRM_RESOURCE_INSTANCE(virs->rs.rs_handle);
-	struct eventq_resource_hardware *evq_hw =
-	    &virs->nic_info.evq_pages;
-	uint32_t buf_bytes = efrm_vi_rm_evq_bytes(virs);
-	int rc;
-
-	if (virs->evq_capacity == 0)
-		return 0;
-	evq_hw->capacity = virs->evq_capacity;
-
-	/* Allocate buffer table entries to map onto the iobuffer.  This
-	 * currently allocates its own buffer table entries on Falcon which is
-	 * a bit wasteful on a multi-NIC system. */
-	evq_hw->buf_tbl_alloc.base = (unsigned)-1;
-	rc = efrm_buffer_table_alloc(get_order(buf_bytes),
-				     &evq_hw->buf_tbl_alloc);
-	if (rc < 0) {
-		EFHW_WARN("%s: failed (%d) to alloc %d buffer table entries",
-			  __func__, rc, get_order(buf_bytes));
-		return rc;
-	}
-
-	/* Allocate the event queue memory. */
-	rc = efhw_nic_event_queue_alloc_iobuffer(nic, evq_hw, instance,
-						 buf_bytes);
-	if (rc != 0) {
-		EFRM_ERR("%s: Error allocating iobuffer: %d", __func__, rc);
-		efrm_buffer_table_free(&evq_hw->buf_tbl_alloc);
-		return rc;
-	}
-
-	/* Initialise the event queue hardware */
-	efhw_nic_event_queue_enable(nic, instance, virs->evq_capacity,
-				    efhw_iopages_dma_addr(&evq_hw->iobuff) +
-				    evq_hw->iobuff_off,
-				    evq_hw->buf_tbl_alloc.base,
-				    instance < 64);
-
-	EFRM_TRACE("%s: " EFRM_RESOURCE_FMT " capacity=%u", __func__,
-		   EFRM_RESOURCE_PRI_ARG(virs->rs.rs_handle),
-		   virs->evq_capacity);
-
-#if defined(__ia64__)
-	/* Page size may be large, so for now just increase the
-	 * size of the requested evq up to a round number of
-	 * pages
-	 */
-	buf_bytes = CI_ROUNDUP(buf_bytes, PAGE_SIZE);
-#endif
-	EFRM_ASSERT(buf_bytes % PAGE_SIZE == 0);
-
-	virs->mem_mmap_bytes += buf_bytes;
-
-	return 0;
-}
-
-static inline void
-efrm_vi_rm_fini_evq(struct vi_resource *virs, struct efhw_nic *nic)
-{
-	int instance = EFRM_RESOURCE_INSTANCE(virs->rs.rs_handle);
-	struct vi_resource_nic_info *nic_info = &virs->nic_info;
-
-	if (virs->evq_capacity == 0)
-		return;
-
-	/* Zero the timer-value for this queue.
-	   And Tell NIC to stop using this event queue. */
-	efhw_nic_event_queue_disable(nic, instance, 0);
-
-	if (nic_info->evq_pages.buf_tbl_alloc.base != (unsigned)-1)
-		efrm_buffer_table_free(&nic_info->evq_pages.buf_tbl_alloc);
-
-	efhw_iopages_free(nic, &nic_info->evq_pages.iobuff);
-}
-
-/*! FIXME: we should make sure this number is never zero (=> unprotected) */
-/*! FIXME: put this definition in a relevant header (e.g. as (evqid)+1) */
-#define EFAB_EVQ_OWNER_ID(evqid) ((evqid))
-
-void
-efrm_vi_rm_init_dmaq(struct vi_resource *virs, int queue_type,
-		     struct efhw_nic *nic)
-{
-	int instance;
-	int evq_instance;
-	efhw_buffer_addr_t buf_addr;
-
-	instance = EFRM_RESOURCE_INSTANCE(virs->rs.rs_handle);
-	evq_instance = EFRM_RESOURCE_INSTANCE(virs->evq_virs->rs.rs_handle);
-
-	buf_addr = virs->dmaq_buf_tbl_alloc[queue_type].base;
-
-	if (queue_type == EFRM_VI_RM_DMA_QUEUE_TX) {
-		efhw_nic_dmaq_tx_q_init(nic,
-			instance,	/* dmaq */
-			evq_instance,	/* evq */
-			EFAB_EVQ_OWNER_ID(evq_instance),	/* owner */
-			virs->dmaq_tag[queue_type],	/* tag */
-			virs->dmaq_capacity[queue_type], /* size of queue */
-			buf_addr,	/* buffer index */
-			virs->flags);	/* user specified Q attrs */
-	} else {
-		efhw_nic_dmaq_rx_q_init(nic,
-			instance,	/* dmaq */
-			evq_instance,	/* evq */
-			EFAB_EVQ_OWNER_ID(evq_instance),	/* owner */
-			virs->dmaq_tag[queue_type],	/* tag */
-			virs->dmaq_capacity[queue_type], /* size of queue */
-			buf_addr,	/* buffer index */
-			virs->flags);	/* user specified Q attrs */
-	}
-}
-
-static int
-efrm_vi_rm_init_or_fini_dmaq(struct vi_resource *virs,
-			     int queue_type, int init,
-			     struct efhw_nic *nic)
-{
-	int rc;
-	int instance = EFRM_RESOURCE_INSTANCE(virs->rs.rs_handle);
-	uint32_t buf_bytes;
-	struct vi_resource_nic_info *nic_info = &virs->nic_info;
-	int page_order;
-	uint32_t num_pages;
-	struct efhw_iopages *iobuff;
-
-	if (!init)
-		goto destroy;
-
-	/* Ignore disabled queues. */
-	if (virs->dmaq_capacity[queue_type] == 0) {
-		if (queue_type == EFRM_VI_RM_DMA_QUEUE_TX)
-			efhw_nic_dmaq_tx_q_disable(nic, instance);
-		else
-			efhw_nic_dmaq_rx_q_disable(nic, instance);
-		return 0;
-	}
-
-	buf_bytes = (queue_type == EFRM_VI_RM_DMA_QUEUE_TX
-		     ? efrm_vi_rm_txq_bytes(virs)
-		     : efrm_vi_rm_rxq_bytes(virs));
-
-	page_order = get_order(buf_bytes);
-
-	rc = efhw_iopages_alloc(nic, &nic_info->dmaq_pages[queue_type],
-			      page_order);
-	if (rc != 0) {
-		EFRM_ERR("%s: Failed to allocate %s DMA buffer.", __func__,
-			 dmaq_names[queue_type]);
-		goto fail_iopages;
-	}
-
-	num_pages = 1 << page_order;
-	iobuff = &nic_info->dmaq_pages[queue_type];
-	efhw_nic_buffer_table_set_n(nic,
-				    virs->dmaq_buf_tbl_alloc[queue_type].base,
-				    efhw_iopages_dma_addr(iobuff),
-				    EFHW_NIC_PAGE_SIZE, 0, num_pages, 0);
-
-	falcon_nic_buffer_table_confirm(nic);
-
-	virs->mem_mmap_bytes += roundup(buf_bytes, PAGE_SIZE);
-
-	/* Make sure there is an event queue. */
-	if (virs->evq_virs->evq_capacity <= 0) {
-		EFRM_ERR("%s: Cannot use empty event queue for %s DMA",
-			 __func__, dmaq_names[queue_type]);
-		rc = -EINVAL;
-		goto fail_evq;
-	}
-
-	efrm_vi_rm_init_dmaq(virs, queue_type, nic);
-
-	return 0;
-
-destroy:
-	rc = 0;
-
-	/* Ignore disabled queues. */
-	if (virs->dmaq_capacity[queue_type] == 0)
-		return 0;
-
-	/* Ensure TX pacing turned off -- queue flush doesn't reset this. */
-	if (queue_type == EFRM_VI_RM_DMA_QUEUE_TX)
-		falcon_nic_pace(nic, instance, 0);
-
-	/* No need to disable the queue here.  Nobody is using it anyway. */
-
-fail_evq:
-	efhw_iopages_free(nic, &nic_info->dmaq_pages[queue_type]);
-fail_iopages:
-
-	return rc;
-}
-
-static int
-efrm_vi_rm_init_or_fini_nic(struct vi_resource *virs, int init,
-			    struct efhw_nic *nic)
-{
-	int rc;
-#ifndef NDEBUG
-	int instance = EFRM_RESOURCE_INSTANCE(virs->rs.rs_handle);
-#endif
-
-	if (!init)
-		goto destroy;
-
-	rc = efrm_vi_rm_init_evq(virs, nic);
-	if (rc != 0)
-		goto fail_evq;
-
-	rc = efrm_vi_rm_init_or_fini_dmaq(virs, EFRM_VI_RM_DMA_QUEUE_TX,
-					  init, nic);
-	if (rc != 0)
-		goto fail_txq;
-
-	rc = efrm_vi_rm_init_or_fini_dmaq(virs, EFRM_VI_RM_DMA_QUEUE_RX,
-					  init, nic);
-	if (rc != 0)
-		goto fail_rxq;
-
-	/* Allocate space for the control page. */
-	EFRM_ASSERT(falcon_tx_dma_page_offset(instance) < PAGE_SIZE);
-	EFRM_ASSERT(falcon_rx_dma_page_offset(instance) < PAGE_SIZE);
-	EFRM_ASSERT(falcon_timer_page_offset(instance) < PAGE_SIZE);
-	virs->bar_mmap_bytes += PAGE_SIZE;
-
-	return 0;
-
-destroy:
-	rc = 0;
-
-	efrm_vi_rm_init_or_fini_dmaq(virs, EFRM_VI_RM_DMA_QUEUE_RX,
-				     false, nic);
-fail_rxq:
-
-	efrm_vi_rm_init_or_fini_dmaq(virs, EFRM_VI_RM_DMA_QUEUE_TX,
-				     false, nic);
-fail_txq:
-
-	efrm_vi_rm_fini_evq(virs, nic);
-fail_evq:
-
-	EFRM_ASSERT(rc != 0 || !init);
-	return rc;
-}
-
-static int
-efrm_vi_resource_alloc_or_free(struct efrm_client *client,
-			       int alloc, struct vi_resource *evq_virs,
-			       uint16_t vi_flags, int32_t evq_capacity,
-			       int32_t txq_capacity, int32_t rxq_capacity,
-			       uint8_t tx_q_tag, uint8_t rx_q_tag,
-			       struct vi_resource **virs_in_out)
-{
-	struct efhw_nic *nic = client->nic;
-	struct vi_resource *virs;
-	int rc;
-	int instance;
-
-	EFRM_ASSERT(virs_in_out);
-	EFRM_ASSERT(efrm_vi_manager);
-	EFRM_RESOURCE_MANAGER_ASSERT_VALID(&efrm_vi_manager->rm);
-
-	if (!alloc)
-		goto destroy;
-
-	rx_q_tag &= (1 << TX_DESCQ_LABEL_WIDTH) - 1;
-	tx_q_tag &= (1 << RX_DESCQ_LABEL_WIDTH) - 1;
-
-	virs = kmalloc(sizeof(*virs), GFP_KERNEL);
-	if (virs == NULL) {
-		EFRM_ERR("%s: Error allocating VI resource object",
-			 __func__);
-		rc = -ENOMEM;
-		goto fail_alloc;
-	}
-	memset(virs, 0, sizeof(*virs));
-
-	/* Some macros make the assumption that the struct efrm_resource is
-	 * the first member of a struct vi_resource. */
-	EFRM_ASSERT(&virs->rs == (struct efrm_resource *) (virs));
-
-	instance = efrm_vi_rm_alloc_id(vi_flags, evq_capacity);
-	if (instance < 0) {
-		/* Clear out the close list... */
-		efrm_vi_rm_salvage_flushed_vis();
-		instance = efrm_vi_rm_alloc_id(vi_flags, evq_capacity);
-		if (instance >= 0)
-			EFRM_TRACE("%s: Salvaged a closed VI.", __func__);
-	}
-
-	if (instance < 0) {
-		/* Could flush resources and try again here. */
-		EFRM_ERR("%s: Out of appropriate VI resources", __func__);
-		rc = -EBUSY;
-		goto fail_alloc_id;
-	}
-
-	EFRM_TRACE("%s: new VI ID %d", __func__, instance);
-	efrm_resource_init(&virs->rs, EFRM_RESOURCE_VI, instance);
-
-	/* Start with one reference.  Any external VIs using the EVQ of this
-	 * resource will increment this reference rather than the resource
-	 * reference to avoid DMAQ flushes from waiting for other DMAQ
-	 * flushes to complete.  When the resource reference goes to zero,
-	 * the DMAQ flush happens.  When the flush completes, this reference
-	 * is decremented.  When this reference reaches zero, the instance
-	 * is freed. */
-	atomic_set(&virs->evq_refs, 1);
-
-	virs->bar_mmap_bytes = 0;
-	virs->mem_mmap_bytes = 0;
-	virs->evq_capacity = evq_capacity;
-	virs->dmaq_capacity[EFRM_VI_RM_DMA_QUEUE_TX] = txq_capacity;
-	virs->dmaq_capacity[EFRM_VI_RM_DMA_QUEUE_RX] = rxq_capacity;
-	virs->dmaq_tag[EFRM_VI_RM_DMA_QUEUE_TX] = tx_q_tag;
-	virs->dmaq_tag[EFRM_VI_RM_DMA_QUEUE_RX] = rx_q_tag;
-	virs->flags = vi_flags;
-	INIT_LIST_HEAD(&virs->tx_flush_link);
-	INIT_LIST_HEAD(&virs->rx_flush_link);
-	virs->tx_flushing = 0;
-	virs->rx_flushing = 0;
-
-	/* Adjust the queue sizes. */
-	rc = efrm_vi_rm_adjust_alloc_request(virs, nic);
-	if (rc != 0)
-		goto fail_adjust_request;
-
-	/* Attach the EVQ early so that we can ensure that the NIC sets
-	 * match. */
-	if (evq_virs == NULL) {
-		evq_virs = virs;
-		EFRM_TRACE("%s: " EFRM_RESOURCE_FMT
-			   " has no external event queue", __func__,
-			   EFRM_RESOURCE_PRI_ARG(virs->rs.rs_handle));
-	} else {
-		/* Make sure the resource managers are the same. */
-		if (EFRM_RESOURCE_TYPE(evq_virs->rs.rs_handle) !=
-		    EFRM_RESOURCE_VI) {
-			EFRM_ERR("%s: Mismatched owner for event queue VI "
-				 EFRM_RESOURCE_FMT, __func__,
-				 EFRM_RESOURCE_PRI_ARG(evq_virs->rs.rs_handle));
-			return -EINVAL;
-		}
-		EFRM_ASSERT(atomic_read(&evq_virs->evq_refs) != 0);
-		efrm_vi_rm_get_ref(evq_virs);
-		EFRM_TRACE("%s: " EFRM_RESOURCE_FMT " uses event queue "
-			   EFRM_RESOURCE_FMT,
-			   __func__,
-			   EFRM_RESOURCE_PRI_ARG(virs->rs.rs_handle),
-			   EFRM_RESOURCE_PRI_ARG(evq_virs->rs.rs_handle));
-	}
-	virs->evq_virs = evq_virs;
-
-	rc = efrm_vi_rm_alloc_or_free_buffer_table(virs, true);
-	if (rc != 0)
-		goto fail_buffer_table;
-
-	rc = efrm_vi_rm_init_or_fini_nic(virs, true, nic);
-	if (rc != 0)
-		goto fail_init_nic;
-
-	efrm_client_add_resource(client, &virs->rs);
-	*virs_in_out = virs;
-	EFRM_TRACE("%s: Allocated " EFRM_RESOURCE_FMT, __func__,
-		   EFRM_RESOURCE_PRI_ARG(virs->rs.rs_handle));
-	return 0;
-
-destroy:
-	virs = *virs_in_out;
-	EFRM_RESOURCE_ASSERT_VALID(&virs->rs, 1);
-	instance = EFRM_RESOURCE_INSTANCE(virs->rs.rs_handle);
-
-	EFRM_TRACE("%s: Freeing %d", __func__,
-		   EFRM_RESOURCE_INSTANCE(virs->rs.rs_handle));
-
-	/* Destroying the VI.  The reference count must be zero. */
-	EFRM_ASSERT(atomic_read(&virs->evq_refs) == 0);
-
-	/* The EVQ should have gone (and DMA disabled) so that this
-	 * function can't be re-entered to destroy the EVQ VI. */
-	EFRM_ASSERT(virs->evq_virs == NULL);
-	rc = 0;
-
-fail_init_nic:
-	efrm_vi_rm_init_or_fini_nic(virs, false, nic);
-
-	efrm_vi_rm_alloc_or_free_buffer_table(virs, false);
-fail_buffer_table:
-
-	efrm_vi_rm_detach_evq(virs);
-
-fail_adjust_request:
-
-	EFRM_ASSERT(virs->evq_callback_fn == NULL);
-	EFRM_TRACE("%s: delete VI ID %d", __func__, instance);
-	efrm_vi_rm_free_id(instance);
-fail_alloc_id:
-	if (!alloc)
-		efrm_client_put(virs->rs.rs_client);
-	EFRM_DO_DEBUG(memset(virs, 0, sizeof(*virs)));
-	kfree(virs);
-fail_alloc:
-	*virs_in_out = NULL;
-
-	return rc;
-}
-
-/*** Resource object  ****************************************************/
-
-int
-efrm_vi_resource_alloc(struct efrm_client *client,
-		       struct vi_resource *evq_virs,
-		       uint16_t vi_flags, int32_t evq_capacity,
-		       int32_t txq_capacity, int32_t rxq_capacity,
-		       uint8_t tx_q_tag, uint8_t rx_q_tag,
-		       struct vi_resource **virs_out,
-		       uint32_t *out_io_mmap_bytes,
-		       uint32_t *out_mem_mmap_bytes,
-		       uint32_t *out_txq_capacity, uint32_t *out_rxq_capacity)
-{
-	int rc;
-	EFRM_ASSERT(client != NULL);
-	rc = efrm_vi_resource_alloc_or_free(client, true, evq_virs, vi_flags,
-					    evq_capacity, txq_capacity,
-					    rxq_capacity, tx_q_tag, rx_q_tag,
-					    virs_out);
-	if (rc == 0) {
-		if (out_io_mmap_bytes != NULL)
-			*out_io_mmap_bytes = (*virs_out)->bar_mmap_bytes;
-		if (out_mem_mmap_bytes != NULL)
-			*out_mem_mmap_bytes = (*virs_out)->mem_mmap_bytes;
-		if (out_txq_capacity != NULL)
-			*out_txq_capacity =
-			    (*virs_out)->dmaq_capacity[EFRM_VI_RM_DMA_QUEUE_TX];
-		if (out_rxq_capacity != NULL)
-			*out_rxq_capacity =
-			    (*virs_out)->dmaq_capacity[EFRM_VI_RM_DMA_QUEUE_RX];
-	}
-
-	return rc;
-}
-EXPORT_SYMBOL(efrm_vi_resource_alloc);
-
-void efrm_vi_rm_free_flushed_resource(struct vi_resource *virs)
-{
-	EFRM_ASSERT(virs != NULL);
-	EFRM_ASSERT(virs->rs.rs_ref_count == 0);
-
-	EFRM_TRACE("%s: " EFRM_RESOURCE_FMT, __func__,
-		   EFRM_RESOURCE_PRI_ARG(virs->rs.rs_handle));
-	/* release the associated event queue then drop our own reference
-	 * count */
-	efrm_vi_rm_detach_evq(virs);
-	efrm_vi_rm_drop_ref(virs);
-}
diff -r 5b3d4d3c1166 drivers/net/sfc/sfc_resource/vi_resource_event.c
--- a/drivers/net/sfc/sfc_resource/vi_resource_event.c	Fri Nov 05 15:20:28 2010 +0000
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,250 +0,0 @@
-/****************************************************************************
- * Driver for Solarflare network controllers -
- *          resource management for Xen backend, OpenOnload, etc
- *           (including support for SFE4001 10GBT NIC)
- *
- * This file contains event handling for VI resource.
- *
- * Copyright 2005-2007: Solarflare Communications Inc,
- *                      9501 Jeronimo Road, Suite 250,
- *                      Irvine, CA 92618, USA
- *
- * Developed and maintained by Solarflare Communications:
- *                      <linux-xen-drivers@solarflare.com>
- *                      <onload-dev@solarflare.com>
- *
- * Certain parts of the driver were implemented by
- *          Alexandra Kossovsky <Alexandra.Kossovsky@oktetlabs.ru>
- *          OKTET Labs Ltd, Russia,
- *          http://oktetlabs.ru, <info@oktetlabs.ru>
- *          by request of Solarflare Communications
- *
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 as published
- * by the Free Software Foundation, incorporated herein by reference.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
- ****************************************************************************
- */
-
-#include <ci/efrm/nic_table.h>
-#include <ci/driver/efab/hardware.h>
-#include <ci/efhw/eventq.h>
-#include <ci/efrm/private.h>
-#include <ci/efrm/vi_resource_private.h>
-#include <ci/efrm/efrm_nic.h>
-#include "efrm_internal.h"
-
-
-static inline int
-efrm_eventq_bytes(struct vi_resource *virs)
-{
-	return efrm_vi_rm_evq_bytes(virs);
-}
-
-
-static inline efhw_event_t *
-efrm_eventq_base(struct vi_resource *virs)
-{
-	struct eventq_resource_hardware *hw;
-	hw = &(virs->nic_info.evq_pages);
-	return (efhw_event_t *) (efhw_iopages_ptr(&(hw->iobuff)) +
-				 hw->iobuff_off);
-}
-
-
-void
-efrm_eventq_request_wakeup(struct vi_resource *virs, unsigned current_ptr)
-{
-	struct efhw_nic *nic = virs->rs.rs_client->nic;
-	int next_i;
-	next_i = ((current_ptr / sizeof(efhw_event_t)) &
-		  (virs->evq_capacity - 1));
-
-	efhw_nic_wakeup_request(nic, efrm_eventq_dma_addr(virs), next_i,
-				EFRM_RESOURCE_INSTANCE(virs->rs.rs_handle));
-}
-EXPORT_SYMBOL(efrm_eventq_request_wakeup);
-
-void efrm_eventq_reset(struct vi_resource *virs)
-{
-	struct efhw_nic *nic = virs->rs.rs_client->nic;
-	int instance = EFRM_RESOURCE_INSTANCE(virs->rs.rs_handle);
-
-	EFRM_ASSERT(virs->evq_capacity != 0);
-
-	/* FIXME: Protect against concurrent resets. */
-
-	efhw_nic_event_queue_disable(nic, instance, 0);
-
-	memset(efrm_eventq_base(virs), EFHW_CLEAR_EVENT_VALUE,
-	       efrm_eventq_bytes(virs));
-	efhw_nic_event_queue_enable(nic, instance, virs->evq_capacity,
-				    efrm_eventq_dma_addr(virs),
-				    virs->nic_info.evq_pages.
-				      buf_tbl_alloc.base,
-				    instance < 64);
-	EFRM_TRACE("%s: " EFRM_RESOURCE_FMT, __func__,
-		   EFRM_RESOURCE_PRI_ARG(virs->rs.rs_handle));
-}
-EXPORT_SYMBOL(efrm_eventq_reset);
-
-int
-efrm_eventq_register_callback(struct vi_resource *virs,
-			      void (*handler) (void *, int,
-					       struct efhw_nic *nic),
-			      void *arg)
-{
-	struct efrm_nic_per_vi *cb_info;
-	int instance;
-	int bit;
-
-	EFRM_RESOURCE_ASSERT_VALID(&virs->rs, 0);
-	EFRM_ASSERT(virs->evq_capacity != 0);
-	EFRM_ASSERT(handler != NULL);
-
-	/* ?? TODO: Get rid of this test when client is compulsory. */
-	if (virs->rs.rs_client == NULL) {
-		EFRM_ERR("%s: no client", __func__);
-		return -EINVAL;
-	}
-
-	virs->evq_callback_arg = arg;
-	virs->evq_callback_fn = handler;
-	instance = EFRM_RESOURCE_INSTANCE(virs->rs.rs_handle);
-	cb_info = &efrm_nic(virs->rs.rs_client->nic)->vis[instance];
-
-	/* The handler can be set only once. */
-	bit = test_and_set_bit(VI_RESOURCE_EVQ_STATE_CALLBACK_REGISTERED,
-			       &cb_info->state);
-	if (bit)
-		return -EBUSY;
-	cb_info->vi = virs;
-
-	return 0;
-}
-EXPORT_SYMBOL(efrm_eventq_register_callback);
-
-void efrm_eventq_kill_callback(struct vi_resource *virs)
-{
-	struct efrm_nic_per_vi *cb_info;
-	int32_t evq_state;
-	int instance;
-	int bit;
-
-	EFRM_RESOURCE_ASSERT_VALID(&virs->rs, 0);
-	EFRM_ASSERT(virs->evq_capacity != 0);
-	EFRM_ASSERT(virs->rs.rs_client != NULL);
-
-	instance = EFRM_RESOURCE_INSTANCE(virs->rs.rs_handle);
-	cb_info = &efrm_nic(virs->rs.rs_client->nic)->vis[instance];
-	cb_info->vi = NULL;
-
-	/* Disable the timer. */
-	efhw_nic_event_queue_disable(virs->rs.rs_client->nic,
-				     instance, /*timer_only */ 1);
-
-	/* Disable the callback. */
-	bit = test_and_clear_bit(VI_RESOURCE_EVQ_STATE_CALLBACK_REGISTERED,
-				 &cb_info->state);
-	EFRM_ASSERT(bit);	/* do not call me twice! */
-
-	/* Spin until the callback is complete. */
-	do {
-		rmb();
-
-		udelay(1);
-		evq_state = cb_info->state;
-	} while ((evq_state & VI_RESOURCE_EVQ_STATE(BUSY)));
-
-	virs->evq_callback_fn = NULL;
-}
-EXPORT_SYMBOL(efrm_eventq_kill_callback);
-
-static void
-efrm_eventq_do_callback(struct efhw_nic *nic, unsigned instance,
-			bool is_timeout)
-{
-	struct efrm_nic *rnic = efrm_nic(nic);
-	void (*handler) (void *, int is_timeout, struct efhw_nic *nic);
-	void *arg;
-	struct efrm_nic_per_vi *cb_info;
-	int32_t evq_state;
-	int32_t new_evq_state;
-	struct vi_resource *virs;
-	int bit;
-
-	EFRM_ASSERT(efrm_vi_manager);
-
-	cb_info = &rnic->vis[instance];
-
-	/* Set the BUSY bit and clear WAKEUP_PENDING.  Do this
-	 * before waking up the sleeper to avoid races. */
-	while (1) {
-		evq_state = cb_info->state;
-		new_evq_state = evq_state;
-
-		if ((evq_state & VI_RESOURCE_EVQ_STATE(BUSY)) != 0) {
-			EFRM_ERR("%s:%d: evq_state[%d] corrupted!",
-				 __func__, __LINE__, instance);
-			return;
-		}
-
-		if (!is_timeout)
-			new_evq_state &= ~VI_RESOURCE_EVQ_STATE(WAKEUP_PENDING);
-
-		if (evq_state & VI_RESOURCE_EVQ_STATE(CALLBACK_REGISTERED)) {
-			new_evq_state |= VI_RESOURCE_EVQ_STATE(BUSY);
-			virs = cb_info->vi;
-			if (cmpxchg(&cb_info->state, evq_state,
-				    new_evq_state) == evq_state)
-				break;
-		} else {
-			/* Just update the state if necessary. */
-			if (new_evq_state == evq_state ||
-			    cmpxchg(&cb_info->state, evq_state,
-				    new_evq_state) == evq_state)
-				return;
-		}
-	}
-
-	if (virs) {
-		handler = virs->evq_callback_fn;
-		arg = virs->evq_callback_arg;
-		EFRM_ASSERT(handler != NULL);
-		handler(arg, is_timeout, nic);
-	}
-
-	/* Clear the BUSY bit. */
-	bit =
-	    test_and_clear_bit(VI_RESOURCE_EVQ_STATE_BUSY,
-			       &cb_info->state);
-	if (!bit) {
-		EFRM_ERR("%s:%d: evq_state corrupted!",
-			 __func__, __LINE__);
-	}
-}
-
-void efrm_handle_wakeup_event(struct efhw_nic *nic, unsigned instance)
-{
-	efrm_eventq_do_callback(nic, instance, false);
-}
-
-void efrm_handle_timeout_event(struct efhw_nic *nic, unsigned instance)
-{
-	efrm_eventq_do_callback(nic, instance, true);
-}
-
-void efrm_handle_sram_event(struct efhw_nic *nic)
-{
-  if (nic->buf_commit_outstanding > 0)
-    nic->buf_commit_outstanding--;
-}
diff -r 5b3d4d3c1166 drivers/net/sfc/sfc_resource/vi_resource_flush.c
--- a/drivers/net/sfc/sfc_resource/vi_resource_flush.c	Fri Nov 05 15:20:28 2010 +0000
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,483 +0,0 @@
-/****************************************************************************
- * Driver for Solarflare network controllers -
- *          resource management for Xen backend, OpenOnload, etc
- *           (including support for SFE4001 10GBT NIC)
- *
- * This file contains DMA queue flushing of VI resources.
- *
- * Copyright 2005-2007: Solarflare Communications Inc,
- *                      9501 Jeronimo Road, Suite 250,
- *                      Irvine, CA 92618, USA
- *
- * Developed and maintained by Solarflare Communications:
- *                      <linux-xen-drivers@solarflare.com>
- *                      <onload-dev@solarflare.com>
- *
- * Certain parts of the driver were implemented by
- *          Alexandra Kossovsky <Alexandra.Kossovsky@oktetlabs.ru>
- *          OKTET Labs Ltd, Russia,
- *          http://oktetlabs.ru, <info@oktetlabs.ru>
- *          by request of Solarflare Communications
- *
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 as published
- * by the Free Software Foundation, incorporated herein by reference.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
- ****************************************************************************
- */
-
-#include <ci/efrm/nic_table.h>
-#include <ci/driver/efab/hardware.h>
-#include <ci/efhw/falcon.h>
-#include <ci/efrm/private.h>
-#include <ci/efrm/sysdep.h>
-#include <ci/efrm/buffer_table.h>
-#include <ci/efrm/vi_resource_private.h>
-#include "efrm_internal.h"
-
-
-/* can fail as workitem can already be scheuled -- ignore failure */
-#define EFRM_VI_RM_DELAYED_FREE(manager) \
-	queue_work(manager->workqueue, &manager->work_item)
-
-static const int flush_fifo_hwm = 8 /* TODO should be a HW specific const */ ;
-
-static void
-efrm_vi_resource_rx_flush_done(struct vi_resource *virs, bool *completed)
-{
-	/* We should only get a flush event if there is a flush
-	 * outstanding. */
-	EFRM_ASSERT(virs->rx_flush_outstanding);
-
-	virs->rx_flush_outstanding = 0;
-	virs->rx_flushing = 0;
-
-	list_del(&virs->rx_flush_link);
-	efrm_vi_manager->rx_flush_outstanding_count--;
-
-	if (virs->tx_flushing == 0) {
-		list_add_tail(&virs->rx_flush_link,
-			      &efrm_vi_manager->close_pending);
-		*completed = 1;
-	}
-}
-
-static void
-efrm_vi_resource_tx_flush_done(struct vi_resource *virs, bool *completed)
-{
-	/* We should only get a flush event if there is a flush
-	 * outstanding. */
-	EFRM_ASSERT(virs->tx_flushing);
-
-	virs->tx_flushing = 0;
-
-	list_del(&virs->tx_flush_link);
-
-	if (virs->rx_flushing == 0) {
-		list_add_tail(&virs->rx_flush_link,
-			      &efrm_vi_manager->close_pending);
-		*completed = 1;
-	}
-}
-
-static void
-efrm_vi_resource_issue_rx_flush(struct vi_resource *virs, bool *completed)
-{
-	struct efhw_nic *nic = virs->rs.rs_client->nic;
-	int instance;
-	int rc;
-
-	instance = EFRM_RESOURCE_INSTANCE(virs->rs.rs_handle);
-
-	list_add_tail(&virs->rx_flush_link,
-		      &efrm_vi_manager->rx_flush_outstanding_list);
-	virs->rx_flush_outstanding = virs->rx_flushing;
-	efrm_vi_manager->rx_flush_outstanding_count++;
-
-	EFRM_TRACE("%s: rx queue %d flush requested for nic %d",
-		   __func__, instance, nic->index);
-	rc = efhw_nic_flush_rx_dma_channel(nic, instance);
-	if (rc == -EAGAIN)
-		efrm_vi_resource_rx_flush_done(virs, completed);
-}
-
-static void
-efrm_vi_resource_issue_tx_flush(struct vi_resource *virs, bool *completed)
-{
-	struct efhw_nic *nic = virs->rs.rs_client->nic;
-	int instance;
-	int rc;
-
-	instance = EFRM_RESOURCE_INSTANCE(virs->rs.rs_handle);
-
-	list_add_tail(&virs->tx_flush_link,
-		      &efrm_vi_manager->tx_flush_outstanding_list);
-
-	EFRM_TRACE("%s: tx queue %d flush requested for nic %d",
-		   __func__, instance, nic->index);
-	rc = efhw_nic_flush_tx_dma_channel(nic, instance);
-	if (rc == -EAGAIN)
-		efrm_vi_resource_tx_flush_done(virs, completed);
-}
-
-static void efrm_vi_resource_process_waiting_flushes(bool *completed)
-{
-	struct vi_resource *virs;
-
-	while (efrm_vi_manager->rx_flush_outstanding_count < flush_fifo_hwm &&
-	       !list_empty(&efrm_vi_manager->rx_flush_waiting_list)) {
-		virs =
-		    list_entry(list_pop
-			       (&efrm_vi_manager->rx_flush_waiting_list),
-			       struct vi_resource, rx_flush_link);
-		efrm_vi_resource_issue_rx_flush(virs, completed);
-	}
-}
-
-#if BUG7916_WORKAROUND || BUG5302_WORKAROUND
-static void
-efrm_vi_resource_flush_retry_vi(struct vi_resource *virs,
-				int64_t time_now, bool *completed)
-{
-	struct efhw_nic *nic;
-	int instance;
-
-	instance = EFRM_RESOURCE_INSTANCE(virs->rs.rs_handle);
-
-	virs->flush_count++;
-	virs->flush_time = time_now;
-	nic = virs->rs.rs_client->nic;
-
-#if BUG7916_WORKAROUND
-	if (virs->rx_flush_outstanding) {
-		EFRM_TRACE("%s: Retrying RX flush on instance %d",
-			   __func__, instance);
-
-		list_del(&virs->rx_flush_link);
-		efrm_vi_manager->rx_flush_outstanding_count--;
-		efrm_vi_resource_issue_rx_flush(virs, completed);
-		efrm_vi_resource_process_waiting_flushes(completed);
-	}
-#endif
-
-#if BUG5302_WORKAROUND
-	if (virs->tx_flushing) {
-		if (virs->flush_count > 5) {
-			EFRM_TRACE("%s: VI resource stuck flush pending "
-				   "(instance=%d, count=%d)",
-				   __func__, instance, virs->flush_count);
-			falcon_clobber_tx_dma_ptrs(nic, instance);
-		} else {
-			EFRM_TRACE("%s: Retrying TX flush on instance %d",
-				   __func__, instance);
-		}
-
-		list_del(&virs->tx_flush_link);
-		efrm_vi_resource_issue_tx_flush(virs, completed);
-	}
-#endif
-}
-#endif
-
-int efrm_vi_resource_flush_retry(struct vi_resource *virs)
-{
-#if BUG7916_WORKAROUND || BUG5302_WORKAROUND
-	irq_flags_t lock_flags;
-	bool completed = false;
-
-	if (virs->rx_flushing == 0 && virs->tx_flushing == 0)
-		return -EALREADY;
-
-	spin_lock_irqsave(&efrm_vi_manager->rm.rm_lock, lock_flags);
-	efrm_vi_resource_flush_retry_vi(virs, get_jiffies_64(), &completed);
-	spin_unlock_irqrestore(&efrm_vi_manager->rm.rm_lock, lock_flags);
-
-	if (completed)
-		EFRM_VI_RM_DELAYED_FREE(efrm_vi_manager);
-#endif
-
-	return 0;
-}
-EXPORT_SYMBOL(efrm_vi_resource_flush_retry);
-
-#if BUG7916_WORKAROUND || BUG5302_WORKAROUND
-/* resource manager lock should be taken before this call */
-static void efrm_vi_handle_flush_loss(bool *completed)
-{
-	struct list_head *pos, *temp;
-	struct vi_resource *virs;
-	int64_t time_now, time_pending;
-
-	/* It's possible we miss flushes - the list is sorted in order we
-	 * generate flushes, see if any are very old. It's also possible
-	 * that we decide an endpoint is flushed even though we've not
-	 * received all the flush events. We *should * mark as
-	 * completed, reclaim and loop again. ??
-	 * THIS NEEDS BACKPORTING FROM THE FALCON branch
-	 */
-	time_now = get_jiffies_64();
-
-#if BUG7916_WORKAROUND
-	list_for_each_safe(pos, temp,
-			   &efrm_vi_manager->rx_flush_outstanding_list) {
-		virs = container_of(pos, struct vi_resource, rx_flush_link);
-
-		time_pending = time_now - virs->flush_time;
-
-		/* List entries are held in reverse chronological order.  Only
-		 * process the old ones. */
-		if (time_pending <= 0x100000000LL)
-			break;
-
-		efrm_vi_resource_flush_retry_vi(virs, time_now, completed);
-	}
-#endif
-
-#if BUG5302_WORKAROUND
-	list_for_each_safe(pos, temp,
-			   &efrm_vi_manager->tx_flush_outstanding_list) {
-		virs = container_of(pos, struct vi_resource, tx_flush_link);
-
-		time_pending = time_now - virs->flush_time;
-
-		/* List entries are held in reverse chronological order.
-		 * Only process the old ones. */
-		if (time_pending <= 0x100000000LL)
-			break;
-
-		efrm_vi_resource_flush_retry_vi(virs, time_now, completed);
-	}
-#endif
-}
-#endif
-
-void
-efrm_vi_register_flush_callback(struct vi_resource *virs,
-				void (*handler)(void *), void *arg)
-{
-	if (handler == NULL) {
-		virs->flush_callback_fn = handler;
-		wmb();
-		virs->flush_callback_arg = arg;
-	} else {
-		virs->flush_callback_arg = arg;
-		wmb();
-		virs->flush_callback_fn = handler;
-	}
-}
-EXPORT_SYMBOL(efrm_vi_register_flush_callback);
-
-int efrm_pt_flush(struct vi_resource *virs)
-{
-	int instance;
-	irq_flags_t lock_flags;
-	bool completed = false;
-
-	instance = EFRM_RESOURCE_INSTANCE(virs->rs.rs_handle);
-
-	EFRM_ASSERT(virs->rx_flushing == 0);
-	EFRM_ASSERT(virs->rx_flush_outstanding == 0);
-	EFRM_ASSERT(virs->tx_flushing == 0);
-
-	EFRM_TRACE("%s: " EFRM_RESOURCE_FMT " EVQ=%d TXQ=%d RXQ=%d",
-		   __func__, EFRM_RESOURCE_PRI_ARG(virs->rs.rs_handle),
-		   virs->evq_capacity,
-		   virs->dmaq_capacity[EFRM_VI_RM_DMA_QUEUE_TX],
-		   virs->dmaq_capacity[EFRM_VI_RM_DMA_QUEUE_RX]);
-
-	spin_lock_irqsave(&efrm_vi_manager->rm.rm_lock, lock_flags);
-
-	if (virs->dmaq_capacity[EFRM_VI_RM_DMA_QUEUE_RX] != 0)
-		virs->rx_flushing = 1;
-
-	if (virs->dmaq_capacity[EFRM_VI_RM_DMA_QUEUE_TX] != 0)
-		virs->tx_flushing = 1;
-
-	/* Clean up immediately if there are no flushes. */
-	if (virs->rx_flushing == 0 && virs->tx_flushing == 0) {
-		list_add_tail(&virs->rx_flush_link,
-			      &efrm_vi_manager->close_pending);
-		completed = true;
-	}
-
-	/* Issue the RX flush if possible or queue it for later. */
-	if (virs->rx_flushing) {
-#if BUG7916_WORKAROUND || BUG5302_WORKAROUND
-		if (efrm_vi_manager->rx_flush_outstanding_count >=
-		    flush_fifo_hwm)
-			efrm_vi_handle_flush_loss(&completed);
-#endif
-		if (efrm_vi_manager->rx_flush_outstanding_count >=
-		    flush_fifo_hwm) {
-			list_add_tail(&virs->rx_flush_link,
-				      &efrm_vi_manager->rx_flush_waiting_list);
-		} else {
-			efrm_vi_resource_issue_rx_flush(virs, &completed);
-		}
-	}
-
-	/* Issue the TX flush.  There's no limit to the number of
-	 * outstanding TX flushes. */
-	if (virs->tx_flushing)
-		efrm_vi_resource_issue_tx_flush(virs, &completed);
-
-	virs->flush_time = get_jiffies_64();
-
-	spin_unlock_irqrestore(&efrm_vi_manager->rm.rm_lock, lock_flags);
-
-	if (completed)
-		EFRM_VI_RM_DELAYED_FREE(efrm_vi_manager);
-
-	return 0;
-}
-EXPORT_SYMBOL(efrm_pt_flush);
-
-static void
-efrm_handle_rx_dmaq_flushed(struct efhw_nic *flush_nic, int instance,
-			    bool *completed)
-{
-	struct list_head *pos, *temp;
-	struct vi_resource *virs;
-
-	list_for_each_safe(pos, temp,
-			   &efrm_vi_manager->rx_flush_outstanding_list) {
-		virs = container_of(pos, struct vi_resource, rx_flush_link);
-
-		if (instance == EFRM_RESOURCE_INSTANCE(virs->rs.rs_handle)) {
-			efrm_vi_resource_rx_flush_done(virs, completed);
-			efrm_vi_resource_process_waiting_flushes(completed);
-			return;
-		}
-	}
-	EFRM_TRACE("%s: Unhandled rx flush event, nic %d, instance %d",
-		   __func__, flush_nic->index, instance);
-}
-
-static void
-efrm_handle_tx_dmaq_flushed(struct efhw_nic *flush_nic, int instance,
-			    bool *completed)
-{
-	struct list_head *pos, *temp;
-	struct vi_resource *virs;
-
-	list_for_each_safe(pos, temp,
-			   &efrm_vi_manager->tx_flush_outstanding_list) {
-		virs = container_of(pos, struct vi_resource, tx_flush_link);
-
-		if (instance == EFRM_RESOURCE_INSTANCE(virs->rs.rs_handle)) {
-			efrm_vi_resource_tx_flush_done(virs, completed);
-			return;
-		}
-	}
-	EFRM_TRACE("%s: Unhandled tx flush event, nic %d, instance %d",
-		   __func__, flush_nic->index, instance);
-}
-
-void
-efrm_handle_dmaq_flushed(struct efhw_nic *flush_nic, unsigned instance,
-			 int rx_flush)
-{
-	irq_flags_t lock_flags;
-	bool completed = false;
-
-	EFRM_TRACE("%s: nic_i=%d  instance=%d  rx_flush=%d", __func__,
-		   flush_nic->index, instance, rx_flush);
-
-	spin_lock_irqsave(&efrm_vi_manager->rm.rm_lock, lock_flags);
-
-	if (rx_flush)
-		efrm_handle_rx_dmaq_flushed(flush_nic, instance, &completed);
-	else
-		efrm_handle_tx_dmaq_flushed(flush_nic, instance, &completed);
-
-#if BUG7916_WORKAROUND || BUG5302_WORKAROUND
-	efrm_vi_handle_flush_loss(&completed);
-#endif
-
-	spin_unlock_irqrestore(&efrm_vi_manager->rm.rm_lock, lock_flags);
-
-	if (completed)
-		EFRM_VI_RM_DELAYED_FREE(efrm_vi_manager);
-}
-
-static void
-efrm_vi_rm_reinit_dmaqs(struct vi_resource *virs)
-{
-	struct efhw_nic *nic = virs->rs.rs_client->nic;
-
-	if (virs->dmaq_capacity[EFRM_VI_RM_DMA_QUEUE_TX] != 0)
-		efrm_vi_rm_init_dmaq(virs, EFRM_VI_RM_DMA_QUEUE_TX, nic);
-	if (virs->dmaq_capacity[EFRM_VI_RM_DMA_QUEUE_RX])
-		efrm_vi_rm_init_dmaq(virs, EFRM_VI_RM_DMA_QUEUE_RX, nic);
-}
-
-/* free any PT endpoints whose flush has now complete */
-void efrm_vi_rm_delayed_free(struct work_struct *data)
-{
-	irq_flags_t lock_flags;
-	struct list_head close_pending;
-	struct vi_resource *virs;
-
-	EFRM_RESOURCE_MANAGER_ASSERT_VALID(&efrm_vi_manager->rm);
-
-	spin_lock_irqsave(&efrm_vi_manager->rm.rm_lock, lock_flags);
-	list_replace_init(&efrm_vi_manager->close_pending, &close_pending);
-	spin_unlock_irqrestore(&efrm_vi_manager->rm.rm_lock, lock_flags);
-
-	EFRM_TRACE("%s: %p", __func__, efrm_vi_manager);
-	while (!list_empty(&close_pending)) {
-		virs =
-		    list_entry(list_pop(&close_pending), struct vi_resource,
-			       rx_flush_link);
-		EFRM_TRACE("%s: flushed VI instance=%d", __func__,
-			   EFRM_RESOURCE_INSTANCE(virs->rs.rs_handle));
-
-		if (virs->flush_callback_fn != NULL) {
-			efrm_vi_rm_reinit_dmaqs(virs);
-			virs->flush_callback_fn(virs->flush_callback_arg);
-		} else
-			efrm_vi_rm_free_flushed_resource(virs);
-	}
-}
-
-void efrm_vi_rm_salvage_flushed_vis(void)
-{
-#if BUG7916_WORKAROUND || BUG5302_WORKAROUND
-	irq_flags_t lock_flags;
-	bool completed;
-
-	spin_lock_irqsave(&efrm_vi_manager->rm.rm_lock, lock_flags);
-	efrm_vi_handle_flush_loss(&completed);
-	spin_unlock_irqrestore(&efrm_vi_manager->rm.rm_lock, lock_flags);
-#endif
-
-	efrm_vi_rm_delayed_free(&efrm_vi_manager->work_item);
-}
-
-void efrm_vi_resource_free(struct vi_resource *virs)
-{
-	efrm_vi_register_flush_callback(virs, NULL, NULL);
-	efrm_pt_flush(virs);
-}
-EXPORT_SYMBOL(efrm_vi_resource_free);
-
-
-void efrm_vi_resource_release(struct vi_resource *virs)
-{
-	if (__efrm_resource_release(&virs->rs))
-		efrm_vi_resource_free(virs);
-}
-EXPORT_SYMBOL(efrm_vi_resource_release);
-
-/*
- * vi: sw=8:ai:aw
- */
diff -r 5b3d4d3c1166 drivers/net/sfc/sfc_resource/vi_resource_manager.c
--- a/drivers/net/sfc/sfc_resource/vi_resource_manager.c	Fri Nov 05 15:20:28 2010 +0000
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,231 +0,0 @@
-/****************************************************************************
- * Driver for Solarflare network controllers -
- *          resource management for Xen backend, OpenOnload, etc
- *           (including support for SFE4001 10GBT NIC)
- *
- * This file contains the VI resource manager.
- *
- * Copyright 2005-2007: Solarflare Communications Inc,
- *                      9501 Jeronimo Road, Suite 250,
- *                      Irvine, CA 92618, USA
- *
- * Developed and maintained by Solarflare Communications:
- *                      <linux-xen-drivers@solarflare.com>
- *                      <onload-dev@solarflare.com>
- *
- * Certain parts of the driver were implemented by
- *          Alexandra Kossovsky <Alexandra.Kossovsky@oktetlabs.ru>
- *          OKTET Labs Ltd, Russia,
- *          http://oktetlabs.ru, <info@oktetlabs.ru>
- *          by request of Solarflare Communications
- *
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 as published
- * by the Free Software Foundation, incorporated herein by reference.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
- ****************************************************************************
- */
-
-#include <ci/efrm/nic_table.h>
-#include <ci/driver/efab/hardware.h>
-#include <ci/efhw/falcon.h>
-#include <ci/efrm/private.h>
-#include <ci/efrm/vi_resource_private.h>
-#include "efrm_internal.h"
-
-
-int efrm_pt_pace(struct vi_resource *virs, unsigned int val)
-{
-	struct efhw_nic *nic = virs->rs.rs_client->nic;
-	int instance;
-
-	EFRM_RESOURCE_ASSERT_VALID(&virs->rs, 0);
-	instance = EFRM_RESOURCE_INSTANCE(virs->rs.rs_handle);
-	falcon_nic_pace(nic, instance, val);
-	EFRM_TRACE("%s[%d]=%d DONE", __func__, instance, val);
-	return 0;
-}
-EXPORT_SYMBOL(efrm_pt_pace);
-
-/*** Resource manager creation/destruction *******************************/
-
-static void efrm_vi_rm_dtor(struct efrm_resource_manager *rm);
-
-static int
-efrm_create_or_destroy_vi_resource_manager(
-				struct efrm_resource_manager **rm_in_out,
-				const struct vi_resource_dimensions *dims,
-				bool destroy)
-{
-	struct vi_resource *virs;
-	struct list_head *pos, *temp;
-	struct list_head flush_pending;
-	irq_flags_t lock_flags;
-	int rc;
-	unsigned dmaq_min, dmaq_lim;
-
-	EFRM_ASSERT(rm_in_out);
-
-	if (destroy)
-		goto destroy;
-
-	EFRM_ASSERT(dims);
-	EFRM_NOTICE("vi_resource_manager: evq_int=%u-%u evq_timer=%u-%u",
-		    dims->evq_int_min, dims->evq_int_lim,
-		    dims->evq_timer_min, dims->evq_timer_lim);
-	EFRM_NOTICE("vi_resource_manager: rxq=%u-%u txq=%u-%u",
-		    dims->rxq_min, dims->rxq_lim,
-		    dims->txq_min, dims->txq_lim);
-
-	efrm_vi_manager = kmalloc(sizeof(*efrm_vi_manager), GFP_KERNEL);
-	if (efrm_vi_manager == NULL) {
-		rc = -ENOMEM;
-		goto fail_alloc;
-	}
-
-	memset(efrm_vi_manager, 0, sizeof(*efrm_vi_manager));
-
-	efrm_vi_manager->iscsi_dmaq_instance_is_free = true;
-
-	dmaq_min = max(dims->rxq_min, dims->txq_min);
-	dmaq_lim = min(dims->rxq_lim, dims->txq_lim);
-
-	efrm_vi_manager->with_timer_base =
-	    max(dmaq_min, dims->evq_timer_min);
-	efrm_vi_manager->with_timer_limit =
-	    min(dmaq_lim, dims->evq_timer_lim);
-	rc = efrm_kfifo_id_ctor(&efrm_vi_manager->instances_with_timer,
-				efrm_vi_manager->with_timer_base,
-				efrm_vi_manager->with_timer_limit,
-				&efrm_vi_manager->rm.rm_lock);
-	if (rc < 0)
-		goto fail_with_timer_id_pool;
-
-	efrm_vi_manager->with_interrupt_base =
-	    max(dmaq_min, dims->evq_int_min);
-	efrm_vi_manager->with_interrupt_limit =
-	    min(dmaq_lim, dims->evq_int_lim);
-	efrm_vi_manager->with_interrupt_limit =
-		max(efrm_vi_manager->with_interrupt_limit,
-		    efrm_vi_manager->with_interrupt_base);
-	rc = efrm_kfifo_id_ctor(&efrm_vi_manager->instances_with_interrupt,
-				efrm_vi_manager->with_interrupt_base,
-				efrm_vi_manager->with_interrupt_limit,
-				&efrm_vi_manager->rm.rm_lock);
-	if (rc < 0)
-		goto fail_with_int_id_pool;
-
-	INIT_LIST_HEAD(&efrm_vi_manager->rx_flush_waiting_list);
-	INIT_LIST_HEAD(&efrm_vi_manager->rx_flush_outstanding_list);
-	INIT_LIST_HEAD(&efrm_vi_manager->tx_flush_outstanding_list);
-	efrm_vi_manager->rx_flush_outstanding_count = 0;
-
-	INIT_LIST_HEAD(&efrm_vi_manager->close_pending);
-	efrm_vi_manager->workqueue = create_workqueue("sfc_vi");
-	if (efrm_vi_manager->workqueue == NULL)
-		goto fail_create_workqueue;
-	INIT_WORK(&efrm_vi_manager->work_item, efrm_vi_rm_delayed_free);
-
-	/* NB.  This must be the last step to avoid things getting tangled.
-	 * efrm_resource_manager_dtor calls the vi_rm_dtor which ends up in
-	 * this function. */
-	rc = efrm_resource_manager_ctor(&efrm_vi_manager->rm, efrm_vi_rm_dtor,
-					"VI", EFRM_RESOURCE_VI);
-	if (rc < 0)
-		goto fail_rm_ctor;
-
-	*rm_in_out = &efrm_vi_manager->rm;
-	return 0;
-
-destroy:
-	rc = 0;
-	EFRM_RESOURCE_MANAGER_ASSERT_VALID(*rm_in_out);
-
-	/* Abort outstanding flushes.  Note, a VI resource can be on more
-	 * than one of these lists.  We handle this by starting with the TX
-	 * list and then append VIs to this list if they aren't on the TX
-	 * list already.  A VI is on the TX flush list if tx_flushing
-	 * is not empty. */
-	spin_lock_irqsave(&efrm_vi_manager->rm.rm_lock, lock_flags);
-
-	list_replace_init(&efrm_vi_manager->tx_flush_outstanding_list,
-			  &flush_pending);
-
-	list_for_each_safe(pos, temp,
-			   &efrm_vi_manager->rx_flush_waiting_list) {
-		virs = container_of(pos, struct vi_resource, rx_flush_link);
-
-		list_del(&virs->rx_flush_link);
-		if (virs->tx_flushing == 0)
-			list_add_tail(&virs->tx_flush_link, &flush_pending);
-	}
-
-	list_for_each_safe(pos, temp,
-			   &efrm_vi_manager->rx_flush_outstanding_list) {
-		virs = container_of(pos, struct vi_resource, rx_flush_link);
-
-		list_del(&virs->rx_flush_link);
-		if (virs->tx_flushing == 0)
-			list_add_tail(&virs->tx_flush_link, &flush_pending);
-	}
-
-	spin_unlock_irqrestore(&efrm_vi_manager->rm.rm_lock, lock_flags);
-
-	while (!list_empty(&flush_pending)) {
-		virs =
-		    list_entry(list_pop(&flush_pending), struct vi_resource,
-			       tx_flush_link);
-		EFRM_TRACE("%s: found PT endpoint " EFRM_RESOURCE_FMT
-			   " with flush pending [Tx=0x%x, Rx=0x%x, RxO=0x%x]",
-			   __func__,
-			   EFRM_RESOURCE_PRI_ARG(virs->rs.rs_handle),
-			   virs->tx_flushing,
-			   virs->rx_flushing,
-			   virs->rx_flush_outstanding);
-		efrm_vi_rm_free_flushed_resource(virs);
-	}
-
-fail_rm_ctor:
-
-	/* Complete outstanding closes. */
-	destroy_workqueue(efrm_vi_manager->workqueue);
-fail_create_workqueue:
-	EFRM_ASSERT(list_empty(&efrm_vi_manager->close_pending));
-	kfifo_vfree(efrm_vi_manager->instances_with_interrupt);
-fail_with_int_id_pool:
-
-	kfifo_vfree(efrm_vi_manager->instances_with_timer);
-fail_with_timer_id_pool:
-
-	if (destroy)
-		return 0;
-
-	EFRM_DO_DEBUG(memset(efrm_vi_manager, 0, sizeof(*efrm_vi_manager)));
-	kfree(efrm_vi_manager);
-fail_alloc:
-
-	*rm_in_out = NULL;
-	EFRM_ERR("%s: failed rc=%d", __func__, rc);
-	return rc;
-}
-
-int
-efrm_create_vi_resource_manager(struct efrm_resource_manager **rm_out,
-				const struct vi_resource_dimensions *dims)
-{
-	return efrm_create_or_destroy_vi_resource_manager(rm_out, dims, false);
-}
-
-static void efrm_vi_rm_dtor(struct efrm_resource_manager *rm)
-{
-	efrm_create_or_destroy_vi_resource_manager(&rm, NULL, true);
-}
diff -r 5b3d4d3c1166 drivers/net/sfc/sfe4001.c
--- a/drivers/net/sfc/sfe4001.c	Fri Nov 05 15:20:28 2010 +0000
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,435 +0,0 @@
-/****************************************************************************
- * Driver for Solarflare Solarstorm network controllers and boards
- * Copyright 2007-2008 Solarflare Communications Inc.
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 as published
- * by the Free Software Foundation, incorporated herein by reference.
- */
-
-/*****************************************************************************
- * Support for the SFE4001 and SFN4111T NICs.
- *
- * The SFE4001 does not power-up fully at reset due to its high power
- * consumption.  We control its power via a PCA9539 I/O expander.
- * Both boards have a MAX6647 temperature monitor which we expose to
- * the lm90 driver.
- *
- * This also provides minimal support for reflashing the PHY, which is
- * initiated by resetting it with the FLASH_CFG_1 pin pulled down.
- * On SFE4001 rev A2 and later this is connected to the 3V3X output of
- * the IO-expander; on the SFN4111T it is connected to Falcon's GPIO3.
- * We represent reflash mode as PHY_MODE_SPECIAL and make it mutually
- * exclusive with the network device being open.
- */
-
-#include <linux/delay.h>
-#include <linux/rtnetlink.h>
-#include "net_driver.h"
-#include "efx.h"
-#include "phy.h"
-#include "boards.h"
-#include "falcon.h"
-#include "falcon_hwdefs.h"
-#include "falcon_io.h"
-#include "mac.h"
-#include "workarounds.h"
-
-/**************************************************************************
- *
- * I2C IO Expander device
- *
- **************************************************************************/
-#define	PCA9539 0x74
-
-#define	P0_IN 0x00
-#define	P0_OUT 0x02
-#define	P0_INVERT 0x04
-#define	P0_CONFIG 0x06
-
-#define	P0_EN_1V0X_LBN 0
-#define	P0_EN_1V0X_WIDTH 1
-#define	P0_EN_1V2_LBN 1
-#define	P0_EN_1V2_WIDTH 1
-#define	P0_EN_2V5_LBN 2
-#define	P0_EN_2V5_WIDTH 1
-#define	P0_EN_3V3X_LBN 3
-#define	P0_EN_3V3X_WIDTH 1
-#define	P0_EN_5V_LBN 4
-#define	P0_EN_5V_WIDTH 1
-#define	P0_SHORTEN_JTAG_LBN 5
-#define	P0_SHORTEN_JTAG_WIDTH 1
-#define	P0_X_TRST_LBN 6
-#define	P0_X_TRST_WIDTH 1
-#define	P0_DSP_RESET_LBN 7
-#define	P0_DSP_RESET_WIDTH 1
-
-#define	P1_IN 0x01
-#define	P1_OUT 0x03
-#define	P1_INVERT 0x05
-#define	P1_CONFIG 0x07
-
-#define	P1_AFE_PWD_LBN 0
-#define	P1_AFE_PWD_WIDTH 1
-#define	P1_DSP_PWD25_LBN 1
-#define	P1_DSP_PWD25_WIDTH 1
-#define	P1_RESERVED_LBN 2
-#define	P1_RESERVED_WIDTH 2
-#define	P1_SPARE_LBN 4
-#define	P1_SPARE_WIDTH 4
-
-/* Temperature Sensor */
-#define MAX664X_REG_RSL		0x02
-#define MAX664X_REG_WLHO	0x0B
-
-static void sfe4001_poweroff(struct efx_nic *efx)
-{
-	struct i2c_client *ioexp_client = efx->board_info.ioexp_client;
-	struct i2c_client *hwmon_client = efx->board_info.hwmon_client;
-
-	/* Turn off all power rails and disable outputs */
-	i2c_smbus_write_byte_data(ioexp_client, P0_OUT, 0xff);
-	i2c_smbus_write_byte_data(ioexp_client, P1_CONFIG, 0xff);
-	i2c_smbus_write_byte_data(ioexp_client, P0_CONFIG, 0xff);
-
-	/* Clear any over-temperature alert */
-	i2c_smbus_read_byte_data(hwmon_client, MAX664X_REG_RSL);
-}
-
-static int sfe4001_poweron(struct efx_nic *efx)
-{
-	struct i2c_client *hwmon_client = efx->board_info.hwmon_client;
-	struct i2c_client *ioexp_client = efx->board_info.ioexp_client;
-	unsigned int i, j;
-	int rc;
-	u8 out;
-
-	/* Clear any previous over-temperature alert */
-	rc = i2c_smbus_read_byte_data(hwmon_client, MAX664X_REG_RSL);
-	if (rc < 0)
-		return rc;
-
-	/* Enable port 0 and port 1 outputs on IO expander */
-	rc = i2c_smbus_write_byte_data(ioexp_client, P0_CONFIG, 0x00);
-	if (rc)
-		return rc;
-	rc = i2c_smbus_write_byte_data(ioexp_client, P1_CONFIG,
-				       0xff & ~(1 << P1_SPARE_LBN));
-	if (rc)
-		goto fail_on;
-
-	/* If PHY power is on, turn it all off and wait 1 second to
-	 * ensure a full reset.
-	 */
-	rc = i2c_smbus_read_byte_data(ioexp_client, P0_OUT);
-	if (rc < 0)
-		goto fail_on;
-	out = 0xff & ~((0 << P0_EN_1V2_LBN) | (0 << P0_EN_2V5_LBN) |
-		       (0 << P0_EN_3V3X_LBN) | (0 << P0_EN_5V_LBN) |
-		       (0 << P0_EN_1V0X_LBN));
-	if (rc != out) {
-		EFX_INFO(efx, "power-cycling PHY\n");
-		rc = i2c_smbus_write_byte_data(ioexp_client, P0_OUT, out);
-		if (rc)
-			goto fail_on;
-		schedule_timeout_uninterruptible(HZ);
-	}
-
-	for (i = 0; i < 20; ++i) {
-		/* Turn on 1.2V, 2.5V, 3.3V and 5V power rails */
-		out = 0xff & ~((1 << P0_EN_1V2_LBN) | (1 << P0_EN_2V5_LBN) |
-			       (1 << P0_EN_3V3X_LBN) | (1 << P0_EN_5V_LBN) |
-			       (1 << P0_X_TRST_LBN));
-		if (efx->phy_mode & PHY_MODE_SPECIAL)
-			out |= 1 << P0_EN_3V3X_LBN;
-
-		rc = i2c_smbus_write_byte_data(ioexp_client, P0_OUT, out);
-		if (rc)
-			goto fail_on;
-		msleep(10);
-
-		/* Turn on 1V power rail */
-		out &= ~(1 << P0_EN_1V0X_LBN);
-		rc = i2c_smbus_write_byte_data(ioexp_client, P0_OUT, out);
-		if (rc)
-			goto fail_on;
-
-		EFX_INFO(efx, "waiting for DSP boot (attempt %d)...\n", i);
-
-		/* In flash config mode, DSP does not turn on AFE, so
-		 * just wait 1 second.
-		 */
-		if (efx->phy_mode & PHY_MODE_SPECIAL) {
-			schedule_timeout_uninterruptible(HZ);
-			return 0;
-		}
-
-		for (j = 0; j < 10; ++j) {
-			msleep(100);
-
-			/* Check DSP has asserted AFE power line */
-			rc = i2c_smbus_read_byte_data(ioexp_client, P1_IN);
-			if (rc < 0)
-				goto fail_on;
-			if (rc & (1 << P1_AFE_PWD_LBN))
-				return 0;
-		}
-	}
-
-	EFX_INFO(efx, "timed out waiting for DSP boot\n");
-	rc = -ETIMEDOUT;
-fail_on:
-	sfe4001_poweroff(efx);
-	return rc;
-}
-
-static int sfn4111t_reset(struct efx_nic *efx)
-{
-	efx_oword_t reg;
-
-	/* GPIO 3 and the GPIO register are shared with I2C, so block that */
-	i2c_lock_adapter(&efx->i2c_adap);
-
-	/* Pull RST_N (GPIO 2) low then let it up again, setting the
-	 * FLASH_CFG_1 strap (GPIO 3) appropriately.  Only change the
-	 * output enables; the output levels should always be 0 (low)
-	 * and we rely on external pull-ups. */
-	falcon_read(efx, &reg, GPIO_CTL_REG_KER);
-	EFX_SET_OWORD_FIELD(reg, GPIO2_OEN, true);
-	falcon_write(efx, &reg, GPIO_CTL_REG_KER);
-	msleep(1000);
-	EFX_SET_OWORD_FIELD(reg, GPIO2_OEN, false);
-	EFX_SET_OWORD_FIELD(reg, GPIO3_OEN,
-			    !!(efx->phy_mode & PHY_MODE_SPECIAL));
-	falcon_write(efx, &reg, GPIO_CTL_REG_KER);
-	msleep(1);
-
-	i2c_unlock_adapter(&efx->i2c_adap);
-
-	ssleep(1);
-	return 0;
-}
-
-static ssize_t show_phy_flash_cfg(struct device *dev,
-				  struct device_attribute *attr, char *buf)
-{
-	struct efx_nic *efx = pci_get_drvdata(to_pci_dev(dev));
-	return sprintf(buf, "%d\n", !!(efx->phy_mode & PHY_MODE_SPECIAL));
-}
-
-static ssize_t set_phy_flash_cfg(struct device *dev,
-				 struct device_attribute *attr,
-				 const char *buf, size_t count)
-{
-	struct efx_nic *efx = pci_get_drvdata(to_pci_dev(dev));
-	enum efx_phy_mode old_mode, new_mode;
-	int err;
-
-	rtnl_lock();
-	old_mode = efx->phy_mode;
-	if (count == 0 || *buf == '0')
-		new_mode = old_mode & ~PHY_MODE_SPECIAL;
-	else
-		new_mode = PHY_MODE_SPECIAL;
-	if (old_mode == new_mode) {
-		err = 0;
-	} else if (efx->state != STATE_RUNNING || netif_running(efx->net_dev)) {
-		err = -EBUSY;
-	} else {
-		/* Reset the PHY, reconfigure the MAC and enable/disable
-		 * MAC stats accordingly. */
-		efx->phy_mode = new_mode;
-		if (new_mode & PHY_MODE_SPECIAL)
-			efx_stats_disable(efx);
-		if (efx->board_info.type == EFX_BOARD_SFE4001)
-			err = sfe4001_poweron(efx);
-		else
-			err = sfn4111t_reset(efx);
-		efx_reconfigure_port(efx);
-		if (!(new_mode & PHY_MODE_SPECIAL))
-			efx_stats_enable(efx);
-	}
-	rtnl_unlock();
-
-	return err ? err : count;
-}
-
-static DEVICE_ATTR(phy_flash_cfg, 0644, show_phy_flash_cfg, set_phy_flash_cfg);
-
-static void sfe4001_fini(struct efx_nic *efx)
-{
-	EFX_INFO(efx, "%s\n", __func__);
-
-	device_remove_file(&efx->pci_dev->dev, &dev_attr_phy_flash_cfg);
-	sfe4001_poweroff(efx);
-	i2c_unregister_device(efx->board_info.ioexp_client);
-	i2c_unregister_device(efx->board_info.hwmon_client);
-}
-
-static int sfe4001_check_hw(struct efx_nic *efx)
-{
-	s32 status;
-
-	/* If XAUI link is up then do not monitor */
-	if (EFX_WORKAROUND_7884(efx) && efx->mac_up)
-		return 0;
-
-	/* Check the powered status of the PHY. Lack of power implies that
-	 * the MAX6647 has shut down power to it, probably due to a temp.
-	 * alarm. Reading the power status rather than the MAX6647 status
-	 * directly because the later is read-to-clear and would thus
-	 * start to power up the PHY again when polled, causing us to blip
-	 * the power undesirably.
-	 * We know we can read from the IO expander because we did
-	 * it during power-on. Assume failure now is bad news. */
-	status = i2c_smbus_read_byte_data(efx->board_info.ioexp_client, P1_IN);
-	if (status >= 0 &&
-	    (status & ((1 << P1_AFE_PWD_LBN) | (1 << P1_DSP_PWD25_LBN))) != 0)
-		return 0;
-
-	/* Use board power control, not PHY power control */
-	sfe4001_poweroff(efx);
-	efx->phy_mode = PHY_MODE_OFF;
-
-	return (status < 0) ? -EIO : -ERANGE;
-}
-
-static struct i2c_board_info sfe4001_hwmon_info = {
-	I2C_BOARD_INFO("max6647", 0x4e),
-};
-
-/* This board uses an I2C expander to provider power to the PHY, which needs to
- * be turned on before the PHY can be used.
- * Context: Process context, rtnl lock held
- */
-int sfe4001_init(struct efx_nic *efx)
-{
-	int rc;
-
-#if defined(CONFIG_SENSORS_LM90) || defined(CONFIG_SENSORS_LM90_MODULE)
-	efx->board_info.hwmon_client =
-		i2c_new_device(&efx->i2c_adap, &sfe4001_hwmon_info);
-#else
-	efx->board_info.hwmon_client =
-		i2c_new_dummy(&efx->i2c_adap, sfe4001_hwmon_info.addr);
-#endif
-	if (!efx->board_info.hwmon_client)
-		return -EIO;
-
-	/* Raise board/PHY high limit from 85 to 90 degrees Celsius */
-	rc = i2c_smbus_write_byte_data(efx->board_info.hwmon_client,
-				       MAX664X_REG_WLHO, 90);
-	if (rc)
-		goto fail_hwmon;
-
-	efx->board_info.ioexp_client = i2c_new_dummy(&efx->i2c_adap, PCA9539);
-	if (!efx->board_info.ioexp_client) {
-		rc = -EIO;
-		goto fail_hwmon;
-	}
-
-	/* 10Xpress has fixed-function LED pins, so there is no board-specific
-	 * blink code. */
-	efx->board_info.blink = tenxpress_phy_blink;
-
-	efx->board_info.monitor = sfe4001_check_hw;
-	efx->board_info.fini = sfe4001_fini;
-
-	if (efx->phy_mode & PHY_MODE_SPECIAL) {
-		/* PHY won't generate a 156.25 MHz clock and MAC stats fetch
-		 * will fail. */
-		efx_stats_disable(efx);
-	}
-	rc = sfe4001_poweron(efx);
-	if (rc)
-		goto fail_ioexp;
-
-	rc = device_create_file(&efx->pci_dev->dev, &dev_attr_phy_flash_cfg);
-	if (rc)
-		goto fail_on;
-
-	EFX_INFO(efx, "PHY is powered on\n");
-	return 0;
-
-fail_on:
-	sfe4001_poweroff(efx);
-fail_ioexp:
-	i2c_unregister_device(efx->board_info.ioexp_client);
-fail_hwmon:
-	i2c_unregister_device(efx->board_info.hwmon_client);
-	return rc;
-}
-
-static int sfn4111t_check_hw(struct efx_nic *efx)
-{
-	s32 status;
-
-	/* If XAUI link is up then do not monitor */
-	if (EFX_WORKAROUND_7884(efx) && efx->mac_up)
-		return 0;
-
-	/* Test LHIGH, RHIGH, FAULT, EOT and IOT alarms */
-	status = i2c_smbus_read_byte_data(efx->board_info.hwmon_client,
-					  MAX664X_REG_RSL);
-	if (status < 0)
-		return -EIO;
-	if (status & 0x57)
-		return -ERANGE;
-	return 0;
-}
-
-static void sfn4111t_fini(struct efx_nic *efx)
-{
-	EFX_INFO(efx, "%s\n", __func__);
-
-	device_remove_file(&efx->pci_dev->dev, &dev_attr_phy_flash_cfg);
-	i2c_unregister_device(efx->board_info.hwmon_client);
-}
-
-static struct i2c_board_info sfn4111t_a0_hwmon_info = {
-	I2C_BOARD_INFO("max6647", 0x4e),
-};
-
-static struct i2c_board_info sfn4111t_r5_hwmon_info = {
-	I2C_BOARD_INFO("max6646", 0x4d),
-};
-
-int sfn4111t_init(struct efx_nic *efx)
-{
-	int i = 0;
-	int rc;
-
-	efx->board_info.hwmon_client =
-		i2c_new_device(&efx->i2c_adap,
-			       (efx->board_info.minor < 5) ?
-			       &sfn4111t_a0_hwmon_info :
-			       &sfn4111t_r5_hwmon_info);
-	if (!efx->board_info.hwmon_client)
-		return -EIO;
-
-	efx->board_info.blink = tenxpress_phy_blink;
-	efx->board_info.monitor = sfn4111t_check_hw;
-	efx->board_info.fini = sfn4111t_fini;
-
-	rc = device_create_file(&efx->pci_dev->dev, &dev_attr_phy_flash_cfg);
-	if (rc)
-		goto fail_hwmon;
-
-	do {
-		if (efx->phy_mode & PHY_MODE_SPECIAL) {
-			/* PHY may not generate a 156.25 MHz clock and MAC
-			 * stats fetch will fail. */
-			efx_stats_disable(efx);
-			sfn4111t_reset(efx);
-		}
-		rc = sft9001_wait_boot(efx);
-		if (rc == 0)
-			return 0;
-		efx->phy_mode = PHY_MODE_SPECIAL;
-	} while (rc == -EINVAL && ++i < 2);
-
-	device_remove_file(&efx->pci_dev->dev, &dev_attr_phy_flash_cfg);
-fail_hwmon:
-	i2c_unregister_device(efx->board_info.hwmon_client);
-	return rc;
-}
diff -r 5b3d4d3c1166 drivers/net/sfc/siena.c
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/drivers/net/sfc/siena.c	Tue Nov 09 10:06:27 2010 +0000
@@ -0,0 +1,848 @@
+/****************************************************************************
+ * Driver for Solarflare Solarstorm network controllers and boards
+ * Copyright 2005-2006 Fen Systems Ltd.
+ * Copyright 2006-2009 Solarflare Communications Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 as published
+ * by the Free Software Foundation, incorporated herein by reference.
+ */
+
+#include <linux/bitops.h>
+#include <linux/delay.h>
+#include <linux/pci.h>
+#include <linux/module.h>
+#include <linux/slab.h>
+#include <linux/random.h>
+#include "net_driver.h"
+#include "bitfield.h"
+#include "efx.h"
+#include "nic.h"
+#include "mac.h"
+#include "spi.h"
+#include "regs.h"
+#include "io.h"
+#include "phy.h"
+#include "workarounds.h"
+#include "mcdi.h"
+#include "mcdi_pcol.h"
+
+/* Hardware control for SFC9000 family including SFL9021 (aka Siena). */
+
+static void siena_init_wol(struct efx_nic *efx);
+
+
+static void siena_push_irq_moderation(struct efx_channel *channel)
+{
+	efx_dword_t timer_cmd;
+
+	if (channel->irq_moderation)
+		EFX_POPULATE_DWORD_2(timer_cmd,
+				     FRF_CZ_TC_TIMER_MODE,
+				     FFE_CZ_TIMER_MODE_INT_HLDOFF,
+				     FRF_CZ_TC_TIMER_VAL,
+				     channel->irq_moderation - 1);
+	else
+		EFX_POPULATE_DWORD_2(timer_cmd,
+				     FRF_CZ_TC_TIMER_MODE,
+				     FFE_CZ_TIMER_MODE_DIS,
+				     FRF_CZ_TC_TIMER_VAL, 0);
+	efx_writed_page_locked(channel->efx, &timer_cmd, FR_BZ_TIMER_COMMAND_P0,
+			       channel->channel);
+}
+
+static void siena_push_multicast_hash(struct efx_nic *efx)
+{
+	WARN_ON(!mutex_is_locked(&efx->mac_lock));
+
+	efx_mcdi_rpc(efx, MC_CMD_SET_MCAST_HASH,
+		     efx->multicast_hash.byte, sizeof(efx->multicast_hash),
+		     NULL, 0, NULL);
+}
+
+static int siena_mdio_write(struct net_device *net_dev,
+			    int prtad, int devad, u16 addr, u16 value)
+{
+	struct efx_nic *efx = netdev_priv(net_dev);
+	uint32_t status;
+	int rc;
+
+	rc = efx_mcdi_mdio_write(efx, efx->mdio_bus, prtad, devad,
+				 addr, value, &status);
+	if (rc)
+		return rc;
+	if (status != MC_CMD_MDIO_STATUS_GOOD)
+		return -EIO;
+
+	return 0;
+}
+
+static int siena_mdio_read(struct net_device *net_dev,
+			   int prtad, int devad, u16 addr)
+{
+	struct efx_nic *efx = netdev_priv(net_dev);
+	uint16_t value;
+	uint32_t status;
+	int rc;
+
+	rc = efx_mcdi_mdio_read(efx, efx->mdio_bus, prtad, devad,
+				addr, &value, &status);
+	if (rc)
+		return rc;
+	if (status != MC_CMD_MDIO_STATUS_GOOD)
+		return -EIO;
+
+	return (int)value;
+}
+
+/* This call is responsible for hooking in the MAC and PHY operations */
+static int siena_probe_port(struct efx_nic *efx)
+{
+	int rc;
+
+	/* Hook in PHY operations table */
+	efx->phy_op = &efx_mcdi_phy_ops;
+
+	/* Set up MDIO structure for PHY */
+	efx->mdio.mode_support = MDIO_SUPPORTS_C45 | MDIO_EMULATE_C22;
+	efx->mdio.mdio_read = siena_mdio_read;
+	efx->mdio.mdio_write = siena_mdio_write;
+
+	/* Fill out MDIO structure, loopback modes, and initial link state */
+	rc = efx->phy_op->probe(efx);
+	if (rc != 0)
+		return rc;
+
+	/* Allocate buffer for stats */
+	rc = efx_nic_alloc_buffer(efx, &efx->stats_buffer,
+				  MC_CMD_MAC_NSTATS * sizeof(u64));
+	if (rc)
+		return rc;
+	netif_dbg(efx, probe, efx->net_dev,
+		  "stats buffer at %llx (virt %p phys %llx)\n",
+		  (u64)efx->stats_buffer.dma_addr,
+		  efx->stats_buffer.addr,
+		  (u64)virt_to_phys(efx->stats_buffer.addr));
+
+	efx_mcdi_mac_stats(efx, efx->stats_buffer.dma_addr, 0, 0, 1);
+
+	return 0;
+}
+
+static void siena_remove_port(struct efx_nic *efx)
+{
+	efx->phy_op->remove(efx);
+	efx_nic_free_buffer(efx, &efx->stats_buffer);
+}
+
+static int siena_test_sram(struct efx_nic *efx,
+			   void (*pattern)(unsigned, efx_qword_t *, int, int),
+			   int a, int b)
+{
+	void __iomem *membase = efx->membase + FR_BZ_BUF_FULL_TBL;
+	int finish = efx->sram_lim / 8;
+	efx_qword_t buf1, buf2;
+	efx_oword_t reg;
+	int wptr = 0, rptr = 0;
+
+	/* Move descriptor caches out into space so we can treat all
+	 * SRAM as buffer table.  These registers will be restored by
+	 * a following reset. */
+	EFX_POPULATE_OWORD_1(reg, FRF_AZ_SRM_RX_DC_BASE_ADR, finish);
+	efx_writeo(efx, &reg, FR_AZ_SRM_RX_DC_CFG);
+	EFX_POPULATE_OWORD_1(reg, FRF_AZ_SRM_TX_DC_BASE_ADR, finish + 64);
+	efx_writeo(efx, &reg, FR_AZ_SRM_TX_DC_CFG);
+
+	while (wptr < finish) {
+		pattern(wptr, &buf1, a, b);
+		efx_sram_writeq(efx, membase, &buf1, wptr);
+		wptr++;
+
+		/* Buffer table writes are not performed synchronously
+		 * but go through a 128-entry FIFO, so we must switch
+		 * from writing to reading after at most 128 writes.
+		 * We choose 125 to make the following calculation
+		 * result in a round number. */
+		if ((wptr - rptr) < 125 && wptr < finish)
+			continue;
+
+		/* The SRAM arbiter will allow 2 writes per 8 cycles
+		 * with a cycle time of 8 ns.  Each MMIO access takes
+		 * at least one cycle.  So in order to avoid reads
+		 * overtaking writes we must wait for at least
+		 * 125 * (8 / 2 - 2) * 8 ns = 2 us */
+		udelay(2);
+
+		for (; rptr < wptr; ++rptr) {
+			pattern(rptr, &buf1, a, b);
+			efx_sram_readq(efx, membase, &buf2, rptr);
+
+			if (!memcmp(&buf1, &buf2, sizeof(buf1)))
+				continue;
+
+			netif_err(efx, hw, efx->net_dev,
+				  "sram test failed at index 0x%x. wrote "
+				  EFX_QWORD_FMT" read "EFX_QWORD_FMT"\n",
+				  rptr, EFX_QWORD_VAL(buf1),
+				  EFX_QWORD_VAL(buf2));
+			return -EIO;
+		}
+	}
+
+	return 0;
+}
+
+static const struct efx_nic_register_test siena_register_tests[] = {
+	{ FR_AZ_ADR_REGION,
+	  EFX_OWORD32(0x0003FFFF, 0x0003FFFF, 0x0003FFFF, 0x0003FFFF) },
+	{ FR_CZ_USR_EV_CFG,
+	  EFX_OWORD32(0x000103FF, 0x00000000, 0x00000000, 0x00000000) },
+	{ FR_AZ_RX_CFG,
+	  EFX_OWORD32(0xFFFFFFFE, 0xFFFFFFFF, 0x0003FFFF, 0x00000000) },
+	{ FR_AZ_TX_CFG,
+	  EFX_OWORD32(0x7FFF0037, 0xFFFF8000, 0xFFFFFFFF, 0x03FFFFFF) },
+	{ FR_AZ_TX_RESERVED,
+	  EFX_OWORD32(0xFFFEFE80, 0x1FFFFFFF, 0x020000FE, 0x007FFFFF) },
+	{ FR_AZ_SRM_TX_DC_CFG,
+	  EFX_OWORD32(0x001FFFFF, 0x00000000, 0x00000000, 0x00000000) },
+	{ FR_AZ_RX_DC_CFG,
+	  EFX_OWORD32(0x00000003, 0x00000000, 0x00000000, 0x00000000) },
+	{ FR_AZ_RX_DC_PF_WM,
+	  EFX_OWORD32(0x000003FF, 0x00000000, 0x00000000, 0x00000000) },
+	{ FR_BZ_DP_CTRL,
+	  EFX_OWORD32(0x00000FFF, 0x00000000, 0x00000000, 0x00000000) },
+	{ FR_BZ_RX_RSS_TKEY,
+	  EFX_OWORD32(0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF) },
+	{ FR_CZ_RX_RSS_IPV6_REG1,
+	  EFX_OWORD32(0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF) },
+	{ FR_CZ_RX_RSS_IPV6_REG2,
+	  EFX_OWORD32(0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF) },
+	{ FR_CZ_RX_RSS_IPV6_REG3,
+	  EFX_OWORD32(0xFFFFFFFF, 0xFFFFFFFF, 0x00000007, 0x00000000) },
+};
+
+static const struct efx_nic_table_test siena_table_tests[] = {
+	{ FR_BZ_RX_FILTER_TBL0,
+	  FR_BZ_RX_FILTER_TBL0_STEP, FR_BZ_RX_FILTER_TBL0_ROWS,
+	  EFX_OWORD32(0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0x000003FF) },
+	{ FR_CZ_RX_MAC_FILTER_TBL0,
+	  FR_CZ_RX_MAC_FILTER_TBL0_STEP, FR_CZ_RX_MAC_FILTER_TBL0_ROWS,
+	  EFX_OWORD32(0xFFFF0FFF, 0xFFFFFFFF, 0x00000E7F, 0x00000000) },
+	{ FR_BZ_RX_DESC_PTR_TBL,
+	  FR_BZ_RX_DESC_PTR_TBL_STEP, FR_CZ_RX_DESC_PTR_TBL_ROWS,
+	  EFX_OWORD32(0xFFFFFFFF, 0x0FFFFFFF, 0x01800000, 0x00000000) },
+	{ FR_BZ_TX_DESC_PTR_TBL,
+	  FR_BZ_TX_DESC_PTR_TBL_STEP, FR_CZ_TX_DESC_PTR_TBL_ROWS,
+	  EFX_OWORD32(0xFFFFFFFE, 0x0FFFFFFF, 0x0C000000, 0x00000000) },
+	{ FR_BZ_TIMER_TBL,
+	  FR_BZ_TIMER_TBL_STEP, FR_CZ_TIMER_TBL_ROWS,
+	  EFX_OWORD32(0x3FFFFFFF, 0x00000000, 0x00000000, 0x00000000) },
+	{ FR_CZ_TX_FILTER_TBL0,
+	  FR_CZ_TX_FILTER_TBL0_STEP, FR_CZ_TX_FILTER_TBL0_ROWS,
+	  EFX_OWORD32(0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0x000013FF) },
+	{ FR_CZ_TX_MAC_FILTER_TBL0,
+	  FR_CZ_TX_MAC_FILTER_TBL0_STEP, FR_CZ_TX_MAC_FILTER_TBL0_ROWS,
+	  EFX_OWORD32(0xFFFF07FF, 0xFFFFFFFF, 0x0000007F, 0x00000000) },
+};
+
+static int siena_test_registers(struct efx_nic *efx)
+{
+	return efx_nic_test_registers(efx, siena_register_tests,
+				      ARRAY_SIZE(siena_register_tests));
+}
+
+static int
+siena_test_tables(struct efx_nic *efx,
+		  void (*pattern)(unsigned, efx_qword_t *, int, int),
+		  int a, int b)
+{
+	int rc, i;
+
+	rc = siena_test_sram(efx, pattern, a, b);
+	if (rc)
+		return rc;
+
+	for (i = 0; i < ARRAY_SIZE(siena_table_tests); i++) {
+		rc = efx_nic_test_table(efx, &siena_table_tests[i],
+					pattern, a, b);
+		if (rc)
+			return rc;
+	}
+
+	return 0;
+}
+
+/**************************************************************************
+ *
+ * Device reset
+ *
+ **************************************************************************
+ */
+
+static int siena_reset_hw(struct efx_nic *efx, enum reset_type method)
+{
+	int rc;
+
+#ifdef EFX_NOT_UPSTREAM
+	if (efx_nic_no_resets) {
+		netif_dbg(efx, hw, efx->net_dev, "skipping hardware reset %s\n",
+			  RESET_TYPE(method));
+		return 0;
+	}
+#endif
+
+	/* Recover from a failed assertion pre-reset */
+	rc = efx_mcdi_handle_assertion(efx);
+	if (rc)
+		return rc;
+
+	if (method == RESET_TYPE_WORLD)
+		return efx_mcdi_reset_mc(efx);
+	else
+		return efx_mcdi_reset_port(efx);
+}
+
+static int siena_probe_nvconfig(struct efx_nic *efx)
+{
+	return efx_mcdi_get_board_cfg(efx, efx->mac_address, NULL, NULL);
+}
+
+static int siena_dimension_resources(struct efx_nic *efx)
+{
+	/* There is a small block of internal SRAM dedicated to the
+	 * buffer table and descriptor caches. */
+	size_t sram_size = 72 * 1024 * 64 / 8;
+	struct efx_dl_falcon_resources *res = &efx->resources;
+	unsigned vi_count = res->evq_timer_min;
+	u8 outbuf[MC_CMD_GET_RESOURCE_LIMITS_OUT_LEN];
+	size_t outlen;
+	int rc;
+
+	BUILD_BUG_ON(MC_CMD_GET_RESOURCE_LIMITS_IN_LEN != 0);
+
+	rc = efx_mcdi_rpc(efx, MC_CMD_GET_RESOURCE_LIMITS, NULL, 0,
+			  outbuf, sizeof(outbuf), &outlen);
+	if (rc == -ENOSYS) {
+		res->buffer_table_lim = sram_size / 8;
+	} else if (rc) {
+		return rc;
+	} else {
+		res->buffer_table_lim =
+			MCDI_DWORD(outbuf, GET_RESOURCE_LIMITS_OUT_BUFTBL);
+		res->rxq_lim = MCDI_DWORD(outbuf, GET_RESOURCE_LIMITS_OUT_RXQ);
+		res->txq_lim = MCDI_DWORD(outbuf, GET_RESOURCE_LIMITS_OUT_TXQ);
+		res->evq_timer_lim =
+			MCDI_DWORD(outbuf, GET_RESOURCE_LIMITS_OUT_EVQ);
+		if (res->buffer_table_lim < sram_size / 8) {
+			efx->resources.flags |=
+				EFX_DL_FALCON_ONLOAD_UNSUPPORTED;
+		}
+	}
+
+#ifdef CONFIG_SFC_SRIOV
+	/* Reserve sram and vnics for the VFs */
+	if (efx->vf_count && res->evq_timer_lim > EFX_VI_BASE) {
+		vi_count = EFX_VI_BASE + (efx->vf_count << efx->vi_scale);
+		res->buffer_table_min += vi_count *
+			(EFX_MAX_DMAQ_SIZE * 2 + EFX_MAX_EVQ_SIZE) *
+			sizeof(efx_qword_t) / EFX_BUF_SIZE;
+		res->evq_timer_min = max_t(int, res->evq_timer_min, vi_count);
+		res->evq_int_min = max_t(int, res->evq_int_min, vi_count);
+		res->rxq_min = max_t(int, res->rxq_min, vi_count);
+		res->txq_min = max_t(int, res->txq_min, vi_count);
+	}
+	else
+		efx->vf_count = 0;
+#endif
+
+	return efx_nic_dimension_resources(efx, sram_size, vi_count);
+}
+
+static int siena_probe_nic(struct efx_nic *efx)
+{
+	struct siena_nic_data *nic_data;
+	bool already_attached = 0;
+	efx_oword_t reg;
+	int rc;
+
+	/* Allocate storage for hardware specific data */
+	nic_data = kzalloc(sizeof(struct siena_nic_data), GFP_KERNEL);
+	if (!nic_data)
+		return -ENOMEM;
+	efx->nic_data = nic_data;
+
+#ifdef EFX_NOT_UPSTREAM
+	rc = efx_nic_test_biu(efx);
+	if (rc) {
+		netif_err(efx, probe, efx->net_dev,
+			  "self-test failed rc %d\n", rc);
+		goto fail1;
+	}
+#endif
+
+	if (efx_nic_fpga_ver(efx) != 0) {
+		netif_err(efx, probe, efx->net_dev,
+			  "Siena FPGA not supported\n");
+		rc = -ENODEV;
+		goto fail1;
+	}
+
+	efx_reado(efx, &reg, FR_AZ_CS_DEBUG);
+#if !defined(EFX_USE_KCOMPAT) || defined(EFX_USE_NETDEV_DEV_ID)
+	efx->net_dev->dev_id = EFX_OWORD_FIELD(reg, FRF_CZ_CS_PORT_NUM) - 1;
+#else
+	efx->port_num = EFX_OWORD_FIELD(reg, FRF_CZ_CS_PORT_NUM) - 1;
+#endif
+
+	efx_mcdi_init(efx);
+
+	/* Recover from a failed assertion before probing */
+	rc = efx_mcdi_handle_assertion(efx);
+	if (rc)
+		goto fail1;
+
+	/* Let the BMC know that the driver is now in charge of link and
+	 * filter settings. We must do this before we reset the NIC */
+	rc = efx_mcdi_drv_attach(efx, true, &already_attached);
+	if (rc) {
+		netif_err(efx, probe, efx->net_dev,
+			  "Unable to register driver with MCPU\n");
+		goto fail2;
+	}
+	if (already_attached)
+		/* Not a fatal error */
+		netif_err(efx, probe, efx->net_dev,
+			  "Host already registered with MCPU\n");
+
+	/* Now we can reset the NIC */
+	rc = siena_reset_hw(efx, RESET_TYPE_ALL);
+	if (rc) {
+		netif_err(efx, probe, efx->net_dev, "failed to reset NIC\n");
+		goto fail3;
+	}
+
+	siena_init_wol(efx);
+
+	/* Allocate memory for INT_KER */
+	rc = efx_nic_alloc_buffer(efx, &efx->irq_status, sizeof(efx_oword_t));
+	if (rc)
+		goto fail4;
+	BUG_ON(efx->irq_status.dma_addr & 0x0f);
+
+	netif_dbg(efx, probe, efx->net_dev,
+		  "INT_KER at %llx (virt %p phys %llx)\n",
+		  (unsigned long long)efx->irq_status.dma_addr,
+		  efx->irq_status.addr,
+		  (unsigned long long)virt_to_phys(efx->irq_status.addr));
+
+	/* Read in the non-volatile configuration */
+#ifdef EFX_NOT_UPSTREAM
+	if (efx_ignore_nvconfig)
+		rc = -EINVAL;
+	else
+		/* fall through to next statement */
+#endif
+	rc = siena_probe_nvconfig(efx);
+	if (rc == -EINVAL) {
+		netif_err(efx, probe, efx->net_dev,
+			  "NVRAM is invalid therefore using defaults\n");
+		efx->phy_type = PHY_TYPE_NONE;
+		efx->mdio.prtad = MDIO_PRTAD_NONE;
+	} else if (rc) {
+		goto fail5;
+	}
+
+	efx_sriov_probe(efx);
+	rc = siena_dimension_resources(efx);
+	if (rc)
+		goto fail6;
+
+	return 0;
+
+fail6:
+fail5:
+	efx_nic_free_buffer(efx, &efx->irq_status);
+fail4:
+fail3:
+	efx_mcdi_drv_attach(efx, false, NULL);
+fail2:
+fail1:
+	kfree(efx->nic_data);
+	return rc;
+}
+
+/* This call performs hardware-specific global initialisation, such as
+ * defining the descriptor cache sizes and number of RSS channels.
+ * It does not set up any buffers, descriptor rings or event queues.
+ */
+static int siena_init_nic(struct efx_nic *efx)
+{
+	efx_oword_t temp;
+	int rc;
+
+	/* Recover from a failed assertion post-reset */
+	rc = efx_mcdi_handle_assertion(efx);
+	if (rc)
+		return rc;
+
+	efx_nic_check_pcie_link(efx, 8, 2);
+
+	/* Do not enable TX_NO_EOP_DISC_EN, since it limits packets to 16
+	 * descriptors (which is bad).
+	 */
+	efx_reado(efx, &temp, FR_AZ_TX_CFG);
+	EFX_SET_OWORD_FIELD(temp, FRF_AZ_TX_NO_EOP_DISC_EN, 0);
+	EFX_SET_OWORD_FIELD(temp, FRF_CZ_TX_FILTER_EN_BIT, 1);
+	efx_writeo(efx, &temp, FR_AZ_TX_CFG);
+
+	efx_reado(efx, &temp, FR_AZ_RX_CFG);
+	EFX_SET_OWORD_FIELD(temp, FRF_BZ_RX_DESC_PUSH_EN, 0);
+	EFX_SET_OWORD_FIELD(temp, FRF_BZ_RX_INGR_EN, 1);
+	/* Enable hash insertion. This is broken for the 'Falcon' hash
+	 * if IPv6 hashing is also enabled, so also select Toeplitz
+	 * TCP/IPv4 and IPv4 hashes. */
+	EFX_SET_OWORD_FIELD(temp, FRF_BZ_RX_HASH_INSRT_HDR, 1);
+	EFX_SET_OWORD_FIELD(temp, FRF_BZ_RX_HASH_ALG, 1);
+	EFX_SET_OWORD_FIELD(temp, FRF_BZ_RX_IP_HASH, 1);
+	efx_writeo(efx, &temp, FR_AZ_RX_CFG);
+
+	/* Set hash key for IPv4 */
+	memcpy(&temp, efx->rx_hash_key, sizeof(temp));
+	efx_writeo(efx, &temp, FR_BZ_RX_RSS_TKEY);
+
+	/* Enable IPv6 RSS */
+	BUILD_BUG_ON(sizeof(efx->rx_hash_key) <
+		     2 * sizeof(temp) + FRF_CZ_RX_RSS_IPV6_TKEY_HI_WIDTH / 8 ||
+		     FRF_CZ_RX_RSS_IPV6_TKEY_HI_LBN != 0);
+	memcpy(&temp, efx->rx_hash_key, sizeof(temp));
+	efx_writeo(efx, &temp, FR_CZ_RX_RSS_IPV6_REG1);
+	memcpy(&temp, efx->rx_hash_key + sizeof(temp), sizeof(temp));
+	efx_writeo(efx, &temp, FR_CZ_RX_RSS_IPV6_REG2);
+	EFX_POPULATE_OWORD_2(temp, FRF_CZ_RX_RSS_IPV6_THASH_ENABLE, 1,
+			     FRF_CZ_RX_RSS_IPV6_IP_THASH_ENABLE, 1);
+	memcpy(&temp, efx->rx_hash_key + 2 * sizeof(temp),
+	       FRF_CZ_RX_RSS_IPV6_TKEY_HI_WIDTH / 8);
+	efx_writeo(efx, &temp, FR_CZ_RX_RSS_IPV6_REG3);
+
+	if (efx_nic_rx_xoff_thresh >= 0 || efx_nic_rx_xon_thresh >= 0)
+		/* No MCDI operation has been defined to set thresholds */
+		netif_err(efx, hw, efx->net_dev,
+			  "ignoring RX flow control thresholds\n");
+
+	/* Enable event logging */
+	rc = efx_mcdi_log_ctrl(efx, true, false, 0);
+	if (rc)
+		return rc;
+
+	/* Set destination of both TX and RX Flush events */
+	EFX_POPULATE_OWORD_1(temp, FRF_BZ_FLS_EVQ_ID, 0);
+	efx_writeo(efx, &temp, FR_BZ_DP_CTRL);
+
+	EFX_POPULATE_OWORD_1(temp, FRF_CZ_USREV_DIS, 1);
+	efx_writeo(efx, &temp, FR_CZ_USR_EV_CFG);
+
+	efx_nic_init_common(efx);
+	return 0;
+}
+
+static void siena_remove_nic(struct efx_nic *efx)
+{
+	efx_nic_free_buffer(efx, &efx->irq_status);
+
+	siena_reset_hw(efx, RESET_TYPE_ALL);
+
+	/* Relinquish the device back to the BMC */
+	efx_mcdi_drv_attach(efx, false, NULL);
+
+	/* Tear down the private nic state, and the driverlink nic params */
+	kfree(efx->nic_data);
+	efx->nic_data = NULL;
+}
+
+#define STATS_GENERATION_INVALID ((u64)(-1))
+
+static int siena_try_update_nic_stats(struct efx_nic *efx)
+{
+	u64 *dma_stats;
+	struct efx_mac_stats *mac_stats;
+	u64 generation_start;
+	u64 generation_end;
+	u64 stat_val;
+
+	mac_stats = &efx->mac_stats;
+	dma_stats = (u64 *)efx->stats_buffer.addr;
+
+	generation_end = dma_stats[MC_CMD_MAC_GENERATION_END];
+	if (generation_end == STATS_GENERATION_INVALID)
+		return 0;
+	rmb();
+
+#define MAC_STAT(M, D) \
+	mac_stats->M = dma_stats[MC_CMD_MAC_ ## D]
+
+	MAC_STAT(tx_bytes, TX_BYTES);
+	MAC_STAT(tx_bad_bytes, TX_BAD_BYTES);
+	mac_stats->tx_good_bytes = (mac_stats->tx_bytes -
+				    mac_stats->tx_bad_bytes);
+	MAC_STAT(tx_packets, TX_PKTS);
+	MAC_STAT(tx_bad, TX_BAD_FCS_PKTS);
+	MAC_STAT(tx_pause, TX_PAUSE_PKTS);
+	MAC_STAT(tx_control, TX_CONTROL_PKTS);
+	MAC_STAT(tx_unicast, TX_UNICAST_PKTS);
+	MAC_STAT(tx_multicast, TX_MULTICAST_PKTS);
+	MAC_STAT(tx_broadcast, TX_BROADCAST_PKTS);
+	MAC_STAT(tx_lt64, TX_LT64_PKTS);
+	MAC_STAT(tx_64, TX_64_PKTS);
+	MAC_STAT(tx_65_to_127, TX_65_TO_127_PKTS);
+	MAC_STAT(tx_128_to_255, TX_128_TO_255_PKTS);
+	MAC_STAT(tx_256_to_511, TX_256_TO_511_PKTS);
+	MAC_STAT(tx_512_to_1023, TX_512_TO_1023_PKTS);
+	MAC_STAT(tx_1024_to_15xx, TX_1024_TO_15XX_PKTS);
+	MAC_STAT(tx_15xx_to_jumbo, TX_15XX_TO_JUMBO_PKTS);
+	MAC_STAT(tx_gtjumbo, TX_GTJUMBO_PKTS);
+	mac_stats->tx_collision = 0;
+	MAC_STAT(tx_single_collision, TX_SINGLE_COLLISION_PKTS);
+	MAC_STAT(tx_multiple_collision, TX_MULTIPLE_COLLISION_PKTS);
+	MAC_STAT(tx_excessive_collision, TX_EXCESSIVE_COLLISION_PKTS);
+	MAC_STAT(tx_deferred, TX_DEFERRED_PKTS);
+	MAC_STAT(tx_late_collision, TX_LATE_COLLISION_PKTS);
+	mac_stats->tx_collision = (mac_stats->tx_single_collision +
+				   mac_stats->tx_multiple_collision +
+				   mac_stats->tx_excessive_collision +
+				   mac_stats->tx_late_collision);
+	MAC_STAT(tx_excessive_deferred, TX_EXCESSIVE_DEFERRED_PKTS);
+	MAC_STAT(tx_non_tcpudp, TX_NON_TCPUDP_PKTS);
+	MAC_STAT(tx_mac_src_error, TX_MAC_SRC_ERR_PKTS);
+	MAC_STAT(tx_ip_src_error, TX_IP_SRC_ERR_PKTS);
+	MAC_STAT(rx_bytes, RX_BYTES);
+	MAC_STAT(rx_bad_bytes, RX_BAD_BYTES);
+	mac_stats->rx_good_bytes = (mac_stats->rx_bytes -
+				    mac_stats->rx_bad_bytes);
+	MAC_STAT(rx_packets, RX_PKTS);
+	MAC_STAT(rx_good, RX_GOOD_PKTS);
+	MAC_STAT(rx_bad, RX_BAD_FCS_PKTS);
+	MAC_STAT(rx_pause, RX_PAUSE_PKTS);
+	MAC_STAT(rx_control, RX_CONTROL_PKTS);
+	MAC_STAT(rx_unicast, RX_UNICAST_PKTS);
+	MAC_STAT(rx_multicast, RX_MULTICAST_PKTS);
+	MAC_STAT(rx_broadcast, RX_BROADCAST_PKTS);
+	MAC_STAT(rx_lt64, RX_UNDERSIZE_PKTS);
+	MAC_STAT(rx_64, RX_64_PKTS);
+	MAC_STAT(rx_65_to_127, RX_65_TO_127_PKTS);
+	MAC_STAT(rx_128_to_255, RX_128_TO_255_PKTS);
+	MAC_STAT(rx_256_to_511, RX_256_TO_511_PKTS);
+	MAC_STAT(rx_512_to_1023, RX_512_TO_1023_PKTS);
+	MAC_STAT(rx_1024_to_15xx, RX_1024_TO_15XX_PKTS);
+	MAC_STAT(rx_15xx_to_jumbo, RX_15XX_TO_JUMBO_PKTS);
+	MAC_STAT(rx_gtjumbo, RX_GTJUMBO_PKTS);
+	mac_stats->rx_bad_lt64 = 0;
+	mac_stats->rx_bad_64_to_15xx = 0;
+	mac_stats->rx_bad_15xx_to_jumbo = 0;
+	MAC_STAT(rx_bad_gtjumbo, RX_JABBER_PKTS);
+	MAC_STAT(rx_overflow, RX_OVERFLOW_PKTS);
+	mac_stats->rx_missed = 0;
+	MAC_STAT(rx_false_carrier, RX_FALSE_CARRIER_PKTS);
+	MAC_STAT(rx_symbol_error, RX_SYMBOL_ERROR_PKTS);
+	MAC_STAT(rx_align_error, RX_ALIGN_ERROR_PKTS);
+	MAC_STAT(rx_length_error, RX_LENGTH_ERROR_PKTS);
+	MAC_STAT(rx_internal_error, RX_INTERNAL_ERROR_PKTS);
+	mac_stats->rx_good_lt64 = 0;
+
+	efx->n_rx_nodesc_drop_cnt = dma_stats[MC_CMD_MAC_RX_NODESC_DROPS];
+
+	stat_val = dma_stats[MC_CMD_MAC_RX_LANES01_CHAR_ERR];
+	mac_stats->rx_char_error_lane0 = (stat_val >>  0) & 0xffffffff;
+	mac_stats->rx_char_error_lane1 = (stat_val >> 32) & 0xffffffff;
+	stat_val = dma_stats[MC_CMD_MAC_RX_LANES23_CHAR_ERR];
+	mac_stats->rx_char_error_lane2 = (stat_val >>  0) & 0xffffffff;
+	mac_stats->rx_char_error_lane3 = (stat_val >> 32) & 0xffffffff;
+	stat_val = dma_stats[MC_CMD_MAC_RX_LANES01_DISP_ERR];
+	mac_stats->rx_disp_error_lane0 = (stat_val >>  0) & 0xffffffff;
+	mac_stats->rx_disp_error_lane1 = (stat_val >> 32) & 0xffffffff;
+	stat_val = dma_stats[MC_CMD_MAC_RX_LANES23_DISP_ERR];
+	mac_stats->rx_disp_error_lane2 = (stat_val >>  0) & 0xffffffff;
+	mac_stats->rx_disp_error_lane3 = (stat_val >> 32) & 0xffffffff;
+	MAC_STAT(rx_match_fault, RX_MATCH_FAULT);
+#undef MAC_STAT
+
+	rmb();
+	generation_start = dma_stats[MC_CMD_MAC_GENERATION_START];
+	if (generation_end != generation_start)
+		return -EAGAIN;
+
+	return 0;
+}
+
+static void siena_update_nic_stats(struct efx_nic *efx)
+{
+	int retry;
+
+	/* If we're unlucky enough to read statistics wduring the DMA, wait
+	 * up to 10ms for it to finish (typically takes <500us) */
+	for (retry = 0; retry < 100; ++retry) {
+		if (siena_try_update_nic_stats(efx) == 0)
+			return;
+		udelay(100);
+	}
+
+	/* Use the old values instead */
+}
+
+static void siena_start_nic_stats(struct efx_nic *efx)
+{
+	u64 *dma_stats = (u64 *)efx->stats_buffer.addr;
+
+	dma_stats[MC_CMD_MAC_GENERATION_END] = STATS_GENERATION_INVALID;
+
+	efx_mcdi_mac_stats(efx, efx->stats_buffer.dma_addr,
+			   MC_CMD_MAC_NSTATS * sizeof(u64), 1, 0);
+}
+
+static void siena_stop_nic_stats(struct efx_nic *efx)
+{
+	efx_mcdi_mac_stats(efx, efx->stats_buffer.dma_addr, 0, 0, 0);
+}
+
+/**************************************************************************
+ *
+ * Wake on LAN
+ *
+ **************************************************************************
+ */
+
+static void siena_get_wol(struct efx_nic *efx, struct ethtool_wolinfo *wol)
+{
+	struct siena_nic_data *nic_data = efx->nic_data;
+
+	wol->supported = WAKE_MAGIC;
+	if (nic_data->wol_filter_id != -1)
+		wol->wolopts = WAKE_MAGIC;
+	else
+		wol->wolopts = 0;
+	memset(&wol->sopass, 0, sizeof(wol->sopass));
+}
+
+
+static int siena_set_wol(struct efx_nic *efx, u32 type)
+{
+	struct siena_nic_data *nic_data = efx->nic_data;
+	int rc;
+
+	if (type & ~WAKE_MAGIC)
+		return -EINVAL;
+
+	if (type & WAKE_MAGIC) {
+		if (nic_data->wol_filter_id != -1)
+			efx_mcdi_wol_filter_remove(efx,
+						   nic_data->wol_filter_id);
+		rc = efx_mcdi_wol_filter_set_magic(efx, efx->mac_address,
+						   &nic_data->wol_filter_id);
+		if (rc)
+			goto fail;
+
+		pci_wake_from_d3(efx->pci_dev, true);
+	} else {
+		rc = efx_mcdi_wol_filter_reset(efx);
+		nic_data->wol_filter_id = -1;
+		pci_wake_from_d3(efx->pci_dev, false);
+		if (rc)
+			goto fail;
+	}
+
+	return 0;
+ fail:
+	netif_err(efx, hw, efx->net_dev, "%s failed: type=%d rc=%d\n",
+		  __func__, type, rc);
+	return rc;
+}
+
+
+static void siena_init_wol(struct efx_nic *efx)
+{
+	struct siena_nic_data *nic_data = efx->nic_data;
+	int rc;
+
+	rc = efx_mcdi_wol_filter_get_magic(efx, &nic_data->wol_filter_id);
+
+	if (rc != 0) {
+		/* If it failed, attempt to get into a synchronised
+		 * state with MC by resetting any set WoL filters */
+		efx_mcdi_wol_filter_reset(efx);
+		nic_data->wol_filter_id = -1;
+	} else if (nic_data->wol_filter_id != -1) {
+		pci_wake_from_d3(efx->pci_dev, true);
+	}
+}
+
+
+/**************************************************************************
+ *
+ * Revision-dependent attributes used by efx.c and nic.c
+ *
+ **************************************************************************
+ */
+
+struct efx_nic_type siena_a0_nic_type = {
+	.probe = siena_probe_nic,
+	.remove = siena_remove_nic,
+	.init = siena_init_nic,
+	.fini = efx_port_dummy_op_void,
+	.monitor = NULL,
+	.reset = siena_reset_hw,
+	.probe_port = siena_probe_port,
+	.remove_port = siena_remove_port,
+	.prepare_flush = efx_port_dummy_op_void,
+	.update_stats = siena_update_nic_stats,
+	.start_stats = siena_start_nic_stats,
+	.stop_stats = siena_stop_nic_stats,
+	.set_id_led = efx_mcdi_set_id_led,
+	.push_irq_moderation = siena_push_irq_moderation,
+	.push_multicast_hash = siena_push_multicast_hash,
+	.reconfigure_port = efx_mcdi_phy_reconfigure,
+	.get_wol = siena_get_wol,
+	.set_wol = siena_set_wol,
+	.resume_wol = siena_init_wol,
+	.test_registers = siena_test_registers,
+	.test_memory = siena_test_tables,
+	.test_nvram = efx_mcdi_nvram_test_all,
+	.default_mac_ops = &efx_mcdi_mac_operations,
+
+	.revision = EFX_REV_SIENA_A0,
+	.dl_revision = "siena/a0",
+	.mem_map_size = (FR_CZ_MC_TREG_SMEM +
+			 FR_CZ_MC_TREG_SMEM_STEP * FR_CZ_MC_TREG_SMEM_ROWS),
+	.txd_ptr_tbl_base = FR_BZ_TX_DESC_PTR_TBL,
+	.rxd_ptr_tbl_base = FR_BZ_RX_DESC_PTR_TBL,
+	.buf_tbl_base = FR_BZ_BUF_FULL_TBL,
+	.evq_ptr_tbl_base = FR_BZ_EVQ_PTR_TBL,
+	.evq_rptr_tbl_base = FR_BZ_EVQ_RPTR,
+	.max_dma_mask = DMA_BIT_MASK(FSF_AZ_TX_KER_BUF_ADDR_WIDTH),
+	.rx_buffer_hash_size = 0x10,
+	.rx_buffer_padding = 0,
+	.max_interrupt_mode = EFX_INT_MODE_MSIX,
+	.phys_addr_channels = 32, /* Hardware limit is 64, but the legacy
+				   * interrupt handler only supports 32
+				   * channels */
+	.resources = {
+		.hdr.next = &siena_a0_nic_type.dl_hash_insertion.hdr,
+		.hdr.type = EFX_DL_FALCON_RESOURCES,
+		.rxq_min = 0, .rxq_lim = 1024,
+		.txq_min = 0, .txq_lim = 1024,
+		.evq_int_min = 0, .evq_int_lim = 64,
+		.evq_timer_min = 64, .evq_timer_lim = 1024,
+	},
+	.dl_hash_insertion = {
+		.hdr.type = EFX_DL_HASH_INSERTION,
+		.data_offset = 0x10,
+		.hash_offset = 0x0c,
+		.flags = (EFX_DL_HASH_TOEP_TCPIP4 | EFX_DL_HASH_TOEP_IP4 |
+			  EFX_DL_HASH_TOEP_TCPIP6 | EFX_DL_HASH_TOEP_IP6),
+	},
+#if !defined(EFX_USE_KCOMPAT) || defined(NETIF_F_IPV6_CSUM)
+	.offload_features = (NETIF_F_IP_CSUM | NETIF_F_IPV6_CSUM |
+			     NETIF_F_RXHASH | NETIF_F_NTUPLE),
+#else
+	.offload_features = NETIF_F_HW_CSUM | NETIF_F_RXHASH | NETIF_F_NTUPLE,
+#endif
+	.reset_world_flags = ETH_RESET_MGMT << ETH_RESET_SHARED_SHIFT,
+};
diff -r 5b3d4d3c1166 drivers/net/sfc/spi.h
--- a/drivers/net/sfc/spi.h	Fri Nov 05 15:20:28 2010 +0000
+++ b/drivers/net/sfc/spi.h	Tue Nov 09 10:06:27 2010 +0000
@@ -36,8 +36,6 @@
 
 /**
  * struct efx_spi_device - an Efx SPI (Serial Peripheral Interface) device
- * @efx:		The Efx controller that owns this device
- * @mtd:		MTD state
  * @device_id:		Controller's id for the device
  * @size:		Size (in bytes)
  * @addr_len:		Number of address bytes in read/write commands
@@ -54,10 +52,6 @@
  *	Write commands are limited to blocks with this size and alignment.
  */
 struct efx_spi_device {
-	struct efx_nic *efx;
-#ifdef CONFIG_SFC_MTD
-	void *mtd;
-#endif
 	int device_id;
 	unsigned int size;
 	unsigned int addr_len;
@@ -67,12 +61,16 @@ struct efx_spi_device {
 	unsigned int block_size;
 };
 
-int falcon_spi_cmd(const struct efx_spi_device *spi, unsigned int command,
+int falcon_spi_cmd(struct efx_nic *efx,
+		   const struct efx_spi_device *spi, unsigned int command,
 		   int address, const void* in, void *out, size_t len);
-int falcon_spi_wait_write(const struct efx_spi_device *spi);
-int falcon_spi_read(const struct efx_spi_device *spi, loff_t start,
+int falcon_spi_wait_write(struct efx_nic *efx,
+			  const struct efx_spi_device *spi);
+int falcon_spi_read(struct efx_nic *efx,
+		    const struct efx_spi_device *spi, loff_t start,
 		    size_t len, size_t *retlen, u8 *buffer);
-int falcon_spi_write(const struct efx_spi_device *spi, loff_t start,
+int falcon_spi_write(struct efx_nic *efx,
+		     const struct efx_spi_device *spi, loff_t start,
 		     size_t len, size_t *retlen, const u8 *buffer);
 
 /*
diff -r 5b3d4d3c1166 drivers/net/sfc/sriov.c
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/drivers/net/sfc/sriov.c	Tue Nov 09 10:06:27 2010 +0000
@@ -0,0 +1,1170 @@
+/****************************************************************************
+ * Driver for Solarflare Solarstorm network controllers and boards
+ * Copyright 2010 Solarflare Communications Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 as published
+ * by the Free Software Foundation, incorporated herein by reference.
+ */
+#include <linux/pci.h>
+#include <linux/module.h>
+#include "net_driver.h"
+#include "efx.h"
+#include "nic.h"
+#include "io.h"
+#include "mcdi.h"
+#include "filter.h"
+#include "mcdi_pcol.h"
+#include "regs.h"
+#include "vfdi.h"
+
+/* Number of longs required to track all the VIs in a VF */
+#define VI_MASK_LENGTH					\
+	((1 << EFX_VI_SCALE_MAX) / BITS_PER_LONG)
+
+/**
+ * struct efx_vf - A VF
+ * @efx: The Efx NIC owning this PF
+ * @pci_dev: The PCI device of this VF. Used to construct pci dma
+ *	mappings into the guest pci address space.
+ * @index: The zero-based index of this VF.
+ * @req: VFDI incoming request work item. Incoming USR_EV events are received
+ *	by the NAPI handler, but must be handled by executing MCDI requests
+ *	inside a work item.
+ * @req_addr: VFDI incoming request dma address (in VF's pci address space).
+ * @req_type: Expected next incoming (from VF) VFDI_EV_TYPE member.
+ * @req_seqno: Expected next incoming (from VF) VFDI_EV_SEQ member.
+ * @msg_seqno: Next VFDI_EV_SEQ member to reply to VF.
+ * @busy: VFDI request queued to be processed or being processed. Receiving
+ *	a VFDI request when %busy is set is an error condition.
+ * @buf_ptr: Incoming VFDI requests are dma from the VF into this buffer.
+ * @buf_addr: PF dma address of %buf_ptr.
+ * @buftbl_base: Buffer table entries for this VF start at this index.
+ * @filter_idx: Receive mac filter index. Only one filter per VF is supported.
+ * @addr: The mac address and outer vlan tag of the VF.
+ * @status_addr: VF dma address of page for vfdi_status updates.
+ * @wq: wait queue used by %VFDI_FINI_ALL_QUEUES handler to wait for flush
+ *	completions.
+ * @txq_mask: Mask of initialized transmit quues.
+ * @txq_count: Number of initialized transmit queues.
+ * @rxq_mask: Mask of initialized receive queues.
+ * @rxq_count: Number of initialized receive queues.
+ * @rxq_retry_mask: Mask or receive queues that need to be flushed again
+ *	due to flush failure.
+ * @rxq_retry_count: Number of receive queues in %rxq_retry_mask.
+ */
+struct efx_vf {
+	struct efx_nic *efx;
+	struct pci_dev *pci_dev;
+	unsigned int index;
+	struct work_struct req;
+	u64 req_addr;
+	int req_type;
+	unsigned req_seqno;
+	unsigned msg_seqno;
+	bool busy;
+	void *buf_ptr;
+	dma_addr_t buf_addr;
+	unsigned int buftbl_base;
+	int filter_idx;
+	struct vfdi_endpoint addr;
+	dma_addr_t status_addr;
+	wait_queue_head_t wq;
+	unsigned long txq_mask[VI_MASK_LENGTH];
+	unsigned txq_count;
+	unsigned long rxq_mask[VI_MASK_LENGTH];
+	unsigned rxq_count;
+	unsigned long rxq_retry_mask[VI_MASK_LENGTH];
+	atomic_t rxq_retry_count;
+#ifdef EFX_NOT_UPSTREAM
+	struct device_attribute dev_attr_mac_addr;
+	struct device_attribute dev_attr_tci;
+#endif
+};
+
+struct efx_memcpy_req {
+	struct pci_dev *from_dev;
+	void *from_buf;
+	u64 from_addr;
+	struct pci_dev *to_dev;
+	u64 to_addr;
+	unsigned length;
+};
+
+/* Buffer table entries are reserved txq0,rxq0,evq0,txq1,rxq1,evq1 */
+#define EFX_BUFTBL_BLOCK_SIZE						\
+	((EFX_MAX_EVQ_SIZE + 2 * EFX_MAX_DMAQ_SIZE) *			\
+	 sizeof(efx_qword_t) / EFX_BUF_SIZE)
+#define EFX_BUFTBL_TXQ_BASE(_vf, _qid)					\
+	((_vf)->buftbl_base +						\
+	 EFX_BUFTBL_BLOCK_SIZE * ((1 << (_vf)->efx->vi_scale) + (_qid)))
+#define EFX_BUFTBL_RXQ_BASE(_vf, _qid)					\
+	(EFX_BUFTBL_TXQ_BASE(_vf, _qid) +				\
+	 (EFX_MAX_DMAQ_SIZE * sizeof(efx_qword_t) / EFX_BUF_SIZE))
+#define EFX_BUFTBL_EVQ_BASE(_vf, _qid)					\
+	(EFX_BUFTBL_TXQ_BASE(_vf, _qid) +				\
+	 (2 * EFX_MAX_DMAQ_SIZE * sizeof(efx_qword_t) / EFX_BUF_SIZE))
+
+#define EFX_FIELD_MASK(_field)			\
+	((1 << _field ## _WIDTH) - 1)
+
+#ifdef CONFIG_SFC_SRIOV
+
+static int efx_sriov_cmd(struct efx_nic *efx, bool enable,
+			 unsigned *vi_scale_out, unsigned *vf_total_out)
+{
+	u8 inbuf[MC_CMD_SRIOV_IN_LEN];
+	u8 outbuf[MC_CMD_SRIOV_OUT_LEN];
+	unsigned vi_scale, vf_total;
+	size_t outlen;
+	int rc;
+
+	MCDI_SET_DWORD(inbuf, SRIOV_IN_ENABLE, enable ? 1 : 0);
+	MCDI_SET_DWORD(inbuf, SRIOV_IN_VI_BASE, EFX_VI_BASE);
+	MCDI_SET_DWORD(inbuf, SRIOV_IN_VF_COUNT, efx->vf_count);
+
+	rc = efx_mcdi_rpc(efx, MC_CMD_SRIOV, inbuf, MC_CMD_SRIOV_IN_LEN,
+			  outbuf, MC_CMD_SRIOV_OUT_LEN, &outlen);
+	if (rc)
+		return rc;
+	if (outlen < MC_CMD_SRIOV_OUT_LEN)
+		return -EIO;
+
+	vf_total = MCDI_DWORD(outbuf, SRIOV_OUT_VF_TOTAL);
+	vi_scale = MCDI_DWORD(outbuf, SRIOV_OUT_VI_SCALE);
+	if (vi_scale > EFX_VI_SCALE_MAX)
+		return -EOPNOTSUPP;
+
+	if (vi_scale_out)
+		*vi_scale_out = vi_scale;
+	if (vf_total_out)
+		*vf_total_out = vf_total;
+
+	return 0;
+}
+
+static void efx_sriov_usrev(struct efx_nic *efx, bool enabled)
+{
+	efx_oword_t reg;
+
+	EFX_POPULATE_OWORD_2(reg,
+			     FRF_CZ_USREV_DIS, enabled ? 0 : 1,
+			     FRF_CZ_DFLT_EVQ, efx->n_channels - 1);
+	efx_writeo(efx, &reg, FR_CZ_USR_EV_CFG);
+}
+
+static int efx_sriov_memcpy(struct efx_nic *efx, struct efx_memcpy_req *req,
+			    unsigned int count)
+{
+	u8 *inbuf, *record;
+	unsigned int used;
+	u32 from_rid, from_hi, from_lo;
+	int rc;
+
+	mmiowb();	/* Order writes with MC reads */
+
+	used = MC_CMD_MEMCPY_IN_LEN(count);
+	if (used > MCDI_CTL_SDU_LEN_MAX)
+		return -ENOSPC;
+
+	/* Allocate room for the largest request */
+	inbuf = kzalloc(MCDI_CTL_SDU_LEN_MAX, GFP_KERNEL);
+	if (inbuf == NULL)
+		return -ENOMEM;
+
+	record = inbuf;
+	MCDI_SET_DWORD(record, MEMCPY_IN_RECORD, count);
+	while (count-- > 0) {
+		MCDI_SET_DWORD(record, MEMCPY_RECORD_TYPEDEF_TO_RID,
+			       req->to_dev->devfn);
+		MCDI_SET_DWORD(record, MEMCPY_RECORD_TYPEDEF_TO_ADDR_LO,
+			       (u32)req->to_addr);
+		MCDI_SET_DWORD(record, MEMCPY_RECORD_TYPEDEF_TO_ADDR_HI,
+			       (u32)(req->to_addr >> 32));
+		if (req->from_dev != NULL) {
+			from_rid = req->from_dev->devfn;
+			from_lo = (u32)req->from_addr;
+			from_hi = (u32)(req->from_addr >> 32);
+		} else {
+			if (used + req->length > MCDI_CTL_SDU_LEN_MAX) {
+				rc = -ENOSPC;
+				goto out;
+			}
+
+			from_rid = MC_CMD_MEMCPY_RECORD_TYPEDEF_RID_INLINE;
+			from_lo = used;
+			from_hi = 0;
+			memcpy(inbuf + used, req->from_buf, req->length);
+			used += req->length;
+		}
+
+		MCDI_SET_DWORD(record, MEMCPY_RECORD_TYPEDEF_FROM_RID, from_rid);
+		MCDI_SET_DWORD(record, MEMCPY_RECORD_TYPEDEF_FROM_ADDR_LO,
+			       from_lo);
+		MCDI_SET_DWORD(record, MEMCPY_RECORD_TYPEDEF_FROM_ADDR_HI,
+			       from_hi);
+		MCDI_SET_DWORD(record, MEMCPY_RECORD_TYPEDEF_LENGTH,
+			       req->length);
+
+		++req;
+		record += MC_CMD_MEMCPY_IN_RECORD_LEN;
+	}
+
+	rc = efx_mcdi_rpc(efx, MC_CMD_MEMCPY, inbuf, used, NULL, 0, NULL);
+out:
+	kfree(inbuf);
+
+	/* If MCDI were not event completed then a rmb() would be required
+	 * here to. But efx_mcdi_rpc() calls wake_up() which provides this.
+	 */
+
+	return rc;
+}
+
+static void efx_sriov_update_vf_status(struct efx_vf *vf)
+{
+	memcpy(&vf->efx->vfdi_status->peers[vf->index + 1],
+	       &vf->addr, sizeof(vf->addr));
+}
+
+static void efx_sriov_push_vf_status(struct efx_vf *vf)
+{
+	struct efx_nic *efx = vf->efx;
+	struct vfdi_status *status = efx->vfdi_status;
+	struct efx_memcpy_req copy[3];
+	unsigned data_offset;
+	efx_qword_t event;
+
+	ASSERT_RTNL();		/* Interlock with efx_vfdi_clear_status_page() */
+
+	memcpy(&status->local, &vf->addr, sizeof(vf->addr));
+	status->generation_end = ++status->generation_start;
+
+	memset(copy, '\0', sizeof(copy));
+	/* Write generation_start */
+	copy[0].from_buf = &status->generation_start;
+	copy[0].to_dev = vf->pci_dev;
+	copy[0].to_addr = vf->status_addr + offsetof(struct vfdi_status,
+						     generation_start);
+	copy[0].length = sizeof(status->generation_start);
+	/* DMA the rest of the structure (excluding the generations). This
+	 * assumes that the non-generation portion of vfdi_status is in
+	 * one chunk starting at the version member. */
+	data_offset = offsetof(struct vfdi_status, version);
+	copy[1].from_dev = efx->pci_dev;
+	copy[1].from_addr = efx->vfdi_status_addr + data_offset;
+	copy[1].to_dev = vf->pci_dev;
+	copy[1].to_addr = vf->status_addr + data_offset;
+	copy[1].length =  status->length - data_offset;
+	/* Write generation_end */
+	copy[2].from_buf = &status->generation_end;
+	copy[2].to_dev =  vf->pci_dev;
+	copy[2].to_addr = vf->status_addr + offsetof(struct vfdi_status,
+						     generation_end);
+	copy[2].length = sizeof(status->generation_start);
+
+	efx_sriov_memcpy(efx, copy, ARRAY_SIZE(copy));
+
+	/* Notify the guest */
+	EFX_POPULATE_QWORD_3(event,
+			     FSF_AZ_EV_CODE, FSE_CZ_EV_CODE_USER_EV,
+			     VFDI_EV_SEQ, (vf->msg_seqno & 0xff),
+			     VFDI_EV_TYPE, VFDI_EV_TYPE_REQ_STATUS);
+	++vf->msg_seqno;
+	efx_generate_event(efx, EFX_VI_BASE + (vf->index << efx->vi_scale),
+			   &event);
+}
+
+static void efx_sriov_push_status(struct efx_nic *efx)
+{
+	unsigned int pos;
+	struct efx_vf *vf;
+
+	ASSERT_RTNL();
+
+	for (pos = 0; pos < efx->vf_count; ++pos) {
+		vf = efx->vf + pos;
+		if (vf->status_addr != 0)
+			efx_sriov_push_vf_status(vf);
+	}
+}
+
+static void efx_sriov_bufs(struct efx_nic *efx, unsigned offset,
+			   u64 *addr, unsigned count)
+{
+	efx_qword_t buf;
+	unsigned pos;
+
+	for (pos = 0; pos < count; ++pos) {
+		EFX_POPULATE_QWORD_3(buf,
+				     FRF_AZ_BUF_ADR_REGION, 0,
+				     FRF_AZ_BUF_ADR_FBUF,
+				     addr ? addr[pos] >> 12 : 0,
+				     FRF_AZ_BUF_OWNER_ID_FBUF, 0);
+		efx_sram_writeq(efx, efx->membase + FR_BZ_BUF_FULL_TBL,
+				&buf, offset + pos);
+	}
+}
+
+static unsigned abs_index(struct efx_vf *vf, unsigned index)
+{
+	return EFX_VI_BASE + (vf->index << vf->efx->vi_scale) + index;
+}
+
+static bool bad_vf_index(struct efx_nic *efx, unsigned index)
+{
+	return (index > (1 << efx->vi_scale));
+}
+
+static bool bad_buf_count(unsigned buf_count, unsigned max_entry_count)
+{
+	unsigned max_buf_count = max_entry_count *
+		sizeof(efx_qword_t) / EFX_BUF_SIZE;
+
+	return ((buf_count & (buf_count - 1)) || buf_count > max_buf_count);
+}
+
+static bool bad_abs_index(struct efx_nic *efx, unsigned abs_index,
+			  struct efx_vf **vf_out, unsigned *rel_index_out)
+{
+	unsigned vf_i;
+
+	if (abs_index < EFX_VI_BASE)
+		return true;
+	vf_i = (abs_index - EFX_VI_BASE) >> efx->vi_scale;
+	if (vf_i >= efx->vf_count)
+		return true;
+
+	if (vf_out)
+		*vf_out = efx->vf + vf_i;
+	if (rel_index_out)
+		*rel_index_out = abs_index & ((1 << efx->vi_scale) - 1);
+	return false;
+}
+
+static int efx_vfdi_init_evq(struct efx_vf *vf)
+{
+	struct efx_nic *efx = vf->efx;
+	struct vfdi_req *req = vf->buf_ptr;
+	unsigned vf_evq = req->u.init_evq.index;
+	unsigned buf_count = req->u.init_evq.buf_count;
+	unsigned abs_evq = abs_index(vf, vf_evq);
+	unsigned buftbl = EFX_BUFTBL_EVQ_BASE(vf, vf_evq);
+	efx_oword_t reg;
+
+	if (bad_vf_index(efx, vf_evq) ||
+	    bad_buf_count(buf_count, EFX_MAX_EVQ_SIZE)) {
+		netif_err(efx, hw, efx->net_dev,
+			  "ERROR: Invalid INIT_EVQ from %s: evq %d bufs %d\n",
+			  pci_name(vf->pci_dev), vf_evq, buf_count);
+		return -EINVAL;
+	}
+
+	
+	efx_sriov_bufs(efx, buftbl, req->u.init_evq.addr, buf_count);
+
+	EFX_POPULATE_OWORD_3(reg,
+			     FRF_CZ_TIMER_Q_EN, 1,
+			     FRF_CZ_HOST_NOTIFY_MODE, 0,
+			     FRF_CZ_TIMER_MODE, FFE_CZ_TIMER_MODE_DIS);
+	efx_writeo_table(efx, &reg, FR_BZ_TIMER_TBL, abs_evq);
+	EFX_POPULATE_OWORD_3(reg,
+			     FRF_AZ_EVQ_EN, 1,
+			     FRF_AZ_EVQ_SIZE, __ffs(buf_count),
+			     FRF_AZ_EVQ_BUF_BASE_ID, buftbl);
+	efx_writeo_table(efx, &reg, FR_BZ_EVQ_PTR_TBL, abs_evq);
+
+	return 0;
+}
+
+static int efx_vfdi_init_rxq(struct efx_vf *vf)
+{
+	struct efx_nic *efx = vf->efx;
+	struct vfdi_req *req = vf->buf_ptr;
+	unsigned vf_rxq = req->u.init_rxq.index;
+	unsigned vf_evq = req->u.init_rxq.evq;
+	unsigned buf_count = req->u.init_rxq.buf_count;
+	unsigned buftbl = EFX_BUFTBL_RXQ_BASE(vf, vf_rxq);
+	unsigned label;
+	efx_oword_t reg;
+
+	if (bad_vf_index(efx, vf_evq) || bad_vf_index(efx, vf_rxq) ||
+	    bad_buf_count(buf_count, EFX_MAX_DMAQ_SIZE)) {
+		netif_err(efx, hw, efx->net_dev,
+			  "ERROR: Invalid INIT_RXQ from %s: rxq %d evq %d "
+			  "buf_count %d\n", pci_name(vf->pci_dev), vf_rxq,
+			  vf_evq, buf_count);
+		return -EINVAL;
+	}
+	if (__test_and_set_bit(req->u.init_rxq.index, vf->rxq_mask))
+		++vf->rxq_count;
+	efx_sriov_bufs(efx, buftbl, req->u.init_rxq.addr, buf_count);
+
+	label = req->u.init_rxq.label & EFX_FIELD_MASK(FRF_AZ_RX_DESCQ_LABEL);
+	EFX_POPULATE_OWORD_5(reg,
+			     FRF_AZ_RX_DESCQ_BUF_BASE_ID, buftbl,
+			     FRF_AZ_RX_DESCQ_EVQ_ID, abs_index(vf, vf_evq),
+			     FRF_AZ_RX_DESCQ_LABEL, label,
+			     FRF_AZ_RX_DESCQ_SIZE, __ffs(buf_count),
+			     FRF_AZ_RX_DESCQ_EN, 1);
+	efx_writeo_table(efx, &reg, FR_BZ_RX_DESC_PTR_TBL,
+			 abs_index(vf, vf_rxq));
+
+	return 0;
+}
+
+static int efx_vfdi_init_txq(struct efx_vf *vf)
+{
+	struct efx_nic *efx = vf->efx;
+	struct vfdi_req *req = vf->buf_ptr;
+	unsigned vf_txq = req->u.init_txq.index;
+	unsigned vf_evq = req->u.init_txq.evq;
+	unsigned buf_count = req->u.init_txq.buf_count;
+	unsigned buftbl = EFX_BUFTBL_TXQ_BASE(vf, vf_txq);
+	unsigned label;
+	efx_oword_t reg;
+
+	if (bad_vf_index(efx, vf_evq) || bad_vf_index(efx, vf_txq) ||
+	    bad_buf_count(buf_count, EFX_MAX_DMAQ_SIZE)) {
+		netif_err(efx, hw, efx->net_dev,
+			  "ERROR: Invalid INIT_TXQ from %s: txq %d evq %d "
+			  "buf_count %d\n", pci_name(vf->pci_dev), vf_txq,
+			  vf_evq, buf_count);
+		return -EINVAL;
+	}
+	if (__test_and_set_bit(req->u.init_txq.index, vf->txq_mask))
+		++vf->txq_count;
+	efx_sriov_bufs(efx, buftbl, req->u.init_txq.addr, buf_count);
+
+	label = req->u.init_txq.label & EFX_FIELD_MASK(FRF_AZ_TX_DESCQ_LABEL);
+	EFX_POPULATE_OWORD_6(reg,
+			     FRF_AZ_TX_DESCQ_EN, 1,
+			     FRF_AZ_TX_DESCQ_BUF_BASE_ID, buftbl,
+			     FRF_AZ_TX_DESCQ_EVQ_ID, abs_index(vf, vf_evq),
+			     FRF_AZ_TX_DESCQ_LABEL, label,
+			     FRF_AZ_TX_DESCQ_SIZE, __ffs(buf_count),
+			     FRF_BZ_TX_NON_IP_DROP_DIS, 1);
+	efx_writeo_table(efx, &reg, FR_BZ_TX_DESC_PTR_TBL,
+			 abs_index(vf, vf_txq));
+
+	return 0;
+}
+
+/* Returns true when efx_vfdi_fini_all_queues should wake */
+static bool efx_vfdi_flush_wake(struct efx_vf *vf)
+{
+	return ((!vf->txq_count && !vf->rxq_count) ||
+		atomic_read(&vf->rxq_retry_count));
+}
+
+static void efx_vfdi_flush_clear(struct efx_vf *vf)
+{
+	memset(vf->txq_mask, 0, sizeof(vf->txq_mask));
+	vf->txq_count = 0;
+	memset(vf->rxq_mask, 0, sizeof(vf->rxq_mask));
+	vf->rxq_count = 0;
+	memset(vf->rxq_retry_mask, 0, sizeof(vf->rxq_retry_mask));
+	atomic_set(&vf->rxq_retry_count, 0);
+}
+
+static int efx_vfdi_fini_all_queues(struct efx_vf *vf)
+{
+	struct efx_nic *efx = vf->efx;
+	efx_oword_t reg;
+	unsigned count = (1 << efx->vi_scale);
+	unsigned vf_offset = EFX_VI_BASE + (vf->index << efx->vi_scale);
+	unsigned timeout = msecs_to_jiffies(1000); /* 1s */
+	unsigned index, rxqs_count;
+	__le32 *rxqs;
+	int rc;
+
+	rxqs = kmalloc(count * sizeof(*rxqs), GFP_KERNEL);
+	if (rxqs == NULL)
+		return -ENOMEM;
+
+	/* Flush all the initialized queues */
+	rxqs_count = 0;
+	for (index = 0; index < count; ++index) {
+		if (test_bit(index, vf->txq_mask)) {
+			EFX_POPULATE_OWORD_2(reg,
+					     FRF_AZ_TX_FLUSH_DESCQ_CMD, 1,
+					     FRF_AZ_TX_FLUSH_DESCQ,
+					     vf_offset + index);
+			efx_writeo(efx, &reg, FR_AZ_TX_FLUSH_DESCQ);
+		}
+		if (test_bit(index, vf->rxq_mask))
+			rxqs[rxqs_count++] = cpu_to_le32(vf_offset + index);
+	}
+
+	atomic_set(&vf->rxq_retry_count, 0);
+	while (timeout && (vf->rxq_count || vf->txq_count)) {
+		rc = efx_mcdi_rpc(efx, MC_CMD_FLUSH_RX_QUEUES, (u8 *)rxqs,
+				  rxqs_count * sizeof(*rxqs), NULL, 0, NULL);
+		WARN_ON(rc > 0);
+
+		timeout = wait_event_timeout(vf->wq, efx_vfdi_flush_wake(vf),
+					     timeout);
+		rxqs_count = 0;
+		for (index = 0; index < count; ++index) {
+			if (test_and_clear_bit(index, vf->rxq_retry_mask)) {
+				atomic_dec(&vf->rxq_retry_count);
+				rxqs[rxqs_count++] =
+					cpu_to_le32(vf_offset + index);
+			}
+		}
+	}
+
+	/* Irrespective of success/failure, fini the queues */
+	EFX_ZERO_OWORD(reg);
+	for (index = 0; index < count; ++index) {
+		efx_writeo_table(efx, &reg, FR_BZ_RX_DESC_PTR_TBL,
+				 vf_offset + index);
+		efx_writeo_table(efx, &reg, FR_BZ_TX_DESC_PTR_TBL,
+				 vf_offset + index);
+		efx_writeo_table(efx, &reg, FR_BZ_EVQ_PTR_TBL,
+				 vf_offset + index);
+		efx_writeo_table(efx, &reg, FR_BZ_TIMER_TBL,
+				 vf_offset + index);
+	}
+	efx_sriov_bufs(efx, vf->buftbl_base, NULL,
+		       EFX_BUFTBL_BLOCK_SIZE << efx->vi_scale);
+	kfree(rxqs);
+	efx_vfdi_flush_clear(vf);
+
+	return (timeout ? 0 : -ETIMEDOUT);
+}
+
+static int efx_vfdi_insert_filter(struct efx_vf *vf)
+{
+	struct efx_nic *efx = vf->efx;
+	struct vfdi_req *req = vf->buf_ptr;
+	unsigned vf_rxq = req->u.mac_filter.rxq;
+	struct efx_filter_spec filter;
+	u16 vlan;
+	int rc;
+
+	if (bad_vf_index(efx, vf_rxq) || vf->filter_idx != -1) {
+#if !defined(EFX_USE_KCOMPAT) || !defined(EFX_USE_PRINT_MAC)
+		netif_err(efx, hw, efx->net_dev,
+			  "ERROR: Invalid INSERT_FILTER from %s: rxq %d "
+			  "flags 0x%x\n", pci_name(vf->pci_dev), vf_rxq,
+			  req->u.mac_filter.flags);
+#else
+		netif_err(efx, hw, efx->net_dev,
+			  "ERROR: Invalid INSERT_FILTER from %s: rxq %d "
+			  "flags 0x%x\n", pci_name(vf->pci_dev), vf_rxq,
+			  req->u.mac_filter.flags);
+#endif
+		return -EINVAL;
+	}
+
+	memset(&filter, 0, sizeof(filter));
+	vlan = ntohs(vf->addr.tci) & VLAN_VID_MASK;
+	if (vlan)
+		efx_filter_set_rx_mac_full(&filter, vlan, vf->addr.mac_addr);
+	else
+		efx_filter_set_rx_mac_wild(&filter, vf->addr.mac_addr);
+	if (req->u.mac_filter.flags & MAC_FILTER_FLAG_RSS)
+		filter.flags |= EFX_FILTER_FLAG_RX_RSS;
+	if (req->u.mac_filter.flags & MAC_FILTER_FLAG_SCATTER)
+		filter.flags |= EFX_FILTER_FLAG_RX_SCATTER;
+	filter.dmaq_id = abs_index(vf, vf_rxq);
+	rc = efx_filter_insert_filter(efx, &filter, true);
+	if (rc > 0) {
+		vf->filter_idx = rc;
+		rc = 0;
+	}
+
+	return rc;
+}
+
+static int efx_vfdi_remove_all_filters(struct efx_vf *vf)
+{
+	struct efx_nic *efx = vf->efx;
+
+	if (vf->filter_idx != -1) {
+		efx_filter_remove_index(efx, EFX_FILTER_TABLE_RX_MAC,
+					vf->filter_idx);
+		vf->filter_idx = -1;
+	}
+
+	return 0;
+}
+
+static int efx_vfdi_set_status_page(struct efx_vf *vf)
+{
+	struct efx_nic *efx = vf->efx;
+	struct vfdi_req *req = vf->buf_ptr;
+
+	if (!req->u.set_status_page.dma_addr) {
+		netif_err(efx, hw, efx->net_dev,
+			  "ERROR: Invalid SET_STATUS_PAGE from %s\n",
+			  pci_name(vf->pci_dev));
+		return -EINVAL;
+	}
+
+	rtnl_lock();
+	vf->status_addr = req->u.set_status_page.dma_addr;
+	efx_sriov_update_vf_status(vf);
+	efx_sriov_push_vf_status(vf);
+	rtnl_unlock();
+
+	return 0;
+}
+
+static int efx_vfdi_clear_status_page(struct efx_vf *vf)
+{
+	rtnl_lock();
+	vf->status_addr = 0;
+	rtnl_unlock();
+
+	return 0;
+}
+
+typedef int (*efx_vfdi_op_t)(struct efx_vf *vf);
+
+static const efx_vfdi_op_t vfdi_ops[VFDI_LIMIT] = {
+	[VFDI_INIT_EVQ] = efx_vfdi_init_evq,
+	[VFDI_INIT_TXQ] = efx_vfdi_init_txq,
+	[VFDI_INIT_RXQ] = efx_vfdi_init_rxq,
+	[VFDI_FINI_ALL_QUEUES] = efx_vfdi_fini_all_queues,
+	[VFDI_INSERT_FILTER] = efx_vfdi_insert_filter,
+	[VFDI_REMOVE_ALL_FILTERS] = efx_vfdi_remove_all_filters,
+	[VFDI_SET_STATUS_PAGE] = efx_vfdi_set_status_page,
+	[VFDI_CLEAR_STATUS_PAGE] = efx_vfdi_clear_status_page,
+};
+
+static void efx_sriov_vfdi(struct work_struct *work)
+{
+	struct efx_vf *vf = container_of(work, struct efx_vf, req);
+	struct efx_nic *efx = vf->efx;
+	struct vfdi_req *req = vf->buf_ptr;
+	struct efx_memcpy_req copy[2];
+	int rc;
+
+	/* Copy this page into the local address space */
+	memset(copy, '\0', sizeof(copy));
+	copy[0].from_dev = vf->pci_dev;
+	copy[0].from_addr = vf->req_addr;
+	copy[0].to_dev = efx->pci_dev;
+	copy[0].to_addr = vf->buf_addr;
+	copy[0].length = PAGE_SIZE;
+	rc = efx_sriov_memcpy(efx, copy, 1);
+	if (rc) {
+		/* If we can't get the request, we can't reply to the caller */
+		netif_err(efx, hw, efx->net_dev,
+			  "ERROR: Unable to fetch VFDI request from %s rc %d\n",
+			  pci_name(vf->pci_dev), rc);
+		vf->busy = false;
+		return;
+	}
+
+	if (req->op < VFDI_LIMIT && vfdi_ops[req->op] != NULL) {
+		rc = vfdi_ops[req->op](vf);
+		if (rc == 0) {
+			netif_info(efx, hw, efx->net_dev,
+				   "vfdi request %d from %s ok\n",
+				   req->op, pci_name(vf->pci_dev));
+		}
+	} else {
+		netif_err(efx, hw, efx->net_dev,
+			  "ERROR: Unrecognised request %d from VF %s addr "
+			  "%llx\n", req->op, pci_name(vf->pci_dev),
+			  (unsigned long long)vf->req_addr);
+		rc = -EINVAL;
+	}
+
+	/* Allow subsequent VF requests */
+	vf->busy = false;
+	smp_wmb();
+
+	/* Respond to the request */
+	req->rc = rc;
+	req->op = VFDI_RESPONSE;
+
+	memset(copy, '\0', sizeof(copy));
+	copy[0].from_buf = &req->rc;
+	copy[0].to_dev = vf->pci_dev;
+	copy[0].to_addr = vf->req_addr + offsetof(struct vfdi_req, rc);
+	copy[0].length = sizeof(req->rc);
+	copy[1].from_buf = &req->op;
+	copy[1].to_dev = vf->pci_dev;
+	copy[1].to_addr = vf->req_addr + offsetof(struct vfdi_req, op);
+	copy[1].length = sizeof(req->op);
+
+	(void) efx_sriov_memcpy(efx, copy, ARRAY_SIZE(copy));
+}
+
+void efx_sriov_probe(struct efx_nic *efx)
+{
+	unsigned vf_count, available;
+
+	if (efx->interrupt_mode != EFX_INT_MODE_MSIX)
+		return;
+
+	if (!efx_sriov_cmd(efx, false, &efx->vi_scale, &vf_count)) {
+		available = min_t(unsigned, EFX_VF_COUNT_MAX,
+				  (1024 - EFX_VI_BASE) >> efx->vi_scale);
+		efx->vf_count = min(available, vf_count);
+ 	}
+}
+
+#ifdef EFX_NOT_UPSTREAM
+
+static ssize_t show_mac_addr(struct device *dev, struct device_attribute *attr,
+			     char *buf)
+{
+	struct efx_vf *vf = container_of(attr, struct efx_vf, dev_attr_mac_addr);
+	DECLARE_MAC_BUF(macbuf);
+
+	return sprintf(buf, "%s", print_mac(macbuf, vf->addr.mac_addr));
+}
+
+static ssize_t set_mac_addr(struct device *dev, struct device_attribute *attr,
+			    const char *buf, size_t count)
+{
+	struct efx_vf *vf = container_of(attr, struct efx_vf, dev_attr_mac_addr);
+	struct efx_nic *efx = vf->efx;
+	unsigned int pos;
+	int v[6];
+	u8 mac_addr[6];
+
+	if (sscanf(buf, "%02x:%02x:%02x:%02x:%02x:%02x",
+		   v + 0, v + 1, v + 2,
+		   v + 3, v + 4, v + 5) != 6)
+		return -EINVAL;
+	for (pos = 0; pos < ETH_ALEN; ++pos)
+		mac_addr[pos] = (u8)v[pos];
+
+	if (!is_valid_ether_addr(mac_addr))
+		return -EINVAL;
+	if (!memcmp(mac_addr, efx->net_dev->dev_addr, ETH_ALEN))
+		return -EINVAL;
+
+	rtnl_lock();
+	memcpy(vf->addr.mac_addr, mac_addr, ETH_ALEN);
+	efx_sriov_update_vf_status(vf);
+	efx_sriov_push_status(efx);
+	rtnl_unlock();
+
+	return count;
+}
+
+static DEVICE_ATTR(mac_addr, 0644, show_mac_addr, set_mac_addr);
+
+static ssize_t show_tci(struct device *dev, struct device_attribute *attr,
+			char *buf)
+{
+	struct efx_vf *vf = container_of(attr, struct efx_vf, dev_attr_tci);
+
+	return sprintf(buf, "0x%04x", ntohs(vf->addr.tci));
+}
+
+static ssize_t set_tci(struct device *dev, struct device_attribute *attr,
+		       const char *buf, size_t count)
+{
+	struct efx_vf *vf = container_of(attr, struct efx_vf, dev_attr_tci);
+	char *end;
+	__le16 tci;
+
+	tci = simple_strtoul(buf, &end, 0x10);
+	if (*end)
+		return -EINVAL;
+
+	rtnl_lock();
+	vf->addr.tci = htons(tci);
+	efx_sriov_update_vf_status(vf);
+	efx_sriov_push_status(vf->efx);
+	rtnl_unlock();
+
+	return count;
+}
+
+static DEVICE_ATTR(tci, 0644, show_tci, set_tci);
+
+#endif
+
+static void efx_sriov_vfs_fini(struct efx_nic *efx)
+{
+	struct efx_vf *vf;
+	unsigned int pos;
+
+	for (pos = 0; pos < efx->vf_count; ++pos) {
+		vf = efx->vf + pos;
+
+		if (vf->buf_ptr) {
+			dma_free_coherent(&efx->pci_dev->dev, PAGE_SIZE,
+					  vf->buf_ptr, vf->buf_addr);
+			vf->buf_ptr = NULL;
+		}
+		if (vf->pci_dev) {
+#ifdef EFX_NOT_UPSTREAM
+			device_remove_file(&vf->pci_dev->dev,
+					   &vf->dev_attr_tci);
+			device_remove_file(&vf->pci_dev->dev,
+					   &vf->dev_attr_mac_addr);
+#endif
+			pci_dev_put(vf->pci_dev);
+			vf->pci_dev = NULL;
+		}
+	}
+
+	kfree(efx->vf);
+}
+
+static int efx_sriov_vfs_init(struct efx_nic *efx)
+{
+	struct pci_dev *pci_dev = efx->pci_dev;
+	unsigned index, devfn, sriov;
+	u16 offset, stride;
+	struct efx_vf *vf;
+	int rc;
+
+	sriov = pci_find_ext_capability(pci_dev, PCI_EXT_CAP_ID_SRIOV);
+	if (!sriov)
+		return -ENOENT;
+
+	efx->vf = kzalloc(sizeof(struct efx_vf) * efx->vf_count, GFP_KERNEL);
+	if (!efx->vf)
+		return -ENOMEM;
+
+	pci_read_config_word(pci_dev, sriov + PCI_SRIOV_VF_OFFSET, &offset);
+	pci_read_config_word(pci_dev, sriov + PCI_SRIOV_VF_STRIDE, &stride);
+
+	devfn = pci_dev->devfn + offset;
+	for (index = 0; index < efx->vf_count; ++index) {
+		vf = efx->vf + index;
+		vf->efx = efx;
+		vf->index = index;
+		vf->filter_idx = -1;
+		INIT_WORK(&vf->req, efx_sriov_vfdi);
+		init_waitqueue_head(&vf->wq);
+
+		/* Reserve buffer entries */
+		vf->buftbl_base = efx->resources.buffer_table_min;
+		efx->resources.buffer_table_min +=  EFX_BUFTBL_BLOCK_SIZE;
+
+		vf->pci_dev = pci_get_slot(efx->pci_dev->bus, devfn);
+		if (!vf->pci_dev) {
+			netif_err(efx, probe, efx->net_dev,
+				  "ERROR: unable to find VF devfn 0x%x\n", devfn);
+			rc = -ENOENT;
+			goto fail;
+		}
+
+#ifdef EFX_NOT_UPSTREAM
+		/* Initialize sysfs access */
+		memcpy(&vf->dev_attr_mac_addr, &dev_attr_mac_addr,
+		       sizeof(struct device_attribute));
+		rc = device_create_file(&vf->pci_dev->dev,
+					&vf->dev_attr_mac_addr);
+		if (rc) {
+			pci_dev_put(vf->pci_dev);
+			vf->pci_dev = NULL;
+			goto fail;
+		}
+		memcpy(&vf->dev_attr_tci, &dev_attr_tci,
+		       sizeof(struct device_attribute));
+		rc = device_create_file(&vf->pci_dev->dev,
+					&vf->dev_attr_tci);
+		if (rc) {
+			device_remove_file(&vf->pci_dev->dev,
+					   &vf->dev_attr_mac_addr);
+			pci_dev_put(vf->pci_dev);
+			vf->pci_dev = NULL;
+			goto fail;
+		}
+#endif
+
+		/* Page for MC_CMD_MEMCPY */
+		vf->buf_ptr = dma_alloc_coherent(&efx->pci_dev->dev, PAGE_SIZE,
+						 &vf->buf_addr, GFP_KERNEL);
+		if (!vf->buf_ptr) {
+			rc = -ENOMEM;
+			goto fail;
+		}
+
+		devfn += stride;
+	}
+
+	return 0;
+
+fail:
+	efx_sriov_vfs_fini(efx);
+	return rc;
+}
+
+int efx_sriov_init(struct efx_nic *efx)
+{
+	struct net_device *net_dev = efx->net_dev;
+	int rc;
+
+	/* Ensure there's room for vf_channel */
+	BUILD_BUG_ON(EFX_MAX_CHANNELS + 1 >= EFX_VI_BASE);
+	/* Ensure that VI_BASE is aligned on VI_SCALE */
+	BUILD_BUG_ON(EFX_VI_BASE & ((1 << EFX_VI_SCALE_MAX) - 1));
+
+	rc = efx_sriov_cmd(efx, true, NULL, NULL);
+	if (rc)
+		goto fail1;
+ 
+	efx->vfdi_status = dma_alloc_coherent(
+		&efx->pci_dev->dev, sizeof(struct vfdi_status),
+		&efx->vfdi_status_addr, GFP_KERNEL);
+	if (!efx->vfdi_status)  {
+		rc = -ENOMEM;
+		goto fail2;
+	}
+	efx->vfdi_status->version = 1;
+	efx->vfdi_status->length = sizeof(*efx->vfdi_status);
+	efx->vfdi_status->vi_scale = efx->vi_scale;
+	memcpy(efx->vfdi_status->peers[0].mac_addr,
+	       net_dev->dev_addr, ETH_ALEN);
+
+	/* At this point the net_device is down, so this is safe */
+	efx_sriov_usrev(efx, true);
+
+	rc = pci_enable_sriov(efx->pci_dev, efx->vf_count);
+	if (rc)
+		goto fail3;
+
+	rc = efx_sriov_vfs_init(efx);
+	if (rc)
+		goto fail4;
+
+	netif_info(efx, probe, net_dev,
+		   "enabled SR-IOV for %d VFs, %d VI per VF\n",
+		   efx->vf_count, 1 << efx->vi_scale);
+	return 0;
+
+fail4:
+	pci_disable_sriov(efx->pci_dev);
+fail3:
+	efx_sriov_usrev(efx, false);
+	dma_free_coherent(&efx->pci_dev->dev, sizeof(struct vfdi_status),
+ 			  efx->vfdi_status, efx->vfdi_status_addr);
+fail2:
+	efx_sriov_cmd(efx, false, NULL, NULL);
+fail1:
+	return rc;
+}
+
+void efx_sriov_fini(struct efx_nic *efx)
+{
+	struct efx_vf *vf;
+	unsigned int pos;
+
+	if (efx->vf_count == 0)
+		return;
+
+	for (pos = 0; pos < efx->vf_count; ++pos) {
+		vf = efx->vf + pos;
+#if !defined(EFX_USE_KCOMPAT) || defined(EFX_USE_CANCEL_WORK_SYNC)
+		cancel_work_sync(&vf->req);
+#else
+		/* The workqueue has already been flushed by
+		 * efx_flush_all() after disabling NAPI. */
+#endif
+	}
+
+	efx_sriov_vfs_fini(efx);
+	pci_disable_sriov(efx->pci_dev);
+	efx_sriov_usrev(efx, false);
+	dma_free_coherent(&efx->pci_dev->dev, sizeof(struct vfdi_status),
+ 			  efx->vfdi_status, efx->vfdi_status_addr);
+	efx_sriov_cmd(efx, false, NULL, NULL);
+	efx->vf_count = 0;
+}
+
+void efx_sriov_event(struct efx_channel *channel, efx_qword_t *event)
+{
+	struct efx_nic *efx = channel->efx;
+	struct efx_vf *vf;
+	unsigned qid, seq, type, data;
+
+	qid = EFX_QWORD_FIELD(*event, FSF_CZ_USER_QID);
+
+	/* USR_EV_REG_VALUE is dword0, so access the VFDI_EV fields directly */
+	BUILD_BUG_ON(FSF_CZ_USER_EV_REG_VALUE_LBN != 0);
+	seq = EFX_QWORD_FIELD(*event, VFDI_EV_SEQ);
+	type = EFX_QWORD_FIELD(*event, VFDI_EV_TYPE);
+	data = EFX_QWORD_FIELD(*event, VFDI_EV_DATA);
+
+	netif_vdbg(efx, hw, efx->net_dev,
+		   "USR_EV event from qid %d seq 0x%x type %d data 0x%x\n",
+		   qid, seq, type, data);
+
+	if (bad_abs_index(efx, qid, &vf, NULL))
+		return;
+	if (vf->busy)
+		goto error;
+
+	if (type == VFDI_EV_TYPE_REQ_WORD0) {
+		/* Resynchronise */
+		vf->req_type = VFDI_EV_TYPE_REQ_WORD0;
+		vf->req_seqno = seq + 1;
+		vf->req_addr = 0;
+	} else if (seq != (vf->req_seqno++ & 0xff) || type != vf->req_type)
+		goto error;
+
+	switch (vf->req_type) {
+	case VFDI_EV_TYPE_REQ_WORD0:
+	case VFDI_EV_TYPE_REQ_WORD1:
+	case VFDI_EV_TYPE_REQ_WORD2:
+		vf->req_addr |= (u64)data << (vf->req_type << 4);
+		++vf->req_type;
+		return;
+
+	case VFDI_EV_TYPE_REQ_WORD3:
+		vf->req_addr |= (u64)data << 48;
+		vf->req_type = VFDI_EV_TYPE_REQ_WORD0;
+		vf->busy = true;
+#if !defined(EFX_USE_KCOMPAT) || defined(EFX_USE_CANCEL_WORK_SYNC)
+		schedule_work(&vf->req);
+#else
+		queue_work(efx->workqueue, &vf->req);
+#endif
+		return;
+	}
+
+error:
+	if (net_ratelimit())
+		netif_err(efx, hw, efx->net_dev,
+			  "ERROR: Screaming VFDI request from %s\n",
+			  pci_name(vf->pci_dev));
+	/* Reset the request and sequence number */
+	vf->req_type = VFDI_EV_TYPE_REQ_WORD0;
+	vf->req_seqno = seq + 1;
+}
+
+void efx_sriov_flr(struct efx_nic *efx, unsigned vf_i)
+{
+	struct efx_vf *vf;
+
+	if (vf_i > efx->vf_count)
+		return;
+	vf = efx->vf + vf_i;
+
+	vf->status_addr = 0;
+	efx_vfdi_remove_all_filters(vf);
+	efx_vfdi_flush_clear(vf);
+}
+
+void efx_sriov_mac_address_changed(struct efx_nic *efx)
+{
+	memcpy(efx->vfdi_status->peers[0].mac_addr,
+	       efx->net_dev->dev_addr, ETH_ALEN);
+	efx_sriov_push_status(efx);
+}
+
+void efx_sriov_tx_flush_done(struct efx_nic *efx, efx_qword_t *event)
+{
+	struct efx_vf *vf;
+	unsigned queue, qid;
+
+	queue = EFX_QWORD_FIELD(*event,  FSF_AZ_DRIVER_EV_SUBDATA);
+	if (bad_abs_index(efx, queue, &vf, &qid))
+		return;
+
+	__clear_bit(qid, vf->txq_mask);
+	--vf->txq_count;
+
+	if (efx_vfdi_flush_wake(vf))
+		wake_up(&vf->wq);
+}
+
+void efx_sriov_rx_flush_done(struct efx_nic *efx, efx_qword_t *event)
+{
+	struct efx_vf *vf;
+	unsigned ev_failed, queue, qid;
+
+	queue = EFX_QWORD_FIELD(*event, FSF_AZ_DRIVER_EV_RX_DESCQ_ID);
+	ev_failed = EFX_QWORD_FIELD(*event,
+				    FSF_AZ_DRIVER_EV_RX_FLUSH_FAIL);
+	if (bad_abs_index(efx, queue, &vf, &qid))
+		return;
+
+	if (ev_failed) {
+		set_bit(qid, vf->rxq_retry_mask);
+		atomic_inc(&vf->rxq_retry_count);
+	} else {
+		__clear_bit(qid, vf->rxq_mask);
+		--vf->rxq_count;
+	}
+	if (efx_vfdi_flush_wake(vf))
+		wake_up(&vf->wq);
+}
+
+#if !defined(EFX_USE_KCOMPAT) || defined(EFX_HAVE_NDO_SET_VF_MAC)
+
+int efx_sriov_set_vf_mac(struct net_device *net_dev, int vf_i, u8 *mac)
+{
+	struct efx_nic *efx = netdev_priv(net_dev);
+	struct efx_vf *vf;
+
+	if (!is_valid_ether_addr(mac) || (vf_i >= efx->vf_count))
+                return -EINVAL;
+	vf = efx->vf + vf_i;
+
+	if (!netif_running(net_dev))
+		netif_warn(efx, hw, net_dev,
+			   "WARNING: The PF device must be up before "
+			   "you can start to use VF %s",
+			   pci_name(vf->pci_dev));
+
+	memcpy(vf->addr.mac_addr, mac, ETH_ALEN);
+	efx_sriov_update_vf_status(vf);
+	efx_sriov_push_status(efx);
+
+	return 0;
+}
+
+int efx_sriov_set_vf_vlan(struct net_device *net_dev, int vf_i,
+			  u16 vlan, u8 qos)
+{
+	struct efx_nic *efx = netdev_priv(net_dev);
+	struct efx_vf *vf;
+	u16 tci;
+
+	if (vf_i >= efx->vf_count)
+                return -EINVAL;
+	vf = efx->vf + vf_i;
+
+	if (!netif_running(net_dev))
+		netif_warn(efx, hw, net_dev,
+			   "WARNING: The PF device must be up before "
+			   "you can start to use VF %s",
+			   pci_name(vf->pci_dev));
+
+	tci = (vlan & VLAN_VID_MASK) | ((qos & 0x7) << VLAN_PRIO_SHIFT);
+	vf->addr.tci = htons(tci);
+	efx_sriov_update_vf_status(vf);
+	efx_sriov_push_status(efx);
+
+	return 0;
+}
+
+int efx_sriov_get_vf_config(struct net_device *net_dev, int vf_i,
+			    struct ifla_vf_info *ivi)
+{
+	struct efx_nic *efx = netdev_priv(net_dev);
+	struct efx_vf *vf;
+	u16 tci;
+
+	if (vf_i >= efx->vf_count)
+                return -EINVAL;
+	vf = efx->vf + vf_i;
+
+	ivi->vf = vf_i;
+	memcpy(ivi->mac, vf->addr.mac_addr, ETH_ALEN);
+	ivi->tx_rate = 0;
+	tci = ntohs(vf->addr.tci);
+	ivi->vlan = tci & VLAN_VID_MASK;
+	ivi->qos = (tci >> VLAN_PRIO_SHIFT) & 0x7;
+
+	return 0;
+}
+
+#endif
+
+#endif
diff -r 5b3d4d3c1166 drivers/net/sfc/tenxpress.c
--- a/drivers/net/sfc/tenxpress.c	Fri Nov 05 15:20:28 2010 +0000
+++ b/drivers/net/sfc/tenxpress.c	Tue Nov 09 10:06:27 2010 +0000
@@ -1,6 +1,6 @@
 /****************************************************************************
  * Driver for Solarflare Solarstorm network controllers and boards
- * Copyright 2007-2008 Solarflare Communications Inc.
+ * Copyright 2007-2009 Solarflare Communications Inc.
  *
  * This program is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 as published
@@ -8,21 +8,21 @@
  */
 
 #include <linux/delay.h>
+#ifndef EFX_USE_KCOMPAT
 #include <linux/rtnetlink.h>
+#endif
 #include <linux/seq_file.h>
+#include <linux/slab.h>
 #include "efx.h"
+#include "debugfs.h"
 #include "mdio_10g.h"
-#include "falcon.h"
+#include "nic.h"
 #include "phy.h"
-#include "falcon_hwdefs.h"
-#include "boards.h"
+#include "regs.h"
 #include "workarounds.h"
 #include "selftest.h"
 
-/* We expect these MMDs to be in the package.  SFT9001 also has a
- * clause 22 extension MMD, but since it doesn't have all the generic
- * MMD registers it is pointless to include it here.
- */
+/* We expect these MMDs to be in the package. */
 #define TENXPRESS_REQUIRED_DEVS (MDIO_DEVS_PMAPMD	| \
 				 MDIO_DEVS_PCS		| \
 				 MDIO_DEVS_PHYXS	| \
@@ -31,13 +31,7 @@
 #define SFX7101_LOOPBACKS ((1 << LOOPBACK_PHYXS) |	\
 			   (1 << LOOPBACK_PCS) |	\
 			   (1 << LOOPBACK_PMAPMD) |	\
-			   (1 << LOOPBACK_NETWORK))
-
-#define SFT9001_LOOPBACKS ((1 << LOOPBACK_GPHY) |	\
-			   (1 << LOOPBACK_PHYXS) |	\
-			   (1 << LOOPBACK_PCS) |	\
-			   (1 << LOOPBACK_PMAPMD) |	\
-			   (1 << LOOPBACK_NETWORK))
+			   (1 << LOOPBACK_PHYXS_WS))
 
 /* We complain if we fail to see the link partner as 10G capable this many
  * times in a row (must be > 1 as sampling the autoneg. registers is racy)
@@ -50,9 +44,8 @@
 #define PMA_PMD_EXT_GMII_EN_WIDTH 1
 #define PMA_PMD_EXT_CLK_OUT_LBN	2
 #define PMA_PMD_EXT_CLK_OUT_WIDTH 1
-#define PMA_PMD_LNPGA_POWERDOWN_LBN 8	/* SFX7101 only */
+#define PMA_PMD_LNPGA_POWERDOWN_LBN 8
 #define PMA_PMD_LNPGA_POWERDOWN_WIDTH 1
-#define PMA_PMD_EXT_CLK312_LBN	8	/* SFT9001 only */
 #define PMA_PMD_EXT_CLK312_WIDTH 1
 #define PMA_PMD_EXT_LPOWER_LBN  12
 #define PMA_PMD_EXT_LPOWER_WIDTH 1
@@ -84,9 +77,14 @@
 #define PMA_PMD_LED_FLASH	(3)
 #define PMA_PMD_LED_MASK	3
 /* All LEDs under hardware control */
-#define PMA_PMD_LED_FULL_AUTO	(0)
 /* Green and Amber under hardware control, Red off */
-#define PMA_PMD_LED_DEFAULT	(PMA_PMD_LED_OFF << PMA_PMD_LED_RX_LBN)
+#define SFX7101_PMA_PMD_LED_DEFAULT (PMA_PMD_LED_OFF << PMA_PMD_LED_RX_LBN)
+
+/* Identifier registers: each identifier has 4 part number and 2 revision
+ * registers starting at one of these addresses */
+#define PMA_PMD_AFE_ID_REG      49174
+#define PMA_PMD_DSP_ID_REG      49180
+#define PMA_PMD_FIRMWARE_ID_REG 49186
 
 #define PMA_PMD_SPEED_ENABLE_REG 49192
 #define PMA_PMD_100TX_ADV_LBN    1
@@ -98,31 +96,7 @@
 #define PMA_PMD_SPEED_LBN        4
 #define PMA_PMD_SPEED_WIDTH      4
 
-/* Cable diagnostics - SFT9001 only */
-#define PMA_PMD_CDIAG_CTRL_REG  49213
-#define CDIAG_CTRL_IMMED_LBN    15
-#define CDIAG_CTRL_BRK_LINK_LBN 12
-#define CDIAG_CTRL_IN_PROG_LBN  11
-#define CDIAG_CTRL_LEN_UNIT_LBN 10
-#define CDIAG_CTRL_LEN_METRES   1
-#define PMA_PMD_CDIAG_RES_REG   49174
-#define CDIAG_RES_A_LBN         12
-#define CDIAG_RES_B_LBN         8
-#define CDIAG_RES_C_LBN         4
-#define CDIAG_RES_D_LBN         0
-#define CDIAG_RES_WIDTH         4
-#define CDIAG_RES_OPEN          2
-#define CDIAG_RES_OK            1
-#define CDIAG_RES_INVALID       0
-/* Set of 4 registers for pairs A-D */
-#define PMA_PMD_CDIAG_LEN_REG   49175
-
-/* Serdes control registers - SFT9001 only */
-#define PMA_PMD_CSERDES_CTRL_REG 64258
-/* Set the 156.25 MHz output to 312.5 MHz to drive Falcon's XMAC */
-#define PMA_PMD_CSERDES_DEFAULT	0x000f
-
-/* Misc register defines - SFX7101 only */
+/* Misc register defines */
 #define PCS_CLOCK_CTRL_REG	55297
 #define PLL312_RST_N_LBN 2
 
@@ -175,170 +149,206 @@
 #define C22EXT_MSTSLV_STATUS_LP_1000_HD_LBN	10
 #define C22EXT_MSTSLV_STATUS_LP_1000_FD_LBN	11
 
+#define TENXPRESS_ID_PN_LEN     (8)
+#define TENXPRESS_ID_REV_LEN    (4)
+#define TENXPRESS_ID_LEN        (TENXPRESS_ID_PN_LEN+1+TENXPRESS_ID_REV_LEN)
+
 /* Time to wait between powering down the LNPGA and turning off the power
  * rails */
 #define LNPGA_PDOWN_WAIT	(HZ / 5)
 
 struct tenxpress_phy_data {
+#ifdef CONFIG_SFC_DEBUGFS
+	char phy_snr[4];
+	char phy_afe_id[TENXPRESS_ID_LEN + 1];
+	char phy_dsp_id[TENXPRESS_ID_LEN + 1];
+	char phy_firmware_id[TENXPRESS_ID_PN_LEN + 1];
+	struct efx_nic *efx;
+#endif
 	enum efx_loopback_mode loopback_mode;
 	enum efx_phy_mode phy_mode;
 	int bad_lp_tries;
 };
 
-static ssize_t show_phy_short_reach(struct device *dev,
-				    struct device_attribute *attr, char *buf)
+#ifdef CONFIG_SFC_DEBUGFS
+
+/* debugfs entries for this PHY */
+static int tenxpress_ber_read(struct seq_file *file, void *data)
 {
-	struct efx_nic *efx = pci_get_drvdata(to_pci_dev(dev));
-	int reg;
+	struct efx_nic *efx = *(struct efx_nic **)data;
+	int reg, ber;
 
-	reg = efx_mdio_read(efx, MDIO_MMD_PMAPMD, MDIO_PMA_10GBT_TXPWR);
-	return sprintf(buf, "%d\n", !!(reg & MDIO_PMA_10GBT_TXPWR_SHORT));
+	reg = efx_mdio_read(efx, MDIO_MMD_PCS, MDIO_PCS_10GBRT_STAT2);
+
+	/* Extract the BER */
+	ber = (reg & MDIO_PCS_10GBRT_STAT2_BER) >>
+		__ffs(MDIO_PCS_10GBRT_STAT2_BER);
+
+	return seq_printf(file, "%d", ber);
 }
 
-static ssize_t set_phy_short_reach(struct device *dev,
-				   struct device_attribute *attr,
-				   const char *buf, size_t count)
+
+static int tenxpress_snr_read(struct seq_file *file, void *data)
 {
-	struct efx_nic *efx = pci_get_drvdata(to_pci_dev(dev));
+	struct tenxpress_phy_data *phy_data = NULL;
+	struct efx_nic *efx;
+	int lane = *(char *) data;
+	int reg, snr;
 
-	rtnl_lock();
-	efx_mdio_set_flag(efx, MDIO_MMD_PMAPMD, MDIO_PMA_10GBT_TXPWR,
-			  MDIO_PMA_10GBT_TXPWR_SHORT,
-			  count != 0 && *buf != '0');
-	efx_reconfigure_port(efx);
-	rtnl_unlock();
+	EFX_BUG_ON_PARANOID(lane < 0 || lane >= 4);
+	phy_data = container_of(data, struct tenxpress_phy_data, phy_snr[lane]);
+	efx = phy_data->efx;
 
-	return count;
+	reg = efx_mdio_read(efx, MDIO_MMD_PMAPMD, MDIO_PMA_10GBT_SNR + lane);
+	snr = reg - MDIO_PMA_10GBT_SNR_BIAS;
+	if (abs(snr) <= MDIO_PMA_10GBT_SNR_MAX)
+		return seq_printf(file, "%d.%d", snr / 10, (int)abs(snr % 10));
+	else
+		return seq_puts(file, "Not available");
 }
 
-static DEVICE_ATTR(phy_short_reach, 0644, show_phy_short_reach,
-		   set_phy_short_reach);
 
-int sft9001_wait_boot(struct efx_nic *efx)
+static struct efx_debugfs_parameter debug_entries[] = {
+	EFX_PER_LANE_PARAMETER("phy_lane", "_snr",
+			       struct tenxpress_phy_data, phy_snr, char,
+			       tenxpress_snr_read),
+	EFX_NAMED_PARAMETER(phy_ber, struct tenxpress_phy_data, efx,
+			    struct efx_nic *, tenxpress_ber_read),
+	EFX_STRING_PARAMETER(struct tenxpress_phy_data, phy_afe_id),
+	EFX_STRING_PARAMETER(struct tenxpress_phy_data, phy_dsp_id),
+	EFX_STRING_PARAMETER(struct tenxpress_phy_data, phy_firmware_id),
+	{NULL}
+};
+
+static void tenxpress_phy_get_id(struct efx_nic *efx, char *id_buf, int id_addr)
 {
-	unsigned long timeout = jiffies + HZ + 1;
-	int boot_stat;
+	union {
+		int all[(TENXPRESS_ID_PN_LEN + TENXPRESS_ID_REV_LEN) / 2];
+		struct {
+			int pn[TENXPRESS_ID_PN_LEN / 2];
+			int rev[TENXPRESS_ID_REV_LEN / 2];
+		} s;
+	} regs;
+	int i;
 
-	for (;;) {
-		boot_stat = efx_mdio_read(efx, MDIO_MMD_PCS,
-					  PCS_BOOT_STATUS_REG);
-		if (boot_stat >= 0) {
-			EFX_LOG(efx, "PHY boot status = %#x\n", boot_stat);
-			switch (boot_stat &
-				((1 << PCS_BOOT_FATAL_ERROR_LBN) |
-				 (3 << PCS_BOOT_PROGRESS_LBN) |
-				 (1 << PCS_BOOT_DOWNLOAD_WAIT_LBN) |
-				 (1 << PCS_BOOT_CODE_STARTED_LBN))) {
-			case ((1 << PCS_BOOT_FATAL_ERROR_LBN) |
-			      (PCS_BOOT_PROGRESS_CHECKSUM <<
-			       PCS_BOOT_PROGRESS_LBN)):
-			case ((1 << PCS_BOOT_FATAL_ERROR_LBN) |
-			      (PCS_BOOT_PROGRESS_INIT <<
-			       PCS_BOOT_PROGRESS_LBN) |
-			      (1 << PCS_BOOT_DOWNLOAD_WAIT_LBN)):
-				return -EINVAL;
-			case ((PCS_BOOT_PROGRESS_WAIT_MDIO <<
-			       PCS_BOOT_PROGRESS_LBN) |
-			      (1 << PCS_BOOT_DOWNLOAD_WAIT_LBN)):
-				return (efx->phy_mode & PHY_MODE_SPECIAL) ?
-					0 : -EIO;
-			case ((PCS_BOOT_PROGRESS_JUMP <<
-			       PCS_BOOT_PROGRESS_LBN) |
-			      (1 << PCS_BOOT_CODE_STARTED_LBN)):
-			case ((PCS_BOOT_PROGRESS_JUMP <<
-			       PCS_BOOT_PROGRESS_LBN) |
-			      (1 << PCS_BOOT_DOWNLOAD_WAIT_LBN) |
-			      (1 << PCS_BOOT_CODE_STARTED_LBN)):
-				return (efx->phy_mode & PHY_MODE_SPECIAL) ?
-					-EIO : 0;
-			default:
-				if (boot_stat & (1 << PCS_BOOT_FATAL_ERROR_LBN))
-					return -EIO;
-				break;
-			}
-		}
+	for (i = 0; i < ARRAY_SIZE(regs.all); ++i)
+		regs.all[i] = efx_mdio_read(efx, MDIO_MMD_PMAPMD, id_addr + i);
 
-		if (time_after_eq(jiffies, timeout))
-			return -ETIMEDOUT;
-
-		msleep(50);
+	for (i = ARRAY_SIZE(regs.s.pn) - 1; i >= 0; --i) {
+		*id_buf++ = regs.s.pn[i] & 0xff;
+		*id_buf++ = (regs.s.pn[i] & 0xff00) >> 8;
 	}
+	*id_buf++ = ' ';
+	for (i = ARRAY_SIZE(regs.s.rev) - 1; i >= 0; --i) {
+		*id_buf++ = regs.s.rev[i] & 0xff;
+		*id_buf++ = (regs.s.rev[i] & 0xff00) >> 8;
+	}
+	*id_buf = 0;
 }
 
-static int tenxpress_init(struct efx_nic *efx)
+static int tenxpress_debugfs_init(struct efx_nic *efx)
 {
-	int reg;
+	struct tenxpress_phy_data *phy_data = efx->phy_data;
+	int lane, rc;
 
-	if (efx->phy_type == PHY_TYPE_SFX7101) {
-		/* Enable 312.5 MHz clock */
-		efx_mdio_write(efx, MDIO_MMD_PCS, PCS_TEST_SELECT_REG,
-			       1 << CLK312_EN_LBN);
-	} else {
-		/* Enable 312.5 MHz clock and GMII */
-		reg = efx_mdio_read(efx, MDIO_MMD_PMAPMD, PMA_PMD_XCONTROL_REG);
-		reg |= ((1 << PMA_PMD_EXT_GMII_EN_LBN) |
-			(1 << PMA_PMD_EXT_CLK_OUT_LBN) |
-			(1 << PMA_PMD_EXT_CLK312_LBN) |
-			(1 << PMA_PMD_EXT_ROBUST_LBN));
+	for (lane = 0; lane < 4; lane++)
+		phy_data->phy_snr[lane] = lane;
 
-		efx_mdio_write(efx, MDIO_MMD_PMAPMD, PMA_PMD_XCONTROL_REG, reg);
-		efx_mdio_set_flag(efx, MDIO_MMD_C22EXT,
-			      GPHY_XCONTROL_REG, 1 << GPHY_ISOLATE_LBN,
-			      false);
-	}
+	phy_data->efx = efx;
+	rc = efx_extend_debugfs_port(efx, efx->phy_data, 0,
+				     debug_entries);
+	if (rc < 0)
+		return rc;
 
-	/* Set the LEDs up as: Green = Link, Amber = Link/Act, Red = Off */
-	if (efx->phy_type == PHY_TYPE_SFX7101) {
-		efx_mdio_set_flag(efx, MDIO_MMD_PMAPMD, PMA_PMD_LED_CTRL_REG,
-				  1 << PMA_PMA_LED_ACTIVITY_LBN, true);
-		efx_mdio_write(efx, MDIO_MMD_PMAPMD, PMA_PMD_LED_OVERR_REG,
-			       PMA_PMD_LED_DEFAULT);
-	}
+	tenxpress_phy_get_id(efx, phy_data->phy_dsp_id,
+			     PMA_PMD_DSP_ID_REG);
+	tenxpress_phy_get_id(efx, phy_data->phy_afe_id,
+			     PMA_PMD_AFE_ID_REG);
+	tenxpress_phy_get_id(efx, phy_data->phy_firmware_id,
+			     PMA_PMD_FIRMWARE_ID_REG);
 
 	return 0;
 }
 
-static int tenxpress_phy_init(struct efx_nic *efx)
+#endif /* CONFIG_SFC_DEBUGFS */
+
+/* Initialise the part post power on reset or software special reset */
+static int tenxpress_init(struct efx_nic *efx)
+{
+	/* Enable 312.5 MHz clock */
+	efx_mdio_write(efx, MDIO_MMD_PCS, PCS_TEST_SELECT_REG,
+		       1 << CLK312_EN_LBN);
+
+	/* Set the LEDs up as: Green = Link, Amber = Link/Act, Red = Off */
+	efx_mdio_set_flag(efx, MDIO_MMD_PMAPMD, PMA_PMD_LED_CTRL_REG,
+			  1 << PMA_PMA_LED_ACTIVITY_LBN, true);
+	efx_mdio_write(efx, MDIO_MMD_PMAPMD, PMA_PMD_LED_OVERR_REG,
+		       SFX7101_PMA_PMD_LED_DEFAULT);
+
+	return 0;
+}
+
+static int tenxpress_phy_probe(struct efx_nic *efx)
 {
 	struct tenxpress_phy_data *phy_data;
-	int rc = 0;
+	int rc;
 
+	/* Allocate phy private storage */
 	phy_data = kzalloc(sizeof(*phy_data), GFP_KERNEL);
 	if (!phy_data)
 		return -ENOMEM;
 	efx->phy_data = phy_data;
 	phy_data->phy_mode = efx->phy_mode;
 
+#ifdef CONFIG_SFC_DEBUGFS
+	rc = tenxpress_debugfs_init(efx);
+	if (rc < 0)
+		goto fail;
+#endif
+
+	efx->mdio.mmds = TENXPRESS_REQUIRED_DEVS;
+	efx->mdio.mode_support = MDIO_SUPPORTS_C45;
+
+	efx->loopback_modes = SFX7101_LOOPBACKS | FALCON_XMAC_LOOPBACKS;
+	efx->startup_loopback_mode = LOOPBACK_PCS;
+
+	strlcpy(efx->phy_name, "SFX7101 10GBASE-T",
+		sizeof(efx->phy_name));
+
+	efx->link_advertising = (ADVERTISED_TP | ADVERTISED_Autoneg |
+				 ADVERTISED_10000baseT_Full);
+
+	return 0;
+
+fail:
+	kfree(efx->phy_data);
+	efx->phy_data = NULL;
+	return rc;
+}
+
+static int tenxpress_phy_init(struct efx_nic *efx)
+{
+	int rc;
+
+	falcon_board(efx)->type->init_phy(efx);
+
 	if (!(efx->phy_mode & PHY_MODE_SPECIAL)) {
-		if (efx->phy_type == PHY_TYPE_SFT9001A) {
-			int reg;
-			reg = efx_mdio_read(efx, MDIO_MMD_PMAPMD,
-					    PMA_PMD_XCONTROL_REG);
-			reg |= (1 << PMA_PMD_EXT_SSR_LBN);
-			efx_mdio_write(efx, MDIO_MMD_PMAPMD,
-				       PMA_PMD_XCONTROL_REG, reg);
-			mdelay(200);
-		}
-
 		rc = efx_mdio_wait_reset_mmds(efx, TENXPRESS_REQUIRED_DEVS);
 		if (rc < 0)
-			goto fail;
+			return rc;
 
 		rc = efx_mdio_check_mmds(efx, TENXPRESS_REQUIRED_DEVS, 0);
 		if (rc < 0)
-			goto fail;
+			return rc;
 	}
 
 	rc = tenxpress_init(efx);
 	if (rc < 0)
-		goto fail;
+		return rc;
 
-	if (efx->phy_type == PHY_TYPE_SFT9001B) {
-		rc = device_create_file(&efx->pci_dev->dev,
-					&dev_attr_phy_short_reach);
-		if (rc)
-			goto fail;
-	}
+	/* Reinitialise flow control settings */
+	efx_link_set_wanted_fc(efx, efx->wanted_fc);
+	efx_mdio_an_reconfigure(efx);
 
 	schedule_timeout_uninterruptible(HZ / 5); /* 200ms */
 
@@ -346,11 +356,6 @@ static int tenxpress_phy_init(struct efx
 	falcon_reset_xaui(efx);
 
 	return 0;
-
- fail:
-	kfree(efx->phy_data);
-	efx->phy_data = NULL;
-	return rc;
 }
 
 /* Perform a "special software reset" on the PHY. The caller is
@@ -360,10 +365,10 @@ static int tenxpress_special_reset(struc
 {
 	int rc, reg;
 
-	/* The XGMAC clock is driven from the SFC7101/SFT9001 312MHz clock, so
+	/* The XGMAC clock is driven from the SFX7101 312MHz clock, so
 	 * a special software reset can glitch the XGMAC sufficiently for stats
 	 * requests to fail. */
-	efx_stats_disable(efx);
+	falcon_stop_nic_stats(efx);
 
 	/* Initiate reset */
 	reg = efx_mdio_read(efx, MDIO_MMD_PMAPMD, PMA_PMD_XCONTROL_REG);
@@ -385,7 +390,7 @@ static int tenxpress_special_reset(struc
 	/* Wait for the XGXS state machine to churn */
 	mdelay(10);
 out:
-	efx_stats_enable(efx);
+	falcon_start_nic_stats(efx);
 	return rc;
 }
 
@@ -421,10 +426,11 @@ static void sfx7101_check_bad_lp(struct 
 			reg |= PMA_PMD_LED_OFF << PMA_PMD_LED_RX_LBN;
 		} else {
 			reg |= PMA_PMD_LED_FLASH << PMA_PMD_LED_RX_LBN;
-			EFX_ERR(efx, "appears to be plugged into a port"
-				" that is not 10GBASE-T capable. The PHY"
-				" supports 10GBASE-T ONLY, so no link can"
-				" be established\n");
+			netif_err(efx, link, efx->net_dev,
+				  "appears to be plugged into a port"
+				  " that is not 10GBASE-T capable. The PHY"
+				  " supports 10GBASE-T ONLY, so no link can"
+				  " be established\n");
 		}
 		efx_mdio_write(efx, MDIO_MMD_PMAPMD,
 			       PMA_PMD_LED_OVERR_REG, reg);
@@ -440,182 +446,114 @@ static bool sfx7101_link_ok(struct efx_n
 				 MDIO_DEVS_PHYXS);
 }
 
-static bool sft9001_link_ok(struct efx_nic *efx, struct ethtool_cmd *ecmd)
-{
-	u32 reg;
-
-	if (efx_phy_mode_disabled(efx->phy_mode))
-		return false;
-	else if (efx->loopback_mode == LOOPBACK_GPHY)
-		return true;
-	else if (efx->loopback_mode)
-		return efx_mdio_links_ok(efx,
-					 MDIO_DEVS_PMAPMD |
-					 MDIO_DEVS_PHYXS);
-
-	/* We must use the same definition of link state as LASI,
-	 * otherwise we can miss a link state transition
-	 */
-	if (ecmd->speed == 10000) {
-		reg = efx_mdio_read(efx, MDIO_MMD_PCS, MDIO_PCS_10GBRT_STAT1);
-		return reg & MDIO_PCS_10GBRT_STAT1_BLKLK;
-	} else {
-		reg = efx_mdio_read(efx, MDIO_MMD_C22EXT, C22EXT_STATUS_REG);
-		return reg & (1 << C22EXT_STATUS_LINK_LBN);
-	}
-}
-
 static void tenxpress_ext_loopback(struct efx_nic *efx)
 {
 	efx_mdio_set_flag(efx, MDIO_MMD_PHYXS, PHYXS_TEST1,
 			  1 << LOOPBACK_NEAR_LBN,
 			  efx->loopback_mode == LOOPBACK_PHYXS);
-	if (efx->phy_type != PHY_TYPE_SFX7101)
-		efx_mdio_set_flag(efx, MDIO_MMD_C22EXT, GPHY_XCONTROL_REG,
-				  1 << GPHY_LOOPBACK_NEAR_LBN,
-				  efx->loopback_mode == LOOPBACK_GPHY);
 }
 
 static void tenxpress_low_power(struct efx_nic *efx)
 {
-	if (efx->phy_type == PHY_TYPE_SFX7101)
-		efx_mdio_set_mmds_lpower(
-			efx, !!(efx->phy_mode & PHY_MODE_LOW_POWER),
-			TENXPRESS_REQUIRED_DEVS);
-	else
-		efx_mdio_set_flag(
-			efx, MDIO_MMD_PMAPMD, PMA_PMD_XCONTROL_REG,
-			1 << PMA_PMD_EXT_LPOWER_LBN,
-			!!(efx->phy_mode & PHY_MODE_LOW_POWER));
+	efx_mdio_set_mmds_lpower(
+		efx, !!(efx->phy_mode & PHY_MODE_LOW_POWER),
+		TENXPRESS_REQUIRED_DEVS);
 }
 
-static void tenxpress_phy_reconfigure(struct efx_nic *efx)
+static int tenxpress_phy_reconfigure(struct efx_nic *efx)
 {
 	struct tenxpress_phy_data *phy_data = efx->phy_data;
-	struct ethtool_cmd ecmd;
 	bool phy_mode_change, loop_reset;
 
 	if (efx->phy_mode & (PHY_MODE_OFF | PHY_MODE_SPECIAL)) {
 		phy_data->phy_mode = efx->phy_mode;
-		return;
+		return 0;
+	}
+
+	phy_mode_change = (efx->phy_mode == PHY_MODE_NORMAL &&
+			   phy_data->phy_mode != PHY_MODE_NORMAL);
+	loop_reset = (LOOPBACK_OUT_OF(phy_data, efx, LOOPBACKS_EXTERNAL(efx)) ||
+		      LOOPBACK_CHANGED(phy_data, efx, 1 << LOOPBACK_GPHY));
+
+	if (loop_reset || phy_mode_change) {
+		tenxpress_special_reset(efx);
+		falcon_reset_xaui(efx);
 	}
 
 	tenxpress_low_power(efx);
-
-	phy_mode_change = (efx->phy_mode == PHY_MODE_NORMAL &&
-			   phy_data->phy_mode != PHY_MODE_NORMAL);
-	loop_reset = (LOOPBACK_OUT_OF(phy_data, efx, efx->phy_op->loopbacks) ||
-		      LOOPBACK_CHANGED(phy_data, efx, 1 << LOOPBACK_GPHY));
-
-	if (loop_reset || phy_mode_change) {
-		int rc;
-
-		efx->phy_op->get_settings(efx, &ecmd);
-
-		if (loop_reset || phy_mode_change) {
-			tenxpress_special_reset(efx);
-
-			/* Reset XAUI if we were in 10G, and are staying
-			 * in 10G. If we're moving into and out of 10G
-			 * then xaui will be reset anyway */
-			if (EFX_IS10G(efx))
-				falcon_reset_xaui(efx);
-		}
-
-		rc = efx->phy_op->set_settings(efx, &ecmd);
-		WARN_ON(rc);
-	}
-
 	efx_mdio_transmit_disable(efx);
 	efx_mdio_phy_reconfigure(efx);
 	tenxpress_ext_loopback(efx);
+	efx_mdio_an_reconfigure(efx);
 
 	phy_data->loopback_mode = efx->loopback_mode;
 	phy_data->phy_mode = efx->phy_mode;
 
-	if (efx->phy_type == PHY_TYPE_SFX7101) {
-		efx->link_speed = 10000;
-		efx->link_fd = true;
-		efx->link_up = sfx7101_link_ok(efx);
-	} else {
-		efx->phy_op->get_settings(efx, &ecmd);
-		efx->link_speed = ecmd.speed;
-		efx->link_fd = ecmd.duplex == DUPLEX_FULL;
-		efx->link_up = sft9001_link_ok(efx, &ecmd);
-	}
-	efx->link_fc = efx_mdio_get_pause(efx);
+	return 0;
 }
 
-/* Poll PHY for interrupt */
-static void tenxpress_phy_poll(struct efx_nic *efx)
+static void
+tenxpress_get_settings(struct efx_nic *efx, struct ethtool_cmd *ecmd);
+
+/* Poll for link state changes */
+static bool tenxpress_phy_poll(struct efx_nic *efx)
 {
-	struct tenxpress_phy_data *phy_data = efx->phy_data;
-	bool change = false;
+	struct efx_link_state old_state = efx->link_state;
 
-	if (efx->phy_type == PHY_TYPE_SFX7101) {
-		bool link_ok = sfx7101_link_ok(efx);
-		if (link_ok != efx->link_up) {
-			change = true;
-		} else {
-			unsigned int link_fc = efx_mdio_get_pause(efx);
-			if (link_fc != efx->link_fc)
-				change = true;
-		}
-		sfx7101_check_bad_lp(efx, link_ok);
-	} else if (efx->loopback_mode) {
-		bool link_ok = sft9001_link_ok(efx, NULL);
-		if (link_ok != efx->link_up)
-			change = true;
-	} else {
-		int status = efx_mdio_read(efx, MDIO_MMD_PMAPMD,
-					   MDIO_PMA_LASI_STAT);
-		if (status & MDIO_PMA_LASI_LSALARM)
-			change = true;
-	}
+	efx->link_state.up = sfx7101_link_ok(efx);
+	efx->link_state.speed = 10000;
+	efx->link_state.fd = true;
+	efx->link_state.fc = efx_mdio_get_pause(efx);
 
-	if (change)
-		falcon_sim_phy_event(efx);
+	sfx7101_check_bad_lp(efx, efx->link_state.up);
 
-	if (phy_data->phy_mode != PHY_MODE_NORMAL)
-		return;
+	return !efx_link_state_equal(&efx->link_state, &old_state);
 }
 
-static void tenxpress_phy_fini(struct efx_nic *efx)
+static void sfx7101_phy_fini(struct efx_nic *efx)
 {
 	int reg;
 
-	if (efx->phy_type == PHY_TYPE_SFT9001B)
-		device_remove_file(&efx->pci_dev->dev,
-				   &dev_attr_phy_short_reach);
+	/* Power down the LNPGA */
+	reg = (1 << PMA_PMD_LNPGA_POWERDOWN_LBN);
+	efx_mdio_write(efx, MDIO_MMD_PMAPMD, PMA_PMD_XCONTROL_REG, reg);
 
-	if (efx->phy_type == PHY_TYPE_SFX7101) {
-		/* Power down the LNPGA */
-		reg = (1 << PMA_PMD_LNPGA_POWERDOWN_LBN);
-		efx_mdio_write(efx, MDIO_MMD_PMAPMD, PMA_PMD_XCONTROL_REG, reg);
+	/* Waiting here ensures that the board fini, which can turn
+	 * off the power to the PHY, won't get run until the LNPGA
+	 * powerdown has been given long enough to complete. */
+	schedule_timeout_uninterruptible(LNPGA_PDOWN_WAIT); /* 200 ms */
+}
 
-		/* Waiting here ensures that the board fini, which can turn
-		 * off the power to the PHY, won't get run until the LNPGA
-		 * powerdown has been given long enough to complete. */
-		schedule_timeout_uninterruptible(LNPGA_PDOWN_WAIT); /* 200 ms */
-	}
-
+static void tenxpress_phy_remove(struct efx_nic *efx)
+{
+#ifdef CONFIG_SFC_DEBUGFS
+	efx_trim_debugfs_port(efx, debug_entries);
+#endif
 	kfree(efx->phy_data);
 	efx->phy_data = NULL;
 }
 
 
-/* Set the RX and TX LEDs and Link LED flashing. The other LEDs
- * (which probably aren't wired anyway) are left in AUTO mode */
-void tenxpress_phy_blink(struct efx_nic *efx, bool blink)
+/* Override the RX, TX and link LEDs */
+void tenxpress_set_id_led(struct efx_nic *efx, enum efx_led_mode mode)
 {
 	int reg;
 
-	if (blink)
-		reg = (PMA_PMD_LED_FLASH << PMA_PMD_LED_TX_LBN) |
-			(PMA_PMD_LED_FLASH << PMA_PMD_LED_RX_LBN) |
-			(PMA_PMD_LED_FLASH << PMA_PMD_LED_LINK_LBN);
-	else
-		reg = PMA_PMD_LED_DEFAULT;
+	switch (mode) {
+	case EFX_LED_OFF:
+		reg = (PMA_PMD_LED_OFF << PMA_PMD_LED_TX_LBN) |
+			(PMA_PMD_LED_OFF << PMA_PMD_LED_RX_LBN) |
+			(PMA_PMD_LED_OFF << PMA_PMD_LED_LINK_LBN);
+		break;
+	case EFX_LED_ON:
+		reg = (PMA_PMD_LED_ON << PMA_PMD_LED_TX_LBN) |
+			(PMA_PMD_LED_ON << PMA_PMD_LED_RX_LBN) |
+			(PMA_PMD_LED_ON << PMA_PMD_LED_LINK_LBN);
+		break;
+	default:
+		reg = SFX7101_PMA_PMD_LED_DEFAULT;
+		break;
+	}
 
 	efx_mdio_write(efx, MDIO_MMD_PMAPMD, PMA_PMD_LED_OVERR_REG, reg);
 }
@@ -623,6 +561,13 @@ static const char *const sfx7101_test_na
 static const char *const sfx7101_test_names[] = {
 	"bist"
 };
+
+static const char *sfx7101_test_name(struct efx_nic *efx, unsigned int index)
+{
+	if (index < ARRAY_SIZE(sfx7101_test_names))
+		return sfx7101_test_names[index];
+	return NULL;
+}
 
 static int
 sfx7101_run_tests(struct efx_nic *efx, int *results, unsigned flags)
@@ -635,84 +580,8 @@ sfx7101_run_tests(struct efx_nic *efx, i
 	/* BIST is automatically run after a special software reset */
 	rc = tenxpress_special_reset(efx);
 	results[0] = rc ? -1 : 1;
-	return rc;
-}
 
-static const char *const sft9001_test_names[] = {
-	"bist",
-	"cable.pairA.status",
-	"cable.pairB.status",
-	"cable.pairC.status",
-	"cable.pairD.status",
-	"cable.pairA.length",
-	"cable.pairB.length",
-	"cable.pairC.length",
-	"cable.pairD.length",
-};
-
-static int sft9001_run_tests(struct efx_nic *efx, int *results, unsigned flags)
-{
-	struct ethtool_cmd ecmd;
-	int rc = 0, rc2, i, ctrl_reg, res_reg;
-
-	if (flags & ETH_TEST_FL_OFFLINE)
-		efx->phy_op->get_settings(efx, &ecmd);
-
-	/* Initialise cable diagnostic results to unknown failure */
-	for (i = 1; i < 9; ++i)
-		results[i] = -1;
-
-	/* Run cable diagnostics; wait up to 5 seconds for them to complete.
-	 * A cable fault is not a self-test failure, but a timeout is. */
-	ctrl_reg = ((1 << CDIAG_CTRL_IMMED_LBN) |
-		    (CDIAG_CTRL_LEN_METRES << CDIAG_CTRL_LEN_UNIT_LBN));
-	if (flags & ETH_TEST_FL_OFFLINE) {
-		/* Break the link in order to run full diagnostics.  We
-		 * must reset the PHY to resume normal service. */
-		ctrl_reg |= (1 << CDIAG_CTRL_BRK_LINK_LBN);
-	}
-	efx_mdio_write(efx, MDIO_MMD_PMAPMD, PMA_PMD_CDIAG_CTRL_REG,
-		       ctrl_reg);
-	i = 0;
-	while (efx_mdio_read(efx, MDIO_MMD_PMAPMD, PMA_PMD_CDIAG_CTRL_REG) &
-	       (1 << CDIAG_CTRL_IN_PROG_LBN)) {
-		if (++i == 50) {
-			rc = -ETIMEDOUT;
-			goto out;
-		}
-		msleep(100);
-	}
-	res_reg = efx_mdio_read(efx, MDIO_MMD_PMAPMD, PMA_PMD_CDIAG_RES_REG);
-	for (i = 0; i < 4; i++) {
-		int pair_res =
-			(res_reg >> (CDIAG_RES_A_LBN - i * CDIAG_RES_WIDTH))
-			& ((1 << CDIAG_RES_WIDTH) - 1);
-		int len_reg = efx_mdio_read(efx, MDIO_MMD_PMAPMD,
-					    PMA_PMD_CDIAG_LEN_REG + i);
-		if (pair_res == CDIAG_RES_OK)
-			results[1 + i] = 1;
-		else if (pair_res == CDIAG_RES_INVALID)
-			results[1 + i] = -1;
-		else
-			results[1 + i] = -pair_res;
-		if (pair_res != CDIAG_RES_INVALID &&
-		    pair_res != CDIAG_RES_OPEN &&
-		    len_reg != 0xffff)
-			results[5 + i] = len_reg;
-	}
-
-out:
-	if (flags & ETH_TEST_FL_OFFLINE) {
-		/* Reset, running the BIST and then resuming normal service. */
-		rc2 = tenxpress_special_reset(efx);
-		results[0] = rc2 ? -1 : 1;
-		if (!rc)
-			rc = rc2;
-
-		rc2 = efx->phy_op->set_settings(efx, &ecmd);
-		if (!rc)
-			rc = rc2;
-	}
+	efx_mdio_an_reconfigure(efx);
 
 	return rc;
 }
@@ -723,16 +592,6 @@ tenxpress_get_settings(struct efx_nic *e
 	u32 adv = 0, lpa = 0;
 	int reg;
 
-	if (efx->phy_type != PHY_TYPE_SFX7101) {
-		reg = efx_mdio_read(efx, MDIO_MMD_C22EXT, C22EXT_MSTSLV_CTRL);
-		if (reg & (1 << C22EXT_MSTSLV_CTRL_ADV_1000_FD_LBN))
-			adv |= ADVERTISED_1000baseT_Full;
-		reg = efx_mdio_read(efx, MDIO_MMD_C22EXT, C22EXT_MSTSLV_STATUS);
-		if (reg & (1 << C22EXT_MSTSLV_STATUS_LP_1000_HD_LBN))
-			lpa |= ADVERTISED_1000baseT_Half;
-		if (reg & (1 << C22EXT_MSTSLV_STATUS_LP_1000_FD_LBN))
-			lpa |= ADVERTISED_1000baseT_Full;
-	}
 	reg = efx_mdio_read(efx, MDIO_MMD_AN, MDIO_AN_10GBT_CTRL);
 	if (reg & MDIO_AN_10GBT_CTRL_ADV10G)
 		adv |= ADVERTISED_10000baseT_Full;
@@ -740,25 +599,27 @@ tenxpress_get_settings(struct efx_nic *e
 	if (reg & MDIO_AN_10GBT_STAT_LP10G)
 		lpa |= ADVERTISED_10000baseT_Full;
 
+#if defined(EFX_USE_KCOMPAT) && defined(EFX_NEED_MDIO45_FLOW_CONTROL_HACKS)
+	/* Old versions of the intree mdio45 layer don't set the pause
+	 * capabilities in the ecmd structure properly */
+	{
+		const struct mdio_if_info *mdio = &efx->mdio;
+		u32 reg;
+
+		reg = mdio->mdio_read(mdio->dev, mdio->prtad, MDIO_MMD_AN,
+				      MDIO_AN_ADVERTISE);
+		if (reg & ADVERTISE_PAUSE_CAP)
+			adv |= ADVERTISED_Pause;
+		if (reg & ADVERTISE_PAUSE_ASYM)
+			adv |= ADVERTISED_Asym_Pause;
+	}
+#endif
+
 	mdio45_ethtool_gset_npage(&efx->mdio, ecmd, adv, lpa);
-
-	if (efx->phy_type != PHY_TYPE_SFX7101) {
-		ecmd->supported |= (SUPPORTED_100baseT_Full |
-				    SUPPORTED_1000baseT_Full);
-		if (ecmd->speed != SPEED_10000) {
-			ecmd->eth_tp_mdix =
-				(efx_mdio_read(efx, MDIO_MMD_PMAPMD,
-					       PMA_PMD_XSTATUS_REG) &
-				 (1 << PMA_PMD_XSTAT_MDIX_LBN))
-				? ETH_TP_MDI_X : ETH_TP_MDI;
-		}
-	}
 
 	/* In loopback, the PHY automatically brings up the correct interface,
 	 * but doesn't advertise the correct speed. So override it */
-	if (efx->loopback_mode == LOOPBACK_GPHY)
-		ecmd->speed = SPEED_1000;
-	else if (LOOPBACK_MASK(efx) & efx->phy_op->loopbacks)
+	if (LOOPBACK_EXTERNAL(efx))
 		ecmd->speed = SPEED_10000;
 }
 
@@ -777,46 +638,17 @@ static void sfx7101_set_npage_adv(struct
 			  advertising & ADVERTISED_10000baseT_Full);
 }
 
-static void sft9001_set_npage_adv(struct efx_nic *efx, u32 advertising)
-{
-	efx_mdio_set_flag(efx, MDIO_MMD_C22EXT, C22EXT_MSTSLV_CTRL,
-			  1 << C22EXT_MSTSLV_CTRL_ADV_1000_FD_LBN,
-			  advertising & ADVERTISED_1000baseT_Full);
-	efx_mdio_set_flag(efx, MDIO_MMD_AN, MDIO_AN_10GBT_CTRL,
-			  MDIO_AN_10GBT_CTRL_ADV10G,
-			  advertising & ADVERTISED_10000baseT_Full);
-}
-
 struct efx_phy_operations falcon_sfx7101_phy_ops = {
-	.macs		  = EFX_XMAC,
+	.probe		  = tenxpress_phy_probe,
 	.init             = tenxpress_phy_init,
 	.reconfigure      = tenxpress_phy_reconfigure,
 	.poll             = tenxpress_phy_poll,
-	.fini             = tenxpress_phy_fini,
-	.clear_interrupt  = efx_port_dummy_op_void,
+	.fini             = sfx7101_phy_fini,
+	.remove		  = tenxpress_phy_remove,
 	.get_settings	  = tenxpress_get_settings,
 	.set_settings	  = tenxpress_set_settings,
 	.set_npage_adv    = sfx7101_set_npage_adv,
-	.num_tests	  = ARRAY_SIZE(sfx7101_test_names),
-	.test_names	  = sfx7101_test_names,
+	.test_alive	  = efx_mdio_test_alive,
+	.test_name	  = sfx7101_test_name,
 	.run_tests	  = sfx7101_run_tests,
-	.mmds             = TENXPRESS_REQUIRED_DEVS,
-	.loopbacks        = SFX7101_LOOPBACKS,
 };
-
-struct efx_phy_operations falcon_sft9001_phy_ops = {
-	.macs		  = EFX_GMAC | EFX_XMAC,
-	.init             = tenxpress_phy_init,
-	.reconfigure      = tenxpress_phy_reconfigure,
-	.poll             = tenxpress_phy_poll,
-	.fini             = tenxpress_phy_fini,
-	.clear_interrupt  = efx_port_dummy_op_void,
-	.get_settings	  = tenxpress_get_settings,
-	.set_settings	  = tenxpress_set_settings,
-	.set_npage_adv    = sft9001_set_npage_adv,
-	.num_tests	  = ARRAY_SIZE(sft9001_test_names),
-	.test_names	  = sft9001_test_names,
-	.run_tests	  = sft9001_run_tests,
-	.mmds             = TENXPRESS_REQUIRED_DEVS,
-	.loopbacks        = SFT9001_LOOPBACKS,
-};
diff -r 5b3d4d3c1166 drivers/net/sfc/tweak.c
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/drivers/net/sfc/tweak.c	Tue Nov 09 10:06:27 2010 +0000
@@ -0,0 +1,477 @@
+/****************************************************************************
+ * Driver for Solarflare Solarstorm network controllers and boards
+ * Copyright 2006-2008 Solarflare Communications Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 as published
+ * by the Free Software Foundation, incorporated herein by reference.
+ */
+
+#include <linux/module.h>
+#include <linux/pci.h>
+
+#ifdef EFX_USE_KCOMPAT
+# include "config.h"
+# include "kernel_compat.h"
+#endif
+
+#include "driverlink_api.h"
+#include "idle.h"
+#include "efx.h"
+
+/* High performance settings */
+#define PCIE_MPL_HPERF 512 /* Max payload */
+#define PCIE_MRR_HPERF 512 /* Max Read Request Size */
+#define PARAM_DIS -1
+#define PARAM_AUTO 0
+
+/* Intel 5000 series specific register definitions */
+#define PCI_5000_READ_MERGE_REG 0x48  /* 5000 chipset specific register */
+#define PCI_5000_READ_MERGE_BIT 10    /* 5000 chipset specific field */
+
+/*****************************************************************************/
+
+/* Information about PCIe parameters being tweaked. */
+struct efx_pcie_tweaks {
+	/* Non-negative once we have found a parent bridge device */
+	int bridge_vendor;
+	int bridge_devid;
+
+	/* Bridge requires disable read coalescing */
+	int disable_bridge_read_coalesce;
+
+	/* The bus which is being tuned. */
+	struct pci_bus *bus;
+
+	/* The slot on the bus which modified.  Since this is PCIe,
+	 * we'd expect it to be zero, but you never know... */
+	int slot;
+
+	/* The maximum payload size supported by all devices seen so
+	 * far as encoded in the device control register.  This is
+	 * modified as devices are checked.  A value of -1 means that
+	 * no change should be made. */
+	int max_payload_size;
+
+	/* The maximum read request size to be programmed into all
+	 * functions on the device as encoded in the device control
+	 * register.  A value of -1 means that no change should be
+	 * made. */
+	int max_read_request_size;
+};
+
+
+/*
+ * PCIe maximum payload size
+ *
+ * If non-zero, tuning of the PCIe maximum payload size is enabled and
+ * the maximum payload size is restricted to be no larger than this
+ * parameter.  The same value is written to the root port and all
+ * functions on the NIC and the value written is restricted to the
+ * supported payload size of those components.  The value of this
+ * parameter must be zero or a value listed in the PCIe specification.
+ */
+static int pcie_max_payload_size = PARAM_AUTO;
+
+/*
+ * PCIe maximum read size
+ *
+ * If non-zero, the PCIe maximum read request size on all functions of
+ * every NIC are set to this value.  The value of this parameter must
+ * be zero or listed in the PCIe specification.
+ *
+ */
+static int pcie_max_read_request_size = PARAM_AUTO;
+
+/*
+ * Disable bridge read coalescing on Intel 5000 chipsets.
+ *
+ * Increasing the PCIe max payload size beyond 128 on an Intel 5000
+ * chipset requires read coalescing to be disabled.
+ */
+static int disable_bridge_read_coalesce = PARAM_AUTO;
+
+/*
+ * Force the PCIe settings to be tweaked
+ */
+static unsigned int tweak_pcie = 0;
+
+/*****************************************************************************/
+
+static void efx_pcie_check_coalesce(struct efx_pcie_tweaks *tweaks)
+{
+	/* Check: http://pciids.sourceforge.net/ */
+	tweaks->disable_bridge_read_coalesce =
+		tweaks->disable_bridge_read_coalesce &&
+		((tweaks->bridge_vendor == 0x8086)
+		 && (tweaks->bridge_devid >= 0x25c0)
+		 && (tweaks->bridge_devid <= 0x25FA));
+}
+
+static void efx_pcie_check_tweaks(struct pci_dev *dev,
+				  struct efx_pcie_tweaks *tweaks)
+{
+	int pos;
+	int rc;
+	u16 dev_flags = -1;
+	u16 dev_type;
+	u32 dev_cap = -1;
+	u32 dev_max_payload;
+
+	/* This indicates that an error has already been
+	 * encountered. */
+	if (tweaks->max_payload_size == -1 &&
+	    tweaks->max_read_request_size == -1)
+		return;
+
+	pos = pci_find_capability(dev, PCI_CAP_ID_EXP);
+	if (pos <= 0) {
+		printk(KERN_INFO "Couldn't find PCIe capabilities of %s\n",
+		       pci_name(dev));
+		tweaks->max_read_request_size = -1;
+		goto err_out;
+	}
+
+	/* Check the PCIe device/port type. */
+	rc = pci_read_config_word(dev, pos + PCI_EXP_FLAGS, &dev_flags);
+	if (rc) {
+		printk(KERN_ERR "%s Error %d reading PCIe flags\n",
+		       pci_name(dev), rc);
+		goto err_out;
+	}
+
+	dev_type = (dev_flags & PCI_EXP_FLAGS_TYPE) >> 4;
+	if (dev == tweaks->bus->self) {
+		/* This is the root port (or a switch port).  For the
+		 * moment, we don't handle switches.  The main reason
+		 * is that updating registers on cards being managed
+		 * by other drivers is a very dangerous thing to do
+		 * rather than just a dangerous thing to do.  It's
+		 * also a bit more awkward to find all the relevant
+		 * devices.  PCIe switches are also uncommon enough
+		 * that it's not worth the bother at the moment. */
+		tweaks->bridge_vendor = dev->vendor;
+		tweaks->bridge_devid = dev->device;
+		if (dev_type != PCI_EXP_TYPE_ROOT_PORT) {
+			printk(KERN_ERR
+			       "PCIe port %s is not a root port (type %d)\n",
+				pci_name(dev), dev_type);
+			goto err_out;
+		}
+		efx_pcie_check_coalesce(tweaks);
+
+	} else if (dev->bus == tweaks->bus &&
+		   PCI_SLOT(dev->devfn) == tweaks->slot) {
+		/* This is a function on the correct slot.  Slot is
+		 * also know as device number and needs to be
+		 * qualified by bus and function number to specify a
+		 * particular function. */
+		if (dev_type != PCI_EXP_TYPE_ENDPOINT &&
+		    dev_type != PCI_EXP_TYPE_LEG_END) {
+			printk(KERN_ERR
+			       "%s PCIe device is not an endpoint (type %d)\n",
+				pci_name(dev), dev_type);
+			goto err_out;
+		}
+
+	} else {
+		/* This is a function on a different slot.  This means
+		 * there's something strange with the topology.  I
+		 * thought PCIe was point-to-point. */
+		printk(KERN_ERR "%s Can't tune performance of device\n",
+			pci_name(dev));
+		goto err_out;
+	}
+
+	/* Query the allowable maximum payload. */
+	rc = pci_read_config_dword(dev, pos + PCI_EXP_DEVCAP, &dev_cap);
+	if (rc) {
+		printk(KERN_ERR "%s Error %d reading PCIe capabilities\n",
+			pci_name(dev), rc);
+		goto err_out;
+	}
+
+	/* The configured maximum payload size must be set to the same
+	 * value for all devices and ports on the bus.  It mustn't
+	 * exceed the maximum payload capability for any of the
+	 * devices.  Here, we limit the payload size to the maximum
+	 * supported by this device.  NB. The encodings used for the
+	 * two fields are the same. */
+	dev_max_payload = (dev_cap & PCI_EXP_DEVCAP_PAYLOAD) >> 0;
+	if (tweaks->max_payload_size != -1 &&
+	    tweaks->max_payload_size > dev_max_payload)
+		tweaks->max_payload_size = dev_max_payload;
+
+	return;
+
+err_out:
+	tweaks->max_payload_size = -1;
+}
+
+
+static void efx_pcie_perform_tweaks(struct pci_dev *dev,
+				    const struct efx_pcie_tweaks *tweaks)
+{
+	int pos;
+	int rc;
+	int max_read_request_size = -1;
+	int max_payload_size = -1;
+	u16 dev_ctl_orig = -1;
+	u16 dev_ctl = -1;
+
+	pos = pci_find_capability(dev, PCI_CAP_ID_EXP);
+	if (pos <= 0) {
+		printk(KERN_INFO "Couldn't find PCIe capabilities of %s\n",
+			 pci_name(dev));
+		goto err_out;
+	}
+
+	if (dev == tweaks->bus->self) {
+		/* This is the root port.  Don't set the max read
+		 * size.  Instead, disable read coalescing if
+		 * required. */
+		if (tweaks->disable_bridge_read_coalesce) {
+			u16 read_merge, read_merge2;
+
+			EFX_BUG_ON_PARANOID(tweaks->bridge_vendor !=
+					    dev->vendor);
+			EFX_BUG_ON_PARANOID(tweaks->bridge_devid !=
+					    dev->device);
+			pci_read_config_word(dev, PCI_5000_READ_MERGE_REG,
+					     &read_merge);
+			read_merge2 = read_merge;
+			read_merge2 &= ~(1 << PCI_5000_READ_MERGE_BIT);
+			printk(KERN_INFO "Changing PCIe read merging of %s "
+				 "from 0x%x to 0x%x\n", pci_name(dev),
+				 read_merge, read_merge2);
+			pci_write_config_word(dev, PCI_5000_READ_MERGE_REG,
+					      read_merge2);
+		}
+
+	} else if (dev->bus == tweaks->bus &&
+		   PCI_SLOT(dev->devfn) == tweaks->slot) {
+		/* This is a function on the correct slot.  Adjust the
+		 * max read request.  Only adjust this on the device
+		 * and not on the root port. */
+		if (tweaks->max_read_request_size != -1) {
+			printk(KERN_INFO "Setting PCIe max read request size"
+				 " on %s to %d\n", pci_name(dev),
+				 128 << tweaks->max_read_request_size);
+			max_read_request_size = tweaks->max_read_request_size;
+		}
+
+	} else {
+		/* This indicates a strange topology - we're not alone
+		   on the bus. */
+		if (tweaks->max_payload_size != -1)
+			printk(KERN_ERR "%s Can't tune performance\n",
+				pci_name(dev));
+		goto err_out;
+	}
+
+	if (tweaks->max_payload_size != -1) {
+		printk(KERN_INFO "Setting PCIe max payload size on %s to %d\n",
+			 pci_name(dev), 128 << tweaks->max_payload_size);
+		max_payload_size = tweaks->max_payload_size;
+	}
+
+	/* Update the configuration word as quickly as possible
+	 * because there's no locking. */
+	rc = pci_read_config_word(dev, pos + PCI_EXP_DEVCTL, &dev_ctl_orig);
+	if (rc) {
+		printk(KERN_ERR "%s Error %d reading PCIe control\n",
+		       pci_name(dev), rc);
+		goto err_out;
+	}
+	dev_ctl = dev_ctl_orig;
+
+	if (max_payload_size != -1) {
+		dev_ctl &= ~PCI_EXP_DEVCTL_PAYLOAD;
+		dev_ctl |= tweaks->max_payload_size << 5;
+	}
+
+	if (max_read_request_size != -1) {
+		dev_ctl &= ~PCI_EXP_DEVCTL_READRQ;
+		dev_ctl |= max_read_request_size << 12;
+	}
+
+	if (dev_ctl != dev_ctl_orig) {
+		rc = pci_write_config_word(dev, pos + PCI_EXP_DEVCTL, dev_ctl);
+		if (rc) {
+			printk(KERN_ERR "%s Error %d writing PCIe control\n",
+				pci_name(dev), rc);
+			goto err_out;
+		}
+	}
+
+	return;
+
+err_out:
+	/* If something went wrong setting the payload size, the
+	 * payload sizes on the bus will be inconsistent. */
+	if (tweaks->max_payload_size != -1)
+		printk(KERN_ERR "%s Performance tuning went wrong."
+		       "  Expect badness.\n", pci_name(dev));
+}
+
+
+static void efx_pcie_tweak_performance(struct efx_dl_device *efx_dev,
+				       const char *name)
+{
+	/* Traverse the PCI bus looking for registers to tweak. */
+	struct efx_pcie_tweaks tweaks;
+	struct pci_dev *root_dev;
+	struct pci_dev *pci_dev;
+	int mpl = ((pcie_max_payload_size != PARAM_AUTO) ?
+		   pcie_max_payload_size : PCIE_MPL_HPERF);
+	int mrr = ((pcie_max_read_request_size != PARAM_AUTO) ?
+		   pcie_max_read_request_size : PCIE_MRR_HPERF);
+
+	switch (mpl) {
+	case PARAM_DIS:  tweaks.max_payload_size = -1; break;
+	case 128:        tweaks.max_payload_size = 0;  break;
+	case 256:        tweaks.max_payload_size = 1;  break;
+	case 512:        tweaks.max_payload_size = 2;  break;
+	case 1024:       tweaks.max_payload_size = 3;  break;
+	case 2048:       tweaks.max_payload_size = 4;  break;
+	case 4096:       tweaks.max_payload_size = 5;  break;
+	default:
+		printk(KERN_ERR "%s Invalid pcie_max_payload_size %d.\n",
+			name, mpl);
+		tweaks.max_payload_size = -1;
+		break;
+	}
+
+	switch (mrr) {
+	case PARAM_DIS: tweaks.max_read_request_size = -1; break;
+	case 128:       tweaks.max_read_request_size = 0;  break;
+	case 256:       tweaks.max_read_request_size = 1;  break;
+	case 512:       tweaks.max_read_request_size = 2;  break;
+	case 1024:      tweaks.max_read_request_size = 3;  break;
+	case 2048:      tweaks.max_read_request_size = 4;  break;
+	case 4096:      tweaks.max_read_request_size = 5;  break;
+	default:
+		printk(KERN_ERR "%s Invalid pcie_max_read_request_size %d.\n",
+			name, mrr);
+		tweaks.max_read_request_size = -1;
+		break;
+	}
+
+	tweaks.disable_bridge_read_coalesce = (disable_bridge_read_coalesce
+					       == PARAM_AUTO);
+
+	tweaks.bridge_vendor = -1;
+	tweaks.bridge_devid = -1;
+	tweaks.bus = efx_dev->pci_dev->bus;
+	tweaks.slot = PCI_SLOT(efx_dev->pci_dev->devfn);
+	root_dev = tweaks.bus->self;
+	if (!root_dev) {
+		printk(KERN_ERR "%s PCI bus '%s' has no root port.\n",
+			name, tweaks.bus->name);
+		return;
+	}
+
+	if (tweaks.max_payload_size != -1 || tweaks.max_read_request_size != -1) {
+		/* Check the values to be modified. */
+		efx_pcie_check_tweaks(root_dev, &tweaks);
+		pci_dev = NULL;
+		while (1) {
+			pci_dev = pci_get_device(PCI_ANY_ID, PCI_ANY_ID,
+						 pci_dev);
+			if (pci_dev == NULL)
+				break;
+			if (pci_dev->bus == tweaks.bus)
+				efx_pcie_check_tweaks(pci_dev, &tweaks);
+			/* No need to drop the reference to pci_dev
+			 * here because it will be dropped by
+			 * pci_get_device next time round the loop. */
+		}
+	}
+
+	if (tweaks.max_payload_size != -1 || tweaks.max_read_request_size != -1) {
+		/* Modify the values. */
+		efx_pcie_perform_tweaks(root_dev, &tweaks);
+		pci_dev = NULL;
+		while (1) {
+			pci_dev = pci_get_device(PCI_ANY_ID, PCI_ANY_ID,
+						 pci_dev);
+			if (pci_dev == NULL)
+				break;
+			if (pci_dev->bus == tweaks.bus)
+				efx_pcie_perform_tweaks(pci_dev, &tweaks);
+			/* No need to drop the reference to pci_dev
+			 * here because it will be dropped by
+			 * pci_get_device next time round the loop. */
+		}
+	}
+#ifdef EFX_HAVE_PM_IDLE
+	/* Enable the enhanced idle loop on Intel PCIe chipsets. */
+	if (!xen_domain() &&
+	    root_dev->vendor == 0x8086 &&
+	    (efx_dev->pci_dev->device == FALCON_A_P_DEVID))
+		efx_idle_enhance();
+#endif
+}
+
+
+/*****************************************************************************/
+
+static int efx_tweak_probe(struct efx_dl_device *efx_dev,
+			   const struct net_device *net_dev,
+			   const struct efx_dl_device_info *dev_info,
+			   const char *silicon_rev)
+{
+	if ((efx_dev->pci_dev->device == FALCON_A_P_DEVID) || tweak_pcie)
+		efx_pcie_tweak_performance(efx_dev, net_dev->name);
+
+	return 0;
+}
+
+/*****************************************************************************/
+
+static struct efx_dl_driver efx_tweak_driver = {
+	.name = "sfc_tune",
+	.probe = efx_tweak_probe,
+};
+
+static int __init efx_tweak_init_module(void)
+{
+#ifdef EFX_HAVE_PM_IDLE
+	int rc;
+
+	if ((rc = efx_idle_init()) != 0)
+		return rc;
+#endif
+
+	return efx_dl_register_driver(&efx_tweak_driver);
+}
+
+static void __exit efx_tweak_exit_module(void)
+{
+	efx_dl_unregister_driver(&efx_tweak_driver);
+#ifdef EFX_HAVE_PM_IDLE
+	efx_idle_fini();
+#endif
+}
+
+module_init(efx_tweak_init_module);
+module_exit(efx_tweak_exit_module);
+
+MODULE_AUTHOR("Solarflare Communications");
+MODULE_DESCRIPTION("System tuning for high performance of SFC4000");
+MODULE_LICENSE("GPL");
+
+module_param(tweak_pcie, uint, 0644);
+MODULE_PARM_DESC(tweak_pcie, "Force PCIe settings to be tuned");
+
+module_param(pcie_max_payload_size, int, 0444);
+MODULE_PARM_DESC(pcie_max_payload_size,
+		 "PCIe maximum payload size or 0=>auto -1=>leave");
+
+module_param(pcie_max_read_request_size, int, 0444);
+MODULE_PARM_DESC(pcie_max_read_request_size,
+		 "PCIe maximum read request size or 0=>auto -1=>leave");
+
+module_param(disable_bridge_read_coalesce, int, 0444);
+MODULE_PARM_DESC(disable_bridge_read_coalesce,
+		 "Disable read coalescing on Intel 5000 chipset. 0=>auto -1=>leave");
diff -r 5b3d4d3c1166 drivers/net/sfc/tx.c
--- a/drivers/net/sfc/tx.c	Fri Nov 05 15:20:28 2010 +0000
+++ b/drivers/net/sfc/tx.c	Tue Nov 09 10:06:27 2010 +0000
@@ -1,7 +1,7 @@
 /****************************************************************************
  * Driver for Solarflare Solarstorm network controllers and boards
  * Copyright 2005-2006 Fen Systems Ltd.
- * Copyright 2005-2008 Solarflare Communications Inc.
+ * Copyright 2005-2009 Solarflare Communications Inc.
  *
  * This program is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 as published
@@ -12,12 +12,21 @@
 #include <linux/tcp.h>
 #include <linux/ip.h>
 #include <linux/in.h>
+#include <linux/ipv6.h>
+#include <linux/slab.h>
+#include <net/ipv6.h>
 #include <linux/if_ether.h>
+#if !defined(EFX_USE_KCOMPAT)
 #include <linux/highmem.h>
+#else
+#include <linux/version.h>
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,20)
+#include <linux/highmem.h>
+#endif
+#endif
 #include "net_driver.h"
-#include "tx.h"
 #include "efx.h"
-#include "falcon.h"
+#include "nic.h"
 #include "workarounds.h"
 
 /*
@@ -26,35 +35,48 @@
  * The tx_queue descriptor ring fill-level must fall below this value
  * before we restart the netif queue
  */
-#define EFX_NETDEV_TX_THRESHOLD(_tx_queue)	\
-	(_tx_queue->efx->type->txd_ring_mask / 2u)
+#define EFX_TXQ_THRESHOLD(_efx) ((_efx)->txq_entries / 2u)
 
-/* We want to be able to nest calls to netif_stop_queue(), since each
- * channel can have an individual stop on the queue.
- */
-void efx_stop_queue(struct efx_nic *efx)
+/* We need to be able to nest calls to netif_tx_stop_queue(), partly
+ * because of the 2 hardware queues associated with each core queue,
+ * but also so that we can inhibit TX for reasons other than a full
+ * hardware queue. */
+void efx_stop_queue(struct efx_channel *channel)
 {
-	spin_lock_bh(&efx->netif_stop_lock);
-	EFX_TRACE(efx, "stop TX queue\n");
+	struct efx_nic *efx = channel->efx;
+	struct efx_tx_queue *tx_queue = efx_channel_get_tx_queue(channel, 0);
 
-	atomic_inc(&efx->netif_stop_count);
-	netif_stop_queue(efx->net_dev);
+	if (!tx_queue)
+		return;
 
-	spin_unlock_bh(&efx->netif_stop_lock);
+	spin_lock_bh(&channel->tx_stop_lock);
+	netif_vdbg(efx, tx_queued, efx->net_dev, "stop TX queue\n");
+
+	atomic_inc(&channel->tx_stop_count);
+	netif_tx_stop_queue(
+		netdev_get_tx_queue(efx->net_dev,
+				    tx_queue->queue / EFX_TXQ_TYPES));
+
+	spin_unlock_bh(&channel->tx_stop_lock);
 }
 
-/* Wake netif's TX queue
- * We want to be able to nest calls to netif_stop_queue(), since each
- * channel can have an individual stop on the queue.
- */
-void efx_wake_queue(struct efx_nic *efx)
+/* Decrement core TX queue stop count and wake it if the count is 0 */
+void efx_wake_queue(struct efx_channel *channel)
 {
+	struct efx_nic *efx = channel->efx;
+	struct efx_tx_queue *tx_queue = efx_channel_get_tx_queue(channel, 0);
+
+	if (!tx_queue)
+		return;
+
 	local_bh_disable();
-	if (atomic_dec_and_lock(&efx->netif_stop_count,
-				&efx->netif_stop_lock)) {
-		EFX_TRACE(efx, "waking TX queue\n");
-		netif_wake_queue(efx->net_dev);
-		spin_unlock(&efx->netif_stop_lock);
+	if (atomic_dec_and_lock(&channel->tx_stop_count,
+				&channel->tx_stop_lock)) {
+		netif_vdbg(efx, tx_queued, efx->net_dev, "waking TX queue\n");
+		netif_tx_wake_queue(
+			netdev_get_tx_queue(efx->net_dev,
+					    tx_queue->queue / EFX_TXQ_TYPES));
+		spin_unlock(&channel->tx_stop_lock);
 	}
 	local_bh_enable();
 }
@@ -79,8 +101,6 @@ static void efx_dequeue_buffer(struct ef
 	if (buffer->skb) {
 		dev_kfree_skb_any((struct sk_buff *) buffer->skb);
 		buffer->skb = NULL;
-		EFX_TRACE(tx_queue->efx, "TX queue %d transmission id %x "
-			  "complete\n", tx_queue->queue, read_ptr);
 	}
 }
 
@@ -125,6 +145,24 @@ static void efx_tsoh_free(struct efx_tx_
 }
 
 
+static inline unsigned
+efx_max_tx_len(struct efx_nic *efx, dma_addr_t dma_addr)
+{
+	/* Depending on the NIC revision, we can use descriptor
+	 * lengths up to 8K or 8K-1.  However, since PCI Express
+	 * devices must split read requests at 4K boundaries, there is
+	 * little benefit from using descriptors that cross those
+	 * boundaries and we keep things simple by not doing so.
+	 */
+	unsigned len = (~dma_addr & 0xfff) + 1;
+
+	/* Work around hardware bug for unaligned buffers. */
+	if (EFX_WORKAROUND_5391(efx) && (dma_addr & 0xf))
+		len = min_t(unsigned, len, 512 - (dma_addr & 0xf));
+
+	return len;
+}
+
 /*
  * Add a socket buffer to a TX queue
  *
@@ -135,11 +173,13 @@ static void efx_tsoh_free(struct efx_tx_
  * If any DMA mapping fails, any mapped fragments will be unmapped,
  * the queue's insert pointer will be restored to its original value.
  *
+ * This function is split out from efx_hard_start_xmit to allow the
+ * loopback test to direct packets via specific TX queues.
+ *
  * Returns NETDEV_TX_OK or NETDEV_TX_BUSY
  * You must hold netif_tx_lock() to call this function.
  */
-static netdev_tx_t efx_enqueue_skb(struct efx_tx_queue *tx_queue,
-					 struct sk_buff *skb)
+netdev_tx_t efx_enqueue_skb(struct efx_tx_queue *tx_queue, struct sk_buff *skb)
 {
 	struct efx_nic *efx = tx_queue->efx;
 	struct pci_dev *pci_dev = efx->pci_dev;
@@ -147,7 +187,7 @@ static netdev_tx_t efx_enqueue_skb(struc
 	skb_frag_t *fragment;
 	struct page *page;
 	int page_offset;
-	unsigned int len, unmap_len = 0, fill_level, insert_ptr, misalign;
+	unsigned int len, unmap_len = 0, fill_level, insert_ptr;
 	dma_addr_t dma_addr, unmap_addr = 0;
 	unsigned int dma_len;
 	bool unmap_single;
@@ -156,7 +196,7 @@ static netdev_tx_t efx_enqueue_skb(struc
 
 	EFX_BUG_ON_PARANOID(tx_queue->write_count != tx_queue->insert_count);
 
-	if (skb_shinfo((struct sk_buff *)skb)->gso_size)
+	if (skb_shinfo(skb)->gso_size)
 		return efx_enqueue_skb_tso(tx_queue, skb);
 
 	/* Get size of the initial fragment */
@@ -171,14 +211,18 @@ static netdev_tx_t efx_enqueue_skb(struc
 	}
 
 	fill_level = tx_queue->insert_count - tx_queue->old_read_count;
-	q_space = efx->type->txd_ring_mask - 1 - fill_level;
+	q_space = efx->txq_entries - 1 - fill_level;
 
 	/* Map for DMA.  Use pci_map_single rather than pci_map_page
 	 * since this is more efficient on machines with sparse
 	 * memory.
 	 */
+#if defined(EFX_NOT_UPSTREAM) && defined(EFX_VMWARE_3_DOT_5)
+	dma_addr = skb->headMA;
+#else
 	unmap_single = true;
 	dma_addr = pci_map_single(pci_dev, skb->data, len, PCI_DMA_TODEVICE);
+#endif
 
 	/* Process all fragments */
 	while (1) {
@@ -208,16 +252,14 @@ static netdev_tx_t efx_enqueue_skb(struc
 					&tx_queue->read_count;
 				fill_level = (tx_queue->insert_count
 					      - tx_queue->old_read_count);
-				q_space = (efx->type->txd_ring_mask - 1 -
-					   fill_level);
+				q_space = efx->txq_entries - 1 - fill_level;
 				if (unlikely(q_space-- <= 0))
 					goto stop;
 				smp_mb();
 				--tx_queue->stopped;
 			}
 
-			insert_ptr = (tx_queue->insert_count &
-				      efx->type->txd_ring_mask);
+			insert_ptr = tx_queue->insert_count & tx_queue->ptr_mask;
 			buffer = &tx_queue->buffer[insert_ptr];
 			efx_tsoh_free(tx_queue, buffer);
 			EFX_BUG_ON_PARANOID(buffer->tsoh);
@@ -226,13 +268,9 @@ static netdev_tx_t efx_enqueue_skb(struc
 			EFX_BUG_ON_PARANOID(!buffer->continuation);
 			EFX_BUG_ON_PARANOID(buffer->unmap_len);
 
-			dma_len = (((~dma_addr) & efx->type->tx_dma_mask) + 1);
-			if (likely(dma_len > len))
+			dma_len = efx_max_tx_len(efx, dma_addr);
+			if (likely(dma_len >= len))
 				dma_len = len;
-
-			misalign = (unsigned)dma_addr & efx->type->bug5391_mask;
-			if (misalign && dma_len + misalign > 512)
-				dma_len = 512 - misalign;
 
 			/* Fill out per descriptor fields */
 			buffer->len = dma_len;
@@ -266,30 +304,37 @@ static netdev_tx_t efx_enqueue_skb(struc
 	buffer->continuation = false;
 
 	/* Pass off to hardware */
-	falcon_push_buffers(tx_queue);
+	efx_nic_push_buffers(tx_queue);
+
+#if defined(EFX_NOT_UPSTREAM)
+	tx_queue->tx_packets++;
+	tx_queue->tx_bytes += skb->len;
+#endif
 
 	return NETDEV_TX_OK;
 
  pci_err:
-	EFX_ERR_RL(efx, " TX queue %d could not map skb with %d bytes %d "
-		   "fragments for DMA\n", tx_queue->queue, skb->len,
-		   skb_shinfo(skb)->nr_frags + 1);
+	netif_err(efx, tx_err, efx->net_dev,
+		  " TX queue %d could not map skb with %d bytes %d "
+		  "fragments for DMA\n", tx_queue->queue, skb->len,
+		  skb_shinfo(skb)->nr_frags + 1);
 
 	/* Mark the packet as transmitted, and free the SKB ourselves */
-	dev_kfree_skb_any((struct sk_buff *)skb);
+	dev_kfree_skb_any(skb);
 	goto unwind;
 
  stop:
 	rc = NETDEV_TX_BUSY;
 
+	/* Stop the queue if it wasn't stopped before. */
 	if (tx_queue->stopped == 1)
-		efx_stop_queue(efx);
+		efx_stop_queue(tx_queue->channel);
 
  unwind:
 	/* Work backwards until we hit the original insert pointer value */
 	while (tx_queue->insert_count != tx_queue->write_count) {
 		--tx_queue->insert_count;
-		insert_ptr = tx_queue->insert_count & efx->type->txd_ring_mask;
+		insert_ptr = tx_queue->insert_count & tx_queue->ptr_mask;
 		buffer = &tx_queue->buffer[insert_ptr];
 		efx_dequeue_buffer(tx_queue, buffer);
 		buffer->len = 0;
@@ -318,46 +363,31 @@ static void efx_dequeue_buffers(struct e
 {
 	struct efx_nic *efx = tx_queue->efx;
 	unsigned int stop_index, read_ptr;
-	unsigned int mask = tx_queue->efx->type->txd_ring_mask;
 
-	stop_index = (index + 1) & mask;
-	read_ptr = tx_queue->read_count & mask;
+	stop_index = (index + 1) & tx_queue->ptr_mask;
+	read_ptr = tx_queue->read_count & tx_queue->ptr_mask;
 
 	while (read_ptr != stop_index) {
 		struct efx_tx_buffer *buffer = &tx_queue->buffer[read_ptr];
 		if (unlikely(buffer->len == 0)) {
-			EFX_ERR(tx_queue->efx, "TX queue %d spurious TX "
-				"completion id %x\n", tx_queue->queue,
-				read_ptr);
+			netif_err(efx, hw, efx->net_dev,
+				  "TX queue %d spurious TX completion id %x\n",
+				  tx_queue->queue, read_ptr);
+			atomic_inc(&efx->errors.spurious_tx);
 			efx_schedule_reset(efx, RESET_TYPE_TX_SKIP);
 			return;
 		}
 
+		netif_vdbg(efx, tx_done, efx->net_dev,
+			   "TX queue %d transmission id %x omplete\n",
+			   tx_queue->queue, read_ptr);
 		efx_dequeue_buffer(tx_queue, buffer);
 		buffer->continuation = true;
 		buffer->len = 0;
 
 		++tx_queue->read_count;
-		read_ptr = tx_queue->read_count & mask;
+		read_ptr = tx_queue->read_count & tx_queue->ptr_mask;
 	}
-}
-
-/* Initiate a packet transmission on the specified TX queue.
- * Note that returning anything other than NETDEV_TX_OK will cause the
- * OS to free the skb.
- *
- * This function is split out from efx_hard_start_xmit to allow the
- * loopback test to direct packets via specific TX queues.  It is
- * therefore a non-static inline, so as not to penalise performance
- * for non-loopback transmissions.
- *
- * Context: netif_tx_lock held
- */
-inline netdev_tx_t efx_xmit(struct efx_nic *efx,
-			   struct efx_tx_queue *tx_queue, struct sk_buff *skb)
-{
-	/* Map fragments for DMA and add to TX queue */
-	return efx_enqueue_skb(tx_queue, skb);
 }
 
 /* Initiate a packet transmission.  We use one channel per CPU
@@ -370,40 +400,49 @@ inline netdev_tx_t efx_xmit(struct efx_n
  * OS to free the skb.
  */
 netdev_tx_t efx_hard_start_xmit(struct sk_buff *skb,
-				      struct net_device *net_dev)
+				struct net_device *net_dev)
 {
 	struct efx_nic *efx = netdev_priv(net_dev);
 	struct efx_tx_queue *tx_queue;
 	enum efx_veto veto;
+	int rc;
 
-	if (unlikely(efx->port_inhibited))
-		return NETDEV_TX_BUSY;
-
-	if (likely(skb->ip_summed == CHECKSUM_PARTIAL))
-		tx_queue = &efx->tx_queue[EFX_TX_QUEUE_OFFLOAD_CSUM];
-	else
-		tx_queue = &efx->tx_queue[EFX_TX_QUEUE_NO_CSUM];
+	tx_queue = efx_get_tx_queue(efx, skb_get_queue_mapping(skb),
+				    skb->ip_summed == CHECKSUM_PARTIAL ?
+				    EFX_TXQ_TYPE_OFFLOAD : 0);
 
 	/* See if driverlink wants to veto the packet. */
 	veto = EFX_DL_CALLBACK(efx, tx_packet, skb);
 	if (unlikely(veto)) {
-		EFX_DL_LOG(efx, "TX queue %d packet vetoed by "
-			   "driverlink %s driver\n", tx_queue->queue,
-			   efx->dl_cb_dev.tx_packet->driver->name);
+		netif_dbg(efx, tx_err, efx->net_dev,
+			  "TX queue %d packet vetoed by driverlink %s driver\n",
+			  tx_queue->queue,
+			  efx->dl_cb_dev.tx_packet->driver->name);
 		/* Free the skb; nothing else will do it */
 		dev_kfree_skb_any(skb);
 		return NETDEV_TX_OK;
 	}
 
-	return efx_xmit(efx, tx_queue, skb);
+	rc = efx_enqueue_skb(tx_queue, skb);
+#if defined(EFX_USE_KCOMPAT) && defined(EFX_USE_NET_DEVICE_TRANS_START)
+	if (likely(rc == NETDEV_TX_OK)) {
+		/* Update last TX timer */
+		efx->net_dev->trans_start = jiffies;
+	}
+#endif
+	return rc;
 }
 
+#if defined(EFX_USE_KCOMPAT) && defined(EFX_USE_FASTCALL)
+void fastcall efx_xmit_done(struct efx_tx_queue *tx_queue, unsigned int index)
+#else
 void efx_xmit_done(struct efx_tx_queue *tx_queue, unsigned int index)
+#endif
 {
 	unsigned fill_level;
 	struct efx_nic *efx = tx_queue->efx;
 
-	EFX_BUG_ON_PARANOID(index > efx->type->txd_ring_mask);
+	EFX_BUG_ON_PARANOID(index > tx_queue->ptr_mask);
 
 	efx_dequeue_buffers(tx_queue, index);
 
@@ -413,7 +452,7 @@ void efx_xmit_done(struct efx_tx_queue *
 	smp_mb();
 	if (unlikely(tx_queue->stopped) && likely(efx->port_enabled)) {
 		fill_level = tx_queue->insert_count - tx_queue->read_count;
-		if (fill_level < EFX_NETDEV_TX_THRESHOLD(tx_queue)) {
+		if (fill_level < EFX_TXQ_THRESHOLD(efx)) {
 			EFX_BUG_ON_PARANOID(!efx_dev_registered(efx));
 
 			/* Do this under netif_tx_lock(), to avoid racing
@@ -421,7 +460,7 @@ void efx_xmit_done(struct efx_tx_queue *
 			netif_tx_lock(efx->net_dev);
 			if (tx_queue->stopped) {
 				tx_queue->stopped = 0;
-				efx_wake_queue(efx);
+				efx_wake_queue(tx_queue->channel);
 			}
 			netif_tx_unlock(efx->net_dev);
 		}
@@ -431,21 +470,28 @@ int efx_probe_tx_queue(struct efx_tx_que
 int efx_probe_tx_queue(struct efx_tx_queue *tx_queue)
 {
 	struct efx_nic *efx = tx_queue->efx;
-	unsigned int txq_size;
+	unsigned int entries;
 	int i, rc;
 
-	EFX_LOG(efx, "creating TX queue %d\n", tx_queue->queue);
+	/* Create the smallest power-of-two aligned ring */
+	entries = max(roundup_pow_of_two(efx->txq_entries), EFX_MIN_DMAQ_SIZE);
+	EFX_BUG_ON_PARANOID(entries > EFX_MAX_DMAQ_SIZE);
+	tx_queue->ptr_mask = entries - 1;
+
+	netif_dbg(efx, probe, efx->net_dev,
+		  "creating TX queue %d size 0x%x mask 0x%x\n",
+		  tx_queue->queue, efx->txq_entries, tx_queue->ptr_mask);
 
 	/* Allocate software ring */
-	txq_size = (efx->type->txd_ring_mask + 1) * sizeof(*tx_queue->buffer);
-	tx_queue->buffer = kzalloc(txq_size, GFP_KERNEL);
+	tx_queue->buffer = kzalloc(entries * sizeof(*tx_queue->buffer),
+				   GFP_KERNEL);
 	if (!tx_queue->buffer)
 		return -ENOMEM;
-	for (i = 0; i <= efx->type->txd_ring_mask; ++i)
+	for (i = 0; i <= tx_queue->ptr_mask; ++i)
 		tx_queue->buffer[i].continuation = true;
 
 	/* Allocate hardware ring */
-	rc = falcon_probe_tx(tx_queue);
+	rc = efx_nic_probe_tx(tx_queue);
 	if (rc)
 		goto fail;
 
@@ -459,7 +505,8 @@ int efx_probe_tx_queue(struct efx_tx_que
 
 void efx_init_tx_queue(struct efx_tx_queue *tx_queue)
 {
-	EFX_LOG(tx_queue->efx, "initialising TX queue %d\n", tx_queue->queue);
+	netif_dbg(tx_queue->efx, drv, tx_queue->efx->net_dev,
+		  "initialising TX queue %d\n", tx_queue->queue);
 
 	tx_queue->insert_count = 0;
 	tx_queue->write_count = 0;
@@ -468,7 +515,7 @@ void efx_init_tx_queue(struct efx_tx_que
 	BUG_ON(tx_queue->stopped);
 
 	/* Set up TX descriptor ring */
-	falcon_init_tx(tx_queue);
+	efx_nic_init_tx(tx_queue);
 }
 
 void efx_release_tx_buffers(struct efx_tx_queue *tx_queue)
@@ -480,8 +527,7 @@ void efx_release_tx_buffers(struct efx_t
 
 	/* Free any buffers left in the ring */
 	while (tx_queue->read_count != tx_queue->write_count) {
-		buffer = &tx_queue->buffer[tx_queue->read_count &
-					   tx_queue->efx->type->txd_ring_mask];
+		buffer = &tx_queue->buffer[tx_queue->read_count & tx_queue->ptr_mask];
 		efx_dequeue_buffer(tx_queue, buffer);
 		buffer->continuation = true;
 		buffer->len = 0;
@@ -492,10 +538,11 @@ void efx_release_tx_buffers(struct efx_t
 
 void efx_fini_tx_queue(struct efx_tx_queue *tx_queue)
 {
-	EFX_LOG(tx_queue->efx, "shutting down TX queue %d\n", tx_queue->queue);
+	netif_dbg(tx_queue->efx, drv, tx_queue->efx->net_dev,
+		  "shutting down TX queue %d\n", tx_queue->queue);
 
 	/* Flush TX queue, remove descriptor ring */
-	falcon_fini_tx(tx_queue);
+	efx_nic_fini_tx(tx_queue);
 
 	efx_release_tx_buffers(tx_queue);
 
@@ -505,14 +552,15 @@ void efx_fini_tx_queue(struct efx_tx_que
 	/* Release queue's stop on port, if any */
 	if (tx_queue->stopped) {
 		tx_queue->stopped = 0;
-		efx_wake_queue(tx_queue->efx);
+		efx_wake_queue(tx_queue->channel);
 	}
 }
 
 void efx_remove_tx_queue(struct efx_tx_queue *tx_queue)
 {
-	EFX_LOG(tx_queue->efx, "destroying TX queue %d\n", tx_queue->queue);
-	falcon_remove_tx(tx_queue);
+	netif_dbg(tx_queue->efx, drv, tx_queue->efx->net_dev,
+		  "destroying TX queue %d\n", tx_queue->queue);
+	efx_nic_remove_tx(tx_queue);
 
 	kfree(tx_queue->buffer);
 	tx_queue->buffer = NULL;
@@ -551,6 +599,7 @@ void efx_remove_tx_queue(struct efx_tx_q
 #define ETH_HDR_LEN(skb)  (skb_network_header(skb) - (skb)->data)
 #define SKB_TCP_OFF(skb)  PTR_DIFF(tcp_hdr(skb), (skb)->data)
 #define SKB_IPV4_OFF(skb) PTR_DIFF(ip_hdr(skb), (skb)->data)
+#define SKB_IPV6_OFF(skb) PTR_DIFF(ipv6_hdr(skb), (skb)->data)
 
 /**
  * struct tso_state - TSO state for an SKB
@@ -563,6 +612,7 @@ void efx_remove_tx_queue(struct efx_tx_q
  * @unmap_len: Length of SKB fragment
  * @unmap_addr: DMA address of SKB fragment
  * @unmap_single: DMA single vs page mapping flag
+ * @protocol: Network protocol (after any VLAN header)
  * @header_len: Number of bytes of header
  * @full_packet_size: Number of bytes to put in each outgoing segment
  *
@@ -583,21 +633,38 @@ struct tso_state {
 	dma_addr_t unmap_addr;
 	bool unmap_single;
 
+	__be16 protocol;
 	unsigned header_len;
 	int full_packet_size;
 };
 
 
+static inline void prefetch_ptr(struct efx_tx_queue *tx_queue)
+{
+	unsigned insert_ptr = tx_queue->insert_count & tx_queue->ptr_mask;
+	char *ptr;
+
+	ptr = (char *) (tx_queue->buffer + insert_ptr);
+	prefetch(ptr);
+	prefetch(ptr + 0x80);
+
+	ptr = (char *) (((efx_qword_t *)tx_queue->txd.addr) + insert_ptr);
+	prefetch(ptr);
+	prefetch(ptr + 0x80);
+}
+
 /*
  * Verify that our various assumptions about sk_buffs and the conditions
- * under which TSO will be attempted hold true.
+ * under which TSO will be attempted hold true.  Return the protocol number.
  */
-static void efx_tso_check_safe(struct sk_buff *skb)
+static __be16 efx_tso_check_protocol(struct sk_buff *skb)
 {
 	__be16 protocol = skb->protocol;
 
 	EFX_BUG_ON_PARANOID(((struct ethhdr *)skb->data)->h_proto !=
 			    protocol);
+#if !defined(EFX_USE_KCOMPAT) || defined(EFX_USE_NETDEV_VLAN_FEATURES) || \
+	defined(NETIF_F_VLAN_TSO)
 	if (protocol == htons(ETH_P_8021Q)) {
 		/* Find the encapsulated protocol; reset network header
 		 * and transport header based on that. */
@@ -607,13 +674,23 @@ static void efx_tso_check_safe(struct sk
 		if (protocol == htons(ETH_P_IP))
 			skb_set_transport_header(skb, sizeof(*veh) +
 						 4 * ip_hdr(skb)->ihl);
+		else if (protocol == htons(ETH_P_IPV6))
+			skb_set_transport_header(skb, sizeof(*veh) +
+						 sizeof(struct ipv6hdr));
 	}
+#endif
 
-	EFX_BUG_ON_PARANOID(protocol != htons(ETH_P_IP));
-	EFX_BUG_ON_PARANOID(ip_hdr(skb)->protocol != IPPROTO_TCP);
+	if (protocol == htons(ETH_P_IP)) {
+		EFX_BUG_ON_PARANOID(ip_hdr(skb)->protocol != IPPROTO_TCP);
+	} else {
+		EFX_BUG_ON_PARANOID(protocol != htons(ETH_P_IPV6));
+		EFX_BUG_ON_PARANOID(ipv6_hdr(skb)->nexthdr != NEXTHDR_TCP);
+	}
 	EFX_BUG_ON_PARANOID((PTR_DIFF(tcp_hdr(skb), skb->data)
 			     + (tcp_hdr(skb)->doff << 2u)) >
 			    skb_headlen(skb));
+
+	return protocol;
 }
 
 
@@ -631,8 +708,8 @@ static int efx_tsoh_block_alloc(struct e
 
 	base_kva = pci_alloc_consistent(pci_dev, PAGE_SIZE, &dma_addr);
 	if (base_kva == NULL) {
-		EFX_ERR(tx_queue->efx, "Unable to allocate page for TSO"
-			" headers\n");
+		netif_err(tx_queue->efx, tx_err, tx_queue->efx->net_dev,
+			  "Unable to allocate page for TSO headers\n");
 		return -ENOMEM;
 	}
 
@@ -720,14 +797,14 @@ static int efx_tx_queue_insert(struct ef
 {
 	struct efx_tx_buffer *buffer;
 	struct efx_nic *efx = tx_queue->efx;
-	unsigned dma_len, fill_level, insert_ptr, misalign;
+	unsigned dma_len, fill_level, insert_ptr;
 	int q_space;
 
 	EFX_BUG_ON_PARANOID(len <= 0);
 
 	fill_level = tx_queue->insert_count - tx_queue->old_read_count;
 	/* -1 as there is no way to represent all descriptors used */
-	q_space = efx->type->txd_ring_mask - 1 - fill_level;
+	q_space = efx->txq_entries - 1 - fill_level;
 
 	while (1) {
 		if (unlikely(q_space-- <= 0)) {
@@ -743,7 +820,7 @@ static int efx_tx_queue_insert(struct ef
 				*(volatile unsigned *)&tx_queue->read_count;
 			fill_level = (tx_queue->insert_count
 				      - tx_queue->old_read_count);
-			q_space = efx->type->txd_ring_mask - 1 - fill_level;
+			q_space = efx->txq_entries - 1 - fill_level;
 			if (unlikely(q_space-- <= 0)) {
 				*final_buffer = NULL;
 				return 1;
@@ -752,13 +829,13 @@ static int efx_tx_queue_insert(struct ef
 			--tx_queue->stopped;
 		}
 
-		insert_ptr = tx_queue->insert_count & efx->type->txd_ring_mask;
+		insert_ptr = tx_queue->insert_count & tx_queue->ptr_mask;
 		buffer = &tx_queue->buffer[insert_ptr];
 		++tx_queue->insert_count;
 
 		EFX_BUG_ON_PARANOID(tx_queue->insert_count -
-				    tx_queue->read_count >
-				    efx->type->txd_ring_mask);
+				    tx_queue->read_count >=
+				    efx->txq_entries);
 
 		efx_tsoh_free(tx_queue, buffer);
 		EFX_BUG_ON_PARANOID(buffer->len);
@@ -769,12 +846,7 @@ static int efx_tx_queue_insert(struct ef
 
 		buffer->dma_addr = dma_addr;
 
-		/* Ensure we do not cross a boundary unsupported by H/W */
-		dma_len = (~dma_addr & efx->type->tx_dma_mask) + 1;
-
-		misalign = (unsigned)dma_addr & efx->type->bug5391_mask;
-		if (misalign && dma_len + misalign > 512)
-			dma_len = 512 - misalign;
+		dma_len = efx_max_tx_len(efx, dma_addr);
 
 		/* If there is enough space to send then do so */
 		if (dma_len >= len)
@@ -804,8 +876,7 @@ static void efx_tso_put_header(struct ef
 {
 	struct efx_tx_buffer *buffer;
 
-	buffer = &tx_queue->buffer[tx_queue->insert_count &
-				   tx_queue->efx->type->txd_ring_mask];
+	buffer = &tx_queue->buffer[tx_queue->insert_count & tx_queue->ptr_mask];
 	efx_tsoh_free(tx_queue, buffer);
 	EFX_BUG_ON_PARANOID(buffer->len);
 	EFX_BUG_ON_PARANOID(buffer->unmap_len);
@@ -830,9 +901,11 @@ static void efx_enqueue_unwind(struct ef
 	while (tx_queue->insert_count != tx_queue->write_count) {
 		--tx_queue->insert_count;
 		buffer = &tx_queue->buffer[tx_queue->insert_count &
-					   tx_queue->efx->type->txd_ring_mask];
+					   tx_queue->ptr_mask];
 		efx_tsoh_free(tx_queue, buffer);
 		EFX_BUG_ON_PARANOID(buffer->skb);
+		buffer->len = 0;
+		buffer->continuation = true;
 		if (buffer->unmap_len) {
 			unmap_addr = (buffer->dma_addr + buffer->len -
 				      buffer->unmap_len);
@@ -846,8 +919,6 @@ static void efx_enqueue_unwind(struct ef
 					       PCI_DMA_TODEVICE);
 			buffer->unmap_len = 0;
 		}
-		buffer->len = 0;
-		buffer->continuation = true;
 	}
 }
 
@@ -862,7 +933,10 @@ static void tso_start(struct tso_state *
 			  + PTR_DIFF(tcp_hdr(skb), skb->data));
 	st->full_packet_size = st->header_len + skb_shinfo(skb)->gso_size;
 
-	st->ipv4_id = ntohs(ip_hdr(skb)->id);
+	if (st->protocol == htons(ETH_P_IP))
+		st->ipv4_id = ntohs(ip_hdr(skb)->id);
+	else
+		st->ipv4_id = 0;
 	st->seqnum = ntohl(tcp_hdr(skb)->seq);
 
 	EFX_BUG_ON_PARANOID(tcp_hdr(skb)->urg);
@@ -977,7 +1051,6 @@ static int tso_start_new_packet(struct e
 				struct tso_state *st)
 {
 	struct efx_tso_header *tsoh;
-	struct iphdr *tsoh_iph;
 	struct tcphdr *tsoh_th;
 	unsigned ip_length;
 	u8 *header;
@@ -1001,7 +1074,6 @@ static int tso_start_new_packet(struct e
 
 	header = TSOH_BUFFER(tsoh);
 	tsoh_th = (struct tcphdr *)(header + SKB_TCP_OFF(skb));
-	tsoh_iph = (struct iphdr *)(header + SKB_IPV4_OFF(skb));
 
 	/* Copy and update the headers. */
 	memcpy(header, skb->data, st->header_len);
@@ -1019,11 +1091,22 @@ static int tso_start_new_packet(struct e
 		tsoh_th->fin = tcp_hdr(skb)->fin;
 		tsoh_th->psh = tcp_hdr(skb)->psh;
 	}
-	tsoh_iph->tot_len = htons(ip_length);
 
-	/* Linux leaves suitable gaps in the IP ID space for us to fill. */
-	tsoh_iph->id = htons(st->ipv4_id);
-	st->ipv4_id++;
+	if (st->protocol == htons(ETH_P_IP)) {
+		struct iphdr *tsoh_iph =
+			(struct iphdr *)(header + SKB_IPV4_OFF(skb));
+
+		tsoh_iph->tot_len = htons(ip_length);
+
+		/* Linux leaves suitable gaps in the IP ID space for us to fill. */
+		tsoh_iph->id = htons(st->ipv4_id);
+		st->ipv4_id++;
+	} else {
+		struct ipv6hdr *tsoh_iph =
+			(struct ipv6hdr *)(header + SKB_IPV6_OFF(skb));
+
+		tsoh_iph->payload_len = htons(ip_length - sizeof(*tsoh_iph));
+	}
 
 	st->packet_space = skb_shinfo(skb)->gso_size;
 	++tx_queue->tso_packets;
@@ -1031,9 +1114,12 @@ static int tso_start_new_packet(struct e
 	/* Form a descriptor for this header. */
 	efx_tso_put_header(tx_queue, tsoh, st->header_len);
 
+#if defined(EFX_NOT_UPSTREAM)
+	tx_queue->tx_packets++;
+#endif
+
 	return 0;
 }
-
 
 /**
  * efx_enqueue_skb_tso - segment and transmit a TSO socket buffer
@@ -1053,8 +1139,10 @@ static int efx_enqueue_skb_tso(struct ef
 	int frag_i, rc, rc2 = NETDEV_TX_OK;
 	struct tso_state state;
 
-	/* Verify TSO is safe - these checks should never fail. */
-	efx_tso_check_safe(skb);
+	prefetch(skb->data);
+
+	/* Find the packet protocol and sanity-check it */
+	state.protocol = efx_tso_check_protocol(skb);
 
 	EFX_BUG_ON_PARANOID(tx_queue->write_count != tx_queue->insert_count);
 
@@ -1081,6 +1169,8 @@ static int efx_enqueue_skb_tso(struct ef
 	if (tso_start_new_packet(tx_queue, skb, &state) < 0)
 		goto mem_err;
 
+	prefetch_ptr(tx_queue);
+
 	while (1) {
 		rc = tso_fill_packet_with_fragment(tx_queue, skb, &state);
 		if (unlikely(rc))
@@ -1103,15 +1193,20 @@ static int efx_enqueue_skb_tso(struct ef
 			goto mem_err;
 	}
 
+#if defined(EFX_NOT_UPSTREAM)
+	tx_queue->tx_bytes += skb->len;
+#endif
+
 	/* Pass off to hardware */
-	falcon_push_buffers(tx_queue);
+	efx_nic_push_buffers(tx_queue);
 
 	tx_queue->tso_bursts++;
 	return NETDEV_TX_OK;
 
  mem_err:
-	EFX_ERR(efx, "Out of memory for TSO headers, or PCI mapping error\n");
-	dev_kfree_skb_any((struct sk_buff *)skb);
+	netif_err(efx, tx_err, efx->net_dev,
+		  "Out of memory for TSO headers, or PCI mapping error\n");
+	dev_kfree_skb_any(skb);
 	goto unwind;
 
  stop:
@@ -1119,7 +1214,7 @@ static int efx_enqueue_skb_tso(struct ef
 
 	/* Stop the queue if it wasn't stopped before. */
 	if (tx_queue->stopped == 1)
-		efx_stop_queue(efx);
+		efx_stop_queue(tx_queue->channel);
 
  unwind:
 	/* Free the DMA mapping we were in the process of writing out */
@@ -1147,7 +1242,7 @@ static void efx_fini_tso(struct efx_tx_q
 	unsigned i;
 
 	if (tx_queue->buffer) {
-		for (i = 0; i <= tx_queue->efx->type->txd_ring_mask; ++i)
+		for (i = 0; i <= tx_queue->ptr_mask; ++i)
 			efx_tsoh_free(tx_queue, &tx_queue->buffer[i]);
 	}
 
diff -r 5b3d4d3c1166 drivers/net/sfc/tx.h
--- a/drivers/net/sfc/tx.h	Fri Nov 05 15:20:28 2010 +0000
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,25 +0,0 @@
-/****************************************************************************
- * Driver for Solarflare Solarstorm network controllers and boards
- * Copyright 2006 Fen Systems Ltd.
- * Copyright 2006-2008 Solarflare Communications Inc.
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 as published
- * by the Free Software Foundation, incorporated herein by reference.
- */
-
-#ifndef EFX_TX_H
-#define EFX_TX_H
-
-#include "net_driver.h"
-
-int efx_probe_tx_queue(struct efx_tx_queue *tx_queue);
-void efx_remove_tx_queue(struct efx_tx_queue *tx_queue);
-void efx_init_tx_queue(struct efx_tx_queue *tx_queue);
-void efx_fini_tx_queue(struct efx_tx_queue *tx_queue);
-
-netdev_tx_t efx_hard_start_xmit(struct sk_buff *skb,
-				      struct net_device *net_dev);
-void efx_release_tx_buffers(struct efx_tx_queue *tx_queue);
-
-#endif /* EFX_TX_H */
diff -r 5b3d4d3c1166 drivers/net/sfc/txc43128_phy.c
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/drivers/net/sfc/txc43128_phy.c	Tue Nov 09 10:06:27 2010 +0000
@@ -0,0 +1,563 @@
+/****************************************************************************
+ * Driver for Solarflare Solarstorm network controllers and boards
+ * Copyright 2006-2010 Solarflare Communications Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 as published
+ * by the Free Software Foundation, incorporated herein by reference.
+ */
+
+/*
+ * Driver for Transwitch/Mysticom CX4 retimer
+ * see www.transwitch.com, part is TXC-43128
+ */
+
+#include <linux/delay.h>
+#include <linux/slab.h>
+#include "efx.h"
+#include "mdio_10g.h"
+#include "phy.h"
+#include "nic.h"
+
+/* We expect these MMDs to be in the package */
+#define TXC_REQUIRED_DEVS (MDIO_DEVS_PCS |	\
+			   MDIO_DEVS_PMAPMD |	\
+			   MDIO_DEVS_PHYXS)
+
+#define TXC_LOOPBACKS ((1 << LOOPBACK_PCS) |	\
+		       (1 << LOOPBACK_PMAPMD) |	\
+		       (1 << LOOPBACK_PHYXS_WS))
+
+/**************************************************************************
+ *
+ * Compile-time config
+ *
+ **************************************************************************
+ */
+#define TXCNAME "TXC43128"
+/* Total length of time we'll wait for the PHY to come out of reset (ms) */
+#define TXC_MAX_RESET_TIME	500
+/* Interval between checks (ms) */
+#define TXC_RESET_WAIT		10
+/* How long to run BIST (us) */
+#define TXC_BIST_DURATION	50
+
+/**************************************************************************
+ *
+ * Register definitions
+ *
+ **************************************************************************
+ */
+
+/* Command register */
+#define TXC_GLRGS_GLCMD		0xc004
+/* Useful bits in command register */
+/* Lane power-down */
+#define TXC_GLCMD_L01PD_LBN	5
+#define TXC_GLCMD_L23PD_LBN	6
+/* Limited SW reset: preserves configuration but
+ * initiates a logic reset. Self-clearing */
+#define TXC_GLCMD_LMTSWRST_LBN	14
+
+/* Signal Quality Control */
+#define TXC_GLRGS_GSGQLCTL	0xc01a
+/* Enable bit */
+#define TXC_GSGQLCT_SGQLEN_LBN	15
+/* Lane selection */
+#define TXC_GSGQLCT_LNSL_LBN	13
+#define TXC_GSGQLCT_LNSL_WIDTH	2
+
+/* Analog TX control */
+#define TXC_ALRGS_ATXCTL	0xc040
+/* Lane power-down */
+#define TXC_ATXCTL_TXPD3_LBN	15
+#define TXC_ATXCTL_TXPD2_LBN	14
+#define TXC_ATXCTL_TXPD1_LBN	13
+#define TXC_ATXCTL_TXPD0_LBN	12
+
+/* Amplitude on lanes 0, 1 */
+#define TXC_ALRGS_ATXAMP0	0xc041
+/* Amplitude on lanes 2, 3 */
+#define TXC_ALRGS_ATXAMP1	0xc042
+/* Bit position of value for lane 0 (or 2) */
+#define TXC_ATXAMP_LANE02_LBN	3
+/* Bit position of value for lane 1 (or 3) */
+#define TXC_ATXAMP_LANE13_LBN	11
+
+#define TXC_ATXAMP_1280_mV	0
+#define TXC_ATXAMP_1200_mV	8
+#define TXC_ATXAMP_1120_mV	12
+#define TXC_ATXAMP_1060_mV	14
+#define TXC_ATXAMP_0820_mV	25
+#define TXC_ATXAMP_0720_mV	26
+#define TXC_ATXAMP_0580_mV	27
+#define TXC_ATXAMP_0440_mV	28
+
+#define TXC_ATXAMP_0820_BOTH					\
+	((TXC_ATXAMP_0820_mV << TXC_ATXAMP_LANE02_LBN)		\
+	 | (TXC_ATXAMP_0820_mV << TXC_ATXAMP_LANE13_LBN))
+
+#define TXC_ATXAMP_DEFAULT	0x6060 /* From databook */
+
+/* Preemphasis on lanes 0, 1 */
+#define TXC_ALRGS_ATXPRE0	0xc043
+/* Preemphasis on lanes 2, 3 */
+#define TXC_ALRGS_ATXPRE1	0xc044
+
+#define TXC_ATXPRE_NONE 0
+#define TXC_ATXPRE_DEFAULT	0x1010 /* From databook */
+
+#define TXC_ALRGS_ARXCTL	0xc045
+/* Lane power-down */
+#define TXC_ARXCTL_RXPD3_LBN	15
+#define TXC_ARXCTL_RXPD2_LBN	14
+#define TXC_ARXCTL_RXPD1_LBN	13
+#define TXC_ARXCTL_RXPD0_LBN	12
+
+/* Main control */
+#define TXC_MRGS_CTL		0xc340
+/* Bits in main control */
+#define TXC_MCTL_RESET_LBN	15	/* Self clear */
+#define TXC_MCTL_TXLED_LBN	14	/* 1 to show align status */
+#define TXC_MCTL_RXLED_LBN	13	/* 1 to show align status */
+
+/* GPIO output */
+#define TXC_GPIO_OUTPUT		0xc346
+#define TXC_GPIO_DIR		0xc348
+
+/* Vendor-specific BIST registers */
+#define TXC_BIST_CTL		0xc280
+#define TXC_BIST_TXFRMCNT	0xc281
+#define TXC_BIST_RX0FRMCNT	0xc282
+#define TXC_BIST_RX1FRMCNT	0xc283
+#define TXC_BIST_RX2FRMCNT	0xc284
+#define TXC_BIST_RX3FRMCNT	0xc285
+#define TXC_BIST_RX0ERRCNT	0xc286
+#define TXC_BIST_RX1ERRCNT	0xc287
+#define TXC_BIST_RX2ERRCNT	0xc288
+#define TXC_BIST_RX3ERRCNT	0xc289
+
+/* BIST type (controls bit patter in test) */
+#define TXC_BIST_CTRL_TYPE_LBN	10
+#define TXC_BIST_CTRL_TYPE_TSD	0	/* TranSwitch Deterministic */
+#define TXC_BIST_CTRL_TYPE_CRP	1	/* CRPAT standard */
+#define TXC_BIST_CTRL_TYPE_CJP	2	/* CJPAT standard */
+#define TXC_BIST_CTRL_TYPE_TSR	3	/* TranSwitch pseudo-random */
+/* Set this to 1 for 10 bit and 0 for 8 bit */
+#define TXC_BIST_CTRL_B10EN_LBN	12
+/* Enable BIST (write 0 to disable) */
+#define TXC_BIST_CTRL_ENAB_LBN	13
+/* Stop BIST (self-clears when stop complete) */
+#define TXC_BIST_CTRL_STOP_LBN	14
+/* Start BIST (cleared by writing 1 to STOP) */
+#define TXC_BIST_CTRL_STRT_LBN	15
+
+/* Mt. Diablo test configuration */
+#define TXC_MTDIABLO_CTRL	0xc34f
+#define TXC_MTDIABLO_CTRL_PMA_LOOP_LBN	10
+
+struct txc43128_data {
+	unsigned long bug10934_timer;
+	enum efx_phy_mode phy_mode;
+	enum efx_loopback_mode loopback_mode;
+};
+
+/* The PHY sometimes needs a reset to bring the link back up.  So long as
+ * it reports link down, we reset it every 5 seconds.
+ */
+#define BUG10934_RESET_INTERVAL (5 * HZ)
+
+/* Perform a reset that doesn't clear configuration changes */
+static void txc_reset_logic(struct efx_nic *efx);
+
+/* Set the output value of a gpio */
+void falcon_txc_set_gpio_val(struct efx_nic *efx, int pin, int on)
+{
+	efx_mdio_set_flag(efx, MDIO_MMD_PHYXS, TXC_GPIO_OUTPUT, 1 << pin, on);
+}
+
+/* Set up the GPIO direction register */
+void falcon_txc_set_gpio_dir(struct efx_nic *efx, int pin, int dir)
+{
+	efx_mdio_set_flag(efx, MDIO_MMD_PHYXS, TXC_GPIO_DIR, 1 << pin, dir);
+}
+
+/* Reset the PMA/PMD MMD. The documentation is explicit that this does a
+ * global reset (it's less clear what reset of other MMDs does).*/
+static int txc_reset_phy(struct efx_nic *efx)
+{
+	int rc = efx_mdio_reset_mmd(efx, MDIO_MMD_PMAPMD,
+				    TXC_MAX_RESET_TIME / TXC_RESET_WAIT,
+				    TXC_RESET_WAIT);
+	if (rc < 0)
+		goto fail;
+
+	/* Check that all the MMDs we expect are present and responding. */
+	rc = efx_mdio_check_mmds(efx, TXC_REQUIRED_DEVS, 0);
+	if (rc < 0)
+		goto fail;
+
+	return 0;
+
+fail:
+	netif_err(efx, hw, efx->net_dev, TXCNAME ": reset timed out!\n");
+	return rc;
+}
+
+/* Run a single BIST on one MMD */
+static int txc_bist_one(struct efx_nic *efx, int mmd, int test)
+{
+	int ctrl, bctl;
+	int lane;
+	int rc = 0;
+
+	/* Set PMA to test into loopback using Mt Diablo reg as per app note */
+	ctrl = efx_mdio_read(efx, MDIO_MMD_PCS, TXC_MTDIABLO_CTRL);
+	ctrl |= (1 << TXC_MTDIABLO_CTRL_PMA_LOOP_LBN);
+	efx_mdio_write(efx, MDIO_MMD_PCS, TXC_MTDIABLO_CTRL, ctrl);
+
+	/* The BIST app. note lists these  as 3 distinct steps. */
+	/* Set the BIST type */
+	bctl = (test << TXC_BIST_CTRL_TYPE_LBN);
+	efx_mdio_write(efx, mmd, TXC_BIST_CTL, bctl);
+
+	/* Set the BSTEN bit in the BIST Control register to enable */
+	bctl |= (1 << TXC_BIST_CTRL_ENAB_LBN);
+	efx_mdio_write(efx, mmd, TXC_BIST_CTL, bctl);
+
+	/* Set the BSTRT bit in the BIST Control register */
+	efx_mdio_write(efx, mmd, TXC_BIST_CTL,
+		       bctl | (1 << TXC_BIST_CTRL_STRT_LBN));
+
+	/* Wait. */
+	udelay(TXC_BIST_DURATION);
+
+	/* Set the BSTOP bit in the BIST Control register */
+	bctl |= (1 << TXC_BIST_CTRL_STOP_LBN);
+	efx_mdio_write(efx, mmd, TXC_BIST_CTL, bctl);
+
+	/* The STOP bit should go off when things have stopped */
+	while (bctl & (1 << TXC_BIST_CTRL_STOP_LBN))
+		bctl = efx_mdio_read(efx, mmd, TXC_BIST_CTL);
+
+	/* Check all the error counts are 0 and all the frame counts are
+	   non-zero */
+	for (lane = 0; lane < 4; lane++) {
+		int count = efx_mdio_read(efx, mmd, TXC_BIST_RX0ERRCNT + lane);
+		if (count != 0) {
+			netif_err(efx, hw, efx->net_dev, TXCNAME": BIST error. "
+				  "Lane %d had %d errs\n", lane, count);
+			rc = -EIO;
+		}
+		count = efx_mdio_read(efx, mmd, TXC_BIST_RX0FRMCNT + lane);
+		if (count == 0) {
+			netif_err(efx, hw, efx->net_dev, TXCNAME": BIST error. "
+				  "Lane %d got 0 frames\n", lane);
+			rc = -EIO;
+		}
+	}
+
+	if (rc == 0)
+		netif_info(efx, hw, efx->net_dev, TXCNAME": BIST pass\n");
+
+	/* Disable BIST */
+	efx_mdio_write(efx, mmd, TXC_BIST_CTL, 0);
+
+	/* Turn off loopback */
+	ctrl &= ~(1 << TXC_MTDIABLO_CTRL_PMA_LOOP_LBN);
+	efx_mdio_write(efx, MDIO_MMD_PCS, TXC_MTDIABLO_CTRL, ctrl);
+
+	return rc;
+}
+
+static int txc_bist(struct efx_nic *efx)
+{
+	return txc_bist_one(efx, MDIO_MMD_PCS, TXC_BIST_CTRL_TYPE_TSD);
+}
+
+/* Push the non-configurable defaults into the PHY. This must be
+ * done after every full reset */
+static void txc_apply_defaults(struct efx_nic *efx)
+{
+	int mctrl;
+
+	/* Turn amplitude down and preemphasis off on the host side
+	 * (PHY<->MAC) as this is believed less likely to upset Falcon
+	 * and no adverse effects have been noted. It probably also
+	 * saves a picowatt or two */
+
+	/* Turn off preemphasis */
+	efx_mdio_write(efx, MDIO_MMD_PHYXS, TXC_ALRGS_ATXPRE0, TXC_ATXPRE_NONE);
+	efx_mdio_write(efx, MDIO_MMD_PHYXS, TXC_ALRGS_ATXPRE1, TXC_ATXPRE_NONE);
+
+	/* Turn down the amplitude */
+	efx_mdio_write(efx, MDIO_MMD_PHYXS,
+		       TXC_ALRGS_ATXAMP0, TXC_ATXAMP_0820_BOTH);
+	efx_mdio_write(efx, MDIO_MMD_PHYXS,
+		       TXC_ALRGS_ATXAMP1, TXC_ATXAMP_0820_BOTH);
+
+	/* Set the line side amplitude and preemphasis to the databook
+	 * defaults as an erratum causes them to be 0 on at least some
+	 * PHY rev.s */
+	efx_mdio_write(efx, MDIO_MMD_PMAPMD,
+		       TXC_ALRGS_ATXPRE0, TXC_ATXPRE_DEFAULT);
+	efx_mdio_write(efx, MDIO_MMD_PMAPMD,
+		       TXC_ALRGS_ATXPRE1, TXC_ATXPRE_DEFAULT);
+	efx_mdio_write(efx, MDIO_MMD_PMAPMD,
+		       TXC_ALRGS_ATXAMP0, TXC_ATXAMP_DEFAULT);
+	efx_mdio_write(efx, MDIO_MMD_PMAPMD,
+		       TXC_ALRGS_ATXAMP1, TXC_ATXAMP_DEFAULT);
+
+	/* Set up the LEDs  */
+	mctrl = efx_mdio_read(efx, MDIO_MMD_PHYXS, TXC_MRGS_CTL);
+
+	/* Set the Green and Red LEDs to their default modes */
+	mctrl &= ~((1 << TXC_MCTL_TXLED_LBN) | (1 << TXC_MCTL_RXLED_LBN));
+	efx_mdio_write(efx, MDIO_MMD_PHYXS, TXC_MRGS_CTL, mctrl);
+
+	/* Databook recommends doing this after configuration changes */
+	txc_reset_logic(efx);
+
+	falcon_board(efx)->type->init_phy(efx);
+}
+
+static int txc43128_phy_probe(struct efx_nic *efx)
+{
+	struct txc43128_data *phy_data;
+
+	/* Allocate phy private storage */
+	phy_data = kzalloc(sizeof(*phy_data), GFP_KERNEL);
+	if (!phy_data)
+		return -ENOMEM;
+	efx->phy_data = phy_data;
+	phy_data->phy_mode = efx->phy_mode;
+
+	efx->mdio.mmds = TXC_REQUIRED_DEVS;
+	efx->mdio.mode_support = MDIO_SUPPORTS_C45 | MDIO_EMULATE_C22;
+
+	efx->loopback_modes = TXC_LOOPBACKS | FALCON_XMAC_LOOPBACKS;
+	efx->startup_loopback_mode = LOOPBACK_PMAPMD;
+
+	strlcpy(efx->phy_name, "Mysticom CX4", sizeof(efx->phy_name));
+
+	return 0;
+}
+
+/* Initialisation entry point for this PHY driver */
+static int txc43128_phy_init(struct efx_nic *efx)
+{
+	int rc;
+
+	rc = txc_reset_phy(efx);
+	if (rc < 0)
+		return rc;
+
+	rc = txc_bist(efx);
+	if (rc < 0)
+		return rc;
+
+	txc_apply_defaults(efx);
+
+	return 0;
+}
+
+/* Set the lane power down state in the global registers */
+static void txc_glrgs_lane_power(struct efx_nic *efx, int mmd)
+{
+	int pd = (1 << TXC_GLCMD_L01PD_LBN) | (1 << TXC_GLCMD_L23PD_LBN);
+	int ctl = efx_mdio_read(efx, mmd, TXC_GLRGS_GLCMD);
+
+	if (!(efx->phy_mode & PHY_MODE_LOW_POWER))
+		ctl &= ~pd;
+	else
+		ctl |= pd;
+
+	efx_mdio_write(efx, mmd, TXC_GLRGS_GLCMD, ctl);
+}
+
+/* Set the lane power down state in the analog control registers */
+static void txc_analog_lane_power(struct efx_nic *efx, int mmd)
+{
+	int txpd = (1 << TXC_ATXCTL_TXPD3_LBN) | (1 << TXC_ATXCTL_TXPD2_LBN)
+		| (1 << TXC_ATXCTL_TXPD1_LBN) | (1 << TXC_ATXCTL_TXPD0_LBN);
+	int rxpd = (1 << TXC_ARXCTL_RXPD3_LBN) | (1 << TXC_ARXCTL_RXPD2_LBN)
+		| (1 << TXC_ARXCTL_RXPD1_LBN) | (1 << TXC_ARXCTL_RXPD0_LBN);
+	int txctl = efx_mdio_read(efx, mmd, TXC_ALRGS_ATXCTL);
+	int rxctl = efx_mdio_read(efx, mmd, TXC_ALRGS_ARXCTL);
+
+	if (!(efx->phy_mode & PHY_MODE_LOW_POWER)) {
+		txctl &= ~txpd;
+		rxctl &= ~rxpd;
+	} else {
+		txctl |= txpd;
+		rxctl |= rxpd;
+	}
+
+	efx_mdio_write(efx, mmd, TXC_ALRGS_ATXCTL, txctl);
+	efx_mdio_write(efx, mmd, TXC_ALRGS_ARXCTL, rxctl);
+}
+
+static void txc_set_power(struct efx_nic *efx)
+{
+	/* According to the data book, all the MMDs can do low power */
+	efx_mdio_set_mmds_lpower(efx,
+				 !!(efx->phy_mode & PHY_MODE_LOW_POWER),
+				 TXC_REQUIRED_DEVS);
+
+	/* Global register bank is in PCS, PHY XS. These control the host
+	 * side and line side settings respectively. */
+	txc_glrgs_lane_power(efx, MDIO_MMD_PCS);
+	txc_glrgs_lane_power(efx, MDIO_MMD_PHYXS);
+
+	/* Analog register bank in PMA/PMD, PHY XS */
+	txc_analog_lane_power(efx, MDIO_MMD_PMAPMD);
+	txc_analog_lane_power(efx, MDIO_MMD_PHYXS);
+}
+
+static void txc_reset_logic_mmd(struct efx_nic *efx, int mmd)
+{
+	int val = efx_mdio_read(efx, mmd, TXC_GLRGS_GLCMD);
+	int tries = 50;
+
+	val |= (1 << TXC_GLCMD_LMTSWRST_LBN);
+	efx_mdio_write(efx, mmd, TXC_GLRGS_GLCMD, val);
+	while (tries--) {
+		val = efx_mdio_read(efx, mmd, TXC_GLRGS_GLCMD);
+		if (!(val & (1 << TXC_GLCMD_LMTSWRST_LBN)))
+			break;
+		udelay(1);
+	}
+	if (!tries)
+		netif_info(efx, hw, efx->net_dev,
+			   TXCNAME " Logic reset timed out!\n");
+}
+
+/* Perform a logic reset. This preserves the configuration registers
+ * and is needed for some configuration changes to take effect */
+static void txc_reset_logic(struct efx_nic *efx)
+{
+	/* The data sheet claims we can do the logic reset on either the
+	 * PCS or the PHYXS and the result is a reset of both host- and
+	 * line-side logic. */
+	txc_reset_logic_mmd(efx, MDIO_MMD_PCS);
+}
+
+static bool txc43128_phy_read_link(struct efx_nic *efx)
+{
+	return efx_mdio_links_ok(efx, TXC_REQUIRED_DEVS);
+}
+
+static int txc43128_phy_reconfigure(struct efx_nic *efx)
+{
+	struct txc43128_data *phy_data = efx->phy_data;
+	enum efx_phy_mode mode_change = efx->phy_mode ^ phy_data->phy_mode;
+	bool loop_change = LOOPBACK_CHANGED(phy_data, efx, TXC_LOOPBACKS);
+
+	if (efx->phy_mode & mode_change & PHY_MODE_TX_DISABLED) {
+		txc_reset_phy(efx);
+		txc_apply_defaults(efx);
+		falcon_reset_xaui(efx);
+		mode_change &= ~PHY_MODE_TX_DISABLED;
+	}
+
+	efx_mdio_transmit_disable(efx);
+	efx_mdio_phy_reconfigure(efx);
+	if (mode_change & PHY_MODE_LOW_POWER)
+		txc_set_power(efx);
+
+	/* The data sheet claims this is required after every reconfiguration
+	 * (note at end of 7.1), but we mustn't do it when nothing changes as
+	 * it glitches the link, and reconfigure gets called on link change,
+	 * so we get an IRQ storm on link up. */
+	if (loop_change || mode_change)
+		txc_reset_logic(efx);
+
+	phy_data->phy_mode = efx->phy_mode;
+	phy_data->loopback_mode = efx->loopback_mode;
+
+	return 0;
+}
+
+static void txc43128_phy_fini(struct efx_nic *efx)
+{
+	/* Disable link events */
+	efx_mdio_write(efx, MDIO_MMD_PMAPMD, MDIO_PMA_LASI_CTRL, 0);
+}
+
+static void txc43128_phy_remove(struct efx_nic *efx)
+{
+	kfree(efx->phy_data);
+	efx->phy_data = NULL;
+}
+
+/* Periodic callback: this exists mainly to poll link status as we
+ * don't use LASI interrupts */
+static bool txc43128_phy_poll(struct efx_nic *efx)
+{
+	struct txc43128_data *data = efx->phy_data;
+	bool was_up = efx->link_state.up;
+
+	efx->link_state.up = txc43128_phy_read_link(efx);
+	efx->link_state.speed = 10000;
+	efx->link_state.fd = true;
+	efx->link_state.fc = efx->wanted_fc;
+
+	if (efx->link_state.up || (efx->loopback_mode != LOOPBACK_NONE)) {
+		data->bug10934_timer = jiffies;
+	} else {
+		if (time_after_eq(jiffies, (data->bug10934_timer +
+					    BUG10934_RESET_INTERVAL))) {
+			data->bug10934_timer = jiffies;
+			txc_reset_logic(efx);
+		}
+	}
+
+	return efx->link_state.up != was_up;
+}
+
+static const char *txc43128_test_names[] = {
+	"bist"
+};
+
+static const char *txc43128_test_name(struct efx_nic *efx, unsigned int index)
+{
+	if (index < ARRAY_SIZE(txc43128_test_names))
+		return txc43128_test_names[index];
+	return NULL;
+}
+
+static int txc43128_run_tests(struct efx_nic *efx, int *results, unsigned flags)
+{
+	int rc;
+
+	if (!(flags & ETH_TEST_FL_OFFLINE))
+		return 0;
+
+	rc = txc_reset_phy(efx);
+	if (rc < 0)
+		return rc;
+
+	rc = txc_bist(efx);
+	txc_apply_defaults(efx);
+	results[0] = rc ? -1 : 1;
+	return rc;
+}
+
+static void txc43128_get_settings(struct efx_nic *efx, struct ethtool_cmd *ecmd)
+{
+	mdio45_ethtool_gset(&efx->mdio, ecmd);
+}
+
+struct efx_phy_operations falcon_txc_phy_ops = {
+	.probe		= txc43128_phy_probe,
+	.init		= txc43128_phy_init,
+	.reconfigure	= txc43128_phy_reconfigure,
+	.poll		= txc43128_phy_poll,
+	.fini		= txc43128_phy_fini,
+	.remove		= txc43128_phy_remove,
+	.get_settings	= txc43128_get_settings,
+	.set_settings	= efx_mdio_set_settings,
+	.test_alive	= efx_mdio_test_alive,
+	.run_tests	= txc43128_run_tests,
+	.test_name	= txc43128_test_name,
+};
diff -r 5b3d4d3c1166 drivers/net/sfc/vfdi.h
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/drivers/net/sfc/vfdi.h	Tue Nov 09 10:06:27 2010 +0000
@@ -0,0 +1,161 @@
+/****************************************************************************
+ * Driver for Solarflare Solarstorm network controllers and boards
+ * Copyright 2010 Solarflare Communications Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 as published
+ * by the Free Software Foundation, incorporated herein by reference.
+ */
+#ifndef _VFDI_H
+#define _VFDI_H
+
+/* This file contains software structures used to form a two way communication
+ * channel between the VF (plugin) driver and the PF (netback) driver.
+ */
+
+/* Events:
+ *
+ * Events are used to communicate between the PF and the VF. Events
+ * are defined in a shared namespace
+ */
+#define VFDI_EV_SEQ_LBN 24
+#define VFDI_EV_SEQ_WIDTH 8
+#define VFDI_EV_TYPE_LBN 16
+#define VFDI_EV_TYPE_WIDTH 8
+#define VFDI_EV_TYPE_REQ_WORD0 0
+#define VFDI_EV_TYPE_REQ_WORD1 1
+#define VFDI_EV_TYPE_REQ_WORD2 2
+#define VFDI_EV_TYPE_REQ_WORD3 3
+#define VFDI_EV_TYPE_REQ_STATUS 4
+#define VFDI_EV_DATA_LBN 0
+#define VFDI_EV_DATA_WIDTH 16
+
+struct vfdi_endpoint {
+	u8 mac_addr[ETH_ALEN];
+	__be16 tci;
+};
+
+/**
+ * enum vfdi_op - VFDI operation enumeration.
+ * @VFDI_RESPONSE: dom0 completes a request by setting op=%VFDI_RESPONSE.
+ * @VFDI_INIT_EVQ: Initialize sram entries and initialize an EVQ.
+ * @VFDI_INIT_RXQ: Initialize sram entries and initialize an RXQ.
+ * @VFDI_INIT_TXQ: Initialize sram entries and initialize a TXQ.
+ * @VFDI_FINI_ALL_QUEUES: Flush all queues, finalize all queues, then
+ *	finalize the sram entries.
+ * @VFDI_INSERT_FILTER: Insert a mac filter targetting the given RXQ.
+ * @VFDI_REMOVE_ALL_FILTERS: Remove all filters.
+ * @VFDI_SET_STATUS_PAGE: Set the dma page used for status updates from dom0.
+ *	When this command has been executed dom0 guarantees to
+ *	send a status page(s) as soon as possible.
+ * @VFDI_CLEAR_STATUS_PAGE: Clear the dma page(s) used for status updates from dom0.
+ */
+enum vfdi_op {
+	VFDI_RESPONSE = 0,
+	VFDI_INIT_EVQ = 1,
+	VFDI_INIT_RXQ = 2,
+	VFDI_INIT_TXQ = 3,
+	VFDI_FINI_ALL_QUEUES = 4,
+	VFDI_INSERT_FILTER = 5,
+	VFDI_REMOVE_ALL_FILTERS = 6,
+	VFDI_SET_STATUS_PAGE = 7,
+	VFDI_CLEAR_STATUS_PAGE = 8,
+	VFDI_LIMIT,
+};
+
+/**
+ * struct vfdi_req - A request from the VF to the PF.
+ * @op: Instance of enum vfdi_op.
+ * @seq: Sequence number reflected in DRIVER_EV sent to evq[0].
+ * @rc: PF returns success/failure inside the request.
+ * @u.init_evq.index: Index of evevent queue to create.
+ * @u.init_evq.buf_count: Number of 4k buffers backing event queue.
+ * @u.init_evq.addr: Array of length %u.init_evq.index containing dma address
+ *	of each page backing the event queue.
+ * @u.init_rxq.index: Index of receive queue to create.
+ * @u.init_rxq.buf_count: Number of 4k buffers backing receive queue.
+ * @u.init_rxq.evq: Instance of event queue to target receive events at.
+ * @u.init_rxq.label: Label used in receive events.
+ * @u.init_rxq.flags: Unused.
+ * @u.init_rxq.addr: Array of length %u.init_rxq.index continaing dma address
+ *	of each page backing the receive queue.
+ * @u.init_txq.index: Index of transmit queue to create.
+ * @u.init_txq.buf_count: Number of 4k buffers backing transmit queue.
+ * @u.init_txq.evq: Instance of event queue to target transmit completion
+ *	events at.
+ * @u.init_txq.label: Label used in transmit completion events.
+ * @u.init_txq.flags: Checksum offload flags.
+ * @u.init_txq.addr: Array of length %u.init_txq.index continaing dma address
+ *	of each page backing the transmit queue.
+ * @u.mac_filter.rxq: Insert mac filter at VF local address/vlan targetting
+ *	all traffic at this receive queue.
+ * @u.mac_filter.flags: Mac filter flags.
+ */
+struct vfdi_req {
+	u32 op;
+	u32 seq;
+	u32 rc;
+	u32 __pad;
+	union {
+		struct {
+			u32 index;
+			u32 buf_count;
+			u64 addr[];
+		} init_evq;
+		struct {
+			u32 index;
+			u32 buf_count;
+			u32 evq;
+			u32 label;
+			u32 flags;
+			u32 __pad;
+			u64 addr[];
+		} init_rxq;
+		struct {
+			u32 index;
+			u32 buf_count;
+			u32 evq;
+			u32 label;
+			u32 flags;
+#define TXQ_FLAG_IP_CSUM_DIS 1
+#define TXQ_FLAG_TCPUDP_CSUM_DIS 2
+			u32 __pad;
+			u64 addr[];
+		} init_txq;
+		struct {
+			u32 rxq;
+			u32 flags;
+#define MAC_FILTER_FLAG_RSS 1
+#define MAC_FILTER_FLAG_SCATTER 2
+		} mac_filter;
+		struct {
+			u64 dma_addr;
+		} set_status_page;
+	} u;
+};
+
+/**
+ * struct vfdi_status - PF view of network topology.
+ * @generation_start: A generation count dma'd to domU *before* the
+ *	rest of the structure.
+ * @generation_end: A generation count dma'd to domU *after* the rest
+ *	rest of the structure.
+ * @version: Version of this structure
+ * @length: Total length of this structure including embedded tables
+ * @vi_scale: The number of queue resources assigned to this VF. RSS support
+ *	can only be enabled if the guest enables all the requested interrupts.
+ * @local: The mac address and outer vlan tag of *this* VF
+ * @peers: Table of peer addresses.
+ */
+struct vfdi_status {
+	u32 generation_start;
+	u32 generation_end;
+	u32 version;
+	u32 length;
+	u32 vi_scale;
+	u32 __pad;
+	struct vfdi_endpoint local;
+	struct vfdi_endpoint peers[256];
+};
+
+#endif
diff -r 5b3d4d3c1166 drivers/net/sfc/workarounds.h
--- a/drivers/net/sfc/workarounds.h	Fri Nov 05 15:20:28 2010 +0000
+++ b/drivers/net/sfc/workarounds.h	Tue Nov 09 10:06:27 2010 +0000
@@ -1,6 +1,6 @@
 /****************************************************************************
  * Driver for Solarflare Solarstorm network controllers and boards
- * Copyright 2006-2008 Solarflare Communications Inc.
+ * Copyright 2006-2009 Solarflare Communications Inc.
  *
  * This program is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 as published
@@ -16,31 +16,41 @@
  */
 
 #define EFX_WORKAROUND_ALWAYS(efx) 1
-#define EFX_WORKAROUND_FALCON_A(efx) (falcon_rev(efx) <= FALCON_REV_A1)
-#define EFX_WORKAROUND_10G(efx) EFX_IS10G(efx)
-#define EFX_WORKAROUND_SFT9001(efx) ((efx)->phy_type == PHY_TYPE_SFT9001A || \
-				     (efx)->phy_type == PHY_TYPE_SFT9001B)
+#define EFX_WORKAROUND_NEVER(efx) 0
+#define EFX_WORKAROUND_FALCON_A(efx) (efx_nic_rev(efx) <= EFX_REV_FALCON_A1)
+#define EFX_WORKAROUND_FALCON_B(efx) (efx_nic_rev(efx) == EFX_REV_FALCON_B0)
+#define EFX_WORKAROUND_FALCON_AB(efx) (efx_nic_rev(efx) <= EFX_REV_FALCON_B0)
+#define EFX_WORKAROUND_SIENA(efx) (efx_nic_rev(efx) == EFX_REV_SIENA_A0)
+#define EFX_WORKAROUND_10G(efx) 1
 
 /* XAUI resets if link not detected */
 #define EFX_WORKAROUND_5147 EFX_WORKAROUND_ALWAYS
+/* Reprog PCIe ACK timer to workaround issue in PCIe IP block */
+#define EFX_WORKAROUND_6943 EFX_WORKAROUND_FALCON_B
 /* RX PCIe double split performance issue */
 #define EFX_WORKAROUND_7575 EFX_WORKAROUND_ALWAYS
 /* Bit-bashed I2C reads cause performance drop */
 #define EFX_WORKAROUND_7884 EFX_WORKAROUND_10G
-/* TX pkt parser problem with <= 16 byte TXes */
-#define EFX_WORKAROUND_9141 EFX_WORKAROUND_ALWAYS
+/* Selftests need to be retried */
+#define EFX_WORKAROUND_8568 EFX_WORKAROUND_ALWAYS
+/* Queued ACKs aren't flushed before L1 entry */
+#define EFX_WORKAROUND_9096 EFX_WORKAROUND_FALCON_B
 /* TX_EV_PKT_ERR can be caused by a dangling TX descriptor
  * or a PCIe error (bug 11028) */
 #define EFX_WORKAROUND_10727 EFX_WORKAROUND_ALWAYS
 /* Transmit flow control may get disabled */
-#define EFX_WORKAROUND_11482 EFX_WORKAROUND_ALWAYS
-/* Flush events can take a very long time to appear */
-#define EFX_WORKAROUND_11557 EFX_WORKAROUND_ALWAYS
+#define EFX_WORKAROUND_11482 EFX_WORKAROUND_FALCON_AB
 /* Truncated IPv4 packets can confuse the TX packet parser */
-#define EFX_WORKAROUND_15592 EFX_WORKAROUND_ALWAYS
+#define EFX_WORKAROUND_15592 EFX_WORKAROUND_FALCON_AB
+/* Legacy ISR read can return zero once */
+#define EFX_WORKAROUND_15783 EFX_WORKAROUND_ALWAYS
+/* Legacy interrupt storm when interrupt fifo fills */
+#define EFX_WORKAROUND_17213 EFX_WORKAROUND_SIENA
 
 /* Spurious parity errors in TSORT buffers */
 #define EFX_WORKAROUND_5129 EFX_WORKAROUND_FALCON_A
+/* Unaligned read request >512 bytes after aligning may break TSORT */
+#define EFX_WORKAROUND_5391 EFX_WORKAROUND_FALCON_A
 /* iSCSI parsing errors */
 #define EFX_WORKAROUND_5583 EFX_WORKAROUND_FALCON_A
 /* RX events go missing */
@@ -50,13 +60,11 @@
 /* Increase filter depth to avoid RX_RESET */
 #define EFX_WORKAROUND_7244 EFX_WORKAROUND_FALCON_A
 /* Flushes may never complete */
-#define EFX_WORKAROUND_7803 EFX_WORKAROUND_FALCON_A
+#define EFX_WORKAROUND_7803 EFX_WORKAROUND_FALCON_AB
 /* Leak overlength packets rather than free */
 #define EFX_WORKAROUND_8071 EFX_WORKAROUND_FALCON_A
 
-/* Need to send XNP pages for 100BaseT */
-#define EFX_WORKAROUND_13204 EFX_WORKAROUND_SFT9001
-/* Don't restart AN in near-side loopback */
-#define EFX_WORKAROUND_15195 EFX_WORKAROUND_SFT9001
+/* Invalid BAR accesses may not be completed, leading to NMI */
+#define EFX_WORKAROUND_11368 EFX_WORKAROUND_FALCON_B
 
 #endif /* EFX_WORKAROUNDS_H */
diff -r 5b3d4d3c1166 drivers/net/sfc/xfp_phy.c
--- a/drivers/net/sfc/xfp_phy.c	Fri Nov 05 15:20:28 2010 +0000
+++ /dev/null	Thu Jan 01 00:00:00 1970 +0000
@@ -1,250 +0,0 @@
-/****************************************************************************
- * Driver for Solarflare Solarstorm network controllers and boards
- * Copyright 2006-2008 Solarflare Communications Inc.
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 as published
- * by the Free Software Foundation, incorporated herein by reference.
- */
-/*
- * Driver for SFP+ and XFP optical PHYs plus some support specific to the
- * AMCC QT20xx adapters; see www.amcc.com for details
- */
-
-#include <linux/timer.h>
-#include <linux/delay.h>
-#include "efx.h"
-#include "mdio_10g.h"
-#include "phy.h"
-#include "falcon.h"
-
-#define XFP_REQUIRED_DEVS (MDIO_DEVS_PCS |	\
-			   MDIO_DEVS_PMAPMD |	\
-			   MDIO_DEVS_PHYXS)
-
-#define XFP_LOOPBACKS ((1 << LOOPBACK_PCS) |		\
-		       (1 << LOOPBACK_PMAPMD) |		\
-		       (1 << LOOPBACK_NETWORK))
-
-/****************************************************************************/
-/* Quake-specific MDIO registers */
-#define MDIO_QUAKE_LED0_REG	(0xD006)
-
-/* QT2025C only */
-#define PCS_FW_HEARTBEAT_REG	0xd7ee
-#define PCS_FW_HEARTB_LBN	0
-#define PCS_FW_HEARTB_WIDTH	8
-#define PCS_UC8051_STATUS_REG	0xd7fd
-#define PCS_UC_STATUS_LBN	0
-#define PCS_UC_STATUS_WIDTH	8
-#define PCS_UC_STATUS_FW_SAVE	0x20
-#define PMA_PMD_FTX_CTRL2_REG	0xc309
-#define PMA_PMD_FTX_STATIC_LBN	13
-#define PMA_PMD_VEND1_REG	0xc001
-#define PMA_PMD_VEND1_LBTXD_LBN	15
-#define PCS_VEND1_REG	   	0xc000
-#define PCS_VEND1_LBTXD_LBN	5
-
-void xfp_set_led(struct efx_nic *p, int led, int mode)
-{
-	int addr = MDIO_QUAKE_LED0_REG + led;
-	efx_mdio_write(p, MDIO_MMD_PMAPMD, addr, mode);
-}
-
-struct xfp_phy_data {
-	enum efx_phy_mode phy_mode;
-};
-
-#define XFP_MAX_RESET_TIME 500
-#define XFP_RESET_WAIT 10
-
-static int qt2025c_wait_reset(struct efx_nic *efx)
-{
-	unsigned long timeout = jiffies + 10 * HZ;
-	int reg, old_counter = 0;
-
-	/* Wait for firmware heartbeat to start */
-	for (;;) {
-		int counter;
-		reg = efx_mdio_read(efx, MDIO_MMD_PCS, PCS_FW_HEARTBEAT_REG);
-		if (reg < 0)
-			return reg;
-		counter = ((reg >> PCS_FW_HEARTB_LBN) &
-			    ((1 << PCS_FW_HEARTB_WIDTH) - 1));
-		if (old_counter == 0)
-			old_counter = counter;
-		else if (counter != old_counter)
-			break;
-		if (time_after(jiffies, timeout))
-			return -ETIMEDOUT;
-		msleep(10);
-	}
-
-	/* Wait for firmware status to look good */
-	for (;;) {
-		reg = efx_mdio_read(efx, MDIO_MMD_PCS, PCS_UC8051_STATUS_REG);
-		if (reg < 0)
-			return reg;
-		if ((reg &
-		     ((1 << PCS_UC_STATUS_WIDTH) - 1) << PCS_UC_STATUS_LBN) >=
-		    PCS_UC_STATUS_FW_SAVE)
-			break;
-		if (time_after(jiffies, timeout))
-			return -ETIMEDOUT;
-		msleep(100);
-	}
-
-	return 0;
-}
-
-static int xfp_reset_phy(struct efx_nic *efx)
-{
-	int rc;
-
-	if (efx->phy_type == PHY_TYPE_QT2025C) {
-		/* Wait for the reset triggered by falcon_reset_hw()
-		 * to complete */
-		rc = qt2025c_wait_reset(efx);
-		if (rc < 0)
-			goto fail;
-	} else {
-		/* Reset the PHYXS MMD. This is documented as doing
-		 * a complete soft reset. */
-		rc = efx_mdio_reset_mmd(efx, MDIO_MMD_PHYXS,
-					XFP_MAX_RESET_TIME / XFP_RESET_WAIT,
-					XFP_RESET_WAIT);
-		if (rc < 0)
-			goto fail;
-	}
-
-	/* Wait 250ms for the PHY to complete bootup */
-	msleep(250);
-
-	/* Check that all the MMDs we expect are present and responding. We
-	 * expect faults on some if the link is down, but not on the PHY XS */
-	rc = efx_mdio_check_mmds(efx, XFP_REQUIRED_DEVS, MDIO_DEVS_PHYXS);
-	if (rc < 0)
-		goto fail;
-
-	efx->board_info.init_leds(efx);
-
-	return rc;
-
- fail:
-	EFX_ERR(efx, "PHY reset timed out\n");
-	return rc;
-}
-
-static int xfp_phy_init(struct efx_nic *efx)
-{
-	struct xfp_phy_data *phy_data;
-	u32 devid = efx_mdio_read_id(efx, MDIO_MMD_PHYXS);
-	int rc;
-
-	phy_data = kzalloc(sizeof(struct xfp_phy_data), GFP_KERNEL);
-	if (!phy_data)
-		return -ENOMEM;
-	efx->phy_data = phy_data;
-
-	EFX_INFO(efx, "PHY ID reg %x (OUI %06x model %02x revision %x)\n",
-		 devid, efx_mdio_id_oui(devid), efx_mdio_id_model(devid),
-		 efx_mdio_id_rev(devid));
-
-	phy_data->phy_mode = efx->phy_mode;
-
-	rc = xfp_reset_phy(efx);
-
-	EFX_INFO(efx, "PHY init %s.\n",
-		 rc ? "failed" : "successful");
-	if (rc < 0)
-		goto fail;
-
-	return 0;
-
- fail:
-	kfree(efx->phy_data);
-	efx->phy_data = NULL;
-	return rc;
-}
-
-static void xfp_phy_clear_interrupt(struct efx_nic *efx)
-{
-	/* Read to clear link status alarm */
-	efx_mdio_read(efx, MDIO_MMD_PMAPMD, MDIO_PMA_LASI_STAT);
-}
-
-static int xfp_link_ok(struct efx_nic *efx)
-{
-	return efx_mdio_links_ok(efx, XFP_REQUIRED_DEVS);
-}
-
-static void xfp_phy_poll(struct efx_nic *efx)
-{
-	int link_up = xfp_link_ok(efx);
-	/* Simulate a PHY event if link state has changed */
-	if (link_up != efx->link_up)
-		falcon_sim_phy_event(efx);
-}
-
-static void xfp_phy_reconfigure(struct efx_nic *efx)
-{
-	struct xfp_phy_data *phy_data = efx->phy_data;
-
-	if (efx->phy_type == PHY_TYPE_QT2025C) {
-		/* There are several different register bits which can
-		 * disable TX (and save power) on direct-attach cables
-		 * or optical transceivers, varying somewhat between
-		 * firmware versions.  Only 'static mode' appears to
-		 * cover everything. */
-		mdio_set_flag(
-			&efx->mdio, efx->mdio.prtad, MDIO_MMD_PMAPMD,
-			PMA_PMD_FTX_CTRL2_REG, 1 << PMA_PMD_FTX_STATIC_LBN,
-			efx->phy_mode & PHY_MODE_TX_DISABLED ||
-			efx->phy_mode & PHY_MODE_LOW_POWER ||
-			efx->loopback_mode == LOOPBACK_PCS ||
-			efx->loopback_mode == LOOPBACK_PMAPMD);
-	} else {
-		/* Reset the PHY when moving from tx off to tx on */
-		if (!(efx->phy_mode & PHY_MODE_TX_DISABLED) &&
-		    (phy_data->phy_mode & PHY_MODE_TX_DISABLED))
-			xfp_reset_phy(efx);
-
-		efx_mdio_transmit_disable(efx);
-	}
-
-	efx_mdio_phy_reconfigure(efx);
-
-	phy_data->phy_mode = efx->phy_mode;
-	efx->link_up = xfp_link_ok(efx);
-	efx->link_speed = 10000;
-	efx->link_fd = true;
-	efx->link_fc = efx->wanted_fc;
-}
-
-static void xfp_phy_get_settings(struct efx_nic *efx, struct ethtool_cmd *ecmd)
-{
-	mdio45_ethtool_gset(&efx->mdio, ecmd);
-}
-
-static void xfp_phy_fini(struct efx_nic *efx)
-{
-	/* Clobber the LED if it was blinking */
-	efx->board_info.blink(efx, false);
-
-	/* Free the context block */
-	kfree(efx->phy_data);
-	efx->phy_data = NULL;
-}
-
-struct efx_phy_operations falcon_xfp_phy_ops = {
-	.macs		 = EFX_XMAC,
-	.init            = xfp_phy_init,
-	.reconfigure     = xfp_phy_reconfigure,
-	.poll            = xfp_phy_poll,
-	.fini            = xfp_phy_fini,
-	.clear_interrupt = xfp_phy_clear_interrupt,
-	.get_settings    = xfp_phy_get_settings,
-	.set_settings	 = efx_mdio_set_settings,
-	.mmds            = XFP_REQUIRED_DEVS,
-	.loopbacks       = XFP_LOOPBACKS,
-};
