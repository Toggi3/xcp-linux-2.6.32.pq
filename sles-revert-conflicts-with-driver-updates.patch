diff -r 15109ec2f661 drivers/net/benet/be.h
--- b/drivers/net/benet/be.h	Wed Aug 17 13:31:06 2011 +0100
+++ a/drivers/net/benet/be.h	Wed Aug 17 13:09:17 2011 +0100
@@ -164,7 +164,6 @@
 	ulong be_tx_jiffies;
 	u64 be_tx_bytes;
 	u64 be_tx_bytes_prev;
-	u64 be_tx_pkts;
 	u32 be_tx_rate;
 
 	u32 cache_barrier[16];
@@ -176,7 +175,6 @@
 	ulong be_rx_jiffies;
 	u64 be_rx_bytes;
 	u64 be_rx_bytes_prev;
-	u64 be_rx_pkts;
 	u32 be_rx_rate;
 	/* number of non ether type II frames dropped where
 	 * frame len > length field of Mac Hdr */
diff -r 15109ec2f661 drivers/net/benet/be_main.c
--- b/drivers/net/benet/be_main.c	Wed Aug 17 13:31:06 2011 +0100
+++ a/drivers/net/benet/be_main.c	Wed Aug 17 13:09:17 2011 +0100
@@ -159,10 +159,13 @@
 	struct net_device_stats *dev_stats = &adapter->netdev->stats;
 	struct be_erx_stats *erx_stats = &hw_stats->erx;
 
-	dev_stats->rx_packets = drvr_stats(adapter)->be_rx_pkts;
-	dev_stats->tx_packets = drvr_stats(adapter)->be_tx_pkts;
-	dev_stats->rx_bytes = drvr_stats(adapter)->be_rx_bytes;
-	dev_stats->tx_bytes = drvr_stats(adapter)->be_tx_bytes;
+	dev_stats->rx_packets = port_stats->rx_total_frames;
+	dev_stats->tx_packets = port_stats->tx_unicastframes +
+		port_stats->tx_multicastframes + port_stats->tx_broadcastframes;
+	dev_stats->rx_bytes = (u64) port_stats->rx_bytes_msd << 32 |
+				(u64) port_stats->rx_bytes_lsd;
+	dev_stats->tx_bytes = (u64) port_stats->tx_bytes_msd << 32 |
+				(u64) port_stats->tx_bytes_lsd;
 
 	/* bad pkts received */
 	dev_stats->rx_errors = port_stats->rx_crc_errors +
@@ -320,13 +323,12 @@
 }
 
 static void be_tx_stats_update(struct be_adapter *adapter,
-			u32 wrb_cnt, u32 copied, u32 gso_segs, bool stopped)
+			u32 wrb_cnt, u32 copied, bool stopped)
 {
 	struct be_drvr_stats *stats = drvr_stats(adapter);
 	stats->be_tx_reqs++;
 	stats->be_tx_wrbs += wrb_cnt;
 	stats->be_tx_bytes += copied;
-	stats->be_tx_pkts += (gso_segs ? gso_segs : 1);
 	if (stopped)
 		stats->be_tx_stops++;
 }
@@ -476,8 +478,7 @@
 
 		be_txq_notify(adapter, txq->id, wrb_cnt);
 
-		be_tx_stats_update(adapter, wrb_cnt, copied,
-				skb_shinfo(skb)->gso_segs, stopped);
+		be_tx_stats_update(adapter, wrb_cnt, copied, stopped);
 	} else {
 		txq->head = start;
 		dev_kfree_skb_any(skb);
@@ -623,7 +624,6 @@
 	stats->be_rx_compl++;
 	stats->be_rx_frags += numfrags;
 	stats->be_rx_bytes += pktsize;
-	stats->be_rx_pkts++;
 }
 
 static inline bool do_pkt_csum(struct be_eth_rx_compl *rxcp, bool cso)
diff -r 15109ec2f661 drivers/net/bnx2.c
--- b/drivers/net/bnx2.c	Wed Aug 17 13:31:06 2011 +0100
+++ a/drivers/net/bnx2.c	Wed Aug 17 13:09:17 2011 +0100
@@ -251,9 +251,6 @@
 
 MODULE_DEVICE_TABLE(pci, bnx2_pci_tbl);
 
-static void bnx2_init_napi(struct bnx2 *bp);
-static void bnx2_del_napi(struct bnx2 *bp);
-
 static inline u32 bnx2_tx_avail(struct bnx2 *bp, struct bnx2_tx_ring_info *txr)
 {
 	u32 diff;
@@ -6225,7 +6222,6 @@
 	bnx2_disable_int(bp);
 
 	bnx2_setup_int_mode(bp, disable_msi);
-	bnx2_init_napi(bp);
 	bnx2_napi_enable(bp);
 	rc = bnx2_alloc_mem(bp);
 	if (rc)
@@ -6287,7 +6283,6 @@
 	bnx2_free_skbs(bp);
 	bnx2_free_irq(bp);
 	bnx2_free_mem(bp);
-	bnx2_del_napi(bp);
 	return rc;
 }
 
@@ -6549,7 +6544,6 @@
 	bnx2_free_irq(bp);
 	bnx2_free_skbs(bp);
 	bnx2_free_mem(bp);
-	bnx2_del_napi(bp);
 	bp->link_up = 0;
 	netif_carrier_off(bp->dev);
 	bnx2_set_power_state(bp, PCI_D3hot);
@@ -8221,21 +8215,12 @@
 	return str;
 }
 
-static void
-bnx2_del_napi(struct bnx2 *bp)
-{
-	int i;
-
-	for (i = 0; i < bp->irq_nvecs; i++)
-		netif_napi_del(&bp->bnx2_napi[i].napi);
-}
-
-static void
+static void __devinit
 bnx2_init_napi(struct bnx2 *bp)
 {
 	int i;
 
-	for (i = 0; i < bp->irq_nvecs; i++) {
+	for (i = 0; i < BNX2_MAX_MSIX_VEC; i++) {
 		struct bnx2_napi *bnapi = &bp->bnx2_napi[i];
 		int (*poll)(struct napi_struct *, int);
 
@@ -8304,6 +8289,7 @@
 	dev->ethtool_ops = &bnx2_ethtool_ops;
 
 	bp = netdev_priv(dev);
+	bnx2_init_napi(bp);
 
 	pci_set_drvdata(pdev, dev);
 
diff -r 15109ec2f661 drivers/net/cnic.c
--- b/drivers/net/cnic.c	Wed Aug 17 13:31:06 2011 +0100
+++ a/drivers/net/cnic.c	Wed Aug 17 13:09:17 2011 +0100
@@ -335,12 +335,6 @@
 		if (l5_cid >= MAX_CM_SK_TBL_SZ)
 			break;
 
-		rcu_read_lock();
-		if (!rcu_dereference(cp->ulp_ops[CNIC_ULP_L4])) {
-			rc = -ENODEV;
-			rcu_read_unlock();
-			break;
-		}
 		csk = &cp->csk_tbl[l5_cid];
 		csk_hold(csk);
 		if (cnic_in_use(csk)) {
@@ -355,7 +349,6 @@
 				cnic_cm_set_pg(csk);
 		}
 		csk_put(csk);
-		rcu_read_unlock();
 		rc = 0;
 	}
 	}
@@ -701,13 +694,13 @@
 static void cnic_setup_page_tbl(struct cnic_dev *dev, struct cnic_dma *dma)
 {
 	int i;
-	__le32 *page_table = (__le32 *) dma->pgtbl;
+	u32 *page_table = dma->pgtbl;
 
 	for (i = 0; i < dma->num_pages; i++) {
 		/* Each entry needs to be in big endian format. */
-		*page_table = cpu_to_le32((u64) dma->pg_map_arr[i] >> 32);
+		*page_table = (u32) ((u64) dma->pg_map_arr[i] >> 32);
 		page_table++;
-		*page_table = cpu_to_le32(dma->pg_map_arr[i] & 0xffffffff);
+		*page_table = (u32) dma->pg_map_arr[i];
 		page_table++;
 	}
 }
@@ -715,13 +708,13 @@
 static void cnic_setup_page_tbl_le(struct cnic_dev *dev, struct cnic_dma *dma)
 {
 	int i;
-	__le32 *page_table = (__le32 *) dma->pgtbl;
+	u32 *page_table = dma->pgtbl;
 
 	for (i = 0; i < dma->num_pages; i++) {
 		/* Each entry needs to be in little endian format. */
-		*page_table = cpu_to_le32(dma->pg_map_arr[i] & 0xffffffff);
+		*page_table = dma->pg_map_arr[i] & 0xffffffff;
 		page_table++;
-		*page_table = cpu_to_le32((u64) dma->pg_map_arr[i] >> 32);
+		*page_table = (u32) ((u64) dma->pg_map_arr[i] >> 32);
 		page_table++;
 	}
 }
@@ -1157,12 +1150,12 @@
 
 	spin_lock_bh(&cp->cnic_ulp_lock);
 	if (num_wqes > cnic_kwq_avail(cp) &&
-	    !test_bit(CNIC_LCL_FL_KWQ_INIT, &cp->cnic_local_flags)) {
+	    !(cp->cnic_local_flags & CNIC_LCL_FL_KWQ_INIT)) {
 		spin_unlock_bh(&cp->cnic_ulp_lock);
 		return -EAGAIN;
 	}
 
-	clear_bit(CNIC_LCL_FL_KWQ_INIT, &cp->cnic_local_flags);
+	cp->cnic_local_flags &= ~CNIC_LCL_FL_KWQ_INIT;
 
 	prod = cp->kwq_prod_idx;
 	sw_prod = prod & MAX_KWQ_IDX;
@@ -2161,56 +2154,17 @@
 	return last_cnt;
 }
 
-static int cnic_l2_completion(struct cnic_local *cp)
-{
-	u16 hw_cons, sw_cons;
-	union eth_rx_cqe *cqe, *cqe_ring = (union eth_rx_cqe *)
-					(cp->l2_ring + (2 * BCM_PAGE_SIZE));
-	u32 cmd;
-	int comp = 0;
-
-	if (!test_bit(CNIC_F_BNX2X_CLASS, &cp->dev->flags))
-		return 0;
-
-	hw_cons = *cp->rx_cons_ptr;
-	if ((hw_cons & BNX2X_MAX_RCQ_DESC_CNT) == BNX2X_MAX_RCQ_DESC_CNT)
-		hw_cons++;
-
-	sw_cons = cp->rx_cons;
-	while (sw_cons != hw_cons) {
-		u8 cqe_fp_flags;
-
-		cqe = &cqe_ring[sw_cons & BNX2X_MAX_RCQ_DESC_CNT];
-		cqe_fp_flags = cqe->fast_path_cqe.type_error_flags;
-		if (cqe_fp_flags & ETH_FAST_PATH_RX_CQE_TYPE) {
-			cmd = le32_to_cpu(cqe->ramrod_cqe.conn_and_cmd_data);
-			cmd >>= COMMON_RAMROD_ETH_RX_CQE_CMD_ID_SHIFT;
-			if (cmd == RAMROD_CMD_ID_ETH_CLIENT_SETUP ||
-			    cmd == RAMROD_CMD_ID_ETH_HALT)
-				comp++;
-		}
-		sw_cons = BNX2X_NEXT_RCQE(sw_cons);
-	}
-	return comp;
-}
-
 static void cnic_chk_pkt_rings(struct cnic_local *cp)
 {
 	u16 rx_cons = *cp->rx_cons_ptr;
 	u16 tx_cons = *cp->tx_cons_ptr;
-	int comp = 0;
 
 	if (cp->tx_cons != tx_cons || cp->rx_cons != rx_cons) {
-		if (test_bit(CNIC_LCL_FL_L2_WAIT, &cp->cnic_local_flags))
-			comp = cnic_l2_completion(cp);
-
 		cp->tx_cons = tx_cons;
 		cp->rx_cons = rx_cons;
 
 		uio_event_notify(cp->cnic_uinfo);
 	}
-	if (comp)
-		clear_bit(CNIC_LCL_FL_L2_WAIT, &cp->cnic_local_flags);
 }
 
 static int cnic_service_bnx2(void *data, void *status_blk)
@@ -2568,7 +2522,7 @@
 	l4kwqe->sa5 = dev->mac_addr[5];
 
 	l4kwqe->etype = ETH_P_IP;
-	l4kwqe->ipid_start = DEF_IPID_START;
+	l4kwqe->ipid_count = DEF_IPID_COUNT;
 	l4kwqe->host_opaque = csk->l5_cid;
 
 	if (csk->vlan_id) {
@@ -3107,14 +3061,6 @@
 		clear_bit(SK_F_OFFLD_SCHED, &csk->flags);
 		goto done;
 	}
-	/* Possible PG kcqe status:  SUCCESS, OFFLOADED_PG, or CTX_ALLOC_FAIL */
-	if (kcqe->status == L4_KCQE_COMPLETION_STATUS_CTX_ALLOC_FAIL) {
-		clear_bit(SK_F_OFFLD_SCHED, &csk->flags);
-		cnic_cm_upcall(cp, csk,
-			       L4_KCQE_OPCODE_VALUE_CONNECT_COMPLETE);
-		goto done;
-	}
-
 	csk->pg_cid = kcqe->pg_cid;
 	set_bit(SK_F_PG_OFFLD_COMPLETE, &csk->flags);
 	cnic_cm_conn_req(csk);
@@ -3152,13 +3098,6 @@
 	}
 
 	switch (opcode) {
-	case L5CM_RAMROD_CMD_ID_TCP_CONNECT:
-		if (l4kcqe->status != 0) {
-			clear_bit(SK_F_OFFLD_SCHED, &csk->flags);
-			cnic_cm_upcall(cp, csk,
-				       L4_KCQE_OPCODE_VALUE_CONNECT_COMPLETE);
-		}
-		break;
 	case L4_KCQE_OPCODE_VALUE_CONNECT_COMPLETE:
 		if (l4kcqe->status == 0)
 			set_bit(SK_F_OFFLD_COMPLETE, &csk->flags);
@@ -3169,10 +3108,7 @@
 		break;
 
 	case L4_KCQE_OPCODE_VALUE_RESET_RECEIVED:
-		if (test_bit(CNIC_F_BNX2_CLASS, &dev->flags)) {
-			cnic_cm_upcall(cp, csk, opcode);
-			break;
-		} else if (test_and_clear_bit(SK_F_OFFLD_COMPLETE, &csk->flags))
+		if (test_and_clear_bit(SK_F_OFFLD_COMPLETE, &csk->flags))
 			csk->state = opcode;
 		/* fall through */
 	case L4_KCQE_OPCODE_VALUE_CLOSE_COMP:
@@ -3236,16 +3172,6 @@
 		if (!test_and_set_bit(SK_F_CLOSING, &csk->flags))
 			return 1;
 	}
-	/* 57710+ only  workaround to handle unsolicited RESET_COMP
-	 * which will be treated like a RESET RCVD notification
-	 * which triggers the clean up procedure
-	 */
-	else if (opcode == L4_KCQE_OPCODE_VALUE_RESET_COMP) {
-		if (!test_and_set_bit(SK_F_CLOSING, &csk->flags)) {
-			csk->state = L4_KCQE_OPCODE_VALUE_RESET_RECEIVED;
-			return 1;
-		}
-	}
 	return 0;
 }
 
@@ -3255,8 +3181,10 @@
 	struct cnic_local *cp = dev->cnic_priv;
 
 	clear_bit(SK_F_CONNECT_START, &csk->flags);
-	cnic_close_conn(csk);
-	cnic_cm_upcall(cp, csk, opcode);
+	if (cnic_ready_to_close(csk, opcode)) {
+		cnic_close_conn(csk);
+		cnic_cm_upcall(cp, csk, opcode);
+	}
 }
 
 static void cnic_cm_stop_bnx2_hw(struct cnic_dev *dev)
@@ -3395,9 +3323,13 @@
 
 static void cnic_init_context(struct cnic_dev *dev, u32 cid)
 {
+	struct cnic_local *cp = dev->cnic_priv;
 	u32 cid_addr;
 	int i;
 
+	if (CHIP_NUM(cp) == CHIP_NUM_5709)
+		return;
+
 	cid_addr = GET_CID_ADDR(cid);
 
 	for (i = 0; i < CTX_SIZE; i += 4)
@@ -3555,11 +3487,14 @@
 
 	sb_id = cp->status_blk_num;
 	tx_cid = 20;
+	cnic_init_context(dev, tx_cid);
+	cnic_init_context(dev, tx_cid + 1);
 	cp->tx_cons_ptr = &s_blk->status_tx_quick_consumer_index2;
 	if (ethdev->drv_state & CNIC_DRV_STATE_USING_MSIX) {
 		struct status_block_msix *sblk = cp->status_blk.bnx2;
 
 		tx_cid = TX_TSS_CID + sb_id - 1;
+		cnic_init_context(dev, tx_cid);
 		CNIC_WR(dev, BNX2_TSCH_TSS_CFG, (sb_id << 24) |
 			(TX_TSS_CID << 7));
 		cp->tx_cons_ptr = &sblk->status_tx_quick_consumer_index;
@@ -3578,9 +3513,6 @@
 		offset2 = BNX2_L2CTX_TBDR_BHADDR_HI_XI;
 		offset3 = BNX2_L2CTX_TBDR_BHADDR_LO_XI;
 	} else {
-		cnic_init_context(dev, tx_cid);
-		cnic_init_context(dev, tx_cid + 1);
-
 		offset0 = BNX2_L2CTX_TYPE;
 		offset1 = BNX2_L2CTX_CMD_TYPE;
 		offset2 = BNX2_L2CTX_TBDR_BHADDR_HI;
@@ -3754,7 +3686,7 @@
 	cp->max_kwq_idx = MAX_KWQ_IDX;
 	cp->kwq_prod_idx = 0;
 	cp->kwq_con_idx = 0;
-	set_bit(CNIC_LCL_FL_KWQ_INIT, &cp->cnic_local_flags);
+	cp->cnic_local_flags |= CNIC_LCL_FL_KWQ_INIT;
 
 	if (CHIP_NUM(cp) == CHIP_NUM_5706 || CHIP_NUM(cp) == CHIP_NUM_5708)
 		cp->kwq_con_idx_ptr = &sblk->status_rx_quick_consumer_index15;
@@ -3949,9 +3881,8 @@
 		HC_INDEX_DEF_C_ETH_ISCSI_CQ_CONS;
 	context->cstorm_st_context.status_block_id = BNX2X_DEF_SB_ID;
 
-	if (cli < MAX_X_STAT_COUNTER_ID)
-		context->xstorm_st_context.statistics_data = cli |
-				XSTORM_ETH_ST_CONTEXT_STATISTICS_ENABLE;
+	context->xstorm_st_context.statistics_data = (cli |
+				XSTORM_ETH_ST_CONTEXT_STATISTICS_ENABLE);
 
 	context->xstorm_ag_context.cdu_reserved =
 		CDU_RSRVD_VALUE_TYPE_A(BNX2X_HW_CID(BNX2X_ISCSI_L2_CID, func),
@@ -3959,12 +3890,10 @@
 					ETH_CONNECTION_TYPE);
 
 	/* reset xstorm per client statistics */
-	if (cli < MAX_X_STAT_COUNTER_ID) {
-		val = BAR_XSTRORM_INTMEM +
-		      XSTORM_PER_COUNTER_ID_STATS_OFFSET(port, cli);
-		for (i = 0; i < sizeof(struct xstorm_per_client_stats) / 4; i++)
-			CNIC_WR(dev, val + i * 4, 0);
-	}
+	val = BAR_XSTRORM_INTMEM +
+	      XSTORM_PER_COUNTER_ID_STATS_OFFSET(port, cli);
+	for (i = 0; i < sizeof(struct xstorm_per_client_stats) / 4; i++)
+		CNIC_WR(dev, val + i * 4, 0);
 
 	cp->tx_cons_ptr =
 		&cp->bnx2x_def_status_blk->c_def_status_block.index_values[
@@ -4011,11 +3940,9 @@
 						BNX2X_ISCSI_RX_SB_INDEX_NUM;
 	context->ustorm_st_context.common.clientId = cli;
 	context->ustorm_st_context.common.status_block_id = BNX2X_DEF_SB_ID;
-	if (cli < MAX_U_STAT_COUNTER_ID) {
-		context->ustorm_st_context.common.flags =
-			USTORM_ETH_ST_CONTEXT_CONFIG_ENABLE_STATISTICS;
-		context->ustorm_st_context.common.statistics_counter_id = cli;
-	}
+	context->ustorm_st_context.common.flags =
+		USTORM_ETH_ST_CONTEXT_CONFIG_ENABLE_STATISTICS;
+	context->ustorm_st_context.common.statistics_counter_id = cli;
 	context->ustorm_st_context.common.mc_alignment_log_size = 0;
 	context->ustorm_st_context.common.bd_buff_size =
 						cp->l2_single_buf_size;
@@ -4046,13 +3973,10 @@
 
 	/* client tstorm info */
 	tstorm_client.mtu = cp->l2_single_buf_size - 14;
-	tstorm_client.config_flags = TSTORM_ETH_CLIENT_CONFIG_E1HOV_REM_ENABLE;
-
-	if (cli < MAX_T_STAT_COUNTER_ID) {
-		tstorm_client.config_flags |=
-				TSTORM_ETH_CLIENT_CONFIG_STATSITICS_ENABLE;
-		tstorm_client.statistics_counter_id = cli;
-	}
+	tstorm_client.config_flags =
+			(TSTORM_ETH_CLIENT_CONFIG_E1HOV_REM_ENABLE |
+			TSTORM_ETH_CLIENT_CONFIG_STATSITICS_ENABLE);
+	tstorm_client.statistics_counter_id = cli;
 
 	CNIC_WR(dev, BAR_TSTRORM_INTMEM +
 		   TSTORM_CLIENT_CONFIG_OFFSET(port, cli),
@@ -4062,21 +3986,16 @@
 		   ((u32 *)&tstorm_client)[1]);
 
 	/* reset tstorm per client statistics */
-	if (cli < MAX_T_STAT_COUNTER_ID) {
-
-		val = BAR_TSTRORM_INTMEM +
-		      TSTORM_PER_COUNTER_ID_STATS_OFFSET(port, cli);
-		for (i = 0; i < sizeof(struct tstorm_per_client_stats) / 4; i++)
-			CNIC_WR(dev, val + i * 4, 0);
-	}
+	val = BAR_TSTRORM_INTMEM +
+	      TSTORM_PER_COUNTER_ID_STATS_OFFSET(port, cli);
+	for (i = 0; i < sizeof(struct tstorm_per_client_stats) / 4; i++)
+		CNIC_WR(dev, val + i * 4, 0);
 
 	/* reset ustorm per client statistics */
-	if (cli < MAX_U_STAT_COUNTER_ID) {
-		val = BAR_USTRORM_INTMEM +
-		      USTORM_PER_COUNTER_ID_STATS_OFFSET(port, cli);
-		for (i = 0; i < sizeof(struct ustorm_per_client_stats) / 4; i++)
-			CNIC_WR(dev, val + i * 4, 0);
-	}
+	val = BAR_USTRORM_INTMEM +
+	      USTORM_PER_COUNTER_ID_STATS_OFFSET(port, cli);
+	for (i = 0; i < sizeof(struct ustorm_per_client_stats) / 4; i++)
+		CNIC_WR(dev, val + i * 4, 0);
 
 	cp->rx_cons_ptr =
 		&cp->bnx2x_def_status_blk->u_def_status_block.index_values[
@@ -4247,8 +4166,6 @@
 		for (i = 0; i < sizeof(struct ustorm_eth_rx_producers) / 4; i++)
 			CNIC_WR(dev, off + i * 4, ((u32 *) &rx_prods)[i]);
 
-		set_bit(CNIC_LCL_FL_L2_WAIT, &cp->cnic_local_flags);
-
 		cnic_init_bnx2x_tx_ring(dev);
 		cnic_init_bnx2x_rx_ring(dev);
 
@@ -4256,16 +4173,6 @@
 		l5_data.phy_address.hi = 0;
 		cnic_submit_kwqe_16(dev, RAMROD_CMD_ID_ETH_CLIENT_SETUP,
 			BNX2X_ISCSI_L2_CID, ETH_CONNECTION_TYPE, &l5_data);
-		i = 0;
-		while (test_bit(CNIC_LCL_FL_L2_WAIT, &cp->cnic_local_flags) &&
-		       ++i < 10)
-			msleep(1);
-
-		if (test_bit(CNIC_LCL_FL_L2_WAIT, &cp->cnic_local_flags))
-			printk(KERN_ERR PFX
-				"%s: iSCSI CLIENT_SETUP did not complete\n",
-				dev->netdev->name);
-		cnic_kwq_completion(dev, 1);
 		cnic_ring_ctl(dev, BNX2X_ISCSI_L2_CID, cli, 1);
 	}
 }
@@ -4278,26 +4185,15 @@
 		struct cnic_local *cp = dev->cnic_priv;
 		u32 cli = BNX2X_ISCSI_CL_ID(CNIC_E1HVN(cp));
 		union l5cm_specific_data l5_data;
-		int i;
 
 		cnic_ring_ctl(dev, BNX2X_ISCSI_L2_CID, cli, 0);
 
-		set_bit(CNIC_LCL_FL_L2_WAIT, &cp->cnic_local_flags);
-
 		l5_data.phy_address.lo = cli;
 		l5_data.phy_address.hi = 0;
 		cnic_submit_kwqe_16(dev, RAMROD_CMD_ID_ETH_HALT,
 			BNX2X_ISCSI_L2_CID, ETH_CONNECTION_TYPE, &l5_data);
-		i = 0;
-		while (test_bit(CNIC_LCL_FL_L2_WAIT, &cp->cnic_local_flags) &&
-		       ++i < 10)
-			msleep(1);
-
-		if (test_bit(CNIC_LCL_FL_L2_WAIT, &cp->cnic_local_flags))
-			printk(KERN_ERR PFX
-				"%s: iSCSI CLIENT_HALT did not complete\n",
-				dev->netdev->name);
-		cnic_kwq_completion(dev, 1);
+		msleep(10);
+
 		memset(&l5_data, 0, sizeof(l5_data));
 		cnic_submit_kwqe_16(dev, RAMROD_CMD_ID_ETH_CFC_DEL,
 			BNX2X_ISCSI_L2_CID, ETH_CONNECTION_TYPE |
@@ -4419,15 +4315,7 @@
 {
 	if (test_bit(CNIC_F_CNIC_UP, &dev->flags)) {
 		struct cnic_local *cp = dev->cnic_priv;
-		int i = 0;
-
-		/* Need to wait for the ring shutdown event to complete
-		 * before clearing the CNIC_UP flag.
-		 */
-		while (cp->uio_dev != -1 && i < 15) {
-			msleep(100);
-			i++;
-		}
+
 		clear_bit(CNIC_F_CNIC_UP, &dev->flags);
 		rcu_assign_pointer(cp->ulp_ops[CNIC_ULP_L4], NULL);
 		synchronize_rcu();
diff -r 15109ec2f661 drivers/net/cnic.h
--- b/drivers/net/cnic.h	Wed Aug 17 13:31:06 2011 +0100
+++ a/drivers/net/cnic.h	Wed Aug 17 13:09:17 2011 +0100
@@ -101,7 +101,7 @@
 #define BNX2X_KWQ_DATA(cp, x)						\
 	&(cp)->kwq_16_data[BNX2X_KWQ_DATA_PG(cp, x)][BNX2X_KWQ_DATA_IDX(cp, x)]
 
-#define DEF_IPID_START		0x8000
+#define DEF_IPID_COUNT		0xc001
 
 #define DEF_KA_TIMEOUT		10000
 #define DEF_KA_INTERVAL		300000
@@ -179,9 +179,9 @@
 #define ULP_F_CALL_PENDING	2
 	struct cnic_ulp_ops *ulp_ops[MAX_CNIC_ULP_TYPE];
 
-	unsigned long cnic_local_flags;
-#define	CNIC_LCL_FL_KWQ_INIT		0x0
-#define	CNIC_LCL_FL_L2_WAIT		0x1
+	/* protected by ulp_lock */
+	u32 cnic_local_flags;
+#define	CNIC_LCL_FL_KWQ_INIT	0x00000001
 
 	struct cnic_dev *dev;
 
@@ -349,10 +349,6 @@
 #define BNX2X_RCQ_DESC_CNT		(BCM_PAGE_SIZE / sizeof(union eth_rx_cqe))
 #define BNX2X_MAX_RCQ_DESC_CNT		(BNX2X_RCQ_DESC_CNT - 1)
 
-#define BNX2X_NEXT_RCQE(x) (((x) & BNX2X_MAX_RCQ_DESC_CNT) ==		\
-		(BNX2X_MAX_RCQ_DESC_CNT - 1)) ?				\
-		((x) + 2) : ((x) + 1)
-
 #define BNX2X_DEF_SB_ID			16
 
 #define BNX2X_ISCSI_RX_SB_INDEX_NUM					\
diff -r 15109ec2f661 drivers/net/cnic_if.h
--- b/drivers/net/cnic_if.h	Wed Aug 17 13:31:06 2011 +0100
+++ a/drivers/net/cnic_if.h	Wed Aug 17 13:09:17 2011 +0100
@@ -12,8 +12,8 @@
 #ifndef CNIC_IF_H
 #define CNIC_IF_H
 
-#define CNIC_MODULE_VERSION	"2.1.2"
-#define CNIC_MODULE_RELDATE	"May 26, 2010"
+#define CNIC_MODULE_VERSION	"2.1.0"
+#define CNIC_MODULE_RELDATE	"Oct 10, 2009"
 
 #define CNIC_ULP_RDMA		0
 #define CNIC_ULP_ISCSI		1
diff -r 15109ec2f661 drivers/net/cxgb3/ael1002.c
--- b/drivers/net/cxgb3/ael1002.c	Wed Aug 17 13:31:06 2011 +0100
+++ a/drivers/net/cxgb3/ael1002.c	Wed Aug 17 13:09:17 2011 +0100
@@ -934,7 +934,7 @@
 int t3_xaui_direct_phy_prep(struct cphy *phy, struct adapter *adapter,
 			    int phy_addr, const struct mdio_ops *mdio_ops)
 {
-	cphy_init(phy, adapter, phy_addr, &xaui_direct_ops, mdio_ops,
+	cphy_init(phy, adapter, MDIO_PRTAD_NONE, &xaui_direct_ops, mdio_ops,
 		  SUPPORTED_10000baseT_Full | SUPPORTED_AUI | SUPPORTED_TP,
 		  "10GBASE-CX4");
 	return 0;
diff -r 15109ec2f661 drivers/net/cxgb3/common.h
--- b/drivers/net/cxgb3/common.h	Wed Aug 17 13:31:06 2011 +0100
+++ a/drivers/net/cxgb3/common.h	Wed Aug 17 13:09:17 2011 +0100
@@ -125,9 +125,11 @@
 	IRQ_NUM_STATS		/* keep last */
 };
 
-#define TP_VERSION_MAJOR	1
-#define TP_VERSION_MINOR	1
-#define TP_VERSION_MICRO	0
+enum {
+	TP_VERSION_MAJOR	= 1,
+	TP_VERSION_MINOR	= 1,
+	TP_VERSION_MICRO	= 0
+};
 
 #define S_TP_VERSION_MAJOR		16
 #define M_TP_VERSION_MAJOR		0xFF
diff -r 15109ec2f661 drivers/net/cxgb3/cxgb3_main.c
--- b/drivers/net/cxgb3/cxgb3_main.c	Wed Aug 17 13:31:06 2011 +0100
+++ a/drivers/net/cxgb3/cxgb3_main.c	Wed Aug 17 13:09:17 2011 +0100
@@ -44,7 +44,6 @@
 #include <linux/rtnetlink.h>
 #include <linux/firmware.h>
 #include <linux/log2.h>
-#include <linux/stringify.h>
 #include <asm/uaccess.h>
 
 #include "common.h"
@@ -990,21 +989,11 @@
 	return err;
 }
 
-#define FW_VERSION __stringify(FW_VERSION_MAJOR) "."			\
-	__stringify(FW_VERSION_MINOR) "." __stringify(FW_VERSION_MICRO)
-#define FW_FNAME "cxgb3/t3fw-" FW_VERSION ".bin"
-#define TPSRAM_VERSION __stringify(TP_VERSION_MAJOR) "."		\
-	__stringify(TP_VERSION_MINOR) "." __stringify(TP_VERSION_MICRO)
-#define TPSRAM_NAME "cxgb3/t3%c_psram-" TPSRAM_VERSION ".bin"
+#define FW_FNAME "cxgb3/t3fw-%d.%d.%d.bin"
+#define TPSRAM_NAME "cxgb3/t3%c_psram-%d.%d.%d.bin"
 #define AEL2005_OPT_EDC_NAME "cxgb3/ael2005_opt_edc.bin"
 #define AEL2005_TWX_EDC_NAME "cxgb3/ael2005_twx_edc.bin"
 #define AEL2020_TWX_EDC_NAME "cxgb3/ael2020_twx_edc.bin"
-MODULE_FIRMWARE(FW_FNAME);
-MODULE_FIRMWARE("cxgb3/t3b_psram-" TPSRAM_VERSION ".bin");
-MODULE_FIRMWARE("cxgb3/t3c_psram-" TPSRAM_VERSION ".bin");
-MODULE_FIRMWARE(AEL2005_OPT_EDC_NAME);
-MODULE_FIRMWARE(AEL2005_TWX_EDC_NAME);
-MODULE_FIRMWARE(AEL2020_TWX_EDC_NAME);
 
 static inline const char *get_edc_fw_name(int edc_idx)
 {
@@ -1075,13 +1064,16 @@
 static int upgrade_fw(struct adapter *adap)
 {
 	int ret;
+	char buf[64];
 	const struct firmware *fw;
 	struct device *dev = &adap->pdev->dev;
 
-	ret = request_firmware(&fw, FW_FNAME, dev);
+	snprintf(buf, sizeof(buf), FW_FNAME, FW_VERSION_MAJOR,
+		 FW_VERSION_MINOR, FW_VERSION_MICRO);
+	ret = request_firmware(&fw, buf, dev);
 	if (ret < 0) {
 		dev_err(dev, "could not upgrade firmware: unable to load %s\n",
-			FW_FNAME);
+			buf);
 		return ret;
 	}
 	ret = t3_load_fw(adap, fw->data, fw->size);
@@ -1125,7 +1117,8 @@
 	if (!rev)
 		return 0;
 
-	snprintf(buf, sizeof(buf), TPSRAM_NAME, rev);
+	snprintf(buf, sizeof(buf), TPSRAM_NAME, rev,
+		 TP_VERSION_MAJOR, TP_VERSION_MINOR, TP_VERSION_MICRO);
 
 	ret = request_firmware(&tpsram, buf, dev);
 	if (ret < 0) {
@@ -1272,7 +1265,7 @@
 /*
  * Release resources when all the ports and offloading have been stopped.
  */
-static void cxgb_down(struct adapter *adapter, int on_wq)
+static void cxgb_down(struct adapter *adapter)
 {
 	t3_sge_stop(adapter);
 	spin_lock_irq(&adapter->work_lock);	/* sync with PHY intr task */
@@ -1282,8 +1275,7 @@
 	free_irq_resources(adapter);
 	quiesce_rx(adapter);
 	t3_sge_stop(adapter);
-	if (!on_wq)
-		flush_workqueue(cxgb3_wq);/* wait for external IRQ handler */
+	flush_workqueue(cxgb3_wq);	/* wait for external IRQ handler */
 }
 
 static void schedule_chk_task(struct adapter *adap)
@@ -1361,7 +1353,7 @@
 	clear_bit(OFFLOAD_DEVMAP_BIT, &adapter->open_device_map);
 
 	if (!adapter->open_device_map)
-		cxgb_down(adapter, 0);
+		cxgb_down(adapter);
 
 	cxgb3_offload_deactivate(adapter);
 	return 0;
@@ -1396,7 +1388,7 @@
 	return 0;
 }
 
-static int __cxgb_close(struct net_device *dev, int on_wq)
+static int cxgb_close(struct net_device *dev)
 {
 	struct port_info *pi = netdev_priv(dev);
 	struct adapter *adapter = pi->adapter;
@@ -1423,17 +1415,12 @@
 		cancel_delayed_work_sync(&adapter->adap_check_task);
 
 	if (!adapter->open_device_map)
-		cxgb_down(adapter, on_wq);
+		cxgb_down(adapter);
 
 	cxgb3_event_notify(&adapter->tdev, OFFLOAD_PORT_DOWN, pi->port_id);
 	return 0;
 }
 
-static int cxgb_close(struct net_device *dev)
-{
-	return __cxgb_close(dev, 0);
-}
-
 static struct net_device_stats *cxgb_get_stats(struct net_device *dev)
 {
 	struct port_info *pi = netdev_priv(dev);
@@ -2288,8 +2275,6 @@
 	case CHELSIO_GET_QSET_NUM:{
 		struct ch_reg edata;
 
-		memset(&edata, 0, sizeof(struct ch_reg));
-
 		edata.cmd = CHELSIO_GET_QSET_NUM;
 		edata.val = pi->nqsets;
 		if (copy_to_user(useraddr, &edata, sizeof(edata)))
@@ -2826,7 +2811,7 @@
 	spin_unlock(&adapter->work_lock);
 }
 
-static int t3_adapter_error(struct adapter *adapter, int reset, int on_wq)
+static int t3_adapter_error(struct adapter *adapter, int reset)
 {
 	int i, ret = 0;
 
@@ -2841,7 +2826,7 @@
 		struct net_device *netdev = adapter->port[i];
 
 		if (netif_running(netdev))
-			__cxgb_close(netdev, on_wq);
+			cxgb_close(netdev);
 	}
 
 	/* Stop SGE timers */
@@ -2912,7 +2897,7 @@
 	int err = 0;
 
 	rtnl_lock();
-	err = t3_adapter_error(adapter, 1, 1);
+	err = t3_adapter_error(adapter, 1);
 	if (!err)
 		err = t3_reenable_adapter(adapter);
 	if (!err)
@@ -2962,7 +2947,7 @@
 	if (state == pci_channel_io_perm_failure)
 		return PCI_ERS_RESULT_DISCONNECT;
 
-	ret = t3_adapter_error(adapter, 0, 0);
+	ret = t3_adapter_error(adapter, 0);
 
 	/* Request a slot reset. */
 	return PCI_ERS_RESULT_NEED_RESET;
diff -r 15109ec2f661 drivers/net/cxgb3/regs.h
--- b/drivers/net/cxgb3/regs.h	Wed Aug 17 13:31:06 2011 +0100
+++ a/drivers/net/cxgb3/regs.h	Wed Aug 17 13:09:17 2011 +0100
@@ -1981,10 +1981,6 @@
 
 #define A_PL_RST 0x6f0
 
-#define S_FATALPERREN    4
-#define V_FATALPERREN(x) ((x) << S_FATALPERREN)
-#define F_FATALPERREN    V_FATALPERREN(1U)
-
 #define S_CRSTWRM    1
 #define V_CRSTWRM(x) ((x) << S_CRSTWRM)
 #define F_CRSTWRM    V_CRSTWRM(1U)
diff -r 15109ec2f661 drivers/net/cxgb3/t3_hw.c
--- b/drivers/net/cxgb3/t3_hw.c	Wed Aug 17 13:31:06 2011 +0100
+++ a/drivers/net/cxgb3/t3_hw.c	Wed Aug 17 13:09:17 2011 +0100
@@ -1416,7 +1416,6 @@
 			fatal++;
 			CH_ALERT(adapter, "%s (0x%x)\n",
 				 acts->msg, status & acts->mask);
-			status &= ~acts->mask;
 		} else if (acts->msg)
 			CH_WARN(adapter, "%s (0x%x)\n",
 				acts->msg, status & acts->mask);
@@ -1849,10 +1848,11 @@
 		t3_os_link_fault_handler(adap, idx);
 	}
 
+	t3_write_reg(adap, A_XGM_INT_CAUSE + mac->offset, cause);
+
 	if (cause & XGM_INTR_FATAL)
 		t3_fatal_err(adap);
 
-	t3_write_reg(adap, A_XGM_INT_CAUSE + mac->offset, cause);
 	return cause != 0;
 }
 
@@ -3574,7 +3574,6 @@
 	t3_write_reg(adapter, A_PM1_TX_MODE, 0);
 	chan_init_hw(adapter, adapter->params.chan_map);
 	t3_sge_init(adapter, &adapter->params.sge);
-	t3_set_reg_field(adapter, A_PL_RST, 0, F_FATALPERREN);
 
 	t3_write_reg(adapter, A_T3DBG_GPIO_ACT_LOW, calc_gpio_intr(adapter));
 
@@ -3688,7 +3687,7 @@
 	mc7->name = name;
 	mc7->offset = base_addr - MC7_PMRX_BASE_ADDR;
 	cfg = t3_read_reg(adapter, mc7->offset + A_MC7_CFG);
-	mc7->size = G_DEN(cfg) == M_DEN ? 0 : mc7_calc_size(cfg);
+	mc7->size = mc7->size = G_DEN(cfg) == M_DEN ? 0 : mc7_calc_size(cfg);
 	mc7->width = G_WIDTH(cfg);
 }
 
diff -r 15109ec2f661 drivers/net/e1000/e1000_main.c
--- b/drivers/net/e1000/e1000_main.c	Wed Aug 17 13:31:06 2011 +0100
+++ a/drivers/net/e1000/e1000_main.c	Wed Aug 17 13:09:17 2011 +0100
@@ -797,70 +797,6 @@
 };
 
 /**
- * e1000_init_hw_struct - initialize members of hw struct
- * @adapter: board private struct
- * @hw: structure used by e1000_hw.c
- *
- * Factors out initialization of the e1000_hw struct to its own function
- * that can be called very early at init (just after struct allocation).
- * Fields are initialized based on PCI device information and
- * OS network device settings (MTU size).
- * Returns negative error codes if MAC type setup fails.
- */
-static int e1000_init_hw_struct(struct e1000_adapter *adapter,
-				struct e1000_hw *hw)
-{
-	struct pci_dev *pdev = adapter->pdev;
-
-	/* PCI config space info */
-	hw->vendor_id = pdev->vendor;
-	hw->device_id = pdev->device;
-	hw->subsystem_vendor_id = pdev->subsystem_vendor;
-	hw->subsystem_id = pdev->subsystem_device;
-	hw->revision_id = pdev->revision;
-
-	pci_read_config_word(pdev, PCI_COMMAND, &hw->pci_cmd_word);
-
-	hw->max_frame_size = adapter->netdev->mtu +
-			     ENET_HEADER_SIZE + ETHERNET_FCS_SIZE;
-	hw->min_frame_size = MINIMUM_ETHERNET_FRAME_SIZE;
-
-	/* identify the MAC */
-	if (e1000_set_mac_type(hw)) {
-		DPRINTK(PROBE, ERR, "Unknown MAC Type\n");
-		return -EIO;
-	}
-
-	switch (hw->mac_type) {
-	default:
-		break;
-	case e1000_82541:
-	case e1000_82547:
-	case e1000_82541_rev_2:
-	case e1000_82547_rev_2:
-		hw->phy_init_script = 1;
-		break;
-	}
-
-	e1000_set_media_type(hw);
-	e1000_get_bus_info(hw);
-
-	hw->wait_autoneg_complete = false;
-	hw->tbi_compatibility_en = true;
-	hw->adaptive_ifs = true;
-
-	/* Copper options */
-
-	if (hw->media_type == e1000_media_type_copper) {
-		hw->mdix = AUTO_ALL_MODES;
-		hw->disable_polarity_correction = false;
-		hw->master_slave = E1000_MASTER_SLAVE;
-	}
-
-	return 0;
-}
-
-/**
  * e1000_probe - Device Initialization Routine
  * @pdev: PCI device information struct
  * @ent: entry in e1000_pci_tbl
@@ -897,6 +833,22 @@
 	if (err)
 		return err;
 
+	if (!pci_set_dma_mask(pdev, DMA_BIT_MASK(64)) &&
+	    !pci_set_consistent_dma_mask(pdev, DMA_BIT_MASK(64))) {
+		pci_using_dac = 1;
+	} else {
+		err = pci_set_dma_mask(pdev, DMA_BIT_MASK(32));
+		if (err) {
+			err = pci_set_consistent_dma_mask(pdev, DMA_BIT_MASK(32));
+			if (err) {
+				E1000_ERR("No usable DMA configuration, "
+					  "aborting\n");
+				goto err_dma;
+			}
+		}
+		pci_using_dac = 0;
+	}
+
 	err = pci_request_selected_regions(pdev, bars, e1000_driver_name);
 	if (err)
 		goto err_pci_reg;
@@ -937,32 +889,6 @@
 		}
 	}
 
-	/* make ready for any if (hw->...) below */
-	err = e1000_init_hw_struct(adapter, hw);
-	if (err)
-		goto err_sw_init;
-
-	/*
-	 * there is a workaround being applied below that limits
-	 * 64-bit DMA addresses to 64-bit hardware.  There are some
-	 * 32-bit adapters that Tx hang when given 64-bit DMA addresses
-	 */
-	pci_using_dac = 0;
-	if ((hw->bus_type == e1000_bus_type_pcix) &&
-	    !pci_set_dma_mask(pdev, DMA_BIT_MASK(64))) {
-		/*
-		 * according to DMA-API-HOWTO, coherent calls will always
-		 * succeed if the set call did
-		 */
-		pci_set_consistent_dma_mask(pdev, DMA_BIT_MASK(64));
-		pci_using_dac = 1;
-	} else if (!pci_set_dma_mask(pdev, DMA_BIT_MASK(32))) {
-		pci_set_consistent_dma_mask(pdev, DMA_BIT_MASK(32));
-	} else {
-		E1000_ERR("No usable DMA configuration, aborting\n");
-		goto err_dma;
-	}
-
 	netdev->netdev_ops = &e1000_netdev_ops;
 	e1000_set_ethtool_ops(netdev);
 	netdev->watchdog_timeo = 5 * HZ;
@@ -1037,6 +963,8 @@
 	if (!is_valid_ether_addr(netdev->perm_addr))
 		DPRINTK(PROBE, ERR, "Invalid MAC Address\n");
 
+	e1000_get_bus_info(hw);
+
 	init_timer(&adapter->tx_fifo_stall_timer);
 	adapter->tx_fifo_stall_timer.function = &e1000_82547_tx_fifo_stall;
 	adapter->tx_fifo_stall_timer.data = (unsigned long)adapter;
@@ -1149,7 +1077,6 @@
 		iounmap(hw->flash_address);
 	kfree(adapter->tx_ring);
 	kfree(adapter->rx_ring);
-err_dma:
 err_sw_init:
 	iounmap(hw->hw_addr);
 err_ioremap:
@@ -1157,6 +1084,7 @@
 err_alloc_etherdev:
 	pci_release_selected_regions(pdev, bars);
 err_pci_reg:
+err_dma:
 	pci_disable_device(pdev);
 	return err;
 }
@@ -1208,12 +1136,62 @@
  * @adapter: board private structure to initialize
  *
  * e1000_sw_init initializes the Adapter private data structure.
- * e1000_init_hw_struct MUST be called before this function
+ * Fields are initialized based on PCI device information and
+ * OS network device settings (MTU size).
  **/
 
 static int __devinit e1000_sw_init(struct e1000_adapter *adapter)
 {
+	struct e1000_hw *hw = &adapter->hw;
+	struct net_device *netdev = adapter->netdev;
+	struct pci_dev *pdev = adapter->pdev;
+
+	/* PCI config space info */
+
+	hw->vendor_id = pdev->vendor;
+	hw->device_id = pdev->device;
+	hw->subsystem_vendor_id = pdev->subsystem_vendor;
+	hw->subsystem_id = pdev->subsystem_device;
+	hw->revision_id = pdev->revision;
+
+	pci_read_config_word(pdev, PCI_COMMAND, &hw->pci_cmd_word);
+
 	adapter->rx_buffer_len = MAXIMUM_ETHERNET_VLAN_SIZE;
+	hw->max_frame_size = netdev->mtu +
+			     ENET_HEADER_SIZE + ETHERNET_FCS_SIZE;
+	hw->min_frame_size = MINIMUM_ETHERNET_FRAME_SIZE;
+
+	/* identify the MAC */
+
+	if (e1000_set_mac_type(hw)) {
+		DPRINTK(PROBE, ERR, "Unknown MAC Type\n");
+		return -EIO;
+	}
+
+	switch (hw->mac_type) {
+	default:
+		break;
+	case e1000_82541:
+	case e1000_82547:
+	case e1000_82541_rev_2:
+	case e1000_82547_rev_2:
+		hw->phy_init_script = 1;
+		break;
+	}
+
+	e1000_set_media_type(hw);
+
+	hw->wait_autoneg_complete = false;
+	hw->tbi_compatibility_en = true;
+	hw->adaptive_ifs = true;
+
+	/* Copper options */
+
+	if (hw->media_type == e1000_media_type_copper) {
+		hw->mdix = AUTO_ALL_MODES;
+		hw->disable_polarity_correction = false;
+		hw->master_slave = E1000_MASTER_SLAVE;
+	}
 
 	adapter->num_tx_queues = 1;
 	adapter->num_rx_queues = 1;
diff -r 15109ec2f661 drivers/net/e1000e/e1000.h
--- b/drivers/net/e1000e/e1000.h	Wed Aug 17 13:31:06 2011 +0100
+++ a/drivers/net/e1000e/e1000.h	Wed Aug 17 13:09:17 2011 +0100
@@ -193,15 +193,12 @@
 			unsigned long time_stamp;
 			u16 length;
 			u16 next_to_watch;
-			u16 mapped_as_page;
 		};
 		/* Rx */
-		struct {
-			/* arrays of page information for packet split */
-			struct e1000_ps_page *ps_pages;
-			struct page *page;
-		};
+		/* arrays of page information for packet split */
+		struct e1000_ps_page *ps_pages;
 	};
+	struct page *page;
 };
 
 struct e1000_ring {
diff -r 15109ec2f661 drivers/net/e1000e/hw.h
--- b/drivers/net/e1000e/hw.h	Wed Aug 17 13:31:06 2011 +0100
+++ a/drivers/net/e1000e/hw.h	Wed Aug 17 13:09:17 2011 +0100
@@ -304,7 +304,7 @@
 #define E1000_KMRNCTRLSTA_DIAG_OFFSET	0x3    /* Kumeran Diagnostic */
 #define E1000_KMRNCTRLSTA_DIAG_NELPBK	0x1000 /* Nearend Loopback mode */
 #define E1000_KMRNCTRLSTA_K1_CONFIG	0x7
-#define E1000_KMRNCTRLSTA_K1_ENABLE	0x0002
+#define E1000_KMRNCTRLSTA_K1_ENABLE	0x140E
 #define E1000_KMRNCTRLSTA_K1_DISABLE	0x1400
 
 #define IFE_PHY_EXTENDED_STATUS_CONTROL	0x10
diff -r 15109ec2f661 drivers/net/e1000e/ich8lan.c
--- b/drivers/net/e1000e/ich8lan.c	Wed Aug 17 13:31:06 2011 +0100
+++ a/drivers/net/e1000e/ich8lan.c	Wed Aug 17 13:09:17 2011 +0100
@@ -274,16 +274,6 @@
 	phy->ops.write_phy_reg_locked = e1000_write_phy_reg_hv_locked;
 	phy->autoneg_mask             = AUTONEG_ADVERTISE_SPEED_DEFAULT;
 
-	/*
-	 * Reset the PHY before any acccess to it.  Doing so, ensures that
-	 * the PHY is in a known good state before we read/write PHY registers.
-	 * The generic reset is sufficient here, because we haven't determined
-	 * the PHY type yet.
-	 */
-	ret_val = e1000e_phy_hw_reset_generic(hw);
-	if (ret_val)
-		goto out;
-
 	phy->id = e1000_phy_unknown;
 	e1000e_get_phy_id(hw);
 	phy->type = e1000e_get_phy_type_from_id(phy->id);
@@ -297,7 +287,6 @@
 		phy->ops.commit_phy = e1000e_phy_sw_reset;
 	}
 
- out:
 	return ret_val;
 }
 
diff -r 15109ec2f661 drivers/net/e1000e/netdev.c
--- b/drivers/net/e1000e/netdev.c	Wed Aug 17 13:31:06 2011 +0100
+++ a/drivers/net/e1000e/netdev.c	Wed Aug 17 13:09:17 2011 +0100
@@ -555,17 +555,10 @@
 static void e1000_put_txbuf(struct e1000_adapter *adapter,
 			     struct e1000_buffer *buffer_info)
 {
-	if (buffer_info->dma) {
-		if (buffer_info->mapped_as_page)
-			pci_unmap_page(adapter->pdev, buffer_info->dma,
-				       buffer_info->length, PCI_DMA_TODEVICE);
-		else
-			pci_unmap_single(adapter->pdev,	buffer_info->dma,
-					 buffer_info->length,
-					 PCI_DMA_TODEVICE);
-		buffer_info->dma = 0;
-	}
+	buffer_info->dma = 0;
 	if (buffer_info->skb) {
+		skb_dma_unmap(&adapter->pdev->dev, buffer_info->skb,
+		              DMA_TO_DEVICE);
 		dev_kfree_skb_any(buffer_info->skb);
 		buffer_info->skb = NULL;
 	}
@@ -1548,8 +1541,8 @@
 
 	if (entropy)
 		irq_flags |= IRQF_SAMPLE_RANDOM;
-	err = request_irq(adapter->pdev->irq, &e1000_intr,
-			  irq_flags | IRQF_SHARED, netdev->name, netdev);
+	err = request_irq(adapter->pdev->irq, &e1000_intr, irq_flags,
+			  netdev->name, netdev);
 	if (err)
 		e_err("Unable to allocate interrupt, Error: %d\n", err);
 
@@ -3058,18 +3051,13 @@
 
 	/* disable SERR in case the MSI write causes a master abort */
 	pci_read_config_word(adapter->pdev, PCI_COMMAND, &pci_cmd);
-	if (pci_cmd & PCI_COMMAND_SERR)
-		pci_write_config_word(adapter->pdev, PCI_COMMAND,
-				      pci_cmd & ~PCI_COMMAND_SERR);
+	pci_write_config_word(adapter->pdev, PCI_COMMAND,
+			      pci_cmd & ~PCI_COMMAND_SERR);
 
 	err = e1000_test_msi_interrupt(adapter);
 
-	/* re-enable SERR */
-	if (pci_cmd & PCI_COMMAND_SERR) {
-		pci_read_config_word(adapter->pdev, PCI_COMMAND, &pci_cmd);
-		pci_cmd |= PCI_COMMAND_SERR;
-		pci_write_config_word(adapter->pdev, PCI_COMMAND, pci_cmd);
-	}
+	/* restore previous setting of command word */
+	pci_write_config_word(adapter->pdev, PCI_COMMAND, pci_cmd);
 
 	/* success ! */
 	if (!err)
@@ -3906,14 +3894,23 @@
 			unsigned int mss)
 {
 	struct e1000_ring *tx_ring = adapter->tx_ring;
-	struct pci_dev *pdev = adapter->pdev;
 	struct e1000_buffer *buffer_info;
 	unsigned int len = skb_headlen(skb);
-	unsigned int offset = 0, size, count = 0, i;
+	unsigned int offset, size, count = 0, i;
 	unsigned int f;
+	dma_addr_t *map;
 
 	i = tx_ring->next_to_use;
 
+	if (skb_dma_map(&adapter->pdev->dev, skb, DMA_TO_DEVICE)) {
+		dev_err(&adapter->pdev->dev, "TX DMA map failed\n");
+		adapter->tx_dma_failed++;
+		return 0;
+	}
+
+	map = skb_shinfo(skb)->dma_maps;
+	offset = 0;
+
 	while (len) {
 		buffer_info = &tx_ring->buffer_info[i];
 		size = min(len, max_per_txd);
@@ -3921,15 +3918,11 @@
 		buffer_info->length = size;
 		buffer_info->time_stamp = jiffies;
 		buffer_info->next_to_watch = i;
-		buffer_info->dma = pci_map_single(pdev,	skb->data + offset,
-						  size,	PCI_DMA_TODEVICE);
-		buffer_info->mapped_as_page = false;
-		if (pci_dma_mapping_error(pdev, buffer_info->dma))
-			goto dma_error;
+		buffer_info->dma = skb_shinfo(skb)->dma_head + offset;
+		count++;
 
 		len -= size;
 		offset += size;
-		count++;
 
 		if (len) {
 			i++;
@@ -3943,7 +3936,7 @@
 
 		frag = &skb_shinfo(skb)->frags[f];
 		len = frag->size;
-		offset = frag->page_offset;
+		offset = 0;
 
 		while (len) {
 			i++;
@@ -3956,12 +3949,7 @@
 			buffer_info->length = size;
 			buffer_info->time_stamp = jiffies;
 			buffer_info->next_to_watch = i;
-			buffer_info->dma = pci_map_page(pdev, frag->page,
-							offset, size,
-							PCI_DMA_TODEVICE);
-			buffer_info->mapped_as_page = true;
-			if (pci_dma_mapping_error(pdev, buffer_info->dma))
-				goto dma_error;
+			buffer_info->dma = map[f] + offset;
 
 			len -= size;
 			offset += size;
@@ -3973,22 +3961,6 @@
 	tx_ring->buffer_info[first].next_to_watch = i;
 
 	return count;
-
-dma_error:
-	dev_err(&pdev->dev, "TX DMA map failed\n");
-	buffer_info->dma = 0;
-	count--;
-
-	while (count >= 0) {
-		count--;
-		i--;
-		if (i < 0)
-			i += tx_ring->count;
-		buffer_info = &tx_ring->buffer_info[i];
-		e1000_put_txbuf(adapter, buffer_info);;
-	}
-
-	return 0;
 }
 
 static void e1000_tx_queue(struct e1000_adapter *adapter,
@@ -5189,8 +5161,7 @@
 		/* APME bit in EEPROM is mapped to WUC.APME */
 		eeprom_data = er32(WUC);
 		eeprom_apme_mask = E1000_WUC_APME;
-		if ((hw->mac.type > e1000_ich10lan) &&
-		    (eeprom_data & E1000_WUC_PHY_WAKE))
+		if (eeprom_data & E1000_WUC_PHY_WAKE)
 			adapter->flags2 |= FLAG2_HAS_PHY_WAKEUP;
 	} else if (adapter->flags & FLAG_APME_IN_CTRL3) {
 		if (adapter->flags & FLAG_APME_CHECK_PORT_B &&
diff -r 15109ec2f661 drivers/net/enic/cq_desc.h
--- b/drivers/net/enic/cq_desc.h	Wed Aug 17 13:31:06 2011 +0100
+++ a/drivers/net/enic/cq_desc.h	Wed Aug 17 13:09:17 2011 +0100
@@ -1,5 +1,5 @@
 /*
- * Copyright 2008-2010 Cisco Systems, Inc.  All rights reserved.
+ * Copyright 2008 Cisco Systems, Inc.  All rights reserved.
  * Copyright 2007 Nuova Systems, Inc.  All rights reserved.
  *
  * This program is free software; you may redistribute it and/or modify
diff -r 15109ec2f661 drivers/net/enic/cq_enet_desc.h
--- b/drivers/net/enic/cq_enet_desc.h	Wed Aug 17 13:31:06 2011 +0100
+++ a/drivers/net/enic/cq_enet_desc.h	Wed Aug 17 13:09:17 2011 +0100
@@ -1,5 +1,5 @@
 /*
- * Copyright 2008-2010 Cisco Systems, Inc.  All rights reserved.
+ * Copyright 2008 Cisco Systems, Inc.  All rights reserved.
  * Copyright 2007 Nuova Systems, Inc.  All rights reserved.
  *
  * This program is free software; you may redistribute it and/or modify
@@ -73,16 +73,7 @@
 #define CQ_ENET_RQ_DESC_FLAGS_TRUNCATED             (0x1 << 14)
 #define CQ_ENET_RQ_DESC_FLAGS_VLAN_STRIPPED         (0x1 << 15)
 
-#define CQ_ENET_RQ_DESC_VLAN_TCI_VLAN_BITS          12
-#define CQ_ENET_RQ_DESC_VLAN_TCI_VLAN_MASK \
-	((1 << CQ_ENET_RQ_DESC_VLAN_TCI_VLAN_BITS) - 1)
-#define CQ_ENET_RQ_DESC_VLAN_TCI_CFI_MASK           (0x1 << 12)
-#define CQ_ENET_RQ_DESC_VLAN_TCI_USER_PRIO_BITS     3
-#define CQ_ENET_RQ_DESC_VLAN_TCI_USER_PRIO_MASK \
-	((1 << CQ_ENET_RQ_DESC_VLAN_TCI_USER_PRIO_BITS) - 1)
-#define CQ_ENET_RQ_DESC_VLAN_TCI_USER_PRIO_SHIFT    13
-
-#define CQ_ENET_RQ_DESC_FCOE_SOF_BITS               8
+#define CQ_ENET_RQ_DESC_FCOE_SOF_BITS               4
 #define CQ_ENET_RQ_DESC_FCOE_SOF_MASK \
 	((1 << CQ_ENET_RQ_DESC_FCOE_SOF_BITS) - 1)
 #define CQ_ENET_RQ_DESC_FCOE_EOF_BITS               8
@@ -105,23 +96,19 @@
 	u8 *type, u8 *color, u16 *q_number, u16 *completed_index,
 	u8 *ingress_port, u8 *fcoe, u8 *eop, u8 *sop, u8 *rss_type,
 	u8 *csum_not_calc, u32 *rss_hash, u16 *bytes_written, u8 *packet_error,
-	u8 *vlan_stripped, u16 *vlan_tci, u16 *checksum, u8 *fcoe_sof,
+	u8 *vlan_stripped, u16 *vlan, u16 *checksum, u8 *fcoe_sof,
 	u8 *fcoe_fc_crc_ok, u8 *fcoe_enc_error, u8 *fcoe_eof,
 	u8 *tcp_udp_csum_ok, u8 *udp, u8 *tcp, u8 *ipv4_csum_ok,
 	u8 *ipv6, u8 *ipv4, u8 *ipv4_fragment, u8 *fcs_ok)
 {
-	u16 completed_index_flags;
-	u16 q_number_rss_type_flags;
-	u16 bytes_written_flags;
+	u16 completed_index_flags = le16_to_cpu(desc->completed_index_flags);
+	u16 q_number_rss_type_flags =
+		le16_to_cpu(desc->q_number_rss_type_flags);
+	u16 bytes_written_flags = le16_to_cpu(desc->bytes_written_flags);
 
 	cq_desc_dec((struct cq_desc *)desc, type,
 		color, q_number, completed_index);
 
-	completed_index_flags = le16_to_cpu(desc->completed_index_flags);
-	q_number_rss_type_flags =
-		le16_to_cpu(desc->q_number_rss_type_flags);
-	bytes_written_flags = le16_to_cpu(desc->bytes_written_flags);
-
 	*ingress_port = (completed_index_flags &
 		CQ_ENET_RQ_DESC_FLAGS_INGRESS_PORT) ? 1 : 0;
 	*fcoe = (completed_index_flags & CQ_ENET_RQ_DESC_FLAGS_FCOE) ?
@@ -145,10 +132,7 @@
 	*vlan_stripped = (bytes_written_flags &
 		CQ_ENET_RQ_DESC_FLAGS_VLAN_STRIPPED) ? 1 : 0;
 
-	/*
-	 * Tag Control Information(16) = user_priority(3) + cfi(1) + vlan(12)
-	 */
-	*vlan_tci = le16_to_cpu(desc->vlan);
+	*vlan = le16_to_cpu(desc->vlan);
 
 	if (*fcoe) {
 		*fcoe_sof = (u8)(le16_to_cpu(desc->checksum_fcoe) &
diff -r 15109ec2f661 drivers/net/enic/enic.h
--- b/drivers/net/enic/enic.h	Wed Aug 17 13:31:06 2011 +0100
+++ a/drivers/net/enic/enic.h	Wed Aug 17 13:09:17 2011 +0100
@@ -1,5 +1,5 @@
 /*
- * Copyright 2008-2010 Cisco Systems, Inc.  All rights reserved.
+ * Copyright 2008 Cisco Systems, Inc.  All rights reserved.
  * Copyright 2007 Nuova Systems, Inc.  All rights reserved.
  *
  * This program is free software; you may redistribute it and/or modify
@@ -20,6 +20,8 @@
 #ifndef _ENIC_H_
 #define _ENIC_H_
 
+#include <linux/inet_lro.h>
+
 #include "vnic_enet.h"
 #include "vnic_dev.h"
 #include "vnic_wq.h"
@@ -31,11 +33,14 @@
 #include "vnic_rss.h"
 
 #define DRV_NAME		"enic"
-#define DRV_DESCRIPTION		"Cisco VIC Ethernet NIC Driver"
-#define DRV_VERSION		"1.4.1.2-1"
-#define DRV_COPYRIGHT		"Copyright 2008-2010 Cisco Systems, Inc"
+#define DRV_DESCRIPTION		"Cisco 10G Ethernet Driver"
+#define DRV_VERSION		"1.1.0.100"
+#define DRV_COPYRIGHT		"Copyright 2008-2009 Cisco Systems, Inc"
 #define PFX			DRV_NAME ": "
 
+#define ENIC_LRO_MAX_DESC	8
+#define ENIC_LRO_MAX_AGGR	64
+
 #define ENIC_BARS_MAX		6
 
 #define ENIC_WQ_MAX		8
@@ -84,20 +89,15 @@
 	spinlock_t devcmd_lock;
 	u8 mac_addr[ETH_ALEN];
 	u8 mc_addr[ENIC_MULTICAST_PERFECT_FILTERS][ETH_ALEN];
-	unsigned int flags;
 	unsigned int mc_count;
 	int csum_rx_enabled;
 	u32 port_mtu;
-	u32 rx_coalesce_usecs;
-	u32 tx_coalesce_usecs;
 
 	/* work queue cache line section */
 	____cacheline_aligned struct vnic_wq wq[ENIC_WQ_MAX];
 	spinlock_t wq_lock[ENIC_WQ_MAX];
 	unsigned int wq_count;
 	struct vlan_group *vlan_group;
-	u16 loop_enable;
-	u16 loop_tag;
 
 	/* receive queue cache line section */
 	____cacheline_aligned struct vnic_rq rq[ENIC_RQ_MAX];
@@ -106,6 +106,8 @@
 	u64 rq_truncated_pkts;
 	u64 rq_bad_fcs;
 	struct napi_struct napi;
+	struct net_lro_mgr lro_mgr;
+	struct net_lro_desc lro_desc[ENIC_LRO_MAX_DESC];
 
 	/* interrupt resource cache line section */
 	____cacheline_aligned struct vnic_intr intr[ENIC_INTR_MAX];
diff -r 15109ec2f661 drivers/net/enic/enic_main.c
--- b/drivers/net/enic/enic_main.c	Wed Aug 17 13:31:06 2011 +0100
+++ a/drivers/net/enic/enic_main.c	Wed Aug 17 13:09:17 2011 +0100
@@ -1,5 +1,5 @@
 /*
- * Copyright 2008-2010 Cisco Systems, Inc.  All rights reserved.
+ * Copyright 2008 Cisco Systems, Inc.  All rights reserved.
  * Copyright 2007 Nuova Systems, Inc.  All rights reserved.
  *
  * This program is free software; you may redistribute it and/or modify
@@ -34,7 +34,6 @@
 #include <linux/ip.h>
 #include <linux/ipv6.h>
 #include <linux/tcp.h>
-#include <linux/rtnetlink.h>
 #include <net/ip6_checksum.h>
 
 #include "cq_enet_desc.h"
@@ -52,7 +51,7 @@
 #define PCI_DEVICE_ID_CISCO_VIC_ENET         0x0043  /* ethernet vnic */
 
 /* Supported devices */
-static DEFINE_PCI_DEVICE_TABLE(enic_id_table) = {
+static struct pci_device_id enic_id_table[] = {
 	{ PCI_VDEVICE(CISCO, PCI_DEVICE_ID_CISCO_VIC_ENET) },
 	{ 0, }	/* end of table */
 };
@@ -137,25 +136,15 @@
 	return 0;
 }
 
-static int enic_dev_fw_info(struct enic *enic,
-	struct vnic_devcmd_fw_info **fw_info)
-{
-	int err;
-
-	spin_lock(&enic->devcmd_lock);
-	err = vnic_dev_fw_info(enic->vdev, fw_info);
-	spin_unlock(&enic->devcmd_lock);
-
-	return err;
-}
-
 static void enic_get_drvinfo(struct net_device *netdev,
 	struct ethtool_drvinfo *drvinfo)
 {
 	struct enic *enic = netdev_priv(netdev);
 	struct vnic_devcmd_fw_info *fw_info;
 
-	enic_dev_fw_info(enic, &fw_info);
+	spin_lock(&enic->devcmd_lock);
+	vnic_dev_fw_info(enic->vdev, &fw_info);
+	spin_unlock(&enic->devcmd_lock);
 
 	strncpy(drvinfo->driver, DRV_NAME, sizeof(drvinfo->driver));
 	strncpy(drvinfo->version, DRV_VERSION, sizeof(drvinfo->version));
@@ -193,17 +182,6 @@
 	}
 }
 
-static int enic_dev_stats_dump(struct enic *enic, struct vnic_stats **vstats)
-{
-	int err;
-
-	spin_lock(&enic->devcmd_lock);
-	err = vnic_dev_stats_dump(enic->vdev, vstats);
-	spin_unlock(&enic->devcmd_lock);
-
-	return err;
-}
-
 static void enic_get_ethtool_stats(struct net_device *netdev,
 	struct ethtool_stats *stats, u64 *data)
 {
@@ -211,7 +189,9 @@
 	struct vnic_stats *vstats;
 	unsigned int i;
 
-	enic_dev_stats_dump(enic, &vstats);
+	spin_lock(&enic->devcmd_lock);
+	vnic_dev_stats_dump(enic->vdev, &vstats);
+	spin_unlock(&enic->devcmd_lock);
 
 	for (i = 0; i < enic_n_tx_stats; i++)
 		*(data++) = ((u64 *)&vstats->tx)[enic_tx_stats[i].offset];
@@ -281,62 +261,6 @@
 	enic->msg_enable = value;
 }
 
-static int enic_get_coalesce(struct net_device *netdev,
-	struct ethtool_coalesce *ecmd)
-{
-	struct enic *enic = netdev_priv(netdev);
-
-	ecmd->tx_coalesce_usecs = enic->tx_coalesce_usecs;
-	ecmd->rx_coalesce_usecs = enic->rx_coalesce_usecs;
-
-	return 0;
-}
-
-static int enic_set_coalesce(struct net_device *netdev,
-	struct ethtool_coalesce *ecmd)
-{
-	struct enic *enic = netdev_priv(netdev);
-	u32 tx_coalesce_usecs;
-	u32 rx_coalesce_usecs;
-
-	tx_coalesce_usecs = min_t(u32,
-		INTR_COALESCE_HW_TO_USEC(VNIC_INTR_TIMER_MAX),
-		ecmd->tx_coalesce_usecs);
-	rx_coalesce_usecs = min_t(u32,
-		INTR_COALESCE_HW_TO_USEC(VNIC_INTR_TIMER_MAX),
-		ecmd->rx_coalesce_usecs);
-
-	switch (vnic_dev_get_intr_mode(enic->vdev)) {
-	case VNIC_DEV_INTR_MODE_INTX:
-		if (tx_coalesce_usecs != rx_coalesce_usecs)
-			return -EINVAL;
-
-		vnic_intr_coalescing_timer_set(&enic->intr[ENIC_INTX_WQ_RQ],
-			INTR_COALESCE_USEC_TO_HW(tx_coalesce_usecs));
-		break;
-	case VNIC_DEV_INTR_MODE_MSI:
-		if (tx_coalesce_usecs != rx_coalesce_usecs)
-			return -EINVAL;
-
-		vnic_intr_coalescing_timer_set(&enic->intr[0],
-			INTR_COALESCE_USEC_TO_HW(tx_coalesce_usecs));
-		break;
-	case VNIC_DEV_INTR_MODE_MSIX:
-		vnic_intr_coalescing_timer_set(&enic->intr[ENIC_MSIX_WQ],
-			INTR_COALESCE_USEC_TO_HW(tx_coalesce_usecs));
-		vnic_intr_coalescing_timer_set(&enic->intr[ENIC_MSIX_RQ],
-			INTR_COALESCE_USEC_TO_HW(rx_coalesce_usecs));
-		break;
-	default:
-		break;
-	}
-
-	enic->tx_coalesce_usecs = tx_coalesce_usecs;
-	enic->rx_coalesce_usecs = rx_coalesce_usecs;
-
-	return 0;
-}
-
 static const struct ethtool_ops enic_ethtool_ops = {
 	.get_settings = enic_get_settings,
 	.get_drvinfo = enic_get_drvinfo,
@@ -354,9 +278,8 @@
 	.set_sg = ethtool_op_set_sg,
 	.get_tso = ethtool_op_get_tso,
 	.set_tso = enic_set_tso,
-	.get_coalesce = enic_get_coalesce,
-	.set_coalesce = enic_set_coalesce,
 	.get_flags = ethtool_op_get_flags,
+	.set_flags = ethtool_op_set_flags,
 };
 
 static void enic_free_wq_buf(struct vnic_wq *wq, struct vnic_wq_buf *buf)
@@ -421,31 +344,6 @@
 	}
 }
 
-static void enic_msglvl_check(struct enic *enic)
-{
-	u32 msg_enable = vnic_dev_msg_lvl(enic->vdev);
-
-	if (msg_enable != enic->msg_enable) {
-		printk(KERN_INFO PFX "%s: msg lvl changed from 0x%x to 0x%x\n",
-			enic->netdev->name, enic->msg_enable, msg_enable);
-		enic->msg_enable = msg_enable;
-	}
-}
-
-static void enic_mtu_check(struct enic *enic)
-{
-	u32 mtu = vnic_dev_mtu(enic->vdev);
-
-	if (mtu && mtu != enic->port_mtu) {
-		enic->port_mtu = mtu;
-		if (mtu < enic->netdev->mtu)
-			printk(KERN_WARNING PFX
-				"%s: interface MTU (%d) set higher "
-				"than switch port MTU (%d)\n",
-				enic->netdev->name, enic->netdev->mtu, mtu);
-	}
-}
-
 static void enic_link_check(struct enic *enic)
 {
 	int link_status = vnic_dev_link_status(enic->vdev);
@@ -460,6 +358,31 @@
 	}
 }
 
+static void enic_mtu_check(struct enic *enic)
+{
+	u32 mtu = vnic_dev_mtu(enic->vdev);
+
+	if (mtu && mtu != enic->port_mtu) {
+		if (mtu < enic->netdev->mtu)
+			printk(KERN_WARNING PFX
+				"%s: interface MTU (%d) set higher "
+				"than switch port MTU (%d)\n",
+				enic->netdev->name, enic->netdev->mtu, mtu);
+		enic->port_mtu = mtu;
+	}
+}
+
+static void enic_msglvl_check(struct enic *enic)
+{
+	u32 msg_enable = vnic_dev_msg_lvl(enic->vdev);
+
+	if (msg_enable != enic->msg_enable) {
+		printk(KERN_INFO PFX "%s: msg lvl changed from 0x%x to 0x%x\n",
+			enic->netdev->name, enic->msg_enable, msg_enable);
+		enic->msg_enable = msg_enable;
+	}
+}
+
 static void enic_notify_check(struct enic *enic)
 {
 	enic_msglvl_check(enic);
@@ -584,7 +507,7 @@
 
 static inline void enic_queue_wq_skb_cont(struct enic *enic,
 	struct vnic_wq *wq, struct sk_buff *skb,
-	unsigned int len_left, int loopback)
+	unsigned int len_left)
 {
 	skb_frag_t *frag;
 
@@ -596,14 +519,13 @@
 				frag->page_offset, frag->size,
 				PCI_DMA_TODEVICE),
 			frag->size,
-			(len_left == 0),	/* EOP? */
-			loopback);
+			(len_left == 0));	/* EOP? */
 	}
 }
 
 static inline void enic_queue_wq_skb_vlan(struct enic *enic,
 	struct vnic_wq *wq, struct sk_buff *skb,
-	int vlan_tag_insert, unsigned int vlan_tag, int loopback)
+	int vlan_tag_insert, unsigned int vlan_tag)
 {
 	unsigned int head_len = skb_headlen(skb);
 	unsigned int len_left = skb->len - head_len;
@@ -619,15 +541,15 @@
 			head_len, PCI_DMA_TODEVICE),
 		head_len,
 		vlan_tag_insert, vlan_tag,
-		eop, loopback);
+		eop);
 
 	if (!eop)
-		enic_queue_wq_skb_cont(enic, wq, skb, len_left, loopback);
+		enic_queue_wq_skb_cont(enic, wq, skb, len_left);
 }
 
 static inline void enic_queue_wq_skb_csum_l4(struct enic *enic,
 	struct vnic_wq *wq, struct sk_buff *skb,
-	int vlan_tag_insert, unsigned int vlan_tag, int loopback)
+	int vlan_tag_insert, unsigned int vlan_tag)
 {
 	unsigned int head_len = skb_headlen(skb);
 	unsigned int len_left = skb->len - head_len;
@@ -647,15 +569,15 @@
 		csum_offset,
 		hdr_len,
 		vlan_tag_insert, vlan_tag,
-		eop, loopback);
+		eop);
 
 	if (!eop)
-		enic_queue_wq_skb_cont(enic, wq, skb, len_left, loopback);
+		enic_queue_wq_skb_cont(enic, wq, skb, len_left);
 }
 
 static inline void enic_queue_wq_skb_tso(struct enic *enic,
 	struct vnic_wq *wq, struct sk_buff *skb, unsigned int mss,
-	int vlan_tag_insert, unsigned int vlan_tag, int loopback)
+	int vlan_tag_insert, unsigned int vlan_tag)
 {
 	unsigned int frag_len_left = skb_headlen(skb);
 	unsigned int len_left = skb->len - frag_len_left;
@@ -692,7 +614,7 @@
 			len,
 			mss, hdr_len,
 			vlan_tag_insert, vlan_tag,
-			eop && (len == frag_len_left), loopback);
+			eop && (len == frag_len_left));
 		frag_len_left -= len;
 		offset += len;
 	}
@@ -718,8 +640,7 @@
 				dma_addr,
 				len,
 				(len_left == 0) &&
-				(len == frag_len_left),		/* EOP? */
-				loopback);
+				(len == frag_len_left));	/* EOP? */
 			frag_len_left -= len;
 			offset += len;
 		}
@@ -732,31 +653,27 @@
 	unsigned int mss = skb_shinfo(skb)->gso_size;
 	unsigned int vlan_tag = 0;
 	int vlan_tag_insert = 0;
-	int loopback = 0;
 
 	if (enic->vlan_group && vlan_tx_tag_present(skb)) {
 		/* VLAN tag from trunking driver */
 		vlan_tag_insert = 1;
 		vlan_tag = vlan_tx_tag_get(skb);
-	} else if (enic->loop_enable) {
-		vlan_tag = enic->loop_tag;
-		loopback = 1;
 	}
 
 	if (mss)
 		enic_queue_wq_skb_tso(enic, wq, skb, mss,
-			vlan_tag_insert, vlan_tag, loopback);
+			vlan_tag_insert, vlan_tag);
 	else if	(skb->ip_summed == CHECKSUM_PARTIAL)
 		enic_queue_wq_skb_csum_l4(enic, wq, skb,
-			vlan_tag_insert, vlan_tag, loopback);
+			vlan_tag_insert, vlan_tag);
 	else
 		enic_queue_wq_skb_vlan(enic, wq, skb,
-			vlan_tag_insert, vlan_tag, loopback);
+			vlan_tag_insert, vlan_tag);
 }
 
 /* netif_tx_lock held, process context with BHs disabled, or BH */
 static netdev_tx_t enic_hard_start_xmit(struct sk_buff *skb,
-	struct net_device *netdev)
+					      struct net_device *netdev)
 {
 	struct enic *enic = netdev_priv(netdev);
 	struct vnic_wq *wq = &enic->wq[0];
@@ -808,7 +725,9 @@
 	struct net_device_stats *net_stats = &netdev->stats;
 	struct vnic_stats *stats;
 
-	enic_dev_stats_dump(enic, &stats);
+	spin_lock(&enic->devcmd_lock);
+	vnic_dev_stats_dump(enic->vdev, &stats);
+	spin_unlock(&enic->devcmd_lock);
 
 	net_stats->tx_packets = stats->tx.tx_frames_ok;
 	net_stats->tx_bytes = stats->tx.tx_bytes_ok;
@@ -826,10 +745,9 @@
 	return net_stats;
 }
 
-static void enic_reset_multicast_list(struct enic *enic)
+static void enic_reset_mcaddrs(struct enic *enic)
 {
 	enic->mc_count = 0;
-	enic->flags = 0;
 }
 
 static int enic_set_mac_addr(struct net_device *netdev, char *addr)
@@ -842,72 +760,6 @@
 	return 0;
 }
 
-static int enic_dev_add_station_addr(struct enic *enic)
-{
-	int err = 0;
-
-	if (is_valid_ether_addr(enic->netdev->dev_addr)) {
-		spin_lock(&enic->devcmd_lock);
-		err = vnic_dev_add_addr(enic->vdev, enic->netdev->dev_addr);
-		spin_unlock(&enic->devcmd_lock);
-	}
-
-	return err;
-}
-
-static int enic_dev_del_station_addr(struct enic *enic)
-{
-	int err = 0;
-
-	if (is_valid_ether_addr(enic->netdev->dev_addr)) {
-		spin_lock(&enic->devcmd_lock);
-		err = vnic_dev_del_addr(enic->vdev, enic->netdev->dev_addr);
-		spin_unlock(&enic->devcmd_lock);
-	}
-
-	return err;
-}
-
-static int enic_set_mac_address(struct net_device *netdev, void *p)
-{
-	return -EOPNOTSUPP;
-}
-
-static int enic_dev_packet_filter(struct enic *enic, int directed,
-	int multicast, int broadcast, int promisc, int allmulti)
-{
-	int err;
-
-	spin_lock(&enic->devcmd_lock);
-	err = vnic_dev_packet_filter(enic->vdev, directed,
-		multicast, broadcast, promisc, allmulti);
-	spin_unlock(&enic->devcmd_lock);
-
-	return err;
-}
-
-static int enic_dev_add_multicast_addr(struct enic *enic, u8 *addr)
-{
-	int err;
-
-	spin_lock(&enic->devcmd_lock);
-	err = vnic_dev_add_addr(enic->vdev, addr);
-	spin_unlock(&enic->devcmd_lock);
-
-	return err;
-}
-
-static int enic_dev_del_multicast_addr(struct enic *enic, u8 *addr)
-{
-	int err;
-
-	spin_lock(&enic->devcmd_lock);
-	err = vnic_dev_del_addr(enic->vdev, addr);
-	spin_unlock(&enic->devcmd_lock);
-
-	return err;
-}
-
 /* netif_tx_lock held, BHs disabled */
 static void enic_set_multicast_list(struct net_device *netdev)
 {
@@ -918,8 +770,7 @@
 	int broadcast = (netdev->flags & IFF_BROADCAST) ? 1 : 0;
 	int promisc = (netdev->flags & IFF_PROMISC) ? 1 : 0;
 	int allmulti = (netdev->flags & IFF_ALLMULTI) ||
-			(netdev->mc_count > ENIC_MULTICAST_PERFECT_FILTERS);
-	unsigned int flags = netdev->flags | (allmulti ? IFF_ALLMULTI : 0);
+	    (netdev->mc_count > ENIC_MULTICAST_PERFECT_FILTERS);
 	u8 mc_addr[ENIC_MULTICAST_PERFECT_FILTERS][ETH_ALEN];
 	unsigned int mc_count = netdev->mc_count;
 	unsigned int i, j;
@@ -927,11 +778,10 @@
 	if (mc_count > ENIC_MULTICAST_PERFECT_FILTERS)
 		mc_count = ENIC_MULTICAST_PERFECT_FILTERS;
 
-	if (enic->flags != flags) {
-		enic->flags = flags;
-		enic_dev_packet_filter(enic, directed,
-			multicast, broadcast, promisc, allmulti);
-	}
+	spin_lock(&enic->devcmd_lock);
+
+	vnic_dev_packet_filter(enic->vdev, directed,
+		multicast, broadcast, promisc, allmulti);
 
 	/* Is there an easier way?  Trying to minimize to
 	 * calls to add/del multicast addrs.  We keep the
@@ -950,7 +800,7 @@
 				mc_addr[j]) == 0)
 				break;
 		if (j == mc_count)
-			enic_dev_del_multicast_addr(enic, enic->mc_addr[i]);
+			enic_del_multicast_addr(enic, enic->mc_addr[i]);
 	}
 
 	for (i = 0; i < mc_count; i++) {
@@ -959,7 +809,7 @@
 				enic->mc_addr[j]) == 0)
 				break;
 		if (j == enic->mc_count)
-			enic_dev_add_multicast_addr(enic, mc_addr[i]);
+			enic_add_multicast_addr(enic, mc_addr[i]);
 	}
 
 	/* Save the list to compare against next time
@@ -969,6 +819,8 @@
 		memcpy(enic->mc_addr[i], mc_addr[i], ETH_ALEN);
 
 	enic->mc_count = mc_count;
+
+	spin_unlock(&enic->devcmd_lock);
 }
 
 /* rtnl lock is held */
@@ -1023,7 +875,7 @@
 	struct enic *enic = vnic_dev_priv(rq->vdev);
 	struct net_device *netdev = enic->netdev;
 	struct sk_buff *skb;
-	unsigned int len = netdev->mtu + VLAN_ETH_HLEN;
+	unsigned int len = netdev->mtu + ETH_HLEN;
 	unsigned int os_buf_index = 0;
 	dma_addr_t dma_addr;
 
@@ -1060,24 +912,12 @@
 	return 0;
 }
 
-static int enic_dev_hw_version(struct enic *enic,
-	enum vnic_dev_hw_version *hw_ver)
-{
-	int err;
-
-	spin_lock(&enic->devcmd_lock);
-	err = vnic_dev_hw_version(enic->vdev, hw_ver);
-	spin_unlock(&enic->devcmd_lock);
-
-	return err;
-}
-
 static int enic_set_rq_alloc_buf(struct enic *enic)
 {
 	enum vnic_dev_hw_version hw_ver;
 	int err;
 
-	err = enic_dev_hw_version(enic, &hw_ver);
+	err = vnic_dev_hw_version(enic->vdev, &hw_ver);
 	if (err)
 		return err;
 
@@ -1096,6 +936,51 @@
 	return 0;
 }
 
+static int enic_get_skb_header(struct sk_buff *skb, void **iphdr,
+	void **tcph, u64 *hdr_flags, void *priv)
+{
+	struct cq_enet_rq_desc *cq_desc = priv;
+	unsigned int ip_len;
+	struct iphdr *iph;
+
+	u8 type, color, eop, sop, ingress_port, vlan_stripped;
+	u8 fcoe, fcoe_sof, fcoe_fc_crc_ok, fcoe_enc_error, fcoe_eof;
+	u8 tcp_udp_csum_ok, udp, tcp, ipv4_csum_ok;
+	u8 ipv6, ipv4, ipv4_fragment, fcs_ok, rss_type, csum_not_calc;
+	u8 packet_error;
+	u16 q_number, completed_index, bytes_written, vlan, checksum;
+	u32 rss_hash;
+
+	cq_enet_rq_desc_dec(cq_desc,
+		&type, &color, &q_number, &completed_index,
+		&ingress_port, &fcoe, &eop, &sop, &rss_type,
+		&csum_not_calc, &rss_hash, &bytes_written,
+		&packet_error, &vlan_stripped, &vlan, &checksum,
+		&fcoe_sof, &fcoe_fc_crc_ok, &fcoe_enc_error,
+		&fcoe_eof, &tcp_udp_csum_ok, &udp, &tcp,
+		&ipv4_csum_ok, &ipv6, &ipv4, &ipv4_fragment,
+		&fcs_ok);
+
+	if (!(ipv4 && tcp && !ipv4_fragment))
+		return -1;
+
+	skb_reset_network_header(skb);
+	iph = ip_hdr(skb);
+
+	ip_len = ip_hdrlen(skb);
+	skb_set_transport_header(skb, ip_len);
+
+	/* check if ip header and tcp header are complete */
+	if (ntohs(iph->tot_len) < ip_len + tcp_hdrlen(skb))
+		return -1;
+
+	*hdr_flags = LRO_IPV4 | LRO_TCP;
+	*tcph = tcp_hdr(skb);
+	*iphdr = iph;
+
+	return 0;
+}
+
 static void enic_rq_indicate_buf(struct vnic_rq *rq,
 	struct cq_desc *cq_desc, struct vnic_rq_buf *buf,
 	int skipped, void *opaque)
@@ -1109,7 +994,7 @@
 	u8 tcp_udp_csum_ok, udp, tcp, ipv4_csum_ok;
 	u8 ipv6, ipv4, ipv4_fragment, fcs_ok, rss_type, csum_not_calc;
 	u8 packet_error;
-	u16 q_number, completed_index, bytes_written, vlan_tci, checksum;
+	u16 q_number, completed_index, bytes_written, vlan, checksum;
 	u32 rss_hash;
 
 	if (skipped)
@@ -1124,7 +1009,7 @@
 		&type, &color, &q_number, &completed_index,
 		&ingress_port, &fcoe, &eop, &sop, &rss_type,
 		&csum_not_calc, &rss_hash, &bytes_written,
-		&packet_error, &vlan_stripped, &vlan_tci, &checksum,
+		&packet_error, &vlan_stripped, &vlan, &checksum,
 		&fcoe_sof, &fcoe_fc_crc_ok, &fcoe_enc_error,
 		&fcoe_eof, &tcp_udp_csum_ok, &udp, &tcp,
 		&ipv4_csum_ok, &ipv6, &ipv4, &ipv4_fragment,
@@ -1159,20 +1044,20 @@
 
 		skb->dev = netdev;
 
-		if (enic->vlan_group && vlan_stripped &&
-			(vlan_tci & CQ_ENET_RQ_DESC_VLAN_TCI_VLAN_MASK)) {
+		if (enic->vlan_group && vlan_stripped) {
 
-			if (netdev->features & NETIF_F_GRO)
-				vlan_gro_receive(&enic->napi, enic->vlan_group,
-					vlan_tci, skb);
+			if ((netdev->features & NETIF_F_LRO) && ipv4)
+				lro_vlan_hwaccel_receive_skb(&enic->lro_mgr,
+					skb, enic->vlan_group,
+					vlan, cq_desc);
 			else
 				vlan_hwaccel_receive_skb(skb,
-					enic->vlan_group, vlan_tci);
+					enic->vlan_group, vlan);
 
 		} else {
 
-			if (netdev->features & NETIF_F_GRO)
-				napi_gro_receive(&enic->napi, skb);
+			if ((netdev->features & NETIF_F_LRO) && ipv4)
+				lro_receive_skb(&enic->lro_mgr, skb, cq_desc);
 			else
 				netif_receive_skb(skb);
 
@@ -1199,13 +1084,41 @@
 	return 0;
 }
 
+static void enic_rq_drop_buf(struct vnic_rq *rq,
+	struct cq_desc *cq_desc, struct vnic_rq_buf *buf,
+	int skipped, void *opaque)
+{
+	struct enic *enic = vnic_dev_priv(rq->vdev);
+	struct sk_buff *skb = buf->os_buf;
+
+	if (skipped)
+		return;
+
+	pci_unmap_single(enic->pdev, buf->dma_addr,
+		buf->len, PCI_DMA_FROMDEVICE);
+
+	dev_kfree_skb_any(skb);
+}
+
+static int enic_rq_service_drop(struct vnic_dev *vdev, struct cq_desc *cq_desc,
+	u8 type, u16 q_number, u16 completed_index, void *opaque)
+{
+	struct enic *enic = vnic_dev_priv(vdev);
+
+	vnic_rq_service(&enic->rq[q_number], cq_desc,
+		completed_index, VNIC_RQ_RETURN_DESC,
+		enic_rq_drop_buf, opaque);
+
+	return 0;
+}
+
 static int enic_poll(struct napi_struct *napi, int budget)
 {
 	struct enic *enic = container_of(napi, struct enic, napi);
+	struct net_device *netdev = enic->netdev;
 	unsigned int rq_work_to_do = budget;
 	unsigned int wq_work_to_do = -1; /* no limit */
 	unsigned int  work_done, rq_work_done, wq_work_done;
-	int err;
 
 	/* Service RQ (first) and WQ
 	 */
@@ -1229,21 +1142,21 @@
 			0 /* don't unmask intr */,
 			0 /* don't reset intr timer */);
 
-	err = vnic_rq_fill(&enic->rq[0], enic->rq_alloc_buf);
+	if (rq_work_done > 0) {
 
-	/* Buffer allocation failed. Stay in polling
-	 * mode so we can try to fill the ring again.
-	 */
-
-	if (err)
-		rq_work_done = rq_work_to_do;
-
-	if (rq_work_done < rq_work_to_do) {
-
-		/* Some work done, but not enough to stay in polling,
-		 * exit polling
+		/* Replenish RQ
 		 */
 
+		vnic_rq_fill(&enic->rq[0], enic->rq_alloc_buf);
+
+	} else {
+
+		/* If no work done, flush all LROs and exit polling
+		 */
+
+		if (netdev->features & NETIF_F_LRO)
+			lro_flush_all(&enic->lro_mgr);
+
 		napi_complete(napi);
 		vnic_intr_unmask(&enic->intr[ENIC_INTX_WQ_RQ]);
 	}
@@ -1254,9 +1167,9 @@
 static int enic_poll_msix(struct napi_struct *napi, int budget)
 {
 	struct enic *enic = container_of(napi, struct enic, napi);
+	struct net_device *netdev = enic->netdev;
 	unsigned int work_to_do = budget;
 	unsigned int work_done;
-	int err;
 
 	/* Service RQ
 	 */
@@ -1264,32 +1177,30 @@
 	work_done = vnic_cq_service(&enic->cq[ENIC_CQ_RQ],
 		work_to_do, enic_rq_service, NULL);
 
-	/* Return intr event credits for this polling
-	 * cycle.  An intr event is the completion of a
-	 * RQ packet.
-	 */
+	if (work_done > 0) {
 
-	if (work_done > 0)
+		/* Replenish RQ
+		 */
+
+		vnic_rq_fill(&enic->rq[0], enic->rq_alloc_buf);
+
+		/* Return intr event credits for this polling
+		 * cycle.  An intr event is the completion of a
+		 * RQ packet.
+		 */
+
 		vnic_intr_return_credits(&enic->intr[ENIC_MSIX_RQ],
 			work_done,
 			0 /* don't unmask intr */,
 			0 /* don't reset intr timer */);
+	} else {
 
-	err = vnic_rq_fill(&enic->rq[0], enic->rq_alloc_buf);
-
-	/* Buffer allocation failed. Stay in polling mode
-	 * so we can try to fill the ring again.
-	 */
-
-	if (err)
-		work_done = work_to_do;
-
-	if (work_done < work_to_do) {
-
-		/* Some work done, but not enough to stay in polling,
-		 * exit polling
+		/* If no work done, flush all LROs and exit polling
 		 */
 
+		if (netdev->features & NETIF_F_LRO)
+			lro_flush_all(&enic->lro_mgr);
+
 		napi_complete(napi);
 		vnic_intr_unmask(&enic->intr[ENIC_MSIX_RQ]);
 	}
@@ -1393,25 +1304,7 @@
 	return err;
 }
 
-static void enic_synchronize_irqs(struct enic *enic)
-{
-	unsigned int i;
-
-	switch (vnic_dev_get_intr_mode(enic->vdev)) {
-	case VNIC_DEV_INTR_MODE_INTX:
-	case VNIC_DEV_INTR_MODE_MSI:
-		synchronize_irq(enic->pdev->irq);
-		break;
-	case VNIC_DEV_INTR_MODE_MSIX:
-		for (i = 0; i < enic->intr_count; i++)
-			synchronize_irq(enic->msix_entry[i].vector);
-		break;
-	default:
-		break;
-	}
-}
-
-static int enic_dev_notify_set(struct enic *enic)
+static int enic_notify_set(struct enic *enic)
 {
 	int err;
 
@@ -1432,39 +1325,6 @@
 	return err;
 }
 
-static int enic_dev_notify_unset(struct enic *enic)
-{
-	int err;
-
-	spin_lock(&enic->devcmd_lock);
-	err = vnic_dev_notify_unset(enic->vdev);
-	spin_unlock(&enic->devcmd_lock);
-
-	return err;
-}
-
-static int enic_dev_enable(struct enic *enic)
-{
-	int err;
-
-	spin_lock(&enic->devcmd_lock);
-	err = vnic_dev_enable(enic->vdev);
-	spin_unlock(&enic->devcmd_lock);
-
-	return err;
-}
-
-static int enic_dev_disable(struct enic *enic)
-{
-	int err;
-
-	spin_lock(&enic->devcmd_lock);
-	err = vnic_dev_disable(enic->vdev);
-	spin_unlock(&enic->devcmd_lock);
-
-	return err;
-}
-
 static void enic_notify_timer_start(struct enic *enic)
 {
 	switch (vnic_dev_get_intr_mode(enic->vdev)) {
@@ -1491,7 +1351,7 @@
 		return err;
 	}
 
-	err = enic_dev_notify_set(enic);
+	err = enic_notify_set(enic);
 	if (err) {
 		printk(KERN_ERR PFX
 			"%s: Failed to alloc notify buffer, aborting.\n",
@@ -1500,13 +1360,11 @@
 	}
 
 	for (i = 0; i < enic->rq_count; i++) {
-		vnic_rq_fill(&enic->rq[i], enic->rq_alloc_buf);
-		/* Need at least one buffer on ring to get going */
-		if (vnic_rq_desc_used(&enic->rq[i]) == 0) {
+		err = vnic_rq_fill(&enic->rq[i], enic->rq_alloc_buf);
+		if (err) {
 			printk(KERN_ERR PFX
 				"%s: Unable to alloc receive buffers.\n",
 				netdev->name);
-			err = -ENOMEM;
 			goto err_out_notify_unset;
 		}
 	}
@@ -1516,12 +1374,16 @@
 	for (i = 0; i < enic->rq_count; i++)
 		vnic_rq_enable(&enic->rq[i]);
 
-	enic_dev_add_station_addr(enic);
+	spin_lock(&enic->devcmd_lock);
+	enic_add_station_addr(enic);
+	spin_unlock(&enic->devcmd_lock);
 	enic_set_multicast_list(netdev);
 
 	netif_wake_queue(netdev);
 	napi_enable(&enic->napi);
-	enic_dev_enable(enic);
+	spin_lock(&enic->devcmd_lock);
+	vnic_dev_enable(enic->vdev);
+	spin_unlock(&enic->devcmd_lock);
 
 	for (i = 0; i < enic->intr_count; i++)
 		vnic_intr_unmask(&enic->intr[i]);
@@ -1531,7 +1393,9 @@
 	return 0;
 
 err_out_notify_unset:
-	enic_dev_notify_unset(enic);
+	spin_lock(&enic->devcmd_lock);
+	vnic_dev_notify_unset(enic->vdev);
+	spin_unlock(&enic->devcmd_lock);
 err_out_free_intr:
 	enic_free_intr(enic);
 
@@ -1545,21 +1409,16 @@
 	unsigned int i;
 	int err;
 
-	for (i = 0; i < enic->intr_count; i++) {
-		vnic_intr_mask(&enic->intr[i]);
-		(void)vnic_intr_masked(&enic->intr[i]); /* flush write */
-	}
-
-	enic_synchronize_irqs(enic);
-
 	del_timer_sync(&enic->notify_timer);
 
-	enic_dev_disable(enic);
+	spin_lock(&enic->devcmd_lock);
+	vnic_dev_disable(enic->vdev);
+	spin_unlock(&enic->devcmd_lock);
 	napi_disable(&enic->napi);
-	netif_carrier_off(netdev);
-	netif_tx_disable(netdev);
+	netif_stop_queue(netdev);
 
-	enic_dev_del_station_addr(enic);
+	for (i = 0; i < enic->intr_count; i++)
+		vnic_intr_mask(&enic->intr[i]);
 
 	for (i = 0; i < enic->wq_count; i++) {
 		err = vnic_wq_disable(&enic->wq[i]);
@@ -1572,9 +1431,16 @@
 			return err;
 	}
 
-	enic_dev_notify_unset(enic);
+	spin_lock(&enic->devcmd_lock);
+	vnic_dev_notify_unset(enic->vdev);
+	spin_unlock(&enic->devcmd_lock);
 	enic_free_intr(enic);
 
+	(void)vnic_cq_service(&enic->cq[ENIC_CQ_RQ],
+		-1, enic_rq_service_drop, NULL);
+	(void)vnic_cq_service(&enic->cq[ENIC_CQ_WQ],
+		-1, enic_wq_service, NULL);
+
 	for (i = 0; i < enic->wq_count; i++)
 		vnic_wq_clean(&enic->wq[i], enic_free_wq_buf);
 	for (i = 0; i < enic->rq_count; i++)
@@ -1683,15 +1549,15 @@
 	return err;
 }
 
-static int enic_dev_hang_reset(struct enic *enic)
+static int enic_dev_soft_reset(struct enic *enic)
 {
 	int err;
 
-	err = enic_dev_wait(enic->vdev, vnic_dev_hang_reset,
-		vnic_dev_hang_reset_done, 0);
+	err = enic_dev_wait(enic->vdev, vnic_dev_soft_reset,
+		vnic_dev_soft_reset_done, 0);
 	if (err)
 		printk(KERN_ERR PFX
-			"vNIC hang reset failed, err %d.\n", err);
+			"vNIC soft reset failed, err %d.\n", err);
 
 	return err;
 }
@@ -1705,43 +1571,15 @@
 	const u8 rss_enable = 0;
 	const u8 tso_ipid_split_en = 0;
 	const u8 ig_vlan_strip_en = 1;
-	int err;
 
 	/* Enable VLAN tag stripping.  RSS not enabled (yet).
 	 */
 
-	spin_lock(&enic->devcmd_lock);
-	err = enic_set_nic_cfg(enic,
+	return enic_set_nic_cfg(enic,
 		rss_default_cpu, rss_hash_type,
 		rss_hash_bits, rss_base_cpu,
 		rss_enable, tso_ipid_split_en,
 		ig_vlan_strip_en);
-	spin_unlock(&enic->devcmd_lock);
-
-	return err;
-}
-
-static int enic_dev_hang_notify(struct enic *enic)
-{
-	int err;
-
-	spin_lock(&enic->devcmd_lock);
-	err = vnic_dev_hang_notify(enic->vdev);
-	spin_unlock(&enic->devcmd_lock);
-
-	return err;
-}
-
-int enic_dev_set_ig_vlan_rewrite_mode(struct enic *enic)
-{
-	int err;
-
-	spin_lock(&enic->devcmd_lock);
-	err = vnic_dev_set_ig_vlan_rewrite_mode(enic->vdev,
-		IG_VLAN_REWRITE_MODE_PRIORITY_TAG_DEFAULT_VLAN);
-	spin_unlock(&enic->devcmd_lock);
-
-	return err;
 }
 
 static void enic_reset(struct work_struct *work)
@@ -1753,13 +1591,16 @@
 
 	rtnl_lock();
 
-	enic_dev_hang_notify(enic);
+	spin_lock(&enic->devcmd_lock);
+	vnic_dev_hang_notify(enic->vdev);
+	spin_unlock(&enic->devcmd_lock);
+
 	enic_stop(enic->netdev);
-	enic_dev_hang_reset(enic);
-	enic_reset_multicast_list(enic);
+	enic_dev_soft_reset(enic);
+	vnic_dev_init(enic->vdev, 0);
+	enic_reset_mcaddrs(enic);
 	enic_init_vnic_resources(enic);
 	enic_set_niccfg(enic);
-	enic_dev_set_ig_vlan_rewrite_mode(enic);
 	enic_open(enic->netdev);
 
 	rtnl_unlock();
@@ -1875,8 +1716,8 @@
 	.ndo_start_xmit		= enic_hard_start_xmit,
 	.ndo_get_stats		= enic_get_stats,
 	.ndo_validate_addr	= eth_validate_addr,
+	.ndo_set_mac_address 	= eth_mac_addr,
 	.ndo_set_multicast_list	= enic_set_multicast_list,
-	.ndo_set_mac_address 	= enic_set_mac_address,
 	.ndo_change_mtu		= enic_change_mtu,
 	.ndo_vlan_rx_register	= enic_vlan_rx_register,
 	.ndo_vlan_rx_add_vid	= enic_vlan_rx_add_vid,
@@ -1921,8 +1762,7 @@
 	err = enic_set_intr_mode(enic);
 	if (err) {
 		printk(KERN_ERR PFX
-			"Failed to set intr mode based on resource "
-			"counts and system capabilities, aborting.\n");
+			"Failed to set intr mode, aborting.\n");
 		return err;
 	}
 
@@ -1952,13 +1792,6 @@
 		goto err_out_free_vnic_resources;
 	}
 
-	err = enic_dev_set_ig_vlan_rewrite_mode(enic);
-	if (err) {
-		printk(KERN_ERR PFX
-			"Failed to set ingress vlan rewrite mode, aborting.\n");
-		goto err_out_free_vnic_resources;
-	}
-
 	switch (vnic_dev_get_intr_mode(enic->vdev)) {
 	default:
 		netif_napi_add(netdev, &enic->napi, enic_poll, 64);
@@ -2016,7 +1849,7 @@
 	/* Setup PCI resources
 	 */
 
-	err = pci_enable_device_mem(pdev);
+	err = pci_enable_device(pdev);
 	if (err) {
 		printk(KERN_ERR PFX
 			"Cannot enable PCI device, aborting.\n");
@@ -2119,11 +1952,6 @@
 		goto err_out_dev_close;
 	}
 
-	/* Setup devcmd lock
-	 */
-
-	spin_lock_init(&enic->devcmd_lock);
-
 	err = enic_dev_init(enic);
 	if (err) {
 		printk(KERN_ERR PFX
@@ -2131,7 +1959,7 @@
 		goto err_out_dev_close;
 	}
 
-	/* Setup notification timer, HW reset task, and wq locks
+	/* Setup notification timer, HW reset task, and locks
 	 */
 
 	init_timer(&enic->notify_timer);
@@ -2143,6 +1971,8 @@
 	for (i = 0; i < enic->wq_count; i++)
 		spin_lock_init(&enic->wq_lock[i]);
 
+	spin_lock_init(&enic->devcmd_lock);
+
 	/* Register net device
 	 */
 
@@ -2156,32 +1986,33 @@
 		goto err_out_dev_deinit;
 	}
 
-	enic->tx_coalesce_usecs = enic->config.intr_timer_usec;
-	enic->rx_coalesce_usecs = enic->tx_coalesce_usecs;
-
 	netdev->netdev_ops = &enic_netdev_ops;
 	netdev->watchdog_timeo = 2 * HZ;
 	netdev->ethtool_ops = &enic_ethtool_ops;
 
-	netdev->features |= NETIF_F_HW_VLAN_TX | NETIF_F_HW_VLAN_RX;
-	if (ENIC_SETTING(enic, LOOP)) {
-		netdev->features &= ~NETIF_F_HW_VLAN_TX;
-		enic->loop_enable = 1;
-		enic->loop_tag = enic->config.loop_tag;
-		printk(KERN_INFO PFX "loopback tag=0x%04x\n", enic->loop_tag);
-	}
+	netdev->features |= NETIF_F_HW_VLAN_TX |
+		NETIF_F_HW_VLAN_RX | NETIF_F_HW_VLAN_FILTER;
 	if (ENIC_SETTING(enic, TXCSUM))
 		netdev->features |= NETIF_F_SG | NETIF_F_HW_CSUM;
 	if (ENIC_SETTING(enic, TSO))
 		netdev->features |= NETIF_F_TSO |
 			NETIF_F_TSO6 | NETIF_F_TSO_ECN;
 	if (ENIC_SETTING(enic, LRO))
-		netdev->features |= NETIF_F_GRO;
+		netdev->features |= NETIF_F_LRO;
 	if (using_dac)
 		netdev->features |= NETIF_F_HIGHDMA;
 
 	enic->csum_rx_enabled = ENIC_SETTING(enic, RXCSUM);
 
+	enic->lro_mgr.max_aggr = ENIC_LRO_MAX_AGGR;
+	enic->lro_mgr.max_desc = ENIC_LRO_MAX_DESC;
+	enic->lro_mgr.lro_arr = enic->lro_desc;
+	enic->lro_mgr.get_skb_header = enic_get_skb_header;
+	enic->lro_mgr.features	= LRO_F_NAPI | LRO_F_EXTRACT_VLAN_ID;
+	enic->lro_mgr.dev = netdev;
+	enic->lro_mgr.ip_summed = CHECKSUM_COMPLETE;
+	enic->lro_mgr.ip_summed_aggr = CHECKSUM_UNNECESSARY;
+
 	err = register_netdev(netdev);
 	if (err) {
 		printk(KERN_ERR PFX
diff -r 15109ec2f661 drivers/net/enic/enic_res.c
--- b/drivers/net/enic/enic_res.c	Wed Aug 17 13:31:06 2011 +0100
+++ a/drivers/net/enic/enic_res.c	Wed Aug 17 13:09:17 2011 +0100
@@ -1,5 +1,5 @@
 /*
- * Copyright 2008-2010 Cisco Systems, Inc.  All rights reserved.
+ * Copyright 2008 Cisco Systems, Inc.  All rights reserved.
  * Copyright 2007 Nuova Systems, Inc.  All rights reserved.
  *
  * This program is free software; you may redistribute it and/or modify
@@ -66,22 +66,21 @@
 	GET_CONFIG(wq_desc_count);
 	GET_CONFIG(rq_desc_count);
 	GET_CONFIG(mtu);
+	GET_CONFIG(intr_timer);
 	GET_CONFIG(intr_timer_type);
 	GET_CONFIG(intr_mode);
-	GET_CONFIG(intr_timer_usec);
-	GET_CONFIG(loop_tag);
 
 	c->wq_desc_count =
 		min_t(u32, ENIC_MAX_WQ_DESCS,
 		max_t(u32, ENIC_MIN_WQ_DESCS,
 		c->wq_desc_count));
-	c->wq_desc_count &= 0xffffffe0; /* must be aligned to groups of 32 */
+	c->wq_desc_count &= 0xfffffff0; /* must be aligned to groups of 16 */
 
 	c->rq_desc_count =
 		min_t(u32, ENIC_MAX_RQ_DESCS,
 		max_t(u32, ENIC_MIN_RQ_DESCS,
 		c->rq_desc_count));
-	c->rq_desc_count &= 0xffffffe0; /* must be aligned to groups of 32 */
+	c->rq_desc_count &= 0xfffffff0; /* must be aligned to groups of 16 */
 
 	if (c->mtu == 0)
 		c->mtu = 1500;
@@ -89,17 +88,15 @@
 		max_t(u16, ENIC_MIN_MTU,
 		c->mtu));
 
-	c->intr_timer_usec = min_t(u32,
-		INTR_COALESCE_HW_TO_USEC(VNIC_INTR_TIMER_MAX),
-		c->intr_timer_usec);
+	c->intr_timer = min_t(u16, VNIC_INTR_TIMER_MAX, c->intr_timer);
 
 	printk(KERN_INFO PFX "vNIC MAC addr %pM wq/rq %d/%d\n",
 		enic->mac_addr, c->wq_desc_count, c->rq_desc_count);
 	printk(KERN_INFO PFX "vNIC mtu %d csum tx/rx %d/%d tso/lro %d/%d "
-		"intr timer %d usec\n",
+		"intr timer %d\n",
 		c->mtu, ENIC_SETTING(enic, TXCSUM),
 		ENIC_SETTING(enic, RXCSUM), ENIC_SETTING(enic, TSO),
-		ENIC_SETTING(enic, LRO), c->intr_timer_usec);
+		ENIC_SETTING(enic, LRO), c->intr_timer);
 
 	return 0;
 }
@@ -109,7 +106,17 @@
 	vnic_dev_add_addr(enic->vdev, enic->mac_addr);
 }
 
-int enic_add_vlan(struct enic *enic, u16 vlanid)
+void enic_add_multicast_addr(struct enic *enic, u8 *addr)
+{
+	vnic_dev_add_addr(enic->vdev, addr);
+}
+
+void enic_del_multicast_addr(struct enic *enic, u8 *addr)
+{
+	vnic_dev_del_addr(enic->vdev, addr);
+}
+
+void enic_add_vlan(struct enic *enic, u16 vlanid)
 {
 	u64 a0 = vlanid, a1 = 0;
 	int wait = 1000;
@@ -118,11 +125,9 @@
 	err = vnic_dev_cmd(enic->vdev, CMD_VLAN_ADD, &a0, &a1, wait);
 	if (err)
 		printk(KERN_ERR PFX "Can't add vlan id, %d\n", err);
-
-	return err;
 }
 
-int enic_del_vlan(struct enic *enic, u16 vlanid)
+void enic_del_vlan(struct enic *enic, u16 vlanid)
 {
 	u64 a0 = vlanid, a1 = 0;
 	int wait = 1000;
@@ -131,8 +136,6 @@
 	err = vnic_dev_cmd(enic->vdev, CMD_VLAN_DEL, &a0, &a1, wait);
 	if (err)
 		printk(KERN_ERR PFX "Can't delete vlan id, %d\n", err);
-
-	return err;
 }
 
 int enic_set_nic_cfg(struct enic *enic, u8 rss_default_cpu, u8 rss_hash_type,
@@ -300,10 +303,15 @@
 
 	for (i = 0; i < enic->intr_count; i++) {
 		vnic_intr_init(&enic->intr[i],
-			INTR_COALESCE_USEC_TO_HW(enic->config.intr_timer_usec),
+			enic->config.intr_timer,
 			enic->config.intr_timer_type,
 			mask_on_assertion);
 	}
+
+	/* Clear LIF stats
+	 */
+
+	vnic_dev_stats_clear(enic->vdev);
 }
 
 int enic_alloc_vnic_resources(struct enic *enic)
diff -r 15109ec2f661 drivers/net/enic/enic_res.h
--- b/drivers/net/enic/enic_res.h	Wed Aug 17 13:31:06 2011 +0100
+++ a/drivers/net/enic/enic_res.h	Wed Aug 17 13:09:17 2011 +0100
@@ -1,5 +1,5 @@
 /*
- * Copyright 2008-2010 Cisco Systems, Inc.  All rights reserved.
+ * Copyright 2008 Cisco Systems, Inc.  All rights reserved.
  * Copyright 2007 Nuova Systems, Inc.  All rights reserved.
  *
  * This program is free software; you may redistribute it and/or modify
@@ -43,7 +43,7 @@
 	void *os_buf, dma_addr_t dma_addr, unsigned int len,
 	unsigned int mss_or_csum_offset, unsigned int hdr_len,
 	int vlan_tag_insert, unsigned int vlan_tag,
-	int offload_mode, int cq_entry, int sop, int eop, int loopback)
+	int offload_mode, int cq_entry, int sop, int eop)
 {
 	struct wq_enet_desc *desc = vnic_wq_next_desc(wq);
 
@@ -56,62 +56,61 @@
 		0, /* fcoe_encap */
 		(u8)vlan_tag_insert,
 		(u16)vlan_tag,
-		(u8)loopback);
+		0 /* loopback */);
 
 	vnic_wq_post(wq, os_buf, dma_addr, len, sop, eop);
 }
 
 static inline void enic_queue_wq_desc_cont(struct vnic_wq *wq,
-	void *os_buf, dma_addr_t dma_addr, unsigned int len,
-	int eop, int loopback)
+	void *os_buf, dma_addr_t dma_addr, unsigned int len, int eop)
 {
 	enic_queue_wq_desc_ex(wq, os_buf, dma_addr, len,
 		0, 0, 0, 0, 0,
-		eop, 0 /* !SOP */, eop, loopback);
+		eop, 0 /* !SOP */, eop);
 }
 
 static inline void enic_queue_wq_desc(struct vnic_wq *wq, void *os_buf,
 	dma_addr_t dma_addr, unsigned int len, int vlan_tag_insert,
-	unsigned int vlan_tag, int eop, int loopback)
+	unsigned int vlan_tag, int eop)
 {
 	enic_queue_wq_desc_ex(wq, os_buf, dma_addr, len,
 		0, 0, vlan_tag_insert, vlan_tag,
 		WQ_ENET_OFFLOAD_MODE_CSUM,
-		eop, 1 /* SOP */, eop, loopback);
+		eop, 1 /* SOP */, eop);
 }
 
 static inline void enic_queue_wq_desc_csum(struct vnic_wq *wq,
 	void *os_buf, dma_addr_t dma_addr, unsigned int len,
 	int ip_csum, int tcpudp_csum, int vlan_tag_insert,
-	unsigned int vlan_tag, int eop, int loopback)
+	unsigned int vlan_tag, int eop)
 {
 	enic_queue_wq_desc_ex(wq, os_buf, dma_addr, len,
 		(ip_csum ? 1 : 0) + (tcpudp_csum ? 2 : 0),
 		0, vlan_tag_insert, vlan_tag,
 		WQ_ENET_OFFLOAD_MODE_CSUM,
-		eop, 1 /* SOP */, eop, loopback);
+		eop, 1 /* SOP */, eop);
 }
 
 static inline void enic_queue_wq_desc_csum_l4(struct vnic_wq *wq,
 	void *os_buf, dma_addr_t dma_addr, unsigned int len,
 	unsigned int csum_offset, unsigned int hdr_len,
-	int vlan_tag_insert, unsigned int vlan_tag, int eop, int loopback)
+	int vlan_tag_insert, unsigned int vlan_tag, int eop)
 {
 	enic_queue_wq_desc_ex(wq, os_buf, dma_addr, len,
 		csum_offset, hdr_len, vlan_tag_insert, vlan_tag,
 		WQ_ENET_OFFLOAD_MODE_CSUM_L4,
-		eop, 1 /* SOP */, eop, loopback);
+		eop, 1 /* SOP */, eop);
 }
 
 static inline void enic_queue_wq_desc_tso(struct vnic_wq *wq,
 	void *os_buf, dma_addr_t dma_addr, unsigned int len,
 	unsigned int mss, unsigned int hdr_len, int vlan_tag_insert,
-	unsigned int vlan_tag, int eop, int loopback)
+	unsigned int vlan_tag, int eop)
 {
 	enic_queue_wq_desc_ex(wq, os_buf, dma_addr, len,
 		mss, hdr_len, vlan_tag_insert, vlan_tag,
 		WQ_ENET_OFFLOAD_MODE_TSO,
-		eop, 1 /* SOP */, eop, loopback);
+		eop, 1 /* SOP */, eop);
 }
 
 static inline void enic_queue_rq_desc(struct vnic_rq *rq,
@@ -133,8 +132,10 @@
 
 int enic_get_vnic_config(struct enic *);
 void enic_add_station_addr(struct enic *enic);
-int enic_add_vlan(struct enic *enic, u16 vlanid);
-int enic_del_vlan(struct enic *enic, u16 vlanid);
+void enic_add_multicast_addr(struct enic *enic, u8 *addr);
+void enic_del_multicast_addr(struct enic *enic, u8 *addr);
+void enic_add_vlan(struct enic *enic, u16 vlanid);
+void enic_del_vlan(struct enic *enic, u16 vlanid);
 int enic_set_nic_cfg(struct enic *enic, u8 rss_default_cpu, u8 rss_hash_type,
 	u8 rss_hash_bits, u8 rss_base_cpu, u8 rss_enable, u8 tso_ipid_split_en,
 	u8 ig_vlan_strip_en);
diff -r 15109ec2f661 drivers/net/enic/rq_enet_desc.h
--- b/drivers/net/enic/rq_enet_desc.h	Wed Aug 17 13:31:06 2011 +0100
+++ a/drivers/net/enic/rq_enet_desc.h	Wed Aug 17 13:09:17 2011 +0100
@@ -1,5 +1,5 @@
 /*
- * Copyright 2008-2010 Cisco Systems, Inc.  All rights reserved.
+ * Copyright 2008 Cisco Systems, Inc.  All rights reserved.
  * Copyright 2007 Nuova Systems, Inc.  All rights reserved.
  *
  * This program is free software; you may redistribute it and/or modify
diff -r 15109ec2f661 drivers/net/enic/vnic_cq.c
--- b/drivers/net/enic/vnic_cq.c	Wed Aug 17 13:31:06 2011 +0100
+++ a/drivers/net/enic/vnic_cq.c	Wed Aug 17 13:09:17 2011 +0100
@@ -1,5 +1,5 @@
 /*
- * Copyright 2008-2010 Cisco Systems, Inc.  All rights reserved.
+ * Copyright 2008 Cisco Systems, Inc.  All rights reserved.
  * Copyright 2007 Nuova Systems, Inc.  All rights reserved.
  *
  * This program is free software; you may redistribute it and/or modify
diff -r 15109ec2f661 drivers/net/enic/vnic_cq.h
--- b/drivers/net/enic/vnic_cq.h	Wed Aug 17 13:31:06 2011 +0100
+++ a/drivers/net/enic/vnic_cq.h	Wed Aug 17 13:09:17 2011 +0100
@@ -1,5 +1,5 @@
 /*
- * Copyright 2008-2010 Cisco Systems, Inc.  All rights reserved.
+ * Copyright 2008 Cisco Systems, Inc.  All rights reserved.
  * Copyright 2007 Nuova Systems, Inc.  All rights reserved.
  *
  * This program is free software; you may redistribute it and/or modify
diff -r 15109ec2f661 drivers/net/enic/vnic_dev.c
--- b/drivers/net/enic/vnic_dev.c	Wed Aug 17 13:31:06 2011 +0100
+++ a/drivers/net/enic/vnic_dev.c	Wed Aug 17 13:09:17 2011 +0100
@@ -1,5 +1,5 @@
 /*
- * Copyright 2008-2010 Cisco Systems, Inc.  All rights reserved.
+ * Copyright 2008 Cisco Systems, Inc.  All rights reserved.
  * Copyright 2007 Nuova Systems, Inc.  All rights reserved.
  *
  * This program is free software; you may redistribute it and/or modify
@@ -23,24 +23,21 @@
 #include <linux/pci.h>
 #include <linux/delay.h>
 #include <linux/if_ether.h>
-#include <linux/slab.h>
 
 #include "vnic_resource.h"
 #include "vnic_devcmd.h"
 #include "vnic_dev.h"
 #include "vnic_stats.h"
 
-enum vnic_proxy_type {
-	PROXY_NONE,
-	PROXY_BY_BDF,
-};
-
 struct vnic_res {
 	void __iomem *vaddr;
 	dma_addr_t bus_addr;
 	unsigned int count;
 };
 
+#define VNIC_DEV_CAP_INIT	0x0001
+#define VNIC_DEV_CAP_PERBI	0x0002
+
 struct vnic_dev {
 	void *priv;
 	struct pci_dev *pdev;
@@ -51,14 +48,13 @@
 	struct vnic_devcmd_notify notify_copy;
 	dma_addr_t notify_pa;
 	u32 notify_sz;
+	u32 *linkstatus;
 	dma_addr_t linkstatus_pa;
 	struct vnic_stats *stats;
 	dma_addr_t stats_pa;
 	struct vnic_devcmd_fw_info *fw_info;
 	dma_addr_t fw_info_pa;
-	enum vnic_proxy_type proxy;
-	u32 proxy_index;
-	u64 args[VNIC_DEVCMD_NARGS];
+	u32 cap_flags;
 };
 
 #define VNIC_MAX_RES_HDR_SIZE \
@@ -75,7 +71,6 @@
 	struct vnic_dev_bar *bar, unsigned int num_bars)
 {
 	struct vnic_resource_header __iomem *rh;
-	struct mgmt_barmap_hdr __iomem *mrh;
 	struct vnic_resource __iomem *r;
 	u8 type;
 
@@ -87,32 +82,22 @@
 		return -EINVAL;
 	}
 
-	rh  = bar->vaddr;
-	mrh = bar->vaddr;
+	rh = bar->vaddr;
 	if (!rh) {
 		printk(KERN_ERR "vNIC BAR0 res hdr not mem-mapped\n");
 		return -EINVAL;
 	}
 
-	/* Check for mgmt vnic in addition to normal vnic */
-	if ((ioread32(&rh->magic) != VNIC_RES_MAGIC) ||
-		(ioread32(&rh->version) != VNIC_RES_VERSION)) {
-		if ((ioread32(&mrh->magic) != MGMTVNIC_MAGIC) ||
-			(ioread32(&mrh->version) != MGMTVNIC_VERSION)) {
-			printk(KERN_ERR "vNIC BAR0 res magic/version error "
-			"exp (%lx/%lx) or (%lx/%lx), curr (%x/%x)\n",
+	if (ioread32(&rh->magic) != VNIC_RES_MAGIC ||
+	    ioread32(&rh->version) != VNIC_RES_VERSION) {
+		printk(KERN_ERR "vNIC BAR0 res magic/version error "
+			"exp (%lx/%lx) curr (%x/%x)\n",
 			VNIC_RES_MAGIC, VNIC_RES_VERSION,
-			MGMTVNIC_MAGIC, MGMTVNIC_VERSION,
 			ioread32(&rh->magic), ioread32(&rh->version));
-			return -EINVAL;
-		}
+		return -EINVAL;
 	}
 
-	if (ioread32(&mrh->magic) == MGMTVNIC_MAGIC)
-		r = (struct vnic_resource __iomem *)(mrh + 1);
-	else
-		r = (struct vnic_resource __iomem *)(rh + 1);
-
+	r = (struct vnic_resource __iomem *)(rh + 1);
 
 	while ((type = ioread8(&r->type)) != RES_TYPE_EOL) {
 
@@ -273,29 +258,23 @@
 	}
 }
 
-static int _vnic_dev_cmd(struct vnic_dev *vdev, enum vnic_devcmd_cmd cmd,
-	int wait)
+int vnic_dev_cmd(struct vnic_dev *vdev, enum vnic_devcmd_cmd cmd,
+	u64 *a0, u64 *a1, int wait)
 {
 	struct vnic_devcmd __iomem *devcmd = vdev->devcmd;
-	unsigned int i;
 	int delay;
 	u32 status;
 	int err;
 
 	status = ioread32(&devcmd->status);
-	if (status == 0xFFFFFFFF) {
-		/* PCI-e target device is gone */
-		return -ENODEV;
-	}
-
 	if (status & STAT_BUSY) {
 		printk(KERN_ERR "Busy devcmd %d\n", _CMD_N(cmd));
 		return -EBUSY;
 	}
 
 	if (_CMD_DIR(cmd) & _CMD_DIR_WRITE) {
-		for (i = 0; i < VNIC_DEVCMD_NARGS; i++)
-			writeq(vdev->args[i], &devcmd->args[i]);
+		writeq(*a0, &devcmd->args[0]);
+		writeq(*a1, &devcmd->args[1]);
 		wmb();
 	}
 
@@ -309,11 +288,6 @@
 		udelay(100);
 
 		status = ioread32(&devcmd->status);
-		if (status == 0xFFFFFFFF) {
-			/* PCI-e target device is gone */
-			return -ENODEV;
-		}
-
 		if (!(status & STAT_BUSY)) {
 
 			if (status & STAT_ERROR) {
@@ -327,8 +301,8 @@
 
 			if (_CMD_DIR(cmd) & _CMD_DIR_READ) {
 				rmb();
-				for (i = 0; i < VNIC_DEVCMD_NARGS; i++)
-					vdev->args[i] = readq(&devcmd->args[i]);
+				*a0 = readq(&devcmd->args[0]);
+				*a1 = readq(&devcmd->args[1]);
 			}
 
 			return 0;
@@ -339,80 +313,6 @@
 	return -ETIMEDOUT;
 }
 
-static int vnic_dev_cmd_proxy_by_bdf(struct vnic_dev *vdev,
-	enum vnic_devcmd_cmd cmd, u64 *a0, u64 *a1, int wait)
-{
-	u32 status;
-	int err;
-
-	memset(vdev->args, 0, sizeof(vdev->args));
-
-	vdev->args[0] = vdev->proxy_index; /* bdf */
-	vdev->args[1] = cmd;
-	vdev->args[2] = *a0;
-	vdev->args[3] = *a1;
-
-	err = _vnic_dev_cmd(vdev, CMD_PROXY_BY_BDF, wait);
-	if (err)
-		return err;
-
-	status = (u32)vdev->args[0];
-	if (status & STAT_ERROR) {
-		err = (int)vdev->args[1];
-		if (err != ERR_ECMDUNKNOWN ||
-		    cmd != CMD_CAPABILITY)
-			printk(KERN_ERR "Error %d proxy devcmd %d\n", err, _CMD_N(cmd));
-		return err;
-	}
-
-	*a0 = vdev->args[1];
-	*a1 = vdev->args[2];
-
-	return 0;
-}
-
-static int vnic_dev_cmd_no_proxy(struct vnic_dev *vdev,
-	enum vnic_devcmd_cmd cmd, u64 *a0, u64 *a1, int wait)
-{
-	int err;
-
-	vdev->args[0] = *a0;
-	vdev->args[1] = *a1;
-
-	err = _vnic_dev_cmd(vdev, cmd, wait);
-
-	*a0 = vdev->args[0];
-	*a1 = vdev->args[1];
-
-	return err;
-}
-
-void vnic_dev_cmd_proxy_by_bdf_start(struct vnic_dev *vdev, u16 bdf)
-{
-	vdev->proxy = PROXY_BY_BDF;
-	vdev->proxy_index = bdf;
-}
-
-void vnic_dev_cmd_proxy_end(struct vnic_dev *vdev)
-{
-	vdev->proxy = PROXY_NONE;
-	vdev->proxy_index = 0;
-}
-
-int vnic_dev_cmd(struct vnic_dev *vdev, enum vnic_devcmd_cmd cmd,
-	u64 *a0, u64 *a1, int wait)
-{
-	memset(vdev->args, 0, sizeof(vdev->args));
-
-	switch (vdev->proxy) {
-	case PROXY_BY_BDF:
-		return vnic_dev_cmd_proxy_by_bdf(vdev, cmd, a0, a1, wait);
-	case PROXY_NONE:
-	default:
-		return vnic_dev_cmd_no_proxy(vdev, cmd, a0, a1, wait);
-	}
-}
-
 static int vnic_dev_capable(struct vnic_dev *vdev, enum vnic_devcmd_cmd cmd)
 {
 	u64 a0 = (u32)cmd, a1 = 0;
@@ -531,19 +431,6 @@
 	return vnic_dev_cmd(vdev, CMD_ENABLE, &a0, &a1, wait);
 }
 
-int vnic_dev_enable_wait(struct vnic_dev *vdev)
-{
-	u64 a0 = 0, a1 = 0;
-	int wait = 1000;
-	int err;
-
-	err = vnic_dev_cmd(vdev, CMD_ENABLE_WAIT, &a0, &a1, wait);
-	if (err == ERR_ECMDUNKNOWN)
-		return vnic_dev_cmd(vdev, CMD_ENABLE, &a0, &a1, wait);
-
-	return err;
-}
-
 int vnic_dev_disable(struct vnic_dev *vdev)
 {
 	u64 a0 = 0, a1 = 0;
@@ -599,44 +486,6 @@
 	return 0;
 }
 
-int vnic_dev_hang_reset(struct vnic_dev *vdev, int arg)
-{
-	u64 a0 = (u32)arg, a1 = 0;
-	int wait = 1000;
-	int err;
-
-	err = vnic_dev_cmd(vdev, CMD_HANG_RESET, &a0, &a1, wait);
-	if (err == ERR_ECMDUNKNOWN) {
-		err = vnic_dev_soft_reset(vdev, arg);
-		if (err)
-			return err;
-
-		return vnic_dev_init(vdev, 0);
-	}
-
-	return err;
-}
-
-int vnic_dev_hang_reset_done(struct vnic_dev *vdev, int *done)
-{
-	u64 a0 = 0, a1 = 0;
-	int wait = 1000;
-	int err;
-
-	*done = 0;
-
-	err = vnic_dev_cmd(vdev, CMD_HANG_RESET_STATUS, &a0, &a1, wait);
-	if (err) {
-		if (err == ERR_ECMDUNKNOWN)
-			return vnic_dev_soft_reset_done(vdev, done);
-		return err;
-	}
-
-	*done = (a0 == 0);
-
-	return 0;
-}
-
 int vnic_dev_hang_notify(struct vnic_dev *vdev)
 {
 	u64 a0, a1;
@@ -663,7 +512,7 @@
 	return 0;
 }
 
-int vnic_dev_packet_filter(struct vnic_dev *vdev, int directed, int multicast,
+void vnic_dev_packet_filter(struct vnic_dev *vdev, int directed, int multicast,
 	int broadcast, int promisc, int allmulti)
 {
 	u64 a0, a1 = 0;
@@ -679,31 +528,9 @@
 	err = vnic_dev_cmd(vdev, CMD_PACKET_FILTER, &a0, &a1, wait);
 	if (err)
 		printk(KERN_ERR "Can't set packet filter\n");
-
-	return err;
 }
 
-int vnic_dev_packet_filter_all(struct vnic_dev *vdev, int directed,
-	int multicast, int broadcast, int promisc, int allmulti)
-{
-	u64 a0, a1 = 0;
-	int wait = 1000;
-	int err;
-
-	a0 = (directed ? CMD_PFILTER_DIRECTED : 0) |
-	     (multicast ? CMD_PFILTER_MULTICAST : 0) |
-	     (broadcast ? CMD_PFILTER_BROADCAST : 0) |
-	     (promisc ? CMD_PFILTER_PROMISCUOUS : 0) |
-	     (allmulti ? CMD_PFILTER_ALL_MULTICAST : 0);
-
-	err = vnic_dev_cmd(vdev, CMD_PACKET_FILTER_ALL, &a0, &a1, wait);
-	if (err)
-		printk(KERN_ERR "Can't set packet filter\n");
-
-	return err;
-}
-
-int vnic_dev_add_addr(struct vnic_dev *vdev, u8 *addr)
+void vnic_dev_add_addr(struct vnic_dev *vdev, u8 *addr)
 {
 	u64 a0 = 0, a1 = 0;
 	int wait = 1000;
@@ -716,11 +543,9 @@
 	err = vnic_dev_cmd(vdev, CMD_ADDR_ADD, &a0, &a1, wait);
 	if (err)
 		printk(KERN_ERR "Can't add addr [%pM], %d\n", addr, err);
-
-	return err;
 }
 
-int vnic_dev_del_addr(struct vnic_dev *vdev, u8 *addr)
+void vnic_dev_del_addr(struct vnic_dev *vdev, u8 *addr)
 {
 	u64 a0 = 0, a1 = 0;
 	int wait = 1000;
@@ -733,22 +558,6 @@
 	err = vnic_dev_cmd(vdev, CMD_ADDR_DEL, &a0, &a1, wait);
 	if (err)
 		printk(KERN_ERR "Can't del addr [%pM], %d\n", addr, err);
-
-	return err;
-}
-
-int vnic_dev_set_ig_vlan_rewrite_mode(struct vnic_dev *vdev,
-	u8 ig_vlan_rewrite_mode)
-{
-	u64 a0 = ig_vlan_rewrite_mode, a1 = 0;
-	int wait = 1000;
-	int err;
-
-	err = vnic_dev_cmd(vdev, CMD_IG_VLAN_REWRITE_MODE, &a0, &a1, wait);
-	if (err == ERR_ECMDUNKNOWN)
-		return 0;
-
-	return err;
 }
 
 int vnic_dev_raise_intr(struct vnic_dev *vdev, u16 intr)
@@ -765,18 +574,22 @@
 	return err;
 }
 
-int vnic_dev_notify_setcmd(struct vnic_dev *vdev,
-	void *notify_addr, dma_addr_t notify_pa, u16 intr)
+int vnic_dev_notify_set(struct vnic_dev *vdev, u16 intr)
 {
 	u64 a0, a1;
 	int wait = 1000;
 	int r;
 
-	memset(notify_addr, 0, sizeof(struct vnic_devcmd_notify));
-	vdev->notify = notify_addr;
-	vdev->notify_pa = notify_pa;
+	if (!vdev->notify) {
+		vdev->notify = pci_alloc_consistent(vdev->pdev,
+			sizeof(struct vnic_devcmd_notify),
+			&vdev->notify_pa);
+		if (!vdev->notify)
+			return -ENOMEM;
+		memset(vdev->notify, 0, sizeof(struct vnic_devcmd_notify));
+	}
 
-	a0 = (u64)notify_pa;
+	a0 = vdev->notify_pa;
 	a1 = ((u64)intr << 32) & 0x0000ffff00000000ULL;
 	a1 += sizeof(struct vnic_devcmd_notify);
 
@@ -785,54 +598,17 @@
 	return r;
 }
 
-int vnic_dev_notify_set(struct vnic_dev *vdev, u16 intr)
-{
-	void *notify_addr;
-	dma_addr_t notify_pa;
-
-	if (vdev->notify || vdev->notify_pa) {
-		printk(KERN_ERR "notify block %p still allocated",
-			vdev->notify);
-		return -EINVAL;
-	}
-
-	notify_addr = pci_alloc_consistent(vdev->pdev,
-			sizeof(struct vnic_devcmd_notify),
-			&notify_pa);
-	if (!notify_addr)
-		return -ENOMEM;
-
-	return vnic_dev_notify_setcmd(vdev, notify_addr, notify_pa, intr);
-}
-
-int vnic_dev_notify_unsetcmd(struct vnic_dev *vdev)
+void vnic_dev_notify_unset(struct vnic_dev *vdev)
 {
 	u64 a0, a1;
 	int wait = 1000;
-	int err;
 
 	a0 = 0;  /* paddr = 0 to unset notify buffer */
 	a1 = 0x0000ffff00000000ULL; /* intr num = -1 to unreg for intr */
 	a1 += sizeof(struct vnic_devcmd_notify);
 
-	err = vnic_dev_cmd(vdev, CMD_NOTIFY, &a0, &a1, wait);
-	vdev->notify = NULL;
-	vdev->notify_pa = 0;
+	vnic_dev_cmd(vdev, CMD_NOTIFY, &a0, &a1, wait);
 	vdev->notify_sz = 0;
-
-	return err;
-}
-
-int vnic_dev_notify_unset(struct vnic_dev *vdev)
-{
-	if (vdev->notify) {
-		pci_free_consistent(vdev->pdev,
-			sizeof(struct vnic_devcmd_notify),
-			vdev->notify,
-			vdev->notify_pa);
-	}
-
-	return vnic_dev_notify_unsetcmd(vdev);
 }
 
 static int vnic_dev_notify_ready(struct vnic_dev *vdev)
@@ -862,14 +638,13 @@
 	int wait = 1000;
 	int r = 0;
 
-	if (vnic_dev_capable(vdev, CMD_INIT))
+	if (vdev->cap_flags & VNIC_DEV_CAP_INIT)
 		r = vnic_dev_cmd(vdev, CMD_INIT, &a0, &a1, wait);
 	else {
 		vnic_dev_cmd(vdev, CMD_INIT_v1, &a0, &a1, wait);
 		if (a0 & CMD_INITF_DEFAULT_MAC) {
-			/* Emulate these for old CMD_INIT_v1 which
-			 * didn't pass a0 so no CMD_INITF_*.
-			 */
+			// Emulate these for old CMD_INIT_v1 which
+			// didn't pass a0 so no CMD_INITF_*.
 			vnic_dev_cmd(vdev, CMD_MAC_ADDR, &a0, &a1, wait);
 			vnic_dev_cmd(vdev, CMD_ADDR_ADD, &a0, &a1, wait);
 		}
@@ -879,6 +654,9 @@
 
 int vnic_dev_link_status(struct vnic_dev *vdev)
 {
+	if (vdev->linkstatus)
+		return *vdev->linkstatus;
+
 	if (!vnic_dev_notify_ready(vdev))
 		return 0;
 
@@ -925,14 +703,6 @@
 	return vdev->notify_copy.status;
 }
 
-u32 vnic_dev_uif(struct vnic_dev *vdev)
-{
-	if (!vnic_dev_notify_ready(vdev))
-		return 0;
-
-	return vdev->notify_copy.uif;
-}
-
 void vnic_dev_set_intr_mode(struct vnic_dev *vdev,
 	enum vnic_dev_intr_mode intr_mode)
 {
@@ -953,9 +723,14 @@
 				sizeof(struct vnic_devcmd_notify),
 				vdev->notify,
 				vdev->notify_pa);
+		if (vdev->linkstatus)
+			pci_free_consistent(vdev->pdev,
+				sizeof(u32),
+				vdev->linkstatus,
+				vdev->linkstatus_pa);
 		if (vdev->stats)
 			pci_free_consistent(vdev->pdev,
-				sizeof(struct vnic_stats),
+				sizeof(struct vnic_dev),
 				vdev->stats, vdev->stats_pa);
 		if (vdev->fw_info)
 			pci_free_consistent(vdev->pdev,
@@ -985,6 +760,11 @@
 	if (!vdev->devcmd)
 		goto err_out;
 
+	vdev->cap_flags = 0;
+
+	if (vnic_dev_capable(vdev, CMD_INIT))
+		vdev->cap_flags |= VNIC_DEV_CAP_INIT;
+
 	return vdev;
 
 err_out:
diff -r 15109ec2f661 drivers/net/enic/vnic_dev.h
--- b/drivers/net/enic/vnic_dev.h	Wed Aug 17 13:31:06 2011 +0100
+++ a/drivers/net/enic/vnic_dev.h	Wed Aug 17 13:09:17 2011 +0100
@@ -1,5 +1,5 @@
 /*
- * Copyright 2008-2010 Cisco Systems, Inc.  All rights reserved.
+ * Copyright 2008 Cisco Systems, Inc.  All rights reserved.
  * Copyright 2007 Nuova Systems, Inc.  All rights reserved.
  *
  * This program is free software; you may redistribute it and/or modify
@@ -92,8 +92,6 @@
 	struct vnic_dev_ring *ring);
 int vnic_dev_cmd(struct vnic_dev *vdev, enum vnic_devcmd_cmd cmd,
 	u64 *a0, u64 *a1, int wait);
-void vnic_dev_cmd_proxy_by_bdf_start(struct vnic_dev *vdev, u16 bdf);
-void vnic_dev_cmd_proxy_end(struct vnic_dev *vdev);
 int vnic_dev_fw_info(struct vnic_dev *vdev,
 	struct vnic_devcmd_fw_info **fw_info);
 int vnic_dev_hw_version(struct vnic_dev *vdev,
@@ -103,43 +101,32 @@
 int vnic_dev_stats_clear(struct vnic_dev *vdev);
 int vnic_dev_stats_dump(struct vnic_dev *vdev, struct vnic_stats **stats);
 int vnic_dev_hang_notify(struct vnic_dev *vdev);
-int vnic_dev_packet_filter(struct vnic_dev *vdev, int directed, int multicast,
+void vnic_dev_packet_filter(struct vnic_dev *vdev, int directed, int multicast,
 	int broadcast, int promisc, int allmulti);
-int vnic_dev_packet_filter_all(struct vnic_dev *vdev, int directed,
-	int multicast, int broadcast, int promisc, int allmulti);
-int vnic_dev_add_addr(struct vnic_dev *vdev, u8 *addr);
-int vnic_dev_del_addr(struct vnic_dev *vdev, u8 *addr);
+void vnic_dev_add_addr(struct vnic_dev *vdev, u8 *addr);
+void vnic_dev_del_addr(struct vnic_dev *vdev, u8 *addr);
 int vnic_dev_mac_addr(struct vnic_dev *vdev, u8 *mac_addr);
 int vnic_dev_raise_intr(struct vnic_dev *vdev, u16 intr);
-int vnic_dev_notify_setcmd(struct vnic_dev *vdev,
-	void *notify_addr, dma_addr_t notify_pa, u16 intr);
 int vnic_dev_notify_set(struct vnic_dev *vdev, u16 intr);
-int vnic_dev_notify_unsetcmd(struct vnic_dev *vdev);
-int vnic_dev_notify_unset(struct vnic_dev *vdev);
+void vnic_dev_notify_unset(struct vnic_dev *vdev);
 int vnic_dev_link_status(struct vnic_dev *vdev);
 u32 vnic_dev_port_speed(struct vnic_dev *vdev);
 u32 vnic_dev_msg_lvl(struct vnic_dev *vdev);
 u32 vnic_dev_mtu(struct vnic_dev *vdev);
 u32 vnic_dev_link_down_cnt(struct vnic_dev *vdev);
 u32 vnic_dev_notify_status(struct vnic_dev *vdev);
-u32 vnic_dev_uif(struct vnic_dev *vdev);
 int vnic_dev_close(struct vnic_dev *vdev);
 int vnic_dev_enable(struct vnic_dev *vdev);
-int vnic_dev_enable_wait(struct vnic_dev *vdev);
 int vnic_dev_disable(struct vnic_dev *vdev);
 int vnic_dev_open(struct vnic_dev *vdev, int arg);
 int vnic_dev_open_done(struct vnic_dev *vdev, int *done);
 int vnic_dev_init(struct vnic_dev *vdev, int arg);
 int vnic_dev_soft_reset(struct vnic_dev *vdev, int arg);
 int vnic_dev_soft_reset_done(struct vnic_dev *vdev, int *done);
-int vnic_dev_hang_reset(struct vnic_dev *vdev, int arg);
-int vnic_dev_hang_reset_done(struct vnic_dev *vdev, int *done);
 void vnic_dev_set_intr_mode(struct vnic_dev *vdev,
 	enum vnic_dev_intr_mode intr_mode);
 enum vnic_dev_intr_mode vnic_dev_get_intr_mode(struct vnic_dev *vdev);
 void vnic_dev_unregister(struct vnic_dev *vdev);
-int vnic_dev_set_ig_vlan_rewrite_mode(struct vnic_dev *vdev,
-	u8 ig_vlan_rewrite_mode);
 struct vnic_dev *vnic_dev_register(struct vnic_dev *vdev,
 	void *priv, struct pci_dev *pdev, struct vnic_dev_bar *bar,
 	unsigned int num_bars);
diff -r 15109ec2f661 drivers/net/enic/vnic_devcmd.h
--- b/drivers/net/enic/vnic_devcmd.h	Wed Aug 17 13:31:06 2011 +0100
+++ a/drivers/net/enic/vnic_devcmd.h	Wed Aug 17 13:09:17 2011 +0100
@@ -1,5 +1,5 @@
 /*
- * Copyright 2008-2010 Cisco Systems, Inc.  All rights reserved.
+ * Copyright 2008 Cisco Systems, Inc.  All rights reserved.
  * Copyright 2007 Nuova Systems, Inc.  All rights reserved.
  *
  * This program is free software; you may redistribute it and/or modify
@@ -98,9 +98,6 @@
 	/* set Rx packet filter: (u32)a0=filters (see CMD_PFILTER_*) */
 	CMD_PACKET_FILTER	= _CMDCNW(_CMD_DIR_WRITE, _CMD_VTYPE_ENET, 7),
 
-	/* set Rx packet filter for all: (u32)a0=filters (see CMD_PFILTER_*) */
-	CMD_PACKET_FILTER_ALL   = _CMDCNW(_CMD_DIR_WRITE, _CMD_VTYPE_ALL, 7),
-
 	/* hang detection notification */
 	CMD_HANG_NOTIFY         = _CMDC(_CMD_DIR_NONE, _CMD_VTYPE_ALL, 8),
 
@@ -174,9 +171,6 @@
 	/* enable virtual link */
 	CMD_ENABLE		= _CMDCNW(_CMD_DIR_WRITE, _CMD_VTYPE_ALL, 28),
 
-	/* enable virtual link, waiting variant. */
-	CMD_ENABLE_WAIT		= _CMDC(_CMD_DIR_WRITE, _CMD_VTYPE_ALL, 28),
-
 	/* disable virtual link */
 	CMD_DISABLE		= _CMDC(_CMD_DIR_NONE, _CMD_VTYPE_ALL, 29),
 
@@ -217,39 +211,6 @@
 	 * in: (u16)a0=interrupt number to assert
 	 */
 	CMD_IAR			= _CMDCNW(_CMD_DIR_WRITE, _CMD_VTYPE_ALL, 38),
-
-	/* initiate hangreset, like softreset after hang detected */
-	CMD_HANG_RESET		= _CMDC(_CMD_DIR_NONE, _CMD_VTYPE_ALL, 39),
-
-	/* hangreset status:
-	 *    out: a0=0 reset complete, a0=1 reset in progress */
-	CMD_HANG_RESET_STATUS   = _CMDC(_CMD_DIR_READ, _CMD_VTYPE_ALL, 40),
-
-	/*
-	 * Set hw ingress packet vlan rewrite mode:
-	 * in:  (u32)a0=new vlan rewrite mode
-	 * out: (u32)a0=old vlan rewrite mode */
-	CMD_IG_VLAN_REWRITE_MODE = _CMDC(_CMD_DIR_RW, _CMD_VTYPE_ENET, 41),
-
-	/*
-	 * in:  (u16)a0=bdf of target vnic
-	 *      (u32)a1=cmd to proxy
-	 *      a2-a15=args to cmd in a1
-	 * out: (u32)a0=status of proxied cmd
-	 *      a1-a15=out args of proxied cmd */
-	CMD_PROXY_BY_BDF =	_CMDC(_CMD_DIR_RW, _CMD_VTYPE_ALL, 42),
-
-	/*
-	 * As for BY_BDF except a0 is index of hvnlink subordinate vnic
-	 * or SR-IOV virtual vnic */
-	CMD_PROXY_BY_INDEX =    _CMDC(_CMD_DIR_RW, _CMD_VTYPE_ALL, 43),
-
-	/*
-	 * in:  (u64)a0=paddr of buffer to put latest VIC VIF-CONFIG-INFO TLV in
-	 *      (u32)a1=length of buffer in a0
-	 * out: (u64)a0=paddr of buffer with latest VIC VIF-CONFIG-INFO TLV
-	 *      (u32)a1=actual length of latest VIC VIF-CONFIG-INFO TLV */
-	CMD_CONFIG_INFO_GET     = _CMDC(_CMD_DIR_RW, _CMD_VTYPE_ALL, 44),
 };
 
 /* flags for CMD_OPEN */
@@ -265,12 +226,6 @@
 #define CMD_PFILTER_PROMISCUOUS		0x08
 #define CMD_PFILTER_ALL_MULTICAST	0x10
 
-/* rewrite modes for CMD_IG_VLAN_REWRITE_MODE */
-#define IG_VLAN_REWRITE_MODE_DEFAULT_TRUNK              0
-#define IG_VLAN_REWRITE_MODE_UNTAG_DEFAULT_VLAN         1
-#define IG_VLAN_REWRITE_MODE_PRIORITY_TAG_DEFAULT_VLAN  2
-#define IG_VLAN_REWRITE_MODE_PASS_THRU                  3
-
 enum vnic_devcmd_status {
 	STAT_NONE = 0,
 	STAT_BUSY = 1 << 0,	/* cmd in progress */
diff -r 15109ec2f661 drivers/net/enic/vnic_enet.h
--- b/drivers/net/enic/vnic_enet.h	Wed Aug 17 13:31:06 2011 +0100
+++ a/drivers/net/enic/vnic_enet.h	Wed Aug 17 13:09:17 2011 +0100
@@ -1,5 +1,5 @@
 /*
- * Copyright 2008-2010 Cisco Systems, Inc.  All rights reserved.
+ * Copyright 2008 Cisco Systems, Inc.  All rights reserved.
  * Copyright 2007 Nuova Systems, Inc.  All rights reserved.
  *
  * This program is free software; you may redistribute it and/or modify
@@ -20,22 +20,16 @@
 #ifndef _VNIC_ENIC_H_
 #define _VNIC_ENIC_H_
 
-/* Hardware intr coalesce timer is in units of 1.5us */
-#define INTR_COALESCE_USEC_TO_HW(usec) ((usec) * 2/3)
-#define INTR_COALESCE_HW_TO_USEC(usec) ((usec) * 3/2)
-
 /* Device-specific region: enet configuration */
 struct vnic_enet_config {
 	u32 flags;
 	u32 wq_desc_count;
 	u32 rq_desc_count;
 	u16 mtu;
-	u16 intr_timer_deprecated;
+	u16 intr_timer;
 	u8 intr_timer_type;
 	u8 intr_mode;
 	char devname[16];
-	u32 intr_timer_usec;
-	u16 loop_tag;
 };
 
 #define VENETF_TSO		0x1	/* TSO enabled */
@@ -49,6 +43,5 @@
 #define VENETF_RSSHASH_TCPIPV6	0x100	/* Hash on TCP + IPv6 fields */
 #define VENETF_RSSHASH_IPV6_EX	0x200	/* Hash on IPv6 extended fields */
 #define VENETF_RSSHASH_TCPIPV6_EX 0x400	/* Hash on TCP + IPv6 ext. fields */
-#define VENETF_LOOP		0x800	/* Loopback enabled */
 
 #endif /* _VNIC_ENIC_H_ */
diff -r 15109ec2f661 drivers/net/enic/vnic_intr.c
--- b/drivers/net/enic/vnic_intr.c	Wed Aug 17 13:31:06 2011 +0100
+++ a/drivers/net/enic/vnic_intr.c	Wed Aug 17 13:09:17 2011 +0100
@@ -1,5 +1,5 @@
 /*
- * Copyright 2008-2010 Cisco Systems, Inc.  All rights reserved.
+ * Copyright 2008 Cisco Systems, Inc.  All rights reserved.
  * Copyright 2007 Nuova Systems, Inc.  All rights reserved.
  *
  * This program is free software; you may redistribute it and/or modify
@@ -50,18 +50,12 @@
 void vnic_intr_init(struct vnic_intr *intr, unsigned int coalescing_timer,
 	unsigned int coalescing_type, unsigned int mask_on_assertion)
 {
-	vnic_intr_coalescing_timer_set(intr, coalescing_timer);
+	iowrite32(coalescing_timer, &intr->ctrl->coalescing_timer);
 	iowrite32(coalescing_type, &intr->ctrl->coalescing_type);
 	iowrite32(mask_on_assertion, &intr->ctrl->mask_on_assertion);
 	iowrite32(0, &intr->ctrl->int_credits);
 }
 
-void vnic_intr_coalescing_timer_set(struct vnic_intr *intr,
-	unsigned int coalescing_timer)
-{
-	iowrite32(coalescing_timer, &intr->ctrl->coalescing_timer);
-}
-
 void vnic_intr_clean(struct vnic_intr *intr)
 {
 	iowrite32(0, &intr->ctrl->int_credits);
diff -r 15109ec2f661 drivers/net/enic/vnic_intr.h
--- b/drivers/net/enic/vnic_intr.h	Wed Aug 17 13:31:06 2011 +0100
+++ a/drivers/net/enic/vnic_intr.h	Wed Aug 17 13:09:17 2011 +0100
@@ -1,5 +1,5 @@
 /*
- * Copyright 2008-2010 Cisco Systems, Inc.  All rights reserved.
+ * Copyright 2008 Cisco Systems, Inc.  All rights reserved.
  * Copyright 2007 Nuova Systems, Inc.  All rights reserved.
  *
  * This program is free software; you may redistribute it and/or modify
@@ -61,12 +61,6 @@
 static inline void vnic_intr_mask(struct vnic_intr *intr)
 {
 	iowrite32(1, &intr->ctrl->mask);
-	(void)ioread32(&intr->ctrl->mask);
-}
-
-static inline int vnic_intr_masked(struct vnic_intr *intr)
-{
-	return ioread32(&intr->ctrl->mask);
 }
 
 static inline void vnic_intr_return_credits(struct vnic_intr *intr,
@@ -107,8 +101,6 @@
 	unsigned int index);
 void vnic_intr_init(struct vnic_intr *intr, unsigned int coalescing_timer,
 	unsigned int coalescing_type, unsigned int mask_on_assertion);
-void vnic_intr_coalescing_timer_set(struct vnic_intr *intr,
-	unsigned int coalescing_timer);
 void vnic_intr_clean(struct vnic_intr *intr);
 
 #endif /* _VNIC_INTR_H_ */
diff -r 15109ec2f661 drivers/net/enic/vnic_nic.h
--- b/drivers/net/enic/vnic_nic.h	Wed Aug 17 13:31:06 2011 +0100
+++ a/drivers/net/enic/vnic_nic.h	Wed Aug 17 13:09:17 2011 +0100
@@ -1,5 +1,5 @@
 /*
- * Copyright 2008-2010 Cisco Systems, Inc.  All rights reserved.
+ * Copyright 2008 Cisco Systems, Inc.  All rights reserved.
  * Copyright 2007 Nuova Systems, Inc.  All rights reserved.
  *
  * This program is free software; you may redistribute it and/or modify
@@ -41,12 +41,12 @@
 #define NIC_CFG_IG_VLAN_STRIP_EN_MASK_FIELD	1UL
 #define NIC_CFG_IG_VLAN_STRIP_EN_SHIFT		24
 
-#define NIC_CFG_RSS_HASH_TYPE_IPV4		(1 << 1)
-#define NIC_CFG_RSS_HASH_TYPE_TCP_IPV4		(1 << 2)
-#define NIC_CFG_RSS_HASH_TYPE_IPV6		(1 << 3)
-#define NIC_CFG_RSS_HASH_TYPE_TCP_IPV6		(1 << 4)
-#define NIC_CFG_RSS_HASH_TYPE_IPV6_EX		(1 << 5)
-#define NIC_CFG_RSS_HASH_TYPE_TCP_IPV6_EX	(1 << 6)
+#define NIC_CFG_RSS_HASH_TYPE_IPV4		(1 << 0)
+#define NIC_CFG_RSS_HASH_TYPE_TCP_IPV4		(1 << 1)
+#define NIC_CFG_RSS_HASH_TYPE_IPV6		(1 << 2)
+#define NIC_CFG_RSS_HASH_TYPE_TCP_IPV6		(1 << 3)
+#define NIC_CFG_RSS_HASH_TYPE_IPV6_EX		(1 << 4)
+#define NIC_CFG_RSS_HASH_TYPE_TCP_IPV6_EX	(1 << 5)
 
 static inline void vnic_set_nic_cfg(u32 *nic_cfg,
 	u8 rss_default_cpu, u8 rss_hash_type,
diff -r 15109ec2f661 drivers/net/enic/vnic_resource.h
--- b/drivers/net/enic/vnic_resource.h	Wed Aug 17 13:31:06 2011 +0100
+++ a/drivers/net/enic/vnic_resource.h	Wed Aug 17 13:09:17 2011 +0100
@@ -1,5 +1,5 @@
 /*
- * Copyright 2008-2010 Cisco Systems, Inc.  All rights reserved.
+ * Copyright 2008 Cisco Systems, Inc.  All rights reserved.
  * Copyright 2007 Nuova Systems, Inc.  All rights reserved.
  *
  * This program is free software; you may redistribute it and/or modify
@@ -22,11 +22,6 @@
 
 #define VNIC_RES_MAGIC		0x766E6963L	/* 'vnic' */
 #define VNIC_RES_VERSION	0x00000000L
-#define MGMTVNIC_MAGIC		0x544d474dL	/* 'MGMT' */
-#define MGMTVNIC_VERSION	0x00000000L
-
-/* The MAC address assigned to the CFG vNIC is fixed. */
-#define MGMTVNIC_MAC		{ 0x02, 0x00, 0x54, 0x4d, 0x47, 0x4d }
 
 /* vNIC resource types */
 enum vnic_res_type {
@@ -57,14 +52,6 @@
 	u32 version;
 };
 
-struct mgmt_barmap_hdr {
-	u32 magic;			/* magic number */
-	u32 version;			/* header format version */
-	u16 lif;			/* loopback lif for mgmt frames */
-	u16 pci_slot;			/* installed pci slot */
-	char serial[16];		/* card serial number */
-};
-
 struct vnic_resource {
 	u8 type;
 	u8 bar;
diff -r 15109ec2f661 drivers/net/enic/vnic_rq.c
--- b/drivers/net/enic/vnic_rq.c	Wed Aug 17 13:31:06 2011 +0100
+++ a/drivers/net/enic/vnic_rq.c	Wed Aug 17 13:09:17 2011 +0100
@@ -1,5 +1,5 @@
 /*
- * Copyright 2008-2010 Cisco Systems, Inc.  All rights reserved.
+ * Copyright 2008 Cisco Systems, Inc.  All rights reserved.
  * Copyright 2007 Nuova Systems, Inc.  All rights reserved.
  *
  * This program is free software; you may redistribute it and/or modify
@@ -22,7 +22,6 @@
 #include <linux/types.h>
 #include <linux/pci.h>
 #include <linux/delay.h>
-#include <linux/slab.h>
 
 #include "vnic_dev.h"
 #include "vnic_rq.h"
@@ -37,7 +36,7 @@
 	vdev = rq->vdev;
 
 	for (i = 0; i < blks; i++) {
-		rq->bufs[i] = kzalloc(VNIC_RQ_BUF_BLK_SZ(count), GFP_ATOMIC);
+		rq->bufs[i] = kzalloc(VNIC_RQ_BUF_BLK_SZ, GFP_ATOMIC);
 		if (!rq->bufs[i]) {
 			printk(KERN_ERR "Failed to alloc rq_bufs\n");
 			return -ENOMEM;
@@ -46,14 +45,14 @@
 
 	for (i = 0; i < blks; i++) {
 		buf = rq->bufs[i];
-		for (j = 0; j < VNIC_RQ_BUF_BLK_ENTRIES(count); j++) {
-			buf->index = i * VNIC_RQ_BUF_BLK_ENTRIES(count) + j;
+		for (j = 0; j < VNIC_RQ_BUF_BLK_ENTRIES; j++) {
+			buf->index = i * VNIC_RQ_BUF_BLK_ENTRIES + j;
 			buf->desc = (u8 *)rq->ring.descs +
 				rq->ring.desc_size * buf->index;
 			if (buf->index + 1 == count) {
 				buf->next = rq->bufs[0];
 				break;
-			} else if (j + 1 == VNIC_RQ_BUF_BLK_ENTRIES(count)) {
+			} else if (j + 1 == VNIC_RQ_BUF_BLK_ENTRIES) {
 				buf->next = rq->bufs[i + 1];
 			} else {
 				buf->next = buf + 1;
@@ -77,10 +76,8 @@
 	vnic_dev_free_desc_ring(vdev, &rq->ring);
 
 	for (i = 0; i < VNIC_RQ_BUF_BLKS_MAX; i++) {
-		if (rq->bufs[i]) {
-			kfree(rq->bufs[i]);
-			rq->bufs[i] = NULL;
-		}
+		kfree(rq->bufs[i]);
+		rq->bufs[i] = NULL;
 	}
 
 	rq->ctrl = NULL;
@@ -121,11 +118,10 @@
 	unsigned int error_interrupt_offset)
 {
 	u64 paddr;
-	unsigned int count = rq->ring.desc_count;
 
 	paddr = (u64)rq->ring.base_addr | VNIC_PADDR_TARGET;
 	writeq(paddr, &rq->ctrl->ring_base);
-	iowrite32(count, &rq->ctrl->ring_size);
+	iowrite32(rq->ring.desc_count, &rq->ctrl->ring_size);
 	iowrite32(cq_index, &rq->ctrl->cq_index);
 	iowrite32(error_interrupt_enable, &rq->ctrl->error_interrupt_enable);
 	iowrite32(error_interrupt_offset, &rq->ctrl->error_interrupt_offset);
@@ -135,8 +131,8 @@
 	iowrite32(posted_index, &rq->ctrl->posted_index);
 
 	rq->to_use = rq->to_clean =
-		&rq->bufs[fetch_index / VNIC_RQ_BUF_BLK_ENTRIES(count)]
-			[fetch_index % VNIC_RQ_BUF_BLK_ENTRIES(count)];
+		&rq->bufs[fetch_index / VNIC_RQ_BUF_BLK_ENTRIES]
+			[fetch_index % VNIC_RQ_BUF_BLK_ENTRIES];
 }
 
 void vnic_rq_init(struct vnic_rq *rq, unsigned int cq_index,
@@ -148,11 +144,6 @@
 	/* Use current fetch_index as the ring starting point */
 	fetch_index = ioread32(&rq->ctrl->fetch_index);
 
-	if (fetch_index == 0xFFFFFFFF) { /* check for hardware gone  */
-		/* Hardware surprise removal: reset fetch_index */
-		fetch_index = 0;
-	}
-
 	vnic_rq_init_start(rq, cq_index,
 		fetch_index, fetch_index,
 		error_interrupt_enable,
@@ -176,10 +167,10 @@
 	iowrite32(0, &rq->ctrl->enable);
 
 	/* Wait for HW to ACK disable request */
-	for (wait = 0; wait < 1000; wait++) {
+	for (wait = 0; wait < 100; wait++) {
 		if (!(ioread32(&rq->ctrl->running)))
 			return 0;
-		udelay(10);
+		udelay(1);
 	}
 
 	printk(KERN_ERR "Failed to disable RQ[%d]\n", rq->index);
@@ -192,7 +183,8 @@
 {
 	struct vnic_rq_buf *buf;
 	u32 fetch_index;
-	unsigned int count = rq->ring.desc_count;
+
+	BUG_ON(ioread32(&rq->ctrl->enable));
 
 	buf = rq->to_clean;
 
@@ -206,14 +198,9 @@
 
 	/* Use current fetch_index as the ring starting point */
 	fetch_index = ioread32(&rq->ctrl->fetch_index);
-
-	if (fetch_index == 0xFFFFFFFF) { /* check for hardware gone  */
-		/* Hardware surprise removal: reset fetch_index */
-		fetch_index = 0;
-	}
 	rq->to_use = rq->to_clean =
-		&rq->bufs[fetch_index / VNIC_RQ_BUF_BLK_ENTRIES(count)]
-			[fetch_index % VNIC_RQ_BUF_BLK_ENTRIES(count)];
+		&rq->bufs[fetch_index / VNIC_RQ_BUF_BLK_ENTRIES]
+			[fetch_index % VNIC_RQ_BUF_BLK_ENTRIES];
 	iowrite32(fetch_index, &rq->ctrl->posted_index);
 
 	vnic_dev_clear_desc_ring(&rq->ring);
diff -r 15109ec2f661 drivers/net/enic/vnic_rq.h
--- b/drivers/net/enic/vnic_rq.h	Wed Aug 17 13:31:06 2011 +0100
+++ a/drivers/net/enic/vnic_rq.h	Wed Aug 17 13:09:17 2011 +0100
@@ -1,5 +1,5 @@
 /*
- * Copyright 2008-2010 Cisco Systems, Inc.  All rights reserved.
+ * Copyright 2008, 2009 Cisco Systems, Inc.  All rights reserved.
  * Copyright 2007 Nuova Systems, Inc.  All rights reserved.
  *
  * This program is free software; you may redistribute it and/or modify
@@ -52,16 +52,12 @@
 	u32 pad10;
 };
 
-/* Break the vnic_rq_buf allocations into blocks of 32/64 entries */
-#define VNIC_RQ_BUF_MIN_BLK_ENTRIES 32
-#define VNIC_RQ_BUF_DFLT_BLK_ENTRIES 64
-#define VNIC_RQ_BUF_BLK_ENTRIES(entries) \
-	((unsigned int)((entries < VNIC_RQ_BUF_DFLT_BLK_ENTRIES) ? \
-	VNIC_RQ_BUF_MIN_BLK_ENTRIES : VNIC_RQ_BUF_DFLT_BLK_ENTRIES))
-#define VNIC_RQ_BUF_BLK_SZ(entries) \
-	(VNIC_RQ_BUF_BLK_ENTRIES(entries) * sizeof(struct vnic_rq_buf))
+/* Break the vnic_rq_buf allocations into blocks of 64 entries */
+#define VNIC_RQ_BUF_BLK_ENTRIES 64
+#define VNIC_RQ_BUF_BLK_SZ \
+	(VNIC_RQ_BUF_BLK_ENTRIES * sizeof(struct vnic_rq_buf))
 #define VNIC_RQ_BUF_BLKS_NEEDED(entries) \
-	DIV_ROUND_UP(entries, VNIC_RQ_BUF_BLK_ENTRIES(entries))
+	DIV_ROUND_UP(entries, VNIC_RQ_BUF_BLK_ENTRIES)
 #define VNIC_RQ_BUF_BLKS_MAX VNIC_RQ_BUF_BLKS_NEEDED(4096)
 
 struct vnic_rq_buf {
diff -r 15109ec2f661 drivers/net/enic/vnic_rss.h
--- b/drivers/net/enic/vnic_rss.h	Wed Aug 17 13:31:06 2011 +0100
+++ a/drivers/net/enic/vnic_rss.h	Wed Aug 17 13:09:17 2011 +0100
@@ -1,5 +1,5 @@
 /*
- * Copyright 2008-2010 Cisco Systems, Inc.  All rights reserved.
+ * Copyright 2008 Cisco Systems, Inc.  All rights reserved.
  * Copyright 2007 Nuova Systems, Inc.  All rights reserved.
  *
  * This program is free software; you may redistribute it and/or modify
diff -r 15109ec2f661 drivers/net/enic/vnic_stats.h
--- b/drivers/net/enic/vnic_stats.h	Wed Aug 17 13:31:06 2011 +0100
+++ a/drivers/net/enic/vnic_stats.h	Wed Aug 17 13:09:17 2011 +0100
@@ -1,5 +1,5 @@
 /*
- * Copyright 2008-2010 Cisco Systems, Inc.  All rights reserved.
+ * Copyright 2008 Cisco Systems, Inc.  All rights reserved.
  * Copyright 2007 Nuova Systems, Inc.  All rights reserved.
  *
  * This program is free software; you may redistribute it and/or modify
diff -r 15109ec2f661 drivers/net/enic/vnic_wq.c
--- b/drivers/net/enic/vnic_wq.c	Wed Aug 17 13:31:06 2011 +0100
+++ a/drivers/net/enic/vnic_wq.c	Wed Aug 17 13:09:17 2011 +0100
@@ -1,5 +1,5 @@
 /*
- * Copyright 2008-2010 Cisco Systems, Inc.  All rights reserved.
+ * Copyright 2008 Cisco Systems, Inc.  All rights reserved.
  * Copyright 2007 Nuova Systems, Inc.  All rights reserved.
  *
  * This program is free software; you may redistribute it and/or modify
@@ -22,7 +22,6 @@
 #include <linux/types.h>
 #include <linux/pci.h>
 #include <linux/delay.h>
-#include <linux/slab.h>
 
 #include "vnic_dev.h"
 #include "vnic_wq.h"
@@ -37,7 +36,7 @@
 	vdev = wq->vdev;
 
 	for (i = 0; i < blks; i++) {
-		wq->bufs[i] = kzalloc(VNIC_WQ_BUF_BLK_SZ(count), GFP_ATOMIC);
+		wq->bufs[i] = kzalloc(VNIC_WQ_BUF_BLK_SZ, GFP_ATOMIC);
 		if (!wq->bufs[i]) {
 			printk(KERN_ERR "Failed to alloc wq_bufs\n");
 			return -ENOMEM;
@@ -46,14 +45,14 @@
 
 	for (i = 0; i < blks; i++) {
 		buf = wq->bufs[i];
-		for (j = 0; j < VNIC_WQ_BUF_BLK_ENTRIES(count); j++) {
-			buf->index = i * VNIC_WQ_BUF_BLK_ENTRIES(count) + j;
+		for (j = 0; j < VNIC_WQ_BUF_BLK_ENTRIES; j++) {
+			buf->index = i * VNIC_WQ_BUF_BLK_ENTRIES + j;
 			buf->desc = (u8 *)wq->ring.descs +
 				wq->ring.desc_size * buf->index;
 			if (buf->index + 1 == count) {
 				buf->next = wq->bufs[0];
 				break;
-			} else if (j + 1 == VNIC_WQ_BUF_BLK_ENTRIES(count)) {
+			} else if (j + 1 == VNIC_WQ_BUF_BLK_ENTRIES) {
 				buf->next = wq->bufs[i + 1];
 			} else {
 				buf->next = buf + 1;
@@ -77,10 +76,8 @@
 	vnic_dev_free_desc_ring(vdev, &wq->ring);
 
 	for (i = 0; i < VNIC_WQ_BUF_BLKS_MAX; i++) {
-		if (wq->bufs[i]) {
-			kfree(wq->bufs[i]);
-			wq->bufs[i] = NULL;
-		}
+		kfree(wq->bufs[i]);
+		wq->bufs[i] = NULL;
 	}
 
 	wq->ctrl = NULL;
@@ -121,11 +118,10 @@
 	unsigned int error_interrupt_offset)
 {
 	u64 paddr;
-	unsigned int count = wq->ring.desc_count;
 
 	paddr = (u64)wq->ring.base_addr | VNIC_PADDR_TARGET;
 	writeq(paddr, &wq->ctrl->ring_base);
-	iowrite32(count, &wq->ctrl->ring_size);
+	iowrite32(wq->ring.desc_count, &wq->ctrl->ring_size);
 	iowrite32(fetch_index, &wq->ctrl->fetch_index);
 	iowrite32(posted_index, &wq->ctrl->posted_index);
 	iowrite32(cq_index, &wq->ctrl->cq_index);
@@ -134,8 +130,8 @@
 	iowrite32(0, &wq->ctrl->error_status);
 
 	wq->to_use = wq->to_clean =
-		&wq->bufs[fetch_index / VNIC_WQ_BUF_BLK_ENTRIES(count)]
-			[fetch_index % VNIC_WQ_BUF_BLK_ENTRIES(count)];
+		&wq->bufs[fetch_index / VNIC_WQ_BUF_BLK_ENTRIES]
+			[fetch_index % VNIC_WQ_BUF_BLK_ENTRIES];
 }
 
 void vnic_wq_init(struct vnic_wq *wq, unsigned int cq_index,
@@ -164,10 +160,10 @@
 	iowrite32(0, &wq->ctrl->enable);
 
 	/* Wait for HW to ACK disable request */
-	for (wait = 0; wait < 1000; wait++) {
+	for (wait = 0; wait < 100; wait++) {
 		if (!(ioread32(&wq->ctrl->running)))
 			return 0;
-		udelay(10);
+		udelay(1);
 	}
 
 	printk(KERN_ERR "Failed to disable WQ[%d]\n", wq->index);
@@ -180,6 +176,8 @@
 {
 	struct vnic_wq_buf *buf;
 
+	BUG_ON(ioread32(&wq->ctrl->enable));
+
 	buf = wq->to_clean;
 
 	while (vnic_wq_desc_used(wq) > 0) {
diff -r 15109ec2f661 drivers/net/enic/vnic_wq.h
--- b/drivers/net/enic/vnic_wq.h	Wed Aug 17 13:31:06 2011 +0100
+++ a/drivers/net/enic/vnic_wq.h	Wed Aug 17 13:09:17 2011 +0100
@@ -1,5 +1,5 @@
 /*
- * Copyright 2008-2010 Cisco Systems, Inc.  All rights reserved.
+ * Copyright 2008 Cisco Systems, Inc.  All rights reserved.
  * Copyright 2007 Nuova Systems, Inc.  All rights reserved.
  *
  * This program is free software; you may redistribute it and/or modify
@@ -60,16 +60,12 @@
 	void *desc;
 };
 
-/* Break the vnic_wq_buf allocations into blocks of 32/64 entries */
-#define VNIC_WQ_BUF_MIN_BLK_ENTRIES 32
-#define VNIC_WQ_BUF_DFLT_BLK_ENTRIES 64
-#define VNIC_WQ_BUF_BLK_ENTRIES(entries) \
-	((unsigned int)((entries < VNIC_WQ_BUF_DFLT_BLK_ENTRIES) ? \
-	VNIC_WQ_BUF_MIN_BLK_ENTRIES : VNIC_WQ_BUF_DFLT_BLK_ENTRIES))
-#define VNIC_WQ_BUF_BLK_SZ(entries) \
-	(VNIC_WQ_BUF_BLK_ENTRIES(entries) * sizeof(struct vnic_wq_buf))
+/* Break the vnic_wq_buf allocations into blocks of 64 entries */
+#define VNIC_WQ_BUF_BLK_ENTRIES 64
+#define VNIC_WQ_BUF_BLK_SZ \
+	(VNIC_WQ_BUF_BLK_ENTRIES * sizeof(struct vnic_wq_buf))
 #define VNIC_WQ_BUF_BLKS_NEEDED(entries) \
-	DIV_ROUND_UP(entries, VNIC_WQ_BUF_BLK_ENTRIES(entries))
+	DIV_ROUND_UP(entries, VNIC_WQ_BUF_BLK_ENTRIES)
 #define VNIC_WQ_BUF_BLKS_MAX VNIC_WQ_BUF_BLKS_NEEDED(4096)
 
 struct vnic_wq {
diff -r 15109ec2f661 drivers/net/enic/wq_enet_desc.h
--- b/drivers/net/enic/wq_enet_desc.h	Wed Aug 17 13:31:06 2011 +0100
+++ a/drivers/net/enic/wq_enet_desc.h	Wed Aug 17 13:09:17 2011 +0100
@@ -1,5 +1,5 @@
 /*
- * Copyright 2008-2010 Cisco Systems, Inc.  All rights reserved.
+ * Copyright 2008 Cisco Systems, Inc.  All rights reserved.
  * Copyright 2007 Nuova Systems, Inc.  All rights reserved.
  *
  * This program is free software; you may redistribute it and/or modify
diff -r 15109ec2f661 drivers/net/igb/e1000_82575.c
--- b/drivers/net/igb/e1000_82575.c	Wed Aug 17 13:31:06 2011 +0100
+++ a/drivers/net/igb/e1000_82575.c	Wed Aug 17 13:09:17 2011 +0100
@@ -1245,18 +1245,9 @@
 {
 	s32 ret_val = 0;
 
-	/*
-	 * If there's an alternate MAC address place it in RAR0
-	 * so that it will override the Si installed default perm
-	 * address.
-	 */
-	ret_val = igb_check_alt_mac_addr(hw);
-	if (ret_val)
-		goto out;
+	if (igb_check_alt_mac_addr(hw))
+		ret_val = igb_read_mac_addr(hw);
 
-	ret_val = igb_read_mac_addr(hw);
-
-out:
 	return ret_val;
 }
 
diff -r 15109ec2f661 drivers/net/igb/e1000_hw.h
--- b/drivers/net/igb/e1000_hw.h	Wed Aug 17 13:31:06 2011 +0100
+++ a/drivers/net/igb/e1000_hw.h	Wed Aug 17 13:09:17 2011 +0100
@@ -58,6 +58,7 @@
 #define E1000_DEV_ID_I350_SERDES              0x1523
 #define E1000_DEV_ID_I350_SGMII               0x1524
 
+
 #define E1000_REVISION_2 2
 #define E1000_REVISION_4 4
 
diff -r 15109ec2f661 drivers/net/igb/e1000_mac.c
--- b/drivers/net/igb/e1000_mac.c	Wed Aug 17 13:31:06 2011 +0100
+++ a/drivers/net/igb/e1000_mac.c	Wed Aug 17 13:09:17 2011 +0100
@@ -185,12 +185,13 @@
 	}
 
 	if (nvm_alt_mac_addr_offset == 0xFFFF) {
-		/* There is no Alternate MAC Address */
+		ret_val = -(E1000_NOT_IMPLEMENTED);
 		goto out;
 	}
 
 	if (hw->bus.func == E1000_FUNC_1)
-		nvm_alt_mac_addr_offset += E1000_ALT_MAC_ADDRESS_OFFSET_LAN1;
+		nvm_alt_mac_addr_offset += ETH_ALEN/sizeof(u16);
+
 	for (i = 0; i < ETH_ALEN; i += 2) {
 		offset = nvm_alt_mac_addr_offset + (i >> 1);
 		ret_val = hw->nvm.ops.read(hw, offset, 1, &nvm_data);
@@ -205,16 +206,14 @@
 
 	/* if multicast bit is set, the alternate address will not be used */
 	if (alt_mac_addr[0] & 0x01) {
-		hw_dbg("Ignoring Alternate Mac Address with MC bit set\n");
+		ret_val = -(E1000_NOT_IMPLEMENTED);
 		goto out;
 	}
 
-	/*
-	 * We have a valid alternate MAC address, and we want to treat it the
-	 * same as the normal permanent MAC address stored by the HW into the
-	 * RAR. Do this by mapping this address into RAR0.
-	 */
-	hw->mac.ops.rar_set(hw, alt_mac_addr, 0);
+	for (i = 0; i < ETH_ALEN; i++)
+		hw->mac.addr[i] = hw->mac.perm_addr[i] = alt_mac_addr[i];
+
+	hw->mac.ops.rar_set(hw, hw->mac.perm_addr, 0);
 
 out:
 	return ret_val;
diff -r 15109ec2f661 drivers/net/igb/igb.h
--- b/drivers/net/igb/igb.h	Wed Aug 17 13:31:06 2011 +0100
+++ a/drivers/net/igb/igb.h	Wed Aug 17 13:09:17 2011 +0100
@@ -130,13 +130,12 @@
 			unsigned long time_stamp;
 			u16 length;
 			u16 next_to_watch;
-			u16 mapped_as_page;
 		};
 		/* RX */
 		struct {
 			struct page *page;
-			dma_addr_t page_dma;
-			u16 page_offset;
+			u64 page_dma;
+			unsigned int page_offset;
 		};
 	};
 };
diff -r 15109ec2f661 drivers/net/igb/igb_main.c
--- b/drivers/net/igb/igb_main.c	Wed Aug 17 13:31:06 2011 +0100
+++ a/drivers/net/igb/igb_main.c	Wed Aug 17 13:09:17 2011 +0100
@@ -2617,27 +2617,15 @@
 static void igb_unmap_and_free_tx_resource(struct igb_adapter *adapter,
 					   struct igb_buffer *buffer_info)
 {
-	if (buffer_info->dma) {
-		if (buffer_info->mapped_as_page)
-			pci_unmap_page(adapter->pdev,
-					buffer_info->dma,
-					buffer_info->length,
-					PCI_DMA_TODEVICE);
-		else
-			pci_unmap_single(adapter->pdev,
-					buffer_info->dma,
-					buffer_info->length,
-					PCI_DMA_TODEVICE);
-		buffer_info->dma = 0;
-	}
+	buffer_info->dma = 0;
 	if (buffer_info->skb) {
+		skb_dma_unmap(&adapter->pdev->dev, buffer_info->skb,
+		              DMA_TO_DEVICE);
 		dev_kfree_skb_any(buffer_info->skb);
 		buffer_info->skb = NULL;
 	}
 	buffer_info->time_stamp = 0;
-	buffer_info->length = 0;
-	buffer_info->next_to_watch = 0;
-	buffer_info->mapped_as_page = false;
+	/* buffer_info must be completely set up in the transmit path */
 }
 
 /**
@@ -3479,19 +3467,24 @@
 	unsigned int len = skb_headlen(skb);
 	unsigned int count = 0, i;
 	unsigned int f;
+	dma_addr_t *map;
 
 	i = tx_ring->next_to_use;
 
+	if (skb_dma_map(&adapter->pdev->dev, skb, DMA_TO_DEVICE)) {
+		dev_err(&adapter->pdev->dev, "TX DMA map failed\n");
+		return 0;
+	}
+
+	map = skb_shinfo(skb)->dma_maps;
+
 	buffer_info = &tx_ring->buffer_info[i];
 	BUG_ON(len >= IGB_MAX_DATA_PER_TXD);
 	buffer_info->length = len;
 	/* set time_stamp *before* dma to help avoid a possible race */
 	buffer_info->time_stamp = jiffies;
 	buffer_info->next_to_watch = i;
-	buffer_info->dma = pci_map_single(adapter->pdev, skb->data, len,
-					  PCI_DMA_TODEVICE);
-	if (pci_dma_mapping_error(adapter->pdev, buffer_info->dma))
-		goto dma_error;
+	buffer_info->dma = skb_shinfo(skb)->dma_head;
 
 	for (f = 0; f < skb_shinfo(skb)->nr_frags; f++) {
 		struct skb_frag_struct *frag;
@@ -3508,15 +3501,7 @@
 		buffer_info->length = len;
 		buffer_info->time_stamp = jiffies;
 		buffer_info->next_to_watch = i;
-		buffer_info->mapped_as_page = true;
-		buffer_info->dma = pci_map_page(adapter->pdev,
-						frag->page,
-						frag->page_offset,
-						len,
-						PCI_DMA_TODEVICE);
-		if (pci_dma_mapping_error(adapter->pdev, buffer_info->dma))
-			goto dma_error;
-
+		buffer_info->dma = map[count];
 		count++;
 	}
 
@@ -3524,29 +3509,6 @@
 	tx_ring->buffer_info[first].next_to_watch = i;
 
 	return count + 1;
-
-dma_error:
-	dev_err(&adapter->pdev->dev, "TX DMA map failed\n");
-
-	/* clear timestamp and dma mappings for failed buffer_info mapping */
-	buffer_info->dma = 0;
-	buffer_info->time_stamp = 0;
-	buffer_info->length = 0;
-	buffer_info->next_to_watch = 0;
-	buffer_info->mapped_as_page = false;
-	count--;
-
-	/* clear timestamp and dma mappings for remaining portion of packet */
-	while (count >= 0) {
-		count--;
-		i--;
-		if (i < 0)
-			i += tx_ring->count;
-		buffer_info = &tx_ring->buffer_info[i];
-		igb_unmap_and_free_tx_resource(adapter, buffer_info);
-	}
-
-	return 0;
 }
 
 static inline void igb_tx_queue_adv(struct igb_adapter *adapter,
@@ -4863,7 +4825,7 @@
 {
 	struct igb_adapter *adapter = q_vector->adapter;
 
-	if (vlan_tag && adapter->vlgrp)
+	if (vlan_tag)
 		vlan_gro_receive(&q_vector->napi, adapter->vlgrp,
 		                 vlan_tag, skb);
 	else
@@ -4950,6 +4912,7 @@
 	struct igb_adapter *adapter = q_vector->adapter;
 	struct net_device *netdev = adapter->netdev;
 	struct igb_ring *rx_ring = q_vector->rx_ring;
+	struct e1000_hw *hw = &adapter->hw;
 	struct pci_dev *pdev = adapter->pdev;
 	union e1000_adv_rx_desc *rx_desc , *next_rxd;
 	struct igb_buffer *buffer_info , *next_buffer;
diff -r 15109ec2f661 drivers/net/ixgbe/ixgbe_82599.c
--- b/drivers/net/ixgbe/ixgbe_82599.c	Wed Aug 17 13:31:06 2011 +0100
+++ a/drivers/net/ixgbe/ixgbe_82599.c	Wed Aug 17 13:09:17 2011 +0100
@@ -92,8 +92,6 @@
 static s32 ixgbe_setup_sfp_modules_82599(struct ixgbe_hw *hw)
 {
 	s32 ret_val = 0;
-	u32 reg_anlp1 = 0;
-	u32 i = 0;
 	u16 list_offset, data_offset, data_value;
 
 	if (hw->phy.sfp_type != ixgbe_sfp_type_unknown) {
@@ -120,34 +118,14 @@
 			IXGBE_WRITE_FLUSH(hw);
 			hw->eeprom.ops.read(hw, ++data_offset, &data_value);
 		}
+		/* Now restart DSP by setting Restart_AN */
+		IXGBE_WRITE_REG(hw, IXGBE_AUTOC,
+		    (IXGBE_READ_REG(hw, IXGBE_AUTOC) | IXGBE_AUTOC_AN_RESTART));
 
 		/* Release the semaphore */
 		ixgbe_release_swfw_sync(hw, IXGBE_GSSR_MAC_CSR_SM);
 		/* Delay obtaining semaphore again to allow FW access */
 		msleep(hw->eeprom.semaphore_delay);
-
-		/* Now restart DSP by setting Restart_AN and clearing LMS */
-		IXGBE_WRITE_REG(hw, IXGBE_AUTOC, ((IXGBE_READ_REG(hw,
-		                IXGBE_AUTOC) & ~IXGBE_AUTOC_LMS_MASK) |
-		                IXGBE_AUTOC_AN_RESTART));
-
-		/* Wait for AN to leave state 0 */
-		for (i = 0; i < 10; i++) {
-			msleep(4);
-			reg_anlp1 = IXGBE_READ_REG(hw, IXGBE_ANLP1);
-			if (reg_anlp1 & IXGBE_ANLP1_AN_STATE_MASK)
-				break;
-		}
-		if (!(reg_anlp1 & IXGBE_ANLP1_AN_STATE_MASK)) {
-			hw_dbg(hw, "sfp module setup not complete\n");
-			ret_val = IXGBE_ERR_SFP_SETUP_NOT_COMPLETE;
-			goto setup_sfp_out;
-		}
-
-		/* Restart DSP by setting Restart_AN and return to SFI mode */
-		IXGBE_WRITE_REG(hw, IXGBE_AUTOC, (IXGBE_READ_REG(hw,
-		                IXGBE_AUTOC) | IXGBE_AUTOC_LMS_10G_SERIAL |
-		                IXGBE_AUTOC_AN_RESTART));
 	}
 
 setup_sfp_out:
@@ -248,14 +226,6 @@
 	s32 status = 0;
 	u32 autoc = 0;
 
-	/* Determine 1G link capabilities off of SFP+ type */
-	if (hw->phy.sfp_type == ixgbe_sfp_type_1g_cu_core0 ||
-	    hw->phy.sfp_type == ixgbe_sfp_type_1g_cu_core1) {
-		*speed = IXGBE_LINK_SPEED_1GB_FULL;
-		*negotiation = true;
-		goto out;
-	}
-
 	/*
 	 * Determine link capabilities based on the stored value of AUTOC,
 	 * which represents EEPROM defaults.  If AUTOC value has not been
@@ -2345,7 +2315,6 @@
 	u32 pma_pmd_1g = autoc & IXGBE_AUTOC_1G_PMA_PMD_MASK;
 	u16 ext_ability = 0;
 	u8 comp_codes_10g = 0;
-	u8 comp_codes_1g = 0;
 
 	hw->phy.ops.identify(hw);
 
@@ -2413,28 +2382,20 @@
 		goto out;
 
 	switch (hw->phy.type) {
-	case ixgbe_phy_sfp_passive_tyco:
-	case ixgbe_phy_sfp_passive_unknown:
+	case ixgbe_phy_tw_tyco:
+	case ixgbe_phy_tw_unknown:
 		physical_layer = IXGBE_PHYSICAL_LAYER_SFP_PLUS_CU;
 		break;
-	case ixgbe_phy_sfp_ftl_active:
-	case ixgbe_phy_sfp_active_unknown:
-		physical_layer = IXGBE_PHYSICAL_LAYER_SFP_ACTIVE_DA;
-		break;
 	case ixgbe_phy_sfp_avago:
 	case ixgbe_phy_sfp_ftl:
 	case ixgbe_phy_sfp_intel:
 	case ixgbe_phy_sfp_unknown:
 		hw->phy.ops.read_i2c_eeprom(hw,
-		      IXGBE_SFF_1GBE_COMP_CODES, &comp_codes_1g);
-		hw->phy.ops.read_i2c_eeprom(hw,
 		      IXGBE_SFF_10GBE_COMP_CODES, &comp_codes_10g);
 		if (comp_codes_10g & IXGBE_SFF_10GBASESR_CAPABLE)
 			physical_layer = IXGBE_PHYSICAL_LAYER_10GBASE_SR;
 		else if (comp_codes_10g & IXGBE_SFF_10GBASELR_CAPABLE)
 			physical_layer = IXGBE_PHYSICAL_LAYER_10GBASE_LR;
-		else if (comp_codes_1g & IXGBE_SFF_1GBASET_CAPABLE)
-			physical_layer = IXGBE_PHYSICAL_LAYER_1000BASE_T;
 		break;
 	default:
 		break;
diff -r 15109ec2f661 drivers/net/ixgbe/ixgbe_dcb_nl.c
--- b/drivers/net/ixgbe/ixgbe_dcb_nl.c	Wed Aug 17 13:31:06 2011 +0100
+++ a/drivers/net/ixgbe/ixgbe_dcb_nl.c	Wed Aug 17 13:09:17 2011 +0100
@@ -341,12 +341,6 @@
 	if (!adapter->dcb_set_bitmap)
 		return DCB_NO_HW_CHG;
 
-	ret = ixgbe_copy_dcb_cfg(&adapter->temp_dcb_cfg, &adapter->dcb_cfg,
-				 adapter->ring_feature[RING_F_DCB].indices);
-
-	if (ret)
-		return DCB_NO_HW_CHG;
-
 	/*
 	 * Only take down the adapter if the configuration change
 	 * requires a reset.
@@ -365,6 +359,14 @@
 		}
 	}
 
+	ret = ixgbe_copy_dcb_cfg(&adapter->temp_dcb_cfg, &adapter->dcb_cfg,
+				 adapter->ring_feature[RING_F_DCB].indices);
+	if (ret) {
+		if (adapter->dcb_set_bitmap & BIT_RESETLINK)
+			clear_bit(__IXGBE_RESETTING, &adapter->state);
+		return DCB_NO_HW_CHG;
+	}
+
 	if (adapter->dcb_cfg.pfc_mode_enable) {
 		if ((adapter->hw.mac.type != ixgbe_mac_82598EB) &&
 			(adapter->hw.fc.current_mode != ixgbe_fc_pfc))
diff -r 15109ec2f661 drivers/net/ixgbe/ixgbe_ethtool.c
--- b/drivers/net/ixgbe/ixgbe_ethtool.c	Wed Aug 17 13:31:06 2011 +0100
+++ a/drivers/net/ixgbe/ixgbe_ethtool.c	Wed Aug 17 13:09:17 2011 +0100
@@ -211,8 +211,8 @@
 		ecmd->port = PORT_FIBRE;
 		break;
 	case ixgbe_phy_nl:
-	case ixgbe_phy_sfp_passive_tyco:
-	case ixgbe_phy_sfp_passive_unknown:
+	case ixgbe_phy_tw_tyco:
+	case ixgbe_phy_tw_unknown:
 	case ixgbe_phy_sfp_ftl:
 	case ixgbe_phy_sfp_avago:
 	case ixgbe_phy_sfp_intel:
@@ -233,13 +233,6 @@
 		case ixgbe_sfp_type_not_present:
 			ecmd->port = PORT_NONE;
 			break;
-		case ixgbe_sfp_type_1g_cu_core0:
-		case ixgbe_sfp_type_1g_cu_core1:
-			ecmd->port = PORT_TP;
-			ecmd->supported = SUPPORTED_TP;
-			ecmd->advertising = (ADVERTISED_1000baseT_Full |
-			                     ADVERTISED_TP);
-			break;
 		case ixgbe_sfp_type_unknown:
 		default:
 			ecmd->port = PORT_OTHER;
@@ -2046,48 +2039,12 @@
 	return 0;
 }
 
-/*
- * this function must be called before setting the new value of
- * rx_itr_setting
- */
-static bool ixgbe_update_rsc(struct ixgbe_adapter *adapter,
-			     struct ethtool_coalesce *ec)
-{
-	struct net_device *netdev = adapter->netdev;
-
-	if (!(adapter->flags2 & IXGBE_FLAG2_RSC_CAPABLE))
-		return false;
-
-	/* if interrupt rate is too high then disable RSC */
-	if (ec->rx_coalesce_usecs != 1 &&
-	    ec->rx_coalesce_usecs <= 1000000/IXGBE_MAX_RSC_INT_RATE) {
-		if (adapter->flags2 & IXGBE_FLAG2_RSC_ENABLED) {
-			DPRINTK(PROBE, INFO, "rx-usecs set too low, "
-				      "disabling RSC\n");
-			adapter->flags2 &= ~IXGBE_FLAG2_RSC_ENABLED;
-			return true;
-		}
-	} else {
-		/* check the feature flag value and enable RSC if necessary */
-		if ((netdev->features & NETIF_F_LRO) &&
-		    !(adapter->flags2 & IXGBE_FLAG2_RSC_ENABLED)) {
-			DPRINTK(PROBE, INFO,  "rx-usecs set to %d, "
-				      "re-enabling RSC\n",
-			       ec->rx_coalesce_usecs);
-			adapter->flags2 |= IXGBE_FLAG2_RSC_ENABLED;
-			return true;
-		}
-	}
-	return false;
-}
-
 static int ixgbe_set_coalesce(struct net_device *netdev,
                               struct ethtool_coalesce *ec)
 {
 	struct ixgbe_adapter *adapter = netdev_priv(netdev);
 	struct ixgbe_q_vector *q_vector;
 	int i;
-	bool need_reset = false;
 
 	/* don't accept tx specific changes if we've got mixed RxTx vectors */
 	if (adapter->q_vector[0]->txr_count && adapter->q_vector[0]->rxr_count
@@ -2103,9 +2060,6 @@
 		    (1000000/ec->rx_coalesce_usecs < IXGBE_MIN_INT_RATE))
 			return -EINVAL;
 
-		/* check the old value and enable RSC if necessary */
-		need_reset = ixgbe_update_rsc(adapter, ec);
-
 		/* store the value in ints/second */
 		adapter->rx_eitr_param = 1000000/ec->rx_coalesce_usecs;
 
@@ -2114,28 +2068,22 @@
 		/* clear the lower bit as its used for dynamic state */
 		adapter->rx_itr_setting &= ~1;
 	} else if (ec->rx_coalesce_usecs == 1) {
-		/* check the old value and enable RSC if necessary */
-		need_reset = ixgbe_update_rsc(adapter, ec);
-
 		/* 1 means dynamic mode */
 		adapter->rx_eitr_param = 20000;
 		adapter->rx_itr_setting = 1;
 	} else {
-		/* check the old value and enable RSC if necessary */
-		need_reset = ixgbe_update_rsc(adapter, ec);
 		/*
 		 * any other value means disable eitr, which is best
 		 * served by setting the interrupt rate very high
 		 */
-		adapter->rx_eitr_param = IXGBE_MAX_INT_RATE;
+		if (adapter->flags2 & IXGBE_FLAG2_RSC_ENABLED)
+			adapter->rx_eitr_param = IXGBE_MAX_RSC_INT_RATE;
+		else
+			adapter->rx_eitr_param = IXGBE_MAX_INT_RATE;
 		adapter->rx_itr_setting = 0;
 	}
 
 	if (ec->tx_coalesce_usecs > 1) {
-		/*
-		 * don't have to worry about max_int as above because
-		 * tx vectors don't do hardware RSC (an rx function)
-		 */
 		/* check the limits */
 		if ((1000000/ec->tx_coalesce_usecs > IXGBE_MAX_INT_RATE) ||
 		    (1000000/ec->tx_coalesce_usecs < IXGBE_MIN_INT_RATE))
@@ -2179,25 +2127,12 @@
 		ixgbe_write_eitr(q_vector);
 	}
 
-	/*
-	 * do reset here at the end to make sure EITR==0 case is handled
-	 * correctly w.r.t stopping tx, and changing TXDCTL.WTHRESH settings
-	 * also locks in RSC enable/disable which requires reset
-	 */
-	if (need_reset) {
-		if (netif_running(netdev))
-			ixgbe_reinit_locked(adapter);
-		else
-			ixgbe_reset(adapter);
-	}
-
 	return 0;
 }
 
 static int ixgbe_set_flags(struct net_device *netdev, u32 data)
 {
 	struct ixgbe_adapter *adapter = netdev_priv(netdev);
-	bool need_reset = false;
 
 	ethtool_op_set_flags(netdev, data);
 
@@ -2205,34 +2140,16 @@
 		return 0;
 
 	/* if state changes we need to update adapter->flags and reset */
-	if ((adapter->flags2 & IXGBE_FLAG2_RSC_CAPABLE) &&
-	    (!!(data & ETH_FLAG_LRO) !=
-	     !!(adapter->flags2 & IXGBE_FLAG2_RSC_ENABLED))) {
-		if ((data & ETH_FLAG_LRO) &&
-		    (!adapter->rx_itr_setting ||
-		     (adapter->rx_itr_setting > IXGBE_MAX_RSC_INT_RATE))) {
-			DPRINTK(PROBE, INFO, "rx-usecs set too low, "
-				      "not enabling RSC.\n");
-		} else {
-			adapter->flags2 ^= IXGBE_FLAG2_RSC_ENABLED;
-			switch (adapter->hw.mac.type) {
-			case ixgbe_mac_82599EB:
-				need_reset = true;
-				break;
-			default:
-				break;
-			}
-		}
-	}
-
-	if (need_reset) {
+	if ((!!(data & ETH_FLAG_LRO)) != 
+	    (!!(adapter->flags2 & IXGBE_FLAG2_RSC_ENABLED))) {
+		adapter->flags2 ^= IXGBE_FLAG2_RSC_ENABLED;
 		if (netif_running(netdev))
 			ixgbe_reinit_locked(adapter);
 		else
 			ixgbe_reset(adapter);
 	}
-
 	return 0;
+
 }
 
 static const struct ethtool_ops ixgbe_ethtool_ops = {
diff -r 15109ec2f661 drivers/net/ixgbe/ixgbe_fcoe.c
--- b/drivers/net/ixgbe/ixgbe_fcoe.c	Wed Aug 17 13:31:06 2011 +0100
+++ a/drivers/net/ixgbe/ixgbe_fcoe.c	Wed Aug 17 13:09:17 2011 +0100
@@ -31,7 +31,6 @@
 #include "ixgbe_dcb_82599.h"
 #endif /* CONFIG_IXGBE_DCB */
 #include <linux/if_ether.h>
-#include <linux/if_vlan.h>
 #include <scsi/scsi_cmnd.h>
 #include <scsi/scsi_device.h>
 #include <scsi/fc/fc_fs.h>
@@ -68,7 +67,7 @@
 static inline void ixgbe_fcoe_clear_ddp(struct ixgbe_fcoe_ddp *ddp)
 {
 	ddp->len = 0;
-	ddp->err = 1;
+	ddp->err = 0;
 	ddp->udl = NULL;
 	ddp->udp = 0UL;
 	ddp->sgl = NULL;
@@ -92,7 +91,6 @@
 	struct ixgbe_fcoe *fcoe;
 	struct ixgbe_adapter *adapter;
 	struct ixgbe_fcoe_ddp *ddp;
-	u32 fcbuff;
 
 	if (!netdev)
 		goto out_ddp_put;
@@ -116,14 +114,7 @@
 		IXGBE_WRITE_REG(&adapter->hw, IXGBE_FCBUFF, 0);
 		IXGBE_WRITE_REG(&adapter->hw, IXGBE_FCDMARW,
 				(xid | IXGBE_FCDMARW_WE));
-
-		/* guaranteed to be invalidated after 100us */
-		IXGBE_WRITE_REG(&adapter->hw, IXGBE_FCDMARW,
-				(xid | IXGBE_FCDMARW_RE));
-		fcbuff = IXGBE_READ_REG(&adapter->hw, IXGBE_FCBUFF);
 		spin_unlock_bh(&fcoe->lock);
-		if (fcbuff & IXGBE_FCBUFF_VALID)
-			udelay(100);
 	}
 	if (ddp->sgl)
 		pci_unmap_sg(adapter->pdev, ddp->sgl, ddp->sgc,
@@ -159,7 +150,7 @@
 	struct scatterlist *sg;
 	unsigned int i, j, dmacount;
 	unsigned int len;
-	static const unsigned int bufflen = IXGBE_FCBUFF_MIN;
+	static const unsigned int bufflen = 4096;
 	unsigned int firstoff = 0;
 	unsigned int lastsize;
 	unsigned int thisoff = 0;
@@ -176,11 +167,6 @@
 		return 0;
 	}
 
-	/* no DDP if we are already down or resetting */
-	if (test_bit(__IXGBE_DOWN, &adapter->state) ||
-	    test_bit(__IXGBE_RESETTING, &adapter->state))
-		return 0;
-
 	fcoe = &adapter->fcoe;
 	if (!fcoe->pool) {
 		DPRINTK(DRV, WARNING, "xid=0x%x no ddp pool for fcoe\n", xid);
@@ -203,7 +189,7 @@
 	}
 
 	/* alloc the udl from our ddp pool */
-	ddp->udl = pci_pool_alloc(fcoe->pool, GFP_ATOMIC, &ddp->udp);
+	ddp->udl = pci_pool_alloc(fcoe->pool, GFP_KERNEL, &ddp->udp);
 	if (!ddp->udl) {
 		DPRINTK(DRV, ERR, "failed allocated ddp context\n");
 		goto out_noddp_unmap;
@@ -253,24 +239,6 @@
 	/* only the last buffer may have non-full bufflen */
 	lastsize = thisoff + thislen;
 
-	/*
-	 * lastsize can not be buffer len.
-	 * If it is then adding another buffer with lastsize = 1.
-	 */
-	if (lastsize == bufflen) {
-		if (j >= IXGBE_BUFFCNT_MAX) {
-			DPRINTK(DRV, ERR, "xid=%x:%d,%d,%d:addr=%llx "
-				"not enough user buffers. We need an extra "
-				"buffer because lastsize is bufflen.\n",
-				xid, i, j, dmacount, (u64)addr);
-			goto out_noddp_free;
-		}
-
-		ddp->udl[j] = (u64)(fcoe->extra_ddp_buffer_dma);
-		j++;
-		lastsize = 1;
-	}
-
 	fcbuff = (IXGBE_FCBUFF_4KB << IXGBE_FCBUFF_BUFFSIZE_SHIFT);
 	fcbuff |= ((j & 0xff) << IXGBE_FCBUFF_BUFFCNT_SHIFT);
 	fcbuff |= (firstoff << IXGBE_FCBUFF_OFFSET_SHIFT);
@@ -341,12 +309,10 @@
 	if (fcerr == IXGBE_FCERR_BADCRC)
 		skb->ip_summed = CHECKSUM_NONE;
 
-	if (eth_hdr(skb)->h_proto == htons(ETH_P_8021Q))
-		fh = (struct fc_frame_header *)(skb->data +
-			sizeof(struct vlan_hdr) + sizeof(struct fcoe_hdr));
-	else
-		fh = (struct fc_frame_header *)(skb->data +
-			sizeof(struct fcoe_hdr));
+	skb_reset_network_header(skb);
+	skb_set_transport_header(skb, skb_network_offset(skb) +
+				 sizeof(struct fcoe_hdr));
+	fh = (struct fc_frame_header *)skb_transport_header(skb);
 	fctl = ntoh24(fh->fh_f_ctl);
 	if (fctl & FC_FC_EX_CTX)
 		xid =  be16_to_cpu(fh->fh_ox_id);
@@ -549,24 +515,6 @@
 				"failed to allocated FCoE DDP pool\n");
 
 		spin_lock_init(&fcoe->lock);
-
-		/* Extra buffer to be shared by all DDPs for HW work around */
-		fcoe->extra_ddp_buffer = kmalloc(IXGBE_FCBUFF_MIN, GFP_ATOMIC);
-		if (fcoe->extra_ddp_buffer == NULL) {
-			DPRINTK(DRV, ERR, "failed to allocated extra DDP buffer\n");
-			goto out_extra_ddp_buffer_alloc;
-		}
-
-		fcoe->extra_ddp_buffer_dma =
-			dma_map_single(&adapter->pdev->dev,
-				       fcoe->extra_ddp_buffer,
-				       IXGBE_FCBUFF_MIN,
-				       DMA_FROM_DEVICE);
-		if (dma_mapping_error(&adapter->pdev->dev,
-				      fcoe->extra_ddp_buffer_dma)) {
-			DPRINTK(DRV, ERR, "failed to map extra DDP buffer\n");
-			goto out_extra_ddp_buffer_dma;
-		}
 	}
 
 	/* Enable L2 eth type filter for FCoE */
@@ -622,14 +570,6 @@
 		}
 	}
 #endif
-
-	return;
-
-out_extra_ddp_buffer_dma:
-	kfree(fcoe->extra_ddp_buffer);
-out_extra_ddp_buffer_alloc:
-	pci_pool_destroy(fcoe->pool);
-	fcoe->pool = NULL;
 }
 
 /**
@@ -649,11 +589,6 @@
 	if (fcoe->pool) {
 		for (i = 0; i < IXGBE_FCOE_DDP_MAX; i++)
 			ixgbe_fcoe_ddp_put(adapter->netdev, i);
-		dma_unmap_single(&adapter->pdev->dev,
-				 fcoe->extra_ddp_buffer_dma,
-				 IXGBE_FCBUFF_MIN,
-				 DMA_FROM_DEVICE);
-		kfree(fcoe->extra_ddp_buffer);
 		pci_pool_destroy(fcoe->pool);
 		fcoe->pool = NULL;
 	}
@@ -690,6 +625,9 @@
 	netdev->features |= NETIF_F_FCOE_CRC;
 	netdev->features |= NETIF_F_FSO;
 	netdev->features |= NETIF_F_FCOE_MTU;
+	netdev->vlan_features |= NETIF_F_FCOE_CRC;
+	netdev->vlan_features |= NETIF_F_FSO;
+	netdev->vlan_features |= NETIF_F_FCOE_MTU;
 	netdev->fcoe_ddp_xid = IXGBE_FCOE_DDP_MAX - 1;
 
 	ixgbe_init_interrupt_scheme(adapter);
@@ -723,20 +661,24 @@
 		goto out_disable;
 
 	DPRINTK(DRV, INFO, "Disabling FCoE offload features.\n");
-	netdev->features &= ~NETIF_F_FCOE_CRC;
-	netdev->features &= ~NETIF_F_FSO;
-	netdev->features &= ~NETIF_F_FCOE_MTU;
-	netdev->fcoe_ddp_xid = 0;
-	netdev_features_change(netdev);
-
 	if (netif_running(netdev))
 		netdev->netdev_ops->ndo_stop(netdev);
 
 	ixgbe_clear_interrupt_scheme(adapter);
+
 	adapter->flags &= ~IXGBE_FLAG_FCOE_ENABLED;
 	adapter->ring_feature[RING_F_FCOE].indices = 0;
+	netdev->features &= ~NETIF_F_FCOE_CRC;
+	netdev->features &= ~NETIF_F_FSO;
+	netdev->features &= ~NETIF_F_FCOE_MTU;
+	netdev->vlan_features &= ~NETIF_F_FCOE_CRC;
+	netdev->vlan_features &= ~NETIF_F_FSO;
+	netdev->vlan_features &= ~NETIF_F_FCOE_MTU;
+	netdev->fcoe_ddp_xid = 0;
+
 	ixgbe_cleanup_fcoe(adapter);
 	ixgbe_init_interrupt_scheme(adapter);
+	netdev_features_change(netdev);
 
 	if (netif_running(netdev))
 		netdev->netdev_ops->ndo_open(netdev);
diff -r 15109ec2f661 drivers/net/ixgbe/ixgbe_fcoe.h
--- b/drivers/net/ixgbe/ixgbe_fcoe.h	Wed Aug 17 13:31:06 2011 +0100
+++ a/drivers/net/ixgbe/ixgbe_fcoe.h	Wed Aug 17 13:09:17 2011 +0100
@@ -69,8 +69,6 @@
 	spinlock_t lock;
 	struct pci_pool *pool;
 	struct ixgbe_fcoe_ddp ddp[IXGBE_FCOE_DDP_MAX];
-	unsigned char *extra_ddp_buffer;
-	dma_addr_t extra_ddp_buffer_dma;
 };
 
 #endif /* _IXGBE_FCOE_H */
diff -r 15109ec2f661 drivers/net/ixgbe/ixgbe_main.c
--- b/drivers/net/ixgbe/ixgbe_main.c	Wed Aug 17 13:31:06 2011 +0100
+++ a/drivers/net/ixgbe/ixgbe_main.c	Wed Aug 17 13:09:17 2011 +0100
@@ -1129,15 +1129,6 @@
 		itr_reg |= (itr_reg << 16);
 	} else if (adapter->hw.mac.type == ixgbe_mac_82599EB) {
 		/*
-		 * 82599 can support a value of zero, so allow it for
-		 * max interrupt rate, but there is an errata where it can
-		 * not be zero with RSC
-		 */
-		if (itr_reg == 8 &&
-		    !(adapter->flags2 & IXGBE_FLAG2_RSC_ENABLED))
-			itr_reg = 0;
-
-		/*
 		 * set the WDIS bit to not clear the timer bits and cause an
 		 * immediate assertion of the interrupt
 		 */
@@ -1229,18 +1220,17 @@
 {
 	struct ixgbe_hw *hw = &adapter->hw;
 
-	if (eicr & IXGBE_EICR_GPI_SDP2) {
-		/* Clear the interrupt */
-		IXGBE_WRITE_REG(hw, IXGBE_EICR, IXGBE_EICR_GPI_SDP2);
-		if (!test_bit(__IXGBE_DOWN, &adapter->state))
-			schedule_work(&adapter->sfp_config_module_task);
-	}
-
 	if (eicr & IXGBE_EICR_GPI_SDP1) {
 		/* Clear the interrupt */
 		IXGBE_WRITE_REG(hw, IXGBE_EICR, IXGBE_EICR_GPI_SDP1);
-		if (!test_bit(__IXGBE_DOWN, &adapter->state))
-			schedule_work(&adapter->multispeed_fiber_task);
+		schedule_work(&adapter->multispeed_fiber_task);
+	} else if (eicr & IXGBE_EICR_GPI_SDP2) {
+		/* Clear the interrupt */
+		IXGBE_WRITE_REG(hw, IXGBE_EICR, IXGBE_EICR_GPI_SDP2);
+		schedule_work(&adapter->sfp_config_module_task);
+	} else {
+		/* Interrupt isn't for us... */
+		return;
 	}
 }
 
@@ -2183,10 +2173,6 @@
 	/* Decide whether to use packet split mode or not */
 	adapter->flags |= IXGBE_FLAG_RX_PS_ENABLED;
 
-	/* Disable packet split due to 82599 erratum #45 */
-	if (hw->mac.type == ixgbe_mac_82599EB)
-		adapter->flags &= ~IXGBE_FLAG_RX_PS_ENABLED;
-
 	/* Set the RX buffer length according to the mode */
 	if (adapter->flags & IXGBE_FLAG_RX_PS_ENABLED) {
 		rx_buf_len = IXGBE_RX_HDR_SIZE;
@@ -2640,10 +2626,8 @@
 	case ixgbe_phy_sfp_ftl:
 	case ixgbe_phy_sfp_intel:
 	case ixgbe_phy_sfp_unknown:
-	case ixgbe_phy_sfp_passive_tyco:
-	case ixgbe_phy_sfp_passive_unknown:
-	case ixgbe_phy_sfp_active_unknown:
-	case ixgbe_phy_sfp_ftl_active:
+	case ixgbe_phy_tw_tyco:
+	case ixgbe_phy_tw_unknown:
 		return true;
 	default:
 		return false;
@@ -2668,8 +2652,7 @@
 			 * We need to try and force an autonegotiation
 			 * session, then bring up link.
 			 */
-			if (hw->mac.ops.setup_sfp)
-				hw->mac.ops.setup_sfp(hw);
+			hw->mac.ops.setup_sfp(hw);
 			if (!(adapter->flags & IXGBE_FLAG_IN_SFP_LINK_TASK))
 				schedule_work(&adapter->multispeed_fiber_task);
 		} else {
@@ -2815,13 +2798,8 @@
 	for (i = 0; i < adapter->num_tx_queues; i++) {
 		j = adapter->tx_ring[i].reg_idx;
 		txdctl = IXGBE_READ_REG(hw, IXGBE_TXDCTL(j));
-		if (adapter->rx_itr_setting == 0) {
-			/* cannot set wthresh when itr==0 */
-			txdctl &= ~0x007F0000;
-		} else {
-			/* enable WTHRESH=8 descriptors, to encourage burst writeback */
-			txdctl |= (8 << 16);
-		}
+		/* enable WTHRESH=8 descriptors, to encourage burst writeback */
+		txdctl |= (8 << 16);
 		IXGBE_WRITE_REG(hw, IXGBE_TXDCTL(j), txdctl);
 	}
 
@@ -2870,14 +2848,6 @@
 	clear_bit(__IXGBE_DOWN, &adapter->state);
 	ixgbe_napi_enable_all(adapter);
 
-	if (ixgbe_is_sfp(hw)) {
-		ixgbe_sfp_link_config(adapter);
-	} else {
-		err = ixgbe_non_sfp_link_config(hw);
-		if (err)
-			DPRINTK(DRV, CRIT, "link_config FAILED %d\n", err);
-	}
-
 	/* clear any pending interrupts, may auto mask */
 	IXGBE_READ_REG(hw, IXGBE_EICR);
 
@@ -2902,8 +2872,26 @@
 	 * If we're not hot-pluggable SFP+, we just need to configure link
 	 * and bring it up.
 	 */
-	if (hw->phy.type == ixgbe_phy_unknown)
-		schedule_work(&adapter->sfp_config_module_task);
+	if (hw->phy.type == ixgbe_phy_unknown) {
+		err = hw->phy.ops.identify(hw);
+		if (err == IXGBE_ERR_SFP_NOT_SUPPORTED) {
+			/*
+			 * Take the device down and schedule the sfp tasklet
+			 * which will unregister_netdev and log it.
+			 */
+			ixgbe_down(adapter);
+			schedule_work(&adapter->sfp_config_module_task);
+			return err;
+		}
+	}
+
+	if (ixgbe_is_sfp(hw)) {
+		ixgbe_sfp_link_config(adapter);
+	} else {
+		err = ixgbe_non_sfp_link_config(hw);
+		if (err)
+			DPRINTK(PROBE, ERR, "link_config FAILED %d\n", err);
+	}
 
 	for (i = 0; i < adapter->num_tx_queues; i++)
 		set_bit(__IXGBE_FDIR_INIT_DONE,
@@ -3101,27 +3089,30 @@
 	/* signal that we are down to the interrupt handler */
 	set_bit(__IXGBE_DOWN, &adapter->state);
 
+	/* power down the optics */
+	if (hw->phy.multispeed_fiber)
+		hw->mac.ops.disable_tx_laser(hw);
+
 	/* disable receives */
 	rxctrl = IXGBE_READ_REG(hw, IXGBE_RXCTRL);
 	IXGBE_WRITE_REG(hw, IXGBE_RXCTRL, rxctrl & ~IXGBE_RXCTRL_RXEN);
 
+	netif_tx_disable(netdev);
+
 	IXGBE_WRITE_FLUSH(hw);
 	msleep(10);
 
 	netif_tx_stop_all_queues(netdev);
 
+	ixgbe_irq_disable(adapter);
+
+	ixgbe_napi_disable_all(adapter);
+
 	clear_bit(__IXGBE_SFP_MODULE_NOT_FOUND, &adapter->state);
 	del_timer_sync(&adapter->sfp_timer);
 	del_timer_sync(&adapter->watchdog_timer);
 	cancel_work_sync(&adapter->watchdog_task);
 
-	netif_carrier_off(netdev);
-	netif_tx_disable(netdev);
-
-	ixgbe_irq_disable(adapter);
-
-	ixgbe_napi_disable_all(adapter);
-
 	if (adapter->flags & IXGBE_FLAG_FDIR_HASH_CAPABLE ||
 	    adapter->flags & IXGBE_FLAG_FDIR_PERFECT_CAPABLE)
 		cancel_work_sync(&adapter->fdir_reinit_task);
@@ -3139,9 +3130,7 @@
 		                (IXGBE_READ_REG(hw, IXGBE_DMATXCTL) &
 		                 ~IXGBE_DMATXCTL_TE));
 
-	/* power down the optics */
-	if (hw->phy.multispeed_fiber)
-		hw->mac.ops.disable_tx_laser(hw);
+	netif_carrier_off(netdev);
 
 	if (!pci_channel_offline(adapter->pdev))
 		ixgbe_reset(adapter);
@@ -3375,7 +3364,7 @@
 
 done:
 	/* Notify the stack of the (possibly) reduced Tx Queue count. */
-	netif_set_real_num_tx_queues(adapter->netdev, adapter->num_tx_queues);
+	adapter->netdev->real_num_tx_queues = adapter->num_tx_queues;
 }
 
 static void ixgbe_acquire_msix_vectors(struct ixgbe_adapter *adapter,
@@ -4801,8 +4790,7 @@
 		unregister_netdev(adapter->netdev);
 		return;
 	}
-	if (hw->mac.ops.setup_sfp)
-		hw->mac.ops.setup_sfp(hw);
+	hw->mac.ops.setup_sfp(hw);
 
 	if (!(adapter->flags & IXGBE_FLAG_IN_SFP_LINK_TASK))
 		/* This will also work for DA Twinax connections */
@@ -5346,7 +5334,6 @@
 			txq -= dev->real_num_tx_queues;
 		return txq;
 	}
-
 #ifdef IXGBE_FCOE
 	if ((adapter->flags & IXGBE_FLAG_FCOE_ENABLED) &&
 	    ((skb->protocol == htons(ETH_P_FCOE)) ||
@@ -5859,11 +5846,6 @@
 				adapter->flags &= ~IXGBE_FLAG_FCOE_CAPABLE;
 		}
 	}
-	if (adapter->flags & IXGBE_FLAG_FCOE_CAPABLE) {
-		netdev->vlan_features |= NETIF_F_FCOE_CRC;
-		netdev->vlan_features |= NETIF_F_FSO;
-		netdev->vlan_features |= NETIF_F_FCOE_MTU;
-	}
 #endif /* IXGBE_FCOE */
 	if (pci_using_dac)
 		netdev->features |= NETIF_F_HIGHDMA;
diff -r 15109ec2f661 drivers/net/ixgbe/ixgbe_phy.c
--- b/drivers/net/ixgbe/ixgbe_phy.c	Wed Aug 17 13:31:06 2011 +0100
+++ a/drivers/net/ixgbe/ixgbe_phy.c	Wed Aug 17 13:09:17 2011 +0100
@@ -531,7 +531,6 @@
 	u8 comp_codes_10g = 0;
 	u8 oui_bytes[3] = {0, 0, 0};
 	u8 cable_tech = 0;
-	u8 cable_spec = 0;
 	u16 enforce_sfp = 0;
 
 	if (hw->mac.ops.get_media_type(hw) != ixgbe_media_type_fiber) {
@@ -570,8 +569,6 @@
 		 * 4    SFP_DA_CORE1 - 82599-specific
 		 * 5    SFP_SR/LR_CORE0 - 82599-specific
 		 * 6    SFP_SR/LR_CORE1 - 82599-specific
-		 * 9    SFP_1g_cu_CORE0 - 82599-specific
-		 * 10   SFP_1g_cu_CORE1 - 82599-specific
 		 */
 		if (hw->mac.type == ixgbe_mac_82598EB) {
 			if (cable_tech & IXGBE_SFF_DA_PASSIVE_CABLE)
@@ -583,30 +580,14 @@
 			else
 				hw->phy.sfp_type = ixgbe_sfp_type_unknown;
 		} else if (hw->mac.type == ixgbe_mac_82599EB) {
-			if (cable_tech & IXGBE_SFF_DA_PASSIVE_CABLE) {
+			if (cable_tech & IXGBE_SFF_DA_PASSIVE_CABLE)
 				if (hw->bus.lan_id == 0)
 					hw->phy.sfp_type =
 					             ixgbe_sfp_type_da_cu_core0;
 				else
 					hw->phy.sfp_type =
 					             ixgbe_sfp_type_da_cu_core1;
-			} else if (cable_tech & IXGBE_SFF_DA_ACTIVE_CABLE) {
-				hw->phy.ops.read_i2c_eeprom(
-						hw, IXGBE_SFF_CABLE_SPEC_COMP,
-						&cable_spec);
-				if (cable_spec &
-				    IXGBE_SFF_DA_SPEC_ACTIVE_LIMITING) {
-					if (hw->bus.lan_id == 0)
-						hw->phy.sfp_type =
-						ixgbe_sfp_type_da_act_lmt_core0;
-					else
-						hw->phy.sfp_type =
-						ixgbe_sfp_type_da_act_lmt_core1;
-				} else {
-					hw->phy.sfp_type =
-						ixgbe_sfp_type_unknown;
-				}
-			} else if (comp_codes_10g & IXGBE_SFF_10GBASESR_CAPABLE)
+			else if (comp_codes_10g & IXGBE_SFF_10GBASESR_CAPABLE)
 				if (hw->bus.lan_id == 0)
 					hw->phy.sfp_type =
 					              ixgbe_sfp_type_srlr_core0;
@@ -620,13 +601,6 @@
 				else
 					hw->phy.sfp_type =
 					              ixgbe_sfp_type_srlr_core1;
-			else if (comp_codes_1g & IXGBE_SFF_1GBASET_CAPABLE)
-				if (hw->bus.lan_id == 0)
-					hw->phy.sfp_type =
-						ixgbe_sfp_type_1g_cu_core0;
-				else
-					hw->phy.sfp_type =
-						ixgbe_sfp_type_1g_cu_core1;
 			else
 				hw->phy.sfp_type = ixgbe_sfp_type_unknown;
 		}
@@ -663,14 +637,10 @@
 			switch (vendor_oui) {
 			case IXGBE_SFF_VENDOR_OUI_TYCO:
 				if (cable_tech & IXGBE_SFF_DA_PASSIVE_CABLE)
-					hw->phy.type =
-						ixgbe_phy_sfp_passive_tyco;
+					hw->phy.type = ixgbe_phy_tw_tyco;
 				break;
 			case IXGBE_SFF_VENDOR_OUI_FTL:
-				if (cable_tech & IXGBE_SFF_DA_ACTIVE_CABLE)
-					hw->phy.type = ixgbe_phy_sfp_ftl_active;
-				else
-					hw->phy.type = ixgbe_phy_sfp_ftl;
+				hw->phy.type = ixgbe_phy_sfp_ftl;
 				break;
 			case IXGBE_SFF_VENDOR_OUI_AVAGO:
 				hw->phy.type = ixgbe_phy_sfp_avago;
@@ -680,11 +650,7 @@
 				break;
 			default:
 				if (cable_tech & IXGBE_SFF_DA_PASSIVE_CABLE)
-					hw->phy.type =
-						ixgbe_phy_sfp_passive_unknown;
-				else if (cable_tech & IXGBE_SFF_DA_ACTIVE_CABLE)
-					hw->phy.type =
-						ixgbe_phy_sfp_active_unknown;
+					hw->phy.type = ixgbe_phy_tw_unknown;
 				else
 					hw->phy.type = ixgbe_phy_sfp_unknown;
 				break;
@@ -692,16 +658,13 @@
 		}
 
 		/* All passive DA cables are supported */
-		if (cable_tech & (IXGBE_SFF_DA_PASSIVE_CABLE |
-		    IXGBE_SFF_DA_ACTIVE_CABLE)) {
+		if (cable_tech & IXGBE_SFF_DA_PASSIVE_CABLE) {
 			status = 0;
 			goto out;
 		}
 
-		/* Verify supported 1G SFP modules */
-		if (comp_codes_10g == 0 &&
-		    !(hw->phy.sfp_type == ixgbe_sfp_type_1g_cu_core1 ||
-		      hw->phy.sfp_type == ixgbe_sfp_type_1g_cu_core0)) {
+		/* 1G SFP modules are not supported */
+		if (comp_codes_10g == 0) {
 			hw->phy.type = ixgbe_phy_sfp_unsupported;
 			status = IXGBE_ERR_SFP_NOT_SUPPORTED;
 			goto out;
@@ -715,9 +678,7 @@
 
 		/* This is guaranteed to be 82599, no need to check for NULL */
 		hw->mac.ops.get_device_caps(hw, &enforce_sfp);
-		if (!(enforce_sfp & IXGBE_DEVICE_CAPS_ALLOW_ANY_SFP) &&
-		    !((hw->phy.sfp_type == ixgbe_sfp_type_1g_cu_core0) ||
-		      (hw->phy.sfp_type == ixgbe_sfp_type_1g_cu_core1))) {
+		if (!(enforce_sfp & IXGBE_DEVICE_CAPS_ALLOW_ANY_SFP)) {
 			/* Make sure we're a supported PHY type */
 			if (hw->phy.type == ixgbe_phy_sfp_intel) {
 				status = 0;
@@ -748,7 +709,6 @@
                                         u16 *data_offset)
 {
 	u16 sfp_id;
-	u16 sfp_type = hw->phy.sfp_type;
 
 	if (hw->phy.sfp_type == ixgbe_sfp_type_unknown)
 		return IXGBE_ERR_SFP_NOT_SUPPORTED;
@@ -760,17 +720,6 @@
 	    (hw->phy.sfp_type == ixgbe_sfp_type_da_cu))
 		return IXGBE_ERR_SFP_NOT_SUPPORTED;
 
-	/*
-	 * Limiting active cables and 1G Phys must be initialized as
-	 * SR modules
-	 */
-	if (sfp_type == ixgbe_sfp_type_da_act_lmt_core0 ||
-	    sfp_type == ixgbe_sfp_type_1g_cu_core0)
-		sfp_type = ixgbe_sfp_type_srlr_core0;
-	else if (sfp_type == ixgbe_sfp_type_da_act_lmt_core1 ||
-	         sfp_type == ixgbe_sfp_type_1g_cu_core1)
-		sfp_type = ixgbe_sfp_type_srlr_core1;
-
 	/* Read offset to PHY init contents */
 	hw->eeprom.ops.read(hw, IXGBE_PHY_INIT_OFFSET_NL, list_offset);
 
@@ -787,7 +736,7 @@
 	hw->eeprom.ops.read(hw, *list_offset, &sfp_id);
 
 	while (sfp_id != IXGBE_PHY_INIT_END_NL) {
-		if (sfp_id == sfp_type) {
+		if (sfp_id == hw->phy.sfp_type) {
 			(*list_offset)++;
 			hw->eeprom.ops.read(hw, *list_offset, data_offset);
 			if ((!*data_offset) || (*data_offset == 0xFFFF)) {
diff -r 15109ec2f661 drivers/net/ixgbe/ixgbe_phy.h
--- b/drivers/net/ixgbe/ixgbe_phy.h	Wed Aug 17 13:31:06 2011 +0100
+++ a/drivers/net/ixgbe/ixgbe_phy.h	Wed Aug 17 13:09:17 2011 +0100
@@ -40,15 +40,11 @@
 #define IXGBE_SFF_1GBE_COMP_CODES    0x6
 #define IXGBE_SFF_10GBE_COMP_CODES   0x3
 #define IXGBE_SFF_CABLE_TECHNOLOGY   0x8
-#define IXGBE_SFF_CABLE_SPEC_COMP    0x3C
 
 /* Bitmasks */
 #define IXGBE_SFF_DA_PASSIVE_CABLE           0x4
-#define IXGBE_SFF_DA_ACTIVE_CABLE            0x8
-#define IXGBE_SFF_DA_SPEC_ACTIVE_LIMITING    0x4
 #define IXGBE_SFF_1GBASESX_CAPABLE           0x1
 #define IXGBE_SFF_1GBASELX_CAPABLE           0x2
-#define IXGBE_SFF_1GBASET_CAPABLE            0x8
 #define IXGBE_SFF_10GBASESR_CAPABLE          0x10
 #define IXGBE_SFF_10GBASELR_CAPABLE          0x20
 #define IXGBE_I2C_EEPROM_READ_MASK           0x100
diff -r 15109ec2f661 drivers/net/ixgbe/ixgbe_type.h
--- b/drivers/net/ixgbe/ixgbe_type.h	Wed Aug 17 13:31:06 2011 +0100
+++ a/drivers/net/ixgbe/ixgbe_type.h	Wed Aug 17 13:09:17 2011 +0100
@@ -1437,8 +1437,6 @@
 #define IXGBE_ANLP1_PAUSE               0x0C00
 #define IXGBE_ANLP1_SYM_PAUSE           0x0400
 #define IXGBE_ANLP1_ASM_PAUSE           0x0800
-#define IXGBE_ANLP1_AN_STATE_MASK       0x000f0000
-
 
 /* SW Semaphore Register bitmasks */
 #define IXGBE_SWSM_SMBI 0x00000001 /* Driver Semaphore bit */
@@ -2070,7 +2068,6 @@
 #define IXGBE_PHYSICAL_LAYER_1000BASE_BX  0x0400
 #define IXGBE_PHYSICAL_LAYER_10GBASE_KR   0x0800
 #define IXGBE_PHYSICAL_LAYER_10GBASE_XAUI 0x1000
-#define IXGBE_PHYSICAL_LAYER_SFP_ACTIVE_DA 0x2000
 
 /* Software ATR hash keys */
 #define IXGBE_ATR_BUCKET_HASH_KEY    0xE214AD3D
@@ -2131,12 +2128,10 @@
 	ixgbe_phy_qt,
 	ixgbe_phy_xaui,
 	ixgbe_phy_nl,
-	ixgbe_phy_sfp_passive_tyco,
-	ixgbe_phy_sfp_passive_unknown,
-	ixgbe_phy_sfp_active_unknown,
+	ixgbe_phy_tw_tyco,
+	ixgbe_phy_tw_unknown,
 	ixgbe_phy_sfp_avago,
 	ixgbe_phy_sfp_ftl,
-	ixgbe_phy_sfp_ftl_active,
 	ixgbe_phy_sfp_unknown,
 	ixgbe_phy_sfp_intel,
 	ixgbe_phy_sfp_unsupported,
@@ -2164,10 +2159,6 @@
 	ixgbe_sfp_type_da_cu_core1 = 4,
 	ixgbe_sfp_type_srlr_core0 = 5,
 	ixgbe_sfp_type_srlr_core1 = 6,
-	ixgbe_sfp_type_da_act_lmt_core0 = 7,
-	ixgbe_sfp_type_da_act_lmt_core1 = 8,
-	ixgbe_sfp_type_1g_cu_core0 = 9,
-	ixgbe_sfp_type_1g_cu_core1 = 10,
 	ixgbe_sfp_type_not_present = 0xFFFE,
 	ixgbe_sfp_type_unknown = 0xFFFF
 };
@@ -2524,7 +2515,6 @@
 #define IXGBE_ERR_SFP_NO_INIT_SEQ_PRESENT       -21
 #define IXGBE_ERR_FDIR_REINIT_FAILED            -23
 #define IXGBE_ERR_EEPROM_VERSION                -24
-#define IXGBE_ERR_SFP_SETUP_NOT_COMPLETE        -30
 #define IXGBE_NOT_IMPLEMENTED                   0x7FFFFFFF
 
 #endif /* _IXGBE_TYPE_H_ */
diff -r 15109ec2f661 drivers/net/netxen/netxen_nic.h
--- b/drivers/net/netxen/netxen_nic.h	Wed Aug 17 13:31:06 2011 +0100
+++ a/drivers/net/netxen/netxen_nic.h	Wed Aug 17 13:09:17 2011 +0100
@@ -520,6 +520,7 @@
 #define NX_P2_MN_ROMIMAGE_NAME		"nxromimg.bin"
 #define NX_P3_CT_ROMIMAGE_NAME		"nx3fwct.bin"
 #define NX_P3_MN_ROMIMAGE_NAME		"nx3fwmn.bin"
+#define NX_UNIFIED_ROMIMAGE_NAME	"phanfw.bin"
 #define NX_FLASH_ROMIMAGE_NAME		"flash"
 
 extern char netxen_nic_driver_name[];
@@ -733,8 +734,7 @@
 #define NX_CDRP_CMD_READ_PEXQ_PARAMETERS	0x0000001c
 #define NX_CDRP_CMD_GET_LIC_CAPABILITIES	0x0000001d
 #define NX_CDRP_CMD_READ_MAX_LRO_PER_BOARD	0x0000001e
-#define NX_CDRP_CMD_CONFIG_GBE_PORT		0x0000001f
-#define NX_CDRP_CMD_MAX				0x00000020
+#define NX_CDRP_CMD_MAX				0x0000001f
 
 #define NX_RCODE_SUCCESS		0
 #define NX_RCODE_NO_HOST_MEM		1
@@ -1049,7 +1049,6 @@
 #define NX_FW_CAPABILITY_BDG			(1 << 8)
 #define NX_FW_CAPABILITY_FVLANTX		(1 << 9)
 #define NX_FW_CAPABILITY_HW_LRO			(1 << 10)
-#define NX_FW_CAPABILITY_GBE_LINK_CFG		(1 << 11)
 
 /* module types */
 #define LINKEVENT_MODULE_NOT_PRESENT			1
@@ -1355,8 +1354,6 @@
 int netxen_linkevent_request(struct netxen_adapter *adapter, int enable);
 void netxen_advert_link_change(struct netxen_adapter *adapter, int linkup);
 
-int nx_fw_cmd_set_gbe_port(struct netxen_adapter *adapter,
-				u32 speed, u32 duplex, u32 autoneg);
 int nx_fw_cmd_set_mtu(struct netxen_adapter *adapter, int mtu);
 int netxen_nic_change_mtu(struct net_device *netdev, int new_mtu);
 int netxen_config_hw_lro(struct netxen_adapter *adapter, int enable);
diff -r 15109ec2f661 drivers/net/netxen/netxen_nic_ctx.c
--- b/drivers/net/netxen/netxen_nic_ctx.c	Wed Aug 17 13:31:06 2011 +0100
+++ a/drivers/net/netxen/netxen_nic_ctx.c	Wed Aug 17 13:09:17 2011 +0100
@@ -112,21 +112,6 @@
 	return 0;
 }
 
-int
-nx_fw_cmd_set_gbe_port(struct netxen_adapter *adapter,
-			u32 speed, u32 duplex, u32 autoneg)
-{
-
-	return netxen_issue_cmd(adapter,
-				adapter->ahw.pci_func,
-				NXHAL_VERSION,
-				speed,
-				duplex,
-				autoneg,
-				NX_CDRP_CMD_CONFIG_GBE_PORT);
-
-}
-
 static int
 nx_fw_cmd_create_rx_ctx(struct netxen_adapter *adapter)
 {
@@ -270,19 +255,6 @@
 }
 
 static void
-nx_fw_cmd_reset_ctx(struct netxen_adapter *adapter)
-{
-
-	netxen_issue_cmd(adapter, adapter->ahw.pci_func, NXHAL_VERSION,
-			adapter->ahw.pci_func, NX_DESTROY_CTX_RESET, 0,
-			NX_CDRP_CMD_DESTROY_RX_CTX);
-
-	netxen_issue_cmd(adapter, adapter->ahw.pci_func, NXHAL_VERSION,
-			adapter->ahw.pci_func, NX_DESTROY_CTX_RESET, 0,
-			NX_CDRP_CMD_DESTROY_TX_CTX);
-}
-
-static void
 nx_fw_cmd_destroy_rx_ctx(struct netxen_adapter *adapter)
 {
 	struct netxen_recv_context *recv_ctx = &adapter->recv_ctx;
@@ -710,8 +682,7 @@
 	if (!NX_IS_REVISION_P2(adapter->ahw.revision_id)) {
 		if (test_and_set_bit(__NX_FW_ATTACHED, &adapter->state))
 			goto done;
-		if (reset_devices)
-			nx_fw_cmd_reset_ctx(adapter);
+
 		err = nx_fw_cmd_create_rx_ctx(adapter);
 		if (err)
 			goto err_out_free;
diff -r 15109ec2f661 drivers/net/netxen/netxen_nic_ethtool.c
--- b/drivers/net/netxen/netxen_nic_ethtool.c	Wed Aug 17 13:31:06 2011 +0100
+++ a/drivers/net/netxen/netxen_nic_ethtool.c	Wed Aug 17 13:09:17 2011 +0100
@@ -214,6 +214,7 @@
 			check_sfp_module = netif_running(dev) &&
 				adapter->has_link_events;
 		} else {
+			ecmd->autoneg = AUTONEG_ENABLE;
 			ecmd->supported |= (SUPPORTED_TP |SUPPORTED_Autoneg);
 			ecmd->advertising |=
 				(ADVERTISED_TP | ADVERTISED_Autoneg);
@@ -251,24 +252,53 @@
 netxen_nic_set_settings(struct net_device *dev, struct ethtool_cmd *ecmd)
 {
 	struct netxen_adapter *adapter = netdev_priv(dev);
-	int ret;
+	__u32 status;
 
-	if (adapter->ahw.port_type != NETXEN_NIC_GBE)
-		return -EOPNOTSUPP;
+	/* read which mode */
+	if (adapter->ahw.port_type == NETXEN_NIC_GBE) {
+		/* autonegotiation */
+		if (adapter->phy_write &&
+		    adapter->phy_write(adapter,
+				       NETXEN_NIU_GB_MII_MGMT_ADDR_AUTONEG,
+				       ecmd->autoneg) != 0)
+			return -EIO;
+		else
+			adapter->link_autoneg = ecmd->autoneg;
 
-	if (!(adapter->capabilities & NX_FW_CAPABILITY_GBE_LINK_CFG))
-		return -EOPNOTSUPP;
+		if (adapter->phy_read &&
+		    adapter->phy_read(adapter,
+				      NETXEN_NIU_GB_MII_MGMT_ADDR_PHY_STATUS,
+				      &status) != 0)
+			return -EIO;
 
-	ret = nx_fw_cmd_set_gbe_port(adapter, ecmd->speed, ecmd->duplex,
-				     ecmd->autoneg);
-	if (ret == NX_RCODE_NOT_SUPPORTED)
+		/* speed */
+		switch (ecmd->speed) {
+		case SPEED_10:
+			netxen_set_phy_speed(status, 0);
+			break;
+		case SPEED_100:
+			netxen_set_phy_speed(status, 1);
+			break;
+		case SPEED_1000:
+			netxen_set_phy_speed(status, 2);
+			break;
+		}
+		/* set duplex mode */
+		if (ecmd->duplex == DUPLEX_HALF)
+			netxen_clear_phy_duplex(status);
+		if (ecmd->duplex == DUPLEX_FULL)
+			netxen_set_phy_duplex(status);
+		if (adapter->phy_write &&
+		    adapter->phy_write(adapter,
+				       NETXEN_NIU_GB_MII_MGMT_ADDR_PHY_STATUS,
+				       *((int *)&status)) != 0)
+			return -EIO;
+		else {
+			adapter->link_speed = ecmd->speed;
+			adapter->link_duplex = ecmd->duplex;
+		}
+	} else
 		return -EOPNOTSUPP;
-	else if (ret)
-		return -EIO;
-
-	adapter->link_speed = ecmd->speed;
-	adapter->link_duplex = ecmd->duplex;
-	adapter->link_autoneg = ecmd->autoneg;
 
 	if (!netif_running(dev))
 		return 0;
@@ -602,9 +632,6 @@
 	if ((data_read & 0xffff) != adapter->pdev->vendor)
 		return 1;
 
-	if (NX_IS_REVISION_P3(adapter->ahw.revision_id))
-		return 0;
-
 	data_written = (u32)0xa5a5a5a5;
 
 	NXWR32(adapter, CRB_SCRATCHPAD_TEST, data_written);
diff -r 15109ec2f661 drivers/net/netxen/netxen_nic_hdr.h
--- b/drivers/net/netxen/netxen_nic_hdr.h	Wed Aug 17 13:31:06 2011 +0100
+++ a/drivers/net/netxen/netxen_nic_hdr.h	Wed Aug 17 13:09:17 2011 +0100
@@ -789,7 +789,9 @@
  * for backward compability
  */
 #define CRB_NIC_CAPABILITIES_HOST	NETXEN_NIC_REG(0x1a8)
+#define CRB_NIC_CAPABILITIES_FW	  	NETXEN_NIC_REG(0x1dc)
 #define CRB_NIC_MSI_MODE_HOST		NETXEN_NIC_REG(0x270)
+#define CRB_NIC_MSI_MODE_FW	  	NETXEN_NIC_REG(0x274)
 
 #define INTR_SCHEME_PERPORT	      	0x1
 #define MSI_MODE_MULTIFUNC	      	0x1
diff -r 15109ec2f661 drivers/net/netxen/netxen_nic_init.c
--- b/drivers/net/netxen/netxen_nic_init.c	Wed Aug 17 13:31:06 2011 +0100
+++ a/drivers/net/netxen/netxen_nic_init.c	Wed Aug 17 13:09:17 2011 +0100
@@ -840,6 +840,7 @@
 	NX_P2_MN_ROMIMAGE_NAME,
 	NX_P3_CT_ROMIMAGE_NAME,
 	NX_P3_MN_ROMIMAGE_NAME,
+	NX_UNIFIED_ROMIMAGE_NAME,
 	NX_FLASH_ROMIMAGE_NAME,
 };
 
@@ -1223,12 +1224,10 @@
 		return err;
 
 	NXWR32(adapter, CRB_NIC_CAPABILITIES_HOST, INTR_SCHEME_PERPORT);
+	NXWR32(adapter, CRB_NIC_MSI_MODE_HOST, MSI_MODE_MULTIFUNC);
 	NXWR32(adapter, CRB_MPORT_MODE, MPORT_MULTI_FUNCTION_MODE);
 	NXWR32(adapter, CRB_CMDPEG_STATE, PHAN_INITIALIZE_ACK);
 
-	if (NX_IS_REVISION_P2(adapter->ahw.revision_id))
-		NXWR32(adapter, CRB_NIC_MSI_MODE_HOST, MSI_MODE_MULTIFUNC);
-
 	return err;
 }
 
@@ -1402,6 +1401,7 @@
 	if (pkt_offset)
 		skb_pull(skb, pkt_offset);
 
+	skb->truesize = skb->len + sizeof(struct sk_buff);
 	skb->protocol = eth_type_trans(skb, netdev);
 
 	napi_gro_receive(&sds_ring->napi, skb);
@@ -1463,6 +1463,8 @@
 
 	skb_put(skb, lro_length + data_offset);
 
+	skb->truesize = skb->len + sizeof(struct sk_buff) + skb_headroom(skb);
+
 	skb_pull(skb, l2_hdr_offset);
 	skb->protocol = eth_type_trans(skb, netdev);
 
diff -r 15109ec2f661 drivers/net/netxen/netxen_nic_main.c
--- b/drivers/net/netxen/netxen_nic_main.c	Wed Aug 17 13:31:06 2011 +0100
+++ a/drivers/net/netxen/netxen_nic_main.c	Wed Aug 17 13:09:17 2011 +0100
@@ -43,6 +43,7 @@
 MODULE_FIRMWARE(NX_P2_MN_ROMIMAGE_NAME);
 MODULE_FIRMWARE(NX_P3_CT_ROMIMAGE_NAME);
 MODULE_FIRMWARE(NX_P3_MN_ROMIMAGE_NAME);
+MODULE_FIRMWARE(NX_UNIFIED_ROMIMAGE_NAME);
 
 char netxen_nic_driver_name[] = "netxen_nic";
 static char netxen_nic_driver_string[] = "QLogic/NetXen Network Driver v"
diff -r 15109ec2f661 drivers/net/niu.c
--- b/drivers/net/niu.c	Wed Aug 17 13:31:06 2011 +0100
+++ a/drivers/net/niu.c	Wed Aug 17 13:09:17 2011 +0100
@@ -7315,28 +7315,33 @@
 	struct niu_parent *parent = np->parent;
 	struct niu_tcam_entry *tp;
 	int i, idx, cnt;
+	u16 n_entries;
 	unsigned long flags;
-	int ret = 0;
+
 
 	/* put the tcam size here */
 	nfc->data = tcam_get_size(np);
 
 	niu_lock_parent(np, flags);
+	n_entries = nfc->rule_cnt;
 	for (cnt = 0, i = 0; i < nfc->data; i++) {
 		idx = tcam_get_index(np, i);
 		tp = &parent->tcam[idx];
 		if (!tp->valid)
 			continue;
-		if (cnt == nfc->rule_cnt) {
-			ret = -EMSGSIZE;
-			break;
-		}
 		rule_locs[cnt] = i;
 		cnt++;
 	}
 	niu_unlock_parent(np, flags);
 
-	return ret;
+	if (n_entries != cnt) {
+		/* print warning, this should not happen */
+		pr_info(PFX "niu%d: %s In niu_get_ethtool_tcam_all, "
+			"n_entries[%d] != cnt[%d]!!!\n\n",
+			np->parent->index, np->dev->name, n_entries, cnt);
+	}
+
+	return 0;
 }
 
 static int niu_get_nfc(struct net_device *dev, struct ethtool_rxnfc *cmd,
diff -r 15109ec2f661 drivers/net/tg3.c
--- b/drivers/net/tg3.c	Wed Aug 17 13:31:06 2011 +0100
+++ a/drivers/net/tg3.c	Wed Aug 17 13:09:17 2011 +0100
@@ -566,23 +566,18 @@
 static void tg3_ape_lock_init(struct tg3 *tp)
 {
 	int i;
-	u32 regbase;
-
-	if (GET_ASIC_REV(tp->pci_chip_rev_id) == ASIC_REV_5761)
-		regbase = TG3_APE_LOCK_GRANT;
-	else
-		regbase = TG3_APE_PER_LOCK_GRANT;
 
 	/* Make sure the driver hasn't any stale locks. */
 	for (i = 0; i < 8; i++)
-		tg3_ape_write32(tp, regbase + 4 * i, APE_LOCK_GRANT_DRIVER);
+		tg3_ape_write32(tp, TG3_APE_LOCK_GRANT + 4 * i,
+				APE_LOCK_GRANT_DRIVER);
 }
 
 static int tg3_ape_lock(struct tg3 *tp, int locknum)
 {
 	int i, off;
 	int ret = 0;
-	u32 status, req, gnt;
+	u32 status;
 
 	if (!(tp->tg3_flags3 & TG3_FLG3_ENABLE_APE))
 		return 0;
@@ -595,21 +590,13 @@
 			return -EINVAL;
 	}
 
-	if (GET_ASIC_REV(tp->pci_chip_rev_id) == ASIC_REV_5761) {
-		req = TG3_APE_LOCK_REQ;
-		gnt = TG3_APE_LOCK_GRANT;
-	} else {
-		req = TG3_APE_PER_LOCK_REQ;
-		gnt = TG3_APE_PER_LOCK_GRANT;
-	}
-
 	off = 4 * locknum;
 
-	tg3_ape_write32(tp, req + off, APE_LOCK_REQ_DRIVER);
+	tg3_ape_write32(tp, TG3_APE_LOCK_REQ + off, APE_LOCK_REQ_DRIVER);
 
 	/* Wait for up to 1 millisecond to acquire lock. */
 	for (i = 0; i < 100; i++) {
-		status = tg3_ape_read32(tp, gnt + off);
+		status = tg3_ape_read32(tp, TG3_APE_LOCK_GRANT + off);
 		if (status == APE_LOCK_GRANT_DRIVER)
 			break;
 		udelay(10);
@@ -617,7 +604,7 @@
 
 	if (status != APE_LOCK_GRANT_DRIVER) {
 		/* Revoke the lock request. */
-		tg3_ape_write32(tp, gnt + off,
+		tg3_ape_write32(tp, TG3_APE_LOCK_GRANT + off,
 				APE_LOCK_GRANT_DRIVER);
 
 		ret = -EBUSY;
@@ -628,7 +615,7 @@
 
 static void tg3_ape_unlock(struct tg3 *tp, int locknum)
 {
-	u32 gnt;
+	int off;
 
 	if (!(tp->tg3_flags3 & TG3_FLG3_ENABLE_APE))
 		return;
@@ -641,12 +628,8 @@
 			return;
 	}
 
-	if (GET_ASIC_REV(tp->pci_chip_rev_id) == ASIC_REV_5761)
-		gnt = TG3_APE_LOCK_GRANT;
-	else
-		gnt = TG3_APE_PER_LOCK_GRANT;
-
-	tg3_ape_write32(tp, gnt + 4 * locknum, APE_LOCK_GRANT_DRIVER);
+	off = 4 * locknum;
+	tg3_ape_write32(tp, TG3_APE_LOCK_GRANT + off, APE_LOCK_GRANT_DRIVER);
 }
 
 static void tg3_disable_ints(struct tg3 *tp)
@@ -5832,7 +5815,7 @@
 
 	if ((mss = skb_shinfo(skb)->gso_size) != 0) {
 		struct iphdr *iph;
-		u32 tcp_opt_len, hdr_len;
+		u32 tcp_opt_len, ip_tcp_len, hdr_len;
 
 		if (skb_header_cloned(skb) &&
 		    pskb_expand_head(skb, 0, 0, GFP_ATOMIC)) {
@@ -5840,21 +5823,10 @@
 			goto out_unlock;
 		}
 
-		iph = ip_hdr(skb);
 		tcp_opt_len = tcp_optlen(skb);
-
-		if (skb_shinfo(skb)->gso_type & SKB_GSO_TCPV6) {
-			hdr_len = skb_headlen(skb) - ETH_HLEN;
-		} else {
-			u32 ip_tcp_len;
-
-			ip_tcp_len = ip_hdrlen(skb) + sizeof(struct tcphdr);
-			hdr_len = ip_tcp_len + tcp_opt_len;
-
-			iph->check = 0;
-			iph->tot_len = htons(mss + hdr_len);
-		}
-
+		ip_tcp_len = ip_hdrlen(skb) + sizeof(struct tcphdr);
+
+		hdr_len = ip_tcp_len + tcp_opt_len;
 		if (unlikely((ETH_HLEN + hdr_len) > 80) &&
 			     (tp->tg3_flags2 & TG3_FLG2_TSO_BUG))
 			return (tg3_tso_bug(tp, skb));
@@ -5862,6 +5834,9 @@
 		base_flags |= (TXD_FLAG_CPU_PRE_DMA |
 			       TXD_FLAG_CPU_POST_DMA);
 
+		iph = ip_hdr(skb);
+		iph->check = 0;
+		iph->tot_len = htons(mss + hdr_len);
 		if (tp->tg3_flags2 & TG3_FLG2_HW_TSO) {
 			tcp_hdr(skb)->check = 0;
 			base_flags &= ~TXD_FLAG_TCPUDP_CSUM;
@@ -6293,8 +6268,6 @@
 	for (j = 0; j < tp->irq_cnt; j++) {
 		struct tg3_napi *tnapi = &tp->napi[j];
 
-		tg3_rx_prodring_free(tp, &tp->prodring[j]);
-
 		if (!tnapi->tx_buffers)
 			continue;
 
@@ -6330,6 +6303,8 @@
 
 			dev_kfree_skb_any(skb);
 		}
+
+		tg3_rx_prodring_free(tp, &tp->prodring[j]);
 	}
 }
 
@@ -6864,8 +6839,7 @@
 	/* Allow reads and writes to the APE register and memory space. */
 	if (tp->tg3_flags3 & TG3_FLG3_ENABLE_APE)
 		val |= PCISTATE_ALLOW_APE_CTLSPC_WR |
-		       PCISTATE_ALLOW_APE_SHMEM_WR |
-		       PCISTATE_ALLOW_APE_PSPACE_WR;
+		       PCISTATE_ALLOW_APE_SHMEM_WR;
 	pci_write_config_dword(tp->pdev, TG3PCI_PCISTATE, val);
 
 	pci_write_config_word(tp->pdev, PCI_COMMAND, tp->pci_cmd);
@@ -7766,25 +7740,6 @@
 		tw32(GRC_MODE, grc_mode);
 	}
 
-	if (tp->pci_chip_rev_id == CHIPREV_ID_57765_A0) {
-		u32 grc_mode = tr32(GRC_MODE);
-
-		/* Access the lower 1K of PL PCIE block registers. */
-		val = grc_mode & ~GRC_MODE_PCIE_PORT_MASK;
-		tw32(GRC_MODE, val | GRC_MODE_PCIE_PL_SEL);
-
-		val = tr32(TG3_PCIE_TLDLPL_PORT + TG3_PCIE_PL_LO_PHYCTL5);
-		tw32(TG3_PCIE_TLDLPL_PORT + TG3_PCIE_PL_LO_PHYCTL5,
-		     val | TG3_PCIE_PL_LO_PHYCTL5_DIS_L2CLKREQ);
-
-		tw32(GRC_MODE, grc_mode);
-
-		val = tr32(TG3_CPMU_LSPD_10MB_CLK);
-		val &= ~CPMU_LSPD_10MB_MACCLK_MASK;
-		val |= CPMU_LSPD_10MB_MACCLK_6_25;
-		tw32(TG3_CPMU_LSPD_10MB_CLK, val);
-	}
-
 	/* This works around an issue with Athlon chipsets on
 	 * B3 tigon3 silicon.  This bit has no effect on any
 	 * other revision.  But do not set this on PCI Express
@@ -7809,8 +7764,7 @@
 		 */
 		val = tr32(TG3PCI_PCISTATE);
 		val |= PCISTATE_ALLOW_APE_CTLSPC_WR |
-		       PCISTATE_ALLOW_APE_SHMEM_WR |
-		       PCISTATE_ALLOW_APE_PSPACE_WR;
+		       PCISTATE_ALLOW_APE_SHMEM_WR;
 		tw32(TG3PCI_PCISTATE, val);
 	}
 
@@ -7834,8 +7788,6 @@
 	    GET_ASIC_REV(tp->pci_chip_rev_id) == ASIC_REV_57765) {
 		val = tr32(TG3PCI_DMA_RW_CTRL) &
 		      ~DMA_RWCTRL_DIS_CACHE_ALIGNMENT;
-		if (tp->pci_chip_rev_id == CHIPREV_ID_57765_A0)
-			val &= ~DMA_RWCTRL_CRDRDR_RDMA_MRRS_MSK;
 		tw32(TG3PCI_DMA_RW_CTRL, val | tp->dma_rwctrl);
 	} else if (GET_ASIC_REV(tp->pci_chip_rev_id) != ASIC_REV_5784 &&
 		   GET_ASIC_REV(tp->pci_chip_rev_id) != ASIC_REV_5761) {
@@ -8287,9 +8239,6 @@
 	}
 
 	tp->tx_mode = TX_MODE_ENABLE;
-	if ((tp->tg3_flags3 & TG3_FLG3_5755_PLUS) ||
-	    GET_ASIC_REV(tp->pci_chip_rev_id) == ASIC_REV_5906)
-		tp->tx_mode |= TX_MODE_MBUF_LOCKUP_FIX;
 	tw32_f(MAC_TX_MODE, tp->tx_mode);
 	udelay(100);
 
@@ -9949,7 +9898,7 @@
 			   ADVERTISED_Pause |
 			   ADVERTISED_Asym_Pause;
 
-		if (!(tp->tg3_flags & TG3_FLAG_10_100_ONLY))
+		if (!(tp->tg3_flags2 & TG3_FLAG_10_100_ONLY))
 			mask |= ADVERTISED_1000baseT_Half |
 				ADVERTISED_1000baseT_Full;
 
@@ -13541,8 +13490,7 @@
 		 * APE register and memory space.
 		 */
 		pci_state_reg |= PCISTATE_ALLOW_APE_CTLSPC_WR |
-				 PCISTATE_ALLOW_APE_SHMEM_WR |
-				 PCISTATE_ALLOW_APE_PSPACE_WR;
+				 PCISTATE_ALLOW_APE_SHMEM_WR;
 		pci_write_config_dword(tp->pdev, TG3PCI_PCISTATE,
 				       pci_state_reg);
 	}
diff -r 15109ec2f661 drivers/net/tg3.h
--- b/drivers/net/tg3.h	Wed Aug 17 13:31:06 2011 +0100
+++ a/drivers/net/tg3.h	Wed Aug 17 13:09:17 2011 +0100
@@ -151,7 +151,6 @@
 #define   METAL_REV_B2			 0x02
 #define TG3PCI_DMA_RW_CTRL		0x0000006c
 #define  DMA_RWCTRL_DIS_CACHE_ALIGNMENT  0x00000001
-#define  DMA_RWCTRL_CRDRDR_RDMA_MRRS_MSK 0x00000380
 #define  DMA_RWCTRL_READ_BNDRY_MASK	 0x00000700
 #define  DMA_RWCTRL_READ_BNDRY_DISAB	 0x00000000
 #define  DMA_RWCTRL_READ_BNDRY_16	 0x00000100
@@ -202,7 +201,6 @@
 #define  PCISTATE_RETRY_SAME_DMA	 0x00002000
 #define  PCISTATE_ALLOW_APE_CTLSPC_WR	 0x00010000
 #define  PCISTATE_ALLOW_APE_SHMEM_WR	 0x00020000
-#define  PCISTATE_ALLOW_APE_PSPACE_WR	 0x00040000
 #define TG3PCI_CLOCK_CTRL		0x00000074
 #define  CLOCK_CTRL_CORECLK_DISABLE	 0x00000200
 #define  CLOCK_CTRL_RXCLK_DISABLE	 0x00000400
@@ -440,7 +438,6 @@
 #define  TX_MODE_FLOW_CTRL_ENABLE	 0x00000010
 #define  TX_MODE_BIG_BCKOFF_ENABLE	 0x00000020
 #define  TX_MODE_LONG_PAUSE_ENABLE	 0x00000040
-#define  TX_MODE_MBUF_LOCKUP_FIX	 0x00000100
 #define MAC_TX_STATUS			0x00000460
 #define  TX_STATUS_XOFFED		 0x00000001
 #define  TX_STATUS_SENT_XOFF		 0x00000002
@@ -1825,8 +1822,6 @@
 #define TG3_PCIE_TLDLPL_PORT		0x00007c00
 #define TG3_PCIE_PL_LO_PHYCTL1		 0x00000004
 #define TG3_PCIE_PL_LO_PHYCTL1_L1PLLPD_EN	  0x00001000
-#define TG3_PCIE_PL_LO_PHYCTL5		 0x00000014
-#define TG3_PCIE_PL_LO_PHYCTL5_DIS_L2CLKREQ	  0x80000000
 
 /* OTP bit definitions */
 #define TG3_OTP_AGCTGT_MASK		0x000000e0
@@ -2187,11 +2182,6 @@
 #define  APE_EVENT_STATUS_STATE_SUSPEND	 0x00040000
 #define  APE_EVENT_STATUS_EVENT_PENDING	 0x80000000
 
-#define TG3_APE_PER_LOCK_REQ		0x8400
-#define  APE_LOCK_PER_REQ_DRIVER	 0x00001000
-#define TG3_APE_PER_LOCK_GRANT		0x8420
-#define  APE_PER_LOCK_GRANT_DRIVER	 0x00001000
-
 /* APE convenience enumerations. */
 #define TG3_APE_LOCK_GRC                1
 #define TG3_APE_LOCK_MEM                4
diff -r 15109ec2f661 drivers/scsi/bfa/bfa_cb_ioim_macros.h
--- b/drivers/scsi/bfa/bfa_cb_ioim_macros.h	Wed Aug 17 13:31:06 2011 +0100
+++ a/drivers/scsi/bfa/bfa_cb_ioim_macros.h	Wed Aug 17 13:09:17 2011 +0100
@@ -117,6 +117,35 @@
 }
 
 /**
+ * Get SG element for the I/O request given the SG element index
+ */
+static inline union bfi_addr_u
+bfa_cb_ioim_get_sgaddr(struct bfad_ioim_s *dio, int sgeid)
+{
+	struct scsi_cmnd *cmnd = (struct scsi_cmnd *)dio;
+	struct scatterlist *sge;
+	u64        addr;
+
+	sge = (struct scatterlist *)scsi_sglist(cmnd) + sgeid;
+	addr = (u64) sg_dma_address(sge);
+
+	return *(union bfi_addr_u *) &addr;
+}
+
+static inline u32
+bfa_cb_ioim_get_sglen(struct bfad_ioim_s *dio, int sgeid)
+{
+	struct scsi_cmnd *cmnd = (struct scsi_cmnd *)dio;
+	struct scatterlist *sge;
+	u32        len;
+
+	sge = (struct scatterlist *)scsi_sglist(cmnd) + sgeid;
+	len = sg_dma_len(sge);
+
+	return len;
+}
+
+/**
  * Get Command Reference Number for the I/O request. 0 if none.
  */
 static inline u8
diff -r 15109ec2f661 drivers/scsi/bfa/bfa_core.c
--- b/drivers/scsi/bfa/bfa_core.c	Wed Aug 17 13:31:06 2011 +0100
+++ a/drivers/scsi/bfa/bfa_core.c	Wed Aug 17 13:09:17 2011 +0100
@@ -84,32 +84,11 @@
 	for (i = 0; hal_mods[i]; i++)
 		hal_mods[i]->meminfo(cfg, &km_len, &dm_len);
 
-	dm_len += bfa_port_meminfo();
 
 	meminfo->meminfo[BFA_MEM_TYPE_KVA - 1].mem_len = km_len;
 	meminfo->meminfo[BFA_MEM_TYPE_DMA - 1].mem_len = dm_len;
 }
 
-static void
-bfa_com_port_attach(struct bfa_s *bfa, struct bfa_meminfo_s *mi)
-{
-	struct bfa_port_s       *port = &bfa->modules.port;
-	uint32_t                dm_len;
-	uint8_t                 *dm_kva;
-	uint64_t                dm_pa;
-
-	dm_len = bfa_port_meminfo();
-	dm_kva = bfa_meminfo_dma_virt(mi);
-	dm_pa  = bfa_meminfo_dma_phys(mi);
-
-	memset(port, 0, sizeof(struct bfa_port_s));
-	bfa_port_attach(port, &bfa->ioc, bfa, bfa->trcmod, bfa->logm);
-	bfa_port_mem_claim(port, dm_kva, dm_pa);
-
-	bfa_meminfo_dma_virt(mi) = dm_kva + dm_len;
-	bfa_meminfo_dma_phys(mi) = dm_pa + dm_len;
-}
-
 /**
  * Use this function to do attach the driver instance with the BFA
  * library. This function will not trigger any HW initialization
@@ -161,7 +140,6 @@
 	for (i = 0; hal_mods[i]; i++)
 		hal_mods[i]->attach(bfa, bfad, cfg, meminfo, pcidev);
 
-	bfa_com_port_attach(bfa, meminfo);
 }
 
 /**
diff -r 15109ec2f661 drivers/scsi/bfa/bfa_ioim.c
--- b/drivers/scsi/bfa/bfa_ioim.c	Wed Aug 17 13:31:06 2011 +0100
+++ a/drivers/scsi/bfa/bfa_ioim.c	Wed Aug 17 13:09:17 2011 +0100
@@ -731,9 +731,6 @@
 	static struct fcp_cmnd_s cmnd_z0 = { 0 };
 	struct bfi_sge_s      *sge;
 	u32        pgdlen = 0;
-	u64	addr;
-	struct scatterlist *sg;
-	struct scsi_cmnd *cmnd = (struct scsi_cmnd *) ioim->dio;
 
 	/**
 	 * check for room in queue to send request now
@@ -757,10 +754,8 @@
 	 */
 	sge = &m->sges[0];
 	if (ioim->nsges) {
-		sg = (struct scatterlist *)scsi_sglist(cmnd);
-		addr = bfa_os_sgaddr(sg_dma_address(sg));
-		sge->sga = *(union bfi_addr_u *) &addr;
-		pgdlen = sg_dma_len(sg);
+		sge->sga = bfa_cb_ioim_get_sgaddr(ioim->dio, 0);
+		pgdlen = bfa_cb_ioim_get_sglen(ioim->dio, 0);
 		sge->sg_len = pgdlen;
 		sge->flags = (ioim->nsges > BFI_SGE_INLINE) ?
 					BFI_SGE_DATA_CPL : BFI_SGE_DATA_LAST;
@@ -873,16 +868,10 @@
 	struct bfi_sge_s      *sge;
 	struct bfa_sgpg_s *sgpg;
 	u32        pgcumsz;
-	u64	addr;
-	struct scatterlist *sg;
-	struct scsi_cmnd *cmnd = (struct scsi_cmnd *) ioim->dio;
 
 	sgeid = BFI_SGE_INLINE;
 	ioim->sgpg = sgpg = bfa_q_first(&ioim->sgpg_q);
 
-	sg = scsi_sglist(cmnd);
-	sg = sg_next(sg);
-
 	do {
 		sge = sgpg->sgpg->sges;
 		nsges = ioim->nsges - sgeid;
@@ -890,10 +879,9 @@
 			nsges = BFI_SGPG_DATA_SGES;
 
 		pgcumsz = 0;
-		for (i = 0; i < nsges; i++, sge++, sgeid++, sg = sg_next(sg)) {
-			addr = bfa_os_sgaddr(sg_dma_address(sg));
-			sge->sga = *(union bfi_addr_u *) &addr;
-			sge->sg_len = sg_dma_len(sg);
+		for (i = 0; i < nsges; i++, sge++, sgeid++) {
+			sge->sga = bfa_cb_ioim_get_sgaddr(ioim->dio, sgeid);
+			sge->sg_len = bfa_cb_ioim_get_sglen(ioim->dio, sgeid);
 			pgcumsz += sge->sg_len;
 
 			/**
diff -r 15109ec2f661 drivers/scsi/bfa/bfa_os_inc.h
--- b/drivers/scsi/bfa/bfa_os_inc.h	Wed Aug 17 13:31:06 2011 +0100
+++ a/drivers/scsi/bfa/bfa_os_inc.h	Wed Aug 17 13:09:17 2011 +0100
@@ -50,10 +50,6 @@
 #include <scsi/scsi_transport_fc.h>
 #include <scsi/scsi_transport.h>
 
-#ifdef __BIG_ENDIAN
-#define __BIGENDIAN
-#endif
-
 #define BFA_ERR			KERN_ERR
 #define BFA_WARNING		KERN_WARNING
 #define BFA_NOTICE		KERN_NOTICE
@@ -127,15 +123,6 @@
 	(((_x) & 0x00ff0000) >> 8)	|	\
 	(((_x) & 0xff000000) >> 24))
 
-#define bfa_os_swap_sgaddr(_x)  ((u64)( 				\
-	(((u64)(_x) & (u64)0x00000000000000ffull) << 32)	|	\
-	(((u64)(_x) & (u64)0x000000000000ff00ull) << 32)	|	\
-	(((u64)(_x) & (u64)0x0000000000ff0000ull) << 32)	|	\
-	(((u64)(_x) & (u64)0x00000000ff000000ull) << 32)	|	\
-	(((u64)(_x) & (u64)0x000000ff00000000ull) >> 32)	|	\
-	(((u64)(_x) & (u64)0x0000ff0000000000ull) >> 32)	|	\
-	(((u64)(_x) & (u64)0x00ff000000000000ull) >> 32)	|	\
-	(((u64)(_x) & (u64)0xff00000000000000ull) >> 32)))
 
 #ifndef __BIGENDIAN
 #define bfa_os_htons(_x) ((u16)((((_x) & 0xff00) >> 8) | \
@@ -146,7 +133,6 @@
 #define bfa_os_hton3b(_x)	bfa_swap_3b(_x)
 
 #define bfa_os_wtole(_x)   (_x)
-#define bfa_os_sgaddr(_x)  (_x)
 
 #else
 
@@ -155,7 +141,6 @@
 #define bfa_os_hton3b(_x)  (_x)
 #define bfa_os_htonll(_x)  (_x)
 #define bfa_os_wtole(_x)   bfa_os_swap32(_x)
-#define bfa_os_sgaddr(_x)  bfa_os_swap_sgaddr(_x)
 
 #endif
 
@@ -176,12 +161,12 @@
 #define bfa_os_addr_t char __iomem *
 #define bfa_os_panic()
 
-#define bfa_os_reg_read(_raddr) readl(_raddr)
-#define bfa_os_reg_write(_raddr, _val) writel((_val), (_raddr))
+#define bfa_os_reg_read(_raddr) bfa_os_wtole(readl(_raddr))
+#define bfa_os_reg_write(_raddr, _val) writel(bfa_os_wtole((_val)), (_raddr))
 #define bfa_os_mem_read(_raddr, _off)                                   \
-	bfa_os_swap32(readl(((_raddr) + (_off))))
+	bfa_os_ntohl(readl(((_raddr) + (_off))))
 #define bfa_os_mem_write(_raddr, _off, _val)                            \
-	writel(bfa_os_swap32((_val)), ((_raddr) + (_off)))
+	writel(bfa_os_htonl((_val)), ((_raddr) + (_off)))
 
 #define BFA_TRC_TS(_trcm)						\
 			({						\
diff -r 15109ec2f661 drivers/scsi/bfa/bfad.c
--- b/drivers/scsi/bfa/bfad.c	Wed Aug 17 13:31:06 2011 +0100
+++ a/drivers/scsi/bfa/bfad.c	Wed Aug 17 13:09:17 2011 +0100
@@ -32,7 +32,7 @@
 #include <fcb/bfa_fcb.h>
 
 BFA_TRC_FILE(LDRV, BFAD);
-DEFINE_MUTEX(bfad_mutex);
+static DEFINE_MUTEX(bfad_mutex);
 LIST_HEAD(bfad_list);
 static	int	bfad_inst;
 int bfad_supported_fc4s;
@@ -590,6 +590,7 @@
 int
 bfad_pci_init(struct pci_dev *pdev, struct bfad_s *bfad)
 {
+	unsigned long	bar0_len;
 	int		rc = -ENODEV;
 
 	if (pci_enable_device(pdev)) {
@@ -608,7 +609,9 @@
 			goto out_release_region;
 		}
 
-	bfad->pci_bar0_kva = pci_iomap(pdev, 0, pci_resource_len(pdev, 0));
+	bfad->pci_bar0_map = pci_resource_start(pdev, 0);
+	bar0_len = pci_resource_len(pdev, 0);
+	bfad->pci_bar0_kva = ioremap(bfad->pci_bar0_map, bar0_len);
 
 	if (bfad->pci_bar0_kva == NULL) {
 		BFA_PRINTF(BFA_ERR, "Fail to map bar0\n");
@@ -641,7 +644,11 @@
 void
 bfad_pci_uninit(struct pci_dev *pdev, struct bfad_s *bfad)
 {
+#if defined(__ia64__)
 	pci_iounmap(pdev, bfad->pci_bar0_kva);
+#else
+	iounmap(bfad->pci_bar0_kva);
+#endif
 	pci_release_regions(pdev);
 	pci_disable_device(pdev);
 	pci_set_drvdata(pdev, NULL);
diff -r 15109ec2f661 drivers/scsi/bfa/bfad_drv.h
--- b/drivers/scsi/bfa/bfad_drv.h	Wed Aug 17 13:31:06 2011 +0100
+++ a/drivers/scsi/bfa/bfad_drv.h	Wed Aug 17 13:09:17 2011 +0100
@@ -162,6 +162,7 @@
 	const char *pci_name;
 	struct bfa_pcidev_s hal_pcidev;
 	struct bfa_ioc_pci_attr_s pci_attr;
+	unsigned long   pci_bar0_map;
 	void __iomem   *pci_bar0_kva;
 	struct completion comp;
 	struct completion suspend;
@@ -293,6 +294,5 @@
 extern int bfa_lun_queue_depth;
 extern int bfad_supported_fc4s;
 extern int bfa_linkup_delay;
-extern struct mutex bfad_mutex;
 
 #endif /* __BFAD_DRV_H__ */
diff -r 15109ec2f661 drivers/scsi/bfa/bfad_im.c
--- b/drivers/scsi/bfa/bfad_im.c	Wed Aug 17 13:31:06 2011 +0100
+++ a/drivers/scsi/bfa/bfad_im.c	Wed Aug 17 13:09:17 2011 +0100
@@ -516,9 +516,7 @@
 {
 	int error = 1;
 
-	mutex_lock(&bfad_mutex);
 	if (!idr_pre_get(&bfad_im_port_index, GFP_KERNEL)) {
-		mutex_unlock(&bfad_mutex);
 		printk(KERN_WARNING "idr_pre_get failure\n");
 		goto out;
 	}
@@ -526,13 +524,10 @@
 	error = idr_get_new(&bfad_im_port_index, im_port,
 					 &im_port->idr_id);
 	if (error) {
-		mutex_unlock(&bfad_mutex);
 		printk(KERN_WARNING "idr_get_new failure\n");
 		goto out;
 	}
 
-	mutex_unlock(&bfad_mutex);
-
 	im_port->shost = bfad_os_scsi_host_alloc(im_port, bfad);
 	if (!im_port->shost) {
 		error = 1;
@@ -563,9 +558,7 @@
 out_fc_rel:
 	scsi_host_put(im_port->shost);
 out_free_idr:
-	mutex_lock(&bfad_mutex);
 	idr_remove(&bfad_im_port_index, im_port->idr_id);
-	mutex_unlock(&bfad_mutex);
 out:
 	return error;
 }
@@ -573,6 +566,8 @@
 void
 bfad_im_scsi_host_free(struct bfad_s *bfad, struct bfad_im_port_s *im_port)
 {
+	unsigned long flags;
+
 	bfa_trc(bfad, bfad->inst_no);
 	bfa_log(bfad->logmod, BFA_LOG_LINUX_SCSI_HOST_FREE,
 			im_port->shost->host_no);
@@ -582,9 +577,9 @@
 	scsi_remove_host(im_port->shost);
 	scsi_host_put(im_port->shost);
 
-	mutex_lock(&bfad_mutex);
+	spin_lock_irqsave(&bfad->bfad_lock, flags);
 	idr_remove(&bfad_im_port_index, im_port->idr_id);
-	mutex_unlock(&bfad_mutex);
+	spin_unlock_irqrestore(&bfad->bfad_lock, flags);
 }
 
 static void
diff -r 15109ec2f661 drivers/scsi/cxgb3i/cxgb3i_ddp.c
--- b/drivers/scsi/cxgb3i/cxgb3i_ddp.c	Wed Aug 17 13:31:06 2011 +0100
+++ a/drivers/scsi/cxgb3i/cxgb3i_ddp.c	Wed Aug 17 13:09:17 2011 +0100
@@ -498,7 +498,6 @@
 	/* set up ulp submode and page size */
 	req = (struct cpl_set_tcb_field *)skb_put(skb, sizeof(*req));
 	req->wr.wr_hi = htonl(V_WR_OP(FW_WROPCODE_FORWARD));
-	req->wr.wr_lo = 0;
 	OPCODE_TID(req) = htonl(MK_OPCODE_TID(CPL_SET_TCB_FIELD, tid));
 	req->reply = V_NO_REPLY(reply ? 0 : 1);
 	req->cpu_idx = 0;
@@ -564,7 +563,6 @@
 	/* set up ulp submode and page size */
 	req = (struct cpl_set_tcb_field *)skb_put(skb, sizeof(*req));
 	req->wr.wr_hi = htonl(V_WR_OP(FW_WROPCODE_FORWARD));
-	req->wr.wr_lo = 0;
 	OPCODE_TID(req) = htonl(MK_OPCODE_TID(CPL_SET_TCB_FIELD, tid));
 	req->reply = V_NO_REPLY(reply ? 0 : 1);
 	req->cpu_idx = 0;
diff -r 15109ec2f661 drivers/scsi/cxgb3i/cxgb3i_offload.c
--- b/drivers/scsi/cxgb3i/cxgb3i_offload.c	Wed Aug 17 13:31:06 2011 +0100
+++ a/drivers/scsi/cxgb3i/cxgb3i_offload.c	Wed Aug 17 13:09:17 2011 +0100
@@ -263,7 +263,6 @@
 	skb->priority = CPL_PRIORITY_SETUP;
 	req = (struct cpl_act_open_req *)__skb_put(skb, sizeof(*req));
 	req->wr.wr_hi = htonl(V_WR_OP(FW_WROPCODE_FORWARD));
-	req->wr.wr_lo = 0;
 	OPCODE_TID(req) = htonl(MK_OPCODE_TID(CPL_ACT_OPEN_REQ, atid));
 	req->local_port = c3cn->saddr.sin_port;
 	req->peer_port = c3cn->daddr.sin_port;
@@ -273,7 +272,6 @@
 			   V_TX_CHANNEL(e->smt_idx));
 	req->opt0l = htonl(calc_opt0l(c3cn));
 	req->params = 0;
-	req->opt2 = 0;
 }
 
 static void fail_act_open(struct s3_conn *c3cn, int errno)
@@ -380,7 +378,6 @@
 
 	c3cn->cpl_abort_req = NULL;
 	req = (struct cpl_abort_req *)skb->head;
-	memset(req, 0, sizeof(*req));
 
 	skb->priority = CPL_PRIORITY_DATA;
 	set_arp_failure_handler(skb, abort_arp_failure);
@@ -408,7 +405,6 @@
 	c3cn->cpl_abort_rpl = NULL;
 
 	skb->priority = CPL_PRIORITY_DATA;
-	memset(rpl, 0, sizeof(*rpl));
 	rpl->wr.wr_hi = htonl(V_WR_OP(FW_WROPCODE_OFLD_HOST_ABORT_CON_RPL));
 	rpl->wr.wr_lo = htonl(V_WR_TID(c3cn->tid));
 	OPCODE_TID(rpl) = htonl(MK_OPCODE_TID(CPL_ABORT_RPL, c3cn->tid));
@@ -433,7 +429,6 @@
 
 	req = (struct cpl_rx_data_ack *)__skb_put(skb, sizeof(*req));
 	req->wr.wr_hi = htonl(V_WR_OP(FW_WROPCODE_FORWARD));
-	req->wr.wr_lo = 0;
 	OPCODE_TID(req) = htonl(MK_OPCODE_TID(CPL_RX_DATA_ACK, c3cn->tid));
 	req->credit_dack = htonl(dack | V_RX_CREDITS(credits));
 	skb->priority = CPL_PRIORITY_ACK;
diff -r 15109ec2f661 drivers/scsi/lpfc/lpfc_scsi.c
--- b/drivers/scsi/lpfc/lpfc_scsi.c	Wed Aug 17 13:31:06 2011 +0100
+++ a/drivers/scsi/lpfc/lpfc_scsi.c	Wed Aug 17 13:09:17 2011 +0100
@@ -2241,21 +2241,15 @@
 	struct lpfc_vport      *vport = pIocbIn->vport;
 	struct lpfc_rport_data *rdata = lpfc_cmd->rdata;
 	struct lpfc_nodelist *pnode = rdata->pnode;
-	struct scsi_cmnd *cmd;
+	struct scsi_cmnd *cmd = lpfc_cmd->pCmd;
 	int result;
 	struct scsi_device *tmp_sdev;
 	int depth;
 	unsigned long flags;
 	struct lpfc_fast_path_event *fast_path_evt;
-	struct Scsi_Host *shost;
+	struct Scsi_Host *shost = cmd->device->host;
 	uint32_t queue_depth, scsi_id;
 
-	/* Sanity check on return of outstanding command */
-	if (!(lpfc_cmd->pCmd))
-		return;
-	cmd = lpfc_cmd->pCmd;
-	shost = cmd->device->host;
-
 	lpfc_cmd->result = pIocbOut->iocb.un.ulpWord[4];
 	lpfc_cmd->status = pIocbOut->iocb.ulpStatus;
 	/* pick up SLI4 exhange busy status from HBA */
@@ -2995,10 +2989,7 @@
 	int ret = SUCCESS;
 	DECLARE_WAIT_QUEUE_HEAD_ONSTACK(waitq);
 
-	ret = fc_block_scsi_eh(cmnd);
-	if (ret != SUCCESS)
-		return ret;
-
+	fc_block_scsi_eh(cmnd);
 	lpfc_cmd = (struct lpfc_scsi_buf *)cmnd->host_scribble;
 	BUG_ON(!lpfc_cmd);
 
@@ -3314,9 +3305,7 @@
 		return FAILED;
 	}
 	pnode = rdata->pnode;
-	status = fc_block_scsi_eh(cmnd);
-	if (status != SUCCESS)
-		return status;
+	fc_block_scsi_eh(cmnd);
 
 	status = lpfc_chk_tgt_mapped(vport, cmnd);
 	if (status == FAILED) {
@@ -3381,9 +3370,7 @@
 		return FAILED;
 	}
 	pnode = rdata->pnode;
-	status = fc_block_scsi_eh(cmnd);
-	if (status != SUCCESS)
-		return status;
+	fc_block_scsi_eh(cmnd);
 
 	status = lpfc_chk_tgt_mapped(vport, cmnd);
 	if (status == FAILED) {
@@ -3440,10 +3427,6 @@
 	int match;
 	int ret = SUCCESS, status, i;
 
-	ret = fc_block_scsi_eh(cmnd);
-	if (ret != SUCCESS)
-		return ret;
-
 	scsi_event.event_type = FC_REG_SCSI_EVENT;
 	scsi_event.subcategory = LPFC_EVENT_BUSRESET;
 	scsi_event.lun = 0;
@@ -3453,6 +3436,8 @@
 	fc_host_post_vendor_event(shost, fc_get_event_number(),
 		sizeof(scsi_event), (char *)&scsi_event, LPFC_NL_VENDOR_ID);
 
+	fc_block_scsi_eh(cmnd);
+
 	/*
 	 * Since the driver manages a single bus device, reset all
 	 * targets known to the driver.  Should any target reset
diff -r 15109ec2f661 drivers/scsi/lpfc/lpfc_version.h
--- b/drivers/scsi/lpfc/lpfc_version.h	Wed Aug 17 13:31:06 2011 +0100
+++ a/drivers/scsi/lpfc/lpfc_version.h	Wed Aug 17 13:09:17 2011 +0100
@@ -18,7 +18,7 @@
  * included with this package.                                     *
  *******************************************************************/
 
-#define LPFC_DRIVER_VERSION "8.3.5.8.2p"
+#define LPFC_DRIVER_VERSION "8.3.5.8.1p"
 #define LPFC_DRIVER_NAME		"lpfc"
 #define LPFC_SP_DRIVER_HANDLER_NAME	"lpfc:sp"
 #define LPFC_FP_DRIVER_HANDLER_NAME	"lpfc:fp"
diff -r 15109ec2f661 drivers/scsi/megaraid/megaraid_sas.c
--- b/drivers/scsi/megaraid/megaraid_sas.c	Wed Aug 17 13:31:06 2011 +0100
+++ a/drivers/scsi/megaraid/megaraid_sas.c	Wed Aug 17 13:09:17 2011 +0100
@@ -251,7 +251,7 @@
  * megasas_adp_reset_xscale -	For controller reset
  * @regs:				MFI register set
  */
-static int
+static int 
 megasas_adp_reset_xscale(struct megasas_instance *instance, struct megasas_register_set __iomem * regs)
 {
         u32 i;
@@ -287,7 +287,7 @@
  * megasas_check_reset_xscale -	For controller reset check
  * @regs:				MFI register set
  */
-static int
+static int 
 megasas_check_reset_xscale(struct megasas_instance *instance, struct megasas_register_set __iomem * regs)
 {
 	u32 consumer;
@@ -409,7 +409,7 @@
  * megasas_adp_reset_ppc -	For controller reset
  * @regs:				MFI register set
  */
-static int
+static int 
 megasas_adp_reset_ppc(struct megasas_instance *instance, struct megasas_register_set __iomem * regs)
 {
 	return 0;
@@ -419,7 +419,7 @@
  * megasas_check_reset_ppc -	For controller reset check
  * @regs:				MFI register set
  */
-static int
+static int 
 megasas_check_reset_ppc(struct megasas_instance *instance, struct megasas_register_set __iomem * regs)
 {
 	return 0;
@@ -530,7 +530,7 @@
  * megasas_adp_reset_skinny -	For controller reset
  * @regs:				MFI register set
  */
-static int
+static int 
 megasas_adp_reset_skinny(struct megasas_instance *instance, struct megasas_register_set __iomem * regs)
 {
 	return 0;
@@ -540,7 +540,7 @@
  * megasas_check_reset_skinny -	For controller reset check
  * @regs:				MFI register set
  */
-static int
+static int 
 megasas_check_reset_skinny(struct megasas_instance *instance, struct megasas_register_set __iomem * regs)
 {
 	return 0;
@@ -660,7 +660,7 @@
  * megasas_adp_reset_gen2 -	For controller reset
  * @regs:				MFI register set
  */
-static int
+static int 
 megasas_adp_reset_gen2(struct megasas_instance *instance, struct megasas_register_set __iomem * reg_set)
 {
     u32			retry = 0, delay = 0;
@@ -672,7 +672,7 @@
 	writel(2, &reg_set->seq_offset);
 	writel(7, &reg_set->seq_offset);
 	writel(0xd, &reg_set->seq_offset);
-
+	
 	msleep(1000);
 
 	HostDiag = (u32)readl(&reg_set->host_diag);
@@ -682,8 +682,8 @@
 		msleep(100);
 		HostDiag = (u32)readl(&reg_set->host_diag);
 		printk("ADP_RESET_GEN2: retry time=%x, hostdiag=%x\n", retry, HostDiag);
-
-		if (retry++ >= 100)
+		
+		if (retry++ >= 100) 
 			return 1;
 
 }
@@ -692,19 +692,19 @@
 
 	writel((HostDiag | DIAG_RESET_ADAPTER), &reg_set->host_diag);
 
-	for (delay=0; delay<10; delay++)
+	for (delay=0; delay<10; delay++) 
 	{
 		msleep(1000);
 	}
-
+	
 	HostDiag = (u32)readl(&reg_set->host_diag);
 	while ( ( HostDiag & DIAG_RESET_ADAPTER) )
 	{
 		msleep(100);
 		HostDiag = (u32)readl(&reg_set->host_diag);
 		printk("ADP_RESET_GEN2: retry time=%x, hostdiag=%x\n", retry, HostDiag);
-
-		if (retry++ >= 1000)
+		
+		if (retry++ >= 1000) 
 			return 1;
 
 	}
@@ -715,7 +715,7 @@
  * megasas_check_reset_gen2 -	For controller reset check
  * @regs:				MFI register set
  */
-static int
+static int 
 megasas_check_reset_gen2(struct megasas_instance *instance, struct megasas_register_set __iomem * regs)
 {
 	return 0;
@@ -1983,12 +1983,6 @@
 	case MFI_CMD_LD_READ:
 	case MFI_CMD_LD_WRITE:
 
-		if (!cmd->scmd && !cmd->sync_cmd) {
-			printk(KERN_DEBUG "megasas: invalid completion on"
-			       " command %p status %x\n", cmd, hdr->cmd_status);
-			break;
-		}
-
 		if (alt_status) {
 			cmd->scmd->result = alt_status << 16;
 			exception = 1;
@@ -2198,8 +2192,8 @@
 }
 
 
-static void
-ProcessfwStChgIsr(struct work_struct *work)
+static void 
+ProcessfwStChgIsr(struct work_struct *work) 
 {
 	struct megasas_instance *instance =
 		container_of(work, struct megasas_instance, work_init);
@@ -2349,7 +2343,7 @@
 	struct megasas_instance *instance;
 	unsigned long flags;
 	irqreturn_t	rc;
-
+      
 	if ( atomic_read( &(( (struct megasas_instance *)devp)->fw_reset_no_pci_access )) )
                 return IRQ_HANDLED;
 
@@ -2849,10 +2843,10 @@
 	pci_free_consistent(instance->pdev,
 				MEGASAS_MAX_PD * sizeof(struct MR_PD_LIST),
 				ci, ci_h);
-
+		
 
 	megasas_return_cmd(instance, cmd);
-
+	
 	return ret;
 }
 /**
@@ -2916,7 +2910,7 @@
 	*/
 
 	if ( (ret == 0) && (ci->ldCount <= (MAX_LOGICAL_DRIVES))){
-
+		
 		memset(instance->ld_ids, 0xff, MEGASAS_MAX_LD_IDS);
 
 		for (ld_index = 0; ld_index < ci->ldCount; ld_index++) {
@@ -2924,13 +2918,13 @@
 				ids = ci->ldList[ld_index].ref.targetId;
 				instance->ld_ids[ids] = ci->ldList[ld_index].ref.targetId;
 			}
-
+								
 		}
 
 	}
 
-	pci_free_consistent(instance->pdev, sizeof(struct MR_LD_LIST), ci, ci_h);
-
+	pci_free_consistent(instance->pdev, sizeof(struct MR_LD_LIST), ci, ci_h); 
+		
 
 	megasas_return_cmd(instance, cmd);
 
@@ -3228,13 +3222,13 @@
 	if (megasas_issue_init_mfi(instance))
 		goto fail_fw_init;
 
-	instance->fw_support_ieee = 0;
-	instance->fw_support_ieee = (instance->instancet->read_fw_status_reg(reg_set) & 0x04000000);
+	instance->fw_support_ieee = 0; 
+	instance->fw_support_ieee = (instance->instancet->read_fw_status_reg(reg_set) & 0x04000000); 
 
 	printk("megasas_init_mfi: fw_support_ieee=%d", instance->fw_support_ieee);
 	if (instance->fw_support_ieee)
 		instance->flag_ieee = 1;
-
+	
 	/** for passthrough
 	* the following function will get the PD LIST.
 	*/
@@ -3672,7 +3666,7 @@
 	instance->ev = NULL;
  	instance->issuepend_done = 1;
 	instance->adprecovery = MEGASAS_HBA_OPERATIONAL;
-	megasas_poll_wait_aen = 0;
+	megasas_poll_wait_aen = 0;	
 
 	instance->evt_detail = pci_alloc_consistent(pdev,
 						    sizeof(struct
@@ -4243,9 +4237,6 @@
 	 * For each user buffer, create a mirror buffer and copy in
 	 */
 	for (i = 0; i < ioc->sge_count; i++) {
-		if (!ioc->sgl[i].iov_len)
-			continue;
-
 		kbuff_arr[i] = dma_alloc_coherent(&instance->pdev->dev,
 						    ioc->sgl[i].iov_len,
 						    &buf_handle, GFP_KERNEL);
@@ -4395,7 +4386,7 @@
 		error = -ERESTARTSYS;
 		goto out_kfree_ioc;
 	}
-
+	
 	// If HBA is undergoing a reset recovery, wait for that to complete
 	// before issuing this command
 
@@ -4520,6 +4511,7 @@
 	int i;
 	int error = 0;
 	compat_uptr_t ptr;
+	u8 *raw_ptr;
 
 	if (clear_user(ioc, sizeof(*ioc)))
 		return -EFAULT;
@@ -4532,18 +4524,10 @@
 	    copy_in_user(&ioc->sge_count, &cioc->sge_count, sizeof(u32)))
 		return -EFAULT;
 
-	/*
-	 * The sense_ptr is used in megasas_mgmt_fw_ioctl only when
-	 * sense_len is not null, so prepare the 64bit value under
-	 * the same condition.
-	 */
 	if (ioc->sense_len) {
-		void __user **sense_ioc_ptr =
-			(void __user **)(ioc->frame.raw + ioc->sense_off);
-		compat_uptr_t *sense_cioc_ptr =
-			(compat_uptr_t *)(cioc->frame.raw + cioc->sense_off);
-		if (get_user(ptr, sense_cioc_ptr) ||
-		    put_user(compat_ptr(ptr), sense_ioc_ptr))
+		raw_ptr = ioc->frame.raw + ioc->sense_off;
+		if (get_user(ptr, (compat_uptr_t *)raw_ptr) ||
+		    put_user(ptr, (unsigned long *)raw_ptr))
 			return -EFAULT;
 	}
 
@@ -4750,7 +4734,7 @@
 		switch (instance->evt_detail->code) {
 		case MR_EVT_PD_INSERTED:
 			if(megasas_get_pd_list(instance) == 0) {
-
+			
 			for (i=0; i < MEGASAS_MAX_PD_CHANNELS; i++) {
 				for (j = 0; j < MEGASAS_MAX_DEV_PER_CHANNEL; j++) {
 					pd_index = (i * MEGASAS_MAX_DEV_PER_CHANNEL) + j;
@@ -4759,17 +4743,17 @@
 						if (!sdev1) {
 							scsi_add_device(host, i, j, 0);
 						}
-					}
+					} 
 					if (sdev1) {
 						scsi_device_put(sdev1);
 					}
-
+					
 				}
 			}
 			}
 			doscan = 0;
 			break;
-
+		
 		case MR_EVT_PD_REMOVED:
 			if(megasas_get_pd_list(instance) == 0) {
 			megasas_get_pd_list(instance);
@@ -4788,7 +4772,7 @@
 						}
 					}
 				}
-
+			
 			}
 			}
 			doscan = 0;
@@ -4806,7 +4790,7 @@
 						if (sdev1) {
 							scsi_device_put(sdev1);
 						}
-
+						
 					} else {
 						if (sdev1) {
 							scsi_remove_device(sdev1);
@@ -4816,7 +4800,7 @@
 				}
 			}
 			doscan = 0;
-			break;
+			break;		
 		case MR_EVT_LD_CREATED:
 			megasas_get_ld_list(instance);
 			for (i=0; i < MEGASAS_MAX_LD_CHANNELS; i++) {
@@ -4827,16 +4811,16 @@
 						if (!sdev1) {
 							scsi_add_device(host, i+2, j, 0);
 						}
-					}
+					} 
 					if (sdev1) {
 						scsi_device_put(sdev1);
 					}
 				}
-			}
+			}		
 			doscan = 0;
 			break;
 		case MR_EVT_CTRL_HOST_BUS_SCAN_REQUESTED:
-		case MR_EVT_FOREIGN_CFG_IMPORTED:
+		case MR_EVT_FOREIGN_CFG_IMPORTED: 
 			doscan = 1;
 			break;
 		default:
@@ -4890,7 +4874,7 @@
 					}
 				}
 			}
-		}
+		}		
 	}
 
 	seq_num = instance->evt_detail->seq_num + 1;
@@ -4899,10 +4883,10 @@
 	class_locale.members.reserved = 0;
 	class_locale.members.locale = MR_EVT_LOCALE_ALL;
 	class_locale.members.class = MR_EVT_CLASS_DEBUG;
-
+	
 	if ( instance->aen_cmd != NULL ) {
 		kfree(ev);
-		return ;
+		return ; 
 	}
 
 	mutex_lock(&instance->aen_mutex);
diff -r 15109ec2f661 drivers/scsi/megaraid/megaraid_sas.h
--- b/drivers/scsi/megaraid/megaraid_sas.h	Wed Aug 17 13:31:06 2011 +0100
+++ a/drivers/scsi/megaraid/megaraid_sas.h	Wed Aug 17 13:09:17 2011 +0100
@@ -778,7 +778,7 @@
 
 #define MFI_REPLY_1078_MESSAGE_INTERRUPT	0x80000000
 #define MFI_REPLY_GEN2_MESSAGE_INTERRUPT	0x00000001
-#define MFI_GEN2_ENABLE_INTERRUPT_MASK		0x00000001
+#define MFI_GEN2_ENABLE_INTERRUPT_MASK		0x00000001 
 #define MFI_REPLY_SKINNY_MESSAGE_INTERRUPT	0x40000000
 #define MFI_SKINNY_ENABLE_INTERRUPT_MASK	(0x00000001)
 #define MFI_1068_PCSR_OFFSET			0x84
diff -r 15109ec2f661 drivers/scsi/mpt2sas/mpt2sas_base.c
--- b/drivers/scsi/mpt2sas/mpt2sas_base.c	Wed Aug 17 13:31:06 2011 +0100
+++ a/drivers/scsi/mpt2sas/mpt2sas_base.c	Wed Aug 17 13:09:17 2011 +0100
@@ -2029,9 +2029,9 @@
 		/* adjust hba_queue_depth, reply_free_queue_depth,
 		 * and queue_size
 		 */
-		ioc->hba_queue_depth -= (queue_diff / 2);
-		ioc->reply_free_queue_depth -= (queue_diff / 2);
-		queue_size = facts->MaxReplyDescriptorPostQueueDepth;
+		ioc->hba_queue_depth -= queue_diff;
+		ioc->reply_free_queue_depth -= queue_diff;
+		queue_size -= queue_diff;
 	}
 	ioc->reply_post_queue_depth = queue_size;
 
@@ -3698,8 +3698,6 @@
 static void
 _base_reset_handler(struct MPT2SAS_ADAPTER *ioc, int reset_phase)
 {
-	mpt2sas_scsih_reset_handler(ioc, reset_phase);
-	mpt2sas_ctl_reset_handler(ioc, reset_phase);
 	switch (reset_phase) {
 	case MPT2_IOC_PRE_RESET:
 		dtmprintk(ioc, printk(MPT2SAS_DEBUG_FMT "%s: "
@@ -3730,6 +3728,8 @@
 		    "MPT2_IOC_DONE_RESET\n", ioc->name, __func__));
 		break;
 	}
+	mpt2sas_scsih_reset_handler(ioc, reset_phase);
+	mpt2sas_ctl_reset_handler(ioc, reset_phase);
 }
 
 /**
@@ -3783,7 +3783,6 @@
 {
 	int r;
 	unsigned long flags;
-	u8 pe_complete = ioc->wait_for_port_enable_to_complete;
 
 	dtmprintk(ioc, printk(MPT2SAS_DEBUG_FMT "%s: enter\n", ioc->name,
 	    __func__));
@@ -3808,14 +3807,6 @@
 	if (r)
 		goto out;
 	_base_reset_handler(ioc, MPT2_IOC_AFTER_RESET);
-
-	/* If this hard reset is called while port enable is active, then
-	 * there is no reason to call make_ioc_operational
-	 */
-	if (pe_complete) {
-		r = -EFAULT;
-		goto out;
-	}
 	r = _base_make_ioc_operational(ioc, sleep_flag);
 	if (!r)
 		_base_reset_handler(ioc, MPT2_IOC_DONE_RESET);
diff -r 15109ec2f661 drivers/scsi/mpt2sas/mpt2sas_base.h
--- b/drivers/scsi/mpt2sas/mpt2sas_base.h	Wed Aug 17 13:31:06 2011 +0100
+++ a/drivers/scsi/mpt2sas/mpt2sas_base.h	Wed Aug 17 13:09:17 2011 +0100
@@ -69,11 +69,11 @@
 #define MPT2SAS_DRIVER_NAME		"mpt2sas"
 #define MPT2SAS_AUTHOR	"LSI Corporation <DL-MPTFusionLinux@lsi.com>"
 #define MPT2SAS_DESCRIPTION	"LSI MPT Fusion SAS 2.0 Device Driver"
-#define MPT2SAS_DRIVER_VERSION		"04.100.01.04"
+#define MPT2SAS_DRIVER_VERSION		"04.100.01.03"
 #define MPT2SAS_MAJOR_VERSION		04
 #define MPT2SAS_MINOR_VERSION		100
 #define MPT2SAS_BUILD_VERSION		01
-#define MPT2SAS_RELEASE_VERSION		04
+#define MPT2SAS_RELEASE_VERSION		03
 
 /*
  * Set MPT2SAS_SG_DEPTH value based on user input.
diff -r 15109ec2f661 drivers/scsi/mpt2sas/mpt2sas_ctl.c
--- b/drivers/scsi/mpt2sas/mpt2sas_ctl.c	Wed Aug 17 13:31:06 2011 +0100
+++ a/drivers/scsi/mpt2sas/mpt2sas_ctl.c	Wed Aug 17 13:09:17 2011 +0100
@@ -636,13 +636,6 @@
 	data_out_sz = karg.data_out_size;
 	data_in_sz = karg.data_in_size;
 
-	/* Check for overflow and wraparound */
-	if (karg.data_sge_offset * 4 > ioc->request_sz ||
-	    karg.data_sge_offset > (UINT_MAX / 4)) {
-		ret = -EINVAL;
-		goto out;
-	}
-
 	/* copy in request message frame from user */
 	if (copy_from_user(mpi_request, mf, karg.data_sge_offset*4)) {
 		printk(KERN_ERR "failure at %s:%d/%s()!\n", __FILE__, __LINE__,
@@ -1884,7 +1877,7 @@
 	Mpi2DiagBufferPostReply_t *mpi_reply;
 	int rc, i;
 	u8 buffer_type;
-	unsigned long timeleft, request_size, copy_size;
+	unsigned long timeleft;
 	u16 smid;
 	u16 ioc_status;
 	u8 issue_reset = 0;
@@ -1920,8 +1913,6 @@
 		return -ENOMEM;
 	}
 
-	request_size = ioc->diag_buffer_sz[buffer_type];
-
 	if ((karg.starting_offset % 4) || (karg.bytes_to_read % 4)) {
 		printk(MPT2SAS_ERR_FMT "%s: either the starting_offset "
 		    "or bytes_to_read are not 4 byte aligned\n", ioc->name,
@@ -1929,23 +1920,13 @@
 		return -EINVAL;
 	}
 
-	if (karg.starting_offset > request_size)
-		return -EINVAL;
-
 	diag_data = (void *)(request_data + karg.starting_offset);
 	dctlprintk(ioc, printk(MPT2SAS_DEBUG_FMT "%s: diag_buffer(%p), "
 	    "offset(%d), sz(%d)\n", ioc->name, __func__,
 	    diag_data, karg.starting_offset, karg.bytes_to_read));
 
-	/* Truncate data on requests that are too large */
-	if ((diag_data + karg.bytes_to_read < diag_data) ||
-	    (diag_data + karg.bytes_to_read > request_data + request_size))
-		copy_size = request_size - karg.starting_offset;
-	else
-		copy_size = karg.bytes_to_read;
-
 	if (copy_to_user((void __user *)uarg->diagnostic_data,
-	    diag_data, copy_size)) {
+	    diag_data, karg.bytes_to_read)) {
 		printk(MPT2SAS_ERR_FMT "%s: Unable to write "
 		    "mpt_diag_read_buffer_t data @ %p\n", ioc->name,
 		    __func__, diag_data);
diff -r 15109ec2f661 drivers/scsi/mpt2sas/mpt2sas_scsih.c
--- b/drivers/scsi/mpt2sas/mpt2sas_scsih.c	Wed Aug 17 13:31:06 2011 +0100
+++ a/drivers/scsi/mpt2sas/mpt2sas_scsih.c	Wed Aug 17 13:09:17 2011 +0100
@@ -2727,6 +2727,9 @@
 	u16 handle;
 
 	for (i = 0 ; i < event_data->NumEntries; i++) {
+		if (event_data->PHY[i].PhyStatus &
+		    MPI2_EVENT_SAS_TOPO_PHYSTATUS_VACANT)
+			continue;
 		handle = le16_to_cpu(event_data->PHY[i].AttachedDevHandle);
 		if (!handle)
 			continue;
@@ -4236,7 +4239,7 @@
 	int i;
 	u16 parent_handle, handle;
 	u16 reason_code;
-	u8 phy_number, max_phys;
+	u8 phy_number;
 	struct _sas_node *sas_expander;
 	struct _sas_device *sas_device;
 	u64 sas_address;
@@ -4274,13 +4277,11 @@
 	sas_expander = mpt2sas_scsih_expander_find_by_handle(ioc,
 	    parent_handle);
 	spin_unlock_irqrestore(&ioc->sas_node_lock, flags);
-	if (sas_expander) {
+	if (sas_expander)
 		sas_address = sas_expander->sas_address;
-		max_phys = sas_expander->num_phys;
-	} else if (parent_handle < ioc->sas_hba.num_phys) {
+	else if (parent_handle < ioc->sas_hba.num_phys)
 		sas_address = ioc->sas_hba.sas_address;
-		max_phys = ioc->sas_hba.num_phys;
-	} else
+	else
 		return;
 
 	/* handle siblings events */
@@ -4293,8 +4294,6 @@
 		if (ioc->shost_recovery)
 			return;
 		phy_number = event_data->StartPhyNum + i;
-		if (phy_number >= max_phys)
-			continue;
 		reason_code = event_data->PHY[i].PhyStatus &
 		    MPI2_EVENT_SAS_TOPO_RC_MASK;
 		if ((event_data->PHY[i].PhyStatus &
diff -r 15109ec2f661 drivers/scsi/qla2xxx/qla_attr.c
--- b/drivers/scsi/qla2xxx/qla_attr.c	Wed Aug 17 13:31:06 2011 +0100
+++ a/drivers/scsi/qla2xxx/qla_attr.c	Wed Aug 17 13:09:17 2011 +0100
@@ -318,8 +318,7 @@
 		else if (start == (ha->flt_region_boot * 4) ||
 		    start == (ha->flt_region_fw * 4))
 			valid = 1;
-		else if (IS_QLA24XX_TYPE(ha) || IS_QLA25XX(ha)
-			|| IS_QLA81XX(ha))
+		else if (IS_QLA25XX(ha) || IS_QLA81XX(ha))
 		    valid = 1;
 		if (!valid) {
 			qla_printk(KERN_WARNING, ha,
@@ -1499,15 +1498,6 @@
 	if (!fcport)
 		return;
 
-	/*
-	 * Transport has effectively 'deleted' the rport, clear
-	 * all local references.
-	 */
-	spin_lock_irq(host->host_lock);
-	fcport->rport = fcport->drport = NULL;
-	*((fc_port_t **)rport->dd_data) = NULL;
-	spin_unlock_irq(host->host_lock);
-
 	if (test_bit(ABORT_ISP_ACTIVE, &fcport->vha->dpc_flags))
 		return;
 
@@ -1515,6 +1505,15 @@
 		qla2x00_abort_all_cmds(fcport->vha, DID_NO_CONNECT << 16);
 		return;
 	}
+
+	/*
+	 * Transport has effectively 'deleted' the rport, clear
+	 * all local references.
+	 */
+	spin_lock_irq(host->host_lock);
+	fcport->rport = NULL;
+	*((fc_port_t **)rport->dd_data) = NULL;
+	spin_unlock_irq(host->host_lock);
 }
 
 static void
diff -r 15109ec2f661 drivers/scsi/qla2xxx/qla_def.h
--- b/drivers/scsi/qla2xxx/qla_def.h	Wed Aug 17 13:31:06 2011 +0100
+++ a/drivers/scsi/qla2xxx/qla_def.h	Wed Aug 17 13:09:17 2011 +0100
@@ -191,7 +191,6 @@
  * SCSI Request Block
  */
 typedef struct srb {
-	atomic_t ref_count;
 	struct fc_port *fcport;
 	uint32_t handle;
 
@@ -2437,8 +2436,7 @@
 				(ha)->flags.msix_enabled)
 #define IS_FAC_REQUIRED(ha)	(IS_QLA81XX(ha))
 #define IS_NOCACHE_VPD_TYPE(ha)	(IS_QLA81XX(ha))
-#define IS_ALOGIO_CAPABLE(ha)	((IS_QLA23XX(ha) && ql2xasyncenable) || \
-				IS_FWI2_CAPABLE(ha))
+#define IS_ALOGIO_CAPABLE(ha)	(IS_QLA23XX(ha) || IS_FWI2_CAPABLE(ha))
 
 #define IS_IIDMA_CAPABLE(ha)    ((ha)->device_type & DT_IIDMA)
 #define IS_FWI2_CAPABLE(ha)     ((ha)->device_type & DT_FWI2)
diff -r 15109ec2f661 drivers/scsi/qla2xxx/qla_gbl.h
--- b/drivers/scsi/qla2xxx/qla_gbl.h	Wed Aug 17 13:31:06 2011 +0100
+++ a/drivers/scsi/qla2xxx/qla_gbl.h	Wed Aug 17 13:09:17 2011 +0100
@@ -83,7 +83,6 @@
 extern int ql2xmultique_tag;
 extern int ql2xfwloadbin;
 extern int ql2xetsenable;
-extern int ql2xasyncenable;
 
 extern int qla2x00_loop_reset(scsi_qla_host_t *);
 extern void qla2x00_abort_all_cmds(scsi_qla_host_t *, int);
diff -r 15109ec2f661 drivers/scsi/qla2xxx/qla_init.c
--- b/drivers/scsi/qla2xxx/qla_init.c	Wed Aug 17 13:31:06 2011 +0100
+++ a/drivers/scsi/qla2xxx/qla_init.c	Wed Aug 17 13:09:17 2011 +0100
@@ -57,8 +57,9 @@
 	req->outstanding_cmds[sp->handle] = NULL;
 	ctx = sp->ctx;
 	ctx->timeout(sp);
-	ctx->free(sp);
 	spin_unlock_irqrestore(&ha->hardware_lock, flags);
+
+	ctx->free(sp);
 }
 
 void
@@ -112,22 +113,14 @@
 {
 	fc_port_t *fcport = sp->fcport;
 	struct srb_logio *lio = sp->ctx;
-	uint16_t data[2];
 
 	DEBUG2(printk(KERN_WARNING
-	    "scsi(%ld:%x): Async-%s timeout - portid=%02x%02x%02x.\n",
-	    fcport->vha->host_no, sp->handle, lio->ctx.name,
-	    fcport->d_id.b.domain, fcport->d_id.b.area, fcport->d_id.b.al_pa));
+	    "scsi(%ld:%x): Async-%s timeout.\n",
+	    fcport->vha->host_no, sp->handle, lio->ctx.name));
 
 	fcport->flags &= ~FCF_ASYNC_SENT;
-	if (lio->ctx.type == SRB_LOGIN_CMD) {
+	if (lio->ctx.type == SRB_LOGIN_CMD)
 		qla2x00_post_async_logout_work(fcport->vha, fcport, NULL);
-		/* Retry as needed. */
-		data[0] = MBS_COMMAND_ERROR;
-		data[1] = lio->flags & SRB_LOGIN_RETRIED ?
-		    QLA_LOGIO_LOGIN_RETRIED: 0;
-		qla2x00_post_async_login_done_work(fcport->vha, fcport, data);
-	}
 }
 
 static void
@@ -297,11 +290,10 @@
 		if (data[1] & QLA_LOGIO_LOGIN_RETRIED)
 			set_bit(RELOGIN_NEEDED, &vha->dpc_flags);
 		else
-			qla2x00_mark_device_lost(vha, fcport, 1, 1);
+			qla2x00_mark_device_lost(vha, fcport, 1, 0);
 		break;
 	case MBS_PORT_ID_USED:
 		fcport->loop_id = data[1];
-		qla2x00_post_async_logout_work(vha, fcport, NULL);
 		qla2x00_post_async_login_work(vha, fcport, NULL);
 		break;
 	case MBS_LOOP_ID_USED:
@@ -309,7 +301,7 @@
 		rval = qla2x00_find_new_loop_id(vha, fcport);
 		if (rval != QLA_SUCCESS) {
 			fcport->flags &= ~FCF_ASYNC_SENT;
-			qla2x00_mark_device_lost(vha, fcport, 1, 1);
+			qla2x00_mark_device_lost(vha, fcport, 1, 0);
 			break;
 		}
 		qla2x00_post_async_login_work(vha, fcport, NULL);
@@ -341,7 +333,7 @@
 	if (data[1] & QLA_LOGIO_LOGIN_RETRIED)
 		set_bit(RELOGIN_NEEDED, &vha->dpc_flags);
 	else
-		qla2x00_mark_device_lost(vha, fcport, 1, 1);
+		qla2x00_mark_device_lost(vha, fcport, 1, 0);
 
 	return QLA_SUCCESS;
 }
@@ -2218,7 +2210,7 @@
 	ha->retry_count = nv->retry_count;
 
 	/* Set minimum login_timeout to 4 seconds. */
-	if (nv->login_timeout != ql2xlogintimeout)
+	if (nv->login_timeout < ql2xlogintimeout)
 		nv->login_timeout = ql2xlogintimeout;
 	if (nv->login_timeout < 4)
 		nv->login_timeout = 4;
@@ -2461,8 +2453,7 @@
 			set_bit(LOCAL_LOOP_UPDATE, &vha->dpc_flags);
 		if (test_bit(RSCN_UPDATE, &save_flags)) {
 			set_bit(RSCN_UPDATE, &vha->dpc_flags);
-			if (!IS_ALOGIO_CAPABLE(ha))
-				vha->flags.rscn_queue_overflow = 1;
+			vha->flags.rscn_queue_overflow = 1;
 		}
 	}
 
@@ -3021,9 +3012,8 @@
 		if (qla2x00_is_reserved_id(vha, loop_id))
 			continue;
 
-		if (ha->current_topology == ISP_CFG_FL &&
-		    (atomic_read(&vha->loop_down_timer) ||
-		     LOOP_TRANSITION(vha))) {
+		if (atomic_read(&vha->loop_down_timer) ||
+		    LOOP_TRANSITION(vha)) {
 			atomic_set(&vha->loop_down_timer, 0);
 			set_bit(LOOP_RESYNC_NEEDED, &vha->dpc_flags);
 			set_bit(LOCAL_LOOP_UPDATE, &vha->dpc_flags);
diff -r 15109ec2f661 drivers/scsi/qla2xxx/qla_isr.c
--- b/drivers/scsi/qla2xxx/qla_isr.c	Wed Aug 17 13:31:06 2011 +0100
+++ a/drivers/scsi/qla2xxx/qla_isr.c	Wed Aug 17 13:09:17 2011 +0100
@@ -915,15 +915,12 @@
 	    QLA_LOGIO_LOGIN_RETRIED: 0;
 	if (mbx->entry_status) {
 		DEBUG2(printk(KERN_WARNING
-		    "scsi(%ld:%x): Async-%s error entry - portid=%02x%02x%02x "
-		    "entry-status=%x status=%x state-flag=%x "
-		    "status-flags=%x.\n",
+		    "scsi(%ld:%x): Async-%s error entry - entry-status=%x "
+		    "status=%x state-flag=%x status-flags=%x.\n",
 		    fcport->vha->host_no, sp->handle, type,
-		    fcport->d_id.b.domain, fcport->d_id.b.area,
-		    fcport->d_id.b.al_pa, mbx->entry_status,
-		    le16_to_cpu(mbx->status), le16_to_cpu(mbx->state_flags),
+		    mbx->entry_status, le16_to_cpu(mbx->status),
+		    le16_to_cpu(mbx->state_flags),
 		    le16_to_cpu(mbx->status_flags)));
-
 		DEBUG2(qla2x00_dump_buffer((uint8_t *)mbx, sizeof(*mbx)));
 
 		goto logio_done;
@@ -935,18 +932,16 @@
 		status = 0;
 	if (!status && le16_to_cpu(mbx->mb0) == MBS_COMMAND_COMPLETE) {
 		DEBUG2(printk(KERN_DEBUG
-		    "scsi(%ld:%x): Async-%s complete - portid=%02x%02x%02x "
-		    "mbx1=%x.\n",
+		    "scsi(%ld:%x): Async-%s complete - mbx1=%x.\n",
 		    fcport->vha->host_no, sp->handle, type,
-		    fcport->d_id.b.domain, fcport->d_id.b.area,
-		    fcport->d_id.b.al_pa, le16_to_cpu(mbx->mb1)));
+		    le16_to_cpu(mbx->mb1)));
 
 		data[0] = MBS_COMMAND_COMPLETE;
 		if (lio->ctx.type == SRB_LOGIN_CMD) {
 			fcport->port_type = FCT_TARGET;
 			if (le16_to_cpu(mbx->mb1) & BIT_0)
 				fcport->port_type = FCT_INITIATOR;
-			else if (le16_to_cpu(mbx->mb1) & BIT_1)
+			if (le16_to_cpu(mbx->mb1) & BIT_1)
 				fcport->flags |= FCF_FCP2_DEVICE;
 		}
 		goto logio_done;
@@ -965,10 +960,9 @@
 	}
 
 	DEBUG2(printk(KERN_WARNING
-	    "scsi(%ld:%x): Async-%s failed - portid=%02x%02x%02x status=%x "
-	    "mb0=%x mb1=%x mb2=%x mb6=%x mb7=%x.\n",
-	    fcport->vha->host_no, sp->handle, type, fcport->d_id.b.domain,
-	    fcport->d_id.b.area, fcport->d_id.b.al_pa, status,
+	    "scsi(%ld:%x): Async-%s failed - status=%x mb0=%x mb1=%x mb2=%x "
+	    "mb6=%x mb7=%x.\n",
+	    fcport->vha->host_no, sp->handle, type, status,
 	    le16_to_cpu(mbx->mb0), le16_to_cpu(mbx->mb1),
 	    le16_to_cpu(mbx->mb2), le16_to_cpu(mbx->mb6),
 	    le16_to_cpu(mbx->mb7)));
@@ -1098,11 +1092,9 @@
 	    QLA_LOGIO_LOGIN_RETRIED: 0;
 	if (logio->entry_status) {
 		DEBUG2(printk(KERN_WARNING
-		    "scsi(%ld:%x): Async-%s error entry - "
-		    "portid=%02x%02x%02x entry-status=%x.\n",
+		    "scsi(%ld:%x): Async-%s error entry - entry-status=%x.\n",
 		    fcport->vha->host_no, sp->handle, type,
-		    fcport->d_id.b.domain, fcport->d_id.b.area,
-		    fcport->d_id.b.al_pa, logio->entry_status));
+		    logio->entry_status));
 		DEBUG2(qla2x00_dump_buffer((uint8_t *)logio, sizeof(*logio)));
 
 		goto logio_done;
@@ -1110,11 +1102,8 @@
 
 	if (le16_to_cpu(logio->comp_status) == CS_COMPLETE) {
 		DEBUG2(printk(KERN_DEBUG
-		    "scsi(%ld:%x): Async-%s complete - portid=%02x%02x%02x "
-		    "iop0=%x.\n",
+		    "scsi(%ld:%x): Async-%s complete - iop0=%x.\n",
 		    fcport->vha->host_no, sp->handle, type,
-		    fcport->d_id.b.domain, fcport->d_id.b.area,
-		    fcport->d_id.b.al_pa,
 		    le32_to_cpu(logio->io_parameter[0])));
 
 		data[0] = MBS_COMMAND_COMPLETE;
@@ -1146,16 +1135,20 @@
 	case LSC_SCODE_NPORT_USED:
 		data[0] = MBS_LOOP_ID_USED;
 		break;
+	case LSC_SCODE_CMD_FAILED:
+		if ((iop[1] & 0xff) == 0x05) {
+			data[0] = MBS_NOT_LOGGED_IN;
+			break;
+		}
+		/* Fall through. */
 	default:
 		data[0] = MBS_COMMAND_ERROR;
 		break;
 	}
 
 	DEBUG2(printk(KERN_WARNING
-	    "scsi(%ld:%x): Async-%s failed - portid=%02x%02x%02x comp=%x "
-	    "iop0=%x iop1=%x.\n",
-	    fcport->vha->host_no, sp->handle, type, fcport->d_id.b.domain,
-	    fcport->d_id.b.area, fcport->d_id.b.al_pa,
+	    "scsi(%ld:%x): Async-%s failed - comp=%x iop0=%x iop1=%x.\n",
+	    fcport->vha->host_no, sp->handle, type,
 	    le16_to_cpu(logio->comp_status),
 	    le32_to_cpu(logio->io_parameter[0]),
 	    le32_to_cpu(logio->io_parameter[1])));
@@ -1245,9 +1238,8 @@
 }
 
 static inline void
-
-qla2x00_handle_sense(srb_t *sp, uint8_t *sense_data, uint32_t par_sense_len,
-    uint32_t sense_len, struct rsp_que *rsp)
+qla2x00_handle_sense(srb_t *sp, uint8_t *sense_data, uint32_t sense_len,
+	struct rsp_que *rsp)
 {
 	struct scsi_cmnd *cp = sp->cmd;
 
@@ -1256,8 +1248,8 @@
 
 	sp->request_sense_length = sense_len;
 	sp->request_sense_ptr = cp->sense_buffer;
-	if (sp->request_sense_length > par_sense_len)
-		sense_len = par_sense_len;
+	if (sp->request_sense_length > 32)
+		sense_len = 32;
 
 	memcpy(cp->sense_buffer, sense_data, sense_len);
 
@@ -1292,8 +1284,7 @@
 	uint16_t	ox_id;
 	uint8_t		lscsi_status;
 	int32_t		resid;
-	uint32_t sense_len, par_sense_len, rsp_info_len, resid_len,
-	    fw_resid_len;
+	uint32_t	sense_len, rsp_info_len, resid_len, fw_resid_len;
 	uint8_t		*rsp_info, *sense_data;
 	struct qla_hw_data *ha = vha->hw;
 	uint32_t handle;
@@ -1350,8 +1341,7 @@
 	fcport = sp->fcport;
 
 	ox_id = 0;
-	sense_len = par_sense_len = rsp_info_len = resid_len =
-	    fw_resid_len = 0;
+	sense_len = rsp_info_len = resid_len = fw_resid_len = 0;
 	if (IS_FWI2_CAPABLE(ha)) {
 		if (scsi_status & SS_SENSE_LEN_VALID)
 			sense_len = le32_to_cpu(sts24->sense_len);
@@ -1365,7 +1355,6 @@
 		sense_data = sts24->data;
 		host_to_fcp_swap(sts24->data, sizeof(sts24->data));
 		ox_id = le16_to_cpu(sts24->ox_id);
-		par_sense_len = sizeof(sts24->data);
 	} else {
 		if (scsi_status & SS_SENSE_LEN_VALID)
 			sense_len = le16_to_cpu(sts->req_sense_length);
@@ -1374,16 +1363,13 @@
 		resid_len = le32_to_cpu(sts->residual_length);
 		rsp_info = sts->rsp_info;
 		sense_data = sts->req_sense_data;
-		par_sense_len = sizeof(sts->req_sense_data);
 	}
 
 	/* Check for any FCP transport errors. */
 	if (scsi_status & SS_RESPONSE_INFO_LEN_VALID) {
 		/* Sense data lies beyond any FCP RESPONSE data. */
-		if (IS_FWI2_CAPABLE(ha)) {
+		if (IS_FWI2_CAPABLE(ha))
 			sense_data += rsp_info_len;
-			par_sense_len -= rsp_info_len;
-		}
 		if (rsp_info_len > 3 && rsp_info[3]) {
 			DEBUG2(qla_printk(KERN_INFO, ha,
 			    "scsi(%ld:%d:%d): FCP I/O protocol failure "
@@ -1443,8 +1429,7 @@
 		if (!(scsi_status & SS_SENSE_LEN_VALID))
 			break;
 
-		qla2x00_handle_sense(sp, sense_data, par_sense_len, sense_len,
-		    rsp);
+		qla2x00_handle_sense(sp, sense_data, sense_len, rsp);
 		break;
 
 	case CS_DATA_UNDERRUN:
@@ -1507,8 +1492,7 @@
 			if (!(scsi_status & SS_SENSE_LEN_VALID))
 				break;
 
-			qla2x00_handle_sense(sp, sense_data, par_sense_len,
-			    sense_len, rsp);
+			qla2x00_handle_sense(sp, sense_data, sense_len, rsp);
 		}
 		break;
 
@@ -1543,9 +1527,6 @@
 		break;
 
 	case CS_RESET:
-		cp->result = DID_TRANSPORT_DISRUPTED << 16;
-		break;
-
 	case CS_ABORTED:
 		cp->result = DID_RESET << 16;
 		break;
@@ -1937,7 +1918,6 @@
 	struct rsp_que *rsp;
 	struct device_reg_24xx __iomem *reg;
 	struct scsi_qla_host *vha;
-	unsigned long flags;
 
 	rsp = (struct rsp_que *) dev_id;
 	if (!rsp) {
@@ -1948,7 +1928,7 @@
 	ha = rsp->hw;
 	reg = &ha->iobase->isp24;
 
-	spin_lock_irqsave(&ha->hardware_lock, flags);
+	spin_lock_irq(&ha->hardware_lock);
 
 	vha = pci_get_drvdata(ha->pdev);
 	qla24xx_process_response_queue(vha, rsp);
@@ -1956,7 +1936,7 @@
 		WRT_REG_DWORD(&reg->hccr, HCCRX_CLR_RISC_INT);
 		RD_REG_DWORD_RELAXED(&reg->hccr);
 	}
-	spin_unlock_irqrestore(&ha->hardware_lock, flags);
+	spin_unlock_irq(&ha->hardware_lock);
 
 	return IRQ_HANDLED;
 }
diff -r 15109ec2f661 drivers/scsi/qla2xxx/qla_mbx.c
--- b/drivers/scsi/qla2xxx/qla_mbx.c	Wed Aug 17 13:31:06 2011 +0100
+++ a/drivers/scsi/qla2xxx/qla_mbx.c	Wed Aug 17 13:09:17 2011 +0100
@@ -833,8 +833,8 @@
 
 	l = l;
 	vha = fcport->vha;
-	req = vha->hw->req_q_map[0];
-	rsp = req->rsp;
+	req = vha->hw->req_q_map[tag];
+	rsp = vha->hw->rsp_q_map[tag];
 	mcp->mb[0] = MBC_ABORT_TARGET;
 	mcp->out_mb = MBX_9|MBX_2|MBX_1|MBX_0;
 	if (HAS_EXTENDED_IDS(vha->hw)) {
@@ -882,8 +882,8 @@
 	DEBUG11(printk("%s(%ld): entered.\n", __func__, fcport->vha->host_no));
 
 	vha = fcport->vha;
-	req = vha->hw->req_q_map[0];
-	rsp = req->rsp;
+	req = vha->hw->req_q_map[tag];
+	rsp = vha->hw->rsp_q_map[tag];
 	mcp->mb[0] = MBC_LUN_RESET;
 	mcp->out_mb = MBX_9|MBX_3|MBX_2|MBX_1|MBX_0;
 	if (HAS_EXTENDED_IDS(vha->hw))
diff -r 15109ec2f661 drivers/scsi/qla2xxx/qla_mid.c
--- b/drivers/scsi/qla2xxx/qla_mid.c	Wed Aug 17 13:31:06 2011 +0100
+++ a/drivers/scsi/qla2xxx/qla_mid.c	Wed Aug 17 13:09:17 2011 +0100
@@ -135,8 +135,7 @@
 
 	/* Check if physical ha port is Up */
 	if (atomic_read(&base_vha->loop_state) == LOOP_DOWN  ||
-		atomic_read(&base_vha->loop_state) == LOOP_DEAD ||
-		!(ha->current_topology & ISP_CFG_F)) {
+		atomic_read(&base_vha->loop_state) == LOOP_DEAD) {
 		vha->vp_err_state =  VP_ERR_PORTDWN;
 		fc_vport_set_state(vha->fc_vport, FC_VPORT_LINKDOWN);
 		goto enable_failed;
diff -r 15109ec2f661 drivers/scsi/qla2xxx/qla_os.c
--- b/drivers/scsi/qla2xxx/qla_os.c	Wed Aug 17 13:31:06 2011 +0100
+++ a/drivers/scsi/qla2xxx/qla_os.c	Wed Aug 17 13:09:17 2011 +0100
@@ -115,18 +115,6 @@
 		"Enables firmware ETS burst."
 		"Default is 0 - skip ETS enablement.");
 
-int ql2xasyncenable;
-module_param(ql2xasyncenable, int, S_IRUGO|S_IRUSR);
-MODULE_PARM_DESC(ql2xasyncenable,
-		"Enables usage of Async-login/adisc on ISP23xx."
-		"Default is 0 - use serialized mailbox commands.");
-
-int ql2xtargetreset = 1;
-module_param(ql2xtargetreset, int, S_IRUGO|S_IRUSR);
-MODULE_PARM_DESC(ql2xtargetreset,
-		 "Enable target reset."
-		 "Default is 1 - use hw defaults.");
-
 /*
  * SCSI host template entry points
  */
@@ -474,7 +462,6 @@
 	if (!sp)
 		return sp;
 
-	atomic_set(&sp->ref_count, 1);
 	sp->fcport = fcport;
 	sp->cmd = cmd;
 	sp->flags = 0;
@@ -747,12 +734,6 @@
 	return (return_status);
 }
 
-static void
-sp_get(struct srb *sp)
-{
-	atomic_inc(&sp->ref_count);
-}
-
 /**************************************************************************
 * qla2xxx_eh_abort
 *
@@ -773,60 +754,72 @@
 {
 	scsi_qla_host_t *vha = shost_priv(cmd->device->host);
 	srb_t *sp;
-	int ret;
+	int ret, i;
 	unsigned int id, lun;
+	unsigned long serial;
 	unsigned long flags;
 	int wait = 0;
 	struct qla_hw_data *ha = vha->hw;
+	struct req_que *req = vha->req;
+	srb_t *spt;
+
+	fc_block_scsi_eh(cmd);
 
 	if (!CMD_SP(cmd))
 		return SUCCESS;
 
-	ret = fc_block_scsi_eh(cmd);
-	if (ret != SUCCESS)
-		return ret;
+	ret = SUCCESS;
 
 	id = cmd->device->id;
 	lun = cmd->device->lun;
-
-	spin_lock_irqsave(&ha->hardware_lock, flags);
-	sp = (srb_t *) CMD_SP(cmd);
-	if (!sp) {
-		spin_unlock_irqrestore(&ha->hardware_lock, flags);
+	serial = cmd->serial_number;
+	spt = (srb_t *) CMD_SP(cmd);
+	if (!spt)
 		return SUCCESS;
+
+	/* Check active list for command command. */
+	spin_lock_irqsave(&ha->hardware_lock, flags);
+	for (i = 1; i < MAX_OUTSTANDING_COMMANDS; i++) {
+		sp = req->outstanding_cmds[i];
+
+		if (sp == NULL)
+			continue;
+		if (sp->ctx)
+			continue;
+		if (sp->cmd != cmd)
+			continue;
+
+		DEBUG2(printk("%s(%ld): aborting sp %p from RISC."
+		" pid=%ld.\n", __func__, vha->host_no, sp, serial));
+
+		spin_unlock_irqrestore(&ha->hardware_lock, flags);
+		if (ha->isp_ops->abort_command(sp)) {
+			DEBUG2(printk("%s(%ld): abort_command "
+			"mbx failed.\n", __func__, vha->host_no));
+			ret = FAILED;
+		} else {
+			DEBUG3(printk("%s(%ld): abort_command "
+			"mbx success.\n", __func__, vha->host_no));
+			wait = 1;
+		}
+		spin_lock_irqsave(&ha->hardware_lock, flags);
+		break;
 	}
-
-	DEBUG2(printk("%s(%ld): aborting sp %p from RISC.",
-	    __func__, vha->host_no, sp));
-
-	/* Get a reference to the sp and drop the lock.*/
-	sp_get(sp);
-
 	spin_unlock_irqrestore(&ha->hardware_lock, flags);
-	if (ha->isp_ops->abort_command(sp)) {
-		DEBUG2(printk("%s(%ld): abort_command "
-		"mbx failed.\n", __func__, vha->host_no));
-		ret = FAILED;
-	} else {
-		DEBUG3(printk("%s(%ld): abort_command "
-		"mbx success.\n", __func__, vha->host_no));
-		wait = 1;
-	}
-	qla2x00_sp_compl(ha, sp);
 
 	/* Wait for the command to be returned. */
 	if (wait) {
 		if (qla2x00_eh_wait_on_command(cmd) != QLA_SUCCESS) {
 			qla_printk(KERN_ERR, ha,
-			    "scsi(%ld:%d:%d): Abort handler timed out -- %x.\n",
-			    vha->host_no, id, lun, ret);
+			    "scsi(%ld:%d:%d): Abort handler timed out -- %lx "
+			    "%x.\n", vha->host_no, id, lun, serial, ret);
 			ret = FAILED;
 		}
 	}
 
 	qla_printk(KERN_INFO, ha,
-	    "scsi(%ld:%d:%d): Abort command issued -- %d %x.\n",
-	    vha->host_no, id, lun, wait, ret);
+	    "scsi(%ld:%d:%d): Abort command issued -- %d %lx %x.\n",
+	    vha->host_no, id, lun, wait, serial, ret);
 
 	return ret;
 }
@@ -901,9 +894,7 @@
 	fc_port_t *fcport = (struct fc_port *) cmd->device->hostdata;
 	int err;
 
-	err = fc_block_scsi_eh(cmd);
-	if (err != SUCCESS)
-		return err;
+	fc_block_scsi_eh(cmd);
 
 	if (!fcport)
 		return FAILED;
@@ -978,21 +969,17 @@
 {
 	scsi_qla_host_t *vha = shost_priv(cmd->device->host);
 	fc_port_t *fcport = (struct fc_port *) cmd->device->hostdata;
-	int ret;
+	int ret = FAILED;
 	unsigned int id, lun;
 	unsigned long serial;
 	srb_t *sp = (srb_t *) CMD_SP(cmd);
 
-	ret = fc_block_scsi_eh(cmd);
-	if (ret != SUCCESS)
-		return ret;
+	fc_block_scsi_eh(cmd);
 
 	id = cmd->device->id;
 	lun = cmd->device->lun;
 	serial = cmd->serial_number;
 
-	ret = FAILED;
-
 	if (!fcport)
 		return ret;
 
@@ -1044,22 +1031,18 @@
 	scsi_qla_host_t *vha = shost_priv(cmd->device->host);
 	fc_port_t *fcport = (struct fc_port *) cmd->device->hostdata;
 	struct qla_hw_data *ha = vha->hw;
-	int ret;
+	int ret = FAILED;
 	unsigned int id, lun;
 	unsigned long serial;
 	srb_t *sp = (srb_t *) CMD_SP(cmd);
 	scsi_qla_host_t *base_vha = pci_get_drvdata(ha->pdev);
 
-	ret = fc_block_scsi_eh(cmd);
-	if (ret != SUCCESS)
-		return ret;
+	fc_block_scsi_eh(cmd);
 
 	id = cmd->device->id;
 	lun = cmd->device->lun;
 	serial = cmd->serial_number;
 
-	ret = FAILED;
-
 	if (!fcport)
 		return ret;
 
@@ -1127,7 +1110,7 @@
 	struct fc_port *fcport;
 	struct qla_hw_data *ha = vha->hw;
 
-	if (ql2xtargetreset == 1 && ha->flags.enable_target_reset) {
+	if (ha->flags.enable_target_reset) {
 		list_for_each_entry(fcport, &vha->vp_fcports, list) {
 			if (fcport->port_type != FCT_TARGET)
 				continue;
@@ -3141,29 +3124,15 @@
 }
 
 void
-qla2x00_sp_final_compl(struct qla_hw_data *ha, srb_t *sp)
-{
-	struct scsi_cmnd *cmd = sp->cmd;
-
-	qla2x00_sp_free_dma(sp);
-
-	mempool_free(sp, ha->srb_mempool);
-
-	cmd->scsi_done(cmd);
-}
-
-void
 qla2x00_sp_compl(struct qla_hw_data *ha, srb_t *sp)
 {
-	if (atomic_read(&sp->ref_count) == 0) {
-		DEBUG2(qla_printk(KERN_WARNING, ha,
-		    "SP reference-count to ZERO -- sp=%p\n", sp));
-		DEBUG2(BUG());
-		return;
-	}
-	if (!atomic_dec_and_test(&sp->ref_count))
-		return;
-	qla2x00_sp_final_compl(ha, sp);
+	struct scsi_cmnd *cmd = sp->cmd;
+
+	qla2x00_sp_free_dma(sp);
+
+	mempool_free(sp, ha->srb_mempool);
+
+	cmd->scsi_done(cmd);
 }
 
 /**************************************************************************
diff -r 15109ec2f661 drivers/scsi/qla2xxx/qla_version.h
--- b/drivers/scsi/qla2xxx/qla_version.h	Wed Aug 17 13:31:06 2011 +0100
+++ a/drivers/scsi/qla2xxx/qla_version.h	Wed Aug 17 13:09:17 2011 +0100
@@ -7,7 +7,7 @@
 /*
  * Driver version
  */
-#define QLA2XXX_VERSION      "8.03.01.08.11.1-k8"
+#define QLA2XXX_VERSION      "8.03.01.06.11.1-k8"
 
 #define QLA_DRIVER_MAJOR_VER	8
 #define QLA_DRIVER_MINOR_VER	3
