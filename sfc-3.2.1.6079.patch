diff -r 9566a4a50a43 drivers/net/Kconfig
--- a/drivers/net/Kconfig
+++ b/drivers/net/Kconfig
@@ -2759,10 +2759,10 @@ config QLGE
 	  To compile this driver as a module, choose M here: the module
 	  will be called qlge.
 
+source "drivers/net/benet/Kconfig"
+
 source "drivers/net/sfc/Kconfig"
 
-source "drivers/net/benet/Kconfig"
-
 endif # NETDEV_10000
 
 source "drivers/net/tokenring/Kconfig"
diff -r 9566a4a50a43 drivers/net/sfc/Kconfig
--- a/drivers/net/sfc/Kconfig
+++ b/drivers/net/sfc/Kconfig
@@ -1,5 +1,5 @@
 config SFC
-	tristate "Solarflare Solarstorm SFC4000 support"
+	tristate "Solarflare SFC4000/SFC9000-family support"
 	depends on PCI && INET
 	select MDIO
 	select CRC32
@@ -7,26 +7,30 @@ config SFC
 	select I2C_ALGOBIT
 	help
 	  This driver supports 10-gigabit Ethernet cards based on
-	  the Solarflare Communications Solarstorm SFC4000 controller.
+	  the Solarflare SFC4000 and SFC9000-family controllers.
 
 	  To compile this driver as a module, choose M here.  The module
 	  will be called sfc.
-
-config SFC_DRIVERLINK
-	bool
-
-config SFC_RESOURCE
-	depends on SFC && X86
-	select SFC_DRIVERLINK
-	tristate "Solarflare Solarstorm SFC4000 resource driver"
-	help
-	  This module provides the SFC resource manager driver.
-
 config SFC_MTD
-	bool "Solarflare Solarstorm SFC4000 flash MTD support"
+	bool "Solarflare SFC4000/SFC9000-family MTD support"
 	depends on SFC && MTD && !(SFC=y && MTD=m)
 	default y
 	help
-	  This exposes the on-board flash memory as an MTD device (e.g.
-          /dev/mtd1).  This makes it possible to upload new boot code
-          to the NIC.
+	  This exposes the on-board flash and/or EEPROM memory as MTD
+	  devices (e.g. /dev/mtd1).  This makes it possible to upload
+	  new boot code to the NIC.
+config SFC_SRIOV
+       bool "Solarflare SFC9000-family SR-IOV support"
+       depends on SFC && PCI_IOV
+       default y
+       help
+          This enables support for the SFC9000 I/O Virtualization
+	  features, allowing accelerated network performance in
+	  virtualized environments.
+config SFC_PTP
+       bool "Solarflare Solarstorm SFC9000-family PTP support"
+       depends on SFC
+       default y
+       help
+          This enables support for the Precision Time Protocol (PTP)
+          on SFC9000-family NICs
diff -r 9566a4a50a43 drivers/net/sfc/Makefile
--- a/drivers/net/sfc/Makefile
+++ b/drivers/net/sfc/Makefile
@@ -1,9 +1,12 @@
-sfc-y			+= efx.o falcon.o tx.o rx.o falcon_gmac.o \
-			   falcon_xmac.o selftest.o ethtool.o xfp_phy.o \
-			   mdio_10g.o tenxpress.o boards.o sfe4001.o
-sfc-$(CONFIG_SFC_DRIVERLINK) += driverlink.o
+
+sfc-y			+= efx.o nic.o falcon.o siena.o tx.o rx.o filter.o \
+			   falcon_xmac.o mcdi_mac.o selftest.o \
+			   driverlink.o ethtool.o qt202x_phy.o mdio_10g.o \
+			   tenxpress.o txc43128_phy.o falcon_boards.o mcdi.o \
+			   mcdi_phy.o ioctl.o kernel_compat.o
 sfc-$(CONFIG_SFC_MTD)	+= mtd.o
+sfc-$(CONFIG_SFC_SRIOV)	+= sriov.o
+sfc-$(CONFIG_SFC_PTP)	+= ptp.o
 
 obj-$(CONFIG_SFC)	+= sfc.o
 
-obj-$(CONFIG_SFC_RESOURCE) += sfc_resource/
diff -r 9566a4a50a43 drivers/net/sfc/autocompat.h
--- /dev/null
+++ b/drivers/net/sfc/autocompat.h
@@ -0,0 +1,216 @@
+// #define EFX_NEED_ETHTOOL_OFFLOAD_SANITY_CHECKS
+// #define EFX_HAVE_MSIX_TABLE_RESERVED
+#define EFX_USE_ETHTOOL_OP_GET_TX_CSUM yes
+// #define EFX_NEED_UNREGISTER_NETDEVICE_NOTIFIER_FIX
+#define EFX_HAVE_COMPOUND_PAGES yes
+// #define EFX_HAVE_NONCONST_ETHTOOL_OPS
+#define EFX_USE_GSO_SIZE_FOR_MSS yes
+// #define EFX_USE_FASTCALL
+// #define EFX_USE_VLAN_RX_KILL_VID
+// #define EFX_NEED_BONDING_HACKS
+// #define EFX_NEED_DEV_CLOSE_HACK
+// #define EFX_NEED_PCI_VPD_ATTR
+// #define EFX_NEED_LM87_DRIVER
+// #define EFX_NEED_LM90_DRIVER
+// #define EFX_USE_NET_DEVICE_LAST_RX
+// #define EFX_USE_NET_DEVICE_TRANS_START
+// #define EFX_USE_PRINT_MAC
+// #define EFX_HAVE_PARAM_BOOL_INT
+#define EFX_HAVE_MTD_TABLE yes
+// #define EFX_HAVE_VMALLOC_REG_DUMP_BUF
+// #define EFX_USE_ETHTOOL_OP_GET_LINK
+// #define EFX_HAVE_OLD_NAPI
+// #define EFX_HAVE_OLD_CSUM
+// #define EFX_NEED_BYTEORDER_TYPES
+// #define EFX_NEED_CSUM_UNFOLDED
+// #define EFX_NEED_CSUM_TCPUDP_NOFOLD
+// #define EFX_NEED_DEV_NOTICE
+// #define EFX_NEED_DUMMY_PCI_DISABLE_MSI
+// #define EFX_NEED_DUMMY_MSIX
+// #define EFX_NEED_ENABLE_MSIX
+#define EFX_NEED_GRO_RESULT_T yes
+// #define EFX_HAVE_NAPI_GRO_RECEIVE_GR
+// #define EFX_NEED_GFP_T
+// #define EFX_NEED_HEX_DUMP
+// #define EFX_NEED_IF_MII
+// #define EFX_HAVE_IRQ_HANDLER_REGS
+// #define EFX_NEED_IRQ_HANDLER_T
+// #define EFX_NEED_KCALLOC
+// #define EFX_NEED_KZALLOC
+#define EFX_NEED_VZALLOC yes
+// #define EFX_NEED_MII_CONSTANTS
+// #define EFX_NEED_MII_ADVERTISE_FLOWCTRL
+// #define EFX_NEED_MII_RESOLVE_FLOWCTRL_FDX
+#define EFX_HAVE_LINUX_MDIO_H yes
+// #define EFX_NEED_MSECS_TO_JIFFIES
+// #define EFX_NEED_MSLEEP
+// #define EFX_NEED_SSLEEP
+#define EFX_NEED_MTD_DEVICE_REGISTER yes
+// #define EFX_NEED_MTD_ERASE_CALLBACK
+// #define EFX_NEED_MUTEX
+// #define EFX_NEED_NETDEV_ALLOC_SKB
+// #define EFX_NEED_SKB_COPY_FROM_LINEAR_DATA
+// #define EFX_NEED___SKB_QUEUE_HEAD_INIT
+// #define EFX_NEED_NETDEV_TX_T
+// #define EFX_NEED_NETIF_NAPI_DEL
+// #define EFX_NEED_NETIF_TX_LOCK
+// #define EFX_NEED_NETIF_ADDR_LOCK
+// #define EFX_NEED_ALLOC_ETHERDEV_MQ
+// #define EFX_NEED_TX_MQ_API
+#define EFX_USE_TX_MQ yes
+// #define EFX_NEED_NETIF_SET_REAL_NUM_TX_QUEUES
+#define EFX_NEED_NETIF_SET_REAL_NUM_RX_QUEUES yes
+// #define EFX_NEED_PCI_CLEAR_MASTER
+// #define EFX_NEED_PCI_MATCH_ID
+// #define EFX_NEED_PRINT_MAC
+// #define EFX_NEED_RANDOM_ETHER_ADDR
+// #define EFX_NEED_RESOURCE_SIZE_T
+// #define EFX_NEED_RTNL_TRYLOCK
+#define EFX_HAVE_ROUND_JIFFIES_UP yes
+// #define EFX_NEED_SAFE_LISTS
+// #define EFX_NEED_SCHEDULE_TIMEOUT_INTERRUPTIBLE
+// #define EFX_NEED_SCHEDULE_TIMEOUT_UNINTERRUPTIBLE
+// #define EFX_NEED_SETUP_TIMER
+// #define EFX_NEED_SKB_HEADER_MACROS
+#define EFX_NEED_SKB_CHECKSUM_START_OFFSET yes
+#define EFX_HAVE_CSUM_START yes
+#define EFX_HAVE_SKB_SET_TRANSPORT_HEADER yes
+// #define EFX_HAVE_SKBTX_HW_TSTAMP
+// #define EFX_NEED_ETH_HDR
+// #define EFX_NEED_VLAN_ETH_HDR
+// #define EFX_NEED_TCP_HDR
+// #define EFX_NEED_UDP_HDR
+// #define EFX_NEED_IP_HDR
+// #define EFX_NEED_IPV6_HDR
+#define EFX_USE_CANCEL_DELAYED_WORK_SYNC yes
+#define EFX_USE_CANCEL_WORK_SYNC yes
+#define EFX_USE_ETHTOOL_ETH_TP_MDIX yes
+// #define EFX_USE_ETHTOOL_GET_PERM_ADDR
+#define EFX_USE_ETHTOOL_FLAGS yes
+#define EFX_USE_ETHTOOL_LP_ADVERTISING yes
+#define EFX_USE_ETHTOOL_MDIO_SUPPORT yes
+#define EFX_USE_LINUX_IO_H yes
+#define EFX_USE_LINUX_UACCESS_H yes
+#define EFX_USE_MTD_ERASE_FAIL_ADDR yes
+#define EFX_USE_MTD_WRITESIZE yes
+#define EFX_USE_PCI_DEV_REVISION yes
+#define EFX_USE_NETDEV_VLAN_FEATURES yes
+#define EFX_USE_NETDEV_PERM_ADDR yes
+// #define EFX_NEED_I2C_NEW_DUMMY
+#define EFX_HAVE_HWMON_H yes
+// #define EFX_NEED_HWMON_VID
+// #define EFX_HAVE_I2C_SENSOR_H
+// #define EFX_NEED_BOOL
+#define EFX_USE_ETHTOOL_GET_SSET_COUNT yes
+// #define EFX_HAVE_ETHTOOL_SET_PHYS_ID
+// #define EFX_NEED_ETHTOOL_CMD_SPEED
+// #define EFX_NEED_I2C_LOCK_ADAPTER
+#define EFX_HAVE_LINUX_SEMAPHORE_H yes
+// #define EFX_NEED_DEV_GET_STATS
+// #define EFX_NEED_NEW_CPUMASK_API
+// #define EFX_NEED_ZALLOC_CPUMASK_VAR
+#define EFX_USE_PM yes
+// #define EFX_USE_PM_EXT_OPS
+#define EFX_USE_DEV_PM_OPS yes
+// #define EFX_NEED_ATOMIC_CMPXCHG
+// #define EFX_NEED_WAIT_EVENT_TIMEOUT
+// #define EFX_NEED_ETHTOOL_CONSTANTS
+// #define EFX_NEED_PCI_WAKE_FROM_D3
+#define EFX_HAVE_DEV_DISABLE_LRO yes
+// #define EFX_NEED_UNMASK_MSIX_VECTORS
+#define EFX_HAVE_PM_IDLE yes
+#define EFX_HAVE_SKB_RECORD_RX_QUEUE yes
+// #define EFX_HAVE_XEN_XEN_H
+#define EFX_HAVE_XEN_START_INFO yes
+#define EFX_HAVE_CPUMASK_OF_NODE yes
+// #define EFX_NEED_SET_CPUS_ALLOWED_PTR
+// #define EFX_HAVE_EXPORTED_CPU_SIBLING_MAP
+#define EFX_HAVE_ROUNDDOWN_POW_OF_TWO yes
+#define EFX_HAVE_ROUNDUP_POW_OF_TWO yes
+#define EFX_HAVE_SRIOV yes
+#define EFX_HAVE_NET_DEVICE_OPS yes
+#define EFX_HAVE_NDO_SET_VF_MAC yes
+// #define EFX_HAVE_NDO_SET_FEATURES
+// #define EFX_NEED_IS_ZERO_ETHER_ADDR
+// #define EFX_NEED_IS_BROADCAST_ETHER_ADDR
+// #define EFX_NEED_IS_MULTICAST_ETHER_ADDR
+// #define EFX_NEED_COMPARE_ETHER_ADDR
+#define EFX_HAVE_LIST_SPLICE_TAIL_INIT yes
+// #define EFX_NEED_LIST_FIRST_ENTRY
+// #define EFX_NEED_TIMESPEC_ADD_NS
+// #define EFX_NEED_TIMESPEC_SUB
+// #define EFX_NEED_TIMESPEC_COMPARE
+// #define EFX_NEED_NS_TO_TIMESPEC
+// #define EFX_NEED_SET_NORMALIZED_TIMESPEC
+// #define EFX_HAVE_PROCFS_DELETED
+#define EFX_HAVE_VLAN_RX_PATH yes
+#define EFX_HAVE_NDO_SET_MULTICAST_LIST yes
+// #define EFX_HAVE_CPU_RMAP
+// #define EFX_NEED_KTIME
+#define EFX_HAVE_NET_TSTAMP yes
+#define EFX_HAVE_DIV_S64_REM yes
+#define EFX_NEED_NETDEV_FEATURES_T yes
+// #define EFX_NEED_SKB_FILL_PAGE_DESC
+#define EFX_NEED_SKB_FRAG_DMA_MAP yes
+// #define EFX_HAVE_OLD_ETHTOOL_RXFH_INDIR
+#define EFX_NEED_ETHTOOL_RXFH_INDIR_DEFAULT yes
+// #define EFX_NEED_COMPAT_U64
+// #define EFX_USE_IRQ_SET_AFFINITY_HINT
+// #define EFX_NEED_FOR_EACH_PCI_DEV
+// #define EFX_NEED_SCSI_SGLIST
+// #define EFX_NEED_SG_NEXT
+// #define EFX_HAVE_NEW_KFIFO
+// #define EFX_NEED_VMALLOC_NODE
+// #define EFX_NEED_VMALLOC_TO_PFN
+// #define EFX_NEED_KVEC
+// #define EFX_NEED_KERNEL_SENDMSG
+#define EFX_HAVE_NFPROTO_CONSTANTS yes
+#define EFX_HAVE_FDTABLE yes
+#define EFX_HAVE_REMAP_PFN_RANGE yes
+#define EFX_HAVE_GETNSTIMEOFDAY yes
+// #define EFX_NEED_PCI_READ_VPD
+#define EFX_NEED_PCI_VPD_LRDT yes
+// #define EFX_HAVE_KERN_UMOUNT
+#define EFX_HAVE_ALLOC_FILE yes
+#define EFX_HAVE_GRO yes
+// #define EFX_NEED_HEX_DUMP_CONST_FIX
+// #define EFX_HAVE___NETIF_TX_LOCK_1PARAM
+// #define EFX_NEED_PCI_SAVE_RESTORE_WRAPPERS
+#define EFX_USE_NETDEV_DEV yes
+#define EFX_USE_NETDEV_DEV_ID yes
+#define EFX_USE_NETDEV_STATS yes
+// #define EFX_USE_NETDEV_STATS64
+#define EFX_USE_DEV_MC_LIST yes
+// #define EFX_HAVE_OLD_SKB_CHECKSUM_HELP
+// #define EFX_HAVE_OLDER_SKB_CHECKSUM_HELP
+// #define EFX_HAVE_OLD_I2C_DRIVER_PROBE
+// #define EFX_HAVE_OLD_I2C_NEW_DUMMY
+// #define EFX_USE_I2C_DRIVER_NAME
+// #define EFX_HAVE_HWMON_CLASS_DEVICE
+// #define EFX_HAVE_OLD_DEVICE_ATTRIBUTE
+// #define EFX_HAVE_BIN_ATTRIBUTE_OP_FILE_PARAM
+// #define EFX_HAVE_ETHTOOL_RESET
+// #define EFX_USE_I2C_BUS_SEMAPHORE
+// #define EFX_HAVE_OLD_PCI_DMA_MAPPING_ERROR
+// #define EFX_NEED_ON_EACH_CPU_WRAPPER
+#define EFX_HAVE_OLD_ETHTOOL_GET_RXNFC yes
+// #define EFX_HAVE_NETFILTER_INDIRECT_SKB
+#define EFX_HAVE_D_DNAME yes
+// #define EFX_HAVE_STRUCT_PATH
+// #define EFX_HAVE_CONST_D_OP
+// #define EFX_FSTYPE_HAS_MOUNT
+#define EFX_NEED_VFSMOUNT_PARAM_IN_GET_SB yes
+// #define EFX_HAVE_KMEM_CACHE_S
+// #define EFX_HAVE_KMEM_CACHE_DTOR
+// #define EFX_HAVE_KMEM_CACHE_FLAGS
+// #define EFX_HAVE_KMEM_CACHE_CACHEP
+// #define EFX_HAVE_OLD_IP_FAST_CSUM
+// #define EFX_NEED_MDELAY
+// #define EFX_HAVE_OLD_SKB_LINEARIZE
+// #define EFX_NEED_WORK_API_WRAPPERS
+// #define EFX_NEED_MMIOWB
+// #define EFX_USE_I2C_LEGACY
+#define EFX_HAVE_BIN_ATTRIBUTE_OP_ATTR_PARAM yes
+// #define EFX_HAVE_OLD_CPUMASK_SCNPRINTF
+// #define EFX_NEED_WARN_ON
+#define EFX_NEED_IS_COMPAT_TASK yes
diff -r 9566a4a50a43 drivers/net/sfc/bitfield.h
--- a/drivers/net/sfc/bitfield.h
+++ b/drivers/net/sfc/bitfield.h
@@ -1,7 +1,7 @@
 /****************************************************************************
  * Driver for Solarflare Solarstorm network controllers and boards
  * Copyright 2005-2006 Fen Systems Ltd.
- * Copyright 2006-2008 Solarflare Communications Inc.
+ * Copyright 2006-2009 Solarflare Communications Inc.
  *
  * This program is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 as published
@@ -37,6 +37,8 @@
 #define EFX_DWORD_2_WIDTH 32
 #define EFX_DWORD_3_LBN 96
 #define EFX_DWORD_3_WIDTH 32
+#define EFX_QWORD_0_LBN 0
+#define EFX_QWORD_0_WIDTH 64
 
 /* Specified attribute (e.g. LBN) of the specified field */
 #define EFX_VAL(field, attribute) field ## _ ## attribute
@@ -520,19 +522,6 @@ typedef union efx_oword {
 #define EFX_SET_QWORD_FIELD EFX_SET_QWORD_FIELD32
 #endif
 
-#define EFX_SET_OWORD_FIELD_VER(efx, oword, field, value) do { \
-	if (falcon_rev(efx) >= FALCON_REV_B0) {			   \
-		EFX_SET_OWORD_FIELD((oword), field##_B0, (value)); \
-	} else { \
-		EFX_SET_OWORD_FIELD((oword), field##_A1, (value)); \
-	} \
-} while (0)
-
-#define EFX_QWORD_FIELD_VER(efx, qword, field)	\
-	(falcon_rev(efx) >= FALCON_REV_B0 ?	\
-	 EFX_QWORD_FIELD((qword), field##_B0) :	\
-	 EFX_QWORD_FIELD((qword), field##_A1))
-
 /* Used to avoid compiler warnings about shift range exceeding width
  * of the data types when dma_addr_t is only 32 bits wide.
  */
@@ -543,7 +532,7 @@ typedef union efx_oword {
 
 /* Static initialiser */
 #define EFX_OWORD32(a, b, c, d)						\
-	{ .u32 = { cpu_to_le32(a), cpu_to_le32(b), \
-		   cpu_to_le32(c), cpu_to_le32(d) } }
+	{ .u32 = { __constant_cpu_to_le32(a), __constant_cpu_to_le32(b), \
+		   __constant_cpu_to_le32(c), __constant_cpu_to_le32(d) } }
 
 #endif /* EFX_BITFIELD_H */
diff -r 9566a4a50a43 drivers/net/sfc/boards.c
--- a/drivers/net/sfc/boards.c
+++ /dev/null
@@ -1,328 +0,0 @@
-/****************************************************************************
- * Driver for Solarflare Solarstorm network controllers and boards
- * Copyright 2007-2008 Solarflare Communications Inc.
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 as published
- * by the Free Software Foundation, incorporated herein by reference.
- */
-
-#include "net_driver.h"
-#include "phy.h"
-#include "boards.h"
-#include "efx.h"
-#include "workarounds.h"
-
-/* Macros for unpacking the board revision */
-/* The revision info is in host byte order. */
-#define BOARD_TYPE(_rev) (_rev >> 8)
-#define BOARD_MAJOR(_rev) ((_rev >> 4) & 0xf)
-#define BOARD_MINOR(_rev) (_rev & 0xf)
-
-/* Blink support. If the PHY has no auto-blink mode so we hang it off a timer */
-#define BLINK_INTERVAL (HZ/2)
-
-static void blink_led_timer(unsigned long context)
-{
-	struct efx_nic *efx = (struct efx_nic *)context;
-	struct efx_blinker *bl = &efx->board_info.blinker;
-	efx->board_info.set_id_led(efx, bl->state);
-	bl->state = !bl->state;
-	if (bl->resubmit)
-		mod_timer(&bl->timer, jiffies + BLINK_INTERVAL);
-}
-
-static void board_blink(struct efx_nic *efx, bool blink)
-{
-	struct efx_blinker *blinker = &efx->board_info.blinker;
-
-	/* The rtnl mutex serialises all ethtool ioctls, so
-	 * nothing special needs doing here. */
-	if (blink) {
-		blinker->resubmit = true;
-		blinker->state = false;
-		setup_timer(&blinker->timer, blink_led_timer,
-			    (unsigned long)efx);
-		mod_timer(&blinker->timer, jiffies + BLINK_INTERVAL);
-	} else {
-		blinker->resubmit = false;
-		if (blinker->timer.function)
-			del_timer_sync(&blinker->timer);
-		efx->board_info.init_leds(efx);
-	}
-}
-
-/*****************************************************************************
- * Support for LM87 sensor chip used on several boards
- */
-#define LM87_REG_ALARMS1		0x41
-#define LM87_REG_ALARMS2		0x42
-#define LM87_IN_LIMITS(nr, _min, _max)			\
-	0x2B + (nr) * 2, _max, 0x2C + (nr) * 2, _min
-#define LM87_AIN_LIMITS(nr, _min, _max)			\
-	0x3B + (nr), _max, 0x1A + (nr), _min
-#define LM87_TEMP_INT_LIMITS(_min, _max)		\
-	0x39, _max, 0x3A, _min
-#define LM87_TEMP_EXT1_LIMITS(_min, _max)		\
-	0x37, _max, 0x38, _min
-
-#define LM87_ALARM_TEMP_INT		0x10
-#define LM87_ALARM_TEMP_EXT1		0x20
-
-#if defined(CONFIG_SENSORS_LM87) || defined(CONFIG_SENSORS_LM87_MODULE)
-
-static int efx_init_lm87(struct efx_nic *efx, struct i2c_board_info *info,
-			 const u8 *reg_values)
-{
-	struct i2c_client *client = i2c_new_device(&efx->i2c_adap, info);
-	int rc;
-
-	if (!client)
-		return -EIO;
-
-	while (*reg_values) {
-		u8 reg = *reg_values++;
-		u8 value = *reg_values++;
-		rc = i2c_smbus_write_byte_data(client, reg, value);
-		if (rc)
-			goto err;
-	}
-
-	efx->board_info.hwmon_client = client;
-	return 0;
-
-err:
-	i2c_unregister_device(client);
-	return rc;
-}
-
-static void efx_fini_lm87(struct efx_nic *efx)
-{
-	i2c_unregister_device(efx->board_info.hwmon_client);
-}
-
-static int efx_check_lm87(struct efx_nic *efx, unsigned mask)
-{
-	struct i2c_client *client = efx->board_info.hwmon_client;
-	s32 alarms1, alarms2;
-
-	/* If link is up then do not monitor temperature */
-	if (EFX_WORKAROUND_7884(efx) && efx->link_up)
-		return 0;
-
-	alarms1 = i2c_smbus_read_byte_data(client, LM87_REG_ALARMS1);
-	alarms2 = i2c_smbus_read_byte_data(client, LM87_REG_ALARMS2);
-	if (alarms1 < 0)
-		return alarms1;
-	if (alarms2 < 0)
-		return alarms2;
-	alarms1 &= mask;
-	alarms2 &= mask >> 8;
-	if (alarms1 || alarms2) {
-		EFX_ERR(efx,
-			"LM87 detected a hardware failure (status %02x:%02x)"
-			"%s%s\n",
-			alarms1, alarms2,
-			(alarms1 & LM87_ALARM_TEMP_INT) ? " INTERNAL" : "",
-			(alarms1 & LM87_ALARM_TEMP_EXT1) ? " EXTERNAL" : "");
-		return -ERANGE;
-	}
-
-	return 0;
-}
-
-#else /* !CONFIG_SENSORS_LM87 */
-
-static inline int
-efx_init_lm87(struct efx_nic *efx, struct i2c_board_info *info,
-	      const u8 *reg_values)
-{
-	return 0;
-}
-static inline void efx_fini_lm87(struct efx_nic *efx)
-{
-}
-static inline int efx_check_lm87(struct efx_nic *efx, unsigned mask)
-{
-	return 0;
-}
-
-#endif /* CONFIG_SENSORS_LM87 */
-
-/*****************************************************************************
- * Support for the SFE4002
- *
- */
-static u8 sfe4002_lm87_channel = 0x03; /* use AIN not FAN inputs */
-
-static const u8 sfe4002_lm87_regs[] = {
-	LM87_IN_LIMITS(0, 0x83, 0x91),		/* 2.5V:  1.8V +/- 5% */
-	LM87_IN_LIMITS(1, 0x51, 0x5a),		/* Vccp1: 1.2V +/- 5% */
-	LM87_IN_LIMITS(2, 0xb6, 0xca),		/* 3.3V:  3.3V +/- 5% */
-	LM87_IN_LIMITS(3, 0xb0, 0xc9),		/* 5V:    4.6-5.2V */
-	LM87_IN_LIMITS(4, 0xb0, 0xe0),		/* 12V:   11-14V */
-	LM87_IN_LIMITS(5, 0x44, 0x4b),		/* Vccp2: 1.0V +/- 5% */
-	LM87_AIN_LIMITS(0, 0xa0, 0xb2),		/* AIN1:  1.66V +/- 5% */
-	LM87_AIN_LIMITS(1, 0x91, 0xa1),		/* AIN2:  1.5V +/- 5% */
-	LM87_TEMP_INT_LIMITS(10, 60),		/* board */
-	LM87_TEMP_EXT1_LIMITS(10, 70),		/* Falcon */
-	0
-};
-
-static struct i2c_board_info sfe4002_hwmon_info = {
-	I2C_BOARD_INFO("lm87", 0x2e),
-	.platform_data	= &sfe4002_lm87_channel,
-};
-
-/****************************************************************************/
-/* LED allocations. Note that on rev A0 boards the schematic and the reality
- * differ: red and green are swapped. Below is the fixed (A1) layout (there
- * are only 3 A0 boards in existence, so no real reason to make this
- * conditional).
- */
-#define SFE4002_FAULT_LED (2)	/* Red */
-#define SFE4002_RX_LED    (0)	/* Green */
-#define SFE4002_TX_LED    (1)	/* Amber */
-
-static void sfe4002_init_leds(struct efx_nic *efx)
-{
-	/* Set the TX and RX LEDs to reflect status and activity, and the
-	 * fault LED off */
-	xfp_set_led(efx, SFE4002_TX_LED,
-		    QUAKE_LED_TXLINK | QUAKE_LED_LINK_ACTSTAT);
-	xfp_set_led(efx, SFE4002_RX_LED,
-		    QUAKE_LED_RXLINK | QUAKE_LED_LINK_ACTSTAT);
-	xfp_set_led(efx, SFE4002_FAULT_LED, QUAKE_LED_OFF);
-}
-
-static void sfe4002_set_id_led(struct efx_nic *efx, bool state)
-{
-	xfp_set_led(efx, SFE4002_FAULT_LED, state ? QUAKE_LED_ON :
-			QUAKE_LED_OFF);
-}
-
-static int sfe4002_check_hw(struct efx_nic *efx)
-{
-	/* A0 board rev. 4002s report a temperature fault the whole time
-	 * (bad sensor) so we mask it out. */
-	unsigned alarm_mask =
-		(efx->board_info.major == 0 && efx->board_info.minor == 0) ?
-		~LM87_ALARM_TEMP_EXT1 : ~0;
-
-	return efx_check_lm87(efx, alarm_mask);
-}
-
-static int sfe4002_init(struct efx_nic *efx)
-{
-	int rc = efx_init_lm87(efx, &sfe4002_hwmon_info, sfe4002_lm87_regs);
-	if (rc)
-		return rc;
-	efx->board_info.monitor = sfe4002_check_hw;
-	efx->board_info.init_leds = sfe4002_init_leds;
-	efx->board_info.set_id_led = sfe4002_set_id_led;
-	efx->board_info.blink = board_blink;
-	efx->board_info.fini = efx_fini_lm87;
-	return 0;
-}
-
-/*****************************************************************************
- * Support for the SFN4112F
- *
- */
-static u8 sfn4112f_lm87_channel = 0x03; /* use AIN not FAN inputs */
-
-static const u8 sfn4112f_lm87_regs[] = {
-	LM87_IN_LIMITS(0, 0x83, 0x91),		/* 2.5V:  1.8V +/- 5% */
-	LM87_IN_LIMITS(1, 0x51, 0x5a),		/* Vccp1: 1.2V +/- 5% */
-	LM87_IN_LIMITS(2, 0xb6, 0xca),		/* 3.3V:  3.3V +/- 5% */
-	LM87_IN_LIMITS(4, 0xb0, 0xe0),		/* 12V:   11-14V */
-	LM87_IN_LIMITS(5, 0x44, 0x4b),		/* Vccp2: 1.0V +/- 5% */
-	LM87_AIN_LIMITS(1, 0x91, 0xa1),		/* AIN2:  1.5V +/- 5% */
-	LM87_TEMP_INT_LIMITS(10, 60),		/* board */
-	LM87_TEMP_EXT1_LIMITS(10, 70),		/* Falcon */
-	0
-};
-
-static struct i2c_board_info sfn4112f_hwmon_info = {
-	I2C_BOARD_INFO("lm87", 0x2e),
-	.platform_data	= &sfn4112f_lm87_channel,
-};
-
-#define SFN4112F_ACT_LED	0
-#define SFN4112F_LINK_LED	1
-
-static void sfn4112f_init_leds(struct efx_nic *efx)
-{
-	xfp_set_led(efx, SFN4112F_ACT_LED,
-		    QUAKE_LED_RXLINK | QUAKE_LED_LINK_ACT);
-	xfp_set_led(efx, SFN4112F_LINK_LED,
-		    QUAKE_LED_RXLINK | QUAKE_LED_LINK_STAT);
-}
-
-static void sfn4112f_set_id_led(struct efx_nic *efx, bool state)
-{
-	xfp_set_led(efx, SFN4112F_LINK_LED,
-		    state ? QUAKE_LED_ON : QUAKE_LED_OFF);
-}
-
-static int sfn4112f_check_hw(struct efx_nic *efx)
-{
-	/* Mask out unused sensors */
-	return efx_check_lm87(efx, ~0x48);
-}
-
-static int sfn4112f_init(struct efx_nic *efx)
-{
-	int rc = efx_init_lm87(efx, &sfn4112f_hwmon_info, sfn4112f_lm87_regs);
-	if (rc)
-		return rc;
-	efx->board_info.monitor = sfn4112f_check_hw;
-	efx->board_info.init_leds = sfn4112f_init_leds;
-	efx->board_info.set_id_led = sfn4112f_set_id_led;
-	efx->board_info.blink = board_blink;
-	efx->board_info.fini = efx_fini_lm87;
-	return 0;
-}
-
-/* This will get expanded as board-specific details get moved out of the
- * PHY drivers. */
-struct efx_board_data {
-	enum efx_board_type type;
-	const char *ref_model;
-	const char *gen_type;
-	int (*init) (struct efx_nic *nic);
-};
-
-
-static struct efx_board_data board_data[] = {
-	{ EFX_BOARD_SFE4001, "SFE4001", "10GBASE-T adapter", sfe4001_init },
-	{ EFX_BOARD_SFE4002, "SFE4002", "XFP adapter", sfe4002_init },
-	{ EFX_BOARD_SFN4111T, "SFN4111T", "100/1000/10GBASE-T adapter",
-	  sfn4111t_init },
-	{ EFX_BOARD_SFN4112F, "SFN4112F", "SFP+ adapter",
-	  sfn4112f_init },
-};
-
-void efx_set_board_info(struct efx_nic *efx, u16 revision_info)
-{
-	struct efx_board_data *data = NULL;
-	int i;
-
-	efx->board_info.type = BOARD_TYPE(revision_info);
-	efx->board_info.major = BOARD_MAJOR(revision_info);
-	efx->board_info.minor = BOARD_MINOR(revision_info);
-
-	for (i = 0; i < ARRAY_SIZE(board_data); i++)
-		if (board_data[i].type == efx->board_info.type)
-			data = &board_data[i];
-
-	if (data) {
-		EFX_INFO(efx, "board is %s rev %c%d\n",
-			 (efx->pci_dev->subsystem_vendor == EFX_VENDID_SFC)
-			 ? data->ref_model : data->gen_type,
-			 'A' + efx->board_info.major, efx->board_info.minor);
-		efx->board_info.init = data->init;
-	} else {
-		EFX_ERR(efx, "unknown board type %d\n", efx->board_info.type);
-	}
-}
diff -r 9566a4a50a43 drivers/net/sfc/boards.h
--- a/drivers/net/sfc/boards.h
+++ /dev/null
@@ -1,28 +0,0 @@
-/****************************************************************************
- * Driver for Solarflare Solarstorm network controllers and boards
- * Copyright 2007-2008 Solarflare Communications Inc.
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 as published
- * by the Free Software Foundation, incorporated herein by reference.
- */
-
-#ifndef EFX_BOARDS_H
-#define EFX_BOARDS_H
-
-/* Board IDs (must fit in 8 bits) */
-enum efx_board_type {
-	EFX_BOARD_SFE4001 = 1,
-	EFX_BOARD_SFE4002 = 2,
-	EFX_BOARD_SFN4111T = 0x51,
-	EFX_BOARD_SFN4112F = 0x52,
-};
-
-extern void efx_set_board_info(struct efx_nic *efx, u16 revision_info);
-
-/* SFE4001 (10GBASE-T) */
-extern int sfe4001_init(struct efx_nic *efx);
-/* SFN4111T (100/1000/10GBASE-T) */
-extern int sfn4111t_init(struct efx_nic *efx);
-
-#endif
diff -r 9566a4a50a43 drivers/net/sfc/debugfs.c
--- /dev/null
+++ b/drivers/net/sfc/debugfs.c
@@ -0,0 +1,965 @@
+/****************************************************************************
+ * Driver for Solarflare Solarstorm network controllers and boards
+ * Copyright 2005-2006 Fen Systems Ltd.
+ * Copyright 2006-2010 Solarflare Communications Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 as published
+ * by the Free Software Foundation, incorporated herein by reference.
+ */
+
+#include <linux/module.h>
+#include <linux/pci.h>
+/* For out-of-tree builds we always need procfs, if only for a compatibility
+ * symlink.
+ */
+#include <linux/proc_fs.h>
+#include <linux/dcache.h>
+#include <linux/seq_file.h>
+#include <linux/slab.h>
+#include "net_driver.h"
+#include "efx.h"
+#include "debugfs.h"
+#include "nic.h"
+
+
+/* Parameter definition bound to a structure - each file has one of these */
+struct efx_debugfs_bound_param {
+#if defined(EFX_USE_KCOMPAT) && !defined(EFX_USE_DEBUGFS)
+	struct efx_debugfs_bound_param *next;
+#endif
+	const struct efx_debugfs_parameter *param;
+	void *(*get_struct)(void *, unsigned);
+	void *ref;
+	unsigned index;
+};
+
+
+/* EFX_USE_DEBUGFS is defined by kernel_compat.h so we can't decide whether to
+ * include this earlier.
+ */
+#ifdef EFX_USE_DEBUGFS
+#include <linux/debugfs.h>
+#endif
+
+#ifndef EFX_USE_DEBUGFS
+
+static void efx_debugfs_remove(struct proc_dir_entry *entry)
+{
+	struct efx_debugfs_bound_param *binding, *next;
+
+	if (!entry)
+		return;
+	remove_proc_entry(entry->name, entry->parent);
+	if (S_ISDIR(entry->mode)) {
+		for (binding = entry->data; binding != NULL; binding = next) {
+			next = binding->next;
+			kfree(binding);
+		}
+	}
+}
+#define debugfs_remove efx_debugfs_remove
+
+#define debugfs_create_dir proc_mkdir
+#define debugfs_create_symlink proc_symlink
+
+#endif /* !EFX_USE_DEBUGFS */
+
+
+/* Maximum length for a name component or symlink target */
+#define EFX_DEBUGFS_NAME_LEN 32
+
+
+/* Top-level debug directory ([/sys/kernel]/debug/sfc) */
+static efx_debugfs_entry *efx_debug_root;
+
+/* "cards" directory ([/sys/kernel]/debug/sfc/cards) */
+static efx_debugfs_entry *efx_debug_cards;
+
+
+/* Sequential file interface to bound parameters */
+
+#if !defined(EFX_USE_KCOMPAT) || defined(EFX_USE_DEBUGFS)
+
+static int efx_debugfs_seq_show(struct seq_file *file, void *v)
+{
+	struct efx_debugfs_bound_param *binding = file->private;
+	void *structure;
+	int rc;
+
+	rtnl_lock();
+	structure = binding->get_struct(binding->ref, binding->index);
+	rc = binding->param->reader(file, structure + binding->param->offset);
+	rtnl_unlock();
+	return rc;
+}
+
+static int efx_debugfs_open(struct inode *inode, struct file *file)
+{
+	return single_open(file, efx_debugfs_seq_show, inode->i_private);
+}
+
+#else /* EFX_USE_KCOMPAT && !EFX_USE_DEBUGFS */
+
+static int efx_debugfs_seq_show(struct seq_file *file, void *v)
+{
+	struct proc_dir_entry *entry = file->private;
+	struct efx_debugfs_bound_param *binding = entry->data;
+	void *structure;
+	int rc;
+
+	if (!binding)
+		return -EIO;
+	rtnl_lock();
+	structure = binding->get_struct(binding->ref, binding->index);
+	rc = binding->param->reader(file, structure + binding->param->offset);
+	rtnl_unlock();
+
+	return rc;
+}
+
+static int efx_debugfs_open(struct inode *inode, struct file *file)
+{
+	return single_open(file, efx_debugfs_seq_show, PROC_I(inode)->pde);
+}
+
+#endif /* !EFX_USE_KCOMPAT || EFX_USE_DEBUGFS */
+
+
+static struct file_operations efx_debugfs_file_ops = {
+	.owner   = THIS_MODULE,
+	.open    = efx_debugfs_open,
+	.read    = seq_read,
+	.llseek  = seq_lseek,
+	.release = single_release
+};
+
+
+#if !defined(EFX_USE_KCOMPAT) || defined(EFX_USE_DEBUGFS)
+
+/**
+ * efx_fini_debugfs_child - remove a named child of a debugfs directory
+ * @dir:		Directory
+ * @name:		Name of child
+ *
+ * This removes the named child from the directory, if it exists.
+ */
+void efx_fini_debugfs_child(efx_debugfs_entry *dir, const char *name)
+{
+	struct qstr child_name;
+	efx_debugfs_entry *child;
+
+	child_name.len = strlen(name);
+	child_name.name = name;
+	child_name.hash = full_name_hash(child_name.name, child_name.len);
+	child = d_lookup(dir, &child_name);
+	if (child) {
+		/* If it's a "regular" file, free its parameter binding */
+		if (S_ISREG(child->d_inode->i_mode))
+			kfree(child->d_inode->i_private);
+		debugfs_remove(child);
+		dput(child);
+	}
+}
+
+#else /* EFX_USE_KCOMPAT && !EFX_USE_DEBUGFS */
+
+void efx_fini_debugfs_child(struct proc_dir_entry *dir, const char *name)
+{
+	remove_proc_entry(name, dir);
+}
+
+#endif /* !EFX_USE_KCOMPAT || EFX_USE_DEBUGFS */
+
+/*
+ * Remove a debugfs directory.
+ *
+ * This removes the named parameter-files and sym-links from the
+ * directory, and the directory itself.  It does not do any recursion
+ * to subdirectories.
+ */
+static void efx_fini_debugfs_dir(efx_debugfs_entry *dir,
+				 struct efx_debugfs_parameter *params,
+				 const char *const *symlink_names)
+{
+	if (!dir)
+		return;
+
+	while (params->name) {
+		efx_fini_debugfs_child(dir, params->name);
+		params++;
+	}
+	while (symlink_names && *symlink_names) {
+		efx_fini_debugfs_child(dir, *symlink_names);
+		symlink_names++;
+	}
+	debugfs_remove(dir);
+}
+
+/* Functions for printing various types of parameter. */
+
+int efx_debugfs_read_uint(struct seq_file *file, void *data)
+{
+	return seq_printf(file, "%#x\n", *(unsigned int *)data);
+}
+
+int efx_debugfs_read_int(struct seq_file *file, void *data)
+{
+	return seq_printf(file, "%d\n", *(int *)data);
+}
+
+int efx_debugfs_read_atomic(struct seq_file *file, void *data)
+{
+	unsigned int value = atomic_read((atomic_t *) data);
+
+	return seq_printf(file, "%#x\n", value);
+}
+
+int efx_debugfs_read_dword(struct seq_file *file, void *data)
+{
+	unsigned int value = EFX_DWORD_FIELD(*(efx_dword_t *) data,
+					     EFX_DWORD_0);
+
+	return seq_printf(file, "%#x\n", value);
+}
+
+int efx_debugfs_read_bool(struct seq_file *file, void *data)
+{
+	return seq_printf(file, "%d\n", *(bool *)data);
+}
+
+static int efx_debugfs_read_int_mode(struct seq_file *file, void *data)
+{
+	unsigned int value = *(enum efx_int_mode *) data;
+
+	return seq_printf(file, "%d => %s\n", value,
+			  STRING_TABLE_LOOKUP(value, efx_interrupt_mode));
+}
+
+#define EFX_INT_MODE_PARAMETER(container_type, parameter)		\
+	EFX_PARAMETER(container_type, parameter,			\
+		      enum efx_int_mode, efx_debugfs_read_int_mode)
+
+static int efx_debugfs_read_loop_mode(struct seq_file *file, void *data)
+{
+	unsigned int value = *(enum efx_loopback_mode *)data;
+
+	return seq_printf(file, "%d => %s\n", value,
+			  STRING_TABLE_LOOKUP(value, efx_loopback_mode));
+}
+
+#define EFX_LOOPBACK_MODE_PARAMETER(container_type, parameter)		\
+	EFX_PARAMETER(container_type, parameter,			\
+		      enum efx_loopback_mode, efx_debugfs_read_loop_mode)
+
+int efx_debugfs_read_string(struct seq_file *file, void *data)
+{
+	return seq_printf(file, "%s\n", (const char *)data);
+}
+
+
+/**
+ * efx_init_debugfs_files - create parameter-files in a debugfs directory
+ * @parent:		Containing directory
+ * @params:		Pointer to zero-terminated parameter definition array
+ * @ignore:		Bitmask of array entries to ignore
+ * @structure:		Structure containing parameters
+ *
+ * Add parameter-files to the given debugfs directory.  Return a
+ * negative error code or 0 on success.
+ */
+static int
+efx_init_debugfs_files(efx_debugfs_entry *parent,
+		       struct efx_debugfs_parameter *params, u64 ignore,
+		       void *(*get_struct)(void *, unsigned),
+		       void *ref, unsigned struct_index)
+{
+	struct efx_debugfs_bound_param *binding;
+	unsigned int pos;
+
+	for (pos = 0; params[pos].name; pos++) {
+		efx_debugfs_entry *entry;
+
+		if ((1ULL << pos) & ignore)
+			continue;
+
+		binding = kmalloc(sizeof(*binding), GFP_KERNEL);
+		if (!binding)
+			goto err;
+		binding->param = &params[pos];
+		binding->get_struct = get_struct;
+		binding->ref = ref;
+		binding->index = struct_index;
+
+#if !defined(EFX_USE_KCOMPAT) || defined(EFX_USE_DEBUGFS)
+		entry = debugfs_create_file(params[pos].name, S_IRUGO, parent,
+					    binding, &efx_debugfs_file_ops);
+#else
+		entry = create_proc_entry(params[pos].name, S_IRUGO, parent);
+		if (entry) {
+			entry->data = binding;
+			smp_wmb();
+			entry->proc_fops = &efx_debugfs_file_ops;
+
+			/* Add binding to parent's list so it can be
+			 * freed when the parent is removed.
+			 */
+			binding->next = parent->data;
+			parent->data = binding;
+		}
+#endif
+		if (!entry) {
+			kfree(binding);
+			goto err;
+		}
+	}
+
+	return 0;
+
+ err:
+	while (pos--) {
+		if ((1ULL << pos) & ignore)
+			continue;
+
+		efx_fini_debugfs_child(parent, params[pos].name);
+	}
+	return -ENOMEM;
+}
+
+/**
+ * efx_init_debugfs_netdev - create debugfs sym-links for net device
+ * @net_dev:		Net device
+ *
+ * Create sym-links named after @net_dev to the debugfs directories for
+ * the corresponding NIC and  port.  Return a negative error code or 0 on
+ * success.  The sym-links must be cleaned up using
+ * efx_fini_debugfs_netdev().
+ */
+int efx_init_debugfs_netdev(struct net_device *net_dev)
+{
+	struct efx_nic *efx = netdev_priv(net_dev);
+	char name[EFX_DEBUGFS_NAME_LEN];
+	char target[EFX_DEBUGFS_NAME_LEN];
+	size_t len;
+
+	if (snprintf(name, sizeof(name), "nic_%s", net_dev->name) >=
+	    sizeof(name))
+		return -ENAMETOOLONG;
+	if (snprintf(target, sizeof(target), "cards/%s", pci_name(efx->pci_dev))
+	    >= sizeof(target))
+		return -ENAMETOOLONG;
+	efx->debug_symlink = debugfs_create_symlink(name,
+						    efx_debug_root, target);
+	if (!efx->debug_symlink)
+		return -ENOMEM;
+
+	if (snprintf(name, sizeof(name), "if_%s", net_dev->name) >=
+	    sizeof(name))
+		return -ENAMETOOLONG;
+	len = snprintf(target, sizeof(target),
+		       "cards/%s/port0", pci_name(efx->pci_dev));
+	if (len >= sizeof(target))
+		return -ENAMETOOLONG;
+	efx->debug_port_symlink = debugfs_create_symlink(name,
+							 efx_debug_root,
+							 target);
+	if (!efx->debug_port_symlink)
+		return -ENOMEM;
+
+	return 0;
+}
+
+/**
+ * efx_fini_debugfs_netdev - remove debugfs sym-links for net device
+ * @net_dev:		Net device
+ *
+ * Remove sym-links created for @net_dev by efx_init_debugfs_netdev().
+ */
+void efx_fini_debugfs_netdev(struct net_device *net_dev)
+{
+	struct efx_nic *efx = netdev_priv(net_dev);
+
+	debugfs_remove(efx->debug_port_symlink);
+	efx->debug_port_symlink = NULL;
+	debugfs_remove(efx->debug_symlink);
+	efx->debug_symlink = NULL;
+}
+
+/* Per-port parameters */
+static struct efx_debugfs_parameter efx_debugfs_port_parameters[] = {
+	EFX_NAMED_PARAMETER(enabled, struct efx_nic, port_enabled,
+			    bool, efx_debugfs_read_bool),
+#if defined(EFX_USE_KCOMPAT) && !defined(NETIF_F_LRO)
+	EFX_BOOL_PARAMETER(struct efx_nic, lro_enabled),
+#endif
+	EFX_BOOL_PARAMETER(struct efx_nic, rx_checksum_enabled),
+	EFX_NAMED_PARAMETER(link_up, struct efx_nic, link_state.up,
+			    bool, efx_debugfs_read_bool),
+	EFX_NAMED_PARAMETER(link_fd, struct efx_nic, link_state.fd,
+			    bool, efx_debugfs_read_bool),
+	EFX_NAMED_PARAMETER(link_speed, struct efx_nic, link_state.speed,
+			    unsigned int, efx_debugfs_read_uint),
+	EFX_BOOL_PARAMETER(struct efx_nic, promiscuous),
+	EFX_U64_PARAMETER(struct efx_nic, loopback_modes),
+	EFX_LOOPBACK_MODE_PARAMETER(struct efx_nic, loopback_mode),
+	EFX_UINT_PARAMETER(struct efx_nic, phy_type),
+	EFX_STRING_PARAMETER(struct efx_nic, phy_name),
+	EFX_NAMED_PARAMETER(phy_id, struct efx_nic, mdio.prtad,
+			    int, efx_debugfs_read_int),
+	EFX_UINT_PARAMETER(struct efx_nic, n_link_state_changes),
+	{NULL},
+};
+
+static void *efx_debugfs_get_same(void *ref, unsigned index)
+{
+	return ref;
+}
+
+/**
+ * efx_init_debugfs_port - create debugfs directory for port
+ * @efx:		Efx NIC
+ *
+ * Create a debugfs directory containing parameter-files for @efx.
+ * Return a negative error code or 0 on success.  The directory must be
+ * cleaned up using efx_fini_debugfs_port().
+ */
+int efx_init_debugfs_port(struct efx_nic *efx)
+{
+	int rc;
+
+	/* Create directory */
+	efx->debug_port_dir = debugfs_create_dir("port0", efx->debug_dir);
+	if (!efx->debug_port_dir)
+		return -ENOMEM;
+
+	/* Create files */
+	rc = efx_init_debugfs_files(efx->debug_port_dir,
+				    efx_debugfs_port_parameters, 0,
+				    efx_debugfs_get_same, efx, 0);
+	if (rc)
+		efx_fini_debugfs_port(efx);
+
+	return rc;
+}
+
+/**
+ * efx_fini_debugfs_port - remove debugfs directory for port
+ * @efx:		Efx NIC
+ *
+ * Remove directory created for @efx by efx_init_debugfs_port().
+ */
+void efx_fini_debugfs_port(struct efx_nic *efx)
+{
+	efx_fini_debugfs_dir(efx->debug_port_dir,
+			     efx_debugfs_port_parameters, NULL);
+	efx->debug_port_dir = NULL;
+}
+
+/**
+ * efx_extend_debugfs_port - add parameter-files to directory for port
+ * @efx:		Efx NIC
+ * @structure:		Structure containing parameters
+ * @ignore:		Bitmask of structure elements to ignore
+ * @params:		Pointer to zero-terminated parameter definition array
+ *
+ * Add parameter-files to the debugfs directory for @efx.  Return
+ * a negative error code or 0 on success.  This is intended for
+ * PHY-specific parameters.  The files must be cleaned up using
+ * efx_trim_debugfs_port().
+ */
+int efx_extend_debugfs_port(struct efx_nic *efx,
+			    void *structure, u64 ignore,
+			    struct efx_debugfs_parameter *params)
+{
+	return efx_init_debugfs_files(efx->debug_port_dir, params, ignore,
+				      efx_debugfs_get_same, structure, 0);
+}
+
+/**
+ * efx_trim_debugfs_port - remove parameter-files from directory for port
+ * @efx:		Efx NIC
+ * @params:		Pointer to zero-terminated parameter definition array
+ *
+ * Remove parameter-files previously added to the debugfs directory
+ * for @efx using efx_extend_debugfs_port().
+ */
+void efx_trim_debugfs_port(struct efx_nic *efx,
+			   struct efx_debugfs_parameter *params)
+{
+	efx_debugfs_entry *dir = efx->debug_port_dir;
+
+	if (dir) {
+		struct efx_debugfs_parameter *field;
+		for (field = params; field->name; field++)
+			efx_fini_debugfs_child(dir, field->name);
+	}
+}
+
+/* Per-TX-queue parameters */
+static struct efx_debugfs_parameter efx_debugfs_tx_queue_parameters[] = {
+	EFX_UINT_PARAMETER(struct efx_tx_queue, insert_count),
+	EFX_UINT_PARAMETER(struct efx_tx_queue, write_count),
+	EFX_UINT_PARAMETER(struct efx_tx_queue, read_count),
+	EFX_UINT_PARAMETER(struct efx_tx_queue, tso_bursts),
+	EFX_UINT_PARAMETER(struct efx_tx_queue, tso_long_headers),
+	EFX_UINT_PARAMETER(struct efx_tx_queue, tso_packets),
+	EFX_UINT_PARAMETER(struct efx_tx_queue, pushes),
+	{NULL},
+};
+
+static void *efx_debugfs_get_tx_queue(void *ref, unsigned index)
+{
+	return efx_get_tx_queue(ref, index / EFX_TXQ_TYPES,
+				index % EFX_TXQ_TYPES);
+}
+
+static void efx_fini_debugfs_tx_queue(struct efx_tx_queue *tx_queue);
+
+/**
+ * efx_init_debugfs_tx_queue - create debugfs directory for TX queue
+ * @tx_queue:		Efx TX queue
+ *
+ * Create a debugfs directory containing parameter-files for @tx_queue.
+ * Return a negative error code or 0 on success.  The directory must be
+ * cleaned up using efx_fini_debugfs_tx_queue().
+ */
+static int efx_init_debugfs_tx_queue(struct efx_tx_queue *tx_queue)
+{
+	char name[EFX_DEBUGFS_NAME_LEN];
+	char target[EFX_DEBUGFS_NAME_LEN];
+	int rc;
+
+	/* Create directory */
+	if (snprintf(name, sizeof(name), EFX_TX_QUEUE_NAME(tx_queue))
+	    >= sizeof(name))
+		goto err_len;
+	tx_queue->debug_dir = debugfs_create_dir(name,
+						 tx_queue->efx->debug_dir);
+	if (!tx_queue->debug_dir)
+		goto err_mem;
+
+	/* Create files */
+	rc = efx_init_debugfs_files(tx_queue->debug_dir,
+				    efx_debugfs_tx_queue_parameters, 0,
+				    efx_debugfs_get_tx_queue, tx_queue->efx,
+				    tx_queue->queue);
+	if (rc)
+		goto err;
+
+	/* Create symlink to channel */
+	if (snprintf(target, sizeof(target),
+		     "../" EFX_CHANNEL_NAME(tx_queue->channel)) >=
+	    sizeof(target))
+		goto err_len;
+	if (!debugfs_create_symlink("channel", tx_queue->debug_dir, target))
+		goto err_mem;
+
+	/* Create symlink to port */
+	if (!debugfs_create_symlink("port", tx_queue->debug_dir, "../port0"))
+		goto err_mem;
+
+	return 0;
+
+ err_len:
+	rc = -ENAMETOOLONG;
+	goto err;
+ err_mem:
+	rc = -ENOMEM;
+ err:
+	efx_fini_debugfs_tx_queue(tx_queue);
+	return rc;
+}
+
+/**
+ * efx_fini_debugfs_tx_queue - remove debugfs directory for TX queue
+ * @tx_queue:		Efx TX queue
+ *
+ * Remove directory created for @tx_queue by efx_init_debugfs_tx_queue().
+ */
+static void efx_fini_debugfs_tx_queue(struct efx_tx_queue *tx_queue)
+{
+	static const char *const symlink_names[] = {
+		"channel", "port", NULL
+	};
+
+	efx_fini_debugfs_dir(tx_queue->debug_dir,
+			     efx_debugfs_tx_queue_parameters, symlink_names);
+	tx_queue->debug_dir = NULL;
+}
+
+/* Per-RX-queue parameters */
+static struct efx_debugfs_parameter efx_debugfs_rx_queue_parameters[] = {
+	EFX_INT_PARAMETER(struct efx_rx_queue, added_count),
+	EFX_INT_PARAMETER(struct efx_rx_queue, removed_count),
+	EFX_UINT_PARAMETER(struct efx_rx_queue, max_fill),
+	EFX_UINT_PARAMETER(struct efx_rx_queue, fast_fill_trigger),
+	EFX_UINT_PARAMETER(struct efx_rx_queue, fast_fill_limit),
+	EFX_UINT_PARAMETER(struct efx_rx_queue, min_fill),
+	EFX_UINT_PARAMETER(struct efx_rx_queue, alloc_page_count),
+	EFX_UINT_PARAMETER(struct efx_rx_queue, alloc_skb_count),
+	EFX_UINT_PARAMETER(struct efx_rx_queue, recycle_count),
+	EFX_UINT_PARAMETER(struct efx_rx_queue, resurrect_count),
+	EFX_UINT_PARAMETER(struct efx_rx_queue, resurrect_failed_count),
+	EFX_UINT_PARAMETER(struct efx_rx_queue, slow_fill_count),
+	{NULL},
+};
+
+static void *efx_debugfs_get_rx_queue(void *ref, unsigned index)
+{
+	return efx_channel_get_rx_queue(efx_get_channel(ref, index));
+}
+
+static void efx_fini_debugfs_rx_queue(struct efx_rx_queue *rx_queue);
+
+/**
+ * efx_init_debugfs_rx_queue - create debugfs directory for RX queue
+ * @rx_queue:		Efx RX queue
+ *
+ * Create a debugfs directory containing parameter-files for @rx_queue.
+ * Return a negative error code or 0 on success.  The directory must be
+ * cleaned up using efx_fini_debugfs_rx_queue().
+ */
+static int efx_init_debugfs_rx_queue(struct efx_rx_queue *rx_queue)
+{
+	char name[EFX_DEBUGFS_NAME_LEN];
+	char target[EFX_DEBUGFS_NAME_LEN];
+	int rc;
+
+	/* Create directory */
+	if (snprintf(name, sizeof(name), EFX_RX_QUEUE_NAME(rx_queue))
+	    >= sizeof(name))
+		goto err_len;
+	rx_queue->debug_dir = debugfs_create_dir(name,
+						 rx_queue->efx->debug_dir);
+	if (!rx_queue->debug_dir)
+		goto err_mem;
+
+	/* Create files */
+	rc = efx_init_debugfs_files(rx_queue->debug_dir,
+				    efx_debugfs_rx_queue_parameters, 0,
+				    efx_debugfs_get_rx_queue, rx_queue->efx,
+				    efx_rx_queue_index(rx_queue));
+	if (rc)
+		goto err;
+
+	/* Create symlink to channel */
+	if (snprintf(target, sizeof(target),
+		     "../" EFX_CHANNEL_NAME(efx_rx_queue_channel(rx_queue))) >=
+	    sizeof(target))
+		goto err_len;
+	if (!debugfs_create_symlink("channel", rx_queue->debug_dir, target))
+		goto err_mem;
+
+	return 0;
+
+ err_len:
+	rc = -ENAMETOOLONG;
+	goto err;
+ err_mem:
+	rc = -ENOMEM;
+ err:
+	efx_fini_debugfs_rx_queue(rx_queue);
+	return rc;
+}
+
+/**
+ * efx_fini_debugfs_rx_queue - remove debugfs directory for RX queue
+ * @rx_queue:		Efx RX queue
+ *
+ * Remove directory created for @rx_queue by efx_init_debugfs_rx_queue().
+ */
+static void efx_fini_debugfs_rx_queue(struct efx_rx_queue *rx_queue)
+{
+	const char *const symlink_names[] = {
+		"channel", NULL
+	};
+
+	efx_fini_debugfs_dir(rx_queue->debug_dir,
+			     efx_debugfs_rx_queue_parameters, symlink_names);
+	rx_queue->debug_dir = NULL;
+}
+
+/* Per-channel parameters */
+static struct efx_debugfs_parameter efx_debugfs_channel_parameters[] = {
+	EFX_BOOL_PARAMETER(struct efx_channel, enabled),
+	EFX_INT_PARAMETER(struct efx_channel, irq),
+	EFX_UINT_PARAMETER(struct efx_channel, irq_moderation),
+	EFX_UINT_PARAMETER(struct efx_channel, eventq_read_ptr),
+	EFX_UINT_PARAMETER(struct efx_channel, n_rx_tobe_disc),
+	EFX_UINT_PARAMETER(struct efx_channel, n_rx_ip_frag),
+	EFX_UINT_PARAMETER(struct efx_channel, n_rx_ip_hdr_chksum_err),
+	EFX_UINT_PARAMETER(struct efx_channel, n_rx_tcp_udp_chksum_err),
+	EFX_UINT_PARAMETER(struct efx_channel, n_rx_eth_crc_err),
+	EFX_UINT_PARAMETER(struct efx_channel, n_rx_mcast_mismatch),
+	EFX_UINT_PARAMETER(struct efx_channel, n_rx_frm_trunc),
+	EFX_UINT_PARAMETER(struct efx_channel, n_rx_overlength),
+	EFX_UINT_PARAMETER(struct efx_channel, n_skbuff_leaks),
+	EFX_INT_PARAMETER(struct efx_channel, rx_alloc_level),
+	EFX_INT_PARAMETER(struct efx_channel, rx_alloc_push_pages),
+	{NULL},
+};
+
+static void *efx_debugfs_get_channel(void *ref, unsigned index)
+{
+	return efx_get_channel(ref, index);
+}
+
+static void efx_fini_debugfs_channel(struct efx_channel *channel);
+
+/**
+ * efx_init_debugfs_channel - create debugfs directory for channel
+ * @channel:		Efx channel
+ *
+ * Create a debugfs directory containing parameter-files for @channel.
+ * Return a negative error code or 0 on success.  The directory must be
+ * cleaned up using efx_fini_debugfs_channel().
+ */
+static int efx_init_debugfs_channel(struct efx_channel *channel)
+{
+	char name[EFX_DEBUGFS_NAME_LEN];
+	int rc;
+
+	/* Create directory */
+	if (snprintf(name, sizeof(name), EFX_CHANNEL_NAME(channel))
+	    >= sizeof(name))
+		goto err_len;
+	channel->debug_dir = debugfs_create_dir(name, channel->efx->debug_dir);
+	if (!channel->debug_dir)
+		goto err_mem;
+
+	/* Create files */
+	rc = efx_init_debugfs_files(channel->debug_dir,
+				    efx_debugfs_channel_parameters, 0,
+				    efx_debugfs_get_channel, channel->efx,
+				    channel->channel);
+	if (rc)
+		goto err;
+
+	return 0;
+
+ err_len:
+	rc = -ENAMETOOLONG;
+	goto err;
+ err_mem:
+	rc = -ENOMEM;
+ err:
+	efx_fini_debugfs_channel(channel);
+	return rc;
+}
+
+/**
+ * efx_fini_debugfs_channel - remove debugfs directory for channel
+ * @channel:		Efx channel
+ *
+ * Remove directory created for @channel by efx_init_debugfs_channel().
+ */
+static void efx_fini_debugfs_channel(struct efx_channel *channel)
+{
+	efx_fini_debugfs_dir(channel->debug_dir,
+			     efx_debugfs_channel_parameters, NULL);
+	channel->debug_dir = NULL;
+}
+
+/* Per-NIC parameters */
+static struct efx_debugfs_parameter efx_debugfs_nic_parameters[] = {
+	EFX_INT_PARAMETER(struct efx_nic, legacy_irq),
+	EFX_UINT_PARAMETER(struct efx_nic, irq_zero_count),
+	/* Runbench requires we call this n_rx_queues and use decimal format */
+	EFX_NAMED_PARAMETER(n_rx_queues, struct efx_nic, n_rx_channels,
+			    unsigned int, efx_debugfs_read_int),
+	EFX_UINT_PARAMETER(struct efx_nic, n_tx_channels),
+	EFX_UINT_PARAMETER(struct efx_nic, rx_buffer_len),
+	EFX_INT_MODE_PARAMETER(struct efx_nic, interrupt_mode),
+	EFX_UINT_PARAMETER(struct efx_nic, state),
+	{.name = "hardware_desc",
+	 .offset = 0,
+	 .reader = efx_nic_debugfs_read_desc},
+	{NULL},
+};
+
+/* Per-NIC error counts */
+static struct efx_debugfs_parameter efx_debugfs_nic_error_parameters[] = {
+	EFX_ATOMIC_PARAMETER(struct efx_nic_errors, missing_event),
+	EFX_ATOMIC_PARAMETER(struct efx_nic_errors, rx_reset),
+	EFX_ATOMIC_PARAMETER(struct efx_nic_errors, rx_desc_fetch),
+	EFX_ATOMIC_PARAMETER(struct efx_nic_errors, tx_desc_fetch),
+	EFX_ATOMIC_PARAMETER(struct efx_nic_errors, spurious_tx),
+	{NULL},
+};
+
+/**
+ * efx_init_debugfs_channels - create debugfs directories for NIC channels
+ * @efx:		Efx NIC
+ *
+ * Create subdirectories of @efx's debugfs directory for all the
+ * channels, RX queues and TX queues used by this driver.  Return a
+ * negative error code or 0 on success.  The subdirectories must be
+ * cleaned up using efx_fini_debugfs_channels().
+ */
+int efx_init_debugfs_channels(struct efx_nic *efx)
+{
+	struct efx_channel *channel;
+	struct efx_rx_queue *rx_queue;
+	struct efx_tx_queue *tx_queue;
+	int rc;
+
+	efx_for_each_channel(channel, efx) {
+		rc = efx_init_debugfs_channel(channel);
+		if (rc)
+			goto err;
+
+		efx_for_each_channel_rx_queue(rx_queue, channel) {
+			rc = efx_init_debugfs_rx_queue(rx_queue);
+			if (rc)
+				goto err;
+		}
+
+		efx_for_each_channel_tx_queue(tx_queue, channel) {
+			rc = efx_init_debugfs_tx_queue(tx_queue);
+			if (rc)
+				goto err;
+		}
+	}
+
+	return 0;
+
+ err:
+	efx_fini_debugfs_channels(efx);
+	return rc;
+}
+
+/**
+ * efx_fini_debugfs_channels - remove debugfs directories for NIC queues
+ * @efx:		Efx NIC
+ *
+ * Remove subdirectories of @efx's debugfs directory created by
+ * efx_init_debugfs_channels().
+ */
+void efx_fini_debugfs_channels(struct efx_nic *efx)
+{
+	struct efx_channel *channel;
+	struct efx_rx_queue *rx_queue;
+	struct efx_tx_queue *tx_queue;
+
+	efx_for_each_channel(channel, efx) {
+		efx_for_each_channel_tx_queue(tx_queue, channel)
+			efx_fini_debugfs_tx_queue(tx_queue);
+
+		efx_for_each_channel_rx_queue(rx_queue, channel)
+			efx_fini_debugfs_rx_queue(rx_queue);
+
+		efx_fini_debugfs_channel(channel);
+	}
+}
+
+/**
+ * efx_init_debugfs_nic - create debugfs directory for NIC
+ * @efx:		Efx NIC
+ *
+ * Create debugfs directory containing parameter-files for @efx,
+ * and a subdirectory "errors" containing per-NIC error counts.
+ * Return a negative error code or 0 on success.  The directories
+ * must be cleaned up using efx_fini_debugfs_nic().
+ */
+int efx_init_debugfs_nic(struct efx_nic *efx)
+{
+	int rc;
+
+	/* Create directory */
+	efx->debug_dir = debugfs_create_dir(pci_name(efx->pci_dev),
+					    efx_debug_cards);
+	if (!efx->debug_dir)
+		goto err_mem;
+
+	/* Create errors directory */
+	efx->errors.debug_dir = debugfs_create_dir("errors", efx->debug_dir);
+	if (!efx->errors.debug_dir)
+		goto err_mem;
+
+	/* Create files */
+	rc = efx_init_debugfs_files(efx->debug_dir,
+				    efx_debugfs_nic_parameters, 0,
+				    efx_debugfs_get_same, efx, 0);
+	if (rc)
+		goto err;
+	rc = efx_init_debugfs_files(efx->errors.debug_dir,
+				    efx_debugfs_nic_error_parameters, 0,
+				    efx_debugfs_get_same, &efx->errors, 0);
+	if (rc)
+		goto err;
+
+	return 0;
+
+ err_mem:
+	rc = -ENOMEM;
+ err:
+	efx_fini_debugfs_nic(efx);
+	return rc;
+}
+
+/**
+ * efx_fini_debugfs_nic - remove debugfs directories for NIC
+ * @efx:		Efx NIC
+ *
+ * Remove debugfs directories created for @efx by efx_init_debugfs_nic().
+ */
+void efx_fini_debugfs_nic(struct efx_nic *efx)
+{
+	efx_fini_debugfs_dir(efx->errors.debug_dir,
+			     efx_debugfs_nic_error_parameters, NULL);
+	efx->errors.debug_dir = NULL;
+	efx_fini_debugfs_dir(efx->debug_dir, efx_debugfs_nic_parameters, NULL);
+	efx->debug_dir = NULL;
+}
+
+/**
+ * efx_init_debugfs - create debugfs directories for sfc driver
+ *
+ * Create debugfs directories "sfc" and "sfc/cards".  This must be
+ * called before any of the other functions that create debugfs
+ * directories.  Return a negative error code or 0 on success.  The
+ * directories must be cleaned up using efx_fini_debugfs().
+ */
+int efx_init_debugfs(void)
+{
+	/* Create top-level directory */
+#if !defined(EFX_USE_KCOMPAT) || defined(EFX_USE_DEBUGFS)
+	efx_debug_root = debugfs_create_dir("sfc", NULL);
+#else
+	efx_debug_root = proc_mkdir("driver/sfc", NULL);
+#endif
+	if (!efx_debug_root)
+		goto err;
+
+	/* Create "cards" directory */
+	efx_debug_cards = debugfs_create_dir("cards", efx_debug_root);
+	if (!efx_debug_cards)
+		goto err;
+
+#if defined(EFX_USE_KCOMPAT) && defined(EFX_USE_DEBUGFS)
+	/* Create compatibility sym-link */
+	if (!proc_symlink("driver/sfc", NULL, "/sys/kernel/debug/sfc"))
+		goto err;
+#endif
+	return 0;
+
+ err:
+	efx_fini_debugfs();
+	return -ENOMEM;
+}
+
+/**
+ * efx_fini_debugfs - remove debugfs directories for sfc driver
+ *
+ * Remove directories created by efx_init_debugfs().
+ */
+void efx_fini_debugfs(void)
+{
+#if defined(EFX_USE_KCOMPAT) && defined(EFX_USE_DEBUGFS)
+	remove_proc_entry("driver/sfc", NULL);
+#endif
+	debugfs_remove(efx_debug_cards);
+	efx_debug_cards = NULL;
+	debugfs_remove(efx_debug_root);
+	efx_debug_root = NULL;
+}
diff -r 9566a4a50a43 drivers/net/sfc/debugfs.h
--- /dev/null
+++ b/drivers/net/sfc/debugfs.h
@@ -0,0 +1,40 @@
+/****************************************************************************
+ * Driver for Solarflare Solarstorm network controllers and boards
+ * Copyright 2005-2006 Fen Systems Ltd.
+ * Copyright 2006-2010 Solarflare Communications Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 as published
+ * by the Free Software Foundation, incorporated herein by reference.
+ */
+
+#ifndef EFX_DEBUGFS_H
+#define EFX_DEBUGFS_H
+
+static inline int efx_init_debugfs_netdev(struct net_device *net_dev)
+{
+	return 0;
+}
+static inline void efx_fini_debugfs_netdev(struct net_device *net_dev) {}
+static inline int efx_init_debugfs_port(struct efx_nic *efx)
+{
+	return 0;
+}
+static inline void efx_fini_debugfs_port(struct efx_nic *efx) {}
+static inline int efx_init_debugfs_nic(struct efx_nic *efx)
+{
+	return 0;
+}
+static inline void efx_fini_debugfs_nic(struct efx_nic *efx) {}
+static inline int efx_init_debugfs_channels(struct efx_nic *efx)
+{
+	return 0;
+}
+static inline void efx_fini_debugfs_channels(struct efx_nic *efx) {}
+static inline int efx_init_debugfs(void)
+{
+	return 0;
+}
+static inline void efx_fini_debugfs(void) {}
+
+#endif /* EFX_DEBUGFS_H */
diff -r 9566a4a50a43 drivers/net/sfc/driverlink.c
--- a/drivers/net/sfc/driverlink.c
+++ b/drivers/net/sfc/driverlink.c
@@ -1,7 +1,7 @@
 /****************************************************************************
  * Driver for Solarflare Solarstorm network controllers and boards
  * Copyright 2005      Fen Systems Ltd.
- * Copyright 2005-2008 Solarflare Communications Inc.
+ * Copyright 2005-2010 Solarflare Communications Inc.
  *
  * This program is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 as published
@@ -12,18 +12,21 @@
 #include <linux/list.h>
 #include <linux/skbuff.h>
 #include <linux/rtnetlink.h>
+#include <linux/slab.h>
 #include "net_driver.h"
 #include "efx.h"
+#include "driverlink_api.h"
 #include "driverlink.h"
+#include "filter.h"
+#include "nic.h"
 
-/* Protects @efx_driverlink_lock and @efx_driver_list */
-static DEFINE_MUTEX(efx_driverlink_lock);
+/* Global lists are protected by rtnl_lock */
 
 /* List of all registered drivers */
 static LIST_HEAD(efx_driver_list);
 
-/* List of all registered Efx ports */
-static LIST_HEAD(efx_port_list);
+/* List of all registered Efx ports. Protected by the rtnl_lock */
+LIST_HEAD(efx_port_list);
 
 /**
  * Driver link handle used internally to track devices
@@ -45,13 +48,18 @@ static struct efx_dl_handle *efx_dl_hand
 }
 
 /* Remove an Efx device, and call the driver's remove() callback if
- * present. The caller must hold @efx_driverlink_lock. */
+ * present. The caller must hold rtnl_lock. */
 static void efx_dl_del_device(struct efx_dl_device *efx_dev)
 {
 	struct efx_dl_handle *efx_handle = efx_dl_handle(efx_dev);
+	struct efx_nic *efx = efx_handle->efx;
 
-	EFX_INFO(efx_handle->efx, "%s driverlink client unregistering\n",
-		 efx_dev->driver->name);
+	netif_info(efx, drv, efx->net_dev,
+		   "%s driverlink client unregistering\n",
+		   efx_dev->driver->name);
+
+	if (efx->dl_event_handler == efx_dev)
+		efx->dl_event_handler = NULL;
 
 	if (efx_dev->driver->remove)
 		efx_dev->driver->remove(efx_dev);
@@ -83,18 +91,32 @@ static void efx_dl_try_add_device(struct
 	INIT_LIST_HEAD(&efx_handle->driver_node);
 
 	rc = driver->probe(efx_dev, efx->net_dev,
-			   efx->dl_info, efx->silicon_rev);
+			   efx->dl_info, efx->type->dl_revision);
 	if (rc)
 		goto fail;
 
 	list_add_tail(&efx_handle->driver_node, &driver->device_list);
 	list_add_tail(&efx_handle->port_node, &efx->dl_device_list);
 
-	EFX_INFO(efx, "%s driverlink client registered\n", driver->name);
+	/* Install event handler if appropriate */
+	if (!efx_nic_is_dual_func(efx) && driver->handle_event) {
+		if (efx->dl_event_handler) {
+			netif_warn(efx, drv, efx->net_dev,
+				   "not replacing %s event handler with %s\n",
+				   efx->dl_event_handler->driver->name,
+				   driver->name);
+		} else {
+			efx->dl_event_handler = efx_dev;
+		}
+	}
+
+	netif_info(efx, drv, efx->net_dev,
+		   "%s driverlink client registered\n", driver->name);
 	return;
 
  fail:
-	EFX_INFO(efx, "%s driverlink client skipped\n", driver->name);
+	netif_info(efx, drv, efx->net_dev,
+		   "%s driverlink client skipped\n", driver->name);
 
 	kfree(efx_handle);
 }
@@ -108,7 +130,7 @@ void efx_dl_unregister_driver(struct efx
 	printk(KERN_INFO "Efx driverlink unregistering %s driver\n",
 		 driver->name);
 
-	mutex_lock(&efx_driverlink_lock);
+	rtnl_lock();
 
 	list_for_each_entry_safe(efx_handle, efx_handle_n,
 				 &driver->device_list, driver_node)
@@ -116,7 +138,7 @@ void efx_dl_unregister_driver(struct efx
 
 	list_del(&driver->node);
 
-	mutex_unlock(&efx_driverlink_lock);
+	rtnl_unlock();
 }
 EXPORT_SYMBOL(efx_dl_unregister_driver);
 
@@ -125,7 +147,6 @@ EXPORT_SYMBOL(efx_dl_unregister_driver);
 int efx_dl_register_driver(struct efx_dl_driver *driver)
 {
 	struct efx_nic *efx;
-	int rc;
 
 	printk(KERN_INFO "Efx driverlink registering %s driver\n",
 		 driver->name);
@@ -133,16 +154,13 @@ int efx_dl_register_driver(struct efx_dl
 	INIT_LIST_HEAD(&driver->node);
 	INIT_LIST_HEAD(&driver->device_list);
 
-	rc = mutex_lock_interruptible(&efx_driverlink_lock);
-	if (rc)
-		return rc;
+	rtnl_lock();
 
 	list_add_tail(&driver->node, &efx_driver_list);
 	list_for_each_entry(efx, &efx_port_list, dl_node)
 		efx_dl_try_add_device(efx, driver);
 
-	mutex_unlock(&efx_driverlink_lock);
-
+	rtnl_unlock();
 	return 0;
 }
 EXPORT_SYMBOL(efx_dl_register_driver);
@@ -151,7 +169,7 @@ void efx_dl_unregister_nic(struct efx_ni
 {
 	struct efx_dl_handle *efx_handle, *efx_handle_n;
 
-	mutex_lock(&efx_driverlink_lock);
+	ASSERT_RTNL();
 
 	list_for_each_entry_safe_reverse(efx_handle, efx_handle_n,
 					 &efx->dl_device_list,
@@ -159,161 +177,39 @@ void efx_dl_unregister_nic(struct efx_ni
 		efx_dl_del_device(&efx_handle->efx_dev);
 
 	list_del(&efx->dl_node);
-
-	mutex_unlock(&efx_driverlink_lock);
 }
 
-int efx_dl_register_nic(struct efx_nic *efx)
+void efx_dl_register_nic(struct efx_nic *efx)
 {
 	struct efx_dl_driver *driver;
-	int rc;
 
-	rc = mutex_lock_interruptible(&efx_driverlink_lock);
-	if (rc)
-		return rc;
+	ASSERT_RTNL();
 
 	list_add_tail(&efx->dl_node, &efx_port_list);
 	list_for_each_entry(driver, &efx_driver_list, node)
 		efx_dl_try_add_device(efx, driver);
-
-	mutex_unlock(&efx_driverlink_lock);
-
-	return 0;
 }
 
-/* Dummy callback implementations.
- * To avoid a branch point on the fast-path, the callbacks are always
- * implemented - they are never NULL.
- */
-static enum efx_veto efx_dummy_tx_packet_callback(struct efx_dl_device *efx_dev,
-						  struct sk_buff *skb)
+struct efx_dl_device *efx_dl_dev_from_netdev(const struct net_device *net_dev,
+					     struct efx_dl_driver *driver)
 {
-	return EFX_ALLOW_PACKET;
-}
+	struct efx_dl_handle *efx_handle;
+	struct efx_nic *efx;
 
-static enum efx_veto efx_dummy_rx_packet_callback(struct efx_dl_device *efx_dev,
-						  const char *pkt_buf, int len)
-{
-	return EFX_ALLOW_PACKET;
-}
+	ASSERT_RTNL();
 
-static int efx_dummy_request_mtu_callback(struct efx_dl_device *efx_dev,
-					  int new_mtu)
-{
-	return 0;
-}
+	if (!efx_dl_netdev_is_ours(net_dev))
+		return NULL;
 
-static void efx_dummy_mtu_changed_callback(struct efx_dl_device *efx_dev,
-					   int mtu)
-{
-	return;
-}
-
-static void efx_dummy_event_callback(struct efx_dl_device *efx_dev, void *event)
-{
-	return;
-}
-
-struct efx_dl_callbacks efx_default_callbacks = {
-	.tx_packet	= efx_dummy_tx_packet_callback,
-	.rx_packet	= efx_dummy_rx_packet_callback,
-	.request_mtu	= efx_dummy_request_mtu_callback,
-	.mtu_changed	= efx_dummy_mtu_changed_callback,
-	.event		= efx_dummy_event_callback,
-};
-
-void efx_dl_unregister_callbacks(struct efx_dl_device *efx_dev,
-				 struct efx_dl_callbacks *callbacks)
-{
-	struct efx_dl_handle *efx_handle = efx_dl_handle(efx_dev);
-	struct efx_nic *efx = efx_handle->efx;
-
-	efx_suspend(efx);
-
-	EFX_INFO(efx, "removing callback hooks into %s driver\n",
-		 efx_dev->driver->name);
-
-	if (callbacks->tx_packet) {
-		BUG_ON(efx->dl_cb_dev.tx_packet != efx_dev);
-		efx->dl_cb.tx_packet = efx_default_callbacks.tx_packet;
-		efx->dl_cb_dev.tx_packet = NULL;
-	}
-	if (callbacks->rx_packet) {
-		BUG_ON(efx->dl_cb_dev.rx_packet != efx_dev);
-		efx->dl_cb.rx_packet = efx_default_callbacks.rx_packet;
-		efx->dl_cb_dev.rx_packet = NULL;
-	}
-	if (callbacks->request_mtu) {
-		BUG_ON(efx->dl_cb_dev.request_mtu != efx_dev);
-		efx->dl_cb.request_mtu = efx_default_callbacks.request_mtu;
-		efx->dl_cb_dev.request_mtu = NULL;
-	}
-	if (callbacks->mtu_changed) {
-		BUG_ON(efx->dl_cb_dev.mtu_changed != efx_dev);
-		efx->dl_cb.mtu_changed = efx_default_callbacks.mtu_changed;
-		efx->dl_cb_dev.mtu_changed = NULL;
-	}
-	if (callbacks->event) {
-		BUG_ON(efx->dl_cb_dev.event != efx_dev);
-		efx->dl_cb.event = efx_default_callbacks.event;
-		efx->dl_cb_dev.event = NULL;
+	efx = netdev_priv((struct net_device *)net_dev);
+	list_for_each_entry(efx_handle, &efx->dl_device_list, port_node) {
+		if (efx_handle->efx_dev.driver == driver)
+			return &efx_handle->efx_dev;
 	}
 
-	efx_resume(efx);
+	return NULL;
 }
-EXPORT_SYMBOL(efx_dl_unregister_callbacks);
-
-int efx_dl_register_callbacks(struct efx_dl_device *efx_dev,
-			      struct efx_dl_callbacks *callbacks)
-{
-	struct efx_dl_handle *efx_handle = efx_dl_handle(efx_dev);
-	struct efx_nic *efx = efx_handle->efx;
-	int rc = 0;
-
-	efx_suspend(efx);
-
-	/* Check that the requested callbacks are not already hooked. */
-	if ((callbacks->tx_packet && efx->dl_cb_dev.tx_packet) ||
-	    (callbacks->rx_packet && efx->dl_cb_dev.rx_packet) ||
-	    (callbacks->request_mtu && efx->dl_cb_dev.request_mtu) ||
-	    (callbacks->mtu_changed && efx->dl_cb_dev.mtu_changed) ||
-	    (callbacks->event && efx->dl_cb_dev.event)) {
-		rc = -EBUSY;
-		goto out;
-	}
-
-	EFX_INFO(efx, "adding callback hooks to %s driver\n",
-		 efx_dev->driver->name);
-
-	/* Hook in the requested callbacks, leaving any NULL members
-	 * referencing the members of @efx_default_callbacks */
-	if (callbacks->tx_packet) {
-		efx->dl_cb.tx_packet = callbacks->tx_packet;
-		efx->dl_cb_dev.tx_packet = efx_dev;
-	}
-	if (callbacks->rx_packet) {
-		efx->dl_cb.rx_packet = callbacks->rx_packet;
-		efx->dl_cb_dev.rx_packet = efx_dev;
-	}
-	if (callbacks->request_mtu) {
-		efx->dl_cb.request_mtu = callbacks->request_mtu;
-		efx->dl_cb_dev.request_mtu = efx_dev;
-	}
-	if (callbacks->mtu_changed) {
-		efx->dl_cb.mtu_changed = callbacks->mtu_changed;
-		efx->dl_cb_dev.mtu_changed = efx_dev;
-	}
-	if (callbacks->event) {
-		efx->dl_cb.event = callbacks->event;
-		efx->dl_cb_dev.event = efx_dev;
-	}
-
- out:
-	efx_resume(efx);
-
-	return rc;
-}
-EXPORT_SYMBOL(efx_dl_register_callbacks);
+EXPORT_SYMBOL(efx_dl_dev_from_netdev);
 
 void efx_dl_schedule_reset(struct efx_dl_device *efx_dev)
 {
@@ -324,19 +220,14 @@ void efx_dl_schedule_reset(struct efx_dl
 }
 EXPORT_SYMBOL(efx_dl_schedule_reset);
 
-void efx_dl_reset_unlock(void)
-{
-	mutex_unlock(&efx_driverlink_lock);
-}
-
-/* Suspend ready for reset, serialising against all the driverlink interfacse
- * and calling the suspend() callback of every registered driver */
+/* Suspend ready for reset, calling the reset_suspend() callback of every
+ * registered driver */
 void efx_dl_reset_suspend(struct efx_nic *efx)
 {
 	struct efx_dl_handle *efx_handle;
 	struct efx_dl_device *efx_dev;
 
-	mutex_lock(&efx_driverlink_lock);
+	ASSERT_RTNL();
 
 	list_for_each_entry_reverse(efx_handle,
 				    &efx->dl_device_list,
@@ -348,19 +239,74 @@ void efx_dl_reset_suspend(struct efx_nic
 }
 
 /* Resume after a reset, calling the resume() callback of every registered
- * driver, and releasing @Efx_driverlink_lock acquired in
- * efx_dl_reset_resume() */
+ * driver */
 void efx_dl_reset_resume(struct efx_nic *efx, int ok)
 {
 	struct efx_dl_handle *efx_handle;
 	struct efx_dl_device *efx_dev;
 
+	ASSERT_RTNL();
+
 	list_for_each_entry(efx_handle, &efx->dl_device_list,
 			    port_node) {
 		efx_dev = &efx_handle->efx_dev;
 		if (efx_dev->driver->reset_resume)
 			efx_dev->driver->reset_resume(efx_dev, ok);
 	}
+}
 
-	mutex_unlock(&efx_driverlink_lock);
+bool efx_dl_handle_event(struct efx_nic *efx, void *event)
+{
+	struct efx_dl_device *efx_dev = efx->dl_event_handler;
+
+	if (!efx_dev)
+		return false;
+
+	efx_dev->driver->handle_event(efx_dev, event);
+	return true;
 }
+
+EXPORT_SYMBOL(efx_filter_set_ipv4_local);
+EXPORT_SYMBOL(efx_filter_set_ipv4_full);
+EXPORT_SYMBOL(efx_filter_set_eth_local);
+EXPORT_SYMBOL(efx_filter_set_uc_def);
+EXPORT_SYMBOL(efx_filter_set_mc_def);
+
+/* We additionally include priority in the filter ID so that we
+ * can pass it back into efx_filter_remove_id_safe().
+ */
+#define EFX_FILTER_PRI_SHIFT	28
+#define EFX_FILTER_ID_MASK	((1 << EFX_FILTER_PRI_SHIFT) - 1)
+
+int efx_dl_filter_insert(struct efx_dl_device *efx_dev,
+			 struct efx_filter_spec *spec,
+			 bool replace)
+{
+	s32 filter_id = efx_filter_insert_filter(efx_dl_handle(efx_dev)->efx,
+						 spec, replace);
+	if (filter_id >= 0) {
+		EFX_BUG_ON_PARANOID(filter_id & ~EFX_FILTER_ID_MASK);
+		filter_id |= spec->priority << EFX_FILTER_PRI_SHIFT;
+	}
+	return filter_id;
+}
+EXPORT_SYMBOL(efx_dl_filter_insert);
+
+void efx_dl_filter_remove(struct efx_dl_device *efx_dev, int filter_id)
+{
+	if (filter_id < 0)
+		return;
+	efx_filter_remove_id_safe(efx_dl_handle(efx_dev)->efx,
+				  filter_id >> EFX_FILTER_PRI_SHIFT,
+				  filter_id & EFX_FILTER_ID_MASK);
+}
+EXPORT_SYMBOL(efx_dl_filter_remove);
+
+void efx_dl_filter_redirect(struct efx_dl_device *efx_dev,
+			    int filter_id, int rxq_i)
+{
+	BUG_ON(filter_id < 0);
+	efx_filter_redirect_id(efx_dl_handle(efx_dev)->efx,
+			       filter_id & EFX_FILTER_ID_MASK, rxq_i);
+}
+EXPORT_SYMBOL(efx_dl_filter_redirect);
diff -r 9566a4a50a43 drivers/net/sfc/driverlink.h
--- a/drivers/net/sfc/driverlink.h
+++ b/drivers/net/sfc/driverlink.h
@@ -1,7 +1,7 @@
 /****************************************************************************
  * Driver for Solarflare Solarstorm network controllers and boards
  * Copyright 2005      Fen Systems Ltd.
- * Copyright 2006-2008 Solarflare Communications Inc.
+ * Copyright 2006-2010 Solarflare Communications Inc.
  *
  * This program is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 as published
@@ -11,56 +11,19 @@
 #ifndef EFX_DRIVERLINK_H
 #define EFX_DRIVERLINK_H
 
-/* Forward declarations */
-struct efx_dl_device;
 struct efx_nic;
 
-#ifdef CONFIG_SFC_DRIVERLINK
-
-#include "driverlink_api.h"
-
-/* Efx callback devices
- *
- * A list of the devices that own each callback. The partner to
- * struct efx_dl_callbacks.
- */
-struct efx_dl_cb_devices {
-	struct efx_dl_device *tx_packet;
-	struct efx_dl_device *rx_packet;
-	struct efx_dl_device *request_mtu;
-	struct efx_dl_device *mtu_changed;
-	struct efx_dl_device *event;
-};
-
-extern struct efx_dl_callbacks efx_default_callbacks;
-
-#define EFX_DL_CALLBACK(_port, _name, ...)				\
-	(_port)->dl_cb._name((_port)->dl_cb_dev._name, __VA_ARGS__)
-
-extern int efx_dl_register_nic(struct efx_nic *efx);
+extern void efx_dl_register_nic(struct efx_nic *efx);
 extern void efx_dl_unregister_nic(struct efx_nic *efx);
 
 /* Suspend and resume client drivers over a hardware reset */
 extern void efx_dl_reset_suspend(struct efx_nic *efx);
 extern void efx_dl_reset_resume(struct efx_nic *efx, int ok);
 
-#define EFX_DL_LOG EFX_LOG
+/* Send unrecognised event to client drivers */
+extern bool efx_dl_handle_event(struct efx_nic *efx, void *event);
 
-#else /* CONFIG_SFC_DRIVERLINK */
-
-enum efx_veto { EFX_ALLOW_PACKET = 0 };
-
-static inline int efx_nop_callback(struct efx_nic *efx) { return 0; }
-#define EFX_DL_CALLBACK(port, name, ...) efx_nop_callback(port)
-
-static inline int efx_dl_register_nic(struct efx_nic *efx) { return 0; }
-static inline void efx_dl_unregister_nic(struct efx_nic *efx) {}
-
-static inline void efx_dl_reset_suspend(struct efx_nic *efx) {}
-static inline void efx_dl_reset_resume(struct efx_nic *efx, int ok) {}
-
-#define EFX_DL_LOG(efx, fmt, args...) ((void)(efx))
-
-#endif /* CONFIG_SFC_DRIVERLINK */
+/* List of all registered Efx ports. Protected by the rtnl_lock */
+extern struct list_head efx_port_list;
 
 #endif /* EFX_DRIVERLINK_H */
diff -r 9566a4a50a43 drivers/net/sfc/driverlink_api.h
--- a/drivers/net/sfc/driverlink_api.h
+++ b/drivers/net/sfc/driverlink_api.h
@@ -1,7 +1,7 @@
 /****************************************************************************
  * Driver for Solarflare Solarstorm network controllers and boards
  * Copyright 2005-2006 Fen Systems Ltd.
- * Copyright 2005-2008 Solarflare Communications Inc.
+ * Copyright 2005-2010 Solarflare Communications Inc.
  *
  * This program is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 as published
@@ -12,6 +12,13 @@
 #define EFX_DRIVERLINK_API_H
 
 #include <linux/list.h>
+	#include <linux/version.h>
+	#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,20)
+		#define EFX_USE_FASTCALL yes
+		#include <linux/linkage.h>
+	#endif
+
+#include "filter.h"
 
 /* Forward declarations */
 struct pci_dev;
@@ -21,7 +28,7 @@ struct efx_dl_device;
 struct efx_dl_device_info;
 
 /* An extra safeguard in addition to symbol versioning */
-#define EFX_DRIVERLINK_API_VERSION 2
+#define EFX_DRIVERLINK_API_VERSION 5
 
 /**
  * struct efx_dl_driver - An Efx driverlink device driver
@@ -34,21 +41,25 @@ struct efx_dl_device_info;
  * @probe: Called when device added
  *	The client should use the @def_info linked list and @silicon_rev
  *	to determine if they wish to attach to this device.
- *	Context: process, driverlink semaphore held
+ *	Context: process, rtnl_lock or driverlink mutex held
  * @remove: Called when device removed
  *	The client must ensure the finish all operations with this
  *	device before returning from this method.
- *	Context: process, driverlink semaphore held
+ *	Context: process, rtnl_lock or driverlink mutex held
  * @reset_suspend: Called before device is reset
  *	Called immediately before a hardware reset. The client must stop all
  *	hardware processing before returning from this method. Callbacks will
  *	be inactive when this method is called.
- *	Context: process, driverlink semaphore held. rtnl_lock may be held
+ *	Context: process, rtnl_lock and/or driverlink mutex held
  * @reset_resume: Called after device is reset
  *	Called after a hardware reset. If @ok is true, the client should
  *	state and resume normal operations. If @ok is false, the client should
  *	abandon use of the hardware resources. remove() will still be called.
- *	Context: process, driverlink semaphore held. rtnl_lock may be held
+ *	Context: process, rtnl_lock and/or driverlink mutex held
+ * @handle_event: Called when an event on a single-function port may need to
+ *	be handled by a client. May be %NULL. Currently only the first
+ *	implementation in any driver registered for a device will be called.
+ *	Context: NAPI.
  */
 struct efx_dl_driver {
 	const char *name;
@@ -60,6 +71,7 @@ struct efx_dl_driver {
 	void (*remove) (struct efx_dl_device *efx_dev);
 	void (*reset_suspend) (struct efx_dl_device *efx_dev);
 	void (*reset_resume) (struct efx_dl_device *efx_dev, int ok);
+	void (*handle_event) (struct efx_dl_device *efx_dev, void *p_event);
 
 /* private: */
 	struct list_head node;
@@ -73,10 +85,14 @@ struct efx_dl_driver {
  * provided to each driverlink client in the probe() @dev_info member.
  *
  * @EFX_DL_FALCON_RESOURCES: Information type is &struct efx_dl_falcon_resources
+ * @EFX_DL_HASH_INSERTION: Information type is &struct efx_dl_hash_insertion
+ * @EFX_DL_SIENA_SRIOV: Information type is &struct efx_dl_siena_sriov
  */
 enum efx_dl_device_info_type {
 	/** Falcon resources available for export */
 	EFX_DL_FALCON_RESOURCES = 0,
+	EFX_DL_HASH_INSERTION = 1,
+	EFX_DL_SIENA_SRIOV = 2,
 };
 
 /**
@@ -103,10 +119,17 @@ struct efx_dl_device_info {
  *	Falcon supports traditional legacy interrupts and MSI/MSI-X
  *	interrupts. The choice is made at run time by the sfc driver, and
  *	notified to the clients by this enumeration
+ * @EFX_DL_FALCON_ONLOAD_UNSUPPORTED: OpenOnload unsupported on this port.
+ * @EFX_DL_FALCON_HAVE_RSS_CHANNEL_COUNT: %rs_channel_count member is valid.
+ * @EFX_DL_FALCON_HAVE_TIMER_QUANTUM_NS: %timer_quantum_ns member is valid.
  */
 enum efx_dl_falcon_resource_flags {
 	EFX_DL_FALCON_DUAL_FUNC = 0x1,
 	EFX_DL_FALCON_USE_MSI = 0x2,
+	EFX_DL_FALCON_ONLOAD_UNSUPPORTED = 0x4,
+	EFX_DL_FALCON_WRITE_COMBINING = 0x8,
+	EFX_DL_FALCON_HAVE_RSS_CHANNEL_COUNT = 0x10,
+	EFX_DL_FALCON_HAVE_TIMER_QUANTUM_NS = 0x20,
 };
 
 /**
@@ -132,6 +155,11 @@ enum efx_dl_falcon_resource_flags {
  * @txq_min: First available TX queue
  * @txq_lim: Last available TX queue + 1
  * @flags: Hardware variation flags
+ * @rss_channel_count: Number of receive channels used for RSS. This member is
+ *	only present if %EFX_DL_FALCON_HAVE_RSS_CHANNEL_COUNT is set.
+ * @timer_quantum_ns: Timer quantum (nominal period between timer ticks)
+ *	for wakeup timers, in nanoseconds. This member is only present if
+ * 	%EFX_DL_FALCON_HAVE_TIMER_QUANTUM_NS is set.
  */
 struct efx_dl_falcon_resources {
 	struct efx_dl_device_info hdr;
@@ -147,6 +175,57 @@ struct efx_dl_falcon_resources {
 	unsigned txq_min;
 	unsigned txq_lim;
 	enum efx_dl_falcon_resource_flags flags;
+	unsigned rss_channel_count;
+	unsigned timer_quantum_ns;
+};
+
+/**
+ * enum efx_dl_hash_type_flags - Hash insertion type flags
+ *
+ * @EFX_DL_HASH_TOEP_TCPIP4: Toeplitz hash of TCP/IPv4 4-tuple
+ * @EFX_DL_HASH_TOEP_IP4: Toeplitz hash of IPv4 addresses
+ * @EFX_DL_HASH_TOEP_TCPIP6: Toeplitz hash of TCP/IPv6 4-tuple
+ * @EFX_DL_HASH_TOEP_IP6: Toeplitz hash of IPv6 addresses
+ */
+enum efx_dl_hash_type_flags {
+	EFX_DL_HASH_TOEP_TCPIP4 = 0x1,
+	EFX_DL_HASH_TOEP_IP4 = 0x2,
+	EFX_DL_HASH_TOEP_TCPIP6 = 0x4,
+	EFX_DL_HASH_TOEP_IP6 = 0x8,
+};
+
+/**
+ * struct efx_dl_hash_insertion - Hash insertion behaviour
+ *
+ * @hdr: Resource linked list header
+ * @data_offset: Offset of packet data relative to start of buffer
+ * @hash_offset: Offset of hash relative to start of buffer
+ * @flags: Flags for hash type(s) enabled
+ */
+struct efx_dl_hash_insertion {
+	struct efx_dl_device_info hdr;
+	unsigned data_offset;
+	unsigned hash_offset;
+	enum efx_dl_hash_type_flags flags;
+};
+
+/**
+ * struct efx_dl_siena_sriov - Siena SRIOV information
+ *
+ * This structure is initialised before pci_enable_sriov() is called,
+ * which mail fail. Therefore the consumer should cope with the fact
+ * that there may be fewer than %vf_count VFs.
+ *
+ * @hdr: Resource linked list header
+ * @vi_base: The zeroth VI mapped into VFs
+ * @vi_scale: Log2 of the number of VIs per VF
+ * @vf_count: Number of VFs that have been enabled
+ */
+struct efx_dl_siena_sriov {
+	struct efx_dl_device_info hdr;
+	unsigned vi_base;
+	unsigned vi_scale;
+	unsigned vf_count;
 };
 
 /**
@@ -166,65 +245,6 @@ struct efx_dl_device {
 	struct efx_dl_driver *driver;
 };
 
-/**
- * enum efx_veto - Packet veto request flag.
- *
- * This is the return type for the rx_packet() and tx_packet() methods
- * in &struct efx_dl_callbacks.
- *
- * @EFX_ALLOW_PACKET: Packet may be transmitted/received
- * @EFX_VETO_PACKET: Packet must not be transmitted/received
- */
-enum efx_veto {
-	EFX_ALLOW_PACKET = 0,
-	EFX_VETO_PACKET = 1,
-};
-
-/**
- * struct efx_dl_callbacks - Efx callbacks
- *
- * This is a tighly controlled set of simple callbacks, that are attached
- * to the sfc driver via efx_dl_register_callbacks().  They export just enough
- * state to allow clients to make use of the available hardware resources.
- *
- * For efficiency, only one client can hook each callback. Since these
- * callbacks are called on packet transmit and reception paths, and the
- * sfc driver may have multiple tx and rx queues per port, clients should
- * avoid acquiring locks or allocating memory.
- *
- * @tx_packet: Called when packet is about to be transmitted
- *	Called for every packet about to be transmitted, providing means
- *	for the client to snoop traffic, and veto transmission by returning
- *	%EFX_VETO_PACKET (the sfc driver will subsequently free the skb).
- *	Context: tasklet, netif_tx_lock held
- * @rx_packet: Called when packet is received
- *	Called for every received packet (after LRO), allowing the client
- *	to snoop every received packet (on every rx queue), and veto
- *	reception by returning %EFX_VETO_PACKET.
- *	Context: tasklet
- * @request_mtu: Called to request MTU change.
- *	Called whenever the user requests the net_dev mtu to be changed.
- *	If the client returns an error, the mtu change is aborted. The sfc
- *	driver guarantees that no other callbacks are running.
- *	Context: process, rtnl_lock held.
- * @mtu_changed: Called when MTU has been changed.
- *	Called after the mtu has been successfully changed, always after
- *	a previous call to request_mtu(). The sfc driver guarantees that no
- *	other callbacks are running.
- *	Context: process, rtnl_lock held.
- * @event: Called when a hardware NIC event is not understood by the sfc driver.
- *	Context: tasklet.
- */
-struct efx_dl_callbacks {
-	enum efx_veto (*tx_packet) (struct efx_dl_device *efx_dev,
-				    struct sk_buff *skb);
-	enum efx_veto (*rx_packet) (struct efx_dl_device *efx_dev,
-				    const char *pkt_hdr, int pkt_len);
-	int (*request_mtu) (struct efx_dl_device *efx_dev, int new_mtu);
-	void (*mtu_changed) (struct efx_dl_device *efx_dev, int mtu);
-	void (*event) (struct efx_dl_device *efx_dev, void *p_event);
-};
-
 /* Include API version number in symbol used for efx_dl_register_driver */
 #define efx_dl_stringify_1(x, y) x ## y
 #define efx_dl_stringify_2(x, y) efx_dl_stringify_1(x, y)
@@ -232,27 +252,52 @@ struct efx_dl_callbacks {
 	efx_dl_stringify_2(efx_dl_register_driver_api_ver_,	\
 			   EFX_DRIVERLINK_API_VERSION)
 
-/* Exported driverlink api used to register and unregister the client driver
- * and any callbacks [only one per port allowed], and to allow a client driver
- * to request reset to recover from an error condition.
+/**
+ * efx_dl_register_driver() - Register a client driver
+ * @driver: Driver operations structure
  *
- * All of these functions acquire the driverlink semaphore, so must not be
- * called from an efx_dl_driver or efx_dl_callbacks member, and must be called
- * from process context.
+ * This acquires the rtnl_lock and therefore must be called from
+ * process context.
  */
 extern int efx_dl_register_driver(struct efx_dl_driver *driver);
 
+/**
+ * efx_dl_unregister_driver() - Unregister a client driver
+ * @driver: Driver operations structure
+ *
+ * This acquires the rtnl_lock and therefore must be called from
+ * process context.
+ */
 extern void efx_dl_unregister_driver(struct efx_dl_driver *driver);
 
-extern int efx_dl_register_callbacks(struct efx_dl_device *efx_dev,
-				     struct efx_dl_callbacks *callbacks);
+/**
+ * efx_dl_netdev_is_ours() - Check whether device is handled by sfc
+ * @net_dev: Net device to be checked
+ */
+extern bool efx_dl_netdev_is_ours(const struct net_device *net_dev);
 
-extern void efx_dl_unregister_callbacks(struct efx_dl_device *efx_dev,
-					struct efx_dl_callbacks *callbacks);
+/**
+ * efx_dl_dev_from_netdev() - Find Driverlink device structure for net device
+ * @net_dev: Net device to be checked
+ * @driver: Driver structure for the device to be found
+ *
+ * Caller must hold the rtnl_lock.
+ */
+extern struct efx_dl_device *
+efx_dl_dev_from_netdev(const struct net_device *net_dev,
+		       struct efx_dl_driver *driver);
 
 /* Schedule a reset without grabbing any locks */
 extern void efx_dl_schedule_reset(struct efx_dl_device *efx_dev);
 
+extern int efx_dl_filter_insert(struct efx_dl_device *efx_dev,
+				struct efx_filter_spec *spec,
+				bool replace);
+extern void efx_dl_filter_remove(struct efx_dl_device *efx_dev,
+				 int filter_id);
+extern void efx_dl_filter_redirect(struct efx_dl_device *efx_dev,
+				   int filter_id, int rxq_i);
+
 /**
  * efx_dl_for_each_device_info_matching - iterate an efx_dl_device_info list
  * @_dev_info: Pointer to first &struct efx_dl_device_info
diff -r 9566a4a50a43 drivers/net/sfc/efx.c
--- a/drivers/net/sfc/efx.c
+++ b/drivers/net/sfc/efx.c
@@ -1,7 +1,7 @@
 /****************************************************************************
  * Driver for Solarflare Solarstorm network controllers and boards
  * Copyright 2005-2006 Fen Systems Ltd.
- * Copyright 2005-2008 Solarflare Communications Inc.
+ * Copyright 2005-2011 Solarflare Communications Inc.
  *
  * This program is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 as published
@@ -20,22 +20,83 @@
 #include <linux/crc32.h>
 #include <linux/ethtool.h>
 #include <linux/topology.h>
+#include <linux/gfp.h>
 #include "net_driver.h"
-#include "ethtool.h"
-#include "tx.h"
-#include "rx.h"
+#include "driverlink.h"
+#include "debugfs.h"
 #include "efx.h"
-#include "mdio_10g.h"
-#include "falcon.h"
+#include "nic.h"
+#include "selftest.h"
+#include "efx_ioctl.h"
+
+#include "mcdi.h"
+#include "workarounds.h"
+
+/**************************************************************************
+ *
+ * Type name strings
+ *
+ **************************************************************************
+ */
+
+/* Loopback mode names (see LOOPBACK_MODE()) */
+const unsigned int efx_loopback_mode_max = LOOPBACK_MAX;
+const char *efx_loopback_mode_names[] = {
+	[LOOPBACK_NONE]		= "NONE",
+	[LOOPBACK_DATA]		= "DATAPATH",
+	[LOOPBACK_GMAC]		= "GMAC",
+	[LOOPBACK_XGMII]	= "XGMII",
+	[LOOPBACK_XGXS]		= "XGXS",
+	[LOOPBACK_XAUI]  	= "XAUI",
+	[LOOPBACK_GMII] 	= "GMII",
+	[LOOPBACK_SGMII] 	= "SGMII",
+	[LOOPBACK_XGBR]		= "XGBR",
+	[LOOPBACK_XFI]		= "XFI",
+	[LOOPBACK_XAUI_FAR]	= "XAUI_FAR",
+	[LOOPBACK_GMII_FAR]	= "GMII_FAR",
+	[LOOPBACK_SGMII_FAR]	= "SGMII_FAR",
+	[LOOPBACK_XFI_FAR]	= "XFI_FAR",
+	[LOOPBACK_GPHY]		= "GPHY",
+	[LOOPBACK_PHYXS]	= "PHYXS",
+	[LOOPBACK_PCS]	 	= "PCS",
+	[LOOPBACK_PMAPMD] 	= "PMA/PMD",
+	[LOOPBACK_XPORT]	= "XPORT",
+	[LOOPBACK_XGMII_WS]	= "XGMII_WS",
+	[LOOPBACK_XAUI_WS]  	= "XAUI_WS",
+	[LOOPBACK_XAUI_WS_FAR]  = "XAUI_WS_FAR",
+	[LOOPBACK_XAUI_WS_NEAR] = "XAUI_WS_NEAR",
+	[LOOPBACK_GMII_WS] 	= "GMII_WS",
+	[LOOPBACK_XFI_WS]	= "XFI_WS",
+	[LOOPBACK_XFI_WS_FAR]	= "XFI_WS_FAR",
+	[LOOPBACK_PHYXS_WS]  	= "PHYXS_WS",
+};
+
+/* Interrupt mode names (see INT_MODE())) */
+const unsigned int efx_interrupt_mode_max = EFX_INT_MODE_MAX;
+const char *efx_interrupt_mode_names[] = {
+	[EFX_INT_MODE_MSIX]   = "MSI-X",
+	[EFX_INT_MODE_MSI]    = "MSI",
+	[EFX_INT_MODE_LEGACY] = "legacy",
+};
+
+const unsigned int efx_reset_type_max = RESET_TYPE_MAX;
+const char *efx_reset_type_names[] = {
+	[RESET_TYPE_INVISIBLE]     = "INVISIBLE",
+	[RESET_TYPE_ALL]           = "ALL",
+	[RESET_TYPE_WORLD]         = "WORLD",
+	[RESET_TYPE_DISABLE]       = "DISABLE",
+	[RESET_TYPE_TX_WATCHDOG]   = "TX_WATCHDOG",
+	[RESET_TYPE_INT_ERROR]     = "INT_ERROR",
+	[RESET_TYPE_RX_RECOVERY]   = "RX_RECOVERY",
+	[RESET_TYPE_RX_DESC_FETCH] = "RX_DESC_FETCH",
+	[RESET_TYPE_TX_DESC_FETCH] = "TX_DESC_FETCH",
+	[RESET_TYPE_TX_SKIP]       = "TX_SKIP",
+	[RESET_TYPE_MC_FAILURE]    = "MC_FAILURE",
+};
 
 #define EFX_MAX_MTU (9 * 1024)
 
-/* RX slow fill workqueue. If memory allocation fails in the fast path,
- * a work item is pushed onto this work queue to retry the allocation later,
- * to avoid the NIC being starved of RX buffers. Since this is a per cpu
- * workqueue, there is nothing to be gained in making it per NIC
- */
-static struct workqueue_struct *refill_workqueue;
+#define EFX_DEFAULT_WATCHDOG (5 * HZ)
 
 /* Reset workqueue. If any NIC has a hardware failure then a reset will be
  * queued onto this work queue. This is not a per-nic work queue, because
@@ -43,6 +104,13 @@ static struct workqueue_struct *refill_w
  */
 static struct workqueue_struct *reset_workqueue;
 
+static unsigned debug = (NETIF_MSG_DRV | NETIF_MSG_PROBE |
+			 NETIF_MSG_LINK | NETIF_MSG_IFDOWN |
+			 NETIF_MSG_IFUP | NETIF_MSG_RX_ERR |
+			 NETIF_MSG_TX_ERR | NETIF_MSG_HW);
+module_param(debug, uint, 0);
+MODULE_PARM_DESC(debug, "Bitmapped debugging message enable value");
+
 /**************************************************************************
  *
  * Configurable values
@@ -50,6 +118,16 @@ static struct workqueue_struct *reset_wo
  *************************************************************************/
 
 /*
+ * Enable large receive offload (LRO) aka soft segment reassembly (SSR)
+ *
+ * This sets the default for new devices.  It can be controlled later
+ * using ethtool.
+ */
+static int lro = true;
+module_param(lro, int, 0444);
+MODULE_PARM_DESC(lro, "Large receive offload acceleration");
+
+/*
  * Use separate channels for TX and RX events
  *
  * Set this to 1 to use separate channels for TX and RX. It allows us
@@ -58,7 +136,7 @@ static struct workqueue_struct *reset_wo
  * This is only used in MSI-X interrupt mode
  */
 static unsigned int separate_tx_channels;
-module_param(separate_tx_channels, uint, 0644);
+module_param(separate_tx_channels, uint, 0444);
 MODULE_PARM_DESC(separate_tx_channels,
 		 "Use separate channels for TX and RX");
 
@@ -68,10 +146,11 @@ MODULE_PARM_DESC(separate_tx_channels,
 static int napi_weight = 64;
 
 /* This is the time (in jiffies) between invocations of the hardware
- * monitor, which checks for known hardware bugs and resets the
- * hardware and driver as necessary.
+ * monitor.  On Falcon-based NICs, this will:
+ * - Check the on-board hardware monitor;
+ * - Poll the link state and reconfigure the hardware as necessary.
  */
-unsigned int efx_monitor_interval = 1 * HZ;
+static unsigned int efx_monitor_interval = 1 * HZ;
 
 /* This controls whether or not the driver will initialise devices
  * with invalid MAC addresses stored in the EEPROM or flash.  If true,
@@ -108,44 +187,82 @@ static unsigned int tx_irq_mod_usec = 15
  */
 static unsigned int interrupt_mode;
 
-/* This is the requested number of CPUs to use for Receive-Side Scaling (RSS),
- * i.e. the number of CPUs among which we may distribute simultaneous
- * interrupt handling.
+/* This is the requested number of CPUs to use for Receive-Side Scaling
+ * (RSS), i.e. the number of CPUs among which we may distribute
+ * simultaneous interrupt handling.  Or alternatively it may be set to
+ * "packages", "cores" or "hyperthreads" to get one receive channel per
+ * package, core or hyperthread.
  *
- * Cards without MSI-X will only target one CPU via legacy or MSI interrupt.
- * The default (0) means to assign an interrupt to each package (level II cache)
+ * Systems without MSI-X will only target one CPU via legacy or MSI
+ * interrupt.  The default is "packages".
  */
-static unsigned int rss_cpus;
-module_param(rss_cpus, uint, 0444);
-MODULE_PARM_DESC(rss_cpus, "Number of CPUs to use for Receive-Side Scaling");
+static char *rss_cpus;
+module_param(rss_cpus, charp, 0444);
+MODULE_PARM_DESC(rss_cpus, "Number of CPUs to use for Receive-Side Scaling, "
+		 "or 'packages', 'cores' or 'hyperthreads'");
+
+enum rss_mode {
+	EFX_RSS_PACKAGES,
+	EFX_RSS_CORES,
+	EFX_RSS_HYPERTHREADS,
+	EFX_RSS_CUSTOM,
+};
 
 static int phy_flash_cfg;
 module_param(phy_flash_cfg, int, 0644);
 MODULE_PARM_DESC(phy_flash_cfg, "Set PHYs into reflash mode initially");
 
-static unsigned irq_adapt_low_thresh = 10000;
+static unsigned irq_adapt_enable = 1;
+module_param(irq_adapt_enable, uint, 0444);
+MODULE_PARM_DESC(irq_adapt_enable,
+		 "Enable adaptive interrupt moderation");
+
+static unsigned irq_adapt_low_thresh = 8000;
 module_param(irq_adapt_low_thresh, uint, 0644);
 MODULE_PARM_DESC(irq_adapt_low_thresh,
 		 "Threshold score for reducing IRQ moderation");
 
-static unsigned irq_adapt_high_thresh = 20000;
+static unsigned irq_adapt_high_thresh = 16000;
 module_param(irq_adapt_high_thresh, uint, 0644);
 MODULE_PARM_DESC(irq_adapt_high_thresh,
 		 "Threshold score for increasing IRQ moderation");
 
+static unsigned irq_adapt_irqs = 1000;
+module_param(irq_adapt_irqs, uint, 0644);
+MODULE_PARM_DESC(irq_adapt_irqs,
+		 "Number of IRQs per IRQ moderation adaptation");
+
+static unsigned int rx_ring = EFX_DEFAULT_DMAQ_SIZE;
+module_param(rx_ring, uint, 0644);
+MODULE_PARM_DESC(rx_ring,
+		 "Maximum number of descriptors in a receive ring");
+
+static unsigned int tx_ring = EFX_DEFAULT_DMAQ_SIZE;
+module_param(tx_ring, uint, 0644);
+MODULE_PARM_DESC(tx_ring,
+		 "Maximum number of descriptors in a transmit ring");
+
 /**************************************************************************
  *
  * Utility functions and prototypes
  *
  *************************************************************************/
+
+static void efx_start_interrupts(struct efx_nic *efx, bool may_keep_eventq);
+static void efx_stop_interrupts(struct efx_nic *efx, bool may_keep_eventq);
+static int efx_init_napi_channel(struct efx_channel *channel);
+static void efx_fini_napi_channel(struct efx_channel *channel);
 static void efx_remove_channel(struct efx_channel *channel);
+static void efx_remove_channels(struct efx_nic *efx);
+static const struct efx_channel_type efx_default_channel_type;
 static void efx_remove_port(struct efx_nic *efx);
 static void efx_fini_napi(struct efx_nic *efx);
-static void efx_fini_channels(struct efx_nic *efx);
+static void efx_fini_struct(struct efx_nic *efx);
 
 #define EFX_ASSERT_RESET_SERIALISED(efx)		\
 	do {						\
-		if (efx->state == STATE_RUNNING)	\
+		if ((efx->state == STATE_RUNNING) ||	\
+		    (efx->state == STATE_DISABLED))	\
 			ASSERT_RTNL();			\
 	} while (0)
 
@@ -162,31 +279,31 @@ static void efx_fini_channels(struct efx
  * never be concurrently called more than once on the same channel,
  * though different channels may be being processed concurrently.
  */
-static int efx_process_channel(struct efx_channel *channel, int rx_quota)
+static int efx_process_channel(struct efx_channel *channel, int budget)
 {
-	struct efx_nic *efx = channel->efx;
-	int rx_packets;
-
-	if (unlikely(efx->reset_pending != RESET_TYPE_NONE ||
-		     !channel->enabled))
+	int spent;
+
+	if (unlikely(!channel->enabled))
 		return 0;
 
-	rx_packets = falcon_process_eventq(channel, rx_quota);
-	if (rx_packets == 0)
-		return 0;
-
-	/* Deliver last RX packet. */
-	if (channel->rx_pkt) {
-		__efx_rx_packet(channel, channel->rx_pkt,
-				channel->rx_pkt_csummed);
-		channel->rx_pkt = NULL;
+	spent = efx_nic_process_eventq(channel, budget);
+
+	if (spent && efx_channel_has_rx_queue(channel)) {
+		struct efx_rx_queue *rx_queue =
+			efx_channel_get_rx_queue(channel);
+
+		/* Deliver last RX packet. */
+		if (channel->rx_pkt) {
+			__efx_rx_packet(channel, channel->rx_pkt);
+			channel->rx_pkt = NULL;
+		}
+		if (rx_queue->enabled) {
+			efx_rx_strategy(channel);
+			efx_fast_push_rx_descriptors(rx_queue);
+		}
 	}
 
-	efx_rx_strategy(channel);
-
-	efx_fast_push_rx_descriptors(&efx->rx_queue[channel->channel]);
-
-	return rx_packets;
+	return spent;
 }
 
 /* Mark channel as finished processing
@@ -203,7 +320,7 @@ static inline void efx_channel_processed
 	channel->work_pending = false;
 	smp_wmb();
 
-	falcon_eventq_read_ack(channel);
+	efx_nic_eventq_read_ack(channel);
 }
 
 /* NAPI poll handler
@@ -215,43 +332,39 @@ static int efx_poll(struct napi_struct *
 {
 	struct efx_channel *channel =
 		container_of(napi, struct efx_channel, napi_str);
-	int rx_packets;
-
-	EFX_TRACE(channel->efx, "channel %d NAPI poll executing on CPU %d\n",
-		  channel->channel, raw_smp_processor_id());
-
-	rx_packets = efx_process_channel(channel, budget);
-
-	if (rx_packets < budget) {
-		struct efx_nic *efx = channel->efx;
-
-		if (channel->used_flags & EFX_USED_BY_RX &&
+	struct efx_nic *efx = channel->efx;
+	int spent;
+
+	netif_vdbg(efx, intr, efx->net_dev,
+		   "channel %d NAPI poll executing on CPU %d\n",
+		   channel->channel, raw_smp_processor_id());
+
+	spent = efx_process_channel(channel, budget);
+
+	if (spent < budget) {
+		if (efx_channel_has_rx_queue(channel) &&
 		    efx->irq_rx_adaptive &&
-		    unlikely(++channel->irq_count == 1000)) {
-			unsigned old_irq_moderation = channel->irq_moderation;
-
+		    unlikely(++channel->irq_count == irq_adapt_irqs)) {
 			if (unlikely(channel->irq_mod_score <
 				     irq_adapt_low_thresh)) {
-				channel->irq_moderation =
-					max_t(int,
-					      channel->irq_moderation -
-					      FALCON_IRQ_MOD_RESOLUTION,
-					      FALCON_IRQ_MOD_RESOLUTION);
+				if (channel->irq_moderation > 1) {
+					channel->irq_moderation -= 1;
+					efx->type->push_irq_moderation(channel);
+				}
 			} else if (unlikely(channel->irq_mod_score >
 					    irq_adapt_high_thresh)) {
-				channel->irq_moderation =
-					min(channel->irq_moderation +
-					    FALCON_IRQ_MOD_RESOLUTION,
-					    efx->irq_rx_moderation);
+				if (channel->irq_moderation <
+				    efx->irq_rx_moderation) {
+					channel->irq_moderation += 1;
+					efx->type->push_irq_moderation(channel);
+				}
 			}
-
-			if (channel->irq_moderation != old_irq_moderation)
-				falcon_set_int_moderation(channel);
-
 			channel->irq_count = 0;
 			channel->irq_mod_score = 0;
 		}
 
+		efx_filter_rfs_expire(channel);
+
 		/* There is no race here; although napi_disable() will
 		 * only wait for napi_complete(), this isn't a problem
 		 * since efx_channel_processed() will have no effect if
@@ -261,7 +374,7 @@ static int efx_poll(struct napi_struct *
 		efx_channel_processed(channel);
 	}
 
-	return rx_packets;
+	return spent;
 }
 
 /* Process the eventq of the specified channel immediately on this CPU
@@ -270,19 +383,23 @@ static int efx_poll(struct napi_struct *
  * processing to finish, then directly poll (and ack ) the eventq.
  * Finally reenable NAPI and interrupts.
  *
- * Since we are touching interrupts the caller should hold the suspend lock
+ * This is for use only during a loopback self-test.  It must not
+ * deliver any packets up the stack as this can result in deadlock.
  */
 void efx_process_channel_now(struct efx_channel *channel)
 {
 	struct efx_nic *efx = channel->efx;
 
-	BUG_ON(!channel->used_flags);
+	BUG_ON(channel->channel >= efx->n_channels);
 	BUG_ON(!channel->enabled);
+	BUG_ON(!efx->loopback_selftest);
 
 	/* Disable interrupts and wait for ISRs to complete */
-	falcon_disable_interrupts(efx);
-	if (efx->legacy_irq)
+	efx_nic_disable_interrupts(efx);
+	if (efx->legacy_irq) {
 		synchronize_irq(efx->legacy_irq);
+		efx->legacy_irq_enabled = false;
+	}
 	if (channel->irq)
 		synchronize_irq(channel->irq);
 
@@ -290,14 +407,16 @@ void efx_process_channel_now(struct efx_
 	napi_disable(&channel->napi_str);
 
 	/* Poll the channel */
-	efx_process_channel(channel, efx->type->evq_size);
+	efx_process_channel(channel, channel->eventq_mask + 1);
 
 	/* Ack the eventq. This may cause an interrupt to be generated
 	 * when they are reenabled */
 	efx_channel_processed(channel);
 
 	napi_enable(&channel->napi_str);
-	falcon_enable_interrupts(efx);
+	if (efx->legacy_irq)
+		efx->legacy_irq_enabled = true;
+	efx_nic_enable_interrupts(efx);
 }
 
 /* Create event queue
@@ -307,33 +426,76 @@ void efx_process_channel_now(struct efx_
  */
 static int efx_probe_eventq(struct efx_channel *channel)
 {
-	EFX_LOG(channel->efx, "chan %d create event queue\n", channel->channel);
-
-	return falcon_probe_eventq(channel);
+	struct efx_nic *efx = channel->efx;
+	unsigned long entries;
+
+	netif_dbg(efx, probe, channel->efx->net_dev,
+		  "chan %d create event queue\n", channel->channel);
+
+	/* Build an event queue with room for one event per tx and rx buffer,
+	 * plus some extra for link state events and MCDI completions. */
+	entries = roundup_pow_of_two(efx->rxq_entries + efx->txq_entries + 128);
+	EFX_BUG_ON_PARANOID(entries > EFX_MAX_EVQ_SIZE);
+	channel->eventq_mask = max(entries, EFX_MIN_EVQ_SIZE) - 1;
+
+	return efx_nic_probe_eventq(channel);
 }
 
 /* Prepare channel's event queue */
 static void efx_init_eventq(struct efx_channel *channel)
 {
-	EFX_LOG(channel->efx, "chan %d init event queue\n", channel->channel);
+	netif_dbg(channel->efx, drv, channel->efx->net_dev,
+		  "chan %d init event queue\n", channel->channel);
 
 	channel->eventq_read_ptr = 0;
 
-	falcon_init_eventq(channel);
+	efx_nic_init_eventq(channel);
+}
+
+/* Enable event queue processing and NAPI */
+void efx_start_eventq(struct efx_channel *channel)
+{
+	netif_dbg(channel->efx, ifup, channel->efx->net_dev,
+		  "chan %d start event queue\n", channel->channel);
+
+	/* The interrupt handler for this channel may set work_pending
+	 * as soon as we enable it.  Make sure it's cleared before
+	 * then.  Similarly, make sure it sees the enabled flag set. */
+	channel->work_pending = false;
+	channel->enabled = true;
+	smp_wmb();
+
+	napi_enable(&channel->napi_str);
+	efx_nic_eventq_read_ack(channel);
+}
+
+/* Disable event queue processing and NAPI */
+void efx_stop_eventq(struct efx_channel *channel)
+{
+	if (!channel->enabled)
+		return;
+
+	netif_dbg(channel->efx, drv, channel->efx->net_dev,
+			"chan %d stop event queue\n", channel->channel);
+
+	napi_disable(&channel->napi_str);
+	channel->enabled = false;
 }
 
 static void efx_fini_eventq(struct efx_channel *channel)
 {
-	EFX_LOG(channel->efx, "chan %d fini event queue\n", channel->channel);
-
-	falcon_fini_eventq(channel);
+	netif_dbg(channel->efx, drv, channel->efx->net_dev,
+		  "chan %d fini event queue\n", channel->channel);
+
+	efx_nic_fini_eventq(channel);
 }
 
 static void efx_remove_eventq(struct efx_channel *channel)
 {
-	EFX_LOG(channel->efx, "chan %d remove event queue\n", channel->channel);
-
-	falcon_remove_eventq(channel);
+	netif_dbg(channel->efx, drv, channel->efx->net_dev,
+		  "chan %d remove event queue\n", channel->channel);
+
+	efx_nic_remove_eventq(channel);
 }
 
 /**************************************************************************
@@ -342,71 +504,175 @@ static void efx_remove_eventq(struct efx
  *
  *************************************************************************/
 
+/* Allocate and initialise a channel structure. */
+static struct efx_channel *
+efx_alloc_channel(struct efx_nic *efx, int i, struct efx_channel *old_channel)
+{
+	struct efx_channel *channel;
+	struct efx_rx_queue *rx_queue;
+	struct efx_tx_queue *tx_queue;
+	int j;
+
+	channel = kzalloc(sizeof(*channel), GFP_KERNEL);
+	if (!channel)
+		return NULL;
+
+	channel->efx = efx;
+	channel->channel = i;
+	channel->type = &efx_default_channel_type;
+
+	for (j = 0; j < EFX_TXQ_TYPES; j++) {
+		tx_queue = &channel->tx_queue[j];
+		tx_queue->efx = efx;
+		tx_queue->queue = i * EFX_TXQ_TYPES + j;
+		tx_queue->channel = channel;
+	}
+
+	rx_queue = &channel->rx_queue;
+	rx_queue->efx = efx;
+	setup_timer(&rx_queue->slow_fill, efx_rx_slow_fill,
+		    (unsigned long)rx_queue);
+
+	return channel;
+}
+
+/* Allocate and initialise a channel structure, copying parameters
+ * (but not resources) from an old channel structure. */
+static struct efx_channel *
+efx_copy_channel(const struct efx_channel *old_channel)
+{
+	struct efx_channel *channel;
+	struct efx_rx_queue *rx_queue;
+	struct efx_tx_queue *tx_queue;
+	int j;
+
+	channel = kmalloc(sizeof(*channel), GFP_KERNEL);
+	if (!channel)
+		return NULL;
+
+	*channel = *old_channel;
+
+	channel->napi_dev = NULL;
+	memset(&channel->eventq, 0, sizeof(channel->eventq));
+
+	for (j = 0; j < EFX_TXQ_TYPES; j++) {
+		tx_queue = &channel->tx_queue[j];
+		if (tx_queue->channel)
+			tx_queue->channel = channel;
+		tx_queue->buffer = NULL;
+		memset(&tx_queue->txd, 0, sizeof(tx_queue->txd));
+	}
+
+	rx_queue = &channel->rx_queue;
+	rx_queue->buffer = NULL;
+	memset(&rx_queue->rxd, 0, sizeof(rx_queue->rxd));
+	setup_timer(&rx_queue->slow_fill, efx_rx_slow_fill,
+		    (unsigned long)rx_queue);
+
+	return channel;
+}
+
 static int efx_probe_channel(struct efx_channel *channel)
 {
 	struct efx_tx_queue *tx_queue;
 	struct efx_rx_queue *rx_queue;
 	int rc;
 
-	EFX_LOG(channel->efx, "creating channel %d\n", channel->channel);
+	netif_dbg(channel->efx, probe, channel->efx->net_dev,
+		  "creating channel %d\n", channel->channel);
+
+	rc = channel->type->pre_probe(channel);
+	if (rc)
+		goto fail;
 
 	rc = efx_probe_eventq(channel);
 	if (rc)
-		goto fail1;
+		goto fail;
 
 	efx_for_each_channel_tx_queue(tx_queue, channel) {
 		rc = efx_probe_tx_queue(tx_queue);
 		if (rc)
-			goto fail2;
+			goto fail;
 	}
 
 	efx_for_each_channel_rx_queue(rx_queue, channel) {
 		rc = efx_probe_rx_queue(rx_queue);
 		if (rc)
-			goto fail3;
+			goto fail;
 	}
 
-	channel->n_rx_frm_trunc = 0;
-
 	return 0;
 
- fail3:
-	efx_for_each_channel_rx_queue(rx_queue, channel)
-		efx_remove_rx_queue(rx_queue);
- fail2:
-	efx_for_each_channel_tx_queue(tx_queue, channel)
-		efx_remove_tx_queue(tx_queue);
- fail1:
+fail:
+	efx_remove_channel(channel);
 	return rc;
 }
 
+static void
+efx_get_channel_name(struct efx_channel *channel, char *buf, size_t len)
+{
+	struct efx_nic *efx = channel->efx;
+	const char *type;
+	int number;
+
+	number = channel->channel;
+	if (efx->tx_channel_offset == 0) {
+		type = "";
+	} else if (channel->channel < efx->tx_channel_offset) {
+		type = "-rx";
+	} else {
+		type = "-tx";
+		number -= efx->tx_channel_offset;
+	}
+	snprintf(buf, len, "%s%s-%d", efx->name, type, number);
+}
 
 static void efx_set_channel_names(struct efx_nic *efx)
 {
 	struct efx_channel *channel;
-	const char *type = "";
-	int number;
-
-	efx_for_each_channel(channel, efx) {
-		number = channel->channel;
-		if (efx->n_channels > efx->n_rx_queues) {
-			if (channel->channel < efx->n_rx_queues) {
-				type = "-rx";
-			} else {
-				type = "-tx";
-				number -= efx->n_rx_queues;
-			}
+
+	efx_for_each_channel(channel, efx)
+		channel->type->get_name(channel,
+					efx->channel_name[channel->channel],
+					sizeof(efx->channel_name[0]));
+}
+
+static int efx_probe_channels(struct efx_nic *efx)
+{
+	struct efx_channel *channel;
+	int rc;
+
+	/* Restart buffer table allocation */
+	efx->next_buffer_table = 0;
+
+	/* Probe channels in reverse, so that any 'extra' channels
+	 * use the start of the buffer table. This allows the traffic
+	 * channels to be resized without moving them or wasting the
+	 * entries before them.
+	 */
+	efx_for_each_channel_rev(channel, efx) {
+		rc = efx_probe_channel(channel);
+		if (rc) {
+			netif_err(efx, probe, efx->net_dev,
+				  "failed to create channel %d\n",
+				  channel->channel);
+			goto fail;
 		}
-		snprintf(channel->name, sizeof(channel->name),
-			 "%s%s-%d", efx->name, type, number);
 	}
+	efx_set_channel_names(efx);
+
+	return 0;
+
+fail:
+	efx_remove_channels(efx);
+	return rc;
 }
 
 /* Channels are shutdown and reinitialised whilst the NIC is running
  * to propagate configuration changes (mtu, checksum offload), or
  * to clear hardware error conditions
  */
-static void efx_init_channels(struct efx_nic *efx)
+static void efx_start_datapath(struct efx_nic *efx)
 {
 	struct efx_tx_queue *tx_queue;
 	struct efx_rx_queue *rx_queue;
@@ -418,78 +684,33 @@ static void efx_init_channels(struct efx
 	 */
 	efx->rx_buffer_len = (max(EFX_PAGE_IP_ALIGN, NET_IP_ALIGN) +
 			      EFX_MAX_FRAME_LEN(efx->net_dev->mtu) +
+			      efx->type->rx_buffer_hash_size +
 			      efx->type->rx_buffer_padding);
-	efx->rx_buffer_order = get_order(efx->rx_buffer_len);
+	efx->rx_buffer_order = get_order(efx->rx_buffer_len +
+					 sizeof(struct efx_rx_page_state));
 
 	/* Initialise the channels */
 	efx_for_each_channel(channel, efx) {
-		EFX_LOG(channel->efx, "init chan %d\n", channel->channel);
-
-		efx_init_eventq(channel);
-
 		efx_for_each_channel_tx_queue(tx_queue, channel)
 			efx_init_tx_queue(tx_queue);
 
 		/* The rx buffer allocation strategy is MTU dependent */
 		efx_rx_strategy(channel);
 
-		efx_for_each_channel_rx_queue(rx_queue, channel)
+		efx_for_each_channel_rx_queue(rx_queue, channel) {
 			efx_init_rx_queue(rx_queue);
+			efx_nic_generate_fill_event(rx_queue);
+		}
 
 		WARN_ON(channel->rx_pkt != NULL);
 		efx_rx_strategy(channel);
 	}
+
+	if (netif_device_present(efx->net_dev))
+		netif_tx_wake_all_queues(efx->net_dev);
 }
 
-/* This enables event queue processing and packet transmission.
- *
- * Note that this function is not allowed to fail, since that would
- * introduce too much complexity into the suspend/resume path.
- */
-static void efx_start_channel(struct efx_channel *channel)
-{
-	struct efx_rx_queue *rx_queue;
-
-	EFX_LOG(channel->efx, "starting chan %d\n", channel->channel);
-
-	/* The interrupt handler for this channel may set work_pending
-	 * as soon as we enable it.  Make sure it's cleared before
-	 * then.  Similarly, make sure it sees the enabled flag set. */
-	channel->work_pending = false;
-	channel->enabled = true;
-	smp_wmb();
-
-	napi_enable(&channel->napi_str);
-
-	/* Load up RX descriptors */
-	efx_for_each_channel_rx_queue(rx_queue, channel)
-		efx_fast_push_rx_descriptors(rx_queue);
-}
-
-/* This disables event queue processing and packet transmission.
- * This function does not guarantee that all queue processing
- * (e.g. RX refill) is complete.
- */
-static void efx_stop_channel(struct efx_channel *channel)
-{
-	struct efx_rx_queue *rx_queue;
-
-	if (!channel->enabled)
-		return;
-
-	EFX_LOG(channel->efx, "stop chan %d\n", channel->channel);
-
-	channel->enabled = false;
-	napi_disable(&channel->napi_str);
-
-	/* Ensure that any worker threads have exited or will be no-ops */
-	efx_for_each_channel_rx_queue(rx_queue, channel) {
-		spin_lock_bh(&rx_queue->add_lock);
-		spin_unlock_bh(&rx_queue->add_lock);
-	}
-}
-
-static void efx_fini_channels(struct efx_nic *efx)
+static void efx_stop_datapath(struct efx_nic *efx)
 {
 	struct efx_channel *channel;
 	struct efx_tx_queue *tx_queue;
@@ -499,20 +720,38 @@ static void efx_fini_channels(struct efx
 	EFX_ASSERT_RESET_SERIALISED(efx);
 	BUG_ON(efx->port_enabled);
 
-	rc = falcon_flush_queues(efx);
-	if (rc)
-		EFX_ERR(efx, "failed to flush queues\n");
-	else
-		EFX_LOG(efx, "successfully flushed all queues\n");
+	rc = efx_nic_flush_queues(efx);
+	if (rc && EFX_WORKAROUND_7803(efx)) {
+		/* Schedule a reset to recover from the flush failure. The
+		 * descriptor caches reference memory we're about to free,
+		 * but falcon_reconfigure_mac_wrapper() won't reconnect
+		 * the MACs because of the pending reset. */
+		netif_err(efx, drv, efx->net_dev,
+			  "Resetting to recover from flush failure\n");
+		efx_schedule_reset(efx, RESET_TYPE_ALL);
+	} else if (rc) {
+		netif_err(efx, drv, efx->net_dev, "failed to flush queues\n");
+	} else {
+		netif_dbg(efx, drv, efx->net_dev,
+			  "successfully flushed all queues\n");
+	}
 
 	efx_for_each_channel(channel, efx) {
-		EFX_LOG(channel->efx, "shut down chan %d\n", channel->channel);
+		/* RX packet processing is pipelined, so wait for the
+		 * NAPI handler to complete.  At least event queue 0
+		 * might be kept active by non-data events, so don't
+		 * use napi_synchronize() but actually disable NAPI
+		 * temporarily.
+		 */
+		if (efx_channel_has_rx_queue(channel)) {
+			efx_stop_eventq(channel);
+			efx_start_eventq(channel);
+		}
 
 		efx_for_each_channel_rx_queue(rx_queue, channel)
 			efx_fini_rx_queue(rx_queue);
 		efx_for_each_channel_tx_queue(tx_queue, channel)
 			efx_fini_tx_queue(tx_queue);
-		efx_fini_eventq(channel);
 	}
 }
 
@@ -521,20 +760,144 @@ static void efx_remove_channel(struct ef
 	struct efx_tx_queue *tx_queue;
 	struct efx_rx_queue *rx_queue;
 
-	EFX_LOG(channel->efx, "destroy chan %d\n", channel->channel);
+	netif_dbg(channel->efx, drv, channel->efx->net_dev,
+		  "destroy chan %d\n", channel->channel);
 
 	efx_for_each_channel_rx_queue(rx_queue, channel)
 		efx_remove_rx_queue(rx_queue);
 	efx_for_each_channel_tx_queue(tx_queue, channel)
 		efx_remove_tx_queue(tx_queue);
 	efx_remove_eventq(channel);
-
-	channel->used_flags = 0;
+	channel->type->post_remove(channel);
 }
 
-void efx_schedule_slow_fill(struct efx_rx_queue *rx_queue, int delay)
+static void efx_remove_channels(struct efx_nic *efx)
 {
-	queue_delayed_work(refill_workqueue, &rx_queue->work, delay);
+	struct efx_channel *channel;
+
+	efx_for_each_channel(channel, efx)
+		efx_remove_channel(channel);
+}
+
+int
+efx_realloc_channels(struct efx_nic *efx, u32 rxq_entries, u32 txq_entries)
+{
+	struct efx_channel *other_channel[EFX_MAX_CHANNELS], *channel;
+	u32 old_rxq_entries, old_txq_entries;
+	unsigned i, next_buffer_table = 0;
+	int rc = 0;
+
+	/* Not all channels should be reallocated. We must avoid
+	 * reallocating their buffer table entries.
+	 */
+	efx_for_each_channel(channel, efx) {
+		struct efx_rx_queue *rx_queue;
+		struct efx_tx_queue *tx_queue;
+
+		if (channel->type->copy)
+			continue;
+		next_buffer_table = max(next_buffer_table,
+					channel->eventq.index +
+					channel->eventq.entries);
+		efx_for_each_channel_rx_queue(rx_queue, channel)
+			next_buffer_table = max(next_buffer_table,
+						rx_queue->rxd.index +
+						rx_queue->rxd.entries);
+		efx_for_each_channel_tx_queue(tx_queue, channel)
+			next_buffer_table = max(next_buffer_table,
+						tx_queue->txd.index +
+						tx_queue->txd.entries);
+	}
+
+	efx_stop_all(efx);
+	efx_stop_interrupts(efx, true);
+
+	/* Clone channels (where possible) */
+	memset(other_channel, 0, sizeof(other_channel));
+	for (i = 0; i < efx->n_channels; i++) {
+		channel = efx->channel[i];
+		if (channel->type->copy)
+			channel = channel->type->copy(channel);
+		if (!channel) {
+			rc = -ENOMEM;
+			goto out;
+		}
+		other_channel[i] = channel;
+	}
+
+	/* Swap entry counts and channel pointers */
+	old_rxq_entries = efx->rxq_entries;
+	old_txq_entries = efx->txq_entries;
+	efx->rxq_entries = rxq_entries;
+	efx->txq_entries = txq_entries;
+	for (i = 0; i < efx->n_channels; i++) {
+		channel = efx->channel[i];
+		efx->channel[i] = other_channel[i];
+		other_channel[i] = channel;
+	}
+
+	/* Restart buffer table allocation */
+	efx->next_buffer_table = next_buffer_table;
+
+	for (i = 0; i < efx->n_channels; i++) {
+		channel = efx->channel[i];
+		if (!channel->type->copy)
+			continue;
+		rc = efx_probe_channel(channel);
+		if (rc)
+			goto rollback;
+		rc = efx_init_napi_channel(efx->channel[i]);
+		if (rc)
+			goto rollback;
+	}
+
+out:
+	/* Destroy unused channel structures */
+	for (i = 0; i < efx->n_channels; i++) {
+		channel = other_channel[i];
+		if (channel && channel->type->copy) {
+			efx_fini_napi_channel(channel);
+			efx_remove_channel(channel);
+			kfree(channel);
+		}
+	}
+
+	efx_start_interrupts(efx, true);
+	efx_start_all(efx);
+	return rc;
+
+rollback:
+	/* Swap back */
+	efx->rxq_entries = old_rxq_entries;
+	efx->txq_entries = old_txq_entries;
+	for (i = 0; i < efx->n_channels; i++) {
+		channel = efx->channel[i];
+		efx->channel[i] = other_channel[i];
+		other_channel[i] = channel;
+	}
+	goto out;
+}
+
+void efx_schedule_slow_fill(struct efx_rx_queue *rx_queue)
+{
+	mod_timer(&rx_queue->slow_fill, jiffies + msecs_to_jiffies(100));
+}
+
+static const struct efx_channel_type efx_default_channel_type = {
+	.pre_probe		= efx_channel_dummy_op_int,
+	.post_remove		= efx_channel_dummy_op_void,
+	.get_name		= efx_get_channel_name,
+	.copy			= efx_copy_channel,
+	.keep_eventq		= false,
+};
+
+int efx_channel_dummy_op_int(struct efx_channel *channel)
+{
+	return 0;
+}
+
+void efx_channel_dummy_op_void(struct efx_channel *channel)
+{
 }
 
 /**************************************************************************
@@ -547,8 +910,10 @@ void efx_schedule_slow_fill(struct efx_r
  * netif_carrier_on/off) of the link status, and also maintains the
  * link status's stop on the port's TX queue.
  */
-static void efx_link_status_changed(struct efx_nic *efx)
+void efx_link_status_changed(struct efx_nic *efx)
 {
+	struct efx_link_state *link_state = &efx->link_state;
+
 	/* SFC Bug 5356: A net_dev notifier is registered, so we must ensure
 	 * that no events are triggered between unregister_netdev() and the
 	 * driver unloading. A more general condition is that NETDEV_CHANGE
@@ -556,140 +921,177 @@ static void efx_link_status_changed(stru
 	if (!netif_running(efx->net_dev))
 		return;
 
-	if (efx->port_inhibited) {
-		netif_carrier_off(efx->net_dev);
-		return;
-	}
-
-	if (efx->link_up != netif_carrier_ok(efx->net_dev)) {
+	if (link_state->up != netif_carrier_ok(efx->net_dev)) {
 		efx->n_link_state_changes++;
 
-		if (efx->link_up)
+		if (link_state->up)
 			netif_carrier_on(efx->net_dev);
 		else
 			netif_carrier_off(efx->net_dev);
 	}
 
 	/* Status message for kernel log */
-	if (efx->link_up) {
-		EFX_INFO(efx, "link up at %uMbps %s-duplex (MTU %d)%s\n",
-			 efx->link_speed, efx->link_fd ? "full" : "half",
-			 efx->net_dev->mtu,
-			 (efx->promiscuous ? " [PROMISC]" : ""));
+	if (link_state->up) {
+		netif_info(efx, link, efx->net_dev,
+			   "link up at %uMbps %s-duplex (MTU %d)%s%s%s%s\n",
+			   link_state->speed, link_state->fd ? "full" : "half",
+			   efx->net_dev->mtu,
+			   (efx->loopback_mode ? " [" : ""),
+			   (efx->loopback_mode ? LOOPBACK_MODE(efx) : ""),
+			   (efx->loopback_mode ? " LOOPBACK]" : ""),
+			   (efx->promiscuous ? " [PROMISC]" : ""));
+
+		if ((efx->wanted_fc & EFX_FC_AUTO) &&
+		    (efx->wanted_fc & EFX_FC_TX) &&
+		    (~efx->link_state.fc & EFX_FC_TX))
+			/* There is no way to report this state
+			 * through ethtool, so print this information
+			 * to the kernel log */
+			netif_info(efx, link, efx->net_dev,
+				   "Flow control autonegotiated "
+				   "tx OFF (wanted ON)\n");
 	} else {
-		EFX_INFO(efx, "link down\n");
+		netif_info(efx, link, efx->net_dev, "link down%s\n",
+			   (efx->phy_mode & PHY_MODE_LOW_POWER) ? " [OFF]" : "");
 	}
 
 }
 
+void efx_link_set_advertising(struct efx_nic *efx, u32 advertising)
+{
+	efx->link_advertising = advertising;
+	if (advertising & ADVERTISED_Autoneg) {
+		if (advertising & ADVERTISED_Pause)
+			efx->wanted_fc |= (EFX_FC_TX | EFX_FC_RX);
+		else
+			efx->wanted_fc &= ~(EFX_FC_TX | EFX_FC_RX);
+		if (advertising & ADVERTISED_Asym_Pause)
+			efx->wanted_fc ^= EFX_FC_TX;
+	}
+}
+
+void efx_link_set_wanted_fc(struct efx_nic *efx, enum efx_fc_type wanted_fc)
+{
+	efx->wanted_fc = wanted_fc;
+	if (efx->link_advertising & ADVERTISED_Autoneg) {
+		if (wanted_fc & EFX_FC_RX)
+			efx->link_advertising |= (ADVERTISED_Pause |
+						  ADVERTISED_Asym_Pause);
+		else
+			efx->link_advertising &= ~(ADVERTISED_Pause |
+						   ADVERTISED_Asym_Pause);
+		if (wanted_fc & EFX_FC_TX)
+			efx->link_advertising ^= ADVERTISED_Asym_Pause;
+	}
+}
+
 static void efx_fini_port(struct efx_nic *efx);
 
-/* This call reinitialises the MAC to pick up new PHY settings. The
- * caller must hold the mac_lock */
-void __efx_reconfigure_port(struct efx_nic *efx)
+/* Push loopback/power/transmit disable settings to the PHY, and reconfigure
+ * the MAC appropriately. All other PHY configuration changes are pushed
+ * through phy_op->set_settings(), and pushed asynchronously to the MAC
+ * through efx_monitor().
+ *
+ * Callers must hold the mac_lock
+ */
+int __efx_reconfigure_port(struct efx_nic *efx)
 {
+	enum efx_phy_mode phy_mode;
+	int rc;
+
 	WARN_ON(!mutex_is_locked(&efx->mac_lock));
 
-	EFX_LOG(efx, "reconfiguring MAC from PHY settings on CPU %d\n",
-		raw_smp_processor_id());
-
-	/* Serialise the promiscuous flag with efx_set_multicast_list. */
-	if (efx_dev_registered(efx)) {
-		netif_addr_lock_bh(efx->net_dev);
-		netif_addr_unlock_bh(efx->net_dev);
-	}
-
-	falcon_deconfigure_mac_wrapper(efx);
-
-	/* Reconfigure the PHY, disabling transmit in mac level loopback. */
+	/* Serialise the promiscuous flag with efx_set_rx_mode. */
+	netif_addr_lock_bh(efx->net_dev);
+	netif_addr_unlock_bh(efx->net_dev);
+
+	/* Disable PHY transmit in mac level loopbacks */
+	phy_mode = efx->phy_mode;
 	if (LOOPBACK_INTERNAL(efx))
 		efx->phy_mode |= PHY_MODE_TX_DISABLED;
 	else
 		efx->phy_mode &= ~PHY_MODE_TX_DISABLED;
-	efx->phy_op->reconfigure(efx);
-
-	if (falcon_switch_mac(efx))
-		goto fail;
-
-	efx->mac_op->reconfigure(efx);
-
-	/* Inform kernel of loss/gain of carrier */
-	efx_link_status_changed(efx);
-	return;
-
-fail:
-	EFX_ERR(efx, "failed to reconfigure MAC\n");
-	efx->port_enabled = false;
-	efx_fini_port(efx);
+
+	rc = efx->type->reconfigure_port(efx);
+
+	if (rc)
+		efx->phy_mode = phy_mode;
+
+	return rc;
 }
 
 /* Reinitialise the MAC to pick up new PHY settings, even if the port is
  * disabled. */
-void efx_reconfigure_port(struct efx_nic *efx)
+int efx_reconfigure_port(struct efx_nic *efx)
 {
+	int rc;
+
 	EFX_ASSERT_RESET_SERIALISED(efx);
 
 	mutex_lock(&efx->mac_lock);
-	__efx_reconfigure_port(efx);
+	rc = __efx_reconfigure_port(efx);
 	mutex_unlock(&efx->mac_lock);
+
+	return rc;
 }
 
-/* Asynchronous efx_reconfigure_port work item. To speed up efx_flush_all()
- * we don't efx_reconfigure_port() if the port is disabled. Care is taken
- * in efx_stop_all() and efx_start_port() to prevent PHY events being lost */
-static void efx_phy_work(struct work_struct *data)
-{
-	struct efx_nic *efx = container_of(data, struct efx_nic, phy_work);
-
-	mutex_lock(&efx->mac_lock);
-	if (efx->port_enabled)
-		__efx_reconfigure_port(efx);
-	mutex_unlock(&efx->mac_lock);
-}
-
+/* Asynchronous work item for changing MAC promiscuity and multicast
+ * hash.  Avoid a drain/rx_ingress enable by reconfiguring the current
+ * MAC directly. */
 static void efx_mac_work(struct work_struct *data)
 {
 	struct efx_nic *efx = container_of(data, struct efx_nic, mac_work);
 
 	mutex_lock(&efx->mac_lock);
 	if (efx->port_enabled)
-		efx->mac_op->irq(efx);
+		efx->type->reconfigure_mac(efx);
 	mutex_unlock(&efx->mac_lock);
 }
 
 static int efx_probe_port(struct efx_nic *efx)
 {
+	unsigned char *perm_addr;
 	int rc;
 
-	EFX_LOG(efx, "create port\n");
-
-	/* Connect up MAC/PHY operations table and read MAC address */
-	rc = falcon_probe_port(efx);
-	if (rc)
-		goto err;
+	netif_dbg(efx, probe, efx->net_dev, "create port\n");
 
 	if (phy_flash_cfg)
 		efx->phy_mode = PHY_MODE_SPECIAL;
 
+	/* Register debugfs entries */
+	rc = efx_init_debugfs_port(efx);
+	if (rc)
+		return rc;
+
+	/* Connect up MAC/PHY operations table */
+	rc = efx->type->probe_port(efx);
+	if (rc)
+		goto fail1;
+
 	/* Sanity check MAC address */
-	if (is_valid_ether_addr(efx->mac_address)) {
-		memcpy(efx->net_dev->dev_addr, efx->mac_address, ETH_ALEN);
+	perm_addr = efx->net_dev->perm_addr;
+	if (is_valid_ether_addr(perm_addr)) {
+		memcpy(efx->net_dev->dev_addr, perm_addr, ETH_ALEN);
 	} else {
-		EFX_ERR(efx, "invalid MAC address %pM\n",
-			efx->mac_address);
 		if (!allow_bad_hwaddr) {
+			netif_err(efx, probe, efx->net_dev,
+				  "invalid MAC address %pM\n",
+				  perm_addr);
 			rc = -EINVAL;
-			goto err;
+			goto fail2;
 		}
 		random_ether_addr(efx->net_dev->dev_addr);
-		EFX_INFO(efx, "using locally-generated MAC %pM\n",
-			 efx->net_dev->dev_addr);
+		netif_info(efx, probe, efx->net_dev,
+			   "using locally-generated MAC %pM\n",
+			   efx->net_dev->dev_addr);
 	}
 
 	return 0;
 
- err:
-	efx_remove_port(efx);
+fail2:
+	efx->type->remove_port(efx);
+fail1:
+	efx_fini_debugfs_port(efx);
 	return rc;
 }
 
@@ -697,82 +1099,84 @@ static int efx_init_port(struct efx_nic 
 {
 	int rc;
 
-	EFX_LOG(efx, "init port\n");
+	netif_dbg(efx, drv, efx->net_dev, "init port\n");
+
+	mutex_lock(&efx->mac_lock);
 
 	rc = efx->phy_op->init(efx);
 	if (rc)
-		return rc;
-	mutex_lock(&efx->mac_lock);
-	efx->phy_op->reconfigure(efx);
-	rc = falcon_switch_mac(efx);
+		goto fail1;
+
+	efx->port_initialized = true;
+
+	/* Reconfigure the MAC before creating dma queues (required for
+	 * Falcon/A1 where RX_INGR_EN/TX_DRAIN_EN isn't supported) */
+	efx->type->reconfigure_mac(efx);
+
+	/* Ensure the PHY advertises the correct flow control settings */
+	rc = efx->phy_op->reconfigure(efx);
+	if (rc)
+		goto fail2;
+
 	mutex_unlock(&efx->mac_lock);
-	if (rc)
-		goto fail;
-	efx->mac_op->reconfigure(efx);
-
-	efx->port_initialized = true;
-	efx_stats_enable(efx);
 	return 0;
 
-fail:
+fail2:
 	efx->phy_op->fini(efx);
+fail1:
+	mutex_unlock(&efx->mac_lock);
 	return rc;
 }
 
-/* Allow efx_reconfigure_port() to be scheduled, and close the window
- * between efx_stop_port and efx_flush_all whereby a previously scheduled
- * efx_phy_work()/efx_mac_work() may have been cancelled */
 static void efx_start_port(struct efx_nic *efx)
 {
-	EFX_LOG(efx, "start port\n");
+	netif_dbg(efx, ifup, efx->net_dev, "start port\n");
 	BUG_ON(efx->port_enabled);
 
 	mutex_lock(&efx->mac_lock);
 	efx->port_enabled = true;
-	__efx_reconfigure_port(efx);
-	efx->mac_op->irq(efx);
+
+	/* efx_mac_work() might have been scheduled after efx_stop_port(),
+	 * and then cancelled by efx_flush_all(). Also reverse the actions
+	 * of prepare_flush() */
+	efx->type->reconfigure_mac(efx);
+
 	mutex_unlock(&efx->mac_lock);
 }
 
-/* Prevent efx_phy_work, efx_mac_work, and efx_monitor() from executing,
- * and efx_set_multicast_list() from scheduling efx_phy_work. efx_phy_work
- * and efx_mac_work may still be scheduled via NAPI processing until
- * efx_flush_all() is called */
+/* Prevent efx_mac_work() and efx_monitor() from working */
 static void efx_stop_port(struct efx_nic *efx)
 {
-	EFX_LOG(efx, "stop port\n");
+	netif_dbg(efx, ifdown, efx->net_dev, "stop port\n");
 
 	mutex_lock(&efx->mac_lock);
 	efx->port_enabled = false;
 	mutex_unlock(&efx->mac_lock);
 
-	/* Serialise against efx_set_multicast_list() */
-	if (efx_dev_registered(efx)) {
-		netif_addr_lock_bh(efx->net_dev);
-		netif_addr_unlock_bh(efx->net_dev);
-	}
+	netif_addr_lock_bh(efx->net_dev);
+	netif_addr_unlock_bh(efx->net_dev);
 }
 
 static void efx_fini_port(struct efx_nic *efx)
 {
-	EFX_LOG(efx, "shut down port\n");
+	netif_dbg(efx, drv, efx->net_dev, "shut down port\n");
 
 	if (!efx->port_initialized)
 		return;
 
-	efx_stats_disable(efx);
 	efx->phy_op->fini(efx);
 	efx->port_initialized = false;
 
-	efx->link_up = false;
+	efx->link_state.up = false;
 	efx_link_status_changed(efx);
 }
 
 static void efx_remove_port(struct efx_nic *efx)
 {
-	EFX_LOG(efx, "destroying port\n");
-
-	falcon_remove_port(efx);
+	netif_dbg(efx, drv, efx->net_dev, "destroying port\n");
+
+	efx->type->remove_port(efx);
+	efx_fini_debugfs_port(efx);
 }
 
 /**************************************************************************
@@ -788,11 +1192,12 @@ static int efx_init_io(struct efx_nic *e
 	dma_addr_t dma_mask = efx->type->max_dma_mask;
 	int rc;
 
-	EFX_LOG(efx, "initialising I/O\n");
+	netif_dbg(efx, probe, efx->net_dev, "initialising I/O\n");
 
 	rc = pci_enable_device(pci_dev);
 	if (rc) {
-		EFX_ERR(efx, "failed to enable PCI device\n");
+		netif_err(efx, probe, efx->net_dev,
+			  "failed to enable PCI device\n");
 		goto fail1;
 	}
 
@@ -810,46 +1215,50 @@ static int efx_init_io(struct efx_nic *e
 		dma_mask >>= 1;
 	}
 	if (rc) {
-		EFX_ERR(efx, "could not find a suitable DMA mask\n");
+		netif_err(efx, probe, efx->net_dev,
+			  "could not find a suitable DMA mask\n");
 		goto fail2;
 	}
-	EFX_LOG(efx, "using DMA mask %llx\n", (unsigned long long) dma_mask);
+	netif_dbg(efx, probe, efx->net_dev,
+		  "using DMA mask %llx\n", (unsigned long long) dma_mask);
 	rc = pci_set_consistent_dma_mask(pci_dev, dma_mask);
 	if (rc) {
 		/* pci_set_consistent_dma_mask() is not *allowed* to
 		 * fail with a mask that pci_set_dma_mask() accepted,
 		 * but just in case...
 		 */
-		EFX_ERR(efx, "failed to set consistent DMA mask\n");
+		netif_err(efx, probe, efx->net_dev,
+			  "failed to set consistent DMA mask\n");
 		goto fail2;
 	}
 
-	efx->membase_phys = pci_resource_start(efx->pci_dev,
-					       efx->type->mem_bar);
-	rc = pci_request_region(pci_dev, efx->type->mem_bar, "sfc");
+	efx->membase_phys = pci_resource_start(efx->pci_dev, EFX_MEM_BAR);
+	rc = pci_request_region(pci_dev, EFX_MEM_BAR, "sfc");
 	if (rc) {
-		EFX_ERR(efx, "request for memory BAR failed\n");
+		netif_err(efx, probe, efx->net_dev,
+			  "request for memory BAR failed\n");
 		rc = -EIO;
 		goto fail3;
 	}
 	efx->membase = ioremap_nocache(efx->membase_phys,
 				       efx->type->mem_map_size);
 	if (!efx->membase) {
-		EFX_ERR(efx, "could not map memory BAR %d at %llx+%x\n",
-			efx->type->mem_bar,
-			(unsigned long long)efx->membase_phys,
-			efx->type->mem_map_size);
+		netif_err(efx, probe, efx->net_dev,
+			  "could not map memory BAR at %llx+%x\n",
+			  (unsigned long long)efx->membase_phys,
+			  efx->type->mem_map_size);
 		rc = -ENOMEM;
 		goto fail4;
 	}
-	EFX_LOG(efx, "memory BAR %u at %llx+%x (virtual %p)\n",
-		efx->type->mem_bar, (unsigned long long)efx->membase_phys,
-		efx->type->mem_map_size, efx->membase);
+	netif_dbg(efx, probe, efx->net_dev,
+		  "memory BAR at %llx+%x (virtual %p)\n",
+		  (unsigned long long)efx->membase_phys,
+		  efx->type->mem_map_size, efx->membase);
 
 	return 0;
 
  fail4:
-	pci_release_region(efx->pci_dev, efx->type->mem_bar);
+	pci_release_region(efx->pci_dev, EFX_MEM_BAR);
  fail3:
 	efx->membase_phys = 0;
  fail2:
@@ -860,7 +1269,7 @@ static int efx_init_io(struct efx_nic *e
 
 static void efx_fini_io(struct efx_nic *efx)
 {
-	EFX_LOG(efx, "shutting down I/O\n");
+	netif_dbg(efx, drv, efx->net_dev, "shutting down I/O\n");
 
 	if (efx->membase) {
 		iounmap(efx->membase);
@@ -868,21 +1277,20 @@ static void efx_fini_io(struct efx_nic *
 	}
 
 	if (efx->membase_phys) {
-		pci_release_region(efx->pci_dev, efx->type->mem_bar);
+		pci_release_region(efx->pci_dev, EFX_MEM_BAR);
 		efx->membase_phys = 0;
 	}
 
 	pci_disable_device(efx->pci_dev);
 }
 
-/* Get number of RX queues wanted.  Return number of online CPU
- * packages in the expectation that an IRQ balancer will spread
- * interrupts across them. */
-static int efx_wanted_rx_queues(void)
+#if !defined(EFX_USE_KCOMPAT) || (defined(topology_core_cpumask) && !defined(__VMKLNX__))
+#define HAVE_EFX_NUM_PACKAGES
+static int efx_num_packages(void)
 {
 	cpumask_var_t core_mask;
 	int count;
-	int cpu;
+	int cpu, cpu2;
 
 	if (unlikely(!zalloc_cpumask_var(&core_mask, GFP_KERNEL))) {
 		printk(KERN_WARNING
@@ -894,81 +1302,337 @@ static int efx_wanted_rx_queues(void)
 	for_each_online_cpu(cpu) {
 		if (!cpumask_test_cpu(cpu, core_mask)) {
 			++count;
-			cpumask_or(core_mask, core_mask,
-				   topology_core_cpumask(cpu));
+
+			/* Treat each numa node as a seperate package */
+			for_each_cpu(cpu2, topology_core_cpumask(cpu)) {
+				if (cpu_to_node(cpu) == cpu_to_node(cpu2))
+					cpumask_set_cpu(cpu2, core_mask);
+			}
 		}
 	}
 
+	/* Create two RSS queues even on a single package host */
+	if (count == 1)
+		count = 2;
+
 	free_cpumask_var(core_mask);
 	return count;
 }
+#endif
+
+static int efx_wanted_parallelism(struct efx_nic *efx)
+{
+	enum rss_mode rss_mode = EFX_RSS_CORES;
+	bool selected = false;
+	int n_rxq = -1;
+	struct net_device *net_dev =
+#ifdef __VMKLNX__
+		!efx ? NULL :
+#endif
+		efx->net_dev;
+
+	if (rss_cpus == NULL) {
+		/* Leave at default. */
+	} else if (strcmp(rss_cpus, "packages") == 0) {
+		rss_mode = EFX_RSS_PACKAGES;
+		selected = true;
+	} else if (strcmp(rss_cpus, "cores") == 0) {
+		rss_mode = EFX_RSS_CORES;
+		selected = true;
+	} else if (strcmp(rss_cpus, "hyperthreads") == 0) {
+		rss_mode = EFX_RSS_HYPERTHREADS;
+		selected = true;
+	} else if (sscanf(rss_cpus, "%d", &n_rxq) == 1 && n_rxq > 0) {
+		rss_mode = EFX_RSS_CUSTOM;
+		selected = true;
+	} else {
+		netif_err(efx, drv, net_dev,
+			  "Bad value for module parameter rss_cpus='%s'\n",
+			  rss_cpus);
+	}
+
+	switch (rss_mode) {
+#if defined(HAVE_EFX_NUM_PACKAGES)
+	case EFX_RSS_PACKAGES:
+		if (xen_domain()) {
+			netif_warn(efx, drv, net_dev,
+				   "Unable to determine CPU topology"
+				   " on Xen reliably. Using 4 rss channels.\n");
+			n_rxq = 4;
+		} else {
+			netif_dbg(efx,  drv, net_dev,
+				  "using efx_num_packages()\n");
+			n_rxq = efx_num_packages();
+		}
+		break;
+#endif
+#if defined(HAVE_EFX_NUM_CORES)
+	case EFX_RSS_CORES:
+		if (xen_domain()) {
+			netif_warn(efx, drv, net_dev,
+				   "Unable to determine CPU topology"
+				   " on Xen reliably. Assuming hyperthreading"
+				   " enabled.\n");
+			n_rxq = max_t(int, 1, num_online_cpus() / 2);
+		} else {
+			netif_dbg(efx, drv, net_dev,
+				  "using efx_num_cores()\n");
+			n_rxq = efx_num_cores();
+		}
+		break;
+#endif
+	case EFX_RSS_HYPERTHREADS:
+		n_rxq = num_online_cpus();
+		break;
+	case EFX_RSS_CUSTOM:
+		break;
+	default:
+		if (selected)
+			netif_err(efx, drv, net_dev,
+				  "Selected rss mode '%s' not available\n",
+				  rss_cpus);
+		rss_mode = EFX_RSS_HYPERTHREADS;
+		n_rxq = num_online_cpus();
+		break;
+	}
+
+	if (n_rxq > EFX_MAX_RX_QUEUES) {
+		netif_warn(efx, drv, net_dev,
+			   "Reducing number of rss channels from %d to %d.\n",
+			   n_rxq, EFX_MAX_RX_QUEUES);
+		n_rxq = EFX_MAX_RX_QUEUES;
+	}
+
+	/* If RSS is requested for the PF *and* VFs then we can't write RSS
+	 * table entries that are inaccessible to VFs */
+#ifdef __VMKLNX__
+	if (efx)
+#endif
+	if (efx->vf_count && efx->vi_scale && n_rxq > (1 << efx->vi_scale)) {
+		netif_warn(efx, drv, net_dev,
+			   "Reducing number of rss channels from %d to %d for "
+			   "VF support. Increase vf-msix-limit to use more "
+			   "channels on the PF.\n", n_rxq, 1 << efx->vi_scale);
+		n_rxq = (1 << efx->vi_scale);
+	}
+
+	return n_rxq;
+}
+
+static int
+efx_init_rx_cpu_rmap(struct efx_nic *efx, struct msix_entry *xentries)
+{
+#ifdef CONFIG_RFS_ACCEL
+	int i, rc;
+
+	efx->net_dev->rx_cpu_rmap = alloc_irq_cpu_rmap(efx->n_rx_channels);
+	if (!efx->net_dev->rx_cpu_rmap)
+		return -ENOMEM;
+	for (i = 0; i < efx->n_rx_channels; i++) {
+		rc = irq_cpu_rmap_add(efx->net_dev->rx_cpu_rmap,
+		                      xentries[i].vector);
+		if (rc) {
+			free_irq_cpu_rmap(efx->net_dev->rx_cpu_rmap);
+			efx->net_dev->rx_cpu_rmap = NULL;
+			return rc;
+		}
+	}
+#endif
+	return 0;
+}
+
+static int efx_allocate_msix_channels(struct efx_nic *efx, int max_channels,
+                                      int extra_channels, int parallelism)
+{
+	int n_channels = parallelism;
+
+	if (separate_tx_channels)
+		n_channels *= 2;
+	n_channels += extra_channels;
+	n_channels = min(n_channels, max_channels);
+
+	efx->n_channels = n_channels;
+
+	if (n_channels > extra_channels)
+		n_channels -= extra_channels;
+
+	if (separate_tx_channels) {
+		efx->n_tx_channels =
+			max(n_channels / 2, 1);
+		efx->tx_channel_offset =
+			n_channels - efx->n_tx_channels;
+		efx->n_rx_channels =
+			max(n_channels -
+			    efx->n_tx_channels, 1U);
+	} else {
+		efx->n_tx_channels = n_channels;
+		efx->tx_channel_offset = 0;
+		efx->n_rx_channels = n_channels;
+	}
+	efx->n_rss_channels = efx->n_rx_channels;
+	efx->rss_spread = efx->n_rss_channels;
+
+	return efx->n_channels;
+}
 
 /* Probe the number and type of interrupts we are able to obtain, and
  * the resulting numbers of channels and RX queues.
  */
-static void efx_probe_interrupts(struct efx_nic *efx)
+static int efx_probe_interrupts(struct efx_nic *efx)
 {
 	int max_channels =
 		min_t(int, efx->type->phys_addr_channels, EFX_MAX_CHANNELS);
-	int rc, i;
+	unsigned extra_channels = 0;
+	int rc, i, j;
+
+	for (i = 0; i < EFX_MAX_EXTRA_CHANNELS; i++)
+		if (efx->extra_channel_type[i])
+			++extra_channels;
 
 	if (efx->interrupt_mode == EFX_INT_MODE_MSIX) {
 		struct msix_entry xentries[EFX_MAX_CHANNELS];
-		int wanted_ints;
-		int rx_queues;
-
-		/* We want one RX queue and interrupt per CPU package
-		 * (or as specified by the rss_cpus module parameter).
-		 * We will need one channel per interrupt.
-		 */
-		rx_queues = rss_cpus ? rss_cpus : efx_wanted_rx_queues();
-		wanted_ints = rx_queues + (separate_tx_channels ? 1 : 0);
-		wanted_ints = min(wanted_ints, max_channels);
-
-		for (i = 0; i < wanted_ints; i++)
+		int parallelism = efx_wanted_parallelism(efx);
+		int n_channels = efx_allocate_msix_channels(efx, max_channels,
+		                                            extra_channels,
+		                                            parallelism);
+		efx->n_wanted_channels = n_channels +
+			EFX_MAX_EXTRA_CHANNELS - extra_channels;
+
+		for (i = 0; i < n_channels; i++)
 			xentries[i].entry = i;
-		rc = pci_enable_msix(efx->pci_dev, xentries, wanted_ints);
+		rc = pci_enable_msix(efx->pci_dev, xentries, n_channels);
 		if (rc > 0) {
-			EFX_ERR(efx, "WARNING: Insufficient MSI-X vectors"
-				" available (%d < %d).\n", rc, wanted_ints);
-			EFX_ERR(efx, "WARNING: Performance may be reduced.\n");
-			EFX_BUG_ON_PARANOID(rc >= wanted_ints);
-			wanted_ints = rc;
+			netif_err(efx, drv, efx->net_dev,
+				  "WARNING: Insufficient MSI-X vectors"
+				  " available (%d < %d).\n", rc, n_channels);
+			netif_err(efx, drv, efx->net_dev,
+				  "WARNING: Performance may be reduced.\n");
+			EFX_BUG_ON_PARANOID(rc >= n_channels);
+			n_channels = rc;
+			efx_allocate_msix_channels(efx, n_channels,
+			                           extra_channels,
+			                           parallelism);
 			rc = pci_enable_msix(efx->pci_dev, xentries,
-					     wanted_ints);
+					     n_channels);
 		}
 
 		if (rc == 0) {
-			efx->n_rx_queues = min(rx_queues, wanted_ints);
-			efx->n_channels = wanted_ints;
-			for (i = 0; i < wanted_ints; i++)
-				efx->channel[i].irq = xentries[i].vector;
+			rc = efx_init_rx_cpu_rmap(efx, xentries);
+			if (rc) {
+				pci_disable_msix(efx->pci_dev);
+				return rc;
+			}
+			for (i = 0; i < efx->n_channels; i++)
+				efx_get_channel(efx, i)->irq =
+					xentries[i].vector;
 		} else {
 			/* Fall back to single channel MSI */
 			efx->interrupt_mode = EFX_INT_MODE_MSI;
-			EFX_ERR(efx, "could not enable MSI-X\n");
+			netif_err(efx, drv, efx->net_dev,
+				  "could not enable MSI-X\n");
 		}
 	}
 
 	/* Try single interrupt MSI */
 	if (efx->interrupt_mode == EFX_INT_MODE_MSI) {
-		efx->n_rx_queues = 1;
 		efx->n_channels = 1;
+		efx->n_rx_channels = 1;
+		efx->n_rss_channels = 1;
+		efx->rss_spread = 1;
+		efx->n_tx_channels = 1;
+		efx->tx_channel_offset = 0;
+		efx->n_wanted_channels = 1;
 		rc = pci_enable_msi(efx->pci_dev);
 		if (rc == 0) {
-			efx->channel[0].irq = efx->pci_dev->irq;
+			efx_get_channel(efx, 0)->irq = efx->pci_dev->irq;
 		} else {
-			EFX_ERR(efx, "could not enable MSI\n");
+			netif_err(efx, drv, efx->net_dev,
+				  "could not enable MSI\n");
 			efx->interrupt_mode = EFX_INT_MODE_LEGACY;
 		}
 	}
 
 	/* Assume legacy interrupts */
 	if (efx->interrupt_mode == EFX_INT_MODE_LEGACY) {
-		efx->n_rx_queues = 1;
-		efx->n_channels = 1 + (separate_tx_channels ? 1 : 0);
+		efx->n_channels = 1 + (separate_tx_channels ? 1 : 0)
+			+ (efx->vf_count ? 1 : 0);
+		efx->n_rx_channels = 1;
+		efx->n_rss_channels = 1;
+		efx->rss_spread = 1;
+		efx->n_tx_channels = 1;
+		efx->tx_channel_offset = 0;
+		efx->n_wanted_channels = efx->n_channels;
 		efx->legacy_irq = efx->pci_dev->irq;
 	}
+
+	/* Assign extra channels if possible */
+	j = efx->n_channels;
+	for (i = 0; i < EFX_MAX_EXTRA_CHANNELS; i++) {
+		if (!efx->extra_channel_type[i])
+			continue;
+		if (efx->interrupt_mode != EFX_INT_MODE_MSIX ||
+		    efx->n_channels <= extra_channels) {
+			efx->extra_channel_type[i]->handle_no_channel(efx);
+		} else {
+			--j;
+			efx_get_channel(efx, j)->type =
+				efx->extra_channel_type[i];
+		}
+	}
+
+#ifdef __VMKLNX__
+	rx_set_num_qs_per_nic(efx);
+#endif
+
+	/* RSS on the PF might now be impossible due to interrupt allocation
+	 * failure */
+	efx->rss_spread = (efx->vf_count && efx->rss_spread == 1) ?
+		(1 << efx->vi_scale) : efx->rss_spread;
+
+	netif_info(efx, drv, efx->net_dev, "RSS spread is %d channels\n",
+					efx->rss_spread);
+
+	return 0;
+}
+
+/* Enable interrupts, then probe and start the event queues */
+static void efx_start_interrupts(struct efx_nic *efx, bool may_keep_eventq)
+{
+	struct efx_channel *channel;
+
+	if (efx->legacy_irq)
+		efx->legacy_irq_enabled = true;
+	efx_nic_enable_interrupts(efx);
+
+	efx_for_each_channel(channel, efx) {
+		if (!channel->type->keep_eventq || !may_keep_eventq)
+			efx_init_eventq(channel);
+		efx_start_eventq(channel);
+	}
+
+		efx_mcdi_mode_event(efx);
+}
+
+static void efx_stop_interrupts(struct efx_nic *efx, bool may_keep_eventq)
+{
+	struct efx_channel *channel;
+
+	efx_mcdi_mode_poll(efx);
+
+	efx_nic_disable_interrupts(efx);
+	if (efx->legacy_irq) {
+		synchronize_irq(efx->legacy_irq);
+		efx->legacy_irq_enabled = false;
+	}
+
+	efx_for_each_channel(channel, efx) {
+		if (channel->irq)
+			synchronize_irq(channel->irq);
+
+		efx_stop_eventq(channel);
+		if (!channel->type->keep_eventq || !may_keep_eventq)
+			efx_fini_eventq(channel);
+	}
 }
 
 static void efx_remove_interrupts(struct efx_nic *efx)
@@ -987,52 +1651,96 @@ static void efx_remove_interrupts(struct
 
 static void efx_set_channels(struct efx_nic *efx)
 {
+	struct efx_channel *channel;
 	struct efx_tx_queue *tx_queue;
-	struct efx_rx_queue *rx_queue;
-
-	efx_for_each_tx_queue(tx_queue, efx) {
-		if (separate_tx_channels)
-			tx_queue->channel = &efx->channel[efx->n_channels-1];
+
+	/* We need to mark which channels really have RX and TX
+	 * queues, and adjust the TX queue numbers if we have separate
+	 * RX-only and TX-only channels.
+	 */
+	efx_for_each_channel(channel, efx) {
+		if (channel->channel < efx->n_rx_channels)
+			channel->rx_queue.core_index = channel->channel;
 		else
-			tx_queue->channel = &efx->channel[0];
-		tx_queue->channel->used_flags |= EFX_USED_BY_TX;
-	}
-
-	efx_for_each_rx_queue(rx_queue, efx) {
-		rx_queue->channel = &efx->channel[rx_queue->queue];
-		rx_queue->channel->used_flags |= EFX_USED_BY_RX;
+			channel->rx_queue.core_index = -1;
+
+		efx_for_each_channel_tx_queue(tx_queue, channel)
+			tx_queue->queue -= (efx->tx_channel_offset *
+					    EFX_TXQ_TYPES);
 	}
 }
 
 static int efx_probe_nic(struct efx_nic *efx)
 {
+	size_t i;
 	int rc;
 
-	EFX_LOG(efx, "creating NIC\n");
+	netif_dbg(efx, probe, efx->net_dev, "creating NIC\n");
+
+	/* Initialise NIC resource information */
+	efx->resources = efx->type->resources;
+	efx->resources.biu_lock = &efx->biu_lock;
+	efx->dl_info = &efx->resources.hdr;
 
 	/* Carry out hardware-type specific initialisation */
-	rc = falcon_probe_nic(efx);
+	rc = efx->type->probe(efx);
 	if (rc)
-		return rc;
-
-	/* Determine the number of channels and RX queues by trying to hook
+		goto fail1;
+
+	/* Determine the number of channels and queues by trying to hook
 	 * in MSI-X interrupts. */
-	efx_probe_interrupts(efx);
+	rc = efx_probe_interrupts(efx);
+	if (rc)
+		goto fail2;
+
+	rc = efx->type->dimension_resources(efx);
+	if (rc)
+		goto fail3;
+
+	if (EFX_INT_MODE_USE_MSI(efx))
+		efx->resources.flags |= EFX_DL_FALCON_USE_MSI;
+
+	if (efx->n_channels > 1)
+		get_random_bytes(&efx->rx_hash_key, sizeof(efx->rx_hash_key));
+
+	for (i = 0; i < ARRAY_SIZE(efx->rx_indir_table); i++)
+		efx->rx_indir_table[i] =
+			ethtool_rxfh_indir_default(i, efx->rss_spread);
 
 	efx_set_channels(efx);
+	netif_set_real_num_tx_queues(efx->net_dev, efx->n_tx_channels);
+	netif_set_real_num_rx_queues(efx->net_dev, efx->n_rx_channels);
+
+	/* Register debugfs entries */
+	rc = efx_init_debugfs_nic(efx);
+	if (rc)
+		goto fail4;
 
 	/* Initialise the interrupt moderation settings */
-	efx_init_irq_moderation(efx, tx_irq_mod_usec, rx_irq_mod_usec, true);
+	efx_init_irq_moderation(efx, tx_irq_mod_usec, rx_irq_mod_usec,
+				irq_adapt_enable, true);
 
 	return 0;
+
+fail4:
+fail3:
+	efx_remove_interrupts(efx);
+fail2:
+	efx->type->remove(efx);
+fail1:
+	efx->dl_info = NULL;
+	return rc;
 }
 
 static void efx_remove_nic(struct efx_nic *efx)
 {
-	EFX_LOG(efx, "destroying NIC\n");
+	netif_dbg(efx, drv, efx->net_dev, "destroying NIC\n");
 
 	efx_remove_interrupts(efx);
-	falcon_remove_nic(efx);
+	efx->type->remove(efx);
+	efx->dl_info = NULL;
+
+	efx_fini_debugfs_nic(efx);
 }
 
 /**************************************************************************
@@ -1043,39 +1751,56 @@ static void efx_remove_nic(struct efx_ni
 
 static int efx_probe_all(struct efx_nic *efx)
 {
-	struct efx_channel *channel;
 	int rc;
 
-	/* Create NIC */
 	rc = efx_probe_nic(efx);
 	if (rc) {
-		EFX_ERR(efx, "failed to create NIC\n");
+		netif_err(efx, probe, efx->net_dev, "failed to create NIC\n");
 		goto fail1;
 	}
 
-	/* Create port */
 	rc = efx_probe_port(efx);
 	if (rc) {
-		EFX_ERR(efx, "failed to create port\n");
+		netif_err(efx, probe, efx->net_dev, "failed to create port\n");
 		goto fail2;
 	}
 
-	/* Create channels */
-	efx_for_each_channel(channel, efx) {
-		rc = efx_probe_channel(channel);
-		if (rc) {
-			EFX_ERR(efx, "failed to create channel %d\n",
-				channel->channel);
-			goto fail3;
-		}
+	efx->rxq_entries = rx_ring;
+	efx->txq_entries = tx_ring;
+
+	if (efx->rxq_entries < EFX_MIN_RING_SIZE ||
+	    efx->rxq_entries > EFX_MAX_DMAQ_SIZE) {
+		netif_err(efx, drv, efx->net_dev,
+			  "rx_ring parameter must be between %ld and %ld",
+			  EFX_MIN_RING_SIZE, EFX_MAX_DMAQ_SIZE);
+		rc = -EINVAL;
+		goto fail3;
 	}
-	efx_set_channel_names(efx);
+	if (efx->txq_entries < EFX_MIN_RING_SIZE ||
+	    efx->txq_entries > EFX_MAX_DMAQ_SIZE) {
+		netif_err(efx, drv, efx->net_dev,
+			  "tx_ring parameter must be between %ld and %ld",
+			  EFX_MIN_RING_SIZE, EFX_MAX_DMAQ_SIZE);
+		rc = -EINVAL;
+		goto fail3;
+	}
+
+	rc = efx_probe_filters(efx);
+	if (rc) {
+		netif_err(efx, probe, efx->net_dev,
+			  "failed to create filter tables\n");
+		goto fail3;
+	}
+
+	rc = efx_probe_channels(efx);
+	if (rc)
+		goto fail4;
 
 	return 0;
 
+ fail4:
+	efx_remove_filters(efx);
  fail3:
-	efx_for_each_channel(channel, efx)
-		efx_remove_channel(channel);
 	efx_remove_port(efx);
  fail2:
 	efx_remove_nic(efx);
@@ -1083,15 +1808,12 @@ static int efx_probe_all(struct efx_nic 
 	return rc;
 }
 
-/* Called after previous invocation(s) of efx_stop_all, restarts the
- * port, kernel transmit queue, NAPI processing and hardware interrupts,
- * and ensures that the port is scheduled to be reconfigured.
- * This function is safe to call multiple times when the NIC is in any
- * state. */
-static void efx_start_all(struct efx_nic *efx)
+/* Called after previous invocation(s) of efx_stop_all, restarts the port,
+ * kernel transmit queues and NAPI processing, and ensures that the port is
+ * scheduled to be reconfigured. This function is safe to call multiple
+ * times when the NIC is in any state. */
+void efx_start_all(struct efx_nic *efx)
 {
-	struct efx_channel *channel;
-
 	EFX_ASSERT_RESET_SERIALISED(efx);
 
 	/* Check that it is appropriate to restart the interface. All
@@ -1100,24 +1822,30 @@ static void efx_start_all(struct efx_nic
 		return;
 	if ((efx->state != STATE_RUNNING) && (efx->state != STATE_INIT))
 		return;
-	if (efx_dev_registered(efx) && !netif_running(efx->net_dev))
+	if (!netif_running(efx->net_dev))
 		return;
 
-	/* Mark the port as enabled so port reconfigurations can start, then
-	 * restart the transmit interface early so the watchdog timer stops */
 	efx_start_port(efx);
-	if (efx_dev_registered(efx))
-		efx_wake_queue(efx);
-
-	efx_for_each_channel(channel, efx)
-		efx_start_channel(channel);
-
-	falcon_enable_interrupts(efx);
-
-	/* Start hardware monitor if we're in RUNNING */
-	if (efx->state == STATE_RUNNING)
-		queue_delayed_work(efx->workqueue, &efx->monitor_work,
-				   efx_monitor_interval);
+	efx_start_datapath(efx);
+
+#ifdef __VMKLNX__
+	efx->net_dev->trans_start = jiffies;
+	efx->net_dev->watchdog_timeo = EFX_DEFAULT_WATCHDOG;
+#endif
+
+	/* Start the hardware monitor if there is one. Otherwise (we're link
+	 * event driven), we have to poll the PHY because after an event queue
+	 * flush we could have a missed a link state change */
+	if (efx->type->monitor != NULL) {
+		schedule_delayed_work(&efx->monitor_work, efx_monitor_interval);
+	} else {
+		mutex_lock(&efx->mac_lock);
+		if (efx->phy_op->poll(efx))
+			efx_link_status_changed(efx);
+		mutex_unlock(&efx->mac_lock);
+	}
+
+	efx->type->start_stats(efx);
 }
 
 /* Flush all delayed work. Should only be called when no more delayed work
@@ -1125,19 +1853,13 @@ static void efx_start_all(struct efx_nic
  * since we're holding the rtnl_lock at this point. */
 static void efx_flush_all(struct efx_nic *efx)
 {
-	struct efx_rx_queue *rx_queue;
-
-	/* Make sure the hardware monitor is stopped */
+	EFX_ASSERT_RESET_SERIALISED(efx);
+
+	/* Make sure the hardware monitor and event self-test are stopped */
 	cancel_delayed_work_sync(&efx->monitor_work);
-
-	/* Ensure that all RX slow refills are complete. */
-	efx_for_each_rx_queue(rx_queue, efx)
-		cancel_delayed_work_sync(&rx_queue->work);
-
+	efx_selftest_async_cancel(efx);
 	/* Stop scheduled port reconfigurations */
 	cancel_work_sync(&efx->mac_work);
-	cancel_work_sync(&efx->phy_work);
-
 }
 
 /* Quiesce hardware and software without bringing the link down.
@@ -1145,97 +1867,122 @@ static void efx_flush_all(struct efx_nic
  * state. The caller is guaranteed to subsequently be in a position
  * to modify any hardware and software state they see fit without
  * taking locks. */
-static void efx_stop_all(struct efx_nic *efx)
+void efx_stop_all(struct efx_nic *efx)
 {
-	struct efx_channel *channel;
-
 	EFX_ASSERT_RESET_SERIALISED(efx);
 
 	/* port_enabled can be read safely under the rtnl lock */
 	if (!efx->port_enabled)
 		return;
 
-	/* Disable interrupts and wait for ISR to complete */
-	falcon_disable_interrupts(efx);
-	if (efx->legacy_irq)
-		synchronize_irq(efx->legacy_irq);
-	efx_for_each_channel(channel, efx) {
-		if (channel->irq)
-			synchronize_irq(channel->irq);
+	efx->type->stop_stats(efx);
+	efx_stop_port(efx);
+
+	/* Flush efx_mac_work(), refill_workqueue and efx_monitor_work() */
+	efx_flush_all(efx);
+
+#ifdef __VMKLNX__
+	{
+		/* keep TX watchdog happy for the worst case flush time */
+		unsigned timeout = msecs_to_jiffies(EFX_MAX_FLUSH_TIME * 3 / 2);
+		if (efx->net_dev->watchdog_timeo < timeout)
+			efx->net_dev->watchdog_timeo = timeout;
+		efx->net_dev->trans_start = jiffies;
 	}
-
-	/* Stop all NAPI processing and synchronous rx refills */
-	efx_for_each_channel(channel, efx)
-		efx_stop_channel(channel);
-
-	/* Stop all asynchronous port reconfigurations. Since all
-	 * event processing has already been stopped, there is no
-	 * window to loose phy events */
-	efx_stop_port(efx);
-
-	/* Flush efx_phy_work, efx_mac_work, refill_workqueue, monitor_work */
-	efx_flush_all(efx);
-
-	/* Isolate the MAC from the TX and RX engines, so that queue
-	 * flushes will complete in a timely fashion. */
-	falcon_deconfigure_mac_wrapper(efx);
-	msleep(10); /* Let the Rx FIFO drain */
-	falcon_drain_tx_fifo(efx);
+#endif
 
 	/* Stop the kernel transmit interface late, so the watchdog
 	 * timer isn't ticking over the flush */
-	if (efx_dev_registered(efx)) {
-		efx_stop_queue(efx);
-		netif_tx_lock_bh(efx->net_dev);
-		netif_tx_unlock_bh(efx->net_dev);
-	}
+	netif_tx_disable(efx->net_dev);
+
+	efx_stop_datapath(efx);
 }
 
 static void efx_remove_all(struct efx_nic *efx)
 {
-	struct efx_channel *channel;
-
-	efx_for_each_channel(channel, efx)
-		efx_remove_channel(channel);
+	efx_remove_channels(efx);
+	efx_remove_filters(efx);
 	efx_remove_port(efx);
 	efx_remove_nic(efx);
 }
 
-/* A convinience function to safely flush all the queues */
-void efx_flush_queues(struct efx_nic *efx)
-{
-	EFX_ASSERT_RESET_SERIALISED(efx);
-
-	efx_stop_all(efx);
-
-	efx_fini_channels(efx);
-	efx_init_channels(efx);
-
-	efx_start_all(efx);
-}
-
 /**************************************************************************
  *
  * Interrupt moderation
  *
  **************************************************************************/
 
+static unsigned int irq_mod_ticks(unsigned int usecs, unsigned int quantum_ns)
+{
+	if (usecs == 0)
+		return 0;
+	if (usecs * 1000 < quantum_ns)
+		return 1; /* never round down to 0 */
+	return usecs * 1000 / quantum_ns;
+}
+
 /* Set interrupt moderation parameters */
-void efx_init_irq_moderation(struct efx_nic *efx, int tx_usecs, int rx_usecs,
-			     bool rx_adaptive)
+int efx_init_irq_moderation(struct efx_nic *efx, unsigned int tx_usecs,
+			    unsigned int rx_usecs, bool rx_adaptive,
+			    bool rx_may_override_tx)
 {
-	struct efx_tx_queue *tx_queue;
-	struct efx_rx_queue *rx_queue;
+	struct efx_channel *channel;
+	unsigned int irq_mod_max = DIV_ROUND_UP(efx->type->timer_period_max *
+						efx->timer_quantum_ns,
+						1000);
+	unsigned int tx_ticks;
+	unsigned int rx_ticks;
 
 	EFX_ASSERT_RESET_SERIALISED(efx);
 
-	efx_for_each_tx_queue(tx_queue, efx)
-		tx_queue->channel->irq_moderation = tx_usecs;
+	if (tx_usecs > irq_mod_max || rx_usecs > irq_mod_max)
+		return -EINVAL;
+
+	tx_ticks = irq_mod_ticks(tx_usecs, efx->timer_quantum_ns);
+	rx_ticks = irq_mod_ticks(rx_usecs, efx->timer_quantum_ns);
+
+	if (tx_ticks != rx_ticks && efx->tx_channel_offset == 0 &&
+	    !rx_may_override_tx) {
+		netif_err(efx, drv, efx->net_dev, "Channels are shared. "
+			  "RX and TX IRQ moderation must be equal\n");
+		return -EINVAL;
+	}
 
 	efx->irq_rx_adaptive = rx_adaptive;
-	efx->irq_rx_moderation = rx_usecs;
-	efx_for_each_rx_queue(rx_queue, efx)
-		rx_queue->channel->irq_moderation = rx_usecs;
+	efx->irq_rx_moderation = rx_ticks;
+	efx_for_each_channel(channel, efx) {
+		if (efx_channel_has_rx_queue(channel))
+			channel->irq_moderation = rx_ticks;
+		else if (efx_channel_has_tx_queues(channel))
+			channel->irq_moderation = tx_ticks;
+	}
+
+	return 0;
+}
+
+void efx_get_irq_moderation(struct efx_nic *efx, unsigned int *tx_usecs,
+			    unsigned int *rx_usecs, bool *rx_adaptive)
+{
+	/* We must round up when converting ticks to microseconds
+	 * because we round down when converting the other way.
+	 */
+
+	*rx_adaptive = efx->irq_rx_adaptive;
+	*rx_usecs = DIV_ROUND_UP(efx->irq_rx_moderation *
+				 efx->timer_quantum_ns,
+				 1000);
+
+	/* If channels are shared between RX and TX, so is IRQ
+	 * moderation.  Otherwise, IRQ moderation is the same for all
+	 * TX channels and is not adaptive.
+	 */
+	if (efx->tx_channel_offset == 0)
+		*tx_usecs = *rx_usecs;
+	else
+		*tx_usecs = DIV_ROUND_UP(
+			efx->channel[efx->tx_channel_offset]->irq_moderation *
+			efx->timer_quantum_ns,
+			1000);
 }
 
 /**************************************************************************
@@ -1244,39 +1991,26 @@ void efx_init_irq_moderation(struct efx_
  *
  **************************************************************************/
 
-/* Run periodically off the general workqueue. Serialised against
- * efx_reconfigure_port via the mac_lock */
+/* Run periodically off the general workqueue */
 static void efx_monitor(struct work_struct *data)
 {
 	struct efx_nic *efx = container_of(data, struct efx_nic,
 					   monitor_work.work);
-	int rc;
-
-	EFX_TRACE(efx, "hardware monitor executing on CPU %d\n",
-		  raw_smp_processor_id());
-
+
+	netif_vdbg(efx, timer, efx->net_dev,
+		   "hardware monitor executing on CPU %d\n",
+		   raw_smp_processor_id());
+	BUG_ON(efx->type->monitor == NULL);
 	/* If the mac_lock is already held then it is likely a port
 	 * reconfiguration is already in place, which will likely do
 	 * most of the work of check_hw() anyway. */
-	if (!mutex_trylock(&efx->mac_lock))
-		goto out_requeue;
-	if (!efx->port_enabled)
-		goto out_unlock;
-	rc = efx->board_info.monitor(efx);
-	if (rc) {
-		EFX_ERR(efx, "Board sensor %s; shutting down PHY\n",
-			(rc == -ERANGE) ? "reported fault" : "failed");
-		efx->phy_mode |= PHY_MODE_LOW_POWER;
-		falcon_sim_phy_event(efx);
+	if (mutex_trylock(&efx->mac_lock)) {
+		if (efx->port_enabled)
+			efx->type->monitor(efx);
+		mutex_unlock(&efx->mac_lock);
 	}
-	efx->phy_op->poll(efx);
-	efx->mac_op->poll(efx);
-
-out_unlock:
-	mutex_unlock(&efx->mac_lock);
-out_requeue:
-	queue_delayed_work(efx->workqueue, &efx->monitor_work,
-			   efx_monitor_interval);
+
+	schedule_delayed_work(&efx->monitor_work, efx_monitor_interval);
 }
 
 /**************************************************************************
@@ -1293,8 +2027,25 @@ static int efx_ioctl(struct net_device *
 	struct efx_nic *efx = netdev_priv(net_dev);
 	struct mii_ioctl_data *data = if_mii(ifr);
 
+	ASSERT_RTNL();
+
 	EFX_ASSERT_RESET_SERIALISED(efx);
 
+#if defined(SIOCSHWTSTAMP)
+	if (cmd == SIOCSHWTSTAMP)
+		return efx_ptp_ioctl(efx, ifr, cmd);
+#endif
+
+	if (cmd == SIOCEFX) {
+		struct efx_sock_ioctl __user *user_data =
+			(struct efx_sock_ioctl __user *)ifr->ifr_data;
+		u16 efx_cmd;
+
+		if (copy_from_user(&efx_cmd, &user_data->cmd, sizeof(efx_cmd)))
+			return -EFAULT;
+		return efx_private_ioctl(efx, efx_cmd, &user_data->u);
+	}
+
 	/* Convert phy_id from older PRTAD/DEVAD format */
 	if ((cmd == SIOCGMIIREG || cmd == SIOCSMIIREG) &&
 	    (data->phy_id & 0xfc00) == 0x0400)
@@ -1309,27 +2060,44 @@ static int efx_ioctl(struct net_device *
  *
  **************************************************************************/
 
+static int efx_init_napi_channel(struct efx_channel *channel)
+{
+	struct efx_nic *efx = channel->efx;
+
+	channel->napi_dev = efx->net_dev;
+	netif_napi_add(channel->napi_dev, &channel->napi_str,
+		       efx_poll, napi_weight);
+
+	return 0;
+}
+
 static int efx_init_napi(struct efx_nic *efx)
 {
 	struct efx_channel *channel;
+	int rc;
 
 	efx_for_each_channel(channel, efx) {
-		channel->napi_dev = efx->net_dev;
-		netif_napi_add(channel->napi_dev, &channel->napi_str,
-			       efx_poll, napi_weight);
+		rc = efx_init_napi_channel(channel);
+		if (rc)
+			return rc;
 	}
+
 	return 0;
 }
 
+static void efx_fini_napi_channel(struct efx_channel *channel)
+{
+	if (channel->napi_dev)
+		netif_napi_del(&channel->napi_str);
+	channel->napi_dev = NULL;
+}
+
 static void efx_fini_napi(struct efx_nic *efx)
 {
 	struct efx_channel *channel;
 
-	efx_for_each_channel(channel, efx) {
-		if (channel->napi_dev)
-			netif_napi_del(&channel->napi_str);
-		channel->napi_dev = NULL;
-	}
+	efx_for_each_channel(channel, efx)
+		efx_fini_napi_channel(channel);
 }
 
 /**************************************************************************
@@ -1367,15 +2135,24 @@ static int efx_net_open(struct net_devic
 	struct efx_nic *efx = netdev_priv(net_dev);
 	EFX_ASSERT_RESET_SERIALISED(efx);
 
-	EFX_LOG(efx, "opening device %s on CPU %d\n", net_dev->name,
-		raw_smp_processor_id());
-
-	if (efx->state == STATE_DISABLED)
+	netif_dbg(efx, ifup, efx->net_dev, "opening device on CPU %d\n",
+		  raw_smp_processor_id());
+
+	if (efx->state == STATE_DISABLED) {
+		netif_err(efx, ifup, efx->net_dev, "Device is disabled.\n");
 		return -EIO;
+	}
 	if (efx->phy_mode & PHY_MODE_SPECIAL)
 		return -EBUSY;
+	if (efx_mcdi_poll_reboot(efx) && efx_reset(efx, RESET_TYPE_ALL))
+		return -EIO;
+
+	/* Notify the kernel of the link state polled during driver load,
+	 * before the monitor starts running */
+	efx_link_status_changed(efx);
 
 	efx_start_all(efx);
+	efx_selftest_async_start(efx);
 	return 0;
 }
 
@@ -1386,62 +2163,38 @@ static int efx_net_open(struct net_devic
 static int efx_net_stop(struct net_device *net_dev)
 {
 	struct efx_nic *efx = netdev_priv(net_dev);
-
-	EFX_LOG(efx, "closing %s on CPU %d\n", net_dev->name,
-		raw_smp_processor_id());
+	ASSERT_RTNL();
+
+	netif_dbg(efx, ifdown, efx->net_dev, "closing on CPU %d\n",
+		  raw_smp_processor_id());
 
 	if (efx->state != STATE_DISABLED) {
 		/* Stop the device and flush all the channels */
 		efx_stop_all(efx);
-		efx_fini_channels(efx);
-		efx_init_channels(efx);
 	}
 
 	return 0;
 }
 
-void efx_stats_disable(struct efx_nic *efx)
-{
-	spin_lock(&efx->stats_lock);
-	++efx->stats_disable_count;
-	spin_unlock(&efx->stats_lock);
-}
-
-void efx_stats_enable(struct efx_nic *efx)
-{
-	spin_lock(&efx->stats_lock);
-	--efx->stats_disable_count;
-	spin_unlock(&efx->stats_lock);
-}
-
 /* Context: process, dev_base_lock or RTNL held, non-blocking. */
 static struct net_device_stats *efx_net_stats(struct net_device *net_dev)
 {
 	struct efx_nic *efx = netdev_priv(net_dev);
 	struct efx_mac_stats *mac_stats = &efx->mac_stats;
 	struct net_device_stats *stats = &net_dev->stats;
-
-	/* Update stats if possible, but do not wait if another thread
-	 * is updating them or if MAC stats fetches are temporarily
-	 * disabled; slightly stale stats are acceptable.
-	 */
-	if (!spin_trylock(&efx->stats_lock))
-		return stats;
-	if (!efx->stats_disable_count) {
-		efx->mac_op->update_stats(efx);
-		falcon_update_nic_stats(efx);
-	}
-	spin_unlock(&efx->stats_lock);
+	spin_lock_bh(&efx->stats_lock);
+
+	efx->type->update_stats(efx);
 
 	stats->rx_packets = mac_stats->rx_packets;
 	stats->tx_packets = mac_stats->tx_packets;
 	stats->rx_bytes = mac_stats->rx_bytes;
 	stats->tx_bytes = mac_stats->tx_bytes;
+	stats->rx_dropped = efx->n_rx_nodesc_drop_cnt;
 	stats->multicast = mac_stats->rx_multicast;
 	stats->collisions = mac_stats->tx_collision;
 	stats->rx_length_errors = (mac_stats->rx_gtjumbo +
 				   mac_stats->rx_length_error);
-	stats->rx_over_errors = efx->n_rx_nodesc_drop_cnt;
 	stats->rx_crc_errors = mac_stats->rx_bad;
 	stats->rx_frame_errors = mac_stats->rx_align_error;
 	stats->rx_fifo_errors = mac_stats->rx_overflow;
@@ -1449,15 +2202,14 @@ static struct net_device_stats *efx_net_
 	stats->tx_window_errors = mac_stats->tx_late_collision;
 
 	stats->rx_errors = (stats->rx_length_errors +
-			    stats->rx_over_errors +
 			    stats->rx_crc_errors +
 			    stats->rx_frame_errors +
-			    stats->rx_fifo_errors +
-			    stats->rx_missed_errors +
 			    mac_stats->rx_symbol_error);
 	stats->tx_errors = (stats->tx_window_errors +
 			    mac_stats->tx_bad);
 
+	spin_unlock_bh(&efx->stats_lock);
+
 	return stats;
 }
 
@@ -1466,9 +2218,9 @@ static void efx_watchdog(struct net_devi
 {
 	struct efx_nic *efx = netdev_priv(net_dev);
 
-	EFX_ERR(efx, "TX stuck with stop_count=%d port_enabled=%d:"
-		" resetting channels\n",
-		atomic_read(&efx->netif_stop_count), efx->port_enabled);
+	netif_err(efx, tx_err, efx->net_dev,
+		  "TX stuck with port_enabled=%d: resetting channels\n",
+		  efx->port_enabled);
 
 	efx_schedule_reset(efx, RESET_TYPE_TX_WATCHDOG);
 }
@@ -1478,92 +2230,85 @@ static void efx_watchdog(struct net_devi
 static int efx_change_mtu(struct net_device *net_dev, int new_mtu)
 {
 	struct efx_nic *efx = netdev_priv(net_dev);
-	int rc = 0;
 
 	EFX_ASSERT_RESET_SERIALISED(efx);
 
 	if (new_mtu > EFX_MAX_MTU)
 		return -EINVAL;
 
+	netif_dbg(efx, drv, efx->net_dev, "changing MTU to %d\n", new_mtu);
+
 	efx_stop_all(efx);
 
-	/* Ask driverlink client if we can change MTU */
-	rc = EFX_DL_CALLBACK(efx, request_mtu, new_mtu);
-	if (rc)
-		goto out;
-
-	EFX_LOG(efx, "changing MTU to %d\n", new_mtu);
-
-	efx_fini_channels(efx);
+	mutex_lock(&efx->mac_lock);
+	/* Reconfigure the MAC before enabling the dma queues so that
+	 * the RX buffers don't overflow */
 	net_dev->mtu = new_mtu;
-	efx_init_channels(efx);
-
-	/* Notify driverlink client of new MTU */
-	EFX_DL_CALLBACK(efx, mtu_changed, new_mtu);
-
- out:
+	efx->type->reconfigure_mac(efx);
+	mutex_unlock(&efx->mac_lock);
+
 	efx_start_all(efx);
-	return rc;
+	return 0;
 }
 
 static int efx_set_mac_address(struct net_device *net_dev, void *data)
 {
 	struct efx_nic *efx = netdev_priv(net_dev);
 	struct sockaddr *addr = data;
-	char *new_addr = addr->sa_data;
+	u8 *new_addr = addr->sa_data;
 
 	EFX_ASSERT_RESET_SERIALISED(efx);
 
 	if (!is_valid_ether_addr(new_addr)) {
-		EFX_ERR(efx, "invalid ethernet MAC address requested: %pM\n",
-			new_addr);
+		netif_err(efx, drv, efx->net_dev,
+			  "invalid ethernet MAC address requested: %pM\n",
+			  new_addr);
 		return -EINVAL;
 	}
 
 	memcpy(net_dev->dev_addr, new_addr, net_dev->addr_len);
+	efx_sriov_mac_address_changed(efx);
 
 	/* Reconfigure the MAC */
-	efx_reconfigure_port(efx);
+	mutex_lock(&efx->mac_lock);
+	efx->type->reconfigure_mac(efx);
+	mutex_unlock(&efx->mac_lock);
 
 	return 0;
 }
 
 /* Context: netif_addr_lock held, BHs disabled. */
-static void efx_set_multicast_list(struct net_device *net_dev)
+static void efx_set_rx_mode(struct net_device *net_dev)
 {
 	struct efx_nic *efx = netdev_priv(net_dev);
-	struct dev_mc_list *mc_list = net_dev->mc_list;
+	struct dev_mc_list *ha;
 	union efx_multicast_hash *mc_hash = &efx->multicast_hash;
-	bool promiscuous = !!(net_dev->flags & IFF_PROMISC);
-	bool changed = (efx->promiscuous != promiscuous);
 	u32 crc;
 	int bit;
-	int i;
-
-	efx->promiscuous = promiscuous;
+
+	efx->promiscuous = !!(net_dev->flags & IFF_PROMISC);
 
 	/* Build multicast hash table */
-	if (promiscuous || (net_dev->flags & IFF_ALLMULTI)) {
+	if (efx->promiscuous || (net_dev->flags & IFF_ALLMULTI)) {
 		memset(mc_hash, 0xff, sizeof(*mc_hash));
 	} else {
 		memset(mc_hash, 0x00, sizeof(*mc_hash));
-		for (i = 0; i < net_dev->mc_count; i++) {
-			crc = ether_crc_le(ETH_ALEN, mc_list->dmi_addr);
+		netdev_for_each_mc_addr(ha, net_dev) {
+			crc = ether_crc_le(ETH_ALEN, ha->dmi_addr);
 			bit = crc & (EFX_MCAST_HASH_ENTRIES - 1);
 			set_bit_le(bit, mc_hash->byte);
-			mc_list = mc_list->next;
 		}
+
+		/* Broadcast packets go through the multicast hash filter.
+		 * ether_crc_le() of the broadcast address is 0xbe2612ff
+		 * so we always add bit 0xff to the mask.
+		 */
+		set_bit_le(0xff, mc_hash->byte);
 	}
 
-	if (!efx->port_enabled)
-		/* Delay pushing settings until efx_start_port() */
-		return;
-
-	if (changed)
-		queue_work(efx->workqueue, &efx->phy_work);
-
-	/* Create and activate new global multicast hash table */
-	falcon_set_multicast_hash(efx);
+	if (efx->port_enabled)
+		schedule_work(&efx->mac_work);
+	/* Otherwise efx_start_port() will do this */
 }
 
 static const struct net_device_ops efx_netdev_ops = {
@@ -1576,10 +2321,18 @@ static const struct net_device_ops efx_n
 	.ndo_do_ioctl		= efx_ioctl,
 	.ndo_change_mtu		= efx_change_mtu,
 	.ndo_set_mac_address	= efx_set_mac_address,
-	.ndo_set_multicast_list = efx_set_multicast_list,
+	.ndo_set_multicast_list	= efx_set_rx_mode,
+#if defined(CONFIG_SFC_SRIOV) && (!defined(EFX_USE_KCOMPAT) || defined(EFX_HAVE_NDO_SET_VF_MAC))
+	.ndo_set_vf_mac		= efx_sriov_set_vf_mac,
+	.ndo_set_vf_vlan	= efx_sriov_set_vf_vlan,
+	.ndo_get_vf_config	= efx_sriov_get_vf_config,
+#endif
 #ifdef CONFIG_NET_POLL_CONTROLLER
 	.ndo_poll_controller = efx_netpoll,
 #endif
+#ifdef CONFIG_RFS_ACCEL
+	.ndo_rx_flow_steer	= efx_filter_rfs,
+#endif
 };
 
 static void efx_update_name(struct efx_nic *efx)
@@ -1589,14 +2342,24 @@ static void efx_update_name(struct efx_n
 	efx_set_channel_names(efx);
 }
 
+bool efx_dl_netdev_is_ours(const struct net_device *net_dev)
+{
+	return net_dev->netdev_ops == &efx_netdev_ops;
+}
+EXPORT_SYMBOL(efx_dl_netdev_is_ours);
+
 static int efx_netdev_event(struct notifier_block *this,
 			    unsigned long event, void *ptr)
 {
 	struct net_device *net_dev = ptr;
 
 	if (net_dev->netdev_ops == &efx_netdev_ops &&
-	    event == NETDEV_CHANGENAME)
-		efx_update_name(netdev_priv(net_dev));
+	    event == NETDEV_CHANGENAME) {
+		struct efx_nic *efx = netdev_priv(net_dev);
+
+		if (efx->state == STATE_RUNNING)
+			efx_update_name(efx);
+	}
 
 	return NOTIFY_DONE;
 }
@@ -1616,18 +2379,14 @@ static DEVICE_ATTR(phy_type, 0644, show_
 static int efx_register_netdev(struct efx_nic *efx)
 {
 	struct net_device *net_dev = efx->net_dev;
+	struct efx_channel *channel;
 	int rc;
 
-	net_dev->watchdog_timeo = 5 * HZ;
+	net_dev->watchdog_timeo = EFX_DEFAULT_WATCHDOG;
 	net_dev->irq = efx->pci_dev->irq;
 	net_dev->netdev_ops = &efx_netdev_ops;
-	SET_NETDEV_DEV(net_dev, &efx->pci_dev->dev);
 	SET_ETHTOOL_OPS(net_dev, &efx_ethtool_ops);
 
-	/* Clear MAC statistics */
-	efx->mac_op->update_stats(efx);
-	memset(&efx->mac_stats, 0, sizeof(efx->mac_stats));
-
 	rtnl_lock();
 
 	rc = dev_alloc_name(net_dev, net_dev->name);
@@ -1639,47 +2398,68 @@ static int efx_register_netdev(struct ef
 	if (rc)
 		goto fail_locked;
 
+	efx_for_each_channel(channel, efx) {
+		struct efx_tx_queue *tx_queue;
+		efx_for_each_channel_tx_queue(tx_queue, channel)
+			efx_init_tx_queue_core_txq(tx_queue);
+	}
+
 	/* Always start with carrier off; PHY events will detect the link */
-	netif_carrier_off(efx->net_dev);
+	netif_carrier_off(net_dev);
+
+	/* Register with driverlink layer */
+	efx_dl_register_nic(efx);
 
 	rtnl_unlock();
 
+	/* Create debugfs symlinks */
+	rc = efx_init_debugfs_netdev(net_dev);
+	if (rc) {
+		netif_err(efx, drv, efx->net_dev,
+			  "failed to init net dev debugfs\n");
+		goto fail_registered;
+	}
+
 	rc = device_create_file(&efx->pci_dev->dev, &dev_attr_phy_type);
 	if (rc) {
-		EFX_ERR(efx, "failed to init net dev attributes\n");
-		goto fail_registered;
+		netif_err(efx, drv, efx->net_dev,
+			  "failed to init net dev attributes\n");
+		goto fail_debugfs;
 	}
 
 	return 0;
 
+fail_debugfs:
+	efx_fini_debugfs_netdev(net_dev);
+fail_registered:
+	rtnl_lock();
+	efx_dl_unregister_nic(efx);
+	unregister_netdevice(net_dev);
 fail_locked:
 	rtnl_unlock();
-	EFX_ERR(efx, "could not register net dev\n");
-	return rc;
-
-fail_registered:
-	unregister_netdev(net_dev);
+	netif_err(efx, drv, efx->net_dev, "could not register net dev\n");
 	return rc;
 }
 
 static void efx_unregister_netdev(struct efx_nic *efx)
 {
+	struct efx_channel *channel;
 	struct efx_tx_queue *tx_queue;
 
-	if (!efx->net_dev)
-		return;
-
 	BUG_ON(netdev_priv(efx->net_dev) != efx);
 
 	/* Free up any skbs still remaining. This has to happen before
 	 * we try to unregister the netdev as running their destructors
 	 * may be needed to get the device ref. count to 0. */
-	efx_for_each_tx_queue(tx_queue, efx)
-		efx_release_tx_buffers(tx_queue);
+	efx_for_each_channel(channel, efx) {
+		efx_for_each_channel_tx_queue(tx_queue, channel)
+			efx_release_tx_buffers(tx_queue);
+	}
 
 	if (efx_dev_registered(efx)) {
 		strlcpy(efx->name, pci_name(efx->pci_dev), sizeof(efx->name));
 		device_remove_file(&efx->pci_dev->dev, &dev_attr_phy_type);
+		efx_fini_debugfs_netdev(efx->net_dev);
 		unregister_netdev(efx->net_dev);
 	}
 }
@@ -1689,43 +2469,20 @@ static void efx_unregister_netdev(struct
  * Device reset and suspend
  *
  **************************************************************************/
-#ifdef CONFIG_SFC_DRIVERLINK
-/* Serialise access to the driverlink callbacks, by quiescing event processing
- * (without flushing the descriptor queues), and acquiring the rtnl_lock */
-void efx_suspend(struct efx_nic *efx)
-{
-	EFX_LOG(efx, "suspending operations\n");
-
-	rtnl_lock();
-	efx_stop_all(efx);
-}
-
-void efx_resume(struct efx_nic *efx)
-{
-	EFX_LOG(efx, "resuming operations\n");
-
-	efx_start_all(efx);
-	rtnl_unlock();
-}
-#endif
-
-/* Tears down the entire software state and most of the hardware state
- * before reset.  */
-void efx_reset_down(struct efx_nic *efx, enum reset_type method,
-		    struct ethtool_cmd *ecmd)
+
+/* Tears down driverlink clients, the entire software state,
+ * and most of the hardware state before reset.  */
+void efx_reset_down(struct efx_nic *efx, enum reset_type method)
 {
 	EFX_ASSERT_RESET_SERIALISED(efx);
 
-	efx_stats_disable(efx);
 	efx_stop_all(efx);
 	mutex_lock(&efx->mac_lock);
-	mutex_lock(&efx->spi_lock);
-
-	efx->phy_op->get_settings(efx, ecmd);
-
-	efx_fini_channels(efx);
+
+	efx_stop_interrupts(efx, false);
 	if (efx->port_initialized && method != RESET_TYPE_INVISIBLE)
 		efx->phy_op->fini(efx);
+	efx->type->fini(efx);
 }
 
 /* This function will always ensure that the locks acquired in
@@ -1733,83 +2490,83 @@ void efx_reset_down(struct efx_nic *efx,
  * that we were unable to reinitialise the hardware, and the
  * driver should be disabled. If ok is false, then the rx and tx
  * engines are not restarted, pending a RESET_DISABLE. */
-int efx_reset_up(struct efx_nic *efx, enum reset_type method,
-		 struct ethtool_cmd *ecmd, bool ok)
+int efx_reset_up(struct efx_nic *efx, enum reset_type method, bool ok)
 {
 	int rc;
 
 	EFX_ASSERT_RESET_SERIALISED(efx);
 
-	rc = falcon_init_nic(efx);
+	/* Ensure that SRAM is initialised even if we're disabling the device */
+	rc = efx->type->init(efx);
 	if (rc) {
-		EFX_ERR(efx, "failed to initialise NIC\n");
-		ok = false;
+		netif_err(efx, drv, efx->net_dev, "failed to initialise NIC\n");
+		goto fail;
 	}
 
+	if (!ok)
+		goto fail;
+
 	if (efx->port_initialized && method != RESET_TYPE_INVISIBLE) {
-		if (ok) {
-			rc = efx->phy_op->init(efx);
-			if (rc)
-				ok = false;
-		}
-		if (!ok)
-			efx->port_initialized = false;
+		rc = efx->phy_op->init(efx);
+		if (rc)
+			goto fail;
+		if (efx->phy_op->reconfigure(efx))
+			netif_err(efx, drv, efx->net_dev,
+				  "could not restore PHY settings\n");
 	}
 
-	if (ok) {
-		efx_init_channels(efx);
-
-		if (efx->phy_op->set_settings(efx, ecmd))
-			EFX_ERR(efx, "could not restore PHY settings\n");
-	}
-
-	mutex_unlock(&efx->spi_lock);
+	efx->type->reconfigure_mac(efx);
+
+	efx_start_interrupts(efx, false);
+	efx_restore_filters(efx);
+	efx_sriov_reset(efx);
+
 	mutex_unlock(&efx->mac_lock);
 
-	if (ok) {
-		efx_start_all(efx);
-		efx_stats_enable(efx);
-	}
+	efx_start_all(efx);
+
+	return 0;
+
+fail:
+	efx->port_initialized = false;
+
+	mutex_unlock(&efx->mac_lock);
+
 	return rc;
 }
 
-/* Reset the NIC as transparently as possible. Do not reset the PHY
- * Note that the reset may fail, in which case the card will be left
- * in a most-probably-unusable state.
+/* Reset the NIC using the specified method.  Note that the reset may
+ * fail, in which case the card will be left in an unusable state.
  *
- * This function will sleep.  You cannot reset from within an atomic
- * state; use efx_schedule_reset() instead.
- *
- * Grabs the rtnl_lock.
+ * Caller must hold the rtnl_lock.
  */
-static int efx_reset(struct efx_nic *efx)
+int efx_reset(struct efx_nic *efx, enum reset_type method)
 {
-	struct ethtool_cmd ecmd;
-	enum reset_type method = efx->reset_pending;
-	int rc = 0;
-
-	rtnl_lock();
+	int rc, rc2;
+	bool disabled;
+
+	ASSERT_RTNL();
+
+	/* Notify driverlink clients of imminent reset then serialise
+	 * against other driver operations */
 	efx_dl_reset_suspend(efx);
 
-	/* If we're not RUNNING then don't reset. Leave the reset_pending
-	 * flag set so that efx_pci_probe_main will be retried */
-	if (efx->state != STATE_RUNNING) {
-		EFX_INFO(efx, "scheduled reset quenched. NIC not RUNNING\n");
-		goto out_unlock;
+	netif_info(efx, drv, efx->net_dev, "resetting (%s)\n",
+		   RESET_TYPE(method));
+
+	netif_device_detach(efx->net_dev);
+	efx_reset_down(efx, method);
+
+	rc = efx->type->reset(efx, method);
+	if (rc) {
+		netif_err(efx, drv, efx->net_dev, "failed to reset hardware\n");
+		goto out;
 	}
 
-	EFX_INFO(efx, "resetting (%d)\n", method);
-
-	efx_reset_down(efx, method, &ecmd);
-
-	rc = falcon_reset_hw(efx, method);
-	if (rc) {
-		EFX_ERR(efx, "failed to reset hardware\n");
-		goto out_disable;
-	}
-
-	/* Allow resets to be rescheduled. */
-	efx->reset_pending = RESET_TYPE_NONE;
+	/* Clear flags for the scopes we covered.  We assume the NIC and
+	 * driver are now quiescent so that there is no race here.
+	 */
+	efx->reset_pending &= -(1 << (method + 1));
 
 	/* Reinitialise bus-mastering, which may have been turned off before
 	 * the reset was scheduled. This is still appropriate, even in the
@@ -1817,26 +2574,25 @@ static int efx_reset(struct efx_nic *efx
 	 * can respond to requests. */
 	pci_set_master(efx->pci_dev);
 
+out:
 	/* Leave device stopped if necessary */
-	if (method == RESET_TYPE_DISABLE) {
-		efx_reset_up(efx, method, &ecmd, false);
-		rc = -EIO;
+	disabled = rc || method == RESET_TYPE_DISABLE;
+	rc2 = efx_reset_up(efx, method, !disabled);
+	if (rc2) {
+		disabled = true;
+		if (!rc)
+			rc = rc2;
+	}
+
+	if (disabled) {
+		dev_close(efx->net_dev);
+		netif_err(efx, drv, efx->net_dev, "has been disabled\n");
+		efx->state = STATE_DISABLED;
 	} else {
-		rc = efx_reset_up(efx, method, &ecmd, true);
+		netif_dbg(efx, drv, efx->net_dev, "reset complete\n");
+		netif_device_attach(efx->net_dev);
 	}
-
-out_disable:
-	if (rc) {
-		EFX_ERR(efx, "has been disabled\n");
-		efx->state = STATE_DISABLED;
-		dev_close(efx->net_dev);
-	} else {
-		EFX_LOG(efx, "reset complete\n");
-	}
-
-out_unlock:
-	efx_dl_reset_resume(efx, 1);
-	rtnl_unlock();
+	efx_dl_reset_resume(efx, !disabled);
 	return rc;
 }
 
@@ -1845,44 +2601,51 @@ out_unlock:
  */
 static void efx_reset_work(struct work_struct *data)
 {
-	struct efx_nic *nic = container_of(data, struct efx_nic, reset_work);
-
-	efx_reset(nic);
+	struct efx_nic *efx = container_of(data, struct efx_nic, reset_work);
+	unsigned long pending = ACCESS_ONCE(efx->reset_pending);
+
+	if (!pending)
+		return;
+
+	/* If we're not RUNNING then don't reset. Leave the reset_pending
+	 * flags set so that efx_pci_probe_main will be retried */
+	if (efx->state != STATE_RUNNING) {
+		netif_info(efx, drv, efx->net_dev,
+			   "scheduled reset quenched. NIC not RUNNING\n");
+		return;
+	}
+
+	rtnl_lock();
+	(void)efx_reset(efx, fls(pending) - 1);
+	rtnl_unlock();
 }
 
 void efx_schedule_reset(struct efx_nic *efx, enum reset_type type)
 {
 	enum reset_type method;
 
-	if (efx->reset_pending != RESET_TYPE_NONE) {
-		EFX_INFO(efx, "quenching already scheduled reset\n");
-		return;
-	}
-
 	switch (type) {
 	case RESET_TYPE_INVISIBLE:
 	case RESET_TYPE_ALL:
 	case RESET_TYPE_WORLD:
 	case RESET_TYPE_DISABLE:
 		method = type;
-		break;
-	case RESET_TYPE_RX_RECOVERY:
-	case RESET_TYPE_RX_DESC_FETCH:
-	case RESET_TYPE_TX_DESC_FETCH:
-	case RESET_TYPE_TX_SKIP:
-		method = RESET_TYPE_INVISIBLE;
+		netif_dbg(efx, drv, efx->net_dev, "scheduling %s reset\n",
+			  RESET_TYPE(method));
 		break;
 	default:
-		method = RESET_TYPE_ALL;
+		method = efx->type->map_reset_reason(type);
+		netif_dbg(efx, drv, efx->net_dev,
+			  "scheduling %s reset for %s\n",
+			  RESET_TYPE(method), RESET_TYPE(type));
 		break;
 	}
 
-	if (method != type)
-		EFX_LOG(efx, "scheduling reset (%d:%d)\n", type, method);
-	else
-		EFX_LOG(efx, "scheduling reset (%d)\n", method);
-
-	efx->reset_pending = method;
+	set_bit(method, &efx->reset_pending);
+
+	/* efx_process_channel() will no longer read events once a
+	 * reset is scheduled. So switch back to poll'd MCDI completions. */
+	efx_mcdi_mode_poll(efx);
 
 	queue_work(reset_workqueue, &efx->reset_work);
 }
@@ -1894,17 +2657,25 @@ void efx_schedule_reset(struct efx_nic *
  **************************************************************************/
 
 /* PCI device ID table */
-static struct pci_device_id efx_pci_table[] __devinitdata = {
-	{PCI_DEVICE(EFX_VENDID_SFC, FALCON_A_P_DEVID),
-	 .driver_data = (unsigned long) &falcon_a_nic_type},
-	{PCI_DEVICE(EFX_VENDID_SFC, FALCON_B_P_DEVID),
-	 .driver_data = (unsigned long) &falcon_b_nic_type},
+static DEFINE_PCI_DEVICE_TABLE(efx_pci_table) = {
+#ifndef __VMKERNEL_MODULE__
+	{PCI_DEVICE(PCI_VENDOR_ID_SOLARFLARE,
+		    PCI_DEVICE_ID_SOLARFLARE_SFC4000A_0),
+	 .driver_data = (unsigned long) &falcon_a1_nic_type},
+#endif
+	{PCI_DEVICE(PCI_VENDOR_ID_SOLARFLARE,
+		    PCI_DEVICE_ID_SOLARFLARE_SFC4000B),
+	 .driver_data = (unsigned long) &falcon_b0_nic_type},
+	{PCI_DEVICE(PCI_VENDOR_ID_SOLARFLARE, BETHPAGE_A_P_DEVID),
+	 .driver_data = (unsigned long) &siena_a0_nic_type},
+	{PCI_DEVICE(PCI_VENDOR_ID_SOLARFLARE, SIENA_A_P_DEVID),
+	 .driver_data = (unsigned long) &siena_a0_nic_type},
 	{0}			/* end of list */
 };
 
 /**************************************************************************
  *
- * Dummy PHY/MAC/Board operations
+ * Dummy PHY/MAC operations
  *
  * Can be used for some unimplemented operations
  * Needed so all function pointers are valid and do not have to be tested
@@ -1916,29 +2687,17 @@ int efx_port_dummy_op_int(struct efx_nic
 	return 0;
 }
 void efx_port_dummy_op_void(struct efx_nic *efx) {}
-void efx_port_dummy_op_blink(struct efx_nic *efx, bool blink) {}
-
-static struct efx_mac_operations efx_dummy_mac_operations = {
-	.reconfigure	= efx_port_dummy_op_void,
-	.poll		= efx_port_dummy_op_void,
-	.irq		= efx_port_dummy_op_void,
-};
-
-static struct efx_phy_operations efx_dummy_phy_operations = {
+
+static bool efx_port_dummy_op_poll(struct efx_nic *efx)
+{
+	return false;
+}
+
+static const struct efx_phy_operations efx_dummy_phy_operations = {
 	.init		 = efx_port_dummy_op_int,
-	.reconfigure	 = efx_port_dummy_op_void,
-	.poll		 = efx_port_dummy_op_void,
+	.reconfigure	 = efx_port_dummy_op_int,
+	.poll		 = efx_port_dummy_op_poll,
 	.fini		 = efx_port_dummy_op_void,
-	.clear_interrupt = efx_port_dummy_op_void,
-};
-
-static struct efx_board efx_dummy_board_info = {
-	.init		= efx_port_dummy_op_int,
-	.init_leds	= efx_port_dummy_op_void,
-	.set_id_led	= efx_port_dummy_op_blink,
-	.monitor	= efx_port_dummy_op_int,
-	.blink		= efx_port_dummy_op_blink,
-	.fini		= efx_port_dummy_op_void,
 };
 
 /**************************************************************************
@@ -1950,104 +2709,68 @@ static struct efx_board efx_dummy_board_
 /* This zeroes out and then fills in the invariants in a struct
  * efx_nic (including all sub-structures).
  */
-static int efx_init_struct(struct efx_nic *efx, struct efx_nic_type *type,
+static int efx_init_struct(struct efx_nic *efx, const struct efx_nic_type *type,
 			   struct pci_dev *pci_dev, struct net_device *net_dev)
 {
-	struct efx_channel *channel;
-	struct efx_tx_queue *tx_queue;
-	struct efx_rx_queue *rx_queue;
 	int i;
 
 	/* Initialise common structures */
 	memset(efx, 0, sizeof(*efx));
 	spin_lock_init(&efx->biu_lock);
-	spin_lock_init(&efx->phy_lock);
-	mutex_init(&efx->spi_lock);
+#ifdef CONFIG_SFC_MTD
+	INIT_LIST_HEAD(&efx->mtd_list);
+#endif
 	INIT_WORK(&efx->reset_work, efx_reset_work);
 	INIT_DELAYED_WORK(&efx->monitor_work, efx_monitor);
+	INIT_DELAYED_WORK(&efx->selftest_work, efx_selftest_async_work);
 	efx->pci_dev = pci_dev;
+	efx->msg_enable = debug;
 	efx->state = STATE_INIT;
-	efx->reset_pending = RESET_TYPE_NONE;
 	strlcpy(efx->name, pci_name(pci_dev), sizeof(efx->name));
-	efx->board_info = efx_dummy_board_info;
 
 	efx->net_dev = net_dev;
 	efx->rx_checksum_enabled = true;
-	spin_lock_init(&efx->netif_stop_lock);
+#if defined(EFX_USE_KCOMPAT) && defined(EFX_USE_SFC_LRO) && !defined(NETIF_F_LRO)
+	efx->lro_enabled = lro;
+#endif
+	efx->rx_buffer_hash_size = type->rx_buffer_hash_size;
 	spin_lock_init(&efx->stats_lock);
-	efx->stats_disable_count = 1;
 	mutex_init(&efx->mac_lock);
-	efx->mac_op = &efx_dummy_mac_operations;
 	efx->phy_op = &efx_dummy_phy_operations;
 	efx->mdio.dev = net_dev;
-#ifdef CONFIG_SFC_DRIVERLINK
 	INIT_LIST_HEAD(&efx->dl_node);
 	INIT_LIST_HEAD(&efx->dl_device_list);
-	efx->dl_cb = efx_default_callbacks;
-#endif
-	INIT_WORK(&efx->phy_work, efx_phy_work);
 	INIT_WORK(&efx->mac_work, efx_mac_work);
-	atomic_set(&efx->netif_stop_count, 1);
+	init_waitqueue_head(&efx->flush_wq);
 
 	for (i = 0; i < EFX_MAX_CHANNELS; i++) {
-		channel = &efx->channel[i];
-		channel->efx = efx;
-		channel->channel = i;
-		channel->work_pending = false;
+		/* TODO: NUMA affinity */
+		efx->channel[i] = efx_alloc_channel(efx, i, NULL);
+		if (!efx->channel[i])
+			goto fail;
 	}
-	for (i = 0; i < EFX_TX_QUEUE_COUNT; i++) {
-		tx_queue = &efx->tx_queue[i];
-		tx_queue->efx = efx;
-		tx_queue->queue = i;
-		tx_queue->buffer = NULL;
-		tx_queue->channel = &efx->channel[0]; /* for safety */
-		tx_queue->tso_headers_free = NULL;
-	}
-	for (i = 0; i < EFX_MAX_RX_QUEUES; i++) {
-		rx_queue = &efx->rx_queue[i];
-		rx_queue->efx = efx;
-		rx_queue->queue = i;
-		rx_queue->channel = &efx->channel[0]; /* for safety */
-		rx_queue->buffer = NULL;
-		spin_lock_init(&rx_queue->add_lock);
-		INIT_DELAYED_WORK(&rx_queue->work, efx_rx_work);
-	}
 
 	efx->type = type;
 
-	/* Sanity-check NIC type */
-	EFX_BUG_ON_PARANOID(efx->type->txd_ring_mask &
-			    (efx->type->txd_ring_mask + 1));
-	EFX_BUG_ON_PARANOID(efx->type->rxd_ring_mask &
-			    (efx->type->rxd_ring_mask + 1));
-	EFX_BUG_ON_PARANOID(efx->type->evq_size &
-			    (efx->type->evq_size - 1));
-	/* As close as we can get to guaranteeing that we don't overflow */
-	EFX_BUG_ON_PARANOID(efx->type->evq_size <
-			    (efx->type->txd_ring_mask + 1 +
-			     efx->type->rxd_ring_mask + 1));
 	EFX_BUG_ON_PARANOID(efx->type->phys_addr_channels > EFX_MAX_CHANNELS);
 
 	/* Higher numbered interrupt modes are less capable! */
 	efx->interrupt_mode = max(efx->type->max_interrupt_mode,
 				  interrupt_mode);
 
-	/* Would be good to use the net_dev name, but we're too early */
-	snprintf(efx->workqueue_name, sizeof(efx->workqueue_name), "sfc%s",
-		 pci_name(pci_dev));
-	efx->workqueue = create_singlethread_workqueue(efx->workqueue_name);
-	if (!efx->workqueue)
-		return -ENOMEM;
-
 	return 0;
+
+fail:
+	efx_fini_struct(efx);
+	return -ENOMEM;
 }
 
 static void efx_fini_struct(struct efx_nic *efx)
 {
-	if (efx->workqueue) {
-		destroy_workqueue(efx->workqueue);
-		efx->workqueue = NULL;
-	}
+	int i;
+
+	for (i = 0; i < EFX_MAX_CHANNELS; i++)
+		kfree(efx->channel[i]);
 }
 
 /**************************************************************************
@@ -2056,24 +2779,156 @@ static void efx_fini_struct(struct efx_n
  *
  **************************************************************************/
 
+/*
+ * VPD access through PCI 2.2+ VPD capability, roughly based on the
+ * implementation present in Linux 2.6.26+.
+ *
+ * We could access VPD through our own NVRAM interfaces, but on Siena
+ * the firmware merges VPD from two sources and it seems like a waste
+ * of effort to duplicate that here.
+ */
+
+#if defined(EFX_USE_KCOMPAT) && \
+	(defined(EFX_NEED_PCI_VPD_ATTR) || defined(EFX_NEED_PCI_READ_VPD))
+#define PCI_VPD_PCI22_SIZE (PCI_VPD_ADDR_MASK + 1)
+
+struct pci_vpd_pci22 {
+	struct mutex lock;
+	u16	flag;
+	bool	busy;
+	u8	cap;
+};
+
+/*
+ * Wait for last operation to complete.
+ * This code has to spin since there is no notification.
+ */
+static int pci_vpd_pci22_wait(struct pci_dev *dev)
+{
+	struct efx_nic *efx = pci_get_drvdata(dev);
+	struct pci_vpd_pci22 *vpd = efx->vpd;
+	unsigned long timeout = jiffies + HZ/20 + 2;
+	u16 status;
+	int ret;
+
+	if (!vpd->busy)
+		return 0;
+
+	for (;;) {
+		ret = pci_read_config_word(dev, vpd->cap + PCI_VPD_ADDR,
+					   &status);
+		if (ret)
+			return ret;
+
+		if ((status & PCI_VPD_ADDR_F) == vpd->flag) {
+			vpd->busy = false;
+			return 0;
+		}
+
+		if (time_after(jiffies, timeout))
+			return -ETIMEDOUT;
+		if (signal_pending(current))
+			return -EINTR;
+		cond_resched();
+	}
+}
+#endif
+
+#if defined(EFX_USE_KCOMPAT) && \
+	(defined(EFX_NEED_PCI_VPD_ATTR) || defined(EFX_NEED_PCI_READ_VPD))
+static void efx_pci_vpd_probe(struct efx_nic *efx)
+{
+	struct pci_dev *dev = efx->pci_dev;
+	struct pci_vpd_pci22 *vpd;
+	u8 cap;
+
+	cap = pci_find_capability(dev, PCI_CAP_ID_VPD);
+	if (!cap)
+		return;
+	vpd = kzalloc(sizeof(*vpd), GFP_ATOMIC);
+	if (!vpd)
+		return;
+
+	mutex_init(&vpd->lock);
+	vpd->cap = cap;
+	vpd->busy = false;
+
+	efx->vpd = vpd;
+}
+
+static void efx_pci_vpd_remove(struct efx_nic *efx)
+{
+	if (efx->vpd) {
+		kfree(efx->vpd);
+	}
+}
+#endif
+
+/* NIC VPD information
+ * Called during probe to display the serial/part numbers of the
+ * installed NICs, It is expeted that the required will be at the start
+ */
+#define SFC_VPD_LEN	512
+static void efx_print_product_vpd(struct efx_nic *efx)
+{
+	struct pci_dev *dev = efx->pci_dev;
+	char vpd_data[SFC_VPD_LEN];
+	int vpd_size;
+	int i, j;
+
+	/* Get the vpd data from the device */
+	vpd_size = pci_read_vpd(dev, 0, sizeof(vpd_data), vpd_data);
+
+	if (vpd_size <= 0) {
+		netif_err(efx, drv, efx->net_dev, "Unable to read VPD\n");
+		return;
+	}
+
+	/* Get the Read only section */
+	i = pci_vpd_find_tag(vpd_data, 0, vpd_size,
+				       PCI_VPD_LRDT_RO_DATA);
+
+	if (i < 0) {
+		netif_err(efx, drv, efx->net_dev, "VPD Read-only not found\n");
+		return;
+	}
+
+	j = pci_vpd_lrdt_size(&vpd_data[i]);
+	i += PCI_VPD_LRDT_TAG_SIZE;
+	if (i + j > vpd_size)
+		j = vpd_size - i;
+
+	/* Get the Part number */
+	i = pci_vpd_find_info_keyword(vpd_data, i, j, "PN");
+	if (i < 0) {
+		netif_err(efx, drv, efx->net_dev, "Part number not found\n");
+		return;
+	}
+
+	j = pci_vpd_info_field_size(&vpd_data[i]);
+	i += PCI_VPD_INFO_FLD_HDR_SIZE;
+	if (i + j > vpd_size) {
+		netif_err(efx, drv, efx->net_dev, "Incomplete part number\n");
+		return;
+	}
+
+	netif_info(efx, drv, efx->net_dev,
+		   "Part Number : %.*s\n", j, &vpd_data[i]);
+}
+
 /* Main body of final NIC shutdown code
  * This is called only at module unload (or hotplug removal).
  */
 static void efx_pci_remove_main(struct efx_nic *efx)
 {
-	EFX_ASSERT_RESET_SERIALISED(efx);
-
-	/* Skip everything if we never obtained a valid membase */
-	if (!efx->membase)
-		return;
-
-	efx_fini_channels(efx);
+#ifdef CONFIG_RFS_ACCEL
+	free_irq_cpu_rmap(efx->net_dev->rx_cpu_rmap);
+	efx->net_dev->rx_cpu_rmap = NULL;
+#endif
+	efx_stop_interrupts(efx, false);
+	efx_nic_fini_interrupt(efx);
 	efx_fini_port(efx);
-
-	/* Shutdown the board, then the NIC and board state */
-	efx->board_info.fini(efx);
-	falcon_fini_interrupt(efx);
-
+	efx->type->fini(efx);
 	efx_fini_napi(efx);
 	efx_remove_all(efx);
 }
@@ -2088,22 +2943,26 @@ static void efx_pci_remove(struct pci_de
 	efx = pci_get_drvdata(pci_dev);
 	if (!efx)
 		return;
-	efx_dl_unregister_nic(efx);
 
 	/* Mark the NIC as fini, then stop the interface */
 	rtnl_lock();
+	efx_dl_unregister_nic(efx);
 	efx->state = STATE_FINI;
 	dev_close(efx->net_dev);
 
 	/* Allow any queued efx_resets() to complete */
 	rtnl_unlock();
 
-	if (efx->membase == NULL)
-		goto out;
-
+	efx_stop_interrupts(efx, false);
+	efx_sriov_fini(efx);
 	efx_unregister_netdev(efx);
 
 	efx_mtd_remove(efx);
+#if defined(EFX_USE_KCOMPAT) && \
+	(defined(EFX_NEED_PCI_VPD_ATTR) || defined(EFX_NEED_PCI_READ_VPD))
+	efx_pci_vpd_remove(efx);
+#endif
+	efx_fini_debugfs_channels(efx);
 
 	/* Wait for any scheduled resets to complete. No more will be
 	 * scheduled from this point because efx_stop_all() has been
@@ -2113,9 +2972,8 @@ static void efx_pci_remove(struct pci_de
 
 	efx_pci_remove_main(efx);
 
-out:
 	efx_fini_io(efx);
-	EFX_LOG(efx, "shutdown successful\n");
+	netif_dbg(efx, drv, efx->net_dev, "shutdown successful\n");
 
 	pci_set_drvdata(pci_dev, NULL);
 	efx_fini_struct(efx);
@@ -2138,39 +2996,31 @@ static int efx_pci_probe_main(struct efx
 	if (rc)
 		goto fail2;
 
-	/* Initialise the board */
-	rc = efx->board_info.init(efx);
+	rc = efx->type->init(efx);
 	if (rc) {
-		EFX_ERR(efx, "failed to initialise board\n");
+		netif_err(efx, probe, efx->net_dev,
+			  "failed to initialise NIC\n");
 		goto fail3;
 	}
 
-	rc = falcon_init_nic(efx);
+	rc = efx_init_port(efx);
 	if (rc) {
-		EFX_ERR(efx, "failed to initialise NIC\n");
+		netif_err(efx, probe, efx->net_dev,
+			  "failed to initialise port\n");
 		goto fail4;
 	}
 
-	rc = efx_init_port(efx);
-	if (rc) {
-		EFX_ERR(efx, "failed to initialise port\n");
+	rc = efx_nic_init_interrupt(efx);
+	if (rc)
 		goto fail5;
-	}
-
-	efx_init_channels(efx);
-
-	rc = falcon_init_interrupt(efx);
-	if (rc)
-		goto fail6;
+	efx_start_interrupts(efx, false);
 
 	return 0;
 
- fail6:
-	efx_fini_channels(efx);
+ fail5:
 	efx_fini_port(efx);
- fail5:
  fail4:
-	efx->board_info.fini(efx);
+	efx->type->fini(efx);
  fail3:
 	efx_fini_napi(efx);
  fail2:
@@ -2182,7 +3032,7 @@ static int efx_pci_probe_main(struct efx
 /* NIC initialisation
  *
  * This is called at module load (or hotplug insertion,
- * theoretically).  It sets up PCI mappings, tests and resets the NIC,
+ * theoretically).  It sets up PCI mappings, resets the NIC,
  * sets up and registers the network devices with the kernel and hooks
  * the interrupt service routine.  It does not prepare the device for
  * transmission; this is left to the first time one of the network
@@ -2191,28 +3041,43 @@ static int efx_pci_probe_main(struct efx
 static int __devinit efx_pci_probe(struct pci_dev *pci_dev,
 				   const struct pci_device_id *entry)
 {
-	struct efx_nic_type *type = (struct efx_nic_type *) entry->driver_data;
+	const struct efx_nic_type *type = (const struct efx_nic_type *) entry->driver_data;
 	struct net_device *net_dev;
 	struct efx_nic *efx;
 	int i, rc;
 
 	/* Allocate and initialise a struct net_device and struct efx_nic */
-	net_dev = alloc_etherdev(sizeof(*efx));
+	net_dev = alloc_etherdev_mq(sizeof(*efx), EFX_MAX_CORE_TX_QUEUES);
 	if (!net_dev)
 		return -ENOMEM;
-	net_dev->features |= (NETIF_F_IP_CSUM | NETIF_F_SG |
+	net_dev->features |= (type->offload_features | NETIF_F_SG |
 			      NETIF_F_HIGHDMA | NETIF_F_TSO |
-			      NETIF_F_GRO);
+			      NETIF_F_RXCSUM);
+	if (type->offload_features & NETIF_F_V6_CSUM)
+		net_dev->features |= NETIF_F_TSO6;
+	if (lro)
+		net_dev->features |= NETIF_F_GRO;
 	/* Mask for features that also apply to VLAN devices */
 	net_dev->vlan_features |= (NETIF_F_ALL_CSUM | NETIF_F_SG |
-				   NETIF_F_HIGHDMA | NETIF_F_TSO);
+				   NETIF_F_HIGHDMA | NETIF_F_ALL_TSO |
+				   NETIF_F_RXCSUM);
 	efx = netdev_priv(net_dev);
 	pci_set_drvdata(pci_dev, efx);
+	SET_NETDEV_DEV(net_dev, &pci_dev->dev);
 	rc = efx_init_struct(efx, type, pci_dev, net_dev);
 	if (rc)
 		goto fail1;
 
-	EFX_INFO(efx, "Solarflare Communications NIC detected\n");
+	netif_info(efx, probe, efx->net_dev,
+		   "Solarflare NIC detected PCI(%x:%x)\n",
+		   pci_dev->vendor, pci_dev->device);
+
+#if defined(EFX_USE_KCOMPAT) && \
+	(defined(EFX_NEED_PCI_VPD_ATTR) || defined(EFX_NEED_PCI_READ_VPD))
+	efx_pci_vpd_probe(efx); /* allowed to fail */
+#endif
+
+	efx_print_product_vpd(efx);
 
 	/* Set up basic I/O (BAR mappings etc) */
 	rc = efx_init_io(efx);
@@ -2231,7 +3096,7 @@ static int __devinit efx_pci_probe(struc
 		cancel_work_sync(&efx->reset_work);
 
 		if (rc == 0) {
-			if (efx->reset_pending != RESET_TYPE_NONE) {
+			if (efx->reset_pending) {
 				/* If there was a scheduled reset during
 				 * probe, the NIC is probably hosed anyway */
 				efx_pci_remove_main(efx);
@@ -2242,39 +3107,66 @@ static int __devinit efx_pci_probe(struc
 		}
 
 		/* Retry if a recoverably reset event has been scheduled */
-		if ((efx->reset_pending != RESET_TYPE_INVISIBLE) &&
-		    (efx->reset_pending != RESET_TYPE_ALL))
+		if (efx->reset_pending &
+		    ~(1 << RESET_TYPE_INVISIBLE | 1 << RESET_TYPE_ALL) ||
+		    !efx->reset_pending) {
+			if (efx->reset_pending)
+				netif_err(efx, probe, efx->net_dev,
+					  "Unrecoverable scheduled reset: %s\n",
+					  RESET_TYPE(fls(efx->reset_pending) - 1));
 			goto fail3;
-
-		efx->reset_pending = RESET_TYPE_NONE;
+		}
+
+		efx->reset_pending = 0;
 	}
 
 	if (rc) {
-		EFX_ERR(efx, "Could not reset NIC\n");
+		netif_err(efx, probe, efx->net_dev,
+			  "Initialisation failed due to persistent reset\n");
 		goto fail4;
 	}
 
-	/* Switch to the running state before we expose the device to
-	 * the OS.  This is to ensure that the initial gathering of
-	 * MAC stats succeeds. */
+	rc = efx_init_debugfs_channels(efx);
+	if (rc)
+		goto fail5;
+
+	/* Switch to the running state before we expose the device to the OS,
+	 * so that dev_open()|efx_start_all() will actually start the device */
 	efx->state = STATE_RUNNING;
 
-	efx_mtd_probe(efx); /* allowed to fail */
-
 	rc = efx_register_netdev(efx);
 	if (rc)
-		goto fail5;
-
-	/* Register with driverlink layer */
-	rc = efx_dl_register_nic(efx);
+		goto fail6;
+
+	if (efx->vf_count) {
+		rc = efx_sriov_init(efx);
+		if (rc) {
+			netif_err(efx, probe, efx->net_dev,
+				  "SR-IOV can't be enabled rc %d\n", rc);
+			efx->vf_count = 0;
+		}
+	}
+
+	netif_info(efx, probe, efx->net_dev,
+		   "is Solarflare NIC PCI(%x:%x)\n",
+		   pci_dev->vendor, pci_dev->device);
+
+	/* Try to create MTDs, but allow this to fail */
+	rtnl_lock();
+	rc = efx_mtd_probe(efx);
+	rtnl_unlock();
+	if (rc == -EBUSY)
+		netif_warn(efx, probe, efx->net_dev,
+			   "kernel MTD table is full; flash will not be acccessible\n");
+	else
 	if (rc)
-		goto fail6;
-
-	EFX_LOG(efx, "initialisation successful\n");
+		netif_warn(efx, probe, efx->net_dev,
+			   "failed to create MTDs (%d)\n", rc);
+
 	return 0;
 
  fail6:
-	efx_unregister_netdev(efx);
+	efx_fini_debugfs_channels(efx);
  fail5:
 	efx_pci_remove_main(efx);
  fail4:
@@ -2283,16 +3175,128 @@ static int __devinit efx_pci_probe(struc
  fail2:
 	efx_fini_struct(efx);
  fail1:
-	EFX_LOG(efx, "initialisation failed. rc=%d\n", rc);
+	WARN_ON(rc > 0);
+	netif_dbg(efx, drv, efx->net_dev, "initialisation failed. rc=%d\n", rc);
 	free_netdev(net_dev);
 	return rc;
 }
 
+static int efx_pm_freeze(struct device *dev)
+{
+	struct efx_nic *efx = pci_get_drvdata(to_pci_dev(dev));
+
+	rtnl_lock();
+	efx_dl_reset_suspend(efx);
+	rtnl_unlock();
+
+	efx->state = STATE_FINI;
+
+	netif_device_detach(efx->net_dev);
+
+	efx_stop_all(efx);
+	efx_stop_interrupts(efx, false);
+
+	return 0;
+}
+
+static int efx_pm_thaw(struct device *dev)
+{
+	struct efx_nic *efx = pci_get_drvdata(to_pci_dev(dev));
+
+	efx->state = STATE_INIT;
+
+	efx_start_interrupts(efx, false);
+
+	mutex_lock(&efx->mac_lock);
+	efx->phy_op->reconfigure(efx);
+	mutex_unlock(&efx->mac_lock);
+
+	efx_start_all(efx);
+
+	netif_device_attach(efx->net_dev);
+
+	efx->state = STATE_RUNNING;
+
+	rtnl_lock();
+	efx_dl_reset_resume(efx, true);
+	rtnl_unlock();
+
+	efx->type->resume_wol(efx);
+
+	/* Reschedule any quenched resets scheduled during efx_pm_freeze() */
+	queue_work(reset_workqueue, &efx->reset_work);
+
+	return 0;
+}
+
+static int efx_pm_poweroff(struct device *dev)
+{
+	struct pci_dev *pci_dev = to_pci_dev(dev);
+	struct efx_nic *efx = pci_get_drvdata(pci_dev);
+
+	efx->type->fini(efx);
+
+	efx->reset_pending = 0;
+
+	pci_save_state(pci_dev);
+	return pci_set_power_state(pci_dev, PCI_D3hot);
+}
+
+/* Used for both resume and restore */
+static int efx_pm_resume(struct device *dev)
+{
+	struct pci_dev *pci_dev = to_pci_dev(dev);
+	struct efx_nic *efx = pci_get_drvdata(pci_dev);
+	int rc;
+
+	rc = pci_set_power_state(pci_dev, PCI_D0);
+	if (rc)
+		goto fail;
+	pci_restore_state(pci_dev);
+	rc = pci_enable_device(pci_dev);
+	if (rc)
+		goto fail;
+	pci_set_master(efx->pci_dev);
+	rc = efx->type->reset(efx, RESET_TYPE_ALL);
+	if (rc)
+		goto fail;
+	rc = efx->type->init(efx);
+	if (rc)
+		goto fail;
+	efx_pm_thaw(dev);
+	return 0;
+
+fail:
+	efx_dl_reset_resume(efx, false);
+	return rc;
+}
+
+static int efx_pm_suspend(struct device *dev)
+{
+	int rc;
+
+	efx_pm_freeze(dev);
+	rc = efx_pm_poweroff(dev);
+	if (rc)
+		efx_pm_resume(dev);
+	return rc;
+}
+
+static struct dev_pm_ops efx_pm_ops = {
+	.suspend	= efx_pm_suspend,
+	.resume		= efx_pm_resume,
+	.freeze		= efx_pm_freeze,
+	.thaw		= efx_pm_thaw,
+	.poweroff	= efx_pm_poweroff,
+	.restore	= efx_pm_resume,
+};
+
 static struct pci_driver efx_pci_driver = {
-	.name		= EFX_DRIVER_NAME,
+	.name		= KBUILD_MODNAME,
 	.id_table	= efx_pci_table,
 	.probe		= efx_pci_probe,
 	.remove		= efx_pci_remove,
+	.driver.pm	= &efx_pm_ops,
 };
 
 /**************************************************************************
@@ -2311,15 +3315,18 @@ static int __init efx_init_module(void)
 
 	printk(KERN_INFO "Solarflare NET driver v" EFX_DRIVER_VERSION "\n");
 
+	rc = efx_init_debugfs();
+	if (rc)
+		goto err_debugfs;
+
 	rc = register_netdevice_notifier(&efx_netdev_notifier);
 	if (rc)
 		goto err_notifier;
 
-	refill_workqueue = create_workqueue("sfc_refill");
-	if (!refill_workqueue) {
-		rc = -ENOMEM;
-		goto err_refill;
-	}
+	rc = efx_init_sriov();
+	if (rc)
+		goto err_sriov;
+
 	reset_workqueue = create_singlethread_workqueue("sfc_reset");
 	if (!reset_workqueue) {
 		rc = -ENOMEM;
@@ -2335,10 +3342,12 @@ static int __init efx_init_module(void)
  err_pci:
 	destroy_workqueue(reset_workqueue);
  err_reset:
-	destroy_workqueue(refill_workqueue);
- err_refill:
+	efx_fini_sriov();
+ err_sriov:
 	unregister_netdevice_notifier(&efx_netdev_notifier);
  err_notifier:
+	efx_fini_debugfs();
+ err_debugfs:
 	return rc;
 }
 
@@ -2348,16 +3357,18 @@ static void __exit efx_exit_module(void)
 
 	pci_unregister_driver(&efx_pci_driver);
 	destroy_workqueue(reset_workqueue);
-	destroy_workqueue(refill_workqueue);
+	efx_fini_sriov();
 	unregister_netdevice_notifier(&efx_netdev_notifier);
+	efx_fini_debugfs();
 
 }
 
 module_init(efx_init_module);
 module_exit(efx_exit_module);
 
-MODULE_AUTHOR("Michael Brown <mbrown@fensystems.co.uk> and "
-	      "Solarflare Communications");
-MODULE_DESCRIPTION("Solarflare Communications network driver");
+MODULE_AUTHOR("Solarflare Communications and "
+	      "Michael Brown <mbrown@fensystems.co.uk>");
+MODULE_DESCRIPTION("Solarflare network driver");
 MODULE_LICENSE("GPL");
 MODULE_DEVICE_TABLE(pci, efx_pci_table);
+MODULE_VERSION(EFX_DRIVER_VERSION);
diff -r 9566a4a50a43 drivers/net/sfc/efx.h
--- a/drivers/net/sfc/efx.h
+++ b/drivers/net/sfc/efx.h
@@ -1,7 +1,7 @@
 /****************************************************************************
  * Driver for Solarflare Solarstorm network controllers and boards
  * Copyright 2005-2006 Fen Systems Ltd.
- * Copyright 2006-2008 Solarflare Communications Inc.
+ * Copyright 2006-2010 Solarflare Communications Inc.
  *
  * This program is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 as published
@@ -12,55 +12,146 @@
 #define EFX_EFX_H
 
 #include "net_driver.h"
+#include "filter.h"
 
 /* PCI IDs */
-#define EFX_VENDID_SFC	        0x1924
-#define FALCON_A_P_DEVID	0x0703
-#define FALCON_A_S_DEVID        0x6703
-#define FALCON_B_P_DEVID        0x0710
+#define BETHPAGE_A_P_DEVID      0x0803
+#define SIENA_A_P_DEVID         0x0813
+
+/* Solarstorm controllers use BAR 0 for I/O space and BAR 2(&3) for memory */
+#define EFX_MEM_BAR 2
 
 /* TX */
-extern netdev_tx_t efx_xmit(struct efx_nic *efx,
-				  struct efx_tx_queue *tx_queue,
-				  struct sk_buff *skb);
-extern void efx_stop_queue(struct efx_nic *efx);
-extern void efx_wake_queue(struct efx_nic *efx);
+extern int efx_probe_tx_queue(struct efx_tx_queue *tx_queue);
+extern void efx_remove_tx_queue(struct efx_tx_queue *tx_queue);
+extern void efx_init_tx_queue(struct efx_tx_queue *tx_queue);
+extern void efx_init_tx_queue_core_txq(struct efx_tx_queue *tx_queue);
+extern void efx_fini_tx_queue(struct efx_tx_queue *tx_queue);
+extern void efx_release_tx_buffers(struct efx_tx_queue *tx_queue);
+extern netdev_tx_t
+efx_hard_start_xmit(struct sk_buff *skb, struct net_device *net_dev);
+extern netdev_tx_t
+efx_enqueue_skb(struct efx_tx_queue *tx_queue, struct sk_buff *skb);
+extern void efx_xmit_done(struct efx_tx_queue *tx_queue, unsigned int index);
 
 /* RX */
-extern void efx_xmit_done(struct efx_tx_queue *tx_queue, unsigned int index);
+extern int efx_probe_rx_queue(struct efx_rx_queue *rx_queue);
+extern void efx_remove_rx_queue(struct efx_rx_queue *rx_queue);
+extern void efx_init_rx_queue(struct efx_rx_queue *rx_queue);
+extern void efx_fini_rx_queue(struct efx_rx_queue *rx_queue);
+extern void efx_rx_strategy(struct efx_channel *channel);
+extern void efx_fast_push_rx_descriptors(struct efx_rx_queue *rx_queue);
+extern void efx_rx_slow_fill(unsigned long context);
+extern void __efx_rx_packet(struct efx_channel *channel,
+			    struct efx_rx_buffer *rx_buf);
 extern void efx_rx_packet(struct efx_rx_queue *rx_queue, unsigned int index,
-			  unsigned int len, bool checksummed, bool discard);
-extern void efx_schedule_slow_fill(struct efx_rx_queue *rx_queue, int delay);
+			  unsigned int len, u16 flags);
+extern void efx_schedule_slow_fill(struct efx_rx_queue *rx_queue);
+
+#define EFX_MAX_DMAQ_SIZE 4096UL
+#define EFX_DEFAULT_DMAQ_SIZE 1024UL
+#define EFX_MIN_DMAQ_SIZE 512UL
+
+#define EFX_MAX_EVQ_SIZE 16384UL
+#define EFX_MIN_EVQ_SIZE 512UL
+
+/* The smallest [rt]xq_entries that the driver supports. Callers of
+ * efx_wake_queue() assume that they can subsequently send at least one
+ * skb. Falcon/A1 may require up to three descriptors per skb_frag. */
+#define EFX_MIN_RING_SIZE (roundup_pow_of_two(2 * 3 * MAX_SKB_FRAGS))
+
+/* Filters */
+extern int efx_probe_filters(struct efx_nic *efx);
+extern void efx_restore_filters(struct efx_nic *efx);
+extern void efx_remove_filters(struct efx_nic *efx);
+extern s32 efx_filter_insert_filter(struct efx_nic *efx,
+				    struct efx_filter_spec *spec,
+				    bool replace);
+extern int efx_filter_remove_filter(struct efx_nic *efx,
+				    struct efx_filter_spec *spec);
+extern int efx_filter_remove_id_safe(struct efx_nic *efx,
+				     enum efx_filter_priority priority,
+				     u32 filter_id);
+extern int efx_filter_get_filter_safe(struct efx_nic *efx,
+				      enum efx_filter_priority priority,
+				      u32 filter_id, struct efx_filter_spec *);
+extern void efx_filter_clear_rx(struct efx_nic *efx,
+				enum efx_filter_priority priority);
+extern void efx_filter_redirect_id(struct efx_nic *efx,
+				   u32 filter_id, int rxq_i);
+extern u32 efx_filter_count_rx_used(struct efx_nic *efx,
+				    enum efx_filter_priority priority);
+extern u32 efx_filter_get_rx_id_limit(struct efx_nic *efx);
+extern s32 efx_filter_get_rx_ids(struct efx_nic *efx,
+				 enum efx_filter_priority priority,
+				 u32 *buf, u32 size);
+#ifdef CONFIG_RFS_ACCEL
+extern int efx_filter_rfs(struct net_device *net_dev, const struct sk_buff *skb,
+			  u16 rxq_index, u32 flow_id);
+extern bool __efx_filter_rfs_expire(struct efx_nic *efx, unsigned quota);
+static inline void efx_filter_rfs_expire(struct efx_channel *channel)
+{
+	if (channel->rfs_filters_added >= 60 &&
+	    __efx_filter_rfs_expire(channel->efx, 100))
+		channel->rfs_filters_added -= 60;
+}
+#define efx_filter_rfs_enabled() 1
+#else
+static inline void efx_filter_rfs_expire(struct efx_channel *channel) {}
+#define efx_filter_rfs_enabled() 0
+#endif
 
 /* Channels */
+extern int efx_channel_dummy_op_int(struct efx_channel *channel);
+extern void efx_channel_dummy_op_void(struct efx_channel *channel);
 extern void efx_process_channel_now(struct efx_channel *channel);
-extern void efx_flush_queues(struct efx_nic *efx);
+extern int
+efx_realloc_channels(struct efx_nic *efx, u32 rxq_entries, u32 txq_entries);
+
+#ifdef __VMKLNX__
+extern void rx_set_num_qs_per_nic(struct efx_nic *efx);
+#endif
 
 /* Ports */
-extern void efx_stats_disable(struct efx_nic *efx);
-extern void efx_stats_enable(struct efx_nic *efx);
-extern void efx_reconfigure_port(struct efx_nic *efx);
-extern void __efx_reconfigure_port(struct efx_nic *efx);
+extern int efx_reconfigure_port(struct efx_nic *efx);
+extern int __efx_reconfigure_port(struct efx_nic *efx);
+
+/* Ethtool support */
+extern int efx_ethtool_reset(struct net_device *net_dev, u32 *flags);
+extern int efx_ethtool_get_rxnfc(struct net_device *net_dev,
+				 struct efx_ethtool_rxnfc *info, u32 *rules);
+extern int efx_ethtool_set_rxnfc(struct net_device *net_dev,
+				 struct efx_ethtool_rxnfc *info);
+#if defined(EFX_USE_KCOMPAT) && !defined(EFX_HAVE_ETHTOOL_RXFH_INDIR)
+extern int efx_ethtool_old_get_rxfh_indir(struct net_device *net_dev,
+					  struct ethtool_rxfh_indir *indir);
+extern int efx_ethtool_old_set_rxfh_indir(struct net_device *net_dev,
+					  const struct ethtool_rxfh_indir *indir);
+#endif
+
+extern const struct ethtool_ops efx_ethtool_ops;
 
 /* Reset handling */
-extern void efx_reset_down(struct efx_nic *efx, enum reset_type method,
-			   struct ethtool_cmd *ecmd);
-extern int efx_reset_up(struct efx_nic *efx, enum reset_type method,
-			struct ethtool_cmd *ecmd, bool ok);
+extern int efx_reset(struct efx_nic *efx, enum reset_type method);
+extern void efx_reset_down(struct efx_nic *efx, enum reset_type method);
+extern int efx_reset_up(struct efx_nic *efx, enum reset_type method, bool ok);
 
 /* Global */
 extern void efx_schedule_reset(struct efx_nic *efx, enum reset_type type);
-extern void efx_suspend(struct efx_nic *efx);
-extern void efx_resume(struct efx_nic *efx);
-extern void efx_init_irq_moderation(struct efx_nic *efx, int tx_usecs,
-				    int rx_usecs, bool rx_adaptive);
-extern int efx_request_power(struct efx_nic *efx, int mw, const char *name);
-extern void efx_hex_dump(const u8 *, unsigned int, const char *);
+extern void efx_start_all(struct efx_nic *efx);
+extern void efx_stop_all(struct efx_nic *efx);
+extern int efx_init_irq_moderation(struct efx_nic *efx, unsigned int tx_usecs,
+				   unsigned int rx_usecs, bool rx_adaptive,
+				   bool rx_may_override_tx);
+extern void efx_get_irq_moderation(struct efx_nic *efx, unsigned int *tx_usecs,
+				   unsigned int *rx_usecs, bool *rx_adaptive);
+extern void efx_stop_eventq(struct efx_channel *channel);
+extern void efx_start_eventq(struct efx_channel *channel);
 
 /* Dummy PHY ops for PHY drivers */
 extern int efx_port_dummy_op_int(struct efx_nic *efx);
 extern void efx_port_dummy_op_void(struct efx_nic *efx);
-extern void efx_port_dummy_op_blink(struct efx_nic *efx, bool blink);
+
 
 /* MTD */
 #ifdef CONFIG_SFC_MTD
@@ -73,15 +164,24 @@ static inline void efx_mtd_rename(struct
 static inline void efx_mtd_remove(struct efx_nic *efx) {}
 #endif
 
-extern unsigned int efx_monitor_interval;
-
 static inline void efx_schedule_channel(struct efx_channel *channel)
 {
-	EFX_TRACE(channel->efx, "channel %d scheduling NAPI poll on CPU%d\n",
-		  channel->channel, raw_smp_processor_id());
+	netif_vdbg(channel->efx, intr, channel->efx->net_dev,
+		   "channel %d scheduling NAPI poll on CPU%d\n",
+		   channel->channel, raw_smp_processor_id());
 	channel->work_pending = true;
 
 	napi_schedule(&channel->napi_str);
 }
 
+static inline void efx_schedule_channel_irq(struct efx_channel *channel)
+{
+	channel->event_test_cpu = raw_smp_processor_id();
+	efx_schedule_channel(channel);
+}
+
+extern void efx_link_status_changed(struct efx_nic *efx);
+extern void efx_link_set_advertising(struct efx_nic *efx, u32);
+extern void efx_link_set_wanted_fc(struct efx_nic *efx, enum efx_fc_type);
+
 #endif /* EFX_EFX_H */
diff -r 9566a4a50a43 drivers/net/sfc/efx_ioctl.h
--- /dev/null
+++ b/drivers/net/sfc/efx_ioctl.h
@@ -0,0 +1,232 @@
+/****************************************************************************
+ * Driver for Solarflare network controllers
+ *           (including support for SFE4001 10GBT NIC)
+ *
+ * Copyright 2005-2006: Fen Systems Ltd.
+ * Copyright 2006-2010: Solarflare Communications Inc,
+ *                      9501 Jeronimo Road, Suite 250,
+ *                      Irvine, CA 92618, USA
+ *
+ * Initially developed by Michael Brown <mbrown@fensystems.co.uk>
+ * Maintained by Solarflare Communications <linux-net-drivers@solarflare.com>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 as published
+ * by the Free Software Foundation, incorporated herein by reference.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ ****************************************************************************
+ */
+
+#ifndef EFX_IOCTL_H
+#define EFX_IOCTL_H
+
+#if defined(__KERNEL__)
+#include <linux/if.h>
+#include <linux/types.h>
+#else
+#include <net/if.h>
+#ifndef _LINUX_IF_H
+#define _LINUX_IF_H /* prevent <linux/if.h> from conflicting with <net/if.h> */
+#endif
+#include "efx_linux_types.h"
+#endif
+#include <linux/if_ether.h>
+#include <linux/sockios.h>
+#include <linux/ethtool.h>
+
+/* Efx private ioctl number */
+/* We do not use the first 3 private ioctls because some utilities expect
+ * them to be the old MDIO ioctls. */
+#define SIOCEFX (SIOCDEVPRIVATE + 3)
+
+/*
+ * Efx private ioctls
+ */
+
+/* For talking MCDI to siena ************************************************/
+#define EFX_MCDI_REQUEST 0xef0c
+struct efx_mcdi_request {
+	__u32 payload[63];
+	__u8 cmd;
+	__u8 len; /* In and out */
+	__u8 rc;
+};
+
+/* Reset selected components, like ETHTOOL_RESET ****************************/
+#define EFX_RESET_FLAGS 0xef0d
+struct efx_reset_flags {
+	__u32 flags;
+};
+#ifndef ETH_RESET_SHARED_SHIFT
+	enum ethtool_reset_flags {
+		/* These flags represent components dedicated to the interface
+		 * the command is addressed to.  Shift any flag left by
+		 * ETH_RESET_SHARED_SHIFT to reset a shared component of the
+		 * same type.
+		 */
+	  	ETH_RESET_MGMT		= 1 << 0,	/* Management processor */
+		ETH_RESET_IRQ		= 1 << 1,	/* Interrupt requester */
+		ETH_RESET_DMA		= 1 << 2,	/* DMA engine */
+		ETH_RESET_FILTER	= 1 << 3,	/* Filtering/flow direction */
+		ETH_RESET_OFFLOAD	= 1 << 4,	/* Protocol offload */
+		ETH_RESET_MAC		= 1 << 5,	/* Media access controller */
+		ETH_RESET_PHY		= 1 << 6,	/* Transceiver/PHY */
+		ETH_RESET_RAM		= 1 << 7,	/* RAM shared between
+							 * multiple components */
+
+		ETH_RESET_DEDICATED	= 0x0000ffff,	/* All components dedicated to
+							 * this interface */
+		ETH_RESET_ALL		= 0xffffffff,	/* All components used by this
+							 * interface, even if shared */
+	};
+	#define ETH_RESET_SHARED_SHIFT	16
+#endif
+#ifndef ETHTOOL_RESET
+	#define ETHTOOL_RESET           0x00000034
+#endif
+
+/* Get RX flow hashing capabilities, like ETHTOOL_GRX{RINGS,FH} *************/
+#define EFX_RXNFC 0xef0e
+#ifndef ETHTOOL_GRXFH
+	#define ETHTOOL_GRXFH		0x00000029
+#endif
+#ifndef ETHTOOL_GRXRINGS
+	#define ETHTOOL_GRXRINGS	0x0000002d
+#endif
+#ifndef ETHTOOL_GRXCLSRULE
+	struct ethtool_tcpip4_spec {
+		__be32	ip4src;
+		__be32	ip4dst;
+		__be16	psrc;
+		__be16	pdst;
+		__u8    tos;
+	};
+	#define RX_CLS_FLOW_DISC	0xffffffffffffffffULL
+	#define ETHTOOL_GRXCLSRLCNT	0x0000002e
+	#define ETHTOOL_GRXCLSRULE	0x0000002f
+	#define ETHTOOL_GRXCLSRLALL	0x00000030
+	#define ETHTOOL_SRXCLSRLDEL     0x00000031
+	#define ETHTOOL_SRXCLSRLINS	0x00000032
+#endif
+#ifndef EFX_HAVE_EFX_ETHTOOL_RXNFC
+	union efx_ethtool_flow_union {
+		struct ethtool_tcpip4_spec		tcp_ip4_spec;
+		struct ethtool_tcpip4_spec		udp_ip4_spec;
+		struct ethtool_tcpip4_spec		sctp_ip4_spec;
+		struct ethhdr				ether_spec;
+		/* unneeded members omitted... */
+		__u8					hdata[60];
+	};
+	struct efx_ethtool_flow_ext {
+		__be16	vlan_etype;
+		__be16	vlan_tci;
+		__be32	data[2];
+	};
+	struct efx_ethtool_rx_flow_spec {
+		__u32		flow_type;
+		union efx_ethtool_flow_union h_u;
+		struct efx_ethtool_flow_ext h_ext;
+		union efx_ethtool_flow_union m_u;
+		struct efx_ethtool_flow_ext m_ext;
+		__u64		ring_cookie;
+		__u32		location;
+	};
+	struct efx_ethtool_rxnfc {
+		__u32				cmd;
+		__u32				flow_type;
+		__u64				data;
+		struct efx_ethtool_rx_flow_spec	fs;
+		__u32				rule_cnt;
+		__u32				rule_locs[0];
+	};
+	#define EFX_HAVE_EFX_ETHTOOL_RXNFC yes
+#endif
+#ifndef RX_CLS_LOC_SPECIAL
+	#define RX_CLS_LOC_SPECIAL	0x80000000
+	#define RX_CLS_LOC_ANY		0xffffffff
+	#define RX_CLS_LOC_FIRST	0xfffffffe
+	#define RX_CLS_LOC_LAST		0xfffffffd
+#endif
+
+/* Get/set RX flow hash indirection table, like ETHTOOL_{G,S}RXFHINDIR} *****/
+#define EFX_RXFHINDIR 0xef10
+#ifndef ETHTOOL_GRXFHINDIR
+	struct ethtool_rxfh_indir {
+		__u32	cmd;
+		/* On entry, this is the array size of the user buffer.  On
+		 * return from ETHTOOL_GRXFHINDIR, this is the array size of
+		 * the hardware indirection table. */
+		__u32	size;
+		__u32	ring_index[0];	/* ring/queue index for each hash value */
+	};
+	#define ETHTOOL_GRXFHINDIR	0x00000038
+	#define ETHTOOL_SRXFHINDIR	0x00000039
+#endif
+struct efx_rxfh_indir {
+	struct ethtool_rxfh_indir head;
+	__u32 table[128];
+};
+
+/* PTP support for NIC time disciplining ************************************/
+
+struct efx_timespec {
+	__s64	tv_sec;
+	__s32	tv_nsec;
+};
+
+/* Set the NIC time clock offset ********************************************/
+#define EFX_TS_SETTIME 0xef14
+struct efx_ts_settime {
+	struct efx_timespec ts;	/* In and out */
+	__u32 iswrite;		/* 1 == write, 0 == read (only) */
+};
+
+/* Adjust the NIC time frequency ********************************************/
+#define EFX_TS_ADJTIME 0xef15
+struct efx_ts_adjtime {
+	__s64 adjustment;	/* Parts per billion, In and out */
+	__u32 iswrite;		/* 1 == write, 0 == read (only) */
+};
+
+/* Get the NIC-system time skew *********************************************/
+#define EFX_TS_SYNC 0xef16
+struct efx_ts_sync {
+	struct efx_timespec ts;
+};
+
+/* Next available cmd number is 0xef17 */
+
+/* Efx private ioctl command structures *************************************/
+
+union efx_ioctl_data {
+	struct efx_mcdi_request mcdi_request;
+	struct efx_reset_flags reset_flags;
+	struct efx_ethtool_rxnfc rxnfc;
+	struct efx_rxfh_indir rxfh_indir;
+	struct efx_ts_settime ts_settime;
+	struct efx_ts_adjtime ts_adjtime;
+	struct efx_ts_sync ts_sync;
+};
+
+struct efx_sock_ioctl {
+	/* Command to run */
+	__u16 cmd;
+	__u16 reserved;
+	/* Parameters */
+	union efx_ioctl_data u;
+} __attribute__ ((packed));
+
+#ifdef __KERNEL__
+extern int efx_private_ioctl(struct efx_nic *efx, u16 cmd,
+			     union efx_ioctl_data __user *data);
+#endif
+
+#endif /* EFX_IOCTL_H */
diff -r 9566a4a50a43 drivers/net/sfc/efx_linux_types.h
--- /dev/null
+++ b/drivers/net/sfc/efx_linux_types.h
@@ -0,0 +1,38 @@
+/**************************************************************************/
+/*!  \file  efx_linux_types.h
+** \author  bwh
+**  \brief  Wrapper for <linux/types.h>
+**   \date  2008/12/11
+**    \cop  Copyright 2008 Solarflare Communications Inc.
+*//************************************************************************/
+
+#ifndef EFX_LINUX_TYPES_H
+#define EFX_LINUX_TYPES_H
+
+#include <linux/types.h>
+#include <linux/version.h>
+
+/* Although we don't support kernel versions before 2.6.9, the kernel
+ * headers for userland may come from a rather older version (as they
+ * do in RHEL 4).
+ */
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,9)
+typedef __u16 __be16;
+typedef __u32 __be32;
+typedef __u64 __be64;
+#endif
+
+/* Prior to Linux 2.6.18, some kernel headers wrongly used the
+ * in-kernel type names for user API.  Also, sfctool really wants
+ * these names.
+ */
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,18) || \
+  defined(EFX_WANT_KERNEL_TYPES)
+typedef __u8 u8;
+typedef __u16 u16;
+typedef __u32 u32;
+typedef __s32 s32;
+typedef __u64 u64;
+#endif
+
+#endif /* !EFX_LINUX_TYPES_H */
diff -r 9566a4a50a43 drivers/net/sfc/enum.h
--- a/drivers/net/sfc/enum.h
+++ b/drivers/net/sfc/enum.h
@@ -1,6 +1,6 @@
 /****************************************************************************
  * Driver for Solarflare Solarstorm network controllers and boards
- * Copyright 2007-2008 Solarflare Communications Inc.
+ * Copyright 2007-2009 Solarflare Communications Inc.
  *
  * This program is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 as published
@@ -13,44 +13,101 @@
 /**
  * enum efx_loopback_mode - loopback modes
  * @LOOPBACK_NONE: no loopback
- * @LOOPBACK_GMAC: loopback within GMAC at unspecified level
- * @LOOPBACK_XGMII: loopback within XMAC at XGMII level
- * @LOOPBACK_XGXS: loopback within XMAC at XGXS level
- * @LOOPBACK_XAUI: loopback within XMAC at XAUI level
+ * @LOOPBACK_DATA: data path loopback
+ * @LOOPBACK_GMAC: loopback within GMAC
+ * @LOOPBACK_XGMII: loopback after XMAC
+ * @LOOPBACK_XGXS: loopback within BPX after XGXS
+ * @LOOPBACK_XAUI: loopback within BPX before XAUI serdes
+ * @LOOPBACK_GMII: loopback within BPX after GMAC
+ * @LOOPBACK_SGMII: loopback within BPX within SGMII
+ * @LOOPBACK_XGBR: loopback within BPX within XGBR
+ * @LOOPBACK_XFI: loopback within BPX before XFI serdes
+ * @LOOPBACK_XAUI_FAR: loopback within BPX after XAUI serdes
+ * @LOOPBACK_GMII_FAR: loopback within BPX before SGMII
+ * @LOOPBACK_SGMII_FAR: loopback within BPX after SGMII
+ * @LOOPBACK_XFI_FAR: loopback after XFI serdes
  * @LOOPBACK_GPHY: loopback within 1G PHY at unspecified level
  * @LOOPBACK_PHYXS: loopback within 10G PHY at PHYXS level
  * @LOOPBACK_PCS: loopback within 10G PHY at PCS level
  * @LOOPBACK_PMAPMD: loopback within 10G PHY at PMAPMD level
- * @LOOPBACK_NETWORK: reflecting loopback (even further than furthest!)
+ * @LOOPBACK_XPORT: cross port loopback
+ * @LOOPBACK_XGMII_WS: wireside loopback excluding XMAC
+ * @LOOPBACK_XAUI_WS: wireside loopback within BPX within XAUI serdes
+ * @LOOPBACK_XAUI_WS_FAR: wireside loopback within BPX including XAUI serdes
+ * @LOOPBACK_XAUI_WS_NEAR: wireside loopback within BPX excluding XAUI serdes
+ * @LOOPBACK_GMII_WS: wireside loopback excluding GMAC
+ * @LOOPBACK_XFI_WS: wireside loopback excluding XFI serdes
+ * @LOOPBACK_XFI_WS_FAR: wireside loopback including XFI serdes
+ * @LOOPBACK_PHYXS_WS: wireside loopback within 10G PHY at PHYXS level
  */
-/* Please keep in order and up-to-date w.r.t the following two #defines */
+/* Please keep up-to-date w.r.t the following two #defines */
 enum efx_loopback_mode {
 	LOOPBACK_NONE = 0,
-	LOOPBACK_GMAC = 1,
-	LOOPBACK_XGMII = 2,
-	LOOPBACK_XGXS = 3,
-	LOOPBACK_XAUI = 4,
-	LOOPBACK_GPHY = 5,
-	LOOPBACK_PHYXS = 6,
-	LOOPBACK_PCS = 7,
-	LOOPBACK_PMAPMD = 8,
-	LOOPBACK_NETWORK = 9,
+	LOOPBACK_DATA = 1,
+	LOOPBACK_GMAC = 2,
+	LOOPBACK_XGMII = 3,
+	LOOPBACK_XGXS = 4,
+	LOOPBACK_XAUI = 5,
+	LOOPBACK_GMII = 6,
+	LOOPBACK_SGMII = 7,
+	LOOPBACK_XGBR = 8,
+	LOOPBACK_XFI = 9,
+	LOOPBACK_XAUI_FAR = 10,
+	LOOPBACK_GMII_FAR = 11,
+	LOOPBACK_SGMII_FAR = 12,
+	LOOPBACK_XFI_FAR = 13,
+	LOOPBACK_GPHY = 14,
+	LOOPBACK_PHYXS = 15,
+	LOOPBACK_PCS = 16,
+	LOOPBACK_PMAPMD = 17,
+	LOOPBACK_XPORT = 18,
+	LOOPBACK_XGMII_WS = 19,
+	LOOPBACK_XAUI_WS = 20,
+	LOOPBACK_XAUI_WS_FAR = 21,
+	LOOPBACK_XAUI_WS_NEAR = 22,
+	LOOPBACK_GMII_WS = 23,
+	LOOPBACK_XFI_WS = 24,
+	LOOPBACK_XFI_WS_FAR = 25,
+	LOOPBACK_PHYXS_WS = 26,
 	LOOPBACK_MAX
 };
-
 #define LOOPBACK_TEST_MAX LOOPBACK_PMAPMD
 
-extern const char *efx_loopback_mode_names[];
-#define LOOPBACK_MODE_NAME(mode)			\
-	STRING_TABLE_LOOKUP(mode, efx_loopback_mode)
-#define LOOPBACK_MODE(efx)				\
-	LOOPBACK_MODE_NAME(efx->loopback_mode)
+/* These loopbacks occur within the controller */
+#define LOOPBACKS_INTERNAL ((1 << LOOPBACK_DATA) |		\
+			    (1 << LOOPBACK_GMAC) |		\
+			    (1 << LOOPBACK_XGMII)|		\
+			    (1 << LOOPBACK_XGXS) |		\
+			    (1 << LOOPBACK_XAUI) |		\
+			    (1 << LOOPBACK_GMII) |		\
+			    (1 << LOOPBACK_SGMII) |		\
+			    (1 << LOOPBACK_SGMII) |		\
+			    (1 << LOOPBACK_XGBR) |		\
+			    (1 << LOOPBACK_XFI) |		\
+			    (1 << LOOPBACK_XAUI_FAR) |		\
+			    (1 << LOOPBACK_GMII_FAR) |		\
+			    (1 << LOOPBACK_SGMII_FAR) |		\
+			    (1 << LOOPBACK_XFI_FAR) |		\
+			    (1 << LOOPBACK_XGMII_WS) |		\
+			    (1 << LOOPBACK_XAUI_WS) |		\
+			    (1 << LOOPBACK_XAUI_WS_FAR) |	\
+			    (1 << LOOPBACK_XAUI_WS_NEAR) |	\
+			    (1 << LOOPBACK_GMII_WS) |		\
+			    (1 << LOOPBACK_XFI_WS) |		\
+			    (1 << LOOPBACK_XFI_WS_FAR))
 
-/* These loopbacks occur within the controller */
-#define LOOPBACKS_INTERNAL ((1 << LOOPBACK_GMAC) |     \
-			    (1 << LOOPBACK_XGMII)|     \
-			    (1 << LOOPBACK_XGXS) |     \
-			    (1 << LOOPBACK_XAUI))
+#define LOOPBACKS_WS ((1 << LOOPBACK_XGMII_WS) |		\
+		      (1 << LOOPBACK_XAUI_WS) |			\
+		      (1 << LOOPBACK_XAUI_WS_FAR) |		\
+		      (1 << LOOPBACK_XAUI_WS_NEAR) |		\
+		      (1 << LOOPBACK_GMII_WS) |			\
+		      (1 << LOOPBACK_XFI_WS) |			\
+		      (1 << LOOPBACK_XFI_WS_FAR) |		\
+		      (1 << LOOPBACK_PHYXS_WS))
+
+#define LOOPBACKS_EXTERNAL(_efx)					\
+	((_efx)->loopback_modes & ~LOOPBACKS_INTERNAL &			\
+	 ~(1 << LOOPBACK_NONE))
 
 #define LOOPBACK_MASK(_efx)			\
 	(1 << (_efx)->loopback_mode)
@@ -58,6 +115,9 @@ extern const char *efx_loopback_mode_nam
 #define LOOPBACK_INTERNAL(_efx)				\
 	(!!(LOOPBACKS_INTERNAL & LOOPBACK_MASK(_efx)))
 
+#define LOOPBACK_EXTERNAL(_efx)				\
+	(!!(LOOPBACK_MASK(_efx) & LOOPBACKS_EXTERNAL(_efx)))
+
 #define LOOPBACK_CHANGED(_from, _to, _mask)				\
 	(!!((LOOPBACK_MASK(_from) ^ LOOPBACK_MASK(_to)) & (_mask)))
 
@@ -74,6 +134,8 @@ extern const char *efx_loopback_mode_nam
  * other valuesspecify reasons, which efx_schedule_reset() will choose
  * a method for.
  *
+ * Reset methods are numbered in order of increasing scope.
+ *
  * @RESET_TYPE_INVISIBLE: don't reset the PHYs or interrupts
  * @RESET_TYPE_ALL: reset everything but PCI core blocks
  * @RESET_TYPE_WORLD: reset everything, save & restore PCI config
@@ -84,9 +146,9 @@ extern const char *efx_loopback_mode_nam
  * @RESET_TYPE_RX_DESC_FETCH: pcie error during rx descriptor fetch
  * @RESET_TYPE_TX_DESC_FETCH: pcie error during tx descriptor fetch
  * @RESET_TYPE_TX_SKIP: hardware completed empty tx descriptors
+ * @RESET_TYPE_MC_FAILURE: MC reboot/assertion
  */
 enum reset_type {
-	RESET_TYPE_NONE = -1,
 	RESET_TYPE_INVISIBLE = 0,
 	RESET_TYPE_ALL = 1,
 	RESET_TYPE_WORLD = 2,
@@ -98,6 +160,7 @@ enum reset_type {
 	RESET_TYPE_RX_DESC_FETCH,
 	RESET_TYPE_TX_DESC_FETCH,
 	RESET_TYPE_TX_SKIP,
+	RESET_TYPE_MC_FAILURE,
 	RESET_TYPE_MAX,
 };
 
diff -r 9566a4a50a43 drivers/net/sfc/ethtool.c
--- a/drivers/net/sfc/ethtool.c
+++ b/drivers/net/sfc/ethtool.c
@@ -1,7 +1,7 @@
 /****************************************************************************
  * Driver for Solarflare Solarstorm network controllers and boards
  * Copyright 2005-2006 Fen Systems Ltd.
- * Copyright 2006-2008 Solarflare Communications Inc.
+ * Copyright 2006-2010 Solarflare Communications Inc.
  *
  * This program is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 as published
@@ -10,29 +10,14 @@
 
 #include <linux/netdevice.h>
 #include <linux/ethtool.h>
-#include <linux/mdio.h>
 #include <linux/rtnetlink.h>
+#include <linux/in.h>
 #include "net_driver.h"
 #include "workarounds.h"
 #include "selftest.h"
 #include "efx.h"
-#include "ethtool.h"
-#include "falcon.h"
-#include "spi.h"
-#include "mdio_10g.h"
-
-const char *efx_loopback_mode_names[] = {
-	[LOOPBACK_NONE]		= "NONE",
-	[LOOPBACK_GMAC]		= "GMAC",
-	[LOOPBACK_XGMII]	= "XGMII",
-	[LOOPBACK_XGXS]		= "XGXS",
-	[LOOPBACK_XAUI] 	= "XAUI",
-	[LOOPBACK_GPHY]		= "GPHY",
-	[LOOPBACK_PHYXS]	= "PHYXS",
-	[LOOPBACK_PCS]	 	= "PCS",
-	[LOOPBACK_PMAPMD]	= "PMA/PMD",
-	[LOOPBACK_NETWORK]	= "NETWORK",
-};
+#include "filter.h"
+#include "nic.h"
 
 struct ethtool_string {
 	char name[ETH_GSTRING_LEN];
@@ -43,7 +28,8 @@ struct efx_ethtool_stat {
 	enum {
 		EFX_ETHTOOL_STAT_SOURCE_mac_stats,
 		EFX_ETHTOOL_STAT_SOURCE_nic,
-		EFX_ETHTOOL_STAT_SOURCE_channel
+		EFX_ETHTOOL_STAT_SOURCE_channel,
+		EFX_ETHTOOL_STAT_SOURCE_tx_queue
 	} source;
 	unsigned offset;
 	u64(*get_stat) (void *field); /* Reader function */
@@ -66,11 +52,6 @@ static u64 efx_get_uint_stat(void *field
 	return *(unsigned int *)field;
 }
 
-static u64 efx_get_ulong_stat(void *field)
-{
-	return *(unsigned long *)field;
-}
-
 static u64 efx_get_u64_stat(void *field)
 {
 	return *(u64 *) field;
@@ -81,10 +62,6 @@ static u64 efx_get_atomic_stat(void *fie
 	return atomic_read((atomic_t *) field);
 }
 
-#define EFX_ETHTOOL_ULONG_MAC_STAT(field)			\
-	EFX_ETHTOOL_STAT(field, mac_stats, field, 		\
-			  unsigned long, efx_get_ulong_stat)
-
 #define EFX_ETHTOOL_U64_MAC_STAT(field)				\
 	EFX_ETHTOOL_STAT(field, mac_stats, field, 		\
 			  u64, efx_get_u64_stat)
@@ -94,80 +71,99 @@ static u64 efx_get_atomic_stat(void *fie
 			 unsigned int, efx_get_uint_stat)
 
 #define EFX_ETHTOOL_ATOMIC_NIC_ERROR_STAT(field)		\
-	EFX_ETHTOOL_STAT(field, nic, field,			\
+	EFX_ETHTOOL_STAT(field, nic, errors.field,		\
 			 atomic_t, efx_get_atomic_stat)
 
 #define EFX_ETHTOOL_UINT_CHANNEL_STAT(field)			\
 	EFX_ETHTOOL_STAT(field, channel, n_##field,		\
 			 unsigned int, efx_get_uint_stat)
 
+#define EFX_ETHTOOL_UINT_TXQ_STAT(field)			\
+	EFX_ETHTOOL_STAT(tx_##field, tx_queue, field,		\
+			 unsigned int, efx_get_uint_stat)
+
 static struct efx_ethtool_stat efx_ethtool_stats[] = {
 	EFX_ETHTOOL_U64_MAC_STAT(tx_bytes),
 	EFX_ETHTOOL_U64_MAC_STAT(tx_good_bytes),
 	EFX_ETHTOOL_U64_MAC_STAT(tx_bad_bytes),
-	EFX_ETHTOOL_ULONG_MAC_STAT(tx_packets),
-	EFX_ETHTOOL_ULONG_MAC_STAT(tx_bad),
-	EFX_ETHTOOL_ULONG_MAC_STAT(tx_pause),
-	EFX_ETHTOOL_ULONG_MAC_STAT(tx_control),
-	EFX_ETHTOOL_ULONG_MAC_STAT(tx_unicast),
-	EFX_ETHTOOL_ULONG_MAC_STAT(tx_multicast),
-	EFX_ETHTOOL_ULONG_MAC_STAT(tx_broadcast),
-	EFX_ETHTOOL_ULONG_MAC_STAT(tx_lt64),
-	EFX_ETHTOOL_ULONG_MAC_STAT(tx_64),
-	EFX_ETHTOOL_ULONG_MAC_STAT(tx_65_to_127),
-	EFX_ETHTOOL_ULONG_MAC_STAT(tx_128_to_255),
-	EFX_ETHTOOL_ULONG_MAC_STAT(tx_256_to_511),
-	EFX_ETHTOOL_ULONG_MAC_STAT(tx_512_to_1023),
-	EFX_ETHTOOL_ULONG_MAC_STAT(tx_1024_to_15xx),
-	EFX_ETHTOOL_ULONG_MAC_STAT(tx_15xx_to_jumbo),
-	EFX_ETHTOOL_ULONG_MAC_STAT(tx_gtjumbo),
-	EFX_ETHTOOL_ULONG_MAC_STAT(tx_collision),
-	EFX_ETHTOOL_ULONG_MAC_STAT(tx_single_collision),
-	EFX_ETHTOOL_ULONG_MAC_STAT(tx_multiple_collision),
-	EFX_ETHTOOL_ULONG_MAC_STAT(tx_excessive_collision),
-	EFX_ETHTOOL_ULONG_MAC_STAT(tx_deferred),
-	EFX_ETHTOOL_ULONG_MAC_STAT(tx_late_collision),
-	EFX_ETHTOOL_ULONG_MAC_STAT(tx_excessive_deferred),
-	EFX_ETHTOOL_ULONG_MAC_STAT(tx_non_tcpudp),
-	EFX_ETHTOOL_ULONG_MAC_STAT(tx_mac_src_error),
-	EFX_ETHTOOL_ULONG_MAC_STAT(tx_ip_src_error),
+	EFX_ETHTOOL_U64_MAC_STAT(tx_packets),
+	EFX_ETHTOOL_U64_MAC_STAT(tx_bad),
+	EFX_ETHTOOL_U64_MAC_STAT(tx_pause),
+	EFX_ETHTOOL_U64_MAC_STAT(tx_control),
+	EFX_ETHTOOL_U64_MAC_STAT(tx_unicast),
+	EFX_ETHTOOL_U64_MAC_STAT(tx_multicast),
+	EFX_ETHTOOL_U64_MAC_STAT(tx_broadcast),
+	EFX_ETHTOOL_U64_MAC_STAT(tx_lt64),
+	EFX_ETHTOOL_U64_MAC_STAT(tx_64),
+	EFX_ETHTOOL_U64_MAC_STAT(tx_65_to_127),
+	EFX_ETHTOOL_U64_MAC_STAT(tx_128_to_255),
+	EFX_ETHTOOL_U64_MAC_STAT(tx_256_to_511),
+	EFX_ETHTOOL_U64_MAC_STAT(tx_512_to_1023),
+	EFX_ETHTOOL_U64_MAC_STAT(tx_1024_to_15xx),
+	EFX_ETHTOOL_U64_MAC_STAT(tx_15xx_to_jumbo),
+	EFX_ETHTOOL_U64_MAC_STAT(tx_gtjumbo),
+	EFX_ETHTOOL_U64_MAC_STAT(tx_collision),
+	EFX_ETHTOOL_U64_MAC_STAT(tx_single_collision),
+	EFX_ETHTOOL_U64_MAC_STAT(tx_multiple_collision),
+	EFX_ETHTOOL_U64_MAC_STAT(tx_excessive_collision),
+	EFX_ETHTOOL_U64_MAC_STAT(tx_deferred),
+	EFX_ETHTOOL_U64_MAC_STAT(tx_late_collision),
+	EFX_ETHTOOL_U64_MAC_STAT(tx_excessive_deferred),
+	EFX_ETHTOOL_U64_MAC_STAT(tx_non_tcpudp),
+	EFX_ETHTOOL_U64_MAC_STAT(tx_mac_src_error),
+	EFX_ETHTOOL_U64_MAC_STAT(tx_ip_src_error),
+	EFX_ETHTOOL_UINT_TXQ_STAT(tso_bursts),
+	EFX_ETHTOOL_UINT_TXQ_STAT(tso_long_headers),
+	EFX_ETHTOOL_UINT_TXQ_STAT(tso_packets),
+	EFX_ETHTOOL_UINT_TXQ_STAT(pushes),
 	EFX_ETHTOOL_U64_MAC_STAT(rx_bytes),
 	EFX_ETHTOOL_U64_MAC_STAT(rx_good_bytes),
 	EFX_ETHTOOL_U64_MAC_STAT(rx_bad_bytes),
-	EFX_ETHTOOL_ULONG_MAC_STAT(rx_packets),
-	EFX_ETHTOOL_ULONG_MAC_STAT(rx_good),
-	EFX_ETHTOOL_ULONG_MAC_STAT(rx_bad),
-	EFX_ETHTOOL_ULONG_MAC_STAT(rx_pause),
-	EFX_ETHTOOL_ULONG_MAC_STAT(rx_control),
-	EFX_ETHTOOL_ULONG_MAC_STAT(rx_unicast),
-	EFX_ETHTOOL_ULONG_MAC_STAT(rx_multicast),
-	EFX_ETHTOOL_ULONG_MAC_STAT(rx_broadcast),
-	EFX_ETHTOOL_ULONG_MAC_STAT(rx_lt64),
-	EFX_ETHTOOL_ULONG_MAC_STAT(rx_64),
-	EFX_ETHTOOL_ULONG_MAC_STAT(rx_65_to_127),
-	EFX_ETHTOOL_ULONG_MAC_STAT(rx_128_to_255),
-	EFX_ETHTOOL_ULONG_MAC_STAT(rx_256_to_511),
-	EFX_ETHTOOL_ULONG_MAC_STAT(rx_512_to_1023),
-	EFX_ETHTOOL_ULONG_MAC_STAT(rx_1024_to_15xx),
-	EFX_ETHTOOL_ULONG_MAC_STAT(rx_15xx_to_jumbo),
-	EFX_ETHTOOL_ULONG_MAC_STAT(rx_gtjumbo),
-	EFX_ETHTOOL_ULONG_MAC_STAT(rx_bad_lt64),
-	EFX_ETHTOOL_ULONG_MAC_STAT(rx_bad_64_to_15xx),
-	EFX_ETHTOOL_ULONG_MAC_STAT(rx_bad_15xx_to_jumbo),
-	EFX_ETHTOOL_ULONG_MAC_STAT(rx_bad_gtjumbo),
-	EFX_ETHTOOL_ULONG_MAC_STAT(rx_overflow),
-	EFX_ETHTOOL_ULONG_MAC_STAT(rx_missed),
-	EFX_ETHTOOL_ULONG_MAC_STAT(rx_false_carrier),
-	EFX_ETHTOOL_ULONG_MAC_STAT(rx_symbol_error),
-	EFX_ETHTOOL_ULONG_MAC_STAT(rx_align_error),
-	EFX_ETHTOOL_ULONG_MAC_STAT(rx_length_error),
-	EFX_ETHTOOL_ULONG_MAC_STAT(rx_internal_error),
+	EFX_ETHTOOL_U64_MAC_STAT(rx_packets),
+	EFX_ETHTOOL_U64_MAC_STAT(rx_good),
+	EFX_ETHTOOL_U64_MAC_STAT(rx_bad),
+	EFX_ETHTOOL_U64_MAC_STAT(rx_pause),
+	EFX_ETHTOOL_U64_MAC_STAT(rx_control),
+	EFX_ETHTOOL_U64_MAC_STAT(rx_unicast),
+	EFX_ETHTOOL_U64_MAC_STAT(rx_multicast),
+	EFX_ETHTOOL_U64_MAC_STAT(rx_broadcast),
+	EFX_ETHTOOL_U64_MAC_STAT(rx_lt64),
+	EFX_ETHTOOL_U64_MAC_STAT(rx_64),
+	EFX_ETHTOOL_U64_MAC_STAT(rx_65_to_127),
+	EFX_ETHTOOL_U64_MAC_STAT(rx_128_to_255),
+	EFX_ETHTOOL_U64_MAC_STAT(rx_256_to_511),
+	EFX_ETHTOOL_U64_MAC_STAT(rx_512_to_1023),
+	EFX_ETHTOOL_U64_MAC_STAT(rx_1024_to_15xx),
+	EFX_ETHTOOL_U64_MAC_STAT(rx_15xx_to_jumbo),
+	EFX_ETHTOOL_U64_MAC_STAT(rx_gtjumbo),
+	EFX_ETHTOOL_U64_MAC_STAT(rx_bad_lt64),
+	EFX_ETHTOOL_U64_MAC_STAT(rx_bad_64_to_15xx),
+	EFX_ETHTOOL_U64_MAC_STAT(rx_bad_15xx_to_jumbo),
+	EFX_ETHTOOL_U64_MAC_STAT(rx_bad_gtjumbo),
+	EFX_ETHTOOL_U64_MAC_STAT(rx_overflow),
+	EFX_ETHTOOL_U64_MAC_STAT(rx_missed),
+	EFX_ETHTOOL_U64_MAC_STAT(rx_false_carrier),
+	EFX_ETHTOOL_U64_MAC_STAT(rx_symbol_error),
+	EFX_ETHTOOL_U64_MAC_STAT(rx_align_error),
+	EFX_ETHTOOL_U64_MAC_STAT(rx_length_error),
+	EFX_ETHTOOL_U64_MAC_STAT(rx_internal_error),
 	EFX_ETHTOOL_UINT_NIC_STAT(rx_nodesc_drop_cnt),
 	EFX_ETHTOOL_ATOMIC_NIC_ERROR_STAT(rx_reset),
 	EFX_ETHTOOL_UINT_CHANNEL_STAT(rx_tobe_disc),
 	EFX_ETHTOOL_UINT_CHANNEL_STAT(rx_ip_hdr_chksum_err),
 	EFX_ETHTOOL_UINT_CHANNEL_STAT(rx_tcp_udp_chksum_err),
+	EFX_ETHTOOL_UINT_CHANNEL_STAT(rx_eth_crc_err),
+	EFX_ETHTOOL_UINT_CHANNEL_STAT(rx_mcast_mismatch),
 	EFX_ETHTOOL_UINT_CHANNEL_STAT(rx_frm_trunc),
+	EFX_ETHTOOL_U64_MAC_STAT(rx_char_error_lane0),
+	EFX_ETHTOOL_U64_MAC_STAT(rx_char_error_lane1),
+	EFX_ETHTOOL_U64_MAC_STAT(rx_char_error_lane2),
+	EFX_ETHTOOL_U64_MAC_STAT(rx_char_error_lane3),
+	EFX_ETHTOOL_U64_MAC_STAT(rx_disp_error_lane0),
+	EFX_ETHTOOL_U64_MAC_STAT(rx_disp_error_lane1),
+	EFX_ETHTOOL_U64_MAC_STAT(rx_disp_error_lane2),
+	EFX_ETHTOOL_U64_MAC_STAT(rx_disp_error_lane3),
+	EFX_ETHTOOL_U64_MAC_STAT(rx_match_fault),
 };
 
 /* Number of ethtool statistics */
@@ -183,56 +179,95 @@ static struct efx_ethtool_stat efx_ethto
  */
 
 /* Identify device by flashing LEDs */
-static int efx_ethtool_phys_id(struct net_device *net_dev, u32 count)
+static int efx_ethtool_phys_id(struct net_device *net_dev,
+			       enum ethtool_phys_id_state state)
 {
 	struct efx_nic *efx = netdev_priv(net_dev);
+	enum efx_led_mode mode = EFX_LED_DEFAULT;
 
-	efx->board_info.blink(efx, 1);
-	set_current_state(TASK_INTERRUPTIBLE);
-	if (count)
-		schedule_timeout(count * HZ);
-	else
-		schedule();
-	efx->board_info.blink(efx, 0);
+	switch (state) {
+	case ETHTOOL_ID_ON:
+		mode = EFX_LED_ON;
+		break;
+	case ETHTOOL_ID_OFF:
+		mode = EFX_LED_OFF;
+		break;
+	case ETHTOOL_ID_INACTIVE:
+		mode = EFX_LED_DEFAULT;
+		break;
+	case ETHTOOL_ID_ACTIVE:
+		return 1;	/* cycle on/off once per second */
+	}
+
+	efx->type->set_id_led(efx, mode);
+	return 0;
+}
+
+static int efx_ethtool_phys_id_loop(struct net_device *net_dev, u32 count)
+{
+	/* Driver expects to be called at twice the frequency in rc */
+	int rc = efx_ethtool_phys_id(net_dev, ETHTOOL_ID_ACTIVE);
+	int n = rc * 2, i, interval = HZ / n;
+
+	/* Count down seconds */
+	do {
+		/* Count down iterations per second */
+		i = n;
+		do {
+			efx_ethtool_phys_id(net_dev,
+					    (i & 1) ? ETHTOOL_ID_OFF
+					    : ETHTOOL_ID_ON);
+			schedule_timeout_interruptible(interval);
+		} while (!signal_pending(current) && --i != 0);
+	} while (!signal_pending(current) &&
+		 (count == 0 || --count != 0));
+
+	(void)efx_ethtool_phys_id(net_dev, ETHTOOL_ID_INACTIVE);
 	return 0;
 }
 
 /* This must be called with rtnl_lock held. */
-int efx_ethtool_get_settings(struct net_device *net_dev,
-			     struct ethtool_cmd *ecmd)
+static int efx_ethtool_get_settings(struct net_device *net_dev,
+				    struct ethtool_cmd *ecmd)
 {
 	struct efx_nic *efx = netdev_priv(net_dev);
+	struct efx_link_state *link_state = &efx->link_state;
 
 	mutex_lock(&efx->mac_lock);
 	efx->phy_op->get_settings(efx, ecmd);
 	mutex_unlock(&efx->mac_lock);
 
-	/* Falcon GMAC does not support 1000Mbps HD */
+	/* GMAC does not support 1000Mbps HD */
 	ecmd->supported &= ~SUPPORTED_1000baseT_Half;
+	/* Both MACs support pause frames (bidirectional and respond-only) */
+	ecmd->supported |= SUPPORTED_Pause | SUPPORTED_Asym_Pause;
+
+	if (LOOPBACK_INTERNAL(efx)) {
+		ethtool_cmd_speed_set(ecmd, link_state->speed);
+		ecmd->duplex = link_state->fd ? DUPLEX_FULL : DUPLEX_HALF;
+	}
 
 	return 0;
 }
 
 /* This must be called with rtnl_lock held. */
-int efx_ethtool_set_settings(struct net_device *net_dev,
-			     struct ethtool_cmd *ecmd)
+static int efx_ethtool_set_settings(struct net_device *net_dev,
+				    struct ethtool_cmd *ecmd)
 {
 	struct efx_nic *efx = netdev_priv(net_dev);
 	int rc;
 
-	/* Falcon GMAC does not support 1000Mbps HD */
-	if (ecmd->speed == SPEED_1000 && ecmd->duplex != DUPLEX_FULL) {
-		EFX_LOG(efx, "rejecting unsupported 1000Mbps HD"
-			" setting\n");
+	/* GMAC does not support 1000Mbps HD */
+	if ((ethtool_cmd_speed(ecmd) == SPEED_1000) &&
+	    (ecmd->duplex != DUPLEX_FULL)) {
+		netif_dbg(efx, drv, efx->net_dev,
+			  "rejecting unsupported 1000Mbps HD setting\n");
 		return -EINVAL;
 	}
 
 	mutex_lock(&efx->mac_lock);
 	rc = efx->phy_op->set_settings(efx, ecmd);
 	mutex_unlock(&efx->mac_lock);
-	if (!rc)
-		efx_reconfigure_port(efx);
-
 	return rc;
 }
 
@@ -241,11 +276,40 @@ static void efx_ethtool_get_drvinfo(stru
 {
 	struct efx_nic *efx = netdev_priv(net_dev);
 
-	strlcpy(info->driver, EFX_DRIVER_NAME, sizeof(info->driver));
+	strlcpy(info->driver, KBUILD_MODNAME, sizeof(info->driver));
 	strlcpy(info->version, EFX_DRIVER_VERSION, sizeof(info->version));
+	if (efx_nic_rev(efx) >= EFX_REV_SIENA_A0)
+		efx_mcdi_print_fwver(efx, info->fw_version,
+				     sizeof(info->fw_version));
 	strlcpy(info->bus_info, pci_name(efx->pci_dev), sizeof(info->bus_info));
 }
 
+static int efx_ethtool_get_regs_len(struct net_device *net_dev)
+{
+	return efx_nic_get_regs_len(netdev_priv(net_dev));
+}
+
+static void efx_ethtool_get_regs(struct net_device *net_dev,
+				 struct ethtool_regs *regs, void *buf)
+{
+	struct efx_nic *efx = netdev_priv(net_dev);
+
+	regs->version = efx->type->revision;
+	efx_nic_get_regs(efx, buf);
+}
+
+static u32 efx_ethtool_get_msglevel(struct net_device *net_dev)
+{
+	struct efx_nic *efx = netdev_priv(net_dev);
+	return efx->msg_enable;
+}
+
+static void efx_ethtool_set_msglevel(struct net_device *net_dev, u32 msg_enable)
+{
+	struct efx_nic *efx = netdev_priv(net_dev);
+	efx->msg_enable = msg_enable;
+}
+
 /**
  * efx_fill_test - fill in an individual self-test entry
  * @test_index:		Index of the test
@@ -285,11 +349,8 @@ static void efx_fill_test(unsigned int t
 	}
 }
 
-#define EFX_CHANNEL_NAME(_channel) "chan%d", _channel->channel
-#define EFX_TX_QUEUE_NAME(_tx_queue) "txq%d", _tx_queue->queue
-#define EFX_RX_QUEUE_NAME(_rx_queue) "rxq%d", _rx_queue->queue
 #define EFX_LOOPBACK_NAME(_mode, _counter)			\
-	"loopback.%s." _counter, LOOPBACK_MODE_NAME(mode)
+	"loopback.%s." _counter, STRING_TABLE_LOOKUP(_mode, efx_loopback_mode)
 
 /**
  * efx_fill_loopback_test - fill in a block of loopback self-test entries
@@ -299,6 +360,9 @@ static void efx_fill_test(unsigned int t
  * @test_index:		Starting index of the test
  * @strings:		Ethtool strings, or %NULL
  * @data:		Ethtool test results, or %NULL
+ *
+ * Fill in a block of loopback self-test entries.  Return new test
+ * index.
  */
 static int efx_fill_loopback_test(struct efx_nic *efx,
 				  struct efx_loopback_self_tests *lb_tests,
@@ -306,9 +370,10 @@ static int efx_fill_loopback_test(struct
 				  unsigned int test_index,
 				  struct ethtool_string *strings, u64 *data)
 {
+	struct efx_channel *channel = efx_get_channel(efx, 0);
 	struct efx_tx_queue *tx_queue;
 
-	efx_for_each_tx_queue(tx_queue, efx) {
+	efx_for_each_channel_tx_queue(tx_queue, channel) {
 		efx_fill_test(test_index++, strings, data,
 			      &lb_tests->tx_sent[tx_queue->queue],
 			      EFX_TX_QUEUE_NAME(tx_queue),
@@ -336,6 +401,12 @@ static int efx_fill_loopback_test(struct
  * @tests:		Efx self-test results structure, or %NULL
  * @strings:		Ethtool strings, or %NULL
  * @data:		Ethtool test results, or %NULL
+ *
+ * Get self-test number of strings, strings, and/or test results.
+ * Return number of strings (== number of test results).
+ *
+ * The reason for merging these three functions is to make sure that
+ * they can never be inconsistent.
  */
 static int efx_ethtool_fill_self_tests(struct efx_nic *efx,
 				       struct efx_self_tests *tests,
@@ -346,8 +417,8 @@ static int efx_ethtool_fill_self_tests(s
 	unsigned int n = 0, i;
 	enum efx_loopback_mode mode;
 
-	efx_fill_test(n++, strings, data, &tests->mdio,
-		      "core", 0, "mdio", NULL);
+	efx_fill_test(n++, strings, data, &tests->phy_alive,
+		      "phy", 0, "alive", NULL);
 	efx_fill_test(n++, strings, data, &tests->nvram,
 		      "core", 0, "nvram", NULL);
 	efx_fill_test(n++, strings, data, &tests->interrupt,
@@ -363,18 +434,28 @@ static int efx_ethtool_fill_self_tests(s
 			      &tests->eventq_int[channel->channel],
 			      EFX_CHANNEL_NAME(channel),
 			      "eventq.int", NULL);
-		efx_fill_test(n++, strings, data,
-			      &tests->eventq_poll[channel->channel],
-			      EFX_CHANNEL_NAME(channel),
-			      "eventq.poll", NULL);
 	}
 
+	efx_fill_test(n++, strings, data, &tests->memory,
+		      "core", 0, "memory", NULL);
 	efx_fill_test(n++, strings, data, &tests->registers,
 		      "core", 0, "registers", NULL);
 
-	for (i = 0; i < efx->phy_op->num_tests; i++)
-		efx_fill_test(n++, strings, data, &tests->phy[i],
-			      "phy", 0, efx->phy_op->test_names[i], NULL);
+	if (efx->phy_op->run_tests != NULL) {
+		EFX_BUG_ON_PARANOID(efx->phy_op->test_name == NULL);
+
+		for (i = 0; true; ++i) {
+			const char *name;
+
+			EFX_BUG_ON_PARANOID(i >= EFX_MAX_PHY_TESTS);
+			name = efx->phy_op->test_name(efx, i);
+			if (name == NULL)
+				break;
+
+			efx_fill_test(n++, strings, data, &tests->phy_ext[i],
+				      "phy", 0, name, NULL);
+		}
+	}
 
 	/* Loopback tests */
 	for (mode = LOOPBACK_NONE; mode <= LOOPBACK_TEST_MAX; mode++) {
@@ -428,19 +509,22 @@ static void efx_ethtool_get_strings(stru
 }
 
 static void efx_ethtool_get_stats(struct net_device *net_dev,
-				  struct ethtool_stats *stats,
-				  u64 *data)
+				  struct ethtool_stats *stats
+				  __attribute__ ((unused)), u64 *data)
 {
 	struct efx_nic *efx = netdev_priv(net_dev);
 	struct efx_mac_stats *mac_stats = &efx->mac_stats;
 	struct efx_ethtool_stat *stat;
 	struct efx_channel *channel;
+	struct efx_tx_queue *tx_queue;
 	int i;
 
 	EFX_BUG_ON_PARANOID(stats->n_stats != EFX_ETHTOOL_NUM_STATS);
 
+	spin_lock_bh(&efx->stats_lock);
+
 	/* Update MAC and NIC statistics */
-	dev_get_stats(net_dev);
+	efx->type->update_stats(efx);
 
 	/* Fill detailed statistics buffer */
 	for (i = 0; i < EFX_ETHTOOL_NUM_STATS; i++) {
@@ -459,8 +543,49 @@ static void efx_ethtool_get_stats(struct
 				data[i] += stat->get_stat((void *)channel +
 							  stat->offset);
 			break;
+		case EFX_ETHTOOL_STAT_SOURCE_tx_queue:
+			data[i] = 0;
+			efx_for_each_channel(channel, efx) {
+				efx_for_each_channel_tx_queue(tx_queue, channel)
+					data[i] +=
+						stat->get_stat((void *)tx_queue
+							       + stat->offset);
+			}
+			break;
 		}
 	}
+
+	spin_unlock_bh(&efx->stats_lock);
+}
+
+static int efx_ethtool_set_tso(struct net_device *net_dev, u32 enable)
+{
+	struct efx_nic *efx __attribute__ ((unused)) = netdev_priv(net_dev);
+	u32 features;
+
+	features = NETIF_F_TSO;
+	if (efx->type->offload_features & NETIF_F_V6_CSUM)
+		features |= NETIF_F_TSO6;
+
+	if (enable)
+		net_dev->features |= features;
+	else
+		net_dev->features &= ~features;
+
+	return 0;
+}
+
+static int efx_ethtool_set_tx_csum(struct net_device *net_dev, u32 enable)
+{
+	struct efx_nic *efx = netdev_priv(net_dev);
+	u32 features = efx->type->offload_features & NETIF_F_ALL_CSUM;
+
+	if (enable)
+		net_dev->features |= features;
+	else
+		net_dev->features &= ~features;
+
+	return 0;
 }
 
 static int efx_ethtool_set_rx_csum(struct net_device *net_dev, u32 enable)
@@ -482,45 +607,83 @@ static u32 efx_ethtool_get_rx_csum(struc
 	return efx->rx_checksum_enabled;
 }
 
+static int efx_ethtool_set_flags(struct net_device *net_dev, u32 data)
+{
+	struct efx_nic *efx = netdev_priv(net_dev);
+	u32 supported = (efx->type->offload_features &
+			 (ETH_FLAG_RXHASH | ETH_FLAG_NTUPLE));
+	int rc;
+	
+	if (data & ~supported)
+		rc = -EINVAL;
+	else {
+		rc = 0;
+		net_dev->features = (net_dev->features & ~supported) | data;
+	}
+	if (rc)
+		return rc;
+
+	if (!(data & ETH_FLAG_NTUPLE))
+		efx_filter_clear_rx(efx, EFX_FILTER_PRI_MANUAL);
+
+	return 0;
+}
+
 static void efx_ethtool_self_test(struct net_device *net_dev,
 				  struct ethtool_test *test, u64 *data)
 {
 	struct efx_nic *efx = netdev_priv(net_dev);
-	struct efx_self_tests efx_tests;
-	int already_up;
-	int rc;
+	struct efx_self_tests *efx_tests;
+	bool already_up;
+	int rc = -ENOMEM;
+
+	efx_tests = kzalloc(sizeof(*efx_tests), GFP_KERNEL);
+	if (!efx_tests)
+		goto fail;
+
 
 	ASSERT_RTNL();
 	if (efx->state != STATE_RUNNING) {
-		rc = -EIO;
-		goto fail1;
+		rc = -EBUSY;
+		goto out;
 	}
 
+	netif_info(efx, drv, efx->net_dev, "starting %sline testing\n",
+		   (test->flags & ETH_TEST_FL_OFFLINE) ? "off" : "on");
+
+	if (test->flags & ETH_TEST_FL_OFFLINE)
+		efx_dl_reset_suspend(efx);
+
 	/* We need rx buffers and interrupts. */
 	already_up = (efx->net_dev->flags & IFF_UP);
 	if (!already_up) {
 		rc = dev_open(efx->net_dev);
 		if (rc) {
-			EFX_ERR(efx, "failed opening device.\n");
-			goto fail2;
+			netif_err(efx, drv, efx->net_dev,
+				  "failed opening device.\n");
+			goto out_resume;
 		}
 	}
 
-	memset(&efx_tests, 0, sizeof(efx_tests));
-
-	rc = efx_selftest(efx, &efx_tests, test->flags);
+	rc = efx_selftest(efx, efx_tests, test->flags);
 
 	if (!already_up)
 		dev_close(efx->net_dev);
 
-	EFX_LOG(efx, "%s %sline self-tests\n",
-		rc == 0 ? "passed" : "failed",
-		(test->flags & ETH_TEST_FL_OFFLINE) ? "off" : "on");
+	netif_info(efx, drv, efx->net_dev, "%s %sline self-tests\n",
+		   rc == 0 ? "passed" : "failed",
+		   (test->flags & ETH_TEST_FL_OFFLINE) ? "off" : "on");
 
- fail2:
- fail1:
-	/* Fill ethtool results structures */
-	efx_ethtool_fill_self_tests(efx, &efx_tests, NULL, data);
+out_resume:
+	if (test->flags & ETH_TEST_FL_OFFLINE) {
+		/* Return success because if efx_reset_up() failed, an
+		 * EFX_RESET_DISABLE reset will have been scheduled */
+		efx_dl_reset_resume(efx, true);
+	}
+out:
+	efx_ethtool_fill_self_tests(efx, efx_tests, NULL, data);
+	kfree(efx_tests);
+fail:
 	if (rc)
 		test->flags |= ETH_TEST_FL_FAILED;
 }
@@ -535,88 +698,52 @@ static int efx_ethtool_nway_reset(struct
 
 static u32 efx_ethtool_get_link(struct net_device *net_dev)
 {
-	struct efx_nic *efx = netdev_priv(net_dev);
-
-	return efx->link_up;
+	return netif_running(net_dev) && netif_carrier_ok(net_dev);
 }
 
-static int efx_ethtool_get_eeprom_len(struct net_device *net_dev)
-{
-	struct efx_nic *efx = netdev_priv(net_dev);
-	struct efx_spi_device *spi = efx->spi_eeprom;
-
-	if (!spi)
-		return 0;
-	return min(spi->size, EFX_EEPROM_BOOTCONFIG_END) -
-		min(spi->size, EFX_EEPROM_BOOTCONFIG_START);
-}
-
-static int efx_ethtool_get_eeprom(struct net_device *net_dev,
-				  struct ethtool_eeprom *eeprom, u8 *buf)
-{
-	struct efx_nic *efx = netdev_priv(net_dev);
-	struct efx_spi_device *spi = efx->spi_eeprom;
-	size_t len;
-	int rc;
-
-	rc = mutex_lock_interruptible(&efx->spi_lock);
-	if (rc)
-		return rc;
-	rc = falcon_spi_read(spi, eeprom->offset + EFX_EEPROM_BOOTCONFIG_START,
-			     eeprom->len, &len, buf);
-	mutex_unlock(&efx->spi_lock);
-
-	eeprom->magic = EFX_ETHTOOL_EEPROM_MAGIC;
-	eeprom->len = len;
-	return rc;
-}
-
-static int efx_ethtool_set_eeprom(struct net_device *net_dev,
-				  struct ethtool_eeprom *eeprom, u8 *buf)
-{
-	struct efx_nic *efx = netdev_priv(net_dev);
-	struct efx_spi_device *spi = efx->spi_eeprom;
-	size_t len;
-	int rc;
-
-	if (eeprom->magic != EFX_ETHTOOL_EEPROM_MAGIC)
-		return -EINVAL;
-
-	rc = mutex_lock_interruptible(&efx->spi_lock);
-	if (rc)
-		return rc;
-	rc = falcon_spi_write(spi, eeprom->offset + EFX_EEPROM_BOOTCONFIG_START,
-			      eeprom->len, &len, buf);
-	mutex_unlock(&efx->spi_lock);
-
-	eeprom->len = len;
-	return rc;
-}
+/*
+ * Each channel has a single IRQ and moderation timer, started by any
+ * completion (or other event).  Unless the module parameter
+ * separate_tx_channels is set, IRQs and moderation are therefore
+ * shared between RX and TX completions.  In this case, when RX IRQ
+ * moderation is explicitly changed then TX IRQ moderation is
+ * automatically changed too, but otherwise we fail if the two values
+ * are requested to be different.
+ *
+ * The hardware does not support a limit on the number of completions
+ * before an IRQ, so we do not use the max_frames fields.  We should
+ * report and require that max_frames == (usecs != 0), but this would
+ * invalidate existing user documentation.
+ *
+ * The hardware does not have distinct settings for interrupt
+ * moderation while the previous IRQ is being handled, so we should
+ * not use the 'irq' fields.  However, an earlier developer
+ * misunderstood the meaning of the 'irq' fields and the driver did
+ * not support the standard fields.  To avoid invalidating existing
+ * user documentation, we report and accept changes through either the
+ * standard or 'irq' fields.  If both are changed at the same time, we
+ * prefer the standard field.
+ *
+ * We implement adaptive IRQ moderation, but use a different algorithm
+ * from that assumed in the definition of struct ethtool_coalesce.
+ * Therefore we do not use any of the adaptive moderation parameters
+ * in it.
+ */
 
 static int efx_ethtool_get_coalesce(struct net_device *net_dev,
 				    struct ethtool_coalesce *coalesce)
 {
 	struct efx_nic *efx = netdev_priv(net_dev);
-	struct efx_tx_queue *tx_queue;
-	struct efx_channel *channel;
+	unsigned int tx_usecs, rx_usecs;
+	bool rx_adaptive;
 
-	memset(coalesce, 0, sizeof(*coalesce));
+	efx_get_irq_moderation(efx, &tx_usecs, &rx_usecs, &rx_adaptive);
 
-	/* Find lowest IRQ moderation across all used TX queues */
-	coalesce->tx_coalesce_usecs_irq = ~((u32) 0);
-	efx_for_each_tx_queue(tx_queue, efx) {
-		channel = tx_queue->channel;
-		if (channel->irq_moderation < coalesce->tx_coalesce_usecs_irq) {
-			if (channel->used_flags != EFX_USED_BY_RX_TX)
-				coalesce->tx_coalesce_usecs_irq =
-					channel->irq_moderation;
-			else
-				coalesce->tx_coalesce_usecs_irq = 0;
-		}
-	}
-
-	coalesce->use_adaptive_rx_coalesce = efx->irq_rx_adaptive;
-	coalesce->rx_coalesce_usecs_irq = efx->irq_rx_moderation;
+	coalesce->tx_coalesce_usecs = tx_usecs;
+	coalesce->tx_coalesce_usecs_irq = tx_usecs;
+	coalesce->rx_coalesce_usecs = rx_usecs;
+	coalesce->rx_coalesce_usecs_irq = rx_usecs;
+	coalesce->use_adaptive_rx_coalesce = rx_adaptive;
 
 	return 0;
 }
@@ -629,65 +756,107 @@ static int efx_ethtool_set_coalesce(stru
 {
 	struct efx_nic *efx = netdev_priv(net_dev);
 	struct efx_channel *channel;
-	struct efx_tx_queue *tx_queue;
-	unsigned tx_usecs, rx_usecs, adaptive;
+	unsigned int tx_usecs, rx_usecs;
+	bool adaptive, rx_may_override_tx;
+	int rc;
 
 	if (coalesce->use_adaptive_tx_coalesce)
-		return -EOPNOTSUPP;
+		return -EINVAL;
 
-	if (coalesce->rx_coalesce_usecs || coalesce->tx_coalesce_usecs) {
-		EFX_ERR(efx, "invalid coalescing setting. "
-			"Only rx/tx_coalesce_usecs_irq are supported\n");
-		return -EOPNOTSUPP;
+	efx_get_irq_moderation(efx, &tx_usecs, &rx_usecs, &adaptive);
+
+	if (coalesce->rx_coalesce_usecs != rx_usecs)
+		rx_usecs = coalesce->rx_coalesce_usecs;
+	else
+		rx_usecs = coalesce->rx_coalesce_usecs_irq;
+
+	adaptive = coalesce->use_adaptive_rx_coalesce;
+
+	/* If channels are shared, TX IRQ moderation can be quietly
+	 * overridden unless it is changed from its old value.
+	 */
+	rx_may_override_tx = (coalesce->tx_coalesce_usecs == tx_usecs &&
+			      coalesce->tx_coalesce_usecs_irq == tx_usecs);
+	if (coalesce->tx_coalesce_usecs != tx_usecs)
+		tx_usecs = coalesce->tx_coalesce_usecs;
+	else
+		tx_usecs = coalesce->tx_coalesce_usecs_irq;
+
+	rc = efx_init_irq_moderation(efx, tx_usecs, rx_usecs, adaptive,
+				     rx_may_override_tx);
+	if (rc != 0)
+		return rc;
+
+	efx_for_each_channel(channel, efx)
+		efx->type->push_irq_moderation(channel);
+
+	return 0;
+}
+
+static void efx_ethtool_get_ringparam(struct net_device *net_dev,
+				      struct ethtool_ringparam *ring)
+{
+	struct efx_nic *efx = netdev_priv(net_dev);
+
+	ring->rx_max_pending = EFX_MAX_DMAQ_SIZE;
+	ring->tx_max_pending = EFX_MAX_DMAQ_SIZE;
+	ring->rx_mini_max_pending = 0;
+	ring->rx_jumbo_max_pending = 0;
+	ring->rx_pending = efx->rxq_entries;
+	ring->tx_pending = efx->txq_entries;
+	ring->rx_mini_pending = 0;
+	ring->rx_jumbo_pending = 0;
+}
+
+static int efx_ethtool_set_ringparam(struct net_device *net_dev,
+				     struct ethtool_ringparam *ring)
+{
+	struct efx_nic *efx = netdev_priv(net_dev);
+
+	if (ring->rx_mini_pending || ring->rx_jumbo_pending ||
+	    ring->rx_pending > EFX_MAX_DMAQ_SIZE ||
+	    ring->tx_pending > EFX_MAX_DMAQ_SIZE)
+		return -EINVAL;
+
+	if (ring->rx_pending < EFX_MIN_RING_SIZE ||
+	    ring->tx_pending < EFX_MIN_RING_SIZE) {
+		netif_err(efx, drv, efx->net_dev,
+			  "TX and RX queues cannot be smaller than %ld\n",
+			  EFX_MIN_RING_SIZE);
+		return -EINVAL;
 	}
 
-	rx_usecs = coalesce->rx_coalesce_usecs_irq;
-	tx_usecs = coalesce->tx_coalesce_usecs_irq;
-	adaptive = coalesce->use_adaptive_rx_coalesce;
-
-	/* If the channel is shared only allow RX parameters to be set */
-	efx_for_each_tx_queue(tx_queue, efx) {
-		if ((tx_queue->channel->used_flags == EFX_USED_BY_RX_TX) &&
-		    tx_usecs) {
-			EFX_ERR(efx, "Channel is shared. "
-				"Only RX coalescing may be set\n");
-			return -EOPNOTSUPP;
-		}
-	}
-
-	efx_init_irq_moderation(efx, tx_usecs, rx_usecs, adaptive);
-
-	/* Reset channel to pick up new moderation value.  Note that
-	 * this may change the value of the irq_moderation field
-	 * (e.g. to allow for hardware timer granularity).
-	 */
-	efx_for_each_channel(channel, efx)
-		falcon_set_int_moderation(channel);
-
-	return 0;
+	return efx_realloc_channels(efx, ring->rx_pending, ring->tx_pending);
 }
 
 static int efx_ethtool_set_pauseparam(struct net_device *net_dev,
 				      struct ethtool_pauseparam *pause)
 {
 	struct efx_nic *efx = netdev_priv(net_dev);
-	enum efx_fc_type wanted_fc;
+	enum efx_fc_type wanted_fc, old_fc;
+	u32 old_adv;
 	bool reset;
+	int rc = 0;
+
+	mutex_lock(&efx->mac_lock);
 
 	wanted_fc = ((pause->rx_pause ? EFX_FC_RX : 0) |
 		     (pause->tx_pause ? EFX_FC_TX : 0) |
 		     (pause->autoneg ? EFX_FC_AUTO : 0));
 
 	if ((wanted_fc & EFX_FC_TX) && !(wanted_fc & EFX_FC_RX)) {
-		EFX_LOG(efx, "Flow control unsupported: tx ON rx OFF\n");
-		return -EINVAL;
+		netif_dbg(efx, drv, efx->net_dev,
+			  "Flow control unsupported: tx ON rx OFF\n");
+		rc = -EINVAL;
+		goto out;
 	}
 
-	if (!(efx->phy_op->mmds & MDIO_DEVS_AN) &&
-	    (wanted_fc & EFX_FC_AUTO)) {
-		EFX_LOG(efx, "PHY does not support flow control "
-			"autonegotiation\n");
-		return -EINVAL;
+	if ((wanted_fc & EFX_FC_AUTO) &&
+	    !(efx->link_advertising & ADVERTISED_Autoneg)) {
+		netif_dbg(efx, drv, efx->net_dev,
+			  "Autonegotiation is disabled\n");
+		rc = -EINVAL;
+		goto out;
 	}
 
 	/* TX flow control may automatically turn itself off if the
@@ -697,27 +866,41 @@ static int efx_ethtool_set_pauseparam(st
 	 * and fix it be cycling transmit flow control on this end. */
 	reset = (wanted_fc & EFX_FC_TX) && !(efx->wanted_fc & EFX_FC_TX);
 	if (EFX_WORKAROUND_11482(efx) && reset) {
-		if (falcon_rev(efx) >= FALCON_REV_B0) {
+		if (efx_nic_rev(efx) == EFX_REV_FALCON_B0) {
 			/* Recover by resetting the EM block */
-			if (efx->link_up)
-				falcon_drain_tx_fifo(efx);
+			falcon_stop_nic_stats(efx);
+			falcon_drain_tx_fifo(efx);
+			falcon_reconfigure_xmac(efx);
+			falcon_start_nic_stats(efx);
 		} else {
 			/* Schedule a reset to recover */
 			efx_schedule_reset(efx, RESET_TYPE_INVISIBLE);
 		}
 	}
 
-	/* Try to push the pause parameters */
-	mutex_lock(&efx->mac_lock);
+	old_adv = efx->link_advertising;
+	old_fc = efx->wanted_fc;
+	efx_link_set_wanted_fc(efx, wanted_fc);
+	if (efx->link_advertising != old_adv ||
+	    (efx->wanted_fc ^ old_fc) & EFX_FC_AUTO) {
+		rc = efx->phy_op->reconfigure(efx);
+		if (rc) {
+			netif_err(efx, drv, efx->net_dev,
+				  "Unable to advertise requested flow "
+				  "control setting\n");
+			goto out;
+		}
+	}
 
-	efx->wanted_fc = wanted_fc;
-	if (efx->phy_op->mmds & MDIO_DEVS_AN)
-		mdio45_ethtool_spauseparam_an(&efx->mdio, pause);
-	__efx_reconfigure_port(efx);
+	/* Reconfigure the MAC. The PHY *may* generate a link state change event
+	 * if the user just changed the advertised capabilities, but there's no
+	 * harm doing this twice */
+	efx->type->reconfigure_mac(efx);
 
+out:
 	mutex_unlock(&efx->mac_lock);
 
-	return 0;
+	return rc;
 }
 
 static void efx_ethtool_get_pauseparam(struct net_device *net_dev,
@@ -730,33 +913,440 @@ static void efx_ethtool_get_pauseparam(s
 	pause->autoneg = !!(efx->wanted_fc & EFX_FC_AUTO);
 }
 
+static void efx_ethtool_get_wol(struct net_device *net_dev,
+				struct ethtool_wolinfo *wol)
+{
+	struct efx_nic *efx = netdev_priv(net_dev);
+	return efx->type->get_wol(efx, wol);
+}
+
+
+static int efx_ethtool_set_wol(struct net_device *net_dev,
+			       struct ethtool_wolinfo *wol)
+{
+	struct efx_nic *efx = netdev_priv(net_dev);
+	return efx->type->set_wol(efx, wol->wolopts);
+}
+
+int efx_ethtool_reset(struct net_device *net_dev, u32 *flags)
+{
+	struct efx_nic *efx = netdev_priv(net_dev);
+	int rc;
+
+	rc = efx->type->map_reset_flags(flags);
+	if (rc < 0)
+		return rc;
+
+	return efx_reset(efx, rc);
+}
+
+/* MAC address mask including only MC flag */
+static const u8 mac_addr_mc_mask[ETH_ALEN] = { 0x01, 0, 0, 0, 0, 0 };
+
+static int efx_ethtool_get_class_rule(struct efx_nic *efx,
+				      struct efx_ethtool_rx_flow_spec *rule)
+{
+	struct ethtool_tcpip4_spec *ip_entry = &rule->h_u.tcp_ip4_spec;
+	struct ethtool_tcpip4_spec *ip_mask = &rule->m_u.tcp_ip4_spec;
+	struct ethhdr *mac_entry = &rule->h_u.ether_spec;
+	struct ethhdr *mac_mask = &rule->m_u.ether_spec;
+	struct efx_filter_spec spec;
+	u16 vid;
+	u8 proto;
+	int rc;
+
+	rc = efx_filter_get_filter_safe(efx, EFX_FILTER_PRI_MANUAL,
+					rule->location, &spec);
+	if (rc)
+		return rc;
+
+	if (spec.dmaq_id == 0xfff)
+		rule->ring_cookie = RX_CLS_FLOW_DISC;
+	else
+		rule->ring_cookie = spec.dmaq_id;
+
+	if (spec.type == EFX_FILTER_MC_DEF || spec.type == EFX_FILTER_UC_DEF) {
+		rule->flow_type = ETHER_FLOW;
+		memcpy(mac_mask->h_dest, mac_addr_mc_mask, ETH_ALEN);
+		if (spec.type == EFX_FILTER_MC_DEF)
+			memcpy(mac_entry->h_dest, mac_addr_mc_mask, ETH_ALEN);
+		return 0;
+	}
+
+	rc = efx_filter_get_eth_local(&spec, &vid, mac_entry->h_dest);
+	if (rc == 0) {
+		rule->flow_type = ETHER_FLOW;
+		memset(mac_mask->h_dest, ~0, ETH_ALEN);
+		if (vid != EFX_FILTER_VID_UNSPEC) {
+			rule->flow_type |= FLOW_EXT;
+			rule->h_ext.vlan_tci = htons(vid);
+			rule->m_ext.vlan_tci = htons(0xfff);
+		}
+		return 0;
+	}
+
+	rc = efx_filter_get_ipv4_local(&spec, &proto,
+				       &ip_entry->ip4dst, &ip_entry->pdst);
+	if (rc != 0) {
+		rc = efx_filter_get_ipv4_full(
+			&spec, &proto, &ip_entry->ip4src, &ip_entry->psrc,
+			&ip_entry->ip4dst, &ip_entry->pdst);
+		EFX_WARN_ON_PARANOID(rc);
+		ip_mask->ip4src = ~0;
+		ip_mask->psrc = ~0;
+	}
+	rule->flow_type = (proto == IPPROTO_TCP) ? TCP_V4_FLOW : UDP_V4_FLOW;
+	ip_mask->ip4dst = ~0;
+	ip_mask->pdst = ~0;
+	return rc;
+}
+
+int
+efx_ethtool_get_rxnfc(struct net_device *net_dev,
+		      struct efx_ethtool_rxnfc *info, u32 *rule_locs)
+{
+	struct efx_nic *efx = netdev_priv(net_dev);
+	
+	switch (info->cmd) {
+	case ETHTOOL_GRXRINGS:
+		info->data = efx->n_rx_channels;
+		return 0;
+
+	case ETHTOOL_GRXFH: {
+		unsigned min_revision = 0;
+
+		info->data = 0;
+		switch (info->flow_type) {
+		case TCP_V4_FLOW:
+			info->data |= RXH_L4_B_0_1 | RXH_L4_B_2_3;
+			/* fall through */
+		case UDP_V4_FLOW:
+		case SCTP_V4_FLOW:
+		case AH_ESP_V4_FLOW:
+		case IPV4_FLOW:
+			info->data |= RXH_IP_SRC | RXH_IP_DST;
+			min_revision = EFX_REV_FALCON_B0;
+			break;
+		case TCP_V6_FLOW:
+			info->data |= RXH_L4_B_0_1 | RXH_L4_B_2_3;
+			/* fall through */
+		case UDP_V6_FLOW:
+		case SCTP_V6_FLOW:
+		case AH_ESP_V6_FLOW:
+		case IPV6_FLOW:
+			info->data |= RXH_IP_SRC | RXH_IP_DST;
+			min_revision = EFX_REV_SIENA_A0;
+			break;
+		default:
+			break;
+		}
+		if (efx_nic_rev(efx) < min_revision)
+			info->data = 0;
+		return 0;
+	}
+
+	case ETHTOOL_GRXCLSRLCNT:
+		info->data = efx_filter_get_rx_id_limit(efx);
+		if (info->data == 0)
+			return -EOPNOTSUPP;
+		info->data |= RX_CLS_LOC_SPECIAL;
+		info->rule_cnt =
+			efx_filter_count_rx_used(efx, EFX_FILTER_PRI_MANUAL);
+		return 0;
+
+	case ETHTOOL_GRXCLSRULE:
+		if (efx_filter_get_rx_id_limit(efx) == 0)
+			return -EOPNOTSUPP;
+		return efx_ethtool_get_class_rule(efx, &info->fs);
+
+	case ETHTOOL_GRXCLSRLALL: {
+		s32 rc;
+		info->data = efx_filter_get_rx_id_limit(efx);
+		if (info->data == 0)
+			return -EOPNOTSUPP;
+		rc = efx_filter_get_rx_ids(efx, EFX_FILTER_PRI_MANUAL,
+					   rule_locs, info->rule_cnt);
+		if (rc < 0)
+			return rc;
+		info->rule_cnt = rc;
+		return 0;
+	}
+
+	default:
+		return -EOPNOTSUPP;
+	}
+}
+
+#if defined(EFX_USE_KCOMPAT) && defined(EFX_HAVE_ETHTOOL_RXNFC)
+static int efx_ethtool_get_rxnfc_wrapper(struct net_device *net_dev,
+					 struct ethtool_rxnfc *info,
+					 void *rules)
+{
+	return efx_ethtool_get_rxnfc(net_dev, (struct efx_ethtool_rxnfc *)info,
+				     rules);
+}
+static int efx_ethtool_set_rxnfc_wrapper(struct net_device *net_dev,
+					 struct ethtool_rxnfc *info)
+{
+	return efx_ethtool_set_rxnfc(net_dev, (struct efx_ethtool_rxnfc *)info);
+}
+#endif
+
+static int efx_ethtool_set_class_rule(struct efx_nic *efx,
+				      struct efx_ethtool_rx_flow_spec *rule)
+{
+	struct ethtool_tcpip4_spec *ip_entry = &rule->h_u.tcp_ip4_spec;
+	struct ethtool_tcpip4_spec *ip_mask = &rule->m_u.tcp_ip4_spec;
+	struct ethhdr *mac_entry = &rule->h_u.ether_spec;
+	struct ethhdr *mac_mask = &rule->m_u.ether_spec;
+	struct efx_filter_spec spec;
+	int rc;
+
+	/* Check that user wants us to choose the location */
+	if (rule->location != RX_CLS_LOC_ANY &&
+	    rule->location != RX_CLS_LOC_FIRST &&
+	    rule->location != RX_CLS_LOC_LAST)
+		return -EINVAL;
+
+	/* Range-check ring_cookie */
+	if (rule->ring_cookie >= efx->n_rx_channels &&
+	    rule->ring_cookie != RX_CLS_FLOW_DISC)
+		return -EINVAL;
+
+	/* Check for unsupported extensions */
+	if ((rule->flow_type & FLOW_EXT) &&
+	    (rule->m_ext.vlan_etype | rule->m_ext.data[0] |
+	     rule->m_ext.data[1]))
+		return -EINVAL;
+
+	efx_filter_init_rx(&spec, EFX_FILTER_PRI_MANUAL,
+			   (rule->location == RX_CLS_LOC_FIRST) ?
+			   EFX_FILTER_FLAG_RX_OVERRIDE_IP : 0,
+			   (rule->ring_cookie == RX_CLS_FLOW_DISC) ?
+			   0xfff : rule->ring_cookie);
+
+	switch (rule->flow_type) {
+	case TCP_V4_FLOW:
+	case UDP_V4_FLOW: {
+		u8 proto = (rule->flow_type == TCP_V4_FLOW ?
+			    IPPROTO_TCP : IPPROTO_UDP);
+
+		/* Must match all of destination, */
+		if ((__force u32)~ip_mask->ip4dst |
+		    (__force u16)~ip_mask->pdst)
+			return -EINVAL;
+		/* all or none of source, */
+		if ((ip_mask->ip4src | ip_mask->psrc) &&
+		    ((__force u32)~ip_mask->ip4src |
+		     (__force u16)~ip_mask->psrc))
+			return -EINVAL;
+		/* and nothing else */
+		if (ip_mask->tos | rule->m_ext.vlan_tci)
+			return -EINVAL;
+
+		if (ip_mask->ip4src)
+			rc = efx_filter_set_ipv4_full(&spec, proto,
+						      ip_entry->ip4dst,
+						      ip_entry->pdst,
+						      ip_entry->ip4src,
+						      ip_entry->psrc);
+		else
+			rc = efx_filter_set_ipv4_local(&spec, proto,
+						       ip_entry->ip4dst,
+						       ip_entry->pdst);
+		if (rc)
+			return rc;
+		break;
+	}
+
+	case ETHER_FLOW | FLOW_EXT:
+	case ETHER_FLOW: {
+		u16 vlan_tag_mask = (rule->flow_type & FLOW_EXT ?
+				     ntohs(rule->m_ext.vlan_tci) : 0);
+
+		/* Must not match on source address or Ethertype */
+		if (!is_zero_ether_addr(mac_mask->h_source) ||
+		    mac_mask->h_proto)
+			return -EINVAL;
+
+		/* Is it a default UC or MC filter? */
+		if (!compare_ether_addr(mac_mask->h_dest, mac_addr_mc_mask) &&
+		    vlan_tag_mask == 0) {
+			if (is_multicast_ether_addr(mac_entry->h_dest))
+				rc = efx_filter_set_mc_def(&spec);
+			else
+				rc = efx_filter_set_uc_def(&spec);
+		}
+		/* Otherwise, it must match all of destination and all
+		 * or none of VID.
+		 */
+		else if (is_broadcast_ether_addr(mac_mask->h_dest) && 
+			 (vlan_tag_mask == 0xfff || vlan_tag_mask == 0)) {
+			rc = efx_filter_set_eth_local(
+				&spec,
+				vlan_tag_mask ?
+				ntohs(rule->h_ext.vlan_tci) : EFX_FILTER_VID_UNSPEC,
+				mac_entry->h_dest);
+		} else {
+			rc = -EINVAL;
+		}
+		if (rc)
+			return rc;
+		break;
+	}
+
+	default:
+		return -EINVAL;
+	}
+
+	rc = efx_filter_insert_filter(efx, &spec, true);
+	if (rc < 0)
+		return rc;
+
+	rule->location = rc;
+	return 0;
+}
+
+int efx_ethtool_set_rxnfc(struct net_device *net_dev,
+			  struct efx_ethtool_rxnfc *info)
+{
+	struct efx_nic *efx = netdev_priv(net_dev);
+
+	if (efx_filter_get_rx_id_limit(efx) == 0)
+		return -EOPNOTSUPP;
+
+	switch (info->cmd) {
+	case ETHTOOL_SRXCLSRLINS:
+		return efx_ethtool_set_class_rule(efx, &info->fs);
+
+	case ETHTOOL_SRXCLSRLDEL:
+		return efx_filter_remove_id_safe(efx, EFX_FILTER_PRI_MANUAL,
+						 info->fs.location);
+
+	default:
+		return -EOPNOTSUPP;
+	}
+}
+
+static u32 efx_ethtool_get_rxfh_indir_size(struct net_device *net_dev)
+{
+	struct efx_nic *efx = netdev_priv(net_dev);
+
+	return ((efx_nic_rev(efx) < EFX_REV_FALCON_B0 ||
+		 efx->n_rx_channels == 1) ?
+		0 : ARRAY_SIZE(efx->rx_indir_table));
+}
+
+static int efx_ethtool_get_rxfh_indir(struct net_device *net_dev, u32 *indir)
+{
+	struct efx_nic *efx = netdev_priv(net_dev);
+
+	memcpy(indir, efx->rx_indir_table, sizeof(efx->rx_indir_table));
+	return 0;
+}
+
+static int
+efx_ethtool_set_rxfh_indir(struct net_device *net_dev, const u32 *indir)
+{
+	struct efx_nic *efx = netdev_priv(net_dev);
+
+	memcpy(efx->rx_indir_table, indir, sizeof(efx->rx_indir_table));
+	efx_nic_push_rx_indir_table(efx);
+	return 0;
+}
+
+#if defined(EFX_USE_KCOMPAT) && (!defined(EFX_HAVE_ETHTOOL_RXFH_INDIR) || defined(EFX_HAVE_OLD_ETHTOOL_RXFH_INDIR))
+#ifndef EFX_HAVE_ETHTOOL_RXFH_INDIR
+int efx_ethtool_old_get_rxfh_indir(struct net_device *net_dev,
+				   struct ethtool_rxfh_indir *indir)
+#else
+static int efx_ethtool_old_get_rxfh_indir(struct net_device *net_dev,
+					  struct ethtool_rxfh_indir *indir)
+#endif
+{
+	u32 user_size = indir->size, dev_size;
+
+	dev_size = efx_ethtool_get_rxfh_indir_size(net_dev);
+	if (dev_size == 0)
+		return -EOPNOTSUPP;
+
+	if (user_size < dev_size) {
+		indir->size = dev_size;
+		return user_size == 0 ? 0 : -EINVAL;
+	}
+
+	return efx_ethtool_get_rxfh_indir(net_dev, indir->ring_index);
+}
+
+#ifndef EFX_HAVE_ETHTOOL_RXFH_INDIR
+int efx_ethtool_old_set_rxfh_indir(struct net_device *net_dev,
+				   const struct ethtool_rxfh_indir *indir)
+#else
+static int efx_ethtool_old_set_rxfh_indir(struct net_device *net_dev,
+					  const struct ethtool_rxfh_indir *indir)
+#endif
+{
+	struct efx_nic *efx = netdev_priv(net_dev);
+	u32 user_size = indir->size, dev_size, i;
+
+	dev_size = efx_ethtool_get_rxfh_indir_size(net_dev);
+	if (dev_size == 0)
+		return -EOPNOTSUPP;
+
+	if (user_size != dev_size)
+		return -EINVAL;
+
+	/* Validate ring indices */
+	for (i = 0; i < dev_size; i++)
+		if (indir->ring_index[i] >= efx->n_rx_channels)
+			return -EINVAL;
+
+	return efx_ethtool_set_rxfh_indir(net_dev, indir->ring_index);
+}
+#endif
 
 const struct ethtool_ops efx_ethtool_ops = {
 	.get_settings		= efx_ethtool_get_settings,
 	.set_settings		= efx_ethtool_set_settings,
 	.get_drvinfo		= efx_ethtool_get_drvinfo,
+	.get_regs_len		= efx_ethtool_get_regs_len,
+	.get_regs		= efx_ethtool_get_regs,
+	.get_msglevel		= efx_ethtool_get_msglevel,
+	.set_msglevel		= efx_ethtool_set_msglevel,
 	.nway_reset		= efx_ethtool_nway_reset,
 	.get_link		= efx_ethtool_get_link,
-	.get_eeprom_len		= efx_ethtool_get_eeprom_len,
-	.get_eeprom		= efx_ethtool_get_eeprom,
-	.set_eeprom		= efx_ethtool_set_eeprom,
 	.get_coalesce		= efx_ethtool_get_coalesce,
 	.set_coalesce		= efx_ethtool_set_coalesce,
+	.get_ringparam		= efx_ethtool_get_ringparam,
+	.set_ringparam		= efx_ethtool_set_ringparam,
 	.get_pauseparam         = efx_ethtool_get_pauseparam,
 	.set_pauseparam         = efx_ethtool_set_pauseparam,
 	.get_rx_csum		= efx_ethtool_get_rx_csum,
 	.set_rx_csum		= efx_ethtool_set_rx_csum,
 	.get_tx_csum		= ethtool_op_get_tx_csum,
-	.set_tx_csum		= ethtool_op_set_tx_csum,
+	/* Need to enable/disable IPv6 too */
+	.set_tx_csum		= efx_ethtool_set_tx_csum,
 	.get_sg			= ethtool_op_get_sg,
 	.set_sg			= ethtool_op_set_sg,
 	.get_tso		= ethtool_op_get_tso,
-	.set_tso		= ethtool_op_set_tso,
+	/* Need to enable/disable TSO-IPv6 too */
+	.set_tso		= efx_ethtool_set_tso,
 	.get_flags		= ethtool_op_get_flags,
-	.set_flags		= ethtool_op_set_flags,
+	.set_flags		= efx_ethtool_set_flags,
 	.get_sset_count		= efx_ethtool_get_sset_count,
 	.self_test		= efx_ethtool_self_test,
 	.get_strings		= efx_ethtool_get_strings,
-	.phys_id		= efx_ethtool_phys_id,
+	.phys_id		= efx_ethtool_phys_id_loop,
 	.get_ethtool_stats	= efx_ethtool_get_stats,
+	.get_wol                = efx_ethtool_get_wol,
+	.set_wol                = efx_ethtool_set_wol,
+#if   defined(EFX_HAVE_ETHTOOL_RXNFC)
+	.get_rxnfc		= efx_ethtool_get_rxnfc_wrapper,
+	.set_rxnfc		= efx_ethtool_set_rxnfc_wrapper,
+#endif
+#if !defined(EFX_USE_KCOMPAT) || defined(EFX_HAVE_ETHTOOL_RXFH_INDIR)
+	.get_rxfh_indir_size	= efx_ethtool_get_rxfh_indir_size,
+	.get_rxfh_indir		= efx_ethtool_get_rxfh_indir,
+	.set_rxfh_indir		= efx_ethtool_set_rxfh_indir,
+#endif
 };
diff -r 9566a4a50a43 drivers/net/sfc/ethtool.h
--- a/drivers/net/sfc/ethtool.h
+++ /dev/null
@@ -1,27 +0,0 @@
-/****************************************************************************
- * Driver for Solarflare Solarstorm network controllers and boards
- * Copyright 2005 Fen Systems Ltd.
- * Copyright 2006 Solarflare Communications Inc.
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 as published
- * by the Free Software Foundation, incorporated herein by reference.
- */
-
-#ifndef EFX_ETHTOOL_H
-#define EFX_ETHTOOL_H
-
-#include "net_driver.h"
-
-/*
- * Ethtool support
- */
-
-extern int efx_ethtool_get_settings(struct net_device *net_dev,
-				    struct ethtool_cmd *ecmd);
-extern int efx_ethtool_set_settings(struct net_device *net_dev,
-				    struct ethtool_cmd *ecmd);
-
-extern const struct ethtool_ops efx_ethtool_ops;
-
-#endif /* EFX_ETHTOOL_H */
diff -r 9566a4a50a43 drivers/net/sfc/falcon.c
--- a/drivers/net/sfc/falcon.c
+++ b/drivers/net/sfc/falcon.c
@@ -1,7 +1,7 @@
 /****************************************************************************
  * Driver for Solarflare Solarstorm network controllers and boards
  * Copyright 2005-2006 Fen Systems Ltd.
- * Copyright 2006-2008 Solarflare Communications Inc.
+ * Copyright 2006-2010 Solarflare Communications Inc.
  *
  * This program is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 as published
@@ -14,79 +14,34 @@
 #include <linux/module.h>
 #include <linux/seq_file.h>
 #include <linux/i2c.h>
-#include <linux/i2c-algo-bit.h>
 #include <linux/mii.h>
+#include <linux/slab.h>
 #include "net_driver.h"
 #include "bitfield.h"
 #include "efx.h"
-#include "mac.h"
 #include "spi.h"
-#include "falcon.h"
-#include "falcon_hwdefs.h"
-#include "falcon_io.h"
-#include "mdio_10g.h"
+#include "nic.h"
+#include "regs.h"
+#include "io.h"
 #include "phy.h"
-#include "boards.h"
+#include "driverlink.h"
 #include "workarounds.h"
 
-/* Falcon hardware control.
- * Falcon is the internal codename for the SFC4000 controller that is
- * present in SFE400X evaluation boards
+/* Hardware control for SFC4000 (aka Falcon). */
+
+/*
+ * Override EEPROM/flash type from non-volatile configuration or GPIO;
+ * may need to be specified if bootstrapping from blank flash.
  */
-
-/**
- * struct falcon_nic_data - Falcon NIC state
- * @sram_cfg: SRAM configuration value
- * @tx_dc_base: Base address in SRAM of TX queue descriptor caches
- * @rx_dc_base: Base address in SRAM of RX queue descriptor caches
- * @next_buffer_table: First available buffer table id
- * @resources: Resource information for driverlink client
- * @pci_dev2: The secondary PCI device if present
- * @i2c_data: Operations and state for I2C bit-bashing algorithm
- * @int_error_count: Number of internal errors seen recently
- * @int_error_expire: Time at which error count will be expired
- */
-struct falcon_nic_data {
-	int sram_cfg;
-	unsigned tx_dc_base;
-	unsigned rx_dc_base;
-#ifndef CONFIG_SFC_DRIVERLINK
-	unsigned next_buffer_table;
-#else
-	struct efx_dl_falcon_resources resources;
-#endif
-	struct pci_dev *pci_dev2;
-	struct i2c_algo_bit_data i2c_data;
-
-	unsigned int_error_count;
-	unsigned long int_error_expire;
-};
-
-/**************************************************************************
- *
- * Configurable values
- *
- **************************************************************************
- */
-
-static int disable_dma_stats;
-
-/* This is set to 16 for a good reason.  In summary, if larger than
- * 16, the descriptor cache holds more than a default socket
- * buffer's worth of packets (for UDP we can only have at most one
- * socket buffer's worth outstanding).  This combined with the fact
- * that we only get 1 TX event per descriptor cache means the NIC
- * goes idle.
- */
-#define TX_DC_ENTRIES 16
-#define TX_DC_ENTRIES_ORDER 0
-#define TX_DC_INTERNAL_BASE 0x130000
-
-#define RX_DC_ENTRIES 64
-#define RX_DC_ENTRIES_ORDER 2
-#define RX_DC_INTERNAL_BASE 0x100000
+static unsigned int eeprom_type = -1;
+static unsigned int flash_type = -1;
 
 static const unsigned int
+/* "Small" EEPROM device: Atmel AT25040 or similar
+ * 512 B, 9-bit address, 8 B write block */
+small_eeprom_type = ((9 << SPI_DEV_TYPE_SIZE_LBN)
+		     | (1 << SPI_DEV_TYPE_ADDR_LEN_LBN)
+		     | (3 << SPI_DEV_TYPE_BLOCK_SIZE_LBN)),
 /* "Large" EEPROM device: Atmel AT25640 or similar
  * 8 KB, 16-bit address, 32 B write block */
 large_eeprom_type = ((13 << SPI_DEV_TYPE_SIZE_LBN)
@@ -100,102 +55,45 @@ default_flash_type = ((17 << SPI_DEV_TYP
 		      | (15 << SPI_DEV_TYPE_ERASE_SIZE_LBN)
 		      | (8 << SPI_DEV_TYPE_BLOCK_SIZE_LBN));
 
-/* RX FIFO XOFF watermark
- *
- * When the amount of the RX FIFO increases used increases past this
- * watermark send XOFF. Only used if RX flow control is enabled (ethtool -A)
- * This also has an effect on RX/TX arbitration
- */
-static int rx_xoff_thresh_bytes = -1;
-module_param(rx_xoff_thresh_bytes, int, 0644);
-MODULE_PARM_DESC(rx_xoff_thresh_bytes, "RX fifo XOFF threshold");
+/* Dummy SRAM configuration code */
+#define SRAM_CONFIG_INTERNAL (-1)
 
-/* RX FIFO XON watermark
- *
- * When the amount of the RX FIFO used decreases below this
- * watermark send XON. Only used if TX flow control is enabled (ethtool -A)
- * This also has an effect on RX/TX arbitration
- */
-static int rx_xon_thresh_bytes = -1;
-module_param(rx_xon_thresh_bytes, int, 0644);
-MODULE_PARM_DESC(rx_xon_thresh_bytes, "RX fifo XON threshold");
+/* Read dword from a Falcon PCIE core register */
+static void falcon_b0_pcie_core_read_reg(struct efx_nic *efx, int address,
+				      efx_dword_t *result)
+{
+	efx_oword_t temp;
 
-/* TX descriptor ring size - min 512 max 4k */
-#define FALCON_TXD_RING_ORDER TX_DESCQ_SIZE_1K
-#define FALCON_TXD_RING_SIZE 1024
-#define FALCON_TXD_RING_MASK (FALCON_TXD_RING_SIZE - 1)
+	BUG_ON(efx_nic_rev(efx) != EFX_REV_FALCON_B0);
+	BUG_ON(address & 3 || address < 0);
 
-/* RX descriptor ring size - min 512 max 4k */
-#define FALCON_RXD_RING_ORDER RX_DESCQ_SIZE_1K
-#define FALCON_RXD_RING_SIZE 1024
-#define FALCON_RXD_RING_MASK (FALCON_RXD_RING_SIZE - 1)
+	EFX_POPULATE_OWORD_1(temp, FRF_BB_PCIE_CORE_TARGET_REG_ADRS, address);
 
-/* Event queue size - max 32k */
-#define FALCON_EVQ_ORDER EVQ_SIZE_4K
-#define FALCON_EVQ_SIZE 4096
-#define FALCON_EVQ_MASK (FALCON_EVQ_SIZE - 1)
-
-/* If FALCON_MAX_INT_ERRORS internal errors occur within
- * FALCON_INT_ERROR_EXPIRE seconds, we consider the NIC broken and
- * disable it.
- */
-#define FALCON_INT_ERROR_EXPIRE 3600
-#define FALCON_MAX_INT_ERRORS 5
-
-/* We poll for events every FLUSH_INTERVAL ms, and check FLUSH_POLL_COUNT times
- */
-#define FALCON_FLUSH_INTERVAL 10
-#define FALCON_FLUSH_POLL_COUNT 100
-
-/**************************************************************************
- *
- * Falcon constants
- *
- **************************************************************************
- */
-
-/* DMA address mask */
-#define FALCON_DMA_MASK DMA_BIT_MASK(46)
-
-/* TX DMA length mask (13-bit) */
-#define FALCON_TX_DMA_MASK (4096 - 1)
-
-/* Size and alignment of special buffers (4KB) */
-#define FALCON_BUF_SIZE 4096
-
-/* Dummy SRAM size code */
-#define SRM_NB_BSZ_ONCHIP_ONLY (-1)
-
-#define FALCON_IS_DUAL_FUNC(efx)		\
-	(falcon_rev(efx) < FALCON_REV_B0)
-
-/**************************************************************************
- *
- * Falcon hardware access
- *
- **************************************************************************/
-
-/* Read the current event from the event queue */
-static inline efx_qword_t *falcon_event(struct efx_channel *channel,
-					unsigned int index)
-{
-	return (((efx_qword_t *) (channel->eventq.addr)) + index);
+	efx_writeo(efx, &temp, FR_BB_PCIE_CORE_INDIRECT);
+	efx_reado(efx, &temp, FR_BB_PCIE_CORE_INDIRECT);
+	/* Extract PCIE_CORE_VALUE without byte-swapping */
+	BUILD_BUG_ON(FRF_BB_PCIE_CORE_TARGET_DATA_LBN != 32 ||
+		     FRF_BB_PCIE_CORE_TARGET_DATA_WIDTH != 32);
+	result->u32[0] = temp.u32[1];
 }
 
-/* See if an event is present
- *
- * We check both the high and low dword of the event for all ones.  We
- * wrote all ones when we cleared the event, and no valid event can
- * have all ones in either its high or low dwords.  This approach is
- * robust against reordering.
- *
- * Note that using a single 64-bit comparison is incorrect; even
- * though the CPU read will be atomic, the DMA write may not be.
- */
-static inline int falcon_event_present(efx_qword_t *event)
+/* Write dword to a Falcon PCIE core register */
+static void falcon_b0_pcie_core_write_reg(struct efx_nic *efx, int address,
+				       efx_dword_t value)
 {
-	return (!(EFX_DWORD_IS_ALL_ONES(event->dword[0]) |
-		  EFX_DWORD_IS_ALL_ONES(event->dword[1])));
+	efx_oword_t temp;
+
+	BUG_ON(efx_nic_rev(efx) != EFX_REV_FALCON_B0);
+	BUG_ON(address & 0x3 || address < 0);
+
+	EFX_POPULATE_OWORD_2(temp,
+			     FRF_BB_PCIE_CORE_TARGET_REG_ADRS, address,
+			     FRF_BB_PCIE_CORE_INDIRECT_ACCESS_DIR, 1);
+	/* Fill PCIE_CORE_VALUE without byte-swapping */
+	BUILD_BUG_ON(FRF_BB_PCIE_CORE_TARGET_DATA_LBN != 32 ||
+		     FRF_BB_PCIE_CORE_TARGET_DATA_WIDTH != 32);
+	temp.u32[1] = value.u32[0];
+	efx_writeo(efx, &temp, FR_BB_PCIE_CORE_INDIRECT);
 }
 
 /**************************************************************************
@@ -211,9 +109,9 @@ static void falcon_setsda(void *data, in
 	struct efx_nic *efx = (struct efx_nic *)data;
 	efx_oword_t reg;
 
-	falcon_read(efx, &reg, GPIO_CTL_REG_KER);
-	EFX_SET_OWORD_FIELD(reg, GPIO3_OEN, !state);
-	falcon_write(efx, &reg, GPIO_CTL_REG_KER);
+	efx_reado(efx, &reg, FR_AB_GPIO_CTL);
+	EFX_SET_OWORD_FIELD(reg, FRF_AB_GPIO3_OEN, !state);
+	efx_writeo(efx, &reg, FR_AB_GPIO_CTL);
 }
 
 static void falcon_setscl(void *data, int state)
@@ -221,9 +119,9 @@ static void falcon_setscl(void *data, in
 	struct efx_nic *efx = (struct efx_nic *)data;
 	efx_oword_t reg;
 
-	falcon_read(efx, &reg, GPIO_CTL_REG_KER);
-	EFX_SET_OWORD_FIELD(reg, GPIO0_OEN, !state);
-	falcon_write(efx, &reg, GPIO_CTL_REG_KER);
+	efx_reado(efx, &reg, FR_AB_GPIO_CTL);
+	EFX_SET_OWORD_FIELD(reg, FRF_AB_GPIO0_OEN, !state);
+	efx_writeo(efx, &reg, FR_AB_GPIO_CTL);
 }
 
 static int falcon_getsda(void *data)
@@ -231,8 +129,8 @@ static int falcon_getsda(void *data)
 	struct efx_nic *efx = (struct efx_nic *)data;
 	efx_oword_t reg;
 
-	falcon_read(efx, &reg, GPIO_CTL_REG_KER);
-	return EFX_OWORD_FIELD(reg, GPIO3_IN);
+	efx_reado(efx, &reg, FR_AB_GPIO_CTL);
+	return EFX_OWORD_FIELD(reg, FRF_AB_GPIO3_IN);
 }
 
 static int falcon_getscl(void *data)
@@ -240,8 +138,8 @@ static int falcon_getscl(void *data)
 	struct efx_nic *efx = (struct efx_nic *)data;
 	efx_oword_t reg;
 
-	falcon_read(efx, &reg, GPIO_CTL_REG_KER);
-	return EFX_OWORD_FIELD(reg, GPIO0_IN);
+	efx_reado(efx, &reg, FR_AB_GPIO_CTL);
+	return EFX_OWORD_FIELD(reg, FRF_AB_GPIO0_IN);
 }
 
 static struct i2c_algo_bit_data falcon_i2c_bit_operations = {
@@ -254,1151 +152,39 @@ static struct i2c_algo_bit_data falcon_i
 	.timeout	= DIV_ROUND_UP(HZ, 20),
 };
 
-/**************************************************************************
- *
- * Falcon special buffer handling
- * Special buffers are used for event queues and the TX and RX
- * descriptor rings.
- *
- *************************************************************************/
-
-/*
- * Initialise a Falcon special buffer
- *
- * This will define a buffer (previously allocated via
- * falcon_alloc_special_buffer()) in Falcon's buffer table, allowing
- * it to be used for event queues, descriptor rings etc.
- */
-static void
-falcon_init_special_buffer(struct efx_nic *efx,
-			   struct efx_special_buffer *buffer)
-{
-	efx_qword_t buf_desc;
-	int index;
-	dma_addr_t dma_addr;
-	int i;
-
-	EFX_BUG_ON_PARANOID(!buffer->addr);
-
-	/* Write buffer descriptors to NIC */
-	for (i = 0; i < buffer->entries; i++) {
-		index = buffer->index + i;
-		dma_addr = buffer->dma_addr + (i * 4096);
-		EFX_LOG(efx, "mapping special buffer %d at %llx\n",
-			index, (unsigned long long)dma_addr);
-		EFX_POPULATE_QWORD_4(buf_desc,
-				     IP_DAT_BUF_SIZE, IP_DAT_BUF_SIZE_4K,
-				     BUF_ADR_REGION, 0,
-				     BUF_ADR_FBUF, (dma_addr >> 12),
-				     BUF_OWNER_ID_FBUF, 0);
-		falcon_write_sram(efx, &buf_desc, index);
-	}
-}
-
-/* Unmaps a buffer from Falcon and clears the buffer table entries */
-static void
-falcon_fini_special_buffer(struct efx_nic *efx,
-			   struct efx_special_buffer *buffer)
-{
-	efx_oword_t buf_tbl_upd;
-	unsigned int start = buffer->index;
-	unsigned int end = (buffer->index + buffer->entries - 1);
-
-	if (!buffer->entries)
-		return;
-
-	EFX_LOG(efx, "unmapping special buffers %d-%d\n",
-		buffer->index, buffer->index + buffer->entries - 1);
-
-	EFX_POPULATE_OWORD_4(buf_tbl_upd,
-			     BUF_UPD_CMD, 0,
-			     BUF_CLR_CMD, 1,
-			     BUF_CLR_END_ID, end,
-			     BUF_CLR_START_ID, start);
-	falcon_write(efx, &buf_tbl_upd, BUF_TBL_UPD_REG_KER);
-}
-
-/*
- * Allocate a new Falcon special buffer
- *
- * This allocates memory for a new buffer, clears it and allocates a
- * new buffer ID range.  It does not write into Falcon's buffer table.
- *
- * This call will allocate 4KB buffers, since Falcon can't use 8KB
- * buffers for event queues and descriptor rings.
- */
-static int falcon_alloc_special_buffer(struct efx_nic *efx,
-				       struct efx_special_buffer *buffer,
-				       unsigned int len)
-{
-	struct falcon_nic_data *nic_data = efx->nic_data;
-
-	len = ALIGN(len, FALCON_BUF_SIZE);
-
-	buffer->addr = pci_alloc_consistent(efx->pci_dev, len,
-					    &buffer->dma_addr);
-	if (!buffer->addr)
-		return -ENOMEM;
-	buffer->len = len;
-	buffer->entries = len / FALCON_BUF_SIZE;
-	BUG_ON(buffer->dma_addr & (FALCON_BUF_SIZE - 1));
-
-	/* All zeros is a potentially valid event so memset to 0xff */
-	memset(buffer->addr, 0xff, len);
-
-	/* Select new buffer ID */
-#ifndef CONFIG_SFC_DRIVERLINK
-	buffer->index = nic_data->next_buffer_table;
-	nic_data->next_buffer_table += buffer->entries;
-#else
-	buffer->index = nic_data->resources.buffer_table_min;
-	nic_data->resources.buffer_table_min += buffer->entries;
-#endif
-
-	EFX_LOG(efx, "allocating special buffers %d-%d at %llx+%x "
-		"(virt %p phys %llx)\n", buffer->index,
-		buffer->index + buffer->entries - 1,
-		(u64)buffer->dma_addr, len,
-		buffer->addr, (u64)virt_to_phys(buffer->addr));
-
-	return 0;
-}
-
-static void falcon_free_special_buffer(struct efx_nic *efx,
-				       struct efx_special_buffer *buffer)
-{
-	if (!buffer->addr)
-		return;
-
-	EFX_LOG(efx, "deallocating special buffers %d-%d at %llx+%x "
-		"(virt %p phys %llx)\n", buffer->index,
-		buffer->index + buffer->entries - 1,
-		(u64)buffer->dma_addr, buffer->len,
-		buffer->addr, (u64)virt_to_phys(buffer->addr));
-
-	pci_free_consistent(efx->pci_dev, buffer->len, buffer->addr,
-			    buffer->dma_addr);
-	buffer->addr = NULL;
-	buffer->entries = 0;
-}
-
-/**************************************************************************
- *
- * Falcon generic buffer handling
- * These buffers are used for interrupt status and MAC stats
- *
- **************************************************************************/
-
-static int falcon_alloc_buffer(struct efx_nic *efx,
-			       struct efx_buffer *buffer, unsigned int len)
-{
-	buffer->addr = pci_alloc_consistent(efx->pci_dev, len,
-					    &buffer->dma_addr);
-	if (!buffer->addr)
-		return -ENOMEM;
-	buffer->len = len;
-	memset(buffer->addr, 0, len);
-	return 0;
-}
-
-static void falcon_free_buffer(struct efx_nic *efx, struct efx_buffer *buffer)
-{
-	if (buffer->addr) {
-		pci_free_consistent(efx->pci_dev, buffer->len,
-				    buffer->addr, buffer->dma_addr);
-		buffer->addr = NULL;
-	}
-}
-
-/**************************************************************************
- *
- * Falcon TX path
- *
- **************************************************************************/
-
-/* Returns a pointer to the specified transmit descriptor in the TX
- * descriptor queue belonging to the specified channel.
- */
-static inline efx_qword_t *falcon_tx_desc(struct efx_tx_queue *tx_queue,
-					       unsigned int index)
-{
-	return (((efx_qword_t *) (tx_queue->txd.addr)) + index);
-}
-
-/* This writes to the TX_DESC_WPTR; write pointer for TX descriptor ring */
-static inline void falcon_notify_tx_desc(struct efx_tx_queue *tx_queue)
-{
-	unsigned write_ptr;
-	efx_dword_t reg;
-
-	write_ptr = tx_queue->write_count & FALCON_TXD_RING_MASK;
-	EFX_POPULATE_DWORD_1(reg, TX_DESC_WPTR_DWORD, write_ptr);
-	falcon_writel_page(tx_queue->efx, &reg,
-			   TX_DESC_UPD_REG_KER_DWORD, tx_queue->queue);
-}
-
-
-/* For each entry inserted into the software descriptor ring, create a
- * descriptor in the hardware TX descriptor ring (in host memory), and
- * write a doorbell.
- */
-void falcon_push_buffers(struct efx_tx_queue *tx_queue)
-{
-
-	struct efx_tx_buffer *buffer;
-	efx_qword_t *txd;
-	unsigned write_ptr;
-
-	BUG_ON(tx_queue->write_count == tx_queue->insert_count);
-
-	do {
-		write_ptr = tx_queue->write_count & FALCON_TXD_RING_MASK;
-		buffer = &tx_queue->buffer[write_ptr];
-		txd = falcon_tx_desc(tx_queue, write_ptr);
-		++tx_queue->write_count;
-
-		/* Create TX descriptor ring entry */
-		EFX_POPULATE_QWORD_5(*txd,
-				     TX_KER_PORT, 0,
-				     TX_KER_CONT, buffer->continuation,
-				     TX_KER_BYTE_CNT, buffer->len,
-				     TX_KER_BUF_REGION, 0,
-				     TX_KER_BUF_ADR, buffer->dma_addr);
-	} while (tx_queue->write_count != tx_queue->insert_count);
-
-	wmb(); /* Ensure descriptors are written before they are fetched */
-	falcon_notify_tx_desc(tx_queue);
-}
-
-/* Allocate hardware resources for a TX queue */
-int falcon_probe_tx(struct efx_tx_queue *tx_queue)
-{
-	struct efx_nic *efx = tx_queue->efx;
-	int rc = falcon_alloc_special_buffer(efx, &tx_queue->txd,
-					    FALCON_TXD_RING_SIZE *
-					    sizeof(efx_qword_t));
-#ifdef CONFIG_SFC_DRIVERLINK
-	if (rc == 0) {
-		struct falcon_nic_data *nic_data = efx->nic_data;
-		nic_data->resources.txq_min = max(nic_data->resources.txq_min,
-						  (unsigned)tx_queue->queue + 1);
-	}
-#endif
-	return rc;
-}
-
-void falcon_init_tx(struct efx_tx_queue *tx_queue)
-{
-	efx_oword_t tx_desc_ptr;
-	struct efx_nic *efx = tx_queue->efx;
-
-	tx_queue->flushed = false;
-
-	/* Pin TX descriptor ring */
-	falcon_init_special_buffer(efx, &tx_queue->txd);
-
-	/* Push TX descriptor ring to card */
-	EFX_POPULATE_OWORD_10(tx_desc_ptr,
-			      TX_DESCQ_EN, 1,
-			      TX_ISCSI_DDIG_EN, 0,
-			      TX_ISCSI_HDIG_EN, 0,
-			      TX_DESCQ_BUF_BASE_ID, tx_queue->txd.index,
-			      TX_DESCQ_EVQ_ID, tx_queue->channel->channel,
-			      TX_DESCQ_OWNER_ID, 0,
-			      TX_DESCQ_LABEL, tx_queue->queue,
-			      TX_DESCQ_SIZE, FALCON_TXD_RING_ORDER,
-			      TX_DESCQ_TYPE, 0,
-			      TX_NON_IP_DROP_DIS_B0, 1);
-
-	if (falcon_rev(efx) >= FALCON_REV_B0) {
-		int csum = tx_queue->queue == EFX_TX_QUEUE_OFFLOAD_CSUM;
-		EFX_SET_OWORD_FIELD(tx_desc_ptr, TX_IP_CHKSM_DIS_B0, !csum);
-		EFX_SET_OWORD_FIELD(tx_desc_ptr, TX_TCP_CHKSM_DIS_B0, !csum);
-	}
-
-	falcon_write_table(efx, &tx_desc_ptr, efx->type->txd_ptr_tbl_base,
-			   tx_queue->queue);
-
-	if (falcon_rev(efx) < FALCON_REV_B0) {
-		efx_oword_t reg;
-
-		/* Only 128 bits in this register */
-		BUILD_BUG_ON(EFX_TX_QUEUE_COUNT >= 128);
-
-		falcon_read(efx, &reg, TX_CHKSM_CFG_REG_KER_A1);
-		if (tx_queue->queue == EFX_TX_QUEUE_OFFLOAD_CSUM)
-			clear_bit_le(tx_queue->queue, (void *)&reg);
-		else
-			set_bit_le(tx_queue->queue, (void *)&reg);
-		falcon_write(efx, &reg, TX_CHKSM_CFG_REG_KER_A1);
-	}
-}
-
-static void falcon_flush_tx_queue(struct efx_tx_queue *tx_queue)
-{
-	struct efx_nic *efx = tx_queue->efx;
-	efx_oword_t tx_flush_descq;
-
-	/* Post a flush command */
-	EFX_POPULATE_OWORD_2(tx_flush_descq,
-			     TX_FLUSH_DESCQ_CMD, 1,
-			     TX_FLUSH_DESCQ, tx_queue->queue);
-	falcon_write(efx, &tx_flush_descq, TX_FLUSH_DESCQ_REG_KER);
-}
-
-void falcon_fini_tx(struct efx_tx_queue *tx_queue)
-{
-	struct efx_nic *efx = tx_queue->efx;
-	efx_oword_t tx_desc_ptr;
-
-	/* The queue should have been flushed */
-	WARN_ON(!tx_queue->flushed);
-
-	/* Remove TX descriptor ring from card */
-	EFX_ZERO_OWORD(tx_desc_ptr);
-	falcon_write_table(efx, &tx_desc_ptr, efx->type->txd_ptr_tbl_base,
-			   tx_queue->queue);
-
-	/* Unpin TX descriptor ring */
-	falcon_fini_special_buffer(efx, &tx_queue->txd);
-}
-
-/* Free buffers backing TX queue */
-void falcon_remove_tx(struct efx_tx_queue *tx_queue)
-{
-	falcon_free_special_buffer(tx_queue->efx, &tx_queue->txd);
-}
-
-/**************************************************************************
- *
- * Falcon RX path
- *
- **************************************************************************/
-
-/* Returns a pointer to the specified descriptor in the RX descriptor queue */
-static inline efx_qword_t *falcon_rx_desc(struct efx_rx_queue *rx_queue,
-					       unsigned int index)
-{
-	return (((efx_qword_t *) (rx_queue->rxd.addr)) + index);
-}
-
-/* This creates an entry in the RX descriptor queue */
-static inline void falcon_build_rx_desc(struct efx_rx_queue *rx_queue,
-					unsigned index)
-{
-	struct efx_rx_buffer *rx_buf;
-	efx_qword_t *rxd;
-
-	rxd = falcon_rx_desc(rx_queue, index);
-	rx_buf = efx_rx_buffer(rx_queue, index);
-	EFX_POPULATE_QWORD_3(*rxd,
-			     RX_KER_BUF_SIZE,
-			     rx_buf->len -
-			     rx_queue->efx->type->rx_buffer_padding,
-			     RX_KER_BUF_REGION, 0,
-			     RX_KER_BUF_ADR, rx_buf->dma_addr);
-}
-
-/* This writes to the RX_DESC_WPTR register for the specified receive
- * descriptor ring.
- */
-void falcon_notify_rx_desc(struct efx_rx_queue *rx_queue)
-{
-	efx_dword_t reg;
-	unsigned write_ptr;
-
-	while (rx_queue->notified_count != rx_queue->added_count) {
-		falcon_build_rx_desc(rx_queue,
-				     rx_queue->notified_count &
-				     FALCON_RXD_RING_MASK);
-		++rx_queue->notified_count;
-	}
-
-	wmb();
-	write_ptr = rx_queue->added_count & FALCON_RXD_RING_MASK;
-	EFX_POPULATE_DWORD_1(reg, RX_DESC_WPTR_DWORD, write_ptr);
-	falcon_writel_page(rx_queue->efx, &reg,
-			   RX_DESC_UPD_REG_KER_DWORD, rx_queue->queue);
-}
-
-int falcon_probe_rx(struct efx_rx_queue *rx_queue)
-{
-	struct efx_nic *efx = rx_queue->efx;
-	int rc = falcon_alloc_special_buffer(efx, &rx_queue->rxd,
-					    FALCON_RXD_RING_SIZE *
-					    sizeof(efx_qword_t));
-#ifdef CONFIG_SFC_DRIVERLINK
-	if (rc == 0) {
-		struct falcon_nic_data *nic_data = efx->nic_data;
-		nic_data->resources.rxq_min = max(nic_data->resources.rxq_min,
-						  (unsigned)rx_queue->queue + 1);
-	}
-#endif
-	return rc;
-}
-
-void falcon_init_rx(struct efx_rx_queue *rx_queue)
-{
-	efx_oword_t rx_desc_ptr;
-	struct efx_nic *efx = rx_queue->efx;
-	bool is_b0 = falcon_rev(efx) >= FALCON_REV_B0;
-	bool iscsi_digest_en = is_b0;
-
-	EFX_LOG(efx, "RX queue %d ring in special buffers %d-%d\n",
-		rx_queue->queue, rx_queue->rxd.index,
-		rx_queue->rxd.index + rx_queue->rxd.entries - 1);
-
-	rx_queue->flushed = false;
-
-	/* Pin RX descriptor ring */
-	falcon_init_special_buffer(efx, &rx_queue->rxd);
-
-	/* Push RX descriptor ring to card */
-	EFX_POPULATE_OWORD_10(rx_desc_ptr,
-			      RX_ISCSI_DDIG_EN, iscsi_digest_en,
-			      RX_ISCSI_HDIG_EN, iscsi_digest_en,
-			      RX_DESCQ_BUF_BASE_ID, rx_queue->rxd.index,
-			      RX_DESCQ_EVQ_ID, rx_queue->channel->channel,
-			      RX_DESCQ_OWNER_ID, 0,
-			      RX_DESCQ_LABEL, rx_queue->queue,
-			      RX_DESCQ_SIZE, FALCON_RXD_RING_ORDER,
-			      RX_DESCQ_TYPE, 0 /* kernel queue */ ,
-			      /* For >=B0 this is scatter so disable */
-			      RX_DESCQ_JUMBO, !is_b0,
-			      RX_DESCQ_EN, 1);
-	falcon_write_table(efx, &rx_desc_ptr, efx->type->rxd_ptr_tbl_base,
-			   rx_queue->queue);
-}
-
-static void falcon_flush_rx_queue(struct efx_rx_queue *rx_queue)
-{
-	struct efx_nic *efx = rx_queue->efx;
-	efx_oword_t rx_flush_descq;
-
-	/* Post a flush command */
-	EFX_POPULATE_OWORD_2(rx_flush_descq,
-			     RX_FLUSH_DESCQ_CMD, 1,
-			     RX_FLUSH_DESCQ, rx_queue->queue);
-	falcon_write(efx, &rx_flush_descq, RX_FLUSH_DESCQ_REG_KER);
-}
-
-void falcon_fini_rx(struct efx_rx_queue *rx_queue)
-{
-	efx_oword_t rx_desc_ptr;
-	struct efx_nic *efx = rx_queue->efx;
-
-	/* The queue should already have been flushed */
-	WARN_ON(!rx_queue->flushed);
-
-	/* Remove RX descriptor ring from card */
-	EFX_ZERO_OWORD(rx_desc_ptr);
-	falcon_write_table(efx, &rx_desc_ptr, efx->type->rxd_ptr_tbl_base,
-			   rx_queue->queue);
-
-	/* Unpin RX descriptor ring */
-	falcon_fini_special_buffer(efx, &rx_queue->rxd);
-}
-
-/* Free buffers backing RX queue */
-void falcon_remove_rx(struct efx_rx_queue *rx_queue)
-{
-	falcon_free_special_buffer(rx_queue->efx, &rx_queue->rxd);
-}
-
-/**************************************************************************
- *
- * Falcon event queue processing
- * Event queues are processed by per-channel tasklets.
- *
- **************************************************************************/
-
-/* Update a channel's event queue's read pointer (RPTR) register
- *
- * This writes the EVQ_RPTR_REG register for the specified channel's
- * event queue.
- *
- * Note that EVQ_RPTR_REG contains the index of the "last read" event,
- * whereas channel->eventq_read_ptr contains the index of the "next to
- * read" event.
- */
-void falcon_eventq_read_ack(struct efx_channel *channel)
-{
-	efx_dword_t reg;
-	struct efx_nic *efx = channel->efx;
-
-	EFX_POPULATE_DWORD_1(reg, EVQ_RPTR_DWORD, channel->eventq_read_ptr);
-	falcon_writel_table(efx, &reg, efx->type->evq_rptr_tbl_base,
-			    channel->channel);
-}
-
-/* Use HW to insert a SW defined event */
-void falcon_generate_event(struct efx_channel *channel, efx_qword_t *event)
-{
-	efx_oword_t drv_ev_reg;
-
-	EFX_POPULATE_OWORD_2(drv_ev_reg,
-			     DRV_EV_QID, channel->channel,
-			     DRV_EV_DATA,
-			     EFX_QWORD_FIELD64(*event, WHOLE_EVENT));
-	falcon_write(channel->efx, &drv_ev_reg, DRV_EV_REG_KER);
-}
-
-/* Handle a transmit completion event
- *
- * Falcon batches TX completion events; the message we receive is of
- * the form "complete all TX events up to this index".
- */
-static void falcon_handle_tx_event(struct efx_channel *channel,
-				   efx_qword_t *event)
-{
-	unsigned int tx_ev_desc_ptr;
-	unsigned int tx_ev_q_label;
-	struct efx_tx_queue *tx_queue;
-	struct efx_nic *efx = channel->efx;
-
-	if (likely(EFX_QWORD_FIELD(*event, TX_EV_COMP))) {
-		/* Transmit completion */
-		tx_ev_desc_ptr = EFX_QWORD_FIELD(*event, TX_EV_DESC_PTR);
-		tx_ev_q_label = EFX_QWORD_FIELD(*event, TX_EV_Q_LABEL);
-		tx_queue = &efx->tx_queue[tx_ev_q_label];
-		channel->irq_mod_score +=
-			(tx_ev_desc_ptr - tx_queue->read_count) &
-			efx->type->txd_ring_mask;
-		efx_xmit_done(tx_queue, tx_ev_desc_ptr);
-	} else if (EFX_QWORD_FIELD(*event, TX_EV_WQ_FF_FULL)) {
-		/* Rewrite the FIFO write pointer */
-		tx_ev_q_label = EFX_QWORD_FIELD(*event, TX_EV_Q_LABEL);
-		tx_queue = &efx->tx_queue[tx_ev_q_label];
-
-		if (efx_dev_registered(efx))
-			netif_tx_lock(efx->net_dev);
-		falcon_notify_tx_desc(tx_queue);
-		if (efx_dev_registered(efx))
-			netif_tx_unlock(efx->net_dev);
-	} else if (EFX_QWORD_FIELD(*event, TX_EV_PKT_ERR) &&
-		   EFX_WORKAROUND_10727(efx)) {
-		efx_schedule_reset(efx, RESET_TYPE_TX_DESC_FETCH);
-	} else {
-		EFX_ERR(efx, "channel %d unexpected TX event "
-			EFX_QWORD_FMT"\n", channel->channel,
-			EFX_QWORD_VAL(*event));
-	}
-}
-
-/* Detect errors included in the rx_evt_pkt_ok bit. */
-static void falcon_handle_rx_not_ok(struct efx_rx_queue *rx_queue,
-				    const efx_qword_t *event,
-				    bool *rx_ev_pkt_ok,
-				    bool *discard)
-{
-	struct efx_nic *efx = rx_queue->efx;
-	bool rx_ev_buf_owner_id_err, rx_ev_ip_hdr_chksum_err;
-	bool rx_ev_tcp_udp_chksum_err, rx_ev_eth_crc_err;
-	bool rx_ev_frm_trunc, rx_ev_drib_nib, rx_ev_tobe_disc;
-	bool rx_ev_other_err, rx_ev_pause_frm;
-	bool rx_ev_ip_frag_err, rx_ev_hdr_type, rx_ev_mcast_pkt;
-	unsigned rx_ev_pkt_type;
-
-	rx_ev_hdr_type = EFX_QWORD_FIELD(*event, RX_EV_HDR_TYPE);
-	rx_ev_mcast_pkt = EFX_QWORD_FIELD(*event, RX_EV_MCAST_PKT);
-	rx_ev_tobe_disc = EFX_QWORD_FIELD(*event, RX_EV_TOBE_DISC);
-	rx_ev_pkt_type = EFX_QWORD_FIELD(*event, RX_EV_PKT_TYPE);
-	rx_ev_buf_owner_id_err = EFX_QWORD_FIELD(*event,
-						 RX_EV_BUF_OWNER_ID_ERR);
-	rx_ev_ip_frag_err = EFX_QWORD_FIELD(*event, RX_EV_IF_FRAG_ERR);
-	rx_ev_ip_hdr_chksum_err = EFX_QWORD_FIELD(*event,
-						  RX_EV_IP_HDR_CHKSUM_ERR);
-	rx_ev_tcp_udp_chksum_err = EFX_QWORD_FIELD(*event,
-						   RX_EV_TCP_UDP_CHKSUM_ERR);
-	rx_ev_eth_crc_err = EFX_QWORD_FIELD(*event, RX_EV_ETH_CRC_ERR);
-	rx_ev_frm_trunc = EFX_QWORD_FIELD(*event, RX_EV_FRM_TRUNC);
-	rx_ev_drib_nib = ((falcon_rev(efx) >= FALCON_REV_B0) ?
-			  0 : EFX_QWORD_FIELD(*event, RX_EV_DRIB_NIB));
-	rx_ev_pause_frm = EFX_QWORD_FIELD(*event, RX_EV_PAUSE_FRM_ERR);
-
-	/* Every error apart from tobe_disc and pause_frm */
-	rx_ev_other_err = (rx_ev_drib_nib | rx_ev_tcp_udp_chksum_err |
-			   rx_ev_buf_owner_id_err | rx_ev_eth_crc_err |
-			   rx_ev_frm_trunc | rx_ev_ip_hdr_chksum_err);
-
-	/* Count errors that are not in MAC stats.  Ignore expected
-	 * checksum errors during self-test. */
-	if (rx_ev_frm_trunc)
-		++rx_queue->channel->n_rx_frm_trunc;
-	else if (rx_ev_tobe_disc)
-		++rx_queue->channel->n_rx_tobe_disc;
-	else if (!efx->loopback_selftest) {
-		if (rx_ev_ip_hdr_chksum_err)
-			++rx_queue->channel->n_rx_ip_hdr_chksum_err;
-		else if (rx_ev_tcp_udp_chksum_err)
-			++rx_queue->channel->n_rx_tcp_udp_chksum_err;
-	}
-	if (rx_ev_ip_frag_err)
-		++rx_queue->channel->n_rx_ip_frag_err;
-
-	/* The frame must be discarded if any of these are true. */
-	*discard = (rx_ev_eth_crc_err | rx_ev_frm_trunc | rx_ev_drib_nib |
-		    rx_ev_tobe_disc | rx_ev_pause_frm);
-
-	/* TOBE_DISC is expected on unicast mismatches; don't print out an
-	 * error message.  FRM_TRUNC indicates RXDP dropped the packet due
-	 * to a FIFO overflow.
-	 */
-#ifdef EFX_ENABLE_DEBUG
-	if (rx_ev_other_err) {
-		EFX_INFO_RL(efx, " RX queue %d unexpected RX event "
-			    EFX_QWORD_FMT "%s%s%s%s%s%s%s%s\n",
-			    rx_queue->queue, EFX_QWORD_VAL(*event),
-			    rx_ev_buf_owner_id_err ? " [OWNER_ID_ERR]" : "",
-			    rx_ev_ip_hdr_chksum_err ?
-			    " [IP_HDR_CHKSUM_ERR]" : "",
-			    rx_ev_tcp_udp_chksum_err ?
-			    " [TCP_UDP_CHKSUM_ERR]" : "",
-			    rx_ev_eth_crc_err ? " [ETH_CRC_ERR]" : "",
-			    rx_ev_frm_trunc ? " [FRM_TRUNC]" : "",
-			    rx_ev_drib_nib ? " [DRIB_NIB]" : "",
-			    rx_ev_tobe_disc ? " [TOBE_DISC]" : "",
-			    rx_ev_pause_frm ? " [PAUSE]" : "");
-	}
-#endif
-}
-
-/* Handle receive events that are not in-order. */
-static void falcon_handle_rx_bad_index(struct efx_rx_queue *rx_queue,
-				       unsigned index)
-{
-	struct efx_nic *efx = rx_queue->efx;
-	unsigned expected, dropped;
-
-	expected = rx_queue->removed_count & FALCON_RXD_RING_MASK;
-	dropped = ((index + FALCON_RXD_RING_SIZE - expected) &
-		   FALCON_RXD_RING_MASK);
-	EFX_INFO(efx, "dropped %d events (index=%d expected=%d)\n",
-		dropped, index, expected);
-
-	efx_schedule_reset(efx, EFX_WORKAROUND_5676(efx) ?
-			   RESET_TYPE_RX_RECOVERY : RESET_TYPE_DISABLE);
-}
-
-/* Handle a packet received event
- *
- * Falcon silicon gives a "discard" flag if it's a unicast packet with the
- * wrong destination address
- * Also "is multicast" and "matches multicast filter" flags can be used to
- * discard non-matching multicast packets.
- */
-static void falcon_handle_rx_event(struct efx_channel *channel,
-				   const efx_qword_t *event)
-{
-	unsigned int rx_ev_desc_ptr, rx_ev_byte_cnt;
-	unsigned int rx_ev_hdr_type, rx_ev_mcast_pkt;
-	unsigned expected_ptr;
-	bool rx_ev_pkt_ok, discard = false, checksummed;
-	struct efx_rx_queue *rx_queue;
-	struct efx_nic *efx = channel->efx;
-
-	/* Basic packet information */
-	rx_ev_byte_cnt = EFX_QWORD_FIELD(*event, RX_EV_BYTE_CNT);
-	rx_ev_pkt_ok = EFX_QWORD_FIELD(*event, RX_EV_PKT_OK);
-	rx_ev_hdr_type = EFX_QWORD_FIELD(*event, RX_EV_HDR_TYPE);
-	WARN_ON(EFX_QWORD_FIELD(*event, RX_EV_JUMBO_CONT));
-	WARN_ON(EFX_QWORD_FIELD(*event, RX_EV_SOP) != 1);
-	WARN_ON(EFX_QWORD_FIELD(*event, RX_EV_Q_LABEL) != channel->channel);
-
-	rx_queue = &efx->rx_queue[channel->channel];
-
-	rx_ev_desc_ptr = EFX_QWORD_FIELD(*event, RX_EV_DESC_PTR);
-	expected_ptr = rx_queue->removed_count & FALCON_RXD_RING_MASK;
-	if (unlikely(rx_ev_desc_ptr != expected_ptr))
-		falcon_handle_rx_bad_index(rx_queue, rx_ev_desc_ptr);
-
-	if (likely(rx_ev_pkt_ok)) {
-		/* If packet is marked as OK and packet type is TCP/IPv4 or
-		 * UDP/IPv4, then we can rely on the hardware checksum.
-		 */
-		checksummed = RX_EV_HDR_TYPE_HAS_CHECKSUMS(rx_ev_hdr_type);
-	} else {
-		falcon_handle_rx_not_ok(rx_queue, event, &rx_ev_pkt_ok,
-					&discard);
-		checksummed = false;
-	}
-
-	/* Detect multicast packets that didn't match the filter */
-	rx_ev_mcast_pkt = EFX_QWORD_FIELD(*event, RX_EV_MCAST_PKT);
-	if (rx_ev_mcast_pkt) {
-		unsigned int rx_ev_mcast_hash_match =
-			EFX_QWORD_FIELD(*event, RX_EV_MCAST_HASH_MATCH);
-
-		if (unlikely(!rx_ev_mcast_hash_match))
-			discard = true;
-	}
-
-	channel->irq_mod_score += 2;
-
-	/* Handle received packet */
-	efx_rx_packet(rx_queue, rx_ev_desc_ptr, rx_ev_byte_cnt,
-		      checksummed, discard);
-}
-
-/* Global events are basically PHY events */
-static void falcon_handle_global_event(struct efx_channel *channel,
-				       efx_qword_t *event)
-{
-	struct efx_nic *efx = channel->efx;
-	bool handled = false;
-
-	if (EFX_QWORD_FIELD(*event, G_PHY0_INTR) ||
-	    EFX_QWORD_FIELD(*event, G_PHY1_INTR) ||
-	    EFX_QWORD_FIELD(*event, XG_PHY_INTR) ||
-	    EFX_QWORD_FIELD(*event, XFP_PHY_INTR)) {
-		efx->phy_op->clear_interrupt(efx);
-		queue_work(efx->workqueue, &efx->phy_work);
-		handled = true;
-	}
-
-	if ((falcon_rev(efx) >= FALCON_REV_B0) &&
-	    EFX_QWORD_FIELD(*event, XG_MNT_INTR_B0)) {
-		queue_work(efx->workqueue, &efx->mac_work);
-		handled = true;
-	}
-
-	if (EFX_QWORD_FIELD_VER(efx, *event, RX_RECOVERY)) {
-		EFX_ERR(efx, "channel %d seen global RX_RESET "
-			"event. Resetting.\n", channel->channel);
-
-		atomic_inc(&efx->rx_reset);
-		efx_schedule_reset(efx, EFX_WORKAROUND_6555(efx) ?
-				   RESET_TYPE_RX_RECOVERY : RESET_TYPE_DISABLE);
-		handled = true;
-	}
-
-	if (!handled)
-		EFX_ERR(efx, "channel %d unknown global event "
-			EFX_QWORD_FMT "\n", channel->channel,
-			EFX_QWORD_VAL(*event));
-}
-
-static void falcon_handle_driver_event(struct efx_channel *channel,
-				       efx_qword_t *event)
-{
-	struct efx_nic *efx = channel->efx;
-	unsigned int ev_sub_code;
-	unsigned int ev_sub_data;
-
-	ev_sub_code = EFX_QWORD_FIELD(*event, DRIVER_EV_SUB_CODE);
-	ev_sub_data = EFX_QWORD_FIELD(*event, DRIVER_EV_SUB_DATA);
-
-	switch (ev_sub_code) {
-	case TX_DESCQ_FLS_DONE_EV_DECODE:
-		EFX_TRACE(efx, "channel %d TXQ %d flushed\n",
-			  channel->channel, ev_sub_data);
-		EFX_DL_CALLBACK(efx, event, event);
-		break;
-	case RX_DESCQ_FLS_DONE_EV_DECODE:
-		EFX_TRACE(efx, "channel %d RXQ %d flushed\n",
-			  channel->channel, ev_sub_data);
-		EFX_DL_CALLBACK(efx, event, event);
-		break;
-	case EVQ_INIT_DONE_EV_DECODE:
-		EFX_LOG(efx, "channel %d EVQ %d initialised\n",
-			channel->channel, ev_sub_data);
-		break;
-	case SRM_UPD_DONE_EV_DECODE:
-		EFX_TRACE(efx, "channel %d SRAM update done\n",
-			  channel->channel);
-		EFX_DL_CALLBACK(efx, event, event);
-		break;
-	case WAKE_UP_EV_DECODE:
-		EFX_TRACE(efx, "channel %d RXQ %d wakeup event\n",
-			  channel->channel, ev_sub_data);
-		EFX_DL_CALLBACK(efx, event, event);
-		break;
-	case TIMER_EV_DECODE:
-		EFX_TRACE(efx, "channel %d RX queue %d timer expired\n",
-			  channel->channel, ev_sub_data);
-		EFX_DL_CALLBACK(efx, event, event);
-		break;
-	case RX_RECOVERY_EV_DECODE:
-		EFX_ERR(efx, "channel %d seen DRIVER RX_RESET event. "
-			"Resetting.\n", channel->channel);
-		atomic_inc(&efx->rx_reset);
-		efx_schedule_reset(efx,
-				   EFX_WORKAROUND_6555(efx) ?
-				   RESET_TYPE_RX_RECOVERY :
-				   RESET_TYPE_DISABLE);
-		break;
-	case RX_DSC_ERROR_EV_DECODE:
-		EFX_ERR(efx, "RX DMA Q %d reports descriptor fetch error."
-			" RX Q %d is disabled.\n", ev_sub_data, ev_sub_data);
-		efx_schedule_reset(efx, RESET_TYPE_RX_DESC_FETCH);
-		break;
-	case TX_DSC_ERROR_EV_DECODE:
-		EFX_ERR(efx, "TX DMA Q %d reports descriptor fetch error."
-			" TX Q %d is disabled.\n", ev_sub_data, ev_sub_data);
-		efx_schedule_reset(efx, RESET_TYPE_TX_DESC_FETCH);
-		break;
-	default:
-		EFX_TRACE(efx, "channel %d unknown driver event code %d "
-			  "data %04x\n", channel->channel, ev_sub_code,
-			  ev_sub_data);
-		EFX_DL_CALLBACK(efx, event, event);
-		break;
-	}
-}
-
-int falcon_process_eventq(struct efx_channel *channel, int rx_quota)
-{
-	unsigned int read_ptr;
-	efx_qword_t event, *p_event;
-	int ev_code;
-	int rx_packets = 0;
-
-	read_ptr = channel->eventq_read_ptr;
-
-	do {
-		p_event = falcon_event(channel, read_ptr);
-		event = *p_event;
-
-		if (!falcon_event_present(&event))
-			/* End of events */
-			break;
-
-		EFX_TRACE(channel->efx, "channel %d event is "EFX_QWORD_FMT"\n",
-			  channel->channel, EFX_QWORD_VAL(event));
-
-		/* Clear this event by marking it all ones */
-		EFX_SET_QWORD(*p_event);
-
-		ev_code = EFX_QWORD_FIELD(event, EV_CODE);
-
-		switch (ev_code) {
-		case RX_IP_EV_DECODE:
-			falcon_handle_rx_event(channel, &event);
-			++rx_packets;
-			break;
-		case TX_IP_EV_DECODE:
-			falcon_handle_tx_event(channel, &event);
-			break;
-		case DRV_GEN_EV_DECODE:
-			channel->eventq_magic
-				= EFX_QWORD_FIELD(event, EVQ_MAGIC);
-			EFX_LOG(channel->efx, "channel %d received generated "
-				"event "EFX_QWORD_FMT"\n", channel->channel,
-				EFX_QWORD_VAL(event));
-			break;
-		case GLOBAL_EV_DECODE:
-			falcon_handle_global_event(channel, &event);
-			break;
-		case DRIVER_EV_DECODE:
-			falcon_handle_driver_event(channel, &event);
-			break;
-		default:
-			EFX_ERR(channel->efx, "channel %d unknown event type %d"
-				" (data " EFX_QWORD_FMT ")\n", channel->channel,
-				ev_code, EFX_QWORD_VAL(event));
-		}
-
-		/* Increment read pointer */
-		read_ptr = (read_ptr + 1) & FALCON_EVQ_MASK;
-
-	} while (rx_packets < rx_quota);
-
-	channel->eventq_read_ptr = read_ptr;
-	return rx_packets;
-}
-
-void falcon_set_int_moderation(struct efx_channel *channel)
+static void falcon_push_irq_moderation(struct efx_channel *channel)
 {
 	efx_dword_t timer_cmd;
 	struct efx_nic *efx = channel->efx;
 
 	/* Set timer register */
 	if (channel->irq_moderation) {
-		/* Round to resolution supported by hardware.  The value we
-		 * program is based at 0.  So actual interrupt moderation
-		 * achieved is ((x + 1) * res).
-		 */
-		channel->irq_moderation -= (channel->irq_moderation %
-					    FALCON_IRQ_MOD_RESOLUTION);
-		if (channel->irq_moderation < FALCON_IRQ_MOD_RESOLUTION)
-			channel->irq_moderation = FALCON_IRQ_MOD_RESOLUTION;
 		EFX_POPULATE_DWORD_2(timer_cmd,
-				     TIMER_MODE, TIMER_MODE_INT_HLDOFF,
-				     TIMER_VAL,
-				     channel->irq_moderation /
-				     FALCON_IRQ_MOD_RESOLUTION - 1);
+				     FRF_AB_TC_TIMER_MODE,
+				     FFE_BB_TIMER_MODE_INT_HLDOFF,
+				     FRF_AB_TC_TIMER_VAL,
+				     channel->irq_moderation - 1);
 	} else {
 		EFX_POPULATE_DWORD_2(timer_cmd,
-				     TIMER_MODE, TIMER_MODE_DIS,
-				     TIMER_VAL, 0);
+				     FRF_AB_TC_TIMER_MODE,
+				     FFE_BB_TIMER_MODE_DIS,
+				     FRF_AB_TC_TIMER_VAL, 0);
 	}
-	falcon_writel_page_locked(efx, &timer_cmd, TIMER_CMD_REG_KER,
-				  channel->channel);
-
+	BUILD_BUG_ON(FR_AA_TIMER_COMMAND_KER != FR_BZ_TIMER_COMMAND_P0);
+	efx_writed_page_locked(efx, &timer_cmd, FR_BZ_TIMER_COMMAND_P0,
+			       channel->channel);
 }
 
-/* Allocate buffer table entries for event queue */
-int falcon_probe_eventq(struct efx_channel *channel)
+static void falcon_deconfigure_mac_wrapper(struct efx_nic *efx);
+
+static void falcon_prepare_flush(struct efx_nic *efx)
 {
-	struct efx_nic *efx = channel->efx;
-	unsigned int evq_size;
-	int rc;
+	falcon_deconfigure_mac_wrapper(efx);
 
-	evq_size = FALCON_EVQ_SIZE * sizeof(efx_qword_t);
-	rc = falcon_alloc_special_buffer(efx, &channel->eventq, evq_size);
-#ifdef CONFIG_SFC_DRIVERLINK
-	if (rc == 0) {
-		struct falcon_nic_data *nic_data = efx->nic_data;
-		nic_data->resources.evq_int_min = max(nic_data->resources.evq_int_min,
-						      (unsigned)channel->channel + 1);
-	}
-#endif
-	return rc;
-}
-
-void falcon_init_eventq(struct efx_channel *channel)
-{
-	efx_oword_t evq_ptr;
-	struct efx_nic *efx = channel->efx;
-
-	EFX_LOG(efx, "channel %d event queue in special buffers %d-%d\n",
-		channel->channel, channel->eventq.index,
-		channel->eventq.index + channel->eventq.entries - 1);
-
-	/* Pin event queue buffer */
-	falcon_init_special_buffer(efx, &channel->eventq);
-
-	/* Fill event queue with all ones (i.e. empty events) */
-	memset(channel->eventq.addr, 0xff, channel->eventq.len);
-
-	/* Push event queue to card */
-	EFX_POPULATE_OWORD_3(evq_ptr,
-			     EVQ_EN, 1,
-			     EVQ_SIZE, FALCON_EVQ_ORDER,
-			     EVQ_BUF_BASE_ID, channel->eventq.index);
-	falcon_write_table(efx, &evq_ptr, efx->type->evq_ptr_tbl_base,
-			   channel->channel);
-
-	falcon_set_int_moderation(channel);
-}
-
-void falcon_fini_eventq(struct efx_channel *channel)
-{
-	efx_oword_t eventq_ptr;
-	struct efx_nic *efx = channel->efx;
-
-	/* Remove event queue from card */
-	EFX_ZERO_OWORD(eventq_ptr);
-	falcon_write_table(efx, &eventq_ptr, efx->type->evq_ptr_tbl_base,
-			   channel->channel);
-
-	/* Unpin event queue */
-	falcon_fini_special_buffer(efx, &channel->eventq);
-}
-
-/* Free buffers backing event queue */
-void falcon_remove_eventq(struct efx_channel *channel)
-{
-	falcon_free_special_buffer(channel->efx, &channel->eventq);
-}
-
-
-/* Generates a test event on the event queue.  A subsequent call to
- * process_eventq() should pick up the event and place the value of
- * "magic" into channel->eventq_magic;
- */
-void falcon_generate_test_event(struct efx_channel *channel, unsigned int magic)
-{
-	efx_qword_t test_event;
-
-	EFX_POPULATE_QWORD_2(test_event,
-			     EV_CODE, DRV_GEN_EV_DECODE,
-			     EVQ_MAGIC, magic);
-	falcon_generate_event(channel, &test_event);
-}
-
-void falcon_sim_phy_event(struct efx_nic *efx)
-{
-	efx_qword_t phy_event;
-
-	EFX_POPULATE_QWORD_1(phy_event, EV_CODE, GLOBAL_EV_DECODE);
-	if (EFX_IS10G(efx))
-		EFX_SET_QWORD_FIELD(phy_event, XG_PHY_INTR, 1);
-	else
-		EFX_SET_QWORD_FIELD(phy_event, G_PHY0_INTR, 1);
-
-	falcon_generate_event(&efx->channel[0], &phy_event);
-}
-
-/**************************************************************************
- *
- * Flush handling
- *
- **************************************************************************/
-
-
-static void falcon_poll_flush_events(struct efx_nic *efx)
-{
-	struct efx_channel *channel = &efx->channel[0];
-	struct efx_tx_queue *tx_queue;
-	struct efx_rx_queue *rx_queue;
-	unsigned int read_ptr = channel->eventq_read_ptr;
-	unsigned int end_ptr = (read_ptr - 1) & FALCON_EVQ_MASK;
-
-	do {
-		efx_qword_t *event = falcon_event(channel, read_ptr);
-		int ev_code, ev_sub_code, ev_queue;
-		bool ev_failed;
-
-		if (!falcon_event_present(event))
-			break;
-
-		ev_code = EFX_QWORD_FIELD(*event, EV_CODE);
-		ev_sub_code = EFX_QWORD_FIELD(*event, DRIVER_EV_SUB_CODE);
-		if (ev_code == DRIVER_EV_DECODE &&
-		    ev_sub_code == TX_DESCQ_FLS_DONE_EV_DECODE) {
-			ev_queue = EFX_QWORD_FIELD(*event,
-						   DRIVER_EV_TX_DESCQ_ID);
-			if (ev_queue < EFX_TX_QUEUE_COUNT) {
-				tx_queue = efx->tx_queue + ev_queue;
-				tx_queue->flushed = true;
-			}
-		} else if (ev_code == DRIVER_EV_DECODE &&
-			   ev_sub_code == RX_DESCQ_FLS_DONE_EV_DECODE) {
-			ev_queue = EFX_QWORD_FIELD(*event,
-						   DRIVER_EV_RX_DESCQ_ID);
-			ev_failed = EFX_QWORD_FIELD(*event,
-						    DRIVER_EV_RX_FLUSH_FAIL);
-			if (ev_queue < efx->n_rx_queues) {
-				rx_queue = efx->rx_queue + ev_queue;
-
-				/* retry the rx flush */
-				if (ev_failed)
-					falcon_flush_rx_queue(rx_queue);
-				else
-					rx_queue->flushed = true;
-			}
-		}
-
-		read_ptr = (read_ptr + 1) & FALCON_EVQ_MASK;
-	} while (read_ptr != end_ptr);
-}
-
-/* Handle tx and rx flushes at the same time, since they run in
- * parallel in the hardware and there's no reason for us to
- * serialise them */
-int falcon_flush_queues(struct efx_nic *efx)
-{
-	struct efx_rx_queue *rx_queue;
-	struct efx_tx_queue *tx_queue;
-	int i;
-	bool outstanding;
-
-	/* Issue flush requests */
-	efx_for_each_tx_queue(tx_queue, efx) {
-		tx_queue->flushed = false;
-		falcon_flush_tx_queue(tx_queue);
-	}
-	efx_for_each_rx_queue(rx_queue, efx) {
-		rx_queue->flushed = false;
-		falcon_flush_rx_queue(rx_queue);
-	}
-
-	/* Poll the evq looking for flush completions. Since we're not pushing
-	 * any more rx or tx descriptors at this point, we're in no danger of
-	 * overflowing the evq whilst we wait */
-	for (i = 0; i < FALCON_FLUSH_POLL_COUNT; ++i) {
-		msleep(FALCON_FLUSH_INTERVAL);
-		falcon_poll_flush_events(efx);
-
-		/* Check if every queue has been succesfully flushed */
-		outstanding = false;
-		efx_for_each_tx_queue(tx_queue, efx)
-			outstanding |= !tx_queue->flushed;
-		efx_for_each_rx_queue(rx_queue, efx)
-			outstanding |= !rx_queue->flushed;
-		if (!outstanding)
-			return 0;
-	}
-
-	/* Mark the queues as all flushed. We're going to return failure
-	 * leading to a reset, or fake up success anyway. "flushed" now
-	 * indicates that we tried to flush. */
-	efx_for_each_tx_queue(tx_queue, efx) {
-		if (!tx_queue->flushed)
-			EFX_ERR(efx, "tx queue %d flush command timed out\n",
-				tx_queue->queue);
-		tx_queue->flushed = true;
-	}
-	efx_for_each_rx_queue(rx_queue, efx) {
-		if (!rx_queue->flushed)
-			EFX_ERR(efx, "rx queue %d flush command timed out\n",
-				rx_queue->queue);
-		rx_queue->flushed = true;
-	}
-
-	if (EFX_WORKAROUND_7803(efx))
-		return 0;
-
-	return -ETIMEDOUT;
-}
-
-/**************************************************************************
- *
- * Falcon hardware interrupts
- * The hardware interrupt handler does very little work; all the event
- * queue processing is carried out by per-channel tasklets.
- *
- **************************************************************************/
-
-/* Enable/disable/generate Falcon interrupts */
-static inline void falcon_interrupts(struct efx_nic *efx, int enabled,
-				     int force)
-{
-	efx_oword_t int_en_reg_ker;
-
-	EFX_POPULATE_OWORD_2(int_en_reg_ker,
-			     KER_INT_KER, force,
-			     DRV_INT_EN_KER, enabled);
-	falcon_write(efx, &int_en_reg_ker, INT_EN_REG_KER);
-}
-
-void falcon_enable_interrupts(struct efx_nic *efx)
-{
-	efx_oword_t int_adr_reg_ker;
-	struct efx_channel *channel;
-
-	EFX_ZERO_OWORD(*((efx_oword_t *) efx->irq_status.addr));
-	wmb(); /* Ensure interrupt vector is clear before interrupts enabled */
-
-	/* Program address */
-	EFX_POPULATE_OWORD_2(int_adr_reg_ker,
-			     NORM_INT_VEC_DIS_KER, EFX_INT_MODE_USE_MSI(efx),
-			     INT_ADR_KER, efx->irq_status.dma_addr);
-	falcon_write(efx, &int_adr_reg_ker, INT_ADR_REG_KER);
-
-	/* Enable interrupts */
-	falcon_interrupts(efx, 1, 0);
-
-	/* Force processing of all the channels to get the EVQ RPTRs up to
-	   date */
-	efx_for_each_channel(channel, efx)
-		efx_schedule_channel(channel);
-}
-
-void falcon_disable_interrupts(struct efx_nic *efx)
-{
-	/* Disable interrupts */
-	falcon_interrupts(efx, 0, 0);
-}
-
-/* Generate a Falcon test interrupt
- * Interrupt must already have been enabled, otherwise nasty things
- * may happen.
- */
-void falcon_generate_interrupt(struct efx_nic *efx)
-{
-	falcon_interrupts(efx, 1, 1);
+	/* Wait for the tx and rx fifo's to get to the next packet boundary
+	 * (~1ms without back-pressure), then to drain the remainder of the
+	 * fifo's at data path speeds (negligible), with a healthy margin. */
+	msleep(10);
 }
 
 /* Acknowledge a legacy interrupt from Falcon
@@ -1411,117 +197,19 @@ void falcon_generate_interrupt(struct ef
  *
  * NB most hardware supports MSI interrupts
  */
-static inline void falcon_irq_ack_a1(struct efx_nic *efx)
+inline void falcon_irq_ack_a1(struct efx_nic *efx)
 {
 	efx_dword_t reg;
 
-	EFX_POPULATE_DWORD_1(reg, INT_ACK_DUMMY_DATA, 0xb7eb7e);
-	falcon_writel(efx, &reg, INT_ACK_REG_KER_A1);
-	falcon_readl(efx, &reg, WORK_AROUND_BROKEN_PCI_READS_REG_KER_A1);
+	EFX_POPULATE_DWORD_1(reg, FRF_AA_INT_ACK_KER_FIELD, 0xb7eb7e);
+	efx_writed(efx, &reg, FR_AA_INT_ACK_KER);
+	efx_readd(efx, &reg, FR_AA_WORK_AROUND_BROKEN_PCI_READS);
 }
 
-/* Process a fatal interrupt
- * Disable bus mastering ASAP and schedule a reset
- */
-static irqreturn_t falcon_fatal_interrupt(struct efx_nic *efx)
-{
-	struct falcon_nic_data *nic_data = efx->nic_data;
-	efx_oword_t *int_ker = efx->irq_status.addr;
-	efx_oword_t fatal_intr;
-	int error, mem_perr;
-
-	falcon_read(efx, &fatal_intr, FATAL_INTR_REG_KER);
-	error = EFX_OWORD_FIELD(fatal_intr, INT_KER_ERROR);
-
-	EFX_ERR(efx, "SYSTEM ERROR " EFX_OWORD_FMT " status "
-		EFX_OWORD_FMT ": %s\n", EFX_OWORD_VAL(*int_ker),
-		EFX_OWORD_VAL(fatal_intr),
-		error ? "disabling bus mastering" : "no recognised error");
-	if (error == 0)
-		goto out;
-
-	/* If this is a memory parity error dump which blocks are offending */
-	mem_perr = EFX_OWORD_FIELD(fatal_intr, MEM_PERR_INT_KER);
-	if (mem_perr) {
-		efx_oword_t reg;
-		falcon_read(efx, &reg, MEM_STAT_REG_KER);
-		EFX_ERR(efx, "SYSTEM ERROR: memory parity error "
-			EFX_OWORD_FMT "\n", EFX_OWORD_VAL(reg));
-	}
-
-	/* Disable both devices */
-	pci_clear_master(efx->pci_dev);
-	if (FALCON_IS_DUAL_FUNC(efx))
-		pci_clear_master(nic_data->pci_dev2);
-	falcon_disable_interrupts(efx);
-
-	/* Count errors and reset or disable the NIC accordingly */
-	if (nic_data->int_error_count == 0 ||
-	    time_after(jiffies, nic_data->int_error_expire)) {
-		nic_data->int_error_count = 0;
-		nic_data->int_error_expire =
-			jiffies + FALCON_INT_ERROR_EXPIRE * HZ;
-	}
-	if (++nic_data->int_error_count < FALCON_MAX_INT_ERRORS) {
-		EFX_ERR(efx, "SYSTEM ERROR - reset scheduled\n");
-		efx_schedule_reset(efx, RESET_TYPE_INT_ERROR);
-	} else {
-		EFX_ERR(efx, "SYSTEM ERROR - max number of errors seen."
-			"NIC will be disabled\n");
-		efx_schedule_reset(efx, RESET_TYPE_DISABLE);
-	}
-out:
-	return IRQ_HANDLED;
-}
-
-/* Handle a legacy interrupt from Falcon
- * Acknowledges the interrupt and schedule event queue processing.
- */
-static irqreturn_t falcon_legacy_interrupt_b0(int irq, void *dev_id)
+irqreturn_t falcon_legacy_interrupt_a1(int irq, void *dev_id)
 {
 	struct efx_nic *efx = dev_id;
 	efx_oword_t *int_ker = efx->irq_status.addr;
-	irqreturn_t result = IRQ_NONE;
-	struct efx_channel *channel;
-	efx_dword_t reg;
-	u32 queues;
-	int syserr;
-
-	/* Read the ISR which also ACKs the interrupts */
-	falcon_readl(efx, &reg, INT_ISR0_B0);
-	queues = EFX_EXTRACT_DWORD(reg, 0, 31);
-
-	/* Check to see if we have a serious error condition */
-	syserr = EFX_OWORD_FIELD(*int_ker, FATAL_INT);
-	if (unlikely(syserr))
-		return falcon_fatal_interrupt(efx);
-
-	/* Schedule processing of any interrupting queues */
-	efx_for_each_channel(channel, efx) {
-		if ((queues & 1) ||
-		    falcon_event_present(
-			    falcon_event(channel, channel->eventq_read_ptr))) {
-			efx_schedule_channel(channel);
-			result = IRQ_HANDLED;
-		}
-		queues >>= 1;
-	}
-
-	if (result == IRQ_HANDLED) {
-		efx->last_irq_cpu = raw_smp_processor_id();
-		EFX_TRACE(efx, "IRQ %d on CPU %d status " EFX_DWORD_FMT "\n",
-			  irq, raw_smp_processor_id(), EFX_DWORD_VAL(reg));
-	}
-
-	return result;
-}
-
-
-static irqreturn_t falcon_legacy_interrupt_a1(int irq, void *dev_id)
-{
-	struct efx_nic *efx = dev_id;
-	efx_oword_t *int_ker = efx->irq_status.addr;
-	struct efx_channel *channel;
 	int syserr;
 	int queues;
 
@@ -1529,159 +217,34 @@ static irqreturn_t falcon_legacy_interru
 	 * exit without having touched the hardware.
 	 */
 	if (unlikely(EFX_OWORD_IS_ZERO(*int_ker))) {
-		EFX_TRACE(efx, "IRQ %d on CPU %d not for me\n", irq,
-			  raw_smp_processor_id());
+		netif_vdbg(efx, intr, efx->net_dev,
+			   "IRQ %d on CPU %d not for me\n", irq,
+			   raw_smp_processor_id());
 		return IRQ_NONE;
 	}
 	efx->last_irq_cpu = raw_smp_processor_id();
-	EFX_TRACE(efx, "IRQ %d on CPU %d status " EFX_OWORD_FMT "\n",
-		  irq, raw_smp_processor_id(), EFX_OWORD_VAL(*int_ker));
+	netif_vdbg(efx, intr, efx->net_dev,
+		   "IRQ %d on CPU %d status " EFX_OWORD_FMT "\n",
+		   irq, raw_smp_processor_id(), EFX_OWORD_VAL(*int_ker));
 
 	/* Check to see if we have a serious error condition */
-	syserr = EFX_OWORD_FIELD(*int_ker, FATAL_INT);
+	syserr = EFX_OWORD_FIELD(*int_ker, FSF_AZ_NET_IVEC_FATAL_INT);
 	if (unlikely(syserr))
-		return falcon_fatal_interrupt(efx);
+		return efx_nic_fatal_interrupt(efx);
 
 	/* Determine interrupting queues, clear interrupt status
 	 * register and acknowledge the device interrupt.
 	 */
-	BUILD_BUG_ON(INT_EVQS_WIDTH > EFX_MAX_CHANNELS);
-	queues = EFX_OWORD_FIELD(*int_ker, INT_EVQS);
+	BUILD_BUG_ON(FSF_AZ_NET_IVEC_INT_Q_WIDTH > EFX_MAX_CHANNELS);
+	queues = EFX_OWORD_FIELD(*int_ker, FSF_AZ_NET_IVEC_INT_Q);
 	EFX_ZERO_OWORD(*int_ker);
 	wmb(); /* Ensure the vector is cleared before interrupt ack */
 	falcon_irq_ack_a1(efx);
 
-	/* Schedule processing of any interrupting queues */
-	channel = &efx->channel[0];
-	while (queues) {
-		if (queues & 0x01)
-			efx_schedule_channel(channel);
-		channel++;
-		queues >>= 1;
-	}
-
+	efx_schedule_channel_irq(efx->channel[0]);
 	return IRQ_HANDLED;
 }
 
-/* Handle an MSI interrupt from Falcon
- *
- * Handle an MSI hardware interrupt.  This routine schedules event
- * queue processing.  No interrupt acknowledgement cycle is necessary.
- * Also, we never need to check that the interrupt is for us, since
- * MSI interrupts cannot be shared.
- */
-static irqreturn_t falcon_msi_interrupt(int irq, void *dev_id)
-{
-	struct efx_channel *channel = dev_id;
-	struct efx_nic *efx = channel->efx;
-	efx_oword_t *int_ker = efx->irq_status.addr;
-	int syserr;
-
-	efx->last_irq_cpu = raw_smp_processor_id();
-	EFX_TRACE(efx, "IRQ %d on CPU %d status " EFX_OWORD_FMT "\n",
-		  irq, raw_smp_processor_id(), EFX_OWORD_VAL(*int_ker));
-
-	/* Check to see if we have a serious error condition */
-	syserr = EFX_OWORD_FIELD(*int_ker, FATAL_INT);
-	if (unlikely(syserr))
-		return falcon_fatal_interrupt(efx);
-
-	/* Schedule processing of the channel */
-	efx_schedule_channel(channel);
-
-	return IRQ_HANDLED;
-}
-
-
-/* Setup RSS indirection table.
- * This maps from the hash value of the packet to RXQ
- */
-static void falcon_setup_rss_indir_table(struct efx_nic *efx)
-{
-	int i = 0;
-	unsigned long offset;
-	efx_dword_t dword;
-
-	if (falcon_rev(efx) < FALCON_REV_B0)
-		return;
-
-	for (offset = RX_RSS_INDIR_TBL_B0;
-	     offset < RX_RSS_INDIR_TBL_B0 + 0x800;
-	     offset += 0x10) {
-		EFX_POPULATE_DWORD_1(dword, RX_RSS_INDIR_ENT_B0,
-				     i % efx->n_rx_queues);
-		falcon_writel(efx, &dword, offset);
-		i++;
-	}
-}
-
-/* Hook interrupt handler(s)
- * Try MSI and then legacy interrupts.
- */
-int falcon_init_interrupt(struct efx_nic *efx)
-{
-	struct efx_channel *channel;
-	int rc;
-
-	if (!EFX_INT_MODE_USE_MSI(efx)) {
-		irq_handler_t handler;
-		if (falcon_rev(efx) >= FALCON_REV_B0)
-			handler = falcon_legacy_interrupt_b0;
-		else
-			handler = falcon_legacy_interrupt_a1;
-
-		rc = request_irq(efx->legacy_irq, handler, IRQF_SHARED,
-				 efx->name, efx);
-		if (rc) {
-			EFX_ERR(efx, "failed to hook legacy IRQ %d\n",
-				efx->pci_dev->irq);
-			goto fail1;
-		}
-		return 0;
-	}
-
-	/* Hook MSI or MSI-X interrupt */
-	efx_for_each_channel(channel, efx) {
-		rc = request_irq(channel->irq, falcon_msi_interrupt,
-				 IRQF_PROBE_SHARED, /* Not shared */
-				 channel->name, channel);
-		if (rc) {
-			EFX_ERR(efx, "failed to hook IRQ %d\n", channel->irq);
-			goto fail2;
-		}
-	}
-
-	return 0;
-
- fail2:
-	efx_for_each_channel(channel, efx)
-		free_irq(channel->irq, channel);
- fail1:
-	return rc;
-}
-
-void falcon_fini_interrupt(struct efx_nic *efx)
-{
-	struct efx_channel *channel;
-	efx_oword_t reg;
-
-	/* Disable MSI/MSI-X interrupts */
-	efx_for_each_channel(channel, efx) {
-		if (channel->irq)
-			free_irq(channel->irq, channel);
-	}
-
-	/* ACK legacy interrupt */
-	if (falcon_rev(efx) >= FALCON_REV_B0)
-		falcon_read(efx, &reg, INT_ISR0_B0);
-	else
-		falcon_irq_ack_a1(efx);
-
-	/* Disable legacy interrupt */
-	if (efx->legacy_irq)
-		free_irq(efx->legacy_irq, efx);
-}
-
 /**************************************************************************
  *
  * EEPROM/flash
@@ -1694,8 +257,8 @@ void falcon_fini_interrupt(struct efx_ni
 static int falcon_spi_poll(struct efx_nic *efx)
 {
 	efx_oword_t reg;
-	falcon_read(efx, &reg, EE_SPI_HCMD_REG_KER);
-	return EFX_OWORD_FIELD(reg, EE_SPI_HCMD_CMD_EN) ? -EBUSY : 0;
+	efx_reado(efx, &reg, FR_AB_EE_SPI_HCMD);
+	return EFX_OWORD_FIELD(reg, FRF_AB_EE_SPI_HCMD_CMD_EN) ? -EBUSY : 0;
 }
 
 /* Wait for SPI command completion */
@@ -1718,18 +281,18 @@ static int falcon_spi_wait(struct efx_ni
 		if (!falcon_spi_poll(efx))
 			return 0;
 		if (time_after_eq(jiffies, timeout)) {
-			EFX_ERR(efx, "timed out waiting for SPI\n");
+			netif_err(efx, hw, efx->net_dev,
+				  "timed out waiting for SPI\n");
 			return -ETIMEDOUT;
 		}
 		schedule_timeout_uninterruptible(1);
 	}
 }
 
-int falcon_spi_cmd(const struct efx_spi_device *spi,
+int falcon_spi_cmd(struct efx_nic *efx, const struct efx_spi_device *spi,
 		   unsigned int command, int address,
 		   const void *in, void *out, size_t len)
 {
-	struct efx_nic *efx = spi->efx;
 	bool addressed = (address >= 0);
 	bool reading = (out != NULL);
 	efx_oword_t reg;
@@ -1738,7 +301,6 @@ int falcon_spi_cmd(const struct efx_spi_
 	/* Input validation */
 	if (len > FALCON_SPI_MAX_LEN)
 		return -EINVAL;
-	BUG_ON(!mutex_is_locked(&efx->spi_lock));
 
 	/* Check that previous command is not still running */
 	rc = falcon_spi_poll(efx);
@@ -1747,27 +309,27 @@ int falcon_spi_cmd(const struct efx_spi_
 
 	/* Program address register, if we have an address */
 	if (addressed) {
-		EFX_POPULATE_OWORD_1(reg, EE_SPI_HADR_ADR, address);
-		falcon_write(efx, &reg, EE_SPI_HADR_REG_KER);
+		EFX_POPULATE_OWORD_1(reg, FRF_AB_EE_SPI_HADR_ADR, address);
+		efx_writeo(efx, &reg, FR_AB_EE_SPI_HADR);
 	}
 
 	/* Program data register, if we have data */
 	if (in != NULL) {
 		memcpy(&reg, in, len);
-		falcon_write(efx, &reg, EE_SPI_HDATA_REG_KER);
+		efx_writeo(efx, &reg, FR_AB_EE_SPI_HDATA);
 	}
 
 	/* Issue read/write command */
 	EFX_POPULATE_OWORD_7(reg,
-			     EE_SPI_HCMD_CMD_EN, 1,
-			     EE_SPI_HCMD_SF_SEL, spi->device_id,
-			     EE_SPI_HCMD_DABCNT, len,
-			     EE_SPI_HCMD_READ, reading,
-			     EE_SPI_HCMD_DUBCNT, 0,
-			     EE_SPI_HCMD_ADBCNT,
+			     FRF_AB_EE_SPI_HCMD_CMD_EN, 1,
+			     FRF_AB_EE_SPI_HCMD_SF_SEL, spi->device_id,
+			     FRF_AB_EE_SPI_HCMD_DABCNT, len,
+			     FRF_AB_EE_SPI_HCMD_READ, reading,
+			     FRF_AB_EE_SPI_HCMD_DUBCNT, 0,
+			     FRF_AB_EE_SPI_HCMD_ADBCNT,
 			     (addressed ? spi->addr_len : 0),
-			     EE_SPI_HCMD_ENC, command);
-	falcon_write(efx, &reg, EE_SPI_HCMD_REG_KER);
+			     FRF_AB_EE_SPI_HCMD_ENC, command);
+	efx_writeo(efx, &reg, FR_AB_EE_SPI_HCMD);
 
 	/* Wait for read/write to complete */
 	rc = falcon_spi_wait(efx);
@@ -1776,7 +338,7 @@ int falcon_spi_cmd(const struct efx_spi_
 
 	/* Read data */
 	if (out != NULL) {
-		falcon_read(efx, &reg, EE_SPI_HDATA_REG_KER);
+		efx_reado(efx, &reg, FR_AB_EE_SPI_HDATA);
 		memcpy(out, &reg, len);
 	}
 
@@ -1798,32 +360,33 @@ efx_spi_munge_command(const struct efx_s
 }
 
 /* Wait up to 10 ms for buffered write completion */
-int falcon_spi_wait_write(const struct efx_spi_device *spi)
+int
+falcon_spi_wait_write(struct efx_nic *efx, const struct efx_spi_device *spi)
 {
-	struct efx_nic *efx = spi->efx;
 	unsigned long timeout = jiffies + 1 + DIV_ROUND_UP(HZ, 100);
 	u8 status;
 	int rc;
 
 	for (;;) {
-		rc = falcon_spi_cmd(spi, SPI_RDSR, -1, NULL,
+		rc = falcon_spi_cmd(efx, spi, SPI_RDSR, -1, NULL,
 				    &status, sizeof(status));
 		if (rc)
 			return rc;
 		if (!(status & SPI_STATUS_NRDY))
 			return 0;
 		if (time_after_eq(jiffies, timeout)) {
-			EFX_ERR(efx, "SPI write timeout on device %d"
-				" last status=0x%02x\n",
-				spi->device_id, status);
+			netif_err(efx, hw, efx->net_dev,
+				  "SPI write timeout on device %d"
+				  " last status=0x%02x\n",
+				  spi->device_id, status);
 			return -ETIMEDOUT;
 		}
 		schedule_timeout_uninterruptible(1);
 	}
 }
 
-int falcon_spi_read(const struct efx_spi_device *spi, loff_t start,
-		    size_t len, size_t *retlen, u8 *buffer)
+int falcon_spi_read(struct efx_nic *efx, const struct efx_spi_device *spi,
+		    loff_t start, size_t len, size_t *retlen, u8 *buffer)
 {
 	size_t block_len, pos = 0;
 	unsigned int command;
@@ -1833,7 +396,7 @@ int falcon_spi_read(const struct efx_spi
 		block_len = min(len - pos, FALCON_SPI_MAX_LEN);
 
 		command = efx_spi_munge_command(spi, SPI_READ, start + pos);
-		rc = falcon_spi_cmd(spi, command, start + pos, NULL,
+		rc = falcon_spi_cmd(efx, spi, command, start + pos, NULL,
 				    buffer + pos, block_len);
 		if (rc)
 			break;
@@ -1852,8 +415,9 @@ int falcon_spi_read(const struct efx_spi
 	return rc;
 }
 
-int falcon_spi_write(const struct efx_spi_device *spi, loff_t start,
-		     size_t len, size_t *retlen, const u8 *buffer)
+int
+falcon_spi_write(struct efx_nic *efx, const struct efx_spi_device *spi,
+		 loff_t start, size_t len, size_t *retlen, const u8 *buffer)
 {
 	u8 verify_buffer[FALCON_SPI_MAX_LEN];
 	size_t block_len, pos = 0;
@@ -1861,24 +425,24 @@ int falcon_spi_write(const struct efx_sp
 	int rc = 0;
 
 	while (pos < len) {
-		rc = falcon_spi_cmd(spi, SPI_WREN, -1, NULL, NULL, 0);
+		rc = falcon_spi_cmd(efx, spi, SPI_WREN, -1, NULL, NULL, 0);
 		if (rc)
 			break;
 
 		block_len = min(len - pos,
 				falcon_spi_write_limit(spi, start + pos));
 		command = efx_spi_munge_command(spi, SPI_WRITE, start + pos);
-		rc = falcon_spi_cmd(spi, command, start + pos,
+		rc = falcon_spi_cmd(efx, spi, command, start + pos,
 				    buffer + pos, NULL, block_len);
 		if (rc)
 			break;
 
-		rc = falcon_spi_wait_write(spi);
+		rc = falcon_spi_wait_write(efx, spi);
 		if (rc)
 			break;
 
 		command = efx_spi_munge_command(spi, SPI_READ, start + pos);
-		rc = falcon_spi_cmd(spi, command, start + pos,
+		rc = falcon_spi_cmd(efx, spi, command, start + pos,
 				    NULL, verify_buffer, block_len);
 		if (memcmp(verify_buffer, buffer + pos, block_len)) {
 			rc = -EIO;
@@ -1907,200 +471,260 @@ int falcon_spi_write(const struct efx_sp
  **************************************************************************
  */
 
-static int falcon_reset_macs(struct efx_nic *efx)
+static void falcon_push_multicast_hash(struct efx_nic *efx)
 {
-	efx_oword_t reg;
+	union efx_multicast_hash *mc_hash = &efx->multicast_hash;
+
+	WARN_ON(!mutex_is_locked(&efx->mac_lock));
+
+	efx_writeo(efx, &mc_hash->oword[0], FR_AB_MAC_MC_HASH_REG0);
+	efx_writeo(efx, &mc_hash->oword[1], FR_AB_MAC_MC_HASH_REG1);
+}
+
+static void falcon_reset_macs(struct efx_nic *efx)
+{
+	struct falcon_nic_data *nic_data = efx->nic_data;
+	efx_oword_t reg, mac_ctrl;
 	int count;
 
-	if (falcon_rev(efx) < FALCON_REV_B0) {
+	if (efx_nic_rev(efx) < EFX_REV_FALCON_B0) {
 		/* It's not safe to use GLB_CTL_REG to reset the
 		 * macs, so instead use the internal MAC resets
 		 */
-		if (!EFX_IS10G(efx)) {
-			EFX_POPULATE_OWORD_1(reg, GM_SW_RST, 1);
-			falcon_write(efx, &reg, GM_CFG1_REG);
-			udelay(1000);
+		EFX_POPULATE_OWORD_1(reg, FRF_AB_XM_CORE_RST, 1);
+		efx_writeo(efx, &reg, FR_AB_XM_GLB_CFG);
 
-			EFX_POPULATE_OWORD_1(reg, GM_SW_RST, 0);
-			falcon_write(efx, &reg, GM_CFG1_REG);
-			udelay(1000);
-			return 0;
-		} else {
-			EFX_POPULATE_OWORD_1(reg, XM_CORE_RST, 1);
-			falcon_write(efx, &reg, XM_GLB_CFG_REG);
+		for (count = 0; count < 10000; count++) {
+			efx_reado(efx, &reg, FR_AB_XM_GLB_CFG);
+			if (EFX_OWORD_FIELD(reg, FRF_AB_XM_CORE_RST) ==
+			    0)
+				return;
+			udelay(10);
+		}
 
-			for (count = 0; count < 10000; count++) {
-				falcon_read(efx, &reg, XM_GLB_CFG_REG);
-				if (EFX_OWORD_FIELD(reg, XM_CORE_RST) == 0)
-					return 0;
-				udelay(10);
-			}
-
-			EFX_ERR(efx, "timed out waiting for XMAC core reset\n");
-			return -ETIMEDOUT;
-		}
+		netif_err(efx, hw, efx->net_dev,
+			  "timed out waiting for XMAC core reset\n");
 	}
 
-	/* MAC stats will fail whilst the TX fifo is draining. Serialise
-	 * the drain sequence with the statistics fetch */
-	efx_stats_disable(efx);
+	/* Mac stats will fail whist the TX fifo is draining */
+	WARN_ON(nic_data->stats_disable_count == 0);
 
-	falcon_read(efx, &reg, MAC0_CTRL_REG_KER);
-	EFX_SET_OWORD_FIELD(reg, TXFIFO_DRAIN_EN_B0, 1);
-	falcon_write(efx, &reg, MAC0_CTRL_REG_KER);
+	efx_reado(efx, &mac_ctrl, FR_AB_MAC_CTRL);
+	EFX_SET_OWORD_FIELD(mac_ctrl, FRF_BB_TXFIFO_DRAIN_EN, 1);
+	efx_writeo(efx, &mac_ctrl, FR_AB_MAC_CTRL);
 
-	falcon_read(efx, &reg, GLB_CTL_REG_KER);
-	EFX_SET_OWORD_FIELD(reg, RST_XGTX, 1);
-	EFX_SET_OWORD_FIELD(reg, RST_XGRX, 1);
-	EFX_SET_OWORD_FIELD(reg, RST_EM, 1);
-	falcon_write(efx, &reg, GLB_CTL_REG_KER);
+	efx_reado(efx, &reg, FR_AB_GLB_CTL);
+	EFX_SET_OWORD_FIELD(reg, FRF_AB_RST_XGTX, 1);
+	EFX_SET_OWORD_FIELD(reg, FRF_AB_RST_XGRX, 1);
+	EFX_SET_OWORD_FIELD(reg, FRF_AB_RST_EM, 1);
+	efx_writeo(efx, &reg, FR_AB_GLB_CTL);
 
 	count = 0;
 	while (1) {
-		falcon_read(efx, &reg, GLB_CTL_REG_KER);
-		if (!EFX_OWORD_FIELD(reg, RST_XGTX) &&
-		    !EFX_OWORD_FIELD(reg, RST_XGRX) &&
-		    !EFX_OWORD_FIELD(reg, RST_EM)) {
-			EFX_LOG(efx, "Completed MAC reset after %d loops\n",
-				count);
+		efx_reado(efx, &reg, FR_AB_GLB_CTL);
+		if (!EFX_OWORD_FIELD(reg, FRF_AB_RST_XGTX) &&
+		    !EFX_OWORD_FIELD(reg, FRF_AB_RST_XGRX) &&
+		    !EFX_OWORD_FIELD(reg, FRF_AB_RST_EM)) {
+			netif_dbg(efx, hw, efx->net_dev,
+				  "Completed MAC reset after %d loops\n",
+				  count);
 			break;
 		}
 		if (count > 20) {
-			EFX_ERR(efx, "MAC reset failed\n");
+			netif_err(efx, hw, efx->net_dev, "MAC reset failed\n");
 			break;
 		}
 		count++;
 		udelay(10);
 	}
 
-	efx_stats_enable(efx);
+	/* Ensure the correct MAC is selected before statistics
+	 * are re-enabled by the caller */
+	efx_writeo(efx, &mac_ctrl, FR_AB_MAC_CTRL);
 
-	/* If we've reset the EM block and the link is up, then
-	 * we'll have to kick the XAUI link so the PHY can recover */
-	if (efx->link_up && EFX_IS10G(efx) && EFX_WORKAROUND_5147(efx))
-		falcon_reset_xaui(efx);
-
-	return 0;
+	falcon_setup_xaui(efx);
 }
 
 void falcon_drain_tx_fifo(struct efx_nic *efx)
 {
 	efx_oword_t reg;
 
-	if ((falcon_rev(efx) < FALCON_REV_B0) ||
+	if ((efx_nic_rev(efx) < EFX_REV_FALCON_B0) ||
 	    (efx->loopback_mode != LOOPBACK_NONE))
 		return;
 
-	falcon_read(efx, &reg, MAC0_CTRL_REG_KER);
+	efx_reado(efx, &reg, FR_AB_MAC_CTRL);
 	/* There is no point in draining more than once */
-	if (EFX_OWORD_FIELD(reg, TXFIFO_DRAIN_EN_B0))
+	if (EFX_OWORD_FIELD(reg, FRF_BB_TXFIFO_DRAIN_EN))
 		return;
 
 	falcon_reset_macs(efx);
 }
 
-void falcon_deconfigure_mac_wrapper(struct efx_nic *efx)
+static void falcon_deconfigure_mac_wrapper(struct efx_nic *efx)
 {
 	efx_oword_t reg;
 
-	if (falcon_rev(efx) < FALCON_REV_B0)
+	if (efx_nic_rev(efx) < EFX_REV_FALCON_B0)
 		return;
 
 	/* Isolate the MAC -> RX */
-	falcon_read(efx, &reg, RX_CFG_REG_KER);
-	EFX_SET_OWORD_FIELD(reg, RX_INGR_EN_B0, 0);
-	falcon_write(efx, &reg, RX_CFG_REG_KER);
+	efx_reado(efx, &reg, FR_AZ_RX_CFG);
+	EFX_SET_OWORD_FIELD(reg, FRF_BZ_RX_INGR_EN, 0);
+	efx_writeo(efx, &reg, FR_AZ_RX_CFG);
 
-	if (!efx->link_up)
-		falcon_drain_tx_fifo(efx);
+	/* Isolate TX -> MAC */
+	falcon_drain_tx_fifo(efx);
 }
 
 void falcon_reconfigure_mac_wrapper(struct efx_nic *efx)
 {
+	struct efx_link_state *link_state = &efx->link_state;
 	efx_oword_t reg;
-	int link_speed;
-	bool tx_fc;
+	int link_speed, isolate;
 
-	switch (efx->link_speed) {
+	isolate = !!ACCESS_ONCE(efx->reset_pending);
+
+	switch (link_state->speed) {
 	case 10000: link_speed = 3; break;
 	case 1000:  link_speed = 2; break;
 	case 100:   link_speed = 1; break;
 	default:    link_speed = 0; break;
 	}
+
 	/* MAC_LINK_STATUS controls MAC backpressure but doesn't work
 	 * as advertised.  Disable to ensure packets are not
 	 * indefinitely held and TX queue can be flushed at any point
 	 * while the link is down. */
 	EFX_POPULATE_OWORD_5(reg,
-			     MAC_XOFF_VAL, 0xffff /* max pause time */,
-			     MAC_BCAD_ACPT, 1,
-			     MAC_UC_PROM, efx->promiscuous,
-			     MAC_LINK_STATUS, 1, /* always set */
-			     MAC_SPEED, link_speed);
+			     FRF_AB_MAC_XOFF_VAL, 0xffff /* max pause time */,
+			     FRF_AB_MAC_BCAD_ACPT, 1,
+			     FRF_AB_MAC_UC_PROM, efx->promiscuous,
+			     FRF_AB_MAC_LINK_STATUS, 1, /* always set */
+			     FRF_AB_MAC_SPEED, link_speed);
 	/* On B0, MAC backpressure can be disabled and packets get
 	 * discarded. */
-	if (falcon_rev(efx) >= FALCON_REV_B0) {
-		EFX_SET_OWORD_FIELD(reg, TXFIFO_DRAIN_EN_B0,
-				    !efx->link_up);
+	if (efx_nic_rev(efx) >= EFX_REV_FALCON_B0) {
+		EFX_SET_OWORD_FIELD(reg, FRF_BB_TXFIFO_DRAIN_EN,
+				    !link_state->up || isolate);
 	}
 
-	falcon_write(efx, &reg, MAC0_CTRL_REG_KER);
+	efx_writeo(efx, &reg, FR_AB_MAC_CTRL);
 
 	/* Restore the multicast hash registers. */
-	falcon_set_multicast_hash(efx);
+	falcon_push_multicast_hash(efx);
 
-	/* Transmission of pause frames when RX crosses the threshold is
-	 * covered by RX_XOFF_MAC_EN and XM_TX_CFG_REG:XM_FCNTL.
-	 * Action on receipt of pause frames is controller by XM_DIS_FCNTL */
-	tx_fc = !!(efx->link_fc & EFX_FC_TX);
-	falcon_read(efx, &reg, RX_CFG_REG_KER);
-	EFX_SET_OWORD_FIELD_VER(efx, reg, RX_XOFF_MAC_EN, tx_fc);
-
+	efx_reado(efx, &reg, FR_AZ_RX_CFG);
+	/* Enable XOFF signal from RX FIFO (we enabled it during NIC
+	 * initialisation but it may read back as 0) */
+	EFX_SET_OWORD_FIELD(reg, FRF_AZ_RX_XOFF_MAC_EN, 1);
 	/* Unisolate the MAC -> RX */
-	if (falcon_rev(efx) >= FALCON_REV_B0)
-		EFX_SET_OWORD_FIELD(reg, RX_INGR_EN_B0, 1);
-	falcon_write(efx, &reg, RX_CFG_REG_KER);
+	if (efx_nic_rev(efx) >= EFX_REV_FALCON_B0)
+		EFX_SET_OWORD_FIELD(reg, FRF_BZ_RX_INGR_EN, !isolate);
+	efx_writeo(efx, &reg, FR_AZ_RX_CFG);
 }
 
-int falcon_dma_stats(struct efx_nic *efx, unsigned int done_offset)
+static void falcon_stats_request(struct efx_nic *efx)
 {
+	struct falcon_nic_data *nic_data = efx->nic_data;
 	efx_oword_t reg;
-	u32 *dma_done;
-	int i;
 
-	if (disable_dma_stats)
-		return 0;
+	WARN_ON(nic_data->stats_pending);
+	WARN_ON(nic_data->stats_disable_count);
 
-	/* Statistics fetch will fail if the MAC is in TX drain */
-	if (falcon_rev(efx) >= FALCON_REV_B0) {
-		efx_oword_t temp;
-		falcon_read(efx, &temp, MAC0_CTRL_REG_KER);
-		if (EFX_OWORD_FIELD(temp, TXFIFO_DRAIN_EN_B0))
-			return 0;
-	}
+	if (nic_data->stats_dma_done == NULL)
+		return;	/* no mac selected */
 
-	dma_done = (efx->stats_buffer.addr + done_offset);
-	*dma_done = FALCON_STATS_NOT_DONE;
+	*nic_data->stats_dma_done = FALCON_STATS_NOT_DONE;
+	nic_data->stats_pending = true;
 	wmb(); /* ensure done flag is clear */
 
 	/* Initiate DMA transfer of stats */
 	EFX_POPULATE_OWORD_2(reg,
-			     MAC_STAT_DMA_CMD, 1,
-			     MAC_STAT_DMA_ADR,
+			     FRF_AB_MAC_STAT_DMA_CMD, 1,
+			     FRF_AB_MAC_STAT_DMA_ADR,
 			     efx->stats_buffer.dma_addr);
-	falcon_write(efx, &reg, MAC0_STAT_DMA_REG_KER);
+	efx_writeo(efx, &reg, FR_AB_MAC_STAT_DMA);
 
-	/* Wait for transfer to complete */
-	for (i = 0; i < 400; i++) {
-		if (*(volatile u32 *)dma_done == FALCON_STATS_DONE) {
-			rmb(); /* Ensure the stats are valid. */
-			return 0;
-		}
-		udelay(10);
+	mod_timer(&nic_data->stats_timer, round_jiffies_up(jiffies + HZ / 2));
+}
+
+static void falcon_stats_complete(struct efx_nic *efx)
+{
+	struct falcon_nic_data *nic_data = efx->nic_data;
+
+	if (!nic_data->stats_pending)
+		return;
+
+	nic_data->stats_pending = 0;
+	if (*nic_data->stats_dma_done == FALCON_STATS_DONE) {
+		rmb(); /* read the done flag before the stats */
+		falcon_update_stats_xmac(efx);
+	} else {
+		netif_err(efx, hw, efx->net_dev,
+			  "timed out waiting for statistics\n");
 	}
+}
 
-	EFX_ERR(efx, "timed out waiting for statistics\n");
-	return -ETIMEDOUT;
+static void falcon_stats_timer_func(unsigned long context)
+{
+	struct efx_nic *efx = (struct efx_nic *)context;
+	struct falcon_nic_data *nic_data = efx->nic_data;
+
+	spin_lock(&efx->stats_lock);
+
+	falcon_stats_complete(efx);
+	if (nic_data->stats_disable_count == 0)
+		falcon_stats_request(efx);
+
+	spin_unlock(&efx->stats_lock);
+}
+
+static bool falcon_loopback_link_poll(struct efx_nic *efx)
+{
+	struct efx_link_state old_state = efx->link_state;
+
+	WARN_ON(!mutex_is_locked(&efx->mac_lock));
+	WARN_ON(!LOOPBACK_INTERNAL(efx));
+
+	efx->link_state.fd = true;
+	efx->link_state.fc = efx->wanted_fc;
+	efx->link_state.up = true;
+	efx->link_state.speed = 10000;
+
+	return !efx_link_state_equal(&efx->link_state, &old_state);
+}
+
+static int falcon_reconfigure_port(struct efx_nic *efx)
+{
+	int rc;
+
+	WARN_ON(efx_nic_rev(efx) > EFX_REV_FALCON_B0);
+
+	/* Poll the PHY link state *before* reconfiguring it. This means we
+	 * will pick up the correct speed (in loopback) to select the correct
+	 * MAC.
+	 */
+	if (LOOPBACK_INTERNAL(efx))
+		falcon_loopback_link_poll(efx);
+	else
+		efx->phy_op->poll(efx);
+
+	falcon_stop_nic_stats(efx);
+	falcon_deconfigure_mac_wrapper(efx);
+
+	falcon_reset_macs(efx);
+
+	efx->phy_op->reconfigure(efx);
+	rc = falcon_reconfigure_xmac(efx);
+	BUG_ON(rc);
+
+	falcon_start_nic_stats(efx);
+
+	/* Synchronise efx->link_state with the kernel */
+	efx_link_status_changed(efx);
+
+	return 0;
 }
 
 /**************************************************************************
@@ -2113,25 +737,26 @@ int falcon_dma_stats(struct efx_nic *efx
 /* Wait for GMII access to complete */
 static int falcon_gmii_wait(struct efx_nic *efx)
 {
-	efx_dword_t md_stat;
+	efx_oword_t md_stat;
 	int count;
 
-	/* wait upto 50ms - taken max from datasheet */
+	/* wait up to 50ms - taken max from datasheet */
 	for (count = 0; count < 5000; count++) {
-		falcon_readl(efx, &md_stat, MD_STAT_REG_KER);
-		if (EFX_DWORD_FIELD(md_stat, MD_BSY) == 0) {
-			if (EFX_DWORD_FIELD(md_stat, MD_LNFL) != 0 ||
-			    EFX_DWORD_FIELD(md_stat, MD_BSERR) != 0) {
-				EFX_ERR(efx, "error from GMII access "
-					EFX_DWORD_FMT"\n",
-					EFX_DWORD_VAL(md_stat));
+		efx_reado(efx, &md_stat, FR_AB_MD_STAT);
+		if (EFX_OWORD_FIELD(md_stat, FRF_AB_MD_BSY) == 0) {
+			if (EFX_OWORD_FIELD(md_stat, FRF_AB_MD_LNFL) != 0 ||
+			    EFX_OWORD_FIELD(md_stat, FRF_AB_MD_BSERR) != 0) {
+				netif_err(efx, hw, efx->net_dev,
+					  "error from GMII access "
+					  EFX_OWORD_FMT"\n",
+					  EFX_OWORD_VAL(md_stat));
 				return -EIO;
 			}
 			return 0;
 		}
 		udelay(10);
 	}
-	EFX_ERR(efx, "timed out waiting for GMII\n");
+	netif_err(efx, hw, efx->net_dev, "timed out waiting for GMII\n");
 	return -ETIMEDOUT;
 }
 
@@ -2140,13 +765,15 @@ static int falcon_mdio_write(struct net_
 			     int prtad, int devad, u16 addr, u16 value)
 {
 	struct efx_nic *efx = netdev_priv(net_dev);
+	struct falcon_nic_data *nic_data = efx->nic_data;
 	efx_oword_t reg;
 	int rc;
 
-	EFX_REGDUMP(efx, "writing MDIO %d register %d.%d with 0x%04x\n",
+	netif_vdbg(efx, hw, efx->net_dev,
+		   "writing MDIO %d register %d.%d with 0x%04x\n",
 		    prtad, devad, addr, value);
 
-	spin_lock_bh(&efx->phy_lock);
+	mutex_lock(&nic_data->mdio_lock);
 
 	/* Check MDIO not currently being accessed */
 	rc = falcon_gmii_wait(efx);
@@ -2154,34 +781,35 @@ static int falcon_mdio_write(struct net_
 		goto out;
 
 	/* Write the address/ID register */
-	EFX_POPULATE_OWORD_1(reg, MD_PHY_ADR, addr);
-	falcon_write(efx, &reg, MD_PHY_ADR_REG_KER);
+	EFX_POPULATE_OWORD_1(reg, FRF_AB_MD_PHY_ADR, addr);
+	efx_writeo(efx, &reg, FR_AB_MD_PHY_ADR);
 
-	EFX_POPULATE_OWORD_2(reg, MD_PRT_ADR, prtad, MD_DEV_ADR, devad);
-	falcon_write(efx, &reg, MD_ID_REG_KER);
+	EFX_POPULATE_OWORD_2(reg, FRF_AB_MD_PRT_ADR, prtad,
+			     FRF_AB_MD_DEV_ADR, devad);
+	efx_writeo(efx, &reg, FR_AB_MD_ID);
 
 	/* Write data */
-	EFX_POPULATE_OWORD_1(reg, MD_TXD, value);
-	falcon_write(efx, &reg, MD_TXD_REG_KER);
+	EFX_POPULATE_OWORD_1(reg, FRF_AB_MD_TXD, value);
+	efx_writeo(efx, &reg, FR_AB_MD_TXD);
 
 	EFX_POPULATE_OWORD_2(reg,
-			     MD_WRC, 1,
-			     MD_GC, 0);
-	falcon_write(efx, &reg, MD_CS_REG_KER);
+			     FRF_AB_MD_WRC, 1,
+			     FRF_AB_MD_GC, 0);
+	efx_writeo(efx, &reg, FR_AB_MD_CS);
 
 	/* Wait for data to be written */
 	rc = falcon_gmii_wait(efx);
 	if (rc) {
 		/* Abort the write operation */
 		EFX_POPULATE_OWORD_2(reg,
-				     MD_WRC, 0,
-				     MD_GC, 1);
-		falcon_write(efx, &reg, MD_CS_REG_KER);
+				     FRF_AB_MD_WRC, 0,
+				     FRF_AB_MD_GC, 1);
+		efx_writeo(efx, &reg, FR_AB_MD_CS);
 		udelay(10);
 	}
 
- out:
-	spin_unlock_bh(&efx->phy_lock);
+out:
+	mutex_unlock(&nic_data->mdio_lock);
 	return rc;
 }
 
@@ -2190,200 +818,164 @@ static int falcon_mdio_read(struct net_d
 			    int prtad, int devad, u16 addr)
 {
 	struct efx_nic *efx = netdev_priv(net_dev);
+	struct falcon_nic_data *nic_data = efx->nic_data;
 	efx_oword_t reg;
 	int rc;
 
-	spin_lock_bh(&efx->phy_lock);
+	mutex_lock(&nic_data->mdio_lock);
 
 	/* Check MDIO not currently being accessed */
 	rc = falcon_gmii_wait(efx);
 	if (rc)
 		goto out;
 
-	EFX_POPULATE_OWORD_1(reg, MD_PHY_ADR, addr);
-	falcon_write(efx, &reg, MD_PHY_ADR_REG_KER);
+	EFX_POPULATE_OWORD_1(reg, FRF_AB_MD_PHY_ADR, addr);
+	efx_writeo(efx, &reg, FR_AB_MD_PHY_ADR);
 
-	EFX_POPULATE_OWORD_2(reg, MD_PRT_ADR, prtad, MD_DEV_ADR, devad);
-	falcon_write(efx, &reg, MD_ID_REG_KER);
+	EFX_POPULATE_OWORD_2(reg, FRF_AB_MD_PRT_ADR, prtad,
+			     FRF_AB_MD_DEV_ADR, devad);
+	efx_writeo(efx, &reg, FR_AB_MD_ID);
 
 	/* Request data to be read */
-	EFX_POPULATE_OWORD_2(reg, MD_RDC, 1, MD_GC, 0);
-	falcon_write(efx, &reg, MD_CS_REG_KER);
+	EFX_POPULATE_OWORD_2(reg, FRF_AB_MD_RDC, 1, FRF_AB_MD_GC, 0);
+	efx_writeo(efx, &reg, FR_AB_MD_CS);
 
 	/* Wait for data to become available */
 	rc = falcon_gmii_wait(efx);
 	if (rc == 0) {
-		falcon_read(efx, &reg, MD_RXD_REG_KER);
-		rc = EFX_OWORD_FIELD(reg, MD_RXD);
-		EFX_REGDUMP(efx, "read from MDIO %d register %d.%d, got %04x\n",
-			    prtad, devad, addr, rc);
+		efx_reado(efx, &reg, FR_AB_MD_RXD);
+		rc = EFX_OWORD_FIELD(reg, FRF_AB_MD_RXD);
+		netif_vdbg(efx, hw, efx->net_dev,
+			   "read from MDIO %d register %d.%d, got %04x\n",
+			   prtad, devad, addr, rc);
 	} else {
 		/* Abort the read operation */
 		EFX_POPULATE_OWORD_2(reg,
-				     MD_RIC, 0,
-				     MD_GC, 1);
-		falcon_write(efx, &reg, MD_CS_REG_KER);
+				     FRF_AB_MD_RIC, 0,
+				     FRF_AB_MD_GC, 1);
+		efx_writeo(efx, &reg, FR_AB_MD_CS);
 
-		EFX_LOG(efx, "read from MDIO %d register %d.%d, got error %d\n",
-			prtad, devad, addr, rc);
+		netif_dbg(efx, hw, efx->net_dev,
+			  "read from MDIO %d register %d.%d, got error %d\n",
+			  prtad, devad, addr, rc);
 	}
 
- out:
-	spin_unlock_bh(&efx->phy_lock);
+out:
+	mutex_unlock(&nic_data->mdio_lock);
 	return rc;
 }
 
-static int falcon_probe_phy(struct efx_nic *efx)
+/* This call is responsible for hooking in the MAC and PHY operations */
+static int falcon_probe_port(struct efx_nic *efx)
 {
+	struct falcon_nic_data *nic_data = efx->nic_data;
+	int rc;
+
+	/* Hook in PHY operations table */
 	switch (efx->phy_type) {
 	case PHY_TYPE_SFX7101:
 		efx->phy_op = &falcon_sfx7101_phy_ops;
 		break;
-	case PHY_TYPE_SFT9001A:
-	case PHY_TYPE_SFT9001B:
-		efx->phy_op = &falcon_sft9001_phy_ops;
-		break;
 	case PHY_TYPE_QT2022C2:
 	case PHY_TYPE_QT2025C:
-		efx->phy_op = &falcon_xfp_phy_ops;
+		efx->phy_op = &falcon_qt202x_phy_ops;
+		break;
+	case PHY_TYPE_TXC43128:
+		efx->phy_op = &falcon_txc_phy_ops;
 		break;
 	default:
-		EFX_ERR(efx, "Unknown PHY type %d\n",
-			efx->phy_type);
-		return -1;
+		netif_err(efx, probe, efx->net_dev, "Unknown PHY type %d\n",
+			  efx->phy_type);
+		return -ENODEV;
 	}
 
-	if (efx->phy_op->macs & EFX_XMAC)
-		efx->loopback_modes |= ((1 << LOOPBACK_XGMII) |
-					(1 << LOOPBACK_XGXS) |
-					(1 << LOOPBACK_XAUI));
-	if (efx->phy_op->macs & EFX_GMAC)
-		efx->loopback_modes |= (1 << LOOPBACK_GMAC);
-	efx->loopback_modes |= efx->phy_op->loopbacks;
+	/* Fill out MDIO structure and loopback modes */
+	mutex_init(&nic_data->mdio_lock);
+	efx->mdio.mdio_read = falcon_mdio_read;
+	efx->mdio.mdio_write = falcon_mdio_write;
+	rc = efx->phy_op->probe(efx);
+	if (rc != 0)
+		return rc;
+
+	/* Initial assumption */
+	efx->link_state.speed = 10000;
+	efx->link_state.fd = true;
+
+	/* Hardware flow ctrl. FalconA RX FIFO too small for pause generation */
+	if (efx_nic_rev(efx) >= EFX_REV_FALCON_B0)
+		efx->wanted_fc = EFX_FC_RX | EFX_FC_TX;
+	else
+		efx->wanted_fc = EFX_FC_RX;
+	if (efx->mdio.mmds & MDIO_DEVS_AN)
+		efx->wanted_fc |= EFX_FC_AUTO;
+
+	/* Allocate buffer for stats */
+	rc = efx_nic_alloc_buffer(efx, &efx->stats_buffer,
+				  FALCON_MAC_STATS_SIZE);
+	if (rc)
+		return rc;
+	netif_dbg(efx, probe, efx->net_dev,
+		  "stats buffer at %llx (virt %p phys %llx)\n",
+		  (u64)efx->stats_buffer.dma_addr,
+		  efx->stats_buffer.addr,
+		  (u64)virt_to_phys(efx->stats_buffer.addr));
+	nic_data->stats_dma_done = efx->stats_buffer.addr + XgDmaDone_offset;
 
 	return 0;
 }
 
-int falcon_switch_mac(struct efx_nic *efx)
+static void falcon_remove_port(struct efx_nic *efx)
 {
-	struct efx_mac_operations *old_mac_op = efx->mac_op;
-	efx_oword_t nic_stat;
-	unsigned strap_val;
-	int rc = 0;
+	efx->phy_op->remove(efx);
+	efx_nic_free_buffer(efx, &efx->stats_buffer);
+}
 
-	/* Don't try to fetch MAC stats while we're switching MACs */
-	efx_stats_disable(efx);
+/* Global events are basically PHY events */
+static bool
+falcon_handle_global_event(struct efx_channel *channel, efx_qword_t *event)
+{
+	struct efx_nic *efx = channel->efx;
+	struct falcon_nic_data *nic_data = efx->nic_data;
 
-	/* Internal loopbacks override the phy speed setting */
-	if (efx->loopback_mode == LOOPBACK_GMAC) {
-		efx->link_speed = 1000;
-		efx->link_fd = true;
-	} else if (LOOPBACK_INTERNAL(efx)) {
-		efx->link_speed = 10000;
-		efx->link_fd = true;
+	if (EFX_QWORD_FIELD(*event, FSF_AB_GLB_EV_G_PHY0_INTR) ||
+	    EFX_QWORD_FIELD(*event, FSF_AB_GLB_EV_XG_PHY0_INTR) ||
+	    EFX_QWORD_FIELD(*event, FSF_AB_GLB_EV_XFP_PHY0_INTR))
+		/* Ignored */
+		return true;
+
+	if ((efx_nic_rev(efx) == EFX_REV_FALCON_B0) &&
+	    EFX_QWORD_FIELD(*event, FSF_BB_GLB_EV_XG_MGT_INTR)) {
+		nic_data->xmac_poll_required = true;
+		return true;
 	}
 
-	WARN_ON(!mutex_is_locked(&efx->mac_lock));
-	efx->mac_op = (EFX_IS10G(efx) ?
-		       &falcon_xmac_operations : &falcon_gmac_operations);
+	if (efx_nic_rev(efx) <= EFX_REV_FALCON_A1 ?
+	    EFX_QWORD_FIELD(*event, FSF_AA_GLB_EV_RX_RECOVERY) :
+	    EFX_QWORD_FIELD(*event, FSF_BB_GLB_EV_RX_RECOVERY)) {
+		netif_err(efx, rx_err, efx->net_dev,
+			  "channel %d seen global RX_RESET event. Resetting.\n",
+			  channel->channel);
 
-	/* Always push the NIC_STAT_REG setting even if the mac hasn't
-	 * changed, because this function is run post online reset */
-	falcon_read(efx, &nic_stat, NIC_STAT_REG);
-	strap_val = EFX_IS10G(efx) ? 5 : 3;
-	if (falcon_rev(efx) >= FALCON_REV_B0) {
-		EFX_SET_OWORD_FIELD(nic_stat, EE_STRAP_EN, 1);
-		EFX_SET_OWORD_FIELD(nic_stat, EE_STRAP_OVR, strap_val);
-		falcon_write(efx, &nic_stat, NIC_STAT_REG);
-	} else {
-		/* Falcon A1 does not support 1G/10G speed switching
-		 * and must not be used with a PHY that does. */
-		BUG_ON(EFX_OWORD_FIELD(nic_stat, STRAP_PINS) != strap_val);
+		atomic_inc(&efx->errors.rx_reset);
+		efx_schedule_reset(efx, EFX_WORKAROUND_6555(efx) ?
+				   RESET_TYPE_RX_RECOVERY : RESET_TYPE_DISABLE);
+		return true;
 	}
 
-	if (old_mac_op == efx->mac_op)
-		goto out;
-
-	EFX_LOG(efx, "selected %cMAC\n", EFX_IS10G(efx) ? 'X' : 'G');
-	/* Not all macs support a mac-level link state */
-	efx->mac_up = true;
-
-	rc = falcon_reset_macs(efx);
-out:
-	efx_stats_enable(efx);
-	return rc;
+	return false;
 }
 
-/* This call is responsible for hooking in the MAC and PHY operations */
-int falcon_probe_port(struct efx_nic *efx)
-{
-	int rc;
-
-	/* Hook in PHY operations table */
-	rc = falcon_probe_phy(efx);
-	if (rc)
-		return rc;
-
-	/* Set up MDIO structure for PHY */
-	efx->mdio.mmds = efx->phy_op->mmds;
-	efx->mdio.mode_support = MDIO_SUPPORTS_C45 | MDIO_EMULATE_C22;
-	efx->mdio.mdio_read = falcon_mdio_read;
-	efx->mdio.mdio_write = falcon_mdio_write;
-
-	/* Hardware flow ctrl. FalconA RX FIFO too small for pause generation */
-	if (falcon_rev(efx) >= FALCON_REV_B0)
-		efx->wanted_fc = EFX_FC_RX | EFX_FC_TX;
-	else
-		efx->wanted_fc = EFX_FC_RX;
-
-	/* Allocate buffer for stats */
-	rc = falcon_alloc_buffer(efx, &efx->stats_buffer,
-				 FALCON_MAC_STATS_SIZE);
-	if (rc)
-		return rc;
-	EFX_LOG(efx, "stats buffer at %llx (virt %p phys %llx)\n",
-		(u64)efx->stats_buffer.dma_addr,
-		efx->stats_buffer.addr,
-		(u64)virt_to_phys(efx->stats_buffer.addr));
-
-	return 0;
-}
-
-void falcon_remove_port(struct efx_nic *efx)
-{
-	falcon_free_buffer(efx, &efx->stats_buffer);
-}
-
-/**************************************************************************
- *
- * Multicast filtering
- *
- **************************************************************************
- */
-
-void falcon_set_multicast_hash(struct efx_nic *efx)
-{
-	union efx_multicast_hash *mc_hash = &efx->multicast_hash;
-
-	/* Broadcast packets go through the multicast hash filter.
-	 * ether_crc_le() of the broadcast address is 0xbe2612ff
-	 * so we always add bit 0xff to the mask.
-	 */
-	set_bit_le(0xff, mc_hash->byte);
-
-	falcon_write(efx, &mc_hash->oword[0], MAC_MCAST_HASH_REG0_KER);
-	falcon_write(efx, &mc_hash->oword[1], MAC_MCAST_HASH_REG1_KER);
-}
-
-
 /**************************************************************************
  *
  * Falcon test code
  *
  **************************************************************************/
 
+/* Read and verify the correctness of the nvram, optionally returning a copy
+ * of the nvram configuration section if appropriate */
 int falcon_read_nvram(struct efx_nic *efx, struct falcon_nvconfig *nvconfig_out)
 {
+	struct falcon_nic_data *nic_data = efx->nic_data;
 	struct falcon_nvconfig *nvconfig;
 	struct efx_spi_device *spi;
 	void *region;
@@ -2391,21 +983,25 @@ int falcon_read_nvram(struct efx_nic *ef
 	__le16 *word, *limit;
 	u32 csum;
 
-	spi = efx->spi_flash ? efx->spi_flash : efx->spi_eeprom;
-	if (!spi)
+	if (efx_spi_present(&nic_data->spi_flash))
+		spi = &nic_data->spi_flash;
+	else if (efx_spi_present(&nic_data->spi_eeprom))
+		spi = &nic_data->spi_eeprom;
+	else
 		return -EINVAL;
 
 	region = kmalloc(FALCON_NVCONFIG_END, GFP_KERNEL);
 	if (!region)
 		return -ENOMEM;
-	nvconfig = region + NVCONFIG_OFFSET;
+	nvconfig = region + FALCON_NVCONFIG_OFFSET;
 
-	mutex_lock(&efx->spi_lock);
-	rc = falcon_spi_read(spi, 0, FALCON_NVCONFIG_END, NULL, region);
-	mutex_unlock(&efx->spi_lock);
+	mutex_lock(&nic_data->spi_lock);
+	rc = falcon_spi_read(efx, spi, 0, FALCON_NVCONFIG_END, NULL, region);
+	mutex_unlock(&nic_data->spi_lock);
 	if (rc) {
-		EFX_ERR(efx, "Failed to read %s\n",
-			efx->spi_flash ? "flash" : "EEPROM");
+		netif_err(efx, hw, efx->net_dev, "Failed to read %s\n",
+			  efx_spi_present(&nic_data->spi_flash) ?
+			  "flash" : "EEPROM");
 		rc = -EIO;
 		goto out;
 	}
@@ -2414,12 +1010,14 @@ int falcon_read_nvram(struct efx_nic *ef
 	struct_ver = le16_to_cpu(nvconfig->board_struct_ver);
 
 	rc = -EINVAL;
-	if (magic_num != NVCONFIG_BOARD_MAGIC_NUM) {
-		EFX_ERR(efx, "NVRAM bad magic 0x%x\n", magic_num);
+	if (magic_num != FALCON_NVCONFIG_BOARD_MAGIC_NUM) {
+		netif_err(efx, hw, efx->net_dev,
+			  "NVRAM bad magic 0x%x\n", magic_num);
 		goto out;
 	}
 	if (struct_ver < 2) {
-		EFX_ERR(efx, "NVRAM has ancient version 0x%x\n", struct_ver);
+		netif_err(efx, hw, efx->net_dev,
+			  "NVRAM has ancient version 0x%x\n", struct_ver);
 		goto out;
 	} else if (struct_ver < 4) {
 		word = &nvconfig->board_magic_num;
@@ -2432,7 +1030,8 @@ int falcon_read_nvram(struct efx_nic *ef
 		csum += le16_to_cpu(*word);
 
 	if (~csum & 0xffff) {
-		EFX_ERR(efx, "NVRAM has incorrect checksum\n");
+		netif_err(efx, hw, efx->net_dev,
+			  "NVRAM has incorrect checksum\n");
 		goto out;
 	}
 
@@ -2445,107 +1044,150 @@ int falcon_read_nvram(struct efx_nic *ef
 	return rc;
 }
 
-/* Registers tested in the falcon register test */
-static struct {
-	unsigned address;
-	efx_oword_t mask;
-} efx_test_registers[] = {
-	{ ADR_REGION_REG_KER,
-	  EFX_OWORD32(0x0001FFFF, 0x0001FFFF, 0x0001FFFF, 0x0001FFFF) },
-	{ RX_CFG_REG_KER,
+static int
+falcon_b0_test_sram(struct efx_nic *efx,
+		    void (*pattern)(unsigned, efx_qword_t *, int, int),
+		    int a, int b)
+{
+	efx_qword_t buf1, buf2;
+	int wptr, rptr, finish, rc = 0;
+	void __iomem *membase;
+
+	/* So we can test the sram allocated to descriptor caches, access
+	 * via SRAM_DBG_REG rather than BUF_FULL_TBL. */
+	BUG_ON(efx->port_enabled);
+	membase = ioremap_nocache(efx->membase_phys + FR_BZ_SRM_DBG,
+				  efx->sram_lim);
+	if (!membase) {
+		netif_err(efx, hw, efx->net_dev, "Unable to map SRAM_DBG\n");
+		return -EIO;
+	}
+
+	finish = efx->sram_lim / sizeof(buf1) - 1;
+
+	/* write and verify the pattern in 64 8-byte chunks, to avoid
+	 * potentially overrunning the sram update fifo */
+	for (rptr = 0, wptr = 0; wptr <= finish; ++wptr) {
+		pattern(wptr, &buf1, a, b);
+		efx_sram_writeq(efx, membase, &buf1, wptr);
+
+		if (((wptr - rptr) < 64) && (wptr < finish))
+			continue;
+
+		for (; rptr <= wptr; ++rptr) {
+			pattern(rptr, &buf1, a, b);
+			efx_sram_readq(efx, membase, &buf2, rptr);
+
+			if (!memcmp(&buf1, &buf2, sizeof(buf1)))
+				continue;
+
+			netif_err(efx, hw, efx->net_dev,
+				  "sram test failed at index 0x%x. wrote "
+				  EFX_QWORD_FMT" read "EFX_QWORD_FMT"\n",
+				  rptr, EFX_QWORD_VAL(buf1),
+				  EFX_QWORD_VAL(buf2));
+			rc = -EIO;
+			goto out_unmap;
+		}
+	}
+
+out_unmap:
+	iounmap(membase);
+
+	return rc;
+}
+
+static int falcon_test_nvram(struct efx_nic *efx)
+{
+	return falcon_read_nvram(efx, NULL);
+}
+
+static const struct efx_nic_register_test falcon_b0_register_tests[] = {
+	{ FR_AZ_ADR_REGION,
+	  EFX_OWORD32(0x0003FFFF, 0x0003FFFF, 0x0003FFFF, 0x0003FFFF) },
+	{ FR_AZ_RX_CFG,
 	  EFX_OWORD32(0xFFFFFFFE, 0x00017FFF, 0x00000000, 0x00000000) },
-	{ TX_CFG_REG_KER,
+	{ FR_AZ_TX_CFG,
 	  EFX_OWORD32(0x7FFF0037, 0x00000000, 0x00000000, 0x00000000) },
-	{ TX_CFG2_REG_KER,
+	{ FR_AZ_TX_RESERVED,
 	  EFX_OWORD32(0xFFFEFE80, 0x1FFFFFFF, 0x020000FE, 0x007FFFFF) },
-	{ MAC0_CTRL_REG_KER,
+	{ FR_AB_MAC_CTRL,
 	  EFX_OWORD32(0xFFFF0000, 0x00000000, 0x00000000, 0x00000000) },
-	{ SRM_TX_DC_CFG_REG_KER,
+	{ FR_AZ_SRM_TX_DC_CFG,
 	  EFX_OWORD32(0x001FFFFF, 0x00000000, 0x00000000, 0x00000000) },
-	{ RX_DC_CFG_REG_KER,
+	{ FR_AZ_RX_DC_CFG,
 	  EFX_OWORD32(0x0000000F, 0x00000000, 0x00000000, 0x00000000) },
-	{ RX_DC_PF_WM_REG_KER,
+	{ FR_AZ_RX_DC_PF_WM,
 	  EFX_OWORD32(0x000003FF, 0x00000000, 0x00000000, 0x00000000) },
-	{ DP_CTRL_REG,
+	{ FR_BZ_DP_CTRL,
 	  EFX_OWORD32(0x00000FFF, 0x00000000, 0x00000000, 0x00000000) },
-	{ GM_CFG2_REG,
+	{ FR_AB_GM_CFG2,
 	  EFX_OWORD32(0x00007337, 0x00000000, 0x00000000, 0x00000000) },
-	{ GMF_CFG0_REG,
+	{ FR_AB_GMF_CFG0,
 	  EFX_OWORD32(0x00001F1F, 0x00000000, 0x00000000, 0x00000000) },
-	{ XM_GLB_CFG_REG,
+	{ FR_AB_XM_GLB_CFG,
 	  EFX_OWORD32(0x00000C68, 0x00000000, 0x00000000, 0x00000000) },
-	{ XM_TX_CFG_REG,
+	{ FR_AB_XM_TX_CFG,
 	  EFX_OWORD32(0x00080164, 0x00000000, 0x00000000, 0x00000000) },
-	{ XM_RX_CFG_REG,
+	{ FR_AB_XM_RX_CFG,
 	  EFX_OWORD32(0x07100A0C, 0x00000000, 0x00000000, 0x00000000) },
-	{ XM_RX_PARAM_REG,
+	{ FR_AB_XM_RX_PARAM,
 	  EFX_OWORD32(0x00001FF8, 0x00000000, 0x00000000, 0x00000000) },
-	{ XM_FC_REG,
+	{ FR_AB_XM_FC,
 	  EFX_OWORD32(0xFFFF0001, 0x00000000, 0x00000000, 0x00000000) },
-	{ XM_ADR_LO_REG,
+	{ FR_AB_XM_ADR_LO,
 	  EFX_OWORD32(0xFFFFFFFF, 0x00000000, 0x00000000, 0x00000000) },
-	{ XX_SD_CTL_REG,
+	{ FR_AB_XX_SD_CTL,
 	  EFX_OWORD32(0x0003FF0F, 0x00000000, 0x00000000, 0x00000000) },
 };
 
-static bool efx_masked_compare_oword(const efx_oword_t *a, const efx_oword_t *b,
-				     const efx_oword_t *mask)
+static const struct efx_nic_table_test falcon_b0_table_tests[] = {
+	{ FR_BZ_RX_FILTER_TBL0, FR_BZ_RX_FILTER_TBL0_STEP,
+	  FR_BZ_RX_FILTER_TBL0_ROWS,
+	  EFX_OWORD32(0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0x000003FF) },
+	{ FR_BB_RX_FILTER_TBL1, FR_BB_RX_FILTER_TBL1_STEP,
+	  FR_BB_RX_FILTER_TBL1_ROWS,
+	  EFX_OWORD32(0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0x000003FF) },
+	{ FR_BZ_RX_DESC_PTR_TBL, FR_BZ_RX_DESC_PTR_TBL_STEP,
+	  FR_BB_RX_DESC_PTR_TBL_ROWS,
+	  EFX_OWORD32(0xFFFFFFFF, 0x0FFFFFFF, 0x01800000, 0x00000000) },
+	{ FR_BZ_TX_DESC_PTR_TBL, FR_BZ_TX_DESC_PTR_TBL_STEP,
+	  FR_BB_TX_DESC_PTR_TBL_ROWS,
+	  EFX_OWORD32(0xFFFFFFFE, 0x0FFFFFFF, 0x0C000000, 0x00000000) },
+};
+
+static int falcon_b0_test_registers(struct efx_nic *efx)
 {
-	return ((a->u64[0] ^ b->u64[0]) & mask->u64[0]) ||
-		((a->u64[1] ^ b->u64[1]) & mask->u64[1]);
+	return efx_nic_test_registers(efx, falcon_b0_register_tests,
+				      ARRAY_SIZE(falcon_b0_register_tests));
 }
 
-int falcon_test_registers(struct efx_nic *efx)
+static int
+falcon_b0_test_memory(struct efx_nic *efx,
+		      void (*pattern)(unsigned, efx_qword_t *, int, int),
+		      int a, int b)
 {
-	unsigned address = 0, i, j;
-	efx_oword_t mask, imask, original, reg, buf;
+	struct falcon_nic_data *nic_data = efx->nic_data;
+	int rc, i;
 
-	/* Falcon should be in loopback to isolate the XMAC from the PHY */
-	WARN_ON(!LOOPBACK_INTERNAL(efx));
+	rc = falcon_b0_test_sram(efx, pattern, a, b);
+	if (rc)
+		return rc;
 
-	for (i = 0; i < ARRAY_SIZE(efx_test_registers); ++i) {
-		address = efx_test_registers[i].address;
-		mask = imask = efx_test_registers[i].mask;
-		EFX_INVERT_OWORD(imask);
+	for (i = 0; i < ARRAY_SIZE(falcon_b0_table_tests); i++) {
+		/* In internal SRAM mode, the odd filter bank is
+		 * remapped as a descriptor cache */
+		if (falcon_b0_table_tests[i].address == FR_BB_RX_FILTER_TBL1 &&
+		    nic_data->sram_config == SRAM_CONFIG_INTERNAL)
+			continue;
 
-		falcon_read(efx, &original, address);
-
-		/* bit sweep on and off */
-		for (j = 0; j < 128; j++) {
-			if (!EFX_EXTRACT_OWORD32(mask, j, j))
-				continue;
-
-			/* Test this testable bit can be set in isolation */
-			EFX_AND_OWORD(reg, original, mask);
-			EFX_SET_OWORD32(reg, j, j, 1);
-
-			falcon_write(efx, &reg, address);
-			falcon_read(efx, &buf, address);
-
-			if (efx_masked_compare_oword(&reg, &buf, &mask))
-				goto fail;
-
-			/* Test this testable bit can be cleared in isolation */
-			EFX_OR_OWORD(reg, original, mask);
-			EFX_SET_OWORD32(reg, j, j, 0);
-
-			falcon_write(efx, &reg, address);
-			falcon_read(efx, &buf, address);
-
-			if (efx_masked_compare_oword(&reg, &buf, &mask))
-				goto fail;
-		}
-
-		falcon_write(efx, &original, address);
+		rc = efx_nic_test_table(efx, &falcon_b0_table_tests[i],
+					pattern, a, b);
+		if (rc)
+			return rc;
 	}
 
 	return 0;
-
-fail:
-	EFX_ERR(efx, "wrote "EFX_OWORD_FMT" read "EFX_OWORD_FMT
-		" at address 0x%x mask "EFX_OWORD_FMT"\n", EFX_OWORD_VAL(reg),
-		EFX_OWORD_VAL(buf), address, EFX_OWORD_VAL(mask));
-	return -EIO;
 }
 
 /**************************************************************************
@@ -2555,149 +1197,241 @@ fail:
  **************************************************************************
  */
 
+static enum reset_type falcon_map_reset_reason(enum reset_type reason)
+{
+	switch (reason) {
+	case RESET_TYPE_RX_RECOVERY:
+	case RESET_TYPE_RX_DESC_FETCH:
+	case RESET_TYPE_TX_DESC_FETCH:
+	case RESET_TYPE_TX_SKIP:
+		/* These can occasionally occur due to hardware bugs.
+		 * We try to reset without disrupting the link.
+		 */
+		return RESET_TYPE_INVISIBLE;
+	default:
+		return RESET_TYPE_ALL;
+	}
+}
+
+static int falcon_map_reset_flags(u32 *flags)
+{
+	enum {
+		FALCON_RESET_INVISIBLE = (ETH_RESET_DMA | ETH_RESET_FILTER |
+					  ETH_RESET_OFFLOAD | ETH_RESET_MAC),
+		FALCON_RESET_ALL = FALCON_RESET_INVISIBLE | ETH_RESET_PHY,
+		FALCON_RESET_WORLD = FALCON_RESET_ALL | ETH_RESET_IRQ,
+	};
+
+	if ((*flags & FALCON_RESET_WORLD) == FALCON_RESET_WORLD) {
+		*flags &= ~FALCON_RESET_WORLD;
+		return RESET_TYPE_WORLD;
+	}
+
+	if ((*flags & FALCON_RESET_ALL) == FALCON_RESET_ALL) {
+		*flags &= ~FALCON_RESET_ALL;
+		return RESET_TYPE_ALL;
+	}
+
+	if ((*flags & FALCON_RESET_INVISIBLE) == FALCON_RESET_INVISIBLE) {
+		*flags &= ~FALCON_RESET_INVISIBLE;
+		return RESET_TYPE_INVISIBLE;
+	}
+
+	return -EINVAL;
+}
+
 /* Resets NIC to known state.  This routine must be called in process
  * context and is allowed to sleep. */
-int falcon_reset_hw(struct efx_nic *efx, enum reset_type method)
+static int __falcon_reset_hw(struct efx_nic *efx, enum reset_type method)
 {
 	struct falcon_nic_data *nic_data = efx->nic_data;
 	efx_oword_t glb_ctl_reg_ker;
 	int rc;
 
-	EFX_LOG(efx, "performing hardware reset (%d)\n", method);
+	netif_dbg(efx, hw, efx->net_dev, "performing %s hardware reset\n",
+		  RESET_TYPE(method));
 
 	/* Initiate device reset */
 	if (method == RESET_TYPE_WORLD) {
 		rc = pci_save_state(efx->pci_dev);
 		if (rc) {
-			EFX_ERR(efx, "failed to backup PCI state of primary "
-				"function prior to hardware reset\n");
+			netif_err(efx, drv, efx->net_dev,
+				  "failed to backup PCI state of primary "
+				  "function prior to hardware reset\n");
 			goto fail1;
 		}
-		if (FALCON_IS_DUAL_FUNC(efx)) {
+		if (efx_nic_is_dual_func(efx)) {
 			rc = pci_save_state(nic_data->pci_dev2);
 			if (rc) {
-				EFX_ERR(efx, "failed to backup PCI state of "
-					"secondary function prior to "
-					"hardware reset\n");
+				netif_err(efx, drv, efx->net_dev,
+					  "failed to backup PCI state of "
+					  "secondary function prior to "
+					  "hardware reset\n");
 				goto fail2;
 			}
 		}
 
 		EFX_POPULATE_OWORD_2(glb_ctl_reg_ker,
-				     EXT_PHY_RST_DUR, 0x7,
-				     SWRST, 1);
+				     FRF_AB_EXT_PHY_RST_DUR,
+				     FFE_AB_EXT_PHY_RST_DUR_10240US,
+				     FRF_AB_SWRST, 1);
 	} else {
-		int reset_phy = (method == RESET_TYPE_INVISIBLE ?
-				 EXCLUDE_FROM_RESET : 0);
+		EFX_POPULATE_OWORD_7(glb_ctl_reg_ker,
+				     /* exclude PHY from "invisible" reset */
+				     FRF_AB_EXT_PHY_RST_CTL,
+				     method == RESET_TYPE_INVISIBLE,
+				     /* exclude EEPROM/flash and PCIe */
+				     FRF_AB_PCIE_CORE_RST_CTL, 1,
+				     FRF_AB_PCIE_NSTKY_RST_CTL, 1,
+				     FRF_AB_PCIE_SD_RST_CTL, 1,
+				     FRF_AB_EE_RST_CTL, 1,
+				     FRF_AB_EXT_PHY_RST_DUR,
+				     FFE_AB_EXT_PHY_RST_DUR_10240US,
+				     FRF_AB_SWRST, 1);
+	}
+	efx_writeo(efx, &glb_ctl_reg_ker, FR_AB_GLB_CTL);
 
-		EFX_POPULATE_OWORD_7(glb_ctl_reg_ker,
-				     EXT_PHY_RST_CTL, reset_phy,
-				     PCIE_CORE_RST_CTL, EXCLUDE_FROM_RESET,
-				     PCIE_NSTCK_RST_CTL, EXCLUDE_FROM_RESET,
-				     PCIE_SD_RST_CTL, EXCLUDE_FROM_RESET,
-				     EE_RST_CTL, EXCLUDE_FROM_RESET,
-				     EXT_PHY_RST_DUR, 0x7 /* 10ms */,
-				     SWRST, 1);
-	}
-	falcon_write(efx, &glb_ctl_reg_ker, GLB_CTL_REG_KER);
-
-	EFX_LOG(efx, "waiting for hardware reset\n");
+	netif_dbg(efx, hw, efx->net_dev, "waiting for hardware reset\n");
 	schedule_timeout_uninterruptible(HZ / 20);
 
 	/* Restore PCI configuration if needed */
 	if (method == RESET_TYPE_WORLD) {
-		if (FALCON_IS_DUAL_FUNC(efx)) {
-			rc = pci_restore_state(nic_data->pci_dev2);
-			if (rc) {
-				EFX_ERR(efx, "failed to restore PCI config for "
-					"the secondary function\n");
-				goto fail3;
-			}
-		}
-		rc = pci_restore_state(efx->pci_dev);
-		if (rc) {
-			EFX_ERR(efx, "failed to restore PCI config for the "
-				"primary function\n");
-			goto fail4;
-		}
-		EFX_LOG(efx, "successfully restored PCI config\n");
+		if (efx_nic_is_dual_func(efx))
+			pci_restore_state(nic_data->pci_dev2);
+		pci_restore_state(efx->pci_dev);
+		netif_dbg(efx, drv, efx->net_dev,
+			  "successfully restored PCI config\n");
 	}
 
 	/* Assert that reset complete */
-	falcon_read(efx, &glb_ctl_reg_ker, GLB_CTL_REG_KER);
-	if (EFX_OWORD_FIELD(glb_ctl_reg_ker, SWRST) != 0) {
+	efx_reado(efx, &glb_ctl_reg_ker, FR_AB_GLB_CTL);
+	if (EFX_OWORD_FIELD(glb_ctl_reg_ker, FRF_AB_SWRST) != 0) {
 		rc = -ETIMEDOUT;
-		EFX_ERR(efx, "timed out waiting for hardware reset\n");
-		goto fail5;
+		netif_err(efx, hw, efx->net_dev,
+			  "timed out waiting for hardware reset\n");
+		goto fail3;
 	}
-	EFX_LOG(efx, "hardware reset complete\n");
+	netif_dbg(efx, hw, efx->net_dev, "hardware reset complete\n");
 
 	return 0;
 
 	/* pci_save_state() and pci_restore_state() MUST be called in pairs */
 fail2:
-fail3:
 	pci_restore_state(efx->pci_dev);
 fail1:
-fail4:
-fail5:
+fail3:
 	return rc;
 }
 
+static int falcon_reset_hw(struct efx_nic *efx, enum reset_type method)
+{
+	struct falcon_nic_data *nic_data = efx->nic_data;
+	int rc;
+
+	mutex_lock(&nic_data->spi_lock);
+	rc = __falcon_reset_hw(efx, method);
+	mutex_unlock(&nic_data->spi_lock);
+
+	return rc;
+}
+
+void falcon_reset_phy(struct efx_nic *efx)
+{
+	efx_oword_t oword;
+
+	BUG_ON(!mutex_is_locked(&efx->mac_lock));
+
+	efx_reado(efx, &oword, FR_AB_GPIO_CTL);
+	EFX_SET_OWORD_FIELD(oword, FRF_AB_GPIO2_OUT, 0);
+	EFX_SET_OWORD_FIELD(oword, FRF_AB_GPIO2_OEN, 1);
+	efx_writeo(efx, &oword, FR_AB_GPIO_CTL);
+
+	msleep(10);
+
+	EFX_SET_OWORD_FIELD(oword, FRF_AB_GPIO2_OEN, 0);
+	efx_writeo(efx, &oword, FR_AB_GPIO_CTL);
+}
+
+static void falcon_monitor(struct efx_nic *efx)
+{
+	bool link_changed;
+	int rc;
+
+	BUG_ON(!mutex_is_locked(&efx->mac_lock));
+
+	rc = falcon_board(efx)->type->monitor(efx);
+	if (rc) {
+		netif_err(efx, hw, efx->net_dev,
+			  "Board sensor %s; shutting down PHY\n",
+			  (rc == -ERANGE) ? "reported fault" : "failed");
+		efx->phy_mode |= PHY_MODE_LOW_POWER;
+		rc = __efx_reconfigure_port(efx);
+		WARN_ON(rc);
+	}
+
+	if (LOOPBACK_INTERNAL(efx))
+		link_changed = falcon_loopback_link_poll(efx);
+	else
+		link_changed = efx->phy_op->poll(efx);
+
+	if (link_changed) {
+		falcon_stop_nic_stats(efx);
+		falcon_deconfigure_mac_wrapper(efx);
+
+		falcon_reset_macs(efx);
+		rc = falcon_reconfigure_xmac(efx);
+		BUG_ON(rc);
+
+		falcon_start_nic_stats(efx);
+
+		efx_link_status_changed(efx);
+	}
+
+	falcon_poll_xmac(efx);
+}
+
 /* Zeroes out the SRAM contents.  This routine must be called in
  * process context and is allowed to sleep.
  */
-static int falcon_reset_sram(struct efx_nic *efx)
+static int falcon_reset_sram(struct efx_nic *efx, int sram_config)
 {
-	struct falcon_nic_data *nic_data = efx->nic_data;
-	efx_oword_t srm_cfg_reg_ker, gpio_cfg_reg_ker;
-	int count, onchip, sram_cfg_val;
-
-	/* Set the SRAM wake/sleep GPIO appropriately. */
-	onchip = (nic_data->sram_cfg == SRM_NB_BSZ_ONCHIP_ONLY);
-	falcon_read(efx, &gpio_cfg_reg_ker, GPIO_CTL_REG_KER);
-	EFX_SET_OWORD_FIELD(gpio_cfg_reg_ker, GPIO1_OEN, 1);
-	EFX_SET_OWORD_FIELD(gpio_cfg_reg_ker, GPIO1_OUT, onchip);
-	falcon_write(efx, &gpio_cfg_reg_ker, GPIO_CTL_REG_KER);
+	efx_oword_t srm_cfg_reg_ker;
+	int count;
 
 	/* Initiate SRAM reset */
-	sram_cfg_val = onchip ? 0 : nic_data->sram_cfg;
 	EFX_POPULATE_OWORD_2(srm_cfg_reg_ker,
-			     SRAM_OOB_BT_INIT_EN, 1,
-			     SRM_NUM_BANKS_AND_BANK_SIZE, sram_cfg_val);
-	falcon_write(efx, &srm_cfg_reg_ker, SRM_CFG_REG_KER);
+			     FRF_AZ_SRM_INIT_EN, 1,
+			     FRF_AZ_SRM_NB_SZ, sram_config);
+	efx_writeo(efx, &srm_cfg_reg_ker, FR_AZ_SRM_CFG);
 
 	/* Wait for SRAM reset to complete */
 	count = 0;
 	do {
-		EFX_LOG(efx, "waiting for SRAM reset (attempt %d)...\n", count);
+		netif_dbg(efx, hw, efx->net_dev,
+			  "waiting for SRAM reset (attempt %d)...\n", count);
 
 		/* SRAM reset is slow; expect around 16ms */
 		schedule_timeout_uninterruptible(HZ / 50);
 
 		/* Check for reset complete */
-		falcon_read(efx, &srm_cfg_reg_ker, SRM_CFG_REG_KER);
-		if (!EFX_OWORD_FIELD(srm_cfg_reg_ker, SRAM_OOB_BT_INIT_EN)) {
-			EFX_LOG(efx, "SRAM reset complete\n");
+		efx_reado(efx, &srm_cfg_reg_ker, FR_AZ_SRM_CFG);
+		if (!EFX_OWORD_FIELD(srm_cfg_reg_ker, FRF_AZ_SRM_INIT_EN)) {
+			netif_dbg(efx, hw, efx->net_dev,
+				  "SRAM reset complete\n");
 
 			return 0;
 		}
-	} while (++count < 20);	/* wait upto 0.4 sec */
+	} while (++count < 20);	/* wait up to 0.4 sec */
 
-	EFX_ERR(efx, "timed out waiting for SRAM reset\n");
+	netif_err(efx, hw, efx->net_dev, "timed out waiting for SRAM reset\n");
 	return -ETIMEDOUT;
 }
 
-static int falcon_spi_device_init(struct efx_nic *efx,
-				  struct efx_spi_device **spi_device_ret,
+static void falcon_spi_device_init(struct efx_nic *efx,
+				  struct efx_spi_device *spi_device,
 				  unsigned int device_id, u32 device_type)
 {
-	struct efx_spi_device *spi_device;
-
 	if (device_type != 0) {
-		spi_device = kzalloc(sizeof(*spi_device), GFP_KERNEL);
-		if (!spi_device)
-			return -ENOMEM;
 		spi_device->device_id = device_id;
 		spi_device->size =
 			1 << SPI_DEV_TYPE_FIELD(device_type, SPI_DEV_TYPE_SIZE);
@@ -2713,24 +1447,9 @@ static int falcon_spi_device_init(struct
 		spi_device->block_size =
 			1 << SPI_DEV_TYPE_FIELD(device_type,
 						SPI_DEV_TYPE_BLOCK_SIZE);
-
-		spi_device->efx = efx;
 	} else {
-		spi_device = NULL;
+		spi_device->size = 0;
 	}
-
-	kfree(*spi_device_ret);
-	*spi_device_ret = spi_device;
-	return 0;
-}
-
-
-static void falcon_remove_spi_devices(struct efx_nic *efx)
-{
-	kfree(efx->spi_eeprom);
-	efx->spi_eeprom = NULL;
-	kfree(efx->spi_flash);
-	efx->spi_flash = NULL;
 }
 
 /* Extract non-volatile configuration */
@@ -2738,8 +1457,6 @@ static int falcon_probe_nvconfig(struct 
 {
 	struct falcon_nic_data *nic_data = efx->nic_data;
 	struct falcon_nvconfig *nvconfig;
-	int board_rev;
-	bool onchip_sram;
 	int rc;
 
 	nvconfig = kmalloc(sizeof(*nvconfig), GFP_KERNEL);
@@ -2747,266 +1464,166 @@ static int falcon_probe_nvconfig(struct 
 		return -ENOMEM;
 
 	rc = falcon_read_nvram(efx, nvconfig);
-	if (rc == -EINVAL) {
-		EFX_ERR(efx, "NVRAM is invalid therefore using defaults\n");
-		efx->phy_type = PHY_TYPE_NONE;
-		efx->mdio.prtad = MDIO_PRTAD_NONE;
-		board_rev = 0;
-		onchip_sram = true;
-		rc = 0;
-	} else if (rc) {
-		goto fail1;
-	} else {
-		struct falcon_nvconfig_board_v2 *v2 = &nvconfig->board_v2;
-		struct falcon_nvconfig_board_v3 *v3 = &nvconfig->board_v3;
+	if (rc)
+		goto out;
 
-		efx->phy_type = v2->port0_phy_type;
-		efx->mdio.prtad = v2->port0_phy_addr;
-		board_rev = le16_to_cpu(v2->board_revision);
-#ifdef CONFIG_SFC_DRIVERLINK
-		onchip_sram = EFX_OWORD_FIELD(nvconfig->nic_stat_reg,
-					      ONCHIP_SRAM);
-#else
-		/* We have no use for external SRAM */
-		onchip_sram = true;
-#endif
+	memcpy(efx->net_dev->perm_addr, nvconfig->mac_address[0], ETH_ALEN);
 
-		if (le16_to_cpu(nvconfig->board_struct_ver) >= 3) {
-			__le32 fl = v3->spi_device_type[EE_SPI_FLASH];
-			__le32 ee = v3->spi_device_type[EE_SPI_EEPROM];
-			rc = falcon_spi_device_init(efx, &efx->spi_flash,
-						    EE_SPI_FLASH,
-						    le32_to_cpu(fl));
-			if (rc)
-				goto fail2;
-			rc = falcon_spi_device_init(efx, &efx->spi_eeprom,
-						    EE_SPI_EEPROM,
-						    le32_to_cpu(ee));
-			if (rc)
-				goto fail2;
-		}
+	efx->phy_type = nvconfig->board_v2.port0_phy_type;
+	efx->mdio.prtad = nvconfig->board_v2.port0_phy_addr;
+	netif_dbg(efx, probe, efx->net_dev, "PHY is %s(%d) phy_id %d\n",
+		  efx->phy_name, efx->phy_type, efx->mdio.prtad);
+
+	rc = falcon_probe_board(efx,
+				le16_to_cpu(nvconfig->board_v2.board_revision));
+	if (rc)
+		goto out;
+
+	if (le16_to_cpu(nvconfig->board_struct_ver) >= 3) {
+		falcon_spi_device_init(
+			efx, &nic_data->spi_flash, FFE_AB_SPI_DEVICE_FLASH,
+			le32_to_cpu(nvconfig->board_v3
+				    .spi_device_type[FFE_AB_SPI_DEVICE_FLASH]));
+		falcon_spi_device_init(
+			efx, &nic_data->spi_eeprom, FFE_AB_SPI_DEVICE_EEPROM,
+			le32_to_cpu(nvconfig->board_v3
+				    .spi_device_type[FFE_AB_SPI_DEVICE_EEPROM]));
 	}
 
-	/* Read the MAC addresses */
-	memcpy(efx->mac_address, nvconfig->mac_address[0], ETH_ALEN);
-
-	EFX_LOG(efx, "PHY is %d phy_id %d\n", efx->phy_type, efx->mdio.prtad);
-
-	efx_set_board_info(efx, board_rev);
-
 	/* Read the SRAM configuration.  The register is initialised
 	 * automatically but might may been reset since boot.
 	 */
-	if (onchip_sram) {
-		nic_data->sram_cfg = SRM_NB_BSZ_ONCHIP_ONLY;
+	if (EFX_OWORD_FIELD(nvconfig->nic_stat_reg, FRF_AB_ONCHIP_SRAM)) {
+		nic_data->sram_config = SRAM_CONFIG_INTERNAL;
 	} else {
-		nic_data->sram_cfg =
-			EFX_OWORD_FIELD(nvconfig->srm_cfg_reg,
-					SRM_NUM_BANKS_AND_BANK_SIZE);
-		WARN_ON(nic_data->sram_cfg == SRM_NB_BSZ_RESERVED);
+		nic_data->sram_config = EFX_OWORD_FIELD(nvconfig->srm_cfg_reg,
+							FRF_AZ_SRM_NB_SZ);
+		WARN_ON(nic_data->sram_config == FFE_AB_SRM_NB_SZ_RES);
 		/* Replace invalid setting with the smallest defaults */
-		if (nic_data->sram_cfg == SRM_NB_BSZ_DEFAULT)
-			nic_data->sram_cfg = SRM_NB_BSZ_1BANKS_2M;
+		if (nic_data->sram_config == FFE_AB_SRM_NB_SZ_DEF)
+			nic_data->sram_config = FFE_AB_SRM_NB1_SZ2M;
 	}
+	netif_dbg(efx, probe, efx->net_dev,
+		  "sram_config=%d (>=0 is external)\n", nic_data->sram_config);
 
-	kfree(nvconfig);
-	return 0;
-
- fail2:
-	falcon_remove_spi_devices(efx);
- fail1:
+out:
 	kfree(nvconfig);
 	return rc;
 }
 
-/* Looks at available SRAM resources and silicon revision, and works out
- * how many queues we can support, and where things like descriptor caches
- * should live. */
 static int falcon_dimension_resources(struct efx_nic *efx)
 {
 	struct falcon_nic_data *nic_data = efx->nic_data;
-#ifdef CONFIG_SFC_DRIVERLINK
-	unsigned internal_dcs_entries;
-	struct efx_dl_falcon_resources *res = &nic_data->resources;
+	struct efx_dl_falcon_resources *res = &efx->resources;
 
-	/* Fill out the driverlink resource list */
-	res->hdr.type = EFX_DL_FALCON_RESOURCES;
-	res->biu_lock = &efx->biu_lock;
-	efx->dl_info = &res->hdr;
+	res->flags |= EFX_DL_FALCON_HAVE_TIMER_QUANTUM_NS;
+	res->timer_quantum_ns = 24576; /* 3072 cycles */
 
-	/* NB. The minimum values get increased as this driver initialises
-	 * its resources, so this should prevent any overlap.
-	 */
-	switch (falcon_rev(efx)) {
-	case FALCON_REV_A1:
-		res->rxq_min = 16;
-		res->txq_min = 16;
-		res->evq_int_min = 4;
-		res->evq_int_lim = 5;
-		res->evq_timer_min = 5;
-		res->evq_timer_lim = 4096;
-		internal_dcs_entries = 8192;
-		break;
-	case FALCON_REV_B0:
-	default:
-		res->rxq_min = 0;
-		res->txq_min = 0;
-		res->evq_int_min = 0;
-		res->evq_int_lim = 64;
-		res->evq_timer_min = 64;
-		res->evq_timer_lim = 4096;
-		internal_dcs_entries = 4096;
-		break;
-	}
+	if (nic_data->sram_config == SRAM_CONFIG_INTERNAL) {
+		/* We scavenge internal memories to serve as the
+		 * buffer table and descriptor caches. */
+		unsigned internal_dcs_entries =
+			(efx_nic_rev(efx) == EFX_REV_FALCON_A1) ? 8192 : 4096;
 
-	if (nic_data->sram_cfg == SRM_NB_BSZ_ONCHIP_ONLY) {
-		res->rxq_lim = internal_dcs_entries / RX_DC_ENTRIES;
-		res->txq_lim = internal_dcs_entries / TX_DC_ENTRIES;
+		efx->rx_dc_entries = 64;
+		efx->tx_dc_entries = 16;
+		res->rxq_lim = internal_dcs_entries / efx->rx_dc_entries;
+		res->txq_lim = internal_dcs_entries / efx->tx_dc_entries;
 		res->buffer_table_lim = 8192;
-		nic_data->tx_dc_base = TX_DC_INTERNAL_BASE;
-		nic_data->rx_dc_base = RX_DC_INTERNAL_BASE;
+		efx->rx_dc_base = 0x100000;
+		efx->tx_dc_base = 0x130000;
+		efx->sram_lim = 0x140000;
+		return 0;
 	} else {
-		unsigned sram_bytes, vnic_bytes, max_vnics, n_vnics, dcs;
+		/* Otherwise we have a large block of external SRAM */
+		size_t sram_size;
 
-		/* Determine how much SRAM we have to play with.  We have
-		 * to fit buffer table and descriptor caches in.
-		 */
-		switch (nic_data->sram_cfg) {
-		case SRM_NB_BSZ_1BANKS_2M:
+		switch (nic_data->sram_config) {
+		case FFE_AB_SRM_NB1_SZ2M:
 		default:
-			sram_bytes = 2 * 1024 * 1024;
+			sram_size = 2 * 1024 * 1024;
 			break;
-		case SRM_NB_BSZ_1BANKS_4M:
-		case SRM_NB_BSZ_2BANKS_4M:
-			sram_bytes = 4 * 1024 * 1024;
+		case FFE_AB_SRM_NB1_SZ4M:
+		case FFE_AB_SRM_NB2_SZ4M:
+			sram_size = 4 * 1024 * 1024;
 			break;
-		case SRM_NB_BSZ_1BANKS_8M:
-		case SRM_NB_BSZ_2BANKS_8M:
-			sram_bytes = 8 * 1024 * 1024;
+		case FFE_AB_SRM_NB1_SZ8M:
+		case FFE_AB_SRM_NB2_SZ8M:
+			sram_size = 8 * 1024 * 1024;
 			break;
-		case SRM_NB_BSZ_2BANKS_16M:
-			sram_bytes = 16 * 1024 * 1024;
+		case FFE_AB_SRM_NB2_SZ16M:
+			sram_size = 16 * 1024 * 1024;
 			break;
 		}
-		/* For each VNIC allow at least 512 buffer table entries
-		 * and descriptor cache for an rxq and txq.  Buffer table
-		 * space for evqs and dmaqs is relatively trivial, so not
-		 * considered in this calculation.
-		 */
-		vnic_bytes = 512 * 8 + RX_DC_ENTRIES * 8 + TX_DC_ENTRIES * 8;
-		max_vnics = sram_bytes / vnic_bytes;
-		for (n_vnics = 1; n_vnics < res->evq_timer_min + max_vnics;)
-			n_vnics *= 2;
-		res->rxq_lim = n_vnics;
-		res->txq_lim = n_vnics;
-
-		dcs = n_vnics * TX_DC_ENTRIES * 8;
-		nic_data->tx_dc_base = sram_bytes - dcs;
-		dcs = n_vnics * RX_DC_ENTRIES * 8;
-		nic_data->rx_dc_base = nic_data->tx_dc_base - dcs;
-		res->buffer_table_lim = nic_data->rx_dc_base / 8;
+		efx->resources.buffer_table_lim = sram_size / 8;
+		return efx_nic_dimension_resources(efx, sram_size);
 	}
-
-	if (FALCON_IS_DUAL_FUNC(efx))
-		res->flags |= EFX_DL_FALCON_DUAL_FUNC;
-
-	if (EFX_INT_MODE_USE_MSI(efx))
-		res->flags |= EFX_DL_FALCON_USE_MSI;
-#else
-	/* We ignore external SRAM */
-	EFX_BUG_ON_PARANOID(nic_data->sram_cfg != SRM_NB_BSZ_ONCHIP_ONLY);
-	nic_data->tx_dc_base = TX_DC_INTERNAL_BASE;
-	nic_data->rx_dc_base = RX_DC_INTERNAL_BASE;
-#endif
-
-	return 0;
-}
-
-/* Probe the NIC variant (revision, ASIC vs FPGA, function count, port
- * count, port speed).  Set workaround and feature flags accordingly.
- */
-static int falcon_probe_nic_variant(struct efx_nic *efx)
-{
-	efx_oword_t altera_build;
-	efx_oword_t nic_stat;
-
-	falcon_read(efx, &altera_build, ALTERA_BUILD_REG_KER);
-	if (EFX_OWORD_FIELD(altera_build, VER_ALL)) {
-		EFX_ERR(efx, "Falcon FPGA not supported\n");
-		return -ENODEV;
-	}
-
-	falcon_read(efx, &nic_stat, NIC_STAT_REG);
-
-	switch (falcon_rev(efx)) {
-	case FALCON_REV_A0:
-	case 0xff:
-		EFX_ERR(efx, "Falcon rev A0 not supported\n");
-		return -ENODEV;
-
-	case FALCON_REV_A1:
-		if (EFX_OWORD_FIELD(nic_stat, STRAP_PCIE) == 0) {
-			EFX_ERR(efx, "Falcon rev A1 PCI-X not supported\n");
-			return -ENODEV;
-		}
-		efx->silicon_rev = "falcon/a1";
-		break;
-
-	case FALCON_REV_B0:
-		efx->silicon_rev = "falcon/b0";
-		break;
-
-	default:
-		EFX_ERR(efx, "Unknown Falcon rev %d\n", falcon_rev(efx));
-		return -ENODEV;
-	}
-
-	/* Initial assumed speed */
-	efx->link_speed = EFX_OWORD_FIELD(nic_stat, STRAP_10G) ? 10000 : 1000;
-
-	return 0;
 }
 
 /* Probe all SPI devices on the NIC */
 static void falcon_probe_spi_devices(struct efx_nic *efx)
 {
+	struct falcon_nic_data *nic_data = efx->nic_data;
 	efx_oword_t nic_stat, gpio_ctl, ee_vpd_cfg;
 	int boot_dev;
 
-	falcon_read(efx, &gpio_ctl, GPIO_CTL_REG_KER);
-	falcon_read(efx, &nic_stat, NIC_STAT_REG);
-	falcon_read(efx, &ee_vpd_cfg, EE_VPD_CFG_REG_KER);
+	efx_reado(efx, &gpio_ctl, FR_AB_GPIO_CTL);
+	efx_reado(efx, &nic_stat, FR_AB_NIC_STAT);
+	efx_reado(efx, &ee_vpd_cfg, FR_AB_EE_VPD_CFG0);
 
-	if (EFX_OWORD_FIELD(gpio_ctl, BOOTED_USING_NVDEVICE)) {
-		boot_dev = (EFX_OWORD_FIELD(nic_stat, SF_PRST) ?
-			    EE_SPI_FLASH : EE_SPI_EEPROM);
-		EFX_LOG(efx, "Booted from %s\n",
-			boot_dev == EE_SPI_FLASH ? "flash" : "EEPROM");
+	if (EFX_OWORD_FIELD(gpio_ctl, FRF_AB_GPIO3_PWRUP_VALUE)) {
+		boot_dev = (EFX_OWORD_FIELD(nic_stat, FRF_AB_SF_PRST) ?
+			    FFE_AB_SPI_DEVICE_FLASH : FFE_AB_SPI_DEVICE_EEPROM);
+		netif_dbg(efx, probe, efx->net_dev, "Booted from %s\n",
+			  boot_dev == FFE_AB_SPI_DEVICE_FLASH ?
+			  "flash" : "EEPROM");
 	} else {
 		/* Disable VPD and set clock dividers to safe
 		 * values for initial programming. */
 		boot_dev = -1;
-		EFX_LOG(efx, "Booted from internal ASIC settings;"
-			" setting SPI config\n");
-		EFX_POPULATE_OWORD_3(ee_vpd_cfg, EE_VPD_EN, 0,
+		netif_dbg(efx, probe, efx->net_dev,
+			  "Booted from internal ASIC settings;"
+			  " setting SPI config\n");
+		EFX_POPULATE_OWORD_3(ee_vpd_cfg, FRF_AB_EE_VPD_EN, 0,
 				     /* 125 MHz / 7 ~= 20 MHz */
-				     EE_SF_CLOCK_DIV, 7,
+				     FRF_AB_EE_SF_CLOCK_DIV, 7,
 				     /* 125 MHz / 63 ~= 2 MHz */
-				     EE_EE_CLOCK_DIV, 63);
-		falcon_write(efx, &ee_vpd_cfg, EE_VPD_CFG_REG_KER);
+				     FRF_AB_EE_EE_CLOCK_DIV, 63);
+		efx_writeo(efx, &ee_vpd_cfg, FR_AB_EE_VPD_CFG0);
 	}
 
-	if (boot_dev == EE_SPI_FLASH)
-		falcon_spi_device_init(efx, &efx->spi_flash, EE_SPI_FLASH,
-				       default_flash_type);
-	if (boot_dev == EE_SPI_EEPROM)
-		falcon_spi_device_init(efx, &efx->spi_eeprom, EE_SPI_EEPROM,
-				       large_eeprom_type);
+	mutex_init(&nic_data->spi_lock);
+
+	if (boot_dev == FFE_AB_SPI_DEVICE_FLASH || flash_type != -1) {
+		u32 nic_flash_type =
+			flash_type == -1 ? default_flash_type : flash_type;
+		falcon_spi_device_init(efx, &nic_data->spi_flash,
+				       FFE_AB_SPI_DEVICE_FLASH,
+				       nic_flash_type);
+	}
+
+	if (boot_dev == FFE_AB_SPI_DEVICE_EEPROM || eeprom_type != -1) {
+		/* eeprom_type may be -1 (default) for automatic detection,
+		 * 0 or 1 to select the default or large EEPROM, or
+		 * some larger number to specify the precise configuration
+		 */
+		u32 nic_eeprom_type;
+		if (eeprom_type == 0)
+			nic_eeprom_type = small_eeprom_type;
+		else if (eeprom_type == -1 || eeprom_type == 1)
+			nic_eeprom_type = large_eeprom_type;
+		else
+			nic_eeprom_type = eeprom_type;
+		falcon_spi_device_init(efx, &nic_data->spi_eeprom,
+				       FFE_AB_SPI_DEVICE_EEPROM,
+				       nic_eeprom_type);
+	}
 }
 
-int falcon_probe_nic(struct efx_nic *efx)
+static int falcon_probe_nic(struct efx_nic *efx)
 {
 	struct falcon_nic_data *nic_data;
+	struct falcon_board *board;
 	int rc;
 
 	/* Allocate storage for hardware specific data */
@@ -3015,16 +1632,39 @@ int falcon_probe_nic(struct efx_nic *efx
 		return -ENOMEM;
 	efx->nic_data = nic_data;
 
-	/* Determine number of ports etc. */
-	rc = falcon_probe_nic_variant(efx);
-	if (rc)
+	rc = -ENODEV;
+
+	if (efx_nic_fpga_ver(efx) != 0) {
+		netif_err(efx, probe, efx->net_dev,
+			  "Falcon FPGA not supported\n");
 		goto fail1;
+	}
 
-	/* Probe secondary function if expected */
-	if (FALCON_IS_DUAL_FUNC(efx)) {
-		struct pci_dev *dev = pci_dev_get(efx->pci_dev);
+	if (efx_nic_rev(efx) <= EFX_REV_FALCON_A1) {
+		efx_oword_t nic_stat;
+		struct pci_dev *dev;
+		u8 pci_rev = efx->pci_dev->revision;
 
-		while ((dev = pci_get_device(EFX_VENDID_SFC, FALCON_A_S_DEVID,
+		if ((pci_rev == 0xff) || (pci_rev == 0)) {
+			netif_err(efx, probe, efx->net_dev,
+				  "Falcon rev A0 not supported\n");
+			goto fail1;
+		}
+		efx_reado(efx, &nic_stat, FR_AB_NIC_STAT);
+		if (EFX_OWORD_FIELD(nic_stat, FRF_AB_STRAP_10G) == 0) {
+			netif_err(efx, probe, efx->net_dev,
+				  "Falcon rev A1 1G not supported\n");
+			goto fail1;
+		}
+		if (EFX_OWORD_FIELD(nic_stat, FRF_AA_STRAP_PCIE) == 0) {
+			netif_err(efx, probe, efx->net_dev,
+				  "Falcon rev A1 PCI-X not supported\n");
+			goto fail1;
+		}
+
+		dev = pci_dev_get(efx->pci_dev);
+		while ((dev = pci_get_device(PCI_VENDOR_ID_SOLARFLARE,
+					     PCI_DEVICE_ID_SOLARFLARE_SFC4000A_1,
 					     dev))) {
 			if (dev->bus == efx->pci_dev->bus &&
 			    dev->devfn == efx->pci_dev->devfn + 1) {
@@ -3033,236 +1673,355 @@ int falcon_probe_nic(struct efx_nic *efx
 			}
 		}
 		if (!nic_data->pci_dev2) {
-			EFX_ERR(efx, "failed to find secondary function\n");
-			rc = -ENODEV;
-			goto fail2;
+			netif_err(efx, probe, efx->net_dev,
+				  "failed to find secondary function\n");
+			goto fail1;
 		}
 	}
 
 	/* Now we can reset the NIC */
-	rc = falcon_reset_hw(efx, RESET_TYPE_ALL);
+	rc = __falcon_reset_hw(efx, RESET_TYPE_ALL);
 	if (rc) {
-		EFX_ERR(efx, "failed to reset NIC\n");
-		goto fail3;
+		netif_err(efx, probe, efx->net_dev, "failed to reset NIC\n");
+		goto fail2;
 	}
 
 	/* Allocate memory for INT_KER */
-	rc = falcon_alloc_buffer(efx, &efx->irq_status, sizeof(efx_oword_t));
+	rc = efx_nic_alloc_buffer(efx, &efx->irq_status, sizeof(efx_oword_t));
 	if (rc)
-		goto fail4;
+		goto fail3;
 	BUG_ON(efx->irq_status.dma_addr & 0x0f);
 
-	EFX_LOG(efx, "INT_KER at %llx (virt %p phys %llx)\n",
-		(u64)efx->irq_status.dma_addr,
-		efx->irq_status.addr, (u64)virt_to_phys(efx->irq_status.addr));
+	netif_dbg(efx, probe, efx->net_dev,
+		  "INT_KER at %llx (virt %p phys %llx)\n",
+		  (u64)efx->irq_status.dma_addr,
+		  efx->irq_status.addr,
+		  (u64)virt_to_phys(efx->irq_status.addr));
 
 	falcon_probe_spi_devices(efx);
 
 	/* Read in the non-volatile configuration */
 	rc = falcon_probe_nvconfig(efx);
-	if (rc)
-		goto fail5;
+	if (rc) {
+		if (rc == -EINVAL)
+			netif_err(efx, probe, efx->net_dev, "NVRAM is invalid\n");
+		goto fail4;
+	}
 
-	rc = falcon_dimension_resources(efx);
-	if (rc)
-		goto fail6;
+	efx->timer_quantum_ns = 4968; /* 621 cycles */
 
 	/* Initialise I2C adapter */
-	efx->i2c_adap.owner = THIS_MODULE;
-	nic_data->i2c_data = falcon_i2c_bit_operations;
-	nic_data->i2c_data.data = efx;
-	efx->i2c_adap.algo_data = &nic_data->i2c_data;
-	efx->i2c_adap.dev.parent = &efx->pci_dev->dev;
-	strlcpy(efx->i2c_adap.name, "SFC4000 GPIO", sizeof(efx->i2c_adap.name));
-	rc = i2c_bit_add_bus(&efx->i2c_adap);
+	board = falcon_board(efx);
+	board->i2c_adap.owner = THIS_MODULE;
+	board->i2c_data = falcon_i2c_bit_operations;
+	board->i2c_data.data = efx;
+	board->i2c_adap.algo_data = &board->i2c_data;
+	board->i2c_adap.dev.parent = &efx->pci_dev->dev;
+	strlcpy(board->i2c_adap.name, "SFC4000 GPIO",
+		sizeof(board->i2c_adap.name));
+	rc = i2c_bit_add_bus(&board->i2c_adap);
 	if (rc)
-		goto fail6;
+		goto fail4;
+
+	rc = falcon_board(efx)->type->init(efx);
+	if (rc) {
+		netif_err(efx, probe, efx->net_dev,
+			  "failed to initialise board\n");
+		goto fail5;
+	}
+
+	nic_data->stats_disable_count = 1;
+	setup_timer(&nic_data->stats_timer, &falcon_stats_timer_func,
+		    (unsigned long)efx);
 
 	return 0;
 
- fail6:
-#ifdef CONFIG_SFC_DRIVERLINK
-	efx->dl_info = NULL;
-#endif
- fail5:
-	falcon_remove_spi_devices(efx);
-	falcon_free_buffer(efx, &efx->irq_status);
- fail4:
- fail3:
+fail5:
+	BUG_ON(i2c_del_adapter(&board->i2c_adap));
+	memset(&board->i2c_adap, 0, sizeof(board->i2c_adap));
+fail4:
+	efx_nic_free_buffer(efx, &efx->irq_status);
+fail3:
+fail2:
 	if (nic_data->pci_dev2) {
 		pci_dev_put(nic_data->pci_dev2);
 		nic_data->pci_dev2 = NULL;
 	}
- fail2:
- fail1:
-	kfree(efx->nic_data);
+fail1:
+	kfree(nic_data);
 	return rc;
 }
 
+static void falcon_b0_init_ack_repl_timer(struct efx_nic *efx, int num_lanes)
+{
+	unsigned tlp_size;
+	efx_dword_t pcie_ack_rpl_reg;
+	efx_dword_t pcie_ack_freq_reg;
+	efx_dword_t pcie_ctrl_stat_reg;
+	u16 pcie_devicectrl;
+	int lut_index, tlp_size_decoded;
+	int current_replay, expected_replay;
+	int current_ack_timer, current_ack_freq;
+
+	static struct efx_tlp_ack_factor {
+		int tlp;
+		int replay[4]; /* 0=1x, 1=2x, 3=4x, 4=8x (see pcie docs) */
+	} tlp_ack_factor_lut[4] = {
+		{ 128,  { 421, 257, 174, 166 } },
+		{ 256,  { 689, 391, 241, 225 } },
+		{ 512,  { 903, 498, 295, 193 } },
+		{ 1024, { 1670, 881, 487, 290 } }
+	};
+	struct efx_tlp_ack_factor *tlp_ack_factor;
+
+	/* Get TLP size */
+	falcon_b0_pcie_core_read_reg(efx, FPCR_BB_PCIE_DEVICE_CTRL_STAT,
+				     &pcie_ctrl_stat_reg);
+	pcie_devicectrl = (u16) EFX_EXTRACT_DWORD(pcie_ctrl_stat_reg, 0, 15);
+	tlp_size = ((PCI_EXP_DEVCTL_PAYLOAD & pcie_devicectrl) >>
+		    __ffs(PCI_EXP_DEVCTL_PAYLOAD));
+	EFX_WARN_ON_PARANOID(tlp_size > 3); /* => 1024 bytes */
+	tlp_ack_factor = &tlp_ack_factor_lut[tlp_size & 0x3];
+	tlp_size_decoded = tlp_ack_factor->tlp;
+
+	/* Get actual ack & actual and expected replay settings */
+	falcon_b0_pcie_core_read_reg(efx, FPCR_BB_ACK_RPL_TIMER,
+				     &pcie_ack_rpl_reg);
+	current_replay = EFX_DWORD_FIELD(pcie_ack_rpl_reg, FPCRF_BB_RPL_TL);
+	current_ack_timer = EFX_DWORD_FIELD(pcie_ack_rpl_reg, FPCRF_BB_ACK_TL);
+
+	lut_index = ffs(num_lanes) - 1;
+	expected_replay = tlp_ack_factor->replay[lut_index & 0x3];
+
+	falcon_b0_pcie_core_read_reg(efx, FPCR_BB_ACK_FREQ, &pcie_ack_freq_reg);
+	current_ack_freq = EFX_DWORD_FIELD(pcie_ack_freq_reg,
+					   FPCRF_BB_ACK_FREQ);
+
+	netif_dbg(efx, hw, efx->net_dev,
+		  "pcie x%d tlp=%d replay_reg=" EFX_DWORD_FMT " { ack=%d "
+		  "current_replay=%d expected_replay=%d } ack_reg="
+		  EFX_DWORD_FMT " { current_freq=%d expected_freq=%d }\n",
+		  num_lanes, tlp_size_decoded,
+		  EFX_DWORD_VAL(pcie_ack_rpl_reg), current_ack_timer,
+		  current_replay, expected_replay,
+		  EFX_DWORD_VAL(pcie_ack_rpl_reg), current_ack_freq, 0);
+
+	/* If expected replay setting needs to be bigger then set it */
+	if (expected_replay > current_replay) {
+		EFX_SET_DWORD_FIELD(pcie_ack_rpl_reg, FPCRF_BB_RPL_TL,
+				    expected_replay);
+
+		falcon_b0_pcie_core_write_reg(efx, FPCR_BB_ACK_RPL_TIMER,
+					      pcie_ack_rpl_reg);
+	}
+}
+
+static int falcon_init_pcie_core(struct efx_nic *efx)
+{
+	unsigned num_lanes = efx_nic_check_pcie_link(efx, 8, 1);
+
+	if (EFX_WORKAROUND_6943(efx) && num_lanes > 0)
+		falcon_b0_init_ack_repl_timer(efx, num_lanes);
+
+	if (EFX_WORKAROUND_9096(efx)) {
+		efx_dword_t pcie_ack_freq_reg;
+
+		/* ensure ack freq timer is 0 = always ack after timeout */
+		falcon_b0_pcie_core_read_reg(efx, FPCR_BB_ACK_FREQ,
+					     &pcie_ack_freq_reg);
+		EFX_SET_DWORD_FIELD(pcie_ack_freq_reg, FPCRF_BB_ACK_FREQ, 0);
+		falcon_b0_pcie_core_write_reg(efx, FPCR_BB_ACK_FREQ,
+					      pcie_ack_freq_reg);
+	}
+
+	return 0;
+}
+
+static void falcon_fini_pcie_core(struct efx_nic *efx)
+{
+	efx_dword_t pcie_ack_freq_reg;
+
+	if (EFX_WORKAROUND_9096(efx)) {
+		/* Set the ACK frequency timer to 1, so TLP's are acked in
+		 * a timely fashion.
+		 */
+		falcon_b0_pcie_core_read_reg(efx, FPCR_BB_ACK_FREQ,
+					     &pcie_ack_freq_reg);
+		EFX_SET_DWORD_FIELD(pcie_ack_freq_reg, FPCRF_BB_ACK_FREQ, 1);
+		falcon_b0_pcie_core_write_reg(efx, FPCR_BB_ACK_FREQ,
+					      pcie_ack_freq_reg);
+	}
+}
+
+static void falcon_init_rx_cfg(struct efx_nic *efx)
+{
+	/* Prior to Siena the RX DMA engine will split each frame at
+	 * intervals of RX_USR_BUF_SIZE (32-byte units). We set it to
+	 * be so large that that never happens. */
+	const unsigned huge_buf_size = (3 * 4096) >> 5;
+	/* RX control FIFO thresholds (32 entries) */
+	const unsigned ctrl_xon_thr = 20;
+	const unsigned ctrl_xoff_thr = 25;
+	efx_oword_t reg;
+
+	efx_reado(efx, &reg, FR_AZ_RX_CFG);
+	if (efx_nic_rev(efx) <= EFX_REV_FALCON_A1) {
+		/* Data FIFO size is 5.5K */
+		EFX_SET_OWORD_FIELD(reg, FRF_AA_RX_DESC_PUSH_EN, 0);
+		EFX_SET_OWORD_FIELD(reg, FRF_AA_RX_USR_BUF_SIZE,
+				    huge_buf_size);
+		EFX_SET_OWORD_FIELD(reg, FRF_AA_RX_XON_MAC_TH, 512 >> 8);
+		EFX_SET_OWORD_FIELD(reg, FRF_AA_RX_XOFF_MAC_TH, 2048 >> 8);
+		EFX_SET_OWORD_FIELD(reg, FRF_AA_RX_XON_TX_TH, ctrl_xon_thr);
+		EFX_SET_OWORD_FIELD(reg, FRF_AA_RX_XOFF_TX_TH, ctrl_xoff_thr);
+	} else {
+		/* Data FIFO size is 80K; register fields moved */
+		EFX_SET_OWORD_FIELD(reg, FRF_BZ_RX_DESC_PUSH_EN, 0);
+		EFX_SET_OWORD_FIELD(reg, FRF_BZ_RX_USR_BUF_SIZE,
+				    huge_buf_size);
+		/* Send XON and XOFF at ~3 * max MTU away from empty/full */
+		EFX_SET_OWORD_FIELD(reg, FRF_BZ_RX_XON_MAC_TH, 27648 >> 8);
+		EFX_SET_OWORD_FIELD(reg, FRF_BZ_RX_XOFF_MAC_TH, 54272 >> 8);
+		EFX_SET_OWORD_FIELD(reg, FRF_BZ_RX_XON_TX_TH, ctrl_xon_thr);
+		EFX_SET_OWORD_FIELD(reg, FRF_BZ_RX_XOFF_TX_TH, ctrl_xoff_thr);
+		EFX_SET_OWORD_FIELD(reg, FRF_BZ_RX_INGR_EN, 1);
+
+		/* Enable hash insertion. This is broken for the
+		 * 'Falcon' hash so also select Toeplitz TCP/IPv4 and
+		 * IPv4 hashes. */
+		EFX_SET_OWORD_FIELD(reg, FRF_BZ_RX_HASH_INSRT_HDR, 1);
+		EFX_SET_OWORD_FIELD(reg, FRF_BZ_RX_HASH_ALG, 1);
+		EFX_SET_OWORD_FIELD(reg, FRF_BZ_RX_IP_HASH, 1);
+	}
+	/* Always enable XOFF signal from RX FIFO.  We enable
+	 * or disable transmission of pause frames at the MAC. */
+	EFX_SET_OWORD_FIELD(reg, FRF_AZ_RX_XOFF_MAC_EN, 1);
+	efx_writeo(efx, &reg, FR_AZ_RX_CFG);
+}
+
 /* This call performs hardware-specific global initialisation, such as
  * defining the descriptor cache sizes and number of RSS channels.
  * It does not set up any buffers, descriptor rings or event queues.
  */
-int falcon_init_nic(struct efx_nic *efx)
+static int falcon_init_nic(struct efx_nic *efx)
 {
 	struct falcon_nic_data *nic_data = efx->nic_data;
 	efx_oword_t temp;
-	unsigned thresh;
 	int rc;
 
-	/* Use on-chip SRAM if wanted. */
-	falcon_read(efx, &temp, NIC_STAT_REG);
-	EFX_SET_OWORD_FIELD(temp, ONCHIP_SRAM,
-			    nic_data->sram_cfg == SRM_NB_BSZ_ONCHIP_ONLY);
-	falcon_write(efx, &temp, NIC_STAT_REG);
+	/* Use on-chip SRAM if needed */
+	efx_reado(efx, &temp, FR_AB_NIC_STAT);
+	EFX_SET_OWORD_FIELD(temp, FRF_AB_ONCHIP_SRAM,
+			    nic_data->sram_config == SRAM_CONFIG_INTERNAL);
+	efx_writeo(efx, &temp, FR_AB_NIC_STAT);
 
-	/* Set the source of the GMAC clock */
-	if (falcon_rev(efx) == FALCON_REV_B0) {
-		falcon_read(efx, &temp, GPIO_CTL_REG_KER);
-		EFX_SET_OWORD_FIELD(temp, GPIO_USE_NIC_CLK, true);
-		falcon_write(efx, &temp, GPIO_CTL_REG_KER);
-	}
+	/* Warn if <8 lanes of PCIe detected & set pcie timers */
+	rc = falcon_init_pcie_core(efx);
+	if (rc)
+		goto fail1;
 
-	/* Set buffer table mode */
-	EFX_POPULATE_OWORD_1(temp, BUF_TBL_MODE, BUF_TBL_MODE_FULL);
-	falcon_write(efx, &temp, BUF_TBL_CFG_REG_KER);
+	/* Set the SRAM wake/sleep GPIO appropriately. */
+	efx_reado(efx, &temp, FR_AB_GPIO_CTL);
+	EFX_SET_OWORD_FIELD(temp, FRF_AB_GPIO1_OEN, 1);
+	EFX_SET_OWORD_FIELD(temp, FRF_AB_GPIO1_OUT,
+			    nic_data->sram_config == SRAM_CONFIG_INTERNAL);
+	efx_writeo(efx, &temp, FR_AB_GPIO_CTL);
 
-	rc = falcon_reset_sram(efx);
+	rc = falcon_reset_sram(efx,
+			       nic_data->sram_config != SRAM_CONFIG_INTERNAL ?
+			       nic_data->sram_config : 0);
 	if (rc)
-		return rc;
-
-	/* Set positions of descriptor caches in SRAM. */
-	EFX_POPULATE_OWORD_1(temp, SRM_TX_DC_BASE_ADR, nic_data->tx_dc_base / 8);
-	falcon_write(efx, &temp, SRM_TX_DC_CFG_REG_KER);
-	EFX_POPULATE_OWORD_1(temp, SRM_RX_DC_BASE_ADR, nic_data->rx_dc_base / 8);
-	falcon_write(efx, &temp, SRM_RX_DC_CFG_REG_KER);
-
-	/* Set TX descriptor cache size. */
-	BUILD_BUG_ON(TX_DC_ENTRIES != (16 << TX_DC_ENTRIES_ORDER));
-	EFX_POPULATE_OWORD_1(temp, TX_DC_SIZE, TX_DC_ENTRIES_ORDER);
-	falcon_write(efx, &temp, TX_DC_CFG_REG_KER);
-
-	/* Set RX descriptor cache size.  Set low watermark to size-8, as
-	 * this allows most efficient prefetching.
-	 */
-	BUILD_BUG_ON(RX_DC_ENTRIES != (16 << RX_DC_ENTRIES_ORDER));
-	EFX_POPULATE_OWORD_1(temp, RX_DC_SIZE, RX_DC_ENTRIES_ORDER);
-	falcon_write(efx, &temp, RX_DC_CFG_REG_KER);
-	EFX_POPULATE_OWORD_1(temp, RX_DC_PF_LWM, RX_DC_ENTRIES - 8);
-	falcon_write(efx, &temp, RX_DC_PF_WM_REG_KER);
+		goto fail2;
 
 	/* Clear the parity enables on the TX data fifos as
 	 * they produce false parity errors because of timing issues
 	 */
 	if (EFX_WORKAROUND_5129(efx)) {
-		falcon_read(efx, &temp, SPARE_REG_KER);
-		EFX_SET_OWORD_FIELD(temp, MEM_PERR_EN_TX_DATA, 0);
-		falcon_write(efx, &temp, SPARE_REG_KER);
+		efx_reado(efx, &temp, FR_AZ_CSR_SPARE);
+		EFX_SET_OWORD_FIELD(temp, FRF_AB_MEM_PERR_EN_TX_DATA, 0);
+		efx_writeo(efx, &temp, FR_AZ_CSR_SPARE);
 	}
 
-	/* Enable all the genuinely fatal interrupts.  (They are still
-	 * masked by the overall interrupt mask, controlled by
-	 * falcon_interrupts()).
-	 *
-	 * Note: All other fatal interrupts are enabled
-	 */
-	EFX_POPULATE_OWORD_3(temp,
-			     ILL_ADR_INT_KER_EN, 1,
-			     RBUF_OWN_INT_KER_EN, 1,
-			     TBUF_OWN_INT_KER_EN, 1);
-	EFX_INVERT_OWORD(temp);
-	falcon_write(efx, &temp, FATAL_INTR_REG_KER);
-
 	if (EFX_WORKAROUND_7244(efx)) {
-		falcon_read(efx, &temp, RX_FILTER_CTL_REG);
-		EFX_SET_OWORD_FIELD(temp, UDP_FULL_SRCH_LIMIT, 8);
-		EFX_SET_OWORD_FIELD(temp, UDP_WILD_SRCH_LIMIT, 8);
-		EFX_SET_OWORD_FIELD(temp, TCP_FULL_SRCH_LIMIT, 8);
-		EFX_SET_OWORD_FIELD(temp, TCP_WILD_SRCH_LIMIT, 8);
-		falcon_write(efx, &temp, RX_FILTER_CTL_REG);
+		efx_reado(efx, &temp, FR_BZ_RX_FILTER_CTL);
+		EFX_SET_OWORD_FIELD(temp, FRF_BZ_UDP_FULL_SRCH_LIMIT, 8);
+		EFX_SET_OWORD_FIELD(temp, FRF_BZ_UDP_WILD_SRCH_LIMIT, 8);
+		EFX_SET_OWORD_FIELD(temp, FRF_BZ_TCP_FULL_SRCH_LIMIT, 8);
+		EFX_SET_OWORD_FIELD(temp, FRF_BZ_TCP_WILD_SRCH_LIMIT, 8);
+		efx_writeo(efx, &temp, FR_BZ_RX_FILTER_CTL);
 	}
 
-	falcon_setup_rss_indir_table(efx);
+	if (EFX_WORKAROUND_11368(efx)) {
+		/* Ensure that invalid BAR accesses are detected in
+		 * time (prevents denial of service by vNIC users).
+		 */
+		efx_reado(efx, &temp, FR_AZ_HW_INIT);
+		EFX_SET_OWORD_FIELD(temp, FRF_AZ_POST_WR_MASK, 0x0f);
+		EFX_SET_OWORD_FIELD(temp, FRF_AZ_WD_TIMER, 0x10);
+		efx_writeo(efx, &temp, FR_AZ_HW_INIT);
+	}
 
+	/* XXX This is documented only for Falcon A0/A1 */
 	/* Setup RX.  Wait for descriptor is broken and must
 	 * be disabled.  RXDP recovery shouldn't be needed, but is.
 	 */
-	falcon_read(efx, &temp, RX_SELF_RST_REG_KER);
-	EFX_SET_OWORD_FIELD(temp, RX_NODESC_WAIT_DIS, 1);
-	EFX_SET_OWORD_FIELD(temp, RX_RECOVERY_EN, 1);
+	efx_reado(efx, &temp, FR_AA_RX_SELF_RST);
+	EFX_SET_OWORD_FIELD(temp, FRF_AA_RX_NODESC_WAIT_DIS, 1);
+	EFX_SET_OWORD_FIELD(temp, FRF_AA_RX_SELF_RST_EN, 1);
 	if (EFX_WORKAROUND_5583(efx))
-		EFX_SET_OWORD_FIELD(temp, RX_ISCSI_DIS, 1);
-	falcon_write(efx, &temp, RX_SELF_RST_REG_KER);
-
-	/* Disable the ugly timer-based TX DMA backoff and allow TX DMA to be
-	 * controlled by the RX FIFO fill level. Set arbitration to one pkt/Q.
-	 */
-	falcon_read(efx, &temp, TX_CFG2_REG_KER);
-	EFX_SET_OWORD_FIELD(temp, TX_RX_SPACER, 0xfe);
-	EFX_SET_OWORD_FIELD(temp, TX_RX_SPACER_EN, 1);
-	EFX_SET_OWORD_FIELD(temp, TX_ONE_PKT_PER_Q, 1);
-	EFX_SET_OWORD_FIELD(temp, TX_CSR_PUSH_EN, 0);
-	EFX_SET_OWORD_FIELD(temp, TX_DIS_NON_IP_EV, 1);
-	/* Enable SW_EV to inherit in char driver - assume harmless here */
-	EFX_SET_OWORD_FIELD(temp, TX_SW_EV_EN, 1);
-	/* Prefetch threshold 2 => fetch when descriptor cache half empty */
-	EFX_SET_OWORD_FIELD(temp, TX_PREF_THRESHOLD, 2);
-	/* Squash TX of packets of 16 bytes or less */
-	if (falcon_rev(efx) >= FALCON_REV_B0 && EFX_WORKAROUND_9141(efx))
-		EFX_SET_OWORD_FIELD(temp, TX_FLUSH_MIN_LEN_EN_B0, 1);
-	falcon_write(efx, &temp, TX_CFG2_REG_KER);
+		EFX_SET_OWORD_FIELD(temp, FRF_AA_RX_ISCSI_DIS, 1);
+	efx_writeo(efx, &temp, FR_AA_RX_SELF_RST);
 
 	/* Do not enable TX_NO_EOP_DISC_EN, since it limits packets to 16
 	 * descriptors (which is bad).
 	 */
-	falcon_read(efx, &temp, TX_CFG_REG_KER);
-	EFX_SET_OWORD_FIELD(temp, TX_NO_EOP_DISC_EN, 0);
-	falcon_write(efx, &temp, TX_CFG_REG_KER);
+	efx_reado(efx, &temp, FR_AZ_TX_CFG);
+	EFX_SET_OWORD_FIELD(temp, FRF_AZ_TX_NO_EOP_DISC_EN, 0);
+	efx_writeo(efx, &temp, FR_AZ_TX_CFG);
 
-	/* RX config */
-	falcon_read(efx, &temp, RX_CFG_REG_KER);
-	EFX_SET_OWORD_FIELD_VER(efx, temp, RX_DESC_PUSH_EN, 0);
-	if (EFX_WORKAROUND_7575(efx))
-		EFX_SET_OWORD_FIELD_VER(efx, temp, RX_USR_BUF_SIZE,
-					(3 * 4096) / 32);
-	if (falcon_rev(efx) >= FALCON_REV_B0)
-		EFX_SET_OWORD_FIELD(temp, RX_INGR_EN_B0, 1);
+	falcon_init_rx_cfg(efx);
 
-	/* RX FIFO flow control thresholds */
-	thresh = ((rx_xon_thresh_bytes >= 0) ?
-		  rx_xon_thresh_bytes : efx->type->rx_xon_thresh);
-	EFX_SET_OWORD_FIELD_VER(efx, temp, RX_XON_MAC_TH, thresh / 256);
-	thresh = ((rx_xoff_thresh_bytes >= 0) ?
-		  rx_xoff_thresh_bytes : efx->type->rx_xoff_thresh);
-	EFX_SET_OWORD_FIELD_VER(efx, temp, RX_XOFF_MAC_TH, thresh / 256);
-	/* RX control FIFO thresholds [32 entries] */
-	EFX_SET_OWORD_FIELD_VER(efx, temp, RX_XON_TX_TH, 20);
-	EFX_SET_OWORD_FIELD_VER(efx, temp, RX_XOFF_TX_TH, 25);
-	falcon_write(efx, &temp, RX_CFG_REG_KER);
+	if (efx_nic_rev(efx) >= EFX_REV_FALCON_B0) {
+		/* Set hash key for IPv4 */
+		memcpy(&temp, efx->rx_hash_key, sizeof(temp));
+		efx_writeo(efx, &temp, FR_BZ_RX_RSS_TKEY);
 
-	/* Set destination of both TX and RX Flush events */
-	if (falcon_rev(efx) >= FALCON_REV_B0) {
-		EFX_POPULATE_OWORD_1(temp, FLS_EVQ_ID, 0);
-		falcon_write(efx, &temp, DP_CTRL_REG);
+		/* Set destination of both TX and RX Flush events */
+		EFX_POPULATE_OWORD_1(temp, FRF_BZ_FLS_EVQ_ID, 0);
+		efx_writeo(efx, &temp, FR_BZ_DP_CTRL);
 	}
 
+	efx_nic_init_common(efx);
+
 	return 0;
+
+fail2:
+fail1:
+	falcon_fini_pcie_core(efx);
+	return rc;
 }
 
-void falcon_remove_nic(struct efx_nic *efx)
+static void falcon_fini_nic(struct efx_nic *efx)
+{
+	falcon_fini_pcie_core(efx);
+}
+
+static void falcon_remove_nic(struct efx_nic *efx)
 {
 	struct falcon_nic_data *nic_data = efx->nic_data;
+	struct falcon_board *board = falcon_board(efx);
 	int rc;
 
+	board->type->fini(efx);
+
 	/* Remove I2C adapter and clear it in preparation for a retry */
-	rc = i2c_del_adapter(&efx->i2c_adap);
+	rc = i2c_del_adapter(&board->i2c_adap);
 	BUG_ON(rc);
-	memset(&efx->i2c_adap, 0, sizeof(efx->i2c_adap));
+	memset(&board->i2c_adap, 0, sizeof(board->i2c_adap));
 
-	falcon_remove_spi_devices(efx);
-	falcon_free_buffer(efx, &efx->irq_status);
+	efx_nic_free_buffer(efx, &efx->irq_status);
 
-	falcon_reset_hw(efx, RESET_TYPE_ALL);
+	__falcon_reset_hw(efx, RESET_TYPE_ALL);
 
 	/* Release the second function after the reset */
 	if (nic_data->pci_dev2) {
@@ -3270,73 +2029,219 @@ void falcon_remove_nic(struct efx_nic *e
 		nic_data->pci_dev2 = NULL;
 	}
 
-	/* Tear down the private nic state */
+	/* Tear down the private nic state, and the driverlink nic params */
 	kfree(efx->nic_data);
 	efx->nic_data = NULL;
-#ifdef CONFIG_SFC_DRIVERLINK
-	efx->dl_info = NULL;
-#endif
 }
 
-void falcon_update_nic_stats(struct efx_nic *efx)
+static void falcon_update_nic_stats(struct efx_nic *efx)
 {
+	struct falcon_nic_data *nic_data = efx->nic_data;
 	efx_oword_t cnt;
 
-	falcon_read(efx, &cnt, RX_NODESC_DROP_REG_KER);
-	efx->n_rx_nodesc_drop_cnt += EFX_OWORD_FIELD(cnt, RX_NODESC_DROP_CNT);
+	if (nic_data->stats_disable_count)
+		return;
+
+	efx_reado(efx, &cnt, FR_AZ_RX_NODESC_DROP);
+	efx->n_rx_nodesc_drop_cnt +=
+		EFX_OWORD_FIELD(cnt, FRF_AB_RX_NODESC_DROP_CNT);
+
+	if (nic_data->stats_pending &&
+	    *nic_data->stats_dma_done == FALCON_STATS_DONE) {
+		nic_data->stats_pending = false;
+		rmb(); /* read the done flag before the stats */
+		falcon_update_stats_xmac(efx);
+	}
+}
+
+void falcon_start_nic_stats(struct efx_nic *efx)
+{
+	struct falcon_nic_data *nic_data = efx->nic_data;
+
+	spin_lock_bh(&efx->stats_lock);
+	if (--nic_data->stats_disable_count == 0)
+		falcon_stats_request(efx);
+	spin_unlock_bh(&efx->stats_lock);
+}
+
+void falcon_stop_nic_stats(struct efx_nic *efx)
+{
+	struct falcon_nic_data *nic_data = efx->nic_data;
+	int i;
+
+	might_sleep();
+
+	spin_lock_bh(&efx->stats_lock);
+	++nic_data->stats_disable_count;
+	spin_unlock_bh(&efx->stats_lock);
+
+	del_timer_sync(&nic_data->stats_timer);
+
+	/* Wait enough time for the most recent transfer to
+	 * complete. */
+	for (i = 0; i < 4 && nic_data->stats_pending; i++) {
+		if (*nic_data->stats_dma_done == FALCON_STATS_DONE)
+			break;
+		msleep(1);
+	}
+
+	spin_lock_bh(&efx->stats_lock);
+	falcon_stats_complete(efx);
+	spin_unlock_bh(&efx->stats_lock);
+}
+
+static void falcon_set_id_led(struct efx_nic *efx, enum efx_led_mode mode)
+{
+	falcon_board(efx)->type->set_id_led(efx, mode);
 }
 
 /**************************************************************************
  *
- * Revision-dependent attributes used by efx.c
+ * Wake on LAN
  *
  **************************************************************************
  */
 
-struct efx_nic_type falcon_a_nic_type = {
-	.mem_bar = 2,
+static void falcon_get_wol(struct efx_nic *efx, struct ethtool_wolinfo *wol)
+{
+	wol->supported = 0;
+	wol->wolopts = 0;
+	memset(&wol->sopass, 0, sizeof(wol->sopass));
+}
+
+static int falcon_set_wol(struct efx_nic *efx, u32 type)
+{
+	if (type != 0)
+		return -EINVAL;
+	return 0;
+}
+
+/**************************************************************************
+ *
+ * Revision-dependent attributes used by efx.c and nic.c
+ *
+ **************************************************************************
+ */
+
+const struct efx_nic_type falcon_a1_nic_type = {
+	.probe = falcon_probe_nic,
+	.dimension_resources = falcon_dimension_resources,
+	.remove = falcon_remove_nic,
+	.init = falcon_init_nic,
+	.fini = falcon_fini_nic,
+	.monitor = falcon_monitor,
+	.map_reset_reason = falcon_map_reset_reason,
+	.map_reset_flags = falcon_map_reset_flags,
+	.reset = falcon_reset_hw,
+	.probe_port = falcon_probe_port,
+	.remove_port = falcon_remove_port,
+	.handle_global_event = falcon_handle_global_event,
+	.prepare_flush = falcon_prepare_flush,
+	.update_stats = falcon_update_nic_stats,
+	.start_stats = falcon_start_nic_stats,
+	.stop_stats = falcon_stop_nic_stats,
+	.set_id_led = falcon_set_id_led,
+	.push_irq_moderation = falcon_push_irq_moderation,
+	.reconfigure_port = falcon_reconfigure_port,
+	.reconfigure_mac = falcon_reconfigure_xmac,
+	.check_mac_fault = falcon_xmac_check_fault,
+	.get_wol = falcon_get_wol,
+	.set_wol = falcon_set_wol,
+	.resume_wol = efx_port_dummy_op_void,
+	.test_nvram = falcon_test_nvram,
+
+	.revision = EFX_REV_FALCON_A1,
+	.dl_revision = "falcon/a1",
 	.mem_map_size = 0x20000,
-	.txd_ptr_tbl_base = TX_DESC_PTR_TBL_KER_A1,
-	.rxd_ptr_tbl_base = RX_DESC_PTR_TBL_KER_A1,
-	.buf_tbl_base = BUF_TBL_KER_A1,
-	.evq_ptr_tbl_base = EVQ_PTR_TBL_KER_A1,
-	.evq_rptr_tbl_base = EVQ_RPTR_REG_KER_A1,
-	.txd_ring_mask = FALCON_TXD_RING_MASK,
-	.rxd_ring_mask = FALCON_RXD_RING_MASK,
-	.evq_size = FALCON_EVQ_SIZE,
-	.max_dma_mask = FALCON_DMA_MASK,
-	.tx_dma_mask = FALCON_TX_DMA_MASK,
-	.bug5391_mask = 0xf,
-	.rx_xoff_thresh = 2048,
-	.rx_xon_thresh = 512,
+	.txd_ptr_tbl_base = FR_AA_TX_DESC_PTR_TBL_KER,
+	.rxd_ptr_tbl_base = FR_AA_RX_DESC_PTR_TBL_KER,
+	.buf_tbl_base = FR_AA_BUF_FULL_TBL_KER,
+	.evq_ptr_tbl_base = FR_AA_EVQ_PTR_TBL_KER,
+	.evq_rptr_tbl_base = FR_AA_EVQ_RPTR_KER,
+	.max_dma_mask = DMA_BIT_MASK(FSF_AZ_TX_KER_BUF_ADDR_WIDTH),
 	.rx_buffer_padding = 0x24,
 	.max_interrupt_mode = EFX_INT_MODE_MSI,
 	.phys_addr_channels = 4,
+	.timer_period_max =  1 << FRF_AB_TC_TIMER_VAL_WIDTH,
+	.resources = {
+		.hdr.type = EFX_DL_FALCON_RESOURCES,
+		.flags = EFX_DL_FALCON_DUAL_FUNC,
+		/* There are really 4096 queue-sets, but it's not
+		 * worth trying to map more than 1024. */
+		.rxq_min = 16, .rxq_lim = 1024,
+		.txq_min = 16, .txq_lim = 1024,
+		.evq_int_min = 4, .evq_int_lim = 5,
+		.evq_timer_min = 5, .evq_timer_lim = 1024,
+	},
+	.offload_features = NETIF_F_IP_CSUM,
 };
 
-struct efx_nic_type falcon_b_nic_type = {
-	.mem_bar = 2,
+const struct efx_nic_type falcon_b0_nic_type = {
+	.probe = falcon_probe_nic,
+	.dimension_resources = falcon_dimension_resources,
+	.remove = falcon_remove_nic,
+	.init = falcon_init_nic,
+	.fini = falcon_fini_nic,
+	.monitor = falcon_monitor,
+	.map_reset_reason = falcon_map_reset_reason,
+	.map_reset_flags = falcon_map_reset_flags,
+	.reset = falcon_reset_hw,
+	.probe_port = falcon_probe_port,
+	.remove_port = falcon_remove_port,
+	.handle_global_event = falcon_handle_global_event,
+	.prepare_flush = falcon_prepare_flush,
+	.update_stats = falcon_update_nic_stats,
+	.start_stats = falcon_start_nic_stats,
+	.stop_stats = falcon_stop_nic_stats,
+	.set_id_led = falcon_set_id_led,
+	.push_irq_moderation = falcon_push_irq_moderation,
+	.reconfigure_port = falcon_reconfigure_port,
+	.reconfigure_mac = falcon_reconfigure_xmac,
+	.check_mac_fault = falcon_xmac_check_fault,
+	.get_wol = falcon_get_wol,
+	.set_wol = falcon_set_wol,
+	.resume_wol = efx_port_dummy_op_void,
+	.test_registers = falcon_b0_test_registers,
+	.test_memory = falcon_b0_test_memory,
+	.test_nvram = falcon_test_nvram,
+
+	.revision = EFX_REV_FALCON_B0,
+	.dl_revision = "falcon/b0",
 	/* Map everything up to and including the RSS indirection
 	 * table.  Don't map MSI-X table, MSI-X PBA since Linux
 	 * requires that they not be mapped.  */
-	.mem_map_size = RX_RSS_INDIR_TBL_B0 + 0x800,
-	.txd_ptr_tbl_base = TX_DESC_PTR_TBL_KER_B0,
-	.rxd_ptr_tbl_base = RX_DESC_PTR_TBL_KER_B0,
-	.buf_tbl_base = BUF_TBL_KER_B0,
-	.evq_ptr_tbl_base = EVQ_PTR_TBL_KER_B0,
-	.evq_rptr_tbl_base = EVQ_RPTR_REG_KER_B0,
-	.txd_ring_mask = FALCON_TXD_RING_MASK,
-	.rxd_ring_mask = FALCON_RXD_RING_MASK,
-	.evq_size = FALCON_EVQ_SIZE,
-	.max_dma_mask = FALCON_DMA_MASK,
-	.tx_dma_mask = FALCON_TX_DMA_MASK,
-	.bug5391_mask = 0,
-	.rx_xoff_thresh = 54272, /* ~80Kb - 3*max MTU */
-	.rx_xon_thresh = 27648,  /* ~3*max MTU */
+	.mem_map_size = (FR_BZ_RX_INDIRECTION_TBL +
+			 FR_BZ_RX_INDIRECTION_TBL_STEP *
+			 FR_BZ_RX_INDIRECTION_TBL_ROWS),
+	.txd_ptr_tbl_base = FR_BZ_TX_DESC_PTR_TBL,
+	.rxd_ptr_tbl_base = FR_BZ_RX_DESC_PTR_TBL,
+	.buf_tbl_base = FR_BZ_BUF_FULL_TBL,
+	.evq_ptr_tbl_base = FR_BZ_EVQ_PTR_TBL,
+	.evq_rptr_tbl_base = FR_BZ_EVQ_RPTR,
+	.max_dma_mask = DMA_BIT_MASK(FSF_AZ_TX_KER_BUF_ADDR_WIDTH),
+	.rx_buffer_hash_size = 0x10,
 	.rx_buffer_padding = 0,
 	.max_interrupt_mode = EFX_INT_MODE_MSIX,
 	.phys_addr_channels = 32, /* Hardware limit is 64, but the legacy
 				   * interrupt handler only supports 32
 				   * channels */
+	.timer_period_max =  1 << FRF_AB_TC_TIMER_VAL_WIDTH,
+	.resources = {
+		.hdr.next = ((struct efx_dl_device_info *)
+			     &falcon_b0_nic_type.dl_hash_insertion.hdr),
+		.hdr.type = EFX_DL_FALCON_RESOURCES,
+		/* There are really 4096 queue-sets, but it's not
+		 * worth trying to map more than 1024. */
+		.rxq_min = 0, .rxq_lim = 1024,
+		.txq_min = 0, .txq_lim = 1024,
+		.evq_int_min = 0, .evq_int_lim = 64,
+		.evq_timer_min = 64, .evq_timer_lim = 1024,
+	},
+	.dl_hash_insertion = {
+		.hdr.type = EFX_DL_HASH_INSERTION,
+		.data_offset = 0x10,
+		.hash_offset = 0x0c,
+		.flags = EFX_DL_HASH_TOEP_TCPIP4 | EFX_DL_HASH_TOEP_IP4,
+	},
+	.offload_features = NETIF_F_IP_CSUM | NETIF_F_RXHASH | NETIF_F_NTUPLE,
 };
-
diff -r 9566a4a50a43 drivers/net/sfc/falcon.h
--- a/drivers/net/sfc/falcon.h
+++ /dev/null
@@ -1,145 +0,0 @@
-/****************************************************************************
- * Driver for Solarflare Solarstorm network controllers and boards
- * Copyright 2005-2006 Fen Systems Ltd.
- * Copyright 2006-2008 Solarflare Communications Inc.
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 as published
- * by the Free Software Foundation, incorporated herein by reference.
- */
-
-#ifndef EFX_FALCON_H
-#define EFX_FALCON_H
-
-#include "net_driver.h"
-#include "efx.h"
-
-/*
- * Falcon hardware control
- */
-
-enum falcon_revision {
-	FALCON_REV_A0 = 0,
-	FALCON_REV_A1 = 1,
-	FALCON_REV_B0 = 2,
-};
-
-static inline int falcon_rev(struct efx_nic *efx)
-{
-	return efx->pci_dev->revision;
-}
-
-extern struct efx_nic_type falcon_a_nic_type;
-extern struct efx_nic_type falcon_b_nic_type;
-
-/**************************************************************************
- *
- * Externs
- *
- **************************************************************************
- */
-
-/* TX data path */
-extern int falcon_probe_tx(struct efx_tx_queue *tx_queue);
-extern void falcon_init_tx(struct efx_tx_queue *tx_queue);
-extern void falcon_fini_tx(struct efx_tx_queue *tx_queue);
-extern void falcon_remove_tx(struct efx_tx_queue *tx_queue);
-extern void falcon_push_buffers(struct efx_tx_queue *tx_queue);
-
-/* RX data path */
-extern int falcon_probe_rx(struct efx_rx_queue *rx_queue);
-extern void falcon_init_rx(struct efx_rx_queue *rx_queue);
-extern void falcon_fini_rx(struct efx_rx_queue *rx_queue);
-extern void falcon_remove_rx(struct efx_rx_queue *rx_queue);
-extern void falcon_notify_rx_desc(struct efx_rx_queue *rx_queue);
-
-/* Event data path */
-extern int falcon_probe_eventq(struct efx_channel *channel);
-extern void falcon_init_eventq(struct efx_channel *channel);
-extern void falcon_fini_eventq(struct efx_channel *channel);
-extern void falcon_remove_eventq(struct efx_channel *channel);
-extern int falcon_process_eventq(struct efx_channel *channel, int rx_quota);
-extern void falcon_eventq_read_ack(struct efx_channel *channel);
-
-/* Ports */
-extern int falcon_probe_port(struct efx_nic *efx);
-extern void falcon_remove_port(struct efx_nic *efx);
-
-/* MAC/PHY */
-extern int falcon_switch_mac(struct efx_nic *efx);
-extern bool falcon_xaui_link_ok(struct efx_nic *efx);
-extern int falcon_dma_stats(struct efx_nic *efx,
-			    unsigned int done_offset);
-extern void falcon_drain_tx_fifo(struct efx_nic *efx);
-extern void falcon_deconfigure_mac_wrapper(struct efx_nic *efx);
-extern void falcon_reconfigure_mac_wrapper(struct efx_nic *efx);
-
-/* Interrupts and test events */
-extern int falcon_init_interrupt(struct efx_nic *efx);
-extern void falcon_enable_interrupts(struct efx_nic *efx);
-extern void falcon_generate_test_event(struct efx_channel *channel,
-				       unsigned int magic);
-extern void falcon_sim_phy_event(struct efx_nic *efx);
-extern void falcon_generate_interrupt(struct efx_nic *efx);
-extern void falcon_set_int_moderation(struct efx_channel *channel);
-extern void falcon_disable_interrupts(struct efx_nic *efx);
-extern void falcon_fini_interrupt(struct efx_nic *efx);
-
-#define FALCON_IRQ_MOD_RESOLUTION 5
-
-/* Global Resources */
-extern int falcon_probe_nic(struct efx_nic *efx);
-extern int falcon_probe_resources(struct efx_nic *efx);
-extern int falcon_init_nic(struct efx_nic *efx);
-extern int falcon_flush_queues(struct efx_nic *efx);
-extern int falcon_reset_hw(struct efx_nic *efx, enum reset_type method);
-extern void falcon_remove_resources(struct efx_nic *efx);
-extern void falcon_remove_nic(struct efx_nic *efx);
-extern void falcon_update_nic_stats(struct efx_nic *efx);
-extern void falcon_set_multicast_hash(struct efx_nic *efx);
-extern int falcon_reset_xaui(struct efx_nic *efx);
-
-/* Tests */
-struct falcon_nvconfig;
-extern int falcon_read_nvram(struct efx_nic *efx,
-			     struct falcon_nvconfig *nvconfig);
-extern int falcon_test_registers(struct efx_nic *efx);
-
-/**************************************************************************
- *
- * Falcon MAC stats
- *
- **************************************************************************
- */
-
-#define FALCON_STAT_OFFSET(falcon_stat) EFX_VAL(falcon_stat, offset)
-#define FALCON_STAT_WIDTH(falcon_stat) EFX_VAL(falcon_stat, WIDTH)
-
-/* Retrieve statistic from statistics block */
-#define FALCON_STAT(efx, falcon_stat, efx_stat) do {		\
-	if (FALCON_STAT_WIDTH(falcon_stat) == 16)		\
-		(efx)->mac_stats.efx_stat += le16_to_cpu(	\
-			*((__force __le16 *)				\
-			  (efx->stats_buffer.addr +		\
-			   FALCON_STAT_OFFSET(falcon_stat))));	\
-	else if (FALCON_STAT_WIDTH(falcon_stat) == 32)		\
-		(efx)->mac_stats.efx_stat += le32_to_cpu(	\
-			*((__force __le32 *)				\
-			  (efx->stats_buffer.addr +		\
-			   FALCON_STAT_OFFSET(falcon_stat))));	\
-	else							\
-		(efx)->mac_stats.efx_stat += le64_to_cpu(	\
-			*((__force __le64 *)				\
-			  (efx->stats_buffer.addr +		\
-			   FALCON_STAT_OFFSET(falcon_stat))));	\
-	} while (0)
-
-#define FALCON_MAC_STATS_SIZE 0x100
-
-#define MAC_DATA_LBN 0
-#define MAC_DATA_WIDTH 32
-
-extern void falcon_generate_event(struct efx_channel *channel,
-				  efx_qword_t *event);
-
-#endif /* EFX_FALCON_H */
diff -r 9566a4a50a43 drivers/net/sfc/falcon_boards.c
--- /dev/null
+++ b/drivers/net/sfc/falcon_boards.c
@@ -0,0 +1,738 @@
+/****************************************************************************
+ * Driver for Solarflare Solarstorm network controllers and boards
+ * Copyright 2007-2010 Solarflare Communications Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 as published
+ * by the Free Software Foundation, incorporated herein by reference.
+ */
+
+#include "net_driver.h"
+#include "phy.h"
+#include "efx.h"
+#include "nic.h"
+#include "workarounds.h"
+
+/* Macros for unpacking the board revision */
+/* The revision info is in host byte order. */
+#define FALCON_BOARD_TYPE(_rev) (_rev >> 8)
+#define FALCON_BOARD_MAJOR(_rev) ((_rev >> 4) & 0xf)
+#define FALCON_BOARD_MINOR(_rev) (_rev & 0xf)
+
+/* Board types */
+#define FALCON_BOARD_SFE4001 0x01
+#define FALCON_BOARD_SFE4002 0x02
+#define FALCON_BOARD_SFE4003 0x03
+#define FALCON_BOARD_SFN4112F 0x52
+
+/* Board temperature is about 15°C above ambient when air flow is
+ * limited.  The maximum acceptable ambient temperature varies
+ * depending on the PHY specifications but the critical temperature
+ * above which we should shut down to avoid damage is 80°C. */
+#define FALCON_BOARD_TEMP_BIAS	15
+#define FALCON_BOARD_TEMP_CRIT	(80 + FALCON_BOARD_TEMP_BIAS)
+
+/* SFC4000 datasheet says: 'The maximum permitted junction temperature
+ * is 125°C; the thermal design of the environment for the SFC4000
+ * should aim to keep this well below 100°C.' */
+#define FALCON_JUNC_TEMP_MIN	0
+#define FALCON_JUNC_TEMP_MAX	90
+#define FALCON_JUNC_TEMP_CRIT	125
+
+/*****************************************************************************
+ * Support for LM87 sensor chip used on several boards
+ */
+#define LM87_REG_TEMP_HW_INT_LOCK	0x13
+#define LM87_REG_TEMP_HW_EXT_LOCK	0x14
+#define LM87_REG_TEMP_HW_INT		0x17
+#define LM87_REG_TEMP_HW_EXT		0x18
+#define LM87_REG_TEMP_EXT1		0x26
+#define LM87_REG_TEMP_INT		0x27
+#define LM87_REG_ALARMS1		0x41
+#define LM87_REG_ALARMS2		0x42
+#define LM87_IN_LIMITS(nr, _min, _max)			\
+	0x2B + (nr) * 2, _max, 0x2C + (nr) * 2, _min
+#define LM87_AIN_LIMITS(nr, _min, _max)			\
+	0x3B + (nr), _max, 0x1A + (nr), _min
+#define LM87_TEMP_INT_LIMITS(_min, _max)		\
+	0x39, _max, 0x3A, _min
+#define LM87_TEMP_EXT1_LIMITS(_min, _max)		\
+	0x37, _max, 0x38, _min
+
+#define LM87_ALARM_TEMP_INT		0x10
+#define LM87_ALARM_TEMP_EXT1		0x20
+
+static int efx_poke_lm87(struct i2c_client *client, const u8 *reg_values)
+{
+	while (*reg_values) {
+		u8 reg = *reg_values++;
+		u8 value = *reg_values++;
+		int rc = i2c_smbus_write_byte_data(client, reg, value);
+		if (rc)
+			return rc;
+	}
+	return 0;
+}
+
+static const u8 falcon_lm87_common_regs[] = {
+	LM87_REG_TEMP_HW_INT_LOCK, FALCON_BOARD_TEMP_CRIT,
+	LM87_REG_TEMP_HW_INT, FALCON_BOARD_TEMP_CRIT,
+	LM87_TEMP_EXT1_LIMITS(FALCON_JUNC_TEMP_MIN, FALCON_JUNC_TEMP_MAX),
+	LM87_REG_TEMP_HW_EXT_LOCK, FALCON_JUNC_TEMP_CRIT,
+	LM87_REG_TEMP_HW_EXT, FALCON_JUNC_TEMP_CRIT,
+	0
+};
+
+static int efx_init_lm87(struct efx_nic *efx, struct i2c_board_info *info,
+			 const u8 *reg_values)
+{
+	struct falcon_board *board = falcon_board(efx);
+	struct i2c_client *client = i2c_new_device(&board->i2c_adap, info);
+	int rc;
+
+	if (!client)
+		return -EIO;
+
+	/* Read-to-clear alarm/interrupt status */
+	i2c_smbus_read_byte_data(client, LM87_REG_ALARMS1);
+	i2c_smbus_read_byte_data(client, LM87_REG_ALARMS2);
+
+	rc = efx_poke_lm87(client, reg_values);
+	if (rc)
+		goto err;
+	rc = efx_poke_lm87(client, falcon_lm87_common_regs);
+	if (rc)
+		goto err;
+
+	board->hwmon_client = client;
+	return 0;
+
+err:
+	i2c_unregister_device(client);
+	return rc;
+}
+
+static void efx_fini_lm87(struct efx_nic *efx)
+{
+	i2c_unregister_device(falcon_board(efx)->hwmon_client);
+}
+
+static int efx_check_lm87(struct efx_nic *efx, unsigned mask)
+{
+	struct i2c_client *client = falcon_board(efx)->hwmon_client;
+	bool temp_crit, elec_fault, is_failure;
+	u16 alarms;
+	s32 reg;
+
+	/* If link is up then do not monitor temperature */
+	if (EFX_WORKAROUND_7884(efx) && efx->link_state.up)
+		return 0;
+
+	reg = i2c_smbus_read_byte_data(client, LM87_REG_ALARMS1);
+	if (reg < 0)
+		return reg;
+	alarms = reg;
+	reg = i2c_smbus_read_byte_data(client, LM87_REG_ALARMS2);
+	if (reg < 0)
+		return reg;
+	alarms |= reg << 8;
+	alarms &= mask;
+
+	temp_crit = false;
+	if (alarms & LM87_ALARM_TEMP_INT) {
+		reg = i2c_smbus_read_byte_data(client, LM87_REG_TEMP_INT);
+		if (reg < 0)
+			return reg;
+		if (reg > FALCON_BOARD_TEMP_CRIT)
+			temp_crit = true;
+	}
+	if (alarms & LM87_ALARM_TEMP_EXT1) {
+		reg = i2c_smbus_read_byte_data(client, LM87_REG_TEMP_EXT1);
+		if (reg < 0)
+			return reg;
+		if (reg > FALCON_JUNC_TEMP_CRIT)
+			temp_crit = true;
+	}
+	elec_fault = alarms & ~(LM87_ALARM_TEMP_INT | LM87_ALARM_TEMP_EXT1);
+	is_failure = temp_crit || elec_fault;
+
+	if (alarms)
+		netif_err(efx, hw, efx->net_dev,
+			  "LM87 detected a hardware %s (status %02x:%02x)"
+			  "%s%s%s%s\n",
+			  is_failure ? "failure" : "problem",
+			  alarms & 0xff, alarms >> 8,
+			  (alarms & LM87_ALARM_TEMP_INT) ?
+			  "; board is overheating" : "",
+			  (alarms & LM87_ALARM_TEMP_EXT1) ?
+			  "; controller is overheating" : "",
+			  temp_crit ? "; reached critical temperature" : "",
+			  elec_fault ? "; electrical fault" : "");
+
+	return is_failure ? -ERANGE : 0;
+}
+
+/*****************************************************************************
+ * Support for the SFE4001 NIC.
+ *
+ * The SFE4001 does not power-up fully at reset due to its high power
+ * consumption.  We control its power via a PCA9539 I/O expander.
+ * It also has a MAX6647 temperature monitor which we expose to
+ * the lm90 driver.
+ *
+ * This also provides minimal support for reflashing the PHY, which is
+ * initiated by resetting it with the FLASH_CFG_1 pin pulled down.
+ * On SFE4001 rev A2 and later this is connected to the 3V3X output of
+ * the IO-expander.
+ * We represent reflash mode as PHY_MODE_SPECIAL and make it mutually
+ * exclusive with the network device being open.
+ */
+
+/**************************************************************************
+ * Support for I2C IO Expander device on SFE4001
+ */
+#define	PCA9539 0x74
+
+#define	P0_IN 0x00
+#define	P0_OUT 0x02
+#define	P0_INVERT 0x04
+#define	P0_CONFIG 0x06
+
+#define	P0_EN_1V0X_LBN 0
+#define	P0_EN_1V0X_WIDTH 1
+#define	P0_EN_1V2_LBN 1
+#define	P0_EN_1V2_WIDTH 1
+#define	P0_EN_2V5_LBN 2
+#define	P0_EN_2V5_WIDTH 1
+#define	P0_EN_3V3X_LBN 3
+#define	P0_EN_3V3X_WIDTH 1
+#define	P0_EN_5V_LBN 4
+#define	P0_EN_5V_WIDTH 1
+#define	P0_SHORTEN_JTAG_LBN 5
+#define	P0_SHORTEN_JTAG_WIDTH 1
+#define	P0_X_TRST_LBN 6
+#define	P0_X_TRST_WIDTH 1
+#define	P0_DSP_RESET_LBN 7
+#define	P0_DSP_RESET_WIDTH 1
+
+#define	P1_IN 0x01
+#define	P1_OUT 0x03
+#define	P1_INVERT 0x05
+#define	P1_CONFIG 0x07
+
+#define	P1_AFE_PWD_LBN 0
+#define	P1_AFE_PWD_WIDTH 1
+#define	P1_DSP_PWD25_LBN 1
+#define	P1_DSP_PWD25_WIDTH 1
+#define	P1_RESERVED_LBN 2
+#define	P1_RESERVED_WIDTH 2
+#define	P1_SPARE_LBN 4
+#define	P1_SPARE_WIDTH 4
+
+/* Temperature Sensor */
+#define MAX664X_REG_RSL		0x02
+#define MAX664X_REG_WLHO	0x0B
+
+static void sfe4001_poweroff(struct efx_nic *efx)
+{
+	struct i2c_client *ioexp_client = falcon_board(efx)->ioexp_client;
+	struct i2c_client *hwmon_client = falcon_board(efx)->hwmon_client;
+
+	/* Turn off all power rails and disable outputs */
+	i2c_smbus_write_byte_data(ioexp_client, P0_OUT, 0xff);
+	i2c_smbus_write_byte_data(ioexp_client, P1_CONFIG, 0xff);
+	i2c_smbus_write_byte_data(ioexp_client, P0_CONFIG, 0xff);
+
+	/* Clear any over-temperature alert */
+	i2c_smbus_read_byte_data(hwmon_client, MAX664X_REG_RSL);
+}
+
+static int sfe4001_poweron(struct efx_nic *efx)
+{
+	struct i2c_client *ioexp_client = falcon_board(efx)->ioexp_client;
+	struct i2c_client *hwmon_client = falcon_board(efx)->hwmon_client;
+	unsigned int i, j;
+	int rc;
+	u8 out;
+
+	/* Clear any previous over-temperature alert */
+	rc = i2c_smbus_read_byte_data(hwmon_client, MAX664X_REG_RSL);
+	if (rc < 0)
+		return rc;
+
+	/* Enable port 0 and port 1 outputs on IO expander */
+	rc = i2c_smbus_write_byte_data(ioexp_client, P0_CONFIG, 0x00);
+	if (rc)
+		return rc;
+	rc = i2c_smbus_write_byte_data(ioexp_client, P1_CONFIG,
+				       0xff & ~(1 << P1_SPARE_LBN));
+	if (rc)
+		goto fail_on;
+
+	/* If PHY power is on, turn it all off and wait 1 second to
+	 * ensure a full reset.
+	 */
+	rc = i2c_smbus_read_byte_data(ioexp_client, P0_OUT);
+	if (rc < 0)
+		goto fail_on;
+	out = 0xff & ~((0 << P0_EN_1V2_LBN) | (0 << P0_EN_2V5_LBN) |
+		       (0 << P0_EN_3V3X_LBN) | (0 << P0_EN_5V_LBN) |
+		       (0 << P0_EN_1V0X_LBN));
+	if (rc != out) {
+		netif_info(efx, hw, efx->net_dev, "power-cycling PHY\n");
+		rc = i2c_smbus_write_byte_data(ioexp_client, P0_OUT, out);
+		if (rc)
+			goto fail_on;
+		schedule_timeout_uninterruptible(HZ);
+	}
+
+	for (i = 0; i < 20; ++i) {
+		/* Turn on 1.2V, 2.5V, 3.3V and 5V power rails */
+		out = 0xff & ~((1 << P0_EN_1V2_LBN) | (1 << P0_EN_2V5_LBN) |
+			       (1 << P0_EN_3V3X_LBN) | (1 << P0_EN_5V_LBN) |
+			       (1 << P0_X_TRST_LBN));
+		if (efx->phy_mode & PHY_MODE_SPECIAL)
+			out |= 1 << P0_EN_3V3X_LBN;
+
+		rc = i2c_smbus_write_byte_data(ioexp_client, P0_OUT, out);
+		if (rc)
+			goto fail_on;
+		msleep(10);
+
+		/* Turn on 1V power rail */
+		out &= ~(1 << P0_EN_1V0X_LBN);
+		rc = i2c_smbus_write_byte_data(ioexp_client, P0_OUT, out);
+		if (rc)
+			goto fail_on;
+
+		netif_info(efx, hw, efx->net_dev,
+			   "waiting for DSP boot (attempt %d)...\n", i);
+
+		/* In flash config mode, DSP does not turn on AFE, so
+		 * just wait 1 second.
+		 */
+		if (efx->phy_mode & PHY_MODE_SPECIAL) {
+			schedule_timeout_uninterruptible(HZ);
+			return 0;
+		}
+
+		for (j = 0; j < 10; ++j) {
+			msleep(100);
+
+			/* Check DSP has asserted AFE power line */
+			rc = i2c_smbus_read_byte_data(ioexp_client, P1_IN);
+			if (rc < 0)
+				goto fail_on;
+			if (rc & (1 << P1_AFE_PWD_LBN))
+				return 0;
+		}
+	}
+
+	netif_info(efx, hw, efx->net_dev, "timed out waiting for DSP boot\n");
+	rc = -ETIMEDOUT;
+fail_on:
+	sfe4001_poweroff(efx);
+	return rc;
+}
+
+static ssize_t show_phy_flash_cfg(struct device *dev,
+				  struct device_attribute *attr, char *buf)
+{
+	struct efx_nic *efx = pci_get_drvdata(to_pci_dev(dev));
+	return sprintf(buf, "%d\n", !!(efx->phy_mode & PHY_MODE_SPECIAL));
+}
+
+static ssize_t set_phy_flash_cfg(struct device *dev,
+				 struct device_attribute *attr,
+				 const char *buf, size_t count)
+{
+	struct efx_nic *efx = pci_get_drvdata(to_pci_dev(dev));
+	enum efx_phy_mode old_mode, new_mode;
+	int err;
+
+	rtnl_lock();
+	old_mode = efx->phy_mode;
+	if (count == 0 || *buf == '0')
+		new_mode = old_mode & ~PHY_MODE_SPECIAL;
+	else
+		new_mode = PHY_MODE_SPECIAL;
+	if (!((old_mode ^ new_mode) & PHY_MODE_SPECIAL)) {
+		err = 0;
+	} else if (efx->state != STATE_RUNNING || netif_running(efx->net_dev)) {
+		err = -EBUSY;
+	} else {
+		/* Reset the PHY, reconfigure the MAC and enable/disable
+		 * MAC stats accordingly. */
+		efx->phy_mode = new_mode;
+		if (new_mode & PHY_MODE_SPECIAL)
+			falcon_stop_nic_stats(efx);
+		err = sfe4001_poweron(efx);
+		if (!err)
+			err = efx_reconfigure_port(efx);
+		if (!(new_mode & PHY_MODE_SPECIAL))
+			falcon_start_nic_stats(efx);
+	}
+	rtnl_unlock();
+
+	return err ? err : count;
+}
+
+static DEVICE_ATTR(phy_flash_cfg, 0644, show_phy_flash_cfg, set_phy_flash_cfg);
+
+static void sfe4001_fini(struct efx_nic *efx)
+{
+	struct falcon_board *board = falcon_board(efx);
+
+	netif_info(efx, drv, efx->net_dev, "%s\n", __func__);
+
+	device_remove_file(&efx->pci_dev->dev, &dev_attr_phy_flash_cfg);
+	sfe4001_poweroff(efx);
+	i2c_unregister_device(board->ioexp_client);
+	i2c_unregister_device(board->hwmon_client);
+}
+
+static int sfe4001_check_hw(struct efx_nic *efx)
+{
+	struct falcon_nic_data *nic_data = efx->nic_data;
+	s32 status;
+
+	/* If XAUI link is up then do not monitor */
+	if (EFX_WORKAROUND_7884(efx) && !nic_data->xmac_poll_required)
+		return 0;
+	if (efx->phy_mode != PHY_MODE_NORMAL)
+		return 0;
+
+	/* Check the powered status of the PHY. Lack of power implies that
+	 * the MAX6647 has shut down power to it, probably due to a temp.
+	 * alarm. Reading the power status rather than the MAX6647 status
+	 * directly because the later is read-to-clear and would thus
+	 * start to power up the PHY again when polled, causing us to blip
+	 * the power undesirably.
+	 * We know we can read from the IO expander because we did
+	 * it during power-on. Assume failure now is bad news. */
+	status = i2c_smbus_read_byte_data(falcon_board(efx)->ioexp_client, P1_IN);
+	if (status >= 0 &&
+	    (status & ((1 << P1_AFE_PWD_LBN) | (1 << P1_DSP_PWD25_LBN))) != 0)
+		return 0;
+
+	/* Use board power control, not PHY power control */
+	sfe4001_poweroff(efx);
+	efx->phy_mode = PHY_MODE_OFF;
+
+	return (status < 0) ? -EIO : -ERANGE;
+}
+
+static struct i2c_board_info sfe4001_hwmon_info = {
+	I2C_BOARD_INFO("max6647", 0x4e),
+};
+
+/* This board uses an I2C expander to provider power to the PHY, which needs to
+ * be turned on before the PHY can be used.
+ * Context: Process context, rtnl lock held
+ */
+static int sfe4001_init(struct efx_nic *efx)
+{
+	struct falcon_board *board = falcon_board(efx);
+	int rc;
+
+	board->hwmon_client =
+		i2c_new_device(&board->i2c_adap, &sfe4001_hwmon_info);
+	if (!board->hwmon_client)
+		return -EIO;
+
+	/* Raise board/PHY high limit from 85 to 90 degrees Celsius */
+	rc = i2c_smbus_write_byte_data(board->hwmon_client,
+				       MAX664X_REG_WLHO, 90);
+	if (rc)
+		goto fail_hwmon;
+
+	board->ioexp_client = i2c_new_dummy(&board->i2c_adap, PCA9539);
+	if (!board->ioexp_client) {
+		rc = -EIO;
+		goto fail_hwmon;
+	}
+
+	if (efx->phy_mode & PHY_MODE_SPECIAL) {
+		/* PHY won't generate a 156.25 MHz clock and MAC stats fetch
+		 * will fail. */
+		falcon_stop_nic_stats(efx);
+	}
+	rc = sfe4001_poweron(efx);
+	if (rc)
+		goto fail_ioexp;
+
+	rc = device_create_file(&efx->pci_dev->dev, &dev_attr_phy_flash_cfg);
+	if (rc)
+		goto fail_on;
+
+	netif_info(efx, hw, efx->net_dev, "PHY is powered on\n");
+	return 0;
+
+fail_on:
+	sfe4001_poweroff(efx);
+fail_ioexp:
+	i2c_unregister_device(board->ioexp_client);
+fail_hwmon:
+	i2c_unregister_device(board->hwmon_client);
+	return rc;
+}
+
+/*****************************************************************************
+ * Support for the SFE4002
+ *
+ */
+static u8 sfe4002_lm87_channel = 0x03; /* use AIN not FAN inputs */
+
+static const u8 sfe4002_lm87_regs[] = {
+	LM87_IN_LIMITS(0, 0x7c, 0x99),		/* 2.5V:  1.8V +/- 10% */
+	LM87_IN_LIMITS(1, 0x4c, 0x5e),		/* Vccp1: 1.2V +/- 10% */
+	LM87_IN_LIMITS(2, 0xac, 0xd4),		/* 3.3V:  3.3V +/- 10% */
+	LM87_IN_LIMITS(3, 0xac, 0xd4),		/* 5V:    5.0V +/- 10% */
+	LM87_IN_LIMITS(4, 0xac, 0xe0),		/* 12V:   10.8-14V */
+	LM87_IN_LIMITS(5, 0x3f, 0x4f),		/* Vccp2: 1.0V +/- 10% */
+	LM87_AIN_LIMITS(0, 0x98, 0xbb),		/* AIN1:  1.66V +/- 10% */
+	LM87_AIN_LIMITS(1, 0x8a, 0xa9),		/* AIN2:  1.5V +/- 10% */
+	LM87_TEMP_INT_LIMITS(0, 80 + FALCON_BOARD_TEMP_BIAS),
+	0
+};
+
+static struct i2c_board_info sfe4002_hwmon_info = {
+	I2C_BOARD_INFO("lm87", 0x2e),
+	.platform_data	= &sfe4002_lm87_channel,
+};
+
+/****************************************************************************/
+/* LED allocations. Note that on rev A0 boards the schematic and the reality
+ * differ: red and green are swapped. Below is the fixed (A1) layout (there
+ * are only 3 A0 boards in existence, so no real reason to make this
+ * conditional).
+ */
+#define SFE4002_FAULT_LED (2)	/* Red */
+#define SFE4002_RX_LED    (0)	/* Green */
+#define SFE4002_TX_LED    (1)	/* Amber */
+
+static void sfe4002_init_phy(struct efx_nic *efx)
+{
+	/* Set the TX and RX LEDs to reflect status and activity, and the
+	 * fault LED off */
+	falcon_qt202x_set_led(efx, SFE4002_TX_LED,
+			      QUAKE_LED_TXLINK | QUAKE_LED_LINK_ACTSTAT);
+	falcon_qt202x_set_led(efx, SFE4002_RX_LED,
+			      QUAKE_LED_RXLINK | QUAKE_LED_LINK_ACTSTAT);
+	falcon_qt202x_set_led(efx, SFE4002_FAULT_LED, QUAKE_LED_OFF);
+}
+
+static void sfe4002_set_id_led(struct efx_nic *efx, enum efx_led_mode mode)
+{
+	falcon_qt202x_set_led(
+		efx, SFE4002_FAULT_LED,
+		(mode == EFX_LED_ON) ? QUAKE_LED_ON : QUAKE_LED_OFF);
+}
+
+static int sfe4002_check_hw(struct efx_nic *efx)
+{
+	struct falcon_board *board = falcon_board(efx);
+
+	/* A0 board rev. 4002s report a temperature fault the whole time
+	 * (bad sensor) so we mask it out. */
+	unsigned alarm_mask =
+		(board->major == 0 && board->minor == 0) ?
+		~LM87_ALARM_TEMP_EXT1 : ~0;
+
+	return efx_check_lm87(efx, alarm_mask);
+}
+
+static int sfe4002_init(struct efx_nic *efx)
+{
+	return efx_init_lm87(efx, &sfe4002_hwmon_info, sfe4002_lm87_regs);
+}
+
+/*****************************************************************************
+ * Support for the SFN4112F
+ *
+ */
+static u8 sfn4112f_lm87_channel = 0x03; /* use AIN not FAN inputs */
+
+static const u8 sfn4112f_lm87_regs[] = {
+	LM87_IN_LIMITS(0, 0x7c, 0x99),		/* 2.5V:  1.8V +/- 10% */
+	LM87_IN_LIMITS(1, 0x4c, 0x5e),		/* Vccp1: 1.2V +/- 10% */
+	LM87_IN_LIMITS(2, 0xac, 0xd4),		/* 3.3V:  3.3V +/- 10% */
+	LM87_IN_LIMITS(4, 0xac, 0xe0),		/* 12V:   10.8-14V */
+	LM87_IN_LIMITS(5, 0x3f, 0x4f),		/* Vccp2: 1.0V +/- 10% */
+	LM87_AIN_LIMITS(1, 0x8a, 0xa9),		/* AIN2:  1.5V +/- 10% */
+	LM87_TEMP_INT_LIMITS(0, 60 + FALCON_BOARD_TEMP_BIAS),
+	0
+};
+
+static struct i2c_board_info sfn4112f_hwmon_info = {
+	I2C_BOARD_INFO("lm87", 0x2e),
+	.platform_data	= &sfn4112f_lm87_channel,
+};
+
+#define SFN4112F_ACT_LED	0
+#define SFN4112F_LINK_LED	1
+
+static void sfn4112f_init_phy(struct efx_nic *efx)
+{
+	falcon_qt202x_set_led(efx, SFN4112F_ACT_LED,
+			      QUAKE_LED_RXLINK | QUAKE_LED_LINK_ACT);
+	falcon_qt202x_set_led(efx, SFN4112F_LINK_LED,
+			      QUAKE_LED_RXLINK | QUAKE_LED_LINK_STAT);
+}
+
+static void sfn4112f_set_id_led(struct efx_nic *efx, enum efx_led_mode mode)
+{
+	int reg;
+
+	switch (mode) {
+	case EFX_LED_OFF:
+		reg = QUAKE_LED_OFF;
+		break;
+	case EFX_LED_ON:
+		reg = QUAKE_LED_ON;
+		break;
+	default:
+		reg = QUAKE_LED_RXLINK | QUAKE_LED_LINK_STAT;
+		break;
+	}
+
+	falcon_qt202x_set_led(efx, SFN4112F_LINK_LED, reg);
+}
+
+static int sfn4112f_check_hw(struct efx_nic *efx)
+{
+	/* Mask out unused sensors */
+	return efx_check_lm87(efx, ~0x48);
+}
+
+static int sfn4112f_init(struct efx_nic *efx)
+{
+	return efx_init_lm87(efx, &sfn4112f_hwmon_info, sfn4112f_lm87_regs);
+}
+
+/*****************************************************************************
+ * Support for the SFE4003
+ *
+ */
+static u8 sfe4003_lm87_channel = 0x03; /* use AIN not FAN inputs */
+
+static const u8 sfe4003_lm87_regs[] = {
+	LM87_IN_LIMITS(0, 0x67, 0x7f),		/* 2.5V:  1.5V +/- 10% */
+	LM87_IN_LIMITS(1, 0x4c, 0x5e),		/* Vccp1: 1.2V +/- 10% */
+	LM87_IN_LIMITS(2, 0xac, 0xd4),		/* 3.3V:  3.3V +/- 10% */
+	LM87_IN_LIMITS(4, 0xac, 0xe0),		/* 12V:   10.8-14V */
+	LM87_IN_LIMITS(5, 0x3f, 0x4f),		/* Vccp2: 1.0V +/- 10% */
+	LM87_TEMP_INT_LIMITS(0, 70 + FALCON_BOARD_TEMP_BIAS),
+	0
+};
+
+static struct i2c_board_info sfe4003_hwmon_info = {
+	I2C_BOARD_INFO("lm87", 0x2e),
+	.platform_data	= &sfe4003_lm87_channel,
+};
+
+/* Board-specific LED info. */
+#define SFE4003_RED_LED_GPIO	11
+#define SFE4003_LED_ON		1
+#define SFE4003_LED_OFF		0
+
+static void sfe4003_set_id_led(struct efx_nic *efx, enum efx_led_mode mode)
+{
+	struct falcon_board *board = falcon_board(efx);
+
+	/* The LEDs were not wired to GPIOs before A3 */
+	if (board->minor < 3 && board->major == 0)
+		return;
+
+	falcon_txc_set_gpio_val(
+		efx, SFE4003_RED_LED_GPIO,
+		(mode == EFX_LED_ON) ? SFE4003_LED_ON : SFE4003_LED_OFF);
+}
+
+static void sfe4003_init_phy(struct efx_nic *efx)
+{
+	struct falcon_board *board = falcon_board(efx);
+
+	/* The LEDs were not wired to GPIOs before A3 */
+	if (board->minor < 3 && board->major == 0)
+		return;
+
+	falcon_txc_set_gpio_dir(efx, SFE4003_RED_LED_GPIO, TXC_GPIO_DIR_OUTPUT);
+	falcon_txc_set_gpio_val(efx, SFE4003_RED_LED_GPIO, SFE4003_LED_OFF);
+}
+
+static int sfe4003_check_hw(struct efx_nic *efx)
+{
+	struct falcon_board *board = falcon_board(efx);
+
+	/* A0/A1/A2 board rev. 4003s  report a temperature fault the whole time
+	 * (bad sensor) so we mask it out. */
+	unsigned alarm_mask =
+		(board->major == 0 && board->minor <= 2) ?
+		~LM87_ALARM_TEMP_EXT1 : ~0;
+
+	return efx_check_lm87(efx, alarm_mask);
+}
+
+static int sfe4003_init(struct efx_nic *efx)
+{
+	return efx_init_lm87(efx, &sfe4003_hwmon_info, sfe4003_lm87_regs);
+}
+
+static const struct falcon_board_type board_types[] = {
+	{
+		.id		= FALCON_BOARD_SFE4001,
+		.init		= sfe4001_init,
+		.init_phy	= efx_port_dummy_op_void,
+		.fini		= sfe4001_fini,
+		.set_id_led	= tenxpress_set_id_led,
+		.monitor	= sfe4001_check_hw,
+	},
+	{
+		.id		= FALCON_BOARD_SFE4002,
+		.init		= sfe4002_init,
+		.init_phy	= sfe4002_init_phy,
+		.fini		= efx_fini_lm87,
+		.set_id_led	= sfe4002_set_id_led,
+		.monitor	= sfe4002_check_hw,
+	},
+	{
+		.id		= FALCON_BOARD_SFE4003,
+		.init		= sfe4003_init,
+		.init_phy	= sfe4003_init_phy,
+		.fini		= efx_fini_lm87,
+		.set_id_led	= sfe4003_set_id_led,
+		.monitor	= sfe4003_check_hw,
+	},
+	{
+		.id		= FALCON_BOARD_SFN4112F,
+		.init		= sfn4112f_init,
+		.init_phy	= sfn4112f_init_phy,
+		.fini		= efx_fini_lm87,
+		.set_id_led	= sfn4112f_set_id_led,
+		.monitor	= sfn4112f_check_hw,
+	},
+};
+
+int falcon_probe_board(struct efx_nic *efx, u16 revision_info)
+{
+	struct falcon_board *board = falcon_board(efx);
+	u8 type_id = FALCON_BOARD_TYPE(revision_info);
+	int i;
+
+	board->major = FALCON_BOARD_MAJOR(revision_info);
+	board->minor = FALCON_BOARD_MINOR(revision_info);
+
+	for (i = 0; i < ARRAY_SIZE(board_types); i++)
+		if (board_types[i].id == type_id)
+			board->type = &board_types[i];
+
+	if (board->type) {
+		return 0;
+	} else {
+		netif_err(efx, probe, efx->net_dev, "unknown board type %d\n",
+			  type_id);
+		return -ENODEV;
+	}
+	return 0;
+}
diff -r 9566a4a50a43 drivers/net/sfc/falcon_gmac.c
--- a/drivers/net/sfc/falcon_gmac.c
+++ /dev/null
@@ -1,229 +0,0 @@
-/****************************************************************************
- * Driver for Solarflare Solarstorm network controllers and boards
- * Copyright 2005-2006 Fen Systems Ltd.
- * Copyright 2006-2008 Solarflare Communications Inc.
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 as published
- * by the Free Software Foundation, incorporated herein by reference.
- */
-
-#include <linux/delay.h>
-#include "net_driver.h"
-#include "efx.h"
-#include "falcon.h"
-#include "mac.h"
-#include "falcon_hwdefs.h"
-#include "falcon_io.h"
-#include "gmii.h"
-
-/**************************************************************************
- *
- * MAC operations
- *
- *************************************************************************/
-
-static void falcon_reconfigure_gmac(struct efx_nic *efx)
-{
-	bool loopback, tx_fc, rx_fc, bytemode;
-	int if_mode;
-	unsigned int max_frame_len;
-	efx_oword_t reg;
-
-	/* Configuration register 1 */
-	tx_fc = (efx->link_fc & EFX_FC_TX) || !efx->link_fd;
-	rx_fc = !!(efx->link_fc & EFX_FC_RX);
-	loopback = (efx->loopback_mode == LOOPBACK_GMAC);
-	bytemode = (efx->link_speed == 1000);
-
-	EFX_POPULATE_OWORD_5(reg,
-			     GM_LOOP, loopback,
-			     GM_TX_EN, 1,
-			     GM_TX_FC_EN, tx_fc,
-			     GM_RX_EN, 1,
-			     GM_RX_FC_EN, rx_fc);
-	falcon_write(efx, &reg, GM_CFG1_REG);
-	udelay(10);
-
-	/* Configuration register 2 */
-	if_mode = (bytemode) ? 2 : 1;
-	EFX_POPULATE_OWORD_5(reg,
-			     GM_IF_MODE, if_mode,
-			     GM_PAD_CRC_EN, 1,
-			     GM_LEN_CHK, 1,
-			     GM_FD, efx->link_fd,
-			     GM_PAMBL_LEN, 0x7/*datasheet recommended */);
-
-	falcon_write(efx, &reg, GM_CFG2_REG);
-	udelay(10);
-
-	/* Max frame len register */
-	max_frame_len = EFX_MAX_FRAME_LEN(efx->net_dev->mtu);
-	EFX_POPULATE_OWORD_1(reg, GM_MAX_FLEN, max_frame_len);
-	falcon_write(efx, &reg, GM_MAX_FLEN_REG);
-	udelay(10);
-
-	/* FIFO configuration register 0 */
-	EFX_POPULATE_OWORD_5(reg,
-			     GMF_FTFENREQ, 1,
-			     GMF_STFENREQ, 1,
-			     GMF_FRFENREQ, 1,
-			     GMF_SRFENREQ, 1,
-			     GMF_WTMENREQ, 1);
-	falcon_write(efx, &reg, GMF_CFG0_REG);
-	udelay(10);
-
-	/* FIFO configuration register 1 */
-	EFX_POPULATE_OWORD_2(reg,
-			     GMF_CFGFRTH, 0x12,
-			     GMF_CFGXOFFRTX, 0xffff);
-	falcon_write(efx, &reg, GMF_CFG1_REG);
-	udelay(10);
-
-	/* FIFO configuration register 2 */
-	EFX_POPULATE_OWORD_2(reg,
-			     GMF_CFGHWM, 0x3f,
-			     GMF_CFGLWM, 0xa);
-	falcon_write(efx, &reg, GMF_CFG2_REG);
-	udelay(10);
-
-	/* FIFO configuration register 3 */
-	EFX_POPULATE_OWORD_2(reg,
-			     GMF_CFGHWMFT, 0x1c,
-			     GMF_CFGFTTH, 0x08);
-	falcon_write(efx, &reg, GMF_CFG3_REG);
-	udelay(10);
-
-	/* FIFO configuration register 4 */
-	EFX_POPULATE_OWORD_1(reg, GMF_HSTFLTRFRM_PAUSE, 1);
-	falcon_write(efx, &reg, GMF_CFG4_REG);
-	udelay(10);
-
-	/* FIFO configuration register 5 */
-	falcon_read(efx, &reg, GMF_CFG5_REG);
-	EFX_SET_OWORD_FIELD(reg, GMF_CFGBYTMODE, bytemode);
-	EFX_SET_OWORD_FIELD(reg, GMF_CFGHDPLX, !efx->link_fd);
-	EFX_SET_OWORD_FIELD(reg, GMF_HSTDRPLT64, !efx->link_fd);
-	EFX_SET_OWORD_FIELD(reg, GMF_HSTFLTRFRMDC_PAUSE, 0);
-	falcon_write(efx, &reg, GMF_CFG5_REG);
-	udelay(10);
-
-	/* MAC address */
-	EFX_POPULATE_OWORD_4(reg,
-			     GM_HWADDR_5, efx->net_dev->dev_addr[5],
-			     GM_HWADDR_4, efx->net_dev->dev_addr[4],
-			     GM_HWADDR_3, efx->net_dev->dev_addr[3],
-			     GM_HWADDR_2, efx->net_dev->dev_addr[2]);
-	falcon_write(efx, &reg, GM_ADR1_REG);
-	udelay(10);
-	EFX_POPULATE_OWORD_2(reg,
-			     GM_HWADDR_1, efx->net_dev->dev_addr[1],
-			     GM_HWADDR_0, efx->net_dev->dev_addr[0]);
-	falcon_write(efx, &reg, GM_ADR2_REG);
-	udelay(10);
-
-	falcon_reconfigure_mac_wrapper(efx);
-}
-
-static void falcon_update_stats_gmac(struct efx_nic *efx)
-{
-	struct efx_mac_stats *mac_stats = &efx->mac_stats;
-	unsigned long old_rx_pause, old_tx_pause;
-	unsigned long new_rx_pause, new_tx_pause;
-	int rc;
-
-	rc = falcon_dma_stats(efx, GDmaDone_offset);
-	if (rc)
-		return;
-
-	/* Pause frames are erroneously counted as errors (SFC bug 3269) */
-	old_rx_pause = mac_stats->rx_pause;
-	old_tx_pause = mac_stats->tx_pause;
-
-	/* Update MAC stats from DMAed values */
-	FALCON_STAT(efx, GRxGoodOct, rx_good_bytes);
-	FALCON_STAT(efx, GRxBadOct, rx_bad_bytes);
-	FALCON_STAT(efx, GRxMissPkt, rx_missed);
-	FALCON_STAT(efx, GRxFalseCRS, rx_false_carrier);
-	FALCON_STAT(efx, GRxPausePkt, rx_pause);
-	FALCON_STAT(efx, GRxBadPkt, rx_bad);
-	FALCON_STAT(efx, GRxUcastPkt, rx_unicast);
-	FALCON_STAT(efx, GRxMcastPkt, rx_multicast);
-	FALCON_STAT(efx, GRxBcastPkt, rx_broadcast);
-	FALCON_STAT(efx, GRxGoodLt64Pkt, rx_good_lt64);
-	FALCON_STAT(efx, GRxBadLt64Pkt, rx_bad_lt64);
-	FALCON_STAT(efx, GRx64Pkt, rx_64);
-	FALCON_STAT(efx, GRx65to127Pkt, rx_65_to_127);
-	FALCON_STAT(efx, GRx128to255Pkt, rx_128_to_255);
-	FALCON_STAT(efx, GRx256to511Pkt, rx_256_to_511);
-	FALCON_STAT(efx, GRx512to1023Pkt, rx_512_to_1023);
-	FALCON_STAT(efx, GRx1024to15xxPkt, rx_1024_to_15xx);
-	FALCON_STAT(efx, GRx15xxtoJumboPkt, rx_15xx_to_jumbo);
-	FALCON_STAT(efx, GRxGtJumboPkt, rx_gtjumbo);
-	FALCON_STAT(efx, GRxFcsErr64to15xxPkt, rx_bad_64_to_15xx);
-	FALCON_STAT(efx, GRxFcsErr15xxtoJumboPkt, rx_bad_15xx_to_jumbo);
-	FALCON_STAT(efx, GRxFcsErrGtJumboPkt, rx_bad_gtjumbo);
-	FALCON_STAT(efx, GTxGoodBadOct, tx_bytes);
-	FALCON_STAT(efx, GTxGoodOct, tx_good_bytes);
-	FALCON_STAT(efx, GTxSglColPkt, tx_single_collision);
-	FALCON_STAT(efx, GTxMultColPkt, tx_multiple_collision);
-	FALCON_STAT(efx, GTxExColPkt, tx_excessive_collision);
-	FALCON_STAT(efx, GTxDefPkt, tx_deferred);
-	FALCON_STAT(efx, GTxLateCol, tx_late_collision);
-	FALCON_STAT(efx, GTxExDefPkt, tx_excessive_deferred);
-	FALCON_STAT(efx, GTxPausePkt, tx_pause);
-	FALCON_STAT(efx, GTxBadPkt, tx_bad);
-	FALCON_STAT(efx, GTxUcastPkt, tx_unicast);
-	FALCON_STAT(efx, GTxMcastPkt, tx_multicast);
-	FALCON_STAT(efx, GTxBcastPkt, tx_broadcast);
-	FALCON_STAT(efx, GTxLt64Pkt, tx_lt64);
-	FALCON_STAT(efx, GTx64Pkt, tx_64);
-	FALCON_STAT(efx, GTx65to127Pkt, tx_65_to_127);
-	FALCON_STAT(efx, GTx128to255Pkt, tx_128_to_255);
-	FALCON_STAT(efx, GTx256to511Pkt, tx_256_to_511);
-	FALCON_STAT(efx, GTx512to1023Pkt, tx_512_to_1023);
-	FALCON_STAT(efx, GTx1024to15xxPkt, tx_1024_to_15xx);
-	FALCON_STAT(efx, GTx15xxtoJumboPkt, tx_15xx_to_jumbo);
-	FALCON_STAT(efx, GTxGtJumboPkt, tx_gtjumbo);
-	FALCON_STAT(efx, GTxNonTcpUdpPkt, tx_non_tcpudp);
-	FALCON_STAT(efx, GTxMacSrcErrPkt, tx_mac_src_error);
-	FALCON_STAT(efx, GTxIpSrcErrPkt, tx_ip_src_error);
-
-	/* Pause frames are erroneously counted as errors (SFC bug 3269) */
-	new_rx_pause = mac_stats->rx_pause;
-	new_tx_pause = mac_stats->tx_pause;
-	mac_stats->rx_bad -= (new_rx_pause - old_rx_pause);
-	mac_stats->tx_bad -= (new_tx_pause - old_tx_pause);
-
-	/* Derive stats that the MAC doesn't provide directly */
-	mac_stats->tx_bad_bytes =
-		mac_stats->tx_bytes - mac_stats->tx_good_bytes;
-	mac_stats->tx_packets =
-		mac_stats->tx_lt64 + mac_stats->tx_64 +
-		mac_stats->tx_65_to_127 + mac_stats->tx_128_to_255 +
-		mac_stats->tx_256_to_511 + mac_stats->tx_512_to_1023 +
-		mac_stats->tx_1024_to_15xx + mac_stats->tx_15xx_to_jumbo +
-		mac_stats->tx_gtjumbo;
-	mac_stats->tx_collision =
-		mac_stats->tx_single_collision +
-		mac_stats->tx_multiple_collision +
-		mac_stats->tx_excessive_collision +
-		mac_stats->tx_late_collision;
-	mac_stats->rx_bytes =
-		mac_stats->rx_good_bytes + mac_stats->rx_bad_bytes;
-	mac_stats->rx_packets =
-		mac_stats->rx_good_lt64 + mac_stats->rx_bad_lt64 +
-		mac_stats->rx_64 + mac_stats->rx_65_to_127 +
-		mac_stats->rx_128_to_255 + mac_stats->rx_256_to_511 +
-		mac_stats->rx_512_to_1023 + mac_stats->rx_1024_to_15xx +
-		mac_stats->rx_15xx_to_jumbo + mac_stats->rx_gtjumbo;
-	mac_stats->rx_good = mac_stats->rx_packets - mac_stats->rx_bad;
-	mac_stats->rx_lt64 = mac_stats->rx_good_lt64 + mac_stats->rx_bad_lt64;
-}
-
-struct efx_mac_operations falcon_gmac_operations = {
-	.reconfigure	= falcon_reconfigure_gmac,
-	.update_stats	= falcon_update_stats_gmac,
-	.irq		= efx_port_dummy_op_void,
-	.poll		= efx_port_dummy_op_void,
-};
diff -r 9566a4a50a43 drivers/net/sfc/falcon_hwdefs.h
--- a/drivers/net/sfc/falcon_hwdefs.h
+++ /dev/null
@@ -1,1333 +0,0 @@
-/****************************************************************************
- * Driver for Solarflare Solarstorm network controllers and boards
- * Copyright 2005-2006 Fen Systems Ltd.
- * Copyright 2006-2008 Solarflare Communications Inc.
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 as published
- * by the Free Software Foundation, incorporated herein by reference.
- */
-
-#ifndef EFX_FALCON_HWDEFS_H
-#define EFX_FALCON_HWDEFS_H
-
-/*
- * Falcon hardware value definitions.
- * Falcon is the internal codename for the SFC4000 controller that is
- * present in SFE400X evaluation boards
- */
-
-/**************************************************************************
- *
- * Falcon registers
- *
- **************************************************************************
- */
-
-/* Address region register */
-#define ADR_REGION_REG_KER	0x00
-#define ADR_REGION0_LBN	0
-#define ADR_REGION0_WIDTH	18
-#define ADR_REGION1_LBN	32
-#define ADR_REGION1_WIDTH	18
-#define ADR_REGION2_LBN	64
-#define ADR_REGION2_WIDTH	18
-#define ADR_REGION3_LBN	96
-#define ADR_REGION3_WIDTH	18
-
-/* Interrupt enable register */
-#define INT_EN_REG_KER 0x0010
-#define KER_INT_KER_LBN 3
-#define KER_INT_KER_WIDTH 1
-#define DRV_INT_EN_KER_LBN 0
-#define DRV_INT_EN_KER_WIDTH 1
-
-/* Interrupt status address register */
-#define INT_ADR_REG_KER	0x0030
-#define NORM_INT_VEC_DIS_KER_LBN 64
-#define NORM_INT_VEC_DIS_KER_WIDTH 1
-#define INT_ADR_KER_LBN 0
-#define INT_ADR_KER_WIDTH EFX_DMA_TYPE_WIDTH(64) /* not 46 for this one */
-
-/* Interrupt status register (B0 only) */
-#define INT_ISR0_B0 0x90
-#define INT_ISR1_B0 0xA0
-
-/* Interrupt acknowledge register (A0/A1 only) */
-#define INT_ACK_REG_KER_A1 0x0050
-#define INT_ACK_DUMMY_DATA_LBN 0
-#define INT_ACK_DUMMY_DATA_WIDTH 32
-
-/* Interrupt acknowledge work-around register (A0/A1 only )*/
-#define WORK_AROUND_BROKEN_PCI_READS_REG_KER_A1 0x0070
-
-/* SPI host command register */
-#define EE_SPI_HCMD_REG_KER 0x0100
-#define EE_SPI_HCMD_CMD_EN_LBN 31
-#define EE_SPI_HCMD_CMD_EN_WIDTH 1
-#define EE_WR_TIMER_ACTIVE_LBN 28
-#define EE_WR_TIMER_ACTIVE_WIDTH 1
-#define EE_SPI_HCMD_SF_SEL_LBN 24
-#define EE_SPI_HCMD_SF_SEL_WIDTH 1
-#define EE_SPI_EEPROM 0
-#define EE_SPI_FLASH 1
-#define EE_SPI_HCMD_DABCNT_LBN 16
-#define EE_SPI_HCMD_DABCNT_WIDTH 5
-#define EE_SPI_HCMD_READ_LBN 15
-#define EE_SPI_HCMD_READ_WIDTH 1
-#define EE_SPI_READ 1
-#define EE_SPI_WRITE 0
-#define EE_SPI_HCMD_DUBCNT_LBN 12
-#define EE_SPI_HCMD_DUBCNT_WIDTH 2
-#define EE_SPI_HCMD_ADBCNT_LBN 8
-#define EE_SPI_HCMD_ADBCNT_WIDTH 2
-#define EE_SPI_HCMD_ENC_LBN 0
-#define EE_SPI_HCMD_ENC_WIDTH 8
-
-/* SPI host address register */
-#define EE_SPI_HADR_REG_KER 0x0110
-#define EE_SPI_HADR_ADR_LBN 0
-#define EE_SPI_HADR_ADR_WIDTH 24
-
-/* SPI host data register */
-#define EE_SPI_HDATA_REG_KER 0x0120
-
-/* SPI/VPD config register */
-#define EE_VPD_CFG_REG_KER 0x0140
-#define EE_VPD_EN_LBN 0
-#define EE_VPD_EN_WIDTH 1
-#define EE_VPD_EN_AD9_MODE_LBN 1
-#define EE_VPD_EN_AD9_MODE_WIDTH 1
-#define EE_EE_CLOCK_DIV_LBN 112
-#define EE_EE_CLOCK_DIV_WIDTH 7
-#define EE_SF_CLOCK_DIV_LBN 120
-#define EE_SF_CLOCK_DIV_WIDTH 7
-
-/* PCIE CORE ACCESS REG */
-#define PCIE_CORE_ADDR_PCIE_DEVICE_CTRL_STAT 0x68
-#define PCIE_CORE_ADDR_PCIE_LINK_CTRL_STAT 0x70
-#define PCIE_CORE_ADDR_ACK_RPL_TIMER 0x700
-#define PCIE_CORE_ADDR_ACK_FREQ 0x70C
-
-/* NIC status register */
-#define NIC_STAT_REG 0x0200
-#define EE_STRAP_EN_LBN 31
-#define EE_STRAP_EN_WIDTH 1
-#define EE_STRAP_OVR_LBN 24
-#define EE_STRAP_OVR_WIDTH 4
-#define ONCHIP_SRAM_LBN 16
-#define ONCHIP_SRAM_WIDTH 1
-#define SF_PRST_LBN 9
-#define SF_PRST_WIDTH 1
-#define EE_PRST_LBN 8
-#define EE_PRST_WIDTH 1
-#define STRAP_PINS_LBN 0
-#define STRAP_PINS_WIDTH 3
-/* These bit definitions are extrapolated from the list of numerical
- * values for STRAP_PINS.
- */
-#define STRAP_10G_LBN 2
-#define STRAP_10G_WIDTH 1
-#define STRAP_PCIE_LBN 0
-#define STRAP_PCIE_WIDTH 1
-
-#define BOOTED_USING_NVDEVICE_LBN 3
-#define BOOTED_USING_NVDEVICE_WIDTH 1
-
-/* GPIO control register */
-#define GPIO_CTL_REG_KER 0x0210
-#define GPIO_USE_NIC_CLK_LBN (30)
-#define GPIO_USE_NIC_CLK_WIDTH (1)
-#define GPIO_OUTPUTS_LBN   (16)
-#define GPIO_OUTPUTS_WIDTH (4)
-#define GPIO_INPUTS_LBN (8)
-#define GPIO_DIRECTION_LBN (24)
-#define GPIO_DIRECTION_WIDTH (4)
-#define GPIO_DIRECTION_OUT (1)
-#define GPIO_SRAM_SLEEP (1 << 1)
-
-#define GPIO3_OEN_LBN (GPIO_DIRECTION_LBN + 3)
-#define	GPIO3_OEN_WIDTH 1
-#define	GPIO2_OEN_LBN (GPIO_DIRECTION_LBN + 2)
-#define	GPIO2_OEN_WIDTH 1
-#define	GPIO1_OEN_LBN (GPIO_DIRECTION_LBN + 1)
-#define	GPIO1_OEN_WIDTH 1
-#define GPIO0_OEN_LBN (GPIO_DIRECTION_LBN + 0)
-#define	GPIO0_OEN_WIDTH 1
-
-#define	GPIO3_OUT_LBN (GPIO_OUTPUTS_LBN + 3)
-#define	GPIO3_OUT_WIDTH 1
-#define	GPIO2_OUT_LBN (GPIO_OUTPUTS_LBN + 2)
-#define	GPIO2_OUT_WIDTH 1
-#define	GPIO1_OUT_LBN (GPIO_OUTPUTS_LBN + 1)
-#define	GPIO1_OUT_WIDTH 1
-#define	GPIO0_OUT_LBN (GPIO_OUTPUTS_LBN + 0)
-#define	GPIO0_OUT_WIDTH 1
-
-#define GPIO3_IN_LBN (GPIO_INPUTS_LBN + 3)
-#define	GPIO3_IN_WIDTH 1
-#define	GPIO2_IN_WIDTH 1
-#define	GPIO1_IN_WIDTH 1
-#define GPIO0_IN_LBN (GPIO_INPUTS_LBN + 0)
-#define	GPIO0_IN_WIDTH 1
-
-/* Global control register */
-#define GLB_CTL_REG_KER	0x0220
-#define EXT_PHY_RST_CTL_LBN 63
-#define EXT_PHY_RST_CTL_WIDTH 1
-#define PCIE_SD_RST_CTL_LBN 61
-#define PCIE_SD_RST_CTL_WIDTH 1
-
-#define PCIE_NSTCK_RST_CTL_LBN 58
-#define PCIE_NSTCK_RST_CTL_WIDTH 1
-#define PCIE_CORE_RST_CTL_LBN 57
-#define PCIE_CORE_RST_CTL_WIDTH 1
-#define EE_RST_CTL_LBN 49
-#define EE_RST_CTL_WIDTH 1
-#define RST_XGRX_LBN 24
-#define RST_XGRX_WIDTH 1
-#define RST_XGTX_LBN 23
-#define RST_XGTX_WIDTH 1
-#define RST_EM_LBN 22
-#define RST_EM_WIDTH 1
-#define EXT_PHY_RST_DUR_LBN 1
-#define EXT_PHY_RST_DUR_WIDTH 3
-#define SWRST_LBN 0
-#define SWRST_WIDTH 1
-#define INCLUDE_IN_RESET 0
-#define EXCLUDE_FROM_RESET 1
-
-/* Fatal interrupt register */
-#define FATAL_INTR_REG_KER 0x0230
-#define RBUF_OWN_INT_KER_EN_LBN 39
-#define RBUF_OWN_INT_KER_EN_WIDTH 1
-#define TBUF_OWN_INT_KER_EN_LBN 38
-#define TBUF_OWN_INT_KER_EN_WIDTH 1
-#define ILL_ADR_INT_KER_EN_LBN 33
-#define ILL_ADR_INT_KER_EN_WIDTH 1
-#define MEM_PERR_INT_KER_LBN 8
-#define MEM_PERR_INT_KER_WIDTH 1
-#define INT_KER_ERROR_LBN 0
-#define INT_KER_ERROR_WIDTH 12
-
-#define DP_CTRL_REG 0x250
-#define FLS_EVQ_ID_LBN 0
-#define FLS_EVQ_ID_WIDTH 11
-
-#define MEM_STAT_REG_KER 0x260
-
-/* Debug probe register */
-#define DEBUG_BLK_SEL_MISC 7
-#define DEBUG_BLK_SEL_SERDES 6
-#define DEBUG_BLK_SEL_EM 5
-#define DEBUG_BLK_SEL_SR 4
-#define DEBUG_BLK_SEL_EV 3
-#define DEBUG_BLK_SEL_RX 2
-#define DEBUG_BLK_SEL_TX 1
-#define DEBUG_BLK_SEL_BIU 0
-
-/* FPGA build version */
-#define ALTERA_BUILD_REG_KER 0x0300
-#define VER_ALL_LBN 0
-#define VER_ALL_WIDTH 32
-
-/* Spare EEPROM bits register (flash 0x390) */
-#define SPARE_REG_KER 0x310
-#define MEM_PERR_EN_TX_DATA_LBN 72
-#define MEM_PERR_EN_TX_DATA_WIDTH 2
-
-/* Timer table for kernel access */
-#define TIMER_CMD_REG_KER 0x420
-#define TIMER_MODE_LBN 12
-#define TIMER_MODE_WIDTH 2
-#define TIMER_MODE_DIS 0
-#define TIMER_MODE_INT_HLDOFF 2
-#define TIMER_VAL_LBN 0
-#define TIMER_VAL_WIDTH 12
-
-/* Driver generated event register */
-#define DRV_EV_REG_KER 0x440
-#define DRV_EV_QID_LBN 64
-#define DRV_EV_QID_WIDTH 12
-#define DRV_EV_DATA_LBN 0
-#define DRV_EV_DATA_WIDTH 64
-
-/* Buffer table configuration register */
-#define BUF_TBL_CFG_REG_KER 0x600
-#define BUF_TBL_MODE_LBN 3
-#define BUF_TBL_MODE_WIDTH 1
-#define BUF_TBL_MODE_HALF 0
-#define BUF_TBL_MODE_FULL 1
-
-/* SRAM receive descriptor cache configuration register */
-#define SRM_RX_DC_CFG_REG_KER 0x610
-#define SRM_RX_DC_BASE_ADR_LBN 0
-#define SRM_RX_DC_BASE_ADR_WIDTH 21
-
-/* SRAM transmit descriptor cache configuration register */
-#define SRM_TX_DC_CFG_REG_KER 0x620
-#define SRM_TX_DC_BASE_ADR_LBN 0
-#define SRM_TX_DC_BASE_ADR_WIDTH 21
-
-/* SRAM configuration register */
-#define SRM_CFG_REG_KER 0x630
-#define SRAM_OOB_BT_INIT_EN_LBN 3
-#define SRAM_OOB_BT_INIT_EN_WIDTH 1
-#define SRM_NUM_BANKS_AND_BANK_SIZE_LBN 0
-#define SRM_NUM_BANKS_AND_BANK_SIZE_WIDTH 3
-#define SRM_NB_BSZ_1BANKS_2M 0
-#define SRM_NB_BSZ_1BANKS_4M 1
-#define SRM_NB_BSZ_1BANKS_8M 2
-#define SRM_NB_BSZ_DEFAULT 3 /* char driver will set the default */
-#define SRM_NB_BSZ_2BANKS_4M 4
-#define SRM_NB_BSZ_2BANKS_8M 5
-#define SRM_NB_BSZ_2BANKS_16M 6
-#define SRM_NB_BSZ_RESERVED 7
-
-/* Special buffer table update register */
-#define BUF_TBL_UPD_REG_KER 0x0650
-#define BUF_UPD_CMD_LBN 63
-#define BUF_UPD_CMD_WIDTH 1
-#define BUF_CLR_CMD_LBN 62
-#define BUF_CLR_CMD_WIDTH 1
-#define BUF_CLR_END_ID_LBN 32
-#define BUF_CLR_END_ID_WIDTH 20
-#define BUF_CLR_START_ID_LBN 0
-#define BUF_CLR_START_ID_WIDTH 20
-
-/* Receive configuration register */
-#define RX_CFG_REG_KER 0x800
-
-/* B0 */
-#define RX_INGR_EN_B0_LBN 47
-#define RX_INGR_EN_B0_WIDTH 1
-#define RX_DESC_PUSH_EN_B0_LBN 43
-#define RX_DESC_PUSH_EN_B0_WIDTH 1
-#define RX_XON_TX_TH_B0_LBN 33
-#define RX_XON_TX_TH_B0_WIDTH 5
-#define RX_XOFF_TX_TH_B0_LBN 28
-#define RX_XOFF_TX_TH_B0_WIDTH 5
-#define RX_USR_BUF_SIZE_B0_LBN 19
-#define RX_USR_BUF_SIZE_B0_WIDTH 9
-#define RX_XON_MAC_TH_B0_LBN 10
-#define RX_XON_MAC_TH_B0_WIDTH 9
-#define RX_XOFF_MAC_TH_B0_LBN 1
-#define RX_XOFF_MAC_TH_B0_WIDTH 9
-#define RX_XOFF_MAC_EN_B0_LBN 0
-#define RX_XOFF_MAC_EN_B0_WIDTH 1
-
-/* A1 */
-#define RX_DESC_PUSH_EN_A1_LBN 35
-#define RX_DESC_PUSH_EN_A1_WIDTH 1
-#define RX_XON_TX_TH_A1_LBN 25
-#define RX_XON_TX_TH_A1_WIDTH 5
-#define RX_XOFF_TX_TH_A1_LBN 20
-#define RX_XOFF_TX_TH_A1_WIDTH 5
-#define RX_USR_BUF_SIZE_A1_LBN 11
-#define RX_USR_BUF_SIZE_A1_WIDTH 9
-#define RX_XON_MAC_TH_A1_LBN 6
-#define RX_XON_MAC_TH_A1_WIDTH 5
-#define RX_XOFF_MAC_TH_A1_LBN 1
-#define RX_XOFF_MAC_TH_A1_WIDTH 5
-#define RX_XOFF_MAC_EN_A1_LBN 0
-#define RX_XOFF_MAC_EN_A1_WIDTH 1
-
-/* Receive filter control register */
-#define RX_FILTER_CTL_REG 0x810
-#define UDP_FULL_SRCH_LIMIT_LBN 32
-#define UDP_FULL_SRCH_LIMIT_WIDTH 8
-#define NUM_KER_LBN 24
-#define NUM_KER_WIDTH 2
-#define UDP_WILD_SRCH_LIMIT_LBN 16
-#define UDP_WILD_SRCH_LIMIT_WIDTH 8
-#define TCP_WILD_SRCH_LIMIT_LBN 8
-#define TCP_WILD_SRCH_LIMIT_WIDTH 8
-#define TCP_FULL_SRCH_LIMIT_LBN 0
-#define TCP_FULL_SRCH_LIMIT_WIDTH 8
-
-/* RX queue flush register */
-#define RX_FLUSH_DESCQ_REG_KER 0x0820
-#define RX_FLUSH_DESCQ_CMD_LBN 24
-#define RX_FLUSH_DESCQ_CMD_WIDTH 1
-#define RX_FLUSH_DESCQ_LBN 0
-#define RX_FLUSH_DESCQ_WIDTH 12
-
-/* Receive descriptor update register */
-#define RX_DESC_UPD_REG_KER_DWORD (0x830 + 12)
-#define RX_DESC_WPTR_DWORD_LBN 0
-#define RX_DESC_WPTR_DWORD_WIDTH 12
-
-/* Receive descriptor cache configuration register */
-#define RX_DC_CFG_REG_KER 0x840
-#define RX_DC_SIZE_LBN 0
-#define RX_DC_SIZE_WIDTH 2
-
-#define RX_DC_PF_WM_REG_KER 0x850
-#define RX_DC_PF_LWM_LBN 0
-#define RX_DC_PF_LWM_WIDTH 6
-
-/* RX no descriptor drop counter */
-#define RX_NODESC_DROP_REG_KER 0x880
-#define RX_NODESC_DROP_CNT_LBN 0
-#define RX_NODESC_DROP_CNT_WIDTH 16
-
-/* RX black magic register */
-#define RX_SELF_RST_REG_KER 0x890
-#define RX_ISCSI_DIS_LBN 17
-#define RX_ISCSI_DIS_WIDTH 1
-#define RX_NODESC_WAIT_DIS_LBN 9
-#define RX_NODESC_WAIT_DIS_WIDTH 1
-#define RX_RECOVERY_EN_LBN 8
-#define RX_RECOVERY_EN_WIDTH 1
-
-/* TX queue flush register */
-#define TX_FLUSH_DESCQ_REG_KER 0x0a00
-#define TX_FLUSH_DESCQ_CMD_LBN 12
-#define TX_FLUSH_DESCQ_CMD_WIDTH 1
-#define TX_FLUSH_DESCQ_LBN 0
-#define TX_FLUSH_DESCQ_WIDTH 12
-
-/* Transmit descriptor update register */
-#define TX_DESC_UPD_REG_KER_DWORD (0xa10 + 12)
-#define TX_DESC_WPTR_DWORD_LBN 0
-#define TX_DESC_WPTR_DWORD_WIDTH 12
-
-/* Transmit descriptor cache configuration register */
-#define TX_DC_CFG_REG_KER 0xa20
-#define TX_DC_SIZE_LBN 0
-#define TX_DC_SIZE_WIDTH 2
-
-/* Transmit checksum configuration register (A0/A1 only) */
-#define TX_CHKSM_CFG_REG_KER_A1 0xa30
-
-/* Transmit configuration register */
-#define TX_CFG_REG_KER 0xa50
-#define TX_NO_EOP_DISC_EN_LBN 5
-#define TX_NO_EOP_DISC_EN_WIDTH 1
-
-/* Transmit configuration register 2 */
-#define TX_CFG2_REG_KER 0xa80
-#define TX_CSR_PUSH_EN_LBN 89
-#define TX_CSR_PUSH_EN_WIDTH 1
-#define TX_RX_SPACER_LBN 64
-#define TX_RX_SPACER_WIDTH 8
-#define TX_SW_EV_EN_LBN 59
-#define TX_SW_EV_EN_WIDTH 1
-#define TX_RX_SPACER_EN_LBN 57
-#define TX_RX_SPACER_EN_WIDTH 1
-#define TX_PREF_THRESHOLD_LBN 19
-#define TX_PREF_THRESHOLD_WIDTH 2
-#define TX_ONE_PKT_PER_Q_LBN 18
-#define TX_ONE_PKT_PER_Q_WIDTH 1
-#define TX_DIS_NON_IP_EV_LBN 17
-#define TX_DIS_NON_IP_EV_WIDTH 1
-#define TX_FLUSH_MIN_LEN_EN_B0_LBN 7
-#define TX_FLUSH_MIN_LEN_EN_B0_WIDTH 1
-
-/* PHY management transmit data register */
-#define MD_TXD_REG_KER 0xc00
-#define MD_TXD_LBN 0
-#define MD_TXD_WIDTH 16
-
-/* PHY management receive data register */
-#define MD_RXD_REG_KER 0xc10
-#define MD_RXD_LBN 0
-#define MD_RXD_WIDTH 16
-
-/* PHY management configuration & status register */
-#define MD_CS_REG_KER 0xc20
-#define MD_GC_LBN 4
-#define MD_GC_WIDTH 1
-#define MD_RIC_LBN 2
-#define MD_RIC_WIDTH 1
-#define MD_RDC_LBN 1
-#define MD_RDC_WIDTH 1
-#define MD_WRC_LBN 0
-#define MD_WRC_WIDTH 1
-
-/* PHY management PHY address register */
-#define MD_PHY_ADR_REG_KER 0xc30
-#define MD_PHY_ADR_LBN 0
-#define MD_PHY_ADR_WIDTH 16
-
-/* PHY management ID register */
-#define MD_ID_REG_KER 0xc40
-#define MD_PRT_ADR_LBN 11
-#define MD_PRT_ADR_WIDTH 5
-#define MD_DEV_ADR_LBN 6
-#define MD_DEV_ADR_WIDTH 5
-
-/* PHY management status & mask register (DWORD read only) */
-#define MD_STAT_REG_KER 0xc50
-#define MD_BSERR_LBN 2
-#define MD_BSERR_WIDTH 1
-#define MD_LNFL_LBN 1
-#define MD_LNFL_WIDTH 1
-#define MD_BSY_LBN 0
-#define MD_BSY_WIDTH 1
-
-/* Port 0 and 1 MAC stats registers */
-#define MAC0_STAT_DMA_REG_KER 0xc60
-#define MAC_STAT_DMA_CMD_LBN 48
-#define MAC_STAT_DMA_CMD_WIDTH 1
-#define MAC_STAT_DMA_ADR_LBN 0
-#define MAC_STAT_DMA_ADR_WIDTH EFX_DMA_TYPE_WIDTH(46)
-
-/* Port 0 and 1 MAC control registers */
-#define MAC0_CTRL_REG_KER 0xc80
-#define MAC_XOFF_VAL_LBN 16
-#define MAC_XOFF_VAL_WIDTH 16
-#define TXFIFO_DRAIN_EN_B0_LBN 7
-#define TXFIFO_DRAIN_EN_B0_WIDTH 1
-#define MAC_BCAD_ACPT_LBN 4
-#define MAC_BCAD_ACPT_WIDTH 1
-#define MAC_UC_PROM_LBN 3
-#define MAC_UC_PROM_WIDTH 1
-#define MAC_LINK_STATUS_LBN 2
-#define MAC_LINK_STATUS_WIDTH 1
-#define MAC_SPEED_LBN 0
-#define MAC_SPEED_WIDTH 2
-
-/* 10G XAUI XGXS default values */
-#define XX_TXDRV_DEQ_DEFAULT 0xe /* deq=.6 */
-#define XX_TXDRV_DTX_DEFAULT 0x5 /* 1.25 */
-#define XX_SD_CTL_DRV_DEFAULT 0  /* 20mA */
-
-/* Multicast address hash table */
-#define MAC_MCAST_HASH_REG0_KER 0xca0
-#define MAC_MCAST_HASH_REG1_KER 0xcb0
-
-/* GMAC configuration register 1 */
-#define GM_CFG1_REG 0xe00
-#define GM_SW_RST_LBN 31
-#define GM_SW_RST_WIDTH 1
-#define GM_LOOP_LBN 8
-#define GM_LOOP_WIDTH 1
-#define GM_RX_FC_EN_LBN 5
-#define GM_RX_FC_EN_WIDTH 1
-#define GM_TX_FC_EN_LBN 4
-#define GM_TX_FC_EN_WIDTH 1
-#define GM_RX_EN_LBN 2
-#define GM_RX_EN_WIDTH 1
-#define GM_TX_EN_LBN 0
-#define GM_TX_EN_WIDTH 1
-
-/* GMAC configuration register 2 */
-#define GM_CFG2_REG 0xe10
-#define GM_PAMBL_LEN_LBN 12
-#define GM_PAMBL_LEN_WIDTH 4
-#define GM_IF_MODE_LBN 8
-#define GM_IF_MODE_WIDTH 2
-#define GM_LEN_CHK_LBN 4
-#define GM_LEN_CHK_WIDTH 1
-#define GM_PAD_CRC_EN_LBN 2
-#define GM_PAD_CRC_EN_WIDTH 1
-#define GM_FD_LBN 0
-#define GM_FD_WIDTH 1
-
-/* GMAC maximum frame length register */
-#define GM_MAX_FLEN_REG 0xe40
-#define GM_MAX_FLEN_LBN 0
-#define GM_MAX_FLEN_WIDTH 16
-
-/* GMAC station address register 1 */
-#define GM_ADR1_REG 0xf00
-#define GM_HWADDR_5_LBN 24
-#define GM_HWADDR_5_WIDTH 8
-#define GM_HWADDR_4_LBN 16
-#define GM_HWADDR_4_WIDTH 8
-#define GM_HWADDR_3_LBN 8
-#define GM_HWADDR_3_WIDTH 8
-#define GM_HWADDR_2_LBN 0
-#define GM_HWADDR_2_WIDTH 8
-
-/* GMAC station address register 2 */
-#define GM_ADR2_REG 0xf10
-#define GM_HWADDR_1_LBN 24
-#define GM_HWADDR_1_WIDTH 8
-#define GM_HWADDR_0_LBN 16
-#define GM_HWADDR_0_WIDTH 8
-
-/* GMAC FIFO configuration register 0 */
-#define GMF_CFG0_REG 0xf20
-#define GMF_FTFENREQ_LBN 12
-#define GMF_FTFENREQ_WIDTH 1
-#define GMF_STFENREQ_LBN 11
-#define GMF_STFENREQ_WIDTH 1
-#define GMF_FRFENREQ_LBN 10
-#define GMF_FRFENREQ_WIDTH 1
-#define GMF_SRFENREQ_LBN 9
-#define GMF_SRFENREQ_WIDTH 1
-#define GMF_WTMENREQ_LBN 8
-#define GMF_WTMENREQ_WIDTH 1
-
-/* GMAC FIFO configuration register 1 */
-#define GMF_CFG1_REG 0xf30
-#define GMF_CFGFRTH_LBN 16
-#define GMF_CFGFRTH_WIDTH 5
-#define GMF_CFGXOFFRTX_LBN 0
-#define GMF_CFGXOFFRTX_WIDTH 16
-
-/* GMAC FIFO configuration register 2 */
-#define GMF_CFG2_REG 0xf40
-#define GMF_CFGHWM_LBN 16
-#define GMF_CFGHWM_WIDTH 6
-#define GMF_CFGLWM_LBN 0
-#define GMF_CFGLWM_WIDTH 6
-
-/* GMAC FIFO configuration register 3 */
-#define GMF_CFG3_REG 0xf50
-#define GMF_CFGHWMFT_LBN 16
-#define GMF_CFGHWMFT_WIDTH 6
-#define GMF_CFGFTTH_LBN 0
-#define GMF_CFGFTTH_WIDTH 6
-
-/* GMAC FIFO configuration register 4 */
-#define GMF_CFG4_REG 0xf60
-#define GMF_HSTFLTRFRM_PAUSE_LBN 12
-#define GMF_HSTFLTRFRM_PAUSE_WIDTH 12
-
-/* GMAC FIFO configuration register 5 */
-#define GMF_CFG5_REG 0xf70
-#define GMF_CFGHDPLX_LBN 22
-#define GMF_CFGHDPLX_WIDTH 1
-#define GMF_CFGBYTMODE_LBN 19
-#define GMF_CFGBYTMODE_WIDTH 1
-#define GMF_HSTDRPLT64_LBN 18
-#define GMF_HSTDRPLT64_WIDTH 1
-#define GMF_HSTFLTRFRMDC_PAUSE_LBN 12
-#define GMF_HSTFLTRFRMDC_PAUSE_WIDTH 1
-
-/* XGMAC address register low */
-#define XM_ADR_LO_REG 0x1200
-#define XM_ADR_3_LBN 24
-#define XM_ADR_3_WIDTH 8
-#define XM_ADR_2_LBN 16
-#define XM_ADR_2_WIDTH 8
-#define XM_ADR_1_LBN 8
-#define XM_ADR_1_WIDTH 8
-#define XM_ADR_0_LBN 0
-#define XM_ADR_0_WIDTH 8
-
-/* XGMAC address register high */
-#define XM_ADR_HI_REG 0x1210
-#define XM_ADR_5_LBN 8
-#define XM_ADR_5_WIDTH 8
-#define XM_ADR_4_LBN 0
-#define XM_ADR_4_WIDTH 8
-
-/* XGMAC global configuration */
-#define XM_GLB_CFG_REG 0x1220
-#define XM_RX_STAT_EN_LBN 11
-#define XM_RX_STAT_EN_WIDTH 1
-#define XM_TX_STAT_EN_LBN 10
-#define XM_TX_STAT_EN_WIDTH 1
-#define XM_RX_JUMBO_MODE_LBN 6
-#define XM_RX_JUMBO_MODE_WIDTH 1
-#define XM_INTCLR_MODE_LBN 3
-#define XM_INTCLR_MODE_WIDTH 1
-#define XM_CORE_RST_LBN 0
-#define XM_CORE_RST_WIDTH 1
-
-/* XGMAC transmit configuration */
-#define XM_TX_CFG_REG 0x1230
-#define XM_IPG_LBN 16
-#define XM_IPG_WIDTH 4
-#define XM_FCNTL_LBN 10
-#define XM_FCNTL_WIDTH 1
-#define XM_TXCRC_LBN 8
-#define XM_TXCRC_WIDTH 1
-#define XM_AUTO_PAD_LBN 5
-#define XM_AUTO_PAD_WIDTH 1
-#define XM_TX_PRMBL_LBN 2
-#define XM_TX_PRMBL_WIDTH 1
-#define XM_TXEN_LBN 1
-#define XM_TXEN_WIDTH 1
-
-/* XGMAC receive configuration */
-#define XM_RX_CFG_REG 0x1240
-#define XM_PASS_CRC_ERR_LBN 25
-#define XM_PASS_CRC_ERR_WIDTH 1
-#define XM_ACPT_ALL_MCAST_LBN 11
-#define XM_ACPT_ALL_MCAST_WIDTH 1
-#define XM_ACPT_ALL_UCAST_LBN 9
-#define XM_ACPT_ALL_UCAST_WIDTH 1
-#define XM_AUTO_DEPAD_LBN 8
-#define XM_AUTO_DEPAD_WIDTH 1
-#define XM_RXEN_LBN 1
-#define XM_RXEN_WIDTH 1
-
-/* XGMAC management interrupt mask register */
-#define XM_MGT_INT_MSK_REG_B0 0x1250
-#define XM_MSK_PRMBLE_ERR_LBN 2
-#define XM_MSK_PRMBLE_ERR_WIDTH 1
-#define XM_MSK_RMTFLT_LBN 1
-#define XM_MSK_RMTFLT_WIDTH 1
-#define XM_MSK_LCLFLT_LBN 0
-#define XM_MSK_LCLFLT_WIDTH 1
-
-/* XGMAC flow control register */
-#define XM_FC_REG 0x1270
-#define XM_PAUSE_TIME_LBN 16
-#define XM_PAUSE_TIME_WIDTH 16
-#define XM_DIS_FCNTL_LBN 0
-#define XM_DIS_FCNTL_WIDTH 1
-
-/* XGMAC pause time count register */
-#define XM_PAUSE_TIME_REG 0x1290
-
-/* XGMAC transmit parameter register */
-#define XM_TX_PARAM_REG 0x012d0
-#define XM_TX_JUMBO_MODE_LBN 31
-#define XM_TX_JUMBO_MODE_WIDTH 1
-#define XM_MAX_TX_FRM_SIZE_LBN 16
-#define XM_MAX_TX_FRM_SIZE_WIDTH 14
-
-/* XGMAC receive parameter register */
-#define XM_RX_PARAM_REG 0x12e0
-#define XM_MAX_RX_FRM_SIZE_LBN 0
-#define XM_MAX_RX_FRM_SIZE_WIDTH 14
-
-/* XGMAC management interrupt status register */
-#define XM_MGT_INT_REG_B0 0x12f0
-#define XM_PRMBLE_ERR 2
-#define XM_PRMBLE_WIDTH 1
-#define XM_RMTFLT_LBN 1
-#define XM_RMTFLT_WIDTH 1
-#define XM_LCLFLT_LBN 0
-#define XM_LCLFLT_WIDTH 1
-
-/* XGXS/XAUI powerdown/reset register */
-#define XX_PWR_RST_REG 0x1300
-
-#define XX_SD_RST_ACT_LBN 16
-#define XX_SD_RST_ACT_WIDTH 1
-#define XX_PWRDND_EN_LBN 15
-#define XX_PWRDND_EN_WIDTH 1
-#define XX_PWRDNC_EN_LBN 14
-#define XX_PWRDNC_EN_WIDTH 1
-#define XX_PWRDNB_EN_LBN 13
-#define XX_PWRDNB_EN_WIDTH 1
-#define XX_PWRDNA_EN_LBN 12
-#define XX_PWRDNA_EN_WIDTH 1
-#define XX_RSTPLLCD_EN_LBN 9
-#define XX_RSTPLLCD_EN_WIDTH 1
-#define XX_RSTPLLAB_EN_LBN 8
-#define XX_RSTPLLAB_EN_WIDTH 1
-#define XX_RESETD_EN_LBN 7
-#define XX_RESETD_EN_WIDTH 1
-#define XX_RESETC_EN_LBN 6
-#define XX_RESETC_EN_WIDTH 1
-#define XX_RESETB_EN_LBN 5
-#define XX_RESETB_EN_WIDTH 1
-#define XX_RESETA_EN_LBN 4
-#define XX_RESETA_EN_WIDTH 1
-#define XX_RSTXGXSRX_EN_LBN 2
-#define XX_RSTXGXSRX_EN_WIDTH 1
-#define XX_RSTXGXSTX_EN_LBN 1
-#define XX_RSTXGXSTX_EN_WIDTH 1
-#define XX_RST_XX_EN_LBN 0
-#define XX_RST_XX_EN_WIDTH 1
-
-/* XGXS/XAUI powerdown/reset control register */
-#define XX_SD_CTL_REG 0x1310
-#define XX_HIDRVD_LBN 15
-#define XX_HIDRVD_WIDTH 1
-#define XX_LODRVD_LBN 14
-#define XX_LODRVD_WIDTH 1
-#define XX_HIDRVC_LBN 13
-#define XX_HIDRVC_WIDTH 1
-#define XX_LODRVC_LBN 12
-#define XX_LODRVC_WIDTH 1
-#define XX_HIDRVB_LBN 11
-#define XX_HIDRVB_WIDTH 1
-#define XX_LODRVB_LBN 10
-#define XX_LODRVB_WIDTH 1
-#define XX_HIDRVA_LBN 9
-#define XX_HIDRVA_WIDTH 1
-#define XX_LODRVA_LBN 8
-#define XX_LODRVA_WIDTH 1
-#define XX_LPBKD_LBN 3
-#define XX_LPBKD_WIDTH 1
-#define XX_LPBKC_LBN 2
-#define XX_LPBKC_WIDTH 1
-#define XX_LPBKB_LBN 1
-#define XX_LPBKB_WIDTH 1
-#define XX_LPBKA_LBN 0
-#define XX_LPBKA_WIDTH 1
-
-#define XX_TXDRV_CTL_REG 0x1320
-#define XX_DEQD_LBN 28
-#define XX_DEQD_WIDTH 4
-#define XX_DEQC_LBN 24
-#define XX_DEQC_WIDTH 4
-#define XX_DEQB_LBN 20
-#define XX_DEQB_WIDTH 4
-#define XX_DEQA_LBN 16
-#define XX_DEQA_WIDTH 4
-#define XX_DTXD_LBN 12
-#define XX_DTXD_WIDTH 4
-#define XX_DTXC_LBN 8
-#define XX_DTXC_WIDTH 4
-#define XX_DTXB_LBN 4
-#define XX_DTXB_WIDTH 4
-#define XX_DTXA_LBN 0
-#define XX_DTXA_WIDTH 4
-
-/* XAUI XGXS core status register */
-#define XX_CORE_STAT_REG 0x1360
-#define XX_FORCE_SIG_LBN 24
-#define XX_FORCE_SIG_WIDTH 8
-#define XX_FORCE_SIG_DECODE_FORCED 0xff
-#define XX_XGXS_LB_EN_LBN 23
-#define XX_XGXS_LB_EN_WIDTH 1
-#define XX_XGMII_LB_EN_LBN 22
-#define XX_XGMII_LB_EN_WIDTH 1
-#define XX_ALIGN_DONE_LBN 20
-#define XX_ALIGN_DONE_WIDTH 1
-#define XX_SYNC_STAT_LBN 16
-#define XX_SYNC_STAT_WIDTH 4
-#define XX_SYNC_STAT_DECODE_SYNCED 0xf
-#define XX_COMMA_DET_LBN 12
-#define XX_COMMA_DET_WIDTH 4
-#define XX_COMMA_DET_DECODE_DETECTED 0xf
-#define XX_COMMA_DET_RESET 0xf
-#define XX_CHARERR_LBN 4
-#define XX_CHARERR_WIDTH 4
-#define XX_CHARERR_RESET 0xf
-#define XX_DISPERR_LBN 0
-#define XX_DISPERR_WIDTH 4
-#define XX_DISPERR_RESET 0xf
-
-/* Receive filter table */
-#define RX_FILTER_TBL0 0xF00000
-
-/* Receive descriptor pointer table */
-#define RX_DESC_PTR_TBL_KER_A1 0x11800
-#define RX_DESC_PTR_TBL_KER_B0 0xF40000
-#define RX_DESC_PTR_TBL_KER_P0 0x900
-#define RX_ISCSI_DDIG_EN_LBN 88
-#define RX_ISCSI_DDIG_EN_WIDTH 1
-#define RX_ISCSI_HDIG_EN_LBN 87
-#define RX_ISCSI_HDIG_EN_WIDTH 1
-#define RX_DESCQ_BUF_BASE_ID_LBN 36
-#define RX_DESCQ_BUF_BASE_ID_WIDTH 20
-#define RX_DESCQ_EVQ_ID_LBN 24
-#define RX_DESCQ_EVQ_ID_WIDTH 12
-#define RX_DESCQ_OWNER_ID_LBN 10
-#define RX_DESCQ_OWNER_ID_WIDTH 14
-#define RX_DESCQ_LABEL_LBN 5
-#define RX_DESCQ_LABEL_WIDTH 5
-#define RX_DESCQ_SIZE_LBN 3
-#define RX_DESCQ_SIZE_WIDTH 2
-#define RX_DESCQ_SIZE_4K 3
-#define RX_DESCQ_SIZE_2K 2
-#define RX_DESCQ_SIZE_1K 1
-#define RX_DESCQ_SIZE_512 0
-#define RX_DESCQ_TYPE_LBN 2
-#define RX_DESCQ_TYPE_WIDTH 1
-#define RX_DESCQ_JUMBO_LBN 1
-#define RX_DESCQ_JUMBO_WIDTH 1
-#define RX_DESCQ_EN_LBN 0
-#define RX_DESCQ_EN_WIDTH 1
-
-/* Transmit descriptor pointer table */
-#define TX_DESC_PTR_TBL_KER_A1 0x11900
-#define TX_DESC_PTR_TBL_KER_B0 0xF50000
-#define TX_DESC_PTR_TBL_KER_P0 0xa40
-#define TX_NON_IP_DROP_DIS_B0_LBN 91
-#define TX_NON_IP_DROP_DIS_B0_WIDTH 1
-#define TX_IP_CHKSM_DIS_B0_LBN 90
-#define TX_IP_CHKSM_DIS_B0_WIDTH 1
-#define TX_TCP_CHKSM_DIS_B0_LBN 89
-#define TX_TCP_CHKSM_DIS_B0_WIDTH 1
-#define TX_DESCQ_EN_LBN 88
-#define TX_DESCQ_EN_WIDTH 1
-#define TX_ISCSI_DDIG_EN_LBN 87
-#define TX_ISCSI_DDIG_EN_WIDTH 1
-#define TX_ISCSI_HDIG_EN_LBN 86
-#define TX_ISCSI_HDIG_EN_WIDTH 1
-#define TX_DESCQ_BUF_BASE_ID_LBN 36
-#define TX_DESCQ_BUF_BASE_ID_WIDTH 20
-#define TX_DESCQ_EVQ_ID_LBN 24
-#define TX_DESCQ_EVQ_ID_WIDTH 12
-#define TX_DESCQ_OWNER_ID_LBN 10
-#define TX_DESCQ_OWNER_ID_WIDTH 14
-#define TX_DESCQ_LABEL_LBN 5
-#define TX_DESCQ_LABEL_WIDTH 5
-#define TX_DESCQ_SIZE_LBN 3
-#define TX_DESCQ_SIZE_WIDTH 2
-#define TX_DESCQ_SIZE_4K 3
-#define TX_DESCQ_SIZE_2K 2
-#define TX_DESCQ_SIZE_1K 1
-#define TX_DESCQ_SIZE_512 0
-#define TX_DESCQ_TYPE_LBN 1
-#define TX_DESCQ_TYPE_WIDTH 2
-
-/* Event queue pointer */
-#define EVQ_PTR_TBL_KER_A1 0x11a00
-#define EVQ_PTR_TBL_KER_B0 0xf60000
-#define EVQ_PTR_TBL_KER_P0 0x500
-#define EVQ_EN_LBN 23
-#define EVQ_EN_WIDTH 1
-#define EVQ_SIZE_LBN 20
-#define EVQ_SIZE_WIDTH 3
-#define EVQ_SIZE_32K 6
-#define EVQ_SIZE_16K 5
-#define EVQ_SIZE_8K 4
-#define EVQ_SIZE_4K 3
-#define EVQ_SIZE_2K 2
-#define EVQ_SIZE_1K 1
-#define EVQ_SIZE_512 0
-#define EVQ_BUF_BASE_ID_LBN 0
-#define EVQ_BUF_BASE_ID_WIDTH 20
-
-/* Event queue read pointer */
-#define EVQ_RPTR_REG_KER_A1 0x11b00
-#define EVQ_RPTR_REG_KER_B0 0xfa0000
-#define EVQ_RPTR_REG_KER_DWORD (EVQ_RPTR_REG_KER + 0)
-#define EVQ_RPTR_DWORD_LBN 0
-#define EVQ_RPTR_DWORD_WIDTH 14
-
-/* RSS indirection table */
-#define RX_RSS_INDIR_TBL_B0 0xFB0000
-#define RX_RSS_INDIR_ENT_B0_LBN 0
-#define RX_RSS_INDIR_ENT_B0_WIDTH 6
-
-/* Special buffer descriptors (full-mode) */
-#define BUF_FULL_TBL_KER_A1 0x8000
-#define BUF_FULL_TBL_KER_B0 0x800000
-#define IP_DAT_BUF_SIZE_LBN 50
-#define IP_DAT_BUF_SIZE_WIDTH 1
-#define IP_DAT_BUF_SIZE_8K 1
-#define IP_DAT_BUF_SIZE_4K 0
-#define BUF_ADR_REGION_LBN 48
-#define BUF_ADR_REGION_WIDTH 2
-#define BUF_ADR_FBUF_LBN 14
-#define BUF_ADR_FBUF_WIDTH 34
-#define BUF_OWNER_ID_FBUF_LBN 0
-#define BUF_OWNER_ID_FBUF_WIDTH 14
-
-/* Transmit descriptor */
-#define TX_KER_PORT_LBN 63
-#define TX_KER_PORT_WIDTH 1
-#define TX_KER_CONT_LBN 62
-#define TX_KER_CONT_WIDTH 1
-#define TX_KER_BYTE_CNT_LBN 48
-#define TX_KER_BYTE_CNT_WIDTH 14
-#define TX_KER_BUF_REGION_LBN 46
-#define TX_KER_BUF_REGION_WIDTH 2
-#define TX_KER_BUF_REGION0_DECODE 0
-#define TX_KER_BUF_REGION1_DECODE 1
-#define TX_KER_BUF_REGION2_DECODE 2
-#define TX_KER_BUF_REGION3_DECODE 3
-#define TX_KER_BUF_ADR_LBN 0
-#define TX_KER_BUF_ADR_WIDTH EFX_DMA_TYPE_WIDTH(46)
-
-/* Receive descriptor */
-#define RX_KER_BUF_SIZE_LBN 48
-#define RX_KER_BUF_SIZE_WIDTH 14
-#define RX_KER_BUF_REGION_LBN 46
-#define RX_KER_BUF_REGION_WIDTH 2
-#define RX_KER_BUF_REGION0_DECODE 0
-#define RX_KER_BUF_REGION1_DECODE 1
-#define RX_KER_BUF_REGION2_DECODE 2
-#define RX_KER_BUF_REGION3_DECODE 3
-#define RX_KER_BUF_ADR_LBN 0
-#define RX_KER_BUF_ADR_WIDTH EFX_DMA_TYPE_WIDTH(46)
-
-/**************************************************************************
- *
- * Falcon events
- *
- **************************************************************************
- */
-
-/* Event queue entries */
-#define EV_CODE_LBN 60
-#define EV_CODE_WIDTH 4
-#define RX_IP_EV_DECODE 0
-#define TX_IP_EV_DECODE 2
-#define DRIVER_EV_DECODE 5
-#define GLOBAL_EV_DECODE 6
-#define DRV_GEN_EV_DECODE 7
-#define WHOLE_EVENT_LBN 0
-#define WHOLE_EVENT_WIDTH 64
-
-/* Receive events */
-#define RX_EV_PKT_OK_LBN 56
-#define RX_EV_PKT_OK_WIDTH 1
-#define RX_EV_PAUSE_FRM_ERR_LBN 55
-#define RX_EV_PAUSE_FRM_ERR_WIDTH 1
-#define RX_EV_BUF_OWNER_ID_ERR_LBN 54
-#define RX_EV_BUF_OWNER_ID_ERR_WIDTH 1
-#define RX_EV_IF_FRAG_ERR_LBN 53
-#define RX_EV_IF_FRAG_ERR_WIDTH 1
-#define RX_EV_IP_HDR_CHKSUM_ERR_LBN 52
-#define RX_EV_IP_HDR_CHKSUM_ERR_WIDTH 1
-#define RX_EV_TCP_UDP_CHKSUM_ERR_LBN 51
-#define RX_EV_TCP_UDP_CHKSUM_ERR_WIDTH 1
-#define RX_EV_ETH_CRC_ERR_LBN 50
-#define RX_EV_ETH_CRC_ERR_WIDTH 1
-#define RX_EV_FRM_TRUNC_LBN 49
-#define RX_EV_FRM_TRUNC_WIDTH 1
-#define RX_EV_DRIB_NIB_LBN 48
-#define RX_EV_DRIB_NIB_WIDTH 1
-#define RX_EV_TOBE_DISC_LBN 47
-#define RX_EV_TOBE_DISC_WIDTH 1
-#define RX_EV_PKT_TYPE_LBN 44
-#define RX_EV_PKT_TYPE_WIDTH 3
-#define RX_EV_PKT_TYPE_ETH_DECODE 0
-#define RX_EV_PKT_TYPE_LLC_DECODE 1
-#define RX_EV_PKT_TYPE_JUMBO_DECODE 2
-#define RX_EV_PKT_TYPE_VLAN_DECODE 3
-#define RX_EV_PKT_TYPE_VLAN_LLC_DECODE 4
-#define RX_EV_PKT_TYPE_VLAN_JUMBO_DECODE 5
-#define RX_EV_HDR_TYPE_LBN 42
-#define RX_EV_HDR_TYPE_WIDTH 2
-#define RX_EV_HDR_TYPE_TCP_IPV4_DECODE 0
-#define RX_EV_HDR_TYPE_UDP_IPV4_DECODE 1
-#define RX_EV_HDR_TYPE_OTHER_IP_DECODE 2
-#define RX_EV_HDR_TYPE_NON_IP_DECODE 3
-#define RX_EV_HDR_TYPE_HAS_CHECKSUMS(hdr_type) \
-	((hdr_type) <= RX_EV_HDR_TYPE_UDP_IPV4_DECODE)
-#define RX_EV_MCAST_HASH_MATCH_LBN 40
-#define RX_EV_MCAST_HASH_MATCH_WIDTH 1
-#define RX_EV_MCAST_PKT_LBN 39
-#define RX_EV_MCAST_PKT_WIDTH 1
-#define RX_EV_Q_LABEL_LBN 32
-#define RX_EV_Q_LABEL_WIDTH 5
-#define RX_EV_JUMBO_CONT_LBN 31
-#define RX_EV_JUMBO_CONT_WIDTH 1
-#define RX_EV_BYTE_CNT_LBN 16
-#define RX_EV_BYTE_CNT_WIDTH 14
-#define RX_EV_SOP_LBN 15
-#define RX_EV_SOP_WIDTH 1
-#define RX_EV_DESC_PTR_LBN 0
-#define RX_EV_DESC_PTR_WIDTH 12
-
-/* Transmit events */
-#define TX_EV_PKT_ERR_LBN 38
-#define TX_EV_PKT_ERR_WIDTH 1
-#define TX_EV_Q_LABEL_LBN 32
-#define TX_EV_Q_LABEL_WIDTH 5
-#define TX_EV_WQ_FF_FULL_LBN 15
-#define TX_EV_WQ_FF_FULL_WIDTH 1
-#define TX_EV_COMP_LBN 12
-#define TX_EV_COMP_WIDTH 1
-#define TX_EV_DESC_PTR_LBN 0
-#define TX_EV_DESC_PTR_WIDTH 12
-
-/* Driver events */
-#define DRIVER_EV_SUB_CODE_LBN 56
-#define DRIVER_EV_SUB_CODE_WIDTH 4
-#define DRIVER_EV_SUB_DATA_LBN 0
-#define DRIVER_EV_SUB_DATA_WIDTH 14
-#define TX_DESCQ_FLS_DONE_EV_DECODE 0
-#define RX_DESCQ_FLS_DONE_EV_DECODE 1
-#define EVQ_INIT_DONE_EV_DECODE 2
-#define EVQ_NOT_EN_EV_DECODE 3
-#define RX_DESCQ_FLSFF_OVFL_EV_DECODE 4
-#define SRM_UPD_DONE_EV_DECODE 5
-#define WAKE_UP_EV_DECODE 6
-#define TX_PKT_NON_TCP_UDP_DECODE 9
-#define TIMER_EV_DECODE 10
-#define RX_RECOVERY_EV_DECODE 11
-#define RX_DSC_ERROR_EV_DECODE 14
-#define TX_DSC_ERROR_EV_DECODE 15
-#define DRIVER_EV_TX_DESCQ_ID_LBN 0
-#define DRIVER_EV_TX_DESCQ_ID_WIDTH 12
-#define DRIVER_EV_RX_FLUSH_FAIL_LBN 12
-#define DRIVER_EV_RX_FLUSH_FAIL_WIDTH 1
-#define DRIVER_EV_RX_DESCQ_ID_LBN 0
-#define DRIVER_EV_RX_DESCQ_ID_WIDTH 12
-#define SRM_CLR_EV_DECODE 0
-#define SRM_UPD_EV_DECODE 1
-#define SRM_ILLCLR_EV_DECODE 2
-
-/* Global events */
-#define RX_RECOVERY_B0_LBN 12
-#define RX_RECOVERY_B0_WIDTH 1
-#define XG_MNT_INTR_B0_LBN 11
-#define XG_MNT_INTR_B0_WIDTH 1
-#define RX_RECOVERY_A1_LBN 11
-#define RX_RECOVERY_A1_WIDTH 1
-#define XFP_PHY_INTR_LBN 10
-#define XFP_PHY_INTR_WIDTH 1
-#define XG_PHY_INTR_LBN 9
-#define XG_PHY_INTR_WIDTH 1
-#define G_PHY1_INTR_LBN 8
-#define G_PHY1_INTR_WIDTH 1
-#define G_PHY0_INTR_LBN 7
-#define G_PHY0_INTR_WIDTH 1
-
-/* Driver-generated test events */
-#define EVQ_MAGIC_LBN 0
-#define EVQ_MAGIC_WIDTH 32
-
-/**************************************************************************
- *
- * Falcon MAC stats
- *
- **************************************************************************
- *
- */
-
-#define GRxGoodOct_offset 0x0
-#define GRxGoodOct_WIDTH 48
-#define GRxBadOct_offset 0x8
-#define GRxBadOct_WIDTH 48
-#define GRxMissPkt_offset 0x10
-#define GRxMissPkt_WIDTH 32
-#define GRxFalseCRS_offset 0x14
-#define GRxFalseCRS_WIDTH 32
-#define GRxPausePkt_offset 0x18
-#define GRxPausePkt_WIDTH 32
-#define GRxBadPkt_offset 0x1C
-#define GRxBadPkt_WIDTH 32
-#define GRxUcastPkt_offset 0x20
-#define GRxUcastPkt_WIDTH 32
-#define GRxMcastPkt_offset 0x24
-#define GRxMcastPkt_WIDTH 32
-#define GRxBcastPkt_offset 0x28
-#define GRxBcastPkt_WIDTH 32
-#define GRxGoodLt64Pkt_offset 0x2C
-#define GRxGoodLt64Pkt_WIDTH 32
-#define GRxBadLt64Pkt_offset 0x30
-#define GRxBadLt64Pkt_WIDTH 32
-#define GRx64Pkt_offset 0x34
-#define GRx64Pkt_WIDTH 32
-#define GRx65to127Pkt_offset 0x38
-#define GRx65to127Pkt_WIDTH 32
-#define GRx128to255Pkt_offset 0x3C
-#define GRx128to255Pkt_WIDTH 32
-#define GRx256to511Pkt_offset 0x40
-#define GRx256to511Pkt_WIDTH 32
-#define GRx512to1023Pkt_offset 0x44
-#define GRx512to1023Pkt_WIDTH 32
-#define GRx1024to15xxPkt_offset 0x48
-#define GRx1024to15xxPkt_WIDTH 32
-#define GRx15xxtoJumboPkt_offset 0x4C
-#define GRx15xxtoJumboPkt_WIDTH 32
-#define GRxGtJumboPkt_offset 0x50
-#define GRxGtJumboPkt_WIDTH 32
-#define GRxFcsErr64to15xxPkt_offset 0x54
-#define GRxFcsErr64to15xxPkt_WIDTH 32
-#define GRxFcsErr15xxtoJumboPkt_offset 0x58
-#define GRxFcsErr15xxtoJumboPkt_WIDTH 32
-#define GRxFcsErrGtJumboPkt_offset 0x5C
-#define GRxFcsErrGtJumboPkt_WIDTH 32
-#define GTxGoodBadOct_offset 0x80
-#define GTxGoodBadOct_WIDTH 48
-#define GTxGoodOct_offset 0x88
-#define GTxGoodOct_WIDTH 48
-#define GTxSglColPkt_offset 0x90
-#define GTxSglColPkt_WIDTH 32
-#define GTxMultColPkt_offset 0x94
-#define GTxMultColPkt_WIDTH 32
-#define GTxExColPkt_offset 0x98
-#define GTxExColPkt_WIDTH 32
-#define GTxDefPkt_offset 0x9C
-#define GTxDefPkt_WIDTH 32
-#define GTxLateCol_offset 0xA0
-#define GTxLateCol_WIDTH 32
-#define GTxExDefPkt_offset 0xA4
-#define GTxExDefPkt_WIDTH 32
-#define GTxPausePkt_offset 0xA8
-#define GTxPausePkt_WIDTH 32
-#define GTxBadPkt_offset 0xAC
-#define GTxBadPkt_WIDTH 32
-#define GTxUcastPkt_offset 0xB0
-#define GTxUcastPkt_WIDTH 32
-#define GTxMcastPkt_offset 0xB4
-#define GTxMcastPkt_WIDTH 32
-#define GTxBcastPkt_offset 0xB8
-#define GTxBcastPkt_WIDTH 32
-#define GTxLt64Pkt_offset 0xBC
-#define GTxLt64Pkt_WIDTH 32
-#define GTx64Pkt_offset 0xC0
-#define GTx64Pkt_WIDTH 32
-#define GTx65to127Pkt_offset 0xC4
-#define GTx65to127Pkt_WIDTH 32
-#define GTx128to255Pkt_offset 0xC8
-#define GTx128to255Pkt_WIDTH 32
-#define GTx256to511Pkt_offset 0xCC
-#define GTx256to511Pkt_WIDTH 32
-#define GTx512to1023Pkt_offset 0xD0
-#define GTx512to1023Pkt_WIDTH 32
-#define GTx1024to15xxPkt_offset 0xD4
-#define GTx1024to15xxPkt_WIDTH 32
-#define GTx15xxtoJumboPkt_offset 0xD8
-#define GTx15xxtoJumboPkt_WIDTH 32
-#define GTxGtJumboPkt_offset 0xDC
-#define GTxGtJumboPkt_WIDTH 32
-#define GTxNonTcpUdpPkt_offset 0xE0
-#define GTxNonTcpUdpPkt_WIDTH 16
-#define GTxMacSrcErrPkt_offset 0xE4
-#define GTxMacSrcErrPkt_WIDTH 16
-#define GTxIpSrcErrPkt_offset 0xE8
-#define GTxIpSrcErrPkt_WIDTH 16
-#define GDmaDone_offset 0xEC
-#define GDmaDone_WIDTH 32
-
-#define XgRxOctets_offset 0x0
-#define XgRxOctets_WIDTH 48
-#define XgRxOctetsOK_offset 0x8
-#define XgRxOctetsOK_WIDTH 48
-#define XgRxPkts_offset 0x10
-#define XgRxPkts_WIDTH 32
-#define XgRxPktsOK_offset 0x14
-#define XgRxPktsOK_WIDTH 32
-#define XgRxBroadcastPkts_offset 0x18
-#define XgRxBroadcastPkts_WIDTH 32
-#define XgRxMulticastPkts_offset 0x1C
-#define XgRxMulticastPkts_WIDTH 32
-#define XgRxUnicastPkts_offset 0x20
-#define XgRxUnicastPkts_WIDTH 32
-#define XgRxUndersizePkts_offset 0x24
-#define XgRxUndersizePkts_WIDTH 32
-#define XgRxOversizePkts_offset 0x28
-#define XgRxOversizePkts_WIDTH 32
-#define XgRxJabberPkts_offset 0x2C
-#define XgRxJabberPkts_WIDTH 32
-#define XgRxUndersizeFCSerrorPkts_offset 0x30
-#define XgRxUndersizeFCSerrorPkts_WIDTH 32
-#define XgRxDropEvents_offset 0x34
-#define XgRxDropEvents_WIDTH 32
-#define XgRxFCSerrorPkts_offset 0x38
-#define XgRxFCSerrorPkts_WIDTH 32
-#define XgRxAlignError_offset 0x3C
-#define XgRxAlignError_WIDTH 32
-#define XgRxSymbolError_offset 0x40
-#define XgRxSymbolError_WIDTH 32
-#define XgRxInternalMACError_offset 0x44
-#define XgRxInternalMACError_WIDTH 32
-#define XgRxControlPkts_offset 0x48
-#define XgRxControlPkts_WIDTH 32
-#define XgRxPausePkts_offset 0x4C
-#define XgRxPausePkts_WIDTH 32
-#define XgRxPkts64Octets_offset 0x50
-#define XgRxPkts64Octets_WIDTH 32
-#define XgRxPkts65to127Octets_offset 0x54
-#define XgRxPkts65to127Octets_WIDTH 32
-#define XgRxPkts128to255Octets_offset 0x58
-#define XgRxPkts128to255Octets_WIDTH 32
-#define XgRxPkts256to511Octets_offset 0x5C
-#define XgRxPkts256to511Octets_WIDTH 32
-#define XgRxPkts512to1023Octets_offset 0x60
-#define XgRxPkts512to1023Octets_WIDTH 32
-#define XgRxPkts1024to15xxOctets_offset 0x64
-#define XgRxPkts1024to15xxOctets_WIDTH 32
-#define XgRxPkts15xxtoMaxOctets_offset 0x68
-#define XgRxPkts15xxtoMaxOctets_WIDTH 32
-#define XgRxLengthError_offset 0x6C
-#define XgRxLengthError_WIDTH 32
-#define XgTxPkts_offset 0x80
-#define XgTxPkts_WIDTH 32
-#define XgTxOctets_offset 0x88
-#define XgTxOctets_WIDTH 48
-#define XgTxMulticastPkts_offset 0x90
-#define XgTxMulticastPkts_WIDTH 32
-#define XgTxBroadcastPkts_offset 0x94
-#define XgTxBroadcastPkts_WIDTH 32
-#define XgTxUnicastPkts_offset 0x98
-#define XgTxUnicastPkts_WIDTH 32
-#define XgTxControlPkts_offset 0x9C
-#define XgTxControlPkts_WIDTH 32
-#define XgTxPausePkts_offset 0xA0
-#define XgTxPausePkts_WIDTH 32
-#define XgTxPkts64Octets_offset 0xA4
-#define XgTxPkts64Octets_WIDTH 32
-#define XgTxPkts65to127Octets_offset 0xA8
-#define XgTxPkts65to127Octets_WIDTH 32
-#define XgTxPkts128to255Octets_offset 0xAC
-#define XgTxPkts128to255Octets_WIDTH 32
-#define XgTxPkts256to511Octets_offset 0xB0
-#define XgTxPkts256to511Octets_WIDTH 32
-#define XgTxPkts512to1023Octets_offset 0xB4
-#define XgTxPkts512to1023Octets_WIDTH 32
-#define XgTxPkts1024to15xxOctets_offset 0xB8
-#define XgTxPkts1024to15xxOctets_WIDTH 32
-#define XgTxPkts1519toMaxOctets_offset 0xBC
-#define XgTxPkts1519toMaxOctets_WIDTH 32
-#define XgTxUndersizePkts_offset 0xC0
-#define XgTxUndersizePkts_WIDTH 32
-#define XgTxOversizePkts_offset 0xC4
-#define XgTxOversizePkts_WIDTH 32
-#define XgTxNonTcpUdpPkt_offset 0xC8
-#define XgTxNonTcpUdpPkt_WIDTH 16
-#define XgTxMacSrcErrPkt_offset 0xCC
-#define XgTxMacSrcErrPkt_WIDTH 16
-#define XgTxIpSrcErrPkt_offset 0xD0
-#define XgTxIpSrcErrPkt_WIDTH 16
-#define XgDmaDone_offset 0xD4
-
-#define FALCON_STATS_NOT_DONE 0x00000000
-#define FALCON_STATS_DONE 0xffffffff
-
-/* Interrupt status register bits */
-#define FATAL_INT_LBN 64
-#define FATAL_INT_WIDTH 1
-#define INT_EVQS_LBN 40
-#define INT_EVQS_WIDTH 4
-
-/**************************************************************************
- *
- * Falcon non-volatile configuration
- *
- **************************************************************************
- */
-
-/* Board configuration v2 (v1 is obsolete; later versions are compatible) */
-struct falcon_nvconfig_board_v2 {
-	__le16 nports;
-	u8 port0_phy_addr;
-	u8 port0_phy_type;
-	u8 port1_phy_addr;
-	u8 port1_phy_type;
-	__le16 asic_sub_revision;
-	__le16 board_revision;
-} __packed;
-
-/* Board configuration v3 extra information */
-struct falcon_nvconfig_board_v3 {
-	__le32 spi_device_type[2];
-} __packed;
-
-/* Bit numbers for spi_device_type */
-#define SPI_DEV_TYPE_SIZE_LBN 0
-#define SPI_DEV_TYPE_SIZE_WIDTH 5
-#define SPI_DEV_TYPE_ADDR_LEN_LBN 6
-#define SPI_DEV_TYPE_ADDR_LEN_WIDTH 2
-#define SPI_DEV_TYPE_ERASE_CMD_LBN 8
-#define SPI_DEV_TYPE_ERASE_CMD_WIDTH 8
-#define SPI_DEV_TYPE_ERASE_SIZE_LBN 16
-#define SPI_DEV_TYPE_ERASE_SIZE_WIDTH 5
-#define SPI_DEV_TYPE_BLOCK_SIZE_LBN 24
-#define SPI_DEV_TYPE_BLOCK_SIZE_WIDTH 5
-#define SPI_DEV_TYPE_FIELD(type, field)					\
-	(((type) >> EFX_LOW_BIT(field)) & EFX_MASK32(EFX_WIDTH(field)))
-
-#define NVCONFIG_OFFSET 0x300
-
-#define NVCONFIG_BOARD_MAGIC_NUM 0xFA1C
-struct falcon_nvconfig {
-	efx_oword_t ee_vpd_cfg_reg;			/* 0x300 */
-	u8 mac_address[2][8];			/* 0x310 */
-	efx_oword_t pcie_sd_ctl0123_reg;		/* 0x320 */
-	efx_oword_t pcie_sd_ctl45_reg;			/* 0x330 */
-	efx_oword_t pcie_pcs_ctl_stat_reg;		/* 0x340 */
-	efx_oword_t hw_init_reg;			/* 0x350 */
-	efx_oword_t nic_stat_reg;			/* 0x360 */
-	efx_oword_t glb_ctl_reg;			/* 0x370 */
-	efx_oword_t srm_cfg_reg;			/* 0x380 */
-	efx_oword_t spare_reg;				/* 0x390 */
-	__le16 board_magic_num;			/* 0x3A0 */
-	__le16 board_struct_ver;
-	__le16 board_checksum;
-	struct falcon_nvconfig_board_v2 board_v2;
-	efx_oword_t ee_base_page_reg;			/* 0x3B0 */
-	struct falcon_nvconfig_board_v3 board_v3;
-} __packed;
-
-#endif /* EFX_FALCON_HWDEFS_H */
diff -r 9566a4a50a43 drivers/net/sfc/falcon_io.h
--- a/drivers/net/sfc/falcon_io.h
+++ /dev/null
@@ -1,258 +0,0 @@
-/****************************************************************************
- * Driver for Solarflare Solarstorm network controllers and boards
- * Copyright 2005-2006 Fen Systems Ltd.
- * Copyright 2006-2008 Solarflare Communications Inc.
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 as published
- * by the Free Software Foundation, incorporated herein by reference.
- */
-
-#ifndef EFX_FALCON_IO_H
-#define EFX_FALCON_IO_H
-
-#include <linux/io.h>
-#include <linux/spinlock.h>
-
-/**************************************************************************
- *
- * Falcon hardware access
- *
- **************************************************************************
- *
- * Notes on locking strategy:
- *
- * Most Falcon registers require 16-byte (or 8-byte, for SRAM
- * registers) atomic writes which necessitates locking.
- * Under normal operation few writes to the Falcon BAR are made and these
- * registers (EVQ_RPTR_REG, RX_DESC_UPD_REG and TX_DESC_UPD_REG) are special
- * cased to allow 4-byte (hence lockless) accesses.
- *
- * It *is* safe to write to these 4-byte registers in the middle of an
- * access to an 8-byte or 16-byte register.  We therefore use a
- * spinlock to protect accesses to the larger registers, but no locks
- * for the 4-byte registers.
- *
- * A write barrier is needed to ensure that DW3 is written after DW0/1/2
- * due to the way the 16byte registers are "collected" in the Falcon BIU
- *
- * We also lock when carrying out reads, to ensure consistency of the
- * data (made possible since the BIU reads all 128 bits into a cache).
- * Reads are very rare, so this isn't a significant performance
- * impact.  (Most data transferred from NIC to host is DMAed directly
- * into host memory).
- *
- * I/O BAR access uses locks for both reads and writes (but is only provided
- * for testing purposes).
- */
-
-/* Special buffer descriptors (Falcon SRAM) */
-#define BUF_TBL_KER_A1 0x18000
-#define BUF_TBL_KER_B0 0x800000
-
-
-#if BITS_PER_LONG == 64
-#define FALCON_USE_QWORD_IO 1
-#endif
-
-#ifdef FALCON_USE_QWORD_IO
-static inline void _falcon_writeq(struct efx_nic *efx, __le64 value,
-				  unsigned int reg)
-{
-	__raw_writeq((__force u64)value, efx->membase + reg);
-}
-static inline __le64 _falcon_readq(struct efx_nic *efx, unsigned int reg)
-{
-	return (__force __le64)__raw_readq(efx->membase + reg);
-}
-#endif
-
-static inline void _falcon_writel(struct efx_nic *efx, __le32 value,
-				  unsigned int reg)
-{
-	__raw_writel((__force u32)value, efx->membase + reg);
-}
-static inline __le32 _falcon_readl(struct efx_nic *efx, unsigned int reg)
-{
-	return (__force __le32)__raw_readl(efx->membase + reg);
-}
-
-/* Writes to a normal 16-byte Falcon register, locking as appropriate. */
-static inline void falcon_write(struct efx_nic *efx, efx_oword_t *value,
-				unsigned int reg)
-{
-	unsigned long flags;
-
-	EFX_REGDUMP(efx, "writing register %x with " EFX_OWORD_FMT "\n", reg,
-		    EFX_OWORD_VAL(*value));
-
-	spin_lock_irqsave(&efx->biu_lock, flags);
-#ifdef FALCON_USE_QWORD_IO
-	_falcon_writeq(efx, value->u64[0], reg + 0);
-	wmb();
-	_falcon_writeq(efx, value->u64[1], reg + 8);
-#else
-	_falcon_writel(efx, value->u32[0], reg + 0);
-	_falcon_writel(efx, value->u32[1], reg + 4);
-	_falcon_writel(efx, value->u32[2], reg + 8);
-	wmb();
-	_falcon_writel(efx, value->u32[3], reg + 12);
-#endif
-	mmiowb();
-	spin_unlock_irqrestore(&efx->biu_lock, flags);
-}
-
-/* Writes to an 8-byte Falcon SRAM register, locking as appropriate. */
-static inline void falcon_write_sram(struct efx_nic *efx, efx_qword_t *value,
-				     unsigned int index)
-{
-	unsigned int reg = efx->type->buf_tbl_base + (index * sizeof(*value));
-	unsigned long flags;
-
-	EFX_REGDUMP(efx, "writing SRAM register %x with " EFX_QWORD_FMT "\n",
-		    reg, EFX_QWORD_VAL(*value));
-
-	spin_lock_irqsave(&efx->biu_lock, flags);
-#ifdef FALCON_USE_QWORD_IO
-	_falcon_writeq(efx, value->u64[0], reg + 0);
-#else
-	_falcon_writel(efx, value->u32[0], reg + 0);
-	wmb();
-	_falcon_writel(efx, value->u32[1], reg + 4);
-#endif
-	mmiowb();
-	spin_unlock_irqrestore(&efx->biu_lock, flags);
-}
-
-/* Write dword to Falcon register that allows partial writes
- *
- * Some Falcon registers (EVQ_RPTR_REG, RX_DESC_UPD_REG and
- * TX_DESC_UPD_REG) can be written to as a single dword.  This allows
- * for lockless writes.
- */
-static inline void falcon_writel(struct efx_nic *efx, efx_dword_t *value,
-				 unsigned int reg)
-{
-	EFX_REGDUMP(efx, "writing partial register %x with "EFX_DWORD_FMT"\n",
-		    reg, EFX_DWORD_VAL(*value));
-
-	/* No lock required */
-	_falcon_writel(efx, value->u32[0], reg);
-}
-
-/* Read from a Falcon register
- *
- * This reads an entire 16-byte Falcon register in one go, locking as
- * appropriate.  It is essential to read the first dword first, as this
- * prompts Falcon to load the current value into the shadow register.
- */
-static inline void falcon_read(struct efx_nic *efx, efx_oword_t *value,
-			       unsigned int reg)
-{
-	unsigned long flags;
-
-	spin_lock_irqsave(&efx->biu_lock, flags);
-	value->u32[0] = _falcon_readl(efx, reg + 0);
-	rmb();
-	value->u32[1] = _falcon_readl(efx, reg + 4);
-	value->u32[2] = _falcon_readl(efx, reg + 8);
-	value->u32[3] = _falcon_readl(efx, reg + 12);
-	spin_unlock_irqrestore(&efx->biu_lock, flags);
-
-	EFX_REGDUMP(efx, "read from register %x, got " EFX_OWORD_FMT "\n", reg,
-		    EFX_OWORD_VAL(*value));
-}
-
-/* This reads an 8-byte Falcon SRAM entry in one go. */
-static inline void falcon_read_sram(struct efx_nic *efx, efx_qword_t *value,
-				    unsigned int index)
-{
-	unsigned int reg = efx->type->buf_tbl_base + (index * sizeof(*value));
-	unsigned long flags;
-
-	spin_lock_irqsave(&efx->biu_lock, flags);
-#ifdef FALCON_USE_QWORD_IO
-	value->u64[0] = _falcon_readq(efx, reg + 0);
-#else
-	value->u32[0] = _falcon_readl(efx, reg + 0);
-	rmb();
-	value->u32[1] = _falcon_readl(efx, reg + 4);
-#endif
-	spin_unlock_irqrestore(&efx->biu_lock, flags);
-
-	EFX_REGDUMP(efx, "read from SRAM register %x, got "EFX_QWORD_FMT"\n",
-		    reg, EFX_QWORD_VAL(*value));
-}
-
-/* Read dword from Falcon register that allows partial writes (sic) */
-static inline void falcon_readl(struct efx_nic *efx, efx_dword_t *value,
-				unsigned int reg)
-{
-	value->u32[0] = _falcon_readl(efx, reg);
-	EFX_REGDUMP(efx, "read from register %x, got "EFX_DWORD_FMT"\n",
-		    reg, EFX_DWORD_VAL(*value));
-}
-
-/* Write to a register forming part of a table */
-static inline void falcon_write_table(struct efx_nic *efx, efx_oword_t *value,
-				      unsigned int reg, unsigned int index)
-{
-	falcon_write(efx, value, reg + index * sizeof(efx_oword_t));
-}
-
-/* Read to a register forming part of a table */
-static inline void falcon_read_table(struct efx_nic *efx, efx_oword_t *value,
-				     unsigned int reg, unsigned int index)
-{
-	falcon_read(efx, value, reg + index * sizeof(efx_oword_t));
-}
-
-/* Write to a dword register forming part of a table */
-static inline void falcon_writel_table(struct efx_nic *efx, efx_dword_t *value,
-				       unsigned int reg, unsigned int index)
-{
-	falcon_writel(efx, value, reg + index * sizeof(efx_oword_t));
-}
-
-/* Page-mapped register block size */
-#define FALCON_PAGE_BLOCK_SIZE 0x2000
-
-/* Calculate offset to page-mapped register block */
-#define FALCON_PAGED_REG(page, reg) \
-	((page) * FALCON_PAGE_BLOCK_SIZE + (reg))
-
-/* As for falcon_write(), but for a page-mapped register. */
-static inline void falcon_write_page(struct efx_nic *efx, efx_oword_t *value,
-				     unsigned int reg, unsigned int page)
-{
-	falcon_write(efx, value, FALCON_PAGED_REG(page, reg));
-}
-
-/* As for falcon_writel(), but for a page-mapped register. */
-static inline void falcon_writel_page(struct efx_nic *efx, efx_dword_t *value,
-				      unsigned int reg, unsigned int page)
-{
-	falcon_writel(efx, value, FALCON_PAGED_REG(page, reg));
-}
-
-/* Write dword to Falcon page-mapped register with an extra lock.
- *
- * As for falcon_writel_page(), but for a register that suffers from
- * SFC bug 3181.  If writing to page 0, take out a lock so the BIU
- * collector cannot be confused.
- */
-static inline void falcon_writel_page_locked(struct efx_nic *efx,
-					     efx_dword_t *value,
-					     unsigned int reg,
-					     unsigned int page)
-{
-	unsigned long flags = 0;
-
-	if (page == 0)
-		spin_lock_irqsave(&efx->biu_lock, flags);
-	falcon_writel(efx, value, FALCON_PAGED_REG(page, reg));
-	if (page == 0)
-		spin_unlock_irqrestore(&efx->biu_lock, flags);
-}
-
-#endif /* EFX_FALCON_IO_H */
diff -r 9566a4a50a43 drivers/net/sfc/falcon_xmac.c
--- a/drivers/net/sfc/falcon_xmac.c
+++ b/drivers/net/sfc/falcon_xmac.c
@@ -1,7 +1,7 @@
 /****************************************************************************
  * Driver for Solarflare Solarstorm network controllers and boards
  * Copyright 2005-2006 Fen Systems Ltd.
- * Copyright 2006-2008 Solarflare Communications Inc.
+ * Copyright 2006-2010 Solarflare Communications Inc.
  *
  * This program is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 as published
@@ -11,13 +11,10 @@
 #include <linux/delay.h>
 #include "net_driver.h"
 #include "efx.h"
-#include "falcon.h"
-#include "falcon_hwdefs.h"
-#include "falcon_io.h"
-#include "mac.h"
+#include "nic.h"
+#include "regs.h"
+#include "io.h"
 #include "mdio_10g.h"
-#include "phy.h"
-#include "boards.h"
 #include "workarounds.h"
 
 /**************************************************************************
@@ -27,7 +24,7 @@
  *************************************************************************/
 
 /* Configure the XAUI driver that is an output from Falcon */
-static void falcon_setup_xaui(struct efx_nic *efx)
+void falcon_setup_xaui(struct efx_nic *efx)
 {
 	efx_oword_t sdctl, txdrv;
 
@@ -36,167 +33,167 @@ static void falcon_setup_xaui(struct efx
 	if (efx->phy_type == PHY_TYPE_NONE)
 		return;
 
-	falcon_read(efx, &sdctl, XX_SD_CTL_REG);
-	EFX_SET_OWORD_FIELD(sdctl, XX_HIDRVD, XX_SD_CTL_DRV_DEFAULT);
-	EFX_SET_OWORD_FIELD(sdctl, XX_LODRVD, XX_SD_CTL_DRV_DEFAULT);
-	EFX_SET_OWORD_FIELD(sdctl, XX_HIDRVC, XX_SD_CTL_DRV_DEFAULT);
-	EFX_SET_OWORD_FIELD(sdctl, XX_LODRVC, XX_SD_CTL_DRV_DEFAULT);
-	EFX_SET_OWORD_FIELD(sdctl, XX_HIDRVB, XX_SD_CTL_DRV_DEFAULT);
-	EFX_SET_OWORD_FIELD(sdctl, XX_LODRVB, XX_SD_CTL_DRV_DEFAULT);
-	EFX_SET_OWORD_FIELD(sdctl, XX_HIDRVA, XX_SD_CTL_DRV_DEFAULT);
-	EFX_SET_OWORD_FIELD(sdctl, XX_LODRVA, XX_SD_CTL_DRV_DEFAULT);
-	falcon_write(efx, &sdctl, XX_SD_CTL_REG);
+	efx_reado(efx, &sdctl, FR_AB_XX_SD_CTL);
+	EFX_SET_OWORD_FIELD(sdctl, FRF_AB_XX_HIDRVD, FFE_AB_XX_SD_CTL_DRV_DEF);
+	EFX_SET_OWORD_FIELD(sdctl, FRF_AB_XX_LODRVD, FFE_AB_XX_SD_CTL_DRV_DEF);
+	EFX_SET_OWORD_FIELD(sdctl, FRF_AB_XX_HIDRVC, FFE_AB_XX_SD_CTL_DRV_DEF);
+	EFX_SET_OWORD_FIELD(sdctl, FRF_AB_XX_LODRVC, FFE_AB_XX_SD_CTL_DRV_DEF);
+	EFX_SET_OWORD_FIELD(sdctl, FRF_AB_XX_HIDRVB, FFE_AB_XX_SD_CTL_DRV_DEF);
+	EFX_SET_OWORD_FIELD(sdctl, FRF_AB_XX_LODRVB, FFE_AB_XX_SD_CTL_DRV_DEF);
+	EFX_SET_OWORD_FIELD(sdctl, FRF_AB_XX_HIDRVA, FFE_AB_XX_SD_CTL_DRV_DEF);
+	EFX_SET_OWORD_FIELD(sdctl, FRF_AB_XX_LODRVA, FFE_AB_XX_SD_CTL_DRV_DEF);
+	efx_writeo(efx, &sdctl, FR_AB_XX_SD_CTL);
 
 	EFX_POPULATE_OWORD_8(txdrv,
-			     XX_DEQD, XX_TXDRV_DEQ_DEFAULT,
-			     XX_DEQC, XX_TXDRV_DEQ_DEFAULT,
-			     XX_DEQB, XX_TXDRV_DEQ_DEFAULT,
-			     XX_DEQA, XX_TXDRV_DEQ_DEFAULT,
-			     XX_DTXD, XX_TXDRV_DTX_DEFAULT,
-			     XX_DTXC, XX_TXDRV_DTX_DEFAULT,
-			     XX_DTXB, XX_TXDRV_DTX_DEFAULT,
-			     XX_DTXA, XX_TXDRV_DTX_DEFAULT);
-	falcon_write(efx, &txdrv, XX_TXDRV_CTL_REG);
+			     FRF_AB_XX_DEQD, FFE_AB_XX_TXDRV_DEQ_DEF,
+			     FRF_AB_XX_DEQC, FFE_AB_XX_TXDRV_DEQ_DEF,
+			     FRF_AB_XX_DEQB, FFE_AB_XX_TXDRV_DEQ_DEF,
+			     FRF_AB_XX_DEQA, FFE_AB_XX_TXDRV_DEQ_DEF,
+			     FRF_AB_XX_DTXD, FFE_AB_XX_TXDRV_DTX_DEF,
+			     FRF_AB_XX_DTXC, FFE_AB_XX_TXDRV_DTX_DEF,
+			     FRF_AB_XX_DTXB, FFE_AB_XX_TXDRV_DTX_DEF,
+			     FRF_AB_XX_DTXA, FFE_AB_XX_TXDRV_DTX_DEF);
+	efx_writeo(efx, &txdrv, FR_AB_XX_TXDRV_CTL);
 }
 
 int falcon_reset_xaui(struct efx_nic *efx)
 {
+	struct falcon_nic_data *nic_data = efx->nic_data;
 	efx_oword_t reg;
 	int count;
 
+	/* Don't fetch MAC statistics over an XMAC reset */
+	WARN_ON(nic_data->stats_disable_count == 0);
+
 	/* Start reset sequence */
-	EFX_POPULATE_DWORD_1(reg, XX_RST_XX_EN, 1);
-	falcon_write(efx, &reg, XX_PWR_RST_REG);
+	EFX_POPULATE_OWORD_1(reg, FRF_AB_XX_RST_XX_EN, 1);
+	efx_writeo(efx, &reg, FR_AB_XX_PWR_RST);
 
 	/* Wait up to 10 ms for completion, then reinitialise */
 	for (count = 0; count < 1000; count++) {
-		falcon_read(efx, &reg, XX_PWR_RST_REG);
-		if (EFX_OWORD_FIELD(reg, XX_RST_XX_EN) == 0 &&
-		    EFX_OWORD_FIELD(reg, XX_SD_RST_ACT) == 0) {
+		efx_reado(efx, &reg, FR_AB_XX_PWR_RST);
+		if (EFX_OWORD_FIELD(reg, FRF_AB_XX_RST_XX_EN) == 0 &&
+		    EFX_OWORD_FIELD(reg, FRF_AB_XX_SD_RST_ACT) == 0) {
 			falcon_setup_xaui(efx);
 			return 0;
 		}
 		udelay(10);
 	}
-	EFX_ERR(efx, "timed out waiting for XAUI/XGXS reset\n");
+	netif_err(efx, hw, efx->net_dev,
+		  "timed out waiting for XAUI/XGXS reset\n");
 	return -ETIMEDOUT;
 }
 
-static void falcon_mask_status_intr(struct efx_nic *efx, bool enable)
+static void falcon_ack_status_intr(struct efx_nic *efx)
 {
+	struct falcon_nic_data *nic_data = efx->nic_data;
 	efx_oword_t reg;
 
-	if ((falcon_rev(efx) != FALCON_REV_B0) || LOOPBACK_INTERNAL(efx))
+	if ((efx_nic_rev(efx) != EFX_REV_FALCON_B0) || LOOPBACK_INTERNAL(efx))
 		return;
 
-	/* We expect xgmii faults if the wireside link is up */
-	if (!EFX_WORKAROUND_5147(efx) || !efx->link_up)
+	/* We expect xgmii faults if the wireside link is down */
+	if (!EFX_WORKAROUND_5147(efx) || !efx->link_state.up)
 		return;
 
 	/* We can only use this interrupt to signal the negative edge of
 	 * xaui_align [we have to poll the positive edge]. */
-	if (!efx->mac_up)
+	if (nic_data->xmac_poll_required)
 		return;
 
-	/* Flush the ISR */
-	if (enable)
-		falcon_read(efx, &reg, XM_MGT_INT_REG_B0);
-
-	EFX_POPULATE_OWORD_2(reg,
-			     XM_MSK_RMTFLT, !enable,
-			     XM_MSK_LCLFLT, !enable);
-	falcon_write(efx, &reg, XM_MGT_INT_MSK_REG_B0);
+	efx_reado(efx, &reg, FR_AB_XM_MGT_INT_MSK);
 }
 
-/* Get status of XAUI link */
-bool falcon_xaui_link_ok(struct efx_nic *efx)
+static bool falcon_xgxs_link_ok(struct efx_nic *efx)
 {
 	efx_oword_t reg;
 	bool align_done, link_ok = false;
 	int sync_status;
 
-	if (LOOPBACK_INTERNAL(efx))
-		return true;
+	/* Read link status */
+	efx_reado(efx, &reg, FR_AB_XX_CORE_STAT);
 
-	/* Read link status */
-	falcon_read(efx, &reg, XX_CORE_STAT_REG);
-
-	align_done = EFX_OWORD_FIELD(reg, XX_ALIGN_DONE);
-	sync_status = EFX_OWORD_FIELD(reg, XX_SYNC_STAT);
-	if (align_done && (sync_status == XX_SYNC_STAT_DECODE_SYNCED))
+	align_done = EFX_OWORD_FIELD(reg, FRF_AB_XX_ALIGN_DONE);
+	sync_status = EFX_OWORD_FIELD(reg, FRF_AB_XX_SYNC_STAT);
+	if (align_done && (sync_status == FFE_AB_XX_STAT_ALL_LANES))
 		link_ok = true;
 
 	/* Clear link status ready for next read */
-	EFX_SET_OWORD_FIELD(reg, XX_COMMA_DET, XX_COMMA_DET_RESET);
-	EFX_SET_OWORD_FIELD(reg, XX_CHARERR, XX_CHARERR_RESET);
-	EFX_SET_OWORD_FIELD(reg, XX_DISPERR, XX_DISPERR_RESET);
-	falcon_write(efx, &reg, XX_CORE_STAT_REG);
-
-	/* If the link is up, then check the phy side of the xaui link */
-	if (efx->link_up && link_ok)
-		if (efx->phy_op->mmds & (1 << MDIO_MMD_PHYXS))
-			link_ok = efx_mdio_phyxgxs_lane_sync(efx);
+	EFX_SET_OWORD_FIELD(reg, FRF_AB_XX_COMMA_DET, FFE_AB_XX_STAT_ALL_LANES);
+	EFX_SET_OWORD_FIELD(reg, FRF_AB_XX_CHAR_ERR, FFE_AB_XX_STAT_ALL_LANES);
+	EFX_SET_OWORD_FIELD(reg, FRF_AB_XX_DISPERR, FFE_AB_XX_STAT_ALL_LANES);
+	efx_writeo(efx, &reg, FR_AB_XX_CORE_STAT);
 
 	return link_ok;
 }
 
+static bool falcon_xmac_link_ok(struct efx_nic *efx)
+{
+	/*
+	 * Check MAC's XGXS link status except when using XGMII loopback
+	 * which bypasses the XGXS block.
+	 * If possible, check PHY's XGXS link status except when using
+	 * MAC loopback.
+	 */
+	return (efx->loopback_mode == LOOPBACK_XGMII ||
+		falcon_xgxs_link_ok(efx)) &&
+		(!(efx->mdio.mmds & (1 << MDIO_MMD_PHYXS)) ||
+		 LOOPBACK_INTERNAL(efx) || 
+		 efx_mdio_phyxgxs_lane_sync(efx));
+}
+
 static void falcon_reconfigure_xmac_core(struct efx_nic *efx)
 {
 	unsigned int max_frame_len;
 	efx_oword_t reg;
-	bool rx_fc = !!(efx->link_fc & EFX_FC_RX);
+	bool rx_fc = !!(efx->link_state.fc & EFX_FC_RX);
+	bool tx_fc = !!(efx->link_state.fc & EFX_FC_TX);
 
 	/* Configure MAC  - cut-thru mode is hard wired on */
-	EFX_POPULATE_DWORD_3(reg,
-			     XM_RX_JUMBO_MODE, 1,
-			     XM_TX_STAT_EN, 1,
-			     XM_RX_STAT_EN, 1);
-	falcon_write(efx, &reg, XM_GLB_CFG_REG);
+	EFX_POPULATE_OWORD_3(reg,
+			     FRF_AB_XM_RX_JUMBO_MODE, 1,
+			     FRF_AB_XM_TX_STAT_EN, 1,
+			     FRF_AB_XM_RX_STAT_EN, 1);
+	efx_writeo(efx, &reg, FR_AB_XM_GLB_CFG);
 
 	/* Configure TX */
-	EFX_POPULATE_DWORD_6(reg,
-			     XM_TXEN, 1,
-			     XM_TX_PRMBL, 1,
-			     XM_AUTO_PAD, 1,
-			     XM_TXCRC, 1,
-			     XM_FCNTL, 1,
-			     XM_IPG, 0x3);
-	falcon_write(efx, &reg, XM_TX_CFG_REG);
+	EFX_POPULATE_OWORD_6(reg,
+			     FRF_AB_XM_TXEN, 1,
+			     FRF_AB_XM_TX_PRMBL, 1,
+			     FRF_AB_XM_AUTO_PAD, 1,
+			     FRF_AB_XM_TXCRC, 1,
+			     FRF_AB_XM_FCNTL, tx_fc,
+			     FRF_AB_XM_IPG, 0x3);
+	efx_writeo(efx, &reg, FR_AB_XM_TX_CFG);
 
 	/* Configure RX */
-	EFX_POPULATE_DWORD_5(reg,
-			     XM_RXEN, 1,
-			     XM_AUTO_DEPAD, 0,
-			     XM_ACPT_ALL_MCAST, 1,
-			     XM_ACPT_ALL_UCAST, efx->promiscuous,
-			     XM_PASS_CRC_ERR, 1);
-	falcon_write(efx, &reg, XM_RX_CFG_REG);
+	EFX_POPULATE_OWORD_5(reg,
+			     FRF_AB_XM_RXEN, 1,
+			     FRF_AB_XM_AUTO_DEPAD, 0,
+			     FRF_AB_XM_ACPT_ALL_MCAST, 1,
+			     FRF_AB_XM_ACPT_ALL_UCAST, efx->promiscuous,
+			     FRF_AB_XM_PASS_CRC_ERR, 1);
+	efx_writeo(efx, &reg, FR_AB_XM_RX_CFG);
 
 	/* Set frame length */
 	max_frame_len = EFX_MAX_FRAME_LEN(efx->net_dev->mtu);
-	EFX_POPULATE_DWORD_1(reg, XM_MAX_RX_FRM_SIZE, max_frame_len);
-	falcon_write(efx, &reg, XM_RX_PARAM_REG);
-	EFX_POPULATE_DWORD_2(reg,
-			     XM_MAX_TX_FRM_SIZE, max_frame_len,
-			     XM_TX_JUMBO_MODE, 1);
-	falcon_write(efx, &reg, XM_TX_PARAM_REG);
+	EFX_POPULATE_OWORD_1(reg, FRF_AB_XM_MAX_RX_FRM_SIZE, max_frame_len);
+	efx_writeo(efx, &reg, FR_AB_XM_RX_PARAM);
+	EFX_POPULATE_OWORD_2(reg,
+			     FRF_AB_XM_MAX_TX_FRM_SIZE, max_frame_len,
+			     FRF_AB_XM_TX_JUMBO_MODE, 1);
+	efx_writeo(efx, &reg, FR_AB_XM_TX_PARAM);
 
-	EFX_POPULATE_DWORD_2(reg,
-			     XM_PAUSE_TIME, 0xfffe, /* MAX PAUSE TIME */
-			     XM_DIS_FCNTL, !rx_fc);
-	falcon_write(efx, &reg, XM_FC_REG);
+	EFX_POPULATE_OWORD_2(reg,
+			     FRF_AB_XM_PAUSE_TIME, 0xfffe, /* MAX PAUSE TIME */
+			     FRF_AB_XM_DIS_FCNTL, !rx_fc);
+	efx_writeo(efx, &reg, FR_AB_XM_FC);
 
 	/* Set MAC address */
-	EFX_POPULATE_DWORD_4(reg,
-			     XM_ADR_0, efx->net_dev->dev_addr[0],
-			     XM_ADR_1, efx->net_dev->dev_addr[1],
-			     XM_ADR_2, efx->net_dev->dev_addr[2],
-			     XM_ADR_3, efx->net_dev->dev_addr[3]);
-	falcon_write(efx, &reg, XM_ADR_LO_REG);
-	EFX_POPULATE_DWORD_2(reg,
-			     XM_ADR_4, efx->net_dev->dev_addr[4],
-			     XM_ADR_5, efx->net_dev->dev_addr[5]);
-	falcon_write(efx, &reg, XM_ADR_HI_REG);
+	memcpy(&reg, &efx->net_dev->dev_addr[0], 4);
+	efx_writeo(efx, &reg, FR_AB_XM_ADR_LO);
+	memcpy(&reg, &efx->net_dev->dev_addr[4], 2);
+	efx_writeo(efx, &reg, FR_AB_XM_ADR_HI);
 }
 
 static void falcon_reconfigure_xgxs_core(struct efx_nic *efx)
@@ -212,12 +209,13 @@ static void falcon_reconfigure_xgxs_core
 		bool old_xgmii_loopback, old_xgxs_loopback, old_xaui_loopback;
 		bool reset_xgxs;
 
-		falcon_read(efx, &reg, XX_CORE_STAT_REG);
-		old_xgxs_loopback = EFX_OWORD_FIELD(reg, XX_XGXS_LB_EN);
-		old_xgmii_loopback = EFX_OWORD_FIELD(reg, XX_XGMII_LB_EN);
+		efx_reado(efx, &reg, FR_AB_XX_CORE_STAT);
+		old_xgxs_loopback = EFX_OWORD_FIELD(reg, FRF_AB_XX_XGXS_LB_EN);
+		old_xgmii_loopback =
+			EFX_OWORD_FIELD(reg, FRF_AB_XX_XGMII_LB_EN);
 
-		falcon_read(efx, &reg, XX_SD_CTL_REG);
-		old_xaui_loopback = EFX_OWORD_FIELD(reg, XX_LPBKA);
+		efx_reado(efx, &reg, FR_AB_XX_SD_CTL);
+		old_xaui_loopback = EFX_OWORD_FIELD(reg, FRF_AB_XX_LPBKA);
 
 		/* The PHY driver may have turned XAUI off */
 		reset_xgxs = ((xgxs_loopback != old_xgxs_loopback) ||
@@ -228,65 +226,72 @@ static void falcon_reconfigure_xgxs_core
 			falcon_reset_xaui(efx);
 	}
 
-	falcon_read(efx, &reg, XX_CORE_STAT_REG);
-	EFX_SET_OWORD_FIELD(reg, XX_FORCE_SIG,
+	efx_reado(efx, &reg, FR_AB_XX_CORE_STAT);
+	EFX_SET_OWORD_FIELD(reg, FRF_AB_XX_FORCE_SIG,
 			    (xgxs_loopback || xaui_loopback) ?
-			    XX_FORCE_SIG_DECODE_FORCED : 0);
-	EFX_SET_OWORD_FIELD(reg, XX_XGXS_LB_EN, xgxs_loopback);
-	EFX_SET_OWORD_FIELD(reg, XX_XGMII_LB_EN, xgmii_loopback);
-	falcon_write(efx, &reg, XX_CORE_STAT_REG);
+			    FFE_AB_XX_FORCE_SIG_ALL_LANES : 0);
+	EFX_SET_OWORD_FIELD(reg, FRF_AB_XX_XGXS_LB_EN, xgxs_loopback);
+	EFX_SET_OWORD_FIELD(reg, FRF_AB_XX_XGMII_LB_EN, xgmii_loopback);
+	efx_writeo(efx, &reg, FR_AB_XX_CORE_STAT);
 
-	falcon_read(efx, &reg, XX_SD_CTL_REG);
-	EFX_SET_OWORD_FIELD(reg, XX_LPBKD, xaui_loopback);
-	EFX_SET_OWORD_FIELD(reg, XX_LPBKC, xaui_loopback);
-	EFX_SET_OWORD_FIELD(reg, XX_LPBKB, xaui_loopback);
-	EFX_SET_OWORD_FIELD(reg, XX_LPBKA, xaui_loopback);
-	falcon_write(efx, &reg, XX_SD_CTL_REG);
+	efx_reado(efx, &reg, FR_AB_XX_SD_CTL);
+	EFX_SET_OWORD_FIELD(reg, FRF_AB_XX_LPBKD, xaui_loopback);
+	EFX_SET_OWORD_FIELD(reg, FRF_AB_XX_LPBKC, xaui_loopback);
+	EFX_SET_OWORD_FIELD(reg, FRF_AB_XX_LPBKB, xaui_loopback);
+	EFX_SET_OWORD_FIELD(reg, FRF_AB_XX_LPBKA, xaui_loopback);
+	efx_writeo(efx, &reg, FR_AB_XX_SD_CTL);
 }
 
 
-/* Try and bring the Falcon side of the Falcon-Phy XAUI link fails
- * to come back up. Bash it until it comes back up */
-static void falcon_check_xaui_link_up(struct efx_nic *efx, int tries)
+/* Try to bring up the Falcon side of the Falcon-Phy XAUI link */
+static bool falcon_xmac_link_ok_retry(struct efx_nic *efx, int tries)
 {
-	efx->mac_up = falcon_xaui_link_ok(efx);
+	bool mac_up = falcon_xmac_link_ok(efx);
 
-	if ((efx->loopback_mode == LOOPBACK_NETWORK) ||
+	if (LOOPBACK_MASK(efx) & LOOPBACKS_EXTERNAL(efx) & LOOPBACKS_WS ||
 	    efx_phy_mode_disabled(efx->phy_mode))
 		/* XAUI link is expected to be down */
-		return;
+		return mac_up;
 
-	while (!efx->mac_up && tries) {
-		EFX_LOG(efx, "bashing xaui\n");
+	falcon_stop_nic_stats(efx);
+
+	while (!mac_up && tries) {
+		netif_dbg(efx, hw, efx->net_dev, "bashing xaui\n");
 		falcon_reset_xaui(efx);
 		udelay(200);
 
-		efx->mac_up = falcon_xaui_link_ok(efx);
+		mac_up = falcon_xmac_link_ok(efx);
 		--tries;
 	}
+
+	falcon_start_nic_stats(efx);
+
+	return mac_up;
 }
 
-static void falcon_reconfigure_xmac(struct efx_nic *efx)
+bool falcon_xmac_check_fault(struct efx_nic *efx)
 {
-	falcon_mask_status_intr(efx, false);
+	return !falcon_xmac_link_ok_retry(efx, 5);
+}
+
+int falcon_reconfigure_xmac(struct efx_nic *efx)
+{
+	struct falcon_nic_data *nic_data = efx->nic_data;
 
 	falcon_reconfigure_xgxs_core(efx);
 	falcon_reconfigure_xmac_core(efx);
 
 	falcon_reconfigure_mac_wrapper(efx);
 
-	falcon_check_xaui_link_up(efx, 5);
-	falcon_mask_status_intr(efx, true);
+	nic_data->xmac_poll_required = !falcon_xmac_link_ok_retry(efx, 5);
+	falcon_ack_status_intr(efx);
+
+	return 0;
 }
 
-static void falcon_update_stats_xmac(struct efx_nic *efx)
+void falcon_update_stats_xmac(struct efx_nic *efx)
 {
 	struct efx_mac_stats *mac_stats = &efx->mac_stats;
-	int rc;
-
-	rc = falcon_dma_stats(efx, XgDmaDone_offset);
-	if (rc)
-		return;
 
 	/* Update MAC stats from DMAed values */
 	FALCON_STAT(efx, XgRxOctets, rx_bytes);
@@ -344,35 +349,14 @@ static void falcon_update_stats_xmac(str
 		 mac_stats->rx_control * 64);
 }
 
-static void falcon_xmac_irq(struct efx_nic *efx)
+void falcon_poll_xmac(struct efx_nic *efx)
 {
-	/* The XGMII link has a transient fault, which indicates either:
-	 *   - there's a transient xgmii fault
-	 *   - falcon's end of the xaui link may need a kick
-	 *   - the wire-side link may have gone down, but the lasi/poll()
-	 *     hasn't noticed yet.
-	 *
-	 * We only want to even bother polling XAUI if we're confident it's
-	 * not (1) or (3). In both cases, the only reliable way to spot this
-	 * is to wait a bit. We do this here by forcing the mac link state
-	 * to down, and waiting for the mac poll to come round and check
-	 */
-	efx->mac_up = false;
-}
+	struct falcon_nic_data *nic_data = efx->nic_data;
 
-static void falcon_poll_xmac(struct efx_nic *efx)
-{
-	if (!EFX_WORKAROUND_5147(efx) || !efx->link_up || efx->mac_up)
+	if (!EFX_WORKAROUND_5147(efx) || !efx->link_state.up ||
+	    !nic_data->xmac_poll_required)
 		return;
 
-	falcon_mask_status_intr(efx, false);
-	falcon_check_xaui_link_up(efx, 1);
-	falcon_mask_status_intr(efx, true);
+	nic_data->xmac_poll_required = !falcon_xmac_link_ok_retry(efx, 1);
+	falcon_ack_status_intr(efx);
 }
-
-struct efx_mac_operations falcon_xmac_operations = {
-	.reconfigure	= falcon_reconfigure_xmac,
-	.update_stats	= falcon_update_stats_xmac,
-	.irq		= falcon_xmac_irq,
-	.poll		= falcon_poll_xmac,
-};
diff -r 9566a4a50a43 drivers/net/sfc/filter.c
--- /dev/null
+++ b/drivers/net/sfc/filter.c
@@ -0,0 +1,1317 @@
+/****************************************************************************
+ * Driver for Solarflare Solarstorm network controllers and boards
+ * Copyright 2005-2011 Solarflare Communications Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 as published
+ * by the Free Software Foundation, incorporated herein by reference.
+ */
+
+#include <linux/in.h>
+#include <net/ip.h>
+#include "efx.h"
+#include "filter.h"
+#include "io.h"
+#include "nic.h"
+#include "regs.h"
+
+/* "Fudge factors" - difference between programmed value and actual depth.
+ * Due to pipelined implementation we need to program H/W with a value that
+ * is larger than the hop limit we want.
+ */
+#define FILTER_CTL_SRCH_FUDGE_WILD 3
+#define FILTER_CTL_SRCH_FUDGE_FULL 1
+
+/* Hard maximum hop limit.  Hardware will time-out beyond 200-something.
+ * We also need to avoid infinite loops in efx_filter_search() when the
+ * table is full.
+ */
+#define FILTER_CTL_SRCH_MAX 200
+
+/* Don't try very hard to find space for performance hints, as this is
+ * counter-productive. */
+#define FILTER_CTL_SRCH_HINT_MAX 5
+
+enum efx_filter_table_id {
+	EFX_FILTER_TABLE_RX_IP = 0,
+	EFX_FILTER_TABLE_RX_MAC,
+	EFX_FILTER_TABLE_RX_DEF,
+	EFX_FILTER_TABLE_TX_IP,
+	EFX_FILTER_TABLE_TX_MAC,
+	EFX_FILTER_TABLE_COUNT,
+};
+
+enum efx_filter_index {
+	EFX_FILTER_INDEX_UC_DEF,
+	EFX_FILTER_INDEX_MC_DEF,
+	EFX_FILTER_SIZE_RX_DEF,
+};
+
+struct efx_filter_table {
+	enum efx_filter_table_id id;
+	u32		offset;		/* address of table relative to BAR */
+	unsigned	size;		/* number of entries */
+	unsigned	step;		/* step between entries */
+	unsigned	used;		/* number currently used */
+	unsigned long	*used_bitmap;
+	struct efx_filter_spec *spec;
+	unsigned	search_depth[EFX_FILTER_TYPE_COUNT];
+};
+
+struct efx_filter_state {
+	spinlock_t 	lock;
+	struct efx_filter_table table[EFX_FILTER_TABLE_COUNT];
+#ifdef CONFIG_RFS_ACCEL
+	u32		*rps_flow_id;
+	unsigned	rps_expire_index;
+#endif
+};
+
+/* The filter hash function is LFSR polynomial x^16 + x^3 + 1 of a 32-bit
+ * key derived from the n-tuple.  The initial LFSR state is 0xffff. */
+static u16 efx_filter_hash(u32 key)
+{
+	u16 tmp;
+
+	/* First 16 rounds */
+	tmp = 0x1fff ^ key >> 16;
+	tmp = tmp ^ tmp >> 3 ^ tmp >> 6;
+	tmp = tmp ^ tmp >> 9;
+	/* Last 16 rounds */
+	tmp = tmp ^ tmp << 13 ^ key;
+	tmp = tmp ^ tmp >> 3 ^ tmp >> 6;
+	return tmp ^ tmp >> 9;
+}
+
+/* To allow for hash collisions, filter search continues at these
+ * increments from the first possible entry selected by the hash. */
+static u16 efx_filter_increment(u32 key)
+{
+	return key * 2 - 1;
+}
+
+static enum efx_filter_table_id
+efx_filter_spec_table_id(const struct efx_filter_spec *spec)
+{
+	BUILD_BUG_ON(EFX_FILTER_TABLE_RX_IP != (EFX_FILTER_TCP_FULL >> 2));
+	BUILD_BUG_ON(EFX_FILTER_TABLE_RX_IP != (EFX_FILTER_TCP_WILD >> 2));
+	BUILD_BUG_ON(EFX_FILTER_TABLE_RX_IP != (EFX_FILTER_UDP_FULL >> 2));
+	BUILD_BUG_ON(EFX_FILTER_TABLE_RX_IP != (EFX_FILTER_UDP_WILD >> 2));
+	BUILD_BUG_ON(EFX_FILTER_TABLE_RX_MAC != (EFX_FILTER_MAC_FULL >> 2));
+	BUILD_BUG_ON(EFX_FILTER_TABLE_RX_MAC != (EFX_FILTER_MAC_WILD >> 2));
+	BUILD_BUG_ON(EFX_FILTER_TABLE_TX_IP != EFX_FILTER_TABLE_RX_IP + 3);
+	BUILD_BUG_ON(EFX_FILTER_TABLE_TX_MAC != EFX_FILTER_TABLE_RX_MAC + 3);
+	EFX_BUG_ON_PARANOID(spec->type == EFX_FILTER_UNSPEC);
+	return (spec->type >> 2) + ((spec->flags & EFX_FILTER_FLAG_TX) ? 3 : 0);
+}
+
+static struct efx_filter_table *
+efx_filter_spec_table(struct efx_filter_state *state,
+		      const struct efx_filter_spec *spec)
+{
+	if (spec->type == EFX_FILTER_UNSPEC)
+		return NULL;
+	else
+		return &state->table[efx_filter_spec_table_id(spec)];
+}
+
+static void efx_filter_table_reset_search_depth(struct efx_filter_table *table)
+{
+	memset(table->search_depth, 0, sizeof(table->search_depth));
+}
+
+static void efx_filter_push_rx_config(struct efx_nic *efx)
+{
+	struct efx_filter_state *state = efx->filter_state;
+	struct efx_filter_table *table;
+	efx_oword_t filter_ctl;
+
+	efx_reado(efx, &filter_ctl, FR_BZ_RX_FILTER_CTL);
+
+	table = &state->table[EFX_FILTER_TABLE_RX_IP];
+	EFX_SET_OWORD_FIELD(filter_ctl, FRF_BZ_TCP_FULL_SRCH_LIMIT,
+			    table->search_depth[EFX_FILTER_TCP_FULL] +
+			    FILTER_CTL_SRCH_FUDGE_FULL);
+	EFX_SET_OWORD_FIELD(filter_ctl, FRF_BZ_TCP_WILD_SRCH_LIMIT,
+			    table->search_depth[EFX_FILTER_TCP_WILD] +
+			    FILTER_CTL_SRCH_FUDGE_WILD);
+	EFX_SET_OWORD_FIELD(filter_ctl, FRF_BZ_UDP_FULL_SRCH_LIMIT,
+			    table->search_depth[EFX_FILTER_UDP_FULL] +
+			    FILTER_CTL_SRCH_FUDGE_FULL);
+	EFX_SET_OWORD_FIELD(filter_ctl, FRF_BZ_UDP_WILD_SRCH_LIMIT,
+			    table->search_depth[EFX_FILTER_UDP_WILD] +
+			    FILTER_CTL_SRCH_FUDGE_WILD);
+
+	table = &state->table[EFX_FILTER_TABLE_RX_MAC];
+	if (table->size) {
+		EFX_SET_OWORD_FIELD(
+			filter_ctl, FRF_CZ_ETHERNET_FULL_SEARCH_LIMIT, 
+			table->search_depth[EFX_FILTER_MAC_FULL] +
+			FILTER_CTL_SRCH_FUDGE_FULL);
+		EFX_SET_OWORD_FIELD(
+			filter_ctl, FRF_CZ_ETHERNET_WILDCARD_SEARCH_LIMIT,
+			table->search_depth[EFX_FILTER_MAC_WILD] +
+			FILTER_CTL_SRCH_FUDGE_WILD);
+	}
+
+	table = &state->table[EFX_FILTER_TABLE_RX_DEF];
+	if (table->size) {
+		EFX_SET_OWORD_FIELD(
+			filter_ctl, FRF_CZ_UNICAST_NOMATCH_Q_ID,
+			table->spec[EFX_FILTER_INDEX_UC_DEF].dmaq_id);
+		EFX_SET_OWORD_FIELD(
+			filter_ctl, FRF_CZ_UNICAST_NOMATCH_RSS_ENABLED,
+			!!(table->spec[EFX_FILTER_INDEX_UC_DEF].flags &
+			   EFX_FILTER_FLAG_RX_RSS));
+		EFX_SET_OWORD_FIELD(
+			filter_ctl, FRF_CZ_UNICAST_NOMATCH_IP_OVERRIDE,
+			!!(table->spec[EFX_FILTER_INDEX_UC_DEF].flags &
+			   EFX_FILTER_FLAG_RX_OVERRIDE_IP));
+		EFX_SET_OWORD_FIELD(
+			filter_ctl, FRF_CZ_MULTICAST_NOMATCH_Q_ID,
+			table->spec[EFX_FILTER_INDEX_MC_DEF].dmaq_id);
+		EFX_SET_OWORD_FIELD(
+			filter_ctl, FRF_CZ_MULTICAST_NOMATCH_RSS_ENABLED,
+			!!(table->spec[EFX_FILTER_INDEX_MC_DEF].flags &
+			   EFX_FILTER_FLAG_RX_RSS));
+		EFX_SET_OWORD_FIELD(
+			filter_ctl, FRF_CZ_MULTICAST_NOMATCH_IP_OVERRIDE,
+			!!(table->spec[EFX_FILTER_INDEX_MC_DEF].flags &
+			   EFX_FILTER_FLAG_RX_OVERRIDE_IP));
+
+		/* There is a single bit to enable RX scatter for all
+		 * unmatched packets.  Only set it if scatter is
+		 * enabled in both filter specs.
+		 */
+		EFX_SET_OWORD_FIELD(
+			filter_ctl, FRF_BZ_SCATTER_ENBL_NO_MATCH_Q,
+			!!(table->spec[EFX_FILTER_INDEX_UC_DEF].flags &
+			   table->spec[EFX_FILTER_INDEX_MC_DEF].flags &
+			   EFX_FILTER_FLAG_RX_SCATTER));
+	}
+
+	efx_writeo(efx, &filter_ctl, FR_BZ_RX_FILTER_CTL);
+}
+
+static void efx_filter_push_tx_limits(struct efx_nic *efx)
+{
+	struct efx_filter_state *state = efx->filter_state;
+	struct efx_filter_table *table;
+	efx_oword_t tx_cfg;
+
+	efx_reado(efx, &tx_cfg, FR_AZ_TX_CFG);
+
+	table = &state->table[EFX_FILTER_TABLE_TX_IP];
+	if (table->size) {
+		EFX_SET_OWORD_FIELD(
+			tx_cfg, FRF_CZ_TX_TCPIP_FILTER_FULL_SEARCH_RANGE,
+			table->search_depth[EFX_FILTER_TCP_FULL] +
+			FILTER_CTL_SRCH_FUDGE_FULL);
+		EFX_SET_OWORD_FIELD(
+			tx_cfg, FRF_CZ_TX_TCPIP_FILTER_WILD_SEARCH_RANGE,
+			table->search_depth[EFX_FILTER_TCP_WILD] +
+			FILTER_CTL_SRCH_FUDGE_WILD);
+		EFX_SET_OWORD_FIELD(
+			tx_cfg, FRF_CZ_TX_UDPIP_FILTER_FULL_SEARCH_RANGE,
+			table->search_depth[EFX_FILTER_UDP_FULL] +
+			FILTER_CTL_SRCH_FUDGE_FULL);
+		EFX_SET_OWORD_FIELD(
+			tx_cfg, FRF_CZ_TX_UDPIP_FILTER_WILD_SEARCH_RANGE,
+			table->search_depth[EFX_FILTER_UDP_WILD] +
+			FILTER_CTL_SRCH_FUDGE_WILD);
+	}
+
+	table = &state->table[EFX_FILTER_TABLE_TX_MAC];
+	if (table->size) {
+		EFX_SET_OWORD_FIELD(
+			tx_cfg, FRF_CZ_TX_ETH_FILTER_FULL_SEARCH_RANGE,
+			table->search_depth[EFX_FILTER_MAC_FULL] +
+			FILTER_CTL_SRCH_FUDGE_FULL);
+		EFX_SET_OWORD_FIELD(
+			tx_cfg, FRF_CZ_TX_ETH_FILTER_WILD_SEARCH_RANGE,
+			table->search_depth[EFX_FILTER_MAC_WILD] +
+			FILTER_CTL_SRCH_FUDGE_WILD);
+	}
+
+	efx_writeo(efx, &tx_cfg, FR_AZ_TX_CFG);
+}
+
+static inline void __efx_filter_set_ipv4(struct efx_filter_spec *spec,
+					 __be32 host1, __be16 port1,
+					 __be32 host2, __be16 port2)
+{
+	spec->data[0] = ntohl(host1) << 16 | ntohs(port1);
+	spec->data[1] = ntohs(port2) << 16 | ntohl(host1) >> 16;
+	spec->data[2] = ntohl(host2);
+}
+
+static inline void __efx_filter_get_ipv4(const struct efx_filter_spec *spec,
+					 __be32 *host1, __be16 *port1,
+					 __be32 *host2, __be16 *port2)
+{
+	*host1 = htonl(spec->data[0] >> 16 | spec->data[1] << 16);
+	*port1 = htons(spec->data[0]);
+	*host2 = htonl(spec->data[2]);
+	*port2 = htons(spec->data[1] >> 16);
+}
+
+/**
+ * efx_filter_set_ipv4_local - specify IPv4 host, transport protocol and port
+ * @spec: Specification to initialise
+ * @proto: Transport layer protocol number
+ * @host: Local host address (network byte order)
+ * @port: Local port (network byte order)
+ */
+int efx_filter_set_ipv4_local(struct efx_filter_spec *spec, u8 proto,
+			      __be32 host, __be16 port)
+{
+	__be32 host1;
+	__be16 port1;
+
+	EFX_BUG_ON_PARANOID(!(spec->flags &
+			      (EFX_FILTER_FLAG_RX | EFX_FILTER_FLAG_TX)));
+
+	/* This cannot currently be combined with other filtering */
+	if (spec->type != EFX_FILTER_UNSPEC)
+		return -EPROTONOSUPPORT;
+
+	if (port == 0)
+		return -EINVAL;
+
+	switch (proto) {
+	case IPPROTO_TCP:
+		spec->type = EFX_FILTER_TCP_WILD;
+		break;
+	case IPPROTO_UDP:
+		spec->type = EFX_FILTER_UDP_WILD;
+		break;
+	default:
+		return -EPROTONOSUPPORT;
+	}
+
+	/* Filter is constructed in terms of source and destination,
+	 * with the odd wrinkle that the ports are swapped in a UDP
+	 * wildcard filter.  We need to convert from local and remote
+	 * (= zero for wildcard) addresses.
+	 */
+	if (spec->flags & EFX_FILTER_FLAG_TX) {
+		host1 = host;
+		host = 0;
+		if (proto != IPPROTO_UDP) {
+			port1 = port;
+			port = 0;
+		} else {
+			port1 = 0;
+		}
+	} else {
+		host1 = 0;
+		if (proto != IPPROTO_UDP) {
+			port1 = 0;
+		} else {
+			port1 = port;
+			port = 0;
+		}
+	}
+
+	__efx_filter_set_ipv4(spec, host1, port1, host, port);
+	return 0;
+}
+
+int efx_filter_get_ipv4_local(const struct efx_filter_spec *spec,
+			      u8 *proto, __be32 *host, __be16 *port)
+{
+	__be32 host1;
+	__be16 port1;
+
+	switch (spec->type) {
+	case EFX_FILTER_TCP_WILD:
+		*proto = IPPROTO_TCP;
+		__efx_filter_get_ipv4(spec, &host1, &port1, host, port);
+		return 0;
+	case EFX_FILTER_UDP_WILD:
+		*proto = IPPROTO_UDP;
+		__efx_filter_get_ipv4(spec, &host1, port, host, &port1);
+		return 0;
+	default:
+		return -EINVAL;
+	}
+}
+
+/**
+ * efx_filter_set_ipv4_full - specify IPv4 hosts, transport protocol and ports
+ * @spec: Specification to initialise
+ * @proto: Transport layer protocol number
+ * @host: Local host address (network byte order)
+ * @port: Local port (network byte order)
+ * @rhost: Remote host address (network byte order)
+ * @rport: Remote port (network byte order)
+ */
+int efx_filter_set_ipv4_full(struct efx_filter_spec *spec, u8 proto,
+			     __be32 host, __be16 port,
+			     __be32 rhost, __be16 rport)
+{
+	__be32 host1;
+	__be16 port1;
+
+	EFX_BUG_ON_PARANOID(!(spec->flags &
+			      (EFX_FILTER_FLAG_RX | EFX_FILTER_FLAG_TX)));
+
+	/* This cannot currently be combined with other filtering */
+	if (spec->type != EFX_FILTER_UNSPEC)
+		return -EPROTONOSUPPORT;
+
+	if (port == 0 || rport == 0)
+		return -EINVAL;
+
+	switch (proto) {
+	case IPPROTO_TCP:
+		spec->type = EFX_FILTER_TCP_FULL;
+		break;
+	case IPPROTO_UDP:
+		spec->type = EFX_FILTER_UDP_FULL;
+		break;
+	default:
+		return -EPROTONOSUPPORT;
+	}
+
+	/* Filter is constructed in terms of source and destination.
+	 * We need to convert from local and remote addresses.
+	 */
+	if (spec->flags & EFX_FILTER_FLAG_TX) {
+		host1 = host;
+		port1 = port;
+		host = rhost;
+		port = rport;
+	} else {
+		host1 = rhost;
+		port1 = rport;
+	}
+
+	__efx_filter_set_ipv4(spec, host1, port1, host, port);
+	return 0;
+}
+
+int efx_filter_get_ipv4_full(const struct efx_filter_spec *spec,
+			     u8 *proto, __be32 *host, __be16 *port,
+			     __be32 *rhost, __be16 *rport)
+{
+	switch (spec->type) {
+	case EFX_FILTER_TCP_FULL:
+		*proto = IPPROTO_TCP;
+		break;
+	case EFX_FILTER_UDP_FULL:
+		*proto = IPPROTO_UDP;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	__efx_filter_get_ipv4(spec, rhost, rport, host, port);
+	return 0;
+}
+
+/**
+ * efx_filter_set_eth_local - specify local Ethernet address and optional VID
+ * @spec: Specification to initialise
+ * @vid: VLAN ID to match, or %EFX_FILTER_VID_UNSPEC
+ * @addr: Local Ethernet MAC address
+ */
+int efx_filter_set_eth_local(struct efx_filter_spec *spec,
+			     u16 vid, const u8 *addr)
+{
+	EFX_BUG_ON_PARANOID(!(spec->flags &
+			      (EFX_FILTER_FLAG_RX | EFX_FILTER_FLAG_TX)));
+
+	/* This cannot currently be combined with other filtering */
+	if (spec->type != EFX_FILTER_UNSPEC)
+		return -EPROTONOSUPPORT;
+
+	if (vid == EFX_FILTER_VID_UNSPEC) {
+		spec->type = EFX_FILTER_MAC_WILD;
+		spec->data[0] = 0;
+	} else {
+		spec->type = EFX_FILTER_MAC_FULL;
+		spec->data[0] = vid;
+	}
+
+	spec->data[1] = addr[2] << 24 | addr[3] << 16 | addr[4] << 8 | addr[5];
+	spec->data[2] = addr[0] << 8 | addr[1];
+	return 0;
+}
+
+/**
+ * efx_filter_set_uc_def - specify matching otherwise-unmatched unicast
+ * @spec: Specification to initialise
+ */
+int efx_filter_set_uc_def(struct efx_filter_spec *spec)
+{
+	EFX_BUG_ON_PARANOID(!(spec->flags &
+			      (EFX_FILTER_FLAG_RX | EFX_FILTER_FLAG_TX)));
+
+	if (spec->type != EFX_FILTER_UNSPEC)
+		return -EINVAL;
+
+	spec->type = EFX_FILTER_UC_DEF;
+	memset(spec->data, 0, sizeof(spec->data)); /* ensure equality */
+	return 0;
+}
+
+/**
+ * efx_filter_set_mc_def - specify matching otherwise-unmatched multicast
+ * @spec: Specification to initialise
+ */
+int efx_filter_set_mc_def(struct efx_filter_spec *spec)
+{
+	EFX_BUG_ON_PARANOID(!(spec->flags &
+			      (EFX_FILTER_FLAG_RX | EFX_FILTER_FLAG_TX)));
+
+	if (spec->type != EFX_FILTER_UNSPEC)
+		return -EINVAL;
+
+	spec->type = EFX_FILTER_MC_DEF;
+	memset(spec->data, 0, sizeof(spec->data)); /* ensure equality */
+	return 0;
+}
+
+static void efx_filter_reset_rx_def(struct efx_nic *efx, unsigned filter_idx)
+{
+	struct efx_filter_state *state = efx->filter_state;
+	struct efx_filter_table *table = &state->table[EFX_FILTER_TABLE_RX_DEF];
+	struct efx_filter_spec *spec = &table->spec[filter_idx];
+
+	/* If there's only one channel then disable RSS for non VF
+	 * traffic, thereby allowing VFs to use RSS when the PF can't.
+	 */
+	efx_filter_init_rx(spec, EFX_FILTER_PRI_MANUAL,
+			   efx->n_rss_channels > 1 ? EFX_FILTER_FLAG_RX_RSS : 0,
+			   0);
+	spec->type = EFX_FILTER_UC_DEF + filter_idx;
+	table->used_bitmap[0] |= 1 << filter_idx;
+}
+
+int efx_filter_get_eth_local(const struct efx_filter_spec *spec,
+			     u16 *vid, u8 *addr)
+{
+	switch (spec->type) {
+	case EFX_FILTER_MAC_WILD:
+		*vid = EFX_FILTER_VID_UNSPEC;
+		break;
+	case EFX_FILTER_MAC_FULL:
+		*vid = spec->data[0];
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	addr[0] = spec->data[2] >> 8;
+	addr[1] = spec->data[2];
+	addr[2] = spec->data[1] >> 24;
+	addr[3] = spec->data[1] >> 16;
+	addr[4] = spec->data[1] >> 8;
+	addr[5] = spec->data[1];
+	return 0;
+}
+
+/* Build a filter entry and return its n-tuple key. */
+static u32 efx_filter_build(efx_oword_t *filter, struct efx_filter_spec *spec)
+{
+	u32 data3;
+
+	switch (efx_filter_spec_table_id(spec)) {
+	case EFX_FILTER_TABLE_RX_IP: {
+		bool is_udp = (spec->type == EFX_FILTER_UDP_FULL ||
+			       spec->type == EFX_FILTER_UDP_WILD);
+		EFX_POPULATE_OWORD_7(
+			*filter,
+			FRF_BZ_RSS_EN,
+			!!(spec->flags & EFX_FILTER_FLAG_RX_RSS),
+			FRF_BZ_SCATTER_EN,
+			!!(spec->flags & EFX_FILTER_FLAG_RX_SCATTER),
+			FRF_BZ_TCP_UDP, is_udp,
+			FRF_BZ_RXQ_ID, spec->dmaq_id,
+			EFX_DWORD_2, spec->data[2],
+			EFX_DWORD_1, spec->data[1],
+			EFX_DWORD_0, spec->data[0]);
+		data3 = is_udp;
+		break;
+	}
+
+	case EFX_FILTER_TABLE_RX_DEF:
+		/* One filter spec per type */
+		BUILD_BUG_ON(EFX_FILTER_INDEX_UC_DEF != 0);
+		BUILD_BUG_ON(EFX_FILTER_INDEX_MC_DEF !=
+			     EFX_FILTER_MC_DEF - EFX_FILTER_UC_DEF);
+		return spec->type - EFX_FILTER_UC_DEF;
+
+	case EFX_FILTER_TABLE_RX_MAC: {
+		bool is_wild = spec->type == EFX_FILTER_MAC_WILD;
+		EFX_POPULATE_OWORD_8(
+			*filter,
+			FRF_CZ_RMFT_RSS_EN,
+			!!(spec->flags & EFX_FILTER_FLAG_RX_RSS),
+			FRF_CZ_RMFT_SCATTER_EN,
+			!!(spec->flags & EFX_FILTER_FLAG_RX_SCATTER),
+			FRF_CZ_RMFT_IP_OVERRIDE,
+			!!(spec->flags & EFX_FILTER_FLAG_RX_OVERRIDE_IP),
+			FRF_CZ_RMFT_RXQ_ID, spec->dmaq_id,
+			FRF_CZ_RMFT_WILDCARD_MATCH, is_wild,
+			FRF_CZ_RMFT_DEST_MAC_HI, spec->data[2],
+			FRF_CZ_RMFT_DEST_MAC_LO, spec->data[1],
+			FRF_CZ_RMFT_VLAN_ID, spec->data[0]);
+		data3 = is_wild;
+		break;
+	}
+
+	case EFX_FILTER_TABLE_TX_IP: {
+		bool is_udp = (spec->type == EFX_FILTER_UDP_FULL ||
+			       spec->type == EFX_FILTER_UDP_WILD);
+		EFX_POPULATE_OWORD_5(*filter,
+				     FRF_CZ_TIFT_TCP_UDP, is_udp,
+				     FRF_CZ_TIFT_TXQ_ID, spec->dmaq_id,
+				     EFX_DWORD_2, spec->data[2],
+				     EFX_DWORD_1, spec->data[1],
+				     EFX_DWORD_0, spec->data[0]);
+		data3 = is_udp | spec->dmaq_id << 1;
+		break;
+	}
+
+	case EFX_FILTER_TABLE_TX_MAC: {
+		bool is_wild = spec->type == EFX_FILTER_MAC_WILD;
+		EFX_POPULATE_OWORD_5(*filter,
+				     FRF_CZ_TMFT_TXQ_ID, spec->dmaq_id,
+				     FRF_CZ_TMFT_WILDCARD_MATCH, is_wild,
+				     FRF_CZ_TMFT_SRC_MAC_HI, spec->data[2],
+				     FRF_CZ_TMFT_SRC_MAC_LO, spec->data[1],
+				     FRF_CZ_TMFT_VLAN_ID, spec->data[0]);
+		data3 = is_wild | spec->dmaq_id << 1;
+		break;
+	}
+
+	default:
+		/* Needed if BUG() is not declared as noreturn */
+		data3 = 0;
+		BUG();
+	}
+
+	return spec->data[0] ^ spec->data[1] ^ spec->data[2] ^ data3;
+}
+
+static bool efx_filter_equal(const struct efx_filter_spec *left,
+			     const struct efx_filter_spec *right)
+{
+	if (left->type != right->type ||
+	    memcmp(left->data, right->data, sizeof(left->data)))
+		return false;
+
+	if (left->flags & EFX_FILTER_FLAG_TX &&
+	    left->dmaq_id != right->dmaq_id)
+		return false;
+
+	return true;
+}
+
+static int efx_filter_search(struct efx_filter_table *table,
+			     struct efx_filter_spec *spec, u32 key,
+			     bool for_insert, unsigned int *depth_required)
+{
+	unsigned hash, incr, filter_idx, depth, depth_max;
+
+	hash = efx_filter_hash(key);
+	incr = efx_filter_increment(key);
+
+	filter_idx = hash & (table->size - 1);
+	depth = 1;
+	depth_max = (for_insert ?
+		     (spec->priority <= EFX_FILTER_PRI_HINT ?
+		      FILTER_CTL_SRCH_HINT_MAX : FILTER_CTL_SRCH_MAX) :
+		     table->search_depth[spec->type]);
+
+	for (;;) {
+		/* Return success if entry is used and matches this spec
+		 * or entry is unused and we are trying to insert.
+		 */
+		if (test_bit(filter_idx, table->used_bitmap) ?
+		    efx_filter_equal(spec, &table->spec[filter_idx]) :
+		    for_insert) {
+			*depth_required = depth;
+			return filter_idx;
+		}
+
+		/* Return failure if we reached the maximum search depth */
+		if (depth == depth_max)
+			return for_insert ? -EBUSY : -ENOENT;
+
+		filter_idx = (filter_idx + incr) & (table->size - 1);
+		++depth;
+	}
+}
+
+/*
+ * Construct/deconstruct external filter IDs.  These must be ordered
+ * by matching priority, for RX NFC semantics.
+ *
+ * Each RX MAC filter entry has a flag for whether it can override an
+ * RX IP filter that also matches.  So we assign locations for MAC
+ * filters with overriding behaviour, then for IP filters, then for
+ * MAC filters without overriding behaviour.
+ */
+
+#define EFX_FILTER_MATCH_PRI_RX_MAC_OVERRIDE_IP	0
+#define EFX_FILTER_MATCH_PRI_RX_DEF_OVERRIDE_IP	1
+#define EFX_FILTER_MATCH_PRI_NORMAL_BASE	2
+
+#define EFX_FILTER_INDEX_WIDTH	13
+#define EFX_FILTER_INDEX_MASK	((1 << EFX_FILTER_INDEX_WIDTH) - 1)
+
+static inline u32 efx_filter_make_id(enum efx_filter_table_id table_id,
+				     unsigned int index, u8 flags)
+{
+	unsigned int match_pri = EFX_FILTER_MATCH_PRI_NORMAL_BASE + table_id;
+
+	if (flags & EFX_FILTER_FLAG_RX_OVERRIDE_IP) {
+		if (table_id == EFX_FILTER_TABLE_RX_MAC)
+			match_pri = EFX_FILTER_MATCH_PRI_RX_MAC_OVERRIDE_IP;
+		else if (table_id == EFX_FILTER_TABLE_RX_DEF)
+			match_pri = EFX_FILTER_MATCH_PRI_RX_DEF_OVERRIDE_IP;
+	}
+		
+	return match_pri << EFX_FILTER_INDEX_WIDTH | index;
+}
+
+static inline enum efx_filter_table_id efx_filter_id_table_id(u32 id)
+{
+	unsigned int match_pri = id >> EFX_FILTER_INDEX_WIDTH;
+
+	switch (match_pri) {
+	case EFX_FILTER_MATCH_PRI_RX_MAC_OVERRIDE_IP:
+		return EFX_FILTER_TABLE_RX_MAC;
+	case EFX_FILTER_MATCH_PRI_RX_DEF_OVERRIDE_IP:
+		return EFX_FILTER_TABLE_RX_DEF;
+	default:
+		return match_pri - EFX_FILTER_MATCH_PRI_NORMAL_BASE;
+	}
+}
+
+static inline unsigned int efx_filter_id_index(u32 id)
+{
+	return id & EFX_FILTER_INDEX_MASK;
+}
+
+static inline u8 efx_filter_id_flags(u32 id)
+{
+	unsigned int match_pri = id >> EFX_FILTER_INDEX_WIDTH;
+
+	if (match_pri < EFX_FILTER_MATCH_PRI_NORMAL_BASE)
+		return EFX_FILTER_FLAG_RX | EFX_FILTER_FLAG_RX_OVERRIDE_IP;
+	else if (match_pri <=
+		 EFX_FILTER_MATCH_PRI_NORMAL_BASE + EFX_FILTER_TABLE_RX_DEF)
+		return EFX_FILTER_FLAG_RX;
+	else
+		return EFX_FILTER_FLAG_TX;
+}
+
+u32 efx_filter_get_rx_id_limit(struct efx_nic *efx)
+{
+	struct efx_filter_state *state = efx->filter_state;
+	unsigned int table_id = EFX_FILTER_TABLE_RX_DEF;
+
+	do {
+		if (state->table[table_id].size != 0)
+			return ((EFX_FILTER_MATCH_PRI_NORMAL_BASE + table_id)
+				<< EFX_FILTER_INDEX_WIDTH) +
+				state->table[table_id].size;
+	} while (table_id--);
+
+	return 0;
+}
+
+/**
+ * efx_filter_insert_filter - add or replace a filter
+ * @efx: NIC in which to insert the filter
+ * @spec: Specification for the filter
+ * @replace: Flag for whether the specified filter may replace a filter
+ *	with an identical match expression and equal or lower priority
+ *
+ * On success, return the filter ID.
+ * On failure, return a negative error code.
+ */
+s32 efx_filter_insert_filter(struct efx_nic *efx, struct efx_filter_spec *spec,
+			     bool replace)
+{
+	struct efx_filter_state *state = efx->filter_state;
+	struct efx_filter_table *table = efx_filter_spec_table(state, spec);
+	struct efx_filter_spec *saved_spec;
+	efx_oword_t filter;
+	unsigned int filter_idx, depth;
+	u32 key;
+	int rc;
+
+	if (!table || table->size == 0)
+		return -EINVAL;
+
+	key = efx_filter_build(&filter, spec);
+
+	netif_vdbg(efx, hw, efx->net_dev,
+		   "%s: type %d search_depth=%d", __func__, spec->type,
+		   table->search_depth[spec->type]);
+
+	spin_lock_bh(&state->lock);
+
+	rc = efx_filter_search(table, spec, key, true, &depth);
+	if (rc < 0)
+		goto out;
+	filter_idx = rc;
+	BUG_ON(filter_idx >= table->size);
+	saved_spec = &table->spec[filter_idx];
+
+	if (test_bit(filter_idx, table->used_bitmap)) {
+		/* Should we replace the existing filter? */
+		if (!replace) {
+			rc = -EEXIST;
+			goto out;
+		}
+		if (spec->priority < saved_spec->priority) {
+			rc = -EPERM;
+			goto out;
+		}
+	} else {
+		__set_bit(filter_idx, table->used_bitmap);
+		++table->used;
+	}
+	*saved_spec = *spec;
+
+	if (table->id == EFX_FILTER_TABLE_RX_DEF) {
+		efx_filter_push_rx_config(efx);
+	} else {
+		if (table->search_depth[spec->type] < depth) {
+			table->search_depth[spec->type] = depth;
+			if (spec->flags & EFX_FILTER_FLAG_TX)
+				efx_filter_push_tx_limits(efx);
+			else
+				efx_filter_push_rx_config(efx);
+		}
+
+		efx_writeo(efx, &filter,
+			   table->offset + table->step * filter_idx);
+	}
+
+	netif_vdbg(efx, hw, efx->net_dev,
+		   "%s: filter type %d index %d rxq %u set",
+		   __func__, spec->type, filter_idx, spec->dmaq_id);
+	rc = efx_filter_make_id(table->id, filter_idx, spec->flags);
+
+out:
+	spin_unlock_bh(&state->lock);
+	return rc;
+}
+
+static void efx_filter_table_clear_entry(struct efx_nic *efx,
+					 struct efx_filter_table *table,
+					 unsigned int filter_idx)
+{
+	static efx_oword_t filter;
+
+	if (table->id == EFX_FILTER_TABLE_RX_DEF) {
+		/* RX default filters must always exist */
+		efx_filter_reset_rx_def(efx, filter_idx);
+		efx_filter_push_rx_config(efx);
+	} else if (test_bit(filter_idx, table->used_bitmap)) {
+		__clear_bit(filter_idx, table->used_bitmap);
+		--table->used;
+		memset(&table->spec[filter_idx], 0, sizeof(table->spec[0]));
+
+		efx_writeo(efx, &filter,
+			   table->offset + table->step * filter_idx);
+	}
+}
+
+/**
+ * efx_filter_remove_id_safe - remove a filter by ID, carefully
+ * @efx: NIC from which to remove the filter
+ * @priority: Priority of filter, as passed to @efx_filter_insert_filter
+ * @filter_id: ID of filter, as returned by @efx_filter_insert_filter
+ *
+ * This function will range-check @filter_id, so it is safe to call
+ * with a value passed from userland.
+ */
+int efx_filter_remove_id_safe(struct efx_nic *efx,
+			      enum efx_filter_priority priority,
+			      u32 filter_id)
+{
+	struct efx_filter_state *state = efx->filter_state;
+	enum efx_filter_table_id table_id;
+	struct efx_filter_table *table;
+	unsigned int filter_idx;
+	struct efx_filter_spec *spec;
+	u8 filter_flags;
+	int rc;
+
+	table_id = efx_filter_id_table_id(filter_id);
+	if ((unsigned int)table_id >= EFX_FILTER_TABLE_COUNT)
+		return -ENOENT;
+	table = &state->table[table_id];
+
+	filter_idx = efx_filter_id_index(filter_id);
+	if (filter_idx >= table->size)
+		return -ENOENT;
+	spec = &table->spec[filter_idx];
+
+	filter_flags = efx_filter_id_flags(filter_id);
+
+	spin_lock_bh(&state->lock);
+
+	if (test_bit(filter_idx, table->used_bitmap) &&
+	    spec->priority == priority &&
+	    !((spec->flags ^ filter_flags) & EFX_FILTER_FLAG_RX_OVERRIDE_IP)) {
+		efx_filter_table_clear_entry(efx, table, filter_idx);
+		if (table->used == 0)
+			efx_filter_table_reset_search_depth(table);
+		rc = 0;
+	} else {
+		rc = -ENOENT;
+	}
+
+	spin_unlock_bh(&state->lock);
+
+	return rc;
+}
+
+/**
+ * efx_filter_get_filter_safe - retrieve a filter by ID, carefully
+ * @efx: NIC from which to remove the filter
+ * @priority: Priority of filter, as passed to @efx_filter_insert_filter
+ * @filter_id: ID of filter, as returned by @efx_filter_insert_filter
+ * @spec: Buffer in which to store filter specification
+ *
+ * This function will range-check @filter_id, so it is safe to call
+ * with a value passed from userland.
+ */
+int efx_filter_get_filter_safe(struct efx_nic *efx,
+			       enum efx_filter_priority priority,
+			       u32 filter_id, struct efx_filter_spec *spec_buf)
+{
+	struct efx_filter_state *state = efx->filter_state;
+	enum efx_filter_table_id table_id;
+	struct efx_filter_table *table;
+	struct efx_filter_spec *spec;
+	unsigned int filter_idx;
+	u8 filter_flags;
+	int rc;
+
+	table_id = efx_filter_id_table_id(filter_id);
+	if ((unsigned int)table_id >= EFX_FILTER_TABLE_COUNT)
+		return -ENOENT;
+	table = &state->table[table_id];
+
+	filter_idx = efx_filter_id_index(filter_id);
+	if (filter_idx >= table->size)
+		return -ENOENT;
+	spec = &table->spec[filter_idx];
+
+	filter_flags = efx_filter_id_flags(filter_id);
+
+	spin_lock_bh(&state->lock);
+
+	if (test_bit(filter_idx, table->used_bitmap) &&
+	    spec->priority == priority &&
+	    !((spec->flags ^ filter_flags) & EFX_FILTER_FLAG_RX_OVERRIDE_IP)) {
+		*spec_buf = *spec;
+		rc = 0;
+	} else {
+		rc = -ENOENT;
+	}
+
+	spin_unlock_bh(&state->lock);
+
+	return rc;
+}
+
+/**
+ * efx_filter_remove_filter - remove a filter by specification
+ * @efx: NIC from which to remove the filter
+ * @spec: Specification for the filter
+ *
+ * On success, return zero.
+ * On failure, return a negative error code.
+ */
+int efx_filter_remove_filter(struct efx_nic *efx, struct efx_filter_spec *spec)
+{
+	struct efx_filter_state *state = efx->filter_state;
+	struct efx_filter_table *table = efx_filter_spec_table(state, spec);
+	struct efx_filter_spec *saved_spec;
+	efx_oword_t filter;
+	unsigned int filter_idx, depth;
+	u32 key;
+	int rc;
+
+	if (!table)
+		return -EINVAL;
+
+	key = efx_filter_build(&filter, spec);
+
+	spin_lock_bh(&state->lock);
+
+	rc = efx_filter_search(table, spec, key, false, &depth);
+	if (rc < 0)
+		goto out;
+	filter_idx = rc;
+	saved_spec = &table->spec[filter_idx];
+
+	if (spec->priority < saved_spec->priority) {
+		rc = -EPERM;
+		goto out;
+	}
+
+	efx_filter_table_clear_entry(efx, table, filter_idx);
+	if (table->used == 0)
+		efx_filter_table_reset_search_depth(table);
+	rc = 0;
+
+out:
+	spin_unlock_bh(&state->lock);
+	return rc;
+}
+
+static void efx_filter_table_clear(struct efx_nic *efx,
+				   enum efx_filter_table_id table_id,
+				   enum efx_filter_priority priority)
+{
+	struct efx_filter_state *state = efx->filter_state;
+	struct efx_filter_table *table = &state->table[table_id];
+	unsigned int filter_idx;
+
+	spin_lock_bh(&state->lock);
+
+	for (filter_idx = 0; filter_idx < table->size; ++filter_idx)
+		if (table->spec[filter_idx].priority <= priority)
+			efx_filter_table_clear_entry(efx, table, filter_idx);
+	if (table->used == 0)
+		efx_filter_table_reset_search_depth(table);
+
+	spin_unlock_bh(&state->lock);
+}
+
+/**
+ * efx_filter_clear_rx - remove RX filters by priority
+ * @efx: NIC from which to remove the filters
+ * @priority: Maximum priority to remove
+ */
+void efx_filter_clear_rx(struct efx_nic *efx, enum efx_filter_priority priority)
+{
+	efx_filter_table_clear(efx, EFX_FILTER_TABLE_RX_IP, priority);
+	efx_filter_table_clear(efx, EFX_FILTER_TABLE_RX_MAC, priority);
+}
+
+/**
+ * efx_filter_redirect_id - update the queue for an existing RX filter
+ * @efx: NIC in which to update the filter
+ * @filter_id: ID of filter, as returned by @efx_filter_insert_filter
+ * @rxq_i: Index of RX queue
+ */
+void efx_filter_redirect_id(struct efx_nic *efx, u32 filter_id, int rxq_i)
+{
+	struct efx_filter_state *state = efx->filter_state;
+	enum efx_filter_table_id table_id;
+	struct efx_filter_table *table;
+	unsigned int filter_i;
+	struct efx_filter_spec *spec;
+	efx_oword_t filter;
+
+	table_id = efx_filter_id_table_id(filter_id);
+	table = &state->table[table_id];
+	filter_i = efx_filter_id_index(filter_id);
+
+	spin_lock_bh(&state->lock);
+	
+	spec = &table->spec[filter_i];
+	spec->dmaq_id = rxq_i;
+	efx_filter_build(&filter, spec);
+	if (table_id == EFX_FILTER_TABLE_RX_DEF)
+		efx_filter_push_rx_config(efx);
+	else
+		efx_writeo(efx, &filter,
+			   table->offset + table->step * filter_i);
+
+	spin_unlock_bh(&state->lock);
+}
+
+u32 efx_filter_count_rx_used(struct efx_nic *efx,
+			     enum efx_filter_priority priority)
+{
+	struct efx_filter_state *state = efx->filter_state;
+	enum efx_filter_table_id table_id;
+	struct efx_filter_table *table;
+	unsigned int filter_idx;
+	u32 count = 0;
+
+	spin_lock_bh(&state->lock);
+
+	for (table_id = EFX_FILTER_TABLE_RX_IP;
+	     table_id <= EFX_FILTER_TABLE_RX_DEF;
+	     table_id++) {
+		table = &state->table[table_id];
+		for (filter_idx = 0; filter_idx < table->size; filter_idx++) {
+			if (test_bit(filter_idx, table->used_bitmap) &&
+			    table->spec[filter_idx].priority == priority)
+				++count;
+		}
+	}
+
+	spin_unlock_bh(&state->lock);
+
+	return count;
+}
+
+s32 efx_filter_get_rx_ids(struct efx_nic *efx,
+			  enum efx_filter_priority priority,
+			  u32 *buf, u32 size)
+{
+	struct efx_filter_state *state = efx->filter_state;
+	enum efx_filter_table_id table_id;
+	struct efx_filter_table *table;
+	unsigned int filter_idx;
+	s32 count = 0;
+
+	spin_lock_bh(&state->lock);
+
+	for (table_id = EFX_FILTER_TABLE_RX_IP;
+	     table_id <= EFX_FILTER_TABLE_RX_DEF;
+	     table_id++) {
+		table = &state->table[table_id];
+		for (filter_idx = 0; filter_idx < table->size; filter_idx++) {
+			if (test_bit(filter_idx, table->used_bitmap) &&
+			    table->spec[filter_idx].priority == priority) {
+				if (count == size) {
+					count = -EMSGSIZE;
+					goto out;
+				}
+				buf[count++] = efx_filter_make_id(
+					table_id, filter_idx,
+					table->spec[filter_idx].flags);
+			}
+		}
+	}
+out:
+	spin_unlock_bh(&state->lock);
+
+	return count;
+}
+
+/* Restore filter stater after reset */
+void efx_restore_filters(struct efx_nic *efx)
+{
+	struct efx_filter_state *state = efx->filter_state;
+	enum efx_filter_table_id table_id;
+	struct efx_filter_table *table;
+	efx_oword_t filter;
+	unsigned int filter_idx;
+
+	spin_lock_bh(&state->lock);
+
+	for (table_id = 0; table_id < EFX_FILTER_TABLE_COUNT; table_id++) {
+		table = &state->table[table_id];
+
+		/* Check whether this is a regular register table */
+		if (table->step == 0)
+			continue;
+
+		for (filter_idx = 0; filter_idx < table->size; filter_idx++) {
+			if (!test_bit(filter_idx, table->used_bitmap))
+				continue;
+			efx_filter_build(&filter, &table->spec[filter_idx]);
+			efx_writeo(efx, &filter,
+				   table->offset + table->step * filter_idx);
+		}
+	}
+
+	efx_filter_push_rx_config(efx);
+	efx_filter_push_tx_limits(efx);
+
+	spin_unlock_bh(&state->lock);
+}
+
+int efx_probe_filters(struct efx_nic *efx)
+{
+	struct efx_filter_state *state;
+	struct efx_filter_table *table;
+	unsigned table_id;
+
+	state = kzalloc(sizeof(*efx->filter_state), GFP_KERNEL);
+	if (!state)
+		return -ENOMEM;
+	efx->filter_state = state;
+
+	spin_lock_init(&state->lock);
+
+	if (efx_nic_rev(efx) >= EFX_REV_FALCON_B0) {
+#ifdef CONFIG_RFS_ACCEL
+		state->rps_flow_id = kcalloc(FR_BZ_RX_FILTER_TBL0_ROWS,
+					     sizeof(*state->rps_flow_id),
+					     GFP_KERNEL);
+		if (!state->rps_flow_id)
+			goto fail;
+#endif
+		table = &state->table[EFX_FILTER_TABLE_RX_IP];
+		table->id = EFX_FILTER_TABLE_RX_IP;
+		table->offset = FR_BZ_RX_FILTER_TBL0;
+		table->size = FR_BZ_RX_FILTER_TBL0_ROWS;
+		table->step = FR_BZ_RX_FILTER_TBL0_STEP;
+	}
+
+	if (efx_nic_rev(efx) >= EFX_REV_SIENA_A0) {
+		table = &state->table[EFX_FILTER_TABLE_RX_MAC];
+		table->id = EFX_FILTER_TABLE_RX_MAC;
+		table->offset = FR_CZ_RX_MAC_FILTER_TBL0;
+		table->size = FR_CZ_RX_MAC_FILTER_TBL0_ROWS;
+		table->step = FR_CZ_RX_MAC_FILTER_TBL0_STEP;
+
+		table = &state->table[EFX_FILTER_TABLE_RX_DEF];
+		table->id = EFX_FILTER_TABLE_RX_DEF;
+		table->size = EFX_FILTER_SIZE_RX_DEF;
+
+		table = &state->table[EFX_FILTER_TABLE_TX_IP];
+		table->id = EFX_FILTER_TABLE_TX_IP;
+		table->offset = FR_CZ_TX_FILTER_TBL0;
+		table->size = FR_CZ_TX_FILTER_TBL0_ROWS;
+		table->step = FR_CZ_TX_FILTER_TBL0_STEP;
+
+		table = &state->table[EFX_FILTER_TABLE_TX_MAC];
+		table->id = EFX_FILTER_TABLE_TX_MAC;
+		table->offset = FR_CZ_TX_MAC_FILTER_TBL0;
+		table->size = FR_CZ_TX_MAC_FILTER_TBL0_ROWS;
+		table->step = FR_CZ_TX_MAC_FILTER_TBL0_STEP;
+	}
+
+	for (table_id = 0; table_id < EFX_FILTER_TABLE_COUNT; table_id++) {
+		table = &state->table[table_id];
+		if (table->size == 0)
+			continue;
+		table->used_bitmap = kcalloc(BITS_TO_LONGS(table->size),
+					     sizeof(unsigned long),
+					     GFP_KERNEL);
+		if (!table->used_bitmap)
+			goto fail;
+		table->spec = vzalloc(table->size * sizeof(*table->spec));
+		if (!table->spec)
+			goto fail;
+	}
+
+	if (state->table[EFX_FILTER_TABLE_RX_DEF].size) {
+		/* RX default filters must always exist */
+		unsigned i;
+		for (i = 0; i < EFX_FILTER_SIZE_RX_DEF; i++)
+			efx_filter_reset_rx_def(efx, i);
+	}
+
+	efx_filter_push_rx_config(efx);
+
+	return 0;
+
+fail:
+	efx_remove_filters(efx);
+	return -ENOMEM;
+}
+
+void efx_remove_filters(struct efx_nic *efx)
+{
+	struct efx_filter_state *state = efx->filter_state;
+	enum efx_filter_table_id table_id;
+
+	for (table_id = 0; table_id < EFX_FILTER_TABLE_COUNT; table_id++) {
+		kfree(state->table[table_id].used_bitmap);
+		vfree(state->table[table_id].spec);
+	}
+#ifdef CONFIG_RFS_ACCEL
+	kfree(state->rps_flow_id);
+#endif
+	kfree(state);
+}
+
+#ifdef CONFIG_RFS_ACCEL
+
+int efx_filter_rfs(struct net_device *net_dev, const struct sk_buff *skb,
+		   u16 rxq_index, u32 flow_id)
+{
+	struct efx_nic *efx = netdev_priv(net_dev);
+	struct efx_channel *channel;
+	struct efx_filter_state *state = efx->filter_state;
+	struct efx_filter_spec spec;
+	const struct iphdr *ip;
+	const __be16 *ports;
+	int nhoff;
+	int rc;
+
+	nhoff = skb_network_offset(skb);
+
+	if (skb->protocol != htons(ETH_P_IP))
+		return -EPROTONOSUPPORT;
+
+	/* RFS must validate the IP header length before calling us */
+	EFX_BUG_ON_PARANOID(skb_headlen(skb) < nhoff + sizeof(*ip));
+	ip = (const struct iphdr *)(skb->data + nhoff);
+	if (ip->frag_off & htons(IP_MF | IP_OFFSET))
+		return -EPROTONOSUPPORT;
+	EFX_BUG_ON_PARANOID(skb_headlen(skb) < nhoff + 4 * ip->ihl + 4);
+	ports = (const __be16 *)(skb->data + nhoff + 4 * ip->ihl);
+
+	efx_filter_init_rx(&spec, EFX_FILTER_PRI_HINT, 0, rxq_index);
+	rc = efx_filter_set_ipv4_full(&spec, ip->protocol,
+				      ip->daddr, ports[1], ip->saddr, ports[0]);
+	if (rc)
+		return rc;
+
+	rc = efx_filter_insert_filter(efx, &spec, true);
+	if (rc < 0)
+		return rc;
+
+	/* Remember this so we can check whether to expire the filter later */
+	state->rps_flow_id[rc] = flow_id;
+	channel = efx_get_channel(efx, skb_get_rx_queue(skb));
+	++channel->rfs_filters_added;
+
+	netif_info(efx, rx_status, efx->net_dev,
+		   "steering %s %pI4:%u:%pI4:%u to queue %u [flow %u filter %d]\n",
+		   (ip->protocol == IPPROTO_TCP) ? "TCP" : "UDP",
+		   &ip->saddr, ntohs(ports[0]), &ip->daddr, ntohs(ports[1]),
+		   rxq_index, flow_id, rc);
+
+	return rc;
+}
+
+bool __efx_filter_rfs_expire(struct efx_nic *efx, unsigned quota)
+{
+	struct efx_filter_state *state = efx->filter_state;
+	struct efx_filter_table *table = &state->table[EFX_FILTER_TABLE_RX_IP];
+	unsigned mask = table->size - 1;
+	unsigned index;
+	unsigned stop;
+
+	if (!spin_trylock_bh(&state->lock))
+		return false;
+
+	index = state->rps_expire_index;
+	stop = (index + quota) & mask;
+
+	while (index != stop) {
+		if (test_bit(index, table->used_bitmap) &&
+		    table->spec[index].priority == EFX_FILTER_PRI_HINT &&
+		    rps_may_expire_flow(efx->net_dev,
+					table->spec[index].dmaq_id,
+					state->rps_flow_id[index], index)) {
+			netif_info(efx, rx_status, efx->net_dev,
+				   "expiring filter %d [flow %u]\n",
+				   index, state->rps_flow_id[index]);
+			efx_filter_table_clear_entry(efx, table, index);
+		}
+		index = (index + 1) & mask;
+	}
+
+	state->rps_expire_index = stop;
+	if (table->used == 0)
+		efx_filter_table_reset_search_depth(table);
+
+	spin_unlock_bh(&state->lock);
+	return true;
+}
+
+#endif /* CONFIG_RFS_ACCEL */
diff -r 9566a4a50a43 drivers/net/sfc/filter.h
--- /dev/null
+++ b/drivers/net/sfc/filter.h
@@ -0,0 +1,144 @@
+/****************************************************************************
+ * Driver for Solarflare Solarstorm network controllers and boards
+ * Copyright 2005-2010 Solarflare Communications Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 as published
+ * by the Free Software Foundation, incorporated herein by reference.
+ */
+
+#ifndef EFX_FILTER_H
+#define EFX_FILTER_H
+
+#include <linux/types.h>
+
+/**
+ * enum efx_filter_type - type of hardware filter
+ * @EFX_FILTER_TCP_FULL: Matching TCP/IPv4 4-tuple
+ * @EFX_FILTER_TCP_WILD: Matching TCP/IPv4 destination (host, port)
+ * @EFX_FILTER_UDP_FULL: Matching UDP/IPv4 4-tuple
+ * @EFX_FILTER_UDP_WILD: Matching UDP/IPv4 destination (host, port)
+ * @EFX_FILTER_MAC_FULL: Matching Ethernet destination MAC address, VID
+ * @EFX_FILTER_MAC_WILD: Matching Ethernet destination MAC address
+ * @EFX_FILTER_UC_DEF: Matching all otherwise unmatched unicast
+ * @EFX_FILTER_MC_DEF: Matching all otherwise unmatched multicast
+ * @EFX_FILTER_UNSPEC: Match type is unspecified
+ *
+ * Falcon NICs only support the TCP/IPv4 and UDP/IPv4 filter types.
+ */
+enum efx_filter_type {
+	EFX_FILTER_TCP_FULL = 0,
+	EFX_FILTER_TCP_WILD,
+	EFX_FILTER_UDP_FULL,
+	EFX_FILTER_UDP_WILD,
+	EFX_FILTER_MAC_FULL = 4,
+	EFX_FILTER_MAC_WILD,
+	EFX_FILTER_UC_DEF = 8,
+	EFX_FILTER_MC_DEF,
+	EFX_FILTER_TYPE_COUNT,		/* number of specific types */
+	EFX_FILTER_UNSPEC = 0xf,
+};
+
+/**
+ * enum efx_filter_priority - priority of a hardware filter specification
+ * @EFX_FILTER_PRI_HINT: Performance hint
+ * @EFX_FILTER_PRI_MANUAL: Manually configured filter
+ * @EFX_FILTER_PRI_REQUIRED: Required for correct behaviour (user-level
+ *	networking and SR-IOV)
+ */
+enum efx_filter_priority {
+	EFX_FILTER_PRI_HINT = 0,
+	EFX_FILTER_PRI_MANUAL,
+	EFX_FILTER_PRI_REQUIRED,
+};
+
+/**
+ * enum efx_filter_flags - flags for hardware filter specifications
+ * @EFX_FILTER_FLAG_RX_RSS: Use RSS to spread across multiple queues.
+ *	By default, matching packets will be delivered only to the
+ *	specified queue. If this flag is set, they will be delivered
+ *	to a range of queues offset from the specified queue number
+ *	according to the indirection table.
+ * @EFX_FILTER_FLAG_RX_SCATTER: Enable DMA scatter on the receiving
+ *	queue.  Note that this cannot be enabled independently for
+ *	unicast and multicast default filters; it will only be enabled
+ *	if both have this flag set.
+ * @EFX_FILTER_FLAG_RX_OVERRIDE_IP: Enables a MAC filter to override
+ *	any IP filter that matches the same packet.  By default, IP
+ *	filters take precedence.
+ * @EFX_FILTER_FLAG_RX: Filter is for RX
+ * @EFX_FILTER_FLAG_TX: Filter is for TX
+ */
+enum efx_filter_flags {
+	EFX_FILTER_FLAG_RX_RSS = 0x01,
+	EFX_FILTER_FLAG_RX_SCATTER = 0x02,
+	EFX_FILTER_FLAG_RX_OVERRIDE_IP = 0x04,
+	EFX_FILTER_FLAG_RX = 0x08,
+	EFX_FILTER_FLAG_TX = 0x10,
+};
+
+/**
+ * struct efx_filter_spec - specification for a hardware filter
+ * @type: Type of match to be performed, from &enum efx_filter_type
+ * @priority: Priority of the filter, from &enum efx_filter_priority
+ * @flags: Miscellaneous flags, from &enum efx_filter_flags
+ * @dmaq_id: Source/target queue index
+ * @data: Match data (type-dependent)
+ *
+ * Use the efx_filter_set_*() functions to initialise the @type and
+ * @data fields.
+ *
+ * The @priority field is used by software to determine whether a new
+ * filter may replace an old one.  The hardware priority of a filter
+ * depends on the filter type and %EFX_FILTER_FLAG_RX_OVERRIDE_IP
+ * flag.
+ */
+struct efx_filter_spec {
+	u8	type : 4;
+	u8	priority : 4;
+	u8	flags;
+	u16	dmaq_id;
+	u32	data[3];
+};
+
+static inline void efx_filter_init_rx(struct efx_filter_spec *spec,
+				      enum efx_filter_priority priority,
+				      enum efx_filter_flags flags,
+				      unsigned rxq_id)
+{
+	spec->type = EFX_FILTER_UNSPEC;
+	spec->priority = priority;
+	spec->flags = EFX_FILTER_FLAG_RX | flags;
+	spec->dmaq_id = rxq_id;
+}
+
+static inline void efx_filter_init_tx(struct efx_filter_spec *spec,
+				      unsigned txq_id)
+{
+	spec->type = EFX_FILTER_UNSPEC;
+	spec->priority = EFX_FILTER_PRI_REQUIRED;
+	spec->flags = EFX_FILTER_FLAG_TX;
+	spec->dmaq_id = txq_id;
+}
+
+extern int efx_filter_set_ipv4_local(struct efx_filter_spec *spec, u8 proto,
+				     __be32 host, __be16 port);
+extern int efx_filter_get_ipv4_local(const struct efx_filter_spec *spec,
+				     u8 *proto, __be32 *host, __be16 *port);
+extern int efx_filter_set_ipv4_full(struct efx_filter_spec *spec, u8 proto,
+				    __be32 host, __be16 port,
+				    __be32 rhost, __be16 rport);
+extern int efx_filter_get_ipv4_full(const struct efx_filter_spec *spec,
+				    u8 *proto, __be32 *host, __be16 *port,
+				    __be32 *rhost, __be16 *rport);
+extern int efx_filter_set_eth_local(struct efx_filter_spec *spec,
+				    u16 vid, const u8 *addr);
+extern int efx_filter_get_eth_local(const struct efx_filter_spec *spec,
+				    u16 *vid, u8 *addr);
+extern int efx_filter_set_uc_def(struct efx_filter_spec *spec);
+extern int efx_filter_set_mc_def(struct efx_filter_spec *spec);
+enum {
+	EFX_FILTER_VID_UNSPEC = 0xffff,
+};
+
+#endif /* EFX_FILTER_H */
diff -r 9566a4a50a43 drivers/net/sfc/gmii.h
--- a/drivers/net/sfc/gmii.h
+++ /dev/null
@@ -1,60 +0,0 @@
-/****************************************************************************
- * Driver for Solarflare Solarstorm network controllers and boards
- * Copyright 2005-2006 Fen Systems Ltd.
- * Copyright 2006-2008 Solarflare Communications Inc.
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 as published
- * by the Free Software Foundation, incorporated herein by reference.
- */
-
-#ifndef EFX_GMII_H
-#define EFX_GMII_H
-
-/*
- * GMII interface
- */
-
-#include <linux/mii.h>
-
-/* GMII registers, excluding registers already defined as MII
- * registers in mii.h
- */
-#define GMII_IER		0x12	/* Interrupt enable register */
-#define GMII_ISR		0x13	/* Interrupt status register */
-
-/* Interrupt enable register */
-#define IER_ANEG_ERR		0x8000	/* Bit 15 - autonegotiation error */
-#define IER_SPEED_CHG		0x4000	/* Bit 14 - speed changed */
-#define IER_DUPLEX_CHG		0x2000	/* Bit 13 - duplex changed */
-#define IER_PAGE_RCVD		0x1000	/* Bit 12 - page received */
-#define IER_ANEG_DONE		0x0800	/* Bit 11 - autonegotiation complete */
-#define IER_LINK_CHG		0x0400	/* Bit 10 - link status changed */
-#define IER_SYM_ERR		0x0200	/* Bit 9 - symbol error */
-#define IER_FALSE_CARRIER	0x0100	/* Bit 8 - false carrier */
-#define IER_FIFO_ERR		0x0080	/* Bit 7 - FIFO over/underflow */
-#define IER_MDIX_CHG		0x0040	/* Bit 6 - MDI crossover changed */
-#define IER_DOWNSHIFT		0x0020	/* Bit 5 - downshift */
-#define IER_ENERGY		0x0010	/* Bit 4 - energy detect */
-#define IER_DTE_POWER		0x0004	/* Bit 2 - DTE power detect */
-#define IER_POLARITY_CHG	0x0002	/* Bit 1 - polarity changed */
-#define IER_JABBER		0x0001	/* Bit 0 - jabber */
-
-/* Interrupt status register */
-#define ISR_ANEG_ERR		0x8000	/* Bit 15 - autonegotiation error */
-#define ISR_SPEED_CHG		0x4000	/* Bit 14 - speed changed */
-#define ISR_DUPLEX_CHG		0x2000	/* Bit 13 - duplex changed */
-#define ISR_PAGE_RCVD		0x1000	/* Bit 12 - page received */
-#define ISR_ANEG_DONE		0x0800	/* Bit 11 - autonegotiation complete */
-#define ISR_LINK_CHG		0x0400	/* Bit 10 - link status changed */
-#define ISR_SYM_ERR		0x0200	/* Bit 9 - symbol error */
-#define ISR_FALSE_CARRIER	0x0100	/* Bit 8 - false carrier */
-#define ISR_FIFO_ERR		0x0080	/* Bit 7 - FIFO over/underflow */
-#define ISR_MDIX_CHG		0x0040	/* Bit 6 - MDI crossover changed */
-#define ISR_DOWNSHIFT		0x0020	/* Bit 5 - downshift */
-#define ISR_ENERGY		0x0010	/* Bit 4 - energy detect */
-#define ISR_DTE_POWER		0x0004	/* Bit 2 - DTE power detect */
-#define ISR_POLARITY_CHG	0x0002	/* Bit 1 - polarity changed */
-#define ISR_JABBER		0x0001	/* Bit 0 - jabber */
-
-#endif /* EFX_GMII_H */
diff -r 9566a4a50a43 drivers/net/sfc/io.h
--- /dev/null
+++ b/drivers/net/sfc/io.h
@@ -0,0 +1,293 @@
+/****************************************************************************
+ * Driver for Solarflare Solarstorm network controllers and boards
+ * Copyright 2005-2006 Fen Systems Ltd.
+ * Copyright 2006-2010 Solarflare Communications Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 as published
+ * by the Free Software Foundation, incorporated herein by reference.
+ */
+
+#ifndef EFX_IO_H
+#define EFX_IO_H
+
+#include <linux/io.h>
+#include <linux/spinlock.h>
+
+/**************************************************************************
+ *
+ * NIC register I/O
+ *
+ **************************************************************************
+ *
+ * Notes on locking strategy:
+ *
+ * Most CSRs are 128-bit (oword) and therefore cannot be read or
+ * written atomically.  Access from the host is buffered by the Bus
+ * Interface Unit (BIU).  Whenever the host reads from the lowest
+ * address of such a register, or from the address of a different such
+ * register, the BIU latches the register's value.  Subsequent reads
+ * from higher addresses of the same register will read the latched
+ * value.  Whenever the host writes part of such a register, the BIU
+ * collects the written value and does not write to the underlying
+ * register until all 4 dwords have been written.  A similar buffering
+ * scheme applies to host access to the NIC's 64-bit SRAM.
+ *
+ * Access to different CSRs and 64-bit SRAM words must be serialised,
+ * since interleaved access can result in lost writes or lost
+ * information from read-to-clear fields.  We use efx_nic::biu_lock
+ * for this.  (We could use separate locks for read and write, but
+ * this is not normally a performance bottleneck.)
+ *
+ * The DMA descriptor pointers (RX_DESC_UPD and TX_DESC_UPD) are
+ * 128-bit but are special-cased in the BIU to avoid the need for
+ * locking in the host:
+ *
+ * - They are write-only.
+ * - The semantics of writing to these registers are such that
+ *   replacing the low 96 bits with zero does not affect functionality.
+ * - If the host writes to the last dword address of such a register
+ *   (i.e. the high 32 bits) the underlying register will always be
+ *   written.  If the collector and the current write together do not
+ *   provide values for all 128 bits of the register, the low 96 bits
+ *   will be written as zero.
+ * - If the host writes to the address of any other part of such a
+ *   register while the collector already holds values for some other
+ *   register, the write is discarded and the collector maintains its
+ *   current state.
+ */
+
+#if BITS_PER_LONG == 64
+#define EFX_USE_QWORD_IO 1
+#endif
+
+#ifdef EFX_USE_QWORD_IO
+static inline void _efx_writeq(struct efx_nic *efx, __le64 value,
+				  unsigned int reg)
+{
+	__raw_writeq((__force u64)value, efx->membase + reg);
+}
+static inline __le64 _efx_readq(struct efx_nic *efx, unsigned int reg)
+{
+	return (__force __le64)__raw_readq(efx->membase + reg);
+}
+#endif
+
+static inline void _efx_writed(struct efx_nic *efx, __le32 value,
+				  unsigned int reg)
+{
+	__raw_writel((__force u32)value, efx->membase + reg);
+}
+static inline __le32 _efx_readd(struct efx_nic *efx, unsigned int reg)
+{
+	return (__force __le32)__raw_readl(efx->membase + reg);
+}
+
+/* Write a normal 128-bit CSR, locking as appropriate. */
+static inline void efx_writeo(struct efx_nic *efx, efx_oword_t *value,
+			      unsigned int reg)
+{
+	unsigned long flags __attribute__ ((unused));
+
+	netif_vdbg(efx, hw, efx->net_dev,
+		   "writing register %x with " EFX_OWORD_FMT "\n", reg,
+		   EFX_OWORD_VAL(*value));
+
+	spin_lock_irqsave(&efx->biu_lock, flags);
+#ifdef EFX_USE_QWORD_IO
+	_efx_writeq(efx, value->u64[0], reg + 0);
+	_efx_writeq(efx, value->u64[1], reg + 8);
+#else
+	_efx_writed(efx, value->u32[0], reg + 0);
+	_efx_writed(efx, value->u32[1], reg + 4);
+	_efx_writed(efx, value->u32[2], reg + 8);
+	_efx_writed(efx, value->u32[3], reg + 12);
+#endif
+	mmiowb();
+	spin_unlock_irqrestore(&efx->biu_lock, flags);
+}
+
+/* Write 64-bit SRAM through the supplied mapping, locking as appropriate. */
+static inline void efx_sram_writeq(struct efx_nic *efx, void __iomem *membase,
+				   efx_qword_t *value, unsigned int index)
+{
+	unsigned int addr = index * sizeof(*value);
+	unsigned long flags __attribute__ ((unused));
+
+	netif_vdbg(efx, hw, efx->net_dev,
+		   "writing SRAM address %x with " EFX_QWORD_FMT "\n",
+		   addr, EFX_QWORD_VAL(*value));
+
+	spin_lock_irqsave(&efx->biu_lock, flags);
+#ifdef EFX_USE_QWORD_IO
+	__raw_writeq((__force u64)value->u64[0], membase + addr);
+#else
+	__raw_writel((__force u32)value->u32[0], membase + addr);
+	__raw_writel((__force u32)value->u32[1], membase + addr + 4);
+#endif
+	mmiowb();
+	spin_unlock_irqrestore(&efx->biu_lock, flags);
+}
+
+/* Write a 32-bit CSR or the last dword of a special 128-bit CSR */
+static inline void efx_writed(struct efx_nic *efx, efx_dword_t *value,
+			      unsigned int reg)
+{
+	netif_vdbg(efx, hw, efx->net_dev,
+		   "writing register %x with "EFX_DWORD_FMT"\n",
+		   reg, EFX_DWORD_VAL(*value));
+
+	/* No lock required */
+	_efx_writed(efx, value->u32[0], reg);
+}
+
+/* Read a 128-bit CSR, locking as appropriate. */
+static inline void efx_reado(struct efx_nic *efx, efx_oword_t *value,
+			     unsigned int reg)
+{
+	unsigned long flags __attribute__ ((unused));
+
+	spin_lock_irqsave(&efx->biu_lock, flags);
+	value->u32[0] = _efx_readd(efx, reg + 0);
+	value->u32[1] = _efx_readd(efx, reg + 4);
+	value->u32[2] = _efx_readd(efx, reg + 8);
+	value->u32[3] = _efx_readd(efx, reg + 12);
+	spin_unlock_irqrestore(&efx->biu_lock, flags);
+
+	netif_vdbg(efx, hw, efx->net_dev,
+		   "read from register %x, got " EFX_OWORD_FMT "\n", reg,
+		   EFX_OWORD_VAL(*value));
+}
+
+/* Read 64-bit SRAM through the supplied mapping, locking as appropriate. */
+static inline void efx_sram_readq(struct efx_nic *efx, void __iomem *membase,
+				  efx_qword_t *value, unsigned int index)
+{
+	unsigned int addr = index * sizeof(*value);
+	unsigned long flags __attribute__ ((unused));
+
+	spin_lock_irqsave(&efx->biu_lock, flags);
+#ifdef EFX_USE_QWORD_IO
+	value->u64[0] = (__force __le64)__raw_readq(membase + addr);
+#else
+	value->u32[0] = (__force __le32)__raw_readl(membase + addr);
+	value->u32[1] = (__force __le32)__raw_readl(membase + addr + 4);
+#endif
+	spin_unlock_irqrestore(&efx->biu_lock, flags);
+
+	netif_vdbg(efx, hw, efx->net_dev,
+		   "read from SRAM address %x, got "EFX_QWORD_FMT"\n",
+		   addr, EFX_QWORD_VAL(*value));
+}
+
+/* Read a 32-bit CSR or SRAM */
+static inline void efx_readd(struct efx_nic *efx, efx_dword_t *value,
+				unsigned int reg)
+{
+	value->u32[0] = _efx_readd(efx, reg);
+	netif_vdbg(efx, hw, efx->net_dev,
+		   "read from register %x, got "EFX_DWORD_FMT"\n",
+		   reg, EFX_DWORD_VAL(*value));
+}
+
+/* Write a 128-bit CSR forming part of a table */
+static inline void efx_writeo_table(struct efx_nic *efx, efx_oword_t *value,
+				      unsigned int reg, unsigned int index)
+{
+	efx_writeo(efx, value, reg + index * sizeof(efx_oword_t));
+}
+
+/* Read a 128-bit CSR forming part of a table */
+static inline void efx_reado_table(struct efx_nic *efx, efx_oword_t *value,
+				     unsigned int reg, unsigned int index)
+{
+	efx_reado(efx, value, reg + index * sizeof(efx_oword_t));
+}
+
+/* Write a 32-bit CSR forming part of a table, or 32-bit SRAM */
+static inline void efx_writed_table(struct efx_nic *efx, efx_dword_t *value,
+				       unsigned int reg, unsigned int index)
+{
+	efx_writed(efx, value, reg + index * sizeof(efx_oword_t));
+}
+
+/* Read a 32-bit CSR forming part of a table, or 32-bit SRAM */
+static inline void efx_readd_table(struct efx_nic *efx, efx_dword_t *value,
+				   unsigned int reg, unsigned int index)
+{
+	efx_readd(efx, value, reg + index * sizeof(efx_dword_t));
+}
+
+/* Page-mapped register block size */
+#define EFX_PAGE_BLOCK_SIZE 0x2000
+
+/* Calculate offset to page-mapped register block */
+#define EFX_PAGED_REG(page, reg) \
+	((page) * EFX_PAGE_BLOCK_SIZE + (reg))
+
+/* Write the whole of RX_DESC_UPD or TX_DESC_UPD */
+static inline void _efx_writeo_page(struct efx_nic *efx, efx_oword_t *value,
+				    unsigned int reg, unsigned int page)
+{
+	reg = EFX_PAGED_REG(page, reg);
+
+	netif_vdbg(efx, hw, efx->net_dev,
+		   "writing register %x with " EFX_OWORD_FMT "\n", reg,
+		   EFX_OWORD_VAL(*value));
+
+#ifdef EFX_USE_QWORD_IO
+	_efx_writeq(efx, value->u64[0], reg + 0);
+	_efx_writeq(efx, value->u64[1], reg + 8);
+#else
+	_efx_writed(efx, value->u32[0], reg + 0);
+	_efx_writed(efx, value->u32[1], reg + 4);
+	_efx_writed(efx, value->u32[2], reg + 8);
+	_efx_writed(efx, value->u32[3], reg + 12);
+#endif
+}
+#define efx_writeo_page(efx, value, reg, page)				\
+	_efx_writeo_page(efx, value,					\
+			 reg +						\
+			 BUILD_BUG_ON_ZERO((reg) != 0x830 && (reg) != 0xa10), \
+			 page)
+
+/* Write a page-mapped 32-bit CSR (EVQ_RPTR or the high bits of
+ * RX_DESC_UPD or TX_DESC_UPD)
+ */
+static inline void _efx_writed_page(struct efx_nic *efx, efx_dword_t *value,
+				    unsigned int reg, unsigned int page)
+{
+	efx_writed(efx, value, EFX_PAGED_REG(page, reg));
+}
+#define efx_writed_page(efx, value, reg, page)				\
+	_efx_writed_page(efx, value,					\
+			 reg +						\
+			 BUILD_BUG_ON_ZERO((reg) != 0x400 && (reg) != 0x83c \
+					   && (reg) != 0xa1c),		\
+			 page)
+
+/* Write TIMER_COMMAND.  This is a page-mapped 32-bit CSR, but a bug
+ * in the BIU means that writes to TIMER_COMMAND[0] invalidate the
+ * collector register.
+ */
+static inline void _efx_writed_page_locked(struct efx_nic *efx,
+					   efx_dword_t *value,
+					   unsigned int reg,
+					   unsigned int page)
+{
+	unsigned long flags __attribute__ ((unused));
+
+	if (page == 0) {
+		spin_lock_irqsave(&efx->biu_lock, flags);
+		efx_writed(efx, value, EFX_PAGED_REG(page, reg));
+		spin_unlock_irqrestore(&efx->biu_lock, flags);
+	} else {
+		efx_writed(efx, value, EFX_PAGED_REG(page, reg));
+	}
+}
+#define efx_writed_page_locked(efx, value, reg, page)			\
+	_efx_writed_page_locked(efx, value,				\
+				reg + BUILD_BUG_ON_ZERO((reg) != 0x420), \
+				page)
+
+#endif /* EFX_IO_H */
diff -r 9566a4a50a43 drivers/net/sfc/ioctl.c
--- /dev/null
+++ b/drivers/net/sfc/ioctl.c
@@ -0,0 +1,304 @@
+/****************************************************************************
+ * Driver for Solarflare network controllers
+ *           (including support for SFE4001 10GBT NIC)
+ *
+ * Copyright 2005-2006: Fen Systems Ltd.
+ * Copyright 2005-2010: Solarflare Communications Inc,
+ *                      9501 Jeronimo Road, Suite 250,
+ *                      Irvine, CA 92618, USA
+ *
+ * Initially developed by Michael Brown <mbrown@fensystems.co.uk>
+ * Maintained by Solarflare Communications <linux-net-drivers@solarflare.com>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 as published
+ * by the Free Software Foundation, incorporated herein by reference.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ ****************************************************************************
+ */
+#include "net_driver.h"
+#include "efx.h"
+#include "efx_ioctl.h"
+#include "nic.h"
+#include "mcdi.h"
+#include "mcdi_pcol.h"
+
+static int efx_ioctl_do_mcdi(struct efx_nic *efx, union efx_ioctl_data *data)
+{
+	struct efx_mcdi_request *req = &data->mcdi_request;
+	size_t outlen;
+	int rc;
+
+	if (req->len > sizeof(req->payload) || req->len & 3) {
+		netif_err(efx, drv, efx->net_dev, "inlen is too long");
+		return -EINVAL;
+	}
+
+	if (efx_nic_rev(efx) < EFX_REV_SIENA_A0) {
+		netif_err(efx, drv, efx->net_dev,
+			  "error: NIC has no MC for MCDI\n");
+		return -ENOTSUPP;
+	}
+
+	rc = efx_mcdi_rpc(efx, req->cmd, (const u8 *)req->payload,
+			  req->len, (u8 *)req->payload,
+			  sizeof(req->payload), &outlen);
+
+	/* efx_mcdi_rpc() will not schedule a reset if MC_CMD_PAYLOAD causes
+	 * a reboot. But from the user's POV, they're triggering a reboot
+	 * 'externally', and want both ports to recover. So schedule the
+	 * reset here */
+	if (req->cmd == MC_CMD_REBOOT && rc == -EIO) {
+		netif_err(efx, drv, efx->net_dev, "MC fatal error %d\n", -rc);
+		efx_schedule_reset(efx, RESET_TYPE_MC_FAILURE);
+	}
+
+	/* No distinction is made between RPC failures (driver timeouts) and
+	 * MCDI failures (timeouts, reboots etc) */
+	req->rc = -rc;
+	req->len = (__u8)outlen;
+	return 0;
+}
+
+static int
+efx_ioctl_reset_flags(struct efx_nic *efx, union efx_ioctl_data *data)
+{
+	return efx_ethtool_reset(efx->net_dev, &data->reset_flags.flags);
+}
+
+#ifdef CONFIG_COMPAT
+/* struct ethtool_rxnfc has extra padding on 64-bit architectures.
+ * And we have to follow this stupidity in order to use the same
+ * underlying implementation for both SIOCEFX and SIOCETHTOOL
+ * operations.
+ */
+struct efx_compat_ethtool_rx_flow_spec {
+	u32		flow_type;
+	union efx_ethtool_flow_union h_u;
+	struct efx_ethtool_flow_ext h_ext;
+	union efx_ethtool_flow_union m_u;
+	struct efx_ethtool_flow_ext m_ext;
+	compat_u64	ring_cookie;
+	u32		location;
+};
+struct efx_compat_ethtool_rxnfc {
+	u32				cmd;
+	u32				flow_type;
+	compat_u64			data;
+	struct efx_compat_ethtool_rx_flow_spec fs;
+	u32				rule_cnt;
+	u32				rule_locs[0];
+};
+#endif
+
+#ifndef __VMKLNX__
+static int efx_ioctl_rxnfc(struct efx_nic *efx, void __user *useraddr)
+{
+#ifdef CONFIG_COMPAT
+	struct efx_compat_ethtool_rxnfc __user *compat_rxnfc = useraddr;
+#endif
+	struct efx_ethtool_rxnfc info;
+	int ret;
+	void *rule_buf = NULL;
+
+#ifdef CONFIG_COMPAT
+	if (is_compat_task()) {
+		if (copy_from_user(&info, compat_rxnfc,
+				   (void *)(&info.fs.m_ext + 1) -
+				   (void *)&info) ||
+		    copy_from_user(&info.fs.ring_cookie,
+				   &compat_rxnfc->fs.ring_cookie,
+				   (void *)(&info.fs.location + 1) -
+				   (void *)&info.fs.ring_cookie) ||
+		    copy_from_user(&info.rule_cnt, &compat_rxnfc->rule_cnt,
+				   sizeof(info.rule_cnt)))
+			return -EFAULT;
+	} else
+#endif
+	if (copy_from_user(&info, useraddr, sizeof(info)))
+		return -EFAULT;
+
+	switch (info.cmd) {
+	case ETHTOOL_GRXCLSRLALL:
+		if (info.rule_cnt > 0) {
+			/* No more than 1 MB of rule indices - way
+			 * more than we could possibly have! */
+			if (info.rule_cnt <= (1 << 18))
+				rule_buf = kzalloc(info.rule_cnt * sizeof(u32),
+						   GFP_USER);
+			if (!rule_buf)
+				return -ENOMEM;
+		}
+		/* fall through */
+	case ETHTOOL_GRXFH:
+	case ETHTOOL_GRXRINGS:
+	case ETHTOOL_GRXCLSRLCNT:
+	case ETHTOOL_GRXCLSRULE:
+		ret = efx_ethtool_get_rxnfc(efx->net_dev, &info, rule_buf);
+		break;
+	case ETHTOOL_SRXCLSRLINS:
+	case ETHTOOL_SRXCLSRLDEL:
+		ret = efx_ethtool_set_rxnfc(efx->net_dev, &info);
+		break;
+	default:
+		return -EOPNOTSUPP;
+	}
+
+	if (ret < 0)
+		goto err_out;
+
+	ret = -EFAULT;
+#ifdef CONFIG_COMPAT
+	if (is_compat_task()) {
+		if (copy_to_user(compat_rxnfc, &info,
+				 (const void *)(&info.fs.m_ext + 1) -
+				 (const void *)&info) ||
+		    copy_to_user(&compat_rxnfc->fs.ring_cookie,
+				 &info.fs.ring_cookie,
+				 (const void *)(&info.fs.location + 1) -
+				 (const void *)&info.fs.ring_cookie) ||
+		    copy_to_user(&compat_rxnfc->rule_cnt, &info.rule_cnt,
+				 sizeof(info.rule_cnt)))
+			goto err_out;
+	} else
+#endif
+	if (copy_to_user(useraddr, &info, sizeof(info)))
+		goto err_out;
+
+	if (rule_buf) {
+#ifdef CONFIG_COMPAT
+		if (is_compat_task())
+			useraddr += offsetof(struct efx_compat_ethtool_rxnfc,
+					     rule_locs);
+		else
+#endif
+			useraddr += offsetof(struct efx_ethtool_rxnfc,
+					     rule_locs);
+		if (copy_to_user(useraddr, rule_buf,
+				 info.rule_cnt * sizeof(u32)))
+			goto err_out;
+	}
+	ret = 0;
+
+err_out:
+	kfree(rule_buf);
+
+	return ret;
+}
+#endif /* !__VMKLNX__ */
+
+#if defined(EFX_USE_KCOMPAT) && !defined(EFX_HAVE_ETHTOOL_RXFH_INDIR)
+
+static int
+efx_ioctl_rxfh_indir(struct efx_nic *efx, union efx_ioctl_data *data)
+{
+	BUILD_BUG_ON(ARRAY_SIZE(data->rxfh_indir.table) !=
+		     ARRAY_SIZE(efx->rx_indir_table));
+
+	switch (data->rxfh_indir.head.cmd) {
+	case ETHTOOL_GRXFHINDIR:
+		return efx_ethtool_old_get_rxfh_indir(efx->net_dev,
+						      &data->rxfh_indir.head);
+	case ETHTOOL_SRXFHINDIR:
+		return efx_ethtool_old_set_rxfh_indir(efx->net_dev,
+						      &data->rxfh_indir.head);
+	default:
+		return -EOPNOTSUPP;
+	}
+}
+
+#endif
+
+#ifdef CONFIG_SFC_PTP
+
+static int
+efx_ioctl_ts_settime(struct efx_nic *efx, union efx_ioctl_data *data)
+{
+	return efx_ptp_ts_settime(efx, &data->ts_settime);
+}
+
+static int
+efx_ioctl_ts_adjtime(struct efx_nic *efx, union efx_ioctl_data *data)
+{
+	return efx_ptp_ts_adjtime(efx, &data->ts_adjtime);
+}
+
+static int
+efx_ioctl_ts_sync(struct efx_nic *efx, union efx_ioctl_data *data)
+{
+	return efx_ptp_ts_sync(efx, &data->ts_sync);
+}
+
+#endif
+
+/*****************************************************************************/
+
+int efx_private_ioctl(struct efx_nic *efx, u16 cmd,
+		      union efx_ioctl_data __user *user_data)
+{
+	int (*op)(struct efx_nic *, union efx_ioctl_data *);
+	union efx_ioctl_data data;
+	size_t size;
+	int rc;
+
+	if (!capable(CAP_NET_ADMIN))
+		return -EPERM;
+
+	switch (cmd) {
+	case EFX_MCDI_REQUEST:
+		size = sizeof(data.mcdi_request);
+		op = efx_ioctl_do_mcdi;
+		break;
+	case EFX_RESET_FLAGS:
+		size = sizeof(data.reset_flags);
+		op = efx_ioctl_reset_flags;
+		break;
+#ifndef __VMKLNX__
+	case EFX_RXNFC:
+		/* This command has variable length */
+		return efx_ioctl_rxnfc(efx, &user_data->rxnfc);
+#endif
+#if defined(EFX_USE_KCOMPAT) && !defined(EFX_HAVE_ETHTOOL_RXFH_INDIR)
+	case EFX_RXFHINDIR:
+		size = sizeof(data.rxfh_indir);
+		op = efx_ioctl_rxfh_indir;
+		break;
+#endif
+#ifdef CONFIG_SFC_PTP
+	case EFX_TS_SETTIME:
+		size = sizeof(data.ts_settime);
+		op = efx_ioctl_ts_settime;
+		break;
+	case EFX_TS_ADJTIME:
+		size = sizeof(data.ts_adjtime);
+		op = efx_ioctl_ts_adjtime;
+		break;
+	case EFX_TS_SYNC:
+		size = sizeof(data.ts_sync);
+		op = efx_ioctl_ts_sync;
+		break;
+#endif
+	default:
+		netif_err(efx, drv, efx->net_dev,
+			  "unknown private ioctl cmd %x\n", cmd);
+		return -EOPNOTSUPP;
+	}
+
+	if (copy_from_user(&data, user_data, size))
+		return -EFAULT;
+	rc = op(efx, &data);
+	if (rc)
+		return rc;
+	if (copy_to_user(user_data, &data, size))
+		return -EFAULT;
+	return 0;
+}
+
diff -r 9566a4a50a43 drivers/net/sfc/kernel_compat.c
--- /dev/null
+++ b/drivers/net/sfc/kernel_compat.c
@@ -0,0 +1,193 @@
+/****************************************************************************
+ * Driver for Solarflare Solarstorm network controllers and boards
+ * Copyright 2005-2006 Fen Systems Ltd.
+ * Copyright 2006-2010 Solarflare Communications Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 as published
+ * by the Free Software Foundation, incorporated herein by reference.
+ */
+
+#define EFX_IN_KCOMPAT_C 1
+
+#include "efx.h"
+#include <linux/mii.h>
+#include <linux/ethtool.h>
+#include <linux/random.h>
+#include <linux/pci.h>
+#include <linux/spinlock.h>
+#include <linux/rtnetlink.h>
+#include <linux/bootmem.h>
+#include <linux/slab.h>
+#include <asm/uaccess.h>
+
+/*
+ * Kernel backwards compatibility
+ *
+ * This file provides functionality missing from earlier kernels.
+ */
+
+#ifdef EFX_NEED_COMPOUND_PAGE_FIX
+
+void efx_compound_page_destructor(struct page *page)
+{
+	/* Fake up page state to keep __free_pages happy */
+	set_page_count(page, 1);
+	page[1].mapping = NULL;
+
+	__free_pages(page, (unsigned long)page[1].index);
+}
+
+#endif /* NEED_COMPOUND_PAGE_FIX */
+
+/**************************************************************************
+ *
+ * print_mac, from net/ethernet/eth.c in v2.6.24
+ *
+ **************************************************************************
+ *
+ */
+
+
+#if (defined(EFX_NEED_UNMASK_MSIX_VECTORS) || \
+     defined(EFX_NEED_SAVE_MSIX_MESSAGES)) && \
+	!defined(EFX_HAVE_MSIX_TABLE_RESERVED)
+
+#undef pci_save_state
+#undef pci_restore_state
+
+#include <linux/pci.h>
+
+#define PCI_MSIX_TABLE         4
+#define PCI_MSIX_PBA           8
+#define  PCI_MSIX_BIR          0x7
+
+#define PCI_MSIX_ENTRY_SIZE		16
+#define  PCI_MSIX_ENTRY_LOWER_ADDR	0
+#define  PCI_MSIX_ENTRY_UPPER_ADDR	4
+#define  PCI_MSIX_ENTRY_DATA		8
+#define  PCI_MSIX_ENTRY_VECTOR_CTRL	12
+
+static void
+efx_for_each_msix_vector(struct efx_nic *efx,
+			 void (*fn)(struct efx_channel *, void __iomem *))
+{
+	struct pci_dev *pci_dev = efx->pci_dev;
+	resource_size_t membase_phys;
+	void __iomem *membase;
+	int msix, offset, bar, length, i;
+	u32 dword;
+
+	if (efx->interrupt_mode != EFX_INT_MODE_MSIX)
+		return;
+
+	/* Find the location (bar, offset) of the MSI-X table */
+	msix = pci_find_capability(pci_dev, PCI_CAP_ID_MSIX);
+	if (!msix)
+		return;
+	pci_read_config_dword(pci_dev, msix + PCI_MSIX_TABLE, &dword);
+	bar = dword & PCI_MSIX_BIR;
+	offset = dword & ~PCI_MSIX_BIR;
+
+	/* Map enough of the table for all our interrupts */
+	membase_phys = pci_resource_start(pci_dev, bar);
+	length = efx->n_channels * 0x10;
+	membase = ioremap_nocache(membase_phys + offset, length);
+	if (!membase) {
+		dev_dbg(&pci_dev->dev, "failed to remap MSI-X table\n");
+		return;
+	}
+
+	for (i = 0; i < efx->n_channels; i++)
+		fn(efx_get_channel(efx, i), membase + i * PCI_MSIX_ENTRY_SIZE);
+
+	/* Release the mapping */
+	iounmap(membase);
+}
+
+static void
+efx_save_msix_state(struct efx_channel *channel, void __iomem *entry)
+{
+#ifdef EFX_NEED_SAVE_MSIX_MESSAGES
+	channel->msix_msg.address_lo = readl(entry + PCI_MSIX_ENTRY_LOWER_ADDR);
+	channel->msix_msg.address_hi = readl(entry + PCI_MSIX_ENTRY_UPPER_ADDR);
+	channel->msix_msg.data = readl(entry + PCI_MSIX_ENTRY_DATA);
+#endif
+}
+
+int efx_pci_save_state(struct pci_dev *pci_dev)
+{
+	efx_for_each_msix_vector(pci_get_drvdata(pci_dev), efx_save_msix_state);
+	return pci_save_state(pci_dev);
+}
+
+static void
+efx_restore_msix_state(struct efx_channel *channel, void __iomem *entry)
+{
+#ifdef EFX_NEED_SAVE_MSIX_MESSAGES
+	writel(channel->msix_msg.address_lo, entry + PCI_MSIX_ENTRY_LOWER_ADDR);
+	writel(channel->msix_msg.address_hi, entry + PCI_MSIX_ENTRY_UPPER_ADDR);
+	writel(channel->msix_msg.data, entry + PCI_MSIX_ENTRY_DATA);
+#endif
+}
+
+void efx_pci_restore_state(struct pci_dev *pci_dev)
+{
+	pci_restore_state(pci_dev);
+	efx_for_each_msix_vector(pci_get_drvdata(pci_dev),
+				 efx_restore_msix_state);
+}
+
+#endif /* (EFX_NEED_UNMASK_MSIX_VECTORS || EFX_NEED_SAVE_MSIX_MESSAGES) &&
+	  !EFX_HAVE_MSIX_TABLE_RESERVED */
+
+int efx_pci_vpd_find_tag(const u8 *buf, unsigned int off, unsigned int len, u8 rdt)
+{
+	int i;
+
+	for (i = off; i < len; ) {
+		u8 val = buf[i];
+
+		if (val & PCI_VPD_LRDT) {
+			/* Don't return success of the tag isn't complete */
+			if (i + PCI_VPD_LRDT_TAG_SIZE > len)
+				break;
+
+			if (val == rdt)
+				return i;
+
+			i += PCI_VPD_LRDT_TAG_SIZE +
+			     pci_vpd_lrdt_size(&buf[i]);
+		} else {
+			u8 tag = val & ~PCI_VPD_SRDT_LEN_MASK;
+
+			if (tag == rdt)
+				return i;
+
+			if (tag == PCI_VPD_SRDT_END)
+				break;
+
+			i += PCI_VPD_SRDT_TAG_SIZE +
+			     pci_vpd_srdt_size(&buf[i]);
+		}
+	}
+
+	return -ENOENT;
+}
+
+int efx_pci_vpd_find_info_keyword(const u8 *buf, unsigned int off,
+			      unsigned int len, const char *kw)
+{
+	int i;
+
+	for (i = off; i + PCI_VPD_INFO_FLD_HDR_SIZE <= off + len;) {
+		if (buf[i + 0] == kw[0] &&
+		    buf[i + 1] == kw[1])
+			return i;
+
+		i += PCI_VPD_INFO_FLD_HDR_SIZE +
+		     pci_vpd_info_field_size(&buf[i]);
+	}
+
+	return -ENOENT;
+}
diff -r 9566a4a50a43 drivers/net/sfc/kernel_compat.h
--- /dev/null
+++ b/drivers/net/sfc/kernel_compat.h
@@ -0,0 +1,926 @@
+/****************************************************************************
+ * Driver for Solarflare Solarstorm network controllers and boards
+ * Copyright 2005-2006 Fen Systems Ltd.
+ * Copyright 2006-2011 Solarflare Communications Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 as published
+ * by the Free Software Foundation, incorporated herein by reference.
+ */
+
+#ifndef EFX_KERNEL_COMPAT_H
+#define EFX_KERNEL_COMPAT_H
+
+#include <linux/version.h>
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,15)
+#include <linux/autoconf.h>
+#endif
+#include <linux/sched.h>
+#include <linux/errno.h>
+#include <linux/pci.h>
+#include <linux/workqueue.h>
+#include <linux/moduleparam.h>
+#include <linux/interrupt.h>
+#include <linux/skbuff.h>
+#include <linux/netdevice.h>
+#include <linux/rtnetlink.h>
+#include <linux/i2c.h>
+#include <linux/sysfs.h>
+#include <linux/stringify.h>
+#include <linux/device.h>
+#include <linux/delay.h>
+#include <linux/wait.h>
+#include <linux/cpumask.h>
+#include <linux/topology.h>
+#include <linux/ethtool.h>
+#include <linux/vmalloc.h>
+#include <linux/if_vlan.h>
+#include <linux/time.h>
+
+/**************************************************************************
+ *
+ * Autoconf compatability
+ *
+ **************************************************************************/
+
+#define EFX_USE_KCOMPAT
+#include "autocompat.h"
+
+/**************************************************************************
+ *
+ * Resolve conflicts between feature switches and compatibility flags
+ *
+ **************************************************************************/
+
+#ifdef CONFIG_SFC_PRIVATE_MDIO
+	#undef EFX_HAVE_LINUX_MDIO_H
+#endif
+
+/**************************************************************************
+ *
+ * Version/config/architecture compatability.
+ *
+ **************************************************************************
+ *
+ * The preferred kernel compatability mechanism is through the autoconf
+ * layer above. The following definitions are all deprecated
+ */
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,5)
+	#error "This kernel version is now unsupported"
+#endif
+
+	#define EFX_USE_COMPOUND_PAGES yes
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,16) && defined(EFX_USE_COMPOUND_PAGES)
+	#define EFX_NEED_COMPOUND_PAGE_FIX
+#endif
+
+/* debugfs only supports sym-links from 2.6.21 */
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,21) && defined(CONFIG_DEBUG_FS)
+	#define EFX_USE_DEBUGFS yes
+#endif
+
+/* netif_device_{detach,attach}() were missed in multiqueue transition */
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,30) && defined(EFX_USE_TX_MQ)
+	#define EFX_NEED_NETIF_DEVICE_DETACH_ATTACH_MQ yes
+#endif
+
+#if defined(EFX_USE_IOCTL_RESET_FLAGS) && defined(EFX_HAVE_LINUX_MDIO_H)
+	/* mdio module has some bugs in pause frame advertising */
+	#define EFX_NEED_MDIO45_FLOW_CONTROL_HACKS yes
+#endif
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,36) && \
+	!defined(EFX_NEED_UNMASK_MSIX_VECTORS)
+	/* Fixing that bug introduced a different one, fixed in 2.6.36 */
+	#define EFX_NEED_SAVE_MSIX_MESSAGES yes
+#endif
+
+#ifdef CONFIG_PPC64
+	/* __raw_writel and friends are broken on ppc64 */
+	#define EFX_NEED_RAW_READ_AND_WRITE_FIX yes
+#endif
+
+/**************************************************************************
+ *
+ * Definitions of missing constants, types, functions and macros
+ *
+ **************************************************************************
+ *
+ */
+
+#ifndef spin_trylock_irqsave
+	#define spin_trylock_irqsave(lock, flags)	\
+	({						\
+		local_irq_save(flags);			\
+		spin_trylock(lock) ?			\
+		1 : ({local_irq_restore(flags); 0;});	\
+	})
+#endif
+
+#ifndef raw_smp_processor_id
+	#define raw_smp_processor_id() (current_thread_info()->cpu)
+#endif
+
+#ifndef NETIF_F_GEN_CSUM
+	#define NETIF_F_GEN_CSUM (NETIF_F_NO_CSUM | NETIF_F_HW_CSUM)
+#endif
+#ifndef NETIF_F_V4_CSUM
+	#define NETIF_F_V4_CSUM (NETIF_F_GEN_CSUM | NETIF_F_IP_CSUM)
+#endif
+#ifndef NETIF_F_V6_CSUM
+	#define NETIF_F_V6_CSUM  NETIF_F_GEN_CSUM
+#endif
+#ifndef NETIF_F_ALL_CSUM
+	#define NETIF_F_ALL_CSUM (NETIF_F_V4_CSUM | NETIF_F_V6_CSUM)
+#endif
+
+#ifdef NETIF_F_RXHASH
+	#define EFX_HAVE_RXHASH_SUPPORT yes
+#else
+	/* This reduces the need for #ifdefs */
+	#define NETIF_F_RXHASH 0
+	#define ETH_FLAG_RXHASH 0
+#endif
+
+#ifndef NETIF_F_NTUPLE
+	/* This reduces the need for #ifdefs */
+	#define NETIF_F_NTUPLE 0
+	#define ETH_FLAG_NTUPLE 0
+#endif
+
+#ifndef NETIF_F_RXCSUM
+	/* This reduces the need for #ifdefs */
+	#define NETIF_F_RXCSUM 0
+#endif
+
+/* This reduces the need for #ifdefs */
+#ifndef NETIF_F_TSO6
+	#define NETIF_F_TSO6 0
+#endif
+#ifndef NETIF_F_TSO_ECN
+	#define NETIF_F_TSO_ECN 0
+#endif
+#ifndef NETIF_F_ALL_TSO
+	#define NETIF_F_ALL_TSO (NETIF_F_TSO | NETIF_F_TSO6 | NETIF_F_TSO_ECN)
+#endif
+
+/* Cope with small changes in PCI constants between minor kernel revisions */
+#if PCI_X_STATUS != 4
+	#undef PCI_X_STATUS
+	#define PCI_X_STATUS 4
+	#undef PCI_X_STATUS_MAX_SPLIT
+	#define PCI_X_STATUS_MAX_SPLIT 0x03800000
+#endif
+
+#ifndef __GFP_COMP
+	#define __GFP_COMP 0
+#endif
+
+#ifndef __iomem
+	#define __iomem
+#endif
+
+#ifndef NET_IP_ALIGN
+	#define NET_IP_ALIGN 2
+#endif
+
+#ifndef PCI_EXP_FLAGS
+	#define PCI_EXP_FLAGS		2	/* Capabilities register */
+	#define PCI_EXP_FLAGS_TYPE	0x00f0	/* Device/Port type */
+	#define  PCI_EXP_TYPE_ENDPOINT	0x0	/* Express Endpoint */
+	#define  PCI_EXP_TYPE_LEG_END	0x1	/* Legacy Endpoint */
+	#define  PCI_EXP_TYPE_ROOT_PORT 0x4	/* Root Port */
+#endif
+
+#ifndef PCI_EXP_DEVCAP
+	#define PCI_EXP_DEVCAP		4	/* Device capabilities */
+	#define  PCI_EXP_DEVCAP_PAYLOAD	0x07	/* Max_Payload_Size */
+	#define  PCI_EXP_DEVCAP_PWR_VAL	0x3fc0000 /* Slot Power Limit Value */
+	#define  PCI_EXP_DEVCAP_PWR_SCL	0xc000000 /* Slot Power Limit Scale */
+#endif
+
+#ifndef PCI_EXP_DEVCTL
+	#define PCI_EXP_DEVCTL		8	/* Device Control */
+	#define  PCI_EXP_DEVCTL_PAYLOAD	0x00e0	/* Max_Payload_Size */
+	#define  PCI_EXP_DEVCTL_READRQ	0x7000	/* Max_Read_Request_Size */
+#endif
+
+#ifndef PCI_EXP_LNKSTA
+	#define PCI_EXP_LNKSTA		18	/* Link Status */
+#endif
+#ifndef PCI_EXP_LNKSTA_CLS
+	#define  PCI_EXP_LNKSTA_CLS	0x000f	/* Current Link Speed */
+#endif
+#ifndef PCI_EXP_LNKSTA_NLW
+	#define  PCI_EXP_LNKSTA_NLW	0x03f0	/* Nogotiated Link Width */
+#endif
+
+#ifndef PCI_VENDOR_ID_SOLARFLARE
+	#define PCI_VENDOR_ID_SOLARFLARE	0x1924
+	#define PCI_DEVICE_ID_SOLARFLARE_SFC4000A_0	0x0703
+	#define PCI_DEVICE_ID_SOLARFLARE_SFC4000A_1	0x6703
+	#define PCI_DEVICE_ID_SOLARFLARE_SFC4000B	0x0710
+#endif
+
+#ifndef __force
+	#define __force
+#endif
+
+#if ! defined(for_each_cpu_mask) && ! defined(CONFIG_SMP)
+	#define for_each_cpu_mask(cpu, mask)            \
+		for ((cpu) = 0; (cpu) < 1; (cpu)++, (void)mask)
+#endif
+
+#ifndef IRQF_PROBE_SHARED
+	#ifdef SA_PROBEIRQ
+		#define IRQF_PROBE_SHARED  SA_PROBEIRQ
+	#else
+		#define IRQF_PROBE_SHARED  0
+	#endif
+#endif
+
+#ifndef IRQF_SHARED
+	#define IRQF_SHARED	   SA_SHIRQ
+#endif
+
+#ifndef CHECKSUM_PARTIAL
+	#define CHECKSUM_PARTIAL CHECKSUM_HW
+#endif
+
+#ifndef DMA_BIT_MASK
+	#define DMA_BIT_MASK(n) (((n) == 64) ? ~0ULL : ((1ULL<<(n))-1))
+#endif
+
+#if defined(__GNUC__) && !defined(inline)
+	#define inline inline __attribute__ ((always_inline))
+#endif
+
+#if defined(__GNUC__) && !defined(__packed)
+	#define __packed __attribute__((packed))
+#endif
+
+#ifndef DIV_ROUND_UP
+	#define DIV_ROUND_UP(n,d) (((n) + (d) - 1) / (d))
+#endif
+
+#ifndef __ATTR
+	#define __ATTR(_name,_mode,_show,_store) {			\
+		.attr = {.name = __stringify(_name), .mode = _mode },	\
+		.show   = _show,					\
+		.store  = _store,					\
+	}
+#endif
+
+#ifndef DEVICE_ATTR
+	#define DEVICE_ATTR(_name, _mode, _show, _store)		\
+		struct device_attribute dev_attr_ ## _name =		\
+			__ATTR(_name, _mode, _show, _store)
+#endif
+
+#ifndef to_i2c_adapter
+	#define to_i2c_adapter dev_to_i2c_adapter
+#endif
+
+#if defined(CONFIG_X86) && !defined(CONFIG_HAVE_EFFICIENT_UNALIGNED_ACCESS)
+	#define CONFIG_HAVE_EFFICIENT_UNALIGNED_ACCESS
+#endif
+
+#ifndef BUILD_BUG_ON_ZERO
+	#define BUILD_BUG_ON_ZERO(e) (sizeof(char[1 - 2 * !!(e)]) - 1)
+#endif
+
+#ifndef __bitwise
+	#define __bitwise
+#endif
+
+#ifndef cpumask_of
+	/* This is an absolute nightmare. In old kernels, cpumask_of_cpu() is
+	 * a macro closure, so we can't use &cpumask_of_cpu(). This should
+	 * always be safe, and should provide some protection against
+	 * inter-file use of cpumask_of()
+	 */
+	static inline cpumask_t *cpumask_of(int cpu)
+	{
+		static cpumask_t var;
+
+		var = cpumask_of_cpu(cpu);
+		return &var;
+	}
+#endif
+
+#ifndef KBUILD_STR
+	/* KBUILD_MODNAME is not a string */
+	#define __KBUILD_STR(s) #s
+	#define KBUILD_STR(s) __KBUILD_STR(s)
+	static char efx_kbuild_modname[] __attribute__((unused)) =
+		KBUILD_STR(KBUILD_MODNAME);
+	#undef KBUILD_MODNAME
+	#define KBUILD_MODNAME efx_kbuild_modname
+#endif
+
+#ifndef VLAN_PRIO_SHIFT
+	#define VLAN_PRIO_SHIFT         13
+#endif
+
+#ifndef ACCESS_ONCE
+	#define ACCESS_ONCE(x) (*(volatile typeof(x) *)&(x))
+#endif
+
+/**************************************************************************/
+
+/* linux_mdio.h needs this */
+
+	#include <linux/mdio.h>
+
+#ifndef ETH_RESET_SHARED_SHIFT
+	enum ethtool_reset_flags {
+		/* These flags represent components dedicated to the interface
+		 * the command is addressed to.  Shift any flag left by
+		 * ETH_RESET_SHARED_SHIFT to reset a shared component of the
+		 * same type.
+		 */
+	  	ETH_RESET_MGMT		= 1 << 0,	/* Management processor */
+		ETH_RESET_IRQ		= 1 << 1,	/* Interrupt requester */
+		ETH_RESET_DMA		= 1 << 2,	/* DMA engine */
+		ETH_RESET_FILTER	= 1 << 3,	/* Filtering/flow direction */
+		ETH_RESET_OFFLOAD	= 1 << 4,	/* Protocol offload */
+		ETH_RESET_MAC		= 1 << 5,	/* Media access controller */
+		ETH_RESET_PHY		= 1 << 6,	/* Transceiver/PHY */
+		ETH_RESET_RAM		= 1 << 7,	/* RAM shared between
+							 * multiple components */
+
+		ETH_RESET_DEDICATED	= 0x0000ffff,	/* All components dedicated to
+							 * this interface */
+		ETH_RESET_ALL		= 0xffffffff,	/* All components used by this
+							 * interface, even if shared */
+	};
+	#define ETH_RESET_SHARED_SHIFT	16
+	#define ETHTOOL_RESET		0x00000034
+#endif
+
+#ifndef ETHTOOL_GRXFH
+	#define ETHTOOL_GRXFH		0x00000029
+#endif
+
+#ifdef ETHTOOL_GRXRINGS
+	#define EFX_HAVE_ETHTOOL_RXNFC yes
+#else
+	#define ETHTOOL_GRXRINGS	0x0000002d
+#endif
+
+#ifndef TCP_V4_FLOW
+	#define	TCP_V4_FLOW	0x01
+	#define	UDP_V4_FLOW	0x02
+	#define	SCTP_V4_FLOW	0x03
+	#define	AH_ESP_V4_FLOW	0x04
+	#define	TCP_V6_FLOW	0x05
+	#define	UDP_V6_FLOW	0x06
+	#define	SCTP_V6_FLOW	0x07
+	#define	AH_ESP_V6_FLOW	0x08
+#endif
+#ifndef AH_V4_FLOW
+	#define	AH_V4_FLOW	0x09
+	#define	ESP_V4_FLOW	0x0a
+	#define	AH_V6_FLOW	0x0b
+	#define	ESP_V6_FLOW	0x0c
+	#define	IP_USER_FLOW	0x0d
+#endif
+#ifndef IPV4_FLOW
+	#define	IPV4_FLOW	0x10
+	#define	IPV6_FLOW	0x11
+#endif
+#ifndef ETHER_FLOW
+	#define ETHER_FLOW	0x12
+#endif
+#ifndef FLOW_EXT
+	#define	FLOW_EXT	0x80000000
+#endif
+#ifndef RXH_L2DA
+	#define	RXH_L2DA	(1 << 1)
+	#define	RXH_VLAN	(1 << 2)
+	#define	RXH_L3_PROTO	(1 << 3)
+	#define	RXH_IP_SRC	(1 << 4)
+	#define	RXH_IP_DST	(1 << 5)
+	#define	RXH_L4_B_0_1	(1 << 6)
+	#define	RXH_L4_B_2_3	(1 << 7)
+	#define	RXH_DISCARD	(1 << 31)
+#endif
+
+#ifndef ETHTOOL_GRXCLSRULE
+	struct ethtool_tcpip4_spec {
+		__be32	ip4src;
+		__be32	ip4dst;
+		__be16	psrc;
+		__be16	pdst;
+		__u8    tos;
+	};
+
+	#define RX_CLS_FLOW_DISC	0xffffffffffffffffULL
+
+	#define ETHTOOL_GRXCLSRLCNT	0x0000002e
+	#define ETHTOOL_GRXCLSRULE	0x0000002f
+	#define ETHTOOL_GRXCLSRLALL	0x00000030
+	#define ETHTOOL_SRXCLSRLDEL     0x00000031
+	#define ETHTOOL_SRXCLSRLINS	0x00000032
+#endif
+
+/* We want to use the latest definition of ethtool_rxnfc, even if the
+ * kernel headers don't define all the fields in it.  Use our own name
+ * and cast as necessary.
+ */
+#ifndef EFX_HAVE_EFX_ETHTOOL_RXNFC
+	union efx_ethtool_flow_union {
+		struct ethtool_tcpip4_spec		tcp_ip4_spec;
+		struct ethtool_tcpip4_spec		udp_ip4_spec;
+		struct ethtool_tcpip4_spec		sctp_ip4_spec;
+		struct ethhdr				ether_spec;
+		/* unneeded members omitted... */
+		__u8					hdata[60];
+	};
+	struct efx_ethtool_flow_ext {
+		__be16	vlan_etype;
+		__be16	vlan_tci;
+		__be32	data[2];
+	};
+	struct efx_ethtool_rx_flow_spec {
+		__u32		flow_type;
+		union efx_ethtool_flow_union h_u;
+		struct efx_ethtool_flow_ext h_ext;
+		union efx_ethtool_flow_union m_u;
+		struct efx_ethtool_flow_ext m_ext;
+		__u64		ring_cookie;
+		__u32		location;
+	};
+	struct efx_ethtool_rxnfc {
+		__u32				cmd;
+		__u32				flow_type;
+		__u64				data;
+		struct efx_ethtool_rx_flow_spec	fs;
+		__u32				rule_cnt;
+		__u32				rule_locs[0];
+	};
+	#define EFX_HAVE_EFX_ETHTOOL_RXNFC yes
+#endif
+
+#ifndef RX_CLS_LOC_SPECIAL
+	#define RX_CLS_LOC_SPECIAL	0x80000000
+	#define RX_CLS_LOC_ANY		0xffffffff
+	#define RX_CLS_LOC_FIRST	0xfffffffe
+	#define RX_CLS_LOC_LAST		0xfffffffd
+#endif
+
+#ifdef ETHTOOL_GRXFHINDIR
+	#define EFX_HAVE_ETHTOOL_RXFH_INDIR yes
+#else
+	struct ethtool_rxfh_indir {
+		__u32	cmd;
+		/* On entry, this is the array size of the user buffer.  On
+		 * return from ETHTOOL_GRXFHINDIR, this is the array size of
+		 * the hardware indirection table. */
+		__u32	size;
+		__u32	ring_index[0];	/* ring/queue index for each hash value */
+	};
+	#define ETHTOOL_GRXFHINDIR	0x00000038
+	#define ETHTOOL_SRXFHINDIR	0x00000039
+#endif
+
+	static inline u32 ethtool_rxfh_indir_default(u32 index, u32 n_rx_rings)
+	{
+		return index % n_rx_rings;
+	}
+
+	enum ethtool_phys_id_state {
+		ETHTOOL_ID_INACTIVE,
+		ETHTOOL_ID_ACTIVE,
+		ETHTOOL_ID_ON,
+		ETHTOOL_ID_OFF
+	};
+
+#ifndef FLOW_CTRL_TX
+	#define FLOW_CTRL_TX		0x01
+	#define FLOW_CTRL_RX		0x02
+#endif
+
+#ifndef PORT_OTHER
+	#define PORT_OTHER		0xff
+#endif
+
+#ifndef SUPPORTED_Pause
+	#define SUPPORTED_Pause			(1 << 13)
+	#define SUPPORTED_Asym_Pause		(1 << 14)
+#endif
+
+#ifndef SUPPORTED_Backplane
+	#define SUPPORTED_Backplane		(1 << 16)
+	#define SUPPORTED_1000baseKX_Full	(1 << 17)
+	#define SUPPORTED_10000baseKX4_Full	(1 << 18)
+	#define SUPPORTED_10000baseKR_Full	(1 << 19)
+	#define SUPPORTED_10000baseR_FEC	(1 << 20)
+#endif
+
+#ifdef EFX_NEED_RAW_READ_AND_WRITE_FIX
+	#include <asm/io.h>
+	static inline void
+	efx_raw_writeb(u8 value, volatile void __iomem *addr)
+	{
+		writeb(value, addr);
+	}
+	static inline void
+	efx_raw_writew(u16 value, volatile void __iomem *addr)
+	{
+		writew(le16_to_cpu(value), addr);
+	}
+	static inline void
+	efx_raw_writel(u32 value, volatile void __iomem *addr)
+	{
+		writel(le32_to_cpu(value), addr);
+	}
+	static inline void
+	efx_raw_writeq(u64 value, volatile void __iomem *addr)
+	{
+		writeq(le64_to_cpu(value), addr);
+	}
+	static inline u8
+	efx_raw_readb(const volatile void __iomem *addr)
+	{
+		return readb(addr);
+	}
+	static inline u16
+	efx_raw_readw(const volatile void __iomem *addr)
+	{
+		return cpu_to_le16(readw(addr));
+	}
+	static inline u32
+	efx_raw_readl(const volatile void __iomem *addr)
+	{
+		return cpu_to_le32(readl(addr));
+	}
+	static inline u64
+	efx_raw_readq(const volatile void __iomem *addr)
+	{
+		return cpu_to_le64(readq(addr));
+	}
+
+	#undef __raw_writeb
+	#undef __raw_writew
+	#undef __raw_writel
+	#undef __raw_writeq
+	#undef __raw_readb
+	#undef __raw_readw
+	#undef __raw_readl
+	#undef __raw_readq
+	#define __raw_writeb efx_raw_writeb
+	#define __raw_writew efx_raw_writew
+	#define __raw_writel efx_raw_writel
+	#define __raw_writeq efx_raw_writeq
+	#define __raw_readb efx_raw_readb
+	#define __raw_readw efx_raw_readw
+	#define __raw_readl efx_raw_readl
+	#define __raw_readq efx_raw_readq
+#endif
+
+	static inline void *vzalloc(unsigned long size)
+	{
+		void *buf = vmalloc(size);
+		if (buf)
+			memset(buf, 0, size);
+		return buf;
+	}
+
+	#include <linux/mutex.h>
+
+#ifndef NETIF_F_GSO
+	#define efx_gso_size tso_size
+	#undef gso_size
+	#define gso_size efx_gso_size
+	#define efx_gso_segs tso_segs
+	#undef gso_segs
+	#define gso_segs efx_gso_segs
+#endif
+
+#ifndef netdev_for_each_mc_addr
+	#define netdev_for_each_mc_addr(mclist, dev) \
+		for (mclist = dev->mc_list; mclist; mclist = mclist->next)
+#endif
+
+	static inline void
+	netif_set_real_num_rx_queues(struct net_device *dev, unsigned int rxq)
+	{
+#ifdef CONFIG_RPS
+		dev->num_rx_queues = rxq;
+#endif
+	}
+
+#ifndef DEFINE_PCI_DEVICE_TABLE
+	#define DEFINE_PCI_DEVICE_TABLE(_table) \
+		const struct pci_device_id _table[] __devinitdata
+#endif
+
+/*
+ * Recent mainline kernels can be configured so that the resulting
+ * image will run both on 'bare metal' and in a Xen domU.
+ * xen_domain() or xen_start_info tells us which is the case at
+ * run-time.  If neither is defined, assume that CONFIG_XEN tells us
+ * at compile-time.
+ */
+#if   defined(CONFIG_XEN) && defined(EFX_HAVE_XEN_START_INFO)
+	/* We should be able to include <asm/xen/hypervisor.h> but that
+	 * is broken (#includes other headers that are not installed) in
+	 * Fedora 10. */
+	extern struct start_info *xen_start_info;
+	#define xen_domain() (xen_start_info ? 1 : 0)
+#endif
+#ifndef xen_domain
+	#ifdef CONFIG_XEN
+		#define xen_domain() 1
+	#else
+		#define xen_domain() 0
+	#endif
+#endif
+
+#ifndef IS_ALIGNED
+	#define IS_ALIGNED(x, a) (((x) & ((typeof(x))(a) - 1)) == 0)
+#endif
+
+#ifndef netif_printk
+
+	/* A counterpart to SET_NETDEV_DEV */
+		#define EFX_GET_NETDEV_DEV(netdev) ((netdev)->dev.parent)
+
+	static inline const char *netdev_name(const struct net_device *dev)
+	{
+		if (dev->reg_state != NETREG_REGISTERED)
+			return "(unregistered net_device)";
+		return dev->name;
+	}
+
+	#define netdev_printk(level, netdev, format, args...)		\
+		dev_printk(level, EFX_GET_NETDEV_DEV(netdev),		\
+			   "%s: " format,				\
+			   netdev_name(netdev), ##args)
+
+	#define netif_printk(priv, type, level, dev, fmt, args...)	\
+	do {					  			\
+		if (netif_msg_##type(priv))				\
+			netdev_printk(level, (dev), fmt, ##args);	\
+	} while (0)
+
+	#define netif_emerg(priv, type, dev, fmt, args...)		\
+		netif_printk(priv, type, KERN_EMERG, dev, fmt, ##args)
+	#define netif_alert(priv, type, dev, fmt, args...)		\
+		netif_printk(priv, type, KERN_ALERT, dev, fmt, ##args)
+	#define netif_crit(priv, type, dev, fmt, args...)		\
+		netif_printk(priv, type, KERN_CRIT, dev, fmt, ##args)
+	#define netif_err(priv, type, dev, fmt, args...)		\
+		netif_printk(priv, type, KERN_ERR, dev, fmt, ##args)
+	#define netif_warn(priv, type, dev, fmt, args...)		\
+		netif_printk(priv, type, KERN_WARNING, dev, fmt, ##args)
+	#define netif_notice(priv, type, dev, fmt, args...)		\
+		netif_printk(priv, type, KERN_NOTICE, dev, fmt, ##args)
+	#define netif_info(priv, type, dev, fmt, args...)		\
+		netif_printk(priv, type, KERN_INFO, (dev), fmt, ##args)
+
+	#if defined(DEBUG)
+	#define netif_dbg(priv, type, dev, format, args...)		\
+		netif_printk(priv, type, KERN_DEBUG, dev, format, ##args)
+	#elif defined(CONFIG_DYNAMIC_DEBUG)
+	#define netif_dbg(priv, type, netdev, format, args...)		\
+	do {								\
+		if (netif_msg_##type(priv))				\
+			dynamic_dev_dbg((netdev)->dev.parent,		\
+					"%s: " format,			\
+					netdev_name(netdev), ##args);	\
+	} while (0)
+	#else
+	#define netif_dbg(priv, type, dev, format, args...)		\
+	({								\
+		if (0)							\
+			netif_printk(priv, type, KERN_DEBUG, dev,	\
+				     format, ##args);			\
+		0;							\
+	})
+	#endif
+
+#endif
+
+/* netif_vdbg may be defined wrongly */
+#undef netif_vdbg
+#if defined(VERBOSE_DEBUG)
+#define netif_vdbg	netif_dbg
+#else
+#define netif_vdbg(priv, type, dev, format, args...)		\
+({								\
+	if (0)							\
+		netif_printk(priv, type, KERN_DEBUG, dev,	\
+			     format, ##args);			\
+	0;							\
+})
+#endif
+
+#ifndef pr_err
+	#define pr_err(fmt, arg...) \
+		printk(KERN_ERR fmt, ##arg)
+#endif
+
+#ifndef __always_unused
+	#define __always_unused __attribute__((unused))
+#endif
+
+	typedef u32 netdev_features_t;
+
+	static inline dma_addr_t skb_frag_dma_map(struct device *dev,
+						  const skb_frag_t *frag,
+						  size_t offset, size_t size,
+						  enum dma_data_direction dir)
+	{
+		return dma_map_page(dev, frag->page,
+				    frag->page_offset + offset, size, dir);
+	}
+
+	static inline int is_compat_task(void)
+	{
+	#if !defined(CONFIG_COMPAT)
+		return 0;
+	#elif defined(CONFIG_X86_64)
+		return test_thread_flag(TIF_IA32);
+	#elif defined(CONFIG_PPC64)
+		return test_thread_flag(TIF_32BIT);
+	#else
+	#error "cannot define is_compat_task() for this architecture"
+	#endif
+	}
+
+/**************************************************************************
+ *
+ * Missing functions provided by kernel_compat.c
+ *
+ **************************************************************************
+ *
+ */
+
+#ifdef EFX_NEED_COMPOUND_PAGE_FIX
+	extern void efx_compound_page_destructor(struct page *page);
+#endif
+
+#if (defined(EFX_NEED_UNMASK_MSIX_VECTORS) || \
+     defined(EFX_NEED_SAVE_MSIX_MESSAGES)) && \
+	!defined(EFX_HAVE_MSIX_TABLE_RESERVED)
+
+	#if defined(EFX_NEED_SAVE_MSIX_MESSAGES)
+		#include <linux/msi.h>
+	#endif
+
+	extern int efx_pci_save_state(struct pci_dev *dev);
+	#define pci_save_state efx_pci_save_state
+
+	extern void efx_pci_restore_state(struct pci_dev *dev);
+	#define pci_restore_state efx_pci_restore_state
+
+#endif
+
+/**************************************************************************
+ *
+ * Wrappers to fix bugs and parameter changes
+ *
+ **************************************************************************
+ *
+ */
+
+	typedef int gro_result_t;
+
+	#define napi_gro_frags(_napi)				\
+		({ napi_gro_frags(_napi);			\
+		   GRO_MERGED; })
+	#define napi_gro_receive(_napi, _skb)			\
+		({ napi_gro_receive(_napi, _skb);		\
+		   GRO_MERGED; })
+	/* vlan_gro_{frags,receive} won't return gro_result_t in
+	 * either of the above cases.
+	 */
+	#define vlan_gro_frags(_napi, _group, _tag)		\
+		({ vlan_gro_frags(_napi, _group, _tag);		\
+		   GRO_MERGED; })
+	#define vlan_gro_receive(_napi, _group, _tag, _skb)	\
+		({ vlan_gro_receive(_napi, _group, _tag, _skb);	\
+		   GRO_MERGED; })
+
+#ifdef EFX_NEED_COMPOUND_PAGE_FIX
+	static inline
+	struct page *efx_alloc_pages(gfp_t flags, unsigned int order)
+	{
+		struct page *p = alloc_pages(flags, order);
+		if ((flags & __GFP_COMP) && (p != NULL) && (order > 0))
+			p[1].mapping = (void *)efx_compound_page_destructor;
+		return p;
+	}
+	#undef alloc_pages
+	#define alloc_pages efx_alloc_pages
+
+	static inline
+	void efx_free_pages(struct page *p, unsigned int order)
+	{
+		if ((order > 0) && (page_count(p) == 1))
+			p[1].mapping = NULL;
+		__free_pages(p, order);
+	}
+	#define __free_pages efx_free_pages
+#endif
+
+
+#ifdef EFX_NEED_NETIF_DEVICE_DETACH_ATTACH_MQ
+	static inline void efx_netif_device_detach(struct net_device *dev)
+	{
+		if (test_and_clear_bit(__LINK_STATE_PRESENT, &dev->state) &&
+		    netif_running(dev)) {
+			netif_tx_stop_all_queues(dev);
+		}
+	}
+	#define netif_device_detach efx_netif_device_detach
+
+	static inline void efx_netif_device_attach(struct net_device *dev)
+	{
+		/* __netdev_watchdog_up() is not exported, so we have
+		 * to call the broken implementation and then start
+		 * the remaining queues.
+		 */
+		if (!test_bit(__LINK_STATE_PRESENT, &dev->state) &&
+		    netif_running(dev)) {
+			netif_device_attach(dev);
+			netif_tx_wake_all_queues(dev);
+		}
+	}
+	#define netif_device_attach efx_netif_device_attach
+#endif
+
+	static inline int skb_checksum_start_offset(const struct sk_buff *skb)
+	{
+	        return skb->csum_start - skb_headroom(skb);
+	}
+
+	#include <linux/ktime.h>
+
+	#include <linux/net_tstamp.h>
+
+#define PCI_VPD_LRDT                    0x80    /* Large Resource Data Type */
+#define PCI_VPD_LRDT_ID(x)              (x | PCI_VPD_LRDT)
+
+/* Large Resource Data Type Tag Item Names */
+#define PCI_VPD_LTIN_ID_STRING          0x02    /* Identifier String */
+#define PCI_VPD_LTIN_RO_DATA            0x10    /* Read-Only Data */
+#define PCI_VPD_LTIN_RW_DATA            0x11    /* Read-Write Data */
+
+#define PCI_VPD_LRDT_ID_STRING          PCI_VPD_LRDT_ID(PCI_VPD_LTIN_ID_STRING)
+#define PCI_VPD_LRDT_RO_DATA            PCI_VPD_LRDT_ID(PCI_VPD_LTIN_RO_DATA)
+#define PCI_VPD_LRDT_RW_DATA            PCI_VPD_LRDT_ID(PCI_VPD_LTIN_RW_DATA)
+
+/* Small Resource Data Type Tag Item Names */
+#define PCI_VPD_STIN_END                0x78    /* End */
+
+#define PCI_VPD_SRDT_END                PCI_VPD_STIN_END
+
+#define PCI_VPD_SRDT_TIN_MASK           0x78
+#define PCI_VPD_SRDT_LEN_MASK           0x07
+
+#define PCI_VPD_LRDT_TAG_SIZE           3
+#define PCI_VPD_SRDT_TAG_SIZE           1
+
+#define PCI_VPD_INFO_FLD_HDR_SIZE       3
+
+#define PCI_VPD_RO_KEYWORD_PARTNO       "PN"
+#define PCI_VPD_RO_KEYWORD_MFR_ID       "MN"
+#define PCI_VPD_RO_KEYWORD_VENDOR0      "V0"
+#define PCI_VPD_RO_KEYWORD_CHKSUM       "RV"
+
+static inline u16 efx_pci_vpd_lrdt_size(const u8 *lrdt)
+{
+	return (u16)lrdt[1] + ((u16)lrdt[2] << 8);
+}
+#undef pci_vpd_lrdt_size
+#define pci_vpd_lrdt_size efx_pci_vpd_lrdt_size
+
+static inline u8 efx_pci_vpd_srdt_size(const u8 *srdt)
+{
+	return (*srdt) & PCI_VPD_SRDT_LEN_MASK;
+}
+#undef pci_vpd_srdt_size
+#define pci_vpd_srdt_size efx_pci_vpd_srdt_size
+
+static inline u8 efx_pci_vpd_info_field_size(const u8 *info_field)
+{
+	return info_field[2];
+}
+#undef pci_vpd_info_field_size
+#define pci_vpd_info_field_size efx_pci_vpd_info_field_size
+
+int efx_pci_vpd_find_tag(const u8 *buf, unsigned int off, unsigned int len, u8 rdt);
+#undef pci_vpd_find_tag
+#define pci_vpd_find_tag efx_pci_vpd_find_tag
+
+int efx_pci_vpd_find_info_keyword(const u8 *buf, unsigned int off,
+				  unsigned int len, const char *kw);
+#undef pci_vpd_find_info_keyword
+#define pci_vpd_find_info_keyword efx_pci_vpd_find_info_keyword
+
+#endif /* EFX_KERNEL_COMPAT_H */
diff -r 9566a4a50a43 drivers/net/sfc/linux_mdio.c
--- /dev/null
+++ b/drivers/net/sfc/linux_mdio.c
@@ -0,0 +1,448 @@
+/*
+ * mdio.c: Generic support for MDIO-compatible transceivers
+ * Copyright 2006-2009 Solarflare Communications Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 as published
+ * by the Free Software Foundation, incorporated herein by reference.
+ */
+
+#include "config.h"
+#include "kernel_compat.h"
+
+#if defined(CONFIG_SFC_PRIVATE_MDIO) || (!defined(CONFIG_MDIO) && !defined(CONFIG_MDIO_MODULE))
+
+#include <linux/kernel.h>
+#include <linux/capability.h>
+#include <linux/errno.h>
+#include <linux/ethtool.h>
+#include "linux_mdio.h"
+#include <linux/module.h>
+
+/**
+ * mdio45_probe - probe for an MDIO (clause 45) device
+ * @mdio: MDIO interface
+ * @prtad: Expected PHY address
+ *
+ * This sets @prtad and @mmds in the MDIO interface if successful.
+ * Returns 0 on success, negative on error.
+ */
+int mdio45_probe(struct mdio_if_info *mdio, int prtad)
+{
+	int mmd, stat2, devs1, devs2;
+
+	/* Assume PHY must have at least one of PMA/PMD, WIS, PCS, PHY
+	 * XS or DTE XS; give up if none is present. */
+	for (mmd = 1; mmd <= 5; mmd++) {
+		/* Is this MMD present? */
+		stat2 = mdio->mdio_read(mdio->dev, prtad, mmd, MDIO_STAT2);
+		if (stat2 < 0 ||
+		    (stat2 & MDIO_STAT2_DEVPRST) != MDIO_STAT2_DEVPRST_VAL)
+			continue;
+
+		/* It should tell us about all the other MMDs */
+		devs1 = mdio->mdio_read(mdio->dev, prtad, mmd, MDIO_DEVS1);
+		devs2 = mdio->mdio_read(mdio->dev, prtad, mmd, MDIO_DEVS2);
+		if (devs1 < 0 || devs2 < 0)
+			continue;
+
+		mdio->prtad = prtad;
+		mdio->mmds = devs1 | (devs2 << 16);
+		return 0;
+	}
+
+	return -ENODEV;
+}
+/*EXPORT_SYMBOL(mdio45_probe);*/
+
+/**
+ * mdio_set_flag - set or clear flag in an MDIO register
+ * @mdio: MDIO interface
+ * @prtad: PHY address
+ * @devad: MMD address
+ * @addr: Register address
+ * @mask: Mask for flag (single bit set)
+ * @sense: New value of flag
+ *
+ * This debounces changes: it does not write the register if the flag
+ * already has the proper value.  Returns 0 on success, negative on error.
+ */
+int mdio_set_flag(const struct mdio_if_info *mdio,
+		  int prtad, int devad, u16 addr, int mask,
+		  bool sense)
+{
+	int old_val = mdio->mdio_read(mdio->dev, prtad, devad, addr);
+	int new_val;
+
+	if (old_val < 0)
+		return old_val;
+	if (sense)
+		new_val = old_val | mask;
+	else
+		new_val = old_val & ~mask;
+	if (old_val == new_val)
+		return 0;
+	return mdio->mdio_write(mdio->dev, prtad, devad, addr, new_val);
+}
+/*EXPORT_SYMBOL(mdio_set_flag);*/
+
+/**
+ * mdio_link_ok - is link status up/OK
+ * @mdio: MDIO interface
+ * @mmd_mask: Mask for MMDs to check
+ *
+ * Returns 1 if the PHY reports link status up/OK, 0 otherwise.
+ * @mmd_mask is normally @mdio->mmds, but if loopback is enabled
+ * the MMDs being bypassed should be excluded from the mask.
+ */
+int mdio45_links_ok(const struct mdio_if_info *mdio, u32 mmd_mask)
+{
+	int devad, reg;
+
+	if (!mmd_mask) {
+		/* Use absence of XGMII faults in lieu of link state */
+		reg = mdio->mdio_read(mdio->dev, mdio->prtad,
+				      MDIO_MMD_PHYXS, MDIO_STAT2);
+		return reg >= 0 && !(reg & MDIO_STAT2_RXFAULT);
+	}
+
+	for (devad = 0; mmd_mask; devad++) {
+		if (mmd_mask & (1 << devad)) {
+			mmd_mask &= ~(1 << devad);
+
+			/* Reset the latched status and fault flags */
+			mdio->mdio_read(mdio->dev, mdio->prtad,
+					devad, MDIO_STAT1);
+			if (devad == MDIO_MMD_PMAPMD || devad == MDIO_MMD_PCS ||
+			    devad == MDIO_MMD_PHYXS || devad == MDIO_MMD_DTEXS)
+				mdio->mdio_read(mdio->dev, mdio->prtad,
+						devad, MDIO_STAT2);
+
+			/* Check the current status and fault flags */
+			reg = mdio->mdio_read(mdio->dev, mdio->prtad,
+					      devad, MDIO_STAT1);
+			if (reg < 0 ||
+			    (reg & (MDIO_STAT1_FAULT | MDIO_STAT1_LSTATUS)) !=
+			    MDIO_STAT1_LSTATUS)
+				return false;
+		}
+	}
+
+	return true;
+}
+/*EXPORT_SYMBOL(mdio45_links_ok);*/
+
+/**
+ * mdio45_nway_restart - restart auto-negotiation for this interface
+ * @mdio: MDIO interface
+ *
+ * Returns 0 on success, negative on error.
+ */
+int mdio45_nway_restart(const struct mdio_if_info *mdio)
+{
+	if (!(mdio->mmds & MDIO_DEVS_AN))
+		return -EOPNOTSUPP;
+
+	mdio_set_flag(mdio, mdio->prtad, MDIO_MMD_AN, MDIO_CTRL1,
+		      MDIO_AN_CTRL1_RESTART, true);
+	return 0;
+}
+/*EXPORT_SYMBOL(mdio45_nway_restart);*/
+
+static u32 mdio45_get_an(const struct mdio_if_info *mdio, u16 addr)
+{
+	u32 result = 0;
+	int reg;
+
+	reg = mdio->mdio_read(mdio->dev, mdio->prtad, MDIO_MMD_AN, addr);
+	if (reg & ADVERTISE_10HALF)
+		result |= ADVERTISED_10baseT_Half;
+	if (reg & ADVERTISE_10FULL)
+		result |= ADVERTISED_10baseT_Full;
+	if (reg & ADVERTISE_100HALF)
+		result |= ADVERTISED_100baseT_Half;
+	if (reg & ADVERTISE_100FULL)
+		result |= ADVERTISED_100baseT_Full;
+	if (reg & ADVERTISE_PAUSE_CAP)
+		result |= ADVERTISED_Pause;
+	if (reg & ADVERTISE_PAUSE_ASYM)
+		result |= ADVERTISED_Asym_Pause;
+	return result;
+}
+
+/**
+ * mdio45_ethtool_gset_npage - get settings for ETHTOOL_GSET
+ * @mdio: MDIO interface
+ * @ecmd: Ethtool request structure
+ * @npage_adv: Modes currently advertised on next pages
+ * @npage_lpa: Modes advertised by link partner on next pages
+ *
+ * Since the CSRs for auto-negotiation using next pages are not fully
+ * standardised, this function does not attempt to decode them.  The
+ * caller must pass them in.
+ */
+void mdio45_ethtool_gset_npage(const struct mdio_if_info *mdio,
+			       struct ethtool_cmd *ecmd,
+			       u32 npage_adv, u32 npage_lpa)
+{
+	int reg;
+
+	ecmd->transceiver = XCVR_INTERNAL;
+	ecmd->phy_address = mdio->prtad;
+	ecmd->mdio_support =
+		mdio->mode_support & (MDIO_SUPPORTS_C45 | MDIO_SUPPORTS_C22);
+
+	reg = mdio->mdio_read(mdio->dev, mdio->prtad, MDIO_MMD_PMAPMD,
+			      MDIO_CTRL2);
+	switch (reg & MDIO_PMA_CTRL2_TYPE) {
+	case MDIO_PMA_CTRL2_10GBT:
+	case MDIO_PMA_CTRL2_1000BT:
+	case MDIO_PMA_CTRL2_100BTX:
+	case MDIO_PMA_CTRL2_10BT:
+		ecmd->port = PORT_TP;
+		ecmd->supported = SUPPORTED_TP;
+		reg = mdio->mdio_read(mdio->dev, mdio->prtad, MDIO_MMD_PMAPMD,
+				      MDIO_SPEED);
+		if (reg & MDIO_SPEED_10G)
+			ecmd->supported |= SUPPORTED_10000baseT_Full;
+		if (reg & MDIO_PMA_SPEED_1000)
+			ecmd->supported |= (SUPPORTED_1000baseT_Full |
+					    SUPPORTED_1000baseT_Half);
+		if (reg & MDIO_PMA_SPEED_100)
+			ecmd->supported |= (SUPPORTED_100baseT_Full |
+					    SUPPORTED_100baseT_Half);
+		if (reg & MDIO_PMA_SPEED_10)
+			ecmd->supported |= (SUPPORTED_10baseT_Full |
+					    SUPPORTED_10baseT_Half);
+		ecmd->advertising = ADVERTISED_TP;
+		break;
+
+	case MDIO_PMA_CTRL2_10GBCX4:
+		ecmd->port = PORT_OTHER;
+		ecmd->supported = 0;
+		ecmd->advertising = 0;
+		break;
+
+/*
+	case MDIO_PMA_CTRL2_10GBKX4:
+	case MDIO_PMA_CTRL2_10GBKR:
+	case MDIO_PMA_CTRL2_1000BKX:
+		ecmd->port = PORT_OTHER;
+		ecmd->supported = SUPPORTED_Backplane;
+		reg = mdio->mdio_read(mdio->dev, mdio->prtad, MDIO_MMD_PMAPMD,
+				      MDIO_PMA_EXTABLE);
+		if (reg & MDIO_PMA_EXTABLE_10GBKX4)
+			ecmd->supported |= SUPPORTED_10000baseKX4_Full;
+		if (reg & MDIO_PMA_EXTABLE_10GBKR)
+			ecmd->supported |= SUPPORTED_10000baseKR_Full;
+		if (reg & MDIO_PMA_EXTABLE_1000BKX)
+			ecmd->supported |= SUPPORTED_1000baseKX_Full;
+		reg = mdio->mdio_read(mdio->dev, mdio->prtad, MDIO_MMD_PMAPMD,
+				      MDIO_PMA_10GBR_FECABLE);
+		if (reg & MDIO_PMA_10GBR_FECABLE_ABLE)
+			ecmd->supported |= SUPPORTED_10000baseR_FEC;
+		ecmd->advertising = ADVERTISED_Backplane;
+		break;
+*/
+
+	/* All the other defined modes are flavours of optical */
+	default:
+		ecmd->port = PORT_FIBRE;
+		ecmd->supported = SUPPORTED_FIBRE;
+		ecmd->advertising = ADVERTISED_FIBRE;
+		break;
+	}
+
+	if (mdio->mmds & MDIO_DEVS_AN) {
+		ecmd->supported |= SUPPORTED_Autoneg;
+		reg = mdio->mdio_read(mdio->dev, mdio->prtad, MDIO_MMD_AN,
+				      MDIO_CTRL1);
+		if (reg & MDIO_AN_CTRL1_ENABLE) {
+			ecmd->autoneg = AUTONEG_ENABLE;
+			ecmd->advertising |=
+				ADVERTISED_Autoneg |
+				mdio45_get_an(mdio, MDIO_AN_ADVERTISE) |
+				npage_adv;
+		} else {
+			ecmd->autoneg = AUTONEG_DISABLE;
+		}
+	} else {
+		ecmd->autoneg = AUTONEG_DISABLE;
+	}
+
+	if (ecmd->autoneg) {
+		u32 modes = 0;
+		int an_stat = mdio->mdio_read(mdio->dev, mdio->prtad,
+					      MDIO_MMD_AN, MDIO_STAT1);
+
+		/* If AN is complete and successful, report best common
+		 * mode, otherwise report best advertised mode. */
+		if (an_stat & MDIO_AN_STAT1_COMPLETE) {
+			u32 lp_advertising;
+			lp_advertising =
+				mdio45_get_an(mdio, MDIO_AN_LPA) | npage_lpa;
+			if (an_stat & MDIO_AN_STAT1_LPABLE)
+				lp_advertising |= ADVERTISED_Autoneg;
+			modes = ecmd->advertising & lp_advertising;
+			ecmd->lp_advertising = lp_advertising;
+		}
+		if ((modes & ~ADVERTISED_Autoneg) == 0)
+			modes = ecmd->advertising;
+
+		if (modes & (ADVERTISED_10000baseT_Full/* |
+			     ADVERTISED_10000baseKX4_Full |
+			     ADVERTISED_10000baseKR_Full*/)) {
+			ecmd->speed = SPEED_10000;
+			ecmd->duplex = DUPLEX_FULL;
+		} else if (modes & (ADVERTISED_1000baseT_Full |
+				    ADVERTISED_1000baseT_Half/* |
+				    ADVERTISED_1000baseKX_Full*/)) {
+			ecmd->speed = SPEED_1000;
+			ecmd->duplex = !(modes & ADVERTISED_1000baseT_Half);
+		} else if (modes & (ADVERTISED_100baseT_Full |
+				    ADVERTISED_100baseT_Half)) {
+			ecmd->speed = SPEED_100;
+			ecmd->duplex = !!(modes & ADVERTISED_100baseT_Full);
+		} else {
+			ecmd->speed = SPEED_10;
+			ecmd->duplex = !!(modes & ADVERTISED_10baseT_Full);
+		}
+	} else {
+		/* Report forced settings */
+		reg = mdio->mdio_read(mdio->dev, mdio->prtad, MDIO_MMD_PMAPMD,
+				      MDIO_CTRL1);
+		ecmd->speed = (((reg & MDIO_PMA_CTRL1_SPEED1000) ? 100 : 1) *
+			       ((reg & MDIO_PMA_CTRL1_SPEED100) ? 100 : 10));
+		ecmd->duplex = (reg & MDIO_CTRL1_FULLDPLX ||
+				ecmd->speed == SPEED_10000);
+	}
+
+	/* 10GBASE-T MDI/MDI-X */
+	if (ecmd->port == PORT_TP && ecmd->speed == SPEED_10000) {
+		switch (mdio->mdio_read(mdio->dev, mdio->prtad, MDIO_MMD_PMAPMD,
+					MDIO_PMA_10GBT_SWAPPOL)) {
+		case MDIO_PMA_10GBT_SWAPPOL_ABNX | MDIO_PMA_10GBT_SWAPPOL_CDNX:
+			ecmd->eth_tp_mdix = ETH_TP_MDI;
+			break;
+		case 0:
+			ecmd->eth_tp_mdix = ETH_TP_MDI_X;
+			break;
+		default:
+			/* It's complicated... */
+			ecmd->eth_tp_mdix = ETH_TP_MDI_INVALID;
+			break;
+		}
+	}
+}
+/*EXPORT_SYMBOL(mdio45_ethtool_gset_npage);*/
+
+/**
+ * mdio45_ethtool_spauseparam_an - set auto-negotiated pause parameters
+ * @mdio: MDIO interface
+ * @ecmd: Ethtool request structure
+ *
+ * This function assumes that the PHY has an auto-negotiation MMD.  It
+ * will enable and disable advertising of flow control as appropriate.
+ */
+void mdio45_ethtool_spauseparam_an(const struct mdio_if_info *mdio,
+				   const struct ethtool_pauseparam *ecmd)
+{
+	int adv, old_adv;
+
+	WARN_ON(!(mdio->mmds & MDIO_DEVS_AN));
+
+	old_adv = mdio->mdio_read(mdio->dev, mdio->prtad, MDIO_MMD_AN,
+				  MDIO_AN_ADVERTISE);
+	adv = ((old_adv & ~(ADVERTISE_PAUSE_CAP | ADVERTISE_PAUSE_ASYM)) |
+	       mii_advertise_flowctrl((ecmd->rx_pause ? FLOW_CTRL_RX : 0) |
+				      (ecmd->tx_pause ? FLOW_CTRL_TX : 0)));
+	if (adv != old_adv) {
+		mdio->mdio_write(mdio->dev, mdio->prtad, MDIO_MMD_AN,
+				 MDIO_AN_ADVERTISE, adv);
+		mdio45_nway_restart(mdio);
+	}
+}
+/*EXPORT_SYMBOL(mdio45_ethtool_spauseparam_an);*/
+
+/**
+ * mdio_mii_ioctl - MII ioctl interface for MDIO (clause 22 or 45) PHYs
+ * @mdio: MDIO interface
+ * @mii_data: MII ioctl data structure
+ * @cmd: MII ioctl command
+ *
+ * Returns 0 on success, negative on error.
+ */
+int mdio_mii_ioctl(const struct mdio_if_info *mdio,
+		   struct mii_ioctl_data *mii_data, int cmd)
+{
+	int prtad, devad;
+	u16 addr = mii_data->reg_num;
+
+	/* Validate/convert cmd to one of SIOC{G,S}MIIREG */
+	switch (cmd) {
+	case SIOCGMIIPHY:
+		if (mdio->prtad == MDIO_PRTAD_NONE)
+			return -EOPNOTSUPP;
+		mii_data->phy_id = mdio->prtad;
+		cmd = SIOCGMIIREG;
+		break;
+	case SIOCGMIIREG:
+	case SIOCSMIIREG:
+		break;
+	default:
+		return -EOPNOTSUPP;
+	}
+
+	/* Validate/convert phy_id */
+	if ((mdio->mode_support & MDIO_SUPPORTS_C45) &&
+	    mdio_phy_id_is_c45(mii_data->phy_id)) {
+		prtad = mdio_phy_id_prtad(mii_data->phy_id);
+		devad = mdio_phy_id_devad(mii_data->phy_id);
+	} else if ((mdio->mode_support & MDIO_SUPPORTS_C22) &&
+		   mii_data->phy_id < 0x20) {
+		prtad = mii_data->phy_id;
+		devad = MDIO_DEVAD_NONE;
+		addr &= 0x1f;
+	} else if ((mdio->mode_support & MDIO_EMULATE_C22) &&
+		   mdio->prtad != MDIO_PRTAD_NONE &&
+		   mii_data->phy_id == mdio->prtad) {
+		/* Remap commonly-used MII registers. */
+		prtad = mdio->prtad;
+		switch (addr) {
+		case MII_BMCR:
+		case MII_BMSR:
+		case MII_PHYSID1:
+		case MII_PHYSID2:
+			devad = __ffs(mdio->mmds);
+			break;
+		case MII_ADVERTISE:
+		case MII_LPA:
+			if (!(mdio->mmds & MDIO_DEVS_AN))
+				return -EINVAL;
+			devad = MDIO_MMD_AN;
+			if (addr == MII_ADVERTISE)
+				addr = MDIO_AN_ADVERTISE;
+			else
+				addr = MDIO_AN_LPA;
+			break;
+		default:
+			return -EINVAL;
+		}
+	} else {
+		return -EINVAL;
+	}
+
+	if (cmd == SIOCGMIIREG) {
+		int rc = mdio->mdio_read(mdio->dev, prtad, devad, addr);
+		if (rc < 0)
+			return rc;
+		mii_data->val_out = rc;
+		return 0;
+	} else {
+		return mdio->mdio_write(mdio->dev, prtad, devad, addr,
+					mii_data->val_in);
+	}
+}
+/*EXPORT_SYMBOL(mdio_mii_ioctl);*/
+
+#endif /* !CONFIG_MDIO && !CONFIG_MDIO_MODULE */
diff -r 9566a4a50a43 drivers/net/sfc/linux_mdio.h
--- /dev/null
+++ b/drivers/net/sfc/linux_mdio.h
@@ -0,0 +1,356 @@
+/*
+ * linux/mdio.h: definitions for MDIO (clause 45) transceivers
+ * Copyright 2006-2009 Solarflare Communications Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 as published
+ * by the Free Software Foundation, incorporated herein by reference.
+ */
+
+#ifndef __LINUX_MDIO_H__
+#define __LINUX_MDIO_H__
+
+#include <linux/mii.h>
+
+/* MDIO Manageable Devices (MMDs). */
+#define MDIO_MMD_PMAPMD		1	/* Physical Medium Attachment/
+					 * Physical Medium Dependent */
+#define MDIO_MMD_WIS		2	/* WAN Interface Sublayer */
+#define MDIO_MMD_PCS		3	/* Physical Coding Sublayer */
+#define MDIO_MMD_PHYXS		4	/* PHY Extender Sublayer */
+#define MDIO_MMD_DTEXS		5	/* DTE Extender Sublayer */
+#define MDIO_MMD_TC		6	/* Transmission Convergence */
+#define MDIO_MMD_AN		7	/* Auto-Negotiation */
+#define MDIO_MMD_C22EXT		29	/* Clause 22 extension */
+#define MDIO_MMD_VEND1		30	/* Vendor specific 1 */
+#define MDIO_MMD_VEND2		31	/* Vendor specific 2 */
+
+/* Generic MDIO registers. */
+#define MDIO_CTRL1		MII_BMCR
+#define MDIO_STAT1		MII_BMSR
+#define MDIO_DEVID1		MII_PHYSID1
+#define MDIO_DEVID2		MII_PHYSID2
+#define MDIO_SPEED		4	/* Speed ability */
+#define MDIO_DEVS1		5	/* Devices in package */
+#define MDIO_DEVS2		6
+#define MDIO_CTRL2		7	/* 10G control 2 */
+#define MDIO_STAT2		8	/* 10G status 2 */
+#define MDIO_PMA_TXDIS		9	/* 10G PMA/PMD transmit disable */
+#define MDIO_PMA_RXDET		10	/* 10G PMA/PMD receive signal detect */
+#define MDIO_PMA_EXTABLE	11	/* 10G PMA/PMD extended ability */
+#define MDIO_PKGID1		14	/* Package identifier */
+#define MDIO_PKGID2		15
+#define MDIO_AN_ADVERTISE	16	/* AN advertising (base page) */
+#define MDIO_AN_LPA		19	/* AN LP abilities (base page) */
+#define MDIO_PHYXS_LNSTAT	24	/* PHY XGXS lane state */
+
+/* Media-dependent registers. */
+#define MDIO_PMA_10GBT_SWAPPOL	130	/* 10GBASE-T pair swap & polarity */
+#define MDIO_PMA_10GBT_TXPWR	131	/* 10GBASE-T TX power control */
+#define MDIO_PMA_10GBT_SNR	133	/* 10GBASE-T SNR margin, lane A.
+					 * Lanes B-D are numbered 134-136. */
+#define MDIO_PMA_10GBR_FECABLE	170	/* 10GBASE-R FEC ability */
+#define MDIO_PCS_10GBX_STAT1	24	/* 10GBASE-X PCS status 1 */
+#define MDIO_PCS_10GBRT_STAT1	32	/* 10GBASE-R/-T PCS status 1 */
+#define MDIO_PCS_10GBRT_STAT2	33	/* 10GBASE-R/-T PCS status 2 */
+#define MDIO_AN_10GBT_CTRL	32	/* 10GBASE-T auto-negotiation control */
+#define MDIO_AN_10GBT_STAT	33	/* 10GBASE-T auto-negotiation status */
+
+/* LASI (Link Alarm Status Interrupt) registers, defined by XENPAK MSA. */
+#define MDIO_PMA_LASI_RXCTRL	0x9000	/* RX_ALARM control */
+#define MDIO_PMA_LASI_TXCTRL	0x9001	/* TX_ALARM control */
+#define MDIO_PMA_LASI_CTRL	0x9002	/* LASI control */
+#define MDIO_PMA_LASI_RXSTAT	0x9003	/* RX_ALARM status */
+#define MDIO_PMA_LASI_TXSTAT	0x9004	/* TX_ALARM status */
+#define MDIO_PMA_LASI_STAT	0x9005	/* LASI status */
+
+/* Control register 1. */
+/* Enable extended speed selection */
+#define MDIO_CTRL1_SPEEDSELEXT		(BMCR_SPEED1000 | BMCR_SPEED100)
+/* All speed selection bits */
+#define MDIO_CTRL1_SPEEDSEL		(MDIO_CTRL1_SPEEDSELEXT | 0x003c)
+#define MDIO_CTRL1_FULLDPLX		BMCR_FULLDPLX
+#define MDIO_CTRL1_LPOWER		BMCR_PDOWN
+#define MDIO_CTRL1_RESET		BMCR_RESET
+#define MDIO_PMA_CTRL1_LOOPBACK		0x0001
+#define MDIO_PMA_CTRL1_SPEED1000	BMCR_SPEED1000
+#define MDIO_PMA_CTRL1_SPEED100		BMCR_SPEED100
+#define MDIO_PCS_CTRL1_LOOPBACK		BMCR_LOOPBACK
+#define MDIO_PHYXS_CTRL1_LOOPBACK	BMCR_LOOPBACK
+#define MDIO_AN_CTRL1_RESTART		BMCR_ANRESTART
+#define MDIO_AN_CTRL1_ENABLE		BMCR_ANENABLE
+#define MDIO_AN_CTRL1_XNP		0x2000	/* Enable extended next page */
+
+/* 10 Gb/s */
+#define MDIO_CTRL1_SPEED10G		(MDIO_CTRL1_SPEEDSELEXT | 0x00)
+/* 10PASS-TS/2BASE-TL */
+#define MDIO_CTRL1_SPEED10P2B		(MDIO_CTRL1_SPEEDSELEXT | 0x04)
+
+/* Status register 1. */
+#define MDIO_STAT1_LPOWERABLE		0x0002	/* Low-power ability */
+#define MDIO_STAT1_LSTATUS		BMSR_LSTATUS
+#define MDIO_STAT1_FAULT		0x0080	/* Fault */
+#define MDIO_AN_STAT1_LPABLE		0x0001	/* Link partner AN ability */
+#define MDIO_AN_STAT1_ABLE		BMSR_ANEGCAPABLE
+#define MDIO_AN_STAT1_RFAULT		BMSR_RFAULT
+#define MDIO_AN_STAT1_COMPLETE		BMSR_ANEGCOMPLETE
+#define MDIO_AN_STAT1_PAGE		0x0040	/* Page received */
+#define MDIO_AN_STAT1_XNP		0x0080	/* Extended next page status */
+
+/* Speed register. */
+#define MDIO_SPEED_10G			0x0001	/* 10G capable */
+#define MDIO_PMA_SPEED_2B		0x0002	/* 2BASE-TL capable */
+#define MDIO_PMA_SPEED_10P		0x0004	/* 10PASS-TS capable */
+#define MDIO_PMA_SPEED_1000		0x0010	/* 1000M capable */
+#define MDIO_PMA_SPEED_100		0x0020	/* 100M capable */
+#define MDIO_PMA_SPEED_10		0x0040	/* 10M capable */
+#define MDIO_PCS_SPEED_10P2B		0x0002	/* 10PASS-TS/2BASE-TL capable */
+
+/* Device present registers. */
+#define MDIO_DEVS_PRESENT(devad)	(1 << (devad))
+#define MDIO_DEVS_PMAPMD		MDIO_DEVS_PRESENT(MDIO_MMD_PMAPMD)
+#define MDIO_DEVS_WIS			MDIO_DEVS_PRESENT(MDIO_MMD_WIS)
+#define MDIO_DEVS_PCS			MDIO_DEVS_PRESENT(MDIO_MMD_PCS)
+#define MDIO_DEVS_PHYXS			MDIO_DEVS_PRESENT(MDIO_MMD_PHYXS)
+#define MDIO_DEVS_DTEXS			MDIO_DEVS_PRESENT(MDIO_MMD_DTEXS)
+#define MDIO_DEVS_TC			MDIO_DEVS_PRESENT(MDIO_MMD_TC)
+#define MDIO_DEVS_AN			MDIO_DEVS_PRESENT(MDIO_MMD_AN)
+#define MDIO_DEVS_C22EXT		MDIO_DEVS_PRESENT(MDIO_MMD_C22EXT)
+
+/* Control register 2. */
+#define MDIO_PMA_CTRL2_TYPE		0x000f	/* PMA/PMD type selection */
+#define MDIO_PMA_CTRL2_10GBCX4		0x0000	/* 10GBASE-CX4 type */
+#define MDIO_PMA_CTRL2_10GBEW		0x0001	/* 10GBASE-EW type */
+#define MDIO_PMA_CTRL2_10GBLW		0x0002	/* 10GBASE-LW type */
+#define MDIO_PMA_CTRL2_10GBSW		0x0003	/* 10GBASE-SW type */
+#define MDIO_PMA_CTRL2_10GBLX4		0x0004	/* 10GBASE-LX4 type */
+#define MDIO_PMA_CTRL2_10GBER		0x0005	/* 10GBASE-ER type */
+#define MDIO_PMA_CTRL2_10GBLR		0x0006	/* 10GBASE-LR type */
+#define MDIO_PMA_CTRL2_10GBSR		0x0007	/* 10GBASE-SR type */
+#define MDIO_PMA_CTRL2_10GBLRM		0x0008	/* 10GBASE-LRM type */
+#define MDIO_PMA_CTRL2_10GBT		0x0009	/* 10GBASE-T type */
+#define MDIO_PMA_CTRL2_10GBKX4		0x000a	/* 10GBASE-KX4 type */
+#define MDIO_PMA_CTRL2_10GBKR		0x000b	/* 10GBASE-KR type */
+#define MDIO_PMA_CTRL2_1000BT		0x000c	/* 1000BASE-T type */
+#define MDIO_PMA_CTRL2_1000BKX		0x000d	/* 1000BASE-KX type */
+#define MDIO_PMA_CTRL2_100BTX		0x000e	/* 100BASE-TX type */
+#define MDIO_PMA_CTRL2_10BT		0x000f	/* 10BASE-T type */
+#define MDIO_PCS_CTRL2_TYPE		0x0003	/* PCS type selection */
+#define MDIO_PCS_CTRL2_10GBR		0x0000	/* 10GBASE-R type */
+#define MDIO_PCS_CTRL2_10GBX		0x0001	/* 10GBASE-X type */
+#define MDIO_PCS_CTRL2_10GBW		0x0002	/* 10GBASE-W type */
+#define MDIO_PCS_CTRL2_10GBT		0x0003	/* 10GBASE-T type */
+
+/* Status register 2. */
+#define MDIO_STAT2_RXFAULT		0x0400	/* Receive fault */
+#define MDIO_STAT2_TXFAULT		0x0800	/* Transmit fault */
+#define MDIO_STAT2_DEVPRST		0xc000	/* Device present */
+#define MDIO_STAT2_DEVPRST_VAL		0x8000	/* Device present value */
+#define MDIO_PMA_STAT2_LBABLE		0x0001	/* PMA loopback ability */
+#define MDIO_PMA_STAT2_10GBEW		0x0002	/* 10GBASE-EW ability */
+#define MDIO_PMA_STAT2_10GBLW		0x0004	/* 10GBASE-LW ability */
+#define MDIO_PMA_STAT2_10GBSW		0x0008	/* 10GBASE-SW ability */
+#define MDIO_PMA_STAT2_10GBLX4		0x0010	/* 10GBASE-LX4 ability */
+#define MDIO_PMA_STAT2_10GBER		0x0020	/* 10GBASE-ER ability */
+#define MDIO_PMA_STAT2_10GBLR		0x0040	/* 10GBASE-LR ability */
+#define MDIO_PMA_STAT2_10GBSR		0x0080	/* 10GBASE-SR ability */
+#define MDIO_PMD_STAT2_TXDISAB		0x0100	/* PMD TX disable ability */
+#define MDIO_PMA_STAT2_EXTABLE		0x0200	/* Extended abilities */
+#define MDIO_PMA_STAT2_RXFLTABLE	0x1000	/* Receive fault ability */
+#define MDIO_PMA_STAT2_TXFLTABLE	0x2000	/* Transmit fault ability */
+#define MDIO_PCS_STAT2_10GBR		0x0001	/* 10GBASE-R capable */
+#define MDIO_PCS_STAT2_10GBX		0x0002	/* 10GBASE-X capable */
+#define MDIO_PCS_STAT2_10GBW		0x0004	/* 10GBASE-W capable */
+#define MDIO_PCS_STAT2_RXFLTABLE	0x1000	/* Receive fault ability */
+#define MDIO_PCS_STAT2_TXFLTABLE	0x2000	/* Transmit fault ability */
+
+/* Transmit disable register. */
+#define MDIO_PMD_TXDIS_GLOBAL		0x0001	/* Global PMD TX disable */
+#define MDIO_PMD_TXDIS_0		0x0002	/* PMD TX disable 0 */
+#define MDIO_PMD_TXDIS_1		0x0004	/* PMD TX disable 1 */
+#define MDIO_PMD_TXDIS_2		0x0008	/* PMD TX disable 2 */
+#define MDIO_PMD_TXDIS_3		0x0010	/* PMD TX disable 3 */
+
+/* Receive signal detect register. */
+#define MDIO_PMD_RXDET_GLOBAL		0x0001	/* Global PMD RX signal detect */
+#define MDIO_PMD_RXDET_0		0x0002	/* PMD RX signal detect 0 */
+#define MDIO_PMD_RXDET_1		0x0004	/* PMD RX signal detect 1 */
+#define MDIO_PMD_RXDET_2		0x0008	/* PMD RX signal detect 2 */
+#define MDIO_PMD_RXDET_3		0x0010	/* PMD RX signal detect 3 */
+
+/* Extended abilities register. */
+#define MDIO_PMA_EXTABLE_10GCX4		0x0001	/* 10GBASE-CX4 ability */
+#define MDIO_PMA_EXTABLE_10GBLRM	0x0002	/* 10GBASE-LRM ability */
+#define MDIO_PMA_EXTABLE_10GBT		0x0004	/* 10GBASE-T ability */
+#define MDIO_PMA_EXTABLE_10GBKX4	0x0008	/* 10GBASE-KX4 ability */
+#define MDIO_PMA_EXTABLE_10GBKR		0x0010	/* 10GBASE-KR ability */
+#define MDIO_PMA_EXTABLE_1000BT		0x0020	/* 1000BASE-T ability */
+#define MDIO_PMA_EXTABLE_1000BKX	0x0040	/* 1000BASE-KX ability */
+#define MDIO_PMA_EXTABLE_100BTX		0x0080	/* 100BASE-TX ability */
+#define MDIO_PMA_EXTABLE_10BT		0x0100	/* 10BASE-T ability */
+
+/* PHY XGXS lane state register. */
+#define MDIO_PHYXS_LNSTAT_SYNC0		0x0001
+#define MDIO_PHYXS_LNSTAT_SYNC1		0x0002
+#define MDIO_PHYXS_LNSTAT_SYNC2		0x0004
+#define MDIO_PHYXS_LNSTAT_SYNC3		0x0008
+#define MDIO_PHYXS_LNSTAT_ALIGN		0x1000
+
+/* PMA 10GBASE-T pair swap & polarity */
+#define MDIO_PMA_10GBT_SWAPPOL_ABNX	0x0001	/* Pair A/B uncrossed */
+#define MDIO_PMA_10GBT_SWAPPOL_CDNX	0x0002	/* Pair C/D uncrossed */
+#define MDIO_PMA_10GBT_SWAPPOL_AREV	0x0100	/* Pair A polarity reversed */
+#define MDIO_PMA_10GBT_SWAPPOL_BREV	0x0200	/* Pair B polarity reversed */
+#define MDIO_PMA_10GBT_SWAPPOL_CREV	0x0400	/* Pair C polarity reversed */
+#define MDIO_PMA_10GBT_SWAPPOL_DREV	0x0800	/* Pair D polarity reversed */
+
+/* PMA 10GBASE-T TX power register. */
+#define MDIO_PMA_10GBT_TXPWR_SHORT	0x0001	/* Short-reach mode */
+
+/* PMA 10GBASE-T SNR registers. */
+/* Value is SNR margin in dB, clamped to range [-127, 127], plus 0x8000. */
+#define MDIO_PMA_10GBT_SNR_BIAS		0x8000
+#define MDIO_PMA_10GBT_SNR_MAX		127
+
+/* PMA 10GBASE-R FEC ability register. */
+#define MDIO_PMA_10GBR_FECABLE_ABLE	0x0001	/* FEC ability */
+#define MDIO_PMA_10GBR_FECABLE_ERRABLE	0x0002	/* FEC error indic. ability */
+
+/* PCS 10GBASE-R/-T status register 1. */
+#define MDIO_PCS_10GBRT_STAT1_BLKLK	0x0001	/* Block lock attained */
+
+/* PCS 10GBASE-R/-T status register 2. */
+#define MDIO_PCS_10GBRT_STAT2_ERR	0x00ff
+#define MDIO_PCS_10GBRT_STAT2_BER	0x3f00
+
+/* AN 10GBASE-T control register. */
+#define MDIO_AN_10GBT_CTRL_ADV10G	0x1000	/* Advertise 10GBASE-T */
+
+/* AN 10GBASE-T status register. */
+#define MDIO_AN_10GBT_STAT_LPTRR	0x0200	/* LP training reset req. */
+#define MDIO_AN_10GBT_STAT_LPLTABLE	0x0400	/* LP loop timing ability */
+#define MDIO_AN_10GBT_STAT_LP10G	0x0800	/* LP is 10GBT capable */
+#define MDIO_AN_10GBT_STAT_REMOK	0x1000	/* Remote OK */
+#define MDIO_AN_10GBT_STAT_LOCOK	0x2000	/* Local OK */
+#define MDIO_AN_10GBT_STAT_MS		0x4000	/* Master/slave config */
+#define MDIO_AN_10GBT_STAT_MSFLT	0x8000	/* Master/slave config fault */
+
+/* LASI RX_ALARM control/status registers. */
+#define MDIO_PMA_LASI_RX_PHYXSLFLT	0x0001	/* PHY XS RX local fault */
+#define MDIO_PMA_LASI_RX_PCSLFLT	0x0008	/* PCS RX local fault */
+#define MDIO_PMA_LASI_RX_PMALFLT	0x0010	/* PMA/PMD RX local fault */
+#define MDIO_PMA_LASI_RX_OPTICPOWERFLT	0x0020	/* RX optical power fault */
+#define MDIO_PMA_LASI_RX_WISLFLT	0x0200	/* WIS local fault */
+
+/* LASI TX_ALARM control/status registers. */
+#define MDIO_PMA_LASI_TX_PHYXSLFLT	0x0001	/* PHY XS TX local fault */
+#define MDIO_PMA_LASI_TX_PCSLFLT	0x0008	/* PCS TX local fault */
+#define MDIO_PMA_LASI_TX_PMALFLT	0x0010	/* PMA/PMD TX local fault */
+#define MDIO_PMA_LASI_TX_LASERPOWERFLT	0x0080	/* Laser output power fault */
+#define MDIO_PMA_LASI_TX_LASERTEMPFLT	0x0100	/* Laser temperature fault */
+#define MDIO_PMA_LASI_TX_LASERBICURRFLT	0x0200	/* Laser bias current fault */
+
+/* LASI control/status registers. */
+#define MDIO_PMA_LASI_LSALARM		0x0001	/* LS_ALARM enable/status */
+#define MDIO_PMA_LASI_TXALARM		0x0002	/* TX_ALARM enable/status */
+#define MDIO_PMA_LASI_RXALARM		0x0004	/* RX_ALARM enable/status */
+
+/* Mapping between MDIO PRTAD/DEVAD and mii_ioctl_data::phy_id */
+
+#define MDIO_PHY_ID_C45			0x8000
+#define MDIO_PHY_ID_PRTAD		0x03e0
+#define MDIO_PHY_ID_DEVAD		0x001f
+#define MDIO_PHY_ID_C45_MASK						\
+	(MDIO_PHY_ID_C45 | MDIO_PHY_ID_PRTAD | MDIO_PHY_ID_DEVAD)
+
+static inline __u16 mdio_phy_id_c45(int prtad, int devad)
+{
+	return MDIO_PHY_ID_C45 | (prtad << 5) | devad;
+}
+
+static inline bool mdio_phy_id_is_c45(int phy_id)
+{
+	return (phy_id & MDIO_PHY_ID_C45) && !(phy_id & ~MDIO_PHY_ID_C45_MASK);
+}
+
+static inline __u16 mdio_phy_id_prtad(int phy_id)
+{
+	return (phy_id & MDIO_PHY_ID_PRTAD) >> 5;
+}
+
+static inline __u16 mdio_phy_id_devad(int phy_id)
+{
+	return phy_id & MDIO_PHY_ID_DEVAD;
+}
+
+#define MDIO_SUPPORTS_C22		1
+#define MDIO_SUPPORTS_C45		2
+
+#ifdef __KERNEL__ 
+
+/**
+ * struct mdio_if_info - Ethernet controller MDIO interface
+ * @prtad: PRTAD of the PHY (%MDIO_PRTAD_NONE if not present/unknown)
+ * @mmds: Mask of MMDs expected to be present in the PHY.  This must be
+ *	non-zero unless @prtad = %MDIO_PRTAD_NONE.
+ * @mode_support: MDIO modes supported.  If %MDIO_SUPPORTS_C22 is set then
+ *	MII register access will be passed through with @devad =
+ *	%MDIO_DEVAD_NONE.  If %MDIO_EMULATE_C22 is set then access to
+ *	commonly used clause 22 registers will be translated into
+ *	clause 45 registers.
+ * @dev: Net device structure
+ * @mdio_read: Register read function; returns value or negative error code
+ * @mdio_write: Register write function; returns 0 or negative error code
+ */
+struct mdio_if_info {
+	int prtad;
+	u32 mmds;
+	unsigned mode_support;
+
+	struct net_device *dev;
+	int (*mdio_read)(struct net_device *dev, int prtad, int devad,
+			 u16 addr);
+	int (*mdio_write)(struct net_device *dev, int prtad, int devad,
+			  u16 addr, u16 val);
+};
+
+#define MDIO_PRTAD_NONE			(-1)
+#define MDIO_DEVAD_NONE			(-1)
+#define MDIO_EMULATE_C22		4
+
+struct ethtool_cmd;
+struct ethtool_pauseparam;
+extern int mdio45_probe(struct mdio_if_info *mdio, int prtad);
+extern int mdio_set_flag(const struct mdio_if_info *mdio,
+			 int prtad, int devad, u16 addr, int mask,
+			 bool sense);
+extern int mdio45_links_ok(const struct mdio_if_info *mdio, u32 mmds);
+extern int mdio45_nway_restart(const struct mdio_if_info *mdio);
+extern void mdio45_ethtool_gset_npage(const struct mdio_if_info *mdio,
+				      struct ethtool_cmd *ecmd,
+				      u32 npage_adv, u32 npage_lpa);
+extern void
+mdio45_ethtool_spauseparam_an(const struct mdio_if_info *mdio,
+			      const struct ethtool_pauseparam *ecmd);
+
+/**
+ * mdio45_ethtool_gset - get settings for ETHTOOL_GSET
+ * @mdio: MDIO interface
+ * @ecmd: Ethtool request structure
+ *
+ * Since the CSRs for auto-negotiation using next pages are not fully
+ * standardised, this function does not attempt to decode them.  Use
+ * mdio45_ethtool_gset_npage() to specify advertisement bits from next
+ * pages.
+ */
+static inline void mdio45_ethtool_gset(const struct mdio_if_info *mdio,
+				       struct ethtool_cmd *ecmd)
+{
+	mdio45_ethtool_gset_npage(mdio, ecmd, 0, 0);
+}
+
+extern int mdio_mii_ioctl(const struct mdio_if_info *mdio,
+			  struct mii_ioctl_data *mii_data, int cmd);
+
+#endif /* __KERNEL__ */
+#endif /* __LINUX_MDIO_H__ */
diff -r 9566a4a50a43 drivers/net/sfc/lm87.c
--- /dev/null
+++ b/drivers/net/sfc/lm87.c
@@ -0,0 +1,70 @@
+/*
+ * lm87.c
+ *
+ * Copyright (C) 2000       Frodo Looijaard <frodol@dds.nl>
+ *                          Philip Edelbrock <phil@netroedge.com>
+ *                          Stephen Rousset <stephen.rousset@rocketlogix.com>
+ *                          Dan Eaton <dan.eaton@rocketlogix.com>
+ * Copyright (C) 2004-2008  Jean Delvare <khali@linux-fr.org>
+ *
+ * Original port to Linux 2.6 by Jeff Oliver.
+ *
+ * The LM87 is a sensor chip made by National Semiconductor. It monitors up
+ * to 8 voltages (including its own power source), up to three temperatures
+ * (its own plus up to two external ones) and up to two fans. The default
+ * configuration is 6 voltages, two temperatures and two fans (see below).
+ * Voltages are scaled internally with ratios such that the nominal value of
+ * each voltage correspond to a register value of 192 (which means a
+ * resolution of about 0.5% of the nominal value). Temperature values are
+ * reported with a 1 deg resolution and a 3-4 deg accuracy. Complete
+ * datasheet can be obtained from National's website at:
+ *   http://www.national.com/pf/LM/LM87.html
+ *
+ * Some functions share pins, so not all functions are available at the same
+ * time. Which are depends on the hardware setup. This driver normally
+ * assumes that firmware configured the chip correctly. Where this is not
+ * the case, platform code must set the I2C client's platform_data to point
+ * to a u8 value to be written to the channel register.
+ * For reference, here is the list of exclusive functions:
+ *  - in0+in5 (default) or temp3
+ *  - fan1 (default) or in6
+ *  - fan2 (default) or in7
+ *  - VID lines (default) or IRQ lines (not handled by this driver)
+ *
+ * The LM87 additionally features an analog output, supposedly usable to
+ * control the speed of a fan. All new chips use pulse width modulation
+ * instead. The LM87 is the only hardware monitoring chipset I know of
+ * which uses amplitude modulation. Be careful when using this feature.
+ *
+ * This driver also supports the ADM1024, a sensor chip made by Analog
+ * Devices. That chip is fully compatible with the LM87. Complete
+ * datasheet can be obtained from Analog's website at:
+ *   http://www.analog.com/en/prod/0,2877,ADM1024,00.html
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/slab.h>
+#include <linux/jiffies.h>
+#include <linux/i2c.h>
+#include <linux/err.h>
+
+#include "kernel_compat.h"
+#include <linux/hwmon.h>
+#include <linux/hwmon-sysfs.h>
+#include <linux/hwmon-vid.h>
+
diff -r 9566a4a50a43 drivers/net/sfc/lm90.c
--- /dev/null
+++ b/drivers/net/sfc/lm90.c
@@ -0,0 +1,80 @@
+/*
+ * lm90.c - Part of lm_sensors, Linux kernel modules for hardware
+ *          monitoring
+ * Copyright (C) 2003-2008  Jean Delvare <khali@linux-fr.org>
+ *
+ * Based on the lm83 driver. The LM90 is a sensor chip made by National
+ * Semiconductor. It reports up to two temperatures (its own plus up to
+ * one external one) with a 0.125 deg resolution (1 deg for local
+ * temperature) and a 3-4 deg accuracy.
+ *
+ * This driver also supports the LM89 and LM99, two other sensor chips
+ * made by National Semiconductor. Both have an increased remote
+ * temperature measurement accuracy (1 degree), and the LM99
+ * additionally shifts remote temperatures (measured and limits) by 16
+ * degrees, which allows for higher temperatures measurement. The
+ * driver doesn't handle it since it can be done easily in user-space.
+ * Note that there is no way to differentiate between both chips.
+ *
+ * This driver also supports the LM86, another sensor chip made by
+ * National Semiconductor. It is exactly similar to the LM90 except it
+ * has a higher accuracy.
+ *
+ * This driver also supports the ADM1032, a sensor chip made by Analog
+ * Devices. That chip is similar to the LM90, with a few differences
+ * that are not handled by this driver. Among others, it has a higher
+ * accuracy than the LM90, much like the LM86 does.
+ *
+ * This driver also supports the MAX6657, MAX6658 and MAX6659 sensor
+ * chips made by Maxim. These chips are similar to the LM86.
+ * Note that there is no easy way to differentiate between the three
+ * variants. The extra address and features of the MAX6659 are not
+ * supported by this driver. These chips lack the remote temperature
+ * offset feature.
+ *
+ * This driver also supports the MAX6646, MAX6647 and MAX6649 chips
+ * made by Maxim.  These are again similar to the LM86, but they use
+ * unsigned temperature values and can report temperatures from 0 to
+ * 145 degrees.
+ *
+ * This driver also supports the MAX6680 and MAX6681, two other sensor
+ * chips made by Maxim. These are quite similar to the other Maxim
+ * chips. The MAX6680 and MAX6681 only differ in the pinout so they can
+ * be treated identically.
+ *
+ * This driver also supports the ADT7461 chip from Analog Devices.
+ * It's supported in both compatibility and extended mode. It is mostly
+ * compatible with LM90 except for a data format difference for the
+ * temperature value registers.
+ *
+ * Since the LM90 was the first chipset supported by this driver, most
+ * comments will refer to this chipset, but are actually general and
+ * concern all supported chipsets, unless mentioned otherwise.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/slab.h>
+#include <linux/jiffies.h>
+#include <linux/i2c.h>
+#include <linux/err.h>
+#include <linux/sysfs.h>
+
+#include "kernel_compat.h"
+#include <linux/hwmon-sysfs.h>
+#include <linux/hwmon.h>
+
diff -r 9566a4a50a43 drivers/net/sfc/mac.h
--- a/drivers/net/sfc/mac.h
+++ /dev/null
@@ -1,19 +0,0 @@
-/****************************************************************************
- * Driver for Solarflare Solarstorm network controllers and boards
- * Copyright 2005-2006 Fen Systems Ltd.
- * Copyright 2006-2008 Solarflare Communications Inc.
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 as published
- * by the Free Software Foundation, incorporated herein by reference.
- */
-
-#ifndef EFX_MAC_H
-#define EFX_MAC_H
-
-#include "net_driver.h"
-
-extern struct efx_mac_operations falcon_gmac_operations;
-extern struct efx_mac_operations falcon_xmac_operations;
-
-#endif
diff -r 9566a4a50a43 drivers/net/sfc/mcdi.c
--- /dev/null
+++ b/drivers/net/sfc/mcdi.c
@@ -0,0 +1,1308 @@
+/****************************************************************************
+ * Driver for Solarflare Solarstorm network controllers and boards
+ * Copyright 2008-2011 Solarflare Communications Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 as published
+ * by the Free Software Foundation, incorporated herein by reference.
+ */
+
+#include <linux/delay.h>
+#include "net_driver.h"
+#include "nic.h"
+#include "io.h"
+#include "regs.h"
+#include "mcdi_pcol.h"
+#include "phy.h"
+
+/**************************************************************************
+ *
+ * Management-Controller-to-Driver Interface
+ *
+ **************************************************************************
+ */
+
+#define MCDI_RPC_TIMEOUT       10 /*seconds */
+
+#define MCDI_PDU(efx)							\
+	(efx_port_num(efx) ? MC_SMEM_P1_PDU_OFST : MC_SMEM_P0_PDU_OFST)
+#define MCDI_DOORBELL(efx)						\
+	(efx_port_num(efx) ? MC_SMEM_P1_DOORBELL_OFST : MC_SMEM_P0_DOORBELL_OFST)
+#define MCDI_STATUS(efx)						\
+	(efx_port_num(efx) ? MC_SMEM_P1_STATUS_OFST : MC_SMEM_P0_STATUS_OFST)
+
+/* A reboot/assertion causes the MCDI status word to be set after the
+ * command word is set or a REBOOT event is sent. If we notice a reboot
+ * via these mechanisms then wait 10ms for the status word to be set. */
+#define MCDI_STATUS_DELAY_US		100
+#define MCDI_STATUS_DELAY_COUNT		100
+#define MCDI_STATUS_SLEEP_MS						\
+	(MCDI_STATUS_DELAY_US * MCDI_STATUS_DELAY_COUNT / 1000)
+
+#define SEQ_MASK							\
+	EFX_MASK32(EFX_WIDTH(MCDI_HEADER_SEQ))
+
+static inline struct efx_mcdi_iface *efx_mcdi(struct efx_nic *efx)
+{
+	struct siena_nic_data *nic_data;
+	EFX_BUG_ON_PARANOID(efx_nic_rev(efx) < EFX_REV_SIENA_A0);
+	nic_data = efx->nic_data;
+	return &nic_data->mcdi;
+}
+
+void efx_mcdi_init(struct efx_nic *efx)
+{
+	struct efx_mcdi_iface *mcdi;
+
+	if (efx_nic_rev(efx) < EFX_REV_SIENA_A0)
+		return;
+
+	mcdi = efx_mcdi(efx);
+	init_waitqueue_head(&mcdi->wq);
+	spin_lock_init(&mcdi->iface_lock);
+	atomic_set(&mcdi->state, MCDI_STATE_QUIESCENT);
+	mcdi->mode = MCDI_MODE_POLL;
+
+	(void) efx_mcdi_poll_reboot(efx);
+}
+
+static void efx_mcdi_copyin(struct efx_nic *efx, unsigned cmd,
+			    const u8 *inbuf, size_t inlen)
+{
+	struct efx_mcdi_iface *mcdi = efx_mcdi(efx);
+	unsigned pdu = FR_CZ_MC_TREG_SMEM + MCDI_PDU(efx);
+	unsigned doorbell = FR_CZ_MC_TREG_SMEM + MCDI_DOORBELL(efx);
+	unsigned int i;
+	efx_dword_t hdr;
+	u32 xflags, seqno;
+
+	BUG_ON(atomic_read(&mcdi->state) == MCDI_STATE_QUIESCENT);
+	BUG_ON(inlen & 3 || inlen >= MC_SMEM_PDU_LEN);
+
+	seqno = mcdi->seqno & SEQ_MASK;
+	xflags = 0;
+	if (mcdi->mode == MCDI_MODE_EVENTS)
+		xflags |= MCDI_HEADER_XFLAGS_EVREQ;
+
+	EFX_POPULATE_DWORD_6(hdr,
+			     MCDI_HEADER_RESPONSE, 0,
+			     MCDI_HEADER_RESYNC, 1,
+			     MCDI_HEADER_CODE, cmd,
+			     MCDI_HEADER_DATALEN, inlen,
+			     MCDI_HEADER_SEQ, seqno,
+			     MCDI_HEADER_XFLAGS, xflags);
+
+	efx_writed(efx, &hdr, pdu);
+
+	for (i = 0; i < inlen; i += 4)
+		_efx_writed(efx, *((__le32 *)(inbuf + i)), pdu + 4 + i);
+
+	/* Ensure the payload is written out before the header */
+	wmb();
+
+	/* ring the doorbell with a distinctive value */
+	_efx_writed(efx, (__force __le32) 0x45789abc, doorbell);
+}
+
+static void efx_mcdi_copyout(struct efx_nic *efx, u8 *outbuf, size_t outlen)
+{
+	struct efx_mcdi_iface *mcdi = efx_mcdi(efx);
+	unsigned int pdu = FR_CZ_MC_TREG_SMEM + MCDI_PDU(efx);
+	int i;
+
+	BUG_ON(atomic_read(&mcdi->state) == MCDI_STATE_QUIESCENT);
+	BUG_ON(outlen & 3 || outlen >= MC_SMEM_PDU_LEN);
+
+	for (i = 0; i < outlen; i += 4)
+		*((__le32 *)(outbuf + i)) = _efx_readd(efx, pdu + 4 + i);
+}
+
+static int efx_mcdi_poll(struct efx_nic *efx)
+{
+	struct efx_mcdi_iface *mcdi = efx_mcdi(efx);
+	unsigned int time, finish;
+	unsigned int respseq, respcmd, error;
+	unsigned int pdu = FR_CZ_MC_TREG_SMEM + MCDI_PDU(efx);
+	unsigned int rc, spins;
+	efx_dword_t reg;
+
+	/* Check for a reboot atomically with respect to efx_mcdi_copyout() */
+	rc = -efx_mcdi_poll_reboot(efx);
+	if (rc)
+		goto out;
+
+	/* Poll for completion. Poll quickly (once a us) for the 1st jiffy,
+	 * because generally mcdi responses are fast. After that, back off
+	 * and poll once a jiffy (approximately)
+	 */
+	spins = TICK_USEC;
+	finish = get_seconds() + MCDI_RPC_TIMEOUT;
+
+	while (1) {
+		if (spins != 0) {
+			--spins;
+			udelay(1);
+		} else {
+			schedule_timeout_uninterruptible(1);
+		}
+
+		time = get_seconds();
+
+		rmb();
+		efx_readd(efx, &reg, pdu);
+
+		/* All 1's indicates that shared memory is in reset (and is
+		 * not a valid header). Wait for it to come out reset before
+		 * completing the command */
+		if (EFX_DWORD_FIELD(reg, EFX_DWORD_0) != 0xffffffff &&
+		    EFX_DWORD_FIELD(reg, MCDI_HEADER_RESPONSE))
+			break;
+
+		if (time >= finish)
+			return -ETIMEDOUT;
+	}
+
+	mcdi->resplen = EFX_DWORD_FIELD(reg, MCDI_HEADER_DATALEN);
+	respseq = EFX_DWORD_FIELD(reg, MCDI_HEADER_SEQ);
+	respcmd = EFX_DWORD_FIELD(reg, MCDI_HEADER_CODE);
+	error = EFX_DWORD_FIELD(reg, MCDI_HEADER_ERROR);
+
+	if (error && mcdi->resplen == 0) {
+		netif_err(efx, hw, efx->net_dev, "MC rebooted\n");
+		rc = EIO;
+	} else if ((respseq ^ mcdi->seqno) & SEQ_MASK) {
+		netif_err(efx, hw, efx->net_dev,
+			  "MC response mismatch tx seq 0x%x rx seq 0x%x\n",
+			  respseq, mcdi->seqno);
+		rc = EIO;
+	} else if (error) {
+		efx_readd(efx, &reg, pdu + 4);
+		switch (EFX_DWORD_FIELD(reg, EFX_DWORD_0)) {
+#define TRANSLATE_ERROR(name)					\
+		case MC_CMD_ERR_ ## name:			\
+			rc = name;				\
+			break
+			TRANSLATE_ERROR(ENOENT);
+			TRANSLATE_ERROR(EINTR);
+			TRANSLATE_ERROR(EACCES);
+			TRANSLATE_ERROR(EBUSY);
+			TRANSLATE_ERROR(EINVAL);
+			TRANSLATE_ERROR(EDEADLK);
+			TRANSLATE_ERROR(ENOSYS);
+			TRANSLATE_ERROR(ETIME);
+#undef TRANSLATE_ERROR
+		default:
+			rc = EIO;
+			break;
+		}
+	} else
+		rc = 0;
+
+out:
+	mcdi->resprc = rc;
+	if (rc)
+		mcdi->resplen = 0;
+
+	/* Return rc=0 like wait_event_timeout() */
+	return 0;
+}
+
+/* Test and clear MC-rebooted flag for this port/function */
+int efx_mcdi_poll_reboot(struct efx_nic *efx)
+{
+	unsigned int addr = FR_CZ_MC_TREG_SMEM + MCDI_STATUS(efx);
+	efx_dword_t reg;
+	uint32_t value;
+
+	if (efx_nic_rev(efx) < EFX_REV_SIENA_A0)
+		return false;
+
+	efx_readd(efx, &reg, addr);
+	value = EFX_DWORD_FIELD(reg, EFX_DWORD_0);
+
+	if (value == 0)
+		return 0;
+
+	EFX_ZERO_DWORD(reg);
+	efx_writed(efx, &reg, addr);
+
+	if (value == MC_STATUS_DWORD_ASSERT)
+		return -EINTR;
+	else
+		return -EIO;
+}
+
+static void efx_mcdi_acquire(struct efx_mcdi_iface *mcdi)
+{
+	/* Wait until the interface becomes QUIESCENT and we win the race
+	 * to mark it RUNNING. */
+	wait_event(mcdi->wq,
+		   atomic_cmpxchg(&mcdi->state,
+				  MCDI_STATE_QUIESCENT,
+				  MCDI_STATE_RUNNING)
+		   == MCDI_STATE_QUIESCENT);
+}
+
+static int efx_mcdi_await_completion(struct efx_nic *efx)
+{
+	struct efx_mcdi_iface *mcdi = efx_mcdi(efx);
+
+	if (wait_event_timeout(
+		    mcdi->wq,
+		    atomic_read(&mcdi->state) == MCDI_STATE_COMPLETED,
+		    msecs_to_jiffies(MCDI_RPC_TIMEOUT * 1000)) == 0)
+		return -ETIMEDOUT;
+
+	/* Check if efx_mcdi_set_mode() switched us back to polled completions.
+	 * In which case, poll for completions directly. If efx_mcdi_ev_cpl()
+	 * completed the request first, then we'll just end up completing the
+	 * request again, which is safe.
+	 *
+	 * We need an smp_rmb() to synchronise with efx_mcdi_mode_poll(), which
+	 * wait_event_timeout() implicitly provides.
+	 */
+	if (mcdi->mode == MCDI_MODE_POLL)
+		return efx_mcdi_poll(efx);
+
+	return 0;
+}
+
+static bool efx_mcdi_complete(struct efx_mcdi_iface *mcdi)
+{
+	/* If the interface is RUNNING, then move to COMPLETED and wake any
+	 * waiters. If the interface isn't in RUNNING then we've received a
+	 * duplicate completion after we've already transitioned back to
+	 * QUIESCENT. [A subsequent invocation would increment seqno, so would
+	 * have failed the seqno check].
+	 */
+	if (atomic_cmpxchg(&mcdi->state,
+			   MCDI_STATE_RUNNING,
+			   MCDI_STATE_COMPLETED) == MCDI_STATE_RUNNING) {
+		wake_up(&mcdi->wq);
+		return true;
+	}
+
+	return false;
+}
+
+static void efx_mcdi_release(struct efx_mcdi_iface *mcdi)
+{
+	atomic_set(&mcdi->state, MCDI_STATE_QUIESCENT);
+	wake_up(&mcdi->wq);
+}
+
+static void efx_mcdi_ev_cpl(struct efx_nic *efx, unsigned int seqno,
+			    unsigned int datalen, unsigned int errno)
+{
+	struct efx_mcdi_iface *mcdi = efx_mcdi(efx);
+	bool wake = false;
+
+	spin_lock(&mcdi->iface_lock);
+
+	if ((seqno ^ mcdi->seqno) & SEQ_MASK) {
+		if (mcdi->credits)
+			/* The request has been cancelled */
+			--mcdi->credits;
+		else
+			netif_err(efx, hw, efx->net_dev,
+				  "MC response mismatch tx seq 0x%x rx "
+				  "seq 0x%x\n", seqno, mcdi->seqno);
+	} else {
+		mcdi->resprc = errno;
+		mcdi->resplen = datalen;
+
+		wake = true;
+	}
+
+	spin_unlock(&mcdi->iface_lock);
+
+	if (wake)
+		efx_mcdi_complete(mcdi);
+}
+
+/* Issue the given command by writing the data into the shared memory PDU,
+ * ring the doorbell and wait for completion. Copyout the result. */
+int efx_mcdi_rpc(struct efx_nic *efx, unsigned cmd,
+		 const u8 *inbuf, size_t inlen, u8 *outbuf, size_t outlen,
+		 size_t *outlen_actual)
+{
+	efx_mcdi_rpc_start(efx, cmd, inbuf, inlen);
+	return efx_mcdi_rpc_finish(efx, cmd, inlen, outbuf, outlen, outlen_actual);
+}
+
+void efx_mcdi_rpc_start(struct efx_nic *efx, unsigned cmd, const u8 *inbuf,
+			size_t inlen)
+{
+	struct efx_mcdi_iface *mcdi = efx_mcdi(efx);
+
+	BUG_ON(efx_nic_rev(efx) < EFX_REV_SIENA_A0);
+
+	efx_mcdi_acquire(mcdi);
+
+	/* Serialise with efx_mcdi_ev_cpl() and efx_mcdi_ev_death() */
+	spin_lock_bh(&mcdi->iface_lock);
+	++mcdi->seqno;
+	spin_unlock_bh(&mcdi->iface_lock);
+
+	efx_mcdi_copyin(efx, cmd, inbuf, inlen);
+}
+
+int efx_mcdi_rpc_finish(struct efx_nic *efx, unsigned cmd, size_t inlen,
+			u8 *outbuf, size_t outlen, size_t *outlen_actual)
+{
+	struct efx_mcdi_iface *mcdi = efx_mcdi(efx);
+	int rc;
+
+	BUG_ON(efx_nic_rev(efx) < EFX_REV_SIENA_A0);
+
+	if (mcdi->mode == MCDI_MODE_POLL)
+		rc = efx_mcdi_poll(efx);
+	else
+		rc = efx_mcdi_await_completion(efx);
+
+	if (rc != 0) {
+		/* Close the race with efx_mcdi_ev_cpl() executing just too late
+		 * and completing a request we've just cancelled, by ensuring
+		 * that the seqno check therein fails.
+		 */
+		spin_lock_bh(&mcdi->iface_lock);
+		++mcdi->seqno;
+		++mcdi->credits;
+		spin_unlock_bh(&mcdi->iface_lock);
+
+		netif_err(efx, hw, efx->net_dev,
+			  "MC command 0x%x inlen %d mode %d timed out\n",
+			  cmd, (int)inlen, mcdi->mode);
+	} else {
+		size_t resplen;
+
+		/* At the very least we need a memory barrier here to ensure
+		 * we pick up changes from efx_mcdi_ev_cpl(). Protect against
+		 * a spurious efx_mcdi_ev_cpl() running concurrently by
+		 * acquiring the iface_lock. */
+		spin_lock_bh(&mcdi->iface_lock);
+		rc = -mcdi->resprc;
+		resplen = mcdi->resplen;
+		spin_unlock_bh(&mcdi->iface_lock);
+
+		if (rc == 0) {
+			efx_mcdi_copyout(efx, outbuf,
+					 min(outlen, mcdi->resplen + 3) & ~0x3);
+			if (outlen_actual != NULL)
+				*outlen_actual = resplen;
+		} else if (cmd == MC_CMD_REBOOT && rc == -EIO)
+			; /* Don't reset if MC_CMD_REBOOT returns EIO */
+		else if (rc == -EIO || rc == -EINTR) {
+			netif_err(efx, hw, efx->net_dev, "MC fatal error %d\n",
+				  -rc);
+			efx_schedule_reset(efx, RESET_TYPE_MC_FAILURE);
+		} else
+			netif_dbg(efx, hw, efx->net_dev,
+				  "MC command 0x%x inlen %d failed rc=%d\n",
+				  cmd, (int)inlen, -rc);
+
+		if (rc == -EIO || rc == -EINTR) {
+			msleep(MCDI_STATUS_SLEEP_MS);
+			efx_mcdi_poll_reboot(efx);
+		}
+	}
+
+	efx_mcdi_release(mcdi);
+	return rc;
+}
+
+void efx_mcdi_mode_poll(struct efx_nic *efx)
+{
+	struct efx_mcdi_iface *mcdi;
+
+	if (efx_nic_rev(efx) < EFX_REV_SIENA_A0)
+		return;
+
+	mcdi = efx_mcdi(efx);
+	if (mcdi->mode == MCDI_MODE_POLL)
+		return;
+
+	/* We can switch from event completion to polled completion, because
+	 * mcdi requests are always completed in shared memory. We do this by
+	 * switching the mode to POLL'd then completing the request.
+	 * efx_mcdi_await_completion() will then call efx_mcdi_poll().
+	 *
+	 * We need an smp_wmb() to synchronise with efx_mcdi_await_completion(),
+	 * which efx_mcdi_complete() provides for us.
+	 */
+	mcdi->mode = MCDI_MODE_POLL;
+
+	efx_mcdi_complete(mcdi);
+}
+
+void efx_mcdi_mode_event(struct efx_nic *efx)
+{
+	struct efx_mcdi_iface *mcdi;
+
+	if (efx_nic_rev(efx) < EFX_REV_SIENA_A0)
+		return;
+
+	mcdi = efx_mcdi(efx);
+
+	if (mcdi->mode == MCDI_MODE_EVENTS)
+		return;
+
+	/* We can't switch from polled to event completion in the middle of a
+	 * request, because the completion method is specified in the request.
+	 * So acquire the interface to serialise the requestors. We don't need
+	 * to acquire the iface_lock to change the mode here, but we do need a
+	 * write memory barrier ensure that efx_mcdi_rpc() sees it, which
+	 * efx_mcdi_acquire() provides.
+	 */
+	efx_mcdi_acquire(mcdi);
+	mcdi->mode = MCDI_MODE_EVENTS;
+	efx_mcdi_release(mcdi);
+}
+
+static void efx_mcdi_ev_death(struct efx_nic *efx, int rc)
+{
+	struct efx_mcdi_iface *mcdi = efx_mcdi(efx);
+
+	/* If there is an outstanding MCDI request, it has been terminated
+	 * either by a BADASSERT or REBOOT event. If the mcdi interface is
+	 * in polled mode, then do nothing because the MC reboot handler will
+	 * set the header correctly. However, if the mcdi interface is waiting
+	 * for a CMDDONE event it won't receive it [and since all MCDI events
+	 * are sent to the same queue, we can't be racing with
+	 * efx_mcdi_ev_cpl()]
+	 *
+	 * There's a race here with efx_mcdi_rpc(), because we might receive
+	 * a REBOOT event *before* the request has been copied out. In polled
+	 * mode (during startup) this is irrelevant, because efx_mcdi_complete()
+	 * is ignored. In event mode, this condition is just an edge-case of
+	 * receiving a REBOOT event after posting the MCDI request. Did the mc
+	 * reboot before or after the copyout? The best we can do always is
+	 * just return failure.
+	 */
+	spin_lock(&mcdi->iface_lock);
+	if (efx_mcdi_complete(mcdi)) {
+		if (mcdi->mode == MCDI_MODE_EVENTS) {
+			mcdi->resprc = rc;
+			mcdi->resplen = 0;
+			++mcdi->credits;
+		}
+	} else {
+		int count;
+
+		/* Nobody was waiting for an MCDI request, so trigger a reset */
+		efx_schedule_reset(efx, RESET_TYPE_MC_FAILURE);
+
+		/* Consume the status word since efx_mcdi_rpc_finish() won't */
+		for (count = 0; count < MCDI_STATUS_DELAY_COUNT; ++count) {
+			if (efx_mcdi_poll_reboot(efx))
+				break;
+			udelay(MCDI_STATUS_DELAY_US);
+		}
+	}
+
+	spin_unlock(&mcdi->iface_lock);
+}
+
+static unsigned int efx_mcdi_event_link_speed[] = {
+	[MCDI_EVENT_LINKCHANGE_SPEED_100M] = 100,
+	[MCDI_EVENT_LINKCHANGE_SPEED_1G] = 1000,
+	[MCDI_EVENT_LINKCHANGE_SPEED_10G] = 10000,
+};
+
+
+static void efx_mcdi_process_link_change(struct efx_nic *efx, efx_qword_t *ev)
+{
+	u32 flags, fcntl, speed, lpa;
+
+	speed = EFX_QWORD_FIELD(*ev, MCDI_EVENT_LINKCHANGE_SPEED);
+	EFX_BUG_ON_PARANOID(speed >= ARRAY_SIZE(efx_mcdi_event_link_speed));
+	speed = efx_mcdi_event_link_speed[speed];
+
+	flags = EFX_QWORD_FIELD(*ev, MCDI_EVENT_LINKCHANGE_LINK_FLAGS);
+	fcntl = EFX_QWORD_FIELD(*ev, MCDI_EVENT_LINKCHANGE_FCNTL);
+	lpa = EFX_QWORD_FIELD(*ev, MCDI_EVENT_LINKCHANGE_LP_CAP);
+
+	/* efx->link_state is only modified by efx_mcdi_phy_get_link(),
+	 * which is only run after flushing the event queues. Therefore, it
+	 * is safe to modify the link state outside of the mac_lock here.
+	 */
+	efx_mcdi_phy_decode_link(efx, &efx->link_state, speed, flags, fcntl);
+
+	efx_mcdi_phy_check_fcntl(efx, lpa);
+
+	efx_link_status_changed(efx);
+}
+
+static const char *sensor_names[] = {
+	[MC_CMD_SENSOR_CONTROLLER_TEMP] = "Controller temp. sensor",
+	[MC_CMD_SENSOR_PHY_COMMON_TEMP] = "PHY shared temp. sensor",
+	[MC_CMD_SENSOR_CONTROLLER_COOLING] = "Controller cooling",
+	[MC_CMD_SENSOR_PHY0_TEMP] = "PHY 0 temp. sensor",
+	[MC_CMD_SENSOR_PHY0_COOLING] = "PHY 0 cooling",
+	[MC_CMD_SENSOR_PHY1_TEMP] = "PHY 1 temp. sensor",
+	[MC_CMD_SENSOR_PHY1_COOLING] = "PHY 1 cooling",
+	[MC_CMD_SENSOR_IN_1V0] = "1.0V supply sensor",
+	[MC_CMD_SENSOR_IN_1V2] = "1.2V supply sensor",
+	[MC_CMD_SENSOR_IN_1V8] = "1.8V supply sensor",
+	[MC_CMD_SENSOR_IN_2V5] = "2.5V supply sensor",
+	[MC_CMD_SENSOR_IN_3V3] = "3.3V supply sensor",
+	[MC_CMD_SENSOR_IN_12V0] = "12V supply sensor",
+	[MC_CMD_SENSOR_IN_1V2A] = "1.2V analogue supply sensor",
+	[MC_CMD_SENSOR_IN_VREF] = "Reference voltage supply sensor"
+};
+
+static const char *sensor_status_names[] = {
+	[MC_CMD_SENSOR_STATE_OK] = "OK",
+	[MC_CMD_SENSOR_STATE_WARNING] = "Warning",
+	[MC_CMD_SENSOR_STATE_FATAL] = "Fatal",
+	[MC_CMD_SENSOR_STATE_BROKEN] = "Device failure",
+};
+
+static void efx_mcdi_sensor_event(struct efx_nic *efx, efx_qword_t *ev)
+{
+	unsigned int monitor, state, value;
+	const char *name, *state_txt;
+	monitor = EFX_QWORD_FIELD(*ev, MCDI_EVENT_SENSOREVT_MONITOR);
+	state = EFX_QWORD_FIELD(*ev, MCDI_EVENT_SENSOREVT_STATE);
+	value = EFX_QWORD_FIELD(*ev, MCDI_EVENT_SENSOREVT_VALUE);
+	/* Deal gracefully with the board having more drivers than we
+	 * know about, but do not expect new sensor states. */
+	name = (monitor >= ARRAY_SIZE(sensor_names))
+				    ? "No sensor name available" :
+				    sensor_names[monitor];
+	EFX_BUG_ON_PARANOID(state >= ARRAY_SIZE(sensor_status_names));
+	state_txt = sensor_status_names[state];
+
+	netif_err(efx, hw, efx->net_dev,
+		  "Sensor %d (%s) reports condition '%s' for raw value %d\n",
+		  monitor, name, state_txt, value);
+}
+
+static void efx_mcdi_fwalert_event(struct efx_nic *efx, efx_qword_t *ev)
+{
+	unsigned int reason, data;
+
+	reason = EFX_QWORD_FIELD(*ev, MCDI_EVENT_FWALERT_REASON);
+	data = EFX_QWORD_FIELD(*ev, MCDI_EVENT_FWALERT_DATA);
+
+	switch (reason) {
+	case MCDI_EVENT_FWALERT_REASON_SRAM_ACCESS:
+		netif_err(efx, hw, efx->net_dev,
+			  "Error - controller firmware has detected a write"
+			  " to an illegal SRAM address\n");
+		break;
+	default:
+		netif_err(efx, hw, efx->net_dev,
+			  "Firmware alert reason %u: 0x%x\n", reason, data);
+	}
+}
+
+/* Called from  falcon_process_eventq for MCDI events */
+void efx_mcdi_process_event(struct efx_channel *channel,
+			    efx_qword_t *event)
+{
+	struct efx_nic *efx = channel->efx;
+	int code = EFX_QWORD_FIELD(*event, MCDI_EVENT_CODE);
+	u32 data = EFX_QWORD_FIELD(*event, MCDI_EVENT_DATA);
+
+	switch (code) {
+	case MCDI_EVENT_CODE_BADSSERT:
+		netif_err(efx, hw, efx->net_dev,
+			  "MC watchdog or assertion failure at 0x%x\n", data);
+		efx_mcdi_ev_death(efx, EINTR);
+		break;
+
+	case MCDI_EVENT_CODE_PMNOTICE:
+		netif_info(efx, wol, efx->net_dev, "MCDI PM event.\n");
+		break;
+
+	case MCDI_EVENT_CODE_CMDDONE:
+		efx_mcdi_ev_cpl(efx,
+				MCDI_EVENT_FIELD(*event, CMDDONE_SEQ),
+				MCDI_EVENT_FIELD(*event, CMDDONE_DATALEN),
+				MCDI_EVENT_FIELD(*event, CMDDONE_ERRNO));
+		break;
+
+	case MCDI_EVENT_CODE_LINKCHANGE:
+		efx_mcdi_process_link_change(efx, event);
+		break;
+	case MCDI_EVENT_CODE_SENSOREVT:
+		efx_mcdi_sensor_event(efx, event);
+		break;
+	case MCDI_EVENT_CODE_SCHEDERR:
+		netif_info(efx, hw, efx->net_dev,
+			   "MC Scheduler error address=0x%x\n", data);
+		break;
+	case MCDI_EVENT_CODE_REBOOT:
+		netif_info(efx, hw, efx->net_dev, "MC Reboot\n");
+		efx_mcdi_ev_death(efx, EIO);
+		break;
+	case MCDI_EVENT_CODE_MAC_STATS_DMA:
+		/* MAC stats are gather lazily.  We can ignore this. */
+		break;
+	case MCDI_EVENT_CODE_FWALERT:
+		efx_mcdi_fwalert_event(efx, event);
+		break;
+	case MCDI_EVENT_CODE_FLR:
+		efx_sriov_flr(efx, MCDI_EVENT_FIELD(*event, FLR_VF));
+		break;
+	case MCDI_EVENT_CODE_PTP_RX:
+	case MCDI_EVENT_CODE_PTP_FAULT:
+		efx_ptp_event(efx, event);
+		break;
+
+	default:
+		netif_err(efx, hw, efx->net_dev, "Unknown MCDI event 0x%x\n",
+			  code);
+	}
+}
+
+/**************************************************************************
+ *
+ * Specific request functions
+ *
+ **************************************************************************
+ */
+
+void efx_mcdi_print_fwver(struct efx_nic *efx, char *buf, size_t len)
+{
+	u8 outbuf[ALIGN(MC_CMD_GET_VERSION_OUT_LEN, 4)];
+	size_t outlength;
+	const __le16 *ver_words;
+	int rc;
+
+	BUILD_BUG_ON(MC_CMD_GET_VERSION_IN_LEN != 0);
+
+	rc = efx_mcdi_rpc(efx, MC_CMD_GET_VERSION, NULL, 0,
+			  outbuf, sizeof(outbuf), &outlength);
+	if (rc)
+		goto fail;
+
+	if (outlength < MC_CMD_GET_VERSION_OUT_LEN) {
+		rc = -EIO;
+		goto fail;
+	}
+
+	ver_words = (__le16 *)MCDI_PTR(outbuf, GET_VERSION_OUT_VERSION);
+	snprintf(buf, len, "%u.%u.%u.%u",
+		 le16_to_cpu(ver_words[0]), le16_to_cpu(ver_words[1]),
+		 le16_to_cpu(ver_words[2]), le16_to_cpu(ver_words[3]));
+	return;
+
+fail:
+	netif_err(efx, probe, efx->net_dev, "%s: failed rc=%d\n", __func__, rc);
+	buf[0] = 0;
+}
+
+int efx_mcdi_drv_attach(struct efx_nic *efx, bool driver_operating,
+			bool *was_attached)
+{
+	u8 inbuf[MC_CMD_DRV_ATTACH_IN_LEN];
+	u8 outbuf[MC_CMD_DRV_ATTACH_OUT_LEN];
+	size_t outlen;
+	int rc;
+
+	MCDI_SET_DWORD(inbuf, DRV_ATTACH_IN_NEW_STATE,
+		       driver_operating ? 1 : 0);
+	MCDI_SET_DWORD(inbuf, DRV_ATTACH_IN_UPDATE, 1);
+
+	rc = efx_mcdi_rpc(efx, MC_CMD_DRV_ATTACH, inbuf, sizeof(inbuf),
+			  outbuf, sizeof(outbuf), &outlen);
+	if (rc)
+		goto fail;
+	if (outlen < MC_CMD_DRV_ATTACH_OUT_LEN) {
+		rc = -EIO;
+		goto fail;
+	}
+
+	if (was_attached != NULL)
+		*was_attached = MCDI_DWORD(outbuf, DRV_ATTACH_OUT_OLD_STATE);
+	return 0;
+
+fail:
+	netif_err(efx, probe, efx->net_dev, "%s: failed rc=%d\n", __func__, rc);
+	return rc;
+}
+
+int efx_mcdi_get_board_cfg(struct efx_nic *efx, u8 *mac_address,
+			   u16 *fw_subtype_list, u32 *capabilities)
+{
+	uint8_t outbuf[MC_CMD_GET_BOARD_CFG_OUT_LENMAX];
+	size_t outlen, src_size, dst_size;
+	int port_num = efx_port_num(efx);
+	int offset;
+	int rc;
+
+	BUILD_BUG_ON(MC_CMD_GET_BOARD_CFG_IN_LEN != 0);
+
+	rc = efx_mcdi_rpc(efx, MC_CMD_GET_BOARD_CFG, NULL, 0,
+			  outbuf, sizeof(outbuf), &outlen);
+	if (rc)
+		goto fail;
+
+	if (outlen < MC_CMD_GET_BOARD_CFG_OUT_LENMIN) {
+		rc = -EIO;
+		goto fail;
+	}
+
+	offset = (port_num)
+		? MC_CMD_GET_BOARD_CFG_OUT_MAC_ADDR_BASE_PORT1_OFST
+		: MC_CMD_GET_BOARD_CFG_OUT_MAC_ADDR_BASE_PORT0_OFST;
+	if (mac_address)
+		memcpy(mac_address, outbuf + offset, ETH_ALEN);
+	if (fw_subtype_list) {
+		/* Truncate or zero-pad as necessary */
+		src_size = (outlen -
+			    MC_CMD_GET_BOARD_CFG_OUT_FW_SUBTYPE_LIST_OFST);
+		dst_size = (MC_CMD_GET_BOARD_CFG_OUT_FW_SUBTYPE_LIST_MAXNUM *
+			    sizeof(*fw_subtype_list));
+		memcpy(fw_subtype_list,
+		       outbuf + MC_CMD_GET_BOARD_CFG_OUT_FW_SUBTYPE_LIST_OFST,
+		       min(src_size, dst_size));
+		if (dst_size < src_size)
+			memset(fw_subtype_list + src_size, 0,
+			       dst_size - src_size);
+	}
+	if (capabilities) {
+		if (port_num)
+			*capabilities = MCDI_DWORD(outbuf,
+				   	GET_BOARD_CFG_OUT_CAPABILITIES_PORT1);
+		else
+			*capabilities = MCDI_DWORD(outbuf,
+				   	GET_BOARD_CFG_OUT_CAPABILITIES_PORT0);
+	}
+
+	return 0;
+
+fail:
+	netif_err(efx, hw, efx->net_dev, "%s: failed rc=%d len=%d\n",
+		  __func__, rc, (int)outlen);
+
+	return rc;
+}
+
+int efx_mcdi_log_ctrl(struct efx_nic *efx, bool evq, bool uart, u32 dest_evq)
+{
+	u8 inbuf[MC_CMD_LOG_CTRL_IN_LEN];
+	u32 dest = 0;
+	int rc;
+
+	if (uart)
+		dest |= MC_CMD_LOG_CTRL_IN_LOG_DEST_UART;
+	if (evq)
+		dest |= MC_CMD_LOG_CTRL_IN_LOG_DEST_EVQ;
+
+	MCDI_SET_DWORD(inbuf, LOG_CTRL_IN_LOG_DEST, dest);
+	MCDI_SET_DWORD(inbuf, LOG_CTRL_IN_LOG_DEST_EVQ, dest_evq);
+
+	BUILD_BUG_ON(MC_CMD_LOG_CTRL_OUT_LEN != 0);
+
+	rc = efx_mcdi_rpc(efx, MC_CMD_LOG_CTRL, inbuf, sizeof(inbuf),
+			  NULL, 0, NULL);
+	if (rc)
+		goto fail;
+
+	return 0;
+
+fail:
+	netif_err(efx, hw, efx->net_dev, "%s: failed rc=%d\n", __func__, rc);
+	return rc;
+}
+
+int efx_mcdi_nvram_types(struct efx_nic *efx, u32 *nvram_types_out)
+{
+	u8 outbuf[MC_CMD_NVRAM_TYPES_OUT_LEN];
+	size_t outlen;
+	int rc;
+
+	BUILD_BUG_ON(MC_CMD_NVRAM_TYPES_IN_LEN != 0);
+
+	rc = efx_mcdi_rpc(efx, MC_CMD_NVRAM_TYPES, NULL, 0,
+			  outbuf, sizeof(outbuf), &outlen);
+	if (rc)
+		goto fail;
+	if (outlen < MC_CMD_NVRAM_TYPES_OUT_LEN) {
+		rc = -EIO;
+		goto fail;
+	}
+
+	*nvram_types_out = MCDI_DWORD(outbuf, NVRAM_TYPES_OUT_TYPES);
+	return 0;
+
+fail:
+	netif_err(efx, hw, efx->net_dev, "%s: failed rc=%d\n",
+		  __func__, rc);
+	return rc;
+}
+
+int efx_mcdi_nvram_info(struct efx_nic *efx, unsigned int type,
+			size_t *size_out, size_t *erase_size_out,
+			bool *protected_out)
+{
+	u8 inbuf[MC_CMD_NVRAM_INFO_IN_LEN];
+	u8 outbuf[MC_CMD_NVRAM_INFO_OUT_LEN];
+	size_t outlen;
+	int rc;
+
+	MCDI_SET_DWORD(inbuf, NVRAM_INFO_IN_TYPE, type);
+
+	rc = efx_mcdi_rpc(efx, MC_CMD_NVRAM_INFO, inbuf, sizeof(inbuf),
+			  outbuf, sizeof(outbuf), &outlen);
+	if (rc)
+		goto fail;
+	if (outlen < MC_CMD_NVRAM_INFO_OUT_LEN) {
+		rc = -EIO;
+		goto fail;
+	}
+
+	*size_out = MCDI_DWORD(outbuf, NVRAM_INFO_OUT_SIZE);
+	*erase_size_out = MCDI_DWORD(outbuf, NVRAM_INFO_OUT_ERASESIZE);
+	*protected_out = !!(MCDI_DWORD(outbuf, NVRAM_INFO_OUT_FLAGS) &
+				(1 << MC_CMD_NVRAM_INFO_OUT_PROTECTED_LBN));
+	return 0;
+
+fail:
+	netif_err(efx, hw, efx->net_dev, "%s: failed rc=%d\n", __func__, rc);
+	return rc;
+}
+
+int efx_mcdi_nvram_update_start(struct efx_nic *efx, unsigned int type)
+{
+	u8 inbuf[MC_CMD_NVRAM_UPDATE_START_IN_LEN];
+	int rc;
+
+	MCDI_SET_DWORD(inbuf, NVRAM_UPDATE_START_IN_TYPE, type);
+
+	BUILD_BUG_ON(MC_CMD_NVRAM_UPDATE_START_OUT_LEN != 0);
+
+	rc = efx_mcdi_rpc(efx, MC_CMD_NVRAM_UPDATE_START, inbuf, sizeof(inbuf),
+			  NULL, 0, NULL);
+	if (rc)
+		goto fail;
+
+	return 0;
+
+fail:
+	netif_err(efx, hw, efx->net_dev, "%s: failed rc=%d\n", __func__, rc);
+	return rc;
+}
+
+int efx_mcdi_nvram_read(struct efx_nic *efx, unsigned int type,
+			loff_t offset, u8 *buffer, size_t length)
+{
+	u8 inbuf[MC_CMD_NVRAM_READ_IN_LEN];
+	u8 outbuf[MC_CMD_NVRAM_READ_OUT_LEN(EFX_MCDI_NVRAM_LEN_MAX)];
+	size_t outlen;
+	int rc;
+
+	MCDI_SET_DWORD(inbuf, NVRAM_READ_IN_TYPE, type);
+	MCDI_SET_DWORD(inbuf, NVRAM_READ_IN_OFFSET, offset);
+	MCDI_SET_DWORD(inbuf, NVRAM_READ_IN_LENGTH, length);
+
+	rc = efx_mcdi_rpc(efx, MC_CMD_NVRAM_READ, inbuf, sizeof(inbuf),
+			  outbuf, sizeof(outbuf), &outlen);
+	if (rc)
+		goto fail;
+
+	memcpy(buffer, MCDI_PTR(outbuf, NVRAM_READ_OUT_READ_BUFFER), length);
+	return 0;
+
+fail:
+	netif_err(efx, hw, efx->net_dev, "%s: failed rc=%d\n", __func__, rc);
+	return rc;
+}
+
+int efx_mcdi_nvram_write(struct efx_nic *efx, unsigned int type,
+			   loff_t offset, const u8 *buffer, size_t length)
+{
+	u8 inbuf[MC_CMD_NVRAM_WRITE_IN_LEN(EFX_MCDI_NVRAM_LEN_MAX)];
+	int rc;
+
+	MCDI_SET_DWORD(inbuf, NVRAM_WRITE_IN_TYPE, type);
+	MCDI_SET_DWORD(inbuf, NVRAM_WRITE_IN_OFFSET, offset);
+	MCDI_SET_DWORD(inbuf, NVRAM_WRITE_IN_LENGTH, length);
+	memcpy(MCDI_PTR(inbuf, NVRAM_WRITE_IN_WRITE_BUFFER), buffer, length);
+
+	BUILD_BUG_ON(MC_CMD_NVRAM_WRITE_OUT_LEN != 0);
+
+	rc = efx_mcdi_rpc(efx, MC_CMD_NVRAM_WRITE, inbuf,
+			  ALIGN(MC_CMD_NVRAM_WRITE_IN_LEN(length), 4),
+			  NULL, 0, NULL);
+	if (rc)
+		goto fail;
+
+	return 0;
+
+fail:
+	netif_err(efx, hw, efx->net_dev, "%s: failed rc=%d\n", __func__, rc);
+	return rc;
+}
+
+int efx_mcdi_nvram_erase(struct efx_nic *efx, unsigned int type,
+			 loff_t offset, size_t length)
+{
+	u8 inbuf[MC_CMD_NVRAM_ERASE_IN_LEN];
+	int rc;
+
+	MCDI_SET_DWORD(inbuf, NVRAM_ERASE_IN_TYPE, type);
+	MCDI_SET_DWORD(inbuf, NVRAM_ERASE_IN_OFFSET, offset);
+	MCDI_SET_DWORD(inbuf, NVRAM_ERASE_IN_LENGTH, length);
+
+	BUILD_BUG_ON(MC_CMD_NVRAM_ERASE_OUT_LEN != 0);
+
+	rc = efx_mcdi_rpc(efx, MC_CMD_NVRAM_ERASE, inbuf, sizeof(inbuf),
+			  NULL, 0, NULL);
+	if (rc)
+		goto fail;
+
+	return 0;
+
+fail:
+	netif_err(efx, hw, efx->net_dev, "%s: failed rc=%d\n", __func__, rc);
+	return rc;
+}
+
+int efx_mcdi_nvram_update_finish(struct efx_nic *efx, unsigned int type)
+{
+	u8 inbuf[MC_CMD_NVRAM_UPDATE_FINISH_IN_LEN];
+	u32 reboot;
+	int rc;
+
+	/* Reboot PHY's into the new firmware. mcfw reboot is handled
+	 * explicity via ethtool. */
+	reboot = (type == MC_CMD_NVRAM_TYPE_PHY_PORT0 ||
+		  type == MC_CMD_NVRAM_TYPE_PHY_PORT1 ||
+		  type == MC_CMD_NVRAM_TYPE_DISABLED_CALLISTO);
+	MCDI_SET_DWORD(inbuf, NVRAM_UPDATE_FINISH_IN_TYPE, type);
+	MCDI_SET_DWORD(inbuf, NVRAM_UPDATE_FINISH_IN_REBOOT, reboot);
+
+	BUILD_BUG_ON(MC_CMD_NVRAM_UPDATE_FINISH_OUT_LEN != 0);
+
+	rc = efx_mcdi_rpc(efx, MC_CMD_NVRAM_UPDATE_FINISH, inbuf, sizeof(inbuf),
+			  NULL, 0, NULL);
+	if (rc)
+		goto fail;
+
+	return 0;
+
+fail:
+	netif_err(efx, hw, efx->net_dev, "%s: failed rc=%d\n", __func__, rc);
+	return rc;
+}
+
+static int efx_mcdi_nvram_test(struct efx_nic *efx, unsigned int type)
+{
+	u8 inbuf[MC_CMD_NVRAM_TEST_IN_LEN];
+	u8 outbuf[MC_CMD_NVRAM_TEST_OUT_LEN];
+	int rc;
+
+	MCDI_SET_DWORD(inbuf, NVRAM_TEST_IN_TYPE, type);
+
+	rc = efx_mcdi_rpc(efx, MC_CMD_NVRAM_TEST, inbuf, sizeof(inbuf),
+			  outbuf, sizeof(outbuf), NULL);
+	if (rc)
+		return rc;
+
+	switch (MCDI_DWORD(outbuf, NVRAM_TEST_OUT_RESULT)) {
+	case MC_CMD_NVRAM_TEST_PASS:
+	case MC_CMD_NVRAM_TEST_NOTSUPP:
+		return 0;
+	default:
+		return -EIO;
+	}
+}
+
+int efx_mcdi_nvram_test_all(struct efx_nic *efx)
+{
+	u32 nvram_types = 0;
+	unsigned int type;
+	int rc;
+
+	rc = efx_mcdi_nvram_types(efx, &nvram_types);
+	if (rc)
+		goto fail1;
+
+	type = 0;
+	while (nvram_types != 0) {
+		if (nvram_types & 1) {
+			rc = efx_mcdi_nvram_test(efx, type);
+			if (rc)
+				goto fail2;
+		}
+		type++;
+		nvram_types >>= 1;
+	}
+
+	return 0;
+
+fail2:
+	netif_err(efx, hw, efx->net_dev, "%s: failed type=%u\n",
+		  __func__, type);
+fail1:
+	netif_err(efx, hw, efx->net_dev, "%s: failed rc=%d\n", __func__, rc);
+	return rc;
+}
+
+static int efx_mcdi_read_assertion(struct efx_nic *efx)
+{
+	u8 inbuf[MC_CMD_GET_ASSERTS_IN_LEN];
+	u8 outbuf[MC_CMD_GET_ASSERTS_OUT_LEN];
+	unsigned int flags, index, ofst;
+	const char *reason;
+	size_t outlen;
+	int retry;
+	int rc;
+
+	/* Attempt to read any stored assertion state before we reboot
+	 * the mcfw out of the assertion handler. Retry twice, once
+	 * because a boot-time assertion might cause this command to fail
+	 * with EINTR. And once again because GET_ASSERTS can race with
+	 * MC_CMD_REBOOT running on the other port. */
+	retry = 2;
+	do {
+		MCDI_SET_DWORD(inbuf, GET_ASSERTS_IN_CLEAR, 1);
+		rc = efx_mcdi_rpc(efx, MC_CMD_GET_ASSERTS,
+				  inbuf, MC_CMD_GET_ASSERTS_IN_LEN,
+				  outbuf, sizeof(outbuf), &outlen);
+	} while ((rc == -EINTR || rc == -EIO) && retry-- > 0);
+
+	if (rc)
+		return rc;
+	if (outlen < MC_CMD_GET_ASSERTS_OUT_LEN)
+		return -EIO;
+
+	/* Print out any recorded assertion state */
+	flags = MCDI_DWORD(outbuf, GET_ASSERTS_OUT_GLOBAL_FLAGS);
+	if (flags == MC_CMD_GET_ASSERTS_FLAGS_NO_FAILS)
+		return 0;
+
+	reason = (flags == MC_CMD_GET_ASSERTS_FLAGS_SYS_FAIL)
+		? "system-level assertion"
+		: (flags == MC_CMD_GET_ASSERTS_FLAGS_THR_FAIL)
+		? "thread-level assertion"
+		: (flags == MC_CMD_GET_ASSERTS_FLAGS_WDOG_FIRED)
+		? "watchdog reset"
+		: "unknown assertion";
+	netif_err(efx, hw, efx->net_dev,
+		  "MCPU %s at PC = 0x%.8x in thread 0x%.8x\n", reason,
+		  MCDI_DWORD(outbuf, GET_ASSERTS_OUT_SAVED_PC_OFFS),
+		  MCDI_DWORD(outbuf, GET_ASSERTS_OUT_THREAD_OFFS));
+
+	/* Print out the registers */
+	ofst = MC_CMD_GET_ASSERTS_OUT_GP_REGS_OFFS_OFST;
+	for (index = 1; index < 32; index++) {
+		netif_err(efx, hw, efx->net_dev, "R%.2d (?): 0x%.8x\n", index,
+			MCDI_DWORD2(outbuf, ofst));
+		ofst += sizeof(efx_dword_t);
+	}
+
+	return 0;
+}
+
+static void efx_mcdi_exit_assertion(struct efx_nic *efx)
+{
+	u8 inbuf[MC_CMD_REBOOT_IN_LEN];
+
+	/* Atomically reboot the mcfw out of the assertion handler */
+	BUILD_BUG_ON(MC_CMD_REBOOT_OUT_LEN != 0);
+	MCDI_SET_DWORD(inbuf, REBOOT_IN_FLAGS,
+		       MC_CMD_REBOOT_FLAGS_AFTER_ASSERTION);
+	efx_mcdi_rpc(efx, MC_CMD_REBOOT, inbuf, MC_CMD_REBOOT_IN_LEN,
+		     NULL, 0, NULL);
+}
+
+int efx_mcdi_handle_assertion(struct efx_nic *efx)
+{
+	int rc;
+
+	rc = efx_mcdi_read_assertion(efx);
+	if (rc)
+		return rc;
+
+	efx_mcdi_exit_assertion(efx);
+
+	return 0;
+}
+
+void efx_mcdi_set_id_led(struct efx_nic *efx, enum efx_led_mode mode)
+{
+	u8 inbuf[MC_CMD_SET_ID_LED_IN_LEN];
+	int rc;
+
+	BUILD_BUG_ON(EFX_LED_OFF != MC_CMD_LED_OFF);
+	BUILD_BUG_ON(EFX_LED_ON != MC_CMD_LED_ON);
+	BUILD_BUG_ON(EFX_LED_DEFAULT != MC_CMD_LED_DEFAULT);
+
+	BUILD_BUG_ON(MC_CMD_SET_ID_LED_OUT_LEN != 0);
+
+	MCDI_SET_DWORD(inbuf, SET_ID_LED_IN_STATE, mode);
+
+	rc = efx_mcdi_rpc(efx, MC_CMD_SET_ID_LED, inbuf, sizeof(inbuf),
+			  NULL, 0, NULL);
+	if (rc)
+		netif_err(efx, hw, efx->net_dev, "%s: failed rc=%d\n",
+			  __func__, rc);
+}
+
+int efx_mcdi_reset_port(struct efx_nic *efx)
+{
+	int rc = efx_mcdi_rpc(efx, MC_CMD_PORT_RESET, NULL, 0, NULL, 0, NULL);
+	if (rc)
+		netif_err(efx, hw, efx->net_dev, "%s: failed rc=%d\n",
+			  __func__, rc);
+	return rc;
+}
+
+int efx_mcdi_reset_mc(struct efx_nic *efx)
+{
+	u8 inbuf[MC_CMD_REBOOT_IN_LEN];
+	int rc;
+
+	BUILD_BUG_ON(MC_CMD_REBOOT_OUT_LEN != 0);
+	MCDI_SET_DWORD(inbuf, REBOOT_IN_FLAGS, 0);
+	rc = efx_mcdi_rpc(efx, MC_CMD_REBOOT, inbuf, sizeof(inbuf),
+			  NULL, 0, NULL);
+	/* White is black, and up is down */
+	if (rc == -EIO)
+		return 0;
+	if (rc == 0)
+		rc = -EIO;
+	netif_err(efx, hw, efx->net_dev, "%s: failed rc=%d\n", __func__, rc);
+	return rc;
+}
+
+static int efx_mcdi_wol_filter_set(struct efx_nic *efx, u32 type,
+				   const u8 *mac, int *id_out)
+{
+	u8 inbuf[MC_CMD_WOL_FILTER_SET_IN_LEN];
+	u8 outbuf[MC_CMD_WOL_FILTER_SET_OUT_LEN];
+	size_t outlen;
+	int rc;
+
+	MCDI_SET_DWORD(inbuf, WOL_FILTER_SET_IN_WOL_TYPE, type);
+	MCDI_SET_DWORD(inbuf, WOL_FILTER_SET_IN_FILTER_MODE,
+		       MC_CMD_FILTER_MODE_SIMPLE);
+	memcpy(MCDI_PTR(inbuf, WOL_FILTER_SET_IN_MAGIC_MAC), mac, ETH_ALEN);
+
+	rc = efx_mcdi_rpc(efx, MC_CMD_WOL_FILTER_SET, inbuf, sizeof(inbuf),
+			  outbuf, sizeof(outbuf), &outlen);
+	if (rc)
+		goto fail;
+
+	if (outlen < MC_CMD_WOL_FILTER_SET_OUT_LEN) {
+		rc = -EIO;
+		goto fail;
+	}
+
+	*id_out = (int)MCDI_DWORD(outbuf, WOL_FILTER_SET_OUT_FILTER_ID);
+
+	return 0;
+
+fail:
+	*id_out = -1;
+	netif_err(efx, hw, efx->net_dev, "%s: failed rc=%d\n", __func__, rc);
+	return rc;
+
+}
+
+
+int
+efx_mcdi_wol_filter_set_magic(struct efx_nic *efx,  const u8 *mac, int *id_out)
+{
+	return efx_mcdi_wol_filter_set(efx, MC_CMD_WOL_TYPE_MAGIC, mac, id_out);
+}
+
+
+int efx_mcdi_wol_filter_get_magic(struct efx_nic *efx, int *id_out)
+{
+	u8 outbuf[MC_CMD_WOL_FILTER_GET_OUT_LEN];
+	size_t outlen;
+	int rc;
+
+	rc = efx_mcdi_rpc(efx, MC_CMD_WOL_FILTER_GET, NULL, 0,
+			  outbuf, sizeof(outbuf), &outlen);
+	if (rc)
+		goto fail;
+
+	if (outlen < MC_CMD_WOL_FILTER_GET_OUT_LEN) {
+		rc = -EIO;
+		goto fail;
+	}
+
+	*id_out = (int)MCDI_DWORD(outbuf, WOL_FILTER_GET_OUT_FILTER_ID);
+
+	return 0;
+
+fail:
+	*id_out = -1;
+	netif_err(efx, hw, efx->net_dev, "%s: failed rc=%d\n", __func__, rc);
+	return rc;
+}
+
+
+int efx_mcdi_wol_filter_remove(struct efx_nic *efx, int id)
+{
+	u8 inbuf[MC_CMD_WOL_FILTER_REMOVE_IN_LEN];
+	int rc;
+
+	MCDI_SET_DWORD(inbuf, WOL_FILTER_REMOVE_IN_FILTER_ID, (u32)id);
+
+	rc = efx_mcdi_rpc(efx, MC_CMD_WOL_FILTER_REMOVE, inbuf, sizeof(inbuf),
+			  NULL, 0, NULL);
+	if (rc)
+		goto fail;
+
+	return 0;
+
+fail:
+	netif_err(efx, hw, efx->net_dev, "%s: failed rc=%d\n", __func__, rc);
+	return rc;
+}
+
+int efx_mcdi_flush_rxqs(struct efx_nic *efx)
+{
+	struct efx_channel *channel;
+	struct efx_rx_queue *rx_queue;
+	__le32 *qid;
+	int rc, count;
+
+	qid = kmalloc(EFX_MAX_CHANNELS * sizeof(*qid), GFP_KERNEL);
+	if (qid == NULL)
+		return -ENOMEM;
+
+	count = 0;
+	efx_for_each_channel(channel, efx) {
+		efx_for_each_channel_rx_queue(rx_queue, channel) {
+			if (rx_queue->flush_pending) {
+				rx_queue->flush_pending = false;
+				atomic_dec(&efx->rxq_flush_pending);
+				qid[count++] = cpu_to_le32(
+					efx_rx_queue_index(rx_queue));
+			}
+		}
+	}
+	
+	rc = efx_mcdi_rpc(efx, MC_CMD_FLUSH_RX_QUEUES, (u8 *)qid,
+			  count * sizeof(*qid), NULL, 0, NULL);
+	WARN_ON(rc > 0);
+
+	kfree(qid);
+
+	return rc;
+}
+
+int efx_mcdi_wol_filter_reset(struct efx_nic *efx)
+{
+	int rc;
+
+	rc = efx_mcdi_rpc(efx, MC_CMD_WOL_FILTER_RESET, NULL, 0, NULL, 0, NULL);
+	if (rc)
+		goto fail;
+
+	return 0;
+
+fail:
+	netif_err(efx, hw, efx->net_dev, "%s: failed rc=%d\n", __func__, rc);
+	return rc;
+}
+
diff -r 9566a4a50a43 drivers/net/sfc/mcdi.h
--- /dev/null
+++ b/drivers/net/sfc/mcdi.h
@@ -0,0 +1,142 @@
+/****************************************************************************
+ * Driver for Solarflare Solarstorm network controllers and boards
+ * Copyright 2008-2010 Solarflare Communications Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 as published
+ * by the Free Software Foundation, incorporated herein by reference.
+ */
+
+#ifndef EFX_MCDI_H
+#define EFX_MCDI_H
+
+/**
+ * enum efx_mcdi_state
+ * @MCDI_STATE_QUIESCENT: No pending MCDI requests. If the caller holds the
+ *	mcdi_lock then they are able to move to MCDI_STATE_RUNNING
+ * @MCDI_STATE_RUNNING: There is an MCDI request pending. Only the thread that
+ *	moved into this state is allowed to move out of it.
+ * @MCDI_STATE_COMPLETED: An MCDI request has completed, but the owning thread
+ *	has not yet consumed the result. For all other threads, equivalent to
+ *	MCDI_STATE_RUNNING.
+ */
+enum efx_mcdi_state {
+	MCDI_STATE_QUIESCENT,
+	MCDI_STATE_RUNNING,
+	MCDI_STATE_COMPLETED,
+};
+
+enum efx_mcdi_mode {
+	MCDI_MODE_POLL,
+	MCDI_MODE_EVENTS,
+};
+
+/**
+ * struct efx_mcdi_iface
+ * @state: Interface state. Waited for by mcdi_wq.
+ * @wq: Wait queue for threads waiting for state != STATE_RUNNING
+ * @iface_lock: Protects @credits, @seqno, @resprc, @resplen
+ * @mode: Poll for mcdi completion, or wait for an mcdi_event.
+ *	Serialised by @lock
+ * @seqno: The next sequence number to use for mcdi requests.
+ *	Serialised by @lock
+ * @credits: Number of spurious MCDI completion events allowed before we
+ *	trigger a fatal error. Protected by @lock
+ * @resprc: Returned MCDI completion
+ * @resplen: Returned payload length
+ */
+struct efx_mcdi_iface {
+	atomic_t state;
+	wait_queue_head_t wq;
+	spinlock_t iface_lock;
+	enum efx_mcdi_mode mode;
+	unsigned int credits;
+	unsigned int seqno;
+	unsigned int resprc;
+	size_t resplen;
+};
+
+extern void efx_mcdi_init(struct efx_nic *efx);
+
+extern int efx_mcdi_rpc(struct efx_nic *efx, unsigned cmd, const u8 *inbuf,
+			size_t inlen, u8 *outbuf, size_t outlen,
+			size_t *outlen_actual);
+
+extern void efx_mcdi_rpc_start(struct efx_nic *efx, unsigned cmd, const u8 *inbuf,
+			size_t inlen);
+extern int efx_mcdi_rpc_finish(struct efx_nic *efx, unsigned cmd, size_t inlen,
+			u8 *outbuf, size_t outlen, size_t *outlen_actual);
+
+
+extern int efx_mcdi_poll_reboot(struct efx_nic *efx);
+extern void efx_mcdi_mode_poll(struct efx_nic *efx);
+extern void efx_mcdi_mode_event(struct efx_nic *efx);
+
+extern void efx_mcdi_process_event(struct efx_channel *channel,
+				   efx_qword_t *event);
+
+#define MCDI_PTR2(_buf, _ofst)						\
+	(((u8 *)_buf) + _ofst)
+#define MCDI_SET_DWORD2(_buf, _ofst, _value)				\
+	EFX_POPULATE_DWORD_1(*((efx_dword_t *)MCDI_PTR2(_buf, _ofst)),	\
+			     EFX_DWORD_0, _value)
+#define MCDI_DWORD2(_buf, _ofst)					\
+	EFX_DWORD_FIELD(*((efx_dword_t *)MCDI_PTR2(_buf, _ofst)),	\
+			EFX_DWORD_0)
+#define MCDI_QWORD2(_buf, _ofst)					\
+	EFX_QWORD_FIELD64(*((efx_qword_t *)MCDI_PTR2(_buf, _ofst)),	\
+			  EFX_QWORD_0)
+
+#define MCDI_PTR(_buf, _ofst)						\
+	MCDI_PTR2(_buf, MC_CMD_ ## _ofst ## _OFST)
+#define MCDI_SET_DWORD(_buf, _ofst, _value)				\
+	MCDI_SET_DWORD2(_buf, MC_CMD_ ## _ofst ## _OFST, _value)
+#define MCDI_DWORD(_buf, _ofst)						\
+	MCDI_DWORD2(_buf, MC_CMD_ ## _ofst ## _OFST)
+#define MCDI_QWORD(_buf, _ofst)						\
+	MCDI_QWORD2(_buf, MC_CMD_ ## _ofst ## _OFST)
+
+#define MCDI_EVENT_FIELD(_ev, _field)			\
+	EFX_QWORD_FIELD(_ev, MCDI_EVENT_ ## _field)
+
+extern void efx_mcdi_print_fwver(struct efx_nic *efx, char *buf, size_t len);
+extern int efx_mcdi_drv_attach(struct efx_nic *efx, bool driver_operating,
+			       bool *was_attached_out);
+extern int efx_mcdi_get_board_cfg(struct efx_nic *efx, u8 *mac_address,
+				  u16 *fw_subtype_list, u32 *capabilities);
+extern int efx_mcdi_log_ctrl(struct efx_nic *efx, bool evq, bool uart,
+			     u32 dest_evq);
+extern int efx_mcdi_nvram_types(struct efx_nic *efx, u32 *nvram_types_out);
+extern int efx_mcdi_nvram_info(struct efx_nic *efx, unsigned int type,
+			       size_t *size_out, size_t *erase_size_out,
+			       bool *protected_out);
+extern int efx_mcdi_nvram_update_start(struct efx_nic *efx,
+				       unsigned int type);
+extern int efx_mcdi_nvram_read(struct efx_nic *efx, unsigned int type,
+			       loff_t offset, u8 *buffer, size_t length);
+extern int efx_mcdi_nvram_write(struct efx_nic *efx, unsigned int type,
+				loff_t offset, const u8 *buffer,
+				size_t length);
+#define EFX_MCDI_NVRAM_LEN_MAX 128
+extern int efx_mcdi_nvram_erase(struct efx_nic *efx, unsigned int type,
+				loff_t offset, size_t length);
+extern int efx_mcdi_nvram_update_finish(struct efx_nic *efx,
+					unsigned int type);
+extern int efx_mcdi_nvram_test_all(struct efx_nic *efx);
+extern int efx_mcdi_handle_assertion(struct efx_nic *efx);
+extern void efx_mcdi_set_id_led(struct efx_nic *efx, enum efx_led_mode mode);
+extern int efx_mcdi_reset_port(struct efx_nic *efx);
+extern int efx_mcdi_reset_mc(struct efx_nic *efx);
+extern int efx_mcdi_wol_filter_set_magic(struct efx_nic *efx,
+					 const u8 *mac, int *id_out);
+extern int efx_mcdi_wol_filter_get_magic(struct efx_nic *efx, int *id_out);
+extern int efx_mcdi_wol_filter_remove(struct efx_nic *efx, int id);
+extern int efx_mcdi_wol_filter_reset(struct efx_nic *efx);
+extern int efx_mcdi_flush_rxqs(struct efx_nic *efx);
+extern int efx_mcdi_set_mac(struct efx_nic *efx);
+extern int efx_mcdi_mac_stats(struct efx_nic *efx, dma_addr_t dma_addr,
+			      u32 dma_len, int enable, int clear);
+extern int efx_mcdi_mac_reconfigure(struct efx_nic *efx);
+extern bool efx_mcdi_mac_check_fault(struct efx_nic *efx);
+
+#endif /* EFX_MCDI_H */
diff -r 9566a4a50a43 drivers/net/sfc/mcdi_mac.c
--- /dev/null
+++ b/drivers/net/sfc/mcdi_mac.c
@@ -0,0 +1,132 @@
+/****************************************************************************
+ * Driver for Solarflare Solarstorm network controllers and boards
+ * Copyright 2009-2010 Solarflare Communications Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 as published
+ * by the Free Software Foundation, incorporated herein by reference.
+ */
+
+#include "net_driver.h"
+#include "efx.h"
+#include "mcdi.h"
+#include "mcdi_pcol.h"
+
+int efx_mcdi_set_mac(struct efx_nic *efx)
+{
+	u32 reject, fcntl;
+	u8 cmdbytes[MC_CMD_SET_MAC_IN_LEN];
+
+	BUILD_BUG_ON(MC_CMD_SET_MAC_OUT_LEN != 0);
+
+	memcpy(cmdbytes + MC_CMD_SET_MAC_IN_ADDR_OFST,
+	       efx->net_dev->dev_addr, ETH_ALEN);
+
+	MCDI_SET_DWORD(cmdbytes, SET_MAC_IN_MTU,
+			EFX_MAX_FRAME_LEN(efx->net_dev->mtu));
+	MCDI_SET_DWORD(cmdbytes, SET_MAC_IN_DRAIN, 0);
+
+	/* The MCDI command provides for controlling accept/reject
+	 * of broadcast packets too, but the driver doesn't currently
+	 * expose this. */
+	reject = (efx->promiscuous) ? 0 :
+		(1 << MC_CMD_SET_MAC_IN_REJECT_UNCST_LBN);
+	MCDI_SET_DWORD(cmdbytes, SET_MAC_IN_REJECT, reject);
+
+	switch ((unsigned)efx->wanted_fc) {
+	case EFX_FC_RX | EFX_FC_TX:
+		fcntl = MC_CMD_FCNTL_BIDIR;
+		break;
+	case EFX_FC_RX:
+		fcntl = MC_CMD_FCNTL_RESPOND;
+		break;
+	default:
+		fcntl = MC_CMD_FCNTL_OFF;
+		break;
+	}
+	if (efx->wanted_fc & EFX_FC_AUTO)
+		fcntl = MC_CMD_FCNTL_AUTO;
+	if (efx->fc_disable)
+		fcntl = MC_CMD_FCNTL_OFF;
+
+	MCDI_SET_DWORD(cmdbytes, SET_MAC_IN_FCNTL, fcntl);
+
+	return efx_mcdi_rpc(efx, MC_CMD_SET_MAC, cmdbytes, sizeof(cmdbytes),
+			    NULL, 0, NULL);
+}
+
+bool efx_mcdi_mac_check_fault(struct efx_nic *efx)
+{
+	u8 outbuf[MC_CMD_GET_LINK_OUT_LEN];
+	size_t outlength;
+	int rc;
+
+	BUILD_BUG_ON(MC_CMD_GET_LINK_IN_LEN != 0);
+
+	rc = efx_mcdi_rpc(efx, MC_CMD_GET_LINK, NULL, 0,
+			  outbuf, sizeof(outbuf), &outlength);
+	if (rc) {
+		netif_err(efx, hw, efx->net_dev, "%s: failed rc=%d\n",
+			  __func__, rc);
+		return true;
+	}
+
+	return MCDI_DWORD(outbuf, GET_LINK_OUT_MAC_FAULT) != 0;
+}
+
+int efx_mcdi_mac_stats(struct efx_nic *efx, dma_addr_t dma_addr,
+		       u32 dma_len, int enable, int clear)
+{
+	u8 inbuf[MC_CMD_MAC_STATS_IN_LEN];
+	int rc;
+	efx_dword_t *cmd_ptr;
+	int period = enable ? 1000 : 0;
+	u32 addr_hi;
+	u32 addr_lo;
+
+	BUILD_BUG_ON(MC_CMD_MAC_STATS_OUT_DMA_LEN != 0);
+
+	addr_lo = ((u64)dma_addr) >> 0;
+	addr_hi = ((u64)dma_addr) >> 32;
+
+	MCDI_SET_DWORD(inbuf, MAC_STATS_IN_DMA_ADDR_LO, addr_lo);
+	MCDI_SET_DWORD(inbuf, MAC_STATS_IN_DMA_ADDR_HI, addr_hi);
+	cmd_ptr = (efx_dword_t *)MCDI_PTR(inbuf, MAC_STATS_IN_CMD);
+	EFX_POPULATE_DWORD_7(*cmd_ptr,
+			     MC_CMD_MAC_STATS_IN_DMA, !!enable,
+			     MC_CMD_MAC_STATS_IN_CLEAR, clear,
+			     MC_CMD_MAC_STATS_IN_PERIODIC_CHANGE, 1,
+			     MC_CMD_MAC_STATS_IN_PERIODIC_ENABLE, !!enable,
+			     MC_CMD_MAC_STATS_IN_PERIODIC_CLEAR, 0,
+			     MC_CMD_MAC_STATS_IN_PERIODIC_NOEVENT, 1,
+			     MC_CMD_MAC_STATS_IN_PERIOD_MS, period);
+	MCDI_SET_DWORD(inbuf, MAC_STATS_IN_DMA_LEN, dma_len);
+
+	rc = efx_mcdi_rpc(efx, MC_CMD_MAC_STATS, inbuf, sizeof(inbuf),
+			  NULL, 0, NULL);
+	if (rc)
+		goto fail;
+
+	return 0;
+
+fail:
+	netif_err(efx, hw, efx->net_dev, "%s: %s failed rc=%d\n",
+		  __func__, enable ? "enable" : "disable", rc);
+	return rc;
+}
+
+int efx_mcdi_mac_reconfigure(struct efx_nic *efx)
+{
+	int rc;
+
+	WARN_ON(!mutex_is_locked(&efx->mac_lock));
+
+	rc = efx_mcdi_set_mac(efx);
+	if (rc != 0)
+		return rc;
+
+	return efx_mcdi_rpc(efx, MC_CMD_SET_MCAST_HASH,
+			    efx->multicast_hash.byte,
+			    sizeof(efx->multicast_hash),
+			    NULL, 0, NULL);
+}
diff -r 9566a4a50a43 drivers/net/sfc/mcdi_pcol.h
--- /dev/null
+++ b/drivers/net/sfc/mcdi_pcol.h
@@ -0,0 +1,3012 @@
+/****************************************************************************
+ * Driver for Solarflare Solarstorm network controllers and boards
+ * Copyright 2009-2011 Solarflare Communications Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 as published
+ * by the Free Software Foundation, incorporated herein by reference.
+ */
+
+
+#ifndef MCDI_PCOL_H
+#define MCDI_PCOL_H
+
+/* Values to be written into FMCR_CZ_RESET_STATE_REG to control boot. */
+/* Power-on reset state */
+#define MC_FW_STATE_POR (1)
+/* If this is set in MC_RESET_STATE_REG then it should be
+ * possible to jump into IMEM without loading code from flash. */
+#define MC_FW_WARM_BOOT_OK (2)
+/* The MC main image has started to boot. */
+#define MC_FW_STATE_BOOTING (4)
+/* The Scheduler has started. */
+#define MC_FW_STATE_SCHED (8)
+
+/* Siena MC shared memmory offsets */
+/* The 'doorbell' addresses are hard-wired to alert the MC when written */
+#define	MC_SMEM_P0_DOORBELL_OFST	0x000
+#define	MC_SMEM_P1_DOORBELL_OFST	0x004
+/* The rest of these are firmware-defined */
+#define	MC_SMEM_P0_PDU_OFST		0x008
+#define	MC_SMEM_P1_PDU_OFST		0x108
+#define	MC_SMEM_PDU_LEN			0x100
+#define	MC_SMEM_P0_PTP_TIME_OFST	0x7f0
+#define	MC_SMEM_P0_STATUS_OFST		0x7f8
+#define	MC_SMEM_P1_STATUS_OFST		0x7fc
+
+/* Values to be written to the per-port status dword in shared
+ * memory on reboot and assert */
+#define MC_STATUS_DWORD_REBOOT (0xb007b007)
+#define MC_STATUS_DWORD_ASSERT (0xdeaddead)
+
+/* The current version of the MCDI protocol.
+ *
+ * Note that the ROM burnt into the card only talks V0, so at the very
+ * least every driver must support version 0 and MCDI_PCOL_VERSION
+ */
+#define MCDI_PCOL_VERSION 1
+
+/* Unused commands: 0x23, 0x27, 0x30, 0x31 */
+
+/**
+ * MCDI version 1
+ *
+ * Each MCDI request starts with an MCDI_HEADER, which is a 32byte
+ * structure, filled in by the client.
+ *
+ *       0       7  8     16    20     22  23  24    31
+ *      | CODE | R | LEN | SEQ | Rsvd | E | R | XFLAGS |
+ *               |                      |   |
+ *               |                      |   \--- Response
+ *               |                      \------- Error
+ *               \------------------------------ Resync (always set)
+ *
+ * The client writes it's request into MC shared memory, and rings the
+ * doorbell. Each request is completed by either by the MC writting
+ * back into shared memory, or by writting out an event.
+ *
+ * All MCDI commands support completion by shared memory response. Each
+ * request may also contain additional data (accounted for by HEADER.LEN),
+ * and some response's may also contain additional data (again, accounted
+ * for by HEADER.LEN).
+ *
+ * Some MCDI commands support completion by event, in which any associated
+ * response data is included in the event.
+ *
+ * The protocol requires one response to be delivered for every request, a
+ * request should not be sent unless the response for the previous request
+ * has been received (either by polling shared memory, or by receiving
+ * an event).
+ */
+
+/** Request/Response structure */
+#define MCDI_HEADER_OFST 0
+#define MCDI_HEADER_CODE_LBN 0
+#define MCDI_HEADER_CODE_WIDTH 7
+#define MCDI_HEADER_RESYNC_LBN 7
+#define MCDI_HEADER_RESYNC_WIDTH 1
+#define MCDI_HEADER_DATALEN_LBN 8
+#define MCDI_HEADER_DATALEN_WIDTH 8
+#define MCDI_HEADER_SEQ_LBN 16
+#define MCDI_HEADER_RSVD_LBN 20
+#define MCDI_HEADER_RSVD_WIDTH 2
+#define MCDI_HEADER_SEQ_WIDTH 4
+#define MCDI_HEADER_ERROR_LBN 22
+#define MCDI_HEADER_ERROR_WIDTH 1
+#define MCDI_HEADER_RESPONSE_LBN 23
+#define MCDI_HEADER_RESPONSE_WIDTH 1
+#define MCDI_HEADER_XFLAGS_LBN 24
+#define MCDI_HEADER_XFLAGS_WIDTH 8
+/* Request response using event */
+#define MCDI_HEADER_XFLAGS_EVREQ 0x01
+
+/* Maximum number of payload bytes */
+#define MCDI_CTL_SDU_LEN_MAX 0xfc
+
+/* The MC can generate events for two reasons:
+ *   - To complete a shared memory request if XFLAGS_EVREQ was set
+ *   - As a notification (link state, i2c event), controlled
+ *     via MC_CMD_LOG_CTRL
+ *
+ * Both events share a common structure:
+ *
+ *  0      32     33      36    44     52     60
+ * | Data | Cont | Level | Src | Code | Rsvd |
+ *           |
+ *           \ There is another event pending in this notification
+ *
+ * If Code==CMDDONE, then the fields are further interpreted as:
+ *
+ *   - LEVEL==INFO    Command succeeded
+ *   - LEVEL==ERR     Command failed
+ *
+ *    0     8         16      24     32
+ *   | Seq | Datalen | Errno | Rsvd |
+ *
+ *   These fields are taken directly out of the standard MCDI header, i.e.,
+ *   LEVEL==ERR, Datalen == 0 => Reboot
+ *
+ * Events can be squirted out of the UART (using LOG_CTRL) without a
+ * MCDI header.  An event can be distinguished from a MCDI response by
+ * examining the first byte which is 0xc0.  This corresponds to the
+ * non-existent MCDI command MC_CMD_DEBUG_LOG.
+ *
+ *      0         7        8
+ *     | command | Resync |     = 0xc0
+ *
+ * Since the event is written in big-endian byte order, this works
+ * providing bits 56-63 of the event are 0xc0.
+ *
+ *      56     60  63
+ *     | Rsvd | Code |    = 0xc0
+ *
+ * Which means for convenience the event code is 0xc for all MC
+ * generated events.
+ */
+#define FSE_AZ_EV_CODE_MCDI_EVRESPONSE 0xc
+
+
+/* Non-existent command target */
+#define MC_CMD_ERR_ENOENT 2
+/* assert() has killed the MC */
+#define MC_CMD_ERR_EINTR 4
+/* Caller does not hold required locks */
+#define MC_CMD_ERR_EACCES 13
+/* Resource is currently unavailable (e.g. lock contention) */
+#define MC_CMD_ERR_EBUSY 16
+/* Invalid argument to target */
+#define MC_CMD_ERR_EINVAL 22
+/* Non-recursive resource is already acquired */
+#define MC_CMD_ERR_EDEADLK 35
+/* Operation not implemented */
+#define MC_CMD_ERR_ENOSYS 38
+/* Operation timed out */
+#define MC_CMD_ERR_ETIME 62
+
+#define MC_CMD_ERR_CODE_OFST 0
+
+/* We define 8 "escape" commands to allow
+   for command number space extension */
+
+#define MC_CMD_CMD_SPACE_ESCAPE_0	      0x78
+#define MC_CMD_CMD_SPACE_ESCAPE_1	      0x79
+#define MC_CMD_CMD_SPACE_ESCAPE_2	      0x7A
+#define MC_CMD_CMD_SPACE_ESCAPE_3	      0x7B
+#define MC_CMD_CMD_SPACE_ESCAPE_4	      0x7C
+#define MC_CMD_CMD_SPACE_ESCAPE_5	      0x7D
+#define MC_CMD_CMD_SPACE_ESCAPE_6	      0x7E
+#define MC_CMD_CMD_SPACE_ESCAPE_7	      0x7F
+
+/* Vectors in the boot ROM */
+/* Point to the copycode entry point. */
+#define MC_BOOTROM_COPYCODE_VEC (0x7f4)
+/* Points to the recovery mode entry point. */
+#define MC_BOOTROM_NOFLASH_VEC (0x7f8)
+
+/* The command set exported by the boot ROM (MCDI v0) */
+#define MC_CMD_GET_VERSION_V0_SUPPORTED_FUNCS {		\
+	(1 << MC_CMD_READ32)	|			\
+	(1 << MC_CMD_WRITE32)	|			\
+	(1 << MC_CMD_COPYCODE)	|			\
+	(1 << MC_CMD_GET_VERSION),			\
+	0, 0, 0 }
+
+#define MC_CMD_SENSOR_INFO_OUT_OFFSET_OFST(_x) \
+	(MC_CMD_SENSOR_ENTRY_OFST + (_x))
+
+#define MC_CMD_DBI_WRITE_IN_ADDRESS_OFST(n) (  \
+        (MC_CMD_DBI_WRITE_IN_DBIWROP_OFST+     \
+         MC_CMD_DBIWROP_TYPEDEF_ADDRESS_OFST)+ \
+         ((n)*MC_CMD_DBIWROP_TYPEDEF_LEN))
+
+#define MC_CMD_DBI_WRITE_IN_BYTE_MASK_OFST(n) (  \
+        (MC_CMD_DBI_WRITE_IN_DBIWROP_OFST+     \
+         MC_CMD_DBIWROP_TYPEDEF_BYTE_MASK_OFST)+ \
+         ((n)*MC_CMD_DBIWROP_TYPEDEF_LEN))
+
+#define MC_CMD_DBI_WRITE_IN_VALUE_OFST(n) (  \
+        (MC_CMD_DBI_WRITE_IN_DBIWROP_OFST+     \
+         MC_CMD_DBIWROP_TYPEDEF_VALUE_OFST)+ \
+         ((n)*MC_CMD_DBIWROP_TYPEDEF_LEN))
+
+
+/* MCDI_EVENT structuredef */
+#define    MCDI_EVENT_LEN 8
+#define       MCDI_EVENT_CONT_LBN 32
+#define       MCDI_EVENT_CONT_WIDTH 1
+#define       MCDI_EVENT_LEVEL_LBN 33
+#define       MCDI_EVENT_LEVEL_WIDTH 3
+#define          MCDI_EVENT_LEVEL_INFO  0x0 /* enum */
+#define          MCDI_EVENT_LEVEL_WARN 0x1 /* enum */
+#define          MCDI_EVENT_LEVEL_ERR 0x2 /* enum */
+#define          MCDI_EVENT_LEVEL_FATAL 0x3 /* enum */
+#define       MCDI_EVENT_DATA_OFST 0
+#define        MCDI_EVENT_CMDDONE_SEQ_LBN 0
+#define        MCDI_EVENT_CMDDONE_SEQ_WIDTH 8
+#define        MCDI_EVENT_CMDDONE_DATALEN_LBN 8
+#define        MCDI_EVENT_CMDDONE_DATALEN_WIDTH 8
+#define        MCDI_EVENT_CMDDONE_ERRNO_LBN 16
+#define        MCDI_EVENT_CMDDONE_ERRNO_WIDTH 8
+#define        MCDI_EVENT_LINKCHANGE_LP_CAP_LBN 0
+#define        MCDI_EVENT_LINKCHANGE_LP_CAP_WIDTH 16
+#define        MCDI_EVENT_LINKCHANGE_SPEED_LBN 16
+#define        MCDI_EVENT_LINKCHANGE_SPEED_WIDTH 4
+#define          MCDI_EVENT_LINKCHANGE_SPEED_100M  0x1 /* enum */
+#define          MCDI_EVENT_LINKCHANGE_SPEED_1G  0x2 /* enum */
+#define          MCDI_EVENT_LINKCHANGE_SPEED_10G  0x3 /* enum */
+#define        MCDI_EVENT_LINKCHANGE_FCNTL_LBN 20
+#define        MCDI_EVENT_LINKCHANGE_FCNTL_WIDTH 4
+#define        MCDI_EVENT_LINKCHANGE_LINK_FLAGS_LBN 24
+#define        MCDI_EVENT_LINKCHANGE_LINK_FLAGS_WIDTH 8
+#define        MCDI_EVENT_SENSOREVT_MONITOR_LBN 0
+#define        MCDI_EVENT_SENSOREVT_MONITOR_WIDTH 8
+#define        MCDI_EVENT_SENSOREVT_STATE_LBN 8
+#define        MCDI_EVENT_SENSOREVT_STATE_WIDTH 8
+#define        MCDI_EVENT_SENSOREVT_VALUE_LBN 16
+#define        MCDI_EVENT_SENSOREVT_VALUE_WIDTH 16
+#define        MCDI_EVENT_FWALERT_DATA_LBN 8
+#define        MCDI_EVENT_FWALERT_DATA_WIDTH 24
+#define        MCDI_EVENT_FWALERT_REASON_LBN 0
+#define        MCDI_EVENT_FWALERT_REASON_WIDTH 8
+#define          MCDI_EVENT_FWALERT_REASON_SRAM_ACCESS 0x1 /* enum */
+#define        MCDI_EVENT_FLR_VF_LBN 0
+#define        MCDI_EVENT_FLR_VF_WIDTH 8
+#define        MCDI_EVENT_TX_ERR_TXQ_LBN 0
+#define        MCDI_EVENT_TX_ERR_TXQ_WIDTH 12
+#define        MCDI_EVENT_TX_ERR_TYPE_LBN 12
+#define        MCDI_EVENT_TX_ERR_TYPE_WIDTH 4
+#define          MCDI_EVENT_TX_ERR_DL_FAIL 0x1 /* enum */
+#define          MCDI_EVENT_TX_ERR_NO_EOP 0x2 /* enum */
+#define          MCDI_EVENT_TX_ERR_2BIG 0x3 /* enum */
+#define        MCDI_EVENT_TX_ERR_INFO_LBN 16
+#define        MCDI_EVENT_TX_ERR_INFO_WIDTH 16
+#define        MCDI_EVENT_TX_FLUSH_TXQ_LBN 0
+#define        MCDI_EVENT_TX_FLUSH_TXQ_WIDTH 12
+#define        MCDI_EVENT_PTP_ERR_TYPE_LBN 0
+#define        MCDI_EVENT_PTP_ERR_TYPE_WIDTH 8
+#define          MCDI_EVENT_PTP_ERR_PLL_LOST 0x1 /* enum */
+#define          MCDI_EVENT_PTP_ERR_FILTER 0x2 /* enum */
+#define          MCDI_EVENT_PTP_ERR_FIFO 0x3 /* enum */
+#define          MCDI_EVENT_PTP_ERR_QUEUE 0x4 /* enum */
+#define       MCDI_EVENT_DATA_LBN 0
+#define       MCDI_EVENT_DATA_WIDTH 32
+#define       MCDI_EVENT_SRC_LBN 36
+#define       MCDI_EVENT_SRC_WIDTH 8
+#define       MCDI_EVENT_EV_CODE_LBN 60
+#define       MCDI_EVENT_EV_CODE_WIDTH 4
+#define       MCDI_EVENT_CODE_LBN 44
+#define       MCDI_EVENT_CODE_WIDTH 8
+#define          MCDI_EVENT_CODE_BADSSERT 0x1 /* enum */
+#define          MCDI_EVENT_CODE_PMNOTICE 0x2 /* enum */
+#define          MCDI_EVENT_CODE_CMDDONE 0x3 /* enum */
+#define          MCDI_EVENT_CODE_LINKCHANGE 0x4 /* enum */
+#define          MCDI_EVENT_CODE_SENSOREVT 0x5 /* enum */
+#define          MCDI_EVENT_CODE_SCHEDERR 0x6 /* enum */
+#define          MCDI_EVENT_CODE_REBOOT 0x7 /* enum */
+#define          MCDI_EVENT_CODE_MAC_STATS_DMA 0x8 /* enum */
+#define          MCDI_EVENT_CODE_FWALERT 0x9 /* enum */
+#define          MCDI_EVENT_CODE_FLR 0xa /* enum */
+#define          MCDI_EVENT_CODE_TX_ERR 0xb /* enum */
+#define          MCDI_EVENT_CODE_TX_FLUSH  0xc /* enum */
+#define          MCDI_EVENT_CODE_PTP_RX  0xd /* enum */
+#define          MCDI_EVENT_CODE_PTP_FAULT  0xe /* enum */
+#define       MCDI_EVENT_CMDDONE_DATA_OFST 0
+#define       MCDI_EVENT_CMDDONE_DATA_LBN 0
+#define       MCDI_EVENT_CMDDONE_DATA_WIDTH 32
+#define       MCDI_EVENT_LINKCHANGE_DATA_OFST 0
+#define       MCDI_EVENT_LINKCHANGE_DATA_LBN 0
+#define       MCDI_EVENT_LINKCHANGE_DATA_WIDTH 32
+#define       MCDI_EVENT_SENSOREVT_DATA_OFST 0
+#define       MCDI_EVENT_SENSOREVT_DATA_LBN 0
+#define       MCDI_EVENT_SENSOREVT_DATA_WIDTH 32
+#define       MCDI_EVENT_MAC_STATS_DMA_GENERATION_OFST 0
+#define       MCDI_EVENT_MAC_STATS_DMA_GENERATION_LBN 0
+#define       MCDI_EVENT_MAC_STATS_DMA_GENERATION_WIDTH 32
+#define       MCDI_EVENT_TX_ERR_DATA_OFST 0
+#define       MCDI_EVENT_TX_ERR_DATA_LBN 0
+#define       MCDI_EVENT_TX_ERR_DATA_WIDTH 32
+#define       MCDI_EVENT_PTP_SECONDS_OFST 0
+#define       MCDI_EVENT_PTP_SECONDS_LBN 0
+#define       MCDI_EVENT_PTP_SECONDS_WIDTH 32
+#define       MCDI_EVENT_PTP_NANOSECONDS_OFST 0
+#define       MCDI_EVENT_PTP_NANOSECONDS_LBN 0
+#define       MCDI_EVENT_PTP_NANOSECONDS_WIDTH 32
+#define       MCDI_EVENT_PTP_UUID_OFST 0
+#define       MCDI_EVENT_PTP_UUID_LBN 0
+#define       MCDI_EVENT_PTP_UUID_WIDTH 32
+
+
+/***********************************/
+/* MC_CMD_READ32
+ * Read multiple 32byte words from MC memory.
+ */
+#define MC_CMD_READ32 0x1
+
+/* MC_CMD_READ32_IN msgrequest */
+#define    MC_CMD_READ32_IN_LEN 8
+#define       MC_CMD_READ32_IN_ADDR_OFST 0
+#define       MC_CMD_READ32_IN_NUMWORDS_OFST 4
+
+/* MC_CMD_READ32_OUT msgresponse */
+#define    MC_CMD_READ32_OUT_LENMIN 4
+#define    MC_CMD_READ32_OUT_LENMAX 252
+#define    MC_CMD_READ32_OUT_LEN(num) (0+4*(num))
+#define       MC_CMD_READ32_OUT_BUFFER_OFST 0
+#define       MC_CMD_READ32_OUT_BUFFER_LEN 4
+#define       MC_CMD_READ32_OUT_BUFFER_MINNUM 1
+#define       MC_CMD_READ32_OUT_BUFFER_MAXNUM 63
+
+
+/***********************************/
+/* MC_CMD_WRITE32
+ * Write multiple 32byte words to MC memory.
+ */
+#define MC_CMD_WRITE32 0x2
+
+/* MC_CMD_WRITE32_IN msgrequest */
+#define    MC_CMD_WRITE32_IN_LENMIN 8
+#define    MC_CMD_WRITE32_IN_LENMAX 252
+#define    MC_CMD_WRITE32_IN_LEN(num) (4+4*(num))
+#define       MC_CMD_WRITE32_IN_ADDR_OFST 0
+#define       MC_CMD_WRITE32_IN_BUFFER_OFST 4
+#define       MC_CMD_WRITE32_IN_BUFFER_LEN 4
+#define       MC_CMD_WRITE32_IN_BUFFER_MINNUM 1
+#define       MC_CMD_WRITE32_IN_BUFFER_MAXNUM 62
+
+/* MC_CMD_WRITE32_OUT msgresponse */
+#define    MC_CMD_WRITE32_OUT_LEN 0
+
+
+/***********************************/
+/* MC_CMD_COPYCODE
+ * Copy MC code between two locations and jump.
+ */
+#define MC_CMD_COPYCODE 0x3
+
+/* MC_CMD_COPYCODE_IN msgrequest */
+#define    MC_CMD_COPYCODE_IN_LEN 16
+#define       MC_CMD_COPYCODE_IN_SRC_ADDR_OFST 0
+#define       MC_CMD_COPYCODE_IN_DEST_ADDR_OFST 4
+#define       MC_CMD_COPYCODE_IN_NUMWORDS_OFST 8
+#define       MC_CMD_COPYCODE_IN_JUMP_OFST 12
+#define          MC_CMD_COPYCODE_JUMP_NONE 0x1 /* enum */
+
+/* MC_CMD_COPYCODE_OUT msgresponse */
+#define    MC_CMD_COPYCODE_OUT_LEN 0
+
+
+/***********************************/
+/* MC_CMD_SET_FUNC 
+ */
+#define MC_CMD_SET_FUNC  0x4
+
+/* MC_CMD_SET_FUNC_IN msgrequest */
+#define    MC_CMD_SET_FUNC_IN_LEN 4
+#define       MC_CMD_SET_FUNC_IN_FUNC_OFST 0
+
+/* MC_CMD_SET_FUNC_OUT msgresponse */
+#define    MC_CMD_SET_FUNC_OUT_LEN 0
+
+
+/***********************************/
+/* MC_CMD_GET_BOOT_STATUS
+ */
+#define MC_CMD_GET_BOOT_STATUS 0x5
+
+/* MC_CMD_GET_BOOT_STATUS_IN msgrequest */
+#define    MC_CMD_GET_BOOT_STATUS_IN_LEN 0
+
+/* MC_CMD_GET_BOOT_STATUS_OUT msgresponse */
+#define    MC_CMD_GET_BOOT_STATUS_OUT_LEN 8
+#define       MC_CMD_GET_BOOT_STATUS_OUT_BOOT_OFFSET_OFST 0
+#define       MC_CMD_GET_BOOT_STATUS_OUT_FLAGS_OFST 4
+#define        MC_CMD_GET_BOOT_STATUS_OUT_FLAGS_WATCHDOG_LBN 0
+#define        MC_CMD_GET_BOOT_STATUS_OUT_FLAGS_WATCHDOG_WIDTH 1
+#define        MC_CMD_GET_BOOT_STATUS_OUT_FLAGS_PRIMARY_LBN 1
+#define        MC_CMD_GET_BOOT_STATUS_OUT_FLAGS_PRIMARY_WIDTH 1
+#define        MC_CMD_GET_BOOT_STATUS_OUT_FLAGS_BACKUP_LBN 2
+#define        MC_CMD_GET_BOOT_STATUS_OUT_FLAGS_BACKUP_WIDTH 1
+
+
+/***********************************/
+/* MC_CMD_GET_ASSERTS 
+ * Get and clear any assertion status.
+ */
+#define MC_CMD_GET_ASSERTS  0x6
+
+/* MC_CMD_GET_ASSERTS_IN msgrequest */
+#define    MC_CMD_GET_ASSERTS_IN_LEN 4
+#define       MC_CMD_GET_ASSERTS_IN_CLEAR_OFST 0
+
+/* MC_CMD_GET_ASSERTS_OUT msgresponse */
+#define    MC_CMD_GET_ASSERTS_OUT_LEN 140
+#define       MC_CMD_GET_ASSERTS_OUT_GLOBAL_FLAGS_OFST 0
+#define          MC_CMD_GET_ASSERTS_FLAGS_NO_FAILS 0x1 /* enum */
+#define          MC_CMD_GET_ASSERTS_FLAGS_SYS_FAIL 0x2 /* enum */
+#define          MC_CMD_GET_ASSERTS_FLAGS_THR_FAIL 0x3 /* enum */
+#define          MC_CMD_GET_ASSERTS_FLAGS_WDOG_FIRED 0x4 /* enum */
+#define       MC_CMD_GET_ASSERTS_OUT_SAVED_PC_OFFS_OFST 4
+#define       MC_CMD_GET_ASSERTS_OUT_GP_REGS_OFFS_OFST 8
+#define       MC_CMD_GET_ASSERTS_OUT_GP_REGS_OFFS_LEN 4
+#define       MC_CMD_GET_ASSERTS_OUT_GP_REGS_OFFS_NUM 31
+#define       MC_CMD_GET_ASSERTS_OUT_THREAD_OFFS_OFST 132
+#define       MC_CMD_GET_ASSERTS_OUT_RESERVED_OFST 136
+
+
+/***********************************/
+/* MC_CMD_LOG_CTRL 
+ * Configure the output stream for various events and messages.
+ */
+#define MC_CMD_LOG_CTRL  0x7
+
+/* MC_CMD_LOG_CTRL_IN msgrequest */
+#define    MC_CMD_LOG_CTRL_IN_LEN 8
+#define       MC_CMD_LOG_CTRL_IN_LOG_DEST_OFST 0
+#define          MC_CMD_LOG_CTRL_IN_LOG_DEST_UART 0x1 /* enum */
+#define          MC_CMD_LOG_CTRL_IN_LOG_DEST_EVQ 0x2 /* enum */
+#define       MC_CMD_LOG_CTRL_IN_LOG_DEST_EVQ_OFST 4
+
+/* MC_CMD_LOG_CTRL_OUT msgresponse */
+#define    MC_CMD_LOG_CTRL_OUT_LEN 0
+
+
+/***********************************/
+/* MC_CMD_GET_VERSION 
+ * Get version information about the MC firmware.
+ */
+#define MC_CMD_GET_VERSION  0x8
+
+/* MC_CMD_GET_VERSION_IN msgrequest */
+#define    MC_CMD_GET_VERSION_IN_LEN 0
+
+/* MC_CMD_GET_VERSION_V0_OUT msgresponse */
+#define    MC_CMD_GET_VERSION_V0_OUT_LEN 4
+#define       MC_CMD_GET_VERSION_OUT_FIRMWARE_OFST 0
+#define          MC_CMD_GET_VERSION_OUT_FIRMWARE_ANY 0xffffffff /* enum */
+#define          MC_CMD_GET_VERSION_OUT_FIRMWARE_BOOTROM 0xb0070000 /* enum */
+
+/* MC_CMD_GET_VERSION_OUT msgresponse */
+#define    MC_CMD_GET_VERSION_OUT_LEN 32
+/*            MC_CMD_GET_VERSION_OUT_FIRMWARE_OFST 0 */
+/*            Enum values, see field(s): */
+/*               MC_CMD_GET_VERSION_V0_OUT/MC_CMD_GET_VERSION_OUT_FIRMWARE */
+#define       MC_CMD_GET_VERSION_OUT_PCOL_OFST 4
+#define       MC_CMD_GET_VERSION_OUT_SUPPORTED_FUNCS_OFST 8
+#define       MC_CMD_GET_VERSION_OUT_SUPPORTED_FUNCS_LEN 16
+#define       MC_CMD_GET_VERSION_OUT_VERSION_OFST 24
+#define       MC_CMD_GET_VERSION_OUT_VERSION_LEN 8
+#define       MC_CMD_GET_VERSION_OUT_VERSION_LO_OFST 24
+#define       MC_CMD_GET_VERSION_OUT_VERSION_HI_OFST 28
+
+
+/***********************************/
+/* MC_CMD_GET_FPGAREG 
+ * Read multiple bytes from PTP FPGA.
+ */
+#define MC_CMD_GET_FPGAREG  0x9
+
+/* MC_CMD_GET_FPGAREG_IN msgrequest */
+#define    MC_CMD_GET_FPGAREG_IN_LEN 8
+#define       MC_CMD_GET_FPGAREG_IN_ADDR_OFST 0
+#define       MC_CMD_GET_FPGAREG_IN_NUMBYTES_OFST 4
+
+/* MC_CMD_GET_FPGAREG_OUT msgresponse */
+#define    MC_CMD_GET_FPGAREG_OUT_LENMIN 1
+#define    MC_CMD_GET_FPGAREG_OUT_LENMAX 255
+#define    MC_CMD_GET_FPGAREG_OUT_LEN(num) (0+1*(num))
+#define       MC_CMD_GET_FPGAREG_OUT_BUFFER_OFST 0
+#define       MC_CMD_GET_FPGAREG_OUT_BUFFER_LEN 1
+#define       MC_CMD_GET_FPGAREG_OUT_BUFFER_MINNUM 1
+#define       MC_CMD_GET_FPGAREG_OUT_BUFFER_MAXNUM 255
+
+
+/***********************************/
+/* MC_CMD_PUT_FPGAREG 
+ * Write multiple bytes to PTP FPGA.
+ */
+#define MC_CMD_PUT_FPGAREG  0xa
+
+/* MC_CMD_PUT_FPGAREG_IN msgrequest */
+#define    MC_CMD_PUT_FPGAREG_IN_LENMIN 5
+#define    MC_CMD_PUT_FPGAREG_IN_LENMAX 255
+#define    MC_CMD_PUT_FPGAREG_IN_LEN(num) (4+1*(num))
+#define       MC_CMD_PUT_FPGAREG_IN_ADDR_OFST 0
+#define       MC_CMD_PUT_FPGAREG_IN_BUFFER_OFST 4
+#define       MC_CMD_PUT_FPGAREG_IN_BUFFER_LEN 1
+#define       MC_CMD_PUT_FPGAREG_IN_BUFFER_MINNUM 1
+#define       MC_CMD_PUT_FPGAREG_IN_BUFFER_MAXNUM 251
+
+/* MC_CMD_PUT_FPGAREG_OUT msgresponse */
+#define    MC_CMD_PUT_FPGAREG_OUT_LEN 0
+
+
+/***********************************/
+/* MC_CMD_PTP 
+ * Perform PTP operation
+ */
+#define MC_CMD_PTP  0xb
+
+/* MC_CMD_PTP_IN msgrequest */
+#define    MC_CMD_PTP_IN_LEN 1
+#define       MC_CMD_PTP_IN_OP_OFST 0
+#define       MC_CMD_PTP_IN_OP_LEN 1
+#define          MC_CMD_PTP_OP_ENABLE 0x1 /* enum */
+#define          MC_CMD_PTP_OP_DISABLE 0x2 /* enum */
+#define          MC_CMD_PTP_OP_TRANSMIT 0x3 /* enum */
+#define          MC_CMD_PTP_OP_READ_NIC_TIME 0x4 /* enum */
+#define          MC_CMD_PTP_OP_STATUS 0x5 /* enum */
+#define          MC_CMD_PTP_OP_ADJUST 0x6 /* enum */
+#define          MC_CMD_PTP_OP_SYNCHRONIZE 0x7 /* enum */
+#define          MC_CMD_PTP_OP_MANFTEST_BASIC 0x8 /* enum */
+#define          MC_CMD_PTP_OP_MANFTEST_PACKET 0x9 /* enum */
+#define          MC_CMD_PTP_OP_RESET_STATS 0xa /* enum */
+#define          MC_CMD_PTP_OP_DEBUG 0xb /* enum */
+#define          MC_CMD_PTP_OP_MAX 0xc /* enum */
+
+/* MC_CMD_PTP_IN_ENABLE msgrequest */
+#define    MC_CMD_PTP_IN_ENABLE_LEN 16
+#define       MC_CMD_PTP_IN_CMD_OFST 0
+#define       MC_CMD_PTP_IN_PERIPH_ID_OFST 4
+#define       MC_CMD_PTP_IN_ENABLE_QUEUE_OFST 8
+#define       MC_CMD_PTP_IN_ENABLE_MODE_OFST 12
+#define          MC_CMD_PTP_MODE_V1 0x0 /* enum */
+#define          MC_CMD_PTP_MODE_V1_VLAN 0x1 /* enum */
+#define          MC_CMD_PTP_MODE_V2 0x2 /* enum */
+#define          MC_CMD_PTP_MODE_V2_VLAN 0x3 /* enum */
+
+/* MC_CMD_PTP_IN_DISABLE msgrequest */
+#define    MC_CMD_PTP_IN_DISABLE_LEN 8
+/*            MC_CMD_PTP_IN_CMD_OFST 0 */
+/*            MC_CMD_PTP_IN_PERIPH_ID_OFST 4 */
+
+/* MC_CMD_PTP_IN_TRANSMIT msgrequest */
+#define    MC_CMD_PTP_IN_TRANSMIT_LENMIN 13
+#define    MC_CMD_PTP_IN_TRANSMIT_LENMAX 255
+#define    MC_CMD_PTP_IN_TRANSMIT_LEN(num) (12+1*(num))
+/*            MC_CMD_PTP_IN_CMD_OFST 0 */
+/*            MC_CMD_PTP_IN_PERIPH_ID_OFST 4 */
+#define       MC_CMD_PTP_IN_TRANSMIT_LENGTH_OFST 8
+#define       MC_CMD_PTP_IN_TRANSMIT_PACKET_OFST 12
+#define       MC_CMD_PTP_IN_TRANSMIT_PACKET_LEN 1
+#define       MC_CMD_PTP_IN_TRANSMIT_PACKET_MINNUM 1
+#define       MC_CMD_PTP_IN_TRANSMIT_PACKET_MAXNUM 243
+
+/* MC_CMD_PTP_IN_READ_NIC_TIME msgrequest */
+#define    MC_CMD_PTP_IN_READ_NIC_TIME_LEN 8
+/*            MC_CMD_PTP_IN_CMD_OFST 0 */
+/*            MC_CMD_PTP_IN_PERIPH_ID_OFST 4 */
+
+/* MC_CMD_PTP_IN_STATUS msgrequest */
+#define    MC_CMD_PTP_IN_STATUS_LEN 8
+/*            MC_CMD_PTP_IN_CMD_OFST 0 */
+/*            MC_CMD_PTP_IN_PERIPH_ID_OFST 4 */
+
+/* MC_CMD_PTP_IN_ADJUST msgrequest */
+#define    MC_CMD_PTP_IN_ADJUST_LEN 24
+/*            MC_CMD_PTP_IN_CMD_OFST 0 */
+/*            MC_CMD_PTP_IN_PERIPH_ID_OFST 4 */
+#define       MC_CMD_PTP_IN_ADJUST_FREQ_OFST 8
+#define       MC_CMD_PTP_IN_ADJUST_FREQ_LEN 8
+#define       MC_CMD_PTP_IN_ADJUST_FREQ_LO_OFST 8
+#define       MC_CMD_PTP_IN_ADJUST_FREQ_HI_OFST 12
+#define          MC_CMD_PTP_IN_ADJUST_BITS 0x28 /* enum */
+#define       MC_CMD_PTP_IN_ADJUST_SECONDS_OFST 16
+#define       MC_CMD_PTP_IN_ADJUST_NANOSECONDS_OFST 20
+
+/* MC_CMD_PTP_IN_SYNCHRONIZE msgrequest */
+#define    MC_CMD_PTP_IN_SYNCHRONIZE_LEN 20
+/*            MC_CMD_PTP_IN_CMD_OFST 0 */
+/*            MC_CMD_PTP_IN_PERIPH_ID_OFST 4 */
+#define       MC_CMD_PTP_IN_SYNCHRONIZE_NUMTIMESETS_OFST 8
+#define       MC_CMD_PTP_IN_SYNCHRONIZE_START_ADDR_OFST 12
+#define       MC_CMD_PTP_IN_SYNCHRONIZE_START_ADDR_LEN 8
+#define       MC_CMD_PTP_IN_SYNCHRONIZE_START_ADDR_LO_OFST 12
+#define       MC_CMD_PTP_IN_SYNCHRONIZE_START_ADDR_HI_OFST 16
+
+/* MC_CMD_PTP_IN_MANFTEST_BASIC msgrequest */
+#define    MC_CMD_PTP_IN_MANFTEST_BASIC_LEN 8
+/*            MC_CMD_PTP_IN_CMD_OFST 0 */
+/*            MC_CMD_PTP_IN_PERIPH_ID_OFST 4 */
+
+/* MC_CMD_PTP_IN_MANFTEST_PACKET msgrequest */
+#define    MC_CMD_PTP_IN_MANFTEST_PACKET_LEN 12
+/*            MC_CMD_PTP_IN_CMD_OFST 0 */
+/*            MC_CMD_PTP_IN_PERIPH_ID_OFST 4 */
+#define       MC_CMD_PTP_IN_MANFTEST_PACKET_TEST_ENABLE_OFST 8
+
+/* MC_CMD_PTP_IN_RESET_STATS msgrequest */
+#define    MC_CMD_PTP_IN_RESET_STATS_LEN 8
+/*            MC_CMD_PTP_IN_CMD_OFST 0 */
+/*            MC_CMD_PTP_IN_PERIPH_ID_OFST 4 */
+
+/* MC_CMD_PTP_IN_DEBUG msgrequest */
+#define    MC_CMD_PTP_IN_DEBUG_LEN 12
+/*            MC_CMD_PTP_IN_CMD_OFST 0 */
+/*            MC_CMD_PTP_IN_PERIPH_ID_OFST 4 */
+#define       MC_CMD_PTP_IN_DEBUG_DEBUG_PARAM_OFST 8
+
+/* MC_CMD_PTP_OUT msgresponse */
+#define    MC_CMD_PTP_OUT_LEN 0
+
+/* MC_CMD_PTP_OUT_TRANSMIT msgresponse */
+#define    MC_CMD_PTP_OUT_TRANSMIT_LEN 8
+#define       MC_CMD_PTP_OUT_TRANSMIT_SECONDS_OFST 0
+#define       MC_CMD_PTP_OUT_TRANSMIT_NANOSECONDS_OFST 4
+
+/* MC_CMD_PTP_OUT_READ_NIC_TIME msgresponse */
+#define    MC_CMD_PTP_OUT_READ_NIC_TIME_LEN 8
+#define       MC_CMD_PTP_OUT_READ_NIC_TIME_SECONDS_OFST 0
+#define       MC_CMD_PTP_OUT_READ_NIC_TIME_NANOSECONDS_OFST 4
+
+/* MC_CMD_PTP_OUT_STATUS msgresponse */
+#define    MC_CMD_PTP_OUT_STATUS_LEN 64
+#define       MC_CMD_PTP_OUT_STATUS_CLOCK_FREQ_OFST 0
+#define       MC_CMD_PTP_OUT_STATUS_STATS_TX_OFST 4
+#define       MC_CMD_PTP_OUT_STATUS_STATS_RX_OFST 8
+#define       MC_CMD_PTP_OUT_STATUS_STATS_TS_OFST 12
+#define       MC_CMD_PTP_OUT_STATUS_STATS_FM_OFST 16
+#define       MC_CMD_PTP_OUT_STATUS_STATS_NFM_OFST 20
+#define       MC_CMD_PTP_OUT_STATUS_STATS_PPS_OFLOW_OFST 24
+#define       MC_CMD_PTP_OUT_STATUS_STATS_PPS_BAD_OFST 28
+#define       MC_CMD_PTP_OUT_STATUS_STATS_PPS_PER_MIN_OFST 32
+#define       MC_CMD_PTP_OUT_STATUS_STATS_PPS_PER_MAX_OFST 36
+#define       MC_CMD_PTP_OUT_STATUS_STATS_PPS_PER_LAST_OFST 40
+#define       MC_CMD_PTP_OUT_STATUS_STATS_PPS_PER_MEAN_OFST 44
+#define       MC_CMD_PTP_OUT_STATUS_STATS_PPS_OFF_MIN_OFST 48
+#define       MC_CMD_PTP_OUT_STATUS_STATS_PPS_OFF_MAX_OFST 52
+#define       MC_CMD_PTP_OUT_STATUS_STATS_PPS_OFF_LAST_OFST 56
+#define       MC_CMD_PTP_OUT_STATUS_STATS_PPS_OFF_MEAN_OFST 60
+
+/* MC_CMD_PTP_OUT_SYNCHRONIZE msgresponse */
+#define    MC_CMD_PTP_OUT_SYNCHRONIZE_LENMIN 20
+#define    MC_CMD_PTP_OUT_SYNCHRONIZE_LENMAX 240
+#define    MC_CMD_PTP_OUT_SYNCHRONIZE_LEN(num) (0+20*(num))
+#define       MC_CMD_PTP_OUT_SYNCHRONIZE_TIMESET_OFST 0
+#define       MC_CMD_PTP_OUT_SYNCHRONIZE_TIMESET_LEN 20
+#define       MC_CMD_PTP_OUT_SYNCHRONIZE_TIMESET_MINNUM 1
+#define       MC_CMD_PTP_OUT_SYNCHRONIZE_TIMESET_MAXNUM 12
+#define       MC_CMD_PTP_OUT_SYNCHRONIZE_HOSTSTART_OFST 0
+#define       MC_CMD_PTP_OUT_SYNCHRONIZE_SECONDS_OFST 4
+#define       MC_CMD_PTP_OUT_SYNCHRONIZE_NANOSECONDS_OFST 8
+#define       MC_CMD_PTP_OUT_SYNCHRONIZE_HOSTEND_OFST 12
+#define       MC_CMD_PTP_OUT_SYNCHRONIZE_WAITNS_OFST 16
+
+/* MC_CMD_PTP_OUT_MANFTEST_BASIC msgresponse */
+#define    MC_CMD_PTP_OUT_MANFTEST_BASIC_LEN 8
+#define       MC_CMD_PTP_OUT_MANFTEST_BASIC_TEST_RESULT_OFST 0
+#define          MC_CMD_PTP_MANF_SUCCESS 0x0 /* enum */
+#define          MC_CMD_PTP_MANF_FPGA_LOAD 0x1 /* enum */
+#define          MC_CMD_PTP_MANF_FPGA_VERSION 0x2 /* enum */
+#define          MC_CMD_PTP_MANF_FPGA_REGISTERS 0x3 /* enum */
+#define          MC_CMD_PTP_MANF_OSCILLATOR 0x4 /* enum */
+#define          MC_CMD_PTP_MANF_TIMESTAMPS 0x5 /* enum */
+#define          MC_CMD_PTP_MANF_PACKET_COUNT 0x6 /* enum */
+#define          MC_CMD_PTP_MANF_FILTER_COUNT 0x7 /* enum */
+#define          MC_CMD_PTP_MANF_PACKET_ENOUGH 0x8 /* enum */
+#define          MC_CMD_PTP_MANF_GPIO_TRIGGER 0x9 /* enum */
+#define       MC_CMD_PTP_OUT_MANFTEST_BASIC_TEST_EXTOSC_OFST 4
+
+/* MC_CMD_PTP_OUT_MANFTEST_PACKET msgresponse */
+#define    MC_CMD_PTP_OUT_MANFTEST_PACKET_LEN 12
+#define       MC_CMD_PTP_OUT_MANFTEST_PACKET_TEST_RESULT_OFST 0
+#define       MC_CMD_PTP_OUT_MANFTEST_PACKET_TEST_FPGACOUNT_OFST 4
+#define       MC_CMD_PTP_OUT_MANFTEST_PACKET_TEST_FILTERCOUNT_OFST 8
+
+
+/***********************************/
+/* MC_CMD_CSR_READ32 
+ * Read 32bit words from the indirect memory map.
+ */
+#define MC_CMD_CSR_READ32  0xc
+
+/* MC_CMD_CSR_READ32_IN msgrequest */
+#define    MC_CMD_CSR_READ32_IN_LEN 12
+#define       MC_CMD_CSR_READ32_IN_ADDR_OFST 0
+#define       MC_CMD_CSR_READ32_IN_STEP_OFST 4
+#define       MC_CMD_CSR_READ32_IN_NUMWORDS_OFST 8
+
+/* MC_CMD_CSR_READ32_OUT msgresponse */
+#define    MC_CMD_CSR_READ32_OUT_LENMIN 4
+#define    MC_CMD_CSR_READ32_OUT_LENMAX 252
+#define    MC_CMD_CSR_READ32_OUT_LEN(num) (0+4*(num))
+#define       MC_CMD_CSR_READ32_OUT_BUFFER_OFST 0
+#define       MC_CMD_CSR_READ32_OUT_BUFFER_LEN 4
+#define       MC_CMD_CSR_READ32_OUT_BUFFER_MINNUM 1
+#define       MC_CMD_CSR_READ32_OUT_BUFFER_MAXNUM 63
+
+
+/***********************************/
+/* MC_CMD_CSR_WRITE32 
+ * Write 32bit dwords to the indirect memory map.
+ */
+#define MC_CMD_CSR_WRITE32  0xd
+
+/* MC_CMD_CSR_WRITE32_IN msgrequest */
+#define    MC_CMD_CSR_WRITE32_IN_LENMIN 12
+#define    MC_CMD_CSR_WRITE32_IN_LENMAX 252
+#define    MC_CMD_CSR_WRITE32_IN_LEN(num) (8+4*(num))
+#define       MC_CMD_CSR_WRITE32_IN_ADDR_OFST 0
+#define       MC_CMD_CSR_WRITE32_IN_STEP_OFST 4
+#define       MC_CMD_CSR_WRITE32_IN_BUFFER_OFST 8
+#define       MC_CMD_CSR_WRITE32_IN_BUFFER_LEN 4
+#define       MC_CMD_CSR_WRITE32_IN_BUFFER_MINNUM 1
+#define       MC_CMD_CSR_WRITE32_IN_BUFFER_MAXNUM 61
+
+/* MC_CMD_CSR_WRITE32_OUT msgresponse */
+#define    MC_CMD_CSR_WRITE32_OUT_LEN 4
+#define       MC_CMD_CSR_WRITE32_OUT_STATUS_OFST 0
+
+
+/***********************************/
+/* MC_CMD_STACKINFO 
+ * Get stack information.
+ */
+#define MC_CMD_STACKINFO  0xf
+
+/* MC_CMD_STACKINFO_IN msgrequest */
+#define    MC_CMD_STACKINFO_IN_LEN 0
+
+/* MC_CMD_STACKINFO_OUT msgresponse */
+#define    MC_CMD_STACKINFO_OUT_LENMIN 12
+#define    MC_CMD_STACKINFO_OUT_LENMAX 252
+#define    MC_CMD_STACKINFO_OUT_LEN(num) (0+12*(num))
+#define       MC_CMD_STACKINFO_OUT_THREAD_INFO_OFST 0
+#define       MC_CMD_STACKINFO_OUT_THREAD_INFO_LEN 12
+#define       MC_CMD_STACKINFO_OUT_THREAD_INFO_MINNUM 1
+#define       MC_CMD_STACKINFO_OUT_THREAD_INFO_MAXNUM 21
+
+
+/***********************************/
+/* MC_CMD_MDIO_READ 
+ * MDIO register read.
+ */
+#define MC_CMD_MDIO_READ  0x10
+
+/* MC_CMD_MDIO_READ_IN msgrequest */
+#define    MC_CMD_MDIO_READ_IN_LEN 16
+#define       MC_CMD_MDIO_READ_IN_BUS_OFST 0
+#define          MC_CMD_MDIO_BUS_INTERNAL 0x0 /* enum */
+#define          MC_CMD_MDIO_BUS_EXTERNAL 0x1 /* enum */
+#define       MC_CMD_MDIO_READ_IN_PRTAD_OFST 4
+#define       MC_CMD_MDIO_READ_IN_DEVAD_OFST 8
+#define          MC_CMD_MDIO_CLAUSE22 0x20 /* enum */
+#define       MC_CMD_MDIO_READ_IN_ADDR_OFST 12
+
+/* MC_CMD_MDIO_READ_OUT msgresponse */
+#define    MC_CMD_MDIO_READ_OUT_LEN 8
+#define       MC_CMD_MDIO_READ_OUT_VALUE_OFST 0
+#define       MC_CMD_MDIO_READ_OUT_STATUS_OFST 4
+#define          MC_CMD_MDIO_STATUS_GOOD 0x8 /* enum */
+
+
+/***********************************/
+/* MC_CMD_MDIO_WRITE 
+ * MDIO register write.
+ */
+#define MC_CMD_MDIO_WRITE  0x11
+
+/* MC_CMD_MDIO_WRITE_IN msgrequest */
+#define    MC_CMD_MDIO_WRITE_IN_LEN 20
+#define       MC_CMD_MDIO_WRITE_IN_BUS_OFST 0
+/*               MC_CMD_MDIO_BUS_INTERNAL 0x0 */
+/*               MC_CMD_MDIO_BUS_EXTERNAL 0x1 */
+#define       MC_CMD_MDIO_WRITE_IN_PRTAD_OFST 4
+#define       MC_CMD_MDIO_WRITE_IN_DEVAD_OFST 8
+/*               MC_CMD_MDIO_CLAUSE22 0x20 */
+#define       MC_CMD_MDIO_WRITE_IN_ADDR_OFST 12
+#define       MC_CMD_MDIO_WRITE_IN_VALUE_OFST 16
+
+/* MC_CMD_MDIO_WRITE_OUT msgresponse */
+#define    MC_CMD_MDIO_WRITE_OUT_LEN 4
+#define       MC_CMD_MDIO_WRITE_OUT_STATUS_OFST 0
+/*               MC_CMD_MDIO_STATUS_GOOD 0x8 */
+
+
+/***********************************/
+/* MC_CMD_DBI_WRITE 
+ * Write DBI register(s).
+ */
+#define MC_CMD_DBI_WRITE  0x12
+
+/* MC_CMD_DBI_WRITE_IN msgrequest */
+#define    MC_CMD_DBI_WRITE_IN_LENMIN 12
+#define    MC_CMD_DBI_WRITE_IN_LENMAX 252
+#define    MC_CMD_DBI_WRITE_IN_LEN(num) (0+12*(num))
+#define       MC_CMD_DBI_WRITE_IN_DBIWROP_OFST 0
+#define       MC_CMD_DBI_WRITE_IN_DBIWROP_LEN 12
+#define       MC_CMD_DBI_WRITE_IN_DBIWROP_MINNUM 1
+#define       MC_CMD_DBI_WRITE_IN_DBIWROP_MAXNUM 21
+
+/* MC_CMD_DBI_WRITE_OUT msgresponse */
+#define    MC_CMD_DBI_WRITE_OUT_LEN 0
+
+/* MC_CMD_DBIWROP_TYPEDEF structuredef */
+#define    MC_CMD_DBIWROP_TYPEDEF_LEN 12
+#define       MC_CMD_DBIWROP_TYPEDEF_ADDRESS_OFST 0
+#define       MC_CMD_DBIWROP_TYPEDEF_ADDRESS_LBN 0
+#define       MC_CMD_DBIWROP_TYPEDEF_ADDRESS_WIDTH 32
+#define       MC_CMD_DBIWROP_TYPEDEF_BYTE_MASK_OFST 4
+#define       MC_CMD_DBIWROP_TYPEDEF_BYTE_MASK_LBN 32
+#define       MC_CMD_DBIWROP_TYPEDEF_BYTE_MASK_WIDTH 32
+#define       MC_CMD_DBIWROP_TYPEDEF_VALUE_OFST 8
+#define       MC_CMD_DBIWROP_TYPEDEF_VALUE_LBN 64
+#define       MC_CMD_DBIWROP_TYPEDEF_VALUE_WIDTH 32
+
+
+/***********************************/
+/* MC_CMD_PORT_READ32 
+ * Read a 32-bit register from the indirect port register map.
+ */
+#define MC_CMD_PORT_READ32  0x14
+
+/* MC_CMD_PORT_READ32_IN msgrequest */
+#define    MC_CMD_PORT_READ32_IN_LEN 4
+#define       MC_CMD_PORT_READ32_IN_ADDR_OFST 0
+
+/* MC_CMD_PORT_READ32_OUT msgresponse */
+#define    MC_CMD_PORT_READ32_OUT_LEN 8
+#define       MC_CMD_PORT_READ32_OUT_VALUE_OFST 0
+#define       MC_CMD_PORT_READ32_OUT_STATUS_OFST 4
+
+
+/***********************************/
+/* MC_CMD_PORT_WRITE32 
+ * Write a 32-bit register to the indirect port register map.
+ */
+#define MC_CMD_PORT_WRITE32  0x15
+
+/* MC_CMD_PORT_WRITE32_IN msgrequest */
+#define    MC_CMD_PORT_WRITE32_IN_LEN 8
+#define       MC_CMD_PORT_WRITE32_IN_ADDR_OFST 0
+#define       MC_CMD_PORT_WRITE32_IN_VALUE_OFST 4
+
+/* MC_CMD_PORT_WRITE32_OUT msgresponse */
+#define    MC_CMD_PORT_WRITE32_OUT_LEN 4
+#define       MC_CMD_PORT_WRITE32_OUT_STATUS_OFST 0
+
+
+/***********************************/
+/* MC_CMD_PORT_READ128 
+ * Read a 128-bit register from the indirect port register map.
+ */
+#define MC_CMD_PORT_READ128  0x16
+
+/* MC_CMD_PORT_READ128_IN msgrequest */
+#define    MC_CMD_PORT_READ128_IN_LEN 4
+#define       MC_CMD_PORT_READ128_IN_ADDR_OFST 0
+
+/* MC_CMD_PORT_READ128_OUT msgresponse */
+#define    MC_CMD_PORT_READ128_OUT_LEN 20
+#define       MC_CMD_PORT_READ128_OUT_VALUE_OFST 0
+#define       MC_CMD_PORT_READ128_OUT_VALUE_LEN 16
+#define       MC_CMD_PORT_READ128_OUT_STATUS_OFST 16
+
+
+/***********************************/
+/* MC_CMD_PORT_WRITE128 
+ * Write a 128-bit register to the indirect port register map.
+ */
+#define MC_CMD_PORT_WRITE128  0x17
+
+/* MC_CMD_PORT_WRITE128_IN msgrequest */
+#define    MC_CMD_PORT_WRITE128_IN_LEN 20
+#define       MC_CMD_PORT_WRITE128_IN_ADDR_OFST 0
+#define       MC_CMD_PORT_WRITE128_IN_VALUE_OFST 4
+#define       MC_CMD_PORT_WRITE128_IN_VALUE_LEN 16
+
+/* MC_CMD_PORT_WRITE128_OUT msgresponse */
+#define    MC_CMD_PORT_WRITE128_OUT_LEN 4
+#define       MC_CMD_PORT_WRITE128_OUT_STATUS_OFST 0
+
+
+/***********************************/
+/* MC_CMD_GET_BOARD_CFG 
+ * Returns the MC firmware configuration structure.
+ */
+#define MC_CMD_GET_BOARD_CFG  0x18
+
+/* MC_CMD_GET_BOARD_CFG_IN msgrequest */
+#define    MC_CMD_GET_BOARD_CFG_IN_LEN 0
+
+/* MC_CMD_GET_BOARD_CFG_OUT msgresponse */
+#define    MC_CMD_GET_BOARD_CFG_OUT_LENMIN 96
+#define    MC_CMD_GET_BOARD_CFG_OUT_LENMAX 136
+#define    MC_CMD_GET_BOARD_CFG_OUT_LEN(num) (72+2*(num))
+#define       MC_CMD_GET_BOARD_CFG_OUT_BOARD_TYPE_OFST 0
+#define       MC_CMD_GET_BOARD_CFG_OUT_BOARD_NAME_OFST 4
+#define       MC_CMD_GET_BOARD_CFG_OUT_BOARD_NAME_LEN 32
+#define       MC_CMD_GET_BOARD_CFG_OUT_CAPABILITIES_PORT0_OFST 36
+#define          MC_CMD_CAPABILITIES_SMALL_BUF_TBL_LBN 0x0 /* enum */
+#define          MC_CMD_CAPABILITIES_SMALL_BUF_TBL_WIDTH 0x1 /* enum */
+#define          MC_CMD_CAPABILITIES_TURBO_LBN 0x1 /* enum */
+#define          MC_CMD_CAPABILITIES_TURBO_WIDTH 0x1 /* enum */
+#define          MC_CMD_CAPABILITIES_TURBO_ACTIVE_LBN 0x2 /* enum */
+#define          MC_CMD_CAPABILITIES_TURBO_ACTIVE_WIDTH 0x1 /* enum */
+#define          MC_CMD_CAPABILITIES_PTP_LBN 0x3 /* enum */
+#define          MC_CMD_CAPABILITIES_PTP_WIDTH 0x1 /* enum */
+#define       MC_CMD_GET_BOARD_CFG_OUT_CAPABILITIES_PORT1_OFST 40
+/*            Enum values, see field(s): */
+/*               CAPABILITIES_PORT0 */
+#define       MC_CMD_GET_BOARD_CFG_OUT_MAC_ADDR_BASE_PORT0_OFST 44
+#define       MC_CMD_GET_BOARD_CFG_OUT_MAC_ADDR_BASE_PORT0_LEN 6
+#define       MC_CMD_GET_BOARD_CFG_OUT_MAC_ADDR_BASE_PORT1_OFST 50
+#define       MC_CMD_GET_BOARD_CFG_OUT_MAC_ADDR_BASE_PORT1_LEN 6
+#define       MC_CMD_GET_BOARD_CFG_OUT_MAC_COUNT_PORT0_OFST 56
+#define       MC_CMD_GET_BOARD_CFG_OUT_MAC_COUNT_PORT1_OFST 60
+#define       MC_CMD_GET_BOARD_CFG_OUT_MAC_STRIDE_PORT0_OFST 64
+#define       MC_CMD_GET_BOARD_CFG_OUT_MAC_STRIDE_PORT1_OFST 68
+#define       MC_CMD_GET_BOARD_CFG_OUT_FW_SUBTYPE_LIST_OFST 72
+#define       MC_CMD_GET_BOARD_CFG_OUT_FW_SUBTYPE_LIST_LEN 2
+#define       MC_CMD_GET_BOARD_CFG_OUT_FW_SUBTYPE_LIST_MINNUM 12
+#define       MC_CMD_GET_BOARD_CFG_OUT_FW_SUBTYPE_LIST_MAXNUM 32
+
+
+/***********************************/
+/* MC_CMD_DBI_READX 
+ * Read DBI register(s).
+ */
+#define MC_CMD_DBI_READX  0x19
+
+/* MC_CMD_DBI_READX_IN msgrequest */
+#define    MC_CMD_DBI_READX_IN_LENMIN 8
+#define    MC_CMD_DBI_READX_IN_LENMAX 248
+#define    MC_CMD_DBI_READX_IN_LEN(num) (0+8*(num))
+#define       MC_CMD_DBI_READX_IN_DBIRDOP_OFST 0
+#define       MC_CMD_DBI_READX_IN_DBIRDOP_LEN 8
+#define       MC_CMD_DBI_READX_IN_DBIRDOP_LO_OFST 0
+#define       MC_CMD_DBI_READX_IN_DBIRDOP_HI_OFST 4
+#define       MC_CMD_DBI_READX_IN_DBIRDOP_MINNUM 1
+#define       MC_CMD_DBI_READX_IN_DBIRDOP_MAXNUM 31
+
+/* MC_CMD_DBI_READX_OUT msgresponse */
+#define    MC_CMD_DBI_READX_OUT_LENMIN 4
+#define    MC_CMD_DBI_READX_OUT_LENMAX 252
+#define    MC_CMD_DBI_READX_OUT_LEN(num) (0+4*(num))
+#define       MC_CMD_DBI_READX_OUT_VALUE_OFST 0
+#define       MC_CMD_DBI_READX_OUT_VALUE_LEN 4
+#define       MC_CMD_DBI_READX_OUT_VALUE_MINNUM 1
+#define       MC_CMD_DBI_READX_OUT_VALUE_MAXNUM 63
+
+
+/***********************************/
+/* MC_CMD_SET_RAND_SEED 
+ * Set the 16byte seed for the MC pseudo-random generator.
+ */
+#define MC_CMD_SET_RAND_SEED  0x1a
+
+/* MC_CMD_SET_RAND_SEED_IN msgrequest */
+#define    MC_CMD_SET_RAND_SEED_IN_LEN 16
+#define       MC_CMD_SET_RAND_SEED_IN_SEED_OFST 0
+#define       MC_CMD_SET_RAND_SEED_IN_SEED_LEN 16
+
+/* MC_CMD_SET_RAND_SEED_OUT msgresponse */
+#define    MC_CMD_SET_RAND_SEED_OUT_LEN 0
+
+
+/***********************************/
+/* MC_CMD_LTSSM_HIST 
+ * Retrieve the history of the PCIE LTSSM.
+ */
+#define MC_CMD_LTSSM_HIST  0x1b
+
+/* MC_CMD_LTSSM_HIST_IN msgrequest */
+#define    MC_CMD_LTSSM_HIST_IN_LEN 0
+
+/* MC_CMD_LTSSM_HIST_OUT msgresponse */
+#define    MC_CMD_LTSSM_HIST_OUT_LENMIN 0
+#define    MC_CMD_LTSSM_HIST_OUT_LENMAX 252
+#define    MC_CMD_LTSSM_HIST_OUT_LEN(num) (0+4*(num))
+#define       MC_CMD_LTSSM_HIST_OUT_DATA_OFST 0
+#define       MC_CMD_LTSSM_HIST_OUT_DATA_LEN 4
+#define       MC_CMD_LTSSM_HIST_OUT_DATA_MINNUM 0
+#define       MC_CMD_LTSSM_HIST_OUT_DATA_MAXNUM 63
+
+
+/***********************************/
+/* MC_CMD_DRV_ATTACH 
+ * Inform MCPU that this port is managed on the host.
+ */
+#define MC_CMD_DRV_ATTACH  0x1c
+
+/* MC_CMD_DRV_ATTACH_IN msgrequest */
+#define    MC_CMD_DRV_ATTACH_IN_LEN 8
+#define       MC_CMD_DRV_ATTACH_IN_NEW_STATE_OFST 0
+#define       MC_CMD_DRV_ATTACH_IN_UPDATE_OFST 4
+
+/* MC_CMD_DRV_ATTACH_OUT msgresponse */
+#define    MC_CMD_DRV_ATTACH_OUT_LEN 4
+#define       MC_CMD_DRV_ATTACH_OUT_OLD_STATE_OFST 0
+
+
+/***********************************/
+/* MC_CMD_NCSI_PROD 
+ * Trigger an NC-SI event.
+ */
+#define MC_CMD_NCSI_PROD  0x1d
+
+/* MC_CMD_NCSI_PROD_IN msgrequest */
+#define    MC_CMD_NCSI_PROD_IN_LEN 4
+#define       MC_CMD_NCSI_PROD_IN_EVENTS_OFST 0
+#define          MC_CMD_NCSI_PROD_LINKCHANGE 0x0 /* enum */
+#define          MC_CMD_NCSI_PROD_RESET 0x1 /* enum */
+#define          MC_CMD_NCSI_PROD_DRVATTACH 0x2 /* enum */
+#define        MC_CMD_NCSI_PROD_IN_LINKCHANGE_LBN 0
+#define        MC_CMD_NCSI_PROD_IN_LINKCHANGE_WIDTH 1
+#define        MC_CMD_NCSI_PROD_IN_RESET_LBN 1
+#define        MC_CMD_NCSI_PROD_IN_RESET_WIDTH 1
+#define        MC_CMD_NCSI_PROD_IN_DRVATTACH_LBN 2
+#define        MC_CMD_NCSI_PROD_IN_DRVATTACH_WIDTH 1
+
+/* MC_CMD_NCSI_PROD_OUT msgresponse */
+#define    MC_CMD_NCSI_PROD_OUT_LEN 0
+
+
+/***********************************/
+/* MC_CMD_SHMUART 
+ * Route UART output to circular buffer in shared memory instead.
+ */
+#define MC_CMD_SHMUART  0x1f
+
+/* MC_CMD_SHMUART_IN msgrequest */
+#define    MC_CMD_SHMUART_IN_LEN 4
+#define       MC_CMD_SHMUART_IN_FLAG_OFST 0
+
+/* MC_CMD_SHMUART_OUT msgresponse */
+#define    MC_CMD_SHMUART_OUT_LEN 0
+
+
+/***********************************/
+/* MC_CMD_PORT_RESET 
+ * Generic per-port reset.
+ */
+#define MC_CMD_PORT_RESET  0x20
+
+/* MC_CMD_PORT_RESET_IN msgrequest */
+#define    MC_CMD_PORT_RESET_IN_LEN 0
+
+/* MC_CMD_PORT_RESET_OUT msgresponse */
+#define    MC_CMD_PORT_RESET_OUT_LEN 0
+
+
+/***********************************/
+/* MC_CMD_PCIE_CREDITS 
+ * Read instantaneous and minimum flow control thresholds.
+ */
+#define MC_CMD_PCIE_CREDITS  0x21
+
+/* MC_CMD_PCIE_CREDITS_IN msgrequest */
+#define    MC_CMD_PCIE_CREDITS_IN_LEN 8
+#define       MC_CMD_PCIE_CREDITS_IN_POLL_PERIOD_OFST 0
+#define       MC_CMD_PCIE_CREDITS_IN_WIPE_OFST 4
+
+/* MC_CMD_PCIE_CREDITS_OUT msgresponse */
+#define    MC_CMD_PCIE_CREDITS_OUT_LEN 16
+#define       MC_CMD_PCIE_CREDITS_OUT_CURRENT_P_HDR_OFST 0
+#define       MC_CMD_PCIE_CREDITS_OUT_CURRENT_P_HDR_LEN 2
+#define       MC_CMD_PCIE_CREDITS_OUT_CURRENT_P_DATA_OFST 2
+#define       MC_CMD_PCIE_CREDITS_OUT_CURRENT_P_DATA_LEN 2
+#define       MC_CMD_PCIE_CREDITS_OUT_CURRENT_NP_HDR_OFST 4
+#define       MC_CMD_PCIE_CREDITS_OUT_CURRENT_NP_HDR_LEN 2
+#define       MC_CMD_PCIE_CREDITS_OUT_CURRENT_NP_DATA_OFST 6
+#define       MC_CMD_PCIE_CREDITS_OUT_CURRENT_NP_DATA_LEN 2
+#define       MC_CMD_PCIE_CREDITS_OUT_MINIMUM_P_HDR_OFST 8
+#define       MC_CMD_PCIE_CREDITS_OUT_MINIMUM_P_HDR_LEN 2
+#define       MC_CMD_PCIE_CREDITS_OUT_MINIMUM_P_DATA_OFST 10
+#define       MC_CMD_PCIE_CREDITS_OUT_MINIMUM_P_DATA_LEN 2
+#define       MC_CMD_PCIE_CREDITS_OUT_MINIMUM_NP_HDR_OFST 12
+#define       MC_CMD_PCIE_CREDITS_OUT_MINIMUM_NP_HDR_LEN 2
+#define       MC_CMD_PCIE_CREDITS_OUT_MINIMUM_NP_DATA_OFST 14
+#define       MC_CMD_PCIE_CREDITS_OUT_MINIMUM_NP_DATA_LEN 2
+
+
+/***********************************/
+/* MC_CMD_RXD_MONITOR 
+ * Get histogram of RX queue fill level.
+ */
+#define MC_CMD_RXD_MONITOR  0x22
+
+/* MC_CMD_RXD_MONITOR_IN msgrequest */
+#define    MC_CMD_RXD_MONITOR_IN_LEN 12
+#define       MC_CMD_RXD_MONITOR_IN_QID_OFST 0
+#define       MC_CMD_RXD_MONITOR_IN_POLL_PERIOD_OFST 4
+#define       MC_CMD_RXD_MONITOR_IN_WIPE_OFST 8
+
+/* MC_CMD_RXD_MONITOR_OUT msgresponse */
+#define    MC_CMD_RXD_MONITOR_OUT_LEN 80
+#define       MC_CMD_RXD_MONITOR_OUT_QID_OFST 0
+#define       MC_CMD_RXD_MONITOR_OUT_RING_FILL_OFST 4
+#define       MC_CMD_RXD_MONITOR_OUT_CACHE_FILL_OFST 8
+#define       MC_CMD_RXD_MONITOR_OUT_RING_LT_1_OFST 12
+#define       MC_CMD_RXD_MONITOR_OUT_RING_LT_2_OFST 16
+#define       MC_CMD_RXD_MONITOR_OUT_RING_LT_4_OFST 20
+#define       MC_CMD_RXD_MONITOR_OUT_RING_LT_8_OFST 24
+#define       MC_CMD_RXD_MONITOR_OUT_RING_LT_16_OFST 28
+#define       MC_CMD_RXD_MONITOR_OUT_RING_LT_32_OFST 32
+#define       MC_CMD_RXD_MONITOR_OUT_RING_LT_64_OFST 36
+#define       MC_CMD_RXD_MONITOR_OUT_RING_LT_128_OFST 40
+#define       MC_CMD_RXD_MONITOR_OUT_RING_LT_256_OFST 44
+#define       MC_CMD_RXD_MONITOR_OUT_RING_GE_256_OFST 48
+#define       MC_CMD_RXD_MONITOR_OUT_CACHE_LT_1_OFST 52
+#define       MC_CMD_RXD_MONITOR_OUT_CACHE_LT_2_OFST 56
+#define       MC_CMD_RXD_MONITOR_OUT_CACHE_LT_4_OFST 60
+#define       MC_CMD_RXD_MONITOR_OUT_CACHE_LT_8_OFST 64
+#define       MC_CMD_RXD_MONITOR_OUT_CACHE_LT_16_OFST 68
+#define       MC_CMD_RXD_MONITOR_OUT_CACHE_LT_32_OFST 72
+#define       MC_CMD_RXD_MONITOR_OUT_CACHE_GE_32_OFST 76
+
+
+/***********************************/
+/* MC_CMD_PUTS 
+ * puts(3) implementation over MCDI
+ */
+#define MC_CMD_PUTS  0x23
+
+/* MC_CMD_PUTS_IN msgrequest */
+#define    MC_CMD_PUTS_IN_LENMIN 13
+#define    MC_CMD_PUTS_IN_LENMAX 255
+#define    MC_CMD_PUTS_IN_LEN(num) (12+1*(num))
+#define       MC_CMD_PUTS_IN_DEST_OFST 0
+#define        MC_CMD_PUTS_IN_UART_LBN 0
+#define        MC_CMD_PUTS_IN_UART_WIDTH 1
+#define        MC_CMD_PUTS_IN_PORT_LBN 1
+#define        MC_CMD_PUTS_IN_PORT_WIDTH 1
+#define       MC_CMD_PUTS_IN_DHOST_OFST 4
+#define       MC_CMD_PUTS_IN_DHOST_LEN 6
+#define       MC_CMD_PUTS_IN_STRING_OFST 12
+#define       MC_CMD_PUTS_IN_STRING_LEN 1
+#define       MC_CMD_PUTS_IN_STRING_MINNUM 1
+#define       MC_CMD_PUTS_IN_STRING_MAXNUM 243
+
+/* MC_CMD_PUTS_OUT msgresponse */
+#define    MC_CMD_PUTS_OUT_LEN 0
+
+
+/***********************************/
+/* MC_CMD_GET_PHY_CFG 
+ * Report PHY configuration.
+ */
+#define MC_CMD_GET_PHY_CFG  0x24
+
+/* MC_CMD_GET_PHY_CFG_IN msgrequest */
+#define    MC_CMD_GET_PHY_CFG_IN_LEN 0
+
+/* MC_CMD_GET_PHY_CFG_OUT msgresponse */
+#define    MC_CMD_GET_PHY_CFG_OUT_LEN 72
+#define       MC_CMD_GET_PHY_CFG_OUT_FLAGS_OFST 0
+#define        MC_CMD_GET_PHY_CFG_OUT_PRESENT_LBN 0
+#define        MC_CMD_GET_PHY_CFG_OUT_PRESENT_WIDTH 1
+#define        MC_CMD_GET_PHY_CFG_OUT_BIST_CABLE_SHORT_LBN 1
+#define        MC_CMD_GET_PHY_CFG_OUT_BIST_CABLE_SHORT_WIDTH 1
+#define        MC_CMD_GET_PHY_CFG_OUT_BIST_CABLE_LONG_LBN 2
+#define        MC_CMD_GET_PHY_CFG_OUT_BIST_CABLE_LONG_WIDTH 1
+#define        MC_CMD_GET_PHY_CFG_OUT_LOWPOWER_LBN 3
+#define        MC_CMD_GET_PHY_CFG_OUT_LOWPOWER_WIDTH 1
+#define        MC_CMD_GET_PHY_CFG_OUT_POWEROFF_LBN 4
+#define        MC_CMD_GET_PHY_CFG_OUT_POWEROFF_WIDTH 1
+#define        MC_CMD_GET_PHY_CFG_OUT_TXDIS_LBN 5
+#define        MC_CMD_GET_PHY_CFG_OUT_TXDIS_WIDTH 1
+#define        MC_CMD_GET_PHY_CFG_OUT_BIST_LBN 6
+#define        MC_CMD_GET_PHY_CFG_OUT_BIST_WIDTH 1
+#define       MC_CMD_GET_PHY_CFG_OUT_TYPE_OFST 4
+#define       MC_CMD_GET_PHY_CFG_OUT_SUPPORTED_CAP_OFST 8
+#define        MC_CMD_PHY_CAP_10HDX_LBN 1
+#define        MC_CMD_PHY_CAP_10HDX_WIDTH 1
+#define        MC_CMD_PHY_CAP_10FDX_LBN 2
+#define        MC_CMD_PHY_CAP_10FDX_WIDTH 1
+#define        MC_CMD_PHY_CAP_100HDX_LBN 3
+#define        MC_CMD_PHY_CAP_100HDX_WIDTH 1
+#define        MC_CMD_PHY_CAP_100FDX_LBN 4
+#define        MC_CMD_PHY_CAP_100FDX_WIDTH 1
+#define        MC_CMD_PHY_CAP_1000HDX_LBN 5
+#define        MC_CMD_PHY_CAP_1000HDX_WIDTH 1
+#define        MC_CMD_PHY_CAP_1000FDX_LBN 6
+#define        MC_CMD_PHY_CAP_1000FDX_WIDTH 1
+#define        MC_CMD_PHY_CAP_10000FDX_LBN 7
+#define        MC_CMD_PHY_CAP_10000FDX_WIDTH 1
+#define        MC_CMD_PHY_CAP_PAUSE_LBN 8
+#define        MC_CMD_PHY_CAP_PAUSE_WIDTH 1
+#define        MC_CMD_PHY_CAP_ASYM_LBN 9
+#define        MC_CMD_PHY_CAP_ASYM_WIDTH 1
+#define        MC_CMD_PHY_CAP_AN_LBN 10
+#define        MC_CMD_PHY_CAP_AN_WIDTH 1
+#define       MC_CMD_GET_PHY_CFG_OUT_CHANNEL_OFST 12
+#define       MC_CMD_GET_PHY_CFG_OUT_PRT_OFST 16
+#define       MC_CMD_GET_PHY_CFG_OUT_STATS_MASK_OFST 20
+#define       MC_CMD_GET_PHY_CFG_OUT_NAME_OFST 24
+#define       MC_CMD_GET_PHY_CFG_OUT_NAME_LEN 20
+#define       MC_CMD_GET_PHY_CFG_OUT_MEDIA_TYPE_OFST 44
+#define          MC_CMD_MEDIA_XAUI 0x1 /* enum */
+#define          MC_CMD_MEDIA_CX4 0x2 /* enum */
+#define          MC_CMD_MEDIA_KX4 0x3 /* enum */
+#define          MC_CMD_MEDIA_XFP 0x4 /* enum */
+#define          MC_CMD_MEDIA_SFP_PLUS 0x5 /* enum */
+#define          MC_CMD_MEDIA_BASE_T 0x6 /* enum */
+#define       MC_CMD_GET_PHY_CFG_OUT_MMD_MASK_OFST 48
+#define          MC_CMD_MMD_CLAUSE22 0x0 /* enum */
+#define          MC_CMD_MMD_CLAUSE45_PMAPMD 0x1 /* enum */
+#define          MC_CMD_MMD_CLAUSE45_WIS 0x2 /* enum */
+#define          MC_CMD_MMD_CLAUSE45_PCS 0x3 /* enum */
+#define          MC_CMD_MMD_CLAUSE45_PHYXS 0x4 /* enum */
+#define          MC_CMD_MMD_CLAUSE45_DTEXS 0x5 /* enum */
+#define          MC_CMD_MMD_CLAUSE45_TC 0x6 /* enum */
+#define          MC_CMD_MMD_CLAUSE45_AN 0x7 /* enum */
+#define          MC_CMD_MMD_CLAUSE45_C22EXT 0x1d /* enum */
+#define          MC_CMD_MMD_CLAUSE45_VEND1 0x1e /* enum */
+#define          MC_CMD_MMD_CLAUSE45_VEND2 0x1f /* enum */
+#define       MC_CMD_GET_PHY_CFG_OUT_REVISION_OFST 52
+#define       MC_CMD_GET_PHY_CFG_OUT_REVISION_LEN 20
+
+
+/***********************************/
+/* MC_CMD_START_BIST 
+ * Start a BIST test on the PHY.
+ */
+#define MC_CMD_START_BIST  0x25
+
+/* MC_CMD_START_BIST_IN msgrequest */
+#define    MC_CMD_START_BIST_IN_LEN 4
+#define       MC_CMD_START_BIST_IN_TYPE_OFST 0
+#define          MC_CMD_PHY_BIST_CABLE_SHORT 0x1 /* enum */
+#define          MC_CMD_PHY_BIST_CABLE_LONG 0x2 /* enum */
+#define          MC_CMD_BPX_SERDES_BIST 0x3 /* enum */
+#define          MC_CMD_MC_LOOPBACK_BIST 0x4 /* enum */
+#define          MC_CMD_PHY_BIST 0x5 /* enum */
+
+/* MC_CMD_START_BIST_OUT msgresponse */
+#define    MC_CMD_START_BIST_OUT_LEN 0
+
+
+/***********************************/
+/* MC_CMD_POLL_BIST 
+ * Poll for BIST completion.
+ */
+#define MC_CMD_POLL_BIST  0x26
+
+/* MC_CMD_POLL_BIST_IN msgrequest */
+#define    MC_CMD_POLL_BIST_IN_LEN 0
+
+/* MC_CMD_POLL_BIST_OUT msgresponse */
+#define    MC_CMD_POLL_BIST_OUT_LEN 8
+#define       MC_CMD_POLL_BIST_OUT_RESULT_OFST 0
+#define          MC_CMD_POLL_BIST_RUNNING 0x1 /* enum */
+#define          MC_CMD_POLL_BIST_PASSED 0x2 /* enum */
+#define          MC_CMD_POLL_BIST_FAILED 0x3 /* enum */
+#define          MC_CMD_POLL_BIST_TIMEOUT 0x4 /* enum */
+#define       MC_CMD_POLL_BIST_OUT_PRIVATE_OFST 4
+
+/* MC_CMD_POLL_BIST_OUT_SFT9001 msgresponse */
+#define    MC_CMD_POLL_BIST_OUT_SFT9001_LEN 36
+/*            MC_CMD_POLL_BIST_OUT_RESULT_OFST 0 */
+/*            Enum values, see field(s): */
+/*               MC_CMD_POLL_BIST_OUT/MC_CMD_POLL_BIST_OUT_RESULT */
+#define       MC_CMD_POLL_BIST_OUT_SFT9001_CABLE_LENGTH_A_OFST 4
+#define       MC_CMD_POLL_BIST_OUT_SFT9001_CABLE_LENGTH_B_OFST 8
+#define       MC_CMD_POLL_BIST_OUT_SFT9001_CABLE_LENGTH_C_OFST 12
+#define       MC_CMD_POLL_BIST_OUT_SFT9001_CABLE_LENGTH_D_OFST 16
+#define       MC_CMD_POLL_BIST_OUT_SFT9001_CABLE_STATUS_A_OFST 20
+#define          MC_CMD_POLL_BIST_SFT9001_PAIR_OK 0x1 /* enum */
+#define          MC_CMD_POLL_BIST_SFT9001_PAIR_OPEN 0x2 /* enum */
+#define          MC_CMD_POLL_BIST_SFT9001_INTRA_PAIR_SHORT 0x3 /* enum */
+#define          MC_CMD_POLL_BIST_SFT9001_INTER_PAIR_SHORT 0x4 /* enum */
+#define          MC_CMD_POLL_BIST_SFT9001_PAIR_BUSY 0x9 /* enum */
+#define       MC_CMD_POLL_BIST_OUT_SFT9001_CABLE_STATUS_B_OFST 24
+/*            Enum values, see field(s): */
+/*               CABLE_STATUS_A */
+#define       MC_CMD_POLL_BIST_OUT_SFT9001_CABLE_STATUS_C_OFST 28
+/*            Enum values, see field(s): */
+/*               CABLE_STATUS_A */
+#define       MC_CMD_POLL_BIST_OUT_SFT9001_CABLE_STATUS_D_OFST 32
+/*            Enum values, see field(s): */
+/*               CABLE_STATUS_A */
+
+/* MC_CMD_POLL_BIST_OUT_MRSFP msgresponse */
+#define    MC_CMD_POLL_BIST_OUT_MRSFP_LEN 8
+/*            MC_CMD_POLL_BIST_OUT_RESULT_OFST 0 */
+/*            Enum values, see field(s): */
+/*               MC_CMD_POLL_BIST_OUT/MC_CMD_POLL_BIST_OUT_RESULT */
+#define       MC_CMD_POLL_BIST_OUT_MRSFP_TEST_OFST 4
+#define          MC_CMD_POLL_BIST_MRSFP_TEST_COMPLETE 0x0 /* enum */
+#define          MC_CMD_POLL_BIST_MRSFP_TEST_BUS_SWITCH_OFF_I2C_WRITE 0x1 /* enum */
+#define          MC_CMD_POLL_BIST_MRSFP_TEST_BUS_SWITCH_OFF_I2C_NO_ACCESS_IO_EXP 0x2 /* enum */
+#define          MC_CMD_POLL_BIST_MRSFP_TEST_BUS_SWITCH_OFF_I2C_NO_ACCESS_MODULE 0x3 /* enum */
+#define          MC_CMD_POLL_BIST_MRSFP_TEST_IO_EXP_I2C_CONFIGURE 0x4 /* enum */
+#define          MC_CMD_POLL_BIST_MRSFP_TEST_BUS_SWITCH_I2C_NO_CROSSTALK 0x5 /* enum */
+#define          MC_CMD_POLL_BIST_MRSFP_TEST_MODULE_PRESENCE 0x6 /* enum */
+#define          MC_CMD_POLL_BIST_MRSFP_TEST_MODULE_ID_I2C_ACCESS 0x7 /* enum */
+#define          MC_CMD_POLL_BIST_MRSFP_TEST_MODULE_ID_SANE_VALUE 0x8 /* enum */
+
+
+/***********************************/
+/* MC_CMD_FLUSH_RX_QUEUES 
+ * Flush receive queue(s).
+ */
+#define MC_CMD_FLUSH_RX_QUEUES  0x27
+
+/* MC_CMD_FLUSH_RX_QUEUES_IN msgrequest */
+#define    MC_CMD_FLUSH_RX_QUEUES_IN_LENMIN 4
+#define    MC_CMD_FLUSH_RX_QUEUES_IN_LENMAX 252
+#define    MC_CMD_FLUSH_RX_QUEUES_IN_LEN(num) (0+4*(num))
+#define       MC_CMD_FLUSH_RX_QUEUES_IN_QID_OFST_OFST 0
+#define       MC_CMD_FLUSH_RX_QUEUES_IN_QID_OFST_LEN 4
+#define       MC_CMD_FLUSH_RX_QUEUES_IN_QID_OFST_MINNUM 1
+#define       MC_CMD_FLUSH_RX_QUEUES_IN_QID_OFST_MAXNUM 63
+
+/* MC_CMD_FLUSH_RX_QUEUES_OUT msgresponse */
+#define    MC_CMD_FLUSH_RX_QUEUES_OUT_LEN 0
+
+
+/***********************************/
+/* MC_CMD_GET_LOOPBACK_MODES 
+ * Get port's loopback modes.
+ */
+#define MC_CMD_GET_LOOPBACK_MODES  0x28
+
+/* MC_CMD_GET_LOOPBACK_MODES_IN msgrequest */
+#define    MC_CMD_GET_LOOPBACK_MODES_IN_LEN 0
+
+/* MC_CMD_GET_LOOPBACK_MODES_OUT msgresponse */
+#define    MC_CMD_GET_LOOPBACK_MODES_OUT_LEN 32
+#define       MC_CMD_GET_LOOPBACK_MODES_OUT_100M_OFST 0
+#define       MC_CMD_GET_LOOPBACK_MODES_OUT_100M_LEN 8
+#define       MC_CMD_GET_LOOPBACK_MODES_OUT_100M_LO_OFST 0
+#define       MC_CMD_GET_LOOPBACK_MODES_OUT_100M_HI_OFST 4
+#define          MC_CMD_LOOPBACK_NONE  0x0 /* enum */
+#define          MC_CMD_LOOPBACK_DATA  0x1 /* enum */
+#define          MC_CMD_LOOPBACK_GMAC  0x2 /* enum */
+#define          MC_CMD_LOOPBACK_XGMII 0x3 /* enum */
+#define          MC_CMD_LOOPBACK_XGXS  0x4 /* enum */
+#define          MC_CMD_LOOPBACK_XAUI  0x5 /* enum */
+#define          MC_CMD_LOOPBACK_GMII  0x6 /* enum */
+#define          MC_CMD_LOOPBACK_SGMII  0x7 /* enum */
+#define          MC_CMD_LOOPBACK_XGBR  0x8 /* enum */
+#define          MC_CMD_LOOPBACK_XFI  0x9 /* enum */
+#define          MC_CMD_LOOPBACK_XAUI_FAR  0xa /* enum */
+#define          MC_CMD_LOOPBACK_GMII_FAR  0xb /* enum */
+#define          MC_CMD_LOOPBACK_SGMII_FAR  0xc /* enum */
+#define          MC_CMD_LOOPBACK_XFI_FAR  0xd /* enum */
+#define          MC_CMD_LOOPBACK_GPHY  0xe /* enum */
+#define          MC_CMD_LOOPBACK_PHYXS  0xf /* enum */
+#define          MC_CMD_LOOPBACK_PCS  0x10 /* enum */
+#define          MC_CMD_LOOPBACK_PMAPMD  0x11 /* enum */
+#define          MC_CMD_LOOPBACK_XPORT  0x12 /* enum */
+#define          MC_CMD_LOOPBACK_XGMII_WS  0x13 /* enum */
+#define          MC_CMD_LOOPBACK_XAUI_WS  0x14 /* enum */
+#define          MC_CMD_LOOPBACK_XAUI_WS_FAR  0x15 /* enum */
+#define          MC_CMD_LOOPBACK_XAUI_WS_NEAR  0x16 /* enum */
+#define          MC_CMD_LOOPBACK_GMII_WS  0x17 /* enum */
+#define          MC_CMD_LOOPBACK_XFI_WS  0x18 /* enum */
+#define          MC_CMD_LOOPBACK_XFI_WS_FAR  0x19 /* enum */
+#define          MC_CMD_LOOPBACK_PHYXS_WS  0x1a /* enum */
+#define       MC_CMD_GET_LOOPBACK_MODES_OUT_1G_OFST 8
+#define       MC_CMD_GET_LOOPBACK_MODES_OUT_1G_LEN 8
+#define       MC_CMD_GET_LOOPBACK_MODES_OUT_1G_LO_OFST 8
+#define       MC_CMD_GET_LOOPBACK_MODES_OUT_1G_HI_OFST 12
+/*            Enum values, see field(s): */
+/*               100M */
+#define       MC_CMD_GET_LOOPBACK_MODES_OUT_10G_OFST 16
+#define       MC_CMD_GET_LOOPBACK_MODES_OUT_10G_LEN 8
+#define       MC_CMD_GET_LOOPBACK_MODES_OUT_10G_LO_OFST 16
+#define       MC_CMD_GET_LOOPBACK_MODES_OUT_10G_HI_OFST 20
+/*            Enum values, see field(s): */
+/*               100M */
+#define       MC_CMD_GET_LOOPBACK_MODES_OUT_SUGGESTED_OFST 24
+#define       MC_CMD_GET_LOOPBACK_MODES_OUT_SUGGESTED_LEN 8
+#define       MC_CMD_GET_LOOPBACK_MODES_OUT_SUGGESTED_LO_OFST 24
+#define       MC_CMD_GET_LOOPBACK_MODES_OUT_SUGGESTED_HI_OFST 28
+/*            Enum values, see field(s): */
+/*               100M */
+
+
+/***********************************/
+/* MC_CMD_GET_LINK 
+ * Read the unified MAC/PHY link state.
+ */
+#define MC_CMD_GET_LINK  0x29
+
+/* MC_CMD_GET_LINK_IN msgrequest */
+#define    MC_CMD_GET_LINK_IN_LEN 0
+
+/* MC_CMD_GET_LINK_OUT msgresponse */
+#define    MC_CMD_GET_LINK_OUT_LEN 28
+#define       MC_CMD_GET_LINK_OUT_CAP_OFST 0
+#define       MC_CMD_GET_LINK_OUT_LP_CAP_OFST 4
+#define       MC_CMD_GET_LINK_OUT_LINK_SPEED_OFST 8
+#define       MC_CMD_GET_LINK_OUT_LOOPBACK_MODE_OFST 12
+/*            Enum values, see field(s): */
+/*               MC_CMD_GET_LOOPBACK_MODES/MC_CMD_GET_LOOPBACK_MODES_OUT/100M */
+#define       MC_CMD_GET_LINK_OUT_FLAGS_OFST 16
+#define        MC_CMD_GET_LINK_OUT_LINK_UP_LBN 0
+#define        MC_CMD_GET_LINK_OUT_LINK_UP_WIDTH 1
+#define        MC_CMD_GET_LINK_OUT_FULL_DUPLEX_LBN 1
+#define        MC_CMD_GET_LINK_OUT_FULL_DUPLEX_WIDTH 1
+#define        MC_CMD_GET_LINK_OUT_BPX_LINK_LBN 2
+#define        MC_CMD_GET_LINK_OUT_BPX_LINK_WIDTH 1
+#define        MC_CMD_GET_LINK_OUT_PHY_LINK_LBN 3
+#define        MC_CMD_GET_LINK_OUT_PHY_LINK_WIDTH 1
+#define       MC_CMD_GET_LINK_OUT_FCNTL_OFST 20
+#define          MC_CMD_FCNTL_OFF 0x0 /* enum */
+#define          MC_CMD_FCNTL_RESPOND 0x1 /* enum */
+#define          MC_CMD_FCNTL_BIDIR 0x2 /* enum */
+#define       MC_CMD_GET_LINK_OUT_MAC_FAULT_OFST 24
+#define        MC_CMD_MAC_FAULT_XGMII_LOCAL_LBN 0
+#define        MC_CMD_MAC_FAULT_XGMII_LOCAL_WIDTH 1
+#define        MC_CMD_MAC_FAULT_XGMII_REMOTE_LBN 1
+#define        MC_CMD_MAC_FAULT_XGMII_REMOTE_WIDTH 1
+#define        MC_CMD_MAC_FAULT_SGMII_REMOTE_LBN 2
+#define        MC_CMD_MAC_FAULT_SGMII_REMOTE_WIDTH 1
+#define        MC_CMD_MAC_FAULT_PENDING_RECONFIG_LBN 3
+#define        MC_CMD_MAC_FAULT_PENDING_RECONFIG_WIDTH 1
+
+
+/***********************************/
+/* MC_CMD_SET_LINK 
+ * Write the unified MAC/PHY link configuration.
+ */
+#define MC_CMD_SET_LINK  0x2a
+
+/* MC_CMD_SET_LINK_IN msgrequest */
+#define    MC_CMD_SET_LINK_IN_LEN 16
+#define       MC_CMD_SET_LINK_IN_CAP_OFST 0
+#define       MC_CMD_SET_LINK_IN_FLAGS_OFST 4
+#define        MC_CMD_SET_LINK_IN_LOWPOWER_LBN 0
+#define        MC_CMD_SET_LINK_IN_LOWPOWER_WIDTH 1
+#define        MC_CMD_SET_LINK_IN_POWEROFF_LBN 1
+#define        MC_CMD_SET_LINK_IN_POWEROFF_WIDTH 1
+#define        MC_CMD_SET_LINK_IN_TXDIS_LBN 2
+#define        MC_CMD_SET_LINK_IN_TXDIS_WIDTH 1
+#define       MC_CMD_SET_LINK_IN_LOOPBACK_MODE_OFST 8
+/*            Enum values, see field(s): */
+/*               MC_CMD_GET_LOOPBACK_MODES/MC_CMD_GET_LOOPBACK_MODES_OUT/100M */
+#define       MC_CMD_SET_LINK_IN_LOOPBACK_SPEED_OFST 12
+
+/* MC_CMD_SET_LINK_OUT msgresponse */
+#define    MC_CMD_SET_LINK_OUT_LEN 0
+
+
+/***********************************/
+/* MC_CMD_SET_ID_LED 
+ * Set indentification LED state.
+ */
+#define MC_CMD_SET_ID_LED  0x2b
+
+/* MC_CMD_SET_ID_LED_IN msgrequest */
+#define    MC_CMD_SET_ID_LED_IN_LEN 4
+#define       MC_CMD_SET_ID_LED_IN_STATE_OFST 0
+#define          MC_CMD_LED_OFF  0x0 /* enum */
+#define          MC_CMD_LED_ON  0x1 /* enum */
+#define          MC_CMD_LED_DEFAULT  0x2 /* enum */
+
+/* MC_CMD_SET_ID_LED_OUT msgresponse */
+#define    MC_CMD_SET_ID_LED_OUT_LEN 0
+
+
+/***********************************/
+/* MC_CMD_SET_MAC 
+ * Set MAC configuration.
+ */
+#define MC_CMD_SET_MAC  0x2c
+
+/* MC_CMD_SET_MAC_IN msgrequest */
+#define    MC_CMD_SET_MAC_IN_LEN 24
+#define       MC_CMD_SET_MAC_IN_MTU_OFST 0
+#define       MC_CMD_SET_MAC_IN_DRAIN_OFST 4
+#define       MC_CMD_SET_MAC_IN_ADDR_OFST 8
+#define       MC_CMD_SET_MAC_IN_ADDR_LEN 8
+#define       MC_CMD_SET_MAC_IN_ADDR_LO_OFST 8
+#define       MC_CMD_SET_MAC_IN_ADDR_HI_OFST 12
+#define       MC_CMD_SET_MAC_IN_REJECT_OFST 16
+#define        MC_CMD_SET_MAC_IN_REJECT_UNCST_LBN 0
+#define        MC_CMD_SET_MAC_IN_REJECT_UNCST_WIDTH 1
+#define        MC_CMD_SET_MAC_IN_REJECT_BRDCST_LBN 1
+#define        MC_CMD_SET_MAC_IN_REJECT_BRDCST_WIDTH 1
+#define       MC_CMD_SET_MAC_IN_FCNTL_OFST 20
+/*               MC_CMD_FCNTL_OFF 0x0 */
+/*               MC_CMD_FCNTL_RESPOND 0x1 */
+/*               MC_CMD_FCNTL_BIDIR 0x2 */
+#define          MC_CMD_FCNTL_AUTO 0x3 /* enum */
+
+/* MC_CMD_SET_MAC_OUT msgresponse */
+#define    MC_CMD_SET_MAC_OUT_LEN 0
+
+
+/***********************************/
+/* MC_CMD_PHY_STATS 
+ * Get generic PHY statistics.
+ */
+#define MC_CMD_PHY_STATS  0x2d
+
+/* MC_CMD_PHY_STATS_IN msgrequest */
+#define    MC_CMD_PHY_STATS_IN_LEN 8
+#define       MC_CMD_PHY_STATS_IN_DMA_ADDR_OFST 0
+#define       MC_CMD_PHY_STATS_IN_DMA_ADDR_LEN 8
+#define       MC_CMD_PHY_STATS_IN_DMA_ADDR_LO_OFST 0
+#define       MC_CMD_PHY_STATS_IN_DMA_ADDR_HI_OFST 4
+
+/* MC_CMD_PHY_STATS_OUT_DMA msgresponse */
+#define    MC_CMD_PHY_STATS_OUT_DMA_LEN 0
+
+/* MC_CMD_PHY_STATS_OUT_NO_DMA msgresponse */
+#define    MC_CMD_PHY_STATS_OUT_NO_DMA_LEN (((MC_CMD_PHY_NSTATS*32))>>3)
+#define       MC_CMD_PHY_STATS_OUT_NO_DMA_STATISTICS_OFST 0
+#define       MC_CMD_PHY_STATS_OUT_NO_DMA_STATISTICS_LEN 4
+#define       MC_CMD_PHY_STATS_OUT_NO_DMA_STATISTICS_NUM MC_CMD_PHY_NSTATS
+#define          MC_CMD_OUI  0x0 /* enum */
+#define          MC_CMD_PMA_PMD_LINK_UP  0x1 /* enum */
+#define          MC_CMD_PMA_PMD_RX_FAULT  0x2 /* enum */
+#define          MC_CMD_PMA_PMD_TX_FAULT  0x3 /* enum */
+#define          MC_CMD_PMA_PMD_SIGNAL  0x4 /* enum */
+#define          MC_CMD_PMA_PMD_SNR_A  0x5 /* enum */
+#define          MC_CMD_PMA_PMD_SNR_B  0x6 /* enum */
+#define          MC_CMD_PMA_PMD_SNR_C  0x7 /* enum */
+#define          MC_CMD_PMA_PMD_SNR_D  0x8 /* enum */
+#define          MC_CMD_PCS_LINK_UP  0x9 /* enum */
+#define          MC_CMD_PCS_RX_FAULT  0xa /* enum */
+#define          MC_CMD_PCS_TX_FAULT  0xb /* enum */
+#define          MC_CMD_PCS_BER  0xc /* enum */
+#define          MC_CMD_PCS_BLOCK_ERRORS  0xd /* enum */
+#define          MC_CMD_PHYXS_LINK_UP  0xe /* enum */
+#define          MC_CMD_PHYXS_RX_FAULT  0xf /* enum */
+#define          MC_CMD_PHYXS_TX_FAULT  0x10 /* enum */
+#define          MC_CMD_PHYXS_ALIGN  0x11 /* enum */
+#define          MC_CMD_PHYXS_SYNC  0x12 /* enum */
+#define          MC_CMD_AN_LINK_UP  0x13 /* enum */
+#define          MC_CMD_AN_COMPLETE  0x14 /* enum */
+#define          MC_CMD_AN_10GBT_STATUS  0x15 /* enum */
+#define          MC_CMD_CL22_LINK_UP  0x16 /* enum */
+#define          MC_CMD_PHY_NSTATS  0x17 /* enum */
+
+
+/***********************************/
+/* MC_CMD_MAC_STATS 
+ * Get generic MAC statistics.
+ */
+#define MC_CMD_MAC_STATS  0x2e
+
+/* MC_CMD_MAC_STATS_IN msgrequest */
+#define    MC_CMD_MAC_STATS_IN_LEN 16
+#define       MC_CMD_MAC_STATS_IN_DMA_ADDR_OFST 0
+#define       MC_CMD_MAC_STATS_IN_DMA_ADDR_LEN 8
+#define       MC_CMD_MAC_STATS_IN_DMA_ADDR_LO_OFST 0
+#define       MC_CMD_MAC_STATS_IN_DMA_ADDR_HI_OFST 4
+#define       MC_CMD_MAC_STATS_IN_CMD_OFST 8
+#define        MC_CMD_MAC_STATS_IN_DMA_LBN 0
+#define        MC_CMD_MAC_STATS_IN_DMA_WIDTH 1
+#define        MC_CMD_MAC_STATS_IN_CLEAR_LBN 1
+#define        MC_CMD_MAC_STATS_IN_CLEAR_WIDTH 1
+#define        MC_CMD_MAC_STATS_IN_PERIODIC_CHANGE_LBN 2
+#define        MC_CMD_MAC_STATS_IN_PERIODIC_CHANGE_WIDTH 1
+#define        MC_CMD_MAC_STATS_IN_PERIODIC_ENABLE_LBN 3
+#define        MC_CMD_MAC_STATS_IN_PERIODIC_ENABLE_WIDTH 1
+#define        MC_CMD_MAC_STATS_IN_PERIODIC_CLEAR_LBN 4
+#define        MC_CMD_MAC_STATS_IN_PERIODIC_CLEAR_WIDTH 1
+#define        MC_CMD_MAC_STATS_IN_PERIODIC_NOEVENT_LBN 5
+#define        MC_CMD_MAC_STATS_IN_PERIODIC_NOEVENT_WIDTH 1
+#define        MC_CMD_MAC_STATS_IN_PERIOD_MS_LBN 16
+#define        MC_CMD_MAC_STATS_IN_PERIOD_MS_WIDTH 16
+#define       MC_CMD_MAC_STATS_IN_DMA_LEN_OFST 12
+
+/* MC_CMD_MAC_STATS_OUT_DMA msgresponse */
+#define    MC_CMD_MAC_STATS_OUT_DMA_LEN 0
+
+/* MC_CMD_MAC_STATS_OUT_NO_DMA msgresponse */
+#define    MC_CMD_MAC_STATS_OUT_NO_DMA_LEN (((MC_CMD_MAC_NSTATS*64))>>3)
+#define       MC_CMD_MAC_STATS_OUT_NO_DMA_STATISTICS_OFST 0
+#define       MC_CMD_MAC_STATS_OUT_NO_DMA_STATISTICS_LEN 8
+#define       MC_CMD_MAC_STATS_OUT_NO_DMA_STATISTICS_LO_OFST 0
+#define       MC_CMD_MAC_STATS_OUT_NO_DMA_STATISTICS_HI_OFST 4
+#define       MC_CMD_MAC_STATS_OUT_NO_DMA_STATISTICS_NUM MC_CMD_MAC_NSTATS
+#define          MC_CMD_MAC_GENERATION_START  0x0 /* enum */
+#define          MC_CMD_MAC_TX_PKTS  0x1 /* enum */
+#define          MC_CMD_MAC_TX_PAUSE_PKTS  0x2 /* enum */
+#define          MC_CMD_MAC_TX_CONTROL_PKTS  0x3 /* enum */
+#define          MC_CMD_MAC_TX_UNICAST_PKTS  0x4 /* enum */
+#define          MC_CMD_MAC_TX_MULTICAST_PKTS  0x5 /* enum */
+#define          MC_CMD_MAC_TX_BROADCAST_PKTS  0x6 /* enum */
+#define          MC_CMD_MAC_TX_BYTES  0x7 /* enum */
+#define          MC_CMD_MAC_TX_BAD_BYTES  0x8 /* enum */
+#define          MC_CMD_MAC_TX_LT64_PKTS  0x9 /* enum */
+#define          MC_CMD_MAC_TX_64_PKTS  0xa /* enum */
+#define          MC_CMD_MAC_TX_65_TO_127_PKTS  0xb /* enum */
+#define          MC_CMD_MAC_TX_128_TO_255_PKTS  0xc /* enum */
+#define          MC_CMD_MAC_TX_256_TO_511_PKTS  0xd /* enum */
+#define          MC_CMD_MAC_TX_512_TO_1023_PKTS  0xe /* enum */
+#define          MC_CMD_MAC_TX_1024_TO_15XX_PKTS  0xf /* enum */
+#define          MC_CMD_MAC_TX_15XX_TO_JUMBO_PKTS  0x10 /* enum */
+#define          MC_CMD_MAC_TX_GTJUMBO_PKTS  0x11 /* enum */
+#define          MC_CMD_MAC_TX_BAD_FCS_PKTS  0x12 /* enum */
+#define          MC_CMD_MAC_TX_SINGLE_COLLISION_PKTS  0x13 /* enum */
+#define          MC_CMD_MAC_TX_MULTIPLE_COLLISION_PKTS  0x14 /* enum */
+#define          MC_CMD_MAC_TX_EXCESSIVE_COLLISION_PKTS  0x15 /* enum */
+#define          MC_CMD_MAC_TX_LATE_COLLISION_PKTS  0x16 /* enum */
+#define          MC_CMD_MAC_TX_DEFERRED_PKTS  0x17 /* enum */
+#define          MC_CMD_MAC_TX_EXCESSIVE_DEFERRED_PKTS  0x18 /* enum */
+#define          MC_CMD_MAC_TX_NON_TCPUDP_PKTS  0x19 /* enum */
+#define          MC_CMD_MAC_TX_MAC_SRC_ERR_PKTS  0x1a /* enum */
+#define          MC_CMD_MAC_TX_IP_SRC_ERR_PKTS  0x1b /* enum */
+#define          MC_CMD_MAC_RX_PKTS  0x1c /* enum */
+#define          MC_CMD_MAC_RX_PAUSE_PKTS  0x1d /* enum */
+#define          MC_CMD_MAC_RX_GOOD_PKTS  0x1e /* enum */
+#define          MC_CMD_MAC_RX_CONTROL_PKTS  0x1f /* enum */
+#define          MC_CMD_MAC_RX_UNICAST_PKTS  0x20 /* enum */
+#define          MC_CMD_MAC_RX_MULTICAST_PKTS  0x21 /* enum */
+#define          MC_CMD_MAC_RX_BROADCAST_PKTS  0x22 /* enum */
+#define          MC_CMD_MAC_RX_BYTES  0x23 /* enum */
+#define          MC_CMD_MAC_RX_BAD_BYTES  0x24 /* enum */
+#define          MC_CMD_MAC_RX_64_PKTS  0x25 /* enum */
+#define          MC_CMD_MAC_RX_65_TO_127_PKTS  0x26 /* enum */
+#define          MC_CMD_MAC_RX_128_TO_255_PKTS  0x27 /* enum */
+#define          MC_CMD_MAC_RX_256_TO_511_PKTS  0x28 /* enum */
+#define          MC_CMD_MAC_RX_512_TO_1023_PKTS  0x29 /* enum */
+#define          MC_CMD_MAC_RX_1024_TO_15XX_PKTS  0x2a /* enum */
+#define          MC_CMD_MAC_RX_15XX_TO_JUMBO_PKTS  0x2b /* enum */
+#define          MC_CMD_MAC_RX_GTJUMBO_PKTS  0x2c /* enum */
+#define          MC_CMD_MAC_RX_UNDERSIZE_PKTS  0x2d /* enum */
+#define          MC_CMD_MAC_RX_BAD_FCS_PKTS  0x2e /* enum */
+#define          MC_CMD_MAC_RX_OVERFLOW_PKTS  0x2f /* enum */
+#define          MC_CMD_MAC_RX_FALSE_CARRIER_PKTS  0x30 /* enum */
+#define          MC_CMD_MAC_RX_SYMBOL_ERROR_PKTS  0x31 /* enum */
+#define          MC_CMD_MAC_RX_ALIGN_ERROR_PKTS  0x32 /* enum */
+#define          MC_CMD_MAC_RX_LENGTH_ERROR_PKTS  0x33 /* enum */
+#define          MC_CMD_MAC_RX_INTERNAL_ERROR_PKTS  0x34 /* enum */
+#define          MC_CMD_MAC_RX_JABBER_PKTS  0x35 /* enum */
+#define          MC_CMD_MAC_RX_NODESC_DROPS  0x36 /* enum */
+#define          MC_CMD_MAC_RX_LANES01_CHAR_ERR  0x37 /* enum */
+#define          MC_CMD_MAC_RX_LANES23_CHAR_ERR  0x38 /* enum */
+#define          MC_CMD_MAC_RX_LANES01_DISP_ERR  0x39 /* enum */
+#define          MC_CMD_MAC_RX_LANES23_DISP_ERR  0x3a /* enum */
+#define          MC_CMD_MAC_RX_MATCH_FAULT  0x3b /* enum */
+#define          MC_CMD_GMAC_DMABUF_START  0x40 /* enum */
+#define          MC_CMD_GMAC_DMABUF_END    0x5f /* enum */
+#define          MC_CMD_MAC_GENERATION_END 0x60 /* enum */
+#define          MC_CMD_MAC_NSTATS  0x61 /* enum */
+
+
+/***********************************/
+/* MC_CMD_SRIOV 
+ * to be documented
+ */
+#define MC_CMD_SRIOV  0x30
+
+/* MC_CMD_SRIOV_IN msgrequest */
+#define    MC_CMD_SRIOV_IN_LEN 12
+#define       MC_CMD_SRIOV_IN_ENABLE_OFST 0
+#define       MC_CMD_SRIOV_IN_VI_BASE_OFST 4
+#define       MC_CMD_SRIOV_IN_VF_COUNT_OFST 8
+
+/* MC_CMD_SRIOV_OUT msgresponse */
+#define    MC_CMD_SRIOV_OUT_LEN 8
+#define       MC_CMD_SRIOV_OUT_VI_SCALE_OFST 0
+#define       MC_CMD_SRIOV_OUT_VF_TOTAL_OFST 4
+
+/* MC_CMD_MEMCPY_RECORD_TYPEDEF structuredef */
+#define    MC_CMD_MEMCPY_RECORD_TYPEDEF_LEN 32
+#define       MC_CMD_MEMCPY_RECORD_TYPEDEF_NUM_RECORDS_OFST 0
+#define       MC_CMD_MEMCPY_RECORD_TYPEDEF_NUM_RECORDS_LBN 0
+#define       MC_CMD_MEMCPY_RECORD_TYPEDEF_NUM_RECORDS_WIDTH 32
+#define       MC_CMD_MEMCPY_RECORD_TYPEDEF_TO_RID_OFST 4
+#define       MC_CMD_MEMCPY_RECORD_TYPEDEF_TO_RID_LBN 32
+#define       MC_CMD_MEMCPY_RECORD_TYPEDEF_TO_RID_WIDTH 32
+#define       MC_CMD_MEMCPY_RECORD_TYPEDEF_TO_ADDR_OFST 8
+#define       MC_CMD_MEMCPY_RECORD_TYPEDEF_TO_ADDR_LEN 8
+#define       MC_CMD_MEMCPY_RECORD_TYPEDEF_TO_ADDR_LO_OFST 8
+#define       MC_CMD_MEMCPY_RECORD_TYPEDEF_TO_ADDR_HI_OFST 12
+#define       MC_CMD_MEMCPY_RECORD_TYPEDEF_TO_ADDR_LBN 64
+#define       MC_CMD_MEMCPY_RECORD_TYPEDEF_TO_ADDR_WIDTH 64
+#define       MC_CMD_MEMCPY_RECORD_TYPEDEF_FROM_RID_OFST 16
+#define          MC_CMD_MEMCPY_RECORD_TYPEDEF_RID_INLINE 0x100 /* enum */
+#define       MC_CMD_MEMCPY_RECORD_TYPEDEF_FROM_RID_LBN 128
+#define       MC_CMD_MEMCPY_RECORD_TYPEDEF_FROM_RID_WIDTH 32
+#define       MC_CMD_MEMCPY_RECORD_TYPEDEF_FROM_ADDR_OFST 20
+#define       MC_CMD_MEMCPY_RECORD_TYPEDEF_FROM_ADDR_LEN 8
+#define       MC_CMD_MEMCPY_RECORD_TYPEDEF_FROM_ADDR_LO_OFST 20
+#define       MC_CMD_MEMCPY_RECORD_TYPEDEF_FROM_ADDR_HI_OFST 24
+#define       MC_CMD_MEMCPY_RECORD_TYPEDEF_FROM_ADDR_LBN 160
+#define       MC_CMD_MEMCPY_RECORD_TYPEDEF_FROM_ADDR_WIDTH 64
+#define       MC_CMD_MEMCPY_RECORD_TYPEDEF_LENGTH_OFST 28
+#define       MC_CMD_MEMCPY_RECORD_TYPEDEF_LENGTH_LBN 224
+#define       MC_CMD_MEMCPY_RECORD_TYPEDEF_LENGTH_WIDTH 32
+
+
+/***********************************/
+/* MC_CMD_MEMCPY 
+ * Perform memory copy operation.
+ */
+#define MC_CMD_MEMCPY  0x31
+
+/* MC_CMD_MEMCPY_IN msgrequest */
+#define    MC_CMD_MEMCPY_IN_LENMIN 32
+#define    MC_CMD_MEMCPY_IN_LENMAX 224
+#define    MC_CMD_MEMCPY_IN_LEN(num) (0+32*(num))
+#define       MC_CMD_MEMCPY_IN_RECORD_OFST 0
+#define       MC_CMD_MEMCPY_IN_RECORD_LEN 32
+#define       MC_CMD_MEMCPY_IN_RECORD_MINNUM 1
+#define       MC_CMD_MEMCPY_IN_RECORD_MAXNUM 7
+
+/* MC_CMD_MEMCPY_OUT msgresponse */
+#define    MC_CMD_MEMCPY_OUT_LEN 0
+
+
+/***********************************/
+/* MC_CMD_WOL_FILTER_SET 
+ * Set a WoL filter.
+ */
+#define MC_CMD_WOL_FILTER_SET  0x32
+
+/* MC_CMD_WOL_FILTER_SET_IN msgrequest */
+#define    MC_CMD_WOL_FILTER_SET_IN_LEN 192
+#define       MC_CMD_WOL_FILTER_SET_IN_FILTER_MODE_OFST 0
+#define          MC_CMD_FILTER_MODE_SIMPLE    0x0 /* enum */
+#define          MC_CMD_FILTER_MODE_STRUCTURED 0xffffffff /* enum */
+#define       MC_CMD_WOL_FILTER_SET_IN_WOL_TYPE_OFST 4
+#define          MC_CMD_WOL_TYPE_MAGIC      0x0 /* enum */
+#define          MC_CMD_WOL_TYPE_WIN_MAGIC 0x2 /* enum */
+#define          MC_CMD_WOL_TYPE_IPV4_SYN   0x3 /* enum */
+#define          MC_CMD_WOL_TYPE_IPV6_SYN   0x4 /* enum */
+#define          MC_CMD_WOL_TYPE_BITMAP     0x5 /* enum */
+#define          MC_CMD_WOL_TYPE_LINK       0x6 /* enum */
+#define          MC_CMD_WOL_TYPE_MAX        0x7 /* enum */
+#define       MC_CMD_WOL_FILTER_SET_IN_DATA_OFST 8
+#define       MC_CMD_WOL_FILTER_SET_IN_DATA_LEN 4
+#define       MC_CMD_WOL_FILTER_SET_IN_DATA_NUM 46
+
+/* MC_CMD_WOL_FILTER_SET_IN_MAGIC msgrequest */
+#define    MC_CMD_WOL_FILTER_SET_IN_MAGIC_LEN 16
+/*            MC_CMD_WOL_FILTER_SET_IN_FILTER_MODE_OFST 0 */
+/*            MC_CMD_WOL_FILTER_SET_IN_WOL_TYPE_OFST 4 */
+#define       MC_CMD_WOL_FILTER_SET_IN_MAGIC_MAC_OFST 8
+#define       MC_CMD_WOL_FILTER_SET_IN_MAGIC_MAC_LEN 8
+#define       MC_CMD_WOL_FILTER_SET_IN_MAGIC_MAC_LO_OFST 8
+#define       MC_CMD_WOL_FILTER_SET_IN_MAGIC_MAC_HI_OFST 12
+
+/* MC_CMD_WOL_FILTER_SET_IN_IPV4_SYN msgrequest */
+#define    MC_CMD_WOL_FILTER_SET_IN_IPV4_SYN_LEN 20
+/*            MC_CMD_WOL_FILTER_SET_IN_FILTER_MODE_OFST 0 */
+/*            MC_CMD_WOL_FILTER_SET_IN_WOL_TYPE_OFST 4 */
+#define       MC_CMD_WOL_FILTER_SET_IN_IPV4_SYN_SRC_IP_OFST 8
+#define       MC_CMD_WOL_FILTER_SET_IN_IPV4_SYN_DST_IP_OFST 12
+#define       MC_CMD_WOL_FILTER_SET_IN_IPV4_SYN_SRC_PORT_OFST 16
+#define       MC_CMD_WOL_FILTER_SET_IN_IPV4_SYN_SRC_PORT_LEN 2
+#define       MC_CMD_WOL_FILTER_SET_IN_IPV4_SYN_DST_PORT_OFST 18
+#define       MC_CMD_WOL_FILTER_SET_IN_IPV4_SYN_DST_PORT_LEN 2
+
+/* MC_CMD_WOL_FILTER_SET_IN_IPV6_SYN msgrequest */
+#define    MC_CMD_WOL_FILTER_SET_IN_IPV6_SYN_LEN 44
+/*            MC_CMD_WOL_FILTER_SET_IN_FILTER_MODE_OFST 0 */
+/*            MC_CMD_WOL_FILTER_SET_IN_WOL_TYPE_OFST 4 */
+#define       MC_CMD_WOL_FILTER_SET_IN_IPV6_SYN_SRC_IP_OFST 8
+#define       MC_CMD_WOL_FILTER_SET_IN_IPV6_SYN_SRC_IP_LEN 16
+#define       MC_CMD_WOL_FILTER_SET_IN_IPV6_SYN_DST_IP_OFST 24
+#define       MC_CMD_WOL_FILTER_SET_IN_IPV6_SYN_DST_IP_LEN 16
+#define       MC_CMD_WOL_FILTER_SET_IN_IPV6_SYN_SRC_PORT_OFST 40
+#define       MC_CMD_WOL_FILTER_SET_IN_IPV6_SYN_SRC_PORT_LEN 2
+#define       MC_CMD_WOL_FILTER_SET_IN_IPV6_SYN_DST_PORT_OFST 42
+#define       MC_CMD_WOL_FILTER_SET_IN_IPV6_SYN_DST_PORT_LEN 2
+
+/* MC_CMD_WOL_FILTER_SET_IN_BITMAP msgrequest */
+#define    MC_CMD_WOL_FILTER_SET_IN_BITMAP_LEN 187
+/*            MC_CMD_WOL_FILTER_SET_IN_FILTER_MODE_OFST 0 */
+/*            MC_CMD_WOL_FILTER_SET_IN_WOL_TYPE_OFST 4 */
+#define       MC_CMD_WOL_FILTER_SET_IN_BITMAP_MASK_OFST 8
+#define       MC_CMD_WOL_FILTER_SET_IN_BITMAP_MASK_LEN 48
+#define       MC_CMD_WOL_FILTER_SET_IN_BITMAP_BITMAP_OFST 56
+#define       MC_CMD_WOL_FILTER_SET_IN_BITMAP_BITMAP_LEN 128
+#define       MC_CMD_WOL_FILTER_SET_IN_BITMAP_LEN_OFST 184
+#define       MC_CMD_WOL_FILTER_SET_IN_BITMAP_LEN_LEN 1
+#define       MC_CMD_WOL_FILTER_SET_IN_BITMAP_LAYER3_OFST 185
+#define       MC_CMD_WOL_FILTER_SET_IN_BITMAP_LAYER3_LEN 1
+#define       MC_CMD_WOL_FILTER_SET_IN_BITMAP_LAYER4_OFST 186
+#define       MC_CMD_WOL_FILTER_SET_IN_BITMAP_LAYER4_LEN 1
+
+/* MC_CMD_WOL_FILTER_SET_IN_LINK msgrequest */
+#define    MC_CMD_WOL_FILTER_SET_IN_LINK_LEN 12
+/*            MC_CMD_WOL_FILTER_SET_IN_FILTER_MODE_OFST 0 */
+/*            MC_CMD_WOL_FILTER_SET_IN_WOL_TYPE_OFST 4 */
+#define       MC_CMD_WOL_FILTER_SET_IN_LINK_MASK_OFST 8
+#define        MC_CMD_WOL_FILTER_SET_IN_LINK_UP_LBN 0
+#define        MC_CMD_WOL_FILTER_SET_IN_LINK_UP_WIDTH 1
+#define        MC_CMD_WOL_FILTER_SET_IN_LINK_DOWN_LBN 1
+#define        MC_CMD_WOL_FILTER_SET_IN_LINK_DOWN_WIDTH 1
+
+/* MC_CMD_WOL_FILTER_SET_OUT msgresponse */
+#define    MC_CMD_WOL_FILTER_SET_OUT_LEN 4
+#define       MC_CMD_WOL_FILTER_SET_OUT_FILTER_ID_OFST 0
+
+
+/***********************************/
+/* MC_CMD_WOL_FILTER_REMOVE 
+ * Remove a WoL filter.
+ */
+#define MC_CMD_WOL_FILTER_REMOVE  0x33
+
+/* MC_CMD_WOL_FILTER_REMOVE_IN msgrequest */
+#define    MC_CMD_WOL_FILTER_REMOVE_IN_LEN 4
+#define       MC_CMD_WOL_FILTER_REMOVE_IN_FILTER_ID_OFST 0
+
+/* MC_CMD_WOL_FILTER_REMOVE_OUT msgresponse */
+#define    MC_CMD_WOL_FILTER_REMOVE_OUT_LEN 0
+
+
+/***********************************/
+/* MC_CMD_WOL_FILTER_RESET 
+ * Reset (i.e. remove all) WoL filters.
+ */
+#define MC_CMD_WOL_FILTER_RESET  0x34
+
+/* MC_CMD_WOL_FILTER_RESET_IN msgrequest */
+#define    MC_CMD_WOL_FILTER_RESET_IN_LEN 4
+#define       MC_CMD_WOL_FILTER_RESET_IN_MASK_OFST 0
+#define          MC_CMD_WOL_FILTER_RESET_IN_WAKE_FILTERS 0x1 /* enum */
+#define          MC_CMD_WOL_FILTER_RESET_IN_LIGHTSOUT_OFFLOADS 0x2 /* enum */
+
+/* MC_CMD_WOL_FILTER_RESET_OUT msgresponse */
+#define    MC_CMD_WOL_FILTER_RESET_OUT_LEN 0
+
+
+/***********************************/
+/* MC_CMD_SET_MCAST_HASH 
+ * Set the MCASH hash value.
+ */
+#define MC_CMD_SET_MCAST_HASH  0x35
+
+/* MC_CMD_SET_MCAST_HASH_IN msgrequest */
+#define    MC_CMD_SET_MCAST_HASH_IN_LEN 32
+#define       MC_CMD_SET_MCAST_HASH_IN_HASH0_OFST 0
+#define       MC_CMD_SET_MCAST_HASH_IN_HASH0_LEN 16
+#define       MC_CMD_SET_MCAST_HASH_IN_HASH1_OFST 16
+#define       MC_CMD_SET_MCAST_HASH_IN_HASH1_LEN 16
+
+/* MC_CMD_SET_MCAST_HASH_OUT msgresponse */
+#define    MC_CMD_SET_MCAST_HASH_OUT_LEN 0
+
+
+/***********************************/
+/* MC_CMD_NVRAM_TYPES 
+ * Get virtual NVRAM partitions information.
+ */
+#define MC_CMD_NVRAM_TYPES  0x36
+
+/* MC_CMD_NVRAM_TYPES_IN msgrequest */
+#define    MC_CMD_NVRAM_TYPES_IN_LEN 0
+
+/* MC_CMD_NVRAM_TYPES_OUT msgresponse */
+#define    MC_CMD_NVRAM_TYPES_OUT_LEN 4
+#define       MC_CMD_NVRAM_TYPES_OUT_TYPES_OFST 0
+#define          MC_CMD_NVRAM_TYPE_DISABLED_CALLISTO 0x0 /* enum */
+#define          MC_CMD_NVRAM_TYPE_MC_FW 0x1 /* enum */
+#define          MC_CMD_NVRAM_TYPE_MC_FW_BACKUP 0x2 /* enum */
+#define          MC_CMD_NVRAM_TYPE_STATIC_CFG_PORT0 0x3 /* enum */
+#define          MC_CMD_NVRAM_TYPE_STATIC_CFG_PORT1 0x4 /* enum */
+#define          MC_CMD_NVRAM_TYPE_DYNAMIC_CFG_PORT0 0x5 /* enum */
+#define          MC_CMD_NVRAM_TYPE_DYNAMIC_CFG_PORT1 0x6 /* enum */
+#define          MC_CMD_NVRAM_TYPE_EXP_ROM 0x7 /* enum */
+#define          MC_CMD_NVRAM_TYPE_EXP_ROM_CFG_PORT0 0x8 /* enum */
+#define          MC_CMD_NVRAM_TYPE_EXP_ROM_CFG_PORT1 0x9 /* enum */
+#define          MC_CMD_NVRAM_TYPE_PHY_PORT0 0xa /* enum */
+#define          MC_CMD_NVRAM_TYPE_PHY_PORT1 0xb /* enum */
+#define          MC_CMD_NVRAM_TYPE_LOG 0xc /* enum */
+#define          MC_CMD_NVRAM_TYPE_FPGA 0xd /* enum */
+
+
+/***********************************/
+/* MC_CMD_NVRAM_INFO 
+ * Read info about a virtual NVRAM partition.
+ */
+#define MC_CMD_NVRAM_INFO  0x37
+
+/* MC_CMD_NVRAM_INFO_IN msgrequest */
+#define    MC_CMD_NVRAM_INFO_IN_LEN 4
+#define       MC_CMD_NVRAM_INFO_IN_TYPE_OFST 0
+/*            Enum values, see field(s): */
+/*               MC_CMD_NVRAM_TYPES/MC_CMD_NVRAM_TYPES_OUT/TYPES */
+
+/* MC_CMD_NVRAM_INFO_OUT msgresponse */
+#define    MC_CMD_NVRAM_INFO_OUT_LEN 24
+#define       MC_CMD_NVRAM_INFO_OUT_TYPE_OFST 0
+/*            Enum values, see field(s): */
+/*               MC_CMD_NVRAM_TYPES/MC_CMD_NVRAM_TYPES_OUT/TYPES */
+#define       MC_CMD_NVRAM_INFO_OUT_SIZE_OFST 4
+#define       MC_CMD_NVRAM_INFO_OUT_ERASESIZE_OFST 8
+#define       MC_CMD_NVRAM_INFO_OUT_FLAGS_OFST 12
+#define        MC_CMD_NVRAM_INFO_OUT_PROTECTED_LBN 0
+#define        MC_CMD_NVRAM_INFO_OUT_PROTECTED_WIDTH 1
+#define       MC_CMD_NVRAM_INFO_OUT_PHYSDEV_OFST 16
+#define       MC_CMD_NVRAM_INFO_OUT_PHYSADDR_OFST 20
+
+
+/***********************************/
+/* MC_CMD_NVRAM_UPDATE_START 
+ * Start a group of update operations on a virtual NVRAM partition.
+ */
+#define MC_CMD_NVRAM_UPDATE_START  0x38
+
+/* MC_CMD_NVRAM_UPDATE_START_IN msgrequest */
+#define    MC_CMD_NVRAM_UPDATE_START_IN_LEN 4
+#define       MC_CMD_NVRAM_UPDATE_START_IN_TYPE_OFST 0
+/*            Enum values, see field(s): */
+/*               MC_CMD_NVRAM_TYPES/MC_CMD_NVRAM_TYPES_OUT/TYPES */
+
+/* MC_CMD_NVRAM_UPDATE_START_OUT msgresponse */
+#define    MC_CMD_NVRAM_UPDATE_START_OUT_LEN 0
+
+
+/***********************************/
+/* MC_CMD_NVRAM_READ 
+ * Read data from a virtual NVRAM partition.
+ */
+#define MC_CMD_NVRAM_READ  0x39
+
+/* MC_CMD_NVRAM_READ_IN msgrequest */
+#define    MC_CMD_NVRAM_READ_IN_LEN 12
+#define       MC_CMD_NVRAM_READ_IN_TYPE_OFST 0
+/*            Enum values, see field(s): */
+/*               MC_CMD_NVRAM_TYPES/MC_CMD_NVRAM_TYPES_OUT/TYPES */
+#define       MC_CMD_NVRAM_READ_IN_OFFSET_OFST 4
+#define       MC_CMD_NVRAM_READ_IN_LENGTH_OFST 8
+
+/* MC_CMD_NVRAM_READ_OUT msgresponse */
+#define    MC_CMD_NVRAM_READ_OUT_LENMIN 1
+#define    MC_CMD_NVRAM_READ_OUT_LENMAX 255
+#define    MC_CMD_NVRAM_READ_OUT_LEN(num) (0+1*(num))
+#define       MC_CMD_NVRAM_READ_OUT_READ_BUFFER_OFST 0
+#define       MC_CMD_NVRAM_READ_OUT_READ_BUFFER_LEN 1
+#define       MC_CMD_NVRAM_READ_OUT_READ_BUFFER_MINNUM 1
+#define       MC_CMD_NVRAM_READ_OUT_READ_BUFFER_MAXNUM 255
+
+
+/***********************************/
+/* MC_CMD_NVRAM_WRITE 
+ * Write data to a virtual NVRAM partition.
+ */
+#define MC_CMD_NVRAM_WRITE  0x3a
+
+/* MC_CMD_NVRAM_WRITE_IN msgrequest */
+#define    MC_CMD_NVRAM_WRITE_IN_LENMIN 13
+#define    MC_CMD_NVRAM_WRITE_IN_LENMAX 255
+#define    MC_CMD_NVRAM_WRITE_IN_LEN(num) (12+1*(num))
+#define       MC_CMD_NVRAM_WRITE_IN_TYPE_OFST 0
+/*            Enum values, see field(s): */
+/*               MC_CMD_NVRAM_TYPES/MC_CMD_NVRAM_TYPES_OUT/TYPES */
+#define       MC_CMD_NVRAM_WRITE_IN_OFFSET_OFST 4
+#define       MC_CMD_NVRAM_WRITE_IN_LENGTH_OFST 8
+#define       MC_CMD_NVRAM_WRITE_IN_WRITE_BUFFER_OFST 12
+#define       MC_CMD_NVRAM_WRITE_IN_WRITE_BUFFER_LEN 1
+#define       MC_CMD_NVRAM_WRITE_IN_WRITE_BUFFER_MINNUM 1
+#define       MC_CMD_NVRAM_WRITE_IN_WRITE_BUFFER_MAXNUM 243
+
+/* MC_CMD_NVRAM_WRITE_OUT msgresponse */
+#define    MC_CMD_NVRAM_WRITE_OUT_LEN 0
+
+
+/***********************************/
+/* MC_CMD_NVRAM_ERASE 
+ * Erase sector(s) from a virtual NVRAM partition.
+ */
+#define MC_CMD_NVRAM_ERASE  0x3b
+
+/* MC_CMD_NVRAM_ERASE_IN msgrequest */
+#define    MC_CMD_NVRAM_ERASE_IN_LEN 12
+#define       MC_CMD_NVRAM_ERASE_IN_TYPE_OFST 0
+/*            Enum values, see field(s): */
+/*               MC_CMD_NVRAM_TYPES/MC_CMD_NVRAM_TYPES_OUT/TYPES */
+#define       MC_CMD_NVRAM_ERASE_IN_OFFSET_OFST 4
+#define       MC_CMD_NVRAM_ERASE_IN_LENGTH_OFST 8
+
+/* MC_CMD_NVRAM_ERASE_OUT msgresponse */
+#define    MC_CMD_NVRAM_ERASE_OUT_LEN 0
+
+
+/***********************************/
+/* MC_CMD_NVRAM_UPDATE_FINISH 
+ * Finish a group of update operations on a virtual NVRAM partition.
+ */
+#define MC_CMD_NVRAM_UPDATE_FINISH  0x3c
+
+/* MC_CMD_NVRAM_UPDATE_FINISH_IN msgrequest */
+#define    MC_CMD_NVRAM_UPDATE_FINISH_IN_LEN 8
+#define       MC_CMD_NVRAM_UPDATE_FINISH_IN_TYPE_OFST 0
+/*            Enum values, see field(s): */
+/*               MC_CMD_NVRAM_TYPES/MC_CMD_NVRAM_TYPES_OUT/TYPES */
+#define       MC_CMD_NVRAM_UPDATE_FINISH_IN_REBOOT_OFST 4
+
+/* MC_CMD_NVRAM_UPDATE_FINISH_OUT msgresponse */
+#define    MC_CMD_NVRAM_UPDATE_FINISH_OUT_LEN 0
+
+
+/***********************************/
+/* MC_CMD_REBOOT 
+ * Reboot the MC.
+ */
+#define MC_CMD_REBOOT  0x3d
+
+/* MC_CMD_REBOOT_IN msgrequest */
+#define    MC_CMD_REBOOT_IN_LEN 4
+#define       MC_CMD_REBOOT_IN_FLAGS_OFST 0
+#define          MC_CMD_REBOOT_FLAGS_AFTER_ASSERTION 0x1 /* enum */
+
+/* MC_CMD_REBOOT_OUT msgresponse */
+#define    MC_CMD_REBOOT_OUT_LEN 0
+
+
+/***********************************/
+/* MC_CMD_SCHEDINFO 
+ * Request scheduler info.
+ */
+#define MC_CMD_SCHEDINFO  0x3e
+
+/* MC_CMD_SCHEDINFO_IN msgrequest */
+#define    MC_CMD_SCHEDINFO_IN_LEN 0
+
+/* MC_CMD_SCHEDINFO_OUT msgresponse */
+#define    MC_CMD_SCHEDINFO_OUT_LENMIN 4
+#define    MC_CMD_SCHEDINFO_OUT_LENMAX 252
+#define    MC_CMD_SCHEDINFO_OUT_LEN(num) (0+4*(num))
+#define       MC_CMD_SCHEDINFO_OUT_DATA_OFST 0
+#define       MC_CMD_SCHEDINFO_OUT_DATA_LEN 4
+#define       MC_CMD_SCHEDINFO_OUT_DATA_MINNUM 1
+#define       MC_CMD_SCHEDINFO_OUT_DATA_MAXNUM 63
+
+
+/***********************************/
+/* MC_CMD_REBOOT_MODE 
+ */
+#define MC_CMD_REBOOT_MODE  0x3f
+
+/* MC_CMD_REBOOT_MODE_IN msgrequest */
+#define    MC_CMD_REBOOT_MODE_IN_LEN 4
+#define       MC_CMD_REBOOT_MODE_IN_VALUE_OFST 0
+#define          MC_CMD_REBOOT_MODE_NORMAL 0x0 /* enum */
+#define          MC_CMD_REBOOT_MODE_SNAPPER 0x3 /* enum */
+
+/* MC_CMD_REBOOT_MODE_OUT msgresponse */
+#define    MC_CMD_REBOOT_MODE_OUT_LEN 4
+#define       MC_CMD_REBOOT_MODE_OUT_VALUE_OFST 0
+
+
+/***********************************/
+/* MC_CMD_SENSOR_INFO 
+ * Returns information about every available sensor.
+ */
+#define MC_CMD_SENSOR_INFO  0x41
+
+/* MC_CMD_SENSOR_INFO_IN msgrequest */
+#define    MC_CMD_SENSOR_INFO_IN_LEN 0
+
+/* MC_CMD_SENSOR_INFO_OUT msgresponse */
+#define    MC_CMD_SENSOR_INFO_OUT_LENMIN 12
+#define    MC_CMD_SENSOR_INFO_OUT_LENMAX 252
+#define    MC_CMD_SENSOR_INFO_OUT_LEN(num) (4+8*(num))
+#define       MC_CMD_SENSOR_INFO_OUT_MASK_OFST 0
+#define          MC_CMD_SENSOR_CONTROLLER_TEMP  0x0 /* enum */
+#define          MC_CMD_SENSOR_PHY_COMMON_TEMP  0x1 /* enum */
+#define          MC_CMD_SENSOR_CONTROLLER_COOLING  0x2 /* enum */
+#define          MC_CMD_SENSOR_PHY0_TEMP  0x3 /* enum */
+#define          MC_CMD_SENSOR_PHY0_COOLING  0x4 /* enum */
+#define          MC_CMD_SENSOR_PHY1_TEMP  0x5 /* enum */
+#define          MC_CMD_SENSOR_PHY1_COOLING  0x6 /* enum */
+#define          MC_CMD_SENSOR_IN_1V0  0x7 /* enum */
+#define          MC_CMD_SENSOR_IN_1V2  0x8 /* enum */
+#define          MC_CMD_SENSOR_IN_1V8  0x9 /* enum */
+#define          MC_CMD_SENSOR_IN_2V5  0xa /* enum */
+#define          MC_CMD_SENSOR_IN_3V3  0xb /* enum */
+#define          MC_CMD_SENSOR_IN_12V0  0xc /* enum */
+#define          MC_CMD_SENSOR_IN_1V2A  0xd /* enum */
+#define          MC_CMD_SENSOR_IN_VREF  0xe /* enum */
+#define       MC_CMD_SENSOR_ENTRY_OFST 4
+#define       MC_CMD_SENSOR_ENTRY_LEN 8
+#define       MC_CMD_SENSOR_ENTRY_LO_OFST 4
+#define       MC_CMD_SENSOR_ENTRY_HI_OFST 8
+#define       MC_CMD_SENSOR_ENTRY_MINNUM 1
+#define       MC_CMD_SENSOR_ENTRY_MAXNUM 31
+
+/* MC_CMD_SENSOR_INFO_ENTRY_TYPEDEF structuredef */
+#define    MC_CMD_SENSOR_INFO_ENTRY_TYPEDEF_LEN 8
+#define       MC_CMD_SENSOR_INFO_ENTRY_TYPEDEF_MIN1_OFST 0
+#define       MC_CMD_SENSOR_INFO_ENTRY_TYPEDEF_MIN1_LEN 2
+#define       MC_CMD_SENSOR_INFO_ENTRY_TYPEDEF_MIN1_LBN 0
+#define       MC_CMD_SENSOR_INFO_ENTRY_TYPEDEF_MIN1_WIDTH 16
+#define       MC_CMD_SENSOR_INFO_ENTRY_TYPEDEF_MAX1_OFST 2
+#define       MC_CMD_SENSOR_INFO_ENTRY_TYPEDEF_MAX1_LEN 2
+#define       MC_CMD_SENSOR_INFO_ENTRY_TYPEDEF_MAX1_LBN 16
+#define       MC_CMD_SENSOR_INFO_ENTRY_TYPEDEF_MAX1_WIDTH 16
+#define       MC_CMD_SENSOR_INFO_ENTRY_TYPEDEF_MIN2_OFST 4
+#define       MC_CMD_SENSOR_INFO_ENTRY_TYPEDEF_MIN2_LEN 2
+#define       MC_CMD_SENSOR_INFO_ENTRY_TYPEDEF_MIN2_LBN 32
+#define       MC_CMD_SENSOR_INFO_ENTRY_TYPEDEF_MIN2_WIDTH 16
+#define       MC_CMD_SENSOR_INFO_ENTRY_TYPEDEF_MAX2_OFST 6
+#define       MC_CMD_SENSOR_INFO_ENTRY_TYPEDEF_MAX2_LEN 2
+#define       MC_CMD_SENSOR_INFO_ENTRY_TYPEDEF_MAX2_LBN 48
+#define       MC_CMD_SENSOR_INFO_ENTRY_TYPEDEF_MAX2_WIDTH 16
+
+
+/***********************************/
+/* MC_CMD_READ_SENSORS 
+ * Returns the current reading from each sensor.
+ */
+#define MC_CMD_READ_SENSORS  0x42
+
+/* MC_CMD_READ_SENSORS_IN msgrequest */
+#define    MC_CMD_READ_SENSORS_IN_LEN 8
+#define       MC_CMD_READ_SENSORS_IN_DMA_ADDR_OFST 0
+#define       MC_CMD_READ_SENSORS_IN_DMA_ADDR_LEN 8
+#define       MC_CMD_READ_SENSORS_IN_DMA_ADDR_LO_OFST 0
+#define       MC_CMD_READ_SENSORS_IN_DMA_ADDR_HI_OFST 4
+
+/* MC_CMD_READ_SENSORS_OUT msgresponse */
+#define    MC_CMD_READ_SENSORS_OUT_LEN 0
+
+/* MC_CMD_SENSOR_VALUE_ENTRY_TYPEDEF structuredef */
+#define    MC_CMD_SENSOR_VALUE_ENTRY_TYPEDEF_LEN 3
+#define       MC_CMD_SENSOR_VALUE_ENTRY_TYPEDEF_VALUE_OFST 0
+#define       MC_CMD_SENSOR_VALUE_ENTRY_TYPEDEF_VALUE_LEN 2
+#define       MC_CMD_SENSOR_VALUE_ENTRY_TYPEDEF_VALUE_LBN 0
+#define       MC_CMD_SENSOR_VALUE_ENTRY_TYPEDEF_VALUE_WIDTH 16
+#define       MC_CMD_SENSOR_VALUE_ENTRY_TYPEDEF_STATE_OFST 2
+#define       MC_CMD_SENSOR_VALUE_ENTRY_TYPEDEF_STATE_LEN 1
+#define          MC_CMD_SENSOR_STATE_OK  0x0 /* enum */
+#define          MC_CMD_SENSOR_STATE_WARNING  0x1 /* enum */
+#define          MC_CMD_SENSOR_STATE_FATAL  0x2 /* enum */
+#define          MC_CMD_SENSOR_STATE_BROKEN  0x3 /* enum */
+#define       MC_CMD_SENSOR_VALUE_ENTRY_TYPEDEF_STATE_LBN 16
+#define       MC_CMD_SENSOR_VALUE_ENTRY_TYPEDEF_STATE_WIDTH 8
+
+
+/***********************************/
+/* MC_CMD_GET_PHY_STATE 
+ * Report current state of PHY.
+ */
+#define MC_CMD_GET_PHY_STATE  0x43
+
+/* MC_CMD_GET_PHY_STATE_IN msgrequest */
+#define    MC_CMD_GET_PHY_STATE_IN_LEN 0
+
+/* MC_CMD_GET_PHY_STATE_OUT msgresponse */
+#define    MC_CMD_GET_PHY_STATE_OUT_LEN 4
+#define       MC_CMD_GET_PHY_STATE_OUT_STATE_OFST 0
+#define          MC_CMD_PHY_STATE_OK 0x1 /* enum */
+#define          MC_CMD_PHY_STATE_ZOMBIE 0x2 /* enum */
+
+
+/***********************************/
+/* MC_CMD_SETUP_8021QBB 
+ * 802.1Qbb control.
+ */
+#define MC_CMD_SETUP_8021QBB  0x44
+
+/* MC_CMD_SETUP_8021QBB_IN msgrequest */
+#define    MC_CMD_SETUP_8021QBB_IN_LEN 32
+#define       MC_CMD_SETUP_8021QBB_IN_TXQS_OFST 0
+#define       MC_CMD_SETUP_8021QBB_IN_TXQS_LEN 32
+
+/* MC_CMD_SETUP_8021QBB_OUT msgresponse */
+#define    MC_CMD_SETUP_8021QBB_OUT_LEN 0
+
+
+/***********************************/
+/* MC_CMD_WOL_FILTER_GET 
+ * Retrieve ID of any WoL filters.
+ */
+#define MC_CMD_WOL_FILTER_GET  0x45
+
+/* MC_CMD_WOL_FILTER_GET_IN msgrequest */
+#define    MC_CMD_WOL_FILTER_GET_IN_LEN 0
+
+/* MC_CMD_WOL_FILTER_GET_OUT msgresponse */
+#define    MC_CMD_WOL_FILTER_GET_OUT_LEN 4
+#define       MC_CMD_WOL_FILTER_GET_OUT_FILTER_ID_OFST 0
+
+
+/***********************************/
+/* MC_CMD_ADD_LIGHTSOUT_OFFLOAD 
+ * Add a protocol offload to NIC for lights-out state.
+ */
+#define MC_CMD_ADD_LIGHTSOUT_OFFLOAD  0x46
+
+/* MC_CMD_ADD_LIGHTSOUT_OFFLOAD_IN msgrequest */
+#define    MC_CMD_ADD_LIGHTSOUT_OFFLOAD_IN_LENMIN 8
+#define    MC_CMD_ADD_LIGHTSOUT_OFFLOAD_IN_LENMAX 252
+#define    MC_CMD_ADD_LIGHTSOUT_OFFLOAD_IN_LEN(num) (4+4*(num))
+#define       MC_CMD_ADD_LIGHTSOUT_OFFLOAD_IN_PROTOCOL_OFST 0
+#define          MC_CMD_LIGHTSOUT_OFFLOAD_PROTOCOL_ARP 0x1 /* enum */
+#define          MC_CMD_LIGHTSOUT_OFFLOAD_PROTOCOL_NS  0x2 /* enum */
+#define       MC_CMD_ADD_LIGHTSOUT_OFFLOAD_IN_DATA_OFST 4
+#define       MC_CMD_ADD_LIGHTSOUT_OFFLOAD_IN_DATA_LEN 4
+#define       MC_CMD_ADD_LIGHTSOUT_OFFLOAD_IN_DATA_MINNUM 1
+#define       MC_CMD_ADD_LIGHTSOUT_OFFLOAD_IN_DATA_MAXNUM 62
+
+/* MC_CMD_ADD_LIGHTSOUT_OFFLOAD_IN_ARP msgrequest */
+#define    MC_CMD_ADD_LIGHTSOUT_OFFLOAD_IN_ARP_LEN 14
+/*            MC_CMD_ADD_LIGHTSOUT_OFFLOAD_IN_PROTOCOL_OFST 0 */
+#define       MC_CMD_ADD_LIGHTSOUT_OFFLOAD_IN_ARP_MAC_OFST 4
+#define       MC_CMD_ADD_LIGHTSOUT_OFFLOAD_IN_ARP_MAC_LEN 6
+#define       MC_CMD_ADD_LIGHTSOUT_OFFLOAD_IN_ARP_IP_OFST 10
+
+/* MC_CMD_ADD_LIGHTSOUT_OFFLOAD_IN_NS msgrequest */
+#define    MC_CMD_ADD_LIGHTSOUT_OFFLOAD_IN_NS_LEN 42
+/*            MC_CMD_ADD_LIGHTSOUT_OFFLOAD_IN_PROTOCOL_OFST 0 */
+#define       MC_CMD_ADD_LIGHTSOUT_OFFLOAD_IN_NS_MAC_OFST 4
+#define       MC_CMD_ADD_LIGHTSOUT_OFFLOAD_IN_NS_MAC_LEN 6
+#define       MC_CMD_ADD_LIGHTSOUT_OFFLOAD_IN_NS_SNIPV6_OFST 10
+#define       MC_CMD_ADD_LIGHTSOUT_OFFLOAD_IN_NS_SNIPV6_LEN 16
+#define       MC_CMD_ADD_LIGHTSOUT_OFFLOAD_IN_NS_IPV6_OFST 26
+#define       MC_CMD_ADD_LIGHTSOUT_OFFLOAD_IN_NS_IPV6_LEN 16
+
+/* MC_CMD_ADD_LIGHTSOUT_OFFLOAD_OUT msgresponse */
+#define    MC_CMD_ADD_LIGHTSOUT_OFFLOAD_OUT_LEN 4
+#define       MC_CMD_ADD_LIGHTSOUT_OFFLOAD_OUT_FILTER_ID_OFST 0
+
+
+/***********************************/
+/* MC_CMD_REMOVE_LIGHTSOUT_OFFLOAD 
+ * Remove a protocol offload from NIC for lights-out state.
+ */
+#define MC_CMD_REMOVE_LIGHTSOUT_OFFLOAD  0x47
+
+/* MC_CMD_REMOVE_LIGHTSOUT_OFFLOAD_IN msgrequest */
+#define    MC_CMD_REMOVE_LIGHTSOUT_OFFLOAD_IN_LEN 8
+#define       MC_CMD_REMOVE_LIGHTSOUT_OFFLOAD_IN_PROTOCOL_OFST 0
+#define       MC_CMD_REMOVE_LIGHTSOUT_OFFLOAD_IN_FILTER_ID_OFST 4
+
+/* MC_CMD_REMOVE_LIGHTSOUT_OFFLOAD_OUT msgresponse */
+#define    MC_CMD_REMOVE_LIGHTSOUT_OFFLOAD_OUT_LEN 0
+
+
+/***********************************/
+/* MC_CMD_MAC_RESET_RESTORE 
+ * Restore MAC after block reset.
+ */
+#define MC_CMD_MAC_RESET_RESTORE  0x48
+
+/* MC_CMD_MAC_RESET_RESTORE_IN msgrequest */
+#define    MC_CMD_MAC_RESET_RESTORE_IN_LEN 0
+
+/* MC_CMD_MAC_RESET_RESTORE_OUT msgresponse */
+#define    MC_CMD_MAC_RESET_RESTORE_OUT_LEN 0
+
+
+/***********************************/
+/* MC_CMD_TESTASSERT  
+ */
+#define MC_CMD_TESTASSERT   0x49
+
+/* MC_CMD_TESTASSERT_IN msgrequest */
+#define    MC_CMD_TESTASSERT_IN_LEN 0
+
+/* MC_CMD_TESTASSERT_OUT msgresponse */
+#define    MC_CMD_TESTASSERT_OUT_LEN 0
+
+
+/***********************************/
+/* MC_CMD_WORKAROUND 
+ * Enable/Disable a given workaround.
+ */
+#define MC_CMD_WORKAROUND  0x4a
+
+/* MC_CMD_WORKAROUND_IN msgrequest */
+#define    MC_CMD_WORKAROUND_IN_LEN 8
+#define       MC_CMD_WORKAROUND_IN_TYPE_OFST 0
+#define          MC_CMD_WORKAROUND_BUG17230 0x1 /* enum */
+#define       MC_CMD_WORKAROUND_IN_ENABLED_OFST 4
+
+/* MC_CMD_WORKAROUND_OUT msgresponse */
+#define    MC_CMD_WORKAROUND_OUT_LEN 0
+
+
+/***********************************/
+/* MC_CMD_GET_PHY_MEDIA_INFO 
+ * Read media-specific data from PHY.
+ */
+#define MC_CMD_GET_PHY_MEDIA_INFO  0x4b
+
+/* MC_CMD_GET_PHY_MEDIA_INFO_IN msgrequest */
+#define    MC_CMD_GET_PHY_MEDIA_INFO_IN_LEN 4
+#define       MC_CMD_GET_PHY_MEDIA_INFO_IN_PAGE_OFST 0
+
+/* MC_CMD_GET_PHY_MEDIA_INFO_OUT msgresponse */
+#define    MC_CMD_GET_PHY_MEDIA_INFO_OUT_LENMIN 5
+#define    MC_CMD_GET_PHY_MEDIA_INFO_OUT_LENMAX 255
+#define    MC_CMD_GET_PHY_MEDIA_INFO_OUT_LEN(num) (4+1*(num))
+#define       MC_CMD_GET_PHY_MEDIA_INFO_OUT_DATALEN_OFST 0
+#define       MC_CMD_GET_PHY_MEDIA_INFO_OUT_DATA_OFST 4
+#define       MC_CMD_GET_PHY_MEDIA_INFO_OUT_DATA_LEN 1
+#define       MC_CMD_GET_PHY_MEDIA_INFO_OUT_DATA_MINNUM 1
+#define       MC_CMD_GET_PHY_MEDIA_INFO_OUT_DATA_MAXNUM 251
+
+
+/***********************************/
+/* MC_CMD_NVRAM_TEST 
+ * Test a particular NVRAM partition.
+ */
+#define MC_CMD_NVRAM_TEST  0x4c
+
+/* MC_CMD_NVRAM_TEST_IN msgrequest */
+#define    MC_CMD_NVRAM_TEST_IN_LEN 4
+#define       MC_CMD_NVRAM_TEST_IN_TYPE_OFST 0
+/*            Enum values, see field(s): */
+/*               MC_CMD_NVRAM_TYPES/MC_CMD_NVRAM_TYPES_OUT/TYPES */
+
+/* MC_CMD_NVRAM_TEST_OUT msgresponse */
+#define    MC_CMD_NVRAM_TEST_OUT_LEN 4
+#define       MC_CMD_NVRAM_TEST_OUT_RESULT_OFST 0
+#define          MC_CMD_NVRAM_TEST_PASS 0x0 /* enum */
+#define          MC_CMD_NVRAM_TEST_FAIL 0x1 /* enum */
+#define          MC_CMD_NVRAM_TEST_NOTSUPP 0x2 /* enum */
+
+
+/***********************************/
+/* MC_CMD_MRSFP_TWEAK 
+ * Read status and/or set parameters for the 'mrsfp' driver.
+ */
+#define MC_CMD_MRSFP_TWEAK  0x4d
+
+/* MC_CMD_MRSFP_TWEAK_IN_EQ_CONFIG msgrequest */
+#define    MC_CMD_MRSFP_TWEAK_IN_EQ_CONFIG_LEN 16
+#define       MC_CMD_MRSFP_TWEAK_IN_EQ_CONFIG_TXEQ_LEVEL_OFST 0
+#define       MC_CMD_MRSFP_TWEAK_IN_EQ_CONFIG_TXEQ_DT_CFG_OFST 4
+#define       MC_CMD_MRSFP_TWEAK_IN_EQ_CONFIG_RXEQ_BOOST_OFST 8
+#define       MC_CMD_MRSFP_TWEAK_IN_EQ_CONFIG_RXEQ_DT_CFG_OFST 12
+
+/* MC_CMD_MRSFP_TWEAK_IN_READ_ONLY msgrequest */
+#define    MC_CMD_MRSFP_TWEAK_IN_READ_ONLY_LEN 0
+
+/* MC_CMD_MRSFP_TWEAK_OUT msgresponse */
+#define    MC_CMD_MRSFP_TWEAK_OUT_LEN 12
+#define       MC_CMD_MRSFP_TWEAK_OUT_IOEXP_INPUTS_OFST 0
+#define       MC_CMD_MRSFP_TWEAK_OUT_IOEXP_OUTPUTS_OFST 4
+#define       MC_CMD_MRSFP_TWEAK_OUT_IOEXP_DIRECTION_OFST 8
+#define          MC_CMD_MRSFP_TWEAK_OUT_IOEXP_DIRECTION_OUT 0x0 /* enum */
+#define          MC_CMD_MRSFP_TWEAK_OUT_IOEXP_DIRECTION_IN 0x1 /* enum */
+
+
+/***********************************/
+/* MC_CMD_SENSOR_SET_LIMS 
+ * Adjusts the sensor limits.
+ */
+#define MC_CMD_SENSOR_SET_LIMS  0x4e
+
+/* MC_CMD_SENSOR_SET_LIMS_IN msgrequest */
+#define    MC_CMD_SENSOR_SET_LIMS_IN_LEN 20
+#define       MC_CMD_SENSOR_SET_LIMS_IN_SENSOR_OFST 0
+/*            Enum values, see field(s): */
+/*               MC_CMD_SENSOR_INFO/MC_CMD_SENSOR_INFO_OUT/MASK */
+#define       MC_CMD_SENSOR_SET_LIMS_IN_LOW0_OFST 4
+#define       MC_CMD_SENSOR_SET_LIMS_IN_HI0_OFST 8
+#define       MC_CMD_SENSOR_SET_LIMS_IN_LOW1_OFST 12
+#define       MC_CMD_SENSOR_SET_LIMS_IN_HI1_OFST 16
+
+/* MC_CMD_SENSOR_SET_LIMS_OUT msgresponse */
+#define    MC_CMD_SENSOR_SET_LIMS_OUT_LEN 0
+
+
+/***********************************/
+/* MC_CMD_GET_RESOURCE_LIMITS 
+ */
+#define MC_CMD_GET_RESOURCE_LIMITS  0x4f
+
+/* MC_CMD_GET_RESOURCE_LIMITS_IN msgrequest */
+#define    MC_CMD_GET_RESOURCE_LIMITS_IN_LEN 0
+
+/* MC_CMD_GET_RESOURCE_LIMITS_OUT msgresponse */
+#define    MC_CMD_GET_RESOURCE_LIMITS_OUT_LEN 16
+#define       MC_CMD_GET_RESOURCE_LIMITS_OUT_BUFTBL_OFST 0
+#define       MC_CMD_GET_RESOURCE_LIMITS_OUT_EVQ_OFST 4
+#define       MC_CMD_GET_RESOURCE_LIMITS_OUT_RXQ_OFST 8
+#define       MC_CMD_GET_RESOURCE_LIMITS_OUT_TXQ_OFST 12
+
+/* MC_CMD_RESOURCE_SPECIFIER enum */
+#define          MC_CMD_RESOURCE_INSTANCE_ANY 0xffffffff /* enum */
+#define          MC_CMD_RESOURCE_INSTANCE_NONE 0xfffffffe /* enum */
+
+
+/***********************************/
+/* MC_CMD_INIT_EVQ 
+ */
+#define MC_CMD_INIT_EVQ  0x50
+
+/* MC_CMD_INIT_EVQ_IN msgrequest */
+#define    MC_CMD_INIT_EVQ_IN_LENMIN 36
+#define    MC_CMD_INIT_EVQ_IN_LENMAX 540
+#define    MC_CMD_INIT_EVQ_IN_LEN(num) (28+8*(num))
+#define       MC_CMD_INIT_EVQ_IN_SIZE_OFST 0
+#define       MC_CMD_INIT_EVQ_IN_INSTANCE_OFST 4
+#define       MC_CMD_INIT_EVQ_IN_TMR_LOAD_OFST 8
+#define       MC_CMD_INIT_EVQ_IN_TMR_RELOAD_OFST 12
+#define       MC_CMD_INIT_EVQ_IN_FLAGS_OFST 16
+#define        MC_CMD_INIT_EVQ_IN_FLAG_INTERRUPTING_LBN 0
+#define        MC_CMD_INIT_EVQ_IN_FLAG_INTERRUPTING_WIDTH 1
+#define        MC_CMD_INIT_EVQ_IN_FLAG_RPTR_DOS_LBN 1
+#define        MC_CMD_INIT_EVQ_IN_FLAG_RPTR_DOS_WIDTH 1
+#define       MC_CMD_INIT_EVQ_IN_TMR_MODE_OFST 20
+#define          MC_CMD_INIT_EVQ_IN_TMR_MODE_DIS 0x0 /* enum */
+#define          MC_CMD_INIT_EVQ_IN_TMR_IMMED_START 0x1 /* enum */
+#define          MC_CMD_INIT_EVQ_IN_TMR_TRIG_START 0x2 /* enum */
+#define          MC_CMD_INIT_EVQ_IN_TMR_INT_HLDOFF 0x3 /* enum */
+#define       MC_CMD_INIT_EVQ_IN_TARGET_EVQ_OFST 24
+#define       MC_CMD_INIT_EVQ_IN_IRQ_NUM_OFST 24
+#define       MC_CMD_INIT_EVQ_IN_DMA_ADDR_OFST 28
+#define       MC_CMD_INIT_EVQ_IN_DMA_ADDR_LEN 8
+#define       MC_CMD_INIT_EVQ_IN_DMA_ADDR_LO_OFST 28
+#define       MC_CMD_INIT_EVQ_IN_DMA_ADDR_HI_OFST 32
+#define       MC_CMD_INIT_EVQ_IN_DMA_ADDR_MINNUM 1
+#define       MC_CMD_INIT_EVQ_IN_DMA_ADDR_MAXNUM 64
+
+/* MC_CMD_INIT_EVQ_OUT msgresponse */
+#define    MC_CMD_INIT_EVQ_OUT_LEN 4
+#define       MC_CMD_INIT_EVQ_OUT_IRQ_OFST 0
+
+/* QUEUE_CRC_MODE structuredef */
+#define    QUEUE_CRC_MODE_LEN 1
+#define       QUEUE_CRC_MODE_MODE_LBN 0
+#define       QUEUE_CRC_MODE_MODE_WIDTH 4
+#define          QUEUE_CRC_MODE_NONE  0x0 /* enum */
+#define          QUEUE_CRC_MODE_FCOE  0x1 /* enum */
+#define          QUEUE_CRC_MODE_ISCSI_HDR  0x2 /* enum */
+#define          QUEUE_CRC_MODE_ISCSI  0x3 /* enum */
+#define          QUEUE_CRC_MODE_FCOIPOE  0x4 /* enum */
+#define          QUEUE_CRC_MODE_MPA  0x5 /* enum */
+#define       QUEUE_CRC_MODE_SPARE_LBN 4
+#define       QUEUE_CRC_MODE_SPARE_WIDTH 4
+
+
+/***********************************/
+/* MC_CMD_INIT_RXQ 
+ */
+#define MC_CMD_INIT_RXQ  0x51
+
+/* MC_CMD_INIT_RXQ_IN msgrequest */
+#define    MC_CMD_INIT_RXQ_IN_LENMIN 32
+#define    MC_CMD_INIT_RXQ_IN_LENMAX 248
+#define    MC_CMD_INIT_RXQ_IN_LEN(num) (24+8*(num))
+#define       MC_CMD_INIT_RXQ_IN_SIZE_OFST 0
+#define       MC_CMD_INIT_RXQ_IN_TARGET_EVQ_OFST 4
+#define       MC_CMD_INIT_RXQ_IN_LABEL_OFST 8
+#define       MC_CMD_INIT_RXQ_IN_INSTANCE_OFST 12
+#define       MC_CMD_INIT_RXQ_IN_FLAGS_OFST 16
+#define        MC_CMD_INIT_RXQ_IN_FLAG_BUFF_MODE_LBN 0
+#define        MC_CMD_INIT_RXQ_IN_FLAG_BUFF_MODE_WIDTH 1
+#define        MC_CMD_INIT_RXQ_IN_FLAG_HDR_SPLIT_LBN 1
+#define        MC_CMD_INIT_RXQ_IN_FLAG_HDR_SPLIT_WIDTH 1
+#define        MC_CMD_INIT_RXQ_IN_FLAG_PKT_EDIT_LBN 2
+#define        MC_CMD_INIT_RXQ_IN_FLAG_PKT_EDIT_WIDTH 1
+#define        MC_CMD_INIT_RXQ_IN_CRC_MODE_LBN 3
+#define        MC_CMD_INIT_RXQ_IN_CRC_MODE_WIDTH 4
+#define       MC_CMD_INIT_RXQ_IN_OWNER_ID_OFST 20
+#define       MC_CMD_INIT_RXQ_IN_DMA_ADDR_OFST 24
+#define       MC_CMD_INIT_RXQ_IN_DMA_ADDR_LEN 8
+#define       MC_CMD_INIT_RXQ_IN_DMA_ADDR_LO_OFST 24
+#define       MC_CMD_INIT_RXQ_IN_DMA_ADDR_HI_OFST 28
+#define       MC_CMD_INIT_RXQ_IN_DMA_ADDR_MINNUM 1
+#define       MC_CMD_INIT_RXQ_IN_DMA_ADDR_MAXNUM 28
+
+/* MC_CMD_INIT_RXQ_OUT msgresponse */
+#define    MC_CMD_INIT_RXQ_OUT_LEN 0
+
+
+/***********************************/
+/* MC_CMD_INIT_TXQ 
+ */
+#define MC_CMD_INIT_TXQ  0x52
+
+/* MC_CMD_INIT_TXQ_IN msgrequest */
+#define    MC_CMD_INIT_TXQ_IN_LENMIN 32
+#define    MC_CMD_INIT_TXQ_IN_LENMAX 248
+#define    MC_CMD_INIT_TXQ_IN_LEN(num) (24+8*(num))
+#define       MC_CMD_INIT_TXQ_IN_SIZE_OFST 0
+#define       MC_CMD_INIT_TXQ_IN_TARGET_EVQ_OFST 4
+#define       MC_CMD_INIT_TXQ_IN_LABEL_OFST 8
+#define       MC_CMD_INIT_TXQ_IN_INSTANCE_OFST 12
+#define       MC_CMD_INIT_TXQ_IN_FLAGS_OFST 16
+#define        MC_CMD_INIT_TXQ_IN_FLAG_BUFF_MODE_LBN 0
+#define        MC_CMD_INIT_TXQ_IN_FLAG_BUFF_MODE_WIDTH 1
+#define        MC_CMD_INIT_TXQ_IN_FLAG_IP_CSUM_DIS_LBN 1
+#define        MC_CMD_INIT_TXQ_IN_FLAG_IP_CSUM_DIS_WIDTH 1
+#define        MC_CMD_INIT_TXQ_IN_FLAG_TCP_CSUM_DIS_LBN 2
+#define        MC_CMD_INIT_TXQ_IN_FLAG_TCP_CSUM_DIS_WIDTH 1
+#define        MC_CMD_INIT_TXQ_IN_CRC_MODE_LBN 4
+#define        MC_CMD_INIT_TXQ_IN_CRC_MODE_WIDTH 4
+#define       MC_CMD_INIT_TXQ_IN_OWNER_ID_OFST 20
+#define       MC_CMD_INIT_TXQ_IN_DMA_ADDR_OFST 24
+#define       MC_CMD_INIT_TXQ_IN_DMA_ADDR_LEN 8
+#define       MC_CMD_INIT_TXQ_IN_DMA_ADDR_LO_OFST 24
+#define       MC_CMD_INIT_TXQ_IN_DMA_ADDR_HI_OFST 28
+#define       MC_CMD_INIT_TXQ_IN_DMA_ADDR_MINNUM 1
+#define       MC_CMD_INIT_TXQ_IN_DMA_ADDR_MAXNUM 28
+
+/* MC_CMD_INIT_TXQ_OUT msgresponse */
+#define    MC_CMD_INIT_TXQ_OUT_LEN 0
+
+
+/***********************************/
+/* MC_CMD_FINI_EVQ 
+ */
+#define MC_CMD_FINI_EVQ  0x55
+
+/* MC_CMD_FINI_EVQ_IN msgrequest */
+#define    MC_CMD_FINI_EVQ_IN_LEN 4
+#define       MC_CMD_FINI_EVQ_IN_INSTANCE_OFST 0
+
+/* MC_CMD_FINI_EVQ_OUT msgresponse */
+#define    MC_CMD_FINI_EVQ_OUT_LEN 0
+
+
+/***********************************/
+/* MC_CMD_FINI_RXQ 
+ */
+#define MC_CMD_FINI_RXQ  0x56
+
+/* MC_CMD_FINI_RXQ_IN msgrequest */
+#define    MC_CMD_FINI_RXQ_IN_LEN 4
+#define       MC_CMD_FINI_RXQ_IN_INSTANCE_OFST 0
+
+/* MC_CMD_FINI_RXQ_OUT msgresponse */
+#define    MC_CMD_FINI_RXQ_OUT_LEN 0
+
+
+/***********************************/
+/* MC_CMD_FINI_TXQ 
+ */
+#define MC_CMD_FINI_TXQ  0x57
+
+/* MC_CMD_FINI_TXQ_IN msgrequest */
+#define    MC_CMD_FINI_TXQ_IN_LEN 4
+#define       MC_CMD_FINI_TXQ_IN_INSTANCE_OFST 0
+
+/* MC_CMD_FINI_TXQ_OUT msgresponse */
+#define    MC_CMD_FINI_TXQ_OUT_LEN 0
+
+
+/***********************************/
+/* MC_CMD_DRIVER_EVENT 
+ */
+#define MC_CMD_DRIVER_EVENT  0x5a
+
+/* MC_CMD_DRIVER_EVENT_IN msgrequest */
+#define    MC_CMD_DRIVER_EVENT_IN_LEN 12
+#define       MC_CMD_DRIVER_EVENT_IN_EVQ_OFST 0
+#define       MC_CMD_DRIVER_EVENT_IN_DATA_OFST 4
+#define       MC_CMD_DRIVER_EVENT_IN_DATA_LEN 8
+#define       MC_CMD_DRIVER_EVENT_IN_DATA_LO_OFST 4
+#define       MC_CMD_DRIVER_EVENT_IN_DATA_HI_OFST 8
+
+
+/***********************************/
+/* MC_CMD_PROXY_CMD 
+ */
+#define MC_CMD_PROXY_CMD  0x5b
+
+/* MC_CMD_PROXY_CMD_IN msgrequest */
+#define    MC_CMD_PROXY_CMD_IN_LEN 4
+#define       MC_CMD_PROXY_CMD_IN_TARGET_OFST 0
+
+
+/***********************************/
+/* MC_CMD_ALLOC_OWNER_IDS 
+ */
+#define MC_CMD_ALLOC_OWNER_IDS  0x54
+
+/* MC_CMD_ALLOC_OWNER_IDS_IN msgrequest */
+#define    MC_CMD_ALLOC_OWNER_IDS_IN_LEN 4
+#define       MC_CMD_ALLOC_OWNER_IDS_IN_NIDS_OFST 0
+
+/* MC_CMD_ALLOC_OWNER_IDS_OUT msgresponse */
+#define    MC_CMD_ALLOC_OWNER_IDS_OUT_LEN 12
+#define       MC_CMD_ALLOC_OWNER_IDS_OUT_HANDLE_OFST 0
+#define       MC_CMD_ALLOC_OWNER_IDS_OUT_NIDS_OFST 4
+#define       MC_CMD_ALLOC_OWNER_IDS_OUT_BASE_OFST 8
+
+
+/***********************************/
+/* MC_CMD_FREE_OWNER_IDS 
+ */
+#define MC_CMD_FREE_OWNER_IDS  0x59
+
+/* MC_CMD_FREE_OWNER_IDS_IN msgrequest */
+#define    MC_CMD_FREE_OWNER_IDS_IN_LEN 4
+#define       MC_CMD_FREE_OWNER_IDS_IN_HANDLE_OFST 0
+
+/* MC_CMD_FREE_OWNER_IDS_OUT msgresponse */
+#define    MC_CMD_FREE_OWNER_IDS_OUT_LEN 0
+
+
+/***********************************/
+/* MC_CMD_ALLOC_BUFTBL_CHUNK 
+ */
+#define MC_CMD_ALLOC_BUFTBL_CHUNK  0x5c
+
+/* MC_CMD_ALLOC_BUFTBL_CHUNK_IN msgrequest */
+#define    MC_CMD_ALLOC_BUFTBL_CHUNK_IN_LEN 8
+#define       MC_CMD_ALLOC_BUFTBL_CHUNK_IN_OWNER_OFST 0
+#define       MC_CMD_ALLOC_BUFTBL_CHUNK_IN_PAGE_SIZE_OFST 4
+
+/* MC_CMD_ALLOC_BUFTBL_CHUNK_OUT msgresponse */
+#define    MC_CMD_ALLOC_BUFTBL_CHUNK_OUT_LEN 12
+#define       MC_CMD_ALLOC_BUFTBL_CHUNK_OUT_HANDLE_OFST 0
+#define       MC_CMD_ALLOC_BUFTBL_CHUNK_OUT_NUMENTRIES_OFST 4
+#define       MC_CMD_ALLOC_BUFTBL_CHUNK_OUT_ID_OFST 8
+
+
+/***********************************/
+/* MC_CMD_PROGRAM_BUFTBL_ENTRIES 
+ */
+#define MC_CMD_PROGRAM_BUFTBL_ENTRIES  0x5d
+
+/* MC_CMD_PROGRAM_BUFTBL_ENTRIES_IN msgrequest */
+#define    MC_CMD_PROGRAM_BUFTBL_ENTRIES_IN_LENMIN 20
+#define    MC_CMD_PROGRAM_BUFTBL_ENTRIES_IN_LENMAX 252
+#define    MC_CMD_PROGRAM_BUFTBL_ENTRIES_IN_LEN(num) (12+8*(num))
+#define       MC_CMD_PROGRAM_BUFTBL_ENTRIES_IN_HANDLE_OFST 0
+#define       MC_CMD_PROGRAM_BUFTBL_ENTRIES_IN_FIRSTID_OFST 4
+#define       MC_CMD_PROGRAM_BUFTBL_ENTRIES_IN_NUMENTRIES_OFST 8
+#define       MC_CMD_PROGRAM_BUFTBL_ENTRIES_IN_ENTRY_OFST 12
+#define       MC_CMD_PROGRAM_BUFTBL_ENTRIES_IN_ENTRY_LEN 8
+#define       MC_CMD_PROGRAM_BUFTBL_ENTRIES_IN_ENTRY_LO_OFST 12
+#define       MC_CMD_PROGRAM_BUFTBL_ENTRIES_IN_ENTRY_HI_OFST 16
+#define       MC_CMD_PROGRAM_BUFTBL_ENTRIES_IN_ENTRY_MINNUM 1
+#define       MC_CMD_PROGRAM_BUFTBL_ENTRIES_IN_ENTRY_MAXNUM 30
+
+/* MC_CMD_PROGRAM_BUFTBL_ENTRIES_OUT msgresponse */
+#define    MC_CMD_PROGRAM_BUFTBL_ENTRIES_OUT_LEN 0
+
+
+/***********************************/
+/* MC_CMD_FREE_BUFTBL_CHUNK 
+ */
+#define MC_CMD_FREE_BUFTBL_CHUNK  0x5e
+
+/* MC_CMD_FREE_BUFTBL_CHUNK_IN msgrequest */
+#define    MC_CMD_FREE_BUFTBL_CHUNK_IN_LEN 4
+#define       MC_CMD_FREE_BUFTBL_CHUNK_IN_HANDLE_OFST 0
+
+/* MC_CMD_FREE_BUFTBL_CHUNK_OUT msgresponse */
+#define    MC_CMD_FREE_BUFTBL_CHUNK_OUT_LEN 0
+
+
+/***********************************/
+/* MC_CMD_GET_PF_COUNT 
+ */
+#define MC_CMD_GET_PF_COUNT  0x60
+
+/* MC_CMD_GET_PF_COUNT_IN msgrequest */
+#define    MC_CMD_GET_PF_COUNT_IN_LEN 0
+
+/* MC_CMD_GET_PF_COUNT_OUT msgresponse */
+#define    MC_CMD_GET_PF_COUNT_OUT_LEN 1
+#define       MC_CMD_GET_PF_COUNT_OUT_PF_COUNT_OFST 0
+#define       MC_CMD_GET_PF_COUNT_OUT_PF_COUNT_LEN 1
+
+
+/***********************************/
+/* MC_CMD_FILTER_OP 
+ */
+#define MC_CMD_FILTER_OP  0x61
+
+/* MC_CMD_FILTER_OP_IN msgrequest */
+#define    MC_CMD_FILTER_OP_IN_LEN 100
+#define       MC_CMD_FILTER_OP_IN_OP_OFST 0
+#define          MC_CMD_FILTER_OP_IN_OP_INSERT  0x0 /* enum */
+#define          MC_CMD_FILTER_OP_IN_OP_REMOVE  0x1 /* enum */
+#define          MC_CMD_FILTER_OP_IN_OP_SUBSCRIBE  0x2 /* enum */
+#define          MC_CMD_FILTER_OP_IN_OP_UNSUBSCRIBE  0x3 /* enum */
+#define       MC_CMD_FILTER_OP_IN_HANDLE_OFST 4
+#define       MC_CMD_FILTER_OP_IN_MATCH_FIELDS_OFST 8
+#define        MC_CMD_FILTER_OP_IN_MATCH_SRC_IP_LBN 0
+#define        MC_CMD_FILTER_OP_IN_MATCH_SRC_IP_WIDTH 1
+#define        MC_CMD_FILTER_OP_IN_MATCH_DST_IP_LBN 1
+#define        MC_CMD_FILTER_OP_IN_MATCH_DST_IP_WIDTH 1
+#define        MC_CMD_FILTER_OP_IN_MATCH_SRC_MAC_LBN 2
+#define        MC_CMD_FILTER_OP_IN_MATCH_SRC_MAC_WIDTH 1
+#define        MC_CMD_FILTER_OP_IN_MATCH_SRC_PORT_LBN 3
+#define        MC_CMD_FILTER_OP_IN_MATCH_SRC_PORT_WIDTH 1
+#define        MC_CMD_FILTER_OP_IN_MATCH_DST_MAC_LBN 4
+#define        MC_CMD_FILTER_OP_IN_MATCH_DST_MAC_WIDTH 1
+#define        MC_CMD_FILTER_OP_IN_MATCH_DST_PORT_LBN 5
+#define        MC_CMD_FILTER_OP_IN_MATCH_DST_PORT_WIDTH 1
+#define        MC_CMD_FILTER_OP_IN_MATCH_ETHER_TYPE_LBN 6
+#define        MC_CMD_FILTER_OP_IN_MATCH_ETHER_TYPE_WIDTH 1
+#define        MC_CMD_FILTER_OP_IN_MATCH_INNER_VLAN_LBN 7
+#define        MC_CMD_FILTER_OP_IN_MATCH_INNER_VLAN_WIDTH 1
+#define        MC_CMD_FILTER_OP_IN_MATCH_OUTER_VLAN_LBN 8
+#define        MC_CMD_FILTER_OP_IN_MATCH_OUTER_VLAN_WIDTH 1
+#define        MC_CMD_FILTER_OP_IN_MATCH_IP_PROTO_LBN 9
+#define        MC_CMD_FILTER_OP_IN_MATCH_IP_PROTO_WIDTH 1
+#define        MC_CMD_FILTER_OP_IN_MATCH_FWDEF0_LBN 10
+#define        MC_CMD_FILTER_OP_IN_MATCH_FWDEF0_WIDTH 1
+#define        MC_CMD_FILTER_OP_IN_MATCH_FWDEF1_LBN 11
+#define        MC_CMD_FILTER_OP_IN_MATCH_FWDEF1_WIDTH 1
+#define       MC_CMD_FILTER_OP_IN_RX_DEST_OFST 12
+#define          MC_CMD_FILTER_OP_IN_RX_DEST_DROP  0x0 /* enum */
+#define          MC_CMD_FILTER_OP_IN_RX_DEST_HOST  0x1 /* enum */
+#define          MC_CMD_FILTER_OP_IN_RX_DEST_MC  0x2 /* enum */
+#define          MC_CMD_FILTER_OP_IN_RX_DEST_TX0  0x3 /* enum */
+#define          MC_CMD_FILTER_OP_IN_RX_DEST_TX1  0x4 /* enum */
+#define       MC_CMD_FILTER_OP_IN_RX_QUEUE_OFST 16
+#define       MC_CMD_FILTER_OP_IN_RX_FLAGS_OFST 20
+#define        MC_CMD_FILTER_OP_IN_RX_FLAG_RSS_LBN 0
+#define        MC_CMD_FILTER_OP_IN_RX_FLAG_RSS_WIDTH 1
+#define       MC_CMD_FILTER_OP_IN_RSS_CONTEXT_OFST 24
+#define       MC_CMD_FILTER_OP_IN_TX_DOMAIN_OFST 28
+#define       MC_CMD_FILTER_OP_IN_TX_DEST_OFST 32
+#define        MC_CMD_FILTER_OP_IN_TX_DEST_MAC_LBN 0
+#define        MC_CMD_FILTER_OP_IN_TX_DEST_MAC_WIDTH 1
+#define        MC_CMD_FILTER_OP_IN_TX_DEST_PM_LBN 1
+#define        MC_CMD_FILTER_OP_IN_TX_DEST_PM_WIDTH 1
+#define       MC_CMD_FILTER_OP_IN_SRC_MAC_OFST 36
+#define       MC_CMD_FILTER_OP_IN_SRC_MAC_LEN 6
+#define       MC_CMD_FILTER_OP_IN_SRC_PORT_OFST 42
+#define       MC_CMD_FILTER_OP_IN_SRC_PORT_LEN 2
+#define       MC_CMD_FILTER_OP_IN_DST_MAC_OFST 44
+#define       MC_CMD_FILTER_OP_IN_DST_MAC_LEN 6
+#define       MC_CMD_FILTER_OP_IN_DST_PORT_OFST 50
+#define       MC_CMD_FILTER_OP_IN_DST_PORT_LEN 2
+#define       MC_CMD_FILTER_OP_IN_ETHER_TYPE_OFST 52
+#define       MC_CMD_FILTER_OP_IN_ETHER_TYPE_LEN 2
+#define       MC_CMD_FILTER_OP_IN_INNER_VLAN_OFST 54
+#define       MC_CMD_FILTER_OP_IN_INNER_VLAN_LEN 2
+#define       MC_CMD_FILTER_OP_IN_OUTER_VLAN_OFST 56
+#define       MC_CMD_FILTER_OP_IN_OUTER_VLAN_LEN 2
+#define       MC_CMD_FILTER_OP_IN_IP_PROTO_OFST 58
+#define       MC_CMD_FILTER_OP_IN_IP_PROTO_LEN 2
+#define       MC_CMD_FILTER_OP_IN_FWDEF0_OFST 60
+#define       MC_CMD_FILTER_OP_IN_FWDEF1_OFST 64
+#define       MC_CMD_FILTER_OP_IN_SRC_IP_OFST 68
+#define       MC_CMD_FILTER_OP_IN_SRC_IP_LEN 16
+#define       MC_CMD_FILTER_OP_IN_DST_IP_OFST 84
+#define       MC_CMD_FILTER_OP_IN_DST_IP_LEN 16
+
+/* MC_CMD_FILTER_OP_OUT msgresponse */
+#define    MC_CMD_FILTER_OP_OUT_LEN 8
+#define       MC_CMD_FILTER_OP_OUT_OP_OFST 0
+#define          MC_CMD_FILTER_OP_OUT_OP_INSERT  0x0 /* enum */
+#define          MC_CMD_FILTER_OP_OUT_OP_REMOVE  0x1 /* enum */
+#define          MC_CMD_FILTER_OP_OUT_OP_SUBSCRIBE  0x2 /* enum */
+#define          MC_CMD_FILTER_OP_OUT_OP_UNSUBSCRIBE  0x3 /* enum */
+#define       MC_CMD_FILTER_OP_OUT_HANDLE_OFST 4
+
+
+/***********************************/
+/* MC_CMD_SET_PF_COUNT 
+ */
+#define MC_CMD_SET_PF_COUNT  0x62
+
+/* MC_CMD_SET_PF_COUNT_IN msgrequest */
+#define    MC_CMD_SET_PF_COUNT_IN_LEN 4
+#define       MC_CMD_SET_PF_COUNT_IN_PF_COUNT_OFST 0
+
+/* MC_CMD_SET_PF_COUNT_OUT msgresponse */
+#define    MC_CMD_SET_PF_COUNT_OUT_LEN 0
+
+
+/***********************************/
+/* MC_CMD_GET_PORT_ASSIGNMENT 
+ */
+#define MC_CMD_GET_PORT_ASSIGNMENT  0x63
+
+/* MC_CMD_GET_PORT_ASSIGNMENT_IN msgrequest */
+#define    MC_CMD_GET_PORT_ASSIGNMENT_IN_LEN 0
+
+/* MC_CMD_GET_PORT_ASSIGNMENT_OUT msgresponse */
+#define    MC_CMD_GET_PORT_ASSIGNMENT_OUT_LEN 4
+#define       MC_CMD_GET_PORT_ASSIGNMENT_OUT_PORT_OFST 0
+
+
+/***********************************/
+/* MC_CMD_SET_PORT_ASSIGNMENT 
+ */
+#define MC_CMD_SET_PORT_ASSIGNMENT  0x64
+
+/* MC_CMD_SET_PORT_ASSIGNMENT_IN msgrequest */
+#define    MC_CMD_SET_PORT_ASSIGNMENT_IN_LEN 4
+#define       MC_CMD_SET_PORT_ASSIGNMENT_IN_PORT_OFST 0
+
+/* MC_CMD_SET_PORT_ASSIGNMENT_OUT msgresponse */
+#define    MC_CMD_SET_PORT_ASSIGNMENT_OUT_LEN 0
+
+
+/***********************************/
+/* MC_CMD_ALLOC_VIS 
+ */
+#define MC_CMD_ALLOC_VIS  0x65
+
+/* MC_CMD_ALLOC_VIS_IN msgrequest */
+#define    MC_CMD_ALLOC_VIS_IN_LEN 4
+#define       MC_CMD_ALLOC_VIS_IN_VI_COUNT_OFST 0
+
+/* MC_CMD_ALLOC_VIS_OUT msgresponse */
+#define    MC_CMD_ALLOC_VIS_OUT_LEN 0
+
+
+/***********************************/
+/* MC_CMD_FREE_VIS 
+ */
+#define MC_CMD_FREE_VIS  0x66
+
+/* MC_CMD_FREE_VIS_IN msgrequest */
+#define    MC_CMD_FREE_VIS_IN_LEN 0
+
+/* MC_CMD_FREE_VIS_OUT msgresponse */
+#define    MC_CMD_FREE_VIS_OUT_LEN 0
+
+
+/***********************************/
+/* MC_CMD_GET_SRIOV_CFG 
+ */
+#define MC_CMD_GET_SRIOV_CFG  0x67
+
+/* MC_CMD_GET_SRIOV_CFG_IN msgrequest */
+#define    MC_CMD_GET_SRIOV_CFG_IN_LEN 0
+
+/* MC_CMD_GET_SRIOV_CFG_OUT msgresponse */
+#define    MC_CMD_GET_SRIOV_CFG_OUT_LEN 20
+#define       MC_CMD_GET_SRIOV_CFG_OUT_VF_CURRENT_OFST 0
+#define       MC_CMD_GET_SRIOV_CFG_OUT_VF_MAX_OFST 4
+#define       MC_CMD_GET_SRIOV_CFG_OUT_FLAGS_OFST 8
+#define        MC_CMD_GET_SRIOV_CFG_OUT_VF_ENABLED_LBN 0
+#define        MC_CMD_GET_SRIOV_CFG_OUT_VF_ENABLED_WIDTH 1
+#define       MC_CMD_GET_SRIOV_CFG_OUT_VF_OFFSET_OFST 12
+#define       MC_CMD_GET_SRIOV_CFG_OUT_VF_STRIDE_OFST 16
+
+
+/***********************************/
+/* MC_CMD_SET_SRIOV_CFG 
+ */
+#define MC_CMD_SET_SRIOV_CFG  0x68
+
+/* MC_CMD_SET_SRIOV_CFG_IN msgrequest */
+#define    MC_CMD_SET_SRIOV_CFG_IN_LEN 20
+#define       MC_CMD_SET_SRIOV_CFG_IN_VF_CURRENT_OFST 0
+#define       MC_CMD_SET_SRIOV_CFG_IN_VF_MAX_OFST 4
+#define       MC_CMD_SET_SRIOV_CFG_IN_FLAGS_OFST 8
+#define        MC_CMD_SET_SRIOV_CFG_IN_VF_ENABLED_LBN 0
+#define        MC_CMD_SET_SRIOV_CFG_IN_VF_ENABLED_WIDTH 1
+#define       MC_CMD_SET_SRIOV_CFG_IN_VF_OFFSET_OFST 12
+#define       MC_CMD_SET_SRIOV_CFG_IN_VF_STRIDE_OFST 16
+
+/* MC_CMD_SET_SRIOV_CFG_OUT msgresponse */
+#define    MC_CMD_SET_SRIOV_CFG_OUT_LEN 0
+
+
+/***********************************/
+/* MC_CMD_GET_VI_COUNT 
+ */
+#define MC_CMD_GET_VI_COUNT  0x69
+
+/* MC_CMD_GET_VI_COUNT_IN msgrequest */
+#define    MC_CMD_GET_VI_COUNT_IN_LEN 0
+
+/* MC_CMD_GET_VI_COUNT_OUT msgresponse */
+#define    MC_CMD_GET_VI_COUNT_OUT_LEN 4
+#define       MC_CMD_GET_VI_COUNT_OUT_VI_COUNT_OFST 0
+
+
+/***********************************/
+/* MC_CMD_GET_VECTOR_CFG 
+ */
+#define MC_CMD_GET_VECTOR_CFG  0x70
+
+/* MC_CMD_GET_VECTOR_CFG_IN msgrequest */
+#define    MC_CMD_GET_VECTOR_CFG_IN_LEN 0
+
+/* MC_CMD_GET_VECTOR_CFG_OUT msgresponse */
+#define    MC_CMD_GET_VECTOR_CFG_OUT_LEN 12
+#define       MC_CMD_GET_VECTOR_CFG_OUT_VEC_BASE_OFST 0
+#define       MC_CMD_GET_VECTOR_CFG_OUT_VECS_PER_PF_OFST 4
+#define       MC_CMD_GET_VECTOR_CFG_OUT_VECS_PER_VF_OFST 8
+
+
+/***********************************/
+/* MC_CMD_SET_VECTOR_CFG 
+ */
+#define MC_CMD_SET_VECTOR_CFG  0x71
+
+/* MC_CMD_SET_VECTOR_CFG_IN msgrequest */
+#define    MC_CMD_SET_VECTOR_CFG_IN_LEN 12
+#define       MC_CMD_SET_VECTOR_CFG_IN_VEC_BASE_OFST 0
+#define       MC_CMD_SET_VECTOR_CFG_IN_VECS_PER_PF_OFST 4
+#define       MC_CMD_SET_VECTOR_CFG_IN_VECS_PER_VF_OFST 8
+
+/* MC_CMD_SET_VECTOR_CFG_OUT msgresponse */
+#define    MC_CMD_SET_VECTOR_CFG_OUT_LEN 0
+
+
+/***********************************/
+/* MC_CMD_ALLOC_PIOBUF 
+ */
+#define MC_CMD_ALLOC_PIOBUF  0x72
+
+/* MC_CMD_ALLOC_PIOBUF_IN msgrequest */
+#define    MC_CMD_ALLOC_PIOBUF_IN_LEN 0
+
+/* MC_CMD_ALLOC_PIOBUF_OUT msgresponse */
+#define    MC_CMD_ALLOC_PIOBUF_OUT_LEN 4
+#define       MC_CMD_ALLOC_PIOBUF_OUT_PIOBUF_HANDLE_OFST 0
+
+
+/***********************************/
+/* MC_CMD_FREE_PIOBUF 
+ */
+#define MC_CMD_FREE_PIOBUF  0x73
+
+/* MC_CMD_FREE_PIOBUF_IN msgrequest */
+#define    MC_CMD_FREE_PIOBUF_IN_LEN 4
+#define       MC_CMD_FREE_PIOBUF_IN_PIOBUF_HANDLE_OFST 0
+
+/* MC_CMD_FREE_PIOBUF_OUT msgresponse */
+#define    MC_CMD_FREE_PIOBUF_OUT_LEN 0
+
+
+/***********************************/
+/* MC_CMD_V2_EXTN 
+ */
+#define MC_CMD_V2_EXTN  0x7f
+
+/* MC_CMD_V2_EXTN_IN msgrequest */
+#define    MC_CMD_V2_EXTN_IN_LEN 4
+#define       MC_CMD_V2_EXTN_IN_EXTENDED_CMD_LBN 0
+#define       MC_CMD_V2_EXTN_IN_EXTENDED_CMD_WIDTH 15
+#define       MC_CMD_V2_EXTN_IN_UNUSED_LBN 15
+#define       MC_CMD_V2_EXTN_IN_UNUSED_WIDTH 1
+#define       MC_CMD_V2_EXTN_IN_ACTUAL_LEN_LBN 16
+#define       MC_CMD_V2_EXTN_IN_ACTUAL_LEN_WIDTH 10
+#define       MC_CMD_V2_EXTN_IN_UNUSED2_LBN 26
+#define       MC_CMD_V2_EXTN_IN_UNUSED2_WIDTH 6
+
+
+/***********************************/
+/* MC_CMD_TCM_BUCKET_ALLOC 
+ */
+#define MC_CMD_TCM_BUCKET_ALLOC  0x80
+
+/* MC_CMD_TCM_BUCKET_ALLOC_IN msgrequest */
+#define    MC_CMD_TCM_BUCKET_ALLOC_IN_LEN 0
+
+/* MC_CMD_TCM_BUCKET_ALLOC_OUT msgresponse */
+#define    MC_CMD_TCM_BUCKET_ALLOC_OUT_LEN 4
+#define       MC_CMD_TCM_BUCKET_ALLOC_OUT_BUCKET_OFST 0
+
+
+/***********************************/
+/* MC_CMD_TCM_BUCKET_FREE 
+ */
+#define MC_CMD_TCM_BUCKET_FREE  0x81
+
+/* MC_CMD_TCM_BUCKET_FREE_IN msgrequest */
+#define    MC_CMD_TCM_BUCKET_FREE_IN_LEN 4
+#define       MC_CMD_TCM_BUCKET_FREE_IN_BUCKET_OFST 0
+
+/* MC_CMD_TCM_BUCKET_FREE_OUT msgresponse */
+#define    MC_CMD_TCM_BUCKET_FREE_OUT_LEN 0
+
+
+/***********************************/
+/* MC_CMD_TCM_BUCKET_INIT 
+ */
+#define MC_CMD_TCM_BUCKET_INIT  0x82
+
+/* MC_CMD_TCM_BUCKET_INIT_IN msgrequest */
+#define    MC_CMD_TCM_BUCKET_INIT_IN_LEN 8
+#define       MC_CMD_TCM_BUCKET_INIT_IN_BUCKET_OFST 0
+#define       MC_CMD_TCM_BUCKET_INIT_IN_RATE_OFST 4
+
+/* MC_CMD_TCM_BUCKET_INIT_OUT msgresponse */
+#define    MC_CMD_TCM_BUCKET_INIT_OUT_LEN 0
+
+
+/***********************************/
+/* MC_CMD_TCM_TXQ_INIT 
+ */
+#define MC_CMD_TCM_TXQ_INIT  0x83
+
+/* MC_CMD_TCM_TXQ_INIT_IN msgrequest */
+#define    MC_CMD_TCM_TXQ_INIT_IN_LEN 28
+#define       MC_CMD_TCM_TXQ_INIT_IN_QID_OFST 0
+#define       MC_CMD_TCM_TXQ_INIT_IN_LABEL_OFST 4
+#define       MC_CMD_TCM_TXQ_INIT_IN_PQ_FLAGS_OFST 8
+#define       MC_CMD_TCM_TXQ_INIT_IN_RP_BKT_OFST 12
+#define       MC_CMD_TCM_TXQ_INIT_IN_MAX_BKT1_OFST 16
+#define       MC_CMD_TCM_TXQ_INIT_IN_MAX_BKT2_OFST 20
+#define       MC_CMD_TCM_TXQ_INIT_IN_MIN_BKT_OFST 24
+
+/* MC_CMD_TCM_TXQ_INIT_OUT msgresponse */
+#define    MC_CMD_TCM_TXQ_INIT_OUT_LEN 0
+
+
+#endif /* MCDI_PCOL_H */
diff -r 9566a4a50a43 drivers/net/sfc/mcdi_phy.c
--- /dev/null
+++ b/drivers/net/sfc/mcdi_phy.c
@@ -0,0 +1,794 @@
+/****************************************************************************
+ * Driver for Solarflare Solarstorm network controllers and boards
+ * Copyright 2009-2010 Solarflare Communications Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 as published
+ * by the Free Software Foundation, incorporated herein by reference.
+ */
+
+/*
+ * Driver for PHY related operations via MCDI.
+ */
+
+#include <linux/slab.h>
+#include <linux/seq_file.h>
+#include "efx.h"
+#include "debugfs.h"
+#include "phy.h"
+#include "mcdi.h"
+#include "mcdi_pcol.h"
+#include "nic.h"
+#include "selftest.h"
+
+struct efx_mcdi_phy_data {
+	u32 flags;
+	u32 type;
+	u32 supported_cap;
+	u32 channel;
+	u32 port;
+	u32 stats_mask;
+	u8 name[20];
+	u32 media;
+	u32 mmd_mask;
+	u8 revision[20];
+};
+
+
+static int
+efx_mcdi_get_phy_cfg(struct efx_nic *efx, struct efx_mcdi_phy_data *cfg)
+{
+	u8 outbuf[MC_CMD_GET_PHY_CFG_OUT_LEN];
+	size_t outlen;
+	int rc;
+
+	BUILD_BUG_ON(MC_CMD_GET_PHY_CFG_IN_LEN != 0);
+	BUILD_BUG_ON(MC_CMD_GET_PHY_CFG_OUT_NAME_LEN != sizeof(cfg->name));
+
+	rc = efx_mcdi_rpc(efx, MC_CMD_GET_PHY_CFG, NULL, 0,
+			  outbuf, sizeof(outbuf), &outlen);
+	if (rc)
+		goto fail;
+
+	if (outlen < MC_CMD_GET_PHY_CFG_OUT_LEN) {
+		rc = -EIO;
+		goto fail;
+	}
+
+	cfg->flags = MCDI_DWORD(outbuf, GET_PHY_CFG_OUT_FLAGS);
+	cfg->type = MCDI_DWORD(outbuf, GET_PHY_CFG_OUT_TYPE);
+	cfg->supported_cap =
+		MCDI_DWORD(outbuf, GET_PHY_CFG_OUT_SUPPORTED_CAP);
+	cfg->channel = MCDI_DWORD(outbuf, GET_PHY_CFG_OUT_CHANNEL);
+	cfg->port = MCDI_DWORD(outbuf, GET_PHY_CFG_OUT_PRT);
+	cfg->stats_mask = MCDI_DWORD(outbuf, GET_PHY_CFG_OUT_STATS_MASK);
+	memcpy(cfg->name, MCDI_PTR(outbuf, GET_PHY_CFG_OUT_NAME),
+	       sizeof(cfg->name));
+	cfg->media = MCDI_DWORD(outbuf, GET_PHY_CFG_OUT_MEDIA_TYPE);
+	cfg->mmd_mask = MCDI_DWORD(outbuf, GET_PHY_CFG_OUT_MMD_MASK);
+	memcpy(cfg->revision, MCDI_PTR(outbuf, GET_PHY_CFG_OUT_REVISION),
+	       sizeof(cfg->revision));
+
+	return 0;
+
+fail:
+	netif_err(efx, hw, efx->net_dev, "%s: failed rc=%d\n", __func__, rc);
+	return rc;
+}
+
+static int efx_mcdi_set_link(struct efx_nic *efx, u32 capabilities,
+			     u32 flags, u32 loopback_mode,
+			     u32 loopback_speed)
+{
+	u8 inbuf[MC_CMD_SET_LINK_IN_LEN];
+	int rc;
+
+	BUILD_BUG_ON(MC_CMD_SET_LINK_OUT_LEN != 0);
+
+	MCDI_SET_DWORD(inbuf, SET_LINK_IN_CAP, capabilities);
+	MCDI_SET_DWORD(inbuf, SET_LINK_IN_FLAGS, flags);
+	MCDI_SET_DWORD(inbuf, SET_LINK_IN_LOOPBACK_MODE, loopback_mode);
+	MCDI_SET_DWORD(inbuf, SET_LINK_IN_LOOPBACK_SPEED, loopback_speed);
+
+	rc = efx_mcdi_rpc(efx, MC_CMD_SET_LINK, inbuf, sizeof(inbuf),
+			  NULL, 0, NULL);
+	if (rc)
+		goto fail;
+
+	return 0;
+
+fail:
+	netif_err(efx, hw, efx->net_dev, "%s: failed rc=%d\n", __func__, rc);
+	return rc;
+}
+
+static int efx_mcdi_loopback_modes(struct efx_nic *efx, u64 *loopback_modes)
+{
+	u8 outbuf[MC_CMD_GET_LOOPBACK_MODES_OUT_LEN];
+	size_t outlen;
+	int rc;
+
+	rc = efx_mcdi_rpc(efx, MC_CMD_GET_LOOPBACK_MODES, NULL, 0,
+			  outbuf, sizeof(outbuf), &outlen);
+	if (rc)
+		goto fail;
+
+	if (outlen < MC_CMD_GET_LOOPBACK_MODES_OUT_LEN) {
+		rc = -EIO;
+		goto fail;
+	}
+
+	*loopback_modes = MCDI_QWORD(outbuf, 
+				     GET_LOOPBACK_MODES_OUT_SUGGESTED);
+
+	return 0;
+
+fail:
+	netif_err(efx, hw, efx->net_dev, "%s: failed rc=%d\n", __func__, rc);
+	return rc;
+}
+
+int efx_mcdi_mdio_read(struct efx_nic *efx, unsigned int bus,
+			 unsigned int prtad, unsigned int devad, u16 addr,
+			 u16 *value_out, u32 *status_out)
+{
+	u8 inbuf[MC_CMD_MDIO_READ_IN_LEN];
+	u8 outbuf[MC_CMD_MDIO_READ_OUT_LEN];
+	size_t outlen;
+	int rc;
+
+	MCDI_SET_DWORD(inbuf, MDIO_READ_IN_BUS, bus);
+	MCDI_SET_DWORD(inbuf, MDIO_READ_IN_PRTAD, prtad);
+	MCDI_SET_DWORD(inbuf, MDIO_READ_IN_DEVAD, devad);
+	MCDI_SET_DWORD(inbuf, MDIO_READ_IN_ADDR, addr);
+
+	rc = efx_mcdi_rpc(efx, MC_CMD_MDIO_READ, inbuf, sizeof(inbuf),
+			  outbuf, sizeof(outbuf), &outlen);
+	if (rc)
+		goto fail;
+
+	*value_out = (u16)MCDI_DWORD(outbuf, MDIO_READ_OUT_VALUE);
+	*status_out = MCDI_DWORD(outbuf, MDIO_READ_OUT_STATUS);
+	return 0;
+
+fail:
+	netif_err(efx, hw, efx->net_dev, "%s: failed rc=%d\n", __func__, rc);
+	return rc;
+}
+
+int efx_mcdi_mdio_write(struct efx_nic *efx, unsigned int bus,
+			  unsigned int prtad, unsigned int devad, u16 addr,
+			  u16 value, u32 *status_out)
+{
+	u8 inbuf[MC_CMD_MDIO_WRITE_IN_LEN];
+	u8 outbuf[MC_CMD_MDIO_WRITE_OUT_LEN];
+	size_t outlen;
+	int rc;
+
+	MCDI_SET_DWORD(inbuf, MDIO_WRITE_IN_BUS, bus);
+	MCDI_SET_DWORD(inbuf, MDIO_WRITE_IN_PRTAD, prtad);
+	MCDI_SET_DWORD(inbuf, MDIO_WRITE_IN_DEVAD, devad);
+	MCDI_SET_DWORD(inbuf, MDIO_WRITE_IN_ADDR, addr);
+	MCDI_SET_DWORD(inbuf, MDIO_WRITE_IN_VALUE, value);
+
+	rc = efx_mcdi_rpc(efx, MC_CMD_MDIO_WRITE, inbuf, sizeof(inbuf),
+			  outbuf, sizeof(outbuf), &outlen);
+	if (rc)
+		goto fail;
+
+	*status_out = MCDI_DWORD(outbuf, MDIO_WRITE_OUT_STATUS);
+	return 0;
+
+fail:
+	netif_err(efx, hw, efx->net_dev, "%s: failed rc=%d\n", __func__, rc);
+	return rc;
+}
+
+static u32 mcdi_to_ethtool_cap(u32 media, u32 cap)
+{
+	u32 result = 0;
+
+	switch (media) {
+	case MC_CMD_MEDIA_KX4:
+		result |= SUPPORTED_Backplane;
+		if (cap & (1 << MC_CMD_PHY_CAP_1000FDX_LBN))
+			result |= SUPPORTED_1000baseKX_Full;
+		if (cap & (1 << MC_CMD_PHY_CAP_10000FDX_LBN))
+			result |= SUPPORTED_10000baseKX4_Full;
+		break;
+
+	case MC_CMD_MEDIA_XFP:
+	case MC_CMD_MEDIA_SFP_PLUS:
+		result |= SUPPORTED_FIBRE;
+		if (cap & (1 << MC_CMD_PHY_CAP_1000FDX_LBN))
+			result |= SUPPORTED_1000baseT_Full;
+		if (cap & (1 << MC_CMD_PHY_CAP_10000FDX_LBN))
+			result |= SUPPORTED_10000baseT_Full;	
+		break;
+
+	case MC_CMD_MEDIA_BASE_T:
+		result |= SUPPORTED_TP;
+		if (cap & (1 << MC_CMD_PHY_CAP_10HDX_LBN))
+			result |= SUPPORTED_10baseT_Half;
+		if (cap & (1 << MC_CMD_PHY_CAP_10FDX_LBN))
+			result |= SUPPORTED_10baseT_Full;
+		if (cap & (1 << MC_CMD_PHY_CAP_100HDX_LBN))
+			result |= SUPPORTED_100baseT_Half;
+		if (cap & (1 << MC_CMD_PHY_CAP_100FDX_LBN))
+			result |= SUPPORTED_100baseT_Full;
+		if (cap & (1 << MC_CMD_PHY_CAP_1000HDX_LBN))
+			result |= SUPPORTED_1000baseT_Half;
+		if (cap & (1 << MC_CMD_PHY_CAP_1000FDX_LBN))
+			result |= SUPPORTED_1000baseT_Full;
+		if (cap & (1 << MC_CMD_PHY_CAP_10000FDX_LBN))
+			result |= SUPPORTED_10000baseT_Full;
+		break;
+	}
+
+	if (cap & (1 << MC_CMD_PHY_CAP_PAUSE_LBN))
+		result |= SUPPORTED_Pause;
+	if (cap & (1 << MC_CMD_PHY_CAP_ASYM_LBN))
+		result |= SUPPORTED_Asym_Pause;
+	if (cap & (1 << MC_CMD_PHY_CAP_AN_LBN))
+		result |= SUPPORTED_Autoneg;
+
+	return result;
+}
+
+static u32 ethtool_to_mcdi_cap(u32 cap)
+{
+	u32 result = 0;
+
+	if (cap & SUPPORTED_10baseT_Half)
+		result |= (1 << MC_CMD_PHY_CAP_10HDX_LBN);
+	if (cap & SUPPORTED_10baseT_Full)
+		result |= (1 << MC_CMD_PHY_CAP_10FDX_LBN);
+	if (cap & SUPPORTED_100baseT_Half)
+		result |= (1 << MC_CMD_PHY_CAP_100HDX_LBN);
+	if (cap & SUPPORTED_100baseT_Full)
+		result |= (1 << MC_CMD_PHY_CAP_100FDX_LBN);
+	if (cap & SUPPORTED_1000baseT_Half)
+		result |= (1 << MC_CMD_PHY_CAP_1000HDX_LBN);
+	if (cap & (SUPPORTED_1000baseT_Full | SUPPORTED_1000baseKX_Full))
+		result |= (1 << MC_CMD_PHY_CAP_1000FDX_LBN);
+	if (cap & (SUPPORTED_10000baseT_Full | SUPPORTED_10000baseKX4_Full))
+		result |= (1 << MC_CMD_PHY_CAP_10000FDX_LBN);
+	if (cap & SUPPORTED_Pause)
+		result |= (1 << MC_CMD_PHY_CAP_PAUSE_LBN);
+	if (cap & SUPPORTED_Asym_Pause)
+		result |= (1 << MC_CMD_PHY_CAP_ASYM_LBN);
+	if (cap & SUPPORTED_Autoneg)
+		result |= (1 << MC_CMD_PHY_CAP_AN_LBN);
+
+	return result;
+}
+
+static u32 efx_get_mcdi_phy_flags(struct efx_nic *efx)
+{
+	struct efx_mcdi_phy_data *phy_cfg = efx->phy_data;
+	enum efx_phy_mode mode, supported;
+	u32 flags;
+
+	/* TODO: Advertise the capabilities supported by this PHY */
+	supported = 0;
+	if (phy_cfg->flags & (1 << MC_CMD_GET_PHY_CFG_OUT_TXDIS_LBN))
+		supported |= PHY_MODE_TX_DISABLED;
+	if (phy_cfg->flags & (1 << MC_CMD_GET_PHY_CFG_OUT_LOWPOWER_LBN))
+		supported |= PHY_MODE_LOW_POWER;
+	if (phy_cfg->flags & (1 << MC_CMD_GET_PHY_CFG_OUT_POWEROFF_LBN))
+		supported |= PHY_MODE_OFF;
+
+	mode = efx->phy_mode & supported;
+
+	flags = 0;
+	if (mode & PHY_MODE_TX_DISABLED)
+		flags |= (1 << MC_CMD_SET_LINK_IN_TXDIS_LBN);
+	if (mode & PHY_MODE_LOW_POWER)
+		flags |= (1 << MC_CMD_SET_LINK_IN_LOWPOWER_LBN);
+	if (mode & PHY_MODE_OFF)
+		flags |= (1 << MC_CMD_SET_LINK_IN_POWEROFF_LBN);
+
+	return flags;
+}
+
+static u32 mcdi_to_ethtool_media(u32 media)
+{
+	switch (media) {
+	case MC_CMD_MEDIA_XAUI:
+	case MC_CMD_MEDIA_CX4:
+	case MC_CMD_MEDIA_KX4:
+		return PORT_OTHER;
+
+	case MC_CMD_MEDIA_XFP:
+	case MC_CMD_MEDIA_SFP_PLUS:
+		return PORT_FIBRE;
+
+	case MC_CMD_MEDIA_BASE_T:
+		return PORT_TP;
+
+	default:
+		return PORT_OTHER;
+	}
+}
+
+static int efx_mcdi_phy_probe(struct efx_nic *efx)
+{
+	struct efx_mcdi_phy_data *phy_data;
+	u8 outbuf[MC_CMD_GET_LINK_OUT_LEN];
+	u32 caps;
+	int rc;
+
+	/* Initialise and populate phy_data */
+	phy_data = kzalloc(sizeof(*phy_data), GFP_KERNEL);
+	if (phy_data == NULL)
+		return -ENOMEM;
+
+	rc = efx_mcdi_get_phy_cfg(efx, phy_data);
+	if (rc != 0)
+		goto fail;
+
+	/* Read initial link advertisement */
+	BUILD_BUG_ON(MC_CMD_GET_LINK_IN_LEN != 0);
+	rc = efx_mcdi_rpc(efx, MC_CMD_GET_LINK, NULL, 0,
+			  outbuf, sizeof(outbuf), NULL);
+	if (rc)
+		goto fail;
+
+	/* Fill out nic state */
+	efx->phy_data = phy_data;
+	efx->phy_type = phy_data->type;
+	strlcpy(efx->phy_name, phy_data->name, sizeof(efx->phy_name));
+
+	efx->mdio_bus = phy_data->channel;
+	efx->mdio.prtad = phy_data->port;
+	efx->mdio.mmds = phy_data->mmd_mask & ~(1 << MC_CMD_MMD_CLAUSE22);
+	efx->mdio.mode_support = 0;
+	if (phy_data->mmd_mask & (1 << MC_CMD_MMD_CLAUSE22))
+		efx->mdio.mode_support |= MDIO_SUPPORTS_C22;
+	if (phy_data->mmd_mask & ~(1 << MC_CMD_MMD_CLAUSE22))
+		efx->mdio.mode_support |= MDIO_SUPPORTS_C45 | MDIO_EMULATE_C22;
+
+	caps = MCDI_DWORD(outbuf, GET_LINK_OUT_CAP);
+	efx->link_advertising = mcdi_to_ethtool_cap(phy_data->media, caps);
+
+	/* Assert that we can map efx -> mcdi loopback modes */
+	BUILD_BUG_ON(LOOPBACK_NONE != MC_CMD_LOOPBACK_NONE);
+	BUILD_BUG_ON(LOOPBACK_DATA != MC_CMD_LOOPBACK_DATA);
+	BUILD_BUG_ON(LOOPBACK_GMAC != MC_CMD_LOOPBACK_GMAC);
+	BUILD_BUG_ON(LOOPBACK_XGMII != MC_CMD_LOOPBACK_XGMII);
+	BUILD_BUG_ON(LOOPBACK_XGXS != MC_CMD_LOOPBACK_XGXS);
+	BUILD_BUG_ON(LOOPBACK_XAUI != MC_CMD_LOOPBACK_XAUI);
+	BUILD_BUG_ON(LOOPBACK_GMII != MC_CMD_LOOPBACK_GMII);
+	BUILD_BUG_ON(LOOPBACK_SGMII != MC_CMD_LOOPBACK_SGMII);
+	BUILD_BUG_ON(LOOPBACK_XGBR != MC_CMD_LOOPBACK_XGBR);
+	BUILD_BUG_ON(LOOPBACK_XFI != MC_CMD_LOOPBACK_XFI);
+	BUILD_BUG_ON(LOOPBACK_XAUI_FAR != MC_CMD_LOOPBACK_XAUI_FAR);
+	BUILD_BUG_ON(LOOPBACK_GMII_FAR != MC_CMD_LOOPBACK_GMII_FAR);
+	BUILD_BUG_ON(LOOPBACK_SGMII_FAR != MC_CMD_LOOPBACK_SGMII_FAR);
+	BUILD_BUG_ON(LOOPBACK_XFI_FAR != MC_CMD_LOOPBACK_XFI_FAR);
+	BUILD_BUG_ON(LOOPBACK_GPHY != MC_CMD_LOOPBACK_GPHY);
+	BUILD_BUG_ON(LOOPBACK_PHYXS != MC_CMD_LOOPBACK_PHYXS);
+	BUILD_BUG_ON(LOOPBACK_PCS != MC_CMD_LOOPBACK_PCS);
+	BUILD_BUG_ON(LOOPBACK_PMAPMD != MC_CMD_LOOPBACK_PMAPMD);
+	BUILD_BUG_ON(LOOPBACK_XPORT != MC_CMD_LOOPBACK_XPORT);
+	BUILD_BUG_ON(LOOPBACK_XGMII_WS != MC_CMD_LOOPBACK_XGMII_WS);
+	BUILD_BUG_ON(LOOPBACK_XAUI_WS != MC_CMD_LOOPBACK_XAUI_WS);
+	BUILD_BUG_ON(LOOPBACK_XAUI_WS_FAR != MC_CMD_LOOPBACK_XAUI_WS_FAR);
+	BUILD_BUG_ON(LOOPBACK_XAUI_WS_NEAR != MC_CMD_LOOPBACK_XAUI_WS_NEAR);
+	BUILD_BUG_ON(LOOPBACK_GMII_WS != MC_CMD_LOOPBACK_GMII_WS);
+	BUILD_BUG_ON(LOOPBACK_XFI_WS != MC_CMD_LOOPBACK_XFI_WS);
+	BUILD_BUG_ON(LOOPBACK_XFI_WS_FAR != MC_CMD_LOOPBACK_XFI_WS_FAR);
+	BUILD_BUG_ON(LOOPBACK_PHYXS_WS != MC_CMD_LOOPBACK_PHYXS_WS);
+
+	rc = efx_mcdi_loopback_modes(efx, &efx->loopback_modes);
+	if (rc != 0)
+		goto fail;
+	/* The MC indicates that LOOPBACK_NONE is a valid loopback mode,
+	 * but by convention we don't */
+	efx->loopback_modes &= ~(1 << LOOPBACK_NONE);
+	efx->startup_loopback_mode = __ffs(efx->loopback_modes);
+
+	/* Set the initial link mode */
+	efx_mcdi_phy_decode_link(
+		efx, &efx->link_state,
+		MCDI_DWORD(outbuf, GET_LINK_OUT_LINK_SPEED),
+		MCDI_DWORD(outbuf, GET_LINK_OUT_FLAGS),
+		MCDI_DWORD(outbuf, GET_LINK_OUT_FCNTL));
+
+	/* Default to Autonegotiated flow control if the PHY supports it */
+	efx->wanted_fc = EFX_FC_RX | EFX_FC_TX;
+	if (phy_data->supported_cap & (1 << MC_CMD_PHY_CAP_AN_LBN))
+		efx->wanted_fc |= EFX_FC_AUTO;
+	efx_link_set_wanted_fc(efx, efx->wanted_fc);
+
+	return 0;
+
+fail:
+	kfree(phy_data);
+	return rc;
+}
+
+int efx_mcdi_phy_reconfigure(struct efx_nic *efx)
+{
+	u32 caps = ethtool_to_mcdi_cap(efx->link_advertising);
+
+	return efx_mcdi_set_link(efx, caps, efx_get_mcdi_phy_flags(efx),
+				 efx->loopback_mode, 0);
+}
+
+void efx_mcdi_phy_decode_link(struct efx_nic *efx,
+			      struct efx_link_state *link_state,
+			      u32 speed, u32 flags, u32 fcntl)
+{
+	switch (fcntl) {
+	case MC_CMD_FCNTL_AUTO:
+		WARN_ON(1);	/* This is not a link mode */
+		link_state->fc = EFX_FC_AUTO | EFX_FC_TX | EFX_FC_RX;
+		break;
+	case MC_CMD_FCNTL_BIDIR:
+		link_state->fc = EFX_FC_TX | EFX_FC_RX;
+		break;
+	case MC_CMD_FCNTL_RESPOND:
+		link_state->fc = EFX_FC_RX;
+		break;
+	default:
+		WARN_ON(1);
+	case MC_CMD_FCNTL_OFF:
+		link_state->fc = 0;
+		break;
+	}
+
+	link_state->up = !!(flags & (1 << MC_CMD_GET_LINK_OUT_LINK_UP_LBN));
+	link_state->fd = !!(flags & (1 << MC_CMD_GET_LINK_OUT_FULL_DUPLEX_LBN));
+	link_state->speed = speed;
+}
+
+/* Verify that the forced flow control settings (!EFX_FC_AUTO) are
+ * supported by the link partner. Warn the user if this isn't the case
+ */
+void efx_mcdi_phy_check_fcntl(struct efx_nic *efx, u32 lpa)
+{
+	struct efx_mcdi_phy_data *phy_cfg = efx->phy_data;
+	u32 rmtadv;
+
+	/* The link partner capabilities are only relevant if the
+	 * link supports flow control autonegotiation */
+	if (~phy_cfg->supported_cap & (1 << MC_CMD_PHY_CAP_AN_LBN))
+		return;
+
+	/* If flow control autoneg is supported and enabled, then fine */
+	if (efx->wanted_fc & EFX_FC_AUTO)
+		return;
+
+	rmtadv = 0;
+	if (lpa & (1 << MC_CMD_PHY_CAP_PAUSE_LBN))
+		rmtadv |= ADVERTISED_Pause;
+	if (lpa & (1 << MC_CMD_PHY_CAP_ASYM_LBN))
+		rmtadv |=  ADVERTISED_Asym_Pause;
+
+	if ((efx->wanted_fc & EFX_FC_TX) && rmtadv == ADVERTISED_Asym_Pause)
+		netif_err(efx, link, efx->net_dev,
+			  "warning: link partner doesn't support pause frames");
+}
+
+static bool efx_mcdi_phy_poll(struct efx_nic *efx)
+{
+	struct efx_link_state old_state = efx->link_state;
+	u8 outbuf[MC_CMD_GET_LINK_OUT_LEN];
+	int rc;
+
+	WARN_ON(!mutex_is_locked(&efx->mac_lock));
+
+	BUILD_BUG_ON(MC_CMD_GET_LINK_IN_LEN != 0);
+
+	rc = efx_mcdi_rpc(efx, MC_CMD_GET_LINK, NULL, 0,
+			  outbuf, sizeof(outbuf), NULL);
+	if (rc) {
+		netif_err(efx, hw, efx->net_dev, "%s: failed rc=%d\n",
+			  __func__, rc);
+		efx->link_state.up = false;
+	} else {
+		efx_mcdi_phy_decode_link(
+			efx, &efx->link_state,
+			MCDI_DWORD(outbuf, GET_LINK_OUT_LINK_SPEED),
+			MCDI_DWORD(outbuf, GET_LINK_OUT_FLAGS),
+			MCDI_DWORD(outbuf, GET_LINK_OUT_FCNTL));
+	}
+
+	return !efx_link_state_equal(&efx->link_state, &old_state);
+}
+
+static void efx_mcdi_phy_remove(struct efx_nic *efx)
+{
+	struct efx_mcdi_phy_data *phy_data = efx->phy_data;
+
+	efx->phy_data = NULL;
+	kfree(phy_data);
+}
+
+static void efx_mcdi_phy_get_settings(struct efx_nic *efx, struct ethtool_cmd *ecmd)
+{
+	struct efx_mcdi_phy_data *phy_cfg = efx->phy_data;
+	u8 outbuf[MC_CMD_GET_LINK_OUT_LEN];
+	int rc;
+
+	ecmd->supported =
+		mcdi_to_ethtool_cap(phy_cfg->media, phy_cfg->supported_cap);
+	ecmd->advertising = efx->link_advertising;
+	ethtool_cmd_speed_set(ecmd, efx->link_state.speed);
+	ecmd->duplex = efx->link_state.fd;
+	ecmd->port = mcdi_to_ethtool_media(phy_cfg->media);
+	ecmd->phy_address = phy_cfg->port;
+	ecmd->transceiver = XCVR_INTERNAL;
+	ecmd->autoneg = !!(efx->link_advertising & ADVERTISED_Autoneg);
+	ecmd->mdio_support = (efx->mdio.mode_support &
+			      (MDIO_SUPPORTS_C45 | MDIO_SUPPORTS_C22));
+
+	BUILD_BUG_ON(MC_CMD_GET_LINK_IN_LEN != 0);
+	rc = efx_mcdi_rpc(efx, MC_CMD_GET_LINK, NULL, 0,
+			  outbuf, sizeof(outbuf), NULL);
+	if (rc) {
+		netif_err(efx, hw, efx->net_dev, "%s: failed rc=%d\n",
+			  __func__, rc);
+		return;
+	}
+	ecmd->lp_advertising =
+		mcdi_to_ethtool_cap(phy_cfg->media,
+				    MCDI_DWORD(outbuf, GET_LINK_OUT_LP_CAP));
+}
+
+static int efx_mcdi_phy_set_settings(struct efx_nic *efx, struct ethtool_cmd *ecmd)
+{
+	struct efx_mcdi_phy_data *phy_cfg = efx->phy_data;
+	unsigned advertising = ecmd->advertising;
+	bool autoneg = !!(efx->link_advertising & ADVERTISED_Autoneg);
+	u32 caps;
+	int rc;
+
+	/* Remove flow control settings that the MAC supports
+	 * but that the PHY can't advertise. */
+	if (~phy_cfg->supported_cap & (1 << MC_CMD_PHY_CAP_PAUSE_LBN))
+		advertising &= ~ADVERTISED_Pause;
+	if (~phy_cfg->supported_cap & (1 << MC_CMD_PHY_CAP_ASYM_LBN))
+		advertising &= ~ADVERTISED_Asym_Pause;
+
+	if (advertising != efx->link_advertising) {
+		caps = ethtool_to_mcdi_cap(advertising);
+	} else if (ecmd->speed == efx->link_state.speed &&
+		   ecmd->duplex == efx->link_state.fd &&
+		   !!ecmd->autoneg == autoneg) {
+		/* ecmd->advertising is unchanged. Don't change the advertised
+		 * capabilities unless speed/duplex/fd has changed. */
+		return 0;
+	} else if (ecmd->duplex) {
+		switch (ethtool_cmd_speed(ecmd)) {
+		case 10:    caps = 1 << MC_CMD_PHY_CAP_10FDX_LBN;    break;
+		case 100:   caps = 1 << MC_CMD_PHY_CAP_100FDX_LBN;   break;
+		case 1000:  caps = 1 << MC_CMD_PHY_CAP_1000FDX_LBN;  break;
+		case 10000: caps = 1 << MC_CMD_PHY_CAP_10000FDX_LBN; break;
+		default:    return -EINVAL;
+		}
+	} else {
+		switch (ethtool_cmd_speed(ecmd)) {
+		case 10:    caps = 1 << MC_CMD_PHY_CAP_10HDX_LBN;    break;
+		case 100:   caps = 1 << MC_CMD_PHY_CAP_100HDX_LBN;   break;
+		case 1000:  caps = 1 << MC_CMD_PHY_CAP_1000HDX_LBN;  break;
+		default:    return -EINVAL;
+		}
+	}
+
+	caps &= ~(1 << MC_CMD_PHY_CAP_AN_LBN);
+	if (ecmd->autoneg) {
+		caps |= 1 << MC_CMD_PHY_CAP_AN_LBN;
+		/* Override the flow control advertised capabilities since
+		 * ethtool never populates them correctly. Unfortunately
+		 * this means that "ethtool advertising" can't be used to
+		 * adjust the flow control capabilities. */
+		if (efx->wanted_fc & EFX_FC_RX)
+			caps |= ((1 << MC_CMD_PHY_CAP_PAUSE_LBN) |
+				 (1 << MC_CMD_PHY_CAP_ASYM_LBN));
+		if (efx->wanted_fc & EFX_FC_TX)
+			caps ^= (1 << MC_CMD_PHY_CAP_ASYM_LBN);
+	}
+
+	rc = efx_mcdi_set_link(efx, caps, efx_get_mcdi_phy_flags(efx),
+			       efx->loopback_mode, 0);
+	if (rc) {
+		if (rc == -EINVAL)
+			netif_err(efx, link, efx->net_dev,
+				  "invalid link settings: autoneg=%u"
+				  " advertising=%#x speed=%u duplex=%u"
+				  " translated to caps=%#x\n",
+				  ecmd->autoneg, ecmd->advertising,
+				  ecmd->speed, ecmd->duplex, caps);
+		return rc;
+	}
+
+	/* Rather than storing the original advertising mask, we
+	 * convert the capabilities we're actually using back to an
+	 * advertising mask so that (1) get_settings() will report
+	 * correct information (2) we can push the capabilities again
+	 * after an MC reset.
+	 */
+	efx_link_set_advertising(efx,
+				 mcdi_to_ethtool_cap(phy_cfg->media, caps));
+
+	return 0;
+}
+
+static int efx_mcdi_phy_test_alive(struct efx_nic *efx)
+{
+	u8 outbuf[MC_CMD_GET_PHY_STATE_OUT_LEN];
+	size_t outlen;
+	int rc;
+
+	BUILD_BUG_ON(MC_CMD_GET_PHY_STATE_IN_LEN != 0);
+
+	rc = efx_mcdi_rpc(efx, MC_CMD_GET_PHY_STATE, NULL, 0,
+			  outbuf, sizeof(outbuf), &outlen);
+	if (rc)
+		return rc;
+
+	if (outlen < MC_CMD_GET_PHY_STATE_OUT_LEN)
+		return -EIO;
+	if (MCDI_DWORD(outbuf, GET_PHY_STATE_OUT_STATE) != 
+	    MC_CMD_PHY_STATE_OK)
+		return -EINVAL;
+
+	return 0;
+}
+
+static const char *const mcdi_sft9001_cable_diag_names[] = {
+	"cable.pairA.length",
+	"cable.pairB.length",
+	"cable.pairC.length",
+	"cable.pairD.length",
+	"cable.pairA.status",
+	"cable.pairB.status",
+	"cable.pairC.status",
+	"cable.pairD.status",
+};
+
+static int efx_mcdi_bist(struct efx_nic *efx, unsigned int bist_mode,
+			 int *results)
+{
+	unsigned int retry, i, count = 0;
+	size_t outlen;
+	u32 status;
+	u8 *buf, *ptr;
+	int rc;
+
+	buf = kzalloc(0x100, GFP_KERNEL);
+	if (buf == NULL)
+		return -ENOMEM;
+
+	BUILD_BUG_ON(MC_CMD_START_BIST_OUT_LEN != 0);
+	MCDI_SET_DWORD(buf, START_BIST_IN_TYPE, bist_mode);
+	rc = efx_mcdi_rpc(efx, MC_CMD_START_BIST, buf, MC_CMD_START_BIST_IN_LEN,
+			  NULL, 0, NULL);
+	if (rc)
+		goto out;
+
+	/* Wait up to 10s for BIST to finish */
+	for( retry = 0; retry < 100; ++retry) {
+		BUILD_BUG_ON(MC_CMD_POLL_BIST_IN_LEN != 0);
+		rc = efx_mcdi_rpc(efx, MC_CMD_POLL_BIST, NULL, 0,
+				  buf, 0x100, &outlen);
+		if (rc)
+			goto out;
+
+		status = MCDI_DWORD(buf, POLL_BIST_OUT_RESULT);
+		if (status != MC_CMD_POLL_BIST_RUNNING)
+			goto finished;
+
+		msleep(100);
+	}
+
+	rc = -ETIMEDOUT;
+	goto out;
+
+finished:
+	results[count++] = (status == MC_CMD_POLL_BIST_PASSED) ? 1 : -1;
+
+	/* SFT9001 specific cable diagnostics output */
+	if (efx->phy_type == PHY_TYPE_SFT9001B &&
+	    (bist_mode == MC_CMD_PHY_BIST_CABLE_SHORT ||
+	     bist_mode == MC_CMD_PHY_BIST_CABLE_LONG)) {
+		ptr = MCDI_PTR(buf, POLL_BIST_OUT_SFT9001_CABLE_LENGTH_A);
+		if (status == MC_CMD_POLL_BIST_PASSED &&
+		    outlen >= MC_CMD_POLL_BIST_OUT_SFT9001_LEN) {
+			for (i = 0; i < 8; i++) {
+				results[count + i] =
+					EFX_DWORD_FIELD(((efx_dword_t *)ptr)[i],
+							EFX_DWORD_0);
+			}
+		}
+		count += 8;
+	}
+	rc = count;
+
+out:
+	kfree(buf);
+
+	return rc;
+}
+
+static int efx_mcdi_phy_run_tests(struct efx_nic *efx, int *results,
+				  unsigned flags)
+{
+	struct efx_mcdi_phy_data *phy_cfg = efx->phy_data;
+	u32 mode;
+	int rc;
+
+	if (phy_cfg->flags & (1 << MC_CMD_GET_PHY_CFG_OUT_BIST_LBN)) {
+		rc = efx_mcdi_bist(efx, MC_CMD_PHY_BIST, results);
+		if (rc < 0)
+			return rc;
+
+		results += rc;
+	}
+
+	/* If we support both LONG and SHORT, then run each in response to
+	 * break or not. Otherwise, run the one we support */
+	mode = 0;
+	if (phy_cfg->flags & (1 << MC_CMD_GET_PHY_CFG_OUT_BIST_CABLE_SHORT_LBN)) {
+		if ((flags & ETH_TEST_FL_OFFLINE) &&
+		    (phy_cfg->flags &
+		     (1 << MC_CMD_GET_PHY_CFG_OUT_BIST_CABLE_LONG_LBN)))
+			mode = MC_CMD_PHY_BIST_CABLE_LONG;
+		else
+			mode = MC_CMD_PHY_BIST_CABLE_SHORT;
+	} else if (phy_cfg->flags &
+		   (1 << MC_CMD_GET_PHY_CFG_OUT_BIST_CABLE_LONG_LBN))
+		mode = MC_CMD_PHY_BIST_CABLE_LONG;
+
+	if (mode != 0) {
+		rc = efx_mcdi_bist(efx, mode, results);
+		if (rc < 0)
+			return rc;
+		results += rc;
+	}	
+
+	return 0;
+}
+
+static const char *efx_mcdi_phy_test_name(struct efx_nic *efx,
+					  unsigned int index)
+{
+	struct efx_mcdi_phy_data *phy_cfg = efx->phy_data;
+
+	if (phy_cfg->flags & (1 << MC_CMD_GET_PHY_CFG_OUT_BIST_LBN)) {
+		if (index == 0)
+			return "bist";
+		--index;
+	}
+
+	if (phy_cfg->flags & ((1 << MC_CMD_GET_PHY_CFG_OUT_BIST_CABLE_SHORT_LBN) |
+			      (1 << MC_CMD_GET_PHY_CFG_OUT_BIST_CABLE_LONG_LBN))) {
+		if (index == 0)
+			return "cable";
+		--index;
+
+		if (efx->phy_type == PHY_TYPE_SFT9001B) {
+			if (index < ARRAY_SIZE(mcdi_sft9001_cable_diag_names))
+				return mcdi_sft9001_cable_diag_names[index];
+			index -= ARRAY_SIZE(mcdi_sft9001_cable_diag_names);
+		}
+	}
+
+	return NULL;
+}
+
+const struct efx_phy_operations efx_mcdi_phy_ops = {
+	.probe		= efx_mcdi_phy_probe,
+	.init 	 	= efx_port_dummy_op_int,
+	.reconfigure	= efx_mcdi_phy_reconfigure,
+	.poll		= efx_mcdi_phy_poll,
+	.fini		= efx_port_dummy_op_void,
+	.remove		= efx_mcdi_phy_remove,
+	.get_settings	= efx_mcdi_phy_get_settings,
+	.set_settings	= efx_mcdi_phy_set_settings,
+	.test_alive	= efx_mcdi_phy_test_alive,
+	.run_tests	= efx_mcdi_phy_run_tests,
+	.test_name	= efx_mcdi_phy_test_name,
+};
diff -r 9566a4a50a43 drivers/net/sfc/mdio_10g.c
--- a/drivers/net/sfc/mdio_10g.c
+++ b/drivers/net/sfc/mdio_10g.c
@@ -1,6 +1,6 @@
 /****************************************************************************
  * Driver for Solarflare Solarstorm network controllers and boards
- * Copyright 2006-2008 Solarflare Communications Inc.
+ * Copyright 2006-2011 Solarflare Communications Inc.
  *
  * This program is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 as published
@@ -14,9 +14,26 @@
 #include <linux/delay.h>
 #include "net_driver.h"
 #include "mdio_10g.h"
-#include "boards.h"
 #include "workarounds.h"
 
+static const char *mmd_block_names[] = {
+	[0]               = "(illegal)",
+	[MDIO_MMD_PMAPMD] = "PMA/PMD",
+	[MDIO_MMD_WIS]    = "WIS",
+	[MDIO_MMD_PCS]    = "PCS",
+	[MDIO_MMD_PHYXS]  = "PHY XS",
+	[MDIO_MMD_DTEXS]  = "DTE XS",
+	[MDIO_MMD_TC]     = "TC",
+	[MDIO_MMD_AN]     = "AN",
+	[MDIO_MMD_C22EXT] = "c22 ext",
+};
+static const int mmd_block_max = ARRAY_SIZE(mmd_block_names);
+
+const char *efx_mdio_mmd_name(int mmd)
+{
+	return STRING_TABLE_LOOKUP(mmd, mmd_block);
+}
+
 unsigned efx_mdio_id_oui(u32 id)
 {
 	unsigned oui = 0;
@@ -33,7 +50,7 @@ unsigned efx_mdio_id_oui(u32 id)
 }
 
 int efx_mdio_reset_mmd(struct efx_nic *port, int mmd,
-			    int spins, int spintime)
+		       int spins, int spintime)
 {
 	u32 ctrl;
 
@@ -52,34 +69,21 @@ int efx_mdio_reset_mmd(struct efx_nic *p
 	return spins ? spins : -ETIMEDOUT;
 }
 
-static int efx_mdio_check_mmd(struct efx_nic *efx, int mmd, int fault_fatal)
+static int efx_mdio_check_mmd(struct efx_nic *efx, int mmd)
 {
 	int status;
-
-	if (LOOPBACK_INTERNAL(efx))
-		return 0;
+	const char *mmdname = STRING_TABLE_LOOKUP(mmd, mmd_block);
 
 	if (mmd != MDIO_MMD_AN) {
 		/* Read MMD STATUS2 to check it is responding. */
 		status = efx_mdio_read(efx, mmd, MDIO_STAT2);
 		if ((status & MDIO_STAT2_DEVPRST) != MDIO_STAT2_DEVPRST_VAL) {
-			EFX_ERR(efx, "PHY MMD %d not responding.\n", mmd);
+			netif_err(efx, hw, efx->net_dev,
+				  "PHY MMD %s not responding.\n", mmdname);
 			return -EIO;
 		}
 	}
 
-	/* Read MMD STATUS 1 to check for fault. */
-	status = efx_mdio_read(efx, mmd, MDIO_STAT1);
-	if (status & MDIO_STAT1_FAULT) {
-		if (fault_fatal) {
-			EFX_ERR(efx, "PHY MMD %d reporting fatal"
-				" fault: status %x\n", mmd, status);
-			return -EIO;
-		} else {
-			EFX_LOG(efx, "PHY MMD %d reporting status"
-				" %x (expected)\n", mmd, status);
-		}
-	}
 	return 0;
 }
 
@@ -103,8 +107,11 @@ int efx_mdio_wait_reset_mmds(struct efx_
 			if (mask & 1) {
 				stat = efx_mdio_read(efx, mmd, MDIO_CTRL1);
 				if (stat < 0) {
-					EFX_ERR(efx, "failed to read status of"
-						" MMD %d\n", mmd);
+					netif_err(efx, hw, efx->net_dev,
+						  "failed to read status of"
+						  " MMD %s\n",
+						  STRING_TABLE_LOOKUP(
+							  mmd, mmd_block));
 					return -EIO;
 				}
 				if (stat & MDIO_CTRL1_RESET)
@@ -119,15 +126,19 @@ int efx_mdio_wait_reset_mmds(struct efx_
 		msleep(spintime);
 	}
 	if (in_reset != 0) {
-		EFX_ERR(efx, "not all MMDs came out of reset in time."
-			" MMDs still in reset: %x\n", in_reset);
+		netif_err(efx, hw, efx->net_dev,
+			  "not all MMDs came out of reset in time."
+			  " MMDs still in reset: %x\n", in_reset);
 		rc = -ETIMEDOUT;
 	}
+	else
+		netif_info(efx, hw, efx->net_dev,
+			   "mmds %x came out of reset in %d ms\n",
+			   mmd_mask, spintime * (MDIO45_RESET_ITERS - tries));
 	return rc;
 }
 
-int efx_mdio_check_mmds(struct efx_nic *efx,
-			unsigned int mmd_mask, unsigned int fatal_mask)
+int efx_mdio_check_mmds(struct efx_nic *efx, unsigned int mmd_mask)
 {
 	int mmd = 0, probe_mmd, devs1, devs2;
 	u32 devices;
@@ -142,26 +153,24 @@ int efx_mdio_check_mmds(struct efx_nic *
 	devs1 = efx_mdio_read(efx, probe_mmd, MDIO_DEVS1);
 	devs2 = efx_mdio_read(efx, probe_mmd, MDIO_DEVS2);
 	if (devs1 < 0 || devs2 < 0) {
-		EFX_ERR(efx, "failed to read devices present\n");
+		netif_err(efx, hw, efx->net_dev,
+			  "failed to read devices present\n");
 		return -EIO;
 	}
 	devices = devs1 | (devs2 << 16);
 	if ((devices & mmd_mask) != mmd_mask) {
-		EFX_ERR(efx, "required MMDs not present: got %x, "
-			"wanted %x\n", devices, mmd_mask);
+		netif_err(efx, hw, efx->net_dev,
+			  "required MMDs not present: got %x, wanted %x\n",
+			  devices, mmd_mask);
 		return -ENODEV;
 	}
-	EFX_TRACE(efx, "Devices present: %x\n", devices);
+	netif_vdbg(efx, hw, efx->net_dev, "Devices present: %x\n", devices);
 
 	/* Check all required MMDs are responding and happy. */
 	while (mmd_mask) {
-		if (mmd_mask & 1) {
-			int fault_fatal = fatal_mask & 1;
-			if (efx_mdio_check_mmd(efx, mmd, fault_fatal))
-				return -EIO;
-		}
+		if ((mmd_mask & 1) && efx_mdio_check_mmd(efx, mmd))
+			return -EIO;
 		mmd_mask = mmd_mask >> 1;
-		fatal_mask = fatal_mask >> 1;
 		mmd++;
 	}
 
@@ -170,11 +179,13 @@ int efx_mdio_check_mmds(struct efx_nic *
 
 bool efx_mdio_links_ok(struct efx_nic *efx, unsigned int mmd_mask)
 {
+	WARN_ON(LOOPBACK_INTERNAL(efx));
+
 	/* If the port is in loopback, then we should only consider a subset
 	 * of mmd's */
 	if (LOOPBACK_INTERNAL(efx))
 		return true;
-	else if (efx->loopback_mode == LOOPBACK_NETWORK)
+	else if ((1 << efx->loopback_mode) & LOOPBACKS_WS)
 		return false;
 	else if (efx_phy_mode_disabled(efx->phy_mode))
 		return false;
@@ -211,16 +222,19 @@ void efx_mdio_phy_reconfigure(struct efx
 			  efx->loopback_mode == LOOPBACK_PCS);
 	efx_mdio_set_flag(efx, MDIO_MMD_PHYXS,
 			  MDIO_CTRL1, MDIO_PHYXS_CTRL1_LOOPBACK,
-			  efx->loopback_mode == LOOPBACK_NETWORK);
+			  efx->loopback_mode == LOOPBACK_PHYXS_WS);
 }
 
 static void efx_mdio_set_mmd_lpower(struct efx_nic *efx,
 				    int lpower, int mmd)
 {
+	const char *mmdname __attribute__((unused)) =
+		STRING_TABLE_LOOKUP(mmd, mmd_block);
 	int stat = efx_mdio_read(efx, mmd, MDIO_STAT1);
 
-	EFX_TRACE(efx, "Setting low power mode for MMD %d to %d\n",
-		  mmd, lpower);
+	netif_vdbg(efx, hw, efx->net_dev,
+		   "Setting low power mode for MMD %s to %d\n",
+		   mmdname, lpower);
 
 	if (stat & MDIO_STAT1_LPOWERABLE) {
 		efx_mdio_set_flag(efx, mmd, MDIO_CTRL1,
@@ -248,14 +262,12 @@ void efx_mdio_set_mmds_lpower(struct efx
  */
 int efx_mdio_set_settings(struct efx_nic *efx, struct ethtool_cmd *ecmd)
 {
-	struct ethtool_cmd prev;
-	u32 required;
-	int reg;
+	struct ethtool_cmd prev = { .cmd = ETHTOOL_GSET };
 
 	efx->phy_op->get_settings(efx, &prev);
 
 	if (ecmd->advertising == prev.advertising &&
-	    ecmd->speed == prev.speed &&
+	    ethtool_cmd_speed(ecmd) == ethtool_cmd_speed(&prev) &&
 	    ecmd->duplex == prev.duplex &&
 	    ecmd->port == prev.port &&
 	    ecmd->autoneg == prev.autoneg)
@@ -266,86 +278,76 @@ int efx_mdio_set_settings(struct efx_nic
 		return -EINVAL;
 
 	/* Check that PHY supports these settings */
-	if (ecmd->autoneg) {
-		required = SUPPORTED_Autoneg;
-	} else if (ecmd->duplex) {
-		switch (ecmd->speed) {
-		case SPEED_10:  required = SUPPORTED_10baseT_Full;  break;
-		case SPEED_100: required = SUPPORTED_100baseT_Full; break;
-		default:        return -EINVAL;
-		}
-	} else {
-		switch (ecmd->speed) {
-		case SPEED_10:  required = SUPPORTED_10baseT_Half;  break;
-		case SPEED_100: required = SUPPORTED_100baseT_Half; break;
-		default:        return -EINVAL;
-		}
-	}
-	required |= ecmd->advertising;
-	if (required & ~prev.supported)
+	if (!ecmd->autoneg ||
+	    (ecmd->advertising | SUPPORTED_Autoneg) & ~prev.supported)
 		return -EINVAL;
 
-	if (ecmd->autoneg) {
-		bool xnp = (ecmd->advertising & ADVERTISED_10000baseT_Full
-			    || EFX_WORKAROUND_13204(efx));
+	efx_link_set_advertising(efx, ecmd->advertising | ADVERTISED_Autoneg);
+	efx_mdio_an_reconfigure(efx);
+	return 0;
+}
 
-		/* Set up the base page */
-		reg = ADVERTISE_CSMA;
-		if (ecmd->advertising & ADVERTISED_10baseT_Half)
-			reg |= ADVERTISE_10HALF;
-		if (ecmd->advertising & ADVERTISED_10baseT_Full)
-			reg |= ADVERTISE_10FULL;
-		if (ecmd->advertising & ADVERTISED_100baseT_Half)
-			reg |= ADVERTISE_100HALF;
-		if (ecmd->advertising & ADVERTISED_100baseT_Full)
-			reg |= ADVERTISE_100FULL;
-		if (xnp)
-			reg |= ADVERTISE_RESV;
-		else if (ecmd->advertising & (ADVERTISED_1000baseT_Half |
-					      ADVERTISED_1000baseT_Full))
-			reg |= ADVERTISE_NPAGE;
-		reg |= mii_advertise_flowctrl(efx->wanted_fc);
-		efx_mdio_write(efx, MDIO_MMD_AN, MDIO_AN_ADVERTISE, reg);
+/**
+ * efx_mdio_an_reconfigure - Push advertising flags and restart autonegotiation
+ * @efx:		Efx NIC
+ */
+void efx_mdio_an_reconfigure(struct efx_nic *efx)
+{
+	int reg;
 
-		/* Set up the (extended) next page if necessary */
-		if (efx->phy_op->set_npage_adv)
-			efx->phy_op->set_npage_adv(efx, ecmd->advertising);
+	WARN_ON(!(efx->mdio.mmds & MDIO_DEVS_AN));
 
-		/* Enable and restart AN */
-		reg = efx_mdio_read(efx, MDIO_MMD_AN, MDIO_CTRL1);
-		reg |= MDIO_AN_CTRL1_ENABLE;
-		if (!(EFX_WORKAROUND_15195(efx) &&
-		      LOOPBACK_MASK(efx) & efx->phy_op->loopbacks))
-			reg |= MDIO_AN_CTRL1_RESTART;
-		if (xnp)
-			reg |= MDIO_AN_CTRL1_XNP;
-		else
-			reg &= ~MDIO_AN_CTRL1_XNP;
-		efx_mdio_write(efx, MDIO_MMD_AN, MDIO_CTRL1, reg);
-	} else {
-		/* Disable AN */
-		efx_mdio_set_flag(efx, MDIO_MMD_AN, MDIO_CTRL1,
-				  MDIO_AN_CTRL1_ENABLE, false);
+	/* Set up the base page */
+	reg = ADVERTISE_CSMA | ADVERTISE_RESV;
+	if (efx->link_advertising & ADVERTISED_Pause)
+		reg |= ADVERTISE_PAUSE_CAP;
+	if (efx->link_advertising & ADVERTISED_Asym_Pause)
+		reg |= ADVERTISE_PAUSE_ASYM;
+	efx_mdio_write(efx, MDIO_MMD_AN, MDIO_AN_ADVERTISE, reg);
 
-		/* Set the basic control bits */
-		reg = efx_mdio_read(efx, MDIO_MMD_PMAPMD, MDIO_CTRL1);
-		reg &= ~(MDIO_CTRL1_SPEEDSEL | MDIO_CTRL1_FULLDPLX);
-		if (ecmd->speed == SPEED_100)
-			reg |= MDIO_PMA_CTRL1_SPEED100;
-		if (ecmd->duplex)
-			reg |= MDIO_CTRL1_FULLDPLX;
-		efx_mdio_write(efx, MDIO_MMD_PMAPMD, MDIO_CTRL1, reg);
-	}
+	/* Set up the (extended) next page */
+	efx->phy_op->set_npage_adv(efx, efx->link_advertising);
 
-	return 0;
+	/* Enable and restart AN */
+	reg = efx_mdio_read(efx, MDIO_MMD_AN, MDIO_CTRL1);
+	reg |= MDIO_AN_CTRL1_ENABLE | MDIO_AN_CTRL1_RESTART | MDIO_AN_CTRL1_XNP;
+	efx_mdio_write(efx, MDIO_MMD_AN, MDIO_CTRL1, reg);
 }
 
 enum efx_fc_type efx_mdio_get_pause(struct efx_nic *efx)
 {
-	int lpa;
+	BUILD_BUG_ON(EFX_FC_AUTO & (EFX_FC_RX | EFX_FC_TX));
 
-	if (!(efx->phy_op->mmds & MDIO_DEVS_AN))
+	if (!(efx->wanted_fc & EFX_FC_AUTO))
 		return efx->wanted_fc;
-	lpa = efx_mdio_read(efx, MDIO_MMD_AN, MDIO_AN_LPA);
-	return efx_fc_resolve(efx->wanted_fc, lpa);
+
+	WARN_ON(!(efx->mdio.mmds & MDIO_DEVS_AN));
+
+	return mii_resolve_flowctrl_fdx(
+		mii_advertise_flowctrl(efx->wanted_fc),
+		efx_mdio_read(efx, MDIO_MMD_AN, MDIO_AN_LPA));
 }
+
+int efx_mdio_test_alive(struct efx_nic *efx)
+{
+	int rc;
+	int devad = __ffs(efx->mdio.mmds);
+	u16 physid1, physid2;
+
+	mutex_lock(&efx->mac_lock);
+
+	physid1 = efx_mdio_read(efx, devad, MDIO_DEVID1);
+	physid2 = efx_mdio_read(efx, devad, MDIO_DEVID2);
+
+	if ((physid1 == 0x0000) || (physid1 == 0xffff) ||
+	    (physid2 == 0x0000) || (physid2 == 0xffff)) {
+		netif_err(efx, hw, efx->net_dev,
+			  "no MDIO PHY present with ID %d\n", efx->mdio.prtad);
+		rc = -EINVAL;
+	} else {
+		rc = efx_mdio_check_mmds(efx, efx->mdio.mmds);
+	}
+
+	mutex_unlock(&efx->mac_lock);
+	return rc;
+}
diff -r 9566a4a50a43 drivers/net/sfc/mdio_10g.h
--- a/drivers/net/sfc/mdio_10g.h
+++ b/drivers/net/sfc/mdio_10g.h
@@ -1,6 +1,6 @@
 /****************************************************************************
  * Driver for Solarflare Solarstorm network controllers and boards
- * Copyright 2006-2008 Solarflare Communications Inc.
+ * Copyright 2006-2011 Solarflare Communications Inc.
  *
  * This program is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 as published
@@ -10,14 +10,13 @@
 #ifndef EFX_MDIO_10G_H
 #define EFX_MDIO_10G_H
 
-#include <linux/mdio.h>
+#include "kernel_compat.h"
 
 /*
  * Helper functions for doing 10G MDIO as specified in IEEE 802.3 clause 45.
  */
 
 #include "efx.h"
-#include "boards.h"
 
 static inline unsigned efx_mdio_id_rev(u32 id) { return id & 0xf; }
 static inline unsigned efx_mdio_id_model(u32 id) { return (id >> 4) & 0x3f; }
@@ -52,7 +51,8 @@ static inline bool efx_mdio_phyxgxs_lane
 
 	sync = !!(lane_status & MDIO_PHYXS_LNSTAT_ALIGN);
 	if (!sync)
-		EFX_LOG(efx, "XGXS lane status: %x\n", lane_status);
+		netif_dbg(efx, hw, efx->net_dev, "XGXS lane status: %x\n",
+			  lane_status);
 	return sync;
 }
 
@@ -68,8 +68,7 @@ extern int efx_mdio_reset_mmd(struct efx
 			      int spins, int spintime);
 
 /* As efx_mdio_check_mmd but for multiple MMDs */
-int efx_mdio_check_mmds(struct efx_nic *efx,
-			unsigned int mmd_mask, unsigned int fatal_mask);
+int efx_mdio_check_mmds(struct efx_nic *efx, unsigned int mmd_mask);
 
 /* Check the link status of specified mmds in bit mask */
 extern bool efx_mdio_links_ok(struct efx_nic *efx, unsigned int mmd_mask);
@@ -87,6 +86,9 @@ extern void efx_mdio_set_mmds_lpower(str
 /* Set (some of) the PHY settings over MDIO */
 extern int efx_mdio_set_settings(struct efx_nic *efx, struct ethtool_cmd *ecmd);
 
+/* Push advertising flags and restart autonegotiation */
+extern void efx_mdio_an_reconfigure(struct efx_nic *efx);
+
 /* Get pause parameters from AN if available (otherwise return
  * requested pause parameters)
  */
@@ -104,4 +106,7 @@ efx_mdio_set_flag(struct efx_nic *efx, i
 	mdio_set_flag(&efx->mdio, efx->mdio.prtad, devad, addr, mask, state);
 }
 
+/* Liveness self-test for MDIO PHYs */
+extern int efx_mdio_test_alive(struct efx_nic *efx);
+
 #endif /* EFX_MDIO_10G_H */
diff -r 9566a4a50a43 drivers/net/sfc/mtd.c
--- a/drivers/net/sfc/mtd.c
+++ b/drivers/net/sfc/mtd.c
@@ -1,36 +1,109 @@
 /****************************************************************************
  * Driver for Solarflare Solarstorm network controllers and boards
  * Copyright 2005-2006 Fen Systems Ltd.
- * Copyright 2006-2008 Solarflare Communications Inc.
+ * Copyright 2006-2010 Solarflare Communications Inc.
  *
  * This program is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 as published
  * by the Free Software Foundation, incorporated herein by reference.
  */
 
+#include <linux/bitops.h>
 #include <linux/module.h>
+#undef DEBUG /* <linux/mtd/mtd.h> has its own use for DEBUG */
 #include <linux/mtd/mtd.h>
 #include <linux/delay.h>
+#include <linux/slab.h>
 
-#define EFX_DRIVER_NAME "sfc_mtd"
 #include "net_driver.h"
 #include "spi.h"
 #include "efx.h"
+#include "nic.h"
+#include "mcdi.h"
+#include "mcdi_pcol.h"
+
+/*
+ * MTD-specific kernel compatibility stuff goes here, not in
+ * kernel_compat.h, because inclusion of <linux/mtd/mtd.h> causes
+ * problems for other source files.
+ */
+
+	struct mtd_partition;
+
+	static inline int
+	mtd_device_register(struct mtd_info *master,
+			    const struct mtd_partition *parts,
+			    int nr_parts)
+	{
+		BUG_ON(parts);
+		return add_mtd_device(master);
+	}
+
+	static inline int mtd_device_unregister(struct mtd_info *master)
+	{
+		return del_mtd_device(master);
+	}
 
 #define EFX_SPI_VERIFY_BUF_LEN 16
 
-struct efx_mtd {
-	const struct efx_spi_device *spi;
+/* Some partitions should only be written during manufacturing.  Not
+ * only should they not be rewritten later, but exposing all of them
+ * can easily fill up the MTD table (16 or 32 entries).
+ */
+static unsigned int efx_allow_nvconfig_writes;
+
+struct efx_mtd_partition {
 	struct mtd_info mtd;
+	union {
+		struct {
+			bool updating;
+			u8 nvram_type;
+			u16 fw_subtype;
+		} mcdi;
+		size_t offset;
+	};
+	const char *type_name;
 	char name[IFNAMSIZ + 20];
 };
 
+struct efx_mtd_ops {
+	int (*read)(struct mtd_info *mtd, loff_t start, size_t len,
+		    size_t *retlen, u8 *buffer);
+	int (*erase)(struct mtd_info *mtd, loff_t start, size_t len);
+	int (*write)(struct mtd_info *mtd, loff_t start, size_t len,
+		     size_t *retlen, const u8 *buffer);
+	int (*sync)(struct mtd_info *mtd);
+};
+
+struct efx_mtd {
+	struct list_head node;
+	struct efx_nic *efx;
+	const struct efx_spi_device *spi;
+	const char *name;
+	const struct efx_mtd_ops *ops;
+	size_t n_parts;
+	struct efx_mtd_partition part[0];
+};
+
+#define efx_for_each_partition(part, efx_mtd)			\
+	for ((part) = &(efx_mtd)->part[0];			\
+	     (part) != &(efx_mtd)->part[(efx_mtd)->n_parts];	\
+	     (part)++)
+
+#define to_efx_mtd_partition(mtd)				\
+	container_of(mtd, struct efx_mtd_partition, mtd)
+
+static int falcon_mtd_probe(struct efx_nic *efx);
+static int siena_mtd_probe(struct efx_nic *efx);
+
 /* SPI utilities */
 
-static int efx_spi_slow_wait(struct efx_mtd *efx_mtd, bool uninterruptible)
+static int
+efx_spi_slow_wait(struct efx_mtd_partition *part, bool uninterruptible)
 {
+	struct efx_mtd *efx_mtd = part->mtd.priv;	
 	const struct efx_spi_device *spi = efx_mtd->spi;
-	struct efx_nic *efx = spi->efx;
+	struct efx_nic *efx = efx_mtd->efx;
 	u8 status;
 	int rc, i;
 
@@ -39,7 +112,7 @@ static int efx_spi_slow_wait(struct efx_
 		__set_current_state(uninterruptible ?
 				    TASK_UNINTERRUPTIBLE : TASK_INTERRUPTIBLE);
 		schedule_timeout(HZ / 10);
-		rc = falcon_spi_cmd(spi, SPI_RDSR, -1, NULL,
+		rc = falcon_spi_cmd(efx, spi, SPI_RDSR, -1, NULL,
 				    &status, sizeof(status));
 		if (rc)
 			return rc;
@@ -48,45 +121,51 @@ static int efx_spi_slow_wait(struct efx_
 		if (signal_pending(current))
 			return -EINTR;
 	}
-	EFX_ERR(efx, "timed out waiting for %s\n", efx_mtd->name);
+	pr_err("%s: timed out waiting for %s\n", part->name, efx_mtd->name);
 	return -ETIMEDOUT;
 }
 
-static int efx_spi_unlock(const struct efx_spi_device *spi)
+static int
+efx_spi_unlock(struct efx_nic *efx, const struct efx_spi_device *spi)
 {
 	const u8 unlock_mask = (SPI_STATUS_BP2 | SPI_STATUS_BP1 |
 				SPI_STATUS_BP0);
 	u8 status;
 	int rc;
 
-	rc = falcon_spi_cmd(spi, SPI_RDSR, -1, NULL, &status, sizeof(status));
+	rc = falcon_spi_cmd(efx, spi, SPI_RDSR, -1, NULL,
+			    &status, sizeof(status));
 	if (rc)
 		return rc;
 
 	if (!(status & unlock_mask))
 		return 0; /* already unlocked */
 
-	rc = falcon_spi_cmd(spi, SPI_WREN, -1, NULL, NULL, 0);
+	rc = falcon_spi_cmd(efx, spi, SPI_WREN, -1, NULL, NULL, 0);
 	if (rc)
 		return rc;
-	rc = falcon_spi_cmd(spi, SPI_SST_EWSR, -1, NULL, NULL, 0);
+	rc = falcon_spi_cmd(efx, spi, SPI_SST_EWSR, -1, NULL, NULL, 0);
 	if (rc)
 		return rc;
 
 	status &= ~unlock_mask;
-	rc = falcon_spi_cmd(spi, SPI_WRSR, -1, &status, NULL, sizeof(status));
+	rc = falcon_spi_cmd(efx, spi, SPI_WRSR, -1, &status,
+			    NULL, sizeof(status));
 	if (rc)
 		return rc;
-	rc = falcon_spi_wait_write(spi);
+	rc = falcon_spi_wait_write(efx, spi);
 	if (rc)
 		return rc;
 
 	return 0;
 }
 
-static int efx_spi_erase(struct efx_mtd *efx_mtd, loff_t start, size_t len)
+static int
+efx_spi_erase(struct efx_mtd_partition *part, loff_t start, size_t len)
 {
+	struct efx_mtd *efx_mtd = part->mtd.priv;	
 	const struct efx_spi_device *spi = efx_mtd->spi;
+	struct efx_nic *efx = efx_mtd->efx;
 	unsigned pos, block_len;
 	u8 empty[EFX_SPI_VERIFY_BUF_LEN];
 	u8 buffer[EFX_SPI_VERIFY_BUF_LEN];
@@ -98,22 +177,24 @@ static int efx_spi_erase(struct efx_mtd 
 	if (spi->erase_command == 0)
 		return -EOPNOTSUPP;
 
-	rc = efx_spi_unlock(spi);
+	rc = efx_spi_unlock(efx, spi);
 	if (rc)
 		return rc;
-	rc = falcon_spi_cmd(spi, SPI_WREN, -1, NULL, NULL, 0);
+	rc = falcon_spi_cmd(efx, spi, SPI_WREN, -1, NULL, NULL, 0);
 	if (rc)
 		return rc;
-	rc = falcon_spi_cmd(spi, spi->erase_command, start, NULL, NULL, 0);
+	rc = falcon_spi_cmd(efx, spi, spi->erase_command, start, NULL,
+			    NULL, 0);
 	if (rc)
 		return rc;
-	rc = efx_spi_slow_wait(efx_mtd, false);
+	rc = efx_spi_slow_wait(part, false);
 
 	/* Verify the entire region has been wiped */
 	memset(empty, 0xff, sizeof(empty));
 	for (pos = 0; pos < len; pos += block_len) {
 		block_len = min(len - pos, sizeof(buffer));
-		rc = falcon_spi_read(spi, start + pos, block_len, NULL, buffer);
+		rc = falcon_spi_read(efx, spi, start + pos, block_len,
+				     NULL, buffer);
 		if (rc)
 			return rc;
 		if (memcmp(empty, buffer, block_len))
@@ -130,36 +211,12 @@ static int efx_spi_erase(struct efx_mtd 
 
 /* MTD interface */
 
-static int efx_mtd_read(struct mtd_info *mtd, loff_t start, size_t len,
-			size_t *retlen, u8 *buffer)
-{
-	struct efx_mtd *efx_mtd = mtd->priv;
-	const struct efx_spi_device *spi = efx_mtd->spi;
-	struct efx_nic *efx = spi->efx;
-	int rc;
-
-	rc = mutex_lock_interruptible(&efx->spi_lock);
-	if (rc)
-		return rc;
-	rc = falcon_spi_read(spi, FALCON_FLASH_BOOTCODE_START + start,
-			     len, retlen, buffer);
-	mutex_unlock(&efx->spi_lock);
-	return rc;
-}
-
 static int efx_mtd_erase(struct mtd_info *mtd, struct erase_info *erase)
 {
 	struct efx_mtd *efx_mtd = mtd->priv;
-	struct efx_nic *efx = efx_mtd->spi->efx;
 	int rc;
 
-	rc = mutex_lock_interruptible(&efx->spi_lock);
-	if (rc)
-		return rc;
-	rc = efx_spi_erase(efx_mtd, FALCON_FLASH_BOOTCODE_START + erase->addr,
-			   erase->len);
-	mutex_unlock(&efx->spi_lock);
-
+	rc = efx_mtd->ops->erase(mtd, erase->addr, erase->len);
 	if (rc == 0) {
 		erase->state = MTD_ERASE_DONE;
 	} else {
@@ -170,100 +227,550 @@ static int efx_mtd_erase(struct mtd_info
 	return rc;
 }
 
-static int efx_mtd_write(struct mtd_info *mtd, loff_t start,
-			 size_t len, size_t *retlen, const u8 *buffer)
+static void efx_mtd_sync(struct mtd_info *mtd)
 {
+	struct efx_mtd_partition *part = to_efx_mtd_partition(mtd);
 	struct efx_mtd *efx_mtd = mtd->priv;
-	const struct efx_spi_device *spi = efx_mtd->spi;
-	struct efx_nic *efx = spi->efx;
 	int rc;
 
-	rc = mutex_lock_interruptible(&efx->spi_lock);
+	rc = efx_mtd->ops->sync(mtd);
 	if (rc)
-		return rc;
-	rc = falcon_spi_write(spi, FALCON_FLASH_BOOTCODE_START + start,
-			      len, retlen, buffer);
-	mutex_unlock(&efx->spi_lock);
-	return rc;
+		pr_err("%s: %s sync failed (%d)\n",
+		       part->name, efx_mtd->name, rc);
 }
 
-static void efx_mtd_sync(struct mtd_info *mtd)
+static void efx_mtd_remove_partition(struct efx_mtd_partition *part)
 {
-	struct efx_mtd *efx_mtd = mtd->priv;
-	struct efx_nic *efx = efx_mtd->spi->efx;
 	int rc;
 
-	mutex_lock(&efx->spi_lock);
-	rc = efx_spi_slow_wait(efx_mtd, true);
-	mutex_unlock(&efx->spi_lock);
+	for (;;) {
+		rc = mtd_device_unregister(&part->mtd);
+		if (rc != -EBUSY)
+			break;
+		ssleep(1);
+	}
+	WARN_ON(rc);
+}
 
-	if (rc)
-		EFX_ERR(efx, "%s sync failed (%d)\n", efx_mtd->name, rc);
-	return;
+static void efx_mtd_remove_device(struct efx_mtd *efx_mtd)
+{
+	struct efx_mtd_partition *part;
+
+	efx_for_each_partition(part, efx_mtd)
+		efx_mtd_remove_partition(part);
+	list_del(&efx_mtd->node);
+	kfree(efx_mtd);
+}
+
+static void efx_mtd_rename_device(struct efx_mtd *efx_mtd)
+{
+	struct efx_mtd_partition *part;
+
+	efx_for_each_partition(part, efx_mtd)
+		if (efx_nic_rev(efx_mtd->efx) >= EFX_REV_SIENA_A0)
+			snprintf(part->name, sizeof(part->name),
+				 "%s %s:%02x", efx_mtd->efx->name,
+				 part->type_name, part->mcdi.fw_subtype);
+		else
+			snprintf(part->name, sizeof(part->name),
+				 "%s %s", efx_mtd->efx->name,
+				 part->type_name);
+}
+
+static int efx_mtd_probe_device(struct efx_nic *efx, struct efx_mtd *efx_mtd)
+{
+	struct efx_mtd_partition *part;
+
+	efx_mtd->efx = efx;
+
+	efx_mtd_rename_device(efx_mtd);
+
+	efx_for_each_partition(part, efx_mtd) {
+		part->mtd.writesize = 1;
+		if (efx_allow_nvconfig_writes)
+			part->mtd.flags |= MTD_WRITEABLE;
+
+		part->mtd.owner = THIS_MODULE;
+		part->mtd.priv = efx_mtd;
+		part->mtd.name = part->name;
+		part->mtd.erase = efx_mtd_erase;
+		part->mtd.read = efx_mtd->ops->read;
+		part->mtd.write = efx_mtd->ops->write;
+		part->mtd.sync = efx_mtd_sync;
+
+		if (mtd_device_register(&part->mtd, NULL, 0))
+			goto fail;
+	}
+
+	list_add(&efx_mtd->node, &efx->mtd_list);
+	return 0;
+
+fail:
+	while (part != &efx_mtd->part[0]) {
+		--part;
+		efx_mtd_remove_partition(part);
+	}
+	/* The number of MTDs is limited (to 16 or 32 by default) and
+	 * we probably reached that limit.
+	 */
+	return -EBUSY;
 }
 
 void efx_mtd_remove(struct efx_nic *efx)
 {
-	if (efx->spi_flash && efx->spi_flash->mtd) {
-		struct efx_mtd *efx_mtd = efx->spi_flash->mtd;
-		int rc;
+	struct efx_mtd *efx_mtd, *next;
 
-		for (;;) {
-			rc = del_mtd_device(&efx_mtd->mtd);
-			if (rc != -EBUSY)
-				break;
-			ssleep(1);
-		}
-		WARN_ON(rc);
-		kfree(efx_mtd);
-	}
+	WARN_ON(efx_dev_registered(efx));
+
+	list_for_each_entry_safe(efx_mtd, next, &efx->mtd_list, node)
+		efx_mtd_remove_device(efx_mtd);
 }
 
 void efx_mtd_rename(struct efx_nic *efx)
 {
-	if (efx->spi_flash && efx->spi_flash->mtd) {
-		struct efx_mtd *efx_mtd = efx->spi_flash->mtd;
-		snprintf(efx_mtd->name, sizeof(efx_mtd->name),
-			 "%s sfc_flash_bootrom", efx->name);
-	}
+	struct efx_mtd *efx_mtd;
+
+	ASSERT_RTNL();
+
+	list_for_each_entry(efx_mtd, &efx->mtd_list, node)
+		efx_mtd_rename_device(efx_mtd);
 }
 
 int efx_mtd_probe(struct efx_nic *efx)
 {
-	struct efx_spi_device *spi = efx->spi_flash;
+	if (efx_nic_rev(efx) >= EFX_REV_SIENA_A0)
+		return siena_mtd_probe(efx);
+	else
+		return falcon_mtd_probe(efx);
+}
+
+/* Implementation of MTD operations for Falcon */
+
+static int falcon_mtd_read(struct mtd_info *mtd, loff_t start,
+			   size_t len, size_t *retlen, u8 *buffer)
+{
+	struct efx_mtd_partition *part = to_efx_mtd_partition(mtd);
+	struct efx_mtd *efx_mtd = mtd->priv;
+	const struct efx_spi_device *spi = efx_mtd->spi;
+	struct efx_nic *efx = efx_mtd->efx;
+	struct falcon_nic_data *nic_data = efx->nic_data;
+	int rc;
+
+	rc = mutex_lock_interruptible(&nic_data->spi_lock);
+	if (rc)
+		return rc;
+	rc = falcon_spi_read(efx, spi, part->offset + start, len,
+			     retlen, buffer);
+	mutex_unlock(&nic_data->spi_lock);
+	return rc;
+}
+
+static int falcon_mtd_erase(struct mtd_info *mtd, loff_t start, size_t len)
+{
+	struct efx_mtd_partition *part = to_efx_mtd_partition(mtd);
+	struct efx_mtd *efx_mtd = mtd->priv;
+	struct efx_nic *efx = efx_mtd->efx;
+	struct falcon_nic_data *nic_data = efx->nic_data;
+	int rc;
+
+	rc = mutex_lock_interruptible(&nic_data->spi_lock);
+	if (rc)
+		return rc;
+	rc = efx_spi_erase(part, part->offset + start, len);
+	mutex_unlock(&nic_data->spi_lock);
+	return rc;
+}
+
+static int falcon_mtd_write(struct mtd_info *mtd, loff_t start,
+			    size_t len, size_t *retlen, const u8 *buffer)
+{
+	struct efx_mtd_partition *part = to_efx_mtd_partition(mtd);
+	struct efx_mtd *efx_mtd = mtd->priv;
+	const struct efx_spi_device *spi = efx_mtd->spi;
+	struct efx_nic *efx = efx_mtd->efx;
+	struct falcon_nic_data *nic_data = efx->nic_data;
+	int rc;
+
+	rc = mutex_lock_interruptible(&nic_data->spi_lock);
+	if (rc)
+		return rc;
+	rc = falcon_spi_write(efx, spi, part->offset + start, len,
+			      retlen, buffer);
+	mutex_unlock(&nic_data->spi_lock);
+	return rc;
+}
+
+static int falcon_mtd_sync(struct mtd_info *mtd)
+{
+	struct efx_mtd_partition *part = to_efx_mtd_partition(mtd);
+	struct efx_mtd *efx_mtd = mtd->priv;
+	struct efx_nic *efx = efx_mtd->efx;
+	struct falcon_nic_data *nic_data = efx->nic_data;
+	int rc;
+
+	mutex_lock(&nic_data->spi_lock);
+	rc = efx_spi_slow_wait(part, true);
+	mutex_unlock(&nic_data->spi_lock);
+	return rc;
+}
+
+static struct efx_mtd_ops falcon_mtd_ops = {
+	.read	= falcon_mtd_read,
+	.erase	= falcon_mtd_erase,
+	.write	= falcon_mtd_write,
+	.sync	= falcon_mtd_sync,
+};
+
+static int falcon_mtd_probe(struct efx_nic *efx)
+{
+	struct falcon_nic_data *nic_data = efx->nic_data;
+	struct efx_spi_device *spi;
 	struct efx_mtd *efx_mtd;
+	int rc = -ENODEV;
 
-	if (!spi || spi->size <= FALCON_FLASH_BOOTCODE_START)
+	ASSERT_RTNL();
+
+	spi = &nic_data->spi_flash;
+	if (efx_spi_present(spi)) {
+		size_t n_parts =
+			(spi->size > FALCON_FLASH_BOOTCODE_START) ? 2 : 1;
+
+		efx_mtd = kzalloc(sizeof(*efx_mtd) +
+				  n_parts * sizeof(efx_mtd->part[0]),
+				  GFP_KERNEL);
+		if (!efx_mtd)
+			return -ENOMEM;
+
+		efx_mtd->spi = spi;
+		efx_mtd->name = "flash";
+
+		efx_mtd->ops = &falcon_mtd_ops;
+
+		efx_mtd->n_parts = n_parts;
+
+		efx_mtd->part[0].mtd.type = MTD_NORFLASH;
+		efx_mtd->part[0].mtd.flags = MTD_CAP_NORFLASH & ~MTD_WRITEABLE;
+		efx_mtd->part[0].mtd.size = min(spi->size,
+						FALCON_FLASH_BOOTCODE_START);
+		efx_mtd->part[0].mtd.erasesize = spi->erase_size;
+		efx_mtd->part[0].offset = 0;
+		efx_mtd->part[0].type_name = "sfc_flash_config";
+
+		if (n_parts > 1) {
+			efx_mtd->part[1].mtd.type = MTD_NORFLASH;
+			efx_mtd->part[1].mtd.flags = MTD_CAP_NORFLASH;
+			efx_mtd->part[1].mtd.size = (spi->size
+						     - FALCON_FLASH_BOOTCODE_START);
+			efx_mtd->part[1].mtd.erasesize = spi->erase_size;
+			efx_mtd->part[1].offset = FALCON_FLASH_BOOTCODE_START;
+			efx_mtd->part[1].type_name = "sfc_flash_bootrom";
+		}
+
+		rc = efx_mtd_probe_device(efx, efx_mtd);
+		if (rc) {
+			kfree(efx_mtd);
+			return rc;
+		}
+	}
+
+	spi = &nic_data->spi_eeprom;
+	if (efx_spi_present(spi)) {
+		size_t n_parts =
+			(spi->size > EFX_EEPROM_BOOTCONFIG_END) ? 3 :
+			(spi->size > EFX_EEPROM_BOOTCONFIG_START) ? 2 : 1;
+		efx_mtd = kzalloc(sizeof(*efx_mtd) +
+				  n_parts * sizeof(efx_mtd->part[0]),
+				  GFP_KERNEL);
+		if (!efx_mtd)
+			return -ENOMEM;
+
+		efx_mtd->spi = spi;
+		efx_mtd->name = "EEPROM";
+
+		efx_mtd->ops = &falcon_mtd_ops;
+
+		efx_mtd->n_parts = n_parts;
+
+		efx_mtd->part[0].mtd.type = MTD_RAM;
+		efx_mtd->part[0].mtd.flags = MTD_CAP_RAM;
+		efx_mtd->part[0].mtd.size = min(spi->size,
+						EFX_EEPROM_BOOTCONFIG_START);
+		efx_mtd->part[0].mtd.erasesize = spi->erase_size;
+		efx_mtd->part[0].offset = 0;
+		if (spi->size >= FALCON_NVCONFIG_END) {
+			/* Chip and board config are in EEPROM */
+			efx_mtd->part[0].mtd.flags &= ~MTD_WRITEABLE;
+			efx_mtd->part[0].type_name = "sfc_large_config";
+		} else {
+			efx_mtd->part[0].type_name = "sfc_small_config";
+		}
+
+		if (n_parts > 1) {
+			efx_mtd->part[1].mtd.type = MTD_RAM;
+			efx_mtd->part[1].mtd.flags = MTD_CAP_RAM;
+			efx_mtd->part[1].mtd.size =
+				min(spi->size, EFX_EEPROM_BOOTCONFIG_END) -
+				EFX_EEPROM_BOOTCONFIG_START;
+			efx_mtd->part[1].mtd.erasesize = spi->erase_size;
+			efx_mtd->part[1].offset = EFX_EEPROM_BOOTCONFIG_START;
+			efx_mtd->part[1].type_name = "sfc_bootconfig";
+		}
+
+		if (n_parts > 2) {
+			efx_mtd->part[2].mtd.type = MTD_RAM;
+			efx_mtd->part[2].mtd.flags = MTD_CAP_RAM;
+			efx_mtd->part[2].mtd.size =
+				spi->size - EFX_EEPROM_BOOTCONFIG_END;
+			efx_mtd->part[2].mtd.erasesize = spi->erase_size;
+			efx_mtd->part[2].offset = EFX_EEPROM_BOOTCONFIG_END;
+			efx_mtd->part[2].type_name = "sfc_eeprom_spare";
+		}
+
+		rc = efx_mtd_probe_device(efx, efx_mtd);
+		if (rc) {
+			kfree(efx_mtd);
+			return rc;
+		}
+	}
+
+	return rc;
+}
+
+/* Implementation of MTD operations for Siena */
+
+static int siena_mtd_read(struct mtd_info *mtd, loff_t start,
+			  size_t len, size_t *retlen, u8 *buffer)
+{
+	struct efx_mtd_partition *part = to_efx_mtd_partition(mtd);
+	struct efx_mtd *efx_mtd = mtd->priv;
+	struct efx_nic *efx = efx_mtd->efx;
+	loff_t offset = start;
+	loff_t end = min_t(loff_t, start + len, mtd->size);
+	size_t chunk;
+	int rc = 0;
+
+	while (offset < end) {
+		chunk = min_t(size_t, end - offset, EFX_MCDI_NVRAM_LEN_MAX);
+		rc = efx_mcdi_nvram_read(efx, part->mcdi.nvram_type, offset,
+					 buffer, chunk);
+		if (rc)
+			goto out;
+		offset += chunk;
+		buffer += chunk;
+	}
+out:
+	*retlen = offset - start;
+	return rc;
+}
+
+static int siena_mtd_erase(struct mtd_info *mtd, loff_t start, size_t len)
+{
+	struct efx_mtd_partition *part = to_efx_mtd_partition(mtd);
+	struct efx_mtd *efx_mtd = mtd->priv;
+	struct efx_nic *efx = efx_mtd->efx;
+	loff_t offset = start & ~((loff_t)(mtd->erasesize - 1));
+	loff_t end = min_t(loff_t, start + len, mtd->size);
+	size_t chunk = part->mtd.erasesize;
+	int rc = 0;
+
+	if (!part->mcdi.updating) {
+		rc = efx_mcdi_nvram_update_start(efx, part->mcdi.nvram_type);
+		if (rc)
+			goto out;
+		part->mcdi.updating = 1;
+	}
+
+	/* The MCDI interface can in fact do multiple erase blocks at once;
+	 * but erasing may be slow, so we make multiple calls here to avoid
+	 * tripping the MCDI RPC timeout. */
+	while (offset < end) {
+		rc = efx_mcdi_nvram_erase(efx, part->mcdi.nvram_type, offset,
+					  chunk);
+		if (rc)
+			goto out;
+		offset += chunk;
+	}
+out:
+	return rc;
+}
+
+static int siena_mtd_write(struct mtd_info *mtd, loff_t start,
+			   size_t len, size_t *retlen, const u8 *buffer)
+{
+	struct efx_mtd_partition *part = to_efx_mtd_partition(mtd);
+	struct efx_mtd *efx_mtd = mtd->priv;
+	struct efx_nic *efx = efx_mtd->efx;
+	loff_t offset = start;
+	loff_t end = min_t(loff_t, start + len, mtd->size);
+	size_t chunk;
+	int rc = 0;
+
+	if (!part->mcdi.updating) {
+		rc = efx_mcdi_nvram_update_start(efx, part->mcdi.nvram_type);
+		if (rc)
+			goto out;
+		part->mcdi.updating = 1;
+	}
+
+	while (offset < end) {
+		chunk = min_t(size_t, end - offset, EFX_MCDI_NVRAM_LEN_MAX);
+		rc = efx_mcdi_nvram_write(efx, part->mcdi.nvram_type, offset,
+					  buffer, chunk);
+		if (rc)
+			goto out;
+		offset += chunk;
+		buffer += chunk;
+	}
+out:
+	*retlen = offset - start;
+	return rc;
+}
+
+static int siena_mtd_sync(struct mtd_info *mtd)
+{
+	struct efx_mtd_partition *part = to_efx_mtd_partition(mtd);
+	struct efx_mtd *efx_mtd = mtd->priv;
+	struct efx_nic *efx = efx_mtd->efx;
+	int rc = 0;
+
+	if (part->mcdi.updating) {
+		part->mcdi.updating = 0;
+		rc = efx_mcdi_nvram_update_finish(efx, part->mcdi.nvram_type);
+	}
+
+	return rc;
+}
+
+static struct efx_mtd_ops siena_mtd_ops = {
+	.read	= siena_mtd_read,
+	.erase	= siena_mtd_erase,
+	.write	= siena_mtd_write,
+	.sync	= siena_mtd_sync,
+};
+
+struct siena_nvram_type_info {
+	int port;
+	const char *name;
+};
+
+static struct siena_nvram_type_info siena_nvram_types[] = {
+	[MC_CMD_NVRAM_TYPE_DISABLED_CALLISTO]	= { 0, "sfc_dummy_phy" },
+	[MC_CMD_NVRAM_TYPE_MC_FW]		= { 0, "sfc_mcfw" },
+	[MC_CMD_NVRAM_TYPE_MC_FW_BACKUP]	= { 0, "sfc_mcfw_backup" },
+	[MC_CMD_NVRAM_TYPE_STATIC_CFG_PORT0]	= { 0, "sfc_static_cfg" },
+	[MC_CMD_NVRAM_TYPE_STATIC_CFG_PORT1]	= { 1, "sfc_static_cfg" },
+	[MC_CMD_NVRAM_TYPE_DYNAMIC_CFG_PORT0]	= { 0, "sfc_dynamic_cfg" },
+	[MC_CMD_NVRAM_TYPE_DYNAMIC_CFG_PORT1]	= { 1, "sfc_dynamic_cfg" },
+	[MC_CMD_NVRAM_TYPE_EXP_ROM]		= { 0, "sfc_exp_rom" },
+	[MC_CMD_NVRAM_TYPE_EXP_ROM_CFG_PORT0]	= { 0, "sfc_exp_rom_cfg" },
+	[MC_CMD_NVRAM_TYPE_EXP_ROM_CFG_PORT1]	= { 1, "sfc_exp_rom_cfg" },
+	[MC_CMD_NVRAM_TYPE_PHY_PORT0]		= { 0, "sfc_phy_fw" },
+	[MC_CMD_NVRAM_TYPE_PHY_PORT1]		= { 1, "sfc_phy_fw" },
+	[MC_CMD_NVRAM_TYPE_FPGA]		= { 0, "sfc_fpga" },
+};
+
+static int siena_mtd_probe_partition(struct efx_nic *efx,
+				     struct efx_mtd *efx_mtd,
+				     unsigned int part_id,
+				     unsigned int type)
+{
+	struct efx_mtd_partition *part = &efx_mtd->part[part_id];
+	struct siena_nvram_type_info *info;
+	size_t size, erase_size;
+	bool protected;
+	int rc;
+
+	if (type >= ARRAY_SIZE(siena_nvram_types) ||
+	    siena_nvram_types[type].name == NULL)
 		return -ENODEV;
 
-	efx_mtd = kzalloc(sizeof(*efx_mtd), GFP_KERNEL);
+	info = &siena_nvram_types[type];
+
+	if (info->port != efx_port_num(efx))
+		return -ENODEV;
+
+	rc = efx_mcdi_nvram_info(efx, type, &size, &erase_size, &protected);
+	if (rc)
+		return rc;
+	if (protected && !efx_allow_nvconfig_writes)
+		return -ENODEV; /* hide it */
+
+	part->mcdi.nvram_type = type;
+	part->type_name = info->name;
+
+	part->mtd.type = MTD_NORFLASH;
+	part->mtd.flags = MTD_CAP_NORFLASH;
+	part->mtd.size = size;
+	part->mtd.erasesize = erase_size;
+
+	return 0;
+}
+
+static int siena_mtd_get_fw_subtypes(struct efx_nic *efx,
+				     struct efx_mtd *efx_mtd)
+{
+	struct efx_mtd_partition *part;
+	uint16_t fw_subtype_list[
+		MC_CMD_GET_BOARD_CFG_OUT_FW_SUBTYPE_LIST_MAXNUM];
+	int rc;
+
+	rc = efx_mcdi_get_board_cfg(efx, NULL, fw_subtype_list, NULL);
+	if (rc)
+		return rc;
+
+	efx_for_each_partition(part, efx_mtd)
+		part->mcdi.fw_subtype = fw_subtype_list[part->mcdi.nvram_type];
+
+	return 0;
+}
+
+static int siena_mtd_probe(struct efx_nic *efx)
+{
+	struct efx_mtd *efx_mtd;
+	int rc = -ENODEV;
+	u32 nvram_types;
+	unsigned int type;
+
+	ASSERT_RTNL();
+
+	rc = efx_mcdi_nvram_types(efx, &nvram_types);
+	if (rc)
+		return rc;
+
+	efx_mtd = kzalloc(sizeof(*efx_mtd) +
+			  hweight32(nvram_types) * sizeof(efx_mtd->part[0]),
+			  GFP_KERNEL);
 	if (!efx_mtd)
 		return -ENOMEM;
 
-	efx_mtd->spi = spi;
-	spi->mtd = efx_mtd;
+	efx_mtd->name = "Siena NVRAM manager";
 
-	efx_mtd->mtd.type = MTD_NORFLASH;
-	efx_mtd->mtd.flags = MTD_CAP_NORFLASH;
-	efx_mtd->mtd.size = spi->size - FALCON_FLASH_BOOTCODE_START;
-	efx_mtd->mtd.erasesize = spi->erase_size;
-	efx_mtd->mtd.writesize = 1;
-	efx_mtd_rename(efx);
+	efx_mtd->ops = &siena_mtd_ops;
 
-	efx_mtd->mtd.owner = THIS_MODULE;
-	efx_mtd->mtd.priv = efx_mtd;
-	efx_mtd->mtd.name = efx_mtd->name;
-	efx_mtd->mtd.erase = efx_mtd_erase;
-	efx_mtd->mtd.read = efx_mtd_read;
-	efx_mtd->mtd.write = efx_mtd_write;
-	efx_mtd->mtd.sync = efx_mtd_sync;
+	type = 0;
+	efx_mtd->n_parts = 0;
 
-	if (add_mtd_device(&efx_mtd->mtd)) {
-		kfree(efx_mtd);
-		spi->mtd = NULL;
-		/* add_mtd_device() returns 1 if the MTD table is full */
-		return -ENOMEM;
+	while (nvram_types != 0) {
+		if (nvram_types & 1) {
+			rc = siena_mtd_probe_partition(efx, efx_mtd,
+						       efx_mtd->n_parts, type);
+			if (rc == 0)
+				efx_mtd->n_parts++;
+			else if (rc != -ENODEV)
+				goto fail;
+		}
+		type++;
+		nvram_types >>= 1;
 	}
 
-	return 0;
+	rc = siena_mtd_get_fw_subtypes(efx, efx_mtd);
+	if (rc)
+		goto fail;
+
+	rc = efx_mtd_probe_device(efx, efx_mtd);
+fail:
+	if (rc)
+		kfree(efx_mtd);
+	return rc;
 }
+
diff -r 9566a4a50a43 drivers/net/sfc/net_driver.h
--- a/drivers/net/sfc/net_driver.h
+++ b/drivers/net/sfc/net_driver.h
@@ -1,7 +1,7 @@
 /****************************************************************************
  * Driver for Solarflare Solarstorm network controllers and boards
  * Copyright 2005-2006 Fen Systems Ltd.
- * Copyright 2005-2008 Solarflare Communications Inc.
+ * Copyright 2005-2011 Solarflare Communications Inc.
  *
  * This program is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 as published
@@ -19,29 +19,37 @@
 #include <linux/ethtool.h>
 #include <linux/if_vlan.h>
 #include <linux/timer.h>
-#include <linux/mdio.h>
 #include <linux/list.h>
 #include <linux/pci.h>
 #include <linux/device.h>
-#include <linux/highmem.h>
-#include <linux/workqueue.h>
+#include <linux/vmalloc.h>
 #include <linux/i2c.h>
 
+/* Must come before other headers */
+#include "kernel_compat.h"
+
 #include "enum.h"
 #include "bitfield.h"
+#include "driverlink_api.h"
 #include "driverlink.h"
 
+	#ifdef EFX_USE_DEBUGFS
+		struct dentry;
+		typedef struct dentry efx_debugfs_entry;
+	#else
+		struct proc_dir_entry;
+		typedef struct proc_dir_entry efx_debugfs_entry;
+	#endif
+
 /**************************************************************************
  *
  * Build definitions
  *
  **************************************************************************/
-#ifndef EFX_DRIVER_NAME
-#define EFX_DRIVER_NAME	"sfc"
-#endif
-#define EFX_DRIVER_VERSION	"2.3"
 
-#ifdef EFX_ENABLE_DEBUG
+#define EFX_DRIVER_VERSION	"3.2.1.6079"
+
+#ifdef DEBUG
 #define EFX_BUG_ON_PARANOID(x) BUG_ON(x)
 #define EFX_WARN_ON_PARANOID(x) WARN_ON(x)
 #else
@@ -49,35 +57,6 @@
 #define EFX_WARN_ON_PARANOID(x) do {} while (0)
 #endif
 
-/* Un-rate-limited logging */
-#define EFX_ERR(efx, fmt, args...) \
-dev_err(&((efx)->pci_dev->dev), "ERR: %s " fmt, efx_dev_name(efx), ##args)
-
-#define EFX_INFO(efx, fmt, args...) \
-dev_info(&((efx)->pci_dev->dev), "INFO: %s " fmt, efx_dev_name(efx), ##args)
-
-#ifdef EFX_ENABLE_DEBUG
-#define EFX_LOG(efx, fmt, args...) \
-dev_info(&((efx)->pci_dev->dev), "DBG: %s " fmt, efx_dev_name(efx), ##args)
-#else
-#define EFX_LOG(efx, fmt, args...) \
-dev_dbg(&((efx)->pci_dev->dev), "DBG: %s " fmt, efx_dev_name(efx), ##args)
-#endif
-
-#define EFX_TRACE(efx, fmt, args...) do {} while (0)
-
-#define EFX_REGDUMP(efx, fmt, args...) do {} while (0)
-
-/* Rate-limited logging */
-#define EFX_ERR_RL(efx, fmt, args...) \
-do {if (net_ratelimit()) EFX_ERR(efx, fmt, ##args); } while (0)
-
-#define EFX_INFO_RL(efx, fmt, args...) \
-do {if (net_ratelimit()) EFX_INFO(efx, fmt, ##args); } while (0)
-
-#define EFX_LOG_RL(efx, fmt, args...) \
-do {if (net_ratelimit()) EFX_LOG(efx, fmt, ##args); } while (0)
-
 /**************************************************************************
  *
  * Efx data structures
@@ -86,10 +65,20 @@ do {if (net_ratelimit()) EFX_LOG(efx, fm
 
 #define EFX_MAX_CHANNELS 32
 #define EFX_MAX_RX_QUEUES EFX_MAX_CHANNELS
+#define EFX_EXTRA_CHANNEL_IOV	0
+#define EFX_EXTRA_CHANNEL_PTP	1
+#define EFX_MAX_EXTRA_CHANNELS	2
 
-#define EFX_TX_QUEUE_OFFLOAD_CSUM	0
-#define EFX_TX_QUEUE_NO_CSUM		1
-#define EFX_TX_QUEUE_COUNT		2
+/* Checksum generation is a per-queue option in hardware, so each
+ * queue visible to the networking core is backed by two hardware TX
+ * queues. */
+#define EFX_MAX_CORE_TX_QUEUES	EFX_MAX_CHANNELS
+#define EFX_TXQ_TYPE_OFFLOAD	1
+#define EFX_TXQ_TYPES		2
+#define EFX_MAX_TX_QUEUES	(EFX_TXQ_TYPES * EFX_MAX_CORE_TX_QUEUES)
+
+/* Forward declare structure used in the Precision Time Protocol (PTP) support. */
+struct efx_ptp_data;
 
 /**
  * struct efx_special_buffer - An Efx special buffer
@@ -102,16 +91,13 @@ do {if (net_ratelimit()) EFX_LOG(efx, fm
  * Special buffers are used for the event queues and the TX and RX
  * descriptor queues for each channel.  They are *not* used for the
  * actual transmit and receive buffers.
- *
- * Note that for Falcon, TX and RX descriptor queues live in host memory.
- * Allocation and freeing procedures must take this into account.
  */
 struct efx_special_buffer {
 	void *addr;
 	dma_addr_t dma_addr;
 	unsigned int len;
-	int index;
-	int entries;
+	unsigned int index;
+	unsigned int entries;
 };
 
 /**
@@ -155,13 +141,19 @@ struct efx_tx_buffer {
  * @efx: The associated Efx NIC
  * @queue: DMA queue number
  * @channel: The associated channel
+ * @core_txq: The networking core TX queue structure
  * @buffer: The software buffer ring
  * @txd: The hardware descriptor ring
- * @flushed: Used when handling queue flushing
+ * @ptr_mask: The size of the ring minus 1.
+ * @debug_dir: debugfs directory
  * @read_count: Current read pointer.
  *	This is the number of buffers that have been removed from both rings.
- * @stopped: Stopped count.
- *	Set if this TX queue is currently stopping its port.
+ * @old_write_count: The value of @write_count when last checked.
+ *	This is here for performance reasons.  The xmit path will
+ *	only get the up-to-date value of @write_count if this
+ *	variable indicates that the queue is empty.  This is to
+ *	avoid cache-line ping-pong between the xmit path and the
+ *	completion path.
  * @insert_count: Current insert pointer
  *	This is the number of buffers that have been added to the
  *	software ring.
@@ -181,20 +173,24 @@ struct efx_tx_buffer {
  * @tso_long_headers: Number of packets with headers too long for standard
  *	blocks
  * @tso_packets: Number of packets via the TSO xmit path
+ * @pushes: Number of times the TX push feature has been used
+ * @empty_read_count: If the completion path has seen the queue as empty
+ *	and the transmission path has not yet checked this, the value of
+ *	@read_count bitwise-added to %EFX_EMPTY_COUNT_VALID; otherwise 0.
  */
 struct efx_tx_queue {
 	/* Members which don't change on the fast path */
 	struct efx_nic *efx ____cacheline_aligned_in_smp;
-	int queue;
+	unsigned queue;
 	struct efx_channel *channel;
-	struct efx_nic *nic;
+	struct netdev_queue *core_txq;
 	struct efx_tx_buffer *buffer;
 	struct efx_special_buffer txd;
-	bool flushed;
+	unsigned int ptr_mask;
 
 	/* Members used mainly on the completion path */
 	unsigned int read_count ____cacheline_aligned_in_smp;
-	int stopped;
+	unsigned int old_write_count;
 
 	/* Members used only on the xmit path */
 	unsigned int insert_count ____cacheline_aligned_in_smp;
@@ -204,42 +200,69 @@ struct efx_tx_queue {
 	unsigned int tso_bursts;
 	unsigned int tso_long_headers;
 	unsigned int tso_packets;
+	unsigned int pushes;
+
+	/* Members shared between paths and sometimes updated */
+	unsigned int empty_read_count ____cacheline_aligned_in_smp;
+#define EFX_EMPTY_COUNT_VALID 0x80000000
 };
 
 /**
  * struct efx_rx_buffer - An Efx RX data buffer
  * @dma_addr: DMA base address of the buffer
- * @skb: The associated socket buffer, if any.
- *	If both this and page are %NULL, the buffer slot is currently free.
- * @page: The associated page buffer, if any.
- *	If both this and skb are %NULL, the buffer slot is currently free.
- * @data: Pointer to ethernet header
+ * @skb: The associated socket buffer. Valid iff !(@flags & %EFX_RX_BUF_PAGE).
+ *	Will be %NULL if the buffer slot is currently free.
+ * @page: The associated page buffer. Valif iff @flags & %EFX_RX_BUF_PAGE.
+ *	Will be %NULL if the buffer slot is currently free.
  * @len: Buffer length, in bytes.
- * @unmap_addr: DMA address to unmap
+ * @flags: Flags for buffer and packet state.
  */
 struct efx_rx_buffer {
 	dma_addr_t dma_addr;
-	struct sk_buff *skb;
-	struct page *page;
-	char *data;
+	union {
+		struct sk_buff *skb;
+		struct page *page;
+	} u;
 	unsigned int len;
-	dma_addr_t unmap_addr;
+	u16 flags;
+};
+#define EFX_RX_BUF_PAGE		0x0001
+#define EFX_RX_PKT_CSUMMED	0x0002
+#define EFX_RX_PKT_DISCARD	0x0004
+#define EFX_RX_PKT_VLAN		0x0008
+
+/**
+ * struct efx_rx_page_state - Page-based rx buffer state
+ *
+ * Inserted at the start of every page allocated for receive buffers.
+ * Used to facilitate sharing dma mappings between recycled rx buffers
+ * and those passed up to the kernel.
+ *
+ * @refcnt: Number of struct efx_rx_buffer's referencing this page.
+ *	When refcnt falls to zero, the page is unmapped for dma
+ * @dma_addr: The dma address of this page.
+ */
+struct efx_rx_page_state {
+	unsigned refcnt;
+	dma_addr_t dma_addr;
+
+	unsigned int __pad[0] ____cacheline_aligned;
 };
 
 /**
  * struct efx_rx_queue - An Efx RX queue
  * @efx: The associated Efx NIC
- * @queue: DMA queue number
- * @channel: The associated channel
+ * @core_index: Index of network core RX queue.  Will be >= 0 iff this
+ *	is associated with a real RX queue.
  * @buffer: The software buffer ring
  * @rxd: The hardware descriptor ring
+ * @ptr_mask: The size of the ring minus 1.
+ * @enabled: Receive queue enabled indicator.
+ * @flush_pending: Set when a RX flush is pending. Has the same liftime as
+ *	%rxq_flush_pending.
  * @added_count: Number of buffers added to the receive queue.
  * @notified_count: Number of buffers given to NIC (<= @added_count).
  * @removed_count: Number of buffers removed from the receive queue.
- * @add_lock: Receive queue descriptor add spin lock.
- *	This lock must be held in order to add buffers to the RX
- *	descriptor ring (rxd and buffer) and to update added_count (but
- *	not removed_count).
  * @max_fill: RX descriptor maximum fill level (<= ring size)
  * @fast_fill_trigger: RX descriptor fill level that will trigger a fast fill
  *	(<= @max_fill)
@@ -248,30 +271,26 @@ struct efx_rx_buffer {
  * @min_fill: RX descriptor minimum non-zero fill level.
  *	This records the minimum fill level observed when a ring
  *	refill was triggered.
- * @min_overfill: RX descriptor minimum overflow fill level.
- *	This records the minimum fill level at which RX queue
- *	overflow was observed.  It should never be set.
  * @alloc_page_count: RX allocation strategy counter.
  * @alloc_skb_count: RX allocation strategy counter.
- * @work: Descriptor push work thread
- * @buf_page: Page for next RX buffer.
- *	We can use a single page for multiple RX buffers. This tracks
- *	the remaining space in the allocation.
- * @buf_dma_addr: Page's DMA address.
- * @buf_data: Page's host address.
- * @flushed: Use when handling queue flushing
+ * @recycle_count: RX buffer recycle counter.
+ * @resurrect_count: Shared RX buffer resurrection counter.
+ * @resurrect_failed_count: Shared RX buffer resurrection failed counter.
+ * @slow_fill: Timer used to defer efx_nic_generate_fill_event().
+ * @debug_dir: debugfs directory
  */
 struct efx_rx_queue {
 	struct efx_nic *efx;
-	int queue;
-	struct efx_channel *channel;
+	int core_index;
 	struct efx_rx_buffer *buffer;
 	struct efx_special_buffer rxd;
+	unsigned int ptr_mask;
+	bool enabled;
+	bool flush_pending;
 
 	int added_count;
 	int notified_count;
 	int removed_count;
-	spinlock_t add_lock;
 	unsigned int max_fill;
 	unsigned int fast_fill_trigger;
 	unsigned int fast_fill_limit;
@@ -279,13 +298,12 @@ struct efx_rx_queue {
 	unsigned int min_overfill;
 	unsigned int alloc_page_count;
 	unsigned int alloc_skb_count;
-	struct delayed_work work;
+	unsigned int recycle_count;
+	unsigned int resurrect_count;
+	unsigned int resurrect_failed_count;
+	struct timer_list slow_fill;
 	unsigned int slow_fill_count;
 
-	struct page *buf_page;
-	dma_addr_t buf_dma_addr;
-	char *buf_data;
-	bool flushed;
 };
 
 /**
@@ -294,7 +312,7 @@ struct efx_rx_queue {
  * @dma_addr: DMA base address of the buffer
  * @len: Buffer length, in bytes
  *
- * Falcon uses these buffers for its interrupt status registers and
+ * The NIC uses these buffers for its interrupt status registers and
  * MAC stats dumps.
  */
 struct efx_buffer {
@@ -304,11 +322,6 @@ struct efx_buffer {
 };
 
 
-/* Flags for channel->used_flags */
-#define EFX_USED_BY_RX 1
-#define EFX_USED_BY_TX 2
-#define EFX_USED_BY_RX_TX (EFX_USED_BY_RX | EFX_USED_BY_TX)
-
 enum efx_rx_alloc_method {
 	RX_ALLOC_METHOD_AUTO = 0,
 	RX_ALLOC_METHOD_SKB = 1,
@@ -324,38 +337,41 @@ enum efx_rx_alloc_method {
  *
  * @efx: Associated Efx NIC
  * @channel: Channel instance number
- * @name: Name for channel and IRQ
- * @used_flags: Channel is used by net driver
+ * @type: Channel type definition
  * @enabled: Channel enabled indicator
  * @irq: IRQ number (MSI and MSI-X only)
- * @irq_moderation: IRQ moderation value (in us)
+ * @irq_moderation: IRQ moderation value (in hardware ticks)
  * @napi_dev: Net device used with NAPI
  * @napi_str: NAPI control structure
- * @reset_work: Scheduled reset work thread
  * @work_pending: Is work pending via NAPI?
  * @eventq: Event queue buffer
+ * @eventq_mask: Event queue pointer mask
  * @eventq_read_ptr: Event queue read pointer
  * @last_eventq_read_ptr: Last event queue read pointer value.
- * @eventq_magic: Event queue magic value for driver-generated test events
+ * @event_test_cpu: Last CPU to handle interrupt or test event for this channel
  * @irq_count: Number of IRQs since last adaptive moderation decision
  * @irq_mod_score: IRQ moderation score
+ * @debug_dir: debugfs directory
  * @rx_alloc_level: Watermark based heuristic counter for pushing descriptors
  *	and diagnostic counters
  * @rx_alloc_push_pages: RX allocation method currently in use for pushing
  *	descriptors
  * @n_rx_tobe_disc: Count of RX_TOBE_DISC errors
- * @n_rx_ip_frag_err: Count of RX IP fragment errors
+ * @n_rx_ip_frag: Count of RX packets containing fragmented IP
  * @n_rx_ip_hdr_chksum_err: Count of RX IP header checksum errors
  * @n_rx_tcp_udp_chksum_err: Count of RX TCP and UDP checksum errors
+ * @n_rx_eth_crc_err: Count of RX CRC errors
+ * @n_rx_mcast_mismatch: Count of unmatched multicast frames
  * @n_rx_frm_trunc: Count of RX_FRM_TRUNC errors
  * @n_rx_overlength: Count of RX_OVERLENGTH errors
  * @n_skbuff_leaks: Count of skbuffs leaked due to RX overrun
+ * @rx_queue: RX queue for this channel
+ * @tx_queue: TX queues for this channel
  */
 struct efx_channel {
 	struct efx_nic *efx;
 	int channel;
-	char name[IFNAMSIZ + 6];
-	int used_flags;
+	const struct efx_channel_type *type;
 	bool enabled;
 	int irq;
 	unsigned int irq_moderation;
@@ -363,20 +379,30 @@ struct efx_channel {
 	struct napi_struct napi_str;
 	bool work_pending;
 	struct efx_special_buffer eventq;
+	unsigned int eventq_mask;
 	unsigned int eventq_read_ptr;
 	unsigned int last_eventq_read_ptr;
-	unsigned int eventq_magic;
+	int event_test_cpu;
 
 	unsigned int irq_count;
 	unsigned int irq_mod_score;
+#ifdef CONFIG_RFS_ACCEL
+	unsigned int rfs_filters_added;
+#endif
+
+#if defined(EFX_USE_KCOMPAT) && defined(EFX_NEED_SAVE_MSIX_MESSAGES)
+	struct msi_msg msix_msg;
+#endif
 
 	int rx_alloc_level;
 	int rx_alloc_push_pages;
 
 	unsigned n_rx_tobe_disc;
-	unsigned n_rx_ip_frag_err;
+	unsigned n_rx_ip_frag;
 	unsigned n_rx_ip_hdr_chksum_err;
 	unsigned n_rx_tcp_udp_chksum_err;
+	unsigned n_rx_eth_crc_err;
+	unsigned n_rx_mcast_mismatch;
 	unsigned n_rx_frm_trunc;
 	unsigned n_rx_overlength;
 	unsigned n_skbuff_leaks;
@@ -385,57 +411,57 @@ struct efx_channel {
 	 * access with prefetches.
 	 */
 	struct efx_rx_buffer *rx_pkt;
-	bool rx_pkt_csummed;
 
+	struct efx_rx_queue rx_queue;
+	struct efx_tx_queue tx_queue[2];
 };
 
 /**
- * struct efx_blinker - S/W LED blinking context
- * @state: Current state - on or off
- * @resubmit: Timer resubmission flag
- * @timer: Control timer for blinking
+ * struct efx_channel_type - distinguishes traffic and extra channels
+ * @handle_no_channel: Handle failure to allocate an extra channel
+ * @pre_probe: Set up extra state prior to initialisation
+ * @post_remove: Tear down extra state after finalisation, if allocated.
+ *	May be called on channels that have not been probed.
+ * @get_name: Generate the channel's name (used for its IRQ handler)
+ * @copy: Copy the channel state prior to reallocation.  May be %NULL if
+ *	reallocation is not supported.
+ * @receive_skb: Handle an skb ready to be passed to netif_receive_skb()
+ * @keep_eventq: Flag for whether event queue should be kept initialised
+ *	while the device is stopped
  */
-struct efx_blinker {
-	bool state;
-	bool resubmit;
-	struct timer_list timer;
+struct efx_channel_type {
+	void (*handle_no_channel)(struct efx_nic *);
+	int (*pre_probe)(struct efx_channel *);
+	void (*post_remove)(struct efx_channel *);
+	void (*get_name)(struct efx_channel *, char *buf, size_t len);
+	struct efx_channel *(*copy)(const struct efx_channel *);
+	void (*receive_skb)(struct efx_channel *, struct sk_buff *);
+	bool keep_eventq;
 };
 
-
-/**
- * struct efx_board - board information
- * @type: Board model type
- * @major: Major rev. ('A', 'B' ...)
- * @minor: Minor rev. (0, 1, ...)
- * @init: Initialisation function
- * @init_leds: Sets up board LEDs. May be called repeatedly.
- * @set_id_led: Turns the identification LED on or off
- * @blink: Starts/stops blinking
- * @monitor: Board-specific health check function
- * @fini: Cleanup function
- * @blinker: used to blink LEDs in software
- * @hwmon_client: I2C client for hardware monitor
- * @ioexp_client: I2C client for power/port control
- */
-struct efx_board {
-	int type;
-	int major;
-	int minor;
-	int (*init) (struct efx_nic *nic);
-	/* As the LEDs are typically attached to the PHY, LEDs
-	 * have a separate init callback that happens later than
-	 * board init. */
-	void (*init_leds)(struct efx_nic *efx);
-	void (*set_id_led) (struct efx_nic *efx, bool state);
-	int (*monitor) (struct efx_nic *nic);
-	void (*blink) (struct efx_nic *efx, bool start);
-	void (*fini) (struct efx_nic *nic);
-	struct efx_blinker blinker;
-	struct i2c_client *hwmon_client, *ioexp_client;
+enum efx_led_mode {
+	EFX_LED_OFF	= 0,
+	EFX_LED_ON	= 1,
+	EFX_LED_DEFAULT	= 2
 };
 
-#define STRING_TABLE_LOOKUP(val, member)	\
-	member ## _names[val]
+#define STRING_TABLE_LOOKUP(val, member) \
+	((val) < member ## _max) ? member ## _names[val] : "(invalid)"
+
+extern const char *efx_loopback_mode_names[];
+extern const unsigned int efx_loopback_mode_max;
+#define LOOPBACK_MODE(efx) \
+	STRING_TABLE_LOOKUP((efx)->loopback_mode, efx_loopback_mode)
+
+extern const char *efx_interrupt_mode_names[];
+extern const unsigned int efx_interrupt_mode_max;
+#define INT_MODE(efx) \
+	STRING_TABLE_LOOKUP(efx->interrupt_mode, efx_interrupt_mode)
+
+extern const char *efx_reset_type_names[];
+extern const unsigned int efx_reset_type_max;
+#define RESET_TYPE(type) \
+	STRING_TABLE_LOOKUP(type, efx_reset_type)
 
 enum efx_int_mode {
 	/* Be careful if altering to correct macro below */
@@ -446,21 +472,6 @@ enum efx_int_mode {
 };
 #define EFX_INT_MODE_USE_MSI(x) (((x)->interrupt_mode) <= EFX_INT_MODE_MSI)
 
-enum phy_type {
-	PHY_TYPE_NONE = 0,
-	PHY_TYPE_TXC43128 = 1,
-	PHY_TYPE_88E1111 = 2,
-	PHY_TYPE_SFX7101 = 3,
-	PHY_TYPE_QT2022C2 = 4,
-	PHY_TYPE_PM8358 = 6,
-	PHY_TYPE_SFT9001A = 8,
-	PHY_TYPE_QT2025C = 9,
-	PHY_TYPE_SFT9001B = 10,
-	PHY_TYPE_MAX	/* Insert any new items before this */
-};
-
-#define EFX_IS10G(efx) ((efx)->link_speed == 10000)
-
 enum nic_state {
 	STATE_INIT = 0,
 	STATE_RUNNING = 1,
@@ -501,73 +512,60 @@ enum efx_fc_type {
 	EFX_FC_AUTO = 4,
 };
 
-/* Supported MAC bit-mask */
-enum efx_mac_type {
-	EFX_GMAC = 1,
-	EFX_XMAC = 2,
+/**
+ * struct efx_link_state - Current state of the link
+ * @up: Link is up
+ * @fd: Link is full-duplex
+ * @fc: Actual flow control flags
+ * @speed: Link speed (Mbps)
+ */
+struct efx_link_state {
+	bool up;
+	bool fd;
+	enum efx_fc_type fc;
+	unsigned int speed;
 };
 
-static inline enum efx_fc_type efx_fc_resolve(enum efx_fc_type wanted_fc,
-					      unsigned int lpa)
+static inline bool efx_link_state_equal(const struct efx_link_state *left,
+					const struct efx_link_state *right)
 {
-	BUILD_BUG_ON(EFX_FC_AUTO & (EFX_FC_RX | EFX_FC_TX));
-
-	if (!(wanted_fc & EFX_FC_AUTO))
-		return wanted_fc;
-
-	return mii_resolve_flowctrl_fdx(mii_advertise_flowctrl(wanted_fc), lpa);
+	return left->up == right->up && left->fd == right->fd &&
+		left->fc == right->fc && left->speed == right->speed;
 }
 
 /**
- * struct efx_mac_operations - Efx MAC operations table
- * @reconfigure: Reconfigure MAC. Serialised by the mac_lock
- * @update_stats: Update statistics
- * @irq: Hardware MAC event callback. Serialised by the mac_lock
- * @poll: Poll for hardware state. Serialised by the mac_lock
- */
-struct efx_mac_operations {
-	void (*reconfigure) (struct efx_nic *efx);
-	void (*update_stats) (struct efx_nic *efx);
-	void (*irq) (struct efx_nic *efx);
-	void (*poll) (struct efx_nic *efx);
-};
-
-/**
  * struct efx_phy_operations - Efx PHY operations table
+ * @probe: Probe PHY and initialise efx->mdio.mode_support, efx->mdio.mmds,
+ *	efx->loopback_modes.
  * @init: Initialise PHY
  * @fini: Shut down PHY
  * @reconfigure: Reconfigure PHY (e.g. for new link parameters)
- * @clear_interrupt: Clear down interrupt
- * @blink: Blink LEDs
- * @poll: Poll for hardware state. Serialised by the mac_lock.
+ * @poll: Update @link_state and report whether it changed.
+ *	Serialised by the mac_lock.
  * @get_settings: Get ethtool settings. Serialised by the mac_lock.
  * @set_settings: Set ethtool settings. Serialised by the mac_lock.
  * @set_npage_adv: Set abilities advertised in (Extended) Next Page
  *	(only needed where AN bit is set in mmds)
- * @num_tests: Number of PHY-specific tests/results
- * @test_names: Names of the tests/results
- * @run_tests: Run tests and record results as appropriate.
+ * @test_alive: Test that PHY is 'alive' (online)
+ * @test_name: Get the name of a PHY-specific test/result
+ * @run_tests: Run tests and record results as appropriate (offline).
  *	Flags are the ethtool tests flags.
- * @mmds: MMD presence mask
- * @loopbacks: Supported loopback modes mask
  */
 struct efx_phy_operations {
-	enum efx_mac_type macs;
+	int (*probe) (struct efx_nic *efx);
 	int (*init) (struct efx_nic *efx);
 	void (*fini) (struct efx_nic *efx);
-	void (*reconfigure) (struct efx_nic *efx);
-	void (*clear_interrupt) (struct efx_nic *efx);
-	void (*poll) (struct efx_nic *efx);
+	void (*remove) (struct efx_nic *efx);
+	int (*reconfigure) (struct efx_nic *efx);
+	bool (*poll) (struct efx_nic *efx);
 	void (*get_settings) (struct efx_nic *efx,
 			      struct ethtool_cmd *ecmd);
 	int (*set_settings) (struct efx_nic *efx,
 			     struct ethtool_cmd *ecmd);
 	void (*set_npage_adv) (struct efx_nic *efx, u32);
-	u32 num_tests;
-	const char *const *test_names;
+	int (*test_alive) (struct efx_nic *efx);
+	const char *(*test_name) (struct efx_nic *efx, unsigned int index);
 	int (*run_tests) (struct efx_nic *efx, int *results, unsigned flags);
-	int mmds;
-	unsigned loopbacks;
 };
 
 /**
@@ -602,64 +600,73 @@ struct efx_mac_stats {
 	u64 tx_bytes;
 	u64 tx_good_bytes;
 	u64 tx_bad_bytes;
-	unsigned long tx_packets;
-	unsigned long tx_bad;
-	unsigned long tx_pause;
-	unsigned long tx_control;
-	unsigned long tx_unicast;
-	unsigned long tx_multicast;
-	unsigned long tx_broadcast;
-	unsigned long tx_lt64;
-	unsigned long tx_64;
-	unsigned long tx_65_to_127;
-	unsigned long tx_128_to_255;
-	unsigned long tx_256_to_511;
-	unsigned long tx_512_to_1023;
-	unsigned long tx_1024_to_15xx;
-	unsigned long tx_15xx_to_jumbo;
-	unsigned long tx_gtjumbo;
-	unsigned long tx_collision;
-	unsigned long tx_single_collision;
-	unsigned long tx_multiple_collision;
-	unsigned long tx_excessive_collision;
-	unsigned long tx_deferred;
-	unsigned long tx_late_collision;
-	unsigned long tx_excessive_deferred;
-	unsigned long tx_non_tcpudp;
-	unsigned long tx_mac_src_error;
-	unsigned long tx_ip_src_error;
+	u64 tx_packets;
+	u64 tx_bad;
+	u64 tx_pause;
+	u64 tx_control;
+	u64 tx_unicast;
+	u64 tx_multicast;
+	u64 tx_broadcast;
+	u64 tx_lt64;
+	u64 tx_64;
+	u64 tx_65_to_127;
+	u64 tx_128_to_255;
+	u64 tx_256_to_511;
+	u64 tx_512_to_1023;
+	u64 tx_1024_to_15xx;
+	u64 tx_15xx_to_jumbo;
+	u64 tx_gtjumbo;
+	u64 tx_collision;
+	u64 tx_single_collision;
+	u64 tx_multiple_collision;
+	u64 tx_excessive_collision;
+	u64 tx_deferred;
+	u64 tx_late_collision;
+	u64 tx_excessive_deferred;
+	u64 tx_non_tcpudp;
+	u64 tx_mac_src_error;
+	u64 tx_ip_src_error;
 	u64 rx_bytes;
 	u64 rx_good_bytes;
 	u64 rx_bad_bytes;
-	unsigned long rx_packets;
-	unsigned long rx_good;
-	unsigned long rx_bad;
-	unsigned long rx_pause;
-	unsigned long rx_control;
-	unsigned long rx_unicast;
-	unsigned long rx_multicast;
-	unsigned long rx_broadcast;
-	unsigned long rx_lt64;
-	unsigned long rx_64;
-	unsigned long rx_65_to_127;
-	unsigned long rx_128_to_255;
-	unsigned long rx_256_to_511;
-	unsigned long rx_512_to_1023;
-	unsigned long rx_1024_to_15xx;
-	unsigned long rx_15xx_to_jumbo;
-	unsigned long rx_gtjumbo;
-	unsigned long rx_bad_lt64;
-	unsigned long rx_bad_64_to_15xx;
-	unsigned long rx_bad_15xx_to_jumbo;
-	unsigned long rx_bad_gtjumbo;
-	unsigned long rx_overflow;
-	unsigned long rx_missed;
-	unsigned long rx_false_carrier;
-	unsigned long rx_symbol_error;
-	unsigned long rx_align_error;
-	unsigned long rx_length_error;
-	unsigned long rx_internal_error;
-	unsigned long rx_good_lt64;
+	u64 rx_packets;
+	u64 rx_good;
+	u64 rx_bad;
+	u64 rx_pause;
+	u64 rx_control;
+	u64 rx_unicast;
+	u64 rx_multicast;
+	u64 rx_broadcast;
+	u64 rx_lt64;
+	u64 rx_64;
+	u64 rx_65_to_127;
+	u64 rx_128_to_255;
+	u64 rx_256_to_511;
+	u64 rx_512_to_1023;
+	u64 rx_1024_to_15xx;
+	u64 rx_15xx_to_jumbo;
+	u64 rx_gtjumbo;
+	u64 rx_bad_lt64;
+	u64 rx_bad_64_to_15xx;
+	u64 rx_bad_15xx_to_jumbo;
+	u64 rx_bad_gtjumbo;
+	u64 rx_overflow;
+	u64 rx_missed;
+	u64 rx_false_carrier;
+	u64 rx_symbol_error;
+	u64 rx_align_error;
+	u64 rx_length_error;
+	u64 rx_internal_error;
+	u64 rx_good_lt64;
+	u64 rx_char_error_lane0;
+	u64 rx_char_error_lane1;
+	u64 rx_char_error_lane2;
+	u64 rx_char_error_lane3;
+	u64 rx_disp_error_lane0;
+	u64 rx_disp_error_lane1;
+	u64 rx_disp_error_lane2;
+	u64 rx_disp_error_lane3;
+	u64 rx_match_fault;
 };
 
 /* Number of bits used in a multicast filter hash address */
@@ -674,192 +681,287 @@ union efx_multicast_hash {
 	efx_oword_t oword[EFX_MCAST_HASH_ENTRIES / sizeof(efx_oword_t) / 8];
 };
 
+/* Efx Error condition statistics */
+struct efx_nic_errors {
+	atomic_t missing_event;
+	atomic_t rx_reset;
+	atomic_t rx_desc_fetch;
+	atomic_t tx_desc_fetch;
+	atomic_t spurious_tx;
+
+};
+
+struct efx_filter_state;
+struct efx_vf;
+struct vfdi_status;
+
 /**
  * struct efx_nic - an Efx NIC
  * @name: Device name (net device name or bus id before net device registered)
  * @pci_dev: The PCI device
+ * @revision: Hardware architecture revision
+ * @dl_revision: Revision name for driverlink
  * @type: Controller type attributes
  * @legacy_irq: IRQ number
- * @workqueue: Workqueue for port reconfigures and the HW monitor.
- *	Work items do not hold and must not acquire RTNL.
- * @workqueue_name: Name of workqueue
+ * @legacy_irq_enabled: Are IRQs enabled on NIC (INT_EN_KER register)?
  * @reset_work: Scheduled reset workitem
- * @monitor_work: Hardware monitor workitem
  * @membase_phys: Memory BAR value as physical address
  * @membase: Memory BAR value
- * @biu_lock: BIU (bus interface unit) lock
  * @interrupt_mode: Interrupt mode
+ * @timer_quantum_ns: Interrupt timer quantum, in nanoseconds
  * @irq_rx_adaptive: Adaptive IRQ moderation enabled for RX event queues
  * @irq_rx_moderation: IRQ moderation time for RX event queues
- * @i2c_adap: I2C adapter
- * @board_info: Board-level information
+ * @msg_enable: Log message enable flags
+ * @caps: Board capabilities as read from nvram
  * @state: Device state flag. Serialised by the rtnl_lock.
- * @reset_pending: Pending reset method (normally RESET_TYPE_NONE)
+ * @reset_pending: Bitmask for pending resets
  * @tx_queue: TX DMA queues
  * @rx_queue: RX DMA queues
  * @channel: Channels
- * @n_rx_queues: Number of RX queues
+ * @channel_name: Names for channels and their IRQs
+ * @extra_channel_types: Types of extra (non-traffic) channels that
+ *	should be allocated for this NIC
+ * @rxq_entries: Size of receive queues requested by user.
+ * @txq_entries: Size of transmit queues requested by user.
+ * @tx_dc_entries: Number of entries in each TX queue descriptor cache
+ * @rx_dc_entries: Number of entries in each RX queue descriptor cache
+ * @tx_dc_base: Base address in SRAM of TX queue descriptor caches
+ * @rx_dc_base: Base address in SRAM of RX queue descriptor caches
+ * @sram_lim: High address limit of SRAM
+ * @next_buffer_table: Next buffer table index to use
+ * @resources: Driverlink parameters
  * @n_channels: Number of channels in use
+ * @n_rx_channels: Number of channels used for RX (= number of RX queues)
+ * @n_rss_channels: Number of rx channels available for RSS.
+ * @rss_spread: Number of event queues to spread traffic over.
+ * @n_tx_channels: Number of channels used for TX
+ * @tx_channel_offset: Offset of zeroth channel used for TX.
+ * @n_wanted_channels: Number of interrupts efx_probe_interrupts() attempted
+ *     to enable.
+ * @n_rx_netqs: Number of receive NETQs (only in VMware port)
  * @rx_buffer_len: RX buffer length
  * @rx_buffer_order: Order (log2) of number of pages for each RX buffer
+ * @rx_buffer_hash_size: Size of hash at start of RX buffer
+ * @rx_hash_key: Toeplitz hash key for RSS
+ * @rx_indir_table: Indirection table for RSS
+ * @errors: Error condition stats
+ * @int_error_count: Number of internal errors seen recently
+ * @int_error_expire: Time at which error count will be expired
  * @irq_status: Interrupt status buffer
- * @last_irq_cpu: Last CPU to handle interrupt.
- *	This register is written with the SMP processor ID whenever an
- *	interrupt is handled.  It is used by falcon_test_interrupt()
- *	to verify that an interrupt has occurred.
- * @spi_flash: SPI flash device
- *	This field will be %NULL if no flash device is present.
- * @spi_eeprom: SPI EEPROM device
- *	This field will be %NULL if no EEPROM device is present.
- * @spi_lock: SPI bus lock
- * @n_rx_nodesc_drop_cnt: RX no descriptor drop count
- * @nic_data: Hardware dependant state
- * @mac_lock: MAC access lock. Protects @port_enabled, @phy_mode,
- *	@port_inhibited, efx_monitor() and efx_reconfigure_port()
+ * @irq_level: IRQ level/index for IRQs not triggered by an event queue
+ * @selftest_work: Work item for asynchronous self-test
+ * @mtd_list: List of MTDs attached to the NIC
+ * @nic_data: Hardware dependent state
+ * @mac_lock: MAC access lock. Protects @port_enabled, @link_up, @phy_mode,
+ *	efx_monitor() and efx_mac_work()
+ * @mac_work: Work item for changing MAC promiscuity and multicast hash
  * @port_enabled: Port enabled indicator.
- *	Serialises efx_stop_all(), efx_start_all(), efx_monitor(),
- *	efx_phy_work(), and efx_mac_work() with kernel interfaces. Safe to read
- *	under any one of the rtnl_lock, mac_lock, or netif_tx_lock, but all
- *	three must be held to modify it.
- * @port_inhibited: If set, the netif_carrier is always off. Hold the mac_lock
+ *	Serialises efx_stop_all(), efx_start_all(), efx_monitor() and
+ *	efx_mac_work() with kernel interfaces. Safe to read under any
+ *	one of the rtnl_lock, mac_lock, or netif_tx_lock, but all three must
+ *	be held to modify it.
  * @port_initialized: Port initialized?
  * @net_dev: Operating system network device. Consider holding the rtnl lock
- * @rx_checksum_enabled: RX checksumming enabled
- * @netif_stop_count: Port stop count
- * @netif_stop_lock: Port stop lock
- * @mac_stats: MAC statistics. These include all statistics the MACs
- *	can provide.  Generic code converts these into a standard
- *	&struct net_device_stats.
  * @stats_buffer: DMA buffer for statistics
- * @stats_lock: Statistics update lock. Serialises statistics fetches
- * @stats_disable_count: Nest count for disabling statistics fetches
- * @mac_op: MAC interface
- * @mac_address: Permanent MAC address
  * @phy_type: PHY type
- * @phy_lock: PHY access lock
  * @phy_op: PHY interface
  * @phy_data: PHY private data (including PHY-specific stats)
  * @mdio: PHY MDIO interface
+ * @mdio_bus: PHY MDIO bus ID (only used by Siena)
  * @phy_mode: PHY operating mode. Serialised by @mac_lock.
- * @mac_up: MAC link state
- * @link_up: Link status
- * @link_fd: Link is full duplex
- * @link_fc: Actualy flow control flags
- * @link_speed: Link speed (Mbps)
+ * @link_advertising: Autonegotiation advertising flags
+ * @link_state: Current state of the link
  * @n_link_state_changes: Number of times the link has changed state
  * @promiscuous: Promiscuous flag. Protected by netif_tx_lock.
  * @multicast_hash: Multicast hash table
  * @wanted_fc: Wanted flow control flags
- * @phy_work: work item for dealing with PHY events
- * @mac_work: work item for dealing with MAC events
+ * @fc_disable: When non-zero flow control is disabled. Typically used to
+ *	ensure that network back pressure doesn't delay dma queue flushes.
+ *	Serialised by the rtnl lock.
  * @loopback_mode: Loopback status
  * @loopback_modes: Supported loopback mode bitmask
  * @loopback_selftest: Offline self-test private state
- * @silicon_rev: Silicon revision description for driverlink
  * @dl_info: Linked list of hardware parameters exposed through driverlink
  * @dl_node: Driverlink port list
  * @dl_device_list: Driverlink device list
- * @dl_cb: Driverlink callbacks table
- * @dl_cb_dev: Driverlink callback owner devices
+ * @dl_event_handler: Driverlink device handling unrecognised events
+ * @debug_dir: NIC debugfs directory
+ * @debug_symlink: NIC debugfs sym-link (nic_eth\%d)
+ * @debug_port_dir: Port debugfs directory
+ * @debug_port_symlink: Port debugfs sym-link (if_eth\%d)
+ * @drain_pending: Count of RX and TX queues that haven't been flushed and drained.
+ * @rxq_flush_pending: Count of number of receive queues that need to be flushed.
+ *	Decremented when the efx_flush_rx_queue() is called.
+ * @rxq_flush_outstanding: Count of number of RX flushes started but not yet
+ *	completed (either success or failure). Not used when MCDI is used to
+ *	flush receive queues.
+ * @flush_wq: wait queue used by efx_nic_flush_queues() to wait for flush completions.
+ * @vf: Array of &struct efx_vf objects.
+ * @vf_count: Number of VFs to be enabled.
+ * @vf_init_count: Number of VFs that have been fully initialised.
+ * @vi_scale: log2 number of vnics per VF.
+ * @vf_buftbl_base: The zeroth buffer table index used to back VF queues.
+ * @vfdi_status: Common VFDI status page to be dmad to VF address space.
+ * @local_addr_list: List of local addresses. Protected by %local_lock.
+ * @local_page_list: List of DMA addressable pages used to broadcast
+ *	%local_addr_list. Protected by %local_lock.
+ * @local_lock: Mutex protecting %local_addr_list and %local_page_list.
+ * @peer_work: Work item to broadcast peer addresses to VMs.
+ * @ptp_data: PTP state data
+ * @monitor_work: Hardware monitor workitem
+ * @biu_lock: BIU (bus interface unit) lock
+ * @last_irq_cpu: Last CPU to handle a possible test interrupt.  This
+ *	field is used by efx_test_interrupts() to verify that an
+ *	interrupt has occurred.
+ * @n_rx_nodesc_drop_cnt: RX no descriptor drop count
+ * @mac_stats: MAC statistics. These include all statistics the MACs
+ *	can provide.  Generic code converts these into a standard
+ *	&struct net_device_stats.
+ * @stats_lock: Statistics update lock. Serialises statistics fetches
+ *	and access to @mac_stats.
  *
- * The @priv field of the corresponding &struct net_device points to
- * this.
+ * This is stored in the private area of the &struct net_device.
  */
 struct efx_nic {
+	/* The following fields should be written very rarely */
+
 	char name[IFNAMSIZ];
 	struct pci_dev *pci_dev;
 	const struct efx_nic_type *type;
 	int legacy_irq;
-	struct workqueue_struct *workqueue;
-	char workqueue_name[16];
+	bool legacy_irq_enabled;
 	struct work_struct reset_work;
-	struct delayed_work monitor_work;
 	resource_size_t membase_phys;
 	void __iomem *membase;
-	spinlock_t biu_lock;
+
 	enum efx_int_mode interrupt_mode;
+	unsigned int timer_quantum_ns;
 	bool irq_rx_adaptive;
 	unsigned int irq_rx_moderation;
-
-	struct i2c_adapter i2c_adap;
-	struct efx_board board_info;
+	u32 msg_enable;
+	u32 caps;
 
 	enum nic_state state;
-	enum reset_type reset_pending;
+	unsigned long reset_pending;
 
-	struct efx_tx_queue tx_queue[EFX_TX_QUEUE_COUNT];
-	struct efx_rx_queue rx_queue[EFX_MAX_RX_QUEUES];
-	struct efx_channel channel[EFX_MAX_CHANNELS];
+	struct efx_channel *channel[EFX_MAX_CHANNELS];
+	char channel_name[EFX_MAX_CHANNELS][IFNAMSIZ + 6];
+	const struct efx_channel_type *
+	extra_channel_type[EFX_MAX_EXTRA_CHANNELS];
 
-	int n_rx_queues;
-	int n_channels;
+	unsigned rxq_entries;
+	unsigned txq_entries;
+
+	unsigned tx_dc_entries;
+	unsigned rx_dc_entries;
+	unsigned tx_dc_base;
+	unsigned rx_dc_base;
+	unsigned sram_lim;
+	unsigned next_buffer_table;
+	struct efx_dl_falcon_resources resources;
+
+	unsigned n_channels;
+	unsigned n_rx_channels;
+	unsigned n_rss_channels;
+	unsigned rss_spread;
+	unsigned n_tx_channels;
+	unsigned tx_channel_offset;
+	unsigned n_wanted_channels;
 	unsigned int rx_buffer_len;
 	unsigned int rx_buffer_order;
+	unsigned int rx_buffer_hash_size;
+	u8 rx_hash_key[40];
+	u32 rx_indir_table[128];
+
+	struct efx_nic_errors errors;
+	unsigned int_error_count;
+	unsigned long int_error_expire;
 
 	struct efx_buffer irq_status;
-	volatile signed int last_irq_cpu;
+	unsigned irq_zero_count;
+	unsigned long irq_level;
+	struct delayed_work selftest_work;
 
-	struct efx_spi_device *spi_flash;
-	struct efx_spi_device *spi_eeprom;
-	struct mutex spi_lock;
+#ifdef CONFIG_SFC_MTD
+	struct list_head mtd_list;
+#endif
 
-	unsigned n_rx_nodesc_drop_cnt;
+#if defined(EFX_USE_KCOMPAT) && \
+	(defined(EFX_NEED_PCI_VPD_ATTR) || defined(EFX_NEED_PCI_READ_VPD))
+	struct pci_vpd_pci22 *vpd;
+#endif
 
-	struct falcon_nic_data *nic_data;
+	void *nic_data;
 
 	struct mutex mac_lock;
 	struct work_struct mac_work;
 	bool port_enabled;
-	bool port_inhibited;
 
 	bool port_initialized;
 	struct net_device *net_dev;
 	bool rx_checksum_enabled;
+#if defined(EFX_USE_KCOMPAT) && !defined(NETIF_F_LRO)
+	bool lro_enabled;
+#endif
 
-	atomic_t netif_stop_count;
-	spinlock_t netif_stop_lock;
+	struct efx_buffer stats_buffer;
 
-	struct efx_mac_stats mac_stats;
-	struct efx_buffer stats_buffer;
-	spinlock_t stats_lock;
-	unsigned int stats_disable_count;
-
-	struct efx_mac_operations *mac_op;
-	unsigned char mac_address[ETH_ALEN];
-
-	enum phy_type phy_type;
-	spinlock_t phy_lock;
-	struct work_struct phy_work;
-	struct efx_phy_operations *phy_op;
+	unsigned int phy_type;
+	char phy_name[20];
+	const struct efx_phy_operations *phy_op;
 	void *phy_data;
 	struct mdio_if_info mdio;
+	unsigned int mdio_bus;
 	enum efx_phy_mode phy_mode;
 
-	bool mac_up;
-	bool link_up;
-	bool link_fd;
-	enum efx_fc_type link_fc;
-	unsigned int link_speed;
+	u32 link_advertising;
+	struct efx_link_state link_state;
 	unsigned int n_link_state_changes;
 
 	bool promiscuous;
 	union efx_multicast_hash multicast_hash;
 	enum efx_fc_type wanted_fc;
+	unsigned fc_disable;
 
-	atomic_t rx_reset;
 	enum efx_loopback_mode loopback_mode;
-	unsigned int loopback_modes;
-
+	u64 loopback_modes;
+	unsigned int startup_loopback_mode;
 	void *loopback_selftest;
 
-	const char *silicon_rev;
-#ifdef CONFIG_SFC_DRIVERLINK
+	struct efx_filter_state *filter_state;
+
 	struct efx_dl_device_info *dl_info;
 	struct list_head dl_node;
 	struct list_head dl_device_list;
-	struct efx_dl_callbacks dl_cb;
-	struct efx_dl_cb_devices dl_cb_dev;
-#endif
+	struct efx_dl_device *dl_event_handler;
+
+	atomic_t drain_pending;
+	atomic_t rxq_flush_pending;
+	atomic_t rxq_flush_outstanding;
+	wait_queue_head_t flush_wq;
+
+	struct efx_channel *vfdi_channel;
+	struct efx_vf *vf;
+	unsigned vf_count;
+	unsigned vf_init_count;
+	unsigned vi_scale;
+	unsigned vf_buftbl_base;
+	struct efx_buffer vfdi_status;
+	struct list_head local_addr_list;
+	struct list_head local_page_list;
+	struct mutex local_lock;
+	struct work_struct peer_work;
+	struct efx_ptp_data *ptp_data;
+	struct efx_dl_siena_sriov sriov_resources;
+
+	/* The following fields may be written more often */
+
+	struct delayed_work monitor_work ____cacheline_aligned_in_smp;
+	spinlock_t biu_lock;
+	int last_irq_cpu;
+	unsigned n_rx_nodesc_drop_cnt;
+	struct efx_mac_stats mac_stats;
+	spinlock_t stats_lock;
 };
 
 static inline int efx_dev_registered(struct efx_nic *efx)
@@ -867,59 +969,116 @@ static inline int efx_dev_registered(str
 	return efx->net_dev->reg_state == NETREG_REGISTERED;
 }
 
-/* Net device name, for inclusion in log messages if it has been registered.
- * Use efx->name not efx->net_dev->name so that races with (un)registration
- * are harmless.
- */
-static inline const char *efx_dev_name(struct efx_nic *efx)
+static inline unsigned int efx_port_num(struct efx_nic *efx)
 {
-	return efx_dev_registered(efx) ? efx->name : "";
+	return efx->net_dev->dev_id;
 }
 
+struct efx_nic_register_mask;
+struct efx_nic_table_mask;
+
 /**
  * struct efx_nic_type - Efx device type definition
- * @mem_bar: Memory BAR number
+ * @probe: Probe the controller
+ * @remove: Free resources allocated by probe()
+ * @init: Initialise the controller
+ * @dimension_resources: Dimension controller resources (buffer table,
+ *	and VIs once the available interrupt resources are clear)
+ * @fini: Shut down the controller
+ * @monitor: Periodic function for polling link state and hardware monitor
+ * @map_reset_reason: Map ethtool reset reason to a reset method
+ * @map_reset_flags: Map ethtool reset flags to a reset method, if possible
+ * @reset: Reset the controller hardware and possibly the PHY.  This will
+ *	be called while the controller is uninitialised.
+ * @probe_port: Probe the MAC and PHY
+ * @remove_port: Free resources allocated by probe_port()
+ * @handle_global_event: Handle a "global" event (may be %NULL)
+ * @prepare_flush: Prepare the hardware for flushing the DMA queues
+ * @update_stats: Update statistics not provided by event handling
+ * @start_stats: Start the regular fetching of statistics
+ * @stop_stats: Stop the regular fetching of statistics
+ * @set_id_led: Set state of identifying LED or revert to automatic function
+ * @push_irq_moderation: Apply interrupt moderation value
+ * @reconfigure_port: Push loopback/power/txdis changes to the MAC and PHY
+ * @reconfigure_mac: Push MAC address, MTU, flow control and filter settings
+ *	to the hardware.  Serialised by the mac_lock.
+ * @check_mac_fault: Check MAC fault state. True if fault present.
+ * @get_wol: Get WoL configuration from driver state
+ * @set_wol: Push WoL configuration to the NIC
+ * @resume_wol: Synchronise WoL state between driver and MC (e.g. after resume)
+ * @test_registers: Test read/write functionality of control registers
+ * @test_memory: Test read/write functionality of memory blocks, using
+ *	the given test pattern generator
+ * @test_nvram: Test validity of NVRAM contents
+ * @revision: Hardware architecture revision
+ * @dl_revision: Driverlink revision string
  * @mem_map_size: Memory BAR mapped size
  * @txd_ptr_tbl_base: TX descriptor ring base address
  * @rxd_ptr_tbl_base: RX descriptor ring base address
  * @buf_tbl_base: Buffer table base address
  * @evq_ptr_tbl_base: Event queue pointer table base address
  * @evq_rptr_tbl_base: Event queue read-pointer table base address
- * @txd_ring_mask: TX descriptor ring size - 1 (must be a power of two - 1)
- * @rxd_ring_mask: RX descriptor ring size - 1 (must be a power of two - 1)
- * @evq_size: Event queue size (must be a power of two)
  * @max_dma_mask: Maximum possible DMA mask
- * @tx_dma_mask: TX DMA mask
- * @bug5391_mask: Address mask for bug 5391 workaround
- * @rx_xoff_thresh: RX FIFO XOFF watermark (bytes)
- * @rx_xon_thresh: RX FIFO XON watermark (bytes)
- * @rx_buffer_padding: Padding added to each RX buffer
+ * @rx_buffer_hash_size: Size of hash at start of RX buffer
+ * @rx_buffer_padding: Size of padding at end of RX buffer
  * @max_interrupt_mode: Highest capability interrupt mode supported
  *	from &enum efx_init_mode.
  * @phys_addr_channels: Number of channels with physically addressed
  *	descriptors
+ * @timer_period_max: Maximum period of interrupt timer (in ticks)
+ * @resources: Resources to be shared via driverlink (copied and
+ *	updated as efx_nic::resources)
+ * @offload_features: net_device feature flags for protocol offload
+ *	features implemented in hardware
  */
 struct efx_nic_type {
-	unsigned int mem_bar;
+	int (*probe)(struct efx_nic *efx);
+	int (*dimension_resources)(struct efx_nic *efx);
+	void (*remove)(struct efx_nic *efx);
+	int (*init)(struct efx_nic *efx);
+	void (*fini)(struct efx_nic *efx);
+	void (*monitor)(struct efx_nic *efx);
+	enum reset_type (*map_reset_reason)(enum reset_type reason);
+	int (*map_reset_flags)(u32 *flags);
+	int (*reset)(struct efx_nic *efx, enum reset_type method);
+	int (*probe_port)(struct efx_nic *efx);
+	void (*remove_port)(struct efx_nic *efx);
+	bool (*handle_global_event)(struct efx_channel *channel, efx_qword_t *);
+	void (*prepare_flush)(struct efx_nic *efx);
+	void (*update_stats)(struct efx_nic *efx);
+	void (*start_stats)(struct efx_nic *efx);
+	void (*stop_stats)(struct efx_nic *efx);
+	void (*set_id_led)(struct efx_nic *efx, enum efx_led_mode mode);
+	void (*push_irq_moderation)(struct efx_channel *channel);
+	int (*reconfigure_port)(struct efx_nic *efx);
+	int (*reconfigure_mac)(struct efx_nic *efx);
+	bool (*check_mac_fault)(struct efx_nic *efx);
+	void (*get_wol)(struct efx_nic *efx, struct ethtool_wolinfo *wol);
+	int (*set_wol)(struct efx_nic *efx, u32 type);
+	void (*resume_wol)(struct efx_nic *efx);
+	int (*test_registers)(struct efx_nic *efx);
+	int (*test_memory)(struct efx_nic *efx,
+			   void (*pattern)(unsigned, efx_qword_t *, int, int),
+			   int a, int b);
+	int (*test_nvram)(struct efx_nic *efx);
+
+	int revision;
+	const char *dl_revision;
 	unsigned int mem_map_size;
 	unsigned int txd_ptr_tbl_base;
 	unsigned int rxd_ptr_tbl_base;
 	unsigned int buf_tbl_base;
 	unsigned int evq_ptr_tbl_base;
 	unsigned int evq_rptr_tbl_base;
-
-	unsigned int txd_ring_mask;
-	unsigned int rxd_ring_mask;
-	unsigned int evq_size;
 	u64 max_dma_mask;
-	unsigned int tx_dma_mask;
-	unsigned bug5391_mask;
-
-	int rx_xoff_thresh;
-	int rx_xon_thresh;
+	unsigned int rx_buffer_hash_size;
 	unsigned int rx_buffer_padding;
 	unsigned int max_interrupt_mode;
 	unsigned int phys_addr_channels;
+	unsigned int timer_period_max;
+	struct efx_dl_falcon_resources resources;
+	struct efx_dl_hash_insertion dl_hash_insertion;
+	netdev_features_t offload_features;
 };
 
 /**************************************************************************
@@ -928,44 +1087,94 @@ struct efx_nic_type {
  *
  *************************************************************************/
 
+static inline struct efx_channel *
+efx_get_channel(struct efx_nic *efx, unsigned index)
+{
+	EFX_BUG_ON_PARANOID(index >= efx->n_channels);
+	return efx->channel[index];
+}
+
 /* Iterate over all used channels */
 #define efx_for_each_channel(_channel, _efx)				\
-	for (_channel = &_efx->channel[0];				\
-	     _channel < &_efx->channel[EFX_MAX_CHANNELS];		\
-	     _channel++)						\
-		if (!_channel->used_flags)				\
-			continue;					\
-		else
+	for (_channel = (_efx)->channel[0];				\
+	     _channel;							\
+	     _channel = (_channel->channel + 1 < (_efx)->n_channels) ?	\
+		     (_efx)->channel[_channel->channel + 1] : NULL)
 
-/* Iterate over all used TX queues */
-#define efx_for_each_tx_queue(_tx_queue, _efx)				\
-	for (_tx_queue = &_efx->tx_queue[0];				\
-	     _tx_queue < &_efx->tx_queue[EFX_TX_QUEUE_COUNT];		\
-	     _tx_queue++)
+/* Iterate over all used channels in reverse */
+#define efx_for_each_channel_rev(_channel, _efx)			\
+	for (_channel = (_efx)->channel[(_efx)->n_channels - 1];	\
+	     _channel;							\
+	     _channel = _channel->channel ?				\
+		     (_efx)->channel[_channel->channel - 1] : NULL)
+
+static inline struct efx_tx_queue *
+efx_get_tx_queue(struct efx_nic *efx, unsigned index, unsigned type)
+{
+	EFX_BUG_ON_PARANOID(index >= efx->n_tx_channels ||
+			    type >= EFX_TXQ_TYPES);
+	return &efx->channel[efx->tx_channel_offset + index]->tx_queue[type];
+}
+
+static inline bool efx_channel_has_tx_queues(struct efx_channel *channel)
+{
+	return channel->channel - channel->efx->tx_channel_offset <
+		channel->efx->n_tx_channels;
+}
+
+static inline struct efx_tx_queue *
+efx_channel_get_tx_queue(struct efx_channel *channel, unsigned type)
+{
+	EFX_BUG_ON_PARANOID(!efx_channel_has_tx_queues(channel) ||
+			    type >= EFX_TXQ_TYPES);
+	return &channel->tx_queue[type];
+}
 
 /* Iterate over all TX queues belonging to a channel */
 #define efx_for_each_channel_tx_queue(_tx_queue, _channel)		\
-	for (_tx_queue = &_channel->efx->tx_queue[0];			\
-	     _tx_queue < &_channel->efx->tx_queue[EFX_TX_QUEUE_COUNT];	\
-	     _tx_queue++)						\
-		if (_tx_queue->channel != _channel)			\
-			continue;					\
-		else
+	if (!efx_channel_has_tx_queues(_channel))			\
+		;							\
+	else								\
+		for (_tx_queue = (_channel)->tx_queue;			\
+		     _tx_queue < (_channel)->tx_queue + EFX_TXQ_TYPES;	\
+		     _tx_queue++)
 
-/* Iterate over all used RX queues */
-#define efx_for_each_rx_queue(_rx_queue, _efx)				\
-	for (_rx_queue = &_efx->rx_queue[0];				\
-	     _rx_queue < &_efx->rx_queue[_efx->n_rx_queues];		\
-	     _rx_queue++)
+static inline bool efx_channel_has_rx_queue(struct efx_channel *channel)
+{
+	return channel->rx_queue.core_index >= 0;
+}
+
+static inline struct efx_rx_queue *
+efx_channel_get_rx_queue(struct efx_channel *channel)
+{
+	EFX_BUG_ON_PARANOID(!efx_channel_has_rx_queue(channel));
+	return &channel->rx_queue;
+}
 
 /* Iterate over all RX queues belonging to a channel */
 #define efx_for_each_channel_rx_queue(_rx_queue, _channel)		\
-	for (_rx_queue = &_channel->efx->rx_queue[_channel->channel];	\
-	     _rx_queue;							\
-	     _rx_queue = NULL)						\
-		if (_rx_queue->channel != _channel)			\
-			continue;					\
-		else
+	if (!efx_channel_has_rx_queue(_channel))			\
+		;							\
+	else								\
+		for (_rx_queue = &(_channel)->rx_queue;			\
+		     _rx_queue;						\
+		     _rx_queue = NULL)
+
+/* Name formats */
+#define EFX_CHANNEL_NAME(_channel) "chan%d", (_channel)->channel
+#define EFX_TX_QUEUE_NAME(_tx_queue) "txq%d", (_tx_queue)->queue
+#define EFX_RX_QUEUE_NAME(_rx_queue) "rxq%d", efx_rx_queue_index(_rx_queue)
+
+static inline struct efx_channel *
+efx_rx_queue_channel(struct efx_rx_queue *rx_queue)
+{
+	return container_of(rx_queue, struct efx_channel, rx_queue);
+}
+
+static inline int efx_rx_queue_index(struct efx_rx_queue *rx_queue)
+{
+	return efx_rx_queue_channel(rx_queue)->channel;
+}
 
 /* Returns a pointer to the specified receive buffer in the RX
  * descriptor queue.
@@ -973,7 +1182,7 @@ struct efx_nic_type {
 static inline struct efx_rx_buffer *efx_rx_buffer(struct efx_rx_queue *rx_queue,
 						  unsigned int index)
 {
-	return (&rx_queue->buffer[index]);
+	return &rx_queue->buffer[index];
 }
 
 /* Set bit in a little-endian bitfield */
@@ -998,7 +1207,7 @@ static inline void clear_bit_le(unsigned
  * that the net driver will program into the MAC as the maximum frame
  * length.
  *
- * The 10G MAC used in Falcon requires 8-byte alignment on the frame
+ * The 10G MAC requires 8-byte alignment on the frame
  * length, so we round up to the nearest 8.
  *
  * Re-clocking by the XGXS on RX can reduce an IPG to 32 bits (half an
@@ -1010,4 +1219,36 @@ static inline void clear_bit_le(unsigned
 	((((mtu) + ETH_HLEN + VLAN_HLEN + 4/* FCS */ + 7) & ~7) + 16)
 
 
+#if   defined(CONFIG_SFC_PTP) && defined(EFX_HAVE_NET_TSTAMP) && !defined(EFX_HAVE_SKBTX_HW_TSTAMP)
+	static inline bool efx_xmit_with_hwtstamp(struct sk_buff *skb)
+	{
+		return skb_shinfo(skb)->tx_flags.hardware;
+	}
+	static inline void efx_xmit_hwtstamp_pending(struct sk_buff *skb)
+	{
+		skb_shinfo(skb)->tx_flags.in_progress = 1;
+	}
+#elif defined(CONFIG_SFC_PTP)
+	/* No kernel timestamping: must examine the sk_buff */
+	static inline bool efx_xmit_with_hwtstamp(struct sk_buff *skb)
+	{
+		return (likely(skb->protocol == htons(ETH_P_IP)) &&
+		ip_hdr(skb)->protocol == IPPROTO_UDP &&
+		unlikely(udp_hdr(skb)->dest == htons(319) ||
+		 udp_hdr(skb)->dest == htons(320)));
+
+	}
+	static inline void efx_xmit_hwtstamp_pending(struct sk_buff *skb)
+	{
+	}
+#else
+	static inline bool efx_xmit_with_hwtstamp(struct sk_buff *skb)
+	{
+		return false;
+	}
+	static inline void efx_xmit_hwtstamp_pending(struct sk_buff *skb)
+	{
+	}
+#endif
+
 #endif /* EFX_NET_DRIVER_H */
diff -r 9566a4a50a43 drivers/net/sfc/nic.c
--- /dev/null
+++ b/drivers/net/sfc/nic.c
@@ -0,0 +1,2263 @@
+/****************************************************************************
+ * Driver for Solarflare Solarstorm network controllers and boards
+ * Copyright 2005-2006 Fen Systems Ltd.
+ * Copyright 2006-2011 Solarflare Communications Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 as published
+ * by the Free Software Foundation, incorporated herein by reference.
+ */
+
+#include <linux/bitops.h>
+#include <linux/delay.h>
+#include <linux/pci.h>
+#include <linux/module.h>
+#include <linux/seq_file.h>
+#include "net_driver.h"
+#include "bitfield.h"
+#include "efx.h"
+#include "nic.h"
+#include "regs.h"
+#include "io.h"
+#include "workarounds.h"
+
+/**************************************************************************
+ *
+ * Configurable values
+ *
+ **************************************************************************
+ */
+
+/* Specify the size of the RX descriptor cache.
+ * Values 16, 32 and 64 are supported (8 won't work).
+ */
+int rx_desc_cache_size = 64;
+
+/* This is set to 16 for a good reason.  In summary, if larger than
+ * 16, the descriptor cache holds more than a default socket
+ * buffer's worth of packets (for UDP we can only have at most one
+ * socket buffer's worth outstanding).  This combined with the fact
+ * that we only get 1 TX event per descriptor cache means the NIC
+ * goes idle.
+ * 16 gives us up to 256 TXQs on Falcon B in internal-SRAM mode,
+ * and up to 512 on Falcon A.
+ */
+int tx_desc_cache_size = 16;
+
+
+/* If EFX_MAX_INT_ERRORS internal errors occur within
+ * EFX_INT_ERROR_EXPIRE seconds, we consider the NIC broken and
+ * disable it.
+ */
+#define EFX_INT_ERROR_EXPIRE 3600
+#define EFX_MAX_INT_ERRORS 5
+
+/* Depth of RX flush request fifo */
+#define EFX_RX_FLUSH_COUNT 4
+
+/* Driver generated events */
+#define _EFX_CHANNEL_MAGIC_TEST		0x000101
+#define _EFX_CHANNEL_MAGIC_FILL		0x000102
+#define _EFX_CHANNEL_MAGIC_RX_DRAIN	0x000103
+#define _EFX_CHANNEL_MAGIC_TX_DRAIN	0x000104
+
+#define _EFX_CHANNEL_MAGIC(_code, _data)			\
+	((_code) << 8 | (_data))
+#define _EFX_CHANNEL_MAGIC_CODE(_magic)				\
+	((_magic) >> 8)
+
+#define EFX_CHANNEL_MAGIC_TEST(_channel)			\
+	_EFX_CHANNEL_MAGIC(_EFX_CHANNEL_MAGIC_TEST,		\
+			   (_channel)->channel)
+#define EFX_CHANNEL_MAGIC_FILL(_rx_queue)			\
+	_EFX_CHANNEL_MAGIC(_EFX_CHANNEL_MAGIC_FILL,		\
+			   efx_rx_queue_index(_rx_queue))
+#define EFX_CHANNEL_MAGIC_RX_DRAIN(_rx_queue)			\
+	_EFX_CHANNEL_MAGIC(_EFX_CHANNEL_MAGIC_RX_DRAIN,		\
+			   efx_rx_queue_index(_rx_queue))
+#define EFX_CHANNEL_MAGIC_TX_DRAIN(_tx_queue)			\
+	_EFX_CHANNEL_MAGIC(_EFX_CHANNEL_MAGIC_TX_DRAIN,		\
+			   (_tx_queue)->queue)
+
+/**************************************************************************
+ *
+ * Solarstorm hardware access
+ *
+ **************************************************************************/
+
+/* Write to a buffer table entry, locking as appropriate. */
+static inline void efx_write_buf_tbl(struct efx_nic *efx, efx_qword_t *value,
+				     unsigned int index)
+{
+	efx_sram_writeq(efx, efx->membase + efx->type->buf_tbl_base,
+			value, index);
+}
+
+/* Read the current event from the event queue */
+static inline efx_qword_t *efx_event(struct efx_channel *channel,
+				     unsigned int index)
+{
+	return ((efx_qword_t *) (channel->eventq.addr)) +
+		(index & channel->eventq_mask);
+}
+
+/* See if an event is present
+ *
+ * We check both the high and low dword of the event for all ones.  We
+ * wrote all ones when we cleared the event, and no valid event can
+ * have all ones in either its high or low dwords.  This approach is
+ * robust against reordering.
+ *
+ * Note that using a single 64-bit comparison is incorrect; even
+ * though the CPU read will be atomic, the DMA write may not be.
+ */
+static inline int efx_event_present(efx_qword_t *event)
+{
+	return !(EFX_DWORD_IS_ALL_ONES(event->dword[0]) |
+		  EFX_DWORD_IS_ALL_ONES(event->dword[1]));
+}
+
+static bool efx_masked_compare_oword(const efx_oword_t *a, const efx_oword_t *b,
+				     const efx_oword_t *mask)
+{
+	return ((a->u64[0] ^ b->u64[0]) & mask->u64[0]) ||
+		((a->u64[1] ^ b->u64[1]) & mask->u64[1]);
+}
+
+int efx_nic_test_registers(struct efx_nic *efx,
+			   const struct efx_nic_register_test *regs,
+			   size_t n_regs)
+{
+	unsigned address = 0, i, j;
+	efx_oword_t mask, imask, original, reg, buf;
+
+	/* Falcon should be in loopback to isolate the XMAC from the PHY */
+	WARN_ON(!LOOPBACK_INTERNAL(efx));
+
+	for (i = 0; i < n_regs; ++i) {
+		address = regs[i].address;
+		mask = imask = regs[i].mask;
+		EFX_INVERT_OWORD(imask);
+
+		efx_reado(efx, &original, address);
+
+		/* bit sweep on and off */
+		for (j = 0; j < 128; j++) {
+			if (!EFX_EXTRACT_OWORD32(mask, j, j))
+				continue;
+
+			/* Test this testable bit can be set in isolation */
+			EFX_AND_OWORD(reg, original, mask);
+			EFX_SET_OWORD32(reg, j, j, 1);
+
+			efx_writeo(efx, &reg, address);
+			efx_reado(efx, &buf, address);
+
+			if (efx_masked_compare_oword(&reg, &buf, &mask))
+				goto fail;
+
+			/* Test this testable bit can be cleared in isolation */
+			EFX_OR_OWORD(reg, original, mask);
+			EFX_SET_OWORD32(reg, j, j, 0);
+
+			efx_writeo(efx, &reg, address);
+			efx_reado(efx, &buf, address);
+
+			if (efx_masked_compare_oword(&reg, &buf, &mask))
+				goto fail;
+		}
+
+		efx_writeo(efx, &original, address);
+	}
+
+	return 0;
+
+fail:
+	netif_err(efx, hw, efx->net_dev,
+		  "wrote "EFX_OWORD_FMT" read "EFX_OWORD_FMT
+		  " at address 0x%x mask "EFX_OWORD_FMT"\n", EFX_OWORD_VAL(reg),
+		  EFX_OWORD_VAL(buf), address, EFX_OWORD_VAL(mask));
+	return -EIO;
+}
+
+int efx_nic_test_table(struct efx_nic *efx,
+		       const struct efx_nic_table_test *table,
+		       void (*pattern)(unsigned, efx_qword_t *, int, int),
+		       int a, int b)
+{
+	efx_oword_t reg, buf;
+	int index;
+
+	/* write */
+	for (index = 0; index < table->rows; index += table->step) {
+		pattern(2 * index + 0, &reg.qword[0], a, b);
+		pattern(2 * index + 1, &reg.qword[1], a, b);
+		reg.u64[0] &= table->mask.u64[0];
+		reg.u64[1] &= table->mask.u64[1];
+
+		efx_writeo_table(efx, &reg, table->address, index);
+	}
+
+	/* verify */
+	for (index = 0; index < table->rows; index += table->step) {
+		pattern(2 * index + 0, &reg.qword[0], a, b);
+		pattern(2 * index + 1, &reg.qword[1], a, b);
+		reg.u64[0] &= table->mask.u64[0];
+		reg.u64[1] &= table->mask.u64[1];
+
+		efx_reado_table(efx, &buf, table->address, index);
+		if (memcmp(&reg, &buf, sizeof(reg))) {
+			netif_err(efx, hw, efx->net_dev,
+				  "table test failed at address 0x%x"
+				  " index 0x%x. wrote "EFX_OWORD_FMT
+				  " read "EFX_OWORD_FMT"\n",
+				  table->address, index,
+				  EFX_OWORD_VAL(reg), EFX_OWORD_VAL(buf));
+			return -EIO;
+		}
+	}
+
+	return 0;
+}
+
+/**************************************************************************
+ *
+ * Special buffer handling
+ * Special buffers are used for event queues and the TX and RX
+ * descriptor rings.
+ *
+ *************************************************************************/
+
+/*
+ * Initialise a special buffer
+ *
+ * This will define a buffer (previously allocated via
+ * efx_alloc_special_buffer()) in the buffer table, allowing
+ * it to be used for event queues, descriptor rings etc.
+ */
+static void
+efx_init_special_buffer(struct efx_nic *efx, struct efx_special_buffer *buffer)
+{
+	efx_qword_t buf_desc;
+	unsigned int index;
+	dma_addr_t dma_addr;
+	int i;
+
+	EFX_BUG_ON_PARANOID(!buffer->addr);
+
+	/* Write buffer descriptors to NIC */
+	for (i = 0; i < buffer->entries; i++) {
+		index = buffer->index + i;
+		dma_addr = buffer->dma_addr + (i * 4096);
+		netif_dbg(efx, probe, efx->net_dev,
+			  "mapping special buffer %d at %llx\n",
+			  index, (unsigned long long)dma_addr);
+		EFX_POPULATE_QWORD_3(buf_desc,
+				     FRF_AZ_BUF_ADR_REGION, 0,
+				     FRF_AZ_BUF_ADR_FBUF, dma_addr >> 12,
+				     FRF_AZ_BUF_OWNER_ID_FBUF, 0);
+		efx_write_buf_tbl(efx, &buf_desc, index);
+	}
+}
+
+/* Unmaps a buffer and clears the buffer table entries */
+static void
+efx_fini_special_buffer(struct efx_nic *efx, struct efx_special_buffer *buffer)
+{
+	efx_oword_t buf_tbl_upd;
+	unsigned int start = buffer->index;
+	unsigned int end = (buffer->index + buffer->entries - 1);
+
+	if (!buffer->entries)
+		return;
+
+	netif_dbg(efx, hw, efx->net_dev, "unmapping special buffers %d-%d\n",
+		  buffer->index, buffer->index + buffer->entries - 1);
+
+	EFX_POPULATE_OWORD_4(buf_tbl_upd,
+			     FRF_AZ_BUF_UPD_CMD, 0,
+			     FRF_AZ_BUF_CLR_CMD, 1,
+			     FRF_AZ_BUF_CLR_END_ID, end,
+			     FRF_AZ_BUF_CLR_START_ID, start);
+	efx_writeo(efx, &buf_tbl_upd, FR_AZ_BUF_TBL_UPD);
+}
+
+/*
+ * Allocate a new special buffer
+ *
+ * This allocates memory for a new buffer, clears it and allocates a
+ * new buffer ID range.  It does not write into the buffer table.
+ *
+ * This call will allocate 4KB buffers, since 8KB buffers can't be
+ * used for event queues and descriptor rings.
+ */
+static int efx_alloc_special_buffer(struct efx_nic *efx,
+				    struct efx_special_buffer *buffer,
+				    unsigned int len)
+{
+	len = ALIGN(len, EFX_BUF_SIZE);
+
+	buffer->addr = dma_alloc_coherent(&efx->pci_dev->dev, len,
+					  &buffer->dma_addr, GFP_KERNEL);
+	if (!buffer->addr)
+		return -ENOMEM;
+	buffer->len = len;
+	buffer->entries = len / EFX_BUF_SIZE;
+	BUG_ON(buffer->dma_addr & (EFX_BUF_SIZE - 1));
+	buffer->index = efx->next_buffer_table;
+
+	/* All zeros is a potentially valid event so memset to 0xff */
+	memset(buffer->addr, 0xff, len);
+
+	/* Select new buffer ID */
+	buffer->index = efx->next_buffer_table;
+	efx->next_buffer_table += buffer->entries;
+	BUG_ON(efx->vf_count && efx->vf_buftbl_base < efx->next_buffer_table);
+
+	netif_dbg(efx, hw, efx->net_dev,
+		  "allocated special buffers %d-%d at %llx+%x "
+		  "(virt %p phys %llx)\n", buffer->index,
+		  buffer->index + buffer->entries - 1,
+		  (u64)buffer->dma_addr, len,
+		  buffer->addr, (u64)virt_to_phys(buffer->addr));
+
+	return 0;
+}
+
+static void
+efx_free_special_buffer(struct efx_nic *efx, struct efx_special_buffer *buffer)
+{
+	if (!buffer->addr)
+		return;
+
+	netif_dbg(efx, hw, efx->net_dev,
+		  "deallocating special buffers %d-%d at %llx+%x "
+		  "(virt %p phys %llx)\n", buffer->index,
+		  buffer->index + buffer->entries - 1,
+		  (u64)buffer->dma_addr, buffer->len,
+		  buffer->addr, (u64)virt_to_phys(buffer->addr));
+
+	dma_free_coherent(&efx->pci_dev->dev, buffer->len, buffer->addr,
+			  buffer->dma_addr);
+	buffer->addr = NULL;
+	buffer->entries = 0;
+}
+
+/**************************************************************************
+ *
+ * Generic buffer handling
+ * These buffers are used for interrupt status and MAC stats
+ *
+ **************************************************************************/
+
+int efx_nic_alloc_buffer(struct efx_nic *efx, struct efx_buffer *buffer,
+			 unsigned int len)
+{
+	buffer->addr = pci_alloc_consistent(efx->pci_dev, len,
+					    &buffer->dma_addr);
+	if (!buffer->addr)
+		return -ENOMEM;
+	buffer->len = len;
+	memset(buffer->addr, 0, len);
+	return 0;
+}
+
+void efx_nic_free_buffer(struct efx_nic *efx, struct efx_buffer *buffer)
+{
+	if (buffer->addr) {
+		pci_free_consistent(efx->pci_dev, buffer->len,
+				    buffer->addr, buffer->dma_addr);
+		buffer->addr = NULL;
+	}
+}
+
+/**************************************************************************
+ *
+ * TX path
+ *
+ **************************************************************************/
+
+/* Returns a pointer to the specified transmit descriptor in the TX
+ * descriptor queue belonging to the specified channel.
+ */
+static inline efx_qword_t *
+efx_tx_desc(struct efx_tx_queue *tx_queue, unsigned int index)
+{
+	return ((efx_qword_t *) (tx_queue->txd.addr)) + index;
+}
+
+/* This writes to the TX_DESC_WPTR; write pointer for TX descriptor ring */
+static inline void efx_notify_tx_desc(struct efx_tx_queue *tx_queue)
+{
+	unsigned write_ptr;
+	efx_dword_t reg;
+
+	write_ptr = tx_queue->write_count & tx_queue->ptr_mask;
+	EFX_POPULATE_DWORD_1(reg, FRF_AZ_TX_DESC_WPTR_DWORD, write_ptr);
+	efx_writed_page(tx_queue->efx, &reg,
+			FR_AZ_TX_DESC_UPD_DWORD_P0, tx_queue->queue);
+}
+
+/* Write pointer and first descriptor for TX descriptor ring */
+static inline void efx_push_tx_desc(struct efx_tx_queue *tx_queue,
+				    const efx_qword_t *txd)
+{
+	unsigned write_ptr;
+	efx_oword_t reg;
+
+	BUILD_BUG_ON(FRF_AZ_TX_DESC_LBN != 0);
+	BUILD_BUG_ON(FR_AA_TX_DESC_UPD_KER != FR_BZ_TX_DESC_UPD_P0);
+
+	write_ptr = tx_queue->write_count & tx_queue->ptr_mask;
+	EFX_POPULATE_OWORD_2(reg, FRF_AZ_TX_DESC_PUSH_CMD, true,
+			     FRF_AZ_TX_DESC_WPTR, write_ptr);
+	reg.qword[0] = *txd;
+	efx_writeo_page(tx_queue->efx, &reg,
+			FR_BZ_TX_DESC_UPD_P0, tx_queue->queue);
+}
+
+static inline bool
+efx_may_push_tx_desc(struct efx_tx_queue *tx_queue, unsigned int write_count)
+{
+	unsigned empty_read_count = ACCESS_ONCE(tx_queue->empty_read_count);
+
+	if (empty_read_count == 0)
+		return false;
+
+	tx_queue->empty_read_count = 0;
+	return ((empty_read_count ^ write_count) & ~EFX_EMPTY_COUNT_VALID) == 0;
+}
+
+/* For each entry inserted into the software descriptor ring, create a
+ * descriptor in the hardware TX descriptor ring (in host memory), and
+ * write a doorbell.
+ */
+void efx_nic_push_buffers(struct efx_tx_queue *tx_queue)
+{
+	struct efx_tx_buffer *buffer;
+	efx_qword_t *txd;
+	unsigned write_ptr;
+	unsigned old_write_count = tx_queue->write_count;
+
+	BUG_ON(tx_queue->write_count == tx_queue->insert_count);
+
+	do {
+		write_ptr = tx_queue->write_count & tx_queue->ptr_mask;
+		buffer = &tx_queue->buffer[write_ptr];
+		txd = efx_tx_desc(tx_queue, write_ptr);
+		++tx_queue->write_count;
+
+		/* Create TX descriptor ring entry */
+		EFX_POPULATE_QWORD_4(*txd,
+				     FSF_AZ_TX_KER_CONT, buffer->continuation,
+				     FSF_AZ_TX_KER_BYTE_COUNT, buffer->len,
+				     FSF_AZ_TX_KER_BUF_REGION, 0,
+				     FSF_AZ_TX_KER_BUF_ADDR, buffer->dma_addr);
+	} while (tx_queue->write_count != tx_queue->insert_count);
+
+	wmb(); /* Ensure descriptors are written before they are fetched */
+
+	if (efx_may_push_tx_desc(tx_queue, old_write_count)) {
+		txd = efx_tx_desc(tx_queue,
+				  old_write_count & tx_queue->ptr_mask);
+		efx_push_tx_desc(tx_queue, txd);
+		++tx_queue->pushes;
+	} else {
+		efx_notify_tx_desc(tx_queue);
+	}
+}
+
+/* Allocate hardware resources for a TX queue */
+int efx_nic_probe_tx(struct efx_tx_queue *tx_queue)
+{
+	struct efx_nic *efx = tx_queue->efx;
+	unsigned entries;
+	int rc;
+
+	entries = tx_queue->ptr_mask + 1;
+	rc = efx_alloc_special_buffer(efx, &tx_queue->txd,
+				      entries * sizeof(efx_qword_t));
+	if (rc)
+		return rc;
+
+	efx->resources.txq_min = max(efx->resources.txq_min,
+				     (unsigned)tx_queue->queue + 1);
+
+	return 0;
+}
+
+void efx_nic_init_tx(struct efx_tx_queue *tx_queue)
+{
+	efx_oword_t tx_desc_ptr;
+	struct efx_nic *efx = tx_queue->efx;
+
+	/* Pin TX descriptor ring */
+	efx_init_special_buffer(efx, &tx_queue->txd);
+
+	/* Push TX descriptor ring to card */
+	EFX_POPULATE_OWORD_10(tx_desc_ptr,
+			      FRF_AZ_TX_DESCQ_EN, 1,
+			      FRF_AZ_TX_ISCSI_DDIG_EN, 0,
+			      FRF_AZ_TX_ISCSI_HDIG_EN, 0,
+			      FRF_AZ_TX_DESCQ_BUF_BASE_ID, tx_queue->txd.index,
+			      FRF_AZ_TX_DESCQ_EVQ_ID,
+			      tx_queue->channel->channel,
+			      FRF_AZ_TX_DESCQ_OWNER_ID, 0,
+			      FRF_AZ_TX_DESCQ_LABEL, tx_queue->queue,
+			      FRF_AZ_TX_DESCQ_SIZE,
+			      __ffs(tx_queue->txd.entries),
+			      FRF_AZ_TX_DESCQ_TYPE, 0,
+			      FRF_BZ_TX_NON_IP_DROP_DIS, 1);
+
+	if (efx_nic_rev(efx) >= EFX_REV_FALCON_B0) {
+		int csum = tx_queue->queue & EFX_TXQ_TYPE_OFFLOAD;
+		EFX_SET_OWORD_FIELD(tx_desc_ptr, FRF_BZ_TX_IP_CHKSM_DIS, !csum);
+		EFX_SET_OWORD_FIELD(tx_desc_ptr, FRF_BZ_TX_TCP_CHKSM_DIS,
+				    !csum);
+	}
+
+	efx_writeo_table(efx, &tx_desc_ptr, efx->type->txd_ptr_tbl_base,
+			 tx_queue->queue);
+
+	if (efx_nic_rev(efx) < EFX_REV_FALCON_B0) {
+		efx_oword_t reg;
+
+		/* Only 128 bits in this register */
+		BUILD_BUG_ON(EFX_MAX_TX_QUEUES > 128);
+
+		efx_reado(efx, &reg, FR_AA_TX_CHKSM_CFG);
+		if (tx_queue->queue & EFX_TXQ_TYPE_OFFLOAD)
+			clear_bit_le(tx_queue->queue, (void *)&reg);
+		else
+			set_bit_le(tx_queue->queue, (void *)&reg);
+		efx_writeo(efx, &reg, FR_AA_TX_CHKSM_CFG);
+	}
+}
+
+static void efx_flush_tx_queue(struct efx_tx_queue *tx_queue)
+{
+	struct efx_nic *efx = tx_queue->efx;
+	efx_oword_t tx_flush_descq;
+
+	EFX_POPULATE_OWORD_2(tx_flush_descq,
+			     FRF_AZ_TX_FLUSH_DESCQ_CMD, 1,
+			     FRF_AZ_TX_FLUSH_DESCQ, tx_queue->queue);
+	efx_writeo(efx, &tx_flush_descq, FR_AZ_TX_FLUSH_DESCQ);
+}
+
+void efx_nic_fini_tx(struct efx_tx_queue *tx_queue)
+{
+	struct efx_nic *efx = tx_queue->efx;
+	efx_oword_t tx_desc_ptr;
+
+	/* Remove TX descriptor ring from card */
+	EFX_ZERO_OWORD(tx_desc_ptr);
+	efx_writeo_table(efx, &tx_desc_ptr, efx->type->txd_ptr_tbl_base,
+			 tx_queue->queue);
+
+	/* Unpin TX descriptor ring */
+	efx_fini_special_buffer(efx, &tx_queue->txd);
+}
+
+/* Free buffers backing TX queue */
+void efx_nic_remove_tx(struct efx_tx_queue *tx_queue)
+{
+	efx_free_special_buffer(tx_queue->efx, &tx_queue->txd);
+}
+
+/**************************************************************************
+ *
+ * RX path
+ *
+ **************************************************************************/
+
+/* Returns a pointer to the specified descriptor in the RX descriptor queue */
+static inline efx_qword_t *
+efx_rx_desc(struct efx_rx_queue *rx_queue, unsigned int index)
+{
+	return ((efx_qword_t *) (rx_queue->rxd.addr)) + index;
+}
+
+/* This creates an entry in the RX descriptor queue */
+static inline void
+efx_build_rx_desc(struct efx_rx_queue *rx_queue, unsigned index)
+{
+	struct efx_rx_buffer *rx_buf;
+	efx_qword_t *rxd;
+
+	rxd = efx_rx_desc(rx_queue, index);
+	rx_buf = efx_rx_buffer(rx_queue, index);
+	EFX_POPULATE_QWORD_3(*rxd,
+			     FSF_AZ_RX_KER_BUF_SIZE,
+			     rx_buf->len -
+			     rx_queue->efx->type->rx_buffer_padding,
+			     FSF_AZ_RX_KER_BUF_REGION, 0,
+			     FSF_AZ_RX_KER_BUF_ADDR, rx_buf->dma_addr);
+}
+
+/* This writes to the RX_DESC_WPTR register for the specified receive
+ * descriptor ring.
+ */
+void efx_nic_notify_rx_desc(struct efx_rx_queue *rx_queue)
+{
+	struct efx_nic *efx = rx_queue->efx;
+	efx_dword_t reg;
+	unsigned write_ptr;
+
+	while (rx_queue->notified_count != rx_queue->added_count) {
+		efx_build_rx_desc(
+			rx_queue,
+			rx_queue->notified_count & rx_queue->ptr_mask);
+		++rx_queue->notified_count;
+	}
+
+	wmb();
+	write_ptr = rx_queue->added_count & rx_queue->ptr_mask;
+	EFX_POPULATE_DWORD_1(reg, FRF_AZ_RX_DESC_WPTR_DWORD, write_ptr);
+	efx_writed_page(efx, &reg, FR_AZ_RX_DESC_UPD_DWORD_P0,
+			efx_rx_queue_index(rx_queue));
+}
+
+int efx_nic_probe_rx(struct efx_rx_queue *rx_queue)
+{
+	struct efx_nic *efx = rx_queue->efx;
+	unsigned entries;
+	int rc;
+
+	entries = rx_queue->ptr_mask + 1;
+	rc = efx_alloc_special_buffer(efx, &rx_queue->rxd,
+				      entries * sizeof(efx_qword_t));
+	if (rc)
+		return rc;
+
+	/* Increment the rxq_min counter */
+	efx->resources.rxq_min = max(efx->resources.rxq_min,
+				     (unsigned)efx_rx_queue_index(rx_queue) + 1);
+
+	return 0;
+}
+
+void efx_nic_init_rx(struct efx_rx_queue *rx_queue)
+{
+	efx_oword_t rx_desc_ptr;
+	struct efx_nic *efx = rx_queue->efx;
+	bool is_b0 = efx_nic_rev(efx) >= EFX_REV_FALCON_B0;
+	bool iscsi_digest_en = is_b0;
+
+	netif_dbg(efx, hw, efx->net_dev,
+		  "RX queue %d ring in special buffers %d-%d\n",
+		  efx_rx_queue_index(rx_queue), rx_queue->rxd.index,
+		  rx_queue->rxd.index + rx_queue->rxd.entries - 1);
+
+	/* Pin RX descriptor ring */
+	efx_init_special_buffer(efx, &rx_queue->rxd);
+
+	/* Push RX descriptor ring to card */
+	EFX_POPULATE_OWORD_10(rx_desc_ptr,
+			      FRF_AZ_RX_ISCSI_DDIG_EN, iscsi_digest_en,
+			      FRF_AZ_RX_ISCSI_HDIG_EN, iscsi_digest_en,
+			      FRF_AZ_RX_DESCQ_BUF_BASE_ID, rx_queue->rxd.index,
+			      FRF_AZ_RX_DESCQ_EVQ_ID,
+			      efx_rx_queue_channel(rx_queue)->channel,
+			      FRF_AZ_RX_DESCQ_OWNER_ID, 0,
+			      FRF_AZ_RX_DESCQ_LABEL,
+			      efx_rx_queue_index(rx_queue),
+			      FRF_AZ_RX_DESCQ_SIZE,
+			      __ffs(rx_queue->rxd.entries),
+			      FRF_AZ_RX_DESCQ_TYPE, 0 /* kernel queue */ ,
+			      /* For >=B0 this is scatter so disable */
+			      FRF_AZ_RX_DESCQ_JUMBO, !is_b0,
+			      FRF_AZ_RX_DESCQ_EN, 1);
+	efx_writeo_table(efx, &rx_desc_ptr, efx->type->rxd_ptr_tbl_base,
+			 efx_rx_queue_index(rx_queue));
+}
+
+static void efx_flush_rx_queue(struct efx_rx_queue *rx_queue)
+{
+	struct efx_nic *efx = rx_queue->efx;
+	efx_oword_t rx_flush_descq;
+
+	EFX_POPULATE_OWORD_2(rx_flush_descq,
+			     FRF_AZ_RX_FLUSH_DESCQ_CMD, 1,
+			     FRF_AZ_RX_FLUSH_DESCQ,
+			     efx_rx_queue_index(rx_queue));
+	efx_writeo(efx, &rx_flush_descq, FR_AZ_RX_FLUSH_DESCQ);
+}
+
+void efx_nic_fini_rx(struct efx_rx_queue *rx_queue)
+{
+	efx_oword_t rx_desc_ptr;
+	struct efx_nic *efx = rx_queue->efx;
+
+	/* Remove RX descriptor ring from card */
+	EFX_ZERO_OWORD(rx_desc_ptr);
+	efx_writeo_table(efx, &rx_desc_ptr, efx->type->rxd_ptr_tbl_base,
+			 efx_rx_queue_index(rx_queue));
+
+	/* Unpin RX descriptor ring */
+	efx_fini_special_buffer(efx, &rx_queue->rxd);
+}
+
+/* Free buffers backing RX queue */
+void efx_nic_remove_rx(struct efx_rx_queue *rx_queue)
+{
+	efx_free_special_buffer(rx_queue->efx, &rx_queue->rxd);
+}
+
+/**************************************************************************
+ *
+ * Flush handling
+ *
+ **************************************************************************/
+
+/* efx_nic_flush_queues() must be woken up when all flushes are completed,
+ * or more RX flushes can be kicked off. */
+static bool efx_flush_wake(struct efx_nic *efx)
+{
+	/* Ensure that all updates are visible to efx_nic_flush_queues() */
+	smp_mb();
+
+	return (atomic_read(&efx->drain_pending) == 0 ||
+		(atomic_read(&efx->rxq_flush_outstanding) < EFX_RX_FLUSH_COUNT
+		 && atomic_read(&efx->rxq_flush_pending) > 0));
+}
+
+/* Wait for transmit queues to finish flushing and continue flushing receive
+ * queues until they're all flushed. Wait for the DRAIN events to be recieved
+ * so that there are no more RX and TX events left on any channel.
+ */
+static int efx_nic_flush_queues_wait(struct efx_nic *efx, unsigned timeout)
+{
+	struct efx_channel *channel;
+	struct efx_rx_queue *rx_queue;
+	int rc = 0;
+
+	while (timeout && atomic_read(&efx->drain_pending) > 0) {
+		/* If SRIOV is enabled, then offload receive queue flushing to
+		 * the firmware (though we will still have to poll for
+		 * completion). If that fails, fall back to the old scheme. */
+		if (efx->vf_count) {
+			rc = efx_mcdi_flush_rxqs(efx);
+			if (!rc)
+				goto wait;
+		}
+
+		/* The hardware supports four concurrent rx flushes, each of
+		 * which may need to be retried if there is an outstanding
+		 * descriptor fetch */
+		efx_for_each_channel(channel, efx) {
+			efx_for_each_channel_rx_queue(rx_queue, channel) {
+				if (atomic_read(&efx->rxq_flush_outstanding) >=
+				    EFX_RX_FLUSH_COUNT)
+					break;
+
+				if (rx_queue->flush_pending) {
+					rx_queue->flush_pending = false;
+					atomic_dec(&efx->rxq_flush_pending);
+					atomic_inc(&efx->rxq_flush_outstanding);
+					efx_flush_rx_queue(rx_queue);
+				}
+			}
+		}
+
+wait:
+		timeout = wait_event_timeout(efx->flush_wq, efx_flush_wake(efx),
+					     timeout);
+	}
+
+	return rc;
+}
+
+/* Flush all the transmit and receive queues.
+ */
+int efx_nic_flush_queues(struct efx_nic *efx)
+{
+	unsigned timeout = msecs_to_jiffies(EFX_MAX_FLUSH_TIME);
+	struct efx_channel *channel;
+	struct efx_rx_queue *rx_queue;
+	struct efx_tx_queue *tx_queue;
+	int rc = 0;
+
+	efx->fc_disable++;
+	efx->type->prepare_flush(efx);
+
+	efx_for_each_channel(channel, efx) {
+		efx_for_each_channel_tx_queue(tx_queue, channel) {
+			atomic_inc(&efx->drain_pending);
+			efx_flush_tx_queue(tx_queue);
+		}
+		efx_for_each_channel_rx_queue(rx_queue, channel) {
+			atomic_inc(&efx->drain_pending);
+			rx_queue->flush_pending = true;
+			atomic_inc(&efx->rxq_flush_pending);
+		}
+	}
+
+#ifdef __VMKLNX__
+	#define NUM_FLUSH_RETRIES 5
+	/* under VMware if it doesn't work then kick the event queues
+	 * and try again
+	 */
+	{
+		int i;
+		for (i = 0; i < NUM_FLUSH_RETRIES && rc == 0 &&
+			    atomic_read(&efx->drain_pending);
+		     ++i) {
+#endif
+	rc = efx_nic_flush_queues_wait(efx, timeout);
+#ifdef __VMKLNX__
+			if (rc == 0 && atomic_read(&efx->drain_pending)) {
+				netif_dbg(efx, hw, efx->net_dev, "stuck event queue suspected. restarting event queues\n");
+				efx_for_each_channel(channel, efx) {
+					efx_stop_eventq(channel);
+					efx_start_eventq(channel);
+				}
+			}
+		}
+	}
+#endif
+
+	if (rc == 0 && atomic_read(&efx->drain_pending)) {
+		netif_err(efx, hw, efx->net_dev, "failed to flush %d queues "
+			  "(rx %d+%d)\n", atomic_read(&efx->drain_pending),
+			  atomic_read(&efx->rxq_flush_outstanding),
+			  atomic_read(&efx->rxq_flush_pending));
+		rc = -ETIMEDOUT;
+
+		atomic_set(&efx->drain_pending, 0);
+		atomic_set(&efx->rxq_flush_pending, 0);
+		atomic_set(&efx->rxq_flush_outstanding, 0);
+	}
+
+	efx->fc_disable--;
+
+	return rc;
+}
+
+/**************************************************************************
+ *
+ * Event queue processing
+ * Event queues are processed by per-channel tasklets.
+ *
+ **************************************************************************/
+
+/* Update a channel's event queue's read pointer (RPTR) register
+ *
+ * This writes the EVQ_RPTR_REG register for the specified channel's
+ * event queue.
+ */
+void efx_nic_eventq_read_ack(struct efx_channel *channel)
+{
+	efx_dword_t reg;
+	struct efx_nic *efx = channel->efx;
+
+	EFX_POPULATE_DWORD_1(reg, FRF_AZ_EVQ_RPTR,
+			     channel->eventq_read_ptr & channel->eventq_mask);
+	efx_writed_table(efx, &reg, efx->type->evq_rptr_tbl_base,
+			 channel->channel);
+}
+
+/* Use HW to insert a SW defined event */
+void efx_generate_event(struct efx_nic *efx, unsigned int evq,
+			efx_qword_t *event)
+{
+	efx_oword_t drv_ev_reg;
+
+	BUILD_BUG_ON(FRF_AZ_DRV_EV_DATA_LBN != 0 ||
+		     FRF_AZ_DRV_EV_DATA_WIDTH != 64);
+	drv_ev_reg.u32[0] = event->u32[0];
+	drv_ev_reg.u32[1] = event->u32[1];
+	drv_ev_reg.u32[2] = 0;
+	drv_ev_reg.u32[3] = 0;
+	EFX_SET_OWORD_FIELD(drv_ev_reg, FRF_AZ_DRV_EV_QID, evq);
+	efx_writeo(efx, &drv_ev_reg, FR_AZ_DRV_EV);
+}
+
+static void efx_magic_event(struct efx_channel *channel, u32 magic)
+{
+	efx_qword_t event;
+
+	EFX_POPULATE_QWORD_2(event, FSF_AZ_EV_CODE,
+			     FSE_AZ_EV_CODE_DRV_GEN_EV,
+			     FSF_AZ_DRV_GEN_EV_MAGIC, magic);
+	efx_generate_event(channel->efx, channel->channel, &event);
+}
+
+/* Handle a transmit completion event
+ *
+ * The NIC batches TX completion events; the message we receive is of
+ * the form "complete all TX events up to this index".
+ */
+static int
+efx_handle_tx_event(struct efx_channel *channel, efx_qword_t *event)
+{
+	unsigned int tx_ev_desc_ptr;
+	unsigned int tx_ev_q_label;
+	struct efx_tx_queue *tx_queue;
+	struct efx_nic *efx = channel->efx;
+	int tx_packets = 0;
+
+	if (unlikely(ACCESS_ONCE(efx->reset_pending)))
+		return 0;
+
+	if (likely(EFX_QWORD_FIELD(*event, FSF_AZ_TX_EV_COMP))) {
+		/* Transmit completion */
+		tx_ev_desc_ptr = EFX_QWORD_FIELD(*event, FSF_AZ_TX_EV_DESC_PTR);
+		tx_ev_q_label = EFX_QWORD_FIELD(*event, FSF_AZ_TX_EV_Q_LABEL);
+		tx_queue = efx_channel_get_tx_queue(
+			channel, tx_ev_q_label % EFX_TXQ_TYPES);
+		tx_packets = ((tx_ev_desc_ptr - tx_queue->read_count) &
+			      tx_queue->ptr_mask);
+		efx_xmit_done(tx_queue, tx_ev_desc_ptr);
+	} else if (EFX_QWORD_FIELD(*event, FSF_AZ_TX_EV_WQ_FF_FULL)) {
+		/* Rewrite the FIFO write pointer */
+		tx_ev_q_label = EFX_QWORD_FIELD(*event, FSF_AZ_TX_EV_Q_LABEL);
+		tx_queue = efx_channel_get_tx_queue(
+			channel, tx_ev_q_label % EFX_TXQ_TYPES);
+
+		netif_tx_lock(efx->net_dev);
+		efx_notify_tx_desc(tx_queue);
+		netif_tx_unlock(efx->net_dev);
+	} else if (EFX_QWORD_FIELD(*event, FSF_AZ_TX_EV_PKT_ERR) &&
+		   EFX_WORKAROUND_10727(efx)) {
+		netif_err(efx, tx_err, efx->net_dev,
+			  "TX DMA Q reports TX_EV_PKT_ERR.\n");
+		efx_schedule_reset(efx, RESET_TYPE_TX_DESC_FETCH);
+	} else {
+		netif_err(efx, hw, efx->net_dev,
+			  "channel %d unexpected TX event "
+			  EFX_QWORD_FMT"\n", channel->channel,
+			  EFX_QWORD_VAL(*event));
+	}
+
+	return tx_packets;
+}
+
+/* Detect errors included in the rx_evt_pkt_ok bit. */
+static u16 efx_handle_rx_not_ok(struct efx_rx_queue *rx_queue,
+				const efx_qword_t *event)
+{
+	struct efx_channel *channel = efx_rx_queue_channel(rx_queue);
+	struct efx_nic *efx = rx_queue->efx;
+	bool rx_ev_buf_owner_id_err, rx_ev_ip_hdr_chksum_err;
+	bool rx_ev_tcp_udp_chksum_err, rx_ev_eth_crc_err;
+	bool rx_ev_frm_trunc, rx_ev_drib_nib, rx_ev_tobe_disc;
+	bool rx_ev_other_err, rx_ev_pause_frm;
+	bool rx_ev_ip_frag_err, rx_ev_hdr_type, rx_ev_mcast_pkt;
+	unsigned rx_ev_pkt_type;
+
+	rx_ev_hdr_type = EFX_QWORD_FIELD(*event, FSF_AZ_RX_EV_HDR_TYPE);
+	rx_ev_mcast_pkt = EFX_QWORD_FIELD(*event, FSF_AZ_RX_EV_MCAST_PKT);
+	rx_ev_tobe_disc = EFX_QWORD_FIELD(*event, FSF_AZ_RX_EV_TOBE_DISC);
+	rx_ev_pkt_type = EFX_QWORD_FIELD(*event, FSF_AZ_RX_EV_PKT_TYPE);
+	rx_ev_buf_owner_id_err = EFX_QWORD_FIELD(*event,
+						 FSF_AZ_RX_EV_BUF_OWNER_ID_ERR);
+	rx_ev_ip_frag_err = EFX_QWORD_FIELD(*event, FSF_AZ_RX_EV_IP_FRAG_ERR);
+	rx_ev_ip_hdr_chksum_err = EFX_QWORD_FIELD(*event,
+						  FSF_AZ_RX_EV_IP_HDR_CHKSUM_ERR);
+	rx_ev_tcp_udp_chksum_err = EFX_QWORD_FIELD(*event,
+						   FSF_AZ_RX_EV_TCP_UDP_CHKSUM_ERR);
+	rx_ev_eth_crc_err = EFX_QWORD_FIELD(*event, FSF_AZ_RX_EV_ETH_CRC_ERR);
+	rx_ev_frm_trunc = EFX_QWORD_FIELD(*event, FSF_AZ_RX_EV_FRM_TRUNC);
+	rx_ev_drib_nib = ((efx_nic_rev(efx) >= EFX_REV_FALCON_B0) ?
+			  0 : EFX_QWORD_FIELD(*event, FSF_AA_RX_EV_DRIB_NIB));
+	rx_ev_pause_frm = EFX_QWORD_FIELD(*event, FSF_AZ_RX_EV_PAUSE_FRM_ERR);
+
+	/* Every error apart from tobe_disc and pause_frm */
+	rx_ev_other_err = (rx_ev_drib_nib | rx_ev_tcp_udp_chksum_err |
+			   rx_ev_buf_owner_id_err | rx_ev_eth_crc_err |
+			   rx_ev_frm_trunc | rx_ev_ip_hdr_chksum_err);
+
+	/* Count errors that are not in MAC stats.  Ignore expected
+	 * checksum errors during self-test. */
+	if (rx_ev_frm_trunc)
+		++channel->n_rx_frm_trunc;
+	else if (rx_ev_tobe_disc)
+		++channel->n_rx_tobe_disc;
+	else if (!efx->loopback_selftest) {
+		if (rx_ev_eth_crc_err)
+			++channel->n_rx_eth_crc_err;
+		else if (rx_ev_ip_hdr_chksum_err)
+			++channel->n_rx_ip_hdr_chksum_err;
+		else if (rx_ev_tcp_udp_chksum_err)
+			++channel->n_rx_tcp_udp_chksum_err;
+	}
+	if (rx_ev_ip_frag_err)
+		++channel->n_rx_ip_frag;
+
+	/* TOBE_DISC is expected on unicast mismatches; don't print out an
+	 * error message.  FRM_TRUNC indicates RXDP dropped the packet due
+	 * to a FIFO overflow.
+	 */
+#ifdef DEBUG
+	if (rx_ev_other_err && net_ratelimit()) {
+		netif_dbg(efx, rx_err, efx->net_dev,
+			  " RX queue %d unexpected RX event "
+			  EFX_QWORD_FMT "%s%s%s%s%s%s%s%s\n",
+			  efx_rx_queue_index(rx_queue), EFX_QWORD_VAL(*event),
+			  rx_ev_buf_owner_id_err ? " [OWNER_ID_ERR]" : "",
+			  rx_ev_ip_hdr_chksum_err ?
+			  " [IP_HDR_CHKSUM_ERR]" : "",
+			  rx_ev_tcp_udp_chksum_err ?
+			  " [TCP_UDP_CHKSUM_ERR]" : "",
+			  rx_ev_eth_crc_err ? " [ETH_CRC_ERR]" : "",
+			  rx_ev_frm_trunc ? " [FRM_TRUNC]" : "",
+			  rx_ev_drib_nib ? " [DRIB_NIB]" : "",
+			  rx_ev_tobe_disc ? " [TOBE_DISC]" : "",
+			  rx_ev_pause_frm ? " [PAUSE]" : "");
+	}
+#endif
+
+	/* The frame must be discarded if any of these are true. */
+	return (rx_ev_eth_crc_err | rx_ev_frm_trunc | rx_ev_drib_nib |
+		rx_ev_tobe_disc | rx_ev_pause_frm) ?
+		EFX_RX_PKT_DISCARD : 0;
+}
+
+/* Handle receive events that are not in-order. */
+static void
+efx_handle_rx_bad_index(struct efx_rx_queue *rx_queue, unsigned index)
+{
+	struct efx_nic *efx = rx_queue->efx;
+	unsigned expected, dropped;
+
+	expected = rx_queue->removed_count & rx_queue->ptr_mask;
+	dropped = (index - expected) & rx_queue->ptr_mask;
+	netif_info(efx, hw, efx->net_dev,
+		   "dropped %d events (index=%d expected=%d)\n",
+		   dropped, index, expected);
+
+	atomic_inc(&efx->errors.missing_event);
+	efx_schedule_reset(efx, EFX_WORKAROUND_5676(efx) ?
+			   RESET_TYPE_RX_RECOVERY : RESET_TYPE_DISABLE);
+}
+
+/* Handle a packet received event
+ *
+ * The NIC gives a "discard" flag if it's a unicast packet with the
+ * wrong destination address
+ * Also "is multicast" and "matches multicast filter" flags can be used to
+ * discard non-matching multicast packets.
+ */
+static void
+efx_handle_rx_event(struct efx_channel *channel, const efx_qword_t *event)
+{
+	unsigned int rx_ev_desc_ptr, rx_ev_byte_cnt;
+	unsigned int rx_ev_hdr_type, rx_ev_pkt_type, rx_ev_mcast_pkt;
+	unsigned expected_ptr;
+	bool rx_ev_pkt_ok;
+	u16 flags;
+	struct efx_rx_queue *rx_queue;
+	struct efx_nic *efx = channel->efx;
+
+	if (unlikely(ACCESS_ONCE(efx->reset_pending)))
+		return;
+
+	/* Basic packet information */
+	rx_ev_byte_cnt = EFX_QWORD_FIELD(*event, FSF_AZ_RX_EV_BYTE_CNT);
+	rx_ev_pkt_ok = EFX_QWORD_FIELD(*event, FSF_AZ_RX_EV_PKT_OK);
+	rx_ev_hdr_type = EFX_QWORD_FIELD(*event, FSF_AZ_RX_EV_HDR_TYPE);
+	rx_ev_pkt_type = EFX_QWORD_FIELD(*event, FSF_AZ_RX_EV_PKT_TYPE);
+	WARN_ON(EFX_QWORD_FIELD(*event, FSF_AZ_RX_EV_JUMBO_CONT));
+	WARN_ON(EFX_QWORD_FIELD(*event, FSF_AZ_RX_EV_SOP) != 1);
+	WARN_ON(EFX_QWORD_FIELD(*event, FSF_AZ_RX_EV_Q_LABEL) !=
+		channel->channel);
+
+	rx_queue = efx_channel_get_rx_queue(channel);
+
+	rx_ev_desc_ptr = EFX_QWORD_FIELD(*event, FSF_AZ_RX_EV_DESC_PTR);
+	expected_ptr = rx_queue->removed_count & rx_queue->ptr_mask;
+	if (unlikely(rx_ev_desc_ptr != expected_ptr))
+		efx_handle_rx_bad_index(rx_queue, rx_ev_desc_ptr);
+
+	if (likely(rx_ev_pkt_ok)) {
+		/* If packet is marked as OK and packet type is TCP/IP or
+		 * UDP/IP, then we can rely on the hardware checksum.
+		 */
+		flags = (rx_ev_hdr_type == FSE_CZ_RX_EV_HDR_TYPE_IPV4V6_TCP ||
+			 rx_ev_hdr_type == FSE_CZ_RX_EV_HDR_TYPE_IPV4V6_UDP) ?
+			EFX_RX_PKT_CSUMMED : 0;
+	} else {
+		flags = efx_handle_rx_not_ok(rx_queue, event);
+	}
+
+	if (rx_ev_pkt_type >= FSE_AZ_RX_EV_PKT_TYPE_VLAN)
+		flags |= EFX_RX_PKT_VLAN;
+
+	/* Detect multicast packets that didn't match the filter */
+	rx_ev_mcast_pkt = EFX_QWORD_FIELD(*event, FSF_AZ_RX_EV_MCAST_PKT);
+	if (rx_ev_mcast_pkt) {
+		unsigned int rx_ev_mcast_hash_match =
+			EFX_QWORD_FIELD(*event, FSF_AZ_RX_EV_MCAST_HASH_MATCH);
+
+		if (unlikely(!rx_ev_mcast_hash_match)) {
+			++channel->n_rx_mcast_mismatch;
+			flags |= EFX_RX_PKT_DISCARD;
+		}
+	}
+
+	channel->irq_mod_score += 2;
+
+	/* Handle received packet */
+	efx_rx_packet(rx_queue, rx_ev_desc_ptr, rx_ev_byte_cnt, flags);
+}
+
+static void
+efx_handle_drain_event(struct efx_channel *channel)
+{
+	struct efx_nic *efx = channel->efx;
+
+	WARN_ON(atomic_read(&efx->drain_pending) == 0);
+	atomic_dec(&efx->drain_pending);
+	if (efx_flush_wake(efx))
+		wake_up(&efx->flush_wq);
+}
+
+static void
+efx_handle_generated_event(struct efx_channel *channel, efx_qword_t *event)
+{
+	struct efx_nic *efx = channel->efx;
+	struct efx_rx_queue *rx_queue =
+		efx_channel_has_rx_queue(channel) ?
+		efx_channel_get_rx_queue(channel) : NULL;
+	unsigned magic, code;
+
+	magic = EFX_QWORD_FIELD(*event, FSF_AZ_DRV_GEN_EV_MAGIC);
+	code = _EFX_CHANNEL_MAGIC_CODE(magic);
+
+	if (magic == EFX_CHANNEL_MAGIC_TEST(channel)) {
+		channel->event_test_cpu = raw_smp_processor_id();
+	} else if (rx_queue && magic == EFX_CHANNEL_MAGIC_FILL(rx_queue)) {
+		/* The queue must be empty, so we won't receive any rx
+		 * events, so efx_process_channel() won't refill the
+		 * queue. Refill it here */
+		efx_fast_push_rx_descriptors(rx_queue);
+	} else if (rx_queue && magic == EFX_CHANNEL_MAGIC_RX_DRAIN(rx_queue)) {
+		rx_queue->enabled = false;
+		efx_handle_drain_event(channel);
+	} else if (code == _EFX_CHANNEL_MAGIC_TX_DRAIN) {
+		efx_handle_drain_event(channel);
+	} else {
+		netif_dbg(efx, hw, efx->net_dev, "channel %d received "
+			  "generated event "EFX_QWORD_FMT"\n",
+			  channel->channel, EFX_QWORD_VAL(*event));
+	}
+}
+
+/* If this flush done event corresponds to a &struct efx_tx_queue, then
+ * send an %EFX_CHANNEL_MAGIC_TX_DRAIN event to drain the event queue
+ * of all transmit completions. */
+static void
+efx_handle_tx_flush_done(struct efx_nic *efx, efx_qword_t *event)
+{
+	struct efx_tx_queue *tx_queue;
+	int qid;
+
+	qid = EFX_QWORD_FIELD(*event, FSF_AZ_DRIVER_EV_SUBDATA);
+	if (qid < EFX_TXQ_TYPES * efx->n_tx_channels) {
+		tx_queue = efx_get_tx_queue(efx, qid / EFX_TXQ_TYPES,
+					    qid % EFX_TXQ_TYPES);
+
+		efx_magic_event(tx_queue->channel,
+				EFX_CHANNEL_MAGIC_TX_DRAIN(tx_queue));
+	}
+}
+
+/* If this flush done event corresponds to a &struct efx_rx_queue: If the flush
+ * was succesful then send an %EFX_CHANNEL_MAGIC_RX_DRAIN, otherwise add
+ * the RX queue back to the mask of RX queues in need of flushing. */
+static void
+efx_handle_rx_flush_done(struct efx_nic *efx, efx_qword_t *event)
+{
+	struct efx_channel *channel;
+	struct efx_rx_queue *rx_queue;
+	int qid;
+	bool failed;
+
+	qid = EFX_QWORD_FIELD(*event, FSF_AZ_DRIVER_EV_RX_DESCQ_ID);
+	failed = EFX_QWORD_FIELD(*event, FSF_AZ_DRIVER_EV_RX_FLUSH_FAIL);
+	if (qid >= efx->n_channels)
+		return;
+	channel = efx_get_channel(efx, qid);
+	if (!efx_channel_has_rx_queue(channel))
+		return;
+	rx_queue = efx_channel_get_rx_queue(channel);
+
+	if (failed) {
+		netif_info(efx, hw, efx->net_dev,
+			   "RXQ %d flush retry\n", qid);
+		rx_queue->flush_pending = true;
+		atomic_inc(&efx->rxq_flush_pending);
+	} else {
+		efx_magic_event(efx_rx_queue_channel(rx_queue),
+				EFX_CHANNEL_MAGIC_RX_DRAIN(rx_queue));
+	}
+	atomic_dec(&efx->rxq_flush_outstanding);
+	if (efx_flush_wake(efx))
+		wake_up(&efx->flush_wq);
+}
+
+static void
+efx_handle_driver_event(struct efx_channel *channel, efx_qword_t *event)
+{
+	struct efx_nic *efx = channel->efx;
+	unsigned int ev_sub_code;
+	unsigned int ev_sub_data;
+
+	ev_sub_code = EFX_QWORD_FIELD(*event, FSF_AZ_DRIVER_EV_SUBCODE);
+	ev_sub_data = EFX_QWORD_FIELD(*event, FSF_AZ_DRIVER_EV_SUBDATA);
+
+	switch (ev_sub_code) {
+	case FSE_AZ_TX_DESCQ_FLS_DONE_EV:
+		netif_vdbg(efx, hw, efx->net_dev, "channel %d TXQ %d flushed\n",
+			   channel->channel, ev_sub_data);
+		efx_handle_tx_flush_done(efx, event);
+		efx_sriov_tx_flush_done(efx, event);
+		efx_dl_handle_event(efx, event);
+		break;
+	case FSE_AZ_RX_DESCQ_FLS_DONE_EV:
+		netif_vdbg(efx, hw, efx->net_dev, "channel %d RXQ %d flushed\n",
+			   channel->channel, ev_sub_data);
+		efx_handle_rx_flush_done(efx, event);
+		efx_sriov_rx_flush_done(efx, event);
+		efx_dl_handle_event(efx, event);
+		break;
+	case FSE_AZ_EVQ_INIT_DONE_EV:
+		netif_dbg(efx, hw, efx->net_dev,
+			  "channel %d EVQ %d initialised\n",
+			  channel->channel, ev_sub_data);
+		break;
+	case FSE_AZ_SRM_UPD_DONE_EV:
+		netif_vdbg(efx, hw, efx->net_dev,
+			   "channel %d SRAM update done\n", channel->channel);
+		efx_dl_handle_event(efx, event);
+		break;
+	case FSE_AZ_WAKE_UP_EV:
+		netif_vdbg(efx, hw, efx->net_dev,
+			   "channel %d RXQ %d wakeup event\n",
+			   channel->channel, ev_sub_data);
+		efx_dl_handle_event(efx, event);
+		break;
+	case FSE_AZ_TIMER_EV:
+		netif_vdbg(efx, hw, efx->net_dev,
+			   "channel %d RX queue %d timer expired\n",
+			   channel->channel, ev_sub_data);
+		efx_dl_handle_event(efx, event);
+		break;
+	case FSE_AA_RX_RECOVER_EV:
+		netif_err(efx, hw, efx->net_dev,
+			  "channel %d seen DRIVER RX_RESET event. Resetting.\n",
+			  channel->channel);
+		atomic_inc(&efx->errors.rx_reset);
+		efx_schedule_reset(efx,
+				   EFX_WORKAROUND_6555(efx) ?
+				   RESET_TYPE_RX_RECOVERY :
+				   RESET_TYPE_DISABLE);
+		break;
+	case FSE_BZ_RX_DSC_ERROR_EV:
+		if (ev_sub_data < EFX_VI_BASE) {
+			netif_err(efx, rx_err, efx->net_dev,
+				  "RX DMA Q %d reports descriptor fetch error."
+				  " RX Q %d is disabled.\n", ev_sub_data,
+				  ev_sub_data);
+			atomic_inc(&efx->errors.rx_desc_fetch);
+			efx_schedule_reset(efx, RESET_TYPE_RX_DESC_FETCH);
+		} else
+			efx_sriov_desc_fetch_err(efx, ev_sub_data);
+		break;
+	case FSE_BZ_TX_DSC_ERROR_EV:
+		if (ev_sub_data < EFX_VI_BASE) {
+			netif_err(efx, tx_err, efx->net_dev,
+				  "TX DMA Q %d reports descriptor fetch error."
+				  " TX Q %d is disabled.\n", ev_sub_data,
+				  ev_sub_data);
+			atomic_inc(&efx->errors.tx_desc_fetch);
+			efx_schedule_reset(efx, RESET_TYPE_TX_DESC_FETCH);
+		} else
+			efx_sriov_desc_fetch_err(efx, ev_sub_data);
+		break;
+	default:
+		if (!efx_dl_handle_event(efx, event)) {
+			netif_vdbg(efx, hw, efx->net_dev,
+				   "channel %d unknown driver event"
+				   " code %d data %04x\n",
+				   channel->channel, ev_sub_code,
+				   ev_sub_data);
+		}
+		break;
+	}
+}
+
+int efx_nic_process_eventq(struct efx_channel *channel, int budget)
+{
+	struct efx_nic *efx = channel->efx;
+	unsigned int read_ptr;
+	efx_qword_t event, *p_event;
+	int ev_code;
+	int tx_packets = 0;
+	int spent = 0;
+
+	read_ptr = channel->eventq_read_ptr;
+
+	for (;;) {
+		p_event = efx_event(channel, read_ptr);
+		event = *p_event;
+
+		if (!efx_event_present(&event))
+			/* End of events */
+			break;
+
+		netif_vdbg(efx, hw, efx->net_dev, "channel %d event is "EFX_QWORD_FMT"\n",
+			  channel->channel, EFX_QWORD_VAL(event));
+
+		/* Clear this event by marking it all ones */
+		EFX_SET_QWORD(*p_event);
+
+		++read_ptr;
+
+		ev_code = EFX_QWORD_FIELD(event, FSF_AZ_EV_CODE);
+
+		switch (ev_code) {
+		case FSE_AZ_EV_CODE_RX_EV:
+			efx_handle_rx_event(channel, &event);
+			if (++spent == budget)
+				goto out;
+			break;
+		case FSE_AZ_EV_CODE_TX_EV:
+			tx_packets += efx_handle_tx_event(channel, &event);
+			if (tx_packets > efx->txq_entries) {
+				spent = budget;
+				goto out;
+			}
+			break;
+		case FSE_AZ_EV_CODE_DRV_GEN_EV:
+			efx_handle_generated_event(channel, &event);
+			break;
+		case FSE_AZ_EV_CODE_DRIVER_EV:
+			efx_handle_driver_event(channel, &event);
+			/* Currently, driverlink API does not allow us to
+			 * find the real "spent" number, but we do not want
+			 * to habdle here ALL char event, so let's linit
+			 * them in some way. */
+			if (++spent == budget)
+				goto out;
+			break;
+		case FSE_CZ_EV_CODE_USER_EV:
+			efx_sriov_event(channel, &event);
+			break;
+		case FSE_CZ_EV_CODE_MCDI_EV:
+			efx_mcdi_process_event(channel, &event);
+			break;
+		case FSE_AZ_EV_CODE_GLOBAL_EV:
+			if (efx->type->handle_global_event &&
+			    efx->type->handle_global_event(channel, &event))
+				break;
+			/* else fall through */
+		default:
+			netif_err(efx, hw, efx->net_dev,
+				  "channel %d unknown event type %d"
+				  " (data " EFX_QWORD_FMT ")\n",
+				  channel->channel, ev_code,
+				  EFX_QWORD_VAL(event));
+		}
+	}
+
+out:
+	channel->eventq_read_ptr = read_ptr;
+	return spent;
+}
+
+/* Check whether an event is present in the eventq at the current
+ * read pointer.  Only useful for self-test.
+ */
+bool efx_nic_event_present(struct efx_channel *channel)
+{
+	return efx_event_present(efx_event(channel, channel->eventq_read_ptr));
+}
+
+/* Allocate buffer table entries for event queue */
+int efx_nic_probe_eventq(struct efx_channel *channel)
+{
+	struct efx_nic *efx = channel->efx;
+	unsigned entries;
+	int rc;
+
+	entries = channel->eventq_mask + 1;
+	rc = efx_alloc_special_buffer(efx, &channel->eventq,
+				      entries * sizeof(efx_qword_t));
+	if (rc)
+		return rc;
+
+	efx->resources.evq_int_min = max(efx->resources.evq_int_min,
+					 (unsigned)channel->channel + 1);
+
+	return 0;
+}
+
+void efx_nic_init_eventq(struct efx_channel *channel)
+{
+	efx_oword_t reg;
+	struct efx_nic *efx = channel->efx;
+
+	netif_dbg(efx, hw, efx->net_dev,
+		  "channel %d event queue in special buffers %d-%d\n",
+		  channel->channel, channel->eventq.index,
+		  channel->eventq.index + channel->eventq.entries - 1);
+
+	if (efx_nic_rev(efx) >= EFX_REV_SIENA_A0) {
+		EFX_POPULATE_OWORD_3(reg,
+				     FRF_CZ_TIMER_Q_EN, 1,
+				     FRF_CZ_HOST_NOTIFY_MODE, 0,
+				     FRF_CZ_TIMER_MODE, FFE_CZ_TIMER_MODE_DIS);
+		efx_writeo_table(efx, &reg, FR_BZ_TIMER_TBL, channel->channel);
+	}
+
+	/* Pin event queue buffer */
+	efx_init_special_buffer(efx, &channel->eventq);
+
+	/* Fill event queue with all ones (i.e. empty events) */
+	memset(channel->eventq.addr, 0xff, channel->eventq.len);
+
+	/* Push event queue to card */
+	EFX_POPULATE_OWORD_3(reg,
+			     FRF_AZ_EVQ_EN, 1,
+			     FRF_AZ_EVQ_SIZE, __ffs(channel->eventq.entries),
+			     FRF_AZ_EVQ_BUF_BASE_ID, channel->eventq.index);
+	efx_writeo_table(efx, &reg, efx->type->evq_ptr_tbl_base,
+			 channel->channel);
+
+	efx->type->push_irq_moderation(channel);
+}
+
+void efx_nic_fini_eventq(struct efx_channel *channel)
+{
+	efx_oword_t reg;
+	struct efx_nic *efx = channel->efx;
+
+	/* Remove event queue from card */
+	EFX_ZERO_OWORD(reg);
+	efx_writeo_table(efx, &reg, efx->type->evq_ptr_tbl_base,
+			 channel->channel);
+	if (efx_nic_rev(efx) >= EFX_REV_SIENA_A0)
+		efx_writeo_table(efx, &reg, FR_BZ_TIMER_TBL, channel->channel);
+
+	/* Unpin event queue */
+	efx_fini_special_buffer(efx, &channel->eventq);
+}
+
+/* Free buffers backing event queue */
+void efx_nic_remove_eventq(struct efx_channel *channel)
+{
+	efx_free_special_buffer(channel->efx, &channel->eventq);
+}
+
+
+void efx_nic_event_test_start(struct efx_channel *channel)
+{
+	channel->event_test_cpu = -1;
+	smp_wmb();
+	efx_magic_event(channel, EFX_CHANNEL_MAGIC_TEST(channel));
+}
+
+void efx_nic_generate_fill_event(struct efx_rx_queue *rx_queue)
+{
+	efx_magic_event(efx_rx_queue_channel(rx_queue),
+			EFX_CHANNEL_MAGIC_FILL(rx_queue));
+}
+
+/**************************************************************************
+ *
+ * Hardware interrupts
+ * The hardware interrupt handler does very little work; all the event
+ * queue processing is carried out by per-channel tasklets.
+ *
+ **************************************************************************/
+
+/* Enable/disable/generate interrupts */
+static inline void efx_nic_interrupts(struct efx_nic *efx,
+				      bool enabled, bool force)
+{
+	efx_oword_t int_en_reg_ker;
+
+	EFX_POPULATE_OWORD_3(int_en_reg_ker,
+			     FRF_AZ_KER_INT_LEVE_SEL, efx->irq_level,
+			     FRF_AZ_KER_INT_KER, force,
+			     FRF_AZ_DRV_INT_EN_KER, enabled);
+	efx_writeo(efx, &int_en_reg_ker, FR_AZ_INT_EN_KER);
+}
+
+void efx_nic_enable_interrupts(struct efx_nic *efx)
+{
+	EFX_ZERO_OWORD(*((efx_oword_t *) efx->irq_status.addr));
+	wmb(); /* Ensure interrupt vector is clear before interrupts enabled */
+
+	efx_nic_interrupts(efx, true, false);
+}
+
+void efx_nic_disable_interrupts(struct efx_nic *efx)
+{
+	efx_nic_interrupts(efx, false, false);
+}
+
+/* Generate a test interrupt
+ * Interrupt must already have been enabled, otherwise nasty things
+ * may happen.
+ */
+void efx_nic_irq_test_start(struct efx_nic *efx)
+{
+	efx->last_irq_cpu = -1;
+	smp_wmb();
+	efx_nic_interrupts(efx, true, true);
+}
+
+/* Process a fatal interrupt
+ * Disable bus mastering ASAP and schedule a reset
+ */
+irqreturn_t efx_nic_fatal_interrupt(struct efx_nic *efx)
+{
+	struct falcon_nic_data *nic_data = efx->nic_data;
+	efx_oword_t *int_ker = efx->irq_status.addr;
+	efx_oword_t fatal_intr;
+	int error, mem_perr;
+
+	efx_reado(efx, &fatal_intr, FR_AZ_FATAL_INTR_KER);
+	error = EFX_OWORD_FIELD(fatal_intr, FRF_AZ_FATAL_INTR);
+
+	netif_err(efx, hw, efx->net_dev, "SYSTEM ERROR "EFX_OWORD_FMT" status "
+		  EFX_OWORD_FMT ": %s\n", EFX_OWORD_VAL(*int_ker),
+		  EFX_OWORD_VAL(fatal_intr),
+		  error ? "disabling bus mastering" : "no recognised error");
+
+	/* If this is a memory parity error dump which blocks are offending */
+	mem_perr = (EFX_OWORD_FIELD(fatal_intr, FRF_AZ_MEM_PERR_INT_KER) ||
+		    EFX_OWORD_FIELD(fatal_intr, FRF_AZ_SRM_PERR_INT_KER));
+	if (mem_perr) {
+		efx_oword_t reg;
+		efx_reado(efx, &reg, FR_AZ_MEM_STAT);
+		netif_err(efx, hw, efx->net_dev,
+			  "SYSTEM ERROR: memory parity error "EFX_OWORD_FMT"\n",
+			  EFX_OWORD_VAL(reg));
+	}
+
+	/* Disable both devices */
+	pci_clear_master(efx->pci_dev);
+	if (efx_nic_is_dual_func(efx))
+		pci_clear_master(nic_data->pci_dev2);
+	efx_nic_disable_interrupts(efx);
+
+	/* Count errors and reset or disable the NIC accordingly */
+	if (efx->int_error_count == 0 ||
+	    time_after(jiffies, efx->int_error_expire)) {
+		efx->int_error_count = 0;
+		efx->int_error_expire =
+			jiffies + EFX_INT_ERROR_EXPIRE * HZ;
+	}
+	if (++efx->int_error_count < EFX_MAX_INT_ERRORS) {
+		netif_err(efx, hw, efx->net_dev,
+			  "SYSTEM ERROR - reset scheduled\n");
+		efx_schedule_reset(efx, RESET_TYPE_INT_ERROR);
+	} else {
+		netif_err(efx, hw, efx->net_dev,
+			  "SYSTEM ERROR - max number of errors seen."
+			  "NIC will be disabled\n");
+		efx_schedule_reset(efx, RESET_TYPE_DISABLE);
+	}
+
+	return IRQ_HANDLED;
+}
+
+/* Handle a legacy interrupt
+ * Acknowledges the interrupt and schedule event queue processing.
+ *
+ * This routine must guarantee not to touch the hardware when
+ * interrupts are disabled, to allow for correct semantics of
+ * efx_suspend() and efx_resume().
+ */
+static irqreturn_t efx_legacy_interrupt(int irq, void *dev_id)
+{
+	struct efx_nic *efx = dev_id;
+	efx_oword_t *int_ker = efx->irq_status.addr;
+	irqreturn_t result = IRQ_NONE;
+	struct efx_channel *channel;
+	efx_dword_t reg;
+	u32 queues;
+	int syserr;
+
+	/* Could this be ours?  If interrupts are disabled then the
+	 * channel state may not be valid.
+	 */
+	if (!efx->legacy_irq_enabled)
+		return result;
+
+	/* Read the ISR which also ACKs the interrupts */
+	efx_readd(efx, &reg, FR_BZ_INT_ISR0);
+	queues = EFX_EXTRACT_DWORD(reg, 0, 31);
+
+	/* Handle non-event-queue sources */
+	if (queues & (1U << efx->irq_level)) {
+		syserr = EFX_OWORD_FIELD(*int_ker, FSF_AZ_NET_IVEC_FATAL_INT);
+		if (unlikely(syserr))
+			return efx_nic_fatal_interrupt(efx);
+		efx->last_irq_cpu = raw_smp_processor_id();
+	}
+
+	if (queues != 0) {
+		if (EFX_WORKAROUND_15783(efx))
+			efx->irq_zero_count = 0;
+
+		/* Schedule processing of any interrupting queues */
+		efx_for_each_channel(channel, efx) {
+			if (queues & 1)
+				efx_schedule_channel_irq(channel);
+			queues >>= 1;
+		}
+		result = IRQ_HANDLED;
+
+	} else if (EFX_WORKAROUND_15783(efx)) {
+		efx_qword_t *event;
+
+		/* We can't return IRQ_HANDLED more than once on seeing ISR=0
+		 * because this might be a shared interrupt. */
+		if (efx->irq_zero_count++ == 0)
+			result = IRQ_HANDLED;
+
+		/* Ensure we schedule or rearm all event queues */
+		efx_for_each_channel(channel, efx) {
+			event = efx_event(channel, channel->eventq_read_ptr);
+			if (efx_event_present(event))
+				efx_schedule_channel_irq(channel);
+			else
+				efx_nic_eventq_read_ack(channel);
+		}
+	}
+
+	if (result == IRQ_HANDLED)
+		netif_vdbg(efx, intr, efx->net_dev,
+			   "IRQ %d on CPU %d status " EFX_DWORD_FMT "\n",
+			   irq, raw_smp_processor_id(), EFX_DWORD_VAL(reg));
+
+	return result;
+}
+
+/* Handle an MSI interrupt
+ *
+ * Handle an MSI hardware interrupt.  This routine schedules event
+ * queue processing.  No interrupt acknowledgement cycle is necessary.
+ * Also, we never need to check that the interrupt is for us, since
+ * MSI interrupts cannot be shared.
+ *
+ * This routine must guarantee not to touch the hardware when
+ * interrupts are disabled, to allow for correct semantics of
+ * efx_suspend() and efx_resume().
+ */
+irqreturn_t efx_msi_interrupt(int irq, void *dev_id)
+{
+	struct efx_channel *channel = *(struct efx_channel **)dev_id;
+	struct efx_nic *efx = channel->efx;
+	efx_oword_t *int_ker = efx->irq_status.addr;
+	int syserr;
+
+	netif_vdbg(efx, intr, efx->net_dev,
+		   "IRQ %d on CPU %d status " EFX_OWORD_FMT "\n",
+		   irq, raw_smp_processor_id(), EFX_OWORD_VAL(*int_ker));
+
+	/* Handle non-event-queue sources */
+	if (channel->channel == efx->irq_level) {
+		syserr = EFX_OWORD_FIELD(*int_ker, FSF_AZ_NET_IVEC_FATAL_INT);
+		if (unlikely(syserr))
+			return efx_nic_fatal_interrupt(efx);
+		efx->last_irq_cpu = raw_smp_processor_id();
+	}
+
+	/* Schedule processing of the channel */
+	efx_schedule_channel_irq(channel);
+
+	return IRQ_HANDLED;
+}
+
+/* Setup RSS indirection table.
+ * This maps from the hash value of the packet to RXQ
+ */
+void efx_nic_push_rx_indir_table(struct efx_nic *efx)
+{
+	size_t i = 0;
+	efx_dword_t dword;
+
+	if (efx_nic_rev(efx) < EFX_REV_FALCON_B0)
+		return;
+
+	BUILD_BUG_ON(ARRAY_SIZE(efx->rx_indir_table) !=
+		     FR_BZ_RX_INDIRECTION_TBL_ROWS);
+
+	for (i = 0; i < FR_BZ_RX_INDIRECTION_TBL_ROWS; i++) {
+		EFX_POPULATE_DWORD_1(dword, FRF_BZ_IT_QUEUE,
+				     efx->rx_indir_table[i]);
+		efx_writed_table(efx, &dword, FR_BZ_RX_INDIRECTION_TBL, i);
+	}
+}
+
+/* Hook interrupt handler(s)
+ * Try MSI and then legacy interrupts.
+ */
+int efx_nic_init_interrupt(struct efx_nic *efx)
+{
+	struct efx_channel *channel;
+	int rc;
+
+	if (!EFX_INT_MODE_USE_MSI(efx)) {
+		irq_handler_t handler;
+		if (efx_nic_rev(efx) >= EFX_REV_FALCON_B0)
+			handler = efx_legacy_interrupt;
+		else
+			handler = falcon_legacy_interrupt_a1;
+
+		rc = request_irq(efx->legacy_irq, handler, IRQF_SHARED,
+				 efx->name, efx);
+		if (rc) {
+			netif_err(efx, drv, efx->net_dev,
+				  "failed to hook legacy IRQ %d\n",
+				  efx->pci_dev->irq);
+			goto fail1;
+		}
+		return 0;
+	}
+
+	/* Hook MSI or MSI-X interrupt */
+	efx_for_each_channel(channel, efx) {
+		rc = request_irq(channel->irq, efx_msi_interrupt,
+				 IRQF_PROBE_SHARED, /* Not shared */
+				 efx->channel_name[channel->channel],
+				 &efx->channel[channel->channel]);
+		if (rc) {
+			netif_err(efx, drv, efx->net_dev,
+				  "failed to hook IRQ %d\n", channel->irq);
+			goto fail2;
+		}
+	}
+
+	return 0;
+
+ fail2:
+	efx_for_each_channel(channel, efx)
+		free_irq(channel->irq, &efx->channel[channel->channel]);
+ fail1:
+	return rc;
+}
+
+void efx_nic_fini_interrupt(struct efx_nic *efx)
+{
+	struct efx_channel *channel;
+	efx_oword_t reg;
+
+	/* Disable MSI/MSI-X interrupts */
+	efx_for_each_channel(channel, efx) {
+		if (channel->irq)
+			free_irq(channel->irq, &efx->channel[channel->channel]);
+	}
+
+	/* ACK legacy interrupt */
+	if (efx_nic_rev(efx) >= EFX_REV_FALCON_B0)
+		efx_reado(efx, &reg, FR_BZ_INT_ISR0);
+	else
+		falcon_irq_ack_a1(efx);
+
+	/* Disable legacy interrupt */
+	if (efx->legacy_irq)
+		free_irq(efx->legacy_irq, efx);
+}
+
+/* Looks at available SRAM resources and works out how many queues we
+ * can support, and where things like descriptor caches should live.
+ *
+ * SRAM is split up as follows:
+ * 0                          buftbl entries for channels
+ * efx->vf_buftbl_base        buftbl entries for SR-IOV
+ * res->buftbl_min            buftbl entries for onload
+ * res->buftbl_lim            descriptor caches
+ */
+int efx_nic_dimension_resources(struct efx_nic *efx, size_t sram_size)
+{
+	struct efx_dl_falcon_resources *res = &efx->resources;
+	unsigned vi_dc_entries, vi_count, buftbl_free, dcs;
+	unsigned entries_per_vf, entries_per_vnic, vnic_limit;
+
+	efx->sram_lim = sram_size;
+
+	if (rx_desc_cache_size & (rx_desc_cache_size - 1) ||
+	    rx_desc_cache_size < 8 || rx_desc_cache_size > 64) {
+		netif_err(efx, drv, efx->net_dev,
+			  "bad rx_desc_cache_size=%d\n", rx_desc_cache_size);
+		return -EINVAL;
+	}
+	efx->rx_dc_entries = rx_desc_cache_size;
+
+	if (tx_desc_cache_size & (tx_desc_cache_size - 1) ||
+	    tx_desc_cache_size < 8 || tx_desc_cache_size > 32) {
+		netif_err(efx, drv, efx->net_dev,
+			  "bad tx_desc_cache_size=%d\n", tx_desc_cache_size);
+		return -EINVAL;
+	}
+	efx->tx_dc_entries = tx_desc_cache_size;
+	vi_dc_entries = efx->rx_dc_entries + efx->tx_dc_entries;
+
+	/* Account for the buffer table entries backing the datapath channels
+	 * and the descriptor caches for those channels. For simplicity assume
+	 * that all channels are fully populated with TX and RX queues */
+	efx->vf_buftbl_base =
+		(((EFX_TXQ_TYPES + 1) * EFX_MAX_DMAQ_SIZE + EFX_MAX_EVQ_SIZE) *
+		 efx->n_wanted_channels) * sizeof(efx_qword_t) / EFX_BUF_SIZE;
+	vi_count = res->evq_timer_min;
+	if (efx->vf_count)
+		vi_count = max_t(unsigned, vi_count, EFX_VI_BASE);
+	buftbl_free = (sram_size / 8) - efx->vf_buftbl_base -
+		vi_count * vi_dc_entries;
+
+	entries_per_vf = (vi_dc_entries + EFX_VF_BUFTBL_PER_VI) << efx->vi_scale;
+	/* VNICs exported through driverlink use an additional 512 entries per
+	 * VI for buffer table entries backing descriptors. */
+	entries_per_vnic = vi_dc_entries + 512 +
+		((2 * EFX_MAX_DMAQ_SIZE + EFX_MAX_EVQ_SIZE) *
+		 sizeof(efx_qword_t) / EFX_BUF_SIZE);
+
+	/* If there is buffer table left, then try and allocate VFs */
+	if (efx->vf_count) {
+		unsigned vf_limit = min(buftbl_free / entries_per_vf,
+					res->evq_timer_lim - vi_count);
+		vf_limit = min_t(unsigned, vf_limit, EFX_VF_COUNT_MAX);
+		vf_limit = min_t(unsigned, vf_limit,
+				 (1024 - EFX_VI_BASE) >> efx->vi_scale);
+
+		if (efx->vf_count > vf_limit) {
+			netif_err(efx, probe, efx->net_dev,
+				  "Reducing VF count from from %d to %d. "
+				  "Reduce rx_desc_cache_size, "
+				  "tx_desc_cache_size and/or target_num_vis\n",
+				  efx->vf_count, vf_limit);
+			efx->vf_count = vf_limit;
+		}
+		vi_count += efx->vf_count << efx->vi_scale;
+		buftbl_free -= efx->vf_count * entries_per_vf;
+	}
+
+	/* Export remaining buffer table through driverlink */
+	vnic_limit = min(buftbl_free / entries_per_vnic,
+			 res->evq_timer_lim - vi_count); 
+	vi_count += vnic_limit;
+	buftbl_free -= vnic_limit * entries_per_vnic;
+
+	dcs = vi_count * efx->tx_dc_entries * 8;
+	efx->tx_dc_base = sram_size - dcs;
+	dcs = vi_count * efx->rx_dc_entries * 8;
+	efx->rx_dc_base = efx->tx_dc_base - dcs;
+
+	res->buffer_table_min = efx->vf_buftbl_base +
+		entries_per_vf * efx->vf_count;
+	res->buffer_table_lim = min(res->buffer_table_lim,
+				    efx->rx_dc_base / 8);
+	if (res->buffer_table_lim < res->buffer_table_min)
+		res->buffer_table_min = res->buffer_table_lim;
+
+	res->rxq_lim = min(res->rxq_lim, vi_count);
+	res->txq_lim = min(res->txq_lim, vi_count);
+	if (efx->vf_count) {
+		unsigned vnic_base = EFX_VI_BASE +
+			(efx->vf_count << efx->vi_scale);
+
+		res->evq_timer_min = max_t(int, res->evq_timer_min, vnic_base);
+		res->evq_int_min = max_t(int, res->evq_int_min, vnic_base);
+		res->rxq_min = max_t(int, res->rxq_min, vnic_base);
+		res->txq_min = max_t(int, res->txq_min, vnic_base);
+	}
+	res->flags |= EFX_DL_FALCON_HAVE_RSS_CHANNEL_COUNT;
+	res->rss_channel_count = efx->rss_spread;
+
+	netif_dbg(efx, hw, efx->net_dev,
+		  "Available resources: RXQs [%u,%u), TXQs [%u,%u),"
+		  " buffer table entries [%u,%u)\n",
+		  res->evq_timer_min, res->rxq_lim,
+		  res->evq_timer_min, res->txq_lim,
+		  res->buffer_table_min, res->buffer_table_lim);
+
+	return 0;
+}
+
+u32 efx_nic_fpga_ver(struct efx_nic *efx)
+{
+	efx_oword_t altera_build;
+	efx_reado(efx, &altera_build, FR_AZ_ALTERA_BUILD);
+	return EFX_OWORD_FIELD(altera_build, FRF_AZ_ALTERA_BUILD_VER);
+}
+
+void efx_nic_init_common(struct efx_nic *efx)
+{
+	efx_oword_t temp;
+
+	/* Set positions of descriptor caches in SRAM. */
+	EFX_POPULATE_OWORD_1(temp, FRF_AZ_SRM_TX_DC_BASE_ADR,
+			     efx->tx_dc_base / 8);
+	efx_writeo(efx, &temp, FR_AZ_SRM_TX_DC_CFG);
+	EFX_POPULATE_OWORD_1(temp, FRF_AZ_SRM_RX_DC_BASE_ADR,
+			     efx->rx_dc_base / 8);
+	efx_writeo(efx, &temp, FR_AZ_SRM_RX_DC_CFG);
+
+	/* Set TX descriptor cache size. */
+	EFX_POPULATE_OWORD_1(temp, FRF_AZ_TX_DC_SIZE,
+			     ffs(efx->tx_dc_entries) - 4);
+	efx_writeo(efx, &temp, FR_AZ_TX_DC_CFG);
+
+	/* Set RX descriptor cache size.  Set low watermark to size-8, as
+	 * this allows most efficient prefetching.
+	 */
+	EFX_POPULATE_OWORD_1(temp, FRF_AZ_RX_DC_SIZE,
+			     ffs(efx->rx_dc_entries) - 4);
+	efx_writeo(efx, &temp, FR_AZ_RX_DC_CFG);
+	EFX_POPULATE_OWORD_1(temp, FRF_AZ_RX_DC_PF_LWM,
+			     efx->rx_dc_entries - 8);
+	efx_writeo(efx, &temp, FR_AZ_RX_DC_PF_WM);
+
+	/* Program INT_KER address */
+	EFX_POPULATE_OWORD_2(temp,
+			     FRF_AZ_NORM_INT_VEC_DIS_KER,
+			     EFX_INT_MODE_USE_MSI(efx),
+			     FRF_AZ_INT_ADR_KER, efx->irq_status.dma_addr);
+	efx_writeo(efx, &temp, FR_AZ_INT_ADR_KER);
+
+	if (EFX_WORKAROUND_17213(efx) && !EFX_INT_MODE_USE_MSI(efx))
+		/* Use an interrupt level unused by event queues */
+		efx->irq_level = 0x1f;
+	else
+		/* Use a valid MSI-X vector */
+		efx->irq_level = 0;
+
+	/* Enable all the genuinely fatal interrupts.  (They are still
+	 * masked by the overall interrupt mask, controlled by
+	 * falcon_interrupts()).
+	 *
+	 * Note: All other fatal interrupts are enabled
+	 */
+	EFX_POPULATE_OWORD_3(temp,
+			     FRF_AZ_ILL_ADR_INT_KER_EN, 1,
+			     FRF_AZ_RBUF_OWN_INT_KER_EN, 1,
+			     FRF_AZ_TBUF_OWN_INT_KER_EN, 1);
+	if (efx_nic_rev(efx) >= EFX_REV_SIENA_A0)
+		EFX_SET_OWORD_FIELD(temp, FRF_CZ_SRAM_PERR_INT_P_KER_EN, 1);
+	EFX_INVERT_OWORD(temp);
+	efx_writeo(efx, &temp, FR_AZ_FATAL_INTR_KER);
+
+	efx_nic_push_rx_indir_table(efx);
+
+	/* Disable the ugly timer-based TX DMA backoff and allow TX DMA to be
+	 * controlled by the RX FIFO fill level. Set arbitration to one pkt/Q.
+	 */
+	efx_reado(efx, &temp, FR_AZ_TX_RESERVED);
+	EFX_SET_OWORD_FIELD(temp, FRF_AZ_TX_RX_SPACER, 0xfe);
+	EFX_SET_OWORD_FIELD(temp, FRF_AZ_TX_RX_SPACER_EN, 1);
+	EFX_SET_OWORD_FIELD(temp, FRF_AZ_TX_ONE_PKT_PER_Q, 1);
+	EFX_SET_OWORD_FIELD(temp, FRF_AZ_TX_PUSH_EN, 1);
+	EFX_SET_OWORD_FIELD(temp, FRF_AZ_TX_DIS_NON_IP_EV, 1);
+	/* Enable SW_EV to inherit in char driver - assume harmless here */
+	EFX_SET_OWORD_FIELD(temp, FRF_AZ_TX_SOFT_EVT_EN, 1);
+	/* Prefetch threshold 2 => fetch when descriptor cache half empty */
+	EFX_SET_OWORD_FIELD(temp, FRF_AZ_TX_PREF_THRESHOLD, 2);
+	/* Disable hardware watchdog which can misfire */
+	EFX_SET_OWORD_FIELD(temp, FRF_AZ_TX_PREF_WD_TMR, 0x3fffff);
+	/* Squash TX of packets of 16 bytes or less */
+	if (efx_nic_rev(efx) >= EFX_REV_FALCON_B0)
+		EFX_SET_OWORD_FIELD(temp, FRF_BZ_TX_FLUSH_MIN_LEN_EN, 1);
+	efx_writeo(efx, &temp, FR_AZ_TX_RESERVED);
+}
+
+unsigned
+efx_nic_check_pcie_link(struct efx_nic *efx,
+			unsigned full_width, unsigned full_speed)
+{
+	int cap = pci_find_capability(efx->pci_dev, PCI_CAP_ID_EXP);
+	u16 stat;
+	unsigned width, speed;
+
+	if (!cap ||
+	    pci_read_config_word(efx->pci_dev, cap + PCI_EXP_LNKSTA, &stat))
+		return 0;
+
+	width = (stat & PCI_EXP_LNKSTA_NLW) >> __ffs(PCI_EXP_LNKSTA_NLW);
+	EFX_WARN_ON_PARANOID(width == 0 || width > full_width);
+	speed = stat & PCI_EXP_LNKSTA_CLS;
+	EFX_WARN_ON_PARANOID(speed == 0 || speed > full_speed);
+
+	if (width < full_width || speed < full_speed)
+
+		netif_warn(efx, drv, efx->net_dev,
+			   "This Solarflare Network Adapter requires a "
+			   "slot with %d lanes at PCI Express %d speed for "
+			   "full performance, but is currently limited to "
+			   "%d lanes at PCI Express %d speed. Consult your "
+			   "motherboard documentation to find a more "
+			   "suitable slot\n",
+			   full_width, full_speed, width, speed);
+
+	return width;
+}
+
+/* Register dump */
+
+#define REGISTER_REVISION_A	1
+#define REGISTER_REVISION_B	2
+#define REGISTER_REVISION_C	3
+#define REGISTER_REVISION_Z	3	/* latest revision */
+
+struct efx_nic_reg {
+	u32 offset:24;
+	u32 min_revision:2, max_revision:2;
+};
+
+#define REGISTER(name, min_rev, max_rev) {				\
+	FR_ ## min_rev ## max_rev ## _ ## name,				\
+	REGISTER_REVISION_ ## min_rev, REGISTER_REVISION_ ## max_rev	\
+}
+#define REGISTER_AA(name) REGISTER(name, A, A)
+#define REGISTER_AB(name) REGISTER(name, A, B)
+#define REGISTER_AZ(name) REGISTER(name, A, Z)
+#define REGISTER_BB(name) REGISTER(name, B, B)
+#define REGISTER_BZ(name) REGISTER(name, B, Z)
+#define REGISTER_CZ(name) REGISTER(name, C, Z)
+
+static const struct efx_nic_reg efx_nic_regs[] = {
+	REGISTER_AZ(ADR_REGION),
+	REGISTER_AZ(INT_EN_KER),
+	REGISTER_BZ(INT_EN_CHAR),
+	REGISTER_AZ(INT_ADR_KER),
+	REGISTER_BZ(INT_ADR_CHAR),
+	/* INT_ACK_KER is WO */
+	/* INT_ISR0 is RC */
+	REGISTER_AZ(HW_INIT),
+	REGISTER_CZ(USR_EV_CFG),
+	REGISTER_AB(EE_SPI_HCMD),
+	REGISTER_AB(EE_SPI_HADR),
+	REGISTER_AB(EE_SPI_HDATA),
+	REGISTER_AB(EE_BASE_PAGE),
+	REGISTER_AB(EE_VPD_CFG0),
+	/* EE_VPD_SW_CNTL and EE_VPD_SW_DATA are not used */
+	/* PMBX_DBG_IADDR and PBMX_DBG_IDATA are indirect */
+	/* PCIE_CORE_INDIRECT is indirect */
+	REGISTER_AB(NIC_STAT),
+	REGISTER_AB(GPIO_CTL),
+	REGISTER_AB(GLB_CTL),
+	/* FATAL_INTR_KER and FATAL_INTR_CHAR are partly RC */
+	REGISTER_BZ(DP_CTRL),
+	REGISTER_AZ(MEM_STAT),
+	REGISTER_AZ(CS_DEBUG),
+	REGISTER_AZ(ALTERA_BUILD),
+	REGISTER_AZ(CSR_SPARE),
+	REGISTER_AB(PCIE_SD_CTL0123),
+	REGISTER_AB(PCIE_SD_CTL45),
+	REGISTER_AB(PCIE_PCS_CTL_STAT),
+	/* DEBUG_DATA_OUT is not used */
+	/* DRV_EV is WO */
+	REGISTER_AZ(EVQ_CTL),
+	REGISTER_AZ(EVQ_CNT1),
+	REGISTER_AZ(EVQ_CNT2),
+	REGISTER_AZ(BUF_TBL_CFG),
+	REGISTER_AZ(SRM_RX_DC_CFG),
+	REGISTER_AZ(SRM_TX_DC_CFG),
+	REGISTER_AZ(SRM_CFG),
+	/* BUF_TBL_UPD is WO */
+	REGISTER_AZ(SRM_UPD_EVQ),
+	REGISTER_AZ(SRAM_PARITY),
+	REGISTER_AZ(RX_CFG),
+	REGISTER_BZ(RX_FILTER_CTL),
+	/* RX_FLUSH_DESCQ is WO */
+	REGISTER_AZ(RX_DC_CFG),
+	REGISTER_AZ(RX_DC_PF_WM),
+	REGISTER_BZ(RX_RSS_TKEY),
+	/* RX_NODESC_DROP is RC */
+	REGISTER_AA(RX_SELF_RST),
+	/* RX_DEBUG, RX_PUSH_DROP are not used */
+	REGISTER_CZ(RX_RSS_IPV6_REG1),
+	REGISTER_CZ(RX_RSS_IPV6_REG2),
+	REGISTER_CZ(RX_RSS_IPV6_REG3),
+	/* TX_FLUSH_DESCQ is WO */
+	REGISTER_AZ(TX_DC_CFG),
+	REGISTER_AA(TX_CHKSM_CFG),
+	REGISTER_AZ(TX_CFG),
+	/* TX_PUSH_DROP is not used */
+	REGISTER_AZ(TX_RESERVED),
+	REGISTER_BZ(TX_PACE),
+	/* TX_PACE_DROP_QID is RC */
+	REGISTER_BB(TX_VLAN),
+	REGISTER_BZ(TX_IPFIL_PORTEN),
+	REGISTER_AB(MD_TXD),
+	REGISTER_AB(MD_RXD),
+	REGISTER_AB(MD_CS),
+	REGISTER_AB(MD_PHY_ADR),
+	REGISTER_AB(MD_ID),
+	/* MD_STAT is RC */
+	REGISTER_AB(MAC_STAT_DMA),
+	REGISTER_AB(MAC_CTRL),
+	REGISTER_BB(GEN_MODE),
+	REGISTER_AB(MAC_MC_HASH_REG0),
+	REGISTER_AB(MAC_MC_HASH_REG1),
+	REGISTER_AB(GM_CFG1),
+	REGISTER_AB(GM_CFG2),
+	/* GM_IPG and GM_HD are not used */
+	REGISTER_AB(GM_MAX_FLEN),
+	/* GM_TEST is not used */
+	REGISTER_AB(GM_ADR1),
+	REGISTER_AB(GM_ADR2),
+	REGISTER_AB(GMF_CFG0),
+	REGISTER_AB(GMF_CFG1),
+	REGISTER_AB(GMF_CFG2),
+	REGISTER_AB(GMF_CFG3),
+	REGISTER_AB(GMF_CFG4),
+	REGISTER_AB(GMF_CFG5),
+	REGISTER_BB(TX_SRC_MAC_CTL),
+	REGISTER_AB(XM_ADR_LO),
+	REGISTER_AB(XM_ADR_HI),
+	REGISTER_AB(XM_GLB_CFG),
+	REGISTER_AB(XM_TX_CFG),
+	REGISTER_AB(XM_RX_CFG),
+	REGISTER_AB(XM_MGT_INT_MASK),
+	REGISTER_AB(XM_FC),
+	REGISTER_AB(XM_PAUSE_TIME),
+	REGISTER_AB(XM_TX_PARAM),
+	REGISTER_AB(XM_RX_PARAM),
+	/* XM_MGT_INT_MSK (note no 'A') is RC */
+	REGISTER_AB(XX_PWR_RST),
+	REGISTER_AB(XX_SD_CTL),
+	REGISTER_AB(XX_TXDRV_CTL),
+	/* XX_PRBS_CTL, XX_PRBS_CHK and XX_PRBS_ERR are not used */
+	/* XX_CORE_STAT is partly RC */
+};
+
+struct efx_nic_reg_table {
+	u32 offset:24;
+	u32 min_revision:2, max_revision:2;
+	u32 step:6, rows:21;
+};
+
+#define REGISTER_TABLE_DIMENSIONS(_, offset, min_rev, max_rev, step, rows) { \
+	offset,								\
+	REGISTER_REVISION_ ## min_rev, REGISTER_REVISION_ ## max_rev,	\
+	step, rows							\
+}
+#define REGISTER_TABLE(name, min_rev, max_rev) 				\
+	REGISTER_TABLE_DIMENSIONS(					\
+		name, FR_ ## min_rev ## max_rev ## _ ## name,		\
+		min_rev, max_rev,					\
+		FR_ ## min_rev ## max_rev ## _ ## name ## _STEP,	\
+		FR_ ## min_rev ## max_rev ## _ ## name ## _ROWS)
+#define REGISTER_TABLE_AA(name) REGISTER_TABLE(name, A, A)
+#define REGISTER_TABLE_AZ(name) REGISTER_TABLE(name, A, Z)
+#define REGISTER_TABLE_BB(name) REGISTER_TABLE(name, B, B)
+#define REGISTER_TABLE_BZ(name) REGISTER_TABLE(name, B, Z)
+#define REGISTER_TABLE_BB_CZ(name)					\
+	REGISTER_TABLE_DIMENSIONS(name, FR_BZ_ ## name, B, B,		\
+				  FR_BZ_ ## name ## _STEP,		\
+				  FR_BB_ ## name ## _ROWS),		\
+	REGISTER_TABLE_DIMENSIONS(name, FR_BZ_ ## name, C, Z,		\
+				  FR_BZ_ ## name ## _STEP,		\
+				  FR_CZ_ ## name ## _ROWS)
+#define REGISTER_TABLE_CZ(name) REGISTER_TABLE(name, C, Z)
+
+static const struct efx_nic_reg_table efx_nic_reg_tables[] = {
+	/* DRIVER is not used */
+	/* EVQ_RPTR, TIMER_COMMAND, USR_EV and {RX,TX}_DESC_UPD are WO */
+	REGISTER_TABLE_BB(TX_IPFIL_TBL),
+	REGISTER_TABLE_BB(TX_SRC_MAC_TBL),
+	REGISTER_TABLE_AA(RX_DESC_PTR_TBL_KER),
+	REGISTER_TABLE_BB_CZ(RX_DESC_PTR_TBL),
+	REGISTER_TABLE_AA(TX_DESC_PTR_TBL_KER),
+	REGISTER_TABLE_BB_CZ(TX_DESC_PTR_TBL),
+	REGISTER_TABLE_AA(EVQ_PTR_TBL_KER),
+	REGISTER_TABLE_BB_CZ(EVQ_PTR_TBL),
+	/* We can't reasonably read all of the buffer table (up to 8MB!).
+	 * However this driver will only use a few entries.  Reading
+	 * 1K entries allows for some expansion of queue count and
+	 * size before we need to change the version. */
+	REGISTER_TABLE_DIMENSIONS(BUF_FULL_TBL_KER, FR_AA_BUF_FULL_TBL_KER,
+				  A, A, 8, 1024),
+	REGISTER_TABLE_DIMENSIONS(BUF_FULL_TBL, FR_BZ_BUF_FULL_TBL,
+				  B, Z, 8, 1024),
+	REGISTER_TABLE_CZ(RX_MAC_FILTER_TBL0),
+	REGISTER_TABLE_BB_CZ(TIMER_TBL),
+	REGISTER_TABLE_BB_CZ(TX_PACE_TBL),
+	REGISTER_TABLE_BZ(RX_INDIRECTION_TBL),
+	/* TX_FILTER_TBL0 is huge and not used by this driver */
+	REGISTER_TABLE_CZ(TX_MAC_FILTER_TBL0),
+	REGISTER_TABLE_CZ(MC_TREG_SMEM),
+	/* MSIX_PBA_TABLE is not mapped */
+	/* SRM_DBG is not mapped (and is redundant with BUF_FLL_TBL) */
+};
+
+size_t efx_nic_get_regs_len(struct efx_nic *efx)
+{
+	const struct efx_nic_reg *reg;
+	const struct efx_nic_reg_table *table;
+	size_t len = 0;
+
+	for (reg = efx_nic_regs;
+	     reg < efx_nic_regs + ARRAY_SIZE(efx_nic_regs);
+	     reg++)
+		if (efx->type->revision >= reg->min_revision &&
+		    efx->type->revision <= reg->max_revision)
+			len += sizeof(efx_oword_t);
+
+	for (table = efx_nic_reg_tables;
+	     table < efx_nic_reg_tables + ARRAY_SIZE(efx_nic_reg_tables);
+	     table++)
+		if (efx->type->revision >= table->min_revision &&
+		    efx->type->revision <= table->max_revision)
+			len += table->rows * min_t(size_t, table->step, 16);
+
+	return len;
+}
+
+void efx_nic_get_regs(struct efx_nic *efx, void *buf)
+{
+	const struct efx_nic_reg *reg;
+	const struct efx_nic_reg_table *table;
+
+	for (reg = efx_nic_regs;
+	     reg < efx_nic_regs + ARRAY_SIZE(efx_nic_regs);
+	     reg++) {
+		if (efx->type->revision >= reg->min_revision &&
+		    efx->type->revision <= reg->max_revision) {
+			efx_reado(efx, (efx_oword_t *)buf, reg->offset);
+			buf += sizeof(efx_oword_t);
+		}
+	}
+
+	for (table = efx_nic_reg_tables;
+	     table < efx_nic_reg_tables + ARRAY_SIZE(efx_nic_reg_tables);
+	     table++) {
+		size_t size, i;
+
+		if (!(efx->type->revision >= table->min_revision &&
+		      efx->type->revision <= table->max_revision))
+			continue;
+
+		size = min_t(size_t, table->step, 16);
+
+		for (i = 0; i < table->rows; i++) {
+			switch (table->step) {
+			case 4: /* 32-bit register or SRAM */
+				efx_readd_table(efx, buf, table->offset, i);
+				break;
+			case 8: /* 64-bit SRAM */
+				efx_sram_readq(efx,
+					       efx->membase + table->offset,
+					       buf, i);
+				break;
+			case 16: /* 128-bit register */
+				efx_reado_table(efx, buf, table->offset, i);
+				break;
+			case 32: /* 128-bit register, interleaved */
+				efx_reado_table(efx, buf, table->offset, 2 * i);
+				break;
+			default:
+				WARN_ON(1);
+				return;
+			}
+			buf += size;
+		}
+	}
+}
diff -r 9566a4a50a43 drivers/net/sfc/nic.h
--- /dev/null
+++ b/drivers/net/sfc/nic.h
@@ -0,0 +1,377 @@
+/****************************************************************************
+ * Driver for Solarflare Solarstorm network controllers and boards
+ * Copyright 2005-2006 Fen Systems Ltd.
+ * Copyright 2006-2011 Solarflare Communications Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 as published
+ * by the Free Software Foundation, incorporated herein by reference.
+ */
+
+#ifndef EFX_NIC_H
+#define EFX_NIC_H
+
+#include <linux/i2c-algo-bit.h>
+#include <linux/timer.h>
+
+#include "net_driver.h"
+#include "efx.h"
+#include "mcdi.h"
+#include "spi.h"
+
+/*
+ * Falcon hardware control
+ */
+
+enum {
+	EFX_REV_FALCON_A0 = 0,
+	EFX_REV_FALCON_A1 = 1,
+	EFX_REV_FALCON_B0 = 2,
+	EFX_REV_SIENA_A0 = 3,
+};
+
+static inline int efx_nic_rev(struct efx_nic *efx)
+{
+	return efx->type->revision;
+}
+
+extern u32 efx_nic_fpga_ver(struct efx_nic *efx);
+
+/* NIC has two interlinked PCI functions for the same port. */
+static inline bool efx_nic_is_dual_func(struct efx_nic *efx)
+{
+	return efx_nic_rev(efx) < EFX_REV_FALCON_B0;
+}
+
+enum {
+	PHY_TYPE_NONE = 0,
+	PHY_TYPE_TXC43128 = 1,
+	PHY_TYPE_88E1111 = 2,
+	PHY_TYPE_SFX7101 = 3,
+	PHY_TYPE_QT2022C2 = 4,
+	PHY_TYPE_PM8358 = 6,
+	PHY_TYPE_SFT9001A = 8,
+	PHY_TYPE_QT2025C = 9,
+	PHY_TYPE_SFT9001B = 10,
+};
+
+#define FALCON_XMAC_LOOPBACKS			\
+	((1 << LOOPBACK_XGMII) |		\
+	 (1 << LOOPBACK_XGXS) |			\
+	 (1 << LOOPBACK_XAUI))
+
+#define FALCON_GMAC_LOOPBACKS			\
+	(1 << LOOPBACK_GMAC)
+
+/* Alignment of PCIe DMA boundaries (4KB) */
+#define EFX_PAGE_SIZE	4096
+/* Size and alignment of buffer table entries (same) */
+#define EFX_BUF_SIZE	EFX_PAGE_SIZE
+
+/**
+ * struct falcon_board_type - board operations and type information
+ * @id: Board type id, as found in NVRAM
+ * @init: Allocate resources and initialise peripheral hardware
+ * @init_phy: Do board-specific PHY initialisation
+ * @fini: Shut down hardware and free resources
+ * @set_id_led: Set state of identifying LED or revert to automatic function
+ * @monitor: Board-specific health check function
+ */
+struct falcon_board_type {
+	u8 id;
+	int (*init) (struct efx_nic *nic);
+	void (*init_phy) (struct efx_nic *efx);
+	void (*fini) (struct efx_nic *nic);
+	void (*set_id_led) (struct efx_nic *efx, enum efx_led_mode mode);
+	int (*monitor) (struct efx_nic *nic);
+};
+
+/**
+ * struct falcon_board - board information
+ * @type: Type of board
+ * @major: Major rev. ('A', 'B' ...)
+ * @minor: Minor rev. (0, 1, ...)
+ * @i2c_adap: I2C adapter for on-board peripherals
+ * @i2c_data: Data for bit-banging algorithm
+ * @hwmon_client: I2C client for hardware monitor
+ * @ioexp_client: I2C client for power/port control
+ */
+struct falcon_board {
+	const struct falcon_board_type *type;
+	int major;
+	int minor;
+	struct i2c_adapter i2c_adap;
+	struct i2c_algo_bit_data i2c_data;
+	struct i2c_client *hwmon_client;
+	struct i2c_client *ioexp_client;
+};
+
+/**
+ * struct falcon_nic_data - Falcon NIC state
+ * @sram_config: NIC SRAM configuration code
+ * @pci_dev2: Secondary function of Falcon A
+ * @board: Board state and functions
+ * @stats_disable_count: Nest count for disabling statistics fetches
+ * @stats_pending: Is there a pending DMA of MAC statistics.
+ * @stats_timer: A timer for regularly fetching MAC statistics.
+ * @stats_dma_done: Pointer to the flag which indicates DMA completion.
+ * @spi_flash: SPI flash device
+ * @spi_eeprom: SPI EEPROM device
+ * @spi_lock: SPI bus lock
+ * @mdio_lock: MDIO bus lock
+ * @xmac_poll_required: XMAC link state needs polling
+ */
+struct falcon_nic_data {
+	int sram_config;
+	struct pci_dev *pci_dev2;
+	struct falcon_board board;
+	unsigned int stats_disable_count;
+	bool stats_pending;
+	struct timer_list stats_timer;
+	u32 *stats_dma_done;
+	struct efx_spi_device spi_flash;
+	struct efx_spi_device spi_eeprom;
+	struct mutex spi_lock;
+	struct mutex mdio_lock;
+	bool xmac_poll_required;
+};
+
+static inline struct falcon_board *falcon_board(struct efx_nic *efx)
+{
+	struct falcon_nic_data *nic_data;
+	EFX_BUG_ON_PARANOID(efx_nic_rev(efx) > EFX_REV_FALCON_B0);
+	nic_data = efx->nic_data;
+	return &nic_data->board;
+}
+
+/**
+ * struct siena_nic_data - Siena NIC state
+ * @mcdi: Management-Controller-to-Driver Interface
+ * @wol_filter_id: Wake-on-LAN packet filter id
+ */
+struct siena_nic_data {
+	struct efx_mcdi_iface mcdi;
+	int wol_filter_id;
+};
+
+extern void siena_print_fwver(struct efx_nic *efx, char *buf, size_t len);
+
+/* Maximum VI_SCALE parameter supported by Siena */
+#define EFX_VI_SCALE_MAX 6
+/* Base VI to use for SR-IOV. Must be aligned to (1 << EFX_VI_SCALE_MAX),
+ * so this is the smallest allowed value. */
+#define EFX_VI_BASE 64
+/* Maximum number of VFs allowed */
+#define EFX_VF_COUNT_MAX 127
+/* Limit EVQs on VFs to be only 8k to reduce buffer table reservation */
+#define EFX_MAX_VF_EVQ_SIZE 8192UL
+/* The number of buffer table entries reserved for each VI on a VF */
+#define EFX_VF_BUFTBL_PER_VI					\
+	((EFX_MAX_VF_EVQ_SIZE + 2 * EFX_MAX_DMAQ_SIZE) *	\
+	 sizeof(efx_qword_t) / EFX_BUF_SIZE)
+
+extern int rx_desc_cache_size, tx_desc_cache_size;
+#ifdef CONFIG_SFC_SRIOV
+extern int efx_init_sriov(void);
+extern void efx_sriov_probe(struct efx_nic *efx);
+extern int efx_sriov_init(struct efx_nic *efx);
+extern void efx_sriov_mac_address_changed(struct efx_nic *efx);
+extern void efx_sriov_tx_flush_done(struct efx_nic *efx, efx_qword_t *event);
+extern void efx_sriov_rx_flush_done(struct efx_nic *efx, efx_qword_t *event);
+extern void efx_sriov_event(struct efx_channel *channel, efx_qword_t *event);
+extern void efx_sriov_desc_fetch_err(struct efx_nic *efx, unsigned dmaq);
+extern void efx_sriov_flr(struct efx_nic *efx, unsigned flr);
+extern void efx_sriov_reset(struct efx_nic *efx);
+extern void efx_sriov_fini(struct efx_nic *efx);
+extern void efx_fini_sriov(void);
+#else
+static inline int efx_init_sriov(void) { return 0; }
+static inline void efx_sriov_probe(struct efx_nic *efx) {}
+static inline int efx_sriov_init(struct efx_nic *efx) { return -EOPNOTSUPP; }
+static inline void efx_sriov_mac_address_changed(struct efx_nic *efx) {}
+static inline void efx_sriov_tx_flush_done(struct efx_nic *efx,
+					   efx_qword_t *event) {}
+static inline void efx_sriov_rx_flush_done(struct efx_nic *efx,
+					   efx_qword_t *event) {}
+static inline void efx_sriov_event(struct efx_channel *channel,
+				   efx_qword_t *event) {}
+static inline void efx_sriov_desc_fetch_err(struct efx_nic *efx, unsigned dmaq) {}
+static inline void efx_sriov_flr(struct efx_nic *efx, unsigned flr) {}
+static inline void efx_sriov_reset(struct efx_nic *efx) {}
+static inline void efx_sriov_fini(struct efx_nic *efx) {}
+static inline void efx_fini_sriov(void) {}
+#endif
+
+extern int efx_sriov_set_vf_mac(struct net_device *dev, int vf, u8 *mac);
+extern int efx_sriov_set_vf_vlan(struct net_device *dev, int vf,
+				 u16 vlan, u8 qos);
+extern int efx_sriov_get_vf_config(struct net_device *dev, int vf,
+				   struct ifla_vf_info *ivf);
+
+#ifdef CONFIG_SFC_PTP
+struct efx_ts_settime;
+struct efx_ts_adjtime;
+struct efx_ts_sync;
+extern int efx_ptp_ts_settime(struct efx_nic *efx, struct efx_ts_settime *settime);
+extern int efx_ptp_ts_adjtime(struct efx_nic *efx, struct efx_ts_adjtime *adjtime);
+extern int efx_ptp_ts_sync(struct efx_nic *efx, struct efx_ts_sync *sync);
+extern void efx_ptp_probe(struct efx_nic *efx);
+extern int efx_ptp_ioctl(struct efx_nic *efx, struct ifreq *ifr, int cmd);
+extern bool efx_ptp_is_ptp_tx(struct efx_nic *efx, struct sk_buff *skb);
+extern int efx_ptp_tx(struct efx_nic *efx, struct sk_buff *skb);
+extern void efx_ptp_event(struct efx_nic *efx, efx_qword_t *ev);
+#else
+static inline void efx_ptp_probe(struct efx_nic *efx) {}
+static inline int efx_ptp_ioctl(struct efx_nic *efx, struct ifreq *ifr, int cmd) {return -ENOSYS; }
+static inline bool efx_ptp_is_ptp_tx(struct efx_nic *efx, struct sk_buff *skb) { return false; }
+static inline int efx_ptp_tx(struct efx_nic *efx, struct sk_buff *skb) { return NETDEV_TX_OK; }
+static inline void efx_ptp_event(struct efx_nic *efx, efx_qword_t *ev) {}
+#endif
+
+extern const struct efx_nic_type falcon_a1_nic_type;
+extern const struct efx_nic_type falcon_b0_nic_type;
+extern const struct efx_nic_type siena_a0_nic_type;
+
+/**************************************************************************
+ *
+ * Externs
+ *
+ **************************************************************************
+ */
+
+extern int falcon_probe_board(struct efx_nic *efx, u16 revision_info);
+
+/* TX data path */
+extern int efx_nic_probe_tx(struct efx_tx_queue *tx_queue);
+extern void efx_nic_init_tx(struct efx_tx_queue *tx_queue);
+extern void efx_nic_fini_tx(struct efx_tx_queue *tx_queue);
+extern void efx_nic_remove_tx(struct efx_tx_queue *tx_queue);
+extern void efx_nic_push_buffers(struct efx_tx_queue *tx_queue);
+
+/* RX data path */
+extern int efx_nic_probe_rx(struct efx_rx_queue *rx_queue);
+extern void efx_nic_init_rx(struct efx_rx_queue *rx_queue);
+extern void efx_nic_fini_rx(struct efx_rx_queue *rx_queue);
+extern void efx_nic_remove_rx(struct efx_rx_queue *rx_queue);
+extern void efx_nic_notify_rx_desc(struct efx_rx_queue *rx_queue);
+extern void efx_nic_generate_fill_event(struct efx_rx_queue *rx_queue);
+
+/* Event data path */
+extern int efx_nic_probe_eventq(struct efx_channel *channel);
+extern void efx_nic_init_eventq(struct efx_channel *channel);
+extern void efx_nic_fini_eventq(struct efx_channel *channel);
+extern void efx_nic_remove_eventq(struct efx_channel *channel);
+extern int efx_nic_process_eventq(struct efx_channel *channel, int rx_quota);
+extern void efx_nic_eventq_read_ack(struct efx_channel *channel);
+extern bool efx_nic_event_present(struct efx_channel *channel);
+
+/* MAC/PHY */
+extern void falcon_drain_tx_fifo(struct efx_nic *efx);
+extern void falcon_reconfigure_mac_wrapper(struct efx_nic *efx);
+extern bool falcon_xmac_check_fault(struct efx_nic *efx);
+extern int falcon_reconfigure_xmac(struct efx_nic *efx);
+extern void falcon_update_stats_xmac(struct efx_nic *efx);
+
+/* Interrupts and test events */
+extern int efx_nic_init_interrupt(struct efx_nic *efx);
+extern void efx_nic_enable_interrupts(struct efx_nic *efx);
+extern void efx_nic_event_test_start(struct efx_channel *channel);
+extern void efx_nic_irq_test_start(struct efx_nic *efx);
+extern void efx_nic_disable_interrupts(struct efx_nic *efx);
+extern void efx_nic_fini_interrupt(struct efx_nic *efx);
+extern irqreturn_t efx_nic_fatal_interrupt(struct efx_nic *efx);
+extern irqreturn_t efx_msi_interrupt(int irq, void *dev_id);
+extern irqreturn_t falcon_legacy_interrupt_a1(int irq, void *dev_id);
+extern void falcon_irq_ack_a1(struct efx_nic *efx);
+
+static inline int efx_nic_event_test_irq_cpu(struct efx_channel *channel)
+{
+	return ACCESS_ONCE(channel->event_test_cpu);
+}
+static inline int efx_nic_irq_test_irq_cpu(struct efx_nic *efx)
+{
+	return ACCESS_ONCE(efx->last_irq_cpu);
+}
+
+/* Global Resources */
+extern int efx_nic_flush_queues(struct efx_nic *efx);
+extern void falcon_start_nic_stats(struct efx_nic *efx);
+extern void falcon_stop_nic_stats(struct efx_nic *efx);
+extern void falcon_setup_xaui(struct efx_nic *efx);
+extern int falcon_reset_xaui(struct efx_nic *efx);
+extern void falcon_reset_phy(struct efx_nic *efx);
+extern int efx_nic_dimension_resources(struct efx_nic *efx, size_t sram_size);
+extern void efx_nic_init_common(struct efx_nic *efx);
+extern void efx_nic_push_rx_indir_table(struct efx_nic *efx);
+extern unsigned efx_nic_check_pcie_link(struct efx_nic *efx,
+					unsigned full_width,
+					unsigned full_speed);
+
+int efx_nic_alloc_buffer(struct efx_nic *efx, struct efx_buffer *buffer,
+			 unsigned int len);
+void efx_nic_free_buffer(struct efx_nic *efx, struct efx_buffer *buffer);
+
+/* Tests */
+struct efx_nic_register_test {
+	unsigned address;
+	efx_oword_t mask;
+};
+struct efx_nic_table_test {
+	unsigned address;
+	unsigned step;
+	unsigned rows;
+	efx_oword_t mask;
+};
+extern int efx_nic_test_registers(struct efx_nic *efx,
+				  const struct efx_nic_register_test *regs,
+				  size_t n_regs);
+extern int efx_nic_test_table(struct efx_nic *efx,
+			      const struct efx_nic_table_test *table,
+			      void (*pattern)(unsigned, efx_qword_t *, int, int),
+			      int a, int b);
+
+extern size_t efx_nic_get_regs_len(struct efx_nic *efx);
+extern void efx_nic_get_regs(struct efx_nic *efx, void *buf);
+
+#define EFX_MAX_FLUSH_TIME 5000
+
+/**************************************************************************
+ *
+ * Falcon MAC stats
+ *
+ **************************************************************************
+ */
+
+#define FALCON_STAT_OFFSET(falcon_stat) EFX_VAL(falcon_stat, offset)
+#define FALCON_STAT_WIDTH(falcon_stat) EFX_VAL(falcon_stat, WIDTH)
+
+/* Retrieve statistic from statistics block */
+#define FALCON_STAT(efx, falcon_stat, efx_stat) do {		\
+	if (FALCON_STAT_WIDTH(falcon_stat) == 16)		\
+		(efx)->mac_stats.efx_stat += le16_to_cpu(	\
+			*((__force __le16 *)				\
+			  (efx->stats_buffer.addr +		\
+			   FALCON_STAT_OFFSET(falcon_stat))));	\
+	else if (FALCON_STAT_WIDTH(falcon_stat) == 32)		\
+		(efx)->mac_stats.efx_stat += le32_to_cpu(	\
+			*((__force __le32 *)				\
+			  (efx->stats_buffer.addr +		\
+			   FALCON_STAT_OFFSET(falcon_stat))));	\
+	else							\
+		(efx)->mac_stats.efx_stat += le64_to_cpu(	\
+			*((__force __le64 *)				\
+			  (efx->stats_buffer.addr +		\
+			   FALCON_STAT_OFFSET(falcon_stat))));	\
+	} while (0)
+
+#define FALCON_MAC_STATS_SIZE 0x100
+
+#define MAC_DATA_LBN 0
+#define MAC_DATA_WIDTH 32
+
+extern void efx_generate_event(struct efx_nic *efx, unsigned int evq,
+			       efx_qword_t *event);
+
+extern void falcon_poll_xmac(struct efx_nic *efx);
+
+#endif /* EFX_NIC_H */
diff -r 9566a4a50a43 drivers/net/sfc/phy.h
--- a/drivers/net/sfc/phy.h
+++ b/drivers/net/sfc/phy.h
@@ -1,6 +1,6 @@
 /****************************************************************************
  * Driver for Solarflare Solarstorm network controllers and boards
- * Copyright 2007-2008 Solarflare Communications Inc.
+ * Copyright 2007-2010 Solarflare Communications Inc.
  *
  * This program is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 as published
@@ -11,21 +11,16 @@
 #define EFX_PHY_H
 
 /****************************************************************************
- * 10Xpress (SFX7101 and SFT9001) PHYs
+ * 10Xpress (SFX7101) PHY
  */
-extern struct efx_phy_operations falcon_sfx7101_phy_ops;
-extern struct efx_phy_operations falcon_sft9001_phy_ops;
+extern const struct efx_phy_operations falcon_sfx7101_phy_ops;
 
-extern void tenxpress_phy_blink(struct efx_nic *efx, bool blink);
-
-/* Wait for the PHY to boot. Return 0 on success, -EINVAL if the PHY failed
- * to boot due to corrupt flash, or some other negative error code. */
-extern int sft9001_wait_boot(struct efx_nic *efx);
+extern void tenxpress_set_id_led(struct efx_nic *efx, enum efx_led_mode mode);
 
 /****************************************************************************
- * AMCC/Quake QT20xx PHYs
+ * AMCC/Quake QT202x PHYs
  */
-extern struct efx_phy_operations falcon_xfp_phy_ops;
+extern const struct efx_phy_operations falcon_qt202x_phy_ops;
 
 /* These PHYs provide various H/W control states for LEDs */
 #define QUAKE_LED_LINK_INVAL	(0)
@@ -39,6 +34,34 @@ extern struct efx_phy_operations falcon_
 #define QUAKE_LED_TXLINK	(0)
 #define QUAKE_LED_RXLINK	(8)
 
-extern void xfp_set_led(struct efx_nic *p, int led, int state);
+extern void falcon_qt202x_set_led(struct efx_nic *p, int led, int state);
+
+/****************************************************************************
+* Transwitch CX4 retimer
+*/
+extern const struct efx_phy_operations falcon_txc_phy_ops;
+
+#define TXC_GPIO_DIR_INPUT	0
+#define TXC_GPIO_DIR_OUTPUT	1
+
+extern void falcon_txc_set_gpio_dir(struct efx_nic *efx, int pin, int dir);
+extern void falcon_txc_set_gpio_val(struct efx_nic *efx, int pin, int val);
+
+/****************************************************************************
+ * Siena managed PHYs
+ */
+extern const struct efx_phy_operations efx_mcdi_phy_ops;
+
+extern int efx_mcdi_mdio_read(struct efx_nic *efx, unsigned int bus,
+			      unsigned int prtad, unsigned int devad,
+			      u16 addr, u16 *value_out, u32 *status_out);
+extern int efx_mcdi_mdio_write(struct efx_nic *efx, unsigned int bus,
+			       unsigned int prtad, unsigned int devad,
+			       u16 addr, u16 value, u32 *status_out);
+extern void efx_mcdi_phy_decode_link(struct efx_nic *efx,
+				     struct efx_link_state *link_state,
+				     u32 speed, u32 flags, u32 fcntl);
+extern int efx_mcdi_phy_reconfigure(struct efx_nic *efx);
+extern void efx_mcdi_phy_check_fcntl(struct efx_nic *efx, u32 lpa);
 
 #endif
diff -r 9566a4a50a43 drivers/net/sfc/ptp.c
--- /dev/null
+++ b/drivers/net/sfc/ptp.c
@@ -0,0 +1,1530 @@
+/****************************************************************************
+ * Driver for Solarflare Solarstorm network controllers and boards
+ * Copyright 2011 Solarflare Communications Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 as published
+ * by the Free Software Foundation, incorporated herein by reference.
+ */
+
+/*
+ * Theory of operation:
+ *
+ * PTP support is assisted by firmware running on the MC, which provides
+ * the hardware timestamping capabilities.  Both transmitted and received
+ * PTP event packets are queued onto internal queues for subsequent processing;
+ * this is because the MC operations are relatively long and would block
+ * block NAPI/interrupt operation.
+ *
+ * Receive event processing:
+ *	The event contains the packet's UUID and sequence number, together
+ *	with the hardware timestamp.  The PTP receive packet queue is searched
+ *	for this UUID/sequence number and, if found, put on a pending queue.
+ *	Packets not matching are delivered without timestamps (MCDI events will
+ *	always arrive after the actual packet).
+ *	It is important for the operation of the PTP protocol that the ordering
+ *	of packets between the event and general port is maintained.
+ *
+ * Work queue processing:
+ *	If work waiting, synchronise host/hardware time
+ *
+ *	Transmit: send packet through MC, which returns the transmission time
+ *	that is converted to an appropriate timestamp.
+ *
+ *	Receive: the packet's reception time is converted to an appropriate
+ *	timestamp.
+ */
+#include <linux/ip.h>
+#include <linux/udp.h>
+#include <linux/time.h>
+#include "net_driver.h"
+#include "efx.h"
+#include "mcdi.h"
+#include "mcdi_pcol.h"
+#include "io.h"
+#include "regs.h"
+#include "nic.h"
+#include "debugfs.h"
+#include "efx_ioctl.h"
+
+/* Maximum number of events expected to make up a PTP event */
+#define	MAX_EVENT_FRAGS			3
+
+/* Maximum delay, ms, to begin synchronisation */
+#define	MAX_SYNCHRONISE_WAIT_MS		2
+
+/* How long, at most, to spend synchronising */
+#define	SYNCHRONISE_PERIOD_NS		250000
+
+/* How often to update the shared memory time */
+#define	SYNCHRONISATION_GRANULARITY_NS	200
+
+/* Minimum permitted length of a (corrected) synchronisation time */
+#define	MIN_SYNCHRONISATION_NS		120
+
+/* Maximum permitted length of a (corrected) synchronisation time */
+#define	MAX_SYNCHRONISATION_NS		1000
+
+/* How many (MC) receive events that can be queued */
+#define	MAX_RECEIVE_EVENTS		8
+
+/* Length of (modified) moving average. */
+#define	AVERAGE_LENGTH			16
+
+/* How long an unmatched event or packet can be held */
+#define PKT_EVENT_LIFETIME_MS		10
+
+/*
+ * Offsets into PTP packet for identification.  These offsets are from the
+ * start of the IP header, not the MAC header.  Note that neither PTP V1 nor
+ * PTP V2 permit the use of IPV4 options.
+ */
+#define PTP_DPORT_OFFSET	22
+
+#define PTP_V1_VERSION_LENGTH	2
+#define PTP_V1_VERSION_OFFSET	28
+
+#define PTP_V1_UUID_LENGTH	6
+#define PTP_V1_UUID_OFFSET	50
+
+#define PTP_V1_SEQUENCE_LENGTH	2
+#define PTP_V1_SEQUENCE_OFFSET	58
+
+/*
+ * The minimum length of a PTP V1 packet for offsets, etc. to be valid: 
+ * includes IP header.
+ */
+#define	PTP_V1_MIN_LENGTH	64
+
+#define PTP_V2_VERSION_LENGTH	1
+#define PTP_V2_VERSION_OFFSET	29
+
+/*
+ * Although PTP V2 UUIDs are comprised a ClockIdentity (8) and PortNumber (2),
+ * the MC only captures the last six bytes of the clock identity. These values
+ * reflect those, not the ones used in the standard.  The standard permits 
+ * mapping of V1 UUIDs to V2 UUIDs with these same values.
+ */
+#define PTP_V2_MC_UUID_LENGTH	6
+#define PTP_V2_MC_UUID_OFFSET	50
+
+#define PTP_V2_SEQUENCE_LENGTH	2
+#define PTP_V2_SEQUENCE_OFFSET	58
+
+/*
+ * The minimum length of a PTP V2 packet for offsets, etc. to be valid: 
+ * includes IP header.
+ */
+#define	PTP_V2_MIN_LENGTH	63
+
+#define	PTP_MIN_LENGTH		63
+
+#define PTP_ADDRESS		0xe0000181	/* 224.0.1.129 */
+#define PTP_EVENT_PORT		319
+#define PTP_GENERAL_PORT	320
+
+/*
+ * Annoyingly the format of the version numbers are different between
+ * versions 1 and 2 so it isn't possible to simply look for 1 or 2.
+ */
+#define	PTP_VERSION_V1		1
+
+#define	PTP_VERSION_V2		2
+#define	PTP_VERSION_V2_MASK	0x0f
+
+enum ptp_packet_state {
+	PTP_PACKET_STATE_UNMATCHED = 0,
+	PTP_PACKET_STATE_MATCHED,
+	PTP_PACKET_STATE_TIMED_OUT,
+	PTP_PACKET_STATE_MATCH_UNWANTED
+};
+
+/*
+ * NIC synchronised with single word of time only comprising
+ * partial seconds and full nanoseconds: 10^9 ~ 2^30 so 2 bits for seconds.
+ */
+#define	MC_NANOSECOND_BITS	30
+#define	MC_NANOSECOND_MASK	((1 << MC_NANOSECOND_BITS) - 1)
+#define	MC_SECOND_MASK		((1 << (32 - MC_NANOSECOND_BITS)) - 1)
+
+/* Maximum parts-per-billion adjustment that is acceptable */
+#define MAX_PPB			1000000
+
+/* Number of bits required to hold the above */
+#define	MAX_PPB_BITS		20
+
+/*
+ * Number of extra bits allowed when calculating fractional ns.  
+ * EXTRA_BITS + MC_CMD_PTP_IN_ADJUST_BITS + MAX_PPB_BITS should
+ * be less than 63.
+ */
+#define	PPB_EXTRA_BITS		2
+
+/* Precalculate scale word to avoid long long division at runtime */
+#define	PPB_SCALE_WORD	((1LL << (PPB_EXTRA_BITS + MC_CMD_PTP_IN_ADJUST_BITS +\
+			MAX_PPB_BITS)) / 1000000000LL)
+
+/**
+ * struct efx_ptp_match - Matching structure, stored in sk_buff's cb area.
+ * @words: UUID and (partial) sequence number
+ * @expiry: Time after which the packet should be delivered irrespective of
+ *            event arrival.
+ * @state: The state of the packet - whether it is ready for processing or
+ *         whether that is of no interest.
+ */
+struct efx_ptp_match {
+	u32 words[DIV_ROUND_UP(PTP_V1_UUID_LENGTH, 4)];
+	unsigned long expiry;
+	enum ptp_packet_state state;
+};
+
+/**
+ * struct efx_ptp_event_rx - A PTP receive event (from MC)
+ * @seq0: First part of (PTP) UUID
+ * @seq1: Second part of (PTP) UUID and sequence number
+ * @hwtimestamp: Event timestamp
+ */
+struct efx_ptp_event_rx {
+	struct list_head link;
+	u32 seq0;
+	u32 seq1;
+	ktime_t hwtimestamp;
+	unsigned long expiry;
+};
+
+/**
+ * struct efx_ptp_timeset - Synchronisation between host and MC
+ * @host_start: Host time immediately before hardware timestamp taken
+ * @seconds: Hardware timestamp, seconds
+ * @nanoseconds: Hardware timestamp, nanoseconds
+ * @host_end: Host time immediately after hardware timestamp taken
+ * @waitns: Number of nanoseconds between hardware timestamp being read and
+ *          host end time being seen
+ * @window: Difference of host_end and host_start
+ * @valid: Whether this timeset is valid
+ */
+struct efx_ptp_timeset {
+	u32 host_start;
+	u32 seconds;
+	u32 nanoseconds;
+	u32 host_end;
+	u32 waitns;
+	u32 window;	/* Derived: end - start, allowing for wrap */
+};
+
+/**
+ * struct efx_ptp_data - Precision Time Protocol (PTP) state
+ * @channel: The PTP channel
+ * @rxq: Receive queue (awaiting timestamps)
+ * @txq: Transmit queue
+ * @evt_list: List of MC receive events awaiting packets
+ * @evt_free_list: List of free events
+ * @evt_lock: Lock for manipulating evt_list and evt_free_list
+ * @rx_evts: Instantiated events (on evt_list and evt_free_list)
+ * @workwq: Work queue for processing pending PTP operations
+ * @work: Work task
+ * @reset_required: A serious error has occurred and the PTP task needs to be
+ *                  reset (disable, enable).
+ * @rxfilter_event: Receive filter when operating
+ * @rxfilter_general: Receive filter when operating
+ * @config: Current timestamp configuration
+ * @enabled: PTP operation enabled
+ * @mode: Mode in which PTP operating (PTP version)
+ * @evt_frags: Partly assembled PTP events
+ * @evt_frag_idx: Current fragment number
+ * @evt_code: Last event code
+ * @start: Address at which MC indicates ready for synchronisation
+ * @host_base_time: (Synchronised with mc_base_time) host time
+ * @mc_base_time: (Synchronised with host_base_time) MC/hardware time
+ * @base_time_valid: Whether host_base_time and mc_base_time are synchronised
+ * @last_sync_ns: Last number of nanoseconds between readings when synchronising
+ * @base_sync_ns: Number of nanoseconds for last synchronisation.
+ * @base_sync_valid: Whether base_sync_time is valid.
+ * @current_adjtime: Current ppb adjustment.
+ * @txbuf: Buffer for use when transmitting (PTP) packets to MC (avoids
+ *         allocations in main data path).
+ * @debug_ptp_dir: PTP debugfs directory
+ * @missed_rx_sync: Number of packets received without syncrhonisation.
+ * @good_syncs: Number of successful synchronisations.
+ * @no_time_syncs: Number of synchronisations with no good times.
+ * @bad_sync_durations: Number of synchronisations with bad durations.
+ * @bad_syncs: Number of failed synchronisations.
+ * @last_sync_time: Number of nanoseconds for last synchronisation.
+ * @sync_timeouts: Number of synchronisation timeouts
+ * @fast_syncs: Number of synchronisations requiring short delay
+ * @min_sync_delta: Minimum time between event and synchronisation
+ * @max_sync_delta: Maximum time between event and synchronisation
+ * @average_sync_delta: Average time between event and synchronisation.
+ *                      Modified moving average.
+ * @last_sync_delta: Last time between event and synchronisation
+ * @mc_stats: Context value for MC statistics
+ * @timeset: Last set of synchronisation statistics.
+ */
+struct efx_ptp_data {
+	struct efx_channel *channel;
+	struct sk_buff_head rxq;
+	struct sk_buff_head txq;
+	struct list_head evt_list;
+	struct list_head evt_free_list;
+	spinlock_t evt_lock;
+	struct efx_ptp_event_rx rx_evts[MAX_RECEIVE_EVENTS];
+	struct workqueue_struct *workwq;
+	struct work_struct work;
+	bool reset_required;
+	struct efx_filter_spec rxfilter_event;
+	struct efx_filter_spec rxfilter_general;
+	struct hwtstamp_config config;
+	bool enabled;
+	unsigned int mode;
+	efx_qword_t evt_frags[MAX_EVENT_FRAGS];
+	int evt_frag_idx;
+	int evt_code;
+	struct efx_buffer start;
+	ktime_t host_base_time;
+	ktime_t mc_base_time;
+	bool base_time_valid;
+	unsigned last_sync_ns;
+	unsigned base_sync_ns;
+	bool base_sync_valid;
+	s64 current_adjtime;
+	u8 txbuf[ALIGN(MC_CMD_PTP_IN_TRANSMIT_LEN(
+			       MC_CMD_PTP_IN_TRANSMIT_PACKET_MAXNUM), 4)];
+	struct efx_ptp_timeset
+	timeset[MC_CMD_PTP_OUT_SYNCHRONIZE_TIMESET_MAXNUM];
+};
+
+#define EFX_PTP_INC_DEBUG_VAR(var)
+#define EFX_PTP_SET_DEBUG_VAR(var, value)
+
+/*
+ * Enable MCDI PTP support.
+ */
+static int efx_ptp_enable(struct efx_nic *efx)
+{
+	u8 inbuf[MC_CMD_PTP_IN_ENABLE_LEN];
+
+	MCDI_SET_DWORD(inbuf, PTP_IN_OP, MC_CMD_PTP_OP_ENABLE);
+	MCDI_SET_DWORD(inbuf, PTP_IN_ENABLE_QUEUE,
+		       efx->ptp_data->channel->channel);
+	MCDI_SET_DWORD(inbuf, PTP_IN_ENABLE_MODE, efx->ptp_data->mode);
+
+	return efx_mcdi_rpc(efx, MC_CMD_PTP, inbuf, sizeof(inbuf),
+			    NULL, 0, NULL);
+}
+
+/*
+ * Disable MCDI PTP support.
+ *
+ * Note that this function should never rely on the presence of ptp_data -
+ * may be called before that exists.
+ */
+static int efx_ptp_disable(struct efx_nic *efx)
+{
+	u8 inbuf[MC_CMD_PTP_IN_DISABLE_LEN];
+
+	MCDI_SET_DWORD(inbuf, PTP_IN_OP, MC_CMD_PTP_OP_DISABLE);
+	return efx_mcdi_rpc(efx, MC_CMD_PTP, inbuf, sizeof(inbuf),
+			    NULL, 0, NULL);
+}
+
+static void efx_ptp_deliver_rx_queue(struct sk_buff_head *q)
+{
+	struct sk_buff *skb;
+
+	while ((skb = skb_dequeue(q))) {
+		local_bh_disable();
+		netif_receive_skb(skb);
+		local_bh_enable();
+	}
+}
+
+static void efx_ptp_handle_no_channel(struct efx_nic *efx)
+{
+	netif_err(efx, drv, efx->net_dev,
+		  "ERROR: PTP requires MSI-X and 1 additional interrupt"
+		  "vector. PTP disabled\n");
+}
+
+/*
+ * Repeatedly send the host time to the MC which will capture the hardware
+ * time.
+ */
+static void efx_ptp_send_times(struct efx_nic *efx, struct timespec *last_time)
+{
+	struct timespec now;
+	struct timespec limit;
+	struct efx_ptp_data *ptp = efx->ptp_data;
+	struct timespec start;
+	volatile int *mc_running = (int *)ptp->start.addr;
+
+	getnstimeofday(&now);
+	start = now;
+	limit = now;
+	timespec_add_ns(&limit, SYNCHRONISE_PERIOD_NS);
+
+	/* Write host time for specified period or until MC is done */
+	while ((timespec_compare(&now, &limit) < 0) && *mc_running) {
+		struct timespec update_time;
+		unsigned int host_time;
+
+		/*
+		 * Don't update continuously to avoid saturating the PCIe bus.
+		 */
+		update_time = now;
+		timespec_add_ns(&update_time, SYNCHRONISATION_GRANULARITY_NS);
+		do {
+			getnstimeofday(&now);
+		} while ((timespec_compare(&now, &update_time) < 0) && *mc_running);
+		/*
+		 * Synchronise NIC with single word of time only
+		 */
+		host_time = (now.tv_sec << MC_NANOSECOND_BITS) | now.tv_nsec;
+		/* Update host time in NIC memory */
+		_efx_writed(efx, host_time,
+			    FR_CZ_MC_TREG_SMEM + MC_SMEM_P0_PTP_TIME_OFST);
+	}
+	*last_time = now;
+	start = timespec_sub(now, start);
+	EFX_PTP_SET_DEBUG_VAR(ptp->last_sync_time, 
+			      (unsigned int) start.tv_nsec);
+}
+
+/*
+ * Read a timeset from the MC's results and partial process.
+ */
+static void efx_ptp_read_timeset(u8 *data, struct efx_ptp_timeset *timeset)
+{
+	unsigned start_ns, end_ns;
+
+	timeset->host_start = MCDI_DWORD(data, PTP_OUT_SYNCHRONIZE_HOSTSTART);
+	timeset->seconds = MCDI_DWORD(data, PTP_OUT_SYNCHRONIZE_SECONDS);
+	timeset->nanoseconds = MCDI_DWORD(data, PTP_OUT_SYNCHRONIZE_NANOSECONDS);
+	timeset->host_end = MCDI_DWORD(data, PTP_OUT_SYNCHRONIZE_HOSTEND),
+	timeset->waitns = MCDI_DWORD(data, PTP_OUT_SYNCHRONIZE_WAITNS);
+
+	/* Ignore seconds */
+	start_ns = timeset->host_start & MC_NANOSECOND_MASK;
+	end_ns = timeset->host_end & MC_NANOSECOND_MASK;
+	/* Allow for rollover */
+	if (end_ns < start_ns)
+		end_ns += NSEC_PER_SEC;
+	/* Determine duration of operation */
+	timeset->window = end_ns - start_ns;
+}
+
+/*
+ * Process times received from MC.
+ *
+ * Extract times from returned results, and establish the minimum value
+ * seen.  The minimum value represents the "best" possible time and events
+ * too much greater than this are rejected - the machine is, perhaps, too 
+ * busy. A number of readings are taken so that, hopefully, at least one good
+ * synchronisation will be seen in the results.
+ */
+static int efx_ptp_process_times(struct efx_nic *efx, u8 *synch_buf,
+		size_t response_length, struct timespec *last_time)
+{
+	unsigned number_readings = (response_length /
+			       MC_CMD_PTP_OUT_SYNCHRONIZE_TIMESET_LEN);
+	unsigned i;
+	unsigned min;
+	unsigned min_set = 0;
+	unsigned total;
+	unsigned ngood = 0;
+	unsigned last_good = 0;
+	struct efx_ptp_data *ptp = efx->ptp_data;
+	bool min_valid = false;
+	u32 last_sec;
+	u32 start_sec;
+
+	if (number_readings == 0)
+		return -EAGAIN;
+
+	/*
+	 * Find minimum value in this set of results, discarding clearly 
+	 * erroneous results.
+	 */
+	for (i = 0; i < number_readings; i++) {
+		efx_ptp_read_timeset(synch_buf, &ptp->timeset[i]);
+		synch_buf += MC_CMD_PTP_OUT_SYNCHRONIZE_TIMESET_LEN;
+		if (ptp->timeset[i].window > SYNCHRONISATION_GRANULARITY_NS) {
+			if (min_valid) {
+				if (ptp->timeset[i].window < min_set)
+					min_set = ptp->timeset[i].window;
+			} else {
+				min_valid = true;
+				min_set = ptp->timeset[i].window;
+			}
+		} else {
+			/*
+			 * The apparent time for the operation is below
+			 * the expected bound.  This is most likely to be
+			 * as a consequence of the host's time being adjusted.
+			 * Ignore this reading.
+			 */
+			EFX_PTP_INC_DEBUG_VAR(ptp->bad_sync_durations);
+		}
+	}
+
+	if (min_valid) {
+		if (ptp->base_sync_valid && (min_set > ptp->base_sync_ns))
+			min = ptp->base_sync_ns;
+		else
+			min = min_set;
+	} else {
+		min = SYNCHRONISATION_GRANULARITY_NS;
+	}
+
+	/*
+	 * Discard excessively long synchronise durations.  The MC times
+	 * when it finishes reading the host time so the corrected window
+	 * time should be fairly constant for a given platform.
+	 */
+	total = 0;
+	for (i = 0; i < number_readings; i++)
+		if (ptp->timeset[i].window > ptp->timeset[i].waitns) {
+			unsigned win;
+
+			win = ptp->timeset[i].window - ptp->timeset[i].waitns;
+			if (win >= MIN_SYNCHRONISATION_NS &&
+		    	    win < MAX_SYNCHRONISATION_NS) {
+				total += ptp->timeset[i].window;
+				ngood++;
+				last_good = i;
+			}
+		}
+
+	if (ngood == 0) {
+		netif_warn(efx, drv, efx->net_dev,
+			   "PTP no suitable synchronisations %dns %dns\n",
+			   ptp->base_sync_ns, min_set);
+		return -EAGAIN;
+	}
+
+	/* Average minimum this synchronisation */
+	ptp->last_sync_ns = DIV_ROUND_UP(total, ngood);
+	if (!ptp->base_sync_valid || (ptp->last_sync_ns < ptp->base_sync_ns)) {
+		ptp->base_sync_valid = true;
+		ptp->base_sync_ns = ptp->last_sync_ns;
+	}
+
+	ptp->mc_base_time = ktime_set(ptp->timeset[last_good].seconds,
+				      ptp->timeset[last_good].nanoseconds);
+	last_time->tv_nsec =
+		ptp->timeset[last_good].host_start & MC_NANOSECOND_MASK;
+
+	/*
+	 * It is possible that the seconds rolled over between taking
+	 * the start reading and the last value written by the host.  The 
+	 * timescales are such that a gap of more than one second is never 
+	 * expected.
+	 */
+	start_sec = ptp->timeset[last_good].host_start >> MC_NANOSECOND_BITS;
+	last_sec = last_time->tv_sec & MC_SECOND_MASK;
+	if (start_sec != last_sec) {
+		if (((start_sec + 1) & MC_SECOND_MASK) != last_sec) {
+			netif_warn (efx, hw, efx->net_dev,
+				    "PTP bad synchronisation seconds\n");
+			return -EAGAIN;
+		} else {
+			last_time->tv_sec--;
+		}
+	}
+	ptp->host_base_time = ktime_set(last_time->tv_sec,
+					last_time->tv_nsec);
+
+	/* At least one good synchronisation */
+	ptp->base_time_valid = true;
+
+	return 0;
+}
+
+/*
+ * Synchronize times between the host and the MC
+ */
+static int efx_ptp_synchronize(struct efx_nic *efx, unsigned int num_readings)
+{
+	struct efx_ptp_data *ptp = efx->ptp_data;
+	u8 synch_buf[MC_CMD_PTP_OUT_SYNCHRONIZE_LENMAX];
+	size_t response_length;
+	int rc;
+	unsigned long timeout;
+	struct timespec last_time;
+	unsigned int loops = 0;
+	volatile int *start = (int *)ptp->start.addr;
+
+	last_time.tv_sec = 0;
+	last_time.tv_nsec = 0;
+
+	MCDI_SET_DWORD(synch_buf, PTP_IN_OP, MC_CMD_PTP_OP_SYNCHRONIZE);
+	MCDI_SET_DWORD(synch_buf, PTP_IN_SYNCHRONIZE_NUMTIMESETS,
+		       num_readings);
+	MCDI_SET_DWORD(synch_buf, PTP_IN_SYNCHRONIZE_START_ADDR_LO,
+		       (u32)ptp->start.dma_addr);
+	MCDI_SET_DWORD(synch_buf, PTP_IN_SYNCHRONIZE_START_ADDR_HI,
+		       (u32)((u64)ptp->start.dma_addr >> 32));
+
+	/* Clear flag that signals MC ready */
+	*start = 0;
+	efx_mcdi_rpc_start(efx, MC_CMD_PTP, synch_buf,
+			   MC_CMD_PTP_IN_SYNCHRONIZE_LEN);
+
+	/* Wait for start from MCDI (or timeout) */
+	timeout = jiffies + msecs_to_jiffies(MAX_SYNCHRONISE_WAIT_MS);
+	while (!*start && (time_before(jiffies, timeout))) {
+		udelay(20);	/* Usually start MCDI execution quickly */
+		loops++;
+	}
+
+	if (loops <= 1)
+		EFX_PTP_INC_DEBUG_VAR(ptp->fast_syncs);
+	if (!time_before(jiffies, timeout))
+		EFX_PTP_INC_DEBUG_VAR(ptp->sync_timeouts);
+
+	if (*start)
+		efx_ptp_send_times(efx, &last_time);
+
+	/* Collect results */
+	rc = efx_mcdi_rpc_finish(efx, MC_CMD_PTP,
+				 MC_CMD_PTP_IN_SYNCHRONIZE_LEN,
+				 synch_buf, sizeof(synch_buf),
+				 &response_length);
+	if (rc == 0) {
+		rc = efx_ptp_process_times(efx, synch_buf, response_length,
+					   &last_time);
+		if (rc == 0)
+			EFX_PTP_INC_DEBUG_VAR(ptp->good_syncs);
+		else
+			EFX_PTP_INC_DEBUG_VAR(ptp->no_time_syncs);
+	} else {
+		EFX_PTP_INC_DEBUG_VAR(ptp->bad_syncs);
+	}
+
+	return rc;
+}
+
+/*
+ * Get the host time from a given hardware time
+ */
+static bool efx_ptp_get_host_time(struct efx_nic *efx,
+			struct skb_shared_hwtstamps *timestamps)
+{
+	if (efx->ptp_data->base_time_valid) {
+		ktime_t diff = ktime_sub(timestamps->hwtstamp,
+					 efx->ptp_data->mc_base_time);
+
+		timestamps->syststamp = ktime_add(efx->ptp_data->host_base_time,
+						  diff);
+	}
+
+	return efx->ptp_data->base_time_valid;
+}
+
+/*
+ * Transmit a PTP packet, via the MCDI interface, to the wire.
+ */
+static int efx_ptp_xmit_skb(struct efx_nic *efx, struct sk_buff *skb)
+{
+	u8 *txbuf = efx->ptp_data->txbuf;
+	struct skb_shared_hwtstamps timestamps;
+	int rc = -EIO;
+	/* MCDI driver requires word aligned lengths */
+	size_t len = ALIGN(MC_CMD_PTP_IN_TRANSMIT_LEN(skb->len), 4);
+	u8 txtime[MC_CMD_PTP_OUT_TRANSMIT_LEN];
+
+	MCDI_SET_DWORD(txbuf, PTP_IN_OP, MC_CMD_PTP_OP_TRANSMIT);
+	MCDI_SET_DWORD(txbuf, PTP_IN_TRANSMIT_LENGTH, skb->len);
+	if (skb_shinfo(skb)->nr_frags != 0) {
+		rc = skb_linearize(skb);
+		if (rc != 0)
+			goto fail;
+	}
+
+	if (skb->ip_summed == CHECKSUM_PARTIAL) {
+		skb_set_transport_header(skb, skb_checksum_start_offset(skb));
+		rc = skb_checksum_help(skb);
+		if (rc != 0)
+			goto fail;
+	}
+	skb_copy_from_linear_data(skb,
+				  &txbuf[MC_CMD_PTP_IN_TRANSMIT_PACKET_OFST],
+				  len);
+	rc = efx_mcdi_rpc(efx, MC_CMD_PTP, txbuf, len, txtime,
+			  sizeof(txtime), &len);
+	if (rc != 0)
+		goto fail;
+
+	memset(&timestamps, 0, sizeof(timestamps));
+	timestamps.hwtstamp = ktime_set(
+		MCDI_DWORD(txtime, PTP_OUT_TRANSMIT_SECONDS),
+		MCDI_DWORD(txtime, PTP_OUT_TRANSMIT_NANOSECONDS));
+	if (efx_ptp_get_host_time(efx, &timestamps))
+		skb_tstamp_tx(skb, &timestamps);
+	/* Success even if hardware timestamping failed */
+	rc = 0;
+
+fail:
+	dev_kfree_skb(skb);
+
+	return rc;
+}
+
+static void efx_ptp_drop_time_expired_events(struct efx_nic *efx)
+{
+	struct efx_ptp_data *ptp = efx->ptp_data;
+	struct list_head *cursor;
+	struct list_head *next;
+
+	/* Drop time-expired events */
+	spin_lock_bh(&ptp->evt_lock);
+	if (!list_empty(&ptp->evt_list)) {
+		list_for_each_safe(cursor, next, &ptp->evt_list) {
+			struct efx_ptp_event_rx *evt;
+
+			evt = list_entry(cursor, struct efx_ptp_event_rx,
+					 link);
+			if (time_after(jiffies, evt->expiry)) {
+				list_del(&evt->link);
+				list_add(&evt->link, &ptp->evt_free_list);
+				netif_warn(efx, hw, efx->net_dev,
+					   "PTP rx event dropped\n");
+			}
+		}
+	}
+	spin_unlock_bh(&ptp->evt_lock);
+}
+
+static enum ptp_packet_state
+efx_ptp_match_rx(struct efx_nic *efx, struct sk_buff *skb)
+{
+	struct efx_ptp_data *ptp = efx->ptp_data;
+	bool evts_waiting;
+	struct list_head *cursor;
+	struct list_head *next;
+	struct efx_ptp_match *match;
+	enum ptp_packet_state rc = PTP_PACKET_STATE_UNMATCHED;
+
+	spin_lock_bh(&ptp->evt_lock);
+	evts_waiting = !list_empty(&ptp->evt_list);
+	spin_unlock_bh(&ptp->evt_lock);
+
+	if (!evts_waiting)
+		return PTP_PACKET_STATE_UNMATCHED;
+
+	match = (struct efx_ptp_match *)skb->cb;
+	/* Look for a matching timestamp in the event queue */
+	spin_lock_bh(&ptp->evt_lock);
+	list_for_each_safe(cursor, next, &ptp->evt_list) {
+		struct efx_ptp_event_rx *evt;
+
+		evt = list_entry(cursor, struct efx_ptp_event_rx, link);
+		if ((evt->seq0 == match->words[0]) &&
+		    (evt->seq1 == match->words[1])) {
+			struct skb_shared_hwtstamps *timestamps;
+
+			/*
+			 * Match - add in hardware timestamp
+			 */
+			timestamps = skb_hwtstamps(skb);
+			timestamps->hwtstamp = evt->hwtimestamp;
+
+			match->state = PTP_PACKET_STATE_MATCHED;
+			rc = PTP_PACKET_STATE_MATCHED;
+			list_del(&evt->link);
+			list_add(&evt->link, &ptp->evt_free_list);
+			break;
+		}
+	}
+	spin_unlock_bh(&ptp->evt_lock);
+
+	return rc;
+}
+
+/*
+ * Process any queued receive events and corresponding packets
+ *
+ * q is returned with all the packets that are ready for delivery.
+ * true is returned if at least one of those packets requires
+ * synchronisation.
+ */
+static bool efx_ptp_process_events(struct efx_nic *efx, struct sk_buff_head *q)
+{
+	struct efx_ptp_data *ptp = efx->ptp_data;
+	bool rc = false;
+	struct sk_buff *skb;
+
+	while ((skb = skb_dequeue(&ptp->rxq))) {
+		struct efx_ptp_match *match;
+
+		match = (struct efx_ptp_match *)skb->cb;
+		if (match->state == PTP_PACKET_STATE_MATCH_UNWANTED) {
+			__skb_queue_tail(q, skb);
+		} else if (efx_ptp_match_rx(efx, skb) ==
+			   PTP_PACKET_STATE_MATCHED) {
+			rc = true;
+			__skb_queue_tail(q, skb);
+		} else if (time_after(jiffies, match->expiry)) {
+			match->state = PTP_PACKET_STATE_TIMED_OUT;
+			netif_warn(efx, rx_err, efx->net_dev,
+				   "PTP packet - no timestamp seen\n");
+			EFX_PTP_INC_DEBUG_VAR(ptp->missed_rx_sync);
+			__skb_queue_tail(q, skb);
+		} else {
+			/* Replace unprocessed entry and stop */
+			skb_queue_head(&ptp->rxq, skb);
+			break;
+		}
+	}
+
+	return rc;
+}
+
+/*
+ * Calculate synchronisation delta statistics
+ */
+static void efx_ptp_update_delta_stats(struct efx_nic *efx,
+				       struct skb_shared_hwtstamps *timestamps)
+{
+}
+
+/*
+ * Complete processing of a received packet
+ */
+static void efx_ptp_process_rx(struct efx_nic *efx, struct sk_buff *skb)
+{
+	struct efx_ptp_match *match = (struct efx_ptp_match *)skb->cb;
+
+	/* Translate timestamps, as required */
+	if (match->state == PTP_PACKET_STATE_MATCHED) {
+		struct skb_shared_hwtstamps *timestamps;
+
+		timestamps = skb_hwtstamps(skb);
+		efx_ptp_get_host_time(efx, timestamps);
+		efx_ptp_update_delta_stats(efx, timestamps);
+	}
+
+	local_bh_disable();
+	netif_receive_skb(skb);
+	local_bh_enable();
+}
+
+/*
+ * Send a PTP packets, event packets go via the MC, others through the normal
+ * transmission methods.  The others are dealt with here so that the ordering
+ * is maintained.
+ */
+static int efx_ptp_process_tx(struct efx_nic *efx, struct sk_buff *skb)
+{
+	int rc;
+
+	if ((udp_hdr(skb)->dest == htons(PTP_EVENT_PORT)) &&
+	    (skb->len <= MC_CMD_PTP_IN_TRANSMIT_PACKET_MAXNUM)) {
+		rc = efx_ptp_xmit_skb(efx, skb);
+	} else {
+		struct efx_tx_queue *tx_queue;
+		netdev_tx_t ret;
+
+		tx_queue = efx_get_tx_queue(efx, skb_get_queue_mapping(skb),
+					    skb->ip_summed == CHECKSUM_PARTIAL ?
+					    EFX_TXQ_TYPE_OFFLOAD : 0);
+		__netif_tx_lock_bh(tx_queue->core_txq);
+		ret = efx_enqueue_skb(tx_queue, skb);
+		__netif_tx_unlock_bh(tx_queue->core_txq);
+		if (ret == NETDEV_TX_OK)
+			rc = 0;
+		else
+			rc = EBUSY;
+	}
+
+	return rc;
+}
+
+int efx_ptp_start(struct efx_nic *efx)
+{
+	struct efx_ptp_data *ptp = efx->ptp_data;
+	int rc;
+
+	ptp->reset_required = false;
+
+	/* Must resynchronise when starting */
+	ptp->base_time_valid = false;
+	ptp->base_sync_valid = false;
+
+	/* Must filter on both event and general ports to ensure
+	 * that there is no packet re-ordering.
+	 */
+	efx_filter_init_rx(&ptp->rxfilter_event,
+			   EFX_FILTER_PRI_REQUIRED, 0,
+			   efx_rx_queue_index(
+				   efx_channel_get_rx_queue(ptp->channel)));
+	rc = efx_filter_set_ipv4_local(&ptp->rxfilter_event, IPPROTO_UDP,
+				       htonl(PTP_ADDRESS),
+				       htons(PTP_EVENT_PORT));
+	if (rc != 0)
+		return rc;
+
+	rc = efx_filter_insert_filter(efx, &ptp->rxfilter_event, true);
+	if (rc < 0)
+		return rc;
+
+	efx_filter_init_rx(&ptp->rxfilter_general,
+			   EFX_FILTER_PRI_REQUIRED, 0,
+			   efx_rx_queue_index(
+				   efx_channel_get_rx_queue(ptp->channel)));
+	rc = efx_filter_set_ipv4_local(&ptp->rxfilter_general, IPPROTO_UDP,
+				       htonl(PTP_ADDRESS),
+				       htons(PTP_GENERAL_PORT));
+	if (rc != 0)
+		goto fail;
+
+	rc = efx_filter_insert_filter(efx, &ptp->rxfilter_general, true);
+	if (rc < 0)
+		goto fail;
+
+	rc = efx_ptp_enable(efx);
+	if (rc != 0)
+		goto fail2;
+
+	ptp->evt_frag_idx = 0;
+	ptp->current_adjtime = 0;
+
+	return 0;
+
+fail2:
+	efx_filter_remove_filter(efx, &efx->ptp_data->rxfilter_general);
+fail:
+	efx_filter_remove_filter(efx, &efx->ptp_data->rxfilter_event);
+
+	return rc;
+}
+
+int efx_ptp_stop(struct efx_nic *efx)
+{
+	int rc = efx_ptp_disable(efx);
+	struct list_head *cursor;
+	struct list_head *next;
+
+	efx_filter_remove_filter(efx, &efx->ptp_data->rxfilter_general);
+	efx_filter_remove_filter(efx, &efx->ptp_data->rxfilter_event);
+	/* Make sure RX packets are really delivered */
+	efx_ptp_deliver_rx_queue(&efx->ptp_data->rxq);
+	skb_queue_purge(&efx->ptp_data->txq);
+
+	/* Drop any pending receive events */
+	spin_lock_bh(&efx->ptp_data->evt_lock);
+	list_for_each_safe(cursor, next, &efx->ptp_data->evt_list) {
+		list_del(cursor);
+		list_add(cursor, &efx->ptp_data->evt_free_list);
+	}
+	spin_unlock_bh(&efx->ptp_data->evt_lock);
+
+	return rc;
+}
+
+/*
+ * Process any pending transmissions and timestamp any received packets.
+ *
+ * Host and NIC time are synchronised once if there is any work to do:
+ * the process is relatively expensive so don't do it for each packet.
+ */
+static void efx_ptp_worker(struct work_struct *work)
+{
+	struct efx_ptp_data *ptp_data =
+		container_of(work, struct efx_ptp_data, work);
+	struct efx_nic *efx = ptp_data->channel->efx;
+	struct sk_buff *skb;
+	struct sk_buff_head tempq;
+
+	if (ptp_data->reset_required) {
+		efx_ptp_stop(efx);
+		efx_ptp_start(efx);
+		return;
+	}
+
+	efx_ptp_drop_time_expired_events(efx);
+
+	__skb_queue_head_init(&tempq);
+	if (efx_ptp_process_events(efx, &tempq) ||
+	    !skb_queue_empty(&ptp_data->txq)) {
+		/*
+		 * Synchronise PC/MC times when there's work to do. This
+		 * isn't fatal but would be unusual (because of the retries
+		 * within efx_ptp_synchronize).  Failure may suggest a heavily
+		 * overloaded system. 
+		 */
+		if (0 != efx_ptp_synchronize(efx, 4))
+			netif_warn(efx, drv, efx->net_dev,
+			           "PTP couldn't get synchronisation\n");
+
+		while ((skb = skb_dequeue(&ptp_data->txq)))
+			efx_ptp_process_tx(efx, skb);
+	}
+
+	while ((skb = __skb_dequeue(&tempq)))
+		efx_ptp_process_rx(efx, skb);
+}
+
+
+static ssize_t set_ptp_stats(struct device *dev, 
+	       struct device_attribute *attr, const char *buf, size_t count)
+{
+	bool clear = count > 0 && *buf != '0';
+	
+	if (clear) {
+		struct efx_nic *efx = pci_get_drvdata(to_pci_dev(dev));
+		u8 in_rst_stats [MC_CMD_PTP_IN_RESET_STATS_LEN];
+		int rc;
+
+		MCDI_SET_DWORD(in_rst_stats, PTP_IN_OP, MC_CMD_PTP_OP_RESET_STATS);
+
+		rc = efx_mcdi_rpc(efx, MC_CMD_PTP, in_rst_stats, sizeof(in_rst_stats),
+				  NULL, 0, NULL);
+		if (rc < 0)
+			count = (size_t) rc;
+	}
+
+	return count;
+}
+
+static DEVICE_ATTR(ptp_stats, 0200, NULL, set_ptp_stats);
+
+/*
+ * Initialise PTP channel and state.
+ *
+ * Setting core_index to zero causes the queue to be initialised and doesn't
+ * overlap with 'rxq0' because ptp.c doesn't use skb_record_rx_queue.
+ */
+static int efx_ptp_probe_channel(struct efx_channel *channel)
+{
+	struct efx_nic *efx = channel->efx;
+	struct efx_ptp_data *ptp;
+	int rc = 0;
+	unsigned int pos;
+
+	channel->irq_moderation = 0;
+	channel->rx_queue.core_index = 0;
+
+	ptp = kzalloc(sizeof(struct efx_ptp_data), GFP_KERNEL);
+	efx->ptp_data = ptp;
+	if (!efx->ptp_data)
+		return -ENOMEM;
+
+	rc = efx_nic_alloc_buffer(efx, &ptp->start, sizeof(int));
+	if (rc != 0)
+		goto fail1;
+
+	ptp->channel = channel;
+	skb_queue_head_init(&ptp->rxq);
+	skb_queue_head_init(&ptp->txq);
+	ptp->workwq = create_singlethread_workqueue("sfc_ptp");
+	if (!ptp->workwq) {
+		rc = -ENOMEM;
+		goto fail2;
+	}
+
+	INIT_WORK(&ptp->work, efx_ptp_worker);
+	ptp->config.flags = 0;
+	ptp->config.tx_type = HWTSTAMP_TX_OFF;
+	ptp->config.rx_filter = HWTSTAMP_FILTER_NONE;
+	INIT_LIST_HEAD(&ptp->evt_list);
+	INIT_LIST_HEAD(&ptp->evt_free_list);
+	spin_lock_init(&ptp->evt_lock);
+	for (pos = 0; pos < MAX_RECEIVE_EVENTS; pos++)
+		list_add(&ptp->rx_evts[pos].link, &ptp->evt_free_list);
+
+	rc = device_create_file(&efx->pci_dev->dev,
+				&dev_attr_ptp_stats);
+	if (rc < 0)
+		goto fail3;
+
+	return 0;
+
+fail3:
+	destroy_workqueue(efx->ptp_data->workwq);
+	
+fail2:
+	efx_nic_free_buffer(efx, &ptp->start);
+
+fail1:
+	kfree(efx->ptp_data);
+	efx->ptp_data = 0;
+	
+	return rc;
+}
+
+static void efx_ptp_remove_channel(struct efx_channel *channel)
+{
+	struct efx_nic *efx = channel->efx;
+
+	if (!efx->ptp_data)
+		return;
+		
+	(void)efx_ptp_disable(channel->efx);
+
+	cancel_work_sync(&efx->ptp_data->work);
+	skb_queue_purge(&efx->ptp_data->rxq);
+	skb_queue_purge(&efx->ptp_data->txq);
+
+	device_remove_file(&efx->pci_dev->dev, &dev_attr_ptp_stats);
+	
+	destroy_workqueue(efx->ptp_data->workwq);
+
+	efx_nic_free_buffer(efx, &efx->ptp_data->start);
+	kfree(efx->ptp_data);
+}
+
+static void
+efx_ptp_get_channel_name(struct efx_channel *channel, char *buf, size_t len)
+{
+	snprintf(buf, len, "%s-ptp", channel->efx->name);
+}
+
+/*
+ * Determine whether this packet should be processed by the PTP module
+ * or transmitted conventionally.
+ */
+bool efx_ptp_is_ptp_tx(struct efx_nic *efx, struct sk_buff *skb)
+{
+	return efx->ptp_data &&
+		efx->ptp_data->enabled &&
+		skb->len >= PTP_MIN_LENGTH &&
+		likely(skb->protocol == htons(ETH_P_IP)) &&
+		ip_hdr(skb)->protocol == IPPROTO_UDP &&
+		(udp_hdr(skb)->dest == htons(PTP_EVENT_PORT) ||
+		 udp_hdr(skb)->dest == htons(PTP_GENERAL_PORT));
+}
+
+/*
+ * Receive a PTP packet.  Packets are queued until the arrival of
+ * the receive timestamp from the MC - this will probably occur after the
+ * packet arrival because of the processing in the MC.
+ */
+static void efx_ptp_rx(struct efx_channel *channel, struct sk_buff *skb)
+{
+	struct efx_nic *efx = channel->efx;
+	struct efx_ptp_data *ptp = efx->ptp_data;
+	struct efx_ptp_match *match = (struct efx_ptp_match *)skb->cb;
+	u8 *data;
+	unsigned int version;
+
+	match->expiry = jiffies + msecs_to_jiffies(PKT_EVENT_LIFETIME_MS);
+
+	/* Correct version? */
+	if (ptp->mode == MC_CMD_PTP_MODE_V1) {
+		if (skb->len < PTP_V1_MIN_LENGTH) {
+			netif_receive_skb(skb);
+			return;
+		}
+		version = ntohs(*(u16 *)&skb->data[PTP_V1_VERSION_OFFSET]);
+		if (version != PTP_VERSION_V1) {
+			netif_receive_skb(skb);
+			return;
+		}
+	} else {
+		if (skb->len < PTP_V2_MIN_LENGTH) {
+			netif_receive_skb(skb);
+			return;
+		}
+		version = skb->data[PTP_V2_VERSION_OFFSET];
+
+		BUG_ON(ptp->mode != MC_CMD_PTP_MODE_V2);
+		BUILD_BUG_ON(PTP_V1_UUID_OFFSET != PTP_V2_MC_UUID_OFFSET);
+		BUILD_BUG_ON(PTP_V1_UUID_LENGTH != PTP_V2_MC_UUID_LENGTH);
+		BUILD_BUG_ON(PTP_V1_SEQUENCE_OFFSET != PTP_V2_SEQUENCE_OFFSET);
+		BUILD_BUG_ON(PTP_V1_SEQUENCE_LENGTH != PTP_V2_SEQUENCE_LENGTH);
+
+		if ((version & PTP_VERSION_V2_MASK) != PTP_VERSION_V2) {
+			netif_receive_skb(skb);
+			return;
+		}
+	}
+
+	/* Does this packet require timestamping? */
+	if (ntohs(*(u16 *)&skb->data[PTP_DPORT_OFFSET]) == PTP_EVENT_PORT) {
+		struct skb_shared_hwtstamps *timestamps;
+
+		match->state = PTP_PACKET_STATE_UNMATCHED;
+
+		/* Clear all timestamps held: filled in later */
+		timestamps = skb_hwtstamps(skb);
+		memset(timestamps, 0, sizeof(*timestamps));
+
+		/* Extract UUID/Sequence information */
+		data = skb->data + PTP_V1_UUID_OFFSET;
+		match->words[0] = (data[0]         |
+				   (data[1] << 8)  |
+				   (data[2] << 16) |
+				   (data[3] << 24));
+		match->words[1] = (data[4]         |
+				   (data[5] << 8)  |
+				   (skb->data[PTP_V1_SEQUENCE_OFFSET +
+					      PTP_V1_SEQUENCE_LENGTH - 1] <<
+				    16));
+	} else {
+		match->state = PTP_PACKET_STATE_MATCH_UNWANTED;
+	}
+
+	skb_queue_tail(&ptp->rxq, skb);
+	queue_work(ptp->workwq, &ptp->work);
+}
+
+/*
+ * Transmit a PTP packet.  This has to be transmitted by the MC
+ * itself, through an MCDI call.  MCDI calls aren't permitted
+ * in the transmit path so defer the actual transmission to a suitable worker.
+ */
+int efx_ptp_tx(struct efx_nic *efx, struct sk_buff *skb)
+{
+	struct efx_ptp_data *ptp = efx->ptp_data;
+
+	skb_queue_tail(&ptp->txq, skb);
+
+	if ((udp_hdr(skb)->dest == htons(PTP_EVENT_PORT)) &&
+	    (skb->len <= MC_CMD_PTP_IN_TRANSMIT_PACKET_MAXNUM))
+		efx_xmit_hwtstamp_pending(skb);
+	queue_work(ptp->workwq, &ptp->work);
+
+	return NETDEV_TX_OK;
+}
+
+int efx_ptp_change_mode(struct efx_nic *efx, bool enable_wanted,
+			unsigned int new_mode)
+{
+	if ((enable_wanted != efx->ptp_data->enabled) ||
+	    (enable_wanted && (efx->ptp_data->mode != new_mode))) {
+		int rc;
+
+		if (enable_wanted) {
+			/* Change of mode requires disable */
+			if (efx->ptp_data->enabled &&
+			    (efx->ptp_data->mode != new_mode)) {
+				efx->ptp_data->enabled = false;
+				rc = efx_ptp_stop(efx);
+				if (rc != 0)
+					return rc;
+			}
+
+			/* Set new operating mode and establish
+			 * baseline synchronisation, which must
+			 * succeed.
+			 */
+			efx->ptp_data->mode = new_mode;
+			rc = efx_ptp_start(efx);
+			if (rc == 0) {
+				rc = efx_ptp_synchronize(efx, 8);
+				if (rc != 0)
+					efx_ptp_stop(efx);
+			}
+		} else {
+			rc = efx_ptp_stop(efx);
+		}
+
+		if (rc != 0)
+			return rc;
+
+		efx->ptp_data->enabled = enable_wanted;
+	}
+
+	return 0;
+}
+
+int efx_ptp_ts_init(struct efx_nic *efx, struct hwtstamp_config *init)
+{
+	bool enable_wanted = false;
+	unsigned int new_mode;
+	int rc;
+
+	if (!efx->ptp_data)
+		return -ENOTTY;
+
+	if (init->flags)
+		return -EINVAL;
+
+	if ((init->tx_type != HWTSTAMP_TX_OFF) &&
+	    (init->tx_type != HWTSTAMP_TX_ON))
+		return -ERANGE;
+
+	new_mode = efx->ptp_data->mode;
+	/* Determine whether any PTP HW operations are required */
+	switch (init->rx_filter) {
+	case HWTSTAMP_FILTER_NONE:
+		break;
+	case HWTSTAMP_FILTER_PTP_V1_L4_EVENT:
+	case HWTSTAMP_FILTER_PTP_V1_L4_SYNC:
+	case HWTSTAMP_FILTER_PTP_V1_L4_DELAY_REQ:
+		init->rx_filter = HWTSTAMP_FILTER_PTP_V1_L4_EVENT;
+		new_mode = MC_CMD_PTP_MODE_V1;
+		enable_wanted = true;
+		break;
+	case HWTSTAMP_FILTER_PTP_V2_L4_EVENT:
+	case HWTSTAMP_FILTER_PTP_V2_L4_SYNC:
+	case HWTSTAMP_FILTER_PTP_V2_L4_DELAY_REQ:
+	/* Although these three are accepted only IPV4 packets will be
+	 * timestamped */
+	case HWTSTAMP_FILTER_PTP_V2_EVENT:
+	case HWTSTAMP_FILTER_PTP_V2_SYNC:
+	case HWTSTAMP_FILTER_PTP_V2_DELAY_REQ:
+		init->rx_filter = HWTSTAMP_FILTER_PTP_V2_L4_EVENT;
+		new_mode = MC_CMD_PTP_MODE_V2;
+		enable_wanted = true;
+		break;
+	case HWTSTAMP_FILTER_PTP_V2_L2_EVENT:
+	case HWTSTAMP_FILTER_PTP_V2_L2_SYNC:
+	case HWTSTAMP_FILTER_PTP_V2_L2_DELAY_REQ:
+		/* Non-IP timestamping not supported */
+		return -ERANGE;
+		break;
+	default:
+		return -ERANGE;
+	}
+
+	if (init->tx_type != HWTSTAMP_TX_OFF)
+		enable_wanted = true;
+
+	rc = efx_ptp_change_mode(efx, enable_wanted, new_mode);
+	if (rc != 0)
+		return rc;
+
+	efx->ptp_data->config = *init;
+
+	return 0;
+}
+
+int efx_ptp_ioctl(struct efx_nic *efx, struct ifreq *ifr, int cmd)
+{
+	struct hwtstamp_config config;
+	int rc;
+
+	/* Not a PTP enabled port */
+	if (!efx->ptp_data)
+		return -ENOTTY;
+
+	if (copy_from_user(&config, ifr->ifr_data, sizeof(config)))
+		return -EFAULT;
+
+	rc = efx_ptp_ts_init(efx, &config);
+	if (rc != 0)
+		return rc;
+
+	return copy_to_user(ifr->ifr_data, &config, sizeof(config))
+		? -EFAULT : 0;
+}
+
+int efx_ptp_ts_settime(struct efx_nic *efx, struct efx_ts_settime *settime)
+{
+	int rc;
+	u8 inbuf[MC_CMD_PTP_IN_READ_NIC_TIME_LEN];
+	u8 outbuf[MC_CMD_PTP_OUT_READ_NIC_TIME_LEN];
+
+	if (!efx->ptp_data)
+		return -ENOTTY;
+
+	if (settime->iswrite) {
+		u8 inadj[MC_CMD_PTP_IN_ADJUST_LEN];
+	
+		MCDI_SET_DWORD(inadj, PTP_IN_OP, MC_CMD_PTP_OP_ADJUST);
+		MCDI_SET_DWORD(inadj, PTP_IN_ADJUST_FREQ_LO, 0);
+		MCDI_SET_DWORD(inadj, PTP_IN_ADJUST_FREQ_HI, 0);
+		MCDI_SET_DWORD(inadj, PTP_IN_ADJUST_SECONDS,
+			       (u32) settime->ts.tv_sec);
+		MCDI_SET_DWORD(inadj, PTP_IN_ADJUST_NANOSECONDS,
+			       (u32) settime->ts.tv_nsec);
+		rc = efx_mcdi_rpc(efx, MC_CMD_PTP, inadj, sizeof(inadj),
+				  NULL, 0, NULL);
+		if (rc != 0)
+			return rc;
+	}
+
+	MCDI_SET_DWORD(inbuf, PTP_IN_OP, MC_CMD_PTP_OP_READ_NIC_TIME);
+
+	rc = efx_mcdi_rpc(efx, MC_CMD_PTP, inbuf, sizeof(inbuf),
+			  outbuf, sizeof(outbuf), NULL);
+	if (rc != 0)
+		return rc;
+		
+	settime->ts.tv_sec = (s64) MCDI_DWORD(outbuf,
+					PTP_OUT_READ_NIC_TIME_SECONDS);
+	settime->ts.tv_nsec =(s32) MCDI_DWORD(outbuf,
+					 PTP_OUT_READ_NIC_TIME_NANOSECONDS);
+
+	return 0;
+}
+
+int efx_ptp_ts_adjtime(struct efx_nic *efx, struct efx_ts_adjtime *adjtime)
+{
+	if (!efx->ptp_data)
+		return -ENOTTY;
+		
+	if (adjtime->iswrite) {
+		u8 inadj[MC_CMD_PTP_IN_ADJUST_LEN];
+		s64 adjustment_ns;
+		int rc;
+		
+		if (adjtime->adjustment > MAX_PPB)
+			adjtime->adjustment = MAX_PPB;
+		else if (adjtime->adjustment < -MAX_PPB)
+			adjtime->adjustment = -MAX_PPB;
+		    
+		/* Convert ppb to fixed point ns. */
+		adjustment_ns = (adjtime->adjustment * PPB_SCALE_WORD) >> 
+				(PPB_EXTRA_BITS + MAX_PPB_BITS);
+		
+		MCDI_SET_DWORD(inadj, PTP_IN_OP, MC_CMD_PTP_OP_ADJUST);
+		MCDI_SET_DWORD(inadj, PTP_IN_ADJUST_FREQ_LO, 
+				(u32) adjustment_ns);
+		MCDI_SET_DWORD(inadj, PTP_IN_ADJUST_FREQ_HI, 
+				(u32) (adjustment_ns >> 32));
+		MCDI_SET_DWORD(inadj, PTP_IN_ADJUST_SECONDS, 0);
+		MCDI_SET_DWORD(inadj, PTP_IN_ADJUST_NANOSECONDS, 0);
+		rc = efx_mcdi_rpc(efx, MC_CMD_PTP, inadj, sizeof(inadj),
+				  NULL, 0, NULL);
+		if (rc != 0)
+			return rc;
+
+		efx->ptp_data->current_adjtime = adjtime->adjustment;
+	}
+	adjtime->adjustment = efx->ptp_data->current_adjtime;
+	
+	return 0;
+}
+
+int efx_ptp_ts_sync(struct efx_nic *efx, struct efx_ts_sync *sync)
+{
+	int rc;
+
+	if (!efx->ptp_data)
+		return -ENOTTY;
+
+	rc = efx_ptp_synchronize(efx, 4);
+	if (rc == 0) {
+		struct timespec uts;
+		ktime_t diff = ktime_sub(efx->ptp_data->mc_base_time,
+					 efx->ptp_data->host_base_time);
+		uts = ktime_to_timespec(diff);
+		sync->ts.tv_sec = uts.tv_sec;
+		sync->ts.tv_nsec = uts.tv_nsec;
+	}
+
+	return rc;
+}
+
+static void ptp_event_failure(struct efx_nic *efx, int expected_frag_len)
+{
+	struct efx_ptp_data *ptp = efx->ptp_data;
+
+	netif_err(efx, hw, efx->net_dev,
+		"PTP unexpected event length: got %d expected %d\n",
+		ptp->evt_frag_idx, expected_frag_len);
+	ptp->reset_required = true;
+	queue_work(ptp->workwq, &ptp->work);
+}
+
+/*
+ * Process a completed receive event.  Put it on the event queue and
+ * start worker thread.  This is required because event and their
+ * correspoding packets may come in either order.
+ */
+static void ptp_event_rx(struct efx_nic *efx, struct efx_ptp_data *ptp)
+{
+	struct efx_ptp_event_rx *evt = NULL;
+
+	if (ptp->evt_frag_idx != 3) {
+		ptp_event_failure(efx, 3);
+		return;
+	}
+
+	spin_lock_bh(&ptp->evt_lock);
+	if (!list_empty(&ptp->evt_free_list)) {
+		evt = list_first_entry(&ptp->evt_free_list,
+				       struct efx_ptp_event_rx, link);
+		list_del(&evt->link);
+
+		evt->seq0 = EFX_QWORD_FIELD(ptp->evt_frags[2], MCDI_EVENT_DATA);
+		evt->seq1 = (EFX_QWORD_FIELD(ptp->evt_frags[2],
+					     MCDI_EVENT_SRC)        |
+			     (EFX_QWORD_FIELD(ptp->evt_frags[1],
+					      MCDI_EVENT_SRC) << 8) |
+			     (EFX_QWORD_FIELD(ptp->evt_frags[0],
+					      MCDI_EVENT_SRC) << 16));
+		evt->hwtimestamp = ktime_set(
+			EFX_QWORD_FIELD(ptp->evt_frags[0], MCDI_EVENT_DATA),
+			EFX_QWORD_FIELD(ptp->evt_frags[1], MCDI_EVENT_DATA));
+		evt->expiry = jiffies + msecs_to_jiffies(PKT_EVENT_LIFETIME_MS);
+		list_add_tail(&evt->link, &ptp->evt_list);
+
+		queue_work(ptp->workwq, &ptp->work);
+	} else {
+		netif_err(efx, rx_err, efx->net_dev, "No free PTP event");
+	}
+	spin_unlock_bh(&ptp->evt_lock);
+}
+
+static void ptp_event_fault(struct efx_nic *efx, struct efx_ptp_data *ptp)
+{
+	int code = EFX_QWORD_FIELD(ptp->evt_frags[0], MCDI_EVENT_DATA);
+	if (ptp->evt_frag_idx != 1) {
+		ptp_event_failure(efx, 1);
+		return;
+	}
+
+	netif_err(efx, hw, efx->net_dev, "PTP error %d\n", code);
+}
+
+void efx_ptp_event(struct efx_nic *efx, efx_qword_t *ev)
+{
+	struct efx_ptp_data *ptp = efx->ptp_data;
+	int code = EFX_QWORD_FIELD(*ev, MCDI_EVENT_CODE);
+
+	if (!ptp->enabled)
+		return;
+
+	if (ptp->evt_frag_idx == 0) {
+		ptp->evt_code = code;
+	} else if (ptp->evt_code != code) {
+		netif_err(efx, hw, efx->net_dev,
+			  "PTP out of sequence event %d\n", code);
+		ptp->evt_frag_idx = 0;
+	}
+
+	ptp->evt_frags[ptp->evt_frag_idx++] = *ev;
+	if (!MCDI_EVENT_FIELD(*ev, CONT)) {
+		/* Process resulting event */
+		switch (code) {
+		case MCDI_EVENT_CODE_PTP_RX:
+			ptp_event_rx(efx, ptp);
+			break;
+		case MCDI_EVENT_CODE_PTP_FAULT:
+			ptp_event_fault(efx, ptp);
+			break;
+		default:
+			netif_err(efx, hw, efx->net_dev,
+				  "PTP unknown event %d\n", code);
+			break;
+		}
+		ptp->evt_frag_idx = 0;
+	} else if (MAX_EVENT_FRAGS == ptp->evt_frag_idx) {
+		netif_err(efx, hw, efx->net_dev,
+			  "PTP too many event fragments\n");
+		ptp->evt_frag_idx = 0;
+	}
+}
+
+static const struct efx_channel_type efx_ptp_channel_type = {
+	.handle_no_channel	= efx_ptp_handle_no_channel,
+	.pre_probe		= efx_ptp_probe_channel,
+	.post_remove		= efx_ptp_remove_channel,
+	.get_name		= efx_ptp_get_channel_name,
+	/* no copy operation; there is no need to reallocate this channel */
+	.receive_skb		= efx_ptp_rx,
+	.keep_eventq		= false,
+};
+
+void efx_ptp_probe(struct efx_nic *efx)
+{
+	/* Check whether PTP is implemented on this NIC.  The DISABLE
+	 * operation will succeed if and only if it is implemented.
+	 */
+	if (efx_ptp_disable(efx) == 0)
+		efx->extra_channel_type[EFX_EXTRA_CHANNEL_PTP] =
+			&efx_ptp_channel_type;
+}
diff -r 9566a4a50a43 drivers/net/sfc/qt202x_phy.c
--- /dev/null
+++ b/drivers/net/sfc/qt202x_phy.c
@@ -0,0 +1,477 @@
+/****************************************************************************
+ * Driver for Solarflare Solarstorm network controllers and boards
+ * Copyright 2006-2010 Solarflare Communications Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 as published
+ * by the Free Software Foundation, incorporated herein by reference.
+ */
+/*
+ * Driver for AMCC QT202x SFP+ and XFP adapters; see www.amcc.com for details
+ */
+
+#include <linux/slab.h>
+#include <linux/timer.h>
+#include <linux/delay.h>
+#include "efx.h"
+#include "mdio_10g.h"
+#include "phy.h"
+#include "nic.h"
+
+#define QT202X_REQUIRED_DEVS (MDIO_DEVS_PCS |		\
+			      MDIO_DEVS_PMAPMD |	\
+			      MDIO_DEVS_PHYXS)
+
+#define QT202X_LOOPBACKS ((1 << LOOPBACK_PCS) |		\
+			  (1 << LOOPBACK_PMAPMD) |	\
+			  (1 << LOOPBACK_PHYXS_WS))
+
+/****************************************************************************/
+/* Quake-specific MDIO registers */
+#define MDIO_QUAKE_LED0_REG	(0xD006)
+
+/* QT2025C only */
+#define PCS_FW_HEARTBEAT_REG	0xd7ee
+#define PCS_FW_HEARTB_LBN	0
+#define PCS_FW_HEARTB_WIDTH	8
+#define PCS_FW_PRODUCT_CODE_1	0xd7f0
+#define PCS_FW_VERSION_1	0xd7f3
+#define PCS_FW_BUILD_1		0xd7f6
+#define PCS_UC8051_STATUS_REG	0xd7fd
+#define PCS_UC_STATUS_LBN	0
+#define PCS_UC_STATUS_WIDTH	8
+#define PCS_UC_STATUS_FW_SAVE	0x20
+#define PMA_PMD_MODE_REG	0xc301
+#define PMA_PMD_RXIN_SEL_LBN	6
+#define PMA_PMD_FTX_CTRL2_REG	0xc309
+#define PMA_PMD_FTX_STATIC_LBN	13
+#define PMA_PMD_VEND1_REG	0xc001
+#define PMA_PMD_VEND1_LBTXD_LBN	15
+#define PCS_VEND1_REG	   	0xc000
+#define PCS_VEND1_LBTXD_LBN	5
+
+void falcon_qt202x_set_led(struct efx_nic *p, int led, int mode)
+{
+	int addr = MDIO_QUAKE_LED0_REG + led;
+	efx_mdio_write(p, MDIO_MMD_PMAPMD, addr, mode);
+}
+
+static int qt202x_phy_reconfigure(struct efx_nic *efx);
+
+struct qt202x_phy_data {
+	enum efx_phy_mode phy_mode;
+	bool bug17190_in_bad_state;
+	unsigned long bug17190_timer;
+	u32 firmware_ver;
+};
+
+#define QT2022C2_MAX_RESET_TIME 500
+#define QT2022C2_RESET_WAIT 10
+
+#define QT2025C_MAX_HEARTB_TIME (5 * HZ)
+#define QT2025C_HEARTB_WAIT 100
+#define QT2025C_MAX_FWSTART_TIME (25 * HZ / 10)
+#define QT2025C_FWSTART_WAIT 100
+
+#define BUG17190_INTERVAL (2 * HZ)
+
+static int qt2025c_wait_heartbeat(struct efx_nic *efx)
+{
+	unsigned long timeout = jiffies + QT2025C_MAX_HEARTB_TIME;
+	int reg, old_counter = 0;
+
+	/* Wait for firmware heartbeat to start */
+	for (;;) {
+		int counter;
+		reg = efx_mdio_read(efx, MDIO_MMD_PCS, PCS_FW_HEARTBEAT_REG);
+		if (reg < 0)
+			return reg;
+		counter = ((reg >> PCS_FW_HEARTB_LBN) &
+			    ((1 << PCS_FW_HEARTB_WIDTH) - 1));
+		if (old_counter == 0)
+			old_counter = counter;
+		else if (counter != old_counter)
+			break;
+		if (time_after(jiffies, timeout)) {
+			/* Some cables have EEPROMs that conflict with the
+			 * PHY's on-board EEPROM so it cannot load firmware */
+			netif_err(efx, hw, efx->net_dev,
+				  "If an SFP+ direct attach cable is"
+				  " connected, please check that it complies"
+				  " with the SFP+ specification\n");
+			return -ETIMEDOUT;
+		}
+		msleep(QT2025C_HEARTB_WAIT);
+	}
+
+	return 0;
+}
+
+static int qt2025c_wait_fw_status_good(struct efx_nic *efx)
+{
+	unsigned long timeout = jiffies + QT2025C_MAX_FWSTART_TIME;
+	int reg;
+
+	/* Wait for firmware status to look good */
+	for (;;) {
+		reg = efx_mdio_read(efx, MDIO_MMD_PCS, PCS_UC8051_STATUS_REG);
+		if (reg < 0)
+			return reg;
+		if ((reg &
+		     ((1 << PCS_UC_STATUS_WIDTH) - 1) << PCS_UC_STATUS_LBN) >=
+		    PCS_UC_STATUS_FW_SAVE)
+			break;
+		if (time_after(jiffies, timeout))
+			return -ETIMEDOUT;
+		msleep(QT2025C_FWSTART_WAIT);
+	}
+
+	return 0;
+}
+
+static void qt2025c_restart_firmware(struct efx_nic *efx)
+{
+	/* Restart microcontroller execution of firmware from RAM */
+	efx_mdio_write(efx, 3, 0xe854, 0x00c0);
+	efx_mdio_write(efx, 3, 0xe854, 0x0040);
+	msleep(50);
+}
+
+static int qt2025c_wait_reset(struct efx_nic *efx)
+{
+	int rc;
+
+	rc = qt2025c_wait_heartbeat(efx);
+	if (rc != 0)
+		return rc;
+
+	rc = qt2025c_wait_fw_status_good(efx);
+	if (rc == -ETIMEDOUT) {
+		/* Bug 17689: occasionally heartbeat starts but firmware status
+		 * code never progresses beyond 0x00.  Try again, once, after
+		 * restarting execution of the firmware image. */
+		netif_dbg(efx, hw, efx->net_dev,
+			  "bashing QT2025C microcontroller\n");
+		qt2025c_restart_firmware(efx);
+		rc = qt2025c_wait_heartbeat(efx);
+		if (rc != 0)
+			return rc;
+		rc = qt2025c_wait_fw_status_good(efx);
+	}
+
+	return rc;
+}
+
+static void qt2025c_firmware_id(struct efx_nic *efx)
+{
+	struct qt202x_phy_data *phy_data = efx->phy_data;
+	u8 firmware_id[9];
+	size_t i;
+
+	for (i = 0; i < sizeof(firmware_id); i++)
+		firmware_id[i] = efx_mdio_read(efx, MDIO_MMD_PCS,
+					       PCS_FW_PRODUCT_CODE_1 + i);
+	netif_info(efx, probe, efx->net_dev,
+		   "QT2025C firmware %xr%d v%d.%d.%d.%d [20%02d-%02d-%02d]\n",
+		   (firmware_id[0] << 8) | firmware_id[1], firmware_id[2],
+		   firmware_id[3] >> 4, firmware_id[3] & 0xf,
+		   firmware_id[4], firmware_id[5],
+		   firmware_id[6], firmware_id[7], firmware_id[8]);
+	phy_data->firmware_ver = ((firmware_id[3] & 0xf0) << 20) |
+				 ((firmware_id[3] & 0x0f) << 16) |
+				 (firmware_id[4] << 8) | firmware_id[5];
+}
+
+/* The PHY can get stuck in a state where it reports PHY_XS and PMA/PMD layers
+ * up, but PCS down (no block_lock).  If we notice this state persisting
+ * for a couple of seconds, we switch PMA/PMD loopback briefly on and then
+ * off again, which is normally sufficient to recover it.
+ */
+static void qt2025c_bug17190_workaround(struct efx_nic *efx)
+{
+	struct qt202x_phy_data *phy_data = efx->phy_data;
+
+	if (efx->link_state.up ||
+	    !efx_mdio_links_ok(efx, MDIO_DEVS_PMAPMD | MDIO_DEVS_PHYXS)) {
+		phy_data->bug17190_in_bad_state = false;
+		return;
+	}
+
+	if (!phy_data->bug17190_in_bad_state) {
+		phy_data->bug17190_in_bad_state = true;
+		phy_data->bug17190_timer = jiffies + BUG17190_INTERVAL;
+		return;
+	}
+
+	if (time_after_eq(jiffies, phy_data->bug17190_timer)) {
+		netif_dbg(efx, hw, efx->net_dev, "bashing QT2025C PMA/PMD\n");
+		efx_mdio_set_flag(efx, MDIO_MMD_PMAPMD, MDIO_CTRL1,
+				  MDIO_PMA_CTRL1_LOOPBACK, true);
+		msleep(100);
+		efx_mdio_set_flag(efx, MDIO_MMD_PMAPMD, MDIO_CTRL1,
+				  MDIO_PMA_CTRL1_LOOPBACK, false);
+		phy_data->bug17190_timer = jiffies + BUG17190_INTERVAL;
+	}
+}
+
+static int qt2025c_select_phy_mode(struct efx_nic *efx)
+{
+	struct qt202x_phy_data *phy_data = efx->phy_data;
+	struct falcon_board *board = falcon_board(efx);
+	int reg, rc, i;
+	uint16_t phy_op_mode;
+
+	/* Only 2.0.1.0+ PHY firmware supports the more optimal SFP+
+	 * Self-Configure mode.  Don't attempt any switching if we encounter
+	 * older firmware. */
+	if (phy_data->firmware_ver < 0x02000100)
+		return 0;
+
+	/* In general we will get optimal behaviour in "SFP+ Self-Configure"
+	 * mode; however, that powers down most of the PHY when no module is
+	 * present, so we must use a different mode (any fixed mode will do)
+	 * to be sure that loopbacks will work. */
+	phy_op_mode = (efx->loopback_mode == LOOPBACK_NONE) ? 0x0038 : 0x0020;
+
+	/* Only change mode if really necessary */
+	reg = efx_mdio_read(efx, 1, 0xc319);
+	if ((reg & 0x0038) == phy_op_mode)
+		return 0;
+	netif_dbg(efx, hw, efx->net_dev, "Switching PHY to mode 0x%04x\n",
+		  phy_op_mode);
+
+	/* This sequence replicates the register writes configured in the boot
+	 * EEPROM (including the differences between board revisions), except
+	 * that the operating mode is changed, and the PHY is prevented from
+	 * unnecessarily reloading the main firmware image again. */
+	efx_mdio_write(efx, 1, 0xc300, 0x0000);
+	/* (Note: this portion of the boot EEPROM sequence, which bit-bashes 9
+	 * STOPs onto the firmware/module I2C bus to reset it, varies across
+	 * board revisions, as the bus is connected to different GPIO/LED
+	 * outputs on the PHY.) */
+	if (board->major == 0 && board->minor < 2) {
+		efx_mdio_write(efx, 1, 0xc303, 0x4498);
+		for (i = 0; i < 9; i++) {
+			efx_mdio_write(efx, 1, 0xc303, 0x4488);
+			efx_mdio_write(efx, 1, 0xc303, 0x4480);
+			efx_mdio_write(efx, 1, 0xc303, 0x4490);
+			efx_mdio_write(efx, 1, 0xc303, 0x4498);
+		}
+	} else {
+		efx_mdio_write(efx, 1, 0xc303, 0x0920);
+		efx_mdio_write(efx, 1, 0xd008, 0x0004);
+		for (i = 0; i < 9; i++) {
+			efx_mdio_write(efx, 1, 0xc303, 0x0900);
+			efx_mdio_write(efx, 1, 0xd008, 0x0005);
+			efx_mdio_write(efx, 1, 0xc303, 0x0920);
+			efx_mdio_write(efx, 1, 0xd008, 0x0004);
+		}
+		efx_mdio_write(efx, 1, 0xc303, 0x4900);
+	}
+	efx_mdio_write(efx, 1, 0xc303, 0x4900);
+	efx_mdio_write(efx, 1, 0xc302, 0x0004);
+	efx_mdio_write(efx, 1, 0xc316, 0x0013);
+	efx_mdio_write(efx, 1, 0xc318, 0x0054);
+	efx_mdio_write(efx, 1, 0xc319, phy_op_mode);
+	efx_mdio_write(efx, 1, 0xc31a, 0x0098);
+	efx_mdio_write(efx, 3, 0x0026, 0x0e00);
+	efx_mdio_write(efx, 3, 0x0027, 0x0013);
+	efx_mdio_write(efx, 3, 0x0028, 0xa528);
+	efx_mdio_write(efx, 1, 0xd006, 0x000a);
+	efx_mdio_write(efx, 1, 0xd007, 0x0009);
+	efx_mdio_write(efx, 1, 0xd008, 0x0004);
+	/* This additional write is not present in the boot EEPROM.  It
+	 * prevents the PHY's internal boot ROM doing another pointless (and
+	 * slow) reload of the firmware image (the microcontroller's code
+	 * memory is not affected by the microcontroller reset). */
+	efx_mdio_write(efx, 1, 0xc317, 0x00ff);
+	/* PMA/PMD loopback sets RXIN to inverse polarity and the firmware
+	 * restart doesn't reset it. We need to do that ourselves. */
+	efx_mdio_set_flag(efx, 1, PMA_PMD_MODE_REG,
+			  1 << PMA_PMD_RXIN_SEL_LBN, false);
+	efx_mdio_write(efx, 1, 0xc300, 0x0002);
+	msleep(20);
+
+	/* Restart microcontroller execution of firmware from RAM */
+	qt2025c_restart_firmware(efx);
+
+	/* Wait for the microcontroller to be ready again */
+	rc = qt2025c_wait_reset(efx);
+	if (rc < 0) {
+		netif_err(efx, hw, efx->net_dev,
+			  "PHY microcontroller reset during mode switch "
+			  "timed out\n");
+		return rc;
+	}
+
+	return 0;
+}
+
+static int qt202x_reset_phy(struct efx_nic *efx)
+{
+	int rc;
+
+	if (efx->phy_type == PHY_TYPE_QT2025C) {
+		/* Wait for the reset triggered by falcon_reset_hw()
+		 * to complete */
+		rc = qt2025c_wait_reset(efx);
+		if (rc < 0)
+			goto fail;
+	} else {
+		/* Reset the PHYXS MMD. This is documented as doing
+		 * a complete soft reset. */
+		rc = efx_mdio_reset_mmd(efx, MDIO_MMD_PHYXS,
+					QT2022C2_MAX_RESET_TIME /
+					QT2022C2_RESET_WAIT,
+					QT2022C2_RESET_WAIT);
+		if (rc < 0)
+			goto fail;
+	}
+
+	/* Wait 250ms for the PHY to complete bootup */
+	msleep(250);
+
+	falcon_board(efx)->type->init_phy(efx);
+
+	return 0;
+
+ fail:
+	netif_err(efx, hw, efx->net_dev, "PHY reset timed out\n");
+	return rc;
+}
+
+static int qt202x_phy_probe(struct efx_nic *efx)
+{
+	struct qt202x_phy_data *phy_data;
+
+	phy_data = kzalloc(sizeof(struct qt202x_phy_data), GFP_KERNEL);
+	if (!phy_data)
+		return -ENOMEM;
+	efx->phy_data = phy_data;
+	phy_data->phy_mode = efx->phy_mode;
+
+	efx->mdio.mmds = QT202X_REQUIRED_DEVS;
+	efx->mdio.mode_support = MDIO_SUPPORTS_C45 | MDIO_EMULATE_C22;
+
+	efx->loopback_modes = QT202X_LOOPBACKS | FALCON_XMAC_LOOPBACKS;
+	efx->startup_loopback_mode = LOOPBACK_PCS;
+
+	strlcpy(efx->phy_name,
+		(efx->phy_type == PHY_TYPE_QT2025C) ? "Quake SFP+" : "Quake XFP",
+		sizeof(efx->phy_name));
+
+	return 0;
+}
+
+static int qt202x_phy_init(struct efx_nic *efx)
+{
+	u32 devid;
+	int rc;
+
+	/* Reset the PHY before reading the firmware version */
+	rc = qt202x_reset_phy(efx);
+	if (rc) {
+		netif_err(efx, probe, efx->net_dev, "PHY init failed\n");
+		return rc;
+	}
+
+	devid = efx_mdio_read_id(efx, MDIO_MMD_PHYXS);
+	netif_info(efx, probe, efx->net_dev,
+		   "PHY ID reg %x (OUI %06x model %02x revision %x)\n",
+		   devid, efx_mdio_id_oui(devid), efx_mdio_id_model(devid),
+		   efx_mdio_id_rev(devid));
+
+	if (efx->phy_type == PHY_TYPE_QT2025C)
+		qt2025c_firmware_id(efx);
+
+	return 0;
+}
+
+static int qt202x_link_ok(struct efx_nic *efx)
+{
+	return efx_mdio_links_ok(efx, QT202X_REQUIRED_DEVS);
+}
+
+static bool qt202x_phy_poll(struct efx_nic *efx)
+{
+	bool was_up = efx->link_state.up;
+
+	efx->link_state.up = qt202x_link_ok(efx);
+	efx->link_state.speed = 10000;
+	efx->link_state.fd = true;
+	efx->link_state.fc = efx->wanted_fc;
+
+	if (efx->phy_type == PHY_TYPE_QT2025C)
+		qt2025c_bug17190_workaround(efx);
+
+	return efx->link_state.up != was_up;
+}
+
+static int qt202x_phy_reconfigure(struct efx_nic *efx)
+{
+	struct qt202x_phy_data *phy_data = efx->phy_data;
+
+	if (efx->phy_type == PHY_TYPE_QT2025C) {
+		int rc = qt2025c_select_phy_mode(efx);
+		if (rc)
+			return rc;
+
+		/* There are several different register bits which can
+		 * disable TX (and save power) on direct-attach cables
+		 * or optical transceivers, varying somewhat between
+		 * firmware versions.  Only 'static mode' appears to
+		 * cover everything. */
+		mdio_set_flag(
+			&efx->mdio, efx->mdio.prtad, MDIO_MMD_PMAPMD,
+			PMA_PMD_FTX_CTRL2_REG, 1 << PMA_PMD_FTX_STATIC_LBN,
+			efx->phy_mode & PHY_MODE_TX_DISABLED ||
+			efx->phy_mode & PHY_MODE_LOW_POWER ||
+			efx->loopback_mode == LOOPBACK_PCS ||
+			efx->loopback_mode == LOOPBACK_PMAPMD);
+	} else {
+		/* Reset the PHY when moving from transmitter off or powered
+		 * off, to transmitter on and powered on */
+		unsigned mask = PHY_MODE_TX_DISABLED | PHY_MODE_LOW_POWER;
+		if (!(efx->phy_mode & mask) && (phy_data->phy_mode & mask)) {
+			int rc = qt202x_reset_phy(efx);
+			if (rc)
+				netif_err(efx, hw, efx->net_dev,
+					  "Error resetting phy\n");
+		}
+
+		efx_mdio_transmit_disable(efx);
+		efx_mdio_set_mmds_lpower(efx,
+					 !!(efx->phy_mode & PHY_MODE_LOW_POWER),
+					 QT202X_REQUIRED_DEVS);
+	}
+
+	efx_mdio_phy_reconfigure(efx);
+
+	phy_data->phy_mode = efx->phy_mode;
+
+	return 0;
+}
+
+static void qt202x_phy_get_settings(struct efx_nic *efx, struct ethtool_cmd *ecmd)
+{
+	mdio45_ethtool_gset(&efx->mdio, ecmd);
+}
+
+static void qt202x_phy_remove(struct efx_nic *efx)
+{
+	/* Free the context block */
+	kfree(efx->phy_data);
+	efx->phy_data = NULL;
+}
+
+const struct efx_phy_operations falcon_qt202x_phy_ops = {
+	.probe		 = qt202x_phy_probe,
+	.init		 = qt202x_phy_init,
+	.reconfigure	 = qt202x_phy_reconfigure,
+	.poll	     	 = qt202x_phy_poll,
+	.fini		 = efx_port_dummy_op_void,
+	.remove	  	 = qt202x_phy_remove,
+	.get_settings	 = qt202x_phy_get_settings,
+	.set_settings	 = efx_mdio_set_settings,
+	.test_alive	 = efx_mdio_test_alive,
+};
diff -r 9566a4a50a43 drivers/net/sfc/regs.h
--- /dev/null
+++ b/drivers/net/sfc/regs.h
@@ -0,0 +1,3182 @@
+/****************************************************************************
+ * Driver for Solarflare Solarstorm network controllers and boards
+ * Copyright 2005-2006 Fen Systems Ltd.
+ * Copyright 2006-2010 Solarflare Communications Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 as published
+ * by the Free Software Foundation, incorporated herein by reference.
+ */
+
+#ifndef EFX_REGS_H
+#define EFX_REGS_H
+
+/*
+ * Falcon hardware architecture definitions have a name prefix following
+ * the format:
+ *
+ *     F<type>_<min-rev><max-rev>_
+ *
+ * The following <type> strings are used:
+ *
+ *             MMIO register  MC register  Host memory structure
+ * -------------------------------------------------------------
+ * Address     R              MCR
+ * Bitfield    RF             MCRF         SF
+ * Enumerator  FE             MCFE         SE
+ *
+ * <min-rev> is the first revision to which the definition applies:
+ *
+ *     A: Falcon A1 (SFC4000AB)
+ *     B: Falcon B0 (SFC4000BA)
+ *     C: Siena A0 (SFL9021AA)
+ *
+ * If the definition has been changed or removed in later revisions
+ * then <max-rev> is the last revision to which the definition applies;
+ * otherwise it is "Z".
+ */
+
+/**************************************************************************
+ *
+ * Falcon/Siena registers and descriptors
+ *
+ **************************************************************************
+ */
+
+/* ADR_REGION_REG: Address region register */
+#define	FR_AZ_ADR_REGION 0x00000000
+#define	FRF_AZ_ADR_REGION3_LBN 96
+#define	FRF_AZ_ADR_REGION3_WIDTH 18
+#define	FRF_AZ_ADR_REGION2_LBN 64
+#define	FRF_AZ_ADR_REGION2_WIDTH 18
+#define	FRF_AZ_ADR_REGION1_LBN 32
+#define	FRF_AZ_ADR_REGION1_WIDTH 18
+#define	FRF_AZ_ADR_REGION0_LBN 0
+#define	FRF_AZ_ADR_REGION0_WIDTH 18
+
+/* INT_EN_REG_KER: Kernel driver Interrupt enable register */
+#define	FR_AZ_INT_EN_KER 0x00000010
+#define	FRF_AZ_KER_INT_LEVE_SEL_LBN 8
+#define	FRF_AZ_KER_INT_LEVE_SEL_WIDTH 6
+#define	FRF_AZ_KER_INT_CHAR_LBN 4
+#define	FRF_AZ_KER_INT_CHAR_WIDTH 1
+#define	FRF_AZ_KER_INT_KER_LBN 3
+#define	FRF_AZ_KER_INT_KER_WIDTH 1
+#define	FRF_AZ_DRV_INT_EN_KER_LBN 0
+#define	FRF_AZ_DRV_INT_EN_KER_WIDTH 1
+
+/* INT_EN_REG_CHAR: Char Driver interrupt enable register */
+#define	FR_BZ_INT_EN_CHAR 0x00000020
+#define	FRF_BZ_CHAR_INT_LEVE_SEL_LBN 8
+#define	FRF_BZ_CHAR_INT_LEVE_SEL_WIDTH 6
+#define	FRF_BZ_CHAR_INT_CHAR_LBN 4
+#define	FRF_BZ_CHAR_INT_CHAR_WIDTH 1
+#define	FRF_BZ_CHAR_INT_KER_LBN 3
+#define	FRF_BZ_CHAR_INT_KER_WIDTH 1
+#define	FRF_BZ_DRV_INT_EN_CHAR_LBN 0
+#define	FRF_BZ_DRV_INT_EN_CHAR_WIDTH 1
+
+/* INT_ADR_REG_KER: Interrupt host address for Kernel driver */
+#define	FR_AZ_INT_ADR_KER 0x00000030
+#define	FRF_AZ_NORM_INT_VEC_DIS_KER_LBN 64
+#define	FRF_AZ_NORM_INT_VEC_DIS_KER_WIDTH 1
+#define	FRF_AZ_INT_ADR_KER_LBN 0
+#define	FRF_AZ_INT_ADR_KER_WIDTH 64
+
+/* INT_ADR_REG_CHAR: Interrupt host address for Char driver */
+#define	FR_BZ_INT_ADR_CHAR 0x00000040
+#define	FRF_BZ_NORM_INT_VEC_DIS_CHAR_LBN 64
+#define	FRF_BZ_NORM_INT_VEC_DIS_CHAR_WIDTH 1
+#define	FRF_BZ_INT_ADR_CHAR_LBN 0
+#define	FRF_BZ_INT_ADR_CHAR_WIDTH 64
+
+/* INT_ACK_KER: Kernel interrupt acknowledge register */
+#define	FR_AA_INT_ACK_KER 0x00000050
+#define	FRF_AA_INT_ACK_KER_FIELD_LBN 0
+#define	FRF_AA_INT_ACK_KER_FIELD_WIDTH 32
+
+/* INT_ISR0_REG: Function 0 Interrupt Acknowlege Status register */
+#define	FR_BZ_INT_ISR0 0x00000090
+#define	FRF_BZ_INT_ISR_REG_LBN 0
+#define	FRF_BZ_INT_ISR_REG_WIDTH 64
+
+/* HW_INIT_REG: Hardware initialization register */
+#define	FR_AZ_HW_INIT 0x000000c0
+#define	FRF_BB_BDMRD_CPLF_FULL_LBN 124
+#define	FRF_BB_BDMRD_CPLF_FULL_WIDTH 1
+#define	FRF_BB_PCIE_CPL_TIMEOUT_CTRL_LBN 121
+#define	FRF_BB_PCIE_CPL_TIMEOUT_CTRL_WIDTH 3
+#define	FRF_CZ_TX_MRG_TAGS_LBN 120
+#define	FRF_CZ_TX_MRG_TAGS_WIDTH 1
+#define	FRF_AB_TRGT_MASK_ALL_LBN 100
+#define	FRF_AB_TRGT_MASK_ALL_WIDTH 1
+#define	FRF_AZ_DOORBELL_DROP_LBN 92
+#define	FRF_AZ_DOORBELL_DROP_WIDTH 8
+#define	FRF_AB_TX_RREQ_MASK_EN_LBN 76
+#define	FRF_AB_TX_RREQ_MASK_EN_WIDTH 1
+#define	FRF_AB_PE_EIDLE_DIS_LBN 75
+#define	FRF_AB_PE_EIDLE_DIS_WIDTH 1
+#define	FRF_AA_FC_BLOCKING_EN_LBN 45
+#define	FRF_AA_FC_BLOCKING_EN_WIDTH 1
+#define	FRF_BZ_B2B_REQ_EN_LBN 45
+#define	FRF_BZ_B2B_REQ_EN_WIDTH 1
+#define	FRF_AA_B2B_REQ_EN_LBN 44
+#define	FRF_AA_B2B_REQ_EN_WIDTH 1
+#define	FRF_BB_FC_BLOCKING_EN_LBN 44
+#define	FRF_BB_FC_BLOCKING_EN_WIDTH 1
+#define	FRF_AZ_POST_WR_MASK_LBN 40
+#define	FRF_AZ_POST_WR_MASK_WIDTH 4
+#define	FRF_AZ_TLP_TC_LBN 34
+#define	FRF_AZ_TLP_TC_WIDTH 3
+#define	FRF_AZ_TLP_ATTR_LBN 32
+#define	FRF_AZ_TLP_ATTR_WIDTH 2
+#define	FRF_AB_INTB_VEC_LBN 24
+#define	FRF_AB_INTB_VEC_WIDTH 5
+#define	FRF_AB_INTA_VEC_LBN 16
+#define	FRF_AB_INTA_VEC_WIDTH 5
+#define	FRF_AZ_WD_TIMER_LBN 8
+#define	FRF_AZ_WD_TIMER_WIDTH 8
+#define	FRF_AZ_US_DISABLE_LBN 5
+#define	FRF_AZ_US_DISABLE_WIDTH 1
+#define	FRF_AZ_TLP_EP_LBN 4
+#define	FRF_AZ_TLP_EP_WIDTH 1
+#define	FRF_AZ_ATTR_SEL_LBN 3
+#define	FRF_AZ_ATTR_SEL_WIDTH 1
+#define	FRF_AZ_TD_SEL_LBN 1
+#define	FRF_AZ_TD_SEL_WIDTH 1
+#define	FRF_AZ_TLP_TD_LBN 0
+#define	FRF_AZ_TLP_TD_WIDTH 1
+
+/* EE_SPI_HCMD_REG: SPI host command register */
+#define	FR_AB_EE_SPI_HCMD 0x00000100
+#define	FRF_AB_EE_SPI_HCMD_CMD_EN_LBN 31
+#define	FRF_AB_EE_SPI_HCMD_CMD_EN_WIDTH 1
+#define	FRF_AB_EE_WR_TIMER_ACTIVE_LBN 28
+#define	FRF_AB_EE_WR_TIMER_ACTIVE_WIDTH 1
+#define	FRF_AB_EE_SPI_HCMD_SF_SEL_LBN 24
+#define	FRF_AB_EE_SPI_HCMD_SF_SEL_WIDTH 1
+#define	FRF_AB_EE_SPI_HCMD_DABCNT_LBN 16
+#define	FRF_AB_EE_SPI_HCMD_DABCNT_WIDTH 5
+#define	FRF_AB_EE_SPI_HCMD_READ_LBN 15
+#define	FRF_AB_EE_SPI_HCMD_READ_WIDTH 1
+#define	FRF_AB_EE_SPI_HCMD_DUBCNT_LBN 12
+#define	FRF_AB_EE_SPI_HCMD_DUBCNT_WIDTH 2
+#define	FRF_AB_EE_SPI_HCMD_ADBCNT_LBN 8
+#define	FRF_AB_EE_SPI_HCMD_ADBCNT_WIDTH 2
+#define	FRF_AB_EE_SPI_HCMD_ENC_LBN 0
+#define	FRF_AB_EE_SPI_HCMD_ENC_WIDTH 8
+
+/* USR_EV_CFG: User Level Event Configuration register */
+#define	FR_CZ_USR_EV_CFG 0x00000100
+#define	FRF_CZ_USREV_DIS_LBN 16
+#define	FRF_CZ_USREV_DIS_WIDTH 1
+#define	FRF_CZ_DFLT_EVQ_LBN 0
+#define	FRF_CZ_DFLT_EVQ_WIDTH 10
+
+/* EE_SPI_HADR_REG: SPI host address register */
+#define	FR_AB_EE_SPI_HADR 0x00000110
+#define	FRF_AB_EE_SPI_HADR_DUBYTE_LBN 24
+#define	FRF_AB_EE_SPI_HADR_DUBYTE_WIDTH 8
+#define	FRF_AB_EE_SPI_HADR_ADR_LBN 0
+#define	FRF_AB_EE_SPI_HADR_ADR_WIDTH 24
+
+/* EE_SPI_HDATA_REG: SPI host data register */
+#define	FR_AB_EE_SPI_HDATA 0x00000120
+#define	FRF_AB_EE_SPI_HDATA3_LBN 96
+#define	FRF_AB_EE_SPI_HDATA3_WIDTH 32
+#define	FRF_AB_EE_SPI_HDATA2_LBN 64
+#define	FRF_AB_EE_SPI_HDATA2_WIDTH 32
+#define	FRF_AB_EE_SPI_HDATA1_LBN 32
+#define	FRF_AB_EE_SPI_HDATA1_WIDTH 32
+#define	FRF_AB_EE_SPI_HDATA0_LBN 0
+#define	FRF_AB_EE_SPI_HDATA0_WIDTH 32
+
+/* EE_BASE_PAGE_REG: Expansion ROM base mirror register */
+#define	FR_AB_EE_BASE_PAGE 0x00000130
+#define	FRF_AB_EE_EXPROM_MASK_LBN 16
+#define	FRF_AB_EE_EXPROM_MASK_WIDTH 13
+#define	FRF_AB_EE_EXP_ROM_WINDOW_BASE_LBN 0
+#define	FRF_AB_EE_EXP_ROM_WINDOW_BASE_WIDTH 13
+
+/* EE_VPD_CFG0_REG: SPI/VPD configuration register 0 */
+#define	FR_AB_EE_VPD_CFG0 0x00000140
+#define	FRF_AB_EE_SF_FASTRD_EN_LBN 127
+#define	FRF_AB_EE_SF_FASTRD_EN_WIDTH 1
+#define	FRF_AB_EE_SF_CLOCK_DIV_LBN 120
+#define	FRF_AB_EE_SF_CLOCK_DIV_WIDTH 7
+#define	FRF_AB_EE_VPD_WIP_POLL_LBN 119
+#define	FRF_AB_EE_VPD_WIP_POLL_WIDTH 1
+#define	FRF_AB_EE_EE_CLOCK_DIV_LBN 112
+#define	FRF_AB_EE_EE_CLOCK_DIV_WIDTH 7
+#define	FRF_AB_EE_EE_WR_TMR_VALUE_LBN 96
+#define	FRF_AB_EE_EE_WR_TMR_VALUE_WIDTH 16
+#define	FRF_AB_EE_VPDW_LENGTH_LBN 80
+#define	FRF_AB_EE_VPDW_LENGTH_WIDTH 15
+#define	FRF_AB_EE_VPDW_BASE_LBN 64
+#define	FRF_AB_EE_VPDW_BASE_WIDTH 15
+#define	FRF_AB_EE_VPD_WR_CMD_EN_LBN 56
+#define	FRF_AB_EE_VPD_WR_CMD_EN_WIDTH 8
+#define	FRF_AB_EE_VPD_BASE_LBN 32
+#define	FRF_AB_EE_VPD_BASE_WIDTH 24
+#define	FRF_AB_EE_VPD_LENGTH_LBN 16
+#define	FRF_AB_EE_VPD_LENGTH_WIDTH 15
+#define	FRF_AB_EE_VPD_AD_SIZE_LBN 8
+#define	FRF_AB_EE_VPD_AD_SIZE_WIDTH 5
+#define	FRF_AB_EE_VPD_ACCESS_ON_LBN 5
+#define	FRF_AB_EE_VPD_ACCESS_ON_WIDTH 1
+#define	FRF_AB_EE_VPD_ACCESS_BLOCK_LBN 4
+#define	FRF_AB_EE_VPD_ACCESS_BLOCK_WIDTH 1
+#define	FRF_AB_EE_VPD_DEV_SF_SEL_LBN 2
+#define	FRF_AB_EE_VPD_DEV_SF_SEL_WIDTH 1
+#define	FRF_AB_EE_VPD_EN_AD9_MODE_LBN 1
+#define	FRF_AB_EE_VPD_EN_AD9_MODE_WIDTH 1
+#define	FRF_AB_EE_VPD_EN_LBN 0
+#define	FRF_AB_EE_VPD_EN_WIDTH 1
+
+/* EE_VPD_SW_CNTL_REG: VPD access SW control register */
+#define	FR_AB_EE_VPD_SW_CNTL 0x00000150
+#define	FRF_AB_EE_VPD_CYCLE_PENDING_LBN 31
+#define	FRF_AB_EE_VPD_CYCLE_PENDING_WIDTH 1
+#define	FRF_AB_EE_VPD_CYC_WRITE_LBN 28
+#define	FRF_AB_EE_VPD_CYC_WRITE_WIDTH 1
+#define	FRF_AB_EE_VPD_CYC_ADR_LBN 0
+#define	FRF_AB_EE_VPD_CYC_ADR_WIDTH 15
+
+/* EE_VPD_SW_DATA_REG: VPD access SW data register */
+#define	FR_AB_EE_VPD_SW_DATA 0x00000160
+#define	FRF_AB_EE_VPD_CYC_DAT_LBN 0
+#define	FRF_AB_EE_VPD_CYC_DAT_WIDTH 32
+
+/* PBMX_DBG_IADDR_REG: Capture Module address register */
+#define	FR_CZ_PBMX_DBG_IADDR 0x000001f0
+#define	FRF_CZ_PBMX_DBG_IADDR_LBN 0
+#define	FRF_CZ_PBMX_DBG_IADDR_WIDTH 32
+
+/* PCIE_CORE_INDIRECT_REG: Indirect Access to PCIE Core registers */
+#define	FR_BB_PCIE_CORE_INDIRECT 0x000001f0
+#define	FRF_BB_PCIE_CORE_TARGET_DATA_LBN 32
+#define	FRF_BB_PCIE_CORE_TARGET_DATA_WIDTH 32
+#define	FRF_BB_PCIE_CORE_INDIRECT_ACCESS_DIR_LBN 15
+#define	FRF_BB_PCIE_CORE_INDIRECT_ACCESS_DIR_WIDTH 1
+#define	FRF_BB_PCIE_CORE_TARGET_REG_ADRS_LBN 0
+#define	FRF_BB_PCIE_CORE_TARGET_REG_ADRS_WIDTH 12
+
+/* PBMX_DBG_IDATA_REG: Capture Module data register */
+#define	FR_CZ_PBMX_DBG_IDATA 0x000001f8
+#define	FRF_CZ_PBMX_DBG_IDATA_LBN 0
+#define	FRF_CZ_PBMX_DBG_IDATA_WIDTH 64
+
+/* NIC_STAT_REG: NIC status register */
+#define	FR_AB_NIC_STAT 0x00000200
+#define	FRF_BB_AER_DIS_LBN 34
+#define	FRF_BB_AER_DIS_WIDTH 1
+#define	FRF_BB_EE_STRAP_EN_LBN 31
+#define	FRF_BB_EE_STRAP_EN_WIDTH 1
+#define	FRF_BB_EE_STRAP_LBN 24
+#define	FRF_BB_EE_STRAP_WIDTH 4
+#define	FRF_BB_REVISION_ID_LBN 17
+#define	FRF_BB_REVISION_ID_WIDTH 7
+#define	FRF_AB_ONCHIP_SRAM_LBN 16
+#define	FRF_AB_ONCHIP_SRAM_WIDTH 1
+#define	FRF_AB_SF_PRST_LBN 9
+#define	FRF_AB_SF_PRST_WIDTH 1
+#define	FRF_AB_EE_PRST_LBN 8
+#define	FRF_AB_EE_PRST_WIDTH 1
+#define	FRF_AB_ATE_MODE_LBN 3
+#define	FRF_AB_ATE_MODE_WIDTH 1
+#define	FRF_AB_STRAP_PINS_LBN 0
+#define	FRF_AB_STRAP_PINS_WIDTH 3
+
+/* GPIO_CTL_REG: GPIO control register */
+#define	FR_AB_GPIO_CTL 0x00000210
+#define	FRF_AB_GPIO_OUT3_LBN 112
+#define	FRF_AB_GPIO_OUT3_WIDTH 16
+#define	FRF_AB_GPIO_IN3_LBN 104
+#define	FRF_AB_GPIO_IN3_WIDTH 8
+#define	FRF_AB_GPIO_PWRUP_VALUE3_LBN 96
+#define	FRF_AB_GPIO_PWRUP_VALUE3_WIDTH 8
+#define	FRF_AB_GPIO_OUT2_LBN 80
+#define	FRF_AB_GPIO_OUT2_WIDTH 16
+#define	FRF_AB_GPIO_IN2_LBN 72
+#define	FRF_AB_GPIO_IN2_WIDTH 8
+#define	FRF_AB_GPIO_PWRUP_VALUE2_LBN 64
+#define	FRF_AB_GPIO_PWRUP_VALUE2_WIDTH 8
+#define	FRF_AB_GPIO15_OEN_LBN 63
+#define	FRF_AB_GPIO15_OEN_WIDTH 1
+#define	FRF_AB_GPIO14_OEN_LBN 62
+#define	FRF_AB_GPIO14_OEN_WIDTH 1
+#define	FRF_AB_GPIO13_OEN_LBN 61
+#define	FRF_AB_GPIO13_OEN_WIDTH 1
+#define	FRF_AB_GPIO12_OEN_LBN 60
+#define	FRF_AB_GPIO12_OEN_WIDTH 1
+#define	FRF_AB_GPIO11_OEN_LBN 59
+#define	FRF_AB_GPIO11_OEN_WIDTH 1
+#define	FRF_AB_GPIO10_OEN_LBN 58
+#define	FRF_AB_GPIO10_OEN_WIDTH 1
+#define	FRF_AB_GPIO9_OEN_LBN 57
+#define	FRF_AB_GPIO9_OEN_WIDTH 1
+#define	FRF_AB_GPIO8_OEN_LBN 56
+#define	FRF_AB_GPIO8_OEN_WIDTH 1
+#define	FRF_AB_GPIO15_OUT_LBN 55
+#define	FRF_AB_GPIO15_OUT_WIDTH 1
+#define	FRF_AB_GPIO14_OUT_LBN 54
+#define	FRF_AB_GPIO14_OUT_WIDTH 1
+#define	FRF_AB_GPIO13_OUT_LBN 53
+#define	FRF_AB_GPIO13_OUT_WIDTH 1
+#define	FRF_AB_GPIO12_OUT_LBN 52
+#define	FRF_AB_GPIO12_OUT_WIDTH 1
+#define	FRF_AB_GPIO11_OUT_LBN 51
+#define	FRF_AB_GPIO11_OUT_WIDTH 1
+#define	FRF_AB_GPIO10_OUT_LBN 50
+#define	FRF_AB_GPIO10_OUT_WIDTH 1
+#define	FRF_AB_GPIO9_OUT_LBN 49
+#define	FRF_AB_GPIO9_OUT_WIDTH 1
+#define	FRF_AB_GPIO8_OUT_LBN 48
+#define	FRF_AB_GPIO8_OUT_WIDTH 1
+#define	FRF_AB_GPIO15_IN_LBN 47
+#define	FRF_AB_GPIO15_IN_WIDTH 1
+#define	FRF_AB_GPIO14_IN_LBN 46
+#define	FRF_AB_GPIO14_IN_WIDTH 1
+#define	FRF_AB_GPIO13_IN_LBN 45
+#define	FRF_AB_GPIO13_IN_WIDTH 1
+#define	FRF_AB_GPIO12_IN_LBN 44
+#define	FRF_AB_GPIO12_IN_WIDTH 1
+#define	FRF_AB_GPIO11_IN_LBN 43
+#define	FRF_AB_GPIO11_IN_WIDTH 1
+#define	FRF_AB_GPIO10_IN_LBN 42
+#define	FRF_AB_GPIO10_IN_WIDTH 1
+#define	FRF_AB_GPIO9_IN_LBN 41
+#define	FRF_AB_GPIO9_IN_WIDTH 1
+#define	FRF_AB_GPIO8_IN_LBN 40
+#define	FRF_AB_GPIO8_IN_WIDTH 1
+#define	FRF_AB_GPIO15_PWRUP_VALUE_LBN 39
+#define	FRF_AB_GPIO15_PWRUP_VALUE_WIDTH 1
+#define	FRF_AB_GPIO14_PWRUP_VALUE_LBN 38
+#define	FRF_AB_GPIO14_PWRUP_VALUE_WIDTH 1
+#define	FRF_AB_GPIO13_PWRUP_VALUE_LBN 37
+#define	FRF_AB_GPIO13_PWRUP_VALUE_WIDTH 1
+#define	FRF_AB_GPIO12_PWRUP_VALUE_LBN 36
+#define	FRF_AB_GPIO12_PWRUP_VALUE_WIDTH 1
+#define	FRF_AB_GPIO11_PWRUP_VALUE_LBN 35
+#define	FRF_AB_GPIO11_PWRUP_VALUE_WIDTH 1
+#define	FRF_AB_GPIO10_PWRUP_VALUE_LBN 34
+#define	FRF_AB_GPIO10_PWRUP_VALUE_WIDTH 1
+#define	FRF_AB_GPIO9_PWRUP_VALUE_LBN 33
+#define	FRF_AB_GPIO9_PWRUP_VALUE_WIDTH 1
+#define	FRF_AB_GPIO8_PWRUP_VALUE_LBN 32
+#define	FRF_AB_GPIO8_PWRUP_VALUE_WIDTH 1
+#define	FRF_AB_CLK156_OUT_EN_LBN 31
+#define	FRF_AB_CLK156_OUT_EN_WIDTH 1
+#define	FRF_AB_USE_NIC_CLK_LBN 30
+#define	FRF_AB_USE_NIC_CLK_WIDTH 1
+#define	FRF_AB_GPIO5_OEN_LBN 29
+#define	FRF_AB_GPIO5_OEN_WIDTH 1
+#define	FRF_AB_GPIO4_OEN_LBN 28
+#define	FRF_AB_GPIO4_OEN_WIDTH 1
+#define	FRF_AB_GPIO3_OEN_LBN 27
+#define	FRF_AB_GPIO3_OEN_WIDTH 1
+#define	FRF_AB_GPIO2_OEN_LBN 26
+#define	FRF_AB_GPIO2_OEN_WIDTH 1
+#define	FRF_AB_GPIO1_OEN_LBN 25
+#define	FRF_AB_GPIO1_OEN_WIDTH 1
+#define	FRF_AB_GPIO0_OEN_LBN 24
+#define	FRF_AB_GPIO0_OEN_WIDTH 1
+#define	FRF_AB_GPIO7_OUT_LBN 23
+#define	FRF_AB_GPIO7_OUT_WIDTH 1
+#define	FRF_AB_GPIO6_OUT_LBN 22
+#define	FRF_AB_GPIO6_OUT_WIDTH 1
+#define	FRF_AB_GPIO5_OUT_LBN 21
+#define	FRF_AB_GPIO5_OUT_WIDTH 1
+#define	FRF_AB_GPIO4_OUT_LBN 20
+#define	FRF_AB_GPIO4_OUT_WIDTH 1
+#define	FRF_AB_GPIO3_OUT_LBN 19
+#define	FRF_AB_GPIO3_OUT_WIDTH 1
+#define	FRF_AB_GPIO2_OUT_LBN 18
+#define	FRF_AB_GPIO2_OUT_WIDTH 1
+#define	FRF_AB_GPIO1_OUT_LBN 17
+#define	FRF_AB_GPIO1_OUT_WIDTH 1
+#define	FRF_AB_GPIO0_OUT_LBN 16
+#define	FRF_AB_GPIO0_OUT_WIDTH 1
+#define	FRF_AB_GPIO7_IN_LBN 15
+#define	FRF_AB_GPIO7_IN_WIDTH 1
+#define	FRF_AB_GPIO6_IN_LBN 14
+#define	FRF_AB_GPIO6_IN_WIDTH 1
+#define	FRF_AB_GPIO5_IN_LBN 13
+#define	FRF_AB_GPIO5_IN_WIDTH 1
+#define	FRF_AB_GPIO4_IN_LBN 12
+#define	FRF_AB_GPIO4_IN_WIDTH 1
+#define	FRF_AB_GPIO3_IN_LBN 11
+#define	FRF_AB_GPIO3_IN_WIDTH 1
+#define	FRF_AB_GPIO2_IN_LBN 10
+#define	FRF_AB_GPIO2_IN_WIDTH 1
+#define	FRF_AB_GPIO1_IN_LBN 9
+#define	FRF_AB_GPIO1_IN_WIDTH 1
+#define	FRF_AB_GPIO0_IN_LBN 8
+#define	FRF_AB_GPIO0_IN_WIDTH 1
+#define	FRF_AB_GPIO7_PWRUP_VALUE_LBN 7
+#define	FRF_AB_GPIO7_PWRUP_VALUE_WIDTH 1
+#define	FRF_AB_GPIO6_PWRUP_VALUE_LBN 6
+#define	FRF_AB_GPIO6_PWRUP_VALUE_WIDTH 1
+#define	FRF_AB_GPIO5_PWRUP_VALUE_LBN 5
+#define	FRF_AB_GPIO5_PWRUP_VALUE_WIDTH 1
+#define	FRF_AB_GPIO4_PWRUP_VALUE_LBN 4
+#define	FRF_AB_GPIO4_PWRUP_VALUE_WIDTH 1
+#define	FRF_AB_GPIO3_PWRUP_VALUE_LBN 3
+#define	FRF_AB_GPIO3_PWRUP_VALUE_WIDTH 1
+#define	FRF_AB_GPIO2_PWRUP_VALUE_LBN 2
+#define	FRF_AB_GPIO2_PWRUP_VALUE_WIDTH 1
+#define	FRF_AB_GPIO1_PWRUP_VALUE_LBN 1
+#define	FRF_AB_GPIO1_PWRUP_VALUE_WIDTH 1
+#define	FRF_AB_GPIO0_PWRUP_VALUE_LBN 0
+#define	FRF_AB_GPIO0_PWRUP_VALUE_WIDTH 1
+
+/* GLB_CTL_REG: Global control register */
+#define	FR_AB_GLB_CTL 0x00000220
+#define	FRF_AB_EXT_PHY_RST_CTL_LBN 63
+#define	FRF_AB_EXT_PHY_RST_CTL_WIDTH 1
+#define	FRF_AB_XAUI_SD_RST_CTL_LBN 62
+#define	FRF_AB_XAUI_SD_RST_CTL_WIDTH 1
+#define	FRF_AB_PCIE_SD_RST_CTL_LBN 61
+#define	FRF_AB_PCIE_SD_RST_CTL_WIDTH 1
+#define	FRF_AA_PCIX_RST_CTL_LBN 60
+#define	FRF_AA_PCIX_RST_CTL_WIDTH 1
+#define	FRF_BB_BIU_RST_CTL_LBN 60
+#define	FRF_BB_BIU_RST_CTL_WIDTH 1
+#define	FRF_AB_PCIE_STKY_RST_CTL_LBN 59
+#define	FRF_AB_PCIE_STKY_RST_CTL_WIDTH 1
+#define	FRF_AB_PCIE_NSTKY_RST_CTL_LBN 58
+#define	FRF_AB_PCIE_NSTKY_RST_CTL_WIDTH 1
+#define	FRF_AB_PCIE_CORE_RST_CTL_LBN 57
+#define	FRF_AB_PCIE_CORE_RST_CTL_WIDTH 1
+#define	FRF_AB_XGRX_RST_CTL_LBN 56
+#define	FRF_AB_XGRX_RST_CTL_WIDTH 1
+#define	FRF_AB_XGTX_RST_CTL_LBN 55
+#define	FRF_AB_XGTX_RST_CTL_WIDTH 1
+#define	FRF_AB_EM_RST_CTL_LBN 54
+#define	FRF_AB_EM_RST_CTL_WIDTH 1
+#define	FRF_AB_EV_RST_CTL_LBN 53
+#define	FRF_AB_EV_RST_CTL_WIDTH 1
+#define	FRF_AB_SR_RST_CTL_LBN 52
+#define	FRF_AB_SR_RST_CTL_WIDTH 1
+#define	FRF_AB_RX_RST_CTL_LBN 51
+#define	FRF_AB_RX_RST_CTL_WIDTH 1
+#define	FRF_AB_TX_RST_CTL_LBN 50
+#define	FRF_AB_TX_RST_CTL_WIDTH 1
+#define	FRF_AB_EE_RST_CTL_LBN 49
+#define	FRF_AB_EE_RST_CTL_WIDTH 1
+#define	FRF_AB_CS_RST_CTL_LBN 48
+#define	FRF_AB_CS_RST_CTL_WIDTH 1
+#define	FRF_AB_HOT_RST_CTL_LBN 40
+#define	FRF_AB_HOT_RST_CTL_WIDTH 2
+#define	FRF_AB_RST_EXT_PHY_LBN 31
+#define	FRF_AB_RST_EXT_PHY_WIDTH 1
+#define	FRF_AB_RST_XAUI_SD_LBN 30
+#define	FRF_AB_RST_XAUI_SD_WIDTH 1
+#define	FRF_AB_RST_PCIE_SD_LBN 29
+#define	FRF_AB_RST_PCIE_SD_WIDTH 1
+#define	FRF_AA_RST_PCIX_LBN 28
+#define	FRF_AA_RST_PCIX_WIDTH 1
+#define	FRF_BB_RST_BIU_LBN 28
+#define	FRF_BB_RST_BIU_WIDTH 1
+#define	FRF_AB_RST_PCIE_STKY_LBN 27
+#define	FRF_AB_RST_PCIE_STKY_WIDTH 1
+#define	FRF_AB_RST_PCIE_NSTKY_LBN 26
+#define	FRF_AB_RST_PCIE_NSTKY_WIDTH 1
+#define	FRF_AB_RST_PCIE_CORE_LBN 25
+#define	FRF_AB_RST_PCIE_CORE_WIDTH 1
+#define	FRF_AB_RST_XGRX_LBN 24
+#define	FRF_AB_RST_XGRX_WIDTH 1
+#define	FRF_AB_RST_XGTX_LBN 23
+#define	FRF_AB_RST_XGTX_WIDTH 1
+#define	FRF_AB_RST_EM_LBN 22
+#define	FRF_AB_RST_EM_WIDTH 1
+#define	FRF_AB_RST_EV_LBN 21
+#define	FRF_AB_RST_EV_WIDTH 1
+#define	FRF_AB_RST_SR_LBN 20
+#define	FRF_AB_RST_SR_WIDTH 1
+#define	FRF_AB_RST_RX_LBN 19
+#define	FRF_AB_RST_RX_WIDTH 1
+#define	FRF_AB_RST_TX_LBN 18
+#define	FRF_AB_RST_TX_WIDTH 1
+#define	FRF_AB_RST_SF_LBN 17
+#define	FRF_AB_RST_SF_WIDTH 1
+#define	FRF_AB_RST_CS_LBN 16
+#define	FRF_AB_RST_CS_WIDTH 1
+#define	FRF_AB_INT_RST_DUR_LBN 4
+#define	FRF_AB_INT_RST_DUR_WIDTH 3
+#define	FRF_AB_EXT_PHY_RST_DUR_LBN 1
+#define	FRF_AB_EXT_PHY_RST_DUR_WIDTH 3
+#define	FFE_AB_EXT_PHY_RST_DUR_10240US 7
+#define	FFE_AB_EXT_PHY_RST_DUR_5120US 6
+#define	FFE_AB_EXT_PHY_RST_DUR_2560US 5
+#define	FFE_AB_EXT_PHY_RST_DUR_1280US 4
+#define	FFE_AB_EXT_PHY_RST_DUR_640US 3
+#define	FFE_AB_EXT_PHY_RST_DUR_320US 2
+#define	FFE_AB_EXT_PHY_RST_DUR_160US 1
+#define	FFE_AB_EXT_PHY_RST_DUR_80US 0
+#define	FRF_AB_SWRST_LBN 0
+#define	FRF_AB_SWRST_WIDTH 1
+
+/* FATAL_INTR_REG_KER: Fatal interrupt register for Kernel */
+#define	FR_AZ_FATAL_INTR_KER 0x00000230
+#define	FRF_CZ_SRAM_PERR_INT_P_KER_EN_LBN 44
+#define	FRF_CZ_SRAM_PERR_INT_P_KER_EN_WIDTH 1
+#define	FRF_AB_PCI_BUSERR_INT_KER_EN_LBN 43
+#define	FRF_AB_PCI_BUSERR_INT_KER_EN_WIDTH 1
+#define	FRF_CZ_MBU_PERR_INT_KER_EN_LBN 43
+#define	FRF_CZ_MBU_PERR_INT_KER_EN_WIDTH 1
+#define	FRF_AZ_SRAM_OOB_INT_KER_EN_LBN 42
+#define	FRF_AZ_SRAM_OOB_INT_KER_EN_WIDTH 1
+#define	FRF_AZ_BUFID_OOB_INT_KER_EN_LBN 41
+#define	FRF_AZ_BUFID_OOB_INT_KER_EN_WIDTH 1
+#define	FRF_AZ_MEM_PERR_INT_KER_EN_LBN 40
+#define	FRF_AZ_MEM_PERR_INT_KER_EN_WIDTH 1
+#define	FRF_AZ_RBUF_OWN_INT_KER_EN_LBN 39
+#define	FRF_AZ_RBUF_OWN_INT_KER_EN_WIDTH 1
+#define	FRF_AZ_TBUF_OWN_INT_KER_EN_LBN 38
+#define	FRF_AZ_TBUF_OWN_INT_KER_EN_WIDTH 1
+#define	FRF_AZ_RDESCQ_OWN_INT_KER_EN_LBN 37
+#define	FRF_AZ_RDESCQ_OWN_INT_KER_EN_WIDTH 1
+#define	FRF_AZ_TDESCQ_OWN_INT_KER_EN_LBN 36
+#define	FRF_AZ_TDESCQ_OWN_INT_KER_EN_WIDTH 1
+#define	FRF_AZ_EVQ_OWN_INT_KER_EN_LBN 35
+#define	FRF_AZ_EVQ_OWN_INT_KER_EN_WIDTH 1
+#define	FRF_AZ_EVF_OFLO_INT_KER_EN_LBN 34
+#define	FRF_AZ_EVF_OFLO_INT_KER_EN_WIDTH 1
+#define	FRF_AZ_ILL_ADR_INT_KER_EN_LBN 33
+#define	FRF_AZ_ILL_ADR_INT_KER_EN_WIDTH 1
+#define	FRF_AZ_SRM_PERR_INT_KER_EN_LBN 32
+#define	FRF_AZ_SRM_PERR_INT_KER_EN_WIDTH 1
+#define	FRF_CZ_SRAM_PERR_INT_P_KER_LBN 12
+#define	FRF_CZ_SRAM_PERR_INT_P_KER_WIDTH 1
+#define	FRF_AB_PCI_BUSERR_INT_KER_LBN 11
+#define	FRF_AB_PCI_BUSERR_INT_KER_WIDTH 1
+#define	FRF_CZ_MBU_PERR_INT_KER_LBN 11
+#define	FRF_CZ_MBU_PERR_INT_KER_WIDTH 1
+#define	FRF_AZ_SRAM_OOB_INT_KER_LBN 10
+#define	FRF_AZ_SRAM_OOB_INT_KER_WIDTH 1
+#define	FRF_AZ_BUFID_DC_OOB_INT_KER_LBN 9
+#define	FRF_AZ_BUFID_DC_OOB_INT_KER_WIDTH 1
+#define	FRF_AZ_MEM_PERR_INT_KER_LBN 8
+#define	FRF_AZ_MEM_PERR_INT_KER_WIDTH 1
+#define	FRF_AZ_RBUF_OWN_INT_KER_LBN 7
+#define	FRF_AZ_RBUF_OWN_INT_KER_WIDTH 1
+#define	FRF_AZ_TBUF_OWN_INT_KER_LBN 6
+#define	FRF_AZ_TBUF_OWN_INT_KER_WIDTH 1
+#define	FRF_AZ_RDESCQ_OWN_INT_KER_LBN 5
+#define	FRF_AZ_RDESCQ_OWN_INT_KER_WIDTH 1
+#define	FRF_AZ_TDESCQ_OWN_INT_KER_LBN 4
+#define	FRF_AZ_TDESCQ_OWN_INT_KER_WIDTH 1
+#define	FRF_AZ_EVQ_OWN_INT_KER_LBN 3
+#define	FRF_AZ_EVQ_OWN_INT_KER_WIDTH 1
+#define	FRF_AZ_EVF_OFLO_INT_KER_LBN 2
+#define	FRF_AZ_EVF_OFLO_INT_KER_WIDTH 1
+#define	FRF_AZ_ILL_ADR_INT_KER_LBN 1
+#define	FRF_AZ_ILL_ADR_INT_KER_WIDTH 1
+#define	FRF_AZ_SRM_PERR_INT_KER_LBN 0
+#define	FRF_AZ_SRM_PERR_INT_KER_WIDTH 1
+
+/* FATAL_INTR_REG_CHAR: Fatal interrupt register for Char */
+#define	FR_BZ_FATAL_INTR_CHAR 0x00000240
+#define	FRF_CZ_SRAM_PERR_INT_P_CHAR_EN_LBN 44
+#define	FRF_CZ_SRAM_PERR_INT_P_CHAR_EN_WIDTH 1
+#define	FRF_BB_PCI_BUSERR_INT_CHAR_EN_LBN 43
+#define	FRF_BB_PCI_BUSERR_INT_CHAR_EN_WIDTH 1
+#define	FRF_CZ_MBU_PERR_INT_CHAR_EN_LBN 43
+#define	FRF_CZ_MBU_PERR_INT_CHAR_EN_WIDTH 1
+#define	FRF_BZ_SRAM_OOB_INT_CHAR_EN_LBN 42
+#define	FRF_BZ_SRAM_OOB_INT_CHAR_EN_WIDTH 1
+#define	FRF_BZ_BUFID_OOB_INT_CHAR_EN_LBN 41
+#define	FRF_BZ_BUFID_OOB_INT_CHAR_EN_WIDTH 1
+#define	FRF_BZ_MEM_PERR_INT_CHAR_EN_LBN 40
+#define	FRF_BZ_MEM_PERR_INT_CHAR_EN_WIDTH 1
+#define	FRF_BZ_RBUF_OWN_INT_CHAR_EN_LBN 39
+#define	FRF_BZ_RBUF_OWN_INT_CHAR_EN_WIDTH 1
+#define	FRF_BZ_TBUF_OWN_INT_CHAR_EN_LBN 38
+#define	FRF_BZ_TBUF_OWN_INT_CHAR_EN_WIDTH 1
+#define	FRF_BZ_RDESCQ_OWN_INT_CHAR_EN_LBN 37
+#define	FRF_BZ_RDESCQ_OWN_INT_CHAR_EN_WIDTH 1
+#define	FRF_BZ_TDESCQ_OWN_INT_CHAR_EN_LBN 36
+#define	FRF_BZ_TDESCQ_OWN_INT_CHAR_EN_WIDTH 1
+#define	FRF_BZ_EVQ_OWN_INT_CHAR_EN_LBN 35
+#define	FRF_BZ_EVQ_OWN_INT_CHAR_EN_WIDTH 1
+#define	FRF_BZ_EVF_OFLO_INT_CHAR_EN_LBN 34
+#define	FRF_BZ_EVF_OFLO_INT_CHAR_EN_WIDTH 1
+#define	FRF_BZ_ILL_ADR_INT_CHAR_EN_LBN 33
+#define	FRF_BZ_ILL_ADR_INT_CHAR_EN_WIDTH 1
+#define	FRF_BZ_SRM_PERR_INT_CHAR_EN_LBN 32
+#define	FRF_BZ_SRM_PERR_INT_CHAR_EN_WIDTH 1
+#define	FRF_CZ_SRAM_PERR_INT_P_CHAR_LBN 12
+#define	FRF_CZ_SRAM_PERR_INT_P_CHAR_WIDTH 1
+#define	FRF_BB_PCI_BUSERR_INT_CHAR_LBN 11
+#define	FRF_BB_PCI_BUSERR_INT_CHAR_WIDTH 1
+#define	FRF_CZ_MBU_PERR_INT_CHAR_LBN 11
+#define	FRF_CZ_MBU_PERR_INT_CHAR_WIDTH 1
+#define	FRF_BZ_SRAM_OOB_INT_CHAR_LBN 10
+#define	FRF_BZ_SRAM_OOB_INT_CHAR_WIDTH 1
+#define	FRF_BZ_BUFID_DC_OOB_INT_CHAR_LBN 9
+#define	FRF_BZ_BUFID_DC_OOB_INT_CHAR_WIDTH 1
+#define	FRF_BZ_MEM_PERR_INT_CHAR_LBN 8
+#define	FRF_BZ_MEM_PERR_INT_CHAR_WIDTH 1
+#define	FRF_BZ_RBUF_OWN_INT_CHAR_LBN 7
+#define	FRF_BZ_RBUF_OWN_INT_CHAR_WIDTH 1
+#define	FRF_BZ_TBUF_OWN_INT_CHAR_LBN 6
+#define	FRF_BZ_TBUF_OWN_INT_CHAR_WIDTH 1
+#define	FRF_BZ_RDESCQ_OWN_INT_CHAR_LBN 5
+#define	FRF_BZ_RDESCQ_OWN_INT_CHAR_WIDTH 1
+#define	FRF_BZ_TDESCQ_OWN_INT_CHAR_LBN 4
+#define	FRF_BZ_TDESCQ_OWN_INT_CHAR_WIDTH 1
+#define	FRF_BZ_EVQ_OWN_INT_CHAR_LBN 3
+#define	FRF_BZ_EVQ_OWN_INT_CHAR_WIDTH 1
+#define	FRF_BZ_EVF_OFLO_INT_CHAR_LBN 2
+#define	FRF_BZ_EVF_OFLO_INT_CHAR_WIDTH 1
+#define	FRF_BZ_ILL_ADR_INT_CHAR_LBN 1
+#define	FRF_BZ_ILL_ADR_INT_CHAR_WIDTH 1
+#define	FRF_BZ_SRM_PERR_INT_CHAR_LBN 0
+#define	FRF_BZ_SRM_PERR_INT_CHAR_WIDTH 1
+
+/* DP_CTRL_REG: Datapath control register */
+#define	FR_BZ_DP_CTRL 0x00000250
+#define	FRF_BZ_FLS_EVQ_ID_LBN 0
+#define	FRF_BZ_FLS_EVQ_ID_WIDTH 12
+
+/* MEM_STAT_REG: Memory status register */
+#define	FR_AZ_MEM_STAT 0x00000260
+#define	FRF_AB_MEM_PERR_VEC_LBN 53
+#define	FRF_AB_MEM_PERR_VEC_WIDTH 38
+#define	FRF_AB_MBIST_CORR_LBN 38
+#define	FRF_AB_MBIST_CORR_WIDTH 15
+#define	FRF_AB_MBIST_ERR_LBN 0
+#define	FRF_AB_MBIST_ERR_WIDTH 40
+#define	FRF_CZ_MEM_PERR_VEC_LBN 0
+#define	FRF_CZ_MEM_PERR_VEC_WIDTH 35
+
+/* CS_DEBUG_REG: Debug register */
+#define	FR_AZ_CS_DEBUG 0x00000270
+#define	FRF_AB_GLB_DEBUG2_SEL_LBN 50
+#define	FRF_AB_GLB_DEBUG2_SEL_WIDTH 3
+#define	FRF_AB_DEBUG_BLK_SEL2_LBN 47
+#define	FRF_AB_DEBUG_BLK_SEL2_WIDTH 3
+#define	FRF_AB_DEBUG_BLK_SEL1_LBN 44
+#define	FRF_AB_DEBUG_BLK_SEL1_WIDTH 3
+#define	FRF_AB_DEBUG_BLK_SEL0_LBN 41
+#define	FRF_AB_DEBUG_BLK_SEL0_WIDTH 3
+#define	FRF_CZ_CS_PORT_NUM_LBN 40
+#define	FRF_CZ_CS_PORT_NUM_WIDTH 2
+#define	FRF_AB_MISC_DEBUG_ADDR_LBN 36
+#define	FRF_AB_MISC_DEBUG_ADDR_WIDTH 5
+#define	FRF_AB_SERDES_DEBUG_ADDR_LBN 31
+#define	FRF_AB_SERDES_DEBUG_ADDR_WIDTH 5
+#define	FRF_CZ_CS_PORT_FPE_LBN 1
+#define	FRF_CZ_CS_PORT_FPE_WIDTH 35
+#define	FRF_AB_EM_DEBUG_ADDR_LBN 26
+#define	FRF_AB_EM_DEBUG_ADDR_WIDTH 5
+#define	FRF_AB_SR_DEBUG_ADDR_LBN 21
+#define	FRF_AB_SR_DEBUG_ADDR_WIDTH 5
+#define	FRF_AB_EV_DEBUG_ADDR_LBN 16
+#define	FRF_AB_EV_DEBUG_ADDR_WIDTH 5
+#define	FRF_AB_RX_DEBUG_ADDR_LBN 11
+#define	FRF_AB_RX_DEBUG_ADDR_WIDTH 5
+#define	FRF_AB_TX_DEBUG_ADDR_LBN 6
+#define	FRF_AB_TX_DEBUG_ADDR_WIDTH 5
+#define	FRF_AB_CS_BIU_DEBUG_ADDR_LBN 1
+#define	FRF_AB_CS_BIU_DEBUG_ADDR_WIDTH 5
+#define	FRF_AZ_CS_DEBUG_EN_LBN 0
+#define	FRF_AZ_CS_DEBUG_EN_WIDTH 1
+
+/* DRIVER_REG: Driver scratch register [0-7] */
+#define	FR_AZ_DRIVER 0x00000280
+#define	FR_AZ_DRIVER_STEP 16
+#define	FR_AZ_DRIVER_ROWS 8
+#define	FRF_AZ_DRIVER_DW0_LBN 0
+#define	FRF_AZ_DRIVER_DW0_WIDTH 32
+
+/* ALTERA_BUILD_REG: Altera build register */
+#define	FR_AZ_ALTERA_BUILD 0x00000300
+#define	FRF_AZ_ALTERA_BUILD_VER_LBN 0
+#define	FRF_AZ_ALTERA_BUILD_VER_WIDTH 32
+
+/* CSR_SPARE_REG: Spare register */
+#define	FR_AZ_CSR_SPARE 0x00000310
+#define	FRF_AB_MEM_PERR_EN_LBN 64
+#define	FRF_AB_MEM_PERR_EN_WIDTH 38
+#define	FRF_CZ_MEM_PERR_EN_LBN 64
+#define	FRF_CZ_MEM_PERR_EN_WIDTH 35
+#define	FRF_AB_MEM_PERR_EN_TX_DATA_LBN 72
+#define	FRF_AB_MEM_PERR_EN_TX_DATA_WIDTH 2
+#define	FRF_AZ_CSR_SPARE_BITS_LBN 0
+#define	FRF_AZ_CSR_SPARE_BITS_WIDTH 32
+
+/* PCIE_SD_CTL0123_REG: PCIE SerDes control register 0 to 3 */
+#define	FR_AB_PCIE_SD_CTL0123 0x00000320
+#define	FRF_AB_PCIE_TESTSIG_H_LBN 96
+#define	FRF_AB_PCIE_TESTSIG_H_WIDTH 19
+#define	FRF_AB_PCIE_TESTSIG_L_LBN 64
+#define	FRF_AB_PCIE_TESTSIG_L_WIDTH 19
+#define	FRF_AB_PCIE_OFFSET_LBN 56
+#define	FRF_AB_PCIE_OFFSET_WIDTH 8
+#define	FRF_AB_PCIE_OFFSETEN_H_LBN 55
+#define	FRF_AB_PCIE_OFFSETEN_H_WIDTH 1
+#define	FRF_AB_PCIE_OFFSETEN_L_LBN 54
+#define	FRF_AB_PCIE_OFFSETEN_L_WIDTH 1
+#define	FRF_AB_PCIE_HIVMODE_H_LBN 53
+#define	FRF_AB_PCIE_HIVMODE_H_WIDTH 1
+#define	FRF_AB_PCIE_HIVMODE_L_LBN 52
+#define	FRF_AB_PCIE_HIVMODE_L_WIDTH 1
+#define	FRF_AB_PCIE_PARRESET_H_LBN 51
+#define	FRF_AB_PCIE_PARRESET_H_WIDTH 1
+#define	FRF_AB_PCIE_PARRESET_L_LBN 50
+#define	FRF_AB_PCIE_PARRESET_L_WIDTH 1
+#define	FRF_AB_PCIE_LPBKWDRV_H_LBN 49
+#define	FRF_AB_PCIE_LPBKWDRV_H_WIDTH 1
+#define	FRF_AB_PCIE_LPBKWDRV_L_LBN 48
+#define	FRF_AB_PCIE_LPBKWDRV_L_WIDTH 1
+#define	FRF_AB_PCIE_LPBK_LBN 40
+#define	FRF_AB_PCIE_LPBK_WIDTH 8
+#define	FRF_AB_PCIE_PARLPBK_LBN 32
+#define	FRF_AB_PCIE_PARLPBK_WIDTH 8
+#define	FRF_AB_PCIE_RXTERMADJ_H_LBN 30
+#define	FRF_AB_PCIE_RXTERMADJ_H_WIDTH 2
+#define	FRF_AB_PCIE_RXTERMADJ_L_LBN 28
+#define	FRF_AB_PCIE_RXTERMADJ_L_WIDTH 2
+#define	FFE_AB_PCIE_RXTERMADJ_MIN15PCNT 3
+#define	FFE_AB_PCIE_RXTERMADJ_PL10PCNT 2
+#define	FFE_AB_PCIE_RXTERMADJ_MIN17PCNT 1
+#define	FFE_AB_PCIE_RXTERMADJ_NOMNL 0
+#define	FRF_AB_PCIE_TXTERMADJ_H_LBN 26
+#define	FRF_AB_PCIE_TXTERMADJ_H_WIDTH 2
+#define	FRF_AB_PCIE_TXTERMADJ_L_LBN 24
+#define	FRF_AB_PCIE_TXTERMADJ_L_WIDTH 2
+#define	FFE_AB_PCIE_TXTERMADJ_MIN15PCNT 3
+#define	FFE_AB_PCIE_TXTERMADJ_PL10PCNT 2
+#define	FFE_AB_PCIE_TXTERMADJ_MIN17PCNT 1
+#define	FFE_AB_PCIE_TXTERMADJ_NOMNL 0
+#define	FRF_AB_PCIE_RXEQCTL_H_LBN 18
+#define	FRF_AB_PCIE_RXEQCTL_H_WIDTH 2
+#define	FRF_AB_PCIE_RXEQCTL_L_LBN 16
+#define	FRF_AB_PCIE_RXEQCTL_L_WIDTH 2
+#define	FFE_AB_PCIE_RXEQCTL_OFF_ALT 3
+#define	FFE_AB_PCIE_RXEQCTL_OFF 2
+#define	FFE_AB_PCIE_RXEQCTL_MIN 1
+#define	FFE_AB_PCIE_RXEQCTL_MAX 0
+#define	FRF_AB_PCIE_HIDRV_LBN 8
+#define	FRF_AB_PCIE_HIDRV_WIDTH 8
+#define	FRF_AB_PCIE_LODRV_LBN 0
+#define	FRF_AB_PCIE_LODRV_WIDTH 8
+
+/* PCIE_SD_CTL45_REG: PCIE SerDes control register 4 and 5 */
+#define	FR_AB_PCIE_SD_CTL45 0x00000330
+#define	FRF_AB_PCIE_DTX7_LBN 60
+#define	FRF_AB_PCIE_DTX7_WIDTH 4
+#define	FRF_AB_PCIE_DTX6_LBN 56
+#define	FRF_AB_PCIE_DTX6_WIDTH 4
+#define	FRF_AB_PCIE_DTX5_LBN 52
+#define	FRF_AB_PCIE_DTX5_WIDTH 4
+#define	FRF_AB_PCIE_DTX4_LBN 48
+#define	FRF_AB_PCIE_DTX4_WIDTH 4
+#define	FRF_AB_PCIE_DTX3_LBN 44
+#define	FRF_AB_PCIE_DTX3_WIDTH 4
+#define	FRF_AB_PCIE_DTX2_LBN 40
+#define	FRF_AB_PCIE_DTX2_WIDTH 4
+#define	FRF_AB_PCIE_DTX1_LBN 36
+#define	FRF_AB_PCIE_DTX1_WIDTH 4
+#define	FRF_AB_PCIE_DTX0_LBN 32
+#define	FRF_AB_PCIE_DTX0_WIDTH 4
+#define	FRF_AB_PCIE_DEQ7_LBN 28
+#define	FRF_AB_PCIE_DEQ7_WIDTH 4
+#define	FRF_AB_PCIE_DEQ6_LBN 24
+#define	FRF_AB_PCIE_DEQ6_WIDTH 4
+#define	FRF_AB_PCIE_DEQ5_LBN 20
+#define	FRF_AB_PCIE_DEQ5_WIDTH 4
+#define	FRF_AB_PCIE_DEQ4_LBN 16
+#define	FRF_AB_PCIE_DEQ4_WIDTH 4
+#define	FRF_AB_PCIE_DEQ3_LBN 12
+#define	FRF_AB_PCIE_DEQ3_WIDTH 4
+#define	FRF_AB_PCIE_DEQ2_LBN 8
+#define	FRF_AB_PCIE_DEQ2_WIDTH 4
+#define	FRF_AB_PCIE_DEQ1_LBN 4
+#define	FRF_AB_PCIE_DEQ1_WIDTH 4
+#define	FRF_AB_PCIE_DEQ0_LBN 0
+#define	FRF_AB_PCIE_DEQ0_WIDTH 4
+
+/* PCIE_PCS_CTL_STAT_REG: PCIE PCS control and status register */
+#define	FR_AB_PCIE_PCS_CTL_STAT 0x00000340
+#define	FRF_AB_PCIE_PRBSERRCOUNT0_H_LBN 52
+#define	FRF_AB_PCIE_PRBSERRCOUNT0_H_WIDTH 4
+#define	FRF_AB_PCIE_PRBSERRCOUNT0_L_LBN 48
+#define	FRF_AB_PCIE_PRBSERRCOUNT0_L_WIDTH 4
+#define	FRF_AB_PCIE_PRBSERR_LBN 40
+#define	FRF_AB_PCIE_PRBSERR_WIDTH 8
+#define	FRF_AB_PCIE_PRBSERRH0_LBN 32
+#define	FRF_AB_PCIE_PRBSERRH0_WIDTH 8
+#define	FRF_AB_PCIE_FASTINIT_H_LBN 15
+#define	FRF_AB_PCIE_FASTINIT_H_WIDTH 1
+#define	FRF_AB_PCIE_FASTINIT_L_LBN 14
+#define	FRF_AB_PCIE_FASTINIT_L_WIDTH 1
+#define	FRF_AB_PCIE_CTCDISABLE_H_LBN 13
+#define	FRF_AB_PCIE_CTCDISABLE_H_WIDTH 1
+#define	FRF_AB_PCIE_CTCDISABLE_L_LBN 12
+#define	FRF_AB_PCIE_CTCDISABLE_L_WIDTH 1
+#define	FRF_AB_PCIE_PRBSSYNC_H_LBN 11
+#define	FRF_AB_PCIE_PRBSSYNC_H_WIDTH 1
+#define	FRF_AB_PCIE_PRBSSYNC_L_LBN 10
+#define	FRF_AB_PCIE_PRBSSYNC_L_WIDTH 1
+#define	FRF_AB_PCIE_PRBSERRACK_H_LBN 9
+#define	FRF_AB_PCIE_PRBSERRACK_H_WIDTH 1
+#define	FRF_AB_PCIE_PRBSERRACK_L_LBN 8
+#define	FRF_AB_PCIE_PRBSERRACK_L_WIDTH 1
+#define	FRF_AB_PCIE_PRBSSEL_LBN 0
+#define	FRF_AB_PCIE_PRBSSEL_WIDTH 8
+
+/* DEBUG_DATA_OUT_REG: Live Debug and Debug 2 out ports */
+#define	FR_BB_DEBUG_DATA_OUT 0x00000350
+#define	FRF_BB_DEBUG2_PORT_LBN 25
+#define	FRF_BB_DEBUG2_PORT_WIDTH 15
+#define	FRF_BB_DEBUG1_PORT_LBN 0
+#define	FRF_BB_DEBUG1_PORT_WIDTH 25
+
+/* EVQ_RPTR_REGP0: Event queue read pointer register */
+#define	FR_BZ_EVQ_RPTR_P0 0x00000400
+#define	FR_BZ_EVQ_RPTR_P0_STEP 8192
+#define	FR_BZ_EVQ_RPTR_P0_ROWS 1024
+/* EVQ_RPTR_REG_KER: Event queue read pointer register */
+#define	FR_AA_EVQ_RPTR_KER 0x00011b00
+#define	FR_AA_EVQ_RPTR_KER_STEP 4
+#define	FR_AA_EVQ_RPTR_KER_ROWS 4
+/* EVQ_RPTR_REG: Event queue read pointer register */
+#define	FR_BZ_EVQ_RPTR 0x00fa0000
+#define	FR_BZ_EVQ_RPTR_STEP 16
+#define	FR_BB_EVQ_RPTR_ROWS 4096
+#define	FR_CZ_EVQ_RPTR_ROWS 1024
+/* EVQ_RPTR_REGP123: Event queue read pointer register */
+#define	FR_BB_EVQ_RPTR_P123 0x01000400
+#define	FR_BB_EVQ_RPTR_P123_STEP 8192
+#define	FR_BB_EVQ_RPTR_P123_ROWS 3072
+#define	FRF_AZ_EVQ_RPTR_VLD_LBN 15
+#define	FRF_AZ_EVQ_RPTR_VLD_WIDTH 1
+#define	FRF_AZ_EVQ_RPTR_LBN 0
+#define	FRF_AZ_EVQ_RPTR_WIDTH 15
+
+/* TIMER_COMMAND_REGP0: Timer Command Registers */
+#define	FR_BZ_TIMER_COMMAND_P0 0x00000420
+#define	FR_BZ_TIMER_COMMAND_P0_STEP 8192
+#define	FR_BZ_TIMER_COMMAND_P0_ROWS 1024
+/* TIMER_COMMAND_REG_KER: Timer Command Registers */
+#define	FR_AA_TIMER_COMMAND_KER 0x00000420
+#define	FR_AA_TIMER_COMMAND_KER_STEP 8192
+#define	FR_AA_TIMER_COMMAND_KER_ROWS 4
+/* TIMER_COMMAND_REGP123: Timer Command Registers */
+#define	FR_BB_TIMER_COMMAND_P123 0x01000420
+#define	FR_BB_TIMER_COMMAND_P123_STEP 8192
+#define	FR_BB_TIMER_COMMAND_P123_ROWS 3072
+#define	FRF_CZ_TC_TIMER_MODE_LBN 14
+#define	FRF_CZ_TC_TIMER_MODE_WIDTH 2
+#define	FRF_AB_TC_TIMER_MODE_LBN 12
+#define	FRF_AB_TC_TIMER_MODE_WIDTH 2
+#define	FRF_CZ_TC_TIMER_VAL_LBN 0
+#define	FRF_CZ_TC_TIMER_VAL_WIDTH 14
+#define	FRF_AB_TC_TIMER_VAL_LBN 0
+#define	FRF_AB_TC_TIMER_VAL_WIDTH 12
+
+/* DRV_EV_REG: Driver generated event register */
+#define	FR_AZ_DRV_EV 0x00000440
+#define	FRF_AZ_DRV_EV_QID_LBN 64
+#define	FRF_AZ_DRV_EV_QID_WIDTH 12
+#define	FRF_AZ_DRV_EV_DATA_LBN 0
+#define	FRF_AZ_DRV_EV_DATA_WIDTH 64
+
+/* EVQ_CTL_REG: Event queue control register */
+#define	FR_AZ_EVQ_CTL 0x00000450
+#define	FRF_CZ_RX_EVQ_WAKEUP_MASK_LBN 15
+#define	FRF_CZ_RX_EVQ_WAKEUP_MASK_WIDTH 10
+#define	FRF_BB_RX_EVQ_WAKEUP_MASK_LBN 15
+#define	FRF_BB_RX_EVQ_WAKEUP_MASK_WIDTH 6
+#define	FRF_AZ_EVQ_OWNERR_CTL_LBN 14
+#define	FRF_AZ_EVQ_OWNERR_CTL_WIDTH 1
+#define	FRF_AZ_EVQ_FIFO_AF_TH_LBN 7
+#define	FRF_AZ_EVQ_FIFO_AF_TH_WIDTH 7
+#define	FRF_AZ_EVQ_FIFO_NOTAF_TH_LBN 0
+#define	FRF_AZ_EVQ_FIFO_NOTAF_TH_WIDTH 7
+
+/* EVQ_CNT1_REG: Event counter 1 register */
+#define	FR_AZ_EVQ_CNT1 0x00000460
+#define	FRF_AZ_EVQ_CNT_PRE_FIFO_LBN 120
+#define	FRF_AZ_EVQ_CNT_PRE_FIFO_WIDTH 7
+#define	FRF_AZ_EVQ_CNT_TOBIU_LBN 100
+#define	FRF_AZ_EVQ_CNT_TOBIU_WIDTH 20
+#define	FRF_AZ_EVQ_TX_REQ_CNT_LBN 80
+#define	FRF_AZ_EVQ_TX_REQ_CNT_WIDTH 20
+#define	FRF_AZ_EVQ_RX_REQ_CNT_LBN 60
+#define	FRF_AZ_EVQ_RX_REQ_CNT_WIDTH 20
+#define	FRF_AZ_EVQ_EM_REQ_CNT_LBN 40
+#define	FRF_AZ_EVQ_EM_REQ_CNT_WIDTH 20
+#define	FRF_AZ_EVQ_CSR_REQ_CNT_LBN 20
+#define	FRF_AZ_EVQ_CSR_REQ_CNT_WIDTH 20
+#define	FRF_AZ_EVQ_ERR_REQ_CNT_LBN 0
+#define	FRF_AZ_EVQ_ERR_REQ_CNT_WIDTH 20
+
+/* EVQ_CNT2_REG: Event counter 2 register */
+#define	FR_AZ_EVQ_CNT2 0x00000470
+#define	FRF_AZ_EVQ_UPD_REQ_CNT_LBN 104
+#define	FRF_AZ_EVQ_UPD_REQ_CNT_WIDTH 20
+#define	FRF_AZ_EVQ_CLR_REQ_CNT_LBN 84
+#define	FRF_AZ_EVQ_CLR_REQ_CNT_WIDTH 20
+#define	FRF_AZ_EVQ_RDY_CNT_LBN 80
+#define	FRF_AZ_EVQ_RDY_CNT_WIDTH 4
+#define	FRF_AZ_EVQ_WU_REQ_CNT_LBN 60
+#define	FRF_AZ_EVQ_WU_REQ_CNT_WIDTH 20
+#define	FRF_AZ_EVQ_WET_REQ_CNT_LBN 40
+#define	FRF_AZ_EVQ_WET_REQ_CNT_WIDTH 20
+#define	FRF_AZ_EVQ_INIT_REQ_CNT_LBN 20
+#define	FRF_AZ_EVQ_INIT_REQ_CNT_WIDTH 20
+#define	FRF_AZ_EVQ_TM_REQ_CNT_LBN 0
+#define	FRF_AZ_EVQ_TM_REQ_CNT_WIDTH 20
+
+/* USR_EV_REG: Event mailbox register */
+#define	FR_CZ_USR_EV 0x00000540
+#define	FR_CZ_USR_EV_STEP 8192
+#define	FR_CZ_USR_EV_ROWS 1024
+#define	FRF_CZ_USR_EV_DATA_LBN 0
+#define	FRF_CZ_USR_EV_DATA_WIDTH 32
+
+/* BUF_TBL_CFG_REG: Buffer table configuration register */
+#define	FR_AZ_BUF_TBL_CFG 0x00000600
+#define	FRF_AZ_BUF_TBL_MODE_LBN 3
+#define	FRF_AZ_BUF_TBL_MODE_WIDTH 1
+
+/* SRM_RX_DC_CFG_REG: SRAM receive descriptor cache configuration register */
+#define	FR_AZ_SRM_RX_DC_CFG 0x00000610
+#define	FRF_AZ_SRM_CLK_TMP_EN_LBN 21
+#define	FRF_AZ_SRM_CLK_TMP_EN_WIDTH 1
+#define	FRF_AZ_SRM_RX_DC_BASE_ADR_LBN 0
+#define	FRF_AZ_SRM_RX_DC_BASE_ADR_WIDTH 21
+
+/* SRM_TX_DC_CFG_REG: SRAM transmit descriptor cache configuration register */
+#define	FR_AZ_SRM_TX_DC_CFG 0x00000620
+#define	FRF_AZ_SRM_TX_DC_BASE_ADR_LBN 0
+#define	FRF_AZ_SRM_TX_DC_BASE_ADR_WIDTH 21
+
+/* SRM_CFG_REG: SRAM configuration register */
+#define	FR_AZ_SRM_CFG 0x00000630
+#define	FRF_AZ_SRM_OOB_ADR_INTEN_LBN 5
+#define	FRF_AZ_SRM_OOB_ADR_INTEN_WIDTH 1
+#define	FRF_AZ_SRM_OOB_BUF_INTEN_LBN 4
+#define	FRF_AZ_SRM_OOB_BUF_INTEN_WIDTH 1
+#define	FRF_AZ_SRM_INIT_EN_LBN 3
+#define	FRF_AZ_SRM_INIT_EN_WIDTH 1
+#define	FRF_AZ_SRM_NUM_BANK_LBN 2
+#define	FRF_AZ_SRM_NUM_BANK_WIDTH 1
+#define	FRF_AZ_SRM_BANK_SIZE_LBN 0
+#define	FRF_AZ_SRM_BANK_SIZE_WIDTH 2
+
+/* BUF_TBL_UPD_REG: Buffer table update register */
+#define	FR_AZ_BUF_TBL_UPD 0x00000650
+#define	FRF_AZ_BUF_UPD_CMD_LBN 63
+#define	FRF_AZ_BUF_UPD_CMD_WIDTH 1
+#define	FRF_AZ_BUF_CLR_CMD_LBN 62
+#define	FRF_AZ_BUF_CLR_CMD_WIDTH 1
+#define	FRF_AZ_BUF_CLR_END_ID_LBN 32
+#define	FRF_AZ_BUF_CLR_END_ID_WIDTH 20
+#define	FRF_AZ_BUF_CLR_START_ID_LBN 0
+#define	FRF_AZ_BUF_CLR_START_ID_WIDTH 20
+
+/* SRM_UPD_EVQ_REG: Buffer table update register */
+#define	FR_AZ_SRM_UPD_EVQ 0x00000660
+#define	FRF_AZ_SRM_UPD_EVQ_ID_LBN 0
+#define	FRF_AZ_SRM_UPD_EVQ_ID_WIDTH 12
+
+/* SRAM_PARITY_REG: SRAM parity register. */
+#define	FR_AZ_SRAM_PARITY 0x00000670
+#define	FRF_CZ_BYPASS_ECC_LBN 3
+#define	FRF_CZ_BYPASS_ECC_WIDTH 1
+#define	FRF_CZ_SEC_INT_LBN 2
+#define	FRF_CZ_SEC_INT_WIDTH 1
+#define	FRF_CZ_FORCE_SRAM_DOUBLE_ERR_LBN 1
+#define	FRF_CZ_FORCE_SRAM_DOUBLE_ERR_WIDTH 1
+#define	FRF_AB_FORCE_SRAM_PERR_LBN 0
+#define	FRF_AB_FORCE_SRAM_PERR_WIDTH 1
+#define	FRF_CZ_FORCE_SRAM_SINGLE_ERR_LBN 0
+#define	FRF_CZ_FORCE_SRAM_SINGLE_ERR_WIDTH 1
+
+/* RX_CFG_REG: Receive configuration register */
+#define	FR_AZ_RX_CFG 0x00000800
+#define	FRF_CZ_RX_MIN_KBUF_SIZE_LBN 72
+#define	FRF_CZ_RX_MIN_KBUF_SIZE_WIDTH 14
+#define	FRF_CZ_RX_HDR_SPLIT_EN_LBN 71
+#define	FRF_CZ_RX_HDR_SPLIT_EN_WIDTH 1
+#define	FRF_CZ_RX_HDR_SPLIT_PLD_BUF_SIZE_LBN 62
+#define	FRF_CZ_RX_HDR_SPLIT_PLD_BUF_SIZE_WIDTH 9
+#define	FRF_CZ_RX_HDR_SPLIT_HDR_BUF_SIZE_LBN 53
+#define	FRF_CZ_RX_HDR_SPLIT_HDR_BUF_SIZE_WIDTH 9
+#define	FRF_CZ_RX_PRE_RFF_IPG_LBN 49
+#define	FRF_CZ_RX_PRE_RFF_IPG_WIDTH 4
+#define	FRF_BZ_RX_TCP_SUP_LBN 48
+#define	FRF_BZ_RX_TCP_SUP_WIDTH 1
+#define	FRF_BZ_RX_INGR_EN_LBN 47
+#define	FRF_BZ_RX_INGR_EN_WIDTH 1
+#define	FRF_BZ_RX_IP_HASH_LBN 46
+#define	FRF_BZ_RX_IP_HASH_WIDTH 1
+#define	FRF_BZ_RX_HASH_ALG_LBN 45
+#define	FRF_BZ_RX_HASH_ALG_WIDTH 1
+#define	FRF_BZ_RX_HASH_INSRT_HDR_LBN 44
+#define	FRF_BZ_RX_HASH_INSRT_HDR_WIDTH 1
+#define	FRF_BZ_RX_DESC_PUSH_EN_LBN 43
+#define	FRF_BZ_RX_DESC_PUSH_EN_WIDTH 1
+#define	FRF_BZ_RX_RDW_PATCH_EN_LBN 42
+#define	FRF_BZ_RX_RDW_PATCH_EN_WIDTH 1
+#define	FRF_BB_RX_PCI_BURST_SIZE_LBN 39
+#define	FRF_BB_RX_PCI_BURST_SIZE_WIDTH 3
+#define	FRF_BZ_RX_OWNERR_CTL_LBN 38
+#define	FRF_BZ_RX_OWNERR_CTL_WIDTH 1
+#define	FRF_BZ_RX_XON_TX_TH_LBN 33
+#define	FRF_BZ_RX_XON_TX_TH_WIDTH 5
+#define	FRF_AA_RX_DESC_PUSH_EN_LBN 35
+#define	FRF_AA_RX_DESC_PUSH_EN_WIDTH 1
+#define	FRF_AA_RX_RDW_PATCH_EN_LBN 34
+#define	FRF_AA_RX_RDW_PATCH_EN_WIDTH 1
+#define	FRF_AA_RX_PCI_BURST_SIZE_LBN 31
+#define	FRF_AA_RX_PCI_BURST_SIZE_WIDTH 3
+#define	FRF_BZ_RX_XOFF_TX_TH_LBN 28
+#define	FRF_BZ_RX_XOFF_TX_TH_WIDTH 5
+#define	FRF_AA_RX_OWNERR_CTL_LBN 30
+#define	FRF_AA_RX_OWNERR_CTL_WIDTH 1
+#define	FRF_AA_RX_XON_TX_TH_LBN 25
+#define	FRF_AA_RX_XON_TX_TH_WIDTH 5
+#define	FRF_BZ_RX_USR_BUF_SIZE_LBN 19
+#define	FRF_BZ_RX_USR_BUF_SIZE_WIDTH 9
+#define	FRF_AA_RX_XOFF_TX_TH_LBN 20
+#define	FRF_AA_RX_XOFF_TX_TH_WIDTH 5
+#define	FRF_AA_RX_USR_BUF_SIZE_LBN 11
+#define	FRF_AA_RX_USR_BUF_SIZE_WIDTH 9
+#define	FRF_BZ_RX_XON_MAC_TH_LBN 10
+#define	FRF_BZ_RX_XON_MAC_TH_WIDTH 9
+#define	FRF_AA_RX_XON_MAC_TH_LBN 6
+#define	FRF_AA_RX_XON_MAC_TH_WIDTH 5
+#define	FRF_BZ_RX_XOFF_MAC_TH_LBN 1
+#define	FRF_BZ_RX_XOFF_MAC_TH_WIDTH 9
+#define	FRF_AA_RX_XOFF_MAC_TH_LBN 1
+#define	FRF_AA_RX_XOFF_MAC_TH_WIDTH 5
+#define	FRF_AZ_RX_XOFF_MAC_EN_LBN 0
+#define	FRF_AZ_RX_XOFF_MAC_EN_WIDTH 1
+
+/* RX_FILTER_CTL_REG: Receive filter control registers */
+#define	FR_BZ_RX_FILTER_CTL 0x00000810
+#define	FRF_CZ_ETHERNET_WILDCARD_SEARCH_LIMIT_LBN 94
+#define	FRF_CZ_ETHERNET_WILDCARD_SEARCH_LIMIT_WIDTH 8
+#define	FRF_CZ_ETHERNET_FULL_SEARCH_LIMIT_LBN 86
+#define	FRF_CZ_ETHERNET_FULL_SEARCH_LIMIT_WIDTH 8
+#define	FRF_CZ_RX_FILTER_ALL_VLAN_ETHERTYPES_LBN 85
+#define	FRF_CZ_RX_FILTER_ALL_VLAN_ETHERTYPES_WIDTH 1
+#define	FRF_CZ_RX_VLAN_MATCH_ETHERTYPE_LBN 69
+#define	FRF_CZ_RX_VLAN_MATCH_ETHERTYPE_WIDTH 16
+#define	FRF_CZ_MULTICAST_NOMATCH_Q_ID_LBN 57
+#define	FRF_CZ_MULTICAST_NOMATCH_Q_ID_WIDTH 12
+#define	FRF_CZ_MULTICAST_NOMATCH_RSS_ENABLED_LBN 56
+#define	FRF_CZ_MULTICAST_NOMATCH_RSS_ENABLED_WIDTH 1
+#define	FRF_CZ_MULTICAST_NOMATCH_IP_OVERRIDE_LBN 55
+#define	FRF_CZ_MULTICAST_NOMATCH_IP_OVERRIDE_WIDTH 1
+#define	FRF_CZ_UNICAST_NOMATCH_Q_ID_LBN 43
+#define	FRF_CZ_UNICAST_NOMATCH_Q_ID_WIDTH 12
+#define	FRF_CZ_UNICAST_NOMATCH_RSS_ENABLED_LBN 42
+#define	FRF_CZ_UNICAST_NOMATCH_RSS_ENABLED_WIDTH 1
+#define	FRF_CZ_UNICAST_NOMATCH_IP_OVERRIDE_LBN 41
+#define	FRF_CZ_UNICAST_NOMATCH_IP_OVERRIDE_WIDTH 1
+#define	FRF_BZ_SCATTER_ENBL_NO_MATCH_Q_LBN 40
+#define	FRF_BZ_SCATTER_ENBL_NO_MATCH_Q_WIDTH 1
+#define	FRF_BZ_UDP_FULL_SRCH_LIMIT_LBN 32
+#define	FRF_BZ_UDP_FULL_SRCH_LIMIT_WIDTH 8
+#define	FRF_BZ_NUM_KER_LBN 24
+#define	FRF_BZ_NUM_KER_WIDTH 2
+#define	FRF_BZ_UDP_WILD_SRCH_LIMIT_LBN 16
+#define	FRF_BZ_UDP_WILD_SRCH_LIMIT_WIDTH 8
+#define	FRF_BZ_TCP_WILD_SRCH_LIMIT_LBN 8
+#define	FRF_BZ_TCP_WILD_SRCH_LIMIT_WIDTH 8
+#define	FRF_BZ_TCP_FULL_SRCH_LIMIT_LBN 0
+#define	FRF_BZ_TCP_FULL_SRCH_LIMIT_WIDTH 8
+
+/* RX_FLUSH_DESCQ_REG: Receive flush descriptor queue register */
+#define	FR_AZ_RX_FLUSH_DESCQ 0x00000820
+#define	FRF_AZ_RX_FLUSH_DESCQ_CMD_LBN 24
+#define	FRF_AZ_RX_FLUSH_DESCQ_CMD_WIDTH 1
+#define	FRF_AZ_RX_FLUSH_DESCQ_LBN 0
+#define	FRF_AZ_RX_FLUSH_DESCQ_WIDTH 12
+
+/* RX_DESC_UPD_REGP0: Receive descriptor update register. */
+#define	FR_BZ_RX_DESC_UPD_P0 0x00000830
+#define	FR_BZ_RX_DESC_UPD_P0_STEP 8192
+#define	FR_BZ_RX_DESC_UPD_P0_ROWS 1024
+/* RX_DESC_UPD_REG_KER: Receive descriptor update register. */
+#define	FR_AA_RX_DESC_UPD_KER 0x00000830
+#define	FR_AA_RX_DESC_UPD_KER_STEP 8192
+#define	FR_AA_RX_DESC_UPD_KER_ROWS 4
+/* RX_DESC_UPD_REGP123: Receive descriptor update register. */
+#define	FR_BB_RX_DESC_UPD_P123 0x01000830
+#define	FR_BB_RX_DESC_UPD_P123_STEP 8192
+#define	FR_BB_RX_DESC_UPD_P123_ROWS 3072
+#define	FRF_AZ_RX_DESC_WPTR_LBN 96
+#define	FRF_AZ_RX_DESC_WPTR_WIDTH 12
+#define	FRF_AZ_RX_DESC_PUSH_CMD_LBN 95
+#define	FRF_AZ_RX_DESC_PUSH_CMD_WIDTH 1
+#define	FRF_AZ_RX_DESC_LBN 0
+#define	FRF_AZ_RX_DESC_WIDTH 64
+
+/* RX_DC_CFG_REG: Receive descriptor cache configuration register */
+#define	FR_AZ_RX_DC_CFG 0x00000840
+#define	FRF_AB_RX_MAX_PF_LBN 2
+#define	FRF_AB_RX_MAX_PF_WIDTH 2
+#define	FRF_AZ_RX_DC_SIZE_LBN 0
+#define	FRF_AZ_RX_DC_SIZE_WIDTH 2
+#define	FFE_AZ_RX_DC_SIZE_64 3
+#define	FFE_AZ_RX_DC_SIZE_32 2
+#define	FFE_AZ_RX_DC_SIZE_16 1
+#define	FFE_AZ_RX_DC_SIZE_8 0
+
+/* RX_DC_PF_WM_REG: Receive descriptor cache pre-fetch watermark register */
+#define	FR_AZ_RX_DC_PF_WM 0x00000850
+#define	FRF_AZ_RX_DC_PF_HWM_LBN 6
+#define	FRF_AZ_RX_DC_PF_HWM_WIDTH 6
+#define	FRF_AZ_RX_DC_PF_LWM_LBN 0
+#define	FRF_AZ_RX_DC_PF_LWM_WIDTH 6
+
+/* RX_RSS_TKEY_REG: RSS Toeplitz hash key */
+#define	FR_BZ_RX_RSS_TKEY 0x00000860
+#define	FRF_BZ_RX_RSS_TKEY_HI_LBN 64
+#define	FRF_BZ_RX_RSS_TKEY_HI_WIDTH 64
+#define	FRF_BZ_RX_RSS_TKEY_LO_LBN 0
+#define	FRF_BZ_RX_RSS_TKEY_LO_WIDTH 64
+
+/* RX_NODESC_DROP_REG: Receive dropped packet counter register */
+#define	FR_AZ_RX_NODESC_DROP 0x00000880
+#define	FRF_CZ_RX_NODESC_DROP_CNT_LBN 0
+#define	FRF_CZ_RX_NODESC_DROP_CNT_WIDTH 32
+#define	FRF_AB_RX_NODESC_DROP_CNT_LBN 0
+#define	FRF_AB_RX_NODESC_DROP_CNT_WIDTH 16
+
+/* RX_SELF_RST_REG: Receive self reset register */
+#define	FR_AA_RX_SELF_RST 0x00000890
+#define	FRF_AA_RX_ISCSI_DIS_LBN 17
+#define	FRF_AA_RX_ISCSI_DIS_WIDTH 1
+#define	FRF_AA_RX_SW_RST_REG_LBN 16
+#define	FRF_AA_RX_SW_RST_REG_WIDTH 1
+#define	FRF_AA_RX_NODESC_WAIT_DIS_LBN 9
+#define	FRF_AA_RX_NODESC_WAIT_DIS_WIDTH 1
+#define	FRF_AA_RX_SELF_RST_EN_LBN 8
+#define	FRF_AA_RX_SELF_RST_EN_WIDTH 1
+#define	FRF_AA_RX_MAX_PF_LAT_LBN 4
+#define	FRF_AA_RX_MAX_PF_LAT_WIDTH 4
+#define	FRF_AA_RX_MAX_LU_LAT_LBN 0
+#define	FRF_AA_RX_MAX_LU_LAT_WIDTH 4
+
+/* RX_DEBUG_REG: undocumented register */
+#define	FR_AZ_RX_DEBUG 0x000008a0
+#define	FRF_AZ_RX_DEBUG_LBN 0
+#define	FRF_AZ_RX_DEBUG_WIDTH 64
+
+/* RX_PUSH_DROP_REG: Receive descriptor push dropped counter register */
+#define	FR_AZ_RX_PUSH_DROP 0x000008b0
+#define	FRF_AZ_RX_PUSH_DROP_CNT_LBN 0
+#define	FRF_AZ_RX_PUSH_DROP_CNT_WIDTH 32
+
+/* RX_RSS_IPV6_REG1: IPv6 RSS Toeplitz hash key low bytes */
+#define	FR_CZ_RX_RSS_IPV6_REG1 0x000008d0
+#define	FRF_CZ_RX_RSS_IPV6_TKEY_LO_LBN 0
+#define	FRF_CZ_RX_RSS_IPV6_TKEY_LO_WIDTH 128
+
+/* RX_RSS_IPV6_REG2: IPv6 RSS Toeplitz hash key middle bytes */
+#define	FR_CZ_RX_RSS_IPV6_REG2 0x000008e0
+#define	FRF_CZ_RX_RSS_IPV6_TKEY_MID_LBN 0
+#define	FRF_CZ_RX_RSS_IPV6_TKEY_MID_WIDTH 128
+
+/* RX_RSS_IPV6_REG3: IPv6 RSS Toeplitz hash key upper bytes and IPv6 RSS settings */
+#define	FR_CZ_RX_RSS_IPV6_REG3 0x000008f0
+#define	FRF_CZ_RX_RSS_IPV6_THASH_ENABLE_LBN 66
+#define	FRF_CZ_RX_RSS_IPV6_THASH_ENABLE_WIDTH 1
+#define	FRF_CZ_RX_RSS_IPV6_IP_THASH_ENABLE_LBN 65
+#define	FRF_CZ_RX_RSS_IPV6_IP_THASH_ENABLE_WIDTH 1
+#define	FRF_CZ_RX_RSS_IPV6_TCP_SUPPRESS_LBN 64
+#define	FRF_CZ_RX_RSS_IPV6_TCP_SUPPRESS_WIDTH 1
+#define	FRF_CZ_RX_RSS_IPV6_TKEY_HI_LBN 0
+#define	FRF_CZ_RX_RSS_IPV6_TKEY_HI_WIDTH 64
+
+/* TX_FLUSH_DESCQ_REG: Transmit flush descriptor queue register */
+#define	FR_AZ_TX_FLUSH_DESCQ 0x00000a00
+#define	FRF_AZ_TX_FLUSH_DESCQ_CMD_LBN 12
+#define	FRF_AZ_TX_FLUSH_DESCQ_CMD_WIDTH 1
+#define	FRF_AZ_TX_FLUSH_DESCQ_LBN 0
+#define	FRF_AZ_TX_FLUSH_DESCQ_WIDTH 12
+
+/* TX_DESC_UPD_REGP0: Transmit descriptor update register. */
+#define	FR_BZ_TX_DESC_UPD_P0 0x00000a10
+#define	FR_BZ_TX_DESC_UPD_P0_STEP 8192
+#define	FR_BZ_TX_DESC_UPD_P0_ROWS 1024
+/* TX_DESC_UPD_REG_KER: Transmit descriptor update register. */
+#define	FR_AA_TX_DESC_UPD_KER 0x00000a10
+#define	FR_AA_TX_DESC_UPD_KER_STEP 8192
+#define	FR_AA_TX_DESC_UPD_KER_ROWS 8
+/* TX_DESC_UPD_REGP123: Transmit descriptor update register. */
+#define	FR_BB_TX_DESC_UPD_P123 0x01000a10
+#define	FR_BB_TX_DESC_UPD_P123_STEP 8192
+#define	FR_BB_TX_DESC_UPD_P123_ROWS 3072
+#define	FRF_AZ_TX_DESC_WPTR_LBN 96
+#define	FRF_AZ_TX_DESC_WPTR_WIDTH 12
+#define	FRF_AZ_TX_DESC_PUSH_CMD_LBN 95
+#define	FRF_AZ_TX_DESC_PUSH_CMD_WIDTH 1
+#define	FRF_AZ_TX_DESC_LBN 0
+#define	FRF_AZ_TX_DESC_WIDTH 95
+
+/* TX_DC_CFG_REG: Transmit descriptor cache configuration register */
+#define	FR_AZ_TX_DC_CFG 0x00000a20
+#define	FRF_AZ_TX_DC_SIZE_LBN 0
+#define	FRF_AZ_TX_DC_SIZE_WIDTH 2
+#define	FFE_AZ_TX_DC_SIZE_32 2
+#define	FFE_AZ_TX_DC_SIZE_16 1
+#define	FFE_AZ_TX_DC_SIZE_8 0
+
+/* TX_CHKSM_CFG_REG: Transmit checksum configuration register */
+#define	FR_AA_TX_CHKSM_CFG 0x00000a30
+#define	FRF_AA_TX_Q_CHKSM_DIS_96_127_LBN 96
+#define	FRF_AA_TX_Q_CHKSM_DIS_96_127_WIDTH 32
+#define	FRF_AA_TX_Q_CHKSM_DIS_64_95_LBN 64
+#define	FRF_AA_TX_Q_CHKSM_DIS_64_95_WIDTH 32
+#define	FRF_AA_TX_Q_CHKSM_DIS_32_63_LBN 32
+#define	FRF_AA_TX_Q_CHKSM_DIS_32_63_WIDTH 32
+#define	FRF_AA_TX_Q_CHKSM_DIS_0_31_LBN 0
+#define	FRF_AA_TX_Q_CHKSM_DIS_0_31_WIDTH 32
+
+/* TX_CFG_REG: Transmit configuration register */
+#define	FR_AZ_TX_CFG 0x00000a50
+#define	FRF_CZ_TX_CONT_LOOKUP_THRESH_RANGE_LBN 114
+#define	FRF_CZ_TX_CONT_LOOKUP_THRESH_RANGE_WIDTH 8
+#define	FRF_CZ_TX_FILTER_TEST_MODE_BIT_LBN 113
+#define	FRF_CZ_TX_FILTER_TEST_MODE_BIT_WIDTH 1
+#define	FRF_CZ_TX_ETH_FILTER_WILD_SEARCH_RANGE_LBN 105
+#define	FRF_CZ_TX_ETH_FILTER_WILD_SEARCH_RANGE_WIDTH 8
+#define	FRF_CZ_TX_ETH_FILTER_FULL_SEARCH_RANGE_LBN 97
+#define	FRF_CZ_TX_ETH_FILTER_FULL_SEARCH_RANGE_WIDTH 8
+#define	FRF_CZ_TX_UDPIP_FILTER_WILD_SEARCH_RANGE_LBN 89
+#define	FRF_CZ_TX_UDPIP_FILTER_WILD_SEARCH_RANGE_WIDTH 8
+#define	FRF_CZ_TX_UDPIP_FILTER_FULL_SEARCH_RANGE_LBN 81
+#define	FRF_CZ_TX_UDPIP_FILTER_FULL_SEARCH_RANGE_WIDTH 8
+#define	FRF_CZ_TX_TCPIP_FILTER_WILD_SEARCH_RANGE_LBN 73
+#define	FRF_CZ_TX_TCPIP_FILTER_WILD_SEARCH_RANGE_WIDTH 8
+#define	FRF_CZ_TX_TCPIP_FILTER_FULL_SEARCH_RANGE_LBN 65
+#define	FRF_CZ_TX_TCPIP_FILTER_FULL_SEARCH_RANGE_WIDTH 8
+#define	FRF_CZ_TX_FILTER_ALL_VLAN_ETHERTYPES_BIT_LBN 64
+#define	FRF_CZ_TX_FILTER_ALL_VLAN_ETHERTYPES_BIT_WIDTH 1
+#define	FRF_CZ_TX_VLAN_MATCH_ETHERTYPE_RANGE_LBN 48
+#define	FRF_CZ_TX_VLAN_MATCH_ETHERTYPE_RANGE_WIDTH 16
+#define	FRF_CZ_TX_FILTER_EN_BIT_LBN 47
+#define	FRF_CZ_TX_FILTER_EN_BIT_WIDTH 1
+#define	FRF_AZ_TX_IP_ID_P0_OFS_LBN 16
+#define	FRF_AZ_TX_IP_ID_P0_OFS_WIDTH 15
+#define	FRF_AZ_TX_NO_EOP_DISC_EN_LBN 5
+#define	FRF_AZ_TX_NO_EOP_DISC_EN_WIDTH 1
+#define	FRF_AZ_TX_P1_PRI_EN_LBN 4
+#define	FRF_AZ_TX_P1_PRI_EN_WIDTH 1
+#define	FRF_AZ_TX_OWNERR_CTL_LBN 2
+#define	FRF_AZ_TX_OWNERR_CTL_WIDTH 1
+#define	FRF_AA_TX_NON_IP_DROP_DIS_LBN 1
+#define	FRF_AA_TX_NON_IP_DROP_DIS_WIDTH 1
+#define	FRF_AZ_TX_IP_ID_REP_EN_LBN 0
+#define	FRF_AZ_TX_IP_ID_REP_EN_WIDTH 1
+
+/* TX_PUSH_DROP_REG: Transmit push dropped register */
+#define	FR_AZ_TX_PUSH_DROP 0x00000a60
+#define	FRF_AZ_TX_PUSH_DROP_CNT_LBN 0
+#define	FRF_AZ_TX_PUSH_DROP_CNT_WIDTH 32
+
+/* TX_RESERVED_REG: Transmit configuration register */
+#define	FR_AZ_TX_RESERVED 0x00000a80
+#define	FRF_AZ_TX_EVT_CNT_LBN 121
+#define	FRF_AZ_TX_EVT_CNT_WIDTH 7
+#define	FRF_AZ_TX_PREF_AGE_CNT_LBN 119
+#define	FRF_AZ_TX_PREF_AGE_CNT_WIDTH 2
+#define	FRF_AZ_TX_RD_COMP_TMR_LBN 96
+#define	FRF_AZ_TX_RD_COMP_TMR_WIDTH 23
+#define	FRF_AZ_TX_PUSH_EN_LBN 89
+#define	FRF_AZ_TX_PUSH_EN_WIDTH 1
+#define	FRF_AZ_TX_PUSH_CHK_DIS_LBN 88
+#define	FRF_AZ_TX_PUSH_CHK_DIS_WIDTH 1
+#define	FRF_AZ_TX_D_FF_FULL_P0_LBN 85
+#define	FRF_AZ_TX_D_FF_FULL_P0_WIDTH 1
+#define	FRF_AZ_TX_DMAR_ST_P0_LBN 81
+#define	FRF_AZ_TX_DMAR_ST_P0_WIDTH 1
+#define	FRF_AZ_TX_DMAQ_ST_LBN 78
+#define	FRF_AZ_TX_DMAQ_ST_WIDTH 1
+#define	FRF_AZ_TX_RX_SPACER_LBN 64
+#define	FRF_AZ_TX_RX_SPACER_WIDTH 8
+#define	FRF_AZ_TX_DROP_ABORT_EN_LBN 60
+#define	FRF_AZ_TX_DROP_ABORT_EN_WIDTH 1
+#define	FRF_AZ_TX_SOFT_EVT_EN_LBN 59
+#define	FRF_AZ_TX_SOFT_EVT_EN_WIDTH 1
+#define	FRF_AZ_TX_PS_EVT_DIS_LBN 58
+#define	FRF_AZ_TX_PS_EVT_DIS_WIDTH 1
+#define	FRF_AZ_TX_RX_SPACER_EN_LBN 57
+#define	FRF_AZ_TX_RX_SPACER_EN_WIDTH 1
+#define	FRF_AZ_TX_XP_TIMER_LBN 52
+#define	FRF_AZ_TX_XP_TIMER_WIDTH 5
+#define	FRF_AZ_TX_PREF_SPACER_LBN 44
+#define	FRF_AZ_TX_PREF_SPACER_WIDTH 8
+#define	FRF_AZ_TX_PREF_WD_TMR_LBN 22
+#define	FRF_AZ_TX_PREF_WD_TMR_WIDTH 22
+#define	FRF_AZ_TX_ONLY1TAG_LBN 21
+#define	FRF_AZ_TX_ONLY1TAG_WIDTH 1
+#define	FRF_AZ_TX_PREF_THRESHOLD_LBN 19
+#define	FRF_AZ_TX_PREF_THRESHOLD_WIDTH 2
+#define	FRF_AZ_TX_ONE_PKT_PER_Q_LBN 18
+#define	FRF_AZ_TX_ONE_PKT_PER_Q_WIDTH 1
+#define	FRF_AZ_TX_DIS_NON_IP_EV_LBN 17
+#define	FRF_AZ_TX_DIS_NON_IP_EV_WIDTH 1
+#define	FRF_AA_TX_DMA_FF_THR_LBN 16
+#define	FRF_AA_TX_DMA_FF_THR_WIDTH 1
+#define	FRF_AZ_TX_DMA_SPACER_LBN 8
+#define	FRF_AZ_TX_DMA_SPACER_WIDTH 8
+#define	FRF_AA_TX_TCP_DIS_LBN 7
+#define	FRF_AA_TX_TCP_DIS_WIDTH 1
+#define	FRF_BZ_TX_FLUSH_MIN_LEN_EN_LBN 7
+#define	FRF_BZ_TX_FLUSH_MIN_LEN_EN_WIDTH 1
+#define	FRF_AA_TX_IP_DIS_LBN 6
+#define	FRF_AA_TX_IP_DIS_WIDTH 1
+#define	FRF_AZ_TX_MAX_CPL_LBN 2
+#define	FRF_AZ_TX_MAX_CPL_WIDTH 2
+#define	FFE_AZ_TX_MAX_CPL_16 3
+#define	FFE_AZ_TX_MAX_CPL_8 2
+#define	FFE_AZ_TX_MAX_CPL_4 1
+#define	FFE_AZ_TX_MAX_CPL_NOLIMIT 0
+#define	FRF_AZ_TX_MAX_PREF_LBN 0
+#define	FRF_AZ_TX_MAX_PREF_WIDTH 2
+#define	FFE_AZ_TX_MAX_PREF_32 3
+#define	FFE_AZ_TX_MAX_PREF_16 2
+#define	FFE_AZ_TX_MAX_PREF_8 1
+#define	FFE_AZ_TX_MAX_PREF_OFF 0
+
+/* TX_PACE_REG: Transmit pace control register */
+#define	FR_BZ_TX_PACE 0x00000a90
+#define	FRF_BZ_TX_PACE_SB_NOT_AF_LBN 19
+#define	FRF_BZ_TX_PACE_SB_NOT_AF_WIDTH 10
+#define	FRF_BZ_TX_PACE_SB_AF_LBN 9
+#define	FRF_BZ_TX_PACE_SB_AF_WIDTH 10
+#define	FRF_BZ_TX_PACE_FB_BASE_LBN 5
+#define	FRF_BZ_TX_PACE_FB_BASE_WIDTH 4
+#define	FRF_BZ_TX_PACE_BIN_TH_LBN 0
+#define	FRF_BZ_TX_PACE_BIN_TH_WIDTH 5
+
+/* TX_PACE_DROP_QID_REG: PACE Drop QID Counter */
+#define	FR_BZ_TX_PACE_DROP_QID 0x00000aa0
+#define	FRF_BZ_TX_PACE_QID_DRP_CNT_LBN 0
+#define	FRF_BZ_TX_PACE_QID_DRP_CNT_WIDTH 16
+
+/* TX_VLAN_REG: Transmit VLAN tag register */
+#define	FR_BB_TX_VLAN 0x00000ae0
+#define	FRF_BB_TX_VLAN_EN_LBN 127
+#define	FRF_BB_TX_VLAN_EN_WIDTH 1
+#define	FRF_BB_TX_VLAN7_PORT1_EN_LBN 125
+#define	FRF_BB_TX_VLAN7_PORT1_EN_WIDTH 1
+#define	FRF_BB_TX_VLAN7_PORT0_EN_LBN 124
+#define	FRF_BB_TX_VLAN7_PORT0_EN_WIDTH 1
+#define	FRF_BB_TX_VLAN7_LBN 112
+#define	FRF_BB_TX_VLAN7_WIDTH 12
+#define	FRF_BB_TX_VLAN6_PORT1_EN_LBN 109
+#define	FRF_BB_TX_VLAN6_PORT1_EN_WIDTH 1
+#define	FRF_BB_TX_VLAN6_PORT0_EN_LBN 108
+#define	FRF_BB_TX_VLAN6_PORT0_EN_WIDTH 1
+#define	FRF_BB_TX_VLAN6_LBN 96
+#define	FRF_BB_TX_VLAN6_WIDTH 12
+#define	FRF_BB_TX_VLAN5_PORT1_EN_LBN 93
+#define	FRF_BB_TX_VLAN5_PORT1_EN_WIDTH 1
+#define	FRF_BB_TX_VLAN5_PORT0_EN_LBN 92
+#define	FRF_BB_TX_VLAN5_PORT0_EN_WIDTH 1
+#define	FRF_BB_TX_VLAN5_LBN 80
+#define	FRF_BB_TX_VLAN5_WIDTH 12
+#define	FRF_BB_TX_VLAN4_PORT1_EN_LBN 77
+#define	FRF_BB_TX_VLAN4_PORT1_EN_WIDTH 1
+#define	FRF_BB_TX_VLAN4_PORT0_EN_LBN 76
+#define	FRF_BB_TX_VLAN4_PORT0_EN_WIDTH 1
+#define	FRF_BB_TX_VLAN4_LBN 64
+#define	FRF_BB_TX_VLAN4_WIDTH 12
+#define	FRF_BB_TX_VLAN3_PORT1_EN_LBN 61
+#define	FRF_BB_TX_VLAN3_PORT1_EN_WIDTH 1
+#define	FRF_BB_TX_VLAN3_PORT0_EN_LBN 60
+#define	FRF_BB_TX_VLAN3_PORT0_EN_WIDTH 1
+#define	FRF_BB_TX_VLAN3_LBN 48
+#define	FRF_BB_TX_VLAN3_WIDTH 12
+#define	FRF_BB_TX_VLAN2_PORT1_EN_LBN 45
+#define	FRF_BB_TX_VLAN2_PORT1_EN_WIDTH 1
+#define	FRF_BB_TX_VLAN2_PORT0_EN_LBN 44
+#define	FRF_BB_TX_VLAN2_PORT0_EN_WIDTH 1
+#define	FRF_BB_TX_VLAN2_LBN 32
+#define	FRF_BB_TX_VLAN2_WIDTH 12
+#define	FRF_BB_TX_VLAN1_PORT1_EN_LBN 29
+#define	FRF_BB_TX_VLAN1_PORT1_EN_WIDTH 1
+#define	FRF_BB_TX_VLAN1_PORT0_EN_LBN 28
+#define	FRF_BB_TX_VLAN1_PORT0_EN_WIDTH 1
+#define	FRF_BB_TX_VLAN1_LBN 16
+#define	FRF_BB_TX_VLAN1_WIDTH 12
+#define	FRF_BB_TX_VLAN0_PORT1_EN_LBN 13
+#define	FRF_BB_TX_VLAN0_PORT1_EN_WIDTH 1
+#define	FRF_BB_TX_VLAN0_PORT0_EN_LBN 12
+#define	FRF_BB_TX_VLAN0_PORT0_EN_WIDTH 1
+#define	FRF_BB_TX_VLAN0_LBN 0
+#define	FRF_BB_TX_VLAN0_WIDTH 12
+
+/* TX_IPFIL_PORTEN_REG: Transmit filter control register */
+#define	FR_BZ_TX_IPFIL_PORTEN 0x00000af0
+#define	FRF_BZ_TX_MADR0_FIL_EN_LBN 64
+#define	FRF_BZ_TX_MADR0_FIL_EN_WIDTH 1
+#define	FRF_BB_TX_IPFIL31_PORT_EN_LBN 62
+#define	FRF_BB_TX_IPFIL31_PORT_EN_WIDTH 1
+#define	FRF_BB_TX_IPFIL30_PORT_EN_LBN 60
+#define	FRF_BB_TX_IPFIL30_PORT_EN_WIDTH 1
+#define	FRF_BB_TX_IPFIL29_PORT_EN_LBN 58
+#define	FRF_BB_TX_IPFIL29_PORT_EN_WIDTH 1
+#define	FRF_BB_TX_IPFIL28_PORT_EN_LBN 56
+#define	FRF_BB_TX_IPFIL28_PORT_EN_WIDTH 1
+#define	FRF_BB_TX_IPFIL27_PORT_EN_LBN 54
+#define	FRF_BB_TX_IPFIL27_PORT_EN_WIDTH 1
+#define	FRF_BB_TX_IPFIL26_PORT_EN_LBN 52
+#define	FRF_BB_TX_IPFIL26_PORT_EN_WIDTH 1
+#define	FRF_BB_TX_IPFIL25_PORT_EN_LBN 50
+#define	FRF_BB_TX_IPFIL25_PORT_EN_WIDTH 1
+#define	FRF_BB_TX_IPFIL24_PORT_EN_LBN 48
+#define	FRF_BB_TX_IPFIL24_PORT_EN_WIDTH 1
+#define	FRF_BB_TX_IPFIL23_PORT_EN_LBN 46
+#define	FRF_BB_TX_IPFIL23_PORT_EN_WIDTH 1
+#define	FRF_BB_TX_IPFIL22_PORT_EN_LBN 44
+#define	FRF_BB_TX_IPFIL22_PORT_EN_WIDTH 1
+#define	FRF_BB_TX_IPFIL21_PORT_EN_LBN 42
+#define	FRF_BB_TX_IPFIL21_PORT_EN_WIDTH 1
+#define	FRF_BB_TX_IPFIL20_PORT_EN_LBN 40
+#define	FRF_BB_TX_IPFIL20_PORT_EN_WIDTH 1
+#define	FRF_BB_TX_IPFIL19_PORT_EN_LBN 38
+#define	FRF_BB_TX_IPFIL19_PORT_EN_WIDTH 1
+#define	FRF_BB_TX_IPFIL18_PORT_EN_LBN 36
+#define	FRF_BB_TX_IPFIL18_PORT_EN_WIDTH 1
+#define	FRF_BB_TX_IPFIL17_PORT_EN_LBN 34
+#define	FRF_BB_TX_IPFIL17_PORT_EN_WIDTH 1
+#define	FRF_BB_TX_IPFIL16_PORT_EN_LBN 32
+#define	FRF_BB_TX_IPFIL16_PORT_EN_WIDTH 1
+#define	FRF_BB_TX_IPFIL15_PORT_EN_LBN 30
+#define	FRF_BB_TX_IPFIL15_PORT_EN_WIDTH 1
+#define	FRF_BB_TX_IPFIL14_PORT_EN_LBN 28
+#define	FRF_BB_TX_IPFIL14_PORT_EN_WIDTH 1
+#define	FRF_BB_TX_IPFIL13_PORT_EN_LBN 26
+#define	FRF_BB_TX_IPFIL13_PORT_EN_WIDTH 1
+#define	FRF_BB_TX_IPFIL12_PORT_EN_LBN 24
+#define	FRF_BB_TX_IPFIL12_PORT_EN_WIDTH 1
+#define	FRF_BB_TX_IPFIL11_PORT_EN_LBN 22
+#define	FRF_BB_TX_IPFIL11_PORT_EN_WIDTH 1
+#define	FRF_BB_TX_IPFIL10_PORT_EN_LBN 20
+#define	FRF_BB_TX_IPFIL10_PORT_EN_WIDTH 1
+#define	FRF_BB_TX_IPFIL9_PORT_EN_LBN 18
+#define	FRF_BB_TX_IPFIL9_PORT_EN_WIDTH 1
+#define	FRF_BB_TX_IPFIL8_PORT_EN_LBN 16
+#define	FRF_BB_TX_IPFIL8_PORT_EN_WIDTH 1
+#define	FRF_BB_TX_IPFIL7_PORT_EN_LBN 14
+#define	FRF_BB_TX_IPFIL7_PORT_EN_WIDTH 1
+#define	FRF_BB_TX_IPFIL6_PORT_EN_LBN 12
+#define	FRF_BB_TX_IPFIL6_PORT_EN_WIDTH 1
+#define	FRF_BB_TX_IPFIL5_PORT_EN_LBN 10
+#define	FRF_BB_TX_IPFIL5_PORT_EN_WIDTH 1
+#define	FRF_BB_TX_IPFIL4_PORT_EN_LBN 8
+#define	FRF_BB_TX_IPFIL4_PORT_EN_WIDTH 1
+#define	FRF_BB_TX_IPFIL3_PORT_EN_LBN 6
+#define	FRF_BB_TX_IPFIL3_PORT_EN_WIDTH 1
+#define	FRF_BB_TX_IPFIL2_PORT_EN_LBN 4
+#define	FRF_BB_TX_IPFIL2_PORT_EN_WIDTH 1
+#define	FRF_BB_TX_IPFIL1_PORT_EN_LBN 2
+#define	FRF_BB_TX_IPFIL1_PORT_EN_WIDTH 1
+#define	FRF_BB_TX_IPFIL0_PORT_EN_LBN 0
+#define	FRF_BB_TX_IPFIL0_PORT_EN_WIDTH 1
+
+/* TX_IPFIL_TBL: Transmit IP source address filter table */
+#define	FR_BB_TX_IPFIL_TBL 0x00000b00
+#define	FR_BB_TX_IPFIL_TBL_STEP 16
+#define	FR_BB_TX_IPFIL_TBL_ROWS 16
+#define	FRF_BB_TX_IPFIL_MASK_1_LBN 96
+#define	FRF_BB_TX_IPFIL_MASK_1_WIDTH 32
+#define	FRF_BB_TX_IP_SRC_ADR_1_LBN 64
+#define	FRF_BB_TX_IP_SRC_ADR_1_WIDTH 32
+#define	FRF_BB_TX_IPFIL_MASK_0_LBN 32
+#define	FRF_BB_TX_IPFIL_MASK_0_WIDTH 32
+#define	FRF_BB_TX_IP_SRC_ADR_0_LBN 0
+#define	FRF_BB_TX_IP_SRC_ADR_0_WIDTH 32
+
+/* MD_TXD_REG: PHY management transmit data register */
+#define	FR_AB_MD_TXD 0x00000c00
+#define	FRF_AB_MD_TXD_LBN 0
+#define	FRF_AB_MD_TXD_WIDTH 16
+
+/* MD_RXD_REG: PHY management receive data register */
+#define	FR_AB_MD_RXD 0x00000c10
+#define	FRF_AB_MD_RXD_LBN 0
+#define	FRF_AB_MD_RXD_WIDTH 16
+
+/* MD_CS_REG: PHY management configuration & status register */
+#define	FR_AB_MD_CS 0x00000c20
+#define	FRF_AB_MD_RD_EN_CMD_LBN 15
+#define	FRF_AB_MD_RD_EN_CMD_WIDTH 1
+#define	FRF_AB_MD_WR_EN_CMD_LBN 14
+#define	FRF_AB_MD_WR_EN_CMD_WIDTH 1
+#define	FRF_AB_MD_ADDR_CMD_LBN 13
+#define	FRF_AB_MD_ADDR_CMD_WIDTH 1
+#define	FRF_AB_MD_PT_LBN 7
+#define	FRF_AB_MD_PT_WIDTH 3
+#define	FRF_AB_MD_PL_LBN 6
+#define	FRF_AB_MD_PL_WIDTH 1
+#define	FRF_AB_MD_INT_CLR_LBN 5
+#define	FRF_AB_MD_INT_CLR_WIDTH 1
+#define	FRF_AB_MD_GC_LBN 4
+#define	FRF_AB_MD_GC_WIDTH 1
+#define	FRF_AB_MD_PRSP_LBN 3
+#define	FRF_AB_MD_PRSP_WIDTH 1
+#define	FRF_AB_MD_RIC_LBN 2
+#define	FRF_AB_MD_RIC_WIDTH 1
+#define	FRF_AB_MD_RDC_LBN 1
+#define	FRF_AB_MD_RDC_WIDTH 1
+#define	FRF_AB_MD_WRC_LBN 0
+#define	FRF_AB_MD_WRC_WIDTH 1
+
+/* MD_PHY_ADR_REG: PHY management PHY address register */
+#define	FR_AB_MD_PHY_ADR 0x00000c30
+#define	FRF_AB_MD_PHY_ADR_LBN 0
+#define	FRF_AB_MD_PHY_ADR_WIDTH 16
+
+/* MD_ID_REG: PHY management ID register */
+#define	FR_AB_MD_ID 0x00000c40
+#define	FRF_AB_MD_PRT_ADR_LBN 11
+#define	FRF_AB_MD_PRT_ADR_WIDTH 5
+#define	FRF_AB_MD_DEV_ADR_LBN 6
+#define	FRF_AB_MD_DEV_ADR_WIDTH 5
+
+/* MD_STAT_REG: PHY management status & mask register */
+#define	FR_AB_MD_STAT 0x00000c50
+#define	FRF_AB_MD_PINT_LBN 4
+#define	FRF_AB_MD_PINT_WIDTH 1
+#define	FRF_AB_MD_DONE_LBN 3
+#define	FRF_AB_MD_DONE_WIDTH 1
+#define	FRF_AB_MD_BSERR_LBN 2
+#define	FRF_AB_MD_BSERR_WIDTH 1
+#define	FRF_AB_MD_LNFL_LBN 1
+#define	FRF_AB_MD_LNFL_WIDTH 1
+#define	FRF_AB_MD_BSY_LBN 0
+#define	FRF_AB_MD_BSY_WIDTH 1
+
+/* MAC_STAT_DMA_REG: Port MAC statistical counter DMA register */
+#define	FR_AB_MAC_STAT_DMA 0x00000c60
+#define	FRF_AB_MAC_STAT_DMA_CMD_LBN 48
+#define	FRF_AB_MAC_STAT_DMA_CMD_WIDTH 1
+#define	FRF_AB_MAC_STAT_DMA_ADR_LBN 0
+#define	FRF_AB_MAC_STAT_DMA_ADR_WIDTH 48
+
+/* MAC_CTRL_REG: Port MAC control register */
+#define	FR_AB_MAC_CTRL 0x00000c80
+#define	FRF_AB_MAC_XOFF_VAL_LBN 16
+#define	FRF_AB_MAC_XOFF_VAL_WIDTH 16
+#define	FRF_BB_TXFIFO_DRAIN_EN_LBN 7
+#define	FRF_BB_TXFIFO_DRAIN_EN_WIDTH 1
+#define	FRF_AB_MAC_XG_DISTXCRC_LBN 5
+#define	FRF_AB_MAC_XG_DISTXCRC_WIDTH 1
+#define	FRF_AB_MAC_BCAD_ACPT_LBN 4
+#define	FRF_AB_MAC_BCAD_ACPT_WIDTH 1
+#define	FRF_AB_MAC_UC_PROM_LBN 3
+#define	FRF_AB_MAC_UC_PROM_WIDTH 1
+#define	FRF_AB_MAC_LINK_STATUS_LBN 2
+#define	FRF_AB_MAC_LINK_STATUS_WIDTH 1
+#define	FRF_AB_MAC_SPEED_LBN 0
+#define	FRF_AB_MAC_SPEED_WIDTH 2
+#define	FFE_AB_MAC_SPEED_10G 3
+#define	FFE_AB_MAC_SPEED_1G 2
+#define	FFE_AB_MAC_SPEED_100M 1
+#define	FFE_AB_MAC_SPEED_10M 0
+
+/* GEN_MODE_REG: General Purpose mode register (external interrupt mask) */
+#define	FR_BB_GEN_MODE 0x00000c90
+#define	FRF_BB_XFP_PHY_INT_POL_SEL_LBN 3
+#define	FRF_BB_XFP_PHY_INT_POL_SEL_WIDTH 1
+#define	FRF_BB_XG_PHY_INT_POL_SEL_LBN 2
+#define	FRF_BB_XG_PHY_INT_POL_SEL_WIDTH 1
+#define	FRF_BB_XFP_PHY_INT_MASK_LBN 1
+#define	FRF_BB_XFP_PHY_INT_MASK_WIDTH 1
+#define	FRF_BB_XG_PHY_INT_MASK_LBN 0
+#define	FRF_BB_XG_PHY_INT_MASK_WIDTH 1
+
+/* MAC_MC_HASH_REG0: Multicast address hash table */
+#define	FR_AB_MAC_MC_HASH_REG0 0x00000ca0
+#define	FRF_AB_MAC_MCAST_HASH0_LBN 0
+#define	FRF_AB_MAC_MCAST_HASH0_WIDTH 128
+
+/* MAC_MC_HASH_REG1: Multicast address hash table */
+#define	FR_AB_MAC_MC_HASH_REG1 0x00000cb0
+#define	FRF_AB_MAC_MCAST_HASH1_LBN 0
+#define	FRF_AB_MAC_MCAST_HASH1_WIDTH 128
+
+/* GM_CFG1_REG: GMAC configuration register 1 */
+#define	FR_AB_GM_CFG1 0x00000e00
+#define	FRF_AB_GM_SW_RST_LBN 31
+#define	FRF_AB_GM_SW_RST_WIDTH 1
+#define	FRF_AB_GM_SIM_RST_LBN 30
+#define	FRF_AB_GM_SIM_RST_WIDTH 1
+#define	FRF_AB_GM_RST_RX_MAC_CTL_LBN 19
+#define	FRF_AB_GM_RST_RX_MAC_CTL_WIDTH 1
+#define	FRF_AB_GM_RST_TX_MAC_CTL_LBN 18
+#define	FRF_AB_GM_RST_TX_MAC_CTL_WIDTH 1
+#define	FRF_AB_GM_RST_RX_FUNC_LBN 17
+#define	FRF_AB_GM_RST_RX_FUNC_WIDTH 1
+#define	FRF_AB_GM_RST_TX_FUNC_LBN 16
+#define	FRF_AB_GM_RST_TX_FUNC_WIDTH 1
+#define	FRF_AB_GM_LOOP_LBN 8
+#define	FRF_AB_GM_LOOP_WIDTH 1
+#define	FRF_AB_GM_RX_FC_EN_LBN 5
+#define	FRF_AB_GM_RX_FC_EN_WIDTH 1
+#define	FRF_AB_GM_TX_FC_EN_LBN 4
+#define	FRF_AB_GM_TX_FC_EN_WIDTH 1
+#define	FRF_AB_GM_SYNC_RXEN_LBN 3
+#define	FRF_AB_GM_SYNC_RXEN_WIDTH 1
+#define	FRF_AB_GM_RX_EN_LBN 2
+#define	FRF_AB_GM_RX_EN_WIDTH 1
+#define	FRF_AB_GM_SYNC_TXEN_LBN 1
+#define	FRF_AB_GM_SYNC_TXEN_WIDTH 1
+#define	FRF_AB_GM_TX_EN_LBN 0
+#define	FRF_AB_GM_TX_EN_WIDTH 1
+
+/* GM_CFG2_REG: GMAC configuration register 2 */
+#define	FR_AB_GM_CFG2 0x00000e10
+#define	FRF_AB_GM_PAMBL_LEN_LBN 12
+#define	FRF_AB_GM_PAMBL_LEN_WIDTH 4
+#define	FRF_AB_GM_IF_MODE_LBN 8
+#define	FRF_AB_GM_IF_MODE_WIDTH 2
+#define	FFE_AB_IF_MODE_BYTE_MODE 2
+#define	FFE_AB_IF_MODE_NIBBLE_MODE 1
+#define	FRF_AB_GM_HUGE_FRM_EN_LBN 5
+#define	FRF_AB_GM_HUGE_FRM_EN_WIDTH 1
+#define	FRF_AB_GM_LEN_CHK_LBN 4
+#define	FRF_AB_GM_LEN_CHK_WIDTH 1
+#define	FRF_AB_GM_PAD_CRC_EN_LBN 2
+#define	FRF_AB_GM_PAD_CRC_EN_WIDTH 1
+#define	FRF_AB_GM_CRC_EN_LBN 1
+#define	FRF_AB_GM_CRC_EN_WIDTH 1
+#define	FRF_AB_GM_FD_LBN 0
+#define	FRF_AB_GM_FD_WIDTH 1
+
+/* GM_IPG_REG: GMAC IPG register */
+#define	FR_AB_GM_IPG 0x00000e20
+#define	FRF_AB_GM_NONB2B_IPG1_LBN 24
+#define	FRF_AB_GM_NONB2B_IPG1_WIDTH 7
+#define	FRF_AB_GM_NONB2B_IPG2_LBN 16
+#define	FRF_AB_GM_NONB2B_IPG2_WIDTH 7
+#define	FRF_AB_GM_MIN_IPG_ENF_LBN 8
+#define	FRF_AB_GM_MIN_IPG_ENF_WIDTH 8
+#define	FRF_AB_GM_B2B_IPG_LBN 0
+#define	FRF_AB_GM_B2B_IPG_WIDTH 7
+
+/* GM_HD_REG: GMAC half duplex register */
+#define	FR_AB_GM_HD 0x00000e30
+#define	FRF_AB_GM_ALT_BOFF_VAL_LBN 20
+#define	FRF_AB_GM_ALT_BOFF_VAL_WIDTH 4
+#define	FRF_AB_GM_ALT_BOFF_EN_LBN 19
+#define	FRF_AB_GM_ALT_BOFF_EN_WIDTH 1
+#define	FRF_AB_GM_BP_NO_BOFF_LBN 18
+#define	FRF_AB_GM_BP_NO_BOFF_WIDTH 1
+#define	FRF_AB_GM_DIS_BOFF_LBN 17
+#define	FRF_AB_GM_DIS_BOFF_WIDTH 1
+#define	FRF_AB_GM_EXDEF_TX_EN_LBN 16
+#define	FRF_AB_GM_EXDEF_TX_EN_WIDTH 1
+#define	FRF_AB_GM_RTRY_LIMIT_LBN 12
+#define	FRF_AB_GM_RTRY_LIMIT_WIDTH 4
+#define	FRF_AB_GM_COL_WIN_LBN 0
+#define	FRF_AB_GM_COL_WIN_WIDTH 10
+
+/* GM_MAX_FLEN_REG: GMAC maximum frame length register */
+#define	FR_AB_GM_MAX_FLEN 0x00000e40
+#define	FRF_AB_GM_MAX_FLEN_LBN 0
+#define	FRF_AB_GM_MAX_FLEN_WIDTH 16
+
+/* GM_TEST_REG: GMAC test register */
+#define	FR_AB_GM_TEST 0x00000e70
+#define	FRF_AB_GM_MAX_BOFF_LBN 3
+#define	FRF_AB_GM_MAX_BOFF_WIDTH 1
+#define	FRF_AB_GM_REG_TX_FLOW_EN_LBN 2
+#define	FRF_AB_GM_REG_TX_FLOW_EN_WIDTH 1
+#define	FRF_AB_GM_TEST_PAUSE_LBN 1
+#define	FRF_AB_GM_TEST_PAUSE_WIDTH 1
+#define	FRF_AB_GM_SHORT_SLOT_LBN 0
+#define	FRF_AB_GM_SHORT_SLOT_WIDTH 1
+
+/* GM_ADR1_REG: GMAC station address register 1 */
+#define	FR_AB_GM_ADR1 0x00000f00
+#define	FRF_AB_GM_ADR_B0_LBN 24
+#define	FRF_AB_GM_ADR_B0_WIDTH 8
+#define	FRF_AB_GM_ADR_B1_LBN 16
+#define	FRF_AB_GM_ADR_B1_WIDTH 8
+#define	FRF_AB_GM_ADR_B2_LBN 8
+#define	FRF_AB_GM_ADR_B2_WIDTH 8
+#define	FRF_AB_GM_ADR_B3_LBN 0
+#define	FRF_AB_GM_ADR_B3_WIDTH 8
+
+/* GM_ADR2_REG: GMAC station address register 2 */
+#define	FR_AB_GM_ADR2 0x00000f10
+#define	FRF_AB_GM_ADR_B4_LBN 24
+#define	FRF_AB_GM_ADR_B4_WIDTH 8
+#define	FRF_AB_GM_ADR_B5_LBN 16
+#define	FRF_AB_GM_ADR_B5_WIDTH 8
+
+/* GMF_CFG0_REG: GMAC FIFO configuration register 0 */
+#define	FR_AB_GMF_CFG0 0x00000f20
+#define	FRF_AB_GMF_FTFENRPLY_LBN 20
+#define	FRF_AB_GMF_FTFENRPLY_WIDTH 1
+#define	FRF_AB_GMF_STFENRPLY_LBN 19
+#define	FRF_AB_GMF_STFENRPLY_WIDTH 1
+#define	FRF_AB_GMF_FRFENRPLY_LBN 18
+#define	FRF_AB_GMF_FRFENRPLY_WIDTH 1
+#define	FRF_AB_GMF_SRFENRPLY_LBN 17
+#define	FRF_AB_GMF_SRFENRPLY_WIDTH 1
+#define	FRF_AB_GMF_WTMENRPLY_LBN 16
+#define	FRF_AB_GMF_WTMENRPLY_WIDTH 1
+#define	FRF_AB_GMF_FTFENREQ_LBN 12
+#define	FRF_AB_GMF_FTFENREQ_WIDTH 1
+#define	FRF_AB_GMF_STFENREQ_LBN 11
+#define	FRF_AB_GMF_STFENREQ_WIDTH 1
+#define	FRF_AB_GMF_FRFENREQ_LBN 10
+#define	FRF_AB_GMF_FRFENREQ_WIDTH 1
+#define	FRF_AB_GMF_SRFENREQ_LBN 9
+#define	FRF_AB_GMF_SRFENREQ_WIDTH 1
+#define	FRF_AB_GMF_WTMENREQ_LBN 8
+#define	FRF_AB_GMF_WTMENREQ_WIDTH 1
+#define	FRF_AB_GMF_HSTRSTFT_LBN 4
+#define	FRF_AB_GMF_HSTRSTFT_WIDTH 1
+#define	FRF_AB_GMF_HSTRSTST_LBN 3
+#define	FRF_AB_GMF_HSTRSTST_WIDTH 1
+#define	FRF_AB_GMF_HSTRSTFR_LBN 2
+#define	FRF_AB_GMF_HSTRSTFR_WIDTH 1
+#define	FRF_AB_GMF_HSTRSTSR_LBN 1
+#define	FRF_AB_GMF_HSTRSTSR_WIDTH 1
+#define	FRF_AB_GMF_HSTRSTWT_LBN 0
+#define	FRF_AB_GMF_HSTRSTWT_WIDTH 1
+
+/* GMF_CFG1_REG: GMAC FIFO configuration register 1 */
+#define	FR_AB_GMF_CFG1 0x00000f30
+#define	FRF_AB_GMF_CFGFRTH_LBN 16
+#define	FRF_AB_GMF_CFGFRTH_WIDTH 5
+#define	FRF_AB_GMF_CFGXOFFRTX_LBN 0
+#define	FRF_AB_GMF_CFGXOFFRTX_WIDTH 16
+
+/* GMF_CFG2_REG: GMAC FIFO configuration register 2 */
+#define	FR_AB_GMF_CFG2 0x00000f40
+#define	FRF_AB_GMF_CFGHWM_LBN 16
+#define	FRF_AB_GMF_CFGHWM_WIDTH 6
+#define	FRF_AB_GMF_CFGLWM_LBN 0
+#define	FRF_AB_GMF_CFGLWM_WIDTH 6
+
+/* GMF_CFG3_REG: GMAC FIFO configuration register 3 */
+#define	FR_AB_GMF_CFG3 0x00000f50
+#define	FRF_AB_GMF_CFGHWMFT_LBN 16
+#define	FRF_AB_GMF_CFGHWMFT_WIDTH 6
+#define	FRF_AB_GMF_CFGFTTH_LBN 0
+#define	FRF_AB_GMF_CFGFTTH_WIDTH 6
+
+/* GMF_CFG4_REG: GMAC FIFO configuration register 4 */
+#define	FR_AB_GMF_CFG4 0x00000f60
+#define	FRF_AB_GMF_HSTFLTRFRM_LBN 0
+#define	FRF_AB_GMF_HSTFLTRFRM_WIDTH 18
+
+/* GMF_CFG5_REG: GMAC FIFO configuration register 5 */
+#define	FR_AB_GMF_CFG5 0x00000f70
+#define	FRF_AB_GMF_CFGHDPLX_LBN 22
+#define	FRF_AB_GMF_CFGHDPLX_WIDTH 1
+#define	FRF_AB_GMF_SRFULL_LBN 21
+#define	FRF_AB_GMF_SRFULL_WIDTH 1
+#define	FRF_AB_GMF_HSTSRFULLCLR_LBN 20
+#define	FRF_AB_GMF_HSTSRFULLCLR_WIDTH 1
+#define	FRF_AB_GMF_CFGBYTMODE_LBN 19
+#define	FRF_AB_GMF_CFGBYTMODE_WIDTH 1
+#define	FRF_AB_GMF_HSTDRPLT64_LBN 18
+#define	FRF_AB_GMF_HSTDRPLT64_WIDTH 1
+#define	FRF_AB_GMF_HSTFLTRFRMDC_LBN 0
+#define	FRF_AB_GMF_HSTFLTRFRMDC_WIDTH 18
+
+/* TX_SRC_MAC_TBL: Transmit IP source address filter table */
+#define	FR_BB_TX_SRC_MAC_TBL 0x00001000
+#define	FR_BB_TX_SRC_MAC_TBL_STEP 16
+#define	FR_BB_TX_SRC_MAC_TBL_ROWS 16
+#define	FRF_BB_TX_SRC_MAC_ADR_1_LBN 64
+#define	FRF_BB_TX_SRC_MAC_ADR_1_WIDTH 48
+#define	FRF_BB_TX_SRC_MAC_ADR_0_LBN 0
+#define	FRF_BB_TX_SRC_MAC_ADR_0_WIDTH 48
+
+/* TX_SRC_MAC_CTL_REG: Transmit MAC source address filter control */
+#define	FR_BB_TX_SRC_MAC_CTL 0x00001100
+#define	FRF_BB_TX_SRC_DROP_CTR_LBN 16
+#define	FRF_BB_TX_SRC_DROP_CTR_WIDTH 16
+#define	FRF_BB_TX_SRC_FLTR_EN_LBN 15
+#define	FRF_BB_TX_SRC_FLTR_EN_WIDTH 1
+#define	FRF_BB_TX_DROP_CTR_CLR_LBN 12
+#define	FRF_BB_TX_DROP_CTR_CLR_WIDTH 1
+#define	FRF_BB_TX_MAC_QID_SEL_LBN 0
+#define	FRF_BB_TX_MAC_QID_SEL_WIDTH 3
+
+/* XM_ADR_LO_REG: XGMAC address register low */
+#define	FR_AB_XM_ADR_LO 0x00001200
+#define	FRF_AB_XM_ADR_LO_LBN 0
+#define	FRF_AB_XM_ADR_LO_WIDTH 32
+
+/* XM_ADR_HI_REG: XGMAC address register high */
+#define	FR_AB_XM_ADR_HI 0x00001210
+#define	FRF_AB_XM_ADR_HI_LBN 0
+#define	FRF_AB_XM_ADR_HI_WIDTH 16
+
+/* XM_GLB_CFG_REG: XGMAC global configuration */
+#define	FR_AB_XM_GLB_CFG 0x00001220
+#define	FRF_AB_XM_RMTFLT_GEN_LBN 17
+#define	FRF_AB_XM_RMTFLT_GEN_WIDTH 1
+#define	FRF_AB_XM_DEBUG_MODE_LBN 16
+#define	FRF_AB_XM_DEBUG_MODE_WIDTH 1
+#define	FRF_AB_XM_RX_STAT_EN_LBN 11
+#define	FRF_AB_XM_RX_STAT_EN_WIDTH 1
+#define	FRF_AB_XM_TX_STAT_EN_LBN 10
+#define	FRF_AB_XM_TX_STAT_EN_WIDTH 1
+#define	FRF_AB_XM_RX_JUMBO_MODE_LBN 6
+#define	FRF_AB_XM_RX_JUMBO_MODE_WIDTH 1
+#define	FRF_AB_XM_WAN_MODE_LBN 5
+#define	FRF_AB_XM_WAN_MODE_WIDTH 1
+#define	FRF_AB_XM_INTCLR_MODE_LBN 3
+#define	FRF_AB_XM_INTCLR_MODE_WIDTH 1
+#define	FRF_AB_XM_CORE_RST_LBN 0
+#define	FRF_AB_XM_CORE_RST_WIDTH 1
+
+/* XM_TX_CFG_REG: XGMAC transmit configuration */
+#define	FR_AB_XM_TX_CFG 0x00001230
+#define	FRF_AB_XM_TX_PROG_LBN 24
+#define	FRF_AB_XM_TX_PROG_WIDTH 1
+#define	FRF_AB_XM_IPG_LBN 16
+#define	FRF_AB_XM_IPG_WIDTH 4
+#define	FRF_AB_XM_FCNTL_LBN 10
+#define	FRF_AB_XM_FCNTL_WIDTH 1
+#define	FRF_AB_XM_TXCRC_LBN 8
+#define	FRF_AB_XM_TXCRC_WIDTH 1
+#define	FRF_AB_XM_EDRC_LBN 6
+#define	FRF_AB_XM_EDRC_WIDTH 1
+#define	FRF_AB_XM_AUTO_PAD_LBN 5
+#define	FRF_AB_XM_AUTO_PAD_WIDTH 1
+#define	FRF_AB_XM_TX_PRMBL_LBN 2
+#define	FRF_AB_XM_TX_PRMBL_WIDTH 1
+#define	FRF_AB_XM_TXEN_LBN 1
+#define	FRF_AB_XM_TXEN_WIDTH 1
+#define	FRF_AB_XM_TX_RST_LBN 0
+#define	FRF_AB_XM_TX_RST_WIDTH 1
+
+/* XM_RX_CFG_REG: XGMAC receive configuration */
+#define	FR_AB_XM_RX_CFG 0x00001240
+#define	FRF_AB_XM_PASS_LENERR_LBN 26
+#define	FRF_AB_XM_PASS_LENERR_WIDTH 1
+#define	FRF_AB_XM_PASS_CRC_ERR_LBN 25
+#define	FRF_AB_XM_PASS_CRC_ERR_WIDTH 1
+#define	FRF_AB_XM_PASS_PRMBLE_ERR_LBN 24
+#define	FRF_AB_XM_PASS_PRMBLE_ERR_WIDTH 1
+#define	FRF_AB_XM_REJ_BCAST_LBN 20
+#define	FRF_AB_XM_REJ_BCAST_WIDTH 1
+#define	FRF_AB_XM_ACPT_ALL_MCAST_LBN 11
+#define	FRF_AB_XM_ACPT_ALL_MCAST_WIDTH 1
+#define	FRF_AB_XM_ACPT_ALL_UCAST_LBN 9
+#define	FRF_AB_XM_ACPT_ALL_UCAST_WIDTH 1
+#define	FRF_AB_XM_AUTO_DEPAD_LBN 8
+#define	FRF_AB_XM_AUTO_DEPAD_WIDTH 1
+#define	FRF_AB_XM_RXCRC_LBN 3
+#define	FRF_AB_XM_RXCRC_WIDTH 1
+#define	FRF_AB_XM_RX_PRMBL_LBN 2
+#define	FRF_AB_XM_RX_PRMBL_WIDTH 1
+#define	FRF_AB_XM_RXEN_LBN 1
+#define	FRF_AB_XM_RXEN_WIDTH 1
+#define	FRF_AB_XM_RX_RST_LBN 0
+#define	FRF_AB_XM_RX_RST_WIDTH 1
+
+/* XM_MGT_INT_MASK: documentation to be written for sum_XM_MGT_INT_MASK */
+#define	FR_AB_XM_MGT_INT_MASK 0x00001250
+#define	FRF_AB_XM_MSK_STA_INTR_LBN 16
+#define	FRF_AB_XM_MSK_STA_INTR_WIDTH 1
+#define	FRF_AB_XM_MSK_STAT_CNTR_HF_LBN 9
+#define	FRF_AB_XM_MSK_STAT_CNTR_HF_WIDTH 1
+#define	FRF_AB_XM_MSK_STAT_CNTR_OF_LBN 8
+#define	FRF_AB_XM_MSK_STAT_CNTR_OF_WIDTH 1
+#define	FRF_AB_XM_MSK_PRMBLE_ERR_LBN 2
+#define	FRF_AB_XM_MSK_PRMBLE_ERR_WIDTH 1
+#define	FRF_AB_XM_MSK_RMTFLT_LBN 1
+#define	FRF_AB_XM_MSK_RMTFLT_WIDTH 1
+#define	FRF_AB_XM_MSK_LCLFLT_LBN 0
+#define	FRF_AB_XM_MSK_LCLFLT_WIDTH 1
+
+/* XM_FC_REG: XGMAC flow control register */
+#define	FR_AB_XM_FC 0x00001270
+#define	FRF_AB_XM_PAUSE_TIME_LBN 16
+#define	FRF_AB_XM_PAUSE_TIME_WIDTH 16
+#define	FRF_AB_XM_RX_MAC_STAT_LBN 11
+#define	FRF_AB_XM_RX_MAC_STAT_WIDTH 1
+#define	FRF_AB_XM_TX_MAC_STAT_LBN 10
+#define	FRF_AB_XM_TX_MAC_STAT_WIDTH 1
+#define	FRF_AB_XM_MCNTL_PASS_LBN 8
+#define	FRF_AB_XM_MCNTL_PASS_WIDTH 2
+#define	FRF_AB_XM_REJ_CNTL_UCAST_LBN 6
+#define	FRF_AB_XM_REJ_CNTL_UCAST_WIDTH 1
+#define	FRF_AB_XM_REJ_CNTL_MCAST_LBN 5
+#define	FRF_AB_XM_REJ_CNTL_MCAST_WIDTH 1
+#define	FRF_AB_XM_ZPAUSE_LBN 2
+#define	FRF_AB_XM_ZPAUSE_WIDTH 1
+#define	FRF_AB_XM_XMIT_PAUSE_LBN 1
+#define	FRF_AB_XM_XMIT_PAUSE_WIDTH 1
+#define	FRF_AB_XM_DIS_FCNTL_LBN 0
+#define	FRF_AB_XM_DIS_FCNTL_WIDTH 1
+
+/* XM_PAUSE_TIME_REG: XGMAC pause time register */
+#define	FR_AB_XM_PAUSE_TIME 0x00001290
+#define	FRF_AB_XM_TX_PAUSE_CNT_LBN 16
+#define	FRF_AB_XM_TX_PAUSE_CNT_WIDTH 16
+#define	FRF_AB_XM_RX_PAUSE_CNT_LBN 0
+#define	FRF_AB_XM_RX_PAUSE_CNT_WIDTH 16
+
+/* XM_TX_PARAM_REG: XGMAC transmit parameter register */
+#define	FR_AB_XM_TX_PARAM 0x000012d0
+#define	FRF_AB_XM_TX_JUMBO_MODE_LBN 31
+#define	FRF_AB_XM_TX_JUMBO_MODE_WIDTH 1
+#define	FRF_AB_XM_MAX_TX_FRM_SIZE_HI_LBN 19
+#define	FRF_AB_XM_MAX_TX_FRM_SIZE_HI_WIDTH 11
+#define	FRF_AB_XM_MAX_TX_FRM_SIZE_LO_LBN 16
+#define	FRF_AB_XM_MAX_TX_FRM_SIZE_LO_WIDTH 3
+#define	FRF_AB_XM_PAD_CHAR_LBN 0
+#define	FRF_AB_XM_PAD_CHAR_WIDTH 8
+
+/* XM_RX_PARAM_REG: XGMAC receive parameter register */
+#define	FR_AB_XM_RX_PARAM 0x000012e0
+#define	FRF_AB_XM_MAX_RX_FRM_SIZE_HI_LBN 3
+#define	FRF_AB_XM_MAX_RX_FRM_SIZE_HI_WIDTH 11
+#define	FRF_AB_XM_MAX_RX_FRM_SIZE_LO_LBN 0
+#define	FRF_AB_XM_MAX_RX_FRM_SIZE_LO_WIDTH 3
+
+/* XM_MGT_INT_MSK_REG: XGMAC management interrupt mask register */
+#define	FR_AB_XM_MGT_INT_MSK 0x000012f0
+#define	FRF_AB_XM_STAT_CNTR_OF_LBN 9
+#define	FRF_AB_XM_STAT_CNTR_OF_WIDTH 1
+#define	FRF_AB_XM_STAT_CNTR_HF_LBN 8
+#define	FRF_AB_XM_STAT_CNTR_HF_WIDTH 1
+#define	FRF_AB_XM_PRMBLE_ERR_LBN 2
+#define	FRF_AB_XM_PRMBLE_ERR_WIDTH 1
+#define	FRF_AB_XM_RMTFLT_LBN 1
+#define	FRF_AB_XM_RMTFLT_WIDTH 1
+#define	FRF_AB_XM_LCLFLT_LBN 0
+#define	FRF_AB_XM_LCLFLT_WIDTH 1
+
+/* XX_PWR_RST_REG: XGXS/XAUI powerdown/reset register */
+#define	FR_AB_XX_PWR_RST 0x00001300
+#define	FRF_AB_XX_PWRDND_SIG_LBN 31
+#define	FRF_AB_XX_PWRDND_SIG_WIDTH 1
+#define	FRF_AB_XX_PWRDNC_SIG_LBN 30
+#define	FRF_AB_XX_PWRDNC_SIG_WIDTH 1
+#define	FRF_AB_XX_PWRDNB_SIG_LBN 29
+#define	FRF_AB_XX_PWRDNB_SIG_WIDTH 1
+#define	FRF_AB_XX_PWRDNA_SIG_LBN 28
+#define	FRF_AB_XX_PWRDNA_SIG_WIDTH 1
+#define	FRF_AB_XX_SIM_MODE_LBN 27
+#define	FRF_AB_XX_SIM_MODE_WIDTH 1
+#define	FRF_AB_XX_RSTPLLCD_SIG_LBN 25
+#define	FRF_AB_XX_RSTPLLCD_SIG_WIDTH 1
+#define	FRF_AB_XX_RSTPLLAB_SIG_LBN 24
+#define	FRF_AB_XX_RSTPLLAB_SIG_WIDTH 1
+#define	FRF_AB_XX_RESETD_SIG_LBN 23
+#define	FRF_AB_XX_RESETD_SIG_WIDTH 1
+#define	FRF_AB_XX_RESETC_SIG_LBN 22
+#define	FRF_AB_XX_RESETC_SIG_WIDTH 1
+#define	FRF_AB_XX_RESETB_SIG_LBN 21
+#define	FRF_AB_XX_RESETB_SIG_WIDTH 1
+#define	FRF_AB_XX_RESETA_SIG_LBN 20
+#define	FRF_AB_XX_RESETA_SIG_WIDTH 1
+#define	FRF_AB_XX_RSTXGXSRX_SIG_LBN 18
+#define	FRF_AB_XX_RSTXGXSRX_SIG_WIDTH 1
+#define	FRF_AB_XX_RSTXGXSTX_SIG_LBN 17
+#define	FRF_AB_XX_RSTXGXSTX_SIG_WIDTH 1
+#define	FRF_AB_XX_SD_RST_ACT_LBN 16
+#define	FRF_AB_XX_SD_RST_ACT_WIDTH 1
+#define	FRF_AB_XX_PWRDND_EN_LBN 15
+#define	FRF_AB_XX_PWRDND_EN_WIDTH 1
+#define	FRF_AB_XX_PWRDNC_EN_LBN 14
+#define	FRF_AB_XX_PWRDNC_EN_WIDTH 1
+#define	FRF_AB_XX_PWRDNB_EN_LBN 13
+#define	FRF_AB_XX_PWRDNB_EN_WIDTH 1
+#define	FRF_AB_XX_PWRDNA_EN_LBN 12
+#define	FRF_AB_XX_PWRDNA_EN_WIDTH 1
+#define	FRF_AB_XX_RSTPLLCD_EN_LBN 9
+#define	FRF_AB_XX_RSTPLLCD_EN_WIDTH 1
+#define	FRF_AB_XX_RSTPLLAB_EN_LBN 8
+#define	FRF_AB_XX_RSTPLLAB_EN_WIDTH 1
+#define	FRF_AB_XX_RESETD_EN_LBN 7
+#define	FRF_AB_XX_RESETD_EN_WIDTH 1
+#define	FRF_AB_XX_RESETC_EN_LBN 6
+#define	FRF_AB_XX_RESETC_EN_WIDTH 1
+#define	FRF_AB_XX_RESETB_EN_LBN 5
+#define	FRF_AB_XX_RESETB_EN_WIDTH 1
+#define	FRF_AB_XX_RESETA_EN_LBN 4
+#define	FRF_AB_XX_RESETA_EN_WIDTH 1
+#define	FRF_AB_XX_RSTXGXSRX_EN_LBN 2
+#define	FRF_AB_XX_RSTXGXSRX_EN_WIDTH 1
+#define	FRF_AB_XX_RSTXGXSTX_EN_LBN 1
+#define	FRF_AB_XX_RSTXGXSTX_EN_WIDTH 1
+#define	FRF_AB_XX_RST_XX_EN_LBN 0
+#define	FRF_AB_XX_RST_XX_EN_WIDTH 1
+
+/* XX_SD_CTL_REG: XGXS/XAUI powerdown/reset control register */
+#define	FR_AB_XX_SD_CTL 0x00001310
+#define	FRF_AB_XX_TERMADJ1_LBN 17
+#define	FRF_AB_XX_TERMADJ1_WIDTH 1
+#define	FRF_AB_XX_TERMADJ0_LBN 16
+#define	FRF_AB_XX_TERMADJ0_WIDTH 1
+#define	FRF_AB_XX_HIDRVD_LBN 15
+#define	FRF_AB_XX_HIDRVD_WIDTH 1
+#define	FRF_AB_XX_LODRVD_LBN 14
+#define	FRF_AB_XX_LODRVD_WIDTH 1
+#define	FRF_AB_XX_HIDRVC_LBN 13
+#define	FRF_AB_XX_HIDRVC_WIDTH 1
+#define	FRF_AB_XX_LODRVC_LBN 12
+#define	FRF_AB_XX_LODRVC_WIDTH 1
+#define	FRF_AB_XX_HIDRVB_LBN 11
+#define	FRF_AB_XX_HIDRVB_WIDTH 1
+#define	FRF_AB_XX_LODRVB_LBN 10
+#define	FRF_AB_XX_LODRVB_WIDTH 1
+#define	FRF_AB_XX_HIDRVA_LBN 9
+#define	FRF_AB_XX_HIDRVA_WIDTH 1
+#define	FRF_AB_XX_LODRVA_LBN 8
+#define	FRF_AB_XX_LODRVA_WIDTH 1
+#define	FRF_AB_XX_LPBKD_LBN 3
+#define	FRF_AB_XX_LPBKD_WIDTH 1
+#define	FRF_AB_XX_LPBKC_LBN 2
+#define	FRF_AB_XX_LPBKC_WIDTH 1
+#define	FRF_AB_XX_LPBKB_LBN 1
+#define	FRF_AB_XX_LPBKB_WIDTH 1
+#define	FRF_AB_XX_LPBKA_LBN 0
+#define	FRF_AB_XX_LPBKA_WIDTH 1
+
+/* XX_TXDRV_CTL_REG: XAUI SerDes transmit drive control register */
+#define	FR_AB_XX_TXDRV_CTL 0x00001320
+#define	FRF_AB_XX_DEQD_LBN 28
+#define	FRF_AB_XX_DEQD_WIDTH 4
+#define	FRF_AB_XX_DEQC_LBN 24
+#define	FRF_AB_XX_DEQC_WIDTH 4
+#define	FRF_AB_XX_DEQB_LBN 20
+#define	FRF_AB_XX_DEQB_WIDTH 4
+#define	FRF_AB_XX_DEQA_LBN 16
+#define	FRF_AB_XX_DEQA_WIDTH 4
+#define	FRF_AB_XX_DTXD_LBN 12
+#define	FRF_AB_XX_DTXD_WIDTH 4
+#define	FRF_AB_XX_DTXC_LBN 8
+#define	FRF_AB_XX_DTXC_WIDTH 4
+#define	FRF_AB_XX_DTXB_LBN 4
+#define	FRF_AB_XX_DTXB_WIDTH 4
+#define	FRF_AB_XX_DTXA_LBN 0
+#define	FRF_AB_XX_DTXA_WIDTH 4
+
+/* XX_PRBS_CTL_REG: documentation to be written for sum_XX_PRBS_CTL_REG */
+#define	FR_AB_XX_PRBS_CTL 0x00001330
+#define	FRF_AB_XX_CH3_RX_PRBS_SEL_LBN 30
+#define	FRF_AB_XX_CH3_RX_PRBS_SEL_WIDTH 2
+#define	FRF_AB_XX_CH3_RX_PRBS_INV_LBN 29
+#define	FRF_AB_XX_CH3_RX_PRBS_INV_WIDTH 1
+#define	FRF_AB_XX_CH3_RX_PRBS_CHKEN_LBN 28
+#define	FRF_AB_XX_CH3_RX_PRBS_CHKEN_WIDTH 1
+#define	FRF_AB_XX_CH2_RX_PRBS_SEL_LBN 26
+#define	FRF_AB_XX_CH2_RX_PRBS_SEL_WIDTH 2
+#define	FRF_AB_XX_CH2_RX_PRBS_INV_LBN 25
+#define	FRF_AB_XX_CH2_RX_PRBS_INV_WIDTH 1
+#define	FRF_AB_XX_CH2_RX_PRBS_CHKEN_LBN 24
+#define	FRF_AB_XX_CH2_RX_PRBS_CHKEN_WIDTH 1
+#define	FRF_AB_XX_CH1_RX_PRBS_SEL_LBN 22
+#define	FRF_AB_XX_CH1_RX_PRBS_SEL_WIDTH 2
+#define	FRF_AB_XX_CH1_RX_PRBS_INV_LBN 21
+#define	FRF_AB_XX_CH1_RX_PRBS_INV_WIDTH 1
+#define	FRF_AB_XX_CH1_RX_PRBS_CHKEN_LBN 20
+#define	FRF_AB_XX_CH1_RX_PRBS_CHKEN_WIDTH 1
+#define	FRF_AB_XX_CH0_RX_PRBS_SEL_LBN 18
+#define	FRF_AB_XX_CH0_RX_PRBS_SEL_WIDTH 2
+#define	FRF_AB_XX_CH0_RX_PRBS_INV_LBN 17
+#define	FRF_AB_XX_CH0_RX_PRBS_INV_WIDTH 1
+#define	FRF_AB_XX_CH0_RX_PRBS_CHKEN_LBN 16
+#define	FRF_AB_XX_CH0_RX_PRBS_CHKEN_WIDTH 1
+#define	FRF_AB_XX_CH3_TX_PRBS_SEL_LBN 14
+#define	FRF_AB_XX_CH3_TX_PRBS_SEL_WIDTH 2
+#define	FRF_AB_XX_CH3_TX_PRBS_INV_LBN 13
+#define	FRF_AB_XX_CH3_TX_PRBS_INV_WIDTH 1
+#define	FRF_AB_XX_CH3_TX_PRBS_CHKEN_LBN 12
+#define	FRF_AB_XX_CH3_TX_PRBS_CHKEN_WIDTH 1
+#define	FRF_AB_XX_CH2_TX_PRBS_SEL_LBN 10
+#define	FRF_AB_XX_CH2_TX_PRBS_SEL_WIDTH 2
+#define	FRF_AB_XX_CH2_TX_PRBS_INV_LBN 9
+#define	FRF_AB_XX_CH2_TX_PRBS_INV_WIDTH 1
+#define	FRF_AB_XX_CH2_TX_PRBS_CHKEN_LBN 8
+#define	FRF_AB_XX_CH2_TX_PRBS_CHKEN_WIDTH 1
+#define	FRF_AB_XX_CH1_TX_PRBS_SEL_LBN 6
+#define	FRF_AB_XX_CH1_TX_PRBS_SEL_WIDTH 2
+#define	FRF_AB_XX_CH1_TX_PRBS_INV_LBN 5
+#define	FRF_AB_XX_CH1_TX_PRBS_INV_WIDTH 1
+#define	FRF_AB_XX_CH1_TX_PRBS_CHKEN_LBN 4
+#define	FRF_AB_XX_CH1_TX_PRBS_CHKEN_WIDTH 1
+#define	FRF_AB_XX_CH0_TX_PRBS_SEL_LBN 2
+#define	FRF_AB_XX_CH0_TX_PRBS_SEL_WIDTH 2
+#define	FRF_AB_XX_CH0_TX_PRBS_INV_LBN 1
+#define	FRF_AB_XX_CH0_TX_PRBS_INV_WIDTH 1
+#define	FRF_AB_XX_CH0_TX_PRBS_CHKEN_LBN 0
+#define	FRF_AB_XX_CH0_TX_PRBS_CHKEN_WIDTH 1
+
+/* XX_PRBS_CHK_REG: documentation to be written for sum_XX_PRBS_CHK_REG */
+#define	FR_AB_XX_PRBS_CHK 0x00001340
+#define	FRF_AB_XX_REV_LB_EN_LBN 16
+#define	FRF_AB_XX_REV_LB_EN_WIDTH 1
+#define	FRF_AB_XX_CH3_DEG_DET_LBN 15
+#define	FRF_AB_XX_CH3_DEG_DET_WIDTH 1
+#define	FRF_AB_XX_CH3_LFSR_LOCK_IND_LBN 14
+#define	FRF_AB_XX_CH3_LFSR_LOCK_IND_WIDTH 1
+#define	FRF_AB_XX_CH3_PRBS_FRUN_LBN 13
+#define	FRF_AB_XX_CH3_PRBS_FRUN_WIDTH 1
+#define	FRF_AB_XX_CH3_ERR_CHK_LBN 12
+#define	FRF_AB_XX_CH3_ERR_CHK_WIDTH 1
+#define	FRF_AB_XX_CH2_DEG_DET_LBN 11
+#define	FRF_AB_XX_CH2_DEG_DET_WIDTH 1
+#define	FRF_AB_XX_CH2_LFSR_LOCK_IND_LBN 10
+#define	FRF_AB_XX_CH2_LFSR_LOCK_IND_WIDTH 1
+#define	FRF_AB_XX_CH2_PRBS_FRUN_LBN 9
+#define	FRF_AB_XX_CH2_PRBS_FRUN_WIDTH 1
+#define	FRF_AB_XX_CH2_ERR_CHK_LBN 8
+#define	FRF_AB_XX_CH2_ERR_CHK_WIDTH 1
+#define	FRF_AB_XX_CH1_DEG_DET_LBN 7
+#define	FRF_AB_XX_CH1_DEG_DET_WIDTH 1
+#define	FRF_AB_XX_CH1_LFSR_LOCK_IND_LBN 6
+#define	FRF_AB_XX_CH1_LFSR_LOCK_IND_WIDTH 1
+#define	FRF_AB_XX_CH1_PRBS_FRUN_LBN 5
+#define	FRF_AB_XX_CH1_PRBS_FRUN_WIDTH 1
+#define	FRF_AB_XX_CH1_ERR_CHK_LBN 4
+#define	FRF_AB_XX_CH1_ERR_CHK_WIDTH 1
+#define	FRF_AB_XX_CH0_DEG_DET_LBN 3
+#define	FRF_AB_XX_CH0_DEG_DET_WIDTH 1
+#define	FRF_AB_XX_CH0_LFSR_LOCK_IND_LBN 2
+#define	FRF_AB_XX_CH0_LFSR_LOCK_IND_WIDTH 1
+#define	FRF_AB_XX_CH0_PRBS_FRUN_LBN 1
+#define	FRF_AB_XX_CH0_PRBS_FRUN_WIDTH 1
+#define	FRF_AB_XX_CH0_ERR_CHK_LBN 0
+#define	FRF_AB_XX_CH0_ERR_CHK_WIDTH 1
+
+/* XX_PRBS_ERR_REG: documentation to be written for sum_XX_PRBS_ERR_REG */
+#define	FR_AB_XX_PRBS_ERR 0x00001350
+#define	FRF_AB_XX_CH3_PRBS_ERR_CNT_LBN 24
+#define	FRF_AB_XX_CH3_PRBS_ERR_CNT_WIDTH 8
+#define	FRF_AB_XX_CH2_PRBS_ERR_CNT_LBN 16
+#define	FRF_AB_XX_CH2_PRBS_ERR_CNT_WIDTH 8
+#define	FRF_AB_XX_CH1_PRBS_ERR_CNT_LBN 8
+#define	FRF_AB_XX_CH1_PRBS_ERR_CNT_WIDTH 8
+#define	FRF_AB_XX_CH0_PRBS_ERR_CNT_LBN 0
+#define	FRF_AB_XX_CH0_PRBS_ERR_CNT_WIDTH 8
+
+/* XX_CORE_STAT_REG: XAUI XGXS core status register */
+#define	FR_AB_XX_CORE_STAT 0x00001360
+#define	FRF_AB_XX_FORCE_SIG3_LBN 31
+#define	FRF_AB_XX_FORCE_SIG3_WIDTH 1
+#define	FRF_AB_XX_FORCE_SIG3_VAL_LBN 30
+#define	FRF_AB_XX_FORCE_SIG3_VAL_WIDTH 1
+#define	FRF_AB_XX_FORCE_SIG2_LBN 29
+#define	FRF_AB_XX_FORCE_SIG2_WIDTH 1
+#define	FRF_AB_XX_FORCE_SIG2_VAL_LBN 28
+#define	FRF_AB_XX_FORCE_SIG2_VAL_WIDTH 1
+#define	FRF_AB_XX_FORCE_SIG1_LBN 27
+#define	FRF_AB_XX_FORCE_SIG1_WIDTH 1
+#define	FRF_AB_XX_FORCE_SIG1_VAL_LBN 26
+#define	FRF_AB_XX_FORCE_SIG1_VAL_WIDTH 1
+#define	FRF_AB_XX_FORCE_SIG0_LBN 25
+#define	FRF_AB_XX_FORCE_SIG0_WIDTH 1
+#define	FRF_AB_XX_FORCE_SIG0_VAL_LBN 24
+#define	FRF_AB_XX_FORCE_SIG0_VAL_WIDTH 1
+#define	FRF_AB_XX_XGXS_LB_EN_LBN 23
+#define	FRF_AB_XX_XGXS_LB_EN_WIDTH 1
+#define	FRF_AB_XX_XGMII_LB_EN_LBN 22
+#define	FRF_AB_XX_XGMII_LB_EN_WIDTH 1
+#define	FRF_AB_XX_MATCH_FAULT_LBN 21
+#define	FRF_AB_XX_MATCH_FAULT_WIDTH 1
+#define	FRF_AB_XX_ALIGN_DONE_LBN 20
+#define	FRF_AB_XX_ALIGN_DONE_WIDTH 1
+#define	FRF_AB_XX_SYNC_STAT3_LBN 19
+#define	FRF_AB_XX_SYNC_STAT3_WIDTH 1
+#define	FRF_AB_XX_SYNC_STAT2_LBN 18
+#define	FRF_AB_XX_SYNC_STAT2_WIDTH 1
+#define	FRF_AB_XX_SYNC_STAT1_LBN 17
+#define	FRF_AB_XX_SYNC_STAT1_WIDTH 1
+#define	FRF_AB_XX_SYNC_STAT0_LBN 16
+#define	FRF_AB_XX_SYNC_STAT0_WIDTH 1
+#define	FRF_AB_XX_COMMA_DET_CH3_LBN 15
+#define	FRF_AB_XX_COMMA_DET_CH3_WIDTH 1
+#define	FRF_AB_XX_COMMA_DET_CH2_LBN 14
+#define	FRF_AB_XX_COMMA_DET_CH2_WIDTH 1
+#define	FRF_AB_XX_COMMA_DET_CH1_LBN 13
+#define	FRF_AB_XX_COMMA_DET_CH1_WIDTH 1
+#define	FRF_AB_XX_COMMA_DET_CH0_LBN 12
+#define	FRF_AB_XX_COMMA_DET_CH0_WIDTH 1
+#define	FRF_AB_XX_CGRP_ALIGN_CH3_LBN 11
+#define	FRF_AB_XX_CGRP_ALIGN_CH3_WIDTH 1
+#define	FRF_AB_XX_CGRP_ALIGN_CH2_LBN 10
+#define	FRF_AB_XX_CGRP_ALIGN_CH2_WIDTH 1
+#define	FRF_AB_XX_CGRP_ALIGN_CH1_LBN 9
+#define	FRF_AB_XX_CGRP_ALIGN_CH1_WIDTH 1
+#define	FRF_AB_XX_CGRP_ALIGN_CH0_LBN 8
+#define	FRF_AB_XX_CGRP_ALIGN_CH0_WIDTH 1
+#define	FRF_AB_XX_CHAR_ERR_CH3_LBN 7
+#define	FRF_AB_XX_CHAR_ERR_CH3_WIDTH 1
+#define	FRF_AB_XX_CHAR_ERR_CH2_LBN 6
+#define	FRF_AB_XX_CHAR_ERR_CH2_WIDTH 1
+#define	FRF_AB_XX_CHAR_ERR_CH1_LBN 5
+#define	FRF_AB_XX_CHAR_ERR_CH1_WIDTH 1
+#define	FRF_AB_XX_CHAR_ERR_CH0_LBN 4
+#define	FRF_AB_XX_CHAR_ERR_CH0_WIDTH 1
+#define	FRF_AB_XX_DISPERR_CH3_LBN 3
+#define	FRF_AB_XX_DISPERR_CH3_WIDTH 1
+#define	FRF_AB_XX_DISPERR_CH2_LBN 2
+#define	FRF_AB_XX_DISPERR_CH2_WIDTH 1
+#define	FRF_AB_XX_DISPERR_CH1_LBN 1
+#define	FRF_AB_XX_DISPERR_CH1_WIDTH 1
+#define	FRF_AB_XX_DISPERR_CH0_LBN 0
+#define	FRF_AB_XX_DISPERR_CH0_WIDTH 1
+
+/* RX_DESC_PTR_TBL_KER: Receive descriptor pointer table */
+#define	FR_AA_RX_DESC_PTR_TBL_KER 0x00011800
+#define	FR_AA_RX_DESC_PTR_TBL_KER_STEP 16
+#define	FR_AA_RX_DESC_PTR_TBL_KER_ROWS 4
+/* RX_DESC_PTR_TBL: Receive descriptor pointer table */
+#define	FR_BZ_RX_DESC_PTR_TBL 0x00f40000
+#define	FR_BZ_RX_DESC_PTR_TBL_STEP 16
+#define	FR_BB_RX_DESC_PTR_TBL_ROWS 4096
+#define	FR_CZ_RX_DESC_PTR_TBL_ROWS 1024
+#define	FRF_CZ_RX_HDR_SPLIT_LBN 90
+#define	FRF_CZ_RX_HDR_SPLIT_WIDTH 1
+#define	FRF_AA_RX_RESET_LBN 89
+#define	FRF_AA_RX_RESET_WIDTH 1
+#define	FRF_AZ_RX_ISCSI_DDIG_EN_LBN 88
+#define	FRF_AZ_RX_ISCSI_DDIG_EN_WIDTH 1
+#define	FRF_AZ_RX_ISCSI_HDIG_EN_LBN 87
+#define	FRF_AZ_RX_ISCSI_HDIG_EN_WIDTH 1
+#define	FRF_AZ_RX_DESC_PREF_ACT_LBN 86
+#define	FRF_AZ_RX_DESC_PREF_ACT_WIDTH 1
+#define	FRF_AZ_RX_DC_HW_RPTR_LBN 80
+#define	FRF_AZ_RX_DC_HW_RPTR_WIDTH 6
+#define	FRF_AZ_RX_DESCQ_HW_RPTR_LBN 68
+#define	FRF_AZ_RX_DESCQ_HW_RPTR_WIDTH 12
+#define	FRF_AZ_RX_DESCQ_SW_WPTR_LBN 56
+#define	FRF_AZ_RX_DESCQ_SW_WPTR_WIDTH 12
+#define	FRF_AZ_RX_DESCQ_BUF_BASE_ID_LBN 36
+#define	FRF_AZ_RX_DESCQ_BUF_BASE_ID_WIDTH 20
+#define	FRF_AZ_RX_DESCQ_EVQ_ID_LBN 24
+#define	FRF_AZ_RX_DESCQ_EVQ_ID_WIDTH 12
+#define	FRF_AZ_RX_DESCQ_OWNER_ID_LBN 10
+#define	FRF_AZ_RX_DESCQ_OWNER_ID_WIDTH 14
+#define	FRF_AZ_RX_DESCQ_LABEL_LBN 5
+#define	FRF_AZ_RX_DESCQ_LABEL_WIDTH 5
+#define	FRF_AZ_RX_DESCQ_SIZE_LBN 3
+#define	FRF_AZ_RX_DESCQ_SIZE_WIDTH 2
+#define	FFE_AZ_RX_DESCQ_SIZE_4K 3
+#define	FFE_AZ_RX_DESCQ_SIZE_2K 2
+#define	FFE_AZ_RX_DESCQ_SIZE_1K 1
+#define	FFE_AZ_RX_DESCQ_SIZE_512 0
+#define	FRF_AZ_RX_DESCQ_TYPE_LBN 2
+#define	FRF_AZ_RX_DESCQ_TYPE_WIDTH 1
+#define	FRF_AZ_RX_DESCQ_JUMBO_LBN 1
+#define	FRF_AZ_RX_DESCQ_JUMBO_WIDTH 1
+#define	FRF_AZ_RX_DESCQ_EN_LBN 0
+#define	FRF_AZ_RX_DESCQ_EN_WIDTH 1
+
+/* TX_DESC_PTR_TBL_KER: Transmit descriptor pointer */
+#define	FR_AA_TX_DESC_PTR_TBL_KER 0x00011900
+#define	FR_AA_TX_DESC_PTR_TBL_KER_STEP 16
+#define	FR_AA_TX_DESC_PTR_TBL_KER_ROWS 8
+/* TX_DESC_PTR_TBL: Transmit descriptor pointer */
+#define	FR_BZ_TX_DESC_PTR_TBL 0x00f50000
+#define	FR_BZ_TX_DESC_PTR_TBL_STEP 16
+#define	FR_BB_TX_DESC_PTR_TBL_ROWS 4096
+#define	FR_CZ_TX_DESC_PTR_TBL_ROWS 1024
+#define	FRF_CZ_TX_DPT_Q_MASK_WIDTH_LBN 94
+#define	FRF_CZ_TX_DPT_Q_MASK_WIDTH_WIDTH 2
+#define	FRF_CZ_TX_DPT_ETH_FILT_EN_LBN 93
+#define	FRF_CZ_TX_DPT_ETH_FILT_EN_WIDTH 1
+#define	FRF_CZ_TX_DPT_IP_FILT_EN_LBN 92
+#define	FRF_CZ_TX_DPT_IP_FILT_EN_WIDTH 1
+#define	FRF_BZ_TX_NON_IP_DROP_DIS_LBN 91
+#define	FRF_BZ_TX_NON_IP_DROP_DIS_WIDTH 1
+#define	FRF_BZ_TX_IP_CHKSM_DIS_LBN 90
+#define	FRF_BZ_TX_IP_CHKSM_DIS_WIDTH 1
+#define	FRF_BZ_TX_TCP_CHKSM_DIS_LBN 89
+#define	FRF_BZ_TX_TCP_CHKSM_DIS_WIDTH 1
+#define	FRF_AZ_TX_DESCQ_EN_LBN 88
+#define	FRF_AZ_TX_DESCQ_EN_WIDTH 1
+#define	FRF_AZ_TX_ISCSI_DDIG_EN_LBN 87
+#define	FRF_AZ_TX_ISCSI_DDIG_EN_WIDTH 1
+#define	FRF_AZ_TX_ISCSI_HDIG_EN_LBN 86
+#define	FRF_AZ_TX_ISCSI_HDIG_EN_WIDTH 1
+#define	FRF_AZ_TX_DC_HW_RPTR_LBN 80
+#define	FRF_AZ_TX_DC_HW_RPTR_WIDTH 6
+#define	FRF_AZ_TX_DESCQ_HW_RPTR_LBN 68
+#define	FRF_AZ_TX_DESCQ_HW_RPTR_WIDTH 12
+#define	FRF_AZ_TX_DESCQ_SW_WPTR_LBN 56
+#define	FRF_AZ_TX_DESCQ_SW_WPTR_WIDTH 12
+#define	FRF_AZ_TX_DESCQ_BUF_BASE_ID_LBN 36
+#define	FRF_AZ_TX_DESCQ_BUF_BASE_ID_WIDTH 20
+#define	FRF_AZ_TX_DESCQ_EVQ_ID_LBN 24
+#define	FRF_AZ_TX_DESCQ_EVQ_ID_WIDTH 12
+#define	FRF_AZ_TX_DESCQ_OWNER_ID_LBN 10
+#define	FRF_AZ_TX_DESCQ_OWNER_ID_WIDTH 14
+#define	FRF_AZ_TX_DESCQ_LABEL_LBN 5
+#define	FRF_AZ_TX_DESCQ_LABEL_WIDTH 5
+#define	FRF_AZ_TX_DESCQ_SIZE_LBN 3
+#define	FRF_AZ_TX_DESCQ_SIZE_WIDTH 2
+#define	FFE_AZ_TX_DESCQ_SIZE_4K 3
+#define	FFE_AZ_TX_DESCQ_SIZE_2K 2
+#define	FFE_AZ_TX_DESCQ_SIZE_1K 1
+#define	FFE_AZ_TX_DESCQ_SIZE_512 0
+#define	FRF_AZ_TX_DESCQ_TYPE_LBN 1
+#define	FRF_AZ_TX_DESCQ_TYPE_WIDTH 2
+#define	FRF_AZ_TX_DESCQ_FLUSH_LBN 0
+#define	FRF_AZ_TX_DESCQ_FLUSH_WIDTH 1
+
+/* EVQ_PTR_TBL_KER: Event queue pointer table */
+#define	FR_AA_EVQ_PTR_TBL_KER 0x00011a00
+#define	FR_AA_EVQ_PTR_TBL_KER_STEP 16
+#define	FR_AA_EVQ_PTR_TBL_KER_ROWS 4
+/* EVQ_PTR_TBL: Event queue pointer table */
+#define	FR_BZ_EVQ_PTR_TBL 0x00f60000
+#define	FR_BZ_EVQ_PTR_TBL_STEP 16
+#define	FR_CZ_EVQ_PTR_TBL_ROWS 1024
+#define	FR_BB_EVQ_PTR_TBL_ROWS 4096
+#define	FRF_BZ_EVQ_RPTR_IGN_LBN 40
+#define	FRF_BZ_EVQ_RPTR_IGN_WIDTH 1
+#define	FRF_AB_EVQ_WKUP_OR_INT_EN_LBN 39
+#define	FRF_AB_EVQ_WKUP_OR_INT_EN_WIDTH 1
+#define	FRF_CZ_EVQ_DOS_PROTECT_EN_LBN 39
+#define	FRF_CZ_EVQ_DOS_PROTECT_EN_WIDTH 1
+#define	FRF_AZ_EVQ_NXT_WPTR_LBN 24
+#define	FRF_AZ_EVQ_NXT_WPTR_WIDTH 15
+#define	FRF_AZ_EVQ_EN_LBN 23
+#define	FRF_AZ_EVQ_EN_WIDTH 1
+#define	FRF_AZ_EVQ_SIZE_LBN 20
+#define	FRF_AZ_EVQ_SIZE_WIDTH 3
+#define	FFE_AZ_EVQ_SIZE_32K 6
+#define	FFE_AZ_EVQ_SIZE_16K 5
+#define	FFE_AZ_EVQ_SIZE_8K 4
+#define	FFE_AZ_EVQ_SIZE_4K 3
+#define	FFE_AZ_EVQ_SIZE_2K 2
+#define	FFE_AZ_EVQ_SIZE_1K 1
+#define	FFE_AZ_EVQ_SIZE_512 0
+#define	FRF_AZ_EVQ_BUF_BASE_ID_LBN 0
+#define	FRF_AZ_EVQ_BUF_BASE_ID_WIDTH 20
+
+/* BUF_HALF_TBL_KER: Buffer table in half buffer table mode direct access by driver */
+#define	FR_AA_BUF_HALF_TBL_KER 0x00018000
+#define	FR_AA_BUF_HALF_TBL_KER_STEP 8
+#define	FR_AA_BUF_HALF_TBL_KER_ROWS 4096
+/* BUF_HALF_TBL: Buffer table in half buffer table mode direct access by driver */
+#define	FR_BZ_BUF_HALF_TBL 0x00800000
+#define	FR_BZ_BUF_HALF_TBL_STEP 8
+#define	FR_CZ_BUF_HALF_TBL_ROWS 147456
+#define	FR_BB_BUF_HALF_TBL_ROWS 524288
+#define	FRF_AZ_BUF_ADR_HBUF_ODD_LBN 44
+#define	FRF_AZ_BUF_ADR_HBUF_ODD_WIDTH 20
+#define	FRF_AZ_BUF_OWNER_ID_HBUF_ODD_LBN 32
+#define	FRF_AZ_BUF_OWNER_ID_HBUF_ODD_WIDTH 12
+#define	FRF_AZ_BUF_ADR_HBUF_EVEN_LBN 12
+#define	FRF_AZ_BUF_ADR_HBUF_EVEN_WIDTH 20
+#define	FRF_AZ_BUF_OWNER_ID_HBUF_EVEN_LBN 0
+#define	FRF_AZ_BUF_OWNER_ID_HBUF_EVEN_WIDTH 12
+
+/* BUF_FULL_TBL_KER: Buffer table in full buffer table mode direct access by driver */
+#define	FR_AA_BUF_FULL_TBL_KER 0x00018000
+#define	FR_AA_BUF_FULL_TBL_KER_STEP 8
+#define	FR_AA_BUF_FULL_TBL_KER_ROWS 4096
+/* BUF_FULL_TBL: Buffer table in full buffer table mode direct access by driver */
+#define	FR_BZ_BUF_FULL_TBL 0x00800000
+#define	FR_BZ_BUF_FULL_TBL_STEP 8
+#define	FR_CZ_BUF_FULL_TBL_ROWS 147456
+#define	FR_BB_BUF_FULL_TBL_ROWS 917504
+#define	FRF_AZ_BUF_FULL_UNUSED_LBN 51
+#define	FRF_AZ_BUF_FULL_UNUSED_WIDTH 13
+#define	FRF_AZ_IP_DAT_BUF_SIZE_LBN 50
+#define	FRF_AZ_IP_DAT_BUF_SIZE_WIDTH 1
+#define	FRF_AZ_BUF_ADR_REGION_LBN 48
+#define	FRF_AZ_BUF_ADR_REGION_WIDTH 2
+#define	FFE_AZ_BUF_ADR_REGN3 3
+#define	FFE_AZ_BUF_ADR_REGN2 2
+#define	FFE_AZ_BUF_ADR_REGN1 1
+#define	FFE_AZ_BUF_ADR_REGN0 0
+#define	FRF_AZ_BUF_ADR_FBUF_LBN 14
+#define	FRF_AZ_BUF_ADR_FBUF_WIDTH 34
+#define	FRF_AZ_BUF_OWNER_ID_FBUF_LBN 0
+#define	FRF_AZ_BUF_OWNER_ID_FBUF_WIDTH 14
+
+/* RX_FILTER_TBL0: TCP/IPv4 Receive filter table */
+#define	FR_BZ_RX_FILTER_TBL0 0x00f00000
+#define	FR_BZ_RX_FILTER_TBL0_STEP 32
+#define	FR_BZ_RX_FILTER_TBL0_ROWS 8192
+/* RX_FILTER_TBL1: TCP/IPv4 Receive filter table */
+#define	FR_BB_RX_FILTER_TBL1 0x00f00010
+#define	FR_BB_RX_FILTER_TBL1_STEP 32
+#define	FR_BB_RX_FILTER_TBL1_ROWS 8192
+#define	FRF_BZ_RSS_EN_LBN 110
+#define	FRF_BZ_RSS_EN_WIDTH 1
+#define	FRF_BZ_SCATTER_EN_LBN 109
+#define	FRF_BZ_SCATTER_EN_WIDTH 1
+#define	FRF_BZ_TCP_UDP_LBN 108
+#define	FRF_BZ_TCP_UDP_WIDTH 1
+#define	FRF_BZ_RXQ_ID_LBN 96
+#define	FRF_BZ_RXQ_ID_WIDTH 12
+#define	FRF_BZ_DEST_IP_LBN 64
+#define	FRF_BZ_DEST_IP_WIDTH 32
+#define	FRF_BZ_DEST_PORT_TCP_LBN 48
+#define	FRF_BZ_DEST_PORT_TCP_WIDTH 16
+#define	FRF_BZ_SRC_IP_LBN 16
+#define	FRF_BZ_SRC_IP_WIDTH 32
+#define	FRF_BZ_SRC_TCP_DEST_UDP_LBN 0
+#define	FRF_BZ_SRC_TCP_DEST_UDP_WIDTH 16
+
+/* RX_MAC_FILTER_TBL0: Receive Ethernet filter table */
+#define	FR_CZ_RX_MAC_FILTER_TBL0 0x00f00010
+#define	FR_CZ_RX_MAC_FILTER_TBL0_STEP 32
+#define	FR_CZ_RX_MAC_FILTER_TBL0_ROWS 512
+#define	FRF_CZ_RMFT_RSS_EN_LBN 75
+#define	FRF_CZ_RMFT_RSS_EN_WIDTH 1
+#define	FRF_CZ_RMFT_SCATTER_EN_LBN 74
+#define	FRF_CZ_RMFT_SCATTER_EN_WIDTH 1
+#define	FRF_CZ_RMFT_IP_OVERRIDE_LBN 73
+#define	FRF_CZ_RMFT_IP_OVERRIDE_WIDTH 1
+#define	FRF_CZ_RMFT_RXQ_ID_LBN 61
+#define	FRF_CZ_RMFT_RXQ_ID_WIDTH 12
+#define	FRF_CZ_RMFT_WILDCARD_MATCH_LBN 60
+#define	FRF_CZ_RMFT_WILDCARD_MATCH_WIDTH 1
+#define	FRF_CZ_RMFT_DEST_MAC_LBN 12
+#define	FRF_CZ_RMFT_DEST_MAC_WIDTH 48
+#define	FRF_CZ_RMFT_VLAN_ID_LBN 0
+#define	FRF_CZ_RMFT_VLAN_ID_WIDTH 12
+
+/* TIMER_TBL: Timer table */
+#define	FR_BZ_TIMER_TBL 0x00f70000
+#define	FR_BZ_TIMER_TBL_STEP 16
+#define	FR_CZ_TIMER_TBL_ROWS 1024
+#define	FR_BB_TIMER_TBL_ROWS 4096
+#define	FRF_CZ_TIMER_Q_EN_LBN 33
+#define	FRF_CZ_TIMER_Q_EN_WIDTH 1
+#define	FRF_CZ_INT_ARMD_LBN 32
+#define	FRF_CZ_INT_ARMD_WIDTH 1
+#define	FRF_CZ_INT_PEND_LBN 31
+#define	FRF_CZ_INT_PEND_WIDTH 1
+#define	FRF_CZ_HOST_NOTIFY_MODE_LBN 30
+#define	FRF_CZ_HOST_NOTIFY_MODE_WIDTH 1
+#define	FRF_CZ_RELOAD_TIMER_VAL_LBN 16
+#define	FRF_CZ_RELOAD_TIMER_VAL_WIDTH 14
+#define	FRF_CZ_TIMER_MODE_LBN 14
+#define	FRF_CZ_TIMER_MODE_WIDTH 2
+#define	FFE_CZ_TIMER_MODE_INT_HLDOFF 3
+#define	FFE_CZ_TIMER_MODE_TRIG_START 2
+#define	FFE_CZ_TIMER_MODE_IMMED_START 1
+#define	FFE_CZ_TIMER_MODE_DIS 0
+#define	FRF_BB_TIMER_MODE_LBN 12
+#define	FRF_BB_TIMER_MODE_WIDTH 2
+#define	FFE_BB_TIMER_MODE_INT_HLDOFF 2
+#define	FFE_BB_TIMER_MODE_TRIG_START 2
+#define	FFE_BB_TIMER_MODE_IMMED_START 1
+#define	FFE_BB_TIMER_MODE_DIS 0
+#define	FRF_CZ_TIMER_VAL_LBN 0
+#define	FRF_CZ_TIMER_VAL_WIDTH 14
+#define	FRF_BB_TIMER_VAL_LBN 0
+#define	FRF_BB_TIMER_VAL_WIDTH 12
+
+/* TX_PACE_TBL: Transmit pacing table */
+#define	FR_BZ_TX_PACE_TBL 0x00f80000
+#define	FR_BZ_TX_PACE_TBL_STEP 16
+#define	FR_CZ_TX_PACE_TBL_ROWS 1024
+#define	FR_BB_TX_PACE_TBL_ROWS 4096
+#define	FRF_BZ_TX_PACE_LBN 0
+#define	FRF_BZ_TX_PACE_WIDTH 5
+
+/* RX_INDIRECTION_TBL: RX Indirection Table */
+#define	FR_BZ_RX_INDIRECTION_TBL 0x00fb0000
+#define	FR_BZ_RX_INDIRECTION_TBL_STEP 16
+#define	FR_BZ_RX_INDIRECTION_TBL_ROWS 128
+#define	FRF_BZ_IT_QUEUE_LBN 0
+#define	FRF_BZ_IT_QUEUE_WIDTH 6
+
+/* TX_FILTER_TBL0: TCP/IPv4 Transmit filter table */
+#define	FR_CZ_TX_FILTER_TBL0 0x00fc0000
+#define	FR_CZ_TX_FILTER_TBL0_STEP 16
+#define	FR_CZ_TX_FILTER_TBL0_ROWS 8192
+#define	FRF_CZ_TIFT_TCP_UDP_LBN 108
+#define	FRF_CZ_TIFT_TCP_UDP_WIDTH 1
+#define	FRF_CZ_TIFT_TXQ_ID_LBN 96
+#define	FRF_CZ_TIFT_TXQ_ID_WIDTH 12
+#define	FRF_CZ_TIFT_DEST_IP_LBN 64
+#define	FRF_CZ_TIFT_DEST_IP_WIDTH 32
+#define	FRF_CZ_TIFT_DEST_PORT_TCP_LBN 48
+#define	FRF_CZ_TIFT_DEST_PORT_TCP_WIDTH 16
+#define	FRF_CZ_TIFT_SRC_IP_LBN 16
+#define	FRF_CZ_TIFT_SRC_IP_WIDTH 32
+#define	FRF_CZ_TIFT_SRC_TCP_DEST_UDP_LBN 0
+#define	FRF_CZ_TIFT_SRC_TCP_DEST_UDP_WIDTH 16
+
+/* TX_MAC_FILTER_TBL0: Transmit Ethernet filter table */
+#define	FR_CZ_TX_MAC_FILTER_TBL0 0x00fe0000
+#define	FR_CZ_TX_MAC_FILTER_TBL0_STEP 16
+#define	FR_CZ_TX_MAC_FILTER_TBL0_ROWS 512
+#define	FRF_CZ_TMFT_TXQ_ID_LBN 61
+#define	FRF_CZ_TMFT_TXQ_ID_WIDTH 12
+#define	FRF_CZ_TMFT_WILDCARD_MATCH_LBN 60
+#define	FRF_CZ_TMFT_WILDCARD_MATCH_WIDTH 1
+#define	FRF_CZ_TMFT_SRC_MAC_LBN 12
+#define	FRF_CZ_TMFT_SRC_MAC_WIDTH 48
+#define	FRF_CZ_TMFT_VLAN_ID_LBN 0
+#define	FRF_CZ_TMFT_VLAN_ID_WIDTH 12
+
+/* MC_TREG_SMEM: MC Shared Memory */
+#define	FR_CZ_MC_TREG_SMEM 0x00ff0000
+#define	FR_CZ_MC_TREG_SMEM_STEP 4
+#define	FR_CZ_MC_TREG_SMEM_ROWS 512
+#define	FRF_CZ_MC_TREG_SMEM_ROW_LBN 0
+#define	FRF_CZ_MC_TREG_SMEM_ROW_WIDTH 32
+
+/* MSIX_VECTOR_TABLE: MSIX Vector Table */
+#define	FR_BB_MSIX_VECTOR_TABLE 0x00ff0000
+#define	FR_BZ_MSIX_VECTOR_TABLE_STEP 16
+#define	FR_BB_MSIX_VECTOR_TABLE_ROWS 64
+/* MSIX_VECTOR_TABLE: MSIX Vector Table */
+#define	FR_CZ_MSIX_VECTOR_TABLE 0x00000000
+/* FR_BZ_MSIX_VECTOR_TABLE_STEP 16 */
+#define	FR_CZ_MSIX_VECTOR_TABLE_ROWS 1024
+#define	FRF_BZ_MSIX_VECTOR_RESERVED_LBN 97
+#define	FRF_BZ_MSIX_VECTOR_RESERVED_WIDTH 31
+#define	FRF_BZ_MSIX_VECTOR_MASK_LBN 96
+#define	FRF_BZ_MSIX_VECTOR_MASK_WIDTH 1
+#define	FRF_BZ_MSIX_MESSAGE_DATA_LBN 64
+#define	FRF_BZ_MSIX_MESSAGE_DATA_WIDTH 32
+#define	FRF_BZ_MSIX_MESSAGE_ADDRESS_HI_LBN 32
+#define	FRF_BZ_MSIX_MESSAGE_ADDRESS_HI_WIDTH 32
+#define	FRF_BZ_MSIX_MESSAGE_ADDRESS_LO_LBN 0
+#define	FRF_BZ_MSIX_MESSAGE_ADDRESS_LO_WIDTH 32
+
+/* MSIX_PBA_TABLE: MSIX Pending Bit Array */
+#define	FR_BB_MSIX_PBA_TABLE 0x00ff2000
+#define	FR_BZ_MSIX_PBA_TABLE_STEP 4
+#define	FR_BB_MSIX_PBA_TABLE_ROWS 2
+/* MSIX_PBA_TABLE: MSIX Pending Bit Array */
+#define	FR_CZ_MSIX_PBA_TABLE 0x00008000
+/* FR_BZ_MSIX_PBA_TABLE_STEP 4 */
+#define	FR_CZ_MSIX_PBA_TABLE_ROWS 32
+#define	FRF_BZ_MSIX_PBA_PEND_DWORD_LBN 0
+#define	FRF_BZ_MSIX_PBA_PEND_DWORD_WIDTH 32
+
+/* SRM_DBG_REG: SRAM debug access */
+#define	FR_BZ_SRM_DBG 0x03000000
+#define	FR_BZ_SRM_DBG_STEP 8
+#define	FR_CZ_SRM_DBG_ROWS 262144
+#define	FR_BB_SRM_DBG_ROWS 2097152
+#define	FRF_BZ_SRM_DBG_LBN 0
+#define	FRF_BZ_SRM_DBG_WIDTH 64
+
+/* TB_MSIX_PBA_TABLE: MSIX Pending Bit Array */
+#define	FR_CZ_TB_MSIX_PBA_TABLE 0x00008000
+#define	FR_CZ_TB_MSIX_PBA_TABLE_STEP 4
+#define	FR_CZ_TB_MSIX_PBA_TABLE_ROWS 1024
+#define	FRF_CZ_TB_MSIX_PBA_PEND_DWORD_LBN 0
+#define	FRF_CZ_TB_MSIX_PBA_PEND_DWORD_WIDTH 32
+
+/* DRIVER_EV */
+#define	FSF_AZ_DRIVER_EV_SUBCODE_LBN 56
+#define	FSF_AZ_DRIVER_EV_SUBCODE_WIDTH 4
+#define	FSE_BZ_TX_DSC_ERROR_EV 15
+#define	FSE_BZ_RX_DSC_ERROR_EV 14
+#define	FSE_AA_RX_RECOVER_EV 11
+#define	FSE_AZ_TIMER_EV 10
+#define	FSE_AZ_TX_PKT_NON_TCP_UDP 9
+#define	FSE_AZ_WAKE_UP_EV 6
+#define	FSE_AZ_SRM_UPD_DONE_EV 5
+#define	FSE_AB_EVQ_NOT_EN_EV 3
+#define	FSE_AZ_EVQ_INIT_DONE_EV 2
+#define	FSE_AZ_RX_DESCQ_FLS_DONE_EV 1
+#define	FSE_AZ_TX_DESCQ_FLS_DONE_EV 0
+#define	FSF_AZ_DRIVER_EV_SUBDATA_LBN 0
+#define	FSF_AZ_DRIVER_EV_SUBDATA_WIDTH 14
+
+/* EVENT_ENTRY */
+#define	FSF_AZ_EV_CODE_LBN 60
+#define	FSF_AZ_EV_CODE_WIDTH 4
+#define	FSE_CZ_EV_CODE_MCDI_EV 12
+#define	FSE_CZ_EV_CODE_USER_EV 8
+#define	FSE_AZ_EV_CODE_DRV_GEN_EV 7
+#define	FSE_AZ_EV_CODE_GLOBAL_EV 6
+#define	FSE_AZ_EV_CODE_DRIVER_EV 5
+#define	FSE_AZ_EV_CODE_TX_EV 2
+#define	FSE_AZ_EV_CODE_RX_EV 0
+#define	FSF_AZ_EV_DATA_LBN 0
+#define	FSF_AZ_EV_DATA_WIDTH 60
+
+/* GLOBAL_EV */
+#define	FSF_BB_GLB_EV_RX_RECOVERY_LBN 12
+#define	FSF_BB_GLB_EV_RX_RECOVERY_WIDTH 1
+#define	FSF_AA_GLB_EV_RX_RECOVERY_LBN 11
+#define	FSF_AA_GLB_EV_RX_RECOVERY_WIDTH 1
+#define	FSF_BB_GLB_EV_XG_MGT_INTR_LBN 11
+#define	FSF_BB_GLB_EV_XG_MGT_INTR_WIDTH 1
+#define	FSF_AB_GLB_EV_XFP_PHY0_INTR_LBN 10
+#define	FSF_AB_GLB_EV_XFP_PHY0_INTR_WIDTH 1
+#define	FSF_AB_GLB_EV_XG_PHY0_INTR_LBN 9
+#define	FSF_AB_GLB_EV_XG_PHY0_INTR_WIDTH 1
+#define	FSF_AB_GLB_EV_G_PHY0_INTR_LBN 7
+#define	FSF_AB_GLB_EV_G_PHY0_INTR_WIDTH 1
+
+/* LEGACY_INT_VEC */
+#define	FSF_AZ_NET_IVEC_FATAL_INT_LBN 64
+#define	FSF_AZ_NET_IVEC_FATAL_INT_WIDTH 1
+#define	FSF_AZ_NET_IVEC_INT_Q_LBN 40
+#define	FSF_AZ_NET_IVEC_INT_Q_WIDTH 4
+#define	FSF_AZ_NET_IVEC_INT_FLAG_LBN 32
+#define	FSF_AZ_NET_IVEC_INT_FLAG_WIDTH 1
+#define	FSF_AZ_NET_IVEC_EVQ_FIFO_HF_LBN 1
+#define	FSF_AZ_NET_IVEC_EVQ_FIFO_HF_WIDTH 1
+#define	FSF_AZ_NET_IVEC_EVQ_FIFO_AF_LBN 0
+#define	FSF_AZ_NET_IVEC_EVQ_FIFO_AF_WIDTH 1
+
+/* MC_XGMAC_FLTR_RULE_DEF */
+#define	FSF_CZ_MC_XFRC_MODE_LBN 416
+#define	FSF_CZ_MC_XFRC_MODE_WIDTH 1
+#define	FSE_CZ_MC_XFRC_MODE_LAYERED 1
+#define	FSE_CZ_MC_XFRC_MODE_SIMPLE 0
+#define	FSF_CZ_MC_XFRC_HASH_LBN 384
+#define	FSF_CZ_MC_XFRC_HASH_WIDTH 32
+#define	FSF_CZ_MC_XFRC_LAYER4_BYTE_MASK_LBN 256
+#define	FSF_CZ_MC_XFRC_LAYER4_BYTE_MASK_WIDTH 128
+#define	FSF_CZ_MC_XFRC_LAYER3_BYTE_MASK_LBN 128
+#define	FSF_CZ_MC_XFRC_LAYER3_BYTE_MASK_WIDTH 128
+#define	FSF_CZ_MC_XFRC_LAYER2_OR_SIMPLE_BYTE_MASK_LBN 0
+#define	FSF_CZ_MC_XFRC_LAYER2_OR_SIMPLE_BYTE_MASK_WIDTH 128
+
+/* RX_EV */
+#define	FSF_CZ_RX_EV_PKT_NOT_PARSED_LBN 58
+#define	FSF_CZ_RX_EV_PKT_NOT_PARSED_WIDTH 1
+#define	FSF_CZ_RX_EV_IPV6_PKT_LBN 57
+#define	FSF_CZ_RX_EV_IPV6_PKT_WIDTH 1
+#define	FSF_AZ_RX_EV_PKT_OK_LBN 56
+#define	FSF_AZ_RX_EV_PKT_OK_WIDTH 1
+#define	FSF_AZ_RX_EV_PAUSE_FRM_ERR_LBN 55
+#define	FSF_AZ_RX_EV_PAUSE_FRM_ERR_WIDTH 1
+#define	FSF_AZ_RX_EV_BUF_OWNER_ID_ERR_LBN 54
+#define	FSF_AZ_RX_EV_BUF_OWNER_ID_ERR_WIDTH 1
+#define	FSF_AZ_RX_EV_IP_FRAG_ERR_LBN 53
+#define	FSF_AZ_RX_EV_IP_FRAG_ERR_WIDTH 1
+#define	FSF_AZ_RX_EV_IP_HDR_CHKSUM_ERR_LBN 52
+#define	FSF_AZ_RX_EV_IP_HDR_CHKSUM_ERR_WIDTH 1
+#define	FSF_AZ_RX_EV_TCP_UDP_CHKSUM_ERR_LBN 51
+#define	FSF_AZ_RX_EV_TCP_UDP_CHKSUM_ERR_WIDTH 1
+#define	FSF_AZ_RX_EV_ETH_CRC_ERR_LBN 50
+#define	FSF_AZ_RX_EV_ETH_CRC_ERR_WIDTH 1
+#define	FSF_AZ_RX_EV_FRM_TRUNC_LBN 49
+#define	FSF_AZ_RX_EV_FRM_TRUNC_WIDTH 1
+#define	FSF_AA_RX_EV_DRIB_NIB_LBN 49
+#define	FSF_AA_RX_EV_DRIB_NIB_WIDTH 1
+#define	FSF_AZ_RX_EV_TOBE_DISC_LBN 47
+#define	FSF_AZ_RX_EV_TOBE_DISC_WIDTH 1
+#define	FSF_AZ_RX_EV_PKT_TYPE_LBN 44
+#define	FSF_AZ_RX_EV_PKT_TYPE_WIDTH 3
+#define	FSE_AZ_RX_EV_PKT_TYPE_VLAN_JUMBO 5
+#define	FSE_AZ_RX_EV_PKT_TYPE_VLAN_LLC 4
+#define	FSE_AZ_RX_EV_PKT_TYPE_VLAN 3
+#define	FSE_AZ_RX_EV_PKT_TYPE_JUMBO 2
+#define	FSE_AZ_RX_EV_PKT_TYPE_LLC 1
+#define	FSE_AZ_RX_EV_PKT_TYPE_ETH 0
+#define	FSF_AZ_RX_EV_HDR_TYPE_LBN 42
+#define	FSF_AZ_RX_EV_HDR_TYPE_WIDTH 2
+#define	FSE_AZ_RX_EV_HDR_TYPE_OTHER 3
+#define	FSE_AB_RX_EV_HDR_TYPE_IPV4_OTHER 2
+#define	FSE_CZ_RX_EV_HDR_TYPE_IPV4V6_OTHER 2
+#define	FSE_AB_RX_EV_HDR_TYPE_IPV4_UDP 1
+#define	FSE_CZ_RX_EV_HDR_TYPE_IPV4V6_UDP 1
+#define	FSE_AB_RX_EV_HDR_TYPE_IPV4_TCP 0
+#define	FSE_CZ_RX_EV_HDR_TYPE_IPV4V6_TCP 0
+#define	FSF_AZ_RX_EV_DESC_Q_EMPTY_LBN 41
+#define	FSF_AZ_RX_EV_DESC_Q_EMPTY_WIDTH 1
+#define	FSF_AZ_RX_EV_MCAST_HASH_MATCH_LBN 40
+#define	FSF_AZ_RX_EV_MCAST_HASH_MATCH_WIDTH 1
+#define	FSF_AZ_RX_EV_MCAST_PKT_LBN 39
+#define	FSF_AZ_RX_EV_MCAST_PKT_WIDTH 1
+#define	FSF_AA_RX_EV_RECOVERY_FLAG_LBN 37
+#define	FSF_AA_RX_EV_RECOVERY_FLAG_WIDTH 1
+#define	FSF_AZ_RX_EV_Q_LABEL_LBN 32
+#define	FSF_AZ_RX_EV_Q_LABEL_WIDTH 5
+#define	FSF_AZ_RX_EV_JUMBO_CONT_LBN 31
+#define	FSF_AZ_RX_EV_JUMBO_CONT_WIDTH 1
+#define	FSF_AZ_RX_EV_PORT_LBN 30
+#define	FSF_AZ_RX_EV_PORT_WIDTH 1
+#define	FSF_AZ_RX_EV_BYTE_CNT_LBN 16
+#define	FSF_AZ_RX_EV_BYTE_CNT_WIDTH 14
+#define	FSF_AZ_RX_EV_SOP_LBN 15
+#define	FSF_AZ_RX_EV_SOP_WIDTH 1
+#define	FSF_AZ_RX_EV_ISCSI_PKT_OK_LBN 14
+#define	FSF_AZ_RX_EV_ISCSI_PKT_OK_WIDTH 1
+#define	FSF_AZ_RX_EV_ISCSI_DDIG_ERR_LBN 13
+#define	FSF_AZ_RX_EV_ISCSI_DDIG_ERR_WIDTH 1
+#define	FSF_AZ_RX_EV_ISCSI_HDIG_ERR_LBN 12
+#define	FSF_AZ_RX_EV_ISCSI_HDIG_ERR_WIDTH 1
+#define	FSF_AZ_RX_EV_DESC_PTR_LBN 0
+#define	FSF_AZ_RX_EV_DESC_PTR_WIDTH 12
+
+/* RX_KER_DESC */
+#define	FSF_AZ_RX_KER_BUF_SIZE_LBN 48
+#define	FSF_AZ_RX_KER_BUF_SIZE_WIDTH 14
+#define	FSF_AZ_RX_KER_BUF_REGION_LBN 46
+#define	FSF_AZ_RX_KER_BUF_REGION_WIDTH 2
+#define	FSF_AZ_RX_KER_BUF_ADDR_LBN 0
+#define	FSF_AZ_RX_KER_BUF_ADDR_WIDTH 46
+
+/* RX_USER_DESC */
+#define	FSF_AZ_RX_USER_2BYTE_OFFSET_LBN 20
+#define	FSF_AZ_RX_USER_2BYTE_OFFSET_WIDTH 12
+#define	FSF_AZ_RX_USER_BUF_ID_LBN 0
+#define	FSF_AZ_RX_USER_BUF_ID_WIDTH 20
+
+/* TX_EV */
+#define	FSF_AZ_TX_EV_PKT_ERR_LBN 38
+#define	FSF_AZ_TX_EV_PKT_ERR_WIDTH 1
+#define	FSF_AZ_TX_EV_PKT_TOO_BIG_LBN 37
+#define	FSF_AZ_TX_EV_PKT_TOO_BIG_WIDTH 1
+#define	FSF_AZ_TX_EV_Q_LABEL_LBN 32
+#define	FSF_AZ_TX_EV_Q_LABEL_WIDTH 5
+#define	FSF_AZ_TX_EV_PORT_LBN 16
+#define	FSF_AZ_TX_EV_PORT_WIDTH 1
+#define	FSF_AZ_TX_EV_WQ_FF_FULL_LBN 15
+#define	FSF_AZ_TX_EV_WQ_FF_FULL_WIDTH 1
+#define	FSF_AZ_TX_EV_BUF_OWNER_ID_ERR_LBN 14
+#define	FSF_AZ_TX_EV_BUF_OWNER_ID_ERR_WIDTH 1
+#define	FSF_AZ_TX_EV_COMP_LBN 12
+#define	FSF_AZ_TX_EV_COMP_WIDTH 1
+#define	FSF_AZ_TX_EV_DESC_PTR_LBN 0
+#define	FSF_AZ_TX_EV_DESC_PTR_WIDTH 12
+
+/* TX_KER_DESC */
+#define	FSF_AZ_TX_KER_CONT_LBN 62
+#define	FSF_AZ_TX_KER_CONT_WIDTH 1
+#define	FSF_AZ_TX_KER_BYTE_COUNT_LBN 48
+#define	FSF_AZ_TX_KER_BYTE_COUNT_WIDTH 14
+#define	FSF_AZ_TX_KER_BUF_REGION_LBN 46
+#define	FSF_AZ_TX_KER_BUF_REGION_WIDTH 2
+#define	FSF_AZ_TX_KER_BUF_ADDR_LBN 0
+#define	FSF_AZ_TX_KER_BUF_ADDR_WIDTH 46
+
+/* TX_USER_DESC */
+#define	FSF_AZ_TX_USER_SW_EV_EN_LBN 48
+#define	FSF_AZ_TX_USER_SW_EV_EN_WIDTH 1
+#define	FSF_AZ_TX_USER_CONT_LBN 46
+#define	FSF_AZ_TX_USER_CONT_WIDTH 1
+#define	FSF_AZ_TX_USER_BYTE_CNT_LBN 33
+#define	FSF_AZ_TX_USER_BYTE_CNT_WIDTH 13
+#define	FSF_AZ_TX_USER_BUF_ID_LBN 13
+#define	FSF_AZ_TX_USER_BUF_ID_WIDTH 20
+#define	FSF_AZ_TX_USER_BYTE_OFS_LBN 0
+#define	FSF_AZ_TX_USER_BYTE_OFS_WIDTH 13
+
+/* USER_EV */
+#define	FSF_CZ_USER_QID_LBN 32
+#define	FSF_CZ_USER_QID_WIDTH 10
+#define	FSF_CZ_USER_EV_REG_VALUE_LBN 0
+#define	FSF_CZ_USER_EV_REG_VALUE_WIDTH 32
+
+/**************************************************************************
+ *
+ * Falcon B0 PCIe core indirect registers
+ *
+ **************************************************************************
+ */
+
+#define FPCR_BB_PCIE_DEVICE_CTRL_STAT 0x68
+
+#define FPCR_BB_PCIE_LINK_CTRL_STAT 0x70
+
+#define FPCR_BB_ACK_RPL_TIMER 0x700
+#define FPCRF_BB_ACK_TL_LBN 0
+#define FPCRF_BB_ACK_TL_WIDTH 16
+#define FPCRF_BB_RPL_TL_LBN 16
+#define FPCRF_BB_RPL_TL_WIDTH 16
+
+#define FPCR_BB_ACK_FREQ 0x70C
+#define FPCRF_BB_ACK_FREQ_LBN 0
+#define FPCRF_BB_ACK_FREQ_WIDTH 7
+
+/**************************************************************************
+ *
+ * Pseudo-registers and fields
+ *
+ **************************************************************************
+ */
+
+/* Interrupt acknowledge work-around register (A0/A1 only) */
+#define FR_AA_WORK_AROUND_BROKEN_PCI_READS 0x0070
+
+/* EE_SPI_HCMD_REG: SPI host command register */
+/* Values for the EE_SPI_HCMD_SF_SEL register field */
+#define FFE_AB_SPI_DEVICE_EEPROM 0
+#define FFE_AB_SPI_DEVICE_FLASH 1
+
+/* NIC_STAT_REG: NIC status register */
+#define FRF_AB_STRAP_10G_LBN 2
+#define FRF_AB_STRAP_10G_WIDTH 1
+#define FRF_AA_STRAP_PCIE_LBN 0
+#define FRF_AA_STRAP_PCIE_WIDTH 1
+
+/* FATAL_INTR_REG_KER: Fatal interrupt register for Kernel */
+#define FRF_AZ_FATAL_INTR_LBN 0
+#define FRF_AZ_FATAL_INTR_WIDTH 12
+
+/* SRM_CFG_REG: SRAM configuration register */
+/* We treat the number of SRAM banks and bank size as a single field */
+#define	FRF_AZ_SRM_NB_SZ_LBN FRF_AZ_SRM_BANK_SIZE_LBN
+#define	FRF_AZ_SRM_NB_SZ_WIDTH \
+	(FRF_AZ_SRM_BANK_SIZE_WIDTH + FRF_AZ_SRM_NUM_BANK_WIDTH)
+#define FFE_AB_SRM_NB1_SZ2M 0
+#define FFE_AB_SRM_NB1_SZ4M 1
+#define FFE_AB_SRM_NB1_SZ8M 2
+#define FFE_AB_SRM_NB_SZ_DEF 3
+#define FFE_AB_SRM_NB2_SZ4M 4
+#define FFE_AB_SRM_NB2_SZ8M 5
+#define FFE_AB_SRM_NB2_SZ16M 6
+#define FFE_AB_SRM_NB_SZ_RES 7
+
+/* RX_DESC_UPD_REGP0: Receive descriptor update register. */
+/* We write just the last dword of these registers */
+#define	FR_AZ_RX_DESC_UPD_DWORD_P0 \
+	(BUILD_BUG_ON_ZERO(FR_AA_RX_DESC_UPD_KER != FR_BZ_RX_DESC_UPD_P0) + \
+	 FR_BZ_RX_DESC_UPD_P0 + 3 * 4)
+#define	FRF_AZ_RX_DESC_WPTR_DWORD_LBN (FRF_AZ_RX_DESC_WPTR_LBN - 3 * 32)
+#define	FRF_AZ_RX_DESC_WPTR_DWORD_WIDTH FRF_AZ_RX_DESC_WPTR_WIDTH
+
+/* TX_DESC_UPD_REGP0: Transmit descriptor update register. */
+#define FR_AZ_TX_DESC_UPD_DWORD_P0 \
+	(BUILD_BUG_ON_ZERO(FR_AA_TX_DESC_UPD_KER != FR_BZ_TX_DESC_UPD_P0) + \
+	 FR_BZ_TX_DESC_UPD_P0 + 3 * 4)
+#define	FRF_AZ_TX_DESC_WPTR_DWORD_LBN (FRF_AZ_TX_DESC_WPTR_LBN - 3 * 32)
+#define	FRF_AZ_TX_DESC_WPTR_DWORD_WIDTH FRF_AZ_TX_DESC_WPTR_WIDTH
+
+/* GMF_CFG4_REG: GMAC FIFO configuration register 4 */
+#define FRF_AB_GMF_HSTFLTRFRM_PAUSE_LBN 12
+#define FRF_AB_GMF_HSTFLTRFRM_PAUSE_WIDTH 1
+
+/* GMF_CFG5_REG: GMAC FIFO configuration register 5 */
+#define FRF_AB_GMF_HSTFLTRFRMDC_PAUSE_LBN 12
+#define FRF_AB_GMF_HSTFLTRFRMDC_PAUSE_WIDTH 1
+
+/* XM_TX_PARAM_REG: XGMAC transmit parameter register */
+#define	FRF_AB_XM_MAX_TX_FRM_SIZE_LBN FRF_AB_XM_MAX_TX_FRM_SIZE_LO_LBN
+#define	FRF_AB_XM_MAX_TX_FRM_SIZE_WIDTH (FRF_AB_XM_MAX_TX_FRM_SIZE_HI_WIDTH + \
+					 FRF_AB_XM_MAX_TX_FRM_SIZE_LO_WIDTH)
+
+/* XM_RX_PARAM_REG: XGMAC receive parameter register */
+#define	FRF_AB_XM_MAX_RX_FRM_SIZE_LBN FRF_AB_XM_MAX_RX_FRM_SIZE_LO_LBN
+#define	FRF_AB_XM_MAX_RX_FRM_SIZE_WIDTH (FRF_AB_XM_MAX_RX_FRM_SIZE_HI_WIDTH + \
+					 FRF_AB_XM_MAX_RX_FRM_SIZE_LO_WIDTH)
+
+/* XX_TXDRV_CTL_REG: XAUI SerDes transmit drive control register */
+/* Default values */
+#define FFE_AB_XX_TXDRV_DEQ_DEF 0xe /* deq=.6 */
+#define FFE_AB_XX_TXDRV_DTX_DEF 0x5 /* 1.25 */
+#define FFE_AB_XX_SD_CTL_DRV_DEF 0  /* 20mA */
+
+/* XX_CORE_STAT_REG: XAUI XGXS core status register */
+/* XGXS all-lanes status fields */
+#define	FRF_AB_XX_SYNC_STAT_LBN FRF_AB_XX_SYNC_STAT0_LBN
+#define	FRF_AB_XX_SYNC_STAT_WIDTH 4
+#define	FRF_AB_XX_COMMA_DET_LBN FRF_AB_XX_COMMA_DET_CH0_LBN
+#define	FRF_AB_XX_COMMA_DET_WIDTH 4
+#define	FRF_AB_XX_CHAR_ERR_LBN FRF_AB_XX_CHAR_ERR_CH0_LBN
+#define	FRF_AB_XX_CHAR_ERR_WIDTH 4
+#define	FRF_AB_XX_DISPERR_LBN FRF_AB_XX_DISPERR_CH0_LBN
+#define	FRF_AB_XX_DISPERR_WIDTH 4
+#define	FFE_AB_XX_STAT_ALL_LANES 0xf
+#define	FRF_AB_XX_FORCE_SIG_LBN FRF_AB_XX_FORCE_SIG0_VAL_LBN
+#define	FRF_AB_XX_FORCE_SIG_WIDTH 8
+#define	FFE_AB_XX_FORCE_SIG_ALL_LANES 0xff
+
+/* RX_MAC_FILTER_TBL0 */
+/* RMFT_DEST_MAC is wider than 32 bits */
+#define FRF_CZ_RMFT_DEST_MAC_LO_LBN 12
+#define FRF_CZ_RMFT_DEST_MAC_LO_WIDTH 32
+#define FRF_CZ_RMFT_DEST_MAC_HI_LBN 44
+#define FRF_CZ_RMFT_DEST_MAC_HI_WIDTH 16
+
+/* TX_MAC_FILTER_TBL0 */
+/* TMFT_SRC_MAC is wider than 32 bits */
+#define FRF_CZ_TMFT_SRC_MAC_LO_LBN 12
+#define FRF_CZ_TMFT_SRC_MAC_LO_WIDTH 32
+#define FRF_CZ_TMFT_SRC_MAC_HI_LBN 44
+#define FRF_CZ_TMFT_SRC_MAC_HI_WIDTH 16
+
+/* DRIVER_EV */
+/* Sub-fields of an RX flush completion event */
+#define FSF_AZ_DRIVER_EV_RX_FLUSH_FAIL_LBN 12
+#define FSF_AZ_DRIVER_EV_RX_FLUSH_FAIL_WIDTH 1
+#define FSF_AZ_DRIVER_EV_RX_DESCQ_ID_LBN 0
+#define FSF_AZ_DRIVER_EV_RX_DESCQ_ID_WIDTH 12
+
+/* EVENT_ENTRY */
+/* Magic number field for event test */
+#define FSF_AZ_DRV_GEN_EV_MAGIC_LBN 0
+#define FSF_AZ_DRV_GEN_EV_MAGIC_WIDTH 32
+
+/**************************************************************************
+ *
+ * Falcon MAC stats
+ *
+ **************************************************************************
+ *
+ */
+
+#define GRxGoodOct_offset 0x0
+#define GRxGoodOct_WIDTH 48
+#define GRxBadOct_offset 0x8
+#define GRxBadOct_WIDTH 48
+#define GRxMissPkt_offset 0x10
+#define GRxMissPkt_WIDTH 32
+#define GRxFalseCRS_offset 0x14
+#define GRxFalseCRS_WIDTH 32
+#define GRxPausePkt_offset 0x18
+#define GRxPausePkt_WIDTH 32
+#define GRxBadPkt_offset 0x1C
+#define GRxBadPkt_WIDTH 32
+#define GRxUcastPkt_offset 0x20
+#define GRxUcastPkt_WIDTH 32
+#define GRxMcastPkt_offset 0x24
+#define GRxMcastPkt_WIDTH 32
+#define GRxBcastPkt_offset 0x28
+#define GRxBcastPkt_WIDTH 32
+#define GRxGoodLt64Pkt_offset 0x2C
+#define GRxGoodLt64Pkt_WIDTH 32
+#define GRxBadLt64Pkt_offset 0x30
+#define GRxBadLt64Pkt_WIDTH 32
+#define GRx64Pkt_offset 0x34
+#define GRx64Pkt_WIDTH 32
+#define GRx65to127Pkt_offset 0x38
+#define GRx65to127Pkt_WIDTH 32
+#define GRx128to255Pkt_offset 0x3C
+#define GRx128to255Pkt_WIDTH 32
+#define GRx256to511Pkt_offset 0x40
+#define GRx256to511Pkt_WIDTH 32
+#define GRx512to1023Pkt_offset 0x44
+#define GRx512to1023Pkt_WIDTH 32
+#define GRx1024to15xxPkt_offset 0x48
+#define GRx1024to15xxPkt_WIDTH 32
+#define GRx15xxtoJumboPkt_offset 0x4C
+#define GRx15xxtoJumboPkt_WIDTH 32
+#define GRxGtJumboPkt_offset 0x50
+#define GRxGtJumboPkt_WIDTH 32
+#define GRxFcsErr64to15xxPkt_offset 0x54
+#define GRxFcsErr64to15xxPkt_WIDTH 32
+#define GRxFcsErr15xxtoJumboPkt_offset 0x58
+#define GRxFcsErr15xxtoJumboPkt_WIDTH 32
+#define GRxFcsErrGtJumboPkt_offset 0x5C
+#define GRxFcsErrGtJumboPkt_WIDTH 32
+#define GTxGoodBadOct_offset 0x80
+#define GTxGoodBadOct_WIDTH 48
+#define GTxGoodOct_offset 0x88
+#define GTxGoodOct_WIDTH 48
+#define GTxSglColPkt_offset 0x90
+#define GTxSglColPkt_WIDTH 32
+#define GTxMultColPkt_offset 0x94
+#define GTxMultColPkt_WIDTH 32
+#define GTxExColPkt_offset 0x98
+#define GTxExColPkt_WIDTH 32
+#define GTxDefPkt_offset 0x9C
+#define GTxDefPkt_WIDTH 32
+#define GTxLateCol_offset 0xA0
+#define GTxLateCol_WIDTH 32
+#define GTxExDefPkt_offset 0xA4
+#define GTxExDefPkt_WIDTH 32
+#define GTxPausePkt_offset 0xA8
+#define GTxPausePkt_WIDTH 32
+#define GTxBadPkt_offset 0xAC
+#define GTxBadPkt_WIDTH 32
+#define GTxUcastPkt_offset 0xB0
+#define GTxUcastPkt_WIDTH 32
+#define GTxMcastPkt_offset 0xB4
+#define GTxMcastPkt_WIDTH 32
+#define GTxBcastPkt_offset 0xB8
+#define GTxBcastPkt_WIDTH 32
+#define GTxLt64Pkt_offset 0xBC
+#define GTxLt64Pkt_WIDTH 32
+#define GTx64Pkt_offset 0xC0
+#define GTx64Pkt_WIDTH 32
+#define GTx65to127Pkt_offset 0xC4
+#define GTx65to127Pkt_WIDTH 32
+#define GTx128to255Pkt_offset 0xC8
+#define GTx128to255Pkt_WIDTH 32
+#define GTx256to511Pkt_offset 0xCC
+#define GTx256to511Pkt_WIDTH 32
+#define GTx512to1023Pkt_offset 0xD0
+#define GTx512to1023Pkt_WIDTH 32
+#define GTx1024to15xxPkt_offset 0xD4
+#define GTx1024to15xxPkt_WIDTH 32
+#define GTx15xxtoJumboPkt_offset 0xD8
+#define GTx15xxtoJumboPkt_WIDTH 32
+#define GTxGtJumboPkt_offset 0xDC
+#define GTxGtJumboPkt_WIDTH 32
+#define GTxNonTcpUdpPkt_offset 0xE0
+#define GTxNonTcpUdpPkt_WIDTH 16
+#define GTxMacSrcErrPkt_offset 0xE4
+#define GTxMacSrcErrPkt_WIDTH 16
+#define GTxIpSrcErrPkt_offset 0xE8
+#define GTxIpSrcErrPkt_WIDTH 16
+#define GDmaDone_offset 0xEC
+#define GDmaDone_WIDTH 32
+
+#define XgRxOctets_offset 0x0
+#define XgRxOctets_WIDTH 48
+#define XgRxOctetsOK_offset 0x8
+#define XgRxOctetsOK_WIDTH 48
+#define XgRxPkts_offset 0x10
+#define XgRxPkts_WIDTH 32
+#define XgRxPktsOK_offset 0x14
+#define XgRxPktsOK_WIDTH 32
+#define XgRxBroadcastPkts_offset 0x18
+#define XgRxBroadcastPkts_WIDTH 32
+#define XgRxMulticastPkts_offset 0x1C
+#define XgRxMulticastPkts_WIDTH 32
+#define XgRxUnicastPkts_offset 0x20
+#define XgRxUnicastPkts_WIDTH 32
+#define XgRxUndersizePkts_offset 0x24
+#define XgRxUndersizePkts_WIDTH 32
+#define XgRxOversizePkts_offset 0x28
+#define XgRxOversizePkts_WIDTH 32
+#define XgRxJabberPkts_offset 0x2C
+#define XgRxJabberPkts_WIDTH 32
+#define XgRxUndersizeFCSerrorPkts_offset 0x30
+#define XgRxUndersizeFCSerrorPkts_WIDTH 32
+#define XgRxDropEvents_offset 0x34
+#define XgRxDropEvents_WIDTH 32
+#define XgRxFCSerrorPkts_offset 0x38
+#define XgRxFCSerrorPkts_WIDTH 32
+#define XgRxAlignError_offset 0x3C
+#define XgRxAlignError_WIDTH 32
+#define XgRxSymbolError_offset 0x40
+#define XgRxSymbolError_WIDTH 32
+#define XgRxInternalMACError_offset 0x44
+#define XgRxInternalMACError_WIDTH 32
+#define XgRxControlPkts_offset 0x48
+#define XgRxControlPkts_WIDTH 32
+#define XgRxPausePkts_offset 0x4C
+#define XgRxPausePkts_WIDTH 32
+#define XgRxPkts64Octets_offset 0x50
+#define XgRxPkts64Octets_WIDTH 32
+#define XgRxPkts65to127Octets_offset 0x54
+#define XgRxPkts65to127Octets_WIDTH 32
+#define XgRxPkts128to255Octets_offset 0x58
+#define XgRxPkts128to255Octets_WIDTH 32
+#define XgRxPkts256to511Octets_offset 0x5C
+#define XgRxPkts256to511Octets_WIDTH 32
+#define XgRxPkts512to1023Octets_offset 0x60
+#define XgRxPkts512to1023Octets_WIDTH 32
+#define XgRxPkts1024to15xxOctets_offset 0x64
+#define XgRxPkts1024to15xxOctets_WIDTH 32
+#define XgRxPkts15xxtoMaxOctets_offset 0x68
+#define XgRxPkts15xxtoMaxOctets_WIDTH 32
+#define XgRxLengthError_offset 0x6C
+#define XgRxLengthError_WIDTH 32
+#define XgTxPkts_offset 0x80
+#define XgTxPkts_WIDTH 32
+#define XgTxOctets_offset 0x88
+#define XgTxOctets_WIDTH 48
+#define XgTxMulticastPkts_offset 0x90
+#define XgTxMulticastPkts_WIDTH 32
+#define XgTxBroadcastPkts_offset 0x94
+#define XgTxBroadcastPkts_WIDTH 32
+#define XgTxUnicastPkts_offset 0x98
+#define XgTxUnicastPkts_WIDTH 32
+#define XgTxControlPkts_offset 0x9C
+#define XgTxControlPkts_WIDTH 32
+#define XgTxPausePkts_offset 0xA0
+#define XgTxPausePkts_WIDTH 32
+#define XgTxPkts64Octets_offset 0xA4
+#define XgTxPkts64Octets_WIDTH 32
+#define XgTxPkts65to127Octets_offset 0xA8
+#define XgTxPkts65to127Octets_WIDTH 32
+#define XgTxPkts128to255Octets_offset 0xAC
+#define XgTxPkts128to255Octets_WIDTH 32
+#define XgTxPkts256to511Octets_offset 0xB0
+#define XgTxPkts256to511Octets_WIDTH 32
+#define XgTxPkts512to1023Octets_offset 0xB4
+#define XgTxPkts512to1023Octets_WIDTH 32
+#define XgTxPkts1024to15xxOctets_offset 0xB8
+#define XgTxPkts1024to15xxOctets_WIDTH 32
+#define XgTxPkts1519toMaxOctets_offset 0xBC
+#define XgTxPkts1519toMaxOctets_WIDTH 32
+#define XgTxUndersizePkts_offset 0xC0
+#define XgTxUndersizePkts_WIDTH 32
+#define XgTxOversizePkts_offset 0xC4
+#define XgTxOversizePkts_WIDTH 32
+#define XgTxNonTcpUdpPkt_offset 0xC8
+#define XgTxNonTcpUdpPkt_WIDTH 16
+#define XgTxMacSrcErrPkt_offset 0xCC
+#define XgTxMacSrcErrPkt_WIDTH 16
+#define XgTxIpSrcErrPkt_offset 0xD0
+#define XgTxIpSrcErrPkt_WIDTH 16
+#define XgDmaDone_offset 0xD4
+#define XgDmaDone_WIDTH 32
+
+#define FALCON_STATS_NOT_DONE 0x00000000
+#define FALCON_STATS_DONE 0xffffffff
+
+/**************************************************************************
+ *
+ * Falcon non-volatile configuration
+ *
+ **************************************************************************
+ */
+
+/* Board configuration v2 (v1 is obsolete; later versions are compatible) */
+struct falcon_nvconfig_board_v2 {
+	__le16 nports;
+	u8 port0_phy_addr;
+	u8 port0_phy_type;
+	u8 port1_phy_addr;
+	u8 port1_phy_type;
+	__le16 asic_sub_revision;
+	__le16 board_revision;
+} __packed;
+
+/* Board configuration v3 extra information */
+struct falcon_nvconfig_board_v3 {
+	__le32 spi_device_type[2];
+} __packed;
+
+/* Bit numbers for spi_device_type */
+#define SPI_DEV_TYPE_SIZE_LBN 0
+#define SPI_DEV_TYPE_SIZE_WIDTH 5
+#define SPI_DEV_TYPE_ADDR_LEN_LBN 6
+#define SPI_DEV_TYPE_ADDR_LEN_WIDTH 2
+#define SPI_DEV_TYPE_ERASE_CMD_LBN 8
+#define SPI_DEV_TYPE_ERASE_CMD_WIDTH 8
+#define SPI_DEV_TYPE_ERASE_SIZE_LBN 16
+#define SPI_DEV_TYPE_ERASE_SIZE_WIDTH 5
+#define SPI_DEV_TYPE_BLOCK_SIZE_LBN 24
+#define SPI_DEV_TYPE_BLOCK_SIZE_WIDTH 5
+#define SPI_DEV_TYPE_FIELD(type, field)					\
+	(((type) >> EFX_LOW_BIT(field)) & EFX_MASK32(EFX_WIDTH(field)))
+
+#define FALCON_NVCONFIG_OFFSET 0x300
+
+#define FALCON_NVCONFIG_BOARD_MAGIC_NUM 0xFA1C
+struct falcon_nvconfig {
+	efx_oword_t ee_vpd_cfg_reg;			/* 0x300 */
+	u8 mac_address[2][8];			/* 0x310 */
+	efx_oword_t pcie_sd_ctl0123_reg;		/* 0x320 */
+	efx_oword_t pcie_sd_ctl45_reg;			/* 0x330 */
+	efx_oword_t pcie_pcs_ctl_stat_reg;		/* 0x340 */
+	efx_oword_t hw_init_reg;			/* 0x350 */
+	efx_oword_t nic_stat_reg;			/* 0x360 */
+	efx_oword_t glb_ctl_reg;			/* 0x370 */
+	efx_oword_t srm_cfg_reg;			/* 0x380 */
+	efx_oword_t spare_reg;				/* 0x390 */
+	__le16 board_magic_num;			/* 0x3A0 */
+	__le16 board_struct_ver;
+	__le16 board_checksum;
+	struct falcon_nvconfig_board_v2 board_v2;
+	efx_oword_t ee_base_page_reg;			/* 0x3B0 */
+	struct falcon_nvconfig_board_v3 board_v3;	/* 0x3C0 */
+} __packed;
+
+#endif /* EFX_REGS_H */
diff -r 9566a4a50a43 drivers/net/sfc/rx.c
--- a/drivers/net/sfc/rx.c
+++ b/drivers/net/sfc/rx.c
@@ -1,7 +1,7 @@
 /****************************************************************************
  * Driver for Solarflare Solarstorm network controllers and boards
  * Copyright 2005-2006 Fen Systems Ltd.
- * Copyright 2005-2008 Solarflare Communications Inc.
+ * Copyright 2005-2011 Solarflare Communications Inc.
  *
  * This program is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 as published
@@ -10,21 +10,25 @@
 
 #include <linux/socket.h>
 #include <linux/in.h>
+#include <linux/slab.h>
 #include <linux/ip.h>
 #include <linux/tcp.h>
 #include <linux/udp.h>
 #include <net/ip.h>
+#include <net/tcp.h>
 #include <net/checksum.h>
 #include "net_driver.h"
-#include "rx.h"
 #include "efx.h"
-#include "falcon.h"
+#include "nic.h"
 #include "selftest.h"
 #include "workarounds.h"
 
 /* Number of RX descriptors pushed at once. */
 #define EFX_RX_BATCH  8
 
+/* Maximum size of a buffer sharing a page */
+#define EFX_RX_HALF_PAGE ((PAGE_SIZE >> 1) - sizeof(struct efx_rx_page_state))
+
 /* Size of buffer allocated for skb header area. */
 #define EFX_SKB_HEADERS  64u
 
@@ -34,7 +38,7 @@
  * This driver supports two methods for allocating and using RX buffers:
  * each RX buffer may be backed by an skb or by an order-n page.
  *
- * When LRO is in use then the second method has a lower overhead,
+ * When GRO is in use then the second method has a lower overhead,
  * since we don't have to allocate then free skbs on reassembled frames.
  *
  * Values:
@@ -47,25 +51,25 @@
  *
  *   - Since pushing and popping descriptors are separated by the rx_queue
  *     size, so the watermarks should be ~rxd_size.
- *   - The performance win by using page-based allocation for LRO is less
- *     than the performance hit of using page-based allocation of non-LRO,
+ *   - The performance win by using page-based allocation for GRO is less
+ *     than the performance hit of using page-based allocation of non-GRO,
  *     so the watermarks should reflect this.
  *
  * Per channel we maintain a single variable, updated by each channel:
  *
- *   rx_alloc_level += (lro_performed ? RX_ALLOC_FACTOR_LRO :
+ *   rx_alloc_level += (gro_performed ? RX_ALLOC_FACTOR_GRO :
  *                      RX_ALLOC_FACTOR_SKB)
  * Per NAPI poll interval, we constrain rx_alloc_level to 0..MAX (which
  * limits the hysteresis), and update the allocation strategy:
  *
- *   rx_alloc_method = (rx_alloc_level > RX_ALLOC_LEVEL_LRO ?
+ *   rx_alloc_method = (rx_alloc_level > RX_ALLOC_LEVEL_GRO ?
  *                      RX_ALLOC_METHOD_PAGE : RX_ALLOC_METHOD_SKB)
  */
-static int rx_alloc_method = RX_ALLOC_METHOD_PAGE;
+static int rx_alloc_method = RX_ALLOC_METHOD_AUTO;
 
-#define RX_ALLOC_LEVEL_LRO 0x2000
+#define RX_ALLOC_LEVEL_GRO 0x2000
 #define RX_ALLOC_LEVEL_MAX 0x3000
-#define RX_ALLOC_FACTOR_LRO 1
+#define RX_ALLOC_FACTOR_GRO 1
 #define RX_ALLOC_FACTOR_SKB (-2)
 
 /* This is the percentage fill level below which new RX descriptors
@@ -86,169 +90,177 @@ static unsigned int rx_refill_limit = 95
  */
 #define EFX_RXD_HEAD_ROOM 2
 
-static inline unsigned int efx_rx_buf_offset(struct efx_rx_buffer *buf)
+/* Offset of ethernet header within page */
+static inline unsigned int efx_rx_buf_offset(struct efx_nic *efx,
+					     struct efx_rx_buffer *buf)
 {
 	/* Offset is always within one page, so we don't need to consider
 	 * the page order.
 	 */
-	return (__force unsigned long) buf->data & (PAGE_SIZE - 1);
+	return (((__force unsigned long) buf->dma_addr & (PAGE_SIZE - 1)) +
+		efx->rx_buffer_hash_size);
 }
 static inline unsigned int efx_rx_buf_size(struct efx_nic *efx)
 {
 	return PAGE_SIZE << efx->rx_buffer_order;
 }
 
+/* Find the Ethernet header in an efx_rx_buffer.  This must not be
+ * called after any other operation that moves the skb's data pointer.
+ */
+static u8 *efx_rx_buf_eh(struct efx_nic *efx, struct efx_rx_buffer *buf)
+{
+	if (buf->flags & EFX_RX_BUF_PAGE)
+		return page_address(buf->u.page) + efx_rx_buf_offset(efx, buf);
+	else
+		return (u8 *)buf->u.skb->data + efx->rx_buffer_hash_size;
+}
+
+static inline u32 efx_rx_buf_hash(const u8 *eh)
+{
+	/* The ethernet header is always directly after any hash. */
+#if defined(CONFIG_HAVE_EFFICIENT_UNALIGNED_ACCESS) || NET_IP_ALIGN % 4 == 0
+	return __le32_to_cpup((const __le32 *)(eh - 4));
+#else
+	const u8 *data = eh - 4;
+	return ((u32)data[0]       |
+		(u32)data[1] << 8  |
+		(u32)data[2] << 16 |
+		(u32)data[3] << 24);
+#endif
+}
 
 /**
- * efx_init_rx_buffer_skb - create new RX buffer using skb-based allocation
+ * efx_init_rx_buffers_skb - create EFX_RX_BATCH skb-based RX buffers
  *
  * @rx_queue:		Efx RX queue
- * @rx_buf:		RX buffer structure to populate
  *
- * This allocates memory for a new receive buffer, maps it for DMA,
- * and populates a struct efx_rx_buffer with the relevant
- * information.  Return a negative error code or 0 on success.
+ * This allocates EFX_RX_BATCH skbs, maps them for DMA, and populates a
+ * struct efx_rx_buffer for each one. Return a negative error code or 0
+ * on success. May fail having only inserted fewer than EFX_RX_BATCH
+ * buffers.
  */
-static int efx_init_rx_buffer_skb(struct efx_rx_queue *rx_queue,
-				  struct efx_rx_buffer *rx_buf)
+static int efx_init_rx_buffers_skb(struct efx_rx_queue *rx_queue)
 {
 	struct efx_nic *efx = rx_queue->efx;
 	struct net_device *net_dev = efx->net_dev;
+	struct efx_rx_buffer *rx_buf;
+	struct sk_buff *skb;
 	int skb_len = efx->rx_buffer_len;
+	unsigned index, count;
 
-	rx_buf->skb = netdev_alloc_skb(net_dev, skb_len);
-	if (unlikely(!rx_buf->skb))
-		return -ENOMEM;
+	for (count = 0; count < EFX_RX_BATCH; ++count) {
+		index = rx_queue->added_count & rx_queue->ptr_mask;
+		rx_buf = efx_rx_buffer(rx_queue, index);
 
-	/* Adjust the SKB for padding and checksum */
-	skb_reserve(rx_buf->skb, NET_IP_ALIGN);
-	rx_buf->len = skb_len - NET_IP_ALIGN;
-	rx_buf->data = (char *)rx_buf->skb->data;
-	rx_buf->skb->ip_summed = CHECKSUM_UNNECESSARY;
+		rx_buf->u.skb = skb = netdev_alloc_skb(net_dev, skb_len);
+		if (unlikely(!skb))
+			return -ENOMEM;
 
-	rx_buf->dma_addr = pci_map_single(efx->pci_dev,
-					  rx_buf->data, rx_buf->len,
-					  PCI_DMA_FROMDEVICE);
+		/* Adjust the SKB for padding and checksum */
+		skb_reserve(skb, NET_IP_ALIGN);
+		rx_buf->len = skb_len - NET_IP_ALIGN;
+		rx_buf->flags = 0;
+		skb->ip_summed = CHECKSUM_UNNECESSARY;
 
-	if (unlikely(pci_dma_mapping_error(efx->pci_dev, rx_buf->dma_addr))) {
-		dev_kfree_skb_any(rx_buf->skb);
-		rx_buf->skb = NULL;
-		return -EIO;
+		rx_buf->dma_addr = pci_map_single(efx->pci_dev,
+						  skb->data, rx_buf->len,
+						  PCI_DMA_FROMDEVICE);
+		if (unlikely(pci_dma_mapping_error(efx->pci_dev,
+						   rx_buf->dma_addr))) {
+			dev_kfree_skb_any(skb);
+			rx_buf->u.skb = NULL;
+			return -EIO;
+		}
+
+		++rx_queue->added_count;
+		++rx_queue->alloc_skb_count;
 	}
 
 	return 0;
 }
 
 /**
- * efx_init_rx_buffer_page - create new RX buffer using page-based allocation
+ * efx_init_rx_buffers_page - create EFX_RX_BATCH page-based RX buffers
  *
  * @rx_queue:		Efx RX queue
- * @rx_buf:		RX buffer structure to populate
  *
- * This allocates memory for a new receive buffer, maps it for DMA,
- * and populates a struct efx_rx_buffer with the relevant
- * information.  Return a negative error code or 0 on success.
+ * This allocates memory for EFX_RX_BATCH receive buffers, maps them for DMA,
+ * and populates struct efx_rx_buffers for each one. Return a negative error
+ * code or 0 on success. If a single page can be split between two buffers,
+ * then the page will either be inserted fully, or not at at all.
  */
-static int efx_init_rx_buffer_page(struct efx_rx_queue *rx_queue,
-				   struct efx_rx_buffer *rx_buf)
+static int efx_init_rx_buffers_page(struct efx_rx_queue *rx_queue)
 {
 	struct efx_nic *efx = rx_queue->efx;
-	int bytes, space, offset;
+	struct efx_rx_buffer *rx_buf;
+	struct page *page;
+	void *page_addr;
+	struct efx_rx_page_state *state;
+	dma_addr_t dma_addr;
+	unsigned index, count;
 
-	bytes = efx->rx_buffer_len - EFX_PAGE_IP_ALIGN;
+	/* We can split a page between two buffers */
+	BUILD_BUG_ON(EFX_RX_BATCH & 1);
 
-	/* If there is space left in the previously allocated page,
-	 * then use it. Otherwise allocate a new one */
-	rx_buf->page = rx_queue->buf_page;
-	if (rx_buf->page == NULL) {
-		dma_addr_t dma_addr;
-
-		rx_buf->page = alloc_pages(__GFP_COLD | __GFP_COMP | GFP_ATOMIC,
-					   efx->rx_buffer_order);
-		if (unlikely(rx_buf->page == NULL))
+	for (count = 0; count < EFX_RX_BATCH; ++count) {
+		page = alloc_pages(__GFP_COLD | __GFP_COMP | GFP_ATOMIC,
+				   efx->rx_buffer_order);
+		if (unlikely(page == NULL))
 			return -ENOMEM;
-
-		dma_addr = pci_map_page(efx->pci_dev, rx_buf->page,
-					0, efx_rx_buf_size(efx),
+		dma_addr = pci_map_page(efx->pci_dev, page, 0,
+					efx_rx_buf_size(efx),
 					PCI_DMA_FROMDEVICE);
-
 		if (unlikely(pci_dma_mapping_error(efx->pci_dev, dma_addr))) {
-			__free_pages(rx_buf->page, efx->rx_buffer_order);
-			rx_buf->page = NULL;
+			__free_pages(page, efx->rx_buffer_order);
 			return -EIO;
 		}
+		page_addr = page_address(page);
+		state = page_addr;
+		state->refcnt = 0;
+		state->dma_addr = dma_addr;
 
-		rx_queue->buf_page = rx_buf->page;
-		rx_queue->buf_dma_addr = dma_addr;
-		rx_queue->buf_data = (page_address(rx_buf->page) +
-				      EFX_PAGE_IP_ALIGN);
-	}
+		page_addr += sizeof(struct efx_rx_page_state);
+		dma_addr += sizeof(struct efx_rx_page_state);
 
-	rx_buf->len = bytes;
-	rx_buf->data = rx_queue->buf_data;
-	offset = efx_rx_buf_offset(rx_buf);
-	rx_buf->dma_addr = rx_queue->buf_dma_addr + offset;
+	split:
+		index = rx_queue->added_count & rx_queue->ptr_mask;
+		rx_buf = efx_rx_buffer(rx_queue, index);
+		rx_buf->dma_addr = dma_addr + EFX_PAGE_IP_ALIGN;
+		rx_buf->u.page = page;
+		rx_buf->len = efx->rx_buffer_len - EFX_PAGE_IP_ALIGN;
+		rx_buf->flags = EFX_RX_BUF_PAGE;
+		++rx_queue->added_count;
+		++rx_queue->alloc_page_count;
+		++state->refcnt;
 
-	/* Try to pack multiple buffers per page */
-	if (efx->rx_buffer_order == 0) {
-		/* The next buffer starts on the next 512 byte boundary */
-		rx_queue->buf_data += ((bytes + 0x1ff) & ~0x1ff);
-		offset += ((bytes + 0x1ff) & ~0x1ff);
-
-		space = efx_rx_buf_size(efx) - offset;
-		if (space >= bytes) {
-			/* Refs dropped on kernel releasing each skb */
-			get_page(rx_queue->buf_page);
-			goto out;
+		if ((~count & 1) && (efx->rx_buffer_len <= EFX_RX_HALF_PAGE)) {
+			/* Use the second half of the page */
+			get_page(page);
+			dma_addr += (PAGE_SIZE >> 1);
+			page_addr += (PAGE_SIZE >> 1);
+			++count;
+			goto split;
 		}
 	}
 
-	/* This is the final RX buffer for this page, so mark it for
-	 * unmapping */
-	rx_queue->buf_page = NULL;
-	rx_buf->unmap_addr = rx_queue->buf_dma_addr;
-
- out:
 	return 0;
 }
 
-/* This allocates memory for a new receive buffer, maps it for DMA,
- * and populates a struct efx_rx_buffer with the relevant
- * information.
- */
-static int efx_init_rx_buffer(struct efx_rx_queue *rx_queue,
-			      struct efx_rx_buffer *new_rx_buf)
-{
-	int rc = 0;
-
-	if (rx_queue->channel->rx_alloc_push_pages) {
-		new_rx_buf->skb = NULL;
-		rc = efx_init_rx_buffer_page(rx_queue, new_rx_buf);
-		rx_queue->alloc_page_count++;
-	} else {
-		new_rx_buf->page = NULL;
-		rc = efx_init_rx_buffer_skb(rx_queue, new_rx_buf);
-		rx_queue->alloc_skb_count++;
-	}
-
-	if (unlikely(rc < 0))
-		EFX_LOG_RL(rx_queue->efx, "%s RXQ[%d] =%d\n", __func__,
-			   rx_queue->queue, rc);
-	return rc;
-}
-
 static void efx_unmap_rx_buffer(struct efx_nic *efx,
 				struct efx_rx_buffer *rx_buf)
 {
-	if (rx_buf->page) {
-		EFX_BUG_ON_PARANOID(rx_buf->skb);
-		if (rx_buf->unmap_addr) {
-			pci_unmap_page(efx->pci_dev, rx_buf->unmap_addr,
+	if ((rx_buf->flags & EFX_RX_BUF_PAGE) && rx_buf->u.page) {
+		struct efx_rx_page_state *state;
+
+		state = page_address(rx_buf->u.page);
+		if (--state->refcnt == 0) {
+			pci_unmap_page(efx->pci_dev,
+				       state->dma_addr,
 				       efx_rx_buf_size(efx),
 				       PCI_DMA_FROMDEVICE);
-			rx_buf->unmap_addr = 0;
 		}
-	} else if (likely(rx_buf->skb)) {
+	} else if (!(rx_buf->flags & EFX_RX_BUF_PAGE) && rx_buf->u.skb) {
 		pci_unmap_single(efx->pci_dev, rx_buf->dma_addr,
 				 rx_buf->len, PCI_DMA_FROMDEVICE);
 	}
@@ -257,12 +269,12 @@ static void efx_unmap_rx_buffer(struct e
 static void efx_free_rx_buffer(struct efx_nic *efx,
 			       struct efx_rx_buffer *rx_buf)
 {
-	if (rx_buf->page) {
-		__free_pages(rx_buf->page, efx->rx_buffer_order);
-		rx_buf->page = NULL;
-	} else if (likely(rx_buf->skb)) {
-		dev_kfree_skb_any(rx_buf->skb);
-		rx_buf->skb = NULL;
+	if ((rx_buf->flags & EFX_RX_BUF_PAGE) && rx_buf->u.page) {
+		__free_pages(rx_buf->u.page, efx->rx_buffer_order);
+		rx_buf->u.page = NULL;
+	} else if (!(rx_buf->flags & EFX_RX_BUF_PAGE) && rx_buf->u.skb) {
+		dev_kfree_skb_any(rx_buf->u.skb);
+		rx_buf->u.skb = NULL;
 	}
 }
 
@@ -273,32 +285,88 @@ static void efx_fini_rx_buffer(struct ef
 	efx_free_rx_buffer(rx_queue->efx, rx_buf);
 }
 
+/* Attempt to resurrect the other receive buffer that used to share this page,
+ * which had previously been passed up to the kernel and freed. */
+static void efx_resurrect_rx_buffer(struct efx_rx_queue *rx_queue,
+				    struct efx_rx_buffer *rx_buf)
+{
+	struct efx_rx_page_state *state = page_address(rx_buf->u.page);
+	struct efx_rx_buffer *new_buf;
+	unsigned fill_level, index;
+
+	/* +1 because efx_rx_packet() incremented removed_count. +1 because
+	 * we'd like to insert an additional descriptor whilst leaving
+	 * EFX_RXD_HEAD_ROOM for the non-recycle path */
+	fill_level = (rx_queue->added_count - rx_queue->removed_count + 2);
+	if (unlikely(fill_level > rx_queue->max_fill)) {
+		/* We could place "state" on a list, and drain the list in
+		 * efx_fast_push_rx_descriptors(). For now, this will do. */
+		++rx_queue->resurrect_failed_count;
+		return;
+	}
+
+	++state->refcnt;
+	get_page(rx_buf->u.page);
+
+	index = rx_queue->added_count & rx_queue->ptr_mask;
+	new_buf = efx_rx_buffer(rx_queue, index);
+	new_buf->dma_addr = rx_buf->dma_addr ^ (PAGE_SIZE >> 1);
+	new_buf->u.page = rx_buf->u.page;
+	new_buf->len = rx_buf->len;
+	new_buf->flags = EFX_RX_BUF_PAGE;
+	++rx_queue->added_count;
+	++rx_queue->recycle_count;
+	++rx_queue->resurrect_count;
+}
+
+/* Recycle the given rx buffer directly back into the rx_queue. There is
+ * always room to add this buffer, because we've just popped a buffer. */
+static void efx_recycle_rx_buffer(struct efx_channel *channel,
+				  struct efx_rx_buffer *rx_buf)
+{
+	struct efx_nic *efx = channel->efx;
+	struct efx_rx_queue *rx_queue = efx_channel_get_rx_queue(channel);
+	struct efx_rx_buffer *new_buf;
+	unsigned index;
+
+	rx_buf->flags &= EFX_RX_BUF_PAGE;
+
+	if ((rx_buf->flags & EFX_RX_BUF_PAGE) &&
+	    efx->rx_buffer_len <= EFX_RX_HALF_PAGE &&
+	    page_count(rx_buf->u.page) == 1)
+		efx_resurrect_rx_buffer(rx_queue, rx_buf);
+
+	index = rx_queue->added_count & rx_queue->ptr_mask;
+	new_buf = efx_rx_buffer(rx_queue, index);
+
+	memcpy(new_buf, rx_buf, sizeof(*new_buf));
+	rx_buf->u.page = NULL;
+	++rx_queue->added_count;
+	++rx_queue->recycle_count;
+}
+
 /**
  * efx_fast_push_rx_descriptors - push new RX descriptors quickly
  * @rx_queue:		RX descriptor queue
- * @retry:              Recheck the fill level
  * This will aim to fill the RX descriptor queue up to
  * @rx_queue->@fast_fill_limit. If there is insufficient atomic
- * memory to do so, the caller should retry.
+ * memory to do so, a slow fill will be scheduled.
+ *
+ * The caller must provide serialisation (none is used here). In practise,
+ * this means this function must run from the NAPI handler, or be called
+ * when NAPI is disabled.
  */
-static int __efx_fast_push_rx_descriptors(struct efx_rx_queue *rx_queue,
-					  int retry)
+void efx_fast_push_rx_descriptors(struct efx_rx_queue *rx_queue)
 {
-	struct efx_rx_buffer *rx_buf;
-	unsigned fill_level, index;
-	int i, space, rc = 0;
+	struct efx_channel *channel = efx_rx_queue_channel(rx_queue);
+	unsigned fill_level;
+	int space, rc = 0;
 
-	/* Calculate current fill level.  Do this outside the lock,
-	 * because most of the time we'll end up not wanting to do the
-	 * fill anyway.
-	 */
+	/* Calculate current fill level, and exit if we don't need to fill */
 	fill_level = (rx_queue->added_count - rx_queue->removed_count);
-	EFX_BUG_ON_PARANOID(fill_level >
-			    rx_queue->efx->type->rxd_ring_mask + 1);
-
-	/* Don't fill if we don't need to */
+	EFX_BUG_ON_PARANOID(fill_level > rx_queue->efx->rxq_entries);
 	if (fill_level >= rx_queue->fast_fill_trigger)
-		return 0;
+		goto out;
 
 	/* Record minimum fill level */
 	if (unlikely(fill_level < rx_queue->min_fill)) {
@@ -306,107 +374,52 @@ static int __efx_fast_push_rx_descriptor
 			rx_queue->min_fill = fill_level;
 	}
 
-	/* Acquire RX add lock.  If this lock is contended, then a fast
-	 * fill must already be in progress (e.g. in the refill
-	 * tasklet), so we don't need to do anything
-	 */
-	if (!spin_trylock_bh(&rx_queue->add_lock))
-		return -1;
-
- retry:
-	/* Recalculate current fill level now that we have the lock */
-	fill_level = (rx_queue->added_count - rx_queue->removed_count);
-	EFX_BUG_ON_PARANOID(fill_level >
-			    rx_queue->efx->type->rxd_ring_mask + 1);
 	space = rx_queue->fast_fill_limit - fill_level;
 	if (space < EFX_RX_BATCH)
-		goto out_unlock;
+		goto out;
 
-	EFX_TRACE(rx_queue->efx, "RX queue %d fast-filling descriptor ring from"
-		  " level %d to level %d using %s allocation\n",
-		  rx_queue->queue, fill_level, rx_queue->fast_fill_limit,
-		  rx_queue->channel->rx_alloc_push_pages ? "page" : "skb");
+	netif_vdbg(rx_queue->efx, rx_status, rx_queue->efx->net_dev,
+		   "RX queue %d fast-filling descriptor ring from"
+		   " level %d to level %d using %s allocation\n",
+		   efx_rx_queue_index(rx_queue), fill_level,
+		   rx_queue->fast_fill_limit,
+		   channel->rx_alloc_push_pages ? "page" : "skb");
 
 	do {
-		for (i = 0; i < EFX_RX_BATCH; ++i) {
-			index = (rx_queue->added_count &
-				 rx_queue->efx->type->rxd_ring_mask);
-			rx_buf = efx_rx_buffer(rx_queue, index);
-			rc = efx_init_rx_buffer(rx_queue, rx_buf);
-			if (unlikely(rc))
-				goto out;
-			++rx_queue->added_count;
+		if (channel->rx_alloc_push_pages)
+			rc = efx_init_rx_buffers_page(rx_queue);
+		else
+			rc = efx_init_rx_buffers_skb(rx_queue);
+		if (unlikely(rc)) {
+			/* Ensure that we don't leave the rx queue empty */
+			if (rx_queue->added_count == rx_queue->removed_count)
+				efx_schedule_slow_fill(rx_queue);
+			goto out;
 		}
 	} while ((space -= EFX_RX_BATCH) >= EFX_RX_BATCH);
 
-	EFX_TRACE(rx_queue->efx, "RX queue %d fast-filled descriptor ring "
-		  "to level %d\n", rx_queue->queue,
-		  rx_queue->added_count - rx_queue->removed_count);
+	netif_vdbg(rx_queue->efx, rx_status, rx_queue->efx->net_dev,
+		   "RX queue %d fast-filled descriptor ring "
+		   "to level %d\n", efx_rx_queue_index(rx_queue),
+		   rx_queue->added_count - rx_queue->removed_count);
 
- out:
-	/* Send write pointer to card. */
-	falcon_notify_rx_desc(rx_queue);
-
-	/* If the fast fill is running inside from the refill tasklet, then
-	 * for SMP systems it may be running on a different CPU to
-	 * RX event processing, which means that the fill level may now be
-	 * out of date. */
-	if (unlikely(retry && (rc == 0)))
-		goto retry;
-
- out_unlock:
-	spin_unlock_bh(&rx_queue->add_lock);
-
-	return rc;
+out:
+	if (rx_queue->notified_count != rx_queue->added_count)
+		efx_nic_notify_rx_desc(rx_queue);
 }
 
-/**
- * efx_fast_push_rx_descriptors - push new RX descriptors quickly
- * @rx_queue:		RX descriptor queue
- *
- * This will aim to fill the RX descriptor queue up to
- * @rx_queue->@fast_fill_limit.  If there is insufficient memory to do so,
- * it will schedule a work item to immediately continue the fast fill
- */
-void efx_fast_push_rx_descriptors(struct efx_rx_queue *rx_queue)
+void efx_rx_slow_fill(unsigned long context)
 {
-	int rc;
+	struct efx_rx_queue *rx_queue = (struct efx_rx_queue *)context;
 
-	rc = __efx_fast_push_rx_descriptors(rx_queue, 0);
-	if (unlikely(rc)) {
-		/* Schedule the work item to run immediately. The hope is
-		 * that work is immediately pending to free some memory
-		 * (e.g. an RX event or TX completion)
-		 */
-		efx_schedule_slow_fill(rx_queue, 0);
-	}
-}
-
-void efx_rx_work(struct work_struct *data)
-{
-	struct efx_rx_queue *rx_queue;
-	int rc;
-
-	rx_queue = container_of(data, struct efx_rx_queue, work.work);
-
-	if (unlikely(!rx_queue->channel->enabled))
-		return;
-
-	EFX_TRACE(rx_queue->efx, "RX queue %d worker thread executing on CPU "
-		  "%d\n", rx_queue->queue, raw_smp_processor_id());
-
+	/* Post an event to cause NAPI to run and refill the queue */
+	efx_nic_generate_fill_event(rx_queue);
 	++rx_queue->slow_fill_count;
-	/* Push new RX descriptors, allowing at least 1 jiffy for
-	 * the kernel to free some more memory. */
-	rc = __efx_fast_push_rx_descriptors(rx_queue, 1);
-	if (rc)
-		efx_schedule_slow_fill(rx_queue, 1);
 }
 
 static void efx_rx_packet__check_len(struct efx_rx_queue *rx_queue,
 				     struct efx_rx_buffer *rx_buf,
-				     int len, bool *discard,
-				     bool *leak_packet)
+				     int len, bool *leak_packet)
 {
 	struct efx_nic *efx = rx_queue->efx;
 	unsigned max_len = rx_buf->len - efx->type->rx_buffer_padding;
@@ -417,98 +430,106 @@ static void efx_rx_packet__check_len(str
 	/* The packet must be discarded, but this is only a fatal error
 	 * if the caller indicated it was
 	 */
-	*discard = true;
+	rx_buf->flags |= EFX_RX_PKT_DISCARD;
 
 	if ((len > rx_buf->len) && EFX_WORKAROUND_8071(efx)) {
-		EFX_ERR_RL(efx, " RX queue %d seriously overlength "
-			   "RX event (0x%x > 0x%x+0x%x). Leaking\n",
-			   rx_queue->queue, len, max_len,
-			   efx->type->rx_buffer_padding);
+		if (net_ratelimit())
+			netif_err(efx, rx_err, efx->net_dev,
+				  " RX queue %d seriously overlength "
+				  "RX event (0x%x > 0x%x+0x%x). Leaking\n",
+				  efx_rx_queue_index(rx_queue), len, max_len,
+				  efx->type->rx_buffer_padding);
 		/* If this buffer was skb-allocated, then the meta
 		 * data at the end of the skb will be trashed. So
 		 * we have no choice but to leak the fragment.
 		 */
-		*leak_packet = (rx_buf->skb != NULL);
+		*leak_packet = !(rx_buf->flags & EFX_RX_BUF_PAGE);
 		efx_schedule_reset(efx, RESET_TYPE_RX_RECOVERY);
 	} else {
-		EFX_ERR_RL(efx, " RX queue %d overlength RX event "
-			   "(0x%x > 0x%x)\n", rx_queue->queue, len, max_len);
+		if (net_ratelimit())
+			netif_err(efx, rx_err, efx->net_dev,
+				  " RX queue %d overlength RX event "
+				  "(0x%x > 0x%x)\n",
+				  efx_rx_queue_index(rx_queue), len, max_len);
 	}
 
-	rx_queue->channel->n_rx_overlength++;
+	efx_rx_queue_channel(rx_queue)->n_rx_overlength++;
 }
 
-/* Pass a received packet up through the generic LRO stack
+static inline bool efx_gro_enabled(const struct efx_nic *efx)
+{
+	return !!(efx->net_dev->features & NETIF_F_GRO);
+}
+
+/* Pass a received packet up through the generic GRO stack
  *
- * Handles driverlink veto, and passes the fragment up via
- * the appropriate LRO method
+ * Passes the fragment up via the appropriate GRO method
  */
-static void efx_rx_packet_lro(struct efx_channel *channel,
+static void efx_rx_packet_gro(struct efx_channel *channel,
 			      struct efx_rx_buffer *rx_buf,
-			      bool checksummed)
+			      const u8 *eh)
 {
-	struct efx_nic *efx = channel->efx;
 	struct napi_struct *napi = &channel->napi_str;
-	enum efx_veto veto;
+	gro_result_t gro_result;
 
-	/* It would be faster if we had access to packets at the
-	 * other side of generic LRO. Unfortunately, there isn't
-	 * an obvious interface to this, so veto packets before LRO */
-	veto = EFX_DL_CALLBACK(efx, rx_packet, rx_buf->data, rx_buf->len);
-	if (unlikely(veto)) {
-		EFX_DL_LOG(efx, "LRO RX vetoed by driverlink %s driver\n",
-			   efx->dl_cb_dev.rx_packet->driver->name);
-		/* Free the buffer now */
-		efx_free_rx_buffer(efx, rx_buf);
-		return;
-	}
+	/* Pass the skb/page into the GRO engine */
+	if (rx_buf->flags & EFX_RX_BUF_PAGE) {
+		struct efx_nic *efx = channel->efx;
+		struct page *page = rx_buf->u.page;
+		struct sk_buff *skb;
 
-	/* Pass the skb/page into the LRO engine */
-	if (rx_buf->page) {
-		struct sk_buff *skb = napi_get_frags(napi);
+		rx_buf->u.page = NULL;
 
+		skb = napi_get_frags(napi);
 		if (!skb) {
-			put_page(rx_buf->page);
-			goto out;
+			put_page(page);
+			return;
 		}
 
-		skb_shinfo(skb)->frags[0].page = rx_buf->page;
-		skb_shinfo(skb)->frags[0].page_offset =
-			efx_rx_buf_offset(rx_buf);
-		skb_shinfo(skb)->frags[0].size = rx_buf->len;
-		skb_shinfo(skb)->nr_frags = 1;
+#if !defined(EFX_USE_KCOMPAT) || defined(EFX_HAVE_RXHASH_SUPPORT)
+		if (efx->net_dev->features & NETIF_F_RXHASH)
+			skb->rxhash = efx_rx_buf_hash(eh);
+#endif
+
+		skb_fill_page_desc(skb, 0, page,
+				   efx_rx_buf_offset(efx, rx_buf), rx_buf->len);
 
 		skb->len = rx_buf->len;
 		skb->data_len = rx_buf->len;
 		skb->truesize += rx_buf->len;
-		skb->ip_summed =
-			checksummed ? CHECKSUM_UNNECESSARY : CHECKSUM_NONE;
+		skb->ip_summed = ((rx_buf->flags & EFX_RX_PKT_CSUMMED) ?
+				  CHECKSUM_UNNECESSARY : CHECKSUM_NONE);
 
-		napi_gro_frags(napi);
+		skb_record_rx_queue(skb, channel->rx_queue.core_index);
 
-out:
-		EFX_BUG_ON_PARANOID(rx_buf->skb);
-		rx_buf->page = NULL;
+		gro_result = napi_gro_frags(napi);
 	} else {
-		EFX_BUG_ON_PARANOID(!rx_buf->skb);
-		EFX_BUG_ON_PARANOID(!checksummed);
+		struct sk_buff *skb = rx_buf->u.skb;
 
-		napi_gro_receive(napi, rx_buf->skb);
-		rx_buf->skb = NULL;
+		EFX_BUG_ON_PARANOID(!(rx_buf->flags & EFX_RX_PKT_CSUMMED));
+		rx_buf->u.skb = NULL;
+
+		gro_result = napi_gro_receive(napi, skb);
+	}
+
+	if (gro_result == GRO_NORMAL) {
+		channel->rx_alloc_level += RX_ALLOC_FACTOR_SKB;
+	} else if (gro_result != GRO_DROP) {
+		channel->rx_alloc_level += RX_ALLOC_FACTOR_GRO;
+		channel->irq_mod_score += 2;
 	}
 }
 
 void efx_rx_packet(struct efx_rx_queue *rx_queue, unsigned int index,
-		   unsigned int len, bool checksummed, bool discard)
+		   unsigned int len, u16 flags)
 {
 	struct efx_nic *efx = rx_queue->efx;
+	struct efx_channel *channel = efx_rx_queue_channel(rx_queue);
 	struct efx_rx_buffer *rx_buf;
 	bool leak_packet = false;
 
 	rx_buf = efx_rx_buffer(rx_queue, index);
-	EFX_BUG_ON_PARANOID(!rx_buf->data);
-	EFX_BUG_ON_PARANOID(rx_buf->skb && rx_buf->page);
-	EFX_BUG_ON_PARANOID(!(rx_buf->skb || rx_buf->page));
+	rx_buf->flags |= flags;
 
 	/* This allows the refill path to post another buffer.
 	 * EFX_RXD_HEAD_ROOM ensures that the slot we are using
@@ -517,24 +538,25 @@ void efx_rx_packet(struct efx_rx_queue *
 	rx_queue->removed_count++;
 
 	/* Validate the length encoded in the event vs the descriptor pushed */
-	efx_rx_packet__check_len(rx_queue, rx_buf, len,
-				 &discard, &leak_packet);
+	efx_rx_packet__check_len(rx_queue, rx_buf, len, &leak_packet);
 
-	EFX_TRACE(efx, "RX queue %d received id %x at %llx+%x %s%s\n",
-		  rx_queue->queue, index,
-		  (unsigned long long)rx_buf->dma_addr, len,
-		  (checksummed ? " [SUMMED]" : ""),
-		  (discard ? " [DISCARD]" : ""));
+	netif_vdbg(efx, rx_status, efx->net_dev,
+		   "RX queue %d received id %x at %llx+%x %s%s\n",
+		   efx_rx_queue_index(rx_queue), index,
+		   (unsigned long long)rx_buf->dma_addr, len,
+		   (rx_buf->flags & EFX_RX_PKT_CSUMMED) ? " [SUMMED]" : "",
+		   (rx_buf->flags & EFX_RX_PKT_DISCARD) ? " [DISCARD]" : "");
 
 	/* Discard packet, if instructed to do so */
-	if (unlikely(discard)) {
+	if (unlikely(rx_buf->flags & EFX_RX_PKT_DISCARD)) {
 		if (unlikely(leak_packet))
-			rx_queue->channel->n_skbuff_leaks++;
+			channel->n_skbuff_leaks++;
 		else
-			/* We haven't called efx_unmap_rx_buffer yet,
-			 * so fini the entire rx_buffer here */
-			efx_fini_rx_buffer(rx_queue, rx_buf);
-		return;
+			efx_recycle_rx_buffer(channel, rx_buf);
+
+		/* Don't hold off the previous receive */
+		rx_buf = NULL;
+		goto out;
 	}
 
 	/* Release card resources - assumes all RX buffers consumed in-order
@@ -545,92 +567,97 @@ void efx_rx_packet(struct efx_rx_queue *
 	/* Prefetch nice and early so data will (hopefully) be in cache by
 	 * the time we look at it.
 	 */
-	prefetch(rx_buf->data);
+	prefetch(efx_rx_buf_eh(efx, rx_buf));
 
 	/* Pipeline receives so that we give time for packet headers to be
 	 * prefetched into cache.
 	 */
-	rx_buf->len = len;
-	if (rx_queue->channel->rx_pkt)
-		__efx_rx_packet(rx_queue->channel,
-				rx_queue->channel->rx_pkt,
-				rx_queue->channel->rx_pkt_csummed);
-	rx_queue->channel->rx_pkt = rx_buf;
-	rx_queue->channel->rx_pkt_csummed = checksummed;
+	rx_buf->len = len - efx->rx_buffer_hash_size;
+out:
+	if (channel->rx_pkt)
+		__efx_rx_packet(channel, channel->rx_pkt);
+	channel->rx_pkt = rx_buf;
+}
+
+static void efx_rx_deliver(struct efx_channel *channel, u8 *eh,
+			   struct efx_rx_buffer *rx_buf)
+{
+	struct sk_buff *skb;
+
+	/* We now own the SKB */
+	EFX_BUG_ON_PARANOID(rx_buf->flags & EFX_RX_BUF_PAGE);
+	skb = rx_buf->u.skb;
+	rx_buf->u.skb = NULL;
+
+	/* Set the SKB flags */
+	skb->ip_summed = CHECKSUM_NONE;
+
+	skb_record_rx_queue(skb, channel->rx_queue.core_index);
+
+	/* Pass the packet up */
+	if (channel->type->receive_skb)
+		channel->type->receive_skb(channel, skb);
+	else
+		netif_receive_skb(skb);
+
+	/* Update allocation strategy method */
+	channel->rx_alloc_level += RX_ALLOC_FACTOR_SKB;
 }
 
 /* Handle a received packet.  Second half: Touches packet payload. */
-void __efx_rx_packet(struct efx_channel *channel,
-		     struct efx_rx_buffer *rx_buf, bool checksummed)
+void __efx_rx_packet(struct efx_channel *channel, struct efx_rx_buffer *rx_buf)
 {
 	struct efx_nic *efx = channel->efx;
-	enum efx_veto veto;
-	struct sk_buff *skb;
+	u8 *eh = efx_rx_buf_eh(efx, rx_buf);
 
 	/* If we're in loopback test, then pass the packet directly to the
 	 * loopback layer, and free the rx_buf here
 	 */
 	if (unlikely(efx->loopback_selftest)) {
-		efx_loopback_rx_packet(efx, rx_buf->data, rx_buf->len);
+		efx_loopback_rx_packet(efx, eh, rx_buf->len);
 		efx_free_rx_buffer(efx, rx_buf);
-		goto done;
+		return;
 	}
 
-	/* Allow callback to veto the packet */
-	veto = EFX_DL_CALLBACK(efx, rx_packet, rx_buf->data, rx_buf->len);
-	if (unlikely(veto)) {
-		EFX_DL_LOG(efx, "RX vetoed by driverlink %s driver\n",
-			   efx->dl_cb_dev.rx_packet->driver->name);
-		/* Free the buffer now */
-		efx_free_rx_buffer(efx, rx_buf);
-		goto done;
+	if (!(rx_buf->flags & EFX_RX_BUF_PAGE)) {
+		struct sk_buff *skb = rx_buf->u.skb;
+
+		prefetch(skb_shinfo(skb));
+		skb_reserve(skb, efx->rx_buffer_hash_size);
+		skb_put(skb, rx_buf->len);
+
+#if !defined(EFX_USE_KCOMPAT) || defined(EFX_HAVE_RXHASH_SUPPORT)
+		if (efx->net_dev->features & NETIF_F_RXHASH)
+			skb->rxhash = efx_rx_buf_hash(eh);
+#endif
+
+		/* Move past the ethernet header */
+		skb->protocol = eth_type_trans(skb, efx->net_dev);
+
+		skb_record_rx_queue(skb, channel->channel);
 	}
 
-	if (rx_buf->skb) {
-		prefetch(skb_shinfo(rx_buf->skb));
+	if (unlikely(!efx->rx_checksum_enabled))
+		rx_buf->flags &= ~EFX_RX_PKT_CSUMMED;
 
-		skb_put(rx_buf->skb, rx_buf->len);
-
-		/* Move past the ethernet header. rx_buf->data still points
-		 * at the ethernet header */
-		rx_buf->skb->protocol = eth_type_trans(rx_buf->skb,
-						       efx->net_dev);
-	}
-
-	if (likely(checksummed || rx_buf->page)) {
-		efx_rx_packet_lro(channel, rx_buf, checksummed);
-		goto done;
-	}
-
-	/* We now own the SKB */
-	skb = rx_buf->skb;
-	rx_buf->skb = NULL;
-
-	EFX_BUG_ON_PARANOID(rx_buf->page);
-	EFX_BUG_ON_PARANOID(rx_buf->skb);
-	EFX_BUG_ON_PARANOID(!skb);
-
-	/* Set the SKB flags */
-	skb->ip_summed = CHECKSUM_NONE;
-
-	skb_record_rx_queue(skb, channel->channel);
-
-	/* Pass the packet up */
-	netif_receive_skb(skb);
-
-	/* Update allocation strategy method */
-	channel->rx_alloc_level += RX_ALLOC_FACTOR_SKB;
-
-done:
-	;
+	if (likely(rx_buf->flags & (EFX_RX_BUF_PAGE | EFX_RX_PKT_CSUMMED)) &&
+	    !channel->type->receive_skb)
+		efx_rx_packet_gro(channel, rx_buf, eh);
+	else
+		efx_rx_deliver(channel, eh, rx_buf);
 }
 
 void efx_rx_strategy(struct efx_channel *channel)
 {
 	enum efx_rx_alloc_method method = rx_alloc_method;
 
-	/* Only makes sense to use page based allocation if LRO is enabled */
-	if (!(channel->efx->net_dev->features & NETIF_F_GRO)) {
+	if (channel->type->receive_skb) {
+		channel->rx_alloc_push_pages = 0;
+		return;
+	}
+
+	/* Only makes sense to use page based allocation if GRO is enabled */
+	if (!efx_gro_enabled(channel->efx)) {
 		method = RX_ALLOC_METHOD_SKB;
 	} else if (method == RX_ALLOC_METHOD_AUTO) {
 		/* Constrain the rx_alloc_level */
@@ -640,7 +667,7 @@ void efx_rx_strategy(struct efx_channel 
 			channel->rx_alloc_level = RX_ALLOC_LEVEL_MAX;
 
 		/* Decide on the allocation method */
-		method = ((channel->rx_alloc_level > RX_ALLOC_LEVEL_LRO) ?
+		method = ((channel->rx_alloc_level > RX_ALLOC_LEVEL_GRO) ?
 			  RX_ALLOC_METHOD_PAGE : RX_ALLOC_METHOD_SKB);
 	}
 
@@ -651,18 +678,26 @@ void efx_rx_strategy(struct efx_channel 
 int efx_probe_rx_queue(struct efx_rx_queue *rx_queue)
 {
 	struct efx_nic *efx = rx_queue->efx;
-	unsigned int rxq_size;
+	unsigned int entries;
 	int rc;
 
-	EFX_LOG(efx, "creating RX queue %d\n", rx_queue->queue);
+	/* Create the smallest power-of-two aligned ring */
+	entries = max(roundup_pow_of_two(efx->rxq_entries), EFX_MIN_DMAQ_SIZE);
+	EFX_BUG_ON_PARANOID(entries > EFX_MAX_DMAQ_SIZE);
+	rx_queue->ptr_mask = entries - 1;
+
+	netif_dbg(efx, probe, efx->net_dev,
+		  "creating RX queue %d size 0x%x mask 0x%x\n",
+		  efx_rx_queue_index(rx_queue), efx->rxq_entries,
+		  rx_queue->ptr_mask);
 
 	/* Allocate RX buffers */
-	rxq_size = (efx->type->rxd_ring_mask + 1) * sizeof(*rx_queue->buffer);
-	rx_queue->buffer = kzalloc(rxq_size, GFP_KERNEL);
+	rx_queue->buffer = kzalloc(entries * sizeof(*rx_queue->buffer),
+				   GFP_KERNEL);
 	if (!rx_queue->buffer)
 		return -ENOMEM;
 
-	rc = falcon_probe_rx(rx_queue);
+	rc = efx_nic_probe_rx(rx_queue);
 	if (rc) {
 		kfree(rx_queue->buffer);
 		rx_queue->buffer = NULL;
@@ -675,17 +710,17 @@ void efx_init_rx_queue(struct efx_rx_que
 	struct efx_nic *efx = rx_queue->efx;
 	unsigned int max_fill, trigger, limit;
 
-	EFX_LOG(rx_queue->efx, "initialising RX queue %d\n", rx_queue->queue);
+	netif_dbg(rx_queue->efx, drv, rx_queue->efx->net_dev,
+		  "initialising RX queue %d\n", efx_rx_queue_index(rx_queue));
 
 	/* Initialise ptr fields */
 	rx_queue->added_count = 0;
 	rx_queue->notified_count = 0;
 	rx_queue->removed_count = 0;
 	rx_queue->min_fill = -1U;
-	rx_queue->min_overfill = -1U;
 
 	/* Initialise limit fields */
-	max_fill = efx->type->rxd_ring_mask + 1 - EFX_RXD_HEAD_ROOM;
+	max_fill = efx->rxq_entries - EFX_RXD_HEAD_ROOM;
 	trigger = max_fill * min(rx_refill_threshold, 100U) / 100U;
 	limit = max_fill * min(rx_refill_limit, 100U) / 100U;
 
@@ -694,7 +729,8 @@ void efx_init_rx_queue(struct efx_rx_que
 	rx_queue->fast_fill_limit = limit;
 
 	/* Set up RX descriptor ring */
-	falcon_init_rx(rx_queue);
+	rx_queue->enabled = true;
+	efx_nic_init_rx(rx_queue);
 }
 
 void efx_fini_rx_queue(struct efx_rx_queue *rx_queue)
@@ -702,34 +738,30 @@ void efx_fini_rx_queue(struct efx_rx_que
 	int i;
 	struct efx_rx_buffer *rx_buf;
 
-	EFX_LOG(rx_queue->efx, "shutting down RX queue %d\n", rx_queue->queue);
+	netif_dbg(rx_queue->efx, drv, rx_queue->efx->net_dev,
+		  "shutting down RX queue %d\n", efx_rx_queue_index(rx_queue));
 
-	falcon_fini_rx(rx_queue);
+	/* A flush failure might have left rx_queue->enabled */
+	rx_queue->enabled = false;
+	
+	del_timer_sync(&rx_queue->slow_fill);
+	efx_nic_fini_rx(rx_queue);
 
 	/* Release RX buffers NB start at index 0 not current HW ptr */
 	if (rx_queue->buffer) {
-		for (i = 0; i <= rx_queue->efx->type->rxd_ring_mask; i++) {
+		for (i = 0; i <= rx_queue->ptr_mask; i++) {
 			rx_buf = efx_rx_buffer(rx_queue, i);
 			efx_fini_rx_buffer(rx_queue, rx_buf);
 		}
 	}
-
-	/* For a page that is part-way through splitting into RX buffers */
-	if (rx_queue->buf_page != NULL) {
-		pci_unmap_page(rx_queue->efx->pci_dev, rx_queue->buf_dma_addr,
-			       efx_rx_buf_size(rx_queue->efx),
-			       PCI_DMA_FROMDEVICE);
-		__free_pages(rx_queue->buf_page,
-			     rx_queue->efx->rx_buffer_order);
-		rx_queue->buf_page = NULL;
-	}
 }
 
 void efx_remove_rx_queue(struct efx_rx_queue *rx_queue)
 {
-	EFX_LOG(rx_queue->efx, "destroying RX queue %d\n", rx_queue->queue);
+	netif_dbg(rx_queue->efx, drv, rx_queue->efx->net_dev,
+		  "destroying RX queue %d\n", efx_rx_queue_index(rx_queue));
 
-	falcon_remove_rx(rx_queue);
+	efx_nic_remove_rx(rx_queue);
 
 	kfree(rx_queue->buffer);
 	rx_queue->buffer = NULL;
diff -r 9566a4a50a43 drivers/net/sfc/rx.h
--- a/drivers/net/sfc/rx.h
+++ /dev/null
@@ -1,26 +0,0 @@
-/****************************************************************************
- * Driver for Solarflare Solarstorm network controllers and boards
- * Copyright 2006 Solarflare Communications Inc.
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 as published
- * by the Free Software Foundation, incorporated herein by reference.
- */
-
-#ifndef EFX_RX_H
-#define EFX_RX_H
-
-#include "net_driver.h"
-
-int efx_probe_rx_queue(struct efx_rx_queue *rx_queue);
-void efx_remove_rx_queue(struct efx_rx_queue *rx_queue);
-void efx_init_rx_queue(struct efx_rx_queue *rx_queue);
-void efx_fini_rx_queue(struct efx_rx_queue *rx_queue);
-
-void efx_rx_strategy(struct efx_channel *channel);
-void efx_fast_push_rx_descriptors(struct efx_rx_queue *rx_queue);
-void efx_rx_work(struct work_struct *data);
-void __efx_rx_packet(struct efx_channel *channel,
-		     struct efx_rx_buffer *rx_buf, bool checksummed);
-
-#endif /* EFX_RX_H */
diff -r 9566a4a50a43 drivers/net/sfc/selftest.c
--- a/drivers/net/sfc/selftest.c
+++ b/drivers/net/sfc/selftest.c
@@ -1,7 +1,7 @@
 /****************************************************************************
  * Driver for Solarflare Solarstorm network controllers and boards
  * Copyright 2005-2006 Fen Systems Ltd.
- * Copyright 2006-2008 Solarflare Communications Inc.
+ * Copyright 2006-2010 Solarflare Communications Inc.
  *
  * This program is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 as published
@@ -18,17 +18,23 @@
 #include <linux/in.h>
 #include <linux/udp.h>
 #include <linux/rtnetlink.h>
+#include <linux/slab.h>
 #include <asm/io.h>
 #include "net_driver.h"
-#include "ethtool.h"
 #include "efx.h"
-#include "falcon.h"
+#include "nic.h"
 #include "selftest.h"
-#include "boards.h"
 #include "workarounds.h"
-#include "spi.h"
-#include "falcon_io.h"
-#include "mdio_10g.h"
+
+/* IRQ latency can be enormous because:
+ * - All IRQs may be disabled on a CPU for a *long* time by e.g. a
+ *   slow serial console or an old IDE driver doing error recovery
+ * - The PREEMPT_RT patches mostly deal with this, but also allow a
+ *   tasklet or normal task to be given higher priority than our IRQ
+ *   threads
+ * Try to avoid blaming the hardware for this.
+ */
+#define IRQ_TIMEOUT HZ
 
 /*
  * Loopback test packet structure
@@ -42,14 +48,14 @@ struct efx_loopback_payload {
 	struct udphdr udp;
 	__be16 iteration;
 	const char msg[64];
-} __attribute__ ((packed));
+} __packed;
 
 /* Loopback test source MAC address */
 static const unsigned char payload_source[ETH_ALEN] = {
 	0x00, 0x0f, 0x53, 0x1b, 0x1b, 0x1b,
 };
 
-static const char *payload_msg =
+static const char payload_msg[] =
 	"Hello world! This is an Efx loopback test in progress!";
 
 /**
@@ -57,6 +63,7 @@ static const char *payload_msg =
  * @flush:		Drop all packets in efx_loopback_rx_packet
  * @packet_count:	Number of packets being used in this test
  * @skbs:		An array of skbs transmitted
+ * @offload_csum:	Checksums are being offloaded
  * @rx_good:		RX good packet count
  * @rx_bad:		RX bad packet count
  * @payload:		Payload used in tests
@@ -65,76 +72,121 @@ struct efx_loopback_state {
 	bool flush;
 	int packet_count;
 	struct sk_buff **skbs;
-
-	/* Checksums are being offloaded */
 	bool offload_csum;
-
 	atomic_t rx_good;
 	atomic_t rx_bad;
 	struct efx_loopback_payload payload;
 };
 
+/* How long to wait for all the packets to arrive (in ms) */
+#define LOOPBACK_TIMEOUT_MS 1000
+
 /**************************************************************************
  *
  * MII, NVRAM and register tests
  *
  **************************************************************************/
 
-static int efx_test_mdio(struct efx_nic *efx, struct efx_self_tests *tests)
+static int efx_test_phy_alive(struct efx_nic *efx, struct efx_self_tests *tests)
 {
 	int rc = 0;
-	int devad = __ffs(efx->mdio.mmds);
-	u16 physid1, physid2;
 
-	if (efx->phy_type == PHY_TYPE_NONE)
-		return 0;
-
-	mutex_lock(&efx->mac_lock);
-	tests->mdio = -1;
-
-	physid1 = efx_mdio_read(efx, devad, MDIO_DEVID1);
-	physid2 = efx_mdio_read(efx, devad, MDIO_DEVID2);
-
-	if ((physid1 == 0x0000) || (physid1 == 0xffff) ||
-	    (physid2 == 0x0000) || (physid2 == 0xffff)) {
-		EFX_ERR(efx, "no MDIO PHY present with ID %d\n",
-			efx->mdio.prtad);
-		rc = -EINVAL;
-		goto out;
+	if (efx->phy_op->test_alive) {
+		rc = efx->phy_op->test_alive(efx);
+		netif_dbg(efx, drv, efx->net_dev, "%s PHY liveness selftest\n",
+			  rc ? "Failed" : "Passed");
+		tests->phy_alive = rc ? -1 : 1;
 	}
 
-	if (EFX_IS10G(efx)) {
-		rc = efx_mdio_check_mmds(efx, efx->phy_op->mmds, 0);
-		if (rc)
-			goto out;
-	}
-
-out:
-	mutex_unlock(&efx->mac_lock);
-	tests->mdio = rc ? -1 : 1;
 	return rc;
 }
 
 static int efx_test_nvram(struct efx_nic *efx, struct efx_self_tests *tests)
 {
-	int rc;
+	int rc = 0;
 
-	rc = falcon_read_nvram(efx, NULL);
-	tests->nvram = rc ? -1 : 1;
+	if (efx->type->test_nvram) {
+		rc = efx->type->test_nvram(efx);
+		tests->nvram = rc ? -1 : 1;
+	}
+
 	return rc;
 }
 
+static void memtest_simple(unsigned id, efx_qword_t *reg, int a, int b)
+{
+	EFX_POPULATE_QWORD_2(*reg, EFX_DWORD_0, a, EFX_DWORD_1, b);
+}
+
+static void memtest_changing_bytes(unsigned id, efx_qword_t *reg,
+				   int a, int b)
+{
+	int i;
+	u8 *byte;
+	for (i = 0; i < sizeof(efx_qword_t); i++) {
+		unsigned int addr = id * sizeof(efx_qword_t) + i;
+		byte = (u8 *)reg + i;
+		if ((addr >> 8) == 0)
+			*byte = (u8) (addr % 257);
+		else
+			*byte = (u8) ~((addr >> 8) % 257);
+
+		if (addr & 0x40)
+			*byte = ~*byte;
+	}
+}
+
+static void memtest_bit_sweep(unsigned int id, efx_qword_t *reg,
+			      int a, int b)
+{
+	int bit = id % 64;
+	int xor = (id & 64) ? ~0 : 0;
+
+	EFX_POPULATE_QWORD_2(*reg,
+			     EFX_DWORD_0, (bit < 32 ? bit : 0) ^ xor,
+			     EFX_DWORD_1, (bit >= 32 ? bit - 32 : 0) ^ xor);
+}
+
+struct memtest {
+	void (*pattern)(unsigned id, efx_qword_t *reg, int a, int b);
+	int a;
+	int b;
+};
+
+static struct memtest memtests[] = {
+	{memtest_simple, 0x55AA55AA, 0x55AA55AA},
+	{memtest_simple, 0xAA55AA55, 0xAA55AA55},
+	{memtest_changing_bytes, 0, 0},
+	{memtest_bit_sweep, 0, 0},
+};
+
 static int efx_test_chip(struct efx_nic *efx, struct efx_self_tests *tests)
 {
-	int rc;
+	int rc, i;
 
-	/* Not supported on A-series silicon */
-	if (falcon_rev(efx) < FALCON_REV_B0)
-		return 0;
+	/* Test SRAM and register tables */
+	if (efx->type->test_memory) {
+		for (i = 0; i < ARRAY_SIZE(memtests); ++i) {
+			rc = efx->type->test_memory(
+				efx, memtests[i].pattern,
+				memtests[i].a, memtests[i].b);
+			if (rc)
+				break;
+		}
+		netif_dbg(efx, drv, efx->net_dev, "%s memory selftest\n",
+			  rc ? "Failed" : "Passed");
+		tests->memory = rc ? -1 : 1;
+	}
 
-	rc = falcon_test_registers(efx);
-	tests->registers = rc ? -1 : 1;
-	return rc;
+	/* Test register access */
+	if (efx->type->test_registers) {
+		rc = efx->type->test_registers(efx);
+		netif_dbg(efx, drv, efx->net_dev, "%s register selftest\n",
+			  rc ? "Failed" : "Passed");
+		tests->registers = rc ? -1 : 1;
+	}
+
+	return (tests->memory >= 0 && tests->registers >= 0) ? 0 : -EIO;
 }
 
 /**************************************************************************
@@ -147,103 +199,117 @@ static int efx_test_chip(struct efx_nic 
 static int efx_test_interrupts(struct efx_nic *efx,
 			       struct efx_self_tests *tests)
 {
-	struct efx_channel *channel;
+	unsigned long timeout, wait;
+	int cpu;
 
-	EFX_LOG(efx, "testing interrupts\n");
+	netif_dbg(efx, drv, efx->net_dev, "testing interrupts\n");
 	tests->interrupt = -1;
 
-	/* Reset interrupt flag */
-	efx->last_irq_cpu = -1;
-	smp_wmb();
-
-	/* ACK each interrupting event queue. Receiving an interrupt due to
-	 * traffic before a test event is raised is considered a pass */
-	efx_for_each_channel(channel, efx) {
-		if (channel->work_pending)
-			efx_process_channel_now(channel);
-		if (efx->last_irq_cpu >= 0)
-			goto success;
-	}
-
-	falcon_generate_interrupt(efx);
+	efx_nic_irq_test_start(efx);
+	timeout = jiffies + IRQ_TIMEOUT;
+	wait = 1;
 
 	/* Wait for arrival of test interrupt. */
-	EFX_LOG(efx, "waiting for test interrupt\n");
-	schedule_timeout_uninterruptible(HZ / 10);
-	if (efx->last_irq_cpu >= 0)
-		goto success;
+	netif_dbg(efx, drv, efx->net_dev, "waiting for test interrupt\n");
+	do {
+		schedule_timeout_uninterruptible(wait);
+		cpu = efx_nic_irq_test_irq_cpu(efx);
+		if (cpu >= 0)
+			goto success;
+		wait *= 2;
+	} while (time_before(jiffies, timeout));
 
-	EFX_ERR(efx, "timed out waiting for interrupt\n");
+	netif_err(efx, drv, efx->net_dev, "timed out waiting for interrupt\n");
 	return -ETIMEDOUT;
 
  success:
-	EFX_LOG(efx, "test interrupt (mode %d) seen on CPU%d\n",
-		efx->interrupt_mode, efx->last_irq_cpu);
+	netif_dbg(efx, drv, efx->net_dev, "%s test interrupt seen on CPU%d\n",
+		  INT_MODE(efx), cpu);
 	tests->interrupt = 1;
 	return 0;
 }
 
 /* Test generation and receipt of interrupting events */
-static int efx_test_eventq_irq(struct efx_channel *channel,
+static int efx_test_eventq_irq(struct efx_nic *efx,
 			       struct efx_self_tests *tests)
 {
-	unsigned int magic, count;
+	struct efx_channel *channel;
+	unsigned int read_ptr[EFX_MAX_CHANNELS];
+	unsigned long napi_ran = 0, dma_pend = 0, int_pend = 0;
+	unsigned long timeout, wait;
 
-	/* Channel specific code, limited to 20 bits */
-	magic = (0x00010150 + channel->channel);
-	EFX_LOG(channel->efx, "channel %d testing event queue with code %x\n",
-		channel->channel, magic);
+	BUILD_BUG_ON(EFX_MAX_CHANNELS > BITS_PER_LONG);
 
-	tests->eventq_dma[channel->channel] = -1;
-	tests->eventq_int[channel->channel] = -1;
-	tests->eventq_poll[channel->channel] = -1;
-
-	/* Reset flag and zero magic word */
-	channel->efx->last_irq_cpu = -1;
-	channel->eventq_magic = 0;
-	smp_wmb();
-
-	falcon_generate_test_event(channel, magic);
-
-	/* Wait for arrival of interrupt */
-	count = 0;
-	do {
-		schedule_timeout_uninterruptible(HZ / 100);
-
-		if (channel->work_pending)
-			efx_process_channel_now(channel);
-
-		if (channel->eventq_magic == magic)
-			goto eventq_ok;
-	} while (++count < 2);
-
-	EFX_ERR(channel->efx, "channel %d timed out waiting for event queue\n",
-		channel->channel);
-
-	/* See if interrupt arrived */
-	if (channel->efx->last_irq_cpu >= 0) {
-		EFX_ERR(channel->efx, "channel %d saw interrupt on CPU%d "
-			"during event queue test\n", channel->channel,
-			raw_smp_processor_id());
-		tests->eventq_int[channel->channel] = 1;
+	efx_for_each_channel(channel, efx) {
+		read_ptr[channel->channel] = channel->eventq_read_ptr;
+		set_bit(channel->channel, &dma_pend);
+		set_bit(channel->channel, &int_pend);
+		efx_nic_event_test_start(channel);
 	}
 
-	/* Check to see if event was received even if interrupt wasn't */
-	efx_process_channel_now(channel);
-	if (channel->eventq_magic == magic) {
-		EFX_ERR(channel->efx, "channel %d event was generated, but "
-			"failed to trigger an interrupt\n", channel->channel);
-		tests->eventq_dma[channel->channel] = 1;
+	timeout = jiffies + IRQ_TIMEOUT;
+	wait = 1;
+
+	/* Wait for arrival of interrupts.  NAPI processing may or may
+	 * not complete in time, but we can cope in any case.
+	 */
+	do {
+		schedule_timeout_uninterruptible(wait);
+
+		efx_for_each_channel(channel, efx) {
+			napi_disable(&channel->napi_str);
+			if (channel->eventq_read_ptr !=
+			    read_ptr[channel->channel]) {
+				set_bit(channel->channel, &napi_ran);
+				clear_bit(channel->channel, &dma_pend);
+				clear_bit(channel->channel, &int_pend);
+			} else {
+				if (efx_nic_event_present(channel))
+					clear_bit(channel->channel, &dma_pend);
+				if (efx_nic_event_test_irq_cpu(channel) >= 0)
+					clear_bit(channel->channel, &int_pend);
+			}
+			napi_enable(&channel->napi_str);
+			efx_nic_eventq_read_ack(channel);
+		}
+
+		wait *= 2;
+	} while ((dma_pend || int_pend) && time_before(jiffies, timeout));
+
+	efx_for_each_channel(channel, efx) {
+		bool dma_seen = !test_bit(channel->channel, &dma_pend);
+		bool int_seen = !test_bit(channel->channel, &int_pend);
+
+		tests->eventq_dma[channel->channel] = dma_seen ? 1 : -1;
+		tests->eventq_int[channel->channel] = int_seen ? 1 : -1;
+
+		if (dma_seen && int_seen) {
+			netif_dbg(efx, drv, efx->net_dev,
+				  "channel %d event queue passed (with%s NAPI)\n",
+				  channel->channel,
+				  test_bit(channel->channel, &napi_ran) ?
+				  "" : "out");
+		} else {
+			/* Report failure and whether either interrupt or DMA
+			 * worked
+			 */
+			netif_err(efx, drv, efx->net_dev,
+				  "channel %d timed out waiting for event queue\n",
+				  channel->channel);
+			if (int_seen)
+				netif_err(efx, drv, efx->net_dev,
+					  "channel %d saw interrupt "
+					  "during event queue test\n",
+					  channel->channel);
+			if (dma_seen)
+				netif_err(efx, drv, efx->net_dev,
+					  "channel %d event was generated, but "
+					  "failed to trigger an interrupt\n",
+					  channel->channel);
+		}
 	}
 
-	return -ETIMEDOUT;
- eventq_ok:
-	EFX_LOG(channel->efx, "channel %d event queue passed\n",
-		channel->channel);
-	tests->eventq_dma[channel->channel] = 1;
-	tests->eventq_int[channel->channel] = 1;
-	tests->eventq_poll[channel->channel] = 1;
-	return 0;
+	return (dma_pend || int_pend) ? -ETIMEDOUT : 0;
 }
 
 static int efx_test_phy(struct efx_nic *efx, struct efx_self_tests *tests,
@@ -254,12 +320,11 @@ static int efx_test_phy(struct efx_nic *
 	if (!efx->phy_op->run_tests)
 		return 0;
 
-	EFX_BUG_ON_PARANOID(efx->phy_op->num_tests == 0 ||
-			    efx->phy_op->num_tests > EFX_MAX_PHY_TESTS);
-
 	mutex_lock(&efx->mac_lock);
-	rc = efx->phy_op->run_tests(efx, tests->phy, flags);
+	rc = efx->phy_op->run_tests(efx, tests->phy_ext, flags);
 	mutex_unlock(&efx->mac_lock);
+	netif_info(efx, drv, efx->net_dev,
+		   "%s phy selftest\n", rc ? "Failed" : "Passed");
 	return rc;
 }
 
@@ -295,62 +360,68 @@ void efx_loopback_rx_packet(struct efx_n
 
 	/* Check that header exists */
 	if (pkt_len < sizeof(received->header)) {
-		EFX_ERR(efx, "saw runt RX packet (length %d) in %s loopback "
-			"test\n", pkt_len, LOOPBACK_MODE(efx));
+		netif_err(efx, drv, efx->net_dev,
+			  "saw runt RX packet (length %d) in %s loopback "
+			  "test\n", pkt_len, LOOPBACK_MODE(efx));
 		goto err;
 	}
 
 	/* Check that the ethernet header exists */
 	if (memcmp(&received->header, &payload->header, ETH_HLEN) != 0) {
-		EFX_ERR(efx, "saw non-loopback RX packet in %s loopback test\n",
-			LOOPBACK_MODE(efx));
+		netif_err(efx, drv, efx->net_dev,
+			  "saw non-loopback RX packet in %s loopback test\n",
+			  LOOPBACK_MODE(efx));
 		goto err;
 	}
 
 	/* Check packet length */
 	if (pkt_len != sizeof(*payload)) {
-		EFX_ERR(efx, "saw incorrect RX packet length %d (wanted %d) in "
-			"%s loopback test\n", pkt_len, (int)sizeof(*payload),
-			LOOPBACK_MODE(efx));
+		netif_err(efx, drv, efx->net_dev,
+			  "saw incorrect RX packet length %d (wanted %d) in "
+			  "%s loopback test\n", pkt_len, (int)sizeof(*payload),
+			  LOOPBACK_MODE(efx));
 		goto err;
 	}
 
 	/* Check that IP header matches */
 	if (memcmp(&received->ip, &payload->ip, sizeof(payload->ip)) != 0) {
-		EFX_ERR(efx, "saw corrupted IP header in %s loopback test\n",
-			LOOPBACK_MODE(efx));
+		netif_err(efx, drv, efx->net_dev,
+			  "saw corrupted IP header in %s loopback test\n",
+			  LOOPBACK_MODE(efx));
 		goto err;
 	}
 
 	/* Check that msg and padding matches */
 	if (memcmp(&received->msg, &payload->msg, sizeof(received->msg)) != 0) {
-		EFX_ERR(efx, "saw corrupted RX packet in %s loopback test\n",
-			LOOPBACK_MODE(efx));
+		netif_err(efx, drv, efx->net_dev,
+			  "saw corrupted RX packet in %s loopback test\n",
+			  LOOPBACK_MODE(efx));
 		goto err;
 	}
 
 	/* Check that iteration matches */
 	if (received->iteration != payload->iteration) {
-		EFX_ERR(efx, "saw RX packet from iteration %d (wanted %d) in "
-			"%s loopback test\n", ntohs(received->iteration),
-			ntohs(payload->iteration), LOOPBACK_MODE(efx));
+		netif_err(efx, drv, efx->net_dev,
+			  "saw RX packet from iteration %d (wanted %d) in "
+			  "%s loopback test\n", ntohs(received->iteration),
+			  ntohs(payload->iteration), LOOPBACK_MODE(efx));
 		goto err;
 	}
 
 	/* Increase correct RX count */
-	EFX_TRACE(efx, "got loopback RX in %s loopback test\n",
-		  LOOPBACK_MODE(efx));
+	netif_vdbg(efx, drv, efx->net_dev,
+		   "got loopback RX in %s loopback test\n", LOOPBACK_MODE(efx));
 
 	atomic_inc(&state->rx_good);
 	return;
 
  err:
-#ifdef EFX_ENABLE_DEBUG
+#ifdef DEBUG
 	if (atomic_read(&state->rx_bad) == 0) {
-		EFX_ERR(efx, "received packet:\n");
+		netif_err(efx, drv, efx->net_dev, "received packet:\n");
 		print_hex_dump(KERN_ERR, "", DUMP_PREFIX_OFFSET, 0x10, 1,
 			       buf_ptr, pkt_len, 0);
-		EFX_ERR(efx, "expected packet:\n");
+		netif_err(efx, drv, efx->net_dev, "expected packet:\n");
 		print_hex_dump(KERN_ERR, "", DUMP_PREFIX_OFFSET, 0x10, 1,
 			       &state->payload, sizeof(state->payload), 0);
 	}
@@ -424,22 +495,21 @@ static int efx_begin_loopback(struct efx
 		 * interrupt handler. */
 		smp_wmb();
 
-		if (efx_dev_registered(efx))
-			netif_tx_lock_bh(efx->net_dev);
-		rc = efx_xmit(efx, tx_queue, skb);
-		if (efx_dev_registered(efx))
-			netif_tx_unlock_bh(efx->net_dev);
+		netif_tx_lock_bh(efx->net_dev);
+		rc = efx_enqueue_skb(tx_queue, skb);
+		netif_tx_unlock_bh(efx->net_dev);
 
 		if (rc != NETDEV_TX_OK) {
-			EFX_ERR(efx, "TX queue %d could not transmit packet %d "
-				"of %d in %s loopback test\n", tx_queue->queue,
-				i + 1, state->packet_count, LOOPBACK_MODE(efx));
+			netif_err(efx, drv, efx->net_dev,
+				  "TX queue %d could not transmit packet %d of "
+				  "%d in %s loopback test\n", tx_queue->queue,
+				  i + 1, state->packet_count,
+				  LOOPBACK_MODE(efx));
 
 			/* Defer cleaning up the other skbs for the caller */
 			kfree_skb(skb);
 			return -EPIPE;
 		}
-		efx->net_dev->trans_start = jiffies;
 	}
 
 	return 0;
@@ -468,8 +538,7 @@ static int efx_end_loopback(struct efx_t
 	int tx_done = 0, rx_good, rx_bad;
 	int i, rc = 0;
 
-	if (efx_dev_registered(efx))
-		netif_tx_lock_bh(efx->net_dev);
+	netif_tx_lock_bh(efx->net_dev);
 
 	/* Count the number of tx completions, and decrement the refcnt. Any
 	 * skbs not already completed will be free'd when the queue is flushed */
@@ -480,8 +549,7 @@ static int efx_end_loopback(struct efx_t
 		dev_kfree_skb_any(skb);
 	}
 
-	if (efx_dev_registered(efx))
-		netif_tx_unlock_bh(efx->net_dev);
+	netif_tx_unlock_bh(efx->net_dev);
 
 	/* Check TX completion and received packet counts */
 	rx_good = atomic_read(&state->rx_good);
@@ -490,20 +558,22 @@ static int efx_end_loopback(struct efx_t
 		/* Don't free the skbs; they will be picked up on TX
 		 * overflow or channel teardown.
 		 */
-		EFX_ERR(efx, "TX queue %d saw only %d out of an expected %d "
-			"TX completion events in %s loopback test\n",
-			tx_queue->queue, tx_done, state->packet_count,
-			LOOPBACK_MODE(efx));
+		netif_err(efx, drv, efx->net_dev,
+			  "TX queue %d saw only %d out of an expected %d "
+			  "TX completion events in %s loopback test\n",
+			  tx_queue->queue, tx_done, state->packet_count,
+			  LOOPBACK_MODE(efx));
 		rc = -ETIMEDOUT;
 		/* Allow to fall through so we see the RX errors as well */
 	}
 
 	/* We may always be up to a flush away from our desired packet total */
 	if (rx_good != state->packet_count) {
-		EFX_LOG(efx, "TX queue %d saw only %d out of an expected %d "
-			"received packets in %s loopback test\n",
-			tx_queue->queue, rx_good, state->packet_count,
-			LOOPBACK_MODE(efx));
+		netif_dbg(efx, drv, efx->net_dev,
+			  "TX queue %d saw only %d out of an expected %d "
+			  "received packets in %s loopback test\n",
+			  tx_queue->queue, rx_good, state->packet_count,
+			  LOOPBACK_MODE(efx));
 		rc = -ETIMEDOUT;
 		/* Fall through */
 	}
@@ -527,7 +597,7 @@ efx_test_loopback(struct efx_tx_queue *t
 
 	for (i = 0; i < 3; i++) {
 		/* Determine how many packets to send */
-		state->packet_count = (efx->type->txd_ring_mask + 1) / 3;
+		state->packet_count = efx->txq_entries / 3;
 		state->packet_count = min(1 << (i << 2), state->packet_count);
 		state->skbs = kzalloc(sizeof(state->skbs[0]) *
 				      state->packet_count, GFP_KERNEL);
@@ -535,18 +605,19 @@ efx_test_loopback(struct efx_tx_queue *t
 			return -ENOMEM;
 		state->flush = false;
 
-		EFX_LOG(efx, "TX queue %d testing %s loopback with %d "
-			"packets\n", tx_queue->queue, LOOPBACK_MODE(efx),
-			state->packet_count);
+		netif_dbg(efx, drv, efx->net_dev,
+			  "TX queue %d testing %s loopback with %d packets\n",
+			  tx_queue->queue, LOOPBACK_MODE(efx),
+			  state->packet_count);
 
 		efx_iterate_state(efx);
 		begin_rc = efx_begin_loopback(tx_queue);
 
 		/* This will normally complete very quickly, but be
-		 * prepared to wait up to 100 ms. */
+		 * prepared to wait much longer. */
 		msleep(1);
 		if (!efx_poll_loopback(efx)) {
-			msleep(100);
+			msleep(LOOPBACK_TIMEOUT_MS);
 			efx_poll_loopback(efx);
 		}
 
@@ -561,21 +632,63 @@ efx_test_loopback(struct efx_tx_queue *t
 		}
 	}
 
-	EFX_LOG(efx, "TX queue %d passed %s loopback test with a burst length "
-		"of %d packets\n", tx_queue->queue, LOOPBACK_MODE(efx),
-		state->packet_count);
+	netif_dbg(efx, drv, efx->net_dev,
+		  "TX queue %d passed %s loopback test with a burst length "
+		  "of %d packets\n", tx_queue->queue, LOOPBACK_MODE(efx),
+		  state->packet_count);
 
 	return 0;
 }
 
+/* Wait for link up. On Falcon, we would prefer to rely on efx_monitor, but
+ * any contention on the mac lock (via e.g. efx_mac_mcast_work) causes it
+ * to delay and retry. Therefore, it's safer to just poll directly. Wait
+ * for link up and any faults to dissipate. */
+static int efx_wait_for_link(struct efx_nic *efx)
+{
+	struct efx_link_state *link_state = &efx->link_state;
+	int count, link_up_count = 0;
+	bool link_up;
+
+	for (count = 0; count < 40; count++) {
+		schedule_timeout_uninterruptible(HZ / 10);
+
+		if (efx->type->monitor != NULL) {
+			mutex_lock(&efx->mac_lock);
+			efx->type->monitor(efx);
+			mutex_unlock(&efx->mac_lock);
+		} else {
+			struct efx_channel *channel = efx_get_channel(efx, 0);
+			if (channel->work_pending)
+				efx_process_channel_now(channel);
+		}
+
+		mutex_lock(&efx->mac_lock);
+		link_up = link_state->up;
+		if (link_up)
+			link_up = !efx->type->check_mac_fault(efx);
+		mutex_unlock(&efx->mac_lock);
+
+		if (link_up) {
+			if (++link_up_count == 2)
+				return 0;
+		} else {
+			link_up_count = 0;
+		}
+	}
+
+	return -ETIMEDOUT;
+}
+
 static int efx_test_loopbacks(struct efx_nic *efx, struct efx_self_tests *tests,
 			      unsigned int loopback_modes)
 {
 	enum efx_loopback_mode mode;
 	struct efx_loopback_state *state;
+	struct efx_channel *channel = efx_get_channel(efx, 0);
 	struct efx_tx_queue *tx_queue;
-	bool link_up;
-	int count, rc = 0;
+	int rc = 0;
+	bool retry;
 
 	/* Set the port loopback_selftest member. From this point on
 	 * all received packets will be dropped. Mark the state as
@@ -592,56 +705,58 @@ static int efx_test_loopbacks(struct efx
 		if (!(loopback_modes & (1 << mode)))
 			continue;
 
+		retry = EFX_WORKAROUND_8568(efx);
+	set_loopback:
 		/* Move the port into the specified loopback mode. */
 		state->flush = true;
+		mutex_lock(&efx->mac_lock);
 		efx->loopback_mode = mode;
-		efx_reconfigure_port(efx);
-
-		/* Wait for the PHY to signal the link is up. Interrupts
-		 * are enabled for PHY's using LASI, otherwise we poll()
-		 * quickly */
-		count = 0;
-		do {
-			struct efx_channel *channel = &efx->channel[0];
-
-			efx->phy_op->poll(efx);
-			schedule_timeout_uninterruptible(HZ / 10);
-			if (channel->work_pending)
-				efx_process_channel_now(channel);
-			/* Wait for PHY events to be processed */
-			flush_workqueue(efx->workqueue);
-			rmb();
-
-			/* We need both the phy and xaui links to be ok.
-			 * rather than relying on the falcon_xmac irq/poll
-			 * regime, just poll xaui directly */
-			link_up = efx->link_up;
-			if (link_up && EFX_IS10G(efx) &&
-			    !falcon_xaui_link_ok(efx))
-				link_up = false;
-
-		} while ((++count < 20) && !link_up);
-
-		/* The link should now be up. If it isn't, there is no point
-		 * in attempting a loopback test */
-		if (!link_up) {
-			EFX_ERR(efx, "loopback %s never came up\n",
-				LOOPBACK_MODE(efx));
-			rc = -EIO;
+		rc = __efx_reconfigure_port(efx);
+		mutex_unlock(&efx->mac_lock);
+		if (rc) {
+			netif_err(efx, drv, efx->net_dev,
+				  "unable to move into %s loopback\n",
+				  LOOPBACK_MODE(efx));
 			goto out;
 		}
 
-		EFX_LOG(efx, "link came up in %s loopback in %d iterations\n",
-			LOOPBACK_MODE(efx), count);
+		rc = efx_wait_for_link(efx);
+		if (rc) {
+			netif_err(efx, drv, efx->net_dev,
+				  "loopback %s never came up\n",
+				  LOOPBACK_MODE(efx));
+			goto out;
+		}
 
-		/* Test every TX queue */
-		efx_for_each_tx_queue(tx_queue, efx) {
-			state->offload_csum = (tx_queue->queue ==
-					       EFX_TX_QUEUE_OFFLOAD_CSUM);
+		/* Test both types of TX queue */
+		efx_for_each_channel_tx_queue(tx_queue, channel) {
+			state->offload_csum = (tx_queue->queue &
+					       EFX_TXQ_TYPE_OFFLOAD);
 			rc = efx_test_loopback(tx_queue,
 					       &tests->loopback[mode]);
-			if (rc)
+			if (rc && !retry)
 				goto out;
+			if (rc) {
+				/* Give the PHY a kick by moving into
+				 * a Falcon internal loopback mode and
+				 * then back out */
+				int first = ffs(efx->loopback_modes) - 1;
+
+				netif_info(efx, drv, efx->net_dev,
+					   "retrying %s loopback\n",
+					   LOOPBACK_MODE(efx));
+
+				state->flush = true;
+				mutex_lock(&efx->mac_lock);
+				efx->loopback_mode = first;
+				__efx_reconfigure_port(efx);
+				mutex_unlock(&efx->mac_lock);
+
+				memset(&tests->loopback[mode], 0,
+				       sizeof(tests->loopback[mode]));
+				retry = false;
+				goto set_loopback;
+			}
 		}
 	}
 
@@ -667,14 +782,14 @@ int efx_selftest(struct efx_nic *efx, st
 	enum efx_loopback_mode loopback_mode = efx->loopback_mode;
 	int phy_mode = efx->phy_mode;
 	enum reset_type reset_method = RESET_TYPE_INVISIBLE;
-	struct ethtool_cmd ecmd;
-	struct efx_channel *channel;
 	int rc_test = 0, rc_reset = 0, rc;
 
+	efx_selftest_async_cancel(efx);
+
 	/* Online (i.e. non-disruptive) testing
 	 * This checks interrupt generation, event delivery and PHY presence. */
 
-	rc = efx_test_mdio(efx, tests);
+	rc = efx_test_phy_alive(efx, tests);
 	if (rc && !rc_test)
 		rc_test = rc;
 
@@ -686,11 +801,9 @@ int efx_selftest(struct efx_nic *efx, st
 	if (rc && !rc_test)
 		rc_test = rc;
 
-	efx_for_each_channel(channel, efx) {
-		rc = efx_test_eventq_irq(channel, tests);
-		if (rc && !rc_test)
-			rc_test = rc;
-	}
+	rc = efx_test_eventq_irq(efx, tests);
+	if (rc && !rc_test)
+		rc_test = rc;
 
 	if (rc_test)
 		return rc_test;
@@ -701,12 +814,12 @@ int efx_selftest(struct efx_nic *efx, st
 	/* Offline (i.e. disruptive) testing
 	 * This checks MAC and PHY loopback on the specified port. */
 
-	/* force the carrier state off so the kernel doesn't transmit during
-	 * the loopback test, and the watchdog timeout doesn't fire. Also put
-	 * falcon into loopback for the register test.
+	/* Detach the device so the kernel doesn't transmit during the
+	 * loopback test and the watchdog timeout doesn't fire.
 	 */
+	netif_device_detach(efx->net_dev);
+
 	mutex_lock(&efx->mac_lock);
-	efx->port_inhibited = true;
 	if (efx->loopback_modes) {
 		/* We need the 312 clock from the PHY to test the XMAC
 		 * registers, so move into XGMII loopback if available */
@@ -720,26 +833,29 @@ int efx_selftest(struct efx_nic *efx, st
 	mutex_unlock(&efx->mac_lock);
 
 	/* free up all consumers of SRAM (including all the queues) */
-	efx_reset_down(efx, reset_method, &ecmd);
+	efx_dl_reset_suspend(efx);
+	efx_reset_down(efx, reset_method);
 
 	rc = efx_test_chip(efx, tests);
 	if (rc && !rc_test)
 		rc_test = rc;
 
 	/* reset the chip to recover from the register test */
-	rc_reset = falcon_reset_hw(efx, reset_method);
+	rc_reset = efx->type->reset(efx, reset_method);
 
 	/* Ensure that the phy is powered and out of loopback
 	 * for the bist and loopback tests */
 	efx->phy_mode &= ~PHY_MODE_LOW_POWER;
 	efx->loopback_mode = LOOPBACK_NONE;
 
-	rc = efx_reset_up(efx, reset_method, &ecmd, rc_reset == 0);
+	rc = efx_reset_up(efx, reset_method, rc_reset == 0);
 	if (rc && !rc_reset)
 		rc_reset = rc;
+	efx_dl_reset_resume(efx, rc_reset == 0);
 
 	if (rc_reset) {
-		EFX_ERR(efx, "Unable to recover from chip test\n");
+		netif_err(efx, hw, efx->net_dev,
+			  "Unable to recover from chip test\n");
 		efx_schedule_reset(efx, RESET_TYPE_DISABLE);
 		return rc_reset;
 	}
@@ -753,11 +869,47 @@ int efx_selftest(struct efx_nic *efx, st
 		rc_test = rc;
 
 	/* restore the PHY to the previous state */
+	mutex_lock(&efx->mac_lock);
+	efx->phy_mode = phy_mode;
 	efx->loopback_mode = loopback_mode;
-	efx->phy_mode = phy_mode;
-	efx->port_inhibited = false;
-	efx_ethtool_set_settings(efx->net_dev, &ecmd);
+	__efx_reconfigure_port(efx);
+	mutex_unlock(&efx->mac_lock);
+
+	netif_device_attach(efx->net_dev);
 
 	return rc_test;
 }
 
+void efx_selftest_async_start(struct efx_nic *efx)
+{
+	struct efx_channel *channel;
+
+	efx_for_each_channel(channel, efx)
+		efx_nic_event_test_start(channel);
+	schedule_delayed_work(&efx->selftest_work, IRQ_TIMEOUT);
+}
+
+void efx_selftest_async_cancel(struct efx_nic *efx)
+{
+	cancel_delayed_work_sync(&efx->selftest_work);
+}
+
+void efx_selftest_async_work(struct work_struct *data)
+{
+	struct efx_nic *efx = container_of(data, struct efx_nic,
+					   selftest_work.work);
+	struct efx_channel *channel;
+	int cpu;
+
+	efx_for_each_channel(channel, efx) {
+		cpu = efx_nic_event_test_irq_cpu(channel);
+		if (cpu < 0)
+			netif_err(efx, ifup, efx->net_dev,
+				  "channel %d failed to trigger an interrupt\n",
+				  channel->channel);
+		else
+			netif_dbg(efx, ifup, efx->net_dev,
+				  "channel %d triggered interrupt on CPU %d\n",
+				  channel->channel, cpu);
+	}
+}
diff -r 9566a4a50a43 drivers/net/sfc/selftest.h
--- a/drivers/net/sfc/selftest.h
+++ b/drivers/net/sfc/selftest.h
@@ -1,7 +1,7 @@
 /****************************************************************************
  * Driver for Solarflare Solarstorm network controllers and boards
  * Copyright 2005-2006 Fen Systems Ltd.
- * Copyright 2006-2008 Solarflare Communications Inc.
+ * Copyright 2006-2010 Solarflare Communications Inc.
  *
  * This program is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 as published
@@ -18,8 +18,8 @@
  */
 
 struct efx_loopback_self_tests {
-	int tx_sent[EFX_TX_QUEUE_COUNT];
-	int tx_done[EFX_TX_QUEUE_COUNT];
+	int tx_sent[EFX_TXQ_TYPES];
+	int tx_done[EFX_TXQ_TYPES];
 	int rx_good;
 	int rx_bad;
 };
@@ -32,15 +32,15 @@ struct efx_loopback_self_tests {
  */
 struct efx_self_tests {
 	/* online tests */
-	int mdio;
+	int phy_alive;
 	int nvram;
 	int interrupt;
 	int eventq_dma[EFX_MAX_CHANNELS];
 	int eventq_int[EFX_MAX_CHANNELS];
-	int eventq_poll[EFX_MAX_CHANNELS];
 	/* offline tests */
+	int memory;
 	int registers;
-	int phy[EFX_MAX_PHY_TESTS];
+	int phy_ext[EFX_MAX_PHY_TESTS];
 	struct efx_loopback_self_tests loopback[LOOPBACK_TEST_MAX + 1];
 };
 
@@ -49,5 +49,8 @@ extern void efx_loopback_rx_packet(struc
 extern int efx_selftest(struct efx_nic *efx,
 			struct efx_self_tests *tests,
 			unsigned flags);
+extern void efx_selftest_async_start(struct efx_nic *efx);
+extern void efx_selftest_async_cancel(struct efx_nic *efx);
+extern void efx_selftest_async_work(struct work_struct *data);
 
 #endif /* EFX_SELFTEST_H */
diff -r 9566a4a50a43 drivers/net/sfc/sfc_resource/Makefile
--- a/drivers/net/sfc/sfc_resource/Makefile
+++ /dev/null
@@ -1,14 +0,0 @@
-obj-$(CONFIG_SFC_RESOURCE) := sfc_resource.o
-
-EXTRA_CFLAGS += -D__CI_HARDWARE_CONFIG_FALCON__
-EXTRA_CFLAGS += -D__ci_driver__
-EXTRA_CFLAGS += -Werror
-EXTRA_CFLAGS += -Idrivers/net/sfc -Idrivers/net/sfc/sfc_resource
-
-sfc_resource-objs := resource_driver.o iopage.o efx_vi_shm.o \
-	driverlink_new.o kernel_proc.o kfifo.o \
-	nic.o eventq.o falcon.o falcon_hash.o \
-	assert_valid.o buddy.o buffer_table.o filter_resource.o \
-	iobufset_resource.o resource_manager.o resources.o \
-	vi_resource_alloc.o vi_resource_event.o vi_resource_flush.o \
-	vi_resource_manager.o driver_object.o kernel_compat.o
diff -r 9566a4a50a43 drivers/net/sfc/sfc_resource/assert_valid.c
--- a/drivers/net/sfc/sfc_resource/assert_valid.c
+++ /dev/null
@@ -1,92 +0,0 @@
-/****************************************************************************
- * Driver for Solarflare network controllers -
- *          resource management for Xen backend, OpenOnload, etc
- *           (including support for SFE4001 10GBT NIC)
- *
- * This file contains functions to assert validness of resources and
- * resource manager in DEBUG build of the resource driver.
- *
- * Copyright 2005-2007: Solarflare Communications Inc,
- *                      9501 Jeronimo Road, Suite 250,
- *                      Irvine, CA 92618, USA
- *
- * Developed and maintained by Solarflare Communications:
- *                      <linux-xen-drivers@solarflare.com>
- *                      <onload-dev@solarflare.com>
- *
- * Certain parts of the driver were implemented by
- *          Alexandra Kossovsky <Alexandra.Kossovsky@oktetlabs.ru>
- *          OKTET Labs Ltd, Russia,
- *          http://oktetlabs.ru, <info@oktetlabs.ru>
- *          by request of Solarflare Communications
- *
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 as published
- * by the Free Software Foundation, incorporated herein by reference.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
- ****************************************************************************
- */
-
-#include <ci/efrm/sysdep.h>
-
-#ifndef NDEBUG
-#include <ci/efrm/resource.h>
-#include <ci/efrm/driver_private.h>
-#include <ci/efrm/debug.h>
-
-void
-efrm_resource_manager_assert_valid(struct efrm_resource_manager *rm,
-				   const char *file, int line)
-{
-	_EFRM_ASSERT(rm, file, line);
-	_EFRM_ASSERT(rm->rm_name, file, line);
-	_EFRM_ASSERT(rm->rm_type < EFRM_RESOURCE_NUM, file, line);
-	_EFRM_ASSERT(rm->rm_dtor, file, line);
-}
-EXPORT_SYMBOL(efrm_resource_manager_assert_valid);
-
-/*
- * \param rs                    resource to validate
- * \param ref_count_is_zero     One of 3 values
- *                                > 0  - check ref count is zero
- *                                = 0  - check ref count is non-zero
- *                                < 0  - ref count could be any value
- */
-void
-efrm_resource_assert_valid(struct efrm_resource *rs, int ref_count_is_zero,
-			   const char *file, int line)
-{
-	struct efrm_resource_manager *rm;
-
-	_EFRM_ASSERT(rs, file, line);
-
-	if (ref_count_is_zero >= 0) {
-		if (!(ref_count_is_zero || rs->rs_ref_count > 0)
-		    || !(!ref_count_is_zero || rs->rs_ref_count == 0))
-			EFRM_WARN("%s: check %szero ref=%d " EFRM_RESOURCE_FMT,
-				  __func__,
-				  ref_count_is_zero == 0 ? "non-" : "",
-				  rs->rs_ref_count,
-				  EFRM_RESOURCE_PRI_ARG(rs->rs_handle));
-
-		_EFRM_ASSERT(!(ref_count_is_zero == 0) ||
-			     rs->rs_ref_count != 0, file, line);
-		_EFRM_ASSERT(!(ref_count_is_zero > 0) ||
-			     rs->rs_ref_count == 0, file, line);
-	}
-
-	rm = efrm_rm_table[EFRM_RESOURCE_TYPE(rs->rs_handle)];
-	efrm_resource_manager_assert_valid(rm, file, line);
-}
-EXPORT_SYMBOL(efrm_resource_assert_valid);
-
-#endif
diff -r 9566a4a50a43 drivers/net/sfc/sfc_resource/buddy.c
--- a/drivers/net/sfc/sfc_resource/buddy.c
+++ /dev/null
@@ -1,220 +0,0 @@
-
-/****************************************************************************
- * Driver for Solarflare network controllers -
- *          resource management for Xen backend, OpenOnload, etc
- *           (including support for SFE4001 10GBT NIC)
- *
- * This file contains implementation of a buddy allocator.
- *
- * Copyright 2005-2007: Solarflare Communications Inc,
- *                      9501 Jeronimo Road, Suite 250,
- *                      Irvine, CA 92618, USA
- *
- * Developed and maintained by Solarflare Communications:
- *                      <linux-xen-drivers@solarflare.com>
- *                      <onload-dev@solarflare.com>
- *
- * Certain parts of the driver were implemented by
- *          Alexandra Kossovsky <Alexandra.Kossovsky@oktetlabs.ru>
- *          OKTET Labs Ltd, Russia,
- *          http://oktetlabs.ru, <info@oktetlabs.ru>
- *          by request of Solarflare Communications
- *
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 as published
- * by the Free Software Foundation, incorporated herein by reference.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
- ****************************************************************************
- */
-
-#include <ci/efhw/common.h> /* get uintXX types on win32 */
-#include <ci/efrm/sysdep.h>
-#include <ci/efrm/buddy.h>
-#include <ci/efrm/debug.h>
-
-#if 1
-#define DEBUG_ALLOC(x)
-#else
-#define DEBUG_ALLOC(x) x
-
-static inline void efrm_buddy_dump(struct efrm_buddy_allocator *b)
-{
-	unsigned o;
-
-	EFRM_NOTICE("%s: dump allocator with order %u",
-		    __func__, b->order);
-	for (o = 0; o <= b->order; o++) {
-		struct list_head *l = &b->free_lists[o];
-		while (l->next != &b->free_lists[o]) {
-			l = l->next;
-			EFRM_NOTICE("%s: order %x: %zx", __func__, o,
-				    l - b->links);
-		}
-	}
-}
-#endif
-
-/*
- * The purpose of the following inline functions is to give the
- * understandable names to the simple actions.
- */
-static inline void
-efrm_buddy_free_list_add(struct efrm_buddy_allocator *b,
-			 unsigned order, unsigned addr)
-{
-	list_add(&b->links[addr], &b->free_lists[order]);
-	b->orders[addr] = (uint8_t) order;
-}
-static inline void
-efrm_buddy_free_list_del(struct efrm_buddy_allocator *b, unsigned addr)
-{
-	list_del(&b->links[addr]);
-	b->links[addr].next = NULL;
-}
-static inline int
-efrm_buddy_free_list_empty(struct efrm_buddy_allocator *b, unsigned order)
-{
-	return list_empty(&b->free_lists[order]);
-}
-static inline unsigned
-efrm_buddy_free_list_pop(struct efrm_buddy_allocator *b, unsigned order)
-{
-	struct list_head *l = list_pop(&b->free_lists[order]);
-	l->next = NULL;
-	return (unsigned)(l - b->links);
-}
-static inline int
-efrm_buddy_addr_in_free_list(struct efrm_buddy_allocator *b, unsigned addr)
-{
-	return b->links[addr].next != NULL;
-}
-static inline unsigned
-efrm_buddy_free_list_first(struct efrm_buddy_allocator *b, unsigned order)
-{
-	return (unsigned)(b->free_lists[order].next - b->links);
-}
-
-int efrm_buddy_ctor(struct efrm_buddy_allocator *b, unsigned order)
-{
-	unsigned o;
-	unsigned size = 1 << order;
-
-	DEBUG_ALLOC(EFRM_NOTICE("%s(%u)", __func__, order));
-	EFRM_ASSERT(b);
-	EFRM_ASSERT(order <= sizeof(unsigned) * 8 - 1);
-
-	b->order = order;
-	b->free_lists = vmalloc((order + 1) * sizeof(struct list_head));
-	if (b->free_lists == NULL)
-		goto fail1;
-
-	b->links = vmalloc(size * sizeof(struct list_head));
-	if (b->links == NULL)
-		goto fail2;
-
-	b->orders = vmalloc(size);
-	if (b->orders == NULL)
-		goto fail3;
-
-	memset(b->links, 0, size * sizeof(struct list_head));
-
-	for (o = 0; o <= b->order; ++o)
-		INIT_LIST_HEAD(b->free_lists + o);
-
-	efrm_buddy_free_list_add(b, b->order, 0);
-
-	return 0;
-
-fail3:
-	vfree(b->links);
-fail2:
-	vfree(b->free_lists);
-fail1:
-	return -ENOMEM;
-}
-
-void efrm_buddy_dtor(struct efrm_buddy_allocator *b)
-{
-	EFRM_ASSERT(b);
-
-	vfree(b->free_lists);
-	vfree(b->links);
-	vfree(b->orders);
-}
-
-int efrm_buddy_alloc(struct efrm_buddy_allocator *b, unsigned order)
-{
-	unsigned smallest;
-	unsigned addr;
-
-	DEBUG_ALLOC(EFRM_NOTICE("%s(%u)", __func__, order));
-	EFRM_ASSERT(b);
-
-	/* Find smallest chunk that is big enough.  ?? Can optimise this by
-	 ** keeping array of pointers to smallest chunk for each order.
-	 */
-	smallest = order;
-	while (smallest <= b->order &&
-	       efrm_buddy_free_list_empty(b, smallest))
-		++smallest;
-
-	if (smallest > b->order) {
-		DEBUG_ALLOC(EFRM_NOTICE
-			    ("buddy - alloc order %d failed - max order %d",
-			     order, b->order););
-		return -ENOMEM;
-	}
-
-	/* Split blocks until we get one of the correct size. */
-	addr = efrm_buddy_free_list_pop(b, smallest);
-
-	DEBUG_ALLOC(EFRM_NOTICE("buddy - alloc %x order %d cut from order %d",
-				addr, order, smallest););
-	while (smallest-- > order)
-		efrm_buddy_free_list_add(b, smallest, addr + (1 << smallest));
-
-	EFRM_DO_DEBUG(b->orders[addr] = (uint8_t) order);
-
-	EFRM_ASSERT(addr < 1u << b->order);
-	return addr;
-}
-
-void
-efrm_buddy_free(struct efrm_buddy_allocator *b, unsigned addr,
-		unsigned order)
-{
-	unsigned buddy_addr;
-
-	DEBUG_ALLOC(EFRM_NOTICE("%s(%u, %u)", __func__, addr, order));
-	EFRM_ASSERT(b);
-	EFRM_ASSERT(order <= b->order);
-	EFRM_ASSERT((unsigned long)addr + ((unsigned long)1 << order) <=
-		    (unsigned long)1 << b->order);
-	EFRM_ASSERT(!efrm_buddy_addr_in_free_list(b, addr));
-	EFRM_ASSERT(b->orders[addr] == order);
-
-	/* merge free blocks */
-	while (order < b->order) {
-		buddy_addr = addr ^ (1 << order);
-		if (!efrm_buddy_addr_in_free_list(b, buddy_addr) ||
-		    b->orders[buddy_addr] != order)
-			break;
-		efrm_buddy_free_list_del(b, buddy_addr);
-		if (buddy_addr < addr)
-			addr = buddy_addr;
-		++order;
-	}
-
-	DEBUG_ALLOC(EFRM_NOTICE
-		    ("buddy - free %x merged into order %d", addr, order););
-	efrm_buddy_free_list_add(b, order, addr);
-}
diff -r 9566a4a50a43 drivers/net/sfc/sfc_resource/buffer_table.c
--- a/drivers/net/sfc/sfc_resource/buffer_table.c
+++ /dev/null
@@ -1,209 +0,0 @@
-/****************************************************************************
- * Driver for Solarflare network controllers -
- *          resource management for Xen backend, OpenOnload, etc
- *           (including support for SFE4001 10GBT NIC)
- *
- * This file contains abstraction of the buffer table on the NIC.
- *
- * Copyright 2005-2007: Solarflare Communications Inc,
- *                      9501 Jeronimo Road, Suite 250,
- *                      Irvine, CA 92618, USA
- *
- * Developed and maintained by Solarflare Communications:
- *                      <linux-xen-drivers@solarflare.com>
- *                      <onload-dev@solarflare.com>
- *
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 as published
- * by the Free Software Foundation, incorporated herein by reference.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
- ****************************************************************************
- */
-
-/*
-** Might be worth keeping a bitmap of which entries are clear.  Then we
-** wouldn't need to clear them all again when we free an allocation.
-*/
-
-#include <ci/efrm/debug.h>
-#include <ci/driver/efab/hardware.h>
-#include <ci/efrm/nic_table.h>
-#include <ci/efrm/buffer_table.h>
-#include <ci/efrm/buddy.h>
-
-/*! Comment? */
-struct efrm_buffer_table {
-	spinlock_t lock;
-	struct efrm_buddy_allocator buddy;
-};
-
-/* Efab buffer state. */
-static struct efrm_buffer_table efrm_buffers;
-
-int efrm_buffer_table_ctor(unsigned low, unsigned high)
-{
-	int log2_n_entries, rc, i;
-
-	EFRM_ASSERT(high > 0);
-	EFRM_ASSERT(low < high);
-
-	EFRM_TRACE("%s: low=%u high=%u", __func__, low, high);
-	EFRM_NOTICE("%s: low=%u high=%u", __func__, low, high);
-
-	log2_n_entries = fls(high - 1);
-
-	rc = efrm_buddy_ctor(&efrm_buffers.buddy, log2_n_entries);
-	if (rc < 0) {
-		EFRM_ERR("efrm_buffer_table_ctor: efrm_buddy_ctor(%d) "
-			 "failed (%d)", log2_n_entries, rc);
-		return rc;
-	}
-	for (i = 0; i < (1 << log2_n_entries); ++i) {
-		rc = efrm_buddy_alloc(&efrm_buffers.buddy, 0);
-		EFRM_ASSERT(rc >= 0);
-		EFRM_ASSERT(rc < (1 << log2_n_entries));
-	}
-	for (i = low; i < (int) high; ++i)
-		efrm_buddy_free(&efrm_buffers.buddy, i, 0);
-
-	spin_lock_init(&efrm_buffers.lock);
-
-	EFRM_TRACE("%s: done", __func__);
-
-	return 0;
-}
-
-void efrm_buffer_table_dtor(void)
-{
-	/* ?? debug check that all allocations have been freed? */
-
-	spin_lock_destroy(&efrm_buffers.lock);
-	efrm_buddy_dtor(&efrm_buffers.buddy);
-
-	EFRM_TRACE("%s: done", __func__);
-}
-
-/**********************************************************************/
-
-int
-efrm_buffer_table_alloc(unsigned order,
-			struct efhw_buffer_table_allocation *a)
-{
-	irq_flags_t lock_flags;
-	int rc;
-
-	EFRM_ASSERT(&efrm_buffers.buddy);
-	EFRM_ASSERT(a);
-
-	/* Round up to multiple of two, as the buffer clear logic works in
-	 * pairs when not in "full" mode. */
-	order = max_t(unsigned, order, 1);
-
-	spin_lock_irqsave(&efrm_buffers.lock, lock_flags);
-	rc = efrm_buddy_alloc(&efrm_buffers.buddy, order);
-	spin_unlock_irqrestore(&efrm_buffers.lock, lock_flags);
-
-	if (rc < 0) {
-		EFRM_ERR("efrm_buffer_table_alloc: failed (n=%ld) rc %d",
-			 1ul << order, rc);
-		return rc;
-	}
-
-	EFRM_TRACE("efrm_buffer_table_alloc: base=%d n=%ld",
-		   rc, 1ul << order);
-	a->order = order;
-	a->base = (unsigned)rc;
-	return 0;
-}
-
-void efrm_buffer_table_free(struct efhw_buffer_table_allocation *a)
-{
-	irq_flags_t lock_flags;
-	struct efhw_nic *nic;
-	int nic_i;
-
-	EFRM_ASSERT(&efrm_buffers.buddy);
-	EFRM_ASSERT(a);
-	EFRM_ASSERT(a->base != -1);
-	EFRM_ASSERT((unsigned long)a->base + (1ul << a->order) <=
-		    efrm_buddy_size(&efrm_buffers.buddy));
-
-	EFRM_TRACE("efrm_buffer_table_free: base=%d n=%ld",
-		   a->base, (1ul << a->order));
-
-	EFRM_FOR_EACH_NIC(nic_i, nic)
-	    efhw_nic_buffer_table_clear(nic, a->base, 1ul << a->order);
-
-	spin_lock_irqsave(&efrm_buffers.lock, lock_flags);
-	efrm_buddy_free(&efrm_buffers.buddy, a->base, a->order);
-	spin_unlock_irqrestore(&efrm_buffers.lock, lock_flags);
-
-	EFRM_DO_DEBUG(a->base = a->order = -1);
-}
-
-/**********************************************************************/
-
-void
-efrm_buffer_table_set(struct efhw_buffer_table_allocation *a,
-		      struct efhw_nic *nic,
-		      unsigned i, dma_addr_t dma_addr, int owner)
-{
-	EFRM_ASSERT(a);
-	EFRM_ASSERT(i < (unsigned)1 << a->order);
-
-	efhw_nic_buffer_table_set(nic, dma_addr, EFHW_NIC_PAGE_SIZE,
-				  0, owner, a->base + i);
-}
-
-
-int efrm_buffer_table_size(void)
-{
-	return efrm_buddy_size(&efrm_buffers.buddy);
-}
-
-/**********************************************************************/
-
-int
-efrm_page_register(struct efhw_nic *nic, dma_addr_t dma_addr, int owner,
-		   efhw_buffer_addr_t *buf_addr_out)
-{
-	struct efhw_buffer_table_allocation alloc;
-	int rc;
-
-	rc = efrm_buffer_table_alloc(0, &alloc);
-	if (rc == 0) {
-		efrm_buffer_table_set(&alloc, nic, 0, dma_addr, owner);
-		efrm_buffer_table_commit();
-		*buf_addr_out = EFHW_BUFFER_ADDR(alloc.base, 0);
-	}
-	return rc;
-}
-EXPORT_SYMBOL(efrm_page_register);
-
-void efrm_page_unregister(efhw_buffer_addr_t buf_addr)
-{
-	struct efhw_buffer_table_allocation alloc;
-
-	alloc.order = 0;
-	alloc.base = EFHW_BUFFER_PAGE(buf_addr);
-	efrm_buffer_table_free(&alloc);
-}
-EXPORT_SYMBOL(efrm_page_unregister);
-
-void efrm_buffer_table_commit(void)
-{
-	struct efhw_nic *nic;
-	int nic_i;
-
-	EFRM_FOR_EACH_NIC(nic_i, nic)
-	    efhw_nic_buffer_table_commit(nic);
-}
diff -r 9566a4a50a43 drivers/net/sfc/sfc_resource/ci/driver/efab/hardware.h
--- a/drivers/net/sfc/sfc_resource/ci/driver/efab/hardware.h
+++ /dev/null
@@ -1,188 +0,0 @@
-/****************************************************************************
- * Driver for Solarflare network controllers -
- *          resource management for Xen backend, OpenOnload, etc
- *           (including support for SFE4001 10GBT NIC)
- *
- * This file provides EtherFabric NIC hardware interface.
- *
- * Copyright 2005-2007: Solarflare Communications Inc,
- *                      9501 Jeronimo Road, Suite 250,
- *                      Irvine, CA 92618, USA
- *
- * Developed and maintained by Solarflare Communications:
- *                      <linux-xen-drivers@solarflare.com>
- *                      <onload-dev@solarflare.com>
- *
- * Certain parts of the driver were implemented by
- *          Alexandra Kossovsky <Alexandra.Kossovsky@oktetlabs.ru>
- *          OKTET Labs Ltd, Russia,
- *          http://oktetlabs.ru, <info@oktetlabs.ru>
- *          by request of Solarflare Communications
- *
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 as published
- * by the Free Software Foundation, incorporated herein by reference.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
- ****************************************************************************
- */
-
-#ifndef __CI_DRIVER_EFAB_HARDWARE_H__
-#define __CI_DRIVER_EFAB_HARDWARE_H__
-
-#include "ci/driver/efab/hardware/workarounds.h"
-#include <ci/efhw/hardware_sysdep.h>
-
-
-/*----------------------------------------------------------------------------
- *
- * Common EtherFabric definitions
- *
- *---------------------------------------------------------------------------*/
-
-#include <ci/efhw/debug.h>
-#include <ci/efhw/common.h>
-#include <ci/driver/efab/hardware/common.h>
-
-/*----------------------------------------------------------------------------
- *
- * EtherFabric varients
- *
- *---------------------------------------------------------------------------*/
-
-#include <ci/driver/efab/hardware/falcon.h>
-
-/*----------------------------------------------------------------------------
- *
- * EtherFabric Portable Hardware Layer defines
- *
- *---------------------------------------------------------------------------*/
-
-  /*-------------- Initialisation ------------ */
-#define efhw_nic_close_hardware(nic) \
-	((nic)->efhw_func->close_hardware(nic))
-
-#define efhw_nic_init_hardware(nic, ev_handlers, mac_addr, non_irq_evq) \
-	((nic)->efhw_func->init_hardware((nic), (ev_handlers), (mac_addr), \
-					 (non_irq_evq)))
-
-/*-------------- Interrupt support  ------------ */
-/** Handle interrupt.  Return 0 if not handled, 1 if handled. */
-#define efhw_nic_interrupt(nic) \
-	((nic)->efhw_func->interrupt(nic))
-
-#define efhw_nic_interrupt_enable(nic) \
-	((nic)->efhw_func->interrupt_enable(nic))
-
-#define efhw_nic_interrupt_disable(nic) \
-	((nic)->efhw_func->interrupt_disable(nic))
-
-#define efhw_nic_set_interrupt_moderation(nic, evq, val)                 \
-	((nic)->efhw_func->set_interrupt_moderation(nic, evq, val))
-
-/*-------------- Event support  ------------ */
-
-#define efhw_nic_event_queue_enable(nic, evq, size, q_base, buf_base,   \
-				    interrupting)                       \
-	((nic)->efhw_func->event_queue_enable((nic), (evq), (size), (q_base), \
-					      (buf_base), (interrupting)))
-
-#define efhw_nic_event_queue_disable(nic, evq, timer_only) \
-	((nic)->efhw_func->event_queue_disable(nic, evq, timer_only))
-
-#define efhw_nic_wakeup_request(nic, q_base, index, evq) \
-	((nic)->efhw_func->wakeup_request(nic, q_base, index, evq))
-
-#define efhw_nic_sw_event(nic, data, ev) \
-	((nic)->efhw_func->sw_event(nic, data, ev))
-
-/*-------------- Filter support  ------------ */
-#define efhw_nic_ipfilter_set(nic, type, index, dmaq,		\
-			      saddr, sport, daddr, dport)	\
-	((nic)->efhw_func->ipfilter_set(nic, type, index, dmaq,	\
-					saddr, sport, daddr, dport))
-
-#define efhw_nic_ipfilter_clear(nic, index) \
-	((nic)->efhw_func->ipfilter_clear(nic, index))
-
-/*-------------- DMA support  ------------ */
-#define efhw_nic_dmaq_tx_q_init(nic, dmaq, evq, owner, tag,		\
-				dmaq_size, index, flags)		\
-	((nic)->efhw_func->dmaq_tx_q_init(nic, dmaq, evq, owner, tag,	\
-					  dmaq_size, index, flags))
-
-#define efhw_nic_dmaq_rx_q_init(nic, dmaq, evq, owner, tag,		\
-				dmaq_size, index, flags) \
-	((nic)->efhw_func->dmaq_rx_q_init(nic, dmaq, evq, owner, tag,	\
-					  dmaq_size, index, flags))
-
-#define efhw_nic_dmaq_tx_q_disable(nic, dmaq) \
-	((nic)->efhw_func->dmaq_tx_q_disable(nic, dmaq))
-
-#define efhw_nic_dmaq_rx_q_disable(nic, dmaq) \
-	((nic)->efhw_func->dmaq_rx_q_disable(nic, dmaq))
-
-#define efhw_nic_flush_tx_dma_channel(nic, dmaq) \
-	((nic)->efhw_func->flush_tx_dma_channel(nic, dmaq))
-
-#define efhw_nic_flush_rx_dma_channel(nic, dmaq) \
-	((nic)->efhw_func->flush_rx_dma_channel(nic, dmaq))
-
-/*-------------- MAC Low level interface ---- */
-#define efhw_gmac_get_mac_addr(nic) \
-	((nic)->gmac->get_mac_addr((nic)->gmac))
-
-/*-------------- Buffer table -------------- */
-#define efhw_nic_buffer_table_set(nic, addr, bufsz, region,		\
-				  own_id, buf_id)			\
-	((nic)->efhw_func->buffer_table_set(nic, addr, bufsz, region,	\
-					    own_id, buf_id))
-
-#define efhw_nic_buffer_table_set_n(nic, buf_id, addr, bufsz,		\
-				    region, n_pages, own_id) \
-	((nic)->efhw_func->buffer_table_set_n(nic, buf_id, addr, bufsz,	\
-					      region, n_pages, own_id))
-
-#define efhw_nic_buffer_table_clear(nic, id, num) \
-	((nic)->efhw_func->buffer_table_clear(nic, id, num))
-
-#define efhw_nic_buffer_table_commit(nic) \
-	((nic)->efhw_func->buffer_table_commit(nic))
-
-/*-------------- New filter API ------------ */
-#define efhw_nic_filter_set(nic, spec, index_out) \
-	((nic)->efhw_func->filter_set(nic, spec, index_out))
-
-#define efhw_nic_filter_clear(nic, type, index_out) \
-	((nic)->efhw_func->filter_clear(nic, type, index_out))
-
-
-/* --- DMA --- */
-#define EFHW_DMA_ADDRMASK		(0xffffffffffffffffULL)
-
-/* --- Buffers --- */
-#define EFHW_BUFFER_ADDR		FALCON_BUFFER_4K_ADDR
-#define EFHW_BUFFER_PAGE		FALCON_BUFFER_4K_PAGE
-#define EFHW_BUFFER_OFF			FALCON_BUFFER_4K_OFF
-
-/* --- Filters --- */
-#define EFHW_IP_FILTER_NUM		FALCON_FILTER_TBL_NUM
-
-#define EFHW_MAX_PAGE_SIZE		FALCON_MAX_PAGE_SIZE
-
-#if PAGE_SIZE <= EFHW_MAX_PAGE_SIZE
-#define EFHW_NIC_PAGE_SIZE PAGE_SIZE
-#else
-#define EFHW_NIC_PAGE_SIZE EFHW_MAX_PAGE_SIZE
-#endif
-#define EFHW_NIC_PAGE_MASK (~(EFHW_NIC_PAGE_SIZE-1))
-
-#endif /* __CI_DRIVER_EFAB_HARDWARE_H__ */
diff -r 9566a4a50a43 drivers/net/sfc/sfc_resource/ci/driver/efab/hardware/common.h
--- a/drivers/net/sfc/sfc_resource/ci/driver/efab/hardware/common.h
+++ /dev/null
@@ -1,68 +0,0 @@
-/****************************************************************************
- * Driver for Solarflare network controllers -
- *          resource management for Xen backend, OpenOnload, etc
- *           (including support for SFE4001 10GBT NIC)
- *
- * This file provides EtherFabric NIC hardware interface common
- * definitions.
- *
- * Copyright 2005-2007: Solarflare Communications Inc,
- *                      9501 Jeronimo Road, Suite 250,
- *                      Irvine, CA 92618, USA
- *
- * Developed and maintained by Solarflare Communications:
- *                      <linux-xen-drivers@solarflare.com>
- *                      <onload-dev@solarflare.com>
- *
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 as published
- * by the Free Software Foundation, incorporated herein by reference.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
- ****************************************************************************
- */
-
-#ifndef __CI_DRIVER_EFAB_HARDWARE_COMMON_H__
-#define __CI_DRIVER_EFAB_HARDWARE_COMMON_H__
-
-/*----------------------------------------------------------------------------
- *
- * EtherFabric constants
- *
- *---------------------------------------------------------------------------*/
-
-#define EFHW_1K		0x00000400u
-#define EFHW_2K		0x00000800u
-#define EFHW_4K		0x00001000u
-#define EFHW_8K		0x00002000u
-#define EFHW_16K	0x00004000u
-#define EFHW_32K	0x00008000u
-#define EFHW_64K	0x00010000u
-#define EFHW_128K	0x00020000u
-#define EFHW_256K	0x00040000u
-#define EFHW_512K	0x00080000u
-#define EFHW_1M		0x00100000u
-#define EFHW_2M		0x00200000u
-#define EFHW_4M		0x00400000u
-#define EFHW_8M		0x00800000u
-#define EFHW_16M	0x01000000u
-#define EFHW_32M	0x02000000u
-#define EFHW_48M	0x03000000u
-#define EFHW_64M	0x04000000u
-#define EFHW_128M	0x08000000u
-#define EFHW_256M	0x10000000u
-#define EFHW_512M	0x20000000u
-#define EFHW_1G 	0x40000000u
-#define EFHW_2G		0x80000000u
-#define EFHW_4G		0x100000000ULL
-#define EFHW_8G		0x200000000ULL
-
-#endif /* __CI_DRIVER_EFAB_HARDWARE_COMMON_H__ */
diff -r 9566a4a50a43 drivers/net/sfc/sfc_resource/ci/driver/efab/hardware/falcon.h
--- a/drivers/net/sfc/sfc_resource/ci/driver/efab/hardware/falcon.h
+++ /dev/null
@@ -1,422 +0,0 @@
-/****************************************************************************
- * Driver for Solarflare network controllers -
- *          resource management for Xen backend, OpenOnload, etc
- *           (including support for SFE4001 10GBT NIC)
- *
- * This file provides EtherFabric NIC - EFXXXX (aka Falcon) specific
- * definitions.
- *
- * Copyright 2005-2007: Solarflare Communications Inc,
- *                      9501 Jeronimo Road, Suite 250,
- *                      Irvine, CA 92618, USA
- *
- * Developed and maintained by Solarflare Communications:
- *                      <linux-xen-drivers@solarflare.com>
- *                      <onload-dev@solarflare.com>
- *
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 as published
- * by the Free Software Foundation, incorporated herein by reference.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
- ****************************************************************************
- */
-
-#ifndef __CI_DRIVER_EFAB_HARDWARE_FALCON_H__
-#define __CI_DRIVER_EFAB_HARDWARE_FALCON_H__
-
-/*----------------------------------------------------------------------------
- * Compile options
- *---------------------------------------------------------------------------*/
-
-/* Falcon has an 8K maximum page size. */
-#define FALCON_MAX_PAGE_SIZE EFHW_8K
-
-/* include the register definitions */
-#include <ci/driver/efab/hardware/falcon/falcon_core.h>
-#include <ci/driver/efab/hardware/falcon/falcon_desc.h>
-#include <ci/driver/efab/hardware/falcon/falcon_event.h>
-#include <ci/driver/efab/hardware/falcon/falcon_intr_vec.h>
-
-#define FALCON_DMA_TX_DESC_BYTES	8
-#define FALCON_DMA_RX_PHYS_DESC_BYTES	8
-#define FALCON_DMA_RX_BUF_DESC_BYTES	4
-
-
-/* ---- efhw_event_t helpers --- */
-
-#ifndef EFHW_IS_LITTLE_ENDIAN
-#error This needs lots of cpu_to_le64s() in
-#endif
-
-/*!\ TODO look at whether there is an efficiency gain to be had by
-  treating the event codes to 32bit masks as is done for EF1
-
-  These masks apply to the full 64 bits of the event to extract the
-  event code - followed by the common event codes to expect
- */
-#define __FALCON_OPEN_MASK(WIDTH)  ((((uint64_t)1) << (WIDTH)) - 1)
-#define FALCON_EVENT_CODE_MASK \
-	(__FALCON_OPEN_MASK(EV_CODE_WIDTH) << EV_CODE_LBN)
-#define FALCON_EVENT_EV_Q_ID_MASK \
-	(__FALCON_OPEN_MASK(DRIVER_EV_EVQ_ID_WIDTH) << DRIVER_EV_EVQ_ID_LBN)
-#define FALCON_EVENT_TX_FLUSH_Q_ID_MASK \
-	(__FALCON_OPEN_MASK(DRIVER_EV_TX_DESCQ_ID_WIDTH) << \
-	 DRIVER_EV_TX_DESCQ_ID_LBN)
-#define FALCON_EVENT_RX_FLUSH_Q_ID_MASK \
-	(__FALCON_OPEN_MASK(DRIVER_EV_RX_DESCQ_ID_WIDTH) << \
-	 DRIVER_EV_RX_DESCQ_ID_LBN)
-#define FALCON_EVENT_DRV_SUBCODE_MASK \
-	(__FALCON_OPEN_MASK(DRIVER_EV_SUB_CODE_WIDTH) << \
-	 DRIVER_EV_SUB_CODE_LBN)
-
-#define FALCON_EVENT_FMT         "[ev:%x:%08x:%08x]"
-#define FALCON_EVENT_PRI_ARG(e) \
-	((unsigned)(((e).u64 & FALCON_EVENT_CODE_MASK) >> EV_CODE_LBN)), \
-	((unsigned)((e).u64 >> 32)), ((unsigned)((e).u64 & 0xFFFFFFFF))
-
-#define FALCON_EVENT_CODE(evp)		((evp)->u64 & FALCON_EVENT_CODE_MASK)
-#define FALCON_EVENT_WAKE_EVQ_ID(evp) \
-	(((evp)->u64 & FALCON_EVENT_EV_Q_ID_MASK) >> DRIVER_EV_EVQ_ID_LBN)
-#define FALCON_EVENT_TX_FLUSH_Q_ID(evp) \
-	(((evp)->u64 & FALCON_EVENT_TX_FLUSH_Q_ID_MASK) >> \
-	 DRIVER_EV_TX_DESCQ_ID_LBN)
-#define FALCON_EVENT_RX_FLUSH_Q_ID(evp) \
-	(((evp)->u64 & FALCON_EVENT_RX_FLUSH_Q_ID_MASK) >> \
-	 DRIVER_EV_RX_DESCQ_ID_LBN)
-#define FALCON_EVENT_DRIVER_SUBCODE(evp) \
-	(((evp)->u64 & FALCON_EVENT_DRV_SUBCODE_MASK) >> \
-	 DRIVER_EV_SUB_CODE_LBN)
-
-#define FALCON_EVENT_CODE_CHAR	((uint64_t)DRIVER_EV_DECODE << EV_CODE_LBN)
-#define FALCON_EVENT_CODE_SW	((uint64_t)DRV_GEN_EV_DECODE << EV_CODE_LBN)
-
-
-/* so this is the size in bytes of an awful lot of things */
-#define FALCON_REGISTER128          (16)
-
-/* we define some unique dummy values as a debug aid */
-#ifdef _WIN32
-#define FALCON_ATOMIC_BASE		0xdeadbeef00000000ui64
-#else
-#define FALCON_ATOMIC_BASE		0xdeadbeef00000000ULL
-#endif
-#define FALCON_ATOMIC_UPD_REG		(FALCON_ATOMIC_BASE | 0x1)
-#define FALCON_ATOMIC_PTR_TBL_REG	(FALCON_ATOMIC_BASE | 0x2)
-#define FALCON_ATOMIC_SRPM_UDP_EVQ_REG	(FALCON_ATOMIC_BASE | 0x3)
-#define FALCON_ATOMIC_RX_FLUSH_DESCQ	(FALCON_ATOMIC_BASE | 0x4)
-#define FALCON_ATOMIC_TX_FLUSH_DESCQ	(FALCON_ATOMIC_BASE | 0x5)
-#define FALCON_ATOMIC_INT_EN_REG	(FALCON_ATOMIC_BASE | 0x6)
-#define FALCON_ATOMIC_TIMER_CMD_REG	(FALCON_ATOMIC_BASE | 0x7)
-#define FALCON_ATOMIC_PACE_REG		(FALCON_ATOMIC_BASE | 0x8)
-#define FALCON_ATOMIC_INT_ACK_REG	(FALCON_ATOMIC_BASE | 0x9)
-/* XXX It crashed with odd value in FALCON_ATOMIC_INT_ADR_REG */
-#define FALCON_ATOMIC_INT_ADR_REG	(FALCON_ATOMIC_BASE | 0xa)
-
-/*----------------------------------------------------------------------------
- *
- * PCI control blocks for Falcon -
- *          (P) primary is for NET
- *          (S) secondary is for CHAR
- *
- *---------------------------------------------------------------------------*/
-
-#define FALCON_P_CTR_AP_BAR	2
-#define FALCON_S_CTR_AP_BAR	0
-#define FALCON_S_DEVID		0x6703
-
-
-/*----------------------------------------------------------------------------
- *
- * Falcon constants
- *
- *---------------------------------------------------------------------------*/
-
-/* Note: the following constants have moved to values in struct efhw_nic:
- *   FALCON_EVQ_TBL_NUM  ->  nic->num_evqs
- *   FALCON_DMAQ_NUM     ->  nic->num_dmaqs
- *   FALCON_TIMERS_NUM   ->  nic->num_times
- * These replacement constants are used as sanity checks in assertions in
- * certain functions that don't have access to struct efhw_nic.
- */
-#define FALCON_DMAQ_NUM_SANITY          (EFHW_4K)
-#define FALCON_EVQ_TBL_NUM_SANITY       (EFHW_4K)
-#define FALCON_TIMERS_NUM_SANITY        (EFHW_4K)
-
-/* This value is an upper limit on the total number of filter table
- * entries.  The actual size of filter table is determined at runtime, as
- * it can vary.
- */
-#define FALCON_FILTER_TBL_NUM		(EFHW_8K)
-
-/* max number of buffers which can be pushed before commiting */
-#define FALCON_BUFFER_UPD_MAX		(128)
-
-/* We can tell falcon to write its RX buffers in 32 byte quantums,
-   and since we pad packets 2 bytes to the right we can't use
-   a full page (not unless we use jumbo mode for all queues)
-
-   NOTE: tests/nic/dma.c assumes that the value here is the real NIC
-   value, so we explicitly round it down to the nearest 32 bytes */
-
-/* #define FALCON_RX_USR_BUF_SIZE    round_down(4096-2,32) */
-#define FALCON_RX_USR_BUF_SIZE		4064
-
-#define FALCON_EVQ_RPTR_REG_P0		0x400
-
-/*----------------------------------------------------------------------------
- *
- * Falcon requires user-space descriptor pushes to be:
- *    dword[0-2]; wiob(); dword[3]
- *
- * Driver register access must be locked against other threads from
- * the same driver but can be in any order: i.e dword[0-3]; wiob()
- *
- * The following helpers ensure that valid dword orderings are exercised
- *
- *---------------------------------------------------------------------------*/
-
-/* A union to allow writting 64bit values as 32bit values, without
- * hitting the compilers aliasing rules. We hope the compiler optimises
- * away the copy's anyway */
-union __u64to32 {
-	uint64_t u64;
-	struct {
-#ifdef EFHW_IS_LITTLE_ENDIAN
-		uint32_t a;
-		uint32_t b;
-#else
-		uint32_t b;
-		uint32_t a;
-#endif
-	} s;
-};
-
-static inline void
-falcon_write_ddd_d(volatile char __iomem *kva,
-		   uint32_t d0, uint32_t d1, uint32_t d2, uint32_t d3)
-{
-	writel(d0, kva + 0);
-	writel(d1, kva + 4);
-	writel(d2, kva + 8);
-	mmiowb();
-	writel(d3, kva + 12);
-}
-
-static inline void falcon_write_q(volatile char __iomem *kva, uint64_t q)
-{
-	union __u64to32 u;
-	u.u64 = q;
-
-	writel(u.s.a, kva);
-	mmiowb();
-	writel(u.s.b, kva + 4);
-}
-
-static inline void falcon_read_q(volatile char __iomem *addr, uint64_t *q0)
-{
-	/* It is essential that we read dword0 first, so that
-	 * the shadow register is updated with the latest value
-	 * and we get a self consistent value.
-	 */
-	union __u64to32 u;
-	u.s.a = readl(addr);
-	rmb();
-	u.s.b = readl(addr + 4);
-
-	*q0 = u.u64;
-}
-
-static inline void
-falcon_write_qq(volatile char __iomem *kva, uint64_t q0, uint64_t q1)
-{
-	writeq(q0, kva + 0);
-	falcon_write_q(kva + 8, q1);
-}
-
-static inline void
-falcon_read_qq(volatile char __iomem *addr, uint64_t *q0, uint64_t *q1)
-{
-	falcon_read_q(addr, q0);
-	*q1 = readq(addr + 8);
-}
-
-
-
-/*----------------------------------------------------------------------------
- *
- * Buffer virtual addresses (4K buffers)
- *
- *---------------------------------------------------------------------------*/
-
-/* Form a buffer virtual address from buffer ID and offset.  If the offset
-** is larger than the buffer size, then the buffer indexed will be
-** calculated appropriately.  It is the responsibility of the caller to
-** ensure that they have valid buffers programmed at that address.
-*/
-#define FALCON_VADDR_8K_S	(13)
-#define FALCON_VADDR_4K_S	(12)
-#define FALCON_VADDR_M		0xfffff	/* post shift mask  */
-
-#define FALCON_BUFFER_8K_ADDR(id, off)	(((id) << FALCON_VADDR_8K_S) + (off))
-#define FALCON_BUFFER_8K_PAGE(vaddr) \
-	(((vaddr) >> FALCON_VADDR_8K_S) & FALCON_VADDR_M)
-#define FALCON_BUFFER_8K_OFF(vaddr) \
-	((vaddr) & __FALCON_MASK32(FALCON_VADDR_8K_S))
-
-#define FALCON_BUFFER_4K_ADDR(id, off)	(((id) << FALCON_VADDR_4K_S) + (off))
-#define FALCON_BUFFER_4K_PAGE(vaddr) \
-	(((vaddr) >> FALCON_VADDR_4K_S) & FALCON_VADDR_M)
-#define FALCON_BUFFER_4K_OFF(vaddr) \
-	((vaddr) & __FALCON_MASK32(FALCON_VADDR_4K_S))
-
-/*----------------------------------------------------------------------------
- *
- * Timer helpers
- *
- *---------------------------------------------------------------------------*/
-
-static inline int falcon_timer_page_addr(uint idx)
-{
-
-	EFHW_ASSERT(TIMER_CMD_REG_KER_OFST ==
-		    (TIMER_CMD_REG_PAGE4_OFST - 4 * EFHW_8K));
-
-	EFHW_ASSERT(idx < FALCON_TIMERS_NUM_SANITY);
-
-	if (idx < 4)
-		return TIMER_CMD_REG_KER_OFST + (idx * EFHW_8K);
-	else if (idx < 1024)
-		return TIMER_CMD_REG_PAGE4_OFST + ((idx - 4) * EFHW_8K);
-	else
-		return TIMER_CMD_REG_PAGE123K_OFST + ((idx - 1024) * EFHW_8K);
-}
-
-#define FALCON_TIMER_PAGE_MASK		(EFHW_8K-1)
-
-static inline int falcon_timer_page_offset(uint idx)
-{
-	return falcon_timer_page_addr(idx) & FALCON_TIMER_PAGE_MASK;
-}
-
-/*----------------------------------------------------------------------------
- *
- * DMA Queue helpers
- *
- *---------------------------------------------------------------------------*/
-
-/* iSCSI queue for A1; see bug 5427 for more details. */
-#define FALCON_A1_ISCSI_DMAQ 4
-
-/*! returns an address within a bar of the TX DMA doorbell */
-static inline uint falcon_tx_dma_page_addr(uint dmaq_idx)
-{
-	uint page;
-
-	EFHW_ASSERT((((TX_DESC_UPD_REG_PAGE123K_OFST) & (EFHW_8K - 1)) ==
-		     (((TX_DESC_UPD_REG_PAGE4_OFST) & (EFHW_8K - 1)))));
-
-	EFHW_ASSERT(dmaq_idx < FALCON_DMAQ_NUM_SANITY);
-
-	if (dmaq_idx < 1024)
-		page = TX_DESC_UPD_REG_PAGE4_OFST + ((dmaq_idx - 4) * EFHW_8K);
-	else
-		page =
-		    TX_DESC_UPD_REG_PAGE123K_OFST +
-		    ((dmaq_idx - 1024) * EFHW_8K);
-
-	return page;
-}
-
-/*! returns an address within a bar of the RX DMA doorbell */
-static inline uint falcon_rx_dma_page_addr(uint dmaq_idx)
-{
-	uint page;
-
-	EFHW_ASSERT((((RX_DESC_UPD_REG_PAGE123K_OFST) & (EFHW_8K - 1)) ==
-		     ((RX_DESC_UPD_REG_PAGE4_OFST) & (EFHW_8K - 1))));
-
-	EFHW_ASSERT(dmaq_idx < FALCON_DMAQ_NUM_SANITY);
-
-	if (dmaq_idx < 1024)
-		page = RX_DESC_UPD_REG_PAGE4_OFST + ((dmaq_idx - 4) * EFHW_8K);
-	else
-		page =
-		    RX_DESC_UPD_REG_PAGE123K_OFST +
-		    ((dmaq_idx - 1024) * EFHW_8K);
-
-	return page;
-}
-
-/*! "page"=NIC-dependent register set size */
-#define FALCON_DMA_PAGE_MASK  (EFHW_8K-1)
-
-/*! returns an address within a bar of the start of the "page"
-    containing the TX DMA doorbell */
-static inline int falcon_tx_dma_page_base(uint dma_idx)
-{
-	return falcon_tx_dma_page_addr(dma_idx) & ~FALCON_DMA_PAGE_MASK;
-}
-
-/*! returns an address within a bar of the start of the "page"
-    containing the RX DMA doorbell */
-static inline int falcon_rx_dma_page_base(uint dma_idx)
-{
-	return falcon_rx_dma_page_addr(dma_idx) & ~FALCON_DMA_PAGE_MASK;
-}
-
-/*! returns an offset within a "page" of the TX DMA doorbell */
-static inline int falcon_tx_dma_page_offset(uint dma_idx)
-{
-	return falcon_tx_dma_page_addr(dma_idx) & FALCON_DMA_PAGE_MASK;
-}
-
-/*! returns an offset within a "page" of the RX DMA doorbell */
-static inline int falcon_rx_dma_page_offset(uint dma_idx)
-{
-	return falcon_rx_dma_page_addr(dma_idx) & FALCON_DMA_PAGE_MASK;
-}
-
-/*----------------------------------------------------------------------------
- *
- * Events
- *
- *---------------------------------------------------------------------------*/
-
-/* Falcon nails down the event queue mappings */
-#define FALCON_EVQ_KERNEL0   (0)	/* hardwired for net driver */
-#define FALCON_EVQ_CHAR      (4)	/* char driver's event queue      */
-
-/* reserved by the drivers */
-#define FALCON_EVQ_TBL_RESERVED	   (8)
-
-/* default DMA-Q sizes */
-#define FALCON_DMA_Q_DEFAULT_TX_SIZE  512
-
-#define FALCON_DMA_Q_DEFAULT_RX_SIZE  512
-
-#define FALCON_DMA_Q_DEFAULT_MMAP \
-	(FALCON_DMA_Q_DEFAULT_TX_SIZE * (FALCON_DMA_TX_DESC_BYTES * 2))
-
-/*----------------------------------------------------------------------------
- *
- * DEBUG - Analyser trigger
- *
- *---------------------------------------------------------------------------*/
-
-static inline void
-falcon_deadbeef(volatile char __iomem *efhw_kva, unsigned what)
-{
-	writel(what, efhw_kva + 0x300);
-	mmiowb();
-}
-#endif /* __CI_DRIVER_EFAB_HARDWARE_FALCON_H__ */
-/*! \cidoxg_end */
diff -r 9566a4a50a43 drivers/net/sfc/sfc_resource/ci/driver/efab/hardware/falcon/falcon_core.h
--- a/drivers/net/sfc/sfc_resource/ci/driver/efab/hardware/falcon/falcon_core.h
+++ /dev/null
@@ -1,1147 +0,0 @@
-/****************************************************************************
- * Driver for Solarflare network controllers -
- *          resource management for Xen backend, OpenOnload, etc
- *           (including support for SFE4001 10GBT NIC)
- *
- * This file provides EtherFabric NIC - EFXXXX (aka Falcon) core register
- * definitions.
- *
- * Copyright 2005-2007: Solarflare Communications Inc,
- *                      9501 Jeronimo Road, Suite 250,
- *                      Irvine, CA 92618, USA
- *
- * Developed and maintained by Solarflare Communications:
- *                      <linux-xen-drivers@solarflare.com>
- *                      <onload-dev@solarflare.com>
- *
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 as published
- * by the Free Software Foundation, incorporated herein by reference.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
- ****************************************************************************
- */
-
-#define  FALCON_EXTENDED_P_BAR 1
-
-/*************---- Bus Interface Unit Registers C Header ----*************/
-#define IOM_IND_ADR_REG_OFST 0x0 /* IO-mapped indirect access address
-				    register */
-  #define IOM_AUTO_ADR_INC_EN_LBN 16
-  #define IOM_AUTO_ADR_INC_EN_WIDTH 1
-  #define IOM_IND_ADR_LBN 0
-  #define IOM_IND_ADR_WIDTH 16
-#define IOM_IND_DAT_REG_OFST 0x4 /* IO-mapped indirect access data register */
-  #define IOM_IND_DAT_LBN 0
-  #define IOM_IND_DAT_WIDTH 32
-#define ADR_REGION_REG_KER_OFST 0x0 /* Address region register */
-#define ADR_REGION_REG_OFST 0x0 /* Address region register */
-  #define ADR_REGION3_LBN 96
-  #define ADR_REGION3_WIDTH 18
-  #define ADR_REGION2_LBN 64
-  #define ADR_REGION2_WIDTH 18
-  #define ADR_REGION1_LBN 32
-  #define ADR_REGION1_WIDTH 18
-  #define ADR_REGION0_LBN 0
-  #define ADR_REGION0_WIDTH 18
-#define INT_EN_REG_KER_OFST 0x10 /* Kernel driver Interrupt enable register */
-  #define KER_INT_CHAR_LBN 4
-  #define KER_INT_CHAR_WIDTH 1
-  #define KER_INT_KER_LBN 3
-  #define KER_INT_KER_WIDTH 1
-  #define ILL_ADR_ERR_INT_EN_KER_LBN 2
-  #define ILL_ADR_ERR_INT_EN_KER_WIDTH 1
-  #define SRM_PERR_INT_EN_KER_LBN 1
-  #define SRM_PERR_INT_EN_KER_WIDTH 1
-  #define DRV_INT_EN_KER_LBN 0
-  #define DRV_INT_EN_KER_WIDTH 1
-#define INT_EN_REG_CHAR_OFST 0x20 /* Char Driver interrupt enable register */
-  #define CHAR_INT_CHAR_LBN 4
-  #define CHAR_INT_CHAR_WIDTH 1
-  #define CHAR_INT_KER_LBN 3
-  #define CHAR_INT_KER_WIDTH 1
-  #define ILL_ADR_ERR_INT_EN_CHAR_LBN 2
-  #define ILL_ADR_ERR_INT_EN_CHAR_WIDTH 1
-  #define SRM_PERR_INT_EN_CHAR_LBN 1
-  #define SRM_PERR_INT_EN_CHAR_WIDTH 1
-  #define DRV_INT_EN_CHAR_LBN 0
-  #define DRV_INT_EN_CHAR_WIDTH 1
-#define INT_ADR_REG_KER_OFST 0x30 /* Interrupt host address for Kernel driver */
-  #define INT_ADR_KER_LBN 0
-  #define INT_ADR_KER_WIDTH 64
-  #define DRV_INT_KER_LBN 32
-  #define DRV_INT_KER_WIDTH 1
-  #define EV_FF_HALF_INT_KER_LBN 3
-  #define EV_FF_HALF_INT_KER_WIDTH 1
-  #define EV_FF_FULL_INT_KER_LBN 2
-  #define EV_FF_FULL_INT_KER_WIDTH 1
-  #define ILL_ADR_ERR_INT_KER_LBN 1
-  #define ILL_ADR_ERR_INT_KER_WIDTH 1
-  #define SRAM_PERR_INT_KER_LBN 0
-  #define SRAM_PERR_INT_KER_WIDTH 1
-#define INT_ADR_REG_CHAR_OFST 0x40 /* Interrupt host address for Char driver */
-  #define INT_ADR_CHAR_LBN 0
-  #define INT_ADR_CHAR_WIDTH 64
-  #define DRV_INT_CHAR_LBN 32
-  #define DRV_INT_CHAR_WIDTH 1
-  #define EV_FF_HALF_INT_CHAR_LBN 3
-  #define EV_FF_HALF_INT_CHAR_WIDTH 1
-  #define EV_FF_FULL_INT_CHAR_LBN 2
-  #define EV_FF_FULL_INT_CHAR_WIDTH 1
-  #define ILL_ADR_ERR_INT_CHAR_LBN 1
-  #define ILL_ADR_ERR_INT_CHAR_WIDTH 1
-  #define SRAM_PERR_INT_CHAR_LBN 0
-  #define SRAM_PERR_INT_CHAR_WIDTH 1
-#define INT_ISR0_B0_OFST 0x90 /* B0 only */
-#define INT_ISR1_B0_OFST 0xA0
-#define INT_ACK_REG_KER_A1_OFST 0x50 /* Kernel interrupt acknowledge register */
-  #define RESERVED_LBN 0
-  #define RESERVED_WIDTH 32
-#define INT_ACK_REG_CHAR_A1_OFST 0x60 /* CHAR interrupt acknowledge register */
-  #define RESERVED_LBN 0
-  #define RESERVED_WIDTH 32
-/*************---- Global CSR Registers C Header ----*************/
-#define NIC_STAT_REG_KER_OFST 0x200 /* ASIC strap status register */
-#define NIC_STAT_REG_OFST 0x200 /* ASIC strap status register */
-  #define ONCHIP_SRAM_LBN 16
-  #define ONCHIP_SRAM_WIDTH 0
-  #define STRAP_PINS_LBN 0
-  #define STRAP_PINS_WIDTH 3
-#define GPIO_CTL_REG_KER_OFST 0x210 /* GPIO control register */
-#define GPIO_CTL_REG_OFST 0x210 /* GPIO control register */
-  #define GPIO_OEN_LBN 24
-  #define GPIO_OEN_WIDTH 4
-  #define GPIO_OUT_LBN 16
-  #define GPIO_OUT_WIDTH 4
-  #define GPIO_IN_LBN 8
-  #define GPIO_IN_WIDTH 4
-  #define GPIO_PWRUP_VALUE_LBN 0
-  #define GPIO_PWRUP_VALUE_WIDTH 4
-#define GLB_CTL_REG_KER_OFST 0x220 /* Global control register */
-#define GLB_CTL_REG_OFST 0x220 /* Global control register */
-  #define SWRST_LBN 0
-  #define SWRST_WIDTH 1
-#define FATAL_INTR_REG_KER_OFST 0x230 /* Fatal interrupt register for Kernel */
-  #define PCI_BUSERR_INT_KER_EN_LBN 43
-  #define PCI_BUSERR_INT_KER_EN_WIDTH 1
-  #define SRAM_OOB_INT_KER_EN_LBN 42
-  #define SRAM_OOB_INT_KER_EN_WIDTH 1
-  #define BUFID_OOB_INT_KER_EN_LBN 41
-  #define BUFID_OOB_INT_KER_EN_WIDTH 1
-  #define MEM_PERR_INT_KER_EN_LBN 40
-  #define MEM_PERR_INT_KER_EN_WIDTH 1
-  #define RBUF_OWN_INT_KER_EN_LBN 39
-  #define RBUF_OWN_INT_KER_EN_WIDTH 1
-  #define TBUF_OWN_INT_KER_EN_LBN 38
-  #define TBUF_OWN_INT_KER_EN_WIDTH 1
-  #define RDESCQ_OWN_INT_KER_EN_LBN 37
-  #define RDESCQ_OWN_INT_KER_EN_WIDTH 1
-  #define TDESCQ_OWN_INT_KER_EN_LBN 36
-  #define TDESCQ_OWN_INT_KER_EN_WIDTH 1
-  #define EVQ_OWN_INT_KER_EN_LBN 35
-  #define EVQ_OWN_INT_KER_EN_WIDTH 1
-  #define EVFF_OFLO_INT_KER_EN_LBN 34
-  #define EVFF_OFLO_INT_KER_EN_WIDTH 1
-  #define ILL_ADR_INT_KER_EN_LBN 33
-  #define ILL_ADR_INT_KER_EN_WIDTH 1
-  #define SRM_PERR_INT_KER_EN_LBN 32
-  #define SRM_PERR_INT_KER_EN_WIDTH 1
-  #define PCI_BUSERR_INT_KER_LBN 11
-  #define PCI_BUSERR_INT_KER_WIDTH 1
-  #define SRAM_OOB_INT_KER_LBN 10
-  #define SRAM_OOB_INT_KER_WIDTH 1
-  #define BUFID_OOB_INT_KER_LBN 9
-  #define BUFID_OOB_INT_KER_WIDTH 1
-  #define MEM_PERR_INT_KER_LBN 8
-  #define MEM_PERR_INT_KER_WIDTH 1
-  #define RBUF_OWN_INT_KER_LBN 7
-  #define RBUF_OWN_INT_KER_WIDTH 1
-  #define TBUF_OWN_INT_KER_LBN 6
-  #define TBUF_OWN_INT_KER_WIDTH 1
-  #define RDESCQ_OWN_INT_KER_LBN 5
-  #define RDESCQ_OWN_INT_KER_WIDTH 1
-  #define TDESCQ_OWN_INT_KER_LBN 4
-  #define TDESCQ_OWN_INT_KER_WIDTH 1
-  #define EVQ_OWN_INT_KER_LBN 3
-  #define EVQ_OWN_INT_KER_WIDTH 1
-  #define EVFF_OFLO_INT_KER_LBN 2
-  #define EVFF_OFLO_INT_KER_WIDTH 1
-  #define ILL_ADR_INT_KER_LBN 1
-  #define ILL_ADR_INT_KER_WIDTH 1
-  #define SRM_PERR_INT_KER_LBN 0
-  #define SRM_PERR_INT_KER_WIDTH 1
-#define FATAL_INTR_REG_OFST 0x240 /* Fatal interrupt register for Char */
-  #define PCI_BUSERR_INT_CHAR_EN_LBN 43
-  #define PCI_BUSERR_INT_CHAR_EN_WIDTH 1
-  #define SRAM_OOB_INT_CHAR_EN_LBN 42
-  #define SRAM_OOB_INT_CHAR_EN_WIDTH 1
-  #define BUFID_OOB_INT_CHAR_EN_LBN 41
-  #define BUFID_OOB_INT_CHAR_EN_WIDTH 1
-  #define MEM_PERR_INT_CHAR_EN_LBN 40
-  #define MEM_PERR_INT_CHAR_EN_WIDTH 1
-  #define RBUF_OWN_INT_CHAR_EN_LBN 39
-  #define RBUF_OWN_INT_CHAR_EN_WIDTH 1
-  #define TBUF_OWN_INT_CHAR_EN_LBN 38
-  #define TBUF_OWN_INT_CHAR_EN_WIDTH 1
-  #define RDESCQ_OWN_INT_CHAR_EN_LBN 37
-  #define RDESCQ_OWN_INT_CHAR_EN_WIDTH 1
-  #define TDESCQ_OWN_INT_CHAR_EN_LBN 36
-  #define TDESCQ_OWN_INT_CHAR_EN_WIDTH 1
-  #define EVQ_OWN_INT_CHAR_EN_LBN 35
-  #define EVQ_OWN_INT_CHAR_EN_WIDTH 1
-  #define EVFF_OFLO_INT_CHAR_EN_LBN 34
-  #define EVFF_OFLO_INT_CHAR_EN_WIDTH 1
-  #define ILL_ADR_INT_CHAR_EN_LBN 33
-  #define ILL_ADR_INT_CHAR_EN_WIDTH 1
-  #define SRM_PERR_INT_CHAR_EN_LBN 32
-  #define SRM_PERR_INT_CHAR_EN_WIDTH 1
-  #define FATAL_INTR_REG_EN_BITS    0xffffffffffffffffULL
-  #define PCI_BUSERR_INT_CHAR_LBN 11
-  #define PCI_BUSERR_INT_CHAR_WIDTH 1
-  #define SRAM_OOB_INT_CHAR_LBN 10
-  #define SRAM_OOB_INT_CHAR_WIDTH 1
-  #define BUFID_OOB_INT_CHAR_LBN 9
-  #define BUFID_OOB_INT_CHAR_WIDTH 1
-  #define MEM_PERR_INT_CHAR_LBN 8
-  #define MEM_PERR_INT_CHAR_WIDTH 1
-  #define RBUF_OWN_INT_CHAR_LBN 7
-  #define RBUF_OWN_INT_CHAR_WIDTH 1
-  #define TBUF_OWN_INT_CHAR_LBN 6
-  #define TBUF_OWN_INT_CHAR_WIDTH 1
-  #define RDESCQ_OWN_INT_CHAR_LBN 5
-  #define RDESCQ_OWN_INT_CHAR_WIDTH 1
-  #define TDESCQ_OWN_INT_CHAR_LBN 4
-  #define TDESCQ_OWN_INT_CHAR_WIDTH 1
-  #define EVQ_OWN_INT_CHAR_LBN 3
-  #define EVQ_OWN_INT_CHAR_WIDTH 1
-  #define EVFF_OFLO_INT_CHAR_LBN 2
-  #define EVFF_OFLO_INT_CHAR_WIDTH 1
-  #define ILL_ADR_INT_CHAR_LBN 1
-  #define ILL_ADR_INT_CHAR_WIDTH 1
-  #define SRM_PERR_INT_CHAR_LBN 0
-  #define SRM_PERR_INT_CHAR_WIDTH 1
-#define DP_CTRL_REG_OFST 0x250 /* Datapath control register */
-  #define FLS_EVQ_ID_LBN 0
-  #define FLS_EVQ_ID_WIDTH 12
-#define MEM_STAT_REG_KER_OFST 0x260 /* Memory status register */
-#define MEM_STAT_REG_OFST 0x260 /* Memory status register */
-  #define MEM_PERR_VEC_LBN 53
-  #define MEM_PERR_VEC_WIDTH 38
-  #define MBIST_CORR_LBN 38
-  #define MBIST_CORR_WIDTH 15
-  #define MBIST_ERR_LBN 0
-  #define MBIST_ERR_WIDTH 38
-#define DEBUG_REG_KER_OFST 0x270 /* Debug register */
-#define DEBUG_REG_OFST 0x270 /* Debug register */
-  #define DEBUG_BLK_SEL2_LBN 47
-  #define DEBUG_BLK_SEL2_WIDTH 3
-  #define DEBUG_BLK_SEL1_LBN 44
-  #define DEBUG_BLK_SEL1_WIDTH 3
-  #define DEBUG_BLK_SEL0_LBN 41
-  #define DEBUG_BLK_SEL0_WIDTH 3
-  #define MISC_DEBUG_ADDR_LBN 36
-  #define MISC_DEBUG_ADDR_WIDTH 5
-  #define SERDES_DEBUG_ADDR_LBN 31
-  #define SERDES_DEBUG_ADDR_WIDTH 5
-  #define EM_DEBUG_ADDR_LBN 26
-  #define EM_DEBUG_ADDR_WIDTH 5
-  #define SR_DEBUG_ADDR_LBN 21
-  #define SR_DEBUG_ADDR_WIDTH 5
-  #define EV_DEBUG_ADDR_LBN 16
-  #define EV_DEBUG_ADDR_WIDTH 5
-  #define RX_DEBUG_ADDR_LBN 11
-  #define RX_DEBUG_ADDR_WIDTH 5
-  #define TX_DEBUG_ADDR_LBN 6
-  #define TX_DEBUG_ADDR_WIDTH 5
-  #define BIU_DEBUG_ADDR_LBN 1
-  #define BIU_DEBUG_ADDR_WIDTH 5
-  #define DEBUG_EN_LBN 0
-  #define DEBUG_EN_WIDTH 1
-#define DRIVER_REG0_KER_OFST 0x280 /* Driver scratch register 0 */
-#define DRIVER_REG0_OFST 0x280 /* Driver scratch register 0 */
-  #define DRIVER_DW0_LBN 0
-  #define DRIVER_DW0_WIDTH 32
-#define DRIVER_REG1_KER_OFST 0x290 /* Driver scratch register 1 */
-#define DRIVER_REG1_OFST 0x290 /* Driver scratch register 1 */
-  #define DRIVER_DW1_LBN 0
-  #define DRIVER_DW1_WIDTH 32
-#define DRIVER_REG2_KER_OFST 0x2A0 /* Driver scratch register 2 */
-#define DRIVER_REG2_OFST 0x2A0 /* Driver scratch register 2 */
-  #define DRIVER_DW2_LBN 0
-  #define DRIVER_DW2_WIDTH 32
-#define DRIVER_REG3_KER_OFST 0x2B0 /* Driver scratch register 3 */
-#define DRIVER_REG3_OFST 0x2B0 /* Driver scratch register 3 */
-  #define DRIVER_DW3_LBN 0
-  #define DRIVER_DW3_WIDTH 32
-#define DRIVER_REG4_KER_OFST 0x2C0 /* Driver scratch register 4 */
-#define DRIVER_REG4_OFST 0x2C0 /* Driver scratch register 4 */
-  #define DRIVER_DW4_LBN 0
-  #define DRIVER_DW4_WIDTH 32
-#define DRIVER_REG5_KER_OFST 0x2D0 /* Driver scratch register 5 */
-#define DRIVER_REG5_OFST 0x2D0 /* Driver scratch register 5 */
-  #define DRIVER_DW5_LBN 0
-  #define DRIVER_DW5_WIDTH 32
-#define DRIVER_REG6_KER_OFST 0x2E0 /* Driver scratch register 6 */
-#define DRIVER_REG6_OFST 0x2E0 /* Driver scratch register 6 */
-  #define DRIVER_DW6_LBN 0
-  #define DRIVER_DW6_WIDTH 32
-#define DRIVER_REG7_KER_OFST 0x2F0 /* Driver scratch register 7 */
-#define DRIVER_REG7_OFST 0x2F0 /* Driver scratch register 7 */
-  #define DRIVER_DW7_LBN 0
-  #define DRIVER_DW7_WIDTH 32
-#define ALTERA_BUILD_REG_OFST 0x300 /* Altera build register */
-#define ALTERA_BUILD_REG_OFST 0x300 /* Altera build register */
-  #define ALTERA_BUILD_VER_LBN 0
-  #define ALTERA_BUILD_VER_WIDTH 32
-
-/* so called CSR spare register
-    - contains separate parity enable bits for the various internal memory
-    blocks */
-#define MEM_PARITY_ERR_EN_REG_KER 0x310
-#define MEM_PARITY_ALL_BLOCKS_EN_LBN 64
-#define MEM_PARITY_ALL_BLOCKS_EN_WIDTH 38
-#define MEM_PARITY_TX_DATA_EN_LBN   72
-#define MEM_PARITY_TX_DATA_EN_WIDTH 2
-
-/*************---- Event & Timer Module Registers C Header ----*************/
-
-#if FALCON_EXTENDED_P_BAR
-#define EVQ_RPTR_REG_KER_OFST 0x11B00 /* Event queue read pointer register */
-#else
-#define EVQ_RPTR_REG_KER_OFST 0x1B00 /* Event queue read pointer register */
-#endif
-
-#define EVQ_RPTR_REG_OFST 0xFA0000 /* Event queue read pointer register
-				      array. */
-  #define EVQ_RPTR_LBN 0
-  #define EVQ_RPTR_WIDTH 15
-
-#if FALCON_EXTENDED_P_BAR
-#define EVQ_PTR_TBL_KER_OFST 0x11A00 /* Event queue pointer table for kernel
-					access */
-#else
-#define EVQ_PTR_TBL_KER_OFST 0x1A00 /* Event queue pointer table for kernel
-				       access */
-#endif
-
-#define EVQ_PTR_TBL_CHAR_OFST 0xF60000 /* Event queue pointer table for char
-					  direct access */
-  #define EVQ_WKUP_OR_INT_EN_LBN 39
-  #define EVQ_WKUP_OR_INT_EN_WIDTH 1
-  #define EVQ_NXT_WPTR_LBN 24
-  #define EVQ_NXT_WPTR_WIDTH 15
-  #define EVQ_EN_LBN 23
-  #define EVQ_EN_WIDTH 1
-  #define EVQ_SIZE_LBN 20
-  #define EVQ_SIZE_WIDTH 3
-  #define EVQ_BUF_BASE_ID_LBN 0
-  #define EVQ_BUF_BASE_ID_WIDTH 20
-#define TIMER_CMD_REG_KER_OFST 0x420 /* Timer table for kernel access.
-					Page-mapped */
-#define TIMER_CMD_REG_PAGE4_OFST 0x8420 /* Timer table for user-level access.
-					   Page-mapped. For lowest 1K queues.
-					 */
-#define TIMER_CMD_REG_PAGE123K_OFST 0x1000420 /* Timer table for user-level
-						 access. Page-mapped.
-						 For upper 3K queues. */
-#define TIMER_TBL_OFST 0xF70000 /* Timer table for char driver direct access */
-  #define TIMER_MODE_LBN 12
-  #define TIMER_MODE_WIDTH 2
-  #define TIMER_VAL_LBN 0
-  #define TIMER_VAL_WIDTH 12
-  #define TIMER_MODE_INT_HLDOFF 2
-  #define EVQ_BUF_SIZE_LBN 0
-  #define EVQ_BUF_SIZE_WIDTH 1
-#define DRV_EV_REG_KER_OFST 0x440 /* Driver generated event register */
-#define DRV_EV_REG_OFST 0x440 /* Driver generated event register */
-  #define DRV_EV_QID_LBN 64
-  #define DRV_EV_QID_WIDTH 12
-  #define DRV_EV_DATA_LBN 0
-  #define DRV_EV_DATA_WIDTH 64
-#define EVQ_CTL_REG_KER_OFST 0x450 /* Event queue control register */
-#define EVQ_CTL_REG_OFST 0x450 /* Event queue control register */
-  #define RX_EVQ_WAKEUP_MASK_B0_LBN 15
-  #define RX_EVQ_WAKEUP_MASK_B0_WIDTH 6
-  #define EVQ_OWNERR_CTL_LBN 14
-  #define EVQ_OWNERR_CTL_WIDTH 1
-  #define EVQ_FIFO_AF_TH_LBN 8
-  #define EVQ_FIFO_AF_TH_WIDTH 6
-  #define EVQ_FIFO_NOTAF_TH_LBN 0
-  #define EVQ_FIFO_NOTAF_TH_WIDTH 6
-/*************---- SRAM Module Registers C Header ----*************/
-#define BUF_TBL_CFG_REG_KER_OFST 0x600 /* Buffer table configuration register */
-#define BUF_TBL_CFG_REG_OFST 0x600 /* Buffer table configuration register */
-  #define BUF_TBL_MODE_LBN 3
-  #define BUF_TBL_MODE_WIDTH 1
-#define SRM_RX_DC_CFG_REG_KER_OFST 0x610 /* SRAM receive descriptor cache
-					    configuration register */
-#define SRM_RX_DC_CFG_REG_OFST 0x610 /* SRAM receive descriptor cache
-					configuration register */
-  #define SRM_RX_DC_BASE_ADR_LBN 0
-  #define SRM_RX_DC_BASE_ADR_WIDTH 21
-#define SRM_TX_DC_CFG_REG_KER_OFST 0x620 /* SRAM transmit descriptor cache
-					    configuration register */
-#define SRM_TX_DC_CFG_REG_OFST 0x620 /* SRAM transmit descriptor cache
-					configuration register */
-  #define SRM_TX_DC_BASE_ADR_LBN 0
-  #define SRM_TX_DC_BASE_ADR_WIDTH 21
-#define SRM_CFG_REG_KER_OFST 0x630 /* SRAM configuration register */
-#define SRM_CFG_REG_OFST 0x630 /* SRAM configuration register */
-  #define SRAM_OOB_ADR_INTEN_LBN 5
-  #define SRAM_OOB_ADR_INTEN_WIDTH 1
-  #define SRAM_OOB_BUF_INTEN_LBN 4
-  #define SRAM_OOB_BUF_INTEN_WIDTH 1
-  #define SRAM_BT_INIT_EN_LBN 3
-  #define SRAM_BT_INIT_EN_WIDTH 1
-  #define SRM_NUM_BANK_LBN 2
-  #define SRM_NUM_BANK_WIDTH 1
-  #define SRM_BANK_SIZE_LBN 0
-  #define SRM_BANK_SIZE_WIDTH 2
-#define BUF_TBL_UPD_REG_KER_OFST 0x650 /* Buffer table update register */
-#define BUF_TBL_UPD_REG_OFST 0x650 /* Buffer table update register */
-  #define BUF_UPD_CMD_LBN 63
-  #define BUF_UPD_CMD_WIDTH 1
-  #define BUF_CLR_CMD_LBN 62
-  #define BUF_CLR_CMD_WIDTH 1
-  #define BUF_CLR_END_ID_LBN 32
-  #define BUF_CLR_END_ID_WIDTH 20
-  #define BUF_CLR_START_ID_LBN 0
-  #define BUF_CLR_START_ID_WIDTH 20
-#define SRM_UPD_EVQ_REG_KER_OFST 0x660 /* Buffer table update register */
-#define SRM_UPD_EVQ_REG_OFST 0x660 /* Buffer table update register */
-  #define SRM_UPD_EVQ_ID_LBN 0
-  #define SRM_UPD_EVQ_ID_WIDTH 12
-#define SRAM_PARITY_REG_KER_OFST 0x670 /* SRAM parity register. */
-#define SRAM_PARITY_REG_OFST 0x670 /* SRAM parity register. */
-  #define FORCE_SRAM_PERR_LBN 0
-  #define FORCE_SRAM_PERR_WIDTH 1
-
-#if FALCON_EXTENDED_P_BAR
-#define BUF_HALF_TBL_KER_OFST 0x18000 /* Buffer table in half buffer table
-					 mode direct access by kernel driver */
-#else
-#define BUF_HALF_TBL_KER_OFST 0x8000 /* Buffer table in half buffer table
-					mode direct access by kernel driver */
-#endif
-
-
-#define BUF_HALF_TBL_OFST 0x800000 /* Buffer table in half buffer table mode
-				      direct access by char driver */
-  #define BUF_ADR_HBUF_ODD_LBN 44
-  #define BUF_ADR_HBUF_ODD_WIDTH 20
-  #define BUF_OWNER_ID_HBUF_ODD_LBN 32
-  #define BUF_OWNER_ID_HBUF_ODD_WIDTH 12
-  #define BUF_ADR_HBUF_EVEN_LBN 12
-  #define BUF_ADR_HBUF_EVEN_WIDTH 20
-  #define BUF_OWNER_ID_HBUF_EVEN_LBN 0
-  #define BUF_OWNER_ID_HBUF_EVEN_WIDTH 12
-
-
-#if FALCON_EXTENDED_P_BAR
-#define BUF_FULL_TBL_KER_OFST 0x18000 /* Buffer table in full buffer table
-					 mode direct access by kernel driver */
-#else
-#define BUF_FULL_TBL_KER_OFST 0x8000 /* Buffer table in full buffer table mode
-					direct access by kernel driver */
-#endif
-
-
-
-
-#define BUF_FULL_TBL_OFST 0x800000 /* Buffer table in full buffer table mode
-				      direct access by char driver */
-  #define IP_DAT_BUF_SIZE_LBN 50
-  #define IP_DAT_BUF_SIZE_WIDTH 1
-  #define BUF_ADR_REGION_LBN 48
-  #define BUF_ADR_REGION_WIDTH 2
-  #define BUF_ADR_FBUF_LBN 14
-  #define BUF_ADR_FBUF_WIDTH 34
-  #define BUF_OWNER_ID_FBUF_LBN 0
-  #define BUF_OWNER_ID_FBUF_WIDTH 14
-#define SRM_DBG_REG_OFST 0x3000000 /* SRAM debug access */
-  #define SRM_DBG_LBN 0
-  #define SRM_DBG_WIDTH 64
-/*************---- RX Datapath Registers C Header ----*************/
-
-#define RX_CFG_REG_KER_OFST 0x800 /* Receive configuration register */
-#define RX_CFG_REG_OFST 0x800 /* Receive configuration register */
-
-#if !defined(FALCON_64K_RXFIFO) && !defined(FALCON_PRE_02020029)
-# if !defined(FALCON_128K_RXFIFO)
-#  define FALCON_128K_RXFIFO
-# endif
-#endif
-
-#if defined(FALCON_128K_RXFIFO)
-
-/* new for B0 */
-  #define RX_TOEP_TCP_SUPPRESS_B0_LBN 48
-  #define RX_TOEP_TCP_SUPPRESS_B0_WIDTH 1
-  #define RX_INGR_EN_B0_LBN 47
-  #define RX_INGR_EN_B0_WIDTH 1
-  #define RX_TOEP_IPV4_B0_LBN 46
-  #define RX_TOEP_IPV4_B0_WIDTH 1
-  #define RX_HASH_ALG_B0_LBN 45
-  #define RX_HASH_ALG_B0_WIDTH 1
-  #define RX_HASH_INSERT_HDR_B0_LBN 44
-  #define RX_HASH_INSERT_HDR_B0_WIDTH 1
-/* moved for B0 */
-  #define RX_DESC_PUSH_EN_B0_LBN 43
-  #define RX_DESC_PUSH_EN_B0_WIDTH 1
-  #define RX_RDW_PATCH_EN_LBN 42 /* Non head of line blocking */
-  #define RX_RDW_PATCH_EN_WIDTH 1
-  #define RX_PCI_BURST_SIZE_B0_LBN 39
-  #define RX_PCI_BURST_SIZE_B0_WIDTH 3
-  #define RX_OWNERR_CTL_B0_LBN 38
-  #define RX_OWNERR_CTL_B0_WIDTH 1
-  #define RX_XON_TX_TH_B0_LBN 33
-  #define RX_XON_TX_TH_B0_WIDTH 5
-  #define RX_XOFF_TX_TH_B0_LBN 28
-  #define RX_XOFF_TX_TH_B0_WIDTH 5
-  #define RX_USR_BUF_SIZE_B0_LBN 19
-  #define RX_USR_BUF_SIZE_B0_WIDTH 9
-  #define RX_XON_MAC_TH_B0_LBN 10
-  #define RX_XON_MAC_TH_B0_WIDTH 9
-  #define RX_XOFF_MAC_TH_B0_LBN 1
-  #define RX_XOFF_MAC_TH_B0_WIDTH 9
-  #define RX_XOFF_MAC_EN_B0_LBN 0
-  #define RX_XOFF_MAC_EN_B0_WIDTH 1
-
-#elif !defined(FALCON_PRE_02020029)
-/* new for B0 */
-  #define RX_TOEP_TCP_SUPPRESS_B0_LBN 46
-  #define RX_TOEP_TCP_SUPPRESS_B0_WIDTH 1
-  #define RX_INGR_EN_B0_LBN 45
-  #define RX_INGR_EN_B0_WIDTH 1
-  #define RX_TOEP_IPV4_B0_LBN 44
-  #define RX_TOEP_IPV4_B0_WIDTH 1
-  #define RX_HASH_ALG_B0_LBN 43
-  #define RX_HASH_ALG_B0_WIDTH 41
-  #define RX_HASH_INSERT_HDR_B0_LBN 42
-  #define RX_HASH_INSERT_HDR_B0_WIDTH 1
-/* moved for B0 */
-  #define RX_DESC_PUSH_EN_B0_LBN 41
-  #define RX_DESC_PUSH_EN_B0_WIDTH 1
-  #define RX_PCI_BURST_SIZE_B0_LBN 37
-  #define RX_PCI_BURST_SIZE_B0_WIDTH 3
-  #define RX_OWNERR_CTL_B0_LBN 36
-  #define RX_OWNERR_CTL_B0_WIDTH 1
-  #define RX_XON_TX_TH_B0_LBN 31
-  #define RX_XON_TX_TH_B0_WIDTH 5
-  #define RX_XOFF_TX_TH_B0_LBN 26
-  #define RX_XOFF_TX_TH_B0_WIDTH 5
-  #define RX_USR_BUF_SIZE_B0_LBN 17
-  #define RX_USR_BUF_SIZE_B0_WIDTH 9
-  #define RX_XON_MAC_TH_B0_LBN 9
-  #define RX_XON_MAC_TH_B0_WIDTH 8
-  #define RX_XOFF_MAC_TH_B0_LBN 1
-  #define RX_XOFF_MAC_TH_B0_WIDTH 8
-  #define RX_XOFF_MAC_EN_B0_LBN 0
-  #define RX_XOFF_MAC_EN_B0_WIDTH 1
-
-#else
-/* new for B0 */
-  #define RX_TOEP_TCP_SUPPRESS_B0_LBN 44
-  #define RX_TOEP_TCP_SUPPRESS_B0_WIDTH 1
-  #define RX_INGR_EN_B0_LBN 43
-  #define RX_INGR_EN_B0_WIDTH 1
-  #define RX_TOEP_IPV4_B0_LBN 42
-  #define RX_TOEP_IPV4_B0_WIDTH 1
-  #define RX_HASH_ALG_B0_LBN 41
-  #define RX_HASH_ALG_B0_WIDTH 41
-  #define RX_HASH_INSERT_HDR_B0_LBN 40
-  #define RX_HASH_INSERT_HDR_B0_WIDTH 1
-/* moved for B0 */
-  #define RX_DESC_PUSH_EN_B0_LBN 35
-  #define RX_DESC_PUSH_EN_B0_WIDTH 1
-  #define RX_PCI_BURST_SIZE_B0_LBN 35
-  #define RX_PCI_BURST_SIZE_B0_WIDTH 2
-  #define RX_OWNERR_CTL_B0_LBN 34
-  #define RX_OWNERR_CTL_B0_WIDTH 1
-  #define RX_XON_TX_TH_B0_LBN 29
-  #define RX_XON_TX_TH_B0_WIDTH 5
-  #define RX_XOFF_TX_TH_B0_LBN 24
-  #define RX_XOFF_TX_TH_B0_WIDTH 5
-  #define RX_USR_BUF_SIZE_B0_LBN 15
-  #define RX_USR_BUF_SIZE_B0_WIDTH 9
-  #define RX_XON_MAC_TH_B0_LBN 8
-  #define RX_XON_MAC_TH_B0_WIDTH 7
-  #define RX_XOFF_MAC_TH_B0_LBN 1
-  #define RX_XOFF_MAC_TH_B0_WIDTH 7
-  #define RX_XOFF_MAC_EN_B0_LBN 0
-  #define RX_XOFF_MAC_EN_B0_WIDTH 1
-
-#endif
-
-/* A0/A1 */
-  #define RX_PUSH_EN_A1_LBN 35
-  #define RX_PUSH_EN_A1_WIDTH 1
-  #define RX_PCI_BURST_SIZE_A1_LBN 31
-  #define RX_PCI_BURST_SIZE_A1_WIDTH 3
-  #define RX_OWNERR_CTL_A1_LBN 30
-  #define RX_OWNERR_CTL_A1_WIDTH 1
-  #define RX_XON_TX_TH_A1_LBN 25
-  #define RX_XON_TX_TH_A1_WIDTH 5
-  #define RX_XOFF_TX_TH_A1_LBN 20
-  #define RX_XOFF_TX_TH_A1_WIDTH 5
-  #define RX_USR_BUF_SIZE_A1_LBN 11
-  #define RX_USR_BUF_SIZE_A1_WIDTH 9
-  #define RX_XON_MAC_TH_A1_LBN 6
-  #define RX_XON_MAC_TH_A1_WIDTH 5
-  #define RX_XOFF_MAC_TH_A1_LBN 1
-  #define RX_XOFF_MAC_TH_A1_WIDTH 5
-  #define RX_XOFF_MAC_EN_A1_LBN 0
-  #define RX_XOFF_MAC_EN_A1_WIDTH 1
-
-#define RX_FILTER_CTL_REG_OFST 0x810 /* Receive filter control registers */
-  #define SCATTER_ENBL_NO_MATCH_Q_B0_LBN 40
-  #define SCATTER_ENBL_NO_MATCH_Q_B0_WIDTH 1
-  #define UDP_FULL_SRCH_LIMIT_LBN 32
-  #define UDP_FULL_SRCH_LIMIT_WIDTH 8
-  #define NUM_KER_LBN 24
-  #define NUM_KER_WIDTH 2
-  #define UDP_WILD_SRCH_LIMIT_LBN 16
-  #define UDP_WILD_SRCH_LIMIT_WIDTH 8
-  #define TCP_WILD_SRCH_LIMIT_LBN 8
-  #define TCP_WILD_SRCH_LIMIT_WIDTH 8
-  #define TCP_FULL_SRCH_LIMIT_LBN 0
-  #define TCP_FULL_SRCH_LIMIT_WIDTH 8
-#define RX_FLUSH_DESCQ_REG_KER_OFST 0x820 /* Receive flush descriptor queue
-					     register */
-#define RX_FLUSH_DESCQ_REG_OFST 0x820 /* Receive flush descriptor queue
-					 register */
-  #define RX_FLUSH_DESCQ_CMD_LBN 24
-  #define RX_FLUSH_DESCQ_CMD_WIDTH 1
-  #define RX_FLUSH_EVQ_ID_LBN 12
-  #define RX_FLUSH_EVQ_ID_WIDTH 12
-  #define RX_FLUSH_DESCQ_LBN 0
-  #define RX_FLUSH_DESCQ_WIDTH 12
-#define RX_DESC_UPD_REG_KER_OFST 0x830 /* Kernel  receive descriptor update
-					  register. Page-mapped */
-#define RX_DESC_UPD_REG_PAGE4_OFST 0x8830 /* Char & user receive descriptor
-					     update register. Page-mapped.
-					     For lowest 1K queues. */
-#define RX_DESC_UPD_REG_PAGE123K_OFST 0x1000830 /* Char & user receive
-						   descriptor update register.
-						   Page-mapped. For upper
-						   3K queues. */
-  #define RX_DESC_WPTR_LBN 96
-  #define RX_DESC_WPTR_WIDTH 12
-  #define RX_DESC_PUSH_CMD_LBN 95
-  #define RX_DESC_PUSH_CMD_WIDTH 1
-  #define RX_DESC_LBN 0
-  #define RX_DESC_WIDTH 64
-  #define RX_KER_DESC_LBN 0
-  #define RX_KER_DESC_WIDTH 64
-  #define RX_USR_DESC_LBN 0
-  #define RX_USR_DESC_WIDTH 32
-#define RX_DC_CFG_REG_KER_OFST 0x840 /* Receive descriptor cache
-					configuration register */
-#define RX_DC_CFG_REG_OFST 0x840 /* Receive descriptor cache
-				    configuration register */
-  #define RX_DC_SIZE_LBN 0
-  #define RX_DC_SIZE_WIDTH 2
-#define RX_DC_PF_WM_REG_KER_OFST 0x850 /* Receive descriptor cache pre-fetch
-					  watermark register */
-#define RX_DC_PF_WM_REG_OFST 0x850 /* Receive descriptor cache pre-fetch
-				      watermark register */
-  #define RX_DC_PF_LWM_LO_LBN 0
-  #define RX_DC_PF_LWM_LO_WIDTH 6
-
-#define RX_RSS_TKEY_B0_OFST 0x860 /* RSS Toeplitz hash key (B0 only) */
-
-#define RX_NODESC_DROP_REG 0x880
-  #define RX_NODESC_DROP_CNT_LBN 0
-  #define RX_NODESC_DROP_CNT_WIDTH 16
-
-#define XM_TX_CFG_REG_OFST 0x1230
-  #define XM_AUTO_PAD_LBN 5
-  #define XM_AUTO_PAD_WIDTH 1
-
-#define RX_FILTER_TBL0_OFST 0xF00000 /* Receive filter table - even entries */
-  #define RSS_EN_0_B0_LBN 110
-  #define RSS_EN_0_B0_WIDTH 1
-  #define SCATTER_EN_0_B0_LBN 109
-  #define SCATTER_EN_0_B0_WIDTH 1
-  #define TCP_UDP_0_LBN 108
-  #define TCP_UDP_0_WIDTH 1
-  #define RXQ_ID_0_LBN 96
-  #define RXQ_ID_0_WIDTH 12
-  #define DEST_IP_0_LBN 64
-  #define DEST_IP_0_WIDTH 32
-  #define DEST_PORT_TCP_0_LBN 48
-  #define DEST_PORT_TCP_0_WIDTH 16
-  #define SRC_IP_0_LBN 16
-  #define SRC_IP_0_WIDTH 32
-  #define SRC_TCP_DEST_UDP_0_LBN 0
-  #define SRC_TCP_DEST_UDP_0_WIDTH 16
-#define RX_FILTER_TBL1_OFST 0xF00010 /* Receive filter table - odd entries */
-  #define RSS_EN_1_B0_LBN 110
-  #define RSS_EN_1_B0_WIDTH 1
-  #define SCATTER_EN_1_B0_LBN 109
-  #define SCATTER_EN_1_B0_WIDTH 1
-  #define TCP_UDP_1_LBN 108
-  #define TCP_UDP_1_WIDTH 1
-  #define RXQ_ID_1_LBN 96
-  #define RXQ_ID_1_WIDTH 12
-  #define DEST_IP_1_LBN 64
-  #define DEST_IP_1_WIDTH 32
-  #define DEST_PORT_TCP_1_LBN 48
-  #define DEST_PORT_TCP_1_WIDTH 16
-  #define SRC_IP_1_LBN 16
-  #define SRC_IP_1_WIDTH 32
-  #define SRC_TCP_DEST_UDP_1_LBN 0
-  #define SRC_TCP_DEST_UDP_1_WIDTH 16
-
-#if FALCON_EXTENDED_P_BAR
-#define RX_DESC_PTR_TBL_KER_OFST 0x11800 /* Receive descriptor pointer
-					    kernel access */
-#else
-#define RX_DESC_PTR_TBL_KER_OFST 0x1800 /* Receive descriptor pointer
-					   kernel access */
-#endif
-
-
-#define RX_DESC_PTR_TBL_OFST 0xF40000 /* Receive descriptor pointer table */
-  #define RX_ISCSI_DDIG_EN_LBN 88
-  #define RX_ISCSI_DDIG_EN_WIDTH 1
-  #define RX_ISCSI_HDIG_EN_LBN 87
-  #define RX_ISCSI_HDIG_EN_WIDTH 1
-  #define RX_DESC_PREF_ACT_LBN 86
-  #define RX_DESC_PREF_ACT_WIDTH 1
-  #define RX_DC_HW_RPTR_LBN 80
-  #define RX_DC_HW_RPTR_WIDTH 6
-  #define RX_DESCQ_HW_RPTR_LBN 68
-  #define RX_DESCQ_HW_RPTR_WIDTH 12
-  #define RX_DESCQ_SW_WPTR_LBN 56
-  #define RX_DESCQ_SW_WPTR_WIDTH 12
-  #define RX_DESCQ_BUF_BASE_ID_LBN 36
-  #define RX_DESCQ_BUF_BASE_ID_WIDTH 20
-  #define RX_DESCQ_EVQ_ID_LBN 24
-  #define RX_DESCQ_EVQ_ID_WIDTH 12
-  #define RX_DESCQ_OWNER_ID_LBN 10
-  #define RX_DESCQ_OWNER_ID_WIDTH 14
-  #define RX_DESCQ_LABEL_LBN 5
-  #define RX_DESCQ_LABEL_WIDTH 5
-  #define RX_DESCQ_SIZE_LBN 3
-  #define RX_DESCQ_SIZE_WIDTH 2
-  #define RX_DESCQ_TYPE_LBN 2
-  #define RX_DESCQ_TYPE_WIDTH 1
-  #define RX_DESCQ_JUMBO_LBN 1
-  #define RX_DESCQ_JUMBO_WIDTH 1
-  #define RX_DESCQ_EN_LBN 0
-  #define RX_DESCQ_EN_WIDTH 1
-
-
-#define RX_RSS_INDIR_TBL_B0_OFST 0xFB0000 /* RSS indirection table (B0 only) */
-  #define RX_RSS_INDIR_ENT_B0_LBN 0
-  #define RX_RSS_INDIR_ENT_B0_WIDTH 6
-
-/*************---- TX Datapath Registers C Header ----*************/
-#define TX_FLUSH_DESCQ_REG_KER_OFST 0xA00 /* Transmit flush descriptor
-					     queue register */
-#define TX_FLUSH_DESCQ_REG_OFST 0xA00 /* Transmit flush descriptor queue
-					 register */
-  #define TX_FLUSH_DESCQ_CMD_LBN 12
-  #define TX_FLUSH_DESCQ_CMD_WIDTH 1
-  #define TX_FLUSH_DESCQ_LBN 0
-  #define TX_FLUSH_DESCQ_WIDTH 12
-#define TX_DESC_UPD_REG_KER_OFST 0xA10 /* Kernel transmit descriptor update
-					  register. Page-mapped */
-#define TX_DESC_UPD_REG_PAGE4_OFST 0x8A10 /* Char & user transmit descriptor
-					     update register. Page-mapped */
-#define TX_DESC_UPD_REG_PAGE123K_OFST 0x1000A10 /* Char & user transmit
-						   descriptor update register.
-						   Page-mapped */
-  #define TX_DESC_WPTR_LBN 96
-  #define TX_DESC_WPTR_WIDTH 12
-  #define TX_DESC_PUSH_CMD_LBN 95
-  #define TX_DESC_PUSH_CMD_WIDTH 1
-  #define TX_DESC_LBN 0
-  #define TX_DESC_WIDTH 95
-  #define TX_KER_DESC_LBN 0
-  #define TX_KER_DESC_WIDTH 64
-  #define TX_USR_DESC_LBN 0
-  #define TX_USR_DESC_WIDTH 64
-#define TX_DC_CFG_REG_KER_OFST 0xA20 /* Transmit descriptor cache
-					configuration register */
-#define TX_DC_CFG_REG_OFST 0xA20 /* Transmit descriptor cache configuration
-				    register */
-  #define TX_DC_SIZE_LBN 0
-  #define TX_DC_SIZE_WIDTH 2
-
-#if FALCON_EXTENDED_P_BAR
-#define TX_DESC_PTR_TBL_KER_OFST 0x11900 /* Transmit descriptor pointer. */
-#else
-#define TX_DESC_PTR_TBL_KER_OFST 0x1900 /* Transmit descriptor pointer. */
-#endif
-
-
-#define TX_DESC_PTR_TBL_OFST 0xF50000 /* Transmit descriptor pointer */
-  #define TX_NON_IP_DROP_DIS_B0_LBN 91
-  #define TX_NON_IP_DROP_DIS_B0_WIDTH 1
-  #define TX_IP_CHKSM_DIS_B0_LBN 90
-  #define TX_IP_CHKSM_DIS_B0_WIDTH 1
-  #define TX_TCP_CHKSM_DIS_B0_LBN 89
-  #define TX_TCP_CHKSM_DIS_B0_WIDTH 1
-  #define TX_DESCQ_EN_LBN 88
-  #define TX_DESCQ_EN_WIDTH 1
-  #define TX_ISCSI_DDIG_EN_LBN 87
-  #define TX_ISCSI_DDIG_EN_WIDTH 1
-  #define TX_ISCSI_HDIG_EN_LBN 86
-  #define TX_ISCSI_HDIG_EN_WIDTH 1
-  #define TX_DC_HW_RPTR_LBN 80
-  #define TX_DC_HW_RPTR_WIDTH 6
-  #define TX_DESCQ_HW_RPTR_LBN 68
-  #define TX_DESCQ_HW_RPTR_WIDTH 12
-  #define TX_DESCQ_SW_WPTR_LBN 56
-  #define TX_DESCQ_SW_WPTR_WIDTH 12
-  #define TX_DESCQ_BUF_BASE_ID_LBN 36
-  #define TX_DESCQ_BUF_BASE_ID_WIDTH 20
-  #define TX_DESCQ_EVQ_ID_LBN 24
-  #define TX_DESCQ_EVQ_ID_WIDTH 12
-  #define TX_DESCQ_OWNER_ID_LBN 10
-  #define TX_DESCQ_OWNER_ID_WIDTH 14
-  #define TX_DESCQ_LABEL_LBN 5
-  #define TX_DESCQ_LABEL_WIDTH 5
-  #define TX_DESCQ_SIZE_LBN 3
-  #define TX_DESCQ_SIZE_WIDTH 2
-  #define TX_DESCQ_TYPE_LBN 1
-  #define TX_DESCQ_TYPE_WIDTH 2
-  #define TX_DESCQ_FLUSH_LBN 0
-  #define TX_DESCQ_FLUSH_WIDTH 1
-#define TX_CFG_REG_KER_OFST 0xA50 /* Transmit configuration register */
-#define TX_CFG_REG_OFST 0xA50 /* Transmit configuration register */
-  #define TX_IP_ID_P1_OFS_LBN 32
-  #define TX_IP_ID_P1_OFS_WIDTH 15
-  #define TX_IP_ID_P0_OFS_LBN 16
-  #define TX_IP_ID_P0_OFS_WIDTH 15
-  #define TX_TURBO_EN_LBN 3
-  #define TX_TURBO_EN_WIDTH 1
-  #define TX_OWNERR_CTL_LBN 2
-  #define TX_OWNERR_CTL_WIDTH 2
-  #define TX_NON_IP_DROP_DIS_LBN 1
-  #define TX_NON_IP_DROP_DIS_WIDTH 1
-  #define TX_IP_ID_REP_EN_LBN 0
-  #define TX_IP_ID_REP_EN_WIDTH 1
-#define TX_RESERVED_REG_KER_OFST 0xA80 /* Transmit configuration register */
-#define TX_RESERVED_REG_OFST 0xA80 /* Transmit configuration register */
-  #define TX_CSR_PUSH_EN_LBN 89
-  #define TX_CSR_PUSH_EN_WIDTH 1
-  #define TX_RX_SPACER_LBN 64
-  #define TX_RX_SPACER_WIDTH 8
-  #define TX_SW_EV_EN_LBN 59
-  #define TX_SW_EV_EN_WIDTH 1
-  #define TX_RX_SPACER_EN_LBN 57
-  #define TX_RX_SPACER_EN_WIDTH 1
-  #define TX_CSR_PREF_WD_TMR_LBN 24
-  #define TX_CSR_PREF_WD_TMR_WIDTH 16
-  #define TX_CSR_ONLY1TAG_LBN 21
-  #define TX_CSR_ONLY1TAG_WIDTH 1
-  #define TX_PREF_THRESHOLD_LBN 19
-  #define TX_PREF_THRESHOLD_WIDTH 2
-  #define TX_ONE_PKT_PER_Q_LBN 18
-  #define TX_ONE_PKT_PER_Q_WIDTH 1
-  #define TX_DIS_NON_IP_EV_LBN 17
-  #define TX_DIS_NON_IP_EV_WIDTH 1
-  #define TX_DMA_SPACER_LBN 8
-  #define TX_DMA_SPACER_WIDTH 8
-  #define TX_FLUSH_MIN_LEN_EN_B0_LBN 7
-  #define TX_FLUSH_MIN_LEN_EN_B0_WIDTH 1
-  #define TX_TCP_DIS_A1_LBN 7
-  #define TX_TCP_DIS_A1_WIDTH 1
-  #define TX_IP_DIS_A1_LBN 6
-  #define TX_IP_DIS_A1_WIDTH 1
-  #define TX_MAX_CPL_LBN 2
-  #define TX_MAX_CPL_WIDTH 2
-  #define TX_MAX_PREF_LBN 0
-  #define TX_MAX_PREF_WIDTH 2
-#define TX_VLAN_REG_OFST 0xAE0 /* Transmit VLAN tag register */
-  #define TX_VLAN_EN_LBN 127
-  #define TX_VLAN_EN_WIDTH 1
-  #define TX_VLAN7_PORT1_EN_LBN 125
-  #define TX_VLAN7_PORT1_EN_WIDTH 1
-  #define TX_VLAN7_PORT0_EN_LBN 124
-  #define TX_VLAN7_PORT0_EN_WIDTH 1
-  #define TX_VLAN7_LBN 112
-  #define TX_VLAN7_WIDTH 12
-  #define TX_VLAN6_PORT1_EN_LBN 109
-  #define TX_VLAN6_PORT1_EN_WIDTH 1
-  #define TX_VLAN6_PORT0_EN_LBN 108
-  #define TX_VLAN6_PORT0_EN_WIDTH 1
-  #define TX_VLAN6_LBN 96
-  #define TX_VLAN6_WIDTH 12
-  #define TX_VLAN5_PORT1_EN_LBN 93
-  #define TX_VLAN5_PORT1_EN_WIDTH 1
-  #define TX_VLAN5_PORT0_EN_LBN 92
-  #define TX_VLAN5_PORT0_EN_WIDTH 1
-  #define TX_VLAN5_LBN 80
-  #define TX_VLAN5_WIDTH 12
-  #define TX_VLAN4_PORT1_EN_LBN 77
-  #define TX_VLAN4_PORT1_EN_WIDTH 1
-  #define TX_VLAN4_PORT0_EN_LBN 76
-  #define TX_VLAN4_PORT0_EN_WIDTH 1
-  #define TX_VLAN4_LBN 64
-  #define TX_VLAN4_WIDTH 12
-  #define TX_VLAN3_PORT1_EN_LBN 61
-  #define TX_VLAN3_PORT1_EN_WIDTH 1
-  #define TX_VLAN3_PORT0_EN_LBN 60
-  #define TX_VLAN3_PORT0_EN_WIDTH 1
-  #define TX_VLAN3_LBN 48
-  #define TX_VLAN3_WIDTH 12
-  #define TX_VLAN2_PORT1_EN_LBN 45
-  #define TX_VLAN2_PORT1_EN_WIDTH 1
-  #define TX_VLAN2_PORT0_EN_LBN 44
-  #define TX_VLAN2_PORT0_EN_WIDTH 1
-  #define TX_VLAN2_LBN 32
-  #define TX_VLAN2_WIDTH 12
-  #define TX_VLAN1_PORT1_EN_LBN 29
-  #define TX_VLAN1_PORT1_EN_WIDTH 1
-  #define TX_VLAN1_PORT0_EN_LBN 28
-  #define TX_VLAN1_PORT0_EN_WIDTH 1
-  #define TX_VLAN1_LBN 16
-  #define TX_VLAN1_WIDTH 12
-  #define TX_VLAN0_PORT1_EN_LBN 13
-  #define TX_VLAN0_PORT1_EN_WIDTH 1
-  #define TX_VLAN0_PORT0_EN_LBN 12
-  #define TX_VLAN0_PORT0_EN_WIDTH 1
-  #define TX_VLAN0_LBN 0
-  #define TX_VLAN0_WIDTH 12
-#define TX_FIL_CTL_REG_OFST 0xAF0 /* Transmit filter control register */
-  #define TX_MADR1_FIL_EN_LBN 65
-  #define TX_MADR1_FIL_EN_WIDTH 1
-  #define TX_MADR0_FIL_EN_LBN 64
-  #define TX_MADR0_FIL_EN_WIDTH 1
-  #define TX_IPFIL31_PORT1_EN_LBN 63
-  #define TX_IPFIL31_PORT1_EN_WIDTH 1
-  #define TX_IPFIL31_PORT0_EN_LBN 62
-  #define TX_IPFIL31_PORT0_EN_WIDTH 1
-  #define TX_IPFIL30_PORT1_EN_LBN 61
-  #define TX_IPFIL30_PORT1_EN_WIDTH 1
-  #define TX_IPFIL30_PORT0_EN_LBN 60
-  #define TX_IPFIL30_PORT0_EN_WIDTH 1
-  #define TX_IPFIL29_PORT1_EN_LBN 59
-  #define TX_IPFIL29_PORT1_EN_WIDTH 1
-  #define TX_IPFIL29_PORT0_EN_LBN 58
-  #define TX_IPFIL29_PORT0_EN_WIDTH 1
-  #define TX_IPFIL28_PORT1_EN_LBN 57
-  #define TX_IPFIL28_PORT1_EN_WIDTH 1
-  #define TX_IPFIL28_PORT0_EN_LBN 56
-  #define TX_IPFIL28_PORT0_EN_WIDTH 1
-  #define TX_IPFIL27_PORT1_EN_LBN 55
-  #define TX_IPFIL27_PORT1_EN_WIDTH 1
-  #define TX_IPFIL27_PORT0_EN_LBN 54
-  #define TX_IPFIL27_PORT0_EN_WIDTH 1
-  #define TX_IPFIL26_PORT1_EN_LBN 53
-  #define TX_IPFIL26_PORT1_EN_WIDTH 1
-  #define TX_IPFIL26_PORT0_EN_LBN 52
-  #define TX_IPFIL26_PORT0_EN_WIDTH 1
-  #define TX_IPFIL25_PORT1_EN_LBN 51
-  #define TX_IPFIL25_PORT1_EN_WIDTH 1
-  #define TX_IPFIL25_PORT0_EN_LBN 50
-  #define TX_IPFIL25_PORT0_EN_WIDTH 1
-  #define TX_IPFIL24_PORT1_EN_LBN 49
-  #define TX_IPFIL24_PORT1_EN_WIDTH 1
-  #define TX_IPFIL24_PORT0_EN_LBN 48
-  #define TX_IPFIL24_PORT0_EN_WIDTH 1
-  #define TX_IPFIL23_PORT1_EN_LBN 47
-  #define TX_IPFIL23_PORT1_EN_WIDTH 1
-  #define TX_IPFIL23_PORT0_EN_LBN 46
-  #define TX_IPFIL23_PORT0_EN_WIDTH 1
-  #define TX_IPFIL22_PORT1_EN_LBN 45
-  #define TX_IPFIL22_PORT1_EN_WIDTH 1
-  #define TX_IPFIL22_PORT0_EN_LBN 44
-  #define TX_IPFIL22_PORT0_EN_WIDTH 1
-  #define TX_IPFIL21_PORT1_EN_LBN 43
-  #define TX_IPFIL21_PORT1_EN_WIDTH 1
-  #define TX_IPFIL21_PORT0_EN_LBN 42
-  #define TX_IPFIL21_PORT0_EN_WIDTH 1
-  #define TX_IPFIL20_PORT1_EN_LBN 41
-  #define TX_IPFIL20_PORT1_EN_WIDTH 1
-  #define TX_IPFIL20_PORT0_EN_LBN 40
-  #define TX_IPFIL20_PORT0_EN_WIDTH 1
-  #define TX_IPFIL19_PORT1_EN_LBN 39
-  #define TX_IPFIL19_PORT1_EN_WIDTH 1
-  #define TX_IPFIL19_PORT0_EN_LBN 38
-  #define TX_IPFIL19_PORT0_EN_WIDTH 1
-  #define TX_IPFIL18_PORT1_EN_LBN 37
-  #define TX_IPFIL18_PORT1_EN_WIDTH 1
-  #define TX_IPFIL18_PORT0_EN_LBN 36
-  #define TX_IPFIL18_PORT0_EN_WIDTH 1
-  #define TX_IPFIL17_PORT1_EN_LBN 35
-  #define TX_IPFIL17_PORT1_EN_WIDTH 1
-  #define TX_IPFIL17_PORT0_EN_LBN 34
-  #define TX_IPFIL17_PORT0_EN_WIDTH 1
-  #define TX_IPFIL16_PORT1_EN_LBN 33
-  #define TX_IPFIL16_PORT1_EN_WIDTH 1
-  #define TX_IPFIL16_PORT0_EN_LBN 32
-  #define TX_IPFIL16_PORT0_EN_WIDTH 1
-  #define TX_IPFIL15_PORT1_EN_LBN 31
-  #define TX_IPFIL15_PORT1_EN_WIDTH 1
-  #define TX_IPFIL15_PORT0_EN_LBN 30
-  #define TX_IPFIL15_PORT0_EN_WIDTH 1
-  #define TX_IPFIL14_PORT1_EN_LBN 29
-  #define TX_IPFIL14_PORT1_EN_WIDTH 1
-  #define TX_IPFIL14_PORT0_EN_LBN 28
-  #define TX_IPFIL14_PORT0_EN_WIDTH 1
-  #define TX_IPFIL13_PORT1_EN_LBN 27
-  #define TX_IPFIL13_PORT1_EN_WIDTH 1
-  #define TX_IPFIL13_PORT0_EN_LBN 26
-  #define TX_IPFIL13_PORT0_EN_WIDTH 1
-  #define TX_IPFIL12_PORT1_EN_LBN 25
-  #define TX_IPFIL12_PORT1_EN_WIDTH 1
-  #define TX_IPFIL12_PORT0_EN_LBN 24
-  #define TX_IPFIL12_PORT0_EN_WIDTH 1
-  #define TX_IPFIL11_PORT1_EN_LBN 23
-  #define TX_IPFIL11_PORT1_EN_WIDTH 1
-  #define TX_IPFIL11_PORT0_EN_LBN 22
-  #define TX_IPFIL11_PORT0_EN_WIDTH 1
-  #define TX_IPFIL10_PORT1_EN_LBN 21
-  #define TX_IPFIL10_PORT1_EN_WIDTH 1
-  #define TX_IPFIL10_PORT0_EN_LBN 20
-  #define TX_IPFIL10_PORT0_EN_WIDTH 1
-  #define TX_IPFIL9_PORT1_EN_LBN 19
-  #define TX_IPFIL9_PORT1_EN_WIDTH 1
-  #define TX_IPFIL9_PORT0_EN_LBN 18
-  #define TX_IPFIL9_PORT0_EN_WIDTH 1
-  #define TX_IPFIL8_PORT1_EN_LBN 17
-  #define TX_IPFIL8_PORT1_EN_WIDTH 1
-  #define TX_IPFIL8_PORT0_EN_LBN 16
-  #define TX_IPFIL8_PORT0_EN_WIDTH 1
-  #define TX_IPFIL7_PORT1_EN_LBN 15
-  #define TX_IPFIL7_PORT1_EN_WIDTH 1
-  #define TX_IPFIL7_PORT0_EN_LBN 14
-  #define TX_IPFIL7_PORT0_EN_WIDTH 1
-  #define TX_IPFIL6_PORT1_EN_LBN 13
-  #define TX_IPFIL6_PORT1_EN_WIDTH 1
-  #define TX_IPFIL6_PORT0_EN_LBN 12
-  #define TX_IPFIL6_PORT0_EN_WIDTH 1
-  #define TX_IPFIL5_PORT1_EN_LBN 11
-  #define TX_IPFIL5_PORT1_EN_WIDTH 1
-  #define TX_IPFIL5_PORT0_EN_LBN 10
-  #define TX_IPFIL5_PORT0_EN_WIDTH 1
-  #define TX_IPFIL4_PORT1_EN_LBN 9
-  #define TX_IPFIL4_PORT1_EN_WIDTH 1
-  #define TX_IPFIL4_PORT0_EN_LBN 8
-  #define TX_IPFIL4_PORT0_EN_WIDTH 1
-  #define TX_IPFIL3_PORT1_EN_LBN 7
-  #define TX_IPFIL3_PORT1_EN_WIDTH 1
-  #define TX_IPFIL3_PORT0_EN_LBN 6
-  #define TX_IPFIL3_PORT0_EN_WIDTH 1
-  #define TX_IPFIL2_PORT1_EN_LBN 5
-  #define TX_IPFIL2_PORT1_EN_WIDTH 1
-  #define TX_IPFIL2_PORT0_EN_LBN 4
-  #define TX_IPFIL2_PORT0_EN_WIDTH 1
-  #define TX_IPFIL1_PORT1_EN_LBN 3
-  #define TX_IPFIL1_PORT1_EN_WIDTH 1
-  #define TX_IPFIL1_PORT0_EN_LBN 2
-  #define TX_IPFIL1_PORT0_EN_WIDTH 1
-  #define TX_IPFIL0_PORT1_EN_LBN 1
-  #define TX_IPFIL0_PORT1_EN_WIDTH 1
-  #define TX_IPFIL0_PORT0_EN_LBN 0
-  #define TX_IPFIL0_PORT0_EN_WIDTH 1
-#define TX_IPFIL_TBL_OFST 0xB00 /* Transmit IP source address filter table */
-  #define TX_IPFIL_MASK_LBN 32
-  #define TX_IPFIL_MASK_WIDTH 32
-  #define TX_IP_SRC_ADR_LBN 0
-  #define TX_IP_SRC_ADR_WIDTH 32
-#define TX_PACE_REG_A1_OFST 0xF80000 /* Transmit pace control register */
-#define TX_PACE_REG_B0_OFST 0xA90    /* Transmit pace control register */
-  #define TX_PACE_SB_NOTAF_LBN 19
-  #define TX_PACE_SB_NOTAF_WIDTH 10
-  #define TX_PACE_SB_AF_LBN 9
-  #define TX_PACE_SB_AF_WIDTH 10
-  #define TX_PACE_FB_BASE_LBN 5
-  #define TX_PACE_FB_BASE_WIDTH 4
-  #define TX_PACE_BIN_TH_LBN 0
-  #define TX_PACE_BIN_TH_WIDTH 5
-#define TX_PACE_TBL_A1_OFST 0xF80040 /* Transmit pacing table */
-#define TX_PACE_TBL_FIRST_QUEUE_A1 4
-#define TX_PACE_TBL_B0_OFST 0xF80000 /* Transmit pacing table */
-#define TX_PACE_TBL_FIRST_QUEUE_B0 0
-  #define TX_PACE_LBN 0
-  #define TX_PACE_WIDTH 5
-
-/*************---- EE/Flash Registers C Header ----*************/
-#define EE_SPI_HCMD_REG_KER_OFST 0x100 /* SPI host command register */
-#define EE_SPI_HCMD_REG_OFST 0x100 /* SPI host command register */
-  #define EE_SPI_HCMD_CMD_EN_LBN 31
-  #define EE_SPI_HCMD_CMD_EN_WIDTH 1
-  #define EE_WR_TIMER_ACTIVE_LBN 28
-  #define EE_WR_TIMER_ACTIVE_WIDTH 1
-  #define EE_SPI_HCMD_SF_SEL_LBN 24
-  #define EE_SPI_HCMD_SF_SEL_WIDTH 1
-  #define EE_SPI_HCMD_DABCNT_LBN 16
-  #define EE_SPI_HCMD_DABCNT_WIDTH 5
-  #define EE_SPI_HCMD_READ_LBN 15
-  #define EE_SPI_HCMD_READ_WIDTH 1
-  #define EE_SPI_HCMD_DUBCNT_LBN 12
-  #define EE_SPI_HCMD_DUBCNT_WIDTH 2
-  #define EE_SPI_HCMD_ADBCNT_LBN 8
-  #define EE_SPI_HCMD_ADBCNT_WIDTH 2
-  #define EE_SPI_HCMD_ENC_LBN 0
-  #define EE_SPI_HCMD_ENC_WIDTH 8
-#define EE_SPI_HADR_REG_KER_OFST 0X110 /* SPI host address register */
-#define EE_SPI_HADR_REG_OFST 0X110 /* SPI host address register */
-  #define EE_SPI_HADR_DUBYTE_LBN 24
-  #define EE_SPI_HADR_DUBYTE_WIDTH 8
-  #define EE_SPI_HADR_ADR_LBN 0
-  #define EE_SPI_HADR_ADR_WIDTH 24
-#define EE_SPI_HDATA_REG_KER_OFST 0x120 /* SPI host data register */
-#define EE_SPI_HDATA_REG_OFST 0x120 /* SPI host data register */
-  #define EE_SPI_HDATA3_LBN 96
-  #define EE_SPI_HDATA3_WIDTH 32
-  #define EE_SPI_HDATA2_LBN 64
-  #define EE_SPI_HDATA2_WIDTH 32
-  #define EE_SPI_HDATA1_LBN 32
-  #define EE_SPI_HDATA1_WIDTH 32
-  #define EE_SPI_HDATA0_LBN 0
-  #define EE_SPI_HDATA0_WIDTH 32
-#define EE_BASE_PAGE_REG_KER_OFST 0x130 /* Expansion ROM base mirror register */
-#define EE_BASE_PAGE_REG_OFST 0x130 /* Expansion ROM base mirror register */
-  #define EE_EXP_ROM_WINDOW_BASE_LBN 16
-  #define EE_EXP_ROM_WINDOW_BASE_WIDTH 13
-  #define EE_EXPROM_MASK_LBN 0
-  #define EE_EXPROM_MASK_WIDTH 13
-#define EE_VPD_CFG0_REG_KER_OFST 0X140 /* SPI/VPD configuration register */
-#define EE_VPD_CFG0_REG_OFST 0X140 /* SPI/VPD configuration register */
-  #define EE_SF_FASTRD_EN_LBN 127
-  #define EE_SF_FASTRD_EN_WIDTH 1
-  #define EE_SF_CLOCK_DIV_LBN 120
-  #define EE_SF_CLOCK_DIV_WIDTH 7
-  #define EE_VPD_WIP_POLL_LBN 119
-  #define EE_VPD_WIP_POLL_WIDTH 1
-  #define EE_VPDW_LENGTH_LBN 80
-  #define EE_VPDW_LENGTH_WIDTH 15
-  #define EE_VPDW_BASE_LBN 64
-  #define EE_VPDW_BASE_WIDTH 15
-  #define EE_VPD_WR_CMD_EN_LBN 56
-  #define EE_VPD_WR_CMD_EN_WIDTH 8
-  #define EE_VPD_BASE_LBN 32
-  #define EE_VPD_BASE_WIDTH 24
-  #define EE_VPD_LENGTH_LBN 16
-  #define EE_VPD_LENGTH_WIDTH 13
-  #define EE_VPD_AD_SIZE_LBN 8
-  #define EE_VPD_AD_SIZE_WIDTH 5
-  #define EE_VPD_ACCESS_ON_LBN 5
-  #define EE_VPD_ACCESS_ON_WIDTH 1
-#define EE_VPD_SW_CNTL_REG_KER_OFST 0X150 /* VPD access SW control register */
-#define EE_VPD_SW_CNTL_REG_OFST 0X150 /* VPD access SW control register */
-  #define EE_VPD_CYCLE_PENDING_LBN 31
-  #define EE_VPD_CYCLE_PENDING_WIDTH 1
-  #define EE_VPD_CYC_WRITE_LBN 28
-  #define EE_VPD_CYC_WRITE_WIDTH 1
-  #define EE_VPD_CYC_ADR_LBN 0
-  #define EE_VPD_CYC_ADR_WIDTH 15
-#define EE_VPD_SW_DATA_REG_KER_OFST 0x160 /* VPD access SW data register */
-#define EE_VPD_SW_DATA_REG_OFST 0x160 /* VPD access SW data register */
-  #define EE_VPD_CYC_DAT_LBN 0
-  #define EE_VPD_CYC_DAT_WIDTH 32
diff -r 9566a4a50a43 drivers/net/sfc/sfc_resource/ci/driver/efab/hardware/falcon/falcon_desc.h
--- a/drivers/net/sfc/sfc_resource/ci/driver/efab/hardware/falcon/falcon_desc.h
+++ /dev/null
@@ -1,75 +0,0 @@
-/****************************************************************************
- * Driver for Solarflare network controllers -
- *          resource management for Xen backend, OpenOnload, etc
- *           (including support for SFE4001 10GBT NIC)
- *
- * This file provides EtherFabric NIC - EFXXXX (aka Falcon) descriptor
- * definitions.
- *
- * Copyright 2005-2007: Solarflare Communications Inc,
- *                      9501 Jeronimo Road, Suite 250,
- *                      Irvine, CA 92618, USA
- *
- * Developed and maintained by Solarflare Communications:
- *                      <linux-xen-drivers@solarflare.com>
- *                      <onload-dev@solarflare.com>
- *
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 as published
- * by the Free Software Foundation, incorporated herein by reference.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
- ****************************************************************************
- */
-
-/*************---- Descriptors C Headers ----*************/
-/* Receive Kernel IP Descriptor */
-  #define RX_KER_BUF_SIZE_LBN 48
-  #define RX_KER_BUF_SIZE_WIDTH 14
-  #define RX_KER_BUF_REGION_LBN 46
-  #define RX_KER_BUF_REGION_WIDTH 2
-      #define RX_KER_BUF_REGION0_DECODE 0
-      #define RX_KER_BUF_REGION1_DECODE 1
-      #define RX_KER_BUF_REGION2_DECODE 2
-      #define RX_KER_BUF_REGION3_DECODE 3
-  #define RX_KER_BUF_ADR_LBN 0
-  #define RX_KER_BUF_ADR_WIDTH 46
-/* Receive User IP Descriptor */
-  #define RX_USR_2BYTE_OFS_LBN 20
-  #define RX_USR_2BYTE_OFS_WIDTH 12
-  #define RX_USR_BUF_ID_LBN 0
-  #define RX_USR_BUF_ID_WIDTH 20
-/* Transmit Kernel IP Descriptor */
-  #define TX_KER_PORT_LBN 63
-  #define TX_KER_PORT_WIDTH 1
-  #define TX_KER_CONT_LBN 62
-  #define TX_KER_CONT_WIDTH 1
-  #define TX_KER_BYTE_CNT_LBN 48
-  #define TX_KER_BYTE_CNT_WIDTH 14
-  #define TX_KER_BUF_REGION_LBN 46
-  #define TX_KER_BUF_REGION_WIDTH 2
-      #define TX_KER_BUF_REGION0_DECODE 0
-      #define TX_KER_BUF_REGION1_DECODE 1
-      #define TX_KER_BUF_REGION2_DECODE 2
-      #define TX_KER_BUF_REGION3_DECODE 3
-  #define TX_KER_BUF_ADR_LBN 0
-  #define TX_KER_BUF_ADR_WIDTH 46
-/* Transmit User IP Descriptor */
-  #define TX_USR_PORT_LBN 47
-  #define TX_USR_PORT_WIDTH 1
-  #define TX_USR_CONT_LBN 46
-  #define TX_USR_CONT_WIDTH 1
-  #define TX_USR_BYTE_CNT_LBN 33
-  #define TX_USR_BYTE_CNT_WIDTH 13
-  #define TX_USR_BUF_ID_LBN 13
-  #define TX_USR_BUF_ID_WIDTH 20
-  #define TX_USR_BYTE_OFS_LBN 0
-  #define TX_USR_BYTE_OFS_WIDTH 13
diff -r 9566a4a50a43 drivers/net/sfc/sfc_resource/ci/driver/efab/hardware/falcon/falcon_event.h
--- a/drivers/net/sfc/sfc_resource/ci/driver/efab/hardware/falcon/falcon_event.h
+++ /dev/null
@@ -1,155 +0,0 @@
-/****************************************************************************
- * Driver for Solarflare network controllers -
- *          resource management for Xen backend, OpenOnload, etc
- *           (including support for SFE4001 10GBT NIC)
- *
- * This file provides EtherFabric NIC - EFXXXX (aka Falcon) event
- * definitions.
- *
- * Copyright 2005-2007: Solarflare Communications Inc,
- *                      9501 Jeronimo Road, Suite 250,
- *                      Irvine, CA 92618, USA
- *
- * Developed and maintained by Solarflare Communications:
- *                      <linux-xen-drivers@solarflare.com>
- *                      <onload-dev@solarflare.com>
- *
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 as published
- * by the Free Software Foundation, incorporated herein by reference.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
- ****************************************************************************
- */
-
-/*************---- Events Format C Header ----*************/
-/*************---- Event entry ----*************/
-  #define EV_CODE_LBN 60
-  #define EV_CODE_WIDTH 4
-      #define RX_IP_EV_DECODE 0
-      #define TX_IP_EV_DECODE 2
-      #define DRIVER_EV_DECODE 5
-      #define GLOBAL_EV_DECODE 6
-      #define DRV_GEN_EV_DECODE 7
-  #define EV_DATA_LBN 0
-  #define EV_DATA_WIDTH 60
-/******---- Receive IP events for both Kernel & User event queues ----******/
-  #define RX_EV_PKT_OK_LBN 56
-  #define RX_EV_PKT_OK_WIDTH 1
-  #define RX_EV_BUF_OWNER_ID_ERR_LBN 54
-  #define RX_EV_BUF_OWNER_ID_ERR_WIDTH 1
-  #define RX_EV_IP_HDR_CHKSUM_ERR_LBN 52
-  #define RX_EV_IP_HDR_CHKSUM_ERR_WIDTH 1
-  #define RX_EV_TCP_UDP_CHKSUM_ERR_LBN 51
-  #define RX_EV_TCP_UDP_CHKSUM_ERR_WIDTH 1
-  #define RX_EV_ETH_CRC_ERR_LBN 50
-  #define RX_EV_ETH_CRC_ERR_WIDTH 1
-  #define RX_EV_FRM_TRUNC_LBN 49
-  #define RX_EV_FRM_TRUNC_WIDTH 1
-  #define RX_EV_DRIB_NIB_LBN 48
-  #define RX_EV_DRIB_NIB_WIDTH 1
-  #define RX_EV_TOBE_DISC_LBN 47
-  #define RX_EV_TOBE_DISC_WIDTH 1
-  #define RX_EV_PKT_TYPE_LBN 44
-  #define RX_EV_PKT_TYPE_WIDTH 3
-      #define RX_EV_PKT_TYPE_ETH_DECODE 0
-      #define RX_EV_PKT_TYPE_LLC_DECODE 1
-      #define RX_EV_PKT_TYPE_JUMBO_DECODE 2
-      #define RX_EV_PKT_TYPE_VLAN_DECODE 3
-      #define RX_EV_PKT_TYPE_VLAN_LLC_DECODE 4
-      #define RX_EV_PKT_TYPE_VLAN_JUMBO_DECODE 5
-  #define RX_EV_HDR_TYPE_LBN 42
-  #define RX_EV_HDR_TYPE_WIDTH 2
-      #define RX_EV_HDR_TYPE_TCP_IPV4_DECODE 0
-      #define RX_EV_HDR_TYPE_UDP_IPV4_DECODE 1
-      #define RX_EV_HDR_TYPE_OTHER_IP_DECODE 2
-      #define RX_EV_HDR_TYPE_NON_IP_DECODE 3
-  #define RX_EV_DESC_Q_EMPTY_LBN 41
-  #define RX_EV_DESC_Q_EMPTY_WIDTH 1
-  #define RX_EV_MCAST_HASH_MATCH_LBN 40
-  #define RX_EV_MCAST_HASH_MATCH_WIDTH 1
-  #define RX_EV_MCAST_PKT_LBN 39
-  #define RX_EV_MCAST_PKT_WIDTH 1
-  #define RX_EV_Q_LABEL_LBN 32
-  #define RX_EV_Q_LABEL_WIDTH 5
-  #define RX_JUMBO_CONT_LBN 31
-  #define RX_JUMBO_CONT_WIDTH 1
-  #define RX_SOP_LBN 15
-  #define RX_SOP_WIDTH 1
-  #define RX_PORT_LBN 30
-  #define RX_PORT_WIDTH 1
-  #define RX_EV_BYTE_CNT_LBN 16
-  #define RX_EV_BYTE_CNT_WIDTH 14
-  #define RX_iSCSI_PKT_OK_LBN 14
-  #define RX_iSCSI_PKT_OK_WIDTH 1
-  #define RX_ISCSI_DDIG_ERR_LBN 13
-  #define RX_ISCSI_DDIG_ERR_WIDTH 1
-  #define RX_ISCSI_HDIG_ERR_LBN 12
-  #define RX_ISCSI_HDIG_ERR_WIDTH 1
-  #define RX_EV_DESC_PTR_LBN 0
-  #define RX_EV_DESC_PTR_WIDTH 12
-/******---- Transmit IP events for both Kernel & User event queues ----******/
-  #define TX_EV_PKT_ERR_LBN 38
-  #define TX_EV_PKT_ERR_WIDTH 1
-  #define TX_EV_PKT_TOO_BIG_LBN 37
-  #define TX_EV_PKT_TOO_BIG_WIDTH 1
-  #define TX_EV_Q_LABEL_LBN 32
-  #define TX_EV_Q_LABEL_WIDTH 5
-  #define TX_EV_PORT_LBN 16
-  #define TX_EV_PORT_WIDTH 1
-  #define TX_EV_WQ_FF_FULL_LBN 15
-  #define TX_EV_WQ_FF_FULL_WIDTH 1
-  #define TX_EV_BUF_OWNER_ID_ERR_LBN 14
-  #define TX_EV_BUF_OWNER_ID_ERR_WIDTH 1
-  #define TX_EV_COMP_LBN 12
-  #define TX_EV_COMP_WIDTH 1
-  #define TX_EV_DESC_PTR_LBN 0
-  #define TX_EV_DESC_PTR_WIDTH 12
-/*************---- Char or Kernel driver events ----*************/
-  #define DRIVER_EV_SUB_CODE_LBN 56
-  #define DRIVER_EV_SUB_CODE_WIDTH 4
-      #define TX_DESCQ_FLS_DONE_EV_DECODE 0x0
-      #define RX_DESCQ_FLS_DONE_EV_DECODE 0x1
-      #define EVQ_INIT_DONE_EV_DECODE 0x2
-      #define EVQ_NOT_EN_EV_DECODE 0x3
-      #define RX_DESCQ_FLSFF_OVFL_EV_DECODE 0x4
-      #define SRM_UPD_DONE_EV_DECODE 0x5
-      #define WAKE_UP_EV_DECODE 0x6
-      #define TX_PKT_NON_TCP_UDP_DECODE 0x9
-      #define TIMER_EV_DECODE 0xA
-      #define RX_DSC_ERROR_EV_DECODE 0xE
-  #define DRIVER_EV_TX_DESCQ_ID_LBN 0
-  #define DRIVER_EV_TX_DESCQ_ID_WIDTH 12
-  #define DRIVER_EV_RX_DESCQ_ID_LBN 0
-  #define DRIVER_EV_RX_DESCQ_ID_WIDTH 12
-  #define DRIVER_EV_EVQ_ID_LBN 0
-  #define DRIVER_EV_EVQ_ID_WIDTH 12
-  #define DRIVER_TMR_ID_LBN 0
-  #define DRIVER_TMR_ID_WIDTH 12
-  #define DRIVER_EV_SRM_UPD_LBN 0
-  #define DRIVER_EV_SRM_UPD_WIDTH 2
-      #define SRM_CLR_EV_DECODE 0
-      #define SRM_UPD_EV_DECODE 1
-      #define SRM_ILLCLR_EV_DECODE 2
-/********---- Global events. Sent to both event queue 0 and 4. ----********/
-  #define XFP_PHY_INTR_LBN 10
-  #define XFP_PHY_INTR_WIDTH 1
-  #define XG_PHY_INTR_LBN 9
-  #define XG_PHY_INTR_WIDTH 1
-  #define G_PHY1_INTR_LBN 8
-  #define G_PHY1_INTR_WIDTH 1
-  #define G_PHY0_INTR_LBN 7
-  #define G_PHY0_INTR_WIDTH 1
-/*************---- Driver generated events ----*************/
-  #define DRV_GEN_EV_CODE_LBN 60
-  #define DRV_GEN_EV_CODE_WIDTH 4
-  #define DRV_GEN_EV_DATA_LBN 0
-  #define DRV_GEN_EV_DATA_WIDTH 60
diff -r 9566a4a50a43 drivers/net/sfc/sfc_resource/ci/driver/efab/hardware/falcon/falcon_intr_vec.h
--- a/drivers/net/sfc/sfc_resource/ci/driver/efab/hardware/falcon/falcon_intr_vec.h
+++ /dev/null
@@ -1,44 +0,0 @@
-/****************************************************************************
- * Driver for Solarflare network controllers -
- *          resource management for Xen backend, OpenOnload, etc
- *           (including support for SFE4001 10GBT NIC)
- *
- * This file provides EtherFabric NIC - EFXXXX (aka Falcon) interrupt
- * vector definitions.
- *
- * Copyright 2005-2007: Solarflare Communications Inc,
- *                      9501 Jeronimo Road, Suite 250,
- *                      Irvine, CA 92618, USA
- *
- * Developed and maintained by Solarflare Communications:
- *                      <linux-xen-drivers@solarflare.com>
- *                      <onload-dev@solarflare.com>
- *
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 as published
- * by the Free Software Foundation, incorporated herein by reference.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
- ****************************************************************************
- */
-
-/*************---- Interrupt Vector Format C Header ----*************/
-#define DW0_OFST 0x0 /* Double-word 0: Event queue FIFO interrupts */
-  #define EVQ_FIFO_HF_LBN 1
-  #define EVQ_FIFO_HF_WIDTH 1
-  #define EVQ_FIFO_AF_LBN 0
-  #define EVQ_FIFO_AF_WIDTH 1
-#define DW1_OFST 0x4 /* Double-word 1: Interrupt indicator */
-  #define INT_FLAG_LBN 0
-  #define INT_FLAG_WIDTH 1
-#define DW2_OFST 0x8 /* Double-word 2: Fatal interrupts */
-  #define FATAL_INT_LBN 0
-  #define FATAL_INT_WIDTH 1
diff -r 9566a4a50a43 drivers/net/sfc/sfc_resource/ci/driver/efab/hardware/workarounds.h
--- a/drivers/net/sfc/sfc_resource/ci/driver/efab/hardware/workarounds.h
+++ /dev/null
@@ -1,67 +0,0 @@
-/****************************************************************************
- * Driver for Solarflare network controllers -
- *          resource management for Xen backend, OpenOnload, etc
- *           (including support for SFE4001 10GBT NIC)
- *
- * This file provides workaround settings for EtherFabric NICs.
- *
- * Copyright 2005-2007: Solarflare Communications Inc,
- *                      9501 Jeronimo Road, Suite 250,
- *                      Irvine, CA 92618, USA
- *
- * Developed and maintained by Solarflare Communications:
- *                      <linux-xen-drivers@solarflare.com>
- *                      <onload-dev@solarflare.com>
- *
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 as published
- * by the Free Software Foundation, incorporated herein by reference.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
- ****************************************************************************
- */
-
-#ifndef __CI_DRIVER_EFAB_WORKAROUNDS_H__
-#define __CI_DRIVER_EFAB_WORKAROUNDS_H__
-
-/*----------------------------------------------------------------------------
- *
- * Hardware workarounds which have global scope
- *
- *---------------------------------------------------------------------------*/
-
-#if defined(__CI_HARDWARE_CONFIG_FALCON_B0__)
-/*------------------------------- B0 ---------------------------------------*/
-
-#define BUG2175_WORKAROUND 0	/* TX event batching for dual port operation.
-				   This removes the effect (dup TX events)
-				   of the fix
-				   (TX event per packet + batch events) */
-#define BUG5302_WORKAROUND 0	/* unstick TX DMAQ after out-of-range wr ptr */
-#define BUG5762_WORKAROUND 0	/* Set all queues to jumbo mode */
-#define BUG5391_WORKAROUND 0	/* Misaligned TX can't span 512-byte boundary */
-#define BUG7916_WORKAROUND 0	/* RX flush gets lost */
-
-#else
-/*------------------------------- A0/A1 ------------------------------------*/
-
-#define BUG2175_WORKAROUND 1	/* TX event batching for dual port operation.
-				   This removes the effect (dup TX events)
-				   of the fix
-				   (TX event per packet + batch events) */
-#define BUG5302_WORKAROUND 1	/* unstick TX DMAQ after out-of-range wr ptr */
-#define BUG5762_WORKAROUND 1	/* Set all queues to jumbo mode */
-#define BUG5391_WORKAROUND 1	/* Misaligned TX can't span 512-byte boundary */
-#define BUG7916_WORKAROUND 1	/* RX flush gets lost */
-
-#endif /* B0/A01 */
-
-#endif /* __CI_DRIVER_EFAB_WORKAROUNDS_H__ */
diff -r 9566a4a50a43 drivers/net/sfc/sfc_resource/ci/driver/resource/efx_vi.h
--- a/drivers/net/sfc/sfc_resource/ci/driver/resource/efx_vi.h
+++ /dev/null
@@ -1,273 +0,0 @@
-/****************************************************************************
- * Driver for Solarflare network controllers -
- *          resource management for Xen backend, OpenOnload, etc
- *           (including support for SFE4001 10GBT NIC)
- *
- * This file contains public EFX VI API to Solarflare resource manager.
- *
- * Copyright 2005-2007: Solarflare Communications Inc,
- *                      9501 Jeronimo Road, Suite 250,
- *                      Irvine, CA 92618, USA
- *
- * Developed and maintained by Solarflare Communications:
- *                      <linux-xen-drivers@solarflare.com>
- *                      <onload-dev@solarflare.com>
- *
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 as published
- * by the Free Software Foundation, incorporated herein by reference.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
- ****************************************************************************
- */
-
-#ifndef __CI_DRIVER_RESOURCE_EFX_VI_H__
-#define __CI_DRIVER_RESOURCE_EFX_VI_H__
-
-/* Default size of event queue in the efx_vi resource.  Copied from
- * CI_CFG_NETIF_EVENTQ_SIZE */
-#define EFX_VI_EVENTQ_SIZE_DEFAULT 1024
-
-extern int efx_vi_eventq_size;
-
-/**************************************************************************
- * efx_vi_state types, allocation and free
- **************************************************************************/
-
-/*! Handle for refering to a efx_vi */
-struct efx_vi_state;
-
-/*!
- * Allocate an efx_vi, including event queue and pt_endpoint
- *
- * \param vih_out Pointer to a handle that is set on success
- * \param ifindex Index of the network interface desired
- * \return Zero on success (and vih_out set), non-zero on failure.
- */
-extern int
-efx_vi_alloc(struct efx_vi_state **vih_out, int ifindex);
-
-/*!
- * Free a previously allocated efx_vi
- *
- * \param vih The handle of the efx_vi to free
- */
-extern void
-efx_vi_free(struct efx_vi_state *vih);
-
-/*!
- * Reset a previously allocated efx_vi
- *
- * \param vih The handle of the efx_vi to reset
- */
-extern void
-efx_vi_reset(struct efx_vi_state *vih);
-
-/**************************************************************************
- * efx_vi_eventq types and functions
- **************************************************************************/
-
-/*!
- * Register a function to receive callbacks when event queue timeouts
- * or wakeups occur.  Only one function per efx_vi can be registered
- * at once.
- *
- * \param vih The handle to identify the efx_vi
- * \param callback The function to callback
- * \param context An argument to pass to the callback function
- * \return Zero on success, non-zero on failure.
- */
-extern int
-efx_vi_eventq_register_callback(struct efx_vi_state *vih,
-				void (*callback)(void *context, int is_timeout),
-				void *context);
-
-/*!
- * Remove the current eventq timeout or wakeup callback function
- *
- * \param vih The handle to identify the efx_vi
- * \return Zero on success, non-zero on failure
- */
-extern int
-efx_vi_eventq_kill_callback(struct efx_vi_state *vih);
-
-/**************************************************************************
- * efx_vi_dma_map types and functions
- **************************************************************************/
-
-/*!
- * Handle for refering to a efx_vi
- */
-struct efx_vi_dma_map_state;
-
-/*!
- * Map a list of buffer pages so they are registered with the hardware
- *
- * \param vih The handle to identify the efx_vi
- * \param addrs An array of page pointers to map
- * \param n_addrs Length of the page pointer array.  Must be a power of two.
- * \param dmh_out Set on success to a handle used to refer to this mapping
- * \return Zero on success, non-zero on failure.
- */
-extern int
-efx_vi_dma_map_pages(struct efx_vi_state *vih, struct page **pages,
-			 int n_pages, struct efx_vi_dma_map_state **dmh_out);
-extern int
-efx_vi_dma_map_addrs(struct efx_vi_state *vih,
-		     unsigned long long *dev_bus_addrs, int n_pages,
-		     struct efx_vi_dma_map_state **dmh_out);
-
-/*!
- * Unmap a previously mapped set of pages so they are no longer registered
- * with the hardware.
- *
- * \param vih The handle to identify the efx_vi
- * \param dmh The handle to identify the dma mapping
- */
-extern void
-efx_vi_dma_unmap_pages(struct efx_vi_state *vih,
-		       struct efx_vi_dma_map_state *dmh);
-extern void
-efx_vi_dma_unmap_addrs(struct efx_vi_state *vih,
-		       struct efx_vi_dma_map_state *dmh);
-
-/*!
- * Retrieve the buffer address of the mapping
- *
- * \param vih The handle to identify the efx_vi
- * \param dmh The handle to identify the buffer mapping
- * \return The buffer address on success, or zero on failure
- */
-extern unsigned
-efx_vi_dma_get_map_addr(struct efx_vi_state *vih,
-			struct efx_vi_dma_map_state *dmh);
-
-/**************************************************************************
- * efx_vi filter functions
- **************************************************************************/
-
-#define EFX_VI_STATIC_FILTERS 32
-
-/*! Handle to refer to a filter instance */
-struct filter_resource_t;
-
-/*!
- * Allocate and add a filter
- *
- * \param vih The handle to identify the efx_vi
- * \param protocol The protocol of the new filter: UDP or TCP
- * \param ip_addr_be32 The local ip address of the filter
- * \param port_le16 The local port of the filter
- * \param fh_out Set on success to be a handle to refer to this filter
- * \return Zero on success, non-zero on failure.
- */
-extern int
-efx_vi_filter(struct efx_vi_state *vih, int protocol, unsigned ip_addr_be32,
-	      int port_le16, struct filter_resource_t **fh_out);
-
-/*!
- * Remove a filter and free resources associated with it
- *
- * \param vih The handle to identify the efx_vi
- * \param fh The handle to identify the filter
- * \return Zero on success, non-zero on failure
- */
-extern int
-efx_vi_filter_stop(struct efx_vi_state *vih, struct filter_resource_t *fh);
-
-/**************************************************************************
- * efx_vi hw resources types and functions
- **************************************************************************/
-
-/*! Constants for the type field in efx_vi_hw_resource */
-#define EFX_VI_HW_RESOURCE_TXDMAQ    0x0	/* PFN of TX DMA Q */
-#define EFX_VI_HW_RESOURCE_RXDMAQ    0x1	/* PFN of RX DMA Q */
-#define EFX_VI_HW_RESOURCE_EVQTIMER  0x4	/* Address of event q timer */
-
-/* Address of event q pointer (EF1) */
-#define EFX_VI_HW_RESOURCE_EVQPTR    0x5
-/* Address of register pointer (Falcon A) */
-#define EFX_VI_HW_RESOURCE_EVQRPTR   0x6
-/* Offset of register pointer (Falcon B) */
-#define EFX_VI_HW_RESOURCE_EVQRPTR_OFFSET 0x7
-/* Address of mem KVA */
-#define EFX_VI_HW_RESOURCE_EVQMEMKVA 0x8
-/* PFN of doorbell page (Falcon) */
-#define EFX_VI_HW_RESOURCE_BELLPAGE  0x9
-
-/*! How large an array to allocate for the get_() functions - smaller
-  than the total number of constants as some are mutually exclusive */
-#define EFX_VI_HW_RESOURCE_MAXSIZE   0x7
-
-/*! Constants for the mem_type field in efx_vi_hw_resource */
-#define EFX_VI_HW_RESOURCE_IOBUFFER   0	/* Host memory */
-#define EFX_VI_HW_RESOURCE_PERIPHERAL 1	/* Card memory/registers */
-
-/*!
- * Data structure providing information on a hardware resource mapping
- */
-struct efx_vi_hw_resource {
-	u8 type;		/*!< What this resource represents */
-	u8 mem_type;		/*!< What type of memory is it in, eg,
-				 * host or iomem */
-	u8 more_to_follow;	/*!< Is this part of a multi-region resource */
-	u32 length;		/*!< Length of the resource in bytes */
-	unsigned long address;	/*!< Address of this resource */
-};
-
-/*!
- * Metadata concerning the list of hardware resource mappings
- */
-struct efx_vi_hw_resource_metadata {
-	int evq_order;
-	int evq_offs;
-	int evq_capacity;
-	int instance;
-	unsigned rx_capacity;
-	unsigned tx_capacity;
-	int nic_arch;
-	int nic_revision;
-	char nic_variant;
-};
-
-/*!
- * Obtain a list of hardware resource mappings, using virtual addresses
- *
- * \param vih The handle to identify the efx_vi
- * \param mdata Pointer to a structure to receive the metadata
- * \param hw_res_array An array to receive the list of hardware resources
- * \param length The length of hw_res_array.  Updated on success to contain
- * the number of entries in the supplied array that were used.
- * \return Zero on success, non-zero on failure
- */
-extern int
-efx_vi_hw_resource_get_virt(struct efx_vi_state *vih,
-			    struct efx_vi_hw_resource_metadata *mdata,
-			    struct efx_vi_hw_resource *hw_res_array,
-			    int *length);
-
-/*!
- * Obtain a list of hardware resource mappings, using physical addresses
- *
- * \param vih The handle to identify the efx_vi
- * \param mdata Pointer to a structure to receive the metadata
- * \param hw_res_array An array to receive the list of hardware resources
- * \param length The length of hw_res_array.  Updated on success to contain
- * the number of entries in the supplied array that were used.
- * \return Zero on success, non-zero on failure
- */
-extern int
-efx_vi_hw_resource_get_phys(struct efx_vi_state *vih,
-			    struct efx_vi_hw_resource_metadata *mdata,
-			    struct efx_vi_hw_resource *hw_res_array,
-			    int *length);
-
-#endif /* __CI_DRIVER_RESOURCE_EFX_VI_H__ */
diff -r 9566a4a50a43 drivers/net/sfc/sfc_resource/ci/driver/resource/linux_efhw_nic.h
--- a/drivers/net/sfc/sfc_resource/ci/driver/resource/linux_efhw_nic.h
+++ /dev/null
@@ -1,69 +0,0 @@
-/****************************************************************************
- * Driver for Solarflare network controllers -
- *          resource management for Xen backend, OpenOnload, etc
- *           (including support for SFE4001 10GBT NIC)
- *
- * This file contains definition of the public type struct linux_efhw_nic.
- *
- * Copyright 2005-2007: Solarflare Communications Inc,
- *                      9501 Jeronimo Road, Suite 250,
- *                      Irvine, CA 92618, USA
- *
- * Developed and maintained by Solarflare Communications:
- *                      <linux-xen-drivers@solarflare.com>
- *                      <onload-dev@solarflare.com>
- *
- * Certain parts of the driver were implemented by
- *          Alexandra Kossovsky <Alexandra.Kossovsky@oktetlabs.ru>
- *          OKTET Labs Ltd, Russia,
- *          http://oktetlabs.ru, <info@oktetlabs.ru>
- *          by request of Solarflare Communications
- *
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 as published
- * by the Free Software Foundation, incorporated herein by reference.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
- ****************************************************************************
- */
-
-#ifndef __CI_DRIVER_RESOURCE_LINUX_RESOURCE__
-#define __CI_DRIVER_RESOURCE_LINUX_RESOURCE__
-
-#include <ci/efrm/efrm_nic.h>
-#include <linux/interrupt.h>
-
-
-/************************************************************************
- * Per-nic structure in the resource driver                             *
- ************************************************************************/
-
-struct linux_efhw_nic {
-	struct efrm_nic efrm_nic;
-
-	struct pci_dev *pci_dev;	/*!< pci descriptor */
-	struct tasklet_struct tasklet;	/*!< for interrupt bottom half */
-
-	/* Physical addresses of the control aperture bar. */
-	unsigned long ctr_ap_pci_addr;
-
-	/*! Callbacks for driverlink, when needed. */
-	struct efx_dl_callbacks *dl_callbacks;
-
-	/*! Event handlers. */
-	struct efhw_ev_handler *ev_handlers;
-
-};
-
-#define linux_efhw_nic(_efhw_nic)					\
-  container_of(_efhw_nic, struct linux_efhw_nic, efrm_nic.efhw_nic)
-
-#endif /* __CI_DRIVER_RESOURCE_LINUX_RESOURCE__ */
diff -r 9566a4a50a43 drivers/net/sfc/sfc_resource/ci/efhw/checks.h
--- a/drivers/net/sfc/sfc_resource/ci/efhw/checks.h
+++ /dev/null
@@ -1,118 +0,0 @@
-/****************************************************************************
- * Driver for Solarflare network controllers -
- *          resource management for Xen backend, OpenOnload, etc
- *           (including support for SFE4001 10GBT NIC)
- *
- * This file provides helpers to turn bit shifts into dword shifts and
- * check that the bit fields haven't overflown the dword etc.
- *
- * Copyright 2005-2007: Solarflare Communications Inc,
- *                      9501 Jeronimo Road, Suite 250,
- *                      Irvine, CA 92618, USA
- *
- * Developed and maintained by Solarflare Communications:
- *                      <linux-xen-drivers@solarflare.com>
- *                      <onload-dev@solarflare.com>
- *
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 as published
- * by the Free Software Foundation, incorporated herein by reference.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
- ****************************************************************************
- */
-
-#ifndef __CI_EFHW_CHECK_H__
-#define __CI_EFHW_CHECK_H__
-
-/*----------------------------------------------------------------------------
- *
- * Helpers to turn bit shifts into dword shifts and check that the bit fields
- * haven't overflown the dword etc. Aim is to preserve consistency with the
- * autogenerated headers - once stable we could hard code.
- *
- *---------------------------------------------------------------------------*/
-
-/* mask constructors */
-#define __FALCON_MASK(WIDTH, T)	((((T)1) << (WIDTH)) - 1)
-#define __FALCON_MASK32(WIDTH)	__FALCON_MASK((WIDTH), uint32_t)
-#define __FALCON_MASK64(WIDTH)	__FALCON_MASK((WIDTH), uint64_t)
-
-#define __FALCON_MASKFIELD32(LBN, WIDTH) \
-	((uint32_t)(__FALCON_MASK32(WIDTH) << (LBN)))
-
-/* constructors for fields which span the first and second dwords */
-#define __LW(LBN)		(32 - LBN)
-#define __LOW(v, LBN, WIDTH) \
-	((uint32_t)(((v) & __FALCON_MASK64(__LW((LBN)))) << (LBN)))
-#define __HIGH(v, LBN, WIDTH) \
-	((uint32_t)(((v) >> __LW((LBN))) & \
-		    __FALCON_MASK64((WIDTH - __LW((LBN))))))
-/* constructors for fields within the second dword */
-#define __DW2(LBN)		((LBN) - 32)
-
-/* constructors for fields which span the second and third dwords */
-#define __LW2(LBN)		(64 - LBN)
-#define __LOW2(v, LBN, WIDTH) \
-	((uint32_t)(((v) & __FALCON_MASK64(__LW2((LBN)))) << ((LBN) - 32)))
-#define __HIGH2(v, LBN, WIDTH) \
-	((uint32_t)(((v) >> __LW2((LBN))) & \
-		    __FALCON_MASK64((WIDTH - __LW2((LBN))))))
-
-/* constructors for fields within the third dword */
-#define __DW3(LBN)		((LBN) - 64)
-
-/* constructors for fields which span the third and fourth dwords */
-#define __LW3(LBN)		(96 - LBN)
-#define __LOW3(v, LBN, WIDTH) \
-	((uint32_t)(((v) & __FALCON_MASK64(__LW3((LBN)))) << ((LBN) - 64)))
-#define __HIGH3(v, LBN, WIDTH) \
-	((ci_unit32)(((v) >> __LW3((LBN))) & \
-		     __FALCON_MASK64((WIDTH - __LW3((LBN))))))
-
-/* constructors for fields within the fourth dword */
-#define __DW4(LBN)		((LBN) - 96)
-
-/* checks that the autogenerated headers are consistent with our model */
-#define __WIDTHCHCK(a, b)	EFHW_ASSERT((a) == (b))
-#define __RANGECHCK(v, WIDTH) \
-	EFHW_ASSERT(((uint64_t)(v) & ~(__FALCON_MASK64((WIDTH)))) == 0)
-
-/* fields within the first dword */
-#define __DWCHCK(LBN, WIDTH) \
-	EFHW_ASSERT(((LBN) >= 0) && (((LBN)+(WIDTH)) <= 32))
-
-/* fields which span the first and second dwords */
-#define __LWCHK(LBN, WIDTH)	EFHW_ASSERT(WIDTH >= __LW(LBN))
-
-/* fields within the second dword */
-#define __DW2CHCK(LBN, WIDTH) \
-	EFHW_ASSERT(((LBN) >= 32) && (((LBN)+(WIDTH)) <= 64))
-
-/* fields which span the second and third dwords */
-#define __LW2CHK(LBN, WIDTH)	EFHW_ASSERT(WIDTH >= __LW2(LBN))
-
-/* fields within the third dword */
-#define __DW3CHCK(LBN, WIDTH) \
-	EFHW_ASSERT(((LBN) >= 64) && (((LBN)+(WIDTH)) <= 96))
-
-/* fields which span the third and fourth dwords */
-#define __LW3CHK(LBN, WIDTH)	EFHW_ASSERT(WIDTH >= __LW3(LBN))
-
-/* fields within the fourth dword */
-#define __DW4CHCK(LBN, WIDTH) \
-	EFHW_ASSERT(((LBN) >= 96) && (((LBN)+(WIDTH)) <= 128))
-
-/* fields in the first qword */
-#define __QWCHCK(LBN, WIDTH) \
-	EFHW_ASSERT(((LBN) >= 0) && (((LBN)+(WIDTH)) <= 64))
-
-#endif /* __CI_EFHW_CHECK_H__ */
diff -r 9566a4a50a43 drivers/net/sfc/sfc_resource/ci/efhw/common.h
--- a/drivers/net/sfc/sfc_resource/ci/efhw/common.h
+++ /dev/null
@@ -1,97 +0,0 @@
-/****************************************************************************
- * Driver for Solarflare network controllers -
- *          resource management for Xen backend, OpenOnload, etc
- *           (including support for SFE4001 10GBT NIC)
- *
- * This file provides API of the efhw library which may be used both from
- * the kernel and from the user-space code.
- *
- * Copyright 2005-2007: Solarflare Communications Inc,
- *                      9501 Jeronimo Road, Suite 250,
- *                      Irvine, CA 92618, USA
- *
- * Developed and maintained by Solarflare Communications:
- *                      <linux-xen-drivers@solarflare.com>
- *                      <onload-dev@solarflare.com>
- *
- * Certain parts of the driver were implemented by
- *          Alexandra Kossovsky <Alexandra.Kossovsky@oktetlabs.ru>
- *          OKTET Labs Ltd, Russia,
- *          http://oktetlabs.ru, <info@oktetlabs.ru>
- *          by request of Solarflare Communications
- *
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 as published
- * by the Free Software Foundation, incorporated herein by reference.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
- ****************************************************************************
- */
-
-#ifndef __CI_EFHW_COMMON_H__
-#define __CI_EFHW_COMMON_H__
-
-#include <ci/efhw/common_sysdep.h>
-
-enum efhw_arch {
-	EFHW_ARCH_FALCON,
-};
-
-typedef uint32_t efhw_buffer_addr_t;
-#define EFHW_BUFFER_ADDR_FMT	"[ba:%"PRIx32"]"
-
-/*! Comment? */
-typedef union {
-	uint64_t u64;
-	struct {
-		uint32_t a;
-		uint32_t b;
-	} opaque;
-} efhw_event_t;
-
-/* Flags for TX/RX queues */
-#define EFHW_VI_JUMBO_EN           0x01    /*! scatter RX over multiple desc */
-#define EFHW_VI_ISCSI_RX_HDIG_EN   0x02    /*! iscsi rx header digest */
-#define EFHW_VI_ISCSI_TX_HDIG_EN   0x04    /*! iscsi tx header digest */
-#define EFHW_VI_ISCSI_RX_DDIG_EN   0x08    /*! iscsi rx data digest */
-#define EFHW_VI_ISCSI_TX_DDIG_EN   0x10    /*! iscsi tx data digest */
-#define EFHW_VI_TX_PHYS_ADDR_EN    0x20    /*! TX physical address mode */
-#define EFHW_VI_RX_PHYS_ADDR_EN    0x40    /*! RX physical address mode */
-#define EFHW_VI_RM_WITH_INTERRUPT  0x80    /*! VI with an interrupt */
-#define EFHW_VI_TX_IP_CSUM_DIS     0x100   /*! enable ip checksum generation */
-#define EFHW_VI_TX_TCPUDP_CSUM_DIS 0x200   /*! enable tcp/udp checksum
-					       generation */
-#define EFHW_VI_TX_TCPUDP_ONLY     0x400   /*! drop non-tcp/udp packets */
-
-/* Types of hardware filter */
-/* Each of these values implicitly selects scatter filters on B0 - or in
-   EFHW_IP_FILTER_TYPE_NOSCAT_B0_MASK if a non-scatter filter is required */
-#define EFHW_IP_FILTER_TYPE_UDP_WILDCARD  (0)	/* dest host only */
-#define EFHW_IP_FILTER_TYPE_UDP_FULL      (1)	/* dest host and port */
-#define EFHW_IP_FILTER_TYPE_TCP_WILDCARD  (2)	/* dest based filter */
-#define EFHW_IP_FILTER_TYPE_TCP_FULL      (3)	/* src  filter */
-/* Same again, but with RSS (for B0 only) */
-#define EFHW_IP_FILTER_TYPE_UDP_WILDCARD_RSS_B0  (4)
-#define EFHW_IP_FILTER_TYPE_UDP_FULL_RSS_B0      (5)
-#define EFHW_IP_FILTER_TYPE_TCP_WILDCARD_RSS_B0  (6)
-#define EFHW_IP_FILTER_TYPE_TCP_FULL_RSS_B0      (7)
-
-#define EFHW_IP_FILTER_TYPE_FULL_MASK      (0x1) /* Mask for full / wildcard */
-#define EFHW_IP_FILTER_TYPE_TCP_MASK       (0x2) /* Mask for TCP type */
-#define EFHW_IP_FILTER_TYPE_RSS_B0_MASK    (0x4) /* Mask for B0 RSS enable */
-#define EFHW_IP_FILTER_TYPE_NOSCAT_B0_MASK (0x8) /* Mask for B0 SCATTER dsbl */
-
-#define EFHW_IP_FILTER_TYPE_MASK	(0xffff) /* Mask of types above */
-
-#define EFHW_IP_FILTER_BROADCAST	(0x10000) /* driverlink filter
-						     support */
-
-#endif /* __CI_EFHW_COMMON_H__ */
diff -r 9566a4a50a43 drivers/net/sfc/sfc_resource/ci/efhw/common_sysdep.h
--- a/drivers/net/sfc/sfc_resource/ci/efhw/common_sysdep.h
+++ /dev/null
@@ -1,61 +0,0 @@
-/****************************************************************************
- * Driver for Solarflare network controllers -
- *          resource management for Xen backend, OpenOnload, etc
- *           (including support for SFE4001 10GBT NIC)
- *
- * This file provides version-independent Linux kernel API for
- * userland-to-kernel interfaces.
- * Only kernels >=2.6.9 are supported.
- *
- * Copyright 2005-2007: Solarflare Communications Inc,
- *                      9501 Jeronimo Road, Suite 250,
- *                      Irvine, CA 92618, USA
- *
- * Developed and maintained by Solarflare Communications:
- *                      <linux-xen-drivers@solarflare.com>
- *                      <onload-dev@solarflare.com>
- *
- * Certain parts of the driver were implemented by
- *          Alexandra Kossovsky <Alexandra.Kossovsky@oktetlabs.ru>
- *          OKTET Labs Ltd, Russia,
- *          http://oktetlabs.ru, <info@oktetlabs.ru>
- *          by request of Solarflare Communications
- *
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 as published
- * by the Free Software Foundation, incorporated herein by reference.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
- ****************************************************************************
- */
-
-#ifndef __CI_EFHW_COMMON_LINUX_H__
-#define __CI_EFHW_COMMON_LINUX_H__
-
-#include <linux/types.h>
-
-/* Dirty hack, but Linux kernel does not provide DMA_ADDR_T_FMT */
-#if BITS_PER_LONG == 64 || defined(CONFIG_HIGHMEM64G)
-#define DMA_ADDR_T_FMT "%llx"
-#else
-#define DMA_ADDR_T_FMT "%x"
-#endif
-
-/* Linux kernel also does not provide PRIx32... Sigh. */
-#define PRIx32 "x"
-
-#ifdef __ia64__
-# define PRIx64 "lx"
-#else
-# define PRIx64 "llx"
-#endif
-
-#endif /* __CI_EFHW_COMMON_LINUX_H__ */
diff -r 9566a4a50a43 drivers/net/sfc/sfc_resource/ci/efhw/debug.h
--- a/drivers/net/sfc/sfc_resource/ci/efhw/debug.h
+++ /dev/null
@@ -1,84 +0,0 @@
-/****************************************************************************
- * Driver for Solarflare network controllers -
- *          resource management for Xen backend, OpenOnload, etc
- *           (including support for SFE4001 10GBT NIC)
- *
- * This file provides debug-related API for efhw library using Linux kernel
- * primitives.
- *
- * Copyright 2005-2007: Solarflare Communications Inc,
- *                      9501 Jeronimo Road, Suite 250,
- *                      Irvine, CA 92618, USA
- *
- * Developed and maintained by Solarflare Communications:
- *                      <linux-xen-drivers@solarflare.com>
- *                      <onload-dev@solarflare.com>
- *
- * Certain parts of the driver were implemented by
- *          Alexandra Kossovsky <Alexandra.Kossovsky@oktetlabs.ru>
- *          OKTET Labs Ltd, Russia,
- *          http://oktetlabs.ru, <info@oktetlabs.ru>
- *          by request of Solarflare Communications
- *
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 as published
- * by the Free Software Foundation, incorporated herein by reference.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
- ****************************************************************************
- */
-
-#ifndef __CI_EFHW_DEBUG_LINUX_H__
-#define __CI_EFHW_DEBUG_LINUX_H__
-
-#define EFHW_PRINTK_PREFIX "[sfc efhw] "
-
-#define EFHW_PRINTK(level, fmt, ...) \
-	printk(level EFHW_PRINTK_PREFIX fmt "\n", __VA_ARGS__)
-
-/* Following macros should be used with non-zero format parameters
- * due to __VA_ARGS__ limitations.  Use "%s" with __func__ if you can't
- * find better parameters. */
-#define EFHW_ERR(fmt, ...)     EFHW_PRINTK(KERN_ERR, fmt, __VA_ARGS__)
-#define EFHW_WARN(fmt, ...)    EFHW_PRINTK(KERN_WARNING, fmt, __VA_ARGS__)
-#define EFHW_NOTICE(fmt, ...)  EFHW_PRINTK(KERN_NOTICE, fmt, __VA_ARGS__)
-#if 0 && !defined(NDEBUG)
-#define EFHW_TRACE(fmt, ...) EFHW_PRINTK(KERN_DEBUG, fmt, __VA_ARGS__)
-#else
-#define EFHW_TRACE(fmt, ...)
-#endif
-
-#ifndef NDEBUG
-#define EFHW_ASSERT(cond)  BUG_ON((cond) == 0)
-#define EFHW_DO_DEBUG(expr) expr
-#else
-#define EFHW_ASSERT(cond)
-#define EFHW_DO_DEBUG(expr)
-#endif
-
-#define EFHW_TEST(expr)			\
-	do {				\
-		if (unlikely(!(expr)))	\
-		BUG();			\
-	} while (0)
-
-/* Build time asserts. We paste the line number into the type name
- * so that the macro can be used more than once per file even if the
- * compiler objects to multiple identical typedefs. Collisions
- * between use in different header files is still possible. */
-#ifndef EFHW_BUILD_ASSERT
-#define __EFHW_BUILD_ASSERT_NAME(_x) __EFHW_BUILD_ASSERT_ILOATHECPP(_x)
-#define __EFHW_BUILD_ASSERT_ILOATHECPP(_x)  __EFHW_BUILD_ASSERT__ ##_x
-#define EFHW_BUILD_ASSERT(e) \
-	typedef char __EFHW_BUILD_ASSERT_NAME(__LINE__)[(e) ? 1 : -1]
-#endif
-
-#endif /* __CI_EFHW_DEBUG_LINUX_H__ */
diff -r 9566a4a50a43 drivers/net/sfc/sfc_resource/ci/efhw/efhw_config.h
--- a/drivers/net/sfc/sfc_resource/ci/efhw/efhw_config.h
+++ /dev/null
@@ -1,43 +0,0 @@
-/****************************************************************************
- * Driver for Solarflare network controllers -
- *          resource management for Xen backend, OpenOnload, etc
- *           (including support for SFE4001 10GBT NIC)
- *
- * This file provides some limits used in both kernel and userland code.
- *
- * Copyright 2005-2007: Solarflare Communications Inc,
- *                      9501 Jeronimo Road, Suite 250,
- *                      Irvine, CA 92618, USA
- *
- * Developed and maintained by Solarflare Communications:
- *                      <linux-xen-drivers@solarflare.com>
- *                      <onload-dev@solarflare.com>
- *
- * Certain parts of the driver were implemented by
- *          Alexandra Kossovsky <Alexandra.Kossovsky@oktetlabs.ru>
- *          OKTET Labs Ltd, Russia,
- *          http://oktetlabs.ru, <info@oktetlabs.ru>
- *          by request of Solarflare Communications
- *
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 as published
- * by the Free Software Foundation, incorporated herein by reference.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
- ****************************************************************************
- */
-
-#ifndef __CI_EFHW_EFAB_CONFIG_H__
-#define __CI_EFHW_EFAB_CONFIG_H__
-
-#define EFHW_MAX_NR_DEVS 5	/* max number of efhw devices supported */
-
-#endif /* __CI_EFHW_EFAB_CONFIG_H__ */
diff -r 9566a4a50a43 drivers/net/sfc/sfc_resource/ci/efhw/efhw_types.h
--- a/drivers/net/sfc/sfc_resource/ci/efhw/efhw_types.h
+++ /dev/null
@@ -1,382 +0,0 @@
-/****************************************************************************
- * Driver for Solarflare network controllers -
- *          resource management for Xen backend, OpenOnload, etc
- *           (including support for SFE4001 10GBT NIC)
- *
- * This file provides struct efhw_nic and some related types.
- *
- * Copyright 2005-2007: Solarflare Communications Inc,
- *                      9501 Jeronimo Road, Suite 250,
- *                      Irvine, CA 92618, USA
- *
- * Developed and maintained by Solarflare Communications:
- *                      <linux-xen-drivers@solarflare.com>
- *                      <onload-dev@solarflare.com>
- *
- * Certain parts of the driver were implemented by
- *          Alexandra Kossovsky <Alexandra.Kossovsky@oktetlabs.ru>
- *          OKTET Labs Ltd, Russia,
- *          http://oktetlabs.ru, <info@oktetlabs.ru>
- *          by request of Solarflare Communications
- *
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 as published
- * by the Free Software Foundation, incorporated herein by reference.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
- ****************************************************************************
- */
-
-#ifndef __CI_EFHW_EFAB_TYPES_H__
-#define __CI_EFHW_EFAB_TYPES_H__
-
-#include <ci/efhw/efhw_config.h>
-#include <ci/efhw/hardware_sysdep.h>
-#include <ci/efhw/iopage_types.h>
-#include <ci/efhw/sysdep.h>
-
-/*--------------------------------------------------------------------
- *
- * forward type declarations
- *
- *--------------------------------------------------------------------*/
-
-struct efhw_nic;
-
-/*--------------------------------------------------------------------
- *
- * Managed interface
- *
- *--------------------------------------------------------------------*/
-
-struct efhw_buffer_table_allocation{
-	unsigned base;
-	unsigned order;
-};
-
-struct eventq_resource_hardware {
-	/*!iobuffer allocated for eventq - can be larger than eventq */
-	struct efhw_iopages iobuff;
-	unsigned iobuff_off;
-	struct efhw_buffer_table_allocation buf_tbl_alloc;
-	int capacity;		/*!< capacity of event queue */
-};
-
-/*--------------------------------------------------------------------
- *
- * event queues and event driven callbacks
- *
- *--------------------------------------------------------------------*/
-
-struct efhw_keventq {
-	int lock;
-	caddr_t evq_base;
-	int32_t evq_ptr;
-	uint32_t evq_mask;
-	unsigned instance;
-	struct eventq_resource_hardware hw;
-	struct efhw_ev_handler *ev_handlers;
-};
-
-/*--------------------------------------------------------------------
- *
- * filters
- *
- *--------------------------------------------------------------------*/
-
-struct efhw_filter_spec {
-	uint dmaq_id;
-	uint32_t saddr_le32;
-	uint32_t daddr_le32;
-	uint16_t sport_le16;
-	uint16_t dport_le16;
-	unsigned tcp     : 1;
-	unsigned full    : 1;
-	unsigned rss     : 1;  /* not supported on A1 */
-	unsigned scatter : 1;  /* not supported on A1 */
-};
-
-struct efhw_filter_depth {
-	unsigned needed;
-	unsigned max;
-};
-
-struct efhw_filter_search_limits {
-	unsigned tcp_full;
-	unsigned tcp_wild;
-	unsigned udp_full;
-	unsigned udp_wild;
-};
-
-
-/**********************************************************************
- * Portable HW interface. ***************************************
- **********************************************************************/
-
-/*--------------------------------------------------------------------
- *
- * EtherFabric Functional units - configuration and control
- *
- *--------------------------------------------------------------------*/
-
-struct efhw_func_ops {
-
-  /*-------------- Initialisation ------------ */
-
-	/*! close down all hardware functional units - leaves NIC in a safe
-	   state for driver unload */
-	void (*close_hardware) (struct efhw_nic *nic);
-
-	/*! initialise all hardware functional units */
-	int (*init_hardware) (struct efhw_nic *nic,
-			      struct efhw_ev_handler *,
-			      const uint8_t *mac_addr, int non_irq_evq);
-
-  /*-------------- Interrupt support  ------------ */
-
-	/*! Main interrupt routine
-	 **        This function returns,
-	 **  - zero,       if the IRQ was not generated by EF1
-	 **  - non-zero,   if EF1 was the source of the IRQ
-	 **
-	 **
-	 ** opaque is an OS provided pointer for use by the OS callbacks
-	 ** e.g in Windows used to indicate DPC scheduled
-	 */
-	int (*interrupt) (struct efhw_nic *nic);
-
-	/*! Enable the interrupt */
-	void (*interrupt_enable) (struct efhw_nic *nic);
-
-	/*! Disable the interrupt */
-	void (*interrupt_disable) (struct efhw_nic *nic);
-
-	/*! Set interrupt moderation strategy for the given IRQ unit
-	 ** val is in usec
-	 */
-	void (*set_interrupt_moderation)(struct efhw_nic *nic, int evq,
-					 uint val);
-
-  /*-------------- Event support  ------------ */
-
-	/*! Enable the given event queue
-	   depending on the underlying implementation (EF1 or Falcon) then
-	   either a q_base_addr in host memory, or a buffer base id should
-	   be proivded
-	 */
-	void (*event_queue_enable) (struct efhw_nic *nic,
-				    uint evq,	/* evnt queue index */
-				    uint evq_size,	/* units of #entries */
-				    dma_addr_t q_base_addr, uint buf_base_id,
-				    int interrupting);
-
-	/*! Disable the given event queue (and any associated timer) */
-	void (*event_queue_disable) (struct efhw_nic *nic, uint evq,
-				     int timer_only);
-
-	/*! request wakeup from the NIC on a given event Q */
-	void (*wakeup_request) (struct efhw_nic *nic, dma_addr_t q_base_addr,
-				int next_i, int evq);
-
-	/*! Push a SW event on a given eventQ */
-	void (*sw_event) (struct efhw_nic *nic, int data, int evq);
-
-  /*-------------- IP Filter API  ------------ */
-
-	/*! Setup a given filter - The software can request a filter_i,
-	 * but some EtherFabric implementations will override with
-	 * a more suitable index
-	 */
-	int (*ipfilter_set) (struct efhw_nic *nic, int type,
-			     int *filter_i, int dmaq,
-			     unsigned saddr_be32, unsigned sport_be16,
-			     unsigned daddr_be32, unsigned dport_be16);
-
-	/*! Clear down a given filter */
-	void (*ipfilter_clear) (struct efhw_nic *nic, int filter_idx);
-
-  /*-------------- DMA support  ------------ */
-
-	/*! Initialise NIC state for a given TX DMAQ */
-	void (*dmaq_tx_q_init) (struct efhw_nic *nic,
-				uint dmaq, uint evq, uint owner, uint tag,
-				uint dmaq_size, uint buf_idx, uint flags);
-
-	/*! Initialise NIC state for a given RX DMAQ */
-	void (*dmaq_rx_q_init) (struct efhw_nic *nic,
-				uint dmaq, uint evq, uint owner, uint tag,
-				uint dmaq_size, uint buf_idx, uint flags);
-
-	/*! Disable a given TX DMAQ */
-	void (*dmaq_tx_q_disable) (struct efhw_nic *nic, uint dmaq);
-
-	/*! Disable a given RX DMAQ */
-	void (*dmaq_rx_q_disable) (struct efhw_nic *nic, uint dmaq);
-
-	/*! Flush a given TX DMA channel */
-	int (*flush_tx_dma_channel) (struct efhw_nic *nic, uint dmaq);
-
-	/*! Flush a given RX DMA channel */
-	int (*flush_rx_dma_channel) (struct efhw_nic *nic, uint dmaq);
-
-  /*-------------- Buffer table Support ------------ */
-
-	/*! Initialise a buffer table page */
-	void (*buffer_table_set) (struct efhw_nic *nic,
-				  dma_addr_t dma_addr,
-				  uint bufsz, uint region,
-				  int own_id, int buffer_id);
-
-	/*! Initialise a block of buffer table pages */
-	void (*buffer_table_set_n) (struct efhw_nic *nic, int buffer_id,
-				    dma_addr_t dma_addr,
-				    uint bufsz, uint region,
-				    int n_pages, int own_id);
-
-	/*! Clear a block of buffer table pages */
-	void (*buffer_table_clear) (struct efhw_nic *nic, int buffer_id,
-				    int num);
-
-	/*! Commit a buffer table update  */
-	void (*buffer_table_commit) (struct efhw_nic *nic);
-
-  /*-------------- New filter API ------------ */
-
-	/*! Set a given filter */
-	int (*filter_set) (struct efhw_nic *nic, struct efhw_filter_spec *spec,
-			   int *filter_idx_out);
-
-	/*! Clear a given filter */
-	void (*filter_clear) (struct efhw_nic *nic, int filter_idx);
-};
-
-
-/*----------------------------------------------------------------------------
- *
- * NIC type
- *
- *---------------------------------------------------------------------------*/
-
-struct efhw_device_type {
-	int  arch;            /* enum efhw_arch */
-	char variant;         /* 'A', 'B', ... */
-	int  revision;        /* 0, 1, ... */
-};
-
-
-/*----------------------------------------------------------------------------
- *
- * EtherFabric NIC instance - nic.c for HW independent functions
- *
- *---------------------------------------------------------------------------*/
-
-/*! */
-struct efhw_nic {
-	/*! zero base index in efrm_nic_tablep->nic array */
-	int index;
-	int ifindex;		/*!< OS level nic index */
-	struct net *nd_net;
-
-	struct efhw_device_type devtype;
-
-	/*! Options that can be set by user. */
-	unsigned options;
-# define NIC_OPT_EFTEST             0x1	/* owner is an eftest app */
-
-# define NIC_OPT_DEFAULT            0
-
-	/*! Internal flags that indicate hardware properties at runtime. */
-	unsigned flags;
-# define NIC_FLAG_NO_INTERRUPT          0x01 /* to be set at init time only */
-# define NIC_FLAG_TRY_MSI               0x02
-# define NIC_FLAG_MSI                   0x04
-# define NIC_FLAG_OS_IRQ_EN             0x08
-
-	unsigned mtu;		/*!< MAC MTU (includes MAC hdr) */
-
-	/* hardware resources */
-
-	/*! I/O address of the start of the bar */
-	volatile char __iomem *bar_ioaddr;
-
-	/*! Bar number of control aperture. */
-	unsigned ctr_ap_bar;
-	/*! Length of control aperture in bytes. */
-	unsigned ctr_ap_bytes;
-
-	uint8_t mac_addr[ETH_ALEN];	/*!< mac address  */
-
-	/*! EtherFabric Functional Units -- functions */
-	const struct efhw_func_ops *efhw_func;
-
-	/*! This lock protects a number of misc NIC resources.  It should
-	 * only be used for things that can be at the bottom of the lock
-	 * order.  ie. You mustn't attempt to grab any other lock while
-	 * holding this one.
-	 */
-	spinlock_t *reg_lock;
-	spinlock_t the_reg_lock;
-
-	int buf_commit_outstanding;	/*!< outstanding buffer commits */
-
-	/*! interrupt callbacks (hard-irq) */
-	void (*irq_handler) (struct efhw_nic *, int unit);
-
-	/*! event queues per driver */
-	struct efhw_keventq interrupting_evq;
-
-/* for marking when we are not using an IRQ unit
-      - 0 is a valid offset to an IRQ unit on EF1! */
-#define EFHW_IRQ_UNIT_UNUSED  0xffff
-	/*! interrupt unit in use for the interrupting event queue  */
-	unsigned int irq_unit;
-
-	struct efhw_keventq non_interrupting_evq;
-
-	struct efhw_iopage irq_iobuff;	/*!<  Falcon SYSERR interrupt */
-
-	/* The new driverlink infrastructure. */
-	struct efx_dl_device *net_driver_dev;
-	struct efx_dlfilt_cb_s *dlfilter_cb;
-
-	/*! Bit masks of the sizes of event queues and dma queues supported
-	 * by the nic. */
-	unsigned evq_sizes;
-	unsigned rxq_sizes;
-	unsigned txq_sizes;
-
-	/* Size of filter table. */
-	unsigned ip_filter_tbl_size;
-
-	/* Number of filters currently used */
-	unsigned ip_filter_tbl_used;
-
-	/* Dynamically allocated filter state. */
-	uint8_t *filter_in_use;
-	struct efhw_filter_spec *filter_spec_cache;
-
-	/* Currently required and maximum filter table search depths. */
-	struct efhw_filter_depth tcp_full_srch;
-	struct efhw_filter_depth tcp_wild_srch;
-	struct efhw_filter_depth udp_full_srch;
-	struct efhw_filter_depth udp_wild_srch;
-
-	/* Number of event queues, DMA queues and timers. */
-	unsigned num_evqs;
-	unsigned num_dmaqs;
-	unsigned num_timers;
-};
-
-
-#define EFHW_KVA(nic)       ((nic)->bar_ioaddr)
-
-
-#endif /* __CI_EFHW_EFHW_TYPES_H__ */
diff -r 9566a4a50a43 drivers/net/sfc/sfc_resource/ci/efhw/eventq.h
--- a/drivers/net/sfc/sfc_resource/ci/efhw/eventq.h
+++ /dev/null
@@ -1,72 +0,0 @@
-/****************************************************************************
- * Driver for Solarflare network controllers -
- *          resource management for Xen backend, OpenOnload, etc
- *           (including support for SFE4001 10GBT NIC)
- *
- * This file contains API provided by efhw/eventq.c file.  This file is not
- * designed for use outside of the SFC resource driver.
- *
- * Copyright 2005-2007: Solarflare Communications Inc,
- *                      9501 Jeronimo Road, Suite 250,
- *                      Irvine, CA 92618, USA
- *
- * Developed and maintained by Solarflare Communications:
- *                      <linux-xen-drivers@solarflare.com>
- *                      <onload-dev@solarflare.com>
- *
- * Certain parts of the driver were implemented by
- *          Alexandra Kossovsky <Alexandra.Kossovsky@oktetlabs.ru>
- *          OKTET Labs Ltd, Russia,
- *          http://oktetlabs.ru, <info@oktetlabs.ru>
- *          by request of Solarflare Communications
- *
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 as published
- * by the Free Software Foundation, incorporated herein by reference.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
- ****************************************************************************
- */
-
-#ifndef __CI_EFHW_EVENTQ_H__
-#define __CI_EFHW_EVENTQ_H__
-
-#include <ci/efhw/efhw_types.h>
-#include <ci/efhw/eventq_macros.h>
-
-/*! Poll the event queue. */
-extern int efhw_keventq_poll(struct efhw_nic *, struct efhw_keventq *);
-
-/*! Callbacks for handling events. */
-struct efhw_ev_handler {
-	void (*wakeup_fn)(struct efhw_nic *nic, unsigned);
-	void (*timeout_fn)(struct efhw_nic *nic, unsigned);
-	void (*dmaq_flushed_fn) (struct efhw_nic *, unsigned, int);
-};
-
-extern int efhw_keventq_ctor(struct efhw_nic *, int instance,
-			     struct efhw_keventq *, struct efhw_ev_handler *);
-extern void efhw_keventq_dtor(struct efhw_nic *, struct efhw_keventq *);
-
-extern void efhw_handle_txdmaq_flushed(struct efhw_nic *,
-				       struct efhw_ev_handler *,
-				       efhw_event_t *);
-extern void efhw_handle_rxdmaq_flushed(struct efhw_nic *,
-				       struct efhw_ev_handler *,
-				       efhw_event_t *);
-extern void efhw_handle_wakeup_event(struct efhw_nic *,
-				     struct efhw_ev_handler *,
-				     efhw_event_t *);
-extern void efhw_handle_timeout_event(struct efhw_nic *,
-				      struct efhw_ev_handler *,
-				      efhw_event_t *);
-
-#endif /* __CI_EFHW_EVENTQ_H__ */
diff -r 9566a4a50a43 drivers/net/sfc/sfc_resource/ci/efhw/eventq_macros.h
--- a/drivers/net/sfc/sfc_resource/ci/efhw/eventq_macros.h
+++ /dev/null
@@ -1,77 +0,0 @@
-/****************************************************************************
- * Driver for Solarflare network controllers -
- *          resource management for Xen backend, OpenOnload, etc
- *           (including support for SFE4001 10GBT NIC)
- *
- * This file provides some event-related macros.  This file is designed for
- * use from kernel and from the userland contexts.
- *
- * Copyright 2005-2007: Solarflare Communications Inc,
- *                      9501 Jeronimo Road, Suite 250,
- *                      Irvine, CA 92618, USA
- *
- * Developed and maintained by Solarflare Communications:
- *                      <linux-xen-drivers@solarflare.com>
- *                      <onload-dev@solarflare.com>
- *
- * Certain parts of the driver were implemented by
- *          Alexandra Kossovsky <Alexandra.Kossovsky@oktetlabs.ru>
- *          OKTET Labs Ltd, Russia,
- *          http://oktetlabs.ru, <info@oktetlabs.ru>
- *          by request of Solarflare Communications
- *
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 as published
- * by the Free Software Foundation, incorporated herein by reference.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
- ****************************************************************************
- */
-
-#ifndef __CI_EFHW_EVENTQ_MACROS_H__
-#define __CI_EFHW_EVENTQ_MACROS_H__
-
-#include <ci/efhw/common.h>
-
-/*--------------------------------------------------------------------
- *
- * Event Queue manipulation
- *
- *--------------------------------------------------------------------*/
-
-#define EFHW_EVENT_OFFSET(q, s, i)					\
-	(((s)->evq_ptr - (i) * (int32_t)sizeof(efhw_event_t))		\
-	 & (q)->evq_mask)
-
-#define EFHW_EVENT_PTR(q, s, i)						\
-	((efhw_event_t *)((q)->evq_base + EFHW_EVENT_OFFSET(q, s, i)))
-
-#define EFHW_EVENTQ_NEXT(s)						\
-	do { ((s)->evq_ptr += sizeof(efhw_event_t)); } while (0)
-
-#define EFHW_EVENTQ_PREV(s)						\
-	do { ((s)->evq_ptr -= sizeof(efhw_event_t)); } while (0)
-
-/* Be worried about this on byteswapped machines */
-/* Due to crazy chipsets, we see the event words being written in
-** arbitrary order (bug4539).  So test for presence of event must ensure
-** that both halves have changed from the null.
-*/
-#define EFHW_IS_EVENT(evp)			\
-	(((evp)->opaque.a != (uint32_t)-1) &&	\
-	 ((evp)->opaque.b != (uint32_t)-1))
-#define EFHW_CLEAR_EVENT(evp)       ((evp)->u64 = (uint64_t)-1)
-#define EFHW_CLEAR_EVENT_VALUE      0xff
-
-#define EFHW_EVENT_OVERFLOW(evq, s)			\
-	(EFHW_IS_EVENT(EFHW_EVENT_PTR(evq, s, 1)))
-
-#endif /* __CI_EFHW_EVENTQ_MACROS_H__ */
diff -r 9566a4a50a43 drivers/net/sfc/sfc_resource/ci/efhw/falcon.h
--- a/drivers/net/sfc/sfc_resource/ci/efhw/falcon.h
+++ /dev/null
@@ -1,94 +0,0 @@
-/****************************************************************************
- * Driver for Solarflare network controllers -
- *          resource management for Xen backend, OpenOnload, etc
- *           (including support for SFE4001 10GBT NIC)
- *
- * This file contains API provided by efhw/falcon.c file.  This file is not
- * designed for use outside of the SFC resource driver.
- *
- * Copyright 2005-2007: Solarflare Communications Inc,
- *                      9501 Jeronimo Road, Suite 250,
- *                      Irvine, CA 92618, USA
- *
- * Developed and maintained by Solarflare Communications:
- *                      <linux-xen-drivers@solarflare.com>
- *                      <onload-dev@solarflare.com>
- *
- * Certain parts of the driver were implemented by
- *          Alexandra Kossovsky <Alexandra.Kossovsky@oktetlabs.ru>
- *          OKTET Labs Ltd, Russia,
- *          http://oktetlabs.ru, <info@oktetlabs.ru>
- *          by request of Solarflare Communications
- *
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 as published
- * by the Free Software Foundation, incorporated herein by reference.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
- ****************************************************************************
- */
-
-#ifndef __CI_EFHW_FALCON_H__
-#define __CI_EFHW_FALCON_H__
-
-#include <ci/efhw/efhw_types.h>
-#include <ci/efhw/common.h>
-
-/*----------------------------------------------------------------------------
- *
- * Locks - unfortunately required
- *
- *---------------------------------------------------------------------------*/
-
-#define FALCON_LOCK_DECL        irq_flags_t lock_state
-#define FALCON_LOCK_LOCK(nic) \
-	spin_lock_irqsave((nic)->reg_lock, lock_state)
-#define FALCON_LOCK_UNLOCK(nic) \
-	spin_unlock_irqrestore((nic)->reg_lock, lock_state)
-
-extern struct efhw_func_ops falcon_char_functional_units;
-
-/*! specify a pace value for a TX DMA Queue */
-extern void falcon_nic_pace(struct efhw_nic *nic, uint dmaq, uint pace);
-
-/*! configure the pace engine */
-extern void falcon_nic_pace_cfg(struct efhw_nic *nic, int fb_base,
-				int bin_thresh);
-
-/*! confirm buffer table updates - should be used for items where
-   loss of data would be unacceptable. E.g for the buffers that back
-   an event or DMA queue */
-extern void falcon_nic_buffer_table_confirm(struct efhw_nic *nic);
-
-/*! Reset the all the TX DMA queue pointers. */
-extern void falcon_clobber_tx_dma_ptrs(struct efhw_nic *nic, uint dmaq);
-
-extern int
-falcon_handle_char_event(struct efhw_nic *nic,
-			 struct efhw_ev_handler *h, efhw_event_t *evp);
-
-/*! Acknowledge to HW that processing is complete on a given event queue */
-extern void falcon_nic_evq_ack(struct efhw_nic *nic, uint evq,	/* evq id */
-			       uint rptr,	/* new read pointer update */
-			       bool wakeup	/* request a wakeup event if
-						   ptr's != */
-    );
-
-extern void
-falcon_nic_buffer_table_set_n(struct efhw_nic *nic, int buffer_id,
-			      dma_addr_t dma_addr, uint bufsz, uint region,
-			      int n_pages, int own_id);
-
-extern int falcon_nic_filter_ctor(struct efhw_nic *nic);
-
-extern void falcon_nic_filter_dtor(struct efhw_nic *nic);
-
-#endif /* __CI_EFHW_FALCON_H__ */
diff -r 9566a4a50a43 drivers/net/sfc/sfc_resource/ci/efhw/falcon_hash.h
--- a/drivers/net/sfc/sfc_resource/ci/efhw/falcon_hash.h
+++ /dev/null
@@ -1,58 +0,0 @@
-/****************************************************************************
- * Driver for Solarflare network controllers -
- *          resource management for Xen backend, OpenOnload, etc
- *           (including support for SFE4001 10GBT NIC)
- *
- * This file contains API provided by efhw/falcon_hash.c file.
- * Function declared in this file are not exported from the Linux
- * sfc_resource driver.
- *
- * Copyright 2005-2007: Solarflare Communications Inc,
- *                      9501 Jeronimo Road, Suite 250,
- *                      Irvine, CA 92618, USA
- *
- * Developed and maintained by Solarflare Communications:
- *                      <linux-xen-drivers@solarflare.com>
- *                      <onload-dev@solarflare.com>
- *
- * Certain parts of the driver were implemented by
- *          Alexandra Kossovsky <Alexandra.Kossovsky@oktetlabs.ru>
- *          OKTET Labs Ltd, Russia,
- *          http://oktetlabs.ru, <info@oktetlabs.ru>
- *          by request of Solarflare Communications
- *
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 as published
- * by the Free Software Foundation, incorporated herein by reference.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
- ****************************************************************************
- */
-
-#ifndef __CI_EFHW_FALCON_HASH_H__
-#define __CI_EFHW_FALCON_HASH_H__
-
-extern unsigned int
-falcon_hash_get_ip_key(unsigned int src_ip, unsigned int src_port,
-		       unsigned int dest_ip, unsigned int dest_port,
-		       int tcp, int full);
-
-extern unsigned int
-falcon_hash_function1(unsigned int key, unsigned int nfilters);
-
-extern unsigned int
-falcon_hash_function2(unsigned int key, unsigned int nfilters);
-
-extern unsigned int
-falcon_hash_iterator(unsigned int hash1, unsigned int hash2,
-		     unsigned int n_search, unsigned int nfilters);
-
-#endif /* __CI_EFHW_FALCON_HASH_H__ */
diff -r 9566a4a50a43 drivers/net/sfc/sfc_resource/ci/efhw/hardware_sysdep.h
--- a/drivers/net/sfc/sfc_resource/ci/efhw/hardware_sysdep.h
+++ /dev/null
@@ -1,69 +0,0 @@
-/****************************************************************************
- * Driver for Solarflare network controllers -
- *          resource management for Xen backend, OpenOnload, etc
- *           (including support for SFE4001 10GBT NIC)
- *
- * This file provides version-independent Linux kernel API for header files
- * with hardware-related definitions (in ci/driver/efab/hardware*).
- * Only kernels >=2.6.9 are supported.
- *
- * Copyright 2005-2007: Solarflare Communications Inc,
- *                      9501 Jeronimo Road, Suite 250,
- *                      Irvine, CA 92618, USA
- *
- * Developed and maintained by Solarflare Communications:
- *                      <linux-xen-drivers@solarflare.com>
- *                      <onload-dev@solarflare.com>
- *
- * Certain parts of the driver were implemented by
- *          Alexandra Kossovsky <Alexandra.Kossovsky@oktetlabs.ru>
- *          OKTET Labs Ltd, Russia,
- *          http://oktetlabs.ru, <info@oktetlabs.ru>
- *          by request of Solarflare Communications
- *
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 as published
- * by the Free Software Foundation, incorporated herein by reference.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
- ****************************************************************************
- */
-
-#ifndef __CI_EFHW_HARDWARE_LINUX_H__
-#define __CI_EFHW_HARDWARE_LINUX_H__
-
-#include <linux/io.h>
-
-#if defined(__LITTLE_ENDIAN)
-#define EFHW_IS_LITTLE_ENDIAN
-#elif defined(__BIG_ENDIAN)
-#define EFHW_IS_BIG_ENDIAN
-#else
-#error Unknown endianness
-#endif
-
-#ifndef readq
-static inline uint64_t __readq(volatile void __iomem *addr)
-{
-	return *(volatile uint64_t *)addr;
-}
-#define readq(x) __readq(x)
-#endif
-
-#ifndef writeq
-static inline void __writeq(uint64_t v, volatile void __iomem *addr)
-{
-	*(volatile uint64_t *)addr = v;
-}
-#define writeq(val, addr) __writeq((val), (addr))
-#endif
-
-#endif /* __CI_EFHW_HARDWARE_LINUX_H__ */
diff -r 9566a4a50a43 drivers/net/sfc/sfc_resource/ci/efhw/iopage.h
--- a/drivers/net/sfc/sfc_resource/ci/efhw/iopage.h
+++ /dev/null
@@ -1,58 +0,0 @@
-/****************************************************************************
- * Driver for Solarflare network controllers -
- *          resource management for Xen backend, OpenOnload, etc
- *           (including support for SFE4001 10GBT NIC)
- *
- * This file contains OS-independent API for allocating iopage types.
- * The implementation of these functions is highly OS-dependent.
- * This file is not designed for use outside of the SFC resource driver.
- *
- * Copyright 2005-2007: Solarflare Communications Inc,
- *                      9501 Jeronimo Road, Suite 250,
- *                      Irvine, CA 92618, USA
- *
- * Developed and maintained by Solarflare Communications:
- *                      <linux-xen-drivers@solarflare.com>
- *                      <onload-dev@solarflare.com>
- *
- * Certain parts of the driver were implemented by
- *          Alexandra Kossovsky <Alexandra.Kossovsky@oktetlabs.ru>
- *          OKTET Labs Ltd, Russia,
- *          http://oktetlabs.ru, <info@oktetlabs.ru>
- *          by request of Solarflare Communications
- *
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 as published
- * by the Free Software Foundation, incorporated herein by reference.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
- ****************************************************************************
- */
-
-#ifndef __CI_DRIVER_RESOURCE_IOPAGE_H__
-#define __CI_DRIVER_RESOURCE_IOPAGE_H__
-
-#include <ci/efhw/efhw_types.h>
-
-/*--------------------------------------------------------------------
- *
- * memory allocation
- *
- *--------------------------------------------------------------------*/
-
-extern int efhw_iopage_alloc(struct efhw_nic *, struct efhw_iopage *p);
-extern void efhw_iopage_free(struct efhw_nic *, struct efhw_iopage *p);
-
-extern int efhw_iopages_alloc(struct efhw_nic *, struct efhw_iopages *p,
-			      unsigned order);
-extern void efhw_iopages_free(struct efhw_nic *, struct efhw_iopages *p);
-
-#endif /* __CI_DRIVER_RESOURCE_IOPAGE_H__ */
diff -r 9566a4a50a43 drivers/net/sfc/sfc_resource/ci/efhw/iopage_types.h
--- a/drivers/net/sfc/sfc_resource/ci/efhw/iopage_types.h
+++ /dev/null
@@ -1,190 +0,0 @@
-/****************************************************************************
- * Driver for Solarflare network controllers -
- *          resource management for Xen backend, OpenOnload, etc
- *           (including support for SFE4001 10GBT NIC)
- *
- * This file provides struct efhw_page and struct efhw_iopage for Linux
- * kernel.
- *
- * Copyright 2005-2007: Solarflare Communications Inc,
- *                      9501 Jeronimo Road, Suite 250,
- *                      Irvine, CA 92618, USA
- *
- * Developed and maintained by Solarflare Communications:
- *                      <linux-xen-drivers@solarflare.com>
- *                      <onload-dev@solarflare.com>
- *
- * Certain parts of the driver were implemented by
- *          Alexandra Kossovsky <Alexandra.Kossovsky@oktetlabs.ru>
- *          OKTET Labs Ltd, Russia,
- *          http://oktetlabs.ru, <info@oktetlabs.ru>
- *          by request of Solarflare Communications
- *
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 as published
- * by the Free Software Foundation, incorporated herein by reference.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
- ****************************************************************************
- */
-
-#ifndef __CI_EFHW_IOPAGE_LINUX_H__
-#define __CI_EFHW_IOPAGE_LINUX_H__
-
-#include <linux/gfp.h>
-#include <linux/hardirq.h>
-#include <linux/errno.h>
-#include <ci/efhw/debug.h>
-
-/*--------------------------------------------------------------------
- *
- * struct efhw_page: A single page of memory.  Directly mapped in the
- * driver, and can be mapped to userlevel.
- *
- *--------------------------------------------------------------------*/
-
-struct efhw_page {
-	unsigned long kva;
-};
-
-static inline int efhw_page_alloc(struct efhw_page *p)
-{
-	p->kva = __get_free_page(in_interrupt()? GFP_ATOMIC : GFP_KERNEL);
-	return p->kva ? 0 : -ENOMEM;
-}
-
-static inline int efhw_page_alloc_zeroed(struct efhw_page *p)
-{
-	p->kva = get_zeroed_page(in_interrupt()? GFP_ATOMIC : GFP_KERNEL);
-	return p->kva ? 0 : -ENOMEM;
-}
-
-static inline void efhw_page_free(struct efhw_page *p)
-{
-	free_page(p->kva);
-	EFHW_DO_DEBUG(memset(p, 0, sizeof(*p)));
-}
-
-static inline char *efhw_page_ptr(struct efhw_page *p)
-{
-	return (char *)p->kva;
-}
-
-static inline unsigned efhw_page_pfn(struct efhw_page *p)
-{
-	return (unsigned)(__pa(p->kva) >> PAGE_SHIFT);
-}
-
-static inline void efhw_page_mark_invalid(struct efhw_page *p)
-{
-	p->kva = 0;
-}
-
-static inline int efhw_page_is_valid(struct efhw_page *p)
-{
-	return p->kva != 0;
-}
-
-static inline void efhw_page_init_from_va(struct efhw_page *p, void *va)
-{
-	p->kva = (unsigned long)va;
-}
-
-/*--------------------------------------------------------------------
- *
- * struct efhw_iopage: A single page of memory.  Directly mapped in the driver,
- * and can be mapped to userlevel.  Can also be accessed by the NIC.
- *
- *--------------------------------------------------------------------*/
-
-struct efhw_iopage {
-	struct efhw_page p;
-	dma_addr_t dma_addr;
-};
-
-static inline dma_addr_t efhw_iopage_dma_addr(struct efhw_iopage *p)
-{
-	return p->dma_addr;
-}
-
-#define efhw_iopage_ptr(iop)		efhw_page_ptr(&(iop)->p)
-#define efhw_iopage_pfn(iop)		efhw_page_pfn(&(iop)->p)
-#define efhw_iopage_mark_invalid(iop)	efhw_page_mark_invalid(&(iop)->p)
-#define efhw_iopage_is_valid(iop)	efhw_page_is_valid(&(iop)->p)
-
-/*--------------------------------------------------------------------
- *
- * struct efhw_iopages: A set of pages that are contiguous in physical
- * memory.  Directly mapped in the driver, and can be mapped to userlevel.
- * Can also be accessed by the NIC.
- *
- * NB. The O/S may be unwilling to allocate many, or even any of these.  So
- * only use this type where the NIC really needs a physically contiguous
- * buffer.
- *
- *--------------------------------------------------------------------*/
-
-struct efhw_iopages {
-	caddr_t kva;
-	unsigned order;
-	dma_addr_t dma_addr;
-};
-
-static inline caddr_t efhw_iopages_ptr(struct efhw_iopages *p)
-{
-	return p->kva;
-}
-
-static inline unsigned efhw_iopages_pfn(struct efhw_iopages *p)
-{
-	return (unsigned)(__pa(p->kva) >> PAGE_SHIFT);
-}
-
-static inline dma_addr_t efhw_iopages_dma_addr(struct efhw_iopages *p)
-{
-	return p->dma_addr;
-}
-
-static inline unsigned efhw_iopages_size(struct efhw_iopages *p)
-{
-	return 1u << (p->order + PAGE_SHIFT);
-}
-
-/* struct efhw_iopage <-> struct efhw_iopages conversions for handling
- * physically contiguous allocations in iobufsets for iSCSI.  This allows
- * the essential information about contiguous allocations from
- * efhw_iopages_alloc() to be saved away in the struct efhw_iopage array in
- * an iobufset.  (Changing the iobufset resource to use a union type would
- * involve a lot of code changes, and make the iobufset's metadata larger
- * which could be bad as it's supposed to fit into a single page on some
- * platforms.)
- */
-static inline void
-efhw_iopage_init_from_iopages(struct efhw_iopage *iopage,
-			      struct efhw_iopages *iopages, unsigned pageno)
-{
-	iopage->p.kva = ((unsigned long)efhw_iopages_ptr(iopages))
-	    + (pageno * PAGE_SIZE);
-	iopage->dma_addr = efhw_iopages_dma_addr(iopages) +
-	    (pageno * PAGE_SIZE);
-}
-
-static inline void
-efhw_iopages_init_from_iopage(struct efhw_iopages *iopages,
-			      struct efhw_iopage *iopage, unsigned order)
-{
-	iopages->kva = (caddr_t) efhw_iopage_ptr(iopage);
-	EFHW_ASSERT(iopages->kva);
-	iopages->order = order;
-	iopages->dma_addr = efhw_iopage_dma_addr(iopage);
-}
-
-#endif /* __CI_EFHW_IOPAGE_LINUX_H__ */
diff -r 9566a4a50a43 drivers/net/sfc/sfc_resource/ci/efhw/nic.h
--- a/drivers/net/sfc/sfc_resource/ci/efhw/nic.h
+++ /dev/null
@@ -1,62 +0,0 @@
-/****************************************************************************
- * Driver for Solarflare network controllers -
- *          resource management for Xen backend, OpenOnload, etc
- *           (including support for SFE4001 10GBT NIC)
- *
- * This file contains API provided by efhw/nic.c file.  This file is not
- * designed for use outside of the SFC resource driver.
- *
- * Copyright 2005-2007: Solarflare Communications Inc,
- *                      9501 Jeronimo Road, Suite 250,
- *                      Irvine, CA 92618, USA
- *
- * Developed and maintained by Solarflare Communications:
- *                      <linux-xen-drivers@solarflare.com>
- *                      <onload-dev@solarflare.com>
- *
- * Certain parts of the driver were implemented by
- *          Alexandra Kossovsky <Alexandra.Kossovsky@oktetlabs.ru>
- *          OKTET Labs Ltd, Russia,
- *          http://oktetlabs.ru, <info@oktetlabs.ru>
- *          by request of Solarflare Communications
- *
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 as published
- * by the Free Software Foundation, incorporated herein by reference.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
- ****************************************************************************
- */
-
-#ifndef __CI_EFHW_NIC_H__
-#define __CI_EFHW_NIC_H__
-
-#include <ci/efhw/efhw_types.h>
-#include <ci/efhw/public.h>
-
-
-/* Convert PCI info to device type.  Returns false when device is not
- * recognised.
- */
-extern int efhw_device_type_init(struct efhw_device_type *dt,
-				 int vendor_id, int device_id, int revision);
-
-/* Initialise fields that do not involve touching hardware. */
-extern void efhw_nic_init(struct efhw_nic *nic, unsigned flags,
-			  unsigned options, struct efhw_device_type dev_type);
-
-/*! Destruct NIC resources */
-extern void efhw_nic_dtor(struct efhw_nic *nic);
-
-/*! Shutdown interrupts */
-extern void efhw_nic_close_interrupts(struct efhw_nic *nic);
-
-#endif /* __CI_EFHW_NIC_H__ */
diff -r 9566a4a50a43 drivers/net/sfc/sfc_resource/ci/efhw/public.h
--- a/drivers/net/sfc/sfc_resource/ci/efhw/public.h
+++ /dev/null
@@ -1,104 +0,0 @@
-/****************************************************************************
- * Driver for Solarflare network controllers -
- *          resource management for Xen backend, OpenOnload, etc
- *           (including support for SFE4001 10GBT NIC)
- *
- * This file provides public API of efhw library exported from the SFC
- * resource driver.
- *
- * Copyright 2005-2007: Solarflare Communications Inc,
- *                      9501 Jeronimo Road, Suite 250,
- *                      Irvine, CA 92618, USA
- *
- * Developed and maintained by Solarflare Communications:
- *                      <linux-xen-drivers@solarflare.com>
- *                      <onload-dev@solarflare.com>
- *
- * Certain parts of the driver were implemented by
- *          Alexandra Kossovsky <Alexandra.Kossovsky@oktetlabs.ru>
- *          OKTET Labs Ltd, Russia,
- *          http://oktetlabs.ru, <info@oktetlabs.ru>
- *          by request of Solarflare Communications
- *
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 as published
- * by the Free Software Foundation, incorporated herein by reference.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
- ****************************************************************************
- */
-
-#ifndef __CI_EFHW_PUBLIC_H__
-#define __CI_EFHW_PUBLIC_H__
-
-#include <ci/efhw/common.h>
-#include <ci/efhw/efhw_types.h>
-
-/*! Returns true if we have some EtherFabric functional units -
-  whether configured or not */
-static inline int efhw_nic_have_functional_units(struct efhw_nic *nic)
-{
-	return nic->efhw_func != 0;
-}
-
-/*! Returns true if the EtherFabric functional units have been configured  */
-static inline int efhw_nic_have_hw(struct efhw_nic *nic)
-{
-	return efhw_nic_have_functional_units(nic) && (EFHW_KVA(nic) != 0);
-}
-
-/*! Helper function to allocate the iobuffer needed by an eventq
- *   - it ensures the eventq has the correct alignment for the NIC
- *
- * \param rm        Event-queue resource manager
- * \param instance  Event-queue instance (index)
- * \param buf_bytes Requested size of eventq
- * \return          < 0 if iobuffer allocation fails
- */
-int efhw_nic_event_queue_alloc_iobuffer(struct efhw_nic *nic,
-					struct eventq_resource_hardware *h,
-					int evq_instance, unsigned buf_bytes);
-
-extern void falcon_nic_set_rx_usr_buf_size(struct efhw_nic *,
-					   int rx_usr_buf_size);
-
-/*! Get RX filter search limits from RX_FILTER_CTL_REG.
- *  use_raw_values = 0 to get actual depth of search, or 1 to get raw values
- *  from register.
- */
-extern void
-falcon_nic_get_rx_filter_search_limits(struct efhw_nic *nic,
-				       struct efhw_filter_search_limits *lim,
-				       int use_raw_values);
-
-/*! Set RX filter search limits in RX_FILTER_CTL_REG.
- *  use_raw_values = 0 if specifying actual depth of search, or 1 if specifying
- *  raw values to write to the register.
- */
-extern void
-falcon_nic_set_rx_filter_search_limits(struct efhw_nic *nic,
-				       struct efhw_filter_search_limits *lim,
-				       int use_raw_values);
-
-
-/*! Legacy RX IP filter search depth control interface */
-extern void
-falcon_nic_rx_filter_ctl_set(struct efhw_nic *nic, uint32_t tcp_full,
-			     uint32_t tcp_wild,
-			     uint32_t udp_full, uint32_t udp_wild);
-
-/*! Legacy RX IP filter search depth control interface */
-extern void
-falcon_nic_rx_filter_ctl_get(struct efhw_nic *nic, uint32_t *tcp_full,
-			     uint32_t *tcp_wild,
-			     uint32_t *udp_full, uint32_t *udp_wild);
-
-#endif /* __CI_EFHW_PUBLIC_H__ */
diff -r 9566a4a50a43 drivers/net/sfc/sfc_resource/ci/efhw/sysdep.h
--- a/drivers/net/sfc/sfc_resource/ci/efhw/sysdep.h
+++ /dev/null
@@ -1,55 +0,0 @@
-/****************************************************************************
- * Driver for Solarflare network controllers -
- *          resource management for Xen backend, OpenOnload, etc
- *           (including support for SFE4001 10GBT NIC)
- *
- * This file provides version-independent Linux kernel API for efhw library.
- * Only kernels >=2.6.9 are supported.
- *
- * Copyright 2005-2007: Solarflare Communications Inc,
- *                      9501 Jeronimo Road, Suite 250,
- *                      Irvine, CA 92618, USA
- *
- * Developed and maintained by Solarflare Communications:
- *                      <linux-xen-drivers@solarflare.com>
- *                      <onload-dev@solarflare.com>
- *
- * Certain parts of the driver were implemented by
- *          Alexandra Kossovsky <Alexandra.Kossovsky@oktetlabs.ru>
- *          OKTET Labs Ltd, Russia,
- *          http://oktetlabs.ru, <info@oktetlabs.ru>
- *          by request of Solarflare Communications
- *
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 as published
- * by the Free Software Foundation, incorporated herein by reference.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
- ****************************************************************************
- */
-
-#ifndef __CI_EFHW_SYSDEP_LINUX_H__
-#define __CI_EFHW_SYSDEP_LINUX_H__
-
-#include <linux/module.h>
-#include <linux/spinlock.h>
-#include <linux/delay.h>
-#include <linux/vmalloc.h>
-#include <linux/if_ether.h>
-
-#include <linux/netdevice.h> /* necessary for etherdevice.h on some kernels */
-#include <linux/etherdevice.h>
-
-typedef unsigned long irq_flags_t;
-
-#define spin_lock_destroy(l_)  do {} while (0)
-
-#endif /* __CI_EFHW_SYSDEP_LINUX_H__ */
diff -r 9566a4a50a43 drivers/net/sfc/sfc_resource/ci/efrm/buddy.h
--- a/drivers/net/sfc/sfc_resource/ci/efrm/buddy.h
+++ /dev/null
@@ -1,68 +0,0 @@
-/****************************************************************************
- * Driver for Solarflare network controllers -
- *          resource management for Xen backend, OpenOnload, etc
- *           (including support for SFE4001 10GBT NIC)
- *
- * This file provides private API for buddy allocator.  This API is not
- * designed for use outside of SFC resource driver.
- *
- * Copyright 2005-2007: Solarflare Communications Inc,
- *                      9501 Jeronimo Road, Suite 250,
- *                      Irvine, CA 92618, USA
- *
- * Developed and maintained by Solarflare Communications:
- *                      <linux-xen-drivers@solarflare.com>
- *                      <onload-dev@solarflare.com>
- *
- * Certain parts of the driver were implemented by
- *          Alexandra Kossovsky <Alexandra.Kossovsky@oktetlabs.ru>
- *          OKTET Labs Ltd, Russia,
- *          http://oktetlabs.ru, <info@oktetlabs.ru>
- *          by request of Solarflare Communications
- *
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 as published
- * by the Free Software Foundation, incorporated herein by reference.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
- ****************************************************************************
- */
-
-#ifndef __CI_EFRM_BUDDY_H__
-#define __CI_EFRM_BUDDY_H__
-
-#include <ci/efrm/sysdep.h>
-
-/*! Comment? */
-struct efrm_buddy_allocator {
-	struct list_head *free_lists;	/* array[order+1] */
-	struct list_head *links;	/* array[1<<order] */
-	uint8_t *orders;		/* array[1<<order] */
-	unsigned order;		/*!< total size == (1 << order) */
-	/* ?? Consider recording largest available order + for each order the
-	 ** smallest available order that is big enough.
-	 */
-};
-
-  /*! Returns total size of managed space. */
-static inline unsigned long efrm_buddy_size(struct efrm_buddy_allocator *b)
-{
-	return 1ul << b->order;
-}
-
-int efrm_buddy_ctor(struct efrm_buddy_allocator *b, unsigned order);
-void efrm_buddy_dtor(struct efrm_buddy_allocator *b);
-int efrm_buddy_alloc(struct efrm_buddy_allocator *b, unsigned order);
-void efrm_buddy_free(struct efrm_buddy_allocator *b, unsigned addr,
-		     unsigned order);
-
-
-#endif /* __CI_EFRM_BUDDY_H__ */
diff -r 9566a4a50a43 drivers/net/sfc/sfc_resource/ci/efrm/buffer_table.h
--- a/drivers/net/sfc/sfc_resource/ci/efrm/buffer_table.h
+++ /dev/null
@@ -1,81 +0,0 @@
-/****************************************************************************
- * Driver for Solarflare network controllers -
- *          resource management for Xen backend, OpenOnload, etc
- *           (including support for SFE4001 10GBT NIC)
- *
- * This file provides private buffer table API.  This API is not designed
- * for use outside of SFC resource driver.
- *
- * Copyright 2005-2007: Solarflare Communications Inc,
- *                      9501 Jeronimo Road, Suite 250,
- *                      Irvine, CA 92618, USA
- *
- * Developed and maintained by Solarflare Communications:
- *                      <linux-xen-drivers@solarflare.com>
- *                      <onload-dev@solarflare.com>
- *
- * Certain parts of the driver were implemented by
- *          Alexandra Kossovsky <Alexandra.Kossovsky@oktetlabs.ru>
- *          OKTET Labs Ltd, Russia,
- *          http://oktetlabs.ru, <info@oktetlabs.ru>
- *          by request of Solarflare Communications
- *
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 as published
- * by the Free Software Foundation, incorporated herein by reference.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
- ****************************************************************************
- */
-
-#ifndef __CI_EFRM_BUFFER_TABLE_H__
-#define __CI_EFRM_BUFFER_TABLE_H__
-
-#include <ci/efhw/efhw_types.h>
-
-/*--------------------------------------------------------------------
- *
- * NIC's buffer table.
- *
- *--------------------------------------------------------------------*/
-
-/*! Managed interface. */
-
-/*! construct a managed buffer table object, allocated over a region of
- *  the NICs buffer table space
- */
-extern int efrm_buffer_table_ctor(unsigned low, unsigned high);
-/*! destructor for above */
-extern void efrm_buffer_table_dtor(void);
-
-/*! allocate a contiguous region of buffer table space */
-extern int efrm_buffer_table_alloc(unsigned order,
-				   struct efhw_buffer_table_allocation *a);
-
-
-/*--------------------------------------------------------------------
- *
- * buffer table operations through the HW independent API
- *
- *--------------------------------------------------------------------*/
-
-/*! free a previously allocated region of buffer table space */
-extern void efrm_buffer_table_free(struct efhw_buffer_table_allocation *a);
-
-/*! commit the update of a buffer table entry to every NIC */
-extern void efrm_buffer_table_commit(void);
-
-extern void efrm_buffer_table_set(struct efhw_buffer_table_allocation *,
-				  struct efhw_nic *,
-				  unsigned i, dma_addr_t dma_addr, int owner);
-
-
-#endif /* __CI_EFRM_BUFFER_TABLE_H__ */
diff -r 9566a4a50a43 drivers/net/sfc/sfc_resource/ci/efrm/debug.h
--- a/drivers/net/sfc/sfc_resource/ci/efrm/debug.h
+++ /dev/null
@@ -1,78 +0,0 @@
-/****************************************************************************
- * Driver for Solarflare network controllers -
- *          resource management for Xen backend, OpenOnload, etc
- *           (including support for SFE4001 10GBT NIC)
- *
- * This file provides debug-related API for efrm library using Linux kernel
- * primitives.
- *
- * Copyright 2005-2007: Solarflare Communications Inc,
- *                      9501 Jeronimo Road, Suite 250,
- *                      Irvine, CA 92618, USA
- *
- * Developed and maintained by Solarflare Communications:
- *                      <linux-xen-drivers@solarflare.com>
- *                      <onload-dev@solarflare.com>
- *
- * Certain parts of the driver were implemented by
- *          Alexandra Kossovsky <Alexandra.Kossovsky@oktetlabs.ru>
- *          OKTET Labs Ltd, Russia,
- *          http://oktetlabs.ru, <info@oktetlabs.ru>
- *          by request of Solarflare Communications
- *
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 as published
- * by the Free Software Foundation, incorporated herein by reference.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
- ****************************************************************************
- */
-
-#ifndef __CI_EFRM_DEBUG_LINUX_H__
-#define __CI_EFRM_DEBUG_LINUX_H__
-
-#define EFRM_PRINTK_PREFIX "[sfc efrm] "
-
-#define EFRM_PRINTK(level, fmt, ...) \
-	printk(level EFRM_PRINTK_PREFIX fmt "\n", __VA_ARGS__)
-
-/* Following macros should be used with non-zero format parameters
- * due to __VA_ARGS__ limitations.  Use "%s" with __func__ if you can't
- * find better parameters. */
-#define EFRM_ERR(fmt, ...)     EFRM_PRINTK(KERN_ERR, fmt, __VA_ARGS__)
-#define EFRM_WARN(fmt, ...)    EFRM_PRINTK(KERN_WARNING, fmt, __VA_ARGS__)
-#define EFRM_NOTICE(fmt, ...)  EFRM_PRINTK(KERN_NOTICE, fmt, __VA_ARGS__)
-#if !defined(NDEBUG)
-#define EFRM_TRACE(fmt, ...) EFRM_PRINTK(KERN_DEBUG, fmt, __VA_ARGS__)
-#else
-#define EFRM_TRACE(fmt, ...)
-#endif
-
-#ifndef NDEBUG
-#define EFRM_ASSERT(cond)  BUG_ON((cond) == 0)
-#define _EFRM_ASSERT(cond, file, line) \
-	do {								\
-		if (unlikely(!(cond))) {				\
-			EFRM_ERR("assertion \"%s\" failed at %s %d",	\
-				 #cond, file, line);			\
-			BUG();						\
-		}							\
-	} while (0)
-
-#define EFRM_DO_DEBUG(expr) expr
-#define EFRM_VERIFY_EQ(expr, val) EFRM_ASSERT((expr) == (val))
-#else
-#define EFRM_ASSERT(cond)
-#define EFRM_DO_DEBUG(expr)
-#define EFRM_VERIFY_EQ(expr, val) expr
-#endif
-
-#endif /* __CI_EFRM_DEBUG_LINUX_H__ */
diff -r 9566a4a50a43 drivers/net/sfc/sfc_resource/ci/efrm/driver_private.h
--- a/drivers/net/sfc/sfc_resource/ci/efrm/driver_private.h
+++ /dev/null
@@ -1,89 +0,0 @@
-/****************************************************************************
- * Driver for Solarflare network controllers -
- *          resource management for Xen backend, OpenOnload, etc
- *           (including support for SFE4001 10GBT NIC)
- *
- * This file provides private API of efrm library to be used from the SFC
- * resource driver.
- *
- * Copyright 2005-2007: Solarflare Communications Inc,
- *                      9501 Jeronimo Road, Suite 250,
- *                      Irvine, CA 92618, USA
- *
- * Developed and maintained by Solarflare Communications:
- *                      <linux-xen-drivers@solarflare.com>
- *                      <onload-dev@solarflare.com>
- *
- * Certain parts of the driver were implemented by
- *          Alexandra Kossovsky <Alexandra.Kossovsky@oktetlabs.ru>
- *          OKTET Labs Ltd, Russia,
- *          http://oktetlabs.ru, <info@oktetlabs.ru>
- *          by request of Solarflare Communications
- *
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 as published
- * by the Free Software Foundation, incorporated herein by reference.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
- ****************************************************************************
- */
-
-#ifndef __CI_EFRM_DRIVER_PRIVATE_H__
-#define __CI_EFRM_DRIVER_PRIVATE_H__
-
-#include <ci/efrm/resource.h>
-#include <ci/efrm/sysdep.h>
-
-/*--------------------------------------------------------------------
- *
- * global variables
- *
- *--------------------------------------------------------------------*/
-
-/* Internal structure for resource driver */
-extern struct efrm_resource_manager *efrm_rm_table[];
-
-/*--------------------------------------------------------------------
- *
- * efrm_nic_table handling
- *
- *--------------------------------------------------------------------*/
-
-struct efrm_nic;
-
-extern void efrm_driver_ctor(void);
-extern void efrm_driver_dtor(void);
-extern int efrm_driver_register_nic(struct efrm_nic *, int nic_index,
-				    int ifindex);
-extern int efrm_driver_unregister_nic(struct efrm_nic *);
-
-/*--------------------------------------------------------------------
- *
- * create/destroy resource managers
- *
- *--------------------------------------------------------------------*/
-
-struct vi_resource_dimensions {
-	unsigned evq_int_min, evq_int_lim;
-	unsigned evq_timer_min, evq_timer_lim;
-	unsigned rxq_min, rxq_lim;
-	unsigned txq_min, txq_lim;
-};
-
-/*! Initialise resources */
-extern int
-efrm_resources_init(const struct vi_resource_dimensions *,
-		    int buffer_table_min, int buffer_table_lim);
-
-/*! Tear down resources */
-extern void efrm_resources_fini(void);
-
-#endif /* __CI_EFRM_DRIVER_PRIVATE_H__ */
diff -r 9566a4a50a43 drivers/net/sfc/sfc_resource/ci/efrm/efrm_client.h
--- a/drivers/net/sfc/sfc_resource/ci/efrm/efrm_client.h
+++ /dev/null
@@ -1,32 +0,0 @@
-#ifndef __EFRM_CLIENT_H__
-#define __EFRM_CLIENT_H__
-
-
-struct efrm_client;
-
-
-struct efrm_client_callbacks {
-	/* Called before device is reset.  Callee may block. */
-	void (*pre_reset)(struct efrm_client *, void *user_data);
-	void (*stop)(struct efrm_client *, void *user_data);
-	void (*restart)(struct efrm_client *, void *user_data);
-};
-
-
-#define EFRM_IFINDEX_DEFAULT  -1
-
-
-/* NB. Callbacks may be invoked even before this returns. */
-extern int  efrm_client_get(int ifindex, struct efrm_client_callbacks *,
-			    void *user_data, struct efrm_client **client_out);
-extern void efrm_client_put(struct efrm_client *);
-
-extern struct efhw_nic *efrm_client_get_nic(struct efrm_client *);
-
-#if 0
-/* For each resource type... */
-extern void efrm_x_resource_resume(struct x_resource *);
-#endif
-
-
-#endif  /* __EFRM_CLIENT_H__ */
diff -r 9566a4a50a43 drivers/net/sfc/sfc_resource/ci/efrm/efrm_nic.h
--- a/drivers/net/sfc/sfc_resource/ci/efrm/efrm_nic.h
+++ /dev/null
@@ -1,26 +0,0 @@
-#ifndef __EFRM_NIC_H__
-#define __EFRM_NIC_H__
-
-#include <ci/efhw/efhw_types.h>
-
-
-struct efrm_nic_per_vi {
-	unsigned long state;
-	struct vi_resource *vi;
-};
-
-
-struct efrm_nic {
-	struct efhw_nic efhw_nic;
-	struct list_head link;
-	struct list_head clients;
-	struct efrm_nic_per_vi *vis;
-};
-
-
-#define efrm_nic(_efhw_nic)				\
-  container_of(_efhw_nic, struct efrm_nic, efhw_nic)
-
-
-
-#endif  /* __EFRM_NIC_H__ */
diff -r 9566a4a50a43 drivers/net/sfc/sfc_resource/ci/efrm/filter.h
--- a/drivers/net/sfc/sfc_resource/ci/efrm/filter.h
+++ /dev/null
@@ -1,122 +0,0 @@
-/****************************************************************************
- * Driver for Solarflare network controllers -
- *          resource management for Xen backend, OpenOnload, etc
- *           (including support for SFE4001 10GBT NIC)
- *
- * This file provides public API for filter resource.
- *
- * Copyright 2005-2007: Solarflare Communications Inc,
- *                      9501 Jeronimo Road, Suite 250,
- *                      Irvine, CA 92618, USA
- *
- * Developed and maintained by Solarflare Communications:
- *                      <linux-xen-drivers@solarflare.com>
- *                      <onload-dev@solarflare.com>
- *
- * Certain parts of the driver were implemented by
- *          Alexandra Kossovsky <Alexandra.Kossovsky@oktetlabs.ru>
- *          OKTET Labs Ltd, Russia,
- *          http://oktetlabs.ru, <info@oktetlabs.ru>
- *          by request of Solarflare Communications
- *
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 as published
- * by the Free Software Foundation, incorporated herein by reference.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
- ****************************************************************************
- */
-
-#ifndef __CI_EFRM_FILTER_H__
-#define __CI_EFRM_FILTER_H__
-
-#include <ci/efrm/resource.h>
-#include <ci/efhw/common.h>
-
-
-struct filter_resource;
-struct vi_resource;
-struct efrm_client;
-
-
-/*!
- * Allocate filter resource.
- *
- * \param vi_parent VI resource to use as parent. The function takes
- *                  reference to the VI resource on success.
- * \param frs_out   pointer to return the new filter resource
- *
- * \return          status code; if non-zero, frs_out is unchanged
- */
-extern int
-efrm_filter_resource_alloc(struct vi_resource *vi_parent,
-			   struct filter_resource **frs_out);
-
-extern void
-efrm_filter_resource_release(struct filter_resource *);
-
-
-extern int efrm_filter_resource_clear(struct filter_resource *frs);
-
-extern int __efrm_filter_resource_set(struct filter_resource *frs, int type,
-				      unsigned saddr_be32, uint16_t sport_be16,
-				      unsigned daddr_be32, uint16_t dport_be16);
-
-static inline int
-efrm_filter_resource_tcp_set(struct filter_resource *frs,
-			     unsigned saddr, uint16_t sport,
-			     unsigned daddr, uint16_t dport)
-{
-	int type;
-
-	EFRM_ASSERT((saddr && sport) || (!saddr && !sport));
-
-	type =
-	    saddr ? EFHW_IP_FILTER_TYPE_TCP_FULL :
-	    EFHW_IP_FILTER_TYPE_TCP_WILDCARD;
-
-	return __efrm_filter_resource_set(frs, type,
-					  saddr, sport, daddr, dport);
-}
-
-static inline int
-efrm_filter_resource_udp_set(struct filter_resource *frs,
-			     unsigned saddr, uint16_t sport,
-			     unsigned daddr, uint16_t dport)
-{
-	int type;
-
-	EFRM_ASSERT((saddr && sport) || (!saddr && !sport));
-
-	type =
-	    saddr ? EFHW_IP_FILTER_TYPE_UDP_FULL :
-	    EFHW_IP_FILTER_TYPE_UDP_WILDCARD;
-
-	return __efrm_filter_resource_set(frs,
-					  type, saddr, sport, daddr, dport);
-}
-
-
-extern int
-efrm_filter_resource_instance(struct filter_resource *);
-
-extern struct efrm_resource *
-efrm_filter_resource_to_resource(struct filter_resource *);
-
-extern struct filter_resource *
-efrm_filter_resource_from_resource(struct efrm_resource *);
-
-extern void
-efrm_filter_resource_free(struct filter_resource *);
-
-
-#endif /* __CI_EFRM_FILTER_H__ */
-/*! \cidoxg_end */
diff -r 9566a4a50a43 drivers/net/sfc/sfc_resource/ci/efrm/iobufset.h
--- a/drivers/net/sfc/sfc_resource/ci/efrm/iobufset.h
+++ /dev/null
@@ -1,110 +0,0 @@
-/****************************************************************************
- * Driver for Solarflare network controllers -
- *          resource management for Xen backend, OpenOnload, etc
- *           (including support for SFE4001 10GBT NIC)
- *
- * This file provides public API for iobufset resource.
- *
- * Copyright 2005-2007: Solarflare Communications Inc,
- *                      9501 Jeronimo Road, Suite 250,
- *                      Irvine, CA 92618, USA
- *
- * Developed and maintained by Solarflare Communications:
- *                      <linux-xen-drivers@solarflare.com>
- *                      <onload-dev@solarflare.com>
- *
- * Certain parts of the driver were implemented by
- *          Alexandra Kossovsky <Alexandra.Kossovsky@oktetlabs.ru>
- *          OKTET Labs Ltd, Russia,
- *          http://oktetlabs.ru, <info@oktetlabs.ru>
- *          by request of Solarflare Communications
- *
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 as published
- * by the Free Software Foundation, incorporated herein by reference.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
- ****************************************************************************
- */
-
-#ifndef __CI_EFRM_IOBUFSET_H__
-#define __CI_EFRM_IOBUFSET_H__
-
-#include <ci/efrm/vi_resource.h>
-
-/*! Iobufset resource structture.
- * Users should not access the structure fields directly, but use the API
- * below.
- * However, this structure should not be moved out of public headers,
- * because part of API (ex. efrm_iobufset_dma_addr function) is inline and
- * is used in the fast-path code.
- */
-struct iobufset_resource {
-	struct efrm_resource rs;
-	struct vi_resource *evq;
-	struct iobufset_resource *linked;
-	struct efhw_buffer_table_allocation buf_tbl_alloc;
-	unsigned int n_bufs;
-	unsigned int pages_per_contiguous_chunk;
-	unsigned chunk_order;
-	struct efhw_iopage bufs[1];
-	/*!< up to n_bufs can follow this, so this must be the last member */
-};
-
-#define iobufset_resource(rs1) \
-	container_of((rs1), struct iobufset_resource, rs)
-
-/*!
- * Allocate iobufset resource.
- *
- * \param vi        VI that "owns" these buffers. Grabs a reference
- *                  on success.
- * \param linked    Uses memory from an existing iobufset.  Grabs a
- *                  reference on success.
- * \param iobrs_out pointer to return the new filter resource
- *
- * \return          status code; if non-zero, frs_out is unchanged
- */
-extern int
-efrm_iobufset_resource_alloc(int32_t n_pages,
-			     int32_t pages_per_contiguous_chunk,
-			     struct vi_resource *vi,
-			     struct iobufset_resource *linked,
-			     bool phys_addr_mode,
-			     struct iobufset_resource **iobrs_out);
-
-extern void efrm_iobufset_resource_free(struct iobufset_resource *);
-extern void efrm_iobufset_resource_release(struct iobufset_resource *);
-
-static inline char *
-efrm_iobufset_ptr(struct iobufset_resource *rs, unsigned offs)
-{
-	EFRM_ASSERT(offs < (unsigned)(rs->n_bufs << PAGE_SHIFT));
-	return efhw_iopage_ptr(&rs->bufs[offs >> PAGE_SHIFT])
-	    + (offs & (PAGE_SIZE - 1));
-}
-
-static inline char *efrm_iobufset_page_ptr(struct iobufset_resource *rs,
-				       unsigned page_i)
-{
-	EFRM_ASSERT(page_i < (unsigned)rs->n_bufs);
-	return efhw_iopage_ptr(&rs->bufs[page_i]);
-}
-
-static inline dma_addr_t
-efrm_iobufset_dma_addr(struct iobufset_resource *rs, unsigned offs)
-{
-	EFRM_ASSERT(offs < (unsigned)(rs->n_bufs << PAGE_SHIFT));
-	return efhw_iopage_dma_addr(&rs->bufs[offs >> PAGE_SHIFT])
-	    + (offs & (PAGE_SIZE - 1));
-}
-
-#endif /* __CI_EFRM_IOBUFSET_H__ */
diff -r 9566a4a50a43 drivers/net/sfc/sfc_resource/ci/efrm/nic_set.h
--- a/drivers/net/sfc/sfc_resource/ci/efrm/nic_set.h
+++ /dev/null
@@ -1,104 +0,0 @@
-/****************************************************************************
- * Driver for Solarflare network controllers -
- *          resource management for Xen backend, OpenOnload, etc
- *           (including support for SFE4001 10GBT NIC)
- *
- * This file provides public API for NIC sets.
- *
- * Copyright 2005-2007: Solarflare Communications Inc,
- *                      9501 Jeronimo Road, Suite 250,
- *                      Irvine, CA 92618, USA
- *
- * Developed and maintained by Solarflare Communications:
- *                      <linux-xen-drivers@solarflare.com>
- *                      <onload-dev@solarflare.com>
- *
- * Certain parts of the driver were implemented by
- *          Alexandra Kossovsky <Alexandra.Kossovsky@oktetlabs.ru>
- *          OKTET Labs Ltd, Russia,
- *          http://oktetlabs.ru, <info@oktetlabs.ru>
- *          by request of Solarflare Communications
- *
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 as published
- * by the Free Software Foundation, incorporated herein by reference.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
- ****************************************************************************
- */
-
-#ifndef __CI_EFRM_NIC_SET_H__
-#define __CI_EFRM_NIC_SET_H__
-
-#include <ci/efrm/debug.h>
-#include <ci/efhw/common_sysdep.h>
-#include <ci/efhw/efhw_config.h>
-
-/*--------------------------------------------------------------------
- *
- * efrm_nic_set_t - tracks which NICs something has been done on
- *
- *--------------------------------------------------------------------*/
-
-/* Internal suructure of efrm_nic_set_t should not be referenced outside of
- * this file.  Add a new accessor if you should do it. */
-typedef struct {
-	uint32_t nics;
-} efrm_nic_set_t;
-
-#if EFHW_MAX_NR_DEVS > 32
-#error change efrm_nic_set to handle EFHW_MAX_NR_DEVS number of devices
-#endif
-
-static inline bool
-efrm_nic_set_read(const efrm_nic_set_t *nic_set, unsigned index)
-{
-	EFRM_ASSERT(nic_set);
-	EFRM_ASSERT(index < EFHW_MAX_NR_DEVS && index < 32);
-	return (nic_set->nics & (1 << index)) ? true : false;
-}
-
-static inline void
-efrm_nic_set_write(efrm_nic_set_t *nic_set, unsigned index, bool value)
-{
-	EFRM_ASSERT(nic_set);
-	EFRM_ASSERT(index < EFHW_MAX_NR_DEVS && index < 32);
-	EFRM_ASSERT(value == false || value == true);
-	nic_set->nics = (nic_set->nics & (~(1 << index))) + (value << index);
-}
-
-static inline void efrm_nic_set_clear(efrm_nic_set_t *nic_set)
-{
-	nic_set->nics = 0;
-}
-
-static inline void efrm_nic_set_all(efrm_nic_set_t *nic_set)
-{
-	nic_set->nics = 0xffffffff;
-}
-
-static inline bool efrm_nic_set_is_all_clear(efrm_nic_set_t *nic_set)
-{
-	return nic_set->nics == 0 ? true : false;
-}
-
-#define EFRM_NIC_SET_FMT "%x"
-
-static inline uint32_t efrm_nic_set_pri_arg(efrm_nic_set_t *nic_set)
-{
-	return nic_set->nics;
-}
-
-#define EFRM_FOR_EACH_NIC_INDEX_IN_SET(_set, _nic_i)			\
-	for ((_nic_i) = 0; (_nic_i) < EFHW_MAX_NR_DEVS; ++(_nic_i))	\
-		if (efrm_nic_set_read((_set), (_nic_i)))
-
-#endif /* __CI_EFRM_NIC_SET_H__ */
diff -r 9566a4a50a43 drivers/net/sfc/sfc_resource/ci/efrm/nic_table.h
--- a/drivers/net/sfc/sfc_resource/ci/efrm/nic_table.h
+++ /dev/null
@@ -1,98 +0,0 @@
-/****************************************************************************
- * Driver for Solarflare network controllers -
- *          resource management for Xen backend, OpenOnload, etc
- *           (including support for SFE4001 10GBT NIC)
- *
- * This file provides public API for NIC table.
- *
- * Copyright 2005-2007: Solarflare Communications Inc,
- *                      9501 Jeronimo Road, Suite 250,
- *                      Irvine, CA 92618, USA
- *
- * Developed and maintained by Solarflare Communications:
- *                      <linux-xen-drivers@solarflare.com>
- *                      <onload-dev@solarflare.com>
- *
- * Certain parts of the driver were implemented by
- *          Alexandra Kossovsky <Alexandra.Kossovsky@oktetlabs.ru>
- *          OKTET Labs Ltd, Russia,
- *          http://oktetlabs.ru, <info@oktetlabs.ru>
- *          by request of Solarflare Communications
- *
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 as published
- * by the Free Software Foundation, incorporated herein by reference.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
- ****************************************************************************
- */
-
-#ifndef __CI_EFRM_NIC_TABLE_H__
-#define __CI_EFRM_NIC_TABLE_H__
-
-#include <ci/efhw/efhw_types.h>
-#include <ci/efrm/sysdep.h>
-
-/*--------------------------------------------------------------------
- *
- * struct efrm_nic_table - top level driver object keeping all NICs -
- * implemented in driver_object.c
- *
- *--------------------------------------------------------------------*/
-
-/*! Comment? */
-struct efrm_nic_table {
-	/*! nics attached to this driver */
-	struct efhw_nic *nic[EFHW_MAX_NR_DEVS];
-	/*! pointer to an arbitrary struct efhw_nic if one exists;
-	 * for code which does not care which NIC it wants but
-	 * still needs one. Note you cannot assume nic[0] exists. */
-	struct efhw_nic *a_nic;
-	uint32_t nic_count;	/*!< number of nics attached to this driver */
-	spinlock_t lock;	/*!< lock for table modifications */
-	atomic_t ref_count;	/*!< refcount for users of nic table */
-};
-
-/* Resource driver structures used by other drivers as well */
-extern struct efrm_nic_table *efrm_nic_tablep;
-
-static inline void efrm_nic_table_hold(void)
-{
-	atomic_inc(&efrm_nic_tablep->ref_count);
-}
-
-static inline void efrm_nic_table_rele(void)
-{
-	atomic_dec(&efrm_nic_tablep->ref_count);
-}
-
-static inline int efrm_nic_table_held(void)
-{
-	return atomic_read(&efrm_nic_tablep->ref_count) != 0;
-}
-
-/* Run code block _x multiple times with variable nic set to each
- * registered NIC in turn.
- * DO NOT "break" out of this loop early. */
-#define EFRM_FOR_EACH_NIC(_nic_i, _nic)					\
-	for ((_nic_i) = (efrm_nic_table_hold(), 0);			\
-	     (_nic_i) < EFHW_MAX_NR_DEVS || (efrm_nic_table_rele(), 0);	\
-	     (_nic_i)++)						\
-		if (((_nic) = efrm_nic_tablep->nic[_nic_i]))
-
-#define EFRM_FOR_EACH_NIC_IN_SET(_set, _i, _nic)			\
-	for ((_i) = (efrm_nic_table_hold(), 0);				\
-	     (_i) < EFHW_MAX_NR_DEVS || (efrm_nic_table_rele(), 0);	\
-	     ++(_i))							\
-		if (((_nic) = efrm_nic_tablep->nic[_i]) &&		\
-		    efrm_nic_set_read((_set), (_i)))
-
-#endif /* __CI_EFRM_NIC_TABLE_H__ */
diff -r 9566a4a50a43 drivers/net/sfc/sfc_resource/ci/efrm/private.h
--- a/drivers/net/sfc/sfc_resource/ci/efrm/private.h
+++ /dev/null
@@ -1,118 +0,0 @@
-/****************************************************************************
- * Driver for Solarflare network controllers -
- *          resource management for Xen backend, OpenOnload, etc
- *           (including support for SFE4001 10GBT NIC)
- *
- * This file provides private API of efrm library -- resource handling.
- * This API is not designed for use outside of SFC resource driver.
- *
- * Copyright 2005-2007: Solarflare Communications Inc,
- *                      9501 Jeronimo Road, Suite 250,
- *                      Irvine, CA 92618, USA
- *
- * Developed and maintained by Solarflare Communications:
- *                      <linux-xen-drivers@solarflare.com>
- *                      <onload-dev@solarflare.com>
- *
- * Certain parts of the driver were implemented by
- *          Alexandra Kossovsky <Alexandra.Kossovsky@oktetlabs.ru>
- *          OKTET Labs Ltd, Russia,
- *          http://oktetlabs.ru, <info@oktetlabs.ru>
- *          by request of Solarflare Communications
- *
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 as published
- * by the Free Software Foundation, incorporated herein by reference.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
- ****************************************************************************
- */
-
-#ifndef __CI_EFRM_PRIVATE_H__
-#define __CI_EFRM_PRIVATE_H__
-
-#include <ci/efrm/resource.h>
-#include <ci/efrm/driver_private.h>
-#include <ci/efrm/sysdep.h>
-#include <ci/efrm/debug.h>
-
-/*--------------------------------------------------------------------
- *
- * create resource managers
- *
- *--------------------------------------------------------------------*/
-
-/*! Create a resource manager for various types of resources
- */
-extern int
-efrm_create_iobufset_resource_manager(struct efrm_resource_manager **out);
-
-extern int
-efrm_create_filter_resource_manager(struct efrm_resource_manager **out);
-
-extern int
-efrm_create_vi_resource_manager(struct efrm_resource_manager **out,
-				const struct vi_resource_dimensions *);
-
-
-/*--------------------------------------------------------------------
- *
- * Instance pool management
- *
- *--------------------------------------------------------------------*/
-
-/*! Allocate instance pool. Use kfifo_vfree to destroy it. */
-static inline int
-efrm_kfifo_id_ctor(struct kfifo **ids_out,
-		   unsigned int base, unsigned int limit, spinlock_t *lock)
-{
-	unsigned int i;
-	struct kfifo *ids;
-	unsigned char *buffer;
-	unsigned int size = roundup_pow_of_two((limit - base) * sizeof(int));
-	EFRM_ASSERT(base <= limit);
-	buffer = vmalloc(size);
-	ids = kfifo_init(buffer, size, GFP_KERNEL, lock);
-	if (IS_ERR(ids))
-		return PTR_ERR(ids);
-	for (i = base; i < limit; i++)
-		EFRM_VERIFY_EQ(__kfifo_put(ids, (unsigned char *)&i,
-					   sizeof(i)), sizeof(i));
-
-	*ids_out = ids;
-	return 0;
-}
-
-/*--------------------------------------------------------------------
- *
- * Various private functions
- *
- *--------------------------------------------------------------------*/
-
-/*! Initialize the fields in the provided resource manager memory area
- *   \param rm         The area of memory to be initialized
- *   \param dtor       A method to destroy the resource manager
- *   \param name       A Textual name for the resource manager
- *   \param type       The type of resource managed
- *   \param initial_table_size Initial size of the ID table
- *   \param auto_destroy Destroy resource manager on driver onload iff true
- *
- * A default table size is provided if the value 0 is provided.
- */
-extern int
-efrm_resource_manager_ctor(struct efrm_resource_manager *rm,
-			   void (*dtor)(struct efrm_resource_manager *),
-			   const char *name, unsigned type);
-
-extern void efrm_resource_manager_dtor(struct efrm_resource_manager *rm);
-
-
-#endif /* __CI_EFRM_PRIVATE_H__ */
diff -r 9566a4a50a43 drivers/net/sfc/sfc_resource/ci/efrm/resource.h
--- a/drivers/net/sfc/sfc_resource/ci/efrm/resource.h
+++ /dev/null
@@ -1,119 +0,0 @@
-/****************************************************************************
- * Driver for Solarflare network controllers -
- *          resource management for Xen backend, OpenOnload, etc
- *           (including support for SFE4001 10GBT NIC)
- *
- * This file provides public interface of efrm library -- resource handling.
- *
- * Copyright 2005-2007: Solarflare Communications Inc,
- *                      9501 Jeronimo Road, Suite 250,
- *                      Irvine, CA 92618, USA
- *
- * Developed and maintained by Solarflare Communications:
- *                      <linux-xen-drivers@solarflare.com>
- *                      <onload-dev@solarflare.com>
- *
- * Certain parts of the driver were implemented by
- *          Alexandra Kossovsky <Alexandra.Kossovsky@oktetlabs.ru>
- *          OKTET Labs Ltd, Russia,
- *          http://oktetlabs.ru, <info@oktetlabs.ru>
- *          by request of Solarflare Communications
- *
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 as published
- * by the Free Software Foundation, incorporated herein by reference.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
- ****************************************************************************
- */
-
-#ifndef __CI_EFRM_RESOURCE_H__
-#define __CI_EFRM_RESOURCE_H__
-
-/*--------------------------------------------------------------------
- *
- * headers for type dependencies
- *
- *--------------------------------------------------------------------*/
-
-#include <ci/efhw/efhw_types.h>
-#include <ci/efrm/resource_id.h>
-#include <ci/efrm/sysdep.h>
-#include <ci/efhw/common_sysdep.h>
-
-#ifndef __ci_driver__
-#error "Driver-only file"
-#endif
-
-/*--------------------------------------------------------------------
- *
- * struct efrm_resource - represents an allocated resource
- *                   (eg. pinned pages of memory, or resource on a NIC)
- *
- *--------------------------------------------------------------------*/
-
-/*! Representation of an allocated resource */
-struct efrm_resource {
-	int rs_ref_count;
-	efrm_resource_handle_t rs_handle;
-	struct efrm_client *rs_client;
-	struct list_head rs_client_link;
-	struct list_head rs_manager_link;
-};
-
-/*--------------------------------------------------------------------
- *
- * managed resource abstraction
- *
- *--------------------------------------------------------------------*/
-
-/*! Factory for resources of a specific type */
-struct efrm_resource_manager {
-	const char *rm_name;	/*!< human readable only */
-	spinlock_t rm_lock;
-#ifndef NDEBUG
-	unsigned rm_type;
-#endif
-	int rm_resources;
-	int rm_resources_hiwat;
-	struct list_head rm_resources_list;
-	/**
-	 * Destructor for the resource manager. Other resource managers
-	 * might be already dead, although the system guarantees that
-	 * managers are destructed in the order by which they were created
-	 */
-	void (*rm_dtor)(struct efrm_resource_manager *);
-};
-
-#ifdef NDEBUG
-# define EFRM_RESOURCE_ASSERT_VALID(rs, rc_mbz)
-# define EFRM_RESOURCE_MANAGER_ASSERT_VALID(rm)
-#else
-/*! Check validity of resource and report on failure */
-extern void efrm_resource_assert_valid(struct efrm_resource *,
-				       int rc_may_be_zero,
-				       const char *file, int line);
-# define EFRM_RESOURCE_ASSERT_VALID(rs, rc_mbz) \
-	efrm_resource_assert_valid((rs), (rc_mbz), __FILE__, __LINE__)
-
-/*! Check validity of resource manager and report on failure */
-extern void efrm_resource_manager_assert_valid(struct efrm_resource_manager *,
-					       const char *file, int line);
-# define EFRM_RESOURCE_MANAGER_ASSERT_VALID(rm) \
-	efrm_resource_manager_assert_valid((rm), __FILE__, __LINE__)
-#endif
-
-
-extern void efrm_resource_ref(struct efrm_resource *rs);
-extern int  __efrm_resource_release(struct efrm_resource *);
-
-
-#endif /* __CI_EFRM_RESOURCE_H__ */
diff -r 9566a4a50a43 drivers/net/sfc/sfc_resource/ci/efrm/resource_id.h
--- a/drivers/net/sfc/sfc_resource/ci/efrm/resource_id.h
+++ /dev/null
@@ -1,104 +0,0 @@
-/****************************************************************************
- * Driver for Solarflare network controllers -
- *          resource management for Xen backend, OpenOnload, etc
- *           (including support for SFE4001 10GBT NIC)
- *
- * This file provides public type and definitions resource handle, and the
- * definitions of resource types.
- *
- * Copyright 2005-2007: Solarflare Communications Inc,
- *                      9501 Jeronimo Road, Suite 250,
- *                      Irvine, CA 92618, USA
- *
- * Developed and maintained by Solarflare Communications:
- *                      <linux-xen-drivers@solarflare.com>
- *                      <onload-dev@solarflare.com>
- *
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 as published
- * by the Free Software Foundation, incorporated herein by reference.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
- ****************************************************************************
- */
-
-#ifndef __CI_DRIVER_EFRM_RESOURCE_ID_H__
-#define __CI_DRIVER_EFRM_RESOURCE_ID_H__
-
-/***********************************************************************
- * Resource handles
- *
- * Resource handles are intended for identifying resources at kernel
- * level, within the context of a particular NIC. particularly because
- * for some resource types, the low 16 bites correspond to hardware
- * IDs. They were historically also used at user level, with a nonce
- * stored in the bits 16 to 27 (inclusive), but that approach is
- * deprecated (but sill alive!).
- *
- * The handle value 0 is used to mean "no resource".
- * Identify resources within the context of a file descriptor at user
- * level.
- ***********************************************************************/
-
-typedef struct {
-	uint32_t handle;
-} efrm_resource_handle_t;
-
-/* You may think these following functions should all have
- * _HANDLE_ in their names, but really we are providing an abstract set
- * of methods on a (hypothetical) efrm_resource_t object, with
- * efrm_resource_handle_t being just the reference one holds to access
- * the object (aka "this" or "self").
- */
-
-/* Below I use inline instead of macros where possible in order to get
- * more type checking help from the compiler; hopefully we'll never
- * have to rewrite these to use #define as we've found some horrible
- * compiler on which we cannot make static inline do the Right Thing (tm).
- *
- * For consistency and to avoid pointless change I spell these
- * routines as macro names (CAPTILIZE_UNDERSCORED), which also serves
- * to remind people they are compact and inlined.
- */
-
-#define EFRM_RESOURCE_FMT  "[rs:%08x]"
-
-static inline unsigned EFRM_RESOURCE_PRI_ARG(efrm_resource_handle_t h)
-{
-	return h.handle;
-}
-
-static inline unsigned EFRM_RESOURCE_INSTANCE(efrm_resource_handle_t h)
-{
-	return h.handle & 0x0000ffff;
-}
-
-static inline unsigned EFRM_RESOURCE_TYPE(efrm_resource_handle_t h)
-{
-	return (h.handle & 0xf0000000) >> 28;
-}
-
-/***********************************************************************
- * Resource type codes
- ***********************************************************************/
-
-#define EFRM_RESOURCE_IOBUFSET          0x0
-#define EFRM_RESOURCE_VI                0x1
-#define EFRM_RESOURCE_FILTER            0x2
-#define EFRM_RESOURCE_NUM               0x3	/* This isn't a resource! */
-
-#define	EFRM_RESOURCE_NAME(type) \
-	((type) == EFRM_RESOURCE_IOBUFSET?	"IOBUFSET"	: \
-	 (type) == EFRM_RESOURCE_VI?		"VI"		: \
-	 (type) == EFRM_RESOURCE_FILTER?	"FILTER"	: \
-						"<invalid>")
-
-#endif /* __CI_DRIVER_EFRM_RESOURCE_ID_H__ */
diff -r 9566a4a50a43 drivers/net/sfc/sfc_resource/ci/efrm/sysdep.h
--- a/drivers/net/sfc/sfc_resource/ci/efrm/sysdep.h
+++ /dev/null
@@ -1,46 +0,0 @@
-/****************************************************************************
- * Driver for Solarflare network controllers -
- *          resource management for Xen backend, OpenOnload, etc
- *           (including support for SFE4001 10GBT NIC)
- *
- * This file provides Linux-like system-independent API for efrm library.
- *
- * Copyright 2005-2007: Solarflare Communications Inc,
- *                      9501 Jeronimo Road, Suite 250,
- *                      Irvine, CA 92618, USA
- *
- * Developed and maintained by Solarflare Communications:
- *                      <linux-xen-drivers@solarflare.com>
- *                      <onload-dev@solarflare.com>
- *
- * Certain parts of the driver were implemented by
- *          Alexandra Kossovsky <Alexandra.Kossovsky@oktetlabs.ru>
- *          OKTET Labs Ltd, Russia,
- *          http://oktetlabs.ru, <info@oktetlabs.ru>
- *          by request of Solarflare Communications
- *
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 as published
- * by the Free Software Foundation, incorporated herein by reference.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
- ****************************************************************************
- */
-
-#ifndef __CI_EFRM_SYSDEP_H__
-#define __CI_EFRM_SYSDEP_H__
-
-/* Spinlocks are defined in efhw/sysdep.h */
-#include <ci/efhw/sysdep.h>
-
-#include <ci/efrm/sysdep_linux.h>
-
-#endif /* __CI_EFRM_SYSDEP_H__ */
diff -r 9566a4a50a43 drivers/net/sfc/sfc_resource/ci/efrm/sysdep_linux.h
--- a/drivers/net/sfc/sfc_resource/ci/efrm/sysdep_linux.h
+++ /dev/null
@@ -1,93 +0,0 @@
-/****************************************************************************
- * Driver for Solarflare network controllers -
- *          resource management for Xen backend, OpenOnload, etc
- *           (including support for SFE4001 10GBT NIC)
- *
- * This file provides version-independent Linux kernel API for efrm library.
- * Only kernels >=2.6.9 are supported.
- *
- * Copyright 2005-2007: Solarflare Communications Inc,
- *                      9501 Jeronimo Road, Suite 250,
- *                      Irvine, CA 92618, USA
- *
- * Kfifo API is partially stolen from linux-2.6.22/include/linux/list.h
- * Copyright (C) 2004 Stelian Pop <stelian@popies.net>
- *
- * Developed and maintained by Solarflare Communications:
- *                      <linux-xen-drivers@solarflare.com>
- *                      <onload-dev@solarflare.com>
- *
- * Certain parts of the driver were implemented by
- *          Alexandra Kossovsky <Alexandra.Kossovsky@oktetlabs.ru>
- *          OKTET Labs Ltd, Russia,
- *          http://oktetlabs.ru, <info@oktetlabs.ru>
- *          by request of Solarflare Communications
- *
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 as published
- * by the Free Software Foundation, incorporated herein by reference.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
- ****************************************************************************
- */
-
-#ifndef __CI_EFRM_SYSDEP_LINUX_H__
-#define __CI_EFRM_SYSDEP_LINUX_H__
-
-#include <linux/list.h>
-#include <linux/vmalloc.h>
-#include <linux/errno.h>
-#include <linux/string.h>
-#include <linux/workqueue.h>
-#include <linux/gfp.h>
-#include <linux/slab.h>
-#include <linux/hardirq.h>
-#include <linux/kernel.h>
-#include <linux/if_ether.h>
-#include <linux/completion.h>
-#include <linux/in.h>
-#include <linux/log2.h>
-#include <linux/kfifo.h>
-
-
-/********************************************************************
- *
- * List API
- *
- ********************************************************************/
-
-static inline struct list_head *list_pop(struct list_head *list)
-{
-	struct list_head *link = list->next;
-	list_del(link);
-	return link;
-}
-
-static inline struct list_head *list_pop_tail(struct list_head *list)
-{
-	struct list_head *link = list->prev;
-	list_del(link);
-	return link;
-}
-
-/********************************************************************
- *
- * Kfifo API
- *
- ********************************************************************/
-
-static inline void kfifo_vfree(struct kfifo *fifo)
-{
-	vfree(fifo->buffer);
-	kfree(fifo);
-}
-
-#endif /* __CI_EFRM_SYSDEP_LINUX_H__ */
diff -r 9566a4a50a43 drivers/net/sfc/sfc_resource/ci/efrm/vi_resource.h
--- a/drivers/net/sfc/sfc_resource/ci/efrm/vi_resource.h
+++ /dev/null
@@ -1,157 +0,0 @@
-/****************************************************************************
- * Driver for Solarflare network controllers -
- *          resource management for Xen backend, OpenOnload, etc
- *           (including support for SFE4001 10GBT NIC)
- *
- * This file contains public API for VI resource.
- *
- * Copyright 2005-2007: Solarflare Communications Inc,
- *                      9501 Jeronimo Road, Suite 250,
- *                      Irvine, CA 92618, USA
- *
- * Developed and maintained by Solarflare Communications:
- *                      <linux-xen-drivers@solarflare.com>
- *                      <onload-dev@solarflare.com>
- *
- * Certain parts of the driver were implemented by
- *          Alexandra Kossovsky <Alexandra.Kossovsky@oktetlabs.ru>
- *          OKTET Labs Ltd, Russia,
- *          http://oktetlabs.ru, <info@oktetlabs.ru>
- *          by request of Solarflare Communications
- *
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 as published
- * by the Free Software Foundation, incorporated herein by reference.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
- ****************************************************************************
- */
-
-#ifndef __CI_EFRM_VI_RESOURCE_H__
-#define __CI_EFRM_VI_RESOURCE_H__
-
-#include <ci/efhw/efhw_types.h>
-#include <ci/efrm/resource.h>
-#include <ci/efrm/debug.h>
-
-struct vi_resource;
-
-/* Make these inline instead of macros for type checking */
-static inline struct vi_resource *
-efrm_to_vi_resource(struct efrm_resource *rs)
-{
-	EFRM_ASSERT(EFRM_RESOURCE_TYPE(rs->rs_handle) == EFRM_RESOURCE_VI);
-	return (struct vi_resource *) rs;
-}
-static inline struct
-efrm_resource *efrm_from_vi_resource(struct vi_resource *rs)
-{
-	return (struct efrm_resource *)rs;
-}
-
-#define EFAB_VI_RESOURCE_INSTANCE(virs) \
-    EFRM_RESOURCE_INSTANCE(efrm_from_vi_resource(virs)->rs_handle)
-
-#define EFAB_VI_RESOURCE_PRI_ARG(virs) \
-    EFRM_RESOURCE_PRI_ARG(efrm_from_vi_resource(virs)->rs_handle)
-
-extern int
-efrm_vi_resource_alloc(struct efrm_client *client,
-		       struct vi_resource *evq_virs,
-		       uint16_t vi_flags, int32_t evq_capacity,
-		       int32_t txq_capacity, int32_t rxq_capacity,
-		       uint8_t tx_q_tag, uint8_t rx_q_tag,
-		       struct vi_resource **virs_in_out,
-		       uint32_t *out_io_mmap_bytes,
-		       uint32_t *out_mem_mmap_bytes,
-		       uint32_t *out_txq_capacity,
-		       uint32_t *out_rxq_capacity);
-
-extern void efrm_vi_resource_free(struct vi_resource *);
-extern void efrm_vi_resource_release(struct vi_resource *);
-
-
-/*--------------------------------------------------------------------
- *
- * eventq handling
- *
- *--------------------------------------------------------------------*/
-
-/*! Reset an event queue and clear any associated timers */
-extern void efrm_eventq_reset(struct vi_resource *virs);
-
-/*! Register a kernel-level handler for the event queue.  This function is
- * called whenever a timer expires, or whenever the event queue is woken
- * but no thread is blocked on it.
- *
- * This function returns -EBUSY if a callback is already installed.
- *
- * \param rs      Event-queue resource
- * \param handler Callback-handler
- * \param arg     Argument to pass to callback-handler
- * \return        Status code
- */
-extern int
-efrm_eventq_register_callback(struct vi_resource *rs,
-			      void (*handler)(void *arg, int is_timeout,
-					      struct efhw_nic *nic),
-			      void *arg);
-
-/*! Kill the kernel-level callback.
- *
- * This function stops the timer from running and unregisters the callback
- * function.  It waits for any running timeout handlers to complete before
- * returning.
- *
- * \param rs      Event-queue resource
- * \return        Nothing
- */
-extern void efrm_eventq_kill_callback(struct vi_resource *rs);
-
-/*! Ask the NIC to generate a wakeup when an event is next delivered. */
-extern void efrm_eventq_request_wakeup(struct vi_resource *rs,
-				       unsigned current_ptr);
-
-/*! Register a kernel-level handler for flush completions.
- * \TODO Currently, it is unsafe to install a callback more than once.
- *
- * \param rs      VI resource being flushed.
- * \param handler Callback handler function.
- * \param arg     Argument to be passed to handler.
- */
-extern void
-efrm_vi_register_flush_callback(struct vi_resource *rs,
-				void (*handler)(void *),
-				void *arg);
-
-int efrm_vi_resource_flush_retry(struct vi_resource *virs);
-
-/*! Comment? */
-extern int efrm_pt_flush(struct vi_resource *);
-
-/*! Comment? */
-extern int efrm_pt_pace(struct vi_resource *, unsigned int val);
-
-uint32_t efrm_vi_rm_txq_bytes(struct vi_resource *virs
-			      /*,struct efhw_nic *nic */);
-uint32_t efrm_vi_rm_rxq_bytes(struct vi_resource *virs
-			      /*,struct efhw_nic *nic */);
-uint32_t efrm_vi_rm_evq_bytes(struct vi_resource *virs
-			      /*,struct efhw_nic *nic */);
-
-
-/* Fill [out_vi_data] with information required to allow a VI to be init'd.
- * [out_vi_data] must ref at least VI_MAPPINGS_SIZE bytes.
- */
-extern void efrm_vi_resource_mappings(struct vi_resource *, void *out_vi_data);
-
-
-#endif /* __CI_EFRM_VI_RESOURCE_H__ */
diff -r 9566a4a50a43 drivers/net/sfc/sfc_resource/ci/efrm/vi_resource_manager.h
--- a/drivers/net/sfc/sfc_resource/ci/efrm/vi_resource_manager.h
+++ /dev/null
@@ -1,155 +0,0 @@
-/****************************************************************************
- * Driver for Solarflare network controllers -
- *          resource management for Xen backend, OpenOnload, etc
- *           (including support for SFE4001 10GBT NIC)
- *
- * This file contains type definitions for VI resource.  These types
- * may be used outside of the SFC resource driver, but such use is not
- * recommended.
- *
- * Copyright 2005-2007: Solarflare Communications Inc,
- *                      9501 Jeronimo Road, Suite 250,
- *                      Irvine, CA 92618, USA
- *
- * Developed and maintained by Solarflare Communications:
- *                      <linux-xen-drivers@solarflare.com>
- *                      <onload-dev@solarflare.com>
- *
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 as published
- * by the Free Software Foundation, incorporated herein by reference.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
- ****************************************************************************
- */
-
-#ifndef __CI_DRIVER_EFAB_VI_RESOURCE_MANAGER_H__
-#define __CI_DRIVER_EFAB_VI_RESOURCE_MANAGER_H__
-
-#include <ci/efhw/common.h>
-#include <ci/efrm/vi_resource.h>
-
-
-#define EFRM_VI_RM_DMA_QUEUE_COUNT 2
-#define EFRM_VI_RM_DMA_QUEUE_TX    0
-#define EFRM_VI_RM_DMA_QUEUE_RX    1
-
-/** Numbers of bits which can be set in the evq_state member of
- * vi_resource_evq_info. */
-enum {
-  /** This bit is set if a wakeup has been requested on the NIC. */
-	VI_RESOURCE_EVQ_STATE_WAKEUP_PENDING,
-  /** This bit is set if the wakeup is valid for the sleeping
-   * process. */
-	VI_RESOURCE_EVQ_STATE_CALLBACK_REGISTERED,
-  /** This bit is set if a wakeup or timeout event is currently being
-   * processed. */
-	VI_RESOURCE_EVQ_STATE_BUSY,
-};
-#define VI_RESOURCE_EVQ_STATE(X) \
-	(((int32_t)1) << (VI_RESOURCE_EVQ_STATE_##X))
-
-
-/*! Global information for the VI resource manager. */
-struct vi_resource_manager {
-	struct efrm_resource_manager rm;
-
-	struct kfifo *instances_with_timer;
-	int with_timer_base;
-	int with_timer_limit;
-	struct kfifo *instances_with_interrupt;
-	int with_interrupt_base;
-	int with_interrupt_limit;
-
-	bool iscsi_dmaq_instance_is_free;
-
-	/* We keep VI resources which need flushing on these lists.  The VI
-	 * is put on the outstanding list when the flush request is issued
-	 * to the hardware and removed when the flush event arrives.  The
-	 * hardware can only handle a limited number of RX flush requests at
-	 * once, so VIs are placed in the waiting list until the flush can
-	 * be issued.  Flushes can be requested by the client or internally
-	 * by the VI resource manager.  In the former case, the reference
-	 * count must be non-zero for the duration of the flush and in the
-	 * later case, the reference count must be zero. */
-	struct list_head rx_flush_waiting_list;
-	struct list_head rx_flush_outstanding_list;
-	struct list_head tx_flush_outstanding_list;
-	int rx_flush_outstanding_count;
-
-	/* once the flush has happened we push the close into the work queue
-	 * so its OK on Windows to free the resources (Bug 3469).  Resources
-	 * on this list have zero reference count.
-	 */
-	struct list_head close_pending;
-	struct work_struct work_item;
-	struct workqueue_struct *workqueue;
-};
-
-struct vi_resource_nic_info {
-	struct eventq_resource_hardware evq_pages;
-	struct efhw_iopages dmaq_pages[EFRM_VI_RM_DMA_QUEUE_COUNT];
-};
-
-struct vi_resource {
-	/* Some macros make the assumption that the struct efrm_resource is
-	 * the first member of a struct vi_resource. */
-	struct efrm_resource rs;
-	atomic_t evq_refs;	/*!< Number of users of the event queue. */
-
-	uint32_t bar_mmap_bytes;
-	uint32_t mem_mmap_bytes;
-
-	int32_t evq_capacity;
-	int32_t dmaq_capacity[EFRM_VI_RM_DMA_QUEUE_COUNT];
-
-	uint8_t dmaq_tag[EFRM_VI_RM_DMA_QUEUE_COUNT];
-	uint16_t flags;
-
-	/* we keep PT endpoints that have been destroyed on a list
-	 * until we have seen their TX and RX DMAQs flush complete
-	 * (see Bug 1217)
-	 */
-	struct list_head rx_flush_link;
-	struct list_head tx_flush_link;
-	int rx_flushing;
-	int rx_flush_outstanding;
-	int tx_flushing;
-	uint64_t flush_time;
-	int flush_count;
-
-	void (*flush_callback_fn)(void *);
-	void *flush_callback_arg;
-
-	void (*evq_callback_fn) (void *arg, int is_timeout,
-				 struct efhw_nic *nic);
-	void *evq_callback_arg;
-
-	struct vi_resource *evq_virs;	/*!< EVQ for DMA queues */
-
-	 struct efhw_buffer_table_allocation
-	    dmaq_buf_tbl_alloc[EFRM_VI_RM_DMA_QUEUE_COUNT];
-
-	struct vi_resource_nic_info nic_info;
-};
-
-#undef vi_resource
-#define vi_resource(rs1)  container_of((rs1), struct vi_resource, rs)
-
-static inline dma_addr_t
-efrm_eventq_dma_addr(struct vi_resource *virs)
-{
-	struct eventq_resource_hardware *hw;
-	hw = &virs->nic_info.evq_pages;
-	return efhw_iopages_dma_addr(&hw->iobuff) + hw->iobuff_off;
-}
-
-#endif /* __CI_DRIVER_EFAB_VI_RESOURCE_MANAGER_H__ */
diff -r 9566a4a50a43 drivers/net/sfc/sfc_resource/ci/efrm/vi_resource_private.h
--- a/drivers/net/sfc/sfc_resource/ci/efrm/vi_resource_private.h
+++ /dev/null
@@ -1,65 +0,0 @@
-/****************************************************************************
- * Driver for Solarflare network controllers -
- *          resource management for Xen backend, OpenOnload, etc
- *           (including support for SFE4001 10GBT NIC)
- *
- * This file contains private API for VI resource.  The API is not designed
- * to be used outside of the SFC resource driver.
- *
- * Copyright 2005-2007: Solarflare Communications Inc,
- *                      9501 Jeronimo Road, Suite 250,
- *                      Irvine, CA 92618, USA
- *
- * Developed and maintained by Solarflare Communications:
- *                      <linux-xen-drivers@solarflare.com>
- *                      <onload-dev@solarflare.com>
- *
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 as published
- * by the Free Software Foundation, incorporated herein by reference.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
- ****************************************************************************
- */
-
-#ifndef __CI_EFRM_VI_RESOURCE_PRIVATE_H__
-#define __CI_EFRM_VI_RESOURCE_PRIVATE_H__
-
-#include <ci/efhw/common.h>
-#include <ci/efrm/vi_resource_manager.h>
-
-extern struct vi_resource_manager *efrm_vi_manager;
-
-/*************************************************************************/
-
-extern void efrm_vi_rm_delayed_free(struct work_struct *data);
-
-extern void efrm_vi_rm_salvage_flushed_vis(void);
-
-void efrm_vi_rm_free_flushed_resource(struct vi_resource *virs);
-
-void efrm_vi_rm_init_dmaq(struct vi_resource *virs, int queue_index,
-			  struct efhw_nic *nic);
-
-/*! Wakeup handler */
-extern void efrm_handle_wakeup_event(struct efhw_nic *nic, unsigned id);
-
-/*! Timeout handler */
-extern void efrm_handle_timeout_event(struct efhw_nic *nic, unsigned id);
-
-/*! DMA flush handler */
-extern void efrm_handle_dmaq_flushed(struct efhw_nic *nic, unsigned id,
-				   int rx_flush);
-
-/*! SRAM update handler */
-extern void efrm_handle_sram_event(struct efhw_nic *nic);
-
-#endif /* __CI_EFRM_VI_RESOURCE_PRIVATE_H__ */
diff -r 9566a4a50a43 drivers/net/sfc/sfc_resource/driver_object.c
--- a/drivers/net/sfc/sfc_resource/driver_object.c
+++ /dev/null
@@ -1,328 +0,0 @@
-/****************************************************************************
- * Driver for Solarflare network controllers -
- *          resource management for Xen backend, OpenOnload, etc
- *           (including support for SFE4001 10GBT NIC)
- *
- * This file contains support for the global driver variables.
- *
- * Copyright 2005-2007: Solarflare Communications Inc,
- *                      9501 Jeronimo Road, Suite 250,
- *                      Irvine, CA 92618, USA
- *
- * Developed and maintained by Solarflare Communications:
- *                      <linux-xen-drivers@solarflare.com>
- *                      <onload-dev@solarflare.com>
- *
- * Certain parts of the driver were implemented by
- *          Alexandra Kossovsky <Alexandra.Kossovsky@oktetlabs.ru>
- *          OKTET Labs Ltd, Russia,
- *          http://oktetlabs.ru, <info@oktetlabs.ru>
- *          by request of Solarflare Communications
- *
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 as published
- * by the Free Software Foundation, incorporated herein by reference.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
- ****************************************************************************
- */
-
-#include <ci/efrm/nic_table.h>
-#include <ci/efrm/resource.h>
-#include <ci/efrm/debug.h>
-#include <ci/efrm/efrm_client.h>
-#include <ci/efrm/efrm_nic.h>
-#include "efrm_internal.h"
-
-/* We use #define rather than static inline here so that the Windows
- * "prefast" compiler can see its own locking primitive when these
- * two function are used (and then perform extra checking where they
- * are used)
- *
- * Both macros operate on an irq_flags_t
-*/
-
-#define efrm_driver_lock(irqlock_state) \
-	spin_lock_irqsave(&efrm_nic_tablep->lock, irqlock_state)
-
-#define efrm_driver_unlock(irqlock_state)		\
-	spin_unlock_irqrestore(&efrm_nic_tablep->lock,	\
-			       irqlock_state);
-
-/* These routines are all methods on the architecturally singleton
-   global variables: efrm_nic_table, efrm_rm_table.
-
-   I hope we never find a driver model that does not allow global
-   structure variables :) (but that would break almost every driver I've
-   ever seen).
-*/
-
-/*! Exported driver state */
-static struct efrm_nic_table efrm_nic_table;
-struct efrm_nic_table *efrm_nic_tablep;
-EXPORT_SYMBOL(efrm_nic_tablep);
-
-
-/* Internal table with resource managers.
- * We'd like to not export it, but we are still using efrm_rm_table
- * in the char driver. So, it is declared in the private header with
- * a purpose. */
-struct efrm_resource_manager *efrm_rm_table[EFRM_RESOURCE_NUM];
-EXPORT_SYMBOL(efrm_rm_table);
-
-
-/* List of registered nics. */
-static LIST_HEAD(efrm_nics);
-
-
-void efrm_driver_ctor(void)
-{
-	efrm_nic_tablep = &efrm_nic_table;
-	spin_lock_init(&efrm_nic_tablep->lock);
-	EFRM_TRACE("%s: driver created", __func__);
-}
-
-void efrm_driver_dtor(void)
-{
-	EFRM_ASSERT(!efrm_nic_table_held());
-
-	spin_lock_destroy(&efrm_nic_tablep->lock);
-	memset(&efrm_nic_table, 0, sizeof(efrm_nic_table));
-	memset(&efrm_rm_table, 0, sizeof(efrm_rm_table));
-	EFRM_TRACE("%s: driver deleted", __func__);
-}
-
-int efrm_driver_register_nic(struct efrm_nic *rnic, int nic_index,
-			     int ifindex)
-{
-	struct efhw_nic *nic = &rnic->efhw_nic;
-	struct efrm_nic_per_vi *vis;
-	int max_vis, rc = 0;
-	irq_flags_t lock_flags;
-
-	EFRM_ASSERT(nic_index >= 0);
-	EFRM_ASSERT(ifindex >= 0);
-
-	max_vis = 4096; /* TODO: Get runtime value. */
-	vis = vmalloc(max_vis * sizeof(rnic->vis[0]));
-	if (vis == NULL) {
-		EFRM_ERR("%s: Out of memory", __func__);
-		return -ENOMEM;
-	}
-
-	efrm_driver_lock(lock_flags);
-
-	if (efrm_nic_table_held()) {
-		EFRM_ERR("%s: driver object is in use", __func__);
-		rc = -EBUSY;
-		goto done;
-	}
-
-	if (efrm_nic_tablep->nic_count == EFHW_MAX_NR_DEVS) {
-		EFRM_ERR("%s: filled up NIC table size %d", __func__,
-			 EFHW_MAX_NR_DEVS);
-		rc = -E2BIG;
-		goto done;
-	}
-
-	rnic->vis = vis;
-
-	EFRM_ASSERT(efrm_nic_tablep->nic[nic_index] == NULL);
-	efrm_nic_tablep->nic[nic_index] = nic;
-	nic->index = nic_index;
-	nic->ifindex = ifindex;
-
-	if (efrm_nic_tablep->a_nic == NULL)
-		efrm_nic_tablep->a_nic = nic;
-
-	efrm_nic_tablep->nic_count++;
-
-	INIT_LIST_HEAD(&rnic->clients);
-	list_add(&rnic->link, &efrm_nics);
-
-	efrm_driver_unlock(lock_flags);
-	return 0;
-
-done:
-	efrm_driver_unlock(lock_flags);
-	vfree(vis);
-	return rc;
-}
-
-int efrm_driver_unregister_nic(struct efrm_nic *rnic)
-{
-	struct efhw_nic *nic = &rnic->efhw_nic;
-	int rc = 0;
-	int nic_index = nic->index;
-	irq_flags_t lock_flags;
-
-	EFRM_ASSERT(nic_index >= 0);
-
-	efrm_driver_lock(lock_flags);
-
-	if (efrm_nic_table_held()) {
-		EFRM_ERR("%s: driver object is in use", __func__);
-		rc = -EBUSY;
-		goto done;
-	}
-	if (!list_empty(&rnic->clients)) {
-		EFRM_ERR("%s: nic has active clients", __func__);
-		rc = -EBUSY;
-		goto done;
-	}
-
-	EFRM_ASSERT(efrm_nic_tablep->nic[nic_index] == nic);
-	EFRM_ASSERT(list_empty(&rnic->clients));
-
-	list_del(&rnic->link);
-
-	nic->index = -1;
-	efrm_nic_tablep->nic[nic_index] = NULL;
-
-	--efrm_nic_tablep->nic_count;
-
-	if (efrm_nic_tablep->a_nic == nic) {
-		if (efrm_nic_tablep->nic_count == 0) {
-			efrm_nic_tablep->a_nic = NULL;
-		} else {
-			for (nic_index = 0; nic_index < EFHW_MAX_NR_DEVS;
-			     nic_index++) {
-				if (efrm_nic_tablep->nic[nic_index] != NULL)
-					efrm_nic_tablep->a_nic =
-					    efrm_nic_tablep->nic[nic_index];
-			}
-			EFRM_ASSERT(efrm_nic_tablep->a_nic);
-		}
-	}
-
-done:
-	efrm_driver_unlock(lock_flags);
-	return rc;
-}
-
-
-int efrm_nic_pre_reset(struct efhw_nic *nic)
-{
-	struct efrm_nic *rnic = efrm_nic(nic);
-	struct efrm_client *client;
-	struct efrm_resource *rs;
-	struct list_head *client_link;
-	struct list_head *rs_link;
-	irq_flags_t lock_flags;
-
-	spin_lock_irqsave(&efrm_nic_tablep->lock, lock_flags);
-	list_for_each(client_link, &rnic->clients) {
-		client = container_of(client_link, struct efrm_client, link);
-		EFRM_ERR("%s: client %p", __func__, client);
-		if (client->callbacks->pre_reset)
-			client->callbacks->pre_reset(client, client->user_data);
-		list_for_each(rs_link, &client->resources) {
-			rs = container_of(rs_link, struct efrm_resource,
-					  rs_client_link);
-			EFRM_ERR("%s: resource %p", __func__, rs);
-			/* TODO: mark rs defunct */
-		}
-	}
-	spin_unlock_irqrestore(&efrm_nic_tablep->lock, lock_flags);
-
-	return 0;
-}
-
-
-int efrm_nic_stop(struct efhw_nic *nic)
-{
-	/* TODO */
-	return 0;
-}
-
-
-int efrm_nic_resume(struct efhw_nic *nic)
-{
-	/* TODO */
-	return 0;
-}
-
-
-static void efrm_client_nullcb(struct efrm_client *client, void *user_data)
-{
-}
-
-static struct efrm_client_callbacks efrm_null_callbacks = {
-	efrm_client_nullcb,
-	efrm_client_nullcb,
-	efrm_client_nullcb
-};
-
-
-int efrm_client_get(int ifindex, struct efrm_client_callbacks *callbacks,
-		    void *user_data, struct efrm_client **client_out)
-{
-	struct efrm_nic *n, *rnic = NULL;
-	irq_flags_t lock_flags;
-	struct list_head *link;
-	struct efrm_client *client;
-
-	if (callbacks == NULL)
-		callbacks = &efrm_null_callbacks;
-
-	client = kmalloc(sizeof(*client), GFP_KERNEL);
-	if (client == NULL)
-		return -ENOMEM;
-
-	spin_lock_irqsave(&efrm_nic_tablep->lock, lock_flags);
-	list_for_each(link, &efrm_nics) {
-		n = container_of(link, struct efrm_nic, link);
-		if (n->efhw_nic.ifindex == ifindex || ifindex < 0) {
-			rnic = n;
-			break;
-		}
-	}
-	if (rnic) {
-		client->user_data = user_data;
-		client->callbacks = callbacks;
-		client->nic = &rnic->efhw_nic;
-		client->ref_count = 1;
-		INIT_LIST_HEAD(&client->resources);
-		list_add(&client->link, &rnic->clients);
-	}
-	spin_unlock_irqrestore(&efrm_nic_tablep->lock, lock_flags);
-
-	if (rnic == NULL)
-		return -ENODEV;
-
-	*client_out = client;
-	return 0;
-}
-EXPORT_SYMBOL(efrm_client_get);
-
-
-void efrm_client_put(struct efrm_client *client)
-{
-	irq_flags_t lock_flags;
-
-	EFRM_ASSERT(client->ref_count > 0);
-
-	spin_lock_irqsave(&efrm_nic_tablep->lock, lock_flags);
-	if (--client->ref_count > 0)
-		client = NULL;
-	else
-		list_del(&client->link);
-	spin_unlock_irqrestore(&efrm_nic_tablep->lock, lock_flags);
-	kfree(client);
-}
-EXPORT_SYMBOL(efrm_client_put);
-
-
-struct efhw_nic *efrm_client_get_nic(struct efrm_client *client)
-{
-	return client->nic;
-}
-EXPORT_SYMBOL(efrm_client_get_nic);
diff -r 9566a4a50a43 drivers/net/sfc/sfc_resource/driverlink_new.c
--- a/drivers/net/sfc/sfc_resource/driverlink_new.c
+++ /dev/null
@@ -1,260 +0,0 @@
-/****************************************************************************
- * Driver for Solarflare network controllers -
- *          resource management for Xen backend, OpenOnload, etc
- *           (including support for SFE4001 10GBT NIC)
- *
- * This file contains driverlink code which interacts with the sfc network
- * driver.
- *
- * Copyright 2005-2007: Solarflare Communications Inc,
- *                      9501 Jeronimo Road, Suite 250,
- *                      Irvine, CA 92618, USA
- *
- * Developed and maintained by Solarflare Communications:
- *                      <linux-xen-drivers@solarflare.com>
- *                      <onload-dev@solarflare.com>
- *
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 as published
- * by the Free Software Foundation, incorporated herein by reference.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
- ****************************************************************************
- */
-
-#include "linux_resource_internal.h"
-#include "driverlink_api.h"
-#include "kernel_compat.h"
-#include <ci/efhw/falcon.h>
-
-#include <linux/rtnetlink.h>
-#include <linux/netdevice.h>
-#include <net/net_namespace.h>
-
-/* The DL driver and associated calls */
-static int efrm_dl_probe(struct efx_dl_device *efrm_dev,
-			 const struct net_device *net_dev,
-			 const struct efx_dl_device_info *dev_info,
-			 const char *silicon_rev);
-
-static void efrm_dl_remove(struct efx_dl_device *efrm_dev);
-
-static void efrm_dl_reset_suspend(struct efx_dl_device *efrm_dev);
-
-static void efrm_dl_reset_resume(struct efx_dl_device *efrm_dev, int ok);
-
-static void efrm_dl_mtu_changed(struct efx_dl_device *, int);
-static void efrm_dl_event_falcon(struct efx_dl_device *efx_dev, void *p_event);
-
-static struct efx_dl_driver efrm_dl_driver = {
-	.name = "resource",
-	.probe = efrm_dl_probe,
-	.remove = efrm_dl_remove,
-	.reset_suspend = efrm_dl_reset_suspend,
-	.reset_resume = efrm_dl_reset_resume
-};
-
-static void
-init_vi_resource_dimensions(struct vi_resource_dimensions *rd,
-			    const struct efx_dl_falcon_resources *res)
-{
-	rd->evq_timer_min = res->evq_timer_min;
-	rd->evq_timer_lim = res->evq_timer_lim;
-	rd->evq_int_min = res->evq_int_min;
-	rd->evq_int_lim = res->evq_int_lim;
-	rd->rxq_min = res->rxq_min;
-	rd->rxq_lim = res->rxq_lim;
-	rd->txq_min = res->txq_min;
-	rd->txq_lim = res->txq_lim;
-	EFRM_TRACE
-	    ("Using evq_int(%d-%d) evq_timer(%d-%d) RXQ(%d-%d) TXQ(%d-%d)",
-	     res->evq_int_min, res->evq_int_lim, res->evq_timer_min,
-	     res->evq_timer_lim, res->rxq_min, res->rxq_lim, res->txq_min,
-	     res->txq_lim);
-}
-
-static int
-efrm_dl_probe(struct efx_dl_device *efrm_dev,
-	      const struct net_device *net_dev,
-	      const struct efx_dl_device_info *dev_info,
-	      const char *silicon_rev)
-{
-	struct vi_resource_dimensions res_dim;
-	struct efx_dl_falcon_resources *res;
-	struct linux_efhw_nic *lnic;
-	struct pci_dev *dev;
-	struct efhw_nic *nic;
-	unsigned probe_flags = 0;
-	int non_irq_evq;
-	int rc;
-
-	efrm_dev->priv = NULL;
-
-	efx_dl_search_device_info(dev_info, EFX_DL_FALCON_RESOURCES,
-				  struct efx_dl_falcon_resources,
-				  hdr, res);
-
-	if (res == NULL) {
-		EFRM_ERR("%s: Unable to find falcon driverlink resources",
-			 __func__);
-		return -EINVAL;
-	}
-
-	if (res->flags & EFX_DL_FALCON_USE_MSI)
-		probe_flags |= NIC_FLAG_TRY_MSI;
-
-	dev = efrm_dev->pci_dev;
-	if (res->flags & EFX_DL_FALCON_DUAL_FUNC) {
-		unsigned vendor = dev->vendor;
-		EFRM_ASSERT(dev->bus != NULL);
-		dev = NULL;
-
-		while ((dev = pci_get_device(vendor, FALCON_S_DEVID, dev))
-		       != NULL) {
-			EFRM_ASSERT(dev->bus != NULL);
-			/* With PCIe (since it's point to point)
-			 * the slot ID is usually 0 and
-			 * the bus ID changes NIC to NIC, so we really
-			 * need to check both. */
-			if (PCI_SLOT(dev->devfn) ==
-			    PCI_SLOT(efrm_dev->pci_dev->devfn)
-			    && dev->bus->number ==
-			    efrm_dev->pci_dev->bus->number)
-				break;
-		}
-		if (dev == NULL) {
-			EFRM_ERR("%s: Unable to find falcon secondary "
-				 "PCI device.", __func__);
-			return -ENODEV;
-		}
-		pci_dev_put(dev);
-	}
-
-	init_vi_resource_dimensions(&res_dim, res);
-
-	EFRM_ASSERT(res_dim.evq_timer_lim > res_dim.evq_timer_min);
-	res_dim.evq_timer_lim--;
-	non_irq_evq = res_dim.evq_timer_lim;
-
-	rc = efrm_nic_add(dev, probe_flags, net_dev->dev_addr, &lnic,
-			  res->biu_lock,
-			  res->buffer_table_min, res->buffer_table_lim,
-			  non_irq_evq, &res_dim);
-	if (rc != 0)
-		return rc;
-
-	nic = &lnic->efrm_nic.efhw_nic;
-	nic->mtu = net_dev->mtu + ETH_HLEN;
-	nic->net_driver_dev = efrm_dev;
-	nic->ifindex = net_dev->ifindex;
-#ifdef CONFIG_NET_NS
-	nic->nd_net = net_dev->nd_net;
-#endif
-	efrm_dev->priv = nic;
-
-	/* Register a callback so we're told when MTU changes.
-	 * We dynamically allocate efx_dl_callbacks, because
-	 * the callbacks that we want depends on the NIC type.
-	 */
-	lnic->dl_callbacks =
-	    kmalloc(sizeof(struct efx_dl_callbacks), GFP_KERNEL);
-	if (!lnic->dl_callbacks) {
-		EFRM_ERR("Out of memory (%s)", __func__);
-		efrm_nic_del(lnic);
-		return -ENOMEM;
-	}
-	memset(lnic->dl_callbacks, 0, sizeof(*lnic->dl_callbacks));
-	lnic->dl_callbacks->mtu_changed = efrm_dl_mtu_changed;
-
-	if ((res->flags & EFX_DL_FALCON_DUAL_FUNC) == 0) {
-		/* Net driver receives all management events.
-		 * Register a callback to receive the ones
-		 * we're interested in. */
-		lnic->dl_callbacks->event = efrm_dl_event_falcon;
-	}
-
-	rc = efx_dl_register_callbacks(efrm_dev, lnic->dl_callbacks);
-	if (rc < 0) {
-		EFRM_ERR("%s: efx_dl_register_callbacks failed (%d)",
-			 __func__, rc);
-		kfree(lnic->dl_callbacks);
-		efrm_nic_del(lnic);
-		return rc;
-	}
-
-	return 0;
-}
-
-/* When we unregister ourselves on module removal, this function will be
- * called for all the devices we claimed */
-static void efrm_dl_remove(struct efx_dl_device *efrm_dev)
-{
-	struct efhw_nic *nic = efrm_dev->priv;
-	struct linux_efhw_nic *lnic = linux_efhw_nic(nic);
-	EFRM_TRACE("%s called", __func__);
-	if (lnic->dl_callbacks) {
-		efx_dl_unregister_callbacks(efrm_dev, lnic->dl_callbacks);
-		kfree(lnic->dl_callbacks);
-	}
-	if (efrm_dev->priv)
-		efrm_nic_del(lnic);
-	EFRM_TRACE("%s OK", __func__);
-}
-
-static void efrm_dl_reset_suspend(struct efx_dl_device *efrm_dev)
-{
-	EFRM_NOTICE("%s:", __func__);
-}
-
-static void efrm_dl_reset_resume(struct efx_dl_device *efrm_dev, int ok)
-{
-	EFRM_NOTICE("%s: ok=%d", __func__, ok);
-}
-
-int efrm_driverlink_register(void)
-{
-	EFRM_TRACE("%s:", __func__);
-	return efx_dl_register_driver(&efrm_dl_driver);
-}
-
-void efrm_driverlink_unregister(void)
-{
-	EFRM_TRACE("%s:", __func__);
-	efx_dl_unregister_driver(&efrm_dl_driver);
-}
-
-static void efrm_dl_mtu_changed(struct efx_dl_device *efx_dev, int mtu)
-{
-	struct efhw_nic *nic = efx_dev->priv;
-
-	ASSERT_RTNL();	/* Since we're looking at efx_dl_device::port_net_dev */
-
-	EFRM_TRACE("%s: old=%d new=%d", __func__, nic->mtu, mtu + ETH_HLEN);
-	/* If this happened we must have agreed to it above */
-	nic->mtu = mtu + ETH_HLEN;
-}
-
-static void efrm_dl_event_falcon(struct efx_dl_device *efx_dev, void *p_event)
-{
-	struct efhw_nic *nic = efx_dev->priv;
-	struct linux_efhw_nic *lnic = linux_efhw_nic(nic);
-	efhw_event_t *ev = p_event;
-
-	switch (FALCON_EVENT_CODE(ev)) {
-	case FALCON_EVENT_CODE_CHAR:
-		falcon_handle_char_event(nic, lnic->ev_handlers, ev);
-		break;
-	default:
-		EFRM_WARN("%s: unknown event type=%x", __func__,
-			  (unsigned)FALCON_EVENT_CODE(ev));
-		break;
-	}
-}
diff -r 9566a4a50a43 drivers/net/sfc/sfc_resource/efrm_internal.h
--- a/drivers/net/sfc/sfc_resource/efrm_internal.h
+++ /dev/null
@@ -1,41 +0,0 @@
-#ifndef __EFRM_INTERNAL_H__
-#define __EFRM_INTERNAL_H__
-
-
-struct filter_resource {
-	struct efrm_resource rs;
-	struct vi_resource *pt;
-	int filter_idx;
-};
-
-#define filter_resource(rs1)  container_of((rs1), struct filter_resource, rs)
-
-
-struct efrm_client {
-	void *user_data;
-	struct list_head link;
-	struct efrm_client_callbacks *callbacks;
-	struct efhw_nic *nic;
-	int ref_count;
-	struct list_head resources;
-};
-
-
-extern void efrm_client_add_resource(struct efrm_client *,
-				     struct efrm_resource *);
-
-extern int efrm_buffer_table_size(void);
-
-
-static inline void efrm_resource_init(struct efrm_resource *rs,
-				      int type, int instance)
-{
-	EFRM_ASSERT(instance >= 0);
-	EFRM_ASSERT(type >= 0 && type < EFRM_RESOURCE_NUM);
-	rs->rs_ref_count = 1;
-	rs->rs_handle.handle = (type << 28u) |
-		(((unsigned)jiffies & 0xfff) << 16) | instance;
-}
-
-
-#endif  /* __EFRM_INTERNAL_H__ */
diff -r 9566a4a50a43 drivers/net/sfc/sfc_resource/efx_vi_shm.c
--- a/drivers/net/sfc/sfc_resource/efx_vi_shm.c
+++ /dev/null
@@ -1,707 +0,0 @@
-/****************************************************************************
- * Driver for Solarflare network controllers -
- *          resource management for Xen backend, OpenOnload, etc
- *           (including support for SFE4001 10GBT NIC)
- *
- * This file provides implementation of EFX VI API, used from Xen
- * acceleration driver.
- *
- * Copyright 2005-2007: Solarflare Communications Inc,
- *                      9501 Jeronimo Road, Suite 250,
- *                      Irvine, CA 92618, USA
- *
- * Developed and maintained by Solarflare Communications:
- *                      <linux-xen-drivers@solarflare.com>
- *                      <onload-dev@solarflare.com>
- *
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 as published
- * by the Free Software Foundation, incorporated herein by reference.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
- ****************************************************************************
- */
-
-#include "linux_resource_internal.h"
-#include <ci/efrm/vi_resource_manager.h>
-#include <ci/driver/resource/efx_vi.h>
-#include <ci/efrm/filter.h>
-#include <ci/efrm/buffer_table.h>
-#include <ci/efrm/efrm_client.h>
-#include <linux/pci.h>
-#include "kernel_compat.h"
-
-#if EFX_VI_STATIC_FILTERS
-struct filter_list_t {
-	struct filter_list_t *next;
-	struct filter_resource *fres;
-};
-#endif
-
-struct efx_vi_state {
-	struct vi_resource *vi_res;
-
-	int ifindex;
-	struct efrm_client *efrm_client;
-	struct efhw_nic *nic;
-
-	void (*callback_fn)(void *arg, int is_timeout);
-	void *callback_arg;
-
-	struct completion flush_completion;
-
-#if EFX_VI_STATIC_FILTERS
-	struct filter_list_t fres[EFX_VI_STATIC_FILTERS];
-	struct filter_list_t *free_fres;
-	struct filter_list_t *used_fres;
-#endif
-};
-
-static void efx_vi_flush_complete(void *state_void)
-{
-	struct efx_vi_state *state = (struct efx_vi_state *)state_void;
-
-	complete(&state->flush_completion);
-}
-
-static inline int alloc_ep(struct efx_vi_state *state)
-{
-	int rc;
-
-	rc = efrm_vi_resource_alloc(state->efrm_client, NULL, EFHW_VI_JUMBO_EN,
-				    efx_vi_eventq_size,
-				    FALCON_DMA_Q_DEFAULT_TX_SIZE,
-				    FALCON_DMA_Q_DEFAULT_RX_SIZE,
-				    0, 0, &state->vi_res, NULL, NULL, NULL,
-				    NULL);
-	if (rc < 0) {
-		EFRM_ERR("%s: ERROR efrm_vi_resource_alloc error %d",
-			 __func__, rc);
-		return rc;
-	}
-
-	efrm_vi_register_flush_callback(state->vi_res, &efx_vi_flush_complete,
-					(void *)state);
-
-	return 0;
-}
-
-static int free_ep(struct efx_vi_state *efx_state)
-{
-	efrm_vi_resource_release(efx_state->vi_res);
-
-	return 0;
-}
-
-#if EFX_VI_STATIC_FILTERS
-static int efx_vi_alloc_static_filters(struct efx_vi_state *efx_state)
-{
-	int i;
-	int rc;
-
-	efx_state->free_fres = efx_state->used_fres = NULL;
-
-	for (i = 0; i < EFX_VI_STATIC_FILTERS; i++) {
-		rc = efrm_filter_resource_alloc(efx_state->vi_res,
-						&efx_state->fres[i].fres);
-		if (rc < 0) {
-			EFRM_ERR("%s: efrm_filter_resource_alloc failed: %d",
-			     __func__, rc);
-			while (i > 0) {
-				i--;
-				efrm_filter_resource_release(efx_state->
-							     fres[i].fres);
-			}
-			efx_state->free_fres = NULL;
-			return rc;
-		}
-		efx_state->fres[i].next = efx_state->free_fres;
-		efx_state->free_fres = &efx_state->fres[i];
-	}
-
-	return 0;
-}
-#endif
-
-int efx_vi_alloc(struct efx_vi_state **vih_out, int ifindex)
-{
-	struct efx_vi_state *efx_state;
-	int rc;
-
-	efx_state = kmalloc(sizeof(struct efx_vi_state), GFP_KERNEL);
-
-	if (!efx_state) {
-		EFRM_ERR("%s: failed to allocate memory for efx_vi_state",
-			 __func__);
-		rc = -ENOMEM;
-		goto fail;
-	}
-
-	efx_state->ifindex = ifindex;
-	rc = efrm_client_get(ifindex, NULL, NULL, &efx_state->efrm_client);
-	if (rc < 0) {
-		EFRM_ERR("%s: efrm_client_get(%d) failed: %d", __func__,
-			 ifindex, rc);
-		rc = -ENODEV;
-		goto fail_no_ifindex;
-	}
-	efx_state->nic = efrm_client_get_nic(efx_state->efrm_client);
-
-	init_completion(&efx_state->flush_completion);
-
-	/* basically allocate_pt_endpoint() */
-	rc = alloc_ep(efx_state);
-	if (rc) {
-		EFRM_ERR("%s: alloc_ep failed: %d", __func__, rc);
-		goto fail_no_pt;
-	}
-#if EFX_VI_STATIC_FILTERS
-	/* Statically allocate a set of filter resources - removes the
-	   restriction on not being able to use efx_vi_filter() from
-	   in_atomic() */
-	rc = efx_vi_alloc_static_filters(efx_state);
-	if (rc)
-		goto fail_no_filters;
-#endif
-
-	*vih_out = efx_state;
-
-	return 0;
-#if EFX_VI_STATIC_FILTERS
-fail_no_filters:
-	free_ep(efx_state);
-#endif
-fail_no_pt:
-	efrm_client_put(efx_state->efrm_client);
-fail_no_ifindex:
-	kfree(efx_state);
-fail:
-	return rc;
-}
-EXPORT_SYMBOL(efx_vi_alloc);
-
-void efx_vi_free(struct efx_vi_state *vih)
-{
-	struct efx_vi_state *efx_state = vih;
-
-	/* TODO flush dma channels, init dma queues?.  See ef_free_vnic() */
-#if EFX_VI_STATIC_FILTERS
-	int i;
-
-	for (i = 0; i < EFX_VI_STATIC_FILTERS; i++)
-		efrm_filter_resource_release(efx_state->fres[i].fres);
-#endif
-
-	if (efx_state->vi_res)
-		free_ep(efx_state);
-
-	efrm_client_put(efx_state->efrm_client);
-
-	kfree(efx_state);
-}
-EXPORT_SYMBOL(efx_vi_free);
-
-void efx_vi_reset(struct efx_vi_state *vih)
-{
-	struct efx_vi_state *efx_state = vih;
-
-	efrm_pt_flush(efx_state->vi_res);
-
-	while (wait_for_completion_timeout(&efx_state->flush_completion, HZ)
-	       == 0)
-		efrm_vi_resource_flush_retry(efx_state->vi_res);
-
-	/* Bosch the eventq */
-	efrm_eventq_reset(efx_state->vi_res);
-	return;
-}
-EXPORT_SYMBOL(efx_vi_reset);
-
-static void
-efx_vi_eventq_callback(void *context, int is_timeout, struct efhw_nic *nic)
-{
-	struct efx_vi_state *efx_state = (struct efx_vi_state *)context;
-
-	EFRM_ASSERT(efx_state->callback_fn);
-
-	return efx_state->callback_fn(efx_state->callback_arg, is_timeout);
-}
-
-int
-efx_vi_eventq_register_callback(struct efx_vi_state *vih,
-			void (*callback)(void *context, int is_timeout),
-			void *context)
-{
-	struct efx_vi_state *efx_state = vih;
-
-	efx_state->callback_fn = callback;
-	efx_state->callback_arg = context;
-
-	/* Register the eventq timeout event callback */
-	efrm_eventq_register_callback(efx_state->vi_res,
-				      efx_vi_eventq_callback, efx_state);
-
-	return 0;
-}
-EXPORT_SYMBOL(efx_vi_eventq_register_callback);
-
-int efx_vi_eventq_kill_callback(struct efx_vi_state *vih)
-{
-	struct efx_vi_state *efx_state = vih;
-
-	if (efx_state->vi_res->evq_callback_fn)
-		efrm_eventq_kill_callback(efx_state->vi_res);
-
-	efx_state->callback_fn = NULL;
-	efx_state->callback_arg = NULL;
-
-	return 0;
-}
-EXPORT_SYMBOL(efx_vi_eventq_kill_callback);
-
-struct efx_vi_dma_map_state {
-	struct efhw_buffer_table_allocation bt_handle;
-	int n_pages;
-	dma_addr_t *dma_addrs;
-};
-
-int
-efx_vi_dma_map_pages(struct efx_vi_state *vih, struct page **pages,
-		     int n_pages, struct efx_vi_dma_map_state **dmh_out)
-{
-	struct efx_vi_state *efx_state = vih;
-	int order = fls(n_pages - 1), rc, i, evq_id;
-	dma_addr_t dma_addr;
-	struct efx_vi_dma_map_state *dm_state;
-
-	if (n_pages != (1 << order)) {
-		EFRM_WARN("%s: Can only allocate buffers in power of 2 "
-			  "sizes (not %d)", __func__, n_pages);
-		return -EINVAL;
-	}
-
-	dm_state = kmalloc(sizeof(struct efx_vi_dma_map_state), GFP_KERNEL);
-	if (!dm_state)
-		return -ENOMEM;
-
-	dm_state->dma_addrs = kmalloc(sizeof(dma_addr_t) * n_pages,
-				      GFP_KERNEL);
-	if (!dm_state->dma_addrs) {
-		kfree(dm_state);
-		return -ENOMEM;
-	}
-
-	rc = efrm_buffer_table_alloc(order, &dm_state->bt_handle);
-	if (rc < 0) {
-		kfree(dm_state->dma_addrs);
-		kfree(dm_state);
-		return rc;
-	}
-
-	evq_id = EFRM_RESOURCE_INSTANCE(efx_state->vi_res->rs.rs_handle);
-	for (i = 0; i < n_pages; i++) {
-		/* TODO do we need to get_page() here ? */
-
-		dma_addr = pci_map_page(linux_efhw_nic(efx_state->nic)->
-					  pci_dev, pages[i], 0, PAGE_SIZE,
-					PCI_DMA_TODEVICE);
-
-		efrm_buffer_table_set(&dm_state->bt_handle, efx_state->nic,
-				      i, dma_addr, evq_id);
-
-		dm_state->dma_addrs[i] = dma_addr;
-
-		/* Would be nice to not have to call commit each time, but
-		 * comment says there are hardware restrictions on how often
-		 * you can go without it, so do this to be safe */
-		efrm_buffer_table_commit();
-	}
-
-	dm_state->n_pages = n_pages;
-
-	*dmh_out = dm_state;
-
-	return 0;
-}
-EXPORT_SYMBOL(efx_vi_dma_map_pages);
-
-/* Function needed as Xen can't get pages for grants in dom0, but can
-   get dma address */
-int
-efx_vi_dma_map_addrs(struct efx_vi_state *vih,
-		     unsigned long long *bus_dev_addrs,
-		     int n_pages, struct efx_vi_dma_map_state **dmh_out)
-{
-	struct efx_vi_state *efx_state = vih;
-	int order = fls(n_pages - 1), rc, i, evq_id;
-	dma_addr_t dma_addr;
-	struct efx_vi_dma_map_state *dm_state;
-
-	if (n_pages != (1 << order)) {
-		EFRM_WARN("%s: Can only allocate buffers in power of 2 "
-			  "sizes (not %d)", __func__, n_pages);
-		return -EINVAL;
-	}
-
-	dm_state = kmalloc(sizeof(struct efx_vi_dma_map_state), GFP_KERNEL);
-	if (!dm_state)
-		return -ENOMEM;
-
-	dm_state->dma_addrs = kmalloc(sizeof(dma_addr_t) * n_pages,
-				      GFP_KERNEL);
-	if (!dm_state->dma_addrs) {
-		kfree(dm_state);
-		return -ENOMEM;
-	}
-
-	rc = efrm_buffer_table_alloc(order, &dm_state->bt_handle);
-	if (rc < 0) {
-		kfree(dm_state->dma_addrs);
-		kfree(dm_state);
-		return rc;
-	}
-
-	evq_id = EFRM_RESOURCE_INSTANCE(efx_state->vi_res->rs.rs_handle);
-#if 0
-	EFRM_WARN("%s: mapping %d pages to evq %d, bt_ids %d-%d\n",
-		  __func__, n_pages, evq_id,
-		  dm_state->bt_handle.base,
-		  dm_state->bt_handle.base + n_pages);
-#endif
-	for (i = 0; i < n_pages; i++) {
-
-		dma_addr = (dma_addr_t)bus_dev_addrs[i];
-
-		efrm_buffer_table_set(&dm_state->bt_handle, efx_state->nic,
-				      i, dma_addr, evq_id);
-
-		dm_state->dma_addrs[i] = dma_addr;
-
-		/* Would be nice to not have to call commit each time, but
-		 * comment says there are hardware restrictions on how often
-		 * you can go without it, so do this to be safe */
-		efrm_buffer_table_commit();
-	}
-
-	dm_state->n_pages = n_pages;
-
-	*dmh_out = dm_state;
-
-	return 0;
-}
-EXPORT_SYMBOL(efx_vi_dma_map_addrs);
-
-void
-efx_vi_dma_unmap_pages(struct efx_vi_state *vih,
-		       struct efx_vi_dma_map_state *dmh)
-{
-	struct efx_vi_state *efx_state = vih;
-	struct efx_vi_dma_map_state *dm_state =
-	    (struct efx_vi_dma_map_state *)dmh;
-	int i;
-
-	efrm_buffer_table_free(&dm_state->bt_handle);
-
-	for (i = 0; i < dm_state->n_pages; ++i)
-		pci_unmap_page(linux_efhw_nic(efx_state->nic)->pci_dev,
-			       dm_state->dma_addrs[i], PAGE_SIZE,
-			       PCI_DMA_TODEVICE);
-
-	kfree(dm_state->dma_addrs);
-	kfree(dm_state);
-
-	return;
-}
-EXPORT_SYMBOL(efx_vi_dma_unmap_pages);
-
-void
-efx_vi_dma_unmap_addrs(struct efx_vi_state *vih,
-		       struct efx_vi_dma_map_state *dmh)
-{
-	struct efx_vi_dma_map_state *dm_state =
-	    (struct efx_vi_dma_map_state *)dmh;
-
-	efrm_buffer_table_free(&dm_state->bt_handle);
-
-	kfree(dm_state->dma_addrs);
-	kfree(dm_state);
-
-	return;
-}
-EXPORT_SYMBOL(efx_vi_dma_unmap_addrs);
-
-unsigned
-efx_vi_dma_get_map_addr(struct efx_vi_state *vih,
-			struct efx_vi_dma_map_state *dmh)
-{
-	struct efx_vi_dma_map_state *dm_state =
-	    (struct efx_vi_dma_map_state *)dmh;
-
-	return EFHW_BUFFER_ADDR(dm_state->bt_handle.base, 0);
-}
-EXPORT_SYMBOL(efx_vi_dma_get_map_addr);
-
-#if EFX_VI_STATIC_FILTERS
-static int
-get_filter(struct efx_vi_state *efx_state,
-	   efrm_resource_handle_t pthandle, struct filter_resource **fres_out)
-{
-	struct filter_list_t *flist;
-	if (efx_state->free_fres == NULL)
-		return -ENOMEM;
-	else {
-		flist = efx_state->free_fres;
-		efx_state->free_fres = flist->next;
-		flist->next = efx_state->used_fres;
-		efx_state->used_fres = flist;
-		*fres_out = flist->fres;
-		return 0;
-	}
-}
-#endif
-
-static void
-release_filter(struct efx_vi_state *efx_state, struct filter_resource *fres)
-{
-#if EFX_VI_STATIC_FILTERS
-	struct filter_list_t *flist = efx_state->used_fres, *prev = NULL;
-	while (flist) {
-		if (flist->fres == fres) {
-			if (prev)
-				prev->next = flist->next;
-			else
-				efx_state->used_fres = flist->next;
-			flist->next = efx_state->free_fres;
-			efx_state->free_fres = flist;
-			return;
-		}
-		prev = flist;
-		flist = flist->next;
-	}
-	EFRM_ERR("%s: couldn't find filter", __func__);
-#else
-	return efrm_filter_resource_release(fres);
-#endif
-}
-
-int
-efx_vi_filter(struct efx_vi_state *vih, int protocol,
-	      unsigned ip_addr_be32, int port_le16,
-	      struct filter_resource_t **fh_out)
-{
-	struct efx_vi_state *efx_state = vih;
-	struct filter_resource *uninitialized_var(frs);
-	int rc;
-
-#if EFX_VI_STATIC_FILTERS
-	rc = get_filter(efx_state, efx_state->vi_res->rs.rs_handle, &frs);
-#else
-	rc = efrm_filter_resource_alloc(efx_state->vi_res, &frs);
-#endif
-	if (rc < 0)
-		return rc;
-
-	/* Add the hardware filter. We pass in the source port and address
-	 * as 0 (wildcard) to minimise the number of filters needed. */
-	if (protocol == IPPROTO_TCP) {
-		rc = efrm_filter_resource_tcp_set(frs, 0, 0, ip_addr_be32,
-						  port_le16);
-	} else {
-		rc = efrm_filter_resource_udp_set(frs, 0, 0, ip_addr_be32,
-						  port_le16);
-	}
-
-	*fh_out = (struct filter_resource_t *)frs;
-
-	return rc;
-}
-EXPORT_SYMBOL(efx_vi_filter);
-
-int
-efx_vi_filter_stop(struct efx_vi_state *vih, struct filter_resource_t *fh)
-{
-	struct efx_vi_state *efx_state = vih;
-	struct filter_resource *frs = (struct filter_resource *)fh;
-	int rc;
-
-	rc = efrm_filter_resource_clear(frs);
-	release_filter(efx_state, frs);
-
-	return rc;
-}
-EXPORT_SYMBOL(efx_vi_filter_stop);
-
-int
-efx_vi_hw_resource_get_virt(struct efx_vi_state *vih,
-			    struct efx_vi_hw_resource_metadata *mdata,
-			    struct efx_vi_hw_resource *hw_res_array,
-			    int *length)
-{
-	EFRM_NOTICE("%s: TODO!", __func__);
-
-	return 0;
-}
-EXPORT_SYMBOL(efx_vi_hw_resource_get_virt);
-
-int
-efx_vi_hw_resource_get_phys(struct efx_vi_state *vih,
-			    struct efx_vi_hw_resource_metadata *mdata,
-			    struct efx_vi_hw_resource *hw_res_array,
-			    int *length)
-{
-	struct efx_vi_state *efx_state = vih;
-	struct linux_efhw_nic *lnic = linux_efhw_nic(efx_state->nic);
-	unsigned long phys = lnic->ctr_ap_pci_addr;
-	struct efrm_resource *ep_res = &efx_state->vi_res->rs;
-	unsigned ep_mmap_bytes;
-	int i;
-
-	if (*length < EFX_VI_HW_RESOURCE_MAXSIZE)
-		return -EINVAL;
-
-	mdata->nic_arch = efx_state->nic->devtype.arch;
-	mdata->nic_variant = efx_state->nic->devtype.variant;
-	mdata->nic_revision = efx_state->nic->devtype.revision;
-
-	mdata->evq_order =
-	    efx_state->vi_res->nic_info.evq_pages.iobuff.order;
-	mdata->evq_offs = efx_state->vi_res->nic_info.evq_pages.iobuff_off;
-	mdata->evq_capacity = efx_vi_eventq_size;
-	mdata->instance = EFRM_RESOURCE_INSTANCE(ep_res->rs_handle);
-	mdata->rx_capacity = FALCON_DMA_Q_DEFAULT_RX_SIZE;
-	mdata->tx_capacity = FALCON_DMA_Q_DEFAULT_TX_SIZE;
-
-	ep_mmap_bytes = FALCON_DMA_Q_DEFAULT_MMAP;
-	EFRM_ASSERT(ep_mmap_bytes == PAGE_SIZE * 2);
-
-#ifndef NDEBUG
-	{
-		/* Sanity about doorbells */
-		unsigned long tx_dma_page_addr, rx_dma_page_addr;
-
-		/* get rx doorbell address */
-		rx_dma_page_addr =
-		    phys + falcon_rx_dma_page_addr(mdata->instance);
-		/* get tx doorbell address */
-		tx_dma_page_addr =
-		    phys + falcon_tx_dma_page_addr(mdata->instance);
-
-		/* Check the lower bits of the TX doorbell will be
-		 * consistent. */
-		EFRM_ASSERT((TX_DESC_UPD_REG_PAGE4_OFST &
-			     FALCON_DMA_PAGE_MASK) ==
-			    (TX_DESC_UPD_REG_PAGE123K_OFST &
-			     FALCON_DMA_PAGE_MASK));
-
-		/* Check the lower bits of the RX doorbell will be
-		 * consistent. */
-		EFRM_ASSERT((RX_DESC_UPD_REG_PAGE4_OFST &
-			     FALCON_DMA_PAGE_MASK) ==
-			    (RX_DESC_UPD_REG_PAGE123K_OFST &
-			     FALCON_DMA_PAGE_MASK));
-
-		/* Check that the doorbells will be in the same page. */
-		EFRM_ASSERT((TX_DESC_UPD_REG_PAGE4_OFST & PAGE_MASK) ==
-			    (RX_DESC_UPD_REG_PAGE4_OFST & PAGE_MASK));
-
-		/* Check that the doorbells are in the same page. */
-		EFRM_ASSERT((tx_dma_page_addr & PAGE_MASK) ==
-			    (rx_dma_page_addr & PAGE_MASK));
-
-		/* Check that the TX doorbell offset is correct. */
-		EFRM_ASSERT((TX_DESC_UPD_REG_PAGE4_OFST & ~PAGE_MASK) ==
-			    (tx_dma_page_addr & ~PAGE_MASK));
-
-		/* Check that the RX doorbell offset is correct. */
-		EFRM_ASSERT((RX_DESC_UPD_REG_PAGE4_OFST & ~PAGE_MASK) ==
-			    (rx_dma_page_addr & ~PAGE_MASK));
-	}
-#endif
-
-	i = 0;
-	hw_res_array[i].type = EFX_VI_HW_RESOURCE_TXDMAQ;
-	hw_res_array[i].mem_type = EFX_VI_HW_RESOURCE_PERIPHERAL;
-	hw_res_array[i].more_to_follow = 0;
-	hw_res_array[i].length = PAGE_SIZE;
-	hw_res_array[i].address =
-		(unsigned long)efx_state->vi_res->nic_info.
-			dmaq_pages[EFRM_VI_RM_DMA_QUEUE_TX].kva;
-
-	i++;
-	hw_res_array[i].type = EFX_VI_HW_RESOURCE_RXDMAQ;
-	hw_res_array[i].mem_type = EFX_VI_HW_RESOURCE_PERIPHERAL;
-	hw_res_array[i].more_to_follow = 0;
-	hw_res_array[i].length = PAGE_SIZE;
-	hw_res_array[i].address =
-		(unsigned long)efx_state->vi_res->nic_info.
-			dmaq_pages[EFRM_VI_RM_DMA_QUEUE_RX].kva;
-
-	i++;
-	hw_res_array[i].type = EFX_VI_HW_RESOURCE_EVQTIMER;
-	hw_res_array[i].mem_type = EFX_VI_HW_RESOURCE_PERIPHERAL;
-	hw_res_array[i].more_to_follow = 0;
-	hw_res_array[i].length = PAGE_SIZE;
-	hw_res_array[i].address =
-		(unsigned long)phys + falcon_timer_page_addr(mdata->instance);
-
-	/* NB EFX_VI_HW_RESOURCE_EVQPTR not used on Falcon */
-
-	i++;
-	switch (efx_state->nic->devtype.variant) {
-	case 'A':
-		hw_res_array[i].type = EFX_VI_HW_RESOURCE_EVQRPTR;
-		hw_res_array[i].mem_type = EFX_VI_HW_RESOURCE_PERIPHERAL;
-		hw_res_array[i].more_to_follow = 0;
-		hw_res_array[i].length = PAGE_SIZE;
-		hw_res_array[i].address = (unsigned long)phys +
-			EVQ_RPTR_REG_OFST +
-			(FALCON_REGISTER128 * mdata->instance);
-		break;
-	case 'B':
-		hw_res_array[i].type = EFX_VI_HW_RESOURCE_EVQRPTR_OFFSET;
-		hw_res_array[i].mem_type = EFX_VI_HW_RESOURCE_PERIPHERAL;
-		hw_res_array[i].more_to_follow = 0;
-		hw_res_array[i].length = PAGE_SIZE;
-		hw_res_array[i].address =
-			(unsigned long)FALCON_EVQ_RPTR_REG_P0;
-		break;
-	default:
-		EFRM_ASSERT(0);
-		break;
-	}
-
-	i++;
-	hw_res_array[i].type = EFX_VI_HW_RESOURCE_EVQMEMKVA;
-	hw_res_array[i].mem_type = EFX_VI_HW_RESOURCE_IOBUFFER;
-	hw_res_array[i].more_to_follow = 0;
-	hw_res_array[i].length = PAGE_SIZE;
-	hw_res_array[i].address = (unsigned long)efx_state->vi_res->
-		nic_info.evq_pages.iobuff.kva;
-
-	i++;
-	hw_res_array[i].type = EFX_VI_HW_RESOURCE_BELLPAGE;
-	hw_res_array[i].mem_type = EFX_VI_HW_RESOURCE_PERIPHERAL;
-	hw_res_array[i].more_to_follow = 0;
-	hw_res_array[i].length = PAGE_SIZE;
-	hw_res_array[i].address =
-		(unsigned long)(phys +
-				falcon_tx_dma_page_addr(mdata->instance))
-		>> PAGE_SHIFT;
-
-	i++;
-
-	EFRM_ASSERT(i <= *length);
-
-	*length = i;
-
-	return 0;
-}
-EXPORT_SYMBOL(efx_vi_hw_resource_get_phys);
diff -r 9566a4a50a43 drivers/net/sfc/sfc_resource/eventq.c
--- a/drivers/net/sfc/sfc_resource/eventq.c
+++ /dev/null
@@ -1,321 +0,0 @@
-/****************************************************************************
- * Driver for Solarflare network controllers -
- *          resource management for Xen backend, OpenOnload, etc
- *           (including support for SFE4001 10GBT NIC)
- *
- * This file contains event queue support.
- *
- * Copyright 2005-2007: Solarflare Communications Inc,
- *                      9501 Jeronimo Road, Suite 250,
- *                      Irvine, CA 92618, USA
- *
- * Developed and maintained by Solarflare Communications:
- *                      <linux-xen-drivers@solarflare.com>
- *                      <onload-dev@solarflare.com>
- *
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 as published
- * by the Free Software Foundation, incorporated herein by reference.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
- ****************************************************************************
- */
-
-#include <ci/efhw/debug.h>
-#include <ci/efhw/iopage.h>
-#include <ci/driver/efab/hardware.h>
-#include <ci/efhw/eventq.h>
-#include <ci/efhw/falcon.h>
-#include <ci/efhw/nic.h>
-
-#define KEVENTQ_MAGIC 0x07111974
-
-/*! Helper function to allocate the iobuffer needed by an eventq
- *   - it ensures the eventq has the correct alignment for the NIC
- *
- * \param rm        Event-queue resource manager
- * \param instance  Event-queue instance (index)
- * \param buf_bytes Requested size of eventq
- * \return          < 0 if iobuffer allocation fails
- */
-int
-efhw_nic_event_queue_alloc_iobuffer(struct efhw_nic *nic,
-				    struct eventq_resource_hardware *h,
-				    int evq_instance, unsigned buf_bytes)
-{
-	unsigned int page_order;
-	int rc;
-
-	/* Allocate an iobuffer. */
-	page_order = get_order(buf_bytes);
-
-	h->iobuff_off = 0;
-
-	EFHW_TRACE("allocating eventq size %x",
-		   1u << (page_order + PAGE_SHIFT));
-	rc = efhw_iopages_alloc(nic, &h->iobuff, page_order);
-	if (rc < 0) {
-		EFHW_WARN("%s: failed to allocate %u pages",
-			  __func__, 1u << page_order);
-		return rc;
-	}
-
-	/* Set the eventq pages to match EFHW_CLEAR_EVENT() */
-	if (EFHW_CLEAR_EVENT_VALUE)
-		memset(efhw_iopages_ptr(&h->iobuff) + h->iobuff_off,
-		       EFHW_CLEAR_EVENT_VALUE, (1u << page_order) * PAGE_SIZE);
-
-	EFHW_TRACE("%s: allocated %u pages", __func__, 1u << (page_order));
-
-	/* For Falcon the NIC is programmed with the base buffer address of a
-	 * contiguous region of buffer space. This means that larger than a
-	 * PAGE event queues can be expected to allocate even when the host's
-	 * physical memory is fragmented */
-	EFHW_ASSERT(efhw_nic_have_hw(nic));
-	EFHW_ASSERT(page_order <= h->buf_tbl_alloc.order);
-
-	/* Initialise the buffer table entries. */
-	falcon_nic_buffer_table_set_n(nic, h->buf_tbl_alloc.base,
-				      efhw_iopages_dma_addr(&h->iobuff) +
-				      h->iobuff_off, EFHW_NIC_PAGE_SIZE, 0,
-				      1 << page_order, 0);
-
-	if (evq_instance >= FALCON_EVQ_TBL_RESERVED)
-		falcon_nic_buffer_table_confirm(nic);
-	return 0;
-}
-
-/**********************************************************************
- * Kernel event queue management.
- */
-
-/* Values for [struct efhw_keventq::lock] field. */
-#define KEVQ_UNLOCKED      0
-#define KEVQ_LOCKED        1
-#define KEVQ_RECHECK       2
-
-int
-efhw_keventq_ctor(struct efhw_nic *nic, int instance,
-		  struct efhw_keventq *evq,
-		  struct efhw_ev_handler *ev_handlers)
-{
-	int rc;
-	unsigned buf_bytes = evq->hw.capacity * sizeof(efhw_event_t);
-
-	evq->instance = instance;
-	evq->ev_handlers = ev_handlers;
-
-	/* allocate an IObuffer for the eventq */
-	rc = efhw_nic_event_queue_alloc_iobuffer(nic, &evq->hw, evq->instance,
-						 buf_bytes);
-	if (rc < 0)
-		return rc;
-
-	/* Zero the timer-value for this queue.
-	   AND Tell the nic about the event queue. */
-	efhw_nic_event_queue_enable(nic, evq->instance, evq->hw.capacity,
-				    efhw_iopages_dma_addr(&evq->hw.iobuff) +
-				    evq->hw.iobuff_off,
-				    evq->hw.buf_tbl_alloc.base,
-				    1 /* interrupting */);
-
-	evq->lock = KEVQ_UNLOCKED;
-	evq->evq_base = efhw_iopages_ptr(&evq->hw.iobuff) + evq->hw.iobuff_off;
-	evq->evq_ptr = 0;
-	evq->evq_mask = (evq->hw.capacity * sizeof(efhw_event_t)) - 1u;
-
-	EFHW_TRACE("%s: [%d] base=%p end=%p", __func__, evq->instance,
-		   evq->evq_base, evq->evq_base + buf_bytes);
-
-	return 0;
-}
-
-void efhw_keventq_dtor(struct efhw_nic *nic, struct efhw_keventq *evq)
-{
-	EFHW_ASSERT(evq);
-
-	EFHW_TRACE("%s: [%d]", __func__, evq->instance);
-
-	/* Zero the timer-value for this queue.
-	   And Tell NIC to stop using this event queue. */
-	efhw_nic_event_queue_disable(nic, evq->instance, 0);
-
-	/* free the pages used by the eventq itself */
-	efhw_iopages_free(nic, &evq->hw.iobuff);
-}
-
-void
-efhw_handle_txdmaq_flushed(struct efhw_nic *nic, struct efhw_ev_handler *h,
-			   efhw_event_t *evp)
-{
-	int instance = (int)FALCON_EVENT_TX_FLUSH_Q_ID(evp);
-	EFHW_TRACE("%s: instance=%d", __func__, instance);
-
-	if (!h->dmaq_flushed_fn) {
-		EFHW_WARN("%s: no handler registered", __func__);
-		return;
-	}
-
-	h->dmaq_flushed_fn(nic, instance, false);
-}
-
-void
-efhw_handle_rxdmaq_flushed(struct efhw_nic *nic, struct efhw_ev_handler *h,
-			   efhw_event_t *evp)
-{
-	unsigned instance = (unsigned)FALCON_EVENT_RX_FLUSH_Q_ID(evp);
-	EFHW_TRACE("%s: instance=%d", __func__, instance);
-
-	if (!h->dmaq_flushed_fn) {
-		EFHW_WARN("%s: no handler registered", __func__);
-		return;
-	}
-
-	h->dmaq_flushed_fn(nic, instance, true);
-}
-
-void
-efhw_handle_wakeup_event(struct efhw_nic *nic, struct efhw_ev_handler *h,
-			 efhw_event_t *evp)
-{
-	unsigned instance = (unsigned)FALCON_EVENT_WAKE_EVQ_ID(evp);
-
-	if (!h->wakeup_fn) {
-		EFHW_WARN("%s: no handler registered", __func__);
-		return;
-	}
-
-	h->wakeup_fn(nic, instance);
-}
-
-void
-efhw_handle_timeout_event(struct efhw_nic *nic, struct efhw_ev_handler *h,
-			  efhw_event_t *evp)
-{
-	unsigned instance = (unsigned)FALCON_EVENT_WAKE_EVQ_ID(evp);
-
-	if (!h->timeout_fn) {
-		EFHW_WARN("%s: no handler registered", __func__);
-		return;
-	}
-
-	h->timeout_fn(nic, instance);
-}
-
-/**********************************************************************
- * Kernel event queue event handling.
- */
-
-int efhw_keventq_poll(struct efhw_nic *nic, struct efhw_keventq *q)
-{
-	efhw_event_t *ev;
-	int l, count = 0;
-
-	EFHW_ASSERT(nic);
-	EFHW_ASSERT(q);
-	EFHW_ASSERT(q->ev_handlers);
-
-	/* Acquire the lock, or mark the queue as needing re-checking. */
-	for (;;) {
-		l = q->lock;
-		if (l == KEVQ_UNLOCKED) {
-			if ((int)cmpxchg(&q->lock, l, KEVQ_LOCKED) == l)
-				break;
-		} else if (l == KEVQ_LOCKED) {
-			if ((int)cmpxchg(&q->lock, l, KEVQ_RECHECK) == l)
-				return 0;
-		} else {	/* already marked for re-checking */
-			EFHW_ASSERT(l == KEVQ_RECHECK);
-			return 0;
-		}
-	}
-
-	if (unlikely(EFHW_EVENT_OVERFLOW(q, q)))
-		goto overflow;
-
-	ev = EFHW_EVENT_PTR(q, q, 0);
-
-#ifndef NDEBUG
-	if (!EFHW_IS_EVENT(ev))
-		EFHW_TRACE("%s: %d NO EVENTS!", __func__, q->instance);
-#endif
-
-	for (;;) {
-		/* Convention for return codes for handlers is:
-		 **   0   - no error, event consumed
-		 **   1   - no error, event not consumed
-		 **   -ve - error,    event not consumed
-		 */
-		if (likely(EFHW_IS_EVENT(ev))) {
-			count++;
-
-			switch (FALCON_EVENT_CODE(ev)) {
-
-			case FALCON_EVENT_CODE_CHAR:
-				falcon_handle_char_event(nic, q->ev_handlers,
-							 ev);
-				break;
-
-			default:
-				EFHW_ERR("efhw_keventq_poll: [%d] UNEXPECTED "
-					 "EVENT:"FALCON_EVENT_FMT,
-					 q->instance,
-					 FALCON_EVENT_PRI_ARG(*ev));
-			}
-
-			EFHW_CLEAR_EVENT(ev);
-			EFHW_EVENTQ_NEXT(q);
-
-			ev = EFHW_EVENT_PTR(q, q, 0);
-		} else {
-			/* No events left.  Release the lock (checking if we
-			 * need to re-poll to avoid race). */
-			l = q->lock;
-			if (l == KEVQ_LOCKED) {
-				if ((int)cmpxchg(&q->lock, l, KEVQ_UNLOCKED)
-				    == l) {
-					EFHW_TRACE
-					    ("efhw_keventq_poll: %d clean exit",
-					     q->instance);
-					goto clean_exit;
-				}
-			}
-
-			/* Potentially more work to do. */
-			l = q->lock;
-			EFHW_ASSERT(l == KEVQ_RECHECK);
-			EFHW_TEST((int)cmpxchg(&q->lock, l, KEVQ_LOCKED) == l);
-			EFHW_TRACE("efhw_keventq_poll: %d re-poll required",
-				   q->instance);
-		}
-	}
-
-	/* shouldn't get here */
-	EFHW_ASSERT(0);
-
-overflow:
-	/* ?? Oh dear.  Should we poll everything that could have possibly
-	 ** happened?  Or merely cry out in anguish...
-	 */
-	EFHW_WARN("efhw_keventq_poll: %d ***** OVERFLOW nic %d *****",
-		  q->instance, nic->index);
-
-	q->lock = KEVQ_UNLOCKED;
-	return count;
-
-clean_exit:
-	/* Ack the processed events so that this event queue can potentially
-	   raise interrupts again */
-	falcon_nic_evq_ack(nic, q->instance,
-			   (EFHW_EVENT_OFFSET(q, q, 0) / sizeof(efhw_event_t)),
-			   false);
-	return count;
-}
diff -r 9566a4a50a43 drivers/net/sfc/sfc_resource/falcon.c
--- a/drivers/net/sfc/sfc_resource/falcon.c
+++ /dev/null
@@ -1,2525 +0,0 @@
-/****************************************************************************
- * Driver for Solarflare network controllers -
- *          resource management for Xen backend, OpenOnload, etc
- *           (including support for SFE4001 10GBT NIC)
- *
- * This file contains Falcon hardware support.
- *
- * Copyright 2005-2007: Solarflare Communications Inc,
- *                      9501 Jeronimo Road, Suite 250,
- *                      Irvine, CA 92618, USA
- *
- * Developed and maintained by Solarflare Communications:
- *                      <linux-xen-drivers@solarflare.com>
- *                      <onload-dev@solarflare.com>
- *
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 as published
- * by the Free Software Foundation, incorporated herein by reference.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
- ****************************************************************************
- */
-
-#include <ci/driver/efab/hardware.h>
-#include <ci/efhw/debug.h>
-#include <ci/efhw/iopage.h>
-#include <ci/efhw/falcon.h>
-#include <ci/efhw/falcon_hash.h>
-#include <ci/efhw/nic.h>
-#include <ci/efhw/eventq.h>
-#include <ci/efhw/checks.h>
-
-
-/*----------------------------------------------------------------------------
- *
- * Workarounds and options
- *
- *---------------------------------------------------------------------------*/
-
-/* Keep a software copy of the filter table and check for duplicates. */
-#define FALCON_FULL_FILTER_CACHE 1
-
-/* Read filters back from the hardware to detect corruption. */
-#define FALCON_VERIFY_FILTERS    0
-
-/* Options */
-#define RX_FILTER_CTL_SRCH_LIMIT_TCP_FULL 8	/* default search limit */
-#define RX_FILTER_CTL_SRCH_LIMIT_TCP_WILD 8	/* default search limit */
-#define RX_FILTER_CTL_SRCH_LIMIT_UDP_FULL 8	/* default search limit */
-#define RX_FILTER_CTL_SRCH_LIMIT_UDP_WILD 8	/* default search limit */
-
-#define FALCON_MAC_SET_TYPE_BY_SPEED           0
-
-/* FIXME: We should detect mode at runtime. */
-#define FALCON_BUFFER_TABLE_FULL_MODE          1
-
-/* "Fudge factors" - difference between programmed value and actual depth */
-#define RX_FILTER_CTL_SRCH_FUDGE_WILD 3	/* increase the search limit */
-#define RX_FILTER_CTL_SRCH_FUDGE_FULL 1	/* increase the search limit */
-#define TX_FILTER_CTL_SRCH_FUDGE_WILD 3	/* increase the search limit */
-#define TX_FILTER_CTL_SRCH_FUDGE_FULL 1	/* increase the search limit */
-
-/*----------------------------------------------------------------------------
- *
- * Debug Macros
- *
- *---------------------------------------------------------------------------*/
-
-#define _DEBUG_SYM_ static
-
- /*----------------------------------------------------------------------------
-  *
-  * Macros and forward declarations
-  *
-  *--------------------------------------------------------------------------*/
-
-#define FALCON_REGION_NUM 4	/* number of supported memory regions */
-
-#define FALCON_BUFFER_TBL_HALF_BYTES 4
-#define FALCON_BUFFER_TBL_FULL_BYTES 8
-
-/* Shadow buffer table - hack for testing only */
-#if FALCON_BUFFER_TABLE_FULL_MODE == 0
-# define FALCON_USE_SHADOW_BUFFER_TABLE 1
-#else
-# define FALCON_USE_SHADOW_BUFFER_TABLE 0
-#endif
-
-
-/*----------------------------------------------------------------------------
- *
- * Header assertion checks
- *
- *---------------------------------------------------------------------------*/
-
-#define FALCON_ASSERT_VALID()	/* nothing yet */
-
-/* Falcon has a 128bit register model but most registers have useful
-   defaults or only implement a small number of bits. Some registers
-   can be programmed 32bits UNLOCKED all others should be interlocked
-   against other threads within the same protection domain.
-
-   Aim is for software to perform the minimum number of writes and
-   also to minimise the read-modify-write activity (which generally
-   indicates a lack of clarity in the use model).
-
-   Registers which are programmed in this module are listed below
-   together with the method of access. Care must be taken to ensure
-   remain adequate if the register spec changes.
-
-   All 128bits programmed
-    FALCON_BUFFER_TBL_HALF
-    RX_FILTER_TBL
-    TX_DESC_PTR_TBL
-    RX_DESC_PTR_TBL
-    DRV_EV_REG
-
-   All 64bits programmed
-    FALCON_BUFFER_TBL_FULL
-
-   32 bits are programmed (UNLOCKED)
-    EVQ_RPTR_REG
-
-   Low 64bits programmed remainder are written with a random number
-    RX_DC_CFG_REG
-    TX_DC_CFG_REG
-    SRM_RX_DC_CFG_REG
-    SRM_TX_DC_CFG_REG
-    BUF_TBL_CFG_REG
-    BUF_TBL_UPD_REG
-    SRM_UPD_EVQ_REG
-    EVQ_PTR_TBL
-    TIMER_CMD_REG
-    TX_PACE_TBL
-    FATAL_INTR_REG
-    INT_EN_REG (When enabling interrupts)
-    TX_FLUSH_DESCQ_REG
-    RX_FLUSH_DESCQ
-
-  Read Modify Write on low 32bits remainder are written with a random number
-    INT_EN_REG (When sending a driver interrupt)
-    DRIVER_REGX
-
-  Read Modify Write on low 64bits remainder are written with a random number
-   SRM_CFG_REG_OFST
-   RX_CFG_REG_OFST
-   RX_FILTER_CTL_REG
-
-  Read Modify Write on full 128bits
-   TXDP_RESERVED_REG  (aka TXDP_UNDOCUMENTED)
-   TX_CFG_REG
-
-*/
-
-
-/*----------------------------------------------------------------------------
- *
- * DMAQ low-level register interface
- *
- *---------------------------------------------------------------------------*/
-
-static unsigned dmaq_sizes[] = {
-	512,
-	EFHW_1K,
-	EFHW_2K,
-	EFHW_4K,
-};
-
-#define N_DMAQ_SIZES  (sizeof(dmaq_sizes) / sizeof(dmaq_sizes[0]))
-
-static inline ulong falcon_dma_tx_q_offset(struct efhw_nic *nic, unsigned dmaq)
-{
-	EFHW_ASSERT(dmaq < nic->num_dmaqs);
-	return TX_DESC_PTR_TBL_OFST + dmaq * FALCON_REGISTER128;
-}
-
-static inline uint falcon_dma_tx_q_size_index(uint dmaq_size)
-{
-	uint i;
-
-	/* size must be one of the various options, otherwise we assert */
-	for (i = 0; i < N_DMAQ_SIZES; i++) {
-		if (dmaq_size == dmaq_sizes[i])
-			break;
-	}
-	EFHW_ASSERT(i < N_DMAQ_SIZES);
-	return i;
-}
-
-static void
-falcon_dmaq_tx_q_init(struct efhw_nic *nic,
-		      uint dmaq, uint evq_id, uint own_id,
-		      uint tag, uint dmaq_size, uint buf_idx, uint flags)
-{
-	FALCON_LOCK_DECL;
-	uint index, desc_type;
-	uint64_t val1, val2, val3;
-	ulong offset;
-	volatile char __iomem *efhw_kva = EFHW_KVA(nic);
-
-	/* Q attributes */
-	int iscsi_hdig_en = ((flags & EFHW_VI_ISCSI_TX_HDIG_EN) != 0);
-	int iscsi_ddig_en = ((flags & EFHW_VI_ISCSI_TX_DDIG_EN) != 0);
-	int csum_ip_dis = ((flags & EFHW_VI_TX_IP_CSUM_DIS) != 0);
-	int csum_tcp_dis = ((flags & EFHW_VI_TX_TCPUDP_CSUM_DIS) != 0);
-	int non_ip_drop_dis = ((flags & EFHW_VI_TX_TCPUDP_ONLY) == 0);
-
-	/* initialise the TX descriptor queue pointer table */
-
-	/* NB physical vs buffer addressing is determined by the Queue ID. */
-
-	offset = falcon_dma_tx_q_offset(nic, dmaq);
-	index = falcon_dma_tx_q_size_index(dmaq_size);
-
-	/* allow VI flag to override this queue's descriptor type */
-	desc_type = (flags & EFHW_VI_TX_PHYS_ADDR_EN) ? 0 : 1;
-
-	/* bug9403: It is dangerous to allow buffer-addressed queues to
-	 * have owner_id=0. */
-	EFHW_ASSERT((own_id > 0) || desc_type == 0);
-
-	/* dword 1 */
-	__DWCHCK(TX_DESCQ_FLUSH_LBN, TX_DESCQ_FLUSH_WIDTH);
-	__DWCHCK(TX_DESCQ_TYPE_LBN, TX_DESCQ_TYPE_WIDTH);
-	__DWCHCK(TX_DESCQ_SIZE_LBN, TX_DESCQ_SIZE_WIDTH);
-	__DWCHCK(TX_DESCQ_LABEL_LBN, TX_DESCQ_LABEL_WIDTH);
-	__DWCHCK(TX_DESCQ_OWNER_ID_LBN, TX_DESCQ_OWNER_ID_WIDTH);
-
-	__LWCHK(TX_DESCQ_EVQ_ID_LBN, TX_DESCQ_EVQ_ID_WIDTH);
-
-	__RANGECHCK(1, TX_DESCQ_FLUSH_WIDTH);
-	__RANGECHCK(desc_type, TX_DESCQ_TYPE_WIDTH);
-	__RANGECHCK(index, TX_DESCQ_SIZE_WIDTH);
-	__RANGECHCK(tag, TX_DESCQ_LABEL_WIDTH);
-	__RANGECHCK(own_id, TX_DESCQ_OWNER_ID_WIDTH);
-	__RANGECHCK(evq_id, TX_DESCQ_EVQ_ID_WIDTH);
-
-	val1 = ((desc_type << TX_DESCQ_TYPE_LBN) |
-		(index << TX_DESCQ_SIZE_LBN) |
-		(tag << TX_DESCQ_LABEL_LBN) |
-		(own_id << TX_DESCQ_OWNER_ID_LBN) |
-		(__LOW(evq_id, TX_DESCQ_EVQ_ID_LBN, TX_DESCQ_EVQ_ID_WIDTH)));
-
-	/* dword 2 */
-	__DW2CHCK(TX_DESCQ_BUF_BASE_ID_LBN, TX_DESCQ_BUF_BASE_ID_WIDTH);
-	__RANGECHCK(buf_idx, TX_DESCQ_BUF_BASE_ID_WIDTH);
-
-	val2 = ((__HIGH(evq_id, TX_DESCQ_EVQ_ID_LBN, TX_DESCQ_EVQ_ID_WIDTH)) |
-		(buf_idx << __DW2(TX_DESCQ_BUF_BASE_ID_LBN)));
-
-	/* dword 3 */
-	__DW3CHCK(TX_ISCSI_HDIG_EN_LBN, TX_ISCSI_HDIG_EN_WIDTH);
-	__DW3CHCK(TX_ISCSI_DDIG_EN_LBN, TX_ISCSI_DDIG_EN_WIDTH);
-	__RANGECHCK(iscsi_hdig_en, TX_ISCSI_HDIG_EN_WIDTH);
-	__RANGECHCK(iscsi_ddig_en, TX_ISCSI_DDIG_EN_WIDTH);
-
-	val3 = ((iscsi_hdig_en << __DW3(TX_ISCSI_HDIG_EN_LBN)) |
-		(iscsi_ddig_en << __DW3(TX_ISCSI_DDIG_EN_LBN)) |
-		(1 << __DW3(TX_DESCQ_EN_LBN)));	/* queue enable bit */
-
-	switch (nic->devtype.variant) {
-	case 'B':
-		__DW3CHCK(TX_NON_IP_DROP_DIS_B0_LBN,
-			  TX_NON_IP_DROP_DIS_B0_WIDTH);
-		__DW3CHCK(TX_IP_CHKSM_DIS_B0_LBN, TX_IP_CHKSM_DIS_B0_WIDTH);
-		__DW3CHCK(TX_TCP_CHKSM_DIS_B0_LBN, TX_TCP_CHKSM_DIS_B0_WIDTH);
-
-		val3 |= ((non_ip_drop_dis << __DW3(TX_NON_IP_DROP_DIS_B0_LBN))|
-			 (csum_ip_dis << __DW3(TX_IP_CHKSM_DIS_B0_LBN)) |
-			 (csum_tcp_dis << __DW3(TX_TCP_CHKSM_DIS_B0_LBN)));
-		break;
-	case 'A':
-		if (csum_ip_dis || csum_tcp_dis || !non_ip_drop_dis)
-			EFHW_WARN
-				("%s: bad settings for A1 csum_ip_dis=%d "
-				 "csum_tcp_dis=%d non_ip_drop_dis=%d",
-				 __func__, csum_ip_dis,
-				 csum_tcp_dis, non_ip_drop_dis);
-		break;
-	default:
-		EFHW_ASSERT(0);
-		break;
-	}
-
-	EFHW_TRACE("%s: txq %x evq %u tag %x id %x buf %x "
-		   "%x:%x:%x->%" PRIx64 ":%" PRIx64 ":%" PRIx64,
-		   __func__,
-		   dmaq, evq_id, tag, own_id, buf_idx, dmaq_size,
-		   iscsi_hdig_en, iscsi_ddig_en, val1, val2, val3);
-
-	/* Falcon requires 128 bit atomic access for this register */
-	FALCON_LOCK_LOCK(nic);
-	falcon_write_qq(efhw_kva + offset, ((val2 << 32) | val1), val3);
-	mmiowb();
-	FALCON_LOCK_UNLOCK(nic);
-	return;
-}
-
-static inline ulong
-falcon_dma_rx_q_offset(struct efhw_nic *nic, unsigned dmaq)
-{
-	EFHW_ASSERT(dmaq < nic->num_dmaqs);
-	return RX_DESC_PTR_TBL_OFST + dmaq * FALCON_REGISTER128;
-}
-
-static void
-falcon_dmaq_rx_q_init(struct efhw_nic *nic,
-		      uint dmaq, uint evq_id, uint own_id,
-		      uint tag, uint dmaq_size, uint buf_idx, uint flags)
-{
-	FALCON_LOCK_DECL;
-	uint i, desc_type = 1;
-	uint64_t val1, val2, val3;
-	ulong offset;
-	volatile char __iomem *efhw_kva = EFHW_KVA(nic);
-
-	/* Q attributes */
-#if BUG5762_WORKAROUND
-	int jumbo = 1;		/* Queues must not have mixed types */
-#else
-	int jumbo = ((flags & EFHW_VI_JUMBO_EN) != 0);
-#endif
-	int iscsi_hdig_en = ((flags & EFHW_VI_ISCSI_RX_HDIG_EN) != 0);
-	int iscsi_ddig_en = ((flags & EFHW_VI_ISCSI_RX_DDIG_EN) != 0);
-
-	/* initialise the TX descriptor queue pointer table */
-	offset = falcon_dma_rx_q_offset(nic, dmaq);
-
-	/* size must be one of the various options, otherwise we assert */
-	for (i = 0; i < N_DMAQ_SIZES; i++) {
-		if (dmaq_size == dmaq_sizes[i])
-			break;
-	}
-	EFHW_ASSERT(i < N_DMAQ_SIZES);
-
-	/* allow VI flag to override this queue's descriptor type */
-	desc_type = (flags & EFHW_VI_RX_PHYS_ADDR_EN) ? 0 : 1;
-
-	/* bug9403: It is dangerous to allow buffer-addressed queues to have
-	 * owner_id=0 */
-	EFHW_ASSERT((own_id > 0) || desc_type == 0);
-
-	/* dword 1 */
-	__DWCHCK(RX_DESCQ_EN_LBN, RX_DESCQ_EN_WIDTH);
-	__DWCHCK(RX_DESCQ_JUMBO_LBN, RX_DESCQ_JUMBO_WIDTH);
-	__DWCHCK(RX_DESCQ_TYPE_LBN, RX_DESCQ_TYPE_WIDTH);
-	__DWCHCK(RX_DESCQ_SIZE_LBN, RX_DESCQ_SIZE_WIDTH);
-	__DWCHCK(RX_DESCQ_LABEL_LBN, RX_DESCQ_LABEL_WIDTH);
-	__DWCHCK(RX_DESCQ_OWNER_ID_LBN, RX_DESCQ_OWNER_ID_WIDTH);
-
-	__LWCHK(RX_DESCQ_EVQ_ID_LBN, RX_DESCQ_EVQ_ID_WIDTH);
-
-	__RANGECHCK(1, RX_DESCQ_EN_WIDTH);
-	__RANGECHCK(jumbo, RX_DESCQ_JUMBO_WIDTH);
-	__RANGECHCK(desc_type, RX_DESCQ_TYPE_WIDTH);
-	__RANGECHCK(i, RX_DESCQ_SIZE_WIDTH);
-	__RANGECHCK(tag, RX_DESCQ_LABEL_WIDTH);
-	__RANGECHCK(own_id, RX_DESCQ_OWNER_ID_WIDTH);
-	__RANGECHCK(evq_id, RX_DESCQ_EVQ_ID_WIDTH);
-
-	val1 = ((1 << RX_DESCQ_EN_LBN) |
-		(jumbo << RX_DESCQ_JUMBO_LBN) |
-		(desc_type << RX_DESCQ_TYPE_LBN) |
-		(i << RX_DESCQ_SIZE_LBN) |
-		(tag << RX_DESCQ_LABEL_LBN) |
-		(own_id << RX_DESCQ_OWNER_ID_LBN) |
-		(__LOW(evq_id, RX_DESCQ_EVQ_ID_LBN, RX_DESCQ_EVQ_ID_WIDTH)));
-
-	/* dword 2 */
-	__DW2CHCK(RX_DESCQ_BUF_BASE_ID_LBN, RX_DESCQ_BUF_BASE_ID_WIDTH);
-	__RANGECHCK(buf_idx, RX_DESCQ_BUF_BASE_ID_WIDTH);
-
-	val2 = ((__HIGH(evq_id, RX_DESCQ_EVQ_ID_LBN, RX_DESCQ_EVQ_ID_WIDTH)) |
-		(buf_idx << __DW2(RX_DESCQ_BUF_BASE_ID_LBN)));
-
-	/* dword 3 */
-	__DW3CHCK(RX_ISCSI_HDIG_EN_LBN, RX_ISCSI_HDIG_EN_WIDTH);
-	__DW3CHCK(RX_ISCSI_DDIG_EN_LBN, RX_ISCSI_DDIG_EN_WIDTH);
-	__RANGECHCK(iscsi_hdig_en, RX_ISCSI_HDIG_EN_WIDTH);
-	__RANGECHCK(iscsi_ddig_en, RX_ISCSI_DDIG_EN_WIDTH);
-
-	val3 = (iscsi_hdig_en << __DW3(RX_ISCSI_HDIG_EN_LBN)) |
-	    (iscsi_ddig_en << __DW3(RX_ISCSI_DDIG_EN_LBN));
-
-	EFHW_TRACE("%s: rxq %x evq %u tag %x id %x buf %x %s "
-		   "%x:%x:%x -> %" PRIx64 ":%" PRIx64 ":%" PRIx64,
-		   __func__,
-		   dmaq, evq_id, tag, own_id, buf_idx,
-		   jumbo ? "jumbo" : "normal", dmaq_size,
-		   iscsi_hdig_en, iscsi_ddig_en, val1, val2, val3);
-
-	/* Falcon requires 128 bit atomic access for this register */
-	FALCON_LOCK_LOCK(nic);
-	falcon_write_qq(efhw_kva + offset, ((val2 << 32) | val1), val3);
-	mmiowb();
-	FALCON_LOCK_UNLOCK(nic);
-	return;
-}
-
-static void falcon_dmaq_tx_q_disable(struct efhw_nic *nic, uint dmaq)
-{
-	FALCON_LOCK_DECL;
-	uint64_t val1, val2, val3;
-	ulong offset;
-	volatile char __iomem *efhw_kva = EFHW_KVA(nic);
-
-	/* initialise the TX descriptor queue pointer table */
-
-	offset = falcon_dma_tx_q_offset(nic, dmaq);
-
-	/* dword 1 */
-	__DWCHCK(TX_DESCQ_TYPE_LBN, TX_DESCQ_TYPE_WIDTH);
-
-	val1 = ((uint64_t) 1 << TX_DESCQ_TYPE_LBN);
-
-	/* dword 2 */
-	val2 = 0;
-
-	/* dword 3 */
-	val3 = (0 << __DW3(TX_DESCQ_EN_LBN));	/* queue enable bit */
-
-	EFHW_TRACE("%s: %x->%" PRIx64 ":%" PRIx64 ":%" PRIx64,
-		   __func__, dmaq, val1, val2, val3);
-
-	/* Falcon requires 128 bit atomic access for this register */
-	FALCON_LOCK_LOCK(nic);
-	falcon_write_qq(efhw_kva + offset, ((val2 << 32) | val1), val3);
-	mmiowb();
-	FALCON_LOCK_UNLOCK(nic);
-	return;
-}
-
-static void falcon_dmaq_rx_q_disable(struct efhw_nic *nic, uint dmaq)
-{
-	FALCON_LOCK_DECL;
-	uint64_t val1, val2, val3;
-	ulong offset;
-	volatile char __iomem *efhw_kva = EFHW_KVA(nic);
-
-	/* initialise the TX descriptor queue pointer table */
-	offset = falcon_dma_rx_q_offset(nic, dmaq);
-
-	/* dword 1 */
-	__DWCHCK(RX_DESCQ_EN_LBN, RX_DESCQ_EN_WIDTH);
-	__DWCHCK(RX_DESCQ_TYPE_LBN, RX_DESCQ_TYPE_WIDTH);
-
-	val1 = ((0 << RX_DESCQ_EN_LBN) | (1 << RX_DESCQ_TYPE_LBN));
-
-	/* dword 2 */
-	val2 = 0;
-
-	/* dword 3 */
-	val3 = 0;
-
-	EFHW_TRACE("falcon_dmaq_rx_q_disable: %x->%"
-		   PRIx64 ":%" PRIx64 ":%" PRIx64,
-		   dmaq, val1, val2, val3);
-
-	/* Falcon requires 128 bit atomic access for this register */
-	FALCON_LOCK_LOCK(nic);
-	falcon_write_qq(efhw_kva + offset, ((val2 << 32) | val1), val3);
-	mmiowb();
-	FALCON_LOCK_UNLOCK(nic);
-	return;
-}
-
-
-/*----------------------------------------------------------------------------
- *
- * Buffer Table low-level register interface
- *
- *---------------------------------------------------------------------------*/
-
-/*! Convert a (potentially) 64-bit physical address to 32-bits.  Every use
-** of this function is a place where we're not 64-bit clean.
-*/
-static inline uint32_t dma_addr_to_u32(dma_addr_t addr)
-{
-	/* Top bits had better be zero! */
-	EFHW_ASSERT(addr == (addr & 0xffffffff));
-	return (uint32_t) addr;
-}
-
-static inline uint32_t
-falcon_nic_buffer_table_entry32_mk(dma_addr_t dma_addr, int own_id)
-{
-	uint32_t dma_addr32 = FALCON_BUFFER_4K_PAGE(dma_addr_to_u32(dma_addr));
-
-	/* don't do this to me */
-	EFHW_BUILD_ASSERT(BUF_ADR_HBUF_ODD_LBN == BUF_ADR_HBUF_EVEN_LBN + 32);
-	EFHW_BUILD_ASSERT(BUF_OWNER_ID_HBUF_ODD_LBN ==
-			  BUF_OWNER_ID_HBUF_EVEN_LBN + 32);
-
-	EFHW_BUILD_ASSERT(BUF_OWNER_ID_HBUF_ODD_WIDTH ==
-			  BUF_OWNER_ID_HBUF_EVEN_WIDTH);
-	EFHW_BUILD_ASSERT(BUF_ADR_HBUF_ODD_WIDTH == BUF_ADR_HBUF_EVEN_WIDTH);
-
-	__DWCHCK(BUF_ADR_HBUF_EVEN_LBN, BUF_ADR_HBUF_EVEN_WIDTH);
-	__DWCHCK(BUF_OWNER_ID_HBUF_EVEN_LBN, BUF_OWNER_ID_HBUF_EVEN_WIDTH);
-
-	__RANGECHCK(dma_addr32, BUF_ADR_HBUF_EVEN_WIDTH);
-	__RANGECHCK(own_id, BUF_OWNER_ID_HBUF_EVEN_WIDTH);
-
-	return (dma_addr32 << BUF_ADR_HBUF_EVEN_LBN) |
-		(own_id << BUF_OWNER_ID_HBUF_EVEN_LBN);
-}
-
-static inline uint64_t
-falcon_nic_buffer_table_entry64_mk(dma_addr_t dma_addr,
-				   int bufsz,	/* bytes */
-				   int region, int own_id)
-{
-	__DW2CHCK(IP_DAT_BUF_SIZE_LBN, IP_DAT_BUF_SIZE_WIDTH);
-	__DW2CHCK(BUF_ADR_REGION_LBN, BUF_ADR_REGION_WIDTH);
-	__LWCHK(BUF_ADR_FBUF_LBN, BUF_ADR_FBUF_WIDTH);
-	__DWCHCK(BUF_OWNER_ID_FBUF_LBN, BUF_OWNER_ID_FBUF_WIDTH);
-
-	EFHW_ASSERT((bufsz == EFHW_4K) || (bufsz == EFHW_8K));
-
-	dma_addr = (dma_addr >> 12) & __FALCON_MASK64(BUF_ADR_FBUF_WIDTH);
-
-	__RANGECHCK(dma_addr, BUF_ADR_FBUF_WIDTH);
-	__RANGECHCK(1, IP_DAT_BUF_SIZE_WIDTH);
-	__RANGECHCK(region, BUF_ADR_REGION_WIDTH);
-	__RANGECHCK(own_id, BUF_OWNER_ID_FBUF_WIDTH);
-
-	return ((uint64_t) (bufsz == EFHW_8K) << IP_DAT_BUF_SIZE_LBN) |
-		((uint64_t) region << BUF_ADR_REGION_LBN) |
-		((uint64_t) dma_addr << BUF_ADR_FBUF_LBN) |
-		((uint64_t) own_id << BUF_OWNER_ID_FBUF_LBN);
-}
-
-static inline void
-_falcon_nic_buffer_table_set32(struct efhw_nic *nic,
-			       dma_addr_t dma_addr, uint bufsz,
-			       uint region, /* not used */
-			       int own_id, int buffer_id)
-{
-	/* programming the half table needs to be done in pairs. */
-	uint64_t entry, val, shift;
-	volatile char __iomem *efhw_kva = EFHW_KVA(nic);
-	volatile char __iomem *offset;
-
-	EFHW_BUILD_ASSERT(BUF_ADR_HBUF_ODD_LBN == BUF_ADR_HBUF_EVEN_LBN + 32);
-	EFHW_BUILD_ASSERT(BUF_OWNER_ID_HBUF_ODD_LBN ==
-			  BUF_OWNER_ID_HBUF_EVEN_LBN + 32);
-
-	shift = (buffer_id & 1) ? 32 : 0;
-
-	offset = (efhw_kva + BUF_HALF_TBL_OFST +
-		  ((buffer_id & ~1) * FALCON_BUFFER_TBL_HALF_BYTES));
-
-	entry = falcon_nic_buffer_table_entry32_mk(dma_addr_to_u32(dma_addr),
-						   own_id);
-
-#if FALCON_USE_SHADOW_BUFFER_TABLE
-	val = _falcon_buffer_table[buffer_id & ~1];
-#else
-	/* This will not work unless we've completed
-	 * the buffer table updates */
-	falcon_read_q(offset, &val);
-#endif
-	val &= ~(((uint64_t) 0xffffffff) << shift);
-	val |= (entry << shift);
-
-	EFHW_TRACE("%s[%x]: %lx:%x:%" PRIx64 "->%x = %"
-		   PRIx64, __func__, buffer_id, (unsigned long) dma_addr,
-		   own_id, entry, (unsigned)(offset - efhw_kva), val);
-
-	/* Falcon requires that access to this register is serialised */
-	falcon_write_q(offset, val);
-
-	/* NB. No mmiowb().  Caller should do that e.g by calling commit  */
-
-#if FALCON_USE_SHADOW_BUFFER_TABLE
-	_falcon_buffer_table[buffer_id & ~1] = val;
-#endif
-
-	/* Confirm the entry if the event queues haven't been set up. */
-	if (!nic->irq_handler) {
-		uint64_t new_val;
-		int count = 0;
-		while (1) {
-			mmiowb();
-			falcon_read_q(offset, &new_val);
-			if (new_val == val)
-				break;
-			count++;
-			if (count > 1000) {
-				EFHW_WARN("%s: poll Timeout", __func__);
-				break;
-			}
-			udelay(1);
-		}
-	}
-}
-
-static inline void
-_falcon_nic_buffer_table_set64(struct efhw_nic *nic,
-			       dma_addr_t dma_addr, uint bufsz,
-			       uint region, int own_id, int buffer_id)
-{
-	volatile char __iomem *offset;
-	uint64_t entry;
-	volatile char __iomem *efhw_kva = EFHW_KVA(nic);
-
-	EFHW_ASSERT(region < FALCON_REGION_NUM);
-
-	EFHW_ASSERT((bufsz == EFHW_4K) ||
-		    (bufsz == EFHW_8K && FALCON_BUFFER_TABLE_FULL_MODE));
-
-	offset = (efhw_kva + BUF_FULL_TBL_OFST +
-		  (buffer_id * FALCON_BUFFER_TBL_FULL_BYTES));
-
-	entry = falcon_nic_buffer_table_entry64_mk(dma_addr, bufsz, region,
-						   own_id);
-
-	EFHW_TRACE("%s[%x]: %lx:bufsz=%x:region=%x:ownid=%x",
-		   __func__, buffer_id, (unsigned long) dma_addr, bufsz,
-		   region, own_id);
-
-	EFHW_TRACE("%s: BUF[%x]:NIC[%x]->%" PRIx64,
-		   __func__, buffer_id,
-		   (unsigned int)(offset - efhw_kva), entry);
-
-	/* Falcon requires that access to this register is serialised */
-	falcon_write_q(offset, entry);
-
-	/* NB. No mmiowb().  Caller should do that e.g by calling commit */
-
-	/* Confirm the entry if the event queues haven't been set up. */
-	if (!nic->irq_handler) {
-		uint64_t new_entry;
-		int count = 0;
-		while (1) {
-			mmiowb();
-			falcon_read_q(offset, &new_entry);
-			if (new_entry == entry)
-				return;
-			count++;
-			if (count > 1000) {
-				EFHW_WARN("%s: poll Timeout waiting for "
-					  "value %"PRIx64
-					  " (last was %"PRIx64")",
-					  __func__, entry, new_entry);
-				break;
-			}
-			udelay(1);
-		}
-	}
-}
-
-#if FALCON_BUFFER_TABLE_FULL_MODE
-#define _falcon_nic_buffer_table_set _falcon_nic_buffer_table_set64
-#else
-#define _falcon_nic_buffer_table_set _falcon_nic_buffer_table_set32
-#endif
-
-static inline void _falcon_nic_buffer_table_commit(struct efhw_nic *nic)
-{
-	/* MUST be called holding the FALCON_LOCK */
-	volatile char __iomem *efhw_kva = EFHW_KVA(nic);
-	uint64_t cmd;
-
-	EFHW_BUILD_ASSERT(BUF_TBL_UPD_REG_KER_OFST == BUF_TBL_UPD_REG_OFST);
-
-	__DW2CHCK(BUF_UPD_CMD_LBN, BUF_UPD_CMD_WIDTH);
-	__RANGECHCK(1, BUF_UPD_CMD_WIDTH);
-
-	cmd = ((uint64_t) 1 << BUF_UPD_CMD_LBN);
-
-	/* Falcon requires 128 bit atomic access for this register */
-	falcon_write_qq(efhw_kva + BUF_TBL_UPD_REG_OFST,
-			cmd, FALCON_ATOMIC_UPD_REG);
-	mmiowb();
-
-	nic->buf_commit_outstanding++;
-	EFHW_TRACE("COMMIT REQ out=%d", nic->buf_commit_outstanding);
-}
-
-static void falcon_nic_buffer_table_commit(struct efhw_nic *nic)
-{
-	/* nothing to do */
-}
-
-static inline void
-_falcon_nic_buffer_table_clear(struct efhw_nic *nic, int buffer_id, int num)
-{
-	uint64_t cmd;
-	uint64_t start_id = buffer_id;
-	uint64_t end_id = buffer_id + num - 1;
-	volatile char __iomem *efhw_kva = EFHW_KVA(nic);
-
-	volatile char __iomem *offset = (efhw_kva + BUF_TBL_UPD_REG_OFST);
-
-	EFHW_BUILD_ASSERT(BUF_TBL_UPD_REG_KER_OFST == BUF_TBL_UPD_REG_OFST);
-
-#if !FALCON_BUFFER_TABLE_FULL_MODE
-	/* buffer_ids in half buffer mode reference pairs of buffers */
-	EFHW_ASSERT(buffer_id % 1 == 0);
-	EFHW_ASSERT(num % 1 == 0);
-	start_id = start_id >> 1;
-	end_id = end_id >> 1;
-#endif
-
-	EFHW_ASSERT(num >= 1);
-
-	__DWCHCK(BUF_CLR_START_ID_LBN, BUF_CLR_START_ID_WIDTH);
-	__DW2CHCK(BUF_CLR_END_ID_LBN, BUF_CLR_END_ID_WIDTH);
-
-	__DW2CHCK(BUF_CLR_CMD_LBN, BUF_CLR_CMD_WIDTH);
-	__RANGECHCK(1, BUF_CLR_CMD_WIDTH);
-
-	__RANGECHCK(start_id, BUF_CLR_START_ID_WIDTH);
-	__RANGECHCK(end_id, BUF_CLR_END_ID_WIDTH);
-
-	cmd = (((uint64_t) 1 << BUF_CLR_CMD_LBN) |
-	       (start_id << BUF_CLR_START_ID_LBN) |
-	       (end_id << BUF_CLR_END_ID_LBN));
-
-	/* Falcon requires 128 bit atomic access for this register */
-	falcon_write_qq(offset, cmd, FALCON_ATOMIC_UPD_REG);
-	mmiowb();
-
-	nic->buf_commit_outstanding++;
-	EFHW_TRACE("COMMIT CLEAR out=%d", nic->buf_commit_outstanding);
-}
-
-/*----------------------------------------------------------------------------
- *
- * Events low-level register interface
- *
- *---------------------------------------------------------------------------*/
-
-static unsigned eventq_sizes[] = {
-	512,
-	EFHW_1K,
-	EFHW_2K,
-	EFHW_4K,
-	EFHW_8K,
-	EFHW_16K,
-	EFHW_32K
-};
-
-#define N_EVENTQ_SIZES  (sizeof(eventq_sizes) / sizeof(eventq_sizes[0]))
-
-static inline void falcon_nic_srm_upd_evq(struct efhw_nic *nic, int evq)
-{
-	/* set up the eventq which will receive events from the SRAM module.
-	 * i.e buffer table updates and clears, TX and RX aperture table
-	 * updates */
-
-	FALCON_LOCK_DECL;
-	volatile char __iomem *efhw_kva = EFHW_KVA(nic);
-
-	EFHW_BUILD_ASSERT(SRM_UPD_EVQ_REG_OFST == SRM_UPD_EVQ_REG_KER_OFST);
-
-	__DWCHCK(SRM_UPD_EVQ_ID_LBN, SRM_UPD_EVQ_ID_WIDTH);
-	__RANGECHCK(evq, SRM_UPD_EVQ_ID_WIDTH);
-
-	/* Falcon requires 128 bit atomic access for this register */
-	FALCON_LOCK_LOCK(nic);
-	falcon_write_qq(efhw_kva + SRM_UPD_EVQ_REG_OFST,
-			((uint64_t) evq << SRM_UPD_EVQ_ID_LBN),
-			FALCON_ATOMIC_SRPM_UDP_EVQ_REG);
-	mmiowb();
-	FALCON_LOCK_UNLOCK(nic);
-}
-
-static void
-falcon_nic_evq_ptr_tbl(struct efhw_nic *nic,
-		       uint evq,	/* evq id */
-		       uint enable,	/* 1 to enable, 0 to disable */
-		       uint buf_base_id,/* Buffer table base for EVQ */
-		       uint evq_size	/* Number of events */)
-{
-	FALCON_LOCK_DECL;
-	uint i, val;
-	ulong offset;
-	volatile char __iomem *efhw_kva = EFHW_KVA(nic);
-
-	/* size must be one of the various options, otherwise we assert */
-	for (i = 0; i < N_EVENTQ_SIZES; i++) {
-		if (evq_size <= eventq_sizes[i])
-			break;
-	}
-	EFHW_ASSERT(i < N_EVENTQ_SIZES);
-
-	__DWCHCK(EVQ_BUF_BASE_ID_LBN, EVQ_BUF_BASE_ID_WIDTH);
-	__DWCHCK(EVQ_SIZE_LBN, EVQ_SIZE_WIDTH);
-	__DWCHCK(EVQ_EN_LBN, EVQ_EN_WIDTH);
-
-	__RANGECHCK(i, EVQ_SIZE_WIDTH);
-	__RANGECHCK(buf_base_id, EVQ_BUF_BASE_ID_WIDTH);
-	__RANGECHCK(1, EVQ_EN_WIDTH);
-
-	/* if !enable then only evq needs to be correct, although valid
-	 * values need to be passed in for other arguments to prevent
-	 * assertions */
-
-	val = ((i << EVQ_SIZE_LBN) | (buf_base_id << EVQ_BUF_BASE_ID_LBN) |
-	       (enable ? (1 << EVQ_EN_LBN) : 0));
-
-	EFHW_ASSERT(evq < nic->num_evqs);
-
-	offset = EVQ_PTR_TBL_CHAR_OFST;
-	offset += evq * FALCON_REGISTER128;
-
-	EFHW_TRACE("%s: evq %u en=%x:buf=%x:size=%x->%x at %lx",
-		   __func__, evq, enable, buf_base_id, evq_size, val,
-		   offset);
-
-	/* Falcon requires 128 bit atomic access for this register */
-	FALCON_LOCK_LOCK(nic);
-	falcon_write_qq(efhw_kva + offset, val, FALCON_ATOMIC_PTR_TBL_REG);
-	mmiowb();
-	FALCON_LOCK_UNLOCK(nic);
-
-	/* caller must wait for an update done event before writing any more
-	   table entries */
-
-	return;
-}
-
-void
-falcon_nic_evq_ack(struct efhw_nic *nic,
-		   uint evq,	/* evq id */
-		   uint rptr,	/* new read pointer update */
-		   bool wakeup	/* request a wakeup event if ptr's != */
-    )
-{
-	uint val;
-	ulong offset;
-	volatile char __iomem *efhw_kva = EFHW_KVA(nic);
-
-	EFHW_BUILD_ASSERT(FALCON_EVQ_CHAR == 4);
-
-	__DWCHCK(EVQ_RPTR_LBN, EVQ_RPTR_WIDTH);
-	__RANGECHCK(rptr, EVQ_RPTR_WIDTH);
-
-	val = (rptr << EVQ_RPTR_LBN);
-
-	EFHW_ASSERT(evq < nic->num_evqs);
-
-	if (evq < FALCON_EVQ_CHAR) {
-		offset = EVQ_RPTR_REG_KER_OFST;
-		offset += evq * FALCON_REGISTER128;
-
-		EFHW_ASSERT(!wakeup);	/* don't try this at home */
-	} else {
-		offset = EVQ_RPTR_REG_OFST + (FALCON_EVQ_CHAR *
-					      FALCON_REGISTER128);
-		offset += (evq - FALCON_EVQ_CHAR) * FALCON_REGISTER128;
-
-		/* nothing to do for interruptless event queues which do
-		 * not want a wakeup */
-		if (evq != FALCON_EVQ_CHAR && !wakeup)
-			return;
-	}
-
-	EFHW_TRACE("%s: %x %x %x->%x", __func__, evq, rptr, wakeup, val);
-
-	writel(val, efhw_kva + offset);
-	mmiowb();
-}
-
-/*---------------------------------------------------------------------------*/
-
-static inline void
-falcon_drv_ev(struct efhw_nic *nic, uint64_t data, uint qid)
-{
-	FALCON_LOCK_DECL;
-	volatile char __iomem *efhw_kva = EFHW_KVA(nic);
-
-	/* send an event from one driver to the other */
-	EFHW_BUILD_ASSERT(DRV_EV_REG_KER_OFST == DRV_EV_REG_OFST);
-	EFHW_BUILD_ASSERT(DRV_EV_DATA_LBN == 0);
-	EFHW_BUILD_ASSERT(DRV_EV_DATA_WIDTH == 64);
-	EFHW_BUILD_ASSERT(DRV_EV_QID_LBN == 64);
-	EFHW_BUILD_ASSERT(DRV_EV_QID_WIDTH == 12);
-
-	FALCON_LOCK_LOCK(nic);
-	falcon_write_qq(efhw_kva + DRV_EV_REG_OFST, data, qid);
-	mmiowb();
-	FALCON_LOCK_UNLOCK(nic);
-}
-
-_DEBUG_SYM_ void
-falcon_ab_timer_tbl_set(struct efhw_nic *nic,
-			uint evq,	/* timer id */
-			uint mode,	/* mode bits */
-			uint countdown /* counting value to set */)
-{
-	FALCON_LOCK_DECL;
-	uint val;
-	ulong offset;
-	volatile char __iomem *efhw_kva = EFHW_KVA(nic);
-
-	EFHW_BUILD_ASSERT(TIMER_VAL_LBN == 0);
-
-	__DWCHCK(TIMER_MODE_LBN, TIMER_MODE_WIDTH);
-	__DWCHCK(TIMER_VAL_LBN, TIMER_VAL_WIDTH);
-
-	__RANGECHCK(mode, TIMER_MODE_WIDTH);
-	__RANGECHCK(countdown, TIMER_VAL_WIDTH);
-
-	val = ((mode << TIMER_MODE_LBN) | (countdown << TIMER_VAL_LBN));
-
-	if (evq < FALCON_EVQ_CHAR) {
-		offset = TIMER_CMD_REG_KER_OFST;
-		offset += evq * EFHW_8K;	/* PAGE mapped register */
-	} else {
-		offset = TIMER_TBL_OFST;
-		offset += evq * FALCON_REGISTER128;
-	}
-	EFHW_ASSERT(evq < nic->num_evqs);
-
-	EFHW_TRACE("%s: evq %u mode %x (%s) time %x -> %08x",
-		   __func__, evq, mode,
-		   mode == 0 ? "DISABLE" :
-		   mode == 1 ? "IMMED" :
-		   mode == 2 ? (evq < 5 ? "HOLDOFF" : "RX_TRIG") :
-		   "<BAD>", countdown, val);
-
-	/* Falcon requires 128 bit atomic access for this register when
-	 * accessed from the driver. User access to timers is paged mapped
-	 */
-	FALCON_LOCK_LOCK(nic);
-	falcon_write_qq(efhw_kva + offset, val, FALCON_ATOMIC_TIMER_CMD_REG);
-	mmiowb();
-	FALCON_LOCK_UNLOCK(nic);
-	return;
-}
-
-
-/*--------------------------------------------------------------------
- *
- * Rate pacing - Low level interface
- *
- *--------------------------------------------------------------------*/
-void falcon_nic_pace(struct efhw_nic *nic, uint dmaq, uint pace)
-{
-	/* Pace specified in 2^(units of microseconds). This is the minimum
-	   additional delay imposed over and above the IPG.
-
-	   Pacing only available on the virtual interfaces
-	 */
-	FALCON_LOCK_DECL;
-	volatile char __iomem *efhw_kva = EFHW_KVA(nic);
-	ulong offset;
-
-	if (pace > 20)
-		pace = 20;	/* maxm supported value */
-
-	__DWCHCK(TX_PACE_LBN, TX_PACE_WIDTH);
-	__RANGECHCK(pace, TX_PACE_WIDTH);
-
-	switch (nic->devtype.variant) {
-	case 'A':
-		EFHW_ASSERT(dmaq >= TX_PACE_TBL_FIRST_QUEUE_A1);
-		offset = TX_PACE_TBL_A1_OFST;
-		offset += (dmaq - TX_PACE_TBL_FIRST_QUEUE_A1) * 16;
-		break;
-	case 'B':
-		/* Would be nice to assert this, but as dmaq is unsigned and
-		 * TX_PACE_TBL_FIRST_QUEUE_B0 is 0, it makes no sense
-		 * EFHW_ASSERT(dmaq >= TX_PACE_TBL_FIRST_QUEUE_B0);
-		 */
-		offset = TX_PACE_TBL_B0_OFST;
-		offset += (dmaq - TX_PACE_TBL_FIRST_QUEUE_B0) * 16;
-		break;
-	default:
-		EFHW_ASSERT(0);
-		offset = 0;
-		break;
-	}
-
-	/* Falcon requires 128 bit atomic access for this register */
-	FALCON_LOCK_LOCK(nic);
-	falcon_write_qq(efhw_kva + offset, pace, FALCON_ATOMIC_PACE_REG);
-	mmiowb();
-	FALCON_LOCK_UNLOCK(nic);
-
-	EFHW_TRACE("%s: txq %d offset=%lx pace=2^%x",
-		   __func__, dmaq, offset, pace);
-}
-
-/*--------------------------------------------------------------------
- *
- * Interrupt - Low level interface
- *
- *--------------------------------------------------------------------*/
-
-static void falcon_nic_handle_fatal_int(struct efhw_nic *nic)
-{
-	FALCON_LOCK_DECL;
-	volatile char __iomem *offset;
-	volatile char __iomem *efhw_kva = EFHW_KVA(nic);
-	uint64_t val;
-
-	offset = (efhw_kva + FATAL_INTR_REG_OFST);
-
-	/* Falcon requires 32 bit atomic access for this register */
-	FALCON_LOCK_LOCK(nic);
-	val = readl(offset);
-	FALCON_LOCK_UNLOCK(nic);
-
-	/* ?? BUG3249 - need to disable illegal address interrupt */
-	/* ?? BUG3114 - need to backport interrupt storm protection code */
-	EFHW_ERR("fatal interrupt: %s%s%s%s%s%s%s%s%s%s%s%s[%" PRIx64 "]",
-		 val & (1 << PCI_BUSERR_INT_CHAR_LBN) ? "PCI-bus-error " : "",
-		 val & (1 << SRAM_OOB_INT_CHAR_LBN) ? "SRAM-oob " : "",
-		 val & (1 << BUFID_OOB_INT_CHAR_LBN) ? "bufid-oob " : "",
-		 val & (1 << MEM_PERR_INT_CHAR_LBN) ? "int-parity " : "",
-		 val & (1 << RBUF_OWN_INT_CHAR_LBN) ? "rx-bufid-own " : "",
-		 val & (1 << TBUF_OWN_INT_CHAR_LBN) ? "tx-bufid-own " : "",
-		 val & (1 << RDESCQ_OWN_INT_CHAR_LBN) ? "rx-desc-own " : "",
-		 val & (1 << TDESCQ_OWN_INT_CHAR_LBN) ? "tx-desc-own " : "",
-		 val & (1 << EVQ_OWN_INT_CHAR_LBN) ? "evq-own " : "",
-		 val & (1 << EVFF_OFLO_INT_CHAR_LBN) ? "evq-fifo " : "",
-		 val & (1 << ILL_ADR_INT_CHAR_LBN) ? "ill-addr " : "",
-		 val & (1 << SRM_PERR_INT_CHAR_LBN) ? "sram-parity " : "", val);
-}
-
-static void falcon_nic_interrupt_hw_enable(struct efhw_nic *nic)
-{
-	FALCON_LOCK_DECL;
-	uint val;
-	volatile char __iomem *offset;
-	volatile char __iomem *efhw_kva = EFHW_KVA(nic);
-
-	EFHW_BUILD_ASSERT(DRV_INT_EN_CHAR_WIDTH == 1);
-
-	if (nic->flags & NIC_FLAG_NO_INTERRUPT)
-		return;
-
-	offset = (efhw_kva + INT_EN_REG_CHAR_OFST);
-	val = 1 << DRV_INT_EN_CHAR_LBN;
-
-	EFHW_NOTICE("%s: %x -> %x", __func__, (int)(offset - efhw_kva),
-		    val);
-
-	/* Falcon requires 128 bit atomic access for this register */
-	FALCON_LOCK_LOCK(nic);
-	falcon_write_qq(offset, val, FALCON_ATOMIC_INT_EN_REG);
-	mmiowb();
-	FALCON_LOCK_UNLOCK(nic);
-}
-
-static void falcon_nic_interrupt_hw_disable(struct efhw_nic *nic)
-{
-	FALCON_LOCK_DECL;
-	volatile char __iomem *offset;
-	volatile char __iomem *efhw_kva = EFHW_KVA(nic);
-
-	EFHW_BUILD_ASSERT(SRAM_PERR_INT_KER_WIDTH == 1);
-	EFHW_BUILD_ASSERT(DRV_INT_EN_KER_LBN == 0);
-	EFHW_BUILD_ASSERT(SRAM_PERR_INT_CHAR_WIDTH == 1);
-	EFHW_BUILD_ASSERT(DRV_INT_EN_CHAR_LBN == 0);
-	EFHW_BUILD_ASSERT(SRAM_PERR_INT_KER_LBN == SRAM_PERR_INT_CHAR_LBN);
-	EFHW_BUILD_ASSERT(DRV_INT_EN_KER_LBN == DRV_INT_EN_CHAR_LBN);
-
-	if (nic->flags & NIC_FLAG_NO_INTERRUPT)
-		return;
-
-	offset = (efhw_kva + INT_EN_REG_CHAR_OFST);
-
-	EFHW_NOTICE("%s: %x -> 0", __func__, (int)(offset - efhw_kva));
-
-	/* Falcon requires 128 bit atomic access for this register */
-	FALCON_LOCK_LOCK(nic);
-	falcon_write_qq(offset, 0, FALCON_ATOMIC_INT_EN_REG);
-	mmiowb();
-	FALCON_LOCK_UNLOCK(nic);
-}
-
-static void falcon_nic_irq_addr_set(struct efhw_nic *nic, dma_addr_t dma_addr)
-{
-	FALCON_LOCK_DECL;
-	volatile char __iomem *offset;
-	volatile char __iomem *efhw_kva = EFHW_KVA(nic);
-
-	offset = (efhw_kva + INT_ADR_REG_CHAR_OFST);
-
-	EFHW_NOTICE("%s: %x -> " DMA_ADDR_T_FMT, __func__,
-		    (int)(offset - efhw_kva), dma_addr);
-
-	/* Falcon requires 128 bit atomic access for this register */
-	FALCON_LOCK_LOCK(nic);
-	falcon_write_qq(offset, dma_addr, FALCON_ATOMIC_INT_ADR_REG);
-	mmiowb();
-	FALCON_LOCK_UNLOCK(nic);
-}
-
-
-/*--------------------------------------------------------------------
- *
- * RXDP - low level interface
- *
- *--------------------------------------------------------------------*/
-
-void
-falcon_nic_set_rx_usr_buf_size(struct efhw_nic *nic, int usr_buf_bytes)
-{
-	FALCON_LOCK_DECL;
-	volatile char __iomem *efhw_kva = EFHW_KVA(nic);
-	uint64_t val, val2, usr_buf_size = usr_buf_bytes / 32;
-	int rubs_lbn, rubs_width, roec_lbn;
-
-	EFHW_BUILD_ASSERT(RX_CFG_REG_OFST == RX_CFG_REG_KER_OFST);
-
-	switch (nic->devtype.variant) {
-	default:
-		EFHW_ASSERT(0);
-		/* Fall-through to avoid compiler warnings. */
-	case 'A':
-		rubs_lbn = RX_USR_BUF_SIZE_A1_LBN;
-		rubs_width = RX_USR_BUF_SIZE_A1_WIDTH;
-		roec_lbn = RX_OWNERR_CTL_A1_LBN;
-		break;
-	case 'B':
-		rubs_lbn = RX_USR_BUF_SIZE_B0_LBN;
-		rubs_width = RX_USR_BUF_SIZE_B0_WIDTH;
-		roec_lbn = RX_OWNERR_CTL_B0_LBN;
-		break;
-	}
-
-	__DWCHCK(rubs_lbn, rubs_width);
-	__QWCHCK(roec_lbn, 1);
-	__RANGECHCK(usr_buf_size, rubs_width);
-
-	/* Falcon requires 128 bit atomic access for this register */
-	FALCON_LOCK_LOCK(nic);
-	falcon_read_qq(efhw_kva + RX_CFG_REG_OFST, &val, &val2);
-
-	val &= ~((__FALCON_MASK64(rubs_width)) << rubs_lbn);
-	val |= (usr_buf_size << rubs_lbn);
-
-	/* shouldn't be needed for a production driver */
-	val |= ((uint64_t) 1 << roec_lbn);
-
-	falcon_write_qq(efhw_kva + RX_CFG_REG_OFST, val, val2);
-	mmiowb();
-	FALCON_LOCK_UNLOCK(nic);
-}
-EXPORT_SYMBOL(falcon_nic_set_rx_usr_buf_size);
-
-
-/*--------------------------------------------------------------------
- *
- * TXDP - low level interface
- *
- *--------------------------------------------------------------------*/
-
-_DEBUG_SYM_ void falcon_nic_tx_cfg(struct efhw_nic *nic, int unlocked)
-{
-	FALCON_LOCK_DECL;
-	volatile char __iomem *efhw_kva = EFHW_KVA(nic);
-	uint64_t val1, val2;
-
-	EFHW_BUILD_ASSERT(TX_CFG_REG_OFST == TX_CFG_REG_KER_OFST);
-	__DWCHCK(TX_OWNERR_CTL_LBN, TX_OWNERR_CTL_WIDTH);
-	__DWCHCK(TX_NON_IP_DROP_DIS_LBN, TX_NON_IP_DROP_DIS_WIDTH);
-
-	FALCON_LOCK_LOCK(nic);
-	falcon_read_qq(efhw_kva + TX_CFG_REG_OFST, &val1, &val2);
-
-	/* Will flag fatal interrupts on owner id errors. This should not be
-	   on for production code because there is otherwise a denial of
-	   serivce attack possible */
-	val1 |= (1 << TX_OWNERR_CTL_LBN);
-
-	/* Setup user queue TCP/UDP only packet security */
-	if (unlocked)
-		val1 |= (1 << TX_NON_IP_DROP_DIS_LBN);
-	else
-		val1 &= ~(1 << TX_NON_IP_DROP_DIS_LBN);
-
-	falcon_write_qq(efhw_kva + TX_CFG_REG_OFST, val1, val2);
-	mmiowb();
-	FALCON_LOCK_UNLOCK(nic);
-}
-
-/*--------------------------------------------------------------------
- *
- * Random thresholds - Low level interface (Would like these to be op
- * defaults wherever possible)
- *
- *--------------------------------------------------------------------*/
-
-void falcon_nic_pace_cfg(struct efhw_nic *nic, int fb_base, int bin_thresh)
-{
-	FALCON_LOCK_DECL;
-	volatile char __iomem *efhw_kva = EFHW_KVA(nic);
-	unsigned offset = 0;
-	uint64_t val;
-
-	__DWCHCK(TX_PACE_FB_BASE_LBN, TX_PACE_FB_BASE_WIDTH);
-	__DWCHCK(TX_PACE_BIN_TH_LBN, TX_PACE_BIN_TH_WIDTH);
-
-	switch (nic->devtype.variant) {
-	case 'A':  offset = TX_PACE_REG_A1_OFST;  break;
-	case 'B':  offset = TX_PACE_REG_B0_OFST;  break;
-	default:   EFHW_ASSERT(0);                break;
-	}
-
-	val = (0x15 << TX_PACE_SB_NOTAF_LBN);
-	val |= (0xb << TX_PACE_SB_AF_LBN);
-
-	val |= ((fb_base & __FALCON_MASK64(TX_PACE_FB_BASE_WIDTH)) <<
-		 TX_PACE_FB_BASE_LBN);
-	val |= ((bin_thresh & __FALCON_MASK64(TX_PACE_BIN_TH_WIDTH)) <<
-		 TX_PACE_BIN_TH_LBN);
-
-	/* Falcon requires 128 bit atomic access for this register */
-	FALCON_LOCK_LOCK(nic);
-	falcon_write_qq(efhw_kva + offset, val, 0);
-	mmiowb();
-	FALCON_LOCK_UNLOCK(nic);
-}
-
-
-/**********************************************************************
- * Implementation of the HAL. ********************************************
- **********************************************************************/
-
-/*----------------------------------------------------------------------------
- *
- * Initialisation and configuration discovery
- *
- *---------------------------------------------------------------------------*/
-
-static int falcon_nic_init_irq_channel(struct efhw_nic *nic, int enable)
-{
-	/* create a buffer for the irq channel */
-	int rc;
-
-	if (enable) {
-		rc = efhw_iopage_alloc(nic, &nic->irq_iobuff);
-		if (rc < 0)
-			return rc;
-
-		falcon_nic_irq_addr_set(nic,
-				efhw_iopage_dma_addr(&nic->irq_iobuff));
-	} else {
-		if (efhw_iopage_is_valid(&nic->irq_iobuff))
-			efhw_iopage_free(nic, &nic->irq_iobuff);
-
-		efhw_iopage_mark_invalid(&nic->irq_iobuff);
-		falcon_nic_irq_addr_set(nic, 0);
-	}
-
-	EFHW_TRACE("%s: %lx %sable", __func__,
-		   (unsigned long) efhw_iopage_dma_addr(&nic->irq_iobuff),
-		   enable ? "en" : "dis");
-
-	return 0;
-}
-
-static void falcon_nic_close_hardware(struct efhw_nic *nic)
-{
-	/* check we are in possession of some hardware */
-	if (!efhw_nic_have_hw(nic))
-		return;
-
-	falcon_nic_init_irq_channel(nic, 0);
-	falcon_nic_filter_dtor(nic);
-
-	EFHW_NOTICE("%s:", __func__);
-}
-
-static int
-falcon_nic_init_hardware(struct efhw_nic *nic,
-			 struct efhw_ev_handler *ev_handlers,
-			 const uint8_t *mac_addr, int non_irq_evq)
-{
-	int rc;
-
-	/* header sanity checks */
-	FALCON_ASSERT_VALID();
-
-	/* Initialise supporting modules */
-	rc = falcon_nic_filter_ctor(nic);
-	if (rc < 0)
-		return rc;
-
-#if FALCON_USE_SHADOW_BUFFER_TABLE
-	CI_ZERO_ARRAY(_falcon_buffer_table, FALCON_BUFFER_TBL_NUM);
-#endif
-
-	/* Initialise the top level hardware blocks */
-	memcpy(nic->mac_addr, mac_addr, ETH_ALEN);
-
-	EFHW_TRACE("%s:", __func__);
-
-	/* nic.c:efhw_nic_init marks all the interrupt units as unused.
-
-	   ?? TODO we should be able to request the non-interrupting event
-	   queue and the net driver's (for a net driver that is using libefhw)
-	   additional RSS queues here.
-
-	   Result would be that that net driver could call
-	   nic.c:efhw_nic_allocate_common_hardware_resources() and that the
-	   IFDEF FALCON's can be removed from
-	   nic.c:efhw_nic_allocate_common_hardware_resources()
-	 */
-	nic->irq_unit = INT_EN_REG_CHAR_OFST;
-
-	/*****************************************************************
-	 * The rest of this function deals with initialization of the NICs
-	 * hardware (as opposed to the initialization of the
-	 * struct efhw_nic data structure */
-
-	/* char driver grabs SRM events onto the non interrupting
-	 * event queue */
-	falcon_nic_srm_upd_evq(nic, non_irq_evq);
-
-	/* RXDP tweaks */
-
-	/* ?? bug2396 rx_cfg should be ok so long as the net driver
-	 * always pushes buffers big enough for the link MTU */
-
-	/* set the RX buffer cutoff size to be the same as PAGE_SIZE.
-	 * Use this value when we think that there will be a lot of
-	 * jumbo frames.
-	 *
-	 * The default value 1600 is useful when packets are small,
-	 * but would means that jumbo frame RX queues would need more
-	 * descriptors pushing */
-	falcon_nic_set_rx_usr_buf_size(nic, FALCON_RX_USR_BUF_SIZE);
-
-	/* TXDP tweaks */
-	/* ?? bug2396 looks ok */
-	falcon_nic_tx_cfg(nic, /*unlocked(for non-UDP/TCP)= */ 0);
-	falcon_nic_pace_cfg(nic, 4, 2);
-
-	/* ?? bug2396
-	 * netdriver must load first or else must RMW this register */
-	falcon_nic_rx_filter_ctl_set(nic, RX_FILTER_CTL_SRCH_LIMIT_TCP_FULL,
-				     RX_FILTER_CTL_SRCH_LIMIT_TCP_WILD,
-				     RX_FILTER_CTL_SRCH_LIMIT_UDP_FULL,
-				     RX_FILTER_CTL_SRCH_LIMIT_UDP_WILD);
-
-	if (!(nic->flags & NIC_FLAG_NO_INTERRUPT)) {
-		rc = efhw_keventq_ctor(nic, FALCON_EVQ_CHAR,
-				       &nic->interrupting_evq, ev_handlers);
-		if (rc < 0) {
-			EFHW_ERR("%s: efhw_keventq_ctor() failed (%d) evq=%d",
-				 __func__, rc, FALCON_EVQ_CHAR);
-			return rc;
-		}
-	}
-	rc = efhw_keventq_ctor(nic, non_irq_evq,
-			       &nic->non_interrupting_evq, NULL);
-	if (rc < 0) {
-		EFHW_ERR("%s: efhw_keventq_ctor() failed (%d) evq=%d",
-			 __func__, rc, non_irq_evq);
-		return rc;
-	}
-
-	/* allocate IRQ channel */
-	rc = falcon_nic_init_irq_channel(nic, 1);
-	/* ignore failure at user-level for eftest */
-	if ((rc < 0) && !(nic->options & NIC_OPT_EFTEST))
-		return rc;
-
-	return 0;
-}
-
-/*--------------------------------------------------------------------
- *
- * Interrupt
- *
- *--------------------------------------------------------------------*/
-
-static void
-falcon_nic_interrupt_enable(struct efhw_nic *nic)
-{
-	struct efhw_keventq *q;
-	unsigned rdptr;
-
-	if (nic->flags & NIC_FLAG_NO_INTERRUPT)
-		return;
-
-	/* Enable driver interrupts */
-	EFHW_NOTICE("%s: enable master interrupt", __func__);
-	falcon_nic_interrupt_hw_enable(nic);
-
-	/* An interrupting eventq must start of day ack its read pointer */
-	q = &nic->interrupting_evq;
-	rdptr = EFHW_EVENT_OFFSET(q, q, 1) / sizeof(efhw_event_t);
-	falcon_nic_evq_ack(nic, FALCON_EVQ_CHAR, rdptr, false);
-	EFHW_NOTICE("%s: ACK evq[%d]:%x", __func__,
-		    FALCON_EVQ_CHAR, rdptr);
-}
-
-static void falcon_nic_interrupt_disable(struct efhw_nic *nic)
-{
-	/* NB. No need to check for NIC_FLAG_NO_INTERRUPT, as
-	 ** falcon_nic_interrupt_hw_disable() will do it. */
-	falcon_nic_interrupt_hw_disable(nic);
-}
-
-static void
-falcon_nic_set_interrupt_moderation(struct efhw_nic *nic, int evq,
-				    uint32_t val)
-{
-	if (evq < 0)
-		evq = FALCON_EVQ_CHAR;
-
-	falcon_ab_timer_tbl_set(nic, evq, TIMER_MODE_INT_HLDOFF, val / 5);
-}
-
-static inline void legacy_irq_ack(struct efhw_nic *nic)
-{
-	EFHW_ASSERT(!(nic->flags & NIC_FLAG_NO_INTERRUPT));
-
-	if (!(nic->flags & NIC_FLAG_MSI)) {
-		writel(1, EFHW_KVA(nic) + INT_ACK_REG_CHAR_A1_OFST);
-		mmiowb();
-		/* ?? FIXME: We should be doing a read here to ensure IRQ is
-		 * thoroughly acked before we return from ISR. */
-	}
-}
-
-static int falcon_nic_interrupt(struct efhw_nic *nic)
-{
-	uint32_t *syserr_ptr =
-	    (uint32_t *) efhw_iopage_ptr(&nic->irq_iobuff);
-	int handled = 0;
-	int done_ack = 0;
-
-	EFHW_ASSERT(!(nic->flags & NIC_FLAG_NO_INTERRUPT));
-	EFHW_ASSERT(syserr_ptr);
-
-	/* FIFO fill level interrupt - just log it. */
-	if (unlikely(*(syserr_ptr + (DW0_OFST / 4)))) {
-		EFHW_WARN("%s: *** FIFO *** %x", __func__,
-			  *(syserr_ptr + (DW0_OFST / 4)));
-		*(syserr_ptr + (DW0_OFST / 4)) = 0;
-		handled++;
-	}
-
-	/* Fatal interrupts. */
-	if (unlikely(*(syserr_ptr + (DW2_OFST / 4)))) {
-		*(syserr_ptr + (DW2_OFST / 4)) = 0;
-		falcon_nic_handle_fatal_int(nic);
-		handled++;
-	}
-
-	/* Event queue interrupt.  For legacy interrupts we have to check
-	 * that the interrupt is for us, because it could be shared. */
-	if (*(syserr_ptr + (DW1_OFST / 4))) {
-		*(syserr_ptr + (DW1_OFST / 4)) = 0;
-		/* ACK must come before callback to handler fn. */
-		legacy_irq_ack(nic);
-		done_ack = 1;
-		handled++;
-		if (nic->irq_handler)
-			nic->irq_handler(nic, 0);
-	}
-
-	if (unlikely(!done_ack)) {
-		if (!handled)
-			/* Shared interrupt line (hopefully). */
-			return 0;
-		legacy_irq_ack(nic);
-	}
-
-	EFHW_TRACE("%s: handled %d", __func__, handled);
-	return 1;
-}
-
-/*--------------------------------------------------------------------
- *
- * Event Management - and SW event posting
- *
- *--------------------------------------------------------------------*/
-
-static void
-falcon_nic_event_queue_enable(struct efhw_nic *nic, uint evq, uint evq_size,
-			      dma_addr_t q_base_addr,	/* not used */
-			      uint buf_base_id, int interrupting)
-{
-	EFHW_ASSERT(nic);
-
-	/* Whether or not queue has an interrupt depends on
-	 * instance number and h/w variant, so [interrupting] is
-	 * ignored.
-	 */
-	falcon_ab_timer_tbl_set(nic, evq, 0/*disable*/, 0);
-
-	falcon_nic_evq_ptr_tbl(nic, evq, 1, buf_base_id, evq_size);
-	EFHW_TRACE("%s: enable evq %u size %u", __func__, evq, evq_size);
-}
-
-static void
-falcon_nic_event_queue_disable(struct efhw_nic *nic, uint evq, int timer_only)
-{
-	EFHW_ASSERT(nic);
-
-	falcon_ab_timer_tbl_set(nic, evq, 0 /* disable */ , 0);
-
-	if (!timer_only)
-		falcon_nic_evq_ptr_tbl(nic, evq, 0, 0, 0);
-	EFHW_TRACE("%s: disenable evq %u", __func__, evq);
-}
-
-static void
-falcon_nic_wakeup_request(struct efhw_nic *nic, dma_addr_t q_base_addr,
-			  int next_i, int evq)
-{
-	EFHW_ASSERT(evq > FALCON_EVQ_CHAR);
-	falcon_nic_evq_ack(nic, evq, next_i, true);
-	EFHW_TRACE("%s: evq %d next_i %d", __func__, evq, next_i);
-}
-
-static void falcon_nic_sw_event(struct efhw_nic *nic, int data, int evq)
-{
-	uint64_t ev_data = data;
-
-	ev_data &= ~FALCON_EVENT_CODE_MASK;
-	ev_data |= FALCON_EVENT_CODE_SW;
-
-	falcon_drv_ev(nic, ev_data, evq);
-	EFHW_NOTICE("%s: evq[%d]->%x", __func__, evq, data);
-}
-
-
-/*--------------------------------------------------------------------
- *
- * Buffer table - helpers
- *
- *--------------------------------------------------------------------*/
-
-#define FALCON_LAZY_COMMIT_HWM (FALCON_BUFFER_UPD_MAX - 16)
-
-/* Note re.:
- *  falcon_nic_buffer_table_lazy_commit(struct efhw_nic *nic)
- *  falcon_nic_buffer_table_update_poll(struct efhw_nic *nic)
- *  falcon_nic_buffer_table_confirm(struct efhw_nic *nic)
- * -- these are no-ops in the user-level driver because it would need to
- * coordinate with the real driver on the number of outstanding commits.
- *
- * An exception is made for eftest apps, which manage the hardware without
- * using the char driver.
- */
-
-static inline void falcon_nic_buffer_table_lazy_commit(struct efhw_nic *nic)
-{
-	/* Do nothing if operating in synchronous mode. */
-	if (!nic->irq_handler)
-		return;
-}
-
-static inline void falcon_nic_buffer_table_update_poll(struct efhw_nic *nic)
-{
-	FALCON_LOCK_DECL;
-	int count = 0, rc = 0;
-
-	/* We can be called here early days */
-	if (!nic->irq_handler)
-		return;
-
-	/* If we need to gather buffer update events then poll the
-	   non-interrupting event queue */
-
-	/* For each _buffer_table_commit there will be an update done
-	   event. We don't keep track of how many buffers each commit has
-	   committed, just make sure that all the expected events have been
-	   gathered */
-	FALCON_LOCK_LOCK(nic);
-
-	EFHW_TRACE("%s: %d", __func__, nic->buf_commit_outstanding);
-
-	while (nic->buf_commit_outstanding > 0) {
-		/* we're not expecting to handle any events that require
-		 * upcalls into the core driver */
-		struct efhw_ev_handler handler;
-		memset(&handler, 0, sizeof(handler));
-		nic->non_interrupting_evq.ev_handlers = &handler;
-		rc = efhw_keventq_poll(nic, &nic->non_interrupting_evq);
-		nic->non_interrupting_evq.ev_handlers = NULL;
-
-		if (rc < 0) {
-			EFHW_ERR("%s: poll ERROR (%d:%d) ***** ",
-				 __func__, rc,
-				 nic->buf_commit_outstanding);
-			goto out;
-		}
-
-		FALCON_LOCK_UNLOCK(nic);
-
-		if (count++)
-			udelay(1);
-
-		if (count > 1000) {
-			EFHW_WARN("%s: poll Timeout ***** (%d)", __func__,
-				  nic->buf_commit_outstanding);
-			nic->buf_commit_outstanding = 0;
-			return;
-		}
-		FALCON_LOCK_LOCK(nic);
-	}
-
-out:
-	FALCON_LOCK_UNLOCK(nic);
-	return;
-}
-
-void falcon_nic_buffer_table_confirm(struct efhw_nic *nic)
-{
-	/* confirm buffer table updates - should be used for items where
-	   loss of data would be unacceptable. E.g for the buffers that back
-	   an event or DMA queue */
-	FALCON_LOCK_DECL;
-
-	/* Do nothing if operating in synchronous mode. */
-	if (!nic->irq_handler)
-		return;
-
-	FALCON_LOCK_LOCK(nic);
-
-	_falcon_nic_buffer_table_commit(nic);
-
-	FALCON_LOCK_UNLOCK(nic);
-
-	falcon_nic_buffer_table_update_poll(nic);
-}
-
-/*--------------------------------------------------------------------
- *
- * Buffer table - API
- *
- *--------------------------------------------------------------------*/
-
-static void
-falcon_nic_buffer_table_clear(struct efhw_nic *nic, int buffer_id, int num)
-{
-	FALCON_LOCK_DECL;
-	FALCON_LOCK_LOCK(nic);
-	_falcon_nic_buffer_table_clear(nic, buffer_id, num);
-	FALCON_LOCK_UNLOCK(nic);
-}
-
-static void
-falcon_nic_buffer_table_set(struct efhw_nic *nic, dma_addr_t dma_addr,
-			    uint bufsz, uint region,
-			    int own_id, int buffer_id)
-{
-	FALCON_LOCK_DECL;
-
-	EFHW_ASSERT(region < FALCON_REGION_NUM);
-
-	EFHW_ASSERT((bufsz == EFHW_4K) ||
-		    (bufsz == EFHW_8K && FALCON_BUFFER_TABLE_FULL_MODE));
-
-	falcon_nic_buffer_table_update_poll(nic);
-
-	FALCON_LOCK_LOCK(nic);
-
-	_falcon_nic_buffer_table_set(nic, dma_addr, bufsz, region, own_id,
-				     buffer_id);
-
-	falcon_nic_buffer_table_lazy_commit(nic);
-
-	FALCON_LOCK_UNLOCK(nic);
-}
-
-void
-falcon_nic_buffer_table_set_n(struct efhw_nic *nic, int buffer_id,
-			      dma_addr_t dma_addr, uint bufsz, uint region,
-			      int n_pages, int own_id)
-{
-	/* used to set up a contiguous range of buffers */
-	FALCON_LOCK_DECL;
-
-	EFHW_ASSERT(region < FALCON_REGION_NUM);
-
-	EFHW_ASSERT((bufsz == EFHW_4K) ||
-		    (bufsz == EFHW_8K && FALCON_BUFFER_TABLE_FULL_MODE));
-
-	while (n_pages--) {
-
-		falcon_nic_buffer_table_update_poll(nic);
-
-		FALCON_LOCK_LOCK(nic);
-
-		_falcon_nic_buffer_table_set(nic, dma_addr, bufsz, region,
-					     own_id, buffer_id++);
-
-		falcon_nic_buffer_table_lazy_commit(nic);
-
-		FALCON_LOCK_UNLOCK(nic);
-
-		dma_addr += bufsz;
-	}
-}
-
-/*--------------------------------------------------------------------
- *
- * DMA Queues - mid level API
- *
- *--------------------------------------------------------------------*/
-
-#if BUG5302_WORKAROUND
-
-/* Tx queues can get stuck if the software write pointer is set to an index
- * beyond the configured size of the queue, such that they will not flush.
- * This code can be run before attempting a flush; it will detect the bogus
- * value and reset it.  This fixes most instances of this problem, although
- * sometimes it does not work, or we may not detect it in the first place,
- * if the out-of-range value was replaced by an in-range value earlier.
- * (In those cases we have to apply a bigger hammer later, if we see that
- * the queue is still not flushing.)
- */
-static void
-falcon_check_for_bogus_tx_dma_wptr(struct efhw_nic *nic, uint dmaq)
-{
-	FALCON_LOCK_DECL;
-	uint64_t val_low64, val_high64;
-	uint64_t size, hwptr, swptr, val;
-	volatile char __iomem *efhw_kva = EFHW_KVA(nic);
-	ulong offset = falcon_dma_tx_q_offset(nic, dmaq);
-
-	/* Falcon requires 128 bit atomic access for this register */
-	FALCON_LOCK_LOCK(nic);
-	falcon_read_qq(efhw_kva + offset, &val_low64, &val_high64);
-	FALCON_LOCK_UNLOCK(nic);
-
-	size = (val_low64 >> TX_DESCQ_SIZE_LBN)
-	    & __FALCON_MASK64(TX_DESCQ_SIZE_WIDTH);
-	size = (1 << size) * 512;
-	hwptr = (val_high64 >> __DW3(TX_DESCQ_HW_RPTR_LBN))
-	    & __FALCON_MASK64(TX_DESCQ_HW_RPTR_WIDTH);
-	swptr = (val_low64 >> TX_DESCQ_SW_WPTR_LBN)
-	    & __FALCON_MASK64(__LW2(TX_DESCQ_SW_WPTR_LBN));
-	val = (val_high64)
-	    &
-	    __FALCON_MASK64(__DW3
-			    (TX_DESCQ_SW_WPTR_LBN + TX_DESCQ_SW_WPTR_WIDTH));
-	val = val << __LW2(TX_DESCQ_SW_WPTR_LBN);
-	swptr = swptr | val;
-
-	if (swptr >= size) {
-		EFHW_WARN("Resetting bad write pointer for TXQ[%d]", dmaq);
-		writel((uint32_t) ((hwptr + 0) & (size - 1)),
-		       efhw_kva + falcon_tx_dma_page_addr(dmaq) + 12);
-		mmiowb();
-	}
-}
-
-/* Here's that "bigger hammer": we reset all the pointers (hardware read,
- * hardware descriptor cache read, software write) to zero.
- */
-void falcon_clobber_tx_dma_ptrs(struct efhw_nic *nic, uint dmaq)
-{
-	FALCON_LOCK_DECL;
-	uint64_t val_low64, val_high64;
-	volatile char __iomem *efhw_kva = EFHW_KVA(nic);
-	ulong offset = falcon_dma_tx_q_offset(nic, dmaq);
-
-	EFHW_WARN("Recovering stuck TXQ[%d]", dmaq);
-	FALCON_LOCK_LOCK(nic);
-	falcon_read_qq(efhw_kva + offset, &val_low64, &val_high64);
-	val_high64 &= ~(__FALCON_MASK64(TX_DESCQ_HW_RPTR_WIDTH)
-			<< __DW3(TX_DESCQ_HW_RPTR_LBN));
-	val_high64 &= ~(__FALCON_MASK64(TX_DC_HW_RPTR_WIDTH)
-			<< __DW3(TX_DC_HW_RPTR_LBN));
-	falcon_write_qq(efhw_kva + offset, val_low64, val_high64);
-	mmiowb();
-	writel(0, efhw_kva + falcon_tx_dma_page_addr(dmaq) + 12);
-	mmiowb();
-	FALCON_LOCK_UNLOCK(nic);
-}
-
-#endif
-
-static inline int
-__falcon_really_flush_tx_dma_channel(struct efhw_nic *nic, uint dmaq)
-{
-	FALCON_LOCK_DECL;
-	volatile char __iomem *efhw_kva = EFHW_KVA(nic);
-	uint val;
-
-	EFHW_BUILD_ASSERT(TX_FLUSH_DESCQ_REG_KER_OFST ==
-			  TX_FLUSH_DESCQ_REG_OFST);
-
-	__DWCHCK(TX_FLUSH_DESCQ_CMD_LBN, TX_FLUSH_DESCQ_CMD_WIDTH);
-	__DWCHCK(TX_FLUSH_DESCQ_LBN, TX_FLUSH_DESCQ_WIDTH);
-	__RANGECHCK(dmaq, TX_FLUSH_DESCQ_WIDTH);
-
-	val = ((1 << TX_FLUSH_DESCQ_CMD_LBN) | (dmaq << TX_FLUSH_DESCQ_LBN));
-
-	EFHW_TRACE("TX DMA flush[%d]", dmaq);
-
-#if BUG5302_WORKAROUND
-	falcon_check_for_bogus_tx_dma_wptr(nic, dmaq);
-#endif
-
-	/* Falcon requires 128 bit atomic access for this register */
-	FALCON_LOCK_LOCK(nic);
-	falcon_write_qq(efhw_kva + TX_FLUSH_DESCQ_REG_OFST,
-			val, FALCON_ATOMIC_TX_FLUSH_DESCQ);
-
-	mmiowb();
-	FALCON_LOCK_UNLOCK(nic);
-	return 0;
-}
-
-static inline int
-__falcon_is_tx_dma_channel_flushed(struct efhw_nic *nic, uint dmaq)
-{
-	FALCON_LOCK_DECL;
-	uint64_t val_low64, val_high64;
-	uint64_t enable, flush_pending;
-	volatile char __iomem *efhw_kva = EFHW_KVA(nic);
-	ulong offset = falcon_dma_tx_q_offset(nic, dmaq);
-
-	/* Falcon requires 128 bit atomic access for this register */
-	FALCON_LOCK_LOCK(nic);
-	falcon_read_qq(efhw_kva + offset, &val_low64, &val_high64);
-	FALCON_LOCK_UNLOCK(nic);
-
-	/* should see one of three values for these 2 bits
-	 *   1, queue enabled no flush pending
-	 *	- i.e. first flush request
-	 *   2, queue enabled, flush pending
-	 *	- i.e. request to reflush before flush finished
-	 *   3, queue disabled (no flush pending)
-	 *	- flush complete
-	 */
-	__DWCHCK(TX_DESCQ_FLUSH_LBN, TX_DESCQ_FLUSH_WIDTH);
-	__DW3CHCK(TX_DESCQ_EN_LBN, TX_DESCQ_EN_WIDTH);
-	enable = val_high64 & (1 << __DW3(TX_DESCQ_EN_LBN));
-	flush_pending = val_low64 & (1 << TX_DESCQ_FLUSH_LBN);
-
-	if (enable && !flush_pending)
-		return 0;
-
-	EFHW_TRACE("%d, %s: %s, %sflush pending", dmaq, __func__,
-		   enable ? "enabled" : "disabled",
-		   flush_pending ? "" : "NO ");
-	/* still in progress */
-	if (enable && flush_pending)
-		return -EALREADY;
-
-	return -EAGAIN;
-}
-
-static int falcon_flush_tx_dma_channel(struct efhw_nic *nic, uint dmaq)
-{
-	int rc;
-	rc = __falcon_is_tx_dma_channel_flushed(nic, dmaq);
-	if (rc < 0) {
-		EFHW_WARN("%s: failed %d", __func__, rc);
-		return rc;
-	}
-	return __falcon_really_flush_tx_dma_channel(nic, dmaq);
-}
-
-static int
-__falcon_really_flush_rx_dma_channel(struct efhw_nic *nic, uint dmaq)
-{
-	FALCON_LOCK_DECL;
-	volatile char __iomem *efhw_kva = EFHW_KVA(nic);
-	uint val;
-
-	EFHW_BUILD_ASSERT(RX_FLUSH_DESCQ_REG_KER_OFST ==
-			  RX_FLUSH_DESCQ_REG_OFST);
-
-	__DWCHCK(RX_FLUSH_DESCQ_CMD_LBN, RX_FLUSH_DESCQ_CMD_WIDTH);
-	__DWCHCK(RX_FLUSH_DESCQ_LBN, RX_FLUSH_DESCQ_WIDTH);
-	__RANGECHCK(dmaq, RX_FLUSH_DESCQ_WIDTH);
-
-	val = ((1 << RX_FLUSH_DESCQ_CMD_LBN) | (dmaq << RX_FLUSH_DESCQ_LBN));
-
-	EFHW_TRACE("RX DMA flush[%d]", dmaq);
-
-	/* Falcon requires 128 bit atomic access for this register */
-	FALCON_LOCK_LOCK(nic);
-	falcon_write_qq(efhw_kva + RX_FLUSH_DESCQ_REG_OFST, val,
-			FALCON_ATOMIC_RX_FLUSH_DESCQ);
-	mmiowb();
-	FALCON_LOCK_UNLOCK(nic);
-	return 0;
-}
-
-static inline int
-__falcon_is_rx_dma_channel_flushed(struct efhw_nic *nic, uint dmaq)
-{
-	FALCON_LOCK_DECL;
-	uint64_t val;
-	volatile char __iomem *efhw_kva = EFHW_KVA(nic);
-	ulong offset = falcon_dma_rx_q_offset(nic, dmaq);
-
-	/* Falcon requires 128 bit atomic access for this register */
-	FALCON_LOCK_LOCK(nic);
-	falcon_read_q(efhw_kva + offset, &val);
-	FALCON_LOCK_UNLOCK(nic);
-
-	__DWCHCK(RX_DESCQ_EN_LBN, RX_DESCQ_EN_WIDTH);
-
-	/* is it enabled? */
-	return (val & (1 << RX_DESCQ_EN_LBN))
-	    ? 0 : -EAGAIN;
-}
-
-static int falcon_flush_rx_dma_channel(struct efhw_nic *nic, uint dmaq)
-{
-	int rc;
-	rc = __falcon_is_rx_dma_channel_flushed(nic, dmaq);
-	if (rc < 0) {
-		EFHW_ERR("%s: failed %d", __func__, rc);
-		return rc;
-	}
-	return __falcon_really_flush_rx_dma_channel(nic, dmaq);
-}
-
-/*--------------------------------------------------------------------
- *
- * Falcon specific event callbacks
- *
- *--------------------------------------------------------------------*/
-
-int
-falcon_handle_char_event(struct efhw_nic *nic, struct efhw_ev_handler *h,
-			 efhw_event_t *ev)
-{
-	EFHW_TRACE("DRIVER EVENT: "FALCON_EVENT_FMT,
-		   FALCON_EVENT_PRI_ARG(*ev));
-
-	switch (FALCON_EVENT_DRIVER_SUBCODE(ev)) {
-
-	case TX_DESCQ_FLS_DONE_EV_DECODE:
-		EFHW_TRACE("TX[%d] flushed",
-			   (int)FALCON_EVENT_TX_FLUSH_Q_ID(ev));
-		efhw_handle_txdmaq_flushed(nic, h, ev);
-		break;
-
-	case RX_DESCQ_FLS_DONE_EV_DECODE:
-		EFHW_TRACE("RX[%d] flushed",
-			   (int)FALCON_EVENT_TX_FLUSH_Q_ID(ev));
-		efhw_handle_rxdmaq_flushed(nic, h, ev);
-		break;
-
-	case SRM_UPD_DONE_EV_DECODE:
-		nic->buf_commit_outstanding =
-		    max(0, nic->buf_commit_outstanding - 1);
-		EFHW_TRACE("COMMIT DONE %d", nic->buf_commit_outstanding);
-		break;
-
-	case EVQ_INIT_DONE_EV_DECODE:
-		EFHW_TRACE("%sEVQ INIT", "");
-		break;
-
-	case WAKE_UP_EV_DECODE:
-		EFHW_TRACE("%sWAKE UP", "");
-		efhw_handle_wakeup_event(nic, h, ev);
-		break;
-
-	case TIMER_EV_DECODE:
-		EFHW_TRACE("%sTIMER", "");
-		efhw_handle_timeout_event(nic, h, ev);
-		break;
-
-	case RX_DESCQ_FLSFF_OVFL_EV_DECODE:
-		/* This shouldn't happen. */
-		EFHW_ERR("%s: RX flush fifo overflowed", __func__);
-		return -EINVAL;
-
-	default:
-		EFHW_TRACE("UNKOWN DRIVER EVENT: " FALCON_EVENT_FMT,
-			   FALCON_EVENT_PRI_ARG(*ev));
-		break;
-	}
-	return 0;
-}
-
-
-/*--------------------------------------------------------------------
- *
- * Filter search depth control
- *
- *--------------------------------------------------------------------*/
-
-
-#define Q0_READ(q0, name) \
-	((unsigned)(((q0) >> name##_LBN) & (__FALCON_MASK64(name##_WIDTH))))
-#define Q0_MASK(name) \
-	((__FALCON_MASK64(name##_WIDTH)) << name##_LBN)
-#define Q0_VALUE(name, value) \
-	(((uint64_t)(value)) << name##_LBN)
-
-#define Q1_READ(q1, name) \
-	((unsigned)(((q1) >> (name##_LBN - 64)) & \
-		    (__FALCON_MASK64(name##_WIDTH))))
-#define Q1_MASK(name) \
-	((__FALCON_MASK64(name##_WIDTH)) << (name##_LBN - 64))
-#define Q1_VALUE(name, value) \
-	(((uint64_t)(value)) << (name##_LBN - 64))
-
-
-void
-falcon_nic_get_rx_filter_search_limits(struct efhw_nic *nic,
-				       struct efhw_filter_search_limits *lim,
-				       int use_raw_values)
-{
-	volatile char __iomem *efhw_kva = EFHW_KVA(nic);
-	FALCON_LOCK_DECL;
-	uint64_t q0, q1;
-	unsigned ff = (use_raw_values ? 0 : RX_FILTER_CTL_SRCH_FUDGE_FULL);
-	unsigned wf = (use_raw_values ? 0 : RX_FILTER_CTL_SRCH_FUDGE_WILD);
-
-	FALCON_LOCK_LOCK(nic);
-	falcon_read_qq(efhw_kva + RX_FILTER_CTL_REG_OFST, &q0, &q1);
-	FALCON_LOCK_UNLOCK(nic);
-
-	lim->tcp_full = Q0_READ(q0, TCP_FULL_SRCH_LIMIT) - ff;
-	lim->tcp_wild = Q0_READ(q0, TCP_WILD_SRCH_LIMIT) - wf;
-	lim->udp_full = Q0_READ(q0, UDP_FULL_SRCH_LIMIT) - ff;
-	lim->udp_wild = Q0_READ(q0, UDP_WILD_SRCH_LIMIT) - wf;
-}
-EXPORT_SYMBOL(falcon_nic_get_rx_filter_search_limits);
-
-
-void
-falcon_nic_set_rx_filter_search_limits(struct efhw_nic *nic,
-				       struct efhw_filter_search_limits *lim,
-				       int use_raw_values)
-{
-	volatile char __iomem *efhw_kva = EFHW_KVA(nic);
-	FALCON_LOCK_DECL;
-	uint64_t q0, q1;
-	unsigned ff = (use_raw_values ? 0 : RX_FILTER_CTL_SRCH_FUDGE_FULL);
-	unsigned wf = (use_raw_values ? 0 : RX_FILTER_CTL_SRCH_FUDGE_WILD);
-
-	FALCON_LOCK_LOCK(nic);
-	falcon_read_qq(efhw_kva + RX_FILTER_CTL_REG_OFST, &q0, &q1);
-
-	q0 &= ~Q0_MASK(TCP_FULL_SRCH_LIMIT);
-	q0 &= ~Q0_MASK(TCP_WILD_SRCH_LIMIT);
-	q0 &= ~Q0_MASK(UDP_FULL_SRCH_LIMIT);
-	q0 &= ~Q0_MASK(UDP_WILD_SRCH_LIMIT);
-	q0 |= Q0_VALUE(TCP_FULL_SRCH_LIMIT, lim->tcp_full + ff);
-	q0 |= Q0_VALUE(TCP_WILD_SRCH_LIMIT, lim->tcp_wild + wf);
-	q0 |= Q0_VALUE(UDP_FULL_SRCH_LIMIT, lim->udp_full + ff);
-	q0 |= Q0_VALUE(UDP_WILD_SRCH_LIMIT, lim->udp_wild + wf);
-	nic->tcp_full_srch.max = lim->tcp_full + ff
-					- RX_FILTER_CTL_SRCH_FUDGE_FULL;
-	nic->tcp_wild_srch.max = lim->tcp_wild + wf
-					- RX_FILTER_CTL_SRCH_FUDGE_WILD;
-	nic->udp_full_srch.max = lim->udp_full + ff
-					- RX_FILTER_CTL_SRCH_FUDGE_FULL;
-	nic->udp_wild_srch.max = lim->udp_wild + wf
-					- RX_FILTER_CTL_SRCH_FUDGE_WILD;
-
-	falcon_write_qq(efhw_kva + RX_FILTER_CTL_REG_OFST, q0, q1);
-	mmiowb();
-	FALCON_LOCK_UNLOCK(nic);
-}
-EXPORT_SYMBOL(falcon_nic_set_rx_filter_search_limits);
-
-
-#undef READ_Q0
-#undef Q0_MASK
-#undef Q0_VALUE
-#undef READ_Q1
-#undef Q1_MASK
-#undef Q1_VALUE
-
-
-/*--------------------------------------------------------------------
- *
- * New unified filter API
- *
- *--------------------------------------------------------------------*/
-
-
-#if FALCON_FULL_FILTER_CACHE
-static inline struct efhw_filter_spec *
-filter_spec_cache_entry(struct efhw_nic *nic, int filter_idx)
-{
-	EFHW_ASSERT(nic->filter_spec_cache);
-	return &nic->filter_spec_cache[filter_idx];
-}
-#endif
-
-
-static int filter_is_active(struct efhw_nic *nic, int filter_idx)
-{
-	return nic->filter_in_use[filter_idx];
-}
-
-
-static void set_filter_cache_entry(struct efhw_nic *nic,
-				   struct efhw_filter_spec *spec,
-				   int filter_idx)
-{
-	nic->filter_in_use[filter_idx] = 1;
-#if FALCON_FULL_FILTER_CACHE
-	memcpy(filter_spec_cache_entry(nic, filter_idx), spec,
-	       sizeof(struct efhw_filter_spec));
-#endif
-}
-
-
-static void clear_filter_cache_entry(struct efhw_nic *nic,
-				     int filter_idx)
-{
-	nic->filter_in_use[filter_idx] = 0;
-#if FALCON_FULL_FILTER_CACHE
-	memset(filter_spec_cache_entry(nic, filter_idx), 0,
-	       sizeof(struct efhw_filter_spec));
-#endif
-}
-
-
-#if FALCON_FULL_FILTER_CACHE
-static int filter_is_duplicate(struct efhw_nic *nic,
-			       struct efhw_filter_spec *spec, int filter_idx)
-{
-	struct efhw_filter_spec *cmp;
-
-	cmp = filter_spec_cache_entry(nic, filter_idx);
-
-	EFHW_ASSERT(filter_is_active(nic, filter_idx));
-
-	return (spec->saddr_le32 == cmp->saddr_le32) &&
-	       (spec->daddr_le32 == cmp->daddr_le32) &&
-	       (spec->sport_le16 == cmp->sport_le16) &&
-	       (spec->dport_le16 == cmp->dport_le16) &&
-	       (spec->tcp == cmp->tcp) &&
-	       (spec->full == cmp->full);
-}
-#endif
-
-
-static void common_build_ip_filter(struct efhw_nic *nic, int tcp, int full,
-				   int rss, int scatter, uint dmaq_id,
-				   unsigned saddr_le32, unsigned sport_le16,
-				   unsigned daddr_le32, unsigned dport_le16,
-				   uint64_t *q0, uint64_t *q1)
-{
-	uint64_t v1, v2, v3, v4;
-	unsigned tmp_port_le16;
-
-	if (!full) {
-		saddr_le32 = 0;
-		sport_le16 = 0;
-		if (!tcp) {
-			tmp_port_le16 = sport_le16;
-			sport_le16 = dport_le16;
-			dport_le16 = tmp_port_le16;
-		}
-	}
-
-	v4 = (((!tcp) << __DW4(TCP_UDP_0_LBN)) |
-	      (dmaq_id << __DW4(RXQ_ID_0_LBN)));
-
-	switch (nic->devtype.variant) {
-	case 'A':
-		EFHW_ASSERT(!rss);
-		break;
-	case 'B':
-		v4 |= scatter << __DW4(SCATTER_EN_0_B0_LBN);
-		v4 |= rss << __DW4(RSS_EN_0_B0_LBN);
-		break;
-	default:
-		EFHW_ASSERT(0);
-		break;
-	}
-
-	v3 = daddr_le32;
-	v2 = ((dport_le16 << __DW2(DEST_PORT_TCP_0_LBN)) |
-	      (__HIGH(saddr_le32, SRC_IP_0_LBN, SRC_IP_0_WIDTH)));
-	v1 = ((__LOW(saddr_le32, SRC_IP_0_LBN, SRC_IP_0_WIDTH)) |
-	      (sport_le16 << SRC_TCP_DEST_UDP_0_LBN));
-
-	*q0 = (v2 << 32) | v1;
-	*q1 = (v4 << 32) | v3;
-}
-
-
-static void build_filter(struct efhw_nic *nic, struct efhw_filter_spec *spec,
-			 unsigned *key, unsigned *tbl_size,
-			 struct efhw_filter_depth **depth,
-			 uint64_t *q0, uint64_t *q1)
-{
-	*key = falcon_hash_get_ip_key(spec->saddr_le32,
-				      spec->sport_le16,
-				      spec->daddr_le32,
-				      spec->dport_le16,
-				      spec->tcp,
-				      spec->full);
-	*tbl_size = nic->ip_filter_tbl_size;
-	if (spec->tcp && spec->full)
-		*depth = &nic->tcp_full_srch;
-	else if (spec->tcp && !spec->full)
-		*depth = &nic->tcp_wild_srch;
-	else if (!spec->tcp && spec->full)
-		*depth = &nic->udp_full_srch;
-	else
-		*depth = &nic->udp_wild_srch;
-	common_build_ip_filter(nic, spec->tcp, spec->full,
-			       spec->rss, spec->scatter,
-			       spec->dmaq_id,
-			       spec->saddr_le32,
-			       spec->sport_le16,
-			       spec->daddr_le32,
-			       spec->dport_le16,
-			       q0, q1);
-}
-
-
-#if FALCON_VERIFY_FILTERS
-static void verify_filters(struct efhw_nic *nic)
-{
-	unsigned table_offset, table_stride;
-	unsigned i, dummy_key, dummy_tbl_size;
-	struct efhw_filter_depth *dummy_depth;
-	unsigned filter_tbl_size;
-	struct efhw_filter_spec *spec;
-	uint64_t q0_expect, q1_expect, q0_got, q1_got;
-
-	filter_tbl_size = nic->ip_filter_tbl_size;
-	table_offset = RX_FILTER_TBL0_OFST;
-	table_stride = 2 * FALCON_REGISTER128;
-
-	for (i = 0; i < filter_tbl_size; i++) {
-		if (!filter_is_active(nic, type, i))
-			continue;
-
-		spec = filter_spec_cache_entry(nic, type, i);
-
-		build_filter(nic, spec, &dummy_key, &dummy_tbl_size,
-			     &dummy_depth, &q0_expect, &q1_expect);
-
-		falcon_read_qq(EFHW_KVA(nic) + table_offset + i * table_stride,
-			       &q0_got, &q1_got);
-
-		if ((q0_got != q0_expect) || (q1_got != q1_expect)) {
-			falcon_write_qq(EFHW_KVA(nic) + 0x300,
-					q0_got, q1_got);
-			EFHW_ERR("ERROR: RX-filter[%d][%d] was "
-				 "%"PRIx64":%" PRIx64" expected "
-				 "%"PRIx64":%"PRIx64,
-				 nic->index, i, q0_got, q1_got,
-				 q0_expect, q1_expect);
-		}
-	}
-}
-#endif
-
-
-static void write_filter_table_entry(struct efhw_nic *nic,
-				     unsigned filter_idx,
-				     uint64_t q0, uint64_t q1)
-{
-	unsigned table_offset, table_stride, offset;
-
-	EFHW_ASSERT(filter_idx < nic->ip_filter_tbl_size);
-	table_offset = RX_FILTER_TBL0_OFST;
-	table_stride = 2 * FALCON_REGISTER128;
-
-	offset = table_offset + filter_idx * table_stride;
-	falcon_write_qq(EFHW_KVA(nic) + offset, q0, q1);
-	mmiowb();
-
-#if FALCON_VERIFY_FILTERS
-	{
-		uint64_t q0read, q1read;
-
-		/* Read a different entry first - ensure BIU flushed shadow */
-		falcon_read_qq(EFHW_KVA(nic) + offset + 0x10, &q0read, &q1read);
-		falcon_read_qq(EFHW_KVA(nic) + offset, &q0read, &q1read);
-		EFHW_ASSERT(q0read == q0);
-		EFHW_ASSERT(q1read == q1);
-
-		verify_filters(nic, type);
-	}
-#endif
-}
-
-
-static int falcon_nic_filter_set(struct efhw_nic *nic,
-				 struct efhw_filter_spec *spec,
-				 int *filter_idx_out)
-{
-	FALCON_LOCK_DECL;
-	unsigned key = 0, tbl_size = 0, hash1, hash2, k;
-	struct efhw_filter_depth *depth = NULL;
-	int filter_idx = -1;
-	int rc = 0;
-	uint64_t q0, q1;
-
-	build_filter(nic, spec, &key, &tbl_size, &depth, &q0, &q1);
-
-	if (tbl_size == 0)
-		return -EINVAL;
-
-	EFHW_TRACE("%s: depth->max=%d", __func__, depth->max);
-
-	hash1 = falcon_hash_function1(key, tbl_size);
-	hash2 = falcon_hash_function2(key, tbl_size);
-
-	FALCON_LOCK_LOCK(nic);
-
-	for (k = 0; k < depth->max; k++) {
-		filter_idx = falcon_hash_iterator(hash1, hash2, k, tbl_size);
-		if (!filter_is_active(nic, filter_idx))
-			break;
-#if FALCON_FULL_FILTER_CACHE
-		if (filter_is_duplicate(nic, spec, filter_idx)) {
-			EFHW_WARN("%s: ERROR: duplicate filter (disabling "
-				  "interrupts)", __func__);
-			falcon_nic_interrupt_hw_disable(nic);
-			rc = -EINVAL;
-			goto fail1;
-		}
-#endif
-	}
-	if (k == depth->max) {
-		rc = -EADDRINUSE;
-		filter_idx = -1;
-		goto fail1;
-	} else if (depth->needed < (k + 1)) {
-		depth->needed = k + 1;
-	}
-
-	EFHW_ASSERT(filter_idx < (int)tbl_size);
-
-	set_filter_cache_entry(nic, spec, filter_idx);
-	write_filter_table_entry(nic, filter_idx, q0, q1);
-
-	++nic->ip_filter_tbl_used;
-
-	*filter_idx_out = filter_idx;
-
-	EFHW_TRACE("%s: filter index %d rxq %u set in %u",
-		   __func__, filter_idx, spec->dmaq_id, k);
-
-fail1:
-	FALCON_LOCK_UNLOCK(nic);
-	return rc;
-}
-
-
-static void falcon_nic_filter_clear(struct efhw_nic *nic,
-				    int filter_idx)
-{
-	FALCON_LOCK_DECL;
-
-	if (filter_idx < 0)
-		return;
-
-	FALCON_LOCK_LOCK(nic);
-	if (filter_is_active(nic, filter_idx)) {
-		if (--nic->ip_filter_tbl_used == 0) {
-			nic->tcp_full_srch.needed = 0;
-			nic->tcp_wild_srch.needed = 0;
-			nic->udp_full_srch.needed = 0;
-			nic->udp_wild_srch.needed = 0;
-		}
-	}
-	clear_filter_cache_entry(nic, filter_idx);
-	write_filter_table_entry(nic, filter_idx, 0, 0);
-	FALCON_LOCK_UNLOCK(nic);
-}
-
-
-int
-falcon_nic_filter_ctor(struct efhw_nic *nic)
-{
-	nic->ip_filter_tbl_size = 8 * 1024;
-	nic->ip_filter_tbl_used = 0;
-
-	nic->tcp_full_srch.needed = 0;
-	nic->tcp_full_srch.max = RX_FILTER_CTL_SRCH_LIMIT_TCP_FULL
-				   - RX_FILTER_CTL_SRCH_FUDGE_FULL;
-	nic->tcp_wild_srch.needed = 0;
-	nic->tcp_wild_srch.max = RX_FILTER_CTL_SRCH_LIMIT_TCP_WILD
-				   - RX_FILTER_CTL_SRCH_FUDGE_WILD;
-	nic->udp_full_srch.needed = 0;
-	nic->udp_full_srch.max = RX_FILTER_CTL_SRCH_LIMIT_UDP_FULL
-				   - RX_FILTER_CTL_SRCH_FUDGE_FULL;
-	nic->udp_wild_srch.needed = 0;
-	nic->udp_wild_srch.max = RX_FILTER_CTL_SRCH_LIMIT_UDP_WILD
-				   - RX_FILTER_CTL_SRCH_FUDGE_WILD;
-
-	nic->filter_in_use = vmalloc(FALCON_FILTER_TBL_NUM);
-	if (nic->filter_in_use == NULL)
-		return -ENOMEM;
-	memset(nic->filter_in_use, 0, FALCON_FILTER_TBL_NUM);
-#if FALCON_FULL_FILTER_CACHE
-	nic->filter_spec_cache = vmalloc(FALCON_FILTER_TBL_NUM
-					 * sizeof(struct efhw_filter_spec));
-	if (nic->filter_spec_cache == NULL)
-		return -ENOMEM;
-	memset(nic->filter_spec_cache, 0, FALCON_FILTER_TBL_NUM
-					  * sizeof(struct efhw_filter_spec));
-#endif
-
-	return 0;
-}
-
-
-void
-falcon_nic_filter_dtor(struct efhw_nic *nic)
-{
-#if FALCON_FULL_FILTER_CACHE
-	if (nic->filter_spec_cache)
-		vfree(nic->filter_spec_cache);
-#endif
-	if (nic->filter_in_use)
-		vfree(nic->filter_in_use);
-}
-
-
-/*--------------------------------------------------------------------
- *
- * Compatibility with old filter API
- *
- *--------------------------------------------------------------------*/
-
-void
-falcon_nic_rx_filter_ctl_get(struct efhw_nic *nic, uint32_t *tcp_full,
-			     uint32_t *tcp_wild,
-			     uint32_t *udp_full, uint32_t *udp_wild)
-{
-	struct efhw_filter_search_limits lim;
-
-	falcon_nic_get_rx_filter_search_limits(nic, &lim, 0);
-	*tcp_full = (uint32_t)lim.tcp_full;
-	*tcp_wild = (uint32_t)lim.tcp_wild;
-	*udp_full = (uint32_t)lim.udp_full;
-	*udp_wild = (uint32_t)lim.udp_wild;
-}
-EXPORT_SYMBOL(falcon_nic_rx_filter_ctl_get);
-
-
-void
-falcon_nic_rx_filter_ctl_set(struct efhw_nic *nic, uint32_t tcp_full,
-			     uint32_t tcp_wild,
-			     uint32_t udp_full, uint32_t udp_wild)
-{
-	struct efhw_filter_search_limits lim;
-
-	lim.tcp_full = (unsigned)tcp_full;
-	lim.tcp_wild = (unsigned)tcp_wild;
-	lim.udp_full = (unsigned)udp_full;
-	lim.udp_wild = (unsigned)udp_wild;
-	falcon_nic_set_rx_filter_search_limits(nic, &lim, 0);
-}
-EXPORT_SYMBOL(falcon_nic_rx_filter_ctl_set);
-
-
-static int
-falcon_nic_ipfilter_set(struct efhw_nic *nic, int type, int *_filter_idx,
-			int dmaq,
-			unsigned saddr_be32, unsigned sport_be16,
-			unsigned daddr_be32, unsigned dport_be16)
-{
-	struct efhw_filter_spec spec;
-
-	spec.dmaq_id = dmaq;
-	spec.saddr_le32 = ntohl(saddr_be32);
-	spec.daddr_le32 = ntohl(daddr_be32);
-	spec.sport_le16 = ntohs((unsigned short) sport_be16);
-	spec.dport_le16 = ntohs((unsigned short) dport_be16);
-	spec.tcp = ((type & EFHW_IP_FILTER_TYPE_TCP_MASK) != 0);
-	spec.full = ((type & EFHW_IP_FILTER_TYPE_FULL_MASK) != 0);
-	spec.rss = ((type & EFHW_IP_FILTER_TYPE_RSS_B0_MASK) != 0);
-	spec.scatter = ((type & EFHW_IP_FILTER_TYPE_NOSCAT_B0_MASK) == 0);
-	return falcon_nic_filter_set(nic, &spec, _filter_idx);
-}
-
-static void falcon_nic_ipfilter_clear(struct efhw_nic *nic, int filter_idx)
-{
-	falcon_nic_filter_clear(nic, filter_idx);
-}
-
-
-/*--------------------------------------------------------------------
- *
- * Abstraction Layer Hooks
- *
- *--------------------------------------------------------------------*/
-
-struct efhw_func_ops falcon_char_functional_units = {
-	falcon_nic_close_hardware,
-	falcon_nic_init_hardware,
-	falcon_nic_interrupt,
-	falcon_nic_interrupt_enable,
-	falcon_nic_interrupt_disable,
-	falcon_nic_set_interrupt_moderation,
-	falcon_nic_event_queue_enable,
-	falcon_nic_event_queue_disable,
-	falcon_nic_wakeup_request,
-	falcon_nic_sw_event,
-	falcon_nic_ipfilter_set,
-	falcon_nic_ipfilter_clear,
-	falcon_dmaq_tx_q_init,
-	falcon_dmaq_rx_q_init,
-	falcon_dmaq_tx_q_disable,
-	falcon_dmaq_rx_q_disable,
-	falcon_flush_tx_dma_channel,
-	falcon_flush_rx_dma_channel,
-	falcon_nic_buffer_table_set,
-	falcon_nic_buffer_table_set_n,
-	falcon_nic_buffer_table_clear,
-	falcon_nic_buffer_table_commit,
-	falcon_nic_filter_set,
-	falcon_nic_filter_clear,
-};
-
-
diff -r 9566a4a50a43 drivers/net/sfc/sfc_resource/falcon_hash.c
--- a/drivers/net/sfc/sfc_resource/falcon_hash.c
+++ /dev/null
@@ -1,159 +0,0 @@
-/****************************************************************************
- * Driver for Solarflare network controllers -
- *          resource management for Xen backend, OpenOnload, etc
- *           (including support for SFE4001 10GBT NIC)
- *
- * This file contains EtherFabric NIC hash algorithms implementation.
- *
- * Copyright 2005-2007: Solarflare Communications Inc,
- *                      9501 Jeronimo Road, Suite 250,
- *                      Irvine, CA 92618, USA
- *
- * Developed and maintained by Solarflare Communications:
- *                      <linux-xen-drivers@solarflare.com>
- *                      <onload-dev@solarflare.com>
- *
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 as published
- * by the Free Software Foundation, incorporated herein by reference.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
- ****************************************************************************
- */
-
-#include <ci/efhw/debug.h>
-#include <ci/driver/efab/hardware.h>
-
-
-static unsigned int
-common_get_ip_key(unsigned int src_ip, unsigned int src_port,
-		  unsigned int dest_ip, unsigned int dest_port,
-		  int tcp, int full, int tx, unsigned int masked_q_id)
-{
-
-	unsigned int tmp_port, result;
-
-	EFHW_ASSERT(tcp == 0 || tcp == 1);
-	EFHW_ASSERT(full == 0 || full == 1);
-	EFHW_ASSERT(masked_q_id < (1 << 10));
-
-	/* m=masked_q_id(TX)/0(RX)  u=UDP  S,D=src/dest addr  s,d=src/dest port
-	 *
-	 * Wildcard filters have src(TX)/dest(RX) addr and port = 0;
-	 * and UDP wildcard filters have the src and dest port fields swapped.
-	 *
-	 * Addr/port fields are little-endian.
-	 *
-	 * 3322222222221111111111
-	 * 10987654321098765432109876543210
-	 *
-	 * 000000000000000000000mmmmmmmmmmu ^
-	 * DDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDD ^
-	 * ddddddddddddddddSSSSSSSSSSSSSSSS ^
-	 * SSSSSSSSSSSSSSSSssssssssssssssss
-	 */
-
-	if (!tx)
-		masked_q_id = 0;
-
-	if (!full) {
-		if (tx) {
-			dest_ip = 0;
-			dest_port = 0;
-		} else {
-			src_ip = 0;
-			src_port = 0;
-		}
-		if (!tcp) {
-			tmp_port = src_port;
-			src_port = dest_port;
-			dest_port = tmp_port;
-		}
-	}
-
-	result = ((masked_q_id << 1) | (!tcp))                              ^
-		 (dest_ip)                                                  ^
-		 (((dest_port & 0xffff) << 16) | ((src_ip >> 16) & 0xffff)) ^
-		 (((src_ip & 0xffff) << 16) | (src_port & 0xffff));
-
-	EFHW_TRACE("%s: IP %s %s %x", __func__, tcp ? "TCP" : "UDP",
-		   full ? "Full" : "Wildcard", result);
-
-	return result;
-}
-
-
-unsigned int
-falcon_hash_get_ip_key(unsigned int src_ip, unsigned int src_port,
-		       unsigned int dest_ip, unsigned int dest_port,
-		       int tcp, int full)
-{
-	return common_get_ip_key(src_ip, src_port, dest_ip, dest_port, tcp,
-				 full, 0, 0);
-}
-
-
-/* This function generates the First Hash key */
-unsigned int falcon_hash_function1(unsigned int key, unsigned int nfilters)
-{
-
-	unsigned short int lfsr_reg;
-	unsigned int tmp_key;
-	int index;
-
-	unsigned short int lfsr_input;
-	unsigned short int single_bit_key;
-	unsigned short int bit16_lfsr;
-	unsigned short int bit3_lfsr;
-
-	lfsr_reg = 0xFFFF;
-	tmp_key = key;
-
-	/* For Polynomial equation X^16+X^3+1 */
-	for (index = 0; index < 32; index++) {
-		/* Get the bit from key and shift the key */
-		single_bit_key = (tmp_key & 0x80000000) >> 31;
-		tmp_key = tmp_key << 1;
-
-		/* get the Tap bits to XOR operation */
-		bit16_lfsr = (lfsr_reg & 0x8000) >> 15;
-		bit3_lfsr = (lfsr_reg & 0x0004) >> 2;
-
-		/* Get the Input value to the LFSR */
-		lfsr_input = ((bit16_lfsr ^ bit3_lfsr) ^ single_bit_key);
-
-		/* Shift and store out of the two TAPs */
-		lfsr_reg = lfsr_reg << 1;
-		lfsr_reg = lfsr_reg | (lfsr_input & 0x0001);
-
-	}
-
-	lfsr_reg = lfsr_reg & (nfilters - 1);
-
-	return lfsr_reg;
-}
-
-/* This function generates the Second Hash */
-unsigned int
-falcon_hash_function2(unsigned int key, unsigned int nfilters)
-{
-	return (unsigned int)(((unsigned long long)key * 2 - 1) &
-			      (nfilters - 1));
-}
-
-/* This function iterates through the hash table */
-unsigned int
-falcon_hash_iterator(unsigned int hash1, unsigned int hash2,
-		     unsigned int n_search, unsigned int nfilters)
-{
-	return (hash1 + (n_search * hash2)) & (nfilters - 1);
-}
-
diff -r 9566a4a50a43 drivers/net/sfc/sfc_resource/filter_resource.c
--- a/drivers/net/sfc/sfc_resource/filter_resource.c
+++ /dev/null
@@ -1,250 +0,0 @@
-/****************************************************************************
- * Driver for Solarflare network controllers -
- *          resource management for Xen backend, OpenOnload, etc
- *           (including support for SFE4001 10GBT NIC)
- *
- * This file contains filters support.
- *
- * Copyright 2005-2007: Solarflare Communications Inc,
- *                      9501 Jeronimo Road, Suite 250,
- *                      Irvine, CA 92618, USA
- *
- * Developed and maintained by Solarflare Communications:
- *                      <linux-xen-drivers@solarflare.com>
- *                      <onload-dev@solarflare.com>
- *
- * Certain parts of the driver were implemented by
- *          Alexandra Kossovsky <Alexandra.Kossovsky@oktetlabs.ru>
- *          OKTET Labs Ltd, Russia,
- *          http://oktetlabs.ru, <info@oktetlabs.ru>
- *          by request of Solarflare Communications
- *
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 as published
- * by the Free Software Foundation, incorporated herein by reference.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
- ****************************************************************************
- */
-
-#include <ci/efrm/nic_table.h>
-#include <ci/driver/efab/hardware.h>
-#include <ci/efhw/falcon.h>
-#include <ci/efrm/vi_resource_manager.h>
-#include <ci/efrm/private.h>
-#include <ci/efrm/filter.h>
-#include <ci/efrm/buffer_table.h>
-#include <ci/efrm/efrm_client.h>
-#include "efrm_internal.h"
-
-
-struct filter_resource_manager {
-	struct efrm_resource_manager rm;
-	struct kfifo *free_ids;
-};
-
-static struct filter_resource_manager *efrm_filter_manager;
-
-
-void efrm_filter_resource_free(struct filter_resource *frs)
-{
-	struct efhw_nic *nic = frs->rs.rs_client->nic;
-	int id;
-
-	EFRM_RESOURCE_ASSERT_VALID(&frs->rs, 1);
-
-	EFRM_TRACE("%s: " EFRM_RESOURCE_FMT, __func__,
-		   EFRM_RESOURCE_PRI_ARG(frs->rs.rs_handle));
-
-	efhw_nic_ipfilter_clear(nic, frs->filter_idx);
-	frs->filter_idx = -1;
-	efrm_vi_resource_release(frs->pt);
-
-	/* Free this filter. */
-	id = EFRM_RESOURCE_INSTANCE(frs->rs.rs_handle);
-	EFRM_VERIFY_EQ(kfifo_put(efrm_filter_manager->free_ids,
-				 (unsigned char *)&id, sizeof(id)),
-		       sizeof(id));
-
-	efrm_client_put(frs->rs.rs_client);
-	EFRM_DO_DEBUG(memset(frs, 0, sizeof(*frs)));
-	kfree(frs);
-}
-EXPORT_SYMBOL(efrm_filter_resource_free);
-
-
-void efrm_filter_resource_release(struct filter_resource *frs)
-{
-	if (__efrm_resource_release(&frs->rs))
-		efrm_filter_resource_free(frs);
-}
-EXPORT_SYMBOL(efrm_filter_resource_release);
-
-
-static void filter_rm_dtor(struct efrm_resource_manager *rm)
-{
-	EFRM_TRACE("%s:", __func__);
-
-	EFRM_RESOURCE_MANAGER_ASSERT_VALID(&efrm_filter_manager->rm);
-	EFRM_ASSERT(&efrm_filter_manager->rm == rm);
-
-	kfifo_vfree(efrm_filter_manager->free_ids);
-	EFRM_TRACE("%s: done", __func__);
-}
-
-/**********************************************************************/
-/**********************************************************************/
-/**********************************************************************/
-
-int efrm_create_filter_resource_manager(struct efrm_resource_manager **rm_out)
-{
-	int rc;
-
-	EFRM_ASSERT(rm_out);
-
-	efrm_filter_manager =
-	    kmalloc(sizeof(struct filter_resource_manager), GFP_KERNEL);
-	if (efrm_filter_manager == 0)
-		return -ENOMEM;
-	memset(efrm_filter_manager, 0, sizeof(*efrm_filter_manager));
-
-	rc = efrm_resource_manager_ctor(&efrm_filter_manager->rm,
-					filter_rm_dtor, "FILTER",
-					EFRM_RESOURCE_FILTER);
-	if (rc < 0)
-		goto fail1;
-
-	/* Create a pool of free instances */
-	rc = efrm_kfifo_id_ctor(&efrm_filter_manager->free_ids,
-				0, EFHW_IP_FILTER_NUM,
-				&efrm_filter_manager->rm.rm_lock);
-	if (rc != 0)
-		goto fail2;
-
-	*rm_out = &efrm_filter_manager->rm;
-	EFRM_TRACE("%s: filter resources created - %d IDs",
-		   __func__, kfifo_len(efrm_filter_manager->free_ids));
-	return 0;
-
-fail2:
-	efrm_resource_manager_dtor(&efrm_filter_manager->rm);
-fail1:
-	memset(efrm_filter_manager, 0, sizeof(*efrm_filter_manager));
-	kfree(efrm_filter_manager);
-	return rc;
-
-}
-
-
-int efrm_filter_resource_clear(struct filter_resource *frs)
-{
-	struct efhw_nic *nic = frs->rs.rs_client->nic;
-
-	efhw_nic_ipfilter_clear(nic, frs->filter_idx);
-	frs->filter_idx = -1;
-	return 0;
-}
-EXPORT_SYMBOL(efrm_filter_resource_clear);
-
-
-int
-__efrm_filter_resource_set(struct filter_resource *frs, int type,
-			   unsigned saddr, uint16_t sport,
-			   unsigned daddr, uint16_t dport)
-{
-	struct efhw_nic *nic = frs->rs.rs_client->nic;
-	int vi_instance;
-
-	EFRM_ASSERT(frs);
-
-	if (efrm_nic_tablep->a_nic->devtype.variant >= 'B' &&
-	    (frs->pt->flags & EFHW_VI_JUMBO_EN) == 0)
-		type |= EFHW_IP_FILTER_TYPE_NOSCAT_B0_MASK;
-	vi_instance = EFRM_RESOURCE_INSTANCE(frs->pt->rs.rs_handle);
-
-	return efhw_nic_ipfilter_set(nic, type, &frs->filter_idx,
-				     vi_instance, saddr, sport, daddr, dport);
-}
-EXPORT_SYMBOL(__efrm_filter_resource_set);;
-
-
-int
-efrm_filter_resource_alloc(struct vi_resource *vi_parent,
-			   struct filter_resource **frs_out)
-{
-	struct filter_resource *frs;
-	int rc, instance;
-
-	EFRM_ASSERT(frs_out);
-	EFRM_ASSERT(efrm_filter_manager);
-	EFRM_RESOURCE_MANAGER_ASSERT_VALID(&efrm_filter_manager->rm);
-	EFRM_ASSERT(vi_parent != NULL);
-	EFRM_ASSERT(EFRM_RESOURCE_TYPE(vi_parent->rs.rs_handle) ==
-		    EFRM_RESOURCE_VI);
-
-	/* Allocate resource data structure. */
-	frs = kmalloc(sizeof(struct filter_resource), GFP_KERNEL);
-	if (!frs)
-		return -ENOMEM;
-
-	/* Allocate an instance. */
-	rc = kfifo_get(efrm_filter_manager->free_ids,
-		       (unsigned char *)&instance, sizeof(instance));
-	if (rc != sizeof(instance)) {
-		EFRM_TRACE("%s: out of instances", __func__);
-		EFRM_ASSERT(rc == 0);
-		rc = -EBUSY;
-		goto fail1;
-	}
-
-	/* Initialise the resource DS. */
-	efrm_resource_init(&frs->rs, EFRM_RESOURCE_FILTER, instance);
-	frs->pt = vi_parent;
-	efrm_resource_ref(&frs->pt->rs);
-	frs->filter_idx = -1;
-
-	EFRM_TRACE("%s: " EFRM_RESOURCE_FMT " VI %d", __func__,
-		   EFRM_RESOURCE_PRI_ARG(frs->rs.rs_handle),
-		   EFRM_RESOURCE_INSTANCE(vi_parent->rs.rs_handle));
-
-	efrm_client_add_resource(vi_parent->rs.rs_client, &frs->rs);
-	*frs_out = frs;
-	return 0;
-
-fail1:
-	memset(frs, 0, sizeof(*frs));
-	kfree(frs);
-	return rc;
-}
-EXPORT_SYMBOL(efrm_filter_resource_alloc);
-
-
-int efrm_filter_resource_instance(struct filter_resource *frs)
-{
-	return EFRM_RESOURCE_INSTANCE(frs->rs.rs_handle);
-}
-EXPORT_SYMBOL(efrm_filter_resource_instance);
-
-
-struct efrm_resource *
-efrm_filter_resource_to_resource(struct filter_resource *frs)
-{
-	return &frs->rs;
-}
-EXPORT_SYMBOL(efrm_filter_resource_to_resource);
-
-
-struct filter_resource *
-efrm_filter_resource_from_resource(struct efrm_resource *rs)
-{
-	return filter_resource(rs);
-}
-EXPORT_SYMBOL(efrm_filter_resource_from_resource);
diff -r 9566a4a50a43 drivers/net/sfc/sfc_resource/iobufset_resource.c
--- a/drivers/net/sfc/sfc_resource/iobufset_resource.c
+++ /dev/null
@@ -1,404 +0,0 @@
-/****************************************************************************
- * Driver for Solarflare network controllers -
- *          resource management for Xen backend, OpenOnload, etc
- *           (including support for SFE4001 10GBT NIC)
- *
- * This file contains non-contiguous I/O buffers support.
- *
- * Copyright 2005-2007: Solarflare Communications Inc,
- *                      9501 Jeronimo Road, Suite 250,
- *                      Irvine, CA 92618, USA
- *
- * Developed and maintained by Solarflare Communications:
- *                      <linux-xen-drivers@solarflare.com>
- *                      <onload-dev@solarflare.com>
- *
- * Certain parts of the driver were implemented by
- *          Alexandra Kossovsky <Alexandra.Kossovsky@oktetlabs.ru>
- *          OKTET Labs Ltd, Russia,
- *          http://oktetlabs.ru, <info@oktetlabs.ru>
- *          by request of Solarflare Communications
- *
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 as published
- * by the Free Software Foundation, incorporated herein by reference.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
- ****************************************************************************
- */
-
-#include <ci/efrm/nic_table.h>
-#include <ci/efhw/iopage.h>
-#include <ci/driver/efab/hardware.h>
-#include <ci/efrm/private.h>
-#include <ci/efrm/iobufset.h>
-#include <ci/efrm/vi_resource_manager.h>
-#include <ci/efrm/buffer_table.h>
-#include <ci/efrm/efrm_client.h>
-#include "efrm_internal.h"
-
-
-#define EFRM_IOBUFSET_MAX_NUM_INSTANCES 0x00010000
-
-struct iobufset_resource_manager {
-	struct efrm_resource_manager rm;
-	struct kfifo *free_ids;
-};
-
-struct iobufset_resource_manager *efrm_iobufset_manager;
-
-#define iobsrs(rs1)  iobufset_resource(rs1)
-
-/* Returns size of iobufset resource data structure. */
-static inline size_t iobsrs_size(int n_pages)
-{
-	return offsetof(struct iobufset_resource, bufs) +
-	    n_pages * sizeof(struct efhw_iopage);
-}
-
-void efrm_iobufset_resource_free(struct iobufset_resource *rs)
-{
-	unsigned int i;
-	int id;
-
-	EFRM_RESOURCE_ASSERT_VALID(&rs->rs, 1);
-
-	if (!rs->linked && rs->buf_tbl_alloc.base != (unsigned) -1)
-		efrm_buffer_table_free(&rs->buf_tbl_alloc);
-
-	/* see comment on call to efhw_iopage_alloc in the alloc routine above
-	   for discussion on use of efrm_nic_tablep->a_nic here */
-	EFRM_ASSERT(efrm_nic_tablep->a_nic);
-	if (rs->linked) {
-		/* Nothing to do. */
-	} else if (rs->chunk_order == 0) {
-		for (i = 0; i < rs->n_bufs; ++i)
-			efhw_iopage_free(efrm_nic_tablep->a_nic, &rs->bufs[i]);
-	} else {
-		/* it is important that this is executed in increasing page
-		 * order because some implementations of
-		 * efhw_iopages_init_from_iopage() assume this */
-		for (i = 0; i < rs->n_bufs;
-		     i += rs->pages_per_contiguous_chunk) {
-			struct efhw_iopages iopages;
-			efhw_iopages_init_from_iopage(&iopages, &rs->bufs[i],
-						    rs->chunk_order);
-			efhw_iopages_free(efrm_nic_tablep->a_nic, &iopages);
-		}
-	}
-
-	/* free the instance number */
-	id = EFRM_RESOURCE_INSTANCE(rs->rs.rs_handle);
-	EFRM_VERIFY_EQ(kfifo_put(efrm_iobufset_manager->free_ids,
-				 (unsigned char *)&id, sizeof(id)), sizeof(id));
-
-	efrm_vi_resource_release(rs->evq);
-	if (rs->linked)
-		efrm_iobufset_resource_release(rs->linked);
-
-	efrm_client_put(rs->rs.rs_client);
-	if (iobsrs_size(rs->n_bufs) < PAGE_SIZE) {
-		EFRM_DO_DEBUG(memset(rs, 0, sizeof(*rs)));
-		kfree(rs);
-	} else {
-		EFRM_DO_DEBUG(memset(rs, 0, sizeof(*rs)));
-		vfree(rs);
-	}
-}
-EXPORT_SYMBOL(efrm_iobufset_resource_free);
-
-
-void efrm_iobufset_resource_release(struct iobufset_resource *iobrs)
-{
-	if (__efrm_resource_release(&iobrs->rs))
-		efrm_iobufset_resource_free(iobrs);
-}
-EXPORT_SYMBOL(efrm_iobufset_resource_release);
-
-
-
-int
-efrm_iobufset_resource_alloc(int32_t n_pages,
-			     int32_t pages_per_contiguous_chunk,
-			     struct vi_resource *vi_evq,
-			     struct iobufset_resource *linked,
-			     bool phys_addr_mode,
-			     struct iobufset_resource **iobrs_out)
-{
-	struct iobufset_resource *iobrs;
-	int rc, instance, object_size;
-	unsigned int i;
-
-	EFRM_ASSERT(iobrs_out);
-	EFRM_ASSERT(efrm_iobufset_manager);
-	EFRM_RESOURCE_MANAGER_ASSERT_VALID(&efrm_iobufset_manager->rm);
-	EFRM_RESOURCE_ASSERT_VALID(&vi_evq->rs, 0);
-	EFRM_ASSERT(EFRM_RESOURCE_TYPE(vi_evq->rs.rs_handle) ==
-		    EFRM_RESOURCE_VI);
-	EFRM_ASSERT(efrm_nic_tablep->a_nic);
-
-	if (linked) {
-		/* This resource will share properties and memory with
-		 * another.  Only difference is that we'll program it into
-		 * the buffer table of another nic.
-		 */
-		n_pages = linked->n_bufs;
-		pages_per_contiguous_chunk = linked->pages_per_contiguous_chunk;
-		phys_addr_mode = linked->buf_tbl_alloc.base == (unsigned) -1;
-	}
-
-	/* allocate the resource data structure. */
-	object_size = iobsrs_size(n_pages);
-	if (object_size < PAGE_SIZE) {
-		/* this should be OK from a tasklet */
-		/* Necessary to do atomic alloc() as this
-		   can be called from a weird-ass iSCSI context that is
-		   !in_interrupt but is in_atomic - See BUG3163 */
-		iobrs = kmalloc(object_size, GFP_ATOMIC);
-	} else {		/* can't do this within a tasklet */
-#ifndef NDEBUG
-		if (in_interrupt() || in_atomic()) {
-			EFRM_ERR("%s(): alloc->u.iobufset.in_n_pages=%d",
-				 __func__, n_pages);
-			EFRM_ASSERT(!in_interrupt());
-			EFRM_ASSERT(!in_atomic());
-		}
-#endif
-		iobrs = (struct iobufset_resource *) vmalloc(object_size);
-	}
-	if (iobrs == NULL) {
-		EFRM_WARN("%s: failed to allocate container", __func__);
-		rc = -ENOMEM;
-		goto fail1;
-	}
-
-	/* Allocate an instance number. */
-	rc = kfifo_get(efrm_iobufset_manager->free_ids,
-		       (unsigned char *)&instance, sizeof(instance));
-	if (rc != sizeof(instance)) {
-		EFRM_WARN("%s: out of instances", __func__);
-		EFRM_ASSERT(rc == 0);
-		rc = -EBUSY;
-		goto fail3;
-	}
-
-	efrm_resource_init(&iobrs->rs, EFRM_RESOURCE_IOBUFSET, instance);
-
-	iobrs->evq = vi_evq;
-	iobrs->linked = linked;
-	iobrs->n_bufs = n_pages;
-	iobrs->pages_per_contiguous_chunk = pages_per_contiguous_chunk;
-	iobrs->chunk_order = fls(iobrs->pages_per_contiguous_chunk - 1);
-	iobrs->buf_tbl_alloc.base = (unsigned) -1;
-
-	EFRM_TRACE("%s: " EFRM_RESOURCE_FMT " %u pages", __func__,
-		   EFRM_RESOURCE_PRI_ARG(iobrs->rs.rs_handle), iobrs->n_bufs);
-
-	/* Allocate the iobuffers. */
-	if (linked) {
-		memcpy(iobrs->bufs, linked->bufs,
-		       iobrs->n_bufs * sizeof(iobrs->bufs[0]));
-	} else if (iobrs->chunk_order == 0) {
-		memset(iobrs->bufs, 0, iobrs->n_bufs * sizeof(iobrs->bufs[0]));
-		for (i = 0; i < iobrs->n_bufs; ++i) {
-			/* due to bug2426 we have to specifiy a NIC when
-			 * allocating a DMAable page, which is a bit messy.
-			 * For now we assume that if the page is suitable
-			 * (e.g. DMAable) by one nic (efrm_nic_tablep->a_nic),
-			 * it is suitable for all NICs.
-			 * XXX I bet that breaks in Solaris.
-			 */
-			rc = efhw_iopage_alloc(efrm_nic_tablep->a_nic,
-					     &iobrs->bufs[i]);
-			if (rc < 0) {
-				EFRM_WARN("%s: failed (rc %d) to allocate "
-					  "page (i=%u)", __func__, rc, i);
-				goto fail4;
-			}
-		}
-	} else {
-		struct efhw_iopages iopages;
-		unsigned j;
-
-		memset(iobrs->bufs, 0, iobrs->n_bufs * sizeof(iobrs->bufs[0]));
-		for (i = 0; i < iobrs->n_bufs;
-		     i += iobrs->pages_per_contiguous_chunk) {
-			rc = efhw_iopages_alloc(efrm_nic_tablep->a_nic,
-						&iopages, iobrs->chunk_order);
-			if (rc < 0) {
-				EFRM_WARN("%s: failed (rc %d) to allocate "
-					  "pages (i=%u order %d)",
-					  __func__, rc, i,
-					  iobrs->chunk_order);
-				goto fail4;
-			}
-			for (j = 0; j < iobrs->pages_per_contiguous_chunk;
-			     j++) {
-				/* some implementation of
-				 * efhw_iopage_init_from_iopages() rely on
-				 * this function being called for
-				 * _all_ pages in the chunk */
-				efhw_iopage_init_from_iopages(
-							&iobrs->bufs[i + j],
-							&iopages, j);
-			}
-		}
-	}
-
-	if (!phys_addr_mode) {
-		unsigned owner_id = EFAB_VI_RESOURCE_INSTANCE(iobrs->evq);
-
-		if (!linked) {
-			/* Allocate space in the NIC's buffer table. */
-			rc = efrm_buffer_table_alloc(fls(iobrs->n_bufs - 1),
-						     &iobrs->buf_tbl_alloc);
-			if (rc < 0) {
-				EFRM_WARN("%s: failed (%d) to alloc %d buffer "
-					  "table entries", __func__, rc,
-					  iobrs->n_bufs);
-				goto fail5;
-			}
-			EFRM_ASSERT(((unsigned)1 << iobrs->buf_tbl_alloc.order)
-				    >= (unsigned) iobrs->n_bufs);
-		} else {
-			iobrs->buf_tbl_alloc = linked->buf_tbl_alloc;
-		}
-
-		/* Initialise the buffer table entries. */
-		for (i = 0; i < iobrs->n_bufs; ++i) {
-			/*\ ?? \TODO burst them! */
-			efrm_buffer_table_set(&iobrs->buf_tbl_alloc,
-					      vi_evq->rs.rs_client->nic,
-					      i,
-					      efhw_iopage_dma_addr(&iobrs->
-								   bufs[i]),
-					      owner_id);
-		}
-		efrm_buffer_table_commit();
-	}
-
-	EFRM_TRACE("%s: " EFRM_RESOURCE_FMT " %d pages @ "
-		   EFHW_BUFFER_ADDR_FMT, __func__,
-		   EFRM_RESOURCE_PRI_ARG(iobrs->rs.rs_handle),
-		   iobrs->n_bufs, EFHW_BUFFER_ADDR(iobrs->buf_tbl_alloc.base,
-						   0));
-	efrm_resource_ref(&iobrs->evq->rs);
-	if (linked != NULL)
-		efrm_resource_ref(&linked->rs);
-	efrm_client_add_resource(vi_evq->rs.rs_client, &iobrs->rs);
-	*iobrs_out = iobrs;
-	return 0;
-
-fail5:
-	i = iobrs->n_bufs;
-fail4:
-	/* see comment on call to efhw_iopage_alloc above for a discussion
-	 * on use of efrm_nic_tablep->a_nic here */
-	if (linked) {
-		/* Nothing to do. */
-	} else if (iobrs->chunk_order == 0) {
-		while (i--) {
-			struct efhw_iopage *page = &iobrs->bufs[i];
-			efhw_iopage_free(efrm_nic_tablep->a_nic, page);
-		}
-	} else {
-		unsigned int j;
-		for (j = 0; j < i; j += iobrs->pages_per_contiguous_chunk) {
-			struct efhw_iopages iopages;
-
-			EFRM_ASSERT(j % iobrs->pages_per_contiguous_chunk
-				    == 0);
-			/* it is important that this is executed in increasing
-			 * page order because some implementations of
-			 * efhw_iopages_init_from_iopage() assume this */
-			efhw_iopages_init_from_iopage(&iopages,
-						      &iobrs->bufs[j],
-						      iobrs->chunk_order);
-			efhw_iopages_free(efrm_nic_tablep->a_nic, &iopages);
-		}
-	}
-fail3:
-	if (object_size < PAGE_SIZE)
-		kfree(iobrs);
-	else
-		vfree(iobrs);
-fail1:
-	return rc;
-}
-EXPORT_SYMBOL(efrm_iobufset_resource_alloc);
-
-static void iobufset_rm_dtor(struct efrm_resource_manager *rm)
-{
-	EFRM_ASSERT(&efrm_iobufset_manager->rm == rm);
-	kfifo_vfree(efrm_iobufset_manager->free_ids);
-}
-
-int
-efrm_create_iobufset_resource_manager(struct efrm_resource_manager **rm_out)
-{
-	int rc, max;
-
-	EFRM_ASSERT(rm_out);
-
-	efrm_iobufset_manager =
-	    kmalloc(sizeof(*efrm_iobufset_manager), GFP_KERNEL);
-	if (efrm_iobufset_manager == 0)
-		return -ENOMEM;
-	memset(efrm_iobufset_manager, 0, sizeof(*efrm_iobufset_manager));
-
-	/*
-	 * Bug 1145, 1370: We need to set initial size of both the resource
-	 * table and instance id table so they never need to grow as we
-	 * want to be allocate new iobufset at tasklet time. Lets make
-	 * a pessimistic guess at maximum number of iobufsets possible.
-	 * Could be less because
-	 *   - jumbo frames have same no of packets per iobufset BUT more
-	 *     pages per buffer
-	 *   - buffer table entries used independently of iobufsets by
-	 *     sendfile
-	 *
-	 * Based on TCP/IP stack setting of PKTS_PER_SET_S=5 ...
-	 *  - can't use this define here as it breaks the layering.
-	 */
-#define MIN_PAGES_PER_IOBUFSET  (1 << 4)
-
-	max = efrm_buffer_table_size() / MIN_PAGES_PER_IOBUFSET;
-	max = min_t(int, max, EFRM_IOBUFSET_MAX_NUM_INSTANCES);
-
-	/* HACK: There currently exists an option to allocate buffers that
-	 * are not programmed into the buffer table, so the max number is
-	 * not limited by the buffer table size.  I'm hoping this usage
-	 * will go away eventually.
-	 */
-	max = 32768;
-
-	rc = efrm_kfifo_id_ctor(&efrm_iobufset_manager->free_ids,
-				0, max, &efrm_iobufset_manager->rm.rm_lock);
-	if (rc != 0)
-		goto fail1;
-
-	rc = efrm_resource_manager_ctor(&efrm_iobufset_manager->rm,
-					iobufset_rm_dtor, "IOBUFSET",
-					EFRM_RESOURCE_IOBUFSET);
-	if (rc < 0)
-		goto fail2;
-
-	*rm_out = &efrm_iobufset_manager->rm;
-	return 0;
-
-fail2:
-	kfifo_vfree(efrm_iobufset_manager->free_ids);
-fail1:
-	EFRM_DO_DEBUG(memset(efrm_iobufset_manager, 0,
-			     sizeof(*efrm_iobufset_manager)));
-	kfree(efrm_iobufset_manager);
-	return rc;
-}
diff -r 9566a4a50a43 drivers/net/sfc/sfc_resource/iopage.c
--- a/drivers/net/sfc/sfc_resource/iopage.c
+++ /dev/null
@@ -1,103 +0,0 @@
-/****************************************************************************
- * Driver for Solarflare network controllers -
- *          resource management for Xen backend, OpenOnload, etc
- *           (including support for SFE4001 10GBT NIC)
- *
- * This file provides Linux-specific implementation for iopage API used
- * from efhw library.
- *
- * Copyright 2005-2007: Solarflare Communications Inc,
- *                      9501 Jeronimo Road, Suite 250,
- *                      Irvine, CA 92618, USA
- *
- * Developed and maintained by Solarflare Communications:
- *                      <linux-xen-drivers@solarflare.com>
- *                      <onload-dev@solarflare.com>
- *
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 as published
- * by the Free Software Foundation, incorporated herein by reference.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
- ****************************************************************************
- */
-
-#include <ci/driver/resource/linux_efhw_nic.h>
-#include "kernel_compat.h"
-#include <ci/efhw/common_sysdep.h> /* for dma_addr_t */
-
-int efhw_iopage_alloc(struct efhw_nic *nic, struct efhw_iopage *p)
-{
-	struct linux_efhw_nic *lnic = linux_efhw_nic(nic);
-	dma_addr_t handle;
-	void *kva;
-
-	kva = efrm_pci_alloc_consistent(lnic->pci_dev, PAGE_SIZE,
-					&handle);
-	if (kva == 0)
-		return -ENOMEM;
-
-	EFHW_ASSERT((handle & ~PAGE_MASK) == 0);
-
-	memset((void *)kva, 0, PAGE_SIZE);
-	efhw_page_init_from_va(&p->p, kva);
-
-	p->dma_addr = handle;
-
-	return 0;
-}
-
-void efhw_iopage_free(struct efhw_nic *nic, struct efhw_iopage *p)
-{
-	struct linux_efhw_nic *lnic = linux_efhw_nic(nic);
-	EFHW_ASSERT(efhw_page_is_valid(&p->p));
-
-	efrm_pci_free_consistent(lnic->pci_dev, PAGE_SIZE,
-				 efhw_iopage_ptr(p), p->dma_addr);
-}
-
-int
-efhw_iopages_alloc(struct efhw_nic *nic, struct efhw_iopages *p,
-		   unsigned order)
-{
-	unsigned bytes = 1u << (order + PAGE_SHIFT);
-	struct linux_efhw_nic *lnic = linux_efhw_nic(nic);
-	dma_addr_t handle;
-	caddr_t addr;
-	int gfp_flag;
-
-	/* Set __GFP_COMP if available to make reference counting work.
-	 * This is recommended here:
-	 *   http://www.forbiddenweb.org/viewtopic.php?id=83167&page=4#348331
-	 */
-	gfp_flag = ((in_atomic() ? GFP_ATOMIC : GFP_KERNEL) | __GFP_COMP);
-	addr = efrm_dma_alloc_coherent(&lnic->pci_dev->dev, bytes, &handle,
-				       gfp_flag);
-	if (addr == NULL)
-		return -ENOMEM;
-
-	EFHW_ASSERT((handle & ~PAGE_MASK) == 0);
-
-	p->order = order;
-	p->dma_addr = handle;
-	p->kva = addr;
-
-	return 0;
-}
-
-void efhw_iopages_free(struct efhw_nic *nic, struct efhw_iopages *p)
-{
-	unsigned bytes = 1u << (p->order + PAGE_SHIFT);
-	struct linux_efhw_nic *lnic = linux_efhw_nic(nic);
-
-	efrm_dma_free_coherent(&lnic->pci_dev->dev, bytes,
-			       (void *)p->kva, p->dma_addr);
-}
diff -r 9566a4a50a43 drivers/net/sfc/sfc_resource/kernel_compat.c
--- a/drivers/net/sfc/sfc_resource/kernel_compat.c
+++ /dev/null
@@ -1,118 +0,0 @@
-/****************************************************************************
- * Driver for Solarflare network controllers -
- *          resource management for Xen backend, OpenOnload, etc
- *           (including support for SFE4001 10GBT NIC)
- *
- * This file provides compatibility layer for various Linux kernel versions
- * (starting from 2.6.9 RHEL kernel).
- *
- * Copyright 2005-2007: Solarflare Communications Inc,
- *                      9501 Jeronimo Road, Suite 250,
- *                      Irvine, CA 92618, USA
- *
- * Developed and maintained by Solarflare Communications:
- *                      <linux-xen-drivers@solarflare.com>
- *                      <onload-dev@solarflare.com>
- *
- * Certain parts of the driver were implemented by
- *          Alexandra Kossovsky <Alexandra.Kossovsky@oktetlabs.ru>
- *          OKTET Labs Ltd, Russia,
- *          http://oktetlabs.ru, <info@oktetlabs.ru>
- *          by request of Solarflare Communications
- *
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 as published
- * by the Free Software Foundation, incorporated herein by reference.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
- ****************************************************************************
- */
-
-#define IN_KERNEL_COMPAT_C
-#include <linux/types.h>
-#include <ci/efrm/debug.h>
-#include "kernel_compat.h"
-
-/* Set this to 1 to enable very basic counting of iopage(s) allocations, then
- * call dump_iopage_counts() to show the number of current allocations of
- * orders 0-7.
- */
-#define EFRM_IOPAGE_COUNTS_ENABLED 0
-
-
-/****************************************************************************
- *
- * allocate a buffer suitable for DMA to/from the NIC
- *
- ****************************************************************************/
-
-#if EFRM_IOPAGE_COUNTS_ENABLED
-
-static int iopage_counts[8];
-
-void dump_iopage_counts(void)
-{
-	EFRM_NOTICE("iopage counts: %d %d %d %d %d %d %d %d", iopage_counts[0],
-		    iopage_counts[1], iopage_counts[2], iopage_counts[3],
-		    iopage_counts[4], iopage_counts[5], iopage_counts[6],
-		    iopage_counts[7]);
-}
-
-#endif
-
-
-
-/*********** pci_alloc_consistent / pci_free_consistent ***********/
-
-void *efrm_dma_alloc_coherent(struct device *dev, size_t size,
-			      dma_addr_t *dma_addr, int flag)
-{
-	void *ptr;
-	unsigned order;
-
-	order = __ffs(size/PAGE_SIZE);
-	EFRM_ASSERT(size == (PAGE_SIZE<<order));
-
-	/* Can't take a spinlock here since the allocation can
-	 * block. */
-	ptr = dma_alloc_coherent(dev, size, dma_addr, flag);
-	if (ptr == NULL)
-		return ptr;
-
-#if EFRM_IOPAGE_COUNTS_ENABLED
-	if (order < 8)
-		iopage_counts[order]++;
-	else
-		EFRM_ERR("Huge iopages alloc (order=%d) ??? (not counted)",
-			 order);
-#endif
-
-	return ptr;
-}
-
-void efrm_dma_free_coherent(struct device *dev, size_t size,
-			    void *ptr, dma_addr_t dma_addr)
-{
-	unsigned order;
-
-	order = __ffs(size/PAGE_SIZE);
-	EFRM_ASSERT(size == (PAGE_SIZE<<order));
-
-#if EFRM_IOPAGE_COUNTS_ENABLED
-	if (order < 8)
-		--iopage_counts[order];
-	else
-		EFRM_ERR("Huge iopages free (order=%d) ??? (not counted)",
-			 order);
-#endif
-
-	dma_free_coherent(dev, size, ptr, dma_addr);
-}
diff -r 9566a4a50a43 drivers/net/sfc/sfc_resource/kernel_compat.h
--- a/drivers/net/sfc/sfc_resource/kernel_compat.h
+++ /dev/null
@@ -1,70 +0,0 @@
-/****************************************************************************
- * Driver for Solarflare network controllers -
- *          resource management for Xen backend, OpenOnload, etc
- *           (including support for SFE4001 10GBT NIC)
- *
- * This file provides compatibility layer for various Linux kernel versions
- * (starting from 2.6.9 RHEL kernel).
- *
- * Copyright 2005-2007: Solarflare Communications Inc,
- *                      9501 Jeronimo Road, Suite 250,
- *                      Irvine, CA 92618, USA
- *
- * Developed and maintained by Solarflare Communications:
- *                      <linux-xen-drivers@solarflare.com>
- *                      <onload-dev@solarflare.com>
- *
- * Certain parts of the driver were implemented by
- *          Alexandra Kossovsky <Alexandra.Kossovsky@oktetlabs.ru>
- *          OKTET Labs Ltd, Russia,
- *          http://oktetlabs.ru, <info@oktetlabs.ru>
- *          by request of Solarflare Communications
- *
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 as published
- * by the Free Software Foundation, incorporated herein by reference.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
- ****************************************************************************
- */
-
-#ifndef DRIVER_LINUX_RESOURCE_KERNEL_COMPAT_H
-#define DRIVER_LINUX_RESOURCE_KERNEL_COMPAT_H
-
-#include <linux/moduleparam.h>
-#include <linux/sched.h>
-#include <linux/io.h>
-#include <linux/pci.h>
-
-/********* pci_map_*() ********************/
-
-extern void *efrm_dma_alloc_coherent(struct device *dev, size_t size,
-				     dma_addr_t *dma_addr, int flag);
-
-extern void efrm_dma_free_coherent(struct device *dev, size_t size,
-				   void *ptr, dma_addr_t dma_addr);
-
-static inline void *efrm_pci_alloc_consistent(struct pci_dev *hwdev,
-					      size_t size,
-					      dma_addr_t *dma_addr)
-{
-	return efrm_dma_alloc_coherent(&hwdev->dev, size, dma_addr,
-				       GFP_ATOMIC);
-}
-
-static inline void efrm_pci_free_consistent(struct pci_dev *hwdev, size_t size,
-					    void *ptr, dma_addr_t dma_addr)
-{
-	efrm_dma_free_coherent(&hwdev->dev, size, ptr, dma_addr);
-}
-
-
-#endif /* DRIVER_LINUX_RESOURCE_KERNEL_COMPAT_H */
diff -r 9566a4a50a43 drivers/net/sfc/sfc_resource/kernel_proc.c
--- a/drivers/net/sfc/sfc_resource/kernel_proc.c
+++ /dev/null
@@ -1,109 +0,0 @@
-/****************************************************************************
- * Driver for Solarflare network controllers -
- *          resource management for Xen backend, OpenOnload, etc
- *           (including support for SFE4001 10GBT NIC)
- *
- * This file contains /proc/driver/sfc_resource/ implementation.
- *
- * Copyright 2005-2007: Solarflare Communications Inc,
- *                      9501 Jeronimo Road, Suite 250,
- *                      Irvine, CA 92618, USA
- *
- * Developed and maintained by Solarflare Communications:
- *                      <linux-xen-drivers@solarflare.com>
- *                      <onload-dev@solarflare.com>
- *
- * Certain parts of the driver were implemented by
- *          Alexandra Kossovsky <Alexandra.Kossovsky@oktetlabs.ru>
- *          OKTET Labs Ltd, Russia,
- *          http://oktetlabs.ru, <info@oktetlabs.ru>
- *          by request of Solarflare Communications
- *
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 as published
- * by the Free Software Foundation, incorporated herein by reference.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
- ****************************************************************************
- */
-
-#include <ci/efrm/debug.h>
-#include <ci/efrm/driver_private.h>
-#include <linux/proc_fs.h>
-
-/** Top level directory for sfc specific stats **/
-static struct proc_dir_entry *efrm_proc_root; /* = NULL */
-
-static int
-efrm_resource_read_proc(char *buf, char **start, off_t offset, int count,
-			int *eof, void *data);
-
-int efrm_install_proc_entries(void)
-{
-	/* create the top-level directory for etherfabric specific stuff */
-	efrm_proc_root = proc_mkdir("driver/sfc_resource", NULL);
-	if (!efrm_proc_root)
-		return -ENOMEM;
-
-	if (create_proc_read_entry("resources", 0, efrm_proc_root,
-				   efrm_resource_read_proc, 0) == NULL) {
-		EFRM_WARN("%s: Unable to create /proc/drivers/sfc_resource/"
-			  "resources", __func__);
-	}
-	return 0;
-}
-
-void efrm_uninstall_proc_entries(void)
-{
-	EFRM_ASSERT(efrm_proc_root);
-	remove_proc_entry("resources", efrm_proc_root);
-	remove_proc_entry(efrm_proc_root->name, efrm_proc_root->parent);
-	efrm_proc_root = NULL;
-}
-
-/****************************************************************************
- *
- * /proc/drivers/sfc/resources
- *
- ****************************************************************************/
-
-#define EFRM_PROC_PRINTF(buf, len, fmt, ...)				\
-	do {								\
-		if (count - len > 0)					\
-			len += snprintf(buf+len, count-len, (fmt),	\
-					__VA_ARGS__);			\
-	} while (0)
-
-static int
-efrm_resource_read_proc(char *buf, char **start, off_t offset, int count,
-			int *eof, void *data)
-{
-	irq_flags_t lock_flags;
-	int len = 0;
-	int type;
-	struct efrm_resource_manager *rm;
-
-	for (type = 0; type < EFRM_RESOURCE_NUM; type++) {
-		rm = efrm_rm_table[type];
-		if (rm == NULL)
-			continue;
-
-		EFRM_PROC_PRINTF(buf, len, "*** %s ***\n", rm->rm_name);
-
-		spin_lock_irqsave(&rm->rm_lock, lock_flags);
-		EFRM_PROC_PRINTF(buf, len, "current = %u\n", rm->rm_resources);
-		EFRM_PROC_PRINTF(buf, len, "    max = %u\n\n",
-				 rm->rm_resources_hiwat);
-		spin_unlock_irqrestore(&rm->rm_lock, lock_flags);
-	}
-
-	return count ? strlen(buf) : 0;
-}
diff -r 9566a4a50a43 drivers/net/sfc/sfc_resource/kfifo.c
--- a/drivers/net/sfc/sfc_resource/kfifo.c
+++ /dev/null
@@ -1,208 +0,0 @@
-/*
- * A simple kernel FIFO implementation.
- *
- * Copyright (C) 2004 Stelian Pop <stelian@popies.net>
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
- *
- */
-
-/*
- * This file is stolen from the Linux kernel sources
- * (linux-2.6.22/kernel/kfifo.c) into sfc_resource driver.
- * It should be used for old kernels without kfifo implementation.
- * Most part of linux/kfifo.h is incorporated into
- * ci/efrm/sysdep_linux.h.
- */
-#include <ci/efrm/sysdep_linux.h>
-#ifdef HAS_NO_KFIFO
-
-#include <linux/kernel.h>
-#include <linux/module.h>
-#include <linux/slab.h>
-#include <linux/err.h>
-/*#include <linux/kfifo.h>*/
-
-/**
- * kfifo_init - allocates a new FIFO using a preallocated buffer
- * @buffer: the preallocated buffer to be used.
- * @size: the size of the internal buffer, this have to be a power of 2.
- * @gfp_mask: get_free_pages mask, passed to kmalloc()
- * @lock: the lock to be used to protect the fifo buffer
- *
- * Do NOT pass the kfifo to kfifo_free() after use! Simply free the
- * &struct kfifo with kfree().
- */
-struct kfifo *kfifo_init(unsigned char *buffer, unsigned int size,
-			 gfp_t gfp_mask, spinlock_t *lock)
-{
-	struct kfifo *fifo;
-
-	/* size must be a power of 2 */
-	BUG_ON(size & (size - 1));
-
-	fifo = kmalloc(sizeof(struct kfifo), gfp_mask);
-	if (!fifo)
-		return ERR_PTR(-ENOMEM);
-
-	fifo->buffer = buffer;
-	fifo->size = size;
-	fifo->in = fifo->out = 0;
-	fifo->lock = lock;
-
-	return fifo;
-}
-EXPORT_SYMBOL(kfifo_init);
-
-/**
- * kfifo_alloc - allocates a new FIFO and its internal buffer
- * @size: the size of the internal buffer to be allocated.
- * @gfp_mask: get_free_pages mask, passed to kmalloc()
- * @lock: the lock to be used to protect the fifo buffer
- *
- * The size will be rounded-up to a power of 2.
- */
-struct kfifo *kfifo_alloc(unsigned int size, gfp_t gfp_mask, spinlock_t *lock)
-{
-	unsigned char *buffer;
-	struct kfifo *ret;
-
-	/*
-	 * round up to the next power of 2, since our 'let the indices
-	 * wrap' tachnique works only in this case.
-	 */
-	if (size & (size - 1)) {
-		BUG_ON(size > 0x80000000);
-		size = roundup_pow_of_two(size);
-	}
-
-	buffer = kmalloc(size, gfp_mask);
-	if (!buffer)
-		return ERR_PTR(-ENOMEM);
-
-	ret = kfifo_init(buffer, size, gfp_mask, lock);
-
-	if (IS_ERR(ret))
-		kfree(buffer);
-
-	return ret;
-}
-EXPORT_SYMBOL(kfifo_alloc);
-
-/**
- * kfifo_free - frees the FIFO
- * @fifo: the fifo to be freed.
- */
-void kfifo_free(struct kfifo *fifo)
-{
-	kfree(fifo->buffer);
-	kfree(fifo);
-}
-EXPORT_SYMBOL(kfifo_free);
-
-/**
- * __kfifo_put - puts some data into the FIFO, no locking version
- * @fifo: the fifo to be used.
- * @buffer: the data to be added.
- * @len: the length of the data to be added.
- *
- * This function copies at most @len bytes from the @buffer into
- * the FIFO depending on the free space, and returns the number of
- * bytes copied.
- *
- * Note that with only one concurrent reader and one concurrent
- * writer, you don't need extra locking to use these functions.
- */
-unsigned int
-__kfifo_put(struct kfifo *fifo, unsigned char *buffer, unsigned int len)
-{
-	unsigned int l;
-
-	len = min(len, fifo->size - fifo->in + fifo->out);
-
-	/*
-	 * Ensure that we sample the fifo->out index -before- we
-	 * start putting bytes into the kfifo.
-	 */
-
-	smp_mb();
-
-	/* first put the data starting from fifo->in to buffer end */
-	l = min(len, fifo->size - (fifo->in & (fifo->size - 1)));
-	memcpy(fifo->buffer + (fifo->in & (fifo->size - 1)), buffer, l);
-
-	/* then put the rest (if any) at the beginning of the buffer */
-	memcpy(fifo->buffer, buffer + l, len - l);
-
-	/*
-	 * Ensure that we add the bytes to the kfifo -before-
-	 * we update the fifo->in index.
-	 */
-
-	smp_wmb();
-
-	fifo->in += len;
-
-	return len;
-}
-EXPORT_SYMBOL(__kfifo_put);
-
-/**
- * __kfifo_get - gets some data from the FIFO, no locking version
- * @fifo: the fifo to be used.
- * @buffer: where the data must be copied.
- * @len: the size of the destination buffer.
- *
- * This function copies at most @len bytes from the FIFO into the
- * @buffer and returns the number of copied bytes.
- *
- * Note that with only one concurrent reader and one concurrent
- * writer, you don't need extra locking to use these functions.
- */
-unsigned int
-__kfifo_get(struct kfifo *fifo, unsigned char *buffer, unsigned int len)
-{
-	unsigned int l;
-
-	len = min(len, fifo->in - fifo->out);
-
-	/*
-	 * Ensure that we sample the fifo->in index -before- we
-	 * start removing bytes from the kfifo.
-	 */
-
-	smp_rmb();
-
-	/* first get the data from fifo->out until the end of the buffer */
-	l = min(len, fifo->size - (fifo->out & (fifo->size - 1)));
-	memcpy(buffer, fifo->buffer + (fifo->out & (fifo->size - 1)), l);
-
-	/* then get the rest (if any) from the beginning of the buffer */
-	memcpy(buffer + l, fifo->buffer, len - l);
-
-	/*
-	 * Ensure that we remove the bytes from the kfifo -before-
-	 * we update the fifo->out index.
-	 */
-
-	smp_mb();
-
-	fifo->out += len;
-
-	return len;
-}
-EXPORT_SYMBOL(__kfifo_get);
-
-#endif
diff -r 9566a4a50a43 drivers/net/sfc/sfc_resource/linux_resource_internal.h
--- a/drivers/net/sfc/sfc_resource/linux_resource_internal.h
+++ /dev/null
@@ -1,76 +0,0 @@
-/****************************************************************************
- * Driver for Solarflare network controllers -
- *          resource management for Xen backend, OpenOnload, etc
- *           (including support for SFE4001 10GBT NIC)
- *
- * This file contains Linux-specific API internal for the resource driver.
- *
- * Copyright 2005-2007: Solarflare Communications Inc,
- *                      9501 Jeronimo Road, Suite 250,
- *                      Irvine, CA 92618, USA
- *
- * Developed and maintained by Solarflare Communications:
- *                      <linux-xen-drivers@solarflare.com>
- *                      <onload-dev@solarflare.com>
- *
- * Certain parts of the driver were implemented by
- *          Alexandra Kossovsky <Alexandra.Kossovsky@oktetlabs.ru>
- *          OKTET Labs Ltd, Russia,
- *          http://oktetlabs.ru, <info@oktetlabs.ru>
- *          by request of Solarflare Communications
- *
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 as published
- * by the Free Software Foundation, incorporated herein by reference.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
- ****************************************************************************
- */
-
-#ifndef __LINUX_RESOURCE_INTERNAL__
-#define __LINUX_RESOURCE_INTERNAL__
-
-#include <ci/driver/resource/linux_efhw_nic.h>
-#include <ci/efrm/debug.h>
-#include <ci/efrm/driver_private.h>
-#include <ci/driver/efab/hardware.h>
-
-
-/*! Linux specific EtherFabric initialisation */
-extern int
-linux_efrm_nic_ctor(struct linux_efhw_nic *, struct pci_dev *,
-		    spinlock_t *reg_lock,
-		    unsigned nic_flags, unsigned nic_options);
-
-/*! Linux specific EtherFabric initialisation */
-extern void linux_efrm_nic_dtor(struct linux_efhw_nic *);
-
-/*! Linux specific EtherFabric initialisation -- interrupt registration */
-extern int linux_efrm_irq_ctor(struct linux_efhw_nic *);
-
-/*! Linux specific  EtherFabric initialisation -- interrupt deregistration */
-extern void linux_efrm_irq_dtor(struct linux_efhw_nic *);
-
-extern int  efrm_driverlink_register(void);
-extern void efrm_driverlink_unregister(void);
-
-extern int
-efrm_nic_add(struct pci_dev *dev, unsigned int opts, const uint8_t *mac_addr,
-	     struct linux_efhw_nic **lnic_out, spinlock_t *reg_lock,
-	     int bt_min, int bt_max, int non_irq_evq,
-	     const struct vi_resource_dimensions *);
-extern void efrm_nic_del(struct linux_efhw_nic *);
-
-
-extern int efrm_install_proc_entries(void);
-extern void efrm_uninstall_proc_entries(void);
-
-#endif  /* __LINUX_RESOURCE_INTERNAL__ */
diff -r 9566a4a50a43 drivers/net/sfc/sfc_resource/nic.c
--- a/drivers/net/sfc/sfc_resource/nic.c
+++ /dev/null
@@ -1,176 +0,0 @@
-/****************************************************************************
- * Driver for Solarflare network controllers -
- *          resource management for Xen backend, OpenOnload, etc
- *           (including support for SFE4001 10GBT NIC)
- *
- * This file contains EtherFabric Generic NIC instance (init, interrupts,
- * etc)
- *
- * Copyright 2005-2007: Solarflare Communications Inc,
- *                      9501 Jeronimo Road, Suite 250,
- *                      Irvine, CA 92618, USA
- *
- * Developed and maintained by Solarflare Communications:
- *                      <linux-xen-drivers@solarflare.com>
- *                      <onload-dev@solarflare.com>
- *
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 as published
- * by the Free Software Foundation, incorporated herein by reference.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
- ****************************************************************************
- */
-
-#include <ci/efhw/debug.h>
-#include <ci/driver/efab/hardware.h>
-#include <ci/efhw/falcon.h>
-#include <ci/efhw/nic.h>
-#include <ci/efhw/eventq.h>
-
-
-int efhw_device_type_init(struct efhw_device_type *dt,
-			  int vendor_id, int device_id,
-			  int class_revision)
-{
-	if (vendor_id != 0x1924)
-		return 0;
-
-	switch (device_id) {
-	case 0x0703:
-	case 0x6703:
-		dt->arch = EFHW_ARCH_FALCON;
-		dt->variant = 'A';
-		switch (class_revision) {
-		case 0:
-			dt->revision = 0;
-			break;
-		case 1:
-			dt->revision = 1;
-			break;
-		default:
-			return 0;
-		}
-		break;
-	case 0x0710:
-		dt->arch = EFHW_ARCH_FALCON;
-		dt->variant = 'B';
-		switch (class_revision) {
-		case 2:
-			dt->revision = 0;
-			break;
-		default:
-			return 0;
-		}
-		break;
-	default:
-		return 0;
-	}
-
-	return 1;
-}
-
-
-/*--------------------------------------------------------------------
- *
- * NIC Initialisation
- *
- *--------------------------------------------------------------------*/
-
-/* make this separate from initialising data structure
-** to allow this to be called at a later time once we can access PCI
-** config space to find out what hardware we have
-*/
-void efhw_nic_init(struct efhw_nic *nic, unsigned flags, unsigned options,
-		   struct efhw_device_type dev_type)
-{
-	nic->devtype = dev_type;
-	nic->flags = flags;
-	nic->options = options;
-	nic->bar_ioaddr = 0;
-	spin_lock_init(&nic->the_reg_lock);
-	nic->reg_lock = &nic->the_reg_lock;
-	nic->mtu = 1500 + ETH_HLEN;
-
-	nic->irq_unit = EFHW_IRQ_UNIT_UNUSED;
-
-	nic->evq_sizes = 512 | 1024 | 2048 | 4096 | 8192 |
-		16384 | 32768;
-	nic->txq_sizes = 512 | 1024 | 2048 | 4096;
-	nic->rxq_sizes = 512 | 1024 | 2048 | 4096;
-	nic->efhw_func = &falcon_char_functional_units;
-	nic->ctr_ap_bytes = EFHW_64M;
-	switch (nic->devtype.variant) {
-	case 'A':
-		nic->ctr_ap_bar = FALCON_S_CTR_AP_BAR;
-		nic->num_evqs   = 4096;
-		nic->num_dmaqs  = 4096;
-		nic->num_timers = 4096;
-		break;
-	case 'B':
-		nic->flags |= NIC_FLAG_NO_INTERRUPT;
-		nic->ctr_ap_bar = FALCON_P_CTR_AP_BAR;
-		nic->num_evqs   = 4096;
-		nic->num_dmaqs  = 4096;
-		nic->num_timers = 4096;
-		break;
-	default:
-		EFHW_ASSERT(0);
-		break;
-	}
-}
-
-
-void efhw_nic_close_interrupts(struct efhw_nic *nic)
-{
-	EFHW_ASSERT(nic);
-	if (!efhw_nic_have_hw(nic))
-		return;
-
-	EFHW_ASSERT(efhw_nic_have_hw(nic));
-
-	if (nic->irq_unit != EFHW_IRQ_UNIT_UNUSED)
-		efhw_nic_interrupt_disable(nic);
-}
-
-void efhw_nic_dtor(struct efhw_nic *nic)
-{
-	EFHW_ASSERT(nic);
-
-	/* Check that we have functional units because the software only
-	 * driver doesn't initialise anything hardware related any more */
-
-	/* close interrupts is called first because the act of deregistering
-	   the driver could cause this driver to change from master to slave
-	   and hence the implicit interrupt mappings would be wrong */
-
-	EFHW_TRACE("%s: functional units ... ", __func__);
-
-	if (efhw_nic_have_functional_units(nic)) {
-		efhw_nic_close_interrupts(nic);
-		efhw_nic_close_hardware(nic);
-	}
-	EFHW_TRACE("%s: functional units ... done", __func__);
-
-	/* destroy event queues */
-	EFHW_TRACE("%s: event queues ... ", __func__);
-
-	if (nic->interrupting_evq.evq_mask)
-		efhw_keventq_dtor(nic, &nic->interrupting_evq);
-	if (nic->non_interrupting_evq.evq_mask)
-		efhw_keventq_dtor(nic, &nic->non_interrupting_evq);
-
-	EFHW_TRACE("%s: event queues ... done", __func__);
-
-	spin_lock_destroy(&nic->the_reg_lock);
-
-	EFHW_TRACE("%s: DONE", __func__);
-}
diff -r 9566a4a50a43 drivers/net/sfc/sfc_resource/resource_driver.c
--- a/drivers/net/sfc/sfc_resource/resource_driver.c
+++ /dev/null
@@ -1,600 +0,0 @@
-/****************************************************************************
- * Driver for Solarflare network controllers -
- *          resource management for Xen backend, OpenOnload, etc
- *           (including support for SFE4001 10GBT NIC)
- *
- * This file contains main driver entry points.
- *
- * Copyright 2005-2007: Solarflare Communications Inc,
- *                      9501 Jeronimo Road, Suite 250,
- *                      Irvine, CA 92618, USA
- *
- * Developed and maintained by Solarflare Communications:
- *                      <linux-xen-drivers@solarflare.com>
- *                      <onload-dev@solarflare.com>
- *
- * Certain parts of the driver were implemented by
- *          Alexandra Kossovsky <Alexandra.Kossovsky@oktetlabs.ru>
- *          OKTET Labs Ltd, Russia,
- *          http://oktetlabs.ru, <info@oktetlabs.ru>
- *          by request of Solarflare Communications
- *
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 as published
- * by the Free Software Foundation, incorporated herein by reference.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
- ****************************************************************************
- */
-
-#include "linux_resource_internal.h"
-#include "kernel_compat.h"
-#include <ci/efrm/nic_table.h>
-#include <ci/driver/resource/efx_vi.h>
-#include <ci/efhw/eventq.h>
-#include <ci/efhw/nic.h>
-#include <ci/efrm/buffer_table.h>
-#include <ci/efrm/vi_resource_private.h>
-#include <ci/efrm/driver_private.h>
-
-MODULE_AUTHOR("Solarflare Communications");
-MODULE_LICENSE("GPL");
-
-static struct efhw_ev_handler ev_handler = {
-	.wakeup_fn = efrm_handle_wakeup_event,
-	.timeout_fn = efrm_handle_timeout_event,
-	.dmaq_flushed_fn = efrm_handle_dmaq_flushed,
-};
-
-const int max_hardware_init_repeats = 10;
-
-/*--------------------------------------------------------------------
- *
- * Module load time variables
- *
- *--------------------------------------------------------------------*/
-/* See docs/notes/pci_alloc_consistent */
-static int do_irq = 1;		/* enable interrupts */
-
-#if defined(CONFIG_X86_XEN)
-static int irq_moderation = 60;	/* interrupt moderation (60 usec) */
-#else
-static int irq_moderation = 20;	/* interrupt moderation (20 usec) */
-#endif
-static int nic_options = NIC_OPT_DEFAULT;
-int efx_vi_eventq_size = EFX_VI_EVENTQ_SIZE_DEFAULT;
-
-module_param(do_irq, int, S_IRUGO);
-MODULE_PARM_DESC(do_irq, "Enable interrupts.  "
-		 "Do not turn it off unless you know what are you doing.");
-module_param(irq_moderation, int, S_IRUGO);
-MODULE_PARM_DESC(irq_moderation, "IRQ moderation in usec");
-module_param(nic_options, int, S_IRUGO);
-MODULE_PARM_DESC(nic_options, "Nic options -- see efhw_types.h");
-module_param(efx_vi_eventq_size, int, S_IRUGO);
-MODULE_PARM_DESC(efx_vi_eventq_size,
-		 "Size of event queue allocated by efx_vi library");
-
-/*--------------------------------------------------------------------
- *
- * Linux specific NIC initialisation
- *
- *--------------------------------------------------------------------*/
-
-static inline irqreturn_t
-linux_efrm_interrupt(int irr, void *dev_id)
-{
-	return efhw_nic_interrupt((struct efhw_nic *)dev_id);
-}
-
-int linux_efrm_irq_ctor(struct linux_efhw_nic *lnic)
-{
-	struct efhw_nic *nic = &lnic->efrm_nic.efhw_nic;
-
-	nic->flags &= ~NIC_FLAG_MSI;
-	if (nic->flags & NIC_FLAG_TRY_MSI) {
-		int rc = pci_enable_msi(lnic->pci_dev);
-		if (rc < 0) {
-			EFRM_WARN("%s: Could not enable MSI (%d)",
-				  __func__, rc);
-			EFRM_WARN("%s: Continuing with legacy interrupt mode",
-				  __func__);
-		} else {
-			EFRM_NOTICE("%s: MSI enabled", __func__);
-			nic->flags |= NIC_FLAG_MSI;
-		}
-	}
-
-	if (request_irq(lnic->pci_dev->irq, linux_efrm_interrupt,
-			IRQF_SHARED, "sfc_resource", nic)) {
-		EFRM_ERR("Request for interrupt #%d failed",
-			 lnic->pci_dev->irq);
-		nic->flags &= ~NIC_FLAG_OS_IRQ_EN;
-		return -EBUSY;
-	}
-	nic->flags |= NIC_FLAG_OS_IRQ_EN;
-
-	return 0;
-}
-
-void linux_efrm_irq_dtor(struct linux_efhw_nic *lnic)
-{
-	EFRM_TRACE("%s: start", __func__);
-
-	if (lnic->efrm_nic.efhw_nic.flags & NIC_FLAG_OS_IRQ_EN) {
-		free_irq(lnic->pci_dev->irq, &lnic->efrm_nic.efhw_nic);
-		lnic->efrm_nic.efhw_nic.flags &= ~NIC_FLAG_OS_IRQ_EN;
-	}
-
-	if (lnic->efrm_nic.efhw_nic.flags & NIC_FLAG_MSI) {
-		pci_disable_msi(lnic->pci_dev);
-		lnic->efrm_nic.efhw_nic.flags &= ~NIC_FLAG_MSI;
-	}
-
-	EFRM_TRACE("%s: done", __func__);
-}
-
-/* Allocate buffer table entries for a particular NIC.
- */
-static int efrm_nic_buffer_table_alloc(struct efhw_nic *nic)
-{
-	int capacity;
-	int page_order;
-	int rc;
-
-	/* Choose queue size. */
-	for (capacity = 8192; capacity <= nic->evq_sizes; capacity <<= 1) {
-		if (capacity > nic->evq_sizes) {
-			EFRM_ERR
-			    ("%s: Unable to choose EVQ size (supported=%x)",
-			     __func__, nic->evq_sizes);
-			return -E2BIG;
-		} else if (capacity & nic->evq_sizes)
-			break;
-	}
-
-	nic->interrupting_evq.hw.capacity = capacity;
-	nic->interrupting_evq.hw.buf_tbl_alloc.base = (unsigned)-1;
-
-	nic->non_interrupting_evq.hw.capacity = capacity;
-	nic->non_interrupting_evq.hw.buf_tbl_alloc.base = (unsigned)-1;
-
-	/* allocate buffer table entries to map onto the iobuffer */
-	page_order = get_order(capacity * sizeof(efhw_event_t));
-	if (!(nic->flags & NIC_FLAG_NO_INTERRUPT)) {
-		rc = efrm_buffer_table_alloc(page_order,
-					     &nic->interrupting_evq
-					     .hw.buf_tbl_alloc);
-		if (rc < 0) {
-			EFRM_WARN
-			    ("%s: failed (%d) to alloc %d buffer table entries",
-			     __func__, rc, page_order);
-			return rc;
-		}
-	}
-	rc = efrm_buffer_table_alloc(page_order,
-				     &nic->non_interrupting_evq.hw.
-				     buf_tbl_alloc);
-	if (rc < 0) {
-		EFRM_WARN
-		    ("%s: failed (%d) to alloc %d buffer table entries",
-		     __func__, rc, page_order);
-		return rc;
-	}
-
-	return 0;
-}
-
-/* Free buffer table entries allocated for a particular NIC.
- */
-static void efrm_nic_buffer_table_free(struct efhw_nic *nic)
-{
-	if (nic->interrupting_evq.hw.buf_tbl_alloc.base != (unsigned)-1)
-		efrm_buffer_table_free(&nic->interrupting_evq.hw
-				       .buf_tbl_alloc);
-	if (nic->non_interrupting_evq.hw.buf_tbl_alloc.base != (unsigned)-1)
-		efrm_buffer_table_free(&nic->non_interrupting_evq
-				       .hw.buf_tbl_alloc);
-}
-
-static int iomap_bar(struct linux_efhw_nic *lnic, size_t len)
-{
-	volatile char __iomem *ioaddr;
-
-	ioaddr = ioremap_nocache(lnic->ctr_ap_pci_addr, len);
-	if (ioaddr == 0)
-		return -ENOMEM;
-
-	lnic->efrm_nic.efhw_nic.bar_ioaddr = ioaddr;
-	return 0;
-}
-
-static int linux_efhw_nic_map_ctr_ap(struct linux_efhw_nic *lnic)
-{
-	struct efhw_nic *nic = &lnic->efrm_nic.efhw_nic;
-	int rc;
-
-	rc = iomap_bar(lnic, nic->ctr_ap_bytes);
-
-	/* Bug 5195: workaround for now. */
-	if (rc != 0 && nic->ctr_ap_bytes > 16 * 1024 * 1024) {
-		/* Try half the size for now. */
-		nic->ctr_ap_bytes /= 2;
-		EFRM_WARN("Bug 5195 WORKAROUND: retrying iomap of %d bytes",
-			  nic->ctr_ap_bytes);
-		rc = iomap_bar(lnic, nic->ctr_ap_bytes);
-	}
-
-	if (rc < 0) {
-		EFRM_ERR("Failed (%d) to map bar (%d bytes)",
-			 rc, nic->ctr_ap_bytes);
-		return rc;
-	}
-
-	return rc;
-}
-
-int
-linux_efrm_nic_ctor(struct linux_efhw_nic *lnic, struct pci_dev *dev,
-		    spinlock_t *reg_lock,
-		    unsigned nic_flags, unsigned nic_options)
-{
-	struct efhw_device_type dev_type;
-	struct efhw_nic *nic = &lnic->efrm_nic.efhw_nic;
-	u8 class_revision;
-	int rc;
-
-	rc = pci_read_config_byte(dev, PCI_CLASS_REVISION, &class_revision);
-	if (rc != 0) {
-		EFRM_ERR("%s: pci_read_config_byte failed (%d)",
-			 __func__, rc);
-		return rc;
-	}
-
-	if (!efhw_device_type_init(&dev_type, dev->vendor, dev->device,
-				   class_revision)) {
-		EFRM_ERR("%s: efhw_device_type_init failed %04x:%04x(%d)",
-			 __func__, (unsigned) dev->vendor,
-			 (unsigned) dev->device, (int) class_revision);
-		return -ENODEV;
-	}
-
-	EFRM_NOTICE("attaching device type %04x:%04x %d:%c%d",
-		    (unsigned) dev->vendor, (unsigned) dev->device,
-		    dev_type.arch, dev_type.variant, dev_type.revision);
-
-	/* Initialise the adapter-structure. */
-	efhw_nic_init(nic, nic_flags, nic_options, dev_type);
-	lnic->pci_dev = dev;
-
-	rc = pci_enable_device(dev);
-	if (rc < 0) {
-		EFRM_ERR("%s: pci_enable_device failed (%d)",
-			 __func__, rc);
-		return rc;
-	}
-
-	lnic->ctr_ap_pci_addr = pci_resource_start(dev, nic->ctr_ap_bar);
-
-	if (!pci_dma_supported(dev, (dma_addr_t)EFHW_DMA_ADDRMASK)) {
-		EFRM_ERR("%s: pci_dma_supported(%lx) failed", __func__,
-			 (unsigned long)EFHW_DMA_ADDRMASK);
-		return -ENODEV;
-	}
-
-	if (pci_set_dma_mask(dev, (dma_addr_t)EFHW_DMA_ADDRMASK)) {
-		EFRM_ERR("%s: pci_set_dma_mask(%lx) failed", __func__,
-			 (unsigned long)EFHW_DMA_ADDRMASK);
-		return -ENODEV;
-	}
-
-	if (pci_set_consistent_dma_mask(dev, (dma_addr_t)EFHW_DMA_ADDRMASK)) {
-		EFRM_ERR("%s: pci_set_consistent_dma_mask(%lx) failed",
-			 __func__, (unsigned long)EFHW_DMA_ADDRMASK);
-		return -ENODEV;
-	}
-
-	rc = linux_efhw_nic_map_ctr_ap(lnic);
-	if (rc < 0)
-		return rc;
-
-	/* By default struct efhw_nic contains its own lock for protecting
-	 * access to nic registers.  We override it with a pointer to the
-	 * lock in the net driver.  This is needed when resource and net
-	 * drivers share a single PCI function (falcon B series).
-	 */
-	nic->reg_lock = reg_lock;
-	return 0;
-}
-
-void linux_efrm_nic_dtor(struct linux_efhw_nic *lnic)
-{
-	struct efhw_nic *nic = &lnic->efrm_nic.efhw_nic;
-	volatile char __iomem *bar_ioaddr = nic->bar_ioaddr;
-
-	efhw_nic_dtor(nic);
-
-	/* Unmap the bar. */
-	EFRM_ASSERT(bar_ioaddr);
-	iounmap(bar_ioaddr);
-	nic->bar_ioaddr = 0;
-}
-
-/****************************************************************************
- *
- * efrm_tasklet - used to poll the eventq which may result in further callbacks
- *
- ****************************************************************************/
-
-static void efrm_tasklet(unsigned long pdev)
-{
-	struct efhw_nic *nic = (struct efhw_nic *)pdev;
-
-	EFRM_ASSERT(!(nic->flags & NIC_FLAG_NO_INTERRUPT));
-
-	efhw_keventq_poll(nic, &nic->interrupting_evq);
-	EFRM_TRACE("%s: complete", __func__);
-}
-
-/****************************************************************************
- *
- * char driver specific interrupt callbacks -- run at hard IRQL
- *
- ****************************************************************************/
-static void efrm_handle_eventq_irq(struct efhw_nic *nic, int evq)
-{
-	/* NB. The interrupt must have already been acked (for legacy mode). */
-
-	EFRM_TRACE("%s: starting tasklet", __func__);
-	EFRM_ASSERT(!(nic->flags & NIC_FLAG_NO_INTERRUPT));
-
-	tasklet_schedule(&linux_efhw_nic(nic)->tasklet);
-}
-
-/* A count of how many NICs this driver knows about. */
-static int n_nics_probed;
-
-/****************************************************************************
- *
- * efrm_nic_add: add the NIC to the resource driver
- *
- * NOTE: the flow of control through this routine is quite subtle
- * because of the number of operations that can fail. We therefore
- * take the apporaching of keeping the return code (rc) variable
- * accurate, and only do operations while it is non-negative. Tear down
- * is done at the end if rc is negative, depending on what has been set up
- * by that point.
- *
- * So basically just make sure that any code you add checks rc>=0 before
- * doing any work and you'll be fine.
- *
- ****************************************************************************/
-int
-efrm_nic_add(struct pci_dev *dev, unsigned flags, const uint8_t *mac_addr,
-	     struct linux_efhw_nic **lnic_out, spinlock_t *reg_lock,
-	     int bt_min, int bt_lim, int non_irq_evq,
-	     const struct vi_resource_dimensions *res_dim)
-{
-	struct linux_efhw_nic *lnic = NULL;
-	struct efhw_nic *nic = NULL;
-	int count = 0, rc = 0, resources_init = 0;
-	int constructed = 0;
-	int registered_nic = 0;
-	int buffers_allocated = 0;
-	static unsigned nic_index; /* = 0; */
-
-	EFRM_TRACE("%s: device detected (Slot '%s', IRQ %d)", __func__,
-		   pci_name(dev) ? pci_name(dev) : "?", dev->irq);
-
-	/* Ensure that we have room for the new adapter-structure. */
-	if (efrm_nic_tablep->nic_count == EFHW_MAX_NR_DEVS) {
-		EFRM_WARN("%s: WARNING: too many devices", __func__);
-		rc = -ENOMEM;
-		goto failed;
-	}
-
-	if (n_nics_probed == 0) {
-		rc = efrm_resources_init(res_dim, bt_min, bt_lim);
-		if (rc != 0)
-			goto failed;
-		resources_init = 1;
-	}
-
-	/* Allocate memory for the new adapter-structure. */
-	lnic = kmalloc(sizeof(*lnic), GFP_KERNEL);
-	if (lnic == NULL) {
-		EFRM_ERR("%s: ERROR: failed to allocate memory", __func__);
-		rc = -ENOMEM;
-		goto failed;
-	}
-	memset(lnic, 0, sizeof(*lnic));
-	nic = &lnic->efrm_nic.efhw_nic;
-
-	lnic->ev_handlers = &ev_handler;
-
-	/* OS specific hardware mappings */
-	rc = linux_efrm_nic_ctor(lnic, dev, reg_lock, flags, nic_options);
-	if (rc < 0) {
-		EFRM_ERR("%s: ERROR: initialisation failed", __func__);
-		goto failed;
-	}
-
-	constructed = 1;
-
-	/* Tell the driver about the NIC - this needs to be done before the
-	   resources managers get created below. Note we haven't initialised
-	   the hardware yet, and I don't like doing this before the perhaps
-	   unreliable hardware initialisation. However, there's quite a lot
-	   of code to review if we wanted to hardware init before bringing
-	   up the resource managers. */
-	rc = efrm_driver_register_nic(&lnic->efrm_nic, nic_index,
-				      /* TODO: ifindex */ nic_index);
-	if (rc < 0) {
-		EFRM_ERR("%s: cannot register nic %d with nic error code %d",
-			 __func__, efrm_nic_tablep->nic_count, rc);
-		goto failed;
-	}
-	++nic_index;
-	registered_nic = 1;
-
-	rc = efrm_nic_buffer_table_alloc(nic);
-	if (rc < 0)
-		goto failed;
-	buffers_allocated = 1;
-
-	/****************************************************/
-	/* hardware bringup                                 */
-	/****************************************************/
-	/* Detecting hardware can be a slightly unreliable process;
-	   we want to make sure that we maximise our chances, so we
-	   loop a few times until all is good. */
-	for (count = 0; count < max_hardware_init_repeats; count++) {
-		rc = efhw_nic_init_hardware(nic, &ev_handler, mac_addr,
-					    non_irq_evq);
-		if (rc >= 0)
-			break;
-
-		/* pain */
-		EFRM_ERR
-		    ("error - hardware initialisation failed code %d, "
-		     "attempt %d of %d", rc, count + 1,
-		     max_hardware_init_repeats);
-	}
-	if (rc < 0)
-		goto failed;
-
-	tasklet_init(&lnic->tasklet, efrm_tasklet, (ulong)nic);
-
-	/* set up interrupt handlers (hard-irq) */
-	nic->irq_handler = &efrm_handle_eventq_irq;
-
-	/* this device can now take management interrupts */
-	if (do_irq && !(nic->flags & NIC_FLAG_NO_INTERRUPT)) {
-		rc = linux_efrm_irq_ctor(lnic);
-		if (rc < 0) {
-			EFRM_ERR("Interrupt initialisation failed (%d)", rc);
-			goto failed;
-		}
-		efhw_nic_set_interrupt_moderation(nic, -1, irq_moderation);
-		efhw_nic_interrupt_enable(nic);
-	}
-	EFRM_TRACE("interrupts are %sregistered", do_irq ? "" : "not ");
-
-	*lnic_out = lnic;
-	EFRM_ASSERT(rc == 0);
-	++n_nics_probed;
-	return 0;
-
-failed:
-	if (buffers_allocated)
-		efrm_nic_buffer_table_free(nic);
-	if (registered_nic)
-		efrm_driver_unregister_nic(&lnic->efrm_nic);
-	if (constructed)
-		linux_efrm_nic_dtor(lnic);
-	kfree(lnic); /* safe in any case */
-	if (resources_init)
-		efrm_resources_fini();
-	return rc;
-}
-
-/****************************************************************************
- *
- * efrm_nic_del: Remove the nic from the resource driver structures
- *
- ****************************************************************************/
-void efrm_nic_del(struct linux_efhw_nic *lnic)
-{
-	struct efhw_nic *nic = &lnic->efrm_nic.efhw_nic;
-
-	EFRM_TRACE("%s:", __func__);
-	EFRM_ASSERT(nic);
-
-	efrm_nic_buffer_table_free(nic);
-
-	efrm_driver_unregister_nic(&lnic->efrm_nic);
-
-	/*
-	 * Synchronise here with any running ISR.
-	 * Remove the OS handler. There should be no IRQs being generated
-	 * by our NIC at this point.
-	 */
-	if (efhw_nic_have_functional_units(nic)) {
-		efhw_nic_close_interrupts(nic);
-		linux_efrm_irq_dtor(lnic);
-		tasklet_kill(&lnic->tasklet);
-	}
-
-	/* Close down hardware and free resources. */
-	linux_efrm_nic_dtor(lnic);
-	kfree(lnic);
-
-	if (--n_nics_probed == 0)
-		efrm_resources_fini();
-
-	EFRM_TRACE("%s: done", __func__);
-}
-
-/****************************************************************************
- *
- * init_module: register as a PCI driver.
- *
- ****************************************************************************/
-static int init_sfc_resource(void)
-{
-	int rc = 0;
-
-	EFRM_TRACE("%s: RESOURCE driver starting", __func__);
-
-	efrm_driver_ctor();
-
-	/* Register the driver so that our 'probe' function is called for
-	 * each EtherFabric device in the system.
-	 */
-	rc = efrm_driverlink_register();
-	if (rc == -ENODEV)
-		EFRM_ERR("%s: no devices found", __func__);
-	if (rc < 0)
-		goto failed_driverlink;
-
-	if (efrm_install_proc_entries() != 0) {
-		/* Do not fail, but print a warning */
-		EFRM_WARN("%s: WARNING: failed to install /proc entries",
-			  __func__);
-	}
-
-	return 0;
-
-failed_driverlink:
-	efrm_driver_dtor();
-	return rc;
-}
-
-/****************************************************************************
- *
- * cleanup_module: module-removal entry-point
- *
- ****************************************************************************/
-static void cleanup_sfc_resource(void)
-{
-	efrm_uninstall_proc_entries();
-
-	efrm_driverlink_unregister();
-
-	/* Clean up char-driver specific initialisation.
-	   - driver dtor can use both work queue and buffer table entries */
-	efrm_driver_dtor();
-
-	EFRM_TRACE("%s: unloaded", __func__);
-}
-
-module_init(init_sfc_resource);
-module_exit(cleanup_sfc_resource);
diff -r 9566a4a50a43 drivers/net/sfc/sfc_resource/resource_manager.c
--- a/drivers/net/sfc/sfc_resource/resource_manager.c
+++ /dev/null
@@ -1,145 +0,0 @@
-/****************************************************************************
- * Driver for Solarflare network controllers -
- *          resource management for Xen backend, OpenOnload, etc
- *           (including support for SFE4001 10GBT NIC)
- *
- * This file contains generic code for resources and resource managers.
- *
- * Copyright 2005-2007: Solarflare Communications Inc,
- *                      9501 Jeronimo Road, Suite 250,
- *                      Irvine, CA 92618, USA
- *
- * Developed and maintained by Solarflare Communications:
- *                      <linux-xen-drivers@solarflare.com>
- *                      <onload-dev@solarflare.com>
- *
- * Certain parts of the driver were implemented by
- *          Alexandra Kossovsky <Alexandra.Kossovsky@oktetlabs.ru>
- *          OKTET Labs Ltd, Russia,
- *          http://oktetlabs.ru, <info@oktetlabs.ru>
- *          by request of Solarflare Communications
- *
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 as published
- * by the Free Software Foundation, incorporated herein by reference.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
- ****************************************************************************
- */
-
-#include <ci/efrm/debug.h>
-#include <ci/efrm/nic_table.h>
-#include <ci/efhw/iopage.h>
-#include <ci/efrm/driver_private.h>
-#include <ci/efrm/private.h>
-#include "efrm_internal.h"
-
-/**********************************************************************
- * struct efrm_resource_manager
- */
-
-void efrm_resource_manager_dtor(struct efrm_resource_manager *rm)
-{
-	EFRM_RESOURCE_MANAGER_ASSERT_VALID(rm);
-
-	/* call destructor */
-	EFRM_DO_DEBUG(if (rm->rm_resources)
-		      EFRM_ERR("%s: %s leaked %d resources",
-			       __func__, rm->rm_name, rm->rm_resources));
-	EFRM_ASSERT(rm->rm_resources == 0);
-	EFRM_ASSERT(list_empty(&rm->rm_resources_list));
-
-	rm->rm_dtor(rm);
-
-	/* clear out things built by efrm_resource_manager_ctor */
-	spin_lock_destroy(&rm->rm_lock);
-
-	/* and the free the memory */
-	EFRM_DO_DEBUG(memset(rm, 0, sizeof(*rm)));
-	kfree(rm);
-}
-
-/* Construct a resource manager.  Resource managers are singletons. */
-int
-efrm_resource_manager_ctor(struct efrm_resource_manager *rm,
-			   void (*dtor)(struct efrm_resource_manager *),
-			   const char *name, unsigned type)
-{
-	EFRM_ASSERT(rm);
-	EFRM_ASSERT(dtor);
-
-	rm->rm_name = name;
-	EFRM_DO_DEBUG(rm->rm_type = type);
-	rm->rm_dtor = dtor;
-	spin_lock_init(&rm->rm_lock);
-	rm->rm_resources = 0;
-	rm->rm_resources_hiwat = 0;
-	INIT_LIST_HEAD(&rm->rm_resources_list);
-	EFRM_RESOURCE_MANAGER_ASSERT_VALID(rm);
-	return 0;
-}
-
-
-void efrm_client_add_resource(struct efrm_client *client,
-			      struct efrm_resource *rs)
-{
-	struct efrm_resource_manager *rm;
-	irq_flags_t lock_flags;
-
-	EFRM_ASSERT(client != NULL);
-	EFRM_ASSERT(rs != NULL);
-
-	spin_lock_irqsave(&efrm_nic_tablep->lock, lock_flags);
-	rm = efrm_rm_table[EFRM_RESOURCE_TYPE(rs->rs_handle)];
-	++rm->rm_resources;
-	list_add(&rs->rs_manager_link, &rm->rm_resources_list);
-	if (rm->rm_resources > rm->rm_resources_hiwat)
-		rm->rm_resources_hiwat = rm->rm_resources;
-	rs->rs_client = client;
-	++client->ref_count;
-	list_add(&rs->rs_client_link, &client->resources);
-	spin_unlock_irqrestore(&efrm_nic_tablep->lock, lock_flags);
-}
-
-
-void efrm_resource_ref(struct efrm_resource *rs)
-{
-	irq_flags_t lock_flags;
-	spin_lock_irqsave(&efrm_nic_tablep->lock, lock_flags);
-	++rs->rs_ref_count;
-	spin_unlock_irqrestore(&efrm_nic_tablep->lock, lock_flags);
-}
-EXPORT_SYMBOL(efrm_resource_ref);
-
-
-int __efrm_resource_release(struct efrm_resource *rs)
-{
-	struct efrm_resource_manager *rm;
-	irq_flags_t lock_flags;
-	int free_rs;
-
-	spin_lock_irqsave(&efrm_nic_tablep->lock, lock_flags);
-	free_rs = --rs->rs_ref_count == 0;
-	if (free_rs) {
-		rm = efrm_rm_table[EFRM_RESOURCE_TYPE(rs->rs_handle)];
-		EFRM_ASSERT(rm->rm_resources > 0);
-		--rm->rm_resources;
-		list_del(&rs->rs_manager_link);
-		list_del(&rs->rs_client_link);
-	}
-	spin_unlock_irqrestore(&efrm_nic_tablep->lock, lock_flags);
-	return free_rs;
-}
-EXPORT_SYMBOL(__efrm_resource_release);
-
-/*
- * vi: sw=8:ai:aw
- */
diff -r 9566a4a50a43 drivers/net/sfc/sfc_resource/resources.c
--- a/drivers/net/sfc/sfc_resource/resources.c
+++ /dev/null
@@ -1,94 +0,0 @@
-/****************************************************************************
- * Driver for Solarflare network controllers -
- *          resource management for Xen backend, OpenOnload, etc
- *           (including support for SFE4001 10GBT NIC)
- *
- * This file contains resource managers initialisation functions.
- *
- * Copyright 2005-2007: Solarflare Communications Inc,
- *                      9501 Jeronimo Road, Suite 250,
- *                      Irvine, CA 92618, USA
- *
- * Developed and maintained by Solarflare Communications:
- *                      <linux-xen-drivers@solarflare.com>
- *                      <onload-dev@solarflare.com>
- *
- * Certain parts of the driver were implemented by
- *          Alexandra Kossovsky <Alexandra.Kossovsky@oktetlabs.ru>
- *          OKTET Labs Ltd, Russia,
- *          http://oktetlabs.ru, <info@oktetlabs.ru>
- *          by request of Solarflare Communications
- *
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 as published
- * by the Free Software Foundation, incorporated herein by reference.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
- ****************************************************************************
- */
-
-#include <ci/efrm/private.h>
-#include <ci/efrm/buffer_table.h>
-
-int
-efrm_resources_init(const struct vi_resource_dimensions *vi_res_dim,
-		    int buffer_table_min, int buffer_table_lim)
-{
-	int i, rc;
-
-	rc = efrm_buffer_table_ctor(buffer_table_min, buffer_table_lim);
-	if (rc != 0)
-		return rc;
-
-	/* Create resources in the correct order */
-	for (i = 0; i < EFRM_RESOURCE_NUM; ++i) {
-		struct efrm_resource_manager **rmp = &efrm_rm_table[i];
-
-		EFRM_ASSERT(*rmp == NULL);
-		switch (i) {
-		case EFRM_RESOURCE_VI:
-			rc = efrm_create_vi_resource_manager(rmp,
-							     vi_res_dim);
-			break;
-		case EFRM_RESOURCE_FILTER:
-			rc = efrm_create_filter_resource_manager(rmp);
-			break;
-		case EFRM_RESOURCE_IOBUFSET:
-			rc = efrm_create_iobufset_resource_manager(rmp);
-			break;
-		default:
-			rc = 0;
-			break;
-		}
-
-		if (rc < 0) {
-			EFRM_ERR("%s: failed type=%d (%d)",
-				 __func__, i, rc);
-			efrm_buffer_table_dtor();
-			return rc;
-		}
-	}
-
-	return 0;
-}
-
-void efrm_resources_fini(void)
-{
-	int i;
-
-	for (i = EFRM_RESOURCE_NUM - 1; i >= 0; --i)
-		if (efrm_rm_table[i]) {
-			efrm_resource_manager_dtor(efrm_rm_table[i]);
-			efrm_rm_table[i] = NULL;
-		}
-
-	efrm_buffer_table_dtor();
-}
diff -r 9566a4a50a43 drivers/net/sfc/sfc_resource/vi_resource_alloc.c
--- a/drivers/net/sfc/sfc_resource/vi_resource_alloc.c
+++ /dev/null
@@ -1,820 +0,0 @@
-/****************************************************************************
- * Driver for Solarflare network controllers -
- *          resource management for Xen backend, OpenOnload, etc
- *           (including support for SFE4001 10GBT NIC)
- *
- * This file contains allocation of VI resources.
- *
- * Copyright 2005-2007: Solarflare Communications Inc,
- *                      9501 Jeronimo Road, Suite 250,
- *                      Irvine, CA 92618, USA
- *
- * Developed and maintained by Solarflare Communications:
- *                      <linux-xen-drivers@solarflare.com>
- *                      <onload-dev@solarflare.com>
- *
- * Certain parts of the driver were implemented by
- *          Alexandra Kossovsky <Alexandra.Kossovsky@oktetlabs.ru>
- *          OKTET Labs Ltd, Russia,
- *          http://oktetlabs.ru, <info@oktetlabs.ru>
- *          by request of Solarflare Communications
- *
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 as published
- * by the Free Software Foundation, incorporated herein by reference.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
- ****************************************************************************
- */
-
-#include <ci/efrm/nic_table.h>
-#include <ci/efhw/iopage.h>
-#include <ci/driver/efab/hardware.h>
-#include <ci/efhw/public.h>
-#include <ci/efhw/falcon.h>
-#include <ci/efrm/private.h>
-#include <ci/efrm/buffer_table.h>
-#include <ci/efrm/vi_resource_private.h>
-#include <ci/efrm/efrm_client.h>
-#include "efrm_internal.h"
-
-
-/*** Data definitions ****************************************************/
-
-static const char *dmaq_names[] = { "TX", "RX" };
-
-struct vi_resource_manager *efrm_vi_manager;
-
-/*** Forward references **************************************************/
-
-static int
-efrm_vi_resource_alloc_or_free(struct efrm_client *client,
-			       int alloc, struct vi_resource *evq_virs,
-			       uint16_t vi_flags, int32_t evq_capacity,
-			       int32_t txq_capacity, int32_t rxq_capacity,
-			       uint8_t tx_q_tag, uint8_t rx_q_tag,
-			       struct vi_resource **virs_in_out);
-
-/*** Reference count handling ********************************************/
-
-static inline void efrm_vi_rm_get_ref(struct vi_resource *virs)
-{
-	atomic_inc(&virs->evq_refs);
-}
-
-static inline void efrm_vi_rm_drop_ref(struct vi_resource *virs)
-{
-	EFRM_ASSERT(atomic_read(&virs->evq_refs) != 0);
-	if (atomic_dec_and_test(&virs->evq_refs))
-		efrm_vi_resource_alloc_or_free(virs->rs.rs_client, false, NULL,
-					       0, 0, 0, 0, 0, 0, &virs);
-}
-
-/*** Instance numbers ****************************************************/
-
-static inline int efrm_vi_rm_alloc_id(uint16_t vi_flags, int32_t evq_capacity)
-{
-	irq_flags_t lock_flags;
-	int instance;
-	int rc;
-
-	if (efrm_nic_tablep->a_nic == NULL)	/* ?? FIXME: surely not right */
-		return -ENODEV;
-
-	spin_lock_irqsave(&efrm_vi_manager->rm.rm_lock, lock_flags);
-
-	/* Falcon A1 RX phys addr wierdness. */
-	if (efrm_nic_tablep->a_nic->devtype.variant == 'A' &&
-	    (vi_flags & EFHW_VI_RX_PHYS_ADDR_EN)) {
-		if (vi_flags & EFHW_VI_JUMBO_EN) {
-			/* Falcon-A cannot do phys + scatter. */
-			EFRM_WARN
-			    ("%s: falcon-A does not support phys+scatter mode",
-			     __func__);
-			instance = -1;
-		} else if (efrm_vi_manager->iscsi_dmaq_instance_is_free
-			   && evq_capacity == 0) {
-			/* Falcon-A has a single RXQ that gives the correct
-			 * semantics for physical addressing.  However, it
-			 * happens to have the same instance number as the
-			 * 'char' event queue, so we cannot also hand out
-			 * the event queue. */
-			efrm_vi_manager->iscsi_dmaq_instance_is_free = false;
-			instance = FALCON_A1_ISCSI_DMAQ;
-		} else {
-			EFRM_WARN("%s: iSCSI receive queue not free",
-				  __func__);
-			instance = -1;
-		}
-		goto unlock_out;
-	}
-
-	if (vi_flags & EFHW_VI_RM_WITH_INTERRUPT) {
-		rc = __kfifo_get(efrm_vi_manager->instances_with_interrupt,
-				 (unsigned char *)&instance, sizeof(instance));
-		if (rc != sizeof(instance)) {
-			EFRM_ASSERT(rc == 0);
-			instance = -1;
-		}
-		goto unlock_out;
-	}
-
-	/* Otherwise a normal run-of-the-mill VI. */
-	rc = __kfifo_get(efrm_vi_manager->instances_with_timer,
-			 (unsigned char *)&instance, sizeof(instance));
-	if (rc != sizeof(instance)) {
-		EFRM_ASSERT(rc == 0);
-		instance = -1;
-	}
-
-unlock_out:
-	spin_unlock_irqrestore(&efrm_vi_manager->rm.rm_lock, lock_flags);
-	return instance;
-}
-
-static void efrm_vi_rm_free_id(int instance)
-{
-	irq_flags_t lock_flags;
-	struct kfifo *instances;
-
-	if (efrm_nic_tablep->a_nic == NULL)	/* ?? FIXME: surely not right */
-		return;
-
-	if (efrm_nic_tablep->a_nic->devtype.variant == 'A' &&
-	    instance == FALCON_A1_ISCSI_DMAQ) {
-		EFRM_ASSERT(efrm_vi_manager->iscsi_dmaq_instance_is_free ==
-			    false);
-		spin_lock_irqsave(&efrm_vi_manager->rm.rm_lock, lock_flags);
-		efrm_vi_manager->iscsi_dmaq_instance_is_free = true;
-		spin_unlock_irqrestore(&efrm_vi_manager->rm.rm_lock,
-				       lock_flags);
-	} else {
-		if (instance >= efrm_vi_manager->with_timer_base &&
-		    instance < efrm_vi_manager->with_timer_limit) {
-			instances = efrm_vi_manager->instances_with_timer;
-		} else {
-			EFRM_ASSERT(instance >=
-				    efrm_vi_manager->with_interrupt_base);
-			EFRM_ASSERT(instance <
-				    efrm_vi_manager->with_interrupt_limit);
-			instances = efrm_vi_manager->instances_with_interrupt;
-		}
-
-		EFRM_VERIFY_EQ(kfifo_put(instances, (unsigned char *)&instance,
-					 sizeof(instance)), sizeof(instance));
-	}
-}
-
-/*** Queue sizes *********************************************************/
-
-/* NB. This should really take a nic as an argument, but that makes
- * the buffer table allocation difficult. */
-uint32_t efrm_vi_rm_evq_bytes(struct vi_resource *virs
-			      /*,struct efhw_nic *nic */)
-{
-	return virs->evq_capacity * sizeof(efhw_event_t);
-}
-EXPORT_SYMBOL(efrm_vi_rm_evq_bytes);
-
-/* NB. This should really take a nic as an argument, but that makes
- * the buffer table allocation difficult. */
-uint32_t efrm_vi_rm_txq_bytes(struct vi_resource *virs
-			      /*,struct efhw_nic *nic */)
-{
-	return virs->dmaq_capacity[EFRM_VI_RM_DMA_QUEUE_TX] *
-	    FALCON_DMA_TX_DESC_BYTES;
-}
-EXPORT_SYMBOL(efrm_vi_rm_txq_bytes);
-
-/* NB. This should really take a nic as an argument, but that makes
- * the buffer table allocation difficult. */
-uint32_t efrm_vi_rm_rxq_bytes(struct vi_resource *virs
-			      /*,struct efhw_nic *nic */)
-{
-	uint32_t bytes_per_desc = ((virs->flags & EFHW_VI_RX_PHYS_ADDR_EN)
-				   ? FALCON_DMA_RX_PHYS_DESC_BYTES
-				   : FALCON_DMA_RX_BUF_DESC_BYTES);
-	return virs->dmaq_capacity[EFRM_VI_RM_DMA_QUEUE_RX] * bytes_per_desc;
-}
-EXPORT_SYMBOL(efrm_vi_rm_rxq_bytes);
-
-static int choose_size(int size_rq, unsigned sizes)
-{
-	int size;
-
-	/* size_rq < 0 means default, but we interpret this as 'minimum'. */
-
-	for (size = 256;; size <<= 1)
-		if ((size & sizes) && size >= size_rq)
-			return size;
-		else if ((sizes & ~((size - 1) | size)) == 0)
-			return -1;
-}
-
-static int
-efrm_vi_rm_adjust_alloc_request(struct vi_resource *virs, struct efhw_nic *nic)
-{
-	int capacity;
-
-	EFRM_ASSERT(nic->efhw_func);
-
-	if (virs->evq_capacity) {
-		capacity = choose_size(virs->evq_capacity, nic->evq_sizes);
-		if (capacity < 0) {
-			EFRM_ERR("vi_resource: bad evq size %d (supported=%x)",
-				 virs->evq_capacity, nic->evq_sizes);
-			return -E2BIG;
-		}
-		virs->evq_capacity = capacity;
-	}
-	if (virs->dmaq_capacity[EFRM_VI_RM_DMA_QUEUE_TX]) {
-		capacity =
-		    choose_size(virs->dmaq_capacity[EFRM_VI_RM_DMA_QUEUE_TX],
-				nic->txq_sizes);
-		if (capacity < 0) {
-			EFRM_ERR("vi_resource: bad txq size %d (supported=%x)",
-				 virs->dmaq_capacity[EFRM_VI_RM_DMA_QUEUE_TX],
-				 nic->txq_sizes);
-			return -E2BIG;
-		}
-		virs->dmaq_capacity[EFRM_VI_RM_DMA_QUEUE_TX] = capacity;
-	}
-	if (virs->dmaq_capacity[EFRM_VI_RM_DMA_QUEUE_RX]) {
-		capacity =
-		    choose_size(virs->dmaq_capacity[EFRM_VI_RM_DMA_QUEUE_RX],
-				nic->rxq_sizes);
-		if (capacity < 0) {
-			EFRM_ERR("vi_resource: bad rxq size %d (supported=%x)",
-				 virs->dmaq_capacity[EFRM_VI_RM_DMA_QUEUE_RX],
-				 nic->rxq_sizes);
-			return -E2BIG;
-		}
-		virs->dmaq_capacity[EFRM_VI_RM_DMA_QUEUE_RX] = capacity;
-	}
-
-	return 0;
-}
-
-/* remove the reference to the event queue in this VI resource and decrement
-   the event queue's use count */
-static inline void efrm_vi_rm_detach_evq(struct vi_resource *virs)
-{
-	struct vi_resource *evq_virs;
-
-	EFRM_ASSERT(virs != NULL);
-
-	evq_virs = virs->evq_virs;
-
-	if (evq_virs != NULL) {
-		virs->evq_virs = NULL;
-		if (evq_virs == virs) {
-			EFRM_TRACE("%s: " EFRM_RESOURCE_FMT
-				   " had internal event queue ", __func__,
-				   EFRM_RESOURCE_PRI_ARG(virs->rs.rs_handle));
-		} else {
-			efrm_vi_rm_drop_ref(evq_virs);
-			EFRM_TRACE("%s: " EFRM_RESOURCE_FMT " had event queue "
-				   EFRM_RESOURCE_FMT, __func__,
-				   EFRM_RESOURCE_PRI_ARG(virs->rs.rs_handle),
-				   EFRM_RESOURCE_PRI_ARG(evq_virs->rs.
-							 rs_handle));
-		}
-	} else {
-		EFRM_TRACE("%s: " EFRM_RESOURCE_FMT
-			   " had no event queue (nothing to do)",
-			   __func__,
-			   EFRM_RESOURCE_PRI_ARG(virs->rs.rs_handle));
-	}
-}
-
-/*** Buffer Table allocations ********************************************/
-
-static int
-efrm_vi_rm_alloc_or_free_buffer_table(struct vi_resource *virs, bool is_alloc)
-{
-	uint32_t bytes;
-	int page_order;
-	int rc;
-
-	if (!is_alloc)
-		goto destroy;
-
-	if (virs->dmaq_capacity[EFRM_VI_RM_DMA_QUEUE_TX]) {
-		bytes = efrm_vi_rm_txq_bytes(virs);
-		page_order = get_order(bytes);
-		rc = efrm_buffer_table_alloc(page_order,
-					     (virs->dmaq_buf_tbl_alloc +
-					      EFRM_VI_RM_DMA_QUEUE_TX));
-		if (rc != 0) {
-			EFRM_TRACE
-			    ("%s: Error %d allocating TX buffer table entry",
-			     __func__, rc);
-			goto fail_txq_alloc;
-		}
-	}
-
-	if (virs->dmaq_capacity[EFRM_VI_RM_DMA_QUEUE_RX]) {
-		bytes = efrm_vi_rm_rxq_bytes(virs);
-		page_order = get_order(bytes);
-		rc = efrm_buffer_table_alloc(page_order,
-					     (virs->dmaq_buf_tbl_alloc +
-					      EFRM_VI_RM_DMA_QUEUE_RX));
-		if (rc != 0) {
-			EFRM_TRACE
-			    ("%s: Error %d allocating RX buffer table entry",
-			     __func__, rc);
-			goto fail_rxq_alloc;
-		}
-	}
-	return 0;
-
-destroy:
-	rc = 0;
-
-	if (virs->dmaq_capacity[EFRM_VI_RM_DMA_QUEUE_RX]) {
-		efrm_buffer_table_free(&virs->
-				       dmaq_buf_tbl_alloc
-				       [EFRM_VI_RM_DMA_QUEUE_RX]);
-	}
-fail_rxq_alloc:
-
-	if (virs->dmaq_capacity[EFRM_VI_RM_DMA_QUEUE_TX]) {
-		efrm_buffer_table_free(&virs->
-				       dmaq_buf_tbl_alloc
-				       [EFRM_VI_RM_DMA_QUEUE_TX]);
-	}
-fail_txq_alloc:
-
-	return rc;
-}
-
-/*** Per-NIC allocations *************************************************/
-
-static inline int
-efrm_vi_rm_init_evq(struct vi_resource *virs, struct efhw_nic *nic)
-{
-	int instance = EFRM_RESOURCE_INSTANCE(virs->rs.rs_handle);
-	struct eventq_resource_hardware *evq_hw =
-	    &virs->nic_info.evq_pages;
-	uint32_t buf_bytes = efrm_vi_rm_evq_bytes(virs);
-	int rc;
-
-	if (virs->evq_capacity == 0)
-		return 0;
-	evq_hw->capacity = virs->evq_capacity;
-
-	/* Allocate buffer table entries to map onto the iobuffer.  This
-	 * currently allocates its own buffer table entries on Falcon which is
-	 * a bit wasteful on a multi-NIC system. */
-	evq_hw->buf_tbl_alloc.base = (unsigned)-1;
-	rc = efrm_buffer_table_alloc(get_order(buf_bytes),
-				     &evq_hw->buf_tbl_alloc);
-	if (rc < 0) {
-		EFHW_WARN("%s: failed (%d) to alloc %d buffer table entries",
-			  __func__, rc, get_order(buf_bytes));
-		return rc;
-	}
-
-	/* Allocate the event queue memory. */
-	rc = efhw_nic_event_queue_alloc_iobuffer(nic, evq_hw, instance,
-						 buf_bytes);
-	if (rc != 0) {
-		EFRM_ERR("%s: Error allocating iobuffer: %d", __func__, rc);
-		efrm_buffer_table_free(&evq_hw->buf_tbl_alloc);
-		return rc;
-	}
-
-	/* Initialise the event queue hardware */
-	efhw_nic_event_queue_enable(nic, instance, virs->evq_capacity,
-				    efhw_iopages_dma_addr(&evq_hw->iobuff) +
-				    evq_hw->iobuff_off,
-				    evq_hw->buf_tbl_alloc.base,
-				    instance < 64);
-
-	EFRM_TRACE("%s: " EFRM_RESOURCE_FMT " capacity=%u", __func__,
-		   EFRM_RESOURCE_PRI_ARG(virs->rs.rs_handle),
-		   virs->evq_capacity);
-
-#if defined(__ia64__)
-	/* Page size may be large, so for now just increase the
-	 * size of the requested evq up to a round number of
-	 * pages
-	 */
-	buf_bytes = CI_ROUNDUP(buf_bytes, PAGE_SIZE);
-#endif
-	EFRM_ASSERT(buf_bytes % PAGE_SIZE == 0);
-
-	virs->mem_mmap_bytes += buf_bytes;
-
-	return 0;
-}
-
-static inline void
-efrm_vi_rm_fini_evq(struct vi_resource *virs, struct efhw_nic *nic)
-{
-	int instance = EFRM_RESOURCE_INSTANCE(virs->rs.rs_handle);
-	struct vi_resource_nic_info *nic_info = &virs->nic_info;
-
-	if (virs->evq_capacity == 0)
-		return;
-
-	/* Zero the timer-value for this queue.
-	   And Tell NIC to stop using this event queue. */
-	efhw_nic_event_queue_disable(nic, instance, 0);
-
-	if (nic_info->evq_pages.buf_tbl_alloc.base != (unsigned)-1)
-		efrm_buffer_table_free(&nic_info->evq_pages.buf_tbl_alloc);
-
-	efhw_iopages_free(nic, &nic_info->evq_pages.iobuff);
-}
-
-/*! FIXME: we should make sure this number is never zero (=> unprotected) */
-/*! FIXME: put this definition in a relevant header (e.g. as (evqid)+1) */
-#define EFAB_EVQ_OWNER_ID(evqid) ((evqid))
-
-void
-efrm_vi_rm_init_dmaq(struct vi_resource *virs, int queue_type,
-		     struct efhw_nic *nic)
-{
-	int instance;
-	int evq_instance;
-	efhw_buffer_addr_t buf_addr;
-
-	instance = EFRM_RESOURCE_INSTANCE(virs->rs.rs_handle);
-	evq_instance = EFRM_RESOURCE_INSTANCE(virs->evq_virs->rs.rs_handle);
-
-	buf_addr = virs->dmaq_buf_tbl_alloc[queue_type].base;
-
-	if (queue_type == EFRM_VI_RM_DMA_QUEUE_TX) {
-		efhw_nic_dmaq_tx_q_init(nic,
-			instance,	/* dmaq */
-			evq_instance,	/* evq */
-			EFAB_EVQ_OWNER_ID(evq_instance),	/* owner */
-			virs->dmaq_tag[queue_type],	/* tag */
-			virs->dmaq_capacity[queue_type], /* size of queue */
-			buf_addr,	/* buffer index */
-			virs->flags);	/* user specified Q attrs */
-	} else {
-		efhw_nic_dmaq_rx_q_init(nic,
-			instance,	/* dmaq */
-			evq_instance,	/* evq */
-			EFAB_EVQ_OWNER_ID(evq_instance),	/* owner */
-			virs->dmaq_tag[queue_type],	/* tag */
-			virs->dmaq_capacity[queue_type], /* size of queue */
-			buf_addr,	/* buffer index */
-			virs->flags);	/* user specified Q attrs */
-	}
-}
-
-static int
-efrm_vi_rm_init_or_fini_dmaq(struct vi_resource *virs,
-			     int queue_type, int init,
-			     struct efhw_nic *nic)
-{
-	int rc;
-	int instance = EFRM_RESOURCE_INSTANCE(virs->rs.rs_handle);
-	uint32_t buf_bytes;
-	struct vi_resource_nic_info *nic_info = &virs->nic_info;
-	int page_order;
-	uint32_t num_pages;
-	struct efhw_iopages *iobuff;
-
-	if (!init)
-		goto destroy;
-
-	/* Ignore disabled queues. */
-	if (virs->dmaq_capacity[queue_type] == 0) {
-		if (queue_type == EFRM_VI_RM_DMA_QUEUE_TX)
-			efhw_nic_dmaq_tx_q_disable(nic, instance);
-		else
-			efhw_nic_dmaq_rx_q_disable(nic, instance);
-		return 0;
-	}
-
-	buf_bytes = (queue_type == EFRM_VI_RM_DMA_QUEUE_TX
-		     ? efrm_vi_rm_txq_bytes(virs)
-		     : efrm_vi_rm_rxq_bytes(virs));
-
-	page_order = get_order(buf_bytes);
-
-	rc = efhw_iopages_alloc(nic, &nic_info->dmaq_pages[queue_type],
-			      page_order);
-	if (rc != 0) {
-		EFRM_ERR("%s: Failed to allocate %s DMA buffer.", __func__,
-			 dmaq_names[queue_type]);
-		goto fail_iopages;
-	}
-
-	num_pages = 1 << page_order;
-	iobuff = &nic_info->dmaq_pages[queue_type];
-	efhw_nic_buffer_table_set_n(nic,
-				    virs->dmaq_buf_tbl_alloc[queue_type].base,
-				    efhw_iopages_dma_addr(iobuff),
-				    EFHW_NIC_PAGE_SIZE, 0, num_pages, 0);
-
-	falcon_nic_buffer_table_confirm(nic);
-
-	virs->mem_mmap_bytes += roundup(buf_bytes, PAGE_SIZE);
-
-	/* Make sure there is an event queue. */
-	if (virs->evq_virs->evq_capacity <= 0) {
-		EFRM_ERR("%s: Cannot use empty event queue for %s DMA",
-			 __func__, dmaq_names[queue_type]);
-		rc = -EINVAL;
-		goto fail_evq;
-	}
-
-	efrm_vi_rm_init_dmaq(virs, queue_type, nic);
-
-	return 0;
-
-destroy:
-	rc = 0;
-
-	/* Ignore disabled queues. */
-	if (virs->dmaq_capacity[queue_type] == 0)
-		return 0;
-
-	/* Ensure TX pacing turned off -- queue flush doesn't reset this. */
-	if (queue_type == EFRM_VI_RM_DMA_QUEUE_TX)
-		falcon_nic_pace(nic, instance, 0);
-
-	/* No need to disable the queue here.  Nobody is using it anyway. */
-
-fail_evq:
-	efhw_iopages_free(nic, &nic_info->dmaq_pages[queue_type]);
-fail_iopages:
-
-	return rc;
-}
-
-static int
-efrm_vi_rm_init_or_fini_nic(struct vi_resource *virs, int init,
-			    struct efhw_nic *nic)
-{
-	int rc;
-#ifndef NDEBUG
-	int instance = EFRM_RESOURCE_INSTANCE(virs->rs.rs_handle);
-#endif
-
-	if (!init)
-		goto destroy;
-
-	rc = efrm_vi_rm_init_evq(virs, nic);
-	if (rc != 0)
-		goto fail_evq;
-
-	rc = efrm_vi_rm_init_or_fini_dmaq(virs, EFRM_VI_RM_DMA_QUEUE_TX,
-					  init, nic);
-	if (rc != 0)
-		goto fail_txq;
-
-	rc = efrm_vi_rm_init_or_fini_dmaq(virs, EFRM_VI_RM_DMA_QUEUE_RX,
-					  init, nic);
-	if (rc != 0)
-		goto fail_rxq;
-
-	/* Allocate space for the control page. */
-	EFRM_ASSERT(falcon_tx_dma_page_offset(instance) < PAGE_SIZE);
-	EFRM_ASSERT(falcon_rx_dma_page_offset(instance) < PAGE_SIZE);
-	EFRM_ASSERT(falcon_timer_page_offset(instance) < PAGE_SIZE);
-	virs->bar_mmap_bytes += PAGE_SIZE;
-
-	return 0;
-
-destroy:
-	rc = 0;
-
-	efrm_vi_rm_init_or_fini_dmaq(virs, EFRM_VI_RM_DMA_QUEUE_RX,
-				     false, nic);
-fail_rxq:
-
-	efrm_vi_rm_init_or_fini_dmaq(virs, EFRM_VI_RM_DMA_QUEUE_TX,
-				     false, nic);
-fail_txq:
-
-	efrm_vi_rm_fini_evq(virs, nic);
-fail_evq:
-
-	EFRM_ASSERT(rc != 0 || !init);
-	return rc;
-}
-
-static int
-efrm_vi_resource_alloc_or_free(struct efrm_client *client,
-			       int alloc, struct vi_resource *evq_virs,
-			       uint16_t vi_flags, int32_t evq_capacity,
-			       int32_t txq_capacity, int32_t rxq_capacity,
-			       uint8_t tx_q_tag, uint8_t rx_q_tag,
-			       struct vi_resource **virs_in_out)
-{
-	struct efhw_nic *nic = client->nic;
-	struct vi_resource *virs;
-	int rc;
-	int instance;
-
-	EFRM_ASSERT(virs_in_out);
-	EFRM_ASSERT(efrm_vi_manager);
-	EFRM_RESOURCE_MANAGER_ASSERT_VALID(&efrm_vi_manager->rm);
-
-	if (!alloc)
-		goto destroy;
-
-	rx_q_tag &= (1 << TX_DESCQ_LABEL_WIDTH) - 1;
-	tx_q_tag &= (1 << RX_DESCQ_LABEL_WIDTH) - 1;
-
-	virs = kmalloc(sizeof(*virs), GFP_KERNEL);
-	if (virs == NULL) {
-		EFRM_ERR("%s: Error allocating VI resource object",
-			 __func__);
-		rc = -ENOMEM;
-		goto fail_alloc;
-	}
-	memset(virs, 0, sizeof(*virs));
-
-	/* Some macros make the assumption that the struct efrm_resource is
-	 * the first member of a struct vi_resource. */
-	EFRM_ASSERT(&virs->rs == (struct efrm_resource *) (virs));
-
-	instance = efrm_vi_rm_alloc_id(vi_flags, evq_capacity);
-	if (instance < 0) {
-		/* Clear out the close list... */
-		efrm_vi_rm_salvage_flushed_vis();
-		instance = efrm_vi_rm_alloc_id(vi_flags, evq_capacity);
-		if (instance >= 0)
-			EFRM_TRACE("%s: Salvaged a closed VI.", __func__);
-	}
-
-	if (instance < 0) {
-		/* Could flush resources and try again here. */
-		EFRM_ERR("%s: Out of appropriate VI resources", __func__);
-		rc = -EBUSY;
-		goto fail_alloc_id;
-	}
-
-	EFRM_TRACE("%s: new VI ID %d", __func__, instance);
-	efrm_resource_init(&virs->rs, EFRM_RESOURCE_VI, instance);
-
-	/* Start with one reference.  Any external VIs using the EVQ of this
-	 * resource will increment this reference rather than the resource
-	 * reference to avoid DMAQ flushes from waiting for other DMAQ
-	 * flushes to complete.  When the resource reference goes to zero,
-	 * the DMAQ flush happens.  When the flush completes, this reference
-	 * is decremented.  When this reference reaches zero, the instance
-	 * is freed. */
-	atomic_set(&virs->evq_refs, 1);
-
-	virs->bar_mmap_bytes = 0;
-	virs->mem_mmap_bytes = 0;
-	virs->evq_capacity = evq_capacity;
-	virs->dmaq_capacity[EFRM_VI_RM_DMA_QUEUE_TX] = txq_capacity;
-	virs->dmaq_capacity[EFRM_VI_RM_DMA_QUEUE_RX] = rxq_capacity;
-	virs->dmaq_tag[EFRM_VI_RM_DMA_QUEUE_TX] = tx_q_tag;
-	virs->dmaq_tag[EFRM_VI_RM_DMA_QUEUE_RX] = rx_q_tag;
-	virs->flags = vi_flags;
-	INIT_LIST_HEAD(&virs->tx_flush_link);
-	INIT_LIST_HEAD(&virs->rx_flush_link);
-	virs->tx_flushing = 0;
-	virs->rx_flushing = 0;
-
-	/* Adjust the queue sizes. */
-	rc = efrm_vi_rm_adjust_alloc_request(virs, nic);
-	if (rc != 0)
-		goto fail_adjust_request;
-
-	/* Attach the EVQ early so that we can ensure that the NIC sets
-	 * match. */
-	if (evq_virs == NULL) {
-		evq_virs = virs;
-		EFRM_TRACE("%s: " EFRM_RESOURCE_FMT
-			   " has no external event queue", __func__,
-			   EFRM_RESOURCE_PRI_ARG(virs->rs.rs_handle));
-	} else {
-		/* Make sure the resource managers are the same. */
-		if (EFRM_RESOURCE_TYPE(evq_virs->rs.rs_handle) !=
-		    EFRM_RESOURCE_VI) {
-			EFRM_ERR("%s: Mismatched owner for event queue VI "
-				 EFRM_RESOURCE_FMT, __func__,
-				 EFRM_RESOURCE_PRI_ARG(evq_virs->rs.rs_handle));
-			return -EINVAL;
-		}
-		EFRM_ASSERT(atomic_read(&evq_virs->evq_refs) != 0);
-		efrm_vi_rm_get_ref(evq_virs);
-		EFRM_TRACE("%s: " EFRM_RESOURCE_FMT " uses event queue "
-			   EFRM_RESOURCE_FMT,
-			   __func__,
-			   EFRM_RESOURCE_PRI_ARG(virs->rs.rs_handle),
-			   EFRM_RESOURCE_PRI_ARG(evq_virs->rs.rs_handle));
-	}
-	virs->evq_virs = evq_virs;
-
-	rc = efrm_vi_rm_alloc_or_free_buffer_table(virs, true);
-	if (rc != 0)
-		goto fail_buffer_table;
-
-	rc = efrm_vi_rm_init_or_fini_nic(virs, true, nic);
-	if (rc != 0)
-		goto fail_init_nic;
-
-	efrm_client_add_resource(client, &virs->rs);
-	*virs_in_out = virs;
-	EFRM_TRACE("%s: Allocated " EFRM_RESOURCE_FMT, __func__,
-		   EFRM_RESOURCE_PRI_ARG(virs->rs.rs_handle));
-	return 0;
-
-destroy:
-	virs = *virs_in_out;
-	EFRM_RESOURCE_ASSERT_VALID(&virs->rs, 1);
-	instance = EFRM_RESOURCE_INSTANCE(virs->rs.rs_handle);
-
-	EFRM_TRACE("%s: Freeing %d", __func__,
-		   EFRM_RESOURCE_INSTANCE(virs->rs.rs_handle));
-
-	/* Destroying the VI.  The reference count must be zero. */
-	EFRM_ASSERT(atomic_read(&virs->evq_refs) == 0);
-
-	/* The EVQ should have gone (and DMA disabled) so that this
-	 * function can't be re-entered to destroy the EVQ VI. */
-	EFRM_ASSERT(virs->evq_virs == NULL);
-	rc = 0;
-
-fail_init_nic:
-	efrm_vi_rm_init_or_fini_nic(virs, false, nic);
-
-	efrm_vi_rm_alloc_or_free_buffer_table(virs, false);
-fail_buffer_table:
-
-	efrm_vi_rm_detach_evq(virs);
-
-fail_adjust_request:
-
-	EFRM_ASSERT(virs->evq_callback_fn == NULL);
-	EFRM_TRACE("%s: delete VI ID %d", __func__, instance);
-	efrm_vi_rm_free_id(instance);
-fail_alloc_id:
-	if (!alloc)
-		efrm_client_put(virs->rs.rs_client);
-	EFRM_DO_DEBUG(memset(virs, 0, sizeof(*virs)));
-	kfree(virs);
-fail_alloc:
-	*virs_in_out = NULL;
-
-	return rc;
-}
-
-/*** Resource object  ****************************************************/
-
-int
-efrm_vi_resource_alloc(struct efrm_client *client,
-		       struct vi_resource *evq_virs,
-		       uint16_t vi_flags, int32_t evq_capacity,
-		       int32_t txq_capacity, int32_t rxq_capacity,
-		       uint8_t tx_q_tag, uint8_t rx_q_tag,
-		       struct vi_resource **virs_out,
-		       uint32_t *out_io_mmap_bytes,
-		       uint32_t *out_mem_mmap_bytes,
-		       uint32_t *out_txq_capacity, uint32_t *out_rxq_capacity)
-{
-	int rc;
-	EFRM_ASSERT(client != NULL);
-	rc = efrm_vi_resource_alloc_or_free(client, true, evq_virs, vi_flags,
-					    evq_capacity, txq_capacity,
-					    rxq_capacity, tx_q_tag, rx_q_tag,
-					    virs_out);
-	if (rc == 0) {
-		if (out_io_mmap_bytes != NULL)
-			*out_io_mmap_bytes = (*virs_out)->bar_mmap_bytes;
-		if (out_mem_mmap_bytes != NULL)
-			*out_mem_mmap_bytes = (*virs_out)->mem_mmap_bytes;
-		if (out_txq_capacity != NULL)
-			*out_txq_capacity =
-			    (*virs_out)->dmaq_capacity[EFRM_VI_RM_DMA_QUEUE_TX];
-		if (out_rxq_capacity != NULL)
-			*out_rxq_capacity =
-			    (*virs_out)->dmaq_capacity[EFRM_VI_RM_DMA_QUEUE_RX];
-	}
-
-	return rc;
-}
-EXPORT_SYMBOL(efrm_vi_resource_alloc);
-
-void efrm_vi_rm_free_flushed_resource(struct vi_resource *virs)
-{
-	EFRM_ASSERT(virs != NULL);
-	EFRM_ASSERT(virs->rs.rs_ref_count == 0);
-
-	EFRM_TRACE("%s: " EFRM_RESOURCE_FMT, __func__,
-		   EFRM_RESOURCE_PRI_ARG(virs->rs.rs_handle));
-	/* release the associated event queue then drop our own reference
-	 * count */
-	efrm_vi_rm_detach_evq(virs);
-	efrm_vi_rm_drop_ref(virs);
-}
diff -r 9566a4a50a43 drivers/net/sfc/sfc_resource/vi_resource_event.c
--- a/drivers/net/sfc/sfc_resource/vi_resource_event.c
+++ /dev/null
@@ -1,250 +0,0 @@
-/****************************************************************************
- * Driver for Solarflare network controllers -
- *          resource management for Xen backend, OpenOnload, etc
- *           (including support for SFE4001 10GBT NIC)
- *
- * This file contains event handling for VI resource.
- *
- * Copyright 2005-2007: Solarflare Communications Inc,
- *                      9501 Jeronimo Road, Suite 250,
- *                      Irvine, CA 92618, USA
- *
- * Developed and maintained by Solarflare Communications:
- *                      <linux-xen-drivers@solarflare.com>
- *                      <onload-dev@solarflare.com>
- *
- * Certain parts of the driver were implemented by
- *          Alexandra Kossovsky <Alexandra.Kossovsky@oktetlabs.ru>
- *          OKTET Labs Ltd, Russia,
- *          http://oktetlabs.ru, <info@oktetlabs.ru>
- *          by request of Solarflare Communications
- *
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 as published
- * by the Free Software Foundation, incorporated herein by reference.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
- ****************************************************************************
- */
-
-#include <ci/efrm/nic_table.h>
-#include <ci/driver/efab/hardware.h>
-#include <ci/efhw/eventq.h>
-#include <ci/efrm/private.h>
-#include <ci/efrm/vi_resource_private.h>
-#include <ci/efrm/efrm_nic.h>
-#include "efrm_internal.h"
-
-
-static inline int
-efrm_eventq_bytes(struct vi_resource *virs)
-{
-	return efrm_vi_rm_evq_bytes(virs);
-}
-
-
-static inline efhw_event_t *
-efrm_eventq_base(struct vi_resource *virs)
-{
-	struct eventq_resource_hardware *hw;
-	hw = &(virs->nic_info.evq_pages);
-	return (efhw_event_t *) (efhw_iopages_ptr(&(hw->iobuff)) +
-				 hw->iobuff_off);
-}
-
-
-void
-efrm_eventq_request_wakeup(struct vi_resource *virs, unsigned current_ptr)
-{
-	struct efhw_nic *nic = virs->rs.rs_client->nic;
-	int next_i;
-	next_i = ((current_ptr / sizeof(efhw_event_t)) &
-		  (virs->evq_capacity - 1));
-
-	efhw_nic_wakeup_request(nic, efrm_eventq_dma_addr(virs), next_i,
-				EFRM_RESOURCE_INSTANCE(virs->rs.rs_handle));
-}
-EXPORT_SYMBOL(efrm_eventq_request_wakeup);
-
-void efrm_eventq_reset(struct vi_resource *virs)
-{
-	struct efhw_nic *nic = virs->rs.rs_client->nic;
-	int instance = EFRM_RESOURCE_INSTANCE(virs->rs.rs_handle);
-
-	EFRM_ASSERT(virs->evq_capacity != 0);
-
-	/* FIXME: Protect against concurrent resets. */
-
-	efhw_nic_event_queue_disable(nic, instance, 0);
-
-	memset(efrm_eventq_base(virs), EFHW_CLEAR_EVENT_VALUE,
-	       efrm_eventq_bytes(virs));
-	efhw_nic_event_queue_enable(nic, instance, virs->evq_capacity,
-				    efrm_eventq_dma_addr(virs),
-				    virs->nic_info.evq_pages.
-				      buf_tbl_alloc.base,
-				    instance < 64);
-	EFRM_TRACE("%s: " EFRM_RESOURCE_FMT, __func__,
-		   EFRM_RESOURCE_PRI_ARG(virs->rs.rs_handle));
-}
-EXPORT_SYMBOL(efrm_eventq_reset);
-
-int
-efrm_eventq_register_callback(struct vi_resource *virs,
-			      void (*handler) (void *, int,
-					       struct efhw_nic *nic),
-			      void *arg)
-{
-	struct efrm_nic_per_vi *cb_info;
-	int instance;
-	int bit;
-
-	EFRM_RESOURCE_ASSERT_VALID(&virs->rs, 0);
-	EFRM_ASSERT(virs->evq_capacity != 0);
-	EFRM_ASSERT(handler != NULL);
-
-	/* ?? TODO: Get rid of this test when client is compulsory. */
-	if (virs->rs.rs_client == NULL) {
-		EFRM_ERR("%s: no client", __func__);
-		return -EINVAL;
-	}
-
-	virs->evq_callback_arg = arg;
-	virs->evq_callback_fn = handler;
-	instance = EFRM_RESOURCE_INSTANCE(virs->rs.rs_handle);
-	cb_info = &efrm_nic(virs->rs.rs_client->nic)->vis[instance];
-
-	/* The handler can be set only once. */
-	bit = test_and_set_bit(VI_RESOURCE_EVQ_STATE_CALLBACK_REGISTERED,
-			       &cb_info->state);
-	if (bit)
-		return -EBUSY;
-	cb_info->vi = virs;
-
-	return 0;
-}
-EXPORT_SYMBOL(efrm_eventq_register_callback);
-
-void efrm_eventq_kill_callback(struct vi_resource *virs)
-{
-	struct efrm_nic_per_vi *cb_info;
-	int32_t evq_state;
-	int instance;
-	int bit;
-
-	EFRM_RESOURCE_ASSERT_VALID(&virs->rs, 0);
-	EFRM_ASSERT(virs->evq_capacity != 0);
-	EFRM_ASSERT(virs->rs.rs_client != NULL);
-
-	instance = EFRM_RESOURCE_INSTANCE(virs->rs.rs_handle);
-	cb_info = &efrm_nic(virs->rs.rs_client->nic)->vis[instance];
-	cb_info->vi = NULL;
-
-	/* Disable the timer. */
-	efhw_nic_event_queue_disable(virs->rs.rs_client->nic,
-				     instance, /*timer_only */ 1);
-
-	/* Disable the callback. */
-	bit = test_and_clear_bit(VI_RESOURCE_EVQ_STATE_CALLBACK_REGISTERED,
-				 &cb_info->state);
-	EFRM_ASSERT(bit);	/* do not call me twice! */
-
-	/* Spin until the callback is complete. */
-	do {
-		rmb();
-
-		udelay(1);
-		evq_state = cb_info->state;
-	} while ((evq_state & VI_RESOURCE_EVQ_STATE(BUSY)));
-
-	virs->evq_callback_fn = NULL;
-}
-EXPORT_SYMBOL(efrm_eventq_kill_callback);
-
-static void
-efrm_eventq_do_callback(struct efhw_nic *nic, unsigned instance,
-			bool is_timeout)
-{
-	struct efrm_nic *rnic = efrm_nic(nic);
-	void (*handler) (void *, int is_timeout, struct efhw_nic *nic);
-	void *arg;
-	struct efrm_nic_per_vi *cb_info;
-	int32_t evq_state;
-	int32_t new_evq_state;
-	struct vi_resource *virs;
-	int bit;
-
-	EFRM_ASSERT(efrm_vi_manager);
-
-	cb_info = &rnic->vis[instance];
-
-	/* Set the BUSY bit and clear WAKEUP_PENDING.  Do this
-	 * before waking up the sleeper to avoid races. */
-	while (1) {
-		evq_state = cb_info->state;
-		new_evq_state = evq_state;
-
-		if ((evq_state & VI_RESOURCE_EVQ_STATE(BUSY)) != 0) {
-			EFRM_ERR("%s:%d: evq_state[%d] corrupted!",
-				 __func__, __LINE__, instance);
-			return;
-		}
-
-		if (!is_timeout)
-			new_evq_state &= ~VI_RESOURCE_EVQ_STATE(WAKEUP_PENDING);
-
-		if (evq_state & VI_RESOURCE_EVQ_STATE(CALLBACK_REGISTERED)) {
-			new_evq_state |= VI_RESOURCE_EVQ_STATE(BUSY);
-			virs = cb_info->vi;
-			if (cmpxchg(&cb_info->state, evq_state,
-				    new_evq_state) == evq_state)
-				break;
-		} else {
-			/* Just update the state if necessary. */
-			if (new_evq_state == evq_state ||
-			    cmpxchg(&cb_info->state, evq_state,
-				    new_evq_state) == evq_state)
-				return;
-		}
-	}
-
-	if (virs) {
-		handler = virs->evq_callback_fn;
-		arg = virs->evq_callback_arg;
-		EFRM_ASSERT(handler != NULL);
-		handler(arg, is_timeout, nic);
-	}
-
-	/* Clear the BUSY bit. */
-	bit =
-	    test_and_clear_bit(VI_RESOURCE_EVQ_STATE_BUSY,
-			       &cb_info->state);
-	if (!bit) {
-		EFRM_ERR("%s:%d: evq_state corrupted!",
-			 __func__, __LINE__);
-	}
-}
-
-void efrm_handle_wakeup_event(struct efhw_nic *nic, unsigned instance)
-{
-	efrm_eventq_do_callback(nic, instance, false);
-}
-
-void efrm_handle_timeout_event(struct efhw_nic *nic, unsigned instance)
-{
-	efrm_eventq_do_callback(nic, instance, true);
-}
-
-void efrm_handle_sram_event(struct efhw_nic *nic)
-{
-  if (nic->buf_commit_outstanding > 0)
-    nic->buf_commit_outstanding--;
-}
diff -r 9566a4a50a43 drivers/net/sfc/sfc_resource/vi_resource_flush.c
--- a/drivers/net/sfc/sfc_resource/vi_resource_flush.c
+++ /dev/null
@@ -1,483 +0,0 @@
-/****************************************************************************
- * Driver for Solarflare network controllers -
- *          resource management for Xen backend, OpenOnload, etc
- *           (including support for SFE4001 10GBT NIC)
- *
- * This file contains DMA queue flushing of VI resources.
- *
- * Copyright 2005-2007: Solarflare Communications Inc,
- *                      9501 Jeronimo Road, Suite 250,
- *                      Irvine, CA 92618, USA
- *
- * Developed and maintained by Solarflare Communications:
- *                      <linux-xen-drivers@solarflare.com>
- *                      <onload-dev@solarflare.com>
- *
- * Certain parts of the driver were implemented by
- *          Alexandra Kossovsky <Alexandra.Kossovsky@oktetlabs.ru>
- *          OKTET Labs Ltd, Russia,
- *          http://oktetlabs.ru, <info@oktetlabs.ru>
- *          by request of Solarflare Communications
- *
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 as published
- * by the Free Software Foundation, incorporated herein by reference.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
- ****************************************************************************
- */
-
-#include <ci/efrm/nic_table.h>
-#include <ci/driver/efab/hardware.h>
-#include <ci/efhw/falcon.h>
-#include <ci/efrm/private.h>
-#include <ci/efrm/sysdep.h>
-#include <ci/efrm/buffer_table.h>
-#include <ci/efrm/vi_resource_private.h>
-#include "efrm_internal.h"
-
-
-/* can fail as workitem can already be scheuled -- ignore failure */
-#define EFRM_VI_RM_DELAYED_FREE(manager) \
-	queue_work(manager->workqueue, &manager->work_item)
-
-static const int flush_fifo_hwm = 8 /* TODO should be a HW specific const */ ;
-
-static void
-efrm_vi_resource_rx_flush_done(struct vi_resource *virs, bool *completed)
-{
-	/* We should only get a flush event if there is a flush
-	 * outstanding. */
-	EFRM_ASSERT(virs->rx_flush_outstanding);
-
-	virs->rx_flush_outstanding = 0;
-	virs->rx_flushing = 0;
-
-	list_del(&virs->rx_flush_link);
-	efrm_vi_manager->rx_flush_outstanding_count--;
-
-	if (virs->tx_flushing == 0) {
-		list_add_tail(&virs->rx_flush_link,
-			      &efrm_vi_manager->close_pending);
-		*completed = 1;
-	}
-}
-
-static void
-efrm_vi_resource_tx_flush_done(struct vi_resource *virs, bool *completed)
-{
-	/* We should only get a flush event if there is a flush
-	 * outstanding. */
-	EFRM_ASSERT(virs->tx_flushing);
-
-	virs->tx_flushing = 0;
-
-	list_del(&virs->tx_flush_link);
-
-	if (virs->rx_flushing == 0) {
-		list_add_tail(&virs->rx_flush_link,
-			      &efrm_vi_manager->close_pending);
-		*completed = 1;
-	}
-}
-
-static void
-efrm_vi_resource_issue_rx_flush(struct vi_resource *virs, bool *completed)
-{
-	struct efhw_nic *nic = virs->rs.rs_client->nic;
-	int instance;
-	int rc;
-
-	instance = EFRM_RESOURCE_INSTANCE(virs->rs.rs_handle);
-
-	list_add_tail(&virs->rx_flush_link,
-		      &efrm_vi_manager->rx_flush_outstanding_list);
-	virs->rx_flush_outstanding = virs->rx_flushing;
-	efrm_vi_manager->rx_flush_outstanding_count++;
-
-	EFRM_TRACE("%s: rx queue %d flush requested for nic %d",
-		   __func__, instance, nic->index);
-	rc = efhw_nic_flush_rx_dma_channel(nic, instance);
-	if (rc == -EAGAIN)
-		efrm_vi_resource_rx_flush_done(virs, completed);
-}
-
-static void
-efrm_vi_resource_issue_tx_flush(struct vi_resource *virs, bool *completed)
-{
-	struct efhw_nic *nic = virs->rs.rs_client->nic;
-	int instance;
-	int rc;
-
-	instance = EFRM_RESOURCE_INSTANCE(virs->rs.rs_handle);
-
-	list_add_tail(&virs->tx_flush_link,
-		      &efrm_vi_manager->tx_flush_outstanding_list);
-
-	EFRM_TRACE("%s: tx queue %d flush requested for nic %d",
-		   __func__, instance, nic->index);
-	rc = efhw_nic_flush_tx_dma_channel(nic, instance);
-	if (rc == -EAGAIN)
-		efrm_vi_resource_tx_flush_done(virs, completed);
-}
-
-static void efrm_vi_resource_process_waiting_flushes(bool *completed)
-{
-	struct vi_resource *virs;
-
-	while (efrm_vi_manager->rx_flush_outstanding_count < flush_fifo_hwm &&
-	       !list_empty(&efrm_vi_manager->rx_flush_waiting_list)) {
-		virs =
-		    list_entry(list_pop
-			       (&efrm_vi_manager->rx_flush_waiting_list),
-			       struct vi_resource, rx_flush_link);
-		efrm_vi_resource_issue_rx_flush(virs, completed);
-	}
-}
-
-#if BUG7916_WORKAROUND || BUG5302_WORKAROUND
-static void
-efrm_vi_resource_flush_retry_vi(struct vi_resource *virs,
-				int64_t time_now, bool *completed)
-{
-	struct efhw_nic *nic;
-	int instance;
-
-	instance = EFRM_RESOURCE_INSTANCE(virs->rs.rs_handle);
-
-	virs->flush_count++;
-	virs->flush_time = time_now;
-	nic = virs->rs.rs_client->nic;
-
-#if BUG7916_WORKAROUND
-	if (virs->rx_flush_outstanding) {
-		EFRM_TRACE("%s: Retrying RX flush on instance %d",
-			   __func__, instance);
-
-		list_del(&virs->rx_flush_link);
-		efrm_vi_manager->rx_flush_outstanding_count--;
-		efrm_vi_resource_issue_rx_flush(virs, completed);
-		efrm_vi_resource_process_waiting_flushes(completed);
-	}
-#endif
-
-#if BUG5302_WORKAROUND
-	if (virs->tx_flushing) {
-		if (virs->flush_count > 5) {
-			EFRM_TRACE("%s: VI resource stuck flush pending "
-				   "(instance=%d, count=%d)",
-				   __func__, instance, virs->flush_count);
-			falcon_clobber_tx_dma_ptrs(nic, instance);
-		} else {
-			EFRM_TRACE("%s: Retrying TX flush on instance %d",
-				   __func__, instance);
-		}
-
-		list_del(&virs->tx_flush_link);
-		efrm_vi_resource_issue_tx_flush(virs, completed);
-	}
-#endif
-}
-#endif
-
-int efrm_vi_resource_flush_retry(struct vi_resource *virs)
-{
-#if BUG7916_WORKAROUND || BUG5302_WORKAROUND
-	irq_flags_t lock_flags;
-	bool completed = false;
-
-	if (virs->rx_flushing == 0 && virs->tx_flushing == 0)
-		return -EALREADY;
-
-	spin_lock_irqsave(&efrm_vi_manager->rm.rm_lock, lock_flags);
-	efrm_vi_resource_flush_retry_vi(virs, get_jiffies_64(), &completed);
-	spin_unlock_irqrestore(&efrm_vi_manager->rm.rm_lock, lock_flags);
-
-	if (completed)
-		EFRM_VI_RM_DELAYED_FREE(efrm_vi_manager);
-#endif
-
-	return 0;
-}
-EXPORT_SYMBOL(efrm_vi_resource_flush_retry);
-
-#if BUG7916_WORKAROUND || BUG5302_WORKAROUND
-/* resource manager lock should be taken before this call */
-static void efrm_vi_handle_flush_loss(bool *completed)
-{
-	struct list_head *pos, *temp;
-	struct vi_resource *virs;
-	int64_t time_now, time_pending;
-
-	/* It's possible we miss flushes - the list is sorted in order we
-	 * generate flushes, see if any are very old. It's also possible
-	 * that we decide an endpoint is flushed even though we've not
-	 * received all the flush events. We *should * mark as
-	 * completed, reclaim and loop again. ??
-	 * THIS NEEDS BACKPORTING FROM THE FALCON branch
-	 */
-	time_now = get_jiffies_64();
-
-#if BUG7916_WORKAROUND
-	list_for_each_safe(pos, temp,
-			   &efrm_vi_manager->rx_flush_outstanding_list) {
-		virs = container_of(pos, struct vi_resource, rx_flush_link);
-
-		time_pending = time_now - virs->flush_time;
-
-		/* List entries are held in reverse chronological order.  Only
-		 * process the old ones. */
-		if (time_pending <= 0x100000000LL)
-			break;
-
-		efrm_vi_resource_flush_retry_vi(virs, time_now, completed);
-	}
-#endif
-
-#if BUG5302_WORKAROUND
-	list_for_each_safe(pos, temp,
-			   &efrm_vi_manager->tx_flush_outstanding_list) {
-		virs = container_of(pos, struct vi_resource, tx_flush_link);
-
-		time_pending = time_now - virs->flush_time;
-
-		/* List entries are held in reverse chronological order.
-		 * Only process the old ones. */
-		if (time_pending <= 0x100000000LL)
-			break;
-
-		efrm_vi_resource_flush_retry_vi(virs, time_now, completed);
-	}
-#endif
-}
-#endif
-
-void
-efrm_vi_register_flush_callback(struct vi_resource *virs,
-				void (*handler)(void *), void *arg)
-{
-	if (handler == NULL) {
-		virs->flush_callback_fn = handler;
-		wmb();
-		virs->flush_callback_arg = arg;
-	} else {
-		virs->flush_callback_arg = arg;
-		wmb();
-		virs->flush_callback_fn = handler;
-	}
-}
-EXPORT_SYMBOL(efrm_vi_register_flush_callback);
-
-int efrm_pt_flush(struct vi_resource *virs)
-{
-	int instance;
-	irq_flags_t lock_flags;
-	bool completed = false;
-
-	instance = EFRM_RESOURCE_INSTANCE(virs->rs.rs_handle);
-
-	EFRM_ASSERT(virs->rx_flushing == 0);
-	EFRM_ASSERT(virs->rx_flush_outstanding == 0);
-	EFRM_ASSERT(virs->tx_flushing == 0);
-
-	EFRM_TRACE("%s: " EFRM_RESOURCE_FMT " EVQ=%d TXQ=%d RXQ=%d",
-		   __func__, EFRM_RESOURCE_PRI_ARG(virs->rs.rs_handle),
-		   virs->evq_capacity,
-		   virs->dmaq_capacity[EFRM_VI_RM_DMA_QUEUE_TX],
-		   virs->dmaq_capacity[EFRM_VI_RM_DMA_QUEUE_RX]);
-
-	spin_lock_irqsave(&efrm_vi_manager->rm.rm_lock, lock_flags);
-
-	if (virs->dmaq_capacity[EFRM_VI_RM_DMA_QUEUE_RX] != 0)
-		virs->rx_flushing = 1;
-
-	if (virs->dmaq_capacity[EFRM_VI_RM_DMA_QUEUE_TX] != 0)
-		virs->tx_flushing = 1;
-
-	/* Clean up immediately if there are no flushes. */
-	if (virs->rx_flushing == 0 && virs->tx_flushing == 0) {
-		list_add_tail(&virs->rx_flush_link,
-			      &efrm_vi_manager->close_pending);
-		completed = true;
-	}
-
-	/* Issue the RX flush if possible or queue it for later. */
-	if (virs->rx_flushing) {
-#if BUG7916_WORKAROUND || BUG5302_WORKAROUND
-		if (efrm_vi_manager->rx_flush_outstanding_count >=
-		    flush_fifo_hwm)
-			efrm_vi_handle_flush_loss(&completed);
-#endif
-		if (efrm_vi_manager->rx_flush_outstanding_count >=
-		    flush_fifo_hwm) {
-			list_add_tail(&virs->rx_flush_link,
-				      &efrm_vi_manager->rx_flush_waiting_list);
-		} else {
-			efrm_vi_resource_issue_rx_flush(virs, &completed);
-		}
-	}
-
-	/* Issue the TX flush.  There's no limit to the number of
-	 * outstanding TX flushes. */
-	if (virs->tx_flushing)
-		efrm_vi_resource_issue_tx_flush(virs, &completed);
-
-	virs->flush_time = get_jiffies_64();
-
-	spin_unlock_irqrestore(&efrm_vi_manager->rm.rm_lock, lock_flags);
-
-	if (completed)
-		EFRM_VI_RM_DELAYED_FREE(efrm_vi_manager);
-
-	return 0;
-}
-EXPORT_SYMBOL(efrm_pt_flush);
-
-static void
-efrm_handle_rx_dmaq_flushed(struct efhw_nic *flush_nic, int instance,
-			    bool *completed)
-{
-	struct list_head *pos, *temp;
-	struct vi_resource *virs;
-
-	list_for_each_safe(pos, temp,
-			   &efrm_vi_manager->rx_flush_outstanding_list) {
-		virs = container_of(pos, struct vi_resource, rx_flush_link);
-
-		if (instance == EFRM_RESOURCE_INSTANCE(virs->rs.rs_handle)) {
-			efrm_vi_resource_rx_flush_done(virs, completed);
-			efrm_vi_resource_process_waiting_flushes(completed);
-			return;
-		}
-	}
-	EFRM_TRACE("%s: Unhandled rx flush event, nic %d, instance %d",
-		   __func__, flush_nic->index, instance);
-}
-
-static void
-efrm_handle_tx_dmaq_flushed(struct efhw_nic *flush_nic, int instance,
-			    bool *completed)
-{
-	struct list_head *pos, *temp;
-	struct vi_resource *virs;
-
-	list_for_each_safe(pos, temp,
-			   &efrm_vi_manager->tx_flush_outstanding_list) {
-		virs = container_of(pos, struct vi_resource, tx_flush_link);
-
-		if (instance == EFRM_RESOURCE_INSTANCE(virs->rs.rs_handle)) {
-			efrm_vi_resource_tx_flush_done(virs, completed);
-			return;
-		}
-	}
-	EFRM_TRACE("%s: Unhandled tx flush event, nic %d, instance %d",
-		   __func__, flush_nic->index, instance);
-}
-
-void
-efrm_handle_dmaq_flushed(struct efhw_nic *flush_nic, unsigned instance,
-			 int rx_flush)
-{
-	irq_flags_t lock_flags;
-	bool completed = false;
-
-	EFRM_TRACE("%s: nic_i=%d  instance=%d  rx_flush=%d", __func__,
-		   flush_nic->index, instance, rx_flush);
-
-	spin_lock_irqsave(&efrm_vi_manager->rm.rm_lock, lock_flags);
-
-	if (rx_flush)
-		efrm_handle_rx_dmaq_flushed(flush_nic, instance, &completed);
-	else
-		efrm_handle_tx_dmaq_flushed(flush_nic, instance, &completed);
-
-#if BUG7916_WORKAROUND || BUG5302_WORKAROUND
-	efrm_vi_handle_flush_loss(&completed);
-#endif
-
-	spin_unlock_irqrestore(&efrm_vi_manager->rm.rm_lock, lock_flags);
-
-	if (completed)
-		EFRM_VI_RM_DELAYED_FREE(efrm_vi_manager);
-}
-
-static void
-efrm_vi_rm_reinit_dmaqs(struct vi_resource *virs)
-{
-	struct efhw_nic *nic = virs->rs.rs_client->nic;
-
-	if (virs->dmaq_capacity[EFRM_VI_RM_DMA_QUEUE_TX] != 0)
-		efrm_vi_rm_init_dmaq(virs, EFRM_VI_RM_DMA_QUEUE_TX, nic);
-	if (virs->dmaq_capacity[EFRM_VI_RM_DMA_QUEUE_RX])
-		efrm_vi_rm_init_dmaq(virs, EFRM_VI_RM_DMA_QUEUE_RX, nic);
-}
-
-/* free any PT endpoints whose flush has now complete */
-void efrm_vi_rm_delayed_free(struct work_struct *data)
-{
-	irq_flags_t lock_flags;
-	struct list_head close_pending;
-	struct vi_resource *virs;
-
-	EFRM_RESOURCE_MANAGER_ASSERT_VALID(&efrm_vi_manager->rm);
-
-	spin_lock_irqsave(&efrm_vi_manager->rm.rm_lock, lock_flags);
-	list_replace_init(&efrm_vi_manager->close_pending, &close_pending);
-	spin_unlock_irqrestore(&efrm_vi_manager->rm.rm_lock, lock_flags);
-
-	EFRM_TRACE("%s: %p", __func__, efrm_vi_manager);
-	while (!list_empty(&close_pending)) {
-		virs =
-		    list_entry(list_pop(&close_pending), struct vi_resource,
-			       rx_flush_link);
-		EFRM_TRACE("%s: flushed VI instance=%d", __func__,
-			   EFRM_RESOURCE_INSTANCE(virs->rs.rs_handle));
-
-		if (virs->flush_callback_fn != NULL) {
-			efrm_vi_rm_reinit_dmaqs(virs);
-			virs->flush_callback_fn(virs->flush_callback_arg);
-		} else
-			efrm_vi_rm_free_flushed_resource(virs);
-	}
-}
-
-void efrm_vi_rm_salvage_flushed_vis(void)
-{
-#if BUG7916_WORKAROUND || BUG5302_WORKAROUND
-	irq_flags_t lock_flags;
-	bool completed;
-
-	spin_lock_irqsave(&efrm_vi_manager->rm.rm_lock, lock_flags);
-	efrm_vi_handle_flush_loss(&completed);
-	spin_unlock_irqrestore(&efrm_vi_manager->rm.rm_lock, lock_flags);
-#endif
-
-	efrm_vi_rm_delayed_free(&efrm_vi_manager->work_item);
-}
-
-void efrm_vi_resource_free(struct vi_resource *virs)
-{
-	efrm_vi_register_flush_callback(virs, NULL, NULL);
-	efrm_pt_flush(virs);
-}
-EXPORT_SYMBOL(efrm_vi_resource_free);
-
-
-void efrm_vi_resource_release(struct vi_resource *virs)
-{
-	if (__efrm_resource_release(&virs->rs))
-		efrm_vi_resource_free(virs);
-}
-EXPORT_SYMBOL(efrm_vi_resource_release);
-
-/*
- * vi: sw=8:ai:aw
- */
diff -r 9566a4a50a43 drivers/net/sfc/sfc_resource/vi_resource_manager.c
--- a/drivers/net/sfc/sfc_resource/vi_resource_manager.c
+++ /dev/null
@@ -1,231 +0,0 @@
-/****************************************************************************
- * Driver for Solarflare network controllers -
- *          resource management for Xen backend, OpenOnload, etc
- *           (including support for SFE4001 10GBT NIC)
- *
- * This file contains the VI resource manager.
- *
- * Copyright 2005-2007: Solarflare Communications Inc,
- *                      9501 Jeronimo Road, Suite 250,
- *                      Irvine, CA 92618, USA
- *
- * Developed and maintained by Solarflare Communications:
- *                      <linux-xen-drivers@solarflare.com>
- *                      <onload-dev@solarflare.com>
- *
- * Certain parts of the driver were implemented by
- *          Alexandra Kossovsky <Alexandra.Kossovsky@oktetlabs.ru>
- *          OKTET Labs Ltd, Russia,
- *          http://oktetlabs.ru, <info@oktetlabs.ru>
- *          by request of Solarflare Communications
- *
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 as published
- * by the Free Software Foundation, incorporated herein by reference.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
- ****************************************************************************
- */
-
-#include <ci/efrm/nic_table.h>
-#include <ci/driver/efab/hardware.h>
-#include <ci/efhw/falcon.h>
-#include <ci/efrm/private.h>
-#include <ci/efrm/vi_resource_private.h>
-#include "efrm_internal.h"
-
-
-int efrm_pt_pace(struct vi_resource *virs, unsigned int val)
-{
-	struct efhw_nic *nic = virs->rs.rs_client->nic;
-	int instance;
-
-	EFRM_RESOURCE_ASSERT_VALID(&virs->rs, 0);
-	instance = EFRM_RESOURCE_INSTANCE(virs->rs.rs_handle);
-	falcon_nic_pace(nic, instance, val);
-	EFRM_TRACE("%s[%d]=%d DONE", __func__, instance, val);
-	return 0;
-}
-EXPORT_SYMBOL(efrm_pt_pace);
-
-/*** Resource manager creation/destruction *******************************/
-
-static void efrm_vi_rm_dtor(struct efrm_resource_manager *rm);
-
-static int
-efrm_create_or_destroy_vi_resource_manager(
-				struct efrm_resource_manager **rm_in_out,
-				const struct vi_resource_dimensions *dims,
-				bool destroy)
-{
-	struct vi_resource *virs;
-	struct list_head *pos, *temp;
-	struct list_head flush_pending;
-	irq_flags_t lock_flags;
-	int rc;
-	unsigned dmaq_min, dmaq_lim;
-
-	EFRM_ASSERT(rm_in_out);
-
-	if (destroy)
-		goto destroy;
-
-	EFRM_ASSERT(dims);
-	EFRM_NOTICE("vi_resource_manager: evq_int=%u-%u evq_timer=%u-%u",
-		    dims->evq_int_min, dims->evq_int_lim,
-		    dims->evq_timer_min, dims->evq_timer_lim);
-	EFRM_NOTICE("vi_resource_manager: rxq=%u-%u txq=%u-%u",
-		    dims->rxq_min, dims->rxq_lim,
-		    dims->txq_min, dims->txq_lim);
-
-	efrm_vi_manager = kmalloc(sizeof(*efrm_vi_manager), GFP_KERNEL);
-	if (efrm_vi_manager == NULL) {
-		rc = -ENOMEM;
-		goto fail_alloc;
-	}
-
-	memset(efrm_vi_manager, 0, sizeof(*efrm_vi_manager));
-
-	efrm_vi_manager->iscsi_dmaq_instance_is_free = true;
-
-	dmaq_min = max(dims->rxq_min, dims->txq_min);
-	dmaq_lim = min(dims->rxq_lim, dims->txq_lim);
-
-	efrm_vi_manager->with_timer_base =
-	    max(dmaq_min, dims->evq_timer_min);
-	efrm_vi_manager->with_timer_limit =
-	    min(dmaq_lim, dims->evq_timer_lim);
-	rc = efrm_kfifo_id_ctor(&efrm_vi_manager->instances_with_timer,
-				efrm_vi_manager->with_timer_base,
-				efrm_vi_manager->with_timer_limit,
-				&efrm_vi_manager->rm.rm_lock);
-	if (rc < 0)
-		goto fail_with_timer_id_pool;
-
-	efrm_vi_manager->with_interrupt_base =
-	    max(dmaq_min, dims->evq_int_min);
-	efrm_vi_manager->with_interrupt_limit =
-	    min(dmaq_lim, dims->evq_int_lim);
-	efrm_vi_manager->with_interrupt_limit =
-		max(efrm_vi_manager->with_interrupt_limit,
-		    efrm_vi_manager->with_interrupt_base);
-	rc = efrm_kfifo_id_ctor(&efrm_vi_manager->instances_with_interrupt,
-				efrm_vi_manager->with_interrupt_base,
-				efrm_vi_manager->with_interrupt_limit,
-				&efrm_vi_manager->rm.rm_lock);
-	if (rc < 0)
-		goto fail_with_int_id_pool;
-
-	INIT_LIST_HEAD(&efrm_vi_manager->rx_flush_waiting_list);
-	INIT_LIST_HEAD(&efrm_vi_manager->rx_flush_outstanding_list);
-	INIT_LIST_HEAD(&efrm_vi_manager->tx_flush_outstanding_list);
-	efrm_vi_manager->rx_flush_outstanding_count = 0;
-
-	INIT_LIST_HEAD(&efrm_vi_manager->close_pending);
-	efrm_vi_manager->workqueue = create_workqueue("sfc_vi");
-	if (efrm_vi_manager->workqueue == NULL)
-		goto fail_create_workqueue;
-	INIT_WORK(&efrm_vi_manager->work_item, efrm_vi_rm_delayed_free);
-
-	/* NB.  This must be the last step to avoid things getting tangled.
-	 * efrm_resource_manager_dtor calls the vi_rm_dtor which ends up in
-	 * this function. */
-	rc = efrm_resource_manager_ctor(&efrm_vi_manager->rm, efrm_vi_rm_dtor,
-					"VI", EFRM_RESOURCE_VI);
-	if (rc < 0)
-		goto fail_rm_ctor;
-
-	*rm_in_out = &efrm_vi_manager->rm;
-	return 0;
-
-destroy:
-	rc = 0;
-	EFRM_RESOURCE_MANAGER_ASSERT_VALID(*rm_in_out);
-
-	/* Abort outstanding flushes.  Note, a VI resource can be on more
-	 * than one of these lists.  We handle this by starting with the TX
-	 * list and then append VIs to this list if they aren't on the TX
-	 * list already.  A VI is on the TX flush list if tx_flushing
-	 * is not empty. */
-	spin_lock_irqsave(&efrm_vi_manager->rm.rm_lock, lock_flags);
-
-	list_replace_init(&efrm_vi_manager->tx_flush_outstanding_list,
-			  &flush_pending);
-
-	list_for_each_safe(pos, temp,
-			   &efrm_vi_manager->rx_flush_waiting_list) {
-		virs = container_of(pos, struct vi_resource, rx_flush_link);
-
-		list_del(&virs->rx_flush_link);
-		if (virs->tx_flushing == 0)
-			list_add_tail(&virs->tx_flush_link, &flush_pending);
-	}
-
-	list_for_each_safe(pos, temp,
-			   &efrm_vi_manager->rx_flush_outstanding_list) {
-		virs = container_of(pos, struct vi_resource, rx_flush_link);
-
-		list_del(&virs->rx_flush_link);
-		if (virs->tx_flushing == 0)
-			list_add_tail(&virs->tx_flush_link, &flush_pending);
-	}
-
-	spin_unlock_irqrestore(&efrm_vi_manager->rm.rm_lock, lock_flags);
-
-	while (!list_empty(&flush_pending)) {
-		virs =
-		    list_entry(list_pop(&flush_pending), struct vi_resource,
-			       tx_flush_link);
-		EFRM_TRACE("%s: found PT endpoint " EFRM_RESOURCE_FMT
-			   " with flush pending [Tx=0x%x, Rx=0x%x, RxO=0x%x]",
-			   __func__,
-			   EFRM_RESOURCE_PRI_ARG(virs->rs.rs_handle),
-			   virs->tx_flushing,
-			   virs->rx_flushing,
-			   virs->rx_flush_outstanding);
-		efrm_vi_rm_free_flushed_resource(virs);
-	}
-
-fail_rm_ctor:
-
-	/* Complete outstanding closes. */
-	destroy_workqueue(efrm_vi_manager->workqueue);
-fail_create_workqueue:
-	EFRM_ASSERT(list_empty(&efrm_vi_manager->close_pending));
-	kfifo_vfree(efrm_vi_manager->instances_with_interrupt);
-fail_with_int_id_pool:
-
-	kfifo_vfree(efrm_vi_manager->instances_with_timer);
-fail_with_timer_id_pool:
-
-	if (destroy)
-		return 0;
-
-	EFRM_DO_DEBUG(memset(efrm_vi_manager, 0, sizeof(*efrm_vi_manager)));
-	kfree(efrm_vi_manager);
-fail_alloc:
-
-	*rm_in_out = NULL;
-	EFRM_ERR("%s: failed rc=%d", __func__, rc);
-	return rc;
-}
-
-int
-efrm_create_vi_resource_manager(struct efrm_resource_manager **rm_out,
-				const struct vi_resource_dimensions *dims)
-{
-	return efrm_create_or_destroy_vi_resource_manager(rm_out, dims, false);
-}
-
-static void efrm_vi_rm_dtor(struct efrm_resource_manager *rm)
-{
-	efrm_create_or_destroy_vi_resource_manager(&rm, NULL, true);
-}
diff -r 9566a4a50a43 drivers/net/sfc/sfe4001.c
--- a/drivers/net/sfc/sfe4001.c
+++ /dev/null
@@ -1,435 +0,0 @@
-/****************************************************************************
- * Driver for Solarflare Solarstorm network controllers and boards
- * Copyright 2007-2008 Solarflare Communications Inc.
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 as published
- * by the Free Software Foundation, incorporated herein by reference.
- */
-
-/*****************************************************************************
- * Support for the SFE4001 and SFN4111T NICs.
- *
- * The SFE4001 does not power-up fully at reset due to its high power
- * consumption.  We control its power via a PCA9539 I/O expander.
- * Both boards have a MAX6647 temperature monitor which we expose to
- * the lm90 driver.
- *
- * This also provides minimal support for reflashing the PHY, which is
- * initiated by resetting it with the FLASH_CFG_1 pin pulled down.
- * On SFE4001 rev A2 and later this is connected to the 3V3X output of
- * the IO-expander; on the SFN4111T it is connected to Falcon's GPIO3.
- * We represent reflash mode as PHY_MODE_SPECIAL and make it mutually
- * exclusive with the network device being open.
- */
-
-#include <linux/delay.h>
-#include <linux/rtnetlink.h>
-#include "net_driver.h"
-#include "efx.h"
-#include "phy.h"
-#include "boards.h"
-#include "falcon.h"
-#include "falcon_hwdefs.h"
-#include "falcon_io.h"
-#include "mac.h"
-#include "workarounds.h"
-
-/**************************************************************************
- *
- * I2C IO Expander device
- *
- **************************************************************************/
-#define	PCA9539 0x74
-
-#define	P0_IN 0x00
-#define	P0_OUT 0x02
-#define	P0_INVERT 0x04
-#define	P0_CONFIG 0x06
-
-#define	P0_EN_1V0X_LBN 0
-#define	P0_EN_1V0X_WIDTH 1
-#define	P0_EN_1V2_LBN 1
-#define	P0_EN_1V2_WIDTH 1
-#define	P0_EN_2V5_LBN 2
-#define	P0_EN_2V5_WIDTH 1
-#define	P0_EN_3V3X_LBN 3
-#define	P0_EN_3V3X_WIDTH 1
-#define	P0_EN_5V_LBN 4
-#define	P0_EN_5V_WIDTH 1
-#define	P0_SHORTEN_JTAG_LBN 5
-#define	P0_SHORTEN_JTAG_WIDTH 1
-#define	P0_X_TRST_LBN 6
-#define	P0_X_TRST_WIDTH 1
-#define	P0_DSP_RESET_LBN 7
-#define	P0_DSP_RESET_WIDTH 1
-
-#define	P1_IN 0x01
-#define	P1_OUT 0x03
-#define	P1_INVERT 0x05
-#define	P1_CONFIG 0x07
-
-#define	P1_AFE_PWD_LBN 0
-#define	P1_AFE_PWD_WIDTH 1
-#define	P1_DSP_PWD25_LBN 1
-#define	P1_DSP_PWD25_WIDTH 1
-#define	P1_RESERVED_LBN 2
-#define	P1_RESERVED_WIDTH 2
-#define	P1_SPARE_LBN 4
-#define	P1_SPARE_WIDTH 4
-
-/* Temperature Sensor */
-#define MAX664X_REG_RSL		0x02
-#define MAX664X_REG_WLHO	0x0B
-
-static void sfe4001_poweroff(struct efx_nic *efx)
-{
-	struct i2c_client *ioexp_client = efx->board_info.ioexp_client;
-	struct i2c_client *hwmon_client = efx->board_info.hwmon_client;
-
-	/* Turn off all power rails and disable outputs */
-	i2c_smbus_write_byte_data(ioexp_client, P0_OUT, 0xff);
-	i2c_smbus_write_byte_data(ioexp_client, P1_CONFIG, 0xff);
-	i2c_smbus_write_byte_data(ioexp_client, P0_CONFIG, 0xff);
-
-	/* Clear any over-temperature alert */
-	i2c_smbus_read_byte_data(hwmon_client, MAX664X_REG_RSL);
-}
-
-static int sfe4001_poweron(struct efx_nic *efx)
-{
-	struct i2c_client *hwmon_client = efx->board_info.hwmon_client;
-	struct i2c_client *ioexp_client = efx->board_info.ioexp_client;
-	unsigned int i, j;
-	int rc;
-	u8 out;
-
-	/* Clear any previous over-temperature alert */
-	rc = i2c_smbus_read_byte_data(hwmon_client, MAX664X_REG_RSL);
-	if (rc < 0)
-		return rc;
-
-	/* Enable port 0 and port 1 outputs on IO expander */
-	rc = i2c_smbus_write_byte_data(ioexp_client, P0_CONFIG, 0x00);
-	if (rc)
-		return rc;
-	rc = i2c_smbus_write_byte_data(ioexp_client, P1_CONFIG,
-				       0xff & ~(1 << P1_SPARE_LBN));
-	if (rc)
-		goto fail_on;
-
-	/* If PHY power is on, turn it all off and wait 1 second to
-	 * ensure a full reset.
-	 */
-	rc = i2c_smbus_read_byte_data(ioexp_client, P0_OUT);
-	if (rc < 0)
-		goto fail_on;
-	out = 0xff & ~((0 << P0_EN_1V2_LBN) | (0 << P0_EN_2V5_LBN) |
-		       (0 << P0_EN_3V3X_LBN) | (0 << P0_EN_5V_LBN) |
-		       (0 << P0_EN_1V0X_LBN));
-	if (rc != out) {
-		EFX_INFO(efx, "power-cycling PHY\n");
-		rc = i2c_smbus_write_byte_data(ioexp_client, P0_OUT, out);
-		if (rc)
-			goto fail_on;
-		schedule_timeout_uninterruptible(HZ);
-	}
-
-	for (i = 0; i < 20; ++i) {
-		/* Turn on 1.2V, 2.5V, 3.3V and 5V power rails */
-		out = 0xff & ~((1 << P0_EN_1V2_LBN) | (1 << P0_EN_2V5_LBN) |
-			       (1 << P0_EN_3V3X_LBN) | (1 << P0_EN_5V_LBN) |
-			       (1 << P0_X_TRST_LBN));
-		if (efx->phy_mode & PHY_MODE_SPECIAL)
-			out |= 1 << P0_EN_3V3X_LBN;
-
-		rc = i2c_smbus_write_byte_data(ioexp_client, P0_OUT, out);
-		if (rc)
-			goto fail_on;
-		msleep(10);
-
-		/* Turn on 1V power rail */
-		out &= ~(1 << P0_EN_1V0X_LBN);
-		rc = i2c_smbus_write_byte_data(ioexp_client, P0_OUT, out);
-		if (rc)
-			goto fail_on;
-
-		EFX_INFO(efx, "waiting for DSP boot (attempt %d)...\n", i);
-
-		/* In flash config mode, DSP does not turn on AFE, so
-		 * just wait 1 second.
-		 */
-		if (efx->phy_mode & PHY_MODE_SPECIAL) {
-			schedule_timeout_uninterruptible(HZ);
-			return 0;
-		}
-
-		for (j = 0; j < 10; ++j) {
-			msleep(100);
-
-			/* Check DSP has asserted AFE power line */
-			rc = i2c_smbus_read_byte_data(ioexp_client, P1_IN);
-			if (rc < 0)
-				goto fail_on;
-			if (rc & (1 << P1_AFE_PWD_LBN))
-				return 0;
-		}
-	}
-
-	EFX_INFO(efx, "timed out waiting for DSP boot\n");
-	rc = -ETIMEDOUT;
-fail_on:
-	sfe4001_poweroff(efx);
-	return rc;
-}
-
-static int sfn4111t_reset(struct efx_nic *efx)
-{
-	efx_oword_t reg;
-
-	/* GPIO 3 and the GPIO register are shared with I2C, so block that */
-	i2c_lock_adapter(&efx->i2c_adap);
-
-	/* Pull RST_N (GPIO 2) low then let it up again, setting the
-	 * FLASH_CFG_1 strap (GPIO 3) appropriately.  Only change the
-	 * output enables; the output levels should always be 0 (low)
-	 * and we rely on external pull-ups. */
-	falcon_read(efx, &reg, GPIO_CTL_REG_KER);
-	EFX_SET_OWORD_FIELD(reg, GPIO2_OEN, true);
-	falcon_write(efx, &reg, GPIO_CTL_REG_KER);
-	msleep(1000);
-	EFX_SET_OWORD_FIELD(reg, GPIO2_OEN, false);
-	EFX_SET_OWORD_FIELD(reg, GPIO3_OEN,
-			    !!(efx->phy_mode & PHY_MODE_SPECIAL));
-	falcon_write(efx, &reg, GPIO_CTL_REG_KER);
-	msleep(1);
-
-	i2c_unlock_adapter(&efx->i2c_adap);
-
-	ssleep(1);
-	return 0;
-}
-
-static ssize_t show_phy_flash_cfg(struct device *dev,
-				  struct device_attribute *attr, char *buf)
-{
-	struct efx_nic *efx = pci_get_drvdata(to_pci_dev(dev));
-	return sprintf(buf, "%d\n", !!(efx->phy_mode & PHY_MODE_SPECIAL));
-}
-
-static ssize_t set_phy_flash_cfg(struct device *dev,
-				 struct device_attribute *attr,
-				 const char *buf, size_t count)
-{
-	struct efx_nic *efx = pci_get_drvdata(to_pci_dev(dev));
-	enum efx_phy_mode old_mode, new_mode;
-	int err;
-
-	rtnl_lock();
-	old_mode = efx->phy_mode;
-	if (count == 0 || *buf == '0')
-		new_mode = old_mode & ~PHY_MODE_SPECIAL;
-	else
-		new_mode = PHY_MODE_SPECIAL;
-	if (old_mode == new_mode) {
-		err = 0;
-	} else if (efx->state != STATE_RUNNING || netif_running(efx->net_dev)) {
-		err = -EBUSY;
-	} else {
-		/* Reset the PHY, reconfigure the MAC and enable/disable
-		 * MAC stats accordingly. */
-		efx->phy_mode = new_mode;
-		if (new_mode & PHY_MODE_SPECIAL)
-			efx_stats_disable(efx);
-		if (efx->board_info.type == EFX_BOARD_SFE4001)
-			err = sfe4001_poweron(efx);
-		else
-			err = sfn4111t_reset(efx);
-		efx_reconfigure_port(efx);
-		if (!(new_mode & PHY_MODE_SPECIAL))
-			efx_stats_enable(efx);
-	}
-	rtnl_unlock();
-
-	return err ? err : count;
-}
-
-static DEVICE_ATTR(phy_flash_cfg, 0644, show_phy_flash_cfg, set_phy_flash_cfg);
-
-static void sfe4001_fini(struct efx_nic *efx)
-{
-	EFX_INFO(efx, "%s\n", __func__);
-
-	device_remove_file(&efx->pci_dev->dev, &dev_attr_phy_flash_cfg);
-	sfe4001_poweroff(efx);
-	i2c_unregister_device(efx->board_info.ioexp_client);
-	i2c_unregister_device(efx->board_info.hwmon_client);
-}
-
-static int sfe4001_check_hw(struct efx_nic *efx)
-{
-	s32 status;
-
-	/* If XAUI link is up then do not monitor */
-	if (EFX_WORKAROUND_7884(efx) && efx->mac_up)
-		return 0;
-
-	/* Check the powered status of the PHY. Lack of power implies that
-	 * the MAX6647 has shut down power to it, probably due to a temp.
-	 * alarm. Reading the power status rather than the MAX6647 status
-	 * directly because the later is read-to-clear and would thus
-	 * start to power up the PHY again when polled, causing us to blip
-	 * the power undesirably.
-	 * We know we can read from the IO expander because we did
-	 * it during power-on. Assume failure now is bad news. */
-	status = i2c_smbus_read_byte_data(efx->board_info.ioexp_client, P1_IN);
-	if (status >= 0 &&
-	    (status & ((1 << P1_AFE_PWD_LBN) | (1 << P1_DSP_PWD25_LBN))) != 0)
-		return 0;
-
-	/* Use board power control, not PHY power control */
-	sfe4001_poweroff(efx);
-	efx->phy_mode = PHY_MODE_OFF;
-
-	return (status < 0) ? -EIO : -ERANGE;
-}
-
-static struct i2c_board_info sfe4001_hwmon_info = {
-	I2C_BOARD_INFO("max6647", 0x4e),
-};
-
-/* This board uses an I2C expander to provider power to the PHY, which needs to
- * be turned on before the PHY can be used.
- * Context: Process context, rtnl lock held
- */
-int sfe4001_init(struct efx_nic *efx)
-{
-	int rc;
-
-#if defined(CONFIG_SENSORS_LM90) || defined(CONFIG_SENSORS_LM90_MODULE)
-	efx->board_info.hwmon_client =
-		i2c_new_device(&efx->i2c_adap, &sfe4001_hwmon_info);
-#else
-	efx->board_info.hwmon_client =
-		i2c_new_dummy(&efx->i2c_adap, sfe4001_hwmon_info.addr);
-#endif
-	if (!efx->board_info.hwmon_client)
-		return -EIO;
-
-	/* Raise board/PHY high limit from 85 to 90 degrees Celsius */
-	rc = i2c_smbus_write_byte_data(efx->board_info.hwmon_client,
-				       MAX664X_REG_WLHO, 90);
-	if (rc)
-		goto fail_hwmon;
-
-	efx->board_info.ioexp_client = i2c_new_dummy(&efx->i2c_adap, PCA9539);
-	if (!efx->board_info.ioexp_client) {
-		rc = -EIO;
-		goto fail_hwmon;
-	}
-
-	/* 10Xpress has fixed-function LED pins, so there is no board-specific
-	 * blink code. */
-	efx->board_info.blink = tenxpress_phy_blink;
-
-	efx->board_info.monitor = sfe4001_check_hw;
-	efx->board_info.fini = sfe4001_fini;
-
-	if (efx->phy_mode & PHY_MODE_SPECIAL) {
-		/* PHY won't generate a 156.25 MHz clock and MAC stats fetch
-		 * will fail. */
-		efx_stats_disable(efx);
-	}
-	rc = sfe4001_poweron(efx);
-	if (rc)
-		goto fail_ioexp;
-
-	rc = device_create_file(&efx->pci_dev->dev, &dev_attr_phy_flash_cfg);
-	if (rc)
-		goto fail_on;
-
-	EFX_INFO(efx, "PHY is powered on\n");
-	return 0;
-
-fail_on:
-	sfe4001_poweroff(efx);
-fail_ioexp:
-	i2c_unregister_device(efx->board_info.ioexp_client);
-fail_hwmon:
-	i2c_unregister_device(efx->board_info.hwmon_client);
-	return rc;
-}
-
-static int sfn4111t_check_hw(struct efx_nic *efx)
-{
-	s32 status;
-
-	/* If XAUI link is up then do not monitor */
-	if (EFX_WORKAROUND_7884(efx) && efx->mac_up)
-		return 0;
-
-	/* Test LHIGH, RHIGH, FAULT, EOT and IOT alarms */
-	status = i2c_smbus_read_byte_data(efx->board_info.hwmon_client,
-					  MAX664X_REG_RSL);
-	if (status < 0)
-		return -EIO;
-	if (status & 0x57)
-		return -ERANGE;
-	return 0;
-}
-
-static void sfn4111t_fini(struct efx_nic *efx)
-{
-	EFX_INFO(efx, "%s\n", __func__);
-
-	device_remove_file(&efx->pci_dev->dev, &dev_attr_phy_flash_cfg);
-	i2c_unregister_device(efx->board_info.hwmon_client);
-}
-
-static struct i2c_board_info sfn4111t_a0_hwmon_info = {
-	I2C_BOARD_INFO("max6647", 0x4e),
-};
-
-static struct i2c_board_info sfn4111t_r5_hwmon_info = {
-	I2C_BOARD_INFO("max6646", 0x4d),
-};
-
-int sfn4111t_init(struct efx_nic *efx)
-{
-	int i = 0;
-	int rc;
-
-	efx->board_info.hwmon_client =
-		i2c_new_device(&efx->i2c_adap,
-			       (efx->board_info.minor < 5) ?
-			       &sfn4111t_a0_hwmon_info :
-			       &sfn4111t_r5_hwmon_info);
-	if (!efx->board_info.hwmon_client)
-		return -EIO;
-
-	efx->board_info.blink = tenxpress_phy_blink;
-	efx->board_info.monitor = sfn4111t_check_hw;
-	efx->board_info.fini = sfn4111t_fini;
-
-	rc = device_create_file(&efx->pci_dev->dev, &dev_attr_phy_flash_cfg);
-	if (rc)
-		goto fail_hwmon;
-
-	do {
-		if (efx->phy_mode & PHY_MODE_SPECIAL) {
-			/* PHY may not generate a 156.25 MHz clock and MAC
-			 * stats fetch will fail. */
-			efx_stats_disable(efx);
-			sfn4111t_reset(efx);
-		}
-		rc = sft9001_wait_boot(efx);
-		if (rc == 0)
-			return 0;
-		efx->phy_mode = PHY_MODE_SPECIAL;
-	} while (rc == -EINVAL && ++i < 2);
-
-	device_remove_file(&efx->pci_dev->dev, &dev_attr_phy_flash_cfg);
-fail_hwmon:
-	i2c_unregister_device(efx->board_info.hwmon_client);
-	return rc;
-}
diff -r 9566a4a50a43 drivers/net/sfc/siena.c
--- /dev/null
+++ b/drivers/net/sfc/siena.c
@@ -0,0 +1,876 @@
+/****************************************************************************
+ * Driver for Solarflare Solarstorm network controllers and boards
+ * Copyright 2005-2006 Fen Systems Ltd.
+ * Copyright 2006-2010 Solarflare Communications Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 as published
+ * by the Free Software Foundation, incorporated herein by reference.
+ */
+
+#include <linux/bitops.h>
+#include <linux/delay.h>
+#include <linux/pci.h>
+#include <linux/module.h>
+#include <linux/slab.h>
+#include <linux/random.h>
+#include "net_driver.h"
+#include "bitfield.h"
+#include "efx.h"
+#include "nic.h"
+#include "spi.h"
+#include "regs.h"
+#include "io.h"
+#include "phy.h"
+#include "workarounds.h"
+#include "mcdi.h"
+#include "mcdi_pcol.h"
+
+/* Hardware control for SFC9000 family including SFL9021 (aka Siena). */
+
+static inline bool MARANELLO_ENABLED(struct efx_nic *efx) {
+	return (efx->caps & (1 << MC_CMD_CAPABILITIES_TURBO_ACTIVE_LBN));
+}
+
+static inline bool MARANELLO_POSSIBLE(struct efx_nic *efx) {
+	return (efx->caps & (1 << MC_CMD_CAPABILITIES_TURBO_LBN));
+}
+
+
+static void siena_init_wol(struct efx_nic *efx);
+
+
+static void siena_push_irq_moderation(struct efx_channel *channel)
+{
+	efx_dword_t timer_cmd;
+
+	if (channel->irq_moderation)
+		EFX_POPULATE_DWORD_2(timer_cmd,
+				     FRF_CZ_TC_TIMER_MODE,
+				     FFE_CZ_TIMER_MODE_INT_HLDOFF,
+				     FRF_CZ_TC_TIMER_VAL,
+				     channel->irq_moderation - 1);
+	else
+		EFX_POPULATE_DWORD_2(timer_cmd,
+				     FRF_CZ_TC_TIMER_MODE,
+				     FFE_CZ_TIMER_MODE_DIS,
+				     FRF_CZ_TC_TIMER_VAL, 0);
+	efx_writed_page_locked(channel->efx, &timer_cmd, FR_BZ_TIMER_COMMAND_P0,
+			       channel->channel);
+}
+
+static int siena_mdio_write(struct net_device *net_dev,
+			    int prtad, int devad, u16 addr, u16 value)
+{
+	struct efx_nic *efx = netdev_priv(net_dev);
+	uint32_t status;
+	int rc;
+
+	rc = efx_mcdi_mdio_write(efx, efx->mdio_bus, prtad, devad,
+				 addr, value, &status);
+	if (rc)
+		return rc;
+	if (status != MC_CMD_MDIO_STATUS_GOOD)
+		return -EIO;
+
+	return 0;
+}
+
+static int siena_mdio_read(struct net_device *net_dev,
+			   int prtad, int devad, u16 addr)
+{
+	struct efx_nic *efx = netdev_priv(net_dev);
+	uint16_t value;
+	uint32_t status;
+	int rc;
+
+	rc = efx_mcdi_mdio_read(efx, efx->mdio_bus, prtad, devad,
+				addr, &value, &status);
+	if (rc)
+		return rc;
+	if (status != MC_CMD_MDIO_STATUS_GOOD)
+		return -EIO;
+
+	return (int)value;
+}
+
+/* This call is responsible for hooking in the MAC and PHY operations */
+static int siena_probe_port(struct efx_nic *efx)
+{
+	int rc;
+
+	/* Hook in PHY operations table */
+	efx->phy_op = &efx_mcdi_phy_ops;
+
+	/* Set up MDIO structure for PHY */
+	efx->mdio.mode_support = MDIO_SUPPORTS_C45 | MDIO_EMULATE_C22;
+	efx->mdio.mdio_read = siena_mdio_read;
+	efx->mdio.mdio_write = siena_mdio_write;
+
+	/* Fill out MDIO structure, loopback modes, and initial link state */
+	rc = efx->phy_op->probe(efx);
+	if (rc != 0)
+		return rc;
+
+	/* Allocate buffer for stats */
+	rc = efx_nic_alloc_buffer(efx, &efx->stats_buffer,
+				  MC_CMD_MAC_NSTATS * sizeof(u64));
+	if (rc)
+		return rc;
+	netif_dbg(efx, probe, efx->net_dev,
+		  "stats buffer at %llx (virt %p phys %llx)\n",
+		  (u64)efx->stats_buffer.dma_addr,
+		  efx->stats_buffer.addr,
+		  (u64)virt_to_phys(efx->stats_buffer.addr));
+
+	efx_mcdi_mac_stats(efx, efx->stats_buffer.dma_addr, 0, 0, 1);
+
+	return 0;
+}
+
+static void siena_remove_port(struct efx_nic *efx)
+{
+	efx->phy_op->remove(efx);
+	efx_nic_free_buffer(efx, &efx->stats_buffer);
+}
+
+static int siena_test_sram(struct efx_nic *efx,
+			   void (*pattern)(unsigned, efx_qword_t *, int, int),
+			   int a, int b)
+{
+	void __iomem *membase = efx->membase + FR_BZ_BUF_FULL_TBL;
+	int finish = efx->sram_lim / 8;
+	efx_qword_t buf1, buf2;
+	efx_oword_t reg;
+	int wptr = 0, rptr = 0;
+
+	/* Move descriptor caches out into space so we can treat all
+	 * SRAM as buffer table.  These registers will be restored by
+	 * a following reset. */
+	EFX_POPULATE_OWORD_1(reg, FRF_AZ_SRM_RX_DC_BASE_ADR, finish);
+	efx_writeo(efx, &reg, FR_AZ_SRM_RX_DC_CFG);
+	EFX_POPULATE_OWORD_1(reg, FRF_AZ_SRM_TX_DC_BASE_ADR, finish + 64);
+	efx_writeo(efx, &reg, FR_AZ_SRM_TX_DC_CFG);
+
+	while (wptr < finish) {
+		pattern(wptr, &buf1, a, b);
+		efx_sram_writeq(efx, membase, &buf1, wptr);
+		wptr++;
+
+		/* Buffer table writes are not performed synchronously
+		 * but go through a 128-entry FIFO, so we must switch
+		 * from writing to reading after at most 128 writes.
+		 * We choose 125 to make the following calculation
+		 * result in a round number. */
+		if ((wptr - rptr) < 125 && wptr < finish)
+			continue;
+
+		/* The SRAM arbiter will allow 2 writes per 8 cycles
+		 * with a cycle time of 8 ns.  Each MMIO access takes
+		 * at least one cycle.  So in order to avoid reads
+		 * overtaking writes we must wait for at least
+		 * 125 * (8 / 2 - 2) * 8 ns = 2 us */
+		udelay(2);
+
+		for (; rptr < wptr; ++rptr) {
+			pattern(rptr, &buf1, a, b);
+			efx_sram_readq(efx, membase, &buf2, rptr);
+
+			if (!memcmp(&buf1, &buf2, sizeof(buf1)))
+				continue;
+
+			netif_err(efx, hw, efx->net_dev,
+				  "sram test failed at index 0x%x. wrote "
+				  EFX_QWORD_FMT" read "EFX_QWORD_FMT"\n",
+				  rptr, EFX_QWORD_VAL(buf1),
+				  EFX_QWORD_VAL(buf2));
+			return -EIO;
+		}
+	}
+
+	return 0;
+}
+
+static const struct efx_nic_register_test siena_register_tests[] = {
+	{ FR_AZ_ADR_REGION,
+	  EFX_OWORD32(0x0003FFFF, 0x0003FFFF, 0x0003FFFF, 0x0003FFFF) },
+	{ FR_CZ_USR_EV_CFG,
+	  EFX_OWORD32(0x000103FF, 0x00000000, 0x00000000, 0x00000000) },
+	{ FR_AZ_RX_CFG,
+	  EFX_OWORD32(0xFFFFFFFE, 0xFFFFFFFF, 0x0003FFFF, 0x00000000) },
+	{ FR_AZ_TX_CFG,
+	  EFX_OWORD32(0x7FFF0037, 0xFFFF8000, 0xFFFFFFFF, 0x03FFFFFF) },
+	{ FR_AZ_TX_RESERVED,
+	  EFX_OWORD32(0xFFFEFE80, 0x1FFFFFFF, 0x020000FE, 0x007FFFFF) },
+	{ FR_AZ_SRM_TX_DC_CFG,
+	  EFX_OWORD32(0x001FFFFF, 0x00000000, 0x00000000, 0x00000000) },
+	{ FR_AZ_RX_DC_CFG,
+	  EFX_OWORD32(0x00000003, 0x00000000, 0x00000000, 0x00000000) },
+	{ FR_AZ_RX_DC_PF_WM,
+	  EFX_OWORD32(0x000003FF, 0x00000000, 0x00000000, 0x00000000) },
+	{ FR_BZ_DP_CTRL,
+	  EFX_OWORD32(0x00000FFF, 0x00000000, 0x00000000, 0x00000000) },
+	{ FR_BZ_RX_RSS_TKEY,
+	  EFX_OWORD32(0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF) },
+	{ FR_CZ_RX_RSS_IPV6_REG1,
+	  EFX_OWORD32(0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF) },
+	{ FR_CZ_RX_RSS_IPV6_REG2,
+	  EFX_OWORD32(0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF) },
+	{ FR_CZ_RX_RSS_IPV6_REG3,
+	  EFX_OWORD32(0xFFFFFFFF, 0xFFFFFFFF, 0x00000007, 0x00000000) },
+};
+
+static const struct efx_nic_table_test siena_table_tests[] = {
+	{ FR_BZ_RX_FILTER_TBL0,
+	  FR_BZ_RX_FILTER_TBL0_STEP, FR_BZ_RX_FILTER_TBL0_ROWS,
+	  EFX_OWORD32(0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0x000003FF) },
+	{ FR_CZ_RX_MAC_FILTER_TBL0,
+	  FR_CZ_RX_MAC_FILTER_TBL0_STEP, FR_CZ_RX_MAC_FILTER_TBL0_ROWS,
+	  EFX_OWORD32(0xFFFF0FFF, 0xFFFFFFFF, 0x00000E7F, 0x00000000) },
+	{ FR_BZ_RX_DESC_PTR_TBL,
+	  FR_BZ_RX_DESC_PTR_TBL_STEP, FR_CZ_RX_DESC_PTR_TBL_ROWS,
+	  EFX_OWORD32(0xFFFFFFFF, 0x0FFFFFFF, 0x01800000, 0x00000000) },
+	{ FR_BZ_TX_DESC_PTR_TBL,
+	  FR_BZ_TX_DESC_PTR_TBL_STEP, FR_CZ_TX_DESC_PTR_TBL_ROWS,
+	  EFX_OWORD32(0xFFFFFFFE, 0x0FFFFFFF, 0x0C000000, 0x00000000) },
+	{ FR_BZ_TIMER_TBL,
+	  FR_BZ_TIMER_TBL_STEP, FR_CZ_TIMER_TBL_ROWS,
+	  EFX_OWORD32(0x3FFFFFFF, 0x00000000, 0x00000000, 0x00000000) },
+	{ FR_CZ_TX_FILTER_TBL0,
+	  FR_CZ_TX_FILTER_TBL0_STEP, FR_CZ_TX_FILTER_TBL0_ROWS,
+	  EFX_OWORD32(0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0x000013FF) },
+	{ FR_CZ_TX_MAC_FILTER_TBL0,
+	  FR_CZ_TX_MAC_FILTER_TBL0_STEP, FR_CZ_TX_MAC_FILTER_TBL0_ROWS,
+	  EFX_OWORD32(0xFFFF07FF, 0xFFFFFFFF, 0x0000007F, 0x00000000) },
+};
+
+static int siena_test_registers(struct efx_nic *efx)
+{
+	return efx_nic_test_registers(efx, siena_register_tests,
+				      ARRAY_SIZE(siena_register_tests));
+}
+
+static int
+siena_test_tables(struct efx_nic *efx,
+		  void (*pattern)(unsigned, efx_qword_t *, int, int),
+		  int a, int b)
+{
+	int rc, i;
+
+	rc = siena_test_sram(efx, pattern, a, b);
+	if (rc)
+		return rc;
+
+	for (i = 0; i < ARRAY_SIZE(siena_table_tests); i++) {
+		rc = efx_nic_test_table(efx, &siena_table_tests[i],
+					pattern, a, b);
+		if (rc)
+			return rc;
+	}
+
+	return 0;
+}
+
+/**************************************************************************
+ *
+ * Device reset
+ *
+ **************************************************************************
+ */
+
+static enum reset_type siena_map_reset_reason(enum reset_type reason)
+{
+	return RESET_TYPE_ALL;
+}
+
+static int siena_map_reset_flags(u32 *flags)
+{
+	enum {
+		SIENA_RESET_PORT = (ETH_RESET_DMA | ETH_RESET_FILTER |
+				    ETH_RESET_OFFLOAD | ETH_RESET_MAC |
+				    ETH_RESET_PHY),
+		SIENA_RESET_MC = (SIENA_RESET_PORT |
+				  ETH_RESET_MGMT << ETH_RESET_SHARED_SHIFT),
+	};
+
+	if ((*flags & SIENA_RESET_MC) == SIENA_RESET_MC) {
+		*flags &= ~SIENA_RESET_MC;
+		return RESET_TYPE_WORLD;
+	}
+
+	if ((*flags & SIENA_RESET_PORT) == SIENA_RESET_PORT) {
+		*flags &= ~SIENA_RESET_PORT;
+		return RESET_TYPE_ALL;
+	}
+
+	/* no invisible reset implemented */
+
+	return -EINVAL;
+}
+
+static int siena_reset_hw(struct efx_nic *efx, enum reset_type method)
+{
+	int rc;
+
+	/* Recover from a failed assertion pre-reset */
+	rc = efx_mcdi_handle_assertion(efx);
+	if (rc)
+		return rc;
+
+	if (method == RESET_TYPE_WORLD)
+		return efx_mcdi_reset_mc(efx);
+	else
+		return efx_mcdi_reset_port(efx);
+}
+
+static int siena_probe_nvconfig(struct efx_nic *efx)
+{
+	u32 caps = 0;
+	int rc;
+
+	rc = efx_mcdi_get_board_cfg(efx, efx->net_dev->perm_addr, NULL, &caps);
+
+	efx->timer_quantum_ns = MARANELLO_ENABLED(efx) ?
+		3072 : 6144; /* 768 cycles */
+
+	efx->caps = caps;
+
+	return rc;
+}
+
+static int siena_dimension_resources(struct efx_nic *efx)
+{
+	/* There is a small block of internal SRAM dedicated to the
+	 * buffer table and descriptor caches. */
+	size_t sram_size = 72 * 1024 * 64 / 8;
+	struct efx_dl_falcon_resources *res = &efx->resources;
+	u8 outbuf[MC_CMD_GET_RESOURCE_LIMITS_OUT_LEN];
+	size_t outlen;
+	int rc;
+
+	BUILD_BUG_ON(MC_CMD_GET_RESOURCE_LIMITS_IN_LEN != 0);
+
+	rc = efx_mcdi_rpc(efx, MC_CMD_GET_RESOURCE_LIMITS, NULL, 0,
+			  outbuf, sizeof(outbuf), &outlen);
+	if (rc == -ENOSYS) {
+		res->buffer_table_lim = sram_size / 8;
+	} else if (rc) {
+		return rc;
+	} else {
+		res->buffer_table_lim =
+			MCDI_DWORD(outbuf, GET_RESOURCE_LIMITS_OUT_BUFTBL);
+		res->rxq_lim = MCDI_DWORD(outbuf, GET_RESOURCE_LIMITS_OUT_RXQ);
+		res->txq_lim = MCDI_DWORD(outbuf, GET_RESOURCE_LIMITS_OUT_TXQ);
+		res->evq_timer_lim =
+			MCDI_DWORD(outbuf, GET_RESOURCE_LIMITS_OUT_EVQ);
+		if (res->buffer_table_lim < sram_size / 8) {
+			efx->resources.flags |=
+				EFX_DL_FALCON_ONLOAD_UNSUPPORTED;
+		}
+	}
+
+	res->flags |= EFX_DL_FALCON_HAVE_TIMER_QUANTUM_NS;
+	res->timer_quantum_ns = efx->timer_quantum_ns; /* same as IRQ timers */
+
+	rc = efx_nic_dimension_resources(efx, sram_size);
+	if (rc)
+		return rc;
+
+	if (efx->vf_count) {
+		/* Advertise SR-IOV through driverlink */
+		efx->sriov_resources.hdr.type = EFX_DL_SIENA_SRIOV;
+		efx->sriov_resources.vi_base = EFX_VI_BASE;
+		efx->sriov_resources.vi_scale = efx->vi_scale;
+		efx->sriov_resources.vf_count = efx->vf_count;
+		efx->sriov_resources.hdr.next = efx->resources.hdr.next;
+		efx->resources.hdr.next = &efx->sriov_resources.hdr;
+	}
+
+	return 0;
+}
+
+static ssize_t siena_show_turbo(struct device *dev,
+		struct device_attribute *attr,
+		char *buff)
+{
+#define ENABLED         "Enabled\n"
+#define DISABLED        "Disabled\n"
+	struct efx_nic *efx = pci_get_drvdata(to_pci_dev(dev));
+
+	if (MARANELLO_ENABLED(efx))
+		return snprintf(buff, sizeof(ENABLED), "%s", ENABLED);
+	else
+		return snprintf(buff, sizeof(DISABLED), "%s", DISABLED);
+}
+
+static DEVICE_ATTR(turbo_mode, S_IRUGO, siena_show_turbo, NULL);
+
+static int siena_probe_nic(struct efx_nic *efx)
+{
+	struct siena_nic_data *nic_data;
+	bool already_attached = 0;
+	efx_oword_t reg;
+	int rc;
+
+	/* Allocate storage for hardware specific data */
+	nic_data = kzalloc(sizeof(struct siena_nic_data), GFP_KERNEL);
+	if (!nic_data)
+		return -ENOMEM;
+	efx->nic_data = nic_data;
+
+	if (efx_nic_fpga_ver(efx) != 0) {
+		netif_err(efx, probe, efx->net_dev,
+			  "Siena FPGA not supported\n");
+		rc = -ENODEV;
+		goto fail1;
+	}
+
+	efx_reado(efx, &reg, FR_AZ_CS_DEBUG);
+	efx->net_dev->dev_id = EFX_OWORD_FIELD(reg, FRF_CZ_CS_PORT_NUM) - 1;
+
+	efx_mcdi_init(efx);
+
+	/* Recover from a failed assertion before probing */
+	rc = efx_mcdi_handle_assertion(efx);
+	if (rc)
+		goto fail1;
+
+	/* Let the BMC know that the driver is now in charge of link and
+	 * filter settings. We must do this before we reset the NIC */
+	rc = efx_mcdi_drv_attach(efx, true, &already_attached);
+	if (rc) {
+		netif_err(efx, probe, efx->net_dev,
+			  "Unable to register driver with MCPU\n");
+		goto fail2;
+	}
+	if (already_attached)
+		/* Not a fatal error */
+		netif_err(efx, probe, efx->net_dev,
+			  "Host already registered with MCPU\n");
+
+	/* Now we can reset the NIC */
+	rc = siena_reset_hw(efx, RESET_TYPE_ALL);
+	if (rc) {
+		netif_err(efx, probe, efx->net_dev, "failed to reset NIC\n");
+		goto fail3;
+	}
+
+	siena_init_wol(efx);
+
+	/* Allocate memory for INT_KER */
+	rc = efx_nic_alloc_buffer(efx, &efx->irq_status, sizeof(efx_oword_t));
+	if (rc)
+		goto fail4;
+	BUG_ON(efx->irq_status.dma_addr & 0x0f);
+
+	netif_dbg(efx, probe, efx->net_dev,
+		  "INT_KER at %llx (virt %p phys %llx)\n",
+		  (unsigned long long)efx->irq_status.dma_addr,
+		  efx->irq_status.addr,
+		  (unsigned long long)virt_to_phys(efx->irq_status.addr));
+
+	/* Read in the non-volatile configuration */
+	rc = siena_probe_nvconfig(efx);
+	if (rc == -EINVAL) {
+		netif_err(efx, probe, efx->net_dev,
+			  "NVRAM is invalid therefore using defaults\n");
+		efx->phy_type = PHY_TYPE_NONE;
+		efx->mdio.prtad = MDIO_PRTAD_NONE;
+	} else if (rc) {
+		goto fail5;
+	}
+
+	efx_sriov_probe(efx);
+	efx_ptp_probe(efx);
+
+	return 0;
+
+fail5:
+	efx_nic_free_buffer(efx, &efx->irq_status);
+fail4:
+fail3:
+	efx_mcdi_drv_attach(efx, false, NULL);
+fail2:
+fail1:
+	kfree(efx->nic_data);
+	return rc;
+}
+
+/* This call performs hardware-specific global initialisation, such as
+ * defining the descriptor cache sizes and number of RSS channels.
+ * It does not set up any buffers, descriptor rings or event queues.
+ */
+static int siena_init_nic(struct efx_nic *efx)
+{
+	efx_oword_t temp;
+	int rc;
+
+	/* Recover from a failed assertion post-reset */
+	rc = efx_mcdi_handle_assertion(efx);
+	if (rc)
+		return rc;
+
+	efx_nic_check_pcie_link(efx, 8, 2);
+
+	/* Do not enable TX_NO_EOP_DISC_EN, since it limits packets to 16
+	 * descriptors (which is bad).
+	 */
+	efx_reado(efx, &temp, FR_AZ_TX_CFG);
+	EFX_SET_OWORD_FIELD(temp, FRF_AZ_TX_NO_EOP_DISC_EN, 0);
+	EFX_SET_OWORD_FIELD(temp, FRF_CZ_TX_FILTER_EN_BIT, 1);
+	efx_writeo(efx, &temp, FR_AZ_TX_CFG);
+
+	efx_reado(efx, &temp, FR_AZ_RX_CFG);
+	EFX_SET_OWORD_FIELD(temp, FRF_BZ_RX_DESC_PUSH_EN, 0);
+	EFX_SET_OWORD_FIELD(temp, FRF_BZ_RX_INGR_EN, 1);
+	/* Enable hash insertion. This is broken for the 'Falcon' hash
+	 * if IPv6 hashing is also enabled, so also select Toeplitz
+	 * TCP/IPv4 and IPv4 hashes. */
+	EFX_SET_OWORD_FIELD(temp, FRF_BZ_RX_HASH_INSRT_HDR, 1);
+	EFX_SET_OWORD_FIELD(temp, FRF_BZ_RX_HASH_ALG, 1);
+	EFX_SET_OWORD_FIELD(temp, FRF_BZ_RX_IP_HASH, 1);
+	efx_writeo(efx, &temp, FR_AZ_RX_CFG);
+
+	/* Set hash key for IPv4 */
+	memcpy(&temp, efx->rx_hash_key, sizeof(temp));
+	efx_writeo(efx, &temp, FR_BZ_RX_RSS_TKEY);
+
+	/* Enable IPv6 RSS */
+	BUILD_BUG_ON(sizeof(efx->rx_hash_key) <
+		     2 * sizeof(temp) + FRF_CZ_RX_RSS_IPV6_TKEY_HI_WIDTH / 8 ||
+		     FRF_CZ_RX_RSS_IPV6_TKEY_HI_LBN != 0);
+	memcpy(&temp, efx->rx_hash_key, sizeof(temp));
+	efx_writeo(efx, &temp, FR_CZ_RX_RSS_IPV6_REG1);
+	memcpy(&temp, efx->rx_hash_key + sizeof(temp), sizeof(temp));
+	efx_writeo(efx, &temp, FR_CZ_RX_RSS_IPV6_REG2);
+	EFX_POPULATE_OWORD_2(temp, FRF_CZ_RX_RSS_IPV6_THASH_ENABLE, 1,
+			     FRF_CZ_RX_RSS_IPV6_IP_THASH_ENABLE, 1);
+	memcpy(&temp, efx->rx_hash_key + 2 * sizeof(temp),
+	       FRF_CZ_RX_RSS_IPV6_TKEY_HI_WIDTH / 8);
+	efx_writeo(efx, &temp, FR_CZ_RX_RSS_IPV6_REG3);
+
+	/* Enable event logging */
+	rc = efx_mcdi_log_ctrl(efx, true, false, 0);
+	if (rc)
+		return rc;
+
+	/* Set destination of both TX and RX Flush events */
+	EFX_POPULATE_OWORD_1(temp, FRF_BZ_FLS_EVQ_ID, 0);
+	efx_writeo(efx, &temp, FR_BZ_DP_CTRL);
+
+	EFX_POPULATE_OWORD_1(temp, FRF_CZ_USREV_DIS, 1);
+	efx_writeo(efx, &temp, FR_CZ_USR_EV_CFG);
+
+	efx_nic_init_common(efx);
+	return 0;
+}
+
+static void siena_remove_nic(struct efx_nic *efx)
+{
+	efx_nic_free_buffer(efx, &efx->irq_status);
+
+	siena_reset_hw(efx, RESET_TYPE_ALL);
+
+	if (MARANELLO_POSSIBLE(efx))
+		device_remove_file(&efx->pci_dev->dev,
+				&dev_attr_turbo_mode);
+
+	/* Relinquish the device back to the BMC */
+	efx_mcdi_drv_attach(efx, false, NULL);
+
+	/* Tear down the private nic state, and the driverlink nic params */
+	kfree(efx->nic_data);
+	efx->nic_data = NULL;
+}
+
+#define STATS_GENERATION_INVALID ((__le64)(-1))
+
+static int siena_try_update_nic_stats(struct efx_nic *efx)
+{
+	__le64 *dma_stats;
+	struct efx_mac_stats *mac_stats;
+	__le64 generation_start, generation_end;
+	u64 stat_val;
+
+	mac_stats = &efx->mac_stats;
+	dma_stats = (__force __le64 *)efx->stats_buffer.addr;
+
+	generation_end = dma_stats[MC_CMD_MAC_GENERATION_END];
+	if (generation_end == STATS_GENERATION_INVALID)
+		return 0;
+	rmb();
+
+#define MAC_STAT(M, D) \
+	mac_stats->M = le64_to_cpu(dma_stats[MC_CMD_MAC_ ## D])
+
+	MAC_STAT(tx_bytes, TX_BYTES);
+	MAC_STAT(tx_bad_bytes, TX_BAD_BYTES);
+	mac_stats->tx_good_bytes = (mac_stats->tx_bytes -
+				    mac_stats->tx_bad_bytes);
+	MAC_STAT(tx_packets, TX_PKTS);
+	MAC_STAT(tx_bad, TX_BAD_FCS_PKTS);
+	MAC_STAT(tx_pause, TX_PAUSE_PKTS);
+	MAC_STAT(tx_control, TX_CONTROL_PKTS);
+	MAC_STAT(tx_unicast, TX_UNICAST_PKTS);
+	MAC_STAT(tx_multicast, TX_MULTICAST_PKTS);
+	MAC_STAT(tx_broadcast, TX_BROADCAST_PKTS);
+	MAC_STAT(tx_lt64, TX_LT64_PKTS);
+	MAC_STAT(tx_64, TX_64_PKTS);
+	MAC_STAT(tx_65_to_127, TX_65_TO_127_PKTS);
+	MAC_STAT(tx_128_to_255, TX_128_TO_255_PKTS);
+	MAC_STAT(tx_256_to_511, TX_256_TO_511_PKTS);
+	MAC_STAT(tx_512_to_1023, TX_512_TO_1023_PKTS);
+	MAC_STAT(tx_1024_to_15xx, TX_1024_TO_15XX_PKTS);
+	MAC_STAT(tx_15xx_to_jumbo, TX_15XX_TO_JUMBO_PKTS);
+	MAC_STAT(tx_gtjumbo, TX_GTJUMBO_PKTS);
+	mac_stats->tx_collision = 0;
+	MAC_STAT(tx_single_collision, TX_SINGLE_COLLISION_PKTS);
+	MAC_STAT(tx_multiple_collision, TX_MULTIPLE_COLLISION_PKTS);
+	MAC_STAT(tx_excessive_collision, TX_EXCESSIVE_COLLISION_PKTS);
+	MAC_STAT(tx_deferred, TX_DEFERRED_PKTS);
+	MAC_STAT(tx_late_collision, TX_LATE_COLLISION_PKTS);
+	mac_stats->tx_collision = (mac_stats->tx_single_collision +
+				   mac_stats->tx_multiple_collision +
+				   mac_stats->tx_excessive_collision +
+				   mac_stats->tx_late_collision);
+	MAC_STAT(tx_excessive_deferred, TX_EXCESSIVE_DEFERRED_PKTS);
+	MAC_STAT(tx_non_tcpudp, TX_NON_TCPUDP_PKTS);
+	MAC_STAT(tx_mac_src_error, TX_MAC_SRC_ERR_PKTS);
+	MAC_STAT(tx_ip_src_error, TX_IP_SRC_ERR_PKTS);
+	MAC_STAT(rx_bytes, RX_BYTES);
+	MAC_STAT(rx_bad_bytes, RX_BAD_BYTES);
+	mac_stats->rx_good_bytes = (mac_stats->rx_bytes -
+				    mac_stats->rx_bad_bytes);
+	MAC_STAT(rx_packets, RX_PKTS);
+	MAC_STAT(rx_good, RX_GOOD_PKTS);
+	MAC_STAT(rx_bad, RX_BAD_FCS_PKTS);
+	MAC_STAT(rx_pause, RX_PAUSE_PKTS);
+	MAC_STAT(rx_control, RX_CONTROL_PKTS);
+	MAC_STAT(rx_unicast, RX_UNICAST_PKTS);
+	MAC_STAT(rx_multicast, RX_MULTICAST_PKTS);
+	MAC_STAT(rx_broadcast, RX_BROADCAST_PKTS);
+	MAC_STAT(rx_lt64, RX_UNDERSIZE_PKTS);
+	MAC_STAT(rx_64, RX_64_PKTS);
+	MAC_STAT(rx_65_to_127, RX_65_TO_127_PKTS);
+	MAC_STAT(rx_128_to_255, RX_128_TO_255_PKTS);
+	MAC_STAT(rx_256_to_511, RX_256_TO_511_PKTS);
+	MAC_STAT(rx_512_to_1023, RX_512_TO_1023_PKTS);
+	MAC_STAT(rx_1024_to_15xx, RX_1024_TO_15XX_PKTS);
+	MAC_STAT(rx_15xx_to_jumbo, RX_15XX_TO_JUMBO_PKTS);
+	MAC_STAT(rx_gtjumbo, RX_GTJUMBO_PKTS);
+	mac_stats->rx_bad_lt64 = 0;
+	mac_stats->rx_bad_64_to_15xx = 0;
+	mac_stats->rx_bad_15xx_to_jumbo = 0;
+	MAC_STAT(rx_bad_gtjumbo, RX_JABBER_PKTS);
+	MAC_STAT(rx_overflow, RX_OVERFLOW_PKTS);
+	mac_stats->rx_missed = 0;
+	MAC_STAT(rx_false_carrier, RX_FALSE_CARRIER_PKTS);
+	MAC_STAT(rx_symbol_error, RX_SYMBOL_ERROR_PKTS);
+	MAC_STAT(rx_align_error, RX_ALIGN_ERROR_PKTS);
+	MAC_STAT(rx_length_error, RX_LENGTH_ERROR_PKTS);
+	MAC_STAT(rx_internal_error, RX_INTERNAL_ERROR_PKTS);
+	mac_stats->rx_good_lt64 = 0;
+
+	efx->n_rx_nodesc_drop_cnt =
+		le64_to_cpu(dma_stats[MC_CMD_MAC_RX_NODESC_DROPS]);
+
+	stat_val = le64_to_cpu(dma_stats[MC_CMD_MAC_RX_LANES01_CHAR_ERR]);
+	mac_stats->rx_char_error_lane0 = (stat_val >>  0) & 0xffffffff;
+	mac_stats->rx_char_error_lane1 = (stat_val >> 32) & 0xffffffff;
+	stat_val = le64_to_cpu(dma_stats[MC_CMD_MAC_RX_LANES23_CHAR_ERR]);
+	mac_stats->rx_char_error_lane2 = (stat_val >>  0) & 0xffffffff;
+	mac_stats->rx_char_error_lane3 = (stat_val >> 32) & 0xffffffff;
+	stat_val = le64_to_cpu(dma_stats[MC_CMD_MAC_RX_LANES01_DISP_ERR]);
+	mac_stats->rx_disp_error_lane0 = (stat_val >>  0) & 0xffffffff;
+	mac_stats->rx_disp_error_lane1 = (stat_val >> 32) & 0xffffffff;
+	stat_val = le64_to_cpu(dma_stats[MC_CMD_MAC_RX_LANES23_DISP_ERR]);
+	mac_stats->rx_disp_error_lane2 = (stat_val >>  0) & 0xffffffff;
+	mac_stats->rx_disp_error_lane3 = (stat_val >> 32) & 0xffffffff;
+	MAC_STAT(rx_match_fault, RX_MATCH_FAULT);
+#undef MAC_STAT
+
+	rmb();
+	generation_start = dma_stats[MC_CMD_MAC_GENERATION_START];
+	if (generation_end != generation_start)
+		return -EAGAIN;
+
+	return 0;
+}
+
+static void siena_update_nic_stats(struct efx_nic *efx)
+{
+	int retry;
+
+	/* If we're unlucky enough to read statistics wduring the DMA, wait
+	 * up to 10ms for it to finish (typically takes <500us) */
+	for (retry = 0; retry < 100; ++retry) {
+		if (siena_try_update_nic_stats(efx) == 0)
+			return;
+		udelay(100);
+	}
+
+	/* Use the old values instead */
+}
+
+static void siena_start_nic_stats(struct efx_nic *efx)
+{
+	__le64 *dma_stats = (__le64 *)efx->stats_buffer.addr;
+
+	dma_stats[MC_CMD_MAC_GENERATION_END] = STATS_GENERATION_INVALID;
+
+	efx_mcdi_mac_stats(efx, efx->stats_buffer.dma_addr,
+			   MC_CMD_MAC_NSTATS * sizeof(u64), 1, 0);
+}
+
+static void siena_stop_nic_stats(struct efx_nic *efx)
+{
+	efx_mcdi_mac_stats(efx, efx->stats_buffer.dma_addr, 0, 0, 0);
+}
+
+/**************************************************************************
+ *
+ * Wake on LAN
+ *
+ **************************************************************************
+ */
+
+static void siena_get_wol(struct efx_nic *efx, struct ethtool_wolinfo *wol)
+{
+	struct siena_nic_data *nic_data = efx->nic_data;
+
+	wol->supported = WAKE_MAGIC;
+	if (nic_data->wol_filter_id != -1)
+		wol->wolopts = WAKE_MAGIC;
+	else
+		wol->wolopts = 0;
+	memset(&wol->sopass, 0, sizeof(wol->sopass));
+}
+
+
+static int siena_set_wol(struct efx_nic *efx, u32 type)
+{
+	struct siena_nic_data *nic_data = efx->nic_data;
+	int rc;
+
+	if (type & ~WAKE_MAGIC)
+		return -EINVAL;
+
+	if (type & WAKE_MAGIC) {
+		if (nic_data->wol_filter_id != -1)
+			efx_mcdi_wol_filter_remove(efx,
+						   nic_data->wol_filter_id);
+		rc = efx_mcdi_wol_filter_set_magic(efx, efx->net_dev->dev_addr,
+						   &nic_data->wol_filter_id);
+		if (rc)
+			goto fail;
+
+		pci_wake_from_d3(efx->pci_dev, true);
+	} else {
+		rc = efx_mcdi_wol_filter_reset(efx);
+		nic_data->wol_filter_id = -1;
+		pci_wake_from_d3(efx->pci_dev, false);
+		if (rc)
+			goto fail;
+	}
+
+	return 0;
+ fail:
+	netif_err(efx, hw, efx->net_dev, "%s failed: type=%d rc=%d\n",
+		  __func__, type, rc);
+	return rc;
+}
+
+
+static void siena_init_wol(struct efx_nic *efx)
+{
+	struct siena_nic_data *nic_data = efx->nic_data;
+	int rc;
+
+	rc = efx_mcdi_wol_filter_get_magic(efx, &nic_data->wol_filter_id);
+
+	if (rc != 0) {
+		/* If it failed, attempt to get into a synchronised
+		 * state with MC by resetting any set WoL filters */
+		efx_mcdi_wol_filter_reset(efx);
+		nic_data->wol_filter_id = -1;
+	} else if (nic_data->wol_filter_id != -1) {
+		pci_wake_from_d3(efx->pci_dev, true);
+	}
+}
+
+
+/**************************************************************************
+ *
+ * Revision-dependent attributes used by efx.c and nic.c
+ *
+ **************************************************************************
+ */
+
+const struct efx_nic_type siena_a0_nic_type = {
+	.probe = siena_probe_nic,
+	.dimension_resources = siena_dimension_resources,
+	.remove = siena_remove_nic,
+	.init = siena_init_nic,
+	.fini = efx_port_dummy_op_void,
+	.monitor = NULL,
+	.map_reset_reason = siena_map_reset_reason,
+	.map_reset_flags = siena_map_reset_flags,
+	.reset = siena_reset_hw,
+	.probe_port = siena_probe_port,
+	.remove_port = siena_remove_port,
+	.prepare_flush = efx_port_dummy_op_void,
+	.update_stats = siena_update_nic_stats,
+	.start_stats = siena_start_nic_stats,
+	.stop_stats = siena_stop_nic_stats,
+	.set_id_led = efx_mcdi_set_id_led,
+	.push_irq_moderation = siena_push_irq_moderation,
+	.reconfigure_mac = efx_mcdi_mac_reconfigure,
+	.check_mac_fault = efx_mcdi_mac_check_fault,
+	.reconfigure_port = efx_mcdi_phy_reconfigure,
+	.get_wol = siena_get_wol,
+	.set_wol = siena_set_wol,
+	.resume_wol = siena_init_wol,
+	.test_registers = siena_test_registers,
+	.test_memory = siena_test_tables,
+	.test_nvram = efx_mcdi_nvram_test_all,
+
+	.revision = EFX_REV_SIENA_A0,
+	.dl_revision = "siena/a0",
+	.mem_map_size = (FR_CZ_MC_TREG_SMEM +
+			 FR_CZ_MC_TREG_SMEM_STEP * FR_CZ_MC_TREG_SMEM_ROWS),
+	.txd_ptr_tbl_base = FR_BZ_TX_DESC_PTR_TBL,
+	.rxd_ptr_tbl_base = FR_BZ_RX_DESC_PTR_TBL,
+	.buf_tbl_base = FR_BZ_BUF_FULL_TBL,
+	.evq_ptr_tbl_base = FR_BZ_EVQ_PTR_TBL,
+	.evq_rptr_tbl_base = FR_BZ_EVQ_RPTR,
+	.max_dma_mask = DMA_BIT_MASK(FSF_AZ_TX_KER_BUF_ADDR_WIDTH),
+	.rx_buffer_hash_size = 0x10,
+	.rx_buffer_padding = 0,
+	.max_interrupt_mode = EFX_INT_MODE_MSIX,
+	.phys_addr_channels = 32, /* Hardware limit is 64, but the legacy
+				   * interrupt handler only supports 32
+				   * channels */
+	.timer_period_max = 1 << FRF_CZ_TC_TIMER_VAL_WIDTH,
+	.resources = {
+		.hdr.next = ((struct efx_dl_device_info *)
+			     &siena_a0_nic_type.dl_hash_insertion.hdr),
+		.hdr.type = EFX_DL_FALCON_RESOURCES,
+		.rxq_min = 0, .rxq_lim = 1024,
+		.txq_min = 0, .txq_lim = 1024,
+		.evq_int_min = 0, .evq_int_lim = 64,
+		.evq_timer_min = 64, .evq_timer_lim = 1024,
+	},
+	.dl_hash_insertion = {
+		.hdr.type = EFX_DL_HASH_INSERTION,
+		.data_offset = 0x10,
+		.hash_offset = 0x0c,
+		.flags = (EFX_DL_HASH_TOEP_TCPIP4 | EFX_DL_HASH_TOEP_IP4 |
+			  EFX_DL_HASH_TOEP_TCPIP6 | EFX_DL_HASH_TOEP_IP6),
+	},
+#if !defined(EFX_USE_KCOMPAT) || defined(NETIF_F_IPV6_CSUM)
+	.offload_features = (NETIF_F_IP_CSUM | NETIF_F_IPV6_CSUM |
+			     NETIF_F_RXHASH | NETIF_F_NTUPLE),
+#else
+	.offload_features = NETIF_F_HW_CSUM | NETIF_F_RXHASH | NETIF_F_NTUPLE,
+#endif
+};
diff -r 9566a4a50a43 drivers/net/sfc/spi.h
--- a/drivers/net/sfc/spi.h
+++ b/drivers/net/sfc/spi.h
@@ -1,7 +1,7 @@
 /****************************************************************************
  * Driver for Solarflare Solarstorm network controllers and boards
  * Copyright 2005 Fen Systems Ltd.
- * Copyright 2006 Solarflare Communications Inc.
+ * Copyright 2006-2010 Solarflare Communications Inc.
  *
  * This program is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 as published
@@ -36,8 +36,6 @@
 
 /**
  * struct efx_spi_device - an Efx SPI (Serial Peripheral Interface) device
- * @efx:		The Efx controller that owns this device
- * @mtd:		MTD state
  * @device_id:		Controller's id for the device
  * @size:		Size (in bytes)
  * @addr_len:		Number of address bytes in read/write commands
@@ -54,10 +52,6 @@
  *	Write commands are limited to blocks with this size and alignment.
  */
 struct efx_spi_device {
-	struct efx_nic *efx;
-#ifdef CONFIG_SFC_MTD
-	void *mtd;
-#endif
 	int device_id;
 	unsigned int size;
 	unsigned int addr_len;
@@ -67,12 +61,21 @@ struct efx_spi_device {
 	unsigned int block_size;
 };
 
-int falcon_spi_cmd(const struct efx_spi_device *spi, unsigned int command,
+static inline bool efx_spi_present(const struct efx_spi_device *spi)
+{
+	return spi->size != 0;
+}
+
+int falcon_spi_cmd(struct efx_nic *efx,
+		   const struct efx_spi_device *spi, unsigned int command,
 		   int address, const void* in, void *out, size_t len);
-int falcon_spi_wait_write(const struct efx_spi_device *spi);
-int falcon_spi_read(const struct efx_spi_device *spi, loff_t start,
+int falcon_spi_wait_write(struct efx_nic *efx,
+			  const struct efx_spi_device *spi);
+int falcon_spi_read(struct efx_nic *efx,
+		    const struct efx_spi_device *spi, loff_t start,
 		    size_t len, size_t *retlen, u8 *buffer);
-int falcon_spi_write(const struct efx_spi_device *spi, loff_t start,
+int falcon_spi_write(struct efx_nic *efx,
+		     const struct efx_spi_device *spi, loff_t start,
 		     size_t len, size_t *retlen, const u8 *buffer);
 
 /*
diff -r 9566a4a50a43 drivers/net/sfc/sriov.c
--- /dev/null
+++ b/drivers/net/sfc/sriov.c
@@ -0,0 +1,1824 @@
+/****************************************************************************
+ * Driver for Solarflare Solarstorm network controllers and boards
+ * Copyright 2010-2011 Solarflare Communications Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 as published
+ * by the Free Software Foundation, incorporated herein by reference.
+ */
+#include <linux/pci.h>
+#include <linux/module.h>
+#include "net_driver.h"
+#include "efx.h"
+#include "nic.h"
+#include "io.h"
+#include "mcdi.h"
+#include "filter.h"
+#include "mcdi_pcol.h"
+#include "regs.h"
+#include "vfdi.h"
+
+/* Number of longs required to track all the VIs in a VF */
+#define VI_MASK_LENGTH						\
+	DIV_ROUND_UP(1 << EFX_VI_SCALE_MAX, BITS_PER_LONG)
+
+/**
+ * struct efx_vf - A VF
+ * @efx: The Efx NIC owning this PF
+ * @pci_rid: The PCI requester ID for this VF
+ * @pci_name: The PCI name (formatted address) of this VF
+ * @index: The zero-based index of this VF.
+ * @req: VFDI incoming request work item. Incoming USR_EV events are received
+ *	by the NAPI handler, but must be handled by executing MCDI requests
+ *	inside a work item.
+ * @req_addr: VFDI incoming request dma address (in VF's pci address space).
+ * @req_type: Expected next incoming (from VF) VFDI_EV_TYPE member.
+ * @req_seqno: Expected next incoming (from VF) VFDI_EV_SEQ member.
+ * @msg_seqno: Next VFDI_EV_SEQ member to reply to VF. Protected by %status_lock
+ * @busy: VFDI request queued to be processed or being processed. Receiving
+ *	a VFDI request when %busy is set is an error condition.
+ * @buf: Incoming VFDI requests are dma from the VF into this buffer.
+ * @buftbl_base: Buffer table entries for this VF start at this index.
+ * @rx_filtering: Receive filtering has been requested by the VF driver.
+ * @rx_filter_flags: The flags sent in the INSERT_FILTER VFDI request.
+ * @rx_filter_qid: VF relative qid for RX filter requested by VF.
+ * @rx_filter_id: Receive mac filter ID. Only one filter per VF is supported.
+ * @tx_filter_id: Transmit mac filter ID.
+ * @addr: The mac address and outer vlan tag of the VF.
+ * @status_addr: VF dma address of page for vfdi_status updates.
+ * @status_lock: Mutex protecting %status_addr and %addr from simultaneous
+ *	updates by the VM and consumption by efx_sriov_update_vf_addr()
+ * @peer_page_addrs: Pointer to an array of guest pages for local addresses.
+ * @peer_page_count: Number of entries in %peer_page_count.
+ * @evq0_addrs: Pointer to an array of guest pages backing evq0.
+ * @evq0_count: Number of entries in %evq0_addrs.
+ * @wq: wait queue used by %VFDI_FINI_ALL_QUEUES handler to wait for flush
+ *	completions.
+ * @txq_mask: Mask of initialized transmit queues.
+ * @txq_count: Number of initialized transmit queues.
+ * @rxq_mask: Mask of initialized receive queues.
+ * @rxq_count: Number of initialized receive queues.
+ * @rxq_retry_mask: Mask or receive queues that need to be flushed again
+ *	due to flush failure.
+ * @rxq_retry_count: Number of receive queues in %rxq_retry_mask.
+ * @reset_work: Work item to schedule a VF reset.
+ */
+struct efx_vf {
+	struct efx_nic *efx;
+	unsigned int pci_rid;
+	char pci_name[13]; /* dddd:bb:dd.f */
+	unsigned int index;
+	struct work_struct req;
+	u64 req_addr;
+	int req_type;
+	unsigned req_seqno;
+	unsigned msg_seqno;
+	bool busy;
+	struct efx_buffer buf;
+	unsigned buftbl_base;
+	bool rx_filtering;
+	enum efx_filter_flags rx_filter_flags;
+	unsigned rx_filter_qid;
+	int rx_filter_id;
+	int tx_filter_id;
+	struct vfdi_endpoint addr;
+	dma_addr_t status_addr;
+	struct mutex status_lock;
+	u64 *peer_page_addrs;
+	unsigned peer_page_count;
+	u64 *evq0_addrs;
+	unsigned evq0_count;
+	wait_queue_head_t wq;
+	unsigned long txq_mask[VI_MASK_LENGTH];
+	unsigned txq_count;
+	unsigned long rxq_mask[VI_MASK_LENGTH];
+	unsigned rxq_count;
+	unsigned long rxq_retry_mask[VI_MASK_LENGTH];
+	atomic_t rxq_retry_count;
+	struct pci_dev *pci_dev;
+	struct device_attribute dev_attr_mac_addr;
+	struct device_attribute dev_attr_tci;
+	struct work_struct reset_work;
+};
+
+struct efx_memcpy_req {
+	unsigned int from_rid;
+	void *from_buf;
+	u64 from_addr;
+	unsigned int to_rid;
+	u64 to_addr;
+	unsigned length;
+};
+
+/**
+ * struct efx_local_addr - A MAC address on the vswitch without a VF.
+ *
+ * Siena does not have a switch, so VFs can't transmit data to each
+ * other. Instead the VFs must be made aware of the local addresses
+ * on the vswitch, so that they can arrange for an alternative
+ * software datapath to be used.
+ *
+ * There is no security issue here because a the hardware guarantees
+ * that a VF driver can only send traffic on its assigned vlan,address.
+ * Knowing the other addresses doesn't help.
+ *
+ * @link: List head for insertion into efx->local_addr_list.
+ * @mac_addr: Ethernet address
+ */
+struct efx_local_addr {
+	struct list_head link;
+	struct vfdi_endpoint addr;
+};
+
+/**
+ * struct efx_endpoint_page - Page of vfdi_endpoint structures
+ *
+ * @link: List head for insertion into efx->local_page_list.
+ * @ptr: Pointer to page.
+ * @addr: DMA address of page.
+ */
+struct efx_endpoint_page {
+	struct list_head link;
+	void *ptr;
+	dma_addr_t addr;
+};
+
+/* Buffer table entries are reserved txq0,rxq0,evq0,txq1,rxq1,evq1 */
+#define EFX_BUFTBL_TXQ_BASE(_vf, _qid)					\
+	((_vf)->buftbl_base + EFX_VF_BUFTBL_PER_VI * (_qid))
+#define EFX_BUFTBL_RXQ_BASE(_vf, _qid)					\
+	(EFX_BUFTBL_TXQ_BASE(_vf, _qid) +				\
+	 (EFX_MAX_DMAQ_SIZE * sizeof(efx_qword_t) / EFX_BUF_SIZE))
+#define EFX_BUFTBL_EVQ_BASE(_vf, _qid)					\
+	(EFX_BUFTBL_TXQ_BASE(_vf, _qid) +				\
+	 (2 * EFX_MAX_DMAQ_SIZE * sizeof(efx_qword_t) / EFX_BUF_SIZE))
+
+#define EFX_FIELD_MASK(_field)			\
+	((1 << _field ## _WIDTH) - 1)
+
+/* VFs can only use this many transmit channels */
+static unsigned int vf_max_tx_channels = 2;
+module_param(vf_max_tx_channels, uint, 0444);
+MODULE_PARM_DESC(vf_max_tx_channels,
+		 "Limit the number of TX channels VFs can use");
+
+static int vf_count = -1;
+module_param(vf_count, int, 0444);
+MODULE_PARM_DESC(vf_count,
+		 "Reduce the number of VFs initialized by the driver");
+
+enum {
+	VF_TX_FILTER_NEVER,
+	VF_TX_FILTER_AUTO,
+	VF_TX_FILTER_ALWAYS,
+};
+
+static int vf_tx_filter = VF_TX_FILTER_AUTO;
+module_param(vf_tx_filter, int, 0444);
+MODULE_PARM_DESC(vf_tx_filter,
+		 "VF transmit filter mode 0=>never, 1=>auto(default), 2=>always");
+
+#ifdef CONFIG_SFC_SRIOV
+
+/* Workqueue used by VFDI communication. We can't use keventd_wq because
+ * in a VMDq configuration the VF driver's probe() routine will be blocked
+ * there waiting for a VFDI response.
+ */
+static struct workqueue_struct *vfdi_workqueue;
+
+static unsigned abs_index(struct efx_vf *vf, unsigned index)
+{
+	return EFX_VI_BASE + (vf->index << vf->efx->vi_scale) + index;
+}
+
+static int efx_sriov_cmd(struct efx_nic *efx, bool enable,
+			 unsigned *vi_scale_out, unsigned *vf_total_out)
+{
+	u8 inbuf[MC_CMD_SRIOV_IN_LEN];
+	u8 outbuf[MC_CMD_SRIOV_OUT_LEN];
+	unsigned vi_scale, vf_total;
+	size_t outlen;
+	int rc;
+
+	MCDI_SET_DWORD(inbuf, SRIOV_IN_ENABLE, enable ? 1 : 0);
+	MCDI_SET_DWORD(inbuf, SRIOV_IN_VI_BASE, EFX_VI_BASE);
+	MCDI_SET_DWORD(inbuf, SRIOV_IN_VF_COUNT, efx->vf_count);
+
+	rc = efx_mcdi_rpc(efx, MC_CMD_SRIOV, inbuf, MC_CMD_SRIOV_IN_LEN,
+			  outbuf, MC_CMD_SRIOV_OUT_LEN, &outlen);
+	if (rc)
+		return rc;
+	if (outlen < MC_CMD_SRIOV_OUT_LEN)
+		return -EIO;
+
+	vf_total = MCDI_DWORD(outbuf, SRIOV_OUT_VF_TOTAL);
+	vi_scale = MCDI_DWORD(outbuf, SRIOV_OUT_VI_SCALE);
+	if (vi_scale > EFX_VI_SCALE_MAX)
+		return -EOPNOTSUPP;
+
+	if (vi_scale_out)
+		*vi_scale_out = vi_scale;
+	if (vf_total_out)
+		*vf_total_out = vf_total;
+
+	return 0;
+}
+
+static void efx_sriov_usrev(struct efx_nic *efx, bool enabled)
+{
+	efx_oword_t reg;
+
+	EFX_POPULATE_OWORD_2(reg,
+			     FRF_CZ_USREV_DIS, enabled ? 0 : 1,
+			     FRF_CZ_DFLT_EVQ, efx->vfdi_channel->channel);
+	efx_writeo(efx, &reg, FR_CZ_USR_EV_CFG);
+}
+
+static int efx_sriov_memcpy(struct efx_nic *efx, struct efx_memcpy_req *req,
+			    unsigned int count)
+{
+	u8 *inbuf, *record;
+	unsigned int used;
+	u32 from_rid, from_hi, from_lo;
+	int rc;
+
+	mb();	/* Finish writing source/reading dest before DMA starts */
+
+	used = MC_CMD_MEMCPY_IN_LEN(count);
+	if (used > MCDI_CTL_SDU_LEN_MAX)
+		return -ENOSPC;
+
+	/* Allocate room for the largest request */
+	inbuf = kzalloc(MCDI_CTL_SDU_LEN_MAX, GFP_KERNEL);
+	if (inbuf == NULL)
+		return -ENOMEM;
+
+	record = inbuf;
+	MCDI_SET_DWORD(record, MEMCPY_IN_RECORD, count);
+	while (count-- > 0) {
+		MCDI_SET_DWORD(record, MEMCPY_RECORD_TYPEDEF_TO_RID,
+			       req->to_rid);
+		MCDI_SET_DWORD(record, MEMCPY_RECORD_TYPEDEF_TO_ADDR_LO,
+			       (u32)req->to_addr);
+		MCDI_SET_DWORD(record, MEMCPY_RECORD_TYPEDEF_TO_ADDR_HI,
+			       (u32)(req->to_addr >> 32));
+		if (req->from_buf == NULL) {
+			from_rid = req->from_rid;
+			from_lo = (u32)req->from_addr;
+			from_hi = (u32)(req->from_addr >> 32);
+		} else {
+			if (used + req->length > MCDI_CTL_SDU_LEN_MAX) {
+				rc = -ENOSPC;
+				goto out;
+			}
+
+			from_rid = MC_CMD_MEMCPY_RECORD_TYPEDEF_RID_INLINE;
+			from_lo = used;
+			from_hi = 0;
+			memcpy(inbuf + used, req->from_buf, req->length);
+			used += req->length;
+		}
+
+		MCDI_SET_DWORD(record, MEMCPY_RECORD_TYPEDEF_FROM_RID, from_rid);
+		MCDI_SET_DWORD(record, MEMCPY_RECORD_TYPEDEF_FROM_ADDR_LO,
+			       from_lo);
+		MCDI_SET_DWORD(record, MEMCPY_RECORD_TYPEDEF_FROM_ADDR_HI,
+			       from_hi);
+		MCDI_SET_DWORD(record, MEMCPY_RECORD_TYPEDEF_LENGTH,
+			       req->length);
+
+		++req;
+		record += MC_CMD_MEMCPY_IN_RECORD_LEN;
+	}
+
+	rc = efx_mcdi_rpc(efx, MC_CMD_MEMCPY, inbuf, used, NULL, 0, NULL);
+out:
+	kfree(inbuf);
+
+	mb();	/* Don't write source/read dest before DMA is complete */
+
+	return rc;
+}
+
+/* The TX filter is entirely controlled by this driver, and is modified
+ * underneath the feet of the VF */
+static void efx_sriov_reset_tx_filter(struct efx_vf *vf)
+{
+	struct efx_nic *efx = vf->efx;
+	struct efx_filter_spec filter;
+	u16 vlan;
+	int rc;
+
+	if (vf->tx_filter_id != -1) {
+		efx_filter_remove_id_safe(efx, EFX_FILTER_PRI_REQUIRED,
+					  vf->tx_filter_id);
+		netif_dbg(efx, hw, efx->net_dev, "Removed vf %s tx filter %d\n",
+			  vf->pci_name, vf->tx_filter_id);
+		vf->tx_filter_id = -1;
+	}
+
+	if (is_zero_ether_addr(vf->addr.mac_addr))
+		return;
+
+	vlan = ntohs(vf->addr.tci) & VLAN_VID_MASK;
+	efx_filter_init_tx(&filter, abs_index(vf, 0));
+	rc = efx_filter_set_eth_local(&filter,
+				      vlan ? vlan : EFX_FILTER_VID_UNSPEC,
+				      vf->addr.mac_addr);
+	BUG_ON(rc);
+
+	rc = efx_filter_insert_filter(efx, &filter, true);
+	if (rc < 0) {
+		netif_warn(efx, hw, efx->net_dev,
+			   "Unable to migrate tx filter for vf %s\n",
+			   vf->pci_name);
+	} else {
+		netif_dbg(efx, hw, efx->net_dev, "Inserted vf %s tx filter %d\n",
+			  vf->pci_name, rc);
+		vf->tx_filter_id = rc;
+	}
+}
+
+/* The RX filter is managed here on behalf of the VF driver */
+static void efx_sriov_reset_rx_filter(struct efx_vf *vf)
+{
+	struct efx_nic *efx = vf->efx;
+	struct efx_filter_spec filter;
+	u16 vlan;
+	int rc;
+
+	if (vf->rx_filter_id != -1) {
+		efx_filter_remove_id_safe(efx, EFX_FILTER_PRI_REQUIRED,
+					  vf->rx_filter_id);
+		netif_dbg(efx, hw, efx->net_dev, "Removed vf %s rx filter %d\n",
+			  vf->pci_name, vf->rx_filter_id);
+		vf->rx_filter_id = -1;
+	}
+
+	if (!vf->rx_filtering || is_zero_ether_addr(vf->addr.mac_addr))
+		return;
+
+	vlan = ntohs(vf->addr.tci) & VLAN_VID_MASK;
+	efx_filter_init_rx(&filter, EFX_FILTER_PRI_REQUIRED,
+			   vf->rx_filter_flags,
+			   abs_index(vf, vf->rx_filter_qid));
+	rc = efx_filter_set_eth_local(&filter,
+				      vlan ? vlan : EFX_FILTER_VID_UNSPEC,
+				      vf->addr.mac_addr);
+	BUG_ON(rc);
+
+	rc = efx_filter_insert_filter(efx, &filter, true);
+	if (rc < 0) {
+		netif_warn(efx, hw, efx->net_dev,
+			   "Unable to insert rx filter for vf %s\n",
+			   vf->pci_name);
+	} else {
+		netif_dbg(efx, hw, efx->net_dev, "Inserted vf %s rx filter %d\n",
+			  vf->pci_name, rc);
+		vf->rx_filter_id = rc;
+	}
+}
+
+static void __efx_sriov_update_vf_addr(struct efx_vf *vf)
+{
+	efx_sriov_reset_tx_filter(vf);
+	efx_sriov_reset_rx_filter(vf);
+	queue_work(vfdi_workqueue, &vf->efx->peer_work);
+}
+
+/* Push the peer list to this VF. The caller must hold %status_lock to interlock
+ * with VFDI requests, and they must be serialised against manipulation of
+ * %local_page_list, either by acquiring %local_lock or by running from
+ * efx_sriov_peer_work() */
+static void __efx_sriov_push_vf_status(struct efx_vf *vf)
+{
+	struct efx_nic *efx = vf->efx;
+	struct vfdi_status *status = efx->vfdi_status.addr;
+	struct efx_memcpy_req copy[4];
+	struct efx_endpoint_page *epp;
+	unsigned int pos, count;
+	unsigned data_offset;
+	efx_qword_t event;
+
+	WARN_ON(!mutex_is_locked(&vf->status_lock));
+	WARN_ON(!vf->status_addr);
+
+	status->local = vf->addr;
+	status->generation_end = ++status->generation_start;
+
+	memset(copy, '\0', sizeof(copy));
+	/* Write generation_start */
+	copy[0].from_buf = &status->generation_start;
+	copy[0].to_rid = vf->pci_rid;
+	copy[0].to_addr = vf->status_addr + offsetof(struct vfdi_status,
+						     generation_start);
+	copy[0].length = sizeof(status->generation_start);
+	/* DMA the rest of the structure (excluding the generations). This
+	 * assumes that the non-generation portion of vfdi_status is in
+	 * one chunk starting at the version member. */
+	data_offset = offsetof(struct vfdi_status, version);
+	copy[1].from_rid = efx->pci_dev->devfn;
+	copy[1].from_addr = efx->vfdi_status.dma_addr + data_offset;
+	copy[1].to_rid = vf->pci_rid;
+	copy[1].to_addr = vf->status_addr + data_offset;
+	copy[1].length =  status->length - data_offset;
+
+	/* Copy the peer pages */
+	pos = 2;
+	count = 0;
+	list_for_each_entry(epp, &efx->local_page_list, link) {
+		if (count == vf->peer_page_count) {
+			/* The VF driver will know they need to provide more
+			 * pages because peer_addr_count is too large. */
+			break;
+		}
+		copy[pos].from_buf = NULL;
+		copy[pos].from_rid = efx->pci_dev->devfn;
+		copy[pos].from_addr = epp->addr;
+		copy[pos].to_rid = vf->pci_rid;
+		copy[pos].to_addr = vf->peer_page_addrs[count];
+		copy[pos].length = EFX_PAGE_SIZE;
+
+		if (++pos == ARRAY_SIZE(copy)) {
+			efx_sriov_memcpy(efx, copy, ARRAY_SIZE(copy));
+			pos = 0;
+		}
+		++count;
+	}
+
+	/* Write generation_end */
+	copy[pos].from_buf = &status->generation_end;
+	copy[pos].to_rid = vf->pci_rid;
+	copy[pos].to_addr = vf->status_addr + offsetof(struct vfdi_status,
+						       generation_end);
+	copy[pos].length = sizeof(status->generation_end);
+	efx_sriov_memcpy(efx, copy, pos + 1);
+
+	/* Notify the guest */
+	EFX_POPULATE_QWORD_3(event,
+			     FSF_AZ_EV_CODE, FSE_CZ_EV_CODE_USER_EV,
+			     VFDI_EV_SEQ, (vf->msg_seqno & 0xff),
+			     VFDI_EV_TYPE, VFDI_EV_TYPE_REQ_STATUS);
+	++vf->msg_seqno;
+	efx_generate_event(efx, EFX_VI_BASE + (vf->index << efx->vi_scale),
+			   &event);
+}
+
+static void efx_sriov_bufs(struct efx_nic *efx, unsigned offset,
+			   u64 *addr, unsigned count)
+{
+	efx_qword_t buf;
+	unsigned pos;
+
+	for (pos = 0; pos < count; ++pos) {
+		EFX_POPULATE_QWORD_3(buf,
+				     FRF_AZ_BUF_ADR_REGION, 0,
+				     FRF_AZ_BUF_ADR_FBUF,
+				     addr ? addr[pos] >> 12 : 0,
+				     FRF_AZ_BUF_OWNER_ID_FBUF, 0);
+		efx_sram_writeq(efx, efx->membase + FR_BZ_BUF_FULL_TBL,
+				&buf, offset + pos);
+	}
+}
+
+static bool bad_vf_index(struct efx_nic *efx, unsigned index)
+{
+	return (index >= (1 << efx->vi_scale));
+}
+
+static bool bad_buf_count(unsigned buf_count, unsigned max_entry_count)
+{
+	unsigned max_buf_count = max_entry_count *
+		sizeof(efx_qword_t) / EFX_BUF_SIZE;
+
+	return ((buf_count & (buf_count - 1)) || buf_count > max_buf_count);
+}
+
+static bool bad_abs_index(struct efx_nic *efx, unsigned abs_index,
+			  struct efx_vf **vf_out, unsigned *rel_index_out)
+{
+	unsigned vf_i;
+
+	if (abs_index < EFX_VI_BASE)
+		return true;
+	vf_i = (abs_index - EFX_VI_BASE) >> efx->vi_scale;
+	if (vf_i >= efx->vf_init_count)
+		return true;
+
+	if (vf_out)
+		*vf_out = efx->vf + vf_i;
+	if (rel_index_out)
+		*rel_index_out = abs_index & ((1 << efx->vi_scale) - 1);
+	return false;
+}
+
+static int efx_vfdi_init_evq(struct efx_vf *vf)
+{
+	struct efx_nic *efx = vf->efx;
+	struct vfdi_req *req = vf->buf.addr;
+	unsigned vf_evq = req->u.init_evq.index;
+	unsigned buf_count = req->u.init_evq.buf_count;
+	unsigned abs_evq = abs_index(vf, vf_evq);
+	unsigned buftbl = EFX_BUFTBL_EVQ_BASE(vf, vf_evq);
+	efx_oword_t reg;
+
+	if (bad_vf_index(efx, vf_evq) ||
+	    bad_buf_count(buf_count, EFX_MAX_VF_EVQ_SIZE)) {
+		if (net_ratelimit())
+			netif_err(efx, hw, efx->net_dev,
+				  "ERROR: Invalid INIT_EVQ from %s: evq %d bufs %d\n",
+				  vf->pci_name, vf_evq, buf_count);
+		return -EINVAL;
+	}
+
+	efx_sriov_bufs(efx, buftbl, req->u.init_evq.addr, buf_count);
+
+	EFX_POPULATE_OWORD_3(reg,
+			     FRF_CZ_TIMER_Q_EN, 1,
+			     FRF_CZ_HOST_NOTIFY_MODE, 0,
+			     FRF_CZ_TIMER_MODE, FFE_CZ_TIMER_MODE_DIS);
+	efx_writeo_table(efx, &reg, FR_BZ_TIMER_TBL, abs_evq);
+	EFX_POPULATE_OWORD_3(reg,
+			     FRF_AZ_EVQ_EN, 1,
+			     FRF_AZ_EVQ_SIZE, __ffs(buf_count),
+			     FRF_AZ_EVQ_BUF_BASE_ID, buftbl);
+	efx_writeo_table(efx, &reg, FR_BZ_EVQ_PTR_TBL, abs_evq);
+
+	if (vf_evq == 0) {
+		kfree(vf->evq0_addrs);
+		vf->evq0_addrs = NULL;
+		vf->evq0_count = 0;
+
+		vf->evq0_addrs = kcalloc(buf_count, sizeof(u64), GFP_KERNEL);
+		if (vf->evq0_addrs) {
+			memcpy(vf->evq0_addrs, req->u.init_evq.addr,
+			       buf_count * sizeof(u64));
+			vf->evq0_count = buf_count;
+		}
+	}
+
+	return 0;
+}
+
+static int efx_vfdi_init_rxq(struct efx_vf *vf)
+{
+	struct efx_nic *efx = vf->efx;
+	struct vfdi_req *req = vf->buf.addr;
+	unsigned vf_rxq = req->u.init_rxq.index;
+	unsigned vf_evq = req->u.init_rxq.evq;
+	unsigned buf_count = req->u.init_rxq.buf_count;
+	unsigned buftbl = EFX_BUFTBL_RXQ_BASE(vf, vf_rxq);
+	unsigned label;
+	efx_oword_t reg;
+
+	if (bad_vf_index(efx, vf_evq) || bad_vf_index(efx, vf_rxq) ||
+	    bad_buf_count(buf_count, EFX_MAX_DMAQ_SIZE)) {
+		if (net_ratelimit())
+			netif_err(efx, hw, efx->net_dev,
+				  "ERROR: Invalid INIT_RXQ from %s: rxq %d evq %d "
+				  "buf_count %d\n", vf->pci_name, vf_rxq,
+				  vf_evq, buf_count);
+		return -EINVAL;
+	}
+	if (__test_and_set_bit(req->u.init_rxq.index, vf->rxq_mask))
+		++vf->rxq_count;
+	efx_sriov_bufs(efx, buftbl, req->u.init_rxq.addr, buf_count);
+
+	label = req->u.init_rxq.label & EFX_FIELD_MASK(FRF_AZ_RX_DESCQ_LABEL);
+	EFX_POPULATE_OWORD_6(reg,
+			     FRF_AZ_RX_DESCQ_BUF_BASE_ID, buftbl,
+			     FRF_AZ_RX_DESCQ_EVQ_ID, abs_index(vf, vf_evq),
+			     FRF_AZ_RX_DESCQ_LABEL, label,
+			     FRF_AZ_RX_DESCQ_SIZE, __ffs(buf_count),
+			     FRF_AZ_RX_DESCQ_JUMBO,
+			     !!(req->u.init_rxq.flags & RXQ_FLAG_SCATTER_EN),
+			     FRF_AZ_RX_DESCQ_EN, 1);
+	efx_writeo_table(efx, &reg, FR_BZ_RX_DESC_PTR_TBL,
+			 abs_index(vf, vf_rxq));
+
+	return 0;
+}
+
+static int efx_vfdi_init_txq(struct efx_vf *vf)
+{
+	struct efx_nic *efx = vf->efx;
+	struct vfdi_req *req = vf->buf.addr;
+	unsigned vf_txq = req->u.init_txq.index;
+	unsigned vf_evq = req->u.init_txq.evq;
+	unsigned buf_count = req->u.init_txq.buf_count;
+	unsigned buftbl = EFX_BUFTBL_TXQ_BASE(vf, vf_txq);
+	unsigned label, eth_filt_en;
+	efx_oword_t reg;
+
+	if (bad_vf_index(efx, vf_evq) || bad_vf_index(efx, vf_txq) ||
+	    vf_txq >= vf_max_tx_channels ||
+	    bad_buf_count(buf_count, EFX_MAX_DMAQ_SIZE)) {
+		if (net_ratelimit())
+			netif_err(efx, hw, efx->net_dev,
+				  "ERROR: Invalid INIT_TXQ from %s: txq %d evq %d "
+				  "buf_count %d\n", vf->pci_name, vf_txq,
+				  vf_evq, buf_count);
+		return -EINVAL;
+	}
+
+	if (__test_and_set_bit(req->u.init_txq.index, vf->txq_mask))
+		++vf->txq_count;
+	efx_sriov_bufs(efx, buftbl, req->u.init_txq.addr, buf_count);
+
+	if (vf_tx_filter == VF_TX_FILTER_ALWAYS ||
+	    (vf_tx_filter == VF_TX_FILTER_AUTO &&
+	     !is_zero_ether_addr(vf->addr.mac_addr) && vf_max_tx_channels <= 2))
+		eth_filt_en = 1;
+	else
+		eth_filt_en = 0;
+
+	label = req->u.init_txq.label & EFX_FIELD_MASK(FRF_AZ_TX_DESCQ_LABEL);
+	EFX_POPULATE_OWORD_8(reg,
+			     FRF_CZ_TX_DPT_Q_MASK_WIDTH, min(efx->vi_scale, 1U),
+			     FRF_CZ_TX_DPT_ETH_FILT_EN, eth_filt_en,
+			     FRF_AZ_TX_DESCQ_EN, 1,
+			     FRF_AZ_TX_DESCQ_BUF_BASE_ID, buftbl,
+			     FRF_AZ_TX_DESCQ_EVQ_ID, abs_index(vf, vf_evq),
+			     FRF_AZ_TX_DESCQ_LABEL, label,
+			     FRF_AZ_TX_DESCQ_SIZE, __ffs(buf_count),
+			     FRF_BZ_TX_NON_IP_DROP_DIS, 1);
+	efx_writeo_table(efx, &reg, FR_BZ_TX_DESC_PTR_TBL,
+			 abs_index(vf, vf_txq));
+
+	return 0;
+}
+
+/* Returns true when efx_vfdi_fini_all_queues should wake */
+static bool efx_vfdi_flush_wake(struct efx_vf *vf)
+{
+	/* Ensure that all updates are visible to efx_vfdi_fini_all_queues() */
+	smp_mb();
+
+	return (!vf->txq_count && !vf->rxq_count) ||
+		atomic_read(&vf->rxq_retry_count);
+}
+
+static void efx_vfdi_flush_clear(struct efx_vf *vf)
+{
+	memset(vf->txq_mask, 0, sizeof(vf->txq_mask));
+	vf->txq_count = 0;
+	memset(vf->rxq_mask, 0, sizeof(vf->rxq_mask));
+	vf->rxq_count = 0;
+	memset(vf->rxq_retry_mask, 0, sizeof(vf->rxq_retry_mask));
+	atomic_set(&vf->rxq_retry_count, 0);
+}
+
+static int efx_vfdi_fini_all_queues(struct efx_vf *vf)
+{
+	struct efx_nic *efx = vf->efx;
+	efx_oword_t reg;
+	unsigned count = (1 << efx->vi_scale);
+	unsigned vf_offset = EFX_VI_BASE + (vf->index << efx->vi_scale);
+	unsigned timeout = msecs_to_jiffies(1000); /* 1s */
+	unsigned index, rxqs_count;
+	__le32 *rxqs;
+	int rc;
+
+	rxqs = kmalloc(count * sizeof(*rxqs), GFP_KERNEL);
+	if (rxqs == NULL)
+		return -ENOMEM;
+
+	rtnl_lock();
+	if (efx->fc_disable++ == 0)
+		efx_mcdi_set_mac(efx);
+	rtnl_unlock();
+
+	/* Flush all the initialized queues */
+	rxqs_count = 0;
+	for (index = 0; index < count; ++index) {
+		if (test_bit(index, vf->txq_mask)) {
+			EFX_POPULATE_OWORD_2(reg,
+					     FRF_AZ_TX_FLUSH_DESCQ_CMD, 1,
+					     FRF_AZ_TX_FLUSH_DESCQ,
+					     vf_offset + index);
+			efx_writeo(efx, &reg, FR_AZ_TX_FLUSH_DESCQ);
+		}
+		if (test_bit(index, vf->rxq_mask))
+			rxqs[rxqs_count++] = cpu_to_le32(vf_offset + index);
+	}
+
+	atomic_set(&vf->rxq_retry_count, 0);
+	while (timeout && (vf->rxq_count || vf->txq_count)) {
+		rc = efx_mcdi_rpc(efx, MC_CMD_FLUSH_RX_QUEUES, (u8 *)rxqs,
+				  rxqs_count * sizeof(*rxqs), NULL, 0, NULL);
+		WARN_ON(rc < 0);
+
+		timeout = wait_event_timeout(vf->wq, efx_vfdi_flush_wake(vf),
+					     timeout);
+		rxqs_count = 0;
+		for (index = 0; index < count; ++index) {
+			if (test_and_clear_bit(index, vf->rxq_retry_mask)) {
+				atomic_dec(&vf->rxq_retry_count);
+				rxqs[rxqs_count++] =
+					cpu_to_le32(vf_offset + index);
+			}
+		}
+	}
+
+	rtnl_lock();
+	if (--efx->fc_disable == 0)
+		efx_mcdi_set_mac(efx);
+	rtnl_unlock();
+
+	/* Irrespective of success/failure, fini the queues */
+	EFX_ZERO_OWORD(reg);
+	for (index = 0; index < count; ++index) {
+		efx_writeo_table(efx, &reg, FR_BZ_RX_DESC_PTR_TBL,
+				 vf_offset + index);
+		efx_writeo_table(efx, &reg, FR_BZ_TX_DESC_PTR_TBL,
+				 vf_offset + index);
+		efx_writeo_table(efx, &reg, FR_BZ_EVQ_PTR_TBL,
+				 vf_offset + index);
+		efx_writeo_table(efx, &reg, FR_BZ_TIMER_TBL,
+				 vf_offset + index);
+	}
+	efx_sriov_bufs(efx, vf->buftbl_base, NULL,
+		       EFX_VF_BUFTBL_PER_VI << efx->vi_scale);
+	kfree(rxqs);
+	efx_vfdi_flush_clear(vf);
+
+	kfree(vf->evq0_addrs);
+	vf->evq0_addrs = NULL;
+	vf->evq0_count = 0;
+
+	return timeout ? 0 : -ETIMEDOUT;
+}
+
+static int efx_vfdi_insert_filter(struct efx_vf *vf)
+{
+	struct efx_nic *efx = vf->efx;
+	struct vfdi_req *req = vf->buf.addr;
+	unsigned vf_rxq = req->u.mac_filter.rxq;
+	unsigned flags;
+
+	if (bad_vf_index(efx, vf_rxq) || vf->rx_filtering) {
+		if (net_ratelimit())
+			netif_err(efx, hw, efx->net_dev,
+				  "ERROR: Invalid INSERT_FILTER from %s: rxq %d "
+				  "flags 0x%x\n", vf->pci_name, vf_rxq,
+				  req->u.mac_filter.flags);
+		return -EINVAL;
+	}
+
+	flags = 0;
+	if (req->u.mac_filter.flags & MAC_FILTER_FLAG_RSS)
+		flags |= EFX_FILTER_FLAG_RX_RSS;
+	if (req->u.mac_filter.flags & MAC_FILTER_FLAG_SCATTER)
+		flags |= EFX_FILTER_FLAG_RX_SCATTER;
+	vf->rx_filter_flags = flags;
+	vf->rx_filter_qid = vf_rxq;
+	vf->rx_filtering = true;
+
+	efx_sriov_reset_rx_filter(vf);
+	queue_work(vfdi_workqueue, &efx->peer_work);
+
+	return 0;
+}
+
+static int efx_vfdi_remove_all_filters(struct efx_vf *vf)
+{
+	vf->rx_filtering = false;
+	efx_sriov_reset_rx_filter(vf);
+	queue_work(vfdi_workqueue, &vf->efx->peer_work);
+
+	return 0;
+}
+
+static int efx_vfdi_set_status_page(struct efx_vf *vf)
+{
+	struct efx_nic *efx = vf->efx;
+	struct vfdi_req *req = vf->buf.addr;
+	u64 page_count = req->u.set_status_page.peer_page_count;
+	u64 max_page_count =
+		(EFX_PAGE_SIZE -
+		 offsetof(struct vfdi_req, u.set_status_page.peer_page_addr[0]))
+		/ sizeof(req->u.set_status_page.peer_page_addr[0]);
+
+	if (!req->u.set_status_page.dma_addr || page_count > max_page_count) {
+		if (net_ratelimit())
+			netif_err(efx, hw, efx->net_dev,
+				  "ERROR: Invalid SET_STATUS_PAGE from %s\n",
+				  vf->pci_name);
+		return -EINVAL;
+	}
+
+	mutex_lock(&efx->local_lock);
+	mutex_lock(&vf->status_lock);
+	vf->status_addr = req->u.set_status_page.dma_addr;
+
+	kfree(vf->peer_page_addrs);
+	vf->peer_page_addrs = NULL;
+	vf->peer_page_count = 0;
+
+	if (page_count) {
+		vf->peer_page_addrs = kcalloc(page_count, sizeof(u64),
+					      GFP_KERNEL);
+		if (vf->peer_page_addrs) {
+			memcpy(vf->peer_page_addrs,
+			       req->u.set_status_page.peer_page_addr,
+			       page_count * sizeof(u64));
+			vf->peer_page_count = page_count;
+		}
+	}
+
+	__efx_sriov_push_vf_status(vf);
+	mutex_unlock(&vf->status_lock);
+	mutex_unlock(&efx->local_lock);
+
+	return 0;
+}
+
+static int efx_vfdi_clear_status_page(struct efx_vf *vf)
+{
+	mutex_lock(&vf->status_lock);
+	vf->status_addr = 0;
+	mutex_unlock(&vf->status_lock);
+
+	return 0;
+}
+
+typedef int (*efx_vfdi_op_t)(struct efx_vf *vf);
+
+static const efx_vfdi_op_t vfdi_ops[VFDI_LIMIT] = {
+	[VFDI_INIT_EVQ] = efx_vfdi_init_evq,
+	[VFDI_INIT_TXQ] = efx_vfdi_init_txq,
+	[VFDI_INIT_RXQ] = efx_vfdi_init_rxq,
+	[VFDI_FINI_ALL_QUEUES] = efx_vfdi_fini_all_queues,
+	[VFDI_INSERT_FILTER] = efx_vfdi_insert_filter,
+	[VFDI_REMOVE_ALL_FILTERS] = efx_vfdi_remove_all_filters,
+	[VFDI_SET_STATUS_PAGE] = efx_vfdi_set_status_page,
+	[VFDI_CLEAR_STATUS_PAGE] = efx_vfdi_clear_status_page,
+};
+
+static void efx_sriov_vfdi(struct work_struct *work)
+{
+	struct efx_vf *vf = container_of(work, struct efx_vf, req);
+	struct efx_nic *efx = vf->efx;
+	struct vfdi_req *req = vf->buf.addr;
+	struct efx_memcpy_req copy[2];
+	int rc;
+
+	/* Copy this page into the local address space */
+	memset(copy, '\0', sizeof(copy));
+	copy[0].from_rid = vf->pci_rid;
+	copy[0].from_addr = vf->req_addr;
+	copy[0].to_rid = efx->pci_dev->devfn;
+	copy[0].to_addr = vf->buf.dma_addr;
+	copy[0].length = EFX_PAGE_SIZE;
+	rc = efx_sriov_memcpy(efx, copy, 1);
+	if (rc) {
+		/* If we can't get the request, we can't reply to the caller */
+		if (net_ratelimit())
+			netif_err(efx, hw, efx->net_dev,
+				  "ERROR: Unable to fetch VFDI request from %s rc %d\n",
+				  vf->pci_name, -rc);
+		vf->busy = false;
+		return;
+	}
+
+	if (req->op < VFDI_LIMIT && vfdi_ops[req->op] != NULL) {
+		rc = vfdi_ops[req->op](vf);
+		if (rc == 0) {
+			netif_dbg(efx, hw, efx->net_dev,
+				  "vfdi request %d from %s ok\n",
+				  req->op, vf->pci_name);
+		}
+	} else {
+		netif_dbg(efx, hw, efx->net_dev,
+			  "ERROR: Unrecognised request %d from VF %s addr "
+			  "%llx\n", req->op, vf->pci_name,
+			  (unsigned long long)vf->req_addr);
+		rc = -EOPNOTSUPP;
+	}
+
+	/* Allow subsequent VF requests */
+	vf->busy = false;
+	smp_wmb();
+
+	/* Respond to the request */
+	req->rc = rc;
+	req->op = VFDI_RESPONSE;
+
+	memset(copy, '\0', sizeof(copy));
+	copy[0].from_buf = &req->rc;
+	copy[0].to_rid = vf->pci_rid;
+	copy[0].to_addr = vf->req_addr + offsetof(struct vfdi_req, rc);
+	copy[0].length = sizeof(req->rc);
+	copy[1].from_buf = &req->op;
+	copy[1].to_rid = vf->pci_rid;
+	copy[1].to_addr = vf->req_addr + offsetof(struct vfdi_req, op);
+	copy[1].length = sizeof(req->op);
+
+	(void) efx_sriov_memcpy(efx, copy, ARRAY_SIZE(copy));
+}
+
+
+
+/* After a reset the event queues inside the guests no longer exist. Fill the
+ * event ring in guest memory with VFDI reset events, then (re-initialise) the
+ * event queue to raise an interrupt. The guest driver will then recover.
+ */
+static void efx_sriov_reset_vf(struct efx_vf *vf, struct efx_buffer *buffer)
+{
+	struct efx_nic *efx = vf->efx;
+	struct efx_memcpy_req copy_req[4];
+	efx_qword_t event;
+	unsigned int pos, count, k, buftbl, abs_evq;
+	efx_oword_t reg;
+	efx_dword_t ptr;
+	int rc;
+
+	BUG_ON(buffer->len != EFX_PAGE_SIZE);
+
+	if (!vf->evq0_count)
+		return;
+	BUG_ON(vf->evq0_count & (vf->evq0_count - 1));
+
+	mutex_lock(&vf->status_lock);
+	EFX_POPULATE_QWORD_3(event,
+			     FSF_AZ_EV_CODE, FSE_CZ_EV_CODE_USER_EV,
+			     VFDI_EV_SEQ, vf->msg_seqno,
+			     VFDI_EV_TYPE, VFDI_EV_TYPE_RESET);
+	vf->msg_seqno++;
+	for (pos = 0; pos < EFX_PAGE_SIZE; pos += sizeof(event))
+		memcpy(buffer->addr + pos, &event, sizeof(event));
+
+	for (pos = 0; pos < vf->evq0_count; pos += count) {
+		count = min_t(unsigned, vf->evq0_count - pos,
+			      ARRAY_SIZE(copy_req));
+		for (k = 0; k < count; k++) {
+			copy_req[k].from_buf = NULL;
+			copy_req[k].from_rid = efx->pci_dev->devfn;
+			copy_req[k].from_addr = buffer->dma_addr;
+			copy_req[k].to_rid = vf->pci_rid;
+			copy_req[k].to_addr = vf->evq0_addrs[pos + k];
+			copy_req[k].length = EFX_PAGE_SIZE;
+		}
+		rc = efx_sriov_memcpy(efx, copy_req, count);
+		if (rc) {
+			if (net_ratelimit())
+				netif_err(efx, hw, efx->net_dev,
+					  "ERROR: Unable to notify %s of reset"
+					  ": %d\n", vf->pci_name, -rc);
+			break;
+		}
+	}
+
+	/* Reinitialise and arm evq0 */
+	abs_evq = abs_index(vf, 0);
+	buftbl = EFX_BUFTBL_EVQ_BASE(vf, 0);
+	efx_sriov_bufs(efx, buftbl, vf->evq0_addrs, vf->evq0_count);
+
+	EFX_POPULATE_OWORD_3(reg,
+			     FRF_CZ_TIMER_Q_EN, 1,
+			     FRF_CZ_HOST_NOTIFY_MODE, 0,
+			     FRF_CZ_TIMER_MODE, FFE_CZ_TIMER_MODE_DIS);
+	efx_writeo_table(efx, &reg, FR_BZ_TIMER_TBL, abs_evq);
+	EFX_POPULATE_OWORD_3(reg,
+			     FRF_AZ_EVQ_EN, 1,
+			     FRF_AZ_EVQ_SIZE, __ffs(vf->evq0_count),
+			     FRF_AZ_EVQ_BUF_BASE_ID, buftbl);
+	efx_writeo_table(efx, &reg, FR_BZ_EVQ_PTR_TBL, abs_evq);
+	EFX_POPULATE_DWORD_1(ptr, FRF_AZ_EVQ_RPTR, 0);
+	efx_writed_table(efx, &ptr, FR_BZ_EVQ_RPTR, abs_evq);
+
+	mutex_unlock(&vf->status_lock);
+}
+
+static void efx_sriov_reset_vf_work(struct work_struct *work)
+{
+	struct efx_vf *vf = container_of(work, struct efx_vf, req);
+	struct efx_nic *efx = vf->efx;
+	struct efx_buffer buf;
+
+	if (!efx_nic_alloc_buffer(efx, &buf, EFX_PAGE_SIZE)) {
+		efx_sriov_reset_vf(vf, &buf);
+		efx_nic_free_buffer(efx, &buf);
+	}
+}
+
+static void efx_sriov_handle_no_channel(struct efx_nic *efx)
+{
+	netif_err(efx, drv, efx->net_dev,
+		  "ERROR: IOV requires MSI-X and 1 additional interrupt"
+		  "vector. IOV disabled\n");
+	efx->vf_count = 0;
+}
+
+static int efx_sriov_probe_channel(struct efx_channel *channel)
+{
+	channel->efx->vfdi_channel = channel;
+	return 0;
+}
+
+static void
+efx_sriov_get_channel_name(struct efx_channel *channel, char *buf, size_t len)
+{
+	snprintf(buf, len, "%s-iov", channel->efx->name);
+}
+
+static const struct efx_channel_type efx_sriov_channel_type = {
+	.handle_no_channel	= efx_sriov_handle_no_channel,
+	.pre_probe		= efx_sriov_probe_channel,
+	.post_remove		= efx_channel_dummy_op_void,
+	.get_name		= efx_sriov_get_channel_name,
+	/* no copy operation; channel must not be reallocated */
+	.keep_eventq		= true,
+};
+
+void efx_sriov_probe(struct efx_nic *efx)
+{
+	unsigned count;
+
+	if (!vf_count)
+		return;
+
+	if (efx_sriov_cmd(efx, false, &efx->vi_scale, &count))
+		return;
+	if (count > 0 && count > vf_count)
+		count = vf_count;
+
+	/* efx_nic_dimension_resources() will reduce vf_count as appopriate */
+	efx->vf_count = count;
+
+	efx->extra_channel_type[EFX_EXTRA_CHANNEL_IOV] = &efx_sriov_channel_type;
+}
+
+static ssize_t show_mac_addr(struct device *dev, struct device_attribute *attr,
+			     char *buf)
+{
+	struct efx_vf *vf = container_of(attr, struct efx_vf, dev_attr_mac_addr);
+	DECLARE_MAC_BUF(macbuf);
+
+	return sprintf(buf, "%s", print_mac(macbuf, vf->addr.mac_addr));
+}
+
+static ssize_t set_mac_addr(struct device *dev, struct device_attribute *attr,
+			    const char *buf, size_t count)
+{
+	struct efx_vf *vf = container_of(attr, struct efx_vf, dev_attr_mac_addr);
+	struct efx_nic *efx = vf->efx;
+	unsigned int pos;
+	int v[6];
+	u8 mac_addr[6];
+
+	if (sscanf(buf, "%02x:%02x:%02x:%02x:%02x:%02x",
+		   v + 0, v + 1, v + 2,
+		   v + 3, v + 4, v + 5) != 6)
+		return -EINVAL;
+	for (pos = 0; pos < ETH_ALEN; ++pos)
+		mac_addr[pos] = (u8)v[pos];
+
+	if (!memcmp(mac_addr, efx->net_dev->dev_addr, ETH_ALEN))
+		return -EINVAL;
+
+	mutex_lock(&vf->status_lock);
+	memcpy(vf->addr.mac_addr, mac_addr, ETH_ALEN);
+	__efx_sriov_update_vf_addr(vf);
+	mutex_unlock(&vf->status_lock);
+
+	return count;
+}
+
+static DEVICE_ATTR(mac_addr, 0644, show_mac_addr, set_mac_addr);
+
+static ssize_t show_tci(struct device *dev, struct device_attribute *attr,
+			char *buf)
+{
+	struct efx_vf *vf = container_of(attr, struct efx_vf, dev_attr_tci);
+
+	return sprintf(buf, "0x%04x", ntohs(vf->addr.tci));
+}
+
+static ssize_t set_tci(struct device *dev, struct device_attribute *attr,
+		       const char *buf, size_t count)
+{
+	struct efx_vf *vf = container_of(attr, struct efx_vf, dev_attr_tci);
+	char *end;
+	__le16 tci;
+
+	tci = simple_strtoul(buf, &end, 0x10);
+	if (*end)
+		return -EINVAL;
+
+	mutex_lock(&vf->status_lock);
+	vf->addr.tci = htons(tci);
+	__efx_sriov_update_vf_addr(vf);
+	mutex_unlock(&vf->status_lock);
+
+	return count;
+}
+
+static DEVICE_ATTR(tci, 0644, show_tci, set_tci);
+
+/* Print as many entries as we can fit in a PAGE */
+static ssize_t show_local_addrs(struct device *dev,
+				struct device_attribute *attr, char *buf)
+{
+	struct efx_nic *efx = pci_get_drvdata(to_pci_dev(dev));
+	struct efx_local_addr *local_addr;
+	unsigned int chunk, length = 0;
+
+	mutex_lock(&efx->local_lock);
+	list_for_each_entry(local_addr, &efx->local_addr_list, link) {
+		chunk = snprintf(buf + length, PAGE_SIZE - length,
+				 "%pM\n", local_addr->addr.mac_addr);
+		length += chunk;
+		if (PAGE_SIZE - length < chunk + 1)
+			break;
+	}
+	mutex_unlock(&efx->local_lock);
+
+	return length + 1;
+}
+
+/* Expected format: [+-]xx:xx:xx:xx:xx:xx */
+static ssize_t set_local_addrs(struct device *dev,
+			       struct device_attribute *attr,
+			       const char *buf, size_t count)
+{
+	struct efx_nic *efx = pci_get_drvdata(to_pci_dev(dev));
+	struct efx_local_addr *local_addr;
+	u8 new_addr[ETH_ALEN];
+	int byte, rc = 0;
+
+	if (count != 18)
+		return -EINVAL;
+	if (buf[0] != '-' && buf[0] != '+')
+		return -EINVAL;
+	if (buf[3] != ':' || buf[6] != ':' || buf[9] != ':' ||
+	    buf[12] != ':' || buf[15] != ':')
+		return -EINVAL;
+	for (byte = 0; byte < ETH_ALEN; ++byte)
+		new_addr[byte] = (u8)simple_strtol(buf + 1 + (3 * byte),
+						   NULL, 0x10);
+
+	mutex_lock(&efx->local_lock);
+	list_for_each_entry(local_addr, &efx->local_addr_list, link) {
+		if (!memcmp(local_addr->addr.mac_addr, new_addr, ETH_ALEN)) {
+			if (buf[0] == '-') {
+				list_del(&local_addr->link);
+				kfree(local_addr);
+				goto update;
+			}
+			goto unlock;	/* Adding an existing address */
+		}
+	}
+	if (buf[0] == '+') {
+		local_addr = kzalloc(sizeof(*local_addr), GFP_KERNEL);
+		if (local_addr == NULL) {
+			rc = -ENOMEM;
+			goto unlock;
+		}
+		memcpy(local_addr->addr.mac_addr, new_addr, ETH_ALEN);
+		list_add_tail(&local_addr->link, &efx->local_addr_list);
+		goto update;
+	}
+
+	goto unlock;	/* Removing a non-existent address */
+
+update:
+	queue_work(vfdi_workqueue, &efx->peer_work);
+unlock:
+	mutex_unlock(&efx->local_lock);
+	return rc ? rc : count;
+}
+
+static DEVICE_ATTR(local_addrs, 0644, show_local_addrs, set_local_addrs);
+
+/* Copy the list of individual addresses into the vfdi_status.peers
+ * array and auxillary pages, protected by %local_lock. Drop that lock
+ * and then broadcast the address list to every VF.
+ */
+static void efx_sriov_peer_work(struct work_struct *data)
+{
+	struct efx_nic *efx = container_of(data, struct efx_nic, peer_work);
+	struct vfdi_status *vfdi_status = efx->vfdi_status.addr;
+	struct efx_vf *vf;
+	struct efx_local_addr *local_addr;
+	struct vfdi_endpoint *peer;
+	struct efx_endpoint_page *epp;
+	struct list_head pages;
+	unsigned int peer_space;
+	unsigned int peer_count;
+	unsigned int pos;
+
+	mutex_lock(&efx->local_lock);
+
+	/* Move the existing peer pages off %local_page_list */
+	INIT_LIST_HEAD(&pages);
+	list_splice_tail_init(&efx->local_page_list, &pages);
+
+	/* Populate the VF addresses */
+	peer = vfdi_status->peers + 1;
+	peer_space = ARRAY_SIZE(vfdi_status->peers) - 1;
+	peer_count = 1;
+	for (pos = 0; pos < efx->vf_count; ++pos) {
+		vf = efx->vf + pos;
+
+		mutex_lock(&vf->status_lock);
+		if (vf->rx_filtering && !is_zero_ether_addr(vf->addr.mac_addr)) {
+			*peer++ = vf->addr;
+			++peer_count;
+			--peer_space;
+			BUG_ON(peer_space == 0);
+		}
+		mutex_unlock(&vf->status_lock);
+	}
+
+	/* Fill the remaining addresses */
+	list_for_each_entry(local_addr, &efx->local_addr_list, link) {
+		*peer++ = local_addr->addr;
+		++peer_count;
+		if (--peer_space == 0) {
+			if (list_empty(&pages)) {
+				epp = kmalloc(sizeof(*epp), GFP_KERNEL);
+				if (!epp)
+					break;
+				epp->ptr = dma_alloc_coherent(
+					&efx->pci_dev->dev, EFX_PAGE_SIZE,
+					&epp->addr, GFP_KERNEL);
+				if (!epp->ptr) {
+					kfree(epp);
+					break;
+				}
+			} else {
+				epp = list_first_entry(
+					&pages, struct efx_endpoint_page, link);
+				list_del(&epp->link);
+			}
+
+			list_add_tail(&epp->link, &efx->local_page_list);
+			peer = (struct vfdi_endpoint *)epp->ptr;
+			peer_space = EFX_PAGE_SIZE / sizeof(struct vfdi_endpoint);
+		}
+	}
+	vfdi_status->peer_count = peer_count;
+	mutex_unlock(&efx->local_lock);
+
+	/* Free any now unused endpoint pages */
+	while (!list_empty(&pages)) {
+		epp = list_first_entry(
+			&pages, struct efx_endpoint_page, link);
+		list_del(&epp->link);
+		dma_free_coherent(&efx->pci_dev->dev, EFX_PAGE_SIZE,
+				  epp->ptr, epp->addr);
+		kfree(epp);
+	}
+
+	/* Finally, push the pages */
+	for (pos = 0; pos < efx->vf_count; ++pos) {
+		vf = efx->vf + pos;
+
+		mutex_lock(&vf->status_lock);
+		if (vf->status_addr)
+			__efx_sriov_push_vf_status(vf);
+		mutex_unlock(&vf->status_lock);
+	}
+}
+
+static void efx_sriov_free_local(struct efx_nic *efx)
+{
+	struct efx_local_addr *local_addr;
+	struct efx_endpoint_page *epp;
+
+	while (!list_empty(&efx->local_addr_list)) {
+		local_addr = list_first_entry(&efx->local_addr_list,
+					      struct efx_local_addr, link);
+		list_del(&local_addr->link);
+		kfree(local_addr);
+	}
+
+	while (!list_empty(&efx->local_page_list)) {
+		epp = list_first_entry(&efx->local_page_list,
+				       struct efx_endpoint_page, link);
+		list_del(&epp->link);
+		dma_free_coherent(&efx->pci_dev->dev, EFX_PAGE_SIZE,
+				  epp->ptr, epp->addr);
+		kfree(epp);
+	}
+}
+
+static int efx_sriov_vf_alloc(struct efx_nic *efx)
+{
+	unsigned index;
+	struct efx_vf *vf;
+
+	efx->vf = kzalloc(sizeof(struct efx_vf) * efx->vf_count, GFP_KERNEL);
+	if (!efx->vf)
+		return -ENOMEM;
+
+	for (index = 0; index < efx->vf_count; ++index) {
+		vf = efx->vf + index;
+
+		vf->efx = efx;
+		vf->index = index;
+		vf->rx_filter_id = -1;
+		vf->tx_filter_id = -1;
+		INIT_WORK(&vf->req, efx_sriov_vfdi);
+		INIT_WORK(&vf->reset_work, efx_sriov_reset_vf_work);
+		init_waitqueue_head(&vf->wq);
+		mutex_init(&vf->status_lock);
+	}
+
+	return 0;
+}
+
+static void efx_sriov_vfs_fini(struct efx_nic *efx)
+{
+	struct efx_vf *vf;
+	unsigned int pos;
+
+	for (pos = 0; pos < efx->vf_count; ++pos) {
+		vf = efx->vf + pos;
+
+		efx_nic_free_buffer(efx, &vf->buf);
+		kfree(vf->peer_page_addrs);
+		vf->peer_page_addrs = NULL;
+		vf->peer_page_count = 0;
+
+		kfree(vf->evq0_addrs);
+		vf->evq0_addrs = NULL;
+		vf->evq0_count = 0;
+	}
+}
+
+static int efx_sriov_vfs_init(struct efx_nic *efx)
+{
+	struct pci_dev *pci_dev = efx->pci_dev;
+	unsigned index, devfn, sriov, buftbl_base;
+	u16 offset, stride;
+	struct efx_vf *vf;
+	int rc;
+
+	sriov = pci_find_ext_capability(pci_dev, PCI_EXT_CAP_ID_SRIOV);
+	if (!sriov)
+		return -ENOENT;
+
+	pci_read_config_word(pci_dev, sriov + PCI_SRIOV_VF_OFFSET, &offset);
+	pci_read_config_word(pci_dev, sriov + PCI_SRIOV_VF_STRIDE, &stride);
+
+	buftbl_base = efx->vf_buftbl_base;
+	devfn = pci_dev->devfn + offset;
+	for (index = 0; index < efx->vf_count; ++index) {
+		vf = efx->vf + index;
+
+		/* Reserve buffer entries */
+		vf->buftbl_base = buftbl_base;
+		buftbl_base += EFX_VF_BUFTBL_PER_VI << efx->vi_scale;
+
+		vf->pci_rid = devfn;
+		snprintf(vf->pci_name, sizeof(vf->pci_name),
+			 "%04x:%02x:%02x.%d",
+			 pci_domain_nr(pci_dev->bus), pci_dev->bus->number,
+			 PCI_SLOT(devfn), PCI_FUNC(devfn));
+
+		rc = efx_nic_alloc_buffer(efx, &vf->buf, EFX_PAGE_SIZE);
+		if (rc)
+			goto fail;
+
+		devfn += stride;
+	}
+
+	return 0;
+
+fail:
+	efx_sriov_vfs_fini(efx);
+	return rc;
+}
+
+static void efx_sriov_vf_attrs_init(struct efx_nic *efx)
+{
+	struct pci_dev *pci_dev = efx->pci_dev;
+	unsigned devfn, sriov;
+	u16 offset, stride;
+	struct efx_vf *vf;
+	unsigned int index;
+
+	sriov = pci_find_ext_capability(pci_dev, PCI_EXT_CAP_ID_SRIOV);
+	if (WARN_ON(!sriov))
+		return;
+
+	pci_read_config_word(pci_dev, sriov + PCI_SRIOV_VF_OFFSET, &offset);
+	pci_read_config_word(pci_dev, sriov + PCI_SRIOV_VF_STRIDE, &stride);
+
+	for (index = 0; index < efx->vf_count; ++index) {
+		vf = efx->vf + index;
+		devfn = pci_dev->devfn + offset + stride * index;
+
+		vf->pci_dev = pci_get_slot(efx->pci_dev->bus, devfn);
+		if (!vf->pci_dev) {
+			netif_err(efx, probe, efx->net_dev,
+				  "ERROR: unable to find VF devfn 0x%x\n", devfn);
+			continue;
+		}
+
+		memcpy(&vf->dev_attr_mac_addr, &dev_attr_mac_addr,
+		       sizeof(struct device_attribute));
+		memcpy(&vf->dev_attr_tci, &dev_attr_tci,
+		       sizeof(struct device_attribute));
+		if (device_create_file(&vf->pci_dev->dev,
+				       &vf->dev_attr_mac_addr))
+			continue;
+		if (device_create_file(&vf->pci_dev->dev, &vf->dev_attr_tci))
+			continue;
+	}
+}
+
+static void efx_sriov_vf_attrs_fini(struct efx_nic *efx)
+{
+	struct efx_vf *vf;
+	unsigned int pos;
+
+	for (pos = 0; pos < efx->vf_count; ++pos) {
+		vf = efx->vf + pos;
+
+		if (vf->pci_dev) {
+			device_remove_file(&vf->pci_dev->dev,
+					   &vf->dev_attr_tci);
+			device_remove_file(&vf->pci_dev->dev,
+					   &vf->dev_attr_mac_addr);
+			pci_dev_put(vf->pci_dev);
+			vf->pci_dev = NULL;
+		}
+	}
+}
+
+int efx_sriov_init(struct efx_nic *efx)
+{
+	struct net_device *net_dev = efx->net_dev;
+	struct vfdi_status *vfdi_status;
+	int rc;
+
+	/* Ensure there's room for vf_channel */
+	BUILD_BUG_ON(EFX_MAX_CHANNELS + 1 >= EFX_VI_BASE);
+	/* Ensure that VI_BASE is aligned on VI_SCALE */
+	BUILD_BUG_ON(EFX_VI_BASE & ((1 << EFX_VI_SCALE_MAX) - 1));
+
+	rc = efx_sriov_cmd(efx, true, NULL, NULL);
+	if (rc)
+		goto fail_cmd;
+
+	rc = efx_nic_alloc_buffer(efx, &efx->vfdi_status, sizeof(*vfdi_status));
+	if (rc)
+		goto fail_status;
+	vfdi_status = efx->vfdi_status.addr;
+	memset(vfdi_status, 0, sizeof(*vfdi_status));
+	vfdi_status->version = 1;
+	vfdi_status->length = sizeof(*vfdi_status);
+	vfdi_status->max_tx_channels = vf_max_tx_channels;
+	vfdi_status->vi_scale = efx->vi_scale;
+	vfdi_status->rss_rxq_count = efx->rss_spread;
+	vfdi_status->peer_count = 1 + efx->vf_count;
+	vfdi_status->timer_quantum_ns = efx->timer_quantum_ns;
+
+	rc = efx_sriov_vf_alloc(efx);
+	if (rc)
+		goto fail_alloc;
+
+	mutex_init(&efx->local_lock);
+	INIT_WORK(&efx->peer_work, efx_sriov_peer_work);
+	INIT_LIST_HEAD(&efx->local_addr_list);
+	INIT_LIST_HEAD(&efx->local_page_list);
+	rc = device_create_file(&efx->pci_dev->dev, &dev_attr_local_addrs);
+	if (rc)
+		goto fail_dev;
+
+	rc = efx_sriov_vfs_init(efx);
+	if (rc)
+		goto fail_vfs;
+
+	rtnl_lock();
+	memcpy(vfdi_status->peers[0].mac_addr,
+	       net_dev->dev_addr, ETH_ALEN);
+	efx->vf_init_count = efx->vf_count;
+	rtnl_unlock();
+
+	efx_sriov_usrev(efx, true);
+
+	/* At this point we must be ready to accept VFDI requests */
+
+	rc = pci_enable_sriov(efx->pci_dev, efx->vf_count);
+	if (rc)
+		goto fail_pci;
+
+	/* This has to be done after enabling SR-IOV, since there were
+	 * previously no devices to attach the attributes to.
+	 */
+	efx_sriov_vf_attrs_init(efx);
+
+	netif_info(efx, probe, net_dev,
+		   "enabled SR-IOV for %d VFs, %d VI per VF\n",
+		   efx->vf_count, 1 << efx->vi_scale);
+	return 0;
+
+fail_pci:
+	efx_sriov_usrev(efx, false);
+	rtnl_lock();
+	efx->vf_init_count = 0;
+	rtnl_unlock();
+	efx_sriov_vfs_fini(efx);
+fail_vfs:
+	device_remove_file(&efx->pci_dev->dev, &dev_attr_local_addrs);
+	cancel_work_sync(&efx->peer_work);
+	efx_sriov_free_local(efx);
+fail_dev:
+	kfree(efx->vf);
+fail_alloc:
+	efx_nic_free_buffer(efx, &efx->vfdi_status);
+fail_status:
+	efx_sriov_cmd(efx, false, NULL, NULL);
+fail_cmd:
+	return rc;
+}
+
+void efx_sriov_fini(struct efx_nic *efx)
+{
+	struct efx_vf *vf;
+	unsigned int pos;
+
+	if (efx->vf_init_count == 0)
+		return;
+
+	/* Disable all interfaces to reconfiguration */
+	efx_sriov_vf_attrs_fini(efx);
+	BUG_ON(efx->vfdi_channel->enabled);
+	efx_sriov_usrev(efx, false);
+	rtnl_lock();
+	efx->vf_init_count = 0;
+	rtnl_unlock();
+	device_remove_file(&efx->pci_dev->dev, &dev_attr_local_addrs);
+
+	/* Flush all reconfiguration work */
+	for (pos = 0; pos < efx->vf_count; ++pos) {
+		vf = efx->vf + pos;
+		cancel_work_sync(&vf->req);
+		cancel_work_sync(&vf->reset_work);
+	}
+	cancel_work_sync(&efx->peer_work);
+
+	pci_disable_sriov(efx->pci_dev);
+
+	/* Tear down back-end state */
+	efx_sriov_vfs_fini(efx);
+	efx_sriov_free_local(efx);
+	kfree(efx->vf);
+	efx_nic_free_buffer(efx, &efx->vfdi_status);
+	efx_sriov_cmd(efx, false, NULL, NULL);
+}
+
+void efx_sriov_event(struct efx_channel *channel, efx_qword_t *event)
+{
+	struct efx_nic *efx = channel->efx;
+	struct efx_vf *vf;
+	unsigned qid, seq, type, data;
+
+	qid = EFX_QWORD_FIELD(*event, FSF_CZ_USER_QID);
+
+	/* USR_EV_REG_VALUE is dword0, so access the VFDI_EV fields directly */
+	BUILD_BUG_ON(FSF_CZ_USER_EV_REG_VALUE_LBN != 0);
+	seq = EFX_QWORD_FIELD(*event, VFDI_EV_SEQ);
+	type = EFX_QWORD_FIELD(*event, VFDI_EV_TYPE);
+	data = EFX_QWORD_FIELD(*event, VFDI_EV_DATA);
+
+	netif_vdbg(efx, hw, efx->net_dev,
+		   "USR_EV event from qid %d seq 0x%x type %d data 0x%x\n",
+		   qid, seq, type, data);
+
+	if (bad_abs_index(efx, qid, &vf, NULL))
+		return;
+	if (vf->busy)
+		goto error;
+
+	if (type == VFDI_EV_TYPE_REQ_WORD0) {
+		/* Resynchronise */
+		vf->req_type = VFDI_EV_TYPE_REQ_WORD0;
+		vf->req_seqno = seq + 1;
+		vf->req_addr = 0;
+	} else if (seq != (vf->req_seqno++ & 0xff) || type != vf->req_type)
+		goto error;
+
+	switch (vf->req_type) {
+	case VFDI_EV_TYPE_REQ_WORD0:
+	case VFDI_EV_TYPE_REQ_WORD1:
+	case VFDI_EV_TYPE_REQ_WORD2:
+		vf->req_addr |= (u64)data << (vf->req_type << 4);
+		++vf->req_type;
+		return;
+
+	case VFDI_EV_TYPE_REQ_WORD3:
+		vf->req_addr |= (u64)data << 48;
+		vf->req_type = VFDI_EV_TYPE_REQ_WORD0;
+		vf->busy = true;
+		queue_work(vfdi_workqueue, &vf->req);
+		return;
+	}
+
+error:
+	if (net_ratelimit())
+		netif_err(efx, hw, efx->net_dev,
+			  "ERROR: Screaming VFDI request from %s\n",
+			  vf->pci_name);
+	/* Reset the request and sequence number */
+	vf->req_type = VFDI_EV_TYPE_REQ_WORD0;
+	vf->req_seqno = seq + 1;
+}
+
+void efx_sriov_flr(struct efx_nic *efx, unsigned vf_i)
+{
+	struct efx_vf *vf;
+
+	if (vf_i > efx->vf_init_count)
+		return;
+	vf = efx->vf + vf_i;
+	netif_info(efx, hw, efx->net_dev,
+		   "FLR on VF %s\n", vf->pci_name);
+
+	vf->status_addr = 0;
+	efx_vfdi_remove_all_filters(vf);
+	efx_vfdi_flush_clear(vf);
+
+	kfree(vf->evq0_addrs);
+	vf->evq0_addrs = NULL;
+	vf->evq0_count = 0;
+}
+
+void efx_sriov_mac_address_changed(struct efx_nic *efx)
+{
+	struct vfdi_status *vfdi_status = efx->vfdi_status.addr;
+
+	if (!efx->vf_init_count)
+		return;
+	memcpy(vfdi_status->peers[0].mac_addr,
+	       efx->net_dev->dev_addr, ETH_ALEN);
+	queue_work(vfdi_workqueue, &efx->peer_work);
+}
+
+void efx_sriov_tx_flush_done(struct efx_nic *efx, efx_qword_t *event)
+{
+	struct efx_vf *vf;
+	unsigned queue, qid;
+
+	queue = EFX_QWORD_FIELD(*event,  FSF_AZ_DRIVER_EV_SUBDATA);
+	if (bad_abs_index(efx, queue, &vf, &qid))
+		return;
+	/* Ignore flush completions triggered by an FLR */
+	if (!test_bit(qid, vf->txq_mask))
+		return;
+
+	__clear_bit(qid, vf->txq_mask);
+	--vf->txq_count;
+
+	if (efx_vfdi_flush_wake(vf))
+		wake_up(&vf->wq);
+}
+
+void efx_sriov_rx_flush_done(struct efx_nic *efx, efx_qword_t *event)
+{
+	struct efx_vf *vf;
+	unsigned ev_failed, queue, qid;
+
+	queue = EFX_QWORD_FIELD(*event, FSF_AZ_DRIVER_EV_RX_DESCQ_ID);
+	ev_failed = EFX_QWORD_FIELD(*event,
+				    FSF_AZ_DRIVER_EV_RX_FLUSH_FAIL);
+	if (bad_abs_index(efx, queue, &vf, &qid))
+		return;
+	if (!test_bit(qid, vf->rxq_mask))
+		return;
+
+	if (ev_failed) {
+		set_bit(qid, vf->rxq_retry_mask);
+		atomic_inc(&vf->rxq_retry_count);
+	} else {
+		__clear_bit(qid, vf->rxq_mask);
+		--vf->rxq_count;
+	}
+	if (efx_vfdi_flush_wake(vf))
+		wake_up(&vf->wq);
+}
+
+/* Called from napi. Schedule the reset work item */
+void efx_sriov_desc_fetch_err(struct efx_nic *efx, unsigned dmaq)
+{
+	struct efx_vf *vf;
+	unsigned int rel;
+
+	if (bad_abs_index(efx, dmaq, &vf, &rel))
+		return;
+
+	if (net_ratelimit())
+		netif_err(efx, hw, efx->net_dev,
+			  "VF %d DMA Q %d reports descriptor fetch error.\n",
+			  vf->index, rel);
+	queue_work(vfdi_workqueue, &vf->reset_work);
+}
+
+/* Reset all VFs */
+void efx_sriov_reset(struct efx_nic *efx)
+{
+	unsigned int vf_i;
+	struct efx_buffer buf;
+	struct efx_vf *vf;
+
+	ASSERT_RTNL();
+
+	if (efx->vf_init_count == 0)
+		return;
+
+	efx_sriov_usrev(efx, true);
+	(void)efx_sriov_cmd(efx, true, NULL, NULL);
+
+	if (efx_nic_alloc_buffer(efx, &buf, EFX_PAGE_SIZE))
+		return;
+
+	for (vf_i = 0; vf_i < efx->vf_init_count; ++vf_i) {
+		vf = efx->vf + vf_i;
+		efx_sriov_reset_vf(vf, &buf);
+	}
+
+	efx_nic_free_buffer(efx, &buf);
+}
+
+int efx_init_sriov(void)
+{
+	/* A single threaded workqueue is sufficient. efx_sriov_vfdi() and
+	 * efx_sriov_peer_work() spend almost all their time sleeping for
+	 * MCDI to complete anyway */
+	vfdi_workqueue = create_singlethread_workqueue("sfc_vfdi");
+	if (!vfdi_workqueue)
+		return -ENOMEM;
+
+	return 0;
+}
+
+void efx_fini_sriov(void)
+{
+	destroy_workqueue(vfdi_workqueue);
+}
+
+int efx_sriov_set_vf_mac(struct net_device *net_dev, int vf_i, u8 *mac)
+{
+	struct efx_nic *efx = netdev_priv(net_dev);
+	struct efx_vf *vf;
+
+	if (vf_i >= efx->vf_init_count)
+		return -EINVAL;
+	vf = efx->vf + vf_i;
+
+	mutex_lock(&vf->status_lock);
+	memcpy(vf->addr.mac_addr, mac, ETH_ALEN);
+	__efx_sriov_update_vf_addr(vf);
+	mutex_unlock(&vf->status_lock);
+
+	return 0;
+}
+
+int efx_sriov_set_vf_vlan(struct net_device *net_dev, int vf_i,
+			  u16 vlan, u8 qos)
+{
+	struct efx_nic *efx = netdev_priv(net_dev);
+	struct efx_vf *vf;
+	u16 tci;
+
+	if (vf_i >= efx->vf_init_count)
+		return -EINVAL;
+	vf = efx->vf + vf_i;
+
+	mutex_lock(&vf->status_lock);
+	tci = (vlan & VLAN_VID_MASK) | ((qos & 0x7) << VLAN_PRIO_SHIFT);
+	vf->addr.tci = htons(tci);
+	__efx_sriov_update_vf_addr(vf);
+	mutex_unlock(&vf->status_lock);
+
+	return 0;
+}
+
+int efx_sriov_get_vf_config(struct net_device *net_dev, int vf_i,
+			    struct ifla_vf_info *ivi)
+{
+	struct efx_nic *efx = netdev_priv(net_dev);
+	struct efx_vf *vf;
+	u16 tci;
+
+	if (vf_i >= efx->vf_init_count)
+		return -EINVAL;
+	if (vf_i >= 32)
+		return -EINVAL;
+	vf = efx->vf + vf_i;
+
+	ivi->vf = vf_i;
+	memcpy(ivi->mac, vf->addr.mac_addr, ETH_ALEN);
+	ivi->tx_rate = 0;
+	tci = ntohs(vf->addr.tci);
+	ivi->vlan = tci & VLAN_VID_MASK;
+	ivi->qos = (tci >> VLAN_PRIO_SHIFT) & 0x7;
+
+	return 0;
+}
+
+#endif
diff -r 9566a4a50a43 drivers/net/sfc/tenxpress.c
--- a/drivers/net/sfc/tenxpress.c
+++ b/drivers/net/sfc/tenxpress.c
@@ -1,6 +1,6 @@
 /****************************************************************************
  * Driver for Solarflare Solarstorm network controllers and boards
- * Copyright 2007-2008 Solarflare Communications Inc.
+ * Copyright 2007-2011 Solarflare Communications Inc.
  *
  * This program is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 as published
@@ -8,21 +8,16 @@
  */
 
 #include <linux/delay.h>
-#include <linux/rtnetlink.h>
 #include <linux/seq_file.h>
+#include <linux/slab.h>
 #include "efx.h"
+#include "debugfs.h"
 #include "mdio_10g.h"
-#include "falcon.h"
+#include "nic.h"
 #include "phy.h"
-#include "falcon_hwdefs.h"
-#include "boards.h"
 #include "workarounds.h"
-#include "selftest.h"
 
-/* We expect these MMDs to be in the package.  SFT9001 also has a
- * clause 22 extension MMD, but since it doesn't have all the generic
- * MMD registers it is pointless to include it here.
- */
+/* We expect these MMDs to be in the package. */
 #define TENXPRESS_REQUIRED_DEVS (MDIO_DEVS_PMAPMD	| \
 				 MDIO_DEVS_PCS		| \
 				 MDIO_DEVS_PHYXS	| \
@@ -31,13 +26,7 @@
 #define SFX7101_LOOPBACKS ((1 << LOOPBACK_PHYXS) |	\
 			   (1 << LOOPBACK_PCS) |	\
 			   (1 << LOOPBACK_PMAPMD) |	\
-			   (1 << LOOPBACK_NETWORK))
-
-#define SFT9001_LOOPBACKS ((1 << LOOPBACK_GPHY) |	\
-			   (1 << LOOPBACK_PHYXS) |	\
-			   (1 << LOOPBACK_PCS) |	\
-			   (1 << LOOPBACK_PMAPMD) |	\
-			   (1 << LOOPBACK_NETWORK))
+			   (1 << LOOPBACK_PHYXS_WS))
 
 /* We complain if we fail to see the link partner as 10G capable this many
  * times in a row (must be > 1 as sampling the autoneg. registers is racy)
@@ -50,9 +39,8 @@
 #define PMA_PMD_EXT_GMII_EN_WIDTH 1
 #define PMA_PMD_EXT_CLK_OUT_LBN	2
 #define PMA_PMD_EXT_CLK_OUT_WIDTH 1
-#define PMA_PMD_LNPGA_POWERDOWN_LBN 8	/* SFX7101 only */
+#define PMA_PMD_LNPGA_POWERDOWN_LBN 8
 #define PMA_PMD_LNPGA_POWERDOWN_WIDTH 1
-#define PMA_PMD_EXT_CLK312_LBN	8	/* SFT9001 only */
 #define PMA_PMD_EXT_CLK312_WIDTH 1
 #define PMA_PMD_EXT_LPOWER_LBN  12
 #define PMA_PMD_EXT_LPOWER_WIDTH 1
@@ -84,9 +72,14 @@
 #define PMA_PMD_LED_FLASH	(3)
 #define PMA_PMD_LED_MASK	3
 /* All LEDs under hardware control */
-#define PMA_PMD_LED_FULL_AUTO	(0)
 /* Green and Amber under hardware control, Red off */
-#define PMA_PMD_LED_DEFAULT	(PMA_PMD_LED_OFF << PMA_PMD_LED_RX_LBN)
+#define SFX7101_PMA_PMD_LED_DEFAULT (PMA_PMD_LED_OFF << PMA_PMD_LED_RX_LBN)
+
+/* Identifier registers: each identifier has 4 part number and 2 revision
+ * registers starting at one of these addresses */
+#define PMA_PMD_AFE_ID_REG      49174
+#define PMA_PMD_DSP_ID_REG      49180
+#define PMA_PMD_FIRMWARE_ID_REG 49186
 
 #define PMA_PMD_SPEED_ENABLE_REG 49192
 #define PMA_PMD_100TX_ADV_LBN    1
@@ -98,31 +91,7 @@
 #define PMA_PMD_SPEED_LBN        4
 #define PMA_PMD_SPEED_WIDTH      4
 
-/* Cable diagnostics - SFT9001 only */
-#define PMA_PMD_CDIAG_CTRL_REG  49213
-#define CDIAG_CTRL_IMMED_LBN    15
-#define CDIAG_CTRL_BRK_LINK_LBN 12
-#define CDIAG_CTRL_IN_PROG_LBN  11
-#define CDIAG_CTRL_LEN_UNIT_LBN 10
-#define CDIAG_CTRL_LEN_METRES   1
-#define PMA_PMD_CDIAG_RES_REG   49174
-#define CDIAG_RES_A_LBN         12
-#define CDIAG_RES_B_LBN         8
-#define CDIAG_RES_C_LBN         4
-#define CDIAG_RES_D_LBN         0
-#define CDIAG_RES_WIDTH         4
-#define CDIAG_RES_OPEN          2
-#define CDIAG_RES_OK            1
-#define CDIAG_RES_INVALID       0
-/* Set of 4 registers for pairs A-D */
-#define PMA_PMD_CDIAG_LEN_REG   49175
-
-/* Serdes control registers - SFT9001 only */
-#define PMA_PMD_CSERDES_CTRL_REG 64258
-/* Set the 156.25 MHz output to 312.5 MHz to drive Falcon's XMAC */
-#define PMA_PMD_CSERDES_DEFAULT	0x000f
-
-/* Misc register defines - SFX7101 only */
+/* Misc register defines */
 #define PCS_CLOCK_CTRL_REG	55297
 #define PLL312_RST_N_LBN 2
 
@@ -175,6 +144,10 @@
 #define C22EXT_MSTSLV_STATUS_LP_1000_HD_LBN	10
 #define C22EXT_MSTSLV_STATUS_LP_1000_FD_LBN	11
 
+#define TENXPRESS_ID_PN_LEN     (8)
+#define TENXPRESS_ID_REV_LEN    (4)
+#define TENXPRESS_ID_LEN        (TENXPRESS_ID_PN_LEN+1+TENXPRESS_ID_REV_LEN)
+
 /* Time to wait between powering down the LNPGA and turning off the power
  * rails */
 #define LNPGA_PDOWN_WAIT	(HZ / 5)
@@ -185,160 +158,76 @@ struct tenxpress_phy_data {
 	int bad_lp_tries;
 };
 
-static ssize_t show_phy_short_reach(struct device *dev,
-				    struct device_attribute *attr, char *buf)
-{
-	struct efx_nic *efx = pci_get_drvdata(to_pci_dev(dev));
-	int reg;
-
-	reg = efx_mdio_read(efx, MDIO_MMD_PMAPMD, MDIO_PMA_10GBT_TXPWR);
-	return sprintf(buf, "%d\n", !!(reg & MDIO_PMA_10GBT_TXPWR_SHORT));
-}
-
-static ssize_t set_phy_short_reach(struct device *dev,
-				   struct device_attribute *attr,
-				   const char *buf, size_t count)
-{
-	struct efx_nic *efx = pci_get_drvdata(to_pci_dev(dev));
-
-	rtnl_lock();
-	efx_mdio_set_flag(efx, MDIO_MMD_PMAPMD, MDIO_PMA_10GBT_TXPWR,
-			  MDIO_PMA_10GBT_TXPWR_SHORT,
-			  count != 0 && *buf != '0');
-	efx_reconfigure_port(efx);
-	rtnl_unlock();
-
-	return count;
-}
-
-static DEVICE_ATTR(phy_short_reach, 0644, show_phy_short_reach,
-		   set_phy_short_reach);
-
-int sft9001_wait_boot(struct efx_nic *efx)
-{
-	unsigned long timeout = jiffies + HZ + 1;
-	int boot_stat;
-
-	for (;;) {
-		boot_stat = efx_mdio_read(efx, MDIO_MMD_PCS,
-					  PCS_BOOT_STATUS_REG);
-		if (boot_stat >= 0) {
-			EFX_LOG(efx, "PHY boot status = %#x\n", boot_stat);
-			switch (boot_stat &
-				((1 << PCS_BOOT_FATAL_ERROR_LBN) |
-				 (3 << PCS_BOOT_PROGRESS_LBN) |
-				 (1 << PCS_BOOT_DOWNLOAD_WAIT_LBN) |
-				 (1 << PCS_BOOT_CODE_STARTED_LBN))) {
-			case ((1 << PCS_BOOT_FATAL_ERROR_LBN) |
-			      (PCS_BOOT_PROGRESS_CHECKSUM <<
-			       PCS_BOOT_PROGRESS_LBN)):
-			case ((1 << PCS_BOOT_FATAL_ERROR_LBN) |
-			      (PCS_BOOT_PROGRESS_INIT <<
-			       PCS_BOOT_PROGRESS_LBN) |
-			      (1 << PCS_BOOT_DOWNLOAD_WAIT_LBN)):
-				return -EINVAL;
-			case ((PCS_BOOT_PROGRESS_WAIT_MDIO <<
-			       PCS_BOOT_PROGRESS_LBN) |
-			      (1 << PCS_BOOT_DOWNLOAD_WAIT_LBN)):
-				return (efx->phy_mode & PHY_MODE_SPECIAL) ?
-					0 : -EIO;
-			case ((PCS_BOOT_PROGRESS_JUMP <<
-			       PCS_BOOT_PROGRESS_LBN) |
-			      (1 << PCS_BOOT_CODE_STARTED_LBN)):
-			case ((PCS_BOOT_PROGRESS_JUMP <<
-			       PCS_BOOT_PROGRESS_LBN) |
-			      (1 << PCS_BOOT_DOWNLOAD_WAIT_LBN) |
-			      (1 << PCS_BOOT_CODE_STARTED_LBN)):
-				return (efx->phy_mode & PHY_MODE_SPECIAL) ?
-					-EIO : 0;
-			default:
-				if (boot_stat & (1 << PCS_BOOT_FATAL_ERROR_LBN))
-					return -EIO;
-				break;
-			}
-		}
-
-		if (time_after_eq(jiffies, timeout))
-			return -ETIMEDOUT;
-
-		msleep(50);
-	}
-}
-
+/* Initialise the part post power on reset or software special reset */
 static int tenxpress_init(struct efx_nic *efx)
 {
-	int reg;
-
-	if (efx->phy_type == PHY_TYPE_SFX7101) {
-		/* Enable 312.5 MHz clock */
-		efx_mdio_write(efx, MDIO_MMD_PCS, PCS_TEST_SELECT_REG,
-			       1 << CLK312_EN_LBN);
-	} else {
-		/* Enable 312.5 MHz clock and GMII */
-		reg = efx_mdio_read(efx, MDIO_MMD_PMAPMD, PMA_PMD_XCONTROL_REG);
-		reg |= ((1 << PMA_PMD_EXT_GMII_EN_LBN) |
-			(1 << PMA_PMD_EXT_CLK_OUT_LBN) |
-			(1 << PMA_PMD_EXT_CLK312_LBN) |
-			(1 << PMA_PMD_EXT_ROBUST_LBN));
-
-		efx_mdio_write(efx, MDIO_MMD_PMAPMD, PMA_PMD_XCONTROL_REG, reg);
-		efx_mdio_set_flag(efx, MDIO_MMD_C22EXT,
-			      GPHY_XCONTROL_REG, 1 << GPHY_ISOLATE_LBN,
-			      false);
-	}
+	/* Enable 312.5 MHz clock */
+	efx_mdio_write(efx, MDIO_MMD_PCS, PCS_TEST_SELECT_REG,
+		       1 << CLK312_EN_LBN);
 
 	/* Set the LEDs up as: Green = Link, Amber = Link/Act, Red = Off */
-	if (efx->phy_type == PHY_TYPE_SFX7101) {
-		efx_mdio_set_flag(efx, MDIO_MMD_PMAPMD, PMA_PMD_LED_CTRL_REG,
-				  1 << PMA_PMA_LED_ACTIVITY_LBN, true);
-		efx_mdio_write(efx, MDIO_MMD_PMAPMD, PMA_PMD_LED_OVERR_REG,
-			       PMA_PMD_LED_DEFAULT);
-	}
+	efx_mdio_set_flag(efx, MDIO_MMD_PMAPMD, PMA_PMD_LED_CTRL_REG,
+			  1 << PMA_PMA_LED_ACTIVITY_LBN, true);
+	efx_mdio_write(efx, MDIO_MMD_PMAPMD, PMA_PMD_LED_OVERR_REG,
+		       SFX7101_PMA_PMD_LED_DEFAULT);
 
 	return 0;
 }
 
-static int tenxpress_phy_init(struct efx_nic *efx)
+static int tenxpress_phy_probe(struct efx_nic *efx)
 {
 	struct tenxpress_phy_data *phy_data;
-	int rc = 0;
+	int rc;
 
+	/* Allocate phy private storage */
 	phy_data = kzalloc(sizeof(*phy_data), GFP_KERNEL);
 	if (!phy_data)
 		return -ENOMEM;
 	efx->phy_data = phy_data;
 	phy_data->phy_mode = efx->phy_mode;
 
+	efx->mdio.mmds = TENXPRESS_REQUIRED_DEVS;
+	efx->mdio.mode_support = MDIO_SUPPORTS_C45;
+
+	efx->loopback_modes = SFX7101_LOOPBACKS | FALCON_XMAC_LOOPBACKS;
+	efx->startup_loopback_mode = LOOPBACK_PCS;
+
+	strlcpy(efx->phy_name, "SFX7101 10GBASE-T",
+		sizeof(efx->phy_name));
+
+	efx->link_advertising = (ADVERTISED_TP | ADVERTISED_Autoneg |
+				 ADVERTISED_10000baseT_Full);
+
+	return 0;
+
+	kfree(efx->phy_data);
+	efx->phy_data = NULL;
+	return rc;
+}
+
+static int tenxpress_phy_init(struct efx_nic *efx)
+{
+	int rc;
+
+	falcon_board(efx)->type->init_phy(efx);
+
 	if (!(efx->phy_mode & PHY_MODE_SPECIAL)) {
-		if (efx->phy_type == PHY_TYPE_SFT9001A) {
-			int reg;
-			reg = efx_mdio_read(efx, MDIO_MMD_PMAPMD,
-					    PMA_PMD_XCONTROL_REG);
-			reg |= (1 << PMA_PMD_EXT_SSR_LBN);
-			efx_mdio_write(efx, MDIO_MMD_PMAPMD,
-				       PMA_PMD_XCONTROL_REG, reg);
-			mdelay(200);
-		}
-
 		rc = efx_mdio_wait_reset_mmds(efx, TENXPRESS_REQUIRED_DEVS);
 		if (rc < 0)
-			goto fail;
+			return rc;
 
-		rc = efx_mdio_check_mmds(efx, TENXPRESS_REQUIRED_DEVS, 0);
+		rc = efx_mdio_check_mmds(efx, TENXPRESS_REQUIRED_DEVS);
 		if (rc < 0)
-			goto fail;
+			return rc;
 	}
 
 	rc = tenxpress_init(efx);
 	if (rc < 0)
-		goto fail;
+		return rc;
 
-	if (efx->phy_type == PHY_TYPE_SFT9001B) {
-		rc = device_create_file(&efx->pci_dev->dev,
-					&dev_attr_phy_short_reach);
-		if (rc)
-			goto fail;
-	}
+	/* Reinitialise flow control settings */
+	efx_link_set_wanted_fc(efx, efx->wanted_fc);
+	efx_mdio_an_reconfigure(efx);
 
 	schedule_timeout_uninterruptible(HZ / 5); /* 200ms */
 
@@ -346,11 +235,6 @@ static int tenxpress_phy_init(struct efx
 	falcon_reset_xaui(efx);
 
 	return 0;
-
- fail:
-	kfree(efx->phy_data);
-	efx->phy_data = NULL;
-	return rc;
 }
 
 /* Perform a "special software reset" on the PHY. The caller is
@@ -360,10 +244,10 @@ static int tenxpress_special_reset(struc
 {
 	int rc, reg;
 
-	/* The XGMAC clock is driven from the SFC7101/SFT9001 312MHz clock, so
+	/* The XGMAC clock is driven from the SFX7101 312MHz clock, so
 	 * a special software reset can glitch the XGMAC sufficiently for stats
 	 * requests to fail. */
-	efx_stats_disable(efx);
+	falcon_stop_nic_stats(efx);
 
 	/* Initiate reset */
 	reg = efx_mdio_read(efx, MDIO_MMD_PMAPMD, PMA_PMD_XCONTROL_REG);
@@ -385,7 +269,7 @@ static int tenxpress_special_reset(struc
 	/* Wait for the XGXS state machine to churn */
 	mdelay(10);
 out:
-	efx_stats_enable(efx);
+	falcon_start_nic_stats(efx);
 	return rc;
 }
 
@@ -421,10 +305,11 @@ static void sfx7101_check_bad_lp(struct 
 			reg |= PMA_PMD_LED_OFF << PMA_PMD_LED_RX_LBN;
 		} else {
 			reg |= PMA_PMD_LED_FLASH << PMA_PMD_LED_RX_LBN;
-			EFX_ERR(efx, "appears to be plugged into a port"
-				" that is not 10GBASE-T capable. The PHY"
-				" supports 10GBASE-T ONLY, so no link can"
-				" be established\n");
+			netif_err(efx, link, efx->net_dev,
+				  "appears to be plugged into a port"
+				  " that is not 10GBASE-T capable. The PHY"
+				  " supports 10GBASE-T ONLY, so no link can"
+				  " be established\n");
 		}
 		efx_mdio_write(efx, MDIO_MMD_PMAPMD,
 			       PMA_PMD_LED_OVERR_REG, reg);
@@ -440,182 +325,111 @@ static bool sfx7101_link_ok(struct efx_n
 				 MDIO_DEVS_PHYXS);
 }
 
-static bool sft9001_link_ok(struct efx_nic *efx, struct ethtool_cmd *ecmd)
-{
-	u32 reg;
-
-	if (efx_phy_mode_disabled(efx->phy_mode))
-		return false;
-	else if (efx->loopback_mode == LOOPBACK_GPHY)
-		return true;
-	else if (efx->loopback_mode)
-		return efx_mdio_links_ok(efx,
-					 MDIO_DEVS_PMAPMD |
-					 MDIO_DEVS_PHYXS);
-
-	/* We must use the same definition of link state as LASI,
-	 * otherwise we can miss a link state transition
-	 */
-	if (ecmd->speed == 10000) {
-		reg = efx_mdio_read(efx, MDIO_MMD_PCS, MDIO_PCS_10GBRT_STAT1);
-		return reg & MDIO_PCS_10GBRT_STAT1_BLKLK;
-	} else {
-		reg = efx_mdio_read(efx, MDIO_MMD_C22EXT, C22EXT_STATUS_REG);
-		return reg & (1 << C22EXT_STATUS_LINK_LBN);
-	}
-}
-
 static void tenxpress_ext_loopback(struct efx_nic *efx)
 {
 	efx_mdio_set_flag(efx, MDIO_MMD_PHYXS, PHYXS_TEST1,
 			  1 << LOOPBACK_NEAR_LBN,
 			  efx->loopback_mode == LOOPBACK_PHYXS);
-	if (efx->phy_type != PHY_TYPE_SFX7101)
-		efx_mdio_set_flag(efx, MDIO_MMD_C22EXT, GPHY_XCONTROL_REG,
-				  1 << GPHY_LOOPBACK_NEAR_LBN,
-				  efx->loopback_mode == LOOPBACK_GPHY);
 }
 
 static void tenxpress_low_power(struct efx_nic *efx)
 {
-	if (efx->phy_type == PHY_TYPE_SFX7101)
-		efx_mdio_set_mmds_lpower(
-			efx, !!(efx->phy_mode & PHY_MODE_LOW_POWER),
-			TENXPRESS_REQUIRED_DEVS);
-	else
-		efx_mdio_set_flag(
-			efx, MDIO_MMD_PMAPMD, PMA_PMD_XCONTROL_REG,
-			1 << PMA_PMD_EXT_LPOWER_LBN,
-			!!(efx->phy_mode & PHY_MODE_LOW_POWER));
+	efx_mdio_set_mmds_lpower(
+		efx, !!(efx->phy_mode & PHY_MODE_LOW_POWER),
+		TENXPRESS_REQUIRED_DEVS);
 }
 
-static void tenxpress_phy_reconfigure(struct efx_nic *efx)
+static int tenxpress_phy_reconfigure(struct efx_nic *efx)
 {
 	struct tenxpress_phy_data *phy_data = efx->phy_data;
-	struct ethtool_cmd ecmd;
 	bool phy_mode_change, loop_reset;
 
 	if (efx->phy_mode & (PHY_MODE_OFF | PHY_MODE_SPECIAL)) {
 		phy_data->phy_mode = efx->phy_mode;
-		return;
+		return 0;
+	}
+
+	phy_mode_change = (efx->phy_mode == PHY_MODE_NORMAL &&
+			   phy_data->phy_mode != PHY_MODE_NORMAL);
+	loop_reset = (LOOPBACK_OUT_OF(phy_data, efx, LOOPBACKS_EXTERNAL(efx)) ||
+		      LOOPBACK_CHANGED(phy_data, efx, 1 << LOOPBACK_GPHY));
+
+	if (loop_reset || phy_mode_change) {
+		tenxpress_special_reset(efx);
+		falcon_reset_xaui(efx);
 	}
 
 	tenxpress_low_power(efx);
-
-	phy_mode_change = (efx->phy_mode == PHY_MODE_NORMAL &&
-			   phy_data->phy_mode != PHY_MODE_NORMAL);
-	loop_reset = (LOOPBACK_OUT_OF(phy_data, efx, efx->phy_op->loopbacks) ||
-		      LOOPBACK_CHANGED(phy_data, efx, 1 << LOOPBACK_GPHY));
-
-	if (loop_reset || phy_mode_change) {
-		int rc;
-
-		efx->phy_op->get_settings(efx, &ecmd);
-
-		if (loop_reset || phy_mode_change) {
-			tenxpress_special_reset(efx);
-
-			/* Reset XAUI if we were in 10G, and are staying
-			 * in 10G. If we're moving into and out of 10G
-			 * then xaui will be reset anyway */
-			if (EFX_IS10G(efx))
-				falcon_reset_xaui(efx);
-		}
-
-		rc = efx->phy_op->set_settings(efx, &ecmd);
-		WARN_ON(rc);
-	}
-
 	efx_mdio_transmit_disable(efx);
 	efx_mdio_phy_reconfigure(efx);
 	tenxpress_ext_loopback(efx);
+	efx_mdio_an_reconfigure(efx);
 
 	phy_data->loopback_mode = efx->loopback_mode;
 	phy_data->phy_mode = efx->phy_mode;
 
-	if (efx->phy_type == PHY_TYPE_SFX7101) {
-		efx->link_speed = 10000;
-		efx->link_fd = true;
-		efx->link_up = sfx7101_link_ok(efx);
-	} else {
-		efx->phy_op->get_settings(efx, &ecmd);
-		efx->link_speed = ecmd.speed;
-		efx->link_fd = ecmd.duplex == DUPLEX_FULL;
-		efx->link_up = sft9001_link_ok(efx, &ecmd);
-	}
-	efx->link_fc = efx_mdio_get_pause(efx);
+	return 0;
 }
 
-/* Poll PHY for interrupt */
-static void tenxpress_phy_poll(struct efx_nic *efx)
+static void
+tenxpress_get_settings(struct efx_nic *efx, struct ethtool_cmd *ecmd);
+
+/* Poll for link state changes */
+static bool tenxpress_phy_poll(struct efx_nic *efx)
 {
-	struct tenxpress_phy_data *phy_data = efx->phy_data;
-	bool change = false;
+	struct efx_link_state old_state = efx->link_state;
 
-	if (efx->phy_type == PHY_TYPE_SFX7101) {
-		bool link_ok = sfx7101_link_ok(efx);
-		if (link_ok != efx->link_up) {
-			change = true;
-		} else {
-			unsigned int link_fc = efx_mdio_get_pause(efx);
-			if (link_fc != efx->link_fc)
-				change = true;
-		}
-		sfx7101_check_bad_lp(efx, link_ok);
-	} else if (efx->loopback_mode) {
-		bool link_ok = sft9001_link_ok(efx, NULL);
-		if (link_ok != efx->link_up)
-			change = true;
-	} else {
-		int status = efx_mdio_read(efx, MDIO_MMD_PMAPMD,
-					   MDIO_PMA_LASI_STAT);
-		if (status & MDIO_PMA_LASI_LSALARM)
-			change = true;
-	}
+	efx->link_state.up = sfx7101_link_ok(efx);
+	efx->link_state.speed = 10000;
+	efx->link_state.fd = true;
+	efx->link_state.fc = efx_mdio_get_pause(efx);
 
-	if (change)
-		falcon_sim_phy_event(efx);
+	sfx7101_check_bad_lp(efx, efx->link_state.up);
 
-	if (phy_data->phy_mode != PHY_MODE_NORMAL)
-		return;
+	return !efx_link_state_equal(&efx->link_state, &old_state);
 }
 
-static void tenxpress_phy_fini(struct efx_nic *efx)
+static void sfx7101_phy_fini(struct efx_nic *efx)
 {
 	int reg;
 
-	if (efx->phy_type == PHY_TYPE_SFT9001B)
-		device_remove_file(&efx->pci_dev->dev,
-				   &dev_attr_phy_short_reach);
+	/* Power down the LNPGA */
+	reg = (1 << PMA_PMD_LNPGA_POWERDOWN_LBN);
+	efx_mdio_write(efx, MDIO_MMD_PMAPMD, PMA_PMD_XCONTROL_REG, reg);
 
-	if (efx->phy_type == PHY_TYPE_SFX7101) {
-		/* Power down the LNPGA */
-		reg = (1 << PMA_PMD_LNPGA_POWERDOWN_LBN);
-		efx_mdio_write(efx, MDIO_MMD_PMAPMD, PMA_PMD_XCONTROL_REG, reg);
+	/* Waiting here ensures that the board fini, which can turn
+	 * off the power to the PHY, won't get run until the LNPGA
+	 * powerdown has been given long enough to complete. */
+	schedule_timeout_uninterruptible(LNPGA_PDOWN_WAIT); /* 200 ms */
+}
 
-		/* Waiting here ensures that the board fini, which can turn
-		 * off the power to the PHY, won't get run until the LNPGA
-		 * powerdown has been given long enough to complete. */
-		schedule_timeout_uninterruptible(LNPGA_PDOWN_WAIT); /* 200 ms */
-	}
-
+static void tenxpress_phy_remove(struct efx_nic *efx)
+{
 	kfree(efx->phy_data);
 	efx->phy_data = NULL;
 }
 
 
-/* Set the RX and TX LEDs and Link LED flashing. The other LEDs
- * (which probably aren't wired anyway) are left in AUTO mode */
-void tenxpress_phy_blink(struct efx_nic *efx, bool blink)
+/* Override the RX, TX and link LEDs */
+void tenxpress_set_id_led(struct efx_nic *efx, enum efx_led_mode mode)
 {
 	int reg;
 
-	if (blink)
-		reg = (PMA_PMD_LED_FLASH << PMA_PMD_LED_TX_LBN) |
-			(PMA_PMD_LED_FLASH << PMA_PMD_LED_RX_LBN) |
-			(PMA_PMD_LED_FLASH << PMA_PMD_LED_LINK_LBN);
-	else
-		reg = PMA_PMD_LED_DEFAULT;
+	switch (mode) {
+	case EFX_LED_OFF:
+		reg = (PMA_PMD_LED_OFF << PMA_PMD_LED_TX_LBN) |
+			(PMA_PMD_LED_OFF << PMA_PMD_LED_RX_LBN) |
+			(PMA_PMD_LED_OFF << PMA_PMD_LED_LINK_LBN);
+		break;
+	case EFX_LED_ON:
+		reg = (PMA_PMD_LED_ON << PMA_PMD_LED_TX_LBN) |
+			(PMA_PMD_LED_ON << PMA_PMD_LED_RX_LBN) |
+			(PMA_PMD_LED_ON << PMA_PMD_LED_LINK_LBN);
+		break;
+	default:
+		reg = SFX7101_PMA_PMD_LED_DEFAULT;
+		break;
+	}
 
 	efx_mdio_write(efx, MDIO_MMD_PMAPMD, PMA_PMD_LED_OVERR_REG, reg);
 }
@@ -624,6 +438,13 @@ static const char *const sfx7101_test_na
 	"bist"
 };
 
+static const char *sfx7101_test_name(struct efx_nic *efx, unsigned int index)
+{
+	if (index < ARRAY_SIZE(sfx7101_test_names))
+		return sfx7101_test_names[index];
+	return NULL;
+}
+
 static int
 sfx7101_run_tests(struct efx_nic *efx, int *results, unsigned flags)
 {
@@ -635,84 +456,8 @@ sfx7101_run_tests(struct efx_nic *efx, i
 	/* BIST is automatically run after a special software reset */
 	rc = tenxpress_special_reset(efx);
 	results[0] = rc ? -1 : 1;
-	return rc;
-}
 
-static const char *const sft9001_test_names[] = {
-	"bist",
-	"cable.pairA.status",
-	"cable.pairB.status",
-	"cable.pairC.status",
-	"cable.pairD.status",
-	"cable.pairA.length",
-	"cable.pairB.length",
-	"cable.pairC.length",
-	"cable.pairD.length",
-};
-
-static int sft9001_run_tests(struct efx_nic *efx, int *results, unsigned flags)
-{
-	struct ethtool_cmd ecmd;
-	int rc = 0, rc2, i, ctrl_reg, res_reg;
-
-	if (flags & ETH_TEST_FL_OFFLINE)
-		efx->phy_op->get_settings(efx, &ecmd);
-
-	/* Initialise cable diagnostic results to unknown failure */
-	for (i = 1; i < 9; ++i)
-		results[i] = -1;
-
-	/* Run cable diagnostics; wait up to 5 seconds for them to complete.
-	 * A cable fault is not a self-test failure, but a timeout is. */
-	ctrl_reg = ((1 << CDIAG_CTRL_IMMED_LBN) |
-		    (CDIAG_CTRL_LEN_METRES << CDIAG_CTRL_LEN_UNIT_LBN));
-	if (flags & ETH_TEST_FL_OFFLINE) {
-		/* Break the link in order to run full diagnostics.  We
-		 * must reset the PHY to resume normal service. */
-		ctrl_reg |= (1 << CDIAG_CTRL_BRK_LINK_LBN);
-	}
-	efx_mdio_write(efx, MDIO_MMD_PMAPMD, PMA_PMD_CDIAG_CTRL_REG,
-		       ctrl_reg);
-	i = 0;
-	while (efx_mdio_read(efx, MDIO_MMD_PMAPMD, PMA_PMD_CDIAG_CTRL_REG) &
-	       (1 << CDIAG_CTRL_IN_PROG_LBN)) {
-		if (++i == 50) {
-			rc = -ETIMEDOUT;
-			goto out;
-		}
-		msleep(100);
-	}
-	res_reg = efx_mdio_read(efx, MDIO_MMD_PMAPMD, PMA_PMD_CDIAG_RES_REG);
-	for (i = 0; i < 4; i++) {
-		int pair_res =
-			(res_reg >> (CDIAG_RES_A_LBN - i * CDIAG_RES_WIDTH))
-			& ((1 << CDIAG_RES_WIDTH) - 1);
-		int len_reg = efx_mdio_read(efx, MDIO_MMD_PMAPMD,
-					    PMA_PMD_CDIAG_LEN_REG + i);
-		if (pair_res == CDIAG_RES_OK)
-			results[1 + i] = 1;
-		else if (pair_res == CDIAG_RES_INVALID)
-			results[1 + i] = -1;
-		else
-			results[1 + i] = -pair_res;
-		if (pair_res != CDIAG_RES_INVALID &&
-		    pair_res != CDIAG_RES_OPEN &&
-		    len_reg != 0xffff)
-			results[5 + i] = len_reg;
-	}
-
-out:
-	if (flags & ETH_TEST_FL_OFFLINE) {
-		/* Reset, running the BIST and then resuming normal service. */
-		rc2 = tenxpress_special_reset(efx);
-		results[0] = rc2 ? -1 : 1;
-		if (!rc)
-			rc = rc2;
-
-		rc2 = efx->phy_op->set_settings(efx, &ecmd);
-		if (!rc)
-			rc = rc2;
-	}
+	efx_mdio_an_reconfigure(efx);
 
 	return rc;
 }
@@ -723,16 +468,6 @@ tenxpress_get_settings(struct efx_nic *e
 	u32 adv = 0, lpa = 0;
 	int reg;
 
-	if (efx->phy_type != PHY_TYPE_SFX7101) {
-		reg = efx_mdio_read(efx, MDIO_MMD_C22EXT, C22EXT_MSTSLV_CTRL);
-		if (reg & (1 << C22EXT_MSTSLV_CTRL_ADV_1000_FD_LBN))
-			adv |= ADVERTISED_1000baseT_Full;
-		reg = efx_mdio_read(efx, MDIO_MMD_C22EXT, C22EXT_MSTSLV_STATUS);
-		if (reg & (1 << C22EXT_MSTSLV_STATUS_LP_1000_HD_LBN))
-			lpa |= ADVERTISED_1000baseT_Half;
-		if (reg & (1 << C22EXT_MSTSLV_STATUS_LP_1000_FD_LBN))
-			lpa |= ADVERTISED_1000baseT_Full;
-	}
 	reg = efx_mdio_read(efx, MDIO_MMD_AN, MDIO_AN_10GBT_CTRL);
 	if (reg & MDIO_AN_10GBT_CTRL_ADV10G)
 		adv |= ADVERTISED_10000baseT_Full;
@@ -740,26 +475,28 @@ tenxpress_get_settings(struct efx_nic *e
 	if (reg & MDIO_AN_10GBT_STAT_LP10G)
 		lpa |= ADVERTISED_10000baseT_Full;
 
+#if defined(EFX_USE_KCOMPAT) && defined(EFX_NEED_MDIO45_FLOW_CONTROL_HACKS)
+	/* Old versions of the intree mdio45 layer don't set the pause
+	 * capabilities in the ecmd structure properly */
+	{
+		const struct mdio_if_info *mdio = &efx->mdio;
+		u32 reg;
+
+		reg = mdio->mdio_read(mdio->dev, mdio->prtad, MDIO_MMD_AN,
+				      MDIO_AN_ADVERTISE);
+		if (reg & ADVERTISE_PAUSE_CAP)
+			adv |= ADVERTISED_Pause;
+		if (reg & ADVERTISE_PAUSE_ASYM)
+			adv |= ADVERTISED_Asym_Pause;
+	}
+#endif
+
 	mdio45_ethtool_gset_npage(&efx->mdio, ecmd, adv, lpa);
 
-	if (efx->phy_type != PHY_TYPE_SFX7101) {
-		ecmd->supported |= (SUPPORTED_100baseT_Full |
-				    SUPPORTED_1000baseT_Full);
-		if (ecmd->speed != SPEED_10000) {
-			ecmd->eth_tp_mdix =
-				(efx_mdio_read(efx, MDIO_MMD_PMAPMD,
-					       PMA_PMD_XSTATUS_REG) &
-				 (1 << PMA_PMD_XSTAT_MDIX_LBN))
-				? ETH_TP_MDI_X : ETH_TP_MDI;
-		}
-	}
-
 	/* In loopback, the PHY automatically brings up the correct interface,
 	 * but doesn't advertise the correct speed. So override it */
-	if (efx->loopback_mode == LOOPBACK_GPHY)
-		ecmd->speed = SPEED_1000;
-	else if (LOOPBACK_MASK(efx) & efx->phy_op->loopbacks)
-		ecmd->speed = SPEED_10000;
+	if (LOOPBACK_EXTERNAL(efx))
+		ethtool_cmd_speed_set(ecmd, SPEED_10000);
 }
 
 static int tenxpress_set_settings(struct efx_nic *efx, struct ethtool_cmd *ecmd)
@@ -777,46 +514,17 @@ static void sfx7101_set_npage_adv(struct
 			  advertising & ADVERTISED_10000baseT_Full);
 }
 
-static void sft9001_set_npage_adv(struct efx_nic *efx, u32 advertising)
-{
-	efx_mdio_set_flag(efx, MDIO_MMD_C22EXT, C22EXT_MSTSLV_CTRL,
-			  1 << C22EXT_MSTSLV_CTRL_ADV_1000_FD_LBN,
-			  advertising & ADVERTISED_1000baseT_Full);
-	efx_mdio_set_flag(efx, MDIO_MMD_AN, MDIO_AN_10GBT_CTRL,
-			  MDIO_AN_10GBT_CTRL_ADV10G,
-			  advertising & ADVERTISED_10000baseT_Full);
-}
-
-struct efx_phy_operations falcon_sfx7101_phy_ops = {
-	.macs		  = EFX_XMAC,
+const struct efx_phy_operations falcon_sfx7101_phy_ops = {
+	.probe		  = tenxpress_phy_probe,
 	.init             = tenxpress_phy_init,
 	.reconfigure      = tenxpress_phy_reconfigure,
 	.poll             = tenxpress_phy_poll,
-	.fini             = tenxpress_phy_fini,
-	.clear_interrupt  = efx_port_dummy_op_void,
+	.fini             = sfx7101_phy_fini,
+	.remove		  = tenxpress_phy_remove,
 	.get_settings	  = tenxpress_get_settings,
 	.set_settings	  = tenxpress_set_settings,
 	.set_npage_adv    = sfx7101_set_npage_adv,
-	.num_tests	  = ARRAY_SIZE(sfx7101_test_names),
-	.test_names	  = sfx7101_test_names,
+	.test_alive	  = efx_mdio_test_alive,
+	.test_name	  = sfx7101_test_name,
 	.run_tests	  = sfx7101_run_tests,
-	.mmds             = TENXPRESS_REQUIRED_DEVS,
-	.loopbacks        = SFX7101_LOOPBACKS,
 };
-
-struct efx_phy_operations falcon_sft9001_phy_ops = {
-	.macs		  = EFX_GMAC | EFX_XMAC,
-	.init             = tenxpress_phy_init,
-	.reconfigure      = tenxpress_phy_reconfigure,
-	.poll             = tenxpress_phy_poll,
-	.fini             = tenxpress_phy_fini,
-	.clear_interrupt  = efx_port_dummy_op_void,
-	.get_settings	  = tenxpress_get_settings,
-	.set_settings	  = tenxpress_set_settings,
-	.set_npage_adv    = sft9001_set_npage_adv,
-	.num_tests	  = ARRAY_SIZE(sft9001_test_names),
-	.test_names	  = sft9001_test_names,
-	.run_tests	  = sft9001_run_tests,
-	.mmds             = TENXPRESS_REQUIRED_DEVS,
-	.loopbacks        = SFT9001_LOOPBACKS,
-};
diff -r 9566a4a50a43 drivers/net/sfc/tx.c
--- a/drivers/net/sfc/tx.c
+++ b/drivers/net/sfc/tx.c
@@ -1,7 +1,7 @@
 /****************************************************************************
  * Driver for Solarflare Solarstorm network controllers and boards
  * Copyright 2005-2006 Fen Systems Ltd.
- * Copyright 2005-2008 Solarflare Communications Inc.
+ * Copyright 2005-2010 Solarflare Communications Inc.
  *
  * This program is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 as published
@@ -12,12 +12,17 @@
 #include <linux/tcp.h>
 #include <linux/ip.h>
 #include <linux/in.h>
+#include <linux/ipv6.h>
+#include <linux/slab.h>
+#include <net/ipv6.h>
 #include <linux/if_ether.h>
+#include <linux/version.h>
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,20)
 #include <linux/highmem.h>
+#endif
 #include "net_driver.h"
-#include "tx.h"
 #include "efx.h"
-#include "falcon.h"
+#include "nic.h"
 #include "workarounds.h"
 
 /*
@@ -26,38 +31,7 @@
  * The tx_queue descriptor ring fill-level must fall below this value
  * before we restart the netif queue
  */
-#define EFX_NETDEV_TX_THRESHOLD(_tx_queue)	\
-	(_tx_queue->efx->type->txd_ring_mask / 2u)
-
-/* We want to be able to nest calls to netif_stop_queue(), since each
- * channel can have an individual stop on the queue.
- */
-void efx_stop_queue(struct efx_nic *efx)
-{
-	spin_lock_bh(&efx->netif_stop_lock);
-	EFX_TRACE(efx, "stop TX queue\n");
-
-	atomic_inc(&efx->netif_stop_count);
-	netif_stop_queue(efx->net_dev);
-
-	spin_unlock_bh(&efx->netif_stop_lock);
-}
-
-/* Wake netif's TX queue
- * We want to be able to nest calls to netif_stop_queue(), since each
- * channel can have an individual stop on the queue.
- */
-void efx_wake_queue(struct efx_nic *efx)
-{
-	local_bh_disable();
-	if (atomic_dec_and_lock(&efx->netif_stop_count,
-				&efx->netif_stop_lock)) {
-		EFX_TRACE(efx, "waking TX queue\n");
-		netif_wake_queue(efx->net_dev);
-		spin_unlock(&efx->netif_stop_lock);
-	}
-	local_bh_enable();
-}
+#define EFX_TXQ_THRESHOLD(_efx) ((_efx)->txq_entries / 2u)
 
 static void efx_dequeue_buffer(struct efx_tx_queue *tx_queue,
 			       struct efx_tx_buffer *buffer)
@@ -79,8 +53,6 @@ static void efx_dequeue_buffer(struct ef
 	if (buffer->skb) {
 		dev_kfree_skb_any((struct sk_buff *) buffer->skb);
 		buffer->skb = NULL;
-		EFX_TRACE(tx_queue->efx, "TX queue %d transmission id %x "
-			  "complete\n", tx_queue->queue, read_ptr);
 	}
 }
 
@@ -125,6 +97,24 @@ static void efx_tsoh_free(struct efx_tx_
 }
 
 
+static inline unsigned
+efx_max_tx_len(struct efx_nic *efx, dma_addr_t dma_addr)
+{
+	/* Depending on the NIC revision, we can use descriptor
+	 * lengths up to 8K or 8K-1.  However, since PCI Express
+	 * devices must split read requests at 4K boundaries, there is
+	 * little benefit from using descriptors that cross those
+	 * boundaries and we keep things simple by not doing so.
+	 */
+	unsigned len = (~dma_addr & 0xfff) + 1;
+
+	/* Work around hardware bug for unaligned buffers. */
+	if (EFX_WORKAROUND_5391(efx) && (dma_addr & 0xf))
+		len = min_t(unsigned, len, 512 - (dma_addr & 0xf));
+
+	return len;
+}
+
 /*
  * Add a socket buffer to a TX queue
  *
@@ -135,19 +125,19 @@ static void efx_tsoh_free(struct efx_tx_
  * If any DMA mapping fails, any mapped fragments will be unmapped,
  * the queue's insert pointer will be restored to its original value.
  *
+ * This function is split out from efx_hard_start_xmit to allow the
+ * loopback test to direct packets via specific TX queues.
+ *
  * Returns NETDEV_TX_OK or NETDEV_TX_BUSY
  * You must hold netif_tx_lock() to call this function.
  */
-static netdev_tx_t efx_enqueue_skb(struct efx_tx_queue *tx_queue,
-					 struct sk_buff *skb)
+netdev_tx_t efx_enqueue_skb(struct efx_tx_queue *tx_queue, struct sk_buff *skb)
 {
 	struct efx_nic *efx = tx_queue->efx;
 	struct pci_dev *pci_dev = efx->pci_dev;
 	struct efx_tx_buffer *buffer;
 	skb_frag_t *fragment;
-	struct page *page;
-	int page_offset;
-	unsigned int len, unmap_len = 0, fill_level, insert_ptr, misalign;
+	unsigned int len, unmap_len = 0, fill_level, insert_ptr;
 	dma_addr_t dma_addr, unmap_addr = 0;
 	unsigned int dma_len;
 	bool unmap_single;
@@ -156,7 +146,7 @@ static netdev_tx_t efx_enqueue_skb(struc
 
 	EFX_BUG_ON_PARANOID(tx_queue->write_count != tx_queue->insert_count);
 
-	if (skb_shinfo((struct sk_buff *)skb)->gso_size)
+	if (skb_shinfo(skb)->gso_size)
 		return efx_enqueue_skb_tso(tx_queue, skb);
 
 	/* Get size of the initial fragment */
@@ -171,7 +161,7 @@ static netdev_tx_t efx_enqueue_skb(struc
 	}
 
 	fill_level = tx_queue->insert_count - tx_queue->old_read_count;
-	q_space = efx->type->txd_ring_mask - 1 - fill_level;
+	q_space = efx->txq_entries - 1 - fill_level;
 
 	/* Map for DMA.  Use pci_map_single rather than pci_map_page
 	 * since this is more efficient on machines with sparse
@@ -198,26 +188,27 @@ static netdev_tx_t efx_enqueue_skb(struc
 				 * checked.  Update the xmit path's
 				 * copy of read_count.
 				 */
-				++tx_queue->stopped;
+				netif_tx_stop_queue(tx_queue->core_txq);
 				/* This memory barrier protects the
-				 * change of stopped from the access
+				 * change of queue state from the access
 				 * of read_count. */
 				smp_mb();
 				tx_queue->old_read_count =
-					*(volatile unsigned *)
-					&tx_queue->read_count;
+					ACCESS_ONCE(tx_queue->read_count);
 				fill_level = (tx_queue->insert_count
 					      - tx_queue->old_read_count);
-				q_space = (efx->type->txd_ring_mask - 1 -
-					   fill_level);
-				if (unlikely(q_space-- <= 0))
-					goto stop;
+				q_space = efx->txq_entries - 1 - fill_level;
+				if (unlikely(q_space-- <= 0)) {
+					rc = NETDEV_TX_BUSY;
+					goto unwind;
+				}
 				smp_mb();
-				--tx_queue->stopped;
+				if (likely(!efx->loopback_selftest))
+					netif_tx_start_queue(
+						tx_queue->core_txq);
 			}
 
-			insert_ptr = (tx_queue->insert_count &
-				      efx->type->txd_ring_mask);
+			insert_ptr = tx_queue->insert_count & tx_queue->ptr_mask;
 			buffer = &tx_queue->buffer[insert_ptr];
 			efx_tsoh_free(tx_queue, buffer);
 			EFX_BUG_ON_PARANOID(buffer->tsoh);
@@ -226,14 +217,10 @@ static netdev_tx_t efx_enqueue_skb(struc
 			EFX_BUG_ON_PARANOID(!buffer->continuation);
 			EFX_BUG_ON_PARANOID(buffer->unmap_len);
 
-			dma_len = (((~dma_addr) & efx->type->tx_dma_mask) + 1);
-			if (likely(dma_len > len))
+			dma_len = efx_max_tx_len(efx, dma_addr);
+			if (likely(dma_len >= len))
 				dma_len = len;
 
-			misalign = (unsigned)dma_addr & efx->type->bug5391_mask;
-			if (misalign && dma_len + misalign > 512)
-				dma_len = 512 - misalign;
-
 			/* Fill out per descriptor fields */
 			buffer->len = dma_len;
 			buffer->dma_addr = dma_addr;
@@ -252,13 +239,11 @@ static netdev_tx_t efx_enqueue_skb(struc
 			break;
 		fragment = &skb_shinfo(skb)->frags[i];
 		len = fragment->size;
-		page = fragment->page;
-		page_offset = fragment->page_offset;
 		i++;
 		/* Map for DMA */
 		unmap_single = false;
-		dma_addr = pci_map_page(pci_dev, page, page_offset, len,
-					PCI_DMA_TODEVICE);
+		dma_addr = skb_frag_dma_map(&pci_dev->dev, fragment, 0, len,
+					    DMA_TO_DEVICE);
 	}
 
 	/* Transfer ownership of the skb to the final buffer */
@@ -266,30 +251,24 @@ static netdev_tx_t efx_enqueue_skb(struc
 	buffer->continuation = false;
 
 	/* Pass off to hardware */
-	falcon_push_buffers(tx_queue);
+	efx_nic_push_buffers(tx_queue);
 
 	return NETDEV_TX_OK;
 
  pci_err:
-	EFX_ERR_RL(efx, " TX queue %d could not map skb with %d bytes %d "
-		   "fragments for DMA\n", tx_queue->queue, skb->len,
-		   skb_shinfo(skb)->nr_frags + 1);
+	netif_err(efx, tx_err, efx->net_dev,
+		  " TX queue %d could not map skb with %d bytes %d "
+		  "fragments for DMA\n", tx_queue->queue, skb->len,
+		  skb_shinfo(skb)->nr_frags + 1);
 
 	/* Mark the packet as transmitted, and free the SKB ourselves */
-	dev_kfree_skb_any((struct sk_buff *)skb);
-	goto unwind;
-
- stop:
-	rc = NETDEV_TX_BUSY;
-
-	if (tx_queue->stopped == 1)
-		efx_stop_queue(efx);
+	dev_kfree_skb_any(skb);
 
  unwind:
 	/* Work backwards until we hit the original insert pointer value */
 	while (tx_queue->insert_count != tx_queue->write_count) {
 		--tx_queue->insert_count;
-		insert_ptr = tx_queue->insert_count & efx->type->txd_ring_mask;
+		insert_ptr = tx_queue->insert_count & tx_queue->ptr_mask;
 		buffer = &tx_queue->buffer[insert_ptr];
 		efx_dequeue_buffer(tx_queue, buffer);
 		buffer->len = 0;
@@ -318,48 +297,33 @@ static void efx_dequeue_buffers(struct e
 {
 	struct efx_nic *efx = tx_queue->efx;
 	unsigned int stop_index, read_ptr;
-	unsigned int mask = tx_queue->efx->type->txd_ring_mask;
 
-	stop_index = (index + 1) & mask;
-	read_ptr = tx_queue->read_count & mask;
+	stop_index = (index + 1) & tx_queue->ptr_mask;
+	read_ptr = tx_queue->read_count & tx_queue->ptr_mask;
 
 	while (read_ptr != stop_index) {
 		struct efx_tx_buffer *buffer = &tx_queue->buffer[read_ptr];
 		if (unlikely(buffer->len == 0)) {
-			EFX_ERR(tx_queue->efx, "TX queue %d spurious TX "
-				"completion id %x\n", tx_queue->queue,
-				read_ptr);
+			netif_err(efx, hw, efx->net_dev,
+				  "TX queue %d spurious TX completion id %x\n",
+				  tx_queue->queue, read_ptr);
+			atomic_inc(&efx->errors.spurious_tx);
 			efx_schedule_reset(efx, RESET_TYPE_TX_SKIP);
 			return;
 		}
 
+		netif_vdbg(efx, tx_done, efx->net_dev,
+			   "TX queue %d transmission id %x omplete\n",
+			   tx_queue->queue, read_ptr);
 		efx_dequeue_buffer(tx_queue, buffer);
 		buffer->continuation = true;
 		buffer->len = 0;
 
 		++tx_queue->read_count;
-		read_ptr = tx_queue->read_count & mask;
+		read_ptr = tx_queue->read_count & tx_queue->ptr_mask;
 	}
 }
 
-/* Initiate a packet transmission on the specified TX queue.
- * Note that returning anything other than NETDEV_TX_OK will cause the
- * OS to free the skb.
- *
- * This function is split out from efx_hard_start_xmit to allow the
- * loopback test to direct packets via specific TX queues.  It is
- * therefore a non-static inline, so as not to penalise performance
- * for non-loopback transmissions.
- *
- * Context: netif_tx_lock held
- */
-inline netdev_tx_t efx_xmit(struct efx_nic *efx,
-			   struct efx_tx_queue *tx_queue, struct sk_buff *skb)
-{
-	/* Map fragments for DMA and add to TX queue */
-	return efx_enqueue_skb(tx_queue, skb);
-}
-
 /* Initiate a packet transmission.  We use one channel per CPU
  * (sharing when we have more CPUs than channels).  On Falcon, the TX
  * completion events will be directed back to the CPU that transmitted
@@ -370,32 +334,37 @@ inline netdev_tx_t efx_xmit(struct efx_n
  * OS to free the skb.
  */
 netdev_tx_t efx_hard_start_xmit(struct sk_buff *skb,
-				      struct net_device *net_dev)
+				struct net_device *net_dev)
 {
 	struct efx_nic *efx = netdev_priv(net_dev);
 	struct efx_tx_queue *tx_queue;
-	enum efx_veto veto;
+	int rc;
 
-	if (unlikely(efx->port_inhibited))
-		return NETDEV_TX_BUSY;
+	EFX_WARN_ON_PARANOID(!netif_device_present(net_dev));
 
-	if (likely(skb->ip_summed == CHECKSUM_PARTIAL))
-		tx_queue = &efx->tx_queue[EFX_TX_QUEUE_OFFLOAD_CSUM];
-	else
-		tx_queue = &efx->tx_queue[EFX_TX_QUEUE_NO_CSUM];
+#if defined(CONFIG_SFC_PTP)
+	/*
+	 * PTP "event" packet
+	 */
+	if (unlikely(efx_xmit_with_hwtstamp(skb)) &&
+		unlikely(efx_ptp_is_ptp_tx(efx, skb))) {
+		return efx_ptp_tx(efx, skb);
+	}
+#endif
 
-	/* See if driverlink wants to veto the packet. */
-	veto = EFX_DL_CALLBACK(efx, tx_packet, skb);
-	if (unlikely(veto)) {
-		EFX_DL_LOG(efx, "TX queue %d packet vetoed by "
-			   "driverlink %s driver\n", tx_queue->queue,
-			   efx->dl_cb_dev.tx_packet->driver->name);
-		/* Free the skb; nothing else will do it */
-		dev_kfree_skb_any(skb);
-		return NETDEV_TX_OK;
-	}
+	tx_queue = efx_get_tx_queue(efx, skb_get_queue_mapping(skb),
+				    skb->ip_summed == CHECKSUM_PARTIAL ?
+				    EFX_TXQ_TYPE_OFFLOAD : 0);
 
-	return efx_xmit(efx, tx_queue, skb);
+	rc = efx_enqueue_skb(tx_queue, skb);
+	return rc;
+}
+
+void efx_init_tx_queue_core_txq(struct efx_tx_queue *tx_queue)
+{
+	/* Must be inverse of queue lookup in efx_hard_start_xmit() */
+	tx_queue->core_txq = netdev_get_tx_queue(
+		tx_queue->efx->net_dev, tx_queue->queue / EFX_TXQ_TYPES);
 }
 
 void efx_xmit_done(struct efx_tx_queue *tx_queue, unsigned int index)
@@ -403,27 +372,30 @@ void efx_xmit_done(struct efx_tx_queue *
 	unsigned fill_level;
 	struct efx_nic *efx = tx_queue->efx;
 
-	EFX_BUG_ON_PARANOID(index > efx->type->txd_ring_mask);
+	EFX_BUG_ON_PARANOID(index > tx_queue->ptr_mask);
 
 	efx_dequeue_buffers(tx_queue, index);
 
 	/* See if we need to restart the netif queue.  This barrier
-	 * separates the update of read_count from the test of
-	 * stopped. */
+	 * separates the update of read_count from the test of the
+	 * queue state. */
 	smp_mb();
-	if (unlikely(tx_queue->stopped) && likely(efx->port_enabled)) {
+	if (likely(tx_queue->core_txq) &&
+	    unlikely(netif_tx_queue_stopped(tx_queue->core_txq)) &&
+	    likely(efx->port_enabled) &&
+	    likely(netif_device_present(efx->net_dev))) {
 		fill_level = tx_queue->insert_count - tx_queue->read_count;
-		if (fill_level < EFX_NETDEV_TX_THRESHOLD(tx_queue)) {
-			EFX_BUG_ON_PARANOID(!efx_dev_registered(efx));
+		if (fill_level < EFX_TXQ_THRESHOLD(efx))
+			netif_tx_wake_queue(tx_queue->core_txq);
+	}
 
-			/* Do this under netif_tx_lock(), to avoid racing
-			 * with efx_xmit(). */
-			netif_tx_lock(efx->net_dev);
-			if (tx_queue->stopped) {
-				tx_queue->stopped = 0;
-				efx_wake_queue(efx);
-			}
-			netif_tx_unlock(efx->net_dev);
+	/* Check whether the hardware queue is now empty */
+	if ((int)(tx_queue->read_count - tx_queue->old_write_count) >= 0) {
+		tx_queue->old_write_count = ACCESS_ONCE(tx_queue->write_count);
+		if (tx_queue->read_count == tx_queue->old_write_count) {
+			smp_mb();
+			tx_queue->empty_read_count =
+				tx_queue->read_count | EFX_EMPTY_COUNT_VALID;
 		}
 	}
 }
@@ -431,21 +403,28 @@ void efx_xmit_done(struct efx_tx_queue *
 int efx_probe_tx_queue(struct efx_tx_queue *tx_queue)
 {
 	struct efx_nic *efx = tx_queue->efx;
-	unsigned int txq_size;
+	unsigned int entries;
 	int i, rc;
 
-	EFX_LOG(efx, "creating TX queue %d\n", tx_queue->queue);
+	/* Create the smallest power-of-two aligned ring */
+	entries = max(roundup_pow_of_two(efx->txq_entries), EFX_MIN_DMAQ_SIZE);
+	EFX_BUG_ON_PARANOID(entries > EFX_MAX_DMAQ_SIZE);
+	tx_queue->ptr_mask = entries - 1;
+
+	netif_dbg(efx, probe, efx->net_dev,
+		  "creating TX queue %d size 0x%x mask 0x%x\n",
+		  tx_queue->queue, efx->txq_entries, tx_queue->ptr_mask);
 
 	/* Allocate software ring */
-	txq_size = (efx->type->txd_ring_mask + 1) * sizeof(*tx_queue->buffer);
-	tx_queue->buffer = kzalloc(txq_size, GFP_KERNEL);
+	tx_queue->buffer = kzalloc(entries * sizeof(*tx_queue->buffer),
+				   GFP_KERNEL);
 	if (!tx_queue->buffer)
 		return -ENOMEM;
-	for (i = 0; i <= efx->type->txd_ring_mask; ++i)
+	for (i = 0; i <= tx_queue->ptr_mask; ++i)
 		tx_queue->buffer[i].continuation = true;
 
 	/* Allocate hardware ring */
-	rc = falcon_probe_tx(tx_queue);
+	rc = efx_nic_probe_tx(tx_queue);
 	if (rc)
 		goto fail;
 
@@ -459,16 +438,18 @@ int efx_probe_tx_queue(struct efx_tx_que
 
 void efx_init_tx_queue(struct efx_tx_queue *tx_queue)
 {
-	EFX_LOG(tx_queue->efx, "initialising TX queue %d\n", tx_queue->queue);
+	netif_dbg(tx_queue->efx, drv, tx_queue->efx->net_dev,
+		  "initialising TX queue %d\n", tx_queue->queue);
 
 	tx_queue->insert_count = 0;
 	tx_queue->write_count = 0;
+	tx_queue->old_write_count = 0;
 	tx_queue->read_count = 0;
 	tx_queue->old_read_count = 0;
-	BUG_ON(tx_queue->stopped);
+	tx_queue->empty_read_count = 0 | EFX_EMPTY_COUNT_VALID;
 
 	/* Set up TX descriptor ring */
-	falcon_init_tx(tx_queue);
+	efx_nic_init_tx(tx_queue);
 }
 
 void efx_release_tx_buffers(struct efx_tx_queue *tx_queue)
@@ -480,8 +461,7 @@ void efx_release_tx_buffers(struct efx_t
 
 	/* Free any buffers left in the ring */
 	while (tx_queue->read_count != tx_queue->write_count) {
-		buffer = &tx_queue->buffer[tx_queue->read_count &
-					   tx_queue->efx->type->txd_ring_mask];
+		buffer = &tx_queue->buffer[tx_queue->read_count & tx_queue->ptr_mask];
 		efx_dequeue_buffer(tx_queue, buffer);
 		buffer->continuation = true;
 		buffer->len = 0;
@@ -492,27 +472,23 @@ void efx_release_tx_buffers(struct efx_t
 
 void efx_fini_tx_queue(struct efx_tx_queue *tx_queue)
 {
-	EFX_LOG(tx_queue->efx, "shutting down TX queue %d\n", tx_queue->queue);
+	netif_dbg(tx_queue->efx, drv, tx_queue->efx->net_dev,
+		  "shutting down TX queue %d\n", tx_queue->queue);
 
 	/* Flush TX queue, remove descriptor ring */
-	falcon_fini_tx(tx_queue);
+	efx_nic_fini_tx(tx_queue);
 
 	efx_release_tx_buffers(tx_queue);
 
 	/* Free up TSO header cache */
 	efx_fini_tso(tx_queue);
-
-	/* Release queue's stop on port, if any */
-	if (tx_queue->stopped) {
-		tx_queue->stopped = 0;
-		efx_wake_queue(tx_queue->efx);
-	}
 }
 
 void efx_remove_tx_queue(struct efx_tx_queue *tx_queue)
 {
-	EFX_LOG(tx_queue->efx, "destroying TX queue %d\n", tx_queue->queue);
-	falcon_remove_tx(tx_queue);
+	netif_dbg(tx_queue->efx, drv, tx_queue->efx->net_dev,
+		  "destroying TX queue %d\n", tx_queue->queue);
+	efx_nic_remove_tx(tx_queue);
 
 	kfree(tx_queue->buffer);
 	tx_queue->buffer = NULL;
@@ -551,6 +527,7 @@ void efx_remove_tx_queue(struct efx_tx_q
 #define ETH_HDR_LEN(skb)  (skb_network_header(skb) - (skb)->data)
 #define SKB_TCP_OFF(skb)  PTR_DIFF(tcp_hdr(skb), (skb)->data)
 #define SKB_IPV4_OFF(skb) PTR_DIFF(ip_hdr(skb), (skb)->data)
+#define SKB_IPV6_OFF(skb) PTR_DIFF(ipv6_hdr(skb), (skb)->data)
 
 /**
  * struct tso_state - TSO state for an SKB
@@ -563,6 +540,7 @@ void efx_remove_tx_queue(struct efx_tx_q
  * @unmap_len: Length of SKB fragment
  * @unmap_addr: DMA address of SKB fragment
  * @unmap_single: DMA single vs page mapping flag
+ * @protocol: Network protocol (after any VLAN header)
  * @header_len: Number of bytes of header
  * @full_packet_size: Number of bytes to put in each outgoing segment
  *
@@ -583,21 +561,38 @@ struct tso_state {
 	dma_addr_t unmap_addr;
 	bool unmap_single;
 
+	__be16 protocol;
 	unsigned header_len;
 	int full_packet_size;
 };
 
 
+static inline void prefetch_ptr(struct efx_tx_queue *tx_queue)
+{
+	unsigned insert_ptr = tx_queue->insert_count & tx_queue->ptr_mask;
+	char *ptr;
+
+	ptr = (char *) (tx_queue->buffer + insert_ptr);
+	prefetch(ptr);
+	prefetch(ptr + 0x80);
+
+	ptr = (char *) (((efx_qword_t *)tx_queue->txd.addr) + insert_ptr);
+	prefetch(ptr);
+	prefetch(ptr + 0x80);
+}
+
 /*
  * Verify that our various assumptions about sk_buffs and the conditions
- * under which TSO will be attempted hold true.
+ * under which TSO will be attempted hold true.  Return the protocol number.
  */
-static void efx_tso_check_safe(struct sk_buff *skb)
+static __be16 efx_tso_check_protocol(struct sk_buff *skb)
 {
 	__be16 protocol = skb->protocol;
 
 	EFX_BUG_ON_PARANOID(((struct ethhdr *)skb->data)->h_proto !=
 			    protocol);
+#if !defined(EFX_USE_KCOMPAT) || defined(EFX_USE_NETDEV_VLAN_FEATURES) || \
+	defined(NETIF_F_VLAN_TSO)
 	if (protocol == htons(ETH_P_8021Q)) {
 		/* Find the encapsulated protocol; reset network header
 		 * and transport header based on that. */
@@ -607,13 +602,23 @@ static void efx_tso_check_safe(struct sk
 		if (protocol == htons(ETH_P_IP))
 			skb_set_transport_header(skb, sizeof(*veh) +
 						 4 * ip_hdr(skb)->ihl);
+		else if (protocol == htons(ETH_P_IPV6))
+			skb_set_transport_header(skb, sizeof(*veh) +
+						 sizeof(struct ipv6hdr));
 	}
+#endif
 
-	EFX_BUG_ON_PARANOID(protocol != htons(ETH_P_IP));
-	EFX_BUG_ON_PARANOID(ip_hdr(skb)->protocol != IPPROTO_TCP);
+	if (protocol == htons(ETH_P_IP)) {
+		EFX_BUG_ON_PARANOID(ip_hdr(skb)->protocol != IPPROTO_TCP);
+	} else {
+		EFX_BUG_ON_PARANOID(protocol != htons(ETH_P_IPV6));
+		EFX_BUG_ON_PARANOID(ipv6_hdr(skb)->nexthdr != NEXTHDR_TCP);
+	}
 	EFX_BUG_ON_PARANOID((PTR_DIFF(tcp_hdr(skb), skb->data)
 			     + (tcp_hdr(skb)->doff << 2u)) >
 			    skb_headlen(skb));
+
+	return protocol;
 }
 
 
@@ -631,8 +636,8 @@ static int efx_tsoh_block_alloc(struct e
 
 	base_kva = pci_alloc_consistent(pci_dev, PAGE_SIZE, &dma_addr);
 	if (base_kva == NULL) {
-		EFX_ERR(tx_queue->efx, "Unable to allocate page for TSO"
-			" headers\n");
+		netif_err(tx_queue->efx, tx_err, tx_queue->efx->net_dev,
+			  "Unable to allocate page for TSO headers\n");
 		return -ENOMEM;
 	}
 
@@ -720,14 +725,14 @@ static int efx_tx_queue_insert(struct ef
 {
 	struct efx_tx_buffer *buffer;
 	struct efx_nic *efx = tx_queue->efx;
-	unsigned dma_len, fill_level, insert_ptr, misalign;
+	unsigned dma_len, fill_level, insert_ptr;
 	int q_space;
 
 	EFX_BUG_ON_PARANOID(len <= 0);
 
 	fill_level = tx_queue->insert_count - tx_queue->old_read_count;
 	/* -1 as there is no way to represent all descriptors used */
-	q_space = efx->type->txd_ring_mask - 1 - fill_level;
+	q_space = efx->txq_entries - 1 - fill_level;
 
 	while (1) {
 		if (unlikely(q_space-- <= 0)) {
@@ -735,30 +740,30 @@ static int efx_tx_queue_insert(struct ef
 			 * since the xmit path last checked.  Update
 			 * the xmit path's copy of read_count.
 			 */
-			++tx_queue->stopped;
+			netif_tx_stop_queue(tx_queue->core_txq);
 			/* This memory barrier protects the change of
-			 * stopped from the access of read_count. */
+			 * queue state from the access of read_count. */
 			smp_mb();
 			tx_queue->old_read_count =
-				*(volatile unsigned *)&tx_queue->read_count;
+				ACCESS_ONCE(tx_queue->read_count);
 			fill_level = (tx_queue->insert_count
 				      - tx_queue->old_read_count);
-			q_space = efx->type->txd_ring_mask - 1 - fill_level;
+			q_space = efx->txq_entries - 1 - fill_level;
 			if (unlikely(q_space-- <= 0)) {
 				*final_buffer = NULL;
 				return 1;
 			}
 			smp_mb();
-			--tx_queue->stopped;
+			netif_tx_start_queue(tx_queue->core_txq);
 		}
 
-		insert_ptr = tx_queue->insert_count & efx->type->txd_ring_mask;
+		insert_ptr = tx_queue->insert_count & tx_queue->ptr_mask;
 		buffer = &tx_queue->buffer[insert_ptr];
 		++tx_queue->insert_count;
 
 		EFX_BUG_ON_PARANOID(tx_queue->insert_count -
-				    tx_queue->read_count >
-				    efx->type->txd_ring_mask);
+				    tx_queue->read_count >=
+				    efx->txq_entries);
 
 		efx_tsoh_free(tx_queue, buffer);
 		EFX_BUG_ON_PARANOID(buffer->len);
@@ -769,12 +774,7 @@ static int efx_tx_queue_insert(struct ef
 
 		buffer->dma_addr = dma_addr;
 
-		/* Ensure we do not cross a boundary unsupported by H/W */
-		dma_len = (~dma_addr & efx->type->tx_dma_mask) + 1;
-
-		misalign = (unsigned)dma_addr & efx->type->bug5391_mask;
-		if (misalign && dma_len + misalign > 512)
-			dma_len = 512 - misalign;
+		dma_len = efx_max_tx_len(efx, dma_addr);
 
 		/* If there is enough space to send then do so */
 		if (dma_len >= len)
@@ -804,8 +804,7 @@ static void efx_tso_put_header(struct ef
 {
 	struct efx_tx_buffer *buffer;
 
-	buffer = &tx_queue->buffer[tx_queue->insert_count &
-				   tx_queue->efx->type->txd_ring_mask];
+	buffer = &tx_queue->buffer[tx_queue->insert_count & tx_queue->ptr_mask];
 	efx_tsoh_free(tx_queue, buffer);
 	EFX_BUG_ON_PARANOID(buffer->len);
 	EFX_BUG_ON_PARANOID(buffer->unmap_len);
@@ -830,7 +829,7 @@ static void efx_enqueue_unwind(struct ef
 	while (tx_queue->insert_count != tx_queue->write_count) {
 		--tx_queue->insert_count;
 		buffer = &tx_queue->buffer[tx_queue->insert_count &
-					   tx_queue->efx->type->txd_ring_mask];
+					   tx_queue->ptr_mask];
 		efx_tsoh_free(tx_queue, buffer);
 		EFX_BUG_ON_PARANOID(buffer->skb);
 		if (buffer->unmap_len) {
@@ -862,7 +861,10 @@ static void tso_start(struct tso_state *
 			  + PTR_DIFF(tcp_hdr(skb), skb->data));
 	st->full_packet_size = st->header_len + skb_shinfo(skb)->gso_size;
 
-	st->ipv4_id = ntohs(ip_hdr(skb)->id);
+	if (st->protocol == htons(ETH_P_IP))
+		st->ipv4_id = ntohs(ip_hdr(skb)->id);
+	else
+		st->ipv4_id = 0;
 	st->seqnum = ntohl(tcp_hdr(skb)->seq);
 
 	EFX_BUG_ON_PARANOID(tcp_hdr(skb)->urg);
@@ -878,10 +880,9 @@ static void tso_start(struct tso_state *
 static int tso_get_fragment(struct tso_state *st, struct efx_nic *efx,
 			    skb_frag_t *frag)
 {
-	st->unmap_addr = pci_map_page(efx->pci_dev, frag->page,
-				      frag->page_offset, frag->size,
-				      PCI_DMA_TODEVICE);
-	if (likely(!pci_dma_mapping_error(efx->pci_dev, st->unmap_addr))) {
+	st->unmap_addr = skb_frag_dma_map(&efx->pci_dev->dev, frag, 0,
+					  frag->size, DMA_TO_DEVICE);
+	if (likely(!dma_mapping_error(&efx->pci_dev->dev, st->unmap_addr))) {
 		st->unmap_single = false;
 		st->unmap_len = frag->size;
 		st->in_len = frag->size;
@@ -977,7 +978,6 @@ static int tso_start_new_packet(struct e
 				struct tso_state *st)
 {
 	struct efx_tso_header *tsoh;
-	struct iphdr *tsoh_iph;
 	struct tcphdr *tsoh_th;
 	unsigned ip_length;
 	u8 *header;
@@ -1001,7 +1001,6 @@ static int tso_start_new_packet(struct e
 
 	header = TSOH_BUFFER(tsoh);
 	tsoh_th = (struct tcphdr *)(header + SKB_TCP_OFF(skb));
-	tsoh_iph = (struct iphdr *)(header + SKB_IPV4_OFF(skb));
 
 	/* Copy and update the headers. */
 	memcpy(header, skb->data, st->header_len);
@@ -1019,11 +1018,22 @@ static int tso_start_new_packet(struct e
 		tsoh_th->fin = tcp_hdr(skb)->fin;
 		tsoh_th->psh = tcp_hdr(skb)->psh;
 	}
-	tsoh_iph->tot_len = htons(ip_length);
 
-	/* Linux leaves suitable gaps in the IP ID space for us to fill. */
-	tsoh_iph->id = htons(st->ipv4_id);
-	st->ipv4_id++;
+	if (st->protocol == htons(ETH_P_IP)) {
+		struct iphdr *tsoh_iph =
+			(struct iphdr *)(header + SKB_IPV4_OFF(skb));
+
+		tsoh_iph->tot_len = htons(ip_length);
+
+		/* Linux leaves suitable gaps in the IP ID space for us to fill. */
+		tsoh_iph->id = htons(st->ipv4_id);
+		st->ipv4_id++;
+	} else {
+		struct ipv6hdr *tsoh_iph =
+			(struct ipv6hdr *)(header + SKB_IPV6_OFF(skb));
+
+		tsoh_iph->payload_len = htons(ip_length - sizeof(*tsoh_iph));
+	}
 
 	st->packet_space = skb_shinfo(skb)->gso_size;
 	++tx_queue->tso_packets;
@@ -1034,7 +1044,6 @@ static int tso_start_new_packet(struct e
 	return 0;
 }
 
-
 /**
  * efx_enqueue_skb_tso - segment and transmit a TSO socket buffer
  * @tx_queue:		Efx TX queue
@@ -1053,8 +1062,10 @@ static int efx_enqueue_skb_tso(struct ef
 	int frag_i, rc, rc2 = NETDEV_TX_OK;
 	struct tso_state state;
 
-	/* Verify TSO is safe - these checks should never fail. */
-	efx_tso_check_safe(skb);
+	prefetch(skb->data);
+
+	/* Find the packet protocol and sanity-check it */
+	state.protocol = efx_tso_check_protocol(skb);
 
 	EFX_BUG_ON_PARANOID(tx_queue->write_count != tx_queue->insert_count);
 
@@ -1081,10 +1092,14 @@ static int efx_enqueue_skb_tso(struct ef
 	if (tso_start_new_packet(tx_queue, skb, &state) < 0)
 		goto mem_err;
 
+	prefetch_ptr(tx_queue);
+
 	while (1) {
 		rc = tso_fill_packet_with_fragment(tx_queue, skb, &state);
-		if (unlikely(rc))
-			goto stop;
+		if (unlikely(rc)) {
+			rc2 = NETDEV_TX_BUSY;
+			goto unwind;
+		}
 
 		/* Move onto the next fragment? */
 		if (state.in_len == 0) {
@@ -1104,22 +1119,15 @@ static int efx_enqueue_skb_tso(struct ef
 	}
 
 	/* Pass off to hardware */
-	falcon_push_buffers(tx_queue);
+	efx_nic_push_buffers(tx_queue);
 
 	tx_queue->tso_bursts++;
 	return NETDEV_TX_OK;
 
  mem_err:
-	EFX_ERR(efx, "Out of memory for TSO headers, or PCI mapping error\n");
-	dev_kfree_skb_any((struct sk_buff *)skb);
-	goto unwind;
-
- stop:
-	rc2 = NETDEV_TX_BUSY;
-
-	/* Stop the queue if it wasn't stopped before. */
-	if (tx_queue->stopped == 1)
-		efx_stop_queue(efx);
+	netif_err(efx, tx_err, efx->net_dev,
+		  "Out of memory for TSO headers, or PCI mapping error\n");
+	dev_kfree_skb_any(skb);
 
  unwind:
 	/* Free the DMA mapping we were in the process of writing out */
@@ -1147,7 +1155,7 @@ static void efx_fini_tso(struct efx_tx_q
 	unsigned i;
 
 	if (tx_queue->buffer) {
-		for (i = 0; i <= tx_queue->efx->type->txd_ring_mask; ++i)
+		for (i = 0; i <= tx_queue->ptr_mask; ++i)
 			efx_tsoh_free(tx_queue, &tx_queue->buffer[i]);
 	}
 
diff -r 9566a4a50a43 drivers/net/sfc/tx.h
--- a/drivers/net/sfc/tx.h
+++ /dev/null
@@ -1,25 +0,0 @@
-/****************************************************************************
- * Driver for Solarflare Solarstorm network controllers and boards
- * Copyright 2006 Fen Systems Ltd.
- * Copyright 2006-2008 Solarflare Communications Inc.
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 as published
- * by the Free Software Foundation, incorporated herein by reference.
- */
-
-#ifndef EFX_TX_H
-#define EFX_TX_H
-
-#include "net_driver.h"
-
-int efx_probe_tx_queue(struct efx_tx_queue *tx_queue);
-void efx_remove_tx_queue(struct efx_tx_queue *tx_queue);
-void efx_init_tx_queue(struct efx_tx_queue *tx_queue);
-void efx_fini_tx_queue(struct efx_tx_queue *tx_queue);
-
-netdev_tx_t efx_hard_start_xmit(struct sk_buff *skb,
-				      struct net_device *net_dev);
-void efx_release_tx_buffers(struct efx_tx_queue *tx_queue);
-
-#endif /* EFX_TX_H */
diff -r 9566a4a50a43 drivers/net/sfc/txc43128_phy.c
--- /dev/null
+++ b/drivers/net/sfc/txc43128_phy.c
@@ -0,0 +1,563 @@
+/****************************************************************************
+ * Driver for Solarflare Solarstorm network controllers and boards
+ * Copyright 2006-2011 Solarflare Communications Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 as published
+ * by the Free Software Foundation, incorporated herein by reference.
+ */
+
+/*
+ * Driver for Transwitch/Mysticom CX4 retimer
+ * see www.transwitch.com, part is TXC-43128
+ */
+
+#include <linux/delay.h>
+#include <linux/slab.h>
+#include "efx.h"
+#include "mdio_10g.h"
+#include "phy.h"
+#include "nic.h"
+
+/* We expect these MMDs to be in the package */
+#define TXC_REQUIRED_DEVS (MDIO_DEVS_PCS |	\
+			   MDIO_DEVS_PMAPMD |	\
+			   MDIO_DEVS_PHYXS)
+
+#define TXC_LOOPBACKS ((1 << LOOPBACK_PCS) |	\
+		       (1 << LOOPBACK_PMAPMD) |	\
+		       (1 << LOOPBACK_PHYXS_WS))
+
+/**************************************************************************
+ *
+ * Compile-time config
+ *
+ **************************************************************************
+ */
+#define TXCNAME "TXC43128"
+/* Total length of time we'll wait for the PHY to come out of reset (ms) */
+#define TXC_MAX_RESET_TIME	500
+/* Interval between checks (ms) */
+#define TXC_RESET_WAIT		10
+/* How long to run BIST (us) */
+#define TXC_BIST_DURATION	50
+
+/**************************************************************************
+ *
+ * Register definitions
+ *
+ **************************************************************************
+ */
+
+/* Command register */
+#define TXC_GLRGS_GLCMD		0xc004
+/* Useful bits in command register */
+/* Lane power-down */
+#define TXC_GLCMD_L01PD_LBN	5
+#define TXC_GLCMD_L23PD_LBN	6
+/* Limited SW reset: preserves configuration but
+ * initiates a logic reset. Self-clearing */
+#define TXC_GLCMD_LMTSWRST_LBN	14
+
+/* Signal Quality Control */
+#define TXC_GLRGS_GSGQLCTL	0xc01a
+/* Enable bit */
+#define TXC_GSGQLCT_SGQLEN_LBN	15
+/* Lane selection */
+#define TXC_GSGQLCT_LNSL_LBN	13
+#define TXC_GSGQLCT_LNSL_WIDTH	2
+
+/* Analog TX control */
+#define TXC_ALRGS_ATXCTL	0xc040
+/* Lane power-down */
+#define TXC_ATXCTL_TXPD3_LBN	15
+#define TXC_ATXCTL_TXPD2_LBN	14
+#define TXC_ATXCTL_TXPD1_LBN	13
+#define TXC_ATXCTL_TXPD0_LBN	12
+
+/* Amplitude on lanes 0, 1 */
+#define TXC_ALRGS_ATXAMP0	0xc041
+/* Amplitude on lanes 2, 3 */
+#define TXC_ALRGS_ATXAMP1	0xc042
+/* Bit position of value for lane 0 (or 2) */
+#define TXC_ATXAMP_LANE02_LBN	3
+/* Bit position of value for lane 1 (or 3) */
+#define TXC_ATXAMP_LANE13_LBN	11
+
+#define TXC_ATXAMP_1280_mV	0
+#define TXC_ATXAMP_1200_mV	8
+#define TXC_ATXAMP_1120_mV	12
+#define TXC_ATXAMP_1060_mV	14
+#define TXC_ATXAMP_0820_mV	25
+#define TXC_ATXAMP_0720_mV	26
+#define TXC_ATXAMP_0580_mV	27
+#define TXC_ATXAMP_0440_mV	28
+
+#define TXC_ATXAMP_0820_BOTH					\
+	((TXC_ATXAMP_0820_mV << TXC_ATXAMP_LANE02_LBN)		\
+	 | (TXC_ATXAMP_0820_mV << TXC_ATXAMP_LANE13_LBN))
+
+#define TXC_ATXAMP_DEFAULT	0x6060 /* From databook */
+
+/* Preemphasis on lanes 0, 1 */
+#define TXC_ALRGS_ATXPRE0	0xc043
+/* Preemphasis on lanes 2, 3 */
+#define TXC_ALRGS_ATXPRE1	0xc044
+
+#define TXC_ATXPRE_NONE 0
+#define TXC_ATXPRE_DEFAULT	0x1010 /* From databook */
+
+#define TXC_ALRGS_ARXCTL	0xc045
+/* Lane power-down */
+#define TXC_ARXCTL_RXPD3_LBN	15
+#define TXC_ARXCTL_RXPD2_LBN	14
+#define TXC_ARXCTL_RXPD1_LBN	13
+#define TXC_ARXCTL_RXPD0_LBN	12
+
+/* Main control */
+#define TXC_MRGS_CTL		0xc340
+/* Bits in main control */
+#define TXC_MCTL_RESET_LBN	15	/* Self clear */
+#define TXC_MCTL_TXLED_LBN	14	/* 1 to show align status */
+#define TXC_MCTL_RXLED_LBN	13	/* 1 to show align status */
+
+/* GPIO output */
+#define TXC_GPIO_OUTPUT		0xc346
+#define TXC_GPIO_DIR		0xc348
+
+/* Vendor-specific BIST registers */
+#define TXC_BIST_CTL		0xc280
+#define TXC_BIST_TXFRMCNT	0xc281
+#define TXC_BIST_RX0FRMCNT	0xc282
+#define TXC_BIST_RX1FRMCNT	0xc283
+#define TXC_BIST_RX2FRMCNT	0xc284
+#define TXC_BIST_RX3FRMCNT	0xc285
+#define TXC_BIST_RX0ERRCNT	0xc286
+#define TXC_BIST_RX1ERRCNT	0xc287
+#define TXC_BIST_RX2ERRCNT	0xc288
+#define TXC_BIST_RX3ERRCNT	0xc289
+
+/* BIST type (controls bit patter in test) */
+#define TXC_BIST_CTRL_TYPE_LBN	10
+#define TXC_BIST_CTRL_TYPE_TSD	0	/* TranSwitch Deterministic */
+#define TXC_BIST_CTRL_TYPE_CRP	1	/* CRPAT standard */
+#define TXC_BIST_CTRL_TYPE_CJP	2	/* CJPAT standard */
+#define TXC_BIST_CTRL_TYPE_TSR	3	/* TranSwitch pseudo-random */
+/* Set this to 1 for 10 bit and 0 for 8 bit */
+#define TXC_BIST_CTRL_B10EN_LBN	12
+/* Enable BIST (write 0 to disable) */
+#define TXC_BIST_CTRL_ENAB_LBN	13
+/* Stop BIST (self-clears when stop complete) */
+#define TXC_BIST_CTRL_STOP_LBN	14
+/* Start BIST (cleared by writing 1 to STOP) */
+#define TXC_BIST_CTRL_STRT_LBN	15
+
+/* Mt. Diablo test configuration */
+#define TXC_MTDIABLO_CTRL	0xc34f
+#define TXC_MTDIABLO_CTRL_PMA_LOOP_LBN	10
+
+struct txc43128_data {
+	unsigned long bug10934_timer;
+	enum efx_phy_mode phy_mode;
+	enum efx_loopback_mode loopback_mode;
+};
+
+/* The PHY sometimes needs a reset to bring the link back up.  So long as
+ * it reports link down, we reset it every 5 seconds.
+ */
+#define BUG10934_RESET_INTERVAL (5 * HZ)
+
+/* Perform a reset that doesn't clear configuration changes */
+static void txc_reset_logic(struct efx_nic *efx);
+
+/* Set the output value of a gpio */
+void falcon_txc_set_gpio_val(struct efx_nic *efx, int pin, int on)
+{
+	efx_mdio_set_flag(efx, MDIO_MMD_PHYXS, TXC_GPIO_OUTPUT, 1 << pin, on);
+}
+
+/* Set up the GPIO direction register */
+void falcon_txc_set_gpio_dir(struct efx_nic *efx, int pin, int dir)
+{
+	efx_mdio_set_flag(efx, MDIO_MMD_PHYXS, TXC_GPIO_DIR, 1 << pin, dir);
+}
+
+/* Reset the PMA/PMD MMD. The documentation is explicit that this does a
+ * global reset (it's less clear what reset of other MMDs does).*/
+static int txc_reset_phy(struct efx_nic *efx)
+{
+	int rc = efx_mdio_reset_mmd(efx, MDIO_MMD_PMAPMD,
+				    TXC_MAX_RESET_TIME / TXC_RESET_WAIT,
+				    TXC_RESET_WAIT);
+	if (rc < 0)
+		goto fail;
+
+	/* Check that all the MMDs we expect are present and responding. */
+	rc = efx_mdio_check_mmds(efx, TXC_REQUIRED_DEVS);
+	if (rc < 0)
+		goto fail;
+
+	return 0;
+
+fail:
+	netif_err(efx, hw, efx->net_dev, TXCNAME ": reset timed out!\n");
+	return rc;
+}
+
+/* Run a single BIST on one MMD */
+static int txc_bist_one(struct efx_nic *efx, int mmd, int test)
+{
+	int ctrl, bctl;
+	int lane;
+	int rc = 0;
+
+	/* Set PMA to test into loopback using Mt Diablo reg as per app note */
+	ctrl = efx_mdio_read(efx, MDIO_MMD_PCS, TXC_MTDIABLO_CTRL);
+	ctrl |= (1 << TXC_MTDIABLO_CTRL_PMA_LOOP_LBN);
+	efx_mdio_write(efx, MDIO_MMD_PCS, TXC_MTDIABLO_CTRL, ctrl);
+
+	/* The BIST app. note lists these  as 3 distinct steps. */
+	/* Set the BIST type */
+	bctl = (test << TXC_BIST_CTRL_TYPE_LBN);
+	efx_mdio_write(efx, mmd, TXC_BIST_CTL, bctl);
+
+	/* Set the BSTEN bit in the BIST Control register to enable */
+	bctl |= (1 << TXC_BIST_CTRL_ENAB_LBN);
+	efx_mdio_write(efx, mmd, TXC_BIST_CTL, bctl);
+
+	/* Set the BSTRT bit in the BIST Control register */
+	efx_mdio_write(efx, mmd, TXC_BIST_CTL,
+		       bctl | (1 << TXC_BIST_CTRL_STRT_LBN));
+
+	/* Wait. */
+	udelay(TXC_BIST_DURATION);
+
+	/* Set the BSTOP bit in the BIST Control register */
+	bctl |= (1 << TXC_BIST_CTRL_STOP_LBN);
+	efx_mdio_write(efx, mmd, TXC_BIST_CTL, bctl);
+
+	/* The STOP bit should go off when things have stopped */
+	while (bctl & (1 << TXC_BIST_CTRL_STOP_LBN))
+		bctl = efx_mdio_read(efx, mmd, TXC_BIST_CTL);
+
+	/* Check all the error counts are 0 and all the frame counts are
+	   non-zero */
+	for (lane = 0; lane < 4; lane++) {
+		int count = efx_mdio_read(efx, mmd, TXC_BIST_RX0ERRCNT + lane);
+		if (count != 0) {
+			netif_err(efx, hw, efx->net_dev, TXCNAME": BIST error. "
+				  "Lane %d had %d errs\n", lane, count);
+			rc = -EIO;
+		}
+		count = efx_mdio_read(efx, mmd, TXC_BIST_RX0FRMCNT + lane);
+		if (count == 0) {
+			netif_err(efx, hw, efx->net_dev, TXCNAME": BIST error. "
+				  "Lane %d got 0 frames\n", lane);
+			rc = -EIO;
+		}
+	}
+
+	if (rc == 0)
+		netif_info(efx, hw, efx->net_dev, TXCNAME": BIST pass\n");
+
+	/* Disable BIST */
+	efx_mdio_write(efx, mmd, TXC_BIST_CTL, 0);
+
+	/* Turn off loopback */
+	ctrl &= ~(1 << TXC_MTDIABLO_CTRL_PMA_LOOP_LBN);
+	efx_mdio_write(efx, MDIO_MMD_PCS, TXC_MTDIABLO_CTRL, ctrl);
+
+	return rc;
+}
+
+static int txc_bist(struct efx_nic *efx)
+{
+	return txc_bist_one(efx, MDIO_MMD_PCS, TXC_BIST_CTRL_TYPE_TSD);
+}
+
+/* Push the non-configurable defaults into the PHY. This must be
+ * done after every full reset */
+static void txc_apply_defaults(struct efx_nic *efx)
+{
+	int mctrl;
+
+	/* Turn amplitude down and preemphasis off on the host side
+	 * (PHY<->MAC) as this is believed less likely to upset Falcon
+	 * and no adverse effects have been noted. It probably also
+	 * saves a picowatt or two */
+
+	/* Turn off preemphasis */
+	efx_mdio_write(efx, MDIO_MMD_PHYXS, TXC_ALRGS_ATXPRE0, TXC_ATXPRE_NONE);
+	efx_mdio_write(efx, MDIO_MMD_PHYXS, TXC_ALRGS_ATXPRE1, TXC_ATXPRE_NONE);
+
+	/* Turn down the amplitude */
+	efx_mdio_write(efx, MDIO_MMD_PHYXS,
+		       TXC_ALRGS_ATXAMP0, TXC_ATXAMP_0820_BOTH);
+	efx_mdio_write(efx, MDIO_MMD_PHYXS,
+		       TXC_ALRGS_ATXAMP1, TXC_ATXAMP_0820_BOTH);
+
+	/* Set the line side amplitude and preemphasis to the databook
+	 * defaults as an erratum causes them to be 0 on at least some
+	 * PHY rev.s */
+	efx_mdio_write(efx, MDIO_MMD_PMAPMD,
+		       TXC_ALRGS_ATXPRE0, TXC_ATXPRE_DEFAULT);
+	efx_mdio_write(efx, MDIO_MMD_PMAPMD,
+		       TXC_ALRGS_ATXPRE1, TXC_ATXPRE_DEFAULT);
+	efx_mdio_write(efx, MDIO_MMD_PMAPMD,
+		       TXC_ALRGS_ATXAMP0, TXC_ATXAMP_DEFAULT);
+	efx_mdio_write(efx, MDIO_MMD_PMAPMD,
+		       TXC_ALRGS_ATXAMP1, TXC_ATXAMP_DEFAULT);
+
+	/* Set up the LEDs  */
+	mctrl = efx_mdio_read(efx, MDIO_MMD_PHYXS, TXC_MRGS_CTL);
+
+	/* Set the Green and Red LEDs to their default modes */
+	mctrl &= ~((1 << TXC_MCTL_TXLED_LBN) | (1 << TXC_MCTL_RXLED_LBN));
+	efx_mdio_write(efx, MDIO_MMD_PHYXS, TXC_MRGS_CTL, mctrl);
+
+	/* Databook recommends doing this after configuration changes */
+	txc_reset_logic(efx);
+
+	falcon_board(efx)->type->init_phy(efx);
+}
+
+static int txc43128_phy_probe(struct efx_nic *efx)
+{
+	struct txc43128_data *phy_data;
+
+	/* Allocate phy private storage */
+	phy_data = kzalloc(sizeof(*phy_data), GFP_KERNEL);
+	if (!phy_data)
+		return -ENOMEM;
+	efx->phy_data = phy_data;
+	phy_data->phy_mode = efx->phy_mode;
+
+	efx->mdio.mmds = TXC_REQUIRED_DEVS;
+	efx->mdio.mode_support = MDIO_SUPPORTS_C45 | MDIO_EMULATE_C22;
+
+	efx->loopback_modes = TXC_LOOPBACKS | FALCON_XMAC_LOOPBACKS;
+	efx->startup_loopback_mode = LOOPBACK_PMAPMD;
+
+	strlcpy(efx->phy_name, "Mysticom CX4", sizeof(efx->phy_name));
+
+	return 0;
+}
+
+/* Initialisation entry point for this PHY driver */
+static int txc43128_phy_init(struct efx_nic *efx)
+{
+	int rc;
+
+	rc = txc_reset_phy(efx);
+	if (rc < 0)
+		return rc;
+
+	rc = txc_bist(efx);
+	if (rc < 0)
+		return rc;
+
+	txc_apply_defaults(efx);
+
+	return 0;
+}
+
+/* Set the lane power down state in the global registers */
+static void txc_glrgs_lane_power(struct efx_nic *efx, int mmd)
+{
+	int pd = (1 << TXC_GLCMD_L01PD_LBN) | (1 << TXC_GLCMD_L23PD_LBN);
+	int ctl = efx_mdio_read(efx, mmd, TXC_GLRGS_GLCMD);
+
+	if (!(efx->phy_mode & PHY_MODE_LOW_POWER))
+		ctl &= ~pd;
+	else
+		ctl |= pd;
+
+	efx_mdio_write(efx, mmd, TXC_GLRGS_GLCMD, ctl);
+}
+
+/* Set the lane power down state in the analog control registers */
+static void txc_analog_lane_power(struct efx_nic *efx, int mmd)
+{
+	int txpd = (1 << TXC_ATXCTL_TXPD3_LBN) | (1 << TXC_ATXCTL_TXPD2_LBN)
+		| (1 << TXC_ATXCTL_TXPD1_LBN) | (1 << TXC_ATXCTL_TXPD0_LBN);
+	int rxpd = (1 << TXC_ARXCTL_RXPD3_LBN) | (1 << TXC_ARXCTL_RXPD2_LBN)
+		| (1 << TXC_ARXCTL_RXPD1_LBN) | (1 << TXC_ARXCTL_RXPD0_LBN);
+	int txctl = efx_mdio_read(efx, mmd, TXC_ALRGS_ATXCTL);
+	int rxctl = efx_mdio_read(efx, mmd, TXC_ALRGS_ARXCTL);
+
+	if (!(efx->phy_mode & PHY_MODE_LOW_POWER)) {
+		txctl &= ~txpd;
+		rxctl &= ~rxpd;
+	} else {
+		txctl |= txpd;
+		rxctl |= rxpd;
+	}
+
+	efx_mdio_write(efx, mmd, TXC_ALRGS_ATXCTL, txctl);
+	efx_mdio_write(efx, mmd, TXC_ALRGS_ARXCTL, rxctl);
+}
+
+static void txc_set_power(struct efx_nic *efx)
+{
+	/* According to the data book, all the MMDs can do low power */
+	efx_mdio_set_mmds_lpower(efx,
+				 !!(efx->phy_mode & PHY_MODE_LOW_POWER),
+				 TXC_REQUIRED_DEVS);
+
+	/* Global register bank is in PCS, PHY XS. These control the host
+	 * side and line side settings respectively. */
+	txc_glrgs_lane_power(efx, MDIO_MMD_PCS);
+	txc_glrgs_lane_power(efx, MDIO_MMD_PHYXS);
+
+	/* Analog register bank in PMA/PMD, PHY XS */
+	txc_analog_lane_power(efx, MDIO_MMD_PMAPMD);
+	txc_analog_lane_power(efx, MDIO_MMD_PHYXS);
+}
+
+static void txc_reset_logic_mmd(struct efx_nic *efx, int mmd)
+{
+	int val = efx_mdio_read(efx, mmd, TXC_GLRGS_GLCMD);
+	int tries = 50;
+
+	val |= (1 << TXC_GLCMD_LMTSWRST_LBN);
+	efx_mdio_write(efx, mmd, TXC_GLRGS_GLCMD, val);
+	while (tries--) {
+		val = efx_mdio_read(efx, mmd, TXC_GLRGS_GLCMD);
+		if (!(val & (1 << TXC_GLCMD_LMTSWRST_LBN)))
+			break;
+		udelay(1);
+	}
+	if (!tries)
+		netif_info(efx, hw, efx->net_dev,
+			   TXCNAME " Logic reset timed out!\n");
+}
+
+/* Perform a logic reset. This preserves the configuration registers
+ * and is needed for some configuration changes to take effect */
+static void txc_reset_logic(struct efx_nic *efx)
+{
+	/* The data sheet claims we can do the logic reset on either the
+	 * PCS or the PHYXS and the result is a reset of both host- and
+	 * line-side logic. */
+	txc_reset_logic_mmd(efx, MDIO_MMD_PCS);
+}
+
+static bool txc43128_phy_read_link(struct efx_nic *efx)
+{
+	return efx_mdio_links_ok(efx, TXC_REQUIRED_DEVS);
+}
+
+static int txc43128_phy_reconfigure(struct efx_nic *efx)
+{
+	struct txc43128_data *phy_data = efx->phy_data;
+	enum efx_phy_mode mode_change = efx->phy_mode ^ phy_data->phy_mode;
+	bool loop_change = LOOPBACK_CHANGED(phy_data, efx, TXC_LOOPBACKS);
+
+	if (efx->phy_mode & mode_change & PHY_MODE_TX_DISABLED) {
+		txc_reset_phy(efx);
+		txc_apply_defaults(efx);
+		falcon_reset_xaui(efx);
+		mode_change &= ~PHY_MODE_TX_DISABLED;
+	}
+
+	efx_mdio_transmit_disable(efx);
+	efx_mdio_phy_reconfigure(efx);
+	if (mode_change & PHY_MODE_LOW_POWER)
+		txc_set_power(efx);
+
+	/* The data sheet claims this is required after every reconfiguration
+	 * (note at end of 7.1), but we mustn't do it when nothing changes as
+	 * it glitches the link, and reconfigure gets called on link change,
+	 * so we get an IRQ storm on link up. */
+	if (loop_change || mode_change)
+		txc_reset_logic(efx);
+
+	phy_data->phy_mode = efx->phy_mode;
+	phy_data->loopback_mode = efx->loopback_mode;
+
+	return 0;
+}
+
+static void txc43128_phy_fini(struct efx_nic *efx)
+{
+	/* Disable link events */
+	efx_mdio_write(efx, MDIO_MMD_PMAPMD, MDIO_PMA_LASI_CTRL, 0);
+}
+
+static void txc43128_phy_remove(struct efx_nic *efx)
+{
+	kfree(efx->phy_data);
+	efx->phy_data = NULL;
+}
+
+/* Periodic callback: this exists mainly to poll link status as we
+ * don't use LASI interrupts */
+static bool txc43128_phy_poll(struct efx_nic *efx)
+{
+	struct txc43128_data *data = efx->phy_data;
+	bool was_up = efx->link_state.up;
+
+	efx->link_state.up = txc43128_phy_read_link(efx);
+	efx->link_state.speed = 10000;
+	efx->link_state.fd = true;
+	efx->link_state.fc = efx->wanted_fc;
+
+	if (efx->link_state.up || (efx->loopback_mode != LOOPBACK_NONE)) {
+		data->bug10934_timer = jiffies;
+	} else {
+		if (time_after_eq(jiffies, (data->bug10934_timer +
+					    BUG10934_RESET_INTERVAL))) {
+			data->bug10934_timer = jiffies;
+			txc_reset_logic(efx);
+		}
+	}
+
+	return efx->link_state.up != was_up;
+}
+
+static const char *txc43128_test_names[] = {
+	"bist"
+};
+
+static const char *txc43128_test_name(struct efx_nic *efx, unsigned int index)
+{
+	if (index < ARRAY_SIZE(txc43128_test_names))
+		return txc43128_test_names[index];
+	return NULL;
+}
+
+static int txc43128_run_tests(struct efx_nic *efx, int *results, unsigned flags)
+{
+	int rc;
+
+	if (!(flags & ETH_TEST_FL_OFFLINE))
+		return 0;
+
+	rc = txc_reset_phy(efx);
+	if (rc < 0)
+		return rc;
+
+	rc = txc_bist(efx);
+	txc_apply_defaults(efx);
+	results[0] = rc ? -1 : 1;
+	return rc;
+}
+
+static void txc43128_get_settings(struct efx_nic *efx, struct ethtool_cmd *ecmd)
+{
+	mdio45_ethtool_gset(&efx->mdio, ecmd);
+}
+
+const struct efx_phy_operations falcon_txc_phy_ops = {
+	.probe		= txc43128_phy_probe,
+	.init		= txc43128_phy_init,
+	.reconfigure	= txc43128_phy_reconfigure,
+	.poll		= txc43128_phy_poll,
+	.fini		= txc43128_phy_fini,
+	.remove		= txc43128_phy_remove,
+	.get_settings	= txc43128_get_settings,
+	.set_settings	= efx_mdio_set_settings,
+	.test_alive	= efx_mdio_test_alive,
+	.run_tests	= txc43128_run_tests,
+	.test_name	= txc43128_test_name,
+};
diff -r 9566a4a50a43 drivers/net/sfc/vfdi.h
--- /dev/null
+++ b/drivers/net/sfc/vfdi.h
@@ -0,0 +1,250 @@
+/****************************************************************************
+ * Driver for Solarflare Solarstorm network controllers and boards
+ * Copyright 2010-2012 Solarflare Communications Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 as published
+ * by the Free Software Foundation, incorporated herein by reference.
+ */
+#ifndef _VFDI_H
+#define _VFDI_H
+
+/**
+ * DOC: Virtual Function Driver Interface
+ *
+ * This file contains software structures used to form a two way
+ * communication channel between the VF driver and the PF driver,
+ * named Virtual Function Driver Interface (VFDI).
+ *
+ * For the purposes of VFDI, a page is a memory region with size and
+ * alignment of 4K.  All addresses are DMA addresses to be used within
+ * the domain of the relevant VF.
+ *
+ * The only hardware-defined channels for a VF driver to communicate
+ * with the PF driver are the event mailboxes (%FR_CZ_USR_EV
+ * registers).  Writing to these registers generates an event with
+ * EV_CODE = EV_CODE_USR_EV, USER_QID set to the index of the mailbox
+ * and USER_EV_REG_VALUE set to the value written.  The PF driver may
+ * direct or disable delivery of these events by setting
+ * %FR_CZ_USR_EV_CFG.
+ *
+ * The PF driver can send arbitrary events to arbitrary event queues.
+ * However, for consistency, VFDI events from the PF are defined to
+ * follow the same form and be sent to the first event queue assigned
+ * to the VF while that queue is enabled by the VF driver.
+ *
+ * The general form of the variable bits of VFDI events is:
+ *
+ *       0             16                       24   31
+ *      | DATA        | TYPE                   | SEQ   |
+ *
+ * SEQ is a sequence number which should be incremented by 1 (modulo
+ * 256) for each event.  The sequence numbers used in each direction
+ * are independent.
+ *
+ * The VF submits requests of type &struct vfdi_req by sending the
+ * address of the request (ADDR) in a series of 4 events:
+ *
+ *       0             16                       24   31
+ *      | ADDR[0:15]  | VFDI_EV_TYPE_REQ_WORD0 | SEQ   |
+ *      | ADDR[16:31] | VFDI_EV_TYPE_REQ_WORD1 | SEQ+1 |
+ *      | ADDR[32:47] | VFDI_EV_TYPE_REQ_WORD2 | SEQ+2 |
+ *      | ADDR[48:63] | VFDI_EV_TYPE_REQ_WORD3 | SEQ+3 |
+ *
+ * The address must be page-aligned.  After receiving such a valid
+ * series of events, the PF driver will attempt to read the request
+ * and write a response to the same address.  In case of an invalid
+ * sequence of events or a DMA error, there will be no response.
+ *
+ * The VF driver may request that the PF driver writes status
+ * information into its domain asynchronously.  After writing the
+ * status, the PF driver will send an event of the form:
+ *
+ *       0             16                        24   31
+ *      | reserved    | VFDI_EV_TYPE_REQ_STATUS | SEQ   |
+ *
+ * In case the VF must be reset for any reason, the PF driver will
+ * send an event of the form:
+ *
+ *       0             16                       24   31
+ *      | reserved    | VFDI_EV_TYPE_RESET     | SEQ   |
+ *
+ * It is then the responsibility of the VF driver to request
+ * reinitialisation of its queues.
+ */
+#define VFDI_EV_SEQ_LBN 24
+#define VFDI_EV_SEQ_WIDTH 8
+#define VFDI_EV_TYPE_LBN 16
+#define VFDI_EV_TYPE_WIDTH 8
+#define VFDI_EV_TYPE_REQ_WORD0 0
+#define VFDI_EV_TYPE_REQ_WORD1 1
+#define VFDI_EV_TYPE_REQ_WORD2 2
+#define VFDI_EV_TYPE_REQ_WORD3 3
+#define VFDI_EV_TYPE_REQ_STATUS 4
+#define VFDI_EV_TYPE_RESET 5
+#define VFDI_EV_DATA_LBN 0
+#define VFDI_EV_DATA_WIDTH 16
+
+struct vfdi_endpoint {
+	u8 mac_addr[ETH_ALEN];
+	__be16 tci;
+};
+
+/**
+ * enum vfdi_op - VFDI operation enumeration
+ * @VFDI_RESPONSE: Indicates a response to the request.
+ * @VFDI_INIT_EVQ: Initialize SRAM entries and initialize an EVQ.
+ * @VFDI_INIT_RXQ: Initialize SRAM entries and initialize an RXQ.
+ * @VFDI_INIT_TXQ: Initialize SRAM entries and initialize a TXQ.
+ * @VFDI_FINI_ALL_QUEUES: Flush all queues, finalize all queues, then
+ *	finalize the SRAM entries.
+ * @VFDI_INSERT_FILTER: Insert a MAC filter targetting the given RXQ.
+ * @VFDI_REMOVE_ALL_FILTERS: Remove all filters.
+ * @VFDI_SET_STATUS_PAGE: Set the DMA page(s) used for status updates
+ *	from PF and write the initial status.
+ * @VFDI_CLEAR_STATUS_PAGE: Clear the DMA page(s) used for status
+ *	updates from PF.
+ */
+enum vfdi_op {
+	VFDI_RESPONSE = 0,
+	VFDI_INIT_EVQ = 1,
+	VFDI_INIT_RXQ = 2,
+	VFDI_INIT_TXQ = 3,
+	VFDI_FINI_ALL_QUEUES = 4,
+	VFDI_INSERT_FILTER = 5,
+	VFDI_REMOVE_ALL_FILTERS = 6,
+	VFDI_SET_STATUS_PAGE = 7,
+	VFDI_CLEAR_STATUS_PAGE = 8,
+	VFDI_LIMIT,
+};
+
+/**
+ * struct vfdi_req - Request from VF driver to PF driver
+ * @op: Operation code or response indicator, taken from &enum vfdi_op.
+ * @seq: Reserved.
+ * @rc: Response code.  Set to 0 on success or a negative Linux error code
+ *	 on failure.
+ * @u.init_evq.index: Index of event queue to create.
+ * @u.init_evq.buf_count: Number of 4k buffers backing event queue.
+ * @u.init_evq.addr: Array of length %u.init_evq.buf_count containing DMA
+ *	address of each page backing the event queue.
+ * @u.init_rxq.index: Index of receive queue to create.
+ * @u.init_rxq.buf_count: Number of 4k buffers backing receive queue.
+ * @u.init_rxq.evq: Instance of event queue to target receive events at.
+ * @u.init_rxq.label: Label used in receive events.
+ * @u.init_rxq.flags: Unused.
+ * @u.init_rxq.addr: Array of length %u.init_rxq.buf_count containing DMA
+ *	address of each page backing the receive queue.
+ * @u.init_txq.index: Index of transmit queue to create.
+ * @u.init_txq.buf_count: Number of 4k buffers backing transmit queue.
+ * @u.init_txq.evq: Instance of event queue to target transmit completion
+ *	events at.
+ * @u.init_txq.label: Label used in transmit completion events.
+ * @u.init_txq.flags: Checksum offload flags.
+ * @u.init_txq.addr: Array of length %u.init_txq.buf_count containing DMA
+ *	address of each page backing the transmit queue.
+ * @u.mac_filter.rxq: Insert MAC filter at VF local address/VLAN targetting
+ *	all traffic at this receive queue.
+ * @u.mac_filter.flags: MAC filter flags.
+ * @u.set_status_page.dma_addr: Base address for the &struct vfdi_status.
+ *	This address must be page-aligned and the PF may write up to a
+ *	whole page (allowing for extension of the structure).
+ * @u.set_status_page.peer_page_count: Number of additional pages the VF
+ *	has provided into which peer addresses may be DMAd.
+ * @u.set_status_page.peer_page_addr: Array of DMA addresses of pages.
+ *	If the number of peers exceeds 256, then the VF must provide
+ *	additional pages in this array. The PF will then DMA up to
+ *	512 vfdi_endpoint structures into each page.  These addresses
+ *	must be page-aligned.
+ */
+struct vfdi_req {
+	u32 op;
+	u32 seq;
+	s32 rc;
+	u32 reserved2;
+	union {
+		struct {
+			u32 index;
+			u32 buf_count;
+			u64 addr[];
+		} init_evq;
+		struct {
+			u32 index;
+			u32 buf_count;
+			u32 evq;
+			u32 label;
+			u32 flags;
+#define RXQ_FLAG_SCATTER_EN 1
+			u32 reserved;
+			u64 addr[];
+		} init_rxq;
+		struct {
+			u32 index;
+			u32 buf_count;
+			u32 evq;
+			u32 label;
+			u32 flags;
+#define TXQ_FLAG_IP_CSUM_DIS 1
+#define TXQ_FLAG_TCPUDP_CSUM_DIS 2
+			u32 reserved;
+			u64 addr[];
+		} init_txq;
+		struct {
+			u32 rxq;
+			u32 flags;
+#define MAC_FILTER_FLAG_RSS 1
+#define MAC_FILTER_FLAG_SCATTER 2
+		} mac_filter;
+		struct {
+			u64 dma_addr;
+			u64 peer_page_count;
+			u64 peer_page_addr[];
+		} set_status_page;
+	} u;
+};
+
+/**
+ * struct vfdi_status - Status provided by PF driver to VF driver
+ * @generation_start: A generation count DMA'd to VF *before* the
+ *	rest of the structure.
+ * @generation_end: A generation count DMA'd to VF *after* the
+ *	rest of the structure.
+ * @version: Version of this structure; currently set to 1.  Later
+ *	versions must either be layout-compatible or only be sent to VFs
+ *	that specifically request them.
+ * @length: Total length of this structure including embedded tables
+ * @vi_scale: log2 the number of VIs available on this VF. This quantity
+ *	is used by the hardware for register decoding.
+ * @max_tx_channels: The maximum number of transmit queues the VF can use.
+ * @rss_rxq_count: The number of receive queues present in the shared RSS
+ *	indirection table.
+ * @peer_count: Total number of peers in the complete peer list. If larger
+ *	than ARRAY_SIZE(%peers), then the VF must provide sufficient
+ *	additional pages each of which is filled with vfdi_endpoint structures.
+ * @local: The MAC address and outer VLAN tag of *this* VF
+ * @peers: Table of peer addresses.  The @tci fields in these structures
+ *	are currently unused and must be ignored.  Additional peers are
+ *	written into any additional pages provided by the VF.
+ * @timer_quantum_ns: Timer quantum (nominal period between timer ticks)
+ *	for interrupt moderation timers, in nanoseconds. This member is only
+ *	present if @length is sufficiently large.
+ */
+struct vfdi_status {
+	u32 generation_start;
+	u32 generation_end;
+	u32 version;
+	u32 length;
+	u8 vi_scale;
+	u8 max_tx_channels;
+	u8 rss_rxq_count;
+	u8 reserved1;
+	u16 peer_count;
+	u16 reserved2;
+	struct vfdi_endpoint local;
+	struct vfdi_endpoint peers[256];
+
+	/* Members below here extend version 1 of this structure */
+	u32 timer_quantum_ns;
+};
+
+#endif
diff -r 9566a4a50a43 drivers/net/sfc/workarounds.h
--- a/drivers/net/sfc/workarounds.h
+++ b/drivers/net/sfc/workarounds.h
@@ -1,6 +1,6 @@
 /****************************************************************************
  * Driver for Solarflare Solarstorm network controllers and boards
- * Copyright 2006-2008 Solarflare Communications Inc.
+ * Copyright 2006-2010 Solarflare Communications Inc.
  *
  * This program is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 as published
@@ -16,31 +16,41 @@
  */
 
 #define EFX_WORKAROUND_ALWAYS(efx) 1
-#define EFX_WORKAROUND_FALCON_A(efx) (falcon_rev(efx) <= FALCON_REV_A1)
-#define EFX_WORKAROUND_10G(efx) EFX_IS10G(efx)
-#define EFX_WORKAROUND_SFT9001(efx) ((efx)->phy_type == PHY_TYPE_SFT9001A || \
-				     (efx)->phy_type == PHY_TYPE_SFT9001B)
+#define EFX_WORKAROUND_NEVER(efx) 0
+#define EFX_WORKAROUND_FALCON_A(efx) (efx_nic_rev(efx) <= EFX_REV_FALCON_A1)
+#define EFX_WORKAROUND_FALCON_B(efx) (efx_nic_rev(efx) == EFX_REV_FALCON_B0)
+#define EFX_WORKAROUND_FALCON_AB(efx) (efx_nic_rev(efx) <= EFX_REV_FALCON_B0)
+#define EFX_WORKAROUND_SIENA(efx) (efx_nic_rev(efx) == EFX_REV_SIENA_A0)
+#define EFX_WORKAROUND_10G(efx) 1
 
 /* XAUI resets if link not detected */
 #define EFX_WORKAROUND_5147 EFX_WORKAROUND_ALWAYS
+/* Reprog PCIe ACK timer to workaround issue in PCIe IP block */
+#define EFX_WORKAROUND_6943 EFX_WORKAROUND_FALCON_B
 /* RX PCIe double split performance issue */
 #define EFX_WORKAROUND_7575 EFX_WORKAROUND_ALWAYS
 /* Bit-bashed I2C reads cause performance drop */
 #define EFX_WORKAROUND_7884 EFX_WORKAROUND_10G
-/* TX pkt parser problem with <= 16 byte TXes */
-#define EFX_WORKAROUND_9141 EFX_WORKAROUND_ALWAYS
+/* Selftests need to be retried */
+#define EFX_WORKAROUND_8568 EFX_WORKAROUND_ALWAYS
+/* Queued ACKs aren't flushed before L1 entry */
+#define EFX_WORKAROUND_9096 EFX_WORKAROUND_FALCON_B
 /* TX_EV_PKT_ERR can be caused by a dangling TX descriptor
  * or a PCIe error (bug 11028) */
 #define EFX_WORKAROUND_10727 EFX_WORKAROUND_ALWAYS
 /* Transmit flow control may get disabled */
-#define EFX_WORKAROUND_11482 EFX_WORKAROUND_ALWAYS
-/* Flush events can take a very long time to appear */
-#define EFX_WORKAROUND_11557 EFX_WORKAROUND_ALWAYS
+#define EFX_WORKAROUND_11482 EFX_WORKAROUND_FALCON_AB
 /* Truncated IPv4 packets can confuse the TX packet parser */
-#define EFX_WORKAROUND_15592 EFX_WORKAROUND_ALWAYS
+#define EFX_WORKAROUND_15592 EFX_WORKAROUND_FALCON_AB
+/* Legacy ISR read can return zero once */
+#define EFX_WORKAROUND_15783 EFX_WORKAROUND_ALWAYS
+/* Legacy interrupt storm when interrupt fifo fills */
+#define EFX_WORKAROUND_17213 EFX_WORKAROUND_SIENA
 
 /* Spurious parity errors in TSORT buffers */
 #define EFX_WORKAROUND_5129 EFX_WORKAROUND_FALCON_A
+/* Unaligned read request >512 bytes after aligning may break TSORT */
+#define EFX_WORKAROUND_5391 EFX_WORKAROUND_FALCON_A
 /* iSCSI parsing errors */
 #define EFX_WORKAROUND_5583 EFX_WORKAROUND_FALCON_A
 /* RX events go missing */
@@ -50,13 +60,11 @@
 /* Increase filter depth to avoid RX_RESET */
 #define EFX_WORKAROUND_7244 EFX_WORKAROUND_FALCON_A
 /* Flushes may never complete */
-#define EFX_WORKAROUND_7803 EFX_WORKAROUND_FALCON_A
+#define EFX_WORKAROUND_7803 EFX_WORKAROUND_FALCON_AB
 /* Leak overlength packets rather than free */
 #define EFX_WORKAROUND_8071 EFX_WORKAROUND_FALCON_A
 
-/* Need to send XNP pages for 100BaseT */
-#define EFX_WORKAROUND_13204 EFX_WORKAROUND_SFT9001
-/* Don't restart AN in near-side loopback */
-#define EFX_WORKAROUND_15195 EFX_WORKAROUND_SFT9001
+/* Invalid BAR accesses may not be completed, leading to NMI */
+#define EFX_WORKAROUND_11368 EFX_WORKAROUND_FALCON_B
 
 #endif /* EFX_WORKAROUNDS_H */
diff -r 9566a4a50a43 drivers/net/sfc/xfp_phy.c
--- a/drivers/net/sfc/xfp_phy.c
+++ /dev/null
@@ -1,250 +0,0 @@
-/****************************************************************************
- * Driver for Solarflare Solarstorm network controllers and boards
- * Copyright 2006-2008 Solarflare Communications Inc.
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 as published
- * by the Free Software Foundation, incorporated herein by reference.
- */
-/*
- * Driver for SFP+ and XFP optical PHYs plus some support specific to the
- * AMCC QT20xx adapters; see www.amcc.com for details
- */
-
-#include <linux/timer.h>
-#include <linux/delay.h>
-#include "efx.h"
-#include "mdio_10g.h"
-#include "phy.h"
-#include "falcon.h"
-
-#define XFP_REQUIRED_DEVS (MDIO_DEVS_PCS |	\
-			   MDIO_DEVS_PMAPMD |	\
-			   MDIO_DEVS_PHYXS)
-
-#define XFP_LOOPBACKS ((1 << LOOPBACK_PCS) |		\
-		       (1 << LOOPBACK_PMAPMD) |		\
-		       (1 << LOOPBACK_NETWORK))
-
-/****************************************************************************/
-/* Quake-specific MDIO registers */
-#define MDIO_QUAKE_LED0_REG	(0xD006)
-
-/* QT2025C only */
-#define PCS_FW_HEARTBEAT_REG	0xd7ee
-#define PCS_FW_HEARTB_LBN	0
-#define PCS_FW_HEARTB_WIDTH	8
-#define PCS_UC8051_STATUS_REG	0xd7fd
-#define PCS_UC_STATUS_LBN	0
-#define PCS_UC_STATUS_WIDTH	8
-#define PCS_UC_STATUS_FW_SAVE	0x20
-#define PMA_PMD_FTX_CTRL2_REG	0xc309
-#define PMA_PMD_FTX_STATIC_LBN	13
-#define PMA_PMD_VEND1_REG	0xc001
-#define PMA_PMD_VEND1_LBTXD_LBN	15
-#define PCS_VEND1_REG	   	0xc000
-#define PCS_VEND1_LBTXD_LBN	5
-
-void xfp_set_led(struct efx_nic *p, int led, int mode)
-{
-	int addr = MDIO_QUAKE_LED0_REG + led;
-	efx_mdio_write(p, MDIO_MMD_PMAPMD, addr, mode);
-}
-
-struct xfp_phy_data {
-	enum efx_phy_mode phy_mode;
-};
-
-#define XFP_MAX_RESET_TIME 500
-#define XFP_RESET_WAIT 10
-
-static int qt2025c_wait_reset(struct efx_nic *efx)
-{
-	unsigned long timeout = jiffies + 10 * HZ;
-	int reg, old_counter = 0;
-
-	/* Wait for firmware heartbeat to start */
-	for (;;) {
-		int counter;
-		reg = efx_mdio_read(efx, MDIO_MMD_PCS, PCS_FW_HEARTBEAT_REG);
-		if (reg < 0)
-			return reg;
-		counter = ((reg >> PCS_FW_HEARTB_LBN) &
-			    ((1 << PCS_FW_HEARTB_WIDTH) - 1));
-		if (old_counter == 0)
-			old_counter = counter;
-		else if (counter != old_counter)
-			break;
-		if (time_after(jiffies, timeout))
-			return -ETIMEDOUT;
-		msleep(10);
-	}
-
-	/* Wait for firmware status to look good */
-	for (;;) {
-		reg = efx_mdio_read(efx, MDIO_MMD_PCS, PCS_UC8051_STATUS_REG);
-		if (reg < 0)
-			return reg;
-		if ((reg &
-		     ((1 << PCS_UC_STATUS_WIDTH) - 1) << PCS_UC_STATUS_LBN) >=
-		    PCS_UC_STATUS_FW_SAVE)
-			break;
-		if (time_after(jiffies, timeout))
-			return -ETIMEDOUT;
-		msleep(100);
-	}
-
-	return 0;
-}
-
-static int xfp_reset_phy(struct efx_nic *efx)
-{
-	int rc;
-
-	if (efx->phy_type == PHY_TYPE_QT2025C) {
-		/* Wait for the reset triggered by falcon_reset_hw()
-		 * to complete */
-		rc = qt2025c_wait_reset(efx);
-		if (rc < 0)
-			goto fail;
-	} else {
-		/* Reset the PHYXS MMD. This is documented as doing
-		 * a complete soft reset. */
-		rc = efx_mdio_reset_mmd(efx, MDIO_MMD_PHYXS,
-					XFP_MAX_RESET_TIME / XFP_RESET_WAIT,
-					XFP_RESET_WAIT);
-		if (rc < 0)
-			goto fail;
-	}
-
-	/* Wait 250ms for the PHY to complete bootup */
-	msleep(250);
-
-	/* Check that all the MMDs we expect are present and responding. We
-	 * expect faults on some if the link is down, but not on the PHY XS */
-	rc = efx_mdio_check_mmds(efx, XFP_REQUIRED_DEVS, MDIO_DEVS_PHYXS);
-	if (rc < 0)
-		goto fail;
-
-	efx->board_info.init_leds(efx);
-
-	return rc;
-
- fail:
-	EFX_ERR(efx, "PHY reset timed out\n");
-	return rc;
-}
-
-static int xfp_phy_init(struct efx_nic *efx)
-{
-	struct xfp_phy_data *phy_data;
-	u32 devid = efx_mdio_read_id(efx, MDIO_MMD_PHYXS);
-	int rc;
-
-	phy_data = kzalloc(sizeof(struct xfp_phy_data), GFP_KERNEL);
-	if (!phy_data)
-		return -ENOMEM;
-	efx->phy_data = phy_data;
-
-	EFX_INFO(efx, "PHY ID reg %x (OUI %06x model %02x revision %x)\n",
-		 devid, efx_mdio_id_oui(devid), efx_mdio_id_model(devid),
-		 efx_mdio_id_rev(devid));
-
-	phy_data->phy_mode = efx->phy_mode;
-
-	rc = xfp_reset_phy(efx);
-
-	EFX_INFO(efx, "PHY init %s.\n",
-		 rc ? "failed" : "successful");
-	if (rc < 0)
-		goto fail;
-
-	return 0;
-
- fail:
-	kfree(efx->phy_data);
-	efx->phy_data = NULL;
-	return rc;
-}
-
-static void xfp_phy_clear_interrupt(struct efx_nic *efx)
-{
-	/* Read to clear link status alarm */
-	efx_mdio_read(efx, MDIO_MMD_PMAPMD, MDIO_PMA_LASI_STAT);
-}
-
-static int xfp_link_ok(struct efx_nic *efx)
-{
-	return efx_mdio_links_ok(efx, XFP_REQUIRED_DEVS);
-}
-
-static void xfp_phy_poll(struct efx_nic *efx)
-{
-	int link_up = xfp_link_ok(efx);
-	/* Simulate a PHY event if link state has changed */
-	if (link_up != efx->link_up)
-		falcon_sim_phy_event(efx);
-}
-
-static void xfp_phy_reconfigure(struct efx_nic *efx)
-{
-	struct xfp_phy_data *phy_data = efx->phy_data;
-
-	if (efx->phy_type == PHY_TYPE_QT2025C) {
-		/* There are several different register bits which can
-		 * disable TX (and save power) on direct-attach cables
-		 * or optical transceivers, varying somewhat between
-		 * firmware versions.  Only 'static mode' appears to
-		 * cover everything. */
-		mdio_set_flag(
-			&efx->mdio, efx->mdio.prtad, MDIO_MMD_PMAPMD,
-			PMA_PMD_FTX_CTRL2_REG, 1 << PMA_PMD_FTX_STATIC_LBN,
-			efx->phy_mode & PHY_MODE_TX_DISABLED ||
-			efx->phy_mode & PHY_MODE_LOW_POWER ||
-			efx->loopback_mode == LOOPBACK_PCS ||
-			efx->loopback_mode == LOOPBACK_PMAPMD);
-	} else {
-		/* Reset the PHY when moving from tx off to tx on */
-		if (!(efx->phy_mode & PHY_MODE_TX_DISABLED) &&
-		    (phy_data->phy_mode & PHY_MODE_TX_DISABLED))
-			xfp_reset_phy(efx);
-
-		efx_mdio_transmit_disable(efx);
-	}
-
-	efx_mdio_phy_reconfigure(efx);
-
-	phy_data->phy_mode = efx->phy_mode;
-	efx->link_up = xfp_link_ok(efx);
-	efx->link_speed = 10000;
-	efx->link_fd = true;
-	efx->link_fc = efx->wanted_fc;
-}
-
-static void xfp_phy_get_settings(struct efx_nic *efx, struct ethtool_cmd *ecmd)
-{
-	mdio45_ethtool_gset(&efx->mdio, ecmd);
-}
-
-static void xfp_phy_fini(struct efx_nic *efx)
-{
-	/* Clobber the LED if it was blinking */
-	efx->board_info.blink(efx, false);
-
-	/* Free the context block */
-	kfree(efx->phy_data);
-	efx->phy_data = NULL;
-}
-
-struct efx_phy_operations falcon_xfp_phy_ops = {
-	.macs		 = EFX_XMAC,
-	.init            = xfp_phy_init,
-	.reconfigure     = xfp_phy_reconfigure,
-	.poll            = xfp_phy_poll,
-	.fini            = xfp_phy_fini,
-	.clear_interrupt = xfp_phy_clear_interrupt,
-	.get_settings    = xfp_phy_get_settings,
-	.set_settings	 = efx_mdio_set_settings,
-	.mmds            = XFP_REQUIRED_DEVS,
-	.loopbacks       = XFP_LOOPBACKS,
-};
diff -r 9566a4a50a43 drivers/xen/Kconfig
--- a/drivers/xen/Kconfig
+++ b/drivers/xen/Kconfig
@@ -34,10 +34,6 @@ config XEN_XENBUS_DEV
 	def_bool y
 	depends on PROC_FS
 
-config XEN_NETDEV_ACCEL_SFC_UTIL
-    	depends on X86
-	tristate
-
 config XEN_BACKEND
         tristate "Backend driver support"
         default XEN_PRIVILEGED_GUEST
@@ -80,12 +76,6 @@ config XEN_NETDEV_BACKEND
 	  network devices to other guests via a high-performance shared-memory
 	  interface.
 
-config XEN_NETDEV_ACCEL_SFC_BACKEND
-	tristate "Network-device backend driver acceleration for Solarflare NICs"
-	depends on XEN_NETDEV_BACKEND && SFC && SFC_RESOURCE && X86
-	select XEN_NETDEV_ACCEL_SFC_UTIL
-	default m
-
 config XEN_PCIDEV_BACKEND
 	tristate "PCI-device backend driver"
 	depends on PCI && XEN_PRIVILEGED_GUEST && XEN_BACKEND
@@ -191,12 +181,6 @@ config XEN_NETDEV_FRONTEND
 	  dedicated device-driver domain, or your master control domain
 	  (domain 0), then you almost certainly want to say Y here.
 
-config XEN_NETDEV_ACCEL_SFC_FRONTEND
-	tristate "Network-device frontend driver acceleration for Solarflare NICs"
-	depends on XEN_NETDEV_FRONTEND && X86
-	select XEN_NETDEV_ACCEL_SFC_UTIL
-	default m
-
 config XEN_SCSI_FRONTEND
 	tristate "SCSI frontend driver"
 	depends on SCSI
diff -r 9566a4a50a43 drivers/xen/Makefile
--- a/drivers/xen/Makefile
+++ b/drivers/xen/Makefile
@@ -37,6 +37,3 @@ obj-$(CONFIG_XEN_USB_BACKEND)		+= usbbac
 obj-$(CONFIG_XEN_USB_FRONTEND)		+= usbfront/
 obj-$(CONFIG_XEN_PRIVCMD)	+= privcmd/
 obj-$(CONFIG_XEN_GRANT_DEV)	+= gntdev/
-obj-$(CONFIG_XEN_NETDEV_ACCEL_SFC_UTIL)		+= sfc_netutil/
-obj-$(CONFIG_XEN_NETDEV_ACCEL_SFC_FRONTEND)	+= sfc_netfront/
-obj-$(CONFIG_XEN_NETDEV_ACCEL_SFC_BACKEND)	+= sfc_netback/
diff -r 9566a4a50a43 drivers/xen/sfc_netback/Makefile
--- a/drivers/xen/sfc_netback/Makefile
+++ /dev/null
@@ -1,12 +0,0 @@
-EXTRA_CFLAGS += -Idrivers/xen/sfc_netback -Idrivers/xen/sfc_netutil -Idrivers/xen/netback -Idrivers/net/sfc -Idrivers/net/sfc/sfc_resource
-EXTRA_CFLAGS += -D__ci_driver__ 
-EXTRA_CFLAGS += -DEFX_USE_KCOMPAT
-EXTRA_CFLAGS += -Werror
-
-ifdef GCOV
-EXTRA_CFLAGS += -fprofile-arcs -ftest-coverage -DEFX_GCOV
-endif
-
-obj-$(CONFIG_XEN_NETDEV_ACCEL_SFC_BACKEND) := sfc_netback.o
-
-sfc_netback-objs   := accel.o accel_fwd.o accel_msg.o accel_solarflare.o accel_xenbus.o accel_debugfs.o
diff -r 9566a4a50a43 drivers/xen/sfc_netback/accel.c
--- a/drivers/xen/sfc_netback/accel.c
+++ /dev/null
@@ -1,147 +0,0 @@
-/****************************************************************************
- * Solarflare driver for Xen network acceleration
- *
- * Copyright 2006-2008: Solarflare Communications Inc,
- *                      9501 Jeronimo Road, Suite 250,
- *                      Irvine, CA 92618, USA
- *
- * Maintained by Solarflare Communications <linux-xen-drivers@solarflare.com>
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 as published
- * by the Free Software Foundation, incorporated herein by reference.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
- ****************************************************************************
- */
-
-#include "accel.h"
-#include "accel_msg_iface.h"
-#include "accel_solarflare.h"
-
-#include <linux/notifier.h>
-
-#ifdef EFX_GCOV
-#include "gcov.h"
-#endif
-
-static int netback_accel_netdev_event(struct notifier_block *nb,
-				      unsigned long event, void *ptr)
-{
-	struct net_device *net_dev = (struct net_device *)ptr;
-	struct netback_accel *bend;
-
-	if ((event == NETDEV_UP) || 
-	    (event == NETDEV_DOWN) ||
-	    (event == NETDEV_CHANGE)) {
-		mutex_lock(&bend_list_mutex);
-		bend = bend_list;
-		while (bend != NULL) {
-			mutex_lock(&bend->bend_mutex);
-			/*
-			 * This happens when the shared pages have
-			 * been unmapped, but the bend not yet removed
-			 * from list
-			 */
-			if (bend->shared_page == NULL)
-				goto next;
-
-			if (bend->net_dev->ifindex == net_dev->ifindex) {
-				int ok;
-				if (event == NETDEV_CHANGE)
-					ok = (netif_carrier_ok(net_dev) && 
-					      (net_dev->flags & IFF_UP));
-				else
-					ok = (netif_carrier_ok(net_dev) && 
-					      (event == NETDEV_UP));
-				netback_accel_set_interface_state(bend, ok);
-			}
-
-		next:
-			mutex_unlock(&bend->bend_mutex);
-			bend = bend->next_bend;
-		}
-		mutex_unlock(&bend_list_mutex);
-	}
-
-	return NOTIFY_DONE;
-}
-
-
-static struct notifier_block netback_accel_netdev_notifier = {
-	.notifier_call = netback_accel_netdev_event,
-};
-
-
-unsigned sfc_netback_max_pages = NETBACK_ACCEL_DEFAULT_MAX_BUF_PAGES;
-module_param_named(max_pages, sfc_netback_max_pages, uint, 0644);
-MODULE_PARM_DESC(max_pages, 
-		 "The number of buffer pages to enforce on each guest");
-
-/* Initialise subsystems need for the accelerated fast path */
-static int __init netback_accel_init(void)
-{
-	int rc = 0;
-
-#ifdef EFX_GCOV
-	gcov_provider_init(THIS_MODULE);
-#endif
-
-	rc = netback_accel_init_fwd();
-	if (rc != 0)
-		goto fail0;
-
-	netback_accel_debugfs_init();
-
-	rc = netback_accel_sf_init();
-	if (rc != 0)
-		goto fail1;
-
-	rc = register_netdevice_notifier
-		(&netback_accel_netdev_notifier);
-	if (rc != 0)
-		goto fail2;
-
-	return 0;
-
- fail2:
-	netback_accel_sf_shutdown();
- fail1:
-	netback_accel_debugfs_fini();
-	netback_accel_shutdown_fwd();
- fail0:
-#ifdef EFX_GCOV
-	gcov_provider_fini(THIS_MODULE);
-#endif
-	return rc;
-}
-
-module_init(netback_accel_init);
-
-static void __exit netback_accel_exit(void)
-{
-	unregister_netdevice_notifier(&netback_accel_netdev_notifier);
-
-	netback_accel_sf_shutdown();
-
-	netback_accel_shutdown_bends();
-
-	netback_accel_debugfs_fini();
-
-	netback_accel_shutdown_fwd();
-
-#ifdef EFX_GCOV
-	gcov_provider_fini(THIS_MODULE);
-#endif
-}
-
-module_exit(netback_accel_exit);
-
-MODULE_LICENSE("GPL");
diff -r 9566a4a50a43 drivers/xen/sfc_netback/accel.h
--- a/drivers/xen/sfc_netback/accel.h
+++ /dev/null
@@ -1,392 +0,0 @@
-/****************************************************************************
- * Solarflare driver for Xen network acceleration
- *
- * Copyright 2006-2008: Solarflare Communications Inc,
- *                      9501 Jeronimo Road, Suite 250,
- *                      Irvine, CA 92618, USA
- *
- * Maintained by Solarflare Communications <linux-xen-drivers@solarflare.com>
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 as published
- * by the Free Software Foundation, incorporated herein by reference.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
- ****************************************************************************
- */
-
-#ifndef NETBACK_ACCEL_H
-#define NETBACK_ACCEL_H
-
-#include <linux/version.h>
-#include <linux/slab.h>
-#include <linux/ip.h>
-#include <linux/tcp.h>
-#include <linux/udp.h>
-#include <linux/in.h>
-#include <linux/netdevice.h>
-#include <linux/etherdevice.h>
-#include <linux/mutex.h>
-#include <linux/wait.h>
-
-#include <xen/xenbus.h>
-
-#include "accel_shared_fifo.h"
-#include "accel_msg_iface.h"
-#include "accel_util.h"
-
-/**************************************************************************
- * Datatypes
- **************************************************************************/
-
-#define NETBACK_ACCEL_DEFAULT_MAX_FILTERS (8)
-#define NETBACK_ACCEL_DEFAULT_MAX_MCASTS (8)
-#define NETBACK_ACCEL_DEFAULT_MAX_BUF_PAGES (384)
-/* Variable to store module parameter for max_buf_pages */
-extern unsigned sfc_netback_max_pages;
-
-#define NETBACK_ACCEL_STATS 1
-
-#if NETBACK_ACCEL_STATS
-#define NETBACK_ACCEL_STATS_OP(x) x
-#else
-#define NETBACK_ACCEL_STATS_OP(x)
-#endif
-
-/*! Statistics for a given backend */
-struct netback_accel_stats {
-	/*! Number of eventq wakeup events */
-	u64 evq_wakeups;
-	/*! Number of eventq timeout events */
-	u64 evq_timeouts;
-	/*! Number of filters used */
-	u32 num_filters;
-	/*! Number of buffer pages registered */
-	u32 num_buffer_pages;
-};
-
-
-/* Debug fs nodes for each of the above stats */
-struct netback_accel_dbfs {
-	struct dentry *evq_wakeups;
-	struct dentry *evq_timeouts;
-	struct dentry *num_filters;
-	struct dentry *num_buffer_pages;
-};
-
-
-/*! Resource limits for a given NIC */
-struct netback_accel_limits {
-	int max_filters;	    /*!< Max. number of filters to use. */
-	int max_mcasts;	     /*!< Max. number  of mcast subscriptions */
-	int max_buf_pages;	  /*!< Max. number of pages of NIC buffers */
-};
-
-
-/*! The state for an instance of the back end driver. */
-struct netback_accel {
-	/*! mutex to protect this state */
-	struct mutex bend_mutex;
-
-	/*! Watches on xenstore */
-	struct xenbus_watch domu_accel_watch;
-	struct xenbus_watch config_accel_watch;
-
-	/*! Pointer to whatever device cookie ties us in to the hypervisor */
-	void *hdev_data;
-
-	/*! FIFO indices. Next page is msg FIFOs */
-	struct net_accel_shared_page *shared_page;
-
-	/*! Defer control message processing */
-	struct work_struct handle_msg;
-
-	/*! Identifies other end VM and interface.*/
-	int far_end;
-	int vif_num;
-
-	/*!< To unmap the shared pages */
-	void *sh_pages_unmap;
-
-	/* Resource tracking */
-	/*! Limits on H/W & Dom0 resources */
-	struct netback_accel_limits quotas;
-
-	/* Hardware resources */
-	/*! The H/W type of associated NIC */
-	enum net_accel_hw_type hw_type;
-	/*! State of allocation */	       
-	int hw_state;
-	/*! How to set up the acceleration for this hardware */
-	int (*accel_setup)(struct netback_accel *); 
-	/*! And how to stop it. */
-	void (*accel_shutdown)(struct netback_accel *);
-
-	/*! The physical/real net_dev for this interface */
-	struct net_device *net_dev;
-
-	/*! Magic pointer to locate state in fowarding table */
-	void *fwd_priv;
-
-	/*! Message FIFO */
-	sh_msg_fifo2 to_domU;
-	/*! Message FIFO */
-	sh_msg_fifo2 from_domU;
-
-	/*! General notification channel id */
-	int msg_channel;
-	/*! General notification channel irq */
-	int msg_channel_irq;
-
-	/*! Event channel id dedicated to network packet interrupts. */
-	int net_channel; 
-	/*! Event channel irq dedicated to network packets interrupts */
-	int net_channel_irq; 
-
-	/*! The MAC address the frontend goes by. */
-	u8 mac[ETH_ALEN];
-	/*! Driver name of associated NIC */
-	char *nicname;    
-
-	/*! Array of pointers to buffer pages mapped */
-	grant_handle_t *buffer_maps; 
-	u64 *buffer_addrs;
-	/*! Index into buffer_maps */
-	int buffer_maps_index; 
-	/*! Max number of pages that domU is allowed/will request to map */
-	int max_pages; 
-
-	/*! Pointer to hardware specific private area */
-	void *accel_hw_priv; 
-
-	/*! Wait queue for changes in accelstate. */
-	wait_queue_head_t state_wait_queue;
-
-	/*! Current state of the frontend according to the xenbus
-	 *  watch. */
-	XenbusState frontend_state;
-
-	/*! Current state of this backend. */
-	XenbusState backend_state;
-
-	/*! Non-zero if the backend is being removed. */
-	int removing;
-
-	/*! Non-zero if the setup_vnic has been called. */
-	int vnic_is_setup;
-
-#if NETBACK_ACCEL_STATS
-	struct netback_accel_stats stats;
-#endif	
-#if defined(CONFIG_DEBUG_FS)
-	char *dbfs_dir_name;
-	struct dentry *dbfs_dir;
-	struct netback_accel_dbfs dbfs;
-#endif
-
-	/*! List */
-	struct netback_accel *next_bend;
-};
-
-
-/*
- * Values for netback_accel.hw_state.  States of resource allocation
- * we can go through
- */
-/*! No hardware has yet been allocated. */
-#define NETBACK_ACCEL_RES_NONE  (0)
-/*! Hardware has been allocated. */
-#define NETBACK_ACCEL_RES_ALLOC (1)
-#define NETBACK_ACCEL_RES_FILTER (2)
-#define NETBACK_ACCEL_RES_HWINFO (3)
-
-/*! Filtering specification. This assumes that for VNIC support we
- *  will always want wildcard entries, so only specifies the
- *  destination IP/port
- */
-struct netback_accel_filter_spec {
-	/*! Internal, used to access efx_vi API */
-	void *filter_handle; 
-
-	/*! Destination IP in network order */
-	u32 destip_be;
-	/*! Destination port in network order */
-	u16 destport_be;
-	/*! Mac address */
-	u8  mac[ETH_ALEN];
-	/*! TCP or UDP */
-	u8  proto;	
-};
-
-
-/**************************************************************************
- * From accel.c
- **************************************************************************/
-
-/*! \brief Start up all the acceleration plugins 
- *
- * \return 0 on success, an errno on failure
- */
-extern int netback_accel_init_accel(void);
-
-/*! \brief Shut down all the acceleration plugins 
- */
-extern void netback_accel_shutdown_accel(void);
-
-
-/**************************************************************************
- * From accel_fwd.c
- **************************************************************************/
-
-/*! \brief Init the forwarding infrastructure
- * \return 0 on success, or -ENOMEM if it couldn't get memory for the
- * forward table 
- */
-extern int netback_accel_init_fwd(void);
-
-/*! \brief Shut down the forwarding and free memory. */
-extern void netback_accel_shutdown_fwd(void);
-
-/*! Initialise each nic port's fowarding table */
-extern void *netback_accel_init_fwd_port(void);
-extern void netback_accel_shutdown_fwd_port(void *fwd_priv);
-
-/*! \brief Add an entry to the forwarding table. 
- * \param mac : MAC address, used as hash key
- * \param ctxt : value to associate with key (can be NULL, see
- * netback_accel_fwd_set_context)
- * \return 0 on success, -ENOMEM if table was full and could no grow it
- */
-extern int netback_accel_fwd_add(const __u8 *mac, void *context,
-				 void *fwd_priv);
-
-/*! \brief Remove an entry from the forwarding table. 
- * \param mac : the MAC address to remove
- * \return nothing: it is not an error if the mac was not in the table
- */
-extern void netback_accel_fwd_remove(const __u8 *mac, void *fwd_priv);
-
-/*! \brief Set the context pointer for an existing fwd table entry.
- * \param mac : key that is already present in the table
- * \param context : new value to associate with key
- * \return 0 on success, -ENOENT if mac not present in table.
- */
-extern int netback_accel_fwd_set_context(const __u8 *mac, void *context,
-					 void *fwd_priv);
-
-/**************************************************************************
- * From accel_msg.c
- **************************************************************************/
-
-
-/*! \brief Send the start-of-day message that handshakes with the VNIC
- *  and tells it its MAC address.
- *
- * \param bend The back end driver data structure
- * \param version The version of communication to use, e.g. NET_ACCEL_MSG_VERSION
- */
-extern void netback_accel_msg_tx_hello(struct netback_accel *bend,
-				       unsigned version);
-
-/*! \brief Send a "there's a new local mac address" message 
- *
- * \param bend The back end driver data structure for the vnic to send
- * the message to 
- * \param mac Pointer to the new mac address
- */
-extern void netback_accel_msg_tx_new_localmac(struct netback_accel *bend,
-					      const void *mac);
-
-/*! \brief Send a "a mac address that was local has gone away" message 
- *
- * \param bend The back end driver data structure for the vnic to send
- * the message to 
- * \param mac Pointer to the old mac address
- */
-extern void netback_accel_msg_tx_old_localmac(struct netback_accel *bend,
-					      const void *mac);
-
-extern void netback_accel_set_interface_state(struct netback_accel *bend,
-					      int up);
-
-/*! \brief Process the message queue for a bend that has just
- * interrupted.
- * 
- * Demultiplexs an interrupt from the front end driver, taking
- * messages from the fifo and taking appropriate action.
- * 
- * \param bend The back end driver data structure
- */
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,20)
-extern void netback_accel_msg_rx_handler(struct work_struct *arg);
-#else
-extern void netback_accel_msg_rx_handler(void *bend_void);
-#endif
-
-/**************************************************************************
- * From accel_xenbus.c
- **************************************************************************/
-/*! List of all the bends currently in existence. */
-extern struct netback_accel *bend_list;
-extern struct mutex bend_list_mutex;
-
-/*! \brief Probe a new network interface. */
-extern int netback_accel_probe(struct xenbus_device *dev);
-
-/*! \brief Remove a network interface. */
-extern int netback_accel_remove(struct xenbus_device *dev);
-
-/*! \brief Shutdown all accelerator backends */
-extern void netback_accel_shutdown_bends(void);
-
-/*! \brief Initiate the xenbus state teardown handshake */
-extern void netback_accel_set_closing(struct netback_accel *bend);
-
-/**************************************************************************
- * From accel_debugfs.c
- **************************************************************************/
-/*! Global statistics */
-struct netback_accel_global_stats {
-	/*! Number of TX packets seen through driverlink */
-	u64 dl_tx_packets;
-	/*! Number of TX packets seen through driverlink we didn't like */
-	u64 dl_tx_bad_packets;
-	/*! Number of RX packets seen through driverlink */
-	u64 dl_rx_packets;
-	/*! Number of mac addresses we are forwarding to */
-	u32 num_fwds;
-};
-
-/*! Debug fs entries for each of the above stats */
-struct netback_accel_global_dbfs {
-	struct dentry *dl_tx_packets;
-	struct dentry *dl_tx_bad_packets;
-	struct dentry *dl_rx_packets;
-	struct dentry *num_fwds;
-};
-
-#if NETBACK_ACCEL_STATS
-extern struct netback_accel_global_stats global_stats;
-#endif
-
-/*! \brief Initialise the debugfs root and populate with global stats */
-extern void netback_accel_debugfs_init(void);
-
-/*! \brief Remove our debugfs root directory */
-extern void netback_accel_debugfs_fini(void);
-
-/*! \brief Add per-bend statistics to debug fs */
-extern int netback_accel_debugfs_create(struct netback_accel *bend);
-/*! \brief Remove per-bend statistics from debug fs */
-extern int netback_accel_debugfs_remove(struct netback_accel *bend);
-
-#endif /* NETBACK_ACCEL_H */
-
-
diff -r 9566a4a50a43 drivers/xen/sfc_netback/accel_debugfs.c
--- a/drivers/xen/sfc_netback/accel_debugfs.c
+++ /dev/null
@@ -1,148 +0,0 @@
-/****************************************************************************
- * Solarflare driver for Xen network acceleration
- *
- * Copyright 2006-2008: Solarflare Communications Inc,
- *                      9501 Jeronimo Road, Suite 250,
- *                      Irvine, CA 92618, USA
- *
- * Maintained by Solarflare Communications <linux-xen-drivers@solarflare.com>
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 as published
- * by the Free Software Foundation, incorporated herein by reference.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
- ****************************************************************************
- */
-
-#include <linux/fs.h>
-#include <linux/debugfs.h>
-
-#include "accel.h"
-
-#if defined(CONFIG_DEBUG_FS)
-static struct dentry *sfc_debugfs_root = NULL;
-#endif
-
-#if NETBACK_ACCEL_STATS
-struct netback_accel_global_stats global_stats;
-#if defined(CONFIG_DEBUG_FS)
-static struct netback_accel_global_dbfs  global_dbfs;
-#endif
-#endif
-
-void netback_accel_debugfs_init(void) 
-{
-#if defined(CONFIG_DEBUG_FS)
-	sfc_debugfs_root = debugfs_create_dir("sfc_netback", NULL);
-	if (sfc_debugfs_root == NULL)
-		return;
-
-	global_dbfs.num_fwds = debugfs_create_u32
-		("num_fwds", S_IRUSR | S_IRGRP | S_IROTH,
-		 sfc_debugfs_root, &global_stats.num_fwds);
-	global_dbfs.dl_tx_packets = debugfs_create_u64
-		("dl_tx_packets", S_IRUSR | S_IRGRP | S_IROTH,
-		 sfc_debugfs_root, &global_stats.dl_tx_packets);
-	global_dbfs.dl_rx_packets = debugfs_create_u64
-		("dl_rx_packets", S_IRUSR | S_IRGRP | S_IROTH,
-		 sfc_debugfs_root, &global_stats.dl_rx_packets);
-	global_dbfs.dl_tx_bad_packets = debugfs_create_u64
-		("dl_tx_bad_packets", S_IRUSR | S_IRGRP | S_IROTH,
-		 sfc_debugfs_root, &global_stats.dl_tx_bad_packets);
-#endif
-}
-
-
-void netback_accel_debugfs_fini(void)
-{
-#if defined(CONFIG_DEBUG_FS)
-	debugfs_remove(global_dbfs.num_fwds);
-	debugfs_remove(global_dbfs.dl_tx_packets);
-	debugfs_remove(global_dbfs.dl_rx_packets);
-	debugfs_remove(global_dbfs.dl_tx_bad_packets);
-
-	debugfs_remove(sfc_debugfs_root);
-#endif
-}
-
-
-int netback_accel_debugfs_create(struct netback_accel *bend)
-{
-#if defined(CONFIG_DEBUG_FS)
-	/* Smallest length is 7 (vif0.0\n) */
-	int length = 7, temp;
-
-	if (sfc_debugfs_root == NULL)
-		return -ENOENT;
-
-	/* Work out length of string representation of far_end and vif_num */
-	temp = bend->far_end;
-	while (temp > 9) {
-		length++;
-		temp = temp / 10;
-	}
-	temp = bend->vif_num;
-	while (temp > 9) {
-		length++;
-		temp = temp / 10;
-	}
-
-	bend->dbfs_dir_name = kmalloc(length, GFP_KERNEL);
-	if (bend->dbfs_dir_name == NULL)
-		return -ENOMEM;
-	sprintf(bend->dbfs_dir_name, "vif%d.%d", bend->far_end, bend->vif_num);
-
-	bend->dbfs_dir = debugfs_create_dir(bend->dbfs_dir_name, 
-					    sfc_debugfs_root);
-	if (bend->dbfs_dir == NULL) {
-		kfree(bend->dbfs_dir_name);
-		return -ENOMEM;
-	}
-
-#if NETBACK_ACCEL_STATS
-	bend->dbfs.evq_wakeups = debugfs_create_u64
-		("evq_wakeups", S_IRUSR | S_IRGRP | S_IROTH,
-		 bend->dbfs_dir, &bend->stats.evq_wakeups);
-	bend->dbfs.evq_timeouts = debugfs_create_u64
-		("evq_timeouts", S_IRUSR | S_IRGRP | S_IROTH,
-		 bend->dbfs_dir, &bend->stats.evq_timeouts);
-	bend->dbfs.num_filters = debugfs_create_u32
-		("num_filters", S_IRUSR | S_IRGRP | S_IROTH,
-		 bend->dbfs_dir, &bend->stats.num_filters);
-	bend->dbfs.num_buffer_pages = debugfs_create_u32
-		("num_buffer_pages", S_IRUSR | S_IRGRP | S_IROTH,
-		 bend->dbfs_dir, &bend->stats.num_buffer_pages);
-#endif
-#endif
-        return 0;
-}
-
-
-int netback_accel_debugfs_remove(struct netback_accel *bend)
-{
-#if defined(CONFIG_DEBUG_FS)
-	if (bend->dbfs_dir != NULL) {
-#if NETBACK_ACCEL_STATS
-		debugfs_remove(bend->dbfs.evq_wakeups);
-		debugfs_remove(bend->dbfs.evq_timeouts);
-		debugfs_remove(bend->dbfs.num_filters);
-		debugfs_remove(bend->dbfs.num_buffer_pages);
-#endif
-		debugfs_remove(bend->dbfs_dir);
-	}
-
-	if (bend->dbfs_dir_name)
-		kfree(bend->dbfs_dir_name);
-#endif
-        return 0;
-}
-
-
diff -r 9566a4a50a43 drivers/xen/sfc_netback/accel_fwd.c
--- a/drivers/xen/sfc_netback/accel_fwd.c
+++ /dev/null
@@ -1,420 +0,0 @@
-/****************************************************************************
- * Solarflare driver for Xen network acceleration
- *
- * Copyright 2006-2008: Solarflare Communications Inc,
- *                      9501 Jeronimo Road, Suite 250,
- *                      Irvine, CA 92618, USA
- *
- * Maintained by Solarflare Communications <linux-xen-drivers@solarflare.com>
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 as published
- * by the Free Software Foundation, incorporated herein by reference.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
- ****************************************************************************
- */
-
-#include "accel.h"
-#include "accel_cuckoo_hash.h"
-#include "accel_util.h"
-#include "accel_solarflare.h"
-
-#include "driverlink_api.h"
-
-#include <linux/if_arp.h>
-#include <linux/skbuff.h>
-#include <linux/list.h>
-
-/* State stored in the forward table */
-struct fwd_struct {
-	struct list_head link; /* Forms list */
-	void * context;
-	__u8 valid;
-	__u8 mac[ETH_ALEN];
-};
-
-/* Max value we support */
-#define NUM_FWDS_BITS 8
-#define NUM_FWDS (1 << NUM_FWDS_BITS)
-#define FWD_MASK (NUM_FWDS - 1)
-
-struct port_fwd {
-	/* Make a list */
-	struct list_head link;
-	/* Hash table to store the fwd_structs */
-	cuckoo_hash_table fwd_hash_table;
-	/* The array of fwd_structs */
-	struct fwd_struct *fwd_array;
-	/* Linked list of entries in use. */
-	struct list_head fwd_list;
-	/* Could do something clever with a reader/writer lock. */
-	spinlock_t fwd_lock;
-	/* Make find_free_entry() a bit faster by caching this */
-	int last_free_index;
-};
-
-/*
- * This is unlocked as it's only called from dl probe and remove,
- * which are themselves synchronised.  Could get rid of it entirely as
- * it's never iterated, but useful for debug
- */
-static struct list_head port_fwds;
-
-
-/* Search the fwd_array for an unused entry */
-static int fwd_find_free_entry(struct port_fwd *fwd_set)
-{
-	int index = fwd_set->last_free_index;
-
-	do {
-		if (!fwd_set->fwd_array[index].valid) {
-			fwd_set->last_free_index = index;
-			return index;
-		}
-		index++;
-		if (index >= NUM_FWDS)
-			index = 0;
-	} while (index != fwd_set->last_free_index);
-
-	return -ENOMEM;
-}
-
-
-/* Look up a MAC in the hash table. Caller should hold table lock. */
-static inline struct fwd_struct *fwd_find_entry(const __u8 *mac,
-						struct port_fwd *fwd_set)
-{
-	cuckoo_hash_value value;
-	cuckoo_hash_mac_key key = cuckoo_mac_to_key(mac);
-
-	if (cuckoo_hash_lookup(&fwd_set->fwd_hash_table,
-			       (cuckoo_hash_key *)(&key),
-			       &value)) {
-		struct fwd_struct *fwd = &fwd_set->fwd_array[value];
-		DPRINTK_ON(memcmp(fwd->mac, mac, ETH_ALEN) != 0);
-		return fwd;
-	}
-
-	return NULL;
-}
-
-
-/* Initialise each nic port's fowarding table */
-void *netback_accel_init_fwd_port(void) 
-{	
-	struct port_fwd *fwd_set;
-
-	fwd_set = kzalloc(sizeof(struct port_fwd), GFP_KERNEL);
-	if (fwd_set == NULL) {
-		return NULL;
-	}
-
-	spin_lock_init(&fwd_set->fwd_lock);
-	
-	fwd_set->fwd_array = kzalloc(sizeof (struct fwd_struct) * NUM_FWDS,
-				     GFP_KERNEL);
-	if (fwd_set->fwd_array == NULL) {
-		kfree(fwd_set);
-		return NULL;
-	}
-	
-	if (cuckoo_hash_init(&fwd_set->fwd_hash_table, NUM_FWDS_BITS, 8) != 0) {
-		kfree(fwd_set->fwd_array);
-		kfree(fwd_set);
-		return NULL;
-	}
-	
-	INIT_LIST_HEAD(&fwd_set->fwd_list);
-	
-	list_add(&fwd_set->link, &port_fwds);
-
-	return fwd_set;
-}
-
-
-void netback_accel_shutdown_fwd_port(void *fwd_priv)
-{
-	struct port_fwd *fwd_set = (struct port_fwd *)fwd_priv;
-
-	BUG_ON(fwd_priv == NULL);
-	
-	BUG_ON(list_empty(&port_fwds));
-	list_del(&fwd_set->link);
-
-	BUG_ON(!list_empty(&fwd_set->fwd_list));
-
-	cuckoo_hash_destroy(&fwd_set->fwd_hash_table);
-	kfree(fwd_set->fwd_array);
-	kfree(fwd_set);
-}
-
-
-int netback_accel_init_fwd()
-{
-	INIT_LIST_HEAD(&port_fwds);
-	return 0;
-}
-
-
-void netback_accel_shutdown_fwd()
-{
-	BUG_ON(!list_empty(&port_fwds));
-}
-
-
-/*
- * Add an entry to the forwarding table.  Returns -ENOMEM if no
- * space.
- */
-int netback_accel_fwd_add(const __u8 *mac, void *context, void *fwd_priv)
-{
-	struct fwd_struct *fwd;
-	int rc = 0, index;
-	unsigned long flags;
-	cuckoo_hash_mac_key key = cuckoo_mac_to_key(mac);
-	struct port_fwd *fwd_set = (struct port_fwd *)fwd_priv;
-
-	BUG_ON(fwd_priv == NULL);
-
-	DPRINTK("Adding mac %pM\n", mac);
-       
-	spin_lock_irqsave(&fwd_set->fwd_lock, flags);
-	
-	if ((rc = fwd_find_free_entry(fwd_set)) < 0 ) {
-		spin_unlock_irqrestore(&fwd_set->fwd_lock, flags);
-		return rc;
-	}
-
-	index = rc;
-
-	/* Shouldn't already be in the table */
-	if (cuckoo_hash_lookup(&fwd_set->fwd_hash_table,
-			       (cuckoo_hash_key *)(&key), &rc) != 0) {
-		spin_unlock_irqrestore(&fwd_set->fwd_lock, flags);
-		EPRINTK("MAC address %pM already accelerated.\n", mac);
-		return -EEXIST;
-	}
-
-	if ((rc = cuckoo_hash_add(&fwd_set->fwd_hash_table,
-				  (cuckoo_hash_key *)(&key), index, 1)) == 0) {
-		fwd = &fwd_set->fwd_array[index];
-		fwd->valid = 1;
-		fwd->context = context;
-		memcpy(fwd->mac, mac, ETH_ALEN);
-		list_add(&fwd->link, &fwd_set->fwd_list);
-		NETBACK_ACCEL_STATS_OP(global_stats.num_fwds++);
-	}
-
-	spin_unlock_irqrestore(&fwd_set->fwd_lock, flags);
-
-	/*
-	 * No need to tell frontend that this mac address is local -
-	 * it should auto-discover through packets on fastpath what is
-	 * local and what is not, and just being on same server
-	 * doesn't make it local (it could be on a different
-	 * bridge)
-	 */
-
-	return rc;
-}
-
-
-/* remove an entry from the forwarding tables. */
-void netback_accel_fwd_remove(const __u8 *mac, void *fwd_priv)
-{
-	struct fwd_struct *fwd;
-	unsigned long flags;
-	cuckoo_hash_mac_key key = cuckoo_mac_to_key(mac);
-	struct port_fwd *fwd_set = (struct port_fwd *)fwd_priv;
-
-	DPRINTK("Removing mac %pM\n", mac);
-
-	BUG_ON(fwd_priv == NULL);
-
-	spin_lock_irqsave(&fwd_set->fwd_lock, flags);
-
-	fwd = fwd_find_entry(mac, fwd_set);
-	if (fwd != NULL) {
-		BUG_ON(list_empty(&fwd_set->fwd_list));
-		list_del(&fwd->link);
-
-		fwd->valid = 0;
-		cuckoo_hash_remove(&fwd_set->fwd_hash_table, 
-				   (cuckoo_hash_key *)(&key));
-		NETBACK_ACCEL_STATS_OP(global_stats.num_fwds--);
-	}
-	spin_unlock_irqrestore(&fwd_set->fwd_lock, flags);
-
-	/*
-	 * No need to tell frontend that this is no longer present -
-	 * the frontend is currently only interested in remote
-	 * addresses and it works these out (mostly) by itself
-	 */
-}
-
-
-/* Set the context pointer for a hash table entry. */
-int netback_accel_fwd_set_context(const __u8 *mac, void *context, 
-				  void *fwd_priv)
-{
-	struct fwd_struct *fwd;
-	unsigned long flags;
-	int rc = -ENOENT;
-	struct port_fwd *fwd_set = (struct port_fwd *)fwd_priv;
-
-	BUG_ON(fwd_priv == NULL);
-
-	spin_lock_irqsave(&fwd_set->fwd_lock, flags);
-	fwd = fwd_find_entry(mac, fwd_set);
-	if (fwd != NULL) {
-		fwd->context = context;
-		rc = 0;
-	}
-	spin_unlock_irqrestore(&fwd_set->fwd_lock, flags);
-	return rc;
-}
-
-
-/**************************************************************************
- * Process a received packet
- **************************************************************************/
-
-/*
- * Returns whether or not we have a match in our forward table for the
- * this skb. Must be called with appropriate fwd_lock already held
- */
-static struct netback_accel *for_a_vnic(struct netback_pkt_buf *skb, 
-					struct port_fwd *fwd_set)
-{
-	struct fwd_struct *fwd;
-	struct netback_accel *retval = NULL;
-
-	fwd = fwd_find_entry(skb->mac.raw, fwd_set);
-	if (fwd != NULL)
-		retval = fwd->context;
-	return retval;
-}
-
-
-static inline int packet_is_arp_reply(struct sk_buff *skb)
-{
-	return skb->protocol == ntohs(ETH_P_ARP) 
-		&& arp_hdr(skb)->ar_op == ntohs(ARPOP_REPLY);
-}
-
-
-static inline void hdr_to_filt(struct ethhdr *ethhdr, struct iphdr *ip,
-			       struct netback_accel_filter_spec *spec)
-{
-	spec->proto = ip->protocol;
-	spec->destip_be = ip->daddr;
-	memcpy(spec->mac, ethhdr->h_source, ETH_ALEN);
-
-	if (ip->protocol == IPPROTO_TCP) {
-		struct tcphdr *tcp = (struct tcphdr *)((char *)ip + 4 * ip->ihl);
-		spec->destport_be = tcp->dest;
-	} else {
-		struct udphdr *udp = (struct udphdr *)((char *)ip + 4 * ip->ihl);
-		EPRINTK_ON(ip->protocol != IPPROTO_UDP);
-		spec->destport_be = udp->dest;
-	}
-}
-
-
-static inline int netback_accel_can_filter(struct netback_pkt_buf *skb) 
-{
-	return (skb->protocol == htons(ETH_P_IP) && 
-		((skb->nh.iph->protocol == IPPROTO_TCP) ||
-		 (skb->nh.iph->protocol == IPPROTO_UDP)));
-}
-
-
-static inline void netback_accel_filter_packet(struct netback_accel *bend,
-					       struct netback_pkt_buf *skb)
-{
-	struct netback_accel_filter_spec fs;
-	struct ethhdr *eh = (struct ethhdr *)(skb->mac.raw);
-
-	hdr_to_filt(eh, skb->nh.iph, &fs);
-	
-	netback_accel_filter_check_add(bend, &fs);
-}
-
-
-/*
- * Receive a packet and do something appropriate with it. Return true
- * to take exclusive ownership of the packet.  This is verging on
- * solarflare specific
- */
-void netback_accel_rx_packet(struct netback_pkt_buf *skb, void *fwd_priv)
-{
-	struct netback_accel *bend;
-	struct port_fwd *fwd_set = (struct port_fwd *)fwd_priv;
-	unsigned long flags;
-
-	BUG_ON(fwd_priv == NULL);
-
-	/* Checking for bcast is cheaper so do that first */
-	if (is_broadcast_ether_addr(skb->mac.raw)) {
-		/* pass through the slow path by not claiming ownership */
-		return;
-	} else if (is_multicast_ether_addr(skb->mac.raw)) {
-		/* pass through the slow path by not claiming ownership */
-		return;
-	} else {
-		/* It is unicast */
-		spin_lock_irqsave(&fwd_set->fwd_lock, flags);
-		/* We insert filter to pass it off to a VNIC */
-		if ((bend = for_a_vnic(skb, fwd_set)) != NULL)
-			if (netback_accel_can_filter(skb))
-				netback_accel_filter_packet(bend, skb);
-		spin_unlock_irqrestore(&fwd_set->fwd_lock, flags);
-	}
-	return;
-}
-
-
-void netback_accel_tx_packet(struct sk_buff *skb, void *fwd_priv) 
-{
-	__u8 *mac;
-	unsigned long flags;
-	struct port_fwd *fwd_set = (struct port_fwd *)fwd_priv;
-	struct fwd_struct *fwd;
-
-	BUG_ON(fwd_priv == NULL);
-
-	if (is_broadcast_ether_addr(skb_mac_header(skb))
-	    && packet_is_arp_reply(skb)) {
-		/*
-		 * update our fast path forwarding to reflect this
-		 * gratuitous ARP
-		 */ 
-		mac = skb_mac_header(skb)+ETH_ALEN;
-
-		DPRINTK("%s: found gratuitous ARP for %pM\n",
-			__FUNCTION__, mac);
-
-		spin_lock_irqsave(&fwd_set->fwd_lock, flags);
-		/*
-		 * Might not be local, but let's tell them all it is,
-		 * and they can restore the fastpath if they continue
-		 * to get packets that way
-		 */
-		list_for_each_entry(fwd, &fwd_set->fwd_list, link) {
-			struct netback_accel *bend = fwd->context;
-			if (bend != NULL)
-				netback_accel_msg_tx_new_localmac(bend, mac);
-		}
-
-		spin_unlock_irqrestore(&fwd_set->fwd_lock, flags);
-	}
-	return;
-}
diff -r 9566a4a50a43 drivers/xen/sfc_netback/accel_msg.c
--- a/drivers/xen/sfc_netback/accel_msg.c
+++ /dev/null
@@ -1,391 +0,0 @@
-/****************************************************************************
- * Solarflare driver for Xen network acceleration
- *
- * Copyright 2006-2008: Solarflare Communications Inc,
- *                      9501 Jeronimo Road, Suite 250,
- *                      Irvine, CA 92618, USA
- *
- * Maintained by Solarflare Communications <linux-xen-drivers@solarflare.com>
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 as published
- * by the Free Software Foundation, incorporated herein by reference.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
- ****************************************************************************
- */
-
-#include <xen/evtchn.h>
-
-#include "accel.h"
-#include "accel_msg_iface.h"
-#include "accel_util.h"
-#include "accel_solarflare.h"
-
-/* Send a HELLO to front end to start things off */
-void netback_accel_msg_tx_hello(struct netback_accel *bend, unsigned version)
-{
-	unsigned long lock_state;
-	struct net_accel_msg *msg = 
-		net_accel_msg_start_send(bend->shared_page,
-					 &bend->to_domU, &lock_state);
-	/* The queue _cannot_ be full, we're the first users. */
-	EPRINTK_ON(msg == NULL);
-
-	if (msg != NULL) {
-		net_accel_msg_init(msg, NET_ACCEL_MSG_HELLO);
-		msg->u.hello.version = version;
-		msg->u.hello.max_pages = bend->quotas.max_buf_pages; 
-		VPRINTK("Sending hello to channel %d\n", bend->msg_channel);
-		net_accel_msg_complete_send_notify(bend->shared_page, 
-						   &bend->to_domU,
-						   &lock_state, 
-						   bend->msg_channel_irq);
-	}
-}
-
-/* Send a local mac message to vnic */
-static void netback_accel_msg_tx_localmac(struct netback_accel *bend, 
-					  int type, const void *mac)
-{
-	unsigned long lock_state;
-	struct net_accel_msg *msg;
-
-	BUG_ON(bend == NULL || mac == NULL);
-
-	VPRINTK("Sending local mac message: %pM\n", mac);
-	
-	msg = net_accel_msg_start_send(bend->shared_page, &bend->to_domU,
-				       &lock_state);
-	
-	if (msg != NULL) {
-		net_accel_msg_init(msg, NET_ACCEL_MSG_LOCALMAC);
-		msg->u.localmac.flags = type;
-		memcpy(msg->u.localmac.mac, mac, ETH_ALEN);
-		net_accel_msg_complete_send_notify(bend->shared_page, 
-						   &bend->to_domU,
-						   &lock_state, 
-						   bend->msg_channel_irq);
-	} else {
-		/*
-		 * TODO if this happens we may leave a domU
-		 * fastpathing packets when they should be delivered
-		 * locally.  Solution is get domU to timeout entries
-		 * in its fastpath lookup table when it receives no RX
-		 * traffic
-		 */
-		EPRINTK("%s: saw full queue, may need ARP timer to recover\n",
-			__FUNCTION__);
-	}
-}
-
-/* Send an add local mac message to vnic */
-void netback_accel_msg_tx_new_localmac(struct netback_accel *bend,
-				       const void *mac)
-{
-	netback_accel_msg_tx_localmac(bend, NET_ACCEL_MSG_ADD, mac);
-}
-
-
-static int netback_accel_msg_rx_buffer_map(struct netback_accel *bend, 
-					   struct net_accel_msg *msg)
-{
-	int log2_pages, rc;
-
-	/* Can only allocate in power of two */
-	log2_pages = log2_ge(msg->u.mapbufs.pages, 0);
-	if (msg->u.mapbufs.pages != pow2(log2_pages)) {
-		EPRINTK("%s: Can only alloc bufs in power of 2 sizes (%d)\n",
-			__FUNCTION__, msg->u.mapbufs.pages);
-		rc = -EINVAL;
-		goto err_out;
-	}
-  
-	/*
-	 * Sanity.  Assumes NET_ACCEL_MSG_MAX_PAGE_REQ is same for
-	 * both directions/domains
-	 */
-	if (msg->u.mapbufs.pages > NET_ACCEL_MSG_MAX_PAGE_REQ) {
-		EPRINTK("%s: too many pages in a single message: %d %d\n", 
-			__FUNCTION__, msg->u.mapbufs.pages,
-			NET_ACCEL_MSG_MAX_PAGE_REQ);
-		rc = -EINVAL;
-		goto err_out;
-	}
-  
-	if ((rc = netback_accel_add_buffers(bend, msg->u.mapbufs.pages, 
-					    log2_pages, msg->u.mapbufs.grants, 
-					    &msg->u.mapbufs.buf)) < 0) {
-		goto err_out;
-	}
-
-	msg->id |= NET_ACCEL_MSG_REPLY;
-  
-	return 0;
-
- err_out:
-	EPRINTK("%s: err_out\n", __FUNCTION__);
-	msg->id |= NET_ACCEL_MSG_ERROR | NET_ACCEL_MSG_REPLY;
-	return rc;
-}
-
-
-/* Hint from frontend that one of our filters is out of date */
-static int netback_accel_process_fastpath(struct netback_accel *bend, 
-					  struct net_accel_msg *msg)
-{
-	struct netback_accel_filter_spec spec;
-
-	if (msg->u.fastpath.flags & NET_ACCEL_MSG_REMOVE) {
-		/* 
-		 * Would be nice to BUG() this but would leave us
-		 * vulnerable to naughty frontend
-		 */
-		EPRINTK_ON(msg->u.fastpath.flags & NET_ACCEL_MSG_ADD);
-		
-		memcpy(spec.mac, msg->u.fastpath.mac, ETH_ALEN);
-		spec.destport_be = msg->u.fastpath.port;
-		spec.destip_be = msg->u.fastpath.ip;
-		spec.proto = msg->u.fastpath.proto;
-
-		netback_accel_filter_remove_spec(bend, &spec);
-	}
-
-	return 0;
-}
-
-
-/* Flow control for message queues */
-inline void set_queue_not_full(struct netback_accel *bend)
-{
-	if (!test_and_set_bit(NET_ACCEL_MSG_AFLAGS_QUEUEUNOTFULL_B, 
-			      (unsigned long *)&bend->shared_page->aflags))
-		notify_remote_via_irq(bend->msg_channel_irq);
-	else
-		VPRINTK("queue not full bit already set, not signalling\n");
-}
-
-
-/* Flow control for message queues */
-inline void set_queue_full(struct netback_accel *bend)
-{
-	if (!test_and_set_bit(NET_ACCEL_MSG_AFLAGS_QUEUE0FULL_B,
-			      (unsigned long *)&bend->shared_page->aflags))
-		notify_remote_via_irq(bend->msg_channel_irq);
-	else
-		VPRINTK("queue full bit already set, not signalling\n");
-}
-
-
-void netback_accel_set_interface_state(struct netback_accel *bend, int up)
-{
-	bend->shared_page->net_dev_up = up;
-	if (!test_and_set_bit(NET_ACCEL_MSG_AFLAGS_NETUPDOWN_B, 
-			     (unsigned long *)&bend->shared_page->aflags))
-		notify_remote_via_irq(bend->msg_channel_irq);
-	else
-		VPRINTK("interface up/down bit already set, not signalling\n");
-}
-
-
-static int check_rx_hello_version(unsigned version) 
-{
-	/* Should only happen if there's been a version mismatch */
-	BUG_ON(version == NET_ACCEL_MSG_VERSION);
-
-	if (version > NET_ACCEL_MSG_VERSION) {
-		/* Newer protocol, we must refuse */
-		return -EPROTO;
-	}
-
-	if (version < NET_ACCEL_MSG_VERSION) {
-		/*
-		 * We are newer, so have discretion to accept if we
-		 * wish.  For now however, just reject
-		 */
-		return -EPROTO;
-	}
-
-	return -EINVAL;
-}
-
-
-static int process_rx_msg(struct netback_accel *bend,
-			  struct net_accel_msg *msg)
-{
-	int err = 0;
-		      
-	switch (msg->id) {
-	case NET_ACCEL_MSG_REPLY | NET_ACCEL_MSG_HELLO:
-		/* Reply to a HELLO; mark ourselves as connected */
-		DPRINTK("got Hello reply, version %.8x\n",
-			msg->u.hello.version);
-		
-		/*
-		 * Check that we've not successfully done this
-		 * already.  NB no check at the moment that this reply
-		 * comes after we've actually sent a HELLO as that's
-		 * not possible with the current code structure
-		 */
-		if (bend->hw_state != NETBACK_ACCEL_RES_NONE)
-			return -EPROTO;
-
-		/* Store max_pages for accel_setup */
-		if (msg->u.hello.max_pages > bend->quotas.max_buf_pages) {
-			EPRINTK("More pages than quota allows (%d > %d)\n",
-				msg->u.hello.max_pages, 
-				bend->quotas.max_buf_pages);
-			/* Force it down to the quota */
-			msg->u.hello.max_pages = bend->quotas.max_buf_pages;
-		}
-		bend->max_pages = msg->u.hello.max_pages;
-		
-		/* Set up the hardware visible to the other end */
-		err = bend->accel_setup(bend);
-		if (err) {
-			/* This is fatal */
-			DPRINTK("Hello gave accel_setup error %d\n", err);
-			netback_accel_set_closing(bend);
-		} else {
-			/*
-			 * Now add the context so that packet
-			 * forwarding will commence
-			 */
-			netback_accel_fwd_set_context(bend->mac, bend, 
-						      bend->fwd_priv);
-		}
-		break;
-	case NET_ACCEL_MSG_REPLY | NET_ACCEL_MSG_HELLO | NET_ACCEL_MSG_ERROR:
-		EPRINTK("got Hello error, versions us:%.8x them:%.8x\n",
-			NET_ACCEL_MSG_VERSION, msg->u.hello.version);
-
-		if (bend->hw_state != NETBACK_ACCEL_RES_NONE)
-			return -EPROTO;
-
-		if (msg->u.hello.version != NET_ACCEL_MSG_VERSION) {
-			/* Error is due to version mismatch */
-			err = check_rx_hello_version(msg->u.hello.version);
-			if (err == 0) {
-				/*
-				 * It's OK to be compatible, send
-				 * another hello with compatible version
-				 */
-				netback_accel_msg_tx_hello
-					(bend, msg->u.hello.version);
-			} else {
-				/*
-				 * Tell frontend that we're not going to
-				 * send another HELLO by going to Closing.
-				 */
-				netback_accel_set_closing(bend);
-			}
-		} 
-		break;
-	case NET_ACCEL_MSG_MAPBUF:
-		VPRINTK("Got mapped buffers request %d\n",
-			msg->u.mapbufs.reqid);
-
-		if (bend->hw_state == NETBACK_ACCEL_RES_NONE)
-			return -EPROTO;
-
-		/*
-		 * Frontend wants a buffer table entry for the
-		 * supplied pages
-		 */
-		err = netback_accel_msg_rx_buffer_map(bend, msg);
-		if (net_accel_msg_reply_notify(bend->shared_page,
-					       bend->msg_channel_irq, 
-					       &bend->to_domU, msg)) {
-			/*
-			 * This is fatal as we can't tell the frontend
-			 * about the problem through the message
-			 * queue, and so would otherwise stalemate
-			 */
-			netback_accel_set_closing(bend);
-		}
-		break;
-	case NET_ACCEL_MSG_FASTPATH:
-		DPRINTK("Got fastpath request\n");
-
-		if (bend->hw_state == NETBACK_ACCEL_RES_NONE)
-			return -EPROTO;
-
-		err = netback_accel_process_fastpath(bend, msg);
-		break;
-	default:
-		EPRINTK("Huh? Message code is %x\n", msg->id);
-		err = -EPROTO;
-		break;
-	}
-	return err;
-}
-
-
-/*  Demultiplex an IRQ from the frontend driver.  */
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,20)
-void netback_accel_msg_rx_handler(struct work_struct *arg)
-#else
-void netback_accel_msg_rx_handler(void *bend_void)
-#endif
-{
-	struct net_accel_msg msg;
-	int err, queue_was_full = 0;
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,20)
-	struct netback_accel *bend = 
-		container_of(arg, struct netback_accel, handle_msg);
-#else
-	struct netback_accel *bend = (struct netback_accel *)bend_void;
-#endif
-
-	mutex_lock(&bend->bend_mutex);
-
-	/*
-	 * This happens when the shared pages have been unmapped, but
-	 * the workqueue not flushed yet
-	 */
-	if (bend->shared_page == NULL)
-		goto done;
-
-	if ((bend->shared_page->aflags &
-	     NET_ACCEL_MSG_AFLAGS_TO_DOM0_MASK) != 0) {
-		if (bend->shared_page->aflags &
-		    NET_ACCEL_MSG_AFLAGS_QUEUE0NOTFULL) {
-			/* We've been told there may now be space. */
-			clear_bit(NET_ACCEL_MSG_AFLAGS_QUEUE0NOTFULL_B, 
-				  (unsigned long *)&bend->shared_page->aflags);
-		}
-
-		if (bend->shared_page->aflags &
-		    NET_ACCEL_MSG_AFLAGS_QUEUEUFULL) {
-			clear_bit(NET_ACCEL_MSG_AFLAGS_QUEUEUFULL_B, 
-				  (unsigned long *)&bend->shared_page->aflags);
-			queue_was_full = 1;
-		}
-	}
-
-	while ((err = net_accel_msg_recv(bend->shared_page, &bend->from_domU,
-					 &msg)) == 0) {
-		err = process_rx_msg(bend, &msg);
-		
-		if (err != 0) {
-			EPRINTK("%s: Error %d\n", __FUNCTION__, err);
-			goto err;
-		}
-	}
-
- err:
-	/* There will be space now if we can make any. */
-	if (queue_was_full) 
-		set_queue_not_full(bend);
- done:
-	mutex_unlock(&bend->bend_mutex);
-
-	return;
-}
diff -r 9566a4a50a43 drivers/xen/sfc_netback/accel_solarflare.c
--- a/drivers/xen/sfc_netback/accel_solarflare.c
+++ /dev/null
@@ -1,1293 +0,0 @@
-/****************************************************************************
- * Solarflare driver for Xen network acceleration
- *
- * Copyright 2006-2008: Solarflare Communications Inc,
- *                      9501 Jeronimo Road, Suite 250,
- *                      Irvine, CA 92618, USA
- *
- * Maintained by Solarflare Communications <linux-xen-drivers@solarflare.com>
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 as published
- * by the Free Software Foundation, incorporated herein by reference.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
- ****************************************************************************
- */
-
-#include "common.h"
-
-#include "accel.h"
-#include "accel_solarflare.h"
-#include "accel_msg_iface.h"
-#include "accel_util.h"
-
-#include "accel_cuckoo_hash.h"
-
-#include "ci/driver/resource/efx_vi.h"
-
-#include "ci/efrm/nic_table.h" 
-#include "ci/efhw/public.h"
-
-#include <xen/evtchn.h>
-#include <xen/driver_util.h>
-#include <linux/list.h>
-#include <linux/mutex.h>
-
-#include "driverlink_api.h"
-
-#define SF_XEN_RX_USR_BUF_SIZE 2048
-
-struct falcon_bend_accel_priv {
-	struct efx_vi_state *efx_vih;
-
-	/*! Array of pointers to dma_map state, used so VNIC can
-	 *  request their removal in a single message
-	 */
-	struct efx_vi_dma_map_state **dma_maps;
-	/*! Index into dma_maps */
-	int dma_maps_index; 
-
-	/*! Serialises access to filters */
-	spinlock_t filter_lock;	     
-	/*! Bitmap of which filters are free */
-	unsigned long free_filters;	 
-	/*! Used for index normalisation */
-	u32 filter_idx_mask;		
-	struct netback_accel_filter_spec *fspecs; 
-	cuckoo_hash_table filter_hash_table;
-
-	u32 txdmaq_gnt;
-	u32 rxdmaq_gnt;
-	u32 doorbell_gnt;
-	u32 evq_rptr_gnt;
-	u32 evq_mem_gnts[EF_HW_FALCON_EVQ_PAGES];
-	u32 evq_npages;
-};
-
-/* Forward declaration */
-static int netback_accel_filter_init(struct netback_accel *);
-static void netback_accel_filter_shutdown(struct netback_accel *);
-
-/**************************************************************************
- * 
- * Driverlink stuff
- *
- **************************************************************************/
-
-struct driverlink_port {
-	struct list_head link;
-	enum net_accel_hw_type type;
-	struct net_device *net_dev;
-	struct efx_dl_device *efx_dl_dev;
-	void *fwd_priv;
-};
-
-static struct list_head dl_ports;
-
-/* This mutex protects global state, such as the dl_ports list */
-DEFINE_MUTEX(accel_mutex);
-
-static int init_done = 0;
-
-/* The DL callbacks */
-
-
-#if defined(EFX_USE_FASTCALL)
-static enum efx_veto fastcall
-#else
-static enum efx_veto
-#endif
-bend_dl_tx_packet(struct efx_dl_device *efx_dl_dev,
-		  struct sk_buff *skb)
-{
-	struct driverlink_port *port = efx_dl_dev->priv;
-
-	BUG_ON(port == NULL);
-
-	NETBACK_ACCEL_STATS_OP(global_stats.dl_tx_packets++);
-	if (skb_mac_header_was_set(skb))
-		netback_accel_tx_packet(skb, port->fwd_priv);
-	else {
-		DPRINTK("Ignoring packet with missing mac address\n");
-		NETBACK_ACCEL_STATS_OP(global_stats.dl_tx_bad_packets++);
-	}
-	return EFX_ALLOW_PACKET;
-}
-
-/* EFX_USE_FASTCALL */
-#if defined(EFX_USE_FASTCALL)
-static enum efx_veto fastcall
-#else
-static enum efx_veto
-#endif
-bend_dl_rx_packet(struct efx_dl_device *efx_dl_dev,
-		  const char *pkt_buf, int pkt_len)
-{
-	struct driverlink_port *port = efx_dl_dev->priv;
-	struct netback_pkt_buf pkt;
-	struct ethhdr *eh;
-
-	BUG_ON(port == NULL);
-
-	pkt.mac.raw = (char *)pkt_buf;
-	pkt.nh.raw = (char *)pkt_buf + ETH_HLEN;
-	eh = (struct ethhdr *)pkt_buf;
-	pkt.protocol = eh->h_proto;
-
-	NETBACK_ACCEL_STATS_OP(global_stats.dl_rx_packets++);
-	netback_accel_rx_packet(&pkt, port->fwd_priv);
-	return EFX_ALLOW_PACKET;
-}
-
-
-/* Callbacks we'd like to get from the netdriver through driverlink */
-struct efx_dl_callbacks bend_dl_callbacks =
-	{
-		.tx_packet = bend_dl_tx_packet,
-		.rx_packet = bend_dl_rx_packet,
-	};
-
-
-static struct netback_accel_hooks accel_hooks = {
-	THIS_MODULE,
-	&netback_accel_probe,
-	&netback_accel_remove
-};
-
-
-/* Driver link probe - register our callbacks */
-static int bend_dl_probe(struct efx_dl_device *efx_dl_dev,
-			 const struct net_device *net_dev,
-			 const struct efx_dl_device_info *dev_info,
-			 const char* silicon_rev)
-{
-	int rc;
-	enum net_accel_hw_type type;
-	struct driverlink_port *port;
-
-	DPRINTK("%s: %s\n", __FUNCTION__, silicon_rev);
-
-	if (strcmp(silicon_rev, "falcon/a1") == 0)
-		type = NET_ACCEL_MSG_HWTYPE_FALCON_A;
-	else if (strcmp(silicon_rev, "falcon/b0") == 0)
-		type = NET_ACCEL_MSG_HWTYPE_FALCON_B;
-	else if (strcmp(silicon_rev, "siena/a0") == 0)
-		type = NET_ACCEL_MSG_HWTYPE_SIENA_A;
-	else {
-		EPRINTK("%s: unsupported silicon %s\n", __FUNCTION__,
-			silicon_rev);
-		rc = -EINVAL;
-		goto fail1;
-	}
-	
-	port = kmalloc(sizeof(struct driverlink_port), GFP_KERNEL);
-	if (port == NULL) {
-		EPRINTK("%s: no memory for dl probe\n", __FUNCTION__);
-		rc = -ENOMEM;
-		goto fail1;
-	}
-
-	port->efx_dl_dev = efx_dl_dev;
-	efx_dl_dev->priv = port;
-
-	port->fwd_priv = netback_accel_init_fwd_port();
-	if (port->fwd_priv == NULL) {
-		EPRINTK("%s: failed to set up forwarding for port\n",
-			__FUNCTION__);
-		rc = -ENOMEM;
-		goto fail2;
-	}
-
-	rc = efx_dl_register_callbacks(efx_dl_dev, &bend_dl_callbacks);
-	if (rc != 0) {
-		EPRINTK("%s: register_callbacks failed\n", __FUNCTION__);
-		goto fail3;
-	}
-
-	port->type = type;
-	port->net_dev = (struct net_device *)net_dev;
-
-	mutex_lock(&accel_mutex);
-	list_add(&port->link, &dl_ports);
-	mutex_unlock(&accel_mutex);
-
-	rc = netback_connect_accelerator(NETBACK_ACCEL_VERSION, 0,
-					 port->net_dev->name, &accel_hooks);
-
-	if (rc < 0) {
-		EPRINTK("Xen netback accelerator version mismatch\n");
-		goto fail4;
-	} else if (rc > 0) {
-		/*
-		 * In future may want to add backwards compatibility
-		 * and accept certain subsets of previous versions
-		 */
-		EPRINTK("Xen netback accelerator version mismatch\n");
-		goto fail4;
-	} 
-
-	return 0;
-
- fail4:
-	mutex_lock(&accel_mutex);
-	list_del(&port->link);
-	mutex_unlock(&accel_mutex);
-
-	efx_dl_unregister_callbacks(efx_dl_dev, &bend_dl_callbacks);
- fail3: 
-	netback_accel_shutdown_fwd_port(port->fwd_priv);
- fail2:
-	efx_dl_dev->priv = NULL;
-	kfree(port);
- fail1:
-	return rc;
-}
-
-
-static void bend_dl_remove(struct efx_dl_device *efx_dl_dev)
-{
-	struct driverlink_port *port;
-
-	DPRINTK("Unregistering driverlink callbacks.\n");
-
-	mutex_lock(&accel_mutex);
-
-	port = (struct driverlink_port *)efx_dl_dev->priv;
-
-	BUG_ON(list_empty(&dl_ports));
-	BUG_ON(port == NULL);
-	BUG_ON(port->efx_dl_dev != efx_dl_dev);
-
-	netback_disconnect_accelerator(0, port->net_dev->name);
-
-	list_del(&port->link);
-
-	mutex_unlock(&accel_mutex);
-
-	efx_dl_unregister_callbacks(efx_dl_dev, &bend_dl_callbacks);
-	netback_accel_shutdown_fwd_port(port->fwd_priv);
-
-	efx_dl_dev->priv = NULL;
-	kfree(port);
-
-	return;
-}
-
-
-static void bend_dl_reset_suspend(struct efx_dl_device *efx_dl_dev)
-{
-	struct driverlink_port *port;
-
-	DPRINTK("Driverlink reset suspend.\n");
-
-	mutex_lock(&accel_mutex);
-
-	port = (struct driverlink_port *)efx_dl_dev->priv;
-	BUG_ON(list_empty(&dl_ports));
-	BUG_ON(port == NULL);
-	BUG_ON(port->efx_dl_dev != efx_dl_dev);
-
-	netback_disconnect_accelerator(0, port->net_dev->name);
-	mutex_unlock(&accel_mutex);
-}
-
-
-static void bend_dl_reset_resume(struct efx_dl_device *efx_dl_dev, int ok)
-{
-	int rc;
-	struct driverlink_port *port;
-
-	DPRINTK("Driverlink reset resume.\n");
-	
-	if (!ok)
-		return;
-
-	port = (struct driverlink_port *)efx_dl_dev->priv;
-	BUG_ON(list_empty(&dl_ports));
-	BUG_ON(port == NULL);
-	BUG_ON(port->efx_dl_dev != efx_dl_dev);
-
-	rc = netback_connect_accelerator(NETBACK_ACCEL_VERSION, 0,
-					 port->net_dev->name, &accel_hooks);
-	if (rc != 0) {
-		EPRINTK("Xen netback accelerator version mismatch\n");
-
-		mutex_lock(&accel_mutex);
-		list_del(&port->link);
-		mutex_unlock(&accel_mutex);
-
-		efx_dl_unregister_callbacks(efx_dl_dev, &bend_dl_callbacks);
-
-		netback_accel_shutdown_fwd_port(port->fwd_priv);
-
-		efx_dl_dev->priv = NULL;
-		kfree(port);
-	}
-}
-
-
-static struct efx_dl_driver bend_dl_driver = 
-	{
-		.name = "SFC Xen backend",
-		.probe = bend_dl_probe,
-		.remove = bend_dl_remove,
-		.reset_suspend = bend_dl_reset_suspend,
-		.reset_resume = bend_dl_reset_resume
-	};
-
-
-int netback_accel_sf_init(void)
-{
-	int rc, nic_i;
-	struct efhw_nic *nic;
-
-	INIT_LIST_HEAD(&dl_ports);
-
-	rc = efx_dl_register_driver(&bend_dl_driver);
-	/* If we couldn't find the NET driver, give up */
-	if (rc == -ENOENT)
-		return rc;
-	
-	if (rc == 0) {
-		EFRM_FOR_EACH_NIC(nic_i, nic)
-			falcon_nic_set_rx_usr_buf_size(nic, 
-						       SF_XEN_RX_USR_BUF_SIZE);
-	}
-
-	init_done = (rc == 0);
-	return rc;
-}
-
-
-void netback_accel_sf_shutdown(void)
-{
-	if (!init_done)
-		return;
-	DPRINTK("Unregistering driverlink driver\n");
-
-	/*
-	 * This will trigger removal callbacks for all the devices, which
-	 * will unregister their callbacks, disconnect from netfront, etc.
-	 */
-	efx_dl_unregister_driver(&bend_dl_driver);
-}
-
-
-int netback_accel_sf_hwtype(struct netback_accel *bend)
-{
-	struct driverlink_port *port;
-
-	mutex_lock(&accel_mutex);
-
-	list_for_each_entry(port, &dl_ports, link) {
-		if (strcmp(bend->nicname, port->net_dev->name) == 0) {
-			bend->hw_type = port->type;
-			bend->accel_setup = netback_accel_setup_vnic_hw;
-			bend->accel_shutdown = netback_accel_shutdown_vnic_hw;
-			bend->fwd_priv = port->fwd_priv;
-			bend->net_dev = port->net_dev;
-			mutex_unlock(&accel_mutex);
-			return 0;
-		}
-	}
-
-	mutex_unlock(&accel_mutex);
-
-	EPRINTK("Failed to identify backend device '%s' with a NIC\n",
-		bend->nicname);
-
-	return -ENOENT;
-}
-
-
-/****************************************************************************
- * Resource management code
- ***************************************************************************/
-
-static int alloc_page_state(struct netback_accel *bend, int max_pages)
-{
-	struct falcon_bend_accel_priv *accel_hw_priv;
-
-	if (max_pages < 0 || max_pages > bend->quotas.max_buf_pages) {
-		EPRINTK("%s: invalid max_pages: %d\n", __FUNCTION__, max_pages);
-		return -EINVAL;
-	}
-
-	accel_hw_priv = kzalloc(sizeof(struct falcon_bend_accel_priv),
-				GFP_KERNEL);
-	if (accel_hw_priv == NULL) {
-		EPRINTK("%s: no memory for accel_hw_priv\n", __FUNCTION__);
-		return -ENOMEM;
-	}
-
-	accel_hw_priv->dma_maps = kzalloc
-		(sizeof(struct efx_vi_dma_map_state **) * 
-		 (max_pages / NET_ACCEL_MSG_MAX_PAGE_REQ), GFP_KERNEL);
-	if (accel_hw_priv->dma_maps == NULL) {
-		EPRINTK("%s: no memory for dma_maps\n", __FUNCTION__);
-		kfree(accel_hw_priv);
-		return -ENOMEM;
-	}
-
-	bend->buffer_maps = kzalloc(sizeof(struct vm_struct *) * max_pages, 
-				    GFP_KERNEL);
-	if (bend->buffer_maps == NULL) {
-		EPRINTK("%s: no memory for buffer_maps\n", __FUNCTION__);
-		kfree(accel_hw_priv->dma_maps);
-		kfree(accel_hw_priv);
-		return -ENOMEM;
-	}
-
-	bend->buffer_addrs = kzalloc(sizeof(u64) * max_pages, GFP_KERNEL);
-	if (bend->buffer_addrs == NULL) {
-		kfree(bend->buffer_maps);
-		kfree(accel_hw_priv->dma_maps);
-		kfree(accel_hw_priv);
-		return -ENOMEM;
-	}
-
-	bend->accel_hw_priv = accel_hw_priv;
-
-	return 0;
-}
-
-
-static int free_page_state(struct netback_accel *bend)
-{
-	struct falcon_bend_accel_priv *accel_hw_priv;
-
-	DPRINTK("%s: %p\n", __FUNCTION__, bend);
-
-	accel_hw_priv = bend->accel_hw_priv;
-
-	if (accel_hw_priv) {
-		kfree(accel_hw_priv->dma_maps);
-		kfree(bend->buffer_maps);
-		kfree(bend->buffer_addrs);
-		kfree(accel_hw_priv);
-		bend->accel_hw_priv = NULL;
-		bend->max_pages = 0;
-	}
-
-	return 0;
-}
-
-
-/* The timeout event callback for the event q */
-static void bend_evq_timeout(void *context, int is_timeout)
-{
-	struct netback_accel *bend = (struct netback_accel *)context;
-	if (is_timeout) {
-		/* Pass event to vnic front end driver */
-		VPRINTK("timeout event to %d\n", bend->net_channel);
-		NETBACK_ACCEL_STATS_OP(bend->stats.evq_timeouts++);
-		notify_remote_via_irq(bend->net_channel_irq);
-	} else {
-		/* It's a wakeup event, used by Falcon */
-		VPRINTK("wakeup to %d\n", bend->net_channel);
-		NETBACK_ACCEL_STATS_OP(bend->stats.evq_wakeups++);
-		notify_remote_via_irq(bend->net_channel_irq);
-	}
-}
-
-
-/*
- * Create the eventq and associated gubbins for communication with the
- * front end vnic driver
- */
-static int ef_get_vnic(struct netback_accel *bend)
-{
-	struct falcon_bend_accel_priv *accel_hw_priv;
-	int rc = 0;
-
-	BUG_ON(bend->hw_state != NETBACK_ACCEL_RES_NONE);
-
-	/* Allocate page related state and accel_hw_priv */
-	rc = alloc_page_state(bend, bend->max_pages);
-	if (rc != 0) {
-		EPRINTK("Failed to allocate page state: %d\n", rc);
-		return rc;
-	}
-
-	accel_hw_priv = bend->accel_hw_priv;
-
-	rc = efx_vi_alloc(&accel_hw_priv->efx_vih, bend->net_dev->ifindex);
-	if (rc != 0) {
-		EPRINTK("%s: efx_vi_alloc failed %d\n", __FUNCTION__, rc);
-		free_page_state(bend);
-		return rc;
-	}
-
-	rc = efx_vi_eventq_register_callback(accel_hw_priv->efx_vih,
-					     bend_evq_timeout,
-					     bend);
-	if (rc != 0) {
-		EPRINTK("%s: register_callback failed %d\n", __FUNCTION__, rc);
-		efx_vi_free(accel_hw_priv->efx_vih);
-		free_page_state(bend);
-		return rc;
-	}
-
-	bend->hw_state = NETBACK_ACCEL_RES_ALLOC;
-	
-	return 0;
-}
-
-
-static void ef_free_vnic(struct netback_accel *bend)
-{
-	struct falcon_bend_accel_priv *accel_hw_priv = bend->accel_hw_priv;
-
-	BUG_ON(bend->hw_state != NETBACK_ACCEL_RES_ALLOC);
-
-	efx_vi_eventq_kill_callback(accel_hw_priv->efx_vih);
-
-	DPRINTK("Hardware is freeable. Will proceed.\n");
-
-	efx_vi_free(accel_hw_priv->efx_vih);
-	accel_hw_priv->efx_vih = NULL;
-
-	VPRINTK("Free page state...\n");
-	free_page_state(bend);
-
-	bend->hw_state = NETBACK_ACCEL_RES_NONE;
-}
-
-
-static inline void ungrant_or_crash(grant_ref_t gntref, int domain) {
-	if (net_accel_ungrant_page(gntref) == -EBUSY)
-		net_accel_shutdown_remote(domain);
-}
-
-
-static void netback_accel_release_hwinfo(struct netback_accel *bend)
-{
-	struct falcon_bend_accel_priv *accel_hw_priv = bend->accel_hw_priv;
-	int i;
-
-	DPRINTK("Remove dma q grants %d %d\n", accel_hw_priv->txdmaq_gnt,
-		accel_hw_priv->rxdmaq_gnt);
-	ungrant_or_crash(accel_hw_priv->txdmaq_gnt, bend->far_end);
-	ungrant_or_crash(accel_hw_priv->rxdmaq_gnt, bend->far_end);
-
-	DPRINTK("Remove doorbell grant %d\n", accel_hw_priv->doorbell_gnt);
-	ungrant_or_crash(accel_hw_priv->doorbell_gnt, bend->far_end);
-
-	if (bend->hw_type == NET_ACCEL_MSG_HWTYPE_FALCON_A) {
-		DPRINTK("Remove rptr grant %d\n", accel_hw_priv->evq_rptr_gnt);
-		ungrant_or_crash(accel_hw_priv->evq_rptr_gnt, bend->far_end);
-	}
-
-	for (i = 0; i < accel_hw_priv->evq_npages; i++) {
-		DPRINTK("Remove evq grant %d\n", accel_hw_priv->evq_mem_gnts[i]);
-		ungrant_or_crash(accel_hw_priv->evq_mem_gnts[i], bend->far_end);
-	}
-
-	bend->hw_state = NETBACK_ACCEL_RES_FILTER;
-
-	return;
-}
-
-
-static int ef_bend_hwinfo_falcon_common(struct netback_accel *bend, 
-					struct net_accel_hw_falcon_b *hwinfo)
-{
-	struct falcon_bend_accel_priv *accel_hw_priv = bend->accel_hw_priv;
-	struct efx_vi_hw_resource_metadata res_mdata;
-	struct efx_vi_hw_resource res_array[EFX_VI_HW_RESOURCE_MAXSIZE];
-	int rc, len = EFX_VI_HW_RESOURCE_MAXSIZE, i, pfn = 0;
-	unsigned long txdmaq_pfn = 0, rxdmaq_pfn = 0;
-
-	rc = efx_vi_hw_resource_get_phys(accel_hw_priv->efx_vih, &res_mdata,
-					 res_array, &len);
-	if (rc != 0) {
-		DPRINTK("%s: resource_get_phys returned %d\n",
-			__FUNCTION__, rc);
-		return rc;
-	}
-
-	hwinfo->nic_arch = res_mdata.nic_arch;
-	hwinfo->nic_variant = res_mdata.nic_variant;
-	hwinfo->nic_revision = res_mdata.nic_revision;
-
-	hwinfo->evq_order = res_mdata.evq_order;
-	hwinfo->evq_offs = res_mdata.evq_offs;
-	hwinfo->evq_capacity = res_mdata.evq_capacity;
-	hwinfo->instance = res_mdata.instance;
-	hwinfo->rx_capacity = res_mdata.rx_capacity;
-	hwinfo->tx_capacity = res_mdata.tx_capacity;
-
-	VPRINTK("evq_order %d evq_offs %d evq_cap %d inst %d rx_cap %d tx_cap %d\n",
-		hwinfo->evq_order, hwinfo->evq_offs, hwinfo->evq_capacity,
-		hwinfo->instance, hwinfo->rx_capacity, hwinfo->tx_capacity);
-
-	for (i = 0; i < len; i++) {
-		struct efx_vi_hw_resource *res = &(res_array[i]);
-		switch (res->type) {
-		case EFX_VI_HW_RESOURCE_TXDMAQ:
-			txdmaq_pfn = page_to_pfn(virt_to_page(res->address));
-			break;
-		case EFX_VI_HW_RESOURCE_RXDMAQ: 
-			rxdmaq_pfn = page_to_pfn(virt_to_page(res->address));
-			break;
-		case EFX_VI_HW_RESOURCE_EVQTIMER:
-			break;
-		case EFX_VI_HW_RESOURCE_EVQRPTR:
-		case EFX_VI_HW_RESOURCE_EVQRPTR_OFFSET:
-			hwinfo->evq_rptr = res->address;
-			break;
-		case EFX_VI_HW_RESOURCE_EVQMEMKVA: 
-			accel_hw_priv->evq_npages =  1 << res_mdata.evq_order;
-			pfn = page_to_pfn(virt_to_page(res->address));
-			break;
-		case EFX_VI_HW_RESOURCE_BELLPAGE:
-			hwinfo->doorbell_mfn  = res->address;
-			break;
-		default:
-			EPRINTK("%s: Unknown hardware resource type %d\n",
-				__FUNCTION__, res->type);
-			break;
-		}
-	}
-
-	VPRINTK("Passing txdmaq page pfn %lx\n", txdmaq_pfn);
-	rc = net_accel_grant_page(bend->hdev_data, pfn_to_mfn(txdmaq_pfn), 0);
-	if (rc < 0)
-		goto fail0;
-	accel_hw_priv->txdmaq_gnt = hwinfo->txdmaq_gnt = rc;
-
-	VPRINTK("Passing rxdmaq page pfn %lx\n", rxdmaq_pfn);
-	rc = net_accel_grant_page(bend->hdev_data, pfn_to_mfn(rxdmaq_pfn), 0);
-	if (rc < 0)
-		goto fail1;
-	accel_hw_priv->rxdmaq_gnt = hwinfo->rxdmaq_gnt = rc;
-
-	VPRINTK("Passing doorbell page mfn %x\n", hwinfo->doorbell_mfn);
-	/* Make the relevant H/W pages mappable by the far end */
-	rc = net_accel_grant_page(bend->hdev_data, hwinfo->doorbell_mfn, 1);
-	if (rc < 0)
-		goto fail2;
-	accel_hw_priv->doorbell_gnt = hwinfo->doorbell_gnt = rc;
-	
-	/* Now do the same for the memory pages */
-	/* Convert the page + length we got back for the evq to grants. */
-	for (i = 0; i < accel_hw_priv->evq_npages; i++) {
-		rc = net_accel_grant_page(bend->hdev_data, pfn_to_mfn(pfn), 0);
-		if (rc < 0)
-			goto fail3;
-		accel_hw_priv->evq_mem_gnts[i] = hwinfo->evq_mem_gnts[i] = rc;
-
-		VPRINTK("Got grant %u for evq pfn %x\n", hwinfo->evq_mem_gnts[i], 
-			pfn);
-		pfn++;
-	}
-
-	return 0;
-
- fail3:
-	for (i = i - 1; i >= 0; i--) {
-		ungrant_or_crash(accel_hw_priv->evq_mem_gnts[i], bend->far_end);
-	}
-	ungrant_or_crash(accel_hw_priv->doorbell_gnt, bend->far_end);
- fail2:
-	ungrant_or_crash(accel_hw_priv->rxdmaq_gnt, bend->far_end);
- fail1:
-	ungrant_or_crash(accel_hw_priv->txdmaq_gnt, bend->far_end);	
- fail0:
-	return rc;
-}
-
-
-static int ef_bend_hwinfo_falcon_a(struct netback_accel *bend, 
-				   struct net_accel_hw_falcon_a *hwinfo)
-{
-	int rc, i;
-	struct falcon_bend_accel_priv *accel_hw_priv = bend->accel_hw_priv;
-
-	if ((rc = ef_bend_hwinfo_falcon_common(bend, &hwinfo->common)) != 0)
-		return rc;
-
-	/*
-	 * Note that unlike the above, where the message field is the
-	 * page number, here evq_rptr is the entire address because
-	 * it is currently a pointer into the densely mapped timer page.
-	 */
-	VPRINTK("Passing evq_rptr pfn %x for rptr %x\n", 
-		hwinfo->common.evq_rptr >> PAGE_SHIFT,
-		hwinfo->common.evq_rptr);
-	rc = net_accel_grant_page(bend->hdev_data, 
-				  hwinfo->common.evq_rptr >> PAGE_SHIFT, 0);
-	if (rc < 0) {
-		/* Undo ef_bend_hwinfo_falcon_common() */
-		ungrant_or_crash(accel_hw_priv->txdmaq_gnt, bend->far_end);
-		ungrant_or_crash(accel_hw_priv->rxdmaq_gnt, bend->far_end);
-		ungrant_or_crash(accel_hw_priv->doorbell_gnt, bend->far_end);
-		for (i = 0; i < accel_hw_priv->evq_npages; i++) {
-			ungrant_or_crash(accel_hw_priv->evq_mem_gnts[i],
-					 bend->far_end);
-		}
-		return rc;
-	}
-
-	accel_hw_priv->evq_rptr_gnt = hwinfo->evq_rptr_gnt = rc;
-	VPRINTK("evq_rptr_gnt got %d\n", hwinfo->evq_rptr_gnt);
-	
-	return 0;
-}
-
-
-static int ef_bend_hwinfo_falcon_b(struct netback_accel *bend, 
-				   struct net_accel_hw_falcon_b *hwinfo)
-{
-	return ef_bend_hwinfo_falcon_common(bend, hwinfo);
-}
-
-
-/*
- * Fill in the message with a description of the hardware resources, based on
- * the H/W type
- */
-static int netback_accel_hwinfo(struct netback_accel *bend, 
-				struct net_accel_msg_hw *msgvi)
-{
-	int rc = 0;
-	
-	BUG_ON(bend->hw_state != NETBACK_ACCEL_RES_FILTER);
-
-	msgvi->type = bend->hw_type;
-	switch (bend->hw_type) {
-	case NET_ACCEL_MSG_HWTYPE_FALCON_A:
-		rc = ef_bend_hwinfo_falcon_a(bend, &msgvi->resources.falcon_a);
-		break;
-	case NET_ACCEL_MSG_HWTYPE_FALCON_B:
-	case NET_ACCEL_MSG_HWTYPE_SIENA_A:
-		rc = ef_bend_hwinfo_falcon_b(bend, &msgvi->resources.falcon_b);
-		break;
-	case NET_ACCEL_MSG_HWTYPE_NONE:
-		/* Nothing to do. The slow path should just work. */
-		break;
-	}
-
-	if (rc == 0)
-		bend->hw_state = NETBACK_ACCEL_RES_HWINFO;
-		
-	return rc;
-}
-
-
-/* Allocate hardware resources and make them available to the client domain */
-int netback_accel_setup_vnic_hw(struct netback_accel *bend)
-{
-	struct net_accel_msg msg;
-	int err;
-
-	/* Allocate the event queue, VI and so on. */
-	err = ef_get_vnic(bend);
-	if (err) {
-		EPRINTK("Failed to allocate hardware resource for bend:"
-			"error %d\n", err);
-		return err;
-	}
-
-	/* Set up the filter management */
-	err = netback_accel_filter_init(bend);
-	if (err) {
-		EPRINTK("Filter setup failed, error %d", err);
-		ef_free_vnic(bend);
-		return err;
-	}
-
-	net_accel_msg_init(&msg, NET_ACCEL_MSG_SETHW);
-
-	/*
-	 * Extract the low-level hardware info we will actually pass to the
-	 * other end, and set up the grants/ioremap permissions needed
-	 */
-	err = netback_accel_hwinfo(bend, &msg.u.hw);
-
-	if (err != 0) {
-		netback_accel_filter_shutdown(bend);
-		ef_free_vnic(bend);
-		return err;
-	}
-
-	/* Send the message, this is a reply to a hello-reply */
-	err = net_accel_msg_reply_notify(bend->shared_page, 
-					 bend->msg_channel_irq, 
-					 &bend->to_domU, &msg);
-
-	/*
-	 * The message should succeed as it's logically a reply and we
-	 * guarantee space for replies, but a misbehaving frontend
-	 * could result in that behaviour, so be tolerant
-	 */
-	if (err != 0) {
-		netback_accel_release_hwinfo(bend);
-		netback_accel_filter_shutdown(bend);
-		ef_free_vnic(bend);
-	}
-
-	return err;
-}
-
-
-/* Free hardware resources  */
-void netback_accel_shutdown_vnic_hw(struct netback_accel *bend)
-{
-	/*
-	 * Only try and release resources if accel_hw_priv was setup,
-	 * otherwise there is nothing to do as we're on "null-op"
-	 * acceleration
-	 */
-	switch (bend->hw_state) {
-	case NETBACK_ACCEL_RES_HWINFO:
-		VPRINTK("Release hardware resources\n");
-		netback_accel_release_hwinfo(bend);
-		/* deliberate drop through */
-	case NETBACK_ACCEL_RES_FILTER:		
-		VPRINTK("Free filters...\n");
-		netback_accel_filter_shutdown(bend);
-		/* deliberate drop through */
-	case NETBACK_ACCEL_RES_ALLOC:
-		VPRINTK("Free vnic...\n");
-		ef_free_vnic(bend);
-		/* deliberate drop through */
-	case NETBACK_ACCEL_RES_NONE:
-		break;
-	default:
-		BUG();
-	}
-}
-
-/**************************************************************************
- * 
- * Buffer table stuff
- *
- **************************************************************************/
-
-/*
- * Undo any allocation that netback_accel_msg_rx_buffer_map() has made
- * if it fails half way through
- */
-static inline void buffer_map_cleanup(struct netback_accel *bend, int i)
-{
-	while (i > 0) {
-		i--;
-		bend->buffer_maps_index--;
-		net_accel_unmap_device_page(bend->hdev_data, 
-					    bend->buffer_maps[bend->buffer_maps_index],
-					    bend->buffer_addrs[bend->buffer_maps_index]);
-	}
-}
-
-
-int netback_accel_add_buffers(struct netback_accel *bend, int pages, int log2_pages,
-			      u32 *grants, u32 *buf_addr_out)
-{
-	struct falcon_bend_accel_priv *accel_hw_priv = bend->accel_hw_priv;
-	unsigned long long addr_array[NET_ACCEL_MSG_MAX_PAGE_REQ];
-	int rc, i, index;
-	u64 dev_bus_addr;
-
-	/* Make sure we can't overflow the dma_maps array */
-	if (accel_hw_priv->dma_maps_index >= 
-	    bend->max_pages / NET_ACCEL_MSG_MAX_PAGE_REQ) {
-		EPRINTK("%s: too many buffer table allocations: %d %d\n",
-			__FUNCTION__, accel_hw_priv->dma_maps_index, 
-			bend->max_pages / NET_ACCEL_MSG_MAX_PAGE_REQ);
-		return -EINVAL;
-	}
-
-	/* Make sure we can't overflow the buffer_maps array */
-	if (bend->buffer_maps_index + pages > bend->max_pages) {
-		EPRINTK("%s: too many pages mapped: %d + %d > %d\n", 
-			__FUNCTION__, bend->buffer_maps_index,
-			pages, bend->max_pages);
-		return -EINVAL;
-	}
-
-	for (i = 0; i < pages; i++) {
-		VPRINTK("%s: mapping page %d\n", __FUNCTION__, i);
-		rc = net_accel_map_device_page
-			(bend->hdev_data, grants[i],
-			 &bend->buffer_maps[bend->buffer_maps_index],
-			 &dev_bus_addr);
-    
-		if (rc != 0) {
-			EPRINTK("error in net_accel_map_device_page\n");
-			buffer_map_cleanup(bend, i);
-			return rc;
-		}
-		
-		bend->buffer_addrs[bend->buffer_maps_index] = dev_bus_addr;
-
-		bend->buffer_maps_index++;
-
-		addr_array[i] = dev_bus_addr;
-	}
-
-	VPRINTK("%s: mapping dma addresses to vih %p\n", __FUNCTION__, 
-		accel_hw_priv->efx_vih);
-
-	index = accel_hw_priv->dma_maps_index;
-	if ((rc = efx_vi_dma_map_addrs(accel_hw_priv->efx_vih, addr_array, pages,
-				       &(accel_hw_priv->dma_maps[index]))) < 0) {
-		EPRINTK("error in dma_map_pages\n");
-		buffer_map_cleanup(bend, i);
-		return rc;
-	}
-
-	accel_hw_priv->dma_maps_index++;
-	NETBACK_ACCEL_STATS_OP(bend->stats.num_buffer_pages += pages);
-
-	//DPRINTK("%s: getting map address\n", __FUNCTION__);
-
-	*buf_addr_out = efx_vi_dma_get_map_addr(accel_hw_priv->efx_vih, 
-						accel_hw_priv->dma_maps[index]);
-
-	//DPRINTK("%s: done\n", __FUNCTION__);
-
-	return 0;
-}
-
-
-int netback_accel_remove_buffers(struct netback_accel *bend)
-{
-	/* Only try to free buffers if accel_hw_priv was setup */
-	if (bend->hw_state != NETBACK_ACCEL_RES_NONE) {
-		struct falcon_bend_accel_priv *accel_hw_priv = bend->accel_hw_priv;
-		int i;
-
-		efx_vi_reset(accel_hw_priv->efx_vih);
-
-		while (accel_hw_priv->dma_maps_index > 0) {
-			accel_hw_priv->dma_maps_index--;
-			i = accel_hw_priv->dma_maps_index;
-			efx_vi_dma_unmap_addrs(accel_hw_priv->efx_vih, 
-					       accel_hw_priv->dma_maps[i]);
-		}
-		
-		while (bend->buffer_maps_index > 0) {
-			VPRINTK("Unmapping granted buffer %d\n", 
-				bend->buffer_maps_index);
-			bend->buffer_maps_index--;
-			i = bend->buffer_maps_index;
-			net_accel_unmap_device_page(bend->hdev_data, 
-						    bend->buffer_maps[i],
-						    bend->buffer_addrs[i]);
-		}
-
-		NETBACK_ACCEL_STATS_OP(bend->stats.num_buffer_pages = 0);
-	}
-
-	return 0;
-}
-
-/**************************************************************************
- * 
- * Filter stuff
- *
- **************************************************************************/
-
-static int netback_accel_filter_init(struct netback_accel *bend)
-{
-	struct falcon_bend_accel_priv *accel_hw_priv = bend->accel_hw_priv;
-	int i, rc;
-
-	BUG_ON(bend->hw_state != NETBACK_ACCEL_RES_ALLOC);
-
-	spin_lock_init(&accel_hw_priv->filter_lock);
-
-	if ((rc = cuckoo_hash_init(&accel_hw_priv->filter_hash_table, 
-				   5 /* space for 32 filters */, 8)) != 0) {
-		EPRINTK("Failed to initialise filter hash table\n");
-		return rc;
-	}
-
-	accel_hw_priv->fspecs = kzalloc(sizeof(struct netback_accel_filter_spec) *
-					bend->quotas.max_filters,
-					GFP_KERNEL);
-
-	if (accel_hw_priv->fspecs == NULL) {
-		EPRINTK("No memory for filter specs.\n");
-		cuckoo_hash_destroy(&accel_hw_priv->filter_hash_table);
-		return -ENOMEM;
-	}
-
-	for (i = 0; i < bend->quotas.max_filters; i++) {
-		accel_hw_priv->free_filters |= (1 << i);
-	}
-
-	/* Base mask on highest set bit in max_filters  */
-	accel_hw_priv->filter_idx_mask = (1 << fls(bend->quotas.max_filters)) - 1;
-	VPRINTK("filter setup: max is %x mask is %x\n",
-		bend->quotas.max_filters, accel_hw_priv->filter_idx_mask);
-
-	bend->hw_state = NETBACK_ACCEL_RES_FILTER;
-
-	return 0;
-}
-
-
-static inline void make_filter_key(cuckoo_hash_ip_key *key,  
-				   struct netback_accel_filter_spec *filt)
-
-{
-	key->local_ip = filt->destip_be;
-	key->local_port = filt->destport_be;
-	key->proto = filt->proto;
-}
-
-
-static inline 
-void netback_accel_free_filter(struct falcon_bend_accel_priv *accel_hw_priv,
-			       int filter)
-{
-	cuckoo_hash_ip_key filter_key;
-
-	if (!(accel_hw_priv->free_filters & (1 << filter))) {
-		efx_vi_filter_stop(accel_hw_priv->efx_vih, 
-				   accel_hw_priv->fspecs[filter].filter_handle);
-		make_filter_key(&filter_key, &(accel_hw_priv->fspecs[filter]));
-		if (cuckoo_hash_remove(&accel_hw_priv->filter_hash_table,
-				       (cuckoo_hash_key *)&filter_key)) {
-			EPRINTK("%s: Couldn't find filter to remove from table\n",
-				__FUNCTION__);
-			BUG();
-		}
-	}
-}
-
-
-static void netback_accel_filter_shutdown(struct netback_accel *bend)
-{
-	struct falcon_bend_accel_priv *accel_hw_priv = bend->accel_hw_priv;
-	int i;
-	unsigned long flags;
-
-	BUG_ON(bend->hw_state != NETBACK_ACCEL_RES_FILTER);
-
-	spin_lock_irqsave(&accel_hw_priv->filter_lock, flags);
-
-	BUG_ON(accel_hw_priv->fspecs == NULL);
-
-	for (i = 0; i < bend->quotas.max_filters; i++) {
-		netback_accel_free_filter(accel_hw_priv, i);
-	}
-	
-	kfree(accel_hw_priv->fspecs);
-	accel_hw_priv->fspecs = NULL;
-	accel_hw_priv->free_filters = 0;
-	
-	cuckoo_hash_destroy(&accel_hw_priv->filter_hash_table);
-
-	spin_unlock_irqrestore(&accel_hw_priv->filter_lock, flags);
-
-	bend->hw_state = NETBACK_ACCEL_RES_ALLOC;
-}
-
-
-/*! Suggest a filter to replace when we want to insert a new one and have
- *  none free.
- */
-static unsigned get_victim_filter(struct netback_accel *bend)
-{
-	/*
-	 * We could attempt to get really clever, and may do at some
-	 * point, but random replacement is v. cheap and low on
-	 * pathological worst cases.
-	 */
-	unsigned index, cycles;
-
-	rdtscl(cycles);
-
-	/*
-	 * Some doubt about the quality of the bottom few bits, so
-	 * throw 'em * away
-	 */
-	index = (cycles >> 4) & ((struct falcon_bend_accel_priv *)
-				 bend->accel_hw_priv)->filter_idx_mask;
-	/*
-	 * We don't enforce that the number of filters is a power of
-	 * two, but the masking gets us to within one subtraction of a
-	 * valid index
-	 */
-	if (index >= bend->quotas.max_filters)
-		index -= bend->quotas.max_filters;
-	DPRINTK("backend %s->%d has no free filters. Filter %d will be evicted\n",
-		bend->nicname, bend->far_end, index);
-	return index;
-}
-
-
-/* Add a filter for the specified IP/port to the backend */
-int 
-netback_accel_filter_check_add(struct netback_accel *bend, 
-			       struct netback_accel_filter_spec *filt)
-{
-	struct falcon_bend_accel_priv *accel_hw_priv = bend->accel_hw_priv;
-	struct netback_accel_filter_spec *fs;
-	unsigned filter_index;
-	unsigned long flags;
-	int rc, recycling = 0;
-	cuckoo_hash_ip_key filter_key, evict_key;
-
-	BUG_ON(filt->proto != IPPROTO_TCP && filt->proto != IPPROTO_UDP);
-
-	DPRINTK("Will add %s filter for dst ip %08x and dst port %d\n", 
-		(filt->proto == IPPROTO_TCP) ? "TCP" : "UDP",
-		be32_to_cpu(filt->destip_be), be16_to_cpu(filt->destport_be));
-
-	spin_lock_irqsave(&accel_hw_priv->filter_lock, flags);
-	/*
-	 * Check to see if we're already filtering this IP address and
-	 * port. Happens if you insert a filter mid-stream as there
-	 * are many packets backed up to be delivered to dom0 already
-	 */
-	make_filter_key(&filter_key, filt);
-	if (cuckoo_hash_lookup(&accel_hw_priv->filter_hash_table, 
-			       (cuckoo_hash_key *)(&filter_key), 
-			       &filter_index)) {
-		DPRINTK("Found matching filter %d already in table\n", 
-			filter_index);
-		rc = -1;
-		goto out;
-	}
-
-	if (accel_hw_priv->free_filters == 0) {
-		filter_index = get_victim_filter(bend);
-		recycling = 1;
-	} else {
-		filter_index = __ffs(accel_hw_priv->free_filters);
-		clear_bit(filter_index, &accel_hw_priv->free_filters);
-	}
-
-	fs = &accel_hw_priv->fspecs[filter_index];
-
-	if (recycling) {
-		DPRINTK("Removing filter index %d handle %p\n", filter_index,
-			fs->filter_handle);
-
-		if ((rc = efx_vi_filter_stop(accel_hw_priv->efx_vih, 
-					     fs->filter_handle)) != 0) {
-			EPRINTK("Couldn't clear NIC filter table entry %d\n", rc);
-		}
-
-		make_filter_key(&evict_key, fs);
-		if (cuckoo_hash_remove(&accel_hw_priv->filter_hash_table,
-				       (cuckoo_hash_key *)&evict_key)) {
-			EPRINTK("Couldn't find filter to remove from table\n");
-			BUG();
-		}
-		NETBACK_ACCEL_STATS_OP(bend->stats.num_filters--);
-	}
-
-	/* Update the filter spec with new details */
-	*fs = *filt;
-
-	if ((rc = cuckoo_hash_add(&accel_hw_priv->filter_hash_table, 
-				  (cuckoo_hash_key *)&filter_key, filter_index,
-				  1)) != 0) {
-		EPRINTK("Error (%d) adding filter to table\n", rc);
-		accel_hw_priv->free_filters |= (1 << filter_index);
-		goto out;
-	}
-
-	rc = efx_vi_filter(accel_hw_priv->efx_vih, filt->proto, filt->destip_be,
-			   filt->destport_be, 
-			   (struct filter_resource_t **)&fs->filter_handle);
-
-	if (rc != 0) {
-		EPRINTK("Hardware filter insertion failed. Error %d\n", rc);
-		accel_hw_priv->free_filters |= (1 << filter_index);
-		cuckoo_hash_remove(&accel_hw_priv->filter_hash_table, 
-				   (cuckoo_hash_key *)&filter_key);
-		rc = -1;
-		goto out;
-	}
-
-	NETBACK_ACCEL_STATS_OP(bend->stats.num_filters++);
-
-	VPRINTK("%s: success index %d handle %p\n", __FUNCTION__, filter_index, 
-		fs->filter_handle);
-
-	rc = filter_index;
- out:
-	spin_unlock_irqrestore(&accel_hw_priv->filter_lock, flags);
-	return rc;
-}
-
-
-/* Remove a filter entry for the specific device and IP/port */
-static void netback_accel_filter_remove(struct netback_accel *bend, 
-					int filter_index)
-{
-	struct falcon_bend_accel_priv *accel_hw_priv = bend->accel_hw_priv;
-
-	BUG_ON(accel_hw_priv->free_filters & (1 << filter_index));
-	netback_accel_free_filter(accel_hw_priv, filter_index);
-	accel_hw_priv->free_filters |= (1 << filter_index);
-}
-
-
-/* Remove a filter entry for the specific device and IP/port */
-void netback_accel_filter_remove_spec(struct netback_accel *bend, 
-				      struct netback_accel_filter_spec *filt)
-{
-	struct falcon_bend_accel_priv *accel_hw_priv = bend->accel_hw_priv;
-	unsigned filter_found;
-	unsigned long flags;
-	cuckoo_hash_ip_key filter_key;
-	struct netback_accel_filter_spec *fs;
-
-	if (filt->proto == IPPROTO_TCP) {
-		DPRINTK("Remove TCP filter for dst ip %08x and dst port %d\n",
-			be32_to_cpu(filt->destip_be),
-			be16_to_cpu(filt->destport_be));
-	} else if (filt->proto == IPPROTO_UDP) {
-		DPRINTK("Remove UDP filter for dst ip %08x and dst port %d\n",
-			be32_to_cpu(filt->destip_be),
-			be16_to_cpu(filt->destport_be));
-	} else {
-		/*
-		 * This could be provoked by an evil frontend, so can't
-		 * BUG(), but harmless as it should fail tests below 
-		 */
-		DPRINTK("Non-TCP/UDP filter dst ip %08x and dst port %d\n",
-			be32_to_cpu(filt->destip_be),
-			be16_to_cpu(filt->destport_be));
-	}
-
-	spin_lock_irqsave(&accel_hw_priv->filter_lock, flags);
-
-	make_filter_key(&filter_key, filt);
-	if (!cuckoo_hash_lookup(&accel_hw_priv->filter_hash_table, 
-			       (cuckoo_hash_key *)(&filter_key), 
-			       &filter_found)) {
-		EPRINTK("Couldn't find matching filter already in table\n");
-		goto out;
-	}
-	
-	/* Do a full check to make sure we've not had a hash collision */
-	fs = &accel_hw_priv->fspecs[filter_found];
-	if (fs->destip_be == filt->destip_be &&
-	    fs->destport_be == filt->destport_be &&
-	    fs->proto == filt->proto &&
-	    !memcmp(fs->mac, filt->mac, ETH_ALEN)) {
-		netback_accel_filter_remove(bend, filter_found);
-	} else {
-		EPRINTK("Entry in hash table does not match filter spec\n");
-		goto out;
-	}
-
- out:
-	spin_unlock_irqrestore(&accel_hw_priv->filter_lock, flags);
-}
diff -r 9566a4a50a43 drivers/xen/sfc_netback/accel_solarflare.h
--- a/drivers/xen/sfc_netback/accel_solarflare.h
+++ /dev/null
@@ -1,88 +0,0 @@
-/****************************************************************************
- * Solarflare driver for Xen network acceleration
- *
- * Copyright 2006-2008: Solarflare Communications Inc,
- *                      9501 Jeronimo Road, Suite 250,
- *                      Irvine, CA 92618, USA
- *
- * Maintained by Solarflare Communications <linux-xen-drivers@solarflare.com>
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 as published
- * by the Free Software Foundation, incorporated herein by reference.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
- ****************************************************************************
- */
-
-#ifndef NETBACK_ACCEL_SOLARFLARE_H
-#define NETBACK_ACCEL_SOLARFLARE_H
-
-#include "accel.h"
-#include "accel_msg_iface.h"
-
-#include "driverlink_api.h"
-
-#define MAX_NICS 5
-#define MAX_PORTS 2
-
-
-extern int netback_accel_sf_init(void);
-extern void netback_accel_sf_shutdown(void);
-extern int netback_accel_sf_hwtype(struct netback_accel *bend);
-
-extern int netback_accel_sf_char_init(void);
-extern void netback_accel_sf_char_shutdown(void);
-
-extern int netback_accel_setup_vnic_hw(struct netback_accel *bend);
-extern void netback_accel_shutdown_vnic_hw(struct netback_accel *bend);
-
-extern int netback_accel_add_buffers(struct netback_accel *bend, int pages, 
-				     int log2_pages, u32 *grants,
-				     u32 *buf_addr_out);
-extern int netback_accel_remove_buffers(struct netback_accel *bend);
-
-
-/* Add a filter for the specified IP/port to the backend */
-extern int
-netback_accel_filter_check_add(struct netback_accel *bend, 
-			       struct netback_accel_filter_spec *filt);
-/* Remove a filter entry for the specific device and IP/port */
-extern
-void netback_accel_filter_remove_index(struct netback_accel *bend, 
-				       int filter_index);
-extern
-void netback_accel_filter_remove_spec(struct netback_accel *bend, 
-				      struct netback_accel_filter_spec *filt);
-
-/* This is designed to look a bit like a skb */
-struct netback_pkt_buf {
-	union {
-		unsigned char *raw;
-	} mac;
-	union {
-		struct iphdr  *iph;
-		struct arphdr *arph;
-		unsigned char *raw;
-	} nh;
-	int protocol;
-};
-
-/*! \brief Handle a received packet: insert fast path filters as necessary
- * \param skb The packet buffer
- */
-extern void netback_accel_rx_packet(struct netback_pkt_buf *skb, void *fwd_priv);
-
-/*! \brief Handle a transmitted packet: update fast path filters as necessary
- * \param skb The packet buffer
- */
-extern void netback_accel_tx_packet(struct sk_buff *skb, void *fwd_priv);
-
-#endif /* NETBACK_ACCEL_SOLARFLARE_H */
diff -r 9566a4a50a43 drivers/xen/sfc_netback/ci/compat.h
--- a/drivers/xen/sfc_netback/ci/compat.h
+++ /dev/null
@@ -1,53 +0,0 @@
-/****************************************************************************
- * Copyright 2002-2005: Level 5 Networks Inc.
- * Copyright 2005-2008: Solarflare Communications Inc,
- *                      9501 Jeronimo Road, Suite 250,
- *                      Irvine, CA 92618, USA
- *
- * Maintained by Solarflare Communications
- *  <linux-xen-drivers@solarflare.com>
- *  <onload-dev@solarflare.com>
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 as published
- * by the Free Software Foundation, incorporated herein by reference.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
- ****************************************************************************
- */
-
-/*
- * \author  djr
- *  \brief  Compatability layer.  Provides definitions of fundamental
- *          types and definitions that are used throughout CI source
- *          code.  It does not introduce any link time dependencies,
- *          or include any unnecessary system headers.
- */
-/*! \cidoxg_include_ci */
-
-#ifndef __CI_COMPAT_H__
-#define __CI_COMPAT_H__
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-#include <ci/compat/primitive.h>
-#include <ci/compat/sysdep.h>
-#include <ci/compat/utils.h>
-
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif  /* __CI_COMPAT_H__ */
-
-/*! \cidoxg_end */
diff -r 9566a4a50a43 drivers/xen/sfc_netback/ci/compat/gcc.h
--- a/drivers/xen/sfc_netback/ci/compat/gcc.h
+++ /dev/null
@@ -1,158 +0,0 @@
-/****************************************************************************
- * Copyright 2002-2005: Level 5 Networks Inc.
- * Copyright 2005-2008: Solarflare Communications Inc,
- *                      9501 Jeronimo Road, Suite 250,
- *                      Irvine, CA 92618, USA
- *
- * Maintained by Solarflare Communications
- *  <linux-xen-drivers@solarflare.com>
- *  <onload-dev@solarflare.com>
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 as published
- * by the Free Software Foundation, incorporated herein by reference.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
- ****************************************************************************
- */
-
-/*! \cidoxg_include_ci_compat  */
-
-#ifndef __CI_COMPAT_GCC_H__
-#define __CI_COMPAT_GCC_H__
-
-
-#define CI_HAVE_INT64
-
-
-#if defined(__linux__) && defined(__KERNEL__)
-
-# include <linux/types.h>
-
-typedef __u64                 ci_uint64;
-typedef __s64                 ci_int64;
-# if BITS_PER_LONG == 32
-typedef __s32                 ci_ptr_arith_t;
-typedef __u32                 ci_uintptr_t;
-# else
-typedef __s64                 ci_ptr_arith_t;
-typedef __u64                 ci_uintptr_t;
-# endif
-
-
-/* it's not obvious to me why the below is wrong for x64_64, but
- * gcc seems to complain on this platform
- */
-# if defined(__ia64__)
-#  define CI_PRId64            "ld"
-#  define CI_PRIi64            "li"
-#  define CI_PRIo64            "lo"
-#  define CI_PRIu64            "lu"
-#  define CI_PRIx64            "lx"
-#  define CI_PRIX64            "lX"
-# else
-#  define CI_PRId64            "lld"
-#  define CI_PRIi64            "lli"
-#  define CI_PRIo64            "llo"
-#  define CI_PRIu64            "llu"
-#  define CI_PRIx64            "llx"
-#  define CI_PRIX64            "llX"
-# endif
-
-# define CI_PRId32            "d"
-# define CI_PRIi32            "i"
-# define CI_PRIo32            "o"
-# define CI_PRIu32            "u"
-# define CI_PRIx32            "x"
-# define CI_PRIX32            "X"
-
-#else
-
-# include <stdint.h>
-# include <inttypes.h>
-
-typedef uint64_t              ci_uint64;
-typedef int64_t               ci_int64;
-typedef intptr_t              ci_ptr_arith_t;
-typedef uintptr_t             ci_uintptr_t;
-
-# define CI_PRId64            PRId64
-# define CI_PRIi64            PRIi64
-# define CI_PRIo64            PRIo64
-# define CI_PRIu64            PRIu64
-# define CI_PRIx64            PRIx64
-# define CI_PRIX64            PRIX64
-
-# define CI_PRId32            PRId32
-# define CI_PRIi32            PRIi32
-# define CI_PRIo32            PRIo32
-# define CI_PRIu32            PRIu32
-# define CI_PRIx32            PRIx32
-# define CI_PRIX32            PRIX32
-
-#endif
-
-
-typedef ci_uint64                       ci_fixed_descriptor_t;
-
-#define from_fixed_descriptor(desc) ((ci_uintptr_t)(desc))
-#define to_fixed_descriptor(desc) ((ci_fixed_descriptor_t)(ci_uintptr_t)(desc))
-
-
-#if __GNUC__ >= 3 && !defined(__cplusplus)
-/*
-** Checks that [p_mbr] has the same type as [&c_type::mbr_name].
-*/
-# define CI_CONTAINER(c_type, mbr_name, p_mbr)				\
-   __builtin_choose_expr(						\
-     __builtin_types_compatible_p(__typeof__(&((c_type*)0)->mbr_name),	\
-				 __typeof__(p_mbr)),			\
-     __CI_CONTAINER(c_type, mbr_name, p_mbr), (void)0)
-
-# define ci_restrict  __restrict__
-#endif
-
-
-#if !defined(__KERNEL__) || defined(__unix__)
-#define CI_HAVE_NPRINTF  1
-#endif
-
-
-/* At what version was this introduced? */
-#if __GNUC__ >= 3 || (__GNUC__ == 2 && __GNUC_MINOR__ > 91)
-# define CI_LIKELY(t)    __builtin_expect((t), 1)
-# define CI_UNLIKELY(t)  __builtin_expect((t), 0)
-#endif
-
-/**********************************************************************
- * Attributes
- */
-#if __GNUC__ >= 3 && defined(NDEBUG)
-# define CI_HF __attribute__((visibility("hidden")))
-# define CI_HV __attribute__((visibility("hidden")))
-#else
-# define CI_HF
-# define CI_HV
-#endif
-
-#if __GNUC__ >= 4 || (__GNUC__ == 3 && __GNUC_MINOR__ >= 1)
-# define ci_noinline  static __attribute__((__noinline__))
-/* (Linux 2.6 defines its own "noinline", so we use the "__noinline__" form) */
-#else
-# define ci_noinline  static
-#endif
-
-#define CI_ALIGN(x) __attribute__ ((aligned (x)))
-
-#define CI_PRINTF_LIKE(a,b) __attribute__((format(printf,a,b)))
-
-#endif  /* __CI_COMPAT_GCC_H__ */
-
-/*! \cidoxg_end */
diff -r 9566a4a50a43 drivers/xen/sfc_netback/ci/compat/gcc_x86.h
--- a/drivers/xen/sfc_netback/ci/compat/gcc_x86.h
+++ /dev/null
@@ -1,115 +0,0 @@
-/****************************************************************************
- * Copyright 2002-2005: Level 5 Networks Inc.
- * Copyright 2005-2008: Solarflare Communications Inc,
- *                      9501 Jeronimo Road, Suite 250,
- *                      Irvine, CA 92618, USA
- *
- * Maintained by Solarflare Communications
- *  <linux-xen-drivers@solarflare.com>
- *  <onload-dev@solarflare.com>
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 as published
- * by the Free Software Foundation, incorporated herein by reference.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
- ****************************************************************************
- */
-
-/*! \cidoxg_include_ci_compat  */
-
-#ifndef __CI_COMPAT_GCC_X86_H__
-#define __CI_COMPAT_GCC_X86_H__
-
-/*
-** The facts:
-**
-**   SSE   sfence
-**   SSE2  lfence, mfence, pause
-*/
-
-/* 
-   Barriers to enforce ordering with respect to:
-
-   normal memory use: ci_wmb, ci_rmb, ci_wmb
-   IO bus access use: ci_wiob, ci_riob, ci_iob
-*/
-#if defined(__x86_64__)
-# define ci_x86_mb() __asm__ __volatile__ ("lock; addl $0,0(%%rsp)":::"memory")
-#else
-# define ci_x86_mb() __asm__ __volatile__ ("lock; addl $0,0(%%esp)":::"memory")
-#endif
-
-/* ?? measure the impact of latency of sfence on a modern processor before we
-   take a decision on how to integrate with respect to writecombining */
-
-/* DJR: I don't think we need to add "memory" here.  It means the asm does
-** something to memory that GCC doesn't understand.  But all this does is
-** commit changes that GCC thinks have already happened.  NB. GCC will not
-** reorder across a __volatile__ __asm__ anyway.
-*/
-#define ci_gcc_fence()    __asm__ __volatile__ ("")
-
-#if __GNUC__ >= 3 || (__GNUC__ == 2 && __GNUC_MINOR__ >= 96)
-# define ci_x86_sfence()  __asm__ __volatile__ ("sfence")
-# define ci_x86_lfence()  __asm__ __volatile__ ("lfence")
-# define ci_x86_mfence()  __asm__ __volatile__ ("mfence")
-#else
-# define ci_x86_sfence()  __asm__ __volatile__ (".byte 0x0F, 0xAE, 0xF8")
-# define ci_x86_lfence()  __asm__ __volatile__ (".byte 0x0F, 0xAE, 0xE8")
-# define ci_x86_mfence()  __asm__ __volatile__ (".byte 0x0F, 0xAE, 0xF0")
-#endif
-
-
-/* x86 processors to P4 Xeon store in-order unless executing streaming
-   extensions or when using writecombining 
-
-   Hence we do not define ci_wmb to use sfence by default. Requirement is that
-   we do not use writecombining to memory and any code which uses SSE
-   extensions must call sfence directly 
-
-   We need to track non intel clones which may support out of order store.
-
-*/
-
-#if CI_CPU_OOS
-# if CI_CPU_HAS_SSE
-#  define ci_wmb()	ci_x86_sfence()
-# else
-#  define ci_wmb()	ci_x86_mb()
-# endif
-#else
-# define ci_wmb()       ci_gcc_fence()
-#endif
-
-#if CI_CPU_HAS_SSE2
-# define ci_rmb()	ci_x86_lfence()
-# define ci_mb()	ci_x86_mfence()
-# define ci_riob()	ci_x86_lfence()
-# define ci_wiob()	ci_x86_sfence()
-# define ci_iob()	ci_x86_mfence()
-#else
-# if CI_CPU_HAS_SSE
-#  define ci_wiob()	ci_x86_sfence()
-# else
-#  define ci_wiob()	ci_x86_mb()
-# endif
-# define ci_rmb()	ci_x86_mb()
-# define ci_mb()   	ci_x86_mb()
-# define ci_riob()  	ci_x86_mb()
-# define ci_iob()  	ci_x86_mb()
-#endif
-
-typedef unsigned long   ci_phys_addr_t;
-#define ci_phys_addr_fmt  "%lx"
-
-#endif  /* __CI_COMPAT_GCC_X86_H__ */
-
-/*! \cidoxg_end */
diff -r 9566a4a50a43 drivers/xen/sfc_netback/ci/compat/primitive.h
--- a/drivers/xen/sfc_netback/ci/compat/primitive.h
+++ /dev/null
@@ -1,77 +0,0 @@
-/****************************************************************************
- * Copyright 2002-2005: Level 5 Networks Inc.
- * Copyright 2005-2008: Solarflare Communications Inc,
- *                      9501 Jeronimo Road, Suite 250,
- *                      Irvine, CA 92618, USA
- *
- * Maintained by Solarflare Communications
- *  <linux-xen-drivers@solarflare.com>
- *  <onload-dev@solarflare.com>
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 as published
- * by the Free Software Foundation, incorporated herein by reference.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
- ****************************************************************************
- */
-/*! \cidoxg_include_ci_compat  */
-
-#ifndef __CI_COMPAT_PRIMITIVE_H__
-#define __CI_COMPAT_PRIMITIVE_H__
-
-
-/**********************************************************************
- * Primitive types.
- */
-
-typedef unsigned char                   ci_uint8;
-typedef char                            ci_int8;
-
-typedef unsigned short                  ci_uint16;
-typedef short                           ci_int16;
-
-typedef unsigned int                    ci_uint32;
-typedef int                             ci_int32;
-
-/* 64-bit support is platform dependent. */
-
-
-/**********************************************************************
- * Other fancy types.
- */
-
-typedef ci_uint8                        ci_octet;
-
-typedef enum {
-  CI_FALSE = 0,
-  CI_TRUE
-} ci_boolean_t;
-
-
-/**********************************************************************
- * Some nice types you'd always assumed were standards.
- * (Really, they are SYSV "standards".)
- */
-
-#ifdef _WIN32
-typedef unsigned long                   ulong;              
-typedef unsigned int                    uint;
-typedef char*                           caddr_t;
-#elif defined(__linux__) && defined(__KERNEL__)
-#include <linux/types.h>
-#elif defined(__linux__)
-#include <sys/types.h>
-#endif
-
-
-#endif  /* __CI_COMPAT_PRIMITIVE_H__ */
-
-/*! \cidoxg_end */
diff -r 9566a4a50a43 drivers/xen/sfc_netback/ci/compat/sysdep.h
--- a/drivers/xen/sfc_netback/ci/compat/sysdep.h
+++ /dev/null
@@ -1,166 +0,0 @@
-/****************************************************************************
- * Copyright 2002-2005: Level 5 Networks Inc.
- * Copyright 2005-2008: Solarflare Communications Inc,
- *                      9501 Jeronimo Road, Suite 250,
- *                      Irvine, CA 92618, USA
- *
- * Maintained by Solarflare Communications
- *  <linux-xen-drivers@solarflare.com>
- *  <onload-dev@solarflare.com>
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 as published
- * by the Free Software Foundation, incorporated herein by reference.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
- ****************************************************************************
- */
-
-/*! \cidoxg_include_ci_compat  */
-
-#ifndef __CI_COMPAT_SYSDEP_H__
-#define __CI_COMPAT_SYSDEP_H__
-
-
-/**********************************************************************
- * Platform definition fixups.
- */
-
-#if defined(__ci_ul_driver__) && !defined(__ci_driver__)
-# define __ci_driver__
-#endif
-
-#if defined(__ci_driver__) && !defined(__ci_ul_driver__) && \
-   !defined(__KERNEL__)
-# define __KERNEL__
-#endif
-
-
-/**********************************************************************
- * Sanity checks (no cheating!)
- */
-
-#if defined(__KERNEL__) && !defined(__ci_driver__)
-# error Insane.
-#endif
-
-#if defined(__KERNEL__) && defined(__ci_ul_driver__)
-# error Madness.
-#endif
-
-#if defined(__unix__) && defined(_WIN32)
-# error Strange.
-#endif
-
-#if defined(__GNUC__) && defined(_MSC_VER)
-# error Crazy.
-#endif
-
-
-/**********************************************************************
- * Compiler and processor dependencies.
- */
-
-#if defined(__GNUC__)
-
-# include <ci/compat/gcc.h>
-
-# if defined(__i386__)
-#  include <ci/compat/x86.h>
-#  include <ci/compat/gcc_x86.h>
-# elif defined(__x86_64__)
-#  include <ci/compat/x86_64.h>
-#  include <ci/compat/gcc_x86.h>
-# elif defined(__PPC__)
-#  include <ci/compat/ppc.h>
-#  include <ci/compat/gcc_ppc.h>
-# elif defined(__ia64__)
-#  include <ci/compat/ia64.h>
-#  include <ci/compat/gcc_ia64.h>
-# else
-#  error Unknown processor - GNU C
-# endif
-
-#elif defined(_MSC_VER)
-
-# include <ci/compat/msvc.h>
-
-# if defined(__i386__)
-#  include <ci/compat/x86.h>
-#  include <ci/compat/msvc_x86.h>
-# elif defined(__x86_64__)
-#  include <ci/compat/x86_64.h>
-#  include <ci/compat/msvc_x86_64.h>
-# else
-#  error Unknown processor MSC
-# endif
-
-#elif defined(__PGI)
-
-# include <ci/compat/x86.h>
-# include <ci/compat/pg_x86.h>
-
-#elif defined(__INTEL_COMPILER)
-
-/* Intel compilers v7 claim to be very gcc compatible. */
-# if __INTEL_COMPILER >= 700
-#  include <ci/compat/gcc.h>
-#  include <ci/compat/x86.h>
-#  include <ci/compat/gcc_x86.h>
-# else
-#  error Old Intel compiler not supported.  Yet.
-# endif
-
-#else
-# error Unknown compiler.
-#endif
-
-
-/**********************************************************************
- * Misc stuff (that probably shouldn't be here).
- */
-
-#ifdef __sun
-# ifdef __KERNEL__
-#  define _KERNEL
-#  define _SYSCALL32
-#  ifdef _LP64
-#   define _SYSCALL32_IMPL
-#  endif
-# else
-#  define _REENTRANT
-# endif
-#endif
-
-
-/**********************************************************************
- * Defaults for anything left undefined.
- */
-
-#ifndef  CI_LIKELY
-# define CI_LIKELY(t)    (t)
-# define CI_UNLIKELY(t)  (t)
-#endif
-
-#ifndef  ci_restrict
-# define ci_restrict
-#endif
-
-#ifndef  ci_inline
-# define ci_inline  static inline
-#endif
-
-#ifndef  ci_noinline
-# define ci_noinline  static
-#endif
-
-#endif  /* __CI_COMPAT_SYSDEP_H__ */
-
-/*! \cidoxg_end */
diff -r 9566a4a50a43 drivers/xen/sfc_netback/ci/compat/utils.h
--- a/drivers/xen/sfc_netback/ci/compat/utils.h
+++ /dev/null
@@ -1,269 +0,0 @@
-/****************************************************************************
- * Copyright 2002-2005: Level 5 Networks Inc.
- * Copyright 2005-2008: Solarflare Communications Inc,
- *                      9501 Jeronimo Road, Suite 250,
- *                      Irvine, CA 92618, USA
- *
- * Maintained by Solarflare Communications
- *  <linux-xen-drivers@solarflare.com>
- *  <onload-dev@solarflare.com>
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 as published
- * by the Free Software Foundation, incorporated herein by reference.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
- ****************************************************************************
- */
-
-/*
- * \author  djr
- *  \brief  Handy utility macros.
- *   \date  2003/01/17
- */
-
-/*! \cidoxg_include_ci_compat  */
-
-#ifndef __CI_COMPAT_UTILS_H__
-#define __CI_COMPAT_UTILS_H__
-
-
-/**********************************************************************
- * Alignment -- [align] must be a power of 2.
- **********************************************************************/
-
-  /*! Align forward onto next boundary. */
-
-#define CI_ALIGN_FWD(p, align)               (((p)+(align)-1u) & ~((align)-1u))
-
-
-  /*! Align back onto prev boundary. */
-
-#define CI_ALIGN_BACK(p, align)              ((p) & ~((align)-1u))
-
-
-  /*! How far to next boundary? */
-
-#define CI_ALIGN_NEEDED(p, align, signed_t)  (-(signed_t)(p) & ((align)-1u))
-
-
-  /*! How far beyond prev boundary? */
-
-#define CI_OFFSET(p, align)                  ((p) & ((align)-1u))
-
-
-  /*! Does object fit in gap before next boundary? */
-
-#define CI_FITS(p, size, align, signed_t)			\
-  (CI_ALIGN_NEEDED((p) + 1, (align), signed_t) + 1 >= (size))
-
-
-  /*! Align forward onto next boundary. */
-
-#define CI_PTR_ALIGN_FWD(p, align)					   \
-  ((char*) CI_ALIGN_FWD(((ci_ptr_arith_t)(p)), ((ci_ptr_arith_t)(align))))
-
-  /*! Align back onto prev boundary. */
-
-#define CI_PTR_ALIGN_BACK(p, align)					    \
-  ((char*) CI_ALIGN_BACK(((ci_ptr_arith_t)(p)), ((ci_ptr_arith_t)(align))))
-
-  /*! How far to next boundary? */
-
-#define CI_PTR_ALIGN_NEEDED(p, align)					\
-  CI_ALIGN_NEEDED(((ci_ptr_arith_t)(p)), ((ci_ptr_arith_t)(align)),	\
-		  ci_ptr_arith_t)
-
-  /*! How far to next boundary? NZ = not zero i.e. give align if on boundary  */
-
-#define CI_PTR_ALIGN_NEEDED_NZ(p, align)					\
-  ((align) - (((char*)p) -                                                      \
-  ((char*) CI_ALIGN_BACK(((ci_ptr_arith_t)(p)), ((ci_ptr_arith_t)(align))))))
-
-  /*! How far beyond prev boundary? */
-
-#define CI_PTR_OFFSET(p, align)					\
-  CI_OFFSET(((ci_ptr_arith_t)(p)), ((ci_ptr_arith_t)(align)))
-
-
-  /* Same as CI_ALIGN_FWD and CI_ALIGN_BACK. */
-
-#define CI_ROUND_UP(i, align)      (((i)+(align)-1u) & ~((align)-1u))
-
-#define CI_ROUND_DOWN(i, align)    ((i) & ~((align)-1u))
-
-
-/**********************************************************************
- * Byte-order
- **********************************************************************/
-
-/* These are not flags.  They are enumeration values for use with
- * CI_MY_BYTE_ORDER. */
-#define CI_BIG_ENDIAN          1
-#define CI_LITTLE_ENDIAN       0
-
-/*
-** Note that these byte-swapping primitives may leave junk in bits above
-** the range they operate on.
-**
-** The CI_BSWAP_nn() routines require that bits above [nn] are zero.  Use
-** CI_BSWAPM_nn(x) if this cannot be guaranteed.
-*/
-
-/* ?? May be able to improve on some of these with inline assembler on some
-** platforms.
-*/
-
-#define CI_BSWAP_16(v)    ((((v) & 0xff) << 8) | ((v) >> 8))
-#define CI_BSWAPM_16(v)   ((((v) & 0xff) << 8) | (((v) & 0xff00) >> 8))
-
-#define CI_BSWAP_32(v)    (((v) >> 24)               | 	\
-			   (((v) & 0x00ff0000) >> 8) |	\
-			   (((v) & 0x0000ff00) << 8) |	\
-			   ((v) << 24))
-#define CI_BSWAPM_32(v)   ((((v) & 0xff000000) >> 24) |	\
-			   (((v) & 0x00ff0000) >> 8)  |	\
-			   (((v) & 0x0000ff00) << 8)  |	\
-			   ((v) << 24))
-
-#define CI_BSWAP_64(v)    (((v) >> 56)                        |	\
-			   (((v) & 0x00ff000000000000) >> 40) |	\
-			   (((v) & 0x0000ff0000000000) >> 24) |	\
-			   (((v) & 0x000000ff00000000) >> 8)  |	\
-			   (((v) & 0x00000000ff000000) << 8)  |	\
-			   (((v) & 0x0000000000ff0000) << 24) |	\
-			   (((v) & 0x000000000000ff00) << 40) |	\
-			   ((v) << 56))
-
-# define CI_BSWAPPED_16_IF(c,v)  ((c) ? CI_BSWAP_16(v) : (v))
-# define CI_BSWAPPED_32_IF(c,v)  ((c) ? CI_BSWAP_32(v) : (v))
-# define CI_BSWAPPED_64_IF(c,v)  ((c) ? CI_BSWAP_64(v) : (v))
-# define CI_BSWAP_16_IF(c,v)     do{ if((c)) (v) = CI_BSWAP_16(v); }while(0)
-# define CI_BSWAP_32_IF(c,v)     do{ if((c)) (v) = CI_BSWAP_32(v); }while(0)
-# define CI_BSWAP_64_IF(c,v)     do{ if((c)) (v) = CI_BSWAP_64(v); }while(0)
-
-#if (CI_MY_BYTE_ORDER == CI_LITTLE_ENDIAN)
-# define CI_BSWAP_LE16(v)    (v)
-# define CI_BSWAP_LE32(v)    (v)
-# define CI_BSWAP_LE64(v)    (v)
-# define CI_BSWAP_BE16(v)    CI_BSWAP_16(v)
-# define CI_BSWAP_BE32(v)    CI_BSWAP_32(v)
-# define CI_BSWAP_BE64(v)    CI_BSWAP_64(v)
-# define CI_BSWAPM_LE16(v)   (v)
-# define CI_BSWAPM_LE32(v)   (v)
-# define CI_BSWAPM_LE64(v)   (v)
-# define CI_BSWAPM_BE16(v)   CI_BSWAPM_16(v)
-# define CI_BSWAPM_BE32(v)   CI_BSWAPM_32(v)
-#elif (CI_MY_BYTE_ORDER == CI_BIG_ENDIAN)
-# define CI_BSWAP_BE16(v)    (v)
-# define CI_BSWAP_BE32(v)    (v)
-# define CI_BSWAP_BE64(v)    (v)
-# define CI_BSWAP_LE16(v)    CI_BSWAP_16(v)
-# define CI_BSWAP_LE32(v)    CI_BSWAP_32(v)
-# define CI_BSWAP_LE64(v)    CI_BSWAP_64(v)
-# define CI_BSWAPM_BE16(v)   (v)
-# define CI_BSWAPM_BE32(v)   (v)
-# define CI_BSWAPM_BE64(v)   (v)
-# define CI_BSWAPM_LE16(v)   CI_BSWAPM_16(v)
-# define CI_BSWAPM_LE32(v)   CI_BSWAPM_32(v)
-#else
-# error Bad endian.
-#endif
-
-
-/**********************************************************************
- * Get pointer to struct from pointer to member
- **********************************************************************/
-
-#define CI_MEMBER_OFFSET(c_type, mbr_name)  \
-  ((ci_uint32) (ci_uintptr_t)(&((c_type*)0)->mbr_name))
-
-#define CI_MEMBER_SIZE(c_type, mbr_name)        \
-  sizeof(((c_type*)0)->mbr_name)
-
-#define __CI_CONTAINER(c_type, mbr_name, p_mbr)  \
-  ( (c_type*) ((char*)(p_mbr) - CI_MEMBER_OFFSET(c_type, mbr_name)) )
-
-#ifndef CI_CONTAINER
-# define CI_CONTAINER(t,m,p)  __CI_CONTAINER(t,m,p)
-#endif
-
-
-/**********************************************************************
- * Structure member initialiser.
- **********************************************************************/
-
-#ifndef CI_STRUCT_MBR
-# define CI_STRUCT_MBR(name, val)	.name = val
-#endif
-
-
-/**********************************************************************
- * min / max
- **********************************************************************/ 
-
-#define CI_MIN(x,y) (((x) < (y)) ? (x) : (y))
-#define CI_MAX(x,y) (((x) > (y)) ? (x) : (y))
-
-/**********************************************************************
- * abs
- **********************************************************************/ 
-
-#define CI_ABS(x) (((x) < 0) ? -(x) : (x))
-
-/**********************************************************************
- * Conditional debugging
- **********************************************************************/ 
-
-#ifdef NDEBUG
-# define CI_DEBUG(x)
-# define CI_NDEBUG(x)      x
-# define CI_IF_DEBUG(y,n)  (n)
-# define CI_DEBUG_ARG(x)
-#else
-# define CI_DEBUG(x)       x
-# define CI_NDEBUG(x)
-# define CI_IF_DEBUG(y,n)  (y)
-# define CI_DEBUG_ARG(x)   ,x
-#endif
-
-#ifdef __KERNEL__
-#define CI_KERNEL_ARG(x)   ,x
-#else
-#define CI_KERNEL_ARG(x)
-#endif
-
-#ifdef _WIN32
-# define CI_KERNEL_ARG_WIN(x) CI_KERNEL_ARG(x)
-# define CI_ARG_WIN(x) ,x
-#else
-# define CI_KERNEL_ARG_WIN(x)
-# define CI_ARG_WIN(x) 
-#endif
-
-#ifdef __unix__
-# define CI_KERNEL_ARG_UNIX(x) CI_KERNEL_ARG(x)
-# define CI_ARG_UNIX(x) ,x
-#else
-# define CI_KERNEL_ARG_UNIX(x)
-# define CI_ARG_UNIX(x) 
-#endif
-
-#ifdef __linux__
-# define CI_KERNEL_ARG_LINUX(x) CI_KERNEL_ARG(x)
-# define CI_ARG_LINUX(x) ,x
-#else
-# define CI_KERNEL_ARG_LINUX(x)
-# define CI_ARG_LINUX(x) 
-#endif
-
-
-#endif  /* __CI_COMPAT_UTILS_H__ */
-/*! \cidoxg_end */
diff -r 9566a4a50a43 drivers/xen/sfc_netback/ci/compat/x86.h
--- a/drivers/xen/sfc_netback/ci/compat/x86.h
+++ /dev/null
@@ -1,48 +0,0 @@
-/****************************************************************************
- * Copyright 2002-2005: Level 5 Networks Inc.
- * Copyright 2005-2008: Solarflare Communications Inc,
- *                      9501 Jeronimo Road, Suite 250,
- *                      Irvine, CA 92618, USA
- *
- * Maintained by Solarflare Communications
- *  <linux-xen-drivers@solarflare.com>
- *  <onload-dev@solarflare.com>
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 as published
- * by the Free Software Foundation, incorporated herein by reference.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
- ****************************************************************************
- */
-
-/*! \cidoxg_include_ci_compat  */
-
-#ifndef __CI_COMPAT_X86_H__
-#define __CI_COMPAT_X86_H__
-
-
-#define CI_MY_BYTE_ORDER   CI_LITTLE_ENDIAN
-
-#define CI_WORD_SIZE       4
-#define CI_PTR_SIZE        4
-
-#define CI_PAGE_SIZE       4096
-#define CI_PAGE_SHIFT      12
-#define CI_PAGE_MASK       (~(CI_PAGE_SIZE - 1))
-
-#define CI_CPU_HAS_SSE	   1	/* SSE extensions supported */
-#define CI_CPU_HAS_SSE2	   0	/* SSE2 extensions supported */
-#define CI_CPU_OOS	   0	/* CPU does out of order stores */
-
-
-#endif  /* __CI_COMPAT_X86_H__ */
-
-/*! \cidoxg_end */
diff -r 9566a4a50a43 drivers/xen/sfc_netback/ci/compat/x86_64.h
--- a/drivers/xen/sfc_netback/ci/compat/x86_64.h
+++ /dev/null
@@ -1,54 +0,0 @@
-/****************************************************************************
- * Copyright 2002-2005: Level 5 Networks Inc.
- * Copyright 2005-2008: Solarflare Communications Inc,
- *                      9501 Jeronimo Road, Suite 250,
- *                      Irvine, CA 92618, USA
- *
- * Maintained by Solarflare Communications
- *  <linux-xen-drivers@solarflare.com>
- *  <onload-dev@solarflare.com>
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 as published
- * by the Free Software Foundation, incorporated herein by reference.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
- ****************************************************************************
- */
-
-/*
- * \author  djr
- *  \brief  Arch stuff for AMD x86_64.
- *   \date  2004/08/17
- */
-
-/*! \cidoxg_include_ci_compat  */
-#ifndef __CI_COMPAT_X86_64_H__
-#define __CI_COMPAT_X86_64_H__
-
-
-#define CI_MY_BYTE_ORDER	CI_LITTLE_ENDIAN
-
-#define CI_WORD_SIZE		8
-#define CI_PTR_SIZE		8
-
-#define CI_PAGE_SIZE		4096
-#define CI_PAGE_SHIFT		12
-#define CI_PAGE_MASK		(~(CI_PAGE_SIZE - 1))
-
-#define CI_CPU_HAS_SSE		1	/* SSE extensions supported */
-
-/* SSE2 disabled while investigating BUG1060 */
-#define CI_CPU_HAS_SSE2		0	/* SSE2 extensions supported */
-#define CI_CPU_OOS		0	/* CPU does out of order stores */
-
-
-#endif  /* __CI_COMPAT_X86_64_H__ */
-/*! \cidoxg_end */
diff -r 9566a4a50a43 drivers/xen/sfc_netback/ci/tools/config.h
--- a/drivers/xen/sfc_netback/ci/tools/config.h
+++ /dev/null
@@ -1,49 +0,0 @@
-/****************************************************************************
- * Copyright 2002-2005: Level 5 Networks Inc.
- * Copyright 2005-2008: Solarflare Communications Inc,
- *                      9501 Jeronimo Road, Suite 250,
- *                      Irvine, CA 92618, USA
- *
- * Maintained by Solarflare Communications
- *  <linux-xen-drivers@solarflare.com>
- *  <onload-dev@solarflare.com>
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 as published
- * by the Free Software Foundation, incorporated herein by reference.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
- ****************************************************************************
- */
-
-/*! \cidoxg_include_ci_tools */
-
-#ifndef __CI_TOOLS_CONFIG_H__
-#define __CI_TOOLS_CONFIG_H__
-
-
-/**********************************************************************
- * Debugging.
- */
-
-#define CI_INCLUDE_ASSERT_VALID           0
-
-/* Set non-zero to allow info about who has allocated what to appear in
- * /proc/drivers/level5/mem.
- * However - Note that doing so can lead to segfault when you unload the
- * driver, and other weirdness.  i.e. I don't think the code for is quite
- * right (written by Oktet, hacked by gel), but it does work well enough to be
- * useful.
- */
-#define CI_MEMLEAK_DEBUG_ALLOC_TABLE	  0
-
-
-#endif  /* __CI_TOOLS_CONFIG_H__ */
-/*! \cidoxg_end */
diff -r 9566a4a50a43 drivers/xen/sfc_netback/ci/tools/debug.h
--- a/drivers/xen/sfc_netback/ci/tools/debug.h
+++ /dev/null
@@ -1,336 +0,0 @@
-/****************************************************************************
- * Copyright 2002-2005: Level 5 Networks Inc.
- * Copyright 2005-2008: Solarflare Communications Inc,
- *                      9501 Jeronimo Road, Suite 250,
- *                      Irvine, CA 92618, USA
- *
- * Maintained by Solarflare Communications
- *  <linux-xen-drivers@solarflare.com>
- *  <onload-dev@solarflare.com>
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 as published
- * by the Free Software Foundation, incorporated herein by reference.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
- ****************************************************************************
- */
-
-/*! \cidoxg_include_ci_tools */
-
-#ifndef __CI_TOOLS_DEBUG_H__
-#define __CI_TOOLS_DEBUG_H__
-
-#define CI_LOG_E(x)       x              /* errors      */
-#define CI_LOG_W(x)       x              /* warnings    */
-#define CI_LOG_I(x)       x              /* information */
-#define CI_LOG_V(x)       x              /* verbose     */
-
-/* Build time asserts. We paste the line number into the type name
- * so that the macro can be used more than once per file even if the
- * compiler objects to multiple identical typedefs. Collisions
- * between use in different header files is still possible. */
-#ifndef CI_BUILD_ASSERT
-#define __CI_BUILD_ASSERT_NAME(_x) __CI_BUILD_ASSERT_ILOATHECPP(_x)
-#define __CI_BUILD_ASSERT_ILOATHECPP(_x)  __CI_BUILD_ASSERT__ ##_x
-#define CI_BUILD_ASSERT(e)\
- typedef char  __CI_BUILD_ASSERT_NAME(__LINE__)[(e)?1:-1]
-#endif
-
-
-#ifdef NDEBUG
-
-# define _ci_check(exp, file, line)
-# define _ci_assert2(e, x, y, file, line)
-# define _ci_assert(exp, file, line)
-# define _ci_assert_equal(exp1, exp2, file, line)
-# define _ci_assert_equiv(exp1, exp2, file, line)
-# define _ci_assert_nequal(exp1, exp2, file, line)
-# define _ci_assert_le(exp1, exp2, file, line)
-# define _ci_assert_lt(exp1, exp2, file, line)
-# define _ci_assert_ge(exp1, exp2, file, line)
-# define _ci_assert_gt(exp1, exp2, file, line)
-# define _ci_assert_impl(exp1, exp2, file, line)
-
-# define _ci_verify(exp, file, line) \
-  do { \
-    (void)(exp); \
-  } while (0)
-
-# define CI_DEBUG_TRY(exp) \
-  do { \
-    (void)(exp); \
-  } while (0)
-
-#define CI_TRACE(exp,fmt)
-#define CI_TRACE_INT(integer)
-#define CI_TRACE_INT32(integer)
-#define CI_TRACE_INT64(integer)
-#define CI_TRACE_UINT(integer)
-#define CI_TRACE_UINT32(integer)
-#define CI_TRACE_UINT64(integer)
-#define CI_TRACE_HEX(integer)
-#define CI_TRACE_HEX32(integer)
-#define CI_TRACE_HEX64(integer)
-#define CI_TRACE_PTR(pointer)
-#define CI_TRACE_STRING(string)
-#define CI_TRACE_MAC(mac)
-#define CI_TRACE_IP(ip_be32)
-#define CI_TRACE_ARP(arp_pkt)
-
-#else
-
-# define _CI_ASSERT_FMT   "\nfrom %s:%d"
-
-# define _ci_check(exp, file, line)                             \
-  do {                                                          \
-    if (CI_UNLIKELY(!(exp)))                                    \
-      ci_warn(("ci_check(%s)"_CI_ASSERT_FMT, #exp,              \
-               (file), (line)));                                \
-  } while (0)
-
-/*
- * NOTE: ci_fail() emits the file and line where the assert is actually
- *       coded.
- */
-
-# define _ci_assert(exp, file, line)                            \
-  do {                                                          \
-    if (CI_UNLIKELY(!(exp)))                                    \
-      ci_fail(("ci_assert(%s)"_CI_ASSERT_FMT, #exp,		\
-               (file), (line)));                                \
-  } while (0)
-
-# define _ci_assert2(e, x, y, file, line)  do {                 \
-    if(CI_UNLIKELY( ! (e) ))                                    \
-      ci_fail(("ci_assert(%s)\nwhere [%s=%"CI_PRIx64"] "        \
-               "[%s=%"CI_PRIx64"]\nat %s:%d\nfrom %s:%d", #e    \
-               , #x, (ci_uint64)(ci_uintptr_t)(x)               \
-               , #y, (ci_uint64)(ci_uintptr_t)(y),              \
-               __FILE__, __LINE__, (file), (line)));            \
-  } while (0)
-
-# define _ci_verify(exp, file, line)                            \
-  do {                                                          \
-    if (CI_UNLIKELY(!(exp)))                                    \
-      ci_fail(("ci_verify(%s)"_CI_ASSERT_FMT, #exp,             \
-               (file), (line)));                                \
-  } while (0)
-
-# define _ci_assert_equal(x, y, f, l)  _ci_assert2((x)==(y), x, y, (f), (l))
-# define _ci_assert_nequal(x, y, f, l) _ci_assert2((x)!=(y), x, y, (f), (l))
-# define _ci_assert_le(x, y, f, l)     _ci_assert2((x)<=(y), x, y, (f), (l))
-# define _ci_assert_lt(x, y, f, l)     _ci_assert2((x)< (y), x, y, (f), (l))
-# define _ci_assert_ge(x, y, f, l)     _ci_assert2((x)>=(y), x, y, (f), (l))
-# define _ci_assert_gt(x, y, f, l)     _ci_assert2((x)> (y), x, y, (f), (l))
-# define _ci_assert_or(x, y, f, l)     _ci_assert2((x)||(y), x, y, (f), (l))
-# define _ci_assert_impl(x, y, f, l)   _ci_assert2(!(x) || (y), x, y, (f), (l))
-# define _ci_assert_equiv(x, y, f, l)  _ci_assert2(!(x)== !(y), x, y, (f), (l))
-
-#define _ci_assert_equal_msg(exp1, exp2, msg, file, line)       \
-  do {                                                          \
-    if (CI_UNLIKELY((exp1)!=(exp2)))                            \
-      ci_fail(("ci_assert_equal_msg(%s == %s) were "            \
-               "(%"CI_PRIx64":%"CI_PRIx64") with msg[%c%c%c%c]" \
-               _CI_ASSERT_FMT, #exp1, #exp2,                    \
-               (ci_uint64)(ci_uintptr_t)(exp1),                 \
-               (ci_uint64)(ci_uintptr_t)(exp2),                 \
-               (((ci_uint32)msg) >> 24) && 0xff,                \
-               (((ci_uint32)msg) >> 16) && 0xff,                \
-               (((ci_uint32)msg) >> 8 ) && 0xff,                \
-               (((ci_uint32)msg)      ) && 0xff,                \
-               (file), (line)));                                \
-  } while (0)
-
-# define CI_DEBUG_TRY(exp)  CI_TRY(exp)
-
-#define CI_TRACE(exp,fmt)						\
-  ci_log("%s:%d:%s] " #exp "=" fmt,                                     \
-         __FILE__, __LINE__, __FUNCTION__, (exp))
-
-
-#define CI_TRACE_INT(integer)						\
-  ci_log("%s:%d:%s] " #integer "=%d",                                   \
-         __FILE__, __LINE__, __FUNCTION__, (integer))
-
-
-#define CI_TRACE_INT32(integer)						\
-  ci_log("%s:%d:%s] " #integer "=%d",                                   \
-         __FILE__, __LINE__, __FUNCTION__, ((ci_int32)integer))
-
-
-#define CI_TRACE_INT64(integer)						\
-  ci_log("%s:%d:%s] " #integer "=%lld",                                 \
-         __FILE__, __LINE__, __FUNCTION__, ((ci_int64)integer))
-
-
-#define CI_TRACE_UINT(integer)						\
-  ci_log("%s:%d:%s] " #integer "=%ud",                                  \
-         __FILE__, __LINE__, __FUNCTION__, (integer))
-
-
-#define CI_TRACE_UINT32(integer)			  	        \
-  ci_log("%s:%d:%s] " #integer "=%ud",                                  \
-         __FILE__, __LINE__, __FUNCTION__, ((ci_uint32)integer))
-
-
-#define CI_TRACE_UINT64(integer)			  	        \
-  ci_log("%s:%d:%s] " #integer "=%ulld",                                \
-         __FILE__, __LINE__, __FUNCTION__, ((ci_uint64)integer))
-
-
-#define CI_TRACE_HEX(integer)						\
-  ci_log("%s:%d:%s] " #integer "=0x%x",                                 \
-         __FILE__, __LINE__, __FUNCTION__, (integer))
-
-
-#define CI_TRACE_HEX32(integer)						\
-  ci_log("%s:%d:%s] " #integer "=0x%x",                                 \
-         __FILE__, __LINE__, __FUNCTION__, ((ci_uint32)integer))
-
-
-#define CI_TRACE_HEX64(integer)						\
-  ci_log("%s:%d:%s] " #integer "=0x%llx",                               \
-         __FILE__, __LINE__, __FUNCTION__, ((ci_uint64)integer))
-
-
-#define CI_TRACE_PTR(pointer)				                \
-  ci_log("%s:%d:%s] " #pointer "=0x%p",                                 \
-         __FILE__, __LINE__, __FUNCTION__, (pointer))
-
-
-#define CI_TRACE_STRING(string)					        \
-  ci_log("%s:%d:%s] " #string "=%s",                                    \
-         __FILE__, __LINE__, __FUNCTION__, (string))
-
-
-#define CI_TRACE_MAC(mac)						\
-  ci_log("%s:%d:%s] " #mac "=" CI_MAC_PRINTF_FORMAT,                    \
-         __FILE__, __LINE__, __FUNCTION__, CI_MAC_PRINTF_ARGS(mac))
-
-
-#define CI_TRACE_IP(ip_be32)						\
-  ci_log("%s:%d:%s] " #ip_be32 "=" CI_IP_PRINTF_FORMAT, __FILE__,       \
-         __LINE__, __FUNCTION__, CI_IP_PRINTF_ARGS(&(ip_be32)))
-
-
-#define CI_TRACE_ARP(arp_pkt)                                           \
-  ci_log("%s:%d:%s]\n"CI_ARP_PRINTF_FORMAT,                             \
-         __FILE__, __LINE__, __FUNCTION__, CI_ARP_PRINTF_ARGS(arp_pkt))
-
-#endif  /* NDEBUG */
-
-#define ci_check(exp) \
-        _ci_check(exp, __FILE__, __LINE__)
-
-#define ci_assert(exp) \
-        _ci_assert(exp, __FILE__, __LINE__)
-
-#define ci_verify(exp) \
-        _ci_verify(exp, __FILE__, __LINE__)
-
-#define ci_assert_equal(exp1, exp2) \
-        _ci_assert_equal(exp1, exp2, __FILE__, __LINE__)
-
-#define ci_assert_equal_msg(exp1, exp2, msg) \
-        _ci_assert_equal_msg(exp1, exp2, msg, __FILE__, __LINE__)
-
-#define ci_assert_nequal(exp1, exp2) \
-        _ci_assert_nequal(exp1, exp2, __FILE__, __LINE__)
-
-#define ci_assert_le(exp1, exp2) \
-        _ci_assert_le(exp1, exp2, __FILE__, __LINE__)
-
-#define ci_assert_lt(exp1, exp2) \
-        _ci_assert_lt(exp1, exp2, __FILE__, __LINE__)
-
-#define ci_assert_ge(exp1, exp2) \
-        _ci_assert_ge(exp1, exp2, __FILE__, __LINE__)
-
-#define ci_assert_gt(exp1, exp2) \
-        _ci_assert_gt(exp1, exp2, __FILE__, __LINE__)
-
-#define ci_assert_impl(exp1, exp2) \
-        _ci_assert_impl(exp1, exp2, __FILE__, __LINE__)
-
-#define ci_assert_equiv(exp1, exp2) \
-        _ci_assert_equiv(exp1, exp2, __FILE__, __LINE__)
-
-
-#define CI_TEST(exp)                            \
-  do{                                           \
-    if( CI_UNLIKELY(!(exp)) )                   \
-      ci_fail(("CI_TEST(%s)", #exp));           \
-  }while(0)
-
-
-#define CI_TRY(exp)				\
-  do{						\
-    int _trc;					\
-    _trc=(exp);					\
-    if( CI_UNLIKELY(_trc < 0) )			\
-      ci_sys_fail(#exp, _trc);			\
-  }while(0)
-
-
-#define CI_TRY_RET(exp)							 \
-  do{									 \
-    int _trc;								 \
-    _trc=(exp);								 \
-    if( CI_UNLIKELY(_trc < 0) ) {					 \
-      ci_log("%s returned %d at %s:%d", #exp, _trc, __FILE__, __LINE__); \
-      return _trc;							 \
-    }									 \
-  }while(0)
-
-#define CI_LOGLEVEL_TRY_RET(logfn, exp)                                    \
-  do{									 \
-    int _trc;								 \
-    _trc=(exp);								 \
-    if( CI_UNLIKELY(_trc < 0) ) {					 \
-      logfn (ci_log("%s returned %d at %s:%d", #exp, _trc, __FILE__, __LINE__)); \
-      return _trc;							 \
-    }									 \
-  }while(0)
-
-
-#define CI_SOCK_TRY(exp)			\
-  do{						\
-    ci_sock_err_t _trc;				\
-    _trc=(exp);					\
-    if( CI_UNLIKELY(!ci_sock_errok(_trc)) )	\
-      ci_sys_fail(#exp, _trc.val);		\
-  }while(0)
-
-
-#define CI_SOCK_TRY_RET(exp)						     \
-  do{									     \
-    ci_sock_err_t _trc;							     \
-    _trc=(exp);								     \
-    if( CI_UNLIKELY(!ci_sock_errok(_trc)) ) {		  		     \
-      ci_log("%s returned %d at %s:%d", #exp, _trc.val, __FILE__, __LINE__); \
-      return ci_sock_errcode(_trc);					     \
-    }									     \
-  }while(0)
-
-
-#define CI_SOCK_TRY_SOCK_RET(exp)					     \
-  do{									     \
-    ci_sock_err_t _trc;							     \
-    _trc=(exp);								     \
-    if( CI_UNLIKELY(!ci_sock_errok(_trc)) ) {		  		     \
-      ci_log("%s returned %d at %s:%d", #exp, _trc.val, __FILE__, __LINE__); \
-      return _trc;							     \
-    }									     \
-  }while(0)
-
-#endif  /* __CI_TOOLS_DEBUG_H__ */
-
-/*! \cidoxg_end */
diff -r 9566a4a50a43 drivers/xen/sfc_netback/ci/tools/log.h
--- a/drivers/xen/sfc_netback/ci/tools/log.h
+++ /dev/null
@@ -1,269 +0,0 @@
-/****************************************************************************
- * Copyright 2002-2005: Level 5 Networks Inc.
- * Copyright 2005-2008: Solarflare Communications Inc,
- *                      9501 Jeronimo Road, Suite 250,
- *                      Irvine, CA 92618, USA
- *
- * Maintained by Solarflare Communications
- *  <linux-xen-drivers@solarflare.com>
- *  <onload-dev@solarflare.com>
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 as published
- * by the Free Software Foundation, incorporated herein by reference.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
- ****************************************************************************
- */
-
-/*
- * \author  djr
- *  \brief  Functions for logging and pretty-printing.
- *   \date  2002/08/07
- */
-
-/*! \cidoxg_include_ci_tools */
-
-#ifndef __CI_TOOLS_LOG_H__
-#define __CI_TOOLS_LOG_H__
-
-#include <stdarg.h>
-
-
-/**********************************************************************
- * Logging.
- */
-
-/* size of internal log buffer */ 
-#define  CI_LOG_MAX_LINE        512
-/* uses of ci_log must ensure that all trace messages are shorter than this */ 
-#define  CI_LOG_MAX_MSG_LENGTH        (CI_LOG_MAX_LINE-50)
-
-extern void ci_vlog(const char* fmt, va_list args)  CI_HF;
-extern void ci_log(const char* fmt, ...) CI_PRINTF_LIKE(1,2) CI_HF;
-
-  /*! Set the prefix for log messages.
-  **
-  ** Uses the storage pointed to by \em prefix.  Therefore \em prefix must
-  ** be allocated on the heap, or statically.
-  */
-extern void ci_set_log_prefix(const char* prefix)  CI_HF;
-
-typedef void (*ci_log_fn_t)(const char* msg);
-extern ci_log_fn_t  ci_log_fn  CI_HV;
-
-/* Log functions. */
-extern void ci_log_null(const char* msg) CI_HF;
-extern void ci_log_stderr(const char* msg) CI_HF;
-extern void ci_log_stdout(const char* msg) CI_HF;
-extern void ci_log_syslog(const char* msg) CI_HF;
-
-/*! Call the following to install special logging behaviours. */
-extern void ci_log_buffer_till_fail(void) CI_HF;
-extern void ci_log_buffer_till_exit(void) CI_HF;
-
-extern void __ci_log_unique(const char* msg) CI_HF;
-extern ci_log_fn_t __ci_log_unique_fn CI_HV;
-ci_inline void ci_log_uniquify(void) {
-  if( ci_log_fn != __ci_log_unique ) {
-    __ci_log_unique_fn = ci_log_fn;
-    ci_log_fn = __ci_log_unique;
-  }
-}
-
-extern void ci_log_file(const char* msg) CI_HF;
-extern int  ci_log_file_fd CI_HV;
-
-extern void __ci_log_nth(const char* msg) CI_HF;
-extern ci_log_fn_t __ci_log_nth_fn CI_HV;
-extern int  ci_log_nth_n CI_HV;  /* default 100 */
-ci_inline void ci_log_nth(void) {
-  if( ci_log_fn != __ci_log_nth ) {
-    __ci_log_nth_fn = ci_log_fn;
-    ci_log_fn = __ci_log_nth;
-  }
-}
-
-extern int  ci_log_level  CI_HV;
-
-extern int  ci_log_options  CI_HV;
-#define CI_LOG_PID		0x1
-#define CI_LOG_TID		0x2
-#define CI_LOG_TIME		0x4
-#define CI_LOG_DELTA		0x8
-
-/**********************************************************************
- * Used to define which mode we are in
- */
-#if (defined(_WIN32) && !defined(__KERNEL__))
-typedef enum {
-  ci_log_md_NULL=0,
-    ci_log_md_ioctl,
-    ci_log_md_stderr,
-    ci_log_md_stdout,
-    ci_log_md_file,
-    ci_log_md_serial,
-    ci_log_md_syslog,
-    ci_log_md_pidfile
-} ci_log_mode_t;
-extern ci_log_mode_t ci_log_mode;
-#endif
-
-/**********************************************************************
- * Pretty-printing.
- */
-
-extern char ci_printable_char(char c) CI_HF;
-
-extern void (*ci_hex_dump_formatter)(char* buf, const ci_octet* s,
-				     int i, int off, int len) CI_HV;
-extern void ci_hex_dump_format_octets(char*,const ci_octet*,int,int,int) CI_HF;
-extern void ci_hex_dump_format_dwords(char*,const ci_octet*,int,int,int) CI_HF;
-
-extern void ci_hex_dump_row(char* buf, volatile const void* s, int len,
-			    ci_ptr_arith_t address) CI_HF;
-  /*!< A row contains up to 16 bytes.  Row starts at [address & 15u], so
-  ** therefore [len + (address & 15u)] must be <= 16.
-  */
-
-extern void ci_hex_dump(ci_log_fn_t, volatile const void*,
-			int len, ci_ptr_arith_t address) CI_HF;
-
-extern int  ci_hex_dump_to_raw(const char* src_hex, void* buf,
-			       unsigned* addr_out_opt, int* skip)  CI_HF;
-  /*!< Recovers raw data from a single line of a hex dump.  [buf] must be at
-  ** least 16 bytes long.  Returns the number of bytes written to [buf] (in
-  ** range 1 -> 16), or -1 if [src_hex] doesn't contain hex data.  Does not
-  ** cope with missing bytes at the start of a line.
-  */
-
-extern int ci_format_eth_addr(char* buf, const void* eth_mac_addr,
-			      char sep)  CI_HF;
-  /*!< This will write 18 characters to <buf> including terminating null.
-  ** Returns number of bytes written excluding null.  If [sep] is zero, ':'
-  ** is used.
-  */
-
-extern int ci_parse_eth_addr(void* eth_mac_addr,
-			     const char* str, char sep) CI_HF;
-  /*!< If [sep] is zero, absolutely any separator is accepted (even
-  ** inconsistent separators).  Returns 0 on success, -1 on error.
-  */
-
-extern int ci_format_ip4_addr(char* buf, unsigned addr_be32) CI_HF;
-  /*!< Formats the IP address (in network endian) in dotted-quad.  Returns
-  ** the number of bytes written (up to 15), excluding the null.  [buf]
-  ** must be at least 16 bytes long.
-  */
-
-#if defined(__unix__) && ! defined(__KERNEL__)
-extern int ci_format_select_set(char* s, int len_s, int nfds, const fd_set*);
-extern int ci_format_select(char* s, int len_s,
-			    int nfds, const fd_set* rds, const fd_set* wrs,
-			    const fd_set* exs, struct timeval* timeout);
-#endif
-
-
-/**********************************************************************
- * Error checking.
- */
-
-extern void (*ci_fail_stop_fn)(void) CI_HV;
-
-extern void ci_fail_stop(void) CI_HF;
-extern void ci_fail_hang(void) CI_HF;
-extern void ci_fail_bomb(void) CI_HF;
-extern void ci_backtrace(void) CI_HF;
-
-#if defined __linux__ && !defined __KERNEL__
-extern void ci_fail_abort (void) CI_HF;
-#endif
-
-#ifdef __GNUC__
-extern void
-__ci_fail(const char*, ...) CI_PRINTF_LIKE(1,2) CI_HF;
-#else
-# if _PREFAST_
-  extern void _declspec(noreturn) __ci_fail(const char* fmt, ...);
-# else 
-  extern void __ci_fail(const char* fmt, ...);
-# endif
-
-#endif
-
-#define ci_warn(x)							   \
-  do{ ci_log("WARN at %s:%d", __FILE__, __LINE__); }while(0)
-
-#define ci_fail(x)							   \
-  do{ ci_log("FAIL at %s:%d", __FILE__, __LINE__);  __ci_fail x; }while(0)
-
-extern void __ci_sys_fail(const char* fn, int rc,
-			  const char* file, int line) CI_HF;
-#define ci_sys_fail(fn, rc)  __ci_sys_fail(fn, rc, __FILE__, __LINE__)
-
-/**********************************************************************
- * Logging to buffer (src/citools/log_buffer.c)
- */
-
-/*! Divert ci_log() messages to the log buffer
- *  normally they go to the  system console */
-extern void ci_log_buffer_till_fail(void) CI_HF;
-
-/*! Dump the contents of the log buffer to the system console */
-extern void ci_log_buffer_dump(void) CI_HF;
-
-
-/**********************************************************************
- * Some useful pretty-printing.
- */
-
-#ifdef  __linux__
-# define CI_SOCKCALL_FLAGS_FMT	"%s%s%s%s%s%s%s%s%s%s%s"
-
-# define CI_SOCKCALL_FLAGS_PRI_ARG(x)		\
-  (((x) & MSG_OOB         ) ? "OOB "         :""),	\
-  (((x) & MSG_PEEK        ) ? "PEEK "        :""),	\
-  (((x) & MSG_DONTROUTE   ) ? "DONTROUTE "   :""),	\
-  (((x) & MSG_EOR         ) ? "EOR "         :""),	\
-  (((x) & MSG_CTRUNC      ) ? "CTRUNC "      :""),	\
-  (((x) & MSG_TRUNC       ) ? "TRUNC "       :""),	\
-  (((x) & MSG_WAITALL     ) ? "WAITALL "     :""),	\
-  (((x) & MSG_DONTWAIT    ) ? "DONTWAIT "    :""),	\
-  (((x) & MSG_NOSIGNAL    ) ? "NOSIGNAL "    :""),	\
-  (((x) & MSG_ERRQUEUE    ) ? "ERRQUEUE "    :""),	\
-  (((x) & MSG_CONFIRM     ) ? "CONFIRM "     :"")
-#endif
-
-#ifdef  _WIN32
-# define CI_SOCKCALL_FLAGS_FMT	"%s%s%s"
-
-# define CI_SOCKCALL_FLAGS_PRI_ARG(x)		\
-  (((x) & MSG_OOB         ) ? "OOB "         :""),	\
-  (((x) & MSG_PEEK        ) ? "PEEK "        :""),	\
-  (((x) & MSG_DONTROUTE   ) ? "DONTROUTE "   :"")
-#endif
-
-#ifdef  __sun__
-# define CI_SOCKCALL_FLAGS_FMT	"%s%s%s%s%s%s%s%s%s"
-
-# define CI_SOCKCALL_FLAGS_PRI_ARG(x)		\
-  (((x) & MSG_OOB         ) ? "OOB "         :""),	\
-  (((x) & MSG_PEEK        ) ? "PEEK "        :""),	\
-  (((x) & MSG_DONTROUTE   ) ? "DONTROUTE "   :""),	\
-  (((x) & MSG_EOR         ) ? "EOR "         :""),	\
-  (((x) & MSG_CTRUNC      ) ? "CTRUNC "      :""),	\
-  (((x) & MSG_TRUNC       ) ? "TRUNC "       :""),	\
-  (((x) & MSG_WAITALL     ) ? "WAITALL "     :""),	\
-  (((x) & MSG_DONTWAIT    ) ? "DONTWAIT "    :""),	\
-  (((x) & MSG_NOTIFICATION) ? "NOTIFICATION" :"")
-#endif
-
-#endif  /* __CI_TOOLS_LOG_H__ */
-/*! \cidoxg_end */
diff -r 9566a4a50a43 drivers/xen/sfc_netback/ci/tools/platform/gcc_x86.h
--- a/drivers/xen/sfc_netback/ci/tools/platform/gcc_x86.h
+++ /dev/null
@@ -1,370 +0,0 @@
-/****************************************************************************
- * Copyright 2002-2005: Level 5 Networks Inc.
- * Copyright 2005-2008: Solarflare Communications Inc,
- *                      9501 Jeronimo Road, Suite 250,
- *                      Irvine, CA 92618, USA
- *
- * Maintained by Solarflare Communications
- *  <linux-xen-drivers@solarflare.com>
- *  <onload-dev@solarflare.com>
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 as published
- * by the Free Software Foundation, incorporated herein by reference.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
- ****************************************************************************
- */
-
-/*! \cidoxg_include_ci_tools_platform  */
-
-#ifndef __CI_TOOLS_GCC_X86_H__
-#define __CI_TOOLS_GCC_X86_H__
-
-
-/**********************************************************************
- * Free-running cycle counters.
- */
-
-#define CI_HAVE_FRC64
-#define CI_HAVE_FRC32
-
-#define ci_frc32(pval)  __asm__ __volatile__("rdtsc" : "=a" (*pval) : : "edx")
-
-#if defined(__x86_64__)
-ci_inline void ci_frc64(ci_uint64* pval) {
-  /* temp fix until we figure how to get this out in one bite */	   
-  ci_uint64 low, high;
-  __asm__ __volatile__("rdtsc" : "=a" (low) , "=d" (high));	 	
-  *pval = (high << 32) | low;
-}
-
-#else
-#define ci_frc64(pval)  __asm__ __volatile__("rdtsc" : "=A" (*pval))
-#endif
-
-#define ci_frc_flush()  /* ?? Need a pipeline barrier. */
-
-
-/**********************************************************************
- * Atomic integer.
- */
-
-/*
-** int  ci_atomic_read(a)         { return a->n;        }
-** void ci_atomic_set(a, v)       { a->n = v;           }
-** void ci_atomic_inc(a)          { ++a->n;             }
-** void ci_atomic_dec(a)          { --a->n;             }
-** int  ci_atomic_inc_and_test(a) { return ++a->n == 0; }
-** int  ci_atomic_dec_and_test(a) { return --a->n == 0; }
-** void ci_atomic_and(a, v)       { a->n &= v;          }
-** void ci_atomic_or(a, v)        { a->n |= v;          }
-*/
-
-typedef struct { volatile ci_int32 n; } ci_atomic_t;
-
-#define CI_ATOMIC_INITIALISER(i)  {(i)}
-
-static inline ci_int32  ci_atomic_read(const ci_atomic_t* a) { return a->n; }
-static inline void ci_atomic_set(ci_atomic_t* a, int v) { a->n = v; ci_wmb();   }
-
-static inline void ci_atomic_inc(ci_atomic_t* a)
-{ __asm__ __volatile__("lock; incl %0" : "+m" (a->n)); }
-
- 
-static inline void ci_atomic_dec(ci_atomic_t* a)
-{ __asm__ __volatile__("lock; decl %0" : "+m" (a->n)); }
-
-static inline int ci_atomic_inc_and_test(ci_atomic_t* a) {
-  char r;
-  __asm__ __volatile__("lock; incl %0; sete %1"
-		       : "+m" (a->n), "=qm" (r));
-  return r;
-}
-
-static inline int ci_atomic_dec_and_test(ci_atomic_t* a) {
-  char r;
-  __asm__ __volatile__("lock; decl %0; sete %1"
-		       : "+m" (a->n), "=qm" (r));
-  return r;
-}
-
-ci_inline int
-ci_atomic_xadd (ci_atomic_t *a, int v) {
-   __asm__ ("lock xadd %0, %1" : "=r" (v), "+m" (a->n) : "0" (v));
-  return v;
-}
-ci_inline int
-ci_atomic_xchg (ci_atomic_t *a, int v) {
-   __asm__ ("lock xchg %0, %1" : "=r" (v), "+m" (a->n) : "0" (v));
-  return v;
-}
-
-ci_inline void ci_atomic32_or(volatile ci_uint32* p, ci_uint32 mask)
-{ __asm__ __volatile__("lock; orl %1, %0" : "+m" (*p) : "ir" (mask)); }
-
-ci_inline void ci_atomic32_and(volatile ci_uint32* p, ci_uint32 mask)
-{ __asm__ __volatile__("lock; andl %1, %0" : "+m" (*p) : "ir" (mask)); }
-
-ci_inline void ci_atomic32_add(volatile ci_uint32* p, ci_uint32 v)
-{ __asm__ __volatile__("lock; addl %1, %0" : "+m" (*p) : "ir" (v)); }
-
-ci_inline void ci_atomic32_inc(volatile ci_uint32* p)
-{ __asm__ __volatile__("lock; incl %0" : "+m" (*p)); }
-
-ci_inline int ci_atomic32_dec_and_test(volatile ci_uint32* p) {
-  char r;
-  __asm__ __volatile__("lock; decl %0; sete %1" : "+m" (*p), "=qm" (r));
-  return r;
-}
-
-#define ci_atomic_or(a, v)   ci_atomic32_or ((ci_uint32*) &(a)->n, (v))
-#define ci_atomic_and(a, v)  ci_atomic32_and((ci_uint32*) &(a)->n, (v))
-#define ci_atomic_add(a, v)  ci_atomic32_add((ci_uint32*) &(a)->n, (v))
-
-extern int ci_glibc_uses_nptl (void) CI_HF;
-extern int ci_glibc_nptl_broken(void) CI_HF;
-extern int ci_glibc_gs_get_is_multihreaded_offset (void) CI_HF;
-extern int ci_glibc_gs_is_multihreaded_offset CI_HV;
-
-#if !defined(__x86_64__)
-#ifdef __GLIBC__
-/* Returns non-zero if the calling process might be mulithreaded, returns 0 if
- * it definitely isn't (i.e. if reimplementing this function for other
- * architectures and platforms, you can safely just return 1).
- */
-static inline int ci_is_multithreaded (void) {
-
-  while (1) {
-    if (ci_glibc_gs_is_multihreaded_offset >= 0) {
-      /* NPTL keeps a variable that tells us this hanging off gs (i.e. in thread-
-       * local storage); just return this
-       */
-      int r;
-      __asm__ __volatile__ ("movl %%gs:(%1), %0"
-                            : "=r" (r)
-                            : "r" (ci_glibc_gs_is_multihreaded_offset));
-      return r;
-    }
-
-    if (ci_glibc_gs_is_multihreaded_offset == -2) {
-      /* This means we've already determined that the libc version is NOT good
-       * for our funky "is multithreaded" hack
-       */
-      return 1;
-    }
-
-    /* If we get here, it means this is the first time the function has been
-     * called -- detect the libc version and go around again.
-     */
-    ci_glibc_gs_is_multihreaded_offset = ci_glibc_gs_get_is_multihreaded_offset ();
-
-    /* Go around again.  We do the test here rather than at the top so that we go
-     * quicker in the common the case
-     */
-  }
-}
-
-#else    /* def __GLIBC__ */
-
-#define ci_is_multithreaded() 1 /* ?? Is the the POSIX way of finding out */
-                                /*    whether the appication is single */
-                                /*    threaded? */
-
-#endif   /* def __GLIBC__ */
-
-#else    /* defined __x86_64__ */
-
-static inline int ci_is_multithreaded (void) {
-  /* Now easy way to tell on x86_64; so assume we're multithreaded */
-  return 1;
-}
-
-#endif    /* defined __x86_64__ */
-
-
-/**********************************************************************
- * Compare and swap.
- */
-
-#define CI_HAVE_COMPARE_AND_SWAP
-
-ci_inline int ci_cas32_succeed(volatile ci_int32* p, ci_int32 oldval,
-                               ci_int32 newval) {
-  char ret;
-  ci_int32 prevval;
-  __asm__ __volatile__("lock; cmpxchgl %3, %1; sete %0"
-		       : "=q"(ret), "+m"(*p), "=a"(prevval)
-		       : "r"(newval), "a"(oldval));
-  return ret;
-}
-
-ci_inline int ci_cas32_fail(volatile ci_int32* p, ci_int32 oldval,
-                            ci_int32 newval) {
-  char ret;
-  ci_int32 prevval;
-  __asm__ __volatile__("lock; cmpxchgl %3, %1; setne %0"
-		       : "=q"(ret), "+m"(*p), "=a"(prevval)
-		       : "r"(newval), "a"(oldval));
-  return ret;
-}
-
-#ifdef __x86_64__
-ci_inline int ci_cas64_succeed(volatile ci_int64* p, ci_int64 oldval,
-			       ci_int64 newval) {
-  char ret;
-  ci_int64 prevval;
-  __asm__ __volatile__("lock; cmpxchgq %3, %1; sete %0"
-		       : "=q"(ret), "+m"(*p), "=a"(prevval)
-		       : "r"(newval), "a"(oldval));
-  return ret;
-}
-
-ci_inline int ci_cas64_fail(volatile ci_int64* p, ci_int64 oldval,
-			    ci_int64 newval) {
-  char ret;
-  ci_int64 prevval;
-  __asm__ __volatile__("lock; cmpxchgq %3, %1; setne %0"
-		       : "=q"(ret), "+m"(*p), "=a"(prevval)
-		       : "r"(newval), "a"(oldval));
-  return ret;
-}
-#endif
-
-ci_inline int ci_cas32u_succeed(volatile ci_uint32* p, ci_uint32 oldval, ci_uint32 newval) {
-  char ret;
-  ci_uint32 prevval;
-  __asm__ __volatile__("lock; cmpxchgl %3, %1; sete %0"
-		       : "=q"(ret), "+m"(*p), "=a"(prevval)
-		       : "r"(newval), "a"(oldval));
-  return ret;
-}
-
-ci_inline int ci_cas32u_fail(volatile ci_uint32* p, ci_uint32 oldval, ci_uint32 newval) {
-  char ret;
-  ci_uint32 prevval;
-  __asm__ __volatile__("lock; cmpxchgl %3, %1; setne %0"
-		       : "=q"(ret), "+m"(*p), "=a"(prevval)
-		       : "r"(newval), "a"(oldval));
-  return ret;
-}
-
-ci_inline int ci_cas64u_succeed(volatile ci_uint64* p, ci_uint64 oldval,
-			       ci_uint64 newval) {
-  char ret;
-  ci_uint64 prevval;
-  __asm__ __volatile__("lock; cmpxchgq %3, %1; sete %0"
-		       : "=q"(ret), "+m"(*p), "=a"(prevval)
-		       : "r"(newval), "a"(oldval));
-  return ret;
-}
-
-ci_inline int ci_cas64u_fail(volatile ci_uint64* p, ci_uint64 oldval,
-			    ci_uint64 newval) {
-  char ret;
-  ci_uint64 prevval;
-  __asm__ __volatile__("lock; cmpxchgq %3, %1; setne %0"
-		       : "=q"(ret), "+m"(*p), "=a"(prevval)
-		       : "r"(newval), "a"(oldval));
-  return ret;
-}
-
-#ifdef __x86_64__
-
-# define ci_cas_uintptr_succeed(p,o,n)				\
-    ci_cas64u_succeed((volatile ci_uint64*) (p), (o), (n))
-# define ci_cas_uintptr_fail(p,o,n)				\
-    ci_cas64u_fail((volatile ci_uint64*) (p), (o), (n))
-
-#else
-
-# define ci_cas_uintptr_succeed(p,o,n)				\
-    ci_cas32u_succeed((volatile ci_uint32*) (p), (o), (n))
-# define ci_cas_uintptr_fail(p,o,n)				\
-    ci_cas32u_fail((volatile ci_uint32*) (p), (o), (n))
-
-#endif
-
-
-/**********************************************************************
- * Atomic bit field.
- */
-
-typedef ci_uint32  ci_bits;
-#define CI_BITS_N			32u
-
-#define CI_BITS_DECLARE(name, n)			\
-  ci_bits name[((n) + CI_BITS_N - 1u) / CI_BITS_N]
-
-ci_inline void ci_bits_clear_all(volatile ci_bits* b, int n_bits)
-{ memset((void*) b, 0, (n_bits+CI_BITS_N-1u) / CI_BITS_N * sizeof(ci_bits)); }
-
-ci_inline void ci_bit_set(volatile ci_bits* b, int i) {
-  __asm__ __volatile__("lock; btsl %1, %0"
-		       : "=m" (*b)
-		       : "Ir" (i));
-}
-
-ci_inline void ci_bit_clear(volatile ci_bits* b, int i) {
-  __asm__ __volatile__("lock; btrl %1, %0"
-		       : "=m" (*b)
-		       : "Ir" (i));
-}
-
-ci_inline int  ci_bit_test(volatile ci_bits* b, int i) {
-  char rc;
-  __asm__("btl %2, %1; setc %0"
-	  : "=r" (rc)
-	  : "m" (*b), "Ir" (i));
-  return rc;
-}
-
-ci_inline int ci_bit_test_and_set(volatile ci_bits* b, int i) {
-  char rc;
-  __asm__ __volatile__("lock; btsl %2, %1; setc %0"
-		       : "=r" (rc), "+m" (*b)
-		       : "Ir" (i));
-  return rc;
-}
-
-ci_inline int ci_bit_test_and_clear(volatile ci_bits* b, int i) {
-  char rc;
-  __asm__ __volatile__("lock; btrl %2, %1; setc %0"
-		       : "=r" (rc), "+m" (*b)
-		       : "Ir" (i));
-  return rc;
-}
-
-/* These mask ops only work within a single ci_bits word. */
-#define ci_bit_mask_set(b,m)	ci_atomic32_or((b), (m))
-#define ci_bit_mask_clear(b,m)	ci_atomic32_and((b), ~(m))
-
-
-/**********************************************************************
- * Misc.
- */
-
-#if __GNUC__ >= 3
-# define ci_spinloop_pause()  __asm__("pause") 
-#else
-# define ci_spinloop_pause()  __asm__(".byte 0xf3, 0x90")
-#endif
-
-
-#define CI_HAVE_ADDC32
-#define ci_add_carry32(sum, v)  __asm__("addl %1, %0 ;"			  \
-					"adcl $0, %0 ;"			  \
-					: "=r" (sum)			  \
-					: "g" ((ci_uint32) v), "0" (sum))
-
-
-#endif  /* __CI_TOOLS_GCC_X86_H__ */
-
-/*! \cidoxg_end */
diff -r 9566a4a50a43 drivers/xen/sfc_netback/ci/tools/platform/linux_kernel.h
--- a/drivers/xen/sfc_netback/ci/tools/platform/linux_kernel.h
+++ /dev/null
@@ -1,362 +0,0 @@
-/****************************************************************************
- * Copyright 2002-2005: Level 5 Networks Inc.
- * Copyright 2005-2008: Solarflare Communications Inc,
- *                      9501 Jeronimo Road, Suite 250,
- *                      Irvine, CA 92618, USA
- *
- * Maintained by Solarflare Communications
- *  <linux-xen-drivers@solarflare.com>
- *  <onload-dev@solarflare.com>
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 as published
- * by the Free Software Foundation, incorporated herein by reference.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
- ****************************************************************************
- */
-
-
-/*! \cidoxg_include_ci_tools_platform  */
-
-#ifndef __CI_TOOLS_LINUX_KERNEL_H__
-#define __CI_TOOLS_LINUX_KERNEL_H__
-
-/**********************************************************************
- * Need to know the kernel version.
- */
-
-#ifndef LINUX_VERSION_CODE
-# include <linux/version.h>
-# ifndef UTS_RELEASE
-   /* 2.6.18 onwards defines UTS_RELEASE in a separate header */
-#  include <linux/utsrelease.h>
-# endif
-#endif
-
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0) || \
-    LINUX_VERSION_CODE >= KERNEL_VERSION(2,7,0)
-# error "Linux 2.6 required"
-#endif
-
-
-#include <linux/slab.h>     /* kmalloc / kfree */
-#include <linux/vmalloc.h>  /* vmalloc / vfree */
-#include <linux/interrupt.h>/* in_interrupt()  */
-#include <linux/in.h>
-#include <linux/in6.h>
-#include <linux/spinlock.h>
-#include <linux/highmem.h>
-#include <linux/smp_lock.h>
-#include <linux/ctype.h>
-#include <linux/uio.h>
-#include <asm/current.h>
-#include <asm/errno.h>
-#include <asm/kmap_types.h>
-#include <asm/semaphore.h>
-
-#include <ci/tools/config.h>
-
-#define ci_in_irq        in_irq
-#define ci_in_interrupt  in_interrupt
-#define ci_in_atomic     in_atomic
-
-
-/**********************************************************************
- * Misc stuff.
- */
-
-#ifdef BUG
-# define  CI_BOMB     BUG
-#endif
-
-ci_inline void* __ci_alloc(size_t n)
-{ return kmalloc(n, (in_interrupt() ? GFP_ATOMIC : GFP_KERNEL)); }
-
-ci_inline void* __ci_atomic_alloc(size_t n)
-{ return kmalloc(n, GFP_ATOMIC ); }
-
-ci_inline void  __ci_free(void* p)     { return kfree(p);   }
-ci_inline void* __ci_vmalloc(size_t n) { return vmalloc(n); }
-ci_inline void  __ci_vfree(void* p)    { return vfree(p);   }
-
-
-#if CI_MEMLEAK_DEBUG_ALLOC_TABLE
-  #define ci_alloc(s)     ci_alloc_memleak_debug (s, __FILE__, __LINE__)
-  #define ci_atomic_alloc(s)  ci_atomic_alloc_memleak_debug(s, __FILE__, __LINE__)
-  #define ci_free         ci_free_memleak_debug
-  #define ci_vmalloc(s)   ci_vmalloc_memleak_debug (s, __FILE__,__LINE__)
-  #define ci_vfree        ci_vfree_memleak_debug
-  #define ci_alloc_fn     ci_alloc_fn_memleak_debug
-  #define ci_vmalloc_fn   ci_vmalloc_fn_memleak_debug
-#else /* !CI_MEMLEAK_DEBUG_ALLOC_TABLE */
-  #define ci_alloc_fn     __ci_alloc
-  #define ci_vmalloc_fn   __ci_vmalloc
-#endif 
-
-#ifndef ci_alloc
-  #define ci_atomic_alloc __ci_atomic_alloc
-  #define ci_alloc        __ci_alloc
-  #define ci_free         __ci_free
-  #define ci_vmalloc      __ci_vmalloc
-  #define ci_vmalloc_fn   __ci_vmalloc
-  #define ci_vfree        __ci_vfree
-#endif
-
-#define ci_sprintf        sprintf
-#define ci_vsprintf       vsprintf
-#define ci_snprintf       snprintf
-#define ci_vsnprintf      vsnprintf
-#define ci_sscanf         sscanf
-
-
-#define CI_LOG_FN_DEFAULT  ci_log_syslog
-
-
-/*--------------------------------------------------------------------
- *
- * irqs_disabled - needed for kmap helpers on some kernels 
- *
- *--------------------------------------------------------------------*/
-#ifdef irqs_disabled
-# define ci_irqs_disabled irqs_disabled
-#else
-# if defined(__i386__) | defined(__x86_64__)
-#   define ci_irqs_disabled(x)                  \
-  ({                                            \
-    unsigned long flags;                        \
-    local_save_flags(flags);                    \
-    !(flags & (1<<9));                          \
-  })
-# else
-#  error "Need to implement irqs_disabled() for your architecture"
-# endif
-#endif
-
-
-/**********************************************************************
- * kmap helpers. 
- *
- * Use ci_k(un)map for code paths which are not in an atomic context.
- * For atomic code you need to use ci_k(un)map_in_atomic. This will grab
- * one of the per-CPU kmap slots.
- *
- * NB in_interrupt != in_irq. If you don't know the difference then
- * don't use kmap_in_atomic
- *
- * 2.4 allocates kmap slots by function. We are going to re-use the
- * skb module's slot - we also use the same interlock
- * 
- * 2.6 allocates kmap slots by type as well as by function. We are
- * going to use the currently (2.6.10) unsused SOFTIRQ slot 
- *
- */
-
-ci_inline void* ci_kmap(struct page *page) {
-  CI_DEBUG(if( ci_in_atomic() | ci_in_interrupt() | ci_in_irq() )  BUG());
-  return kmap(page);
-}
-
-ci_inline void ci_kunmap(struct page *page) {
-  kunmap(page);
-}
-
-#define CI_KM_SLOT KM_SOFTIRQ0
-
-
-typedef struct semaphore ci_semaphore_t;
-
-ci_inline void
-ci_sem_init (ci_semaphore_t *sem, int val) {
-  sema_init (sem, val);
-}
-
-ci_inline void
-ci_sem_down (ci_semaphore_t *sem) {
-  down (sem);
-}
-
-ci_inline int
-ci_sem_trydown (ci_semaphore_t *sem) {
-  return down_trylock (sem);
-}
-
-ci_inline void
-ci_sem_up (ci_semaphore_t *sem) {
-  up (sem);
-}
-
-ci_inline int
-ci_sem_get_count(ci_semaphore_t *sem) {
-  return sem->count.counter;
-}
-
-ci_inline void* ci_kmap_in_atomic(struct page *page) 
-{
-  CI_DEBUG(if( ci_in_irq() )  BUG());
-
-  /* iSCSI can call without in_interrupt() but with irqs_disabled()
-     and in a context that can't sleep, so we need to check that
-     too */
-  if(ci_in_interrupt() || ci_irqs_disabled())
-    return kmap_atomic(page, CI_KM_SLOT);
-  else
-    return kmap(page);
-}
-
-ci_inline void ci_kunmap_in_atomic(struct page *page, void* kaddr) 
-{
-  CI_DEBUG(if( ci_in_irq() )  BUG());
-
-  /* iSCSI can call without in_interrupt() but with irqs_disabled()
-     and in a context that can't sleep, so we need to check that
-     too */
-  if(ci_in_interrupt() || ci_irqs_disabled())
-    kunmap_atomic(kaddr, CI_KM_SLOT);
-  else
-    kunmap(page);
-}
-
-/**********************************************************************
- * spinlock implementation: used by <ci/tools/spinlock.h>
- */
-
-#define CI_HAVE_SPINLOCKS
-
-typedef ci_uintptr_t    			ci_lock_holder_t;
-#define ci_lock_thisthread 		(ci_lock_holder_t)current		       	
-#define ci_lock_no_holder     (ci_lock_holder_t)NULL
-
-typedef spinlock_t			ci_lock_i;
-typedef spinlock_t			ci_irqlock_i;
-typedef unsigned long			ci_irqlock_state_t;
-
-#define IRQLOCK_CYCLES  500000
-
-#define ci_lock_ctor_i(l)		spin_lock_init(l)
-#define ci_lock_dtor_i(l)		do{}while(0)
-#define ci_lock_lock_i(l)		spin_lock(l)
-#define ci_lock_trylock_i(l)		spin_trylock(l)
-#define ci_lock_unlock_i(l)		spin_unlock(l)
-
-#define ci_irqlock_ctor_i(l)		spin_lock_init(l)
-#define ci_irqlock_dtor_i(l)		do{}while(0)
-#define ci_irqlock_lock_i(l,s)		spin_lock_irqsave(l,*(s))
-#define ci_irqlock_unlock_i(l,s)	spin_unlock_irqrestore(l, *(s))
-
-
-/**********************************************************************
- * register access
- */
-
-#include <asm/io.h>
-
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,9)
-typedef volatile void __iomem*	ioaddr_t;
-#else
-typedef unsigned long ioaddr_t;
-#endif
-
-
-
-/**********************************************************************
- * thread implementation -- kernel dependancies probably should be
- * moved to driver/linux_kernel.h
- */
-
-#define ci_linux_daemonize(name) daemonize(name)
-
-#include <linux/workqueue.h>
-
-
-typedef struct {
-  void*			(*fn)(void* arg);
-  void*			arg;
-  const char*		name;
-  int			thrd_id;
-  struct completion	exit_event;
-  struct work_struct	keventd_witem;
-} ci_kernel_thread_t;
-
-
-typedef ci_kernel_thread_t* cithread_t;
-
-
-extern int cithread_create(cithread_t* tid, void* (*fn)(void*), void* arg,
-			   const char* name);
-extern int cithread_detach(cithread_t kt);
-extern int cithread_join(cithread_t kt);
-
-
-/* Kernel sysctl variables. */
-extern int sysctl_tcp_wmem[3];
-extern int sysctl_tcp_rmem[3];
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,24)
-#define LINUX_HAS_SYSCTL_MEM_MAX
-extern ci_uint32 sysctl_wmem_max;
-extern ci_uint32 sysctl_rmem_max;
-#endif
-
-
-/*--------------------------------------------------------------------
- *
- * ci_bigbuf_t: An abstraction of a large buffer.  Needed because in the
- * Linux kernel, large buffers need to be allocated with vmalloc(), whereas
- * smaller buffers should use kmalloc().  This abstraction chooses the
- * appropriate mechansim.
- *
- *--------------------------------------------------------------------*/
-
-typedef struct {
-  char*		p;
-  int		is_vmalloc;
-} ci_bigbuf_t;
-
-
-ci_inline int ci_bigbuf_alloc(ci_bigbuf_t* bb, size_t bytes) {
-  if( bytes >= CI_PAGE_SIZE && ! ci_in_atomic() ) {
-    bb->is_vmalloc = 1;
-    if( (bb->p = vmalloc(bytes)) )  return 0;
-  }
-  bb->is_vmalloc = 0;
-  bb->p = kmalloc(bytes, ci_in_interrupt() ? GFP_ATOMIC : GFP_KERNEL);
-  return bb->p ? 0 : -ENOMEM;
-}
-
-ci_inline void ci_bigbuf_free(ci_bigbuf_t* bb) {
-  if( bb->is_vmalloc )  vfree(bb->p);
-  else                  kfree(bb->p);
-}
-
-ci_inline char* ci_bigbuf_ptr(ci_bigbuf_t* bb)
-{ return bb->p; }
-
-/**********************************************************************
- * struct iovec abstraction (for Windows port)
- */
-
-typedef struct iovec ci_iovec;
-
-/* Accessors for buffer/length */
-#define CI_IOVEC_BASE(i) ((i)->iov_base)
-#define CI_IOVEC_LEN(i)  ((i)->iov_len)
-
-/**********************************************************************
- * Signals
- */
-
-ci_inline void
-ci_send_sig(int signum)
-{
-  send_sig(signum, current, 0);
-}
-
-#endif  /* __CI_TOOLS_LINUX_KERNEL_H__ */
-/*! \cidoxg_end */
diff -r 9566a4a50a43 drivers/xen/sfc_netback/ci/tools/sysdep.h
--- a/drivers/xen/sfc_netback/ci/tools/sysdep.h
+++ /dev/null
@@ -1,132 +0,0 @@
-/****************************************************************************
- * Copyright 2002-2005: Level 5 Networks Inc.
- * Copyright 2005-2008: Solarflare Communications Inc,
- *                      9501 Jeronimo Road, Suite 250,
- *                      Irvine, CA 92618, USA
- *
- * Maintained by Solarflare Communications
- *  <linux-xen-drivers@solarflare.com>
- *  <onload-dev@solarflare.com>
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 as published
- * by the Free Software Foundation, incorporated herein by reference.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
- ****************************************************************************
- */
-
-/*! \cidoxg_include_ci_tools */
-
-#ifndef __CI_TOOLS_SYSDEP_H__
-#define __CI_TOOLS_SYSDEP_H__
-
-/* Make this header self-sufficient */
-#include <ci/compat.h>
-#include <ci/tools/log.h>
-#include <ci/tools/debug.h>
-
-
-/**********************************************************************
- * Platform dependencies.
- */
-
-#if defined(__KERNEL__)
-
-# if defined(__linux__)
-#  include <ci/tools/platform/linux_kernel.h>
-# elif defined(_WIN32)
-#  include <ci/tools/platform/win32_kernel.h>
-# elif defined(__sun__)
-#  include <ci/tools/platform/sunos_kernel.h>
-# else
-#  error Unknown platform.
-# endif
-
-#elif defined(_WIN32)
-
-# include <ci/tools/platform/win32.h>
-
-#elif defined(__unix__)
-
-# include <ci/tools/platform/unix.h>
-
-#else
-
-# error Unknown platform.
-
-#endif
-
-#if defined(__linux__)
-/*! Linux sendfile() support enable/disable. */
-# define CI_HAVE_SENDFILE            /* provide sendfile i/f */
-
-# define CI_HAVE_OS_NOPAGE
-#endif
-
-#if defined(__sun__)
-# define CI_HAVE_SENDFILE	     /* provide sendfile i/f */
-# define CI_HAVE_SENDFILEV           /* provide sendfilev i/f */
-
-# define CI_IOCTL_SENDFILE           /*  use efrm CI_SENDFILEV ioctl */
-#endif
-
-#if defined(_WIN32)
-typedef ci_uint32 ci_uerr_t; /* range of OS user-mode return codes */
-typedef ci_uint32 ci_kerr_t; /* range of OS kernel-mode return codes */
-#elif defined(__unix__)
-typedef ci_int32 ci_uerr_t; /* range of OS user-mode return codes */
-typedef ci_int32 ci_kerr_t; /* range of OS kernel-mode return codes */
-#endif
-
-
-/**********************************************************************
- * Compiler and processor dependencies.
- */
-
-#if defined(__GNUC__)
-
-#if defined(__i386__) || defined(__x86_64__)
-# include <ci/tools/platform/gcc_x86.h>
-#elif defined(__PPC__)
-#  include <ci/tools/platform/gcc_ppc.h>
-#elif defined(__ia64__)
-#  include <ci/tools/platform/gcc_ia64.h>
-#else
-# error Unknown processor.
-#endif
-
-#elif defined(_MSC_VER)
-
-#if defined(__i386__)
-# include <ci/tools/platform/msvc_x86.h>
-# elif defined(__x86_64__)
-# include <ci/tools/platform/msvc_x86_64.h>
-#else
-# error Unknown processor.
-#endif
-
-#elif defined(__PGI)
-
-# include <ci/tools/platform/pg_x86.h>
-
-#elif defined(__INTEL_COMPILER)
-
-/* Intel compilers v7 claim to be very gcc compatible. */
-# include <ci/tools/platform/gcc_x86.h>
-
-#else
-# error Unknown compiler.
-#endif
-
-
-#endif  /* __CI_TOOLS_SYSDEP_H__ */
-
-/*! \cidoxg_end */
diff -r 9566a4a50a43 drivers/xen/sfc_netfront/Makefile
--- a/drivers/xen/sfc_netfront/Makefile
+++ /dev/null
@@ -1,11 +0,0 @@
-EXTRA_CFLAGS += -Idrivers/xen/sfc_netfront -Idrivers/xen/sfc_netutil -Idrivers/xen/netfront
-EXTRA_CFLAGS += -D__ci_driver__
-EXTRA_CFLAGS += -Werror
-
-ifdef GCOV
-EXTRA_CFLAGS += -fprofile-arcs -ftest-coverage -DEFX_GCOV
-endif
-
-obj-$(CONFIG_XEN_NETDEV_ACCEL_SFC_FRONTEND)	:= sfc_netfront.o
-
-sfc_netfront-objs := accel_msg.o accel_bufs.o accel_netfront.o accel_vi.o accel_xenbus.o accel_tso.o accel_ssr.o accel_debugfs.o falcon_event.o falcon_vi.o pt_tx.o vi_init.o
diff -r 9566a4a50a43 drivers/xen/sfc_netfront/accel.h
--- a/drivers/xen/sfc_netfront/accel.h
+++ /dev/null
@@ -1,494 +0,0 @@
-/****************************************************************************
- * Solarflare driver for Xen network acceleration
- *
- * Copyright 2006-2008: Solarflare Communications Inc,
- *                      9501 Jeronimo Road, Suite 250,
- *                      Irvine, CA 92618, USA
- *
- * Maintained by Solarflare Communications <linux-xen-drivers@solarflare.com>
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 as published
- * by the Free Software Foundation, incorporated herein by reference.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
- ****************************************************************************
- */
-
-#ifndef NETFRONT_ACCEL_H
-#define NETFRONT_ACCEL_H
-
-#include "accel_msg_iface.h"
-#include "accel_cuckoo_hash.h"
-#include "accel_bufs.h"
-
-#include "etherfabric/ef_vi.h"
-
-#include <xen/xenbus.h>
-#include <xen/evtchn.h>
-
-#include <linux/kernel.h>
-#include <linux/version.h>
-#include <linux/list.h>
-
-enum netfront_accel_post_status {
-	NETFRONT_ACCEL_STATUS_GOOD,
-	NETFRONT_ACCEL_STATUS_BUSY,
-	NETFRONT_ACCEL_STATUS_CANT
-};
-
-#define NETFRONT_ACCEL_STATS 1
-#if NETFRONT_ACCEL_STATS
-#define NETFRONT_ACCEL_STATS_OP(x) x
-#else
-#define NETFRONT_ACCEL_STATS_OP(x)
-#endif
-
-
-enum netfront_accel_msg_state {
-	NETFRONT_ACCEL_MSG_NONE = 0,
-	NETFRONT_ACCEL_MSG_HELLO = 1,
-	NETFRONT_ACCEL_MSG_HW = 2
-};
-
-
-typedef struct {
-	u32 in_progress;
-	u32 total_len;
-	struct sk_buff *skb;
-} netfront_accel_jumbo_state;
-
-
-struct netfront_accel_ssr_state {
-	/** List of tracked connections. */
-	struct list_head conns;
-
-	/** Free efx_ssr_conn instances. */
-	struct list_head free_conns;
-};
-
-
-struct netfront_accel_netdev_stats {
-	/* Fastpath stats. */
-	u32 fastpath_rx_pkts;
-	u32 fastpath_rx_bytes;
-	u32 fastpath_rx_errors;
-	u32 fastpath_tx_pkts; 
-	u32 fastpath_tx_bytes;
-	u32 fastpath_tx_errors;
-};
-
-
-struct netfront_accel_netdev_dbfs {
-	struct dentry *fastpath_rx_pkts;
-	struct dentry *fastpath_rx_bytes;
-	struct dentry *fastpath_rx_errors;
-	struct dentry *fastpath_tx_pkts; 
-	struct dentry *fastpath_tx_bytes;
-	struct dentry *fastpath_tx_errors;
-};
-
-
-struct netfront_accel_stats {
-	/** Fast path events */
-	u64 fastpath_tx_busy;
-
-	/** TX DMA queue status */
-	u64 fastpath_tx_completions;
-
-	/** The number of events processed. */
-	u64 event_count;
-
-	/** Number of frame trunc events seen on fastpath */
-	u64 fastpath_frm_trunc;
-
-	/** Number of rx discard (bad crc) events seen on fastpath */
-	u64 fastpath_crc_bad;
-
-	/** Number of rx discard (bad csum) events seen on fastpath */
-	u64 fastpath_csum_bad;
-
-	/** Number of rx discard (bad rights) events seen on fastpath */
-	u64 fastpath_rights_bad;
-
-	/** Number of rx discard ("other") events seen on fastpath */
-	u64 fastpath_discard_other;
-
-	/** Number of no rx descriptor trunc events seen on fastpath */
-	u64 rx_no_desc_trunc;
-
-	/** The number of misc bad events processed. */
-	u64 bad_event_count;
-
-	/** Number of events dealt with in poll loop */
-	u32 events_per_poll_max;
-	u32 events_per_poll_tx_max;
-	u32 events_per_poll_rx_max;
-
-	/** Largest number of concurrently outstanding tx descriptors */
-	u32 fastpath_tx_pending_max;
-
-	/** The number of events since the last interrupts. */
-	u32 event_count_since_irq;
-
-	/** The max number of events between interrupts. */
-	u32 events_per_irq_max;
-
-	/** The number of interrupts. */
-	u64 irq_count;
-
-	/** The number of useless interrupts. */
-	u64 useless_irq_count;
-
-	/** The number of polls scheduled. */
-	u64 poll_schedule_count;
-
-	/** The number of polls called. */
-	u64 poll_call_count;
-
-	/** The number of rechecks. */
-	u64 poll_reschedule_count;
-
-	/** Number of times we've called netif_stop_queue/netif_wake_queue */
-	u64 queue_stops;
-	u64 queue_wakes;
-
-	/** SSR stats */
-	u64 ssr_bursts;
-	u64 ssr_drop_stream;
-	u64 ssr_misorder;
-	u64 ssr_slow_start;
-	u64 ssr_merges;
-	u64 ssr_too_many;
-	u64 ssr_new_stream;
-};
-
-
-struct netfront_accel_dbfs {
-	struct dentry *fastpath_tx_busy;
-	struct dentry *fastpath_tx_completions;
-	struct dentry *fastpath_tx_pending_max;
-	struct dentry *fastpath_frm_trunc;
-	struct dentry *fastpath_crc_bad;
-	struct dentry *fastpath_csum_bad;
-	struct dentry *fastpath_rights_bad;
-	struct dentry *fastpath_discard_other;
-	struct dentry *rx_no_desc_trunc;
-	struct dentry *event_count;
-	struct dentry *bad_event_count;
-	struct dentry *events_per_poll_max;
-	struct dentry *events_per_poll_rx_max;
-	struct dentry *events_per_poll_tx_max;
-	struct dentry *event_count_since_irq;
-	struct dentry *events_per_irq_max;
-	struct dentry *irq_count;
-	struct dentry *useless_irq_count;
-	struct dentry *poll_schedule_count;
-	struct dentry *poll_call_count;
-	struct dentry *poll_reschedule_count;
-	struct dentry *queue_stops;
-	struct dentry *queue_wakes;
-	struct dentry *ssr_bursts;
-	struct dentry *ssr_drop_stream;
-	struct dentry *ssr_misorder;
-	struct dentry *ssr_slow_start;
-	struct dentry *ssr_merges;
-	struct dentry *ssr_too_many;
-	struct dentry *ssr_new_stream;
-};
-
-
-typedef struct netfront_accel_vnic {
-	struct netfront_accel_vnic *next;
-	
-	struct mutex vnic_mutex;
-
-	spinlock_t tx_lock;
-
-	struct netfront_accel_bufpages bufpages;
-	struct netfront_accel_bufinfo *rx_bufs;
-	struct netfront_accel_bufinfo *tx_bufs;
-	
-	/** Hardware & VI state */
-	ef_vi vi;
-
-	ef_vi_state *vi_state;
-
-	ef_eventq_state evq_state;
-
-	void *evq_mapping;
-
-	/** Hardware dependant state */
-	union {
-		struct {
-			/** Falcon A or B */
-			enum net_accel_hw_type type; 
-			u32 *evq_rptr;
-			u32 *doorbell;
-			void *evq_rptr_mapping;
-			void *doorbell_mapping;
-			void *txdmaq_mapping;
-			void *rxdmaq_mapping;
-		} falcon;
-	} hw;
-  
-	/** RX DMA queue status */
-	u32 rx_dma_level;
-
-	/** Number of RX descriptors waiting to be pushed to the card. */
-	u32 rx_dma_batched;
-#define NETFRONT_ACCEL_RX_DESC_BATCH 16
-
-	/**
-	 * Hash table of remote mac addresses to decide whether to try
-	 * fast path
-	 */
-	cuckoo_hash_table fastpath_table;
-	spinlock_t table_lock;
-
-	/** the local mac address of virtual interface we're accelerating */
-	u8 mac[ETH_ALEN];
-
-	int rx_pkt_stride;
-	int rx_skb_stride;
-
-	/**
-	 * Keep track of fragments of jumbo packets as events are
-	 * delivered by NIC 
-	 */
-	netfront_accel_jumbo_state jumbo_state;
-
-	struct net_device *net_dev;
-
-	/** These two gate the enabling of fast path operations */
-	int frontend_ready;
-	int backend_netdev_up;
-
-	int irq_enabled;
-	spinlock_t irq_enabled_lock;
-
-	int tx_enabled;
-
-	int poll_enabled;
-
-	/** A spare slot for a TX packet.  This is treated as an
-	 * extension of the DMA queue.  Reads require either
-	 * netfront's tx_lock or the vnic tx_lock; writes require both
-	 * locks */
-	struct sk_buff *tx_skb;
-
-	/** Keep track of fragments of SSR packets */
-	struct netfront_accel_ssr_state ssr_state;
-
-	struct xenbus_device *dev;
-
-	/** Event channel for messages */
-	int msg_channel;
-	int msg_channel_irq;
-
-	/** Event channel for network interrupts. */
-	int net_channel;
-	int net_channel_irq;
-
-	struct net_accel_shared_page *shared_page;
-
-	grant_ref_t ctrl_page_gnt;
-	grant_ref_t msg_page_gnt;
-
-	/** Message Qs, 1 each way. */
-	sh_msg_fifo2 to_dom0;
-	sh_msg_fifo2 from_dom0;
-
-	enum netfront_accel_msg_state msg_state;
-
-	/** Watch on accelstate */
-	struct xenbus_watch backend_accel_watch;
-	/** Watch on frontend's MAC address */
-	struct xenbus_watch mac_address_watch;
-
-	/** Work to process received irq/msg */
-	struct work_struct msg_from_bend;
-
-	/** Wait queue for changes in accelstate. */
-	wait_queue_head_t state_wait_queue;
-
-	/** The current accelstate of this driver. */
-	XenbusState frontend_state;
-
-	/** The most recent accelstate seen by the xenbus watch. */
-	XenbusState backend_state;
-
-	/** Non-zero if we should reject requests to connect. */
-	int removing;
-
-	/** Non-zero if the domU shared state has been initialised. */
-	int domU_state_is_setup;
-
-	/** Non-zero if the dom0 shared state has been initialised. */
-	int dom0_state_is_setup;
-
-	/* Those statistics that are added to the netdev stats */
-	struct netfront_accel_netdev_stats netdev_stats;
-	struct netfront_accel_netdev_stats stats_last_read;
-#ifdef CONFIG_DEBUG_FS
-	struct netfront_accel_netdev_dbfs netdev_dbfs;
-#endif
-
-	/* These statistics are internal and optional */
-#if NETFRONT_ACCEL_STATS
-	struct netfront_accel_stats stats;
-#ifdef CONFIG_DEBUG_FS
-	struct netfront_accel_dbfs dbfs;
-#endif
-#endif
-
-	/** Debufs fs dir for this interface */
-	struct dentry *dbfs_dir;
-} netfront_accel_vnic;
-
-
-/* Module parameters */
-extern unsigned sfc_netfront_max_pages;
-extern unsigned sfc_netfront_buffer_split;
-
-extern const char *frontend_name;
-extern struct netfront_accel_hooks accel_hooks;
-extern struct workqueue_struct *netfront_accel_workqueue;
-
-
-extern
-void netfront_accel_vi_ctor(netfront_accel_vnic *vnic);
-
-extern
-int netfront_accel_vi_init(netfront_accel_vnic *vnic, 
-			   struct net_accel_msg_hw *hw_msg);
-
-extern
-void netfront_accel_vi_dtor(netfront_accel_vnic *vnic);
-
-
-/**
- * Add new buffers which have been registered with the NIC.
- *
- * @v   vnic     The vnic instance to process the response.
- *
- * The buffers contained in the message are added to the buffer pool.
- */
-extern
-void netfront_accel_vi_add_bufs(netfront_accel_vnic *vnic, int is_rx);
-
-/**
- * Put a packet on the tx DMA queue.
- *
- * @v  vnic	 The vnic instance to accept the packet.
- * @v  skb	 A sk_buff to send.
- *
- * Attempt to send a packet.  On success, the skb is owned by the DMA
- * queue and will be released when the completion event arrives.
- */
-extern enum netfront_accel_post_status
-netfront_accel_vi_tx_post(netfront_accel_vnic *vnic,
-			  struct sk_buff *skb);
-
-
-/**
- * Process events in response to an interrupt.
- *
- * @v   vnic       The vnic instance to poll.
- * @v   rx_packets The maximum number of rx packets to process.
- * @ret rx_done    The number of rx packets processed.
- *
- * The vnic will process events until there are no more events
- * remaining or the specified number of rx packets has been processed.
- * The split from the interrupt call is to allow Linux NAPI
- * polling.
- */
-extern
-int netfront_accel_vi_poll(netfront_accel_vnic *vnic, int rx_packets);
-
-
-/**
- * Iterate over the fragments of a packet buffer.
- *
- * @v   skb      The packet buffer to examine.
- * @v   idx      A variable name for the fragment index.
- * @v   data     A variable name for the address of the fragment data.
- * @v   length   A variable name for the fragment length.
- * @v   code     A section of code to execute for each fragment.
- *
- * This macro iterates over the fragments in a packet buffer and
- * executes the code for each of them.
- */
-#define NETFRONT_ACCEL_PKTBUFF_FOR_EACH_FRAGMENT(skb, frag_idx,		\
-						 frag_data, frag_len,   \
-						 code)			\
-	do {								\
-		int frag_idx;						\
-		void *frag_data;					\
-		unsigned int	  frag_len;				\
-									\
-		frag_data = skb->data;					\
-		frag_len = skb_headlen(skb);				\
-		frag_idx = 0;						\
-		while (1) { /* For each fragment */			\
-			code;						\
-			if (frag_idx >= skb_shinfo(skb)->nr_frags) {	\
-				break;					\
-			} else {					\
-				skb_frag_t *fragment;			\
-				fragment = &skb_shinfo(skb)->frags[frag_idx]; \
-				frag_len = fragment->size;		\
-				frag_data = ((void*)page_address(fragment->page) \
-					     + fragment->page_offset);	\
-			};						\
-			frag_idx++;					\
-		}							\
-	} while(0)
-
-static inline
-void netfront_accel_disable_net_interrupts(netfront_accel_vnic *vnic)
-{
-	mask_evtchn(vnic->net_channel);
-}
-
-static inline
-void netfront_accel_enable_net_interrupts(netfront_accel_vnic *vnic)
-{
-	unmask_evtchn(vnic->net_channel);
-}
-
-void netfront_accel_msg_tx_fastpath(netfront_accel_vnic *vnic, const void *mac,
-				    u32 ip, u16 port, u8 protocol);
-
-/* Process an IRQ received from back end driver */
-irqreturn_t netfront_accel_msg_channel_irq_from_bend(int irq, void *context);
-irqreturn_t netfront_accel_net_channel_irq_from_bend(int irq, void *context);
-
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,20)
-extern void netfront_accel_msg_from_bend(struct work_struct *context);
-#else
-extern void netfront_accel_msg_from_bend(void *context);
-#endif
-
-extern void vnic_stop_fastpath(netfront_accel_vnic *vnic);
-
-extern int netfront_accel_probe(struct net_device *net_dev, 
-				struct xenbus_device *dev);
-extern int netfront_accel_remove(struct xenbus_device *dev);
-extern void netfront_accel_set_closing(netfront_accel_vnic *vnic);
-
-extern int netfront_accel_vi_enable_interrupts(netfront_accel_vnic *vnic);
-
-extern void netfront_accel_debugfs_init(void);
-extern void netfront_accel_debugfs_fini(void);
-extern int netfront_accel_debugfs_create(netfront_accel_vnic *vnic);
-extern int netfront_accel_debugfs_remove(netfront_accel_vnic *vnic);
-
-#endif /* NETFRONT_ACCEL_H */
diff -r 9566a4a50a43 drivers/xen/sfc_netfront/accel_bufs.c
--- a/drivers/xen/sfc_netfront/accel_bufs.c
+++ /dev/null
@@ -1,393 +0,0 @@
-/****************************************************************************
- * Solarflare driver for Xen network acceleration
- *
- * Copyright 2006-2008: Solarflare Communications Inc,
- *                      9501 Jeronimo Road, Suite 250,
- *                      Irvine, CA 92618, USA
- *
- * Maintained by Solarflare Communications <linux-xen-drivers@solarflare.com>
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 as published
- * by the Free Software Foundation, incorporated herein by reference.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
- ****************************************************************************
- */
-
-#include <xen/gnttab.h>
-
-#include "accel_bufs.h"
-#include "accel_util.h"
-
-#include "accel.h"
-
-
-static int 
-netfront_accel_alloc_buf_desc_blocks(struct netfront_accel_bufinfo *manager,
-				     int pages)
-{
-	manager->desc_blocks = 
-		kzalloc(sizeof(struct netfront_accel_pkt_desc *) * 
-			NETFRONT_ACCEL_BUF_NUM_BLOCKS(pages), GFP_KERNEL);
-	if (manager->desc_blocks == NULL) {
-		return -ENOMEM;
-	}
-	
-	return 0;
-}
-
-static int 
-netfront_accel_alloc_buf_lists(struct netfront_accel_bufpages *bufpages,
-			       int pages)
-{
-	bufpages->page_list = kmalloc(pages * sizeof(void *), GFP_KERNEL);
-	if (bufpages->page_list == NULL) {
-		return -ENOMEM;
-	}
-
-	bufpages->grant_list = kzalloc(pages * sizeof(grant_ref_t), GFP_KERNEL);
-	if (bufpages->grant_list == NULL) {
-		kfree(bufpages->page_list);
-		bufpages->page_list = NULL;
-		return -ENOMEM;
-	}
-
-	return 0;
-}
-
-
-int netfront_accel_alloc_buffer_mem(struct netfront_accel_bufpages *bufpages,
-				    struct netfront_accel_bufinfo *rx_manager,
-				    struct netfront_accel_bufinfo *tx_manager,
-				    int pages)
-{
-	int n, rc;
-
-	if ((rc = netfront_accel_alloc_buf_desc_blocks
-	     (rx_manager, pages - (pages / sfc_netfront_buffer_split))) < 0) {
-		goto rx_fail;
-	}
-
-	if ((rc = netfront_accel_alloc_buf_desc_blocks
-	     (tx_manager, pages / sfc_netfront_buffer_split)) < 0) {
-		goto tx_fail;
-	}
-
-	if ((rc = netfront_accel_alloc_buf_lists(bufpages, pages)) < 0) {
-		goto lists_fail;
-	}
-
-	for (n = 0; n < pages; n++) {
-		void *tmp = (void*)__get_free_page(GFP_KERNEL);
-		if (tmp == NULL)
-			break;
-
-		bufpages->page_list[n] = tmp;
-	}
-
-	if (n != pages) {
-		EPRINTK("%s: not enough pages: %d != %d\n", __FUNCTION__, n, 
-			pages);
-		for (; n >= 0; n--)
-			free_page((unsigned long)(bufpages->page_list[n]));
-		rc = -ENOMEM;
-		goto pages_fail;
-	}
-
-	bufpages->max_pages = pages;
-	bufpages->page_reqs = 0;
-
-	return 0;
-
- pages_fail:
-	kfree(bufpages->page_list);
-	kfree(bufpages->grant_list);
-
-	bufpages->page_list = NULL;
-	bufpages->grant_list = NULL;
- lists_fail:
-	kfree(tx_manager->desc_blocks);
-	tx_manager->desc_blocks = NULL;
-
- tx_fail:
-	kfree(rx_manager->desc_blocks);
-	rx_manager->desc_blocks = NULL;
- rx_fail:
-	return rc;
-}
-
-
-void netfront_accel_free_buffer_mem(struct netfront_accel_bufpages *bufpages,
-				    struct netfront_accel_bufinfo *rx_manager,
-				    struct netfront_accel_bufinfo *tx_manager)
-{
-	int i;
-
-	for (i = 0; i < bufpages->max_pages; i++) {
-		if (bufpages->grant_list[i] != 0)
-			net_accel_ungrant_page(bufpages->grant_list[i]);
-		free_page((unsigned long)(bufpages->page_list[i]));
-	}
-
-	if (bufpages->max_pages) {
-		kfree(bufpages->page_list);
-		kfree(bufpages->grant_list);
-		kfree(rx_manager->desc_blocks);
-		kfree(tx_manager->desc_blocks);
-	}
-}
-
-
-/*
- * Allocate memory for the buffer manager and create a lock.  If no
- * lock is supplied its own is allocated.
- */
-struct netfront_accel_bufinfo *netfront_accel_init_bufs(spinlock_t *lock)
-{
-	struct netfront_accel_bufinfo *res = kmalloc(sizeof(*res), GFP_KERNEL);
-	if (res != NULL) {
-		res->npages = res->nused = 0;
-		res->first_free = -1;
-
-		if (lock == NULL) {
-			res->lock = kmalloc(sizeof(*res->lock), GFP_KERNEL);
-			if (res->lock == NULL) {
-				kfree(res);
-				return NULL;
-			}
-			spin_lock_init(res->lock);
-			res->internally_locked = 1;
-		} else {
-			res->lock = lock;
-			res->internally_locked = 0;
-		}
-		
-		res->desc_blocks = NULL;
-	}
-
-	return res;
-}
-
-
-void netfront_accel_fini_bufs(struct netfront_accel_bufinfo *bufs)
-{
-	if (bufs->internally_locked)
-		kfree(bufs->lock);
-	kfree(bufs);
-}
-
-
-int netfront_accel_buf_map_request(struct xenbus_device *dev,
-				   struct netfront_accel_bufpages *bufpages,
-				   struct net_accel_msg *msg, 
-				   int pages, int offset)
-{
-	int i, mfn;
-	int err;
-
-	net_accel_msg_init(msg, NET_ACCEL_MSG_MAPBUF);
-
-	BUG_ON(pages > NET_ACCEL_MSG_MAX_PAGE_REQ);
-
-	msg->u.mapbufs.pages = pages;
-
-	for (i = 0; i < msg->u.mapbufs.pages; i++) {
-		/* 
-		 * This can happen if we tried to send this message
-		 * earlier but the queue was full.
-		 */
-		if (bufpages->grant_list[offset+i] != 0) {
-			msg->u.mapbufs.grants[i] = 
-				bufpages->grant_list[offset+i];
-			continue;
-		}
-
-		mfn = virt_to_mfn(bufpages->page_list[offset+i]);
-		VPRINTK("%s: Granting page %d, mfn %08x\n",
-			__FUNCTION__, i, mfn);
-
-		bufpages->grant_list[offset+i] =
-			net_accel_grant_page(dev, mfn, 0);
-		msg->u.mapbufs.grants[i] = bufpages->grant_list[offset+i];
-
-		if (msg->u.mapbufs.grants[i] < 0) {
-			EPRINTK("%s: Failed to grant buffer: %d\n",
-				__FUNCTION__, msg->u.mapbufs.grants[i]);
-			err = -EIO;
-			goto error;
-		}
-	}
-
-	/* This is interpreted on return as the offset in the the page_list */
-	msg->u.mapbufs.reqid = offset;
-
-	return 0;
-
-error:
-	/* Ungrant all the pages we've successfully granted. */
-	for (i--; i >= 0; i--) {
-		net_accel_ungrant_page(bufpages->grant_list[offset+i]);
-		bufpages->grant_list[offset+i] = 0;
-	}
-	return err;
-}
-
-
-/* Process a response to a buffer request. */
-int netfront_accel_add_bufs(struct netfront_accel_bufpages *bufpages,
-			    struct netfront_accel_bufinfo *manager, 
-			    struct net_accel_msg *msg)
-{
-	int msg_pages, page_offset, i, newtot;
-	int old_block_count, new_block_count;
-	u32 msg_buf;
-	unsigned long flags;
-
-	VPRINTK("%s: manager %p msg %p\n", __FUNCTION__, manager, msg);
-
-	BUG_ON(msg->id != (NET_ACCEL_MSG_MAPBUF | NET_ACCEL_MSG_REPLY));
-
-	msg_pages = msg->u.mapbufs.pages;
-	msg_buf = msg->u.mapbufs.buf;
-	page_offset = msg->u.mapbufs.reqid;
-
-	spin_lock_irqsave(manager->lock, flags);
-	newtot = manager->npages + msg_pages;
-	old_block_count = 
-		(manager->npages + NETFRONT_ACCEL_BUF_PAGES_PER_BLOCK - 1) >>
-		NETFRONT_ACCEL_BUF_PAGES_PER_BLOCK_SHIFT;
-	new_block_count = 
-		(newtot + NETFRONT_ACCEL_BUF_PAGES_PER_BLOCK - 1) >>
-		NETFRONT_ACCEL_BUF_PAGES_PER_BLOCK_SHIFT;
-
-	for (i = old_block_count; i < new_block_count; i++) {
-		struct netfront_accel_pkt_desc *block;
-		if (manager->desc_blocks[i] != NULL) {
-			VPRINTK("Not needed\n");
-			continue;
-		}
-		block = kzalloc(NETFRONT_ACCEL_BUFS_PER_BLOCK * 
-				sizeof(netfront_accel_pkt_desc), GFP_ATOMIC);
-		if (block == NULL) {
-			spin_unlock_irqrestore(manager->lock, flags);
-			return -ENOMEM;
-		}
-		manager->desc_blocks[i] = block;
-	}
-	for (i = manager->npages; i < newtot; i++) {
-		int k, j = i - manager->npages;
-		int block_num;
-		int block_idx;
-		struct netfront_accel_pkt_desc *pkt;
-
-		block_num = i >> NETFRONT_ACCEL_BUF_PAGES_PER_BLOCK_SHIFT;
-		block_idx = (NETFRONT_ACCEL_BUFS_PER_PAGE*i)
-			& (NETFRONT_ACCEL_BUFS_PER_BLOCK-1);
-
-		pkt = manager->desc_blocks[block_num] + block_idx;
-		
-		for (k = 0; k < NETFRONT_ACCEL_BUFS_PER_PAGE; k++) {
-			BUG_ON(page_offset + j >= bufpages->max_pages);
-
-			pkt[k].buf_id = NETFRONT_ACCEL_BUFS_PER_PAGE * i + k;
-			pkt[k].pkt_kva = bufpages->page_list[page_offset + j] +
-				(PAGE_SIZE/NETFRONT_ACCEL_BUFS_PER_PAGE) * k;
-			pkt[k].pkt_buff_addr = msg_buf +
-				(PAGE_SIZE/NETFRONT_ACCEL_BUFS_PER_PAGE) * 
-				(NETFRONT_ACCEL_BUFS_PER_PAGE * j + k);
-			pkt[k].next_free = manager->first_free;
-			manager->first_free = pkt[k].buf_id;
-			*(int*)(pkt[k].pkt_kva) = pkt[k].buf_id;
-
-			VPRINTK("buf %d desc %p kva %p buffaddr %x\n",
-				pkt[k].buf_id, &(pkt[k]), pkt[k].pkt_kva, 
-				pkt[k].pkt_buff_addr);
-		}
-	}
-	manager->npages = newtot;
-	spin_unlock_irqrestore(manager->lock, flags);
-	VPRINTK("Added %d pages. Total is now %d\n", msg_pages,
-		manager->npages);
-	return 0;
-}
-
-
-netfront_accel_pkt_desc *
-netfront_accel_buf_find(struct netfront_accel_bufinfo *manager, u16 id)
-{
-	netfront_accel_pkt_desc *pkt;
-	int block_num = id >> NETFRONT_ACCEL_BUFS_PER_BLOCK_SHIFT;
-	int block_idx = id & (NETFRONT_ACCEL_BUFS_PER_BLOCK - 1);
-	BUG_ON(id >= manager->npages * NETFRONT_ACCEL_BUFS_PER_PAGE);
-	BUG_ON(block_idx >= NETFRONT_ACCEL_BUFS_PER_BLOCK);
-	pkt = manager->desc_blocks[block_num] + block_idx;
-	return pkt;
-}
-
-
-/* Allocate a buffer from the buffer manager */
-netfront_accel_pkt_desc *
-netfront_accel_buf_get(struct netfront_accel_bufinfo *manager)
-{
-	int bufno = -1;
-	netfront_accel_pkt_desc *buf = NULL;
-	unsigned long flags = 0;
-
-	/* Any spare? */
-	if (manager->first_free == -1)
-		return NULL;
-	/* Take lock */
-	if (manager->internally_locked)
-		spin_lock_irqsave(manager->lock, flags);
-	bufno = manager->first_free;
-	if (bufno != -1) {
-		buf = netfront_accel_buf_find(manager, bufno);
-		manager->first_free = buf->next_free;
-		manager->nused++;
-	}
-	/* Release lock */
-	if (manager->internally_locked)
-		spin_unlock_irqrestore(manager->lock, flags);
-
-	/* Tell the world */
-	VPRINTK("Allocated buffer %i, buffaddr %x\n", bufno,
-		buf->pkt_buff_addr);
-
-	return buf;
-}
-
-
-/* Release a buffer back to the buffer manager pool */
-int netfront_accel_buf_put(struct netfront_accel_bufinfo *manager, u16 id)
-{
-	netfront_accel_pkt_desc *buf = netfront_accel_buf_find(manager, id);
-	unsigned long flags = 0;
-	unsigned was_empty = 0;
-	int bufno = id;
-
-	VPRINTK("Freeing buffer %i\n", id);
-	BUG_ON(id == (u16)-1);
-
-	if (manager->internally_locked)
-		spin_lock_irqsave(manager->lock, flags);
-
-	if (manager->first_free == -1)
-		was_empty = 1;
-
-	buf->next_free = manager->first_free;
-	manager->first_free = bufno;
-	manager->nused--;
-
-	if (manager->internally_locked)
-		spin_unlock_irqrestore(manager->lock, flags);
-
-	return was_empty;
-}
diff -r 9566a4a50a43 drivers/xen/sfc_netfront/accel_bufs.h
--- a/drivers/xen/sfc_netfront/accel_bufs.h
+++ /dev/null
@@ -1,181 +0,0 @@
-/****************************************************************************
- * Solarflare driver for Xen network acceleration
- *
- * Copyright 2006-2008: Solarflare Communications Inc,
- *                      9501 Jeronimo Road, Suite 250,
- *                      Irvine, CA 92618, USA
- *
- * Maintained by Solarflare Communications <linux-xen-drivers@solarflare.com>
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 as published
- * by the Free Software Foundation, incorporated herein by reference.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
- ****************************************************************************
- */
-
-#ifndef NETFRONT_ACCEL_BUFS_H
-#define NETFRONT_ACCEL_BUFS_H
-
-#include <linux/skbuff.h>
-#include <linux/spinlock.h>
-#include <xen/xenbus.h>
-
-#include "accel_msg_iface.h"
-
-
-/*! Buffer descriptor structure */
-typedef struct netfront_accel_pkt_desc {
-	int buf_id;
-	u32 pkt_buff_addr;
-	void *pkt_kva;
-	/* This is the socket buffer currently married to this buffer */
-	struct sk_buff *skb;
-	int next_free;
-} netfront_accel_pkt_desc;
-
-
-#define NETFRONT_ACCEL_DEFAULT_BUF_PAGES (384)
-#define NETFRONT_ACCEL_BUF_PAGES_PER_BLOCK_SHIFT (4)
-#define NETFRONT_ACCEL_BUF_PAGES_PER_BLOCK		\
-	(1 << (NETFRONT_ACCEL_BUF_PAGES_PER_BLOCK_SHIFT))
-#define NETFRONT_ACCEL_BUFS_PER_PAGE_SHIFT (1)
-#define NETFRONT_ACCEL_BUFS_PER_PAGE			\
-	(1 << (NETFRONT_ACCEL_BUFS_PER_PAGE_SHIFT))
-#define NETFRONT_ACCEL_BUFS_PER_BLOCK_SHIFT		\
-	(NETFRONT_ACCEL_BUF_PAGES_PER_BLOCK_SHIFT +     \
-	 NETFRONT_ACCEL_BUFS_PER_PAGE_SHIFT)
-#define NETFRONT_ACCEL_BUFS_PER_BLOCK			\
-	(1 << NETFRONT_ACCEL_BUFS_PER_BLOCK_SHIFT)
-#define NETFRONT_ACCEL_BUF_NUM_BLOCKS(max_pages)			\
-	(((max_pages)+NETFRONT_ACCEL_BUF_PAGES_PER_BLOCK-1) /		\
-	 NETFRONT_ACCEL_BUF_PAGES_PER_BLOCK)
-
-/*! Buffer management structure. */
-struct netfront_accel_bufinfo {
-	/* number added to this manager */
-	unsigned npages;
-	/* number currently used from this manager */
-	unsigned nused;
-
-	int first_free;
-
-	int internally_locked;
-	spinlock_t *lock;
-
-	/*
-	 * array of pointers (length NETFRONT_ACCEL_BUF_NUM_BLOCKS) to
-	 * pkt descs
-	 */
-	struct netfront_accel_pkt_desc **desc_blocks; 
-};
-
-
-struct netfront_accel_bufpages {
-	/* length of lists of pages/grants */
-	int max_pages;
-	/* list of pages allocated for network buffers */
-	void **page_list;
-	/* list of grants for the above pages */
-	grant_ref_t *grant_list;
-	
-	/* number of page requests that have been made */
-	unsigned page_reqs;
-};
-
-
-/*! Allocate memory for the buffer manager, set up locks etc.
- * Optionally takes a lock to use, if not supplied it makes its own.
- *
- * \return pointer to netfront_accel_bufinfo structure that represents the
- * buffer manager
- */
-extern struct netfront_accel_bufinfo *
-netfront_accel_init_bufs(spinlock_t *lock);
-
-/*! Allocate memory for the buffers
- */
-extern int
-netfront_accel_alloc_buffer_mem(struct netfront_accel_bufpages *bufpages,
-				struct netfront_accel_bufinfo *rx_res,
-				struct netfront_accel_bufinfo *tx_res,
-				int pages);
-extern void
-netfront_accel_free_buffer_mem(struct netfront_accel_bufpages *bufpages,
-			       struct netfront_accel_bufinfo *rx_res,
-			       struct netfront_accel_bufinfo *tx_res);
-
-/*! Release memory for the buffer manager, buffers, etc.
- *
- * \param manager pointer to netfront_accel_bufinfo structure that
- * represents the buffer manager
- */
-extern void netfront_accel_fini_bufs(struct netfront_accel_bufinfo *manager);
-
-/*! Release a buffer.
- *
- * \param manager  The buffer manager which owns the buffer.
- * \param id   The buffer identifier.
- */
-extern int netfront_accel_buf_put(struct netfront_accel_bufinfo *manager, 
-				  u16 id);
-
-/*! Get the packet descriptor associated with a buffer id.
- *
- * \param manager  The buffer manager which owns the buffer.
- * \param id       The buffer identifier.
- *
- * The returned value is the packet descriptor for this buffer.
- */
-extern netfront_accel_pkt_desc *
-netfront_accel_buf_find(struct netfront_accel_bufinfo *manager, u16 id);
-
-
-/*! Fill out a message request for some buffers to be mapped by the
- * back end driver
- * 
- * \param manager The buffer manager 
- * \param msg Pointer to an ef_msg to complete.
- * \return 0 on success
- */
-extern int 
-netfront_accel_buf_map_request(struct xenbus_device *dev,
-			       struct netfront_accel_bufpages *bufpages,
-			       struct net_accel_msg *msg, 
-			       int pages, int offset);
-
-/*! Process a response to a buffer request. 
- * 
- * Deal with a received message from the back end in response to our
- * request for buffers
- * 
- * \param manager The buffer manager
- * \param msg The received message from the back end describing new
- * buffers
- * \return 0 on success
- */
-extern int 
-netfront_accel_add_bufs(struct netfront_accel_bufpages *bufpages,
-			struct netfront_accel_bufinfo *manager,
-			struct net_accel_msg *msg);
-
-
-/*! Allocate a buffer from the buffer manager 
- *
- * \param manager The buffer manager data structure
- * \param id On exit, the id of the buffer allocated
- * \return Pointer to buffer descriptor.
- */
-struct netfront_accel_pkt_desc *
-netfront_accel_buf_get(struct netfront_accel_bufinfo *manager);
-
-#endif /* NETFRONT_ACCEL_BUFS_H */
-
diff -r 9566a4a50a43 drivers/xen/sfc_netfront/accel_debugfs.c
--- a/drivers/xen/sfc_netfront/accel_debugfs.c
+++ /dev/null
@@ -1,227 +0,0 @@
-/****************************************************************************
- * Solarflare driver for Xen network acceleration
- *
- * Copyright 2006-2008: Solarflare Communications Inc,
- *                      9501 Jeronimo Road, Suite 250,
- *                      Irvine, CA 92618, USA
- *
- * Maintained by Solarflare Communications <linux-xen-drivers@solarflare.com>
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 as published
- * by the Free Software Foundation, incorporated herein by reference.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
- ****************************************************************************
- */
-
-#include <linux/fs.h>
-#include <linux/debugfs.h>
-
-#include "accel.h"
-
-#if defined(CONFIG_DEBUG_FS)
-static struct dentry *sfc_debugfs_root = NULL;
-#endif
-
-void netfront_accel_debugfs_init(void) 
-{
-#if defined(CONFIG_DEBUG_FS)
-	sfc_debugfs_root = debugfs_create_dir(frontend_name, NULL);
-#endif
-}
-
-
-void netfront_accel_debugfs_fini(void)
-{
-#if defined(CONFIG_DEBUG_FS)
-	if (sfc_debugfs_root)
-		debugfs_remove(sfc_debugfs_root);
-#endif
-}
-
-
-int netfront_accel_debugfs_create(netfront_accel_vnic *vnic)
-{
-#if defined(CONFIG_DEBUG_FS)
-	if (sfc_debugfs_root == NULL)
-		return -ENOENT;
-
-	vnic->dbfs_dir = debugfs_create_dir(vnic->net_dev->name, 
-					    sfc_debugfs_root);
-	if (vnic->dbfs_dir == NULL)
-		return -ENOMEM;
-
-	vnic->netdev_dbfs.fastpath_rx_pkts = debugfs_create_u32
-		("fastpath_rx_pkts", S_IRUSR | S_IRGRP | S_IROTH,
-		 vnic->dbfs_dir, &vnic->netdev_stats.fastpath_rx_pkts);
-	vnic->netdev_dbfs.fastpath_rx_bytes = debugfs_create_u32
-		("fastpath_rx_bytes", S_IRUSR | S_IRGRP | S_IROTH,
-		 vnic->dbfs_dir, &vnic->netdev_stats.fastpath_rx_bytes);
-	vnic->netdev_dbfs.fastpath_rx_errors = debugfs_create_u32
-		("fastpath_rx_errors", S_IRUSR | S_IRGRP | S_IROTH,
-		 vnic->dbfs_dir, &vnic->netdev_stats.fastpath_rx_errors);
-	vnic->netdev_dbfs.fastpath_tx_pkts = debugfs_create_u32
-		("fastpath_tx_pkts", S_IRUSR | S_IRGRP | S_IROTH,
-		 vnic->dbfs_dir, &vnic->netdev_stats.fastpath_tx_pkts);
-	vnic->netdev_dbfs.fastpath_tx_bytes = debugfs_create_u32
-		("fastpath_tx_bytes", S_IRUSR | S_IRGRP | S_IROTH,
-		 vnic->dbfs_dir, &vnic->netdev_stats.fastpath_tx_bytes);
-	vnic->netdev_dbfs.fastpath_tx_errors = debugfs_create_u32
-		("fastpath_tx_errors", S_IRUSR | S_IRGRP | S_IROTH,
-		 vnic->dbfs_dir, &vnic->netdev_stats.fastpath_tx_errors);
-
-#if NETFRONT_ACCEL_STATS
-	vnic->dbfs.irq_count = debugfs_create_u64
-		("irq_count", S_IRUSR | S_IRGRP | S_IROTH,
-		 vnic->dbfs_dir, &vnic->stats.irq_count);
-	vnic->dbfs.useless_irq_count = debugfs_create_u64
-		("useless_irq_count", S_IRUSR | S_IRGRP | S_IROTH,
-		 vnic->dbfs_dir, &vnic->stats.useless_irq_count);
-	vnic->dbfs.poll_schedule_count = debugfs_create_u64
-		("poll_schedule_count", S_IRUSR | S_IRGRP | S_IROTH,
-		 vnic->dbfs_dir, &vnic->stats.poll_schedule_count);
-	vnic->dbfs.poll_call_count = debugfs_create_u64
-		("poll_call_count", S_IRUSR | S_IRGRP | S_IROTH,
-		 vnic->dbfs_dir, &vnic->stats.poll_call_count);
-	vnic->dbfs.poll_reschedule_count = debugfs_create_u64
-		("poll_reschedule_count", S_IRUSR | S_IRGRP | S_IROTH,
-		 vnic->dbfs_dir, &vnic->stats.poll_reschedule_count);
-	vnic->dbfs.queue_stops = debugfs_create_u64
-		("queue_stops", S_IRUSR | S_IRGRP | S_IROTH,
-		 vnic->dbfs_dir, &vnic->stats.queue_stops);
-	vnic->dbfs.queue_wakes = debugfs_create_u64
-		("queue_wakes", S_IRUSR | S_IRGRP | S_IROTH,
-		 vnic->dbfs_dir, &vnic->stats.queue_wakes);
-	vnic->dbfs.ssr_bursts = debugfs_create_u64
-		("ssr_bursts", S_IRUSR | S_IRGRP | S_IROTH,
-		 vnic->dbfs_dir, &vnic->stats.ssr_bursts);
-	vnic->dbfs.ssr_drop_stream = debugfs_create_u64
-		("ssr_drop_stream", S_IRUSR | S_IRGRP | S_IROTH,
-		 vnic->dbfs_dir, &vnic->stats.ssr_drop_stream);
-	vnic->dbfs.ssr_misorder = debugfs_create_u64
-		("ssr_misorder", S_IRUSR | S_IRGRP | S_IROTH,
-		 vnic->dbfs_dir, &vnic->stats.ssr_misorder);
-	vnic->dbfs.ssr_slow_start = debugfs_create_u64
-		("ssr_slow_start", S_IRUSR | S_IRGRP | S_IROTH,
-		 vnic->dbfs_dir, &vnic->stats.ssr_slow_start);
-	vnic->dbfs.ssr_merges = debugfs_create_u64
-		("ssr_merges", S_IRUSR | S_IRGRP | S_IROTH,
-		 vnic->dbfs_dir, &vnic->stats.ssr_merges);
-	vnic->dbfs.ssr_too_many = debugfs_create_u64
-		("ssr_too_many", S_IRUSR | S_IRGRP | S_IROTH,
-		 vnic->dbfs_dir, &vnic->stats.ssr_too_many);
-	vnic->dbfs.ssr_new_stream = debugfs_create_u64
-		("ssr_new_stream", S_IRUSR | S_IRGRP | S_IROTH,
-		 vnic->dbfs_dir, &vnic->stats.ssr_new_stream);
-
-	vnic->dbfs.fastpath_tx_busy = debugfs_create_u64
-		("fastpath_tx_busy", S_IRUSR | S_IRGRP | S_IROTH,
-		 vnic->dbfs_dir, &vnic->stats.fastpath_tx_busy);
-	vnic->dbfs.fastpath_tx_completions = debugfs_create_u64
-		("fastpath_tx_completions", S_IRUSR | S_IRGRP | S_IROTH,
-		 vnic->dbfs_dir, &vnic->stats.fastpath_tx_completions);
-	vnic->dbfs.fastpath_tx_pending_max = debugfs_create_u32
-		("fastpath_tx_pending_max", S_IRUSR | S_IRGRP | S_IROTH,
-		 vnic->dbfs_dir, &vnic->stats.fastpath_tx_pending_max);
-	vnic->dbfs.event_count = debugfs_create_u64
-		("event_count", S_IRUSR | S_IRGRP | S_IROTH,
-		 vnic->dbfs_dir, &vnic->stats.event_count);
-	vnic->dbfs.bad_event_count = debugfs_create_u64
-		("bad_event_count", S_IRUSR | S_IRGRP | S_IROTH,
-		 vnic->dbfs_dir, &vnic->stats.bad_event_count);
-	vnic->dbfs.event_count_since_irq = debugfs_create_u32
-		("event_count_since_irq", S_IRUSR | S_IRGRP | S_IROTH,
-		 vnic->dbfs_dir, &vnic->stats.event_count_since_irq);
-	vnic->dbfs.events_per_irq_max = debugfs_create_u32
-		("events_per_irq_max", S_IRUSR | S_IRGRP | S_IROTH,
-		 vnic->dbfs_dir, &vnic->stats.events_per_irq_max);
-	vnic->dbfs.fastpath_frm_trunc = debugfs_create_u64
-		("fastpath_frm_trunc", S_IRUSR | S_IRGRP | S_IROTH,
-		 vnic->dbfs_dir, &vnic->stats.fastpath_frm_trunc);
-	vnic->dbfs.fastpath_crc_bad = debugfs_create_u64
-		("fastpath_crc_bad", S_IRUSR | S_IRGRP | S_IROTH,
-		 vnic->dbfs_dir, &vnic->stats.fastpath_crc_bad);
-	vnic->dbfs.fastpath_csum_bad = debugfs_create_u64
-		("fastpath_csum_bad", S_IRUSR | S_IRGRP | S_IROTH,
-		 vnic->dbfs_dir, &vnic->stats.fastpath_csum_bad);
-	vnic->dbfs.fastpath_rights_bad = debugfs_create_u64
-		("fastpath_rights_bad", S_IRUSR | S_IRGRP | S_IROTH,
-		 vnic->dbfs_dir, &vnic->stats.fastpath_rights_bad);
-	vnic->dbfs.fastpath_discard_other = debugfs_create_u64
-		("fastpath_discard_other", S_IRUSR | S_IRGRP | S_IROTH,
-		 vnic->dbfs_dir, &vnic->stats.fastpath_discard_other);
-	vnic->dbfs.rx_no_desc_trunc = debugfs_create_u64
-		("rx_no_desc_trunc", S_IRUSR | S_IRGRP | S_IROTH,
-		 vnic->dbfs_dir, &vnic->stats.rx_no_desc_trunc);
-	vnic->dbfs.events_per_poll_max = debugfs_create_u32
-		("events_per_poll_max", S_IRUSR | S_IRGRP | S_IROTH,
-		 vnic->dbfs_dir, &vnic->stats.events_per_poll_max);
-	vnic->dbfs.events_per_poll_rx_max = debugfs_create_u32
-		("events_per_poll_rx_max", S_IRUSR | S_IRGRP | S_IROTH,
-		 vnic->dbfs_dir, &vnic->stats.events_per_poll_rx_max);
-	vnic->dbfs.events_per_poll_tx_max = debugfs_create_u32
-		("events_per_poll_tx_max", S_IRUSR | S_IRGRP | S_IROTH,
-		 vnic->dbfs_dir, &vnic->stats.events_per_poll_tx_max);
-#endif
-#endif
-	return 0;
-}
-
-
-int netfront_accel_debugfs_remove(netfront_accel_vnic *vnic)
-{
-#if defined(CONFIG_DEBUG_FS)
-	if (vnic->dbfs_dir != NULL) {
-		debugfs_remove(vnic->netdev_dbfs.fastpath_rx_pkts);
-		debugfs_remove(vnic->netdev_dbfs.fastpath_rx_bytes);
-		debugfs_remove(vnic->netdev_dbfs.fastpath_rx_errors);
-		debugfs_remove(vnic->netdev_dbfs.fastpath_tx_pkts);
-		debugfs_remove(vnic->netdev_dbfs.fastpath_tx_bytes);
-		debugfs_remove(vnic->netdev_dbfs.fastpath_tx_errors);
-		
-#if NETFRONT_ACCEL_STATS
-		debugfs_remove(vnic->dbfs.irq_count);
-		debugfs_remove(vnic->dbfs.useless_irq_count);
-		debugfs_remove(vnic->dbfs.poll_schedule_count);
-		debugfs_remove(vnic->dbfs.poll_call_count);
-		debugfs_remove(vnic->dbfs.poll_reschedule_count);
-		debugfs_remove(vnic->dbfs.queue_stops);
-		debugfs_remove(vnic->dbfs.queue_wakes);
-		debugfs_remove(vnic->dbfs.ssr_bursts);
-		debugfs_remove(vnic->dbfs.ssr_drop_stream);
-		debugfs_remove(vnic->dbfs.ssr_misorder);
-		debugfs_remove(vnic->dbfs.ssr_slow_start);
-		debugfs_remove(vnic->dbfs.ssr_merges);
-		debugfs_remove(vnic->dbfs.ssr_too_many);
-		debugfs_remove(vnic->dbfs.ssr_new_stream);
-		
-		debugfs_remove(vnic->dbfs.fastpath_tx_busy);
-		debugfs_remove(vnic->dbfs.fastpath_tx_completions);
-		debugfs_remove(vnic->dbfs.fastpath_tx_pending_max);
-		debugfs_remove(vnic->dbfs.event_count);
-		debugfs_remove(vnic->dbfs.bad_event_count);
-		debugfs_remove(vnic->dbfs.event_count_since_irq);
-		debugfs_remove(vnic->dbfs.events_per_irq_max);
-		debugfs_remove(vnic->dbfs.fastpath_frm_trunc);
-		debugfs_remove(vnic->dbfs.fastpath_crc_bad);
-		debugfs_remove(vnic->dbfs.fastpath_csum_bad);
-		debugfs_remove(vnic->dbfs.fastpath_rights_bad);
-		debugfs_remove(vnic->dbfs.fastpath_discard_other);
-		debugfs_remove(vnic->dbfs.rx_no_desc_trunc);
-		debugfs_remove(vnic->dbfs.events_per_poll_max);
-		debugfs_remove(vnic->dbfs.events_per_poll_rx_max);
-		debugfs_remove(vnic->dbfs.events_per_poll_tx_max);
-#endif
-		debugfs_remove(vnic->dbfs_dir);
-	}
-#endif
-	return 0;
-}
diff -r 9566a4a50a43 drivers/xen/sfc_netfront/accel_msg.c
--- a/drivers/xen/sfc_netfront/accel_msg.c
+++ /dev/null
@@ -1,567 +0,0 @@
-/****************************************************************************
- * Solarflare driver for Xen network acceleration
- *
- * Copyright 2006-2008: Solarflare Communications Inc,
- *                      9501 Jeronimo Road, Suite 250,
- *                      Irvine, CA 92618, USA
- *
- * Maintained by Solarflare Communications <linux-xen-drivers@solarflare.com>
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 as published
- * by the Free Software Foundation, incorporated herein by reference.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
- ****************************************************************************
- */
-
-#include <linux/stddef.h>
-#include <linux/errno.h>
-
-#include <xen/xenbus.h>
-
-#include "accel.h"
-#include "accel_msg_iface.h"
-#include "accel_util.h"
-#include "accel_bufs.h"
-
-#include "netfront.h" /* drivers/xen/netfront/netfront.h */
-
-static void vnic_start_interrupts(netfront_accel_vnic *vnic)
-{
-	unsigned long flags;
-	
-	/* Prime our interrupt */
-	spin_lock_irqsave(&vnic->irq_enabled_lock, flags);
-	if (!netfront_accel_vi_enable_interrupts(vnic)) {
-		struct netfront_info *np = netdev_priv(vnic->net_dev);
-
-		/* Cripes, that was quick, better pass it up */
-		netfront_accel_disable_net_interrupts(vnic);
-		vnic->irq_enabled = 0;
-		NETFRONT_ACCEL_STATS_OP(vnic->stats.poll_schedule_count++);
-		napi_schedule(&np->napi);
-	} else {
-		/*
-		 * Nothing yet, make sure we get interrupts through
-		 * back end 
-		 */
-		vnic->irq_enabled = 1;
-		netfront_accel_enable_net_interrupts(vnic);
-	}
-	spin_unlock_irqrestore(&vnic->irq_enabled_lock, flags);
-}
-
-
-static void vnic_stop_interrupts(netfront_accel_vnic *vnic)
-{
-	unsigned long flags;
-
-	spin_lock_irqsave(&vnic->irq_enabled_lock, flags);
-	netfront_accel_disable_net_interrupts(vnic);
-	vnic->irq_enabled = 0;
-	spin_unlock_irqrestore(&vnic->irq_enabled_lock, flags);
-}
-
-
-static void vnic_start_fastpath(netfront_accel_vnic *vnic)
-{
-	struct net_device *net_dev = vnic->net_dev;
-	struct netfront_info *np = netdev_priv(net_dev);
-	unsigned long flags;
-
-	DPRINTK("%s\n", __FUNCTION__);
-
-	spin_lock_irqsave(&vnic->tx_lock, flags);
-	vnic->tx_enabled = 1;
-	spin_unlock_irqrestore(&vnic->tx_lock, flags);
-	
-	napi_disable(&np->napi);
-	vnic->poll_enabled = 1;
-	napi_enable(&np->napi);
-	
-	vnic_start_interrupts(vnic);
-}
-
-
-void vnic_stop_fastpath(netfront_accel_vnic *vnic)
-{
-	struct net_device *net_dev = vnic->net_dev;
-	struct netfront_info *np = (struct netfront_info *)netdev_priv(net_dev);
-	unsigned long flags1, flags2;
-
-	DPRINTK("%s\n", __FUNCTION__);
-
-	vnic_stop_interrupts(vnic);
-	
-	spin_lock_irqsave(&vnic->tx_lock, flags1);
-	vnic->tx_enabled = 0;
-	spin_lock_irqsave(&np->tx_lock, flags2);
-	if (vnic->tx_skb != NULL) {
-		dev_kfree_skb_any(vnic->tx_skb);
-		vnic->tx_skb = NULL;
-		if (netfront_check_queue_ready(net_dev)) {
-			netif_wake_queue(net_dev);
-			NETFRONT_ACCEL_STATS_OP
-				(vnic->stats.queue_wakes++);
-		}
-	}
-	spin_unlock_irqrestore(&np->tx_lock, flags2);
-	spin_unlock_irqrestore(&vnic->tx_lock, flags1);
-	
-	/* Must prevent polls and hold lock to modify poll_enabled */
-	napi_disable(&np->napi);
-	spin_lock_irqsave(&vnic->irq_enabled_lock, flags1);
-	vnic->poll_enabled = 0;
-	spin_unlock_irqrestore(&vnic->irq_enabled_lock, flags1);
-	napi_enable(&np->napi);
-}
-
-
-static void netfront_accel_interface_up(netfront_accel_vnic *vnic)
-{
-	if (!vnic->backend_netdev_up) {
-		vnic->backend_netdev_up = 1;
-		
-		if (vnic->frontend_ready)
-			vnic_start_fastpath(vnic);
-	}
-}
-
-
-static void netfront_accel_interface_down(netfront_accel_vnic *vnic)
-{
-	if (vnic->backend_netdev_up) {
-		vnic->backend_netdev_up = 0;
-		
-		if (vnic->frontend_ready)
-			vnic_stop_fastpath(vnic);
-	}
-}
-
-
-static int vnic_add_bufs(netfront_accel_vnic *vnic, 
-			 struct net_accel_msg *msg)
-{
-	int rc, offset;
-	struct netfront_accel_bufinfo *bufinfo;
-  
-	BUG_ON(msg->u.mapbufs.pages > NET_ACCEL_MSG_MAX_PAGE_REQ);
-
-	offset = msg->u.mapbufs.reqid;
-
-	if (offset < vnic->bufpages.max_pages - 
-	    (vnic->bufpages.max_pages / sfc_netfront_buffer_split)) {
-		bufinfo = vnic->rx_bufs;
-	} else
-		bufinfo = vnic->tx_bufs;
-
-	/* Queue up some Rx buffers to start things off. */
-	if ((rc = netfront_accel_add_bufs(&vnic->bufpages, bufinfo, msg)) == 0) {
-		netfront_accel_vi_add_bufs(vnic, bufinfo == vnic->rx_bufs);
-
-		if (offset + msg->u.mapbufs.pages == vnic->bufpages.max_pages) {
-			VPRINTK("%s: got all buffers back\n", __FUNCTION__);
-			vnic->frontend_ready = 1;
-			if (vnic->backend_netdev_up)
-				vnic_start_fastpath(vnic);
-		} else {
-			VPRINTK("%s: got buffers back %d %d\n", __FUNCTION__, 
-				offset, msg->u.mapbufs.pages);
-		}
-	}
-
-	return rc;
-}
-
-
-/* The largest [o] such that (1u << o) <= n.  Requires n > 0. */
-
-inline unsigned log2_le(unsigned long n) {
-	unsigned order = 1;
-	while ((1ul << order) <= n) ++order;
-	return (order - 1);
-}
-
-static int vnic_send_buffer_requests(netfront_accel_vnic *vnic,
-				     struct netfront_accel_bufpages *bufpages)
-{
-	int pages, offset, rc = 0, sent = 0;
-	struct net_accel_msg msg;
-
-	while (bufpages->page_reqs < bufpages->max_pages) {
-		offset = bufpages->page_reqs;
-
-		pages = pow2(log2_le(bufpages->max_pages - 
-				     bufpages->page_reqs));
-		pages = pages < NET_ACCEL_MSG_MAX_PAGE_REQ ? 
-			pages : NET_ACCEL_MSG_MAX_PAGE_REQ;
-
-		BUG_ON(offset < 0);
-		BUG_ON(pages <= 0);
-
-		rc = netfront_accel_buf_map_request(vnic->dev, bufpages,
-						    &msg, pages, offset);
-		if (rc == 0) {
-			rc = net_accel_msg_send(vnic->shared_page, 
-						&vnic->to_dom0, &msg);
-			if (rc < 0) {
-				VPRINTK("%s: queue full, stopping for now\n",
-					__FUNCTION__);
-				break;
-			}
-			sent++;
-		} else {
-			EPRINTK("%s: problem with grant, stopping for now\n",
-				__FUNCTION__);
-			break;
-		}
-
-		bufpages->page_reqs += pages;
-	}
-
-	if (sent)
-		net_accel_msg_notify(vnic->msg_channel_irq);
-
-	return rc;
-}
-
-
-/*
- * In response to dom0 saying "my queue is full", we reply with this
- * when it is no longer full
- */
-inline void vnic_set_queue_not_full(netfront_accel_vnic *vnic)
-{
-
-	if (test_and_set_bit(NET_ACCEL_MSG_AFLAGS_QUEUE0NOTFULL_B,
-			    (unsigned long *)&vnic->shared_page->aflags))
-		notify_remote_via_irq(vnic->msg_channel_irq);
-	else
-		VPRINTK("queue not full bit already set, not signalling\n");
-}
-
-/* 
- * Notify dom0 that the queue we want to use is full, it should
- * respond by setting MSG_AFLAGS_QUEUEUNOTFULL in due course
- */
-inline void vnic_set_queue_full(netfront_accel_vnic *vnic)
-{
-
-	if (!test_and_set_bit(NET_ACCEL_MSG_AFLAGS_QUEUEUFULL_B,
-			     (unsigned long *)&vnic->shared_page->aflags))
-		notify_remote_via_irq(vnic->msg_channel_irq);
-	else
-		VPRINTK("queue full bit already set, not signalling\n");
-}
-
-
-static int vnic_check_hello_version(unsigned version) 
-{
-	if (version > NET_ACCEL_MSG_VERSION) {
-		/* Newer protocol, we must refuse */
-		return -EPROTO;
-	}
-
-	if (version < NET_ACCEL_MSG_VERSION) {
-		/*
-		 * We are newer, so have discretion to accept if we
-		 * wish.  For now however, just reject
-		 */
-		return -EPROTO;
-	}
-
-	BUG_ON(version != NET_ACCEL_MSG_VERSION);
-	return 0;
-}
-
-
-static int vnic_process_hello_msg(netfront_accel_vnic *vnic,
-				  struct net_accel_msg *msg)
-{
-	int err = 0;
-	unsigned pages = sfc_netfront_max_pages;
-
-	if (vnic_check_hello_version(msg->u.hello.version) < 0) {
-		msg->id = NET_ACCEL_MSG_HELLO | NET_ACCEL_MSG_REPLY 
-			| NET_ACCEL_MSG_ERROR;
-		msg->u.hello.version = NET_ACCEL_MSG_VERSION;
-	} else {
-		vnic->backend_netdev_up
-			= vnic->shared_page->net_dev_up;
-		
-		msg->id = NET_ACCEL_MSG_HELLO | NET_ACCEL_MSG_REPLY;
-		msg->u.hello.version = NET_ACCEL_MSG_VERSION;
-		if (msg->u.hello.max_pages &&
-		    msg->u.hello.max_pages < pages)
-			pages = msg->u.hello.max_pages;
-		msg->u.hello.max_pages = pages;
-		
-		/* Half of pages for rx, half for tx */ 
-		err = netfront_accel_alloc_buffer_mem(&vnic->bufpages,
-						      vnic->rx_bufs, 
-						      vnic->tx_bufs,
-						      pages);
-		if (err)
-			msg->id |= NET_ACCEL_MSG_ERROR;		
-	}
-	
-	/* Send reply */
-	net_accel_msg_reply_notify(vnic->shared_page, vnic->msg_channel_irq,
-				   &vnic->to_dom0, msg);
-	return err;
-}
-
-
-static int vnic_process_localmac_msg(netfront_accel_vnic *vnic,
-				     struct net_accel_msg *msg)
-{
-	unsigned long flags;
-	cuckoo_hash_mac_key key;
-
-	if (msg->u.localmac.flags & NET_ACCEL_MSG_ADD) {
-		DPRINTK("MAC has moved, could be local: %pM\n",
-			msg->u.localmac.mac);
-		key = cuckoo_mac_to_key(msg->u.localmac.mac);
-		spin_lock_irqsave(&vnic->table_lock, flags);
-		/* Try to remove it, not a big deal if not there */
-		cuckoo_hash_remove(&vnic->fastpath_table, 
-				   (cuckoo_hash_key *)&key);
-		spin_unlock_irqrestore(&vnic->table_lock, flags);
-	}
-	
-	return 0;
-}
-
-
-static 
-int vnic_process_rx_msg(netfront_accel_vnic *vnic,
-			struct net_accel_msg *msg)
-{
-	int err;
-
-	switch (msg->id) {
-	case NET_ACCEL_MSG_HELLO:
-		/* Hello, reply with Reply */
-		DPRINTK("got Hello, with version %.8x\n",
-			msg->u.hello.version);
-		BUG_ON(vnic->msg_state != NETFRONT_ACCEL_MSG_NONE);
-		err = vnic_process_hello_msg(vnic, msg);
-		if (err == 0)
-			vnic->msg_state = NETFRONT_ACCEL_MSG_HELLO;
-		break;
-	case NET_ACCEL_MSG_SETHW:
-		/* Hardware info message */
-		DPRINTK("got H/W info\n");
-		BUG_ON(vnic->msg_state != NETFRONT_ACCEL_MSG_HELLO);
-		err = netfront_accel_vi_init(vnic, &msg->u.hw);
-		if (err == 0)
-			vnic->msg_state = NETFRONT_ACCEL_MSG_HW;
-		break;
-	case NET_ACCEL_MSG_MAPBUF | NET_ACCEL_MSG_REPLY:
-		VPRINTK("Got mapped buffers back\n");
-		BUG_ON(vnic->msg_state != NETFRONT_ACCEL_MSG_HW);
-		err = vnic_add_bufs(vnic, msg);
-		break;
-	case NET_ACCEL_MSG_MAPBUF | NET_ACCEL_MSG_REPLY | NET_ACCEL_MSG_ERROR:
-		/* No buffers.  Can't use the fast path. */
-		EPRINTK("Got mapped buffers error.  Cannot accelerate.\n");
-		BUG_ON(vnic->msg_state != NETFRONT_ACCEL_MSG_HW);
-		err = -EIO;
-		break;
-	case NET_ACCEL_MSG_LOCALMAC:
-		/* Should be add, remove not currently used */
-		EPRINTK_ON(!(msg->u.localmac.flags & NET_ACCEL_MSG_ADD));
-		BUG_ON(vnic->msg_state != NETFRONT_ACCEL_MSG_HW);
-		err = vnic_process_localmac_msg(vnic, msg);
-		break;
-	default:
-		EPRINTK("Huh? Message code is 0x%x\n", msg->id);
-		err = -EPROTO;
-		break;
-	}
-
-	return err;
-}
-
-
-/* Process an IRQ received from back end driver */
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,20)
-void netfront_accel_msg_from_bend(struct work_struct *context)
-#else
-void netfront_accel_msg_from_bend(void *context)
-#endif
-{
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,20)
-	netfront_accel_vnic *vnic = 
-		container_of(context, netfront_accel_vnic, msg_from_bend);
-#else
-	netfront_accel_vnic *vnic = (netfront_accel_vnic *)context;
-#endif
-	struct net_accel_msg msg;
-	int err, queue_was_full = 0;
-	
-	mutex_lock(&vnic->vnic_mutex);
-
-	/*
-	 * This happens when the shared pages have been unmapped but
-	 * the workqueue has yet to be flushed 
-	 */
-	if (!vnic->dom0_state_is_setup) 
-		goto unlock_out;
-
-	while ((vnic->shared_page->aflags & NET_ACCEL_MSG_AFLAGS_TO_DOMU_MASK)
-	       != 0) {
-		if (vnic->shared_page->aflags &
-		    NET_ACCEL_MSG_AFLAGS_QUEUEUNOTFULL) {
-			/* We've been told there may now be space. */
-			clear_bit(NET_ACCEL_MSG_AFLAGS_QUEUEUNOTFULL_B,
-				  (unsigned long *)&vnic->shared_page->aflags);
-		}
-
-		if (vnic->shared_page->aflags &
-		    NET_ACCEL_MSG_AFLAGS_QUEUE0FULL) {
-			/*
-			 * There will be space at the end of this
-			 * function if we can make any.
-			 */
-			clear_bit(NET_ACCEL_MSG_AFLAGS_QUEUE0FULL_B,
-				  (unsigned long *)&vnic->shared_page->aflags);
-			queue_was_full = 1;
-		}
-
-		if (vnic->shared_page->aflags &
-		    NET_ACCEL_MSG_AFLAGS_NETUPDOWN) {
-			DPRINTK("%s: net interface change\n", __FUNCTION__);
-			clear_bit(NET_ACCEL_MSG_AFLAGS_NETUPDOWN_B,
-				  (unsigned long *)&vnic->shared_page->aflags);
-			if (vnic->shared_page->net_dev_up)
-				netfront_accel_interface_up(vnic);
-			else
-				netfront_accel_interface_down(vnic);
-		}
-	}
-
-	/* Pull msg out of shared memory */
-	while ((err = net_accel_msg_recv(vnic->shared_page, &vnic->from_dom0,
-					 &msg)) == 0) {
-		err = vnic_process_rx_msg(vnic, &msg);
-		
-		if (err != 0)
-			goto done;
-	}
-
-	/*
-	 * Send any pending buffer map request messages that we can,
-	 * and mark domU->dom0 as full if necessary.  
-	 */
-	if (vnic->msg_state == NETFRONT_ACCEL_MSG_HW &&
-	    vnic->bufpages.page_reqs < vnic->bufpages.max_pages) {
-		if (vnic_send_buffer_requests(vnic, &vnic->bufpages) == -ENOSPC)
-			vnic_set_queue_full(vnic);
-	}
-
-	/* 
-	 * If there are no messages then this is not an error.  It
-	 * just means that we've finished processing the queue.
-	 */
-	if (err == -ENOENT)
-		err = 0;
- done:
-	/* We will now have made space in the dom0->domU queue if we can */
-	if (queue_was_full)
-		vnic_set_queue_not_full(vnic);
-
-	if (err != 0) {
-		EPRINTK("%s returned %d\n", __FUNCTION__, err);
-		netfront_accel_set_closing(vnic);
-	}
-
- unlock_out:
-	mutex_unlock(&vnic->vnic_mutex);
-
-	return;
-}
-
-
-irqreturn_t netfront_accel_msg_channel_irq_from_bend(int irq, void *context)
-{
-	netfront_accel_vnic *vnic = (netfront_accel_vnic *)context;
-	VPRINTK("irq %d from device %s\n", irq, vnic->dev->nodename);
-
-	queue_work(netfront_accel_workqueue, &vnic->msg_from_bend);
-
-	return IRQ_HANDLED;
-}
-
-/* Process an interrupt received from the NIC via backend */
-irqreturn_t netfront_accel_net_channel_irq_from_bend(int irq, void *context)
-{
-	netfront_accel_vnic *vnic = (netfront_accel_vnic *)context;
-	struct net_device *net_dev = vnic->net_dev;
-	unsigned long flags;
-
-	VPRINTK("net irq %d from device %s\n", irq, vnic->dev->nodename);
-	
-	NETFRONT_ACCEL_STATS_OP(vnic->stats.irq_count++);
-
-	BUG_ON(net_dev==NULL);
-
-	spin_lock_irqsave(&vnic->irq_enabled_lock, flags);
-	if (vnic->irq_enabled) {
-		struct netfront_info *np = netdev_priv(net_dev);
-
-		netfront_accel_disable_net_interrupts(vnic);
-		vnic->irq_enabled = 0;
-		spin_unlock_irqrestore(&vnic->irq_enabled_lock, flags);
-
-#if NETFRONT_ACCEL_STATS
-		vnic->stats.poll_schedule_count++;
-		if (vnic->stats.event_count_since_irq >
-		    vnic->stats.events_per_irq_max)
-			vnic->stats.events_per_irq_max = 
-				vnic->stats.event_count_since_irq;
-		vnic->stats.event_count_since_irq = 0;
-#endif
-		napi_schedule(&np->napi);
-	}
-	else {
-		spin_unlock_irqrestore(&vnic->irq_enabled_lock, flags);
-		NETFRONT_ACCEL_STATS_OP(vnic->stats.useless_irq_count++);
-		DPRINTK("%s: irq when disabled\n", __FUNCTION__);
-	}
-	
-	return IRQ_HANDLED;
-}
-
-
-void netfront_accel_msg_tx_fastpath(netfront_accel_vnic *vnic, const void *mac,
-				    u32 ip, u16 port, u8 protocol)
-{
-	unsigned long lock_state;
-	struct net_accel_msg *msg;
-
-	msg = net_accel_msg_start_send(vnic->shared_page, &vnic->to_dom0,
-				       &lock_state);
-
-	if (msg == NULL)
-		return;
-
-	net_accel_msg_init(msg, NET_ACCEL_MSG_FASTPATH);
-	msg->u.fastpath.flags = NET_ACCEL_MSG_REMOVE;
-	memcpy(msg->u.fastpath.mac, mac, ETH_ALEN);
-
-	msg->u.fastpath.port = port;
-	msg->u.fastpath.ip = ip;
-	msg->u.fastpath.proto = protocol;
-
-	net_accel_msg_complete_send_notify(vnic->shared_page, &vnic->to_dom0, 
-					   &lock_state, vnic->msg_channel_irq);
-}
diff -r 9566a4a50a43 drivers/xen/sfc_netfront/accel_netfront.c
--- a/drivers/xen/sfc_netfront/accel_netfront.c
+++ /dev/null
@@ -1,328 +0,0 @@
-/****************************************************************************
- * Solarflare driver for Xen network acceleration
- *
- * Copyright 2006-2008: Solarflare Communications Inc,
- *                      9501 Jeronimo Road, Suite 250,
- *                      Irvine, CA 92618, USA
- *
- * Maintained by Solarflare Communications <linux-xen-drivers@solarflare.com>
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 as published
- * by the Free Software Foundation, incorporated herein by reference.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
- ****************************************************************************
- */
-
-#include <linux/skbuff.h>
-#include <linux/netdevice.h>
-
-/* drivers/xen/netfront/netfront.h */
-#include "netfront.h"
-
-#include "accel.h"
-#include "accel_bufs.h"
-#include "accel_util.h"
-#include "accel_msg_iface.h"
-#include "accel_ssr.h"
- 
-#ifdef EFX_GCOV
-#include "gcov.h"
-#endif
-
-#define NETFRONT_ACCEL_VNIC_FROM_NETDEV(_nd)				\
-	((netfront_accel_vnic *)((struct netfront_info *)netdev_priv(net_dev))->accel_priv)
-
-static int netfront_accel_netdev_start_xmit(struct sk_buff *skb,
-					    struct net_device *net_dev)
-{
-	netfront_accel_vnic *vnic = NETFRONT_ACCEL_VNIC_FROM_NETDEV(net_dev);
-	struct netfront_info *np = 
-		(struct netfront_info *)netdev_priv(net_dev);
-	int handled, rc;
-	unsigned long flags1, flags2;
-
-	BUG_ON(vnic == NULL);
-
-	/* Take our tx lock and hold for the duration */
-	spin_lock_irqsave(&vnic->tx_lock, flags1);
-
-	if (!vnic->tx_enabled) {
-		rc = 0;
-		goto unlock_out;
-	}
-
-	handled = netfront_accel_vi_tx_post(vnic, skb);
-	if (handled == NETFRONT_ACCEL_STATUS_BUSY) {
-		BUG_ON(vnic->net_dev != net_dev);
-		DPRINTK("%s stopping queue\n", __FUNCTION__);
-
-		/* Need netfront's tx_lock and vnic tx_lock to write tx_skb */
-		spin_lock_irqsave(&np->tx_lock, flags2);
-		BUG_ON(vnic->tx_skb != NULL);
-		vnic->tx_skb = skb;
-		netif_stop_queue(net_dev);
-		spin_unlock_irqrestore(&np->tx_lock, flags2);
-
-		NETFRONT_ACCEL_STATS_OP(vnic->stats.queue_stops++);
-	}
-
-	if (handled == NETFRONT_ACCEL_STATUS_CANT)
-		rc = 0;
-	else
-		rc = 1;
-
-unlock_out:
-	spin_unlock_irqrestore(&vnic->tx_lock, flags1);
-
-	return rc;
-}
-
-
-static int netfront_accel_netdev_poll(struct net_device *net_dev, int *budget)
-{
-	netfront_accel_vnic *vnic = NETFRONT_ACCEL_VNIC_FROM_NETDEV(net_dev);
-	int rx_allowed = *budget, rx_done;
-	
-	BUG_ON(vnic == NULL);
-
-	/* Can check this without lock as modifier excludes polls */ 
-	if (!vnic->poll_enabled)
-		return 0;
-
-	rx_done = netfront_accel_vi_poll(vnic, rx_allowed);
-	*budget -= rx_done;
-	
-	NETFRONT_ACCEL_STATS_OP(vnic->stats.poll_call_count++);
-
-	VPRINTK("%s: done %d allowed %d\n",
-		__FUNCTION__, rx_done, rx_allowed);
-
-	netfront_accel_ssr_end_of_burst(vnic, &vnic->ssr_state);
-
-	if (rx_done < rx_allowed) {
-		 return 0; /* Done */
-	}
-	
-	NETFRONT_ACCEL_STATS_OP(vnic->stats.poll_reschedule_count++);
-
-	return 1; /* More to do. */
-}
-
-
-/*
- * Process request from netfront to start napi interrupt
- * mode. (i.e. enable interrupts as it's finished polling)
- */
-static int netfront_accel_start_napi_interrupts(struct net_device *net_dev) 
-{
-	netfront_accel_vnic *vnic = NETFRONT_ACCEL_VNIC_FROM_NETDEV(net_dev);
-	unsigned long flags;
-
-	BUG_ON(vnic == NULL);
-	
-	/*
-	 * Can check this without lock as writer excludes poll before
-	 * modifying
-	 */
-	if (!vnic->poll_enabled)
-		return 0;
-
-	if (!netfront_accel_vi_enable_interrupts(vnic)) {
-		/* 
-		 * There was something there, tell caller we had
-		 * something to do.
-		 */
-		return 1;
-	}
-
-	spin_lock_irqsave(&vnic->irq_enabled_lock, flags);
-	vnic->irq_enabled = 1;
-	netfront_accel_enable_net_interrupts(vnic);
-	spin_unlock_irqrestore(&vnic->irq_enabled_lock, flags);
-
-	return 0;
-}
-
-
-/*
- * Process request from netfront to stop napi interrupt
- * mode. (i.e. disable interrupts as it's starting to poll 
- */
-static void netfront_accel_stop_napi_interrupts(struct net_device *net_dev) 
-{
-	netfront_accel_vnic *vnic = NETFRONT_ACCEL_VNIC_FROM_NETDEV(net_dev);
-	unsigned long flags;
-
-	BUG_ON(vnic == NULL);
-
-	spin_lock_irqsave(&vnic->irq_enabled_lock, flags);
-
-	if (!vnic->poll_enabled) {
-		spin_unlock_irqrestore(&vnic->irq_enabled_lock, flags);
-		return;
-	}
-
-	netfront_accel_disable_net_interrupts(vnic);
-	vnic->irq_enabled = 0;
-	spin_unlock_irqrestore(&vnic->irq_enabled_lock, flags);
-}
-
-
-static int netfront_accel_check_ready(struct net_device *net_dev)
-{
-	netfront_accel_vnic *vnic = NETFRONT_ACCEL_VNIC_FROM_NETDEV(net_dev);
-
-	BUG_ON(vnic == NULL);
-
-	/* Read of tx_skb is protected by netfront's tx_lock */ 
-	return vnic->tx_skb == NULL;
-}
-
-
-static int netfront_accel_get_stats(struct net_device *net_dev,
-				    struct net_device_stats *stats)
-{
-	netfront_accel_vnic *vnic = NETFRONT_ACCEL_VNIC_FROM_NETDEV(net_dev);
-	struct netfront_accel_netdev_stats now;
-
-	BUG_ON(vnic == NULL);
-
-	now.fastpath_rx_pkts   = vnic->netdev_stats.fastpath_rx_pkts;
-	now.fastpath_rx_bytes  = vnic->netdev_stats.fastpath_rx_bytes;
-	now.fastpath_rx_errors = vnic->netdev_stats.fastpath_rx_errors;
-	now.fastpath_tx_pkts   = vnic->netdev_stats.fastpath_tx_pkts;
-	now.fastpath_tx_bytes  = vnic->netdev_stats.fastpath_tx_bytes;
-	now.fastpath_tx_errors = vnic->netdev_stats.fastpath_tx_errors;
-	
-	stats->rx_packets += (now.fastpath_rx_pkts - 
-			      vnic->stats_last_read.fastpath_rx_pkts);
-	stats->rx_bytes   += (now.fastpath_rx_bytes -
-			      vnic->stats_last_read.fastpath_rx_bytes);
-	stats->rx_errors  += (now.fastpath_rx_errors - 
-			      vnic->stats_last_read.fastpath_rx_errors);
-	stats->tx_packets += (now.fastpath_tx_pkts - 
-			      vnic->stats_last_read.fastpath_tx_pkts);
-	stats->tx_bytes   += (now.fastpath_tx_bytes - 
-			      vnic->stats_last_read.fastpath_tx_bytes);
-	stats->tx_errors  += (now.fastpath_tx_errors - 
-			      vnic->stats_last_read.fastpath_tx_errors);
-	
-	vnic->stats_last_read = now;
-
-	return 0;
-}
-
-
-struct netfront_accel_hooks accel_hooks = {
-	.new_device	    = &netfront_accel_probe,
-	.remove		= &netfront_accel_remove,
-	.netdev_poll	   = &netfront_accel_netdev_poll,
-	.start_xmit	    = &netfront_accel_netdev_start_xmit,
-	.start_napi_irq	= &netfront_accel_start_napi_interrupts,
-	.stop_napi_irq	 = &netfront_accel_stop_napi_interrupts,
-	.check_ready	   = &netfront_accel_check_ready,
-	.get_stats	     = &netfront_accel_get_stats
-};
-
-
-unsigned sfc_netfront_max_pages = NETFRONT_ACCEL_DEFAULT_BUF_PAGES;
-module_param_named (max_pages, sfc_netfront_max_pages, uint, 0644);
-MODULE_PARM_DESC(max_pages, "Number of buffer pages to request");
-
-unsigned sfc_netfront_buffer_split = 2;
-module_param_named (buffer_split, sfc_netfront_buffer_split, uint, 0644);
-MODULE_PARM_DESC(buffer_split, 
-		 "Fraction of buffers to use for TX, rest for RX");
-
-
-const char *frontend_name = "sfc_netfront";
-
-struct workqueue_struct *netfront_accel_workqueue;
-
-static int __init netfront_accel_init(void)
-{
-	int rc;
-#ifdef EFX_GCOV	
-	gcov_provider_init(THIS_MODULE);
-#endif
-
-	/*
-	 * If we're running on dom0, netfront hasn't initialised
-	 * itself, so we need to keep away
-	 */
-	if (is_initial_xendomain())
-		return 0;
-
-	if (!is_pow2(sizeof(struct net_accel_msg)))
-		EPRINTK("%s: bad structure size\n", __FUNCTION__);
-
-	netfront_accel_workqueue = create_workqueue(frontend_name);
-
-	netfront_accel_debugfs_init();
-
-	rc = netfront_accelerator_loaded(NETFRONT_ACCEL_VERSION,
-					 frontend_name, &accel_hooks);
-
-	if (rc < 0) {
-		EPRINTK("Xen netfront accelerator version mismatch\n");
-		goto fail;
-	}
-
-	if (rc > 0) {
-		/* 
-		 * In future may want to add backwards compatibility
-		 * and accept certain subsets of previous versions
-		 */
-		EPRINTK("Xen netfront accelerator version mismatch\n");
-		goto fail;
-	}
-
-	return 0;
-
- fail:
-	netfront_accel_debugfs_fini();
-	flush_workqueue(netfront_accel_workqueue);
-	destroy_workqueue(netfront_accel_workqueue);
-#ifdef EFX_GCOV
- 	gcov_provider_fini(THIS_MODULE);
-#endif
-	return -EINVAL;
-}
-module_init(netfront_accel_init);
-
-static void __exit netfront_accel_exit(void)
-{
-	if (is_initial_xendomain())
-		return;
-
-	DPRINTK("%s: unhooking\n", __FUNCTION__);
-
-	/* Unhook from normal netfront */
-	netfront_accelerator_stop(frontend_name);
-
-	DPRINTK("%s: done\n", __FUNCTION__);
-
-	netfront_accel_debugfs_fini();
-
-	flush_workqueue(netfront_accel_workqueue);
-
-	destroy_workqueue(netfront_accel_workqueue);
-
-#ifdef EFX_GCOV
- 	gcov_provider_fini(THIS_MODULE);
-#endif
-	return;
-}
-module_exit(netfront_accel_exit);
-
-MODULE_LICENSE("GPL");
-
diff -r 9566a4a50a43 drivers/xen/sfc_netfront/accel_ssr.c
--- a/drivers/xen/sfc_netfront/accel_ssr.c
+++ /dev/null
@@ -1,308 +0,0 @@
-/****************************************************************************
- * Solarflare driver for Xen network acceleration
- *
- * Copyright 2006-2008: Solarflare Communications Inc,
- *                      9501 Jeronimo Road, Suite 250,
- *                      Irvine, CA 92618, USA
- *
- * Maintained by Solarflare Communications <linux-xen-drivers@solarflare.com>
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 as published
- * by the Free Software Foundation, incorporated herein by reference.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
- ****************************************************************************
- */
-
-#include <linux/socket.h>
-#include <linux/in.h>
-#include <linux/ip.h>
-#include <linux/tcp.h>
-#include <linux/list.h>
-#include <net/ip.h>
-#include <net/checksum.h>
-
-#include "accel.h"
-#include "accel_util.h"
-#include "accel_bufs.h"
-
-#include "accel_ssr.h"
-
-static inline int list_valid(struct list_head *lh) {
-	return(lh->next != NULL);
-}
-
-static void netfront_accel_ssr_deliver (struct netfront_accel_vnic *vnic,
-					struct netfront_accel_ssr_state *st,
-					struct netfront_accel_ssr_conn *c);
-
-/** Construct an efx_ssr_state.
- *
- * @v st     The SSR state (per channel per port)
- * @v port   The port.
- */
-void netfront_accel_ssr_init(struct netfront_accel_ssr_state *st) {
-	unsigned i;
-
-	INIT_LIST_HEAD(&st->conns);
-	INIT_LIST_HEAD(&st->free_conns);
-	for (i = 0; i < 8; ++i) {
-		struct netfront_accel_ssr_conn *c = 
-			kmalloc(sizeof(*c), GFP_KERNEL);
-		if (c == NULL)  break;
-		c->n_in_order_pkts = 0;
-		c->skb = NULL;
-		list_add(&c->link, &st->free_conns);
-	}
-
-}
-
-
-/** Destructor for an efx_ssr_state.
- *
- * @v st     The SSR state (per channel per port)
- */
-void netfront_accel_ssr_fini(netfront_accel_vnic *vnic, 
-			     struct netfront_accel_ssr_state *st) {
-	struct netfront_accel_ssr_conn *c;
-
-	/* Return cleanly if efx_ssr_init() not previously called */
-	BUG_ON(list_valid(&st->conns) != list_valid(&st->free_conns));
-	if (! list_valid(&st->conns))
-		return;
-
-	while ( ! list_empty(&st->free_conns)) {
-		c = list_entry(st->free_conns.prev, 
-			       struct netfront_accel_ssr_conn, link);
-		list_del(&c->link);
-		BUG_ON(c->skb != NULL);
-		kfree(c);
-	}
-	while ( ! list_empty(&st->conns)) {
-		c = list_entry(st->conns.prev, 
-			       struct netfront_accel_ssr_conn, link);
-		list_del(&c->link);
-		if (c->skb)
-			netfront_accel_ssr_deliver(vnic, st, c);
-		kfree(c);
-	}
-}
-
-
-/** Calc IP checksum and deliver to the OS
- *
- * @v st     The SSR state (per channel per port)
- * @v c	     The SSR connection state
- */
-static void netfront_accel_ssr_deliver(netfront_accel_vnic *vnic,
-				       struct netfront_accel_ssr_state *st,
-				       struct netfront_accel_ssr_conn *c) {
-	BUG_ON(c->skb == NULL);
-
-	/*
-	 * If we've chained packets together, recalculate the IP
-	 * checksum.
-	 */
-	if (skb_shinfo(c->skb)->frag_list) {
-		NETFRONT_ACCEL_STATS_OP(++vnic->stats.ssr_bursts);
-		c->iph->check = 0;
-		c->iph->check = ip_fast_csum((unsigned char *) c->iph, 
-					     c->iph->ihl);
-	}
-
-	VPRINTK("%s: %d\n", __FUNCTION__, c->skb->len);
-
-	netif_receive_skb(c->skb); 
-	c->skb = NULL;
-}
-
-
-/** Push held skbs down into network stack.
- *
- * @v st       SSR state
- *
- * Only called if we are tracking one or more connections.
- */
-void __netfront_accel_ssr_end_of_burst(netfront_accel_vnic *vnic, 
-				       struct netfront_accel_ssr_state *st) {
-	struct netfront_accel_ssr_conn *c;
-
-	BUG_ON(list_empty(&st->conns));
-
-	list_for_each_entry(c, &st->conns, link)
-		if (c->skb)
-			netfront_accel_ssr_deliver(vnic, st, c);
-
-	/* Time-out connections that have received no traffic for 20ms. */
-	c = list_entry(st->conns.prev, struct netfront_accel_ssr_conn,
-		       link);
-	if (jiffies - c->last_pkt_jiffies > (HZ / 50 + 1)) {
-		NETFRONT_ACCEL_STATS_OP(++vnic->stats.ssr_drop_stream);
-		list_del(&c->link);
-		list_add(&c->link, &st->free_conns);
-	}
-}
-
-
-/** Process SKB and decide whether to dispatch it to the stack now or
- * later.
- *
- * @v st	 SSR state
- * @v skb	SKB to exmaine
- * @ret rc       0 => deliver SKB to kernel now, otherwise the SKB belongs
- *	       us.
- */
-int netfront_accel_ssr_skb(struct netfront_accel_vnic *vnic,
-			   struct netfront_accel_ssr_state *st,
-			   struct sk_buff *skb) {
-	int data_length, dont_merge;
-	struct netfront_accel_ssr_conn *c;
-	struct iphdr *iph;
-	struct tcphdr *th;
-	unsigned th_seq;
-
-	BUG_ON(skb_shinfo(skb)->frag_list != NULL);
-	BUG_ON(skb->next != NULL);
-
-	/* We're not interested if it isn't TCP over IPv4. */
-	iph = (struct iphdr *) skb->data;
-	if (skb->protocol != htons(ETH_P_IP) ||
-	    iph->protocol != IPPROTO_TCP) {
-		return 0;
-	}
-
-	/* Ignore segments that fail csum or are fragmented. */
-	if (unlikely((skb->ip_summed - CHECKSUM_UNNECESSARY) |
-		     (iph->frag_off & htons(IP_MF | IP_OFFSET)))) {
-		return 0;
-	}
-
-	th = (struct tcphdr*)(skb->data + iph->ihl * 4);
-	data_length = ntohs(iph->tot_len) - iph->ihl * 4 - th->doff * 4;
-	th_seq = ntohl(th->seq);
-	dont_merge = (data_length == 0) | th->urg | th->syn | th->rst;
-
-	list_for_each_entry(c, &st->conns, link) {
-		if ((c->saddr  - iph->saddr) |
-		    (c->daddr  - iph->daddr) |
-		    (c->source - th->source) |
-		    (c->dest   - th->dest  ))
-			continue;
-
-		/* Re-insert at head of list to reduce lookup time. */
-		list_del(&c->link);
-		list_add(&c->link, &st->conns);
-		c->last_pkt_jiffies = jiffies;
-
-		if (unlikely(th_seq - c->next_seq)) {
-			/* Out-of-order, so start counting again. */
-			if (c->skb)
-				netfront_accel_ssr_deliver(vnic, st, c);
-			c->n_in_order_pkts = 0;
-			c->next_seq = th_seq + data_length;
-			NETFRONT_ACCEL_STATS_OP(++vnic->stats.ssr_misorder);
-			return 0;
-		}
-		c->next_seq = th_seq + data_length;
-
-		if (++c->n_in_order_pkts < 300) {
-			/* May be in slow-start, so don't merge. */
-			NETFRONT_ACCEL_STATS_OP(++vnic->stats.ssr_slow_start);
-			return 0;
-		}
-
-		if (unlikely(dont_merge)) {
-			if (c->skb)
-				netfront_accel_ssr_deliver(vnic, st, c);
-			return 0;
-		}
-
-		if (c->skb) {
-			c->iph->tot_len = ntohs(c->iph->tot_len);
-			c->iph->tot_len += data_length;
-			c->iph->tot_len = htons(c->iph->tot_len);
-			c->th->ack_seq = th->ack_seq;
-			c->th->fin |= th->fin;
-			c->th->psh |= th->psh;
-			c->th->window = th->window;
-
-			/* Remove the headers from this skb. */
-			skb_pull(skb, skb->len - data_length);
-
-			/*
-			 * Tack the new skb onto the head skb's frag_list.
-			 * This is exactly the format that fragmented IP
-			 * datagrams are reassembled into.
-			 */
-			BUG_ON(skb->next != 0);
-			if ( ! skb_shinfo(c->skb)->frag_list)
-				skb_shinfo(c->skb)->frag_list = skb;
-			else
-				c->skb_tail->next = skb;
-			c->skb_tail = skb;
-			c->skb->len += skb->len;
-			c->skb->data_len += skb->len;
-			c->skb->truesize += skb->truesize;
-
-			NETFRONT_ACCEL_STATS_OP(++vnic->stats.ssr_merges);
-
-			/*
-			 * If the next packet might push this super-packet
-			 * over the limit for an IP packet, deliver it now.
-			 * This is slightly conservative, but close enough.
-			 */
-			if (c->skb->len + 
-			    (PAGE_SIZE / NETFRONT_ACCEL_BUFS_PER_PAGE)
-			    > 16384)
-				netfront_accel_ssr_deliver(vnic, st, c);
-
-			return 1;
-		}
-		else {
-			c->iph = iph;
-			c->th = th;
-			c->skb = skb;
-			return 1;
-		}
-	}
-
-	/* We're not yet tracking this connection. */
-
-	if (dont_merge) {
-		return 0;
-	}
-
-	if (list_empty(&st->free_conns)) {
-		c = list_entry(st->conns.prev, 
-			       struct netfront_accel_ssr_conn,
-			       link);
-		if (c->skb) {
-			NETFRONT_ACCEL_STATS_OP(++vnic->stats.ssr_too_many);
-			return 0;
-		}
-	}
-	else {
-		c = list_entry(st->free_conns.next,
-			       struct netfront_accel_ssr_conn,
-			       link);
-	}
-	list_del(&c->link);
-	list_add(&c->link, &st->conns);
-	c->saddr = iph->saddr;
-	c->daddr = iph->daddr;
-	c->source = th->source;
-	c->dest = th->dest;
-	c->next_seq = th_seq + data_length;
-	c->n_in_order_pkts = 0;
-	BUG_ON(c->skb != NULL);
-	NETFRONT_ACCEL_STATS_OP(++vnic->stats.ssr_new_stream);
-	return 0;
-}
diff -r 9566a4a50a43 drivers/xen/sfc_netfront/accel_ssr.h
--- a/drivers/xen/sfc_netfront/accel_ssr.h
+++ /dev/null
@@ -1,88 +0,0 @@
-/****************************************************************************
- * Solarflare driver for Xen network acceleration
- *
- * Copyright 2006-2008: Solarflare Communications Inc,
- *                      9501 Jeronimo Road, Suite 250,
- *                      Irvine, CA 92618, USA
- *
- * Maintained by Solarflare Communications <linux-xen-drivers@solarflare.com>
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 as published
- * by the Free Software Foundation, incorporated herein by reference.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
- ****************************************************************************
- */
-
-#ifndef NETFRONT_ACCEL_SSR_H
-#define NETFRONT_ACCEL_SSR_H
-
-#include <linux/skbuff.h>
-#include <linux/ip.h>
-#include <linux/tcp.h>
-#include <linux/list.h>
-
-#include "accel.h"
-
-/** State for Soft Segment Reassembly (SSR). */
-
-struct netfront_accel_ssr_conn {
-	struct list_head link;
-
-	unsigned saddr, daddr;
-	unsigned short source, dest;
-
-	/** Number of in-order packets we've seen with payload. */
-	unsigned n_in_order_pkts;
-
-	/** Next in-order sequence number. */
-	unsigned next_seq;
-
-	/** Time we last saw a packet on this connection. */
-	unsigned long last_pkt_jiffies;
-
-	/** The SKB we are currently holding.  If NULL, then all following
-	 * fields are undefined.
-	 */
-	struct sk_buff *skb;
-
-	/** The tail of the frag_list of SKBs we're holding.  Only valid
-	 * after at least one merge.
-	 */
-	struct sk_buff *skb_tail;
-
-	/** The IP header of the skb we are holding. */
-	struct iphdr *iph;
-	
-	/** The TCP header of the skb we are holding. */
-	struct tcphdr *th;
-};
-
-extern void netfront_accel_ssr_init(struct netfront_accel_ssr_state *st);
-extern void netfront_accel_ssr_fini(netfront_accel_vnic *vnic,
-				    struct netfront_accel_ssr_state *st);
-
-extern void
-__netfront_accel_ssr_end_of_burst(netfront_accel_vnic *vnic,
-				  struct netfront_accel_ssr_state *st);
-
-extern int  netfront_accel_ssr_skb(netfront_accel_vnic *vnic,
-				   struct netfront_accel_ssr_state *st,
-				   struct sk_buff *skb);
-
-static inline void
-netfront_accel_ssr_end_of_burst (netfront_accel_vnic *vnic,
-				 struct netfront_accel_ssr_state *st) {
-	if ( ! list_empty(&st->conns) )
-		__netfront_accel_ssr_end_of_burst(vnic, st);
-}
-
-#endif /* NETFRONT_ACCEL_SSR_H */
diff -r 9566a4a50a43 drivers/xen/sfc_netfront/accel_tso.c
--- a/drivers/xen/sfc_netfront/accel_tso.c
+++ /dev/null
@@ -1,509 +0,0 @@
-/****************************************************************************
- * Solarflare driver for Xen network acceleration
- *
- * Copyright 2006-2008: Solarflare Communications Inc,
- *                      9501 Jeronimo Road, Suite 250,
- *                      Irvine, CA 92618, USA
- *
- * Maintained by Solarflare Communications <linux-xen-drivers@solarflare.com>
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 as published
- * by the Free Software Foundation, incorporated herein by reference.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
- ****************************************************************************
- */
-
-#include <linux/pci.h>
-#include <linux/tcp.h>
-#include <linux/ip.h>
-#include <linux/in.h>
-#include <linux/if_ether.h>
-
-#include "accel.h"
-#include "accel_util.h"
-
-#include "accel_tso.h"
-
-#define ETH_HDR_LEN(skb)  skb_network_offset(skb)
-#define SKB_TCP_OFF(skb)  skb_transport_offset(skb)
-#define SKB_IP_OFF(skb)   skb_network_offset(skb)
-
-/*
- * Set a maximum number of buffers in each output packet to make life
- * a little simpler - if this is reached it will just move on to
- * another packet 
- */
-#define ACCEL_TSO_MAX_BUFFERS (6)
-
-/** TSO State.
- *
- * The state used during segmentation.  It is put into this data structure
- * just to make it easy to pass into inline functions.
- */
-struct netfront_accel_tso_state {
-	/** bytes of data we've yet to segment */
-	unsigned remaining_len;
-
-	/** current sequence number */
-	unsigned seqnum;
-
-	/** remaining space in current packet */
-	unsigned packet_space;
-
-	/** List of packets to be output, containing the buffers and
-	 *  iovecs to describe each packet 
-	 */
-	struct netfront_accel_tso_output_packet *output_packets;
-
-	/** Total number of buffers in output_packets */
-	unsigned buffers;
-
-	/** Total number of packets in output_packets */
-	unsigned packets;
-
-	/** Input Fragment Cursor.
-	 *
-	 * Where we are in the current fragment of the incoming SKB.  These
-	 * values get updated in place when we split a fragment over
-	 * multiple packets.
-	 */
-	struct {
-		/** address of current position */
-		void *addr;
-		/** remaining length */   
-		unsigned int len;
-	} ifc; /*  == ifc Input Fragment Cursor */
-
-	/** Parameters.
-	 *
-	 * These values are set once at the start of the TSO send and do
-	 * not get changed as the routine progresses.
-	 */
-	struct {
-		/* the number of bytes of header */
-		unsigned int header_length;
-
-		/* The number of bytes to put in each outgoing segment. */
-		int full_packet_size;
-		
-		/* Current IP ID, host endian. */
-		unsigned ip_id;
-
-		/* Max size of each output packet payload */
-		int gso_size;
-	} p;
-};
-
-
-/**
- * Verify that our various assumptions about sk_buffs and the conditions
- * under which TSO will be attempted hold true.
- *
- * @v skb	       The sk_buff to check.
- */
-static inline void tso_check_safe(struct sk_buff *skb) {
-	EPRINTK_ON(skb->protocol != htons (ETH_P_IP));
-	EPRINTK_ON(((struct ethhdr*) skb->data)->h_proto != htons (ETH_P_IP));
-	EPRINTK_ON(ip_hdr(skb)->protocol != IPPROTO_TCP);
-	EPRINTK_ON((SKB_TCP_OFF(skb) + tcp_hdrlen(skb)) > skb_headlen(skb));
-}
-
-
-
-/** Parse the SKB header and initialise state. */
-static inline void tso_start(struct netfront_accel_tso_state *st, 
-			     struct sk_buff *skb) {
-
-	/*
-	 * All ethernet/IP/TCP headers combined size is TCP header size
-	 * plus offset of TCP header relative to start of packet.
- 	 */
-	st->p.header_length = tcp_hdrlen(skb) + SKB_TCP_OFF(skb);
-	st->p.full_packet_size = (st->p.header_length
-				  + skb_shinfo(skb)->gso_size);
-	st->p.gso_size = skb_shinfo(skb)->gso_size;
-
-	st->p.ip_id = htons(ip_hdr(skb)->id);
-	st->seqnum = ntohl(tcp_hdr(skb)->seq);
-
-	EPRINTK_ON(tcp_hdr(skb)->urg);
-	EPRINTK_ON(tcp_hdr(skb)->syn);
-	EPRINTK_ON(tcp_hdr(skb)->rst);
-
-	st->remaining_len = skb->len - st->p.header_length;
-
-	st->output_packets = NULL;
-	st->buffers = 0;
-	st->packets = 0;
-
-	VPRINTK("Starting new TSO: hl %d ps %d gso %d seq %x len %d\n",
-		st->p.header_length, st->p.full_packet_size, st->p.gso_size,
-		st->seqnum, skb->len);
-}
-
-/**
- * Add another NIC mapped buffer onto an output packet  
- */ 
-static inline int tso_start_new_buffer(netfront_accel_vnic *vnic,
-				       struct netfront_accel_tso_state *st,
-				       int first)
-{
-	struct netfront_accel_tso_buffer *tso_buf;
-	struct netfront_accel_pkt_desc *buf;
-
-	/* Get a mapped packet buffer */
-	buf = netfront_accel_buf_get(vnic->tx_bufs);
-	if (buf == NULL) {
-		DPRINTK("%s: No buffer for TX\n", __FUNCTION__);
-		return -1;
-	}
-
-	/* Store a bit of meta-data at the end */
-	tso_buf =(struct netfront_accel_tso_buffer *)
-		(buf->pkt_kva + NETFRONT_ACCEL_TSO_BUF_LENGTH
-		 + sizeof(struct netfront_accel_tso_output_packet));
-
-	tso_buf->buf = buf;
-
-	tso_buf->length = 0;
-	
-	if (first) {
-		struct netfront_accel_tso_output_packet *output_packet 
-			= (struct netfront_accel_tso_output_packet *)
-			(buf->pkt_kva + NETFRONT_ACCEL_TSO_BUF_LENGTH);
-		output_packet->next = st->output_packets;
-		st->output_packets = output_packet;
-		tso_buf->next = NULL;
-		st->output_packets->tso_bufs = tso_buf;
-		st->output_packets->tso_bufs_len = 1;
-	} else {
-		tso_buf->next = st->output_packets->tso_bufs;
-		st->output_packets->tso_bufs = tso_buf;
-		st->output_packets->tso_bufs_len ++;
-	}
-
-	BUG_ON(st->output_packets->tso_bufs_len > ACCEL_TSO_MAX_BUFFERS);
-	
-	st->buffers ++;
-
-	/*
-	 * Store the context, set to NULL, last packet buffer will get
-	 * non-NULL later
-	 */
-	tso_buf->buf->skb = NULL;
-
-	return 0;
-}
-
-
-/* Generate a new header, and prepare for the new packet.
- *
- * @v vnic	      VNIC
- * @v skb	       Socket buffer
- * @v st		TSO state
- * @ret rc	      0 on success, or -1 if failed to alloc header
- */
-
-static inline 
-int tso_start_new_packet(netfront_accel_vnic *vnic,
-			 struct sk_buff *skb,
-			 struct netfront_accel_tso_state *st) 
-{
-	struct netfront_accel_tso_buffer *tso_buf;
-	struct iphdr *tsoh_iph;
-	struct tcphdr *tsoh_th;
-	unsigned ip_length;
-
-	if (tso_start_new_buffer(vnic, st, 1) < 0) {
-		NETFRONT_ACCEL_STATS_OP(vnic->stats.fastpath_tx_busy++);
-		return -1;		
-	}
-
-	/* This has been set up by tso_start_new_buffer() */
-	tso_buf = st->output_packets->tso_bufs;
-
-	/* Copy in the header */
-	memcpy(tso_buf->buf->pkt_kva, skb->data, st->p.header_length);
-	tso_buf->length = st->p.header_length;
-
-	tsoh_th = (struct tcphdr*) 
-		(tso_buf->buf->pkt_kva + SKB_TCP_OFF(skb));
-	tsoh_iph = (struct iphdr*) 
-		(tso_buf->buf->pkt_kva + SKB_IP_OFF(skb));
-
-	/* Set to zero to encourage falcon to fill these in */
-	tsoh_th->check  = 0;
-	tsoh_iph->check = 0;
-
-	tsoh_th->seq = htonl(st->seqnum);
-	st->seqnum += st->p.gso_size;
-
-	if (st->remaining_len > st->p.gso_size) {
-		/* This packet will not finish the TSO burst. */
-		ip_length = st->p.full_packet_size - ETH_HDR_LEN(skb);
-		tsoh_th->fin = 0;
-		tsoh_th->psh = 0;
-	} else {
-		/* This packet will be the last in the TSO burst. */
-		ip_length = (st->p.header_length - ETH_HDR_LEN(skb)
-			     + st->remaining_len);
-		tsoh_th->fin = tcp_hdr(skb)->fin;
-		tsoh_th->psh = tcp_hdr(skb)->psh;
-	}
-
-	tsoh_iph->tot_len = htons(ip_length);
-
-	/* Linux leaves suitable gaps in the IP ID space for us to fill. */
-	tsoh_iph->id = st->p.ip_id++;
-	tsoh_iph->id = htons(tsoh_iph->id);
-
-	st->packet_space = st->p.gso_size; 
-
-	st->packets++;
-
-	return 0;
-}
-
-
-
-static inline void tso_get_fragment(struct netfront_accel_tso_state *st, 
-				    int len, void *addr)
-{
-	st->ifc.len = len;
-	st->ifc.addr = addr;
-	return;
-}
-
-
-static inline void tso_unwind(netfront_accel_vnic *vnic, 
-			      struct netfront_accel_tso_state *st)
-{
-	struct netfront_accel_tso_buffer *tso_buf;
-	struct netfront_accel_tso_output_packet *output_packet;
-
-	DPRINTK("%s\n", __FUNCTION__);
-
-	while (st->output_packets != NULL) {
-		output_packet = st->output_packets;
-		st->output_packets = output_packet->next;
-		while (output_packet->tso_bufs != NULL) {
-			tso_buf = output_packet->tso_bufs;
-			output_packet->tso_bufs = tso_buf->next;
-
-			st->buffers --;
-			output_packet->tso_bufs_len --;
-
-			netfront_accel_buf_put(vnic->tx_bufs, 
-					       tso_buf->buf->buf_id);
-		}
-	}
-	BUG_ON(st->buffers != 0);
-}
-
-
-
-static inline
-void tso_fill_packet_with_fragment(netfront_accel_vnic *vnic,
-				   struct netfront_accel_tso_state *st) 
-{
-	struct netfront_accel_tso_buffer *tso_buf;
-	int n, space;
-
-	BUG_ON(st->output_packets == NULL);
-	BUG_ON(st->output_packets->tso_bufs == NULL);
-
-	tso_buf = st->output_packets->tso_bufs;
-
-	if (st->ifc.len == 0)  return;
-	if (st->packet_space == 0)  return;
-	if (tso_buf->length == NETFRONT_ACCEL_TSO_BUF_LENGTH) return;
-
-	n = min(st->ifc.len, st->packet_space);
-
-	space = NETFRONT_ACCEL_TSO_BUF_LENGTH - tso_buf->length;
-	n = min(n, space);
-
-	st->packet_space -= n;
-	st->remaining_len -= n;
-	st->ifc.len -= n;
-
-	memcpy(tso_buf->buf->pkt_kva + tso_buf->length, st->ifc.addr, n);
-
-	tso_buf->length += n;
-
-	BUG_ON(tso_buf->length > NETFRONT_ACCEL_TSO_BUF_LENGTH);
-
-	st->ifc.addr += n;
-
-	return;
-}
-
-
-int netfront_accel_enqueue_skb_tso(netfront_accel_vnic *vnic,
-				   struct sk_buff *skb)
-{
-	struct netfront_accel_tso_state state;
-	struct netfront_accel_tso_buffer *tso_buf = NULL;
-	struct netfront_accel_tso_output_packet *reversed_list = NULL;
-	struct netfront_accel_tso_output_packet	*tmp_pkt;
-	ef_iovec iovecs[ACCEL_TSO_MAX_BUFFERS];
-	int frag_i, rc, dma_id;
-	skb_frag_t *f;
-
-	tso_check_safe(skb);
-
-	if (skb->ip_summed != CHECKSUM_PARTIAL)
-		EPRINTK("Trying to TSO send a packet without HW checksum\n");
-
-	tso_start(&state, skb);
-
-	/*
-	 * Setup the first payload fragment.  If the skb header area
-	 * contains exactly the headers and all payload is in the frag
-	 * list things are little simpler
-	 */
-	if (skb_headlen(skb) == state.p.header_length) {
-		/* Grab the first payload fragment. */
-		BUG_ON(skb_shinfo(skb)->nr_frags < 1);
-		frag_i = 0;
-		f = &skb_shinfo(skb)->frags[frag_i];
-		tso_get_fragment(&state, f->size, 
-				 page_address(f->page) + f->page_offset);
-	} else {
-		int hl = state.p.header_length;
-		tso_get_fragment(&state,  skb_headlen(skb) - hl, 
-				 skb->data + hl);
-		frag_i = -1;
-	}
-
-	if (tso_start_new_packet(vnic, skb, &state) < 0) {
-		DPRINTK("%s: out of first start-packet memory\n",
-			__FUNCTION__);
-		goto unwind;
-	}
-
-	while (1) {
-		tso_fill_packet_with_fragment(vnic, &state);
-		
-		/* Move onto the next fragment? */
-		if (state.ifc.len == 0) {
-			if (++frag_i >= skb_shinfo(skb)->nr_frags)
-				/* End of payload reached. */
-				break;
-			f = &skb_shinfo(skb)->frags[frag_i];
-			tso_get_fragment(&state, f->size,
-					 page_address(f->page) +
-					 f->page_offset);
-		}
-
-		/* Start a new buffer? */
-		if ((state.output_packets->tso_bufs->length == 
-		     NETFRONT_ACCEL_TSO_BUF_LENGTH) &&
-		    tso_start_new_buffer(vnic, &state, 0)) {
-			DPRINTK("%s: out of start-buffer memory\n",
-				__FUNCTION__);
-			goto unwind;
-		}
-
-		/* Start at new packet? */
-		if ((state.packet_space == 0 || 
-		     ((state.output_packets->tso_bufs_len >=
-		       ACCEL_TSO_MAX_BUFFERS) &&
-		      (state.output_packets->tso_bufs->length >= 
-		       NETFRONT_ACCEL_TSO_BUF_LENGTH))) &&
-		    tso_start_new_packet(vnic, skb, &state) < 0) {
-			DPRINTK("%s: out of start-packet memory\n",
-				__FUNCTION__);
-			goto unwind;
-		}
-
-	}
-
-	/* Check for space */
-	if (ef_vi_transmit_space(&vnic->vi) < state.buffers) {
-		DPRINTK("%s: Not enough TX space (%d)\n",
-			__FUNCTION__, state.buffers);
-		goto unwind;
-	}
-
-	/*
-	 * Store the skb context in the most recent buffer (i.e. the
-	 * last buffer that will be sent)
-	 */
-	state.output_packets->tso_bufs->buf->skb = skb;
-
-	/* Reverse the list of packets as we construct it on a stack */
-	while (state.output_packets != NULL) {
-		tmp_pkt = state.output_packets;
-		state.output_packets = tmp_pkt->next;
-		tmp_pkt->next = reversed_list;
-		reversed_list = tmp_pkt;
-	}
-
-	/* Pass off to hardware */
-	while (reversed_list != NULL) {
-		tmp_pkt = reversed_list;
-		reversed_list = tmp_pkt->next;
-
-		BUG_ON(tmp_pkt->tso_bufs_len > ACCEL_TSO_MAX_BUFFERS);
-		BUG_ON(tmp_pkt->tso_bufs_len == 0);
-
-		dma_id = tmp_pkt->tso_bufs->buf->buf_id;
-
-		/*
-		 * Make an iovec of the buffers in the list, reversing
-		 * the buffers as we go as they are constructed on a
-		 * stack
-		 */
-		tso_buf = tmp_pkt->tso_bufs;
-		for (frag_i = tmp_pkt->tso_bufs_len - 1;
-		     frag_i >= 0;
-		     frag_i--) {
-			iovecs[frag_i].iov_base = tso_buf->buf->pkt_buff_addr;
-			iovecs[frag_i].iov_len = tso_buf->length;
-			tso_buf = tso_buf->next;
-		}
-
-		rc = ef_vi_transmitv(&vnic->vi, iovecs, tmp_pkt->tso_bufs_len,
-				     dma_id);
-		/*
-		 * We checked for space already, so it really should
-		 * succeed
-		 */
-		BUG_ON(rc != 0);
-	}
-
-	/* Track number of tx fastpath stats */
-	vnic->netdev_stats.fastpath_tx_bytes += skb->len;
-	vnic->netdev_stats.fastpath_tx_pkts += state.packets;
-#if NETFRONT_ACCEL_STATS
-	{
-		unsigned n;
-		n = vnic->netdev_stats.fastpath_tx_pkts -
-			vnic->stats.fastpath_tx_completions;
-		if (n > vnic->stats.fastpath_tx_pending_max)
-			vnic->stats.fastpath_tx_pending_max = n;
-	}
-#endif
-
-	return NETFRONT_ACCEL_STATUS_GOOD;
- 
- unwind:
-	tso_unwind(vnic, &state);
-
-	NETFRONT_ACCEL_STATS_OP(vnic->stats.fastpath_tx_busy++);
-
-	return NETFRONT_ACCEL_STATUS_BUSY;
-}
-
-
-
diff -r 9566a4a50a43 drivers/xen/sfc_netfront/accel_tso.h
--- a/drivers/xen/sfc_netfront/accel_tso.h
+++ /dev/null
@@ -1,57 +0,0 @@
-/****************************************************************************
- * Solarflare driver for Xen network acceleration
- *
- * Copyright 2006-2008: Solarflare Communications Inc,
- *                      9501 Jeronimo Road, Suite 250,
- *                      Irvine, CA 92618, USA
- *
- * Maintained by Solarflare Communications <linux-xen-drivers@solarflare.com>
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 as published
- * by the Free Software Foundation, incorporated herein by reference.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
- ****************************************************************************
- */
-
-#ifndef NETFRONT_ACCEL_TSO_H
-#define NETFRONT_ACCEL_TSO_H
-
-#include "accel_bufs.h"
-
-/* Track the buffers used in each output packet */
-struct netfront_accel_tso_buffer {
-	struct netfront_accel_tso_buffer *next;
-	struct netfront_accel_pkt_desc *buf;
-	unsigned length;
-};
-
-/* Track the output packets formed from each input packet */
-struct netfront_accel_tso_output_packet {
-	struct netfront_accel_tso_output_packet *next;
-	struct netfront_accel_tso_buffer *tso_bufs;
-	unsigned tso_bufs_len;
-};
-
-
-/*
- * Max available space in a buffer for data once meta-data has taken
- * its place 
- */
-#define NETFRONT_ACCEL_TSO_BUF_LENGTH					\
-	((PAGE_SIZE / NETFRONT_ACCEL_BUFS_PER_PAGE)			\
-	 - sizeof(struct netfront_accel_tso_buffer)			\
-	 - sizeof(struct netfront_accel_tso_output_packet))
-
-int netfront_accel_enqueue_skb_tso(netfront_accel_vnic *vnic,
-				   struct sk_buff *skb);
-
-#endif /* NETFRONT_ACCEL_TSO_H */
diff -r 9566a4a50a43 drivers/xen/sfc_netfront/accel_vi.c
--- a/drivers/xen/sfc_netfront/accel_vi.c
+++ /dev/null
@@ -1,1201 +0,0 @@
-/****************************************************************************
- * Solarflare driver for Xen network acceleration
- *
- * Copyright 2006-2008: Solarflare Communications Inc,
- *                      9501 Jeronimo Road, Suite 250,
- *                      Irvine, CA 92618, USA
- *
- * Maintained by Solarflare Communications <linux-xen-drivers@solarflare.com>
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 as published
- * by the Free Software Foundation, incorporated herein by reference.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
- ****************************************************************************
- */
-
-#include <linux/if_ether.h>
-#include <linux/ip.h>
-#include <net/checksum.h>
-#include <asm/io.h>
-
-#include "accel.h"
-#include "accel_util.h"
-#include "accel_bufs.h"
-#include "accel_tso.h"
-#include "accel_ssr.h"
-#include "netfront.h"
-
-#include "etherfabric/ef_vi.h"
-
-/*
- * Max available space in a buffer for data once meta-data has taken
- * its place
- */
-#define NETFRONT_ACCEL_TX_BUF_LENGTH					\
-	((PAGE_SIZE / NETFRONT_ACCEL_BUFS_PER_PAGE)			\
-	 - sizeof(struct netfront_accel_tso_buffer))
-
-#define ACCEL_TX_MAX_BUFFERS (6)
-#define ACCEL_VI_POLL_EVENTS (8)
-
-static
-int netfront_accel_vi_init_fini(netfront_accel_vnic *vnic, 
-				struct net_accel_msg_hw *hw_msg)
-{
-	struct ef_vi_nic_type nic_type;
-	struct net_accel_hw_falcon_b *hw_info;
-	void *io_kva, *evq_base, *rx_dma_kva, *tx_dma_kva, *doorbell_kva;
-	u32 *evq_gnts;
-	u32 evq_order;
-	int vi_state_size;
-	u8 vi_data[VI_MAPPINGS_SIZE];
-
-	if (hw_msg == NULL)
-		goto fini;
-
-	/* And create the local macs table lock */
-	spin_lock_init(&vnic->table_lock);
-	
-	/* Create fastpath table, initial size 8, key length 8 */
-	if (cuckoo_hash_init(&vnic->fastpath_table, 3, 8)) {
-		EPRINTK("failed to allocate fastpath table\n");
-		goto fail_cuckoo;
-	}
-
-	vnic->hw.falcon.type = hw_msg->type;
-
-	switch (hw_msg->type) {
-	case NET_ACCEL_MSG_HWTYPE_FALCON_A:
-		hw_info = &hw_msg->resources.falcon_a.common;
-		/* Need the extra rptr register page on A1 */
-		io_kva = net_accel_map_iomem_page
-			(vnic->dev, hw_msg->resources.falcon_a.evq_rptr_gnt,
-			 &vnic->hw.falcon.evq_rptr_mapping);
-		if (io_kva == NULL) {
-			EPRINTK("%s: evq_rptr permission failed\n", __FUNCTION__);
-			goto evq_rptr_fail;
-		}
-
-		vnic->hw.falcon.evq_rptr = io_kva + 
-			(hw_info->evq_rptr & (PAGE_SIZE - 1));
-		break;
-	case NET_ACCEL_MSG_HWTYPE_FALCON_B:
-	case NET_ACCEL_MSG_HWTYPE_SIENA_A:
-		hw_info = &hw_msg->resources.falcon_b;
-		break;
-	default:
-		goto bad_type;
-	}
-
-	/**** Event Queue ****/
-
-	/* Map the event queue pages */
-	evq_gnts = hw_info->evq_mem_gnts;
-	evq_order = hw_info->evq_order;
-
-	EPRINTK_ON(hw_info->evq_offs != 0);
-
-	DPRINTK("Will map evq %d pages\n", 1 << evq_order);
-
-	evq_base =
-		net_accel_map_grants_contig(vnic->dev, evq_gnts, 1 << evq_order,
-					    &vnic->evq_mapping);
-	if (evq_base == NULL) {
-		EPRINTK("%s: evq_base failed\n", __FUNCTION__);
-		goto evq_fail;
-	}
-
-	/**** Doorbells ****/
-	/* Set up the doorbell mappings. */
-	doorbell_kva = 
-		net_accel_map_iomem_page(vnic->dev, hw_info->doorbell_gnt,
-					 &vnic->hw.falcon.doorbell_mapping);
-	if (doorbell_kva == NULL) {
-		EPRINTK("%s: doorbell permission failed\n", __FUNCTION__);
-		goto doorbell_fail;
-	}
-	vnic->hw.falcon.doorbell = doorbell_kva;
-
-	/* On Falcon_B and Siena we get the rptr from the doorbell page */
-	if (hw_msg->type == NET_ACCEL_MSG_HWTYPE_FALCON_B ||
-	    hw_msg->type == NET_ACCEL_MSG_HWTYPE_SIENA_A) {
-		vnic->hw.falcon.evq_rptr = 
-			(u32 *)((char *)vnic->hw.falcon.doorbell 
-				+ hw_info->evq_rptr);
-	}
-
-	/**** DMA Queue ****/
-
-	/* Set up the DMA Queues from the message. */
-	tx_dma_kva = net_accel_map_grants_contig
-		(vnic->dev, &(hw_info->txdmaq_gnt), 1, 
-		 &vnic->hw.falcon.txdmaq_mapping);
-	if (tx_dma_kva == NULL) {
-		EPRINTK("%s: TX dma failed\n", __FUNCTION__);
-		goto tx_dma_fail;
-	}
-
-	rx_dma_kva = net_accel_map_grants_contig
-		(vnic->dev, &(hw_info->rxdmaq_gnt), 1, 
-		 &vnic->hw.falcon.rxdmaq_mapping);
-	if (rx_dma_kva == NULL) {
-		EPRINTK("%s: RX dma failed\n", __FUNCTION__);
-		goto rx_dma_fail;
-	}
-
-	/* Full confession */
-	DPRINTK("Mapped H/W"
-		"  Tx DMAQ grant %x -> %p\n"
-		"  Rx DMAQ grant %x -> %p\n"
-		"  EVQ grant %x -> %p\n",
-		hw_info->txdmaq_gnt, tx_dma_kva,
-		hw_info->rxdmaq_gnt, rx_dma_kva,
-		evq_gnts[0], evq_base
-		);
-
-	memset(vi_data, 0, sizeof(vi_data));
-	
-	/* TODO BUG11305: convert efhw_arch to ef_vi_arch
-	 * e.g.
-	 * arch = ef_vi_arch_from_efhw_arch(hw_info->nic_arch);
-	 * assert(arch >= 0);
-	 * nic_type.arch = arch;
-	 */
-	nic_type.arch = (unsigned char)hw_info->nic_arch;
-	nic_type.variant = (char)hw_info->nic_variant;
-	nic_type.revision = (unsigned char)hw_info->nic_revision;
-	
-	ef_vi_init_mapping_evq(vi_data, nic_type, hw_info->instance, 
-			       1 << (evq_order + PAGE_SHIFT), evq_base, 
-			       (void *)0xdeadbeef);
-
-	ef_vi_init_mapping_vi(vi_data, nic_type, hw_info->rx_capacity, 
-			      hw_info->tx_capacity, hw_info->instance, 
-			      doorbell_kva, rx_dma_kva, tx_dma_kva, 0);
-
-	vi_state_size = ef_vi_calc_state_bytes(hw_info->rx_capacity,
-					       hw_info->tx_capacity);
-	vnic->vi_state = (ef_vi_state *)kmalloc(vi_state_size, GFP_KERNEL);
-	if (vnic->vi_state == NULL) {
-		EPRINTK("%s: kmalloc for VI state failed\n", __FUNCTION__);
-		goto vi_state_fail;
-	}
-	ef_vi_init(&vnic->vi, vi_data, vnic->vi_state, &vnic->evq_state, 0);
-
-	ef_eventq_state_init(&vnic->vi);
-
-	ef_vi_state_init(&vnic->vi);
-
-	return 0;
-
-fini:
-	kfree(vnic->vi_state);
-	vnic->vi_state = NULL;
-vi_state_fail:
-	net_accel_unmap_grants_contig(vnic->dev, vnic->hw.falcon.rxdmaq_mapping);
-rx_dma_fail:
-	net_accel_unmap_grants_contig(vnic->dev, vnic->hw.falcon.txdmaq_mapping);
-tx_dma_fail:
-	net_accel_unmap_iomem_page(vnic->dev, vnic->hw.falcon.doorbell_mapping);
-	vnic->hw.falcon.doorbell = NULL;
-doorbell_fail:
-	net_accel_unmap_grants_contig(vnic->dev, vnic->evq_mapping);
-evq_fail:
-	if (vnic->hw.falcon.type == NET_ACCEL_MSG_HWTYPE_FALCON_A)
-		net_accel_unmap_iomem_page(vnic->dev, 
-					   vnic->hw.falcon.evq_rptr_mapping);
-	vnic->hw.falcon.evq_rptr = NULL;
-evq_rptr_fail:
-bad_type:
-	cuckoo_hash_destroy(&vnic->fastpath_table);
-fail_cuckoo:
-	return -EIO;
-}
-
-
-void netfront_accel_vi_ctor(netfront_accel_vnic *vnic)
-{
-	/* Just mark the VI as uninitialised. */
-	vnic->vi_state = NULL;
-}
-
-
-int netfront_accel_vi_init(netfront_accel_vnic *vnic, struct net_accel_msg_hw *hw_msg)
-{
-	BUG_ON(hw_msg == NULL);
-	return netfront_accel_vi_init_fini(vnic, hw_msg);
-}
-
-
-void netfront_accel_vi_dtor(netfront_accel_vnic *vnic)
-{
-	if (vnic->vi_state != NULL)
-		netfront_accel_vi_init_fini(vnic, NULL);
-}
-
-
-static
-void netfront_accel_vi_post_rx(netfront_accel_vnic *vnic, u16 id,
-			       netfront_accel_pkt_desc *buf)
-{
-
-	int idx = vnic->rx_dma_batched;
-
-#if 0
-	VPRINTK("Posting buffer %d (0x%08x) for rx at index %d, space is %d\n",
-		id, buf->pkt_buff_addr, idx, ef_vi_receive_space(&vnic->vi));
-#endif
-	/* Set up a virtual buffer descriptor */
-	ef_vi_receive_init(&vnic->vi, buf->pkt_buff_addr, id,
-			   /*rx_bytes=max*/0);
-
-	idx++;
-
-	vnic->rx_dma_level++;
-	
-	/* 
-	 * Only push the descriptor to the card if we've reached the
-	 * batch size.  Otherwise, the descriptors can sit around for
-	 * a while.  There will be plenty available.
-	 */
-	if (idx >= NETFRONT_ACCEL_RX_DESC_BATCH ||
-	    vnic->rx_dma_level < NETFRONT_ACCEL_RX_DESC_BATCH) {
-#if 0
-		VPRINTK("Flushing %d rx descriptors.\n", idx);
-#endif
-
-		/* Push buffer to hardware */
-		ef_vi_receive_push(&vnic->vi);
-		
-		idx = 0;
-	}
-	
-	vnic->rx_dma_batched = idx;
-}
-
-
-inline
-void netfront_accel_vi_post_rx_or_free(netfront_accel_vnic *vnic, u16 id,
-				       netfront_accel_pkt_desc *buf)
-{
-
-	VPRINTK("%s: %d\n", __FUNCTION__, id);
-
-	if (ef_vi_receive_space(&vnic->vi) <= vnic->rx_dma_batched) {
-		VPRINTK("RX space is full\n");
-		netfront_accel_buf_put(vnic->rx_bufs, id);
-		return;
-	}
-
-	VPRINTK("Completed buffer %d is reposted\n", id);
-	netfront_accel_vi_post_rx(vnic, id, buf);
-	
-	/*
-	 * Let's see if there's any more to be pushed out to the NIC
-	 * while we're here
-	 */
-	while (ef_vi_receive_space(&vnic->vi) > vnic->rx_dma_batched) {
-		/* Try to allocate a buffer. */
-		buf = netfront_accel_buf_get(vnic->rx_bufs);
-		if (buf == NULL)
-			break;
-		
-		/* Add it to the rx dma queue. */
-		netfront_accel_vi_post_rx(vnic, buf->buf_id, buf);	
-	}
-}
-
-
-void netfront_accel_vi_add_bufs(netfront_accel_vnic *vnic, int is_rx)
-{
-
-	while (is_rx && 
-	       ef_vi_receive_space(&vnic->vi) > vnic->rx_dma_batched) {
-		netfront_accel_pkt_desc *buf;
-		
-		VPRINTK("%s: %d\n", __FUNCTION__, vnic->rx_dma_level);
-		
-		/* Try to allocate a buffer. */
-		buf = netfront_accel_buf_get(vnic->rx_bufs);
-
-		if (buf == NULL)
-			break;
-		
-		/* Add it to the rx dma queue. */
-		netfront_accel_vi_post_rx(vnic, buf->buf_id, buf);
-	}
-
-	VPRINTK("%s: done\n", __FUNCTION__);
-}
-
-
-struct netfront_accel_multi_state {
-	unsigned remaining_len;
-
-	unsigned buffers;
-
-	struct netfront_accel_tso_buffer *output_buffers;
-
-	/* Where we are in the current fragment of the SKB. */
-	struct {
-		/* address of current position */
-		void *addr;
-		/* remaining length */	  
-		unsigned int len;
-	} ifc; /*  == Input Fragment Cursor */
-};
-
-
-static inline void multi_post_start(struct netfront_accel_multi_state *st, 
-				    struct sk_buff *skb)
-{
-	st->remaining_len = skb->len;
-	st->output_buffers = NULL;
-	st->buffers = 0;
-	st->ifc.len = skb_headlen(skb);
-	st->ifc.addr = skb->data;
-}
-
-static int multi_post_start_new_buffer(netfront_accel_vnic *vnic, 
-				       struct netfront_accel_multi_state *st)
-{
-	struct netfront_accel_tso_buffer *tso_buf;
-	struct netfront_accel_pkt_desc *buf;
-
-	/* Get a mapped packet buffer */
-	buf = netfront_accel_buf_get(vnic->tx_bufs);
-	if (buf == NULL) {
-		DPRINTK("%s: No buffer for TX\n", __FUNCTION__);
-		return -1;
-	}
-
-	/* Store a bit of meta-data at the end */
-	tso_buf = (struct netfront_accel_tso_buffer *)
-		(buf->pkt_kva + NETFRONT_ACCEL_TX_BUF_LENGTH);
-
-	tso_buf->buf = buf;
-
-	tso_buf->length = 0;
-	
-	tso_buf->next = st->output_buffers;
-	st->output_buffers = tso_buf;
-	st->buffers++;
-
-	BUG_ON(st->buffers >= ACCEL_TX_MAX_BUFFERS);
-
-	/*
-	 * Store the context, set to NULL, last packet buffer will get
-	 * non-NULL later
-	 */
-	tso_buf->buf->skb = NULL;
-	
-	return 0;
-}
-
-
-static void
-multi_post_fill_buffer_with_fragment(netfront_accel_vnic *vnic,
-				     struct netfront_accel_multi_state *st)
-{
-	struct netfront_accel_tso_buffer *tso_buf;
-	unsigned n, space;
-
-	BUG_ON(st->output_buffers == NULL);
-	tso_buf = st->output_buffers;
-
-	if (st->ifc.len == 0) return;
-	if (tso_buf->length == NETFRONT_ACCEL_TX_BUF_LENGTH) return;
-
-	BUG_ON(tso_buf->length > NETFRONT_ACCEL_TX_BUF_LENGTH);
-
-	space = NETFRONT_ACCEL_TX_BUF_LENGTH - tso_buf->length;
-	n = min(st->ifc.len, space);
-
-	memcpy(tso_buf->buf->pkt_kva + tso_buf->length, st->ifc.addr, n);
-
-	st->remaining_len -= n;
-	st->ifc.len -= n;
-	tso_buf->length += n;
-	st->ifc.addr += n;
-
-	BUG_ON(tso_buf->length > NETFRONT_ACCEL_TX_BUF_LENGTH);
-
-	return;
-}
-
-
-static inline void multi_post_unwind(netfront_accel_vnic *vnic,
-				     struct netfront_accel_multi_state *st)
-{
-	struct netfront_accel_tso_buffer *tso_buf;
-
-	DPRINTK("%s\n", __FUNCTION__);
-
-	while (st->output_buffers != NULL) {
-		tso_buf = st->output_buffers;
-		st->output_buffers = tso_buf->next;
-		st->buffers--;
-		netfront_accel_buf_put(vnic->tx_bufs, tso_buf->buf->buf_id);
-	}
-	BUG_ON(st->buffers != 0);
-}
-
-
-static enum netfront_accel_post_status
-netfront_accel_enqueue_skb_multi(netfront_accel_vnic *vnic, struct sk_buff *skb)
-{
-	struct netfront_accel_tso_buffer *tso_buf;
-	struct netfront_accel_multi_state state;
-	ef_iovec iovecs[ACCEL_TX_MAX_BUFFERS];
-	skb_frag_t *f;
-	int frag_i, rc, dma_id;
-
-	multi_post_start(&state, skb);
-
-	frag_i = -1;
-
-	if (skb->ip_summed == CHECKSUM_PARTIAL) {
-		/* Set to zero to encourage falcon to work it out for us */
-		*(u16*)(skb->head + skb->csum_start + skb->csum_offset) = 0;
-	}
-
-	if (multi_post_start_new_buffer(vnic, &state)) {
-		DPRINTK("%s: out of buffers\n", __FUNCTION__);
-		goto unwind;
-	}
-
-	while (1) {
-		multi_post_fill_buffer_with_fragment(vnic, &state);
-
-		/* Move onto the next fragment? */
-		if (state.ifc.len == 0) {
-			if (++frag_i >= skb_shinfo(skb)->nr_frags)
-				/* End of payload reached. */
-				break;
-			f = &skb_shinfo(skb)->frags[frag_i];
-			state.ifc.len = f->size;
-			state.ifc.addr = page_address(f->page) + f->page_offset;
-		}
-
-		/* Start a new buffer? */
-		if ((state.output_buffers->length == 
-		     NETFRONT_ACCEL_TX_BUF_LENGTH) &&
-		    multi_post_start_new_buffer(vnic, &state)) {
-			DPRINTK("%s: out of buffers\n", __FUNCTION__);
-			goto unwind;
-		}
-	}
-
-	/* Check for space */
-	if (ef_vi_transmit_space(&vnic->vi) < state.buffers) {
-		DPRINTK("%s: Not enough TX space (%d)\n", __FUNCTION__, state.buffers);
-		goto unwind;
-	}
-
-	/* Store the skb in what will be the last buffer's context */
-	state.output_buffers->buf->skb = skb;
-	/* Remember dma_id of what will be the last buffer */ 
-	dma_id = state.output_buffers->buf->buf_id;
-
-	/*
-	 * Make an iovec of the buffers in the list, reversing the
-	 * buffers as we go as they are constructed on a stack
-	 */
-	tso_buf = state.output_buffers;
-	for (frag_i = state.buffers-1; frag_i >= 0; frag_i--) {
-		iovecs[frag_i].iov_base = tso_buf->buf->pkt_buff_addr;
-		iovecs[frag_i].iov_len = tso_buf->length;
-		tso_buf = tso_buf->next;
-	}
-	
-	rc = ef_vi_transmitv(&vnic->vi, iovecs, state.buffers, dma_id);
-
-	/* Track number of tx fastpath stats */
-	vnic->netdev_stats.fastpath_tx_bytes += skb->len;
-	vnic->netdev_stats.fastpath_tx_pkts ++;
-#if NETFRONT_ACCEL_STATS
-	{
-		u32 n;
-		n = vnic->netdev_stats.fastpath_tx_pkts -
-			(u32)vnic->stats.fastpath_tx_completions;
-		if (n > vnic->stats.fastpath_tx_pending_max)
-			vnic->stats.fastpath_tx_pending_max = n;
-	}
-#endif
-	return NETFRONT_ACCEL_STATUS_GOOD;
-
-unwind:
-	multi_post_unwind(vnic, &state);
-
-	NETFRONT_ACCEL_STATS_OP(vnic->stats.fastpath_tx_busy++);
-
-	return NETFRONT_ACCEL_STATUS_BUSY;
-}
-
-
-static enum netfront_accel_post_status 
-netfront_accel_enqueue_skb_single(netfront_accel_vnic *vnic, struct sk_buff *skb)
-{
-	struct netfront_accel_tso_buffer *tso_buf;
-	struct netfront_accel_pkt_desc *buf;
-	u8 *kva;
-	int rc;
-
-	if (ef_vi_transmit_space(&vnic->vi) < 1) {
-		DPRINTK("%s: No TX space\n", __FUNCTION__);
-		NETFRONT_ACCEL_STATS_OP(vnic->stats.fastpath_tx_busy++);
-		return NETFRONT_ACCEL_STATUS_BUSY;
-	}
-
-	buf = netfront_accel_buf_get(vnic->tx_bufs);
-	if (buf == NULL) {
-		DPRINTK("%s: No buffer for TX\n", __FUNCTION__);
-		NETFRONT_ACCEL_STATS_OP(vnic->stats.fastpath_tx_busy++);
-		return NETFRONT_ACCEL_STATUS_BUSY;
-	}
-
-	/* Track number of tx fastpath stats */
-	vnic->netdev_stats.fastpath_tx_pkts++;
-	vnic->netdev_stats.fastpath_tx_bytes += skb->len;
-
-#if NETFRONT_ACCEL_STATS
-	{
-		u32 n;
-		n = vnic->netdev_stats.fastpath_tx_pkts - 
-			(u32)vnic->stats.fastpath_tx_completions;
-		if (n > vnic->stats.fastpath_tx_pending_max)
-			vnic->stats.fastpath_tx_pending_max = n;
-	}
-#endif
-	
-	/* Store the context */
-	buf->skb = skb;
-	
-	kva = buf->pkt_kva;
-
-	if (skb->ip_summed == CHECKSUM_PARTIAL) {
-		/* Set to zero to encourage falcon to work it out for us */
-		*(u16*)(skb->head + skb->csum_start + skb->csum_offset) = 0;
-	}
-	NETFRONT_ACCEL_PKTBUFF_FOR_EACH_FRAGMENT
-		(skb, idx, frag_data, frag_len, {
-			/* Copy in payload */
-			VPRINTK("*** Copying %d bytes to %p\n", frag_len, kva);
-			memcpy(kva, frag_data, frag_len);
-			kva += frag_len;
-		});
-
-	VPRINTK("%s: id %d pkt %p kva %p buff_addr 0x%08x\n", __FUNCTION__,
-		buf->buf_id, buf, buf->pkt_kva, buf->pkt_buff_addr);
-
-
-	/* Set up the TSO meta-data for a single buffer/packet */
-	tso_buf = (struct netfront_accel_tso_buffer *)
-		(buf->pkt_kva + NETFRONT_ACCEL_TX_BUF_LENGTH);
-	tso_buf->next = NULL;
-	tso_buf->buf = buf;
-	tso_buf->length = skb->len;
-
-	rc = ef_vi_transmit(&vnic->vi, buf->pkt_buff_addr, skb->len,
-			    buf->buf_id);
-	/* We checked for space already, so it really should succeed */
-	BUG_ON(rc != 0);
-
-	return NETFRONT_ACCEL_STATUS_GOOD;
-}
-
-
-enum netfront_accel_post_status 
-netfront_accel_vi_tx_post(netfront_accel_vnic *vnic, struct sk_buff *skb)
-{
-	struct ethhdr *pkt_eth_hdr;
-	struct iphdr *pkt_ipv4_hdr;
-	int value, try_fastpath;
-
-	/*
-	 * This assumes that the data field points to the dest mac
-	 * address.
-	 */
-	cuckoo_hash_mac_key key = cuckoo_mac_to_key(skb->data);
-
-	/*
-	 * NB very important that all things that could return "CANT"
-	 * are tested before things that return "BUSY" as if it it
-	 * returns "BUSY" it is assumed that it won't return "CANT"
-	 * next time it is tried
-	 */
-
-	/*
-	 * Do a fastpath send if fast path table lookup returns true.
-	 * We do this without the table lock and so may get the wrong
-	 * answer, but current opinion is that's not a big problem 
-	 */
-	try_fastpath = cuckoo_hash_lookup(&vnic->fastpath_table, 
-					  (cuckoo_hash_key *)(&key), &value);
-
-	if (!try_fastpath) {
-		VPRINTK("try fast path false for mac: %pM\n", skb->data);
-		
-		return NETFRONT_ACCEL_STATUS_CANT;
-	}
-
-	/* Check to see if the packet can be sent. */
-	if (skb_headlen(skb) < sizeof(*pkt_eth_hdr) + sizeof(*pkt_ipv4_hdr)) {
-		EPRINTK("%s: Packet header is too small\n", __FUNCTION__);
-		return NETFRONT_ACCEL_STATUS_CANT;
-	}
-
-	pkt_eth_hdr  = (void*)skb->data;
-	pkt_ipv4_hdr = (void*)(pkt_eth_hdr+1);
-
-	if (be16_to_cpu(pkt_eth_hdr->h_proto) != ETH_P_IP) {
-		DPRINTK("%s: Packet is not IPV4 (ether_type=0x%04x)\n", __FUNCTION__,
-			be16_to_cpu(pkt_eth_hdr->h_proto));
-		return NETFRONT_ACCEL_STATUS_CANT;
-	}
-	
-	if (pkt_ipv4_hdr->protocol != IPPROTO_TCP &&
-	    pkt_ipv4_hdr->protocol != IPPROTO_UDP) {
-		DPRINTK("%s: Packet is not TCP/UDP (ip_protocol=0x%02x)\n",
-			__FUNCTION__, pkt_ipv4_hdr->protocol);
-		return NETFRONT_ACCEL_STATUS_CANT;
-	}
-	
-	VPRINTK("%s: %d bytes, gso %d\n", __FUNCTION__, skb->len, 
-		skb_shinfo(skb)->gso_size);
-	
-	if (skb_shinfo(skb)->gso_size) {
-		return netfront_accel_enqueue_skb_tso(vnic, skb);
-	}
-
-	if (skb->len <= NETFRONT_ACCEL_TX_BUF_LENGTH) {
-		return netfront_accel_enqueue_skb_single(vnic, skb);
-	}
-
-	return netfront_accel_enqueue_skb_multi(vnic, skb);
-}
-
-
-/*
- * Copy the data to required end destination. NB. len is the total new
- * length of the socket buffer, not the amount of data to copy
- */
-inline
-int ef_vnic_copy_to_skb(netfront_accel_vnic *vnic, struct sk_buff *skb, 
-			struct netfront_accel_pkt_desc *buf, int len)
-{
-	int i, extra = len - skb->len;
-	char c;
-	int pkt_stride = vnic->rx_pkt_stride;
-	int skb_stride = vnic->rx_skb_stride;
-	char *skb_start;
-	
-	/*
-	 * This pulls stuff into the cache - have seen performance
-	 * benefit in this, but disabled by default
-	 */
-	skb_start = skb->data;
-	if (pkt_stride) {
-		for (i = 0; i < len; i += pkt_stride) {
-			c += ((volatile char*)(buf->pkt_kva))[i];
-		}
-	}
-	if (skb_stride) {
-		for (i = skb->len; i < len ; i += skb_stride) {
-			c += ((volatile char*)(skb_start))[i];
-		}
-	}
-
-	if (skb_tailroom(skb) >= extra) {
-		memcpy(skb_put(skb, extra), buf->pkt_kva, extra);
-		return 0;
-	}
-
-	return -ENOSPC;
-}
-
-
-static void discard_jumbo_state(netfront_accel_vnic *vnic) 
-{
-
-	if (vnic->jumbo_state.skb != NULL) {
-		dev_kfree_skb_any(vnic->jumbo_state.skb);
-
-		vnic->jumbo_state.skb = NULL;
-	}
-	vnic->jumbo_state.in_progress = 0;
-}
-
-
-static void  netfront_accel_vi_rx_complete(netfront_accel_vnic *vnic,
-					   struct sk_buff *skb)
-{
-	cuckoo_hash_mac_key key;
-	unsigned long flags;
-	int value;
-	struct net_device *net_dev;
-
-
-	key = cuckoo_mac_to_key(skb->data + ETH_ALEN);
-
-	/*
-	 * If this is a MAC address that we want to do fast path TX
-	 * to, and we don't already, add it to the fastpath table.
-	 * The initial lookup is done without the table lock and so
-	 * may get the wrong answer, but current opinion is that's not
-	 * a big problem
-	 */
-	if (is_valid_ether_addr(skb->data + ETH_ALEN) &&
-	    !cuckoo_hash_lookup(&vnic->fastpath_table, (cuckoo_hash_key *)&key,
-				&value)) {
-		spin_lock_irqsave(&vnic->table_lock, flags);
-		   
-		cuckoo_hash_add_check(&vnic->fastpath_table,
-				      (cuckoo_hash_key *)&key,
-				      1, 1);
-		
-		spin_unlock_irqrestore(&vnic->table_lock, flags);
-	}
-
-	if (compare_ether_addr(skb->data, vnic->mac)) {
-		struct iphdr *ip = (struct iphdr *)(skb->data + ETH_HLEN);
-		u16 port;
-
-		DPRINTK("%s: saw wrong MAC address %pM\n",
-			__FUNCTION__, skb->data);
-
-		if (ip->protocol == IPPROTO_TCP) {
-			struct tcphdr *tcp = (struct tcphdr *)
-				((char *)ip + 4 * ip->ihl);
-			port = tcp->dest;
-		} else {
-			struct udphdr *udp = (struct udphdr *)
-				((char *)ip + 4 * ip->ihl);
-			EPRINTK_ON(ip->protocol != IPPROTO_UDP);
-			port = udp->dest;
-		}
-
-		netfront_accel_msg_tx_fastpath(vnic, skb->data,
-					       ip->daddr, port,
-					       ip->protocol);
-	}
-
-	net_dev = vnic->net_dev;
-	skb->dev = net_dev;
-	skb->protocol = eth_type_trans(skb, net_dev);
-	/* CHECKSUM_UNNECESSARY as hardware has done it already */
-	skb->ip_summed = CHECKSUM_UNNECESSARY;
-
-	if (!netfront_accel_ssr_skb(vnic, &vnic->ssr_state, skb))
-		netif_receive_skb(skb);
-}
-
-
-static int netfront_accel_vi_poll_process_rx(netfront_accel_vnic *vnic, 
-					     ef_event *ev)
-{
-	struct netfront_accel_bufinfo *bufinfo = vnic->rx_bufs;
-	struct netfront_accel_pkt_desc *buf = NULL;
-	struct sk_buff *skb;
-	int id, len, sop = 0, cont = 0;
-
-	VPRINTK("Rx event.\n");
-	/*
-	 * Complete the receive operation, and get the request id of
-	 * the buffer
-	 */
-	id = ef_vi_receive_done(&vnic->vi, ev);
-
-	if (id < 0 || id >= bufinfo->npages*NETFRONT_ACCEL_BUFS_PER_PAGE) {
-		EPRINTK("Rx packet %d is invalid\n", id);
-		/* Carry on round the loop if more events */
-		goto bad_packet;
-	}
-	/* Get our buffer descriptor */
-	buf = netfront_accel_buf_find(bufinfo, id);
-
-	len = EF_EVENT_RX_BYTES(*ev);
-
-	/* An RX buffer has been removed from the DMA ring. */
-	vnic->rx_dma_level--;
-
-	if (EF_EVENT_TYPE(*ev) == EF_EVENT_TYPE_RX) {
-		sop = EF_EVENT_RX_SOP(*ev);
-		cont = EF_EVENT_RX_CONT(*ev);
-
-		skb = vnic->jumbo_state.skb;
-
-		VPRINTK("Rx packet %d: %d bytes so far; sop %d; cont %d\n", 
-			id, len, sop, cont);
-
-		if (sop) {
-			if (!vnic->jumbo_state.in_progress) {
-				vnic->jumbo_state.in_progress = 1;
-				BUG_ON(vnic->jumbo_state.skb != NULL);
-			} else {
-				/*
-				 * This fragment shows a missing tail in 
-				 * previous one, but is itself possibly OK
-				 */
-				DPRINTK("sop and in_progress => no tail\n");
-
-				/* Release the socket buffer we already had */
-				discard_jumbo_state(vnic);
-
-				/* Now start processing this fragment */
-				vnic->jumbo_state.in_progress = 1;
-				skb = NULL;
-			}
-		} else if (!vnic->jumbo_state.in_progress) {
-			DPRINTK("!sop and !in_progress => missing head\n");
-			goto missing_head;
-		}
-
-		if (!cont) {
-			/* Update state for next time */
-			vnic->jumbo_state.in_progress = 0;
-			vnic->jumbo_state.skb = NULL;
-		} else if (!vnic->jumbo_state.in_progress) {
-			DPRINTK("cont and !in_progress => missing head\n");
-			goto missing_head;
-		}
-
-		if (skb == NULL) {
-			BUG_ON(!sop);
-
-			if (!cont)
-				skb = alloc_skb(len+NET_IP_ALIGN, GFP_ATOMIC);
-			else
-				skb = alloc_skb(vnic->net_dev->mtu+NET_IP_ALIGN, 
-						GFP_ATOMIC);
-
-			if (skb == NULL) {
-				DPRINTK("%s: Couldn't get an rx skb.\n",
-					__FUNCTION__);
-				netfront_accel_vi_post_rx_or_free(vnic, (u16)id, buf);
-				/*
-				 * Dropping this fragment means we
-				 * should discard the rest too
-				 */
-				discard_jumbo_state(vnic);
-
-				/* Carry on round the loop if more events */
-				return 0;
-			}
-
-		}
-		
-		/* Copy the data to required end destination */
-		if (ef_vnic_copy_to_skb(vnic, skb, buf, len) != 0) {
-			/*
-			 * No space in the skb - suggests > MTU packet
-			 * received
-			 */
-			EPRINTK("%s: Rx packet too large (%d)\n",
-				__FUNCTION__, len);
-			netfront_accel_vi_post_rx_or_free(vnic, (u16)id, buf);
-			discard_jumbo_state(vnic);
-			return 0;
-		}
-		
-		/* Put the buffer back in the DMA queue. */
-		netfront_accel_vi_post_rx_or_free(vnic, (u16)id, buf);
-
-		if (cont) {
-			vnic->jumbo_state.skb = skb;
-
-			return 0;
-		} else {
-			/* Track number of rx fastpath packets */
-			vnic->netdev_stats.fastpath_rx_pkts++;
-			vnic->netdev_stats.fastpath_rx_bytes += len;
-
-			netfront_accel_vi_rx_complete(vnic, skb);
-
-			return 1;
-		}
-	} else {
-		BUG_ON(EF_EVENT_TYPE(*ev) != EF_EVENT_TYPE_RX_DISCARD);
-
-		if (EF_EVENT_RX_DISCARD_TYPE(*ev) 
-		    == EF_EVENT_RX_DISCARD_TRUNC) {
-			DPRINTK("%s: " EF_EVENT_FMT 
-				" buffer %d FRM_TRUNC q_id %d\n",
-				__FUNCTION__, EF_EVENT_PRI_ARG(*ev), id,
-				EF_EVENT_RX_DISCARD_Q_ID(*ev) );
-			NETFRONT_ACCEL_STATS_OP(++vnic->stats.fastpath_frm_trunc);
-		} else if (EF_EVENT_RX_DISCARD_TYPE(*ev) 
-			  == EF_EVENT_RX_DISCARD_OTHER) {
-			DPRINTK("%s: " EF_EVENT_FMT 
-				" buffer %d RX_DISCARD_OTHER q_id %d\n",
-				__FUNCTION__, EF_EVENT_PRI_ARG(*ev), id,
-				EF_EVENT_RX_DISCARD_Q_ID(*ev) );
-			NETFRONT_ACCEL_STATS_OP(++vnic->stats.fastpath_discard_other);
-		} else if (EF_EVENT_RX_DISCARD_TYPE(*ev) ==
-			   EF_EVENT_RX_DISCARD_CSUM_BAD) {
-			DPRINTK("%s: " EF_EVENT_FMT 
-				" buffer %d DISCARD CSUM_BAD q_id %d\n",
-				__FUNCTION__, EF_EVENT_PRI_ARG(*ev), id,
-				EF_EVENT_RX_DISCARD_Q_ID(*ev) );
-			NETFRONT_ACCEL_STATS_OP(++vnic->stats.fastpath_csum_bad);
-		} else if (EF_EVENT_RX_DISCARD_TYPE(*ev) ==
-			   EF_EVENT_RX_DISCARD_CRC_BAD) {
-			DPRINTK("%s: " EF_EVENT_FMT 
-				" buffer %d DISCARD CRC_BAD q_id %d\n",
-				__FUNCTION__, EF_EVENT_PRI_ARG(*ev), id,
-				EF_EVENT_RX_DISCARD_Q_ID(*ev) );
-			NETFRONT_ACCEL_STATS_OP(++vnic->stats.fastpath_crc_bad);
-		} else {
-			BUG_ON(EF_EVENT_RX_DISCARD_TYPE(*ev) !=
-			       EF_EVENT_RX_DISCARD_RIGHTS);
-			DPRINTK("%s: " EF_EVENT_FMT 
-				" buffer %d DISCARD RIGHTS q_id %d\n",
-				__FUNCTION__, EF_EVENT_PRI_ARG(*ev), id,
-				EF_EVENT_RX_DISCARD_Q_ID(*ev) );
-			NETFRONT_ACCEL_STATS_OP(++vnic->stats.fastpath_rights_bad);
-		}
-	}
-
-	/* discard type drops through here */
-
-bad_packet:
-	/* Release the socket buffer we already had */
-	discard_jumbo_state(vnic);
-
-missing_head:
-	BUG_ON(vnic->jumbo_state.in_progress != 0);
-	BUG_ON(vnic->jumbo_state.skb != NULL);
-
-	if (id >= 0 && id < bufinfo->npages*NETFRONT_ACCEL_BUFS_PER_PAGE)
-		/* Put the buffer back in the DMA queue. */
-		netfront_accel_vi_post_rx_or_free(vnic, (u16)id, buf);
-
-	vnic->netdev_stats.fastpath_rx_errors++;
-
-	DPRINTK("%s experienced bad packet/missing fragment error: %d \n",
-		__FUNCTION__, ev->rx.flags);
-
-	return 0;
-}
-
-
-static void netfront_accel_vi_not_busy(netfront_accel_vnic *vnic)
-{
-	struct netfront_info *np = ((struct netfront_info *)
-				    netdev_priv(vnic->net_dev));
-	int handled;
-	unsigned long flags;
-
-	/*
-	 * We hold the vnic tx_lock which is sufficient to exclude
-	 * writes to tx_skb
-	 */
-
-	if (vnic->tx_skb != NULL) {
-		DPRINTK("%s trying to send spare buffer\n", __FUNCTION__);
-		
-		handled = netfront_accel_vi_tx_post(vnic, vnic->tx_skb);
-		
-		if (handled != NETFRONT_ACCEL_STATUS_BUSY) {
-			DPRINTK("%s restarting tx\n", __FUNCTION__);
-
-			/* Need netfront tx_lock and vnic tx_lock to
-			 * write tx_skb */
-			spin_lock_irqsave(&np->tx_lock, flags);
-
-			vnic->tx_skb = NULL;
-
-			if (netfront_check_queue_ready(vnic->net_dev)) {
-				netif_wake_queue(vnic->net_dev);
-				NETFRONT_ACCEL_STATS_OP
-					(vnic->stats.queue_wakes++);
-			}
-			spin_unlock_irqrestore(&np->tx_lock, flags);
-
-		}
-		
-		/*
-		 * Should never get a CANT, as it checks that before
-		 * deciding it was BUSY first time round 
-		 */
-		BUG_ON(handled == NETFRONT_ACCEL_STATUS_CANT);
-	}
-}
-
-
-static void netfront_accel_vi_tx_complete(netfront_accel_vnic *vnic, 
-					  struct netfront_accel_tso_buffer *tso_buf,
-					  int is_last)
-{
-	struct netfront_accel_tso_buffer *next;
-
-	/* 
-	 * We get a single completion for every call to
-	 * ef_vi_transmitv so handle any other buffers which are part
-	 * of the same packet 
-	 */
-	while (tso_buf != NULL) {
-		if (tso_buf->buf->skb != NULL) {
-			dev_kfree_skb_any(tso_buf->buf->skb);
-			tso_buf->buf->skb = NULL;
-		}
-
-		next = tso_buf->next;
-
-		netfront_accel_buf_put(vnic->tx_bufs, tso_buf->buf->buf_id);
-
-		tso_buf = next;
-	}
-
-	/*
-	 * If this was the last one in the batch, we try and send any
-	 * pending tx_skb. There should now be buffers and
-	 * descriptors
-	 */
-	if (is_last)
-		netfront_accel_vi_not_busy(vnic);
-}
-
-
-static void netfront_accel_vi_poll_process_tx(netfront_accel_vnic *vnic,
-					      ef_event *ev)
-{
-	struct netfront_accel_pkt_desc *buf;
-	struct netfront_accel_tso_buffer *tso_buf;
-	ef_request_id ids[EF_VI_TRANSMIT_BATCH];
-	int i, n_ids;
-	unsigned long flags;
-
-	/* Get the request ids for this tx completion event. */
-	n_ids = ef_vi_transmit_unbundle(&vnic->vi, ev, ids);
-
-	/* Take the tx buffer spin lock and hold for the duration */
-	spin_lock_irqsave(&vnic->tx_lock, flags);
-
-	for (i = 0; i < n_ids; ++i) {
-		VPRINTK("Tx packet %d complete\n", ids[i]);
-		buf = netfront_accel_buf_find(vnic->tx_bufs, ids[i]);
-		NETFRONT_ACCEL_STATS_OP(vnic->stats.fastpath_tx_completions++);
-
-		tso_buf = (struct netfront_accel_tso_buffer *)
-			(buf->pkt_kva + NETFRONT_ACCEL_TX_BUF_LENGTH);
-		BUG_ON(tso_buf->buf != buf);
-
-		netfront_accel_vi_tx_complete(vnic, tso_buf, i == (n_ids-1));
-	}
-
-	spin_unlock_irqrestore(&vnic->tx_lock, flags);
-}
-
-
-int netfront_accel_vi_poll(netfront_accel_vnic *vnic, int rx_packets)
-{
-	ef_event ev[ACCEL_VI_POLL_EVENTS];
-	int rx_remain = rx_packets, rc, events, i;
-#if NETFRONT_ACCEL_STATS
-	int n_evs_polled = 0, rx_evs_polled = 0, tx_evs_polled = 0;
-#endif
-	BUG_ON(rx_packets <= 0);
-
-	events = ef_eventq_poll(&vnic->vi, ev, 
-				min(rx_remain, ACCEL_VI_POLL_EVENTS));
-	i = 0;
-	NETFRONT_ACCEL_STATS_OP(n_evs_polled += events);
-
-	VPRINTK("%s: %d events\n", __FUNCTION__, events);
-
-	/* Loop over each event */
-	while (events) {
-		VPRINTK("%s: Event "EF_EVENT_FMT", index %lu\n", __FUNCTION__, 
-			EF_EVENT_PRI_ARG(ev[i]),	
-			(unsigned long)(vnic->vi.evq_state->evq_ptr));
-
-		if ((EF_EVENT_TYPE(ev[i]) == EF_EVENT_TYPE_RX) ||
-		    (EF_EVENT_TYPE(ev[i]) == EF_EVENT_TYPE_RX_DISCARD)) {
-			rc = netfront_accel_vi_poll_process_rx(vnic, &ev[i]);
-			rx_remain -= rc;
-			BUG_ON(rx_remain < 0);
-			NETFRONT_ACCEL_STATS_OP(rx_evs_polled++);
-		} else if (EF_EVENT_TYPE(ev[i]) == EF_EVENT_TYPE_TX) {
-			netfront_accel_vi_poll_process_tx(vnic, &ev[i]);
-			NETFRONT_ACCEL_STATS_OP(tx_evs_polled++);
-		} else if (EF_EVENT_TYPE(ev[i]) == 
-			   EF_EVENT_TYPE_RX_NO_DESC_TRUNC) {
-			DPRINTK("%s: RX_NO_DESC_TRUNC " EF_EVENT_FMT "\n",
-				__FUNCTION__, EF_EVENT_PRI_ARG(ev[i]));
-			discard_jumbo_state(vnic);
-			NETFRONT_ACCEL_STATS_OP(vnic->stats.rx_no_desc_trunc++);
-		} else {
-			EPRINTK("Unexpected event " EF_EVENT_FMT "\n", 
-				EF_EVENT_PRI_ARG(ev[i]));
-			NETFRONT_ACCEL_STATS_OP(vnic->stats.bad_event_count++);
-		}
-
-		i++;
-
-		/* Carry on round the loop if more events and more space */
-		if (i == events) {
-			if (rx_remain == 0)
-				break;
-
-			events = ef_eventq_poll(&vnic->vi, ev, 
-						min(rx_remain, 
-						    ACCEL_VI_POLL_EVENTS));
-			i = 0;
-			NETFRONT_ACCEL_STATS_OP(n_evs_polled += events);
-		}
-	}
-	
-#if NETFRONT_ACCEL_STATS
-	vnic->stats.event_count += n_evs_polled;
-	vnic->stats.event_count_since_irq += n_evs_polled;
-	if (n_evs_polled > vnic->stats.events_per_poll_max)
-		vnic->stats.events_per_poll_max = n_evs_polled;
-	if (rx_evs_polled > vnic->stats.events_per_poll_rx_max)
-		vnic->stats.events_per_poll_rx_max = rx_evs_polled;
-	if (tx_evs_polled > vnic->stats.events_per_poll_tx_max)
-		vnic->stats.events_per_poll_tx_max = tx_evs_polled;
-#endif
-
-	return rx_packets - rx_remain;
-}
-
-
-int netfront_accel_vi_enable_interrupts(netfront_accel_vnic *vnic)
-{
-	u32 sw_evq_ptr;
-
-	VPRINTK("%s: checking for event on %p\n", __FUNCTION__, &vnic->vi.evq_state);
-
-	BUG_ON(vnic == NULL);
-	BUG_ON(vnic->vi.evq_state == NULL);
-
-	/* Do a quick check for an event. */
-	if (ef_eventq_has_event(&vnic->vi)) {
-		VPRINTK("%s: found event\n",  __FUNCTION__);
-		return 0;
-	}
-
-	VPRINTK("evq_ptr=0x%08x	 evq_mask=0x%08x\n",
-		vnic->evq_state.evq_ptr, vnic->vi.evq_mask);
-  
-	/* Request a wakeup from the hardware. */
-	sw_evq_ptr = vnic->evq_state.evq_ptr & vnic->vi.evq_mask;
-
-	BUG_ON(vnic->hw.falcon.evq_rptr == NULL);
-
-	VPRINTK("Requesting wakeup at 0x%08x, rptr %p\n", sw_evq_ptr,
-		vnic->hw.falcon.evq_rptr);
-	*(volatile u32 *)(vnic->hw.falcon.evq_rptr) = (sw_evq_ptr >> 3);
-
-	return 1;
-}
diff -r 9566a4a50a43 drivers/xen/sfc_netfront/accel_xenbus.c
--- a/drivers/xen/sfc_netfront/accel_xenbus.c
+++ /dev/null
@@ -1,775 +0,0 @@
-/****************************************************************************
- * Solarflare driver for Xen network acceleration
- *
- * Copyright 2006-2008: Solarflare Communications Inc,
- *                      9501 Jeronimo Road, Suite 250,
- *                      Irvine, CA 92618, USA
- *
- * Maintained by Solarflare Communications <linux-xen-drivers@solarflare.com>
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 as published
- * by the Free Software Foundation, incorporated herein by reference.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
- ****************************************************************************
- */
-
-#include <linux/stddef.h>
-#include <linux/errno.h>
-
-#include <xen/xenbus.h>
-#include <xen/evtchn.h>
-#include <xen/gnttab.h>
-
-#include "accel.h"
-#include "accel_util.h"
-#include "accel_msg_iface.h"
-#include "accel_bufs.h"
-#include "accel_ssr.h"
-/* drivers/xen/netfront/netfront.h */
-#include "netfront.h"
-
-void netfront_accel_set_closing(netfront_accel_vnic *vnic) 
-{
-
-	vnic->frontend_state = XenbusStateClosing;
-	net_accel_update_state(vnic->dev, XenbusStateClosing);
-}
-	
-
-static void mac_address_change(struct xenbus_watch *watch,
-			       const char **vec, unsigned int len)
-{
-	netfront_accel_vnic *vnic;
-	struct xenbus_device *dev;
-	int rc;
-
-	DPRINTK("%s\n", __FUNCTION__);
-	
-	vnic = container_of(watch, netfront_accel_vnic, 
-				mac_address_watch);
-	dev = vnic->dev;
-
-	rc = net_accel_xen_net_read_mac(dev, vnic->mac);
-
-	if (rc != 0)
-		EPRINTK("%s: failed to read mac (%d)\n", __FUNCTION__, rc);
-}
-
-
-static int setup_mac_address_watch(struct xenbus_device *dev,
-				   netfront_accel_vnic *vnic)
-{
-	int err;
-
-	DPRINTK("Setting watch on %s/%s\n", dev->nodename, "mac");
-
-	err = xenbus_watch_path2(dev, dev->nodename, "mac", 
-				 &vnic->mac_address_watch, 
-				 mac_address_change);
-	if (err) {
-		EPRINTK("%s: Failed to register xenbus watch: %d\n",
-			__FUNCTION__, err);
-		goto fail;
-	}
-
-	return 0;
- fail:
-	vnic->mac_address_watch.node = NULL;
-	return err;
-}
-
-
-/* Grant access to some pages and publish through xenbus */
-static int make_named_grant(struct xenbus_device *dev, void *page, 
-			    const char *name, grant_ref_t *gnt_ref)
-{
-	struct xenbus_transaction tr;
-	int err;
-	grant_ref_t gnt;
-
-	gnt = net_accel_grant_page(dev, virt_to_mfn(page), 0);
-	if (gnt < 0)
-		return gnt;
-
-	do {
-		err = xenbus_transaction_start(&tr);
-		if (err != 0) {
-			EPRINTK("%s: transaction start failed %d\n",
-				__FUNCTION__, err);
-			return err;
-		}
-		err = xenbus_printf(tr, dev->nodename, name, "%d", gnt);
-		if (err != 0) {
-			EPRINTK("%s: xenbus_printf failed %d\n", __FUNCTION__,
-				err);
-			xenbus_transaction_end(tr, 1);
-			return err;
-		}
-		err = xenbus_transaction_end(tr, 0);
-	} while (err == -EAGAIN);
-	
-	if (err != 0) {
-		EPRINTK("%s: transaction end failed %d\n", __FUNCTION__, err);
-		return err;
-	}
-	
-	*gnt_ref = gnt;
-
-	return 0;
-}
-
-
-static int remove_named_grant(struct xenbus_device *dev,
-			      const char *name, grant_ref_t gnt_ref)
-{
-	struct xenbus_transaction tr;
-	int err;
-
-	net_accel_ungrant_page(gnt_ref);
-
-	do {
-		err = xenbus_transaction_start(&tr);
-		if (err != 0) {
-			EPRINTK("%s: transaction start failed %d\n",
-				__FUNCTION__, err);
-			return err;
-		}
-		err = xenbus_rm(tr, dev->nodename, name);
-		if (err != 0) {
-			EPRINTK("%s: xenbus_rm failed %d\n", __FUNCTION__,
-				err);
-			xenbus_transaction_end(tr, 1);
-			return err;
-		}
-		err = xenbus_transaction_end(tr, 0);
-	} while (err == -EAGAIN);
-	
-	if (err != 0) {
-		EPRINTK("%s: transaction end failed %d\n", __FUNCTION__, err);
-		return err;
-	}
-
-	return 0;
-}
-
-
-static 
-netfront_accel_vnic *netfront_accel_vnic_ctor(struct net_device *net_dev,
-					      struct xenbus_device *dev)
-{
-	struct netfront_info *np =
-		(struct netfront_info *)netdev_priv(net_dev);
-	netfront_accel_vnic *vnic;
-	int err;
-
-	/*
-	 * A bug in earlier versions of Xen accel plugin system meant
-	 * you could be probed twice for the same device on suspend
-	 * cancel.  Be tolerant of that.
-	 */ 
-	if (np->accel_priv != NULL)
-		return ERR_PTR(-EALREADY);
-
-	/* Alloc mem for state */
-	vnic = kzalloc(sizeof(netfront_accel_vnic), GFP_KERNEL);
-	if (vnic == NULL) {
-		EPRINTK("%s: no memory for vnic state\n", __FUNCTION__);
-		return ERR_PTR(-ENOMEM);
-	}
-
-	spin_lock_init(&vnic->tx_lock);
-
-	mutex_init(&vnic->vnic_mutex);
-	mutex_lock(&vnic->vnic_mutex);
-
-	/* Store so state can be retrieved from device */
-	BUG_ON(np->accel_priv != NULL);
-	np->accel_priv = vnic;
-	vnic->dev = dev;
-	vnic->net_dev = net_dev;
-	spin_lock_init(&vnic->irq_enabled_lock);
-	netfront_accel_ssr_init(&vnic->ssr_state);
-
-	init_waitqueue_head(&vnic->state_wait_queue);
-	vnic->backend_state = XenbusStateUnknown;
-	vnic->frontend_state = XenbusStateClosed;
-	vnic->removing = 0;
-	vnic->domU_state_is_setup = 0;
-	vnic->dom0_state_is_setup = 0;
-	vnic->poll_enabled = 0;
-	vnic->tx_enabled = 0;
-	vnic->tx_skb = NULL;
-
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,20)
-	INIT_WORK(&vnic->msg_from_bend, netfront_accel_msg_from_bend);
-#else
-	INIT_WORK(&vnic->msg_from_bend, netfront_accel_msg_from_bend, vnic);
-#endif
-
-	netfront_accel_debugfs_create(vnic);
-
-	mutex_unlock(&vnic->vnic_mutex);
-
-	err = net_accel_xen_net_read_mac(dev, vnic->mac);
-	if (err) 
-		goto fail_mac;
-
-	/* Setup a watch on the frontend's MAC address */
-	err = setup_mac_address_watch(dev, vnic);
-	if (err)
-		goto fail_mac;
-
-	return vnic;
-
-fail_mac:
-
-	mutex_lock(&vnic->vnic_mutex);
-
-	netfront_accel_debugfs_remove(vnic);
-
-	netfront_accel_ssr_fini(vnic, &vnic->ssr_state);
-
-	EPRINTK_ON(vnic->tx_skb != NULL);
-
-	vnic->frontend_state = XenbusStateUnknown;
-	net_accel_update_state(dev, XenbusStateUnknown);
-
-	mutex_unlock(&vnic->vnic_mutex);
-
-	np->accel_priv = NULL;
-	kfree(vnic);
-
-	return ERR_PTR(err);
-}
-
-
-static void netfront_accel_vnic_dtor(netfront_accel_vnic *vnic)
-{
-	struct net_device *net_dev = vnic->net_dev;
-	struct netfront_info *np = 
-		(struct netfront_info *)netdev_priv(net_dev);
-
-	/*
-	 * Now we don't hold the lock any more it is safe to remove
-	 * this watch and synchonrise with the completion of
-	 * watches
-	 */
-	DPRINTK("%s: unregistering xenbus mac watch\n", __FUNCTION__);
-	unregister_xenbus_watch(&vnic->mac_address_watch);
-	kfree(vnic->mac_address_watch.node);
-
-	flush_workqueue(netfront_accel_workqueue);
-
-	mutex_lock(&vnic->vnic_mutex);
-
-	netfront_accel_debugfs_remove(vnic);
-
-	netfront_accel_ssr_fini(vnic, &vnic->ssr_state);
-
-	EPRINTK_ON(vnic->tx_skb != NULL);
-
-	vnic->frontend_state = XenbusStateUnknown;
-	net_accel_update_state(vnic->dev, XenbusStateUnknown);
-
-	mutex_unlock(&vnic->vnic_mutex);
-
-	np->accel_priv = NULL;
-	kfree(vnic);
-}
-
-
-static int vnic_setup_domU_shared_state(struct xenbus_device *dev,
-					netfront_accel_vnic *vnic)
-{
-	struct xenbus_transaction tr;
-	int err;
-	int msgs_per_queue;
-
-
-	DPRINTK("Setting up domU shared state.\n");
-
-	msgs_per_queue = (PAGE_SIZE/2) / sizeof(struct net_accel_msg);
-
-	/* Allocate buffer state */
-	vnic->tx_bufs = netfront_accel_init_bufs(&vnic->tx_lock);
-	if (vnic->tx_bufs == NULL) {
-		err = -ENOMEM;
-		EPRINTK("%s: Failed to allocate tx buffers\n", __FUNCTION__);
-		goto fail_tx_bufs;
-	}
-
-	vnic->rx_bufs = netfront_accel_init_bufs(NULL);
-	if (vnic->rx_bufs == NULL) {
-		err = -ENOMEM;
-		EPRINTK("%s: Failed to allocate rx buffers\n", __FUNCTION__);
-		goto fail_rx_bufs;
-	}
-
-	/* 
-	 * This allocates two pages, one for the shared page and one
-	 * for the message queue.
-	 */
-	vnic->shared_page = (struct net_accel_shared_page *)
-		__get_free_pages(GFP_KERNEL, 1);
-	if (vnic->shared_page == NULL) {
-		EPRINTK("%s: no memory for shared pages\n", __FUNCTION__);
-		err = -ENOMEM;
-		goto fail_shared_page;
-	}
-
-	net_accel_msg_init_queue
-		(&vnic->from_dom0, &vnic->shared_page->queue0, 
-		 (struct net_accel_msg *)((u8*)vnic->shared_page + PAGE_SIZE),
-		 msgs_per_queue);
-
-	net_accel_msg_init_queue
-		(&vnic->to_dom0, &vnic->shared_page->queue1,
-		 (struct net_accel_msg *)((u8*)vnic->shared_page +
-					  (3 * PAGE_SIZE / 2)),
-		 msgs_per_queue);
-	
-	vnic->msg_state = NETFRONT_ACCEL_MSG_NONE;
-
-	err = make_named_grant(dev, vnic->shared_page, "accel-ctrl-page",
-			       &vnic->ctrl_page_gnt);
-	if (err) {
-		EPRINTK("couldn't make ctrl-page named grant\n");
-		goto fail_ctrl_page_grant;
-	}
-
-	err = make_named_grant(dev, (u8*)vnic->shared_page + PAGE_SIZE,
-			       "accel-msg-page", &vnic->msg_page_gnt);
-	if (err) {
-		EPRINTK("couldn't make msg-page named grant\n");
-		goto fail_msg_page_grant;
-	}
-
-	/* Create xenbus msg event channel */
-	err = bind_listening_port_to_irqhandler
-		(dev->otherend_id, netfront_accel_msg_channel_irq_from_bend,
-		 IRQF_SAMPLE_RANDOM, "vnicctrl", vnic);
-	if (err < 0) {
-		EPRINTK("Couldn't bind msg event channel\n");
-		goto fail_msg_irq;
-	}
-	vnic->msg_channel_irq = err;
-	vnic->msg_channel = irq_to_evtchn_port(vnic->msg_channel_irq);
-	
-	/* Create xenbus net event channel */
-	err = bind_listening_port_to_irqhandler
-		(dev->otherend_id, netfront_accel_net_channel_irq_from_bend,
-		 IRQF_SAMPLE_RANDOM, "vnicfront", vnic);
-	if (err < 0) {
-		EPRINTK("Couldn't bind net event channel\n");
-		goto fail_net_irq;
-	}
-	vnic->net_channel_irq = err;
-	vnic->net_channel = irq_to_evtchn_port(vnic->net_channel_irq);
-	/* Want to ensure we don't get interrupts before we're ready */
-	netfront_accel_disable_net_interrupts(vnic);
-
-	DPRINTK("otherend %d has msg ch %u (%u) and net ch %u (%u)\n",
-		dev->otherend_id, vnic->msg_channel, vnic->msg_channel_irq, 
-		vnic->net_channel, vnic->net_channel_irq);
-
-	do {
-		err = xenbus_transaction_start(&tr);
-		if (err != 0) {
-			EPRINTK("%s: Transaction start failed %d\n",
-				__FUNCTION__, err);
-			goto fail_transaction;
-		}
-
-		err = xenbus_printf(tr, dev->nodename, "accel-msg-channel",
-				    "%u", vnic->msg_channel);
-		if (err != 0) {
-			EPRINTK("%s: event channel xenbus write failed %d\n",
-				__FUNCTION__, err);
-			xenbus_transaction_end(tr, 1);
-			goto fail_transaction;
-		}
-
-		err = xenbus_printf(tr, dev->nodename, "accel-net-channel",
-				    "%u", vnic->net_channel);
-		if (err != 0) {
-			EPRINTK("%s: net channel xenbus write failed %d\n",
-				__FUNCTION__, err);
-			xenbus_transaction_end(tr, 1);
-			goto fail_transaction;
-		}
-
-		err = xenbus_transaction_end(tr, 0);
-	} while (err == -EAGAIN);
-
-	if (err != 0) {
-		EPRINTK("%s: Transaction end failed %d\n", __FUNCTION__, err);
-		goto fail_transaction;
-	}
-
-	DPRINTK("Completed setting up domU shared state\n");
-
-	return 0;
-
-fail_transaction:
-
-	unbind_from_irqhandler(vnic->net_channel_irq, vnic);
-fail_net_irq:
-
-	unbind_from_irqhandler(vnic->msg_channel_irq, vnic);
-fail_msg_irq:
-
-	remove_named_grant(dev, "accel-ctrl-page", vnic->ctrl_page_gnt);
-fail_msg_page_grant:
-
-	remove_named_grant(dev, "accel-msg-page", vnic->msg_page_gnt);
-fail_ctrl_page_grant:
-
-	free_pages((unsigned long)vnic->shared_page, 1);
-	vnic->shared_page = NULL;
-fail_shared_page:
-
-	netfront_accel_fini_bufs(vnic->rx_bufs);
-fail_rx_bufs:
-
-	netfront_accel_fini_bufs(vnic->tx_bufs);
-fail_tx_bufs:
-
-	/* Undo the memory allocation created when we got the HELLO */
-	netfront_accel_free_buffer_mem(&vnic->bufpages,
-				       vnic->rx_bufs,
-				       vnic->tx_bufs);
-
-	DPRINTK("Failed to setup domU shared state with code %d\n", err);
-
-	return err;
-}
-
-
-static void vnic_remove_domU_shared_state(struct xenbus_device *dev, 
-					  netfront_accel_vnic *vnic)
-{
-	struct xenbus_transaction tr;
-	
-	/*
-	 * Don't remove any watches because we currently hold the
-	 * mutex and the watches take the mutex.
-	 */
-
-	DPRINTK("%s: removing event channel irq handlers %d %d\n",
-		__FUNCTION__, vnic->net_channel_irq, vnic->msg_channel_irq);
-	do {
-		if (xenbus_transaction_start(&tr) != 0)
-			break;
-		xenbus_rm(tr, dev->nodename, "accel-msg-channel");
-		xenbus_rm(tr, dev->nodename, "accel-net-channel");
-	} while (xenbus_transaction_end(tr, 0) == -EAGAIN);
-
-	unbind_from_irqhandler(vnic->net_channel_irq, vnic);
-	unbind_from_irqhandler(vnic->msg_channel_irq, vnic);
-
-	/* ungrant pages for msg channel */
-	remove_named_grant(dev, "accel-ctrl-page", vnic->ctrl_page_gnt);
-	remove_named_grant(dev, "accel-msg-page", vnic->msg_page_gnt);
-	free_pages((unsigned long)vnic->shared_page, 1);
-	vnic->shared_page = NULL;
-
-	/* ungrant pages for buffers, and free buffer memory */
-	netfront_accel_free_buffer_mem(&vnic->bufpages,
-				       vnic->rx_bufs,
-				       vnic->tx_bufs);
-	netfront_accel_fini_bufs(vnic->rx_bufs);
-	netfront_accel_fini_bufs(vnic->tx_bufs);
-}
-
-
-static void vnic_setup_dom0_shared_state(struct xenbus_device *dev,
-					netfront_accel_vnic *vnic)
-{
-	DPRINTK("Setting up dom0 shared state\n");
-
-	netfront_accel_vi_ctor(vnic);
-
-	/*
-	 * Message processing will be enabled when this function
-	 * returns, but we might have missed an interrupt.  Schedule a
-	 * check just in case.
-	 */
-	queue_work(netfront_accel_workqueue, &vnic->msg_from_bend);
-}
-
-
-static void vnic_remove_dom0_shared_state(struct xenbus_device *dev,
-					  netfront_accel_vnic *vnic)
-{
-	DPRINTK("Removing dom0 shared state\n");
-
-	vnic_stop_fastpath(vnic);
-
-	netfront_accel_vi_dtor(vnic);
-}
-
-
-/*************************************************************************/
-
-/*
- * The following code handles accelstate changes between the frontend
- * and the backend.  In response to transitions, calls the following
- * functions in matching pairs:
- *
- *   vnic_setup_domU_shared_state
- *   vnic_remove_domU_shared_state
- *
- *   vnic_setup_dom0_shared_state
- *   vnic_remove_dom0_shared_state
- *
- * Valid state transitions for DomU are as follows:
- *
- * Closed->Init       on probe or in response to Init from dom0
- *
- * Init->Connected    in response to Init from dom0
- * Init->Closing      on error providing dom0 is in Init
- * Init->Closed       on remove or in response to Closing from dom0
- *
- * Connected->Closing on error/remove
- * Connected->Closed  in response to Closing from dom0
- *
- * Closing->Closed    in response to Closing from dom0
- *
- */
-
-
-/* Function to deal with Xenbus accel state change in backend */
-static void netfront_accel_backend_accel_changed(netfront_accel_vnic *vnic,
-						 XenbusState backend_state)
-{
-	struct xenbus_device *dev = vnic->dev;
-	XenbusState frontend_state;
-	int state;
-
-	DPRINTK("%s: changing from %s to %s. nodename %s, otherend %s\n",
-		__FUNCTION__, xenbus_strstate(vnic->backend_state),
-		xenbus_strstate(backend_state), dev->nodename, dev->otherend);
-
-	/*
-	 * Ignore duplicate state changes.  This can happen if the
-	 * backend changes state twice in quick succession and the
-	 * first watch fires in the frontend after the second
-	 * transition has completed.
-	 */
-	if (vnic->backend_state == backend_state)
-		return;
-
-	vnic->backend_state = backend_state;
-	frontend_state = vnic->frontend_state;
-
-	switch (backend_state) {
-	case XenbusStateInitialising:
-		/*
-		 * It's possible for us to miss the closed state from
-		 * dom0, so do the work here.
-		 */
-		if (vnic->domU_state_is_setup) {
-			vnic_remove_domU_shared_state(dev, vnic);
-			vnic->domU_state_is_setup = 0;
-		}
-
-		if (frontend_state != XenbusStateInitialising) {
-			/* Make sure the backend doesn't go away. */
-			frontend_state = XenbusStateInitialising;
-			net_accel_update_state(dev, frontend_state);
-			xenbus_scanf(XBT_NIL, dev->otherend, "accelstate", "%d", &state);
-			backend_state = (XenbusState)state;
-			if (backend_state != XenbusStateInitialising)
-				break;
-		}
-
-		/* Start the new connection. */
-		if (!vnic->removing) {
-			BUG_ON(vnic->domU_state_is_setup);
-			if (vnic_setup_domU_shared_state(dev, vnic) == 0) {
-				vnic->domU_state_is_setup = 1;
-				frontend_state = XenbusStateConnected;
-			} else
-				frontend_state = XenbusStateClosing;
-		}
-		break;
-	case XenbusStateConnected:
-		if (vnic->domU_state_is_setup &&
-		    !vnic->dom0_state_is_setup) {
-			vnic_setup_dom0_shared_state(dev, vnic);
-			vnic->dom0_state_is_setup = 1;
-		}
-		break;
-	default:
-	case XenbusStateClosing:
-		if (vnic->dom0_state_is_setup) {
-			vnic_remove_dom0_shared_state(dev, vnic);
-			vnic->dom0_state_is_setup = 0;
-		}
-		frontend_state = XenbusStateClosed;
-		break;
-	case XenbusStateUnknown:
-	case XenbusStateClosed:
-		if (vnic->domU_state_is_setup) {
-			vnic_remove_domU_shared_state(dev, vnic);
-			vnic->domU_state_is_setup = 0;
-		}
-		break;
-	}
-
-	if (frontend_state != vnic->frontend_state) {
-		DPRINTK("Switching from state %s (%d) to %s (%d)\n",
-			xenbus_strstate(vnic->frontend_state),
-			vnic->frontend_state,
-			xenbus_strstate(frontend_state), frontend_state);
-		vnic->frontend_state = frontend_state;
-		net_accel_update_state(dev, frontend_state);
-	}
-
-	wake_up(&vnic->state_wait_queue);
-}
-
-
-static void backend_accel_state_change(struct xenbus_watch *watch,
-				       const char **vec, unsigned int len)
-{
-	int state;
-	netfront_accel_vnic *vnic;
-	struct xenbus_device *dev;
-
-	DPRINTK("%s\n", __FUNCTION__);
-
-	vnic = container_of(watch, struct netfront_accel_vnic,
-				backend_accel_watch);
-
-	mutex_lock(&vnic->vnic_mutex);
-
-	dev = vnic->dev;
-
-	state = (int)XenbusStateUnknown;
-	xenbus_scanf(XBT_NIL, dev->otherend, "accelstate", "%d", &state);
-	netfront_accel_backend_accel_changed(vnic, state);
-
-	mutex_unlock(&vnic->vnic_mutex);
-}
-
-
-static int setup_dom0_accel_watch(struct xenbus_device *dev,
-				  netfront_accel_vnic *vnic)
-{
-	int err;
-
-	DPRINTK("Setting watch on %s/%s\n", dev->otherend, "accelstate");
-
-	err = xenbus_watch_path2(dev, dev->otherend, "accelstate", 
-				 &vnic->backend_accel_watch, 
-				 backend_accel_state_change);
-	if (err) {
-		EPRINTK("%s: Failed to register xenbus watch: %d\n",
-			__FUNCTION__, err);
-		goto fail;
-	}
-	return 0;
- fail:
-	vnic->backend_accel_watch.node = NULL;
-	return err;
-}
-
-
-int netfront_accel_probe(struct net_device *net_dev, struct xenbus_device *dev)
-{
-	netfront_accel_vnic *vnic;
-	int err;
-
-	DPRINTK("Probe passed device %s\n", dev->nodename);
-
-	vnic = netfront_accel_vnic_ctor(net_dev, dev);
-	if (IS_ERR(vnic))
-		return PTR_ERR(vnic);
-
-	/*
-	 * Setup a watch on the backend accel state.  This sets things
-	 * going.
-	 */
-	err = setup_dom0_accel_watch(dev, vnic);
-	if (err) {
-		netfront_accel_vnic_dtor(vnic);
-		EPRINTK("%s: probe failed with code %d\n", __FUNCTION__, err);
-		return err;
-	}
-
-	/*
-	 * Indicate to the other end that we're ready to start unless
-	 * the watch has already fired.
-	 */
-	mutex_lock(&vnic->vnic_mutex);
-	VPRINTK("setup success, updating accelstate\n");
-	if (vnic->frontend_state == XenbusStateClosed) {
-		vnic->frontend_state = XenbusStateInitialising;
-		net_accel_update_state(dev, XenbusStateInitialising);
-	}
-	mutex_unlock(&vnic->vnic_mutex);
-
-	DPRINTK("Probe done device %s\n", dev->nodename);
-
-	return 0;
-}
-
-
-int netfront_accel_remove(struct xenbus_device *dev)
-{
-	struct netfront_info *np = dev_get_drvdata(&dev->dev);
-	netfront_accel_vnic *vnic = (netfront_accel_vnic *)np->accel_priv;
-
-	DPRINTK("%s %s\n", __FUNCTION__, dev->nodename);
-
-	BUG_ON(vnic == NULL);
-
-	mutex_lock(&vnic->vnic_mutex);
-
-	/* Reject any attempts to connect. */
-	vnic->removing = 1;
-
-	/* Close any existing connection. */
-	if (vnic->frontend_state == XenbusStateConnected) {
-		vnic->frontend_state = XenbusStateClosing;
-		net_accel_update_state(dev, XenbusStateClosing);
-	}
-
-	mutex_unlock(&vnic->vnic_mutex);
-
-	DPRINTK("%s waiting for release of %s\n", __FUNCTION__, dev->nodename);
-
-	/*
-	 * Wait for the xenbus watch to release the shared resources.
-	 * This indicates that dom0 has made the transition
-	 * Closing->Closed or that dom0 was in Closed or Init and no
-	 * resources were mapped.
-	 */
-	wait_event(vnic->state_wait_queue,
-		   !vnic->domU_state_is_setup);
-
-	/*
-	 * Now we don't need this watch anymore it is safe to remove
-	 * it (and so synchronise with it completing if outstanding)
-	 */
-	DPRINTK("%s: unregistering xenbus accel watch\n",
-		__FUNCTION__);
-	unregister_xenbus_watch(&vnic->backend_accel_watch);
-	kfree(vnic->backend_accel_watch.node);
-
-	netfront_accel_vnic_dtor(vnic);
-
-	DPRINTK("%s done %s\n", __FUNCTION__, dev->nodename);
-
-	return 0;
-}
diff -r 9566a4a50a43 drivers/xen/sfc_netfront/ef_vi_falcon.h
--- a/drivers/xen/sfc_netfront/ef_vi_falcon.h
+++ /dev/null
@@ -1,172 +0,0 @@
-/****************************************************************************
- * Copyright 2002-2005: Level 5 Networks Inc.
- * Copyright 2005-2008: Solarflare Communications Inc,
- *                      9501 Jeronimo Road, Suite 250,
- *                      Irvine, CA 92618, USA
- *
- * Maintained by Solarflare Communications
- *  <linux-xen-drivers@solarflare.com>
- *  <onload-dev@solarflare.com>
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 as published
- * by the Free Software Foundation, incorporated herein by reference.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
- ****************************************************************************
- */
-
-/*
- * \author  slp
- *  \brief  Falcon specific definitions
- *   \date  2004/08
- */
-
-#ifndef __EF_VI_FALCON_H__
-#define __EF_VI_FALCON_H__    
-
-#define EFHW_4K		0x00001000u
-#define EFHW_8K		0x00002000u
-
-/* include the autogenerated register definitions */
-
-#include "ef_vi_falcon_core.h"
-#include "ef_vi_falcon_desc.h"
-#include "ef_vi_falcon_event.h"
-
-
-/*----------------------------------------------------------------------------
- *
- * Helpers to turn bit shifts into dword shifts and check that the bit fields 
- * haven't overflown the dword etc. Aim is to preserve consistency with the 
- * autogenerated headers - once stable we could hard code.
- *
- *---------------------------------------------------------------------------*/
-
-/* mask constructors */
-#define __FALCON_MASK(WIDTH,T)  ((((T)1) << (WIDTH)) - 1)
-#define __EFVI_MASK32(WIDTH)  __FALCON_MASK((WIDTH),uint32_t)
-#define __EFVI_MASK64(WIDTH)  __FALCON_MASK((WIDTH),uint64_t)
-
-#define __EFVI_FALCON_MASKFIELD32(LBN, WIDTH)   ((uint32_t)  \
-                             (__EFVI_MASK32(WIDTH) << (LBN)))
-
-/* constructors for fields which span the first and second dwords */
-#define __LW(LBN) (32 - LBN)
-#define LOW(v, LBN, WIDTH)   ((uint32_t)  \
-                               (((v) & __EFVI_MASK64(__LW((LBN)))) << (LBN)))
-#define HIGH(v, LBN, WIDTH)  ((uint32_t)(((v) >> __LW((LBN))) & \
-                                       __EFVI_MASK64((WIDTH - __LW((LBN))))))
-/* constructors for fields within the second dword */
-#define __DW2(LBN) 	  ((LBN) - 32)
-
-/* constructors for fields which span the second and third dwords */
-#define __LW2(LBN) (64 - LBN)
-#define LOW2(v, LBN, WIDTH) ((uint32_t) \
-                       (((v) & __EFVI_MASK64(__LW2((LBN)))) << ((LBN) - 32)))
-#define HIGH2(v, LBN, WIDTH)  ((uint32_t) \
-             (((v) >> __LW2((LBN))) & __EFVI_MASK64((WIDTH - __LW2((LBN))))))
-
-/* constructors for fields within the third dword */
-#define __DW3(LBN) 	  ((LBN) - 64)
-
-				
-/* constructors for fields which span the third and fourth dwords */
-#define __LW3(LBN) (96 - LBN)
-#define LOW3(v, LBN, WIDTH)   ((uint32_t)    \
-              (((v) & __EFVI_MASK64(__LW3((LBN)))) << ((LBN) - 64)))
-#define HIGH3(v, LBN, WIDTH)  ((unit32_t)    \
-             (((v) >> __LW3((LBN))) & __EFVI_MASK64((WIDTH - __LW3((LBN))))))
-
-/* constructors for fields within the fourth dword */
-#define __DW4(LBN) 	  ((LBN) - 96)
-
-/* checks that the autogenerated headers our consistent with our model */
-#define WIDTHCHCK(a, b) ef_assert((a) == (b))
-#define RANGECHCK(v, WIDTH) \
-                ef_assert(((uint64_t)(v) & ~(__EFVI_MASK64((WIDTH)))) == 0)
-
-/* fields within the first dword */
-#define DWCHCK(LBN, WIDTH) ef_assert(((LBN) >= 0) &&(((LBN)+(WIDTH)) <= 32))
-
-/* fields which span the first and second dwords */
-#define LWCHK(LBN, WIDTH)  ef_assert(WIDTH >= __LW(LBN))
-
-/*----------------------------------------------------------------------------
- *
- * Buffer virtual addresses (4K buffers) 
- *
- *---------------------------------------------------------------------------*/
-
-/* Form a buffer virtual address from buffer ID and offset.  If the offset
-** is larger than the buffer size, then the buffer indexed will be
-** calculated appropriately.  It is the responsibility of the caller to
-** ensure that they have valid buffers programmed at that address.
-*/
-#define EFVI_FALCON_VADDR_4K_S   	(12)	     
-#define EFVI_FALCON_VADDR_M       0xfffff		/* post shift mask  */
-
-
-#define EFVI_FALCON_BUFFER_4K_ADDR(id,off)      \
-  (((id) << EFVI_FALCON_VADDR_4K_S) + (off))
-
-#define EFVI_FALCON_BUFFER_4K_PAGE(vaddr)                       \
-  (((vaddr) >> EFVI_FALCON_VADDR_4K_S) & EFVI_FALCON_VADDR_M)
-
-#define EFVI_FALCON_BUFFER_4K_OFF(vaddr)                \
-  ((vaddr) & __EFVI_MASK32(EFVI_FALCON_VADDR_4K_S))
-
-
-/*----------------------------------------------------------------------------
- *
- * Masks
- *
- *---------------------------------------------------------------------------*/
-
-#define EFVI_FALCON_CLOCK_ASIC_HZ    (125000)
-#define EFVI_FALCON_CLOCK_FPGA_HZ    (62500)
-#define EFVI_FALCON_CLOCK_HZ         EFVI_FALCON_CLOCK_ASIC_HZ
-
-
-/*----------------------------------------------------------------------------
- *
- * Timers
- *
- *---------------------------------------------------------------------------*/
-
-/* Event-Queue Timer granularity - measured in us 
-   Given by: 4096 * 3 cycle * clock period */
-
-#define EFVI_FALCON_EVQTIMER_PERIOD_US   ((4096 * 3 * 1000) / EFVI_FALCON_CLOCK_HZ)
-
-/* mode bits */
-#define EFVI_FALCON_TIMER_MODE_DIS     0     /* disabled */
-#define EFVI_FALCON_TIMER_MODE_RUN     1     /* started counting right away */
-#define EFVI_FALCON_TIMER_MODE_HOLD    2     /* trigger mode (user queues) */
-
-#define EFVI_FALCON_EVQTIMER_HOLD     (EFVI_FALCON_TIMER_MODE_HOLD << TIMER_MODE_LBN)
-#define EFVI_FALCON_EVQTIMER_RUN      (EFVI_FALCON_TIMER_MODE_RUN  << TIMER_MODE_LBN)
-#define EFVI_FALCON_EVQTIMER_DISABLE  (EFVI_FALCON_TIMER_MODE_DIS  << TIMER_MODE_LBN) 
-
-
-/* ---- ef_vi_event helpers --- */
-
-#define EFVI_FALCON_EVENT_CODE(evp) \
-       ((evp)->u64 & EFVI_FALCON_EVENT_CODE_MASK)
-
-#define EFVI_FALCON_EVENT_SW_DATA_MASK    0x0000ffff
-
-#define __EFVI_FALCON_OPEN_MASK(WIDTH)  ((((uint64_t)1) << (WIDTH)) - 1)
-
-#define EFVI_FALCON_EVENT_CODE_MASK \
-           (__EFVI_FALCON_OPEN_MASK(EV_CODE_WIDTH) << EV_CODE_LBN)
-
-
-#endif  /* __EF_VI_FALCON_H__ */
diff -r 9566a4a50a43 drivers/xen/sfc_netfront/ef_vi_falcon_core.h
--- a/drivers/xen/sfc_netfront/ef_vi_falcon_core.h
+++ /dev/null
@@ -1,1075 +0,0 @@
-
-#define  EFVI_FALCON_EXTENDED_P_BAR 1
-
-//////////////---- Bus Interface Unit Registers C Header ----//////////////
-#define IOM_IND_ADR_REG_OFST 0x0 // IO-mapped indirect access address register
-  #define IOM_AUTO_ADR_INC_EN_LBN 16
-  #define IOM_AUTO_ADR_INC_EN_WIDTH 1
-  #define IOM_IND_ADR_LBN 0
-  #define IOM_IND_ADR_WIDTH 16
-#define IOM_IND_DAT_REG_OFST 0x4 // IO-mapped indirect access data register
-  #define IOM_IND_DAT_LBN 0
-  #define IOM_IND_DAT_WIDTH 32
-#define ADR_REGION_REG_KER_OFST 0x0 // Address region register
-#define ADR_REGION_REG_OFST 0x0 // Address region register
-  #define ADR_REGION3_LBN 96
-  #define ADR_REGION3_WIDTH 18
-  #define ADR_REGION2_LBN 64
-  #define ADR_REGION2_WIDTH 18
-  #define ADR_REGION1_LBN 32
-  #define ADR_REGION1_WIDTH 18
-  #define ADR_REGION0_LBN 0
-  #define ADR_REGION0_WIDTH 18
-#define INT_EN_REG_KER_OFST 0x10 // Kernel driver Interrupt enable register
-  #define KER_INT_CHAR_LBN 4
-  #define KER_INT_CHAR_WIDTH 1
-  #define KER_INT_KER_LBN 3
-  #define KER_INT_KER_WIDTH 1
-  #define ILL_ADR_ERR_INT_EN_KER_LBN 2
-  #define ILL_ADR_ERR_INT_EN_KER_WIDTH 1
-  #define SRM_PERR_INT_EN_KER_LBN 1
-  #define SRM_PERR_INT_EN_KER_WIDTH 1
-  #define DRV_INT_EN_KER_LBN 0
-  #define DRV_INT_EN_KER_WIDTH 1
-#define INT_EN_REG_CHAR_OFST 0x20 // Char Driver interrupt enable register
-  #define CHAR_INT_CHAR_LBN 4
-  #define CHAR_INT_CHAR_WIDTH 1
-  #define CHAR_INT_KER_LBN 3
-  #define CHAR_INT_KER_WIDTH 1
-  #define ILL_ADR_ERR_INT_EN_CHAR_LBN 2
-  #define ILL_ADR_ERR_INT_EN_CHAR_WIDTH 1
-  #define SRM_PERR_INT_EN_CHAR_LBN 1
-  #define SRM_PERR_INT_EN_CHAR_WIDTH 1
-  #define DRV_INT_EN_CHAR_LBN 0
-  #define DRV_INT_EN_CHAR_WIDTH 1
-#define INT_ADR_REG_KER_OFST 0x30 // Interrupt host address for Kernel driver
-  #define INT_ADR_KER_LBN 0
-  #define INT_ADR_KER_WIDTH 64
-  #define DRV_INT_KER_LBN 32
-  #define DRV_INT_KER_WIDTH 1
-  #define EV_FF_HALF_INT_KER_LBN 3
-  #define EV_FF_HALF_INT_KER_WIDTH 1
-  #define EV_FF_FULL_INT_KER_LBN 2
-  #define EV_FF_FULL_INT_KER_WIDTH 1
-  #define ILL_ADR_ERR_INT_KER_LBN 1
-  #define ILL_ADR_ERR_INT_KER_WIDTH 1
-  #define SRAM_PERR_INT_KER_LBN 0
-  #define SRAM_PERR_INT_KER_WIDTH 1
-#define INT_ADR_REG_CHAR_OFST 0x40 // Interrupt host address for Char driver
-  #define INT_ADR_CHAR_LBN 0
-  #define INT_ADR_CHAR_WIDTH 64
-  #define DRV_INT_CHAR_LBN 32
-  #define DRV_INT_CHAR_WIDTH 1
-  #define EV_FF_HALF_INT_CHAR_LBN 3
-  #define EV_FF_HALF_INT_CHAR_WIDTH 1
-  #define EV_FF_FULL_INT_CHAR_LBN 2
-  #define EV_FF_FULL_INT_CHAR_WIDTH 1
-  #define ILL_ADR_ERR_INT_CHAR_LBN 1
-  #define ILL_ADR_ERR_INT_CHAR_WIDTH 1
-  #define SRAM_PERR_INT_CHAR_LBN 0
-  #define SRAM_PERR_INT_CHAR_WIDTH 1
-#define INT_ISR0_B0_OFST 0x90 // B0 only
-#define INT_ISR1_B0_OFST 0xA0
-#define INT_ACK_REG_KER_A1_OFST 0x50 // Kernel interrupt acknowledge register
-  #define RESERVED_LBN 0
-  #define RESERVED_WIDTH 32
-#define INT_ACK_REG_CHAR_A1_OFST 0x60 // CHAR interrupt acknowledge register
-  #define RESERVED_LBN 0
-  #define RESERVED_WIDTH 32
-//////////////---- Global CSR Registers C Header ----//////////////
-#define STRAP_REG_KER_OFST 0x200 // ASIC strap status register
-#define STRAP_REG_OFST 0x200 // ASIC strap status register
-  #define ONCHIP_SRAM_LBN 16
-  #define ONCHIP_SRAM_WIDTH 0
-  #define STRAP_ISCSI_EN_LBN 3
-  #define STRAP_ISCSI_EN_WIDTH 1
-  #define STRAP_PINS_LBN 0
-  #define STRAP_PINS_WIDTH 3
-#define GPIO_CTL_REG_KER_OFST 0x210 // GPIO control register
-#define GPIO_CTL_REG_OFST 0x210 // GPIO control register
-  #define GPIO_OEN_LBN 24
-  #define GPIO_OEN_WIDTH 4
-  #define GPIO_OUT_LBN 16
-  #define GPIO_OUT_WIDTH 4
-  #define GPIO_IN_LBN 8
-  #define GPIO_IN_WIDTH 4
-  #define GPIO_PWRUP_VALUE_LBN 0
-  #define GPIO_PWRUP_VALUE_WIDTH 4
-#define GLB_CTL_REG_KER_OFST 0x220 // Global control register
-#define GLB_CTL_REG_OFST 0x220 // Global control register
-  #define SWRST_LBN 0
-  #define SWRST_WIDTH 1
-#define FATAL_INTR_REG_KER_OFST 0x230 // Fatal interrupt register for Kernel
-  #define PCI_BUSERR_INT_KER_EN_LBN 43
-  #define PCI_BUSERR_INT_KER_EN_WIDTH 1
-  #define SRAM_OOB_INT_KER_EN_LBN 42
-  #define SRAM_OOB_INT_KER_EN_WIDTH 1
-  #define BUFID_OOB_INT_KER_EN_LBN 41
-  #define BUFID_OOB_INT_KER_EN_WIDTH 1
-  #define MEM_PERR_INT_KER_EN_LBN 40
-  #define MEM_PERR_INT_KER_EN_WIDTH 1
-  #define RBUF_OWN_INT_KER_EN_LBN 39
-  #define RBUF_OWN_INT_KER_EN_WIDTH 1
-  #define TBUF_OWN_INT_KER_EN_LBN 38
-  #define TBUF_OWN_INT_KER_EN_WIDTH 1
-  #define RDESCQ_OWN_INT_KER_EN_LBN 37
-  #define RDESCQ_OWN_INT_KER_EN_WIDTH 1
-  #define TDESCQ_OWN_INT_KER_EN_LBN 36
-  #define TDESCQ_OWN_INT_KER_EN_WIDTH 1
-  #define EVQ_OWN_INT_KER_EN_LBN 35
-  #define EVQ_OWN_INT_KER_EN_WIDTH 1
-  #define EVFF_OFLO_INT_KER_EN_LBN 34
-  #define EVFF_OFLO_INT_KER_EN_WIDTH 1
-  #define ILL_ADR_INT_KER_EN_LBN 33
-  #define ILL_ADR_INT_KER_EN_WIDTH 1
-  #define SRM_PERR_INT_KER_EN_LBN 32
-  #define SRM_PERR_INT_KER_EN_WIDTH 1
-  #define PCI_BUSERR_INT_KER_LBN 11
-  #define PCI_BUSERR_INT_KER_WIDTH 1
-  #define SRAM_OOB_INT_KER_LBN 10
-  #define SRAM_OOB_INT_KER_WIDTH 1
-  #define BUFID_OOB_INT_KER_LBN 9
-  #define BUFID_OOB_INT_KER_WIDTH 1
-  #define MEM_PERR_INT_KER_LBN 8
-  #define MEM_PERR_INT_KER_WIDTH 1
-  #define RBUF_OWN_INT_KER_LBN 7
-  #define RBUF_OWN_INT_KER_WIDTH 1
-  #define TBUF_OWN_INT_KER_LBN 6
-  #define TBUF_OWN_INT_KER_WIDTH 1
-  #define RDESCQ_OWN_INT_KER_LBN 5
-  #define RDESCQ_OWN_INT_KER_WIDTH 1
-  #define TDESCQ_OWN_INT_KER_LBN 4
-  #define TDESCQ_OWN_INT_KER_WIDTH 1
-  #define EVQ_OWN_INT_KER_LBN 3
-  #define EVQ_OWN_INT_KER_WIDTH 1
-  #define EVFF_OFLO_INT_KER_LBN 2
-  #define EVFF_OFLO_INT_KER_WIDTH 1
-  #define ILL_ADR_INT_KER_LBN 1
-  #define ILL_ADR_INT_KER_WIDTH 1
-  #define SRM_PERR_INT_KER_LBN 0
-  #define SRM_PERR_INT_KER_WIDTH 1
-#define FATAL_INTR_REG_OFST 0x240 // Fatal interrupt register for Char
-  #define PCI_BUSERR_INT_CHAR_EN_LBN 43
-  #define PCI_BUSERR_INT_CHAR_EN_WIDTH 1
-  #define SRAM_OOB_INT_CHAR_EN_LBN 42
-  #define SRAM_OOB_INT_CHAR_EN_WIDTH 1
-  #define BUFID_OOB_INT_CHAR_EN_LBN 41
-  #define BUFID_OOB_INT_CHAR_EN_WIDTH 1
-  #define MEM_PERR_INT_CHAR_EN_LBN 40
-  #define MEM_PERR_INT_CHAR_EN_WIDTH 1
-  #define RBUF_OWN_INT_CHAR_EN_LBN 39
-  #define RBUF_OWN_INT_CHAR_EN_WIDTH 1
-  #define TBUF_OWN_INT_CHAR_EN_LBN 38
-  #define TBUF_OWN_INT_CHAR_EN_WIDTH 1
-  #define RDESCQ_OWN_INT_CHAR_EN_LBN 37
-  #define RDESCQ_OWN_INT_CHAR_EN_WIDTH 1
-  #define TDESCQ_OWN_INT_CHAR_EN_LBN 36
-  #define TDESCQ_OWN_INT_CHAR_EN_WIDTH 1
-  #define EVQ_OWN_INT_CHAR_EN_LBN 35
-  #define EVQ_OWN_INT_CHAR_EN_WIDTH 1
-  #define EVFF_OFLO_INT_CHAR_EN_LBN 34
-  #define EVFF_OFLO_INT_CHAR_EN_WIDTH 1
-  #define ILL_ADR_INT_CHAR_EN_LBN 33
-  #define ILL_ADR_INT_CHAR_EN_WIDTH 1
-  #define SRM_PERR_INT_CHAR_EN_LBN 32
-  #define SRM_PERR_INT_CHAR_EN_WIDTH 1
-  #define FATAL_INTR_REG_EN_BITS    0xffffffffffffffffULL
-  #define PCI_BUSERR_INT_CHAR_LBN 11
-  #define PCI_BUSERR_INT_CHAR_WIDTH 1
-  #define SRAM_OOB_INT_CHAR_LBN 10
-  #define SRAM_OOB_INT_CHAR_WIDTH 1
-  #define BUFID_OOB_INT_CHAR_LBN 9
-  #define BUFID_OOB_INT_CHAR_WIDTH 1
-  #define MEM_PERR_INT_CHAR_LBN 8
-  #define MEM_PERR_INT_CHAR_WIDTH 1
-  #define RBUF_OWN_INT_CHAR_LBN 7
-  #define RBUF_OWN_INT_CHAR_WIDTH 1
-  #define TBUF_OWN_INT_CHAR_LBN 6
-  #define TBUF_OWN_INT_CHAR_WIDTH 1
-  #define RDESCQ_OWN_INT_CHAR_LBN 5
-  #define RDESCQ_OWN_INT_CHAR_WIDTH 1
-  #define TDESCQ_OWN_INT_CHAR_LBN 4
-  #define TDESCQ_OWN_INT_CHAR_WIDTH 1
-  #define EVQ_OWN_INT_CHAR_LBN 3
-  #define EVQ_OWN_INT_CHAR_WIDTH 1
-  #define EVFF_OFLO_INT_CHAR_LBN 2
-  #define EVFF_OFLO_INT_CHAR_WIDTH 1
-  #define ILL_ADR_INT_CHAR_LBN 1
-  #define ILL_ADR_INT_CHAR_WIDTH 1
-  #define SRM_PERR_INT_CHAR_LBN 0
-  #define SRM_PERR_INT_CHAR_WIDTH 1
-#define DP_CTRL_REG_OFST 0x250 // Datapath control register
-  #define FLS_EVQ_ID_LBN 0
-  #define FLS_EVQ_ID_WIDTH 12
-#define MEM_STAT_REG_KER_OFST 0x260 // Memory status register
-#define MEM_STAT_REG_OFST 0x260 // Memory status register
-  #define MEM_PERR_VEC_LBN 53
-  #define MEM_PERR_VEC_WIDTH 38
-  #define MBIST_CORR_LBN 38
-  #define MBIST_CORR_WIDTH 15
-  #define MBIST_ERR_LBN 0
-  #define MBIST_ERR_WIDTH 38
-#define DEBUG_REG_KER_OFST 0x270 // Debug register
-#define DEBUG_REG_OFST 0x270 // Debug register
-  #define DEBUG_BLK_SEL2_LBN 47
-  #define DEBUG_BLK_SEL2_WIDTH 3
-  #define DEBUG_BLK_SEL1_LBN 44
-  #define DEBUG_BLK_SEL1_WIDTH 3
-  #define DEBUG_BLK_SEL0_LBN 41
-  #define DEBUG_BLK_SEL0_WIDTH 3
-  #define MISC_DEBUG_ADDR_LBN 36
-  #define MISC_DEBUG_ADDR_WIDTH 5
-  #define SERDES_DEBUG_ADDR_LBN 31
-  #define SERDES_DEBUG_ADDR_WIDTH 5
-  #define EM_DEBUG_ADDR_LBN 26
-  #define EM_DEBUG_ADDR_WIDTH 5
-  #define SR_DEBUG_ADDR_LBN 21
-  #define SR_DEBUG_ADDR_WIDTH 5
-  #define EV_DEBUG_ADDR_LBN 16
-  #define EV_DEBUG_ADDR_WIDTH 5
-  #define RX_DEBUG_ADDR_LBN 11
-  #define RX_DEBUG_ADDR_WIDTH 5
-  #define TX_DEBUG_ADDR_LBN 6
-  #define TX_DEBUG_ADDR_WIDTH 5
-  #define BIU_DEBUG_ADDR_LBN 1
-  #define BIU_DEBUG_ADDR_WIDTH 5
-  #define DEBUG_EN_LBN 0
-  #define DEBUG_EN_WIDTH 1
-#define DRIVER_REG0_KER_OFST 0x280 // Driver scratch register 0
-#define DRIVER_REG0_OFST 0x280 // Driver scratch register 0
-  #define DRIVER_DW0_LBN 0
-  #define DRIVER_DW0_WIDTH 32
-#define DRIVER_REG1_KER_OFST 0x290 // Driver scratch register 1
-#define DRIVER_REG1_OFST 0x290 // Driver scratch register 1
-  #define DRIVER_DW1_LBN 0
-  #define DRIVER_DW1_WIDTH 32
-#define DRIVER_REG2_KER_OFST 0x2A0 // Driver scratch register 2
-#define DRIVER_REG2_OFST 0x2A0 // Driver scratch register 2
-  #define DRIVER_DW2_LBN 0
-  #define DRIVER_DW2_WIDTH 32
-#define DRIVER_REG3_KER_OFST 0x2B0 // Driver scratch register 3
-#define DRIVER_REG3_OFST 0x2B0 // Driver scratch register 3
-  #define DRIVER_DW3_LBN 0
-  #define DRIVER_DW3_WIDTH 32
-#define DRIVER_REG4_KER_OFST 0x2C0 // Driver scratch register 4
-#define DRIVER_REG4_OFST 0x2C0 // Driver scratch register 4
-  #define DRIVER_DW4_LBN 0
-  #define DRIVER_DW4_WIDTH 32
-#define DRIVER_REG5_KER_OFST 0x2D0 // Driver scratch register 5
-#define DRIVER_REG5_OFST 0x2D0 // Driver scratch register 5
-  #define DRIVER_DW5_LBN 0
-  #define DRIVER_DW5_WIDTH 32
-#define DRIVER_REG6_KER_OFST 0x2E0 // Driver scratch register 6
-#define DRIVER_REG6_OFST 0x2E0 // Driver scratch register 6
-  #define DRIVER_DW6_LBN 0
-  #define DRIVER_DW6_WIDTH 32
-#define DRIVER_REG7_KER_OFST 0x2F0 // Driver scratch register 7
-#define DRIVER_REG7_OFST 0x2F0 // Driver scratch register 7
-  #define DRIVER_DW7_LBN 0
-  #define DRIVER_DW7_WIDTH 32
-#define ALTERA_BUILD_REG_OFST 0x300 // Altera build register
-#define ALTERA_BUILD_REG_OFST 0x300 // Altera build register
-  #define ALTERA_BUILD_VER_LBN 0
-  #define ALTERA_BUILD_VER_WIDTH 32
-
-/* so called CSR spare register 
-    - contains separate parity enable bits for the various internal memory blocks */
-#define MEM_PARITY_ERR_EN_REG_KER 0x310 
-#define MEM_PARITY_ALL_BLOCKS_EN_LBN 64
-#define MEM_PARITY_ALL_BLOCKS_EN_WIDTH 38
-#define MEM_PARITY_TX_DATA_EN_LBN   72
-#define MEM_PARITY_TX_DATA_EN_WIDTH 2
-
-//////////////---- Event & Timer Module Registers C Header ----//////////////
-
-#if EFVI_FALCON_EXTENDED_P_BAR
-#define EVQ_RPTR_REG_KER_OFST 0x11B00 // Event queue read pointer register
-#else
-#define EVQ_RPTR_REG_KER_OFST 0x1B00 // Event queue read pointer register
-#endif
-
-#define EVQ_RPTR_REG_OFST 0xFA0000 // Event queue read pointer register array.
-  #define EVQ_RPTR_LBN 0
-  #define EVQ_RPTR_WIDTH 15
-
-#if EFVI_FALCON_EXTENDED_P_BAR
-#define EVQ_PTR_TBL_KER_OFST 0x11A00 // Event queue pointer table for kernel access
-#else
-#define EVQ_PTR_TBL_KER_OFST 0x1A00 // Event queue pointer table for kernel access
-#endif
-
-#define EVQ_PTR_TBL_CHAR_OFST 0xF60000 // Event queue pointer table for char direct access
-  #define EVQ_WKUP_OR_INT_EN_LBN 39
-  #define EVQ_WKUP_OR_INT_EN_WIDTH 1
-  #define EVQ_NXT_WPTR_LBN 24
-  #define EVQ_NXT_WPTR_WIDTH 15
-  #define EVQ_EN_LBN 23
-  #define EVQ_EN_WIDTH 1
-  #define EVQ_SIZE_LBN 20
-  #define EVQ_SIZE_WIDTH 3
-  #define EVQ_BUF_BASE_ID_LBN 0
-  #define EVQ_BUF_BASE_ID_WIDTH 20
-#define TIMER_CMD_REG_KER_OFST 0x420 // Timer table for kernel access. Page-mapped
-#define TIMER_CMD_REG_PAGE4_OFST 0x8420 // Timer table for user-level access. Page-mapped. For lowest 1K queues.
-#define TIMER_CMD_REG_PAGE123K_OFST 0x1000420 // Timer table for user-level access. Page-mapped. For upper 3K queues.
-#define TIMER_TBL_OFST 0xF70000 // Timer table for char driver direct access
-  #define TIMER_MODE_LBN 12
-  #define TIMER_MODE_WIDTH 2
-  #define TIMER_VAL_LBN 0
-  #define TIMER_VAL_WIDTH 12
-  #define TIMER_MODE_INT_HLDOFF 2
-  #define EVQ_BUF_SIZE_LBN 0
-  #define EVQ_BUF_SIZE_WIDTH 1
-#define DRV_EV_REG_KER_OFST 0x440 // Driver generated event register
-#define DRV_EV_REG_OFST 0x440 // Driver generated event register
-  #define DRV_EV_QID_LBN 64
-  #define DRV_EV_QID_WIDTH 12
-  #define DRV_EV_DATA_LBN 0
-  #define DRV_EV_DATA_WIDTH 64
-#define EVQ_CTL_REG_KER_OFST 0x450 // Event queue control register
-#define EVQ_CTL_REG_OFST 0x450 // Event queue control register
-  #define RX_EVQ_WAKEUP_MASK_B0_LBN 15
-  #define RX_EVQ_WAKEUP_MASK_B0_WIDTH 6
-  #define EVQ_OWNERR_CTL_LBN 14
-  #define EVQ_OWNERR_CTL_WIDTH 1
-  #define EVQ_FIFO_AF_TH_LBN 8
-  #define EVQ_FIFO_AF_TH_WIDTH 6
-  #define EVQ_FIFO_NOTAF_TH_LBN 0
-  #define EVQ_FIFO_NOTAF_TH_WIDTH 6
-//////////////---- SRAM Module Registers C Header ----//////////////
-#define BUF_TBL_CFG_REG_KER_OFST 0x600 // Buffer table configuration register
-#define BUF_TBL_CFG_REG_OFST 0x600 // Buffer table configuration register
-  #define BUF_TBL_MODE_LBN 3
-  #define BUF_TBL_MODE_WIDTH 1
-#define SRM_RX_DC_CFG_REG_KER_OFST 0x610 // SRAM receive descriptor cache configuration register
-#define SRM_RX_DC_CFG_REG_OFST 0x610 // SRAM receive descriptor cache configuration register
-  #define SRM_RX_DC_BASE_ADR_LBN 0
-  #define SRM_RX_DC_BASE_ADR_WIDTH 21
-#define SRM_TX_DC_CFG_REG_KER_OFST 0x620 // SRAM transmit descriptor cache configuration register
-#define SRM_TX_DC_CFG_REG_OFST 0x620 // SRAM transmit descriptor cache configuration register
-  #define SRM_TX_DC_BASE_ADR_LBN 0
-  #define SRM_TX_DC_BASE_ADR_WIDTH 21
-#define SRM_CFG_REG_KER_OFST 0x630 // SRAM configuration register
-#define SRM_CFG_REG_OFST 0x630 // SRAM configuration register
-  #define SRAM_OOB_ADR_INTEN_LBN 5
-  #define SRAM_OOB_ADR_INTEN_WIDTH 1
-  #define SRAM_OOB_BUF_INTEN_LBN 4
-  #define SRAM_OOB_BUF_INTEN_WIDTH 1
-  #define SRAM_BT_INIT_EN_LBN 3
-  #define SRAM_BT_INIT_EN_WIDTH 1
-  #define SRM_NUM_BANK_LBN 2
-  #define SRM_NUM_BANK_WIDTH 1
-  #define SRM_BANK_SIZE_LBN 0
-  #define SRM_BANK_SIZE_WIDTH 2
-#define BUF_TBL_UPD_REG_KER_OFST 0x650 // Buffer table update register
-#define BUF_TBL_UPD_REG_OFST 0x650 // Buffer table update register
-  #define BUF_UPD_CMD_LBN 63
-  #define BUF_UPD_CMD_WIDTH 1
-  #define BUF_CLR_CMD_LBN 62
-  #define BUF_CLR_CMD_WIDTH 1
-  #define BUF_CLR_END_ID_LBN 32
-  #define BUF_CLR_END_ID_WIDTH 20
-  #define BUF_CLR_START_ID_LBN 0
-  #define BUF_CLR_START_ID_WIDTH 20
-#define SRM_UPD_EVQ_REG_KER_OFST 0x660 // Buffer table update register
-#define SRM_UPD_EVQ_REG_OFST 0x660 // Buffer table update register
-  #define SRM_UPD_EVQ_ID_LBN 0
-  #define SRM_UPD_EVQ_ID_WIDTH 12
-#define SRAM_PARITY_REG_KER_OFST 0x670 // SRAM parity register.
-#define SRAM_PARITY_REG_OFST 0x670 // SRAM parity register.
-  #define FORCE_SRAM_PERR_LBN 0
-  #define FORCE_SRAM_PERR_WIDTH 1
-
-#if EFVI_FALCON_EXTENDED_P_BAR
-#define BUF_HALF_TBL_KER_OFST 0x18000 // Buffer table in half buffer table mode direct access by kernel driver
-#else
-#define BUF_HALF_TBL_KER_OFST 0x8000 // Buffer table in half buffer table mode direct access by kernel driver
-#endif
-
-
-#define BUF_HALF_TBL_OFST 0x800000 // Buffer table in half buffer table mode direct access by char driver
-  #define BUF_ADR_HBUF_ODD_LBN 44
-  #define BUF_ADR_HBUF_ODD_WIDTH 20
-  #define BUF_OWNER_ID_HBUF_ODD_LBN 32
-  #define BUF_OWNER_ID_HBUF_ODD_WIDTH 12
-  #define BUF_ADR_HBUF_EVEN_LBN 12
-  #define BUF_ADR_HBUF_EVEN_WIDTH 20
-  #define BUF_OWNER_ID_HBUF_EVEN_LBN 0
-  #define BUF_OWNER_ID_HBUF_EVEN_WIDTH 12
-
-
-#if EFVI_FALCON_EXTENDED_P_BAR
-#define BUF_FULL_TBL_KER_OFST 0x18000 // Buffer table in full buffer table mode direct access by kernel driver
-#else
-#define BUF_FULL_TBL_KER_OFST 0x8000 // Buffer table in full buffer table mode direct access by kernel driver
-#endif
-
-
-
-
-#define BUF_FULL_TBL_OFST 0x800000 // Buffer table in full buffer table mode direct access by char driver
-  #define IP_DAT_BUF_SIZE_LBN 50
-  #define IP_DAT_BUF_SIZE_WIDTH 1
-  #define BUF_ADR_REGION_LBN 48
-  #define BUF_ADR_REGION_WIDTH 2
-  #define BUF_ADR_FBUF_LBN 14
-  #define BUF_ADR_FBUF_WIDTH 34
-  #define BUF_OWNER_ID_FBUF_LBN 0
-  #define BUF_OWNER_ID_FBUF_WIDTH 14
-#define SRM_DBG_REG_OFST 0x3000000 // SRAM debug access
-  #define SRM_DBG_LBN 0
-  #define SRM_DBG_WIDTH 64
-//////////////---- RX Datapath Registers C Header ----//////////////
-
-#define RX_CFG_REG_KER_OFST 0x800 // Receive configuration register
-#define RX_CFG_REG_OFST 0x800 // Receive configuration register
-
-#if !defined(FALCON_64K_RXFIFO) && !defined(FALCON_PRE_02020029)
-# if !defined(FALCON_128K_RXFIFO)
-#  define FALCON_128K_RXFIFO
-# endif
-#endif
-
-#if defined(FALCON_128K_RXFIFO)
-
-/* new for B0 */
-  #define RX_TOEP_TCP_SUPPRESS_B0_LBN 48
-  #define RX_TOEP_TCP_SUPPRESS_B0_WIDTH 1
-  #define RX_INGR_EN_B0_LBN 47
-  #define RX_INGR_EN_B0_WIDTH 1
-  #define RX_TOEP_IPV4_B0_LBN 46
-  #define RX_TOEP_IPV4_B0_WIDTH 1
-  #define RX_HASH_ALG_B0_LBN 45
-  #define RX_HASH_ALG_B0_WIDTH 1
-  #define RX_HASH_INSERT_HDR_B0_LBN 44
-  #define RX_HASH_INSERT_HDR_B0_WIDTH 1
-/* moved for B0 */
-  #define RX_DESC_PUSH_EN_B0_LBN 43
-  #define RX_DESC_PUSH_EN_B0_WIDTH 1
-  #define RX_RDW_PATCH_EN_LBN 42 /* Non head of line blocking */
-  #define RX_RDW_PATCH_EN_WIDTH 1
-  #define RX_PCI_BURST_SIZE_B0_LBN 39
-  #define RX_PCI_BURST_SIZE_B0_WIDTH 3
-  #define RX_OWNERR_CTL_B0_LBN 38
-  #define RX_OWNERR_CTL_B0_WIDTH 1
-  #define RX_XON_TX_TH_B0_LBN 33 
-  #define RX_XON_TX_TH_B0_WIDTH 5
-  #define RX_XOFF_TX_TH_B0_LBN 28 
-  #define RX_XOFF_TX_TH_B0_WIDTH 5
-  #define RX_USR_BUF_SIZE_B0_LBN 19
-  #define RX_USR_BUF_SIZE_B0_WIDTH 9
-  #define RX_XON_MAC_TH_B0_LBN 10
-  #define RX_XON_MAC_TH_B0_WIDTH 9
-  #define RX_XOFF_MAC_TH_B0_LBN 1
-  #define RX_XOFF_MAC_TH_B0_WIDTH 9
-  #define RX_XOFF_MAC_EN_B0_LBN 0
-  #define RX_XOFF_MAC_EN_B0_WIDTH 1
-
-#elif !defined(FALCON_PRE_02020029)
-/* new for B0 */
-  #define RX_TOEP_TCP_SUPPRESS_B0_LBN 46
-  #define RX_TOEP_TCP_SUPPRESS_B0_WIDTH 1
-  #define RX_INGR_EN_B0_LBN 45
-  #define RX_INGR_EN_B0_WIDTH 1
-  #define RX_TOEP_IPV4_B0_LBN 44
-  #define RX_TOEP_IPV4_B0_WIDTH 1
-  #define RX_HASH_ALG_B0_LBN 43
-  #define RX_HASH_ALG_B0_WIDTH 41
-  #define RX_HASH_INSERT_HDR_B0_LBN 42
-  #define RX_HASH_INSERT_HDR_B0_WIDTH 1
-/* moved for B0 */
-  #define RX_DESC_PUSH_EN_B0_LBN 41
-  #define RX_DESC_PUSH_EN_B0_WIDTH 1
-  #define RX_PCI_BURST_SIZE_B0_LBN 37
-  #define RX_PCI_BURST_SIZE_B0_WIDTH 3
-  #define RX_OWNERR_CTL_B0_LBN 36
-  #define RX_OWNERR_CTL_B0_WIDTH 1
-  #define RX_XON_TX_TH_B0_LBN 31
-  #define RX_XON_TX_TH_B0_WIDTH 5
-  #define RX_XOFF_TX_TH_B0_LBN 26
-  #define RX_XOFF_TX_TH_B0_WIDTH 5
-  #define RX_USR_BUF_SIZE_B0_LBN 17
-  #define RX_USR_BUF_SIZE_B0_WIDTH 9
-  #define RX_XON_MAC_TH_B0_LBN 9
-  #define RX_XON_MAC_TH_B0_WIDTH 8
-  #define RX_XOFF_MAC_TH_B0_LBN 1
-  #define RX_XOFF_MAC_TH_B0_WIDTH 8
-  #define RX_XOFF_MAC_EN_B0_LBN 0
-  #define RX_XOFF_MAC_EN_B0_WIDTH 1
-
-#else
-/* new for B0 */
-  #define RX_TOEP_TCP_SUPPRESS_B0_LBN 44
-  #define RX_TOEP_TCP_SUPPRESS_B0_WIDTH 1
-  #define RX_INGR_EN_B0_LBN 43
-  #define RX_INGR_EN_B0_WIDTH 1
-  #define RX_TOEP_IPV4_B0_LBN 42
-  #define RX_TOEP_IPV4_B0_WIDTH 1
-  #define RX_HASH_ALG_B0_LBN 41
-  #define RX_HASH_ALG_B0_WIDTH 41
-  #define RX_HASH_INSERT_HDR_B0_LBN 40
-  #define RX_HASH_INSERT_HDR_B0_WIDTH 1
-/* moved for B0 */
-  #define RX_DESC_PUSH_EN_B0_LBN 35
-  #define RX_DESC_PUSH_EN_B0_WIDTH 1
-  #define RX_PCI_BURST_SIZE_B0_LBN 35
-  #define RX_PCI_BURST_SIZE_B0_WIDTH 2
-  #define RX_OWNERR_CTL_B0_LBN 34
-  #define RX_OWNERR_CTL_B0_WIDTH 1
-  #define RX_XON_TX_TH_B0_LBN 29
-  #define RX_XON_TX_TH_B0_WIDTH 5
-  #define RX_XOFF_TX_TH_B0_LBN 24
-  #define RX_XOFF_TX_TH_B0_WIDTH 5
-  #define RX_USR_BUF_SIZE_B0_LBN 15
-  #define RX_USR_BUF_SIZE_B0_WIDTH 9
-  #define RX_XON_MAC_TH_B0_LBN 8
-  #define RX_XON_MAC_TH_B0_WIDTH 7
-  #define RX_XOFF_MAC_TH_B0_LBN 1
-  #define RX_XOFF_MAC_TH_B0_WIDTH 7
-  #define RX_XOFF_MAC_EN_B0_LBN 0
-  #define RX_XOFF_MAC_EN_B0_WIDTH 1
-
-#endif
-
-/* A0/A1 */
-  #define RX_PUSH_EN_A1_LBN 35
-  #define RX_PUSH_EN_A1_WIDTH 1
-  #define RX_PCI_BURST_SIZE_A1_LBN 31
-  #define RX_PCI_BURST_SIZE_A1_WIDTH 3
-  #define RX_OWNERR_CTL_A1_LBN 30
-  #define RX_OWNERR_CTL_A1_WIDTH 1
-  #define RX_XON_TX_TH_A1_LBN 25
-  #define RX_XON_TX_TH_A1_WIDTH 5
-  #define RX_XOFF_TX_TH_A1_LBN 20
-  #define RX_XOFF_TX_TH_A1_WIDTH 5
-  #define RX_USR_BUF_SIZE_A1_LBN 11
-  #define RX_USR_BUF_SIZE_A1_WIDTH 9
-  #define RX_XON_MAC_TH_A1_LBN 6
-  #define RX_XON_MAC_TH_A1_WIDTH 5
-  #define RX_XOFF_MAC_TH_A1_LBN 1
-  #define RX_XOFF_MAC_TH_A1_WIDTH 5
-  #define RX_XOFF_MAC_EN_A1_LBN 0
-  #define RX_XOFF_MAC_EN_A1_WIDTH 1
-
-#define RX_FILTER_CTL_REG_OFST 0x810 // Receive filter control registers
-  #define SCATTER_ENBL_NO_MATCH_Q_B0_LBN 40
-  #define SCATTER_ENBL_NO_MATCH_Q_B0_WIDTH 1
-  #define UDP_FULL_SRCH_LIMIT_LBN 32
-  #define UDP_FULL_SRCH_LIMIT_WIDTH 8
-  #define NUM_KER_LBN 24
-  #define NUM_KER_WIDTH 2
-  #define UDP_WILD_SRCH_LIMIT_LBN 16
-  #define UDP_WILD_SRCH_LIMIT_WIDTH 8
-  #define TCP_WILD_SRCH_LIMIT_LBN 8
-  #define TCP_WILD_SRCH_LIMIT_WIDTH 8
-  #define TCP_FULL_SRCH_LIMIT_LBN 0
-  #define TCP_FULL_SRCH_LIMIT_WIDTH 8
-#define RX_FLUSH_DESCQ_REG_KER_OFST 0x820 // Receive flush descriptor queue register
-#define RX_FLUSH_DESCQ_REG_OFST 0x820 // Receive flush descriptor queue register
-  #define RX_FLUSH_DESCQ_CMD_LBN 24
-  #define RX_FLUSH_DESCQ_CMD_WIDTH 1
-  #define RX_FLUSH_EVQ_ID_LBN 12
-  #define RX_FLUSH_EVQ_ID_WIDTH 12
-  #define RX_FLUSH_DESCQ_LBN 0
-  #define RX_FLUSH_DESCQ_WIDTH 12
-#define RX_DESC_UPD_REG_KER_OFST 0x830 // Kernel  receive descriptor update register. Page-mapped
-#define RX_DESC_UPD_REG_PAGE4_OFST 0x8830 // Char & user receive descriptor update register. Page-mapped. For lowest 1K queues.
-#define RX_DESC_UPD_REG_PAGE123K_OFST 0x1000830 // Char & user receive descriptor update register. Page-mapped. For upper 3K queues.
-  #define RX_DESC_WPTR_LBN 96
-  #define RX_DESC_WPTR_WIDTH 12
-  #define RX_DESC_PUSH_CMD_LBN 95
-  #define RX_DESC_PUSH_CMD_WIDTH 1
-  #define RX_DESC_LBN 0
-  #define RX_DESC_WIDTH 64
-  #define RX_KER_DESC_LBN 0
-  #define RX_KER_DESC_WIDTH 64
-  #define RX_USR_DESC_LBN 0
-  #define RX_USR_DESC_WIDTH 32
-#define RX_DC_CFG_REG_KER_OFST 0x840 // Receive descriptor cache configuration register
-#define RX_DC_CFG_REG_OFST 0x840 // Receive descriptor cache configuration register
-  #define RX_DC_SIZE_LBN 0
-  #define RX_DC_SIZE_WIDTH 2
-#define RX_DC_PF_WM_REG_KER_OFST 0x850 // Receive descriptor cache pre-fetch watermark register
-#define RX_DC_PF_WM_REG_OFST 0x850 // Receive descriptor cache pre-fetch watermark register
-  #define RX_DC_PF_LWM_LO_LBN 0
-  #define RX_DC_PF_LWM_LO_WIDTH 6
-
-#define RX_RSS_TKEY_B0_OFST 0x860 // RSS Toeplitz hash key (B0 only)
-
-#define RX_NODESC_DROP_REG 0x880
-  #define RX_NODESC_DROP_CNT_LBN 0
-  #define RX_NODESC_DROP_CNT_WIDTH 16
-
-#define XM_TX_CFG_REG_OFST 0x1230
-  #define XM_AUTO_PAD_LBN 5
-  #define XM_AUTO_PAD_WIDTH 1
-
-#define RX_FILTER_TBL0_OFST 0xF00000 // Receive filter table - even entries
-  #define RSS_EN_0_B0_LBN 110
-  #define RSS_EN_0_B0_WIDTH 1
-  #define SCATTER_EN_0_B0_LBN 109
-  #define SCATTER_EN_0_B0_WIDTH 1
-  #define TCP_UDP_0_LBN 108
-  #define TCP_UDP_0_WIDTH 1
-  #define RXQ_ID_0_LBN 96
-  #define RXQ_ID_0_WIDTH 12
-  #define DEST_IP_0_LBN 64
-  #define DEST_IP_0_WIDTH 32
-  #define DEST_PORT_TCP_0_LBN 48
-  #define DEST_PORT_TCP_0_WIDTH 16
-  #define SRC_IP_0_LBN 16
-  #define SRC_IP_0_WIDTH 32
-  #define SRC_TCP_DEST_UDP_0_LBN 0
-  #define SRC_TCP_DEST_UDP_0_WIDTH 16
-#define RX_FILTER_TBL1_OFST 0xF00010 // Receive filter table - odd entries
-  #define RSS_EN_1_B0_LBN 110
-  #define RSS_EN_1_B0_WIDTH 1
-  #define SCATTER_EN_1_B0_LBN 109
-  #define SCATTER_EN_1_B0_WIDTH 1
-  #define TCP_UDP_1_LBN 108
-  #define TCP_UDP_1_WIDTH 1
-  #define RXQ_ID_1_LBN 96
-  #define RXQ_ID_1_WIDTH 12
-  #define DEST_IP_1_LBN 64
-  #define DEST_IP_1_WIDTH 32
-  #define DEST_PORT_TCP_1_LBN 48
-  #define DEST_PORT_TCP_1_WIDTH 16
-  #define SRC_IP_1_LBN 16
-  #define SRC_IP_1_WIDTH 32
-  #define SRC_TCP_DEST_UDP_1_LBN 0
-  #define SRC_TCP_DEST_UDP_1_WIDTH 16
-
-#if EFVI_FALCON_EXTENDED_P_BAR
-#define RX_DESC_PTR_TBL_KER_OFST 0x11800 // Receive descriptor pointer kernel access
-#else
-#define RX_DESC_PTR_TBL_KER_OFST 0x1800 // Receive descriptor pointer kernel access
-#endif
-
-
-#define RX_DESC_PTR_TBL_OFST 0xF40000 // Receive descriptor pointer table
-  #define RX_ISCSI_DDIG_EN_LBN 88
-  #define RX_ISCSI_DDIG_EN_WIDTH 1
-  #define RX_ISCSI_HDIG_EN_LBN 87
-  #define RX_ISCSI_HDIG_EN_WIDTH 1
-  #define RX_DESC_PREF_ACT_LBN 86
-  #define RX_DESC_PREF_ACT_WIDTH 1
-  #define RX_DC_HW_RPTR_LBN 80
-  #define RX_DC_HW_RPTR_WIDTH 6
-  #define RX_DESCQ_HW_RPTR_LBN 68
-  #define RX_DESCQ_HW_RPTR_WIDTH 12
-  #define RX_DESCQ_SW_WPTR_LBN 56
-  #define RX_DESCQ_SW_WPTR_WIDTH 12
-  #define RX_DESCQ_BUF_BASE_ID_LBN 36
-  #define RX_DESCQ_BUF_BASE_ID_WIDTH 20
-  #define RX_DESCQ_EVQ_ID_LBN 24
-  #define RX_DESCQ_EVQ_ID_WIDTH 12
-  #define RX_DESCQ_OWNER_ID_LBN 10
-  #define RX_DESCQ_OWNER_ID_WIDTH 14
-  #define RX_DESCQ_LABEL_LBN 5
-  #define RX_DESCQ_LABEL_WIDTH 5
-  #define RX_DESCQ_SIZE_LBN 3
-  #define RX_DESCQ_SIZE_WIDTH 2
-  #define RX_DESCQ_TYPE_LBN 2
-  #define RX_DESCQ_TYPE_WIDTH 1
-  #define RX_DESCQ_JUMBO_LBN 1
-  #define RX_DESCQ_JUMBO_WIDTH 1
-  #define RX_DESCQ_EN_LBN 0
-  #define RX_DESCQ_EN_WIDTH 1
-
-
-#define RX_RSS_INDIR_TBL_B0_OFST 0xFB0000 // RSS indirection table (B0 only)
-  #define RX_RSS_INDIR_ENT_B0_LBN 0
-  #define RX_RSS_INDIR_ENT_B0_WIDTH 6
-
-//////////////---- TX Datapath Registers C Header ----//////////////
-#define TX_FLUSH_DESCQ_REG_KER_OFST 0xA00 // Transmit flush descriptor queue register
-#define TX_FLUSH_DESCQ_REG_OFST 0xA00 // Transmit flush descriptor queue register
-  #define TX_FLUSH_DESCQ_CMD_LBN 12
-  #define TX_FLUSH_DESCQ_CMD_WIDTH 1
-  #define TX_FLUSH_DESCQ_LBN 0
-  #define TX_FLUSH_DESCQ_WIDTH 12
-#define TX_DESC_UPD_REG_KER_OFST 0xA10 // Kernel transmit descriptor update register. Page-mapped
-#define TX_DESC_UPD_REG_PAGE4_OFST 0x8A10 // Char & user transmit descriptor update register. Page-mapped
-#define TX_DESC_UPD_REG_PAGE123K_OFST 0x1000A10 // Char & user transmit descriptor update register. Page-mapped
-  #define TX_DESC_WPTR_LBN 96
-  #define TX_DESC_WPTR_WIDTH 12
-  #define TX_DESC_PUSH_CMD_LBN 95
-  #define TX_DESC_PUSH_CMD_WIDTH 1
-  #define TX_DESC_LBN 0
-  #define TX_DESC_WIDTH 95
-  #define TX_KER_DESC_LBN 0
-  #define TX_KER_DESC_WIDTH 64
-  #define TX_USR_DESC_LBN 0
-  #define TX_USR_DESC_WIDTH 64
-#define TX_DC_CFG_REG_KER_OFST 0xA20 // Transmit descriptor cache configuration register
-#define TX_DC_CFG_REG_OFST 0xA20 // Transmit descriptor cache configuration register
-  #define TX_DC_SIZE_LBN 0
-  #define TX_DC_SIZE_WIDTH 2
-
-#if EFVI_FALCON_EXTENDED_P_BAR
-#define TX_DESC_PTR_TBL_KER_OFST 0x11900 // Transmit descriptor pointer.
-#else
-#define TX_DESC_PTR_TBL_KER_OFST 0x1900 // Transmit descriptor pointer.
-#endif
-
-
-#define TX_DESC_PTR_TBL_OFST 0xF50000 // Transmit descriptor pointer
-  #define TX_NON_IP_DROP_DIS_B0_LBN 91
-  #define TX_NON_IP_DROP_DIS_B0_WIDTH 1
-  #define TX_IP_CHKSM_DIS_B0_LBN 90
-  #define TX_IP_CHKSM_DIS_B0_WIDTH 1
-  #define TX_TCP_CHKSM_DIS_B0_LBN 89
-  #define TX_TCP_CHKSM_DIS_B0_WIDTH 1
-  #define TX_DESCQ_EN_LBN 88
-  #define TX_DESCQ_EN_WIDTH 1
-  #define TX_ISCSI_DDIG_EN_LBN 87
-  #define TX_ISCSI_DDIG_EN_WIDTH 1
-  #define TX_ISCSI_HDIG_EN_LBN 86
-  #define TX_ISCSI_HDIG_EN_WIDTH 1
-  #define TX_DC_HW_RPTR_LBN 80
-  #define TX_DC_HW_RPTR_WIDTH 6
-  #define TX_DESCQ_HW_RPTR_LBN 68
-  #define TX_DESCQ_HW_RPTR_WIDTH 12
-  #define TX_DESCQ_SW_WPTR_LBN 56
-  #define TX_DESCQ_SW_WPTR_WIDTH 12
-  #define TX_DESCQ_BUF_BASE_ID_LBN 36
-  #define TX_DESCQ_BUF_BASE_ID_WIDTH 20
-  #define TX_DESCQ_EVQ_ID_LBN 24
-  #define TX_DESCQ_EVQ_ID_WIDTH 12
-  #define TX_DESCQ_OWNER_ID_LBN 10
-  #define TX_DESCQ_OWNER_ID_WIDTH 14
-  #define TX_DESCQ_LABEL_LBN 5
-  #define TX_DESCQ_LABEL_WIDTH 5
-  #define TX_DESCQ_SIZE_LBN 3
-  #define TX_DESCQ_SIZE_WIDTH 2
-  #define TX_DESCQ_TYPE_LBN 1
-  #define TX_DESCQ_TYPE_WIDTH 2
-  #define TX_DESCQ_FLUSH_LBN 0
-  #define TX_DESCQ_FLUSH_WIDTH 1
-#define TX_CFG_REG_KER_OFST 0xA50 // Transmit configuration register
-#define TX_CFG_REG_OFST 0xA50 // Transmit configuration register
-  #define TX_IP_ID_P1_OFS_LBN 32
-  #define TX_IP_ID_P1_OFS_WIDTH 15
-  #define TX_IP_ID_P0_OFS_LBN 16
-  #define TX_IP_ID_P0_OFS_WIDTH 15
-  #define TX_TURBO_EN_LBN 3
-  #define TX_TURBO_EN_WIDTH 1 
-  #define TX_OWNERR_CTL_LBN 2
-  #define TX_OWNERR_CTL_WIDTH 2
-  #define TX_NON_IP_DROP_DIS_LBN 1
-  #define TX_NON_IP_DROP_DIS_WIDTH 1
-  #define TX_IP_ID_REP_EN_LBN 0
-  #define TX_IP_ID_REP_EN_WIDTH 1
-#define TX_RESERVED_REG_KER_OFST 0xA80 // Transmit configuration register
-#define TX_RESERVED_REG_OFST 0xA80 // Transmit configuration register
-  #define TX_CSR_PUSH_EN_LBN 89
-  #define TX_CSR_PUSH_EN_WIDTH 1
-  #define TX_RX_SPACER_LBN 64
-  #define TX_RX_SPACER_WIDTH 8
-  #define TX_SW_EV_EN_LBN 59
-  #define TX_SW_EV_EN_WIDTH 1
-  #define TX_RX_SPACER_EN_LBN 57
-  #define TX_RX_SPACER_EN_WIDTH 1
-  #define TX_CSR_PREF_WD_TMR_LBN 24
-  #define TX_CSR_PREF_WD_TMR_WIDTH 16
-  #define TX_CSR_ONLY1TAG_LBN 21
-  #define TX_CSR_ONLY1TAG_WIDTH 1
-  #define TX_PREF_THRESHOLD_LBN 19
-  #define TX_PREF_THRESHOLD_WIDTH 2
-  #define TX_ONE_PKT_PER_Q_LBN 18
-  #define TX_ONE_PKT_PER_Q_WIDTH 1
-  #define TX_DIS_NON_IP_EV_LBN 17
-  #define TX_DIS_NON_IP_EV_WIDTH 1
-  #define TX_DMA_SPACER_LBN 8
-  #define TX_DMA_SPACER_WIDTH 8
-  #define TX_FLUSH_MIN_LEN_EN_B0_LBN 7
-  #define TX_FLUSH_MIN_LEN_EN_B0_WIDTH 1
-  #define TX_TCP_DIS_A1_LBN 7
-  #define TX_TCP_DIS_A1_WIDTH 1
-  #define TX_IP_DIS_A1_LBN 6
-  #define TX_IP_DIS_A1_WIDTH 1
-  #define TX_MAX_CPL_LBN 2
-  #define TX_MAX_CPL_WIDTH 2
-  #define TX_MAX_PREF_LBN 0
-  #define TX_MAX_PREF_WIDTH 2
-#define TX_VLAN_REG_OFST 0xAE0 // Transmit VLAN tag register
-  #define TX_VLAN_EN_LBN 127
-  #define TX_VLAN_EN_WIDTH 1
-  #define TX_VLAN7_PORT1_EN_LBN 125
-  #define TX_VLAN7_PORT1_EN_WIDTH 1
-  #define TX_VLAN7_PORT0_EN_LBN 124
-  #define TX_VLAN7_PORT0_EN_WIDTH 1
-  #define TX_VLAN7_LBN 112
-  #define TX_VLAN7_WIDTH 12
-  #define TX_VLAN6_PORT1_EN_LBN 109
-  #define TX_VLAN6_PORT1_EN_WIDTH 1
-  #define TX_VLAN6_PORT0_EN_LBN 108
-  #define TX_VLAN6_PORT0_EN_WIDTH 1
-  #define TX_VLAN6_LBN 96
-  #define TX_VLAN6_WIDTH 12
-  #define TX_VLAN5_PORT1_EN_LBN 93
-  #define TX_VLAN5_PORT1_EN_WIDTH 1
-  #define TX_VLAN5_PORT0_EN_LBN 92
-  #define TX_VLAN5_PORT0_EN_WIDTH 1
-  #define TX_VLAN5_LBN 80
-  #define TX_VLAN5_WIDTH 12
-  #define TX_VLAN4_PORT1_EN_LBN 77
-  #define TX_VLAN4_PORT1_EN_WIDTH 1
-  #define TX_VLAN4_PORT0_EN_LBN 76
-  #define TX_VLAN4_PORT0_EN_WIDTH 1
-  #define TX_VLAN4_LBN 64
-  #define TX_VLAN4_WIDTH 12
-  #define TX_VLAN3_PORT1_EN_LBN 61
-  #define TX_VLAN3_PORT1_EN_WIDTH 1
-  #define TX_VLAN3_PORT0_EN_LBN 60
-  #define TX_VLAN3_PORT0_EN_WIDTH 1
-  #define TX_VLAN3_LBN 48
-  #define TX_VLAN3_WIDTH 12
-  #define TX_VLAN2_PORT1_EN_LBN 45
-  #define TX_VLAN2_PORT1_EN_WIDTH 1
-  #define TX_VLAN2_PORT0_EN_LBN 44
-  #define TX_VLAN2_PORT0_EN_WIDTH 1
-  #define TX_VLAN2_LBN 32
-  #define TX_VLAN2_WIDTH 12
-  #define TX_VLAN1_PORT1_EN_LBN 29
-  #define TX_VLAN1_PORT1_EN_WIDTH 1
-  #define TX_VLAN1_PORT0_EN_LBN 28
-  #define TX_VLAN1_PORT0_EN_WIDTH 1
-  #define TX_VLAN1_LBN 16
-  #define TX_VLAN1_WIDTH 12
-  #define TX_VLAN0_PORT1_EN_LBN 13
-  #define TX_VLAN0_PORT1_EN_WIDTH 1
-  #define TX_VLAN0_PORT0_EN_LBN 12
-  #define TX_VLAN0_PORT0_EN_WIDTH 1
-  #define TX_VLAN0_LBN 0
-  #define TX_VLAN0_WIDTH 12
-#define TX_FIL_CTL_REG_OFST 0xAF0 // Transmit filter control register
-  #define TX_MADR1_FIL_EN_LBN 65
-  #define TX_MADR1_FIL_EN_WIDTH 1
-  #define TX_MADR0_FIL_EN_LBN 64
-  #define TX_MADR0_FIL_EN_WIDTH 1
-  #define TX_IPFIL31_PORT1_EN_LBN 63
-  #define TX_IPFIL31_PORT1_EN_WIDTH 1
-  #define TX_IPFIL31_PORT0_EN_LBN 62
-  #define TX_IPFIL31_PORT0_EN_WIDTH 1
-  #define TX_IPFIL30_PORT1_EN_LBN 61
-  #define TX_IPFIL30_PORT1_EN_WIDTH 1
-  #define TX_IPFIL30_PORT0_EN_LBN 60
-  #define TX_IPFIL30_PORT0_EN_WIDTH 1
-  #define TX_IPFIL29_PORT1_EN_LBN 59
-  #define TX_IPFIL29_PORT1_EN_WIDTH 1
-  #define TX_IPFIL29_PORT0_EN_LBN 58
-  #define TX_IPFIL29_PORT0_EN_WIDTH 1
-  #define TX_IPFIL28_PORT1_EN_LBN 57
-  #define TX_IPFIL28_PORT1_EN_WIDTH 1
-  #define TX_IPFIL28_PORT0_EN_LBN 56
-  #define TX_IPFIL28_PORT0_EN_WIDTH 1
-  #define TX_IPFIL27_PORT1_EN_LBN 55
-  #define TX_IPFIL27_PORT1_EN_WIDTH 1
-  #define TX_IPFIL27_PORT0_EN_LBN 54
-  #define TX_IPFIL27_PORT0_EN_WIDTH 1
-  #define TX_IPFIL26_PORT1_EN_LBN 53
-  #define TX_IPFIL26_PORT1_EN_WIDTH 1
-  #define TX_IPFIL26_PORT0_EN_LBN 52
-  #define TX_IPFIL26_PORT0_EN_WIDTH 1
-  #define TX_IPFIL25_PORT1_EN_LBN 51
-  #define TX_IPFIL25_PORT1_EN_WIDTH 1
-  #define TX_IPFIL25_PORT0_EN_LBN 50
-  #define TX_IPFIL25_PORT0_EN_WIDTH 1
-  #define TX_IPFIL24_PORT1_EN_LBN 49
-  #define TX_IPFIL24_PORT1_EN_WIDTH 1
-  #define TX_IPFIL24_PORT0_EN_LBN 48
-  #define TX_IPFIL24_PORT0_EN_WIDTH 1
-  #define TX_IPFIL23_PORT1_EN_LBN 47
-  #define TX_IPFIL23_PORT1_EN_WIDTH 1
-  #define TX_IPFIL23_PORT0_EN_LBN 46
-  #define TX_IPFIL23_PORT0_EN_WIDTH 1
-  #define TX_IPFIL22_PORT1_EN_LBN 45
-  #define TX_IPFIL22_PORT1_EN_WIDTH 1
-  #define TX_IPFIL22_PORT0_EN_LBN 44
-  #define TX_IPFIL22_PORT0_EN_WIDTH 1
-  #define TX_IPFIL21_PORT1_EN_LBN 43
-  #define TX_IPFIL21_PORT1_EN_WIDTH 1
-  #define TX_IPFIL21_PORT0_EN_LBN 42
-  #define TX_IPFIL21_PORT0_EN_WIDTH 1
-  #define TX_IPFIL20_PORT1_EN_LBN 41
-  #define TX_IPFIL20_PORT1_EN_WIDTH 1
-  #define TX_IPFIL20_PORT0_EN_LBN 40
-  #define TX_IPFIL20_PORT0_EN_WIDTH 1
-  #define TX_IPFIL19_PORT1_EN_LBN 39
-  #define TX_IPFIL19_PORT1_EN_WIDTH 1
-  #define TX_IPFIL19_PORT0_EN_LBN 38
-  #define TX_IPFIL19_PORT0_EN_WIDTH 1
-  #define TX_IPFIL18_PORT1_EN_LBN 37
-  #define TX_IPFIL18_PORT1_EN_WIDTH 1
-  #define TX_IPFIL18_PORT0_EN_LBN 36
-  #define TX_IPFIL18_PORT0_EN_WIDTH 1
-  #define TX_IPFIL17_PORT1_EN_LBN 35
-  #define TX_IPFIL17_PORT1_EN_WIDTH 1
-  #define TX_IPFIL17_PORT0_EN_LBN 34
-  #define TX_IPFIL17_PORT0_EN_WIDTH 1
-  #define TX_IPFIL16_PORT1_EN_LBN 33
-  #define TX_IPFIL16_PORT1_EN_WIDTH 1
-  #define TX_IPFIL16_PORT0_EN_LBN 32
-  #define TX_IPFIL16_PORT0_EN_WIDTH 1
-  #define TX_IPFIL15_PORT1_EN_LBN 31
-  #define TX_IPFIL15_PORT1_EN_WIDTH 1
-  #define TX_IPFIL15_PORT0_EN_LBN 30
-  #define TX_IPFIL15_PORT0_EN_WIDTH 1
-  #define TX_IPFIL14_PORT1_EN_LBN 29
-  #define TX_IPFIL14_PORT1_EN_WIDTH 1
-  #define TX_IPFIL14_PORT0_EN_LBN 28
-  #define TX_IPFIL14_PORT0_EN_WIDTH 1
-  #define TX_IPFIL13_PORT1_EN_LBN 27
-  #define TX_IPFIL13_PORT1_EN_WIDTH 1
-  #define TX_IPFIL13_PORT0_EN_LBN 26
-  #define TX_IPFIL13_PORT0_EN_WIDTH 1
-  #define TX_IPFIL12_PORT1_EN_LBN 25
-  #define TX_IPFIL12_PORT1_EN_WIDTH 1
-  #define TX_IPFIL12_PORT0_EN_LBN 24
-  #define TX_IPFIL12_PORT0_EN_WIDTH 1
-  #define TX_IPFIL11_PORT1_EN_LBN 23
-  #define TX_IPFIL11_PORT1_EN_WIDTH 1
-  #define TX_IPFIL11_PORT0_EN_LBN 22
-  #define TX_IPFIL11_PORT0_EN_WIDTH 1
-  #define TX_IPFIL10_PORT1_EN_LBN 21
-  #define TX_IPFIL10_PORT1_EN_WIDTH 1
-  #define TX_IPFIL10_PORT0_EN_LBN 20
-  #define TX_IPFIL10_PORT0_EN_WIDTH 1
-  #define TX_IPFIL9_PORT1_EN_LBN 19
-  #define TX_IPFIL9_PORT1_EN_WIDTH 1
-  #define TX_IPFIL9_PORT0_EN_LBN 18
-  #define TX_IPFIL9_PORT0_EN_WIDTH 1
-  #define TX_IPFIL8_PORT1_EN_LBN 17
-  #define TX_IPFIL8_PORT1_EN_WIDTH 1
-  #define TX_IPFIL8_PORT0_EN_LBN 16
-  #define TX_IPFIL8_PORT0_EN_WIDTH 1
-  #define TX_IPFIL7_PORT1_EN_LBN 15
-  #define TX_IPFIL7_PORT1_EN_WIDTH 1
-  #define TX_IPFIL7_PORT0_EN_LBN 14
-  #define TX_IPFIL7_PORT0_EN_WIDTH 1
-  #define TX_IPFIL6_PORT1_EN_LBN 13
-  #define TX_IPFIL6_PORT1_EN_WIDTH 1
-  #define TX_IPFIL6_PORT0_EN_LBN 12
-  #define TX_IPFIL6_PORT0_EN_WIDTH 1
-  #define TX_IPFIL5_PORT1_EN_LBN 11
-  #define TX_IPFIL5_PORT1_EN_WIDTH 1
-  #define TX_IPFIL5_PORT0_EN_LBN 10
-  #define TX_IPFIL5_PORT0_EN_WIDTH 1
-  #define TX_IPFIL4_PORT1_EN_LBN 9
-  #define TX_IPFIL4_PORT1_EN_WIDTH 1
-  #define TX_IPFIL4_PORT0_EN_LBN 8
-  #define TX_IPFIL4_PORT0_EN_WIDTH 1
-  #define TX_IPFIL3_PORT1_EN_LBN 7
-  #define TX_IPFIL3_PORT1_EN_WIDTH 1
-  #define TX_IPFIL3_PORT0_EN_LBN 6
-  #define TX_IPFIL3_PORT0_EN_WIDTH 1
-  #define TX_IPFIL2_PORT1_EN_LBN 5
-  #define TX_IPFIL2_PORT1_EN_WIDTH 1
-  #define TX_IPFIL2_PORT0_EN_LBN 4
-  #define TX_IPFIL2_PORT0_EN_WIDTH 1
-  #define TX_IPFIL1_PORT1_EN_LBN 3
-  #define TX_IPFIL1_PORT1_EN_WIDTH 1
-  #define TX_IPFIL1_PORT0_EN_LBN 2
-  #define TX_IPFIL1_PORT0_EN_WIDTH 1
-  #define TX_IPFIL0_PORT1_EN_LBN 1
-  #define TX_IPFIL0_PORT1_EN_WIDTH 1
-  #define TX_IPFIL0_PORT0_EN_LBN 0
-  #define TX_IPFIL0_PORT0_EN_WIDTH 1
-#define TX_IPFIL_TBL_OFST 0xB00 // Transmit IP source address filter table
-  #define TX_IPFIL_MASK_LBN 32
-  #define TX_IPFIL_MASK_WIDTH 32
-  #define TX_IP_SRC_ADR_LBN 0
-  #define TX_IP_SRC_ADR_WIDTH 32
-#define TX_PACE_REG_A1_OFST 0xF80000 // Transmit pace control register
-#define TX_PACE_REG_B0_OFST 0xA90    // Transmit pace control register
-  #define TX_PACE_SB_AF_LBN 19
-  #define TX_PACE_SB_AF_WIDTH 10
-  #define TX_PACE_SB_NOTAF_LBN 9
-  #define TX_PACE_SB_NOTAF_WIDTH 10
-  #define TX_PACE_FB_BASE_LBN 5
-  #define TX_PACE_FB_BASE_WIDTH 4
-  #define TX_PACE_BIN_TH_LBN 0
-  #define TX_PACE_BIN_TH_WIDTH 5
-#define TX_PACE_TBL_A1_OFST 0xF80040 // Transmit pacing table
-#define TX_PACE_TBL_FIRST_QUEUE_A1 4
-#define TX_PACE_TBL_B0_OFST 0xF80000 // Transmit pacing table
-#define TX_PACE_TBL_FIRST_QUEUE_B0 0
-  #define TX_PACE_LBN 0
-  #define TX_PACE_WIDTH 5
-
-//////////////---- EE/Flash Registers C Header ----//////////////
-#define EE_SPI_HCMD_REG_KER_OFST 0x100 // SPI host command register
-#define EE_SPI_HCMD_REG_OFST 0x100 // SPI host command register
-  #define EE_SPI_HCMD_CMD_EN_LBN 31
-  #define EE_SPI_HCMD_CMD_EN_WIDTH 1
-  #define EE_WR_TIMER_ACTIVE_LBN 28
-  #define EE_WR_TIMER_ACTIVE_WIDTH 1
-  #define EE_SPI_HCMD_SF_SEL_LBN 24
-  #define EE_SPI_HCMD_SF_SEL_WIDTH 1
-  #define EE_SPI_HCMD_DABCNT_LBN 16
-  #define EE_SPI_HCMD_DABCNT_WIDTH 5
-  #define EE_SPI_HCMD_READ_LBN 15
-  #define EE_SPI_HCMD_READ_WIDTH 1
-  #define EE_SPI_HCMD_DUBCNT_LBN 12
-  #define EE_SPI_HCMD_DUBCNT_WIDTH 2
-  #define EE_SPI_HCMD_ADBCNT_LBN 8
-  #define EE_SPI_HCMD_ADBCNT_WIDTH 2
-  #define EE_SPI_HCMD_ENC_LBN 0
-  #define EE_SPI_HCMD_ENC_WIDTH 8
-#define EE_SPI_HADR_REG_KER_OFST 0X110 // SPI host address register
-#define EE_SPI_HADR_REG_OFST 0X110 // SPI host address register
-  #define EE_SPI_HADR_DUBYTE_LBN 24
-  #define EE_SPI_HADR_DUBYTE_WIDTH 8
-  #define EE_SPI_HADR_ADR_LBN 0
-  #define EE_SPI_HADR_ADR_WIDTH 24
-#define EE_SPI_HDATA_REG_KER_OFST 0x120 // SPI host data register
-#define EE_SPI_HDATA_REG_OFST 0x120 // SPI host data register
-  #define EE_SPI_HDATA3_LBN 96
-  #define EE_SPI_HDATA3_WIDTH 32
-  #define EE_SPI_HDATA2_LBN 64
-  #define EE_SPI_HDATA2_WIDTH 32
-  #define EE_SPI_HDATA1_LBN 32
-  #define EE_SPI_HDATA1_WIDTH 32
-  #define EE_SPI_HDATA0_LBN 0
-  #define EE_SPI_HDATA0_WIDTH 32
-#define EE_BASE_PAGE_REG_KER_OFST 0x130 // Expansion ROM base mirror register
-#define EE_BASE_PAGE_REG_OFST 0x130 // Expansion ROM base mirror register
-  #define EE_EXP_ROM_WINDOW_BASE_LBN 16
-  #define EE_EXP_ROM_WINDOW_BASE_WIDTH 13
-  #define EE_EXPROM_MASK_LBN 0
-  #define EE_EXPROM_MASK_WIDTH 13
-#define EE_VPD_CFG0_REG_KER_OFST 0X140 // SPI/VPD configuration register
-#define EE_VPD_CFG0_REG_OFST 0X140 // SPI/VPD configuration register
-  #define EE_SF_FASTRD_EN_LBN 127
-  #define EE_SF_FASTRD_EN_WIDTH 1
-  #define EE_SF_CLOCK_DIV_LBN 120
-  #define EE_SF_CLOCK_DIV_WIDTH 7
-  #define EE_VPD_WIP_POLL_LBN 119
-  #define EE_VPD_WIP_POLL_WIDTH 1
-  #define EE_VPDW_LENGTH_LBN 80
-  #define EE_VPDW_LENGTH_WIDTH 15
-  #define EE_VPDW_BASE_LBN 64
-  #define EE_VPDW_BASE_WIDTH 15
-  #define EE_VPD_WR_CMD_EN_LBN 56
-  #define EE_VPD_WR_CMD_EN_WIDTH 8
-  #define EE_VPD_BASE_LBN 32
-  #define EE_VPD_BASE_WIDTH 24
-  #define EE_VPD_LENGTH_LBN 16
-  #define EE_VPD_LENGTH_WIDTH 13
-  #define EE_VPD_AD_SIZE_LBN 8
-  #define EE_VPD_AD_SIZE_WIDTH 5
-  #define EE_VPD_ACCESS_ON_LBN 5
-  #define EE_VPD_ACCESS_ON_WIDTH 1
-#define EE_VPD_SW_CNTL_REG_KER_OFST 0X150 // VPD access SW control register
-#define EE_VPD_SW_CNTL_REG_OFST 0X150 // VPD access SW control register
-  #define EE_VPD_CYCLE_PENDING_LBN 31
-  #define EE_VPD_CYCLE_PENDING_WIDTH 1
-  #define EE_VPD_CYC_WRITE_LBN 28
-  #define EE_VPD_CYC_WRITE_WIDTH 1
-  #define EE_VPD_CYC_ADR_LBN 0
-  #define EE_VPD_CYC_ADR_WIDTH 15
-#define EE_VPD_SW_DATA_REG_KER_OFST 0x160 // VPD access SW data register
-#define EE_VPD_SW_DATA_REG_OFST 0x160 // VPD access SW data register
-  #define EE_VPD_CYC_DAT_LBN 0
-  #define EE_VPD_CYC_DAT_WIDTH 32
diff -r 9566a4a50a43 drivers/xen/sfc_netfront/ef_vi_falcon_desc.h
--- a/drivers/xen/sfc_netfront/ef_vi_falcon_desc.h
+++ /dev/null
@@ -1,43 +0,0 @@
-//////////////---- Descriptors C Headers ----//////////////
-// Receive Kernel IP Descriptor
-  #define RX_KER_BUF_SIZE_LBN 48
-  #define RX_KER_BUF_SIZE_WIDTH 14
-  #define RX_KER_BUF_REGION_LBN 46
-  #define RX_KER_BUF_REGION_WIDTH 2
-      #define RX_KER_BUF_REGION0_DECODE 0
-      #define RX_KER_BUF_REGION1_DECODE 1
-      #define RX_KER_BUF_REGION2_DECODE 2
-      #define RX_KER_BUF_REGION3_DECODE 3
-  #define RX_KER_BUF_ADR_LBN 0
-  #define RX_KER_BUF_ADR_WIDTH 46
-// Receive User IP Descriptor
-  #define RX_USR_2BYTE_OFS_LBN 20
-  #define RX_USR_2BYTE_OFS_WIDTH 12
-  #define RX_USR_BUF_ID_LBN 0
-  #define RX_USR_BUF_ID_WIDTH 20
-// Transmit Kernel IP Descriptor
-  #define TX_KER_PORT_LBN 63
-  #define TX_KER_PORT_WIDTH 1
-  #define TX_KER_CONT_LBN 62
-  #define TX_KER_CONT_WIDTH 1
-  #define TX_KER_BYTE_CNT_LBN 48
-  #define TX_KER_BYTE_CNT_WIDTH 14
-  #define TX_KER_BUF_REGION_LBN 46
-  #define TX_KER_BUF_REGION_WIDTH 2
-      #define TX_KER_BUF_REGION0_DECODE 0
-      #define TX_KER_BUF_REGION1_DECODE 1
-      #define TX_KER_BUF_REGION2_DECODE 2
-      #define TX_KER_BUF_REGION3_DECODE 3
-  #define TX_KER_BUF_ADR_LBN 0
-  #define TX_KER_BUF_ADR_WIDTH 46
-// Transmit User IP Descriptor
-  #define TX_USR_PORT_LBN 47
-  #define TX_USR_PORT_WIDTH 1
-  #define TX_USR_CONT_LBN 46
-  #define TX_USR_CONT_WIDTH 1
-  #define TX_USR_BYTE_CNT_LBN 33
-  #define TX_USR_BYTE_CNT_WIDTH 13
-  #define TX_USR_BUF_ID_LBN 13
-  #define TX_USR_BUF_ID_WIDTH 20
-  #define TX_USR_BYTE_OFS_LBN 0
-  #define TX_USR_BYTE_OFS_WIDTH 13
diff -r 9566a4a50a43 drivers/xen/sfc_netfront/ef_vi_falcon_event.h
--- a/drivers/xen/sfc_netfront/ef_vi_falcon_event.h
+++ /dev/null
@@ -1,123 +0,0 @@
-//////////////---- Events Format C Header ----//////////////
-//////////////---- Event entry ----//////////////
-  #define EV_CODE_LBN 60
-  #define EV_CODE_WIDTH 4
-      #define RX_IP_EV_DECODE 0
-      #define TX_IP_EV_DECODE 2
-      #define DRIVER_EV_DECODE 5
-      #define GLOBAL_EV_DECODE 6
-      #define DRV_GEN_EV_DECODE 7
-  #define EV_DATA_LBN 0
-  #define EV_DATA_WIDTH 60
-//////////////---- Receive IP events for both Kernel & User event queues ----//////////////
-  #define RX_EV_PKT_OK_LBN 56
-  #define RX_EV_PKT_OK_WIDTH 1
-  #define RX_EV_BUF_OWNER_ID_ERR_LBN 54
-  #define RX_EV_BUF_OWNER_ID_ERR_WIDTH 1
-  #define RX_EV_IP_HDR_CHKSUM_ERR_LBN 52
-  #define RX_EV_IP_HDR_CHKSUM_ERR_WIDTH 1
-  #define RX_EV_TCP_UDP_CHKSUM_ERR_LBN 51
-  #define RX_EV_TCP_UDP_CHKSUM_ERR_WIDTH 1
-  #define RX_EV_ETH_CRC_ERR_LBN 50
-  #define RX_EV_ETH_CRC_ERR_WIDTH 1
-  #define RX_EV_FRM_TRUNC_LBN 49
-  #define RX_EV_FRM_TRUNC_WIDTH 1
-  #define RX_EV_DRIB_NIB_LBN 48
-  #define RX_EV_DRIB_NIB_WIDTH 1
-  #define RX_EV_TOBE_DISC_LBN 47
-  #define RX_EV_TOBE_DISC_WIDTH 1
-  #define RX_EV_PKT_TYPE_LBN 44
-  #define RX_EV_PKT_TYPE_WIDTH 3
-      #define RX_EV_PKT_TYPE_ETH_DECODE 0
-      #define RX_EV_PKT_TYPE_LLC_DECODE 1
-      #define RX_EV_PKT_TYPE_JUMBO_DECODE 2
-      #define RX_EV_PKT_TYPE_VLAN_DECODE 3
-      #define RX_EV_PKT_TYPE_VLAN_LLC_DECODE 4
-      #define RX_EV_PKT_TYPE_VLAN_JUMBO_DECODE 5
-  #define RX_EV_HDR_TYPE_LBN 42
-  #define RX_EV_HDR_TYPE_WIDTH 2
-      #define RX_EV_HDR_TYPE_TCP_IPV4_DECODE 0
-      #define RX_EV_HDR_TYPE_UDP_IPV4_DECODE 1
-      #define RX_EV_HDR_TYPE_OTHER_IP_DECODE 2
-      #define RX_EV_HDR_TYPE_NON_IP_DECODE 3
-  #define RX_EV_DESC_Q_EMPTY_LBN 41
-  #define RX_EV_DESC_Q_EMPTY_WIDTH 1
-  #define RX_EV_MCAST_HASH_MATCH_LBN 40
-  #define RX_EV_MCAST_HASH_MATCH_WIDTH 1
-  #define RX_EV_MCAST_PKT_LBN 39
-  #define RX_EV_MCAST_PKT_WIDTH 1
-  #define RX_EV_Q_LABEL_LBN 32
-  #define RX_EV_Q_LABEL_WIDTH 5
-  #define RX_JUMBO_CONT_LBN 31
-  #define RX_JUMBO_CONT_WIDTH 1
-  #define RX_SOP_LBN 15
-  #define RX_SOP_WIDTH 1
-  #define RX_PORT_LBN 30
-  #define RX_PORT_WIDTH 1
-  #define RX_EV_BYTE_CNT_LBN 16
-  #define RX_EV_BYTE_CNT_WIDTH 14
-  #define RX_iSCSI_PKT_OK_LBN 14
-  #define RX_iSCSI_PKT_OK_WIDTH 1
-  #define RX_ISCSI_DDIG_ERR_LBN 13
-  #define RX_ISCSI_DDIG_ERR_WIDTH 1
-  #define RX_ISCSI_HDIG_ERR_LBN 12
-  #define RX_ISCSI_HDIG_ERR_WIDTH 1
-  #define RX_EV_DESC_PTR_LBN 0
-  #define RX_EV_DESC_PTR_WIDTH 12
-//////////////---- Transmit IP events for both Kernel & User event queues ----//////////////
-  #define TX_EV_PKT_ERR_LBN 38
-  #define TX_EV_PKT_ERR_WIDTH 1
-  #define TX_EV_PKT_TOO_BIG_LBN 37
-  #define TX_EV_PKT_TOO_BIG_WIDTH 1
-  #define TX_EV_Q_LABEL_LBN 32
-  #define TX_EV_Q_LABEL_WIDTH 5
-  #define TX_EV_PORT_LBN 16
-  #define TX_EV_PORT_WIDTH 1
-  #define TX_EV_WQ_FF_FULL_LBN 15
-  #define TX_EV_WQ_FF_FULL_WIDTH 1
-  #define TX_EV_BUF_OWNER_ID_ERR_LBN 14
-  #define TX_EV_BUF_OWNER_ID_ERR_WIDTH 1
-  #define TX_EV_COMP_LBN 12
-  #define TX_EV_COMP_WIDTH 1
-  #define TX_EV_DESC_PTR_LBN 0
-  #define TX_EV_DESC_PTR_WIDTH 12
-//////////////---- Char or Kernel driver events ----//////////////
-  #define DRIVER_EV_SUB_CODE_LBN 56
-  #define DRIVER_EV_SUB_CODE_WIDTH 4
-      #define TX_DESCQ_FLS_DONE_EV_DECODE 0x0
-      #define RX_DESCQ_FLS_DONE_EV_DECODE 0x1
-      #define EVQ_INIT_DONE_EV_DECODE 0x2
-      #define EVQ_NOT_EN_EV_DECODE 0x3
-      #define RX_DESCQ_FLSFF_OVFL_EV_DECODE 0x4
-      #define SRM_UPD_DONE_EV_DECODE 0x5
-      #define WAKE_UP_EV_DECODE 0x6
-      #define TX_PKT_NON_TCP_UDP_DECODE 0x9
-      #define TIMER_EV_DECODE 0xA
-      #define RX_DSC_ERROR_EV_DECODE 0xE
-  #define DRIVER_EV_TX_DESCQ_ID_LBN 0
-  #define DRIVER_EV_TX_DESCQ_ID_WIDTH 12
-  #define DRIVER_EV_RX_DESCQ_ID_LBN 0
-  #define DRIVER_EV_RX_DESCQ_ID_WIDTH 12
-  #define DRIVER_EV_EVQ_ID_LBN 0
-  #define DRIVER_EV_EVQ_ID_WIDTH 12
-  #define DRIVER_TMR_ID_LBN 0
-  #define DRIVER_TMR_ID_WIDTH 12
-  #define DRIVER_EV_SRM_UPD_LBN 0
-  #define DRIVER_EV_SRM_UPD_WIDTH 2
-      #define SRM_CLR_EV_DECODE 0
-      #define SRM_UPD_EV_DECODE 1
-      #define SRM_ILLCLR_EV_DECODE 2
-//////////////---- Global events. Sent to both event queue 0 and 4. ----//////////////
-  #define XFP_PHY_INTR_LBN 10
-  #define XFP_PHY_INTR_WIDTH 1
-  #define XG_PHY_INTR_LBN 9
-  #define XG_PHY_INTR_WIDTH 1
-  #define G_PHY1_INTR_LBN 8
-  #define G_PHY1_INTR_WIDTH 1
-  #define G_PHY0_INTR_LBN 7
-  #define G_PHY0_INTR_WIDTH 1
-//////////////---- Driver generated events ----//////////////
-  #define DRV_GEN_EV_CODE_LBN 60
-  #define DRV_GEN_EV_CODE_WIDTH 4
-  #define DRV_GEN_EV_DATA_LBN 0
-  #define DRV_GEN_EV_DATA_WIDTH 60
diff -r 9566a4a50a43 drivers/xen/sfc_netfront/ef_vi_internal.h
--- a/drivers/xen/sfc_netfront/ef_vi_internal.h
+++ /dev/null
@@ -1,256 +0,0 @@
-/****************************************************************************
- * Copyright 2002-2005: Level 5 Networks Inc.
- * Copyright 2005-2008: Solarflare Communications Inc,
- *                      9501 Jeronimo Road, Suite 250,
- *                      Irvine, CA 92618, USA
- *
- * Maintained by Solarflare Communications
- *  <linux-xen-drivers@solarflare.com>
- *  <onload-dev@solarflare.com>
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 as published
- * by the Free Software Foundation, incorporated herein by reference.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
- ****************************************************************************
- */
-
-/*
- * \author  djr
- *  \brief  Really-and-truely-honestly internal stuff for libef.
- *   \date  2004/06/13
- */
-
-/*! \cidoxg_include_ci_ul */
-#ifndef __CI_EF_VI_INTERNAL_H__
-#define __CI_EF_VI_INTERNAL_H__
-
-
-/* These flags share space with enum ef_vi_flags. */
-#define EF_VI_BUG5692_WORKAROUND  0x10000
-
-
-/* ***********************************************************************
- * COMPILATION CONTROL FLAGS (see ef_vi.h for "workaround" controls)
- */
-
-#define EF_VI_DO_MAGIC_CHECKS 1
-
-
-/**********************************************************************
- * Headers
- */
-
-#include <etherfabric/ef_vi.h>
-#include "sysdep.h"
-#include "ef_vi_falcon.h"
-
-
-/**********************************************************************
- * Debugging.
- */
-
-#ifndef NDEBUG
-
-# define _ef_assert(exp, file, line) BUG_ON(!(exp));
-
-# define _ef_assert2(exp, x, y, file, line)  do {	\
-		if (unlikely(!(exp)))		\
-			BUG();				\
-	} while (0)
-
-#else
-
-# define _ef_assert(exp, file, line)
-# define _ef_assert2(e, x, y, file, line)
-
-#endif
-
-#define ef_assert(a)          do{ _ef_assert((a),__FILE__,__LINE__); } while(0)
-#define ef_assert_equal(a,b)  _ef_assert2((a)==(b),(a),(b),__FILE__,__LINE__)
-#define ef_assert_eq          ef_assert_equal
-#define ef_assert_lt(a,b)     _ef_assert2((a)<(b),(a),(b),__FILE__,__LINE__)
-#define ef_assert_le(a,b)     _ef_assert2((a)<=(b),(a),(b),__FILE__,__LINE__)
-#define ef_assert_nequal(a,b) _ef_assert2((a)!=(b),(a),(b),__FILE__,__LINE__)
-#define ef_assert_ne          ef_assert_nequal
-#define ef_assert_ge(a,b)     _ef_assert2((a)>=(b),(a),(b),__FILE__,__LINE__)
-#define ef_assert_gt(a,b)     _ef_assert2((a)>(b),(a),(b),__FILE__,__LINE__)
-
-/**********************************************************************
- * Debug checks. ******************************************************
- **********************************************************************/
-
-#ifdef NDEBUG
-# define EF_VI_MAGIC_SET(p, type)
-# define EF_VI_CHECK_VI(p)
-# define EF_VI_CHECK_EVENT_Q(p)
-# define EF_VI_CHECK_IOBUFSET(p)
-# define EF_VI_CHECK_FILTER(p)
-# define EF_VI_CHECK_SHMBUF(p)
-# define EF_VI_CHECK_PT_EP(p)
-#else
-# define EF_VI                    0x3
-# define EF_EPLOCK                0x6
-# define EF_IOBUFSET              0x9
-# define EF_FILTER                0xa
-# define EF_SHMBUF                0x11
-
-# define EF_VI_MAGIC(p, type)				\
-	(((unsigned)(type) << 28) |			\
-	 (((unsigned)(intptr_t)(p)) & 0x0fffffffu))
-
-# if !EF_VI_DO_MAGIC_CHECKS
-#  define EF_VI_MAGIC_SET(p, type)
-#  define EF_VI_MAGIC_CHECK(p, type)
-# else
-#  define EF_VI_MAGIC_SET(p, type)			\
-	do {						\
-		(p)->magic = EF_VI_MAGIC((p), (type));	\
-	} while (0)
-
-# define EF_VI_MAGIC_OKAY(p, type)                      \
-	((p)->magic == EF_VI_MAGIC((p), (type)))
-
-# define EF_VI_MAGIC_CHECK(p, type)                     \
-	ef_assert(EF_VI_MAGIC_OKAY((p), (type)))
-
-#endif /* EF_VI_DO_MAGIC_CHECKS */
-
-# define EF_VI_CHECK_VI(p)			\
-	ef_assert(p);				\
-	EF_VI_MAGIC_CHECK((p), EF_VI);
-
-# define EF_VI_CHECK_EVENT_Q(p)			\
-	ef_assert(p);				\
-	EF_VI_MAGIC_CHECK((p), EF_VI);		\
-	ef_assert((p)->evq_base);		\
-	ef_assert((p)->evq_mask);
-
-# define EF_VI_CHECK_PT_EP(p)			\
-	ef_assert(p);				\
-	EF_VI_MAGIC_CHECK((p), EF_VI);		\
-	ef_assert((p)->ep_state);
-
-# define EF_VI_CHECK_IOBUFSET(p)		\
-	ef_assert(p);				\
-	EF_VI_MAGIC_CHECK((p), EF_IOBUFSET)
-
-# define EF_VI_CHECK_FILTER(p)			\
-	ef_assert(p);				\
-	EF_VI_MAGIC_CHECK((p), EF_FILTER);
-
-# define EF_VI_CHECK_SHMBUF(p)			\
-	ef_assert(p);				\
-	EF_VI_MAGIC_CHECK((p), EF_SHMBUF);
-
-#endif
-
-#ifndef NDEBUG
-# define EF_DRIVER_MAGIC 0x00f00ba4
-# define EF_ASSERT_THIS_DRIVER_VALID(driver)				\
-	do{ ef_assert(driver);						\
-		EF_VI_MAGIC_CHECK((driver), EF_DRIVER_MAGIC);		\
-		ef_assert((driver)->init);               }while(0)
-
-# define EF_ASSERT_DRIVER_VALID() EF_ASSERT_THIS_DRIVER_VALID(&ci_driver)
-#else
-# define EF_ASSERT_THIS_DRIVER_VALID(driver)
-# define EF_ASSERT_DRIVER_VALID()
-#endif
-
-
-/* *************************************
- * Power of 2 FIFO
- */
-
-#define EF_VI_FIFO2_M(f, x)  ((x) & ((f)->fifo_mask))
-#define ef_vi_fifo2_valid(f) ((f) && (f)->fifo && (f)->fifo_mask > 0 &&	\
-			      (f)->fifo_rd_i <= (f)->fifo_mask       &&	\
-			      (f)->fifo_wr_i <= (f)->fifo_mask       &&	\
-			      EF_VI_IS_POW2((f)->fifo_mask+1u))
-
-#define ef_vi_fifo2_init(f, cap)			\
-	do{ ef_assert(EF_VI_IS_POW2((cap) + 1));	\
-		(f)->fifo_rd_i = (f)->fifo_wr_i = 0u;	\
-		(f)->fifo_mask = (cap);			\
-	}while(0)
-
-#define ef_vi_fifo2_is_empty(f) ((f)->fifo_rd_i == (f)->fifo_wr_i)
-#define ef_vi_fifo2_capacity(f) ((f)->fifo_mask)
-#define ef_vi_fifo2_buf_size(f) ((f)->fifo_mask + 1u)
-#define ef_vi_fifo2_end(f)      ((f)->fifo + ef_vi_fifo2_buf_size(f))
-#define ef_vi_fifo2_peek(f)     ((f)->fifo[(f)->fifo_rd_i])
-#define ef_vi_fifo2_poke(f)     ((f)->fifo[(f)->fifo_wr_i])
-#define ef_vi_fifo2_num(f)   EF_VI_FIFO2_M((f),(f)->fifo_wr_i-(f)->fifo_rd_i)
-
-#define ef_vi_fifo2_wr_prev(f)						\
-	do{ (f)->fifo_wr_i = EF_VI_FIFO2_M((f), (f)->fifo_wr_i - 1u); }while(0)
-#define ef_vi_fifo2_wr_next(f)						\
-	do{ (f)->fifo_wr_i = EF_VI_FIFO2_M((f), (f)->fifo_wr_i + 1u); }while(0)
-#define ef_vi_fifo2_rd_adv(f, n)					\
-	do{ (f)->fifo_rd_i = EF_VI_FIFO2_M((f), (f)->fifo_rd_i + (n)); }while(0)
-#define ef_vi_fifo2_rd_prev(f)						\
-	do{ (f)->fifo_rd_i = EF_VI_FIFO2_M((f), (f)->fifo_rd_i - 1u); }while(0)
-#define ef_vi_fifo2_rd_next(f)						\
-	do{ (f)->fifo_rd_i = EF_VI_FIFO2_M((f), (f)->fifo_rd_i + 1u); }while(0)
-
-#define ef_vi_fifo2_put(f, v)						\
-	do{ ef_vi_fifo2_poke(f) = (v); ef_vi_fifo2_wr_next(f); }while(0)
-#define ef_vi_fifo2_get(f, pv)						\
-	do{ *(pv) = ef_vi_fifo2_peek(f); ef_vi_fifo2_rd_next(f); }while(0)
-
-
-/* *********************************************************************
- * Eventq handling
- */
-
-typedef union {
-	uint64_t    u64;
-	struct {
-		uint32_t  a;
-		uint32_t  b;
-	} opaque;
-} ef_vi_event;
-
-
-#define EF_VI_EVENT_OFFSET(q, i)					\
-	(((q)->evq_state->evq_ptr - (i) * sizeof(ef_vi_event)) & (q)->evq_mask)
-
-#define EF_VI_EVENT_PTR(q, i)                                           \
-	((ef_vi_event*) ((q)->evq_base + EF_VI_EVENT_OFFSET((q), (i))))
-
-/* *********************************************************************
- * Miscellaneous goodies
- */
-#ifdef NDEBUG
-# define EF_VI_DEBUG(x)
-#else
-# define EF_VI_DEBUG(x)            x
-#endif
-
-#define EF_VI_ROUND_UP(i, align)   (((i)+(align)-1u) & ~((align)-1u))
-#define EF_VI_ALIGN_FWD(p, align)  (((p)+(align)-1u) & ~((align)-1u))
-#define EF_VI_ALIGN_BACK(p, align) ((p) & ~((align)-1u))
-#define EF_VI_PTR_ALIGN_BACK(p, align)					\
-	((char*)EF_VI_ALIGN_BACK(((intptr_t)(p)), ((intptr_t)(align))))
-#define EF_VI_IS_POW2(x)           ((x) && ! ((x) & ((x) - 1)))
-
-
-/* ******************************************************************** 
- */
-
-extern void falcon_vi_init(ef_vi*, void* vvis ) EF_VI_HF;
-extern void ef_eventq_state_init(ef_vi* evq) EF_VI_HF;
-extern void __ef_init(void) EF_VI_HF;
-
-
-#endif  /* __CI_EF_VI_INTERNAL_H__ */
-
diff -r 9566a4a50a43 drivers/xen/sfc_netfront/etherfabric/ef_vi.h
--- a/drivers/xen/sfc_netfront/etherfabric/ef_vi.h
+++ /dev/null
@@ -1,647 +0,0 @@
-/****************************************************************************
- * Copyright 2002-2005: Level 5 Networks Inc.
- * Copyright 2005-2008: Solarflare Communications Inc,
- *                      9501 Jeronimo Road, Suite 250,
- *                      Irvine, CA 92618, USA
- *
- * Maintained by Solarflare Communications
- *  <linux-xen-drivers@solarflare.com>
- *  <onload-dev@solarflare.com>
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 as published
- * by the Free Software Foundation, incorporated herein by reference.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
- ****************************************************************************
- */
-
-/*
- *  \brief  Virtual Interface
- *   \date  2007/05/16
- */
-
-#ifndef __EFAB_EF_VI_H__
-#define __EFAB_EF_VI_H__
-
-
-/**********************************************************************
- * Primitive types ****************************************************
- **********************************************************************/
-
-/* We standardise on the types from stdint.h and synthesise these types
- * for compilers/platforms that don't provide them */
-
-#  include <linux/types.h>
-# define EF_VI_ALIGN(x) __attribute__ ((aligned (x)))
-# define ef_vi_inline static inline
-
-
-
-/**********************************************************************
- * Types **************************************************************
- **********************************************************************/
-
-typedef uint32_t                ef_eventq_ptr;
-
-typedef uint64_t                ef_addr;
-typedef char*                   ef_vi_ioaddr_t;
-
-/**********************************************************************
- * ef_event ***********************************************************
- **********************************************************************/
-
-/*! \i_ef_vi A DMA request identifier.
-**
-** This is an integer token specified by the transport and associated
-** with a DMA request.  It is returned to the VI user with DMA completion
-** events.  It is typically used to identify the buffer associated with
-** the transfer.
-*/
-typedef int			ef_request_id;
-
-typedef union {
-	uint64_t  u64[1];
-	uint32_t  u32[2];
-} ef_vi_qword;
-
-typedef ef_vi_qword             ef_hw_event;
-
-#define EF_REQUEST_ID_BITS      16u
-#define EF_REQUEST_ID_MASK      ((1u << EF_REQUEST_ID_BITS) - 1u)
-
-/*! \i_ef_event An [ef_event] is a token that identifies something that
-** has happened.  Examples include packets received, packets transmitted
-** and errors.
-*/
-typedef union {
-	struct {
-		ef_hw_event    ev;
-		unsigned       type       :16;
-	} generic;
-	struct {
-		ef_hw_event    ev;
-		unsigned       type       :16;
-		/*ef_request_id  request_id :EF_REQUEST_ID_BITS;*/
-		unsigned       q_id       :16;
-		unsigned       len        :16;
-		unsigned       flags      :16;
-	} rx;
-	struct {  /* This *must* have same layout as [rx]. */
-		ef_hw_event    ev;
-		unsigned       type       :16;
-		/*ef_request_id  request_id :EF_REQUEST_ID_BITS;*/
-		unsigned       q_id       :16;
-		unsigned       len        :16;
-		unsigned       flags      :16;
-		unsigned       subtype    :16;
-	} rx_discard;
-	struct {
-		ef_hw_event    ev;
-		unsigned       type       :16;
-		/*ef_request_id  request_id :EF_REQUEST_ID_BITS;*/
-		unsigned       q_id       :16;
-	} tx;
-	struct {
-		ef_hw_event    ev;
-		unsigned       type       :16;
-		/*ef_request_id  request_id :EF_REQUEST_ID_BITS;*/
-		unsigned       q_id       :16;
-		unsigned       subtype    :16;
-	} tx_error;
-	struct {
-		ef_hw_event    ev;
-		unsigned       type       :16;
-		unsigned       q_id       :16;
-	} rx_no_desc_trunc;
-	struct {
-		ef_hw_event    ev;
-		unsigned       type       :16;
-		unsigned       data;
-	} sw;
-} ef_event;
-
-
-#define EF_EVENT_TYPE(e)        ((e).generic.type)
-enum {
-	/** Good data was received. */
-	EF_EVENT_TYPE_RX,
-	/** Packets have been sent. */
-	EF_EVENT_TYPE_TX,
-	/** Data received and buffer consumed, but something is wrong. */
-	EF_EVENT_TYPE_RX_DISCARD,
-	/** Transmit of packet failed. */
-	EF_EVENT_TYPE_TX_ERROR,
-	/** Received packet was truncated due to lack of descriptors. */
-	EF_EVENT_TYPE_RX_NO_DESC_TRUNC,
-	/** Software generated event. */
-	EF_EVENT_TYPE_SW,
-	/** Event queue overflow. */
-	EF_EVENT_TYPE_OFLOW,
-};
-
-#define EF_EVENT_RX_BYTES(e)    ((e).rx.len)
-#define EF_EVENT_RX_Q_ID(e)     ((e).rx.q_id)
-#define EF_EVENT_RX_CONT(e)     ((e).rx.flags & EF_EVENT_FLAG_CONT)
-#define EF_EVENT_RX_SOP(e)      ((e).rx.flags & EF_EVENT_FLAG_SOP)
-#define EF_EVENT_RX_ISCSI_OKAY(e) ((e).rx.flags & EF_EVENT_FLAG_ISCSI_OK)
-#define EF_EVENT_FLAG_SOP       0x1
-#define EF_EVENT_FLAG_CONT      0x2
-#define EF_EVENT_FLAG_ISCSI_OK  0x4
-
-#define EF_EVENT_TX_Q_ID(e)     ((e).tx.q_id)
-
-#define EF_EVENT_RX_DISCARD_Q_ID(e)  ((e).rx_discard.q_id)
-#define EF_EVENT_RX_DISCARD_LEN(e)   ((e).rx_discard.len)
-#define EF_EVENT_RX_DISCARD_TYPE(e)  ((e).rx_discard.subtype)
-enum {
-	EF_EVENT_RX_DISCARD_CSUM_BAD,
-	EF_EVENT_RX_DISCARD_CRC_BAD,
-	EF_EVENT_RX_DISCARD_TRUNC,
-	EF_EVENT_RX_DISCARD_RIGHTS,
-	EF_EVENT_RX_DISCARD_OTHER,
-};
-
-#define EF_EVENT_TX_ERROR_Q_ID(e)    ((e).tx_error.q_id)
-#define EF_EVENT_TX_ERROR_TYPE(e)    ((e).tx_error.subtype)
-enum {
-	EF_EVENT_TX_ERROR_RIGHTS,
-	EF_EVENT_TX_ERROR_OFLOW,
-	EF_EVENT_TX_ERROR_2BIG,
-	EF_EVENT_TX_ERROR_BUS,
-};
-
-#define EF_EVENT_RX_NO_DESC_TRUNC_Q_ID(e)  ((e).rx_no_desc_trunc.q_id)
-
-#define EF_EVENT_SW_DATA_MASK   0xffff
-#define EF_EVENT_SW_DATA(e)     ((e).sw.data)
-
-#define EF_EVENT_FMT            "[ev:%x:%08x:%08x]"
-#define EF_EVENT_PRI_ARG(e)     (unsigned) (e).generic.type,    \
-		(unsigned) (e).generic.ev.u32[1],		\
-		(unsigned) (e).generic.ev.u32[0]
-
-#define EF_GET_HW_EV(e)         ((e).generic.ev)
-#define EF_GET_HW_EV_PTR(e)     (&(e).generic.ev)
-#define EF_GET_HW_EV_U64(e)     ((e).generic.ev.u64[0])
-
-
-/* ***************** */
-
-/*! Used by netif shared state. Must use types of explicit size. */
-typedef struct {
-	uint16_t              rx_last_desc_ptr;   /* for RX duplicates       */
-	uint8_t               bad_sop;            /* bad SOP detected        */
-	uint8_t               frag_num;           /* next fragment #, 0=>SOP */
-} ef_rx_dup_state_t;
-
-
-/* Max number of ports on any SF NIC. */
-#define EFAB_DMAQS_PER_EVQ_MAX 32
-
-typedef struct {
-	ef_eventq_ptr	        evq_ptr;
-	int32_t               trashed;
-	ef_rx_dup_state_t     rx_dup_state[EFAB_DMAQS_PER_EVQ_MAX];
-} ef_eventq_state;
-
-
-/*! \i_ef_base [ef_iovec] is similar the standard [struct iovec].  An
-** array of these is used to designate a scatter/gather list of I/O
-** buffers.
-*/
-typedef struct {
-	ef_addr                       iov_base EF_VI_ALIGN(8);
-	unsigned                      iov_len;
-} ef_iovec;
-
-/* Falcon constants */
-#define TX_EV_DESC_PTR_LBN 0
-
-
-/**********************************************************************
- * ef_vi **************************************************************
- **********************************************************************/
-
-enum ef_vi_flags {
-	EF_VI_RX_SCATTER        = 0x1,
-	EF_VI_ISCSI_RX_HDIG     = 0x2,
-	EF_VI_ISCSI_TX_HDIG     = 0x4,
-	EF_VI_ISCSI_RX_DDIG     = 0x8,
-	EF_VI_ISCSI_TX_DDIG     = 0x10,
-	EF_VI_TX_PHYS_ADDR      = 0x20,
-	EF_VI_RX_PHYS_ADDR      = 0x40,
-	EF_VI_TX_IP_CSUM_DIS    = 0x80,
-	EF_VI_TX_TCPUDP_CSUM_DIS= 0x100,
-	EF_VI_TX_TCPUDP_ONLY    = 0x200,
-	/* Flags in range 0xXXXX0000 are for internal use. */
-};
-
-typedef struct {
-	uint32_t  added;
-	uint32_t  removed;
-} ef_vi_txq_state;
-
-typedef struct {
-	uint32_t  added;
-	uint32_t  removed;
-} ef_vi_rxq_state;
-
-typedef struct {
-	uint32_t         mask;
-	void*            doorbell;
-	void*            descriptors;
-	uint16_t*        ids;
-	unsigned         misalign_mask;
-} ef_vi_txq;
-
-typedef struct {
-	uint32_t         mask;
-	void*            doorbell;
-	void*            descriptors;
-	uint16_t*        ids;
-} ef_vi_rxq;
-
-typedef struct {
-	ef_eventq_state  evq;
-	ef_vi_txq_state  txq;
-	ef_vi_rxq_state  rxq;
-	/* Followed by request id fifos. */
-} ef_vi_state;
-
-/*! \i_ef_vi  A virtual interface.
-**
-** An [ef_vi] represents a virtual interface on a specific NIC.  A
-** virtual interface is a collection of an event queue and two DMA queues
-** used to pass Ethernet frames between the transport implementation and
-** the network.
-*/
-typedef struct ef_vi {
-	unsigned			magic;
-
-	unsigned                      vi_resource_id;
-	unsigned                      vi_resource_handle_hack;
-	unsigned                      vi_i;
-
-	char*				vi_mem_mmap_ptr;
-	int                           vi_mem_mmap_bytes;
-	char*				vi_io_mmap_ptr;
-	int                           vi_io_mmap_bytes;
-
-	ef_eventq_state*              evq_state;
-	char*                         evq_base;
-	unsigned                      evq_mask;
-	ef_vi_ioaddr_t                evq_timer_reg;
-
-	ef_vi_txq                     vi_txq;
-	ef_vi_rxq                     vi_rxq;
-	ef_vi_state*                  ep_state;
-	enum ef_vi_flags              vi_flags;
-} ef_vi;
-
-
-enum ef_vi_arch {
-	EF_VI_ARCH_FALCON,
-};
-
-
-struct ef_vi_nic_type {
-	unsigned char  arch;
-	char           variant;
-	unsigned char  revision;
-};
-
-
-/* This structure is opaque to the client & used to pass mapping data
- * from the resource manager to the ef_vi lib. for ef_vi_init().
- */
-struct vi_mappings {
-	uint32_t         signature;
-# define VI_MAPPING_VERSION   0x02  /*Byte: Increment me if struct altered*/
-# define VI_MAPPING_SIGNATURE (0xBA1150 + VI_MAPPING_VERSION)
-
-	struct ef_vi_nic_type nic_type;
-
-	int              vi_instance;
-
-	unsigned         evq_bytes;
-	char*            evq_base;
-	ef_vi_ioaddr_t   evq_timer_reg;
-
-	unsigned         rx_queue_capacity;
-	ef_vi_ioaddr_t   rx_dma_ef1;
-	char*            rx_dma_falcon;
-	ef_vi_ioaddr_t   rx_bell;
-
-	unsigned         tx_queue_capacity;
-	ef_vi_ioaddr_t   tx_dma_ef1;
-	char*            tx_dma_falcon;
-	ef_vi_ioaddr_t   tx_bell;
-};
-/* This is used by clients to allocate a suitably sized buffer for the 
- * resource manager to fill & ef_vi_init() to use. */
-#define VI_MAPPINGS_SIZE (sizeof(struct vi_mappings))
-
-
-/**********************************************************************
- * ef_config **********************************************************
- **********************************************************************/
-
-struct ef_config_t {
-	int   log;                    /* debug logging level          */
-};
-
-extern struct ef_config_t  ef_config;
-
-
-/**********************************************************************
- * ef_vi **************************************************************
- **********************************************************************/
-
-/* Initialise [data_area] with information required to initialise an ef_vi.
- * In the following, an unused param should be set to NULL. Note the case
- * marked (*) of [iobuf_mmap] for falcon/driver; for normal driver this
- * must be NULL.
- *
- * \param  data_area     [in,out] required, must ref at least VI_MAPPINGS_SIZE 
- *                                bytes
- * \param  evq_capacity  [in] number of events in event queue.  Specify 0 for
- *                            no event queue.
- * \param  rxq_capacity  [in] number of descriptors in RX DMA queue.  Specify
- *                            0 for no RX queue.
- * \param  txq_capacity  [in] number of descriptors in TX DMA queue.  Specify
- *                            0 for no TX queue.
- * \param  mmap_info     [in] mem-map info for resource
- * \param  io_mmap       [in] ef1,    required
- *                            falcon, required
- * \param  iobuf_mmap    [in] ef1,    UL: unused
- *                            falcon, UL: required
- */
-extern void ef_vi_init_mapping_vi(void* data_area, struct ef_vi_nic_type,
-                                  unsigned rxq_capacity,
-                                  unsigned txq_capacity, int instance,
-                                  void* io_mmap, void* iobuf_mmap_rx,
-                                  void* iobuf_mmap_tx, enum ef_vi_flags);
-
-
-extern void ef_vi_init_mapping_evq(void* data_area, struct ef_vi_nic_type,
-                                   int instance, unsigned evq_bytes,
-                                   void* base, void* timer_reg);
-
-ef_vi_inline unsigned ef_vi_resource_id(ef_vi* vi)
-{ 
-	return vi->vi_resource_id; 
-}
-
-ef_vi_inline enum ef_vi_flags ef_vi_flags(ef_vi* vi)
-{ 
-	return vi->vi_flags; 
-}
-
-
-/**********************************************************************
- * Receive interface **************************************************
- **********************************************************************/
-
-/*! \i_ef_vi Returns the amount of space in the RX descriptor ring.
-**
-** \return the amount of space in the queue.
-*/
-ef_vi_inline int ef_vi_receive_space(ef_vi* vi) 
-{
-	ef_vi_rxq_state* qs = &vi->ep_state->rxq;
-	return vi->vi_rxq.mask - (qs->added - qs->removed);
-}
-
-
-/*! \i_ef_vi Returns the fill level of the RX descriptor ring.
-**
-** \return the fill level of the queue.
-*/
-ef_vi_inline int ef_vi_receive_fill_level(ef_vi* vi) 
-{
-	ef_vi_rxq_state* qs = &vi->ep_state->rxq;
-	return qs->added - qs->removed;
-}
-
-
-ef_vi_inline int ef_vi_receive_capacity(ef_vi* vi)
-{ 
-	return vi->vi_rxq.mask;
-}
-
-/*! \i_ef_vi  Complete a receive operation.
-**
-** When a receive completion event is received, it should be passed to
-** this function.  The request-id for the buffer that the packet was
-** delivered to is returned.
-**
-** After this function returns, more space may be available in the
-** receive queue.
-*/
-extern ef_request_id ef_vi_receive_done(const ef_vi*, const ef_event*);
-
-/*! \i_ef_vi  Return request ID indicated by a receive event
- */
-ef_vi_inline ef_request_id ef_vi_receive_request_id(const ef_vi* vi,
-                                                    const ef_event* ef_ev)
-{
-	const ef_vi_qword* ev = EF_GET_HW_EV_PTR(*ef_ev);
-	return ev->u32[0] & vi->vi_rxq.mask;
-}
-  
-
-/*! \i_ef_vi  Form a receive descriptor.
-**
-** If \c initial_rx_bytes is zero use a reception size at least as large
-** as an MTU.
-*/
-extern int ef_vi_receive_init(ef_vi* vi, ef_addr addr, ef_request_id dma_id,
-                              int intial_rx_bytes);
-
-/*! \i_ef_vi  Submit initialised receive descriptors to the NIC. */
-extern void ef_vi_receive_push(ef_vi* vi);
-
-/*! \i_ef_vi  Post a buffer on the receive queue.
-**
-**   \return 0 on success, or -EAGAIN if the receive queue is full
-*/
-extern int ef_vi_receive_post(ef_vi*, ef_addr addr,
-			      ef_request_id dma_id);
-
-/**********************************************************************
- * Transmit interface *************************************************
- **********************************************************************/
-
-/*! \i_ef_vi Return the amount of space (in descriptors) in the transmit
-**           queue.
-**
-** \return the amount of space in the queue (in descriptors)
-*/
-ef_vi_inline int ef_vi_transmit_space(ef_vi* vi) 
-{
-	ef_vi_txq_state* qs = &vi->ep_state->txq;
-	return vi->vi_txq.mask - (qs->added - qs->removed);
-}
-
-
-/*! \i_ef_vi Returns the fill level of the TX descriptor ring.
-**
-** \return the fill level of the queue.
-*/
-ef_vi_inline int ef_vi_transmit_fill_level(ef_vi* vi)
-{
-	ef_vi_txq_state* qs = &vi->ep_state->txq;
-	return qs->added - qs->removed;
-}
-
-
-/*! \i_ef_vi Returns the total capacity of the TX descriptor ring.
-**
-** \return the capacity of the queue.
-*/
-ef_vi_inline int ef_vi_transmit_capacity(ef_vi* vi)
-{ 
-	return vi->vi_txq.mask;
-}
-
-
-/*! \i_ef_vi  Transmit a packet.
-**
-**   \param bytes must be greater than ETH_ZLEN.
-**   \return -EAGAIN if the transmit queue is full, or 0 on success
-*/
-extern int ef_vi_transmit(ef_vi*, ef_addr, int bytes, ef_request_id dma_id);
-
-/*! \i_ef_vi  Transmit a packet using a gather list.
-**
-**   \param iov_len must be greater than zero
-**   \param iov the first must be non-zero in length (but others need not)
-**
-**   \return -EAGAIN if the queue is full, or 0 on success
-*/
-extern int ef_vi_transmitv(ef_vi*, const ef_iovec* iov, int iov_len,
-                           ef_request_id dma_id);
-
-/*! \i_ef_vi  Initialise a DMA request.
-**
-** \return -EAGAIN if the queue is full, or 0 on success
-*/
-extern int ef_vi_transmit_init(ef_vi*, ef_addr, int bytes,
-                               ef_request_id dma_id);
-
-/*! \i_ef_vi  Initialise a DMA request.
-**
-** \return -EAGAIN if the queue is full, or 0 on success
-*/
-extern int ef_vi_transmitv_init(ef_vi*, const ef_iovec*, int iov_len,
-                                ef_request_id dma_id);
-
-/*! \i_ef_vi  Submit DMA requests to the NIC.
-**
-** The DMA requests must have been initialised using
-** ef_vi_transmit_init() or ef_vi_transmitv_init().
-*/
-extern void ef_vi_transmit_push(ef_vi*);
-
-
-/*! \i_ef_vi Maximum number of transmit completions per transmit event. */
-#define EF_VI_TRANSMIT_BATCH  64
-
-/*! \i_ef_vi Determine the set of [ef_request_id]s for each DMA request
-**           which has been completed by a given transmit completion
-**           event.
-**
-** \param ids must point to an array of length EF_VI_TRANSMIT_BATCH
-** \return the number of valid [ef_request_id]s (can be zero)
-*/
-extern int ef_vi_transmit_unbundle(ef_vi* ep, const ef_event*,
-                                   ef_request_id* ids);
-
-
-/*! \i_ef_event Returns true if ef_eventq_poll() will return event(s). */
-extern int ef_eventq_has_event(ef_vi* vi);
-
-/*! \i_ef_event Returns true if there are quite a few events in the event
-** queue.
-**
-** This looks ahead in the event queue, so has the property that it will
-** not ping-pong a cache-line when it is called concurrently with events
-** being delivered.
-*/
-extern int ef_eventq_has_many_events(ef_vi* evq, int look_ahead);
-
-/*! Type of function to handle unknown events arriving on event queue
-**  Return CI_TRUE iff the event has been handled.
-*/
-typedef int/*bool*/ ef_event_handler_fn(void* priv, ef_vi* evq, ef_event* ev);
-
-/*! Standard poll exception routine */
-extern int/*bool*/ ef_eventq_poll_exception(void* priv, ef_vi* evq,
-                                            ef_event* ev);
-
-/*! \i_ef_event  Retrieve events from the event queue, handle RX/TX events
-**  and pass any others to an exception handler function
-**
-**   \return The number of events retrieved.
-*/
-extern int ef_eventq_poll_evs(ef_vi* evq, ef_event* evs, int evs_len,
-                              ef_event_handler_fn *exception, void *expt_priv);
-
-/*! \i_ef_event  Retrieve events from the event queue.
-**
-**   \return The number of events retrieved.
-*/
-ef_vi_inline int ef_eventq_poll(ef_vi* evq, ef_event* evs, int evs_len)
-{
-	return ef_eventq_poll_evs(evq, evs, evs_len,
-                            &ef_eventq_poll_exception, (void*)0);
-}
-
-/*! \i_ef_event Returns the capacity of an event queue. */
-ef_vi_inline int ef_eventq_capacity(ef_vi* vi) 
-{
-	return (vi->evq_mask + 1u) / sizeof(ef_hw_event);
-}
-
-/* Returns the instance ID of [vi] */
-ef_vi_inline unsigned ef_vi_instance(ef_vi* vi)
-{ return vi->vi_i; }
-
-
-/**********************************************************************
- * Initialisation *****************************************************
- **********************************************************************/
-
-/*! Return size of state buffer of an initialised VI. */
-extern int ef_vi_state_bytes(ef_vi*);
-
-/*! Return size of buffer needed for VI state given sizes of RX and TX
-** DMA queues.  Queue sizes must be legal sizes (power of 2), or 0 (no
-** queue).
-*/
-extern int ef_vi_calc_state_bytes(int rxq_size, int txq_size);
-
-/*! Initialise [ef_vi] from the provided resources. [vvis] must have been
-** created by ef_make_vi_data() & remains owned by the caller.
-*/
-extern void ef_vi_init(ef_vi*, void* vi_info, ef_vi_state* state,
-                       ef_eventq_state* evq_state, enum ef_vi_flags);
-
-extern void ef_vi_state_init(ef_vi*);
-extern void ef_eventq_state_init(ef_vi*);
-
-/*! Convert an efhw device arch to ef_vi_arch, or returns -1 if not
-** recognised.
-*/
-extern int  ef_vi_arch_from_efhw_arch(int efhw_arch);
-
-
-#endif /* __EFAB_EF_VI_H__ */
diff -r 9566a4a50a43 drivers/xen/sfc_netfront/falcon_event.c
--- a/drivers/xen/sfc_netfront/falcon_event.c
+++ /dev/null
@@ -1,346 +0,0 @@
-/****************************************************************************
- * Copyright 2002-2005: Level 5 Networks Inc.
- * Copyright 2005-2008: Solarflare Communications Inc,
- *                      9501 Jeronimo Road, Suite 250,
- *                      Irvine, CA 92618, USA
- *
- * Maintained by Solarflare Communications
- *  <linux-xen-drivers@solarflare.com>
- *  <onload-dev@solarflare.com>
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 as published
- * by the Free Software Foundation, incorporated herein by reference.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
- ****************************************************************************
- */
-
-/*
- * \author  djr
- *  \brief  Routine to poll event queues.
- *   \date  2003/03/04
- */
-
-/*! \cidoxg_lib_ef */
-#include "ef_vi_internal.h"
-
-/* Be worried about this on byteswapped machines */
-/* Due to crazy chipsets, we see the event words being written in
-** arbitrary order (bug4539).  So test for presence of event must ensure
-** that both halves have changed from the null.
-*/
-# define EF_VI_IS_EVENT(evp)						\
-	( (((evp)->opaque.a != (uint32_t)-1) &&				\
-	   ((evp)->opaque.b != (uint32_t)-1)) )
-
-
-#ifdef NDEBUG
-# define IS_DEBUG 0
-#else
-# define IS_DEBUG 1
-#endif
-
-
-/*! Check for RX events with inconsistent SOP/CONT
-**
-** Returns true if this event should be discarded
-*/
-ef_vi_inline int ef_eventq_is_rx_sop_cont_bad_efab(ef_vi* vi,
-						   const ef_vi_qword* ev)
-{
-	ef_rx_dup_state_t* rx_dup_state;
-	uint8_t* bad_sop;
-
-	unsigned label = QWORD_GET_U(RX_EV_Q_LABEL, *ev);
-	unsigned sop   = QWORD_TEST_BIT(RX_SOP, *ev);
-  
-	ef_assert(vi);
-	ef_assert_lt(label, EFAB_DMAQS_PER_EVQ_MAX);
-
-	rx_dup_state = &vi->evq_state->rx_dup_state[label];
-	bad_sop = &rx_dup_state->bad_sop;
-
-	if( ! ((vi->vi_flags & EF_VI_BUG5692_WORKAROUND) || IS_DEBUG) ) {
-		*bad_sop = (*bad_sop && !sop);
-	}
-	else {
-		unsigned cont  = QWORD_TEST_BIT(RX_JUMBO_CONT, *ev);
-		uint8_t *frag_num = &rx_dup_state->frag_num;
-
-		/* bad_sop should latch till the next sop */
-		*bad_sop = (*bad_sop && !sop) || ( !!sop != (*frag_num==0) );
-
-		/* we do not check the number of bytes relative to the
-		 * fragment number and size of the user rx buffer here
-		 * because we don't know the size of the user rx
-		 * buffer - we probably should perform this check in
-		 * the nearest code calling this though.
-		 */
-		*frag_num = cont ? (*frag_num + 1) : 0;
-	}
-
-	return *bad_sop;
-}
-
-
-ef_vi_inline int falcon_rx_check_dup(ef_vi* evq, ef_event* ev_out,
-				     const ef_vi_qword* ev)
-{
-	unsigned q_id = QWORD_GET_U(RX_EV_Q_LABEL, *ev);
-	uint16_t desc_ptr = QWORD_GET_U(RX_EV_DESC_PTR, *ev);
-	ef_rx_dup_state_t* rx_dup_state = &evq->evq_state->rx_dup_state[q_id];
-
-	if(likely( desc_ptr != rx_dup_state->rx_last_desc_ptr )) {
-		rx_dup_state->rx_last_desc_ptr = desc_ptr;
-		return 0;
-	}
-
-	rx_dup_state->rx_last_desc_ptr = desc_ptr;
-	rx_dup_state->bad_sop = 1;
-#ifndef NDEBUG
-	rx_dup_state->frag_num = 0;
-#endif
-	BUG_ON(!QWORD_TEST_BIT(RX_EV_FRM_TRUNC, *ev));
-	BUG_ON( QWORD_TEST_BIT(RX_EV_PKT_OK, *ev));
-	BUG_ON(!QWORD_GET_U(RX_EV_BYTE_CNT, *ev) == 0);
-	ev_out->rx_no_desc_trunc.type = EF_EVENT_TYPE_RX_NO_DESC_TRUNC;
-	ev_out->rx_no_desc_trunc.q_id = q_id;
-	return 1;
-}
-
-
-ef_vi_inline void falcon_rx_event(ef_event* ev_out, const ef_vi_qword* ev)
-{
-	if(likely( QWORD_TEST_BIT(RX_EV_PKT_OK, *ev) )) {
-		ev_out->rx.type = EF_EVENT_TYPE_RX;
-		ev_out->rx.q_id = QWORD_GET_U(RX_EV_Q_LABEL, *ev);
-		ev_out->rx.len  = QWORD_GET_U(RX_EV_BYTE_CNT, *ev);
-		if( QWORD_TEST_BIT(RX_SOP, *ev) )
-			ev_out->rx.flags = EF_EVENT_FLAG_SOP;
-		else
-			ev_out->rx.flags = 0;
-		if( QWORD_TEST_BIT(RX_JUMBO_CONT, *ev) )
-			ev_out->rx.flags |= EF_EVENT_FLAG_CONT;
-		if( QWORD_TEST_BIT(RX_iSCSI_PKT_OK, *ev) )
-			ev_out->rx.flags |= EF_EVENT_FLAG_ISCSI_OK;
-	}
-	else {
-		ev_out->rx_discard.type = EF_EVENT_TYPE_RX_DISCARD;
-		ev_out->rx_discard.q_id = QWORD_GET_U(RX_EV_Q_LABEL, *ev);
-		ev_out->rx_discard.len  = QWORD_GET_U(RX_EV_BYTE_CNT, *ev);
-#if 1  /* hack for ptloop compatability: ?? TODO purge */
-		if( QWORD_TEST_BIT(RX_SOP, *ev) )
-			ev_out->rx_discard.flags = EF_EVENT_FLAG_SOP;
-		else
-			ev_out->rx_discard.flags = 0;
-		if( QWORD_TEST_BIT(RX_JUMBO_CONT, *ev) )
-			ev_out->rx_discard.flags |= EF_EVENT_FLAG_CONT;
-		if( QWORD_TEST_BIT(RX_iSCSI_PKT_OK, *ev) )
-			ev_out->rx_discard.flags |= EF_EVENT_FLAG_ISCSI_OK;
-#endif
-		/* Order matters here: more fundamental errors first. */
-		if( QWORD_TEST_BIT(RX_EV_BUF_OWNER_ID_ERR, *ev) )
-			ev_out->rx_discard.subtype = 
-				EF_EVENT_RX_DISCARD_RIGHTS;
-		else if( QWORD_TEST_BIT(RX_EV_FRM_TRUNC, *ev) )
-			ev_out->rx_discard.subtype = 
-				EF_EVENT_RX_DISCARD_TRUNC;
-		else if( QWORD_TEST_BIT(RX_EV_ETH_CRC_ERR, *ev) )
-			ev_out->rx_discard.subtype = 
-				EF_EVENT_RX_DISCARD_CRC_BAD;
-		else if( QWORD_TEST_BIT(RX_EV_IP_HDR_CHKSUM_ERR, *ev) )
-			ev_out->rx_discard.subtype = 
-				EF_EVENT_RX_DISCARD_CSUM_BAD;
-		else if( QWORD_TEST_BIT(RX_EV_TCP_UDP_CHKSUM_ERR, *ev) )
-			ev_out->rx_discard.subtype = 
-				EF_EVENT_RX_DISCARD_CSUM_BAD;
-		else
-			ev_out->rx_discard.subtype = 
-				EF_EVENT_RX_DISCARD_OTHER;
-	}
-}
-
-
-ef_vi_inline void falcon_tx_event(ef_event* ev_out, const ef_vi_qword* ev)
-{
-	/* Danger danger!  No matter what we ask for wrt batching, we
-	** will get a batched event every 16 descriptors, and we also
-	** get dma-queue-empty events.  i.e. Duplicates are expected.
-	**
-	** In addition, if it's been requested in the descriptor, we
-	** get an event per descriptor.  (We don't currently request
-	** this).
-	*/
-	if(likely( QWORD_TEST_BIT(TX_EV_COMP, *ev) )) {
-		ev_out->tx.type = EF_EVENT_TYPE_TX;
-		ev_out->tx.q_id = QWORD_GET_U(TX_EV_Q_LABEL, *ev);
-	}
-	else {
-		ev_out->tx_error.type = EF_EVENT_TYPE_TX_ERROR;
-		ev_out->tx_error.q_id = QWORD_GET_U(TX_EV_Q_LABEL, *ev);
-		if(likely( QWORD_TEST_BIT(TX_EV_BUF_OWNER_ID_ERR, *ev) ))
-			ev_out->tx_error.subtype = EF_EVENT_TX_ERROR_RIGHTS;
-		else if(likely( QWORD_TEST_BIT(TX_EV_WQ_FF_FULL, *ev) ))
-			ev_out->tx_error.subtype = EF_EVENT_TX_ERROR_OFLOW;
-		else if(likely( QWORD_TEST_BIT(TX_EV_PKT_TOO_BIG, *ev) ))
-			ev_out->tx_error.subtype = EF_EVENT_TX_ERROR_2BIG;
-		else if(likely( QWORD_TEST_BIT(TX_EV_PKT_ERR, *ev) ))
-			ev_out->tx_error.subtype = EF_EVENT_TX_ERROR_BUS;
-	}
-}
-
-
-static void mark_bad(ef_event* ev)
-{
-	ev->generic.ev.u64[0] &=~ ((uint64_t) 1u << RX_EV_PKT_OK_LBN);
-}
-
-
-int ef_eventq_poll_evs(ef_vi* evq, ef_event* evs, int evs_len,
-		       ef_event_handler_fn *exception, void *expt_priv)
-{
-	int evs_len_orig = evs_len;
-
-	EF_VI_CHECK_EVENT_Q(evq);
-	ef_assert(evs);
-	ef_assert_gt(evs_len, 0);
-
-	if(unlikely( EF_VI_IS_EVENT(EF_VI_EVENT_PTR(evq, 1)) ))
-		goto overflow;
-
-	do {
-		{ /* Read the event out of the ring, then fiddle with
-		   * copied version.  Reason is that the ring is
-		   * likely to get pushed out of cache by another
-		   * event being delivered by hardware. */
-			ef_vi_event* ev = EF_VI_EVENT_PTR(evq, 0);
-			if( ! EF_VI_IS_EVENT(ev) )
-				break;
-			evs->generic.ev.u64[0] = cpu_to_le64 (ev->u64);
-			evq->evq_state->evq_ptr += sizeof(ef_vi_event);
-			ev->u64 = (uint64_t)(int64_t) -1;
-		}
-
-		/* Ugly: Exploit the fact that event code lies in top
-		 * bits of event. */
-		ef_assert_ge(EV_CODE_LBN, 32u);
-		switch( evs->generic.ev.u32[1] >> (EV_CODE_LBN - 32u) ) {
-		case RX_IP_EV_DECODE:
-			/* Look for duplicate desc_ptr: it signals
-			 * that a jumbo frame was truncated because we
-			 * ran out of descriptors. */
-			if(unlikely( falcon_rx_check_dup
-					   (evq, evs, &evs->generic.ev) )) {
-				--evs_len;
-				++evs;
-				break;
-			}
-			else {
-				/* Cope with FalconA1 bugs where RX
-				 * gives inconsistent RX events Mark
-				 * events as bad until SOP becomes
-				 * consistent again
-				 * ef_eventq_is_rx_sop_cont_bad() has
-				 * side effects - order is important
-				 */
-				if(unlikely
-				   (ef_eventq_is_rx_sop_cont_bad_efab
-				    (evq, &evs->generic.ev) )) {
-					mark_bad(evs);
-				}
-			}
-			falcon_rx_event(evs, &evs->generic.ev);
-			--evs_len;	
-			++evs;
-			break;
-
-		case TX_IP_EV_DECODE:
-			falcon_tx_event(evs, &evs->generic.ev);
-			--evs_len;
-			++evs;
-			break;
-
-		default:
-			break;
-		}
-	} while( evs_len );
-
-	return evs_len_orig - evs_len;
-
-
- overflow:
-	evs->generic.type = EF_EVENT_TYPE_OFLOW;
-	evs->generic.ev.u64[0] = (uint64_t)((int64_t)-1);
-	return 1;
-}
-
-
-int/*bool*/ ef_eventq_poll_exception(void* priv, ef_vi* evq, ef_event* ev)
-{
-	int /*bool*/ handled = 0;
-  
-	switch( ev->generic.ev.u32[1] >> (EV_CODE_LBN - 32u) ) {
-	case DRIVER_EV_DECODE:
-		if( QWORD_GET_U(DRIVER_EV_SUB_CODE, ev->generic.ev) ==
-		    EVQ_INIT_DONE_EV_DECODE )
-			/* EVQ initialised event: ignore. */
-			handled = 1;
-		break;
-	}
-	return handled;
-}
-
-
-void ef_eventq_iterate(ef_vi* vi,
-		       void (*fn)(void* arg, ef_vi*, int rel_pos,
-				  int abs_pos, void* event),
-		       void* arg, int stop_at_end)
-{
-	int i, size_evs = (vi->evq_mask + 1) / sizeof(ef_vi_event);
-
-	for( i = 0; i < size_evs; ++i ) {
-		ef_vi_event* e = EF_VI_EVENT_PTR(vi, -i);
-		if( EF_VI_IS_EVENT(e) )
-			fn(arg, vi, i, 
-			   EF_VI_EVENT_OFFSET(vi, -i) / sizeof(ef_vi_event),
-			   e);
-		else if( stop_at_end )
-			break;
-	}
-}
-
-
-int ef_eventq_has_event(ef_vi* vi)
-{
-	return EF_VI_IS_EVENT(EF_VI_EVENT_PTR(vi, 0));
-}
-
-
-int ef_eventq_has_many_events(ef_vi* vi, int look_ahead)
-{
-	ef_assert_ge(look_ahead, 0);
-	return EF_VI_IS_EVENT(EF_VI_EVENT_PTR(vi, -look_ahead));
-}
-
-
-int ef_eventq_has_rx_event(ef_vi* vi)
-{
-	ef_vi_event* ev;
-	int i, n_evs = 0;
-
-	for( i = 0;  EF_VI_IS_EVENT(EF_VI_EVENT_PTR(vi, i)); --i ) {
-		ev = EF_VI_EVENT_PTR(vi, i);
-		if( EFVI_FALCON_EVENT_CODE(ev) == EF_EVENT_TYPE_RX )  n_evs++;
-	}
-	return n_evs;
-}
-
-/*! \cidoxg_end */
diff -r 9566a4a50a43 drivers/xen/sfc_netfront/falcon_vi.c
--- a/drivers/xen/sfc_netfront/falcon_vi.c
+++ /dev/null
@@ -1,473 +0,0 @@
-/****************************************************************************
- * Copyright 2002-2005: Level 5 Networks Inc.
- * Copyright 2005-2008: Solarflare Communications Inc,
- *                      9501 Jeronimo Road, Suite 250,
- *                      Irvine, CA 92618, USA
- *
- * Maintained by Solarflare Communications
- *  <linux-xen-drivers@solarflare.com>
- *  <onload-dev@solarflare.com>
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 as published
- * by the Free Software Foundation, incorporated herein by reference.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
- ****************************************************************************
- */
-
-/*
- * \author  djr, stg
- *  \brief  Falcon-specific VI
- *   \date  2006/11/30
- */
-
-#include "ef_vi_internal.h"
-
-
-#define EFVI_FALCON_DMA_TX_FRAG		1
-
-
-/* TX descriptor for both physical and virtual packet transfers */
-typedef union {
-	uint32_t	dword[2];
-} ef_vi_falcon_dma_tx_buf_desc;
-typedef ef_vi_falcon_dma_tx_buf_desc ef_vi_falcon_dma_tx_phys_desc;
-
-
-/* RX descriptor for physical addressed transfers */
-typedef union {
-	uint32_t	dword[2];
-} ef_vi_falcon_dma_rx_phys_desc;
-
-
-/* RX descriptor for virtual packet transfers */
-typedef struct {
-	uint32_t	dword[1];
-} ef_vi_falcon_dma_rx_buf_desc;
-
-/* Buffer table index */
-typedef uint32_t		ef_vi_buffer_addr_t;
-
-ef_vi_inline int64_t dma_addr_to_u46(int64_t src_dma_addr)
-{
-	return (src_dma_addr & __FALCON_MASK(46, int64_t));
-}
-
-/*! Setup a physical address based descriptor with a specified length */
-ef_vi_inline void
-__falcon_dma_rx_calc_ip_phys(ef_vi_dma_addr_t dest_pa, 
-			     ef_vi_falcon_dma_rx_phys_desc *desc,
-			     int bytes)
-{
-	int region = 0; 		/* TODO fixme */
-	int64_t dest    = dma_addr_to_u46(dest_pa); /* lower 46 bits */
-
-	DWCHCK(__DW2(RX_KER_BUF_SIZE_LBN),  RX_KER_BUF_SIZE_WIDTH);
-	DWCHCK(__DW2(RX_KER_BUF_REGION_LBN),RX_KER_BUF_REGION_WIDTH);
-
-	LWCHK(RX_KER_BUF_ADR_LBN, RX_KER_BUF_ADR_WIDTH);
-
-	RANGECHCK(bytes,  RX_KER_BUF_SIZE_WIDTH);
-	RANGECHCK(region, RX_KER_BUF_REGION_WIDTH);
-
-	ef_assert(desc);
-
-	desc->dword[1] = ((bytes << __DW2(RX_KER_BUF_SIZE_LBN)) |
-			  (region << __DW2(RX_KER_BUF_REGION_LBN)) |
-			  (HIGH(dest,
-				RX_KER_BUF_ADR_LBN, 
-				RX_KER_BUF_ADR_WIDTH)));
-
-	desc->dword[0] = LOW(dest, 
-			     RX_KER_BUF_ADR_LBN, 
-			     RX_KER_BUF_ADR_WIDTH);
-}
-
-/*! Setup a virtual buffer descriptor for an IPMODE transfer */
-ef_vi_inline void
-__falcon_dma_tx_calc_ip_buf(unsigned buf_id, unsigned buf_ofs, unsigned bytes,
-			    int port, int frag, 
-			    ef_vi_falcon_dma_tx_buf_desc *desc)
-{
-	DWCHCK(__DW2(TX_USR_PORT_LBN), TX_USR_PORT_WIDTH);
-	DWCHCK(__DW2(TX_USR_CONT_LBN), TX_USR_CONT_WIDTH);
-	DWCHCK(__DW2(TX_USR_BYTE_CNT_LBN), TX_USR_BYTE_CNT_WIDTH);
-	LWCHK(RX_KER_BUF_ADR_LBN, RX_KER_BUF_ADR_WIDTH);
-	DWCHCK(TX_USR_BYTE_OFS_LBN, TX_USR_BYTE_OFS_WIDTH);
-
-	RANGECHCK(bytes,   TX_USR_BYTE_CNT_WIDTH);
-	RANGECHCK(port,    TX_USR_PORT_WIDTH);
-	RANGECHCK(frag,    TX_USR_CONT_WIDTH);
-	RANGECHCK(buf_id,  TX_USR_BUF_ID_WIDTH);
-	RANGECHCK(buf_ofs, TX_USR_BYTE_OFS_WIDTH);
-
-	ef_assert(desc);
-
-	desc->dword[1] = ((port   <<  __DW2(TX_USR_PORT_LBN))      | 
-			  (frag   <<  __DW2(TX_USR_CONT_LBN))      | 
-			  (bytes  <<  __DW2(TX_USR_BYTE_CNT_LBN))  |
-			  (HIGH(buf_id, 
-				TX_USR_BUF_ID_LBN,
-				TX_USR_BUF_ID_WIDTH)));
-
-	desc->dword[0] =  ((LOW(buf_id,
-				TX_USR_BUF_ID_LBN,
-				(TX_USR_BUF_ID_WIDTH))) |
-			   (buf_ofs << TX_USR_BYTE_OFS_LBN));
-}
-
-ef_vi_inline void
-falcon_dma_tx_calc_ip_buf_4k(unsigned buf_vaddr, unsigned bytes,
-			     int port, int frag, 
-			     ef_vi_falcon_dma_tx_buf_desc *desc)
-{
-	/* TODO FIXME [buf_vaddr] consists of the buffer index in the
-	** high bits, and an offset in the low bits. Assumptions
-	** permate the code that these can be rolled into one 32bit
-	** value, so this is currently preserved for Falcon. But we
-	** should change to support 8K pages
-	*/
-	unsigned buf_id =  EFVI_FALCON_BUFFER_4K_PAGE(buf_vaddr);
-	unsigned buf_ofs = EFVI_FALCON_BUFFER_4K_OFF(buf_vaddr);
-
-	__falcon_dma_tx_calc_ip_buf( buf_id, buf_ofs, bytes, port, frag, desc);
-}
-
-ef_vi_inline void
-falcon_dma_tx_calc_ip_buf(unsigned buf_vaddr, unsigned bytes, int port, 
-			  int frag, ef_vi_falcon_dma_tx_buf_desc *desc)
-{
-	falcon_dma_tx_calc_ip_buf_4k(buf_vaddr, bytes, port, frag, desc);
-}
-
-/*! Setup a virtual buffer based descriptor */
-ef_vi_inline void
-__falcon_dma_rx_calc_ip_buf(unsigned buf_id, unsigned buf_ofs, 
-			    ef_vi_falcon_dma_rx_buf_desc *desc)
-{ 
-	/* check alignment of buffer offset and pack */
-	ef_assert((buf_ofs & 0x1) == 0);
-
-	buf_ofs >>= 1;
-
-	DWCHCK(RX_USR_2BYTE_OFS_LBN, RX_USR_2BYTE_OFS_WIDTH);
-	DWCHCK(RX_USR_BUF_ID_LBN, RX_USR_BUF_ID_WIDTH);
-
-	RANGECHCK(buf_ofs, RX_USR_2BYTE_OFS_WIDTH);
-	RANGECHCK(buf_id,  RX_USR_BUF_ID_WIDTH);
-
-	ef_assert(desc);
-
-	desc->dword[0] = ((buf_ofs << RX_USR_2BYTE_OFS_LBN) | 
-			  (buf_id  << RX_USR_BUF_ID_LBN));
-}
-
-ef_vi_inline void
-falcon_dma_rx_calc_ip_buf_4k(unsigned buf_vaddr, 
-			     ef_vi_falcon_dma_rx_buf_desc *desc)
-{ 
-	/* TODO FIXME [buf_vaddr] consists of the buffer index in the
-	** high bits, and an offset in the low bits. Assumptions
-	** permeate the code that these can be rolled into one 32bit
-	** value, so this is currently preserved for Falcon. But we
-	** should change to support 8K pages
-	*/
-	unsigned buf_id =  EFVI_FALCON_BUFFER_4K_PAGE(buf_vaddr);
-	unsigned buf_ofs = EFVI_FALCON_BUFFER_4K_OFF(buf_vaddr);
-
-	__falcon_dma_rx_calc_ip_buf(buf_id, buf_ofs, desc);
-}
-
-ef_vi_inline void
-falcon_dma_rx_calc_ip_buf(unsigned buf_vaddr, 
-			  ef_vi_falcon_dma_rx_buf_desc *desc)
-{ 
-	falcon_dma_rx_calc_ip_buf_4k(buf_vaddr, desc);
-}
-
-
-ef_vi_inline ef_vi_dma_addr_t ef_physaddr(ef_addr efaddr)
-{
-	return (ef_vi_dma_addr_t) efaddr;
-}
-
-
-/*! Convert between an ef_addr and a buffer table index
-**  Assert that this was not a physical address
-*/
-ef_vi_inline ef_vi_buffer_addr_t ef_bufaddr(ef_addr efaddr)
-{
-	ef_assert(efaddr < ((uint64_t)1 << 32) );
-
-	return (ef_vi_buffer_addr_t) efaddr;
-}
-
-
-/*! Setup an physical address based descriptor for an IPMODE transfer */
-ef_vi_inline void
-falcon_dma_tx_calc_ip_phys(ef_vi_dma_addr_t src_dma_addr, unsigned bytes, 
-			   int port, int frag,
-			   ef_vi_falcon_dma_tx_phys_desc *desc)
-{
-
-	int region = 0; /* FIXME */
-	int64_t src    = dma_addr_to_u46(src_dma_addr); /* lower 46 bits */
-
-	DWCHCK(__DW2(TX_KER_PORT_LBN),      TX_KER_PORT_WIDTH);
-	DWCHCK(__DW2(TX_KER_CONT_LBN),      TX_KER_CONT_WIDTH);
-	DWCHCK(__DW2(TX_KER_BYTE_CNT_LBN),  TX_KER_BYTE_CNT_WIDTH);
-	DWCHCK(__DW2(TX_KER_BUF_REGION_LBN),TX_KER_BUF_REGION_WIDTH);
-
-	LWCHK(TX_KER_BUF_ADR_LBN, TX_KER_BUF_ADR_WIDTH);
-
-	RANGECHCK(port,   TX_KER_PORT_WIDTH);
-	RANGECHCK(frag,   TX_KER_CONT_WIDTH);
-	RANGECHCK(bytes,  TX_KER_BYTE_CNT_WIDTH);
-	RANGECHCK(region, TX_KER_BUF_REGION_WIDTH);
-
-	desc->dword[1] = ((port   <<  __DW2(TX_KER_PORT_LBN))      | 
-			  (frag   <<  __DW2(TX_KER_CONT_LBN))      | 
-			  (bytes  <<  __DW2(TX_KER_BYTE_CNT_LBN))  | 
-			  (region << __DW2(TX_KER_BUF_REGION_LBN)) |
-			  (HIGH(src,
-				TX_KER_BUF_ADR_LBN, 
-				TX_KER_BUF_ADR_WIDTH)));
-
-	ef_assert_equal(TX_KER_BUF_ADR_LBN, 0);
-	desc->dword[0] = (uint32_t) src_dma_addr;
-}
-
-
-void falcon_vi_init(ef_vi* vi, void* vvis)
-{
-	struct vi_mappings *vm = (struct vi_mappings*)vvis;
-	uint16_t* ids;
-
-	ef_assert(vi);
-	ef_assert(vvis);
-	ef_assert_equal(vm->signature, VI_MAPPING_SIGNATURE);
-	ef_assert_equal(vm->nic_type.arch, EF_VI_ARCH_FALCON);
-
-	/* Initialise masks to zero, so that ef_vi_state_init() will
-	** not do any harm when we don't have DMA queues. */
-	vi->vi_rxq.mask = vi->vi_txq.mask = 0;
-
-	/* Used for BUG5391_WORKAROUND. */
-	vi->vi_txq.misalign_mask = 0;
-
-	/* Initialise doorbell addresses to a distinctive small value
-	** which will cause a segfault, to trap doorbell pushes to VIs
-	** without DMA queues. */
-	vi->vi_rxq.doorbell = vi->vi_txq.doorbell = (ef_vi_ioaddr_t)0xdb;
-
-	ids = (uint16_t*) (vi->ep_state + 1);
-
-	if( vm->tx_queue_capacity ) {
-		vi->vi_txq.mask = vm->tx_queue_capacity - 1;
-		vi->vi_txq.doorbell = vm->tx_bell + 12;
-		vi->vi_txq.descriptors = vm->tx_dma_falcon;
-		vi->vi_txq.ids = ids;
-		ids += vi->vi_txq.mask + 1;
-		/* Check that the id fifo fits in the space allocated. */
-		ef_assert_le((char*) (vi->vi_txq.ids + vm->tx_queue_capacity),
-			     (char*) vi->ep_state
-			     + ef_vi_calc_state_bytes(vm->rx_queue_capacity,
-						      vm->tx_queue_capacity));
-	}
-	if( vm->rx_queue_capacity ) {
-		vi->vi_rxq.mask = vm->rx_queue_capacity - 1;
-		vi->vi_rxq.doorbell = vm->rx_bell + 12;
-		vi->vi_rxq.descriptors = vm->rx_dma_falcon;
-		vi->vi_rxq.ids = ids;
-		/* Check that the id fifo fits in the space allocated. */
-		ef_assert_le((char*) (vi->vi_rxq.ids + vm->rx_queue_capacity),
-			     (char*) vi->ep_state
-			     + ef_vi_calc_state_bytes(vm->rx_queue_capacity,
-						      vm->tx_queue_capacity));
-	}
-
-	if( vm->nic_type.variant == 'A' ) {
-		vi->vi_txq.misalign_mask = 15;    /* BUG5391_WORKAROUND */
-		vi->vi_flags |= EF_VI_BUG5692_WORKAROUND;
-	}
-}
-
-
-int ef_vi_transmitv_init(ef_vi* vi, const ef_iovec* iov, int iov_len,
-			 ef_request_id dma_id)
-{
-	ef_vi_txq* q = &vi->vi_txq;
-	ef_vi_txq_state* qs = &vi->ep_state->txq;
-	ef_vi_falcon_dma_tx_buf_desc* dp;
-	unsigned len, dma_len, di;
-	unsigned added_save = qs->added;
-	ef_addr dma_addr;
-	unsigned last_len = 0;
-
-	ef_assert(iov_len > 0);
-	ef_assert(iov);
-	ef_assert_equal((dma_id & EF_REQUEST_ID_MASK), dma_id);
-	ef_assert_nequal(dma_id, 0xffff);
-
-	dma_addr = iov->iov_base;
-	len = iov->iov_len;
-
-	if( vi->vi_flags & EF_VI_ISCSI_TX_DDIG ) {
-		/* Last 4 bytes of placeholder for digest must be
-		 * removed for h/w */
-		ef_assert(len > 4);
-		last_len = iov[iov_len - 1].iov_len;
-		if( last_len <= 4 ) {
-			ef_assert(iov_len > 1);
-			--iov_len;
-			last_len = iov[iov_len - 1].iov_len - (4 - last_len);
-		}
-		else {
-			last_len = iov[iov_len - 1].iov_len - 4;
-		}
-		if( iov_len == 1 )
-			len = last_len;
-	}
-
-	while( 1 ) {
-		if( qs->added - qs->removed >= q->mask ) {
-			qs->added = added_save;
-			return -EAGAIN;
-		}
-
-		dma_len = (~((unsigned) dma_addr) & 0xfff) + 1;
-		if( dma_len > len )  dma_len = len;
-		{ /* BUG5391_WORKAROUND */
-			unsigned misalign = 
-				(unsigned) dma_addr & q->misalign_mask;
-			if( misalign && dma_len + misalign > 512 )
-				dma_len = 512 - misalign;
-		}
-
-		di = qs->added++ & q->mask;
-		dp = (ef_vi_falcon_dma_tx_buf_desc*) q->descriptors + di;
-		if( vi->vi_flags & EF_VI_TX_PHYS_ADDR )
-			falcon_dma_tx_calc_ip_phys
-				(ef_physaddr(dma_addr), dma_len, /*port*/ 0,
-				 (iov_len == 1 && dma_len == len) ? 0 :
-				 EFVI_FALCON_DMA_TX_FRAG, dp);
-		else
-			falcon_dma_tx_calc_ip_buf
-				(ef_bufaddr(dma_addr), dma_len, /*port*/ 0,
-				 (iov_len == 1 && dma_len == len) ? 0 :
-				 EFVI_FALCON_DMA_TX_FRAG, dp);
-
-		dma_addr += dma_len;
-		len -= dma_len;
-
-		if( len == 0 ) {
-			if( --iov_len == 0 )  break;
-			++iov;
-			dma_addr = iov->iov_base;
-			len = iov->iov_len;
-			if( (vi->vi_flags & EF_VI_ISCSI_TX_DDIG) &&
-			    (iov_len == 1) )
-				len = last_len;
-		}
-	}
-
-	q->ids[di] = (uint16_t) dma_id;
-	return 0;
-}
-
-
-void ef_vi_transmit_push(ef_vi* vi)
-{
-	ef_vi_wiob();
-	writel((vi->ep_state->txq.added & vi->vi_txq.mask) <<
-		__DW4(TX_DESC_WPTR_LBN),
-        	vi->vi_txq.doorbell);
-}
-
-
-/*! The value of initial_rx_bytes is used to set RX_KER_BUF_SIZE in an initial
-**  receive descriptor here if physical addressing is being used. A value of
-**  zero represents 16384 bytes.  This is okay, because caller must provide a
-**  buffer than is > MTU, and mac should filter anything bigger than that.
-*/
-int ef_vi_receive_init(ef_vi* vi, ef_addr addr, ef_request_id dma_id,
-		       int initial_rx_bytes)
-{
-	ef_vi_rxq* q = &vi->vi_rxq;
-	ef_vi_rxq_state* qs = &vi->ep_state->rxq;
-	unsigned di;
-
-	if( ef_vi_receive_space(vi) ) {
-		di = qs->added++ & q->mask;
-		ef_assert_equal(q->ids[di], 0xffff);
-		q->ids[di] = (uint16_t) dma_id;
-
-		if( ! (vi->vi_flags & EF_VI_RX_PHYS_ADDR) ) {
-			ef_vi_falcon_dma_rx_buf_desc* dp;
-			dp = (ef_vi_falcon_dma_rx_buf_desc*) 
-				q->descriptors + di;
-			falcon_dma_rx_calc_ip_buf(ef_bufaddr(addr), dp);
-		}
-		else {
-			ef_vi_falcon_dma_rx_phys_desc* dp;
-			dp = (ef_vi_falcon_dma_rx_phys_desc*) 
-				q->descriptors + di;
-			__falcon_dma_rx_calc_ip_phys(addr, dp,
-						     initial_rx_bytes);
-		}
-
-		return 0;
-	}
-
-	return -EAGAIN;
-}
-
-
-int ef_vi_receive_post(ef_vi* vi, ef_addr addr, ef_request_id dma_id)
-{
-  int rc = ef_vi_receive_init(vi, addr, dma_id, 0);
-  if( rc == 0 )  ef_vi_receive_push(vi);
-  return rc;
-}
-
-
-void ef_vi_receive_push(ef_vi* vi)
-{
-	ef_vi_wiob();
-	writel ((vi->ep_state->rxq.added & vi->vi_rxq.mask) <<
-		__DW4(RX_DESC_WPTR_LBN),
-		vi->vi_rxq.doorbell);
-}
-
-
-ef_request_id ef_vi_receive_done(const ef_vi* vi, const ef_event* ef_ev)
-{
-	const ef_vi_qword* ev = EF_GET_HW_EV_PTR(*ef_ev);
-	unsigned di = ev->u32[0] & vi->vi_rxq.mask;
-	ef_request_id rq_id;
-
-	ef_assert(EF_EVENT_TYPE(*ef_ev) == EF_EVENT_TYPE_RX ||
-		  EF_EVENT_TYPE(*ef_ev) == EF_EVENT_TYPE_RX_DISCARD);
-
-	/* Detect spurious / duplicate RX events.  We may need to modify this
-	** code so that we are robust if they happen. */
-	ef_assert_equal(di, vi->ep_state->rxq.removed & vi->vi_rxq.mask);
-
-	/* We only support 1 port: so events should be in order. */
-	ef_assert(vi->vi_rxq.ids[di] != 0xffff);
-
-	rq_id = vi->vi_rxq.ids[di];
-	vi->vi_rxq.ids[di] = 0xffff;
-	++vi->ep_state->rxq.removed;
-	return rq_id;
-}
-
-/*! \cidoxg_end */
diff -r 9566a4a50a43 drivers/xen/sfc_netfront/pt_tx.c
--- a/drivers/xen/sfc_netfront/pt_tx.c
+++ /dev/null
@@ -1,91 +0,0 @@
-/****************************************************************************
- * Copyright 2002-2005: Level 5 Networks Inc.
- * Copyright 2005-2008: Solarflare Communications Inc,
- *                      9501 Jeronimo Road, Suite 250,
- *                      Irvine, CA 92618, USA
- *
- * Maintained by Solarflare Communications
- *  <linux-xen-drivers@solarflare.com>
- *  <onload-dev@solarflare.com>
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 as published
- * by the Free Software Foundation, incorporated herein by reference.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
- ****************************************************************************
- */
-
-/*
- * \author  djr
- *  \brief  Packet-mode transmit interface.
- *   \date  2003/04/02
- */
-
-/*! \cidoxg_lib_ef */
-#include "ef_vi_internal.h"
-
-
-int ef_vi_transmit_init(ef_vi* vi, ef_addr base, int len, ef_request_id dma_id)
-{
-	ef_iovec iov = { base, len };
-	return ef_vi_transmitv_init(vi, &iov, 1, dma_id);
-}
-
-
-int ef_vi_transmit(ef_vi* vi, ef_addr base, int len, ef_request_id dma_id)
-{
-	ef_iovec iov = { base, len };
-	int rc = ef_vi_transmitv_init(vi, &iov, 1, dma_id);
-	if( rc == 0 )  ef_vi_transmit_push(vi);
-	return rc;
-}
-
-
-int ef_vi_transmitv(ef_vi* vi, const ef_iovec* iov, int iov_len,
-                    ef_request_id dma_id)
-{
-	int rc = ef_vi_transmitv_init(vi, iov, iov_len, dma_id);
-	if( rc == 0 )  ef_vi_transmit_push(vi);
-	return rc;
-}
-
-
-int ef_vi_transmit_unbundle(ef_vi* vi, const ef_event* __ev,
-			    ef_request_id* ids)
-{
-	ef_request_id* ids_in = ids;
-	ef_vi_txq* q = &vi->vi_txq;
-	ef_vi_txq_state* qs = &vi->ep_state->txq;
-	const ef_vi_qword* ev = EF_GET_HW_EV_PTR(*__ev);
-	unsigned i, stop = (ev->u32[0] + 1) & q->mask;
-
-	ef_assert(EF_EVENT_TYPE(*__ev) == EF_EVENT_TYPE_TX ||
-		  EF_EVENT_TYPE(*__ev) == EF_EVENT_TYPE_TX_ERROR);
-
-	/* Shouldn't be batching more than 64 descriptors, and should not go
-	** backwards. */
-	ef_assert_le((((ev->u32[0] + 1) - qs->removed) & q->mask), 64);
-	/* Should not complete more than we've posted. */
-	ef_assert_le((((ev->u32[0] + 1) - qs->removed) & q->mask),
-		     qs->added - qs->removed);
-
-	for( i = qs->removed & q->mask; i != stop; i = ++qs->removed & q->mask )
-		if( q->ids[i] != 0xffff ) {
-			*ids++ = q->ids[i];
-			q->ids[i] = 0xffff;
-		}
-
-	ef_assert_le(ids - ids_in, EF_VI_TRANSMIT_BATCH);
-
-	return (int) (ids - ids_in);
-}
-
-/*! \cidoxg_end */
diff -r 9566a4a50a43 drivers/xen/sfc_netfront/sysdep.h
--- a/drivers/xen/sfc_netfront/sysdep.h
+++ /dev/null
@@ -1,185 +0,0 @@
-/****************************************************************************
- * Copyright 2002-2005: Level 5 Networks Inc.
- * Copyright 2005-2008: Solarflare Communications Inc,
- *                      9501 Jeronimo Road, Suite 250,
- *                      Irvine, CA 92618, USA
- *
- * Maintained by Solarflare Communications
- *  <linux-xen-drivers@solarflare.com>
- *  <onload-dev@solarflare.com>
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 as published
- * by the Free Software Foundation, incorporated herein by reference.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
- ****************************************************************************
- */
-
-/*
- * \author  stg
- *  \brief  System dependent support for ef vi lib
- *   \date  2007/05/10
- */
-
-/*! \cidoxg_include_ci_ul */
-#ifndef __CI_CIUL_SYSDEP_LINUX_H__
-#define __CI_CIUL_SYSDEP_LINUX_H__
-
-
-#define ef_vi_wiob()  mmiowb()
-
-
-/**********************************************************************
- * Kernel version compatability
- */
-
-#if defined(__GNUC__)
-
-/* Linux kernel doesn't have stdint.h or [u]intptr_t. */
-# if !defined(LINUX_VERSION_CODE)
-#  include <linux/version.h>
-# endif
-# include <asm/io.h>
-
-/* In Linux 2.6.24, linux/types.h has uintptr_t */
-# if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,24)
-#  if BITS_PER_LONG == 32
-   typedef __u32         uintptr_t;
-#  else
-   typedef __u64         uintptr_t;
-#  endif
-# endif
-
-/* But even 2.6.24 doesn't define intptr_t */
-# if BITS_PER_LONG == 32
-   typedef __s32         intptr_t;
-# else
-   typedef __s64         intptr_t;
-# endif
-
-# if defined(__ia64__)
-#  define EF_VI_PRIx64  "lx"
-# else
-#  define EF_VI_PRIx64  "llx"
-# endif
-
-# define EF_VI_HF __attribute__((visibility("hidden")))
-# define EF_VI_HV __attribute__((visibility("hidden")))
-
-# if defined(__i386__) || defined(__x86_64__)  /* GCC x86/x64 */
-   typedef unsigned long long ef_vi_dma_addr_t; 
-# endif
-#endif
-
-#ifndef mmiowb
-# if defined(__i386__) || defined(__x86_64__)
-#  define mmiowb()
-# elif defined(__ia64__)
-#  ifndef ia64_mfa
-#   define ia64_mfa() asm volatile ("mf.a" ::: "memory")
-#  endif
-#  define mmiowb ia64_mfa
-# else
-#  error "Need definition for mmiowb"
-# endif
-#endif
-
-#ifdef EFX_NOT_UPSTREAM
-
-/* Stuff for architectures/compilers not officially supported */
-
-#if !defined(__GNUC__)
-# if defined(__PPC__)  /* GCC, PPC */
-   typedef unsigned long     ef_vi_dma_addr_t;
-
-#  ifdef __powerpc64__
-#   ifdef CONFIG_SMP
-#    define CI_SMP_SYNC        "\n   eieio     \n"         /* memory cache sync */
-#    define CI_SMP_ISYNC       "\n   isync     \n"         /* instr cache sync */
-#   else
-#    define CI_SMP_SYNC
-#    define CI_SMP_ISYNC
-#   endif
-#  else	 /* for ppc32 systems */
-#   ifdef CONFIG_SMP
-#    define CI_SMP_SYNC        "\n   eieio     \n"
-#    define CI_SMP_ISYNC       "\n   sync      \n"
-#   else
-#    define CI_SMP_SYNC
-#    define CI_SMP_ISYNC
-#   endif
-#  endif
-
-# elif defined(__ia64__)  /* GCC, IA64 */
-   typedef unsigned long     ef_vi_dma_addr_t;
-# else
-#  error Unknown processor - GNU C
-# endif
-
-#elif defined(__PGI)
-# error PGI not supported 
-
-#elif defined(__INTEL_COMPILER)
-
-/* Intel compilers v7 claim to be very gcc compatible. */
-# if __INTEL_COMPILER >= 700
-#  if __GNUC__ >= 3 || (__GNUC__ == 2 && __GNUC_MINOR__ > 91)
-#   define EF_VI_LIKELY(t)    __builtin_expect((t), 1)
-#   define EF_VI_UNLIKELY(t)  __builtin_expect((t), 0)
-#  endif
-# else
-#  error Old Intel compiler not supported.
-# endif
-
-#else
-# error Unknown compiler.
-#endif
-
-#endif
-
-
-# include <linux/errno.h>
-
-
-/**********************************************************************
- * Extracting bit fields.
- */
-
-#define _QWORD_GET_LOW(f, v)                                    \
-  (((v).u32[0] >> (f##_LBN)) & ((1u << f##_WIDTH) - 1u))
-#define _QWORD_GET_HIGH(f, v)                                           \
-  (((v).u32[1] >> (f##_LBN - 32u)) & ((1u << f##_WIDTH) - 1u))
-#define _QWORD_GET_ANY(f, v)                                            \
-  (((v).u64[0] >> f##_LBN) & (((uint64_t) 1u << f##_WIDTH) - 1u))
-
-#define QWORD_GET(f, v)                                                     \
-  ((f##_LBN + f##_WIDTH) <= 32u                                             \
-   ? _QWORD_GET_LOW(f, (v))                                                 \
-   : ((f##_LBN >= 32u) ? _QWORD_GET_HIGH(f, (v)) : _QWORD_GET_ANY(f, (v))))
-
-#define QWORD_GET_U(f, v)  ((unsigned) QWORD_GET(f, (v)))
-
-#define _QWORD_TEST_BIT_LOW(f, v)   ((v).u32[0] & (1u << (f##_LBN)))
-#define _QWORD_TEST_BIT_HIGH(f, v)  ((v).u32[1] & (1u << (f##_LBN - 32u)))
-
-#define QWORD_TEST_BIT(f, v)                                                  \
-  (f##_LBN < 32 ? _QWORD_TEST_BIT_LOW(f, (v)) : _QWORD_TEST_BIT_HIGH(f, (v)))
-
-
-
-
-#ifndef DECLSPEC_NORETURN
-/* normally defined on Windows to expand to a declaration that the
-   function will not return */
-# define DECLSPEC_NORETURN
-#endif
-
-#endif  /* __CI_CIUL_SYSDEP_LINUX_H__ */
diff -r 9566a4a50a43 drivers/xen/sfc_netfront/vi_init.c
--- a/drivers/xen/sfc_netfront/vi_init.c
+++ /dev/null
@@ -1,183 +0,0 @@
-/****************************************************************************
- * Copyright 2002-2005: Level 5 Networks Inc.
- * Copyright 2005-2008: Solarflare Communications Inc,
- *                      9501 Jeronimo Road, Suite 250,
- *                      Irvine, CA 92618, USA
- *
- * Maintained by Solarflare Communications
- *  <linux-xen-drivers@solarflare.com>
- *  <onload-dev@solarflare.com>
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 as published
- * by the Free Software Foundation, incorporated herein by reference.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
- ****************************************************************************
- */
-
-/*
- * \author  djr
- *  \brief  Initialisation of VIs.
- *   \date  2007/06/08
- */
-
-#include "ef_vi_internal.h"
-
-#define EF_VI_STATE_BYTES(rxq_sz, txq_sz)			\
-	(sizeof(ef_vi_state) + (rxq_sz) * sizeof(uint16_t)	\
-	 + (txq_sz) * sizeof(uint16_t))
-
-int ef_vi_calc_state_bytes(int rxq_sz, int txq_sz)
-{
-	ef_assert(rxq_sz == 0 || EF_VI_IS_POW2(rxq_sz));
-	ef_assert(txq_sz == 0 || EF_VI_IS_POW2(txq_sz));
-
-	return EF_VI_STATE_BYTES(rxq_sz, txq_sz);
-}
-
-
-int ef_vi_state_bytes(ef_vi* vi)
-{
-	int rxq_sz = 0, txq_sz = 0;
-	if( ef_vi_receive_capacity(vi) )
-		rxq_sz = ef_vi_receive_capacity(vi) + 1;
-	if( ef_vi_transmit_capacity(vi) )
-		txq_sz = ef_vi_transmit_capacity(vi) + 1;
-
-	ef_assert(rxq_sz == 0 || EF_VI_IS_POW2(rxq_sz));
-	ef_assert(txq_sz == 0 || EF_VI_IS_POW2(txq_sz));
-
-	return EF_VI_STATE_BYTES(rxq_sz, txq_sz);
-}
-
-
-void ef_eventq_state_init(ef_vi* evq)
-{
-	int j;
-
-	for (j = 0; j<EFAB_DMAQS_PER_EVQ_MAX; j++) {
-		ef_rx_dup_state_t *rx_dup_state =
-			&evq->evq_state->rx_dup_state[j];
-		rx_dup_state->bad_sop = 0;
-		rx_dup_state->rx_last_desc_ptr = -1;
-		rx_dup_state->frag_num = 0;
-	}
-
-	evq->evq_state->evq_ptr = 0;
-}
-
-
-void ef_vi_state_init(ef_vi* vi)
-{
-	ef_vi_state* state = vi->ep_state;
-	unsigned i;
-
-	state->txq.added = state->txq.removed = 0;
-	state->rxq.added = state->rxq.removed = 0;
-
-	if( vi->vi_rxq.mask )
-		for( i = 0; i <= vi->vi_rxq.mask; ++i )
-			vi->vi_rxq.ids[i] = (uint16_t) -1;
-	if( vi->vi_txq.mask )
-		for( i = 0; i <= vi->vi_txq.mask; ++i )
-			vi->vi_txq.ids[i] = (uint16_t) -1;
-}
-
-
-void ef_vi_init_mapping_evq(void* data_area, struct ef_vi_nic_type nic_type,
-                            int instance, unsigned evq_bytes, void* base,
-                            void* timer_reg)
-{
-	struct vi_mappings* vm = (struct vi_mappings*) data_area;
-
-	vm->signature = VI_MAPPING_SIGNATURE;
-	vm->vi_instance = instance;
-	vm->nic_type = nic_type;
-	vm->evq_bytes = evq_bytes;
-	vm->evq_base = base;
-	vm->evq_timer_reg = timer_reg;
-}
-
-
-void ef_vi_init(ef_vi* vi, void* vvis, ef_vi_state* state,
-                ef_eventq_state* evq_state, enum ef_vi_flags vi_flags)
-{
-	struct vi_mappings* vm = (struct vi_mappings*) vvis;
-
-	vi->vi_i = vm->vi_instance;
-	vi->ep_state = state;
-	vi->vi_flags = vi_flags;
-
-	switch( vm->nic_type.arch ) {
-	case EF_VI_ARCH_FALCON:
-		falcon_vi_init(vi, vvis);
-		break;
-	default:
-		/* ?? TODO: We should return an error code. */
-		ef_assert(0);
-		break;
-	}
-
-	if( vm->evq_bytes ) {
-		vi->evq_state = evq_state;
-		vi->evq_mask = vm->evq_bytes - 1u;
-		vi->evq_base = vm->evq_base;
-		vi->evq_timer_reg = vm->evq_timer_reg;
-	}
-
-	EF_VI_MAGIC_SET(vi, EF_VI);
-}
-
-
-/* Initialise [data_area] with information required to initialise an ef_vi.
- * In the following, an unused param should be set to NULL. Note the case
- * marked (*) of [iobuf_mmap] for falcon/driver; for the normal driver this
- * must be NULL.
- *
- * \param  data_area     [in,out] required, must ref at least VI_MAPPING_SIZE 
- *                                bytes
- * \param  io_mmap       [in] ef1,    required
- *                            falcon, required
- * \param  iobuf_mmap    [in] ef1,    unused
- *                            falcon, required
- */
-void ef_vi_init_mapping_vi(void* data_area, struct ef_vi_nic_type nic_type,
-                           unsigned rxq_capacity, unsigned txq_capacity,
-                           int instance, void* io_mmap,
-                           void* iobuf_mmap_rx, void* iobuf_mmap_tx,
-                           enum ef_vi_flags vi_flags)
-{
-	struct vi_mappings* vm = (struct vi_mappings*) data_area;
-	int rx_desc_bytes, rxq_bytes;
-
-	ef_assert(rxq_capacity > 0 || txq_capacity > 0);
-	ef_assert(vm);
-	ef_assert(io_mmap);
-	ef_assert(iobuf_mmap_rx || iobuf_mmap_tx);
-
-	vm->signature = VI_MAPPING_SIGNATURE;
-	vm->vi_instance = instance;
-	vm->nic_type = nic_type;
-
-	rx_desc_bytes = (vi_flags & EF_VI_RX_PHYS_ADDR) ? 8 : 4;
-	rxq_bytes = rxq_capacity * rx_desc_bytes;
-	rxq_bytes = (rxq_bytes + PAGE_SIZE - 1) & ~(PAGE_SIZE - 1);
-
-	if( iobuf_mmap_rx == iobuf_mmap_tx )
-		iobuf_mmap_tx = (char*) iobuf_mmap_rx + rxq_bytes;
-
-	vm->rx_queue_capacity = rxq_capacity;
-	vm->rx_dma_falcon = iobuf_mmap_rx;
-	vm->rx_bell       = (char*) io_mmap + (RX_DESC_UPD_REG_KER_OFST & 4095);
-	vm->tx_queue_capacity = txq_capacity;
-	vm->tx_dma_falcon = iobuf_mmap_tx;
-	vm->tx_bell       = (char*) io_mmap + (TX_DESC_UPD_REG_KER_OFST & 4095);
-}
diff -r 9566a4a50a43 drivers/xen/sfc_netutil/Makefile
--- a/drivers/xen/sfc_netutil/Makefile
+++ /dev/null
@@ -1,11 +0,0 @@
-EXTRA_CFLAGS += -Idrivers/xen/sfc_netutil
-EXTRA_CFLAGS += -Werror
-
-ifdef GGOV
-EXTRA_CFLAGS += -fprofile-arcs -ftest-coverage -DEFX_GCOV
-endif
-
-obj-$(CONFIG_XEN_NETDEV_ACCEL_SFC_UTIL) := sfc_netutil.o
-
-sfc_netutil-objs := accel_cuckoo_hash.o accel_msg_iface.o accel_util.o 
-
diff -r 9566a4a50a43 drivers/xen/sfc_netutil/accel_cuckoo_hash.c
--- a/drivers/xen/sfc_netutil/accel_cuckoo_hash.c
+++ /dev/null
@@ -1,651 +0,0 @@
-/****************************************************************************
- * Solarflare driver for Xen network acceleration
- *
- * Copyright 2006-2008: Solarflare Communications Inc,
- *                      9501 Jeronimo Road, Suite 250,
- *                      Irvine, CA 92618, USA
- *
- * Maintained by Solarflare Communications <linux-xen-drivers@solarflare.com>
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 as published
- * by the Free Software Foundation, incorporated herein by reference.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
- ****************************************************************************
- */
-
-#include <linux/types.h> /* needed for linux/random.h */
-#include <linux/random.h>
-
-#include "accel_cuckoo_hash.h"
-#include "accel_util.h"
-
-static inline int cuckoo_hash_key_compare(cuckoo_hash_table *hashtab,
-					  cuckoo_hash_key *key1, 
-					  cuckoo_hash_key *key2)
-{
-	return !memcmp(key1, key2, hashtab->key_length);
-}
-
-
-static inline void cuckoo_hash_key_set(cuckoo_hash_key *key1, 
-				       cuckoo_hash_key *key2)
-{
-	*key1 = *key2;
-}
-
-
-/*
- * Sets hash function parameters.  Chooses "a" to be odd, 0 < a < 2^w
- * where w is the length of the key
- */
-static void set_hash_parameters(cuckoo_hash_table *hashtab)
-{
- again:
-	hashtab->a0 = hashtab->a1 = 0;
-
-	/* Make sure random */
-	get_random_bytes(&hashtab->a0, hashtab->key_length);
-	get_random_bytes(&hashtab->a1, hashtab->key_length);
-
-	/* Make sure odd */
-	hashtab->a0 |= 1;
-	hashtab->a1 |= 1;
-
-	/* Being different is good */
-	if (hashtab->a0 != hashtab->a1)
-		return;
-		       
-	goto again;
-}
-
-int cuckoo_hash_init(cuckoo_hash_table *hashtab, unsigned length_bits,
-		     unsigned key_length)
-{
-	char *table_mem;
-	unsigned length = 1 << length_bits;
-
-	BUG_ON(length_bits >= sizeof(unsigned) * 8);
-	BUG_ON(key_length > sizeof(cuckoo_hash_key));
-
-	table_mem = kmalloc(sizeof(cuckoo_hash_entry) * 2 * length, GFP_KERNEL);
-
-	if (table_mem == NULL)
-		return -ENOMEM;
-
-	hashtab->length = length;
-	hashtab->length_bits = length_bits;
-	hashtab->key_length = key_length;
-	hashtab->entries = 0;
-
-	hashtab->table0 = (cuckoo_hash_entry *)table_mem;
-	hashtab->table1 = (cuckoo_hash_entry *)
-		(table_mem + length * sizeof(cuckoo_hash_entry));
-
-	set_hash_parameters(hashtab);
-
-	/* Zero the table */
-	memset(hashtab->table0, 0, length * 2 * sizeof(cuckoo_hash_entry));
-
-	return 0;
-}
-EXPORT_SYMBOL_GPL(cuckoo_hash_init);
-
-void cuckoo_hash_destroy(cuckoo_hash_table *hashtab)
-{
-	if (hashtab->table0 != NULL)
-		kfree(hashtab->table0);
-}
-
-EXPORT_SYMBOL_GPL(cuckoo_hash_destroy);
-
-/* 
- * This computes sizeof(cuckoo_hash) bits of hash, not all will be
- * necessarily used, but the hash function throws away any that
- * aren't
- */ 
-static inline void cuckoo_compute_hash_helper(cuckoo_hash_table *hashtab,
-					      cuckoo_hash_key *a,
-					      cuckoo_hash_key *x,
-					      cuckoo_hash *result) 
-{
-	u64 multiply_result = 0, a_temp, x_temp;
-	u32 carry = 0;
-	u32 *a_words;
-	u32 *x_words;
-	int i;
-
-	/*
-	 * As the mod and div operations in the function effectively
-	 * reduce and shift the bits of the product down to just the
-	 * third word, we need only compute that and return it as a
-	 * result.
-	 *
-	 * Do enough long multiplication to get the word we need
-	 */
-
-	/* This assumes things about the sizes of the key and hash */
-	BUG_ON(hashtab->key_length % sizeof(u32) != 0);
-	BUG_ON(sizeof(cuckoo_hash) != sizeof(u32));
-
-	a_words = (u32 *)a;
-	x_words = (u32 *)x;
-
-	for (i = 0; i < hashtab->key_length / sizeof(u32); i++) {
-		a_temp = a_words[i];
-		x_temp = x_words[i];
-		
-		multiply_result = (a_temp * x_temp) + carry;
-		carry = (multiply_result >> 32) & 0xffffffff;
-	}
-	
-	*result = multiply_result & 0xffffffff;
-}
-
-
-/*
- * Want to implement (ax mod 2^w) div 2^(w-q) for odd a, 0 < a < 2^w;
- * w is the length of the key, q is the length of the hash, I think.
- * See http://www.it-c.dk/people/pagh/papers/cuckoo-jour.pdf 
- */
-static cuckoo_hash cuckoo_compute_hash(cuckoo_hash_table *hashtab, 
-				       cuckoo_hash_key *key, 
-				       cuckoo_hash_key *a)
-{
-	unsigned q = hashtab->length_bits;
-	unsigned shift = 32 - q;
-	unsigned mask = ((1 << q) - 1) << shift;
-	cuckoo_hash hash;
-
-	cuckoo_compute_hash_helper(hashtab, a, key, &hash);
-
-	/* 
-	 * Take the top few bits to get the right length for this
-	 * hash table 
-	 */
-	hash = (hash & mask) >> shift;
-
-	BUG_ON(hash >= hashtab->length);
-
-	return hash;
-}
-
-
-static int cuckoo_hash_lookup0(cuckoo_hash_table *hashtab,
-			       cuckoo_hash_key *key,
-			       cuckoo_hash_value *value)
-{
-	cuckoo_hash hash = cuckoo_compute_hash(hashtab, key, &hashtab->a0);
-
-	if ((hashtab->table0[hash].state == CUCKOO_HASH_STATE_OCCUPIED)
-	    && cuckoo_hash_key_compare(hashtab, &(hashtab->table0[hash].key),
-				       key)) {
-		*value = hashtab->table0[hash].value;
-		return 1;
-	}
-
-	return 0;
-}
-
-static int cuckoo_hash_lookup1(cuckoo_hash_table *hashtab,
-			       cuckoo_hash_key *key,
-			       cuckoo_hash_value *value)
-{
-	cuckoo_hash hash = cuckoo_compute_hash(hashtab, key, &hashtab->a1);
-
-	if ((hashtab->table1[hash].state == CUCKOO_HASH_STATE_OCCUPIED)
-	    && cuckoo_hash_key_compare(hashtab, &(hashtab->table1[hash].key),
-				       key)) {
-		*value = hashtab->table1[hash].value;
-		return 1;
-	}
-
-	return 0;
-}
-
-
-int cuckoo_hash_lookup(cuckoo_hash_table *hashtab, cuckoo_hash_key *key,
-		       cuckoo_hash_value *value)
-{
-	return cuckoo_hash_lookup0(hashtab, key, value)
-		|| cuckoo_hash_lookup1(hashtab, key, value);
-}
-EXPORT_SYMBOL_GPL(cuckoo_hash_lookup);
-
-
-/* Transfer any active entries from "old_table" into hashtab */
-static int cuckoo_hash_transfer_entries(cuckoo_hash_table *hashtab,
-					cuckoo_hash_entry *old_table,
-					unsigned capacity)
-{
-	int i, rc;
-	cuckoo_hash_entry *entry;
-
-	hashtab->entries = 0;
-
-	for (i = 0; i < capacity; i++) {
-		entry = &old_table[i];
-		if (entry->state == CUCKOO_HASH_STATE_OCCUPIED) {
-			rc = cuckoo_hash_add(hashtab, &(entry->key), 
-					     entry->value, 0);
-			if (rc != 0) {
-				return rc;
-			}
-		}
-	}
-  
-	return 0;
-}
-
-
-int cuckoo_hash_rehash(cuckoo_hash_table *hashtab)
-{
-	cuckoo_hash_entry *new_table;
-	cuckoo_hash_table old_hashtab;
-	int resize = 0, rc, rehash_count;
-
-	/*
-	 * Store old tables so we can access the existing values and
-	 * copy across
-	 */
-	memcpy(&old_hashtab, hashtab, sizeof(cuckoo_hash_table));
-
-	/* resize if hashtable is more than half full */
-	if (old_hashtab.entries > old_hashtab.length &&
-	    old_hashtab.length_bits < 32)
-		resize = 1;
-
- resize:
-	if (resize) {
-		new_table = kmalloc(sizeof(cuckoo_hash_entry) * 4 * hashtab->length,
-				    GFP_ATOMIC);
-		if (new_table == NULL) {
-			rc = -ENOMEM;
-			goto err;
-		}
-
-		hashtab->length = 2 * hashtab->length;
-		hashtab->length_bits++;
-	} else {
-		new_table = kmalloc(sizeof(cuckoo_hash_entry) * 2 * hashtab->length,
-				    GFP_ATOMIC);
-		if (new_table == NULL) {
-			rc = -ENOMEM;
-			goto err;
-		}
-	}
-    
-	/*
-	 * Point hashtab to new memory region so we can try to
-	 * construct new table
-	 */
-	hashtab->table0 = new_table;
-	hashtab->table1 = (cuckoo_hash_entry *)
-		((char *)new_table + hashtab->length * sizeof(cuckoo_hash_entry));
-  
-	rehash_count = 0;
-
- again:
-	/* Zero the new tables */
-	memset(new_table, 0, hashtab->length * 2 * sizeof(cuckoo_hash_entry));
-
-	/* Choose new parameters for the hash functions */
-	set_hash_parameters(hashtab);
-
-	/*
-	 * Multiply old_table_length by 2 as the length refers to each
-	 * table, and there are two of them.  This assumes that they
-	 * are arranged sequentially in memory, so assert it 
-	 */
-	BUG_ON(((char *)old_hashtab.table1) != 
-	       ((char *)old_hashtab.table0 + old_hashtab.length
-		* sizeof(cuckoo_hash_entry)));
-	rc = cuckoo_hash_transfer_entries(hashtab, old_hashtab.table0, 
-					  old_hashtab.length * 2);
-	if (rc < 0) {
-		/* Problem */
-		if (rc == -ENOSPC) {
-			++rehash_count;
-			if (rehash_count < CUCKOO_HASH_MAX_LOOP) {
-				/*
-				 * Wanted to rehash, but rather than
-				 * recurse we can just do it here
-				 */
-				goto again;
-			} else {
-				/*
-				 * Didn't manage to rehash, so let's
-				 * go up a size (if we haven't already
-				 * and there's space)
-				 */
-				if (!resize && hashtab->length_bits < 32) {
-					resize = 1;
-					kfree(new_table);
-					goto resize;
-				}
-				else
-					goto err;
-			}
-		}
-		else
-			goto err;
-	}
-
-	/* Success, I think.  Free up the old table */
-	kfree(old_hashtab.table0);
-  
-	/* We should have put all the entries from old table in the new one */
-	BUG_ON(hashtab->entries != old_hashtab.entries);
-
-	return 0;
- err:
-	EPRINTK("%s: Rehash failed, giving up\n", __FUNCTION__);
-	/* Some other error, give up, at least restore table to how it was */
-	memcpy(hashtab, &old_hashtab, sizeof(cuckoo_hash_table));
-	if (new_table)
-		kfree(new_table);
-	return rc;
-}
-EXPORT_SYMBOL_GPL(cuckoo_hash_rehash);
-
-
-static int 
-cuckoo_hash_insert_or_displace(cuckoo_hash_entry *table, unsigned hash,
-			       cuckoo_hash_key *key, 
-			       cuckoo_hash_value value,
-			       cuckoo_hash_key *displaced_key, 
-			       cuckoo_hash_value *displaced_value)
-{
-	if (table[hash].state == CUCKOO_HASH_STATE_VACANT) {
-		cuckoo_hash_key_set(&(table[hash].key), key);
-		table[hash].value = value;
-		table[hash].state = CUCKOO_HASH_STATE_OCCUPIED;
-
-		return 1;
-	} else {
-		cuckoo_hash_key_set(displaced_key, &(table[hash].key));
-		*displaced_value = table[hash].value;
-		cuckoo_hash_key_set(&(table[hash].key), key);
-		table[hash].value = value;
-
-		return 0;
-	}
-}
-
-
-int cuckoo_hash_add(cuckoo_hash_table *hashtab, cuckoo_hash_key *key,
-		     cuckoo_hash_value value, int can_rehash)
-{
-	cuckoo_hash hash0, hash1;
-	int i, rc;
-	cuckoo_hash_key key1, key2;
-
-	cuckoo_hash_key_set(&key1, key);
-
- again:
-	i = 0;
-	do {
-		hash0 = cuckoo_compute_hash(hashtab, &key1, &hashtab->a0);
-		if (cuckoo_hash_insert_or_displace(hashtab->table0, hash0, 
-						   &key1, value, &key2,
-						   &value)) {
-			/* Success */
-			hashtab->entries++;
-			return 0;
-		}
-	
-		hash1 = cuckoo_compute_hash(hashtab, &key2, &hashtab->a1);
-		if (cuckoo_hash_insert_or_displace(hashtab->table1, hash1,
-						   &key2, value, &key1,
-						   &value)) {
-			/* Success */
-			hashtab->entries++;
-			return 0;
-		}
-	} while (++i < CUCKOO_HASH_MAX_LOOP);
-
-	if (can_rehash) {
-		if ((rc = cuckoo_hash_rehash(hashtab)) < 0) {
-			/*
-			 * Give up - this will drop whichever
-			 * key/value pair we have currently displaced
-			 * on the floor
-			 */
-			return rc;
-		}
-		goto again;
-	}
-  
-	EPRINTK("%s: failed hash add\n", __FUNCTION__);
-	/*
-	 * Couldn't do it - bad as we've now removed some random thing
-	 * from the table, and will just drop it on the floor.  Better
-	 * would be to somehow revert the table to the state it was in
-	 * at the start
-	 */
-	return -ENOSPC;
-}
-EXPORT_SYMBOL_GPL(cuckoo_hash_add);
-
-
-int cuckoo_hash_add_check(cuckoo_hash_table *hashtab,
-			  cuckoo_hash_key *key, cuckoo_hash_value value,
-			  int can_rehash)
-{
-	int stored_value;
-
-	if (cuckoo_hash_lookup(hashtab, key, &stored_value))
-		return -EBUSY;
-
-	return cuckoo_hash_add(hashtab, key, value, can_rehash);
-}
-EXPORT_SYMBOL_GPL(cuckoo_hash_add_check);
-
-
-int cuckoo_hash_remove(cuckoo_hash_table *hashtab, cuckoo_hash_key *key)
-{
-	cuckoo_hash hash;
-
-	hash = cuckoo_compute_hash(hashtab, key, &hashtab->a0);
-	if ((hashtab->table0[hash].state == CUCKOO_HASH_STATE_OCCUPIED) &&
-	    cuckoo_hash_key_compare(hashtab, &(hashtab->table0[hash].key),
-				    key)) {
-		hashtab->table0[hash].state = CUCKOO_HASH_STATE_VACANT;
-		hashtab->entries--;
-		return 0;
-	}
-  
-	hash = cuckoo_compute_hash(hashtab, key, &hashtab->a1);
-	if ((hashtab->table1[hash].state == CUCKOO_HASH_STATE_OCCUPIED) &&
-	    cuckoo_hash_key_compare(hashtab, &(hashtab->table1[hash].key),
-				    key)) {
-		hashtab->table1[hash].state = CUCKOO_HASH_STATE_VACANT;
-		hashtab->entries--;
-		return 0;
-	}
- 
-	return -EINVAL;
-}
-EXPORT_SYMBOL_GPL(cuckoo_hash_remove);
-
-
-int cuckoo_hash_update(cuckoo_hash_table *hashtab, cuckoo_hash_key *key,
-		       cuckoo_hash_value value)
-{
-	cuckoo_hash hash;
-
-	hash = cuckoo_compute_hash(hashtab, key, &hashtab->a0);
-	if ((hashtab->table0[hash].state == CUCKOO_HASH_STATE_OCCUPIED) &&
-	    cuckoo_hash_key_compare(hashtab, &(hashtab->table0[hash].key),
-				    key)) {
-		hashtab->table0[hash].value = value;
-		return 0;
-	}
-
-	hash = cuckoo_compute_hash(hashtab, key, &hashtab->a1);
-	if ((hashtab->table1[hash].state == CUCKOO_HASH_STATE_OCCUPIED) &&
-	    cuckoo_hash_key_compare(hashtab, &(hashtab->table1[hash].key),
-				    key)) {
-		hashtab->table1[hash].value = value;
-		return 0;
-	}
-
-	return -EINVAL;
-}
-EXPORT_SYMBOL_GPL(cuckoo_hash_update);
-
-
-void cuckoo_hash_iterate_reset(cuckoo_hash_table *hashtab)
-{
-	hashtab->iterate_index = 0;
-}
-EXPORT_SYMBOL_GPL(cuckoo_hash_iterate_reset);
-
-
-int cuckoo_hash_iterate(cuckoo_hash_table *hashtab,
-			cuckoo_hash_key *key, cuckoo_hash_value *value)
-{
-	unsigned index;
-
-	while (hashtab->iterate_index < hashtab->length) {
-		index = hashtab->iterate_index;
-		++hashtab->iterate_index;
-		if (hashtab->table0[index].state == CUCKOO_HASH_STATE_OCCUPIED) {
-			*key = hashtab->table0[index].key;
-			*value = hashtab->table0[index].value;
-			return 0;
-		}
-	}
-
-	while (hashtab->iterate_index >= hashtab->length &&
-	       hashtab->iterate_index < hashtab->length * 2) {
-		index = hashtab->iterate_index - hashtab->length;
-		++hashtab->iterate_index;		
-		if (hashtab->table1[index].state == CUCKOO_HASH_STATE_OCCUPIED) {
-			*key = hashtab->table1[index].key;
-			*value = hashtab->table1[index].value;
-			return 0;
-		}
-	}
-
-	return -ENOSPC;
-}
-EXPORT_SYMBOL_GPL(cuckoo_hash_iterate);
-
-
-#if 0
-void cuckoo_hash_valid(cuckoo_hash_table *hashtab)
-{
-	int i, entry_count = 0;
-
-	for (i=0; i < hashtab->length; i++) {
-		EPRINTK_ON(hashtab->table0[i].state != CUCKOO_HASH_STATE_VACANT &&
-			   hashtab->table0[i].state != CUCKOO_HASH_STATE_OCCUPIED);
-		if (hashtab->table0[i].state == CUCKOO_HASH_STATE_OCCUPIED)
-			entry_count++;
-		EPRINTK_ON(hashtab->table1[i].state != CUCKOO_HASH_STATE_VACANT &&
-			   hashtab->table1[i].state != CUCKOO_HASH_STATE_OCCUPIED);
-		if (hashtab->table1[i].state == CUCKOO_HASH_STATE_OCCUPIED)
-			entry_count++;	
-	}
-	
-	if (entry_count != hashtab->entries) {
-		EPRINTK("%s: bad count\n", __FUNCTION__);
-		cuckoo_hash_dump(hashtab);
-		return;
-	}
-
-	for (i=0; i< hashtab->length; i++) {
-		if (hashtab->table0[i].state == CUCKOO_HASH_STATE_OCCUPIED)
-			if (i != cuckoo_compute_hash(hashtab, 
-						     &hashtab->table0[i].key, 
-						     &hashtab->a0)) {
-				EPRINTK("%s: Bad key table 0 index %d\n",
-					__FUNCTION__, i);
-				cuckoo_hash_dump(hashtab);
-				return;
-			}
-		if (hashtab->table1[i].state == CUCKOO_HASH_STATE_OCCUPIED)
-			if (i != cuckoo_compute_hash(hashtab, 
-						     &hashtab->table1[i].key, 
-						     &hashtab->a1)) {
-				EPRINTK("%s: Bad key table 1 index %d\n",
-					__FUNCTION__, i);
-				cuckoo_hash_dump(hashtab);
-				return;
-			}
-	}
-
-}
-EXPORT_SYMBOL_GPL(cuckoo_hash_valid);
-
-
-void cuckoo_hash_dump(cuckoo_hash_table *hashtab)
-{
-	int i, entry_count;
-
-	entry_count = 0;
-	for (i=0; i < hashtab->length; i++) {
-		EPRINTK_ON(hashtab->table0[i].state != CUCKOO_HASH_STATE_VACANT &&
-			   hashtab->table0[i].state != CUCKOO_HASH_STATE_OCCUPIED);
-		if (hashtab->table0[i].state == CUCKOO_HASH_STATE_OCCUPIED)
-			entry_count++;
-		EPRINTK_ON(hashtab->table1[i].state != CUCKOO_HASH_STATE_VACANT &&
-			   hashtab->table1[i].state != CUCKOO_HASH_STATE_OCCUPIED);
-		if (hashtab->table1[i].state == CUCKOO_HASH_STATE_OCCUPIED)
-			entry_count++;	
-	}
-
-	EPRINTK("======================\n");
-	EPRINTK("Cuckoo hash table dump\n");
-	EPRINTK("======================\n");
-	EPRINTK("length: %d; length_bits: %d; key_length: %d\n", hashtab->length,
-		hashtab->length_bits, hashtab->key_length);
-	EPRINTK("Recorded entries: %d\n", hashtab->entries);
-	EPRINTK("Counted entries: %d\n", entry_count);
-	EPRINTK("a0: %llx; a1: %llx\n", hashtab->a0, hashtab->a1);
-	EPRINTK("-----------------------------------------\n");
-	EPRINTK("Index  Occupied  Key  Value Index0 Index1\n");
-	EPRINTK("-----------------------------------------\n");		
-	for (i=0; i< hashtab->length; i++) {
-		if (hashtab->table0[i].state == CUCKOO_HASH_STATE_OCCUPIED)
-		EPRINTK("%d %d %llx %d %d %d\n", i,
-			hashtab->table0[i].state == CUCKOO_HASH_STATE_OCCUPIED,
-			hashtab->table0[i].key, hashtab->table0[i].value,
-			cuckoo_compute_hash(hashtab, &hashtab->table0[i].key, 
-					    &hashtab->a0),
-			cuckoo_compute_hash(hashtab, &hashtab->table0[i].key, 
-					    &hashtab->a1));
-		else
-		EPRINTK("%d %d - - - -\n", i,
-			hashtab->table0[i].state == CUCKOO_HASH_STATE_OCCUPIED);
-			
-	}
-	EPRINTK("-----------------------------------------\n");
-	EPRINTK("Index  Occupied  Key  Value Index0 Index1\n");
-	EPRINTK("-----------------------------------------\n");
-	for (i=0; i< hashtab->length; i++) {
-		if (hashtab->table1[i].state == CUCKOO_HASH_STATE_OCCUPIED)
-		EPRINTK("%d %d %llx %d %d %d\n", i,
-			hashtab->table1[i].state == CUCKOO_HASH_STATE_OCCUPIED,
-			hashtab->table1[i].key, hashtab->table1[i].value,
-			cuckoo_compute_hash(hashtab, &hashtab->table1[i].key, 
-					    &hashtab->a0),
-			cuckoo_compute_hash(hashtab, &hashtab->table1[i].key, 
-					    &hashtab->a1));
-		else
-		EPRINTK("%d %d - - - -\n", i,
-			hashtab->table1[i].state == CUCKOO_HASH_STATE_OCCUPIED);
-	} 
-	EPRINTK("======================\n");
-}
-EXPORT_SYMBOL_GPL(cuckoo_hash_dump);
-#endif
diff -r 9566a4a50a43 drivers/xen/sfc_netutil/accel_cuckoo_hash.h
--- a/drivers/xen/sfc_netutil/accel_cuckoo_hash.h
+++ /dev/null
@@ -1,227 +0,0 @@
-/****************************************************************************
- * Solarflare driver for Xen network acceleration
- *
- * Copyright 2006-2008: Solarflare Communications Inc,
- *                      9501 Jeronimo Road, Suite 250,
- *                      Irvine, CA 92618, USA
- *
- * Maintained by Solarflare Communications <linux-xen-drivers@solarflare.com>
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 as published
- * by the Free Software Foundation, incorporated herein by reference.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
- ****************************************************************************
- */
-
-/*
- * A cuckoo hash table consists of two sub tables.  Each entry can
- * hash to a position in each table.  If, on entry, its position is
- * found to be occupied, the existing element is moved to it's other
- * location.  This recurses until success or a loop is found.  If a
- * loop is found the table is rehashed.
- *
- *  See http://www.it-c.dk/people/pagh/papers/cuckoo-jour.pdf
- */
-
-#ifndef NET_ACCEL_CUCKOO_HASH_H
-#define NET_ACCEL_CUCKOO_HASH_H
-
-/*! Type used for hash table keys of ip pairs */
-typedef struct {
-	u32 local_ip;
-	//u32 remote_ip;
-	u16 local_port;
-	//u16 remote_port;
-	/* Technically only 1 bit, but use 16 to make key a round
-	   number size */
-	u16 proto;
-} cuckoo_hash_ip_key;
-
-/*! Type used for hash table keys of mac addresses */
-typedef u64 cuckoo_hash_mac_key;
-
-/*! This type is designed to be large enough to hold all supported key
- *  sizes to avoid having to malloc storage for them.
- */
-typedef u64 cuckoo_hash_key;
-
-/*! Type used for the values stored in the hash table */
-typedef int cuckoo_hash_value;
-
-/*! Type used for the hash used to index the table */
-typedef u32 cuckoo_hash;
-
-/*! How long to spend displacing values when adding before giving up
- *  and rehashing */
-#define CUCKOO_HASH_MAX_LOOP (hashtab->length)
-
-/*! State of hash table entry */
-typedef enum {
-	CUCKOO_HASH_STATE_VACANT = 0,
-	CUCKOO_HASH_STATE_OCCUPIED 
-} cuckoo_hash_state;
-
-/*! An entry in the hash table */
-typedef struct {
-	cuckoo_hash_state state;
-	cuckoo_hash_key key;
-	cuckoo_hash_value value;
-} cuckoo_hash_entry;
-
-/*! A cuckoo hash table */
-typedef struct {
-	/*! The length of each table (NB. there are two tables of this
-	 *  length) */
-	unsigned length; 
-	/*! The length of each table in bits */
-	unsigned length_bits;
-	/*! The length of the key in bytes */ 
-	unsigned key_length; 
-	/*! The number of entries currently stored in the table */
-	unsigned entries;
-	/*! Index into table used by cuckoo_hash_iterate */
-	unsigned iterate_index; 
-
-	/* parameter of hash functions */
-	/*! The "a" parameter of the first hash function */
-	cuckoo_hash_key a0; 
-	/*! The "a" parameter of the second hash function */
-	cuckoo_hash_key a1; 
-
-	/*! The first table */
-	cuckoo_hash_entry *table0; 
-	/*! The second table */
-	cuckoo_hash_entry *table1; 
-} cuckoo_hash_table;
-
-/*! Initialise the cuckoo has table 
- *
- * \param hashtab A pointer to an unitialised hash table structure
- * \param length_bits The number of elements in each table equals
- * 2**length_bits
- * \param key_length The length of the key in bytes
- *
- * \return 0 on success, -ENOMEM if it couldn't allocate the tables
- */
-extern
-int cuckoo_hash_init(cuckoo_hash_table *hashtab, unsigned length_bits,
-		     unsigned key_length);
-
-
-/*! Destroy a hash table
- *
- * \param hashtab A hash table that has previously been passed to a
- * successful call of cuckoo_hash_init()
- */
-extern
-void cuckoo_hash_destroy(cuckoo_hash_table *hashtab);
-
-
-/*! Lookup an entry in the hash table 
- *
- * \param hashtab The hash table in which to look.
- * \param key Pointer to a mac address to use as the key
- * \param value On exit set to the value stored if key was present
- *
- * \return 0 if not present in the table, non-zero if it is (and value
- * is set accordingly)
- */
-extern
-int cuckoo_hash_lookup(cuckoo_hash_table *hashtab,
-		       cuckoo_hash_key *key,
-		       cuckoo_hash_value *value);
-
-/*! Add an entry to the hash table.  Key must not be a duplicate of
- * anything already in the table.  If this is a risk, see
- * cuckoo_hash_add_check
- *
- * \param hashtab The hash table to add the entry to
- * \param key Pointer to a mac address to use as a key
- * \param value The value to store 
- * \param can_rehash Flag to allow the add function to rehash the
- * table if necessary
- *
- * \return 0 on success, non-zero on failure.  -ENOSPC means it just
- * couldn't find anywhere to put it - this is bad and probably means
- * an entry has been dropped on the floor (but the entry you just
- * tried to add may now be included)
- */
-extern
-int cuckoo_hash_add(cuckoo_hash_table *hashtab,
-		    cuckoo_hash_key *key, 
-		    cuckoo_hash_value value,
-		    int can_rehash);
-
-/*! Same as cuckoo_hash_add but first checks to ensure entry is not
- * already there
- * \return -EBUSY if already there
- */
-
-extern
-int cuckoo_hash_add_check(cuckoo_hash_table *hashtab,
-			  cuckoo_hash_key *key, 
-			  cuckoo_hash_value value,
-			  int can_rehash);
-/*! Remove an entry from the table 
- *
- * \param hashtab The hash table to remove the entry from
- * \param key The key that was used to previously add the entry
- *
- * \return 0 on success, -EINVAL if the entry couldn't be found 
- */
-extern
-int cuckoo_hash_remove(cuckoo_hash_table *hashtab, cuckoo_hash_key *key);
-
-
-/*! Helper for those using mac addresses to convert to a key for the
- *  hash table
- */
-static inline cuckoo_hash_mac_key cuckoo_mac_to_key(const u8 *mac)
-{
-	return (cuckoo_hash_mac_key)(mac[0])
-		| (cuckoo_hash_mac_key)(mac[1]) << 8
-		| (cuckoo_hash_mac_key)(mac[2]) << 16
-		| (cuckoo_hash_mac_key)(mac[3]) << 24
-		| (cuckoo_hash_mac_key)(mac[4]) << 32
-		| (cuckoo_hash_mac_key)(mac[5]) << 40;
-}
-
-
-/*! Update an entry already in the hash table to take a new value 
- *
- * \param hashtab The hash table to add the entry to
- * \param key Pointer to a mac address to use as a key
- * \param value The value to store 
- *
- * \return 0 on success, non-zero on failure. 
- */
-int cuckoo_hash_update(cuckoo_hash_table *hashtab, cuckoo_hash_key *key,
-		       cuckoo_hash_value value);
-
-
-/*! Go through the hash table and return all used entries (one per call)
- *
- * \param hashtab The hash table to iterate over 
- * \param key Pointer to a key to take the returned key
- * \param value Pointer to a value to take the returned value
- *
- * \return 0 on success (key, value set), non-zero on failure.
- */
-int cuckoo_hash_iterate(cuckoo_hash_table *hashtab,
-			cuckoo_hash_key *key, cuckoo_hash_value *value);
-void cuckoo_hash_iterate_reset(cuckoo_hash_table *hashtab);
-
-/* debug, not compiled by default */
-void cuckoo_hash_valid(cuckoo_hash_table *hashtab);
-void cuckoo_hash_dump(cuckoo_hash_table *hashtab);
-
-#endif /* NET_ACCEL_CUCKOO_HASH_H */
diff -r 9566a4a50a43 drivers/xen/sfc_netutil/accel_msg_iface.c
--- a/drivers/xen/sfc_netutil/accel_msg_iface.c
+++ /dev/null
@@ -1,301 +0,0 @@
-/****************************************************************************
- * Solarflare driver for Xen network acceleration
- *
- * Copyright 2006-2008: Solarflare Communications Inc,
- *                      9501 Jeronimo Road, Suite 250,
- *                      Irvine, CA 92618, USA
- *
- * Maintained by Solarflare Communications <linux-xen-drivers@solarflare.com>
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 as published
- * by the Free Software Foundation, incorporated herein by reference.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
- ****************************************************************************
- */
-
-#include <xen/evtchn.h>
-
-#include "accel_util.h"
-#include "accel_msg_iface.h"
-
-#define NET_ACCEL_MSG_Q_SIZE (1024)
-#define NET_ACCEL_MSG_Q_MASK (NET_ACCEL_MSG_Q_SIZE - 1)
-
-#ifdef NDEBUG
-#define NET_ACCEL_CHECK_MAGIC(_p, _errval)
-#define NET_ACCEL_SHOW_QUEUE(_t, _q, _id)
-#else
-#define NET_ACCEL_CHECK_MAGIC(_p, _errval)				\
-	if (_p->magic != NET_ACCEL_MSG_MAGIC) {				\
-		printk(KERN_ERR "%s: passed invalid shared page %p!\n", \
-		       __FUNCTION__, _p);				\
-		return _errval;						\
-	}
-#define NET_ACCEL_SHOW_QUEUE(_t, _q, _id)				\
-	printk(_t ": queue %d write %x read %x base %x limit %x\n",     \
-	       _id, _q->write, _q->read, _q->base, _q->limit);
-#endif
-
-/*
- * We've been passed at least 2 pages. 1 control page and 1 or more
- * data pages.
- */
-int net_accel_msg_init_page(void *mem, int len, int up)
-{
-	struct net_accel_shared_page *shared_page = 
-		(struct net_accel_shared_page*)mem;
-
-	if ((unsigned long)shared_page & NET_ACCEL_MSG_Q_MASK)
-		return -EINVAL;
-
-	shared_page->magic = NET_ACCEL_MSG_MAGIC;
-
-	shared_page->aflags = 0;
-
-	shared_page->net_dev_up = up;
-
-	return 0;
-}
-EXPORT_SYMBOL_GPL(net_accel_msg_init_page);
-
-
-void net_accel_msg_init_queue(sh_msg_fifo2 *queue,
-			      struct net_accel_msg_queue *indices,
-			      struct net_accel_msg *base, int size)
-{
-	queue->fifo = base;
-	spin_lock_init(&queue->lock);
-	sh_fifo2_init(queue, size-1, &indices->read, &indices->write);
-}
-EXPORT_SYMBOL_GPL(net_accel_msg_init_queue);
-
-
-static inline int _net_accel_msg_send(struct net_accel_shared_page *sp,
-				      sh_msg_fifo2 *queue,
-				      struct net_accel_msg *msg,
-				      int is_reply)
-{
-	int rc = 0;
-	NET_ACCEL_CHECK_MAGIC(sp, -EINVAL);
-	rmb();
-	if (is_reply) {
-		EPRINTK_ON(sh_fifo2_is_full(queue));
-		sh_fifo2_put(queue, *msg);
-	} else {
-		if (sh_fifo2_not_half_full(queue)) {
-			sh_fifo2_put(queue, *msg);
-		} else {
-			rc = -ENOSPC;
-		}
-	}
-	wmb();
-	return rc;
-}
-
-/* Notify after a batch of messages have been sent */
-void net_accel_msg_notify(int irq)
-{
-	notify_remote_via_irq(irq);
-}
-EXPORT_SYMBOL_GPL(net_accel_msg_notify);
-
-/* 
- * Send a message on the specified FIFO. Returns 0 on success, -errno
- * on failure. The message in msg is copied to the current slot of the
- * FIFO.
- */
-int net_accel_msg_send(struct net_accel_shared_page *sp, sh_msg_fifo2 *q, 
-		       struct net_accel_msg *msg)
-{
-	unsigned long flags;
-	int rc;
-	net_accel_msg_lock_queue(q, &flags);
-	rc = _net_accel_msg_send(sp, q, msg, 0);
-	net_accel_msg_unlock_queue(q, &flags);
-	return rc;
-}
-EXPORT_SYMBOL_GPL(net_accel_msg_send);
-
-
-/* As net_accel_msg_send but also posts a notification to the far end. */
-int net_accel_msg_send_notify(struct net_accel_shared_page *sp, int irq, 
-			      sh_msg_fifo2 *q, struct net_accel_msg *msg)
-{
-	unsigned long flags;
-	int rc;
-	net_accel_msg_lock_queue(q, &flags);
-	rc = _net_accel_msg_send(sp, q, msg, 0);
-	net_accel_msg_unlock_queue(q, &flags);
-	if (rc >= 0)
-		notify_remote_via_irq(irq);
-	return rc;
-}
-EXPORT_SYMBOL_GPL(net_accel_msg_send_notify);
-
-
-int net_accel_msg_reply(struct net_accel_shared_page *sp, sh_msg_fifo2 *q, 
-		       struct net_accel_msg *msg)
-{
-	unsigned long flags;
-	int rc;
-	net_accel_msg_lock_queue(q, &flags);
-	rc = _net_accel_msg_send(sp, q, msg, 1);
-	net_accel_msg_unlock_queue(q, &flags);
-	return rc;
-}
-EXPORT_SYMBOL_GPL(net_accel_msg_reply);
-
-
-/* As net_accel_msg_send but also posts a notification to the far end. */
-int net_accel_msg_reply_notify(struct net_accel_shared_page *sp, int irq, 
-			      sh_msg_fifo2 *q, struct net_accel_msg *msg)
-{
-	unsigned long flags;
-	int rc;
-	net_accel_msg_lock_queue(q, &flags);
-	rc = _net_accel_msg_send(sp, q, msg, 1);
-	net_accel_msg_unlock_queue(q, &flags);
-	if (rc >= 0)
-		notify_remote_via_irq(irq);
-	return rc;
-}
-EXPORT_SYMBOL_GPL(net_accel_msg_reply_notify);
-
-
-/*
- * Look at a received message, if any, so a decision can be made about
- * whether to read it now or not.  Cookie is a bit of debug which is
- * set here and checked when passed to net_accel_msg_recv_next()
- */
-int net_accel_msg_peek(struct net_accel_shared_page *sp, 
-		       sh_msg_fifo2 *queue, 
-		       struct net_accel_msg *msg, int *cookie)
-{
-	unsigned long flags;
-	int rc = 0;
-	NET_ACCEL_CHECK_MAGIC(sp, -EINVAL);
-	net_accel_msg_lock_queue(queue, &flags);
-	rmb();
-	if (sh_fifo2_is_empty(queue)) {
-		rc = -ENOENT;
-	} else {
-		*msg = sh_fifo2_peek(queue);
-		*cookie = *(queue->fifo_rd_i);
-	}
-	net_accel_msg_unlock_queue(queue, &flags);
-	return rc;
-}
-EXPORT_SYMBOL_GPL(net_accel_msg_peek);
-
-
-/*
- * Move the queue onto the next element, used after finished with a
- * peeked msg 
- */
-int net_accel_msg_recv_next(struct net_accel_shared_page *sp, 
-			    sh_msg_fifo2 *queue, int cookie)
-{
-	unsigned long flags;
-	NET_ACCEL_CHECK_MAGIC(sp, -EINVAL);
-	net_accel_msg_lock_queue(queue, &flags);
-	rmb();
-	/* Mustn't be empty */
-	BUG_ON(sh_fifo2_is_empty(queue));
-	/* 
-	 * Check cookie matches, i.e. we're advancing over the same message
-	 * as was got using peek 
-	 */
-	BUG_ON(cookie != *(queue->fifo_rd_i));
-	sh_fifo2_rd_next(queue);
-	wmb();
-	net_accel_msg_unlock_queue(queue, &flags);
-	return 0;
-}
-EXPORT_SYMBOL_GPL(net_accel_msg_recv_next);
-
-
-/* 
- * Receive a message on the specified FIFO. Returns 0 on success,
- * -errno on failure.
- */
-int net_accel_msg_recv(struct net_accel_shared_page *sp, sh_msg_fifo2 *queue, 
-		       struct net_accel_msg *msg)
-{
-	unsigned long flags;
-	int rc = 0;
-	NET_ACCEL_CHECK_MAGIC(sp, -EINVAL);
-	net_accel_msg_lock_queue(queue, &flags);
-	rmb();
-	if (sh_fifo2_is_empty(queue)) {
-		rc = -ENOENT;
-	} else {
-		sh_fifo2_get(queue, msg);
-	}
-	wmb();
-	net_accel_msg_unlock_queue(queue, &flags);
-	return rc;
-}
-EXPORT_SYMBOL_GPL(net_accel_msg_recv);
-
-
-/* 
- * Start sending a message without copying. returns a pointer to a message
- * that will be filled out in place. The queue is locked until the message 
- * is sent.
- */
-struct net_accel_msg *net_accel_msg_start_send(struct net_accel_shared_page *sp,
-					       sh_msg_fifo2 *queue, unsigned long *flags)
-{
-	struct net_accel_msg *msg;
-	NET_ACCEL_CHECK_MAGIC(sp, NULL);
-	net_accel_msg_lock_queue(queue, flags);
-	rmb();
-	if (sh_fifo2_not_half_full(queue)) {
-		msg = sh_fifo2_pokep(queue);
-	} else {
-		net_accel_msg_unlock_queue(queue, flags);
-		msg = NULL;
-	}
-	return msg;
-}
-EXPORT_SYMBOL_GPL(net_accel_msg_start_send);
-
-
-static inline void _msg_complete(struct net_accel_shared_page *sp,
-				 sh_msg_fifo2 *queue,
-				 unsigned long *flags)
-{
-	sh_fifo2_wr_next(queue);
-	net_accel_msg_unlock_queue(queue, flags);
-}
-
-/*
- * Complete the sending of a message started with net_accel_msg_start_send. The 
- * message is implicit since the queue was locked by _start
- */
-void net_accel_msg_complete_send(struct net_accel_shared_page *sp,
-				 sh_msg_fifo2 *queue,
-				 unsigned long *flags)
-{
-	_msg_complete(sp, queue, flags);
-}
-EXPORT_SYMBOL_GPL(net_accel_msg_complete_send);
-
-/* As net_accel_msg_complete_send but does the notify. */
-void net_accel_msg_complete_send_notify(struct net_accel_shared_page *sp, 
-					sh_msg_fifo2 *queue, 
-					unsigned long *flags, int irq)
-{
-	_msg_complete(sp, queue, flags);
-	notify_remote_via_irq(irq);
-}
-EXPORT_SYMBOL_GPL(net_accel_msg_complete_send_notify);
diff -r 9566a4a50a43 drivers/xen/sfc_netutil/accel_msg_iface.h
--- a/drivers/xen/sfc_netutil/accel_msg_iface.h
+++ /dev/null
@@ -1,415 +0,0 @@
-/****************************************************************************
- * Solarflare driver for Xen network acceleration
- *
- * Copyright 2006-2008: Solarflare Communications Inc,
- *                      9501 Jeronimo Road, Suite 250,
- *                      Irvine, CA 92618, USA
- *
- * Maintained by Solarflare Communications <linux-xen-drivers@solarflare.com>
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 as published
- * by the Free Software Foundation, incorporated herein by reference.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
- ****************************************************************************
- */
-
-#ifndef NET_ACCEL_MSG_IFACE_H
-#define NET_ACCEL_MSG_IFACE_H
-
-#include <linux/ip.h>
-#include <linux/tcp.h>
-#include <linux/udp.h>
-#include <linux/in.h>
-#include <linux/netdevice.h>
-#include <linux/etherdevice.h>
-
-#include "accel_shared_fifo.h"
-
-#define NET_ACCEL_MSG_MAGIC (0x85465479)
-
-/*! We talk version 0.010 of the interdomain protocol */
-#define NET_ACCEL_MSG_VERSION (0x00001000)
-
-/*! Shared memory portion of inter-domain FIFO */
-struct net_accel_msg_queue {
-	u32 read;
-	u32 write;
-};
-
-
-/*
- * The aflags in the following structure is used as follows:
- *
- *  - each bit is set when one of the corresponding variables is
- *  changed by either end.
- *
- *  - the end that has made the change then forwards an IRQ to the
- *  other
- *
- *  - the IRQ handler deals with these bits either on the fast path, or
- *  for less common changes, by jumping onto the slow path.
- *
- *  - once it has seen a change, it clears the relevant bit.
- *
- * aflags is accessed atomically using clear_bit, test_bit,
- * test_and_set_bit etc
- */
-
-/*
- * The following used to signify to the other domain when the queue
- * they want to use is full, and when it is no longer full.  Could be
- * compressed to use fewer bits but done this way for simplicity and
- * clarity
- */
-
-/* "dom0->domU queue" is full */
-#define NET_ACCEL_MSG_AFLAGS_QUEUE0FULL      0x1 
-#define NET_ACCEL_MSG_AFLAGS_QUEUE0FULL_B    0
-/* "dom0->domU queue" is not full */
-#define NET_ACCEL_MSG_AFLAGS_QUEUE0NOTFULL   0x2 
-#define NET_ACCEL_MSG_AFLAGS_QUEUE0NOTFULL_B 1
-/* "domU->dom0 queue" is full */
-#define NET_ACCEL_MSG_AFLAGS_QUEUEUFULL      0x4 
-#define NET_ACCEL_MSG_AFLAGS_QUEUEUFULL_B    2
-/* "domU->dom0 queue" is not full */
-#define NET_ACCEL_MSG_AFLAGS_QUEUEUNOTFULL   0x8
-#define NET_ACCEL_MSG_AFLAGS_QUEUEUNOTFULL_B 3
-/* dom0 -> domU net_dev up/down events */
-#define NET_ACCEL_MSG_AFLAGS_NETUPDOWN	 0x10
-#define NET_ACCEL_MSG_AFLAGS_NETUPDOWN_B       4
-
-/*
- * Masks used to test if there are any messages for domU and dom0
- * respectively
- */
-#define NET_ACCEL_MSG_AFLAGS_TO_DOMU_MASK	\
-	(NET_ACCEL_MSG_AFLAGS_QUEUE0FULL    |	\
-	 NET_ACCEL_MSG_AFLAGS_QUEUEUNOTFULL |	\
-	 NET_ACCEL_MSG_AFLAGS_NETUPDOWN)
-#define NET_ACCEL_MSG_AFLAGS_TO_DOM0_MASK	\
-	(NET_ACCEL_MSG_AFLAGS_QUEUE0NOTFULL |	\
-	 NET_ACCEL_MSG_AFLAGS_QUEUEUFULL)
-
-/*! The shared data structure used for inter-VM communication. */
-struct net_accel_shared_page {
-	/*! Sanity check */
-	u32 magic;	    
-	/*! Used by host/Dom0 */
-	struct net_accel_msg_queue queue0;
-	/*! Used by guest/DomU */
-	struct net_accel_msg_queue queue1;
-	/*! Atomic flags, used to communicate simple state changes */
-	u32 aflags;     
-	/*! State of net_dev used for acceleration */     
-	u32 net_dev_up; 
-};
-
-
-enum net_accel_hw_type {
-	/*! Not a virtualisable NIC: use slow path. */
-	NET_ACCEL_MSG_HWTYPE_NONE = 0,
-	/*! NIC is Falcon-based */
-	NET_ACCEL_MSG_HWTYPE_FALCON_A = 1,
-	NET_ACCEL_MSG_HWTYPE_FALCON_B = 2,
-	NET_ACCEL_MSG_HWTYPE_SIENA_A = 3,
-};
-
-/*! The maximum number of pages used by an event queue. */
-#define EF_HW_FALCON_EVQ_PAGES 8
-
-struct net_accel_hw_falcon_b {
-	/* VI */
-	/*! Grant for Tx DMA Q */
-	u32 txdmaq_gnt;   
-	/*! Grant for Rx DMA Q */
-	u32 rxdmaq_gnt;   
-	/*! Machine frame number for Tx/Rx doorbell page */
-	u32 doorbell_mfn; 
-	/*! Grant for Tx/Rx doorbell page */
-	u32 doorbell_gnt;
-
-	/* Event Q */
-	/*! Grants for the pages of the EVQ */
-	u32 evq_mem_gnts[EF_HW_FALCON_EVQ_PAGES]; 
-	u32 evq_offs;
-	/*! log2(pages in event Q) */
-	u32 evq_order;    
-	/*! Capacity in events */
-	u32 evq_capacity; 
-	/*! Eventq pointer register physical address */
-	u32 evq_rptr; 
-	/*! Interface instance */
-	u32 instance; 
-	/*! Capacity of RX queue */
-	u32 rx_capacity;
-	/*! Capacity of TX queue */
-	u32 tx_capacity;
-
-	/* NIC */
-	s32 nic_arch;
-	s32 nic_revision;
-	u8 nic_variant;
-};
-
-struct net_accel_hw_falcon_a {
-	struct net_accel_hw_falcon_b common;
-	u32 evq_rptr_gnt;
-};
-
-
-/*! Description of the hardware that the DomU is being given. */
-struct net_accel_msg_hw {
-	u32 type;		/*!< Hardware type */
-	union {
-		struct net_accel_hw_falcon_a falcon_a;
-		struct net_accel_hw_falcon_b falcon_b;
-	} resources;
-};
-
-/*! Start-of-day handshake message. Dom0 fills in its version and
- * sends, DomU checks, inserts its version and replies
- */
-struct net_accel_msg_hello {
-	/*! Sender's version (set by each side in turn) */
-	u32 version;	
-	/*! max pages allocated/allowed for buffers */
-	u32 max_pages;      
-};
-
-/*! Maximum number of page requests that can fit in a message. */
-#define NET_ACCEL_MSG_MAX_PAGE_REQ (8)
-
-/*! Request for NIC buffers. DomU fils out pages and grants (and
- *  optionally) reqid, dom0 fills out buf and sends reply 
- */
-struct net_accel_msg_map_buffers {
-	u32 reqid;	/*!< Optional request ID */
-	u32 pages;	/*!< Number of pages to map */
-	u32 grants[NET_ACCEL_MSG_MAX_PAGE_REQ];  /*!< Grant ids to map */ 
-	u32 buf;	  /*!< NIC buffer address of pages obtained */
-};
-
-/*! Notification of a change to local mac address, used to filter
-  locally destined packets off the fast path */
-struct net_accel_msg_localmac {
-	u32 flags;	/*!< Should this be added or removed? */
-	u8 mac[ETH_ALEN]; /*!< The mac address to filter onto slow path */
-};
-
-struct net_accel_msg_fastpath {
-	u32 flags;	/*!< Should this be added or removed? */
-	u8  mac[ETH_ALEN];/*!< The mac address to filter onto fast path */
-	u16 port;	 /*!< The port of the connection */
-	u32 ip;	   /*!< The IP address of the connection */
-	u8  proto;	/*!< The protocol of connection (TCP/UDP) */
-};
-
-/*! Values for struct ef_msg_localmac/fastpath.flags */
-#define NET_ACCEL_MSG_ADD    0x1
-#define NET_ACCEL_MSG_REMOVE 0x2
-
-/*! Overall message structure */
-struct net_accel_msg {
-	/*! ID specifying type of messge */
-	u32 id;		     
-	union {
-		/*! handshake */
-		struct net_accel_msg_hello hello;  
-		/*! hardware description */
-		struct net_accel_msg_hw hw;	
-		/*! buffer map request */
-		struct net_accel_msg_map_buffers mapbufs; 
-		/*! mac address of a local interface */
-		struct net_accel_msg_localmac localmac; 
-		/*! address of a new fastpath connection */
-		struct net_accel_msg_fastpath fastpath; 
-		/*! make the message a fixed size */
-		u8 pad[128 - sizeof(u32)]; 
-	}  u;
-};
-
-
-#define NET_ACCEL_MSG_HW_TO_MSG(_u) container_of(_u, struct net_accel_msg, u.hw)
-
-/*! Inter-domain message FIFO */
-typedef struct {
-	struct net_accel_msg *fifo;
-	u32 fifo_mask;
-	u32 *fifo_rd_i;
-	u32 *fifo_wr_i;
-	spinlock_t lock;
-	u32 is_locked; /* Debug flag */
-} sh_msg_fifo2;
-
-
-#define NET_ACCEL_MSG_OFFSET_MASK PAGE_MASK
-
-/* Modifiers */
-#define NET_ACCEL_MSG_REPLY    (0x80000000)
-#define NET_ACCEL_MSG_ERROR    (0x40000000)
-
-/* Dom0 -> DomU and reply. Handshake/version check. */
-#define NET_ACCEL_MSG_HELLO    (0x00000001)
-/* Dom0 -> DomU : hardware setup (VI info.) */
-#define NET_ACCEL_MSG_SETHW    (0x00000002)
-/*
- * Dom0 -> DomU. Notification of a local mac to add/remove from slow
- * path filter
- */
-#define NET_ACCEL_MSG_LOCALMAC (0x00000003)
-/* 
- * DomU -> Dom0 and reply. Request for buffer table entries for
- * preallocated pages.
- */
-#define NET_ACCEL_MSG_MAPBUF   (0x00000004)
-/* 
- * Dom0 -> DomU. Notification of a local mac to add/remove from fast
- * path filter
- */
-#define NET_ACCEL_MSG_FASTPATH (0x00000005)
-
-/*! Initialise a message and set the type
- * \param message : the message
- * \param code : the message type 
- */
-static inline void net_accel_msg_init(struct net_accel_msg *msg, int code) {
-	msg->id = (u32)code;
-}
-
-/*! initialise a shared page structure
- * \param shared_page : mapped memory in which the structure resides
- * \param len : size of the message FIFO area that follows
- * \param up : initial up/down state of netdev 
- * \return 0 or an error code
- */
-extern int net_accel_msg_init_page(void *shared_page, int len, int up);
-
-/*! initialise a message queue 
- * \param queue : the message FIFO to initialise 
- * \param indices : the read and write indices in shared memory
- * \param base : the start of the memory area for the FIFO
- * \param size : the size of the FIFO in bytes
- */
-extern void net_accel_msg_init_queue(sh_msg_fifo2 *queue,
-				     struct net_accel_msg_queue *indices,
-				     struct net_accel_msg *base, int size);
-
-/* Notify after a batch of messages have been sent */
-extern void net_accel_msg_notify(int irq);
-
-/*! Send a message on the specified FIFO. The message is copied to the 
- *  current slot of the FIFO.
- * \param sp : pointer to shared page
- * \param q : pointer to message FIFO to use
- * \param msg : pointer to message 
- * \return 0 on success, -errno on
- */ 
-extern int net_accel_msg_send(struct net_accel_shared_page *sp,
-			      sh_msg_fifo2 *q, 
-			      struct net_accel_msg *msg);
-extern int net_accel_msg_reply(struct net_accel_shared_page *sp,
-			      sh_msg_fifo2 *q, 
-			      struct net_accel_msg *msg);
-
-/*! As net_accel_msg_send but also posts a notification to the far end. */
-extern int net_accel_msg_send_notify(struct net_accel_shared_page *sp, 
-				     int irq, sh_msg_fifo2 *q, 
-				     struct net_accel_msg *msg);
-/*! As net_accel_msg_send but also posts a notification to the far end. */
-extern int net_accel_msg_reply_notify(struct net_accel_shared_page *sp, 
-				      int irq, sh_msg_fifo2 *q, 
-				      struct net_accel_msg *msg);
-
-/*! Receive a message on the specified FIFO. Returns 0 on success,
- *  -errno on failure.
- */
-extern int net_accel_msg_recv(struct net_accel_shared_page *sp,
-			      sh_msg_fifo2 *q,
-			      struct net_accel_msg *msg);
-
-/*! Look at a received message, if any, so a decision can be made
- *  about whether to read it now or not.  Cookie is a bit of debug
- *  which is set here and checked when passed to
- *  net_accel_msg_recv_next()
- */
-extern int net_accel_msg_peek(struct net_accel_shared_page *sp,
-			      sh_msg_fifo2 *queue, 
-			      struct net_accel_msg *msg, int *cookie);
-/*! Move the queue onto the next element, used after finished with a
- *  peeked msg 
- */
-extern int net_accel_msg_recv_next(struct net_accel_shared_page *sp,
-				   sh_msg_fifo2 *queue, int cookie);
-
-/*! Start sending a message without copying. returns a pointer to a
- *  message that will be filled out in place. The queue is locked
- *  until the message is sent.
- */
-extern 
-struct net_accel_msg *net_accel_msg_start_send(struct net_accel_shared_page *sp,
-					       sh_msg_fifo2 *queue,
-					       unsigned long *flags);
-
-
-/*! Complete the sending of a message started with
- *  net_accel_msg_start_send. The message is implicit since the queue
- *  was locked by _start 
- */
-extern void net_accel_msg_complete_send(struct net_accel_shared_page *sp,
-					sh_msg_fifo2 *queue,
-					unsigned long *flags);
-
-/*! As net_accel_msg_complete_send but does the notify. */
-extern void net_accel_msg_complete_send_notify(struct net_accel_shared_page *sp, 
-					       sh_msg_fifo2 *queue,
-					       unsigned long *flags, int irq);
-
-/*! Lock the queue so that multiple "_locked" functions can be called
- *  without the queue being modified by others 
- */
-static inline
-void net_accel_msg_lock_queue(sh_msg_fifo2 *queue, unsigned long *flags)
-{
-	spin_lock_irqsave(&queue->lock, (*flags));
-	rmb();
-	BUG_ON(queue->is_locked);
-	queue->is_locked = 1;
-}
-
-/*! Unlock the queue */
-static inline
-void net_accel_msg_unlock_queue(sh_msg_fifo2 *queue, unsigned long *flags)
-{
-	BUG_ON(!queue->is_locked);
-	queue->is_locked = 0;
-	wmb();
-	spin_unlock_irqrestore(&queue->lock, (*flags));
-}
-
-/*! Give up without sending a message that was started with
- *  net_accel_msg_start_send() 
- */
-static inline 
-void net_accel_msg_abort_send(struct net_accel_shared_page *sp,
-			      sh_msg_fifo2 *queue, unsigned long *flags)
-{
-	net_accel_msg_unlock_queue(queue, flags);
-}
-
-/*! Test the queue to ensure there is sufficient space */
-static inline
-int net_accel_msg_check_space(sh_msg_fifo2 *queue, unsigned space)
-{
-	return sh_fifo2_space(queue) >= space;
-}
-
-#endif /* NET_ACCEL_MSG_IFACE_H */
diff -r 9566a4a50a43 drivers/xen/sfc_netutil/accel_shared_fifo.h
--- a/drivers/xen/sfc_netutil/accel_shared_fifo.h
+++ /dev/null
@@ -1,127 +0,0 @@
-/****************************************************************************
- * Solarflare driver for Xen network acceleration
- *
- * Copyright 2006-2008: Solarflare Communications Inc,
- *                      9501 Jeronimo Road, Suite 250,
- *                      Irvine, CA 92618, USA
- *
- * Maintained by Solarflare Communications <linux-xen-drivers@solarflare.com>
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 as published
- * by the Free Software Foundation, incorporated herein by reference.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
- ****************************************************************************
- */
-
-#ifndef NET_ACCEL_SHARED_FIFO_H
-#define NET_ACCEL_SHARED_FIFO_H
-
-/*
- * This is based on fifo.h, but handles sharing between address spaces
- * that don't trust each other, by splitting out the read and write
- * indices. This costs at least one pointer indirection more than the
- * vanilla version per access.
- */
-
-typedef struct {
-	char*	 fifo;
-	unsigned      fifo_mask;
-	unsigned      *fifo_rd_i;
-	unsigned      *fifo_wr_i;
-} sh_byte_fifo2;
-
-#define SH_FIFO2_M(f, x)     ((x) & ((f)->fifo_mask))
-
-static inline unsigned log2_ge(unsigned long n, unsigned min_order) {
-	unsigned order = min_order;
-	while((1ul << order) < n) ++order;
-	return order;
-}
-
-static inline unsigned long pow2(unsigned order) {
-	return (1ul << order);
-}
-
-#define is_pow2(x)  (pow2(log2_ge((x), 0)) == (x))
-
-#define sh_fifo2_valid(f)  ((f) && (f)->fifo && (f)->fifo_mask > 0 &&   \
-			    is_pow2((f)->fifo_mask+1u))
-
-#define sh_fifo2_init(f, cap, _rptr, _wptr)		\
-	do {						\
-		BUG_ON(!is_pow2((cap) + 1));		\
-		(f)->fifo_rd_i = _rptr;			\
-		(f)->fifo_wr_i = _wptr;			\
-		*(f)->fifo_rd_i = *(f)->fifo_wr_i = 0u; \
-		(f)->fifo_mask = (cap);			\
-	} while(0)
-
-#define sh_fifo2_num(f)      SH_FIFO2_M((f),*(f)->fifo_wr_i - *(f)->fifo_rd_i)
-#define sh_fifo2_space(f)    SH_FIFO2_M((f),*(f)->fifo_rd_i - *(f)->fifo_wr_i-1u)
-#define sh_fifo2_is_empty(f)  (sh_fifo2_num(f)==0)
-#define sh_fifo2_not_empty(f) (sh_fifo2_num(f)!=0)
-#define sh_fifo2_is_full(f)   (sh_fifo2_space(f)==0u)
-#define sh_fifo2_not_full(f)  (sh_fifo2_space(f)!=0u)
-#define sh_fifo2_buf_size(f) ((f)->fifo_mask + 1u)
-#define sh_fifo2_capacity(f) ((f)->fifo_mask)
-#define sh_fifo2_end(f)      ((f)->fifo + sh_fifo2_buf_size(f))
-#define sh_fifo2_not_half_full(f) (sh_fifo2_space(f) > (sh_fifo2_capacity(f) >> 1))
-
-#define sh_fifo2_peek(f)     ((f)->fifo[SH_FIFO2_M((f), *(f)->fifo_rd_i)])
-#define sh_fifo2_peekp(f)    ((f)->fifo + SH_FIFO2_M((f), *(f)->fifo_rd_i))
-#define sh_fifo2_poke(f)     ((f)->fifo[SH_FIFO2_M((f), *(f)->fifo_wr_i)])
-#define sh_fifo2_pokep(f)    ((f)->fifo + SH_FIFO2_M((f), *(f)->fifo_wr_i))
-#define sh_fifo2_peek_i(f,i) ((f)->fifo[SH_FIFO2_M((f), *(f)->fifo_rd_i+(i))])
-#define sh_fifo2_poke_i(f,i) ((f)->fifo[SH_FIFO2_M((f), *(f)->fifo_wr_i+(i))])
-
-#define sh_fifo2_rd_next(f)					\
-	do {*(f)->fifo_rd_i = *(f)->fifo_rd_i + 1u;} while(0)
-#define sh_fifo2_wr_next(f)					\
-	do {*(f)->fifo_wr_i = *(f)->fifo_wr_i + 1u;} while(0)
-#define sh_fifo2_rd_adv(f, n)					\
-	do {*(f)->fifo_rd_i = *(f)->fifo_rd_i + (n);} while(0)
-#define sh_fifo2_wr_adv(f, n)					\
-	do {*(f)->fifo_wr_i = *(f)->fifo_wr_i + (n);} while(0)
-
-#define sh_fifo2_put(f, v)						\
-	do {sh_fifo2_poke(f) = (v); wmb(); sh_fifo2_wr_next(f);} while(0)
-
-#define sh_fifo2_get(f, pv)						\
-	do {*(pv) = sh_fifo2_peek(f); mb(); sh_fifo2_rd_next(f);} while(0)
-
-static inline unsigned sh_fifo2_contig_num(sh_byte_fifo2 *f)
-{
-	unsigned fifo_wr_i = SH_FIFO2_M(f, *f->fifo_wr_i);
-	unsigned fifo_rd_i = SH_FIFO2_M(f, *f->fifo_rd_i);
-
-	return (fifo_wr_i >= fifo_rd_i)
-		? fifo_wr_i - fifo_rd_i
-		: f->fifo_mask + 1u - *(f)->fifo_rd_i;
-}
-
-static inline unsigned sh_fifo2_contig_space(sh_byte_fifo2 *f)
-{
-	unsigned fifo_wr_i = SH_FIFO2_M(f, *f->fifo_wr_i);
-	unsigned fifo_rd_i = SH_FIFO2_M(f, *f->fifo_rd_i);
-
-	return (fifo_rd_i > fifo_wr_i)
-		? fifo_rd_i - fifo_wr_i - 1
-		: (f->fifo_mask + 1u - fifo_wr_i
-		   /*
-		    * The last byte can't be used if the read pointer
-		    * is at zero.
-		    */
-		   - (fifo_rd_i==0));
-}
-
-
-#endif /* NET_ACCEL_SHARED_FIFO_H */
diff -r 9566a4a50a43 drivers/xen/sfc_netutil/accel_util.c
--- a/drivers/xen/sfc_netutil/accel_util.c
+++ /dev/null
@@ -1,333 +0,0 @@
-/****************************************************************************
- * Solarflare driver for Xen network acceleration
- *
- * Copyright 2006-2008: Solarflare Communications Inc,
- *                      9501 Jeronimo Road, Suite 250,
- *                      Irvine, CA 92618, USA
- *
- * Maintained by Solarflare Communications <linux-xen-drivers@solarflare.com>
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 as published
- * by the Free Software Foundation, incorporated herein by reference.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
- ****************************************************************************
- */
-
-#include <linux/if_ether.h>
-#include <asm/io.h>
-#include <asm/pgtable.h>
-#include <asm/hypercall.h>
-#include <xen/xenbus.h>
-#include <xen/driver_util.h>
-#include <xen/gnttab.h>
-
-#include "accel_util.h"
-
-#ifdef EFX_GCOV
-#include "gcov.h"
-
-static int __init net_accel_init(void)
-{
-	gcov_provider_init(THIS_MODULE);
-	return 0;
-}
-module_init(net_accel_init);
-
-static void __exit net_accel_exit(void)
-{
-	gcov_provider_fini(THIS_MODULE);
-}
-module_exit(net_accel_exit);
-#endif
-
-/* Shutdown remote domain that is misbehaving */
-int net_accel_shutdown_remote(int domain)
-{
-	struct sched_remote_shutdown sched_shutdown = {
-		.domain_id = domain,
-		.reason = SHUTDOWN_crash
-	};
-
-	EPRINTK("Crashing domain %d\n", domain);
-
-	return HYPERVISOR_sched_op(SCHEDOP_remote_shutdown, &sched_shutdown);
-}
-EXPORT_SYMBOL(net_accel_shutdown_remote);
-
-
-/* Based on xenbus_backend_client.c:xenbus_map_ring() */
-static int net_accel_map_grant(struct xenbus_device *dev, int gnt_ref,
-			       grant_handle_t *handle, void *vaddr, 
-			       u64 *dev_bus_addr, unsigned flags)
-{
-	struct gnttab_map_grant_ref op;
-	
-	gnttab_set_map_op(&op, (unsigned long)vaddr, flags,
-			  gnt_ref, dev->otherend_id);
-
-	BUG_ON(HYPERVISOR_grant_table_op(GNTTABOP_map_grant_ref, &op, 1));
-
-	if (op.status != GNTST_okay) {
-		xenbus_dev_error
-			(dev, op.status,
-			 "failed mapping in shared page %d from domain %d\n",
-			 gnt_ref, dev->otherend_id);
-	} else {
-		*handle = op.handle;
-		if (dev_bus_addr)
-			*dev_bus_addr = op.dev_bus_addr;
-	}
-
-	return op.status;
-}
-
-
-/* Based on xenbus_backend_client.c:xenbus_unmap_ring() */
-static int net_accel_unmap_grant(struct xenbus_device *dev, 
-				 grant_handle_t handle,
-				 void *vaddr, u64 dev_bus_addr,
-				 unsigned flags)
-{
-	struct gnttab_unmap_grant_ref op;
-
-	gnttab_set_unmap_op(&op, (unsigned long)vaddr, flags, handle);
-	
-	if (dev_bus_addr)
-		op.dev_bus_addr = dev_bus_addr;
-
-	BUG_ON(HYPERVISOR_grant_table_op(GNTTABOP_unmap_grant_ref, &op, 1));
-
-	if (op.status != GNTST_okay)
-		xenbus_dev_error(dev, op.status,
-				 "failed unmapping page at handle %d error %d\n",
-				 handle, op.status);
-
-	return op.status;
-}
-
-
-int net_accel_map_device_page(struct xenbus_device *dev,  
-			      int gnt_ref, grant_handle_t *handle,
-			      u64 *dev_bus_addr)
-{
-	return net_accel_map_grant(dev, gnt_ref, handle, 0, dev_bus_addr,
-				   GNTMAP_device_map);
-}
-EXPORT_SYMBOL_GPL(net_accel_map_device_page);
-
- 
-int net_accel_unmap_device_page(struct xenbus_device *dev,
-				grant_handle_t handle, u64 dev_bus_addr)
-{
-	return net_accel_unmap_grant(dev, handle, 0, dev_bus_addr, 
-				     GNTMAP_device_map);
-}
-EXPORT_SYMBOL_GPL(net_accel_unmap_device_page);
-
-
-struct net_accel_valloc_grant_mapping {
-	struct vm_struct *vm;
-	int pages;
-	grant_handle_t grant_handles[0];
-};
-
-/* Map a series of grants into a contiguous virtual area */
-static void *net_accel_map_grants_valloc(struct xenbus_device *dev, 
-					 unsigned *grants, int npages, 
-					 unsigned flags, void **priv)
-{
-	struct net_accel_valloc_grant_mapping *map;
-	struct vm_struct *vm;
-	void *addr;
-	int i, j, rc;
-
-	vm  = alloc_vm_area(PAGE_SIZE * npages);
-	if (vm == NULL) {
-		EPRINTK("No memory from alloc_vm_area.\n");
-		return NULL;
-	}
-	/* 
-	 * Get a structure in which we will record all the info needed
-	 * to undo the mapping.
-	 */
-	map = kzalloc(sizeof(struct net_accel_valloc_grant_mapping)  + 
-		      npages * sizeof(grant_handle_t), GFP_KERNEL);
-	if (map == NULL) {
-		EPRINTK("No memory for net_accel_valloc_grant_mapping\n");
-		free_vm_area(vm);
-		return NULL;
-	}
-	map->vm = vm;
-	map->pages = npages;
-
-	/* Do the actual mapping */
-	addr = vm->addr;
-	for (i = 0; i < npages; i++) {
-		rc = net_accel_map_grant(dev, grants[i], map->grant_handles + i, 
-					 addr, NULL, flags);
-		if (rc != 0)
-			goto undo;
-		addr = (void*)((unsigned long)addr + PAGE_SIZE);
-	}
-
-	if (priv)
-		*priv = (void *)map;
-	else
-		kfree(map);
-
-	return vm->addr;
-
- undo:
-	EPRINTK("Aborting contig map due to single map failure %d (%d of %d)\n",
-		rc, i+1, npages);
-	for (j = 0; j < i; j++) {
-		addr = (void*)((unsigned long)vm->addr + (j * PAGE_SIZE));
-		net_accel_unmap_grant(dev, map->grant_handles[j], addr, 0,
-				      flags);
-	}
-	free_vm_area(vm);
-	kfree(map);
-	return NULL;
-}
-
-/* Undo the result of the mapping */
-static void net_accel_unmap_grants_vfree(struct xenbus_device *dev, 
-					 unsigned flags, void *priv)
-{
-	struct net_accel_valloc_grant_mapping *map = 
-		(struct net_accel_valloc_grant_mapping *)priv;
-
-	void *addr = map->vm->addr;
-	int npages = map->pages;
-	int i;
-
-	for (i = 0; i < npages; i++) {
-		net_accel_unmap_grant(dev, map->grant_handles[i], addr, 0,
-				      flags);
-		addr = (void*)((unsigned long)addr + PAGE_SIZE);
-	}
-	free_vm_area(map->vm);
-	kfree(map);
-}
-
-
-void *net_accel_map_grants_contig(struct xenbus_device *dev,
-				unsigned *grants, int npages, 
-				void **priv)
-{
-	return net_accel_map_grants_valloc(dev, grants, npages,
-					   GNTMAP_host_map, priv);
-}
-EXPORT_SYMBOL(net_accel_map_grants_contig);
-
-
-void net_accel_unmap_grants_contig(struct xenbus_device *dev,
-				   void *priv)
-{
-	net_accel_unmap_grants_vfree(dev, GNTMAP_host_map, priv);
-}
-EXPORT_SYMBOL(net_accel_unmap_grants_contig);
-
-
-void *net_accel_map_iomem_page(struct xenbus_device *dev, int gnt_ref,
-			     void **priv)
-{
-	return net_accel_map_grants_valloc(dev, &gnt_ref, 1, 
-					   GNTMAP_host_map, priv);
-}
-EXPORT_SYMBOL(net_accel_map_iomem_page);
-
-
-void net_accel_unmap_iomem_page(struct xenbus_device *dev, void *priv)
-{
-	net_accel_unmap_grants_vfree(dev, GNTMAP_host_map, priv);
-}
-EXPORT_SYMBOL(net_accel_unmap_iomem_page);
-
-
-int net_accel_grant_page(struct xenbus_device *dev, unsigned long mfn, 
-			 int is_iomem)
-{
-	int err = gnttab_grant_foreign_access(dev->otherend_id, mfn,
-					      is_iomem ? GTF_PCD : 0);
-	if (err < 0)
-		xenbus_dev_error(dev, err, "failed granting access to page\n");
-	return err;
-}
-EXPORT_SYMBOL_GPL(net_accel_grant_page);
-
-
-int net_accel_ungrant_page(grant_ref_t gntref)
-{
-	if (unlikely(gnttab_query_foreign_access(gntref) != 0)) {
-		EPRINTK("%s: remote domain still using grant %d\n", __FUNCTION__, 
-			gntref);
-		return -EBUSY;
-	}
-
-	gnttab_end_foreign_access(gntref, 0);
-	return 0;
-}
-EXPORT_SYMBOL_GPL(net_accel_ungrant_page);
-
-
-int net_accel_xen_net_read_mac(struct xenbus_device *dev, u8 mac[])
-{
-	char *s, *e, *macstr;
-	int i;
-
-	macstr = s = xenbus_read(XBT_NIL, dev->nodename, "mac", NULL);
-	if (IS_ERR(macstr))
-		return PTR_ERR(macstr);
-
-	for (i = 0; i < ETH_ALEN; i++) {
-		mac[i] = simple_strtoul(s, &e, 16);
-		if ((s == e) || (*e != ((i == ETH_ALEN-1) ? '\0' : ':'))) {
-			kfree(macstr);
-			return -ENOENT;
-		}
-		s = e+1;
-	}
-
-	kfree(macstr);
-	return 0;
-}
-EXPORT_SYMBOL_GPL(net_accel_xen_net_read_mac);
-
-
-void net_accel_update_state(struct xenbus_device *dev, int state)
-{
-	struct xenbus_transaction tr;
-	int err;
-
-	DPRINTK("%s: setting accelstate to %s\n", __FUNCTION__,
-		xenbus_strstate(state));
-
-	if (xenbus_exists(XBT_NIL, dev->nodename, "")) {
-		VPRINTK("%s: nodename %s\n", __FUNCTION__, dev->nodename);
-	again:
-		err = xenbus_transaction_start(&tr);
-		if (err == 0)
-			err = xenbus_printf(tr, dev->nodename, "accelstate",
-					    "%d", state);
-		if (err != 0) {
-			xenbus_transaction_end(tr, 1);
-		} else {
-			err = xenbus_transaction_end(tr, 0);
-			if (err == -EAGAIN)
-				goto again;
-		}
-	}
-}
-EXPORT_SYMBOL_GPL(net_accel_update_state);
-
-MODULE_LICENSE("GPL");
diff -r 9566a4a50a43 drivers/xen/sfc_netutil/accel_util.h
--- a/drivers/xen/sfc_netutil/accel_util.h
+++ /dev/null
@@ -1,124 +0,0 @@
-/****************************************************************************
- * Solarflare driver for Xen network acceleration
- *
- * Copyright 2006-2008: Solarflare Communications Inc,
- *                      9501 Jeronimo Road, Suite 250,
- *                      Irvine, CA 92618, USA
- *
- * Maintained by Solarflare Communications <linux-xen-drivers@solarflare.com>
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 as published
- * by the Free Software Foundation, incorporated herein by reference.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
- ****************************************************************************
- */
-
-#ifndef NETBACK_ACCEL_UTIL_H
-#define NETBACK_ACCEL_UTIL_H
-
-#ifdef DPRINTK
-#undef DPRINTK
-#endif
-
-#define FILE_LEAF strrchr(__FILE__, '/') ? strrchr(__FILE__, '/') + 1 : __FILE__
-
-#if 1
-#define VPRINTK(_f, _a...) 
-#else
-#define VPRINTK(_f, _a...)			\
-	printk("(file=%s, line=%d) " _f,	\
-	       FILE_LEAF , __LINE__ , ## _a )
-#endif
-
-#if 1
-#define DPRINTK(_f, _a...) 
-#else
-#define DPRINTK(_f, _a...)			\
-	printk("(file=%s, line=%d) " _f,	\
-	       FILE_LEAF , __LINE__ , ## _a )
-#endif
-
-#define EPRINTK(_f, _a...)			\
-	printk("(file=%s, line=%d) " _f,	\
-	       FILE_LEAF , __LINE__ , ## _a )
-
-#define EPRINTK_ON(exp)							\
-	do {								\
-		if (exp)						\
-			EPRINTK("%s at %s:%d\n", #exp, __FILE__, __LINE__); \
-	} while(0)
-
-#define DPRINTK_ON(exp)							\
-	do {								\
-		if (exp)						\
-			DPRINTK("%s at %s:%d\n", #exp, __FILE__, __LINE__); \
-	} while(0)
-
-#include <xen/xenbus.h>
-
-/*! Map a set of pages from another domain
- * \param dev The xenbus device context
- * \param priv The private data returned by the mapping function 
- */
-extern 
-void *net_accel_map_grants_contig(struct xenbus_device *dev, 
-				  unsigned *grants, int npages, 
-				  void **priv);
-
-/*! Unmap a set of pages mapped using net_accel_map_grants_contig.
- * \param dev The xenbus device context
- * \param priv The private data returned by the mapping function 
- */
-extern 
-void net_accel_unmap_grants_contig(struct xenbus_device *dev, void *priv);
-
-/*! Read the MAC address of a device from xenstore */
-extern
-int net_accel_xen_net_read_mac(struct xenbus_device *dev, u8 mac[]);
-
-/*! Update the accelstate field for a device in xenstore */
-extern
-void net_accel_update_state(struct xenbus_device *dev, int state);
-
-/* These four map/unmap functions are based on
- * xenbus_backend_client.c:xenbus_map_ring().  However, they are not
- * used for ring buffers, instead just to map pages between domains,
- * or to map a page so that it is accessible by a device
- */
-extern
-int net_accel_map_device_page(struct xenbus_device *dev,  
-			      int gnt_ref, grant_handle_t *handle,
-			      u64 *dev_bus_addr);
-extern
-int net_accel_unmap_device_page(struct xenbus_device *dev,
-				grant_handle_t handle, u64 dev_bus_addr);
-extern
-void *net_accel_map_iomem_page(struct xenbus_device *dev, int gnt_ref,
-			     void **priv);
-extern
-void net_accel_unmap_iomem_page(struct xenbus_device *dev, void *priv);
-
-/*! Grrant a page to remote domain */
-extern
-int net_accel_grant_page(struct xenbus_device *dev, unsigned long mfn, 
-			 int is_iomem);
-/*! Undo a net_accel_grant_page */
-extern
-int net_accel_ungrant_page(grant_ref_t gntref);
-
-
-/*! Shutdown remote domain that is misbehaving */
-extern
-int net_accel_shutdown_remote(int domain);
-
-
-#endif
